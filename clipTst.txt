# file opened: clipTst.asm
  1   0000               DEVICE ZXSPECTRUMNEXT
  2   0000               DEVICE ZXSPECTRUMNEXT
  3   0000               CSPECTMAP eliteNext.map
  4   0000               OPT --zxnext=cspect --syntax=a
  5   0000
  6   0000              DEBUGSEGSIZE   equ 1
  7   0000              DEBUGLOGSUMMARY equ 1
  8   0000              ;DEBUGLOGDETAIL equ 1
  9   0000
 10   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 11   0000              ; Game Defines
 12   0000              ScreenLocal     EQU 0
 13   0000              ScreenGalactic  EQU ScreenLocal + 1
 14   0000              ScreenMarket    EQU ScreenGalactic + 1
 15   0000              ScreenMarketDsp EQU ScreenMarket + 1
 16   0000              ScreenStatus    EQU ScreenMarketDsp + 1
 17   0000              ScreenInvent    EQU ScreenStatus + 1
 18   0000              ScreenPlanet    EQU ScreenInvent + 1
 19   0000              ScreenEquip     EQU ScreenPlanet + 1
 20   0000              ScreenLaunch    EQU ScreenEquip + 1
 21   0000              ScreenFront     EQU ScreenLaunch + 1
 22   0000              ScreenAft       EQU ScreenFront+1
 23   0000              ScreenLeft      EQU ScreenAft+2
 24   0000              ScreenRight     EQU ScreenLeft+3
 25   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 26   0000              ; Colour Defines
 27   0000                  INCLUDE "./Hardware/L2ColourDefines.asm"
# file opened: ./Hardware/L2ColourDefines.asm
  1+  0000              L2ColourBLACK           EQU   0
  2+  0000              L2ColourRED             EQU 224
  3+  0000              L2ColourRED_MED         EQU 128
  4+  0000              L2ColourRED_DRK         EQU  32
  5+  0000              L2ColourRED_1           EQU L2ColourRED_MED
  6+  0000              L2ColourRED_2           EQU  96
  7+  0000              L2ColourRED_3           EQU  64
  8+  0000              L2ColourRED_4           EQU L2ColourRED_DRK
  9+  0000              L2ColourDARK_RED        EQU L2ColourRED_DRK
 10+  0000              L2ColourYELLOW          EQU 252
 11+  0000              L2ColourYELLOW_MED      EQU 144
 12+  0000              L2ColourYELLOW_DRK      EQU  72
 13+  0000              L2ColourYELLOW_1	    EQU L2ColourYELLOW_MED
 14+  0000              L2ColourYELLOW_2        EQU L2ColourYELLOW_DRK
 15+  0000              L2ColourGREEN           EQU  29
 16+  0000              L2ColourGREEN_MED       EQU  16
 17+  0000              L2ColourGREEN_DRK       EQU   8
 18+  0000              L2ColourGREEN_1		    EQU L2ColourGREEN
 19+  0000              L2ColourGREEN_2		    EQU L2ColourGREEN_MED
 20+  0000              L2ColourGREEN_3		    EQU L2ColourGREEN_DRK
 21+  0000              L2ColourWHITE           EQU 255
 22+  0000              L2ColourWHITE_MED       EQU 146
 23+  0000              L2ColourWHITE_DRK       EQU  73
 24+  0000              L2ColourWHITE_1         EQU L2ColourWHITE_MED
 25+  0000              L2ColourWHITE_2         EQU L2ColourWHITE_DRK
 26+  0000              L2ColourGREY_1		    EQU 146
 27+  0000              L2ColourGREY_2		    EQU 109
 28+  0000              L2ColourGREY_3		    EQU  73
 29+  0000              L2ColourGREY_4		    EQU  37
 30+  0000              L2ColourMAGENTA         EQU 218
 31+  0000              L2ColourMAGENTA_MED     EQU 130
 32+  0000              L2ColourMAGENTA_DRK     EQU  65
 33+  0000              L2ColourORANGE          EQU 236
 34+  0000              L2ColourORANGE_MED      EQU 168
 35+  0000              L2ColourORANGE_DRK      EQU  68
 36+  0000              L2ColourBLUE            EQU   3
 37+  0000              L2ColourBLUE_MED        EQU   2
 38+  0000              L2ColourBLUE_DRK        EQU   1
 39+  0000              L2ColourBLUE_1          EQU 111
 40+  0000              L2ColourBLUE_2		    EQU  39
 41+  0000              L2ColourBLUE_3		    EQU L2ColourBLUE_MED
 42+  0000              L2ColourBLUE_4		    EQU L2ColourBLUE_DRK
 43+  0000              L2ColourCYAN            EQU  31
 44+  0000              L2ColourCYAN_MED        EQU  18
 45+  0000              L2ColourCYAN_DRK        EQU   9
 46+  0000              L2ColourPURPLE          EQU 109
 47+  0000              L2ColourPURPLE_MED      EQU  66
 48+  0000              L2ColourPURPLE_DRK      EQU  33
 49+  0000              L2ColourPINK_1		    EQU 231
 50+  0000              L2ColourPINK_2		    EQU 226
 51+  0000              L2ColourPINK_3		    EQU 225
 52+  0000              L2ColourPINK_4		    EQU 224
 53+  0000              L2ColourTRANSPARENT     EQU $E3
 54+  0000
# file closed: ./Hardware/L2ColourDefines.asm
 28   0000                  INCLUDE "./Hardware/L1ColourDefines.asm"
# file opened: ./Hardware/L1ColourDefines.asm
  1+  0000
  2+  0000              L1ColourInkBlack        EQU %00000000
  3+  0000              L1ColourInkBlue         EQU %00000001
  4+  0000              L1ColourInkRed          EQU %00000010
  5+  0000              L1ColourInkMagenta      EQU %00000011
  6+  0000              L1ColourInkGreen        EQU %00000100
  7+  0000              L1ColourInkCyan         EQU %00000101
  8+  0000              L1ColourInkYellow       EQU %00000110
  9+  0000              L1ColourInkWhite        EQU %00000111
 10+  0000              L1ColourPaperBlack      EQU %00000000
 11+  0000              L1ColourPaperBlue       EQU %00001000
 12+  0000              L1ColourPaperRed        EQU %00010000
 13+  0000              L1ColourPaperMagenta    EQU %00011000
 14+  0000              L1ColourPaperGreen      EQU %00100000
 15+  0000              L1ColourPaperCyan       EQU %00101000
 16+  0000              L1ColourPaperYellow     EQU %00110000
 17+  0000              L1ColourPaperWhite      EQU %00111000
 18+  0000              L1ColourFlash           EQU %10000000
 19+  0000              L1ColourBright          EQU %01000000
 20+  0000              ;----------------------------------------------------------------------------------------------------------------------------------
 21+  0000              ; Screen Specific Colour Defines
 22+  0000              L1InvHighlight          EQU L1ColourBright | L1ColourPaperRed   | L1ColourInkYellow
 23+  0000              L1InvLowlight           EQU                  L1ColourPaperBlack | L1ColourInkWhite
# file closed: ./Hardware/L1ColourDefines.asm
 29   0000
 30   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 31   0000
 32   0000                  INCLUDE "./Hardware/register_defines.asm"
# file opened: ./Hardware/register_defines.asm
  1+  0000              IO_LAYER2_PORT                          EQU $123B
  2+  0000              IO_EXT_BANK_PORT 			            EQU $DFFD ; 57341
  3+  0000              IO_BANK_PORT                            EQU $7FFD ; 32765
  4+  0000              REGISTER_NUMBER_PORT					EQU $243B
  5+  0000              REGISTER_VALUE_PORT						EQU $253B
  6+  0000              SPRITE_SLOT_PORT						EQU $303B
  7+  0000              SPRITE_INFO_PORT                        EQU $0057
  8+  0000              SPRITE_PATTERN_UPLOAD_PORT				EQU $005B
  9+  0000
 10+  0000              MACHINE_ID_REGISTER						EQU 0
 11+  0000              VERSION_REGISTER						EQU 1
 12+  0000              RESET_REGISTER		    				EQU 2
 13+  0000              MACHINE_TYPE_REGISTER					EQU 3
 14+  0000              PAGE_RAM_REGISTER						EQU 4
 15+  0000              PERIPHERAL_1_REGISTER					EQU 5
 16+  0000              PERIPHERAL_2_REGISTER					EQU 6
 17+  0000              TURBO_MODE_REGISTER						EQU 7
 18+  0000              PERIPHERAL_3_REGISTER					EQU 8
 19+  0000              ANTI_BRICK_SYSTEM_REGISTER				EQU 10
 20+  0000              LAYER2_RAM_PAGE_REGISTER				EQU 18
 21+  0000              LAYER2_RAM_SHADOW_REGISTER      		EQU 19
 22+  0000              TRANSPARENCY_COLOUR_REGISTER			EQU 20
 23+  0000              SPRITE_LAYERS_SYSTEM_REGISTER			EQU 21
 24+  0000              LAYER2_OFFSET_X_REGISTER				EQU 22
 25+  0000              LAYER2_OFFSET_Y_REGISTER				EQU 23
 26+  0000              CLIP_WINDOW_LAYER2_REGISTER				EQU 24
 27+  0000              CLIP_WINDOW_SPRITES_REGISTER			EQU 25
 28+  0000              CLIP_WINDOW_ULA_REGISTER				EQU 26
 29+  0000              CLIP_WINDOW_CONTROL_REGISTER			EQU 28
 30+  0000              ACTIVE_VIDEO_LINE_MSB_REGISTER			EQU 30
 31+  0000              ACTIVE_VIDEO_LINE_LSB_REGISTER			EQU 31
 32+  0000              LINE_INTERRUPT_CONTROL_REGISTER			EQU 34
 33+  0000              LINE_INTERRUPT_VALUE_LSB_REGISTER		EQU 35
 34+  0000              KEYMAP_HIGH_ADDRESS_REGISTER			EQU 40
 35+  0000              KEYMAP_LOW_ADDRESS_REGISTER				EQU 41
 36+  0000              KEYMAP_HIGH_DATA_REGISTER				EQU 42
 37+  0000              KEYMAP_LOW_DATA_REGISTER				EQU 43
 38+  0000              DAC_B_MIRROR_REGISTER                   EQU 44
 39+  0000              DAC_AB_MIRROR_REGISTER                  EQU 45
 40+  0000              DAC_C_MORROR_REGISTER                   EQU 46
 41+  0000              TILEMAP_OFFSET_XMSB_REGISTER            EQU 47
 42+  0000              TILEMAP_OFFSET_XLSB_REGISTER            EQU 48
 43+  0000              TILEMAP_OFFSET_YMSB_REGISTER            EQU 49
 44+  0000              LORES_OFFSET_X_REGISTER					EQU 50
 45+  0000              LORES_OFFSET_Y_REGISTER					EQU 51
 46+  0000              SPRITE_PORT_INDEX_REGISTER              EQU 52
 47+  0000              SPRITE_PORT_ATTR0_REGISTER              EQU 53
 48+  0000              SPRITE_PORT_ATTR1_REGISTER              EQU 54
 49+  0000              SPRITE_PORT_ATTR2_REGISTER              EQU 55
 50+  0000              SPRITE_PORT_ATTR3_REGISTER              EQU 56
 51+  0000              SPRITE_PORT_ATTR4_REGISTER              EQU 57
 52+  0000              PALETTE_INDEX_REGISTER					EQU 64
 53+  0000              PALETTE_VALUE_8BIT_REGISTER				EQU 65
 54+  0000              PALETTE_FORMAT_REGISTER					EQU 66
 55+  0000              PALETTE_CONTROL_REGISTER				EQU 67
 56+  0000              PALETTE_VALUE_9BIT_REGISTER				EQU 68
 57+  0000              MMU_SLOT_0_REGISTER						EQU 80
 58+  0000              MMU_SLOT_1_REGISTER						EQU 81
 59+  0000              MMU_SLOT_2_REGISTER						EQU 82
 60+  0000              MMU_SLOT_3_REGISTER						EQU 83
 61+  0000              MMU_SLOT_4_REGISTER						EQU 84
 62+  0000              MMU_SLOT_5_REGISTER						EQU 85
 63+  0000              MMU_SLOT_6_REGISTER						EQU 86
 64+  0000              MMU_SLOT_7_REGISTER						EQU 87
 65+  0000              COPPER_DATA_REGISTER					EQU 96
 66+  0000              COPPER_CONTROL_LOW_REGISTER				EQU 97
 67+  0000              COPPER_CONTROL_HIGH_REGISTER			EQU 98
 68+  0000              DISPLAY_CONTROL_1_REGISTER              EQU 105
 69+  0000              LAYER_2_CONTROL_REGISTER                EQU 112
 70+  0000              LAYER_2_X_OFFSET_MSB_REGISTER           EQU 113
 71+  0000              DEBUG_LEDS_REGISTER						EQU 255
 72+  0000
 73+  0000
 74+  0000              GetNextReg:	MACRO register
 75+  0000 ~                        push bc
 76+  0000 ~                            ld bc,$243B
 77+  0000 ~                                ld a,register
 78+  0000 ~                                out (c),a
 79+  0000 ~                                inc b
 80+  0000 ~                            in a,(c)
 81+  0000 ~                        pop bc
 82+  0000                          ENDM
 83+  0000
# file closed: ./Hardware/register_defines.asm
 33   0000                  INCLUDE "./Layer2Graphics/layer2_defines.asm"
# file opened: ./Layer2Graphics/layer2_defines.asm
  1+  0000
  2+  0000
  3+  0000              LAYER2_SHIFTED_SCREEN_TOP  	 equ 0
  4+  0000              LAYER2_SHIFTED_SCREEN_MIDDLE equ $40
  5+  0000              LAYER2_SHIFTED_SCREEN_BOTTOM equ $80
  6+  0000
  7+  0000              ; note hi byte is not decoded on DMA port so can out OUTIR
  8+  0000              IO_DATAGEAR_DMA_PORT 		 equ 107
  9+  0000              IO_SPRITE_SLOT_PORT 		 equ 12347
 10+  0000              IO_SPRITE_PATTERN_PORT       equ 91
 11+  0000              IO_SPRITE_ATTRIBUTES_PORT    equ 87
 12+  0000
 13+  0000              LAYER2_VISIBLE_MASK 		equ $02
 14+  0000              ; DEBUG 0 for always write to primary 08 for double buffering
 15+  0000                  IFDEF DOUBLEBUFFER
 16+  0000 ~            LAYER2_SHADOW_SCREEN_MASK 	equ $08
 17+  0000                  ELSE
 18+  0000              LAYER2_SHADOW_SCREEN_MASK 	equ $00
 19+  0000                  ENDIF
 20+  0000              LAYER2_WRITE_ENABLE_MASK 	equ $01
 21+  0000              LAYER2_SCREEN_SECTION_MASK 	equ $03
 22+  0000              LAYER2_SCREEN_SECTION_SHIFT equ 6
 23+  0000
 24+  0000              LAYER2_SCREEN_BANK1          equ 8
 25+  0000              LAYER2_SCREEN_BANK2          equ 9
 26+  0000              LAYER2_SCREEN_BANK3          equ 10
 27+  0000              LAYER2_SHADOW_BANK1          equ 11
 28+  0000              LAYER2_SHADOW_BANK2          equ 12
 29+  0000              LAYER2_SHADOW_BANK3          equ 13
 30+  0000
 31+  0000              SCREEN_HEIGHT 				 equ 192
 32+  0000              SCREEN_RAM_BASE				 equ $0000
 33+  0000              SCREEN_HOZ_MIN_PIX		     equ 10
 34+  0000
 35+  0000              SPRITES_VISIBLE_MASK         equ $01
 36+  0000              SPRITES_ON_BORDER_MASK       equ $02
 37+  0000              LAYER_PRIORITIES_MASK        equ $07
 38+  0000              LORES_MODE_MASK              equ $80
 39+  0000              LAYER_PRIORITIES_SHIFT       equ 2
 40+  0000
 41+  0000              LAYER_PRIORITIES_S_L_U 		equ 0
 42+  0000              LAYER_PRIORITIES_L_S_U 		equ 1
 43+  0000              LAYER_PRIORITIES_S_U_L  	equ 2
 44+  0000              LAYER_PRIORITIES_L_U_S 		equ 3
 45+  0000              LAYER_PRIORITIES_U_S_L 		equ 4
 46+  0000              LAYER_PRIORITIES_U_L_S 		equ 5
 47+  0000
 48+  0000              DMA_WRO_BLOCK_PORTA_A2B_XFR  equ $7D
 49+  0000              DMA_WRO_BLOCK_PORTA_B2A_XFR  equ $79
 50+  0000              DMA_WR1_P1FIXED_MEMORY       equ $24
 51+  0000              DMA_WR1_P1DEC_MEMORY         equ $04
 52+  0000              DMA_WR1_P1INC_MEMORY         equ $14
 53+  0000              DMA_WR2_P2FIXED_MEMORY       equ $20
 54+  0000              DMA_WR2_P2DEC_MEMORY         equ $00
 55+  0000              DMA_WR2_P2INC_MEMORY         equ $10
 56+  0000              DMA_WR4_CONT_MODE            equ $AD
 57+  0000              DMA_RESET                    equ $c3
 58+  0000              DMA_RESET_PORT_A_TIMING      equ $c7
 59+  0000              DMA_RESET_PORT_B_TIMING      equ $cb
 60+  0000              DMA_LOAD                     equ $cf
 61+  0000              DMA_CONTINUE                 equ $d3
 62+  0000              DMA_DISABLE_INTERUPTS        equ $af
 63+  0000              DMA_ENABLE_INTERUPTS         equ $ab
 64+  0000              DMA_RESET_DISABLE_INTERUPTS  equ $a3
 65+  0000              DMA_ENABLE_AFTER_RETI        equ $b7
 66+  0000              DMA_READ_STATUS_BYTE         equ $bf
 67+  0000              DMA_REINIT_STATUS_BYTE       equ $8b
 68+  0000              DMA_START_READ_SEQUENCE      equ $a7
 69+  0000              DMA_FORCE_READY              equ $b3
 70+  0000              DMA_STOP_AT_END			     equ $82
 71+  0000              DMA_DISABLE                  equ $83
 72+  0000              DMA_ENABLE                   equ $87
 73+  0000              DMA_WRITE_REGISTER_COMMAND   equ $bb
 74+  0000              DMA_BURST                    equ $cd
 75+  0000              DMA_CONTINUOUS               equ $ad
 76+  0000              ZXN_DMA_PORT                 equ $6b
 77+  0000
 78+  0000
 79+  0000              COLOUR_TRANSPARENT			 equ $E3
 80+  0000
 81+  0000
 82+  0000
 83+  0000
# file closed: ./Layer2Graphics/layer2_defines.asm
 34   0000                  INCLUDE	"./Hardware/memory_bank_defines.asm"
# file opened: ./Hardware/memory_bank_defines.asm
  1+  0000
  2+  0000              membanksize			    equ	$1FFF
  3+  0000
  4+  0000              StartOfBank     	    equ $0000
  5+  0000
  6+  0000              membank0 			    equ $0000
  7+  0000              dmaCopySrcAddr		    equ	$0000
  8+  0000              membank1 			    equ $2000
  9+  0000              membank2 			    equ $4000
 10+  0000              membank3 			    equ $6000
 11+  0000              membank4 			    equ $8000
 12+  0000              membank5 			    equ $a000
 13+  0000              membank6 			    equ $c000
 14+  0000              ScreenBank              equ $c000
 15+  0000              MenuGalChtAddr          equ $c000
 16+  0000              MenuEquipSAddr          equ $c000
 17+  0000              MenuInventAddr          equ $c000
 18+  0000              MenuMarketAddr          equ $c000
 19+  0000              DispMarketAddr          equ $c000
 20+  0000              MenuShrChtAddr          equ $c000
 21+  0000              MenuStatusAddr          equ $c000
 22+  0000              MenuSystemAddr          equ $c000
 23+  0000              ViewFrontAddr           equ $c000
 24+  0000              UniverseBankAddr	    equ $c000
 25+  0000              LaunchShipAddr          equ $c000
 26+  0000              membank7 			    equ $e000
 27+  0000              L1membankAddr   	    equ $e000
 28+  0000              L2membankAddr   	    equ $e000
 29+  0000              ShipModelsAddr	        equ $e000
 30+  0000              SpritemembankAddr       equ $e000
 31+  0000              ResetUniverseAddr       equ $e000
 32+  0000              StockTableAddr	        equ $e000
 33+  0000              CMDRDATAAddr            equ $e000
 34+  0000              LAYER2Addr              equ $e000
 35+  0000              LAYER1Addr              equ $e000
 36+  0000              SPRITEAddr              equ $e000
 37+  0000              ConsoleImageAddr        equ $e000
 38+  0000              GalaxyDataAddr          equ $e000
 39+  0000
 40+  0000              DMACpySourceMMU		    equ	MMU_SLOT_0_REGISTER
 41+  0000              UniverseMMU 		    equ MMU_SLOT_6_REGISTER
 42+  0000              ScreenBankMMU           equ MMU_SLOT_6_REGISTER
 43+  0000              MenuEquipSMMU           equ MMU_SLOT_6_REGISTER
 44+  0000              MenuShrChtMMU           equ MMU_SLOT_6_REGISTER
 45+  0000              MenuGalChtMMU           equ MMU_SLOT_6_REGISTER
 46+  0000              MenuInventMMU           equ MMU_SLOT_6_REGISTER
 47+  0000              MenuSystemMMU           equ MMU_SLOT_6_REGISTER
 48+  0000              MenuMarketMMU           equ MMU_SLOT_6_REGISTER
 49+  0000              DispMarketMMU           equ MMU_SLOT_6_REGISTER
 50+  0000              MenuStatusMMU           equ MMU_SLOT_6_REGISTER
 51+  0000              LaunchShipMMU           equ MMU_SLOT_6_REGISTER
 52+  0000              L1memMMU       		    equ MMU_SLOT_7_REGISTER
 53+  0000              L2memMMU       		    equ MMU_SLOT_7_REGISTER
 54+  0000              SpritememMMU   		    equ MMU_SLOT_7_REGISTER
 55+  0000              ShipModelMMU  		    equ MMU_SLOT_7_REGISTER
 56+  0000              ResetUniverseMMU	    equ MMU_SLOT_7_REGISTER
 57+  0000              CmdrDataMMU			    equ MMU_SLOT_7_REGISTER
 58+  0000              StockTableMMU		    equ MMU_SLOT_7_REGISTER
 59+  0000              ConsoleImageDataMMU	    equ MMU_SLOT_7_REGISTER
 60+  0000              GalaxyDataMMU	        equ MMU_SLOT_7_REGISTER
 61+  0000
 62+  0000              BankResetUniv           equ 49
 63+  0000              BankMenuShrCht          equ 50
 64+  0000              BankMenuGalCht          equ 51
 65+  0000              BankMenuInvent          equ 52
 66+  0000              BankMenuSystem          equ 53
 67+  0000              BankMenuMarket          equ 54
 68+  0000              BankStockTable          equ 55
 69+  0000              BankCmdrData            equ 56
 70+  0000              BankLAYER2              equ 57
 71+  0000              BankLAYER1              equ 58
 72+  0000              BankShipModelsA         equ 59
 73+  0000              BankSPRITE              equ 60
 74+  0000              BankConsole             equ 61
 75+  0000              BankFrontView           equ 62
 76+  0000              BankMenuStatus          equ 63
 77+  0000              BankMenuEquipS          equ 64
 78+  0000              BankLaunchShip          equ 65
 79+  0000              BankDispMarket          equ 66
 80+  0000              BankShipModelsB         equ 67
 81+  0000              BankShipModelsC         equ 68
 82+  0000
 83+  0000              BankUNIVDATA0           equ 70
 84+  0000              BankUNIVDATA1           equ 71
 85+  0000              BankUNIVDATA2           equ 72
 86+  0000              BankUNIVDATA3           equ 73
 87+  0000              BankUNIVDATA4           equ 74
 88+  0000              BankUNIVDATA5           equ 75
 89+  0000              BankUNIVDATA6           equ 76
 90+  0000              BankUNIVDATA7           equ 77
 91+  0000              BankUNIVDATA8           equ 78
 92+  0000              BankUNIVDATA9           equ 79
 93+  0000              BankUNIVDATA10          equ 80
 94+  0000              BankUNIVDATA11          equ 81
 95+  0000              BankUNIVDATA12          equ 82
 96+  0000
 97+  0000              BankGalaxyData0         equ 91
 98+  0000              BankGalaxyData1         equ 92
 99+  0000              BankGalaxyData2         equ 93
100+  0000              BankGalaxyData3         equ 94
101+  0000              BankGalaxyData4         equ 95
102+  0000              BankGalaxyData5         equ 96
103+  0000              BankGalaxyData6         equ 97
104+  0000              BankGalaxyData7         equ 98
105+  0000
# file closed: ./Hardware/memory_bank_defines.asm
 35   0000                  INCLUDE "./Hardware/screen_equates.asm"
# file opened: ./Hardware/screen_equates.asm
  1+  0000              ScreenHeight 		equ 192
  2+  0000              ScreenLastRow       equ ScreenHeight -1
  3+  0000              ScreenWidth  		equ 256
  4+  0000              ScreenLastCol       equ ScreenWidth -1
  5+  0000              ScreenHeightHalf	equ 96
  6+  0000              ScreenWidthHalf  	equ 128
  7+  0000              ScreenCenterY		equ 96
  8+  0000              ScreenCenterX       equ 128
  9+  0000              ViewHeight          equ 128
 10+  0000              ViewHeightPlus1     equ 128+1
 11+  0000              ViewLastRow       	equ ViewHeight -1
 12+  0000              ViewWidth  			equ 256
 13+  0000              ViewLastCol         equ ViewWidth -1
 14+  0000              ViewHeightHalf      equ 63
 15+  0000              ViewWidthHalf       equ 127
 16+  0000              ViewCenterY         equ 64
 17+  0000              ViewCenterX         equ 128
 18+  0000              ShipColour			equ $FF		; place holder for debugging TODO
 19+  0000              ScreenL1Bottom      equ $5000
 20+  0000              ScreenL1BottomLen   equ 32 * 8 * 8
 21+  0000              ScreenL1AttrBtm     equ $5A00
 22+  0000              ScreenL1AttrBtmLen  equ 32 * 8
 23+  0000
# file closed: ./Hardware/screen_equates.asm
 36   0000
 37   0000                  INCLUDE "./Macros/MMUMacros.asm"
# file opened: ./Macros/MMUMacros.asm
  1+  0000              MMUSelectSpriteBank: MACRO
  2+  0000 ~            					 nextreg SpritememMMU,	    BankSPRITE
  3+  0000              					 ENDM
  4+  0000
  5+  0000              MMUSelectConsoleBank: MACRO
  6+  0000 ~            					 nextreg ConsoleImageDataMMU,  BankConsole
  7+  0000              					 ENDM
  8+  0000
  9+  0000              MMUSelectLayer1: 	 MACRO
 10+  0000 ~            					 nextreg L1memMMU,		    BankLAYER1
 11+  0000              					 ENDM
 12+  0000
 13+  0000              MMUSelectLayer2: 	 MACRO
 14+  0000 ~            					 nextreg L2memMMU,		    BankLAYER2
 15+  0000              					 ENDM
 16+  0000
 17+  0000              MMUSelectResetUniv:  MACRO
 18+  0000 ~                                 nextreg  ResetUniverseMMU, BankResetUniv
 19+  0000                                   ENDM
 20+  0000
 21+  0000              MMUSelectShipModelsA: MACRO
 22+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModelsA
 23+  0000              					 ENDM
 24+  0000              MMUSelectShipModelsB: MACRO
 25+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModelsB
 26+  0000              					 ENDM
 27+  0000              MMUSelectShipModelsC: MACRO
 28+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModelsC
 29+  0000              					 ENDM
 30+  0000
 31+  0000              MMUSelectShipModelA: MACRO
 32+  0000 ~            					 nextreg ShipModelMMU,	    a
 33+  0000              					 ENDM
 34+  0000
 35+  0000              MMUSelectShipModelN: MACRO value
 36+  0000 ~            					 nextreg ShipModelMMU,	    value
 37+  0000              					 ENDM
 38+  0000
 39+  0000              MMUSelectCmdrData:	 MACRO
 40+  0000 ~                                 nextreg CmdrDataMMU,       BankCmdrData
 41+  0000              					 ENDM
 42+  0000
 43+  0000              MMUSelectStockTable: MACRO
 44+  0000 ~                                 nextreg StockTableMMU,     BankStockTable
 45+  0000              					 ENDM
 46+  0000
 47+  0000              MMUSelectCpySrcA:    MACRO
 48+  0000 ~                                 nextreg DMACpySourceMMU,	a
 49+  0000              					 ENDM
 50+  0000
 51+  0000              MMUSelectCpySrcN:    MACRO value
 52+  0000 ~                                 nextreg DMACpySourceMMU,	value
 53+  0000              					 ENDM
 54+  0000
 55+  0000              MMUSelectUniverseA:  MACRO
 56+  0000 ~                                 nextreg UniverseMMU,       a
 57+  0000                                   ENDM
 58+  0000
 59+  0000              MMUSelectUniverseN:  MACRO value
 60+  0000 ~                                 nextreg UniverseMMU,       BankUNIVDATA0+value
 61+  0000                                   ENDM
 62+  0000
 63+  0000              MMUSelectGalaxyA:    MACRO
 64+  0000 ~                                 nextreg GalaxyDataMMU,       a
 65+  0000                                   ENDM
 66+  0000
 67+  0000              MMUSelectGalaxyN:    MACRO value
 68+  0000 ~                                 nextreg GalaxyDataMMU,     BankGalaxyData0+value
 69+  0000                                   ENDM
 70+  0000              MMUSelectGalaxyACopy:MACRO
 71+  0000 ~                                 nextreg UniverseMMU,       a
 72+  0000                                   ENDM
 73+  0000
 74+  0000              MMUSelectUniverseAbs:MACRO value
 75+  0000 ~                                 nextreg UniverseMMU,       value
 76+  0000                                   ENDM
 77+  0000
 78+  0000              MMUSelectMenuGalCht: MACRO
 79+  0000 ~                                 nextreg MenuGalChtMMU,		BankMenuGalCht
 80+  0000              					 ENDM
 81+  0000
 82+  0000              MMUSelectMenuShrCht: MACRO
 83+  0000 ~            					 nextreg MenuShrChtMMU,		BankMenuShrCht
 84+  0000              					 ENDM
 85+  0000
 86+  0000              MMUSelectMenuInvent: MACRO
 87+  0000 ~                                 nextreg MenuInventMMU,		BankMenuInvent
 88+  0000              					 ENDM
 89+  0000
 90+  0000              MMUSelectMenuSystem: MACRO
 91+  0000 ~                                 nextreg MenuSystemMMU,		BankMenuSystem
 92+  0000              					 ENDM
 93+  0000
 94+  0000              MMUSelectMenuMarket: MACRO
 95+  0000 ~                                 nextreg MenuMarketMMU,		BankMenuMarket
 96+  0000              					 ENDM
 97+  0000
 98+  0000              MMUSelectMenuStatus: MACRO
 99+  0000 ~                                 nextreg MenuStatusMMU,		BankMenuStatus
100+  0000              					 ENDM
101+  0000
102+  0000              MMUSelectViewFront:  MACRO
103+  0000 ~                                 nextreg ScreenBankMMU,		BankFrontView
104+  0000              					 ENDM
105+  0000
106+  0000              MMUSelectScreenA:    MACRO
107+  0000 ~                                 nextreg ScreenBankMMU,		a
108+  0000              					 ENDM
109+  0000
# file closed: ./Macros/MMUMacros.asm
 38   0000                  INCLUDE "./Macros/ShiftMacros.asm"
# file opened: ./Macros/ShiftMacros.asm
  1+  0000              ShiftIYRight1: MACRO
  2+  0000 ~            			   ld 	a,iyh
  3+  0000 ~            			   srl 	a
  4+  0000 ~            			   ld	iyh,a
  5+  0000 ~            			   ld 	a,iyl
  6+  0000 ~            			   rra
  7+  0000 ~            			   ld	iyl,a
  8+  0000              			   ENDM
  9+  0000
 10+  0000              ShiftHLRight1: MACRO
 11+  0000 ~            			   srl h
 12+  0000 ~            			   rr  l
 13+  0000              			   ENDM
 14+  0000
 15+  0000              ShiftDERight1: MACRO
 16+  0000 ~            			   srl d
 17+  0000 ~            			   rr  e
 18+  0000              			   ENDM
 19+  0000
 20+  0000              ShiftBCRight1: MACRO
 21+  0000 ~            			   srl b
 22+  0000 ~            			   rr  c
 23+  0000              			   ENDM
 24+  0000
 25+  0000
 26+  0000
 27+  0000              ShiftHLDiv8:   MACRO
 28+  0000 ~            			   srl h
 29+  0000 ~            			   rr  l
 30+  0000 ~            			   srl h
 31+  0000 ~            			   rr  l
 32+  0000 ~            			   srl h
 33+  0000 ~            			   rr  l
 34+  0000              			   ENDM
 35+  0000
 36+  0000              ShiftHLLeft1:  MACRO
 37+  0000 ~            			   sla l
 38+  0000 ~            			   rl  h
 39+  0000              			   ENDM
 40+  0000
 41+  0000              ShiftDELeft1:  MACRO
 42+  0000 ~            			   sla e
 43+  0000 ~            			   rl  d
 44+  0000              			   ENDM
 45+  0000
 46+  0000              ShiftBCLeft1:  MACRO
 47+  0000 ~            			   sla b
 48+  0000 ~            			   rl  c
 49+  0000              			   ENDM
 50+  0000
 51+  0000              ShiftMem16Right1:   MACRO memaddr
 52+  0000 ~                                ld    hl,(memaddr)
 53+  0000 ~                                srl   h
 54+  0000 ~                                rr    l
 55+  0000 ~                                ld    (memaddr),hl
 56+  0000                                  ENDM
 57+  0000
 58+  0000              ShiftMem8Right1:    MACRO memaddr
 59+  0000 ~                                ld      a,(memaddr)
 60+  0000 ~                                srl     a
 61+  0000 ~                                ld      (memaddr),a
 62+  0000                                  ENDM
 63+  0000
 64+  0000
 65+  0000              ShiftMem8Left1A:    MACRO memaddr
 66+  0000 ~                                ld      a,(memaddr)
 67+  0000 ~                                sla     a
 68+  0000 ~                                ld      (memaddr),a
 69+  0000                                  ENDM
 70+  0000
# file closed: ./Macros/ShiftMacros.asm
 39   0000                  INCLUDE "./Macros/CopyByteMacros.asm"
# file opened: ./Macros/CopyByteMacros.asm
  1+  0000              CopyByteAtHLixToA:		MACRO memloc
  2+  0000 ~            						ex          de,hl                               ; save hl
  3+  0000 ~            						ld          hl,memloc
  4+  0000 ~            						add         hl,a
  5+  0000 ~            						ld          a,(hl)                              ; get XX2[x]
  6+  0000 ~            						ex          de,hl                               ; get hl back as we need it in loop
  7+  0000              						ENDM
  8+  0000
  9+  0000              ; Increments IYL
 10+  0000              ; Increments IHL
 11+  0000              ; Gets value at hl and loads into Parameter 1 address
 12+  0000
 13+  0000              CopyByteAtNextHLiyl: 	MACRO memloc
 14+  0000 ~            						inc         iyl                                 ;
 15+  0000 ~            						inc         hl                                  ; vertex byte#1
 16+  0000 ~            						ld          a,(hl)                              ;
 17+  0000 ~            						ld          (memloc),a                     ; XX15+2 = (V),Y
 18+  0000              						ENDM
 19+  0000
# file closed: ./Macros/CopyByteMacros.asm
 40   0000                  INCLUDE "./Macros/GeneralMacros.asm"
# file opened: ./Macros/GeneralMacros.asm
  1+  0000              JumpIfPositive:	        MACRO target
  2+  0000 ~                                    jp		p,target
  3+  0000                                      ENDM
  4+  0000
  5+  0000              JumpIfNegative:	        MACRO target
  6+  0000 ~                                    jp		m,target
  7+  0000                                      ENDM
  8+  0000
  9+  0000              JumpOnMemBitSet:        MACRO mem, bitnbr, target
 10+  0000 ~                                    ld      a,(mem)
 11+  0000 ~                                    bit 	bitnbr,a
 12+  0000 ~                                    jp      nz,target
 13+  0000                                      ENDM
 14+  0000
 15+  0000              JumpOnMemBitClear:      MACRO mem, bitnbr, target
 16+  0000 ~                                    ld      a,(mem)
 17+  0000 ~                                    bit 	bitnbr,a
 18+  0000 ~                                    jp      z,target
 19+  0000                                      ENDM
 20+  0000
 21+  0000
 22+  0000              JumpOnBitSet:           MACRO  reg, bitnbr, target
 23+  0000 ~                                    bit 	bitnbr,reg
 24+  0000 ~                                    jp      nz,target
 25+  0000                                      ENDM
 26+  0000
 27+  0000              JumpOnBitClear:         MACRO  reg, bitnbr, target
 28+  0000 ~                                    bit 	bitnbr,reg
 29+  0000 ~                                    jp      z,target
 30+  0000                                      ENDM
 31+  0000
 32+  0000              ReturnOnBitSet:         MACRO  reg, bitnbr,
 33+  0000 ~                                    bit 	bitnbr,reg
 34+  0000 ~                                    ret     nz
 35+  0000                                      ENDM
 36+  0000
 37+  0000              ReturnOnMemBitSet:      MACRO mem, bitnbr
 38+  0000 ~                                    ld   a,(mem)
 39+  0000 ~                                    bit 	bitnbr,a
 40+  0000 ~                                    ret     nz
 41+  0000                                      ENDM
 42+  0000
 43+  0000              ReturnOnBitClear:       MACRO reg, bitnbr
 44+  0000 ~                                    bit 	bitnbr,reg
 45+  0000 ~                                    ret		z
 46+  0000                                      ENDM
 47+  0000
 48+  0000              ReturnOnMemBitClear:    MACRO mem, bitnbr
 49+  0000 ~                                    ld     a,(mem)
 50+  0000 ~                                    bit 	bitnbr,a
 51+  0000 ~                                    ret		z
 52+  0000                                      ENDM
 53+  0000
 54+  0000              JumpIfAGTEusng:         MACRO
 55+  0000 ~                                    jp		nc,target
 56+  0000                                      ENDM
 57+  0000
 58+  0000              JumpIfAGTENusng:        MACRO reg,target
 59+  0000 ~                                    cp     reg
 60+  0000 ~                                    jp		nc,target
 61+  0000                                      ENDM
 62+  0000
 63+  0000
 64+  0000              CallIfAGTENusng:        MACRO   reg,target
 65+  0000 ~                                    cp      reg
 66+  0000 ~                                    call	nc,target
 67+  0000                                      ENDM
 68+  0000
 69+  0000              JumpIfMemGTENusng:      MACRO mem, value, target
 70+  0000 ~                                    ld     a,(mem)
 71+  0000 ~                                    cp     value
 72+  0000 ~                                    jp	  nc,target
 73+  0000                                      ENDM
 74+  0000
 75+  0000              JumpIfMemGTEMemusng:    MACRO mem, value, target
 76+  0000 ~                                    ld   a,(mem)
 77+  0000 ~                                    ld   hl,value
 78+  0000 ~                                    cp   (hl)
 79+  0000 ~                                    jp	  nc,target
 80+  0000                                      ENDM
 81+  0000
 82+  0000
 83+  0000              JumpIfALTusng:          MACRO target
 84+  0000 ~                                    jp		c,target
 85+  0000                                      ENDM
 86+  0000
 87+  0000              JumpIfALTNusng:         MACRO value, target
 88+  0000 ~                                    cp      value
 89+  0000 ~                                    jp		c,target
 90+  0000                                      ENDM
 91+  0000
 92+  0000              JumpIfMemLTNusng:       MACRO mem, value, target
 93+  0000 ~                                    ld      a,(mem)
 94+  0000 ~                                    cp      value
 95+  0000 ~                                    jp	  c,target
 96+  0000                                      ENDM
 97+  0000
 98+  0000              JumpIfMemLTMemusng:     MACRO mem, value, target
 99+  0000 ~                                    ld    a,(mem)
100+  0000 ~                                    ld    hl,value
101+  0000 ~                                    cp    (hl)
102+  0000 ~                                    jp	  c,target
103+  0000                                      ENDM
104+  0000
105+  0000              JumpIfALTMemHLusng:     MACRO target
106+  0000 ~                                    cp    (hl)
107+  0000 ~                                    jp	  c,target
108+  0000                                      ENDM
109+  0000
110+  0000              JumpIfANENusng: MACRO value, target
111+  0000 ~                            cp     value
112+  0000 ~                            jp      nz,target
113+  0000                              ENDM
114+  0000
115+  0000              JumpIfANEMemusng: MACRO  value, target
116+  0000 ~                              ld    hl,value
117+  0000 ~                              cp    (hl)
118+  0000 ~                              jp      nz,target
119+  0000                                ENDM
120+  0000
121+  0000              JumpIfAEqNusng: MACRO value, target
122+  0000 ~                            cp     value
123+  0000 ~                            jp      z,target
124+  0000                              ENDM
125+  0000
126+  0000              IfAIsZeroGoto:	MACRO target
127+  0000 ~            				cp	0
128+  0000 ~            				jp	z,target
129+  0000              				ENDM
130+  0000
131+  0000              IfANotZeroGoto:	MACRO target
132+  0000 ~            				cp	0
133+  0000 ~            				jp	nz,target
134+  0000              				ENDM
135+  0000
136+  0000              IfResultZeroGoto:	MACRO target
137+  0000 ~            					jp	z,target
138+  0000              					ENDM
139+  0000
140+  0000              IfResultNotZeroGoto:MACRO target
141+  0000 ~            					jp	nz,target
142+  0000              					ENDM
143+  0000
144+  0000              ReturnIfAIsZero: MACRO
145+  0000 ~                             cp     0
146+  0000 ~                             ret    z
147+  0000                               ENDM
148+  0000
149+  0000              ReturnIfMemisZero: MACRO mem
150+  0000 ~                               ld   a,(mem)
151+  0000 ~                               cp     0
152+  0000 ~                               ret    z
153+  0000                                 ENDM
154+  0000
155+  0000              ReturnIfANotZero: MACRO
156+  0000 ~                              cp     0
157+  0000 ~                              ret    nz
158+  0000                                ENDM
159+  0000
160+  0000              ReturnIfMemNotZero: MACRO mem
161+  0000 ~                                ld     a,(mem)
162+  0000 ~                                cp     0
163+  0000 ~                                ret    nz
164+  0000                                  ENDM
165+  0000
166+  0000              ReturnIfAGTEusng: MACRO value
167+  0000 ~            				  cp    value
168+  0000 ~                              ret	 nc
169+  0000                                ENDM
170+  0000
171+  0000              ReturnIfALTNusng:  MACRO value
172+  0000 ~                               cp    value
173+  0000 ~                               ret	 c
174+  0000                                 ENDM
175+  0000
176+  0000              ReturnIfAGTENusng: MACRO value
177+  0000 ~                               cp    value
178+  0000 ~                               ret	 nc
179+  0000                                 ENDM
180+  0000
181+  0000              ReturnIfANENusng: MACRO value
182+  0000 ~                              cp      value
183+  0000 ~                              ret     nz
184+  0000                                ENDM
185+  0000
186+  0000              ReturnIfAEqNusng: MACRO value
187+  0000 ~                              cp      value
188+  0000 ~                              ret     z
189+  0000                                ENDM
190+  0000
191+  0000
192+  0000              ClearCarryFlag:	MACRO
193+  0000 ~            				or a
194+  0000              				ENDM
195+  0000
196+  0000              pushbcde:		MACRO
197+  0000 ~            	push	bc
198+  0000 ~            	push	de
199+  0000              	ENDM
200+  0000
201+  0000              popdebc:		MACRO
202+  0000 ~            	pop		de
203+  0000 ~            	pop		bc
204+  0000              	ENDM
205+  0000
206+  0000              pushhlde:		MACRO
207+  0000 ~                            push	hl
208+  0000 ~                            push	de
209+  0000                              ENDM
210+  0000
211+  0000              popdehl:		MACRO
212+  0000 ~                            pop		de
213+  0000 ~                            pop		hl
214+  0000                              ENDM
215+  0000
216+  0000              pushbcdeaf:		MACRO
217+  0000 ~                            push	bc
218+  0000 ~                            push	de
219+  0000 ~                            push	af
220+  0000                              ENDM
221+  0000
222+  0000              popafdebc:		MACRO
223+  0000 ~                            pop		af
224+  0000 ~                            pop		de
225+  0000 ~                            pop		bc
226+  0000                              ENDM
227+  0000
228+  0000              NegIY:			MACRO
229+  0000 ~                            xor a
230+  0000 ~                            sub iyl
231+  0000 ~                            ld iyl,a
232+  0000 ~                            sbc a,a
233+  0000 ~                            sub iyh
234+  0000 ~                            ld iyh,a
235+  0000                              ENDM
236+  0000
237+  0000              NegHL:			MACRO
238+  0000 ~                            xor a
239+  0000 ~                            sub l
240+  0000 ~                            ld l,a
241+  0000 ~                            sbc a,a
242+  0000 ~                            sub h
243+  0000 ~                            ld h,a
244+  0000                              ENDM
245+  0000
246+  0000              NegDE:			MACRO
247+  0000 ~                            xor a
248+  0000 ~                            sub e
249+  0000 ~                            ld e,a
250+  0000 ~                            sbc a,a
251+  0000 ~                            sub d
252+  0000 ~                            ld d,a
253+  0000                              ENDM
254+  0000
255+  0000
256+  0000              NegBC:			MACRO
257+  0000 ~                            xor a
258+  0000 ~                            sub c
259+  0000 ~                            ld c,a
260+  0000 ~                            sbc a,a
261+  0000 ~                            sub  b
262+  0000 ~                            ld b,a
263+  0000                              ENDM
264+  0000
265+  0000              FourLDIInstrunctions:   MACRO
266+  0000 ~                                    ldi
267+  0000 ~                                    ldi
268+  0000 ~                                    ldi
269+  0000 ~                                    ldi
270+  0000                                      ENDM
271+  0000
272+  0000              FiveLDIInstrunctions:   MACRO
273+  0000 ~                                    ldi
274+  0000 ~                                    ldi
275+  0000 ~                                    ldi
276+  0000 ~                                    ldi
277+  0000 ~                                    ldi
278+  0000                                      ENDM
279+  0000
280+  0000              SixLDIInstrunctions:   MACRO
281+  0000 ~                                    ldi
282+  0000 ~                                    ldi
283+  0000 ~                                    ldi
284+  0000 ~                                    ldi
285+  0000 ~                                    ldi
286+  0000 ~                                    ldi
287+  0000                                      ENDM
288+  0000
289+  0000              EightLDIInstrunctions:  MACRO
290+  0000 ~            		                ldi
291+  0000 ~            		                ldi
292+  0000 ~            		                ldi
293+  0000 ~            		                ldi
294+  0000 ~            		                ldi
295+  0000 ~            		                ldi
296+  0000 ~            		                ldi
297+  0000 ~            		                ldi
298+  0000                                      ENDM
299+  0000
300+  0000              NineLDIInstrunctions:  MACRO
301+  0000 ~            		                ldi
302+  0000 ~            		                ldi
303+  0000 ~            		                ldi
304+  0000 ~            		                ldi
305+  0000 ~            		                ldi
306+  0000 ~            		                ldi
307+  0000 ~            		                ldi
308+  0000 ~            		                ldi
309+  0000 ~            		                ldi
310+  0000                                      ENDM
311+  0000
# file closed: ./Macros/GeneralMacros.asm
 41   0000                  INCLUDE "./Macros/ldCopyMacros.asm"
# file opened: ./Macros/ldCopyMacros.asm
  1+  0000              ZeroA:		   MACRO
  2+  0000 ~            			   xor a
  3+  0000              			   ENDM
  4+  0000
  5+  0000              ldCopyByte:    MACRO memfrom, memto
  6+  0000 ~                           ld       a,(memfrom)
  7+  0000 ~                           ld       (memto),a
  8+  0000              			   ENDM
  9+  0000
 10+  0000
 11+  0000              ldCopyByteABS: MACRO
 12+  0000 ~                           ld       a,(memfrom)
 13+  0000 ~            			   and		$7F
 14+  0000 ~                           ld       (memto),a
 15+  0000              			   ENDM
 16+  0000
 17+  0000              ldCopy2Byte    MACRO  memfrom, memto
 18+  0000 ~                           ld       hl,(memfrom)
 19+  0000 ~                           ld       (memto),hl
 20+  0000                             ENDM
 21+  0000
 22+  0000              ldWriteConst   MACRO  memfrom, memto
 23+  0000 ~                           ld       a,memfrom
 24+  0000 ~                           ld       (memto),a
 25+  0000                             ENDM
 26+  0000
 27+  0000              ldWriteZero    MACRO  memto
 28+  0000 ~                           xor      a
 29+  0000 ~                           ld       (memto),a
 30+  0000                             ENDM
 31+  0000
 32+  0000              ldIXLaFromN:	MACRO memfrom
 33+  0000 ~                            ld		a,(memfrom)
 34+  0000 ~                            ld		ixl,a
 35+  0000                              ENDM
 36+  0000
 37+  0000              ldIXHaFromN:	MACRO memfrom
 38+  0000 ~                            ld		a,(memfrom)
 39+  0000 ~                            ld		ixh,a
 40+  0000                              ENDM
 41+  0000
 42+  0000              ldIYLaFromN:	MACRO memfrom
 43+  0000 ~                            ld		a,(memfrom)
 44+  0000 ~                            ld		iyl,a
 45+  0000                              ENDM
 46+  0000
 47+  0000              ldIYHaFromN:	MACRO memfrom
 48+  0000 ~                            ld		a,(memfrom)
 49+  0000 ~                            ld		iyh,a
 50+  0000                              ENDM
 51+  0000
 52+  0000              ldhlde:			MACRO
 53+  0000 ~                            ld		h,d
 54+  0000 ~                            ld		l,e
 55+  0000                              ENDM
 56+  0000
 57+  0000              ldhlbc:			MACRO
 58+  0000 ~                            ld		h,b
 59+  0000 ~                            ld		l,c
 60+  0000                              ENDM
 61+  0000
 62+  0000              ldbcde:			MACRO
 63+  0000 ~                            ld		b,d
 64+  0000 ~                            ld		c,e
 65+  0000                              ENDM
 66+  0000
 67+  0000              lddebc:			MACRO
 68+  0000 ~                            ld		d,b
 69+  0000 ~                            ld		e,c
 70+  0000                              ENDM
 71+  0000
 72+  0000              ldbchl:			MACRO
 73+  0000 ~                            ld		b,h
 74+  0000 ~                            ld		c,l
 75+  0000                              ENDM
 76+  0000
 77+  0000              lddeiy:			MACRO
 78+  0000 ~                            ld		d,iyh
 79+  0000 ~                            ld		e,iyl
 80+  0000                              ENDM
 81+  0000
 82+  0000              ldiyde:			MACRO
 83+  0000 ~                            ld		iyh,d
 84+  0000 ~                            ld		iyl,e
 85+  0000                              ENDM
 86+  0000
# file closed: ./Macros/ldCopyMacros.asm
 42   0000                  INCLUDE "./Macros/ldIndexedMacros.asm"
# file opened: ./Macros/ldIndexedMacros.asm
  1+  0000              ldAToHLixl:			MACRO value
  2+  0000 ~            					ld          hl,value
  3+  0000 ~            					ex          af,af'
  4+  0000 ~            					ld          a,ixl
  5+  0000 ~            					add         hl,a
  6+  0000 ~            					ex          af,af'
  7+  0000 ~            					ld          (hl),a
  8+  0000              					ENDM
  9+  0000
 10+  0000              ldAToHLiyl:			MACRO value
 11+  0000 ~            					ld          hl,value
 12+  0000 ~            					ex          af,af'
 13+  0000 ~            					ld          a,iyl
 14+  0000 ~            					add         hl,a
 15+  0000 ~            					ex          af,af'
 16+  0000 ~            					ld          (hl),a
 17+  0000              					ENDM
 18+  0000
 19+  0000
 20+  0000              ldHLixlToA:         MACRO value
 21+  0000 ~                                ld          hl,value
 22+  0000 ~                                ex          af,af'
 23+  0000 ~                                ld          a,ixl
 24+  0000 ~                                add         hl,a
 25+  0000 ~                                ld          a,(hl)
 26+  0000                                  ENDM
 27+  0000
 28+  0000              ldHLiylToA:         MACRO value
 29+  0000 ~                                ld          hl,value
 30+  0000 ~                                ex          af,af'
 31+  0000 ~                                ld          a,iyl
 32+  0000 ~                                add         hl,a
 33+  0000 ~                                ld          a,(hl)
 34+  0000                                  ENDM
 35+  0000
 36+  0000              ldHLIdxAToA:        MACRO value
 37+  0000 ~                                ld          hl,value
 38+  0000 ~                                add         hl,a
 39+  0000 ~                                ld          a,(hl)
 40+  0000                                  ENDM
 41+  0000
# file closed: ./Macros/ldIndexedMacros.asm
 43   0000
 44   0000              charactersetaddr		equ 15360
 45   0000              STEPDEBUG               equ 1
 46   0000
 47   0000
 48   0000                                      ORG         $8000
 49   8000 F3                                   di
 50   8001                                      ; "STARTUP"
 51   8001                                      MMUSelectLayer1
 51   8001 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
 52   8005 CD 47 E0                             call		l1_cls
 53   8008 3E 07                                ld			a,7
 54   800A CD 53 E0                             call		l1_attr_cls_to_a
 55   800D 3E FF                                ld          a,$FF
 56   800F CD 5D E0                             call        l2_set_border
 57   8012              Initialise:             MMUSelectLayer2
 57   8012 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 58   8016 CD D0 E0                             call 		l2_initialise
 59   8019 CD C9 E0                             call		l2_cls
 60   801C 21 3C 80     fillLineBuffer:         ld          hl,LineList
 61   801F 11 82 90                             ld          de,UBnkNodeArray
 62   8022 01 F0 00                             ld          bc,LineListLen
 63   8025 ED B0                                ldir
 64   8027 AF           setToLineHead:          xor         a
 65   8028 32 3F 81                             ld          (currentLine),a
 66   802B              ;..................................................................................................................................
 67   802B                                      MMUSelectLayer2
 67   802B ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 68   802F CD A6 E9                             call    PrepLines                   ; LL72, process lines and clip, ciorrectly processing face visibility now
 69   8032 CD B6 95     MainLoop:               call    DrawLines                   ; Need to plot all lines
 70   8035 21 3F 81                             ld      hl,currentLine
 71   8038 34                                   inc     (hl)
 72   8039 C3 32 80                             jp MainLoop
 73   803C              ;..................................................................................................................................
 74   803C              	;call		keyboard_main_loop
 75   803C
 76   803C
 77   803C 0A 00 0A 00  LineList:               dw       10,10,20,20
 77   8040 14 00 14 00
 78   8044 32 00 32 00                          dw       50,50,20,20
 78   8048 14 00 14 00
 79   804C 0A 00 32 00                          dw       10,50,20,20
 79   8050 14 00 14 00
 80   8054 32 00 0A 00                          dw       50,10,20,20
 80   8058 14 00 14 00
 81   805C 32 00 0A 00                          dw       50,10,20,20
 81   8060 14 00 14 00
 82   8064 0F 00 0A 00                          dw       15,10,20,20
 82   8068 14 00 14 00
 83   806C 0F 00 0F 00                          dw       15,15,20,20
 83   8070 14 00 14 00
 84   8074 0A 00 0F 00                          dw       10,15,20,20
 84   8078 14 00 14 00
 85   807C 32 00 14 00                          dw       50,20,20,20
 85   8080 14 00 14 00
 86   8084 14 00 0A 00                          dw       20,10,20,20
 86   8088 14 00 14 00
 87   808C 32 00 14 00                          dw       50,20,20,20
 87   8090 14 00 14 00
 88   8094 0A 00 14 00                          dw       10,20,20,20
 88   8098 14 00 14 00
 89   809C 14 00 0A 00                          dw       20,10,20,20
 89   80A0 14 00 14 00
 90   80A4 14 00 32 00                          dw       20,50,20,20
 90   80A8 14 00 14 00
 91   80AC 00 00 64 00                          dw       000,100,100,100            ; Horizonal left to right on screen         - Loosed first pixel top
 91   80B0 64 00 64 00
 92   80B4 64 00 00 00                          dw       100,000,100,100            ; Veritcal  down on screen                  - Loosed first pixel left
 92   80B8 64 00 64 00
 93   80BC                                     ;dw      0,100,255,100
 94   80BC                                     ;dw      0,110,255,110
 95   80BC                                     ;dw      0,127,255,127
 96   80BC                                     ;dw      0,90,255,90
 97   80BC                                     ;dw      90,0,90,127
 98   80BC                                     ;dw      100,0,100,127
 99   80BC                                     ;dw      110,0,110,127
100   80BC                                     ;dw      90,-10,100,100              ; look better
101   80BC                                     ;dw      110,-10,100,100             ; look better
102   80BC                                     ;dw      90,300,100,100              ; fail upside down?
103   80BC                                     ;dw      110,300,100,100             ; fail
104   80BC                                     ;dw      90,200,100,100              ; loooks beeter
105   80BC                                     ;dw      110,200,100,100             ; loooks beeter
106   80BC                                     ;dw       500,110,100,100            ; Horzontal right to left clip right         - nwo good clips to 255,110      horizontal
107   80BC                                     ;dw       -10,110,100,100            ; Horzontal left to right clip left          - now good clips 0, 110          horizontal
108   80BC                                     ;dw       -10,90,100,100            ; Horzontal left to right clip left          -  now good clips  0, 90          horizontal
109   80BC                                    ; dw       260,110,100,100            ; Horzontal left to right clip left          - now good clips to 255,110      horizontal
110   80BC                                    ; dw       260,90,100,100            ; Horzontal left to right clip left          - now good clips to 255,90        horizontal
111   80BC                                    ; dw       100,100,550,100            ;  looks OK
112   80BC                                    ; dw       100,100,-10,100            ;     looks OK                                         - Total loss of line
113   80BC                                    ; dw        100,500,100,100           ;  now ood ends up vertical
114   80BC                                    ; dw        105,500,100,100           ;                                           - loss of part line, go steep optmisation
115   80BC                                    ; dw        -5,105,100,100            ; loooks beeter                                           - Loosed first pixel left
116   80BC                                    ; dw         10,-5,100,100            ;  loooks beeter                                          - Loosed first pixel top
117   80BC                                    ; dw        300,105,100,100            ;  loooks beeter                                            - large x looses the plot
118   80BC                                    ; dw        300,-105,100,100            ;loooks beeter                                              - Loosed first pixel left
119   80BC                                    ; dw         10,180,100,100            ;  loooks beeter                                            - Loosed first pixel top
120   80BC                                    ; dw       100,105,100,100
121   80BC F4 01 C8 00                          dw       500,200,100,100 ; looks OK
121   80C0 64 00 64 00
122   80C4 C8 00 64 00                    dw       200,100,100,100
122   80C8 64 00 64 00
123   80CC F4 01 C8 00                    dw       500,200,100,100
123   80D0 64 00 64 00
124   80D4 64 00 C8 00                    dw       100,200,100,100
124   80D8 64 00 64 00
125   80DC C8 00 64 00                    dw       200,100,100,100
125   80E0 64 00 64 00
126   80E4 C8 00 F4 01                    dw       200,500,100,100
126   80E8 64 00 64 00
127   80EC
128   80EC 14 00 14 00                   dw       20,20,10,10
128   80F0 0A 00 0A 00
129   80F4 F6 FF 0A 00                   dw       -10,10,20,20
129   80F8 14 00 14 00
130   80FC 0A 00 F6 FF                   dw       10,-10,20,20
130   8100 14 00 14 00
131   8104 0A 00 0A 00                   dw       10,10,-20,20
131   8108 EC FF 14 00
132   810C 0A 00 0A 00                   dw       10,10,20,-20
132   8110 14 00 EC FF
133   8114 F6 FF 0A 00                   dw       -10,10,-20,20
133   8118 EC FF 14 00
134   811C 0A 00 F6 FF                   dw       10,-10,20,-20
134   8120 14 00 EC FF
135   8124 F6 FF F6 FF                   dw       -10,-10,-20,-20
135   8128 EC FF EC FF
136   812C              LineListLen             equ $ - LineList
137   812C 58 58 58 58                       db "XXXXXXXX"
137   8130 58 58 58 58
138   8134
139   8134
140   8134 CD 52 82     TestQuit:               call    scan_keyboard
141   8137 3E 46                                ld      a,c_Pressed_Quit
142   8139 CD CA 82                             call    is_key_pressed
143   813C 20 F6                                jr      nz,TestQuit
144   813E C9                                   ret
145   813F 00           currentLine:            DB 0
146   8140
147   8140                  INCLUDE	"./Hardware/memfill_dma.asm"
# file opened: ./Hardware/memfill_dma.asm
  1+  8140
  2+  8140 00           memfillvalue		DB 0
  3+  8141 83 C3 C7 CB  memfill        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
  3+  8145 7D
  4+  8146 40 81        memfill_astrt  		DW memfillvalue
  5+  8148 00 40        memfill_length 		DB $00,$40
  6+  814A 24 10 AD     					DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
  7+  814D 00 00        memfill_bstrt  		DB $00,$00
  8+  814F 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
  9+  8153              memfill_cmd_len	  	EQU $ - memfill
 10+  8153
 11+  8153              memfill_dma:
 12+  8153              ; "memfill_dma, hl = address to fill, a = value, de = length"
 13+  8153              .set_fill_value:
 14+  8153 32 40 81     	ld 		(memfillvalue),a
 15+  8156              .set_target:
 16+  8156 22 4D 81     	ld		(memfill_bstrt),hl
 17+  8159              .set_length:
 18+  8159 ED 53 48 81  	ld		(memfill_length),de
 19+  815D              .write_dma:
 20+  815D 21 41 81     	ld 		hl, memfill
 21+  8160 06 12        	ld 		b, memfill_cmd_len
 22+  8162 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
 23+  8164 ED B3        	otir
 24+  8166 C9           	ret
 25+  8167
# file closed: ./Hardware/memfill_dma.asm
148   8167                  INCLUDE	"./Hardware/memcopy_dma.asm"
# file opened: ./Hardware/memcopy_dma.asm
  1+  8167
  2+  8167 83 C3 C7 CB  memcopy        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
  2+  816B 7D
  3+  816C 00 00        memcopy_astrt  		DB $00,$00
  4+  816E 00 40        memcopy_length 		DB $00,$40
  5+  8170 14 10 AD     					DB DMA_WR1_P1INC_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
  6+  8173 00 00        memcopy_bstrt  		DB $00,$00
  7+  8175 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
  8+  8179              memcopy_cmd_len	  	equ $ - memcopy
  9+  8179
 10+  8179              memcopy_dma:
 11+  8179              ; "memcopy_dma, hl = target address de = source address to copy, bc = length"
 12+  8179              .set_target:
 13+  8179 22 73 81     	ld		(memcopy_bstrt),hl
 14+  817C              .set_source:
 15+  817C ED 53 6C 81  	ld		(memcopy_astrt),de
 16+  8180              .set_length:
 17+  8180 ED 43 6E 81  	ld		(memcopy_length),bc
 18+  8184              .write_dma:
 19+  8184 21 67 81     	ld 		hl, memcopy
 20+  8187 06 12        	ld 		b, memcopy_cmd_len
 21+  8189 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
 22+  818B ED B3        	otir
 23+  818D C9           	ret
 24+  818E
# file closed: ./Hardware/memcopy_dma.asm
149   818E                  INCLUDE "./Hardware/keyboard.asm"
# file opened: ./Hardware/keyboard.asm
  1+  818E              ;
  2+  818E              ; $FEFE;65278 V, C, X, Z, Caps Shifts       4  3  2  1  0
  3+  818E              ; $FDFE;65022 G, F, D, S, A                 9  8  7  6  5
  4+  818E              ; $FBFE;64510 T, R, E, W, Q                14 13 12 11 10
  5+  818E              ; $F7FE;63486 5, 4, 3, 2, 1                19 18 17 16 15
  6+  818E              ; $EFFE;61438 6, 7, 8, 9, 0                24 23 22 23 20
  7+  818E              ; $DFFE;57342 Y, U, I, O, P                29 28 27 26 25
  8+  818E              ; $BFFE;49150 H, J, K, L, Enter            34 33 32 31 30
  9+  818E              ; $7FFE;32766 B, N, M, Symbol Shift, Space 39 38 37 36 35
 10+  818E              ;
 11+  818E              ; Keyboard
 12+  818E              ;
 13+  818E              ;   0      1       2       3       4       5        6       7       8       9
 14+  818E              ;  VK_CAPS, VK_Z,  VK_X,   VK_C,   VK_V,   VK_A,    VK_S,   VK_D,   VK_F,   VK_G
 15+  818E              ;   10     11      12      13      14      15       16      17      18      19
 16+  818E              ;  VK_Q,   VK_W,   VK_E,   VK_R,   VK_T,   VK_1,    VK_2,   VK_3,   VK_4,   VK_5
 17+  818E              ;   20     21      22      23      24      25       26      27      28      29
 18+  818E              ;  VK_0    VK_9,   VK_8,   VK_7,   VK_6,   VK_P ,    VK_O,  VK_I,   VK_U,   VK_Y
 19+  818E              ;   30     31      32      33      34      35       36      37      38      39
 20+  818E              ; VK_ENTER VK_L,   VK_K,   VK_J,   VK_H,   VK_SPACE VK_SYM, VK_M,   VK_N,   VK_B
 21+  818E              ;
 22+  818E              ; Default map
 23+  818E              ;-----------------------------------------------------------------------------------------------------------------------------------
 24+  818E              ;   0          1           2             3              4           5           6           7           8           9
 25+  818E              ;   VK_CAPS    VK_Z        VK_X,         VK_C,          VK_V,       VK_A        VK_S,       VK_D,       VK_F,       VK_G
 26+  818E              ;              GameSkip                  Equip          SelLCargo   Climb       Decelerate  Recentre    FireM       HomeCursor
 27+  818E              ;                                                                                                       Find System
 28+  818E              ;-----------------------------------------------------------------------------------------------------------------------------------
 29+  818E              ;   10         11          12            13             14          15          16          17          18          19
 30+  818E              ;   VK_Q       VK_W,       VK_E,         VK_R,          VK_T,       VK_1        VK_2        VK_3        VK_4        VK_5
 31+  818E              ;   Dive       Accelerate  ECM           UnarmMissile   TargetM     FrontV      AftV        LeftV       RightV      GalacticChart
 32+  818E              ;-----------------------------------------------------------------------------------------------------------------------------------
 33+  818E              ;   20         Accel       22            23             24          25          26          27          28          29
 34+  818E              ;   VK_0       VK_9,       VK_8,         VK_7,          VK_6,       VK_P ,      VK_O,       VK_I,       VK_U,       VK_Y
 35+  818E              ;   EscapePod  Inventory   Status        MarketPrices   LocalChart  RollRight   RolLLeft                EnergyBomb  Quit
 36+  818E              ;   PlanetData                                                      PauseGame   SaveGame
 37+  818E              ;-----------------------------------------------------------------------------------------------------------------------------------
 38+  818E              ;   30         31          32            33             34          Right       36          37          EnergyBomb  39
 39+  818E              ;   VK_ENTER   VK_L,       VK_K,         VK_J,          VK_H,       VK_SPACE    VK_SYM,     VK_M,       VK_N,       VK_B
 40+  818E              ;              Launch                    Distance       Hyperspace  Laser                               DockComp    BuyCargo
 41+  818E              ;              ResumeGame
 42+  818E
 43+  818E              ; You can read address to check keystate by address KeyboardMap + c_Pressed corresponding key. There is also an addr_ helper too
 44+  818E
 45+  818E              c_Pressed_Front         equ 0  * 2
 46+  818E              c_Pressed_Aft           equ 1  * 2
 47+  818E              c_Pressed_Left          equ 2  * 2
 48+  818E              c_Pressed_Right         equ 3  * 2
 49+  818E              c_Pressed_RollLeft      equ 4  * 2
 50+  818E              c_Pressed_RollRight     equ 5  * 2
 51+  818E              c_Pressed_Dive          equ 6  * 2
 52+  818E              c_Pressed_Climb         equ 7  * 2
 53+  818E              c_Pressed_Accellerate   equ 8  * 2
 54+  818E              c_Pressed_Decellerate   equ 9  * 2
 55+  818E              c_Pressed_FireLaser     equ 10 * 2
 56+  818E              c_Pressed_TargetMissle  equ 11 * 2
 57+  818E              c_Pressed_FireMissile   equ 12 * 2
 58+  818E              c_Pressed_UnarmMissile  equ 13 * 2
 59+  818E              c_Pressed_ECM           equ 14 * 2
 60+  818E              c_Pressed_EnergyBomb    equ 15 * 2
 61+  818E              c_Pressed_EscapePod     equ 16 * 2
 62+  818E              c_Pressed_DockingComp   equ 17 * 2
 63+  818E              c_Pressed_Hyperspace    equ 18 * 2
 64+  818E              c_Pressed_Distance      equ 19 * 2
 65+  818E              c_Pressed_HomeCursor    equ 20 * 2
 66+  818E              c_Pressed_Launch        equ 21 * 2
 67+  818E              c_Pressed_BuyCargo      equ 22 * 2
 68+  818E              c_Pressed_SellCargo     equ 23 * 2
 69+  818E              c_Pressed_Equip         equ 24 * 2
 70+  818E              c_Pressed_GalacticChrt  equ 25 * 2
 71+  818E              c_Pressed_LocalChart    equ 26 * 2
 72+  818E              c_Pressed_MarketPrices  equ 27 * 2
 73+  818E              c_Pressed_Status        equ 28 * 2
 74+  818E              c_Pressed_Inventory     equ 29 * 2
 75+  818E              c_Pressed_GameSkip      equ 30 * 2
 76+  818E              c_Pressed_Save          equ 31 * 2
 77+  818E              c_Pressed_Freeze        equ 32 * 2
 78+  818E              c_Pressed_Resume        equ 33 * 2
 79+  818E              c_Pressed_Recentre      equ 34 * 2
 80+  818E              c_Pressed_Quit          equ 35 * 2
 81+  818E              c_Pressed_PlanetData    equ 36 * 2
 82+  818E              c_Pressed_CursorUp      equ 37 * 2
 83+  818E              c_Pressed_CursorDown    equ 38 * 2
 84+  818E              c_Pressed_Find          equ 39 * 2
 85+  818E
 86+  818E              ; half row 1
 87+  818E              VK_CAPS  				equ 0
 88+  818E              VK_Z  					equ 1
 89+  818E              VK_X  					equ 2
 90+  818E              VK_C  					equ 3
 91+  818E              VK_V  					equ 4
 92+  818E              ; half row 2
 93+  818E              VK_A  					equ 5
 94+  818E              VK_S  					equ 6
 95+  818E              VK_D  					equ 7
 96+  818E              VK_F  					equ 8
 97+  818E              VK_G  					equ 9
 98+  818E              ; half row 3
 99+  818E              VK_Q  					equ 10
100+  818E              VK_W  					equ 11
101+  818E              VK_E  					equ 12
102+  818E              VK_R  					equ 13
103+  818E              VK_T  					equ 14
104+  818E              ; half row 4
105+  818E              VK_1  					equ 15
106+  818E              VK_2  					equ 16
107+  818E              VK_3  					equ 17
108+  818E              VK_4  					equ 18
109+  818E              VK_5  					equ 19
110+  818E              ; half row 5
111+  818E              VK_0 					equ 20
112+  818E              VK_9 					equ 21
113+  818E              VK_8 					equ 22
114+  818E              VK_7 					equ 23
115+  818E              VK_6 					equ 24
116+  818E              ; half row 6
117+  818E              VK_P  					equ 25
118+  818E              VK_O  					equ 26
119+  818E              VK_I  					equ 27
120+  818E              VK_U  					equ 28
121+  818E              VK_Y  					equ 29
122+  818E              ; half row 7
123+  818E              VK_ENTER 				equ 30
124+  818E              VK_L  					equ 31
125+  818E              VK_K  					equ 32
126+  818E              VK_J  					equ 33
127+  818E              VK_H  					equ 34
128+  818E              ; half row 8
129+  818E              VK_SPACE 				equ 35
130+  818E              VK_SYM  				equ 36
131+  818E              VK_M  					equ 37
132+  818E              VK_N  					equ 38
133+  818E              VK_B  					equ 39
134+  818E
135+  818E              ;KeyboardMapping
136+  818E              KeyCode_Front        	equ VK_1
137+  818E              KeyCode_Aft          	equ VK_2
138+  818E              KeyCode_Left         	equ VK_3
139+  818E              KeyCode_Right        	equ VK_4
140+  818E              KeyCode_RollLeft     	equ VK_O
141+  818E              KeyCode_RollRight    	equ VK_P
142+  818E              KeyCode_Dive         	equ VK_Q
143+  818E              KeyCode_Climb        	equ VK_A
144+  818E              KeyCode_Accellerate  	equ VK_W
145+  818E              KeyCode_Decellerate  	equ VK_S
146+  818E              KeyCode_FireLaser    	equ VK_SPACE
147+  818E              KeyCode_TargetMissle 	equ VK_T
148+  818E              KeyCode_FireMissile  	equ VK_F
149+  818E              KeyCode_Find        	equ VK_F
150+  818E              KeyCode_UnarmMissile 	equ VK_R
151+  818E              KeyCode_ECM          	equ VK_E
152+  818E              KeyCode_EnergyBomb   	equ VK_U
153+  818E              KeyCode_EscapePod    	equ VK_CAPS
154+  818E              KeyCode_DockingComp  	equ VK_N
155+  818E              KeyCode_Hyperspace   	equ VK_H
156+  818E              KeyCode_Distance     	equ VK_J
157+  818E              KeyCode_HomeCursor   	equ VK_G
158+  818E              KeyCode_Launch       	equ VK_L
159+  818E              KeyCode_BuyCargo     	equ VK_B
160+  818E              KeyCode_SellCargo    	equ VK_V
161+  818E              KeyCode_Equip        	equ VK_C
162+  818E              KeyCode_GalacticChrt 	equ VK_5
163+  818E              KeyCode_LocalChart   	equ VK_6
164+  818E              KeyCode_MarketPrices 	equ VK_7
165+  818E              KeyCode_Status       	equ VK_8
166+  818E              KeyCode_Inventory    	equ VK_9
167+  818E              KeyCode_GameSkip     	equ VK_Z
168+  818E              KeyCode_Save         	equ VK_O
169+  818E              KeyCode_Freeze       	equ VK_B
170+  818E              KeyCode_Resume       	equ VK_L
171+  818E              KeyCode_Recentre     	equ VK_D
172+  818E              KeyCode_Quit         	equ VK_Y
173+  818E              KeyCode_PlanetData   	equ VK_0
174+  818E              KeyCode_CursorUp        equ VK_Q
175+  818E              KeyCode_CursorDown      equ VK_A
176+  818E
177+  818E 00 00 00...  Keys					DS	40
178+  81B6              c_KeyBoardLen 			equ $ - Keys
179+  81B6 00 00 00...  RawKeys					DS	8
180+  81BE FE FE FE FD  KeyAddrTab				DW	$FEFE, $FDFE, $FBFE, $F7FE, $EFFE, $DFFE, $BFFE, $7FFE
180+  81C2 FE FB FE F7
180+  81C6 FE EF FE DF
180+  81CA FE BF FE 7F
181+  81CE              ; Now keyboard map lists each game key and the corresponding address in the Keys table to get the value. This way redefining keys is just a case
182+  81CE              ; of updating this table with the respective location to look up
183+  81CE              ; key list sequence is in table above
184+  81CE 9D 81 9E 81  KeyboardMap             DW  Keys+KeyCode_Front        ,Keys+KeyCode_Aft          ,Keys+KeyCode_Left         ,Keys+KeyCode_Right        ,Keys+KeyCode_RollLeft
184+  81D2 9F 81 A0 81
184+  81D6 A8 81
185+  81D8 A7 81 98 81                          DW  Keys+KeyCode_RollRight    ,Keys+KeyCode_Dive         ,Keys+KeyCode_Climb        ,Keys+KeyCode_Accellerate  ,Keys+KeyCode_Decellerate
185+  81DC 93 81 99 81
185+  81E0 94 81
186+  81E2 B1 81 9C 81                          DW  Keys+KeyCode_FireLaser    ,Keys+KeyCode_TargetMissle ,Keys+KeyCode_FireMissile  ,Keys+KeyCode_UnarmMissile ,Keys+KeyCode_ECM
186+  81E6 96 81 9B 81
186+  81EA 9A 81
187+  81EC AA 81 8E 81                          DW  Keys+KeyCode_EnergyBomb   ,Keys+KeyCode_EscapePod    ,Keys+KeyCode_DockingComp  ,Keys+KeyCode_Hyperspace   ,Keys+KeyCode_Distance
187+  81F0 B4 81 B0 81
187+  81F4 AF 81
188+  81F6 97 81 AD 81                          DW  Keys+KeyCode_HomeCursor   ,Keys+KeyCode_Launch       ,Keys+KeyCode_BuyCargo     ,Keys+KeyCode_SellCargo    ,Keys+KeyCode_Equip
188+  81FA B5 81 92 81
188+  81FE 91 81
189+  8200 A1 81 A6 81                          DW  Keys+KeyCode_GalacticChrt ,Keys+KeyCode_LocalChart   ,Keys+KeyCode_MarketPrices ,Keys+KeyCode_Status       ,Keys+KeyCode_Inventory
189+  8204 A5 81 A4 81
189+  8208 A3 81
190+  820A 8F 81 A8 81                          DW  Keys+KeyCode_GameSkip     ,Keys+KeyCode_Save         ,Keys+KeyCode_Freeze       ,Keys+KeyCode_Resume       ,Keys+KeyCode_Recentre
190+  820E B5 81 AD 81
190+  8212 95 81
191+  8214 AB 81 A2 81                          DW  Keys+KeyCode_Quit         ,Keys+KeyCode_PlanetData   ,Keys+KeyCode_CursorUp     ,Keys+KeyCode_CursorDown   ,Keys+KeyCode_Find
191+  8218 98 81 93 81
191+  821C 96 81
192+  821E
193+  821E 23 5A 58 43  ASCII_Map:           DB "#","Z","X","C","V"
193+  8222 56
194+  8223 41 53 44 46                       DB "A","S","D","F","G"
194+  8227 47
195+  8228 51 57 45 52                       DB "Q","W","E","R","T"
195+  822C 54
196+  822D 31 32 33 34                       DB "1","2","3","4","5"
196+  8231 35
197+  8232 30 39 38 37                       DB "0","9","8","7","6"
197+  8236 36
198+  8237 50 4F 49 55                       DB "P","O","I","U","Y"
198+  823B 59
199+  823C 3E 4C 4B 4A                       DB ">","L","K","J","H"
199+  8240 48
200+  8241 20 5E 4D 4E                       DB " ","^","M","N","B"
200+  8245 42
201+  8246
202+  8246
203+  8246              addr_Pressed_Front         equ KeyboardMap+c_Pressed_Front
204+  8246              addr_Pressed_Aft           equ KeyboardMap+c_Pressed_Aft
205+  8246              addr_Pressed_Left          equ KeyboardMap+c_Pressed_Left
206+  8246              addr_Pressed_Right         equ KeyboardMap+c_Pressed_Right
207+  8246              addr_Pressed_RollLeft      equ KeyboardMap+c_Pressed_RollLeft
208+  8246              addr_Pressed_RollRight     equ KeyboardMap+c_Pressed_RollRight
209+  8246              addr_Pressed_Dive          equ KeyboardMap+c_Pressed_Dive
210+  8246              addr_Pressed_Climb         equ KeyboardMap+c_Pressed_Climb
211+  8246              addr_Pressed_Accellerate   equ KeyboardMap+c_Pressed_Accellerate
212+  8246              addr_Pressed_Decellerate   equ KeyboardMap+c_Pressed_Decellerate
213+  8246              addr_Pressed_FireLaser     equ KeyboardMap+c_Pressed_FireLaser
214+  8246              addr_Pressed_TargetMissle  equ KeyboardMap+c_Pressed_TargetMissle
215+  8246              addr_Pressed_FireMissile   equ KeyboardMap+c_Pressed_FireMissile
216+  8246              addr_Pressed_UnarmMissile  equ KeyboardMap+c_Pressed_UnarmMissile
217+  8246              addr_Pressed_ECM           equ KeyboardMap+c_Pressed_ECM
218+  8246              addr_Pressed_EnergyBomb    equ KeyboardMap+c_Pressed_EnergyBomb
219+  8246              addr_Pressed_EscapePod     equ KeyboardMap+c_Pressed_EscapePod
220+  8246              addr_Pressed_DockingComp   equ KeyboardMap+c_Pressed_DockingComp
221+  8246              addr_Pressed_Hyperspace    equ KeyboardMap+c_Pressed_Hyperspace
222+  8246              addr_Pressed_Distance      equ KeyboardMap+c_Pressed_Distance
223+  8246              addr_Pressed_HomeCursor    equ KeyboardMap+c_Pressed_HomeCursor
224+  8246              addr_Pressed_Launch        equ KeyboardMap+c_Pressed_Launch
225+  8246              addr_Pressed_BuyCargo      equ KeyboardMap+c_Pressed_BuyCargo
226+  8246              addr_Pressed_SellCargo     equ KeyboardMap+c_Pressed_SellCargo
227+  8246              addr_Pressed_Equip         equ KeyboardMap+c_Pressed_Equip
228+  8246              addr_Pressed_GalacticChrt  equ KeyboardMap+c_Pressed_GalacticChrt
229+  8246              addr_Pressed_LocalChart    equ KeyboardMap+c_Pressed_LocalChart
230+  8246              addr_Pressed_MarketPrices  equ KeyboardMap+c_Pressed_MarketPrices
231+  8246              addr_Pressed_Status        equ KeyboardMap+c_Pressed_Status
232+  8246              addr_Pressed_Inventory     equ KeyboardMap+c_Pressed_Inventory
233+  8246              addr_Pressed_GameSkip      equ KeyboardMap+c_Pressed_GameSkip
234+  8246              addr_Pressed_Save          equ KeyboardMap+c_Pressed_Save
235+  8246              addr_Pressed_Freeze        equ KeyboardMap+c_Pressed_Freeze
236+  8246              addr_Pressed_Resume        equ KeyboardMap+c_Pressed_Resume
237+  8246              addr_Pressed_Recentre      equ KeyboardMap+c_Pressed_Recentre
238+  8246              addr_Pressed_Quit          equ KeyboardMap+c_Pressed_Quit
239+  8246              addr_Pressed_PlanetData    equ KeyboardMap+c_Pressed_PlanetData
240+  8246              addr_Pressed_CursorUp      equ KeyboardMap+c_Pressed_CursorUp
241+  8246              addr_Pressed_CursorDown    equ KeyboardMap+c_Pressed_CursorDown
242+  8246              addr_Pressed_Find          equ KeyboardMap+c_Pressed_Find
243+  8246
244+  8246
245+  8246              init_keyboard:
246+  8246 21 8E 81     	ld		hl,Keys
247+  8249 11 28 00     	ld		de, c_KeyBoardLen
248+  824C 3E 00        	ld		a,0
249+  824E CD 53 81     	call	memfill_dma
250+  8251 C9           	ret
251+  8252
252+  8252              scan_keyboard:
253+  8252 21 B6 81     	ld		hl,RawKeys
254+  8255 11 BE 81     	ld		de,KeyAddrTab
255+  8258 AF           	xor		a
256+  8259 FD 2E 08     	ld		iyl,8
257+  825C DD 21 8E 81      ld      ix,Keys
258+  8260              .PortReadLoop:
259+  8260 1A           	ld		a,(de)							; Set up BC as port to read
260+  8261 4F           	ld		c,a
261+  8262 13           	inc		de
262+  8263 1A               ld      a,(de)
263+  8264 47           	ld		b,a
264+  8265 13           	inc		de
265+  8266 ED 78        	in		a,(c)							; read port to a
266+  8268 77           	ld		(hl),a							; set raw keys to value
267+  8269 23           	inc		hl								; and ready for next element
268+  826A 06 05        	ld		b,5								; loop all bits (there are only 5 keys to a group)
269+  826C              .ProcessBitsLoop:
270+  826C CB 47        	bit		0,a								; is bit set
271+  826E 28 07            jr      z,.SetKeyPressed
272+  8270 08               ex      af,af'
273+  8271 AF               xor     a
274+  8272 C3 7E 82         jp      .SetKey
275+  8275 20 0B        	jr		nz,.SkipKeySet
276+  8277              .SetKeyPressed:
277+  8277 08           	ex		af,af'
278+  8278 DD 7E 00         ld      a,(ix+0)
279+  827B 3C               inc     a
280+  827C E6 03            and     $3                              ; so bit 0 set is pressed, bit 1 set is repeat pressed, i.e. 0 = no, 1 = yes 2,3 = held
281+  827E              .SetKey:
282+  827E DD 77 00     	ld		(ix+0),a							; Key Pressed
283+  8281 08           	ex		af,af'
284+  8282              .SkipKeySet:
285+  8282 DD 23        	inc		ix								; move to next key
286+  8284 CB 3F        	srl		a								; move next key into bit 0
287+  8286 10 E4        	djnz	.ProcessBitsLoop				; Process all key group bits
288+  8288 FD 2D            dec     iyl
289+  828A 20 D4            jr      nz,.PortReadLoop				; Read next input port
290+  828C C9           	ret
291+  828D
292+  828D              GetKeyStateAddressDE: MACRO
293+  828D ~                                  ld      hl,KeyboardMap                  ; work our address to read from
294+  828D ~                                  add     hl,a
295+  828D ~                                  ld      a,(hl)
296+  828D ~                                  ld      e,a
297+  828D ~                                  inc     hl
298+  828D ~                                  ld      a,(hl)
299+  828D ~                                  ld      d,a                             ; now de = address in keypress list
300+  828D                                    ENDM
301+  828D
302+  828D
303+  828D              ; call with a = c_Pressed key, will then read mapping
304+  828D              wait_for_key_a_press:
305+  828D                  GetKeyStateAddressDE
305+  828D 21 CE 81    >                      ld      hl,KeyboardMap                  ; work our address to read from
305+  8290 ED 31       >                      add     hl,a
305+  8292 7E          >                      ld      a,(hl)
305+  8293 5F          >                      ld      e,a
305+  8294 23          >                      inc     hl
305+  8295 7E          >                      ld      a,(hl)
305+  8296 57          >                      ld      d,a                             ; now de = address in keypress list
306+  8297 D5               push    de
307+  8298              wait_for_key_press_loop:
308+  8298 CD 52 82         call    scan_keyboard
309+  829B E1               pop     hl                              ; get key address into hl
310+  829C E5               push    hl
311+  829D 7E               ld      a,(hl)
312+  829E                  JumpIfANENusng  1,wait_for_key_press_loop         ; will also loop if held down when entering this routine
312+  829E FE 01       >                cp     1
312+  82A0 C2 98 82    >                jp      nz,wait_for_key_press_loop
313+  82A3 E1               pop     hl                              ; tidy up rogue push, less t states than detecting if we want to push or not
314+  82A4 C9               ret
315+  82A5
316+  82A5              wait_for_key_a_held:
317+  82A5                  GetKeyStateAddressDE
317+  82A5 21 CE 81    >                      ld      hl,KeyboardMap                  ; work our address to read from
317+  82A8 ED 31       >                      add     hl,a
317+  82AA 7E          >                      ld      a,(hl)
317+  82AB 5F          >                      ld      e,a
317+  82AC 23          >                      inc     hl
317+  82AD 7E          >                      ld      a,(hl)
317+  82AE 57          >                      ld      d,a                             ; now de = address in keypress list
318+  82AF D5               push    de
319+  82B0              wait_for_key_a_held_loop:
320+  82B0 CD 52 82         call    scan_keyboard
321+  82B3 E1               pop     hl
322+  82B4 E5               push    hl
323+  82B5 7E               ld      a,(hl)
324+  82B6                  JumpIfALTNusng  2,wait_for_key_a_held_loop
324+  82B6 FE 02       >                        cp      2
324+  82B8 DA B0 82    >                        jp		c,wait_for_key_a_held_loop
325+  82BB E1               pop     hl
326+  82BC C9               ret
327+  82BD
328+  82BD              get_key_a_state:                            ; reads a mapped key and sets a to key staus, e.g. 0 1 or >=2 DOES NOT SCAN KEYBOARD
329+  82BD                  GetKeyStateAddressDE
329+  82BD 21 CE 81    >                      ld      hl,KeyboardMap                  ; work our address to read from
329+  82C0 ED 31       >                      add     hl,a
329+  82C2 7E          >                      ld      a,(hl)
329+  82C3 5F          >                      ld      e,a
329+  82C4 23          >                      inc     hl
329+  82C5 7E          >                      ld      a,(hl)
329+  82C6 57          >                      ld      d,a                             ; now de = address in keypress list
330+  82C7 EB               ex      de,hl
331+  82C8 7E               ld      a,(hl)                          ; a = keystate
332+  82C9 C9               ret
333+  82CA
334+  82CA              is_key_pressed:                             ; returns z is set if pressed
335+  82CA                  GetKeyStateAddressDE
335+  82CA 21 CE 81    >                      ld      hl,KeyboardMap                  ; work our address to read from
335+  82CD ED 31       >                      add     hl,a
335+  82CF 7E          >                      ld      a,(hl)
335+  82D0 5F          >                      ld      e,a
335+  82D1 23          >                      inc     hl
335+  82D2 7E          >                      ld      a,(hl)
335+  82D3 57          >                      ld      d,a                             ; now de = address in keypress list
336+  82D4 EB               ex      de,hl
337+  82D5 7E               ld      a,(hl)                          ; a = keystate
338+  82D6 FE 01            cp      1
339+  82D8 C9               ret
340+  82D9
341+  82D9              is_key_held:                                ; returns z is set if held
342+  82D9                  GetKeyStateAddressDE
342+  82D9 21 CE 81    >                      ld      hl,KeyboardMap                  ; work our address to read from
342+  82DC ED 31       >                      add     hl,a
342+  82DE 7E          >                      ld      a,(hl)
342+  82DF 5F          >                      ld      e,a
342+  82E0 23          >                      inc     hl
342+  82E1 7E          >                      ld      a,(hl)
342+  82E2 57          >                      ld      d,a                             ; now de = address in keypress list
343+  82E3 EB               ex      de,hl
344+  82E4 7E               ld      a,(hl)                          ; a = keystate
345+  82E5 E6 02            and     2                               ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
346+  82E7 FE 02            cp      2
347+  82E9 C9               ret
348+  82EA
349+  82EA              is_any_key_pressed:
350+  82EA 21 8E 81         ld      hl,Keys
351+  82ED 06 28            ld      b,40
352+  82EF 0E 00            ld      c,0
353+  82F1              .KeyReadLoop:
354+  82F1 7E               ld      a,(hl)
355+  82F2 FE 01            cp      1
356+  82F4 CA FE 82         jp      z,.KeyPressed
357+  82F7 23               inc     hl
358+  82F8 0C               inc     c
359+  82F9 10 F6            djnz    .KeyReadLoop
360+  82FB 3E FF            ld      a,$FF
361+  82FD C9               ret
362+  82FE              .KeyPressed:
363+  82FE 79               ld      a,c
364+  82FF C9               ret
365+  8300
366+  8300              is_any_key_held:
367+  8300 21 8E 81         ld      hl,Keys
368+  8303 06 28            ld      b,40
369+  8305 0E 00            ld      c,0
370+  8307              .KeyReadLoop:
371+  8307 7E               ld      a,(hl)
372+  8308 E6 02            and     2                               ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
373+  830A FE 02            cp      2
374+  830C CA 16 83         jp      z,.KeyPressed
375+  830F 23               inc     hl
376+  8310 0C               inc     c
377+  8311 10 F4            djnz    .KeyReadLoop
378+  8313 3E FF            ld      a,$FF
379+  8315 C9               ret
380+  8316              .KeyPressed:
381+  8316 79               ld      a,c
382+  8317 C9               ret
383+  8318
384+  8318
385+  8318 00 00 00...  InputString             DS  30              ; used for a 30 character input buffer
386+  8336 00                                   DB  0               ; end of string marker as a safety
387+  8337 00           InputCursor             DB  0
388+  8338 00           EnterPressed            DB  0               ; zero notpressed FF pressed
389+  8339 00           InputChanged            DB  0
390+  833A              InputLimit              EQU 20
391+  833A
392+  833A              keyboard_copy_input_to_de:
393+  833A 21 18 83         ld      hl,InputString
394+  833D 3A 37 83         ld      a,(InputCursor)
395+  8340 FE 00            cp      0
396+  8342 28 05            jr      z,.NoString
397+  8344 4F               ld      c,a
398+  8345 06 00            ld      b,0
399+  8347 ED B0            ldir
400+  8349              .NoString
401+  8349 3E 00            ld      a,0
402+  834B 12               ld      (de),a
403+  834C C9               ret
404+  834D
405+  834D              initInputText:
406+  834D AF               xor     a
407+  834E 32 37 83         ld      (InputCursor),a
408+  8351 32 38 83         ld      (EnterPressed),a
409+  8354 32 39 83         ld      (InputChanged),a
410+  8357 21 18 83         ld      hl,InputString
411+  835A 06 1E            ld      b,30
412+  835C              .wipeloop:
413+  835C 77               ld      (hl),a
414+  835D 23               inc     hl
415+  835E 10 FC            djnz    .wipeloop
416+  8360 C9               ret
417+  8361
418+  8361              InputName:
419+  8361 AF               xor     a
420+  8362 32 39 83         ld      (InputChanged),a
421+  8365 CD EA 82         call    is_any_key_pressed
422+  8368 FE FF            cp      $FF
423+  836A C8               ret     z
424+  836B              .KeyPressed:
425+  836B 4F               ld      c,a
426+  836C 3A 37 83         ld      a,(InputCursor)                 ; No key so we can now look at if we are at the end of the buffer
427+  836F FE 14            cp      InputLimit                      ; move to variable later and then cp (hl)
428+  8371 28 0B            jr      z,.DeleteOrEnterOnly            ;
429+  8373 21 1E 82         ld      hl,ASCII_Map
430+  8376 79               ld      a,c
431+  8377 ED 31            add     hl,a
432+  8379 7E               ld      a,(hl)
433+  837A FE 41            cp      "A"
434+  837C 30 15            jr      nc,.AlphaPressed
435+  837E              .DeleteOrEnterOnly                          ; CAPS and Symbol act as delete for now
436+  837E FE 30            cp      "0"                             ; if 0 was preseed check caps shift too
437+  8380 28 3B            jr      z,.CheckShiftDelete             ; for now we will ignore the shift and just assume delete
438+  8382 FE 3E            cp      ">"         ; ENTER
439+  8384 28 24            jr      z,.EnterPressed
440+  8386 FE 23            cp      "#"         ; CAPS
441+  8388 28 33            jr      z,.CapsPressed
442+  838A FE 5E            cp      "^"         ; SYMBOLSHIFT
443+  838C 28 2F            jr      z,.SymbolPressed
444+  838E FE 20            cp      " "         ; space
445+  8390 28 2B            jr      z,.SpacePressed
446+  8392 C9               ret
447+  8393              .AlphaPressed:
448+  8393 47               ld      b,a
449+  8394 3A 37 83         ld      a,(InputCursor)
450+  8397 4F               ld      c,a
451+  8398 21 18 83         ld      hl,InputString
452+  839B ED 31            add     hl,a
453+  839D 78               ld      a,b
454+  839E 70               ld      (hl),b
455+  839F 79               ld      a,c
456+  83A0 21 37 83         ld      hl,InputCursor
457+  83A3 34               inc     (hl)
458+  83A4 3E FF            ld      a,$FF
459+  83A6 32 39 83         ld      (InputChanged),a
460+  83A9 C9               ret
461+  83AA              .EnterPressed:
462+  83AA 3A 37 83         ld      a,(InputCursor)
463+  83AD 3C               inc     a
464+  83AE 21 18 83         ld      hl,InputString
465+  83B1 ED 31            add     hl,a
466+  83B3 AF               xor     a
467+  83B4 77               ld      (hl),a
468+  83B5 3D               dec     a
469+  83B6 32 38 83         ld      (EnterPressed),a
470+  83B9 32 39 83         ld      (InputChanged),a
471+  83BC C9               ret
472+  83BD              .CheckShiftDelete:
473+  83BD              .CapsPressed:                               ; act as a delete key for now
474+  83BD              .SymbolPressed:
475+  83BD              .SpacePressed:
476+  83BD 3A 37 83         ld      a,(InputCursor)
477+  83C0 FE 00            cp      0
478+  83C2 C8               ret     z
479+  83C3 3D               dec     a
480+  83C4 32 37 83         ld      (InputCursor),a
481+  83C7 21 18 83         ld      hl,InputString
482+  83CA ED 31            add     hl,a
483+  83CC AF               xor     a
484+  83CD 77               ld      (hl),a
485+  83CE 3E FF            ld      a,$FF
486+  83D0 32 39 83         ld      (InputChanged),a
487+  83D3 C9               ret
488+  83D4
489+  83D4              MovementKeyTest:
490+  83D4              ;DBG1:jp dbg1
491+  83D4              ;dbx1:
492+  83D4 AF               xor     a
493+  83D5 32 51 85         ld      (CursorKeysPressed),a
494+  83D8 3A 53 85         ld      a,(MenuIdMax)
495+  83DB E6 FC            and     $FC
496+  83DD 20 28            jr      nz,CursorKeys
497+  83DF              ClimbDiveKeys:
498+  83DF 2A DC 81         ld      hl,(addr_Pressed_Climb)
499+  83E2 7E               ld      a,(hl)
500+  83E3                  IfAIsZeroGoto ScanDiveKey
500+  83E3 FE 00       >				cp	0
500+  83E5 CA F3 83    >				jp	z,ScanDiveKey
501+  83E8 3A 51 85         ld      a,(CursorKeysPressed)
502+  83EB F6 80            or      $80
503+  83ED 32 51 85         ld      (CursorKeysPressed),a
504+  83F0 C3 2C 84         jp      ScanLeftKey
505+  83F3              ScanDiveKey:
506+  83F3 2A DA 81         ld      hl,(addr_Pressed_Dive)
507+  83F6 7E               ld      a,(hl)
508+  83F7                  IfAIsZeroGoto ScanLeftKey
508+  83F7 FE 00       >				cp	0
508+  83F9 CA 2C 84    >				jp	z,ScanLeftKey
509+  83FC 3A 51 85         ld      a,(CursorKeysPressed)
510+  83FF F6 40            or      $40
511+  8401 32 51 85         ld      (CursorKeysPressed),a
512+  8404 C3 2C 84         jp      ScanLeftKey
513+  8407              CursorKeys:
514+  8407 2A 18 82         ld      hl,(addr_Pressed_CursorUp)
515+  840A 7E               ld      a,(hl)
516+  840B                  IfAIsZeroGoto ScanCursorDownKey
516+  840B FE 00       >				cp	0
516+  840D CA 1B 84    >				jp	z,ScanCursorDownKey
517+  8410 3A 51 85         ld      a,(CursorKeysPressed)
518+  8413 F6 80            or      $80
519+  8415 32 51 85         ld      (CursorKeysPressed),a
520+  8418 C3 2C 84         jp      ScanLeftKey
521+  841B              ScanCursorDownKey
522+  841B 2A 1A 82         ld      hl,(addr_Pressed_CursorDown)
523+  841E 7E               ld      a,(hl)
524+  841F                  IfAIsZeroGoto ScanLeftKey
524+  841F FE 00       >				cp	0
524+  8421 CA 2C 84    >				jp	z,ScanLeftKey
525+  8424 3A 51 85         ld      a,(CursorKeysPressed)
526+  8427 F6 40            or      $40
527+  8429 32 51 85         ld      (CursorKeysPressed),a
528+  842C              ScanLeftKey:
529+  842C 2A D6 81         ld      hl,(addr_Pressed_RollLeft)
530+  842F 7E               ld      a,(hl)
531+  8430                  IfAIsZeroGoto ScanRightKey
531+  8430 FE 00       >				cp	0
531+  8432 CA 3E 84    >				jp	z,ScanRightKey
532+  8435 3A 51 85         ld      a,(CursorKeysPressed)
533+  8438 F6 20            or      $20
534+  843A 32 51 85         ld      (CursorKeysPressed),a
535+  843D C9               ret
536+  843E              ScanRightKey:
537+  843E 2A D8 81         ld      hl,(addr_Pressed_RollRight)
538+  8441 7E               ld      a,(hl)
539+  8442                  IfAIsZeroGoto ScanHomeKey
539+  8442 FE 00       >				cp	0
539+  8444 CA 50 84    >				jp	z,ScanHomeKey
540+  8447 3A 51 85         ld      a,(CursorKeysPressed)
541+  844A F6 10            or      $10
542+  844C 32 51 85         ld      (CursorKeysPressed),a
543+  844F C9               ret
544+  8450              ScanHomeKey:
545+  8450 2A F6 81         ld      hl,(addr_Pressed_HomeCursor)
546+  8453 7E               ld      a,(hl)
547+  8454                  IfAIsZeroGoto ScanRecentreKey
547+  8454 FE 00       >				cp	0
547+  8456 CA 62 84    >				jp	z,ScanRecentreKey
548+  8459 3A 51 85         ld      a,(CursorKeysPressed)
549+  845C F6 08            or      $08
550+  845E 32 51 85         ld      (CursorKeysPressed),a
551+  8461 C9               ret
552+  8462              ScanRecentreKey:
553+  8462 2A 12 82         ld      hl,(addr_Pressed_Recentre)
554+  8465 7E               ld      a,(hl)
555+  8466                  ReturnIfAIsZero
555+  8466 FE 00       >                 cp     0
555+  8468 C8          >                 ret    z
556+  8469 3A 51 85         ld      a,(CursorKeysPressed)
557+  846C F6 04            or      $04
558+  846E 32 51 85         ld      (CursorKeysPressed),a
559+  8471 C9               ret
560+  8472
561+  8472
# file closed: ./Hardware/keyboard.asm
150   8472
151   8472                  INCLUDE "./Variables/constant_equates.asm"
# file opened: ./Variables/constant_equates.asm
  1+  8472              ;Contants
  2+  8472
  3+  8472              SignMask8Bit		equ %01111111
  4+  8472              SignMask16Bit		equ %0111111111111111
  5+  8472              SignOnly8Bit		equ $80
  6+  8472              SignOnly16Bit		equ $8000
  7+  8472
  8+  8472              ConstPi				equ $80
  9+  8472              ConstNorm           equ 197
 10+  8472
 11+  8472              ;Text Tokens
 12+  8472              EliteToken			equ $1E			; Token ID for text messsage ---- E L I T E ----
 13+  8472              BrabenBellToken 	equ $0D
 14+  8472              AcorToken			equ $0C
 15+  8472
 16+  8472              ; Intro Screen
 17+  8472              TitleShip			equ	$8C
 18+  8472              RotationUnity		equ $60
 19+  8472              DBCheckCode			equ $DB
 20+  8472              MaxVisibility		equ $1F
 21+  8472              FarInFront			equ $C0
 22+  8472
 23+  8472              ; Universe Managment
 24+  8472              MaxNumberOfStars	equ 18
 25+  8472              FreeListSize		equ	$12
 26+  8472              ShipTypeSize		equ	32 			;??????? just a guess for now
 27+  8472              ShipSST				equ 4			; its a space station
 28+  8472              UniverseBasePage 	equ 70			; Base memory bank for universe Item #0
 29+  8472              ShipDataBasePage	equ	90			; Needs 2mb upgrade but what the heck
 30+  8472              ShipCountMax		equ	2			; For now just 2 ships to debug
 31+  8472              LineLimitPerShip	equ 70			; Max lines per ship
 32+  8472              FaceLimitPerShip	equ	70			; Same as line limit to simplify some logic
 33+  8472              ; "NEED TO DEFINE SHIPTYPESIZE TODO"
 34+  8472              PlayerDocked		equ	$FF
 35+  8472
 36+  8472              ; Memory page managment	(Refers to a memory slot as a place to access data)
 37+  8472              ShipDataSlot		equ	6			; this may move into rom swap out space later
 38+  8472              UniverseObjectSlot	equ	7
 39+  8472
 40+  8472              KeyForwardsView		equ	$20
 41+  8472
 42+  8472              ; Ship Data
 43+  8472              ;;;;	.XX21	\ -> &5600 \ Table of pointers to ships' data given to XX0
 44+  8472              ;;;;00 7F			 EQUW &7F00 \ type  1 is #MSL  Missile data on page off bottom of screen
 45+  8472              ;;;;00 00			 EQUW 0     \ type  2 is #SST  Space Station, Coriolis or Dodo.
 46+  8472              ;;;;00 00			 EQUW 0     \ type  3 is #ESC  Escape capsule
 47+  8472              ;;;;00 00			 EQUW 0     \ type  4 is #PLT  Plate, alloys
 48+  8472              ;;;;00 00			 EQUW 0     \ type  5 is #OIL  Cargo cannister
 49+  8472              ;;;;00 00			 EQUW 0     \ type  6 is       Boulder
 50+  8472              ;;;;00 00			 EQUW 0     \ type  7 is #AST  Asteroid
 51+  8472              ;;;;00 00			 EQUW 0     \ type  8 is #SPL  Splinter, rock.
 52+  8472              ;;;;00 00			 EQUW 0     \ type  9 is #SHU  Shuttle
 53+  8472              ;;;;00 00			 EQUW 0     \ type 10 is       Transporter
 54+  8472              ;;;;00 00			 EQUW 0     \ type 11 is #CYL  Cobra Mk III,  Boa
 55+  8472              ;;;;00 00			 EQUW 0     \ type 12 is       Python
 56+  8472              ;;;;00 00			 EQUW 0     \ type 13 is       Last of three traders
 57+  8472              ;;;;00 00			 EQUW 0     \ type 14 is #ANA  Anaconda
 58+  8472              ;;;;00 00			 EQUW 0     \ type 15 is #WRM  Worm with Anaconda
 59+  8472              ;;;;00 00			 EQUW 0     \ type 16 is #COP  Viper
 60+  8472              ;;;;00 00			 EQUW 0     \ type 17 is       First pirate
 61+  8472              ;;;;00 00			 EQUW 0     \ type 18 is
 62+  8472              ;;;;00 00			 EQUW 0     \ type 19 is #KRA  Krait small pirate
 63+  8472              ;;;;00 00			 EQUW 0     \ type 20 is #ADA  Adder
 64+  8472              ;;;;00 00			 EQUW 0     \ type 21 is
 65+  8472              ;;;;00 00			 EQUW 0     \ type 22 is
 66+  8472              ;;;;00 00			 EQUW 0     \ type 23 is
 67+  8472              ;;;;00 00			 EQUW 0     \ type 24 is #CYL2 Last strong pirate
 68+  8472              ;;;;00 00			 EQUW 0     \ type 25 is #ASP  Asp Mk II
 69+  8472              ;;;;00 00			 EQUW 0     \ type 26 is #FER  Fer de Lance
 70+  8472              ;;;;00 00			 EQUW 0     \ type 27 is
 71+  8472              ;;;;00 00			 EQUW 0     \ type 28 is	Last of three bounty hunters
 72+  8472              ;;;;00 00			 EQUW 0     \ type 29 is #THG  Thargoid
 73+  8472              ;;;;00 00			 EQUW 0     \ type 30 is #TGL  Thargon
 74+  8472              ;;;;00 00			 EQUW 0     \ type 31 is #CON  Constrictor
 75+  8472              ;;;;	.E%	\ -> &563E \ Hull NEWB bits are escpod, cop, inno, ?, pirate, angry, hunter, trader.
 76+  8472              ;;;;			\ NEWB examples
 77+  8472              ;;;;\ 21			EQUB &21    \ 0010 0001    9 Shuttle has no escape pod, inno, trader.
 78+  8472              ;;;;\ 61			EQUB &61    \ 0110 0001   10 Tansporter no escape pod, Cop, inno, trader.
 79+  8472              ;;;;\ A0			EQUB &A0    \ 1010 0000   11 Cobra has Escape pod, inno, not a trader.
 80+  8472              ;;;;\ C2			EQUB &C2    \ 1100 0010   16 Viper has Escape pod, Cop, hunter.
 81+  8472              ;;;;\ 8C			EQUB &8C    \ 1000 1100   19 Krait pirate has escape pod, is pirate and angry.
 82+  8472
# file closed: ./Variables/constant_equates.asm
152   8472                  INCLUDE "./Variables/general_variables.asm"
# file opened: ./Variables/general_variables.asm
  1+  8472              ;	PAGE 0 Map to variable anmes
  2+  8472              ;	PAGE 0 Map to variable anmes
  3+  8472              ;
  4+  8472              ;
  5+  8472              ;
  6+  8472              ;	06		T1
  7+  8472              ;	07
  8+  8472              ;	08		SC1					Screen Hi
  9+  8472              ;	09							XX16 Matrix
 10+  8472              ;	0A							XX16+1
 11+  8472              ;	0B							XX16+2
 12+  8472              ;	0C							XX16+3
 13+  8472              ;	0D                          XX16+4
 14+  8472              ;	0E                          XX16+5
 15+  8472              ;	0F							XX16+6
 16+  8472              ;	10		varP				XX16+7
 17+  8472              ;	11		varP				XX16+8
 18+  8472              ;	12                          XX16+9
 19+  8472              ;	13                          XX16+10
 20+  8472              ;	14							XX16+11
 21+  8472              ;	15                          XX16+12
 22+  8472              ;	16                          XX16+13
 23+  8472              ;	17                          XX16+14
 24+  8472              ;	17                          XX16+14
 25+  8472              ;	18                          XX16+15
 26+  8472              ;	19
 27+  8472              ;	1A
 28+  8472              ;	1B
 29+  8472              ;	1C
 30+  8472              ;	1D
 31+  8472              ;	1E							XX0
 32+  8472              ;	1F                          XX0+1
 33+  8472              ;	20		INF                 XX0+2
 34+  8472              ;	21      INF+1               XX0+3
 35+  8472              ;	22      varV                XX0+4
 36+  8472              ;	23      varV +1             XX0+5
 37+  8472              ;	24		XXlo                XX0+6
 38+  8472              ;	25		XXHi
 39+  8472              ;	26		YYlo
 40+  8472              ;	27		YYHi
 41+  8472              ;	28
 42+  8472              ;	29
 43+  8472              ;	2A		BETA (pitch done)
 44+  8472              ;	2B		BET1 lower7 magnitude
 45+  8472              ;	2C		XC
 46+  8472              ;	2D		YC
 47+  8472              ;	2E		QQ22				Outer Hyperspace Countdown
 48+  8472              ;	2E		QQ22				Outer Hyperspace Countdown
 49+  8472              ;	2F		QQ22+1				Inner Hyperspace Countdown
 50+  8472              ;	30		ECM Active
 51+  8472              ;	31		ALP1
 52+  8472              ;	32		ALP2
 53+  8472              ;	33		ALP2FLIP
 54+  8472
 55+  8472              ;	36		Z1					XX15+2yscaled
 56+  8472              ;	37		                    XX15+3ysign
 57+  8472              ;	38		                    XX15+4zscaled
 58+  8472              ;	39							XX15+5zsign
 59+  8472              ;	3A		XX12				xplot for star
 60+  8472              ;	3B
 61+  8472              ;	3C
 62+  8472              ;	3D
 63+  8472              ;	3E
 64+  8472              ;	3F
 65+  8472              ;	40		varKlo
 66+  8472              ;	41		varKmid
 67+  8472              ;	42		varKHi
 68+  8472              ;	43		varKVeryHi+Sign
 69+  8472              ;	44
 70+  8472              ;	45		MSTG				MissileTarget
 71+  8472              ;	46		INWK				; Inner working space of 37 bytes
 72+  8472              ;	47		INWK
 73+  8472              ;	48		INWK
 74+  8472              ;	49		INWK
 75+  8472              ;	4A		INWK
 76+  8472              ;	4B		INWK
 77+  8472              ;	4C		INWK
 78+  8472              ;	4D		INWK
 79+  8472              ;	4E		INWK
 80+  8472              ;	4F		INWK+9
 81+  8472              ;	50		INWK
 82+  8472              ;	51		INWK
 83+  8472              ;	52		INWK
 84+  8472              ;	53		INWK
 85+  8472              ;	54		INWK
 86+  8472              ;	55		INWK
 87+  8472              ;	56		INWK
 88+  8472              ;	57		INWK
 89+  8472              ;	58		INWK
 90+  8472              ;	59		INWK
 91+  8472              ;	5A		INWK
 92+  8472              ;	5B		INWK
 93+  8472              ;	5C		INWK
 94+  8472              ;	5D		INWK
 95+  8472              ;	5E		INWK
 96+  8472              ;	5F		INWK
 97+  8472              ;	60		INWK
 98+  8472              ;	61		INWK
 99+  8472              ;	62		INWK
100+  8472              ;	63		INWK
101+  8472              ;	64		INWK
102+  8472              ;	65		INWK31				 clear exploding/display state|missiles
103+  8472              ;	66		INWK
104+  8472              ;	67		INWK				XX19
105+  8472              ;	68		INWK
106+  8472              ;	69		INWK
107+  8472              ;	6A		INWK36
108+  8472              ;	6B
109+  8472              ;	6C		QQ15				Current Seed
110+  8472              ;	6D		QQ15+1
111+  8472              ;	6E		QQ15+2
112+  8472              ;	6F		QQ15+3
113+  8472              ;	70		QQ15+4
114+  8472              ;	71
115+  8472              ;	72		XX18   xlo			QQ17
116+  8472              ;	73		XX18+1 xhi
117+  8472              ;	74		XX18+2 xsgn
118+  8472              ;	75		XX18   ylo
119+  8472              ;	76		XX18+1 yhi
120+  8472              ;	77		XX18+2 ysgn
121+  8472              ;	78		XX18   zlo
122+  8472              ;	79		XX18+1 zhi
123+  8472              ;	7A		XX18+2 zsgn
124+  8472              ;	7B		BET2				Pitch Sign
125+  8472              ;	7C		BET2FLIP
126+  8472              ;	7D		DELTA
127+  8472              ;	7E		DELT4Lo
128+  8472              ;	7F		DELT4Hi
129+  8472              ;	80
130+  8472              ;	81		varQ
131+  8472              ;	82		varR
132+  8472              ;	83		varS
133+  8472              ;	84		XSAV
134+  8472              ;	85		YSAV
135+  8472              ;	86		XX17
136+  8472              ;	87		MenuIdMax		QQ11
137+  8472              ;	88		ZZDust
138+  8472              ;	89
139+  8472              ;	8A		MCNT			Move Count
140+  8472              ;	8B		ALPHA
141+  8472              ;	8C		TYPE
142+  8472              ;	8D
143+  8472              ;	8E		DockedFlag		QQ12
144+  8472              ;	8F
145+  8472              ;	96		XX4				Nbr of Normals Visible
146+  8472              ;
147+  8472              ;   9F      POINT
148+  8472              ;	D0
149+  8472              ;	D1		varT
150+  8472              ;array list of each face during draw flagged visible or not
151+  8472              ;	D2      XX2
152+  8472              ;	D3      XX2+1
153+  8472              ;	D4      XX2+2
154+  8472              ;	D5      XX2+3
155+  8472              ;	D6      XX2+4
156+  8472              ;	D7      XX2+5
157+  8472              ;	D8      XX2+6
158+  8472              ;	D9      XX2+7
159+  8472              ;	DA      XX2+8
160+  8472              ;	DB      XX2+9
161+  8472              ;	DC      XX2+10
162+  8472              ;	DD      XX2+11
163+  8472              ;	DE      XX2+12
164+  8472              ;	DF		XX2+13
165+  8472              ;	E0		XX2+14
166+  8472              ;	E1		XX2+15
167+  8472              ;	E2
168+  8472              ;	E3
169+  8472              ;	E4
170+  8472              ;	E5
171+  8472              ;	E6
172+  8472              ;	E7
173+  8472              ;	E8
174+  8472              ;	E9
175+  8472              ;	EA
176+  8472              ;	EB
177+  8472              ;	EC
178+  8472              ;	ED
179+  8472              ;	EE
180+  8472              ;	8F
181+  8472
182+  8472 00 00        varAxis1	DW 	0				; address of first axis in a rotation action
183+  8474 00 00        varAxis2	DW	0				; address of 2nd axis in a roation action
184+  8476              ; Variables to simulate 6502 registers until code fixed
185+  8476              ; These must be here in this order as reading Y and X can then be a 16 bit read
186+  8476 00           regX		DB	0               ; using 16 bit read into BC this would go into C
187+  8477 00           regY		DB	0               ; using 16 bit read into BC this would go into B
188+  8478 00           regA		DB	0
189+  8479
190+  8479
191+  8479 00           varGPLoopA	DB	0				; General Purpose innermost loop variable
192+  847A 00 00        INF			DW	0				; page 0 &20 Used to get address from UNIV array
193+  847C 00 00        INF28		DW	0				; page 0 &20 Used to get address from UNIV array
194+  847E
195+  847E
196+  847E
197+  847E              ;XX16		DS	16				; 16 byte Matrix
198+  847E
199+  847E              P0INWK							; page 0 & 46
200+  847E              p0INWK31						; page 0 & 65
201+  847E              P0INWK36						; PAGE 0 &6A
202+  847E
203+  847E 00           XX4			DB	0				; XX4 page 0 &96 last Normal Found to be visible
204+  847F              LastNormalVisible	equ	XX4
205+  847F              varXX4              equ XX4
206+  847F
207+  847F
208+  847F
209+  847F 00           PATG		DB	0				; 6502 &03C9
210+  8480 00 00        SLSP 		DW	0				; &03B0 \ SLSP \ ship lines pointer
211+  8482
212+  8482
213+  8482 00 00 00...  UNIV		DS FreeListSize*2	; Array of Universe Pointers
214+  84A6 00 00 00...  HULLINDEX	DS ShipTypeSize*2	; hull index for table at XX21= &5600 XX21-1,Y
215+  84E6
216+  84E6              ; Present System Variables
217+  84E6
218+  84E6 2B           RandomSeed				DB	43			; 00 DEBUG JUST SOME START VALUES
219+  84E7 20           RandomSeed1				DB	32	; 01
220+  84E8 0C           RandomSeed2				DB	12			; 02
221+  84E9 42           RandomSeed3				DB	66			; 03
222+  84EA
223+  84EA 00           varT1					DB	0				; 06
224+  84EB 00           SClo					DB 0				; 07
225+  84EC 00           SChi					DB 0				; 08
226+  84ED 00           varP					DB 0 				; 10	XX16+7
227+  84EE 00           varPhi					DB 0 				; 11	XX16+8
228+  84EF 00           varPhi2					DB 0 				; 12	XX16+9
229+  84F0              varPp1                  equ varPhi
230+  84F0              varPp2                  equ varPhi2
231+  84F0 00           UnivPointerLo			DB	0				; 20		INF                 XX0+2
232+  84F1 00           UnivPointerHi			DB	0				; 21      INF+1               XX0+3
233+  84F2              UnivPointer				equ	UnivPointerLo
234+  84F2 00           varV					DB 0				; 22                          XX0+4
235+  84F3 00           varVHi					DB 0				; 23                          XX0+5
236+  84F4 00           varXXlo                 DB 0                ; 24
237+  84F5 00           varXXHi                 DB 0                ; 25
238+  84F6              varXX					equ	varXXlo
239+  84F6 00           YYlo                    DB 0                ; 26
240+  84F7 00           YYHi                    DB 0                ; 27
241+  84F8              varYY					equ	YYlo
242+  84F8              											;	28
243+  84F8              											;	29
244+  84F8              ;PlayerShipPositionData - Must be contiguous for setup
245+  84F8 00           BETA 					DB	0               ; 2A        (pitch done)
246+  84F9 00           JSTY                    DB  0               ; Joystick analog
247+  84FA 00           BET1 					DB	0               ; 2B        lower7 magnitude
248+  84FB 00           BET2                    DB  0               ;            climb sign
249+  84FC 00           BET2FLIP				DB	0				; 7C		BET 2 pitch Sign negated
250+  84FD 1F           BET1MAXC                DB  31              ; max climb
251+  84FE E1           BET1MAXD                DB  -31             ; max dive
252+  84FF 00           XC						DB	0               ; 2C
253+  8500 00           YC						DB 	0               ; 2D
254+  8501 00           OuterHyperCount			DB 	0				; 2E		TODO Replace with 16 bit counter later
255+  8502 00           InnerHyperCount			DB 	0				; 2F
256+  8503 00           ECMActive				DB 	0				; 30		ECM Active flag
257+  8504 00 00        JSTX                    DW  0               ;           Joystick analog value
258+  8506
259+  8506 00           ALP1					DB 	0				; 31		ALP1	Roll magnitude
260+  8507 00           ALP2					DB  0				; 32		ALP2	Roll Sign
261+  8508 00           ALP2FLIP				DB  0				; 33		ALP2	negated roll sign
262+  8509 1F           ALP1MAXR                DB  31               ;   Maximum roll, added becuase we may allow different ship types
263+  850A E1           ALP1MAXL                DB  -31             ;   Maximum roll, added becuase we may allow different ship types
264+  850B
265+  850B 00 00        MissileTarget			DW	0				; 45
266+  850D 00 00 00...  IndexedWork				DS	37				; General purpose work space when doing temp arrays
267+  8532
268+  8532              ; MOVED TO Universe XX19					DB	0				; page 0 &67
269+  8532              ; MOVED TO Universe XX20					DB	0				; page 0 &67 also used as XX19+1 for XX19 being a word
270+  8532              NormalCountCopyBy4		equ	XX20			; Also used for normal * 4 holding variable
271+  8532 00           XX21					DB  0				; this may be part of XX20/xx21 accordign to spawn new shipXX21		DW	0				; Ah XX21 is hull pointer  hull pointer lo as it can;t hold HULLINDX as 16bit array
272+  8533              ;XX21 is the pointer table to the pages for ship types. this will be repalaced by paging so just need an equate for first page
273+  8533
274+  8533
275+  8533 00 00 00...  SystemSeed				DS  5				;	6C		QQ15	Current Galaxy Seed
276+  8538              											;	6D		QQ15+1
277+  8538              											;	6E		QQ15+2
278+  8538              											;	6F		QQ15+3
279+  8538              											;	70		QQ15+4
280+  8538              											;	71		QQ15+5
281+  8538 00           QQ17					DB	0				;   72
282+  8539 00           XX18xlo                 DB  0               ;	72		XX18   xlo
283+  853A 00           XX18xhi                 DB  0               ;	73		XX18+1 xhi
284+  853B 00           XX18xsg                 DB  0               ;	74		XX18+2 xsgn
285+  853C 00           XX18ylo                 DB  0               ;	75		XX18   ylo
286+  853D 00           XX18yhi                 DB  0               ;	76		XX18+1 yhi
287+  853E 00           XX18ysg                 DB  0               ;	77		XX18+2 ysgn
288+  853F 00           XX18zlo                 DB  0               ;	78		XX18   zlo
289+  8540 00           XX18zhi                 DB  0               ;	79		XX18+1 zhi
290+  8541 00           XX18zsg                 DB  0               ;	7A		XX18+2 zsgn
291+  8542
292+  8542 28           SHIPMAXSPEED            DB  40              ; variable to facilitate ship editing later
293+  8543 00           DELTA					DB 	0				; 7D 		DELTA  \ bpl -2 inserted here to stall from title code if byte check fails
294+  8544 00           DELT4Lo					DB 	0				; 7E
295+  8545 00           DELT4Hi					DB 	0				; 7F
296+  8546              DELTA4                  equ                 DELT4Lo
297+  8546
298+  8546
299+  8546              ; Not thise must be in this order else 16 bit fetches will fail
300+  8546 00           varU                    DB  0               ;   80
301+  8547 00           varQ					DB  0 				;	81
302+  8548 00           varR					DB  0 				;	82
303+  8549 00           varS					DB  0 				;	83
304+  854A              varRS                   equ varR
305+  854A
306+  854A 00 00        varU16                  DW  0               ; 16 bit variant on varU as I can't use above for this
307+  854C
308+  854C 00           XSAV					DB	0				; 84	   XSAV usef for nearby ship count outer
309+  854D 00           YSAV                    DB  0               ; 85
310+  854E 00           XX17					DB	0				; 86
311+  854F              RequiredScale			equ  XX17			; use to hold calculated scale in drawing ship
312+  854F              varXX17                 equ  XX17
313+  854F 00           ScreenChanged           DB  0
314+  8550 00           ScreenIndex             DB  0
315+  8551 00           CursorKeysPressed       DB  0               ; mapping of the current key presses
316+  8552                                                          ; 7    6    5    4     3    2        1    0
317+  8552                                                          ; Up   Down Left Right Home Recentre
318+  8552 00           InvertedYAxis           DB  0
319+  8553 00           MenuIdMax				DB	0				;	87		MenuIdMax		QQ11
320+  8554              											; Bit 7 Set  ShortRangeChart    $80
321+  8554              											; Bit 6 Set  Galactic Chart     $40
322+  8554              											; Bit 5 Set  Market Place       $20
323+  8554              											; Bit 4 Set  Status Screen      $10
324+  8554              											; Bit 3 Set  Display Inventory  $08
325+  8554                                                          ; Bit 2 Set  Planet Data        $04
326+  8554                                                          ; View bit combinations if the ones above not matched
327+  8554                                                          ; bits 1 0
328+  8554                                                          ;      1 1  Front view , i.e. $03
329+  8554                                                          ;      1 0  Aft View          $02
330+  8554                                                          ;      0 1  Left View         $01
331+  8554                                                          ;      0 0  Right view        $00
332+  8554              											; Bit 0 Set  Data On System
333+  8554              											; 0  Space View (Not a menu)
334+  8554 00           ZZDust					DB	0				;	88		ZZDust (Poss 16 bit need to check)
335+  8555 00           XX13                    DB  0               ;   89
336+  8556 00           MCNT					DB 	0				; 8A
337+  8557 00           TYPE					DB	0				; 8C used for ship type in drawing
338+  8558 00           ALPHA					DB	0				; 8D
339+  8559 00           DockedFlag				DB	0				; 8E
340+  855A 00           GamePaused              DB  0
341+  855B 00           varSWAP                 DB  0               ; 90 , general purpose swap variable
342+  855C 00           varCNT                  DB  0               ; 93
343+  855D 00           varRAT                  DB  0               ; 99
344+  855E 00           varRAT2                 DB  0               ; 9A
345+  855F
346+  855F 00           varK					DB	0				; 40
347+  8560 00           varKp1					DB	0				; 41
348+  8561 00           varKp2					DB	0				; 42
349+  8562 00           varKp3					DB	0				; 43
350+  8563
351+  8563 00           varK2                   DB  0               ; 9B
352+  8564 00           varK2p1                 DB  0               ; 9C K2 plus 1
353+  8565 00           varK2p2                 DB  0               ; 9D K2 plus 2
354+  8566 00           varK2p3                 DB  0               ; 9E K2 plus 3
355+  8567
356+  8567 00           Point                   DB  0               ; 9F      POINT
357+  8568
358+  8568 00           varT					DB	0				; D1
359+  8569
360+  8569 00 00 00 00  varK3					DS	4				; D2
361+  856D 00           varK3p2					DB	0				; 42
362+  856E 00           varK3p3					DB	0				; 43
363+  856F              varK3p1					equ varK3+1			; D3
364+  856F 00 00 00 00  varK4					DS	4				; E0
365+  8573              varK4p1					equ varK4+1			; D3
366+  8573
367+  8573              ;PlayerData:
368+  8573 00           PlayerForwardSheild0	DB	0 ; ?????
369+  8574 00           PlayerForwardSheild1    DB	0
370+  8575 00           PlayerForwardSheild2    DB	0
371+  8576
372+  8576
373+  8576              ;Heap
374+  8576
375+  8576 00 00        HeapStart				DS	2				; &0100 XX3 50 bytes for now
376+  8578 00 00 00...  HeapData				DS	50
377+  85AA              ; Contains 				X 16 bit, Y 16 bit
378+  85AA              ;RuntimeData:
379+  85AA              HeapHead				equ HeapStart
380+  85AA
381+  85AA 00 00 00...  FRIN					DS FreeListSize		; &0311 for 12 bytes Array of Free Index - Now array of while universe pages are occupied
382+  85BC              FreeUniverseSlotList    EQU FRIN
383+  85BC 00           SUN						DB	0				; &031D Actually MANY -1? As we can only have 1?
384+  85BD 00           MANY					DB	0				; &031E array of ship types???
385+  85BE 00           SpaceStationPresent		DB	0				; &0320	Wonder if many is counter of type in univ objects?
386+  85BF 00           						DB	0				; &0321	Speculative?
387+  85C0 00           						DB	0				; &0322	Speculative?
388+  85C1 00           						DB	0				; &0323	Speculative?
389+  85C2 00           						DB	0				; &0324	Speculative?
390+  85C3 00           						DB	0				; &0325	Speculative?
391+  85C4 00           						DB	0				; &0326	Speculative?
392+  85C5 00           						DB	0				; &0327	Speculative?
393+  85C6 00           TransporterPresent		DB	0				; &0328	MANY + 10 (or #SHU + 1)
394+  85C7 00           						DB	0				; &0329	MANY + 11 Speculative?
395+  85C8 00           				        DB	0				; &032A	MANY + 12 Speculative?
396+  85C9 00           				        DB	0				; &032B	MANY + 13 Speculative?
397+  85CA 00           				        DB	0				; &032C	MANY + 14 Speculative?
398+  85CB 00           				        DB	0				; &032D	MANY + 15 Speculative?
399+  85CC 00           				        DB	0				; &032E	MANY+COPS #COP Confirmed in code
400+  85CD 00           				        DB	0				; &032F	MANY + 17 Speculative?
401+  85CE 00           				        DB	0				; &0330	MANY + 18 Speculative?
402+  85CF 00           				        DB	0				; &0331	MANY + 19 Speculative?
403+  85D0 00           						DB	0				; &0332	MANY + 20 Speculative?
404+  85D1 00           				        DB	0				; &0333	MANY + 21 Speculative?
405+  85D2 00           				        DB	0				; &0334	MANY + 22 Speculative?
406+  85D3 00           				        DB	0				; &0335	MANY + 23 Speculative?
407+  85D4 00           				        DB	0				; &0336	MANY + 24 Speculative?
408+  85D5 00           				        DB	0				; &0337	MANY + 25 Speculative?
409+  85D6 00           				        DB	0				; &0338	MANY + 26 Speculative?
410+  85D7 00           				        DB	0				; &0339	MANY + 27 Speculative?
411+  85D8 00           				        DB	0				; &033A	MANY + 28 Speculative?
412+  85D9 00           				        DB	0				; &033B	MANY + 29 Speculative?
413+  85DA 00           				        DB	0				; &033C	MANY + 30 Thargoids
414+  85DB 00           				        DB	0				; &033D	MANY + 31 Constrictor?
415+  85DC 00           JunkCount				DB  0				; $033E
416+  85DD 00           PlayerMisJump			DB	0				; $0341 witchspace misjump
417+  85DE 00           CabinTemp				DB	0				; $0342
418+  85DF 00           MissileArmedStatus		DB	0				; 0344 MSAR
419+  85E0 00           View					DB	0				; 0345 Index for laser mount and screen view, 1 = front 2 = aft = 4 left 8 = right
420+  85E1 00           GunTemperature			DB	0				; 0347	GNTMP
421+  85E2 00           HyperSpaceFX			DB	0				; 0348 HFX (probabyl BBC specific
422+  85E3 00           ExtraVessels			DB	0				; 0349 EV Use d by cops, extra vessels still to spawn?
423+  85E4 00           Delay					DB	0				; 034A Delay general purpose eg. spawing EV or when printign messages
424+  85E5 00           MessageForDestroyed		DB	0				; 034B Message flag for item + destroyed
425+  85E6 00           JoystickX				DB	0				; 034C JSTX
426+  85E7 00           JoystickY				DB	0				; 034D JSTY
427+  85E8 00           XSAV2 					DB	0				; 034E used to temporary save 6502 X reg
428+  85E9 00           YSAV2 					DB	0				; 034F used to temporary save 6502 Y reg
429+  85EA 00 00 00...  CommanderName			DS  8				; 0350 - 3057 Commander Name
430+  85F2 00           CommanderName0			DB	0				; Sneaky little 0 to allow use of print name directly
431+  85F3 00           VarTP					DB	0				; 0358 TP? The Plan  \ mission uses lower 4 bits
432+  85F4              											; Bit mask XXXX10XX - Thargoid plan mission
433+  85F4 00           PresentSystemX			DB	0				; 0359 - 035A QQ0 X Y
434+  85F5 00           PresentSystemY			DB  0
435+  85F6 00 00 00...  GalaxySeeds				DS	6				; 035B - 0360 QQ21
436+  85FC 00           COK						DB	0				; 0366 Competition Byte what ? Does some file check and accelleration check
437+  85FD 00           Galaxy      			DB	0				; 0367 Galaxy (incremented with galactiv drive
438+  85FE              ;036C to D???
439+  85FE 00 00 00...  DampingKeys				DS  7				; 0387 - 038D
440+  8605              ;  #&6 Does K toggle keyboard/joystick control -  03CD certainly makes keyboard not work anymore.
441+  8605              ;  #&5 Does J reverse both joystick channels
442+  8605              ;  #&4 Does Y reverse joystick Y channel			03CB
443+  8605              ;  #&3 Does F toggle flashing information			03CA
444+  8605              ;  #&2 Does X toggle startup message display ? PATG?	03C9
445+  8605              ;  #&1 Does A toggle keyboard auto-recentering ?
446+  8605              ;  #&0 Caps-lock toggles keyboard flight damping
447+  8605 00           NbrMissiles				DB	0				; 038B	Does this clash with Dampingkeys?
448+  8606 00           FugitiveInnocentStatus	DB	0				; 038C	FIST
449+  8607 00 00 00...  StockAvaliabiliy		DS 	16				; 038D - 039C Stock inventory in station
450+  8617 00           AlienItemsAvaliability  DB	0				; 039D
451+  8618 00           RandomMarketSeed		DB	0				; 039E   \ QQ26	\ random byte for each system vist (for market)
452+  8619 00 00        KillTally  				DW	0				; 039F - 03A0 \ TALLY   \ kills lo hi
453+  861B 00           COMP     				DB	0				; 03A1 2nd competion byte used for save integrity checks?
454+  861C              											;
455+  861C 00           MCH						DB	0				; 03A4  \ MCH  \ old message to erase
456+  861D 00           ForeShield				DB	0				; 03A5
457+  861E 00           AftShield				DB	0				; 03A6
458+  861F 00           PlayerEnergy			DB	0				; 03A7
459+  8620 00           CompassX				DB	0				; 03A8
460+  8621 00           CompassY				DB	0				; 03A9
461+  8622 00           MarketPrice				DB	0				; 03AA QQ24
462+  8623 00           MaxStockAvaliable		DB  0				; 03AB   \ QQ25     \ max available
463+  8624 00           SystemEconomy			DB  0				; 03AC \ QQ28   \ the economy byte of present system (0 is Rich Ind.)
464+  8625 00           CargoItem				DB	0				; 03AD (I think its item type just scooped) QQ29
465+  8626 00           GovPresentSystem		DB	0				; 03AE Govenment
466+  8627 00           TekPresentSystem		DB	0				; 03AF Technology
467+  8628 00 00        ShipLineStackPointer	DW	0				; 03B0 & 03B1 ship Lines pointer reset to top LS% = &0CFF (make DW for z80 and direct hl pointer)
468+  862A              											; this is ship lines stack pointer so may be redundant with paging
469+  862A              											; LS = line stack so we will have one for now to remove later
470+  862A 00 00 00...  WorkingSeeds			DS	6
471+  8630 00 00 00...  PresentSystemSeeds		DS	6				; 03B2 - 03B7
472+  8636 00           DisplayEcononmy			DB	0				; 03B8
473+  8637 00           DisplayGovernment		DB  0				; 03B9 Is it target? 03B9 \ QQ4	 \ Government, 0 is Anarchy.
474+  8638 00           DisplayTekLevel			DB	0				; 03BA   \ QQ5	\ Tech
475+  8639 00 00        DisplayPopulation		DW	0				; 03BB \ QQ6  \ population*10
476+  863B 00 00        DisplayProductivity		DW	0				; 03BD \ QQ7   \ productivity*10
477+  863D 00 00        Distance          		DW	0				; 03BE \ QQ8 distince in 0.1LY units
478+  863F 00 00        DisplayRadius			DW	0
479+  8641 00           TargetPlanetX			DB	0               ; 03C1
480+  8642 00           TargetPlanetY			DB	0               ; 03C2
481+  8643 00           SRCTargetPlanetX		DB	0               ; Used for short range chart cursor
482+  8644 00           SRCTargetPlanetY		DB	0               ; then divided down to target planet for compatibilit with galactic chart routines
483+  8645 00           NubmerOfStarsNOSTM		DB	0				; 03C3 NOSTM  \ number of stars, dust.
484+  8646
485+  8646 00           CompassColor			DB	0				; 03C5
486+  8647 00           SoundToggle				DB	0				; 03C6
487+  8648 00           KeyboardRecenterToggle	DB	0				; 03C8
488+  8649 00           PATGMask				DB	0				; &03C9    \ PATG	\ Mask to scan keyboard X-key, for misjump
489+  864A 00           FlashToggle				DB  0				; 03CA \ FLH \ flash toggle
490+  864B 00           ReverseJoystick			DB	0				; 03CB \ JSTGY \ Y reverse joystick Y channel
491+  864C 00           JoystickToggle			DB	0				; 03CD  \ JSTK    \ K toggle keyboard/joystick
492+  864D 00           DigitalJoystick			DB	0				; 03CE \ JDB   \ . = toggle between keyboard and bitpaddle
493+  864E 00           DiskReadFailFlag		DB	0				; 03CF \ CATF \ Disk catalog fail flag
494+  864F
495+  864F              ; Working Data
496+  864F
497+  864F              ;UniverseTable			DS	26				; 1741  \ address pointers for 13 ships INF on pages &9. 37 bytes each.
498+  864F              ; $0900 =	EQUW page9+37* 0 \ copied to inner worskpace INWK on zero-page when needed
499+  864F              ; $0925 =	EQUW page9+37* 1
500+  864F              ; $094A =	EQUW page9+37* 2
501+  864F              ; $096F =	EQUW page9+37* 3
502+  864F              ; $0994 =	EQUW page9+37* 4
503+  864F              ; $09B9 =	EQUW page9+37* 5
504+  864F              ; $09DE =	EQUW page9+37* 6
505+  864F              ; $0A03 =	EQUW page9+37* 7
506+  864F              ; $0A28 =	EQUW page9+37* 8
507+  864F              ; $0A4D =	EQUW page9+37* 9
508+  864F              ; $0A72 =	EQUW page9+37*10
509+  864F              ; $0A97 =	EQUW page9+37*11
510+  864F              ; $0ABC =	EQUW page9+37*12 \ allwk up to &0ABC while heap for edges working down from &CFF.
511+  864F
512+  864F
513+  864F
514+  864F              ; 0b00 is start address of data to save
515+  864F 00           MissionData				DB	0				; &0B00	  \ look at data, first byte is TP mission bits
516+  8650
517+  8650 00 00        FileNameStringPointer	DW	0				;0C00	   \ pointer to filename string
518+  8652 00 00        CommanderLoadAddress	DW	0				;0C03
519+  8654 00 00        LengthOfFile			DW	0				;0C0B
520+  8656 00 00        SaveDataEndAddress		DW	0				;&0C0F	      \ &0C00 is end address of data to save
521+  8658
522+  8658 00 00 00...  EdgesBuffer				DS 50
523+  868A              EdgesBufferSP			equ	$				; Was $0CFF			; Heap pointer for edges buffer
524+  868A              ShipLinesBufferSP		equ EdgesBufferSP	; was $0CFF
525+  868A
526+  868A 00 00 00...  ShipLineStack			DS  70			; For now but will be in the page later
527+  86D0              ShipLineStackTop		equ $ - ShipLineStack
528+  86D0
529+  86D0 00 00 00...  LSO						DS 	$C0				;0E00 Line Buffer Solar of 192 lines (may be 191 in reality)
530+  8790              ; LSX vector overlaps with LSO
531+  8790 00           LSX2					DB	0				; &0EC0	    \ LSX2 bline buffer size?
532+  8791 00           LSY2					DB	0           	; &0F0E	    \ LSY2
533+  8792
534+  8792              ; Star Positions are 16 bit 3d coordinates
535+  8792 00 00 00...  varDust                 DS  MaxNumberOfStars * 6
536+  87FE 00 00 00...  varDustSceen            DS  MaxNumberOfStars * 2 ; To optimise star list to wipe from screen
537+  8822 00           varStarX                DB  0
538+  8823 00           varStarY                DB  0
539+  8824 00 00 00...  varDustX                DS MaxNumberOfStars *2
540+  8848 00 00 00...  varDustY                DS MaxNumberOfStars *2
541+  886C 00 00 00...  varDustZ                DS MaxNumberOfStars *2
542+  8890
543+  8890
544+  8890              SpeedoStart             equ $84D1
545+  8890 01 02 02 03  SpeedoMapping           DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,18,19,20,20,21,22,23,24,24,25,26,26,27,28,28,29,30,31
545+  8894 04 04 05 06
545+  8898 06 07 08 09
545+  889C 0A 0A 0B 0C
545+  88A0 0D 0E 0E 0F
545+  88A4 10 10 11 12
545+  88A8 13 14 14 15
545+  88AC 16 17 18 18
545+  88B0 19 1A 1A 1B
545+  88B4 1C 1C 1D 1E
545+  88B8 1F
546+  88B9
547+  88B9              DialMiddleXPos          equ $E1
548+  88B9              RollMiddle              equ $8AE0
549+  88B9              PitchMiddle             equ $92E0
550+  88B9
551+  88B9              MakeInnocentMacro:		MACRO
552+  88B9 ~            						xor		a
553+  88B9 ~            						ld		(FugitiveInnocentStatus),a
554+  88B9              						ENDM
555+  88B9
556+  88B9              NoEscapePodMacro:		MACRO
557+  88B9 ~            						xor		a
558+  88B9 ~            						ld		(EscapePod),a
559+  88B9              						ENDM
560+  88B9
561+  88B9              MaxFuelLevel            EQU     $46
562+  88B9              MaxFuelMacro:			MACRO
563+  88B9 ~            						ld		a,MaxFuelLevel
564+  88B9 ~            						ld		(Fuel),a
565+  88B9              						ENDM
566+  88B9
567+  88B9              MaxThrottle:            MACRO
568+  88B9 ~                                    ld      a,(SHIPMAXSPEED)
569+  88B9 ~                                    ld      (DELTA),a
570+  88B9 ~                                    ld      d,a
571+  88B9 ~                                    ld      e,4
572+  88B9 ~                                    mul
573+  88B9 ~                                    ld      (DELT4Lo),de
574+  88B9                                      ENDM
575+  88B9
576+  88B9              ZeroThrottle:           MACRO
577+  88B9 ~                                    xor     a
578+  88B9 ~                                    ld      (DELTA),a
579+  88B9 ~                                    ld      (DELT4Lo),a
580+  88B9 ~                                    ld      (DELT4Lo+1),a
581+  88B9                                      ENDM
582+  88B9
# file closed: ./Variables/general_variables.asm
153   88B9                  INCLUDE "./Maths/Utilities/LL28AequAmul256DivD.asm"
# file opened: ./Maths/Utilities/LL28AequAmul256DivD.asm
  1+  88B9
  2+  88B9              LL28Amul256DivD:        JumpIfAGTENusng  d, .Ll28Exit255
  2+  88B9 BA          >                        cp     d
  2+  88BA D2 D8 88    >                        jp		nc,.Ll28Exit255
  3+  88BD 1E FE                                ld      e,%11111110                 ; Set R to have bits 1-7 set, so we can rotate through 7
  4+  88BF CB 27        .LL31:                  sla     a
  5+  88C1 38 0D                                jr      c,.LL29
  6+  88C3                                      JumpIfALTNusng  d, .SkipSub         ; will jump if carry set, so we need to reset on the rol
  6+  88C3 BA          >                        cp      d
  6+  88C4 DA C9 88    >                        jp		c,.SkipSub
  7+  88C7 92                                   sub     d
  8+  88C8                                      ClearCarryFlag                      ; reset clarry as it will be complimented for rotate as 6502 does carry flags inverted
  8+  88C8 B7          >				or a
  9+  88C9 3F           .SkipSub:               ccf                                 ; if we did the subtract the carry will be clear so we need to invert to roll in.
 10+  88CA CB 13                                rl      e
 11+  88CC 38 F1                                jr      c,.LL31
 12+  88CE 7B                                   ld      a,e
 13+  88CF C9                                   ret
 14+  88D0 92           .LL29:                  sub     d                           ; A >= Q, so set A = A - Q
 15+  88D1 37                                   scf                                 ; Set the C flag to rotate into the result in R
 16+  88D2 CB 13                                rl      e                           ; rotate counter e left
 17+  88D4 38 E9                                jr      c,.LL31                     ; if a bit was spat off teh end then loop
 18+  88D6 7B                                   ld      a,e                         ; stick result in a
 19+  88D7 C9                                   ret
 20+  88D8 3E FF        .Ll28Exit255:           ld  a,255                           ; Fail with FF as result
 21+  88DA C9                                   ret
 22+  88DB
# file closed: ./Maths/Utilities/LL28AequAmul256DivD.asm
154   88DB
155   88DB              ; Include all maths libraries to test assembly
156   88DB
157   88DB                  INCLUDE "./Maths/multiply.asm"
# file opened: ./Maths/multiply.asm
  1+  88DB              HLequSRmulQdiv256:      ;X.Y=x1lo.S*M/256  	\ where M/256 is gradient
  2+  88DB 2A 48 85                             ld  hl,(varRS)
  3+  88DE 3A 47 85                             ld  a,(varQ)
  4+  88E1 C5 D5        HLeqyHLmulAdiv256:      push    bc,,de
  5+  88E3 11 00 00                             ld  de,0        ; de = XY
  6+  88E6 47                                   ld  b,a         ; b = Q
  7+  88E7                                      ShiftHLRight1
  7+  88E7 CB 3C       >			   srl h
  7+  88E9 CB 1D       >			   rr  l
  8+  88EB CB 20                                sla b
  9+  88ED 30 03                                jr  nc,.LL126
 10+  88EF EB           .LL125:                 ex de,hl
 11+  88F0 19                                   add hl,de
 12+  88F1 EB                                   ex  de,hl       ; de = de + rs
 13+  88F2              .LL126:                 ShiftHLRight1
 13+  88F2 CB 3C       >			   srl h
 13+  88F4 CB 1D       >			   rr  l
 14+  88F6 CB 20                                sla b
 15+  88F8 38 F5                                jr      c,.LL125
 16+  88FA 20 F6                                jr      nz,.LL126
 17+  88FC EB                                   ex      de,hl   ; hl = result
 18+  88FD D1 C1                                pop     bc,,de
 19+  88FF C9                                   ret
 20+  8900
 21+  8900
 22+  8900                                 ; .MAD	\ -> &22AD  \ Multiply and Add  (DE also) X.A(Lo.Hi) = Q*A + R.S (Lo.Hi)
 23+  8900 DD 67        madXAequQmulAaddRS:     ld      ixh,a
 24+  8902 E6 7F                                and		$7F
 25+  8904 5F                                   ld      e,a
 26+  8905 3A 47 85                             ld      a,(varQ)
 27+  8908 DD 6F                                ld		ixl,a
 28+  890A E6 7F                                and		$7F
 29+  890C 57                                   ld      d,a
 30+  890D              madDEequDmulA
 31+  890D ED 30            mul                                 ;de = d * e
 32+  890F DD 7C        	ld		a,ixh
 33+  8911 DD AD        	xor		ixl
 34+  8913 E6 80        	and		$80
 35+  8915 B2           	or		d
 36+  8916 57           	ld		d,a
 37+  8917              madDEaddRS:
 38+  8917 2A 48 85     	ld		hl,(varR)
 39+  891A                  ;ld      a,(varR)
 40+  891A                  ;ld      l,a
 41+  891A                  ;ld      a,(varS)
 42+  891A                  ;ld      h,a
 43+  891A CD 23 89     	call	madXAAddHLDESigned
 44+  891D              ;
 45+  891D              ;   add     hl,de                       ; hl = R.S + DE
 46+  891D EB               ex      de,hl                       ; de = R.S + DE
 47+  891E                  ClearCarryFlag
 47+  891E B7          >				or a
 48+  891F DD 6B            ld      ixl,e
 49+  8921 7A               ld      a,d
 50+  8922 C9               ret
 51+  8923
 52+  8923
 53+  8923 7C           madXAAddHLDESigned:     ld      a,h
 54+  8924 E6 80                                and     SignOnly8Bit
 55+  8926 47                                   ld      b,a                         ;save sign bit in b
 56+  8927 AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
 57+  8928                                      JumpIfNegative .ADDHLDEOppSGN        ;Signs are opposite there fore we can subtract to get difference
 57+  8928 FA 40 89    >                        jp		m,.ADDHLDEOppSGN
 58+  892B 78           .ADDHLDESameSigns:       ld      a,b
 59+  892C B2                                   or      d
 60+  892D                                      JumpIfNegative .ADDHLDESameNeg       ; optimisation so we can just do simple add if both positive
 60+  892D FA 32 89    >                        jp		m,.ADDHLDESameNeg
 61+  8930 19                                   add     hl,de
 62+  8931 C9                                   ret
 63+  8932 7C           .ADDHLDESameNeg:         ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 64+  8933 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 65+  8935 67                                   ld      h,a
 66+  8936 7A                                   ld      a,d
 67+  8937 E6 7F                                and     SignMask8Bit
 68+  8939 57                                   ld      d,a
 69+  893A 19                                   add     hl,de
 70+  893B 3E 80                                ld      a,SignOnly8Bit
 71+  893D B4                                   or      h                           ; now set bit for negative value, we won't bother with overflow for now TODO
 72+  893E 67                                   ld      h,a
 73+  893F C9                                   ret
 74+  8940 7C           .ADDHLDEOppSGN:          ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit                     ; here HL and DE are opposite
 75+  8941 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 76+  8943 67                                   ld      h,a
 77+  8944 7A                                   ld      a,d
 78+  8945 E6 7F                                and     SignMask8Bit
 79+  8947 57                                   ld      d,a
 80+  8948 B7                                   or      a
 81+  8949 ED 52                                sbc     hl,de
 82+  894B 38 04                                jr      c,.ADDHLDEOppInvert
 83+  894D 78           .ADDHLDEOppSGNNoCarry:   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
 84+  894E B4                                   or      h
 85+  894F 67                                   ld      h,a                         ; set the previou sign value
 86+  8950 C9                                   ret
 87+  8951              .ADDHLDEOppInvert:       NegHL                                                   ; we need to flip the sign and 2'c the Hl result
 87+  8951 AF          >                xor a
 87+  8952 95          >                sub l
 87+  8953 6F          >                ld l,a
 87+  8954 9F          >                sbc a,a
 87+  8955 94          >                sub h
 87+  8956 67          >                ld h,a
 88+  8957 78                                   ld      a,b
 89+  8958 EE 80                                xor     SignOnly8Bit                ; flip sign bit
 90+  895A B4                                   or      h
 91+  895B 67                                   ld      h,a                         ; recover sign
 92+  895C C9                                   ret
 93+  895D
 94+  895D              ; multiplication of two 16-bit numbers into a 16-bit product
 95+  895D              ; enter : de = 16-bit multiplicand
 96+  895D              ;         hl = 16-bit multiplicand
 97+  895D              ; exit  : hl = 16-bit product
 98+  895D              ;         carry reset
 99+  895D              ;
100+  895D              ; uses  : af, bc, de, hl
101+  895D C5           mulDEbyHL:              push    bc
102+  895E 7A                                   ld a,d                      ; a = xh
103+  895F 54                                   ld d,h                      ; d = yh
104+  8960 67                                   ld h,a                      ; h = xh
105+  8961 4B                                   ld c,e                      ; c = xl
106+  8962 45                                   ld b,l                      ; b = yl
107+  8963 ED 30                                mul                         ; yh * yl
108+  8965 EB                                   ex de,hl
109+  8966 ED 30                                mul                         ; xh * yl
110+  8968 19                                   add hl,de                   ; add cross products
111+  8969 59                                   ld e,c
112+  896A 50                                   ld d,b
113+  896B ED 30                                mul                         ; yl * xl
114+  896D 7D                                   ld a,l                      ; cross products lsb
115+  896E 82                                   add a,d                     ; add to msb final
116+  896F 67                                   ld h,a
117+  8970 6B                                   ld l,e                      ; hl = final
118+  8971                                      ; 83 cycles, 19 bytes
119+  8971 AF                                   xor a                       ; reset carry
120+  8972 C1                                   pop     bc
121+  8973 C9                                   ret
122+  8974              ; multiplication of two S156-bit numbers into a 16-bit 2'd compliment product
123+  8974              ; enter : de = 16-bit multiplicand
124+  8974              ;         hl = 16-bit multiplicand
125+  8974              ; exit  : hl = 16-bit product
126+  8974              ;         carry reset
127+  8974              ;
128+  8974              ; uses  : af, bc, de, hl
129+  8974 00           mulDEbyHLSignByte       DB      0
130+  8975 AF           mulDEbyHLSgnTo2c:       xor     a
131+  8976 32 74 89                             ld      (mulDEbyHLSignByte),a
132+  8979 7A           .SignDE:                ld      a,d
133+  897A ED 27 80                             test    $80
134+  897D 28 08                                jr      z,.SignHL
135+  897F E6 7F        .NegativeDE:            and     $7F
136+  8981 57                                   ld      d,a
137+  8982 3E 80                                ld      a,$80
138+  8984 32 74 89                             ld      (mulDEbyHLSignByte),a
139+  8987 7C           .SignHL:                ld      a,h
140+  8988 ED 27 80                             test    $80
141+  898B 28 0B                                jr      z,.AbsoluteMultiply
142+  898D E6 7F        .NegativeHL:            and     $7F
143+  898F 67                                   ld      h,a
144+  8990 3A 74 89                             ld      a,(mulDEbyHLSignByte)
145+  8993 EE 80                                xor     $80
146+  8995 32 74 89                             ld      (mulDEbyHLSignByte),a
147+  8998 CD 5D 89     .AbsoluteMultiply:      call    mulDEbyHL
148+  899B 3A 74 89     .RecoverSign:           ld      a,(mulDEbyHLSignByte)
149+  899E ED 27 80                             test    $80
150+  89A1 C8                                   ret     z
151+  89A2 AF           .Negateghl: 				xor 	a
152+  89A3 95                                   sub 	l
153+  89A4 6F                                   ld 		l,a
154+  89A5 9F                                   sbc 	a,a
155+  89A6 94                                   sub 	h
156+  89A7 67                                   ld 		h,a
157+  89A8 C9                                   ret
158+  89A9
159+  89A9 AF           mulDESgnbyHLUnsgnTo2c:  xor     a
160+  89AA 32 74 89                             ld      (mulDEbyHLSignByte),a
161+  89AD 7A           .SignDE:                ld      a,d
162+  89AE ED 27 80                             test    $80
163+  89B1 28 08                                jr      z,.AbsoluteMultiply
164+  89B3 E6 7F        .NegativeDE:            and     $7F
165+  89B5 57                                   ld      d,a
166+  89B6 3E 80                                ld      a,$80
167+  89B8 32 74 89                             ld      (mulDEbyHLSignByte),a
168+  89BB CD 5D 89     .AbsoluteMultiply:      call    mulDEbyHL
169+  89BE 3A 74 89     .RecoverSign:           ld      a,(mulDEbyHLSignByte)
170+  89C1 ED 27 80                             test    $80
171+  89C4 C8                                   ret     z
172+  89C5 AF           .Negateghl:             xor 	a
173+  89C6 95                                   sub 	l
174+  89C7 6F                                   ld 		l,a
175+  89C8 9F                                   sbc 	a,a
176+  89C9 94                                   sub 	h
177+  89CA 67                                   ld 		h,a
178+  89CB C9                                   ret
179+  89CC
180+  89CC
# file closed: ./Maths/multiply.asm
158   89CC                  INCLUDE "./Maths/asm_square.asm"
# file opened: ./Maths/asm_square.asm
  1+  89CC              ; "ASM_SQUA : TESTGOOD"
  2+  89CC              ; "AP = A^2 A = low,P = hi"
  3+  89CC
  4+  89CC              inline_squde: MACRO
  5+  89CC ~            			ld	e,a
  6+  89CC ~            			ld  d,a
  7+  89CC ~            			mul
  8+  89CC              			ENDM
  9+  89CC
 10+  89CC              inline_squa: MACRO
 11+  89CC ~            			ld	e,a
 12+  89CC ~            			ld  d,a
 13+  89CC ~            			mul
 14+  89CC ~            			ld	a,e
 15+  89CC              			ENDM
 16+  89CC
 17+  89CC
 18+  89CC              asm_squa:
 19+  89CC E6 7F        	and SignMask8Bit
 20+  89CE              ; "ASM SQUA2 : TESTGOOD"
 21+  89CE              ; "AP = A^2 A = low,P = hi singed"
 22+  89CE              asm_squa2:
 23+  89CE 5F           	ld e, a
 24+  89CF 57           	ld d,a
 25+  89D0 ED 30        	mul
 26+  89D2 ED 53 ED 84  	ld (varP),de
 27+  89D6 7B           	ld a,e
 28+  89D7 C9           	ret
# file closed: ./Maths/asm_square.asm
159   89D8                  INCLUDE "./Maths/asm_sqrt.asm"
# file opened: ./Maths/asm_sqrt.asm
  1+  89D8              ; "ASM SQRT : TESTGOOD"
  2+  89D8              ; "16-bit integer square root"
  3+  89D8              ; "call with de = number to square root"
  4+  89D8              ; "returns   hl = square root"
  5+  89D8              ; "corrupts  bc, de"
  6+  89D8              asm_sqrt:
  7+  89D8 01 00 80     	ld bc,$8000
  8+  89DB 61           	ld h,c
  9+  89DC 69           	ld l,c
 10+  89DD              .sqrloop:
 11+  89DD CB 38        	srl b
 12+  89DF CB 19        	rr c
 13+  89E1 09           	add hl,bc
 14+  89E2 EB           	ex de,hl
 15+  89E3 ED 52        	sbc hl,de
 16+  89E5 38 04        	jr c,.sqrbit
 17+  89E7 EB           	ex de,hl
 18+  89E8 09           	add hl,bc
 19+  89E9 18 05        	jr .sqrfi
 20+  89EB              .sqrbit:
 21+  89EB 19           	add hl,de
 22+  89EC EB           	ex de,hl
 23+  89ED B7           	or a
 24+  89EE ED 42        	sbc hl,bc
 25+  89F0              .sqrfi:
 26+  89F0 CB 3C        	srl h
 27+  89F2 CB 1D        	rr l
 28+  89F4 CB 38        	srl b
 29+  89F6 CB 19        	rr c
 30+  89F8 30 E3        	jr nc,.sqrloop
 31+  89FA C9           	ret
 32+  89FB
 33+  89FB
 34+  89FB              sqrtQR:					; Q = SQR(Qlo.Rhi) Q <~127
 35+  89FB 3A 47 85     	ld		a,(varQ)
 36+  89FE 5F           	ld		e,a
 37+  89FF 3A 48 85     	ld		a,(varR)
 38+  8A02 57           	ld		d,a
 39+  8A03 CD D8 89     	call	asm_sqrt
 40+  8A06 7D               ld      a,l
 41+  8A07 32 47 85     	ld		(varQ),a
 42+  8A0A C9           	ret
 43+  8A0B
# file closed: ./Maths/asm_sqrt.asm
160   8A0B                  INCLUDE "./Maths/asm_divide.asm"
# file opened: ./Maths/asm_divide.asm
  1+  8A0B              ; Divide 8-bit values
  2+  8A0B              ; In: Divide E by divider C
  3+  8A0B              ; Out: A = result, B = rest
  4+  8A0B              ;
  5+  8A0B              ;;;Div8:
  6+  8A0B              ;;;    xor a
  7+  8A0B              ;;;    ld b,8
  8+  8A0B              ;;;Div8_Loop:
  9+  8A0B              ;;;    rl e
 10+  8A0B              ;;;    rla
 11+  8A0B              ;;;    sub c
 12+  8A0B              ;;;    jr nc,Div8_NoAdd
 13+  8A0B              ;;;    add a,c
 14+  8A0B              ;;;Div8_NoAdd:
 15+  8A0B              ;;;    djnz Div8_Loop
 16+  8A0B              ;;;    ld b,a
 17+  8A0B              ;;;    ld a,e
 18+  8A0B              ;;;    rla
 19+  8A0B              ;;;    cpl
 20+  8A0B              ;;;    ret
 21+  8A0B
 22+  8A0B              ;;Inputs: DE is the numerator, BC is the divisor
 23+  8A0B              ;;Outputs: DE is the result
 24+  8A0B              ;;         A is a copy of E
 25+  8A0B              ;;         HL is the remainder
 26+  8A0B              ;;         BC is not changed
 27+  8A0B              ;; so DE = DE /BC
 28+  8A0B              ;140 bytes
 29+  8A0B              ;145cc
 30+  8A0B
 31+  8A0B              MacroDEDivBC:       MACRO
 32+  8A0B ~                                rla
 33+  8A0B ~                                adc     hl,hl
 34+  8A0B ~                                sbc     hl,bc
 35+  8A0B ~                                jr      nc,$+3
 36+  8A0B ~                                add     hl,bc
 37+  8A0B                                  ENDM
 38+  8A0B
 39+  8A0B              DEequDEDivBC:
 40+  8A0B AF               xor a
 41+  8A0C ED 62            sbc hl,hl
 42+  8A0E 7A               ld a,d
 43+  8A0F                  MacroDEDivBC
 43+  8A0F 17          >                    rla
 43+  8A10 ED 6A       >                    adc     hl,hl
 43+  8A12 ED 42       >                    sbc     hl,bc
 43+  8A14 30 01       >                    jr      nc,$+3
 43+  8A16 09          >                    add     hl,bc
 44+  8A17                  MacroDEDivBC
 44+  8A17 17          >                    rla
 44+  8A18 ED 6A       >                    adc     hl,hl
 44+  8A1A ED 42       >                    sbc     hl,bc
 44+  8A1C 30 01       >                    jr      nc,$+3
 44+  8A1E 09          >                    add     hl,bc
 45+  8A1F                  MacroDEDivBC
 45+  8A1F 17          >                    rla
 45+  8A20 ED 6A       >                    adc     hl,hl
 45+  8A22 ED 42       >                    sbc     hl,bc
 45+  8A24 30 01       >                    jr      nc,$+3
 45+  8A26 09          >                    add     hl,bc
 46+  8A27                  MacroDEDivBC
 46+  8A27 17          >                    rla
 46+  8A28 ED 6A       >                    adc     hl,hl
 46+  8A2A ED 42       >                    sbc     hl,bc
 46+  8A2C 30 01       >                    jr      nc,$+3
 46+  8A2E 09          >                    add     hl,bc
 47+  8A2F                  MacroDEDivBC
 47+  8A2F 17          >                    rla
 47+  8A30 ED 6A       >                    adc     hl,hl
 47+  8A32 ED 42       >                    sbc     hl,bc
 47+  8A34 30 01       >                    jr      nc,$+3
 47+  8A36 09          >                    add     hl,bc
 48+  8A37                  MacroDEDivBC
 48+  8A37 17          >                    rla
 48+  8A38 ED 6A       >                    adc     hl,hl
 48+  8A3A ED 42       >                    sbc     hl,bc
 48+  8A3C 30 01       >                    jr      nc,$+3
 48+  8A3E 09          >                    add     hl,bc
 49+  8A3F                  MacroDEDivBC
 49+  8A3F 17          >                    rla
 49+  8A40 ED 6A       >                    adc     hl,hl
 49+  8A42 ED 42       >                    sbc     hl,bc
 49+  8A44 30 01       >                    jr      nc,$+3
 49+  8A46 09          >                    add     hl,bc
 50+  8A47                  MacroDEDivBC
 50+  8A47 17          >                    rla
 50+  8A48 ED 6A       >                    adc     hl,hl
 50+  8A4A ED 42       >                    sbc     hl,bc
 50+  8A4C 30 01       >                    jr      nc,$+3
 50+  8A4E 09          >                    add     hl,bc
 51+  8A4F 17               rla
 52+  8A50 2F               cpl
 53+  8A51 57               ld d,a
 54+  8A52
 55+  8A52 7B               ld a,e
 56+  8A53                  MacroDEDivBC
 56+  8A53 17          >                    rla
 56+  8A54 ED 6A       >                    adc     hl,hl
 56+  8A56 ED 42       >                    sbc     hl,bc
 56+  8A58 30 01       >                    jr      nc,$+3
 56+  8A5A 09          >                    add     hl,bc
 57+  8A5B                  MacroDEDivBC
 57+  8A5B 17          >                    rla
 57+  8A5C ED 6A       >                    adc     hl,hl
 57+  8A5E ED 42       >                    sbc     hl,bc
 57+  8A60 30 01       >                    jr      nc,$+3
 57+  8A62 09          >                    add     hl,bc
 58+  8A63                  MacroDEDivBC
 58+  8A63 17          >                    rla
 58+  8A64 ED 6A       >                    adc     hl,hl
 58+  8A66 ED 42       >                    sbc     hl,bc
 58+  8A68 30 01       >                    jr      nc,$+3
 58+  8A6A 09          >                    add     hl,bc
 59+  8A6B                  MacroDEDivBC
 59+  8A6B 17          >                    rla
 59+  8A6C ED 6A       >                    adc     hl,hl
 59+  8A6E ED 42       >                    sbc     hl,bc
 59+  8A70 30 01       >                    jr      nc,$+3
 59+  8A72 09          >                    add     hl,bc
 60+  8A73                  MacroDEDivBC
 60+  8A73 17          >                    rla
 60+  8A74 ED 6A       >                    adc     hl,hl
 60+  8A76 ED 42       >                    sbc     hl,bc
 60+  8A78 30 01       >                    jr      nc,$+3
 60+  8A7A 09          >                    add     hl,bc
 61+  8A7B                  MacroDEDivBC
 61+  8A7B 17          >                    rla
 61+  8A7C ED 6A       >                    adc     hl,hl
 61+  8A7E ED 42       >                    sbc     hl,bc
 61+  8A80 30 01       >                    jr      nc,$+3
 61+  8A82 09          >                    add     hl,bc
 62+  8A83                  MacroDEDivBC
 62+  8A83 17          >                    rla
 62+  8A84 ED 6A       >                    adc     hl,hl
 62+  8A86 ED 42       >                    sbc     hl,bc
 62+  8A88 30 01       >                    jr      nc,$+3
 62+  8A8A 09          >                    add     hl,bc
 63+  8A8B                  MacroDEDivBC
 63+  8A8B 17          >                    rla
 63+  8A8C ED 6A       >                    adc     hl,hl
 63+  8A8E ED 42       >                    sbc     hl,bc
 63+  8A90 30 01       >                    jr      nc,$+3
 63+  8A92 09          >                    add     hl,bc
 64+  8A93 17               rla
 65+  8A94 2F               cpl
 66+  8A95 5F               ld e,a
 67+  8A96 C9               ret
 68+  8A97
 69+  8A97
 70+  8A97
 71+  8A97              ;divdide by 16 using undocumented instrunctions
 72+  8A97              ;Input: BC = Dividend, DE = Divisor, HL = 0
 73+  8A97              ;Output: BC = Quotient, HL = Remainder
 74+  8A97              ; Our use
 75+  8A97              ; BC = A0
 76+  8A97              ; DE = 0C
 77+  8A97              ; so BC = a * 256 / C
 78+  8A97              DIV16Amul256dCUNDOC:    JumpIfAGTENusng	  c,DEV16ATooLarge                                          ; first off if a > c ten return 255
 78+  8A97 B9          >                        cp     c
 78+  8A98 D2 C3 8A    >                        jp		nc,DEV16ATooLarge
 79+  8A9B 47                                   ld      b,a
 80+  8A9C 59                                   ld      e,c
 81+  8A9D 0E 00                                ld      c,0
 82+  8A9F 16 00                                ld      d,0
 83+  8AA1 C3 AE 8A                             jp      DIV16UNDOC
 84+  8AA4 47           DIV16Amul256dQUNDOC:    ld      b,a
 85+  8AA5 0E 00                                ld      c,0
 86+  8AA7 21 47 85                             ld      hl,varQ
 87+  8AAA 7E                                   ld      a,(hl)
 88+  8AAB 16 00                                ld      d,0
 89+  8AAD 5F                                   ld      e,a
 90+  8AAE              DIV16BCDivDEUNDOC:
 91+  8AAE 21 00 00     DIV16UNDOC:             ld      hl,0
 92+  8AB1 78                                   ld      a,b
 93+  8AB2 06 10                                ld      b,16
 94+  8AB4 CB 31        DIV16UNDOCLOOP:         sll	c		; unroll 16 times
 95+  8AB6 17                                   rla			; ...
 96+  8AB7 ED 6A                                adc	hl,hl		; ...
 97+  8AB9 ED 52                                sbc	hl,de		; ...
 98+  8ABB 30 02                                jr	nc,DIV16UNDOCSKIP		; ...
 99+  8ABD 19                                   add	hl,de		; ...
100+  8ABE 0D                                   dec	c		; ...
101+  8ABF 10 F3        DIV16UNDOCSKIP:         djnz DIV16UNDOCLOOP
102+  8AC1 47                                   ld   b,a
103+  8AC2 C9                                   ret
104+  8AC3 01 FF 00     DEV16ATooLarge:         ld     bc,$00FF
105+  8AC6 C9                                   ret
106+  8AC7
107+  8AC7              ; "> asm_div8 C_Div_D - C is the numerator, D is the denominator, A is the remainder, B is 0, C is the result of C/D,D,E,H,L are not changed"
108+  8AC7 06 08        asm_div8:               ld b,8
109+  8AC9 AF                                   xor a
110+  8ACA CB 21        div8_loop:	            sla c
111+  8ACC 17                                   rla
112+  8ACD BA                                   cp d
113+  8ACE 38 02                                jr c,div8_skip
113+  8AD0
114+  8AD0 0C                                   inc c
115+  8AD1 92                                   sub d
116+  8AD2 10 F6        div8_skip:	            djnz div8_loop
117+  8AD4 C9                                   ret
118+  8AD5              ; ">asm_div16: HL_Div_C: HL is the numerator,  C is the denominator, output A is the remainder, B is 0, C,DE is not changedHL is the quotient"
119+  8AD5 06 10        asm_div16:              ld b,16
120+  8AD7 AF                                   xor a
121+  8AD8 CB 25        div16_loop:	            sla l
122+  8ADA CB 14                                rl	h
123+  8ADC              ;    add hl,hl
124+  8ADC 17                                   rla
125+  8ADD B9                                   cp c
126+  8ADE 38 02                                jr c,div16_skip
127+  8AE0 2C                                   inc l
128+  8AE1 91                                   sub c
129+  8AE2 10 F4        div16_skip:		        djnz div16_loop
130+  8AE4 C9                                   ret
131+  8AE5              ;
132+  8AE5              ; Divide 16-bit values (with 16-bit result)
133+  8AE5              ; In: Divide BC by divider DE
134+  8AE5              ; Out: BC = result, HL = rest
135+  8AE5              ;
136+  8AE5              HLDivC_Iteration: 	MACRO
137+  8AE5 ~            					add	hl,hl		; unroll 16 times
138+  8AE5 ~            					rla				; ...
139+  8AE5 ~            					cp	c			; ...
140+  8AE5 ~            					jr	1F
141+  8AE5 ~            					sub	c			; ...
142+  8AE5 ~            1:
143+  8AE5 ~            					inc	l			; ...
144+  8AE5              					ENDM
145+  8AE5
146+  8AE5
147+  8AE5
148+  8AE5              ; ">div1616: BC = BC / DE. HL = remainder"
149+  8AE5 21 00 00     Div1616:            ld hl,0
150+  8AE8 78                               ld a,b
151+  8AE9 06 08                            ld b,8
152+  8AEB 17           .Div16_Loop1:       rla
153+  8AEC ED 6A                            adc hl,hl
154+  8AEE ED 52                            sbc hl,de
155+  8AF0 30 01                            jr nc,.Div16_NoAdd1
156+  8AF2 19                               add hl,de
157+  8AF3 10 F6        .Div16_NoAdd1:      djnz .Div16_Loop1
158+  8AF5 17                               rla
159+  8AF6 2F                               cpl
160+  8AF7 47                               ld b,a
161+  8AF8 79                               ld a,c
162+  8AF9 48                               ld c,b
163+  8AFA 06 08                            ld b,8
164+  8AFC 17           .Div16_Loop2:       rla
165+  8AFD ED 6A                            adc hl,hl
166+  8AFF ED 52                            sbc hl,de
167+  8B01 30 01                            jr nc,.Div16_NoAdd2
168+  8B03 19                               add hl,de
169+  8B04 10 F6        .Div16_NoAdd2:      djnz .Div16_Loop2
170+  8B06 17                               rla
171+  8B07 2F                               cpl
172+  8B08 41                               ld b,c
173+  8B09 4F                               ld c,a
174+  8B0A C9                               ret
175+  8B0B
176+  8B0B
177+  8B0B
178+  8B0B              BCDIVDE_Iteration: MACRO
179+  8B0B ~            				   rla
180+  8B0B ~            				   adc	hl,hl
181+  8B0B ~            				   add	hl,de
182+  8B0B ~            				   jr	c,1F
183+  8B0B ~            				   sbc	hl,de
184+  8B0B ~            1:
185+  8B0B              				   ENDM
186+  8B0B
187+  8B0B
188+  8B0B              ; ">BC_Div_DE: BC = BC / DE. HL = remainder fast divide with unrolled loop"
189+  8B0B              ;BC/DE ==> BC, remainder in HL
190+  8B0B              ;NOTE: BC/0 returns 0 as the quotient.
191+  8B0B              ;min: 738cc
192+  8B0B              ;max: 898cc
193+  8B0B              ;avg: 818cc
194+  8B0B              ;144 bytes
195+  8B0B AF           BC_Div_DE:              xor a
196+  8B0C 67                                   ld h,a
197+  8B0D 6F                                   ld l,a
198+  8B0E 93                                   sub e
199+  8B0F 5F                                   ld e,a
200+  8B10 9F                                   sbc a,a
201+  8B11 92                                   sub d
202+  8B12 57                                   ld d,a
203+  8B13 78                                   ld a,b
204+  8B14                                      BCDIVDE_Iteration
204+  8B14 17          >				   rla
204+  8B15 ED 6A       >				   adc	hl,hl
204+  8B17 19          >				   add	hl,de
204+  8B18 38 02       >				   jr	c,1F
204+  8B1A ED 52       >				   sbc	hl,de
204+  8B1C             >1:
205+  8B1C                                      BCDIVDE_Iteration
205+  8B1C 17          >				   rla
205+  8B1D ED 6A       >				   adc	hl,hl
205+  8B1F 19          >				   add	hl,de
205+  8B20 38 02       >				   jr	c,1F
205+  8B22 ED 52       >				   sbc	hl,de
205+  8B24             >1:
206+  8B24                                      BCDIVDE_Iteration
206+  8B24 17          >				   rla
206+  8B25 ED 6A       >				   adc	hl,hl
206+  8B27 19          >				   add	hl,de
206+  8B28 38 02       >				   jr	c,1F
206+  8B2A ED 52       >				   sbc	hl,de
206+  8B2C             >1:
207+  8B2C                                      BCDIVDE_Iteration
207+  8B2C 17          >				   rla
207+  8B2D ED 6A       >				   adc	hl,hl
207+  8B2F 19          >				   add	hl,de
207+  8B30 38 02       >				   jr	c,1F
207+  8B32 ED 52       >				   sbc	hl,de
207+  8B34             >1:
208+  8B34                                      BCDIVDE_Iteration
208+  8B34 17          >				   rla
208+  8B35 ED 6A       >				   adc	hl,hl
208+  8B37 19          >				   add	hl,de
208+  8B38 38 02       >				   jr	c,1F
208+  8B3A ED 52       >				   sbc	hl,de
208+  8B3C             >1:
209+  8B3C                                      BCDIVDE_Iteration
209+  8B3C 17          >				   rla
209+  8B3D ED 6A       >				   adc	hl,hl
209+  8B3F 19          >				   add	hl,de
209+  8B40 38 02       >				   jr	c,1F
209+  8B42 ED 52       >				   sbc	hl,de
209+  8B44             >1:
210+  8B44                                      BCDIVDE_Iteration
210+  8B44 17          >				   rla
210+  8B45 ED 6A       >				   adc	hl,hl
210+  8B47 19          >				   add	hl,de
210+  8B48 38 02       >				   jr	c,1F
210+  8B4A ED 52       >				   sbc	hl,de
210+  8B4C             >1:
211+  8B4C                                      BCDIVDE_Iteration
211+  8B4C 17          >				   rla
211+  8B4D ED 6A       >				   adc	hl,hl
211+  8B4F 19          >				   add	hl,de
211+  8B50 38 02       >				   jr	c,1F
211+  8B52 ED 52       >				   sbc	hl,de
211+  8B54             >1:
212+  8B54 17                                   rla
213+  8B55 47                                   ld b,a
214+  8B56
215+  8B56 79                                   ld a,c
216+  8B57                                      BCDIVDE_Iteration
216+  8B57 17          >				   rla
216+  8B58 ED 6A       >				   adc	hl,hl
216+  8B5A 19          >				   add	hl,de
216+  8B5B 38 02       >				   jr	c,1F
216+  8B5D ED 52       >				   sbc	hl,de
216+  8B5F             >1:
217+  8B5F                                      BCDIVDE_Iteration
217+  8B5F 17          >				   rla
217+  8B60 ED 6A       >				   adc	hl,hl
217+  8B62 19          >				   add	hl,de
217+  8B63 38 02       >				   jr	c,1F
217+  8B65 ED 52       >				   sbc	hl,de
217+  8B67             >1:
218+  8B67                                      BCDIVDE_Iteration
218+  8B67 17          >				   rla
218+  8B68 ED 6A       >				   adc	hl,hl
218+  8B6A 19          >				   add	hl,de
218+  8B6B 38 02       >				   jr	c,1F
218+  8B6D ED 52       >				   sbc	hl,de
218+  8B6F             >1:
219+  8B6F                                      BCDIVDE_Iteration
219+  8B6F 17          >				   rla
219+  8B70 ED 6A       >				   adc	hl,hl
219+  8B72 19          >				   add	hl,de
219+  8B73 38 02       >				   jr	c,1F
219+  8B75 ED 52       >				   sbc	hl,de
219+  8B77             >1:
220+  8B77                                      BCDIVDE_Iteration
220+  8B77 17          >				   rla
220+  8B78 ED 6A       >				   adc	hl,hl
220+  8B7A 19          >				   add	hl,de
220+  8B7B 38 02       >				   jr	c,1F
220+  8B7D ED 52       >				   sbc	hl,de
220+  8B7F             >1:
221+  8B7F                                      BCDIVDE_Iteration
221+  8B7F 17          >				   rla
221+  8B80 ED 6A       >				   adc	hl,hl
221+  8B82 19          >				   add	hl,de
221+  8B83 38 02       >				   jr	c,1F
221+  8B85 ED 52       >				   sbc	hl,de
221+  8B87             >1:
222+  8B87                                      BCDIVDE_Iteration
222+  8B87 17          >				   rla
222+  8B88 ED 6A       >				   adc	hl,hl
222+  8B8A 19          >				   add	hl,de
222+  8B8B 38 02       >				   jr	c,1F
222+  8B8D ED 52       >				   sbc	hl,de
222+  8B8F             >1:
223+  8B8F                                      BCDIVDE_Iteration
223+  8B8F 17          >				   rla
223+  8B90 ED 6A       >				   adc	hl,hl
223+  8B92 19          >				   add	hl,de
223+  8B93 38 02       >				   jr	c,1F
223+  8B95 ED 52       >				   sbc	hl,de
223+  8B97             >1:
224+  8B97 17                                   rla
225+  8B98 4F                                   ld c,a
226+  8B99 C9                                   ret
227+  8B9A
228+  8B9A              ;Inputs:
229+  8B9A              ;     DE,BC are 8.8 Fixed Point numbers
230+  8B9A              ;Outputs:
231+  8B9A              ;     DE is the 8.8 Fixed Point result (rounded to the least significant bit)
232+  8B9A              ;if DE is 0 : 122cc or 136cc if BC is negative
233+  8B9A              ;if |BC|>=128*|DE| : 152cc or 166cc if BC is negative
234+  8B9A              ;Otherwise:
235+  8B9A              ;min: 1107cc
236+  8B9A              ;max: 1319cc
237+  8B9A              ;avg: 1201cc
238+  8B9A 78           BC_Div_DE_88:           ld a,b  ; First, find out if the output is positive or negative
239+  8B9B AA                                   xor d
240+  8B9C F5                                   push af   ;sign bit is the result sign bit
241+  8B9D              ; Now make sure the inputs are positive
242+  8B9D A8                                   xor b     ;A now has the value of B, since I XORed it with D twice (cancelling)
243+  8B9E F2 A7 8B                             jp p,BC_Div_DE_88_lbl1   ;if Positive, don't negate
244+  8BA1 AF                                   xor a
245+  8BA2 91                                   sub c
246+  8BA3 4F                                   ld c,a
247+  8BA4 9F                                   sbc a,a
248+  8BA5 90                                   sub b
249+  8BA6 47                                   ld b,a
250+  8BA7 7A           BC_Div_DE_88_lbl1:      ld a,d  ;now make DE negative to optimize the remainder comparison
251+  8BA8 B2                                   or d
252+  8BA9 FA B2 8B                             jp m,BC_Div_DE_88_lbl2
253+  8BAC AF                                   xor a
254+  8BAD 93                                   sub e
255+  8BAE 5F                                   ld e,a
256+  8BAF 9F                                   sbc a,a
257+  8BB0 92                                   sub d
258+  8BB1 57                                   ld d,a
259+  8BB2 B3           BC_Div_DE_88_lbl2:      or e      ;if DE is 0, we can call it an overflow ;A is the current value of D
260+  8BB3 28 1D                                jr z,div_fixed88_overflow
261+  8BB5 26 00                                ld h,0          ;The accumulator gets set to B if no overflow.;We can use H=0 to save a few cc in the meantime
262+  8BB7 78                                   ld a,b;if B+DE>=0, then we'll have overflow
263+  8BB8 83                                   add a,e
264+  8BB9 7A                                   ld a,d
265+  8BBA 8C                                   adc a,h
266+  8BBB 38 15                                jr c,div_fixed88_overflow
267+  8BBD 68                                   ld l,b  ;Now we can load the accumulator/remainder with B;H is already 0
268+  8BBE 79                                   ld a,c
269+  8BBF CD DA 8B                             call div_fixed88_sub
270+  8BC2 4F                                   ld c,a
271+  8BC3 78                                   ld a,b      ;A is now 0
272+  8BC4 CD DA 8B                             call div_fixed88_sub
273+  8BC7 51                                   ld d,c
274+  8BC8 5F                                   ld e,a
275+  8BC9 F1                                   pop af
276+  8BCA F0                                   ret p
277+  8BCB AF                                   xor a
278+  8BCC 93                                   sub e
279+  8BCD 5F                                   ld e,a
280+  8BCE 9F                                   sbc a,a
281+  8BCF 92                                   sub d
282+  8BD0 57                                   ld d,a
283+  8BD1 C9                                   ret
284+  8BD2
285+  8BD2 11 FF 7F     div_fixed88_overflow:   ld de,$7FFF
286+  8BD5 F1                                   pop af
287+  8BD6 F0                                   ret p
288+  8BD7 13                                   inc de
289+  8BD8 1C                                   inc e
290+  8BD9 C9                                   ret
291+  8BDA
292+  8BDA              ;min: 456cc
293+  8BDA              ;max: 536cc
294+  8BDA              ;avg: 496cc
295+  8BDA 06 08        div_fixed88_sub:        ld b,8
296+  8BDC 17           BC_Div_DE_88_lbl3:      rla
297+  8BDD ED 6A                                adc hl,hl
298+  8BDF 19                                   add hl,de
299+  8BE0 38 02                                jr c,$+4
300+  8BE2 ED 52                                sbc hl,de
301+  8BE4 10 F6                                djnz BC_Div_DE_88_lbl3
302+  8BE6 8F                                   adc a,a
303+  8BE7 C9                                   ret
304+  8BE8
# file closed: ./Maths/asm_divide.asm
161   8BE8                  INCLUDE "./Maths/asm_unitvector.asm"
# file opened: ./Maths/asm_unitvector.asm
  1+  8BE8              asm_tis2:
  2+  8BE8              ; ">TIS2 A = (A / Q * 96) so A = -96 ---- 96  range "
  3+  8BE8              ; ">DOES NOT DO SIGNED YET"
  4+  8BE8 F5           	push af
  5+  8BE9 E6 7F            and SignMask8Bit
  6+  8BEB 57           	ld d,a				;; d = A
  7+  8BEC 3A 47 85     	ld a,(varQ)
  8+  8BEF 5F           	ld e,a
  9+  8BF0 7A           	ld a,d
 10+  8BF1 BB           	cp e
 11+  8BF2 30 11        	jr nc, .tis2_set96	;; jump if a >= Q
 12+  8BF4 1E 60        	ld e, 96
 13+  8BF6 ED 30        	mul				; de = d * 96 (also a * 96 )
 14+  8BF8 EB           	ex de,hl
 15+  8BF9 3A 47 85     	ld a,(varQ)
 16+  8BFC 4F           	ld c,a
 17+  8BFD CD D5 8A     	call asm_div16
 18+  8C00 F1           	pop af
 19+  8C01 E6 80        	and $80
 20+  8C03 B5           	or l
 21+  8C04 C9           	ret
 22+  8C05              .tis2_set96:
 23+  8C05 F1           	pop af
 24+  8C06 E6 80        	and $80
 25+  8C08 F6 96        	or $96
 26+  8C0A C9           	ret
 27+  8C0B
 28+  8C0B
 29+  8C0B              asm_unit_vector:
 30+  8C0B              squareregfx:
 31+  8C0B 3A 38 90     	ld a,(UBnkXScaled)
 32+  8C0E 57           	ld d,a
 33+  8C0F 5F           	ld e,a
 34+  8C10 ED 30        	mul
 35+  8C12 EB           	ex de,hl
 36+  8C13              squareregfy:
 37+  8C13 3A 3A 90     	ld a, (UBnkYScaled)
 38+  8C16 57           	ld d,a
 39+  8C17 5F           	ld e,a
 40+  8C18 ED 30        	mul
 41+  8C1A 19           	add hl,de
 42+  8C1B              squareregfz:
 43+  8C1B 3A 3C 90     	ld a, (UBnkZScaled)
 44+  8C1E 57           	ld d,a
 45+  8C1F 5F           	ld e,a
 46+  8C20 ED 30        	mul
 47+  8C22 19           	add hl,de
 48+  8C23 EB           	ex de,hl			; de de to number to root
 49+  8C24              hlequsquareroot:
 50+  8C24 CD D8 89     	call asm_sqrt		; hl = sqrt (fx^2 + fy^2 + fx^2)
 51+  8C27 E5           	push hl				; save it for work 3 copies
 52+  8C28 E5           	push hl				; save it for work
 53+  8C29 E5           	push hl				; save it for work
 54+  8C2A              normfx:
 55+  8C2A 3A 38 90     	ld a,(UBnkXScaled)
 56+  8C2D E1           	pop hl				; get copy #1
 57+  8C2E 7D           	ld a,l				; we assume only l had worthwhile data but could spill into h
 58+  8C2F 4F           	ld c,a
 59+  8C30 CD E8 8B     	call asm_tis2
 60+  8C33 32 38 90     	ld (UBnkXScaled),a
 61+  8C36              normfy:
 62+  8C36 3A 3A 90     	ld a,(UBnkYScaled)
 63+  8C39 E1           	pop hl				; get copy #2
 64+  8C3A 7D           	ld a,l
 65+  8C3B 4F           	ld c,a
 66+  8C3C CD E8 8B     	call asm_tis2
 67+  8C3F 32 3A 90     	ld (UBnkYScaled),a
 68+  8C42              normfz:
 69+  8C42 3A 3C 90     	ld a,(UBnkZScaled)
 70+  8C45 E1           	pop hl				; get copy #2
 71+  8C46 7D           	ld a,l
 72+  8C47 4F           	ld c,a
 73+  8C48 CD E8 8B     	call asm_tis2
 74+  8C4B 32 3C 90     	ld (UBnkZScaled),a
 75+  8C4E              asm_unit_vector_end:
 76+  8C4E C9           	ret
 77+  8C4F
# file closed: ./Maths/asm_unitvector.asm
162   8C4F                  INCLUDE "./Maths/compare16.asm"
# file opened: ./Maths/compare16.asm
  1+  8C4F              compare16HLDE:
  2+  8C4F              ; Input:
  3+  8C4F              ;       HL = 1st value
  4+  8C4F              ;       DE = 2nd value
  5+  8C4F              ; Output:
  6+  8C4F              ;       CF, ZF = results of comparison:
  7+  8C4F              ;
  8+  8C4F              ;               CF      ZF      Result
  9+  8C4F              ;               -----------------------------------
 10+  8C4F              ;               0       0       HL > DE
 11+  8C4F              ;               0       1       HL == DE
 12+  8C4F              ;               1       0       HL < DE
 13+  8C4F              ;               1       1       Impossible
 14+  8C4F              ;
 15+  8C4F E5           		push    hl
 16+  8C50 A7           		and     a
 17+  8C51 ED 52        		sbc     hl,de
 18+  8C53 E1           		pop     hl
 19+  8C54 C9           		ret
 20+  8C55
# file closed: ./Maths/compare16.asm
163   8C55                  INCLUDE "./Maths/negate16.asm"
# file opened: ./Maths/negate16.asm
  1+  8C55              ;;----------------------------------------------------------------------------------------------------------------------
  2+  8C55              ;; 16-bit negate
  3+  8C55              negate16:
  4+  8C55              negate16hl:
  5+  8C55                      ; Input:
  6+  8C55                      ;       HL = value
  7+  8C55                      ; Output:
  8+  8C55                      ;       HL = -value
  9+  8C55                      ; Destroys:
 10+  8C55                      ;       AF
 11+  8C55                      ;
 12+  8C55 AF           	xor 	a
 13+  8C56 95           	sub 	l
 14+  8C57 6F           	ld 		l,a
 15+  8C58 9F           	sbc 	a,a
 16+  8C59 94           	sub 	h
 17+  8C5A 67           	ld 		h,a
 18+  8C5B C9           	ret
 19+  8C5C
 20+  8C5C              negate16de:
 21+  8C5C AF           	xor 	a
 22+  8C5D 93           	sub 	e
 23+  8C5E 5F           	ld 		e,a
 24+  8C5F 9F           	sbc 	a,a
 25+  8C60 92           	sub 	d
 26+  8C61 57           	ld 		d,a
 27+  8C62 C9           	ret
 28+  8C63
 29+  8C63              negate16bc:
 30+  8C63 AF           	xor 	a
 31+  8C64 91           	sub 	c
 32+  8C65 4F           	ld 		c,a
 33+  8C66 9F           	sbc 	a,a
 34+  8C67 90           	sub 	b
 35+  8C68 47           	ld 		b,a
 36+  8C69 C9           	ret
 37+  8C6A
 38+  8C6A
 39+  8C6A              macronegate16hl:	MACRO
 40+  8C6A ~            					xor 	a
 41+  8C6A ~            					sub 	l
 42+  8C6A ~            					ld 		l,a
 43+  8C6A ~            					sbc 	a,a
 44+  8C6A ~            					sub 	h
 45+  8C6A ~            					ld 		h,a
 46+  8C6A              					ENDM
 47+  8C6A
 48+  8C6A              macronegate16de:	MACRO
 49+  8C6A ~            					xor 	a
 50+  8C6A ~                                sub 	e
 51+  8C6A ~                                ld 		e,a
 52+  8C6A ~                                sbc 	a,a
 53+  8C6A ~                                sub 	d
 54+  8C6A ~                                ld 		d,a
 55+  8C6A              					ENDM
 56+  8C6A              macronegate16bc:	MACRO
 57+  8C6A ~            					xor 	a
 58+  8C6A ~                                sub 	c
 59+  8C6A ~                                ld 		c,a
 60+  8C6A ~                                sbc 	a,a
 61+  8C6A ~                                sub 	b
 62+  8C6A ~                                ld 		b,a
 63+  8C6A              					ENDM
 64+  8C6A
 65+  8C6A              macronegate16ix:	MACRO
 66+  8C6A ~            					xor 	a
 67+  8C6A ~                                sub 	ixl
 68+  8C6A ~                                ld 		ixl,a
 69+  8C6A ~                                sbc 	a,a
 70+  8C6A ~                                sub 	ixh
 71+  8C6A ~                                ld 		ixh,a
 72+  8C6A              					ENDM
# file closed: ./Maths/negate16.asm
164   8C6A              ;    INCLUDE "./Maths/normalise96.asm"
165   8C6A                  INCLUDE "./Maths/binary_to_decimal.asm"
# file opened: ./Maths/binary_to_decimal.asm
  1+  8C6A              ;Number in hl to decimal ASCII
  2+  8C6A              ;Thanks to z80 Bits
  3+  8C6A              ;inputs:	hl = number to ASCII
  4+  8C6A              ;example: hl=300 outputs '00300'
  5+  8C6A              ;destroys: af, bc, hl, de used
  6+  8C6A              DispHLtoDE:
  7+  8C6A              ; "DispHL, writes HL to DE address"
  8+  8C6A 01 F0 D8     	ld	bc,-10000
  9+  8C6D CD 83 8C     	call	Num1
 10+  8C70 01 18 FC     	ld	bc,-1000
 11+  8C73 CD 83 8C     	call	Num1
 12+  8C76 01 9C FF     	ld	bc,-100
 13+  8C79 CD 83 8C     	call	Num1
 14+  8C7C 0E F6        	ld	c,-10
 15+  8C7E CD 83 8C     	call	Num1
 16+  8C81 0E FF        	ld	c,-1
 17+  8C83              Num1:
 18+  8C83 3E 2F        	ld	a,'0'-1
 19+  8C85              .Num2:
 20+  8C85 3C           	inc	a
 21+  8C86 09           	add	hl,bc
 22+  8C87 38 FC        	jr	c,.Num2
 23+  8C89 ED 42        	sbc	hl,bc
 24+  8C8B 12           	ld	(de),a
 25+  8C8C 13           	inc	de
 26+  8C8D C9           	ret
 27+  8C8E
 28+  8C8E              DispAtoDE:
 29+  8C8E 26 00        	ld h,0
 30+  8C90 6F           	ld l,a
 31+  8C91 C3 6A 8C     	jp DispHLtoDE
 32+  8C94
 33+  8C94              DispPriceAtoDE:
 34+  8C94 26 00        	ld h,0
 35+  8C96 6F           	ld l,a
 36+  8C97 01 9C FF     	ld	bc,-100
 37+  8C9A CD AA 8C     	call	.NumLeadBlank1
 38+  8C9D 0E F6        	ld	c,-10
 39+  8C9F CD 83 8C     	call	Num1
 40+  8CA2 3E 2E        	ld		a,'.'					; we could assume preformat but
 41+  8CA4 12           	ld		(de),a					; we can optimse that later TODO
 42+  8CA5 13           	inc		de						; with just an inc De
 43+  8CA6 0E FF        	ld	c,-1
 44+  8CA8 18 D9        	jr		Num1
 45+  8CAA              .NumLeadBlank1:
 46+  8CAA 3E 2F        	ld	a,'0'-1
 47+  8CAC              .NumLeadBlank2:
 48+  8CAC 3C           	inc	a
 49+  8CAD 09           	add	hl,bc
 50+  8CAE 38 FC        	jr	c,.NumLeadBlank2
 51+  8CB0 FE 30        	cp	'0'
 52+  8CB2 20 02        	jr	nz,.DontBlank
 53+  8CB4              .Blank:
 54+  8CB4 3E 20        	ld	a,' '
 55+  8CB6              .DontBlank:
 56+  8CB6 ED 42        	sbc	hl,bc
 57+  8CB8 12           	ld	(de),a
 58+  8CB9 13           	inc	de
 59+  8CBA C9           	ret
 60+  8CBB
 61+  8CBB              DispQtyAtoDE:
 62+  8CBB FE 00        	cp	0
 63+  8CBD 28 23        	jr	z,.NoStock
 64+  8CBF 26 00        	ld h,0
 65+  8CC1 6F           	ld l,a
 66+  8CC2 01 9C FF     	ld	bc,-100
 67+  8CC5 CD D1 8C     	call	.NumLeadBlank1
 68+  8CC8 0E F6        	ld	c,-10
 69+  8CCA CD D1 8C     	call	.NumLeadBlank1
 70+  8CCD 0E FF        	ld	c,-1
 71+  8CCF 18 B2        	jr		Num1
 72+  8CD1              .NumLeadBlank1:
 73+  8CD1 3E 2F        	ld	a,'0'-1
 74+  8CD3              .NumLeadBlank2:
 75+  8CD3 3C           	inc	a
 76+  8CD4 09           	add	hl,bc
 77+  8CD5 38 FC        	jr	c,.NumLeadBlank2
 78+  8CD7 FE 30        	cp	'0'
 79+  8CD9 20 02        	jr	nz,.DontBlank
 80+  8CDB              .Blank:
 81+  8CDB 3E 20        	ld	a,' '
 82+  8CDD              .DontBlank:
 83+  8CDD ED 42        	sbc	hl,bc
 84+  8CDF 12           	ld	(de),a
 85+  8CE0 13           	inc	de
 86+  8CE1 C9           	ret
 87+  8CE2              .NoStock:
 88+  8CE2 3E 20        	ld	a,' '
 89+  8CE4 12           	ld	(de),a
 90+  8CE5 13           	inc	de
 91+  8CE6 12           	ld	(de),a
 92+  8CE7 13           	inc	de
 93+  8CE8 3E 2D        	ld	a,'-'
 94+  8CEA 12           	ld	(de),a
 95+  8CEB 13           	inc de
 96+  8CEC C9           	ret
 97+  8CED
 98+  8CED
 99+  8CED              ;### CLCN32 -> Converts 32Bit-Value in ASCII-String (terminated by 0)
100+  8CED              ;### Input      DE,IX=32bit value, IY=destination address
101+  8CED              ;### Output     IY=last char in destination string
102+  8CED              ;### Destroyed AF,BC,DE,HL,IX
103+  8CED 01 00 00 00  clcn32t dw 1,0,     10,0,     100,0,     1000,0,       10000,0
103+  8CF1 0A 00 00 00
103+  8CF5 64 00 00 00
103+  8CF9 E8 03 00 00
103+  8CFD 10 27 00 00
104+  8D01 A0 86 01 00          dw $86a0,1, $4240,$0f, $9680,$98, $e100,$05f5, $ca00,$3b9a
104+  8D05 40 42 0F 00
104+  8D09 80 96 98 00
104+  8D0D 00 E1 F5 05
104+  8D11 00 CA 9A 3B
105+  8D15 00 00 00 00  clcn32z ds 4
106+  8D19
107+  8D19              ; As per display but shifts final digit by 1 and puts in "." for 1 decimal place
108+  8D19 CD 28 8D     DispDEIXtoIY1DP:        call    DispDEIXtoIY
109+  8D1C FD 7E 00                             ld      a,(IY+0)
110+  8D1F FD 77 01                             ld      (IY+1),a
111+  8D22 3E 2E                                ld      a,"."
112+  8D24 FD 77 00                             ld      (IY+0),a
113+  8D27 C9                                   ret
114+  8D28
115+  8D28 DD 22 15 8D  DispDEIXtoIY:           ld (clcn32z),ix
116+  8D2C ED 53 17 8D                          ld (clcn32z+2),de
117+  8D30 DD 21 11 8D                          ld ix,clcn32t+36
118+  8D34 06 09                                ld b,9
119+  8D36 0E 00                                ld c,0
120+  8D38 3E 30        .clcn321:               ld a,'0'
121+  8D3A B7                                   or a
122+  8D3B DD 5E 00     .clcn322:               ld e,(ix+0)
123+  8D3E DD 56 01                             ld d,(ix+1)
124+  8D41 2A 15 8D                             ld hl,(clcn32z)
125+  8D44 ED 52                                sbc hl,de
126+  8D46 22 15 8D                             ld (clcn32z),hl
127+  8D49 DD 5E 02                             ld e,(ix+2)
128+  8D4C DD 56 03                             ld d,(ix+3)
129+  8D4F 2A 17 8D                             ld hl,(clcn32z+2)
130+  8D52 ED 52                                sbc hl,de
131+  8D54 22 17 8D                             ld (clcn32z+2),hl
132+  8D57 38 04                                jr c,.clcn325
133+  8D59 0C                                   inc c
134+  8D5A 3C                                   inc a
135+  8D5B 18 DE                                jr .clcn322
136+  8D5D DD 5E 00     .clcn325:               ld e,(ix+0)
137+  8D60 DD 56 01                             ld d,(ix+1)
138+  8D63 2A 15 8D                             ld hl,(clcn32z)
139+  8D66 19                                   add hl,de
140+  8D67 22 15 8D                             ld (clcn32z),hl
141+  8D6A DD 5E 02                             ld e,(ix+2)
142+  8D6D DD 56 03                             ld d,(ix+3)
143+  8D70 2A 17 8D                             ld hl,(clcn32z+2)
144+  8D73 ED 5A                                adc hl,de
145+  8D75 22 17 8D                             ld (clcn32z+2),hl
146+  8D78 11 FC FF                             ld de,-4
147+  8D7B DD 19                                add ix,de
148+  8D7D 0C                                   inc c
149+  8D7E 0D                                   dec c
150+  8D7F 28 05                                jr z,.clcn323
151+  8D81 FD 77 00                             ld (iy+0),a
152+  8D84 FD 23                                inc iy
153+  8D86 10 B0        .clcn323:               djnz .clcn321
154+  8D88 3A 15 8D                             ld a,(clcn32z)
155+  8D8B C6 30                                add A,'0'
156+  8D8D FD 77 00                             ld (iy+0),a
157+  8D90 FD 36 01 00                          ld (iy+1),0
158+  8D94 C9                                   ret
159+  8D95
# file closed: ./Maths/binary_to_decimal.asm
166   8D95
167   8D95
168   8D95              ;--------------------------------------------------------------------------------------------------------------------
169   8D95
170   8D95 00           clipDx                  DB      0           ; also XX12+2
171   8D96 00           clipDxHigh              DB      0           ; also XX12+3
172   8D97 00           clipDxHighNonABS        DB      0           ; also XX12+3
173   8D98 00           clipDy                  DB      0           ; also XX12+4
174   8D99 00           clipDyHigh              DB      0           ; also XX12+5
175   8D9A 00           clipGradient            DB      0
176   8D9B 00           clipDxySign             DB      0
177   8D9C              varX12p3                equ     clipDxySign
178   8D9C 00           clipXGTY                DB      0
179   8D9D 00           clipFlags               DB      0
180   8D9E 00           SWAP                    DB      0
181   8D9F 00 00        varYX                   DW      0
182   8DA1 00           varRegX                 DB      0
183   8DA2 00           varXX12p2               DB      0
184   8DA3 00           clipXX13                 DB      0
185   8DA4
186   8DA4              CLIP:
187   8DA4              ; bounds check and the start to avoid dxy calcs if off screen, eliminating off screens first saves a lot of uncessary mul/div
188   8DA4              ClipXX15XX12Line:
189   8DA4
190   8DA4 ED 4B 3A 90  ClipV2:                 ld      bc,(UbnkPreClipY1)
191   8DA8 DD 2A 3E 90                          ld      ix,(UbnkPreClipY2)
192   8DAC 2A 38 90                             ld      hl,(UbnkPreClipX1)
193   8DAF ED 5B 3C 90                          ld      de,(UbnkPreClipX2)
194   8DB3 DD 01                                break
195   8DB5
196   8DB5 AF                                   xor     a
197   8DB6 32 9E 8D                             ld      (SWAP),a                    ; SWAP = 0
198   8DB9 7A                                   ld      a,d                         ; A = X2Hi
199   8DBA FD 26 BF     .LL147:                 ld      iyh,191                     ; we need to be 191 as its 128 + another bit set from 0 to 6, we are using iyh as regX
200   8DBD F5                                           push    af
201   8DBE FD 7C                                        ld      a,iyh
202   8DC0 32 76 84                                     ld      (regX),a
203   8DC3 F1                                           pop     af
204   8DC4 DD B4                                or      ixh                         ; if (X2Hi L-OR Y2 Hi <> 0) or (Y2 > 191) set XX13 to 191, goto LL107             -- X2Y2 off screen
205   8DC6 20 11                                jr      nz, .LL107
206   8DC8 DD 7C                                ld      a,ixh
207   8DCA ED 27 80                             test    $80
208   8DCD 20 0A                                jr      nz,.LL107
209   8DCF FD 26 00                             ld      iyh, 0                      ; regX = 0                                                                        -- X2Y2 on screen
210   8DD2 F5                                           push    af
211   8DD3 FD 7C                                        ld      a,iyh
212   8DD5 32 76 84                                     ld      (regX),a
213   8DD8 F1                                           pop     af
214   8DD9              ; XX13 = regX (i.e. iyh)      ( if XX13 = XX13 is 191 if (x2, y2) is off-screen else 0) we bin XX13 as not needed
215   8DD9              ; so XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen,  XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lo is off the bottom of the screen
216   8DD9 7C           .LL107                  ld      a,h                         ; If (X1 hi L-OR Y1) hi  goto LL83                   -- X1Y1 off screen and maybe X2Y2
217   8DDA B0                                   or      b
218   8DDB 20 2E                                jr      nz,.LL83
219   8DDD 79                                   ld      a,c                         ; or (y1 lo > bottom of screen)
220   8DDE ED 27 80                             test    $80
221   8DE1 20 28                                jr      nz,.LL83
222   8DE3              ; If we get here, (x1, y1) is on-screen
223   8DE3 FD 7C                                ld      a,iyh                       ; iyh = xx13 at this point if  XX13 <> 0 goto LL108                                                        -- X1Y1 on screen, if we flagged X2Y2 off screen goto LL108
224   8DE5 FE 00                                cp      0
225   8DE7 20 15                                jr      nz, .LL108
226   8DE9 79           .ClipDone:              ld      a,c                         ; LL146 (Clip Done)               Y1 = y1 lo, x2 = x2 lo, x1 = x1 lo y1 = y1 lo                                   -- Nothing off screen
227   8DEA 32 39 90                             ld      (UBnkNewY1),a
228   8DED DD 7D                                ld      a,ixl
229   8DEF 32 3B 90                             ld      (UBnkNewY2),a
230   8DF2 7D                                   ld      a,l
231   8DF3 32 38 90                             ld      (UBnkNewX1),a
232   8DF6 7B                                   ld      a,e
233   8DF7 32 3A 90                             ld      (UBnkNewX2),a
234   8DFA                                      ClearCarryFlag                      ; carry is clear so valid to plot is in XX15(0to3)
234   8DFA B7          >				or a
235   8DFB C9                                   ret                                 ; 2nd pro different, it swops based on swop flag around here.
236   8DFC 37           .PointsOutofBounds:     scf                                 ; LL109 (ClipFailed) carry flag set as not visible
237   8DFD C9                                   ret
238   8DFE FD 7C        .LL108:                 ld      a,iyh
239   8E00 B7                                   or      a
240   8E01 1F                                   rra
241   8E02 FD 67                                ld      iyh,a                       ; (X2Y2 Off Screen)         XX13 = 95 (i.e. divide it by 2)                                                 -- X1Y1 on screen X2Y2 off screen
242   8E04 F5                                           push    af
243   8E05 FD 7C                                        ld      a,iyh
244   8E07 32 76 84                                     ld      (regX),a
245   8E0A F1                                           pop     af
246   8E0B FD 7C        .LL83:                  ld      a,iyh                       ; (Line On screen Test)      if XX13 < 128 then only 1 point is on screen so goto LL115                      -- We only need to deal with X2Y2
247   8E0D ED 27 80                             test    $80
248   8E10 28 24                                jr      z, .LL115
249   8E12 7C                                   ld      a,h                         ; If both x1_hi and x2_hi have bit 7 set, jump to LL109  to return from the subroutine with the C flag set, as the entire line is above the top of the screen
250   8E13 A2                                   and     d
251   8E14 20 E6                                jr      nz, .PointsOutofBounds
252   8E16 78                                   ld      a,b                         ; If both y1_hi and y2_hi have bit 7 set, jump to LL109  to return from the subroutine with the C flag set, as the entire line is above the top of the screen
253   8E17 DD B4                                or      ixh
254   8E19 20 E1                                jr      nz, .PointsOutofBounds
255   8E1B 7C                                   ld      a,h                         ; If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set, jump to LL109 to return from the subroutine with the C  flag set, as the line doesn't fit on-screen
256   8E1C 3D                                   dec     a
257   8E1D FD 6F                                ld      iyl,a                       ; using iyl as XX12+2 var
258   8E1F F5                                           push    af
259   8E20 FD 7D                                        ld      a,iyl
260   8E22 32 A2 8D                                     ld      (varXX12p2),a
261   8E25 F1                                           pop     af
262   8E26 7A                                   ld      a,d
263   8E27 3D                                   dec     a
264   8E28 FD B5                                or      iyl                         ; using iyl as XX12+2 var
265   8E2A F2 FC 8D                             jp      p, .PointsOutofBounds
266   8E2D 79                                   ld      a,c                         ; If y1_lo < y-coordinate of screen bottom, clear the C flag, otherwise set it
267   8E2E DD A5                                and     ixl
268   8E30 ED 27 80                             test    $80
269   8E33 C2 FC 8D                             jp      nz, .PointsOutofBounds      ;Both are positive but are they both > 127
270   8E36              ;                        cp      $80
271   8E36              ;                        ccf                                 ; flip carry flag for the sbc
272   8E36              ;                        ld      a,b                         ; We do this subtraction because we are only interested in trying to move the points up by a screen if that might move the point into the space view portion of the screen, i.e. if y1_lo is on-screen
273   8E36              ;                        sbc     0
274   8E36              ;                        or      ixl                         ; If neither XX12+1 (ixk or Y2 low) or XX12+2 (ixh or Y2 high) have bit 7 set, jump to If neither XX12+1 or XX12+2 have bit 7 set, jump to If neither XX12+1 or XX12+2 have bit 7 set, jump to
275   8E36              ;                        jp      p, .PointsOutofBounds
276   8E36              ; Clip line: calulate the line's gradient
277   8E36              ; here as an optimisation we make sure X1 is always < X2  later on
278   8E36 DD 01        .LL115:                 break
279   8E38                                      ClearCarryFlag
279   8E38 B7          >				or a
280   8E39 7B                                   ld      a,e
281   8E3A 9D                                   sbc     a,l
282   8E3B 32 95 8D                             ld      (clipDx),a
283   8E3E 7A                                   ld      a,d
284   8E3F 9C                                   sbc     a,h
285   8E40 32 96 8D                             ld      (clipDxHigh),a                ; later we will just move to sub hl,de
286   8E43 32 97 8D                             ld      (clipDxHighNonABS),a          ; it looks liek we need this later post scale loop
287   8E46                                      ClearCarryFlag
287   8E46 B7          >				or a
288   8E47 DD 7D                                ld      a,ixl
289   8E49 99                                   sbc     c
290   8E4A 32 98 8D                             ld      (clipDy),a
291   8E4D DD 7C                                ld      a,ixh
292   8E4F 98                                   sbc     a,b
293   8E50 32 99 8D                             ld      (clipDyHigh),a              ; so A = sign of deltay in effect
294   8E53              ;So we now have delta_x in XX12(3 2), delta_y in XX12(5 4)  where the delta is (x1, y1) - (x2, y2))
295   8E53 E5                                   push    hl                          ; Set S = the sign of delta_x * the sign of delta_y, so if bit 7 of S is set, the deltas have different signs
296   8E54 21 96 8D                             ld      hl,clipDxHigh
297   8E57 AE                                   xor     (hl)                        ; now a = sign dx xor sign dy
298   8E58 32 49 85                             ld      (varS),a                    ; DEBGU putting it in var S too for now
299   8E5B 32 9B 8D                             ld      (clipDxySign),a
300   8E5E 3A 99 8D     .AbsDy:                 ld      a,(clipDyHigh)
301   8E61 ED 27 80                             test    $80
302   8E64 28 0C                                jr      z,.LL110                    ; If delta_y_hi is positive, jump down to LL110 to skip the following
303   8E66 2A 98 8D                             ld      hl,(clipDy)
304   8E69                                      macronegate16hl                     ; Otherwise flip the sign of delta_y to make it  positive, starting with the low bytes
304   8E69 AF          >					xor 	a
304   8E6A 95          >					sub 	l
304   8E6B 6F          >					ld 		l,a
304   8E6C 9F          >					sbc 	a,a
304   8E6D 94          >					sub 	h
304   8E6E 67          >					ld 		h,a
305   8E6F 22 98 8D                             ld      (clipDy),hl
306   8E72 3A 96 8D     .LL110:                 ld      a,(clipDxHigh)
307   8E75 ED 27 80                             test    $80                         ; is it a negative X
308   8E78 28 0C                                jr      z,.LL111                    ; If delta_x_hi is positive, jump down to LL110 to skip the following
309   8E7A 2A 95 8D                             ld      hl,(clipDx)
310   8E7D                                      macronegate16hl                     ; Otherwise flip the sign of delta_y to make it  positive, starting with the low bytes
310   8E7D AF          >					xor 	a
310   8E7E 95          >					sub 	l
310   8E7F 6F          >					ld 		l,a
310   8E80 9F          >					sbc 	a,a
310   8E81 94          >					sub 	h
310   8E82 67          >					ld 		h,a
311   8E83 22 95 8D                             ld      (clipDx),hl                 ; we still retain the old sign in NonABS version
312   8E86 D5           .LL111:                 push    de
313   8E87 2A 95 8D                             ld      hl,(clipDx)
314   8E8A ED 5B 98 8D                          ld      de,(clipDy)
315   8E8E 7C           .ScaleLoop:             ld      a,h                         ; At this point DX and DY are ABS values
316   8E8F B2                                   or      d
317   8E90 28 0A                                jr      z,.CalculateDelta
317   8E92
318   8E92                                      ShiftDERight1
318   8E92 CB 3A       >			   srl d
318   8E94 CB 1B       >			   rr  e
319   8E96                                      ShiftHLRight1
319   8E96 CB 3C       >			   srl h
319   8E98 CB 1D       >			   rr  l
320   8E9A 18 F2                                jr      .ScaleLoop                  ; scaled down Dx and Dy to 8 bit, Dy may have been negative
321   8E9C 22 95 8D     .CalculateDelta:        ld      (clipDx),hl
322   8E9F ED 53 98 8D                          ld      (clipDy),de
323   8EA3              ; By now, the high bytes of both |delta_x| and |delta_y| are zero We know that h and d are both = 0 as that's what we tested with a BEQ
324   8EA3 AF           .LL113:                 xor     a
325   8EA4 32 68 85                             ld      (varT),a                    ; t = 0
326   8EA7 3A 95 8D                             ld      a,(clipDx)                  ; If delta_x_lo < delta_y_lo, so our line is more vertical than horizontal, jump to LL114
327   8EAA 21 98 8D                             ld      hl,clipDy
328   8EAD                                      JumpIfALTNusng  (hl), .LL114
328   8EAD BE          >                        cp      (hl)
328   8EAE DA C0 8E    >                        jp		c,.LL114
329   8EB1              ; Here Dx >= Dy (we need an optimisation for pure horizontal and vert adding back in again)
330   8EB1 32 47 85     .DxGTEDy:               ld      (varQ),a                    ; Set Q = delta_x_lo
331   8EB4 57                                   ld      d,a                         ; d = also Q for calc
332   8EB5 3A 98 8D                             ld      a,(clipDy)                  ; Set A = delta_y_lo
333   8EB8 CD B9 88                             call    LL28Amul256DivD             ; Call LL28 to calculate:  R (actually a reg) = 256 * A / Q   = 256 * delta_y_lo / delta_x_lo
334   8EBB 32 48 85                             ld      (varR),a                    ;
335   8EBE 18 14                                jr      .LL116                      ; Jump to LL116, as we now have the line's gradient in R
336   8EC0 3A 98 8D     .LL114:                 ld      a,(clipDy)                  ; Set Q = delta_y_lo
337   8EC3 57                                   ld      d,a
338   8EC4 32 47 85                             ld      (varQ),a
339   8EC7 3A 95 8D                             ld      a,(clipDx)                  ; Set A = delta_x_lo
340   8ECA CD B9 88                             call    LL28Amul256DivD             ; Call LL28 to calculate: R = 256 * A / Q  = 256 * delta_x_lo / delta_y_lo
341   8ECD 32 48 85                             ld      (varR),a                    ;
342   8ED0 21 68 85                             ld      hl,varT                     ; T was set to 0 above, so this sets T = &FF
343   8ED3 35                                   dec     (hl)
344   8ED4 D1           .LL116:                 pop     de                          ; get back X2
345   8ED5 E1                                   pop     hl                          ; get back X1 into hl,
346   8ED6 3A 48 85                             ld      a,(varR)                    ; Store the gradient in XX12+2 this can be optimised later
347   8ED9 32 9A 8D                             ld      (clipGradient),a
348   8EDC FD 6F                                ld      iyl,a
349   8EDE F5                                           push    af
350   8EDF FD 7D                                        ld      a,iyl
351   8EE1 32 A2 8D                                     ld      (varXX12p2),a
352   8EE4 F1                                           pop     af
353   8EE5 3A 49 85                             ld      a,(varS)
354   8EE8 32 9B 8D                             ld      (clipDxySign),a             ;  Store the type of slope in XX12+3, bit 7 clear means ?Not needed as clipDxySign is used for varS earlier?
355   8EEB                                                                          ; top left to bottom right, bit 7 set means top right to bottom left **CODE IS WRONG HERE A TEST IS BL to TR
356   8EEB FD 7C                                ld      a,iyh                       ; iyh was XX13 from earlier
357   8EED FE 00                                cp      0                           ; If XX13 = 0, skip the following instruction
358   8EEF 28 05                                jr      z,.LL138                    ;
359   8EF1 ED 27 80                             test    $80                         ; If XX13 is positive, it must be 95. This means (x1, y1) is on-screen but (x2, y2) isn't, so we jump to LLX117 to swap the (x1, y1) and (x2, y2)
360   8EF4 28 17                                jr      z,.LLX117                   ; coordinates around before doing the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
361   8EF6              ; If we get here, XX13 = 0 or 191, so (x1, y1) is off-screen and needs clipping
362   8EF6 CD 21 8F     .LL138                  call    ClipPointHLBC               ; Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
363   8EF9 FD 7C                                ld      a,iyh                       ; If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to LL124 to return with a successfully clipped line
364   8EFB ED 27 80                             test    $80
365   8EFE 28 1E                                jr      z,.LL124
366   8F00              ; If we get here, XX13 = 191 (both coordinates are off-screen)
367   8F00 7C           .LL117:                 ld      a,h                         ; If either of x1_hi or y1_hi are non-zero, jump to
368   8F01 B1                                   or      c                           ; LL137 to return from the subroutine with the C flag
369   8F02 C2 FC 8D                             jp      nz, .PointsOutofBounds      ; set, as the line doesn't fit on-screen
370   8F05 DD 7D                                ld      a,ixl                       ; If y1_lo > y-coordinate of the bottom of the screen
371   8F07 ED 27 80                             test    $80                         ; jump to LL137 to return from the subroutine with the
372   8F0A C2 FC 8D                             jp      nz,.PointsOutofBounds       ; C flag set, as the line doesn't fit on-screen
373   8F0D              ; If we get here, XX13 = 95 or 191, and in both cases (x2, y2) is off-screen, so we now need to swap the (x1, y1) and (x2, y2) coordinates around before doing
374   8F0D              ; the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
375   8F0D EB           .LLX117:                ex      de,hl                       ;  swap X1 and X2
376   8F0E DD E5                                push    ix                          ;  swap Y1 and Y2
377   8F10 C5                                   push    bc
378   8F11 DD E1                                pop     ix
379   8F13 C1                                   pop     bc
380   8F14 CD F6 8E                             call    .LL138                       ;  Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
381   8F17 3A 9E 8D                             ld      a,(SWAP)
382   8F1A 3D                                   dec     a
383   8F1B 32 9E 8D                             ld      (SWAP),a                    ; Set SWAP = &FF to indicate that we just clipped the line at the (x2, y2) end by swapping the coordinates (the DEC does this as we set SWAP to 0 at the start of this subroutine)
384   8F1E C3 E9 8D     .LL124:                 jp      .ClipDone                    ; now put points in place
385   8F21
386   8F21              ; Move a point along a line until it is on-screen point is held in HL(X) BC(Y) LL118
387   8F21              ; iyh still holds XX13 iyl still holds gradient
388   8F21 7C           ClipPointHLBC:          ld      a,h                         ; If x1_hi is positive, jump down to LL119 to skip the following
389   8F22 ED 27 80                             test    $80
390   8F25 28 17                                jr      z,.LL119
391   8F27 32 49 85     .X1isNegative:          ld      (varS),a                    ;  Otherwise x1_hi is negative, i.e. off the left of the screen, so set S = x1_hi
392   8F2A E5 D5 C5                             push    hl,,de,,bc
393   8F2D CD A7 8F                             call    LL120                       ;  Call LL120 to calculate:   (Y X) = (S x1_lo) * XX12+2      if T = 0   = x1 * gradient
394   8F30                                                                          ;                             (Y X) = (S x1_lo) / XX12+2      if T <> 0  = x1 / gradient
395   8F30                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
396   8F30 C1 D1 E1                             pop    hl,,de,,bc                   ;  get coordinates back
397   8F33 2A 9F 8D                             ld      hl,(varYX)
398   8F36              ;                        ex      hl,de
399   8F36                                  ;    ld      hl,bc
400   8F36 09                                   add     hl,bc                       ; y1 = y1 + varYX
401   8F37 44 4D                                ld      bc,hl
402   8F39 21 00 00                             ld      hl,0                        ; Set x1 = 0
403   8F3C               ;                       pop     de
404   8F3C 18 1D                                jr      .LL134                      ; in BBC is set x to 0 to force jump, we will just jump
405   8F3E FE 00        .LL119:                 cp      0
406   8F40 28 19                                jr      z,.LL134                    ;  If x1_hi = 0 then jump down to LL134 to skip the following, as the x-coordinate is already on-screen (as 0 <= (x_hi x_lo) <= 255)
407   8F42 3D                                   dec     a
408   8F43 32 49 85                             ld      (varS),a                    ;  Otherwise x1_hi is positive, i.e. x1 >= 256 and off the right side of the screen, so set S = x1_hi - 1
409   8F46 E5 D5 C5                             push    hl,,de,,bc
410   8F49 CD A7 8F                             call    LL120                      ;  Call LL120 to calculate: (Y X) = (S x1_lo) * XX12+2      if T = 0  = (x1 - 256) * gradient
411   8F4C                                                                          ;                           (Y X) = (S x1_lo) / XX12+2      if T <> 0 = (x1 - 256) / gradient
412   8F4C                                                                          ;  with the sign of (Y X) set to the opposite of theline's direction of slope
413   8F4C C1 D1 E1                             pop     hl,,de,,bc
414   8F4F D5                                   push    de                          ; Set y1 = y1 + (Y X)
415   8F50 2A 9F 8D                             ld      hl,(varYX)
416   8F53 EB                                   ex      hl,de
417   8F54 60 69                                ld      hl,bc
418   8F56 09                                   add     hl,bc                       ; y1 = y1 + varYX
419   8F57 21 FF 00                             ld      hl,255                      ; Set x1 = 255
420   8F5A D1                                   pop     de
421   8F5B              ; We have moved the point so the x-coordinate is on screen (i.e. in the range 0-255), so now for they-coordinate
422   8F5B 78           .LL134:                 ld      a,b                         ; If y1_hi is positive, jump down to LL119 to skip the following
423   8F5C ED 27 80                             test    $80
424   8F5F 28 1B                                jr      z,.LL135
425   8F61 78                                   ld      a,b
426   8F62 32 49 85                             ld      (varS),a                    ;  Otherwise y1_hi is negative, i.e. off the top of the screen, so set S = y1_hi
427   8F65 79                                   ld      a,c                         ;  Set R = y1_lo
428   8F66 32 48 85                             ld      (varR),a
429   8F69 E5 D5 C5                             push    hl,,de,,bc
430   8F6C CD D0 8F                             call    LL123                       ;  Call LL123 to calculate: (Y X) = (S R) / XX12+2      if T = 0  = y1 / gradient
431   8F6F                                                                          ;                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
432   8F6F                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
433   8F6F C1 D1 E1                             pop     hl,,de,,bc
434   8F72 D5                                   push    de
435   8F73 EB                                   ex      hl,de
436   8F74 2A 9F 8D                             ld      hl,(varYX)
437   8F77 19                                   add     hl,de                       ; we don't need to swap back as its an add, Set x1 = x1 + (Y X)
438   8F78 D1                                   pop     de
439   8F79 01 00 00                             ld      bc,0                        ; Set y1 = 0
440   8F7C 79           .LL135:                 ld      a,c                         ; if bc < 128 then no work to do
441   8F7D E6 80                                and     $80
442   8F7F B0                                   or      b                           ; here we see if c bit 8 is set or anything in b as we know if its 0 this would mean there is no need to clip
443   8F80 C8                                   ret     z
444   8F81 E5                                   push    hl
445   8F82 60 69                                ld      hl,bc
446   8F84 01 80 00                             ld      bc,128
447   8F87 B7                                   or      a
448   8F88 ED 42                                sbc     hl,bc                       ; hl =  (S R) = (y1_hi y1_lo) - 128
449   8F8A 22 48 85                             ld      (varRS), hl                 ; and now RS (or SR)
450   8F8D 7C                                   ld      a,h
451   8F8E E1                                   pop     hl
452   8F8F ED 27 80                             test    $80                         ; If the subtraction underflowed, i.e. if y1 < 192, then y1 is already on-screen, so jump to LL136 to return from the subroutine, as we are done
453   8F92 C0                                   ret     nz
454   8F93              ; If we get here then y1 >= 192, i.e. off the bottom of the screen
455   8F93 E5 D5 C5     .LL139:                 push    hl,,de,,bc
456   8F96 CD D0 8F                             call    LL123                       ;  Call LL123 to calculate: (Y X) = (S R) / XX12+2      if T = 0  = y1 / gradient
457   8F99                                                                          ;                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
458   8F99                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
459   8F99 C1 D1 E1                             pop     hl,,de,,bc
460   8F9C D5                                   push    de
461   8F9D EB                                   ex      hl,de
462   8F9E 2A 9F 8D                             ld      hl,(varYX)
463   8FA1 19                                   add     hl,de                       ; we don't need to swap back as its an add, Set x1 = x1 + (Y X)
464   8FA2 01 80 00                             ld      bc,128                      ; set bc to 128 bottom of screen
465   8FA5 D1                                   pop     de
466   8FA6 C9           .LL136:                 ret                                 ;  Return from the subroutine
467   8FA7
468   8FA7
469   8FA7              ; Calculate the following:   * If T = 0  (more vertical than horizontal), (Y X) = (S x1_lo) * XX12+2
470   8FA7              ;                            * If T <> 0 (more horizontal than vertical), (Y X) = (S x1_lo) / XX12+2
471   8FA7              ;                              giving (Y X) the opposite sign to the slope direction in XX12+3.
472   8FA7              ; Other entry points        LL122                Calculate (Y X) = (S R) * Q and set the sign to the opposite of the top byte on the stack
473   8FA7 DD 01        LL120:                  break
474   8FA9 7D                                   ld      a,l                          ; Set R = x1_lo
475   8FAA 32 48 85                             ld      (varR),a
476   8FAD CD 15 90                             call    LL129                        ;  Call LL129 to do the following:  Q = XX12+2   = line gradient  A = S EOR XX12+3 = S EOR slope direction (S R) = |S R| So A contains the sign of S * slope direction
477   8FB0 F5                                   push    af                           ;  Store A on the stack so we can use it later
478   8FB1 C5                                   push    bc
479   8FB2 47                                   ld      b,a
480   8FB3 3A 68 85                             ld      a,(varT)                     ; instead : (Y X) = (S R ) / Q
481   8FB6 FE 00                                cp      0
482   8FB8 78                                   ld      a,b
483   8FB9 C1                                   pop     bc                           ; we can't use af as that would disrupt the flags
484   8FBA 20 25                                jr      nz, LL121
485   8FBC              ; The following calculates:  (Y X) = (S R) * Q using the same shift-and-add algorithm that's documented in MULT1
486   8FBC 3A 9A 8D     LL122:                  ld      a,(clipGradient)
487   8FBF 32 47 85                             ld      (varQ),a; optimise
488   8FC2 CD DB 88                             call    HLequSRmulQdiv256
489   8FC5 22 9F 8D                             ld      (varYX),hl
490   8FC8 F1                                   pop     af
491   8FC9 ED 27 80                             test    $80
492   8FCC CA 08 90                             jp      z,LL133
493   8FCF C9                                   ret
494   8FD0              ; Calculate the following: * If T = 0,  calculate (Y X) = (S R) / XX12+2 (actually SR & XX12+2 /256)
495   8FD0              ;                          * If T <> 0, calculate (Y X) = (S R) * XX12+2
496   8FD0              ;                          giving (Y X) the opposite sign to the slope direction in XX12+3.
497   8FD0              ;
498   8FD0              ; Other entry points:      LL121                Calculate (Y X) = (S R) / Q and set the sign to the opposite of the top byte on the stack
499   8FD0              ;                          LL133                Negate (Y X) and return from the subroutine
500   8FD0              ;                          LL128                Contains an RTS
501   8FD0
502   8FD0 DD 01        LL123:                  break
503   8FD2 CD 15 90                             call    LL129           ;  Call LL129 to do the following: Q = XX12+2   = line gradient  A = S EOR XX12+3 = S EOR slope direction (S R) = |S R| So A contains the sign of S * slope direction
504   8FD5 F5                                   push    af                           ;  Store A on the stack so we can use it later
505   8FD6 C5                                   push    bc                          ; If T is non-zero, so it's more horizontal than vertical, jump down to LL121 to calculate this
506   8FD7 47                                   ld      b,a
507   8FD8 3A 68 85                             ld      a,(varT)                     ; instead : (Y X) = (S R) * Q
508   8FDB FE 00                                cp      0
509   8FDD 78                                   ld      a,b
510   8FDE C1                                   pop     bc
511   8FDF 20 DB                                jr      nz, LL122
512   8FE1              ; The following calculates: (Y X) = (S R) / Q using the same shift-and-subtract algorithm that's documented in TIS2, its actually X.Y=R.S*256/Q
513   8FE1              ;LL121:                  ld      hl,(varRS)
514   8FE1              ;                        ex      hl,de
515   8FE1              ;                        ld      a,(varQ)
516   8FE1              ;                        ld      b,0
517   8FE1              ;                        ld      c,a
518   8FE1              ;                        call    DEequDEDivBC
519   8FE1              ;                        ex      de,hl
520   8FE1              ;                        ld      (varYX),hl      ; write out XY
521   8FE1 11 FE FF     LL121:                 ld      de,$FFFE                    ;   set XY to &FFFE at start, de holds XY
522   8FE4 2A 48 85                             ld      hl,(varRS)                  ; hl = RS
523   8FE7 3A 47 85                             ld      a,(varQ)
524   8FEA 47                                   ld      b,a                         ; b = q
525   8FEB              .LL130:                 ShiftHLLeft1                        ; RS *= 2
525   8FEB CB 25       >			   sla l
525   8FED CB 14       >			   rl  h
526   8FEF 7C                                   ld      a,h
527   8FF0 38 04                                jr      c,.LL131                    ; if S overflowed skip Q test and do subtractions
528   8FF2                                      JumpIfALTNusng b, .LL132            ; if S <  Q = 256/gradient skip subtractions
528   8FF2 B8          >                        cp      b
528   8FF3 DA FD 8F    >                        jp		c,.LL132
529   8FF6 3F           .LL131:                 ccf                                 ; clear carry
530   8FF7 98                                   sbc     a,b                         ; q
531   8FF8 67                                   ld      h,a                         ; h (s)
532   8FF9 7D                                   ld      a,l                         ; r
533   8FFA DE 00                                sbc     a,0                         ; 0 - so in effect SR - Q*256
534   8FFC 37                                   scf                                 ; set carry for next rolls
535   8FFD              .LL132:                 ShiftDELeft1                        ; Rotate de bits left
535   8FFD CB 23       >			   sla e
535   8FFF CB 12       >			   rl  d
536   9001 38 E8                                jr      c,.LL130                    ;
537   9003 F1                                   pop     af              ; get back sign
538   9004 ED 27 80                             test    $80
539   9007 C8                                   ret     z               ; if negative then return with value as is reversed sign
540   9008 2A 9F 8D     LL133:                  ld      hl,(varYX)      ; may not actually need this?
541   900B                                      NegHL
541   900B AF          >                xor a
541   900C 95          >                sub l
541   900D 6F          >                ld l,a
541   900E 9F          >                sbc a,a
541   900F 94          >                sub h
541   9010 67          >                ld h,a
542   9011 22 9F 8D                             ld      (varYX),hl
543   9014 C9           LL128:                  ret
544   9015
545   9015
546   9015
547   9015
548   9015
549   9015
550   9015
551   9015              ; Do the following, in this order:  Q = XX12+2
552   9015              ;                                   A = S EOR XX12+3
553   9015              ;                                   (S R) = |S R|
554   9015              ; This sets up the variables required above to calculate (S R) / XX12+2 and give the result the opposite sign to XX13+3.
555   9015 3A 9A 8D     LL129:                  ld      a,(clipGradient)
556   9018 32 47 85                             ld      (varQ),a                    ;Set Q = XX12+2
557   901B 3A 49 85                             ld      a,(varS)                    ; If S is positive, jump to LL127
558   901E E5 F5                                push    hl,,af
559   9020 ED 27 80                             test    $80
560   9023 28 0C                                jr      z,.LL127
561   9025 2A 48 85                             ld      hl,(varRS)                  ; else SR = | SR|
562   9028                                      NegHL
562   9028 AF          >                xor a
562   9029 95          >                sub l
562   902A 6F          >                ld l,a
562   902B 9F          >                sbc a,a
562   902C 94          >                sub h
562   902D 67          >                ld h,a
563   902E 22 48 85                             ld      (varRS),hl
564   9031 21 9B 8D     .LL127:                 ld      hl,clipDxySign
565   9034 F1                                   pop     af
566   9035 AE                                   xor     (hl)                        ; a = S XOR clipDxySign
567   9036 E1                                   pop     hl
568   9037 C9                                   ret
569   9038
570   9038
571   9038              ; Repurposed XX15 when plotting lines
572   9038              ; Repurposed XX15 before calling clip routine
573   9038              UBnkX1                      equ XX15
574   9038              UBnKx1Lo                    equ XX15
575   9038              UBnKx1Hi                    equ XX15+1
576   9038              UBnkY1                      equ XX15+2
577   9038              UbnKy1Lo                    equ XX15+2
578   9038              UBnkY1Hi                    equ XX15+3
579   9038              UBnkX2                      equ XX15+4
580   9038              UBnkX2Lo                    equ XX15+4
581   9038              UBnkX2Hi                    equ XX15+5
582   9038              ; Repurposed XX12 when plotting lines
583   9038              UBnkY2                      equ XX12+0
584   9038              UbnKy2Lo                    equ XX12+0
585   9038              UBnkY2Hi                    equ XX12+1
586   9038              UBnkDeltaXLo                equ XX12+2
587   9038              UBnkDeltaXHi                equ XX12+3
588   9038              UBnkDeltaYLo                equ XX12+4
589   9038              UBnkDeltaYHi                equ XX12+5
590   9038              UbnkGradient                equ XX12+2
591   9038              UBnkTemp1                   equ XX12+2
592   9038              UBnkTemp1Lo                 equ XX12+2
593   9038              UBnkTemp1Hi                 equ XX12+3
594   9038              UBnkTemp2                   equ XX12+3
595   9038              UBnkTemp2Lo                 equ XX12+3
596   9038              UBnkTemp2Hi                 equ XX12+4
597   9038              ;-- XX15 --------------------------------------------------------------------------------------------------------------------------
598   9038 00           UBnkXScaled                 DB  0               ; XX15+0Xscaled
599   9039 00           UBnkXScaledSign             DB  0               ; XX15+1xsign
600   903A 00           UBnkYScaled                 DB  0               ; XX15+2yscaled
601   903B 00           UBnkYScaledSign             DB  0               ; XX15+3ysign
602   903C 00           UBnkZScaled                 DB  0               ; XX15+4zscaled
603   903D 00           UBnkZScaledSign             DB  0               ; XX15+5zsign
604   903E
605   903E              XX15                        equ UBnkXScaled
606   903E              XX15VecX                    equ XX15
607   903E              XX15VecY                    equ XX15+1
608   903E
609   903E              XX15VecZ                    equ XX15+2
610   903E              UbnkXPoint                  equ XX15
611   903E              UbnkXPointLo                equ XX15+0
612   903E              UbnkXPointHi                equ XX15+1
613   903E              UbnkXPointSign              equ XX15+2
614   903E              UbnkYPoint                  equ XX15+3
615   903E              UbnkYPointLo                equ XX15+3
616   903E              UbnkYPointHi                equ XX15+4
617   903E              UbnkYPointSign              equ XX15+5
618   903E              ; Repurposed XX15 pre clip plines
619   903E              UbnkPreClipX1               equ XX15+0
620   903E              UbnkPreClipY1               equ XX15+2
621   903E              UbnkPreClipX2               equ XX15+4
622   903E              UbnkPreClipY2               equ XX15+6
623   903E              ; Repurposed XX15 post clip lines
624   903E              UBnkNewX1                   equ XX15+0
625   903E              UBnkNewY1                   equ XX15+1
626   903E              UBnkNewX2                   equ XX15+2
627   903E              UBnkNewY2                   equ XX15+3
628   903E              ; Repurposed XX15
629   903E              regXX15fx                   equ UBnkXScaled
630   903E              regXX15fxSgn                equ UBnkXScaledSign
631   903E              regXX15fy                   equ UBnkYScaled
632   903E              regXX15fySgn                equ UBnkYScaledSign
633   903E              regXX15fz                   equ UBnkZScaled
634   903E              regXX15fzSgn                equ UBnkZScaledSign
635   903E              ; Repurposed XX15
636   903E              varX1                       equ UBnkXScaled       ; Reused, verify correct position
637   903E              varY1                       equ UBnkXScaledSign   ; Reused, verify correct position
638   903E              varZ1                       equ UBnkYScaled       ; Reused, verify correct position
639   903E              ; After clipping the coords are two 8 bit pairs
640   903E              UBnkPoint1Clipped           equ UBnkXScaled
641   903E              UBnkPoint2Clipped           equ UBnkYScaled
642   903E              ;-- transmat0 --------------------------------------------------------------------------------------------------------------------------
643   903E              ; Note XX12 comes after as some logic in normal processing uses XX15 and XX12 combines
644   903E 00           UBnkXX12xLo                 DB  0               ; XX12+0
645   903F 00           UBnkXX12xSign               DB  0               ; XX12+1
646   9040 00           UBnkXX12yLo                 DB  0               ; XX12+2
647   9041 00           UBnkXX12ySign               DB  0               ; XX12+3
648   9042 00           UBnkXX12zLo                 DB  0               ; XX12+4
649   9043 00           UBnkXX12zSign               DB  0               ; XX12+5
650   9044 00 00 00...  XX12Save                    DS  6
651   904A 00 00 00...  XX12Save2                   DS  6
652   9050              XX12                        equ UBnkXX12xLo
653   9050              varXX12                     equ UBnkXX12xLo
654   9050              ; Post clipping the results are now 8 bit
655   9050 00           UBnkVisibility              DB  0               ; replaces general purpose xx4 in rendering
656   9051
657   9051 00           UBnkProjectedY              DB  0
658   9052 00           UBnkProjectedX              DB  0
659   9053              UBnkProjected               equ UBnkProjectedY  ; resultant projected position
660   9053 00 00 00...  XX15Save                    DS  8
661   905B 00 00 00...  XX15Save2                   DS  8
662   9063 00           VarBackface                 DB 0
663   9064              ; Heap (or array) information for lines and normals
664   9064              ; Coords are stored XY,XY,XY,XY
665   9064              ; Normals
666   9064              ; This needs re-oprganising now.
667   9064              ; Runtime Calculation Store
668   9064
669   9064              FaceArraySize               equ 30
670   9064              EdgeHeapSize                equ 40
671   9064              NodeArraySize               equ 40
672   9064              LineArraySize               equ LineListLen
673   9064              ; Storage arrays for data
674   9064              ; Structure of arrays
675   9064              ; Visibility array  - 1 Byte per face/normal on ship model Bit 7 (or FF) visible, 0 Invisible
676   9064              ; Node array corresponds to a processed vertex from the ship model transformed into world coordinates and tracks the node list from model
677   9064              ; NodeArray         -  4 bytes per element      0           1            2          3
678   9064              ;                                               X Coord Lo  Y Coord Lo   Z CoordLo  Sign Bits 7 6 5 for X Y Z Signs (set = negative)
679   9064              ; Line Array        -  4 bytes per eleement     0           1            2          3
680   9064              ;                                               X1          Y1           X2         Y2
681   9064 00 00 00...  UbnkFaceVisArray            DS FaceArraySize            ; XX2 Up to 16 faces this may be normal list, each entry is controlled by bit 7, 1 visible, 0 hidden
682   9082 00 00 00...  UBnkNodeArray               DS NodeArraySize * 4        ; XX3 Holds the points as an array, its an array not a heap
683   9122 00 00 00...  UBnkNodeArray2              DS NodeArraySize * 4        ; XX3 Holds the points as an array, its an array not a heap
684   91C2 00 00 00...  UbnkLineArray               DS LineArraySize * 4        ; XX19 Holds the clipped line details
685   9582              UBnkLinesHeapMax            EQU $ - UbnkLineArray
686   9582 00 00 00...  UbnkEdgeProcessedList DS EdgeHeapSize
687   95AA              ; Array current Lengths
688   95AA 00           UbnkFaceVisArrayLen         DS 1
689   95AB 00           UBnkNodeArrayLen            DS 1
690   95AC 00           UbnkLineArrayLen            DS 1                        ; total number of lines loaded to array
691   95AD 00           UbnkLineArrayBytes          DS 1                        ; total number of bytes loaded to array  = array len * 4
692   95AE              XX20                        equ UbnkLineArrayLen
693   95AE              varXX20                     equ UbnkLineArrayLen
694   95AE
695   95AE
696   95AE 00           UbnkEdgeHeapSize            DS 1
697   95AF 00           UbnkEdgeHeapBytes           DS 1
698   95B0 00           UBnkLinesHeapLen            DS 1
699   95B1 00           UbnKEdgeHeapCounter         DS 1
700   95B2 00           UbnKEdgeRadius              DS 1
701   95B3 00           UbnKEdgeShipType            DS 1
702   95B4 00           UbnKEdgeExplosionType       DS 1
703   95B5
704   95B5              ;--------------------------------------------------------------------------------------------------------
705   95B5              ; ---------------------------------------------------------------------------------------------------------------------------------
706   95B5 00           DrawLinesCounter		db	0
707   95B6              ; Initial tests look OK
708   95B6              LL155:;
709   95B6              ClearLine:                                  ; CLEAR LINEstr visited by EE31 when XX3 heap ready to draw/erase lines in XX19 heap.
710   95B6                    ;break                                                                             ; ObjectInFront:
711   95B6 3E 65        DrawLines:              ld	a,$65 ; DEBUG
712   95B8 FD 6F                                ld		iyl,a							; set ixl to colour (assuming we come in here with a = colour to draw)
713   95BA 3A AC 95                             ld		a,(UbnkLineArrayLen)			; get number of lines
714   95BD                                      ReturnIfAIsZero   						; No lines then bail out.
714   95BD FE 00       >                 cp     0
714   95BF C8          >                 ret    z
715   95C0 FD 67                                ld		iyh,a			                ; number of lines still to draw
716   95C2 21 C2 91                             ld		hl,UbnkLineArray
717   95C5              ;LL27:                                       ; counter Y, Draw clipped lines in XX19 ship lines heap
718   95C5 4E           DrawXX19ClippedLines:   ld      c,(hl)                          ; (XX19),Y c = varX1
719   95C6 23                                   inc     hl
720   95C7 46                                   ld      b,(hl)                          ; bc = point1 Y,X
721   95C8 23                                   inc     hl
722   95C9
723   95C9 5E                                   ld      e,(hl)                          ; c = varX1
724   95CA 23                                   inc     hl
725   95CB 56                                   ld      d,(hl)                          ; de = point2 Y,X
726   95CC 23                                   inc     hl
727   95CD E5                                   push	hl
728   95CE FD E5                                push    iy
729   95D0 60                                   ld      h,b
730   95D1 69                                   ld      l,c
731   95D2                ;  call    l2_draw_any_line                ; call version of LOIN that used BCDE
732   95D2 FD 7D                                ld		a,iyl							; get colour back before calling line draw
733   95D4                                      MMUSelectLayer2
733   95D4 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
734   95D8 CD F0 E8                             call    LineHLtoDE
735   95DB FD E1                                pop     iy
736   95DD E1                                   pop	    hl
737   95DE FD 25                                dec     iyh
738   95E0 20 E3                                jr		nz,DrawXX19ClippedLines
739   95E2 C9                                   ret                                     ; --- Wireframe end  \ LL118-1
740   95E3
741   95E3
742   95E3              ;--------------------------------------------------------------------------------------------------------
743   95E3                  INCLUDE "./ModelRender/getVertexNodeAtAToX1Y1.asm"
# file opened: ./ModelRender/getVertexNodeAtAToX1Y1.asm
  1+  95E3              ;--------------------------------------------------------------------------------------------------------
  2+  95E3              ; a = byteoffset to node array as its pre computed to x4 bytes
  3+  95E3 21 82 90     getVertexNodeAtAToX1Y1: ld          hl,UBnkNodeArray                    ; hl = edgelist  current pointer
  4+  95E6 ED 31                                add         hl,a                                ; hl = address of Node
  5+  95E8 7E                                   ld          a,(hl)                              ; get edge list nbr 1 edge
  6+  95E9 11 38 90                             ld          de,UBnkX1
  7+  95EC ED A0                                ldi                                             ; x1 lo
  8+  95EE ED A0                                ldi                                             ; x1 hi
  9+  95F0 ED A0                                ldi                                             ; y1 lo
 10+  95F2 ED A0                                ldi                                             ; y1 hi
 11+  95F4 C9                                   ret
 12+  95F5
# file closed: ./ModelRender/getVertexNodeAtAToX1Y1.asm
744   95F5                  INCLUDE "./ModelRender/getVertexNodeAtAToX2Y2.asm"
# file opened: ./ModelRender/getVertexNodeAtAToX2Y2.asm
  1+  95F5              ;--------------------------------------------------------------------------------------------------------
  2+  95F5              ; a = byteoffset to node array as its pre computed to x4 bytes
  3+  95F5 21 82 90     getVertexNodeAtAToX2Y2: ld          hl,UBnkNodeArray                    ; hl = edgelist  current pointer
  4+  95F8 ED 31                                add         hl,a                                ; hl = address of Node
  5+  95FA 7E                                   ld          a,(hl)                              ; get edge list nbr 1 edge
  6+  95FB 11 3C 90                             ld          de,UBnkX2
  7+  95FE ED A0                                ldi                                             ; x1 lo
  8+  9600 ED A0                                ldi                                             ; x1 hi
  9+  9602 ED A0                                ldi                                             ; y1 lo
 10+  9604 ED A0                                ldi                                             ; y1 hi
 11+  9606 C9                                   ret
# file closed: ./ModelRender/getVertexNodeAtAToX2Y2.asm
745   9607                  INCLUDE "./ModelRender/GetFaceAtA.asm"
# file opened: ./ModelRender/GetFaceAtA.asm
  1+  9607              ;--------------------------------------------------------------------------------------------------------
  2+  9607              GetFaceAtA:         MACRO
  3+  9607 ~                                ld          hl,UbnkFaceVisArray
  4+  9607 ~                                add         hl,a
  5+  9607 ~                                ld          a,(hl)                              ; get face visibility
  6+  9607                                  ENDM
  7+  9607
# file closed: ./ModelRender/GetFaceAtA.asm
746   9607              ;--------------------------------------------------------------------------------------------------------
747   9607              ; Goes through each edge in to determine if they are on a visible face, if so load start and end to line array as clipped lines
748   9607
749   9607              ; Bank 58  ------------------------------------------------------------------------------------------------------------------------
750   9607                  SLOT    LAYER1Addr
751   9607                  PAGE    BankLAYER1
752   9607                  ORG     LAYER1Addr, BankLAYER1
753   E000
754   E000                  INCLUDE "./Layer1Graphics/layer1_attr_utils.asm"
# file opened: ./Layer1Graphics/layer1_attr_utils.asm
  1+  E000
  2+  E000 00 58        L1AttrRow00:            DW $5800                    ;Row 1    */
  3+  E002 20 58        L1AttrRow01:            DW $5820                    ;Row 2    */
  4+  E004 40 58        L1AttrRow02:            DW $5840                    ;Row 3    */
  5+  E006 60 58        L1AttrRow03:            DW $5860                    ;Row 4    */
  6+  E008 80 58        L1AttrRow04:            DW $5880                    ;Row 5    */
  7+  E00A A0 58        L1AttrRow05:            DW $58A0                    ;Row 6    */
  8+  E00C C0 58        L1AttrRow06:            DW $58C0                    ;Row 7    */
  9+  E00E E0 58        L1AttrRow07:            DW $58E0                    ;Row 8    */
 10+  E010 00 59        L1AttrRow08:            DW $5900                    ;Row 9    */
 11+  E012 20 59        L1AttrRow09:            DW $5920                    ;Row 10   */
 12+  E014 40 59        L1AttrRow10:            DW $5940                    ;Row 11   */
 13+  E016 60 59        L1AttrRow11:            DW $5960                    ;Row 12   */
 14+  E018 80 59        L1AttrRow12:            DW $5980                    ;Row 13   */
 15+  E01A A0 59        L1AttrRow13:            DW $59A0                    ;Row 14   */
 16+  E01C C0 59        L1AttrRow14:            DW $59C0                    ;Row 15   */
 17+  E01E E0 59        L1AttrRow15:            DW $59E0                    ;Row 16   */
 18+  E020 00 5A        L1AttrRow16:            DW $5A00                    ;Row 17   */
 19+  E022 20 5A        L1AttrRow17:            DW $5A20                    ;Row 18   */
 20+  E024 40 5A        L1AttrRow18:            DW $5A40                    ;Row 19   */
 21+  E026 60 5A        L1AttrRow19:            DW $5A60                    ;Row 20   */
 22+  E028 80 5A        L1AttrRow20:            DW $5A80                    ;Row 21   */
 23+  E02A A0 5A        L1AttrRow21:            DW $5AA0                    ;Row 22   */
 24+  E02C C0 5A        L1AttrRow22:            DW $5AC0                    ;Row 23   */
 25+  E02E E0 5A        L1AttrRow23:            DW $5AE0                    ;Row 23   */
 26+  E030
 27+  E030              ; "l2_hilight_row, d = row, e = colour"
 28+  E030 21 00 E0     l1_hilight_row:         ld      hl, L1AttrRow00
 29+  E033 4B                                   ld      c,e
 30+  E034 7A                                   ld      a,d
 31+  E035 CB 27                                sla     a
 32+  E037 ED 31                                add     hl,a
 33+  E039 7E                                   ld      a,(hl)
 34+  E03A 5F                                   ld      e,a
 35+  E03B 23                                   inc     hl
 36+  E03C 7E                                   ld      a,(hl)
 37+  E03D 57                                   ld      d,a
 38+  E03E EB                                   ex      hl,de
 39+  E03F 79                                   ld		a,c
 40+  E040 11 20 00                             ld		de, 32
 41+  E043 CD 53 81                             call	memfill_dma
 42+  E046 C9                                   ret
 43+  E047
# file closed: ./Layer1Graphics/layer1_attr_utils.asm
755   E047                  INCLUDE "./Layer1Graphics/layer1_cls.asm"
# file opened: ./Layer1Graphics/layer1_cls.asm
  1+  E047 AF           l1_cls:                 xor		a
  2+  E048 21 00 40     l1_cls_to_a:            ld		hl,	$4000
  3+  E04B 11 00 18                             ld		de, $1800
  4+  E04E CD 53 81                             call	memfill_dma
  5+  E051 C9                                   ret
  6+  E052
  7+  E052 AF           l1_attr_cls:            xor		a
  8+  E053 21 00 58     l1_attr_cls_to_a:       ld		hl,	$5800
  9+  E056 11 00 03                             ld		de, $0300
 10+  E059 CD 53 81                             call	memfill_dma
 11+  E05C C9                                   ret
 12+  E05D
 13+  E05D 01 FE FE     l2_set_border:          ld	    bc, 0xFEFE
 14+  E060 ED 79                                out		(c),a
 15+  E062 C9                                   ret
# file closed: ./Layer1Graphics/layer1_cls.asm
756   E063                  INCLUDE "./Layer1Graphics/layer1_print_at.asm"
# file opened: ./Layer1Graphics/layer1_print_at.asm
  1+  E063              ; "l1 print char a = character, de = Ypixel Xchar of print"
  2+  E063 D5 E5        l1_print_char:          push	de,,hl
  3+  E065 ED 94                                pixelad								; hl = address of de
  4+  E067 E5                                   push	hl							; save hl for loop
  5+  E068 26 00                                ld		h,0
  6+  E06A 6F                                   ld		l,a
  7+  E06B 29                                   add		hl,hl						; * 2
  8+  E06C 29                                   add		hl,hl						; * 4
  9+  E06D 29                                   add		hl,hl						; * 8 to get byte address
 10+  E06E ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
 11+  E072 EB                                   ex		de,hl						; save address into de
 12+  E073 E1                                   pop		hl							; get back hl for loop
 13+  E074 06 08                                ld		b,8							; do 8 rows
 14+  E076 1A           .PrintCharLoop:         ld		a,(de)						; row byte
 15+  E077 13                                   inc		de							; next byte
 16+  E078 77                                   ld		(hl),a						; poke to screen
 17+  E079 ED 93                                pixeldn								; Down 1 row
 18+  E07B 10 F9                                djnz	.PrintCharLoop				; loop for 8 bytes
 19+  E07D E1 D1                                pop		de,,hl					    ; restore hl
 20+  E07F C9                                   ret
 21+  E080
 22+  E080              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
 23+  E080              ; now skips ascii code < 32 but moves on cursor by 1 char
 24+  E080              l1_print_at:
 25+  E080 7E           .PrintLoop:             ld		a,(hl)
 26+  E081 FE 00                                cp		0
 27+  E083 C8                                   ret		z
 28+  E084                                      CallIfAGTENusng " ", l1_print_char
 28+  E084 FE 20       >                        cp      " "
 28+  E086 D4 63 E0    >                        call	nc,l1_print_char
 29+  E089 23                                   inc		hl							; move 1 message character right
 30+  E08A 7B                                   ld		a,e
 31+  E08B C6 08                                add		a,8
 32+  E08D 5F                                   ld		e,a							; move 1 screen character right
 33+  E08E 18 F0                                jr		.PrintLoop
 34+  E090              .Clearstackandfinish:   ;pop		de                      ; TODO LOOOKS TO BE A ROGUE POPDE
 35+  E090 C9                                   ret
 36+  E091
 37+  E091              ;l1_print_at_wrap:
 38+  E091              ;; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
 39+  E091              ;	ld      iyh,e
 40+  E091              ;.PrintLoop:
 41+  E091              ;	ld		a,(hl)
 42+  E091              ;	cp		0
 43+  E091              ;	ret		z
 44+  E091              ;.CountWordCharLen
 45+  E091              ;; Need to change to word wrap, so it will loop through string as before
 46+  E091              ;; but read up until a null or space, take the character count * 8 for pixels
 47+  E091              ;; if that is > 238 then force a premature line wrap
 48+  E091              ;
 49+  E091              ;
 50+  E091              ;    push    iy
 51+  E091              ;    call	l1_print_char
 52+  E091              ;    pop     iy
 53+  E091              ;	inc		hl							; move 1 message character right
 54+  E091              ;	ld		a,e
 55+  E091              ;    cp      238
 56+  E091              ;    jr      nc,.NextLine
 57+  E091              ;	add		a,8
 58+  E091              ;	ld		e,a							; move 1 screen character right
 59+  E091              ;	jr		.PrintLoop
 60+  E091              ;.Clearstackandfinish:
 61+  E091              ;	pop		de
 62+  E091              ;	ret
 63+  E091              ;.NextLine:
 64+  E091              ;    ld      a,(hl)
 65+  E091              ;    cp      " "
 66+  E091              ;    ld      e,iyh
 67+  E091              ;    ld      a,d
 68+  E091              ;    add     a,8
 69+  E091              ;    ld      d,a
 70+  E091              ;    jr		.PrintLoop
 71+  E091
 72+  E091              ; Counts next word at hl, uses e and forces a wrap if it would over flow puts value in c
 73+  E091 E5           L1LenWordAtHL:          push    hl
 74+  E092 D5                                   push    de
 75+  E093 7E           .CountLoop:             ld      a,(hl)
 76+  E094 FE 00                                cp      0
 77+  E096 28 0F                                jr      z,.CountDone
 78+  E098 FE 20                                cp      32
 79+  E09A 28 0B                                jr      z,.CountDone
 80+  E09C 7B                                   ld      a,e
 81+  E09D C6 08                                add     a,8
 82+  E09F 5F                                   ld      e,a
 83+  E0A0 FE EE                                cp      238
 84+  E0A2 30 07                                jr      nc,.TooLong
 85+  E0A4 23                                   inc     hl
 86+  E0A5 18 EC                                jr      .CountLoop
 87+  E0A7 D1           .CountDone:             pop     de
 88+  E0A8 E1                                   pop     hl
 89+  E0A9 AF                                   xor     a
 90+  E0AA C9                                   ret
 91+  E0AB D1           .TooLong                pop     de
 92+  E0AC E1                                   pop     hl
 93+  E0AD 3E FF                                ld      a,$FF
 94+  E0AF C9                                   ret
 95+  E0B0
 96+  E0B0 7E           L1PrintWordAtHL:        ld      a,(hl)
 97+  E0B1 FE 00                                cp      0
 98+  E0B3 C8                                   ret     z
 99+  E0B4 FE 20                                cp      32
100+  E0B6 28 0F                                jr      z,.ItsASpace
101+  E0B8 FD E5                                push    iy
102+  E0BA CD 63 E0                             call	l1_print_char
103+  E0BD FD E1                                pop     iy
104+  E0BF 7B                                   ld      a,e
105+  E0C0 C6 08                                add     a,8
106+  E0C2 5F                                   ld      e,a
107+  E0C3 23                                   inc     hl
108+  E0C4 C3 B0 E0                             jp      L1PrintWordAtHL
109+  E0C7 23           .ItsASpace:             inc     hl      ;  Just a bodge for now
110+  E0C8 7B                                   ld      a,e
111+  E0C9 C6 08                                add     a,8
112+  E0CB 5F                                   ld      e,a
113+  E0CC C9                                   ret
114+  E0CD
115+  E0CD
116+  E0CD              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
117+  E0CD              ; Now has full word level wrapping
118+  E0CD FD 63        l1_print_at_wrap:       ld      iyh,e
119+  E0CF 7E           .PrintLoop:             ld		a,(hl)
120+  E0D0 FE 00                                cp		0
121+  E0D2 C8                                   ret		z
122+  E0D3 CD 91 E0     .CountWordCharLen:      call    L1LenWordAtHL
123+  E0D6 FE FF                                cp      $FF
124+  E0D8 28 06                                jr      z,.WrapNextLine
125+  E0DA CD B0 E0     .NotTooLong:            call    L1PrintWordAtHL
126+  E0DD              ; Need to change to word wrap, so it will loop through string as before
127+  E0DD              ; but read up until a null or space, take the character count * 8 for pixels
128+  E0DD              ; if that is > 238 then force a premature line wrap
129+  E0DD 18 F0                                jr		.PrintLoop
130+  E0DF              .Clearstackandfinish:   ;op		de
131+  E0DF C9                                   ret
132+  E0E0              .WrapNextLine:
133+  E0E0 FD 5C        .NextLine:              ld      e,iyh
134+  E0E2 7A                                   ld      a,d
135+  E0E3 C6 08                                add     a,8
136+  E0E5 57                                   ld      d,a
137+  E0E6 18 E7                                jr		.PrintLoop
138+  E0E8
139+  E0E8
# file closed: ./Layer1Graphics/layer1_print_at.asm
757   E0E8
758   E0E8                  SLOT    LAYER2Addr
759   E0E8                  PAGE    BankLAYER2
760   E0E8                  ORG     LAYER2Addr
761   E000
762   E000                  INCLUDE "./Layer2Graphics/layer2_bank_select.asm"
# file opened: ./Layer2Graphics/layer2_bank_select.asm
  1+  E000
  2+  E000 00           varL2_BANK_SELECTED			 DB	0
  3+  E001 00           varL2_BUFFER_MODE            DB 0
  4+  E002
  5+  E002 3E 08        asm_l2_double_buffer_on:    ld      a,8
  6+  E004 32 01 E0                                 ld      (varL2_BUFFER_MODE),a
  7+  E007 C9                                       ret
  8+  E008
  9+  E008 AF           asm_l2_double_buffer_off:   xor     a
 10+  E009 32 01 E0                                 ld      (varL2_BUFFER_MODE),a
 11+  E00C C9                                       ret
 12+  E00D
 13+  E00D
 14+  E00D              ; "asm_l2_bank_select"
 15+  E00D              ; " a = sepecific bank mask value to select, does not set varL2_BANK_SELECTED"
 16+  E00D 57           asm_l2_bank_select:         ld      d,a
 17+  E00E 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
 18+  E011 F6 03                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK
 19+  E013 B2                                       or      d; | LAYER2_SHADOW_SCREEN_MASK
 20+  E014 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
 21+  E017 ED 79                                    out 	(c),a
 22+  E019 C9                                       ret
 23+  E01A              ;  "asm_l2_bank_select a = sepecific bank number to select, dsets varL2_BANK_SELECTED"
 24+  E01A 32 00 E0     asm_l2_bank_n_select:       ld		(varL2_BANK_SELECTED),a
 25+  E01D FE 00                                    cp		0
 26+  E01F 20 04                                    jr 		nz,.nottopbank
 27+  E021 3E 00        .topbank:                   ld		a,LAYER2_SHIFTED_SCREEN_TOP
 28+  E023 18 E8                                    jr		asm_l2_bank_select
 29+  E025 FE 01        .nottopbank:                cp		1
 30+  E027 20 04                                    jr 		nz,.notmiddlebank
 31+  E029 3E 40        .middlebank:                ld		a,LAYER2_SHIFTED_SCREEN_MIDDLE
 32+  E02B 18 E0                                    jr		asm_l2_bank_select
 33+  E02D 3E 80        .notmiddlebank:             ld		a,LAYER2_SHIFTED_SCREEN_BOTTOM ; default to bottom
 34+  E02F 18 DC                                    jr		asm_l2_bank_select
 35+  E031              		; Note no ret as its handled by above routines
 36+  E031
 37+  E031              ; "asm_l2_row_bank_select"
 38+  E031              ; "A (unsinged) = y row of pixel line from top, sets the bank to top middle or bottom and adjusts a reg to row memory address"
 39+  E031              ; "Could optimise by holding the previous bank but given its only an out statement it may not save T states at all"
 40+  E031              ; "destroys BC call de is safe a = adjusted poke pixel row"
 41+  E031 FE 40        asm_l2_row_bank_select:     cp 		64			; row < 64?
 42+  E033 30 11                                    jr 		nc, .l2rowGTE64
 43+  E035 08           .l2rowLT64:                 ex		af,af'
 44+  E036                                          ;ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP | LAYER2_SHADOW_SCREEN_MASK
 45+  E036 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
 46+  E039 F6 03                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
 47+  E03B 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
 48+  E03E ED 79                                    out 	(c),a
 49+  E040 AF                                       xor		a						; set a to 0
 50+  E041 32 00 E0                                 ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 51+  E044 08                                       ex		af,af'					; return pixel poke unharmed
 52+  E045 C9                                       ret
 53+  E046 FE 80        .l2rowGTE64:                cp 		128
 54+  E048 30 14                                    jr 		nc, .l2rowGTE128
 55+  E04A 08           .l2row64to127:              ex		af,af'
 56+  E04B                                  ;		ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE | LAYER2_SHADOW_SCREEN_MASK
 57+  E04B 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
 58+  E04E F6 43                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
 59+  E050 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
 60+  E053 ED 79                                    out 	(c),a
 61+  E055 3E 01                                    ld		a,1						; set a to 1
 62+  E057 32 00 E0                                 ld		(varL2_BANK_SELECTED),a	; save selected bank
 63+  E05A 08                                       ex		af,af'
 64+  E05B D6 40                                    sub		64
 65+  E05D C9                                       ret
 66+  E05E 08           .l2rowGTE128:               ex		af,af'
 67+  E05F                                  ;		ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM | LAYER2_SHADOW_SCREEN_MASK
 68+  E05F 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
 69+  E062 F6 83                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 70+  E064
 71+  E064 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
 72+  E067 ED 79                                    out 	(c),a
 73+  E069 3E 01                                    ld		a,1						; set a to 2
 74+  E06B 32 00 E0                                 ld		(varL2_BANK_SELECTED),a	; save selected bank
 75+  E06E 08                                       ex		af,af'
 76+  E06F D6 80                                    sub		128
 77+  E071 C9                                       ret
 78+  E072
# file closed: ./Layer2Graphics/layer2_bank_select.asm
763   E072                  INCLUDE "./Layer2Graphics/layer2_cls.asm"
# file opened: ./Layer2Graphics/layer2_cls.asm
  1+  E072
  2+  E072 00           l2_cls_byte	            DB 0
  3+  E073              ; ">DMA Command BLOCK"
  4+  E073
  5+  E073 83 C3 C7 CB  l2_fill                 DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
  5+  E077 7D
  6+  E078 72 E0        l2_fill_astrt           DW l2_cls_byte
  7+  E07A 00 40        l2_fill_length          DB $00,$40
  8+  E07C 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
  9+  E07F 00 00        l2_fill_bstrt           DB $00,$00
 10+  E081 82 CF B3 87                          DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
 11+  E085              l2_fill_cmd_len	        EQU $ - l2_fill
 12+  E085
 13+  E085              l2_cls_dma_bank:
 14+  E085              ; ">l2_cls_dma_bank"
 15+  E085              ; ">sets a bank to"
 16+  E085 32 72 E0     .set_colour:            ld (l2_cls_byte),a
 17+  E088 21 73 E0     .write_dma:             ld hl, l2_fill
 18+  E08B 06 12                                ld b, l2_fill_cmd_len
 19+  E08D 0E 6B                                ld	c,IO_DATAGEAR_DMA_PORT
 20+  E08F ED B3                                otir
 21+  E091 C9                                   ret
 22+  E092
 23+  E092 3E 00        l2_set_color_upper2:    ld      a,0
 24+  E094 CD 31 E0                             call asm_l2_row_bank_select
 25+  E097 3A 72 E0                             ld      a,(l2_cls_byte)
 26+  E09A CD 85 E0                             call l2_cls_dma_bank
 27+  E09D 3E 40                                ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
 28+  E09F CD 31 E0                             call asm_l2_row_bank_select
 29+  E0A2 3A 72 E0                             ld      a,(l2_cls_byte)
 30+  E0A5 CD 85 E0                             call l2_cls_dma_bank
 31+  E0A8 C9                                   ret
 32+  E0A9
 33+  E0A9
 34+  E0A9 3E 00        l2_cls_upper_two_thirds:ld a,0								; pretend we are plotting pixel on row 0 to force top selection
 35+  E0AB CD 31 E0                             call asm_l2_row_bank_select
 36+  E0AE 3E E3                                ld 	a,COLOUR_TRANSPARENT
 37+  E0B0 CD 85 E0                             call l2_cls_dma_bank
 38+  E0B3 3E 40                                ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
 39+  E0B5 CD 31 E0                             call asm_l2_row_bank_select
 40+  E0B8 3E E3                                ld 	a,COLOUR_TRANSPARENT
 41+  E0BA CD 85 E0                             call l2_cls_dma_bank
 42+  E0BD C9                                   ret
 43+  E0BE
 44+  E0BE 3E 80        l2_cls_lower_third:     ld a,128							; pretend we are plotting pixel on row 64 to force mid selection
 45+  E0C0 CD 31 E0                             call asm_l2_row_bank_select
 46+  E0C3 3E E3                                ld 	a,COLOUR_TRANSPARENT
 47+  E0C5 CD 85 E0                             call l2_cls_dma_bank
 48+  E0C8 C9                                   ret
 49+  E0C9
 50+  E0C9 CD A9 E0     l2_cls:                 call l2_cls_upper_two_thirds
 51+  E0CC CD BE E0                             call l2_cls_lower_third
 52+  E0CF C9                                   ret
 53+  E0D0
# file closed: ./Layer2Graphics/layer2_cls.asm
764   E0D0                  INCLUDE "./Layer2Graphics/layer2_initialise.asm"
# file opened: ./Layer2Graphics/layer2_initialise.asm
  1+  E0D0
  2+  E0D0 ED 91 12 08  l2_initialise:          nextreg		LAYER2_RAM_PAGE_REGISTER,          	LAYER2_SCREEN_BANK1
  3+  E0D4 ED 91 13 0B                          nextreg		LAYER2_RAM_SHADOW_REGISTER,     	LAYER2_SHADOW_BANK1
  4+  E0D8 ED 91 14 E3                          nextreg		TRANSPARENCY_COLOUR_REGISTER, 		COLOUR_TRANSPARENT
  5+  E0DC C9                                   ret
  6+  E0DD
# file closed: ./Layer2Graphics/layer2_initialise.asm
765   E0DD                  INCLUDE "./Layer2Graphics/l2_flip_buffers.asm"
# file opened: ./Layer2Graphics/l2_flip_buffers.asm
  1+  E0DD              l2_flip_buffers:        GetNextReg LAYER2_RAM_PAGE_REGISTER
  1+  E0DD C5          >            push bc
  1+  E0DE 01 3B 24    >                ld bc,$243B
  1+  E0E1 3E 12       >                    ld a,LAYER2_RAM_PAGE_REGISTER
  1+  E0E3 ED 79       >                    out (c),a
  1+  E0E5 04          >                    inc b
  1+  E0E6 ED 78       >                in a,(c)
  1+  E0E8 C1          >            pop bc
  2+  E0E9 57                                   ld      d,a
  3+  E0EA                                      GetNextReg LAYER2_RAM_SHADOW_REGISTER
  3+  E0EA C5          >            push bc
  3+  E0EB 01 3B 24    >                ld bc,$243B
  3+  E0EE 3E 13       >                    ld a,LAYER2_RAM_SHADOW_REGISTER
  3+  E0F0 ED 79       >                    out (c),a
  3+  E0F2 04          >                    inc b
  3+  E0F3 ED 78       >                in a,(c)
  3+  E0F5 C1          >            pop bc
  4+  E0F6 5F                                   ld      e,a
  5+  E0F7 ED 92 12                             nextreg LAYER2_RAM_PAGE_REGISTER, a
  6+  E0FA 7A                                   ld      a,d
  7+  E0FB ED 92 13                             nextreg LAYER2_RAM_SHADOW_REGISTER, a
  8+  E0FE C9                                   ret
  9+  E0FF
# file closed: ./Layer2Graphics/l2_flip_buffers.asm
766   E0FF                  INCLUDE "./Layer2Graphics/layer2_plot_pixel.asm"
# file opened: ./Layer2Graphics/layer2_plot_pixel.asm
  1+  E0FF              l2_plot_pixel:
  2+  E0FF              ; ">l2_plot_pixel b= row number, c = column number, a = pixel col"
  3+  E0FF F5           	push    af
  4+  E100 78               ld      a,b
  5+  E101              l2_pp_row_valid:
  6+  E101                  JumpIfAGTENusng ScreenHeight,l2_pp_dont_plot
  6+  E101 FE C0       >                        cp     ScreenHeight
  6+  E103 D2 11 E1    >                        jp		nc,l2_pp_dont_plot
  7+  E106 C5           	push    bc								; bank select destroys bc so need to save it
  8+  E107              ;	ld      a,b
  9+  E107 CD 31 E0     	call    asm_l2_row_bank_select
 10+  E10A C1           	pop     bc
 11+  E10B 47           	ld      b,a
 12+  E10C 60           	ld      h,b								; hl now holds ram address after bank select
 13+  E10D 69           	ld      l,c
 14+  E10E F1           	pop     af								; a = colour to plott
 15+  E10F 77           	ld      (hl),a
 16+  E110 C9           	ret
 17+  E111              l2_pp_dont_plot:
 18+  E111 F1               pop     af
 19+  E112 C9               ret
 20+  E113
 21+  E113              l2_plot_pixel_no_bank:
 22+  E113              ; ">l2_plot_pixel_no_bank b= row number, c = column number, a = pixel col"
 23+  E113              ; This version assues pixel is in the same bank as previously plotted ones. optimised for horizontal lines
 24+  E113 E5           	push 	hl
 25+  E114 60           	ld 		h,b								; hl now holds ram address after bank select
 26+  E115 69           	ld 		l,c
 27+  E116 77           	ld 		(hl),a
 28+  E117 E1           	pop		hl
 29+  E118 C9           	ret
 30+  E119
 31+  E119              l2_plot_pixel_y_test:
 32+  E119 F5           	push	af
 33+  E11A 78           	ld		a,b
 34+  E11B FE C0        	cp		192
 35+  E11D 30 03        	jr		nc,.clearup
 36+  E11F F1           	pop		af
 37+  E120 18 DD        	jr		l2_plot_pixel
 38+  E122              .clearup:
 39+  E122 F1           	pop		af
 40+  E123 C9           	ret
 41+  E124
 42+  E124              l2_point_pixel_y_safe:	MACRO
 43+  E124 ~            						push	hl
 44+  E124 ~            						push	bc
 45+  E124 ~            						call	l2_plot_pixel
 46+  E124 ~            						pop		bc
 47+  E124 ~            						pop		hl
 48+  E124              						ENDM
 49+  E124
# file closed: ./Layer2Graphics/layer2_plot_pixel.asm
767   E124                  INCLUDE "./Layer2Graphics/layer2_print_character.asm"
# file opened: ./Layer2Graphics/layer2_print_character.asm
  1+  E124
  2+  E124              l2_print_chr_at:
  3+  E124              ; "l2_print_chr_at, bc = col,row, d= character, e = colour"
  4+  E124              ; "Need a version that also prints absence of character"
  5+  E124 7A           	ld		a,d
  6+  E125 FE 20        	cp		32
  7+  E127 38 3F        	jr		c,.InvalidCharacter		; Must be between 32 and 127
  8+  E129 FE 7F        	cp		127
  9+  E12B 30 3B        	jr		nc,.InvalidCharacter
 10+  E12D              .ValidCharater:
 11+  E12D 26 00        	ld		h,0
 12+  E12F 6A           	ld		l,d
 13+  E130 29           	add		hl,hl						; * 2
 14+  E131 29           	add		hl,hl						; * 4
 15+  E132 29           	add		hl,hl						; * 8 to get byte address
 16+  E133 ED 34 00 3C  	add		hl,charactersetaddr			; hl = address of rom char
 17+  E137 04           	inc		b							; start + 1 pixel x and y as we only print 7x7
 18+  E138 23           	inc		hl							; skip first byte
 19+  E139 16 07        	ld		d,7
 20+  E13B              .PrintCharLoop:
 21+  E13B D5           	push	de
 22+  E13C 7E           	ld		a,(hl)
 23+  E13D FE 00        	cp		0
 24+  E13F 28 21        	jr		z,.NextRowNoBCPop
 25+  E141              .PrintARow:
 26+  E141 C5           	push	bc							; save row col
 27+  E142 16 07        	ld		d,7							; d is loop row number now
 28+  E144              .PrintPixelLoop:
 29+  E144 0C           	inc		c							; we start at col 1 not 0 so can move inc here
 30+  E145              .PrintTheRow:
 31+  E145 CB 27        	sla		a							; scroll char 1 pixel as we read from bit 7
 32+  E147 F5           	push	af							; save character byte
 33+  E148 CB 7F        	bit		7,a							; If left most pixel set then plot
 34+  E14A 20 04        	jr		nz,.PixelToPrint
 35+  E14C              .NoPixelToPrint:
 36+  E14C 3E E3        	ld		a,$E3
 37+  E14E 18 01        	jr		.HaveSetPixelColour
 38+  E150              .PixelToPrint:
 39+  E150 7B           	ld		a,e							; Get Colour
 40+  E151              .HaveSetPixelColour
 41+  E151 E5           	push	hl
 42+  E152              ;	push	bc							; at the moment we don't do paging on first plot so need to preserve BC
 43+  E152              .BankOnFirstOnly:
 44+  E152 F5           	push	af
 45+  E153 7A           	ld		a,d
 46+  E154 FE 07        	cp		7
 47+  E156 28 11        	jr		z,.PlotWithBank
 48+  E158              .PlotNoBank:
 49+  E158 F1           	pop		af
 50+  E159 60           	ld 		h,b								; hl now holds ram address after bank select
 51+  E15A 69           	ld 		l,c
 52+  E15B 77           	ld 		(hl),a
 53+  E15C              .IterateLoop:
 54+  E15C              ;	pop		bc
 55+  E15C E1           	pop		hl
 56+  E15D F1           	pop		af							; a= current byte shifted
 57+  E15E 15           	dec		d						 	; do dec after inc as we amy
 58+  E15F 20 E3        	jr		nz,.PrintPixelLoop
 59+  E161              .NextRow:
 60+  E161 C1           	pop		bc							; Current Col Row
 61+  E162              .NextRowNoBCPop:
 62+  E162 D1           	pop		de							; d= row loop
 63+  E163 04           	inc		b							; Down 1 row
 64+  E164 23           	inc		hl							; Next character byte
 65+  E165 15           	dec		d							; 1 done now
 66+  E166 20 D3        	jr		nz,.PrintCharLoop
 67+  E168              .InvalidCharacter:
 68+  E168 C9           	ret
 69+  E169              .PlotWithBank:
 70+  E169 F1           	pop		af
 71+  E16A CD FF E0     	call	l2_plot_pixel				; This will shift bc to poke row
 72+  E16D 18 ED        	jr		.IterateLoop
 73+  E16F
 74+  E16F              l2_print_at:
 75+  E16F              ; "l2_print_at bc= colrow, hl = addr of message, e = colour"
 76+  E16F              ; "No error trapping, if there is no null is will just cycle on the line"
 77+  E16F 7E           	ld	a,(hl)							; Return if empty string
 78+  E170 FE 00        	cp	0
 79+  E172 C8           	ret	z
 80+  E173 E5           	push	hl
 81+  E174 D5           	push	de
 82+  E175 C5           	push	bc
 83+  E176 57           	ld		d,a							; bc = pos, de = char and colour
 84+  E177 CD 24 E1     	call 	l2_print_chr_at
 85+  E17A C1           	pop		bc
 86+  E17B D1           	pop		de
 87+  E17C E1           	pop		hl
 88+  E17D              .Move8Pixlestoright:
 89+  E17D 08           	ex		af,af'
 90+  E17E 79           	ld		a,c
 91+  E17F C6 08        	add		8
 92+  E181 4F           	ld		c,a
 93+  E182 08           	ex		af,af'
 94+  E183 23           	inc		hl
 95+  E184 18 E9        	jr		l2_print_at					; Just loop until 0 found
 96+  E186
 97+  E186
 98+  E186              ; "l2_print_chr_at, bc = col,row, d= character, e = colour"
 99+  E186              ; "Need a version that also prints absence of character"
100+  E186              ; removed blank line optimisation as we need spaces printed
101+  E186 7A           l2_print_7chr_at:       ld		a,d
102+  E187 FE 1F                                cp		31
103+  E189 38 3D                                jr		c,.InvalidCharacter		; Must be between 32 and 127
104+  E18B FE 7F                                cp		127
105+  E18D 30 39                                jr		nc,.InvalidCharacter
106+  E18F 26 00        .ValidCharater:         ld		h,0
107+  E191 6A                                   ld		l,d
108+  E192 29                                   add		hl,hl						; * 2
109+  E193 29                                   add		hl,hl						; * 4
110+  E194 29                                   add		hl,hl						; * 8 to get byte address
111+  E195 ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
112+  E199 04                                   inc		b							; start + 1 pixel x and y as we only print 7x7
113+  E19A 23                                   inc		hl							; skip first byte
114+  E19B 16 07                                ld		d,7
115+  E19D D5           .PrintCharLoop:         push	de
116+  E19E 7E                                   ld		a,(hl)
117+  E19F                                      ;cp		0
118+  E19F                                      ;jr		z,.NextRowNoBCPop
119+  E19F C5           .PrintARow:             push	bc							; save row col
120+  E1A0 16 06                                ld		d,6							; d is loop row number now
121+  E1A2 0C           .PrintPixelLoop:        inc		c							; we start at col 1 not 0 so can move inc here
122+  E1A3 28 1C                                jr		z,.NextRow
123+  E1A5 CB 27                                sla		a							; scroll char 1 pixel as we read from bit 7
124+  E1A7 F5                                   push	af							; save character byte
125+  E1A8 CB 7F                                bit		7,a							; If left most pixel set then plot
126+  E1AA 20 04                                jr		nz,.PixelToPrint
127+  E1AC 3E E3        .NoPixelToPrint:        ld		a,$E3
128+  E1AE 18 01                                jr		.HaveSetPixelColour
129+  E1B0 7B           .PixelToPrint:          ld		a,e							; Get Colour
130+  E1B1 E5           .HaveSetPixelColour		push	hl
131+  E1B2                                      ;	push	bc							; at the moment we don't do paging on first plot so need to preserve BC
132+  E1B2 F5           .BankOnFirstOnly:       push	af
133+  E1B3 7A                                   ld		a,d
134+  E1B4 FE 06                                cp		6
135+  E1B6 28 11                                jr		z,.PlotWithBank
136+  E1B8 F1           .PlotNoBank:            pop		af
137+  E1B9 60                                   ld 		h,b								; hl now holds ram address after bank select
138+  E1BA 69                                   ld 		l,c
139+  E1BB 77                                   ld 		(hl),a
140+  E1BC              .IterateLoop:	        ;	pop		bc
141+  E1BC E1                                   pop		hl
142+  E1BD F1                                   pop		af							; a= current byte shifted
143+  E1BE 15                                   dec		d						 	; do dec after inc as we amy
144+  E1BF 20 E1                                jr		nz,.PrintPixelLoop
145+  E1C1 C1           .NextRow:               pop		bc							; Current Col Row
146+  E1C2 D1           .NextRowNoBCPop:	    pop		de							; d= row loop
147+  E1C3 04                                   inc		b							; Down 1 row
148+  E1C4 23                                   inc		hl							; Next character byte
149+  E1C5 15                                   dec		d							; 1 done now
150+  E1C6 20 D5                                jr		nz,.PrintCharLoop
151+  E1C8 C9           .InvalidCharacter:      ret
152+  E1C9 F1           .PlotWithBank:          pop		af
153+  E1CA CD FF E0                             call	l2_plot_pixel				; This will shift bc to poke row
154+  E1CD 18 ED                                jr		.IterateLoop
155+  E1CF
156+  E1CF              ; "l2_print_7at bc= colrow, hl = addr of message, e = colour"
157+  E1CF              ; "No error trapping, if there is no null is will just cycle on the line"
158+  E1CF 7E           l2_print_7at:           ld	a,(hl)							; Return if empty string
159+  E1D0 FE 00                                cp	0
160+  E1D2 C8                                   ret	z
161+  E1D3 E5                                   push	hl
162+  E1D4 D5                                   push	de
163+  E1D5 C5                                   push	bc
164+  E1D6 57                                   ld		d,a							; bc = pos, de = char and colour
165+  E1D7 CD 86 E1                             call 	l2_print_7chr_at
166+  E1DA C1                                   pop		bc
167+  E1DB D1                                   pop		de
168+  E1DC E1                                   pop		hl
169+  E1DD 08           .Move7Pixlestoright:	ex		af,af'
170+  E1DE 79                                   ld		a,c
171+  E1DF C6 07                                add		7
172+  E1E1 4F                                   ld		c,a
173+  E1E2 08                                   ex		af,af'
174+  E1E3 23                                   inc		hl
175+  E1E4 18 E9                                jr		l2_print_7at					; Just loop until 0 found
176+  E1E6
177+  E1E6
# file closed: ./Layer2Graphics/layer2_print_character.asm
768   E1E6                  INCLUDE "./Layer2Graphics/layer2_draw_box.asm"
# file opened: ./Layer2Graphics/layer2_draw_box.asm
  1+  E1E6              ; "l2_draw_thick_box bc=rowcol, de=heightwidth h=color"
  2+  E1E6              ; TODO DMA Optimise
  3+  E1E6 C5 D5 E5     l2_draw_fill_box:       push    bc,,de,,hl
  4+  E1E9 53                                   ld      d,e
  5+  E1EA 5C                                   ld      e,h
  6+  E1EB CD 62 E2                             call    l2_draw_horz_line           ; "bc = left side row,col, d = length, e = color"
  7+  E1EE E1 D1 C1                             pop     bc,,de,,hl
  8+  E1F1 04                                   inc     b
  9+  E1F2 15                                   dec     d
 10+  E1F3 C8                                   ret     z
 11+  E1F4 18 F0                                jr      l2_draw_fill_box
 12+  E1F6
 13+  E1F6              ; "l2_draw_box bc=rowcol, de=heightwidth a=color"
 14+  E1F6 C5 D5 F5     l2_draw_box:            push	bc,,de,,af
 15+  E1F9 53                                   ld		d,e
 16+  E1FA 5F                                   ld		e,a
 17+  E1FB 14                                   inc		d
 18+  E1FC CD 62 E2                             call	l2_draw_horz_line
 19+  E1FF F1 D1 C1                             pop		bc,,de,,af
 20+  E202 C5 D5 F5     .bottomhorzline:	    push	bc,,de,,af
 21+  E205 67                                   ld		h,a							;save color whilst b = row + height
 22+  E206 78                                   ld		a,b
 23+  E207 82                                   add		a,d
 24+  E208 47                                   ld		b,a
 25+  E209 53                                   ld		d,e							; d = width
 26+  E20A 14                                   inc		d							; Extra pixel for width
 27+  E20B 5C                                   ld		e,h							; e = colour
 28+  E20C CD 62 E2                             call	l2_draw_horz_line
 29+  E20F F1 D1 C1                             pop		bc,,de,,af
 30+  E212 C5 D5 F5     .leftvertline:          push	bc,,de,,af
 31+  E215 04                                   inc		b							; save 2 pixles
 32+  E216 15                                   dec		d
 33+  E217 5F                                   ld		e,a							; e = color
 34+  E218 CD B3 E2                             call	l2_draw_vert_line
 35+  E21B F1 D1 C1                             pop		bc,,de,,af
 36+  E21E 04           .rightvertline:         inc		b							; save 2 pixles
 37+  E21F 15                                   dec		d
 38+  E220 67                                   ld		h,a							;save color whilst c = col + width
 39+  E221 79                                   ld		a,c
 40+  E222 83                                   add		a,e
 41+  E223 4F                                   ld		c,a
 42+  E224 5C                                   ld		e,h							; e = color
 43+  E225 CD B3 E2                             call	l2_draw_vert_line
 44+  E228 C9                                   ret
 45+  E229
# file closed: ./Layer2Graphics/layer2_draw_box.asm
769   E229                  INCLUDE "./Layer2Graphics/asm_l2_plot_horizontal.asm"
# file opened: ./Layer2Graphics/asm_l2_plot_horizontal.asm
  1+  E229
  2+  E229              ;; NOTE DMA is little endian
  3+  E229 00           l2_horz_pixel           DB 0
  4+  E22A
  5+  E22A 83 C3 C7 CB  l2_horz_line            DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
  5+  E22E 7D
  6+  E22F 29 E2        l2_horz_colr            DW l2_horz_pixel
  7+  E231 00           l2_horz_lenlo           DB 0
  8+  E232 00           l2_horz_lenhi           DB 0
  9+  E233 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY, DMA_WR2_P2INC_MEMORY, DMA_WR4_CONT_MODE
 10+  E236 00 00        l2_horz_target          DB $00, $00
 11+  E238 CF 87                                DB DMA_LOAD, DMA_ENABLE
 12+  E23A              l2_horz_cmd_len	        EQU $ - l2_horz_line
 13+  E23A
 14+  E23A
 15+  E23A              ; "l2_draw_horz_dma"
 16+  E23A              ; "plot at bc for length d colour e using dma, assumes bank already selected"
 17+  E23A 7B           l2_draw_horz_dma:       ld		a,e
 18+  E23B 32 29 E2                             ld		(l2_horz_pixel),a
 19+  E23E 7A                                   ld		a,d
 20+  E23F 32 31 E2                             ld 		(l2_horz_lenlo),a
 21+  E242 AF                                   xor 	a
 22+  E243 32 32 E2                             ld 		(l2_horz_lenhi),a
 23+  E246 60                                   ld		h,b
 24+  E247 69                                   ld		l,c
 25+  E248 22 36 E2                             ld		(l2_horz_target),hl
 26+  E24B 21 2A E2     .write_dma:             ld 		hl, l2_horz_line
 27+  E24E 06 10                                ld 		b, l2_horz_cmd_len
 28+  E250 0E 6B                                ld		c,IO_DATAGEAR_DMA_PORT
 29+  E252 ED B3                                otir
 30+  E254 C9                                   ret
 31+  E255
 32+  E255              ; "bc = left side row,col, d = length, e = color"
 33+  E255 D5           l2_draw_horz_dma_bank:  push 	de							; save length and colour
 34+  E256 C5                                   push 	bc							; save row col
 35+  E257 78                                   ld   	a,b
 36+  E258 CD 31 E0                             call 	asm_l2_row_bank_select		; now we have the correct bank, its a horizontal line so bank will not shift
 37+  E25B C1                                   pop  	bc
 38+  E25C 47                                   ld	 	b,a	       					; fixed row by the call we can go straight into HL with row col
 39+  E25D D1                                   pop  	de							; get length back
 40+  E25E CD 3A E2                             call    l2_draw_horz_dma
 41+  E261 C9                                   ret
 42+  E262
 43+  E262              ; "l2_draw_horz_line"
 44+  E262              ; "bc = left side row,col, d = length, e = color"
 45+  E262              ; "optimisation if above min pix is will use dma call SCREEN_HOZ_MIN_PIX not implemented yet"
 46+  E262 7A           l2_draw_horz_line:      ld		a,d
 47+  E263 FE 00                                cp 		0							; if its zero length then just return
 48+  E265 C8           .zerolengthexit:        ret		z
 49+  E266 FE 01        .isitlen1:              cp 		1
 50+  E268 CA 8A E2                             jp 		z,.l2_draw_horz_line_1
 51+  E26B FE 0A        .longenoughtfordma:     cp  10
 52+  E26D C3 55 E2                             jp  l2_draw_horz_dma_bank
 53+  E270 D5 C5        .plottableline:         push 	de,,bc  					; save length and colour an d row col
 54+  E272 78                                   ld   	a,b
 55+  E273 CD 31 E0                             call 	asm_l2_row_bank_select		; now we have the correct bank, its a horizontal line so bank will not shift
 56+  E276 C1                                   pop  	bc
 57+  E277 67                                   ld	 	h,a	       					; fixed row by the call we can go straight into HL with row col
 58+  E278 69                                   ld   	l,c
 59+  E279 D1                                   pop  	de							; get length back
 60+  E27A 79           .cliptest:              ld	 	a,c							; get column + length
 61+  E27B 42                                   ld  	b,d  						; speculate that we don't clip by pre-loading b with length
 62+  E27C 82                                   add  	a,d
 63+  E27D 30 06                                jr   	nc, .l2_draw_horz_plot_loop	; if carry is set c+d > 255
 64+  E27F 3E FF        .clipat255:             ld   	a,$FF
 65+  E281 91                                   sub  	c							; a holds clipped length
 66+  E282 47                                   ld 		b, a 						; so now hl holds poke address  b = clipped length e = colour
 67+  E283 18 00                                jr		.l2_draw_horz_plot_loop
 68+  E285 73           .l2_draw_horz_plot_loop:ld (hl),e							; loop poking hl with e for b pixels
 69+  E286 23                                   inc hl
 70+  E287 10 FC                                djnz .l2_draw_horz_plot_loop
 71+  E289 C9                                   ret
 72+  E28A 7B           .l2_draw_horz_line_1:   ld		a,e
 73+  E28B C3 FF E0                             jp		l2_plot_pixel				; hijack return
 74+  E28E
 75+  E28E              ; "l2_draw_horz_line_to"
 76+  E28E              ; "bc = left side row,col, d right pixel, e = color"
 77+  E28E 7A           l2_draw_horz_line_to:   ld 		a,d
 78+  E28F B9                                   cp 		c
 79+  E290 30 04                                jr		nc, .noswap
 80+  E292 28 07                                jr      z, .singlepixel
 81+  E294 51           .swap:                  ld		d,c
 82+  E295 4F                                   ld		c,a
 83+  E296 7A           .noswap:                ld		a,d
 84+  E297 91                                   sub		c
 85+  E298              ;                        dec		a							; so now its length not offset
 86+  E298 57                                   ld		d,a
 87+  E299 18 C7                                jr 		l2_draw_horz_line			; hijack routine and return statements
 88+  E29B 7B           .singlepixel:           ld		a,e
 89+  E29C C3 FF E0                             jp		l2_plot_pixel				; hijack return
 90+  E29F
# file closed: ./Layer2Graphics/asm_l2_plot_horizontal.asm
770   E29F                  INCLUDE "./Layer2Graphics/asm_l2_plot_vertical.asm"
# file opened: ./Layer2Graphics/asm_l2_plot_vertical.asm
  1+  E29F              ; ">l2_draw_vert_segment"
  2+  E29F              ; ">hl = bank adjusted pixel poke address d = length, e = color"
  3+  E29F              ; ">will always clip once h = 64 even if length > 64 destroys a and hl, d = resudual length not plotted"
  4+  E29F 7A           l2_draw_vert_segment:   ld		a,d
  5+  E2A0 FE 00        .emptylinecheck:	    cp 		0
  6+  E2A2 C8                                   ret		z
  7+  E2A3 FE 01        .justonepixel	        cp		1
  8+  E2A5 20 02                                jr		nz, .multiplepixelsLoop
  9+  E2A7 73                                   ld		(hl),e
 10+  E2A8 C9                                   ret
 11+  E2A9              .multiplepixelsLoop:
 12+  E2A9 7C           .endofbankcheck:        ld   	a,h
 13+  E2AA FE 40                                cp   	64
 14+  E2AC D0                                   ret		nc							; check before we poke data if we have hit a boundary
 15+  E2AD 73           .canplotapixel:         ld   	(hl),e						; set colour
 16+  E2AE 24                                   inc 	h							; we don't check here else we would need a dec d on ret could do for optimisation of loop though
 17+  E2AF 15                                   dec		d
 18+  E2B0 C8                                   ret		z
 19+  E2B1 18 F6                                jr		.multiplepixelsLoop
 20+  E2B3
 21+  E2B3              ; ">l2_draw_vert_line"
 22+  E2B3              ; ">bc = row col d = length, e = color"
 23+  E2B3 78           l2_draw_vert_line:      ld 		a,b
 24+  E2B4 FE C0        .offscreencheck:        cp 		SCREEN_HEIGHT
 25+  E2B6 D0                                   ret 	nc							; can't start off the screen
 26+  E2B7 7A           .emptylinecheck:        ld		a,d
 27+  E2B8 FE 00                                cp		0
 28+  E2BA C8                                   ret		z
 29+  E2BB FE 01                                cp		1
 30+  E2BD 20 04                                jr		nz,.multiplepixels
 31+  E2BF CD FF E0     .itsonepixel:           call	l2_plot_pixel
 32+  E2C2 C9                                   ret
 33+  E2C3              .multiplepixels:						; so now we have at least 2 pixels to plot
 34+  E2C3 7A           .clipto192:             ld		a,d							; get length
 35+  E2C4 80                                   add		a,b							; a= row + length
 36+  E2C5 38 04                                jr		c,.needtoclip				; if it was > 255 then there is a definite need
 37+  E2C7 FE C0                                cp		SCREEN_HEIGHT
 38+  E2C9 38 08                                jr		c, .noclipneeded
 39+  E2CB 78           .needtoclip             ld		a,b
 40+  E2CC 82                                   add		a,d
 41+  E2CD D6 C0                                sub		SCREEN_HEIGHT
 42+  E2CF 67                                   ld		h,a							; use h as a temp holding for (row + length) - 192
 43+  E2D0 7A                                   ld		a,d
 44+  E2D1 94                                   sub		h
 45+  E2D2 57                                   ld		d,a							; d = length - ((row + length) - 192)
 46+  E2D3              ; so now BC = row col, d = length clipped, e = color
 47+  E2D3 78           .noclipneeded:          ld		a,b
 48+  E2D4 C5 D5                                push	bc,,de
 49+  E2D6 CD 31 E0                             call 	asm_l2_row_bank_select
 49+  E2D9               	 	; we now have poke address and a variable holding current bank number
 50+  E2D9 D1 C1                                pop		bc,,de
 51+  E2DB 67                                   ld		h,a							; b now tolds target pixel for first plot
 52+  E2DC 69                                   ld		l,c  						; and c holds pixel column for plotting
 53+  E2DD CD 9F E2                             call 	l2_draw_vert_segment		; draw seg, d = pixels remaining
 54+  E2E0 7A                                   ld		a,d							; a and d = nbr pixels remaining
 55+  E2E1 FE 00                                cp		0
 56+  E2E3 28 27                                jr		z, .doneplotting
 57+  E2E5 3A 00 E0     .anotherbank:           ld		a, (varL2_BANK_SELECTED)
 58+  E2E8 3C                                   inc		a
 59+  E2E9 06 00                                ld		b,0
 60+  E2EB C5 D5                                push	bc,,de
 61+  E2ED CD 1A E0                             call 	asm_l2_bank_n_select
 62+  E2F0 D1 C1                                pop     bc,,de
 63+  E2F2 60                                   ld		h,b							; b now tolds target pixel for first plot
 64+  E2F3 69                                   ld		l,c  						; and c holds pixel column for plotting
 65+  E2F4 CD 9F E2                             call	l2_draw_vert_segment
 66+  E2F7 7A                                   ld		a,d
 67+  E2F8 FE 00                                cp		0
 68+  E2FA 28 10                                jr		z,.doneplotting
 69+  E2FC 3A 00 E0     .yetanotherbank:        ld		a, (varL2_BANK_SELECTED)
 70+  E2FF 3C                                   inc		a
 71+  E300 06 00                                ld		b,0
 72+  E302 C5 D5                                push	bc,,de
 73+  E304 CD 1A E0                             call 	asm_l2_bank_n_select
 74+  E307 D1                                   pop		de
 75+  E308 E1                                   pop		hl							; hl = bc
 76+  E309 CD 9F E2                             call	l2_draw_vert_segment		; we have now hit 192 pixels so done
 77+  E30C C9           .doneplotting:	        ret
 78+  E30D
 79+  E30D              ; ">l2_draw_vert_line_to"
 80+  E30D              ; ">bc = row col d = to position, e = color"
 81+  E30D 78           l2_draw_vert_line_to:   ld		a,b
 82+  E30E BA                                   cp		d
 83+  E30F 38 02                                jr		c, .noyswap
 84+  E311 42           .yswap:                 ld		b,d			; Swap round row numbers so we are always incrementing
 85+  E312 57                                   ld		d,a			; now we have a top to bottom to we we can calc length from bc
 86+  E313 7A           .noyswap:               ld		a,d 		; we still may have d in a but only if it was bottom to top
 87+  E314 90                                   sub		b
 88+  E315 3C                                   inc		a			; so now its length not offset
 89+  E316 57                                   ld		d,a
 90+  E317 18 9A                                jr		l2_draw_vert_line	; we can hijack its clipping, 0 check and return logic
 91+  E319                                      ; no return needed
 92+  E319
# file closed: ./Layer2Graphics/asm_l2_plot_vertical.asm
771   E319                  INCLUDE "./Layer2Graphics/layer2_plot_diagonal.asm"
# file opened: ./Layer2Graphics/layer2_plot_diagonal.asm
  1+  E319
  2+  E319              l2_draw_box_to:
  3+  E319              ; ">l2_draw_box_to bc=rowcol, de=torowcol a=color"
  4+  E319              ; ">NOT IMPLEMENTED YET"
  5+  E319 C9           	ret
  6+  E31A
  7+  E31A              ;; Note l2stepx is done via self modifying code rather than an if for speed
  8+  E31A              ;; l2stepx1 and l2stepx2 are the addresses to stick the inc or dec in
  9+  E31A              l2decbstep	EQU $05
 10+  E31A              l2incbstep	EQU	$04
 11+  E31A              l2deccstep	EQU $0D
 12+  E31A              l2inccstep	EQU	$0C
 13+  E31A              		; l2 deltas are signed
 14+  E31A 00 00        l2deltaY	DW	0
 15+  E31C 00 00        l2deltaX	DW	0
 16+  E31E 00           l2deltaYsq	db	0
 17+  E31F 00           l2deltaXsq	db	0
 18+  E320 00           l2deltaYn	db	0
 19+  E321 00           l2deltaXn	db	0
 20+  E322 00           l2deltaYsqn	db	0
 21+  E323 00           l2deltaXsqn	db	0
 22+  E324 00           l2linecolor	db	0
 23+  E325 00 00        l2fraction	dw	0
 24+  E327 00 00        l2e2		dw	0
 25+  E329 00           l2way		db	0
 26+  E32A 00 00        l2targetPtr	dw	0
 27+  E32C              ;; These arrays should be 192 but if we use 256 then getting array2 value is just inc h rather than indexing again.
 28+  E32C 00 00 00...  l2targetArray1 ds	256
 29+  E42C 00 00 00...  l2targetArray2 ds	256
 30+  E52C              ;; Using Bresenham Algorithm draw a diagonal line top to bottom. First we must sort of course
 31+  E52C              ;;plotLine(int x0, int y0, int x1, int y1)
 32+  E52C              ;;    dx =  abs(x1-x0);
 33+  E52C              ;;    sx = x0<x1 ? 1 : -1;
 34+  E52C              ;;    dy = -abs(y1-y0);
 35+  E52C              ;;    sy = y0<y1 ? 1 : -1;
 36+  E52C              ;;    err = dx+dy;  /* error value e_xy */
 37+  E52C              ;;    while (true)   /* loop */
 38+  E52C              ;;        plot(x0, y0);
 39+  E52C              ;;        if (x0==x1 && y0==y1) break;
 40+  E52C              ;;        e2 = 2*err;
 41+  E52C              ;;        if (e2 >= dy) /* e_xy+e_x > 0 */
 42+  E52C              ;;            err += dy;
 43+  E52C              ;;            x0 += sx;
 44+  E52C              ;;        end if
 45+  E52C              ;;        if (e2 <= dx) /* e_xy+e_y < 0 */
 46+  E52C              ;;            err += dx;
 47+  E52C              ;;            y0 += sy;
 48+  E52C              ;;        end if
 49+  E52C              ;;    end while
 50+  E52C              ; ">l2_draw_diagonal_save, bc = y0,x0 de=y1,x1,a=array nbr ESOURCE LL30 or LION"
 51+  E52C              ; ">hl will be either l2targetArray1 or 2"
 52+  E52C              ; NOTE IF WE INTERLEAVE THESE TWO TABLES WE COUDL READ BOTH X POS as a 16 bit read
 53+  E52C FE 01        l2_draw_diagonal_save:  cp		1
 54+  E52E 28 06                                jr		z,l2S_ItsArray1
 55+  E530 21 2C E4                             ld		hl,l2targetArray2
 56+  E533 C3 39 E5                             jp		l2S_setTarget
 57+  E536 21 2C E3     l2S_ItsArray1:	        ld		hl,l2targetArray1
 58+  E539 22 2A E3     l2S_setTarget:	        ld		(l2targetPtr),hl
 59+  E53C              ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
 60+  E53C 32 24 E3                             ld		(l2linecolor),a					;save colour for later
 61+  E53F 21 00 00                             ld		hl,0                            ;
 62+  E542 22 1C E3                             ld		(l2deltaX),hl                   ;
 63+  E545 22 1A E3                             ld		(l2deltaY),hl                   ; initlaise deltas as we will only be loading 8 bit in there but workign in 16 bit later
 64+  E548 78           l2S_preSort:            ld		a,b								;
 65+  E549                                      JumpIfALTNusng	d,l2S_noYSort			; we must have Y1 < Y2 (if eqyal then verical line picked up earlier
 65+  E549 BA          >                        cp      d
 65+  E54A DA 52 E5    >                        jp		c,l2S_noYSort
 66+  E54D              l2S_SortBasedOnY:	    ldhlbc									;
 66+  E54D 60          >                ld		h,b
 66+  E54E 69          >                ld		l,c
 67+  E54F EB                                   ex		de,hl                           ;
 68+  E550                                      ldbchl									; swap over bc and de using hl as an intermediate
 68+  E550 44          >                ld		b,h
 68+  E551 4D          >                ld		c,l
 69+  E552 DD 62        l2S_noYSort:		    ld		ixh,d							; ixh now holds target Y coord post sorting
 70+  E554 DD 6B                                ld		ixl,e							; ixl now holds target X coord post sorting
 71+  E556 79           l2S_setXLen:            ld		a,c                             ;
 72+  E557                                      JumpIfALTNusng e,l2S_PosXLen			; if x1 < x2 then we have a positive increment
 72+  E557 BB          >                        cp      e
 72+  E558 DA 64 E5    >                        jp		c,l2S_PosXLen
 73+  E55B 79           l2S_NegXLen:            ld		a,c                             ;
 74+  E55C 93                                   sub     e                               ;
 75+  E55D 32 1C E3                             ld		(l2deltaX),a					; As x1 > x2 we do deltaX = X1 - X2
 76+  E560 3E 0D                                ld		a,l2deccstep					; and set the value for inc dec self modifying to Dec
 77+  E562 18 07                                jr		l2S_XINCDEC
 78+  E564 7B           l2S_PosXLen:	        ld		a,e                             ;
 79+  E565 91                                   sub		c                               ;
 80+  E566 32 1C E3                             ld 		(l2deltaX),a                    ; As x1 < x2 we do deltaX = X2 - X1
 81+  E569 3E 0C                                ld		a,l2inccstep                    ; and set the value for inc dec self modifying to Inc
 82+  E56B              l2S_XINCDEC:
 83+  E56B 32 D7 E5     	ld		(l2S_adjustCol),a				;
 84+  E56E 32 08 E6     	ld		(l2S_adjustCol2),a				; update self modifying code for X update with inc or dec from above
 85+  E571              l2S_setYLen
 86+  E571 7A           	ld		a,d							 	; presorted on Y so it is now always positive
 87+  E572 90           	sub		b
 88+  E573 32 1A E3     	ld 		(l2deltaY),a					; DeltaY = Y2 - Y1
 89+  E576              l2S_setErr:									;  LD H  := (D'-E')/2    round up if +ve or down if -ve
 90+  E576              ldS_FracDYltDX:								;
 91+  E576 2A 1A E3     	ld		hl,(l2deltaY)					; Fraction = dY - dX
 92+  E579 ED 5B 1C E3  	ld		de,(l2deltaX)
 93+  E57D              	ClearCarryFlag
 93+  E57D B7          >				or a
 94+  E57E ED 52        	sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
 95+  E580 EB           	ex		de,hl
 96+  E581 FD 62        	ld		iyh,d							; we will use IY reg for fractions
 97+  E583 FD 6B        	ld		iyl,e
 98+  E585 F2 AA E5     	jp		p,l2S_fracIsPositive
 99+  E588              l2S_fracIsNegative:
100+  E588              	NegIY
100+  E588 AF          >                xor a
100+  E589 FD 95       >                sub iyl
100+  E58B FD 6F       >                ld iyl,a
100+  E58D 9F          >                sbc a,a
100+  E58E FD 94       >                sub iyh
100+  E590 FD 67       >                ld iyh,a
101+  E592              	ShiftIYRight1
101+  E592 FD 7C       >			   ld 	a,iyh
101+  E594 CB 3F       >			   srl 	a
101+  E596 FD 67       >			   ld	iyh,a
101+  E598 FD 7D       >			   ld 	a,iyl
101+  E59A 1F          >			   rra
101+  E59B FD 6F       >			   ld	iyl,a
102+  E59D              	NegIY
102+  E59D AF          >                xor a
102+  E59E FD 95       >                sub iyl
102+  E5A0 FD 6F       >                ld iyl,a
102+  E5A2 9F          >                sbc a,a
102+  E5A3 FD 94       >                sub iyh
102+  E5A5 FD 67       >                ld iyh,a
103+  E5A7 C3 B5 E5     	jp		l2S_SkipCalcInc					; so we have a negative frac
104+  E5AA              l2S_fracIsPositive:
105+  E5AA              	ShiftIYRight1
105+  E5AA FD 7C       >			   ld 	a,iyh
105+  E5AC CB 3F       >			   srl 	a
105+  E5AE FD 67       >			   ld	iyh,a
105+  E5B0 FD 7D       >			   ld 	a,iyl
105+  E5B2 1F          >			   rra
105+  E5B3 FD 6F       >			   ld	iyl,a
106+  E5B5              l2S_SkipCalcInc:
107+  E5B5              l2S_Loop:									; As we loop, bc = to plot current XY
108+  E5B5 2A 2A E3     	ld		hl,(l2targetPtr)				; Insert into respective array
109+  E5B8 78           	ld		a,b
110+  E5B9 ED 31        	add		hl,a
111+  E5BB 71           	ld		(hl),c
112+  E5BC              l2S_CheckIfEnd:
113+  E5BC DD 7C        	ld		a,ixh
114+  E5BE              	JumpIfAGTENusng	  b,l2S_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
114+  E5BE B8          >                        cp     b
114+  E5BF D2 C5 E5    >                        jp		nc,l2S_CheckXPos
115+  E5C2 C3 C9 E5     	jp		l2S_Continue
116+  E5C5              l2S_CheckXPos:
117+  E5C5 79           	ld		a,c
118+  E5C6              	ReturnIfAGTENusng ixl					; if X1 has reached or exceeded X2 then we are done
118+  E5C6 DD BD       >                   cp    ixl
118+  E5C8 D0          >                   ret	 nc
119+  E5C9              l2S_Continue:
120+  E5C9              l2S_HNegative:
121+  E5C9 FD 7C        	ld		a,iyh
122+  E5CB CB 7F        	bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
123+  E5CD 28 0B        	jr		z,l2S_ErrNotNegative			;
124+  E5CF              l2S_ErrNegative:								; if its a negative error update X
125+  E5CF 3A 1A E3     	ld		a,(l2deltaY)
126+  E5D2 16 00        	ld		d,0
127+  E5D4 5F           	ld		e,a
128+  E5D5 FD 19        	add		iy,de							; add deltaY(unsinged) to l2fraction
129+  E5D7              l2S_adjustCol:
130+  E5D7 00           	nop										; this is our inc/dec of X
131+  E5D8 18 DB        	jr		l2S_Loop							; repeat loop
132+  E5DA              l2S_ErrNotNegative:
133+  E5DA FD 7C        	ld		a,iyh
134+  E5DC FD B5        	or		iyl
135+  E5DE              	IfAIsZeroGoto l2S_ErrZero					; if there is no error then goto zeroerror
135+  E5DE FE 00       >				cp	0
135+  E5E0 CA F9 E5    >				jp	z,l2S_ErrZero
136+  E5E3              l2S_ErrPositive:								; if its a positive error then we update Y
137+  E5E3              	lddeiy
137+  E5E3 FD 54       >                ld		d,iyh
137+  E5E5 FD 5D       >                ld		e,iyl
138+  E5E7 EB           	ex		de,hl
139+  E5E8 16 00        	ld		d,0
140+  E5EA 3A 1C E3     	ld		a,(l2deltaX)
141+  E5ED 5F           	ld		e,a
142+  E5EE              	ClearCarryFlag
142+  E5EE B7          >				or a
143+  E5EF ED 52        	sbc		hl,de
144+  E5F1 EB           	ex		de,hl
145+  E5F2              	ldiyde
145+  E5F2 FD 62       >                ld		iyh,d
145+  E5F4 FD 6B       >                ld		iyl,e
146+  E5F6              l2S_adjustRow:									; move Y down by one
147+  E5F6 04           	inc		b
148+  E5F7 18 BC        	jr		l2S_Loop
149+  E5F9              l2S_ErrZero:
150+  E5F9 2A 1C E3     	ld		hl,(l2deltaX)
151+  E5FC EB           	ex		de,hl
152+  E5FD 2A 1A E3     	ld		hl,(l2deltaY)
153+  E600              	ClearCarryFlag
153+  E600 B7          >				or a
154+  E601 ED 52        	sbc		hl,de
155+  E603 EB           	ex		de,hl
156+  E604              	ldiyde
156+  E604 FD 62       >                ld		iyh,d
156+  E606 FD 6B       >                ld		iyl,e
157+  E608              l2S_adjustCol2:
158+  E608 00           	nop										; update X and Y
159+  E609 04           	inc		b
160+  E60A 18 A9        	jr		l2S_Loop
161+  E60C
162+  E60C              ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
163+  E60C 32 24 E3     l2_draw_diagonal:       ld		(l2linecolor),a					;save colour for later
164+  E60F 21 00 00                             ld		hl,0                            ;
165+  E612 22 1C E3                             ld		(l2deltaX),hl                   ;
166+  E615 22 1A E3                             ld		(l2deltaY),hl                   ; initlaise deltas as we will only be loading 8 bit in there but workign in 16 bit later
167+  E618 78           l2D_preSort:            ld		a,b								;
168+  E619                                      JumpIfALTNusng	d,l2D_noYSort			; we must have Y1 < Y2 (if eqyal then verical line picked up earlier
168+  E619 BA          >                        cp      d
168+  E61A DA 22 E6    >                        jp		c,l2D_noYSort
169+  E61D              l2D_SortBasedOnY:	    ldhlbc									;
169+  E61D 60          >                ld		h,b
169+  E61E 69          >                ld		l,c
170+  E61F EB                                   ex		de,hl                           ;
171+  E620                                      ldbchl									; swap over bc and de using hl as an intermediate
171+  E620 44          >                ld		b,h
171+  E621 4D          >                ld		c,l
172+  E622 DD 62        l2D_noYSort:		    ld		ixh,d							; ixh now holds target Y coord post sorting
173+  E624 DD 6B                                ld		ixl,e							; ixl now holds target X coord post sorting
174+  E626 79           l2D_setXLen:            ld		a,c                             ;
175+  E627                                      JumpIfALTNusng e,l2D_PosXLen			; if x1 < x2 then we have a positive increment
175+  E627 BB          >                        cp      e
175+  E628 DA 34 E6    >                        jp		c,l2D_PosXLen
176+  E62B 79           l2D_NegXLen:            ld		a,c                             ;
177+  E62C 93                                   sub     e                               ;
178+  E62D 32 1C E3                             ld		(l2deltaX),a					; As x1 > x2 we do deltaX = X1 - X2
179+  E630 3E 0D                                ld		a,l2deccstep					; and set the value for inc dec self modifying to Dec
180+  E632 18 07                                jr		l2D_XINCDEC
181+  E634 7B           l2D_PosXLen:	        ld		a,e                             ;
182+  E635 91                                   sub		c                               ;
183+  E636 32 1C E3                             ld 		(l2deltaX),a                    ; As x1 < x2 we do deltaX = X2 - X1
184+  E639 3E 0C                                ld		a,l2inccstep                    ; and set the value for inc dec self modifying to Inc
185+  E63B 32 AA E6     l2D_XINCDEC:	        ld		(l2D_adjustCol),a				;
186+  E63E 32 DB E6                             ld		(l2D_adjustCol2),a				; update self modifying code for X update with inc or dec from above
187+  E641 7A           l2D_setYLen				ld		a,d							 	; presorted on Y so it is now always positive
188+  E642 90                                   sub		b
189+  E643 32 1A E3                             ld 		(l2deltaY),a					; DeltaY = Y2 - Y1
190+  E646              l2D_setErr:									;  LD H  := (D'-E')/2    round up if +ve or down if -ve
191+  E646 2A 1A E3     ldD_FracDYltDX:			ld		hl,(l2deltaY)					; Fraction = dY - dX
192+  E649 ED 5B 1C E3                          ld		de,(l2deltaX)
193+  E64D                                      ClearCarryFlag
193+  E64D B7          >				or a
194+  E64E ED 52                                sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
195+  E650 EB                                   ex		de,hl
196+  E651 FD 62                                ld		iyh,d							; we will use IY reg for fractions
197+  E653 FD 6B                                ld		iyl,e
198+  E655 F2 7A E6                             jp		p,l2D_fracIsPositive
199+  E658              l2D_fracIsNegative:     NegIY
199+  E658 AF          >                xor a
199+  E659 FD 95       >                sub iyl
199+  E65B FD 6F       >                ld iyl,a
199+  E65D 9F          >                sbc a,a
199+  E65E FD 94       >                sub iyh
199+  E660 FD 67       >                ld iyh,a
200+  E662                                      ShiftIYRight1
200+  E662 FD 7C       >			   ld 	a,iyh
200+  E664 CB 3F       >			   srl 	a
200+  E666 FD 67       >			   ld	iyh,a
200+  E668 FD 7D       >			   ld 	a,iyl
200+  E66A 1F          >			   rra
200+  E66B FD 6F       >			   ld	iyl,a
201+  E66D                                      NegIY
201+  E66D AF          >                xor a
201+  E66E FD 95       >                sub iyl
201+  E670 FD 6F       >                ld iyl,a
201+  E672 9F          >                sbc a,a
201+  E673 FD 94       >                sub iyh
201+  E675 FD 67       >                ld iyh,a
202+  E677 C3 85 E6                             jp		l2D_SkipCalcInc					; so we have a negative frac
203+  E67A              l2D_fracIsPositive:     ShiftIYRight1
203+  E67A FD 7C       >			   ld 	a,iyh
203+  E67C CB 3F       >			   srl 	a
203+  E67E FD 67       >			   ld	iyh,a
203+  E680 FD 7D       >			   ld 	a,iyl
203+  E682 1F          >			   rra
203+  E683 FD 6F       >			   ld	iyl,a
204+  E685              l2D_SkipCalcInc:
205+  E685 C5 D5        l2D_Loop:				push	bc,,de                 			; l2DeltaY and l2DeltaX are set
206+  E687 3A 24 E3                             ld		a,(l2linecolor)     			;
207+  E68A CD FF E0                             call	l2_plot_pixel       			; Plot Pixel
208+  E68D D1 C1                                pop     bc,,de
209+  E68F DD 7C        l2D_CheckIfEnd:	        ld		a,ixh
210+  E691                                      JumpIfAGTENusng	  b,l2D_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
210+  E691 B8          >                        cp     b
210+  E692 D2 98 E6    >                        jp		nc,l2D_CheckXPos
211+  E695 C3 9C E6                             jp		l2D_Continue
212+  E698 79           l2D_CheckXPos:          ld		a,c
213+  E699                                      ReturnIfAEqNusng ixl					; if X1 has reached or exceeded X2 then we are done
213+  E699 DD BD       >                  cp      ixl
213+  E69B C8          >                  ret     z
214+  E69C              l2D_Continue:
215+  E69C FD 7C        l2D_HNegative:			ld		a,iyh
216+  E69E CB 7F                                bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
217+  E6A0 28 0B                                jr		z,l2D_ErrNotNegative			;
218+  E6A2 3A 1A E3     l2D_ErrNegative:		ld		a,(l2deltaY)
219+  E6A5 16 00                                ld		d,0
220+  E6A7 5F                                   ld		e,a
221+  E6A8 FD 19                                add		iy,de							; add deltaY(unsinged) to l2fraction
222+  E6AA 00           l2D_adjustCol:          nop										; this is our inc/dec of X
223+  E6AB 18 D8                                jr		l2D_Loop							; repeat loop
224+  E6AD FD 7C        l2D_ErrNotNegative:     ld		a,iyh
225+  E6AF FD B5                                or		iyl
226+  E6B1                                      IfAIsZeroGoto l2D_ErrZero					; if there is no error then goto zeroerror
226+  E6B1 FE 00       >				cp	0
226+  E6B3 CA CC E6    >				jp	z,l2D_ErrZero
227+  E6B6              l2D_ErrPositive:		lddeiy
227+  E6B6 FD 54       >                ld		d,iyh
227+  E6B8 FD 5D       >                ld		e,iyl
228+  E6BA EB                                   ex		de,hl
229+  E6BB 16 00                                ld		d,0
230+  E6BD 3A 1C E3                             ld		a,(l2deltaX)
231+  E6C0 5F                                   ld		e,a
232+  E6C1                                      ClearCarryFlag
232+  E6C1 B7          >				or a
233+  E6C2 ED 52                                sbc		hl,de
234+  E6C4 EB                                   ex		de,hl
235+  E6C5                                      ldiyde
235+  E6C5 FD 62       >                ld		iyh,d
235+  E6C7 FD 6B       >                ld		iyl,e
236+  E6C9 04           l2D_adjustRow:			inc		b
237+  E6CA 18 B9                                jr		l2D_Loop
238+  E6CC 2A 1C E3     l2D_ErrZero:            ld		hl,(l2deltaX)
239+  E6CF EB                                   ex		de,hl
240+  E6D0 2A 1A E3                             ld		hl,(l2deltaY)
241+  E6D3                                      ClearCarryFlag
241+  E6D3 B7          >				or a
242+  E6D4 ED 52                                sbc		hl,de
243+  E6D6 EB                                   ex		de,hl
244+  E6D7                                      ldiyde
244+  E6D7 FD 62       >                ld		iyh,d
244+  E6D9 FD 6B       >                ld		iyl,e
245+  E6DB 00           l2D_adjustCol2:         nop										; update X and Y
246+  E6DC 04                                   inc		b
247+  E6DD 18 A6                                jr		l2D_Loop
248+  E6DF              ;----------------------------------------------------------------------------------------------------------------------------------
249+  E6DF
250+  E6DF
251+  E6DF
252+  E6DF
253+  E6DF              ;Loin:				; BBC version of line draw
254+  E6DF              ;; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color)"
255+  E6DF              ;	ld		(l2linecolor),a					; save colour as a reg gets used alot, coudl move this into interrupt flag and disable interrups
256+  E6DF              ;	ld		ixh,0							; ixh = s
257+  E6DF              ;	ld		iyh,0							; iyh = swap
258+  E6DF              ;	ld		l,0								; l will hold delta sign flags
259+  E6DF              ;LoinCalcDeltaX:
260+  E6DF              ;	ld		a,e
261+  E6DF              ;	sub		c								; a = deltaX
262+  E6DF              ;	JumpIfPositive LoinPosDx
263+  E6DF              ;LoinNegDx:
264+  E6DF              ;	neg										; carry flag will indicate deltaX was negative
265+  E6DF              ;	ld		l,$80							; set bit 7 of l for negative
266+  E6DF              ;LoinPosDx:
267+  E6DF              ;	ld		ixl,a							; ixl = varP = deltaX
268+  E6DF              ;LoinCalcDeltaY:
269+  E6DF              ;	ld		a,d
270+  E6DF              ;	sub		b								; a= deltaY
271+  E6DF              ;	JumpIfPositive LoinPosDy
272+  E6DF              ;LoinNegDy:
273+  E6DF              ;	neg
274+  E6DF              ;	set		6,l								; set bit 6 of l for negative deltaY
275+  E6DF              ;LoinPosDy:
276+  E6DF              ;	ld		iyl,a							; iyl = varQ = deltaY
277+  E6DF              ;	JumpIfAGTENusng ixl, LoinSTPy			; if deltaY >= DeltaX then step along Y
278+  E6DF              ;LoinSTPx:									; step along X
279+  E6DF              ;	JumpOnBitClear l,7						; if l flags were clear then X2 < X2
280+  E6DF              ;LoinSTPxSwapCoords:
281+  E6DF              ;	dec		iyh								; swap flag now becomes FF
282+  E6DF              ;	ld		a,l								; save l flags
283+  E6DF              ;	ex		de,hl							; save de to hl
284+  E6DF              ;	lddebc									; Point2 = point1
285+  E6DF              ;	ldbchl									; Point1 = point2 that was saved
286+  E6DF              ;	ld		l,a								; get back l flags
287+  E6DF              ;LoinSTPxCorrectOrder:
288+  E6DF              ;	l2_point_pixel_y_safe					; call plot pixel preseving bc hl
289+  E6DF              ;	ld		a,iyl							; get delta Y back
290+  E6DF              ;	ld		iy1,$FE							; roll counter
291+  E6DF              ;LionSTPxRollQ:
292+  E6DF              ;	sla		a								; highest bit of delta-Y
293+  E6DF              ;	jp		c,LoinSTPxSteep
294+  E6DF              ;	cp		ixl								; compare with DeltaX
295+  E6DF              ;	jp		cs,LoinSTPxShallow
296+  E6DF              ;LoinSTPxSteep:								;; LI4
297+  E6DF              ;	sbc		a,ixl							; deltaYwork -= (deltaX+1)
298+  E6DF              ;	scf										; force carry flag set
299+  E6DF              ;LoinSTPxShallow:							;; LI5
300+  E6DF              ;	rl		iyl								; rotate iyl which started as FE
301+  E6DF              ;	jp		c,LionSTPxRollQ					; so we are doing a 6 bit loop
302+  E6DF              ;	inc		ihl								; DeltaX += 1
303+  E6DF              ;LoinSTPxYDirection:							; change this to self modifying code
304+  E6DF              ;	ld		a,d
305+  E6DF              ;	JumpIfAGTEn	b,LionDOWN:
306+  E6DF              ;	ld		a,iyh							; swap flag
307+  E6DF              ;	JumpIfANotZero	X1Inc  					; if swap flag was not set then no need to update R
308+  E6DF              ;LoinSTPxX1Dec:
309+  E6DF              ;	dec		c								; move left 1 pixel as we sawped
310+  E6DF              ;LoinSTPxXCounter:							;; LIL2
311+  E6DF              ;	sub		b
312+  E6DF              ;	if
313+  E6DF              ;
314+  E6DF              ;85 82                   STA &82	   \ R	\ mask byte
315+  E6DF              ;A5 81                   LDA &81	   \ Q	\ delta-Y
316+  E6DF              ;A2 FE                   LDX #&FE	\ roll counter
317+  E6DF              ;86 81                   STX &81		\ Q
318+  E6DF              ;.LIL1	\ roll Q
319+  E6DF              ;0A                      ASL A		\ highest bit of delta-Y
320+  E6DF              ;B0 04                   BCS LI4		\ steep
321+  E6DF              ;C5 1B                   CMP &1B	   \ P	\ delta-X
322+  E6DF              ;90 03                   BCC LI5		\ shallow
323+  E6DF              ;.LI4	\ steep
324+  E6DF              ;E5 1B                   SBC &1B		\ P
325+  E6DF              ;38                      SEC
326+  E6DF              ;.LI5	\ shallow
327+  E6DF              ;26 81                   ROL &81	   \ Q	\ #&FE
328+  E6DF              ;B0 F2                   BCS LIL1 	\ loop Q, end with some low bits in Q
329+  E6DF              ;A6 1B                   LDX &1B		\ P
330+  E6DF              ;E8                      INX 		\ Xreg is width
331+  E6DF              ;A5 37                   LDA &37		\ Y2
332+  E6DF              ;E5 35                   SBC &35		\ Y1
333+  E6DF              ;B0 2C                   BCS DOWN	\ draw line to the right and down
334+  E6DF              ;A5 90                   LDA &90		\ SWAP
335+  E6DF              ;D0 07                   BNE LI6		\ else Xreg was correct after all, no need to update R
336+  E6DF              ;CA                      DEX
337+  E6DF              ;.LIL2	\ counter X width
338+  E6DF              ;A5 82                   LDA &82	   \ R	\ mask byte
339+  E6DF              ;51 07                   EOR (&07),Y	\ (SC),Y
340+  E6DF              ;91 07                   STA (&07),Y	\ (SC),Y
341+  E6DF              ;.LI6	\ Xreg correct
342+  E6DF              ;46 82                   LSR &82	   \ R	\ mask byte
343+  E6DF              ;90 08                   BCC LI7   	\ else moving to next column to right. Bring carry in back
344+  E6DF              ;66 82                   ROR &82		\ R
345+  E6DF              ;A5 07                   LDA &07		\ SC
346+  E6DF              ;69 08                   ADC #8		\ next column
347+  E6DF              ;85 07                   STA &07		\ SC
348+  E6DF              ;.LI7	\ S += Q. this is like an overflow monitor to update Y
349+  E6DF              ;A5 83                   LDA &83		\ S
350+  E6DF              ;65 81                   ADC &81	   \ Q	\ some low bits
351+  E6DF              ;85 83                   STA &83		\ S
352+  E6DF              ;90 07                   BCC LIC2	\ skip Y adjustment
353+  E6DF              ;88                      DEY
354+  E6DF              ;10 04                   BPL LIC2	\ skip Y adjustment
355+  E6DF              ;C6 08                   DEC &08		\ SC+1
356+  E6DF              ;A0 07                   LDY #7
357+  E6DF              ;.LIC2	\ skip Y adjustment
358+  E6DF              ;CA                      DEX
359+  E6DF              ;D0 DC                   BNE LIL2	\ loop X width
360+  E6DF              ;A4 85                   LDY &85	 \ YSAV \ restore Yreg
361+  E6DF              ;60                      RTS
362+  E6DF              ;
363+  E6DF              ;.DOWN	\ Line is going to the right and down
364+  E6DF              ;A5 90                   LDA &90		\ SWAP
365+  E6DF              ;F0 07                   BEQ LI9		\ no swap
366+  E6DF              ;CA                      DEX
367+  E6DF              ;.LIL3	\ counter X width
368+  E6DF              ;A5 82                   LDA &82	    \ R \ mask byte
369+  E6DF              ;51 07                   EOR (&07),Y	\ (SC),Y
370+  E6DF              ;91 07                   STA (&07),Y	\ (SC),Y
371+  E6DF              ;.LI9	\ no swap
372+  E6DF              ;46 82                   LSR &82		\ R
373+  E6DF              ;90 08                   BCC LI10	\ still in correct column, hop
374+  E6DF              ;66 82                   ROR &82		\ R
375+  E6DF              ;A5 07                   LDA &07		\ SC
376+  E6DF              ;69 08                   ADC #8		\ next column
377+  E6DF              ;85 07                   STA &07		\ SC
378+  E6DF              ;.LI10	\ this is like an overflow monitor to update Y
379+  E6DF              ;A5 83                   LDA &83		\ S
380+  E6DF              ;65 81                   ADC &81		\ Q
381+  E6DF              ;85 83                   STA &83		\ S
382+  E6DF              ;90 09                   BCC LIC3	\ skip Y adjustment
383+  E6DF              ;C8                      INY
384+  E6DF              ;C0 08                   CPY #8
385+  E6DF              ;D0 04                   BNE LIC3	\ have not reached bottom byte of char, hop
386+  E6DF              ;E6 08                   INC &08		\ SC+1
387+  E6DF              ;A0 00                   LDY #0
388+  E6DF              ;.LIC3	\ skipped Y adjustment
389+  E6DF              ;CA                      DEX
390+  E6DF              ;D0 DA                   BNE LIL3	\ loop X width
391+  E6DF              ;A4 85                   LDY &85	 \ YSAV \ restore Yreg
392+  E6DF              ;60                      RTS
393+  E6DF              ;
394+  E6DF              ;.STPY	\ -> &1797 \ Step along y for line, goes down and to right
395+  E6DF              ;A4 35                   LDY &35		\ Y1
396+  E6DF              ;98                      TYA
397+  E6DF              ;A6 34                   LDX &34		\ X1
398+  E6DF              ;C4 37                   CPY &37		\ Y2
399+  E6DF              ;B0 10                   BCS LI15	\ skip swap if Y1 >= Y2
400+  E6DF              ;C6 90                   DEC &90		\ SWAP
401+  E6DF              ;A5 36                   LDA &36		\ X2
402+  E6DF              ;85 34                   STA &34		\ X1
403+  E6DF              ;86 36                   STX &36		\ X2
404+  E6DF              ;AA                      TAX
405+  E6DF              ;A5 37                   LDA &37		\ Y2
406+  E6DF              ;85 35                   STA &35		\ Y1
407+  E6DF              ;84 37                   STY &37		\ Y2
408+  E6DF              ;A8                      TAY
409+  E6DF              ;.LI15	\ Y1 Y2 order is now correct
410+  E6DF              ;4A                      LSR A
411+  E6DF              ;4A                      LSR A
412+  E6DF              ;4A                      LSR A
413+  E6DF              ;09 60                   ORA #&60
414+  E6DF              ;85 08                   STA &08	 \ SC+1	\ screen hi
415+  E6DF              ;8A                      TXA 		\ X1
416+  E6DF              ;29 F8                   AND #&F8
417+  E6DF              ;85 07                   STA &07	  \ SC	\ screen lo
418+  E6DF              ;8A                      TXA
419+  E6DF              ;29 07                   AND #7		\ mask index
420+  E6DF              ;AA                      TAX
421+  E6DF              ;BD AF 16                LDA &16AF,X \ TWOS,X \ Mode4 single pixel
422+  E6DF              ;85 82                   STA &82	    \ R	\ mask
423+  E6DF              ;A5 35                   LDA &35		\ Y1
424+  E6DF              ;29 07                   AND #7
425+  E6DF              ;A8                      TAY
426+  E6DF              ;A5 1B                   LDA &1B	    \ P	\ delta-X
427+  E6DF              ;A2 01                   LDX #1		\ roll counter
428+  E6DF              ;86 1B                   STX &1B	    	\ P
429+  E6DF              ;.LIL4	\ roll P
430+  E6DF              ;0A                      ASL A
431+  E6DF              ;B0 04                   BCS LI13	\ do subtraction
432+  E6DF              ;C5 81                   CMP &81	    \ Q	\ delta-Y
433+  E6DF              ;90 03                   BCC LI14	\ less than Q
434+  E6DF              ;.LI13	\ do subtraction
435+  E6DF              ;E5 81                   SBC &81		\ Q
436+  E6DF              ;38                      SEC
437+  E6DF              ;.LI14	\ less than Q
438+  E6DF              ;26 1B                   ROL &1B		\ P
439+  E6DF              ;90 F2                   BCC LIL4	\ loop P, end with some low bits in P
440+  E6DF              ;A6 81                   LDX &81		\ Q
441+  E6DF              ;E8                      INX 		\ adjust height
442+  E6DF              ;A5 36                   LDA &36		\ X2
443+  E6DF              ;E5 34                   SBC &34		\ X1
444+  E6DF              ;90 2D                   BCC LFT		\ if C cleared then line moving to the left - hop down
445+  E6DF              ;18                      CLC
446+  E6DF              ;A5 90                   LDA &90		\ SWAP
447+  E6DF              ;F0 07                   BEQ LI17 	\ skip first point
448+  E6DF              ;CA                      DEX
449+  E6DF              ;.LIL5	\ skipped first point, counter X
450+  E6DF              ;A5 82                   LDA &82	    \ R \ mask byte
451+  E6DF              ;51 07                   EOR (&07),Y	\ (SC),Y
452+  E6DF              ;91 07                   STA (&07),Y	\ (SC),Y
453+  E6DF              ;.LI17	\ skipped first point
454+  E6DF              ;88                      DEY
455+  E6DF              ;10 04                   BPL LI16	\ skip hi adjust
456+  E6DF              ;C6 08                   DEC &08		\ SC+1
457+  E6DF              ;A0 07                   LDY #7		\ new char
458+  E6DF              ;	.LI16	\ skipped hi adjust
459+  E6DF              ;A5 83                   LDA &83		\ S
460+  E6DF              ;65 1B                   ADC &1B		\ P
461+  E6DF              ;85 83                   STA &83		\ S
462+  E6DF              ;90 0C                   BCC LIC5	\ skip, still in same column
463+  E6DF              ;46 82                   LSR &82	  \ R	\ mask
464+  E6DF              ;90 08                   BCC LIC5  	\ no mask bit hop
465+  E6DF              ;66 82                   ROR &82   \ R	\ else moved over to next column, reset mask
466+  E6DF              ;A5 07                   LDA &07	  \ SC  \ screen lo
467+  E6DF              ;69 08                   ADC #8		\ next char below
468+  E6DF              ;85 07                   STA &07		\ SC
469+  E6DF              ;.LIC5	\ same column
470+  E6DF              ;CA                      DEX
471+  E6DF              ;D0 DC                   BNE LIL5	\ loop X height
472+  E6DF              ;A4 85                   LDY &85	 \ YSAV	\ restore Yreg
473+  E6DF              ;60                      RTS
474+  E6DF              ;
475+  E6DF              ;.LFT	\ going left
476+  E6DF              ;A5 90                   LDA &90		\ SWAP
477+  E6DF              ;F0 07                   BEQ LI18	\ skip first point
478+  E6DF              ;CA                      DEX 		\ reduce height
479+  E6DF              ;.LIL6	\ counter X height
480+  E6DF              ;A5 82                   LDA &82	   \ R	\ mask byte
481+  E6DF              ;51 07                   EOR (&07),Y	\ (SC),Y
482+  E6DF              ;91 07                   STA (&07),Y	\ (SC),Y
483+  E6DF              ;.LI18
484+  E6DF              ;88                      DEY
485+  E6DF              ;10 04                   BPL LI19	\ skip hi adjust
486+  E6DF              ;C6 08                   DEC &08		\ SC+1
487+  E6DF              ;A0 07                   LDY #7		\ rest char row
488+  E6DF              ;.LI19	\ skipped hi adjust
489+  E6DF              ;A5 83                   LDA &83		\ S
490+  E6DF              ;65 1B                   ADC &1B	    \ P \ some low bits
491+  E6DF              ;85 83                   STA &83		\ S
492+  E6DF              ;90 0D                   BCC LIC6	\ no overflow
493+  E6DF              ;06 82                   ASL &82	    \ R \ else move byte mask to the left
494+  E6DF              ;90 09                   BCC LIC6	\ no overflow
495+  E6DF              ;26 82                   ROL &82		\ R
496+  E6DF              ;A5 07                   LDA &07		\ SC
497+  E6DF              ;E9 07                   SBC #7		\ down 1 char
498+  E6DF              ;85 07                   STA &07		\ SC
499+  E6DF              ;18                      CLC
500+  E6DF              ;.LIC6	\ no overflow
501+  E6DF              ;CA                      DEX 		\ height
502+  E6DF              ;D0 DB                   BNE LIL6	\ loop X
503+  E6DF              ;A4 85                   LDY &85	 \ YSAV	\ restore Yreg
504+  E6DF              ;.HL6
505+  E6DF              ;60                      RTS 		\ end Line drawing
506+  E6DF
507+  E6DF
508+  E6DF              ;;l2_draw_diagonalopt:
509+  E6DF              	; ">TODO l2_draw_diagonalopt fast horz vert optmisation"
510+  E6DF              ;;	push	af
511+  E6DF              ;;	ld		a,b
512+  E6DF              ;;	cp		d
513+  E6DF              ;;	jr		z,.RegularDiagnonal
514+  E6DF              ;;.CheckHorz:
515+  E6DF              ;;	ld		a,c
516+  E6DF              ;;	cp		e
517+  E6DF              ;;	jr		z,.horizontalLine
518+  E6DF              ;;.RegularDiagnonal:
519+  E6DF              ;;	pop		af
520+  E6DF              ;;	call diag
521+  E6DF
522+  E6DF
523+  E6DF              ;;l2_signed_mul2a:
524+  E6DF              ;;; ">l2_signed_mul2a - Signed a = a * 2 using shift)"
525+  E6DF              ;;	TEST	$80
526+  E6DF              ;;	jr		nz, .negativecalc
527+  E6DF              ;;.positivecalc:
528+  E6DF              ;;	ccf
529+  E6DF              ;;	rla
530+  E6DF              ;;	ret
531+  E6DF              ;;.negativecalc:
532+  E6DF              ;;	neg
533+  E6DF              ;;	ccf
534+  E6DF              ;;	rla
535+  E6DF              ;;	neg
536+  E6DF              ;;	ret
537+  E6DF              ;;
538+  E6DF              ;;l2_signed_mul2atohl:
539+  E6DF              ;;; ">l2_signed_mul2ahl - Signed hl = a * 2 using shift)"
540+  E6DF              ;;	TEST	$80
541+  E6DF              ;;	jr		nz, .negativecalc
542+  E6DF              ;;.positivecalc:
543+  E6DF              ;;	ld		hl,0
544+  E6DF              ;;	ld		l,a
545+  E6DF              ;;	add		hl,a
546+  E6DF              ;;	ret
547+  E6DF              ;;.negativecalc:
548+  E6DF              ;;	neg
549+  E6DF              ;;	ld		hl,0
550+  E6DF              ;;	ld		l,a
551+  E6DF              ;;	neghl
552+  E6DF              ;;	ret
553+  E6DF              ;;
554+  E6DF              ;;l2_e2fractionby2:
555+  E6DF              ;;	ld 		hl,(l2fraction)
556+  E6DF              ;;	push	de
557+  E6DF              ;;	ld		d,h
558+  E6DF              ;;	ld		e,l
559+  E6DF              ;;	add		hl,de
560+  E6DF              ;;	pop		de
561+  E6DF              ;;	ld		(l2e2),hl
562+  E6DF              ;;	ret
563+  E6DF
564+  E6DF
565+  E6DF
566+  E6DF
567+  E6DF
568+  E6DF              ;;//	ld		(l2linecolor),a   			; could do an ex but it will be needed multiple times between many uses of a reg
569+  E6DF              ;;//.catchLoop:
570+  E6DF              ;;//	jp .catchLoop
571+  E6DF              ;;//.continue:
572+  E6DF              ;;//    ld      A,D
573+  E6DF              ;;//    sub     H
574+  E6DF              ;;//    jr      NC,.DXpositive    ;delta_x > 0
575+  E6DF              ;;//.DXNegative:
576+  E6DF              ;;//    neg
577+  E6DF              ;;//.DXPositive:
578+  E6DF              ;;//    ld      B,A              ;B <- |delta_x|
579+  E6DF              ;;//    ld      A,E
580+  E6DF              ;;//    sub     L
581+  E6DF              ;;//    jr      NC,.DYpositive    ;delta_y > 0
582+  E6DF              ;;//.DYNegative:
583+  E6DF              ;;//    neg
584+  E6DF              ;;//.DYPositive:
585+  E6DF              ;;//    sub     B               ;|delta_y|
586+  E6DF              ;;//	push	af
587+  E6DF              ;;//	jr		c,.DeltaX
588+  E6DF              ;;//.DeltaY
589+  E6DF              ;;//	ld      A,H             			;if |delta_x| < |delta_y| then
590+  E6DF              ;;//    ld      H,L             			;then values x and y are swapped
591+  E6DF              ;;//    ld      L,A             			;so the loop will always be performed on the
592+  E6DF              ;;//    ld      A,D             			;x value. A flag must be set to
593+  E6DF              ;;//    ld      D,E             			;remind that data must be drawn (y,x)
594+  E6DF              ;;//    ld      E,A             			;instead of (x,y)
595+  E6DF              ;;//.DeltaX:
596+  E6DF              ;;//	ld		a,d
597+  E6DF              ;;//	sub		h
598+  E6DF              ;;//	jr		nc,.TestDY					; x1 < x2
599+  E6DF              ;;//.TestDX:
600+  E6DF              ;;//	ex		de,hl
601+  E6DF              ;;//.TestDY:
602+  E6DF              ;;//	ld		a,e
603+  E6DF              ;;//	sub		l
604+  E6DF              ;;//    ld      A,$01
605+  E6DF              ;;//    jr      NC,.StoreA
606+  E6DF              ;;//    neg                     ;y1 > y2 : in case2 the 'y' variable
607+  E6DF              ;;//.StoreA:
608+  E6DF              ;;//        ld      (l2way),A
609+  E6DF              ;;//.InitLine:
610+  E6DF              ;;//        ld      B,H
611+  E6DF              ;;//        ld      C,L
612+  E6DF              ;;//        ld      A,E
613+  E6DF              ;;//        sub     L
614+  E6DF              ;;//        jr      NC,.EndInit
615+  E6DF              ;;//        ld      A,L
616+  E6DF              ;;//        ld      L,E
617+  E6DF              ;;//        ld      E,A
618+  E6DF              ;;//.EndInit:
619+  E6DF              ;;//        ld      A,E
620+  E6DF              ;;//        sub     L
621+  E6DF              ;;//        rla
622+  E6DF              ;;//        ld      L,A             ;value to add in case1 (d < 0)
623+  E6DF              ;;//        add     A,H
624+  E6DF              ;;//        sub     D
625+  E6DF              ;;//        ld      E,A             ;'d' variable is initialised
626+  E6DF              ;;//        add     A,H
627+  E6DF              ;;//        sub     D
628+  E6DF              ;;//        ld      H,A             ;value to add in case2 (d >= 0)
629+  E6DF              ;;//.Loop:
630+  E6DF              ;;//        ld      A,B
631+  E6DF              ;;//        sub     D
632+  E6DF              ;;//        jr      NC,.EndLine       ;the line is completely drawn.
633+  E6DF              ;;//        pop     AF
634+  E6DF              ;;//        bit     7,A
635+  E6DF              ;;//        push    AF
636+  E6DF              ;;//        push    AF
637+  E6DF              ;;//        push    BC
638+  E6DF              ;;//        jr      Z,.DrawPoint
639+  E6DF              ;;//        ld      A,B
640+  E6DF              ;;//        ld      B,C
641+  E6DF              ;;//        ld      C,A
642+  E6DF              ;;//.DrawPoint:
643+  E6DF              ;;//		push	hl
644+  E6DF              ;;//		pushbcdeaf
645+  E6DF              ;;//		ld		b,e
646+  E6DF              ;;//		ld		c,d
647+  E6DF              ;;//	ld 		a,(l2linecolor)
648+  E6DF              ;;//	call	l2_plot_pixel
649+  E6DF              ;;//		popafdebc
650+  E6DF              ;;//		pop		hl
651+  E6DF              ;;//        pop     BC
652+  E6DF              ;;//        pop     AF
653+  E6DF              ;;//.TestD:
654+  E6DF              ;;//        bit     7,E
655+  E6DF              ;;//        jr      NZ,.Case1
656+  E6DF              ;;//.Case2:                          ;d >= 0
657+  E6DF              ;;//        ld      A,E
658+  E6DF              ;;//        add     A,H
659+  E6DF              ;;//        ld      E,A
660+  E6DF              ;;//        ld      A,(l2way)
661+  E6DF              ;;//        add     A,C
662+  E6DF              ;;//        ld      C,A
663+  E6DF              ;;//        jr      .EndLoop
664+  E6DF              ;;//.Case1:                          ;d < 0
665+  E6DF              ;;//        ld      A,E
666+  E6DF              ;;//        add     A,L
667+  E6DF              ;;//        ld      E,A
668+  E6DF              ;;//.EndLoop:
669+  E6DF              ;;//        inc     B
670+  E6DF              ;;//        jr      .Loop
671+  E6DF              ;;//.EndLine:
672+  E6DF              ;;//        pop     AF              ;MUST NOT BE REMOVED
673+  E6DF              ;;//        pop     HL              ;can be removed
674+  E6DF              ;;//        pop     DE              ;can be removed
675+  E6DF              ;;//        ret
676+  E6DF
677+  E6DF              ;;	ld		(.l2yadjust),a
678+  E6DF              ;;	call	calcdeltax:
679+  E6DF              ;;	ld		(.l2xadjust),a
680+  E6DF              ;;.calcfraction:							; err(or fraction) = dx+dy;
681+  E6DF              ;;	push	hl
682+  E6DF              ;;	push	de
683+  E6DF              ;;	ld		hl,(l2deltaX)
684+  E6DF              ;;	ld		de,(l2deltaY)
685+  E6DF              ;;	add		hl,de
686+  E6DF              ;;	ld		(l2fraction),hl
687+  E6DF              ;;	pop		de
688+  E6DF              ;;	pop		hl
689+  E6DF              ;;.mainloop:
690+  E6DF              ;;	push	bc
691+  E6DF              ;;	push	de
692+  E6DF              ;;	ld 		a,(l2linecolor)
693+  E6DF              ;;	call	l2_plot_pixel
694+  E6DF              ;;	pop		de
695+  E6DF              ;;	pop		bc
696+  E6DF              ;;.arewefinishedtest
697+  E6DF              ;;	ld		a,b
698+  E6DF              ;;	cp		d
699+  E6DF              ;;	jr		nz,.notthereyet
700+  E6DF              ;;	ld		a,c
701+  E6DF              ;;	cp		e
702+  E6DF              ;;	ret		z
703+  E6DF              ;;.notthereyet:
704+  E6DF              ;;	push	de
705+  E6DF              ;;	call	l2_e2fractionby2			; e2 = 2*err;
706+  E6DF              ;;	pop		de
707+  E6DF              ;;.e2dytest:								; if (e2 >= dy) /* e_xy+e_x > 0 */  then S and P/V are the same
708+  E6DF              ;;	push	de							; so if m & pe  or p & po calc (m = sign set p = 0)
709+  E6DF              ;;	ld		de,(l2deltaY)				;    if m & po  or p & pe skip  (pe = pv set po = pv 0)
710+  E6DF              ;;	or		a							;
711+  E6DF              ;;	sbc		hl,de						;
712+  E6DF              ;;	pop		de
713+  E6DF              ;;	jr		z,  .dodycalc				; if equal then calc
714+  E6DF              ;;	jp		p,	.dodycalc				; sign clear to H>D even with negtives
715+  E6DF              ;;	jr		.skipdycalc         		; sign = 0     so  skip as pe
716+  E6DF              ;;.dodycalc:
717+  E6DF              ;;	ld		hl,(l2fraction)
718+  E6DF              ;;	push	de
719+  E6DF              ;;	ld		de,(l2deltaY)
720+  E6DF              ;;	add		hl,de
721+  E6DF              ;;	ld		(l2fraction),de
722+  E6DF              ;;	pop		de
723+  E6DF              ;;.l2yadjust:
724+  E6DF              ;;	nop
725+  E6DF              ;;.skipdycalc:
726+  E6DF              ;;.e2dxtest:								;  if (e2 <= dx) /* e_xy+e_y < 0 */ then S and P/V are different.
727+  E6DF              ;;	ld		hl,(l2e2)
728+  E6DF              ;;	push	de							;
729+  E6DF              ;;	ld		de,(l2deltaX)				;
730+  E6DF              ;;	or		a							; clear carry flag
731+  E6DF              ;;	sbc		hl,de						; hl = hl - de is if de > hl will get pv and signed different?
732+  E6DF              ;;	pop		de
733+  E6DF              ;;	jr		z,.dodxcalc					; e2 == dx so do calc
734+  E6DF              ;;	jp		m,.dodxcalc					; was sign bit set
735+  E6DF              ;;	jr		.skipdxcalc         	    ; diff so skip ; pvclear = po        pvset = pe
736+  E6DF              ;;.dodxcalc:
737+  E6DF              ;;	ld		hl,(l2fraction)
738+  E6DF              ;;	push	de
739+  E6DF              ;;	ld		de,(l2deltaX)
740+  E6DF              ;;	add		hl,de
741+  E6DF              ;;	ld		(l2fraction),de
742+  E6DF              ;;	pop		de
743+  E6DF              ;;.l2xadjust:
744+  E6DF              ;;	nop
745+  E6DF              ;;.skipdxcalc:
746+  E6DF              ;;	jr 		.mainloop
747+  E6DF
748+  E6DF
749+  E6DF              ;;/l2_draw_diagonalold:
750+  E6DF              ;;/MESSAGE ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color)"
751+  E6DF              ;;/	ld		(l2linecolor),a   			; could do an ex but it will be needed multiple times between many uses of a reg
752+  E6DF              ;;/.sortycoords:
753+  E6DF              ;;/	ld		a,b							; Sort to Y0 is always > y1 so we don't have to deal with step y and only step x
754+  E6DF              ;;/	cp		d
755+  E6DF              ;;/	jr		nc, .nocoordswap
756+  E6DF              ;;/.swapcoords:
757+  E6DF              ;;/	ex		de,hl						; save de to hl ! effective code line 98 after macros
758+  E6DF              ;;/	lddebc
759+  E6DF              ;;/	ldbchl
760+  E6DF              ;;/.nocoordswap:
761+  E6DF              ;;/	ld		a,d							; l2_dy = -ABS(l2_vy1 - l2_vy0)
762+  E6DF              ;;/	sub		b							; we have already sorted  so y1 > y0
763+  E6DF              ;;/	ld		(l2deltaY),a
764+  E6DF              ;;/	neg									; DEBUG
765+  E6DF              ;;/	ld		(l2deltaYn),a				; DEBUG
766+  E6DF              ;;/	neg									; DEBUG
767+  E6DF              ;;/.deltaxequABSx0Minusx1:						; we need to set l2dx to abs x1-x0 and set
768+  E6DF              ;;/    ld		a,c
769+  E6DF              ;;/	cp		e
770+  E6DF              ;;/	jr		c, .x1GTx0
771+  E6DF              ;;/.x1LTx0
772+  E6DF              ;;/	ld		a,c
773+  E6DF              ;;/	sub		e
774+  E6DF              ;;/	ld		(l2deltaX),a				; just 8 bit for now should it be 16?
775+  E6DF              ;;/	neg									; DEBUG
776+  E6DF              ;;/	ld		(l2deltaXn),a				; DEBUG
777+  E6DF              ;;/	neg									; DEBUG
778+  E6DF              ;;/	ld		a,l2incbstep
779+  E6DF              ;;/	jr		.setlayershift0
780+  E6DF              ;;/.x1GTx0:
781+  E6DF              ;;/	ld		a,e
782+  E6DF              ;;/	sub		c
783+  E6DF              ;;/	ld		(l2deltaX),a					; just 8 bit for now should it be 16?
784+  E6DF              ;;/	neg									; DEBUG
785+  E6DF              ;;/	ld		(l2deltaXn),a				; DEBUG
786+  E6DF              ;;/	neg									; DEBUG
787+  E6DF              ;;/	ld		a,l2decbstep
788+  E6DF              ;;/.setlayershift0:
789+  E6DF              ;;/	ld		a,0
790+  E6DF              ;;/	pushbcde
791+  E6DF              ;;/	call	asm_l2_bank_n_select		; l2_layer_shift = 0 and bank 0 selected
792+  E6DF              ;;/	popdebc
793+  E6DF              ;;/; so now we have set inc or dec instruction, l2dy, l2dx and on bank 0,
794+  E6DF              ;;/.dymuliplyby2:
795+  E6DF              ;;/	ld		a, (l2deltaY)				; dy *= 2
796+  E6DF              ;;/	call	l2_signed_mul2a
797+  E6DF              ;;/	ld		(l2deltaYsq),a
798+  E6DF              ;;/	neg									; DEBUG
799+  E6DF              ;;/	ld		(l2deltaYsqn),a				; DEBUG
800+  E6DF              ;;/	neg									; DEBUG
801+  E6DF              ;;/.dxmuliplyby2:
802+  E6DF              ;;/	ld		a, (l2deltaX)				; dx *= 2
803+  E6DF              ;;/	call	l2_signed_mul2a
804+  E6DF              ;;/	ld		(l2deltaXsq),a
805+  E6DF              ;;/	neg									; DEBUG
806+  E6DF              ;;/	ld		(l2deltaXsqn),a				; DEBUG
807+  E6DF              ;;/	neg									; DEBUG
808+  E6DF              ;;/.plotfirstpixel:
809+  E6DF              ;;/	pushbcde
810+  E6DF              ;;/	ld a,(l2linecolor)
811+  E6DF              ;;/	call	l2_plot_pixel
812+  E6DF              ;;/	popdebc
813+  E6DF              ;;/.mainloop:								; if (l2_dx > l2_dy) signed
814+  E6DF              ;;/	ld		a,(l2deltaX)				;If A < N, then S and P/V are different.
815+  E6DF              ;;/	ld		hl,l2deltaY					;A >= N, then S and P/V are the same
816+  E6DF              ;;/	cp		(hl)
817+  E6DF              ;;/	jp		m,	.signset
818+  E6DF              ;;/.signclear:
819+  E6DF              ;;/	jp		pe,	.dxLTEdybranch
820+  E6DF              ;;/	jr		.dxGTdybranch
821+  E6DF              ;;/.signset:
822+  E6DF              ;;/	jp		po,	.dxLTEdybranch
823+  E6DF              ;;/.dxGTdybranch:
824+  E6DF              ;;/	ld		a,(l2deltaYsq)
825+  E6DF              ;;/	ld		hl,l2deltaX
826+  E6DF              ;;/	sub		(hl)
827+  E6DF              ;;/	ld		(l2fraction),a				; faction = dy - 1/2 dx
828+  E6DF              ;;/.BranchAwhile							; while (l2_vx0 != l2_vx1)
829+  E6DF              ;;/	ld		a,c
830+  E6DF              ;;/	cp		e
831+  E6DF              ;;/	ret		z							; if x0 = x1 then done
832+  E6DF              ;;/.BranchAtestfraction:					; if (l2_fraction >= 0)
833+  E6DF              ;;/	ld		a,(l2fraction)
834+  E6DF              ;;/	TEST	$80
835+  E6DF              ;;/	jr		nz,.BranchAskipYstep
836+  E6DF              ;;/	inc		b							; 		++l2_vy0;
837+  E6DF              ;;/	ld		hl,l2deltaXsq
838+  E6DF              ;;/	sub		(hl)						; 		l2_fraction -= l2_dx;
839+  E6DF              ;;/	ld		(l2fraction),a
840+  E6DF              ;;/.BranchAskipYstep:
841+  E6DF              ;;/.l2stepx1:
842+  E6DF              ;;/	inc		b							; this is self modifying code point 1 l2_vx0 += l2_stepx
843+  E6DF              ;;/	ld		a,(l2fraction)				; l2_fraction += l2_dy can optimise later as a already has this?
844+  E6DF              ;;/	ld		hl,l2deltaYsq
845+  E6DF              ;;/	add		a,(hl)
846+  E6DF              ;;/	ld		(l2fraction),a
847+  E6DF              ;;/.BranchAplotBCColA:						; l2_plot_pixel(l2_vx0,l2_vy0,color);
848+  E6DF              ;;/	pushbcde
849+  E6DF              ;;/	ld a,(l2linecolor)
850+  E6DF              ;;/	call	l2_plot_pixel
851+  E6DF              ;;/	popdebc
852+  E6DF              ;;/.BranchAloop:
853+  E6DF              ;;/	jr		.BranchAwhile
854+  E6DF              ;;/.dxLTEdybranch:
855+  E6DF              ;;/	ld		a,(l2deltaXsq)				; l2_fraction = l2_dx - (l2_dy >> 1);
856+  E6DF              ;;/	ld		hl, l2deltaY
857+  E6DF              ;;/	sub		(hl)
858+  E6DF              ;;/	ld		(l2fraction),a				; faction = dy - 1/2 d
859+  E6DF              ;;/.BranchBwhile:							; while (l2_vy0 != l2_vy1)
860+  E6DF              ;;/	ld		a,b
861+  E6DF              ;;/	cp		d
862+  E6DF              ;;/	ret		z							; if x0 = x1 then done
863+  E6DF              ;;/.BranchBtestfraction:					; if (l2_fraction >= 0)
864+  E6DF              ;;/	ld		a,(l2fraction)
865+  E6DF              ;;/	TEST	$80
866+  E6DF              ;;/	jr		nz,.BranchBskipYstep
867+  E6DF              ;;/.l2stepx2
868+  E6DF              ;;/	inc		b							; l2_vx0 += l2_stepx; this is self modifying code point 2
869+  E6DF              ;;/	ld		a,(l2fraction)				; l2_fraction -= l2_dy
870+  E6DF              ;;/	ld		hl,l2deltaYsq
871+  E6DF              ;;/	sub		(hl)
872+  E6DF              ;;/	ld		(l2fraction),a
873+  E6DF              ;;/.BranchBskipYstep:
874+  E6DF              ;;/	ld		hl, l2deltaYsq
875+  E6DF              ;;/	add		a,(hl)
876+  E6DF              ;;/	ld		(l2fraction),a
877+  E6DF              ;;/	inc		b							; ++l2_vy0;
878+  E6DF              ;;/.BranchBplotBCColA:
879+  E6DF              ;;/	pushbcde
880+  E6DF              ;;/	ld a,(l2linecolor)
881+  E6DF              ;;/	call	l2_plot_pixel
882+  E6DF              ;;/	popdebc
883+  E6DF              ;;/.BranchBloop:
884+  E6DF              ;;/	jr		.BranchBwhile
885+  E6DF
# file closed: ./Layer2Graphics/layer2_plot_diagonal.asm
772   E6DF                  INCLUDE "./Layer2Graphics/asm_l2_plot_triangle.asm"
# file opened: ./Layer2Graphics/asm_l2_plot_triangle.asm
  1+  E6DF
  2+  E6DF
  3+  E6DF
  4+  E6DF 00 00        l2trianglebc	        DW 0
  5+  E6E1 00 00        l2trianglede	        DW 0
  6+  E6E3 00 00        l2trianglehl	        DW 0
  7+  E6E5
  8+  E6E5              ; "l2_draw_triangle, BC = y1x1, DE=y2x2, HL=y3x3 a = Color"
  9+  E6E5 C5 D5 E5 F5  l2_draw_triangle:       push	bc,,de,,hl,,af
 10+  E6E9 CD 0C E6                             call	l2_draw_diagonal		; BC to DE
 11+  E6EC F1                                   pop		af
 12+  E6ED D1                                   pop		de						; swap DE and HL
 13+  E6EE E1                                   pop		hl						; so BC to DE is really to HL
 14+  E6EF C1                                   pop		bc
 15+  E6F0 D5 E5                                push    de,,hl                    ; which is pushing original hl then original de
 16+  E6F2 F5                                   push	af
 17+  E6F3 CD 0C E6                             call	l2_draw_diagonal		; BC to HL (leaving DE and HL swapped)
 18+  E6F6 F1                                   pop		af
 19+  E6F7 C1                                   pop		bc						; Now bc = original de
 20+  E6F8 D1                                   pop		de						; de = original hl
 21+  E6F9 CD 0C E6                             call	l2_draw_diagonal		; BC to HL (leaving DE and HL swapped)
 22+  E6FC C9                                   ret
 23+  E6FD
 24+  E6FD
 25+  E6FD
 26+  E6FD
 27+  E6FD
# file closed: ./Layer2Graphics/asm_l2_plot_triangle.asm
773   E6FD                  INCLUDE "./Layer2Graphics/asm_l2_fill_triangle.asm"
# file opened: ./Layer2Graphics/asm_l2_fill_triangle.asm
  1+  E6FD              ; ">l2_fillBottomFlatTriangle BC y0x0 DE x1x2, H YCommon, L Colour"
  2+  E6FD              ; "note >l2_draw_diagonal_save, bc = y0,x0 de=y1,x1,a=array nbr ESOURCE LL30 or LION"
  3+  E6FD              ; "note line to   bc = left side row,col, d right pixel, e = color"
  4+  E6FD DD 01        l2_fillBottomFlatTriangle:break
  5+  E6FF 7D                                   ld		a,l
  6+  E700 32 24 E3                             ld		(l2linecolor),a
  7+  E703 79                                   ld		a,c
  8+  E704 BB                                   cp		e
  9+  E705 30 08                                jr		nc, .x2gtex1
 10+  E707 DD 26 01     .x1ltx2:                ld		ixh,1                           ; list 1 holds x0 down to x1
 11+  E70A DD 2E 02                             ld		ixl,2                           ; list 2 hols  x0 down to x2
 12+  E70D 18 06                                jr		.storepoints
 13+  E70F DD 26 02     .x2gtex1:               ld		ixh,2
 14+  E712 DD 2E 01                             ld		ixl,1
 15+  E715 C5 D5 E5     .storepoints:           push	bc,,de,,hl
 16+  E718 DD 7C                                ld		a,ixh
 17+  E71A 5A                                   ld		e,d                             ; we alreay have bc so its now bc -> hd
 18+  E71B 54                                   ld		d,h
 19+  E71C CD 2C E5                             call	l2_draw_diagonal_save			;l2_store_diagonal(x0,y0,x1,ycommon,l2_LineMinX);
 20+  E71F E1 D1 C1                             pop		bc,,de,,hl
 21+  E722 C5 E5                                push	bc,,hl
 22+  E724 54                                   ld		d,h                             ; now its bc -> he
 23+  E725 DD 7D                                ld		a,ixl
 24+  E727 CD 2C E5                             call	l2_draw_diagonal_save			;l2_store_diagonal(x0,y0,x2,ycommon,l2_LineMaxX);
 25+  E72A E1 C1                                pop		bc,,hl
 26+  E72C 50           .SaveForLoop:           ld		d,b
 27+  E72D 5C                                   ld		e,h								; save loop counters
 28+  E72E D5                                   push	de								; de = y0ycommon
 29+  E72F 21 2C E3     .GetFirstHorizontalRow:	ld		hl,l2targetArray1               ; get first row for loop
 30+  E732 78                                   ld		a,b
 31+  E733 ED 31                                add		hl,a							; hl = l2targetArray1 row b
 32+  E735 7E                                   ld		a,(hl)							;
 33+  E736 4F                                   ld		c,a								; c = col1 i.e. l2targetarray1[b]
 34+  E737 21 2C E4                             ld      hl,l2targetArray2
 35+  E73A 78                                   ld      a,b
 36+  E73B ED 31                                add     hl,a
 37+  E73D              ;                        inc		h								; hl = l2targetArray2 row b if we interleave
 38+  E73D 7E                                   ld		a,(hl)
 39+  E73E 57                                   ld		d,a								; d = col2 i.e. l2targetarray2[b]
 40+  E73F 3A 24 E3     .SetColour:             ld		a,(l2linecolor)
 41+  E742 5F                                   ld		e,a								; de = to colour
 42+  E743 C5           .SavePoints:            push	bc								; bc = rowcol
 43+  E744 25                                   dec		h
 44+  E745 E5                                   push	hl								; hl = l2targetArray1[b]
 45+  E746 CD 8E E2     .DoLine:	            call	l2_draw_horz_line_to
 46+  E749 E1                                   pop		hl
 47+  E74A C1                                   pop		bc
 48+  E74B 04                                   inc		b								; down a rowc
 49+  E74C D1                                   pop		de								; de = from to (and b also = current)
 50+  E74D 14                                   inc		d
 51+  E74E 7B                                   ld		a,e								; while e >= d
 52+  E74F BA                                   cp		d
 53+  E750 30 DA                                jr 		nc,.SaveForLoop					; Is this the right point??
 54+  E752 C9                                   ret
 55+  E753
# file closed: ./Layer2Graphics/asm_l2_fill_triangle.asm
774   E753                  INCLUDE "./Layer2Graphics/layer2_plot_circle.asm"
# file opened: ./Layer2Graphics/layer2_plot_circle.asm
  1+  E753
  2+  E753 00 00        l2_circle_pos		DW 0
  3+  E755 00           l2_circle_colour	DB 0
  4+  E756 00           l2_circle_radius	DB 0
  5+  E757 00           l2_circle_x			DB 0
  6+  E758 00           l2_circle_y			DB 0
  7+  E759 00           l2_circle_d			DB 0
  8+  E75A
  9+  E75A              ; ">l2_draw_circle BC = center row col, d = radius, e = colour"
 10+  E75A 7B           l2_draw_circle:     ld		a,e
 11+  E75B 32 01 E8                         ld		(.PlotPixel+1),a
 12+  E75E 7A                               ld		a,d								; get radius
 13+  E75F A7                               and		a
 14+  E760 C8                               ret		z
 15+  E761 FE 01                            cp		1
 16+  E763 CA 0D E8                         jp		z,CircleSinglepixel
 17+  E766 ED 43 90 E7                      ld		(.Plot1+1),bc					; save origin into DE reg in code
 18+  E76A DD 67                            ld		ixh,a							; ixh = raidus
 19+  E76C DD 2E 00                         ld		ixl,0
 20+  E76F 26 00        .calcd:	            ld		h,0
 21+  E771 6F                               ld		l,a
 22+  E772 29                               add		hl,hl							; hl = r * 2
 23+  E773 EB                               ex		de,hl							; de = r * 2
 24+  E774 21 03 00                         ld		hl,3
 25+  E777 A7                               and		a
 26+  E778 ED 52                            sbc		hl,de							; hl = 3 - (r * 2)
 27+  E77A 44                               ld		b,h
 28+  E77B 4D                               ld		c,l								; bc = 3 - (r * 2)
 29+  E77C 21 01 00     .calcdelta:         ld		hl,1
 30+  E77F 16 00                            ld		d,0
 31+  E781 DD 5D                            ld		e,ixl
 32+  E783 A7                               and		a
 33+  E784 ED 52                            sbc		hl,de
 34+  E786 11 01 00     .Setde1:            ld		de,1
 35+  E789 DD 7C        .CircleLoop:        ld		a,ixh
 36+  E78B DD BD                            cp		ixl
 37+  E78D D8                               ret		c
 38+  E78E D9           .ProcessLoop:	    exx
 39+  E78F 11 00 00     .Plot1:             ld		de,0
 40+  E792 7B                               ld		a,e
 41+  E793 DD 85                            add		a,ixl
 42+  E795 4F                               ld		c,a
 43+  E796 7A                               ld		a,d
 44+  E797 DD 84                            add		a,ixh
 45+  E799 47                               ld		b,a
 46+  E79A CD 00 E8                         call	.PlotPixel			;CX+X,CY+Y
 47+  E79D 7B           .Plot2:             ld 		a,e
 48+  E79E DD 95                            sub 	ixl
 49+  E7A0 4F                               ld 		c,a
 50+  E7A1 7A                               ld 		a,d
 51+  E7A2 DD 84                            add 	a,ixh
 52+  E7A4 47                               ld		b,a
 53+  E7A5 CD 00 E8                         call	.PlotPixel			;CX-X,CY+Y
 54+  E7A8 7B           .Plot3:             ld 		a,e
 55+  E7A9 DD 85                            add		a,ixl
 56+  E7AB 4F                               ld 		c,a
 57+  E7AC 7A                               ld 		a,d
 58+  E7AD DD 94                            sub 	ixh
 59+  E7AF 47                               ld 		b,a
 60+  E7B0 CD 00 E8                         call	.PlotPixel			;CX+X,CY-Y
 61+  E7B3 7B           .Plot4:             ld 		a,e
 62+  E7B4 DD 95                            sub 	ixl
 63+  E7B6 4F                               ld 		c,a
 64+  E7B7 7A                               ld 		a,d
 65+  E7B8 DD 94                            sub 	ixh
 66+  E7BA 47                               ld 		b,a
 67+  E7BB CD 00 E8                         call	.PlotPixel			;CY+X,CX-Y
 68+  E7BE 7A           .Plot5:	            ld 		a,d
 69+  E7BF DD 85                            add 	a,ixl
 70+  E7C1 47                               ld 		b,a
 71+  E7C2 7B                               ld 		a,e
 72+  E7C3 DD 84                            add 	a,ixh
 73+  E7C5 4F                               ld 		c,a
 74+  E7C6 CD 00 E8                         call	.PlotPixel			;CY+X,CX+Y
 75+  E7C9 7A           .Plot6:	            ld 		a,d
 76+  E7CA DD 95                            sub 	ixl
 77+  E7CC 47                               ld 		b,a
 78+  E7CD 7B                               ld 		a,e
 79+  E7CE DD 84                            add 	a,ixh
 80+  E7D0 4F                               ld 		c,a
 81+  E7D1 CD 00 E8                         call	.PlotPixel			;CY-X,CX+Y
 82+  E7D4 7A           .Plot7:	            ld 		a,d
 83+  E7D5 DD 85                            add 	a,ixl
 84+  E7D7 47                               ld 		b,a
 85+  E7D8 7B                               ld 		a,e
 86+  E7D9 DD 94                            sub 	ixh
 87+  E7DB 4F                               ld 		c,a
 88+  E7DC CD 00 E8                         call	.PlotPixel			;CY+X,CX-Y
 89+  E7DF 7A           .Plot8:	            ld 		a,d
 90+  E7E0 DD 95                            sub 	ixl
 91+  E7E2 47                               ld		b,a
 92+  E7E3 7B                               ld 		a,e
 93+  E7E4 DD 94                            sub 	ixh
 94+  E7E6 4F                               ld 		c,a
 95+  E7E7 CD 00 E8                         call	.PlotPixel			;CX+X,CY-Y
 96+  E7EA D9                               exx
 97+  E7EB CB 7C        .IncrementCircle:	bit     7,h				; Check for Hl<=0
 98+  E7ED 28 03                            jr z,   .draw_circle_1
 99+  E7EF 19                               add hl,de			; Delta=Delta+D1
100+  E7F0 18 05                            jr      .draw_circle_2		;
101+  E7F2 09           .draw_circle_1:		add     hl,bc			; Delta=Delta+D2
102+  E7F3 03                               inc     bc
103+  E7F4 03                               inc     bc				; D2=D2+2
104+  E7F5 DD 25                            dec     ixh				; Y=Y-1
105+  E7F7 03           .draw_circle_2:		inc bc				; D2=D2+2
106+  E7F8 03                               inc bc
107+  E7F9 13                               inc de				; D1=D1+2
108+  E7FA 13                               inc de
109+  E7FB DD 2C                            inc ixl				; X=X+1
110+  E7FD C3 89 E7                         jp      .CircleLoop
111+  E800 3A 55 E7     .PlotPixel:         ld		a,(l2_circle_colour)
112+  E803 D5 C5 E5                         push	de,,bc,,hl
113+  E806 CD 19 E1                         call 	l2_plot_pixel_y_test
114+  E809 E1 C1 D1                         pop		de,,bc,,hl
115+  E80C C9                               ret
116+  E80D 7B           CircleSinglepixel:  ld		a,e
117+  E80E CD 19 E1                         call	l2_plot_pixel_y_test
118+  E811 C9                               ret
119+  E812
# file closed: ./Layer2Graphics/layer2_plot_circle.asm
775   E812                  INCLUDE "./Layer2Graphics/layer2_plot_circle_fill.asm"
# file opened: ./Layer2Graphics/layer2_plot_circle_fill.asm
  1+  E812
  2+  E812 00           l2_circle_dblx		DB 0
  3+  E813 00           l2_circle_dbly		DB 0
  4+  E814
  5+  E814              ; ">l2_draw_circle_fill BC = center row col, d = radius, e = colour"
  6+  E814 7B           l2_draw_circle_fill:    ld		a,e
  7+  E815 32 AB E8                             ld		(.LineColour+1),a
  8+  E818 7A                                   ld		a,d								; get radius
  9+  E819 A7                                   and		a
 10+  E81A C8                                   ret		z
 11+  E81B FE 01                                cp		1
 12+  E81D CA 0D E8                             jp		z,CircleSinglepixel
 13+  E820 ED 43 4A E8                          ld		(.Line1+1),bc					; save origin into DE reg in code
 14+  E824 DD 67                                ld		ixh,a							; ixh = raidus (x)
 15+  E826 DD 2E 00                             ld		ixl,0							; ihy = y
 16+  E829 26 00        .calcd:	                ld		h,0
 17+  E82B 6F                                   ld		l,a
 18+  E82C 29                                   add		hl,hl							; hl = r * 2
 19+  E82D EB                                   ex		de,hl							; de = r * 2
 20+  E82E 21 03 00                             ld		hl,3
 21+  E831 A7                                   and		a
 22+  E832 ED 52                                sbc		hl,de							; hl = 3 - (r * 2)
 23+  E834 44                                   ld		b,h
 24+  E835 4D                                   ld		c,l								; bc = 3 - (r * 2)
 25+  E836 21 01 00     .calcdelta              ld		hl,1
 26+  E839 16 00                                ld		d,0
 27+  E83B DD 5D                                ld		e,ixl
 28+  E83D A7                                   and		a
 29+  E83E ED 52                                sbc		hl,de
 30+  E840 11 01 00     .Setde1	                ld		de,1
 31+  E843 DD 7C        .CircleLoop:            ld		a,ixh
 32+  E845 DD BD                                cp		ixl
 33+  E847 D8                                   ret		c
 34+  E848 D9           .ProcessLoop:	        exx
 35+  E849 11 00 00     .Line1:                 ld		de,0
 36+  E84C 7B                                   ld 		a,e
 37+  E84D DD 95                                sub 	ixl
 38+  E84F 4F                                   ld 		c,a
 39+  E850 7A                                   ld 		a,d
 40+  E851 DD 84                                add 	a,ixh
 41+  E853 47                                   ld		b,a
 42+  E854                                      ;; TODO ADD DOUBLE X CALC
 43+  E854 D5                                   push	de
 44+  E855 DD 55                                ld		d,ixl
 45+  E857 CB 22                                sla		d
 46+  E859 CD A6 E8                             call	.PlotLine			;CX-X,CY+Y
 47+  E85C D1                                   pop		de
 48+  E85D 7B           .Line2:                 ld 		a,e
 49+  E85E DD 95                                sub		ixl
 50+  E860 4F                                   ld 		c,a
 51+  E861 7A                                   ld 		a,d
 52+  E862 DD 94                                sub 	ixh
 53+  E864 47                                   ld 		b,a
 54+  E865                                      ;; TODO ADD DOUBLE X CALC
 55+  E865 D5                                   push	de
 56+  E866 DD 55                                ld		d,ixl
 57+  E868 CB 22                                sla		d
 58+  E86A CD A6 E8                             call	.PlotLine			;CX-X,CY-Y
 59+  E86D D1                                   pop		de
 60+  E86E 7B           .Line3:	                ld 		a,e
 61+  E86F DD 94                                sub		ixh
 62+  E871 4F                                   ld 		c,a
 63+  E872 7A                                   ld 		a,d
 64+  E873 DD 85                                add 	a,ixl
 65+  E875 47                                   ld 		b,a
 66+  E876                                      ;; TODO ADD DOUBLE Y CALC
 67+  E876 D5                                   push	de
 68+  E877 DD 54                                ld		d,ixh
 69+  E879 CB 22                                sla		d
 70+  E87B CD A6 E8                             call	.PlotLine			;CX-Y,CY+x
 71+  E87E D1                                   pop		de
 72+  E87F 7B           .Line4:	                ld 		a,e
 73+  E880 DD 94                                sub		ixh
 74+  E882 4F                                   ld 		c,a
 75+  E883 7A                                   ld 		a,d
 76+  E884 DD 95                                sub 	ixl
 77+  E886 47                                   ld 		b,a
 78+  E887                                      ;; TODO ADD DOUBLE Y CALC
 79+  E887 D5                                   push	de
 80+  E888 DD 54                                ld		d,ixh
 81+  E88A CB 22                                sla		d
 82+  E88C CD A6 E8                             call	.PlotLine			;CX-Y,CY+x
 83+  E88F D1                                   pop		de
 84+  E890 D9                                   exx
 85+  E891 CB 7C        .IncrementCircle:	    bit 7,h				; Check for Hl<=0
 86+  E893 28 03                                jr z,.draw_circle_1
 87+  E895 19                                   add hl,de			; Delta=Delta+D1
 88+  E896 18 05                                jr .draw_circle_2		;
 89+  E898 09           .draw_circle_1:		    add hl,bc			; Delta=Delta+D2
 90+  E899 03                                   inc bc
 91+  E89A 03                                   inc bc				; D2=D2+2
 92+  E89B DD 25                                dec ixh				; Y=Y-1
 93+  E89D 03           .draw_circle_2:		    inc bc				; D2=D2+2
 94+  E89E 03                                   inc bc
 95+  E89F 13                                   inc de				; D1=D1+2
 96+  E8A0 13                                   inc de
 97+  E8A1 DD 2C                                inc ixl				; X=X+1
 98+  E8A3 C3 43 E8                             jp .CircleLoop
 99+  E8A6 D5 C5 E5 F5  .PlotLine:              push	de,,bc,,hl,,af
100+  E8AA 3A 55 E7     .LineColour:	        ld		a,(l2_circle_colour)
101+  E8AD 5F                                   ld      e,a
102+  E8AE CD 62 E2                             call 	l2_draw_horz_line
103+  E8B1 F1 E1 C1 D1                          pop     de,,bc,,hl,,af
104+  E8B5 C9                                   ret
105+  E8B6
# file closed: ./Layer2Graphics/layer2_plot_circle_fill.asm
776   E8B6                  INCLUDE "./Layer2Graphics/l2_draw_any_line.asm"
# file opened: ./Layer2Graphics/l2_draw_any_line.asm
  1+  E8B6              ; ">l2_draw_any_line, bc = y0,x0 de=y1,x1,a=color: determines if its horizontal, vertical or diagonal then hands off the work"
  2+  E8B6 08           l2_draw_any_line:       ex		af,af'
  3+  E8B7 79                                   ld		a,c
  4+  E8B8 BB                                   cp		e
  5+  E8B9 28 08                                jr		z,.HorizontalLine
  6+  E8BB 78                                   ld		a,b
  7+  E8BC BA                                   cp		d
  8+  E8BD 28 0A                                jr		z,.VerticalLine
  9+  E8BF              ; use jp and get a free ret instruction optimisation
 10+  E8BF 08           .DiagonalLine:		    ex		af,af'			; get colour back into a
 11+  E8C0 C3 0C E6                             jp		l2_draw_diagonal
 12+  E8C3
 13+  E8C3 08           .HorizontalLine:        ex		af,af'
 14+  E8C4 53                                   ld		d,e				; set d as target right pixel
 15+  E8C5 5F                                   ld		e,a				; e holds colour on this call
 16+  E8C6 C3 8E E2                             jp		l2_draw_horz_line_to
 17+  E8C9 08           .VerticalLine:          ex		af,af'
 18+  E8CA 5F                                   ld		e,a				; e holds colour on this call
 19+  E8CB C3 0D E3                             jp		l2_draw_vert_line_to
 20+  E8CE
 21+  E8CE
# file closed: ./Layer2Graphics/l2_draw_any_line.asm
777   E8CE                  INCLUDE "./Layer2Graphics/clearLines-LL155.asm"
# file opened: ./Layer2Graphics/clearLines-LL155.asm
  1+  E8CE              ; ClearLines (LL155)
  2+  E8CE              ;   y = 0
  3+  E8CE              ; 	XX20 = UbnkEdgeHeapSize
  4+  E8CE              ;   exit if XX20 < 4
  5+  E8CE              ;   ++y
  6+  E8CE              ;   do
  7+  E8CE              ;		X1 = XX19(Y) ;	Y1 = XX19(++Y) ;	X2 = XX19(++Y);	Y2 = XX19(++Y)
  8+  E8CE              ;   	call DrawLine (x1,y1 to x2,y2) two's compliment (we will do 0)
  9+  E8CE              ;		++y
 10+  E8CE              ;	until Y > XX20
 11+  E8CE
 12+  E8CE              clearLines:
 13+  E8CE              layer2_clearLines:
 14+  E8CE 3A AC 95     LL155cl:                ld		a,(UbnkLineArrayLen)
 15+  E8D1 47                                   ld		b,a
 16+  E8D2 21 C2 91                             ld		hl,UbnkLineArray
 17+  E8D5 C5           clearLinesLoop:         push	bc
 18+  E8D6 7E                                   ld		a,(hl)
 19+  E8D7 23                                   inc		hl
 20+  E8D8 4F                                   ld		c,a
 21+  E8D9 7E                                   ld		a,(hl)
 22+  E8DA 23                                   inc		hl
 23+  E8DB 47                                   ld		b,a
 24+  E8DC 7E                                   ld		a,(hl)
 25+  E8DD 23                                   inc		hl
 26+  E8DE 5F                                   ld		e,a
 27+  E8DF 7E                                   ld		a,(hl)
 28+  E8E0 23                                   inc		hl
 29+  E8E1 57                                   ld		d,a
 30+  E8E2 3E E3                                ld		a,COLOUR_TRANSPARENT		; we erase here
 31+  E8E4 E5                                   push	hl
 32+  E8E5 CD B6 E8                             call    l2_draw_any_line
 33+  E8E8 E1                                   pop		hl
 34+  E8E9 C1                                   pop		bc
 35+  E8EA 10 E9                                djnz	clearLinesLoop
 36+  E8EC C9                                   ret
 37+  E8ED
# file closed: ./Layer2Graphics/clearLines-LL155.asm
778   E8ED                  INCLUDE "./Layer2Graphics/l2_draw_line_v2.asm"
# file opened: ./Layer2Graphics/l2_draw_line_v2.asm
  1+  E8ED              ; ******************************************************************************
  2+  E8ED              ;
  3+  E8ED              ;	Draw a pixel line from (x0,y0) defined in (COORDS) - the current plot
  4+  E8ED              ;	coordinate, to the relative distance points (x0+x,y0+y).
  5+  E8ED              ;
  6+  E8ED              ;	Design & programming by Gunther Strube,	Copyright (C) InterLogic 1995
  7+  E8ED              ;
  8+  E8ED              ;	The (COORDS+0)	pointer contains the current y coordinate, (COORDS+1) the
  9+  E8ED              ;	current x coordinate. The main program should reset the (COORDS) variables
 10+  E8ED              ;	before using line drawing.
 11+  E8ED              ;
 12+  E8ED              ;	The routine checks the range of specified coordinates which is the
 13+  E8ED              ;	boundaries of the graphics area (256x64	pixels).
 14+  E8ED              ;	If a boundary error occurs the routine exits automatically.	This may be
 15+  E8ED              ;	useful if you are trying to draw a line longer than allowed. Only the
 16+  E8ED              ;	visible part will be drawn.
 17+  E8ED              ;
 18+  E8ED              ;	The hardware graphics memory is organized as (0,0) in the top left corner.
 19+  E8ED              ;
 20+  E8ED              ;	The plot routine is	defined by an address pointer	in IX.
 21+  E8ED              ;
 22+  E8ED              ;	IN:	HL =	move	relative x horisontal points (maximum +/- 255).
 23+  E8ED              ;		DE =	move	relative y vertical	points (maximum +/-	255).
 24+  E8ED              ;		IX =	pointer to plot routine that uses HL = (x,y)	of plot coordinate.
 25+  E8ED              ;
 26+  E8ED              ;	OUT:	None.
 27+  E8ED              ;
 28+  E8ED              ;	Registers	used	by routine:
 29+  E8ED              ;		   N	:	B, loop counter
 30+  E8ED              ;		   i	:	line	balance variable
 31+  E8ED              ;		   x	:	H/L,	horisontal, vertical distance	variables
 32+  E8ED              ;		   y	:	H/L,	horisontal, vertical distance	variables
 33+  E8ED              ;	  (x0,y0)	:	(h,l)
 34+  E8ED              ;	  direc_x	:	d, horisontal step increment
 35+  E8ED              ;	  direc_y	:	e, vertical step increment
 36+  E8ED              ;		 ddx	:	b, horisontal step increment
 37+  E8ED              ;		 ddy	:	c, vertical step increment
 38+  E8ED              ;
 39+  E8ED              ;		DE, A work registers.
 40+  E8ED              ;
 41+  E8ED              ; The algorithm in pseudo-code:
 42+  E8ED              ;
 43+  E8ED              ;	direc_x =	SGN x: direc_y	= SGN y
 44+  E8ED              ;	x = ABS x: y =	ABS y
 45+  E8ED              ;
 46+  E8ED              ;	if x	>= y
 47+  E8ED              ;		if x+y=0 then return
 48+  E8ED              ;		H = x
 49+  E8ED              ;		L = y
 50+  E8ED              ;		ddx = direc_x
 51+  E8ED              ;		ddy = 0
 52+  E8ED              ;	else
 53+  E8ED              ;		H = y
 54+  E8ED              ;		L = x
 55+  E8ED              ;		ddx = 0
 56+  E8ED              ;		ddy = direc_y
 57+  E8ED              ;	endif
 58+  E8ED              ;
 59+  E8ED              ;	B = H
 60+  E8ED              ;	i = INT(B/2)
 61+  E8ED              ;	FOR N=B TO 1 STEP -1
 62+  E8ED              ;		i = i + L
 63+  E8ED              ;		if i	< H
 64+  E8ED              ;			ix =	ddx
 65+  E8ED              ;			iy =	ddy
 66+  E8ED              ;		else
 67+  E8ED              ;			i = i - H
 68+  E8ED              ;			ix =	direc_x
 69+  E8ED              ;			iy =	direc_y
 70+  E8ED              ;		endif
 71+  E8ED              ;		x0 =	x0 +	ix
 72+  E8ED              ;		y0 =	y0 +	iy
 73+  E8ED              ;		plot	(x0,y0)
 74+  E8ED              ;	NEXT	N
 75+  E8ED              ;
 76+  E8ED              ;
 77+  E8ED              ;	Registers	changed after return:
 78+  E8ED              ;		..BCDEHL/IXIY/af......	same
 79+  E8ED              ;		AF....../..../..bcdehl	different
 80+  E8ED              ;
 81+  E8ED DF           line_gfx_colour db $DF
 82+  E8EE 00 00        line_gfx_coords	dw 0
 83+  E8F0              LineHLtoDE:
 84+  E8F0 7C           TestMaxY:               ld	a,h ; were h = y or l = y?
 85+  E8F1 FE C0                                cp	192
 86+  E8F3 30 26                                jr	nc, exit_line		; y0	coordinate out	of range
 87+  E8F5 7A                                   ld	a,d
 88+  E8F6 FE C0                                cp	192
 89+  E8F8 30 21                                jr	nc, exit_line		; y1	coordinate out	of range
 90+  E8FA 22 EE E8                             ld	(line_gfx_coords),hl		; the starting	point is now default
 91+  E8FD E5                                   push	hl
 92+  E8FE D5                                   push	de
 93+  E8FF 6C                                   ld	l,h				; L = x0
 94+  E900 62                                   ld	h,d				; H = x1
 95+  E901 7C           distanceX:		        ld	a,h
 96+  E902 95                                   sub	l
 97+  E903 6F                                   ld	l,a
 98+  E904 26 00                                ld	h,0
 99+  E906 30 02                                jr	nc, distanceXDone
100+  E908 26 FF                                ld	h,-1
101+  E90A D1           distanceXDone:          pop	de
102+  E90B E3                                   ex	(sp),hl			; L = y0
103+  E90C 63                                   ld	h,e				; H = y1
104+  E90D 7C           distanceY:		        ld	a,h
105+  E90E 95                                   sub	l
106+  E90F 6F                                   ld	l,a
107+  E910 26 00                                ld	h,0
108+  E912 30 02                                jr	nc, distanceYDone
109+  E914 26 FF                                ld	h,-1
110+  E916 D1           distanceYDone:          pop	de
111+  E917 EB                                   ex	de,hl			; h.dist.	= HL, v.dist. = DE
112+  E918 CD 1C E9                             call	DrawLineRelative			; draw line...
113+  E91B C9           exit_line:              ret
114+  E91C
115+  E91C              ; ***************************************************************************
116+  E91C              ;
117+  E91C              ;	IN:	HL =	move	relative x horisontal points (maximum +/- 255).
118+  E91C              ;		DE =	move	relative y vertical	points (maximum +/-	255).
119+  E91C              ;
120+  E91C              ; OUT: h - l distance in	HL
121+  E91C              ;
122+  E91C
123+  E91C D5           DrawLineRelative:       push	de
124+  E91D E5                                   push	hl
125+  E91E D9                                   exx
126+  E91F E1                                   pop	hl					; get relative	horisontal movement
127+  E920 CD 8B E9                             call	sgn
128+  E923 57                                   ld	d,a					; direc_x	= SGN(x) installed d = +/-1 for horizontal update
129+  E924 CD 98 E9                             call	absValue
130+  E927 45                                   ld	b,l					; x = ABS(x)
131+  E928 E1           DrawLineGetVertRelative:pop	hl					; get relative	vertical movement
132+  E929 CD 8B E9                             call	sgn
133+  E92C 5F                                   ld	e,a					; direc_y	= SGN(y) installed  = +/-1 for vertical update
134+  E92D CD 98 E9                             call	absValue
135+  E930 4D                                   ld	c,l					; y = ABS(y) so now bc = dxdy
136+  E931              ; so by here BC = dx dy HL in increment/decrement x y
137+  E931 C5                                   push	bc
138+  E932 D9                                   exx
139+  E933 E1                                   pop	hl					; H = absolute	x dist., L = absolute y distance
140+  E934 7C                                   ld	a,h
141+  E935 BD                                   cp	l
142+  E936 38 0A                                jr	c, x_smaller_y		; if	x >=	y
143+  E938 B4           areXandYZero:           or	h					;	if x+y = 0
144+  E939 28 4F                                jr	z, exit_draw		;		return
145+  E93B D9           y_lessorequal_x:        exx						;	else
146+  E93C 42                                   ld	b,d					;		ddx = direc_x
147+  E93D 0E 00                                ld	c,0					;		ddy = 0
148+  E93F D9                                   exx
149+  E940 18 08                                jr	init_drawloop		; else
150+  E942 7C           x_smaller_y:	        ld	a,h
151+  E943 65                                   ld	h,l					;	H = y
152+  E944 6F                                   ld	l,a					;	L = x
153+  E945 D9                                   exx
154+  E946 06 00                                ld	b,0					;	ddx = 0
155+  E948 4B                                   ld	c,e					;	ddy = direc_y
156+  E949 D9                                   exx
157+  E94A 44           init_drawloop:	        ld	b,h
158+  E94B 4C                                   ld	c,h					; B = H
159+  E94C CB 39                                srl	c					; i = INT(B/2)
160+  E94E              										; FOR N=B	TO 1	STEP	-1
161+  E94E 79           drawloop:		        ld	a,c
162+  E94F 85                                   add	a,l
163+  E950 38 09                                jr	c, i_greater		;	i + L > 255  (i > H)
164+  E952 BC                                   cp	h
165+  E953 30 06                                jr	nc, i_greater		;	if i	< H
166+  E955 4F                                   ld	c,a					;		i = i + L
167+  E956 D9                                   exx
168+  E957 C5                                   push	bc				;		ix =	ddx:	iy =	ddy
169+  E958 D9                                   exx
170+  E959 18 05                                jr	check_plot			;	else
171+  E95B 94           i_greater:		        sub	h					;		i = i - H
172+  E95C 4F                                   ld	c,a
173+  E95D D9                                   exx
174+  E95E D5                                   push	de				;		ix =	direc_x: iy = direc_y
175+  E95F D9                                   exx						;	endif
176+  E960 E3           check_plot:		        ex	(sp),hl				;	preserve H,L distances on stack
177+  E961 EB                                   ex	de,hl				;	D,E = ix,	iy
178+  E962 2A EE E8                             ld	hl,(line_gfx_coords)
179+  E965 7D                                   ld	a,l
180+  E966 83                                   add	a,e					;
181+  E967 6F                                   ld	l,a					;	y0 =	y0 +	iy (y0 is	checked by plot)
182+  E968 7A                                   ld	a,d
183+  E969 3C                                   inc	a
184+  E96A 84                                   add	a,h
185+  E96B 38 04                                jr	c, check_range		;	check out	of range
186+  E96D 28 1A                                jr	z, range_error		;	Fz=1	& Fc=0 denotes	x0 <	0
187+  E96F 18 02                                jr	plot_point
188+  E971 20 16        check_range:            jr	nz, range_error	;	Fz=0	& Fc=1 denotes	x0 >	255
189+  E973
190+  E973 3D           plot_point:             dec	a
191+  E974 C5                                   push	bc
192+  E975 F5                                   push	af
193+  E976 47                                   ld	    b,a					;	x0 =	x0 +	ix
194+  E977 4D                                   ld		c,l
195+  E978 3A ED E8                             ld		a,(line_gfx_colour)
196+  E97B ED 43 EE E8                          ld      (line_gfx_coords),bc
197+  E97F CD FF E0                             call	l2_plot_pixel
197+  E982
198+  E982 F1                                   pop		af
199+  E983 C1                                   pop		bc
200+  E984 E1           plot_RET:		        pop	hl					;	restore H,L distances...
201+  E985 10 C7                                djnz	drawloop		; NEXT N
202+  E987 18 01                                jr	exit_draw
203+  E989
204+  E989 E1           range_error:	        pop	hl					; remove H,L distances...
205+  E98A C9           exit_draw:		        ret
206+  E98B
207+  E98B
208+  E98B              ; ******************************************************************************
209+  E98B              ;
210+  E98B              ;	SGN (Signum value) of 16	bit signed integer.
211+  E98B              ;
212+  E98B              ;	IN:		HL =	integer
213+  E98B              ;	OUT:		A = result: 0,1,-1 (if zero, positive, negative)
214+  E98B              ;
215+  E98B              ;	Registers	changed after return:
216+  E98B              ;	..BCDEHL/IXIY	same
217+  E98B              ;	AF....../....	different
218+  E98B              ;
219+  E98B 7C           sgn:				    ld	a,h
220+  E98C B5                                   or	l
221+  E98D C8                                   ret	z				; integer	is zero, return 0...
222+  E98E CB 7C                                bit	7,h
223+  E990 20 03                                jr	nz, negative_int
224+  E992 3E 01                                ld	a,1
225+  E994 C9                                   ret
226+  E995 3E FF        negative_int:		    ld	a,-1
227+  E997 C9                                   ret
228+  E998
229+  E998
230+  E998              ; ******************************************************************************
231+  E998              ;
232+  E998              ;	ABS (Absolute value) of 16 bit signed integer.
233+  E998              ;
234+  E998              ;	IN:		HL =	integer
235+  E998              ;	OUT:		HL =	converted	integer
236+  E998              ;
237+  E998              ;	Registers	changed after return:
238+  E998              ;	A.BCDE../IXIY	same
239+  E998              ;	.F....HL/....	different
240+  E998              ;
241+  E998 CB 7C        absValue:			    bit	7,h
242+  E99A C8                                   ret	z				; integer	is positive...
243+  E99B D5                                   push	de
244+  E99C EB                                   ex	de,hl
245+  E99D 21 00 00                             ld	hl,0
246+  E9A0 BF                                   cp	a				; Fc	= 0,	may not be used...
247+  E9A1 ED 52                                sbc	hl,de			; convert	negative integer
248+  E9A3 D1                                   pop	de
249+  E9A4 C9                                   ret
250+  E9A5
# file closed: ./Layer2Graphics/l2_draw_line_v2.asm
779   E9A5
780   E9A5              ;--------------------------------------------------------------------------------------------------------
781   E9A5 00           PLEDGECTR           DB          0
782   E9A6
783   E9A6              PrepLines:              ldWriteZero UbnkLineArrayLen                    ; current line array index = 0
783   E9A6 AF          >               xor      a
783   E9A7 32 AC 95    >               ld       (UbnkLineArrayLen),a
784   E9AA                                      ldWriteZero UbnkLineArrayBytes                  ; UbnkLineArrayBytes= nbr of bytes of lines laoded = array len * 4
784   E9AA AF          >               xor      a
784   E9AB 32 AD 95    >               ld       (UbnkLineArrayBytes),a
785   E9AE                                      ldWriteZero PLEDGECTR
785   E9AE AF          >               xor      a
785   E9AF 32 A5 E9    >               ld       (PLEDGECTR),a
786   E9B2 21 C2 91                             ld          hl,UbnkLineArray
787   E9B5 22 4A 85                             ld          (varU16),hl
788   E9B8              ;LL79--Visible edge--------------------------------------
789   E9B8 3A A5 E9     .PrepLoop:              ld          a,(PLEDGECTR)
790   E9BB CB 27                                sla         a
791   E9BD CB 27                                sla         a
792   E9BF CD E3 95                             call        getVertexNodeAtAToX1Y1              ; get the points X1Y1 from node
793   E9C2 3A A5 E9                             ld          a,(PLEDGECTR)
794   E9C5 3C                                   inc         a
795   E9C6 32 A5 E9                             ld          (PLEDGECTR),a
796   E9C9 CB 27                                sla         a
797   E9CB CB 27                                sla         a
798   E9CD CD F5 95                             call        getVertexNodeAtAToX2Y2              ; get the points X2Y2 from node
799   E9D0 CD A4 8D                             call        CLIP
800   E9D3 38 1D                                jr          c,.LL78EdgeNotVisible                ; LL78 edge not visible
801   E9D5 ED 5B 4A 85                          ld          de,(varU16)                         ; clipped edges heap address
802   E9D9 21 38 90                             ld          hl,UBnkNewX1
803   E9DC                                      FourLDIInstrunctions
803   E9DC ED A0       >                        ldi
803   E9DE ED A0       >                        ldi
803   E9E0 ED A0       >                        ldi
803   E9E2 ED A0       >                        ldi
804   E9E4 ED 53 4A 85                          ld          (varU16),de                         ; update U16 with current address
805   E9E8 21 AC 95                             ld          hl,UbnkLineArrayLen                 ; we have loaded one line
806   E9EB 34                                   inc         (hl)
807   E9EC 7E                                   ld          a,(hl)
808   E9ED                                      JumpIfAGTENusng LineArraySize,CompletedLineGeneration   ; have we hit max lines for a model hop over jmp to Exit edge data loop
808   E9ED FE F0       >                        cp     LineArraySize
808   E9EF D2 FC E9    >                        jp		nc,CompletedLineGeneration
809   E9F2              ; If we hit here we skip the write of line arryay u16
810   E9F2 21 A5 E9     .LL78EdgeNotVisible:    ld          hl,PLEDGECTR                        ;
811   E9F5 34                                   inc         (hl)                                ;
812   E9F6 7E                                   ld          a,(hl)                              ; current edge index ++
813   E9F7                                      JumpIfANENusng LineListLen/4, .PrepLoop       ; compare with total number of points which is edges * 2
813   E9F7 FE 3C       >                cp     LineListLen/4
813   E9F9 C2 B8 E9    >                jp      nz,.PrepLoop
814   E9FC 3A AC 95     CompletedLineGeneration:ld          a,(UbnkLineArrayLen)                ; UbnkLineArrayLen = nbr of lines loaded
815   E9FF CB 27                                sla         a
816   EA01 CB 27                                sla         a                                   ; multiple by 4 to equal number of bytes
817   EA03 32 AD 95                             ld          (UbnkLineArrayBytes),a              ; UbnkLineArrayBytes= nbr of bytes of lines laoded = array len * 4
818   EA06 C9           ExitEdgeDataLoop:       ret
819   EA07
820   EA07                  SAVENEX OPEN "clipTst.nex", $8000 , $7F00
821   EA07                  SAVENEX CFG  0,0,0,1
822   EA07                  SAVENEX AUTO
823   EA07                  SAVENEX CLOSE
824   EA07
# file closed: clipTst.asm
