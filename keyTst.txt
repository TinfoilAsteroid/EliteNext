# file opened: keyTst.asm
  1   0000               DEVICE ZXSPECTRUMNEXT
  2   0000
  3   0000               CSPECTMAP keyTst.map
  4   0000               OPT --zxnext=cspect --syntax=a --reversepop
  5   0000
  6   0000              DEBUGSEGSIZE   equ 1
  7   0000              DEBUGLOGSUMMARY equ 1
  8   0000              ;DEBUGLOGDETAIL equ 1
  9   0000
 10   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 11   0000              ; Game Defines
 12   0000              ScreenLocal     EQU 0
 13   0000              ScreenGalactic  EQU ScreenLocal + 1
 14   0000              ScreenMarket    EQU ScreenGalactic + 1
 15   0000              ScreenMarketDsp EQU ScreenMarket + 1
 16   0000              ScreenStatus    EQU ScreenMarketDsp + 1
 17   0000              ScreenInvent    EQU ScreenStatus + 1
 18   0000              ScreenPlanet    EQU ScreenInvent + 1
 19   0000              ScreenEquip     EQU ScreenPlanet + 1
 20   0000              ScreenLaunch    EQU ScreenEquip + 1
 21   0000              ScreenFront     EQU ScreenLaunch + 1
 22   0000              ScreenAft       EQU ScreenFront+1
 23   0000              ScreenLeft      EQU ScreenAft+2
 24   0000              ScreenRight     EQU ScreenLeft+3
 25   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 26   0000              ; Colour Defines
 27   0000                  INCLUDE "./Hardware/L2ColourDefines.asm"
# file opened: ./Hardware/L2ColourDefines.asm
  1+  0000              L2ColourBLACK           EQU   0
  2+  0000              L2ColourRED_1           EQU 224                 ; RGB 255,  0,  0
  3+  0000              L2ColourRED_2           EQU 192                 ; RGB 218,  0,  0
  4+  0000              L2ColourRED_3           EQU 160                 ; RGB 182,  0,  0
  5+  0000              L2ColourRED_4           EQU 128                 ; RGB 145,  0,  0
  6+  0000              L2ColourRED_5           EQU  96                 ; RGB 109,  0,  0
  7+  0000              L2ColourRED_6           EQU  64                 ; RGB  72,  0,  0
  8+  0000              L2ColourRED_7           EQU  32                 ; RGB  36,  0,  0
  9+  0000              L2ColourYELLOW_1        EQU 252                 ; RGB 255,255,  0
 10+  0000              L2ColourYELLOW_2        EQU 216                 ; RGB 218,218,  0
 11+  0000              L2ColourYELLOW_3        EQU 180                 ; RGB 182,182,  0
 12+  0000              L2ColourYELLOW_4        EQU 144                 ; RGB 145,145,  0
 13+  0000              L2ColourYELLOW_5        EQU 108                 ; RGB 109.109,  0
 14+  0000              L2ColourYELLOW_6        EQU  72                 ; RGB  72, 72,  0
 15+  0000              L2ColourYELLOW_7        EQU  36                 ; RGB  36, 36,  0
 16+  0000              L2ColourGREEN_1		    EQU  28                 ; RGB   0,255,  0
 17+  0000              L2ColourGREEN_2		    EQU  24                 ; RGB   0,218,  0
 18+  0000              L2ColourGREEN_3		    EQU  16                 ; RGB   0,145,  0
 19+  0000              L2ColourGREEN_4         EQU  12                 ; RGB   0,109,  0
 20+  0000              L2ColourGREEN_5         EQU   8                 ; RGB   0, 72,  0
 21+  0000              L2ColourGREEN_6         EQU   4                 ; RGB   0, 36,  0
 22+  0000              L2ColourBLUE_1          EQU   3                 ; RGB 0,0,255
 23+  0000              L2ColourBLUE_2          EQU   2                 ; RGB 0,0,170
 24+  0000              L2ColourBLUE_3          EQU   1                 ; RGB 0,0,85
 25+  0000
 26+  0000
 27+  0000              L2ColourWHITE_1         EQU 255                 ; RGB 255,255,255
 28+  0000              L2ColourWHITE_2         EQU 146
 29+  0000              L2ColourGREY_1		    EQU L2ColourWHITE_2
 30+  0000              L2ColourGREY_2		    EQU 109
 31+  0000              L2ColourGREY_3		    EQU  73
 32+  0000              L2ColourGREY_4		    EQU  37
 33+  0000
 34+  0000              L2ColourGREEN_MB        EQU  29                 ;RGB 0,255,85
 35+  0000              L2ColourGREEN_MR        EQU 124                 ;RGB 109.255,0
 36+  0000              L2ColourCREAM_1         EQU 218                 ; RGB 218,218,170
 37+  0000              L2ColourCREAM_2         EQU 182                 ; RGB 182,182,170
 38+  0000              L2ColourCREAM_3         EQU 146                 ; RGB 145,145,170
 39+  0000
 40+  0000              L2ColourTRANSPARENT     EQU 227                 ; RGB 255,  0,255
 41+  0000              L2ColourMAGENTA_1       EQU 162                 ; RGB 182,  0,170
 42+  0000              L2ColourMAGENTA_2       EQU 130                 ; RGB 145,  0,170
 43+  0000              L2ColourMAGENTA_3       EQU  97                 ; RGB 109,  0, 85
 44+  0000              L2ColourMAGENTA_4       EQU  65                 ; RGB  72,  0, 85
 45+  0000              L2ColourORANGE_1        EQU 236                 ; RGB
 46+  0000              L2ColourORANGE_2        EQU 168                 ; RGB
 47+  0000              L2ColourORANGE_3        EQU  68                 ; RGB
 48+  0000              L2ColourCYAN_1          EQU  31                 ; RGB   0,255, 255
 49+  0000              L2ColourCYAN_2          EQU  18                 ; RGB
 50+  0000              L2ColourCYAN_3          EQU   9                 ; RGB
 51+  0000              L2ColourPURPLE_1        EQU 109                 ; RGB
 52+  0000              L2ColourPURPLE_2        EQU  66                 ; RGB
 53+  0000              L2ColourPURPLE_3        EQU  33                 ; RGB
 54+  0000              L2ColourPINK_1		    EQU 231                 ; RGB
 55+  0000              L2ColourPINK_2		    EQU 226                 ; RGB
 56+  0000              L2ColourPINK_3		    EQU 225                 ; RGB
 57+  0000              L2ColourPINK_4		    EQU 224                 ; RGB
 58+  0000
# file closed: ./Hardware/L2ColourDefines.asm
 28   0000                  INCLUDE "./Hardware/L1ColourDefines.asm"
# file opened: ./Hardware/L1ColourDefines.asm
  1+  0000
  2+  0000              L1ColourInkBlack        EQU %00000000
  3+  0000              L1ColourInkBlue         EQU %00000001
  4+  0000              L1ColourInkRed          EQU %00000010
  5+  0000              L1ColourInkMagenta      EQU %00000011
  6+  0000              L1ColourInkGreen        EQU %00000100
  7+  0000              L1ColourInkCyan         EQU %00000101
  8+  0000              L1ColourInkYellow       EQU %00000110
  9+  0000              L1ColourInkWhite        EQU %00000111
 10+  0000              L1ColourPaperBlack      EQU %00000000
 11+  0000              L1ColourPaperBlue       EQU %00001000
 12+  0000              L1ColourPaperRed        EQU %00010000
 13+  0000              L1ColourPaperMagenta    EQU %00011000
 14+  0000              L1ColourPaperGreen      EQU %00100000
 15+  0000              L1ColourPaperCyan       EQU %00101000
 16+  0000              L1ColourPaperYellow     EQU %00110000
 17+  0000              L1ColourPaperWhite      EQU %00111000
 18+  0000              L1ColourFlash           EQU %10000000
 19+  0000              L1ColourBright          EQU %01000000
 20+  0000              ;----------------------------------------------------------------------------------------------------------------------------------
 21+  0000              ; Screen Specific Colour Defines
 22+  0000              L1InvHighlight          EQU L1ColourBright | L1ColourPaperRed   | L1ColourInkYellow
 23+  0000              L1InvLowlight           EQU                  L1ColourPaperBlack | L1ColourInkWhite
# file closed: ./Hardware/L1ColourDefines.asm
 29   0000
 30   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 31   0000
 32   0000                                      INCLUDE "./Hardware/register_defines.asm"
# file opened: ./Hardware/register_defines.asm
  1+  0000              IO_LAYER2_PORT                          EQU $123B
  2+  0000              IO_EXT_BANK_PORT 			            EQU $DFFD ; 57341
  3+  0000              IO_BANK_PORT                            EQU $7FFD ; 32765
  4+  0000              REGISTER_NUMBER_PORT					EQU $243B
  5+  0000              REGISTER_VALUE_PORT						EQU $253B
  6+  0000              SPRITE_SLOT_PORT						EQU $303B
  7+  0000              SPRITE_INFO_PORT                        EQU $0057
  8+  0000              SPRITE_PATTERN_UPLOAD_PORT				EQU $005B
  9+  0000
 10+  0000              MACHINE_ID_REGISTER						EQU 0
 11+  0000              VERSION_REGISTER						EQU 1
 12+  0000              RESET_REGISTER		    				EQU 2
 13+  0000              MACHINE_TYPE_REGISTER					EQU 3
 14+  0000              PAGE_RAM_REGISTER						EQU 4
 15+  0000              PERIPHERAL_1_REGISTER					EQU 5
 16+  0000              PERIPHERAL_2_REGISTER					EQU 6
 17+  0000              TURBO_MODE_REGISTER						EQU 7
 18+  0000              PERIPHERAL_3_REGISTER					EQU 8
 19+  0000              ANTI_BRICK_SYSTEM_REGISTER				EQU 10
 20+  0000              LAYER2_RAM_PAGE_REGISTER				EQU 18
 21+  0000              LAYER2_RAM_SHADOW_REGISTER      		EQU 19
 22+  0000              TRANSPARENCY_COLOUR_REGISTER			EQU 20
 23+  0000              SPRITE_LAYERS_SYSTEM_REGISTER			EQU 21
 24+  0000              LAYER2_OFFSET_X_REGISTER				EQU 22
 25+  0000              LAYER2_OFFSET_Y_REGISTER				EQU 23
 26+  0000              CLIP_WINDOW_LAYER2_REGISTER				EQU 24
 27+  0000              CLIP_WINDOW_SPRITES_REGISTER			EQU 25
 28+  0000              CLIP_WINDOW_ULA_REGISTER				EQU 26
 29+  0000              CLIP_WINDOW_CONTROL_REGISTER			EQU 28
 30+  0000              ACTIVE_VIDEO_LINE_MSB_REGISTER			EQU 30
 31+  0000              ACTIVE_VIDEO_LINE_LSB_REGISTER			EQU 31
 32+  0000              LINE_INTERRUPT_CONTROL_REGISTER			EQU 34
 33+  0000              LINE_INTERRUPT_VALUE_LSB_REGISTER		EQU 35
 34+  0000              KEYMAP_HIGH_ADDRESS_REGISTER			EQU 40
 35+  0000              KEYMAP_LOW_ADDRESS_REGISTER				EQU 41
 36+  0000              KEYMAP_HIGH_DATA_REGISTER				EQU 42
 37+  0000              KEYMAP_LOW_DATA_REGISTER				EQU 43
 38+  0000              DAC_B_MIRROR_REGISTER                   EQU 44
 39+  0000              DAC_AB_MIRROR_REGISTER                  EQU 45
 40+  0000              DAC_C_MORROR_REGISTER                   EQU 46
 41+  0000              TILEMAP_OFFSET_XMSB_REGISTER            EQU 47
 42+  0000              TILEMAP_OFFSET_XLSB_REGISTER            EQU 48
 43+  0000              TILEMAP_OFFSET_YMSB_REGISTER            EQU 49
 44+  0000              LORES_OFFSET_X_REGISTER					EQU 50
 45+  0000              LORES_OFFSET_Y_REGISTER					EQU 51
 46+  0000              SPRITE_PORT_INDEX_REGISTER              EQU 52
 47+  0000              SPRITE_PORT_ATTR0_REGISTER              EQU 53
 48+  0000              SPRITE_PORT_ATTR1_REGISTER              EQU 54
 49+  0000              SPRITE_PORT_ATTR2_REGISTER              EQU 55
 50+  0000              SPRITE_PORT_ATTR3_REGISTER              EQU 56
 51+  0000              SPRITE_PORT_ATTR4_REGISTER              EQU 57
 52+  0000              PALETTE_INDEX_REGISTER					EQU 64
 53+  0000              PALETTE_VALUE_8BIT_REGISTER				EQU 65
 54+  0000              PALETTE_FORMAT_REGISTER					EQU 66
 55+  0000              PALETTE_CONTROL_REGISTER				EQU 67
 56+  0000              PALETTE_VALUE_9BIT_REGISTER				EQU 68
 57+  0000              MMU_SLOT_0_REGISTER						EQU 80
 58+  0000              MMU_SLOT_1_REGISTER						EQU 81
 59+  0000              MMU_SLOT_2_REGISTER						EQU 82
 60+  0000              MMU_SLOT_3_REGISTER						EQU 83
 61+  0000              MMU_SLOT_4_REGISTER						EQU 84
 62+  0000              MMU_SLOT_5_REGISTER						EQU 85
 63+  0000              MMU_SLOT_6_REGISTER						EQU 86
 64+  0000              MMU_SLOT_7_REGISTER						EQU 87
 65+  0000              COPPER_DATA_REGISTER					EQU 96
 66+  0000              COPPER_CONTROL_LOW_REGISTER				EQU 97
 67+  0000              COPPER_CONTROL_HIGH_REGISTER			EQU 98
 68+  0000              DISPLAY_CONTROL_1_REGISTER              EQU 105
 69+  0000              LAYER_2_CONTROL_REGISTER                EQU 112
 70+  0000              LAYER_2_X_OFFSET_MSB_REGISTER           EQU 113
 71+  0000              DEBUG_LEDS_REGISTER						EQU 255
 72+  0000
 73+  0000
 74+  0000              GetNextReg:	MACRO register
 75+  0000 ~                        push bc
 76+  0000 ~                            ld bc,$243B
 77+  0000 ~                                ld a,register
 78+  0000 ~                                out (c),a
 79+  0000 ~                                inc b
 80+  0000 ~                            in a,(c)
 81+  0000 ~                        pop bc
 82+  0000                          ENDM
 83+  0000
# file closed: ./Hardware/register_defines.asm
 33   0000                                      INCLUDE "./Layer2Graphics/layer2_defines.asm"
# file opened: ./Layer2Graphics/layer2_defines.asm
  1+  0000
  2+  0000
  3+  0000              LAYER2_SHIFTED_SCREEN_TOP  	 equ 0
  4+  0000              LAYER2_SHIFTED_SCREEN_MIDDLE equ $40
  5+  0000              LAYER2_SHIFTED_SCREEN_BOTTOM equ $80
  6+  0000
  7+  0000              ; note hi byte is not decoded on DMA port so can out OUTIR
  8+  0000              IO_DATAGEAR_DMA_PORT 		 equ 107
  9+  0000              IO_SPRITE_SLOT_PORT 		 equ 12347
 10+  0000              IO_SPRITE_PATTERN_PORT       equ 91
 11+  0000              IO_SPRITE_ATTRIBUTES_PORT    equ 87
 12+  0000
 13+  0000              LAYER2_VISIBLE_MASK 		equ $02
 14+  0000              ; DEBUG 0 for always write to primary 08 for double buffering
 15+  0000                  IFDEF DOUBLEBUFFER
 16+  0000 ~            LAYER2_SHADOW_SCREEN_MASK 	equ $08
 17+  0000                  ELSE
 18+  0000              LAYER2_SHADOW_SCREEN_MASK 	equ $00
 19+  0000                  ENDIF
 20+  0000              LAYER2_WRITE_ENABLE_MASK 	equ $01
 21+  0000              LAYER2_SCREEN_SECTION_MASK 	equ $03
 22+  0000              LAYER2_SCREEN_SECTION_SHIFT equ 6
 23+  0000
 24+  0000              LAYER2_SCREEN_BANK1          equ 8
 25+  0000              LAYER2_SCREEN_BANK2          equ 9
 26+  0000              LAYER2_SCREEN_BANK3          equ 10
 27+  0000              LAYER2_SHADOW_BANK1          equ 11
 28+  0000              LAYER2_SHADOW_BANK2          equ 12
 29+  0000              LAYER2_SHADOW_BANK3          equ 13
 30+  0000
 31+  0000              SCREEN_HEIGHT 				 equ 192
 32+  0000              SCREEN_RAM_BASE				 equ $0000
 33+  0000              SCREEN_HOZ_MIN_PIX		     equ 10
 34+  0000
 35+  0000              SPRITES_VISIBLE_MASK         equ $01
 36+  0000              SPRITES_ON_BORDER_MASK       equ $02
 37+  0000              LAYER_PRIORITIES_MASK        equ $07
 38+  0000              LORES_MODE_MASK              equ $80
 39+  0000              LAYER_PRIORITIES_SHIFT       equ 2
 40+  0000
 41+  0000              LAYER_PRIORITIES_S_L_U 		equ 0
 42+  0000              LAYER_PRIORITIES_L_S_U 		equ 1
 43+  0000              LAYER_PRIORITIES_S_U_L  	equ 2
 44+  0000              LAYER_PRIORITIES_L_U_S 		equ 3
 45+  0000              LAYER_PRIORITIES_U_S_L 		equ 4
 46+  0000              LAYER_PRIORITIES_U_L_S 		equ 5
 47+  0000
 48+  0000              DMA_WRO_BLOCK_PORTA_A2B_XFR  equ $7D
 49+  0000              DMA_WRO_BLOCK_PORTA_B2A_XFR  equ $79
 50+  0000              DMA_WR1_P1FIXED_MEMORY       equ $24
 51+  0000              DMA_WR1_P1DEC_MEMORY         equ $04
 52+  0000              DMA_WR1_P1INC_MEMORY         equ $14
 53+  0000              DMA_WR2_P2FIXED_MEMORY       equ $20
 54+  0000              DMA_WR2_P2DEC_MEMORY         equ $00
 55+  0000              DMA_WR2_P2INC_MEMORY         equ $10
 56+  0000              DMA_WR4_CONT_MODE            equ $AD
 57+  0000              DMA_RESET                    equ $c3
 58+  0000              DMA_RESET_PORT_A_TIMING      equ $c7
 59+  0000              DMA_RESET_PORT_B_TIMING      equ $cb
 60+  0000              DMA_LOAD                     equ $cf
 61+  0000              DMA_CONTINUE                 equ $d3
 62+  0000              DMA_DISABLE_INTERUPTS        equ $af
 63+  0000              DMA_ENABLE_INTERUPTS         equ $ab
 64+  0000              DMA_RESET_DISABLE_INTERUPTS  equ $a3
 65+  0000              DMA_ENABLE_AFTER_RETI        equ $b7
 66+  0000              DMA_READ_STATUS_BYTE         equ $bf
 67+  0000              DMA_REINIT_STATUS_BYTE       equ $8b
 68+  0000              DMA_START_READ_SEQUENCE      equ $a7
 69+  0000              DMA_FORCE_READY              equ $b3
 70+  0000              DMA_STOP_AT_END			     equ $82
 71+  0000              DMA_DISABLE                  equ $83
 72+  0000              DMA_ENABLE                   equ $87
 73+  0000              DMA_WRITE_REGISTER_COMMAND   equ $bb
 74+  0000              DMA_BURST                    equ $cd
 75+  0000              DMA_CONTINUOUS               equ $ad
 76+  0000              ZXN_DMA_PORT                 equ $6b
 77+  0000
 78+  0000
 79+  0000              COLOUR_TRANSPARENT			 equ $E3
 80+  0000
 81+  0000
 82+  0000
 83+  0000
# file closed: ./Layer2Graphics/layer2_defines.asm
 34   0000                                      INCLUDE	"./Hardware/memory_bank_defines.asm"
# file opened: ./Hardware/memory_bank_defines.asm
  1+  0000
  2+  0000              membanksize			    equ	$1FFF
  3+  0000
  4+  0000              StartOfBank     	    equ $0000
  5+  0000
  6+  0000              membank0 			    equ $0000
  7+  0000              dmaCopySrcAddr		    equ	$0000
  8+  0000              membank1 			    equ $2000
  9+  0000              membank2 			    equ $4000
 10+  0000              membank3 			    equ $6000
 11+  0000              membank4 			    equ $8000
 12+  0000              membank5 			    equ $a000
 13+  0000              membank6 			    equ $c000
 14+  0000              ScreenBank              equ $c000
 15+  0000              MenuGalChtAddr          equ $c000
 16+  0000              MenuEquipSAddr          equ $c000
 17+  0000              MenuInventAddr          equ $c000
 18+  0000              MenuMarketAddr          equ $c000
 19+  0000              DispMarketAddr          equ $c000
 20+  0000              MenuShrChtAddr          equ $c000
 21+  0000              MenuStatusAddr          equ $c000
 22+  0000              MenuSystemAddr          equ $c000
 23+  0000              ViewFrontAddr           equ $c000
 24+  0000              SunBankAddr             equ $c000
 25+  0000              PlanetBankAddr          equ $c000
 26+  0000              UniverseBankAddr	    equ $c000
 27+  0000              LaunchShipAddr          equ $c000
 28+  0000              membank7 			    equ $e000
 29+  0000              L1membankAddr   	    equ $e000
 30+  0000              L2membankAddr   	    equ $e000
 31+  0000              ShipModelsAddr	        equ $e000
 32+  0000              SpritemembankAddr       equ $e000
 33+  0000              ResetUniverseAddr       equ $e000
 34+  0000              StockTableAddr	        equ $e000
 35+  0000              CommanderAddr           equ $e000
 36+  0000              LAYER2Addr              equ $e000
 37+  0000              LAYER1Addr              equ $e000
 38+  0000              SPRITEAddr              equ $e000
 39+  0000              ConsoleImageAddr        equ $e000
 40+  0000              GalaxyDataAddr          equ $e000
 41+  0000
 42+  0000              DMACpySourceMMU		    equ	MMU_SLOT_0_REGISTER
 43+  0000              SunMMU 		            equ MMU_SLOT_6_REGISTER
 44+  0000              PlanetMMU 		        equ MMU_SLOT_6_REGISTER
 45+  0000              UniverseMMU 		    equ MMU_SLOT_6_REGISTER
 46+  0000              ScreenBankMMU           equ MMU_SLOT_6_REGISTER
 47+  0000              MenuEquipSMMU           equ MMU_SLOT_6_REGISTER
 48+  0000              MenuShrChtMMU           equ MMU_SLOT_6_REGISTER
 49+  0000              MenuGalChtMMU           equ MMU_SLOT_6_REGISTER
 50+  0000              MenuInventMMU           equ MMU_SLOT_6_REGISTER
 51+  0000              MenuSystemMMU           equ MMU_SLOT_6_REGISTER
 52+  0000              MenuMarketMMU           equ MMU_SLOT_6_REGISTER
 53+  0000              DispMarketMMU           equ MMU_SLOT_6_REGISTER
 54+  0000              MenuStatusMMU           equ MMU_SLOT_6_REGISTER
 55+  0000              LaunchShipMMU           equ MMU_SLOT_6_REGISTER
 56+  0000              L1memMMU       		    equ MMU_SLOT_7_REGISTER
 57+  0000              L2memMMU       		    equ MMU_SLOT_7_REGISTER
 58+  0000              SpritememMMU   		    equ MMU_SLOT_7_REGISTER
 59+  0000              ShipModelMMU  		    equ MMU_SLOT_7_REGISTER
 60+  0000              ResetUniverseMMU	    equ MMU_SLOT_7_REGISTER
 61+  0000              CommanderMMU	        equ MMU_SLOT_7_REGISTER
 62+  0000              StockTableMMU		    equ MMU_SLOT_7_REGISTER
 63+  0000              ConsoleImageDataMMU	    equ MMU_SLOT_7_REGISTER
 64+  0000              GalaxyDataMMU	        equ MMU_SLOT_7_REGISTER
 65+  0000
 66+  0000              BankResetUniv           equ 49
 67+  0000              BankMenuShrCht          equ 50
 68+  0000              BankMenuGalCht          equ 51
 69+  0000              BankMenuInvent          equ 52
 70+  0000              BankMenuSystem          equ 53
 71+  0000              BankMenuMarket          equ 54
 72+  0000              BankStockTable          equ 55
 73+  0000              BankCommander           equ 56
 74+  0000              BankLAYER2              equ 57
 75+  0000              BankLAYER1              equ 58
 76+  0000              BankShipModels1         equ 59
 77+  0000              BankSPRITE              equ 60
 78+  0000              BankConsole             equ 61
 79+  0000              BankFrontView           equ 62
 80+  0000              BankMenuStatus          equ 63
 81+  0000              BankMenuEquipS          equ 64
 82+  0000              BankLaunchShip          equ 65
 83+  0000              BankDispMarket          equ 66
 84+  0000              BankShipModels2         equ 67
 85+  0000              BankShipModels3         equ 68
 86+  0000              BankShipModels4         equ 69
 87+  0000
 88+  0000              BankUNIVDATA0           equ 70
 89+  0000              BankUNIVDATA1           equ 71
 90+  0000              BankUNIVDATA2           equ 72
 91+  0000              BankUNIVDATA3           equ 73
 92+  0000              BankUNIVDATA4           equ 74
 93+  0000              BankUNIVDATA5           equ 75
 94+  0000              BankUNIVDATA6           equ 76
 95+  0000              BankUNIVDATA7           equ 77
 96+  0000              BankUNIVDATA8           equ 78
 97+  0000              BankUNIVDATA9           equ 79
 98+  0000              BankUNIVDATA10          equ 80
 99+  0000              BankUNIVDATA11          equ 81
100+  0000              BankUNIVDATA12          equ 82
101+  0000              BankSunData             equ 83
102+  0000              BankPlanetData          equ 84
103+  0000
104+  0000              BankGalaxyData0         equ 91
105+  0000              BankGalaxyData1         equ 92
106+  0000              BankGalaxyData2         equ 93
107+  0000              BankGalaxyData3         equ 94
108+  0000              BankGalaxyData4         equ 95
109+  0000              BankGalaxyData5         equ 96
110+  0000              BankGalaxyData6         equ 97
111+  0000              BankGalaxyData7         equ 98
112+  0000
# file closed: ./Hardware/memory_bank_defines.asm
 35   0000                                      INCLUDE "./Hardware/screen_equates.asm"
# file opened: ./Hardware/screen_equates.asm
  1+  0000              ScreenHeight 		equ 192
  2+  0000              ScreenLastRow       equ ScreenHeight -1
  3+  0000              ScreenWidth  		equ 256
  4+  0000              ScreenLastCol       equ ScreenWidth -1
  5+  0000              ScreenHeightHalf	equ 96
  6+  0000              ScreenWidthHalf  	equ 128
  7+  0000              ScreenCenterY		equ 96
  8+  0000              ScreenCenterX       equ 128
  9+  0000              ViewHeight          equ 128
 10+  0000              ViewHeightPlus1     equ 128+1
 11+  0000              ViewLastRow       	equ ViewHeight -1
 12+  0000              ViewWidth  			equ 256
 13+  0000              ViewLastCol         equ ViewWidth -1
 14+  0000              ViewHeightHalf      equ 63
 15+  0000              ViewWidthHalf       equ 127
 16+  0000              ViewCenterY         equ 64
 17+  0000              ViewCenterX         equ 128
 18+  0000              ShipColour			equ $FF		; place holder for debugging TODO
 19+  0000              ScreenL1Bottom      equ $5000
 20+  0000              ScreenL1BottomLen   equ 32 * 8 * 8
 21+  0000              ScreenL1AttrBtm     equ $5A00
 22+  0000              ScreenL1AttrBtmLen  equ 32 * 8
 23+  0000
# file closed: ./Hardware/screen_equates.asm
 36   0000                                      INCLUDE "./Data/ShipModelEquates.asm"
# file opened: ./Data/ShipModelEquates.asm
  1+  0000              ScoopDebrisOffset	    equ	0                               ; hull byte#0 high nibble is scoop info, lower nibble is debris spin info
  2+  0000              MissileLockLoOffset	    equ 1
  3+  0000              MissileLockHiOffset	    equ 2
  4+  0000              EdgeAddyOffset		    equ 3
  5+  0000              LineX4Offset		    equ 5
  6+  0000              GunVertexOffset		    equ 6
  7+  0000              ExplosionCtOffset	    equ 7
  8+  0000              VertexCtX6Offset	    equ 8
  9+  0000              EdgeCountOffset		    equ 9
 10+  0000              BountyLoOffset		    equ 10
 11+  0000              BountyHiOffset		    equ 11
 12+  0000              FaceCtX4Offset		    equ 12
 13+  0000              DotOffset			    equ 13
 14+  0000              EnergyOffset		    equ 14
 15+  0000              SpeedOffset			    equ 15
 16+  0000              FaceAddyOffset		    equ 16
 17+  0000              QOffset				    equ 18
 18+  0000              LaserOffset			    equ 19
 19+  0000              VerticiesAddyOffset     equ 20
 20+  0000              ShipTypeOffset          equ 22
 21+  0000              ShipNewBitsOffset       equ 23
 22+  0000              ShipAIFlagsOffset       equ 24
 23+  0000              ShipDataLength          equ ShipAIFlagsOffset+1
 24+  0000
 25+  0000              CobraTablePointer       equ 43
 26+  0000              ;29 faulty
 27+  0000              BankThreshold           equ 16
 28+  0000
 29+  0000              ShipTableALast          equ 23
 30+  0000              ShipTableBLast          equ 39
 31+  0000              ShipTableCLast          equ 55
 32+  0000
# file closed: ./Data/ShipModelEquates.asm
 37   0000                                      INCLUDE "./Menus/clear_screen_inline_no_double_buffer.asm"
# file opened: ./Menus/clear_screen_inline_no_double_buffer.asm
  1+  0000              InitNoDoubleBuffer:         MACRO
  2+  0000 ~                                        MMUSelectLayer1
  3+  0000 ~                                        call	l1_cls
  4+  0000 ~                                        ld		a,7
  5+  0000 ~                                        call	l1_attr_cls_to_a
  6+  0000 ~                                        MMUSelectLayer2
  7+  0000 ~                                        call    asm_l2_double_buffer_off
  8+  0000 ~                                        call	l2_cls	; Get some space
  9+  0000 ~                                        MMUSelectSpriteBank
 10+  0000 ~                                        call    sprite_cls_cursors
 11+  0000                                          ENDM
 12+  0000
 13+  0000
# file closed: ./Menus/clear_screen_inline_no_double_buffer.asm
 38   0000                                      INCLUDE "./Macros/graphicsMacros.asm"
# file opened: ./Macros/graphicsMacros.asm
  1+  0000              ; General Graphics macros
  2+  0000              DoubleBufferIfPossible: MACRO
  3+  0000 ~                                    IFDEF DOUBLEBUFFER
  4+  0000 ~                                        MMUSelectLayer2
  5+  0000 ~                                        call  l2_cls
  6+  0000 ~                                        call  l2_flip_buffers
  7+  0000 ~                                    ENDIF
  8+  0000                                      ENDM
# file closed: ./Macros/graphicsMacros.asm
 39   0000                                      INCLUDE "./Macros/callMacros.asm"
# file opened: ./Macros/callMacros.asm
  1+  0000
  2+  0000              CallIfAGTENusng:        MACRO   reg,target
  3+  0000 ~                                    cp      reg
  4+  0000 ~                                    call	nc,target
  5+  0000                                      ENDM
  6+  0000
  7+  0000              CallIfAGTEMemusng:      MACRO   reg,target
  8+  0000 ~                                    ld      hl,reg
  9+  0000 ~                                    cp      (hl)
 10+  0000 ~                                    call	nc,target
 11+  0000                                      ENDM
 12+  0000
 13+  0000              CallIfALTNusng:         MACRO   reg,target
 14+  0000 ~                                    cp      reg
 15+  0000 ~                                    call	c,target
 16+  0000                                      ENDM
 17+  0000
 18+  0000              CallIfMemEqMemusng:     MACRO mem, address, target
 19+  0000 ~                                    ld   a,(mem)
 20+  0000 ~                                    ld   hl,address
 21+  0000 ~                                    cp   (hl)
 22+  0000 ~                                    call    z,target
 23+  0000                                      ENDM
 24+  0000
 25+  0000              CallIfMemTrue:          MACRO mem, target
 26+  0000 ~                                    ld      a,(mem)
 27+  0000 ~                                    and     a
 28+  0000 ~                                    call    z, target
 29+  0000                                      ENDM
 30+  0000
 31+  0000              CallIfMemFalse:         MACRO mem, target
 32+  0000 ~                                    ld      a,(mem)
 33+  0000 ~                                    and     a
 34+  0000 ~                                    call    nz, target
 35+  0000                                      ENDM
 36+  0000
 37+  0000              CallIfATrue:            MACRO target
 38+  0000 ~                                    and     a
 39+  0000 ~                                    call    z, target
 40+  0000                                      ENDM
 41+  0000
 42+  0000              CallIfAFalse:           MACRO target
 43+  0000 ~                                    and     a
 44+  0000 ~                                    call    nz, target
 45+  0000                                      ENDM
# file closed: ./Macros/callMacros.asm
 40   0000                                      INCLUDE "./Macros/carryFlagMacros.asm"
# file opened: ./Macros/carryFlagMacros.asm
  1+  0000
  2+  0000              SetCarryFlag:           MACRO
  3+  0000 ~                                    scf
  4+  0000                                      ENDM
  5+  0000
  6+  0000              ClearCarryFlag:	        MACRO
  7+  0000 ~                                    or a
  8+  0000                                      ENDM
  9+  0000
 10+  0000              FlipCarryFlag:          MACRO
 11+  0000 ~                                    ccf
 12+  0000                                      ENDM
 13+  0000
# file closed: ./Macros/carryFlagMacros.asm
 41   0000                                      INCLUDE "./Macros/CopyByteMacros.asm"
# file opened: ./Macros/CopyByteMacros.asm
  1+  0000              CopyByteAtHLixToA:		MACRO memloc
  2+  0000 ~            						ex          de,hl                               ; save hl
  3+  0000 ~            						ld          hl,memloc
  4+  0000 ~            						add         hl,a
  5+  0000 ~            						ld          a,(hl)                              ; get XX2[x]
  6+  0000 ~            						ex          de,hl                               ; get hl back as we need it in loop
  7+  0000              						ENDM
  8+  0000
  9+  0000              ; Increments IYL
 10+  0000              ; Increments IHL
 11+  0000              ; Gets value at hl and loads into Parameter 1 address
 12+  0000
 13+  0000              CopyByteAtNextHLiyl: 	MACRO memloc
 14+  0000 ~            						inc         iyl                                 ;
 15+  0000 ~            						inc         hl                                  ; vertex byte#1
 16+  0000 ~            						ld          a,(hl)                              ;
 17+  0000 ~            						ld          (memloc),a                     ; XX15+2 = (V),Y
 18+  0000              						ENDM
 19+  0000
 20+  0000              ;------------------------------------------------------------------------------------------------------------------------------
 21+  0000              CopyByteAtNextHL:   MACRO targetaddr
 22+  0000 ~                                inc         hl                                  ; vertex byte#1
 23+  0000 ~                                ld          a,(hl)                              ;
 24+  0000 ~                                ld          (targetaddr),a                     ; SunXX15+2 = (V),Y
 25+  0000                                  ENDM
# file closed: ./Macros/CopyByteMacros.asm
 42   0000                                      INCLUDE "./Macros/ldCopyMacros.asm"
# file opened: ./Macros/ldCopyMacros.asm
  1+  0000              ZeroA:		            MACRO
  2+  0000 ~                                    xor a
  3+  0000                                      ENDM
  4+  0000
  5+  0000              SetATrue:               MACRO
  6+  0000 ~                                    xor     a
  7+  0000                                      ENDM
  8+  0000
  9+  0000              SetAFalse:              MACRO
 10+  0000 ~                                    ld      a,$FF
 11+  0000                                      ENDM
 12+  0000
 13+  0000              SetMemFalse             MACRO   mem
 14+  0000 ~                                    ld      a,$FF
 15+  0000 ~                                    ld      (mem),a
 16+  0000                                      ENDM
 17+  0000
 18+  0000              SetMemTrue              MACRO   mem
 19+  0000 ~                                    xor     a
 20+  0000 ~                                    ld      (mem),a
 21+  0000                                      ENDM
 22+  0000
 23+  0000              SetMemToN:              MACRO   mem,value
 24+  0000 ~                                    ld      a,value
 25+  0000 ~                                    ld      (mem),a
 26+  0000                                      ENDM
 27+  0000
 28+  0000              ldCopyTextAtHLtoDE:     MACRO
 29+  0000 ~            .CopyLoop:              ld      a,(hl)
 30+  0000 ~                                    ld      (de),a
 31+  0000 ~                                    cp      0
 32+  0000 ~                                    jp      z,.DoneCopy
 33+  0000 ~                                    inc     hl
 34+  0000 ~                                    inc     de
 35+  0000 ~                                    jr      .CopyLoop
 36+  0000 ~            .DoneCopy:
 37+  0000                                      ENDM
 38+  0000
 39+  0000              ldClearTextLoop:        MACRO   TextSize
 40+  0000 ~                                    ld      b,a
 41+  0000 ~                                    ld      a,TextSize
 42+  0000 ~            .ClearLoop:             ld      (hl),a
 43+  0000 ~                                    inc     hl
 44+  0000 ~                                    djnz    .ClearLoop
 45+  0000                                      ENDM
 46+  0000
 47+  0000              ldCopyByte:             MACRO memfrom, memto
 48+  0000 ~                                    ld       a,(memfrom)
 49+  0000 ~                                    ld       (memto),a
 50+  0000                                      ENDM
 51+  0000
 52+  0000
 53+  0000              ldCopyByteABS:          MACRO memfrom, memto
 54+  0000 ~                                    ld       a,(memfrom)
 55+  0000 ~                                    and		$7F
 56+  0000 ~                                    ld       (memto),a
 57+  0000                                      ENDM
 58+  0000
 59+  0000              ldCopy2Byte             MACRO  memfrom, memto
 60+  0000 ~                                    ld       hl,(memfrom)
 61+  0000 ~                                    ld       (memto),hl
 62+  0000                                      ENDM
 63+  0000
 64+  0000              ldWriteConst            MACRO  memfrom, memto
 65+  0000 ~                                    ld       a,memfrom
 66+  0000 ~                                    ld       (memto),a
 67+  0000                                      ENDM
 68+  0000
 69+  0000              ldWriteZero             MACRO  memto
 70+  0000 ~                                    xor      a
 71+  0000 ~                                    ld       (memto),a
 72+  0000                                      ENDM
 73+  0000
 74+  0000              ldIXLaFromN:	        MACRO memfrom
 75+  0000 ~                                    ld		a,(memfrom)
 76+  0000 ~                                    ld		ixl,a
 77+  0000                                      ENDM
 78+  0000
 79+  0000              ldIXHaFromN:	        MACRO memfrom
 80+  0000 ~                                    ld		a,(memfrom)
 81+  0000 ~                                    ld		ixh,a
 82+  0000                                      ENDM
 83+  0000
 84+  0000              ldIYLaFromN:	        MACRO memfrom
 85+  0000 ~                                    ld		a,(memfrom)
 86+  0000 ~                                    ld		iyl,a
 87+  0000                                      ENDM
 88+  0000
 89+  0000              ldIYHaFromN:	        MACRO memfrom
 90+  0000 ~                                    ld		a,(memfrom)
 91+  0000 ~                                    ld		iyh,a
 92+  0000                                      ENDM
 93+  0000
 94+  0000              ldhlde:			        MACRO
 95+  0000 ~                                    ld		h,d
 96+  0000 ~                                    ld		l,e
 97+  0000                                      ENDM
 98+  0000
 99+  0000              ldhlbc:			        MACRO
100+  0000 ~                                    ld		h,b
101+  0000 ~                                    ld		l,c
102+  0000                                      ENDM
103+  0000
104+  0000              ldbcde:			        MACRO
105+  0000 ~                                    ld		b,d
106+  0000 ~                                    ld		c,e
107+  0000                                      ENDM
108+  0000
109+  0000              lddebc:			        MACRO
110+  0000 ~                                    ld		d,b
111+  0000 ~                                    ld		e,c
112+  0000                                      ENDM
113+  0000
114+  0000              ldbchl:			        MACRO
115+  0000 ~                                    ld		b,h
116+  0000 ~                                    ld		c,l
117+  0000                                      ENDM
118+  0000
119+  0000              lddeiy:			        MACRO
120+  0000 ~                                    ld		d,iyh
121+  0000 ~                                    ld		e,iyl
122+  0000                                      ENDM
123+  0000
124+  0000              ldiyde:			        MACRO
125+  0000 ~                                    ld		iyh,d
126+  0000 ~                                    ld		iyl,e
127+  0000                                      ENDM
128+  0000
129+  0000
130+  0000              FourLDIInstrunctions:   MACRO
131+  0000 ~                                    ldi
132+  0000 ~                                    ldi
133+  0000 ~                                    ldi
134+  0000 ~                                    ldi
135+  0000                                      ENDM
136+  0000
137+  0000              FiveLDIInstrunctions:   MACRO
138+  0000 ~                                    ldi
139+  0000 ~                                    ldi
140+  0000 ~                                    ldi
141+  0000 ~                                    ldi
142+  0000 ~                                    ldi
143+  0000                                      ENDM
144+  0000
145+  0000              SixLDIInstrunctions:    MACRO
146+  0000 ~                                    ldi
147+  0000 ~                                    ldi
148+  0000 ~                                    ldi
149+  0000 ~                                    ldi
150+  0000 ~                                    ldi
151+  0000 ~                                    ldi
152+  0000                                      ENDM
153+  0000
154+  0000              EightLDIInstrunctions:  MACRO
155+  0000 ~            		                ldi
156+  0000 ~            		                ldi
157+  0000 ~            		                ldi
158+  0000 ~            		                ldi
159+  0000 ~            		                ldi
160+  0000 ~            		                ldi
161+  0000 ~            		                ldi
162+  0000 ~            		                ldi
163+  0000                                      ENDM
164+  0000
165+  0000              NineLDIInstrunctions:  MACRO
166+  0000 ~            		                ldi
167+  0000 ~            		                ldi
168+  0000 ~            		                ldi
169+  0000 ~            		                ldi
170+  0000 ~            		                ldi
171+  0000 ~            		                ldi
172+  0000 ~            		                ldi
173+  0000 ~            		                ldi
174+  0000 ~            		                ldi
175+  0000                                      ENDM
# file closed: ./Macros/ldCopyMacros.asm
 43   0000                                      INCLUDE "./Macros/ldIndexedMacros.asm"
# file opened: ./Macros/ldIndexedMacros.asm
  1+  0000              GetByteAInTable:    MACRO table
  2+  0000 ~                                ld          hl,table
  3+  0000 ~                                add         hl,a
  4+  0000 ~                                ld          a,(hl)
  5+  0000                                  ENDM
  6+  0000
  7+  0000              HLWordAInTable:     MACRO table
  8+  0000 ~                                ld          hl,table
  9+  0000 ~                                sla         a
 10+  0000 ~                                add         hl,a
 11+  0000 ~                                ld          a,(hl)
 12+  0000 ~                                inc         hl
 13+  0000 ~                                ld          h,(hl)
 14+  0000 ~                                ld          l,a
 15+  0000                                  ENDM
 16+  0000
 17+  0000
 18+  0000              ldAToHLixl:			MACRO value
 19+  0000 ~            					ld          hl,value
 20+  0000 ~            					ex          af,af'
 21+  0000 ~            					ld          a,ixl
 22+  0000 ~            					add         hl,a
 23+  0000 ~            					ex          af,af'
 24+  0000 ~            					ld          (hl),a
 25+  0000              					ENDM
 26+  0000
 27+  0000              ldAToHLiyl:			MACRO value
 28+  0000 ~            					ld          hl,value
 29+  0000 ~            					ex          af,af'
 30+  0000 ~            					ld          a,iyl
 31+  0000 ~            					add         hl,a
 32+  0000 ~            					ex          af,af'
 33+  0000 ~            					ld          (hl),a
 34+  0000              					ENDM
 35+  0000
 36+  0000
 37+  0000              ldHLixlToA:         MACRO value
 38+  0000 ~                                ld          hl,value
 39+  0000 ~                                ex          af,af'
 40+  0000 ~                                ld          a,ixl
 41+  0000 ~                                add         hl,a
 42+  0000 ~                                ld          a,(hl)
 43+  0000                                  ENDM
 44+  0000
 45+  0000              ldHLiylToA:         MACRO value
 46+  0000 ~                                ld          hl,value
 47+  0000 ~                                ex          af,af'
 48+  0000 ~                                ld          a,iyl
 49+  0000 ~                                add         hl,a
 50+  0000 ~                                ld          a,(hl)
 51+  0000                                  ENDM
 52+  0000
 53+  0000              ldHLIdxAToA:        MACRO value
 54+  0000 ~                                ld          hl,value
 55+  0000 ~                                add         hl,a
 56+  0000 ~                                ld          a,(hl)
 57+  0000                                  ENDM
 58+  0000
 59+  0000              HLEquAddrAtHLPlusA: MACRO
 60+  0000 ~                                sla         a
 61+  0000 ~                                add         hl,a
 62+  0000 ~                                ld          a,(hl)
 63+  0000 ~                                inc         hl
 64+  0000 ~                                ld          h,(hl)
 65+  0000 ~                                ld          l,a
 66+  0000                                  ENDM
# file closed: ./Macros/ldIndexedMacros.asm
 44   0000                                      INCLUDE "./Macros/jumpMacros.asm"
# file opened: ./Macros/jumpMacros.asm
  1+  0000              JumpIfPositive:	        MACRO target
  2+  0000 ~                                    jp		p, target
  3+  0000                                      ENDM
  4+  0000
  5+  0000              JumpIfNegative:	        MACRO target
  6+  0000 ~                                    jp		m, target
  7+  0000                                      ENDM
  8+  0000
  9+  0000
 10+  0000              JumpIfUnderflow:	    MACRO target
 11+  0000 ~                                    jp		po, target
 12+  0000                                      ENDM
 13+  0000
 14+  0000              JumpIfOverflow:	        MACRO target
 15+  0000 ~                                    jp		po, target
 16+  0000                                      ENDM
 17+  0000
 18+  0000
 19+  0000              JumpIfNotZero:	        MACRO target
 20+  0000 ~                                    jp	nz,target
 21+  0000                                      ENDM
 22+  0000
 23+  0000              JumpIfZero:	            MACRO target
 24+  0000 ~                                    jp	z,target
 25+  0000                                      ENDM
 26+  0000
 27+  0000              ;.. Bit routines
 28+  0000              JumpOnMemBitSet:        MACRO mem, bitnbr, target
 29+  0000 ~                                    ld      a,(mem)
 30+  0000 ~                                    bit 	bitnbr,a
 31+  0000 ~                                    jp      nz,target
 32+  0000                                      ENDM
 33+  0000
 34+  0000              JumpOnMemBitClear:      MACRO mem, bitnbr, target
 35+  0000 ~                                    ld      a,(mem)
 36+  0000 ~                                    bit 	bitnbr,a
 37+  0000 ~                                    jp      z,target
 38+  0000                                      ENDM
 39+  0000
 40+  0000              JumpOnABit5Set:         MACRO   target
 41+  0000 ~                                    and     Bit5Only
 42+  0000 ~                                    jp      nz,target
 43+  0000                                      ENDM
 44+  0000
 45+  0000              JumpOnABit5Clear:       MACRO   target
 46+  0000 ~                                    and     Bit5Only
 47+  0000 ~                                    jp      z,target
 48+  0000                                      ENDM
 49+  0000
 50+  0000              JumpOnBitMaskSet:       MACRO   bitmask, target
 51+  0000 ~                                    and     bitmask
 52+  0000 ~                                    jp      nz,target
 53+  0000                                      ENDM
 54+  0000
 55+  0000              JumpOnBitMaskClear:     MACRO   bitmask, target
 56+  0000 ~                                    and     bitmask
 57+  0000 ~                                    jp      z,target
 58+  0000                                      ENDM
 59+  0000
 60+  0000              JumpOnBitSet:           MACRO  reg, bitnbr, target
 61+  0000 ~                                    bit 	bitnbr,reg
 62+  0000 ~                                    jp      nz,target
 63+  0000                                      ENDM
 64+  0000
 65+  0000              JumpOnBitClear:         MACRO  reg, bitnbr, target
 66+  0000 ~                                    bit 	bitnbr,reg
 67+  0000 ~                                    jp      z,target
 68+  0000                                      ENDM
 69+  0000
 70+  0000              ; Comparison Routines
 71+  0000              JumpIfAGTEusng:         MACRO
 72+  0000 ~                                    jp		nc,target
 73+  0000                                      ENDM
 74+  0000
 75+  0000              JumpIfAGTENusng:        MACRO reg,target
 76+  0000 ~                                    cp     reg
 77+  0000 ~                                    jp		nc,target
 78+  0000                                      ENDM
 79+  0000
 80+  0000              JumpIfAGTEMemusng:      MACRO mem,target
 81+  0000 ~                                    ld      hl,mem
 82+  0000 ~                                    cp      (hl)
 83+  0000 ~                                    jp		nc,target
 84+  0000                                      ENDM
 85+  0000
 86+  0000              JumpIfALTMemusng:       MACRO mem,target
 87+  0000 ~                                    ld      hl,mem
 88+  0000 ~                                    cp      (hl)
 89+  0000 ~                                    jp		c,target
 90+  0000                                      ENDM
 91+  0000
 92+  0000              JumpIfMemGTENusng:      MACRO mem, value, target
 93+  0000 ~                                    ld     a,(mem)
 94+  0000 ~                                    cp     value
 95+  0000 ~                                    jp	  nc,target
 96+  0000                                      ENDM
 97+  0000
 98+  0000              JumpIfMemGTEMemusng:    MACRO mem, address, target
 99+  0000 ~                                    ld   a,(mem)
100+  0000 ~                                    ld   hl,address
101+  0000 ~                                    cp   (hl)
102+  0000 ~                                    jp	  nc,target
103+  0000                                      ENDM
104+  0000
105+  0000              JumpIfMemEqMemusng:     MACRO mem, address, target
106+  0000 ~                                    ld   a,(mem)
107+  0000 ~                                    ld   hl,address
108+  0000 ~                                    cp   (hl)
109+  0000 ~                                    jp	  z,target
110+  0000                                      ENDM
111+  0000
112+  0000              JumpIfMemTrue:          MACRO mem, target
113+  0000 ~                                    ld      a,(mem)
114+  0000 ~                                    and     a
115+  0000 ~                                    jp      z, target
116+  0000                                      ENDM
117+  0000
118+  0000              JumpIfMemFalse:         MACRO mem, target
119+  0000 ~                                    ld      a,(mem)
120+  0000 ~                                    and     a
121+  0000 ~                                    jp      nz, target
122+  0000                                      ENDM
123+  0000
124+  0000              JumpIfATrue:            MACRO target
125+  0000 ~                                    and     a
126+  0000 ~                                    jp      z, target
127+  0000                                      ENDM
128+  0000
129+  0000              JumpIfAFalse:           MACRO target
130+  0000 ~                                    and     a
131+  0000 ~                                    jp      nz, target
132+  0000                                      ENDM
133+  0000
134+  0000              JumpIfALTusng:          MACRO target
135+  0000 ~                                    jp		c,target
136+  0000                                      ENDM
137+  0000
138+  0000              JumpIfALTNusng:         MACRO value, target
139+  0000 ~                                    cp      value
140+  0000 ~                                    jp		c, target
141+  0000                                      ENDM
142+  0000
143+  0000              JumpIfMemLTNusng:       MACRO mem, value, target
144+  0000 ~                                    ld      a,(mem)
145+  0000 ~                                    cp      value
146+  0000 ~                                    jp	  c,target
147+  0000                                      ENDM
148+  0000
149+  0000              JumpIfMemLTMemusng:     MACRO mem, value, target
150+  0000 ~                                    ld    a,(mem)
151+  0000 ~                                    ld    hl,value
152+  0000 ~                                    cp    (hl)
153+  0000 ~                                    jp	  c,target
154+  0000                                      ENDM
155+  0000
156+  0000              JumpIfMemEqNusng:       MACRO mem,value,target
157+  0000 ~                                    ld  a,(mem)
158+  0000 ~                                    cp  value
159+  0000 ~                                    jp  z,target
160+  0000                                      ENDM
161+  0000
162+  0000              JumpIfMemNeNusng:       MACRO mem,value,target
163+  0000 ~                                    ld  a,(mem)
164+  0000 ~                                    cp  value
165+  0000 ~                                    jp  nz,target
166+  0000                                      ENDM
167+  0000
168+  0000              JumpIfMemZero:          MACRO mem,target
169+  0000 ~                                    ld  a,(mem)
170+  0000 ~                                    and a
171+  0000 ~                                    jp  z,target
172+  0000                                      ENDM
173+  0000
174+  0000              JumpIfMemNotZero:       MACRO mem,target
175+  0000 ~                                    ld  a,(mem)
176+  0000 ~                                    and a
177+  0000 ~                                    jp  nz,target
178+  0000                                      ENDM
179+  0000
180+  0000              JumpIfALTMemHLusng:     MACRO target
181+  0000 ~                                    cp    (hl)
182+  0000 ~                                    jp	  c,target
183+  0000                                      ENDM
184+  0000
185+  0000              JumpIfANENusng:         MACRO value, target
186+  0000 ~                                    cp     value
187+  0000 ~                                    jp      nz,target
188+  0000                                      ENDM
189+  0000
190+  0000              JumpIfANEMemusng:       MACRO  value, target
191+  0000 ~                                    ld    hl,value
192+  0000 ~                                    cp    (hl)
193+  0000 ~                                    jp      nz,target
194+  0000                                      ENDM
195+  0000
196+  0000              JumpIfAEqNusng:         MACRO value, target
197+  0000 ~                                    cp     value
198+  0000 ~                                    jp      z,target
199+  0000                                      ENDM
200+  0000
201+  0000              JumpIfAIsZero:	        MACRO target
202+  0000 ~                                    and a   ; cp 0 - changed to and a for optimisation but affects other flags
203+  0000 ~                                    jp	z, target
204+  0000                                      ENDM
205+  0000
206+  0000              JumpIfAIsNotZero:       MACRO target
207+  0000 ~                                    cp	0
208+  0000 ~                                    jp	nz,target
209+  0000                                      ENDM
210+  0000
211+  0000              IfResultZeroGoto:	    MACRO target
212+  0000 ~                                    jp	z,target
213+  0000                                      ENDM
214+  0000
215+  0000              IfResultNotZeroGoto:    MACRO target
216+  0000 ~                                    jp	nz,target
217+  0000                                      ENDM
218+  0000
# file closed: ./Macros/jumpMacros.asm
 45   0000                                      INCLUDE "./Macros/MathsMacros.asm"
# file opened: ./Macros/MathsMacros.asm
  1+  0000
  2+  0000
  3+  0000              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
  4+  0000 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
  5+  0000 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
  6+  0000 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
  7+  0000 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
  8+  0000 ~                                    xor $80                             ;
  9+  0000 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
 10+  0000 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
 11+  0000 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
 12+  0000 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
 13+  0000 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
 14+  0000 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
 15+  0000                                      ENDM
 16+  0000
 17+  0000              SignedHLTo2C:           MACRO
 18+  0000 ~                                    bit     7,h
 19+  0000 ~                                    jr      z,.Done2c
 20+  0000 ~                                    ld      a,h
 21+  0000 ~                                    and     SignMask8Bit
 22+  0000 ~                                    ld      h,a
 23+  0000 ~                                    NegHL
 24+  0000 ~            .Done2c:
 25+  0000                                      ENDM
 26+  0000
 27+  0000              MemSignedTo2C:          MACRO   memfrom
 28+  0000 ~                                    ld      hl,(memfrom)
 29+  0000 ~                                    bit     7,h
 30+  0000 ~                                    jr      z,.Done2c
 31+  0000 ~                                    ld      a,h
 32+  0000 ~                                    and     SignMask8Bit
 33+  0000 ~                                    ld      h,a
 34+  0000 ~            .Done2c:                ld      (memfrom),hl
 35+  0000                                      ENDM
 36+  0000
 37+  0000
 38+  0000                  ;returns result in H
 39+  0000              EDiv10Inline:           MACRO
 40+  0000 ~                                    ld      d,0
 41+  0000 ~                                    ld      hl,de
 42+  0000 ~                                    add     hl,hl
 43+  0000 ~                                    add     hl,de
 44+  0000 ~                                    add     hl,hl
 45+  0000 ~                                    add     hl,hl
 46+  0000 ~                                    add     hl,de
 47+  0000 ~                                    add     hl,hl
 48+  0000                                      ENDM
 49+  0000
# file closed: ./Macros/MathsMacros.asm
 46   0000                                      INCLUDE "./Macros/MMUMacros.asm"
# file opened: ./Macros/MMUMacros.asm
  1+  0000              MMUSelectSpriteBank: MACRO
  2+  0000 ~            					 nextreg SpritememMMU,	    BankSPRITE
  3+  0000              					 ENDM
  4+  0000
  5+  0000              MMUSelectConsoleBank: MACRO
  6+  0000 ~            					 nextreg ConsoleImageDataMMU,  BankConsole
  7+  0000              					 ENDM
  8+  0000
  9+  0000              MMUSelectLayer1: 	 MACRO
 10+  0000 ~            					 nextreg L1memMMU,		    BankLAYER1
 11+  0000              					 ENDM
 12+  0000
 13+  0000              MMUSelectLayer2: 	 MACRO
 14+  0000 ~            					 nextreg L2memMMU,		    BankLAYER2
 15+  0000              					 ENDM
 16+  0000
 17+  0000              MMUSelectResetUniv:  MACRO
 18+  0000 ~                                 nextreg  ResetUniverseMMU, BankResetUniv
 19+  0000                                   ENDM
 20+  0000
 21+  0000              MMUSelectShipBank1:  MACRO
 22+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModels1
 23+  0000              					 ENDM
 24+  0000              MMUSelectShipBank2:  MACRO
 25+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModels2
 26+  0000              					 ENDM
 27+  0000              MMUSelectShipBank3:  MACRO
 28+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModels3
 29+  0000              					 ENDM
 30+  0000              MMUSelectShipBank4:  MACRO
 31+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModels4
 32+  0000              					 ENDM
 33+  0000
 34+  0000              MMUSelectShipBankA   MACRO
 35+  0000 ~            					 nextreg ShipModelMMU,	    a
 36+  0000              					 ENDM
 37+  0000
 38+  0000              MMUSelectShipBankN:  MACRO value
 39+  0000 ~            					 nextreg ShipModelMMU,	    value
 40+  0000              					 ENDM
 41+  0000
 42+  0000              MMUSelectCommander:	 MACRO
 43+  0000 ~                                 nextreg CommanderMMU,       BankCommander
 44+  0000              					 ENDM
 45+  0000
 46+  0000              MMUSelectStockTable: MACRO
 47+  0000 ~                                 nextreg StockTableMMU,     BankStockTable
 48+  0000              					 ENDM
 49+  0000
 50+  0000              MMUSelectCpySrcA:    MACRO
 51+  0000 ~                                 nextreg DMACpySourceMMU,	a
 52+  0000              					 ENDM
 53+  0000
 54+  0000              MMUSelectCpySrcN:    MACRO value
 55+  0000 ~                                 nextreg DMACpySourceMMU,	value
 56+  0000              					 ENDM
 57+  0000
 58+  0000              MMUSelectSun:        MACRO
 59+  0000 ~                                 nextreg SunMMU,            BankSunData
 60+  0000                                   ENDM
 61+  0000
 62+  0000              MMUSelectPlanet:     MACRO
 63+  0000 ~                                 nextreg PlanetMMU,         PlanetBankAddr
 64+  0000                                   ENDM
 65+  0000
 66+  0000              MMUSelectUniverseA:  MACRO
 67+  0000 ~                                 add    a,BankUNIVDATA0
 68+  0000 ~                                 nextreg UniverseMMU,       a
 69+  0000                                   ENDM
 70+  0000
 71+  0000              MMUSelectUniverseN:  MACRO value
 72+  0000 ~                                 nextreg UniverseMMU,       BankUNIVDATA0+value
 73+  0000                                   ENDM
 74+  0000
 75+  0000              MMUSelectGalaxyA:    MACRO
 76+  0000 ~                                 nextreg GalaxyDataMMU,       a
 77+  0000                                   ENDM
 78+  0000
 79+  0000              MMUSelectGalaxyN:    MACRO value
 80+  0000 ~                                 nextreg GalaxyDataMMU,     BankGalaxyData0+value
 81+  0000                                   ENDM
 82+  0000              MMUSelectGalaxyACopy:MACRO
 83+  0000 ~                                 nextreg UniverseMMU,       a
 84+  0000                                   ENDM
 85+  0000
 86+  0000              MMUSelectUniverseAbs:MACRO value
 87+  0000 ~                                 nextreg UniverseMMU,       value
 88+  0000                                   ENDM
 89+  0000
 90+  0000              MMUSelectMenuGalCht: MACRO
 91+  0000 ~                                 nextreg MenuGalChtMMU,		BankMenuGalCht
 92+  0000              					 ENDM
 93+  0000
 94+  0000              MMUSelectMenuShrCht: MACRO
 95+  0000 ~            					 nextreg MenuShrChtMMU,		BankMenuShrCht
 96+  0000              					 ENDM
 97+  0000
 98+  0000              MMUSelectMenuInvent: MACRO
 99+  0000 ~                                 nextreg MenuInventMMU,		BankMenuInvent
100+  0000              					 ENDM
101+  0000
102+  0000              MMUSelectMenuSystem: MACRO
103+  0000 ~                                 nextreg MenuSystemMMU,		BankMenuSystem
104+  0000              					 ENDM
105+  0000
106+  0000              MMUSelectMenuMarket: MACRO
107+  0000 ~                                 nextreg MenuMarketMMU,		BankMenuMarket
108+  0000              					 ENDM
109+  0000
110+  0000              MMUSelectMenuStatus: MACRO
111+  0000 ~                                 nextreg MenuStatusMMU,		BankMenuStatus
112+  0000              					 ENDM
113+  0000
114+  0000              MMUSelectViewFront:  MACRO
115+  0000 ~                                 nextreg ScreenBankMMU,		BankFrontView
116+  0000              					 ENDM
117+  0000
118+  0000              MMUSelectScreenA:    MACRO
119+  0000 ~                                 nextreg ScreenBankMMU,		a
120+  0000              					 ENDM
121+  0000
# file closed: ./Macros/MMUMacros.asm
 47   0000                                      INCLUDE "./Macros/NegateMacros.asm"
# file opened: ./Macros/NegateMacros.asm
  1+  0000
  2+  0000              NegIY:			    MACRO
  3+  0000 ~                                xor a
  4+  0000 ~                                sub iyl
  5+  0000 ~                                ld iyl,a
  6+  0000 ~                                sbc a,a
  7+  0000 ~                                sub iyh
  8+  0000 ~                                ld iyh,a
  9+  0000                                  ENDM
 10+  0000
 11+  0000              NegHL:			    MACRO
 12+  0000 ~                                xor a
 13+  0000 ~                                sub l
 14+  0000 ~                                ld l,a
 15+  0000 ~                                sbc a,a
 16+  0000 ~                                sub h
 17+  0000 ~                                ld h,a
 18+  0000                                  ENDM
 19+  0000
 20+  0000              NegDE:			    MACRO
 21+  0000 ~                                xor a
 22+  0000 ~                                sub e
 23+  0000 ~                                ld e,a
 24+  0000 ~                                sbc a,a
 25+  0000 ~                                sub d
 26+  0000 ~                                ld d,a
 27+  0000                                  ENDM
 28+  0000
 29+  0000              NegBC:			    MACRO
 30+  0000 ~                                xor a
 31+  0000 ~                                sub c
 32+  0000 ~                                ld c,a
 33+  0000 ~                                sbc a,a
 34+  0000 ~                                sub  b
 35+  0000 ~                                ld b,a
 36+  0000                                  ENDM
 37+  0000
 38+  0000              NegH                MACRO
 39+  0000 ~                                ld      a,h
 40+  0000 ~                                neg
 41+  0000 ~                                ld      h,a
 42+  0000                                  ENDM
 43+  0000
 44+  0000              NegD                MACRO
 45+  0000 ~                                ld      a,d
 46+  0000 ~                                neg
 47+  0000 ~                                ld      d,a
 48+  0000                                  ENDM
 49+  0000
 50+  0000              NegB                MACRO
 51+  0000 ~                                ld      a,b
 52+  0000 ~                                neg
 53+  0000 ~                                ld      b,a
 54+  0000                                  ENDM
 55+  0000
# file closed: ./Macros/NegateMacros.asm
 48   0000                                      INCLUDE "./Macros/returnMacros.asm"
# file opened: ./Macros/returnMacros.asm
  1+  0000              ReturnOnBitSet:         MACRO  reg, bitnbr,
  2+  0000 ~                                    bit 	bitnbr,reg
  3+  0000 ~                                    ret     nz
  4+  0000                                      ENDM
  5+  0000
  6+  0000              ReturnOnMemBitSet:      MACRO mem, bitnbr
  7+  0000 ~                                    ld   a,(mem)
  8+  0000 ~                                    bit 	bitnbr,a
  9+  0000 ~                                    ret     nz
 10+  0000                                      ENDM
 11+  0000
 12+  0000              ReturnOnBitClear:       MACRO reg, bitnbr
 13+  0000 ~                                    bit 	bitnbr,reg
 14+  0000 ~                                    ret		z
 15+  0000                                      ENDM
 16+  0000
 17+  0000              ReturnOnMemBitClear:    MACRO mem, bitnbr
 18+  0000 ~                                    ld     a,(mem)
 19+  0000 ~                                    bit 	bitnbr,a
 20+  0000 ~                                    ret		z
 21+  0000                                      ENDM
 22+  0000
 23+  0000              ReturnIfMemFalse:       MACRO   mem
 24+  0000 ~                                    ld      a,(mem)
 25+  0000 ~                                    and     a
 26+  0000 ~                                    ret     nz
 27+  0000                                      ENDM
 28+  0000
 29+  0000              ReturnIfMemTrue:        MACRO   mem
 30+  0000 ~                                    ld      a,(mem)
 31+  0000 ~                                    and     a
 32+  0000 ~                                    ret     z
 33+  0000                                      ENDM
 34+  0000
 35+  0000              ReturnIfAIsZero:        MACRO
 36+  0000 ~                                    and     a
 37+  0000 ~                                    ret     z
 38+  0000                                      ENDM
 39+  0000
 40+  0000              ReturnIfMemisZero:      MACRO mem
 41+  0000 ~                                    ld   a,(mem)
 42+  0000 ~                                    and a
 43+  0000 ~                                    ret    z
 44+  0000                                      ENDM
 45+  0000
 46+  0000              ReturnIfBitMaskClear    MACRO   bitmask
 47+  0000 ~                                    and     bitmask
 48+  0000 ~                                    ret     z
 49+  0000                                      ENDM
 50+  0000
 51+  0000              ReturnIfBitMaskSet      MACRO   bitmask
 52+  0000 ~                                    and     bitmask
 53+  0000 ~                                    ret     nz
 54+  0000                                      ENDM
 55+  0000
 56+  0000              ReturnIfMemEquN:        MACRO mem, value
 57+  0000 ~                                    ld     a,(mem)
 58+  0000 ~                                    cp     value
 59+  0000 ~                                    ret    nz
 60+  0000                                      ENDM
 61+  0000
 62+  0000              ReturnIfMemNeNusng:     MACRO mem, value
 63+  0000 ~                                    ld   a,(mem)
 64+  0000 ~                                    cp     value
 65+  0000 ~                                    ret    z
 66+  0000                                      ENDM
 67+  0000
 68+  0000              ReturnIfANotZero:       MACRO
 69+  0000 ~                                    and     a
 70+  0000 ~                                    ret     nz
 71+  0000                                      ENDM
 72+  0000
 73+  0000              ReturnIfNotZero:        MACRO
 74+  0000 ~                                    ret     nz
 75+  0000                                      ENDM
 76+  0000
 77+  0000
 78+  0000              ReturnIfNegative:       MACRO
 79+  0000 ~                                    ret     m
 80+  0000                                      ENDM
 81+  0000
 82+  0000
 83+  0000              ReturnIfMemNotZero:     MACRO mem
 84+  0000 ~                                    ld     a,(mem)
 85+  0000 ~                                    and     a
 86+  0000 ~                                    ret    nz
 87+  0000                                      ENDM
 88+  0000
 89+  0000              ReturnIfAGTEusng:       MACRO value
 90+  0000 ~                                    cp    value
 91+  0000 ~                                    ret	 nc
 92+  0000                                      ENDM
 93+  0000
 94+  0000              ReturnIfALTNusng:       MACRO value
 95+  0000 ~                                    cp    value
 96+  0000 ~                                    ret	 c
 97+  0000                                      ENDM
 98+  0000
 99+  0000              ReturnIfAGTENusng:      MACRO value
100+  0000 ~                                    cp    value
101+  0000 ~                                    ret	 nc
102+  0000                                      ENDM
103+  0000
104+  0000              ReturnIfAGTEMemusng:    MACRO value
105+  0000 ~                                    ld      hl,value
106+  0000 ~                                    cp      (hl)
107+  0000 ~                                    ret	    nc
108+  0000                                      ENDM
109+  0000
110+  0000              ReturnIfANENusng:       MACRO value
111+  0000 ~                                    cp      value
112+  0000 ~                                    ret     nz
113+  0000                                      ENDM
114+  0000
115+  0000              ReturnIfAEqNusng:       MACRO value
116+  0000 ~                                    cp      value
117+  0000 ~                                    ret     z
118+  0000                                      ENDM
119+  0000
# file closed: ./Macros/returnMacros.asm
 49   0000                                      INCLUDE "./Macros/ShiftMacros.asm"
# file opened: ./Macros/ShiftMacros.asm
  1+  0000              ShiftIYRight1: MACRO
  2+  0000 ~            			   ld 	a,iyh
  3+  0000 ~            			   srl 	a
  4+  0000 ~            			   ld	iyh,a
  5+  0000 ~            			   ld 	a,iyl
  6+  0000 ~            			   rra
  7+  0000 ~            			   ld	iyl,a
  8+  0000              			   ENDM
  9+  0000
 10+  0000              ShiftHLRight1: MACRO
 11+  0000 ~            			   srl h
 12+  0000 ~            			   rr  l
 13+  0000              			   ENDM
 14+  0000
 15+  0000              ShiftDERight1: MACRO
 16+  0000 ~            			   srl d
 17+  0000 ~            			   rr  e
 18+  0000              			   ENDM
 19+  0000
 20+  0000              ShiftBCRight1: MACRO
 21+  0000 ~            			   srl b
 22+  0000 ~            			   rr  c
 23+  0000              			   ENDM
 24+  0000
 25+  0000
 26+  0000
 27+  0000              ShiftHLDiv8:   MACRO
 28+  0000 ~            			   srl h
 29+  0000 ~            			   rr  l
 30+  0000 ~            			   srl h
 31+  0000 ~            			   rr  l
 32+  0000 ~            			   srl h
 33+  0000 ~            			   rr  l
 34+  0000              			   ENDM
 35+  0000
 36+  0000              ShiftHLLeft1:  MACRO
 37+  0000 ~            			   sla l
 38+  0000 ~            			   rl  h
 39+  0000              			   ENDM
 40+  0000
 41+  0000              ShiftDELeft1:  MACRO
 42+  0000 ~            			   sla e
 43+  0000 ~            			   rl  d
 44+  0000              			   ENDM
 45+  0000
 46+  0000
 47+  0000              RollDELeft1:   MACRO
 48+  0000 ~                           rl  e
 49+  0000 ~                           rl  d
 50+  0000                             ENDM
 51+  0000
 52+  0000              ShiftBCLeft1:  MACRO
 53+  0000 ~            			   sla c
 54+  0000 ~            			   rl  b
 55+  0000              			   ENDM
 56+  0000
 57+  0000
 58+  0000              ShiftMem16Right1:   MACRO memaddr
 59+  0000 ~                                ld    hl,(memaddr)
 60+  0000 ~                                srl   h
 61+  0000 ~                                rr    l
 62+  0000 ~                                ld    (memaddr),hl
 63+  0000                                  ENDM
 64+  0000
 65+  0000              ShiftMem8Right1:    MACRO memaddr
 66+  0000 ~                                ld      a,(memaddr)
 67+  0000 ~                                srl     a
 68+  0000 ~                                ld      (memaddr),a
 69+  0000                                  ENDM
 70+  0000
 71+  0000
 72+  0000              ShiftMem8Left1A:    MACRO memaddr
 73+  0000 ~                                ld      a,(memaddr)
 74+  0000 ~                                sla     a
 75+  0000 ~                                ld      (memaddr),a
 76+  0000                                  ENDM
 77+  0000
# file closed: ./Macros/ShiftMacros.asm
 50   0000                                      INCLUDE "./Macros/signBitMacros.asm"
# file opened: ./Macros/signBitMacros.asm
  1+  0000
  2+  0000              FlipMemSign:            MACRO mem
  3+  0000 ~                                    ld  a,(mem)
  4+  0000 ~                                    xor SignOnly8Bit
  5+  0000 ~                                    ld  (mem),a
  6+  0000                                      ENDM
  7+  0000
# file closed: ./Macros/signBitMacros.asm
 51   0000                                      INCLUDE "./Tables/message_queue_macros.asm"
# file opened: ./Tables/message_queue_macros.asm
  1+  0000
  2+  0000              AnyMessagesMacro:       MACRO   NoMessageTarget
  3+  0000 ~                                    ld      a, (MessageCount)
  4+  0000 ~                                    and     a
  5+  0000 ~                                    jr      z, NoMessageTarget
  6+  0000                                      ENDM
  7+  0000
  8+  0000              AnyHyperSpaceMacro:     MACRO   NoMessageText
  9+  0000 ~                                    ld      hl,(InnerHyperCount)
 10+  0000 ~                                    ld      a,h
 11+  0000 ~                                    or      l
 12+  0000 ~                                    jr      z, NoMessageText
 13+  0000                                      ENDM
 14+  0000
# file closed: ./Tables/message_queue_macros.asm
 52   0000                                      INCLUDE "./Variables/general_variables_macros.asm"
# file opened: ./Variables/general_variables_macros.asm
  1+  0000              ; limited to 255 character length
  2+  0000              CountLengthHL:          MACRO   Limiter
  3+  0000 ~                                    ld      de,hl
  4+  0000 ~                                    ld      bc,Limiter
  5+  0000 ~                                    xor     a
  6+  0000 ~                                    cpir
  7+  0000 ~                                    ClearCarryFlag
  8+  0000 ~                                    sbc     hl,de
  9+  0000 ~                                    ld      a,l
 10+  0000 ~                                    ret
 11+  0000                                      ENDM
 12+  0000
 13+  0000              HalfLengthHL:           MACRO
 14+  0000 ~                                    ld      b,0
 15+  0000 ~            .CountLenLoop:          ld      a,(hl)
 16+  0000 ~                                    cp      0
 17+  0000 ~                                    jr      z,.DoneCount
 18+  0000 ~                                    inc     b
 19+  0000 ~                                    inc     hl
 20+  0000 ~                                    jr      .CountLenLoop
 21+  0000 ~            .DoneCount:             ld      a,32
 22+  0000 ~                                    sub     b
 23+  0000 ~                                    sra     a
 24+  0000                                      ENDM
 25+  0000
 26+  0000              MakeInnocentMacro:		MACRO
 27+  0000 ~            						xor		a
 28+  0000 ~            						ld		(FugitiveInnocentStatus),a
 29+  0000              						ENDM
 30+  0000
 31+  0000              NoEscapePodMacro:		MACRO
 32+  0000 ~            						xor		a
 33+  0000 ~            						ld		(EscapePod),a
 34+  0000              						ENDM
 35+  0000
 36+  0000              MaxFuelLevel            EQU     70              ; 7.0 light years max
 37+  0000              MaxFuelMacro:			MACRO
 38+  0000 ~            						ld		a,MaxFuelLevel
 39+  0000 ~            						ld		(Fuel),a
 40+  0000              						ENDM
 41+  0000
 42+  0000              MaxThrottle:            MACRO
 43+  0000 ~                                    ld      a,(SHIPMAXSPEED)
 44+  0000 ~                                    ld      (DELTA),a
 45+  0000 ~                                    ld      d,a
 46+  0000 ~                                    ld      e,4
 47+  0000 ~                                    mul
 48+  0000 ~                                    ld      (DELT4Lo),de
 49+  0000                                      ENDM
 50+  0000
 51+  0000              ZeroThrottle:           MACRO
 52+  0000 ~                                    xor     a
 53+  0000 ~                                    ld      (DELTA),a
 54+  0000 ~                                    ld      (DELT4Lo),a
 55+  0000 ~                                    ld      (DELT4Lo+1),a
 56+  0000                                      ENDM
 57+  0000
 58+  0000              ZeroPitch:              MACRO
 59+  0000 ~                                    xor     a
 60+  0000 ~                                    ld      (BET2),a
 61+  0000 ~                                    ld      (BET2FLIP),a
 62+  0000 ~                                    ld      (JSTY),a
 63+  0000 ~                                    ld      (BETA),a
 64+  0000                                      ENDM
 65+  0000
 66+  0000              ZeroRoll:               MACRO
 67+  0000 ~                                    xor     a                              ; zero roll and climb
 68+  0000 ~                                    ld      (ALP2),a
 69+  0000 ~                                    ld      (ALP2FLIP),a
 70+  0000 ~                                    ld      (JSTX),a
 71+  0000 ~                                    ld      (ALPHA),a
 72+  0000                                      ENDM
 73+  0000
 74+  0000              CorrectPostJumpFuel:    MACRO
 75+  0000 ~                                    ld      a,(Fuel)
 76+  0000 ~                                    ld      hl,Distance
 77+  0000 ~                                    sub     a,(hl)
 78+  0000 ~                                    ld      (Fuel),a
 79+  0000                                      ENDM
 80+  0000
 81+  0000              AnyMissilesLeft:        MACRO
 82+  0000 ~                                    ld      a,(NbrMissiles)
 83+  0000 ~                                    and     a
 84+  0000                                      ENDM
 85+  0000
 86+  0000              SetMissileTargetA:      MACRO
 87+  0000 ~                                    ld      (MissileTarget),a
 88+  0000                                      ENDM
 89+  0000
 90+  0000              IsMissileLockedOn:      MACRO
 91+  0000 ~                                    ld      a,(MissileTarget)
 92+  0000 ~                                    cp      $FF
 93+  0000 ~                                    ret     z
 94+  0000 ~                                    ReturnIfSlotAEmpty                  ; if target slot is empty
 95+  0000 ~                                    ret                                 ; will return as nz now
 96+  0000                                      ENDM
 97+  0000
 98+  0000              ClearMissileTarget:     MACRO
 99+  0000 ~                                    xor     a                           ; Set missile target to FF
100+  0000 ~                                    dec     a
101+  0000 ~                                    ld      (MissileTarget),a
102+  0000 ~                                    SetMemFalse MissileLaunchFlag
103+  0000                                      ENDM
104+  0000
105+  0000              ClearECM:               MACRO
106+  0000 ~                                    xor     a
107+  0000 ~                                    ld      (ECMLoopA),a
108+  0000 ~                                    ld      (ECMLoopB),a
109+  0000                                      ENDM
110+  0000
111+  0000              ChargeEnergyAndShields: MACRO
112+  0000 ~                                    ld      a,$FF
113+  0000 ~                                    ld      (PlayerEnergy),a
114+  0000 ~                                    ld      (ForeShield),a
115+  0000 ~                                    ld      (AftShield),a
116+  0000                                      ENDM
117+  0000
118+  0000              CopyPresentSystemToTarget: MACRO
119+  0000 ~                                    ld      hl,(PresentSystemX)
120+  0000 ~                                    ld      (TargetSystemX),hl
121+  0000                                      ENDM
122+  0000
123+  0000              CopyTargetSystemToPresent: MACRO
124+  0000 ~                                    ld      hl,(TargetSystemX)
125+  0000 ~                                    ld      (PresentSystemX),hl
126+  0000                                      ENDM
127+  0000
128+  0000              HalveFugitiveStatus:    MACRO
129+  0000 ~                                    ld      hl,FugitiveInnocentStatus
130+  0000 ~                                    srl     (hl)
131+  0000                                      ENDM
132+  0000
133+  0000              ClearForceTransition    MACRO
134+  0000 ~                                    ld      a,$FF
135+  0000 ~                                    ld      (ScreenTransitionForced),a
136+  0000                                      ENDM
137+  0000
138+  0000              ForceTransition:        MACRO newScreen
139+  0000 ~                                    ld      a,newScreen
140+  0000 ~                                    ld      (ScreenTransitionForced), a
141+  0000                                      ENDM
142+  0000
143+  0000              SetSafeZone:            MACRO
144+  0000 ~                                    ld      a,$FF
145+  0000 ~                                    ld      (SpaceStationSafeZone),a
146+  0000                                      ENDM
147+  0000
148+  0000              ClearSafeZone:          MACRO
149+  0000 ~                                    xor     a
150+  0000 ~                                    ld      (SpaceStationSafeZone),a
151+  0000                                      ENDM
152+  0000
153+  0000              CoolLasers:             MACRO
154+  0000 ~                                    ld      a,(GunTemperature)
155+  0000 ~                                    and     a
156+  0000 ~                                    jr      z,.AlreadyCool
157+  0000 ~                                    dec     a
158+  0000 ~                                    ld      (GunTemperature),a
159+  0000 ~            .AlreadyCool:
160+  0000                                      ENDM
161+  0000
162+  0000
163+  0000              InitEventCounter:       MACRO
164+  0000 ~                                    xor     a
165+  0000 ~                                    ld      (EventCounter),a
166+  0000                                      ENDM
167+  0000
168+  0000              ClearMissJump:          MACRO
169+  0000 ~                                    xor     a
170+  0000 ~                                    ld      (MissJumpFlag),a
171+  0000                                      ENDM
172+  0000
# file closed: ./Variables/general_variables_macros.asm
 53   0000                                      INCLUDE "./Variables/UniverseSlot_macros.asm"
# file opened: ./Variables/UniverseSlot_macros.asm
  1+  0000
  2+  0000              AddJunkCount:           MACRO
  3+  0000 ~                                    ld      hl,JunkCount
  4+  0000 ~                                    inc     (hl)
  5+  0000                                      ENDM
  6+  0000
  7+  0000              SubJunkCount:           MACRO
  8+  0000 ~                                    ld      hl,JunkCount
  9+  0000 ~                                    dec     (hl)
 10+  0000                                      ENDM
 11+  0000
 12+  0000              TestRoomForJunk:        MACRO   Target
 13+  0000 ~                                    ld      a,3
 14+  0000 ~                                    JumpIfALTMemusng    JunkCount, Target
 15+  0000                                      ENDM
 16+  0000
 17+  0000              JumpIfSpaceStation:     MACRO   Target
 18+  0000 ~                                    ld      hl,UniverseSlotType
 19+  0000 ~                                    ld      a,(hl)
 20+  0000 ~                                    cp      ShipTypeStation
 21+  0000                                      ENDM
 22+  0000
 23+  0000
 24+  0000              ; Checks if slot is empty else A = ship type
 25+  0000              ReturnIfSlotAEmpty:     MACRO
 26+  0000 ~                                    ld      hl,UniverseSlotList
 27+  0000 ~                                    add     hl,a
 28+  0000 ~                                    ld      a,(hl)
 29+  0000 ~                                    inc     a
 30+  0000 ~                                    ret     z           ; if slot was ff inc would make it 0
 31+  0000 ~                                    dec     a           ; get original value back for later
 32+  0000                                      ENDM
 33+  0000
 34+  0000              JumpIfSlotAEmpty:       MACRO   Target
 35+  0000 ~                                    ld      hl,UniverseSlotList
 36+  0000 ~                                    add     hl,a
 37+  0000 ~                                    ld      a,(hl)
 38+  0000 ~                                    inc     a
 39+  0000 ~                                    jp      z,Target    ; if slot was ff inc would make it 0
 40+  0000 ~                                    dec     a           ; get original value back for later
 41+  0000                                      ENDM
 42+  0000
 43+  0000              JumpIfSlotHLEmpty:      MACRO   Target
 44+  0000 ~                                    ld      a,(hl)
 45+  0000 ~                                    and     a
 46+  0000 ~                                    jr      nz,Target
 47+  0000                                      ENDM
# file closed: ./Variables/UniverseSlot_macros.asm
 54   0000
 55   0000                                      INCLUDE "./Data/ShipIdEquates.asm"
# file opened: ./Data/ShipIdEquates.asm
  1+  0000              ShipID_Adder            EQU 00
  2+  0000              ShipID_Anaconda         EQU 01
  3+  0000              ShipID_Asp_Mk_2         EQU 02
  4+  0000              ShipID_Boa              EQU 03
  5+  0000              ShipID_CargoType5       EQU 04
  6+  0000              ShipID_Boulder          EQU 05
  7+  0000              ShipID_Asteroid         EQU 06
  8+  0000              ShipID_Bushmaster       EQU 07
  9+  0000              ShipID_Chameleon        EQU 08
 10+  0000              ShipID_CobraMk3         EQU 09
 11+  0000              ShipID_Cobra_Mk_1       EQU 10
 12+  0000              ShipID_Cobra_Mk_3_P     EQU 11
 13+  0000              ShipID_Constrictor      EQU 12
 14+  0000              ShipID_Coriolis         EQU 13
 15+  0000              ShipID_Cougar           EQU 14
 16+  0000              ShipID_Dodo             EQU 15
 17+  0000              ShipID_Dragon           EQU 16
 18+  0000              ShipID_Escape_Pod       EQU 17
 19+  0000              ShipID_Fer_De_Lance     EQU 18
 20+  0000              ShipID_Gecko            EQU 19
 21+  0000              ShipID_Ghavial          EQU 20
 22+  0000              ShipID_Iguana           EQU 21
 23+  0000              ShipID_Krait            EQU 22
 24+  0000              ShipID_Logo             EQU 23
 25+  0000              ShipID_Mamba            EQU 24
 26+  0000              ShipID_Missile          EQU 25
 27+  0000              ShipID_Monitor          EQU 26
 28+  0000              ShipID_Moray            EQU 27
 29+  0000              ShipID_Ophidian         EQU 28
 30+  0000              ShipID_Plate            EQU 29
 31+  0000              ShipID_Python           EQU 30
 32+  0000              ShipID_Python_P         EQU 31
 33+  0000              ShipID_Rock_Hermit      EQU 32
 34+  0000              ShipID_ShuttleType9     EQU 33
 35+  0000              ShipID_Shuttle_Mk_2     EQU 34
 36+  0000              ShipID_Sidewinder       EQU 35
 37+  0000              ShipID_Splinter         EQU 36
 38+  0000              ShipID_TestVector       EQU 37
 39+  0000              ShipID_Thargoid         EQU 38
 40+  0000              ShipID_Thargon          EQU 39
 41+  0000              ShipID_TransportType10  EQU 40
 42+  0000              ShipID_Viper            EQU 41
 43+  0000              ShipID_Worm             EQU 42
 44+  0000              ShipID_Rattler          EQU 43
 45+  0000
# file closed: ./Data/ShipIdEquates.asm
 56   0000
 57   0000              charactersetaddr		equ 15360
 58   0000              STEPDEBUG               equ 1
 59   0000
 60   0000
 61   0000                                      ORG         $8000
 62   8000 F3                                   di
 63   8001                                      ; "STARTUP"
 64   8001                                      MMUSelectLayer1
 64   8001 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
 65   8005 CD 80 E0                             call		l1_cls
 66   8008 3E 07                                ld			a,7
 67   800A CD 9B E0                             call		l1_attr_cls_to_a
 68   800D 3E FF                                ld          a,$FF
 69   800F CD A5 E0                             call        l1_set_border
 70   8012              Initialise:             MMUSelectLayer2
 70   8012 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 71   8016 CD D0 E0                             call 		l2_initialise
 72   8019 CD C9 E0                             call		l2_cls
 73   801C CD 8D 81                             call        init_keyboard
 74   801F CD 99 81     MainLoop:               call        scan_keyboard
 75   8022
 76   8022 CD 3E 80                             call        displayKeyStatus
 77   8025 C3 1F 80                             jp MainLoop
 78   8028
 79   8028 00 00 00...  XX20                DS 20
 80   803C
 81   803C 00           CurrentX            DB 0
 82   803D 00           CurrentY            DB 0
 83   803E
 84   803E AF           displayKeyStatus:       xor         a
 85   803F 32 3C 80                             ld          (CurrentX),a
 86   8042 21 05 81                             ld          hl,RawKeys
 87   8045 7E                                   ld          a,(hl)
 88   8046 E6 1F                                and         %00011111
 89   8048 06 05                                ld          b,5
 90   804A C5 E5        .displayLoop:           push        bc,,hl
 91   804C 1F                                   rra
 92   804D 38 20                                jr          c,.displayNoPress
 93   804F F5           .displayPress:          push        af
 94   8050 3A 3C 80                             ld          a,(CurrentX)
 95   8053 5F                                   ld          e,a
 96   8054 3A 3D 80                             ld          a,(CurrentY)
 97   8057 57                                   ld          d,a
 98   8058 3E 2A                                ld          a,'*'
 99   805A                                      MMUSelectLayer1
 99   805A ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
100   805E CD AB E0                             call        l1_print_char
101   8061 3A 3C 80                             ld          a,(CurrentX)
102   8064 C6 08                                add         a,8
103   8066 32 3C 80                             ld          (CurrentX),a
104   8069 F1                                   pop         af
105   806A E1 C1                                pop         bc,,hl
106   806C 10 DC                                djnz        .displayLoop
107   806E C9                                   ret
108   806F F5           .displayNoPress:        push        af
109   8070 3A 3C 80                             ld          a,(CurrentX)
110   8073 5F                                   ld          e,a
111   8074 3A 3D 80                             ld          a,(CurrentY)
112   8077 57                                   ld          d,a
113   8078 3E 4F                                ld          a,'O'
114   807A                                      MMUSelectLayer1
114   807A ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
115   807E CD AB E0                             call        l1_print_char
116   8081 3A 3C 80                             ld          a,(CurrentX)
117   8084 C6 08                                add         a,8
118   8086 32 3C 80                             ld          (CurrentX),a
119   8089 F1                                   pop         af
120   808A E1 C1                                pop         bc,,hl
121   808C 10 BC                                djnz        .displayLoop
122   808E C9                                   ret
123   808F              ;..................................................................................................................................
124   808F              	;call		keyboard_main_loop
125   808F
126   808F                  INCLUDE	"./Hardware/memfill_dma.asm"
# file opened: ./Hardware/memfill_dma.asm
  1+  808F
  2+  808F 00           memfillvalue		DB 0
  3+  8090 83 C3 C7 CB  memfill        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
  3+  8094 7D
  4+  8095 8F 80        memfill_astrt  		DW memfillvalue
  5+  8097 00 40        memfill_length 		DB $00,$40
  6+  8099 24 10 AD     					DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
  7+  809C 00 00        memfill_bstrt  		DB $00,$00
  8+  809E 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
  9+  80A2              memfill_cmd_len	  	EQU $ - memfill
 10+  80A2
 11+  80A2              memfill_dma:
 12+  80A2              ; "memfill_dma, hl = address to fill, a = value, de = length"
 13+  80A2              .set_fill_value:
 14+  80A2 32 8F 80     	ld 		(memfillvalue),a
 15+  80A5              .set_target:
 16+  80A5 22 9C 80     	ld		(memfill_bstrt),hl
 17+  80A8              .set_length:
 18+  80A8 ED 53 97 80  	ld		(memfill_length),de
 19+  80AC              .write_dma:
 20+  80AC 21 90 80     	ld 		hl, memfill
 21+  80AF 06 12        	ld 		b, memfill_cmd_len
 22+  80B1 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
 23+  80B3 ED B3        	otir
 24+  80B5 C9           	ret
 25+  80B6
# file closed: ./Hardware/memfill_dma.asm
127   80B6                  INCLUDE	"./Hardware/memcopy_dma.asm"
# file opened: ./Hardware/memcopy_dma.asm
  1+  80B6
  2+  80B6 83 C3 C7 CB  memcopy        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
  2+  80BA 7D
  3+  80BB 00 00        memcopy_astrt  		DB $00,$00
  4+  80BD 00 40        memcopy_length 		DB $00,$40
  5+  80BF 14 10 AD     					DB DMA_WR1_P1INC_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
  6+  80C2 00 00        memcopy_bstrt  		DB $00,$00
  7+  80C4 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
  8+  80C8              memcopy_cmd_len	  	equ $ - memcopy
  9+  80C8
 10+  80C8              memcopy_dma:
 11+  80C8              ; "memcopy_dma, hl = target address de = source address to copy, bc = length"
 12+  80C8              .set_target:
 13+  80C8 22 C2 80     	ld		(memcopy_bstrt),hl
 14+  80CB              .set_source:
 15+  80CB ED 53 BB 80  	ld		(memcopy_astrt),de
 16+  80CF              .set_length:
 17+  80CF ED 43 BD 80  	ld		(memcopy_length),bc
 18+  80D3              .write_dma:
 19+  80D3 21 B6 80     	ld 		hl, memcopy
 20+  80D6 06 12        	ld 		b, memcopy_cmd_len
 21+  80D8 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
 22+  80DA ED B3        	otir
 23+  80DC C9           	ret
 24+  80DD
# file closed: ./Hardware/memcopy_dma.asm
128   80DD                  INCLUDE "./Hardware/keyboard.asm"
# file opened: ./Hardware/keyboard.asm
  1+  80DD              ;
  2+  80DD              ; $FEFE;65278 V, C, X, Z, Caps Shifts       4  3  2  1  0
  3+  80DD              ; $FDFE;65022 G, F, D, S, A                 9  8  7  6  5
  4+  80DD              ; $FBFE;64510 T, R, E, W, Q                14 13 12 11 10
  5+  80DD              ; $F7FE;63486 5, 4, 3, 2, 1                19 18 17 16 15
  6+  80DD              ; $EFFE;61438 6, 7, 8, 9, 0                24 23 22 23 20
  7+  80DD              ; $DFFE;57342 Y, U, I, O, P                29 28 27 26 25
  8+  80DD              ; $BFFE;49150 H, J, K, L, Enter            34 33 32 31 30
  9+  80DD              ; $7FFE;32766 B, N, M, Symbol Shift, Space 39 38 37 36 35
 10+  80DD              ;
 11+  80DD              ; Keyboard
 12+  80DD              ;
 13+  80DD              ;   0      1       2       3       4       5        6       7       8       9
 14+  80DD              ;  VK_CAPS, VK_Z,  VK_X,   VK_C,   VK_V,   VK_A,    VK_S,   VK_D,   VK_F,   VK_G
 15+  80DD              ;   10     11      12      13      14      15       16      17      18      19
 16+  80DD              ;  VK_Q,   VK_W,   VK_E,   VK_R,   VK_T,   VK_1,    VK_2,   VK_3,   VK_4,   VK_5
 17+  80DD              ;   20     21      22      23      24      25       26      27      28      29
 18+  80DD              ;  VK_0    VK_9,   VK_8,   VK_7,   VK_6,   VK_P ,    VK_O,  VK_I,   VK_U,   VK_Y
 19+  80DD              ;   30     31      32      33      34      35       36      37      38      39
 20+  80DD              ; VK_ENTER VK_L,   VK_K,   VK_J,   VK_H,   VK_SPACE VK_SYM, VK_M,   VK_N,   VK_B
 21+  80DD              ;
 22+  80DD              ; Default map
 23+  80DD              ;-----------------------------------------------------------------------------------------------------------------------------------
 24+  80DD              ;   0          1           2             3              4           5           6           7           8           9
 25+  80DD              ;   VK_CAPS    VK_Z        VK_X,         VK_C,          VK_V,       VK_A        VK_S,       VK_D,       VK_F,       VK_G
 26+  80DD              ;              GameSkip                  Equip          SelLCargo   Climb       Decelerate  Recentre    FireM       HomeCursor
 27+  80DD              ;                                                                                                       Find System
 28+  80DD              ;-----------------------------------------------------------------------------------------------------------------------------------
 29+  80DD              ;   10         11          12            13             14          15          16          17          18          19
 30+  80DD              ;   VK_Q       VK_W,       VK_E,         VK_R,          VK_T,       VK_1        VK_2        VK_3        VK_4        VK_5
 31+  80DD              ;   Dive       Accelerate  ECM           UnarmMissile   TargetM     FrontV      AftV        LeftV       RightV      GalacticChart
 32+  80DD              ;-----------------------------------------------------------------------------------------------------------------------------------
 33+  80DD              ;   20         Accel       22            23             24          25          26          27          28          29
 34+  80DD              ;   VK_0       VK_9,       VK_8,         VK_7,          VK_6,       VK_P ,      VK_O,       VK_I,       VK_U,       VK_Y
 35+  80DD              ;   EscapePod  Inventory   Status        MarketPrices   LocalChart  RollRight   RolLLeft                EnergyBomb  Quit
 36+  80DD              ;   PlanetData                                                      PauseGame   SaveGame
 37+  80DD              ;-----------------------------------------------------------------------------------------------------------------------------------
 38+  80DD              ;   30         31          32            33             34          Right       36          37          EnergyBomb  39
 39+  80DD              ;   VK_ENTER   VK_L,       VK_K,         VK_J,          VK_H,       VK_SPACE    VK_SYM,     VK_M,       VK_N,       VK_B
 40+  80DD              ;              Launch                    Distance       Hyperspace  Laser                               DockComp    BuyCargo
 41+  80DD              ;              ResumeGame
 42+  80DD
 43+  80DD              ; You can read address to check keystate by address KeyboardMap + c_Pressed corresponding key. There is also an addr_ helper too
 44+  80DD
 45+  80DD              c_Pressed_Front         equ 0  * 2
 46+  80DD              c_Pressed_Aft           equ 1  * 2
 47+  80DD              c_Pressed_Left          equ 2  * 2
 48+  80DD              c_Pressed_Right         equ 3  * 2
 49+  80DD              c_Pressed_RollLeft      equ 4  * 2
 50+  80DD              c_Pressed_RollRight     equ 5  * 2
 51+  80DD              c_Pressed_Dive          equ 6  * 2
 52+  80DD              c_Pressed_Climb         equ 7  * 2
 53+  80DD              c_Pressed_Accellerate   equ 8  * 2
 54+  80DD              c_Pressed_Decellerate   equ 9  * 2
 55+  80DD              c_Pressed_FireLaser     equ 10 * 2
 56+  80DD              c_Pressed_TargetMissle  equ 11 * 2
 57+  80DD              c_Pressed_FireMissile   equ 12 * 2
 58+  80DD              c_Pressed_UnarmMissile  equ 13 * 2
 59+  80DD              c_Pressed_ECM           equ 14 * 2
 60+  80DD              c_Pressed_EnergyBomb    equ 15 * 2
 61+  80DD              c_Pressed_EscapePod     equ 16 * 2
 62+  80DD              c_Pressed_DockingComp   equ 17 * 2
 63+  80DD              c_Pressed_Hyperspace    equ 18 * 2
 64+  80DD              c_Pressed_Distance      equ 19 * 2
 65+  80DD              c_Pressed_HomeCursor    equ 20 * 2
 66+  80DD              c_Pressed_Launch        equ 21 * 2
 67+  80DD              c_Pressed_BuyCargo      equ 22 * 2
 68+  80DD              c_Pressed_SellCargo     equ 23 * 2
 69+  80DD              c_Pressed_Equip         equ 24 * 2
 70+  80DD              c_Pressed_GalacticChrt  equ 25 * 2
 71+  80DD              c_Pressed_LocalChart    equ 26 * 2
 72+  80DD              c_Pressed_MarketPrices  equ 27 * 2
 73+  80DD              c_Pressed_Status        equ 28 * 2
 74+  80DD              c_Pressed_Inventory     equ 29 * 2
 75+  80DD              c_Pressed_GameSkip      equ 30 * 2
 76+  80DD              c_Pressed_Save          equ 31 * 2
 77+  80DD              c_Pressed_Freeze        equ 32 * 2
 78+  80DD              c_Pressed_Resume        equ 33 * 2
 79+  80DD              c_Pressed_Recentre      equ 34 * 2
 80+  80DD              c_Pressed_Quit          equ 35 * 2
 81+  80DD              c_Pressed_PlanetData    equ 36 * 2
 82+  80DD              c_Pressed_CursorUp      equ 37 * 2
 83+  80DD              c_Pressed_CursorDown    equ 38 * 2
 84+  80DD              c_Pressed_Find          equ 39 * 2
 85+  80DD
 86+  80DD              ; half row 1
 87+  80DD              VK_CAPS  				equ 0
 88+  80DD              VK_Z  					equ 1
 89+  80DD              VK_X  					equ 2
 90+  80DD              VK_C  					equ 3
 91+  80DD              VK_V  					equ 4
 92+  80DD              ; half row 2
 93+  80DD              VK_A  					equ 5
 94+  80DD              VK_S  					equ 6
 95+  80DD              VK_D  					equ 7
 96+  80DD              VK_F  					equ 8
 97+  80DD              VK_G  					equ 9
 98+  80DD              ; half row 3
 99+  80DD              VK_Q  					equ 10
100+  80DD              VK_W  					equ 11
101+  80DD              VK_E  					equ 12
102+  80DD              VK_R  					equ 13
103+  80DD              VK_T  					equ 14
104+  80DD              ; half row 4
105+  80DD              VK_1  					equ 15
106+  80DD              VK_2  					equ 16
107+  80DD              VK_3  					equ 17
108+  80DD              VK_4  					equ 18
109+  80DD              VK_5  					equ 19
110+  80DD              ; half row 5
111+  80DD              VK_0 					equ 20
112+  80DD              VK_9 					equ 21
113+  80DD              VK_8 					equ 22
114+  80DD              VK_7 					equ 23
115+  80DD              VK_6 					equ 24
116+  80DD              ; half row 6
117+  80DD              VK_P  					equ 25
118+  80DD              VK_O  					equ 26
119+  80DD              VK_I  					equ 27
120+  80DD              VK_U  					equ 28
121+  80DD              VK_Y  					equ 29
122+  80DD              ; half row 7
123+  80DD              VK_ENTER 				equ 30
124+  80DD              VK_L  					equ 31
125+  80DD              VK_K  					equ 32
126+  80DD              VK_J  					equ 33
127+  80DD              VK_H  					equ 34
128+  80DD              ; half row 8
129+  80DD              VK_SPACE 				equ 35
130+  80DD              VK_SYM  				equ 36
131+  80DD              VK_M  					equ 37
132+  80DD              VK_N  					equ 38
133+  80DD              VK_B  					equ 39
134+  80DD
135+  80DD              ;KeyboardMapping
136+  80DD              KeyCode_Front        	equ VK_1
137+  80DD              KeyCode_Aft          	equ VK_2
138+  80DD              KeyCode_Left         	equ VK_3
139+  80DD              KeyCode_Right        	equ VK_4
140+  80DD              KeyCode_RollLeft     	equ VK_O
141+  80DD              KeyCode_RollRight    	equ VK_P
142+  80DD              KeyCode_Dive         	equ VK_Q
143+  80DD              KeyCode_Climb        	equ VK_A
144+  80DD              KeyCode_Accellerate  	equ VK_W
145+  80DD              KeyCode_Decellerate  	equ VK_S
146+  80DD              KeyCode_FireLaser    	equ VK_SPACE
147+  80DD              KeyCode_TargetMissle 	equ VK_T
148+  80DD              KeyCode_FireMissile  	equ VK_F
149+  80DD              KeyCode_Find        	equ VK_F
150+  80DD              KeyCode_UnarmMissile 	equ VK_R
151+  80DD              KeyCode_ECM          	equ VK_E
152+  80DD              KeyCode_EnergyBomb   	equ VK_U
153+  80DD              KeyCode_EscapePod    	equ VK_CAPS
154+  80DD              KeyCode_DockingComp  	equ VK_N
155+  80DD              KeyCode_Hyperspace   	equ VK_H
156+  80DD              KeyCode_Distance     	equ VK_J
157+  80DD              KeyCode_HomeCursor   	equ VK_G
158+  80DD              KeyCode_Launch       	equ VK_L
159+  80DD              KeyCode_BuyCargo     	equ VK_B
160+  80DD              KeyCode_SellCargo    	equ VK_V
161+  80DD              KeyCode_Equip        	equ VK_C
162+  80DD              KeyCode_GalacticChrt 	equ VK_5
163+  80DD              KeyCode_LocalChart   	equ VK_6
164+  80DD              KeyCode_MarketPrices 	equ VK_7
165+  80DD              KeyCode_Status       	equ VK_8
166+  80DD              KeyCode_Inventory    	equ VK_9
167+  80DD              KeyCode_GameSkip     	equ VK_Z
168+  80DD              KeyCode_Save         	equ VK_O
169+  80DD              KeyCode_Freeze       	equ VK_B
170+  80DD              KeyCode_Resume       	equ VK_L
171+  80DD              KeyCode_Recentre     	equ VK_D
172+  80DD              KeyCode_Quit         	equ VK_Y
173+  80DD              KeyCode_PlanetData   	equ VK_0
174+  80DD              KeyCode_CursorUp        equ VK_Q
175+  80DD              KeyCode_CursorDown      equ VK_A
176+  80DD
177+  80DD 00 00 00...  Keys					DS	40          ; This is the list of key states for all the VK keys presssed i.e. VK_CAPS through to VK_B
178+  8105              c_KeyBoardLen 			equ $ - Keys
179+  8105 00 00 00...  RawKeys					DS	8
180+  810D FE FD FB F7  KeyAddrTab				DB	$FE, $FD, $FB, $F7, $EF, $DF, $BF, $7F
180+  8111 EF DF BF 7F
181+  8115              ; Now keyboard map lists each game key and the corresponding address in the Keys table to get the value. This way redefining keys is just a case
182+  8115              ; of updating this table with the respective location to look up
183+  8115              ; key list sequence is in table above
184+  8115 EC 80 ED 80  KeyboardMap             DW  Keys+KeyCode_Front        ,Keys+KeyCode_Aft          ,Keys+KeyCode_Left         ,Keys+KeyCode_Right        ,Keys+KeyCode_RollLeft
184+  8119 EE 80 EF 80
184+  811D F7 80
185+  811F F6 80 E7 80                          DW  Keys+KeyCode_RollRight    ,Keys+KeyCode_Dive         ,Keys+KeyCode_Climb        ,Keys+KeyCode_Accellerate  ,Keys+KeyCode_Decellerate
185+  8123 E2 80 E8 80
185+  8127 E3 80
186+  8129 00 81 EB 80                          DW  Keys+KeyCode_FireLaser    ,Keys+KeyCode_TargetMissle ,Keys+KeyCode_FireMissile  ,Keys+KeyCode_UnarmMissile ,Keys+KeyCode_ECM
186+  812D E5 80 EA 80
186+  8131 E9 80
187+  8133 F9 80 DD 80                          DW  Keys+KeyCode_EnergyBomb   ,Keys+KeyCode_EscapePod    ,Keys+KeyCode_DockingComp  ,Keys+KeyCode_Hyperspace   ,Keys+KeyCode_Distance
187+  8137 03 81 FF 80
187+  813B FE 80
188+  813D E6 80 FC 80                          DW  Keys+KeyCode_HomeCursor   ,Keys+KeyCode_Launch       ,Keys+KeyCode_BuyCargo     ,Keys+KeyCode_SellCargo    ,Keys+KeyCode_Equip
188+  8141 04 81 E1 80
188+  8145 E0 80
189+  8147 F0 80 F5 80                          DW  Keys+KeyCode_GalacticChrt ,Keys+KeyCode_LocalChart   ,Keys+KeyCode_MarketPrices ,Keys+KeyCode_Status       ,Keys+KeyCode_Inventory
189+  814B F4 80 F3 80
189+  814F F2 80
190+  8151 DE 80 F7 80                          DW  Keys+KeyCode_GameSkip     ,Keys+KeyCode_Save         ,Keys+KeyCode_Freeze       ,Keys+KeyCode_Resume       ,Keys+KeyCode_Recentre
190+  8155 04 81 FC 80
190+  8159 E4 80
191+  815B FA 80 F1 80                          DW  Keys+KeyCode_Quit         ,Keys+KeyCode_PlanetData   ,Keys+KeyCode_CursorUp     ,Keys+KeyCode_CursorDown   ,Keys+KeyCode_Find
191+  815F E7 80 E2 80
191+  8163 E5 80
192+  8165
193+  8165 23 5A 58 43  ASCII_Map:              DB "#","Z","X","C","V"
193+  8169 56
194+  816A 41 53 44 46                          DB "A","S","D","F","G"
194+  816E 47
195+  816F 51 57 45 52                          DB "Q","W","E","R","T"
195+  8173 54
196+  8174 31 32 33 34                          DB "1","2","3","4","5"
196+  8178 35
197+  8179 30 39 38 37                          DB "0","9","8","7","6"
197+  817D 36
198+  817E 50 4F 49 55                          DB "P","O","I","U","Y"
198+  8182 59
199+  8183 3E 4C 4B 4A                          DB ">","L","K","J","H"
199+  8187 48
200+  8188 20 5E 4D 4E                          DB " ","^","M","N","B"
200+  818C 42
201+  818D
202+  818D              ; mapping of a code to the lookup table Keyboard map. So if you are using an addr_Pressed you can then fetch from KeyboardMap the address in Keys
203+  818D              ; for the raw key press status
204+  818D              addr_Pressed_Front         equ KeyboardMap+c_Pressed_Front
205+  818D              addr_Pressed_Aft           equ KeyboardMap+c_Pressed_Aft
206+  818D              addr_Pressed_Left          equ KeyboardMap+c_Pressed_Left
207+  818D              addr_Pressed_Right         equ KeyboardMap+c_Pressed_Right
208+  818D              addr_Pressed_RollLeft      equ KeyboardMap+c_Pressed_RollLeft
209+  818D              addr_Pressed_RollRight     equ KeyboardMap+c_Pressed_RollRight
210+  818D              addr_Pressed_Dive          equ KeyboardMap+c_Pressed_Dive
211+  818D              addr_Pressed_Climb         equ KeyboardMap+c_Pressed_Climb
212+  818D              addr_Pressed_Accellerate   equ KeyboardMap+c_Pressed_Accellerate
213+  818D              addr_Pressed_Decellerate   equ KeyboardMap+c_Pressed_Decellerate
214+  818D              addr_Pressed_FireLaser     equ KeyboardMap+c_Pressed_FireLaser
215+  818D              addr_Pressed_TargetMissle  equ KeyboardMap+c_Pressed_TargetMissle
216+  818D              addr_Pressed_FireMissile   equ KeyboardMap+c_Pressed_FireMissile
217+  818D              addr_Pressed_UnarmMissile  equ KeyboardMap+c_Pressed_UnarmMissile
218+  818D              addr_Pressed_ECM           equ KeyboardMap+c_Pressed_ECM
219+  818D              addr_Pressed_EnergyBomb    equ KeyboardMap+c_Pressed_EnergyBomb
220+  818D              addr_Pressed_EscapePod     equ KeyboardMap+c_Pressed_EscapePod
221+  818D              addr_Pressed_DockingComp   equ KeyboardMap+c_Pressed_DockingComp
222+  818D              addr_Pressed_Hyperspace    equ KeyboardMap+c_Pressed_Hyperspace
223+  818D              addr_Pressed_Distance      equ KeyboardMap+c_Pressed_Distance
224+  818D              addr_Pressed_HomeCursor    equ KeyboardMap+c_Pressed_HomeCursor
225+  818D              addr_Pressed_Launch        equ KeyboardMap+c_Pressed_Launch
226+  818D              addr_Pressed_BuyCargo      equ KeyboardMap+c_Pressed_BuyCargo
227+  818D              addr_Pressed_SellCargo     equ KeyboardMap+c_Pressed_SellCargo
228+  818D              addr_Pressed_Equip         equ KeyboardMap+c_Pressed_Equip
229+  818D              addr_Pressed_GalacticChrt  equ KeyboardMap+c_Pressed_GalacticChrt
230+  818D              addr_Pressed_LocalChart    equ KeyboardMap+c_Pressed_LocalChart
231+  818D              addr_Pressed_MarketPrices  equ KeyboardMap+c_Pressed_MarketPrices
232+  818D              addr_Pressed_Status        equ KeyboardMap+c_Pressed_Status
233+  818D              addr_Pressed_Inventory     equ KeyboardMap+c_Pressed_Inventory
234+  818D              addr_Pressed_GameSkip      equ KeyboardMap+c_Pressed_GameSkip
235+  818D              addr_Pressed_Save          equ KeyboardMap+c_Pressed_Save
236+  818D              addr_Pressed_Freeze        equ KeyboardMap+c_Pressed_Freeze
237+  818D              addr_Pressed_Resume        equ KeyboardMap+c_Pressed_Resume
238+  818D              addr_Pressed_Recentre      equ KeyboardMap+c_Pressed_Recentre
239+  818D              addr_Pressed_Quit          equ KeyboardMap+c_Pressed_Quit
240+  818D              addr_Pressed_PlanetData    equ KeyboardMap+c_Pressed_PlanetData
241+  818D              addr_Pressed_CursorUp      equ KeyboardMap+c_Pressed_CursorUp
242+  818D              addr_Pressed_CursorDown    equ KeyboardMap+c_Pressed_CursorDown
243+  818D              addr_Pressed_Find          equ KeyboardMap+c_Pressed_Find
244+  818D
245+  818D
246+  818D              MIsKeyPressed:          MACRO   keyaddress, misstarget
247+  818D ~                                    ld      hl,(keyaddress)
248+  818D ~                                    ld      a,(hl)
249+  818D ~                                    JumpIfAIsZero   misstarget
250+  818D                                      ENDM
251+  818D
252+  818D 21 DD 80     init_keyboard:          ld		hl,Keys                         ; no key s are pressed by default
253+  8190 11 28 00                             ld		de, c_KeyBoardLen               ;
254+  8193 3E 00                                ld		a,0                             ;
255+  8195 CD A2 80                             call	memfill_dma                     ;
256+  8198 C9                                   ret                                     ;
257+  8199
258+  8199
259+  8199
260+  8199 DD 21 05 81  scan_keyboard:          ld		ix,RawKeys                      ; hl = table of raw IO port readings
261+  819D 21 0D 81                             ld		hl,KeyAddrTab                   ; de = table of IO ports to read
262+  81A0 0E 08                                ld		c,8                             ; 8 ports to ready
263+  81A2 11 DD 80                             ld      de,Keys                         ; ix = table of key states from raw read
264+  81A5 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
265+  81A6 DB FE                                in		a,($FE)							; read port to a
266+  81A8 DD 77 00                             ld      (ix+0),a                        ; save raw scan
267+  81AB DD 23                                inc     ix
268+  81AD 23                                   inc		hl                              ; and ready for next read
269+  81AE 06 05        .ProcessInputBits:      ld		b,5								; loop all bits (there are only 5 keys to a group)
270+  81B0 1F           .ProcessBitsLoop:       rra                                     ; shit bit 0 into carry
271+  81B1 CB 47                                bit		0,a								; is bit set
272+  81B3 30 08                                jr      nc,.SetKeyPressed               ; low bit means it was pressed
273+  81B5 FD 6F                                ld      iyl,a
274+  81B7                                      ZeroA
274+  81B7 AF          >                        xor a
275+  81B8 C3 C3 81                             jp      .SetKey
276+  81BB 20 09                                jr		nz,.SkipKeySet
277+  81BD FD 6F        .SetKeyPressed:	        ld      iyl,a                           ; save current input byte
278+  81BF 1A                                   ld      a,(de)                          ; get current keystate
279+  81C0 3C                                   inc     a                               ; and increment by 1 as its moved from previous state
280+  81C1 E6 03                                and     %00000011                       ; up to a maximum of 3. so bit 0 set is pressed, bit 1 set is repeat pressed, i.e. bit 0 = pressed bit bit 1 = held bit
281+  81C3 12           .SetKey:                ld		(de),a				  	        ; save key Pressed state
282+  81C4 FD 7D                                ld      a,iyl                           ; and retrieve the current input byte
283+  81C6 13           .SkipKeySet:	        inc		de								; move to next key
284+  81C7 10 E7                                djnz	.ProcessBitsLoop				; Process all key group bits
285+  81C9 0D                                   dec     c                               ; thats one row of bits all processed
286+  81CA 20 D9                                jr      nz,.PortReadLoop				; Read next input port
287+  81CC C9                                   ret
288+  81CD
289+  81CD
290+  81CD
291+  81CD              GetKeyStateAddressDE:   MACRO
292+  81CD ~                                    ld      hl,KeyboardMap                  ; work our address to read from
293+  81CD ~                                    add     hl,a
294+  81CD ~                                    ld      e,(hl)
295+  81CD ~                                    inc     hl
296+  81CD ~                                    ld      d,(hl)                          ; now de = address in keypress list
297+  81CD                                      ENDM
298+  81CD
299+  81CD              GetKeyStateAddressHL:   MACRO
300+  81CD ~                                    ld      hl,KeyboardMap                  ; work our address to read from
301+  81CD ~                                    add     hl,a
302+  81CD ~                                    ld      a,(hl)
303+  81CD ~                                    inc     hl
304+  81CD ~                                    ld      h,(hl)                          ; now hl = address in keypress list
305+  81CD ~                                    ld      l,a
306+  81CD                                      ENDM
307+  81CD
308+  81CD              ; call with a = c_Pressed key, will then read mapping does this with keyboard scan, waits until key gets to state 1, if it was already held then#
309+  81CD              ; it will have to be let go to reset of 0 and scan again
310+  81CD              ; Deprecated as not used as yet
311+  81CD              ;;;;;;wait_for_key_a_press:   GetKeyStateAddressHL
312+  81CD              ;;;;;;                        push    hl
313+  81CD              ;;;;;;.wait_loop:             call    scan_keyboard
314+  81CD              ;;;;;;                        pop     hl                              ; get key address into hl
315+  81CD              ;;;;;;                        push    hl
316+  81CD              ;;;;;;                        ld      a,(hl)
317+  81CD              ;;;;;;                        JumpIfANENusng  1,.wait_loop             ; will also loop if held down when entering this routine
318+  81CD              ;;;;;;                        pop     hl                              ; tidy up rogue push, less t states than detecting if we want to push or not
319+  81CD              ;;;;;;                        ret
320+  81CD              ;;;;;;; call with a = c_Pressed key, will then read mapping does this with keyboard scan waits until key gets to state 2
321+  81CD              ;;;;;;wait_for_key_a_held:    GetKeyStateAddressDE
322+  81CD              ;;;;;;                        push    hl
323+  81CD              ;;;;;;.wait_loop:             call    scan_keyboard
324+  81CD              ;;;;;;                        pop     hl
325+  81CD              ;;;;;;                        push    hl
326+  81CD              ;;;;;;                        ld      a,(hl)
327+  81CD              ;;;;;;                        JumpIfALTNusng  2, .wait_loop
328+  81CD              ;;;;;;                        pop     hl
329+  81CD              ;;;;;;                        ret
330+  81CD
331+  81CD              ; Gets the current keystate of the c_Pressed Key in a register
332+  81CD              get_key_a_state:        GetKeyStateAddressHL                    ; reads a mapped key and sets a to key staus, e.g. 0 1 or >=2 DOES NOT SCAN KEYBOARD
332+  81CD 21 15 81    >                        ld      hl,KeyboardMap                  ; work our address to read from
332+  81D0 ED 31       >                        add     hl,a
332+  81D2 7E          >                        ld      a,(hl)
332+  81D3 23          >                        inc     hl
332+  81D4 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
332+  81D5 6F          >                        ld      l,a
333+  81D6 7E                                   ld      a,(hl)                          ; a = keystate
334+  81D7 C9                                   ret
335+  81D8
336+  81D8              ; sets they keystate of c pressed key in a register to 1 (pressed)
337+  81D8              force_key_press:        GetKeyStateAddressHL                    ; read key locations
337+  81D8 21 15 81    >                        ld      hl,KeyboardMap                  ; work our address to read from
337+  81DB ED 31       >                        add     hl,a
337+  81DD 7E          >                        ld      a,(hl)
337+  81DE 23          >                        inc     hl
337+  81DF 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
337+  81E0 6F          >                        ld      l,a
338+  81E1 3E 01                                ld      a,1
339+  81E3 77                                   ld      (hl),a
340+  81E4 C9                                   ret
341+  81E5
342+  81E5              ; returns z is set if c_ key is pressed
343+  81E5              is_key_pressed:         GetKeyStateAddressHL
343+  81E5 21 15 81    >                        ld      hl,KeyboardMap                  ; work our address to read from
343+  81E8 ED 31       >                        add     hl,a
343+  81EA 7E          >                        ld      a,(hl)
343+  81EB 23          >                        inc     hl
343+  81EC 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
343+  81ED 6F          >                        ld      l,a
344+  81EE 7E                                   ld      a,(hl)                          ; a = keystate
345+  81EF FE 01                                cp      1                               ; we cant just test bit 0 as this may have been held long
346+  81F1 C9                                   ret
347+  81F2
348+  81F2              ; returns nz is set if c_ key is held, if key was held then keystate would be 2 or 3, i.e. bit 1 set
349+  81F2              is_key_held:            GetKeyStateAddressHL
349+  81F2 21 15 81    >                        ld      hl,KeyboardMap                  ; work our address to read from
349+  81F5 ED 31       >                        add     hl,a
349+  81F7 7E          >                        ld      a,(hl)
349+  81F8 23          >                        inc     hl
349+  81F9 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
349+  81FA 6F          >                        ld      l,a
350+  81FB 7E                                   ld      a,(hl)                          ; a = keystate
351+  81FC E6 02                                and     Bit1Only                        ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
352+  81FE C9                                   ret
353+  81FF
354+  81FF              ; checks to see if any key is pressed in the key table
355+  81FF 21 DD 80     is_any_key_pressed:     ld      hl,Keys
356+  8202 01 28 00                             ld      bc,40
357+  8205 3E 01                                ld      a,1
358+  8207 ED B1                                cpir                                    ; search for the value 1
359+  8209 28 03                                jr      z,.KeyPressed                   ; if a key was pressed then handle press
360+  820B                                      SetAFalse
360+  820B 3E FF       >                        ld      a,$FF
361+  820D C9                                   ret
362+  820E 3E 28        .KeyPressed:            ld      a,40                            ; so c will be how many keys still to scan
363+  8210 91                                   sub     c                               ; so a = 40 - c to get to result
364+  8211 C9                                   ret
365+  8212
366+  8212 21 DD 80     is_any_key_held:        ld      hl,Keys
367+  8215 06 28                                ld      b,40
368+  8217 0E 00                                ld      c,0
369+  8219 7E           .KeyReadLoop:           ld      a,(hl)
370+  821A E6 02                                and     Bit1Only                        ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
371+  821C C2 26 82                             jp      nz,.KeyPressed
372+  821F 23                                   inc     hl
373+  8220 0C                                   inc     c
374+  8221 10 F6                                djnz    .KeyReadLoop
375+  8223                                      SetAFalse
375+  8223 3E FF       >                        ld      a,$FF
376+  8225 C9                                   ret
377+  8226 79           .KeyPressed:            ld      a,c
378+  8227 C9                                   ret
379+  8228
380+  8228
381+  8228 00 00 00...  InputString             DS  30              ; used for a 30 character input buffer
382+  8246 00                                   DB  0               ; end of string marker as a safety
383+  8247 00           InputCursor             DB  0
384+  8248 00           EnterPressed            DB  0               ; zero notpressed FF pressed
385+  8249 00           InputChanged            DB  0
386+  824A              InputLimit              EQU 20
387+  824A
388+  824A 21 28 82     keyboard_copy_input_to_de:  ld      hl,InputString
389+  824D 3A 47 82                                 ld      a,(InputCursor)
390+  8250 FE 00                                    cp      0
391+  8252 28 05                                    jr      z,.NoString
392+  8254 4F                                       ld      c,a
393+  8255 06 00                                    ld      b,0
394+  8257 ED B0                                    ldir
395+  8259 3E 00        .NoString                   ld      a,0
396+  825B 12                                       ld      (de),a
397+  825C C9                                       ret
398+  825D
399+  825D AF           initInputText:          xor     a
400+  825E 32 47 82                             ld      (InputCursor),a
401+  8261 32 48 82                             ld      (EnterPressed),a
402+  8264 32 49 82                             ld      (InputChanged),a
403+  8267 21 28 82                             ld      hl,InputString
404+  826A 06 1E                                ld      b,30
405+  826C 77           .wipeloop:              ld      (hl),a
406+  826D 23                                   inc     hl
407+  826E 10 FC                                djnz    .wipeloop
408+  8270 C9                                   ret
409+  8271
410+  8271 AF           InputName:              xor     a
411+  8272 32 49 82                             ld      (InputChanged),a
412+  8275 CD FF 81                             call    is_any_key_pressed
413+  8278 FE FF                                cp      $FF
414+  827A C8                                   ret     z
415+  827B 4F           .KeyPressed:            ld      c,a
416+  827C 3A 47 82                             ld      a,(InputCursor)                 ; No key so we can now look at if we are at the end of the buffer
417+  827F FE 14                                cp      InputLimit                      ; move to variable later and then cp (hl)
418+  8281 28 0B                                jr      z,.DeleteOrEnterOnly            ;
419+  8283 21 65 81                             ld      hl,ASCII_Map
420+  8286 79                                   ld      a,c
421+  8287 ED 31                                add     hl,a
422+  8289 7E                                   ld      a,(hl)
423+  828A FE 41                                cp      "A"
424+  828C 30 15                                jr      nc,.AlphaPressed
425+  828E              ; CAPS and Symbol act as delete for now
426+  828E FE 30        .DeleteOrEnterOnly      cp      "0"                             ; if 0 was preseed check caps shift too
427+  8290 28 3B                                jr      z,.CheckShiftDelete             ; for now we will ignore the shift and just assume delete
428+  8292 FE 3E                                cp      ">"         ; ENTER
429+  8294 28 24                                jr      z,.EnterPressed
430+  8296 FE 23                                cp      "#"         ; CAPS
431+  8298 28 33                                jr      z,.CapsPressed
432+  829A FE 5E                                cp      "^"         ; SYMBOLSHIFT
433+  829C 28 2F                                jr      z,.SymbolPressed
434+  829E FE 20                                cp      " "         ; space
435+  82A0 28 2B                                jr      z,.SpacePressed
436+  82A2 C9                                   ret
437+  82A3 47           .AlphaPressed:          ld      b,a
438+  82A4 3A 47 82                             ld      a,(InputCursor)
439+  82A7 4F                                   ld      c,a
440+  82A8 21 28 82                             ld      hl,InputString
441+  82AB ED 31                                add     hl,a
442+  82AD 78                                   ld      a,b
443+  82AE 70                                   ld      (hl),b
444+  82AF 79                                   ld      a,c
445+  82B0 21 47 82                             ld      hl,InputCursor
446+  82B3 34                                   inc     (hl)
447+  82B4                                      SetMemFalse InputChanged
447+  82B4 3E FF       >                        ld      a,$FF
447+  82B6 32 49 82    >                        ld      (InputChanged),a
448+  82B9 C9                                   ret
449+  82BA 3A 47 82     .EnterPressed:          ld      a,(InputCursor)
450+  82BD 3C                                   inc     a
451+  82BE 21 28 82                             ld      hl,InputString
452+  82C1 ED 31                                add     hl,a
453+  82C3 AF                                   xor     a
454+  82C4 77                                   ld      (hl),a
455+  82C5 3D                                   dec     a
456+  82C6 32 48 82                             ld      (EnterPressed),a
457+  82C9 32 49 82                             ld      (InputChanged),a
458+  82CC C9                                   ret
459+  82CD              .CheckShiftDelete:
460+  82CD              .CapsPressed:                               ; act as a delete key for now
461+  82CD              .SymbolPressed:
462+  82CD 3A 47 82     .SpacePressed:          ld      a,(InputCursor)
463+  82D0 FE 00                                cp      0
464+  82D2 C8                                   ret     z
465+  82D3 3D                                   dec     a
466+  82D4 32 47 82                             ld      (InputCursor),a
467+  82D7 21 28 82                             ld      hl,InputString
468+  82DA ED 31                                add     hl,a
469+  82DC AF                                   xor     a
470+  82DD 77                                   ld      (hl),a
471+  82DE                                      SetMemFalse InputChanged
471+  82DE 3E FF       >                        ld      a,$FF
471+  82E0 32 49 82    >                        ld      (InputChanged),a
472+  82E3 C9                                   ret
473+  82E4
474+  82E4 AF           MovementKeyTest:        xor     a
475+  82E5 32 A2 84                             ld      (CursorKeysPressed),a
476+  82E8 3A A4 84                             ld      a,(MenuIdMax)
477+  82EB E6 FC                                and     $FC
478+  82ED 20 26                                jr      nz,CursorKeys
479+  82EF 2A 23 81     ClimbDiveKeys:          ld      hl,(addr_Pressed_Climb)
480+  82F2 7E                                   ld      a,(hl)
481+  82F3                                      JumpIfAIsZero ScanDiveKey
481+  82F3 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
481+  82F4 CA 02 83    >                        jp	z, ScanDiveKey
482+  82F7 3A A2 84                             ld      a,(CursorKeysPressed)
483+  82FA F6 80                                or      $80
484+  82FC 32 A2 84                             ld      (CursorKeysPressed),a
485+  82FF C3 38 83                             jp      ScanLeftKey
486+  8302 2A 21 81     ScanDiveKey:            ld      hl,(addr_Pressed_Dive)
487+  8305 7E                                   ld      a,(hl)
488+  8306                                      JumpIfAIsZero ScanLeftKey
488+  8306 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
488+  8307 CA 38 83    >                        jp	z, ScanLeftKey
489+  830A 3A A2 84                             ld      a,(CursorKeysPressed)
490+  830D F6 40                                or      $40
491+  830F 32 A2 84                             ld      (CursorKeysPressed),a
492+  8312 C3 38 83                             jp      ScanLeftKey
493+  8315 2A 5F 81     CursorKeys:             ld      hl,(addr_Pressed_CursorUp)
494+  8318 7E                                   ld      a,(hl)
495+  8319                                      JumpIfAIsZero ScanCursorDownKey
495+  8319 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
495+  831A CA 28 83    >                        jp	z, ScanCursorDownKey
496+  831D 3A A2 84                             ld      a,(CursorKeysPressed)
497+  8320 F6 80                                or      $80
498+  8322 32 A2 84                             ld      (CursorKeysPressed),a
499+  8325 C3 38 83                             jp      ScanLeftKey
500+  8328 2A 61 81     ScanCursorDownKey:      ld      hl,(addr_Pressed_CursorDown)
501+  832B 7E                                   ld      a,(hl)
502+  832C                                      JumpIfAIsZero ScanLeftKey
502+  832C A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
502+  832D CA 38 83    >                        jp	z, ScanLeftKey
503+  8330 3A A2 84                             ld      a,(CursorKeysPressed)
504+  8333 F6 40                                or      $40
505+  8335 32 A2 84                             ld      (CursorKeysPressed),a
506+  8338 2A 1D 81     ScanLeftKey:            ld      hl,(addr_Pressed_RollLeft)
507+  833B 7E                                   ld      a,(hl)
508+  833C                                      JumpIfAIsZero ScanRightKey
508+  833C A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
508+  833D CA 49 83    >                        jp	z, ScanRightKey
509+  8340 3A A2 84                             ld      a,(CursorKeysPressed)
510+  8343 F6 20                                or      $20
511+  8345 32 A2 84                             ld      (CursorKeysPressed),a
512+  8348 C9                                   ret
513+  8349 2A 1F 81     ScanRightKey:           ld      hl,(addr_Pressed_RollRight)
514+  834C 7E                                   ld      a,(hl)
515+  834D                                      JumpIfAIsZero ScanHomeKey
515+  834D A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
515+  834E CA 5A 83    >                        jp	z, ScanHomeKey
516+  8351 3A A2 84                             ld      a,(CursorKeysPressed)
517+  8354 F6 10                                or      $10
518+  8356 32 A2 84                             ld      (CursorKeysPressed),a
519+  8359 C9                                   ret
520+  835A 2A 3D 81     ScanHomeKey:            ld      hl,(addr_Pressed_HomeCursor)
521+  835D 7E                                   ld      a,(hl)
522+  835E                                      JumpIfAIsZero ScanRecentreKey
522+  835E A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
522+  835F CA 6B 83    >                        jp	z, ScanRecentreKey
523+  8362 3A A2 84                             ld      a,(CursorKeysPressed)
524+  8365 F6 08                                or      $08
525+  8367 32 A2 84                             ld      (CursorKeysPressed),a
526+  836A C9                                   ret
527+  836B 2A 59 81     ScanRecentreKey:        ld      hl,(addr_Pressed_Recentre)
528+  836E 7E                                   ld      a,(hl)
529+  836F                                      ReturnIfAIsZero
529+  836F A7          >                        and     a
529+  8370 C8          >                        ret     z
530+  8371 3A A2 84                             ld      a,(CursorKeysPressed)
531+  8374 F6 04                                or      $04
532+  8376 32 A2 84                             ld      (CursorKeysPressed),a
533+  8379 C9                                   ret
534+  837A
535+  837A
# file closed: ./Hardware/keyboard.asm
129   837A
130   837A                  INCLUDE "./Variables/constant_equates.asm"
# file opened: ./Variables/constant_equates.asm
  1+  837A              ;Contants
  2+  837A
  3+  837A              SignMask8Bit		equ %01111111
  4+  837A              SignMask16Bit		equ %0111111111111111
  5+  837A              SignOnly8Bit		equ $80
  6+  837A              SignOnly16Bit		equ $8000
  7+  837A
  8+  837A              Bit7Only            equ %10000000
  9+  837A              Bit6Only            equ %01000000
 10+  837A              Bit5Only            equ %00100000
 11+  837A              Bit4Only            equ %00010000
 12+  837A              Bit3Only            equ %00001000
 13+  837A              Bit2Only            equ %00000100
 14+  837A              Bit1Only            equ %00000010
 15+  837A              Bit0Only            equ %00000001
 16+  837A              Bit7Clear           equ %01111111
 17+  837A
 18+  837A              ConstPi				equ $80
 19+  837A              ConstNorm           equ 197
 20+  837A
 21+  837A              ;Text Tokens
 22+  837A              EliteToken			equ $1E			; Token ID for text messsage ---- E L I T E ----
 23+  837A              BrabenBellToken 	equ $0D
 24+  837A              AcorToken			equ $0C
 25+  837A
 26+  837A              ; Intro Screen
 27+  837A              TitleShip			equ	$8C
 28+  837A              RotationUnity		equ $60
 29+  837A              DBCheckCode			equ $DB
 30+  837A              MaxVisibility		equ $1F
 31+  837A              FarInFront			equ $C0
 32+  837A
 33+  837A              ; Universe Managment
 34+  837A              ShipTypeJunk        equ 3
 35+  837A              ShipTypeStation     equ 2
 36+  837A              ShipTypeMissile     equ 1
 37+  837A              ShipTypeNormal      equ 0
 38+  837A              ShipTypeEmpty       equ 255
 39+  837A              ; TacticsControl
 40+  837A              ShipIsTrader        equ Bit0Only   ; Trader flag  80% are peaceful 20% also have Bounty Hunter flag
 41+  837A              ShipIsBountyHunter  equ Bit1Only   ;
 42+  837A              ShipIsHostile       equ Bit2Only   ;
 43+  837A              ShipIsPirate        equ Bit3Only   ;
 44+  837A              ShipIsDocking       equ Bit4Only   ;
 45+  837A              ShipIsBystander     equ Bit5Only   ;
 46+  837A              ShipIsCop           equ Bit6Only   ;
 47+  837A              ShipIsScoopDockEsc  equ Bit7Only   ;
 48+  837A              ShipAIEnabled       equ Bit7Only   ;
 49+  837A              ShipExploding       equ Bit5Only
 50+  837A              ShipKilled          equ Bit7Clear
 51+  837A
 52+  837A              ; UniverseAIControl
 53+  837A              ShipCanAnger        equ %00000001
 54+  837A
 55+  837A
 56+  837A              ShipMaxDistance     equ 192
 57+  837A              HyperSpaceTimers    equ $0B0B
 58+  837A
 59+  837A
 60+  837A              MaxNumberOfStars	equ 11
 61+  837A              ConsoleRefreshInterval  equ 4
 62+  837A
 63+  837A              ShipTypeSize		equ	32 			;??????? just a guess for now
 64+  837A              ShipSST				equ 4			; its a space station
 65+  837A              UniverseBasePage 	equ 70			; Base memory bank for universe Item #0
 66+  837A              ShipDataBasePage	equ	90			; Needs 2mb upgrade but what the heck
 67+  837A              ShipCountMax		equ	2			; For now just 2 ships to debug
 68+  837A              LineLimitPerShip	equ 70			; Max lines per ship
 69+  837A              FaceLimitPerShip	equ	70			; Same as line limit to simplify some logic
 70+  837A              ; "NEED TO DEFINE SHIPTYPESIZE TODO"
 71+  837A              PlayerDocked		equ	$FF
 72+  837A
 73+  837A              ; Memory page managment	(Refers to a memory slot as a place to access data)
 74+  837A              ShipDataSlot		equ	6			; this may move into rom swap out space later
 75+  837A              UniverseObjectSlot	equ	7
 76+  837A
 77+  837A              KeyForwardsView		equ	$20
 78+  837A              ; Game specific equates
 79+  837A              MissileDropHeight   equ 5           ; how far the missile is ejected on launch in y axis
 80+  837A
 81+  837A              ;...Game Colour Mapping
 82+  837A              L2DustColour        equ L2ColourGREY_1
 83+  837A              L2SunScannerBright  equ 252
 84+  837A              L2SunScanner        equ 180
 85+  837A
 86+  837A
 87+  837A              ; Ship Data
 88+  837A              ;;;;	.XX21	\ -> &5600 \ Table of pointers to ships' data given to XX0
 89+  837A              ;;;;00 7F			 EQUW &7F00 \ type  1 is #MSL  Missile data on page off bottom of screen
 90+  837A              ;;;;00 00			 EQUW 0     \ type  2 is #SST  Space Station, Coriolis or Dodo.
 91+  837A              ;;;;00 00			 EQUW 0     \ type  3 is #ESC  Escape capsule
 92+  837A              ;;;;00 00			 EQUW 0     \ type  4 is #PLT  Plate, alloys
 93+  837A              ;;;;00 00			 EQUW 0     \ type  5 is #OIL  Cargo cannister
 94+  837A              ;;;;00 00			 EQUW 0     \ type  6 is       Boulder
 95+  837A              ;;;;00 00			 EQUW 0     \ type  7 is #AST  Asteroid
 96+  837A              ;;;;00 00			 EQUW 0     \ type  8 is #SPL  Splinter, rock.
 97+  837A              ;;;;00 00			 EQUW 0     \ type  9 is #SHU  Shuttle
 98+  837A              ;;;;00 00			 EQUW 0     \ type 10 is       Transporter
 99+  837A              ;;;;00 00			 EQUW 0     \ type 11 is #CYL  Cobra Mk III,  Boa
100+  837A              ;;;;00 00			 EQUW 0     \ type 12 is       Python
101+  837A              ;;;;00 00			 EQUW 0     \ type 13 is       Last of three traders
102+  837A              ;;;;00 00			 EQUW 0     \ type 14 is #ANA  Anaconda
103+  837A              ;;;;00 00			 EQUW 0     \ type 15 is #WRM  Worm with Anaconda
104+  837A              ;;;;00 00			 EQUW 0     \ type 16 is #COP  Viper
105+  837A              ;;;;00 00			 EQUW 0     \ type 17 is       First pirate
106+  837A              ;;;;00 00			 EQUW 0     \ type 18 is
107+  837A              ;;;;00 00			 EQUW 0     \ type 19 is #KRA  Krait small pirate
108+  837A              ;;;;00 00			 EQUW 0     \ type 20 is #ADA  Adder
109+  837A              ;;;;00 00			 EQUW 0     \ type 21 is
110+  837A              ;;;;00 00			 EQUW 0     \ type 22 is
111+  837A              ;;;;00 00			 EQUW 0     \ type 23 is
112+  837A              ;;;;00 00			 EQUW 0     \ type 24 is #CYL2 Last strong pirate
113+  837A              ;;;;00 00			 EQUW 0     \ type 25 is #ASP  Asp Mk II
114+  837A              ;;;;00 00			 EQUW 0     \ type 26 is #FER  Fer de Lance
115+  837A              ;;;;00 00			 EQUW 0     \ type 27 is
116+  837A              ;;;;00 00			 EQUW 0     \ type 28 is	Last of three bounty hunters
117+  837A              ;;;;00 00			 EQUW 0     \ type 29 is #THG  Thargoid
118+  837A              ;;;;00 00			 EQUW 0     \ type 30 is #TGL  Thargon
119+  837A              ;;;;00 00			 EQUW 0     \ type 31 is #CON  Constrictor
120+  837A              ;;;;	.E%	\ -> &563E \ Hull NEWB bits are escpod, cop, inno, ?, pirate, angry, hunter, trader.
121+  837A              ;;;;			\ NEWB examples
122+  837A              ;;;;\ 21			EQUB &21    \ 0010 0001    9 Shuttle has no escape pod, inno, trader.
123+  837A              ;;;;\ 61			EQUB &61    \ 0110 0001   10 Tansporter no escape pod, Cop, inno, trader.
124+  837A              ;;;;\ A0			EQUB &A0    \ 1010 0000   11 Cobra has Escape pod, inno, not a trader.
125+  837A              ;;;;\ C2			EQUB &C2    \ 1100 0010   16 Viper has Escape pod, Cop, hunter.
126+  837A              ;;;;\ 8C			EQUB &8C    \ 1000 1100   19 Krait pirate has escape pod, is pirate and angry.
127+  837A
# file closed: ./Variables/constant_equates.asm
131   837A                  INCLUDE "./Variables/general_variables.asm"
# file opened: ./Variables/general_variables.asm
  1+  837A
  2+  837A
  3+  837A 00 00        varAxis1	DW 	0				; address of first axis in a rotation action
  4+  837C 00 00        varAxis2	DW	0				; address of 2nd axis in a roation action
  5+  837E              ; Variables to simulate 6502 registers until code fixed
  6+  837E              ; These must be here in this order as reading Y and X can then be a 16 bit read
  7+  837E 00           regX		DB	0               ; using 16 bit read into BC this would go into C
  8+  837F 00           regY		DB	0               ; using 16 bit read into BC this would go into B
  9+  8380 00           regA		DB	0
 10+  8381
 11+  8381
 12+  8381 00           varGPLoopA	DB	0				; General Purpose innermost loop variable
 13+  8382 00 00        INF			DW	0				; page 0 &20 Used to get address from UNIV array
 14+  8384 00 00        INF28		DW	0				; page 0 &20 Used to get address from UNIV array
 15+  8386
 16+  8386
 17+  8386
 18+  8386              ;XX16		DS	16				; 16 byte Matrix
 19+  8386
 20+  8386              P0INWK							; page 0 & 46
 21+  8386              p0INWK31						; page 0 & 65
 22+  8386              P0INWK36						; PAGE 0 &6A
 23+  8386
 24+  8386 00           XX4			DB	0				; XX4 page 0 &96 last Normal Found to be visible
 25+  8387              LastNormalVisible	equ	XX4
 26+  8387              varXX4              equ XX4
 27+  8387
 28+  8387
 29+  8387
 30+  8387 00           PATG		DB	0				; 6502 &03C9
 31+  8388 00 00        SLSP 		DW	0				; &03B0 \ SLSP \ ship lines pointer
 32+  838A
 33+  838A
 34+  838A              ;UNIV		DS FreeListSize*2	; Array of Universe Pointers
 35+  838A              ;HULLINDEX	DS ShipTypeSize*2	; hull index for table at XX21= &5600 XX21-1,Y
 36+  838A
 37+  838A              ; Present System Variables
 38+  838A
 39+  838A 2B           RandomSeed				DB	43			; 00 DEBUG JUST SOME START VALUES
 40+  838B 20           RandomSeed1				DB	32	; 01
 41+  838C 0C           RandomSeed2				DB	12			; 02
 42+  838D 42           RandomSeed3				DB	66			; 03
 43+  838E
 44+  838E 00           varT1					DB	0				; 06
 45+  838F 00           SClo					DB 0				; 07
 46+  8390 00           SChi					DB 0				; 08
 47+  8391 00           varP					DB 0 				; 10	XX16+7
 48+  8392 00           varPhi					DB 0 				; 11	XX16+8
 49+  8393 00           varPhi2					DB 0 				; 12	XX16+9
 50+  8394              varPp1                  equ varPhi
 51+  8394              varPp2                  equ varPhi2
 52+  8394 00           UnivPointerLo			DB	0				; 20		INF                 XX0+2
 53+  8395 00           UnivPointerHi			DB	0				; 21      INF+1               XX0+3
 54+  8396              UnivPointer				equ	UnivPointerLo
 55+  8396 00           varV					DB 0				; 22                          XX0+4
 56+  8397 00           varVHi					DB 0				; 23                          XX0+5
 57+  8398 00           varXXlo                 DB 0                ; 24
 58+  8399 00           varXXHi                 DB 0                ; 25
 59+  839A              varXX					equ	varXXlo
 60+  839A 00           YYlo                    DB 0                ; 26
 61+  839B 00           YYHi                    DB 0                ; 27
 62+  839C              varYY					equ	YYlo
 63+  839C              											;	28
 64+  839C              											;	29
 65+  839C              ;PlayerShipPositionData - Must be contiguous for setup
 66+  839C 00           SpaceStationSafeZone    DB  0               ; Flag to determine if we are in safe zone
 67+  839D 00           BETA 					DB	0               ; 2A        (pitch done)
 68+  839E 00           JSTY                    DB  0               ; Joystick analog
 69+  839F 00           BET1 					DB	0               ; 2B        lower7 magnitude
 70+  83A0 00           BET2                    DB  0               ;            climb sign
 71+  83A1 00           BET2FLIP				DB	0				; 7C		BET 2 pitch Sign negated
 72+  83A2 1F           BET1MAXC                DB  31              ; max climb
 73+  83A3 E1           BET1MAXD                DB  -31             ; max dive
 74+  83A4 00           XC						DB	0               ; 2C
 75+  83A5 00           YC						DB 	0               ; 2D
 76+  83A6 00           InnerHyperCount			DB 	0				; 2F QQ22+1
 77+  83A7 00           OuterHyperCount			DB 	0				; 2E QQ22
 78+  83A8 00           HyperCircle             DB  0
 79+  83A9              ;... ECM logic. If another ship adds ECM then we just set the loop A and B to starting values so they overlap
 80+  83A9 00           ECMActive				DB 	0				; 30		ECM Active flag
 81+  83AA 00           ECMLoopA                DB  0
 82+  83AB 00           ECMLoopB                DB  0
 83+  83AC 00 00        JSTX                    DW  0               ;           Joystick analog value
 84+  83AE 00           ALPHA					DB	0				; 8D        Alpha with bit 7 sign
 85+  83AF 00           ALP1					DB 	0				; 31		ALP1	Roll magnitude Also Apha
 86+  83B0 00           ALP2					DB  0				; 32		ALP2	Roll Sign
 87+  83B1 00           ALP2FLIP				DB  0				; 33		ALP2	negated roll sign
 88+  83B2 1F           ALP1MAXR                DB  31               ;   Maximum roll, added becuase we may allow different ship types
 89+  83B3 E1           ALP1MAXL                DB  -31             ;   Maximum roll, added becuase we may allow different ship types
 90+  83B4
 91+  83B4
 92+  83B4
 93+  83B4              MAXMESSAGES             EQU 5
 94+  83B4              MESSAGETIMELIMIT        EQU 20
 95+  83B4              MESSAGESIZE             EQU 33
 96+  83B4              MESSAGELINE             EQU $0001
 97+  83B4
 98+  83B4 00           MessageCount            DB  0                ; used for enquing messages later
 99+  83B5 00           MessageCurrent          DB  0
100+  83B6 05 00        MessageIndex            DW  MAXMESSAGES
101+  83B8 00 00 00...  MessageQueue            DS  MAXMESSAGES * MESSAGESIZE
102+  845D 05           MessageTimeout          DB  MAXMESSAGES
103+  845E 00 00 00...  IndexedWork				DS	37				; General purpose work space when doing temp arrays
104+  8483
105+  8483              ; MOVED TO Universe XX19					DB	0				; page 0 &67
106+  8483              ; MOVED TO Universe XX20					DB	0				; page 0 &67 also used as XX19+1 for XX19 being a word
107+  8483              NormalCountCopyBy4		equ	XX20			; Also used for normal * 4 holding variable
108+  8483 00           XX21					DB  0				; this may be part of XX20/xx21 accordign to spawn new shipXX21		DW	0				; Ah XX21 is hull pointer  hull pointer lo as it can;t hold HULLINDX as 16bit array
109+  8484              ;XX21 is the pointer table to the pages for ship types. this will be repalaced by paging so just need an equate for first page
110+  8484
111+  8484
112+  8484 00 00 00...  SystemSeed				DS  5				;	6C		QQ15	Current Galaxy Seed
113+  8489              											;	6D		QQ15+1
114+  8489              											;	6E		QQ15+2
115+  8489              											;	6F		QQ15+3
116+  8489              											;	70		QQ15+4
117+  8489              											;	71		QQ15+5
118+  8489 00           QQ17					DB	0				;   72
119+  848A 00           XX18xlo                 DB  0               ;	72		XX18   xlo
120+  848B 00           XX18xhi                 DB  0               ;	73		XX18+1 xhi
121+  848C 00           XX18xsg                 DB  0               ;	74		XX18+2 xsgn
122+  848D 00           XX18ylo                 DB  0               ;	75		XX18   ylo
123+  848E 00           XX18yhi                 DB  0               ;	76		XX18+1 yhi
124+  848F 00           XX18ysg                 DB  0               ;	77		XX18+2 ysgn
125+  8490 00           XX18zlo                 DB  0               ;	78		XX18   zlo
126+  8491 00           XX18zhi                 DB  0               ;	79		XX18+1 zhi
127+  8492 00           XX18zsg                 DB  0               ;	7A		XX18+2 zsgn
128+  8493
129+  8493 28           SHIPMAXSPEED            DB  40              ; variable to facilitate ship editing later
130+  8494 00           DELTA					DB 	0				; 7D 		DELTA  \ bpl -2 inserted here to stall from title code if byte check fails
131+  8495 00           DELT4Lo					DB 	0				; 7E
132+  8496 00           DELT4Hi					DB 	0				; 7F
133+  8497              DELTA4                  equ                 DELT4Lo
134+  8497
135+  8497
136+  8497              ; Not thise must be in this order else 16 bit fetches will fail
137+  8497 00           varU                    DB  0               ;   80
138+  8498 00           varQ					DB  0 				;	81
139+  8499 00           varR					DB  0 				;	82
140+  849A 00           varS					DB  0 				;	83
141+  849B              varRS                   equ varR
142+  849B
143+  849B 00 00        varU16                  DW  0               ; 16 bit variant on varU as I can't use above for this
144+  849D
145+  849D 00           XSAV					DB	0				; 84	   XSAV usef for nearby ship count outer
146+  849E 00           YSAV                    DB  0               ; 85
147+  849F 00           XX17					DB	0				; 86
148+  84A0              RequiredScale			equ  XX17			; use to hold calculated scale in drawing ship
149+  84A0              varXX17                 equ  XX17
150+  84A0 00           ScreenChanged           DB  0
151+  84A1 00           ScreenIndex             DB  0
152+  84A2 00           CursorKeysPressed       DB  0               ; mapping of the current key presses
153+  84A3                                                          ; 7    6    5    4     3    2        1    0
154+  84A3                                                          ; Up   Down Left Right Home Recentre
155+  84A3 00           InvertedYAxis           DB  0
156+  84A4 00           MenuIdMax				DB	0				;	87		MenuIdMax		QQ11
157+  84A5              											; Bit 7 Set  ShortRangeChart    $80
158+  84A5              											; Bit 6 Set  Galactic Chart     $40
159+  84A5              											; Bit 5 Set  Market Place       $20
160+  84A5              											; Bit 4 Set  Status Screen      $10
161+  84A5              											; Bit 3 Set  Display Inventory  $08
162+  84A5                                                          ; Bit 2 Set  Planet Data        $04
163+  84A5                                                          ; View bit combinations if the ones above not matched
164+  84A5                                                          ; bits 1 0
165+  84A5                                                          ;      1 1  Front view , i.e. $03
166+  84A5                                                          ;      1 0  Aft View          $02
167+  84A5                                                          ;      0 1  Left View         $01
168+  84A5                                                          ;      0 0  Right view        $00
169+  84A5              											; Bit 0 Set  Data On System
170+  84A5              											; 0  Space View (Not a menu)
171+  84A5 00           ZZDust					DB	0				;	88		ZZDust (Poss 16 bit need to check)
172+  84A6 00           XX13                    DB  0               ;   89
173+  84A7 00           TYPE					DB	0				; 8C used for ship type in drawing
174+  84A8              ;Docked flag = 00 = in free space
175+  84A8              ;              FF = Docked
176+  84A8              ;              FE = transition
177+  84A8              ;              FD = Setup open space and transition to not docked
178+  84A8              ;              FC = Hyperspace manimation
179+  84A8              ;              FB = Hyperspace complete
180+  84A8 00           DockedFlag				DB	0				; 8E -
181+  84A9 00           GamePaused              DB  0
182+  84AA 00           varSWAP                 DB  0               ; 90 , general purpose swap variable
183+  84AB 00           varCNT                  DB  0               ; 93
184+  84AC
185+  84AC 00           varK					DB	0				; 40
186+  84AD 00           varKp1					DB	0				; 41
187+  84AE 00           varKp2					DB	0				; 42
188+  84AF 00           varKp3					DB	0				; 43
189+  84B0
190+  84B0 00           varK2                   DB  0               ; 9B
191+  84B1 00           varK2p1                 DB  0               ; 9C K2 plus 1
192+  84B2 00           varK2p2                 DB  0               ; 9D K2 plus 2
193+  84B3 00           varK2p3                 DB  0               ; 9E K2 plus 3
194+  84B4
195+  84B4 00           Point                   DB  0               ; 9F      POINT
196+  84B5
197+  84B5 00           varT					DB	0				; D1
198+  84B6
199+  84B6 00 00 00...  varVector9ByteWork      DS  9
200+  84BF
201+  84BF 00 00 00 00  varK3					DS	4				; D2
202+  84C3 00           varK3p2					DB	0				; 42
203+  84C4 00           varK3p3					DB	0				; 43
204+  84C5              varK3p1					equ varK3+1			; D3
205+  84C5 00 00 00 00  varK4					DS	4				; E0
206+  84C9              varK4p1					equ varK4+1			; D3
207+  84C9
208+  84C9
209+  84C9              ;Heap
210+  84C9
211+  84C9 00 00        HeapStart				DS	2				; &0100 XX3 50 bytes for now
212+  84CB 00 00 00...  HeapData				DS	50
213+  84FD              ; Contains 				X 16 bit, Y ;MissileArmedStatus		DB	0				; 0344 MSAR   using MissileTarget, if missile is not armed tehn target is FF
214+  84FD              ; TODO will need an read for a list of missiles, who they are targeting an the target current vector for AI persuit
215+  84FD              ; i.e. a list of programmed missiles in universe slot list code
216+  84FD 00 00 00...  DampingKeys				DS  7				; 0387 - 038D
217+  8504              ;  #&6 Does K toggle keyboard/joystick control -  03CD certainly makes keyboard not work anymore.
218+  8504              ;  #&5 Does J reverse both joystick channels
219+  8504              ;  #&4 Does Y reverse joystick Y channel			03CB
220+  8504              ;  #&2 Does X toggle startup message display ? PATG?	03C9
221+  8504              ;  #&3 Does F toggle flashing information			03CA
222+  8504              ;  #&1 Does A toggle keyboard auto-recentering ?
223+  8504              ;  #&0 Caps-lock toggles keyboard flight damping
224+  8504 00           NbrMissiles				DB	0				; 038B	Does this clash with Dampingkeys?
225+  8505 00           FugitiveInnocentStatus	DB	0				; 038C	FIST
226+  8506 00 00 00...  StockAvaliabiliy		DS 	16				; 038D - 039C Stock inventory in station
227+  8516 00           AlienItemsAvaliability  DB	0				; 039D
228+  8517 00           RandomMarketSeed		DB	0				; 039E   \ QQ26	\ random byte for each system vist (for market)
229+  8518 00 00        KillTally  				DW	0				; 039F - 03A0 \ TALLY   \ kills lo hi
230+  851A 00           COMP     				DB	0				; 03A1 2nd competion byte used for save integrity checks?
231+  851B              											;
232+  851B 00           MCH						DB	0				; 03A4  \ MCH  \ old message to erase
233+  851C 00           MarketPrice				DB	0				; 03AA QQ24
234+  851D 00           MaxStockAvaliable		DB  0				; 03AB   \ QQ25     \ max available
235+  851E 00           SystemEconomy			DB  0				; 03AC \ QQ28   \ the economy byte of present system (0 is Rich Ind.)
236+  851F 00           CargoItem				DB	0				; 03AD (I think its item type just scooped) QQ29
237+  8520 00 00        ShipLineStackPointer	DW	0				; 03B0 & 03B1 ship Lines pointer reset to top LS% = &0CFF (make DW for z80 and direct hl pointer)
238+  8522              											; this is ship lines stack pointer so may be redundant with paging
239+  8522              											; LS = line stack so we will have one for now to remove later
240+  8522 00           COK						DB	0				; 0366 Competition Byte what ? Does some file check and accelleration check
241+  8523 00           DisplayEcononmy			DB	0				; 03B8
242+  8524 00           DisplayGovernment		DB  0				; 03B9 Is it target? 03B9 \ QQ4	 \ Government, 0 is Anarchy.
243+  8525 00           DisplayTekLevel			DB	0				; 03BA   \ QQ5	\ Tech
244+  8526 00 00        DisplayPopulation		DW	0				; 03BB \ QQ6  \ population*10
245+  8528 00 00        DisplayProductivity		DW	0				; 03BD \ QQ7   \ productivity*10
246+  852A 00 00        Distance          		DW	0				; 03BE \ QQ8 distince in 0.1LY units
247+  852C 00 00        DisplayRadius			DW	0
248+  852E              ; --- Used in creation of sun and planet----;
249+  852E 00           PlanetXPos              DS  1
250+  852F 00           PlanetYPos              DS  1
251+  8530 00           PlanetZPos              DS  1
252+  8531 00           PlanetType              DS  1
253+  8532 00           SunXPos                 DS  1
254+  8533 00           SunYPos                 DS  1
255+  8534 00           SunZPos                 DS  1
256+  8535              ; -- Current Missile Runbtime data
257+  8535 00           CurrentMissileBank:     DB      0                                   ; used by missile logic as local copy of missile bank number
258+  8536 00 00        MissileXPos             DW      0
259+  8538 00           MissileXSgn             DB      0
260+  8539 00 00        MissileYPos             DW      0
261+  853B 00           MissileYSgn             DB      0
262+  853C 00 00        MissileZPos             DW      0
263+  853E 00           MissileZSgn             DB      0
264+  853F 00 00        CurrentTargetXpos       DS      2
265+  8541 00 00        CurrentTargetXsgn       DS      2
266+  8543 00 00        CurrentTargetYpos       DS      2
267+  8545 00 00        CurrentTargetYsgn       DS      2
268+  8547 00 00        CurrentTargetZpos       DS      2
269+  8549 00 00        CurrentTargetZsgn       DS      2
270+  854B 00 00        TargetVectorXpos        DS      2
271+  854D 00 00        TargetVectorXsgn        DS      2
272+  854F 00 00        TargetVectorYpos        DS      2
273+  8551 00 00        TargetVectorYsgn        DS      2
274+  8553 00 00        TargetVectorZpos        DS      2
275+  8555 00 00        TargetVectorZsgn        DS      2
276+  8557 00           CurrentMissileBlastRange:      DB  0                       ; TODO Initi for runtime copied in when setting up a missile
277+  8558 00           CurrentMissileBlastDamage:     DB  0                       ; TODO Initi for runtime copied in when setting up a missile
278+  8559 00           CurrentMissileDetonateRange:   DB  0                       ; TODO Initi for runtime copied in when setting up a missile, allows for proximity missiles
279+  855A 00           CurrentMissileDetonateDamage:  DB  0                       ; TODO Initi for runtime copied in when setting up a missile
280+  855B
281+  855B              ; --- Main Loop Data -----------------------;
282+  855B 00           CurrentUniverseAI       DB  0               ; current ship unviverse slot due an AI update
283+  855C 00           SelectedUniverseSlot    DB  0
284+  855D 00           SetStationAngryFlag     DB  0               ; used to semaphore angry space station
285+  855E 00           ShipBlastCheckCounter   DB  0
286+  855F 00           EventCounter    		DB 	0				; 8A
287+  8560 00           MissJumpFlag            DB  0
288+  8561 00           ExtraVesselsCounter     DB  0
289+  8562 00           JunkCount				DB  0				; $033E
290+  8563 00           PlayerMisJump			DB	0				; $0341 witchspace misjump
291+  8564 00           HyperSpaceFX			DB	0				; 0348 HFX (probabyl BBC specific
292+  8565 00           ExtraVessels			DB	0				; 0349 EV Use d by cops, extra vessels still to spawn?
293+  8566 00           Delay					DB	0				; 034A Delay general purpose eg. spawing EV or when printign messages
294+  8567 00           CurrentMissileCheck:    DB  0               ; if > Universe Slot list then free for next missile
295+  8568 00           MessageForDestroyed		DB	0				; 034B Message flag for item + destroyed
296+  8569              UniverseSlotListSize    equ	12
297+  8569 00 00 00...  UniverseSlotList        DS  UniverseSlotListSize
298+  8575 00 00 00...  UniverseSlotType        DS  UniverseSlotListSize ; base type, e.g. missile, cargo etc,
299+  8581              ; Probably not needed UniverseTypeCount       DS  UniverseSlotListSize
300+  8581 00           TransporterCount        DB  0
301+  8582 00           CopCount                DB  0
302+  8583 00           PirateCount             DB  0
303+  8584 04           ConsoleRefreshCounter   DB  ConsoleRefreshInterval ; Every 4 interations the console will update twice (once for primary and once for seconday buffer)
304+  8585 00           ConsoleRedrawFlag       DB  0
305+  8586              ; --- Galaxy Data --------------------------;
306+  8586 00           Galaxy      			DB	0				; 0367 Galaxy (incremented with galactiv drive
307+  8587 00 00 00...  WorkingSeeds			DS	6
308+  858D 00 00 00...  PresentSystemSeeds		DS	6				; 03B2 - 03B7
309+  8593 00 00 00...  GalaxySeeds				DS	6				; 035B - 0360 QQ21
310+  8599 00           PresentSystemX			DB	0				; System we are currently in
311+  859A 00           PresentSystemY			DB  0				; System we are currently in
312+  859B 00           TargetSystemX			DB	0				; System we are targeting for jump
313+  859C 00           TargetSystemY			DB	0				; System we are targeting for jump
314+  859D 00           GovPresentSystem		DB	0				; 03AE Govenment
315+  859E 00           TekPresentSystem		DB	0				; 03AF Technology
316+  859F
317+  859F 00           CompassColor			DB	0				; 03C5
318+  85A0 00           SoundToggle				DB	0				; 03C6
319+  85A1 00           KeyboardRecenterToggle	DB	0				; 03C8
320+  85A2 00           PATGMask				DB	0				; &03C9    \ PATG	\ Mask to scan keyboard X-key, for misjump
321+  85A3 00           FlashToggle				DB  0				; 03CA \ FLH \ flash toggle
322+  85A4 00           ReverseJoystick			DB	0				; 03CB \ JSTGY \ Y reverse joystick Y channel
323+  85A5 00           JoystickToggle			DB	0				; 03CD  \ JSTK    \ K toggle keyboard/joystick
324+  85A6 00           DigitalJoystick			DB	0				; 03CE \ JDB   \ . = toggle between keyboard and bitpaddle
325+  85A7 00           DiskReadFailFlag		DB	0				; 03CF \ CATF \ Disk catalog fail flag
326+  85A8
327+  85A8              ; Working Data
328+  85A8
329+  85A8              ;UniverseTable			DS	26				; 1741  \ address pointers for 13 ships INF on pages &9. 37 bytes each.
330+  85A8              ; $0900 =	EQUW page9+37* 0 \ copied to inner worskpace INWK on zero-page when needed
331+  85A8              ; $0925 =	EQUW page9+37* 1
332+  85A8              ; $094A =	EQUW page9+37* 2
333+  85A8              ; $096F =	EQUW page9+37* 3
334+  85A8              ; $0994 =	EQUW page9+37* 4
335+  85A8              ; $09B9 =	EQUW page9+37* 5
336+  85A8              ; $09DE =	EQUW page9+37* 6
337+  85A8              ; $0A03 =	EQUW page9+37* 7
338+  85A8              ; $0A28 =	EQUW page9+37* 8
339+  85A8              ; $0A4D =	EQUW page9+37* 9
340+  85A8              ; $0A72 =	EQUW page9+37*10
341+  85A8              ; $0A97 =	EQUW page9+37*11
342+  85A8              ; $0ABC =	EQUW page9+37*12 \ allwk up to &0ABC while heap for edges working down from &CFF.
343+  85A8
344+  85A8
345+  85A8
346+  85A8              ; 0b00 is start address of data to save
347+  85A8              ; Now MissionData VarTP					DB	0				; 0358 TP? The Plan  \ mission uses lower 4 bits
348+  85A8              											; Bit mask XXXX10XX - Thargoid plan mission
349+  85A8
350+  85A8 00           MissionData				DB	0				; &0B00	  \ look at data, first byte is TP mission bits
351+  85A9
352+  85A9 00 00        FileNameStringPointer	DW	0				;0C00	   \ pointer to filename string
353+  85AB 00 00        CommanderLoadAddress	DW	0				;0C03
354+  85AD 00 00        LengthOfFile			DW	0				;0C0B
355+  85AF 00 00        SaveDataEndAddress		DW	0				;&0C0F	      \ &0C00 is end address of data to save
356+  85B1
357+  85B1 00 00 00...  EdgesBuffer				DS 50
358+  85E3              EdgesBufferSP			equ	$				; Was $0CFF			; Heap pointer for edges buffer
359+  85E3              ShipLinesBufferSP		equ EdgesBufferSP	; was $0CFF
360+  85E3
361+  85E3 00 00 00...  ShipLineStack			DS  70			; For now but will be in the page later
362+  8629              ShipLineStackTop		equ $ - ShipLineStack
363+  8629
364+  8629 00 00 00...  LSO						DS 	$C0				;0E00 Line Buffer Solar of 192 lines (may be 191 in reality)
365+  86E9              ; LSX vector overlaps with LSO
366+  86E9 00           LSX2					DB	0				; &0EC0	    \ LSX2 bline buffer size?
367+  86EA 00           LSY2					DB	0           	; &0F0E	    \ LSY2
368+  86EB
369+  86EB              ; Star Positions are 16 bit 3d coordinates
370+  86EB 00 00 00...  varDust                 DS  MaxNumberOfStars * 6
371+  872D 00 00 00...  varDustSceen            DS  MaxNumberOfStars * 2 ; To optimise star list to wipe from screen
372+  8743 00           varStarX                DB  0
373+  8744 00           varStarY                DB  0
374+  8745 00 00 00...  varDustX                DS MaxNumberOfStars *2
375+  875B 00 00 00...  varDustY                DS MaxNumberOfStars *2
376+  8771 00 00 00...  varDustZ                DS MaxNumberOfStars *2
377+  8787              ; -- Player Runtime Data
378+  8787 00           GunTemperature          DB  0
379+  8788 00           CabinTemperature        DB  0
380+  8789 00           PlayerForwardSheild0	DB	0 ; ?????
381+  878A 00           PlayerForwardSheild1    DB	0
382+  878B 00           PlayerForwardSheild2    DB	0
383+  878C 00           ForeShield				DB	0				; 03A5
384+  878D 00           AftShield				DB	0				; 03A6
385+  878E 00           PlayerEnergy			DB	0				; 03A7
386+  878F 00           CompassX				DB	0				; 03A8
387+  8790 00           CompassY				DB	0				; 03A9
388+  8791 00           MissileTarget			DB  0				; 45
389+  8792 00           MissileLaunchFlag       DB  0
390+  8793 00 00 00...  CommanderName           DS  15
391+  87A2 00           CommanderName0			DB	0				; Sneaky little 0 to allow use of print name directly
392+  87A3 00           BadnessStatus           DB  0
393+  87A4              ; -- Input variables
394+  87A4 00           JoystickX				DB	0				; 034C JSTX
395+  87A5 00           JoystickY				DB	0				; 034D JSTY
396+  87A6 00           XSAV2 					DB	0				; 034E used to temporary save 6502 X reg
397+  87A7 00           YSAV2 					DB	0				; 034F used to temporary save 6502 Y reg
398+  87A8
399+  87A8              ; -- Console drawing data
400+  87A8              FShieldStart            equ $8410
401+  87A8              AShieldStart            equ $8D10
402+  87A8              FuelStart               equ $9410
403+  87A8
404+  87A8              EnergyBar4Start         equ $A5D5
405+  87A8              EnergyBar3Start         equ $ADD5
406+  87A8              EnergyBar2Start         equ $B5D5
407+  87A8              EnergyBar1Start         equ $BDD5
408+  87A8              ; 70 /2 = 35 values
409+  87A8              ;                            0                             1                             2                             3
410+  87A8              ;                            0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6
411+  87A8 01 02 02 03  FuelMapping             DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,19,20,21,21,22,23,24,25,26,27,28,30,31,31
411+  87AC 04 04 05 06
411+  87B0 06 07 08 09
411+  87B4 0A 0A 0B 0C
411+  87B8 0D 0E 0E 0F
411+  87BC 10 10 11 13
411+  87C0 14 15 15 16
411+  87C4 17 18 19 1A
411+  87C8 1B 1C 1E 1F
411+  87CC 1F
412+  87CD              SpeedoStart             equ $84D1
413+  87CD              ;                            0                             1                             2                             3                             4
414+  87CD              ;                            0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0
415+  87CD 01 02 02 03  SpeedoMapping           DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,18,19,20,20,21,22,23,24,24,25,26,26,27,28,28,29,30,31
415+  87D1 04 04 05 06
415+  87D5 06 07 08 09
415+  87D9 0A 0A 0B 0C
415+  87DD 0D 0E 0E 0F
415+  87E1 10 10 11 12
415+  87E5 13 14 14 15
415+  87E9 16 17 18 18
415+  87ED 19 1A 1A 1B
415+  87F1 1C 1C 1D 1E
415+  87F5 1F
416+  87F6
417+  87F6              DialMiddleXPos          equ $E1
418+  87F6              RollMiddle              equ $8CE0
419+  87F6              PitchMiddle             equ $94E0
420+  87F6
421+  87F6
422+  87F6              ResetPlayerShip:        ZeroThrottle
422+  87F6 AF          >                        xor     a
422+  87F7 32 94 84    >                        ld      (DELTA),a
422+  87FA 32 95 84    >                        ld      (DELT4Lo),a
422+  87FD 32 96 84    >                        ld      (DELT4Lo+1),a
423+  8800                                      ZeroPitch
423+  8800 AF          >                        xor     a
423+  8801 32 A0 83    >                        ld      (BET2),a
423+  8804 32 A1 83    >                        ld      (BET2FLIP),a
423+  8807 32 9E 83    >                        ld      (JSTY),a
423+  880A 32 9D 83    >                        ld      (BETA),a
424+  880D                                      ZeroRoll
424+  880D AF          >                        xor     a                              ; zero roll and climb
424+  880E 32 B0 83    >                        ld      (ALP2),a
424+  8811 32 B1 83    >                        ld      (ALP2FLIP),a
424+  8814 32 AC 83    >                        ld      (JSTX),a
424+  8817 32 AE 83    >                        ld      (ALPHA),a
425+  881A                                      ClearMissileTarget
425+  881A AF          >                        xor     a                           ; Set missile target to FF
425+  881B 3D          >                        dec     a
425+  881C 32 91 87    >                        ld      (MissileTarget),a
425+  881F             >                        SetMemFalse MissileLaunchFlag
425+  881F 3E FF       >                        ld      a,$FF
425+  8821 32 92 87    >                        ld      (MissileLaunchFlag),a
426+  8824                                      ClearECM
426+  8824 AF          >                        xor     a
426+  8825 32 AA 83    >                        ld      (ECMLoopA),a
426+  8828 32 AB 83    >                        ld      (ECMLoopB),a
427+  882B                                      ChargeEnergyAndShields
427+  882B 3E FF       >                        ld      a,$FF
427+  882D 32 8E 87    >                        ld      (PlayerEnergy),a
427+  8830 32 8C 87    >                        ld      (ForeShield),a
427+  8833 32 8D 87    >                        ld      (AftShield),a
428+  8836 C9                                   ret
429+  8837
# file closed: ./Variables/general_variables.asm
132   8837
133   8837              ; Include all maths libraries to test assembly
134   8837
135   8837
136   8837              ;--------------------------------------------------------------------------------------------------------
137   8837              ; Goes through each edge in to determine if they are on a visible face, if so load start and end to line array as clipped lines
138   8837
139   8837              ; Bank 58  ------------------------------------------------------------------------------------------------------------------------
140   8837                  SLOT    LAYER1Addr
141   8837                  PAGE    BankLAYER1
142   8837                  ORG     LAYER1Addr, BankLAYER1
143   E000
144   E000                  INCLUDE "./Layer1Graphics/layer1_attr_utils.asm"
# file opened: ./Layer1Graphics/layer1_attr_utils.asm
  1+  E000
  2+  E000 00 58        L1AttrRow00:            DW $5800                    ;Row 1    */
  3+  E002 20 58        L1AttrRow01:            DW $5820                    ;Row 2    */
  4+  E004 40 58        L1AttrRow02:            DW $5840                    ;Row 3    */
  5+  E006 60 58        L1AttrRow03:            DW $5860                    ;Row 4    */
  6+  E008 80 58        L1AttrRow04:            DW $5880                    ;Row 5    */
  7+  E00A A0 58        L1AttrRow05:            DW $58A0                    ;Row 6    */
  8+  E00C C0 58        L1AttrRow06:            DW $58C0                    ;Row 7    */
  9+  E00E E0 58        L1AttrRow07:            DW $58E0                    ;Row 8    */
 10+  E010 00 59        L1AttrRow08:            DW $5900                    ;Row 9    */
 11+  E012 20 59        L1AttrRow09:            DW $5920                    ;Row 10   */
 12+  E014 40 59        L1AttrRow10:            DW $5940                    ;Row 11   */
 13+  E016 60 59        L1AttrRow11:            DW $5960                    ;Row 12   */
 14+  E018 80 59        L1AttrRow12:            DW $5980                    ;Row 13   */
 15+  E01A A0 59        L1AttrRow13:            DW $59A0                    ;Row 14   */
 16+  E01C C0 59        L1AttrRow14:            DW $59C0                    ;Row 15   */
 17+  E01E E0 59        L1AttrRow15:            DW $59E0                    ;Row 16   */
 18+  E020 00 5A        L1AttrRow16:            DW $5A00                    ;Row 17   */
 19+  E022 20 5A        L1AttrRow17:            DW $5A20                    ;Row 18   */
 20+  E024 40 5A        L1AttrRow18:            DW $5A40                    ;Row 19   */
 21+  E026 60 5A        L1AttrRow19:            DW $5A60                    ;Row 20   */
 22+  E028 80 5A        L1AttrRow20:            DW $5A80                    ;Row 21   */
 23+  E02A A0 5A        L1AttrRow21:            DW $5AA0                    ;Row 22   */
 24+  E02C C0 5A        L1AttrRow22:            DW $5AC0                    ;Row 23   */
 25+  E02E E0 5A        L1AttrRow23:            DW $5AE0                    ;Row 23   */
 26+  E030
 27+  E030              ; "l2_hilight_row, d = row, e = colour"
 28+  E030 21 00 E0     l1_hilight_row:         ld      hl, L1AttrRow00
 29+  E033 4B                                   ld      c,e
 30+  E034 7A                                   ld      a,d
 31+  E035 CB 27                                sla     a
 32+  E037 ED 31                                add     hl,a
 33+  E039 7E                                   ld      a,(hl)
 34+  E03A 5F                                   ld      e,a
 35+  E03B 23                                   inc     hl
 36+  E03C 7E                                   ld      a,(hl)
 37+  E03D 57                                   ld      d,a
 38+  E03E EB                                   ex      hl,de
 39+  E03F 79                                   ld		a,c
 40+  E040 11 20 00                             ld		de, 32
 41+  E043 CD A2 80                             call	memfill_dma
 42+  E046 C9                                   ret
 43+  E047
# file closed: ./Layer1Graphics/layer1_attr_utils.asm
145   E047                  INCLUDE "./Layer1Graphics/layer1_cls.asm"
# file opened: ./Layer1Graphics/layer1_cls.asm
  1+  E047 AF           l1_cls_top:             xor     a
  2+  E048 21 00 40                             ld      hl, $4000
  3+  E04B 11 00 08                             ld      de, $0800
  4+  E04E CD A2 80                             call    memfill_dma
  5+  E051 C9                                   ret
  6+  E052
  7+  E052 AF           l1_cls_mid:             xor     a
  8+  E053 21 00 48                             ld      hl, $4800
  9+  E056 11 00 08                             ld      de, $0800
 10+  E059 CD A2 80                             call    memfill_dma
 11+  E05C C9                                   ret
 12+  E05D
 13+  E05D AF           l1_cls_bottom:          xor     a
 14+  E05E 21 00 50                             ld      hl, $5000
 15+  E061 11 00 08                             ld      de, $0800
 16+  E064 CD A2 80                             call    memfill_dma
 17+  E067 C9                                   ret
 18+  E068
 19+  E068              ; Designed specifically to clear a whole character aligned line
 20+  E068 1E 00        l1_cls_line_d:          ld      e,0
 21+  E06A ED 94                                pixelad
 22+  E06C 11 00 01                             ld      de,32 * 8
 23+  E06F AF                                   xor     a
 24+  E070 CD A2 80                             call    memfill_dma
 25+  E073 C9                                   ret
 26+  E074
 27+  E074              ; Designed specifically to clear a whole character aligned 2 lines line, used for say clearing hyperspace message
 28+  E074 1E 00        l1_cls_2_lines_d:       ld      e,0
 29+  E076 ED 94                                pixelad
 30+  E078 11 00 02                             ld      de,32 * 16
 31+  E07B AF                                   xor     a
 32+  E07C CD A2 80                             call    memfill_dma
 33+  E07F C9                                   ret
 34+  E080
 35+  E080 AF           l1_cls:                 xor		a
 36+  E081 21 00 40     l1_cls_to_a:            ld		hl,	$4000
 37+  E084 11 00 18                             ld		de, $1800
 38+  E087 CD A2 80                             call	memfill_dma
 39+  E08A C9                                   ret
 40+  E08B
 41+  E08B 21 00 58     l1_attr_cls_2DlinesA:   ld		hl,	$5800
 42+  E08E 1E 20                                ld      e,32
 43+  E090 ED 30                                mul
 44+  E092 19                                   add     hl,de
 45+  E093 11 40 00                             ld		de, 32 * 2
 46+  E096 CD A2 80                             call	memfill_dma
 47+  E099 C9                                   ret
 48+  E09A
 49+  E09A
 50+  E09A AF           l1_attr_cls:            xor		a
 51+  E09B 21 00 58     l1_attr_cls_to_a:       ld		hl,	$5800
 52+  E09E 11 00 03                             ld		de, $0300
 53+  E0A1 CD A2 80                             call	memfill_dma
 54+  E0A4 C9                                   ret
 55+  E0A5
 56+  E0A5 01 FE FE     l1_set_border:          ld	    bc, 0xFEFE
 57+  E0A8 ED 79                                out		(c),a
 58+  E0AA C9                                   ret
# file closed: ./Layer1Graphics/layer1_cls.asm
146   E0AB                  INCLUDE "./Layer1Graphics/layer1_print_at.asm"
# file opened: ./Layer1Graphics/layer1_print_at.asm
  1+  E0AB              ; "l1 print char a = character, de = Ypixel Xchar of print"
  2+  E0AB D5 E5        l1_print_char:          push	de,,hl
  3+  E0AD ED 94                                pixelad								; hl = address of de
  4+  E0AF E5                                   push	hl							; save hl for loop
  5+  E0B0 26 00                                ld		h,0
  6+  E0B2 6F                                   ld		l,a
  7+  E0B3 29                                   add		hl,hl						; * 2
  8+  E0B4 29                                   add		hl,hl						; * 4
  9+  E0B5 29                                   add		hl,hl						; * 8 to get byte address
 10+  E0B6 ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
 11+  E0BA EB                                   ex		de,hl						; save address into de
 12+  E0BB E1                                   pop		hl							; get back hl for loop
 13+  E0BC 06 08                                ld		b,8							; do 8 rows
 14+  E0BE 1A           .PrintCharLoop:         ld		a,(de)						; row byte
 15+  E0BF 13                                   inc		de							; next byte
 16+  E0C0 77                                   ld		(hl),a						; poke to screen
 17+  E0C1 ED 93                                pixeldn								; Down 1 row
 18+  E0C3 10 F9                                djnz	.PrintCharLoop				; loop for 8 bytes
 19+  E0C5 E1 D1                                pop		de,,hl					    ; restore hl
 20+  E0C7 C9                                   ret
 21+  E0C8
 22+  E0C8              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
 23+  E0C8              ; now skips ascii code < 32 but moves on cursor by 1 char
 24+  E0C8              l1_print_at:
 25+  E0C8 7E           .PrintLoop:             ld		a,(hl)
 26+  E0C9 FE 00                                cp		0
 27+  E0CB C8                                   ret		z
 28+  E0CC                                      CallIfAGTENusng " ", l1_print_char
 28+  E0CC FE 20       >                        cp      " "
 28+  E0CE D4 AB E0    >                        call	nc,l1_print_char
 29+  E0D1 23                                   inc		hl							; move 1 message character right
 30+  E0D2 7B                                   ld		a,e
 31+  E0D3 C6 08                                add		a,8
 32+  E0D5 5F                                   ld		e,a							; move 1 screen character right
 33+  E0D6 18 F0                                jr		.PrintLoop
 34+  E0D8              .Clearstackandfinish:   ;pop		de                      ; TODO LOOOKS TO BE A ROGUE POPDE
 35+  E0D8 C9                                   ret
 36+  E0D9
 37+  E0D9              ;l1_print_at_wrap:
 38+  E0D9              ;; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
 39+  E0D9              ;	ld      iyh,e
 40+  E0D9              ;.PrintLoop:
 41+  E0D9              ;	ld		a,(hl)
 42+  E0D9              ;	cp		0
 43+  E0D9              ;	ret		z
 44+  E0D9              ;.CountWordCharLen
 45+  E0D9              ;; Need to change to word wrap, so it will loop through string as before
 46+  E0D9              ;; but read up until a null or space, take the character count * 8 for pixels
 47+  E0D9              ;; if that is > 238 then force a premature line wrap
 48+  E0D9              ;
 49+  E0D9              ;
 50+  E0D9              ;    push    iy
 51+  E0D9              ;    call	l1_print_char
 52+  E0D9              ;    pop     iy
 53+  E0D9              ;	inc		hl							; move 1 message character right
 54+  E0D9              ;	ld		a,e
 55+  E0D9              ;    cp      238
 56+  E0D9              ;    jr      nc,.NextLine
 57+  E0D9              ;	add		a,8
 58+  E0D9              ;	ld		e,a							; move 1 screen character right
 59+  E0D9              ;	jr		.PrintLoop
 60+  E0D9              ;.Clearstackandfinish:
 61+  E0D9              ;	pop		de
 62+  E0D9              ;	ret
 63+  E0D9              ;.NextLine:
 64+  E0D9              ;    ld      a,(hl)
 65+  E0D9              ;    cp      " "
 66+  E0D9              ;    ld      e,iyh
 67+  E0D9              ;    ld      a,d
 68+  E0D9              ;    add     a,8
 69+  E0D9              ;    ld      d,a
 70+  E0D9              ;    jr		.PrintLoop
 71+  E0D9
 72+  E0D9              ; Counts next word at hl, uses e and forces a wrap if it would over flow puts value in c
 73+  E0D9 E5           L1LenWordAtHL:          push    hl
 74+  E0DA D5                                   push    de
 75+  E0DB 7E           .CountLoop:             ld      a,(hl)
 76+  E0DC FE 00                                cp      0
 77+  E0DE 28 0F                                jr      z,.CountDone
 78+  E0E0 FE 20                                cp      32
 79+  E0E2 28 0B                                jr      z,.CountDone
 80+  E0E4 7B                                   ld      a,e
 81+  E0E5 C6 08                                add     a,8
 82+  E0E7 5F                                   ld      e,a
 83+  E0E8 FE EE                                cp      238
 84+  E0EA 30 07                                jr      nc,.TooLong
 85+  E0EC 23                                   inc     hl
 86+  E0ED 18 EC                                jr      .CountLoop
 87+  E0EF D1           .CountDone:             pop     de
 88+  E0F0 E1                                   pop     hl
 89+  E0F1 AF                                   xor     a
 90+  E0F2 C9                                   ret
 91+  E0F3 D1           .TooLong                pop     de
 92+  E0F4 E1                                   pop     hl
 93+  E0F5 3E FF                                ld      a,$FF
 94+  E0F7 C9                                   ret
 95+  E0F8
 96+  E0F8 7E           L1PrintWordAtHL:        ld      a,(hl)
 97+  E0F9 FE 00                                cp      0
 98+  E0FB C8                                   ret     z
 99+  E0FC FE 20                                cp      32
100+  E0FE 28 0F                                jr      z,.ItsASpace
101+  E100 FD E5                                push    iy
102+  E102 CD AB E0                             call	l1_print_char
103+  E105 FD E1                                pop     iy
104+  E107 7B                                   ld      a,e
105+  E108 C6 08                                add     a,8
106+  E10A 5F                                   ld      e,a
107+  E10B 23                                   inc     hl
108+  E10C C3 F8 E0                             jp      L1PrintWordAtHL
109+  E10F 23           .ItsASpace:             inc     hl      ;  Just a bodge for now
110+  E110 7B                                   ld      a,e
111+  E111 C6 08                                add     a,8
112+  E113 5F                                   ld      e,a
113+  E114 C9                                   ret
114+  E115
115+  E115
116+  E115              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
117+  E115              ; Now has full word level wrapping
118+  E115 FD 63        l1_print_at_wrap:       ld      iyh,e
119+  E117 7E           .PrintLoop:             ld		a,(hl)
120+  E118 FE 00                                cp		0
121+  E11A C8                                   ret		z
122+  E11B CD D9 E0     .CountWordCharLen:      call    L1LenWordAtHL
123+  E11E FE FF                                cp      $FF
124+  E120 28 06                                jr      z,.WrapNextLine
125+  E122 CD F8 E0     .NotTooLong:            call    L1PrintWordAtHL
126+  E125              ; Need to change to word wrap, so it will loop through string as before
127+  E125              ; but read up until a null or space, take the character count * 8 for pixels
128+  E125              ; if that is > 238 then force a premature line wrap
129+  E125 18 F0                                jr		.PrintLoop
130+  E127              .Clearstackandfinish:   ;op		de
131+  E127 C9                                   ret
132+  E128              .WrapNextLine:
133+  E128 FD 5C        .NextLine:              ld      e,iyh
134+  E12A 7A                                   ld      a,d
135+  E12B C6 08                                add     a,8
136+  E12D 57                                   ld      d,a
137+  E12E 18 E7                                jr		.PrintLoop
138+  E130
139+  E130
# file closed: ./Layer1Graphics/layer1_print_at.asm
147   E130
148   E130                  SLOT    LAYER2Addr
149   E130                  PAGE    BankLAYER2
150   E130                  ORG     LAYER2Addr
151   E000
152   E000                  INCLUDE "./Layer2Graphics/layer2_bank_select.asm"
# file opened: ./Layer2Graphics/layer2_bank_select.asm
  1+  E000
  2+  E000 00           varL2_BANK_SELECTED			 DB	0
  3+  E001 00           varL2_BUFFER_MODE            DB 0
  4+  E002
  5+  E002 3E 08        asm_l2_double_buffer_on:    ld      a,8
  6+  E004 32 01 E0                                 ld      (varL2_BUFFER_MODE),a
  7+  E007 C9                                       ret
  8+  E008
  9+  E008 AF           asm_l2_double_buffer_off:   xor     a
 10+  E009 32 01 E0                                 ld      (varL2_BUFFER_MODE),a
 11+  E00C C9                                       ret
 12+  E00D
 13+  E00D
 14+  E00D              ; "asm_l2_bank_select"
 15+  E00D              ; " a = sepecific bank mask value to select, does not set varL2_BANK_SELECTED"
 16+  E00D 57           asm_l2_bank_select:         ld      d,a
 17+  E00E 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
 18+  E011 F6 03                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK
 19+  E013 B2                                       or      d; | LAYER2_SHADOW_SCREEN_MASK
 20+  E014 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
 21+  E017 ED 79                                    out 	(c),a
 22+  E019 C9                                       ret
 23+  E01A              ;  "asm_l2_bank_select a = sepecific bank number to select, dsets varL2_BANK_SELECTED"
 24+  E01A 32 00 E0     asm_l2_bank_n_select:       ld		(varL2_BANK_SELECTED),a
 25+  E01D FE 00                                    cp		0
 26+  E01F 20 04                                    jr 		nz,.nottopbank
 27+  E021 3E 00        .topbank:                   ld		a,LAYER2_SHIFTED_SCREEN_TOP
 28+  E023 18 E8                                    jr		asm_l2_bank_select
 29+  E025 FE 01        .nottopbank:                cp		1
 30+  E027 20 04                                    jr 		nz,.notmiddlebank
 31+  E029 3E 40        .middlebank:                ld		a,LAYER2_SHIFTED_SCREEN_MIDDLE
 32+  E02B 18 E0                                    jr		asm_l2_bank_select
 33+  E02D 3E 80        .notmiddlebank:             ld		a,LAYER2_SHIFTED_SCREEN_BOTTOM ; default to bottom
 34+  E02F 18 DC                                    jr		asm_l2_bank_select
 35+  E031              		; Note no ret as its handled by above routines
 36+  E031
 37+  E031              ; "asm_l2_row_bank_select"
 38+  E031              ; "A (unsinged) = y row of pixel line from top, sets the bank to top middle or bottom and adjusts a reg to row memory address"
 39+  E031              ; "Could optimise by holding the previous bank but given its only an out statement it may not save T states at all"
 40+  E031              ; "destroys BC call de is safe a = adjusted poke pixel row"
 41+  E031 FE 40        asm_l2_row_bank_select:     cp 		64			; row < 64?
 42+  E033 30 11                                    jr 		nc, .l2rowGTE64
 43+  E035 08           .l2rowLT64:                 ex		af,af'
 44+  E036                                          ;ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP | LAYER2_SHADOW_SCREEN_MASK
 45+  E036 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
 46+  E039 F6 03                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
 47+  E03B 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
 48+  E03E ED 79                                    out 	(c),a
 49+  E040 AF                                       xor		a						; set a to 0
 50+  E041 32 00 E0                                 ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 51+  E044 08                                       ex		af,af'					; return pixel poke unharmed
 52+  E045 C9                                       ret
 53+  E046 FE 80        .l2rowGTE64:                cp 		128
 54+  E048 30 14                                    jr 		nc, .l2rowGTE128
 55+  E04A 08           .l2row64to127:              ex		af,af'
 56+  E04B                                  ;		ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE | LAYER2_SHADOW_SCREEN_MASK
 57+  E04B 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
 58+  E04E F6 43                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
 59+  E050 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
 60+  E053 ED 79                                    out 	(c),a
 61+  E055 3E 01                                    ld		a,1						; set a to 1
 62+  E057 32 00 E0                                 ld		(varL2_BANK_SELECTED),a	; save selected bank
 63+  E05A 08                                       ex		af,af'
 64+  E05B D6 40                                    sub		64
 65+  E05D C9                                       ret
 66+  E05E 08           .l2rowGTE128:               ex		af,af'
 67+  E05F                                  ;		ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM | LAYER2_SHADOW_SCREEN_MASK
 68+  E05F 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
 69+  E062 F6 83                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 70+  E064
 71+  E064 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
 72+  E067 ED 79                                    out 	(c),a
 73+  E069 3E 01                                    ld		a,1						; set a to 2
 74+  E06B 32 00 E0                                 ld		(varL2_BANK_SELECTED),a	; save selected bank
 75+  E06E 08                                       ex		af,af'
 76+  E06F D6 80                                    sub		128
 77+  E071 C9                                       ret
 78+  E072
# file closed: ./Layer2Graphics/layer2_bank_select.asm
153   E072                  INCLUDE "./Layer2Graphics/layer2_cls.asm"
# file opened: ./Layer2Graphics/layer2_cls.asm
  1+  E072
  2+  E072 00           l2_cls_byte	            DB 0
  3+  E073              ; ">DMA Command BLOCK"
  4+  E073
  5+  E073 83 C3 C7 CB  l2_fill                 DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
  5+  E077 7D
  6+  E078 72 E0        l2_fill_astrt           DW l2_cls_byte
  7+  E07A 00 40        l2_fill_length          DB $00,$40
  8+  E07C 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
  9+  E07F 00 00        l2_fill_bstrt           DB $00,$00
 10+  E081 82 CF B3 87                          DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
 11+  E085              l2_fill_cmd_len	        EQU $ - l2_fill
 12+  E085
 13+  E085              l2_cls_dma_bank:
 14+  E085              ; ">l2_cls_dma_bank"
 15+  E085              ; ">sets a bank to"
 16+  E085 32 72 E0     .set_colour:            ld (l2_cls_byte),a
 17+  E088 21 73 E0     .write_dma:             ld hl, l2_fill
 18+  E08B 06 12                                ld b, l2_fill_cmd_len
 19+  E08D 0E 6B                                ld	c,IO_DATAGEAR_DMA_PORT
 20+  E08F ED B3                                otir
 21+  E091 C9                                   ret
 22+  E092
 23+  E092 3E 00        l2_set_color_upper2:    ld      a,0
 24+  E094 CD 31 E0                             call asm_l2_row_bank_select
 25+  E097 3A 72 E0                             ld      a,(l2_cls_byte)
 26+  E09A CD 85 E0                             call l2_cls_dma_bank
 27+  E09D 3E 40                                ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
 28+  E09F CD 31 E0                             call asm_l2_row_bank_select
 29+  E0A2 3A 72 E0                             ld      a,(l2_cls_byte)
 30+  E0A5 CD 85 E0                             call l2_cls_dma_bank
 31+  E0A8 C9                                   ret
 32+  E0A9
 33+  E0A9
 34+  E0A9 3E 00        l2_cls_upper_two_thirds:ld a,0								; pretend we are plotting pixel on row 0 to force top selection
 35+  E0AB CD 31 E0                             call asm_l2_row_bank_select
 36+  E0AE 3E E3                                ld 	a,COLOUR_TRANSPARENT
 37+  E0B0 CD 85 E0                             call l2_cls_dma_bank
 38+  E0B3 3E 40                                ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
 39+  E0B5 CD 31 E0                             call asm_l2_row_bank_select
 40+  E0B8 3E E3                                ld 	a,COLOUR_TRANSPARENT
 41+  E0BA CD 85 E0                             call l2_cls_dma_bank
 42+  E0BD C9                                   ret
 43+  E0BE
 44+  E0BE 3E 80        l2_cls_lower_third:     ld a,128							; pretend we are plotting pixel on row 64 to force mid selection
 45+  E0C0 CD 31 E0                             call asm_l2_row_bank_select
 46+  E0C3 3E E3                                ld 	a,COLOUR_TRANSPARENT
 47+  E0C5 CD 85 E0                             call l2_cls_dma_bank
 48+  E0C8 C9                                   ret
 49+  E0C9
 50+  E0C9 CD A9 E0     l2_cls:                 call l2_cls_upper_two_thirds
 51+  E0CC CD BE E0                             call l2_cls_lower_third
 52+  E0CF C9                                   ret
 53+  E0D0
# file closed: ./Layer2Graphics/layer2_cls.asm
154   E0D0                  INCLUDE "./Layer2Graphics/layer2_initialise.asm"
# file opened: ./Layer2Graphics/layer2_initialise.asm
  1+  E0D0
  2+  E0D0 ED 91 12 08  l2_initialise:          nextreg		LAYER2_RAM_PAGE_REGISTER,          	LAYER2_SCREEN_BANK1
  3+  E0D4 ED 91 13 0B                          nextreg		LAYER2_RAM_SHADOW_REGISTER,     	LAYER2_SHADOW_BANK1
  4+  E0D8 ED 91 14 E3                          nextreg		TRANSPARENCY_COLOUR_REGISTER, 		COLOUR_TRANSPARENT
  5+  E0DC C9                                   ret
  6+  E0DD
# file closed: ./Layer2Graphics/layer2_initialise.asm
155   E0DD                  INCLUDE "./Layer2Graphics/l2_flip_buffers.asm"
# file opened: ./Layer2Graphics/l2_flip_buffers.asm
  1+  E0DD              l2_flip_buffers:        GetNextReg LAYER2_RAM_PAGE_REGISTER
  1+  E0DD C5          >            push bc
  1+  E0DE 01 3B 24    >                ld bc,$243B
  1+  E0E1 3E 12       >                    ld a,LAYER2_RAM_PAGE_REGISTER
  1+  E0E3 ED 79       >                    out (c),a
  1+  E0E5 04          >                    inc b
  1+  E0E6 ED 78       >                in a,(c)
  1+  E0E8 C1          >            pop bc
  2+  E0E9 57                                   ld      d,a
  3+  E0EA                                      GetNextReg LAYER2_RAM_SHADOW_REGISTER
  3+  E0EA C5          >            push bc
  3+  E0EB 01 3B 24    >                ld bc,$243B
  3+  E0EE 3E 13       >                    ld a,LAYER2_RAM_SHADOW_REGISTER
  3+  E0F0 ED 79       >                    out (c),a
  3+  E0F2 04          >                    inc b
  3+  E0F3 ED 78       >                in a,(c)
  3+  E0F5 C1          >            pop bc
  4+  E0F6 5F                                   ld      e,a
  5+  E0F7 ED 92 12                             nextreg LAYER2_RAM_PAGE_REGISTER, a
  6+  E0FA 7A                                   ld      a,d
  7+  E0FB ED 92 13                             nextreg LAYER2_RAM_SHADOW_REGISTER, a
  8+  E0FE C9                                   ret
  9+  E0FF
# file closed: ./Layer2Graphics/l2_flip_buffers.asm
156   E0FF                  INCLUDE "./Layer2Graphics/layer2_plot_pixel.asm"
# file opened: ./Layer2Graphics/layer2_plot_pixel.asm
  1+  E0FF              l2_plot_pixel:
  2+  E0FF              ; ">l2_plot_pixel b= row number, c = column number, a = pixel col"
  3+  E0FF F5           	push    af
  4+  E100 78               ld      a,b
  5+  E101              l2_pp_row_valid:
  6+  E101                  JumpIfAGTENusng ScreenHeight,l2_pp_dont_plot
  6+  E101 FE C0       >                        cp     ScreenHeight
  6+  E103 D2 11 E1    >                        jp		nc,l2_pp_dont_plot
  7+  E106 C5           	push    bc								; bank select destroys bc so need to save it
  8+  E107              ;	ld      a,b
  9+  E107 CD 31 E0     	call    asm_l2_row_bank_select
 10+  E10A C1           	pop     bc
 11+  E10B 47           	ld      b,a
 12+  E10C 60           	ld      h,b								; hl now holds ram address after bank select
 13+  E10D 69           	ld      l,c
 14+  E10E F1           	pop     af								; a = colour to plott
 15+  E10F 77           	ld      (hl),a
 16+  E110 C9           	ret
 17+  E111              l2_pp_dont_plot:
 18+  E111 F1               pop     af
 19+  E112 C9               ret
 20+  E113
 21+  E113              l2_plot_pixel_no_bank:
 22+  E113              ; ">l2_plot_pixel_no_bank b= row number, c = column number, a = pixel col"
 23+  E113              ; This version assues pixel is in the same bank as previously plotted ones. optimised for horizontal lines
 24+  E113 E5           	push 	hl
 25+  E114 60           	ld 		h,b								; hl now holds ram address after bank select
 26+  E115 69           	ld 		l,c
 27+  E116 77           	ld 		(hl),a
 28+  E117 E1           	pop		hl
 29+  E118 C9           	ret
 30+  E119
 31+  E119              l2_plot_pixel_y_test:
 32+  E119 F5           	push	af
 33+  E11A 78           	ld		a,b
 34+  E11B FE C0        	cp		192
 35+  E11D 30 03        	jr		nc,.clearup
 36+  E11F F1           	pop		af
 37+  E120 18 DD        	jr		l2_plot_pixel
 38+  E122              .clearup:
 39+  E122 F1           	pop		af
 40+  E123 C9           	ret
 41+  E124
 42+  E124              l2_point_pixel_y_safe:	MACRO
 43+  E124 ~            						push	hl
 44+  E124 ~            						push	bc
 45+  E124 ~            						call	l2_plot_pixel
 46+  E124 ~            						pop		bc
 47+  E124 ~            						pop		hl
 48+  E124              						ENDM
 49+  E124
# file closed: ./Layer2Graphics/layer2_plot_pixel.asm
157   E124                  INCLUDE "./Layer2Graphics/layer2_print_character.asm"
# file opened: ./Layer2Graphics/layer2_print_character.asm
  1+  E124
  2+  E124              l2_print_chr_at:
  3+  E124              ; "l2_print_chr_at, bc = col,row, d= character, e = colour"
  4+  E124              ; "Need a version that also prints absence of character"
  5+  E124 7A           	ld		a,d
  6+  E125 FE 20        	cp		32
  7+  E127 38 3F        	jr		c,.InvalidCharacter		; Must be between 32 and 127
  8+  E129 FE 7F        	cp		127
  9+  E12B 30 3B        	jr		nc,.InvalidCharacter
 10+  E12D              .ValidCharater:
 11+  E12D 26 00        	ld		h,0
 12+  E12F 6A           	ld		l,d
 13+  E130 29           	add		hl,hl						; * 2
 14+  E131 29           	add		hl,hl						; * 4
 15+  E132 29           	add		hl,hl						; * 8 to get byte address
 16+  E133 ED 34 00 3C  	add		hl,charactersetaddr			; hl = address of rom char
 17+  E137 04           	inc		b							; start + 1 pixel x and y as we only print 7x7
 18+  E138 23           	inc		hl							; skip first byte
 19+  E139 16 07        	ld		d,7
 20+  E13B              .PrintCharLoop:
 21+  E13B D5           	push	de
 22+  E13C 7E           	ld		a,(hl)
 23+  E13D FE 00        	cp		0
 24+  E13F 28 21        	jr		z,.NextRowNoBCPop
 25+  E141              .PrintARow:
 26+  E141 C5           	push	bc							; save row col
 27+  E142 16 07        	ld		d,7							; d is loop row number now
 28+  E144              .PrintPixelLoop:
 29+  E144 0C           	inc		c							; we start at col 1 not 0 so can move inc here
 30+  E145              .PrintTheRow:
 31+  E145 CB 27        	sla		a							; scroll char 1 pixel as we read from bit 7
 32+  E147 F5           	push	af							; save character byte
 33+  E148 CB 7F        	bit		7,a							; If left most pixel set then plot
 34+  E14A 20 04        	jr		nz,.PixelToPrint
 35+  E14C              .NoPixelToPrint:
 36+  E14C 3E E3        	ld		a,$E3
 37+  E14E 18 01        	jr		.HaveSetPixelColour
 38+  E150              .PixelToPrint:
 39+  E150 7B           	ld		a,e							; Get Colour
 40+  E151              .HaveSetPixelColour
 41+  E151 E5           	push	hl
 42+  E152              ;	push	bc							; at the moment we don't do paging on first plot so need to preserve BC
 43+  E152              .BankOnFirstOnly:
 44+  E152 F5           	push	af
 45+  E153 7A           	ld		a,d
 46+  E154 FE 07        	cp		7
 47+  E156 28 11        	jr		z,.PlotWithBank
 48+  E158              .PlotNoBank:
 49+  E158 F1           	pop		af
 50+  E159 60           	ld 		h,b								; hl now holds ram address after bank select
 51+  E15A 69           	ld 		l,c
 52+  E15B 77           	ld 		(hl),a
 53+  E15C              .IterateLoop:
 54+  E15C              ;	pop		bc
 55+  E15C E1           	pop		hl
 56+  E15D F1           	pop		af							; a= current byte shifted
 57+  E15E 15           	dec		d						 	; do dec after inc as we amy
 58+  E15F 20 E3        	jr		nz,.PrintPixelLoop
 59+  E161              .NextRow:
 60+  E161 C1           	pop		bc							; Current Col Row
 61+  E162              .NextRowNoBCPop:
 62+  E162 D1           	pop		de							; d= row loop
 63+  E163 04           	inc		b							; Down 1 row
 64+  E164 23           	inc		hl							; Next character byte
 65+  E165 15           	dec		d							; 1 done now
 66+  E166 20 D3        	jr		nz,.PrintCharLoop
 67+  E168              .InvalidCharacter:
 68+  E168 C9           	ret
 69+  E169              .PlotWithBank:
 70+  E169 F1           	pop		af
 71+  E16A CD FF E0     	call	l2_plot_pixel				; This will shift bc to poke row
 72+  E16D 18 ED        	jr		.IterateLoop
 73+  E16F
 74+  E16F              l2_print_at:
 75+  E16F              ; "l2_print_at bc= colrow, hl = addr of message, e = colour"
 76+  E16F              ; "No error trapping, if there is no null is will just cycle on the line"
 77+  E16F 7E           	ld	a,(hl)							; Return if empty string
 78+  E170 FE 00        	cp	0
 79+  E172 C8           	ret	z
 80+  E173 E5           	push	hl
 81+  E174 D5           	push	de
 82+  E175 C5           	push	bc
 83+  E176 57           	ld		d,a							; bc = pos, de = char and colour
 84+  E177 CD 24 E1     	call 	l2_print_chr_at
 85+  E17A C1           	pop		bc
 86+  E17B D1           	pop		de
 87+  E17C E1           	pop		hl
 88+  E17D              .Move8Pixlestoright:
 89+  E17D 08           	ex		af,af'
 90+  E17E 79           	ld		a,c
 91+  E17F C6 08        	add		8
 92+  E181 4F           	ld		c,a
 93+  E182 08           	ex		af,af'
 94+  E183 23           	inc		hl
 95+  E184 18 E9        	jr		l2_print_at					; Just loop until 0 found
 96+  E186
 97+  E186
 98+  E186              ; "l2_print_chr_at, bc = col,row, d= character, e = colour"
 99+  E186              ; "Need a version that also prints absence of character"
100+  E186              ; removed blank line optimisation as we need spaces printed
101+  E186 7A           l2_print_7chr_at:       ld		a,d
102+  E187 FE 1F                                cp		31
103+  E189 38 3D                                jr		c,.InvalidCharacter		; Must be between 32 and 127
104+  E18B FE 7F                                cp		127
105+  E18D 30 39                                jr		nc,.InvalidCharacter
106+  E18F 26 00        .ValidCharater:         ld		h,0
107+  E191 6A                                   ld		l,d
108+  E192 29                                   add		hl,hl						; * 2
109+  E193 29                                   add		hl,hl						; * 4
110+  E194 29                                   add		hl,hl						; * 8 to get byte address
111+  E195 ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
112+  E199 04                                   inc		b							; start + 1 pixel x and y as we only print 7x7
113+  E19A 23                                   inc		hl							; skip first byte
114+  E19B 16 07                                ld		d,7
115+  E19D D5           .PrintCharLoop:         push	de
116+  E19E 7E                                   ld		a,(hl)
117+  E19F                                      ;cp		0
118+  E19F                                      ;jr		z,.NextRowNoBCPop
119+  E19F C5           .PrintARow:             push	bc							; save row col
120+  E1A0 16 06                                ld		d,6							; d is loop row number now
121+  E1A2 0C           .PrintPixelLoop:        inc		c							; we start at col 1 not 0 so can move inc here
122+  E1A3 28 1C                                jr		z,.NextRow
123+  E1A5 CB 27                                sla		a							; scroll char 1 pixel as we read from bit 7
124+  E1A7 F5                                   push	af							; save character byte
125+  E1A8 CB 7F                                bit		7,a							; If left most pixel set then plot
126+  E1AA 20 04                                jr		nz,.PixelToPrint
127+  E1AC 3E E3        .NoPixelToPrint:        ld		a,$E3
128+  E1AE 18 01                                jr		.HaveSetPixelColour
129+  E1B0 7B           .PixelToPrint:          ld		a,e							; Get Colour
130+  E1B1 E5           .HaveSetPixelColour		push	hl
131+  E1B2                                      ;	push	bc							; at the moment we don't do paging on first plot so need to preserve BC
132+  E1B2 F5           .BankOnFirstOnly:       push	af
133+  E1B3 7A                                   ld		a,d
134+  E1B4 FE 06                                cp		6
135+  E1B6 28 11                                jr		z,.PlotWithBank
136+  E1B8 F1           .PlotNoBank:            pop		af
137+  E1B9 60                                   ld 		h,b								; hl now holds ram address after bank select
138+  E1BA 69                                   ld 		l,c
139+  E1BB 77                                   ld 		(hl),a
140+  E1BC              .IterateLoop:	        ;	pop		bc
141+  E1BC E1                                   pop		hl
142+  E1BD F1                                   pop		af							; a= current byte shifted
143+  E1BE 15                                   dec		d						 	; do dec after inc as we amy
144+  E1BF 20 E1                                jr		nz,.PrintPixelLoop
145+  E1C1 C1           .NextRow:               pop		bc							; Current Col Row
146+  E1C2 D1           .NextRowNoBCPop:	    pop		de							; d= row loop
147+  E1C3 04                                   inc		b							; Down 1 row
148+  E1C4 23                                   inc		hl							; Next character byte
149+  E1C5 15                                   dec		d							; 1 done now
150+  E1C6 20 D5                                jr		nz,.PrintCharLoop
151+  E1C8 C9           .InvalidCharacter:      ret
152+  E1C9 F1           .PlotWithBank:          pop		af
153+  E1CA CD FF E0                             call	l2_plot_pixel				; This will shift bc to poke row
154+  E1CD 18 ED                                jr		.IterateLoop
155+  E1CF
156+  E1CF              ; "l2_print_7at bc= colrow, hl = addr of message, e = colour"
157+  E1CF              ; "No error trapping, if there is no null is will just cycle on the line"
158+  E1CF 7E           l2_print_7at:           ld	a,(hl)							; Return if empty string
159+  E1D0 FE 00                                cp	0
160+  E1D2 C8                                   ret	z
161+  E1D3 E5                                   push	hl
162+  E1D4 D5                                   push	de
163+  E1D5 C5                                   push	bc
164+  E1D6 57                                   ld		d,a							; bc = pos, de = char and colour
165+  E1D7 CD 86 E1                             call 	l2_print_7chr_at
166+  E1DA C1                                   pop		bc
167+  E1DB D1                                   pop		de
168+  E1DC E1                                   pop		hl
169+  E1DD 08           .Move7Pixlestoright:	ex		af,af'
170+  E1DE 79                                   ld		a,c
171+  E1DF C6 07                                add		7
172+  E1E1 4F                                   ld		c,a
173+  E1E2 08                                   ex		af,af'
174+  E1E3 23                                   inc		hl
175+  E1E4 18 E9                                jr		l2_print_7at					; Just loop until 0 found
176+  E1E6
177+  E1E6
# file closed: ./Layer2Graphics/layer2_print_character.asm
158   E1E6                  INCLUDE "./Layer2Graphics/layer2_draw_box.asm"
# file opened: ./Layer2Graphics/layer2_draw_box.asm
  1+  E1E6              ; "l2_draw_thick_box bc=rowcol, de=heightwidth h=color"
  2+  E1E6              ; TODO DMA Optimise
  3+  E1E6 C5 D5 E5     l2_draw_fill_box:       push    bc,,de,,hl
  4+  E1E9 53                                   ld      d,e
  5+  E1EA 5C                                   ld      e,h
  6+  E1EB CD 60 E2                             call    l2_draw_horz_line           ; "bc = left side row,col, d = length, e = color"
  7+  E1EE E1 D1 C1                             pop     bc,,de,,hl
  8+  E1F1 04                                   inc     b
  9+  E1F2 15                                   dec     d
 10+  E1F3 C8                                   ret     z
 11+  E1F4 18 F0                                jr      l2_draw_fill_box
 12+  E1F6
 13+  E1F6              ; "l2_draw_box bc=rowcol, de=heightwidth a=color"
 14+  E1F6 C5 D5 F5     l2_draw_box:            push	bc,,de,,af
 15+  E1F9 53                                   ld		d,e
 16+  E1FA 5F                                   ld		e,a
 17+  E1FB 14                                   inc		d
 18+  E1FC CD 60 E2                             call	l2_draw_horz_line
 19+  E1FF F1 D1 C1                             pop		bc,,de,,af
 20+  E202 C5 D5 F5     .bottomhorzline:	    push	bc,,de,,af
 21+  E205 67                                   ld		h,a							;save color whilst b = row + height
 22+  E206 78                                   ld		a,b
 23+  E207 82                                   add		a,d
 24+  E208 47                                   ld		b,a
 25+  E209 53                                   ld		d,e							; d = width
 26+  E20A 14                                   inc		d							; Extra pixel for width
 27+  E20B 5C                                   ld		e,h							; e = colour
 28+  E20C CD 60 E2                             call	l2_draw_horz_line
 29+  E20F F1 D1 C1                             pop		bc,,de,,af
 30+  E212 C5 D5 F5     .leftvertline:          push	bc,,de,,af
 31+  E215 04                                   inc		b							; save 2 pixles
 32+  E216 15                                   dec		d
 33+  E217 5F                                   ld		e,a							; e = color
 34+  E218 CD B1 E2                             call	l2_draw_vert_line
 35+  E21B F1 D1 C1                             pop		bc,,de,,af
 36+  E21E 04           .rightvertline:         inc		b							; save 2 pixles
 37+  E21F 15                                   dec		d
 38+  E220 67                                   ld		h,a							;save color whilst c = col + width
 39+  E221 79                                   ld		a,c
 40+  E222 83                                   add		a,e
 41+  E223 4F                                   ld		c,a
 42+  E224 5C                                   ld		e,h							; e = color
 43+  E225 CD B1 E2                             call	l2_draw_vert_line
 44+  E228 C9                                   ret
 45+  E229
# file closed: ./Layer2Graphics/layer2_draw_box.asm
159   E229                  INCLUDE "./Layer2Graphics/asm_l2_plot_horizontal.asm"
# file opened: ./Layer2Graphics/asm_l2_plot_horizontal.asm
  1+  E229
  2+  E229              ;; NOTE DMA is little endian
  3+  E229 00           l2_horz_pixel           DB 0
  4+  E22A
  5+  E22A 83 C3 C7 CB  l2_horz_line            DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
  5+  E22E 7D
  6+  E22F 29 E2        l2_horz_colr            DW l2_horz_pixel
  7+  E231 00           l2_horz_lenlo           DB 0
  8+  E232 00           l2_horz_lenhi           DB 0
  9+  E233 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY, DMA_WR2_P2INC_MEMORY, DMA_WR4_CONT_MODE
 10+  E236 00 00        l2_horz_target          DB $00, $00
 11+  E238 CF 87                                DB DMA_LOAD, DMA_ENABLE
 12+  E23A              l2_horz_cmd_len	        EQU $ - l2_horz_line
 13+  E23A
 14+  E23A
 15+  E23A              ; "l2_draw_horz_dma"
 16+  E23A              ; "plot at bc for length d colour e using dma, assumes bank already selected"
 17+  E23A 7B           l2_draw_horz_dma:       ld		a,e                                               ; T=4      ;
 18+  E23B 32 29 E2                             ld		(l2_horz_pixel),a                                 ; T=13     ;
 19+  E23E 5A                                   ld      e,d ; saved 3 t states ld		a,d                                               ; T=4      ; e=d   4
 20+  E23F 16 00                                ld      d,0; saved 3 t states ld 		(l2_horz_lenlo),a                                 ; T=13     ; d = 0  7
 21+  E241 ED 53 31 E2                          ld      (l2_horz_lenlo),de; saved 3 t states xor 	a                                                 ; T=4      ; t 20  31
 22+  E245                                      ; saved 3 t states ld ld 		(l2_horz_lenhi),a                                 ; T=13     ;
 23+  E245                                    ; saved 4 t states  ld		h,b                           ;          ;
 24+  E245                                    ; saved 4 t states  ld		l,c                           ;          ;
 25+  E245 ED 43 36 E2                          ld      (l2_horz_target),bc ; saved 4 t states  was , hl  ; T=20     ;
 26+  E249 21 2A E2     .write_dma:             ld 		hl, l2_horz_line                                  ;          ;
 27+  E24C 06 10                                ld 		b, l2_horz_cmd_len                                ;
 28+  E24E 0E 6B                                ld		c,IO_DATAGEAR_DMA_PORT                            ;
 29+  E250 ED B3                                otir                                                      ;
 30+  E252 C9                                   ret
 31+  E253
 32+  E253              ; "bc = left side row,col, d = length, e = color"
 33+  E253 D5           l2_draw_horz_dma_bank:  push 	de							; save length and colour
 34+  E254 C5                                   push 	bc							; save row col
 35+  E255 78                                   ld   	a,b
 36+  E256 CD 31 E0                             call 	asm_l2_row_bank_select		; now we have the correct bank, its a horizontal line so bank will not shift
 37+  E259 C1                                   pop  	bc
 38+  E25A 47                                   ld	 	b,a	       					; fixed row by the call we can go straight into HL with row col
 39+  E25B D1                                   pop  	de							; get length back
 40+  E25C CD 3A E2                             call    l2_draw_horz_dma
 41+  E25F C9                                   ret
 42+  E260
 43+  E260              ; "l2_draw_horz_line"
 44+  E260              ; "bc = left side row,col, d = length, e = color"
 45+  E260              ; "optimisation if above min pix is will use dma call SCREEN_HOZ_MIN_PIX not implemented yet"
 46+  E260 7A           l2_draw_horz_line:      ld		a,d
 47+  E261 FE 00                                cp 		0							; if its zero length then just return
 48+  E263 C8           .zerolengthexit:        ret		z
 49+  E264 FE 01        .isitlen1:              cp 		1
 50+  E266 CA 88 E2                             jp 		z,.l2_draw_horz_line_1
 51+  E269 FE 0A        .longenoughtfordma:     cp  10
 52+  E26B C3 53 E2                             jp  l2_draw_horz_dma_bank
 53+  E26E D5 C5        .plottableline:         push 	de,,bc  					; save length and colour an d row col
 54+  E270 78                                   ld   	a,b
 55+  E271 CD 31 E0                             call 	asm_l2_row_bank_select		; now we have the correct bank, its a horizontal line so bank will not shift
 56+  E274 C1                                   pop  	bc
 57+  E275 67                                   ld	 	h,a	       					; fixed row by the call we can go straight into HL with row col
 58+  E276 69                                   ld   	l,c
 59+  E277 D1                                   pop  	de							; get length back
 60+  E278 79           .cliptest:              ld	 	a,c							; get column + length
 61+  E279 42                                   ld  	b,d  						; speculate that we don't clip by pre-loading b with length
 62+  E27A 82                                   add  	a,d
 63+  E27B 30 06                                jr   	nc, .l2_draw_horz_plot_loop	; if carry is set c+d > 255
 64+  E27D 3E FF        .clipat255:             ld   	a,$FF
 65+  E27F 91                                   sub  	c							; a holds clipped length
 66+  E280 47                                   ld 		b, a 						; so now hl holds poke address  b = clipped length e = colour
 67+  E281 18 00                                jr		.l2_draw_horz_plot_loop
 68+  E283 73           .l2_draw_horz_plot_loop:ld (hl),e							; loop poking hl with e for b pixels
 69+  E284 23                                   inc hl
 70+  E285 10 FC                                djnz .l2_draw_horz_plot_loop
 71+  E287 C9                                   ret
 72+  E288 7B           .l2_draw_horz_line_1:   ld		a,e
 73+  E289 C3 FF E0                             jp		l2_plot_pixel				; hijack return
 74+  E28C
 75+  E28C              ; "l2_draw_horz_line_to"
 76+  E28C              ; "bc = left side row,col, d right pixel, e = color"
 77+  E28C 7A           l2_draw_horz_line_to:   ld 		a,d
 78+  E28D B9                                   cp 		c
 79+  E28E 30 04                                jr		nc, .noswap
 80+  E290 28 07                                jr      z, .singlepixel
 81+  E292 51           .swap:                  ld		d,c
 82+  E293 4F                                   ld		c,a
 83+  E294 7A           .noswap:                ld		a,d
 84+  E295 91                                   sub		c
 85+  E296              ;                        dec		a							; so now its length not offset
 86+  E296 57                                   ld		d,a
 87+  E297 18 C7                                jr 		l2_draw_horz_line			; hijack routine and return statements
 88+  E299 7B           .singlepixel:           ld		a,e
 89+  E29A C3 FF E0                             jp		l2_plot_pixel				; hijack return
 90+  E29D
# file closed: ./Layer2Graphics/asm_l2_plot_horizontal.asm
160   E29D                  INCLUDE "./Layer2Graphics/asm_l2_plot_vertical.asm"
# file opened: ./Layer2Graphics/asm_l2_plot_vertical.asm
  1+  E29D              ; ">l2_draw_vert_segment"
  2+  E29D              ; ">hl = bank adjusted pixel poke address d = length, e = color"
  3+  E29D              ; ">will always clip once h = 64 even if length > 64 destroys a and hl, d = resudual length not plotted"
  4+  E29D 7A           l2_draw_vert_segment:   ld		a,d
  5+  E29E FE 00        .emptylinecheck:	    cp 		0
  6+  E2A0 C8                                   ret		z
  7+  E2A1 FE 01        .justonepixel	        cp		1
  8+  E2A3 20 02                                jr		nz, .multiplepixelsLoop
  9+  E2A5 73                                   ld		(hl),e
 10+  E2A6 C9                                   ret
 11+  E2A7              .multiplepixelsLoop:
 12+  E2A7 7C           .endofbankcheck:        ld   	a,h
 13+  E2A8 FE 40                                cp   	64
 14+  E2AA D0                                   ret		nc							; check before we poke data if we have hit a boundary
 15+  E2AB 73           .canplotapixel:         ld   	(hl),e						; set colour
 16+  E2AC 24                                   inc 	h							; we don't check here else we would need a dec d on ret could do for optimisation of loop though
 17+  E2AD 15                                   dec		d
 18+  E2AE C8                                   ret		z
 19+  E2AF 18 F6                                jr		.multiplepixelsLoop
 20+  E2B1
 21+  E2B1              ; ">l2_draw_vert_line"
 22+  E2B1              ; ">bc = row col d = length, e = color"
 23+  E2B1 78           l2_draw_vert_line:      ld 		a,b
 24+  E2B2 FE C0        .offscreencheck:        cp 		SCREEN_HEIGHT
 25+  E2B4 D0                                   ret 	nc							; can't start off the screen
 26+  E2B5 7A           .emptylinecheck:        ld		a,d
 27+  E2B6 FE 00                                cp		0
 28+  E2B8 C8                                   ret		z
 29+  E2B9 FE 01                                cp		1
 30+  E2BB 20 04                                jr		nz,.multiplepixels
 31+  E2BD CD FF E0     .itsonepixel:           call	l2_plot_pixel
 32+  E2C0 C9                                   ret
 33+  E2C1              .multiplepixels:						; so now we have at least 2 pixels to plot
 34+  E2C1 7A           .clipto192:             ld		a,d							; get length
 35+  E2C2 80                                   add		a,b							; a= row + length
 36+  E2C3 38 04                                jr		c,.needtoclip				; if it was > 255 then there is a definite need
 37+  E2C5 FE C0                                cp		SCREEN_HEIGHT
 38+  E2C7 38 08                                jr		c, .noclipneeded
 39+  E2C9 78           .needtoclip             ld		a,b
 40+  E2CA 82                                   add		a,d
 41+  E2CB D6 C0                                sub		SCREEN_HEIGHT
 42+  E2CD 67                                   ld		h,a							; use h as a temp holding for (row + length) - 192
 43+  E2CE 7A                                   ld		a,d
 44+  E2CF 94                                   sub		h
 45+  E2D0 57                                   ld		d,a							; d = length - ((row + length) - 192)
 46+  E2D1              ; so now BC = row col, d = length clipped, e = color
 47+  E2D1 78           .noclipneeded:          ld		a,b
 48+  E2D2 C5 D5                                push	bc,,de
 49+  E2D4 CD 31 E0                             call 	asm_l2_row_bank_select
 49+  E2D7               	 	; we now have poke address and a variable holding current bank number
 50+  E2D7 D1 C1                                pop		bc,,de
 51+  E2D9 67                                   ld		h,a							; b now tolds target pixel for first plot
 52+  E2DA 69                                   ld		l,c  						; and c holds pixel column for plotting
 53+  E2DB CD 9D E2                             call 	l2_draw_vert_segment		; draw seg, d = pixels remaining
 54+  E2DE 7A                                   ld		a,d							; a and d = nbr pixels remaining
 55+  E2DF FE 00                                cp		0
 56+  E2E1 28 27                                jr		z, .doneplotting
 57+  E2E3 3A 00 E0     .anotherbank:           ld		a, (varL2_BANK_SELECTED)
 58+  E2E6 3C                                   inc		a
 59+  E2E7 06 00                                ld		b,0
 60+  E2E9 C5 D5                                push	bc,,de
 61+  E2EB CD 1A E0                             call 	asm_l2_bank_n_select
 62+  E2EE D1 C1                                pop     bc,,de
 63+  E2F0 60                                   ld		h,b							; b now tolds target pixel for first plot
 64+  E2F1 69                                   ld		l,c  						; and c holds pixel column for plotting
 65+  E2F2 CD 9D E2                             call	l2_draw_vert_segment
 66+  E2F5 7A                                   ld		a,d
 67+  E2F6 FE 00                                cp		0
 68+  E2F8 28 10                                jr		z,.doneplotting
 69+  E2FA 3A 00 E0     .yetanotherbank:        ld		a, (varL2_BANK_SELECTED)
 70+  E2FD 3C                                   inc		a
 71+  E2FE 06 00                                ld		b,0
 72+  E300 C5 D5                                push	bc,,de
 73+  E302 CD 1A E0                             call 	asm_l2_bank_n_select
 74+  E305 D1                                   pop		de
 75+  E306 E1                                   pop		hl							; hl = bc
 76+  E307 CD 9D E2                             call	l2_draw_vert_segment		; we have now hit 192 pixels so done
 77+  E30A C9           .doneplotting:	        ret
 78+  E30B
 79+  E30B              ; ">l2_draw_vert_line_to"
 80+  E30B              ; ">bc = row col d = to position, e = color"
 81+  E30B 78           l2_draw_vert_line_to:   ld		a,b
 82+  E30C BA                                   cp		d
 83+  E30D 38 02                                jr		c, .noyswap
 84+  E30F 42           .yswap:                 ld		b,d			; Swap round row numbers so we are always incrementing
 85+  E310 57                                   ld		d,a			; now we have a top to bottom to we we can calc length from bc
 86+  E311 7A           .noyswap:               ld		a,d 		; we still may have d in a but only if it was bottom to top
 87+  E312 90                                   sub		b
 88+  E313 3C                                   inc		a			; so now its length not offset
 89+  E314 57                                   ld		d,a
 90+  E315 18 9A                                jr		l2_draw_vert_line	; we can hijack its clipping, 0 check and return logic
 91+  E317                                      ; no return needed
 92+  E317
# file closed: ./Layer2Graphics/asm_l2_plot_vertical.asm
161   E317                  INCLUDE "./Layer2Graphics/layer2_plot_diagonal.asm"
# file opened: ./Layer2Graphics/layer2_plot_diagonal.asm
  1+  E317
  2+  E317              l2_draw_box_to:
  3+  E317              ; ">l2_draw_box_to bc=rowcol, de=torowcol a=color"
  4+  E317              ; ">NOT IMPLEMENTED YET"
  5+  E317 C9           	ret
  6+  E318
  7+  E318              ;; Note l2stepx is done via self modifying code rather than an if for speed
  8+  E318              ;; l2stepx1 and l2stepx2 are the addresses to stick the inc or dec in
  9+  E318              l2decbstep	EQU $05
 10+  E318              l2incbstep	EQU	$04
 11+  E318              l2deccstep	EQU $0D
 12+  E318              l2inccstep	EQU	$0C
 13+  E318              		; l2 deltas are signed
 14+  E318 00 00        l2deltaY	DW	0
 15+  E31A 00 00        l2deltaX	DW	0
 16+  E31C 00           l2deltaYsq	db	0
 17+  E31D 00           l2deltaXsq	db	0
 18+  E31E 00           l2deltaYn	db	0
 19+  E31F 00           l2deltaXn	db	0
 20+  E320 00           l2deltaYsqn	db	0
 21+  E321 00           l2deltaXsqn	db	0
 22+  E322 00           l2linecolor	db	0
 23+  E323 00 00        l2fraction	dw	0
 24+  E325 00 00        l2e2		dw	0
 25+  E327 00           l2way		db	0
 26+  E328 00 00        l2targetPtr	dw	0
 27+  E32A              ;; These arrays should be 192 but if we use 256 then getting array2 value is just inc h rather than indexing again.
 28+  E32A 00 00 00...  l2targetArray1 ds	256
 29+  E42A 00 00 00...  l2targetArray2 ds	256
 30+  E52A              ;; Using Bresenham Algorithm draw a diagonal line top to bottom. First we must sort of course
 31+  E52A              ;;plotLine(int x0, int y0, int x1, int y1)
 32+  E52A              ;;    dx =  abs(x1-x0);
 33+  E52A              ;;    sx = x0<x1 ? 1 : -1;
 34+  E52A              ;;    dy = -abs(y1-y0);
 35+  E52A              ;;    sy = y0<y1 ? 1 : -1;
 36+  E52A              ;;    err = dx+dy;  /* error value e_xy */
 37+  E52A              ;;    while (true)   /* loop */
 38+  E52A              ;;        plot(x0, y0);
 39+  E52A              ;;        if (x0==x1 && y0==y1) break;
 40+  E52A              ;;        e2 = 2*err;
 41+  E52A              ;;        if (e2 >= dy) /* e_xy+e_x > 0 */
 42+  E52A              ;;            err += dy;
 43+  E52A              ;;            x0 += sx;
 44+  E52A              ;;        end if
 45+  E52A              ;;        if (e2 <= dx) /* e_xy+e_y < 0 */
 46+  E52A              ;;            err += dx;
 47+  E52A              ;;            y0 += sy;
 48+  E52A              ;;        end if
 49+  E52A              ;;    end while
 50+  E52A              ; ">l2_draw_diagonal_save, bc = y0,x0 de=y1,x1,a=array nbr ESOURCE LL30 or LION"
 51+  E52A              ; ">hl will be either l2targetArray1 or 2"
 52+  E52A              ; NOTE IF WE INTERLEAVE THESE TWO TABLES WE COUDL READ BOTH X POS as a 16 bit read
 53+  E52A FE 01        l2_draw_diagonal_save:  cp		1
 54+  E52C 28 06                                jr		z,l2S_ItsArray1
 55+  E52E 21 2A E4                             ld		hl,l2targetArray2
 56+  E531 C3 37 E5                             jp		l2S_setTarget
 57+  E534 21 2A E3     l2S_ItsArray1:	        ld		hl,l2targetArray1
 58+  E537 22 28 E3     l2S_setTarget:	        ld		(l2targetPtr),hl
 59+  E53A              ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
 60+  E53A 32 22 E3                             ld		(l2linecolor),a					;save colour for later
 61+  E53D 21 00 00                             ld		hl,0                            ;
 62+  E540 22 1A E3                             ld		(l2deltaX),hl                   ;
 63+  E543 22 18 E3                             ld		(l2deltaY),hl                   ; initlaise deltas as we will only be loading 8 bit in there but workign in 16 bit later
 64+  E546 78           l2S_preSort:            ld		a,b								;
 65+  E547                                      JumpIfALTNusng	d,l2S_noYSort			; we must have Y1 < Y2 (if eqyal then verical line picked up earlier
 65+  E547 BA          >                        cp      d
 65+  E548 DA 50 E5    >                        jp		c, l2S_noYSort
 66+  E54B              l2S_SortBasedOnY:	    ldhlbc									;
 66+  E54B 60          >                        ld		h,b
 66+  E54C 69          >                        ld		l,c
 67+  E54D EB                                   ex		de,hl                           ;
 68+  E54E                                      ldbchl									; swap over bc and de using hl as an intermediate
 68+  E54E 44          >                        ld		b,h
 68+  E54F 4D          >                        ld		c,l
 69+  E550 DD 62        l2S_noYSort:		    ld		ixh,d							; ixh now holds target Y coord post sorting
 70+  E552 DD 6B                                ld		ixl,e							; ixl now holds target X coord post sorting
 71+  E554 79           l2S_setXLen:            ld		a,c                             ;
 72+  E555                                      JumpIfALTNusng e,l2S_PosXLen			; if x1 < x2 then we have a positive increment
 72+  E555 BB          >                        cp      e
 72+  E556 DA 62 E5    >                        jp		c, l2S_PosXLen
 73+  E559 79           l2S_NegXLen:            ld		a,c                             ;
 74+  E55A 93                                   sub     e                               ;
 75+  E55B 32 1A E3                             ld		(l2deltaX),a					; As x1 > x2 we do deltaX = X1 - X2
 76+  E55E 3E 0D                                ld		a,l2deccstep					; and set the value for inc dec self modifying to Dec
 77+  E560 18 07                                jr		l2S_XINCDEC
 78+  E562 7B           l2S_PosXLen:	        ld		a,e                             ;
 79+  E563 91                                   sub		c                               ;
 80+  E564 32 1A E3                             ld 		(l2deltaX),a                    ; As x1 < x2 we do deltaX = X2 - X1
 81+  E567 3E 0C                                ld		a,l2inccstep                    ; and set the value for inc dec self modifying to Inc
 82+  E569              l2S_XINCDEC:
 83+  E569 32 D5 E5     	ld		(l2S_adjustCol),a				;
 84+  E56C 32 05 E6     	ld		(l2S_adjustCol2),a				; update self modifying code for X update with inc or dec from above
 85+  E56F              l2S_setYLen
 86+  E56F 7A           	ld		a,d							 	; presorted on Y so it is now always positive
 87+  E570 90           	sub		b
 88+  E571 32 18 E3     	ld 		(l2deltaY),a					; DeltaY = Y2 - Y1
 89+  E574              l2S_setErr:									;  LD H  := (D'-E')/2    round up if +ve or down if -ve
 90+  E574              ldS_FracDYltDX:								;
 91+  E574 2A 18 E3     	ld		hl,(l2deltaY)					; Fraction = dY - dX
 92+  E577 ED 5B 1A E3  	ld		de,(l2deltaX)
 93+  E57B              	ClearCarryFlag
 93+  E57B B7          >                        or a
 94+  E57C ED 52        	sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
 95+  E57E EB           	ex		de,hl
 96+  E57F FD 62        	ld		iyh,d							; we will use IY reg for fractions
 97+  E581 FD 6B        	ld		iyl,e
 98+  E583 F2 A8 E5     	jp		p,l2S_fracIsPositive
 99+  E586              l2S_fracIsNegative:
100+  E586              	NegIY
100+  E586 AF          >                    xor a
100+  E587 FD 95       >                    sub iyl
100+  E589 FD 6F       >                    ld iyl,a
100+  E58B 9F          >                    sbc a,a
100+  E58C FD 94       >                    sub iyh
100+  E58E FD 67       >                    ld iyh,a
101+  E590              	ShiftIYRight1
101+  E590 FD 7C       >			   ld 	a,iyh
101+  E592 CB 3F       >			   srl 	a
101+  E594 FD 67       >			   ld	iyh,a
101+  E596 FD 7D       >			   ld 	a,iyl
101+  E598 1F          >			   rra
101+  E599 FD 6F       >			   ld	iyl,a
102+  E59B              	NegIY
102+  E59B AF          >                    xor a
102+  E59C FD 95       >                    sub iyl
102+  E59E FD 6F       >                    ld iyl,a
102+  E5A0 9F          >                    sbc a,a
102+  E5A1 FD 94       >                    sub iyh
102+  E5A3 FD 67       >                    ld iyh,a
103+  E5A5 C3 B3 E5     	jp		l2S_SkipCalcInc					; so we have a negative frac
104+  E5A8              l2S_fracIsPositive:
105+  E5A8              	ShiftIYRight1
105+  E5A8 FD 7C       >			   ld 	a,iyh
105+  E5AA CB 3F       >			   srl 	a
105+  E5AC FD 67       >			   ld	iyh,a
105+  E5AE FD 7D       >			   ld 	a,iyl
105+  E5B0 1F          >			   rra
105+  E5B1 FD 6F       >			   ld	iyl,a
106+  E5B3              l2S_SkipCalcInc:
107+  E5B3              l2S_Loop:									; As we loop, bc = to plot current XY
108+  E5B3 2A 28 E3     	ld		hl,(l2targetPtr)				; Insert into respective array
109+  E5B6 78           	ld		a,b
110+  E5B7 ED 31        	add		hl,a
111+  E5B9 71           	ld		(hl),c
112+  E5BA              l2S_CheckIfEnd:
113+  E5BA DD 7C        	ld		a,ixh
114+  E5BC              	JumpIfAGTENusng	  b,l2S_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
114+  E5BC B8          >                        cp     b
114+  E5BD D2 C3 E5    >                        jp		nc,l2S_CheckXPos
115+  E5C0 C3 C7 E5     	jp		l2S_Continue
116+  E5C3              l2S_CheckXPos:
117+  E5C3 79           	ld		a,c
118+  E5C4              	ReturnIfAGTENusng ixl					; if X1 has reached or exceeded X2 then we are done
118+  E5C4 DD BD       >                        cp    ixl
118+  E5C6 D0          >                        ret	 nc
119+  E5C7              l2S_Continue:
120+  E5C7              l2S_HNegative:
121+  E5C7 FD 7C        	ld		a,iyh
122+  E5C9 CB 7F        	bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
123+  E5CB 28 0B        	jr		z,l2S_ErrNotNegative			;
124+  E5CD              l2S_ErrNegative:								; if its a negative error update X
125+  E5CD 3A 18 E3     	ld		a,(l2deltaY)
126+  E5D0 16 00        	ld		d,0
127+  E5D2 5F           	ld		e,a
128+  E5D3 FD 19        	add		iy,de							; add deltaY(unsinged) to l2fraction
129+  E5D5              l2S_adjustCol:
130+  E5D5 00           	nop										; this is our inc/dec of X
131+  E5D6 18 DB        	jr		l2S_Loop							; repeat loop
132+  E5D8              l2S_ErrNotNegative:
133+  E5D8 FD 7C        	ld		a,iyh
134+  E5DA FD B5        	or		iyl
135+  E5DC              	JumpIfAIsZero l2S_ErrZero					; if there is no error then goto zeroerror
135+  E5DC A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
135+  E5DD CA F6 E5    >                        jp	z, l2S_ErrZero
136+  E5E0              l2S_ErrPositive:								; if its a positive error then we update Y
137+  E5E0              	lddeiy
137+  E5E0 FD 54       >                        ld		d,iyh
137+  E5E2 FD 5D       >                        ld		e,iyl
138+  E5E4 EB           	ex		de,hl
139+  E5E5 16 00        	ld		d,0
140+  E5E7 3A 1A E3     	ld		a,(l2deltaX)
141+  E5EA 5F           	ld		e,a
142+  E5EB              	ClearCarryFlag
142+  E5EB B7          >                        or a
143+  E5EC ED 52        	sbc		hl,de
144+  E5EE EB           	ex		de,hl
145+  E5EF              	ldiyde
145+  E5EF FD 62       >                        ld		iyh,d
145+  E5F1 FD 6B       >                        ld		iyl,e
146+  E5F3              l2S_adjustRow:									; move Y down by one
147+  E5F3 04           	inc		b
148+  E5F4 18 BD        	jr		l2S_Loop
149+  E5F6              l2S_ErrZero:
150+  E5F6 2A 1A E3     	ld		hl,(l2deltaX)
151+  E5F9 EB           	ex		de,hl
152+  E5FA 2A 18 E3     	ld		hl,(l2deltaY)
153+  E5FD              	ClearCarryFlag
153+  E5FD B7          >                        or a
154+  E5FE ED 52        	sbc		hl,de
155+  E600 EB           	ex		de,hl
156+  E601              	ldiyde
156+  E601 FD 62       >                        ld		iyh,d
156+  E603 FD 6B       >                        ld		iyl,e
157+  E605              l2S_adjustCol2:
158+  E605 00           	nop										; update X and Y
159+  E606 04           	inc		b
160+  E607 18 AA        	jr		l2S_Loop
161+  E609
162+  E609              ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
163+  E609 32 22 E3     l2_draw_diagonal:       ld		(l2linecolor),a					;save colour for later
164+  E60C 21 00 00                             ld		hl,0                            ;
165+  E60F 22 1A E3                             ld		(l2deltaX),hl                   ;
166+  E612 22 18 E3                             ld		(l2deltaY),hl                   ; initlaise deltas as we will only be loading 8 bit in there but workign in 16 bit later
167+  E615 78           l2D_preSort:            ld		a,b								;
168+  E616                                      JumpIfALTNusng	d,l2D_noYSort			; we must have Y1 < Y2 (if equal then verical line picked up earlier
168+  E616 BA          >                        cp      d
168+  E617 DA 1F E6    >                        jp		c, l2D_noYSort
169+  E61A              l2D_SortBasedOnY:	    ldhlbc									;
169+  E61A 60          >                        ld		h,b
169+  E61B 69          >                        ld		l,c
170+  E61C EB                                   ex		de,hl                           ;
171+  E61D                                      ldbchl									; swap over bc and de using hl as an intermediate
171+  E61D 44          >                        ld		b,h
171+  E61E 4D          >                        ld		c,l
172+  E61F DD 62        l2D_noYSort:		    ld		ixh,d							; ixh now holds target Y coord post sorting
173+  E621 DD 6B                                ld		ixl,e							; ixl now holds target X coord post sorting
174+  E623 79           l2D_setXLen:            ld		a,c                             ;
175+  E624                                      JumpIfALTNusng e,l2D_PosXLen			; if x1 < x2 then we have a positive increment
175+  E624 BB          >                        cp      e
175+  E625 DA 31 E6    >                        jp		c, l2D_PosXLen
176+  E628 79           l2D_NegXLen:            ld		a,c                             ;
177+  E629 93                                   sub     e                               ;
178+  E62A 32 1A E3                             ld		(l2deltaX),a					; As x1 > x2 we do deltaX = X1 - X2
179+  E62D 3E 0D                                ld		a,l2deccstep					; and set the value for inc dec self modifying to Dec
180+  E62F 18 07                                jr		l2D_XINCDEC
181+  E631 7B           l2D_PosXLen:	        ld		a,e                             ;
182+  E632 91                                   sub		c                               ;
183+  E633 32 1A E3                             ld 		(l2deltaX),a                    ; As x1 < x2 we do deltaX = X2 - X1
184+  E636 3E 0C                                ld		a,l2inccstep                    ; and set the value for inc dec self modifying to Inc
185+  E638 32 A7 E6     l2D_XINCDEC:	        ld		(l2D_adjustCol),a				;
186+  E63B 32 D7 E6                             ld		(l2D_adjustCol2),a				; update self modifying code for X update with inc or dec from above
187+  E63E 7A           l2D_setYLen				ld		a,d							 	; presorted on Y so it is now always positive
188+  E63F 90                                   sub		b
189+  E640 32 18 E3                             ld 		(l2deltaY),a					; DeltaY = Y2 - Y1
190+  E643              l2D_setErr:									;  LD H  := (D'-E')/2    round up if +ve or down if -ve
191+  E643 2A 18 E3     ldD_FracDYltDX:			ld		hl,(l2deltaY)					; Fraction = dY - dX
192+  E646 ED 5B 1A E3                          ld		de,(l2deltaX)
193+  E64A                                      ClearCarryFlag
193+  E64A B7          >                        or a
194+  E64B ED 52                                sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
195+  E64D EB                                   ex		de,hl
196+  E64E FD 62                                ld		iyh,d							; we will use IY reg for fractions
197+  E650 FD 6B                                ld		iyl,e
198+  E652 F2 77 E6                             jp		p,l2D_fracIsPositive
199+  E655              l2D_fracIsNegative:     NegIY
199+  E655 AF          >                    xor a
199+  E656 FD 95       >                    sub iyl
199+  E658 FD 6F       >                    ld iyl,a
199+  E65A 9F          >                    sbc a,a
199+  E65B FD 94       >                    sub iyh
199+  E65D FD 67       >                    ld iyh,a
200+  E65F                                      ShiftIYRight1
200+  E65F FD 7C       >			   ld 	a,iyh
200+  E661 CB 3F       >			   srl 	a
200+  E663 FD 67       >			   ld	iyh,a
200+  E665 FD 7D       >			   ld 	a,iyl
200+  E667 1F          >			   rra
200+  E668 FD 6F       >			   ld	iyl,a
201+  E66A                                      NegIY
201+  E66A AF          >                    xor a
201+  E66B FD 95       >                    sub iyl
201+  E66D FD 6F       >                    ld iyl,a
201+  E66F 9F          >                    sbc a,a
201+  E670 FD 94       >                    sub iyh
201+  E672 FD 67       >                    ld iyh,a
202+  E674 C3 82 E6                             jp		l2D_SkipCalcInc					; so we have a negative frac
203+  E677              l2D_fracIsPositive:     ShiftIYRight1
203+  E677 FD 7C       >			   ld 	a,iyh
203+  E679 CB 3F       >			   srl 	a
203+  E67B FD 67       >			   ld	iyh,a
203+  E67D FD 7D       >			   ld 	a,iyl
203+  E67F 1F          >			   rra
203+  E680 FD 6F       >			   ld	iyl,a
204+  E682              l2D_SkipCalcInc:
205+  E682 C5 D5        l2D_Loop:				push	bc,,de                 			; l2DeltaY and l2DeltaX are set
206+  E684 3A 22 E3                             ld		a,(l2linecolor)     			;
207+  E687 CD FF E0                             call	l2_plot_pixel       			; Plot Pixel
208+  E68A D1 C1                                pop     bc,,de
209+  E68C DD 7C        l2D_CheckIfEnd:	        ld		a,ixh
210+  E68E                                      JumpIfAGTENusng	  b,l2D_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
210+  E68E B8          >                        cp     b
210+  E68F D2 95 E6    >                        jp		nc,l2D_CheckXPos
211+  E692 C3 99 E6                             jp		l2D_Continue
212+  E695 79           l2D_CheckXPos:          ld		a,c
213+  E696                                      ReturnIfAEqNusng ixl					; if X1 has reached or exceeded X2 then we are done
213+  E696 DD BD       >                        cp      ixl
213+  E698 C8          >                        ret     z
214+  E699              l2D_Continue:
215+  E699 FD 7C        l2D_HNegative:			ld		a,iyh
216+  E69B CB 7F                                bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
217+  E69D 28 0B                                jr		z,l2D_ErrNotNegative			;
218+  E69F 3A 18 E3     l2D_ErrNegative:		ld		a,(l2deltaY)
219+  E6A2 16 00                                ld		d,0
220+  E6A4 5F                                   ld		e,a
221+  E6A5 FD 19                                add		iy,de							; add deltaY(unsinged) to l2fraction
222+  E6A7 00           l2D_adjustCol:          nop										; this is our inc/dec of X
223+  E6A8 18 D8                                jr		l2D_Loop							; repeat loop
224+  E6AA FD 7C        l2D_ErrNotNegative:     ld		a,iyh
225+  E6AC FD B5                                or		iyl
226+  E6AE                                      JumpIfAIsZero l2D_ErrZero					; if there is no error then goto zeroerror
226+  E6AE A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
226+  E6AF CA C8 E6    >                        jp	z, l2D_ErrZero
227+  E6B2              l2D_ErrPositive:		lddeiy
227+  E6B2 FD 54       >                        ld		d,iyh
227+  E6B4 FD 5D       >                        ld		e,iyl
228+  E6B6 EB                                   ex		de,hl
229+  E6B7 16 00                                ld		d,0
230+  E6B9 3A 1A E3                             ld		a,(l2deltaX)
231+  E6BC 5F                                   ld		e,a
232+  E6BD                                      ClearCarryFlag
232+  E6BD B7          >                        or a
233+  E6BE ED 52                                sbc		hl,de
234+  E6C0 EB                                   ex		de,hl
235+  E6C1                                      ldiyde
235+  E6C1 FD 62       >                        ld		iyh,d
235+  E6C3 FD 6B       >                        ld		iyl,e
236+  E6C5 04           l2D_adjustRow:			inc		b
237+  E6C6 18 BA                                jr		l2D_Loop
238+  E6C8 2A 1A E3     l2D_ErrZero:            ld		hl,(l2deltaX)
239+  E6CB EB                                   ex		de,hl
240+  E6CC 2A 18 E3                             ld		hl,(l2deltaY)
241+  E6CF                                      ClearCarryFlag
241+  E6CF B7          >                        or a
242+  E6D0 ED 52                                sbc		hl,de
243+  E6D2 EB                                   ex		de,hl
244+  E6D3                                      ldiyde
244+  E6D3 FD 62       >                        ld		iyh,d
244+  E6D5 FD 6B       >                        ld		iyl,e
245+  E6D7 00           l2D_adjustCol2:         nop										; update X and Y
246+  E6D8 04                                   inc		b
247+  E6D9 18 A7                                jr		l2D_Loop
248+  E6DB              ;----------------------------------------------------------------------------------------------------------------------------------
249+  E6DB
250+  E6DB
251+  E6DB
252+  E6DB
253+  E6DB              ;Loin:				; BBC version of line draw
254+  E6DB              ;; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color)"
255+  E6DB              ;	ld		(l2linecolor),a					; save colour as a reg gets used alot, coudl move this into interrupt flag and disable interrups
256+  E6DB              ;	ld		ixh,0							; ixh = s
257+  E6DB              ;	ld		iyh,0							; iyh = swap
258+  E6DB              ;	ld		l,0								; l will hold delta sign flags
259+  E6DB              ;LoinCalcDeltaX:
260+  E6DB              ;	ld		a,e
261+  E6DB              ;	sub		c								; a = deltaX
262+  E6DB              ;	JumpIfPositive LoinPosDx
263+  E6DB              ;LoinNegDx:
264+  E6DB              ;	neg										; carry flag will indicate deltaX was negative
265+  E6DB              ;	ld		l,$80							; set bit 7 of l for negative
266+  E6DB              ;LoinPosDx:
267+  E6DB              ;	ld		ixl,a							; ixl = varP = deltaX
268+  E6DB              ;LoinCalcDeltaY:
269+  E6DB              ;	ld		a,d
270+  E6DB              ;	sub		b								; a= deltaY
271+  E6DB              ;	JumpIfPositive LoinPosDy
272+  E6DB              ;LoinNegDy:
273+  E6DB              ;	neg
274+  E6DB              ;	set		6,l								; set bit 6 of l for negative deltaY
275+  E6DB              ;LoinPosDy:
276+  E6DB              ;	ld		iyl,a							; iyl = varQ = deltaY
277+  E6DB              ;	JumpIfAGTENusng ixl, LoinSTPy			; if deltaY >= DeltaX then step along Y
278+  E6DB              ;LoinSTPx:									; step along X
279+  E6DB              ;	JumpOnBitClear l,7						; if l flags were clear then X2 < X2
280+  E6DB              ;LoinSTPxSwapCoords:
281+  E6DB              ;	dec		iyh								; swap flag now becomes FF
282+  E6DB              ;	ld		a,l								; save l flags
283+  E6DB              ;	ex		de,hl							; save de to hl
284+  E6DB              ;	lddebc									; Point2 = point1
285+  E6DB              ;	ldbchl									; Point1 = point2 that was saved
286+  E6DB              ;	ld		l,a								; get back l flags
287+  E6DB              ;LoinSTPxCorrectOrder:
288+  E6DB              ;	l2_point_pixel_y_safe					; call plot pixel preseving bc hl
289+  E6DB              ;	ld		a,iyl							; get delta Y back
290+  E6DB              ;	ld		iy1,$FE							; roll counter
291+  E6DB              ;LionSTPxRollQ:
292+  E6DB              ;	sla		a								; highest bit of delta-Y
293+  E6DB              ;	jp		c,LoinSTPxSteep
294+  E6DB              ;	cp		ixl								; compare with DeltaX
295+  E6DB              ;	jp		cs,LoinSTPxShallow
296+  E6DB              ;LoinSTPxSteep:								;; LI4
297+  E6DB              ;	sbc		a,ixl							; deltaYwork -= (deltaX+1)
298+  E6DB              ;	scf										; force carry flag set
299+  E6DB              ;LoinSTPxShallow:							;; LI5
300+  E6DB              ;	rl		iyl								; rotate iyl which started as FE
301+  E6DB              ;	jp		c,LionSTPxRollQ					; so we are doing a 6 bit loop
302+  E6DB              ;	inc		ihl								; DeltaX += 1
303+  E6DB              ;LoinSTPxYDirection:							; change this to self modifying code
304+  E6DB              ;	ld		a,d
305+  E6DB              ;	JumpIfAGTEn	b,LionDOWN:
306+  E6DB              ;	ld		a,iyh							; swap flag
307+  E6DB              ;	JumpIfANotZero	X1Inc  					; if swap flag was not set then no need to update R
308+  E6DB              ;LoinSTPxX1Dec:
309+  E6DB              ;	dec		c								; move left 1 pixel as we sawped
310+  E6DB              ;LoinSTPxXCounter:							;; LIL2
311+  E6DB              ;	sub		b
312+  E6DB              ;	if
313+  E6DB              ;
314+  E6DB              ;85 82                   STA &82	   \ R	\ mask byte
315+  E6DB              ;A5 81                   LDA &81	   \ Q	\ delta-Y
316+  E6DB              ;A2 FE                   LDX #&FE	\ roll counter
317+  E6DB              ;86 81                   STX &81		\ Q
318+  E6DB              ;.LIL1	\ roll Q
319+  E6DB              ;0A                      ASL A		\ highest bit of delta-Y
320+  E6DB              ;B0 04                   BCS LI4		\ steep
321+  E6DB              ;C5 1B                   CMP &1B	   \ P	\ delta-X
322+  E6DB              ;90 03                   BCC LI5		\ shallow
323+  E6DB              ;.LI4	\ steep
324+  E6DB              ;E5 1B                   SBC &1B		\ P
325+  E6DB              ;38                      SEC
326+  E6DB              ;.LI5	\ shallow
327+  E6DB              ;26 81                   ROL &81	   \ Q	\ #&FE
328+  E6DB              ;B0 F2                   BCS LIL1 	\ loop Q, end with some low bits in Q
329+  E6DB              ;A6 1B                   LDX &1B		\ P
330+  E6DB              ;E8                      INX 		\ Xreg is width
331+  E6DB              ;A5 37                   LDA &37		\ Y2
332+  E6DB              ;E5 35                   SBC &35		\ Y1
333+  E6DB              ;B0 2C                   BCS DOWN	\ draw line to the right and down
334+  E6DB              ;A5 90                   LDA &90		\ SWAP
335+  E6DB              ;D0 07                   BNE LI6		\ else Xreg was correct after all, no need to update R
336+  E6DB              ;CA                      DEX
337+  E6DB              ;.LIL2	\ counter X width
338+  E6DB              ;A5 82                   LDA &82	   \ R	\ mask byte
339+  E6DB              ;51 07                   EOR (&07),Y	\ (SC),Y
340+  E6DB              ;91 07                   STA (&07),Y	\ (SC),Y
341+  E6DB              ;.LI6	\ Xreg correct
342+  E6DB              ;46 82                   LSR &82	   \ R	\ mask byte
343+  E6DB              ;90 08                   BCC LI7   	\ else moving to next column to right. Bring carry in back
344+  E6DB              ;66 82                   ROR &82		\ R
345+  E6DB              ;A5 07                   LDA &07		\ SC
346+  E6DB              ;69 08                   ADC #8		\ next column
347+  E6DB              ;85 07                   STA &07		\ SC
348+  E6DB              ;.LI7	\ S += Q. this is like an overflow monitor to update Y
349+  E6DB              ;A5 83                   LDA &83		\ S
350+  E6DB              ;65 81                   ADC &81	   \ Q	\ some low bits
351+  E6DB              ;85 83                   STA &83		\ S
352+  E6DB              ;90 07                   BCC LIC2	\ skip Y adjustment
353+  E6DB              ;88                      DEY
354+  E6DB              ;10 04                   BPL LIC2	\ skip Y adjustment
355+  E6DB              ;C6 08                   DEC &08		\ SC+1
356+  E6DB              ;A0 07                   LDY #7
357+  E6DB              ;.LIC2	\ skip Y adjustment
358+  E6DB              ;CA                      DEX
359+  E6DB              ;D0 DC                   BNE LIL2	\ loop X width
360+  E6DB              ;A4 85                   LDY &85	 \ YSAV \ restore Yreg
361+  E6DB              ;60                      RTS
362+  E6DB              ;
363+  E6DB              ;.DOWN	\ Line is going to the right and down
364+  E6DB              ;A5 90                   LDA &90		\ SWAP
365+  E6DB              ;F0 07                   BEQ LI9		\ no swap
366+  E6DB              ;CA                      DEX
367+  E6DB              ;.LIL3	\ counter X width
368+  E6DB              ;A5 82                   LDA &82	    \ R \ mask byte
369+  E6DB              ;51 07                   EOR (&07),Y	\ (SC),Y
370+  E6DB              ;91 07                   STA (&07),Y	\ (SC),Y
371+  E6DB              ;.LI9	\ no swap
372+  E6DB              ;46 82                   LSR &82		\ R
373+  E6DB              ;90 08                   BCC LI10	\ still in correct column, hop
374+  E6DB              ;66 82                   ROR &82		\ R
375+  E6DB              ;A5 07                   LDA &07		\ SC
376+  E6DB              ;69 08                   ADC #8		\ next column
377+  E6DB              ;85 07                   STA &07		\ SC
378+  E6DB              ;.LI10	\ this is like an overflow monitor to update Y
379+  E6DB              ;A5 83                   LDA &83		\ S
380+  E6DB              ;65 81                   ADC &81		\ Q
381+  E6DB              ;85 83                   STA &83		\ S
382+  E6DB              ;90 09                   BCC LIC3	\ skip Y adjustment
383+  E6DB              ;C8                      INY
384+  E6DB              ;C0 08                   CPY #8
385+  E6DB              ;D0 04                   BNE LIC3	\ have not reached bottom byte of char, hop
386+  E6DB              ;E6 08                   INC &08		\ SC+1
387+  E6DB              ;A0 00                   LDY #0
388+  E6DB              ;.LIC3	\ skipped Y adjustment
389+  E6DB              ;CA                      DEX
390+  E6DB              ;D0 DA                   BNE LIL3	\ loop X width
391+  E6DB              ;A4 85                   LDY &85	 \ YSAV \ restore Yreg
392+  E6DB              ;60                      RTS
393+  E6DB              ;
394+  E6DB              ;.STPY	\ -> &1797 \ Step along y for line, goes down and to right
395+  E6DB              ;A4 35                   LDY &35		\ Y1
396+  E6DB              ;98                      TYA
397+  E6DB              ;A6 34                   LDX &34		\ X1
398+  E6DB              ;C4 37                   CPY &37		\ Y2
399+  E6DB              ;B0 10                   BCS LI15	\ skip swap if Y1 >= Y2
400+  E6DB              ;C6 90                   DEC &90		\ SWAP
401+  E6DB              ;A5 36                   LDA &36		\ X2
402+  E6DB              ;85 34                   STA &34		\ X1
403+  E6DB              ;86 36                   STX &36		\ X2
404+  E6DB              ;AA                      TAX
405+  E6DB              ;A5 37                   LDA &37		\ Y2
406+  E6DB              ;85 35                   STA &35		\ Y1
407+  E6DB              ;84 37                   STY &37		\ Y2
408+  E6DB              ;A8                      TAY
409+  E6DB              ;.LI15	\ Y1 Y2 order is now correct
410+  E6DB              ;4A                      LSR A
411+  E6DB              ;4A                      LSR A
412+  E6DB              ;4A                      LSR A
413+  E6DB              ;09 60                   ORA #&60
414+  E6DB              ;85 08                   STA &08	 \ SC+1	\ screen hi
415+  E6DB              ;8A                      TXA 		\ X1
416+  E6DB              ;29 F8                   AND #&F8
417+  E6DB              ;85 07                   STA &07	  \ SC	\ screen lo
418+  E6DB              ;8A                      TXA
419+  E6DB              ;29 07                   AND #7		\ mask index
420+  E6DB              ;AA                      TAX
421+  E6DB              ;BD AF 16                LDA &16AF,X \ TWOS,X \ Mode4 single pixel
422+  E6DB              ;85 82                   STA &82	    \ R	\ mask
423+  E6DB              ;A5 35                   LDA &35		\ Y1
424+  E6DB              ;29 07                   AND #7
425+  E6DB              ;A8                      TAY
426+  E6DB              ;A5 1B                   LDA &1B	    \ P	\ delta-X
427+  E6DB              ;A2 01                   LDX #1		\ roll counter
428+  E6DB              ;86 1B                   STX &1B	    	\ P
429+  E6DB              ;.LIL4	\ roll P
430+  E6DB              ;0A                      ASL A
431+  E6DB              ;B0 04                   BCS LI13	\ do subtraction
432+  E6DB              ;C5 81                   CMP &81	    \ Q	\ delta-Y
433+  E6DB              ;90 03                   BCC LI14	\ less than Q
434+  E6DB              ;.LI13	\ do subtraction
435+  E6DB              ;E5 81                   SBC &81		\ Q
436+  E6DB              ;38                      SEC
437+  E6DB              ;.LI14	\ less than Q
438+  E6DB              ;26 1B                   ROL &1B		\ P
439+  E6DB              ;90 F2                   BCC LIL4	\ loop P, end with some low bits in P
440+  E6DB              ;A6 81                   LDX &81		\ Q
441+  E6DB              ;E8                      INX 		\ adjust height
442+  E6DB              ;A5 36                   LDA &36		\ X2
443+  E6DB              ;E5 34                   SBC &34		\ X1
444+  E6DB              ;90 2D                   BCC LFT		\ if C cleared then line moving to the left - hop down
445+  E6DB              ;18                      CLC
446+  E6DB              ;A5 90                   LDA &90		\ SWAP
447+  E6DB              ;F0 07                   BEQ LI17 	\ skip first point
448+  E6DB              ;CA                      DEX
449+  E6DB              ;.LIL5	\ skipped first point, counter X
450+  E6DB              ;A5 82                   LDA &82	    \ R \ mask byte
451+  E6DB              ;51 07                   EOR (&07),Y	\ (SC),Y
452+  E6DB              ;91 07                   STA (&07),Y	\ (SC),Y
453+  E6DB              ;.LI17	\ skipped first point
454+  E6DB              ;88                      DEY
455+  E6DB              ;10 04                   BPL LI16	\ skip hi adjust
456+  E6DB              ;C6 08                   DEC &08		\ SC+1
457+  E6DB              ;A0 07                   LDY #7		\ new char
458+  E6DB              ;	.LI16	\ skipped hi adjust
459+  E6DB              ;A5 83                   LDA &83		\ S
460+  E6DB              ;65 1B                   ADC &1B		\ P
461+  E6DB              ;85 83                   STA &83		\ S
462+  E6DB              ;90 0C                   BCC LIC5	\ skip, still in same column
463+  E6DB              ;46 82                   LSR &82	  \ R	\ mask
464+  E6DB              ;90 08                   BCC LIC5  	\ no mask bit hop
465+  E6DB              ;66 82                   ROR &82   \ R	\ else moved over to next column, reset mask
466+  E6DB              ;A5 07                   LDA &07	  \ SC  \ screen lo
467+  E6DB              ;69 08                   ADC #8		\ next char below
468+  E6DB              ;85 07                   STA &07		\ SC
469+  E6DB              ;.LIC5	\ same column
470+  E6DB              ;CA                      DEX
471+  E6DB              ;D0 DC                   BNE LIL5	\ loop X height
472+  E6DB              ;A4 85                   LDY &85	 \ YSAV	\ restore Yreg
473+  E6DB              ;60                      RTS
474+  E6DB              ;
475+  E6DB              ;.LFT	\ going left
476+  E6DB              ;A5 90                   LDA &90		\ SWAP
477+  E6DB              ;F0 07                   BEQ LI18	\ skip first point
478+  E6DB              ;CA                      DEX 		\ reduce height
479+  E6DB              ;.LIL6	\ counter X height
480+  E6DB              ;A5 82                   LDA &82	   \ R	\ mask byte
481+  E6DB              ;51 07                   EOR (&07),Y	\ (SC),Y
482+  E6DB              ;91 07                   STA (&07),Y	\ (SC),Y
483+  E6DB              ;.LI18
484+  E6DB              ;88                      DEY
485+  E6DB              ;10 04                   BPL LI19	\ skip hi adjust
486+  E6DB              ;C6 08                   DEC &08		\ SC+1
487+  E6DB              ;A0 07                   LDY #7		\ rest char row
488+  E6DB              ;.LI19	\ skipped hi adjust
489+  E6DB              ;A5 83                   LDA &83		\ S
490+  E6DB              ;65 1B                   ADC &1B	    \ P \ some low bits
491+  E6DB              ;85 83                   STA &83		\ S
492+  E6DB              ;90 0D                   BCC LIC6	\ no overflow
493+  E6DB              ;06 82                   ASL &82	    \ R \ else move byte mask to the left
494+  E6DB              ;90 09                   BCC LIC6	\ no overflow
495+  E6DB              ;26 82                   ROL &82		\ R
496+  E6DB              ;A5 07                   LDA &07		\ SC
497+  E6DB              ;E9 07                   SBC #7		\ down 1 char
498+  E6DB              ;85 07                   STA &07		\ SC
499+  E6DB              ;18                      CLC
500+  E6DB              ;.LIC6	\ no overflow
501+  E6DB              ;CA                      DEX 		\ height
502+  E6DB              ;D0 DB                   BNE LIL6	\ loop X
503+  E6DB              ;A4 85                   LDY &85	 \ YSAV	\ restore Yreg
504+  E6DB              ;.HL6
505+  E6DB              ;60                      RTS 		\ end Line drawing
506+  E6DB
507+  E6DB
508+  E6DB              ;;l2_draw_diagonalopt:
509+  E6DB              	; ">TODO l2_draw_diagonalopt fast horz vert optmisation"
510+  E6DB              ;;	push	af
511+  E6DB              ;;	ld		a,b
512+  E6DB              ;;	cp		d
513+  E6DB              ;;	jr		z,.RegularDiagnonal
514+  E6DB              ;;.CheckHorz:
515+  E6DB              ;;	ld		a,c
516+  E6DB              ;;	cp		e
517+  E6DB              ;;	jr		z,.horizontalLine
518+  E6DB              ;;.RegularDiagnonal:
519+  E6DB              ;;	pop		af
520+  E6DB              ;;	call diag
521+  E6DB
522+  E6DB
523+  E6DB              ;;l2_signed_mul2a:
524+  E6DB              ;;; ">l2_signed_mul2a - Signed a = a * 2 using shift)"
525+  E6DB              ;;	TEST	$80
526+  E6DB              ;;	jr		nz, .negativecalc
527+  E6DB              ;;.positivecalc:
528+  E6DB              ;;	ccf
529+  E6DB              ;;	rla
530+  E6DB              ;;	ret
531+  E6DB              ;;.negativecalc:
532+  E6DB              ;;	neg
533+  E6DB              ;;	ccf
534+  E6DB              ;;	rla
535+  E6DB              ;;	neg
536+  E6DB              ;;	ret
537+  E6DB              ;;
538+  E6DB              ;;l2_signed_mul2atohl:
539+  E6DB              ;;; ">l2_signed_mul2ahl - Signed hl = a * 2 using shift)"
540+  E6DB              ;;	TEST	$80
541+  E6DB              ;;	jr		nz, .negativecalc
542+  E6DB              ;;.positivecalc:
543+  E6DB              ;;	ld		hl,0
544+  E6DB              ;;	ld		l,a
545+  E6DB              ;;	add		hl,a
546+  E6DB              ;;	ret
547+  E6DB              ;;.negativecalc:
548+  E6DB              ;;	neg
549+  E6DB              ;;	ld		hl,0
550+  E6DB              ;;	ld		l,a
551+  E6DB              ;;	neghl
552+  E6DB              ;;	ret
553+  E6DB              ;;
554+  E6DB              ;;l2_e2fractionby2:
555+  E6DB              ;;	ld 		hl,(l2fraction)
556+  E6DB              ;;	push	de
557+  E6DB              ;;	ld		d,h
558+  E6DB              ;;	ld		e,l
559+  E6DB              ;;	add		hl,de
560+  E6DB              ;;	pop		de
561+  E6DB              ;;	ld		(l2e2),hl
562+  E6DB              ;;	ret
563+  E6DB
564+  E6DB
565+  E6DB
566+  E6DB
567+  E6DB
568+  E6DB              ;;//	ld		(l2linecolor),a   			; could do an ex but it will be needed multiple times between many uses of a reg
569+  E6DB              ;;//.catchLoop:
570+  E6DB              ;;//	jp .catchLoop
571+  E6DB              ;;//.continue:
572+  E6DB              ;;//    ld      A,D
573+  E6DB              ;;//    sub     H
574+  E6DB              ;;//    jr      NC,.DXpositive    ;delta_x > 0
575+  E6DB              ;;//.DXNegative:
576+  E6DB              ;;//    neg
577+  E6DB              ;;//.DXPositive:
578+  E6DB              ;;//    ld      B,A              ;B <- |delta_x|
579+  E6DB              ;;//    ld      A,E
580+  E6DB              ;;//    sub     L
581+  E6DB              ;;//    jr      NC,.DYpositive    ;delta_y > 0
582+  E6DB              ;;//.DYNegative:
583+  E6DB              ;;//    neg
584+  E6DB              ;;//.DYPositive:
585+  E6DB              ;;//    sub     B               ;|delta_y|
586+  E6DB              ;;//	push	af
587+  E6DB              ;;//	jr		c,.DeltaX
588+  E6DB              ;;//.DeltaY
589+  E6DB              ;;//	ld      A,H             			;if |delta_x| < |delta_y| then
590+  E6DB              ;;//    ld      H,L             			;then values x and y are swapped
591+  E6DB              ;;//    ld      L,A             			;so the loop will always be performed on the
592+  E6DB              ;;//    ld      A,D             			;x value. A flag must be set to
593+  E6DB              ;;//    ld      D,E             			;remind that data must be drawn (y,x)
594+  E6DB              ;;//    ld      E,A             			;instead of (x,y)
595+  E6DB              ;;//.DeltaX:
596+  E6DB              ;;//	ld		a,d
597+  E6DB              ;;//	sub		h
598+  E6DB              ;;//	jr		nc,.TestDY					; x1 < x2
599+  E6DB              ;;//.TestDX:
600+  E6DB              ;;//	ex		de,hl
601+  E6DB              ;;//.TestDY:
602+  E6DB              ;;//	ld		a,e
603+  E6DB              ;;//	sub		l
604+  E6DB              ;;//    ld      A,$01
605+  E6DB              ;;//    jr      NC,.StoreA
606+  E6DB              ;;//    neg                     ;y1 > y2 : in case2 the 'y' variable
607+  E6DB              ;;//.StoreA:
608+  E6DB              ;;//        ld      (l2way),A
609+  E6DB              ;;//.InitLine:
610+  E6DB              ;;//        ld      B,H
611+  E6DB              ;;//        ld      C,L
612+  E6DB              ;;//        ld      A,E
613+  E6DB              ;;//        sub     L
614+  E6DB              ;;//        jr      NC,.EndInit
615+  E6DB              ;;//        ld      A,L
616+  E6DB              ;;//        ld      L,E
617+  E6DB              ;;//        ld      E,A
618+  E6DB              ;;//.EndInit:
619+  E6DB              ;;//        ld      A,E
620+  E6DB              ;;//        sub     L
621+  E6DB              ;;//        rla
622+  E6DB              ;;//        ld      L,A             ;value to add in case1 (d < 0)
623+  E6DB              ;;//        add     A,H
624+  E6DB              ;;//        sub     D
625+  E6DB              ;;//        ld      E,A             ;'d' variable is initialised
626+  E6DB              ;;//        add     A,H
627+  E6DB              ;;//        sub     D
628+  E6DB              ;;//        ld      H,A             ;value to add in case2 (d >= 0)
629+  E6DB              ;;//.Loop:
630+  E6DB              ;;//        ld      A,B
631+  E6DB              ;;//        sub     D
632+  E6DB              ;;//        jr      NC,.EndLine       ;the line is completely drawn.
633+  E6DB              ;;//        pop     AF
634+  E6DB              ;;//        bit     7,A
635+  E6DB              ;;//        push    AF
636+  E6DB              ;;//        push    AF
637+  E6DB              ;;//        push    BC
638+  E6DB              ;;//        jr      Z,.DrawPoint
639+  E6DB              ;;//        ld      A,B
640+  E6DB              ;;//        ld      B,C
641+  E6DB              ;;//        ld      C,A
642+  E6DB              ;;//.DrawPoint:
643+  E6DB              ;;//		push	hl
644+  E6DB              ;;//		pushbcdeaf
645+  E6DB              ;;//		ld		b,e
646+  E6DB              ;;//		ld		c,d
647+  E6DB              ;;//	ld 		a,(l2linecolor)
648+  E6DB              ;;//	call	l2_plot_pixel
649+  E6DB              ;;//		popafdebc
650+  E6DB              ;;//		pop		hl
651+  E6DB              ;;//        pop     BC
652+  E6DB              ;;//        pop     AF
653+  E6DB              ;;//.TestD:
654+  E6DB              ;;//        bit     7,E
655+  E6DB              ;;//        jr      NZ,.Case1
656+  E6DB              ;;//.Case2:                          ;d >= 0
657+  E6DB              ;;//        ld      A,E
658+  E6DB              ;;//        add     A,H
659+  E6DB              ;;//        ld      E,A
660+  E6DB              ;;//        ld      A,(l2way)
661+  E6DB              ;;//        add     A,C
662+  E6DB              ;;//        ld      C,A
663+  E6DB              ;;//        jr      .EndLoop
664+  E6DB              ;;//.Case1:                          ;d < 0
665+  E6DB              ;;//        ld      A,E
666+  E6DB              ;;//        add     A,L
667+  E6DB              ;;//        ld      E,A
668+  E6DB              ;;//.EndLoop:
669+  E6DB              ;;//        inc     B
670+  E6DB              ;;//        jr      .Loop
671+  E6DB              ;;//.EndLine:
672+  E6DB              ;;//        pop     AF              ;MUST NOT BE REMOVED
673+  E6DB              ;;//        pop     HL              ;can be removed
674+  E6DB              ;;//        pop     DE              ;can be removed
675+  E6DB              ;;//        ret
676+  E6DB
677+  E6DB              ;;	ld		(.l2yadjust),a
678+  E6DB              ;;	call	calcdeltax:
679+  E6DB              ;;	ld		(.l2xadjust),a
680+  E6DB              ;;.calcfraction:							; err(or fraction) = dx+dy;
681+  E6DB              ;;	push	hl
682+  E6DB              ;;	push	de
683+  E6DB              ;;	ld		hl,(l2deltaX)
684+  E6DB              ;;	ld		de,(l2deltaY)
685+  E6DB              ;;	add		hl,de
686+  E6DB              ;;	ld		(l2fraction),hl
687+  E6DB              ;;	pop		de
688+  E6DB              ;;	pop		hl
689+  E6DB              ;;.mainloop:
690+  E6DB              ;;	push	bc
691+  E6DB              ;;	push	de
692+  E6DB              ;;	ld 		a,(l2linecolor)
693+  E6DB              ;;	call	l2_plot_pixel
694+  E6DB              ;;	pop		de
695+  E6DB              ;;	pop		bc
696+  E6DB              ;;.arewefinishedtest
697+  E6DB              ;;	ld		a,b
698+  E6DB              ;;	cp		d
699+  E6DB              ;;	jr		nz,.notthereyet
700+  E6DB              ;;	ld		a,c
701+  E6DB              ;;	cp		e
702+  E6DB              ;;	ret		z
703+  E6DB              ;;.notthereyet:
704+  E6DB              ;;	push	de
705+  E6DB              ;;	call	l2_e2fractionby2			; e2 = 2*err;
706+  E6DB              ;;	pop		de
707+  E6DB              ;;.e2dytest:								; if (e2 >= dy) /* e_xy+e_x > 0 */  then S and P/V are the same
708+  E6DB              ;;	push	de							; so if m & pe  or p & po calc (m = sign set p = 0)
709+  E6DB              ;;	ld		de,(l2deltaY)				;    if m & po  or p & pe skip  (pe = pv set po = pv 0)
710+  E6DB              ;;	or		a							;
711+  E6DB              ;;	sbc		hl,de						;
712+  E6DB              ;;	pop		de
713+  E6DB              ;;	jr		z,  .dodycalc				; if equal then calc
714+  E6DB              ;;	jp		p,	.dodycalc				; sign clear to H>D even with negtives
715+  E6DB              ;;	jr		.skipdycalc         		; sign = 0     so  skip as pe
716+  E6DB              ;;.dodycalc:
717+  E6DB              ;;	ld		hl,(l2fraction)
718+  E6DB              ;;	push	de
719+  E6DB              ;;	ld		de,(l2deltaY)
720+  E6DB              ;;	add		hl,de
721+  E6DB              ;;	ld		(l2fraction),de
722+  E6DB              ;;	pop		de
723+  E6DB              ;;.l2yadjust:
724+  E6DB              ;;	nop
725+  E6DB              ;;.skipdycalc:
726+  E6DB              ;;.e2dxtest:								;  if (e2 <= dx) /* e_xy+e_y < 0 */ then S and P/V are different.
727+  E6DB              ;;	ld		hl,(l2e2)
728+  E6DB              ;;	push	de							;
729+  E6DB              ;;	ld		de,(l2deltaX)				;
730+  E6DB              ;;	or		a							; clear carry flag
731+  E6DB              ;;	sbc		hl,de						; hl = hl - de is if de > hl will get pv and signed different?
732+  E6DB              ;;	pop		de
733+  E6DB              ;;	jr		z,.dodxcalc					; e2 == dx so do calc
734+  E6DB              ;;	jp		m,.dodxcalc					; was sign bit set
735+  E6DB              ;;	jr		.skipdxcalc         	    ; diff so skip ; pvclear = po        pvset = pe
736+  E6DB              ;;.dodxcalc:
737+  E6DB              ;;	ld		hl,(l2fraction)
738+  E6DB              ;;	push	de
739+  E6DB              ;;	ld		de,(l2deltaX)
740+  E6DB              ;;	add		hl,de
741+  E6DB              ;;	ld		(l2fraction),de
742+  E6DB              ;;	pop		de
743+  E6DB              ;;.l2xadjust:
744+  E6DB              ;;	nop
745+  E6DB              ;;.skipdxcalc:
746+  E6DB              ;;	jr 		.mainloop
747+  E6DB
748+  E6DB
749+  E6DB              ;;/l2_draw_diagonalold:
750+  E6DB              ;;/MESSAGE ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color)"
751+  E6DB              ;;/	ld		(l2linecolor),a   			; could do an ex but it will be needed multiple times between many uses of a reg
752+  E6DB              ;;/.sortycoords:
753+  E6DB              ;;/	ld		a,b							; Sort to Y0 is always > y1 so we don't have to deal with step y and only step x
754+  E6DB              ;;/	cp		d
755+  E6DB              ;;/	jr		nc, .nocoordswap
756+  E6DB              ;;/.swapcoords:
757+  E6DB              ;;/	ex		de,hl						; save de to hl ! effective code line 98 after macros
758+  E6DB              ;;/	lddebc
759+  E6DB              ;;/	ldbchl
760+  E6DB              ;;/.nocoordswap:
761+  E6DB              ;;/	ld		a,d							; l2_dy = -ABS(l2_vy1 - l2_vy0)
762+  E6DB              ;;/	sub		b							; we have already sorted  so y1 > y0
763+  E6DB              ;;/	ld		(l2deltaY),a
764+  E6DB              ;;/	neg									; DEBUG
765+  E6DB              ;;/	ld		(l2deltaYn),a				; DEBUG
766+  E6DB              ;;/	neg									; DEBUG
767+  E6DB              ;;/.deltaxequABSx0Minusx1:						; we need to set l2dx to abs x1-x0 and set
768+  E6DB              ;;/    ld		a,c
769+  E6DB              ;;/	cp		e
770+  E6DB              ;;/	jr		c, .x1GTx0
771+  E6DB              ;;/.x1LTx0
772+  E6DB              ;;/	ld		a,c
773+  E6DB              ;;/	sub		e
774+  E6DB              ;;/	ld		(l2deltaX),a				; just 8 bit for now should it be 16?
775+  E6DB              ;;/	neg									; DEBUG
776+  E6DB              ;;/	ld		(l2deltaXn),a				; DEBUG
777+  E6DB              ;;/	neg									; DEBUG
778+  E6DB              ;;/	ld		a,l2incbstep
779+  E6DB              ;;/	jr		.setlayershift0
780+  E6DB              ;;/.x1GTx0:
781+  E6DB              ;;/	ld		a,e
782+  E6DB              ;;/	sub		c
783+  E6DB              ;;/	ld		(l2deltaX),a					; just 8 bit for now should it be 16?
784+  E6DB              ;;/	neg									; DEBUG
785+  E6DB              ;;/	ld		(l2deltaXn),a				; DEBUG
786+  E6DB              ;;/	neg									; DEBUG
787+  E6DB              ;;/	ld		a,l2decbstep
788+  E6DB              ;;/.setlayershift0:
789+  E6DB              ;;/	ld		a,0
790+  E6DB              ;;/	pushbcde
791+  E6DB              ;;/	call	asm_l2_bank_n_select		; l2_layer_shift = 0 and bank 0 selected
792+  E6DB              ;;/	popdebc
793+  E6DB              ;;/; so now we have set inc or dec instruction, l2dy, l2dx and on bank 0,
794+  E6DB              ;;/.dymuliplyby2:
795+  E6DB              ;;/	ld		a, (l2deltaY)				; dy *= 2
796+  E6DB              ;;/	call	l2_signed_mul2a
797+  E6DB              ;;/	ld		(l2deltaYsq),a
798+  E6DB              ;;/	neg									; DEBUG
799+  E6DB              ;;/	ld		(l2deltaYsqn),a				; DEBUG
800+  E6DB              ;;/	neg									; DEBUG
801+  E6DB              ;;/.dxmuliplyby2:
802+  E6DB              ;;/	ld		a, (l2deltaX)				; dx *= 2
803+  E6DB              ;;/	call	l2_signed_mul2a
804+  E6DB              ;;/	ld		(l2deltaXsq),a
805+  E6DB              ;;/	neg									; DEBUG
806+  E6DB              ;;/	ld		(l2deltaXsqn),a				; DEBUG
807+  E6DB              ;;/	neg									; DEBUG
808+  E6DB              ;;/.plotfirstpixel:
809+  E6DB              ;;/	pushbcde
810+  E6DB              ;;/	ld a,(l2linecolor)
811+  E6DB              ;;/	call	l2_plot_pixel
812+  E6DB              ;;/	popdebc
813+  E6DB              ;;/.mainloop:								; if (l2_dx > l2_dy) signed
814+  E6DB              ;;/	ld		a,(l2deltaX)				;If A < N, then S and P/V are different.
815+  E6DB              ;;/	ld		hl,l2deltaY					;A >= N, then S and P/V are the same
816+  E6DB              ;;/	cp		(hl)
817+  E6DB              ;;/	jp		m,	.signset
818+  E6DB              ;;/.signclear:
819+  E6DB              ;;/	jp		pe,	.dxLTEdybranch
820+  E6DB              ;;/	jr		.dxGTdybranch
821+  E6DB              ;;/.signset:
822+  E6DB              ;;/	jp		po,	.dxLTEdybranch
823+  E6DB              ;;/.dxGTdybranch:
824+  E6DB              ;;/	ld		a,(l2deltaYsq)
825+  E6DB              ;;/	ld		hl,l2deltaX
826+  E6DB              ;;/	sub		(hl)
827+  E6DB              ;;/	ld		(l2fraction),a				; faction = dy - 1/2 dx
828+  E6DB              ;;/.BranchAwhile							; while (l2_vx0 != l2_vx1)
829+  E6DB              ;;/	ld		a,c
830+  E6DB              ;;/	cp		e
831+  E6DB              ;;/	ret		z							; if x0 = x1 then done
832+  E6DB              ;;/.BranchAtestfraction:					; if (l2_fraction >= 0)
833+  E6DB              ;;/	ld		a,(l2fraction)
834+  E6DB              ;;/	TEST	$80
835+  E6DB              ;;/	jr		nz,.BranchAskipYstep
836+  E6DB              ;;/	inc		b							; 		++l2_vy0;
837+  E6DB              ;;/	ld		hl,l2deltaXsq
838+  E6DB              ;;/	sub		(hl)						; 		l2_fraction -= l2_dx;
839+  E6DB              ;;/	ld		(l2fraction),a
840+  E6DB              ;;/.BranchAskipYstep:
841+  E6DB              ;;/.l2stepx1:
842+  E6DB              ;;/	inc		b							; this is self modifying code point 1 l2_vx0 += l2_stepx
843+  E6DB              ;;/	ld		a,(l2fraction)				; l2_fraction += l2_dy can optimise later as a already has this?
844+  E6DB              ;;/	ld		hl,l2deltaYsq
845+  E6DB              ;;/	add		a,(hl)
846+  E6DB              ;;/	ld		(l2fraction),a
847+  E6DB              ;;/.BranchAplotBCColA:						; l2_plot_pixel(l2_vx0,l2_vy0,color);
848+  E6DB              ;;/	pushbcde
849+  E6DB              ;;/	ld a,(l2linecolor)
850+  E6DB              ;;/	call	l2_plot_pixel
851+  E6DB              ;;/	popdebc
852+  E6DB              ;;/.BranchAloop:
853+  E6DB              ;;/	jr		.BranchAwhile
854+  E6DB              ;;/.dxLTEdybranch:
855+  E6DB              ;;/	ld		a,(l2deltaXsq)				; l2_fraction = l2_dx - (l2_dy >> 1);
856+  E6DB              ;;/	ld		hl, l2deltaY
857+  E6DB              ;;/	sub		(hl)
858+  E6DB              ;;/	ld		(l2fraction),a				; faction = dy - 1/2 d
859+  E6DB              ;;/.BranchBwhile:							; while (l2_vy0 != l2_vy1)
860+  E6DB              ;;/	ld		a,b
861+  E6DB              ;;/	cp		d
862+  E6DB              ;;/	ret		z							; if x0 = x1 then done
863+  E6DB              ;;/.BranchBtestfraction:					; if (l2_fraction >= 0)
864+  E6DB              ;;/	ld		a,(l2fraction)
865+  E6DB              ;;/	TEST	$80
866+  E6DB              ;;/	jr		nz,.BranchBskipYstep
867+  E6DB              ;;/.l2stepx2
868+  E6DB              ;;/	inc		b							; l2_vx0 += l2_stepx; this is self modifying code point 2
869+  E6DB              ;;/	ld		a,(l2fraction)				; l2_fraction -= l2_dy
870+  E6DB              ;;/	ld		hl,l2deltaYsq
871+  E6DB              ;;/	sub		(hl)
872+  E6DB              ;;/	ld		(l2fraction),a
873+  E6DB              ;;/.BranchBskipYstep:
874+  E6DB              ;;/	ld		hl, l2deltaYsq
875+  E6DB              ;;/	add		a,(hl)
876+  E6DB              ;;/	ld		(l2fraction),a
877+  E6DB              ;;/	inc		b							; ++l2_vy0;
878+  E6DB              ;;/.BranchBplotBCColA:
879+  E6DB              ;;/	pushbcde
880+  E6DB              ;;/	ld a,(l2linecolor)
881+  E6DB              ;;/	call	l2_plot_pixel
882+  E6DB              ;;/	popdebc
883+  E6DB              ;;/.BranchBloop:
884+  E6DB              ;;/	jr		.BranchBwhile
885+  E6DB
# file closed: ./Layer2Graphics/layer2_plot_diagonal.asm
162   E6DB                  INCLUDE "./Layer2Graphics/asm_l2_plot_triangle.asm"
# file opened: ./Layer2Graphics/asm_l2_plot_triangle.asm
  1+  E6DB
  2+  E6DB
  3+  E6DB
  4+  E6DB 00 00        l2trianglebc	        DW 0
  5+  E6DD 00 00        l2trianglede	        DW 0
  6+  E6DF 00 00        l2trianglehl	        DW 0
  7+  E6E1
  8+  E6E1              ; "l2_draw_triangle, BC = y1x1, DE=y2x2, HL=y3x3 a = Color"
  9+  E6E1 C5 D5 E5 F5  l2_draw_triangle:       push	bc,,de,,hl,,af
 10+  E6E5 CD 09 E6                             call	l2_draw_diagonal		; BC to DE
 11+  E6E8 F1                                   pop		af
 12+  E6E9 D1                                   pop		de						; swap DE and HL
 13+  E6EA E1                                   pop		hl						; so BC to DE is really to HL
 14+  E6EB C1                                   pop		bc
 15+  E6EC D5 E5                                push    de,,hl                    ; which is pushing original hl then original de
 16+  E6EE F5                                   push	af
 17+  E6EF CD 09 E6                             call	l2_draw_diagonal		; BC to HL (leaving DE and HL swapped)
 18+  E6F2 F1                                   pop		af
 19+  E6F3 C1                                   pop		bc						; Now bc = original de
 20+  E6F4 D1                                   pop		de						; de = original hl
 21+  E6F5 CD 09 E6                             call	l2_draw_diagonal		; BC to HL (leaving DE and HL swapped)
 22+  E6F8 C9                                   ret
 23+  E6F9
 24+  E6F9
 25+  E6F9
 26+  E6F9
 27+  E6F9
# file closed: ./Layer2Graphics/asm_l2_plot_triangle.asm
163   E6F9                  INCLUDE "./Layer2Graphics/asm_l2_fill_triangle.asm"
# file opened: ./Layer2Graphics/asm_l2_fill_triangle.asm
  1+  E6F9              ; ">l2_fillBottomFlatTriangle BC y0x0 DE x1x2, H YCommon, L Colour"
  2+  E6F9              ; "note >l2_draw_diagonal_save, bc = y0,x0 de=y1,x1,a=array nbr ESOURCE LL30 or LION"
  3+  E6F9              ; "note line to   bc = left side row,col, d right pixel, e = color"
  4+  E6F9 DD 01        l2_fillBottomFlatTriangle:break
  5+  E6FB 7D                                   ld		a,l
  6+  E6FC 32 22 E3                             ld		(l2linecolor),a
  7+  E6FF 79                                   ld		a,c
  8+  E700 BB                                   cp		e
  9+  E701 30 08                                jr		nc, .x2gtex1
 10+  E703 DD 26 01     .x1ltx2:                ld		ixh,1                           ; list 1 holds x0 down to x1
 11+  E706 DD 2E 02                             ld		ixl,2                           ; list 2 hols  x0 down to x2
 12+  E709 18 06                                jr		.storepoints
 13+  E70B DD 26 02     .x2gtex1:               ld		ixh,2
 14+  E70E DD 2E 01                             ld		ixl,1
 15+  E711 C5 D5 E5     .storepoints:           push	bc,,de,,hl
 16+  E714 DD 7C                                ld		a,ixh
 17+  E716 5A                                   ld		e,d                             ; we alreay have bc so its now bc -> hd
 18+  E717 54                                   ld		d,h
 19+  E718 CD 2A E5                             call	l2_draw_diagonal_save			;l2_store_diagonal(x0,y0,x1,ycommon,l2_LineMinX);
 20+  E71B E1 D1 C1                             pop		bc,,de,,hl
 21+  E71E C5 E5                                push	bc,,hl
 22+  E720 54                                   ld		d,h                             ; now its bc -> he
 23+  E721 DD 7D                                ld		a,ixl
 24+  E723 CD 2A E5                             call	l2_draw_diagonal_save			;l2_store_diagonal(x0,y0,x2,ycommon,l2_LineMaxX);
 25+  E726 E1 C1                                pop		bc,,hl
 26+  E728 50           .SaveForLoop:           ld		d,b
 27+  E729 5C                                   ld		e,h								; save loop counters
 28+  E72A D5                                   push	de								; de = y0ycommon
 29+  E72B 21 2A E3     .GetFirstHorizontalRow:	ld		hl,l2targetArray1               ; get first row for loop
 30+  E72E 78                                   ld		a,b
 31+  E72F ED 31                                add		hl,a							; hl = l2targetArray1 row b
 32+  E731 7E                                   ld		a,(hl)							;
 33+  E732 4F                                   ld		c,a								; c = col1 i.e. l2targetarray1[b]
 34+  E733 21 2A E4                             ld      hl,l2targetArray2
 35+  E736 78                                   ld      a,b
 36+  E737 ED 31                                add     hl,a
 37+  E739              ;                        inc		h								; hl = l2targetArray2 row b if we interleave
 38+  E739 7E                                   ld		a,(hl)
 39+  E73A 57                                   ld		d,a								; d = col2 i.e. l2targetarray2[b]
 40+  E73B 3A 22 E3     .SetColour:             ld		a,(l2linecolor)
 41+  E73E 5F                                   ld		e,a								; de = to colour
 42+  E73F C5           .SavePoints:            push	bc								; bc = rowcol
 43+  E740 25                                   dec		h
 44+  E741 E5                                   push	hl								; hl = l2targetArray1[b]
 45+  E742 CD 8C E2     .DoLine:	            call	l2_draw_horz_line_to
 46+  E745 E1                                   pop		hl
 47+  E746 C1                                   pop		bc
 48+  E747 04                                   inc		b								; down a rowc
 49+  E748 D1                                   pop		de								; de = from to (and b also = current)
 50+  E749 14                                   inc		d
 51+  E74A 7B                                   ld		a,e								; while e >= d
 52+  E74B BA                                   cp		d
 53+  E74C 30 DA                                jr 		nc,.SaveForLoop					; Is this the right point??
 54+  E74E C9                                   ret
 55+  E74F
# file closed: ./Layer2Graphics/asm_l2_fill_triangle.asm
164   E74F                  INCLUDE "./Layer2Graphics/layer2_plot_circle.asm"
# file opened: ./Layer2Graphics/layer2_plot_circle.asm
  1+  E74F
  2+  E74F 00 00        l2_circle_pos		DW 0
  3+  E751 00           l2_circle_colour	DB 0
  4+  E752 00           l2_circle_radius	DB 0
  5+  E753 00           l2_circle_x			DB 0
  6+  E754 00           l2_circle_y			DB 0
  7+  E755 00           l2_circle_d			DB 0
  8+  E756
  9+  E756              ; ">l2_draw_circle BC = center row col, d = radius, e = colour"
 10+  E756 7B           l2_draw_circle:     ld		a,e
 11+  E757 32 FD E7                         ld		(.PlotPixel+1),a
 12+  E75A 7A                               ld		a,d								; get radius
 13+  E75B A7                               and		a
 14+  E75C C8                               ret		z
 15+  E75D FE 01                            cp		1
 16+  E75F CA 08 E8                         jp		z,CircleSinglepixel
 17+  E762 ED 43 8C E7                      ld		(.Plot1+1),bc					; save origin into DE reg in code
 18+  E766 DD 67                            ld		ixh,a							; ixh = raidus
 19+  E768 DD 2E 00                         ld		ixl,0
 20+  E76B 26 00        .calcd:	            ld		h,0
 21+  E76D 6F                               ld		l,a
 22+  E76E 29                               add		hl,hl							; hl = r * 2
 23+  E76F EB                               ex		de,hl							; de = r * 2
 24+  E770 21 03 00                         ld		hl,3
 25+  E773 A7                               and		a
 26+  E774 ED 52                            sbc		hl,de							; hl = 3 - (r * 2)
 27+  E776 44                               ld		b,h
 28+  E777 4D                               ld		c,l								; bc = 3 - (r * 2)
 29+  E778 21 01 00     .calcdelta:         ld		hl,1
 30+  E77B 16 00                            ld		d,0
 31+  E77D DD 5D                            ld		e,ixl
 32+  E77F A7                               and		a
 33+  E780 ED 52                            sbc		hl,de
 34+  E782 11 01 00     .Setde1:            ld		de,1
 35+  E785 DD 7C        .CircleLoop:        ld		a,ixh
 36+  E787 DD BD                            cp		ixl
 37+  E789 D8                               ret		c
 38+  E78A D9           .ProcessLoop:	    exx
 39+  E78B 11 00 00     .Plot1:             ld		de,0
 40+  E78E 7B                               ld		a,e
 41+  E78F DD 85                            add		a,ixl
 42+  E791 4F                               ld		c,a
 43+  E792 7A                               ld		a,d
 44+  E793 DD 84                            add		a,ixh
 45+  E795 47                               ld		b,a
 46+  E796 CD FC E7                         call	.PlotPixel			;CX+X,CY+Y
 47+  E799 7B           .Plot2:             ld 		a,e
 48+  E79A DD 95                            sub 	ixl
 49+  E79C 4F                               ld 		c,a
 50+  E79D 7A                               ld 		a,d
 51+  E79E DD 84                            add 	a,ixh
 52+  E7A0 47                               ld		b,a
 53+  E7A1 CD FC E7                         call	.PlotPixel			;CX-X,CY+Y
 54+  E7A4 7B           .Plot3:             ld 		a,e
 55+  E7A5 DD 85                            add		a,ixl
 56+  E7A7 4F                               ld 		c,a
 57+  E7A8 7A                               ld 		a,d
 58+  E7A9 DD 94                            sub 	ixh
 59+  E7AB 47                               ld 		b,a
 60+  E7AC CD FC E7                         call	.PlotPixel			;CX+X,CY-Y
 61+  E7AF 7B           .Plot4:             ld 		a,e
 62+  E7B0 DD 95                            sub 	ixl
 63+  E7B2 4F                               ld 		c,a
 64+  E7B3 7A                               ld 		a,d
 65+  E7B4 DD 94                            sub 	ixh
 66+  E7B6 47                               ld 		b,a
 67+  E7B7 CD FC E7                         call	.PlotPixel			;CY+X,CX-Y
 68+  E7BA 7A           .Plot5:	            ld 		a,d
 69+  E7BB DD 85                            add 	a,ixl
 70+  E7BD 47                               ld 		b,a
 71+  E7BE 7B                               ld 		a,e
 72+  E7BF DD 84                            add 	a,ixh
 73+  E7C1 4F                               ld 		c,a
 74+  E7C2 CD FC E7                         call	.PlotPixel			;CY+X,CX+Y
 75+  E7C5 7A           .Plot6:	            ld 		a,d
 76+  E7C6 DD 95                            sub 	ixl
 77+  E7C8 47                               ld 		b,a
 78+  E7C9 7B                               ld 		a,e
 79+  E7CA DD 84                            add 	a,ixh
 80+  E7CC 4F                               ld 		c,a
 81+  E7CD CD FC E7                         call	.PlotPixel			;CY-X,CX+Y
 82+  E7D0 7A           .Plot7:	            ld 		a,d
 83+  E7D1 DD 85                            add 	a,ixl
 84+  E7D3 47                               ld 		b,a
 85+  E7D4 7B                               ld 		a,e
 86+  E7D5 DD 94                            sub 	ixh
 87+  E7D7 4F                               ld 		c,a
 88+  E7D8 CD FC E7                         call	.PlotPixel			;CY+X,CX-Y
 89+  E7DB 7A           .Plot8:	            ld 		a,d
 90+  E7DC DD 95                            sub 	ixl
 91+  E7DE 47                               ld		b,a
 92+  E7DF 7B                               ld 		a,e
 93+  E7E0 DD 94                            sub 	ixh
 94+  E7E2 4F                               ld 		c,a
 95+  E7E3 CD FC E7                         call	.PlotPixel			;CX+X,CY-Y
 96+  E7E6 D9                               exx
 97+  E7E7 CB 7C        .IncrementCircle:	bit     7,h				; Check for Hl<=0
 98+  E7E9 28 03                            jr z,   .draw_circle_1
 99+  E7EB 19                               add hl,de			; Delta=Delta+D1
100+  E7EC 18 05                            jr      .draw_circle_2		;
101+  E7EE 09           .draw_circle_1:		add     hl,bc			; Delta=Delta+D2
102+  E7EF 03                               inc     bc
103+  E7F0 03                               inc     bc				; D2=D2+2
104+  E7F1 DD 25                            dec     ixh				; Y=Y-1
105+  E7F3 03           .draw_circle_2:		inc bc				; D2=D2+2
106+  E7F4 03                               inc bc
107+  E7F5 13                               inc de				; D1=D1+2
108+  E7F6 13                               inc de
109+  E7F7 DD 2C                            inc ixl				; X=X+1
110+  E7F9 C3 85 E7                         jp      .CircleLoop
111+  E7FC 3E 00        .PlotPixel:         ld		a,0                  ; This was originally indirect, where as it neeed to be value
112+  E7FE D5 C5 E5                         push	de,,bc,,hl
113+  E801 CD 19 E1                         call 	l2_plot_pixel_y_test
114+  E804 E1 C1 D1                         pop		de,,bc,,hl
115+  E807 C9                               ret
116+  E808 7B           CircleSinglepixel:  ld		a,e
117+  E809 CD 19 E1                         call	l2_plot_pixel_y_test
118+  E80C C9                               ret
119+  E80D
# file closed: ./Layer2Graphics/layer2_plot_circle.asm
165   E80D                  INCLUDE "./Layer2Graphics/layer2_plot_circle_fill.asm"
# file opened: ./Layer2Graphics/layer2_plot_circle_fill.asm
  1+  E80D
  2+  E80D 00           l2_circle_dblx		DB 0
  3+  E80E 00           l2_circle_dbly		DB 0
  4+  E80F
  5+  E80F              ; ">l2_draw_circle_fill BC = center row col, d = radius, e = colour"
  6+  E80F 7B           l2_draw_circle_fill:    ld		a,e
  7+  E810 32 A6 E8                             ld		(.LineColour+1),a
  8+  E813 7A                                   ld		a,d								; get radius
  9+  E814 A7                                   and		a
 10+  E815 C8                                   ret		z
 11+  E816 FE 01                                cp		1
 12+  E818 CA 08 E8                             jp		z,CircleSinglepixel
 13+  E81B ED 43 45 E8                          ld		(.Line1+1),bc					; save origin into DE reg in code
 14+  E81F DD 67                                ld		ixh,a							; ixh = raidus (x)
 15+  E821 DD 2E 00                             ld		ixl,0							; ihy = y
 16+  E824 26 00        .calcd:	                ld		h,0
 17+  E826 6F                                   ld		l,a
 18+  E827 29                                   add		hl,hl							; hl = r * 2
 19+  E828 EB                                   ex		de,hl							; de = r * 2
 20+  E829 21 03 00                             ld		hl,3
 21+  E82C A7                                   and		a
 22+  E82D ED 52                                sbc		hl,de							; hl = 3 - (r * 2)
 23+  E82F 44                                   ld		b,h
 24+  E830 4D                                   ld		c,l								; bc = 3 - (r * 2)
 25+  E831 21 01 00     .calcdelta              ld		hl,1
 26+  E834 16 00                                ld		d,0
 27+  E836 DD 5D                                ld		e,ixl
 28+  E838 A7                                   and		a
 29+  E839 ED 52                                sbc		hl,de
 30+  E83B 11 01 00     .Setde1	                ld		de,1
 31+  E83E DD 7C        .CircleLoop:            ld		a,ixh
 32+  E840 DD BD                                cp		ixl
 33+  E842 D8                                   ret		c
 34+  E843 D9           .ProcessLoop:	        exx
 35+  E844 11 00 00     .Line1:                 ld		de,0
 36+  E847 7B                                   ld 		a,e
 37+  E848 DD 95                                sub 	ixl
 38+  E84A 4F                                   ld 		c,a
 39+  E84B 7A                                   ld 		a,d
 40+  E84C DD 84                                add 	a,ixh
 41+  E84E 47                                   ld		b,a
 42+  E84F                                      ;; TODO ADD DOUBLE X CALC
 43+  E84F D5                                   push	de
 44+  E850 DD 55                                ld		d,ixl
 45+  E852 CB 22                                sla		d
 46+  E854 CD A1 E8                             call	.PlotLine			;CX-X,CY+Y
 47+  E857 D1                                   pop		de
 48+  E858 7B           .Line2:                 ld 		a,e
 49+  E859 DD 95                                sub		ixl
 50+  E85B 4F                                   ld 		c,a
 51+  E85C 7A                                   ld 		a,d
 52+  E85D DD 94                                sub 	ixh
 53+  E85F 47                                   ld 		b,a
 54+  E860                                      ;; TODO ADD DOUBLE X CALC
 55+  E860 D5                                   push	de
 56+  E861 DD 55                                ld		d,ixl
 57+  E863 CB 22                                sla		d
 58+  E865 CD A1 E8                             call	.PlotLine			;CX-X,CY-Y
 59+  E868 D1                                   pop		de
 60+  E869 7B           .Line3:	                ld 		a,e
 61+  E86A DD 94                                sub		ixh
 62+  E86C 4F                                   ld 		c,a
 63+  E86D 7A                                   ld 		a,d
 64+  E86E DD 85                                add 	a,ixl
 65+  E870 47                                   ld 		b,a
 66+  E871                                      ;; TODO ADD DOUBLE Y CALC
 67+  E871 D5                                   push	de
 68+  E872 DD 54                                ld		d,ixh
 69+  E874 CB 22                                sla		d
 70+  E876 CD A1 E8                             call	.PlotLine			;CX-Y,CY+x
 71+  E879 D1                                   pop		de
 72+  E87A 7B           .Line4:	                ld 		a,e
 73+  E87B DD 94                                sub		ixh
 74+  E87D 4F                                   ld 		c,a
 75+  E87E 7A                                   ld 		a,d
 76+  E87F DD 95                                sub 	ixl
 77+  E881 47                                   ld 		b,a
 78+  E882                                      ;; TODO ADD DOUBLE Y CALC
 79+  E882 D5                                   push	de
 80+  E883 DD 54                                ld		d,ixh
 81+  E885 CB 22                                sla		d
 82+  E887 CD A1 E8                             call	.PlotLine			;CX-Y,CY+x
 83+  E88A D1                                   pop		de
 84+  E88B D9                                   exx
 85+  E88C CB 7C        .IncrementCircle:	    bit 7,h				; Check for Hl<=0
 86+  E88E 28 03                                jr z,.draw_circle_1
 87+  E890 19                                   add hl,de			; Delta=Delta+D1
 88+  E891 18 05                                jr .draw_circle_2		;
 89+  E893 09           .draw_circle_1:		    add hl,bc			; Delta=Delta+D2
 90+  E894 03                                   inc bc
 91+  E895 03                                   inc bc				; D2=D2+2
 92+  E896 DD 25                                dec ixh				; Y=Y-1
 93+  E898 03           .draw_circle_2:		    inc bc				; D2=D2+2
 94+  E899 03                                   inc bc
 95+  E89A 13                                   inc de				; D1=D1+2
 96+  E89B 13                                   inc de
 97+  E89C DD 2C                                inc ixl				; X=X+1
 98+  E89E C3 3E E8                             jp .CircleLoop
 99+  E8A1 D5 C5 E5 F5  .PlotLine:              push	de,,bc,,hl,,af
100+  E8A5 3E 00        .LineColour:	        ld		a,0         ; circle colur
101+  E8A7 5F                                   ld      e,a
102+  E8A8 CD 60 E2                             call 	l2_draw_horz_line
103+  E8AB F1 E1 C1 D1                          pop     de,,bc,,hl,,af
104+  E8AF C9                                   ret
105+  E8B0
# file closed: ./Layer2Graphics/layer2_plot_circle_fill.asm
166   E8B0                  INCLUDE "./Layer2Graphics/l2_draw_any_line.asm"
# file opened: ./Layer2Graphics/l2_draw_any_line.asm
  1+  E8B0              ; ">l2_draw_any_line, bc = y0,x0 de=y1,x1,a=color: determines if its horizontal, vertical or diagonal then hands off the work"
  2+  E8B0 08           l2_draw_any_line:       ex		af,af'              ; save colour into a'
  3+  E8B1 79                                   ld		a,c                 ; if x and e are the same its horizontal
  4+  E8B2 BB                                   cp		e
  5+  E8B3 28 08                                jr		z,.HorizontalLineCheck
  6+  E8B5 78                                   ld		a,b                 ; if b and d are the same its vertica;
  7+  E8B6 BA                                   cp		d
  8+  E8B7 28 0E                                jr		z,.VerticalLine
  9+  E8B9              ; use jp and get a free ret instruction optimisation
 10+  E8B9 08           .DiagonalLine:		    ex		af,af'			     ; get colour back into a
 11+  E8BA C3 09 E6                             jp		l2_draw_diagonal
 12+  E8BD
 13+  E8BD 78           .HorizontalLineCheck:   ld      a,b
 14+  E8BE BA                                   cp      d
 15+  E8BF 28 0B                                jr      z, .SinglePixel
 16+  E8C1 08           .HorizontalLine:        ex		af,af'              ; get colour back into a
 17+  E8C2 53                                   ld		d,e				    ; set d as target right pixel
 18+  E8C3 5F                                   ld		e,a				    ; e holds colour on this call
 19+  E8C4 C3 8C E2                             jp		l2_draw_horz_line_to
 20+  E8C7 08           .VerticalLine:          ex		af,af'
 21+  E8C8 5F                                   ld		e,a				    ; e holds colour on this call
 22+  E8C9 C3 0B E3                             jp		l2_draw_vert_line_to
 23+  E8CC 08           .SinglePixel:           ex		af,af'              ; get colour back into a
 24+  E8CD C3 FF E0                             jp      l2_plot_pixel
 25+  E8D0              ;......................................................
 26+  E8D0
# file closed: ./Layer2Graphics/l2_draw_any_line.asm
167   E8D0                  INCLUDE "./Layer2Graphics/l2_draw_line_v2.asm"
# file opened: ./Layer2Graphics/l2_draw_line_v2.asm
  1+  E8D0              ; ******************************************************************************
  2+  E8D0              ;
  3+  E8D0              ;	Draw a pixel line from (x0,y0) defined in (COORDS) - the current plot
  4+  E8D0              ;	coordinate, to the relative distance points (x0+x,y0+y).
  5+  E8D0              ;
  6+  E8D0              ;	Design & programming by Gunther Strube,	Copyright (C) InterLogic 1995
  7+  E8D0              ;
  8+  E8D0              ;	The (COORDS+0)	pointer contains the current y coordinate, (COORDS+1) the
  9+  E8D0              ;	current x coordinate. The main program should reset the (COORDS) variables
 10+  E8D0              ;	before using line drawing.
 11+  E8D0              ;
 12+  E8D0              ;	The routine checks the range of specified coordinates which is the
 13+  E8D0              ;	boundaries of the graphics area (256x64	pixels).
 14+  E8D0              ;	If a boundary error occurs the routine exits automatically.	This may be
 15+  E8D0              ;	useful if you are trying to draw a line longer than allowed. Only the
 16+  E8D0              ;	visible part will be drawn.
 17+  E8D0              ;
 18+  E8D0              ;	The hardware graphics memory is organized as (0,0) in the top left corner.
 19+  E8D0              ;
 20+  E8D0              ;	The plot routine is	defined by an address pointer	in IX.
 21+  E8D0              ;
 22+  E8D0              ;	IN:	HL =	move	relative x horisontal points (maximum +/- 255).
 23+  E8D0              ;		DE =	move	relative y vertical	points (maximum +/-	255).
 24+  E8D0              ;		IX =	pointer to plot routine that uses HL = (x,y)	of plot coordinate.
 25+  E8D0              ;
 26+  E8D0              ;	OUT:	None.
 27+  E8D0              ;
 28+  E8D0              ;	Registers	used	by routine:
 29+  E8D0              ;		   N	:	B, loop counter
 30+  E8D0              ;		   i	:	line	balance variable
 31+  E8D0              ;		   x	:	H/L,	horisontal, vertical distance	variables
 32+  E8D0              ;		   y	:	H/L,	horisontal, vertical distance	variables
 33+  E8D0              ;	  (x0,y0)	:	(h,l)
 34+  E8D0              ;	  direc_x	:	d, horisontal step increment
 35+  E8D0              ;	  direc_y	:	e, vertical step increment
 36+  E8D0              ;		 ddx	:	b, horisontal step increment
 37+  E8D0              ;		 ddy	:	c, vertical step increment
 38+  E8D0              ;
 39+  E8D0              ;		DE, A work registers.
 40+  E8D0              ;
 41+  E8D0              ; The algorithm in pseudo-code:
 42+  E8D0              ;
 43+  E8D0              ;	direc_x =	SGN x: direc_y	= SGN y
 44+  E8D0              ;	x = ABS x: y =	ABS y
 45+  E8D0              ;
 46+  E8D0              ;	if x	>= y
 47+  E8D0              ;		if x+y=0 then return
 48+  E8D0              ;		H = x
 49+  E8D0              ;		L = y
 50+  E8D0              ;		ddx = direc_x
 51+  E8D0              ;		ddy = 0
 52+  E8D0              ;	else
 53+  E8D0              ;		H = y
 54+  E8D0              ;		L = x
 55+  E8D0              ;		ddx = 0
 56+  E8D0              ;		ddy = direc_y
 57+  E8D0              ;	endif
 58+  E8D0              ;
 59+  E8D0              ;	B = H
 60+  E8D0              ;	i = INT(B/2)
 61+  E8D0              ;	FOR N=B TO 1 STEP -1
 62+  E8D0              ;		i = i + L
 63+  E8D0              ;		if i	< H
 64+  E8D0              ;			ix =	ddx
 65+  E8D0              ;			iy =	ddy
 66+  E8D0              ;		else
 67+  E8D0              ;			i = i - H
 68+  E8D0              ;			ix =	direc_x
 69+  E8D0              ;			iy =	direc_y
 70+  E8D0              ;		endif
 71+  E8D0              ;		x0 =	x0 +	ix
 72+  E8D0              ;		y0 =	y0 +	iy
 73+  E8D0              ;		plot	(x0,y0)
 74+  E8D0              ;	NEXT	N
 75+  E8D0              ;
 76+  E8D0              ;
 77+  E8D0              ;	Registers	changed after return:
 78+  E8D0              ;		..BCDEHL/IXIY/af......	same
 79+  E8D0              ;		AF....../..../..bcdehl	different
 80+  E8D0              ;
 81+  E8D0 DF           line_gfx_colour db $DF
 82+  E8D1 00 00        line_gfx_coords	dw 0
 83+  E8D3              LineHLtoDE:
 84+  E8D3 7C           TestMaxY:               ld	a,h ; were h = y or l = y?
 85+  E8D4 FE C0                                cp	192
 86+  E8D6 30 26                                jr	nc, exit_line		; y0	coordinate out	of range
 87+  E8D8 7A                                   ld	a,d
 88+  E8D9 FE C0                                cp	192
 89+  E8DB 30 21                                jr	nc, exit_line		; y1	coordinate out	of range
 90+  E8DD 22 D1 E8                             ld	(line_gfx_coords),hl		; the starting	point is now default
 91+  E8E0 E5                                   push	hl
 92+  E8E1 D5                                   push	de
 93+  E8E2 6C                                   ld	l,h				; L = x0
 94+  E8E3 62                                   ld	h,d				; H = x1
 95+  E8E4 7C           distanceX:		        ld	a,h
 96+  E8E5 95                                   sub	l
 97+  E8E6 6F                                   ld	l,a
 98+  E8E7 26 00                                ld	h,0
 99+  E8E9 30 02                                jr	nc, distanceXDone
100+  E8EB 26 FF                                ld	h,-1
101+  E8ED D1           distanceXDone:          pop	de
102+  E8EE E3                                   ex	(sp),hl			; L = y0
103+  E8EF 63                                   ld	h,e				; H = y1
104+  E8F0 7C           distanceY:		        ld	a,h
105+  E8F1 95                                   sub	l
106+  E8F2 6F                                   ld	l,a
107+  E8F3 26 00                                ld	h,0
108+  E8F5 30 02                                jr	nc, distanceYDone
109+  E8F7 26 FF                                ld	h,-1
110+  E8F9 D1           distanceYDone:          pop	de
111+  E8FA EB                                   ex	de,hl			; h.dist.	= HL, v.dist. = DE
112+  E8FB CD FF E8                             call	DrawLineRelative			; draw line...
113+  E8FE C9           exit_line:              ret
114+  E8FF
115+  E8FF              ; ***************************************************************************
116+  E8FF              ;
117+  E8FF              ;	IN:	HL =	move	relative x horisontal points (maximum +/- 255).
118+  E8FF              ;		DE =	move	relative y vertical	points (maximum +/-	255).
119+  E8FF              ;
120+  E8FF              ; OUT: h - l distance in	HL
121+  E8FF              ;
122+  E8FF
123+  E8FF D5           DrawLineRelative:       push	de
124+  E900 E5                                   push	hl
125+  E901 D9                                   exx
126+  E902 E1                                   pop	hl					; get relative	horisontal movement
127+  E903 CD 6E E9                             call	sgn
128+  E906 57                                   ld	d,a					; direc_x	= SGN(x) installed d = +/-1 for horizontal update
129+  E907 CD 7B E9                             call	absValue
130+  E90A 45                                   ld	b,l					; x = ABS(x)
131+  E90B E1           DrawLineGetVertRelative:pop	hl					; get relative	vertical movement
132+  E90C CD 6E E9                             call	sgn
133+  E90F 5F                                   ld	e,a					; direc_y	= SGN(y) installed  = +/-1 for vertical update
134+  E910 CD 7B E9                             call	absValue
135+  E913 4D                                   ld	c,l					; y = ABS(y) so now bc = dxdy
136+  E914              ; so by here BC = dx dy HL in increment/decrement x y
137+  E914 C5                                   push	bc
138+  E915 D9                                   exx
139+  E916 E1                                   pop	hl					; H = absolute	x dist., L = absolute y distance
140+  E917 7C                                   ld	a,h
141+  E918 BD                                   cp	l
142+  E919 38 0A                                jr	c, x_smaller_y		; if	x >=	y
143+  E91B B4           areXandYZero:           or	h					;	if x+y = 0
144+  E91C 28 4F                                jr	z, exit_draw		;		return
145+  E91E D9           y_lessorequal_x:        exx						;	else
146+  E91F 42                                   ld	b,d					;		ddx = direc_x
147+  E920 0E 00                                ld	c,0					;		ddy = 0
148+  E922 D9                                   exx
149+  E923 18 08                                jr	init_drawloop		; else
150+  E925 7C           x_smaller_y:	        ld	a,h
151+  E926 65                                   ld	h,l					;	H = y
152+  E927 6F                                   ld	l,a					;	L = x
153+  E928 D9                                   exx
154+  E929 06 00                                ld	b,0					;	ddx = 0
155+  E92B 4B                                   ld	c,e					;	ddy = direc_y
156+  E92C D9                                   exx
157+  E92D 44           init_drawloop:	        ld	b,h
158+  E92E 4C                                   ld	c,h					; B = H
159+  E92F CB 39                                srl	c					; i = INT(B/2)
160+  E931              										; FOR N=B	TO 1	STEP	-1
161+  E931 79           drawloop:		        ld	a,c
162+  E932 85                                   add	a,l
163+  E933 38 09                                jr	c, i_greater		;	i + L > 255  (i > H)
164+  E935 BC                                   cp	h
165+  E936 30 06                                jr	nc, i_greater		;	if i	< H
166+  E938 4F                                   ld	c,a					;		i = i + L
167+  E939 D9                                   exx
168+  E93A C5                                   push	bc				;		ix =	ddx:	iy =	ddy
169+  E93B D9                                   exx
170+  E93C 18 05                                jr	check_plot			;	else
171+  E93E 94           i_greater:		        sub	h					;		i = i - H
172+  E93F 4F                                   ld	c,a
173+  E940 D9                                   exx
174+  E941 D5                                   push	de				;		ix =	direc_x: iy = direc_y
175+  E942 D9                                   exx						;	endif
176+  E943 E3           check_plot:		        ex	(sp),hl				;	preserve H,L distances on stack
177+  E944 EB                                   ex	de,hl				;	D,E = ix,	iy
178+  E945 2A D1 E8                             ld	hl,(line_gfx_coords)
179+  E948 7D                                   ld	a,l
180+  E949 83                                   add	a,e					;
181+  E94A 6F                                   ld	l,a					;	y0 =	y0 +	iy (y0 is	checked by plot)
182+  E94B 7A                                   ld	a,d
183+  E94C 3C                                   inc	a
184+  E94D 84                                   add	a,h
185+  E94E 38 04                                jr	c, check_range		;	check out	of range
186+  E950 28 1A                                jr	z, range_error		;	Fz=1	& Fc=0 denotes	x0 <	0
187+  E952 18 02                                jr	plot_point
188+  E954 20 16        check_range:            jr	nz, range_error	;	Fz=0	& Fc=1 denotes	x0 >	255
189+  E956
190+  E956 3D           plot_point:             dec	a
191+  E957 C5                                   push	bc
192+  E958 F5                                   push	af
193+  E959 47                                   ld	    b,a					;	x0 =	x0 +	ix
194+  E95A 4D                                   ld		c,l
195+  E95B 3A D0 E8                             ld		a,(line_gfx_colour)
196+  E95E ED 43 D1 E8                          ld      (line_gfx_coords),bc
197+  E962 CD FF E0                             call	l2_plot_pixel
197+  E965
198+  E965 F1                                   pop		af
199+  E966 C1                                   pop		bc
200+  E967 E1           plot_RET:		        pop	hl					;	restore H,L distances...
201+  E968 10 C7                                djnz	drawloop		; NEXT N
202+  E96A 18 01                                jr	exit_draw
203+  E96C
204+  E96C E1           range_error:	        pop	hl					; remove H,L distances...
205+  E96D C9           exit_draw:		        ret
206+  E96E
207+  E96E
208+  E96E              ; ******************************************************************************
209+  E96E              ;
210+  E96E              ;	SGN (Signum value) of 16	bit signed integer.
211+  E96E              ;
212+  E96E              ;	IN:		HL =	integer
213+  E96E              ;	OUT:		A = result: 0,1,-1 (if zero, positive, negative)
214+  E96E              ;
215+  E96E              ;	Registers	changed after return:
216+  E96E              ;	..BCDEHL/IXIY	same
217+  E96E              ;	AF....../....	different
218+  E96E              ;
219+  E96E 7C           sgn:				    ld	a,h
220+  E96F B5                                   or	l
221+  E970 C8                                   ret	z				; integer	is zero, return 0...
222+  E971 CB 7C                                bit	7,h
223+  E973 20 03                                jr	nz, negative_int
224+  E975 3E 01                                ld	a,1
225+  E977 C9                                   ret
226+  E978 3E FF        negative_int:		    ld	a,-1
227+  E97A C9                                   ret
228+  E97B
229+  E97B
230+  E97B              ; ******************************************************************************
231+  E97B              ;
232+  E97B              ;	ABS (Absolute value) of 16 bit signed integer.
233+  E97B              ;
234+  E97B              ;	IN:		HL =	integer
235+  E97B              ;	OUT:		HL =	converted	integer
236+  E97B              ;
237+  E97B              ;	Registers	changed after return:
238+  E97B              ;	A.BCDE../IXIY	same
239+  E97B              ;	.F....HL/....	different
240+  E97B              ;
241+  E97B CB 7C        absValue:			    bit	7,h
242+  E97D C8                                   ret	z				; integer	is positive...
243+  E97E D5                                   push	de
244+  E97F EB                                   ex	de,hl
245+  E980 21 00 00                             ld	hl,0
246+  E983 BF                                   cp	a				; Fc	= 0,	may not be used...
247+  E984 ED 52                                sbc	hl,de			; convert	negative integer
248+  E986 D1                                   pop	de
249+  E987 C9                                   ret
250+  E988
# file closed: ./Layer2Graphics/l2_draw_line_v2.asm
168   E988
169   E988
170   E988                  SAVENEX OPEN "keyTst.nex", $8000 , $7F00
171   E988                  SAVENEX CFG  0,0,0,1
172   E988                  SAVENEX AUTO
173   E988                  SAVENEX CLOSE
174   E988
# file closed: keyTst.asm
