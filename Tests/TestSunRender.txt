# file opened: TestSunRender.asm
   1  0000               DEVICE ZXSPECTRUMNEXT
   2  0000               DEVICE ZXSPECTRUMNEXT
   3  0000               DEFINE  DOUBLEBUFFER 1
   4  0000               CSPECTMAP eliteN.map
   5  0000               OPT --zxnext=cspect --syntax=a --reversepop
   6  0000
   7  0000              DEBUGSEGSIZE   equ 1
   8  0000              DEBUGLOGSUMMARY equ 1
   9  0000              ;DEBUGLOGDETAIL equ 1
  10  0000
  11  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  12  0000              ; Game Defines
  13  0000              ScreenLocal      EQU 0
  14  0000              ScreenGalactic   EQU ScreenLocal + 1
  15  0000              ScreenMarket     EQU ScreenGalactic + 1
  16  0000              ScreenMarketDsp  EQU ScreenMarket + 1
  17  0000              ScreenStatus     EQU ScreenMarketDsp + 1
  18  0000              ScreenInvent     EQU ScreenStatus + 1
  19  0000              ScreenPlanet     EQU ScreenInvent + 1
  20  0000              ScreenEquip      EQU ScreenPlanet + 1
  21  0000              ScreenLaunch     EQU ScreenEquip + 1
  22  0000              ScreenFront      EQU ScreenLaunch + 1
  23  0000              ScreenAft        EQU ScreenFront+1
  24  0000              ScreenLeft       EQU ScreenAft+1
  25  0000              ScreenRight      EQU ScreenLeft+1
  26  0000              ScreenDocking    EQU ScreenRight+1
  27  0000              ScreenHyperspace EQU ScreenDocking+1
  28  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  29  0000              ; Colour Defines
  30  0000                  INCLUDE "../Hardware/L2ColourDefines.asm"
# file opened: ../Hardware/L2ColourDefines.asm
   1+ 0000              L2ColourBLACK           EQU   0
   2+ 0000              L2ColourRED_1           EQU 224                 ; RGB 255,  0,  0
   3+ 0000              L2ColourRED_2           EQU 192                 ; RGB 218,  0,  0
   4+ 0000              L2ColourRED_3           EQU 160                 ; RGB 182,  0,  0
   5+ 0000              L2ColourRED_4           EQU 128                 ; RGB 145,  0,  0
   6+ 0000              L2ColourRED_5           EQU  96                 ; RGB 109,  0,  0
   7+ 0000              L2ColourRED_6           EQU  64                 ; RGB  72,  0,  0
   8+ 0000              L2ColourRED_7           EQU  32                 ; RGB  36,  0,  0
   9+ 0000              L2ColourYELLOW_1        EQU 252                 ; RGB 255,255,  0
  10+ 0000              L2ColourYELLOW_2        EQU 216                 ; RGB 218,218,  0
  11+ 0000              L2ColourYELLOW_3        EQU 180                 ; RGB 182,182,  0
  12+ 0000              L2ColourYELLOW_4        EQU 144                 ; RGB 145,145,  0
  13+ 0000              L2ColourYELLOW_5        EQU 108                 ; RGB 109.109,  0
  14+ 0000              L2ColourYELLOW_6        EQU  72                 ; RGB  72, 72,  0
  15+ 0000              L2ColourYELLOW_7        EQU  36                 ; RGB  36, 36,  0
  16+ 0000              L2ColourGREEN_1		    EQU  28                 ; RGB   0,255,  0
  17+ 0000              L2ColourGREEN_2		    EQU  24                 ; RGB   0,218,  0
  18+ 0000              L2ColourGREEN_3		    EQU  16                 ; RGB   0,145,  0
  19+ 0000              L2ColourGREEN_4         EQU  12                 ; RGB   0,109,  0
  20+ 0000              L2ColourGREEN_5         EQU   8                 ; RGB   0, 72,  0
  21+ 0000              L2ColourGREEN_6         EQU   4                 ; RGB   0, 36,  0
  22+ 0000              L2ColourBLUE_1          EQU   3                 ; RGB 0,0,255
  23+ 0000              L2ColourBLUE_2          EQU   2                 ; RGB 0,0,170
  24+ 0000              L2ColourBLUE_3          EQU   1                 ; RGB 0,0,85
  25+ 0000
  26+ 0000
  27+ 0000              L2ColourWHITE_1         EQU 255                 ; RGB 255,255,255
  28+ 0000              L2ColourWHITE_2         EQU 146
  29+ 0000              L2ColourGREY_1		    EQU L2ColourWHITE_2
  30+ 0000              L2ColourGREY_2		    EQU 109
  31+ 0000              L2ColourGREY_3		    EQU  73
  32+ 0000              L2ColourGREY_4		    EQU  37
  33+ 0000
  34+ 0000              L2ColourGREEN_MB        EQU  29                 ;RGB 0,255,85
  35+ 0000              L2ColourGREEN_MR        EQU 124                 ;RGB 109.255,0
  36+ 0000              L2ColourCREAM_1         EQU 218                 ; RGB 218,218,170
  37+ 0000              L2ColourCREAM_2         EQU 182                 ; RGB 182,182,170
  38+ 0000              L2ColourCREAM_3         EQU 146                 ; RGB 145,145,170
  39+ 0000
  40+ 0000              L2ColourTRANSPARENT     EQU 227                 ; RGB 255,  0,255
  41+ 0000              L2ColourMAGENTA_1       EQU 162                 ; RGB 182,  0,170
  42+ 0000              L2ColourMAGENTA_2       EQU 130                 ; RGB 145,  0,170
  43+ 0000              L2ColourMAGENTA_3       EQU  97                 ; RGB 109,  0, 85
  44+ 0000              L2ColourMAGENTA_4       EQU  65                 ; RGB  72,  0, 85
  45+ 0000              L2ColourORANGE_1        EQU 236                 ; RGB
  46+ 0000              L2ColourORANGE_2        EQU 168                 ; RGB
  47+ 0000              L2ColourORANGE_3        EQU  68                 ; RGB
  48+ 0000              L2ColourCYAN_1          EQU  31                 ; RGB   0,255, 255
  49+ 0000              L2ColourCYAN_2          EQU  18                 ; RGB
  50+ 0000              L2ColourCYAN_3          EQU   9                 ; RGB
  51+ 0000              L2ColourPURPLE_1        EQU 109                 ; RGB
  52+ 0000              L2ColourPURPLE_2        EQU  66                 ; RGB
  53+ 0000              L2ColourPURPLE_3        EQU  33                 ; RGB
  54+ 0000              L2ColourPINK_1		    EQU 231                 ; RGB
  55+ 0000              L2ColourPINK_2		    EQU 226                 ; RGB
  56+ 0000              L2ColourPINK_3		    EQU 225                 ; RGB
  57+ 0000              L2ColourPINK_4		    EQU 224                 ; RGB
  58+ 0000
# file closed: ../Hardware/L2ColourDefines.asm
  31  0000                  INCLUDE "../Hardware/L1ColourDefines.asm"
# file opened: ../Hardware/L1ColourDefines.asm
   1+ 0000
   2+ 0000              L1ColourInkBlack        EQU %00000000
   3+ 0000              L1ColourInkBlue         EQU %00000001
   4+ 0000              L1ColourInkRed          EQU %00000010
   5+ 0000              L1ColourInkMagenta      EQU %00000011
   6+ 0000              L1ColourInkGreen        EQU %00000100
   7+ 0000              L1ColourInkCyan         EQU %00000101
   8+ 0000              L1ColourInkYellow       EQU %00000110
   9+ 0000              L1ColourInkWhite        EQU %00000111
  10+ 0000              L1ColourPaperBlack      EQU %00000000
  11+ 0000              L1ColourPaperBlue       EQU %00001000
  12+ 0000              L1ColourPaperRed        EQU %00010000
  13+ 0000              L1ColourPaperMagenta    EQU %00011000
  14+ 0000              L1ColourPaperGreen      EQU %00100000
  15+ 0000              L1ColourPaperCyan       EQU %00101000
  16+ 0000              L1ColourPaperYellow     EQU %00110000
  17+ 0000              L1ColourPaperWhite      EQU %00111000
  18+ 0000              L1ColourFlash           EQU %10000000
  19+ 0000              L1ColourBright          EQU %01000000
  20+ 0000              ;----------------------------------------------------------------------------------------------------------------------------------
  21+ 0000              ; Screen Specific Colour Defines
  22+ 0000              L1InvHighlight          EQU L1ColourBright | L1ColourPaperRed   | L1ColourInkYellow
  23+ 0000              L1InvLowlight           EQU                  L1ColourPaperBlack | L1ColourInkWhite
# file closed: ../Hardware/L1ColourDefines.asm
  32  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  33  0000              ; Total screen list
  34  0000              ; Local Chart
  35  0000              ; Galactic Chart
  36  0000              ; Market Prices
  37  0000              ; Inventory
  38  0000              ; Comander status
  39  0000              ; System Data
  40  0000              ; Mission Briefing
  41  0000              ; missio completion
  42  0000              ; Docked  Menu (only place otehr than pause you can load and save)
  43  0000              ; Pause Menu (only place you can load from )
  44  0000              ; byint and selling equipment
  45  0000              ; bying and selling stock
  46  0000
  47  0000                                      INCLUDE "../Hardware/register_defines.asm"
# file opened: ../Hardware/register_defines.asm
   1+ 0000              IO_LAYER2_PORT                          EQU $123B
   2+ 0000              IO_EXT_BANK_PORT 			            EQU $DFFD ; 57341
   3+ 0000              IO_BANK_PORT                            EQU $7FFD ; 32765
   4+ 0000              REGISTER_NUMBER_PORT					EQU $243B
   5+ 0000              REGISTER_VALUE_PORT						EQU $253B
   6+ 0000              SPRITE_SLOT_PORT						EQU $303B
   7+ 0000              SPRITE_INFO_PORT                        EQU $0057
   8+ 0000              SPRITE_PATTERN_UPLOAD_PORT				EQU $005B
   9+ 0000
  10+ 0000              MACHINE_ID_REGISTER						EQU 0
  11+ 0000              VERSION_REGISTER						EQU 1
  12+ 0000              RESET_REGISTER		    				EQU 2
  13+ 0000              MACHINE_TYPE_REGISTER					EQU 3
  14+ 0000              PAGE_RAM_REGISTER						EQU 4
  15+ 0000              PERIPHERAL_1_REGISTER					EQU 5
  16+ 0000              PERIPHERAL_2_REGISTER					EQU 6
  17+ 0000              TURBO_MODE_REGISTER						EQU 7
  18+ 0000              PERIPHERAL_3_REGISTER					EQU 8
  19+ 0000              ANTI_BRICK_SYSTEM_REGISTER				EQU 10
  20+ 0000              LAYER2_RAM_PAGE_REGISTER				EQU 18
  21+ 0000              LAYER2_RAM_SHADOW_REGISTER      		EQU 19
  22+ 0000              TRANSPARENCY_COLOUR_REGISTER			EQU 20
  23+ 0000              SPRITE_LAYERS_SYSTEM_REGISTER			EQU 21
  24+ 0000              LAYER2_OFFSET_X_REGISTER				EQU 22
  25+ 0000              LAYER2_OFFSET_Y_REGISTER				EQU 23
  26+ 0000              CLIP_WINDOW_LAYER2_REGISTER				EQU 24
  27+ 0000              CLIP_WINDOW_SPRITES_REGISTER			EQU 25
  28+ 0000              CLIP_WINDOW_ULA_REGISTER				EQU 26
  29+ 0000              CLIP_WINDOW_CONTROL_REGISTER			EQU 28
  30+ 0000              ACTIVE_VIDEO_LINE_MSB_REGISTER			EQU 30
  31+ 0000              ACTIVE_VIDEO_LINE_LSB_REGISTER			EQU 31
  32+ 0000              LINE_INTERRUPT_CONTROL_REGISTER			EQU 34
  33+ 0000              LINE_INTERRUPT_VALUE_LSB_REGISTER		EQU 35
  34+ 0000              KEYMAP_HIGH_ADDRESS_REGISTER			EQU 40
  35+ 0000              KEYMAP_LOW_ADDRESS_REGISTER				EQU 41
  36+ 0000              KEYMAP_HIGH_DATA_REGISTER				EQU 42
  37+ 0000              KEYMAP_LOW_DATA_REGISTER				EQU 43
  38+ 0000              DAC_B_MIRROR_REGISTER                   EQU 44
  39+ 0000              DAC_AB_MIRROR_REGISTER                  EQU 45
  40+ 0000              DAC_C_MORROR_REGISTER                   EQU 46
  41+ 0000              TILEMAP_OFFSET_XMSB_REGISTER            EQU 47
  42+ 0000              TILEMAP_OFFSET_XLSB_REGISTER            EQU 48
  43+ 0000              TILEMAP_OFFSET_YMSB_REGISTER            EQU 49
  44+ 0000              LORES_OFFSET_X_REGISTER					EQU 50
  45+ 0000              LORES_OFFSET_Y_REGISTER					EQU 51
  46+ 0000              SPRITE_PORT_INDEX_REGISTER              EQU 52
  47+ 0000              SPRITE_PORT_ATTR0_REGISTER              EQU 53
  48+ 0000              SPRITE_PORT_ATTR1_REGISTER              EQU 54
  49+ 0000              SPRITE_PORT_ATTR2_REGISTER              EQU 55
  50+ 0000              SPRITE_PORT_ATTR3_REGISTER              EQU 56
  51+ 0000              SPRITE_PORT_ATTR4_REGISTER              EQU 57
  52+ 0000              PALETTE_INDEX_REGISTER					EQU 64
  53+ 0000              PALETTE_VALUE_8BIT_REGISTER				EQU 65
  54+ 0000              PALETTE_FORMAT_REGISTER					EQU 66
  55+ 0000              PALETTE_CONTROL_REGISTER				EQU 67
  56+ 0000              PALETTE_VALUE_9BIT_REGISTER				EQU 68
  57+ 0000              MMU_SLOT_0_REGISTER						EQU 80
  58+ 0000              MMU_SLOT_1_REGISTER						EQU 81
  59+ 0000              MMU_SLOT_2_REGISTER						EQU 82
  60+ 0000              MMU_SLOT_3_REGISTER						EQU 83
  61+ 0000              MMU_SLOT_4_REGISTER						EQU 84
  62+ 0000              MMU_SLOT_5_REGISTER						EQU 85
  63+ 0000              MMU_SLOT_6_REGISTER						EQU 86
  64+ 0000              MMU_SLOT_7_REGISTER						EQU 87
  65+ 0000              COPPER_DATA_REGISTER					EQU 96
  66+ 0000              COPPER_CONTROL_LOW_REGISTER				EQU 97
  67+ 0000              COPPER_CONTROL_HIGH_REGISTER			EQU 98
  68+ 0000              DISPLAY_CONTROL_1_REGISTER              EQU 105
  69+ 0000              LAYER_2_CONTROL_REGISTER                EQU 112
  70+ 0000              LAYER_2_X_OFFSET_MSB_REGISTER           EQU 113
  71+ 0000              DEBUG_LEDS_REGISTER						EQU 255
  72+ 0000
  73+ 0000
  74+ 0000              GetNextReg:	MACRO register
  75+ 0000 ~                        push bc
  76+ 0000 ~                            ld bc,$243B
  77+ 0000 ~                                ld a,register
  78+ 0000 ~                                out (c),a
  79+ 0000 ~                                inc b
  80+ 0000 ~                            in a,(c)
  81+ 0000 ~                        pop bc
  82+ 0000                          ENDM
  83+ 0000
# file closed: ../Hardware/register_defines.asm
  48  0000                                      INCLUDE "../Layer2Graphics/layer2_defines.asm"
# file opened: ../Layer2Graphics/layer2_defines.asm
   1+ 0000
   2+ 0000
   3+ 0000              LAYER2_SHIFTED_SCREEN_TOP  	 equ 0
   4+ 0000              LAYER2_SHIFTED_SCREEN_MIDDLE equ $40
   5+ 0000              LAYER2_SHIFTED_SCREEN_BOTTOM equ $80
   6+ 0000
   7+ 0000              ; note hi byte is not decoded on DMA port so can out OUTIR
   8+ 0000              IO_DATAGEAR_DMA_PORT 		 equ 107
   9+ 0000              IO_SPRITE_SLOT_PORT 		 equ 12347
  10+ 0000              IO_SPRITE_PATTERN_PORT       equ 91
  11+ 0000              IO_SPRITE_ATTRIBUTES_PORT    equ 87
  12+ 0000
  13+ 0000              LAYER2_VISIBLE_MASK 		equ $02
  14+ 0000              ; DEBUG 0 for always write to primary 08 for double buffering
  15+ 0000                  IFDEF DOUBLEBUFFER
  16+ 0000              LAYER2_SHADOW_SCREEN_MASK 	equ $08
  17+ 0000                  ELSE
  18+ 0000 ~            LAYER2_SHADOW_SCREEN_MASK 	equ $00
  19+ 0000                  ENDIF
  20+ 0000              LAYER2_READ_ENABLE_MASK 	equ %00000100
  21+ 0000              LAYER2_WRITE_ENABLE_MASK 	equ %00000001
  22+ 0000              LAYER2_READ_WRITE_MASK      equ %00000101
  23+ 0000              LAYER2_SCREEN_SECTION_MASK 	equ $03
  24+ 0000              LAYER2_SCREEN_SECTION_SHIFT equ 6
  25+ 0000
  26+ 0000              LAYER2_DISABLE_MEM_WRITE    equ %11111110
  27+ 0000              LAYER2_DISABLE_MEM_READ     equ %11111011
  28+ 0000              LAYER2_DISABLE_MEM_ACCESS   equ %11111010
  29+ 0000
  30+ 0000              LAYER2_SCREEN_BANK1          equ 8
  31+ 0000              LAYER2_SCREEN_BANK2          equ 9
  32+ 0000              LAYER2_SCREEN_BANK3          equ 10
  33+ 0000              LAYER2_SHADOW_BANK1          equ 11
  34+ 0000              LAYER2_SHADOW_BANK2          equ 12
  35+ 0000              LAYER2_SHADOW_BANK3          equ 13
  36+ 0000
  37+ 0000              SCREEN_HEIGHT 				 equ 192
  38+ 0000              SCREEN_RAM_BASE				 equ $0000
  39+ 0000              SCREEN_HOZ_MIN_PIX		     equ 10
  40+ 0000
  41+ 0000              SPRITES_VISIBLE_MASK         equ $01
  42+ 0000              SPRITES_ON_BORDER_MASK       equ $02
  43+ 0000              LAYER_PRIORITIES_MASK        equ $07
  44+ 0000              LORES_MODE_MASK              equ $80
  45+ 0000              LAYER_PRIORITIES_SHIFT       equ 2
  46+ 0000
  47+ 0000              LAYER_PRIORITIES_S_L_U 		equ 0
  48+ 0000              LAYER_PRIORITIES_L_S_U 		equ 1
  49+ 0000              LAYER_PRIORITIES_S_U_L  	equ 2
  50+ 0000              LAYER_PRIORITIES_L_U_S 		equ 3
  51+ 0000              LAYER_PRIORITIES_U_S_L 		equ 4
  52+ 0000              LAYER_PRIORITIES_U_L_S 		equ 5
  53+ 0000
  54+ 0000              DMA_WRO_BLOCK_PORTA_A2B_XFR  equ $7D
  55+ 0000              DMA_WRO_BLOCK_PORTA_B2A_XFR  equ $79
  56+ 0000              DMA_WR1_P1FIXED_MEMORY       equ $24
  57+ 0000              DMA_WR1_P1DEC_MEMORY         equ $04
  58+ 0000              DMA_WR1_P1INC_MEMORY         equ $14
  59+ 0000              DMA_WR2_P2FIXED_MEMORY       equ $20
  60+ 0000              DMA_WR2_P2DEC_MEMORY         equ $00
  61+ 0000              DMA_WR2_P2INC_MEMORY         equ $10
  62+ 0000              DMA_WR4_CONT_MODE            equ $AD
  63+ 0000              DMA_RESET                    equ $c3
  64+ 0000              DMA_RESET_PORT_A_TIMING      equ $c7
  65+ 0000              DMA_RESET_PORT_B_TIMING      equ $cb
  66+ 0000              DMA_LOAD                     equ $cf
  67+ 0000              DMA_CONTINUE                 equ $d3
  68+ 0000              DMA_DISABLE_INTERUPTS        equ $af
  69+ 0000              DMA_ENABLE_INTERUPTS         equ $ab
  70+ 0000              DMA_RESET_DISABLE_INTERUPTS  equ $a3
  71+ 0000              DMA_ENABLE_AFTER_RETI        equ $b7
  72+ 0000              DMA_READ_STATUS_BYTE         equ $bf
  73+ 0000              DMA_REINIT_STATUS_BYTE       equ $8b
  74+ 0000              DMA_START_READ_SEQUENCE      equ $a7
  75+ 0000              DMA_FORCE_READY              equ $b3
  76+ 0000              DMA_STOP_AT_END			     equ $82
  77+ 0000              DMA_DISABLE                  equ $83
  78+ 0000              DMA_ENABLE                   equ $87
  79+ 0000              DMA_WRITE_REGISTER_COMMAND   equ $bb
  80+ 0000              DMA_BURST                    equ $cd
  81+ 0000              DMA_CONTINUOUS               equ $ad
  82+ 0000              ZXN_DMA_PORT                 equ $6b
  83+ 0000
  84+ 0000
  85+ 0000              COLOUR_TRANSPARENT			 equ $E3
  86+ 0000
  87+ 0000
  88+ 0000
  89+ 0000
# file closed: ../Layer2Graphics/layer2_defines.asm
  49  0000                                      INCLUDE	"../Hardware/memory_bank_defines.asm"
# file opened: ../Hardware/memory_bank_defines.asm
   1+ 0000
   2+ 0000              membanksize			    equ	$1FFF
   3+ 0000
   4+ 0000              StartOfBank     	    equ $0000
   5+ 0000
   6+ 0000              membank0 			    equ $0000
   7+ 0000              dmaCopySrcAddr		    equ	$0000
   8+ 0000              membank1 			    equ $2000
   9+ 0000              membank2 			    equ $4000
  10+ 0000              membank3 			    equ $6000
  11+ 0000              membank4 			    equ $8000
  12+ 0000              membank5 			    equ $a000
  13+ 0000              membank6 			    equ $c000
  14+ 0000              ScreenBank              equ $c000
  15+ 0000              MenuGalChtAddr          equ $c000
  16+ 0000              MenuEquipSAddr          equ $c000
  17+ 0000              MenuInventAddr          equ $c000
  18+ 0000              MenuMarketAddr          equ $c000
  19+ 0000              DispMarketAddr          equ $c000
  20+ 0000              MenuShrChtAddr          equ $c000
  21+ 0000              MenuStatusAddr          equ $c000
  22+ 0000              MenuSystemAddr          equ $c000
  23+ 0000              ViewFrontAddr           equ $c000
  24+ 0000              SunBankAddr             equ $c000
  25+ 0000              PlanetBankAddr          equ $c000
  26+ 0000              UniverseBankAddr	    equ $c000
  27+ 0000              LaunchShipAddr          equ $c000
  28+ 0000              membank7 			    equ $e000
  29+ 0000              L1membankAddr   	    equ $e000
  30+ 0000              L2membankAddr   	    equ $e000
  31+ 0000              ShipModelsAddr	        equ $e000
  32+ 0000              SpritemembankAddr       equ $e000
  33+ 0000              ResetUniverseAddr       equ $e000
  34+ 0000              StockTableAddr	        equ $e000
  35+ 0000              CommanderAddr           equ $e000
  36+ 0000              LAYER2Addr              equ $e000
  37+ 0000              LAYER1Addr              equ $e000
  38+ 0000              SPRITEAddr              equ $e000
  39+ 0000              ConsoleImageAddr        equ $e000
  40+ 0000              GalaxyDataAddr          equ $e000
  41+ 0000
  42+ 0000              EXSDOSMMU0              equ MMU_SLOT_0_REGISTER
  43+ 0000              EXSDOSMMU1              equ MMU_SLOT_1_REGISTER
  44+ 0000              DMACpySourceMMU		    equ	MMU_SLOT_0_REGISTER
  45+ 0000              SunMMU 		            equ MMU_SLOT_6_REGISTER
  46+ 0000              PlanetMMU 		        equ MMU_SLOT_6_REGISTER
  47+ 0000              UniverseMMU 		    equ MMU_SLOT_6_REGISTER
  48+ 0000              ScreenBankMMU           equ MMU_SLOT_6_REGISTER
  49+ 0000              MenuEquipSMMU           equ MMU_SLOT_6_REGISTER
  50+ 0000              MenuShrChtMMU           equ MMU_SLOT_6_REGISTER
  51+ 0000              MenuGalChtMMU           equ MMU_SLOT_6_REGISTER
  52+ 0000              MenuInventMMU           equ MMU_SLOT_6_REGISTER
  53+ 0000              MenuSystemMMU           equ MMU_SLOT_6_REGISTER
  54+ 0000              MenuMarketMMU           equ MMU_SLOT_6_REGISTER
  55+ 0000              DispMarketMMU           equ MMU_SLOT_6_REGISTER
  56+ 0000              MenuStatusMMU           equ MMU_SLOT_6_REGISTER
  57+ 0000              LaunchShipMMU           equ MMU_SLOT_6_REGISTER
  58+ 0000              L1memMMU       		    equ MMU_SLOT_7_REGISTER
  59+ 0000              L2memMMU       		    equ MMU_SLOT_7_REGISTER
  60+ 0000              SpritememMMU   		    equ MMU_SLOT_7_REGISTER
  61+ 0000              ShipModelMMU  		    equ MMU_SLOT_7_REGISTER
  62+ 0000              ResetUniverseMMU	    equ MMU_SLOT_7_REGISTER
  63+ 0000              CommanderMMU	        equ MMU_SLOT_7_REGISTER
  64+ 0000              StockTableMMU		    equ MMU_SLOT_7_REGISTER
  65+ 0000              ConsoleImageDataMMU	    equ MMU_SLOT_7_REGISTER
  66+ 0000              GalaxyDataMMU	        equ MMU_SLOT_7_REGISTER
  67+ 0000
  68+ 0000              BankResetUniv           equ 49
  69+ 0000              BankMenuShrCht          equ 50
  70+ 0000              BankMenuGalCht          equ 51
  71+ 0000              BankMenuInvent          equ 52
  72+ 0000              BankMenuSystem          equ 53
  73+ 0000              BankMenuMarket          equ 54
  74+ 0000              BankStockTable          equ 55
  75+ 0000              BankCommander           equ 56
  76+ 0000              BankLAYER2              equ 57
  77+ 0000              BankLAYER1              equ 58
  78+ 0000              BankShipModels1         equ 59
  79+ 0000              BankSPRITE              equ 60
  80+ 0000              BankConsole             equ 61
  81+ 0000              BankFrontView           equ 62
  82+ 0000              BankMenuStatus          equ 63
  83+ 0000              BankMenuEquipS          equ 64
  84+ 0000              BankLaunchShip          equ 65
  85+ 0000              BankDispMarket          equ 66
  86+ 0000              BankShipModels2         equ 67
  87+ 0000              BankShipModels3         equ 68
  88+ 0000              BankShipModels4         equ 69
  89+ 0000
  90+ 0000              BankUNIVDATA0           equ 70
  91+ 0000              BankUNIVDATA1           equ 71
  92+ 0000              BankUNIVDATA2           equ 72
  93+ 0000              BankUNIVDATA3           equ 73
  94+ 0000              BankUNIVDATA4           equ 74
  95+ 0000              BankUNIVDATA5           equ 75
  96+ 0000              BankUNIVDATA6           equ 76
  97+ 0000              BankUNIVDATA7           equ 77
  98+ 0000              BankUNIVDATA8           equ 78
  99+ 0000              BankUNIVDATA9           equ 79
 100+ 0000              BankUNIVDATA10          equ 80
 101+ 0000              BankUNIVDATA11          equ 81
 102+ 0000              BankUNIVDATA12          equ 82
 103+ 0000              BankSunData             equ 83
 104+ 0000              BankPlanetData          equ 84
 105+ 0000
 106+ 0000              BankGalaxyData0         equ 91
 107+ 0000              BankGalaxyData1         equ 92
 108+ 0000              BankGalaxyData2         equ 93
 109+ 0000              BankGalaxyData3         equ 94
 110+ 0000              BankGalaxyData4         equ 95
 111+ 0000              BankGalaxyData5         equ 96
 112+ 0000              BankGalaxyData6         equ 97
 113+ 0000              BankGalaxyData7         equ 98
 114+ 0000
 115+ 0000              BankROM                 equ 255
 116+ 0000
# file closed: ../Hardware/memory_bank_defines.asm
  50  0000                                      INCLUDE "../Hardware/screen_equates.asm"
# file opened: ../Hardware/screen_equates.asm
   1+ 0000              ScreenHeight 		equ 192
   2+ 0000              ScreenLastRow       equ ScreenHeight -1
   3+ 0000              ScreenWidth  		equ 256
   4+ 0000              ScreenLastCol       equ ScreenWidth -1
   5+ 0000              ScreenHeightHalf	equ 96
   6+ 0000              ScreenWidthHalf  	equ 128
   7+ 0000              ScreenCenterY		equ 96
   8+ 0000              ScreenCenterX       equ 128
   9+ 0000              ViewHeight          equ 128
  10+ 0000              ViewHeightPlus1     equ 128+1
  11+ 0000              ViewLastRow       	equ ViewHeight -1
  12+ 0000              ViewWidth  			equ 256
  13+ 0000              ViewLastCol         equ ViewWidth -1
  14+ 0000              ViewHeightHalf      equ 63
  15+ 0000              ViewWidthHalf       equ 127
  16+ 0000              ViewCenterY         equ 64
  17+ 0000              ViewCenterX         equ 128
  18+ 0000              ShipColour			equ $FF		; place holder for debugging TODO
  19+ 0000              ScreenL1Bottom      equ $5000
  20+ 0000              ScreenL1BottomLen   equ 32 * 8 * 8
  21+ 0000              ScreenL1AttrBtm     equ $5A00
  22+ 0000              ScreenL1AttrBtmLen  equ 32 * 8
  23+ 0000
# file closed: ../Hardware/screen_equates.asm
  51  0000                                      INCLUDE "../Menus/clear_screen_inline_no_double_buffer.asm"
# file opened: ../Menus/clear_screen_inline_no_double_buffer.asm
   1+ 0000              InitNoDoubleBuffer:         MACRO
   2+ 0000 ~                                        MMUSelectLayer1
   3+ 0000 ~                                        call	l1_cls
   4+ 0000 ~                                        ld		a,7
   5+ 0000 ~                                        call	l1_attr_cls_to_a
   6+ 0000 ~                                        MMUSelectLayer2
   7+ 0000 ~                                        call    asm_l2_double_buffer_off
   8+ 0000 ~                                        call	l2_cls	; Get some space
   9+ 0000 ~                                        MMUSelectSpriteBank
  10+ 0000 ~                                        call    sprite_cls_cursors
  11+ 0000                                          ENDM
  12+ 0000
  13+ 0000
# file closed: ../Menus/clear_screen_inline_no_double_buffer.asm
  52  0000                                      INCLUDE "../Macros/graphicsMacros.asm"
# file opened: ../Macros/graphicsMacros.asm
   1+ 0000              ; General Graphics macros
   2+ 0000              DoubleBufferIfPossible: MACRO
   3+ 0000 ~                                    IFDEF DOUBLEBUFFER
   4+ 0000 ~                                        MMUSelectLayer2
   5+ 0000 ~                                        call  l2_cls
   6+ 0000 ~                                        call  l2_flip_buffers
   7+ 0000 ~                                    ENDIF
   8+ 0000                                      ENDM
# file closed: ../Macros/graphicsMacros.asm
  53  0000                                      INCLUDE "../Macros/callMacros.asm"
# file opened: ../Macros/callMacros.asm
   1+ 0000
   2+ 0000              CallIfAEqNusng:         MACRO   reg,target
   3+ 0000 ~                                    cp      reg
   4+ 0000 ~                                    call	z,target
   5+ 0000                                      ENDM
   6+ 0000
   7+ 0000              CallIfAGTENusng:        MACRO   reg,target
   8+ 0000 ~                                    cp      reg
   9+ 0000 ~                                    call	nc,target
  10+ 0000                                      ENDM
  11+ 0000
  12+ 0000              CallIfAGTEMemusng:      MACRO   reg,target
  13+ 0000 ~                                    ld      hl,reg
  14+ 0000 ~                                    cp      (hl)
  15+ 0000 ~                                    call	nc,target
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              CallIfALTNusng:         MACRO   reg,target
  19+ 0000 ~                                    cp      reg
  20+ 0000 ~                                    call	c,target
  21+ 0000                                      ENDM
  22+ 0000
  23+ 0000              CallIfMemEqMemusng:     MACRO mem, address, target
  24+ 0000 ~                                    ld   a,(mem)
  25+ 0000 ~                                    ld   hl,address
  26+ 0000 ~                                    cp   (hl)
  27+ 0000 ~                                    call    z,target
  28+ 0000                                      ENDM
  29+ 0000
  30+ 0000              CallIfMemEqNusng:       MACRO mem, value, target
  31+ 0000 ~                                    ld   a,(mem)
  32+ 0000 ~                                    cp   value
  33+ 0000 ~                                    call    z,target
  34+ 0000                                      ENDM
  35+ 0000
  36+ 0000              CallIfMemTrue:          MACRO mem, target
  37+ 0000 ~                                    ld      a,(mem)
  38+ 0000 ~                                    and     a
  39+ 0000 ~                                    call    z, target
  40+ 0000                                      ENDM
  41+ 0000
  42+ 0000              CallIfMemFalse:         MACRO mem, target
  43+ 0000 ~                                    ld      a,(mem)
  44+ 0000 ~                                    and     a
  45+ 0000 ~                                    call    nz, target
  46+ 0000                                      ENDM
  47+ 0000
  48+ 0000              CallIfATrue:            MACRO target
  49+ 0000 ~                                    and     a
  50+ 0000 ~                                    call    z, target
  51+ 0000                                      ENDM
  52+ 0000
  53+ 0000              CallIfAFalse:           MACRO target
  54+ 0000 ~                                    and     a
  55+ 0000 ~                                    call    nz, target
  56+ 0000                                      ENDM
# file closed: ../Macros/callMacros.asm
  54  0000                                      INCLUDE "../Macros/carryFlagMacros.asm"
# file opened: ../Macros/carryFlagMacros.asm
   1+ 0000
   2+ 0000              SetCarryFlag:           MACRO
   3+ 0000 ~                                    scf
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              ClearCarryFlag:	        MACRO
   7+ 0000 ~                                    or a
   8+ 0000                                      ENDM
   9+ 0000
  10+ 0000              FlipCarryFlag:          MACRO
  11+ 0000 ~                                    ccf
  12+ 0000                                      ENDM
  13+ 0000
# file closed: ../Macros/carryFlagMacros.asm
  55  0000                                      INCLUDE "../Macros/CopyByteMacros.asm"
# file opened: ../Macros/CopyByteMacros.asm
   1+ 0000              CopyByteAtHLixToA:		MACRO memloc
   2+ 0000 ~            						ex          de,hl                               ; save hl
   3+ 0000 ~            						ld          hl,memloc
   4+ 0000 ~            						add         hl,a
   5+ 0000 ~            						ld          a,(hl)                              ; get XX2[x]
   6+ 0000 ~            						ex          de,hl                               ; get hl back as we need it in loop
   7+ 0000              						ENDM
   8+ 0000
   9+ 0000              ; Increments IYL
  10+ 0000              ; Increments IHL
  11+ 0000              ; Gets value at hl and loads into Parameter 1 address
  12+ 0000
  13+ 0000              CopyByteAtNextHLiyl: 	MACRO memloc
  14+ 0000 ~            						inc         iyl                                 ;
  15+ 0000 ~            						inc         hl                                  ; vertex byte#1
  16+ 0000 ~            						ld          a,(hl)                              ;
  17+ 0000 ~            						ld          (memloc),a                     ; XX15+2 = (V),Y
  18+ 0000              						ENDM
  19+ 0000
  20+ 0000              ;------------------------------------------------------------------------------------------------------------------------------
  21+ 0000              CopyByteAtNextHL:   MACRO targetaddr
  22+ 0000 ~                                inc         hl                                  ; vertex byte#1
  23+ 0000 ~                                ld          a,(hl)                              ;
  24+ 0000 ~                                ld          (targetaddr),a                     ; SunXX15+2 = (V),Y
  25+ 0000                                  ENDM
# file closed: ../Macros/CopyByteMacros.asm
  56  0000                                      INCLUDE "../Macros/ldCopyMacros.asm"
# file opened: ../Macros/ldCopyMacros.asm
   1+ 0000              ZeroA:		            MACRO
   2+ 0000 ~                                    xor a
   3+ 0000                                      ENDM
   4+ 0000
   5+ 0000              SetATrue:               MACRO
   6+ 0000 ~                                    xor     a
   7+ 0000                                      ENDM
   8+ 0000
   9+ 0000              SetAFalse:              MACRO
  10+ 0000 ~                                    ld      a,$FF
  11+ 0000                                      ENDM
  12+ 0000
  13+ 0000              SetMemFalse             MACRO   mem
  14+ 0000 ~                                    ld      a,$FF
  15+ 0000 ~                                    ld      (mem),a
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              SetMemTrue              MACRO   mem
  19+ 0000 ~                                    xor     a
  20+ 0000 ~                                    ld      (mem),a
  21+ 0000                                      ENDM
  22+ 0000
  23+ 0000              SetMemToN:              MACRO   mem,value
  24+ 0000 ~                                    ld      a,value
  25+ 0000 ~                                    ld      (mem),a
  26+ 0000                                      ENDM
  27+ 0000
  28+ 0000              ldCopyStringLen:        MACRO   source, target, strlen
  29+ 0000 ~                                    ld      hl,source
  30+ 0000 ~                                    ld      de, target
  31+ 0000 ~                                    ld      bc, strlen
  32+ 0000 ~                                    ldir
  33+ 0000                                      ENDM
  34+ 0000
  35+ 0000              ldCopyTextAtHLtoDE:     MACRO
  36+ 0000 ~            .CopyLoop:              ld      a,(hl)
  37+ 0000 ~                                    ld      (de),a
  38+ 0000 ~                                    cp      0
  39+ 0000 ~                                    jp      z,.DoneCopy
  40+ 0000 ~                                    inc     hl
  41+ 0000 ~                                    inc     de
  42+ 0000 ~                                    jr      .CopyLoop
  43+ 0000 ~            .DoneCopy:
  44+ 0000                                      ENDM
  45+ 0000
  46+ 0000              ldClearTextLoop:        MACRO   TextSize
  47+ 0000 ~                                    ld      b,a
  48+ 0000 ~                                    ld      a,TextSize
  49+ 0000 ~            .ClearLoop:             ld      (hl),a
  50+ 0000 ~                                    inc     hl
  51+ 0000 ~                                    djnz    .ClearLoop
  52+ 0000                                      ENDM
  53+ 0000
  54+ 0000              ldCopyByte:             MACRO memfrom, memto
  55+ 0000 ~                                    ld       a,(memfrom)
  56+ 0000 ~                                    ld       (memto),a
  57+ 0000                                      ENDM
  58+ 0000
  59+ 0000
  60+ 0000              ldCopyByteABS:          MACRO memfrom, memto
  61+ 0000 ~                                    ld       a,(memfrom)
  62+ 0000 ~                                    and		$7F
  63+ 0000 ~                                    ld       (memto),a
  64+ 0000                                      ENDM
  65+ 0000
  66+ 0000              ldAtHLtoMem:            MACRO   memto
  67+ 0000 ~                                    ld      a,(hl)
  68+ 0000 ~                                    ld      (memto),a
  69+ 0000                                      ENDM
  70+ 0000
  71+ 0000              ldCopy2Byte             MACRO  memfrom, memto
  72+ 0000 ~                                    ld       hl,(memfrom)
  73+ 0000 ~                                    ld       (memto),hl
  74+ 0000                                      ENDM
  75+ 0000
  76+ 0000              ldWriteConst            MACRO  memfrom, memto
  77+ 0000 ~                                    ld       a,memfrom
  78+ 0000 ~                                    ld       (memto),a
  79+ 0000                                      ENDM
  80+ 0000
  81+ 0000              ldWriteZero             MACRO  memto
  82+ 0000 ~                                    xor      a
  83+ 0000 ~                                    ld       (memto),a
  84+ 0000                                      ENDM
  85+ 0000
  86+ 0000              ldIXLaFromN:	        MACRO memfrom
  87+ 0000 ~                                    ld		a,(memfrom)
  88+ 0000 ~                                    ld		ixl,a
  89+ 0000                                      ENDM
  90+ 0000
  91+ 0000              ldIXHaFromN:	        MACRO memfrom
  92+ 0000 ~                                    ld		a,(memfrom)
  93+ 0000 ~                                    ld		ixh,a
  94+ 0000                                      ENDM
  95+ 0000
  96+ 0000              ldIYLaFromN:	        MACRO memfrom
  97+ 0000 ~                                    ld		a,(memfrom)
  98+ 0000 ~                                    ld		iyl,a
  99+ 0000                                      ENDM
 100+ 0000
 101+ 0000              ldIYHaFromN:	        MACRO memfrom
 102+ 0000 ~                                    ld		a,(memfrom)
 103+ 0000 ~                                    ld		iyh,a
 104+ 0000                                      ENDM
 105+ 0000
 106+ 0000              ldhlde:			        MACRO
 107+ 0000 ~                                    ld		h,d
 108+ 0000 ~                                    ld		l,e
 109+ 0000                                      ENDM
 110+ 0000
 111+ 0000              ldhlbc:			        MACRO
 112+ 0000 ~                                    ld		h,b
 113+ 0000 ~                                    ld		l,c
 114+ 0000                                      ENDM
 115+ 0000
 116+ 0000              ldbcde:			        MACRO
 117+ 0000 ~                                    ld		b,d
 118+ 0000 ~                                    ld		c,e
 119+ 0000                                      ENDM
 120+ 0000
 121+ 0000              lddebc:			        MACRO
 122+ 0000 ~                                    ld		d,b
 123+ 0000 ~                                    ld		e,c
 124+ 0000                                      ENDM
 125+ 0000
 126+ 0000              ldbchl:			        MACRO
 127+ 0000 ~                                    ld		b,h
 128+ 0000 ~                                    ld		c,l
 129+ 0000                                      ENDM
 130+ 0000
 131+ 0000              lddeiy:			        MACRO
 132+ 0000 ~                                    ld		d,iyh
 133+ 0000 ~                                    ld		e,iyl
 134+ 0000                                      ENDM
 135+ 0000
 136+ 0000              ldiyde:			        MACRO
 137+ 0000 ~                                    ld		iyh,d
 138+ 0000 ~                                    ld		iyl,e
 139+ 0000                                      ENDM
 140+ 0000
 141+ 0000
 142+ 0000              FourLDIInstrunctions:   MACRO
 143+ 0000 ~                                    ldi
 144+ 0000 ~                                    ldi
 145+ 0000 ~                                    ldi
 146+ 0000 ~                                    ldi
 147+ 0000                                      ENDM
 148+ 0000
 149+ 0000              FiveLDIInstrunctions:   MACRO
 150+ 0000 ~                                    ldi
 151+ 0000 ~                                    ldi
 152+ 0000 ~                                    ldi
 153+ 0000 ~                                    ldi
 154+ 0000 ~                                    ldi
 155+ 0000                                      ENDM
 156+ 0000
 157+ 0000              SixLDIInstrunctions:    MACRO
 158+ 0000 ~                                    ldi
 159+ 0000 ~                                    ldi
 160+ 0000 ~                                    ldi
 161+ 0000 ~                                    ldi
 162+ 0000 ~                                    ldi
 163+ 0000 ~                                    ldi
 164+ 0000                                      ENDM
 165+ 0000
 166+ 0000              EightLDIInstrunctions:  MACRO
 167+ 0000 ~            		                ldi
 168+ 0000 ~            		                ldi
 169+ 0000 ~            		                ldi
 170+ 0000 ~            		                ldi
 171+ 0000 ~            		                ldi
 172+ 0000 ~            		                ldi
 173+ 0000 ~            		                ldi
 174+ 0000 ~            		                ldi
 175+ 0000                                      ENDM
 176+ 0000
 177+ 0000              NineLDIInstrunctions:  MACRO
 178+ 0000 ~            		                ldi
 179+ 0000 ~            		                ldi
 180+ 0000 ~            		                ldi
 181+ 0000 ~            		                ldi
 182+ 0000 ~            		                ldi
 183+ 0000 ~            		                ldi
 184+ 0000 ~            		                ldi
 185+ 0000 ~            		                ldi
 186+ 0000 ~            		                ldi
 187+ 0000                                      ENDM
# file closed: ../Macros/ldCopyMacros.asm
  57  0000                                      INCLUDE "../Macros/ldIndexedMacros.asm"
# file opened: ../Macros/ldIndexedMacros.asm
   1+ 0000              GetByteAInTable:    MACRO table
   2+ 0000 ~                                ld          hl,table
   3+ 0000 ~                                add         hl,a
   4+ 0000 ~                                ld          a,(hl)
   5+ 0000                                  ENDM
   6+ 0000
   7+ 0000              HLWordAInTable:     MACRO table
   8+ 0000 ~                                ld          hl,table
   9+ 0000 ~                                sla         a
  10+ 0000 ~                                add         hl,a
  11+ 0000 ~                                ld          a,(hl)
  12+ 0000 ~                                inc         hl
  13+ 0000 ~                                ld          h,(hl)
  14+ 0000 ~                                ld          l,a
  15+ 0000                                  ENDM
  16+ 0000
  17+ 0000
  18+ 0000              ldAToHLixl:			MACRO value
  19+ 0000 ~            					ld          hl,value
  20+ 0000 ~            					ex          af,af'
  21+ 0000 ~            					ld          a,ixl
  22+ 0000 ~            					add         hl,a
  23+ 0000 ~            					ex          af,af'
  24+ 0000 ~            					ld          (hl),a
  25+ 0000              					ENDM
  26+ 0000
  27+ 0000              ldAToHLiyl:			MACRO value
  28+ 0000 ~            					ld          hl,value
  29+ 0000 ~            					ex          af,af'
  30+ 0000 ~            					ld          a,iyl
  31+ 0000 ~            					add         hl,a
  32+ 0000 ~            					ex          af,af'
  33+ 0000 ~            					ld          (hl),a
  34+ 0000              					ENDM
  35+ 0000
  36+ 0000
  37+ 0000              ldHLixlToA:         MACRO value
  38+ 0000 ~                                ld          hl,value
  39+ 0000 ~                                ex          af,af'
  40+ 0000 ~                                ld          a,ixl
  41+ 0000 ~                                add         hl,a
  42+ 0000 ~                                ld          a,(hl)
  43+ 0000                                  ENDM
  44+ 0000
  45+ 0000              ldHLiylToA:         MACRO value
  46+ 0000 ~                                ld          hl,value
  47+ 0000 ~                                ex          af,af'
  48+ 0000 ~                                ld          a,iyl
  49+ 0000 ~                                add         hl,a
  50+ 0000 ~                                ld          a,(hl)
  51+ 0000                                  ENDM
  52+ 0000
  53+ 0000              ldHLIdxAToA:        MACRO value
  54+ 0000 ~                                ld          hl,value
  55+ 0000 ~                                add         hl,a
  56+ 0000 ~                                ld          a,(hl)
  57+ 0000                                  ENDM
  58+ 0000
  59+ 0000              HLEquAddrAtHLPlusA: MACRO
  60+ 0000 ~                                sla         a
  61+ 0000 ~                                add         hl,a
  62+ 0000 ~                                ld          a,(hl)
  63+ 0000 ~                                inc         hl
  64+ 0000 ~                                ld          h,(hl)
  65+ 0000 ~                                ld          l,a
  66+ 0000                                  ENDM
# file closed: ../Macros/ldIndexedMacros.asm
  58  0000                                      INCLUDE "../Macros/jumpMacros.asm"
# file opened: ../Macros/jumpMacros.asm
   1+ 0000              JumpIfPositive:	        MACRO target
   2+ 0000 ~                                    jp		p, target
   3+ 0000                                      ENDM
   4+ 0000
   5+ 0000              JumpIfNegative:	        MACRO target
   6+ 0000 ~                                    jp		m, target
   7+ 0000                                      ENDM
   8+ 0000
   9+ 0000
  10+ 0000              JumpIfUnderflow:	    MACRO target
  11+ 0000 ~                                    jp		po, target
  12+ 0000                                      ENDM
  13+ 0000
  14+ 0000              JumpIfOverflow:	        MACRO target
  15+ 0000 ~                                    jp		po, target
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000
  19+ 0000              JumpIfNotZero:	        MACRO target
  20+ 0000 ~                                    jp	nz,target
  21+ 0000                                      ENDM
  22+ 0000
  23+ 0000              JumpIfZero:	            MACRO target
  24+ 0000 ~                                    jp	z,target
  25+ 0000                                      ENDM
  26+ 0000
  27+ 0000              ;.. Bit routines
  28+ 0000              JumpOnLeadSignSet:      MACRO   reg, target
  29+ 0000 ~                                    ld      a,reg
  30+ 0000 ~                                    and     SignOnly8Bit
  31+ 0000 ~                                    jp      nz,target
  32+ 0000                                      ENDM
  33+ 0000
  34+ 0000              JumpOnLeadSignClear:    MACRO   reg, target
  35+ 0000 ~                                    ld      a,reg
  36+ 0000 ~                                    and     SignOnly8Bit
  37+ 0000 ~                                    jp      z,target
  38+ 0000                                      ENDM
  39+ 0000
  40+ 0000              JumpOnLeadSignSetA:     MACRO   target
  41+ 0000 ~                                    and     SignOnly8Bit
  42+ 0000 ~                                    jp      nz,target
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              JumpOnLeadSignClearA:   MACRO   target
  46+ 0000 ~                                    and     SignOnly8Bit
  47+ 0000 ~                                    jp      z,target
  48+ 0000                                      ENDM
  49+ 0000
  50+ 0000              JumpOnMemBitSet:        MACRO mem, bitnbr, target
  51+ 0000 ~                                    ld      a,(mem)
  52+ 0000 ~                                    bit 	bitnbr,a
  53+ 0000 ~                                    jp      nz,target
  54+ 0000                                      ENDM
  55+ 0000
  56+ 0000              JumpOnMemBitClear:      MACRO mem, bitnbr, target
  57+ 0000 ~                                    ld      a,(mem)
  58+ 0000 ~                                    bit 	bitnbr,a
  59+ 0000 ~                                    jp      z,target
  60+ 0000                                      ENDM
  61+ 0000
  62+ 0000              JumpOnABit5Set:         MACRO   target
  63+ 0000 ~                                    and     Bit5Only
  64+ 0000 ~                                    jp      nz,target
  65+ 0000                                      ENDM
  66+ 0000
  67+ 0000              JumpOnABit5Clear:       MACRO   target
  68+ 0000 ~                                    and     Bit5Only
  69+ 0000 ~                                    jp      z,target
  70+ 0000                                      ENDM
  71+ 0000
  72+ 0000              JumpOnBitMaskSet:       MACRO   bitmask, target
  73+ 0000 ~                                    and     bitmask
  74+ 0000 ~                                    jp      nz,target
  75+ 0000                                      ENDM
  76+ 0000
  77+ 0000              JumpOnBitMaskClear:     MACRO   bitmask, target
  78+ 0000 ~                                    and     bitmask
  79+ 0000 ~                                    jp      z,target
  80+ 0000                                      ENDM
  81+ 0000
  82+ 0000              JumpOnBitSet:           MACRO  reg, bitnbr, target
  83+ 0000 ~                                    bit 	bitnbr,reg
  84+ 0000 ~                                    jp      nz,target
  85+ 0000                                      ENDM
  86+ 0000
  87+ 0000              JumpOnBitClear:         MACRO  reg, bitnbr, target
  88+ 0000 ~                                    bit 	bitnbr,reg
  89+ 0000 ~                                    jp      z,target
  90+ 0000                                      ENDM
  91+ 0000
  92+ 0000              ; Comparison Routines
  93+ 0000              JumpIfAGTEusng:         MACRO
  94+ 0000 ~                                    jp		nc,target
  95+ 0000                                      ENDM
  96+ 0000
  97+ 0000              JumpIfAGTENusng:        MACRO reg,target
  98+ 0000 ~                                    cp     reg
  99+ 0000 ~                                    jp		nc,target
 100+ 0000                                      ENDM
 101+ 0000
 102+ 0000              JumpIfAGTEMemusng:      MACRO mem,target
 103+ 0000 ~                                    ld      hl,mem
 104+ 0000 ~                                    cp      (hl)
 105+ 0000 ~                                    jp		nc,target
 106+ 0000                                      ENDM
 107+ 0000
 108+ 0000              JumpIfALTMemusng:       MACRO mem,target
 109+ 0000 ~                                    ld      hl,mem
 110+ 0000 ~                                    cp      (hl)
 111+ 0000 ~                                    jp		c,target
 112+ 0000                                      ENDM
 113+ 0000
 114+ 0000              JumpIfMemGTENusng:      MACRO mem, value, target
 115+ 0000 ~                                    ld     a,(mem)
 116+ 0000 ~                                    cp     value
 117+ 0000 ~                                    jp	  nc,target
 118+ 0000                                      ENDM
 119+ 0000
 120+ 0000              JumpIfMemGTEMemusng:    MACRO mem, address, target
 121+ 0000 ~                                    ld   a,(mem)
 122+ 0000 ~                                    ld   hl,address
 123+ 0000 ~                                    cp   (hl)
 124+ 0000 ~                                    jp	  nc,target
 125+ 0000                                      ENDM
 126+ 0000
 127+ 0000              JumpIfMemEqMemusng:     MACRO mem, address, target
 128+ 0000 ~                                    ld   a,(mem)
 129+ 0000 ~                                    ld   hl,address
 130+ 0000 ~                                    cp   (hl)
 131+ 0000 ~                                    jp	  z,target
 132+ 0000                                      ENDM
 133+ 0000
 134+ 0000              JumpIfMemNeMemusng:     MACRO mem, address, target
 135+ 0000 ~                                    ld   a,(mem)
 136+ 0000 ~                                    ld   hl,address
 137+ 0000 ~                                    cp   (hl)
 138+ 0000 ~                                    jp	  nz,target
 139+ 0000                                      ENDM
 140+ 0000
 141+ 0000              JumpIfMemTrue:          MACRO mem, target
 142+ 0000 ~                                    ld      a,(mem)
 143+ 0000 ~                                    and     a
 144+ 0000 ~                                    jp      z, target
 145+ 0000                                      ENDM
 146+ 0000
 147+ 0000              JumpIfMemFalse:         MACRO mem, target
 148+ 0000 ~                                    ld      a,(mem)
 149+ 0000 ~                                    and     a
 150+ 0000 ~                                    jp      nz, target
 151+ 0000                                      ENDM
 152+ 0000
 153+ 0000              JumpIfATrue:            MACRO target
 154+ 0000 ~                                    and     a
 155+ 0000 ~                                    jp      z, target
 156+ 0000                                      ENDM
 157+ 0000
 158+ 0000              JumpIfAFalse:           MACRO target
 159+ 0000 ~                                    and     a
 160+ 0000 ~                                    jp      nz, target
 161+ 0000                                      ENDM
 162+ 0000
 163+ 0000              JumpIfALTusng:          MACRO target
 164+ 0000 ~                                    jp		c,target
 165+ 0000                                      ENDM
 166+ 0000
 167+ 0000              JumpIfALTNusng:         MACRO value, target
 168+ 0000 ~                                    cp      value
 169+ 0000 ~                                    jp		c, target
 170+ 0000                                      ENDM
 171+ 0000
 172+ 0000              JumpIfMemLTNusng:       MACRO mem, value, target
 173+ 0000 ~                                    ld      a,(mem)
 174+ 0000 ~                                    cp      value
 175+ 0000 ~                                    jp	  c,target
 176+ 0000                                      ENDM
 177+ 0000
 178+ 0000              JumpIfMemLTMemusng:     MACRO mem, value, target
 179+ 0000 ~                                    ld    a,(mem)
 180+ 0000 ~                                    ld    hl,value
 181+ 0000 ~                                    cp    (hl)
 182+ 0000 ~                                    jp	  c,target
 183+ 0000                                      ENDM
 184+ 0000
 185+ 0000              JumpIfMemEqNusng:       MACRO mem,value,target
 186+ 0000 ~                                    ld  a,(mem)
 187+ 0000 ~                                    cp  value
 188+ 0000 ~                                    jp  z,target
 189+ 0000                                      ENDM
 190+ 0000
 191+ 0000              JumpIfMemNeNusng:       MACRO mem,value,target
 192+ 0000 ~                                    ld  a,(mem)
 193+ 0000 ~                                    cp  value
 194+ 0000 ~                                    jp  nz,target
 195+ 0000                                      ENDM
 196+ 0000
 197+ 0000              JumpIfMemZero:          MACRO mem,target
 198+ 0000 ~                                    ld  a,(mem)
 199+ 0000 ~                                    and a
 200+ 0000 ~                                    jp  z,target
 201+ 0000                                      ENDM
 202+ 0000
 203+ 0000              JumpIfMemNotZero:       MACRO mem,target
 204+ 0000 ~                                    ld  a,(mem)
 205+ 0000 ~                                    and a
 206+ 0000 ~                                    jp  nz,target
 207+ 0000                                      ENDM
 208+ 0000
 209+ 0000              JumpIfALTMemHLusng:     MACRO target
 210+ 0000 ~                                    cp    (hl)
 211+ 0000 ~                                    jp	  c,target
 212+ 0000                                      ENDM
 213+ 0000
 214+ 0000              JumpIfANENusng:         MACRO value, target
 215+ 0000 ~                                    cp     value
 216+ 0000 ~                                    jp      nz,target
 217+ 0000                                      ENDM
 218+ 0000
 219+ 0000              JumpIfANEMemusng:       MACRO  value, target
 220+ 0000 ~                                    ld    hl,value
 221+ 0000 ~                                    cp    (hl)
 222+ 0000 ~                                    jp      nz,target
 223+ 0000                                      ENDM
 224+ 0000
 225+ 0000              JumpIfAEqNusng:         MACRO value, target
 226+ 0000 ~                                    cp     value
 227+ 0000 ~                                    jp      z,target
 228+ 0000                                      ENDM
 229+ 0000
 230+ 0000              JumpIfAIsZero:	        MACRO target
 231+ 0000 ~                                    and a   ; cp 0 - changed to and a for optimisation but affects other flags
 232+ 0000 ~                                    jp	z, target
 233+ 0000                                      ENDM
 234+ 0000
 235+ 0000              JumpIfAIsNotZero:       MACRO target
 236+ 0000 ~                                    cp	0
 237+ 0000 ~                                    jp	nz,target
 238+ 0000                                      ENDM
 239+ 0000
 240+ 0000              IfResultZeroGoto:	    MACRO target
 241+ 0000 ~                                    jp	z,target
 242+ 0000                                      ENDM
 243+ 0000
 244+ 0000              IfResultNotZeroGoto:    MACRO target
 245+ 0000 ~                                    jp	nz,target
 246+ 0000                                      ENDM
 247+ 0000
# file closed: ../Macros/jumpMacros.asm
  59  0000                                      INCLUDE "../Macros/MathsMacros.asm"
# file opened: ../Macros/MathsMacros.asm
   1+ 0000
   2+ 0000
   3+ 0000              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
   4+ 0000 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
   5+ 0000 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
   6+ 0000 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
   7+ 0000 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
   8+ 0000 ~                                    xor $80                             ;
   9+ 0000 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
  10+ 0000 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
  11+ 0000 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
  12+ 0000 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
  13+ 0000 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
  14+ 0000 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
  15+ 0000                                      ENDM
  16+ 0000
  17+ 0000              SignedHLTo2C:           MACRO
  18+ 0000 ~                                    bit     7,h
  19+ 0000 ~                                    jr      z,.Done2c
  20+ 0000 ~                                    ld      a,h
  21+ 0000 ~                                    and     SignMask8Bit
  22+ 0000 ~                                    ld      h,a
  23+ 0000 ~                                    NegHL
  24+ 0000 ~            .Done2c:
  25+ 0000                                      ENDM
  26+ 0000
  27+ 0000              MemSignedTo2C:          MACRO   memfrom
  28+ 0000 ~                                    ld      hl,(memfrom)
  29+ 0000 ~                                    bit     7,h
  30+ 0000 ~                                    jr      z,.Done2c
  31+ 0000 ~                                    ld      a,h
  32+ 0000 ~                                    and     SignMask8Bit
  33+ 0000 ~                                    ld      h,a
  34+ 0000 ~            .Done2c:                ld      (memfrom),hl
  35+ 0000                                      ENDM
  36+ 0000
  37+ 0000
  38+ 0000                  ;returns result in H
  39+ 0000              EDiv10Inline:           MACRO
  40+ 0000 ~                                    ld      d,0
  41+ 0000 ~                                    ld      hl,de
  42+ 0000 ~                                    add     hl,hl
  43+ 0000 ~                                    add     hl,de
  44+ 0000 ~                                    add     hl,hl
  45+ 0000 ~                                    add     hl,hl
  46+ 0000 ~                                    add     hl,de
  47+ 0000 ~                                    add     hl,hl
  48+ 0000                                      ENDM
  49+ 0000
# file closed: ../Macros/MathsMacros.asm
  60  0000                                      INCLUDE "../Macros/MMUMacros.asm"
# file opened: ../Macros/MMUMacros.asm
   1+ 0000              MMUSelectROMS:       MACRO
   2+ 0000 ~                                 nextreg EXSDOSMMU0,        BankROM
   3+ 0000 ~                                 nextreg EXSDOSMMU1,        BankROM
   4+ 0000                                   ENDM
   5+ 0000
   6+ 0000              MMUSelectSpriteBank: MACRO
   7+ 0000 ~            					 nextreg SpritememMMU,	    BankSPRITE
   8+ 0000              					 ENDM
   9+ 0000
  10+ 0000              MMUSelectConsoleBank: MACRO
  11+ 0000 ~            					 nextreg ConsoleImageDataMMU,  BankConsole
  12+ 0000              					 ENDM
  13+ 0000
  14+ 0000              MMUSelectLayer1: 	 MACRO
  15+ 0000 ~            					 nextreg L1memMMU,		    BankLAYER1
  16+ 0000              					 ENDM
  17+ 0000
  18+ 0000              MMUSelectLayer2: 	 MACRO
  19+ 0000 ~            					 nextreg L2memMMU,		    BankLAYER2
  20+ 0000              					 ENDM
  21+ 0000
  22+ 0000              MMUSelectResetUniv:  MACRO
  23+ 0000 ~                                 nextreg  ResetUniverseMMU, BankResetUniv
  24+ 0000                                   ENDM
  25+ 0000
  26+ 0000              MMUSelectShipBank1:  MACRO
  27+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels1
  28+ 0000              					 ENDM
  29+ 0000              MMUSelectShipBank2:  MACRO
  30+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels2
  31+ 0000              					 ENDM
  32+ 0000              MMUSelectShipBank3:  MACRO
  33+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels3
  34+ 0000              					 ENDM
  35+ 0000              MMUSelectShipBank4:  MACRO
  36+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels4
  37+ 0000              					 ENDM
  38+ 0000
  39+ 0000              MMUSelectShipBankA   MACRO
  40+ 0000 ~            					 nextreg ShipModelMMU,	    a
  41+ 0000              					 ENDM
  42+ 0000
  43+ 0000              MMUSelectShipBankN:  MACRO value
  44+ 0000 ~            					 nextreg ShipModelMMU,	    value
  45+ 0000              					 ENDM
  46+ 0000
  47+ 0000              MMUSelectCommander:	 MACRO
  48+ 0000 ~                                 nextreg CommanderMMU,       BankCommander
  49+ 0000              					 ENDM
  50+ 0000
  51+ 0000              MMUSelectStockTable: MACRO
  52+ 0000 ~                                 nextreg StockTableMMU,     BankStockTable
  53+ 0000              					 ENDM
  54+ 0000
  55+ 0000              MMUSelectCpySrcA:    MACRO
  56+ 0000 ~                                 nextreg DMACpySourceMMU,	a
  57+ 0000              					 ENDM
  58+ 0000
  59+ 0000              MMUSelectCpySrcN:    MACRO value
  60+ 0000 ~                                 nextreg DMACpySourceMMU,	value
  61+ 0000              					 ENDM
  62+ 0000
  63+ 0000              MMUSelectSun:        MACRO
  64+ 0000 ~                                 nextreg SunMMU,            BankSunData
  65+ 0000                                   ENDM
  66+ 0000
  67+ 0000              MMUSelectPlanet:     MACRO
  68+ 0000 ~                                 nextreg PlanetMMU,         PlanetBankAddr
  69+ 0000                                   ENDM
  70+ 0000
  71+ 0000              MMUSelectUniverseA:  MACRO
  72+ 0000 ~                                 add    a,BankUNIVDATA0
  73+ 0000 ~                                 nextreg UniverseMMU,       a
  74+ 0000                                   ENDM
  75+ 0000
  76+ 0000              MMUSelectUniverseN:  MACRO value
  77+ 0000 ~                                 nextreg UniverseMMU,       BankUNIVDATA0+value
  78+ 0000                                   ENDM
  79+ 0000
  80+ 0000              MMUSelectGalaxyA:    MACRO
  81+ 0000 ~                                 nextreg GalaxyDataMMU,       a
  82+ 0000                                   ENDM
  83+ 0000
  84+ 0000              MMUSelectGalaxyN:    MACRO value
  85+ 0000 ~                                 nextreg GalaxyDataMMU,     BankGalaxyData0+value
  86+ 0000                                   ENDM
  87+ 0000              MMUSelectGalaxyACopy:MACRO
  88+ 0000 ~                                 nextreg UniverseMMU,       a
  89+ 0000                                   ENDM
  90+ 0000
  91+ 0000              MMUSelectUniverseAbs:MACRO value
  92+ 0000 ~                                 nextreg UniverseMMU,       value
  93+ 0000                                   ENDM
  94+ 0000
  95+ 0000              MMUSelectMenuGalCht: MACRO
  96+ 0000 ~                                 nextreg MenuGalChtMMU,		BankMenuGalCht
  97+ 0000              					 ENDM
  98+ 0000
  99+ 0000              MMUSelectMenuShrCht: MACRO
 100+ 0000 ~            					 nextreg MenuShrChtMMU,		BankMenuShrCht
 101+ 0000              					 ENDM
 102+ 0000
 103+ 0000              MMUSelectMenuInvent: MACRO
 104+ 0000 ~                                 nextreg MenuInventMMU,		BankMenuInvent
 105+ 0000              					 ENDM
 106+ 0000
 107+ 0000              MMUSelectMenuSystem: MACRO
 108+ 0000 ~                                 nextreg MenuSystemMMU,		BankMenuSystem
 109+ 0000              					 ENDM
 110+ 0000
 111+ 0000              MMUSelectMenuMarket: MACRO
 112+ 0000 ~                                 nextreg MenuMarketMMU,		BankMenuMarket
 113+ 0000              					 ENDM
 114+ 0000
 115+ 0000              MMUSelectMenuStatus: MACRO
 116+ 0000 ~                                 nextreg MenuStatusMMU,		BankMenuStatus
 117+ 0000              					 ENDM
 118+ 0000
 119+ 0000              MMUSelectViewFront:  MACRO
 120+ 0000 ~                                 nextreg ScreenBankMMU,		BankFrontView
 121+ 0000              					 ENDM
 122+ 0000
 123+ 0000              MMUSelectScreenA:    MACRO
 124+ 0000 ~                                 nextreg ScreenBankMMU,		a
 125+ 0000              					 ENDM
 126+ 0000
# file closed: ../Macros/MMUMacros.asm
  61  0000                                      INCLUDE "../Macros/NegateMacros.asm"
# file opened: ../Macros/NegateMacros.asm
   1+ 0000
   2+ 0000              NegIY:			    MACRO
   3+ 0000 ~                                xor a
   4+ 0000 ~                                sub iyl
   5+ 0000 ~                                ld iyl,a
   6+ 0000 ~                                sbc a,a
   7+ 0000 ~                                sub iyh
   8+ 0000 ~                                ld iyh,a
   9+ 0000                                  ENDM
  10+ 0000
  11+ 0000              NegHL:			    MACRO
  12+ 0000 ~                                xor a
  13+ 0000 ~                                sub l
  14+ 0000 ~                                ld l,a
  15+ 0000 ~                                sbc a,a
  16+ 0000 ~                                sub h
  17+ 0000 ~                                ld h,a
  18+ 0000                                  ENDM
  19+ 0000
  20+ 0000              NegDE:			    MACRO
  21+ 0000 ~                                xor a
  22+ 0000 ~                                sub e
  23+ 0000 ~                                ld e,a
  24+ 0000 ~                                sbc a,a
  25+ 0000 ~                                sub d
  26+ 0000 ~                                ld d,a
  27+ 0000                                  ENDM
  28+ 0000
  29+ 0000              NegBC:			    MACRO
  30+ 0000 ~                                xor a
  31+ 0000 ~                                sub c
  32+ 0000 ~                                ld c,a
  33+ 0000 ~                                sbc a,a
  34+ 0000 ~                                sub  b
  35+ 0000 ~                                ld b,a
  36+ 0000                                  ENDM
  37+ 0000
  38+ 0000              NegH                MACRO
  39+ 0000 ~                                ld      a,h
  40+ 0000 ~                                neg
  41+ 0000 ~                                ld      h,a
  42+ 0000                                  ENDM
  43+ 0000
  44+ 0000              NegD                MACRO
  45+ 0000 ~                                ld      a,d
  46+ 0000 ~                                neg
  47+ 0000 ~                                ld      d,a
  48+ 0000                                  ENDM
  49+ 0000
  50+ 0000              NegB                MACRO
  51+ 0000 ~                                ld      a,b
  52+ 0000 ~                                neg
  53+ 0000 ~                                ld      b,a
  54+ 0000                                  ENDM
  55+ 0000
# file closed: ../Macros/NegateMacros.asm
  62  0000                                      INCLUDE "../Macros/returnMacros.asm"
# file opened: ../Macros/returnMacros.asm
   1+ 0000              ReturnOnBitSet:         MACRO  reg, bitnbr,
   2+ 0000 ~                                    bit 	bitnbr,reg
   3+ 0000 ~                                    ret     nz
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              ReturnOnMemBitSet:      MACRO mem, bitnbr
   7+ 0000 ~                                    ld   a,(mem)
   8+ 0000 ~                                    bit 	bitnbr,a
   9+ 0000 ~                                    ret     nz
  10+ 0000                                      ENDM
  11+ 0000
  12+ 0000              ReturnOnBitClear:       MACRO reg, bitnbr
  13+ 0000 ~                                    bit 	bitnbr,reg
  14+ 0000 ~                                    ret		z
  15+ 0000                                      ENDM
  16+ 0000
  17+ 0000              ReturnOnMemBitClear:    MACRO mem, bitnbr
  18+ 0000 ~                                    ld     a,(mem)
  19+ 0000 ~                                    bit 	bitnbr,a
  20+ 0000 ~                                    ret		z
  21+ 0000                                      ENDM
  22+ 0000
  23+ 0000              ReturnIfMemFalse:       MACRO   mem
  24+ 0000 ~                                    ld      a,(mem)
  25+ 0000 ~                                    and     a
  26+ 0000 ~                                    ret     nz
  27+ 0000                                      ENDM
  28+ 0000
  29+ 0000              ReturnIfMemTrue:        MACRO   mem
  30+ 0000 ~                                    ld      a,(mem)
  31+ 0000 ~                                    and     a
  32+ 0000 ~                                    ret     z
  33+ 0000                                      ENDM
  34+ 0000
  35+ 0000              ReturnIfAIsZero:        MACRO
  36+ 0000 ~                                    and     a
  37+ 0000 ~                                    ret     z
  38+ 0000                                      ENDM
  39+ 0000
  40+ 0000              ReturnIfMemisZero:      MACRO mem
  41+ 0000 ~                                    ld   a,(mem)
  42+ 0000 ~                                    and a
  43+ 0000 ~                                    ret    z
  44+ 0000                                      ENDM
  45+ 0000
  46+ 0000              ReturnIfBitMaskClear    MACRO   bitmask
  47+ 0000 ~                                    and     bitmask
  48+ 0000 ~                                    ret     z
  49+ 0000                                      ENDM
  50+ 0000
  51+ 0000              ReturnIfBitMaskSet      MACRO   bitmask
  52+ 0000 ~                                    and     bitmask
  53+ 0000 ~                                    ret     nz
  54+ 0000                                      ENDM
  55+ 0000
  56+ 0000              ReturnIfMemEquN:        MACRO mem, value
  57+ 0000 ~                                    ld     a,(mem)
  58+ 0000 ~                                    cp     value
  59+ 0000 ~                                    ret    nz
  60+ 0000                                      ENDM
  61+ 0000
  62+ 0000              ReturnIfMemNeNusng:     MACRO mem, value
  63+ 0000 ~                                    ld   a,(mem)
  64+ 0000 ~                                    cp     value
  65+ 0000 ~                                    ret    z
  66+ 0000                                      ENDM
  67+ 0000
  68+ 0000              ReturnIfRegNotZero:     MACRO reg
  69+ 0000 ~                                    ld      a, reg
  70+ 0000 ~                                    and     a
  71+ 0000 ~                                    ret     nz
  72+ 0000                                      ENDM
  73+ 0000
  74+ 0000              ReturnIfANotZero:       MACRO
  75+ 0000 ~                                    and     a
  76+ 0000 ~                                    ret     nz
  77+ 0000                                      ENDM
  78+ 0000
  79+ 0000              ReturnIfNotZero:        MACRO
  80+ 0000 ~                                    ret     nz
  81+ 0000                                      ENDM
  82+ 0000
  83+ 0000
  84+ 0000              ReturnIfNegative:       MACRO
  85+ 0000 ~                                    ret     m
  86+ 0000                                      ENDM
  87+ 0000
  88+ 0000
  89+ 0000              ReturnIfMemNotZero:     MACRO mem
  90+ 0000 ~                                    ld     a,(mem)
  91+ 0000 ~                                    and     a
  92+ 0000 ~                                    ret    nz
  93+ 0000                                      ENDM
  94+ 0000
  95+ 0000              ReturnIfAGTEusng:       MACRO value
  96+ 0000 ~                                    cp    value
  97+ 0000 ~                                    ret	 nc
  98+ 0000                                      ENDM
  99+ 0000
 100+ 0000              ReturnIfALTNusng:       MACRO value
 101+ 0000 ~                                    cp    value
 102+ 0000 ~                                    ret	 c
 103+ 0000                                      ENDM
 104+ 0000
 105+ 0000              ReturnIfAGTENusng:      MACRO value
 106+ 0000 ~                                    cp    value
 107+ 0000 ~                                    ret	 nc
 108+ 0000                                      ENDM
 109+ 0000
 110+ 0000              ReturnIfAGTEMemusng:    MACRO value
 111+ 0000 ~                                    ld      hl,value
 112+ 0000 ~                                    cp      (hl)
 113+ 0000 ~                                    ret	    nc
 114+ 0000                                      ENDM
 115+ 0000
 116+ 0000              ReturnIfANENusng:       MACRO value
 117+ 0000 ~                                    cp      value
 118+ 0000 ~                                    ret     nz
 119+ 0000                                      ENDM
 120+ 0000
 121+ 0000              ReturnIfAEqNusng:       MACRO value
 122+ 0000 ~                                    cp      value
 123+ 0000 ~                                    ret     z
 124+ 0000                                      ENDM
 125+ 0000
# file closed: ../Macros/returnMacros.asm
  63  0000                                      INCLUDE "../Macros/ShiftMacros.asm"
# file opened: ../Macros/ShiftMacros.asm
   1+ 0000              ShiftIYRight1: MACRO
   2+ 0000 ~            			   ld 	a,iyh
   3+ 0000 ~            			   srl 	a
   4+ 0000 ~            			   ld	iyh,a
   5+ 0000 ~            			   ld 	a,iyl
   6+ 0000 ~            			   rra
   7+ 0000 ~            			   ld	iyl,a
   8+ 0000              			   ENDM
   9+ 0000
  10+ 0000              ShiftHLRight1: MACRO
  11+ 0000 ~            			   srl h
  12+ 0000 ~            			   rr  l
  13+ 0000              			   ENDM
  14+ 0000
  15+ 0000              ShiftDERight1: MACRO
  16+ 0000 ~            			   srl d
  17+ 0000 ~            			   rr  e
  18+ 0000              			   ENDM
  19+ 0000
  20+ 0000              ShiftBCRight1: MACRO
  21+ 0000 ~            			   srl b
  22+ 0000 ~            			   rr  c
  23+ 0000              			   ENDM
  24+ 0000
  25+ 0000
  26+ 0000
  27+ 0000              ShiftHLDiv8:   MACRO
  28+ 0000 ~            			   srl h
  29+ 0000 ~            			   rr  l
  30+ 0000 ~            			   srl h
  31+ 0000 ~            			   rr  l
  32+ 0000 ~            			   srl h
  33+ 0000 ~            			   rr  l
  34+ 0000              			   ENDM
  35+ 0000
  36+ 0000              ShiftHLLeft1:  MACRO
  37+ 0000 ~            			   sla l
  38+ 0000 ~            			   rl  h
  39+ 0000              			   ENDM
  40+ 0000
  41+ 0000              ShiftDELeft1:  MACRO
  42+ 0000 ~            			   sla e
  43+ 0000 ~            			   rl  d
  44+ 0000              			   ENDM
  45+ 0000
  46+ 0000
  47+ 0000              RollDELeft1:   MACRO
  48+ 0000 ~                           rl  e
  49+ 0000 ~                           rl  d
  50+ 0000                             ENDM
  51+ 0000
  52+ 0000              ShiftBCLeft1:  MACRO
  53+ 0000 ~            			   sla c
  54+ 0000 ~            			   rl  b
  55+ 0000              			   ENDM
  56+ 0000
  57+ 0000
  58+ 0000              ShiftMem16Right1:   MACRO memaddr
  59+ 0000 ~                                ld    hl,(memaddr)
  60+ 0000 ~                                srl   h
  61+ 0000 ~                                rr    l
  62+ 0000 ~                                ld    (memaddr),hl
  63+ 0000                                  ENDM
  64+ 0000
  65+ 0000              ShiftMem8Right1:    MACRO memaddr
  66+ 0000 ~                                ld      a,(memaddr)
  67+ 0000 ~                                srl     a
  68+ 0000 ~                                ld      (memaddr),a
  69+ 0000                                  ENDM
  70+ 0000
  71+ 0000
  72+ 0000              ShiftMem8Left1A:    MACRO memaddr
  73+ 0000 ~                                ld      a,(memaddr)
  74+ 0000 ~                                sla     a
  75+ 0000 ~                                ld      (memaddr),a
  76+ 0000                                  ENDM
  77+ 0000
# file closed: ../Macros/ShiftMacros.asm
  64  0000                                      INCLUDE "../Macros/signBitMacros.asm"
# file opened: ../Macros/signBitMacros.asm
   1+ 0000              ClearSignBitMem:        MACRO mem
   2+ 0000 ~                                    ld      a,(mem)
   3+ 0000 ~                                    and     SignMask8Bit
   4+ 0000 ~                                    ld      (mem),a
   5+ 0000                                      ENDM
   6+ 0000
   7+ 0000              SetSignBitMem:          MACRO   mem
   8+ 0000 ~                                    ld      a,(mem)
   9+ 0000 ~                                    or      SignOnly8Bit
  10+ 0000 ~                                    ld      (mem),a
  11+ 0000                                      ENDM
  12+ 0000
  13+ 0000              FlipSignMem:            MACRO mem
  14+ 0000 ~                                    ld  a,(mem)
  15+ 0000 ~                                    xor SignOnly8Bit
  16+ 0000 ~                                    ld  (mem),a
  17+ 0000                                      ENDM
  18+ 0000
  19+ 0000              ClearSignBit:           MACRO reg
  20+ 0000 ~                                    ld      a,reg
  21+ 0000 ~                                    and     SignMask8Bit
  22+ 0000 ~                                    ld      reg,a
  23+ 0000                                      ENDM
  24+ 0000
  25+ 0000              SetSignBit:             MACRO   reg
  26+ 0000 ~                                    ld      a,reg
  27+ 0000 ~                                    or      SignOnly8Bit
  28+ 0000 ~                                    ld      reg,a
  29+ 0000                                      ENDM
  30+ 0000
  31+ 0000              FlipSignBit:            MACRO   reg
  32+ 0000 ~                                    ld      a,reg
  33+ 0000 ~                                    xor     SignOnly8Bit
  34+ 0000 ~                                    ld      reg,a
  35+ 0000                                      ENDM
  36+ 0000
  37+ 0000              ClearSignBitA:          MACRO
  38+ 0000 ~                                    and     SignMask8Bit
  39+ 0000                                      ENDM
  40+ 0000
  41+ 0000              SetSignBitA:            MACRO
  42+ 0000 ~                                    or      SignOnly8Bit
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              FlipSignBitA:           MACRO
  46+ 0000 ~                                    xor     SignOnly8Bit
  47+ 0000                                      ENDM
  48+ 0000
# file closed: ../Macros/signBitMacros.asm
  65  0000                                      INCLUDE "../Tables/message_queue_macros.asm"
# file opened: ../Tables/message_queue_macros.asm
   1+ 0000
   2+ 0000              AnyMessagesMacro:       MACRO   NoMessageTarget
   3+ 0000 ~                                    ld      a, (MessageCount)
   4+ 0000 ~                                    and     a
   5+ 0000 ~                                    jr      z, NoMessageTarget
   6+ 0000                                      ENDM
   7+ 0000
   8+ 0000              AnyHyperSpaceMacro:     MACRO   NoMessageText
   9+ 0000 ~                                    ld      hl,(InnerHyperCount)
  10+ 0000 ~                                    ld      a,h
  11+ 0000 ~                                    or      l
  12+ 0000 ~                                    jr      z, NoMessageText
  13+ 0000                                      ENDM
  14+ 0000
# file closed: ../Tables/message_queue_macros.asm
  66  0000                                      INCLUDE "../Variables/general_variables_macros.asm"
# file opened: ../Variables/general_variables_macros.asm
   1+ 0000              ; limited to 255 character length
   2+ 0000              CountLengthHL:          MACRO   Limiter
   3+ 0000 ~                                    ld      de,hl
   4+ 0000 ~                                    ld      bc,Limiter
   5+ 0000 ~                                    xor     a
   6+ 0000 ~                                    cpir
   7+ 0000 ~                                    ClearCarryFlag
   8+ 0000 ~                                    sbc     hl,de
   9+ 0000 ~                                    ld      a,l
  10+ 0000 ~                                    ret
  11+ 0000                                      ENDM
  12+ 0000
  13+ 0000              HalfLengthHL:           MACRO
  14+ 0000 ~                                    ld      b,0
  15+ 0000 ~            .CountLenLoop:          ld      a,(hl)
  16+ 0000 ~                                    cp      0
  17+ 0000 ~                                    jr      z,.DoneCount
  18+ 0000 ~                                    inc     b
  19+ 0000 ~                                    inc     hl
  20+ 0000 ~                                    jr      .CountLenLoop
  21+ 0000 ~            .DoneCount:             ld      a,32
  22+ 0000 ~                                    sub     b
  23+ 0000 ~                                    sra     a
  24+ 0000                                      ENDM
  25+ 0000
  26+ 0000              MakeInnocentMacro:		MACRO
  27+ 0000 ~            						xor		a
  28+ 0000 ~            						ld		(FugitiveInnocentStatus),a
  29+ 0000              						ENDM
  30+ 0000
  31+ 0000              NoEscapePodMacro:		MACRO
  32+ 0000 ~            						xor		a
  33+ 0000 ~            						ld		(EscapePod),a
  34+ 0000              						ENDM
  35+ 0000
  36+ 0000              MaxFuelLevel            EQU     70              ; 7.0 light years max
  37+ 0000              MaxFuelMacro:			MACRO
  38+ 0000 ~            						ld		a,MaxFuelLevel
  39+ 0000 ~            						ld		(Fuel),a
  40+ 0000              						ENDM
  41+ 0000
  42+ 0000              MaxThrottle:            MACRO
  43+ 0000 ~                                    ld      a,(SHIPMAXSPEED)
  44+ 0000 ~                                    ld      (DELTA),a
  45+ 0000 ~                                    ld      d,a
  46+ 0000 ~                                    ld      e,4
  47+ 0000 ~                                    mul
  48+ 0000 ~                                    ld      (DELT4Lo),de
  49+ 0000                                      ENDM
  50+ 0000
  51+ 0000              ZeroThrottle:           MACRO
  52+ 0000 ~                                    xor     a
  53+ 0000 ~                                    ld      (DELTA),a
  54+ 0000 ~                                    ld      (DELT4Lo),a
  55+ 0000 ~                                    ld      (DELT4Lo+1),a
  56+ 0000                                      ENDM
  57+ 0000
  58+ 0000              ZeroPitch:              MACRO
  59+ 0000 ~                                    xor     a
  60+ 0000 ~                                    ld      (BET2),a
  61+ 0000 ~                                    ld      (BET2FLIP),a
  62+ 0000 ~                                    ld      (JSTY),a
  63+ 0000 ~                                    ld      (BETA),a
  64+ 0000                                      ENDM
  65+ 0000
  66+ 0000              ZeroRoll:               MACRO
  67+ 0000 ~                                    xor     a                              ; zero roll and climb
  68+ 0000 ~                                    ld      (ALP2),a
  69+ 0000 ~                                    ld      (ALP2FLIP),a
  70+ 0000 ~                                    ld      (JSTX),a
  71+ 0000 ~                                    ld      (ALPHA),a
  72+ 0000                                      ENDM
  73+ 0000
  74+ 0000              CorrectPostJumpFuel:    MACRO
  75+ 0000 ~                                    ld      a,(Fuel)
  76+ 0000 ~                                    ld      hl,Distance
  77+ 0000 ~                                    sub     a,(hl)
  78+ 0000 ~                                    ld      (Fuel),a
  79+ 0000                                      ENDM
  80+ 0000
  81+ 0000              AnyMissilesLeft:        MACRO
  82+ 0000 ~                                    ld      a,(NbrMissiles)
  83+ 0000 ~                                    and     a
  84+ 0000                                      ENDM
  85+ 0000
  86+ 0000              SetMissileTargetA:      MACRO
  87+ 0000 ~                                    ld      (MissileTarget),a
  88+ 0000                                      ENDM
  89+ 0000
  90+ 0000              IsMissileLockedOn:      MACRO
  91+ 0000 ~                                    ld      a,(MissileTarget)
  92+ 0000 ~                                    cp      $FF
  93+ 0000 ~                                    ret     z
  94+ 0000 ~                                    ReturnIfSlotAEmpty                  ; if target slot is empty
  95+ 0000 ~                                    ret                                 ; will return as nz now
  96+ 0000                                      ENDM
  97+ 0000
  98+ 0000              ClearMissileTarget:     MACRO
  99+ 0000 ~                                    xor     a                           ; Set missile target to FF
 100+ 0000 ~                                    dec     a
 101+ 0000 ~                                    ld      (MissileTarget),a
 102+ 0000 ~                                    SetMemFalse MissileLaunchFlag
 103+ 0000                                      ENDM
 104+ 0000
 105+ 0000              ClearECM:               MACRO
 106+ 0000 ~                                    xor     a
 107+ 0000 ~                                    ld      (ECMLoopA),a
 108+ 0000 ~                                    ld      (ECMLoopB),a
 109+ 0000                                      ENDM
 110+ 0000
 111+ 0000              ChargeEnergyAndShields: MACRO
 112+ 0000 ~                                    ld      a,$FF
 113+ 0000 ~                                    ld      (PlayerEnergy),a
 114+ 0000 ~                                    ld      (ForeShield),a
 115+ 0000 ~                                    ld      (AftShield),a
 116+ 0000                                      ENDM
 117+ 0000
 118+ 0000              CopyPresentSystemToTarget: MACRO
 119+ 0000 ~                                    ld      hl,(PresentSystemX)
 120+ 0000 ~                                    ld      (TargetSystemX),hl
 121+ 0000                                      ENDM
 122+ 0000
 123+ 0000              CopyTargetSystemToPresent: MACRO
 124+ 0000 ~                                    ld      hl,(TargetSystemX)
 125+ 0000 ~                                    ld      (PresentSystemX),hl
 126+ 0000                                      ENDM
 127+ 0000
 128+ 0000              HalveFugitiveStatus:    MACRO
 129+ 0000 ~                                    ld      hl,FugitiveInnocentStatus
 130+ 0000 ~                                    srl     (hl)
 131+ 0000                                      ENDM
 132+ 0000
 133+ 0000              ClearForceTransition    MACRO
 134+ 0000 ~                                    ld      a,$FF
 135+ 0000 ~                                    ld      (ScreenTransitionForced),a
 136+ 0000                                      ENDM
 137+ 0000
 138+ 0000              ForceTransition:        MACRO newScreen
 139+ 0000 ~                                    ld      a,newScreen
 140+ 0000 ~                                    ld      (ScreenTransitionForced), a
 141+ 0000                                      ENDM
 142+ 0000
 143+ 0000              IsSpaceStationPresent:  MACRO
 144+ 0000 ~                                    ld      a,(SpaceStationSafeZone)
 145+ 0000 ~                                    and     a
 146+ 0000                                      ENDM
 147+ 0000
 148+ 0000              SetSafeZone:            MACRO
 149+ 0000 ~                                    xor     a
 150+ 0000 ~                                    ld      (SpaceStationSafeZone),a
 151+ 0000                                      ENDM
 152+ 0000
 153+ 0000              ClearSafeZone:          MACRO
 154+ 0000 ~                                    ld      a,$FF
 155+ 0000 ~                                    ld      (SpaceStationSafeZone),a
 156+ 0000                                      ENDM
 157+ 0000
 158+ 0000              ClearTemperatures:      MACRO
 159+ 0000 ~                                    xor     a
 160+ 0000 ~                                    ld      (CabinTemperature),a
 161+ 0000 ~                                    ld      (GunTemperature),a
 162+ 0000                                      ENDM
 163+ 0000
 164+ 0000              CoolCabin:              MACRO
 165+ 0000 ~                                    ld      a,(CabinTemperature)
 166+ 0000 ~                                    and     a
 167+ 0000 ~                                    jr      z,.AlreadyCool
 168+ 0000 ~                                    dec     a
 169+ 0000 ~                                    ld      (CabinTemperature),a
 170+ 0000 ~            .AlreadyCool:
 171+ 0000                                      ENDM
 172+ 0000
 173+ 0000              CoolLasers:             MACRO
 174+ 0000 ~                                    ld      a,(GunTemperature)
 175+ 0000 ~                                    and     a
 176+ 0000 ~                                    jr      z,.AlreadyCool
 177+ 0000 ~                                    dec     a
 178+ 0000 ~                                    ld      (GunTemperature),a
 179+ 0000 ~            .AlreadyCool:
 180+ 0000                                      ENDM
 181+ 0000
 182+ 0000              ; type 255 is "not fitted"
 183+ 0000
 184+ 0000
 185+ 0000              InitEventCounter:       MACRO
 186+ 0000 ~                                    xor     a
 187+ 0000 ~                                    ld      (EventCounter),a
 188+ 0000                                      ENDM
 189+ 0000
 190+ 0000              ClearMissJump:          MACRO
 191+ 0000 ~                                    ld      a,$FF
 192+ 0000 ~                                    ld      (MissJumpFlag),a
 193+ 0000                                      ENDM
 194+ 0000
 195+ 0000
 196+ 0000              DrainSystem:            MACRO   SystemMem, DrainMem
 197+ 0000 ~                                    ld      a,(DrainMem)
 198+ 0000 ~                                    ld      b,a
 199+ 0000 ~                                    ld      a,(SystemMem)
 200+ 0000 ~                                    sub     a,b
 201+ 0000 ~                                    ld      (SystemMem),a
 202+ 0000 ~                                    jr      c,.ZeroSystem
 203+ 0000 ~                                    jp      .ExitPoint
 204+ 0000 ~            .ZeroSystem:            ZeroA
 205+ 0000 ~                                    ld      (SystemMem),a
 206+ 0000 ~            .ExitPoint
 207+ 0000                                      ENDM
 208+ 0000
 209+ 0000              BoostSystem:            MACRO   SystemMem, BoostMem
 210+ 0000 ~                                    ld      a,(BoostMem)
 211+ 0000 ~                                    ld      b,a
 212+ 0000 ~                                    ld      a,(SystemMem)
 213+ 0000 ~                                    add     b
 214+ 0000 ~                                    ld      (SystemMem),a
 215+ 0000 ~                                    jr      c, .MaxSystem
 216+ 0000 ~                                    jp      .ExitPoint
 217+ 0000 ~            .MaxSystem:             ld      a,255
 218+ 0000 ~                                    ld      (SystemMem),a
 219+ 0000 ~            .ExitPoint
 220+ 0000                                      ENDM
 221+ 0000
# file closed: ../Variables/general_variables_macros.asm
  67  0000                                      INCLUDE "../Variables/UniverseSlot_macros.asm"
# file opened: ../Variables/UniverseSlot_macros.asm
   1+ 0000
   2+ 0000              AddJunkCount:           MACRO
   3+ 0000 ~                                    ld      hl,JunkCount
   4+ 0000 ~                                    inc     (hl)
   5+ 0000                                      ENDM
   6+ 0000
   7+ 0000              SubJunkCount:           MACRO
   8+ 0000 ~                                    ld      hl,JunkCount
   9+ 0000 ~                                    dec     (hl)
  10+ 0000                                      ENDM
  11+ 0000
  12+ 0000              AddCop:                 MACRO
  13+ 0000 ~                                    ld      hl,CopCount
  14+ 0000 ~                                    inc     (hl)
  15+ 0000                                      ENDM
  16+ 0000
  17+ 0000              SubCop:                 MACRO
  18+ 0000 ~                                    ld      hl,CopCount
  19+ 0000 ~                                    dec     (hl)
  20+ 0000                                      ENDM
  21+ 0000
  22+ 0000              AddPirateCount:         MACRO
  23+ 0000 ~                                    ld      hl,PirateCount
  24+ 0000 ~                                    inc     (hl)
  25+ 0000                                      ENDM
  26+ 0000
  27+ 0000              SubPirateCount:         MACRO
  28+ 0000 ~                                    ld      hl,PirateCount
  29+ 0000 ~                                    inc     (hl)
  30+ 0000                                      ENDM
  31+ 0000
  32+ 0000              AreCopsPresent:         MACRO
  33+ 0000 ~                                    ld      a,(CopCount)
  34+ 0000 ~                                    and     a
  35+ 0000                                      ENDM
  36+ 0000
  37+ 0000              TestRoomForJunk:        MACRO   Target
  38+ 0000 ~                                    ld      a,3
  39+ 0000 ~                                    JumpIfALTMemusng    JunkCount, Target
  40+ 0000                                      ENDM
  41+ 0000
  42+ 0000              JumpIfSpaceStation:     MACRO   Target
  43+ 0000 ~                                    ld      hl,UniverseSlotType
  44+ 0000 ~                                    ld      a,(hl)
  45+ 0000 ~                                    cp      ShipTypeStation
  46+ 0000                                      ENDM
  47+ 0000
  48+ 0000
  49+ 0000              ; Checks if slot is empty else A = ship type
  50+ 0000              ReturnIfSlotAEmpty:     MACRO
  51+ 0000 ~                                    ld      hl,UniverseSlotList
  52+ 0000 ~                                    add     hl,a
  53+ 0000 ~                                    ld      a,(hl)
  54+ 0000 ~                                    inc     a
  55+ 0000 ~                                    ret     z           ; if slot was ff inc would make it 0
  56+ 0000 ~                                    dec     a           ; get original value back for later
  57+ 0000                                      ENDM
  58+ 0000
  59+ 0000              JumpIfSlotAEmpty:       MACRO   Target
  60+ 0000 ~                                    ld      hl,UniverseSlotList
  61+ 0000 ~                                    add     hl,a
  62+ 0000 ~                                    ld      a,(hl)
  63+ 0000 ~                                    inc     a
  64+ 0000 ~                                    jp      z,Target    ; if slot was ff inc would make it 0
  65+ 0000 ~                                    dec     a           ; get original value back for later
  66+ 0000                                      ENDM
  67+ 0000
  68+ 0000              JumpIfSlotHLEmpty:      MACRO   Target
  69+ 0000 ~                                    ld      a,(hl)
  70+ 0000 ~                                    and     a
  71+ 0000 ~                                    jr      nz,Target
  72+ 0000                                      ENDM
# file closed: ../Variables/UniverseSlot_macros.asm
  68  0000
  69  0000
  70  0000              charactersetaddr		equ 15360
  71  0000              STEPDEBUG               equ 1
  72  0000
  73  0000              TopOfStack              equ $7F00
  74  0000
  75  0000              EliteNextStartup:       ORG         $8000
  76  8000 F3                                   di
  77  8001                                      ; "STARTUP"
  78  8001                                      ; Make sure  rom is in page 0 during load
  79  8001                                      MMUSelectLayer1
  79  8001 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
  80  8005 CD 80 E0                             call		l1_cls
  81  8008 3E 07                                ld			a,7
  82  800A CD 9B E0                             call		l1_attr_cls_to_a
  83  800D 3E FF                                ld          a,$FF
  84  800F CD A5 E0                             call        l1_set_border
  85  8012              Initialise:             MMUSelectLayer2
  85  8012 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
  86  8016 CD FA E0                             call 		l2_initialise
  87  8019 CD 09 E0                             call        asm_l2_double_buffer_off
  88  801C                                      ClearForceTransition
  88  801C 3E FF       >                        ld      a,$FF
general_variables_macros.asm(135): error: Label not found: ScreenTransitionForced
TestSunRender.asm(88): ^ emitted from here
  88  801E 32 00 00    >                        ld      (ScreenTransitionForced),a
  89  8021              SunLoop:                MMUSelectSun
  89  8021 ED 91 56 53 >                     nextreg SunMMU,            BankSunData
  90  8025 21 01 00                             ld          hl,$0001
  91  8028 22 10 C0                             ld          (SBnKxlo),hl
  92  802B 22 13 C0                             ld          (SBnKylo),hl
TestSunRender.asm(93): warning: value 0x160 is truncated to 8bit value: 0x60
  93  802E 26 60                                ld          h,$0160
  94  8030 22 16 C0                             ld          (SBnKzlo),hl
  95  8033                                      ZeroA
  95  8033 AF          >                        xor a
  96  8034 32 12 C0                             ld          (SBnKxsgn),a
  97  8037 32 15 C0                             ld          (SBnKysgn),a
  98  803A 32 18 C0                             ld          (SBnKzsgn),a
  99  803D CD F3 C5                             call        SunUpdateAndRender
 100  8040                                      MMUSelectLayer2
 100  8040 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 101  8044 C3 21 80                             jp          SunLoop
 102  8047
 103  8047                  INCLUDE "../Hardware/keyboard.asm"
# file opened: ../Hardware/keyboard.asm
   1+ 8047              ;
   2+ 8047              ; $FEFE;65278 V, C, X, Z, Caps Shifts       4  3  2  1  0
   3+ 8047              ; $FDFE;65022 G, F, D, S, A                 9  8  7  6  5
   4+ 8047              ; $FBFE;64510 T, R, E, W, Q                14 13 12 11 10
   5+ 8047              ; $F7FE;63486 5, 4, 3, 2, 1                19 18 17 16 15
   6+ 8047              ; $EFFE;61438 6, 7, 8, 9, 0                24 23 22 23 20
   7+ 8047              ; $DFFE;57342 Y, U, I, O, P                29 28 27 26 25
   8+ 8047              ; $BFFE;49150 H, J, K, L, Enter            34 33 32 31 30
   9+ 8047              ; $7FFE;32766 B, N, M, Symbol Shift, Space 39 38 37 36 35
  10+ 8047              ;
  11+ 8047              ; Keyboard
  12+ 8047              ;
  13+ 8047              ;   0      1       2       3       4       5        6       7       8       9
  14+ 8047              ;  VK_CAPS, VK_Z,  VK_X,   VK_C,   VK_V,   VK_A,    VK_S,   VK_D,   VK_F,   VK_G
  15+ 8047              ;   10     11      12      13      14      15       16      17      18      19
  16+ 8047              ;  VK_Q,   VK_W,   VK_E,   VK_R,   VK_T,   VK_1,    VK_2,   VK_3,   VK_4,   VK_5
  17+ 8047              ;   20     21      22      23      24      25       26      27      28      29
  18+ 8047              ;  VK_0    VK_9,   VK_8,   VK_7,   VK_6,   VK_P ,    VK_O,  VK_I,   VK_U,   VK_Y
  19+ 8047              ;   30     31      32      33      34      35       36      37      38      39
  20+ 8047              ; VK_ENTER VK_L,   VK_K,   VK_J,   VK_H,   VK_SPACE VK_SYM, VK_M,   VK_N,   VK_B
  21+ 8047              ;
  22+ 8047              ; Default map
  23+ 8047              ;-----------------------------------------------------------------------------------------------------------------------------------
  24+ 8047              ;   0          1           2             3              4           5           6           7           8           9
  25+ 8047              ;   VK_CAPS    VK_Z        VK_X,         VK_C,          VK_V,       VK_A        VK_S,       VK_D,       VK_F,       VK_G
  26+ 8047              ;              GameSkip                  Equip          SelLCargo   Climb       Decelerate  Recentre    FireM       HomeCursor
  27+ 8047              ;                                                                                                       Find System
  28+ 8047              ;-----------------------------------------------------------------------------------------------------------------------------------
  29+ 8047              ;   10         11          12            13             14          15          16          17          18          19
  30+ 8047              ;   VK_Q       VK_W,       VK_E,         VK_R,          VK_T,       VK_1        VK_2        VK_3        VK_4        VK_5
  31+ 8047              ;   Dive       Accelerate  ECM           UnarmMissile   TargetM     FrontV      AftV        LeftV       RightV      GalacticChart
  32+ 8047              ;-----------------------------------------------------------------------------------------------------------------------------------
  33+ 8047              ;   20         Accel       22            23             24          25          26          27          28          29
  34+ 8047              ;   VK_0       VK_9,       VK_8,         VK_7,          VK_6,       VK_P ,      VK_O,       VK_I,       VK_U,       VK_Y
  35+ 8047              ;   EscapePod  Inventory   Status        MarketPrices   LocalChart  RollRight   RolLLeft                EnergyBomb  Quit
  36+ 8047              ;   PlanetData                                                      PauseGame   SaveGame
  37+ 8047              ;-----------------------------------------------------------------------------------------------------------------------------------
  38+ 8047              ;   30         31          32            33             34          Right       36          37          EnergyBomb  39
  39+ 8047              ;   VK_ENTER   VK_L,       VK_K,         VK_J,          VK_H,       VK_SPACE    VK_SYM,     VK_M,       VK_N,       VK_B
  40+ 8047              ;              Launch                    Distance       Hyperspace  Laser                               DockComp    BuyCargo
  41+ 8047              ;              ResumeGame
  42+ 8047
  43+ 8047              ; You can read address to check keystate by address KeyboardMap + c_Pressed corresponding key. There is also an addr_ helper too
  44+ 8047
  45+ 8047              c_Pressed_Front         equ 0  * 2
  46+ 8047              c_Pressed_Aft           equ 1  * 2
  47+ 8047              c_Pressed_Left          equ 2  * 2
  48+ 8047              c_Pressed_Right         equ 3  * 2
  49+ 8047              c_Pressed_RollLeft      equ 4  * 2
  50+ 8047              c_Pressed_RollRight     equ 5  * 2
  51+ 8047              c_Pressed_Dive          equ 6  * 2
  52+ 8047              c_Pressed_Climb         equ 7  * 2
  53+ 8047              c_Pressed_Accellerate   equ 8  * 2
  54+ 8047              c_Pressed_Decellerate   equ 9  * 2
  55+ 8047              c_Pressed_FireLaser     equ 10 * 2
  56+ 8047              c_Pressed_TargetMissle  equ 11 * 2
  57+ 8047              c_Pressed_FireMissile   equ 12 * 2
  58+ 8047              c_Pressed_UnarmMissile  equ 13 * 2
  59+ 8047              c_Pressed_ECM           equ 14 * 2
  60+ 8047              c_Pressed_EnergyBomb    equ 15 * 2
  61+ 8047              c_Pressed_EscapePod     equ 16 * 2
  62+ 8047              c_Pressed_DockingComp   equ 17 * 2
  63+ 8047              c_Pressed_Hyperspace    equ 18 * 2
  64+ 8047              c_Pressed_Distance      equ 19 * 2
  65+ 8047              c_Pressed_HomeCursor    equ 20 * 2
  66+ 8047              c_Pressed_Launch        equ 21 * 2
  67+ 8047              c_Pressed_BuyCargo      equ 22 * 2
  68+ 8047              c_Pressed_SellCargo     equ 23 * 2
  69+ 8047              c_Pressed_Equip         equ 24 * 2
  70+ 8047              c_Pressed_GalacticChrt  equ 25 * 2
  71+ 8047              c_Pressed_LocalChart    equ 26 * 2
  72+ 8047              c_Pressed_MarketPrices  equ 27 * 2
  73+ 8047              c_Pressed_Status        equ 28 * 2
  74+ 8047              c_Pressed_Inventory     equ 29 * 2
  75+ 8047              c_Pressed_GameSkip      equ 30 * 2
  76+ 8047              c_Pressed_Save          equ 31 * 2
  77+ 8047              c_Pressed_Freeze        equ 32 * 2
  78+ 8047              c_Pressed_Resume        equ 33 * 2
  79+ 8047              c_Pressed_Recentre      equ 34 * 2
  80+ 8047              c_Pressed_Quit          equ 35 * 2
  81+ 8047              c_Pressed_PlanetData    equ 36 * 2
  82+ 8047              c_Pressed_CursorUp      equ 37 * 2
  83+ 8047              c_Pressed_CursorDown    equ 38 * 2
  84+ 8047              c_Pressed_Find          equ 39 * 2
  85+ 8047              c_Pressed_Yes           equ 40 * 2
  86+ 8047              c_Pressed_No            equ 41 * 2
  87+ 8047
  88+ 8047
  89+ 8047              ; half row 1
  90+ 8047              VK_CAPS  				equ 0
  91+ 8047              VK_Z  					equ 1
  92+ 8047              VK_X  					equ 2
  93+ 8047              VK_C  					equ 3
  94+ 8047              VK_V  					equ 4
  95+ 8047              ; half row 2
  96+ 8047              VK_A  					equ 5
  97+ 8047              VK_S  					equ 6
  98+ 8047              VK_D  					equ 7
  99+ 8047              VK_F  					equ 8
 100+ 8047              VK_G  					equ 9
 101+ 8047              ; half row 3
 102+ 8047              VK_Q  					equ 10
 103+ 8047              VK_W  					equ 11
 104+ 8047              VK_E  					equ 12
 105+ 8047              VK_R  					equ 13
 106+ 8047              VK_T  					equ 14
 107+ 8047              ; half row 4
 108+ 8047              VK_1  					equ 15
 109+ 8047              VK_2  					equ 16
 110+ 8047              VK_3  					equ 17
 111+ 8047              VK_4  					equ 18
 112+ 8047              VK_5  					equ 19
 113+ 8047              ; half row 5
 114+ 8047              VK_0 					equ 20
 115+ 8047              VK_9 					equ 21
 116+ 8047              VK_8 					equ 22
 117+ 8047              VK_7 					equ 23
 118+ 8047              VK_6 					equ 24
 119+ 8047              ; half row 6
 120+ 8047              VK_P  					equ 25
 121+ 8047              VK_O  					equ 26
 122+ 8047              VK_I  					equ 27
 123+ 8047              VK_U  					equ 28
 124+ 8047              VK_Y  					equ 29
 125+ 8047              ; half row 7
 126+ 8047              VK_ENTER 				equ 30
 127+ 8047              VK_L  					equ 31
 128+ 8047              VK_K  					equ 32
 129+ 8047              VK_J  					equ 33
 130+ 8047              VK_H  					equ 34
 131+ 8047              ; half row 8
 132+ 8047              VK_SPACE 				equ 35
 133+ 8047              VK_SYM  				equ 36
 134+ 8047              VK_M  					equ 37
 135+ 8047              VK_N  					equ 38
 136+ 8047              VK_B  					equ 39
 137+ 8047
 138+ 8047              ;KeyboardMapping
 139+ 8047              KeyCode_Front        	equ VK_1
 140+ 8047              KeyCode_Aft          	equ VK_2
 141+ 8047              KeyCode_Left         	equ VK_3
 142+ 8047              KeyCode_Right        	equ VK_4
 143+ 8047              KeyCode_RollLeft     	equ VK_O
 144+ 8047              KeyCode_RollRight    	equ VK_P
 145+ 8047              KeyCode_Dive         	equ VK_Q
 146+ 8047              KeyCode_Climb        	equ VK_A
 147+ 8047              KeyCode_Accellerate  	equ VK_W
 148+ 8047              KeyCode_Decellerate  	equ VK_S
 149+ 8047              KeyCode_FireLaser    	equ VK_SPACE
 150+ 8047              KeyCode_TargetMissle 	equ VK_T
 151+ 8047              KeyCode_FireMissile  	equ VK_F
 152+ 8047              KeyCode_Find        	equ VK_F
 153+ 8047              KeyCode_UnarmMissile 	equ VK_R
 154+ 8047              KeyCode_ECM          	equ VK_E
 155+ 8047              KeyCode_EnergyBomb   	equ VK_U
 156+ 8047              KeyCode_EscapePod    	equ VK_CAPS
 157+ 8047              KeyCode_DockingComp  	equ VK_N
 158+ 8047              KeyCode_Hyperspace   	equ VK_H
 159+ 8047              KeyCode_Distance     	equ VK_J
 160+ 8047              KeyCode_HomeCursor   	equ VK_G
 161+ 8047              KeyCode_Launch       	equ VK_L
 162+ 8047              KeyCode_BuyCargo     	equ VK_B
 163+ 8047              KeyCode_SellCargo    	equ VK_V
 164+ 8047              KeyCode_Equip        	equ VK_C
 165+ 8047              KeyCode_GalacticChrt 	equ VK_5
 166+ 8047              KeyCode_LocalChart   	equ VK_6
 167+ 8047              KeyCode_MarketPrices 	equ VK_7
 168+ 8047              KeyCode_Status       	equ VK_8
 169+ 8047              KeyCode_Inventory    	equ VK_9
 170+ 8047              KeyCode_GameSkip     	equ VK_Z
 171+ 8047              KeyCode_Save         	equ VK_O
 172+ 8047              KeyCode_Freeze       	equ VK_B
 173+ 8047              KeyCode_Resume       	equ VK_L
 174+ 8047              KeyCode_Recentre     	equ VK_D
 175+ 8047              KeyCode_Quit         	equ VK_Y
 176+ 8047              KeyCode_PlanetData   	equ VK_0
 177+ 8047              KeyCode_CursorUp        equ VK_Q
 178+ 8047              KeyCode_CursorDown      equ VK_A
 179+ 8047              KeyCode_PressedYes      equ VK_Y
 180+ 8047              KeyCode_PressedNo       equ VK_N
 181+ 8047
 182+ 8047 00 00 00...  Keys					DS	40          ; This is the list of key states for all the VK keys presssed i.e. VK_CAPS through to VK_B
 183+ 806F              c_KeyBoardLen 			equ $ - Keys
 184+ 806F 00 00 00...  RawKeys					DS	8
 185+ 8077 FE FD FB F7  KeyAddrTab				DB	$FE, $FD, $FB, $F7, $EF, $DF, $BF, $7F
 185+ 807B EF DF BF 7F
 186+ 807F              ; Now keyboard map lists each game key and the corresponding address in the Keys table to get the value. This way redefining keys is just a case
 187+ 807F              ; of updating this table with the respective location to look up
 188+ 807F              ; key list sequence is in table above
 189+ 807F 56 80 57 80  KeyboardMap             DW  Keys+KeyCode_Front        ,Keys+KeyCode_Aft          ,Keys+KeyCode_Left         ,Keys+KeyCode_Right        ,Keys+KeyCode_RollLeft
 189+ 8083 58 80 59 80
 189+ 8087 61 80
 190+ 8089 60 80 51 80                          DW  Keys+KeyCode_RollRight    ,Keys+KeyCode_Dive         ,Keys+KeyCode_Climb        ,Keys+KeyCode_Accellerate  ,Keys+KeyCode_Decellerate
 190+ 808D 4C 80 52 80
 190+ 8091 4D 80
 191+ 8093 6A 80 55 80                          DW  Keys+KeyCode_FireLaser    ,Keys+KeyCode_TargetMissle ,Keys+KeyCode_FireMissile  ,Keys+KeyCode_UnarmMissile ,Keys+KeyCode_ECM
 191+ 8097 4F 80 54 80
 191+ 809B 53 80
 192+ 809D 63 80 47 80                          DW  Keys+KeyCode_EnergyBomb   ,Keys+KeyCode_EscapePod    ,Keys+KeyCode_DockingComp  ,Keys+KeyCode_Hyperspace   ,Keys+KeyCode_Distance
 192+ 80A1 6D 80 69 80
 192+ 80A5 68 80
 193+ 80A7 50 80 66 80                          DW  Keys+KeyCode_HomeCursor   ,Keys+KeyCode_Launch       ,Keys+KeyCode_BuyCargo     ,Keys+KeyCode_SellCargo    ,Keys+KeyCode_Equip
 193+ 80AB 6E 80 4B 80
 193+ 80AF 4A 80
 194+ 80B1 5A 80 5F 80                          DW  Keys+KeyCode_GalacticChrt ,Keys+KeyCode_LocalChart   ,Keys+KeyCode_MarketPrices ,Keys+KeyCode_Status       ,Keys+KeyCode_Inventory
 194+ 80B5 5E 80 5D 80
 194+ 80B9 5C 80
 195+ 80BB 48 80 61 80                          DW  Keys+KeyCode_GameSkip     ,Keys+KeyCode_Save         ,Keys+KeyCode_Freeze       ,Keys+KeyCode_Resume       ,Keys+KeyCode_Recentre
 195+ 80BF 6E 80 66 80
 195+ 80C3 4E 80
 196+ 80C5 64 80 5B 80                          DW  Keys+KeyCode_Quit         ,Keys+KeyCode_PlanetData   ,Keys+KeyCode_CursorUp     ,Keys+KeyCode_CursorDown   ,Keys+KeyCode_Find
 196+ 80C9 51 80 4C 80
 196+ 80CD 4F 80
 197+ 80CF 64 80 6D 80                          DW  Keys+KeyCode_PressedYes   ,Keys+KeyCode_PressedNo
 198+ 80D3
 199+ 80D3 23 5A 58 43  ASCII_Map:              DB "#","Z","X","C","V"
 199+ 80D7 56
 200+ 80D8 41 53 44 46                          DB "A","S","D","F","G"
 200+ 80DC 47
 201+ 80DD 51 57 45 52                          DB "Q","W","E","R","T"
 201+ 80E1 54
 202+ 80E2 31 32 33 34                          DB "1","2","3","4","5"
 202+ 80E6 35
 203+ 80E7 30 39 38 37                          DB "0","9","8","7","6"
 203+ 80EB 36
 204+ 80EC 50 4F 49 55                          DB "P","O","I","U","Y"
 204+ 80F0 59
 205+ 80F1 3E 4C 4B 4A                          DB ">","L","K","J","H"
 205+ 80F5 48
 206+ 80F6 20 5E 4D 4E                          DB " ","^","M","N","B"
 206+ 80FA 42
 207+ 80FB
 208+ 80FB              ; mapping of a code to the lookup table Keyboard map. So if you are using an addr_Pressed you can then fetch from KeyboardMap the address in Keys
 209+ 80FB              ; for the raw key press status
 210+ 80FB              addr_Pressed_Front         equ KeyboardMap+c_Pressed_Front
 211+ 80FB              addr_Pressed_Aft           equ KeyboardMap+c_Pressed_Aft
 212+ 80FB              addr_Pressed_Left          equ KeyboardMap+c_Pressed_Left
 213+ 80FB              addr_Pressed_Right         equ KeyboardMap+c_Pressed_Right
 214+ 80FB              addr_Pressed_RollLeft      equ KeyboardMap+c_Pressed_RollLeft
 215+ 80FB              addr_Pressed_RollRight     equ KeyboardMap+c_Pressed_RollRight
 216+ 80FB              addr_Pressed_Dive          equ KeyboardMap+c_Pressed_Dive
 217+ 80FB              addr_Pressed_Climb         equ KeyboardMap+c_Pressed_Climb
 218+ 80FB              addr_Pressed_Accellerate   equ KeyboardMap+c_Pressed_Accellerate
 219+ 80FB              addr_Pressed_Decellerate   equ KeyboardMap+c_Pressed_Decellerate
 220+ 80FB              addr_Pressed_FireLaser     equ KeyboardMap+c_Pressed_FireLaser
 221+ 80FB              addr_Pressed_TargetMissle  equ KeyboardMap+c_Pressed_TargetMissle
 222+ 80FB              addr_Pressed_FireMissile   equ KeyboardMap+c_Pressed_FireMissile
 223+ 80FB              addr_Pressed_UnarmMissile  equ KeyboardMap+c_Pressed_UnarmMissile
 224+ 80FB              addr_Pressed_ECM           equ KeyboardMap+c_Pressed_ECM
 225+ 80FB              addr_Pressed_EnergyBomb    equ KeyboardMap+c_Pressed_EnergyBomb
 226+ 80FB              addr_Pressed_EscapePod     equ KeyboardMap+c_Pressed_EscapePod
 227+ 80FB              addr_Pressed_DockingComp   equ KeyboardMap+c_Pressed_DockingComp
 228+ 80FB              addr_Pressed_Hyperspace    equ KeyboardMap+c_Pressed_Hyperspace
 229+ 80FB              addr_Pressed_Distance      equ KeyboardMap+c_Pressed_Distance
 230+ 80FB              addr_Pressed_HomeCursor    equ KeyboardMap+c_Pressed_HomeCursor
 231+ 80FB              addr_Pressed_Launch        equ KeyboardMap+c_Pressed_Launch
 232+ 80FB              addr_Pressed_BuyCargo      equ KeyboardMap+c_Pressed_BuyCargo
 233+ 80FB              addr_Pressed_SellCargo     equ KeyboardMap+c_Pressed_SellCargo
 234+ 80FB              addr_Pressed_Equip         equ KeyboardMap+c_Pressed_Equip
 235+ 80FB              addr_Pressed_GalacticChrt  equ KeyboardMap+c_Pressed_GalacticChrt
 236+ 80FB              addr_Pressed_LocalChart    equ KeyboardMap+c_Pressed_LocalChart
 237+ 80FB              addr_Pressed_MarketPrices  equ KeyboardMap+c_Pressed_MarketPrices
 238+ 80FB              addr_Pressed_Status        equ KeyboardMap+c_Pressed_Status
 239+ 80FB              addr_Pressed_Inventory     equ KeyboardMap+c_Pressed_Inventory
 240+ 80FB              addr_Pressed_GameSkip      equ KeyboardMap+c_Pressed_GameSkip
 241+ 80FB              addr_Pressed_Save          equ KeyboardMap+c_Pressed_Save
 242+ 80FB              addr_Pressed_Freeze        equ KeyboardMap+c_Pressed_Freeze
 243+ 80FB              addr_Pressed_Resume        equ KeyboardMap+c_Pressed_Resume
 244+ 80FB              addr_Pressed_Recentre      equ KeyboardMap+c_Pressed_Recentre
 245+ 80FB              addr_Pressed_Quit          equ KeyboardMap+c_Pressed_Quit
 246+ 80FB              addr_Pressed_PlanetData    equ KeyboardMap+c_Pressed_PlanetData
 247+ 80FB              addr_Pressed_CursorUp      equ KeyboardMap+c_Pressed_CursorUp
 248+ 80FB              addr_Pressed_CursorDown    equ KeyboardMap+c_Pressed_CursorDown
 249+ 80FB              addr_Pressed_Find          equ KeyboardMap+c_Pressed_Find
 250+ 80FB
 251+ 80FB
 252+ 80FB              MIsKeyPressed:          MACRO   keyaddress, misstarget
 253+ 80FB ~                                    ld      hl,(keyaddress)
 254+ 80FB ~                                    ld      a,(hl)
 255+ 80FB ~                                    JumpIfAIsZero   misstarget
 256+ 80FB                                      ENDM
 257+ 80FB
 258+ 80FB 21 47 80     init_keyboard:          ld		hl,Keys                         ; no key s are pressed by default
 259+ 80FE 11 28 00                             ld		de, c_KeyBoardLen               ;
 260+ 8101 3E 00                                ld		a,0                             ;
keyboard.asm(261): error: Label not found: memfill_dma
 261+ 8103 CD 00 00                             call	memfill_dma                     ;
 262+ 8106 C9                                   ret                                     ;
 263+ 8107
 264+ 8107
 265+ 8107
 266+ 8107 DD 21 6F 80  scan_keyboard:          ld		ix,RawKeys                      ; hl = table of raw IO port readings
 267+ 810B 21 77 80                             ld		hl,KeyAddrTab                   ; de = table of IO ports to read
 268+ 810E 0E 08                                ld		c,8                             ; 8 ports to ready
 269+ 8110 11 47 80                             ld      de,Keys                         ; ix = table of key states from raw read
 270+ 8113 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
 271+ 8114 DB FE                                in		a,($FE)							; read port to a
 272+ 8116 DD 77 00                             ld      (ix+0),a                        ; save raw scan
 273+ 8119 DD 23                                inc     ix
 274+ 811B 23                                   inc		hl                              ; and ready for next read
 275+ 811C 06 05        .ProcessInputBits:      ld		b,5								; loop all bits (there are only 5 keys to a group)
 276+ 811E 1F           .ProcessBitsLoop:       rra                                     ; shit bit 0 into carry
 277+ 811F CB 47                                bit		0,a								; is bit set
 278+ 8121 30 08                                jr      nc,.SetKeyPressed               ; low bit means it was pressed
 279+ 8123 FD 6F                                ld      iyl,a
 280+ 8125                                      ZeroA
 280+ 8125 AF          >                        xor a
 281+ 8126 C3 33 81                             jp      .SetKey
 282+ 8129 20 0B                                jr		nz,.SkipKeySet
 283+ 812B FD 6F        .SetKeyPressed:	        ld      iyl,a                           ; save current input byte
 284+ 812D 1A                                   ld      a,(de)                          ; get current keystate
 285+ 812E FE 02                                cp      2
 286+ 8130 28 02                                jr      z,.AlreadyHeld
 287+ 8132 3C                                   inc     a                               ; and increment by 1 as its moved from previous state
 288+ 8133 12           .SetKey:                ld		(de),a				  	        ; save key Pressed state
 289+ 8134 FD 7D        .AlreadyHeld:           ld      a,iyl                           ; and retrieve the current input byte
 290+ 8136 13           .SkipKeySet:	        inc		de								; move to next key
 291+ 8137 10 E5                                djnz	.ProcessBitsLoop				; Process all key group bits
 292+ 8139 0D                                   dec     c                               ; thats one row of bits all processed
 293+ 813A 20 D7                                jr      nz,.PortReadLoop				; Read next input port
 294+ 813C C9                                   ret
 295+ 813D
 296+ 813D
 297+ 813D
 298+ 813D              GetKeyStateAddressDE:   MACRO
 299+ 813D ~                                    ld      hl,KeyboardMap                  ; work our address to read from
 300+ 813D ~                                    add     hl,a
 301+ 813D ~                                    ld      e,(hl)
 302+ 813D ~                                    inc     hl
 303+ 813D ~                                    ld      d,(hl)                          ; now de = address in keypress list
 304+ 813D                                      ENDM
 305+ 813D
 306+ 813D              GetKeyStateAddressHL:   MACRO
 307+ 813D ~                                    ld      hl,KeyboardMap                  ; work our address to read from
 308+ 813D ~                                    add     hl,a
 309+ 813D ~                                    ld      a,(hl)
 310+ 813D ~                                    inc     hl
 311+ 813D ~                                    ld      h,(hl)                          ; now hl = address in keypress list
 312+ 813D ~                                    ld      l,a
 313+ 813D                                      ENDM
 314+ 813D
 315+ 813D
 316+ 813D              ;;old debug codeCurrentX            DB 0
 317+ 813D              ;;old debug codeCurrentY            DB 0
 318+ 813D              ;;old debug code
 319+ 813D              ;;old debug codedisplayKeyStatus:       xor         a
 320+ 813D              ;;old debug code                        ld          (CurrentX),a
 321+ 813D              ;;old debug code                        ld          hl,RawKeys
 322+ 813D              ;;old debug code                        ld          a,(hl)
 323+ 813D              ;;old debug code                        and         %00011111
 324+ 813D              ;;old debug code                        ld          b,5
 325+ 813D              ;;old debug code.displayLoop:           push        bc,,hl
 326+ 813D              ;;old debug code                        rra
 327+ 813D              ;;old debug code                        jr          c,.displayNoPress
 328+ 813D              ;;old debug code.displayPress:          push        af
 329+ 813D              ;;old debug code                        ld          a,(CurrentX)
 330+ 813D              ;;old debug code                        ld          e,a
 331+ 813D              ;;old debug code                        ld          a,(CurrentY)
 332+ 813D              ;;old debug code                        ld          d,a
 333+ 813D              ;;old debug code                        ld          a,'*'
 334+ 813D              ;;old debug code                        MMUSelectLayer1
 335+ 813D              ;;old debug code                        call        l1_print_char
 336+ 813D              ;;old debug code                        ld          a,(CurrentX)
 337+ 813D              ;;old debug code                        add         a,8
 338+ 813D              ;;old debug code                        ld          (CurrentX),a
 339+ 813D              ;;old debug code                        pop         af
 340+ 813D              ;;old debug code                        pop         bc,,hl
 341+ 813D              ;;old debug code                        djnz        .displayLoop
 342+ 813D              ;;old debug code                        ret
 343+ 813D              ;;old debug code.displayNoPress:        push        af
 344+ 813D              ;;old debug code                        ld          a,(CurrentX)
 345+ 813D              ;;old debug code                        ld          e,a
 346+ 813D              ;;old debug code                        ld          a,(CurrentY)
 347+ 813D              ;;old debug code                        ld          d,a
 348+ 813D              ;;old debug code                        ld          a,'O'
 349+ 813D              ;;old debug code                        MMUSelectLayer1
 350+ 813D              ;;old debug code                        call        l1_print_char
 351+ 813D              ;;old debug code                        ld          a,(CurrentX)
 352+ 813D              ;;old debug code                        add         a,8
 353+ 813D              ;;old debug code                        ld          (CurrentX),a
 354+ 813D              ;;old debug code                        pop         af
 355+ 813D              ;;old debug code                        pop         bc,,hl
 356+ 813D              ;;old debug code                        djnz        .displayLoop
 357+ 813D              ;;old debug code                        ret
 358+ 813D              ;;old debug code
 359+ 813D              ;;old debug codedisplayDownStatus:      ld  a,(Keys+      KeyCode_CursorUp)
 360+ 813D              ;;old debug code                        cp  0
 361+ 813D              ;;old debug code                        jr      z,.displayNoUp
 362+ 813D              ;;old debug code                        cp  1
 363+ 813D              ;;old debug code                        jr      z,.displayUp
 364+ 813D              ;;old debug code.displayHeld:           ld      de,8*15
 365+ 813D              ;;old debug code                        ld      a,"*"
 366+ 813D              ;;old debug code                        MMUSelectLayer1
 367+ 813D              ;;old debug code                        call        l1_print_char
 368+ 813D              ;;old debug code                        ret
 369+ 813D              ;;old debug code.displayUp:             ld      de,8*15
 370+ 813D              ;;old debug code                        ld      a,"+"
 371+ 813D              ;;old debug code                        MMUSelectLayer1
 372+ 813D              ;;old debug code                        call        l1_print_char
 373+ 813D              ;;old debug code                        ret
 374+ 813D              ;;old debug code.displayNoUp:             ld      de,8*15
 375+ 813D              ;;old debug code                        ld      a,"O"
 376+ 813D              ;;old debug code                        MMUSelectLayer1
 377+ 813D              ;;old debug code                        call        l1_print_char
 378+ 813D              ;;old debug code                        ret
 379+ 813D              ;;old debug code
 380+ 813D
 381+ 813D
 382+ 813D              ; call with a = c_Pressed key, will then read mapping does this with keyboard scan, waits until key gets to state 1, if it was already held then#
 383+ 813D              ; it will have to be let go to reset of 0 and scan again
 384+ 813D              ; Deprecated as not used as yet
 385+ 813D              ;;;;;;wait_for_key_a_press:   GetKeyStateAddressHL
 386+ 813D              ;;;;;;                        push    hl
 387+ 813D              ;;;;;;.wait_loop:             call    scan_keyboard
 388+ 813D              ;;;;;;                        pop     hl                              ; get key address into hl
 389+ 813D              ;;;;;;                        push    hl
 390+ 813D              ;;;;;;                        ld      a,(hl)
 391+ 813D              ;;;;;;                        JumpIfANENusng  1,.wait_loop             ; will also loop if held down when entering this routine
 392+ 813D              ;;;;;;                        pop     hl                              ; tidy up rogue push, less t states than detecting if we want to push or not
 393+ 813D              ;;;;;;                        ret
 394+ 813D              ;;;;;;; call with a = c_Pressed key, will then read mapping does this with keyboard scan waits until key gets to state 2
 395+ 813D              ;;;;;;wait_for_key_a_held:    GetKeyStateAddressDE
 396+ 813D              ;;;;;;                        push    hl
 397+ 813D              ;;;;;;.wait_loop:             call    scan_keyboard
 398+ 813D              ;;;;;;                        pop     hl
 399+ 813D              ;;;;;;                        push    hl
 400+ 813D              ;;;;;;                        ld      a,(hl)
 401+ 813D              ;;;;;;                        JumpIfALTNusng  2, .wait_loop
 402+ 813D              ;;;;;;                        pop     hl
 403+ 813D              ;;;;;;                        ret
 404+ 813D
 405+ 813D              ; Gets the current keystate of the c_Pressed Key in a register
 406+ 813D              get_key_a_state:        GetKeyStateAddressHL                    ; reads a mapped key and sets a to key staus, e.g. 0 1 or >=2 DOES NOT SCAN KEYBOARD
 406+ 813D 21 7F 80    >                        ld      hl,KeyboardMap                  ; work our address to read from
 406+ 8140 ED 31       >                        add     hl,a
 406+ 8142 7E          >                        ld      a,(hl)
 406+ 8143 23          >                        inc     hl
 406+ 8144 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 406+ 8145 6F          >                        ld      l,a
 407+ 8146 7E                                   ld      a,(hl)                          ; a = keystate
 408+ 8147 C9                                   ret
 409+ 8148
 410+ 8148              ; sets they keystate of c pressed key in a register to 1 (pressed)
 411+ 8148              force_key_press:        GetKeyStateAddressHL                    ; read key locations
 411+ 8148 21 7F 80    >                        ld      hl,KeyboardMap                  ; work our address to read from
 411+ 814B ED 31       >                        add     hl,a
 411+ 814D 7E          >                        ld      a,(hl)
 411+ 814E 23          >                        inc     hl
 411+ 814F 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 411+ 8150 6F          >                        ld      l,a
 412+ 8151 3E 01                                ld      a,1
 413+ 8153 77                                   ld      (hl),a
 414+ 8154 C9                                   ret
 415+ 8155
 416+ 8155              is_key_up_state:        GetKeyStateAddressHL
 416+ 8155 21 7F 80    >                        ld      hl,KeyboardMap                  ; work our address to read from
 416+ 8158 ED 31       >                        add     hl,a
 416+ 815A 7E          >                        ld      a,(hl)
 416+ 815B 23          >                        inc     hl
 416+ 815C 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 416+ 815D 6F          >                        ld      l,a
 417+ 815E 7E                                   ld      a,(hl)
 418+ 815F FE 00                                cp      0
 419+ 8161 C9                                   ret
 420+ 8162
 421+ 8162              ; returns z is set if c_ key is pressed
 422+ 8162              is_key_pressed:         GetKeyStateAddressHL
 422+ 8162 21 7F 80    >                        ld      hl,KeyboardMap                  ; work our address to read from
 422+ 8165 ED 31       >                        add     hl,a
 422+ 8167 7E          >                        ld      a,(hl)
 422+ 8168 23          >                        inc     hl
 422+ 8169 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 422+ 816A 6F          >                        ld      l,a
 423+ 816B 7E                                   ld      a,(hl)                          ; a = keystate
 424+ 816C FE 01                                cp      1                               ; we cant just test bit 0 as this may have been held long
 425+ 816E C9                                   ret
 426+ 816F
 427+ 816F              ; returns nz is set if c_ key is held, if key was held then keystate would be 2 or 3, i.e. bit 1 set
 428+ 816F              is_key_held:            GetKeyStateAddressHL
 428+ 816F 21 7F 80    >                        ld      hl,KeyboardMap                  ; work our address to read from
 428+ 8172 ED 31       >                        add     hl,a
 428+ 8174 7E          >                        ld      a,(hl)
 428+ 8175 23          >                        inc     hl
 428+ 8176 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 428+ 8177 6F          >                        ld      l,a
 429+ 8178 7E                                   ld      a,(hl)                          ; a = keystate
 430+ 8179 E6 02                                and     Bit1Only                        ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
 431+ 817B C9                                   ret
 432+ 817C
 433+ 817C              ; checks to see if any key is pressed in the key table
 434+ 817C 21 47 80     is_any_key_pressed:     ld      hl,Keys
 435+ 817F 01 28 00                             ld      bc,40
 436+ 8182 3E 01                                ld      a,1
 437+ 8184 ED B1                                cpir                                    ; search for the value 1
 438+ 8186 28 03                                jr      z,.KeyPressed                   ; if a key was pressed then handle press
 439+ 8188                                      SetAFalse
 439+ 8188 3E FF       >                        ld      a,$FF
 440+ 818A C9                                   ret
 441+ 818B 3E 27        .KeyPressed:            ld      a,39                            ; so c will be how many keys still to scan
 442+ 818D 91                                   sub     c                               ; so a = 40 - c to get to result
 443+ 818E C9                                   ret
 444+ 818F
 445+ 818F 21 47 80     is_any_key_held:        ld      hl,Keys
 446+ 8192 06 28                                ld      b,40
 447+ 8194 0E 00                                ld      c,0
 448+ 8196 7E           .KeyReadLoop:           ld      a,(hl)
 449+ 8197 E6 02                                and     Bit1Only                        ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
 450+ 8199 C2 A3 81                             jp      nz,.KeyPressed
 451+ 819C 23                                   inc     hl
 452+ 819D 0C                                   inc     c
 453+ 819E 10 F6                                djnz    .KeyReadLoop
 454+ 81A0                                      SetAFalse
 454+ 81A0 3E FF       >                        ld      a,$FF
 455+ 81A2 C9                                   ret
 456+ 81A3 79           .KeyPressed:            ld      a,c
 457+ 81A4 C9                                   ret
 458+ 81A5
 459+ 81A5
 460+ 81A5 00 00 00...  InputString             DS  30              ; used for a 30 character input buffer
 461+ 81C3 00                                   DB  0               ; end of string marker as a safety
 462+ 81C4 00           InputCursor             DB  0
 463+ 81C5 00           EnterPressed            DB  0               ; zero notpressed FF pressed
 464+ 81C6 00           InputChanged            DB  0
 465+ 81C7              InputLimit              EQU 20
 466+ 81C7
 467+ 81C7 21 A5 81     keyboard_copy_input_to_de:  ld      hl,InputString
 468+ 81CA 3A C4 81                                 ld      a,(InputCursor)
 469+ 81CD FE 00                                    cp      0
 470+ 81CF 28 05                                    jr      z,.NoString
 471+ 81D1 4F                                       ld      c,a
 472+ 81D2 06 00                                    ld      b,0
 473+ 81D4 ED B0                                    ldir
 474+ 81D6 3E 00        .NoString                   ld      a,0
 475+ 81D8 12                                       ld      (de),a
 476+ 81D9 C9                                       ret
 477+ 81DA
 478+ 81DA AF           initInputText:          xor     a
 479+ 81DB 32 C4 81                             ld      (InputCursor),a
 480+ 81DE                                      SetMemFalse EnterPressed
 480+ 81DE 3E FF       >                        ld      a,$FF
 480+ 81E0 32 C5 81    >                        ld      (EnterPressed),a
 481+ 81E3                                      SetMemFalse InputChanged
 481+ 81E3 3E FF       >                        ld      a,$FF
 481+ 81E5 32 C6 81    >                        ld      (InputChanged),a
 482+ 81E8 21 A5 81                             ld      hl,InputString
 483+ 81EB 06 1E                                ld      b,30
 484+ 81ED 77           .wipeloop:              ld      (hl),a
 485+ 81EE 23                                   inc     hl
 486+ 81EF 10 FC                                djnz    .wipeloop
 487+ 81F1 C9                                   ret
 488+ 81F2
 489+ 81F2              InputName:              SetMemFalse InputChanged
 489+ 81F2 3E FF       >                        ld      a,$FF
 489+ 81F4 32 C6 81    >                        ld      (InputChanged),a
 490+ 81F7 CD 7C 81                             call    is_any_key_pressed
 491+ 81FA FE FF                                cp      $FF
 492+ 81FC C8                                   ret     z
 493+ 81FD 4F           .KeyPressed:            ld      c,a
 494+ 81FE 3A C4 81                             ld      a,(InputCursor)                 ; No key so we can now look at if we are at the end of the buffer
 495+ 8201 FE 14                                cp      InputLimit                      ; move to variable later and then cp (hl)
 496+ 8203 28 0B                                jr      z,.DeleteOrEnterOnly            ;
 497+ 8205 21 D3 80                             ld      hl,ASCII_Map
 498+ 8208 79                                   ld      a,c
 499+ 8209 ED 31                                add     hl,a
 500+ 820B 7E                                   ld      a,(hl)
 501+ 820C FE 41                                cp      "A"
 502+ 820E 30 0B                                jr      nc,.AlphaPressed
 503+ 8210              ; CAPS and Symbol act as delete for now
 504+ 8210 FE 20        .DeleteOrEnterOnly      cp      " "                             ; if space was  pressed (mapped to Hash in ASCII table))
 505+ 8212 28 33                                jr      z,.SpacePressed               ; for now we will ignore the shift and just assume delete
 506+ 8214 FE 3E                                cp      ">"         ; ENTER
 507+ 8216 28 19                                jr      z,.EnterPressed
 508+ 8218 FE 23                                cp      "#"         ; CAPS
 509+ 821A C9                                   ret
 510+ 821B 47           .AlphaPressed:          ld      b,a
 511+ 821C 3A C4 81                             ld      a,(InputCursor)
 512+ 821F 4F                                   ld      c,a
 513+ 8220 21 A5 81                             ld      hl,InputString
 514+ 8223 ED 31                                add     hl,a
 515+ 8225 78                                   ld      a,b
 516+ 8226 70                                   ld      (hl),b
 517+ 8227 79                                   ld      a,c
 518+ 8228 21 C4 81                             ld      hl,InputCursor
 519+ 822B 34                                   inc     (hl)
 520+ 822C                                      SetMemTrue InputChanged
 520+ 822C AF          >                        xor     a
 520+ 822D 32 C6 81    >                        ld      (InputChanged),a
 521+ 8230 C9                                   ret
 522+ 8231 3A C4 81     .EnterPressed:          ld      a,(InputCursor)
 523+ 8234 21 A5 81                             ld      hl,InputString
 524+ 8237 ED 31                                add     hl,a
 525+ 8239                                      ZeroA
 525+ 8239 AF          >                        xor a
 526+ 823A 77                                   ld      (hl),a
 527+ 823B                                      SetMemTrue EnterPressed
 527+ 823B AF          >                        xor     a
 527+ 823C 32 C5 81    >                        ld      (EnterPressed),a
 528+ 823F                                      SetMemTrue InputChanged
 528+ 823F AF          >                        xor     a
 528+ 8240 32 C6 81    >                        ld      (InputChanged),a
 529+ 8243 CD FB 80                             call    init_keyboard           ; Flush keyboard status so futher inputs don't auto read the enter key as a second press
 530+ 8246 C9                                   ret
 531+ 8247 3A C4 81     .SpacePressed:          ld      a,(InputCursor)         ; Space = delete
 532+ 824A FE 00                                cp      0                       ; if input is zero length then can not delete
 533+ 824C C8                                   ret     z
 534+ 824D 3D                                   dec     a                       ; move back one and update cursor pos
 535+ 824E 32 C4 81                             ld      (InputCursor),a         ;
 536+ 8251 21 A5 81                             ld      hl,InputString          ; now update end of line to null
 537+ 8254 ED 31                                add     hl,a                    ; .
 538+ 8256                                      ZeroA                           ; .
 538+ 8256 AF          >                        xor a
 539+ 8257 77                                   ld      (hl),a                  ; .
 540+ 8258                                      SetMemTrue InputChanged
 540+ 8258 AF          >                        xor     a
 540+ 8259 32 C6 81    >                        ld      (InputChanged),a
 541+ 825C C9                                   ret
 542+ 825D
 543+ 825D AF           MovementKeyTest:        xor     a
 544+ 825E 32 F9 84                             ld      (CursorKeysPressed),a
 545+ 8261 3A 18 84                             ld      a,(MenuIdMax)
 546+ 8264 E6 FC                                and     $FC
 547+ 8266 20 26                                jr      nz,CursorKeys
 548+ 8268 2A 8D 80     ClimbDiveKeys:          ld      hl,(addr_Pressed_Climb)
 549+ 826B 7E                                   ld      a,(hl)
 550+ 826C                                      JumpIfAIsZero ScanDiveKey
 550+ 826C A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 550+ 826D CA 7B 82    >                        jp	z, ScanDiveKey
 551+ 8270 3A F9 84                             ld      a,(CursorKeysPressed)
 552+ 8273 F6 80                                or      $80
 553+ 8275 32 F9 84                             ld      (CursorKeysPressed),a
 554+ 8278 C3 B1 82                             jp      ScanLeftKey
 555+ 827B 2A 8B 80     ScanDiveKey:            ld      hl,(addr_Pressed_Dive)
 556+ 827E 7E                                   ld      a,(hl)
 557+ 827F                                      JumpIfAIsZero ScanLeftKey
 557+ 827F A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 557+ 8280 CA B1 82    >                        jp	z, ScanLeftKey
 558+ 8283 3A F9 84                             ld      a,(CursorKeysPressed)
 559+ 8286 F6 40                                or      $40
 560+ 8288 32 F9 84                             ld      (CursorKeysPressed),a
 561+ 828B C3 B1 82                             jp      ScanLeftKey
 562+ 828E 2A C9 80     CursorKeys:             ld      hl,(addr_Pressed_CursorUp)
 563+ 8291 7E                                   ld      a,(hl)
 564+ 8292                                      JumpIfAIsZero ScanCursorDownKey
 564+ 8292 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 564+ 8293 CA A1 82    >                        jp	z, ScanCursorDownKey
 565+ 8296 3A F9 84                             ld      a,(CursorKeysPressed)
 566+ 8299 F6 80                                or      $80
 567+ 829B 32 F9 84                             ld      (CursorKeysPressed),a
 568+ 829E C3 B1 82                             jp      ScanLeftKey
 569+ 82A1 2A CB 80     ScanCursorDownKey:      ld      hl,(addr_Pressed_CursorDown)
 570+ 82A4 7E                                   ld      a,(hl)
 571+ 82A5                                      JumpIfAIsZero ScanLeftKey
 571+ 82A5 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 571+ 82A6 CA B1 82    >                        jp	z, ScanLeftKey
 572+ 82A9 3A F9 84                             ld      a,(CursorKeysPressed)
 573+ 82AC F6 40                                or      $40
 574+ 82AE 32 F9 84                             ld      (CursorKeysPressed),a
 575+ 82B1 2A 87 80     ScanLeftKey:            ld      hl,(addr_Pressed_RollLeft)
 576+ 82B4 7E                                   ld      a,(hl)
 577+ 82B5                                      JumpIfAIsZero ScanRightKey
 577+ 82B5 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 577+ 82B6 CA C2 82    >                        jp	z, ScanRightKey
 578+ 82B9 3A F9 84                             ld      a,(CursorKeysPressed)
 579+ 82BC F6 20                                or      $20
 580+ 82BE 32 F9 84                             ld      (CursorKeysPressed),a
 581+ 82C1 C9                                   ret
 582+ 82C2 2A 89 80     ScanRightKey:           ld      hl,(addr_Pressed_RollRight)
 583+ 82C5 7E                                   ld      a,(hl)
 584+ 82C6                                      JumpIfAIsZero ScanHomeKey
 584+ 82C6 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 584+ 82C7 CA D3 82    >                        jp	z, ScanHomeKey
 585+ 82CA 3A F9 84                             ld      a,(CursorKeysPressed)
 586+ 82CD F6 10                                or      $10
 587+ 82CF 32 F9 84                             ld      (CursorKeysPressed),a
 588+ 82D2 C9                                   ret
 589+ 82D3 2A A7 80     ScanHomeKey:            ld      hl,(addr_Pressed_HomeCursor)
 590+ 82D6 7E                                   ld      a,(hl)
 591+ 82D7                                      JumpIfAIsZero ScanRecentreKey
 591+ 82D7 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 591+ 82D8 CA E4 82    >                        jp	z, ScanRecentreKey
 592+ 82DB 3A F9 84                             ld      a,(CursorKeysPressed)
 593+ 82DE F6 08                                or      $08
 594+ 82E0 32 F9 84                             ld      (CursorKeysPressed),a
 595+ 82E3 C9                                   ret
 596+ 82E4 2A C3 80     ScanRecentreKey:        ld      hl,(addr_Pressed_Recentre)
 597+ 82E7 7E                                   ld      a,(hl)
 598+ 82E8                                      ReturnIfAIsZero
 598+ 82E8 A7          >                        and     a
 598+ 82E9 C8          >                        ret     z
 599+ 82EA 3A F9 84                             ld      a,(CursorKeysPressed)
 600+ 82ED F6 04                                or      $04
 601+ 82EF 32 F9 84                             ld      (CursorKeysPressed),a
 602+ 82F2 C9                                   ret
 603+ 82F3
 604+ 82F3
# file closed: ../Hardware/keyboard.asm
 104  82F3                  INCLUDE "../Variables/constant_equates.asm"
# file opened: ../Variables/constant_equates.asm
   1+ 82F3              ;Contants
   2+ 82F3
   3+ 82F3              SignMask8Bit		equ %01111111
   4+ 82F3              SignMask16Bit		equ %0111111111111111
   5+ 82F3              SignOnly8Bit		equ $80
   6+ 82F3              SignOnly16Bit		equ $8000
   7+ 82F3
   8+ 82F3              Bit7Only            equ %10000000
   9+ 82F3              Bit6Only            equ %01000000
  10+ 82F3              Bit5Only            equ %00100000
  11+ 82F3              Bit4Only            equ %00010000
  12+ 82F3              Bit3Only            equ %00001000
  13+ 82F3              Bit2Only            equ %00000100
  14+ 82F3              Bit1Only            equ %00000010
  15+ 82F3              Bit0Only            equ %00000001
  16+ 82F3              Bit7Clear           equ %01111111
  17+ 82F3              Bit6Clear           equ %10111111
  18+ 82F3              Bit5Clear           equ %11011111
  19+ 82F3              Bit4Clear           equ %11101111
  20+ 82F3              Bit3Clear           equ %11110111
  21+ 82F3              Bit2Clear           equ %11111011
  22+ 82F3              Bit1Clear           equ %11111101
  23+ 82F3              Bit0Clear           equ %11111110
  24+ 82F3              ConstPi				equ $80
  25+ 82F3              ConstNorm           equ 197
  26+ 82F3
  27+ 82F3              ;Text Tokens
  28+ 82F3              EliteToken			equ $1E			; Token ID for text messsage ---- E L I T E ----
  29+ 82F3              BrabenBellToken 	equ $0D
  30+ 82F3              AcorToken			equ $0C
  31+ 82F3
  32+ 82F3              ; Intro Screen
  33+ 82F3              TitleShip			equ	$8C
  34+ 82F3              RotationUnity		equ $60
  35+ 82F3              DBCheckCode			equ $DB
  36+ 82F3              MaxVisibility		equ $1F
  37+ 82F3              FarInFront			equ $C0
  38+ 82F3
  39+ 82F3              ; Universe Managment
  40+ 82F3              ShipTypeJunk        equ 3
  41+ 82F3              ShipTypeStation     equ 2
  42+ 82F3              ShipTypeMissile     equ 1
  43+ 82F3              ShipTypeNormal      equ 0
  44+ 82F3              ShipTypeText        equ 253
  45+ 82F3              ShipTypeDebug       equ 254
  46+ 82F3              ShipTypeEmpty       equ 255
  47+ 82F3              ; TacticsControl
  48+ 82F3              ShipIsTrader        equ Bit0Only   ; Trader flag  80% are peaceful 20% also have Bounty Hunter flag
  49+ 82F3              ShipIsBountyHunter  equ Bit1Only   ;
  50+ 82F3              ShipIsHostile       equ Bit2Only   ;
  51+ 82F3              ShipNotHostile      equ Bit2Clear   ;
  52+ 82F3              ShipIsPirate        equ Bit3Only   ;
  53+ 82F3              ShipIsDocking       equ Bit4Only   ;
  54+ 82F3              ShipIsBystander     equ Bit5Only   ;
  55+ 82F3              ShipIsCop           equ Bit6Only   ;
  56+ 82F3              ShipIsScoopDockEsc  equ Bit7Only   ;
  57+ 82F3              ShipAIEnabled       equ Bit7Only   ;
  58+ 82F3              ShipExploding       equ Bit5Only
  59+ 82F3              ShipKilled          equ Bit7Clear
  60+ 82F3
  61+ 82F3              ; UniverseAIControl
  62+ 82F3              ShipCanAnger        equ %00000001
  63+ 82F3
  64+ 82F3
  65+ 82F3              ShipMaxDistance     equ 192
  66+ 82F3              HyperSpaceTimers    equ $0B0B
  67+ 82F3
  68+ 82F3
  69+ 82F3              MaxNumberOfStars	equ 11
  70+ 82F3              ConsoleRefreshInterval  equ 4
  71+ 82F3
  72+ 82F3              ShipTypeSize		equ	32 			;??????? just a guess for now
  73+ 82F3              ShipSST				equ 4			; its a space station
  74+ 82F3              UniverseBasePage 	equ 70			; Base memory bank for universe Item #0
  75+ 82F3              ShipDataBasePage	equ	90			; Needs 2mb upgrade but what the heck
  76+ 82F3              ShipCountMax		equ	2			; For now just 2 ships to debug
  77+ 82F3              LineLimitPerShip	equ 70			; Max lines per ship
  78+ 82F3              FaceLimitPerShip	equ	70			; Same as line limit to simplify some logic
  79+ 82F3              ; "NEED TO DEFINE SHIPTYPESIZE TODO"
  80+ 82F3              PlayerDocked		equ	$FF
  81+ 82F3
  82+ 82F3              ; Memory page managment	(Refers to a memory slot as a place to access data)
  83+ 82F3              ShipDataSlot		equ	6			; this may move into rom swap out space later
  84+ 82F3              UniverseObjectSlot	equ	7
  85+ 82F3
  86+ 82F3              KeyForwardsView		equ	$20
  87+ 82F3              ; Game specific equates
  88+ 82F3              MissileDropHeight   equ 5           ; how far the missile is ejected on launch in y axis
  89+ 82F3
  90+ 82F3              ;...Game Colour Mapping
  91+ 82F3              L2DustColour        equ L2ColourGREY_1
  92+ 82F3              L2SunScannerBright  equ 252
  93+ 82F3              L2SunScanner        equ 180
  94+ 82F3
  95+ 82F3
  96+ 82F3              ; Ship Data
  97+ 82F3              ;;;;	.XX21	\ -> &5600 \ Table of pointers to ships' data given to XX0
  98+ 82F3              ;;;;00 7F			 EQUW &7F00 \ type  1 is #MSL  Missile data on page off bottom of screen
  99+ 82F3              ;;;;00 00			 EQUW 0     \ type  2 is #SST  Space Station, Coriolis or Dodo.
 100+ 82F3              ;;;;00 00			 EQUW 0     \ type  3 is #ESC  Escape capsule
 101+ 82F3              ;;;;00 00			 EQUW 0     \ type  4 is #PLT  Plate, alloys
 102+ 82F3              ;;;;00 00			 EQUW 0     \ type  5 is #OIL  Cargo cannister
 103+ 82F3              ;;;;00 00			 EQUW 0     \ type  6 is       Boulder
 104+ 82F3              ;;;;00 00			 EQUW 0     \ type  7 is #AST  Asteroid
 105+ 82F3              ;;;;00 00			 EQUW 0     \ type  8 is #SPL  Splinter, rock.
 106+ 82F3              ;;;;00 00			 EQUW 0     \ type  9 is #SHU  Shuttle
 107+ 82F3              ;;;;00 00			 EQUW 0     \ type 10 is       Transporter
 108+ 82F3              ;;;;00 00			 EQUW 0     \ type 11 is #CYL  Cobra Mk III,  Boa
 109+ 82F3              ;;;;00 00			 EQUW 0     \ type 12 is       Python
 110+ 82F3              ;;;;00 00			 EQUW 0     \ type 13 is       Last of three traders
 111+ 82F3              ;;;;00 00			 EQUW 0     \ type 14 is #ANA  Anaconda
 112+ 82F3              ;;;;00 00			 EQUW 0     \ type 15 is #WRM  Worm with Anaconda
 113+ 82F3              ;;;;00 00			 EQUW 0     \ type 16 is #COP  Viper
 114+ 82F3              ;;;;00 00			 EQUW 0     \ type 17 is       First pirate
 115+ 82F3              ;;;;00 00			 EQUW 0     \ type 18 is
 116+ 82F3              ;;;;00 00			 EQUW 0     \ type 19 is #KRA  Krait small pirate
 117+ 82F3              ;;;;00 00			 EQUW 0     \ type 20 is #ADA  Adder
 118+ 82F3              ;;;;00 00			 EQUW 0     \ type 21 is
 119+ 82F3              ;;;;00 00			 EQUW 0     \ type 22 is
 120+ 82F3              ;;;;00 00			 EQUW 0     \ type 23 is
 121+ 82F3              ;;;;00 00			 EQUW 0     \ type 24 is #CYL2 Last strong pirate
 122+ 82F3              ;;;;00 00			 EQUW 0     \ type 25 is #ASP  Asp Mk II
 123+ 82F3              ;;;;00 00			 EQUW 0     \ type 26 is #FER  Fer de Lance
 124+ 82F3              ;;;;00 00			 EQUW 0     \ type 27 is
 125+ 82F3              ;;;;00 00			 EQUW 0     \ type 28 is	Last of three bounty hunters
 126+ 82F3              ;;;;00 00			 EQUW 0     \ type 29 is #THG  Thargoid
 127+ 82F3              ;;;;00 00			 EQUW 0     \ type 30 is #TGL  Thargon
 128+ 82F3              ;;;;00 00			 EQUW 0     \ type 31 is #CON  Constrictor
 129+ 82F3              ;;;;	.E%	\ -> &563E \ Hull NEWB bits are escpod, cop, inno, ?, pirate, angry, hunter, trader.
 130+ 82F3              ;;;;			\ NEWB examples
 131+ 82F3              ;;;;\ 21			EQUB &21    \ 0010 0001    9 Shuttle has no escape pod, inno, trader.
 132+ 82F3              ;;;;\ 61			EQUB &61    \ 0110 0001   10 Tansporter no escape pod, Cop, inno, trader.
 133+ 82F3              ;;;;\ A0			EQUB &A0    \ 1010 0000   11 Cobra has Escape pod, inno, not a trader.
 134+ 82F3              ;;;;\ C2			EQUB &C2    \ 1100 0010   16 Viper has Escape pod, Cop, hunter.
 135+ 82F3              ;;;;\ 8C			EQUB &8C    \ 1000 1100   19 Krait pirate has escape pod, is pirate and angry.
 136+ 82F3
# file closed: ../Variables/constant_equates.asm
 105  82F3                  INCLUDE "../Variables/general_variables.asm"
# file opened: ../Variables/general_variables.asm
   1+ 82F3
   2+ 82F3
   3+ 82F3 00 00        varAxis1	DW 	0				; address of first axis in a rotation action
   4+ 82F5 00 00        varAxis2	DW	0				; address of 2nd axis in a roation action
   5+ 82F7              ; Variables to simulate 6502 registers until code fixed
   6+ 82F7              ; These must be here in this order as reading Y and X can then be a 16 bit read
   7+ 82F7 00           regX		DB	0               ; using 16 bit read into BC this would go into C
   8+ 82F8 00           regY		DB	0               ; using 16 bit read into BC this would go into B
   9+ 82F9 00           regA		DB	0
  10+ 82FA
  11+ 82FA
  12+ 82FA 00           varGPLoopA	DB	0				; General Purpose innermost loop variable
  13+ 82FB 00 00        INF			DW	0				; page 0 &20 Used to get address from UNIV array
  14+ 82FD 00 00        INF28		DW	0				; page 0 &20 Used to get address from UNIV array
  15+ 82FF
  16+ 82FF
  17+ 82FF
  18+ 82FF              ;XX16		DS	16				; 16 byte Matrix
  19+ 82FF
  20+ 82FF              P0INWK							; page 0 & 46
  21+ 82FF              p0INWK31						; page 0 & 65
  22+ 82FF              P0INWK36						; PAGE 0 &6A
  23+ 82FF
  24+ 82FF 00           XX4			DB	0				; XX4 page 0 &96 last Normal Found to be visible
  25+ 8300              LastNormalVisible	equ	XX4
  26+ 8300              varXX4              equ XX4
  27+ 8300
  28+ 8300
  29+ 8300
  30+ 8300 00           PATG		DB	0				; 6502 &03C9
  31+ 8301 00 00        SLSP 		DW	0				; &03B0 \ SLSP \ ship lines pointer
  32+ 8303
  33+ 8303
  34+ 8303              ;UNIV		DS FreeListSize*2	; Array of Universe Pointers
  35+ 8303              ;HULLINDEX	DS ShipTypeSize*2	; hull index for table at XX21= &5600 XX21-1,Y
  36+ 8303
  37+ 8303              ; Present System Variables
  38+ 8303
  39+ 8303 2B           RandomSeed				DB	43			; 00 DEBUG JUST SOME START VALUES
  40+ 8304 20           RandomSeed1				DB	32	; 01
  41+ 8305 0C           RandomSeed2				DB	12			; 02
  42+ 8306 42           RandomSeed3				DB	66			; 03
  43+ 8307
  44+ 8307 00           varT1					DB	0				; 06
  45+ 8308 00           SClo					DB 0				; 07
  46+ 8309 00           SChi					DB 0				; 08
  47+ 830A 00           varP					DB 0 				; 10	XX16+7
  48+ 830B 00           varPhi					DB 0 				; 11	XX16+8
  49+ 830C 00           varPhi2					DB 0 				; 12	XX16+9
  50+ 830D              varPp1                  equ varPhi
  51+ 830D              varPp2                  equ varPhi2
  52+ 830D 00           UnivPointerLo			DB	0				; 20		INF                 XX0+2
  53+ 830E 00           UnivPointerHi			DB	0				; 21      INF+1               XX0+3
  54+ 830F              UnivPointer				equ	UnivPointerLo
  55+ 830F 00           varV					DB 0				; 22                          XX0+4
  56+ 8310 00           varVHi					DB 0				; 23                          XX0+5
  57+ 8311 00           varXXlo                 DB 0                ; 24
  58+ 8312 00           varXXHi                 DB 0                ; 25
  59+ 8313              varXX					equ	varXXlo
  60+ 8313 00           YYlo                    DB 0                ; 26
  61+ 8314 00           YYHi                    DB 0                ; 27
  62+ 8315              varYY					equ	YYlo
  63+ 8315              											;	28
  64+ 8315              											;	29
  65+ 8315              ;PlayerShipPositionData - Must be contiguous for setup
  66+ 8315 00           BETA 					DB	0               ; 2A        (pitch done)
  67+ 8316 00           JSTY                    DB  0               ; Joystick analog
  68+ 8317 00           BET1 					DB	0               ; 2B        lower7 magnitude
  69+ 8318 00           BET2                    DB  0               ;            climb sign
  70+ 8319 00           BET2FLIP				DB	0				; 7C		BET 2 pitch Sign negated
  71+ 831A 1F           BET1MAXC                DB  31              ; max climb
  72+ 831B E1           BET1MAXD                DB  -31             ; max dive
  73+ 831C 00           XC						DB	0               ; 2C
  74+ 831D 00           YC						DB 	0               ; 2D
  75+ 831E              ;... ECM logic. If another ship adds ECM then we just set the loop A and B to starting values so they overlap
  76+ 831E 00           ECMActive				DB 	0				; 30		ECM Active flag
  77+ 831F 00           ECMLoopA                DB  0
  78+ 8320 00           ECMLoopB                DB  0
  79+ 8321 00 00        JSTX                    DW  0               ;           Joystick analog value
  80+ 8323 00           ALPHA					DB	0				; 8D        Alpha with bit 7 sign
  81+ 8324 00           ALP1					DB 	0				; 31		ALP1	Roll magnitude Also Apha
  82+ 8325 00           ALP2					DB  0				; 32		ALP2	Roll Sign
  83+ 8326 00           ALP2FLIP				DB  0				; 33		ALP2	negated roll sign
  84+ 8327 1F           ALP1MAXR                DB  31               ;   Maximum roll, added becuase we may allow different ship types
  85+ 8328 E1           ALP1MAXL                DB  -31             ;   Maximum roll, added becuase we may allow different ship types
  86+ 8329
  87+ 8329
  88+ 8329
  89+ 8329              MAXMESSAGES             EQU 5
  90+ 8329              MESSAGETIMELIMIT        EQU 20
  91+ 8329              MESSAGESIZE             EQU 33
  92+ 8329              MESSAGELINE             EQU $0001
  93+ 8329
  94+ 8329 00           MessageCount            DB  0                ; used for enquing messages later
  95+ 832A 00           MessageCurrent          DB  0
  96+ 832B 05 00        MessageIndex            DW  MAXMESSAGES
  97+ 832D 00 00 00...  MessageQueue            DS  MAXMESSAGES * MESSAGESIZE
  98+ 83D2 05           MessageTimeout          DB  MAXMESSAGES
  99+ 83D3 00 00 00...  IndexedWork				DS	37				; General purpose work space when doing temp arrays
 100+ 83F8
 101+ 83F8              ; MOVED TO Universe XX19					DB	0				; page 0 &67
 102+ 83F8              ; MOVED TO Universe XX20					DB	0				; page 0 &67 also used as XX19+1 for XX19 being a word
 103+ 83F8              ;DEFUNCT EQUATE NormalCountCopyBy4		equ	XX20			; Also used for normal * 4 holding variable
 104+ 83F8 00           XX21					DB  0				; this may be part of XX20/xx21 accordign to spawn new shipXX21		DW	0				; Ah XX21 is hull pointer  hull pointer lo as it can;t hold HULLINDX as 16bit array
 105+ 83F9              ;XX21 is the pointer table to the pages for ship types. this will be repalaced by paging so just need an equate for first page
 106+ 83F9
 107+ 83F9
 108+ 83F9 00 00 00...  SystemSeed				DS  5				;	6C		QQ15	Current Galaxy Seed
 109+ 83FE              											;	6D		QQ15+1
 110+ 83FE              											;	6E		QQ15+2
 111+ 83FE              											;	6F		QQ15+3
 112+ 83FE              											;	70		QQ15+4
 113+ 83FE              											;	71		QQ15+5
 114+ 83FE 00           QQ17					DB	0				;   72
 115+ 83FF 00           XX18xlo                 DB  0               ;	72		XX18   xlo
 116+ 8400 00           XX18xhi                 DB  0               ;	73		XX18+1 xhi
 117+ 8401 00           XX18xsg                 DB  0               ;	74		XX18+2 xsgn
 118+ 8402 00           XX18ylo                 DB  0               ;	75		XX18   ylo
 119+ 8403 00           XX18yhi                 DB  0               ;	76		XX18+1 yhi
 120+ 8404 00           XX18ysg                 DB  0               ;	77		XX18+2 ysgn
 121+ 8405 00           XX18zlo                 DB  0               ;	78		XX18   zlo
 122+ 8406 00           XX18zhi                 DB  0               ;	79		XX18+1 zhi
 123+ 8407 00           XX18zsg                 DB  0               ;	7A		XX18+2 zsgn
 124+ 8408
 125+ 8408 28           SHIPMAXSPEED            DB  40              ; variable to facilitate ship editing later
 126+ 8409 00           DELTA					DB 	0				; 7D 		DELTA  \ bpl -2 inserted here to stall from title code if byte check fails
 127+ 840A 00           DELT4Lo					DB 	0				; 7E
 128+ 840B 00           DELT4Hi					DB 	0				; 7F
 129+ 840C              DELTA4                  equ                 DELT4Lo
 130+ 840C
 131+ 840C
 132+ 840C              ; Not thise must be in this order else 16 bit fetches will fail
 133+ 840C 00           varU                    DB  0               ;   80
 134+ 840D 00           varQ					DB  0 				;	81
 135+ 840E 00           varR					DB  0 				;	82
 136+ 840F 00           varS					DB  0 				;	83
 137+ 8410              varRS                   equ varR
 138+ 8410
 139+ 8410 00 00        varU16                  DW  0               ; 16 bit variant on varU as I can't use above for this
 140+ 8412
 141+ 8412 00           XSAV					DB	0				; 84	   XSAV usef for nearby ship count outer
 142+ 8413 00           YSAV                    DB  0               ; 85
 143+ 8414 00           XX17					DB	0				; 86
 144+ 8415              RequiredScale			equ  XX17			; use to hold calculated scale in drawing ship
 145+ 8415              varXX17                 equ  XX17
 146+ 8415 00           ScreenChanged           DB  0
 147+ 8416 00           ScreenIndex             DB  0
 148+ 8417 00           InvertedYAxis           DB  0
 149+ 8418 00           MenuIdMax				DB	0				;	87		MenuIdMax		QQ11
 150+ 8419              											; Bit 7 Set  ShortRangeChart    $80
 151+ 8419              											; Bit 6 Set  Galactic Chart     $40
 152+ 8419              											; Bit 5 Set  Market Place       $20
 153+ 8419              											; Bit 4 Set  Status Screen      $10
 154+ 8419              											; Bit 3 Set  Display Inventory  $08
 155+ 8419                                                          ; Bit 2 Set  Planet Data        $04
 156+ 8419                                                          ; View bit combinations if the ones above not matched
 157+ 8419                                                          ; bits 1 0
 158+ 8419                                                          ;      1 1  Front view , i.e. $03
 159+ 8419                                                          ;      1 0  Aft View          $02
 160+ 8419                                                          ;      0 1  Left View         $01
 161+ 8419                                                          ;      0 0  Right view        $00
 162+ 8419              											; Bit 0 Set  Data On System
 163+ 8419              											; 0  Space View (Not a menu)
 164+ 8419 00           ZZDust					DB	0				;	88		ZZDust (Poss 16 bit need to check)
 165+ 841A 00           XX13                    DB  0               ;   89
 166+ 841B 00           TYPE					DB	0				; 8C used for ship type in drawing
 167+ 841C              ;Docked flag = 00 = in free space
 168+ 841C              ;              FF = Docked
 169+ 841C              ;              FE = transition
 170+ 841C              ;              FD = Setup open space and transition to not docked
 171+ 841C              ;              FC = Hyperspace manimation
 172+ 841C              ;              FB = Hyperspace complete
 173+ 841C 00           DockedFlag				DB	0				; 8E -
 174+ 841D 00           GamePaused              DB  0
 175+ 841E 00           varSWAP                 DB  0               ; 90 , general purpose swap variable
 176+ 841F 00           varCNT                  DB  0               ; 93
 177+ 8420
 178+ 8420 00           varK					DB	0				; 40
 179+ 8421 00           varKp1					DB	0				; 41
 180+ 8422 00           varKp2					DB	0				; 42
 181+ 8423 00           varKp3					DB	0				; 43
 182+ 8424
 183+ 8424 00           varK2                   DB  0               ; 9B
 184+ 8425 00           varK2p1                 DB  0               ; 9C K2 plus 1
 185+ 8426 00           varK2p2                 DB  0               ; 9D K2 plus 2
 186+ 8427 00           varK2p3                 DB  0               ; 9E K2 plus 3
 187+ 8428
 188+ 8428 00           Point                   DB  0               ; 9F      POINT
 189+ 8429
 190+ 8429 00           varT					DB	0				; D1
 191+ 842A
 192+ 842A 00 00 00...  varVector9ByteWork      DS  9
 193+ 8433
 194+ 8433 00 00 00 00  varK3					DS	4				; D2
 195+ 8437 00           varK3p2					DB	0				; 42
 196+ 8438 00           varK3p3					DB	0				; 43
 197+ 8439              varK3p1					equ varK3+1			; D3
 198+ 8439 00 00 00 00  varK4					DS	4				; E0
 199+ 843D              varK4p1					equ varK4+1			; D3
 200+ 843D
 201+ 843D
 202+ 843D              ;Heap
 203+ 843D
 204+ 843D 00 00        HeapStart				DS	2				; &0100 XX3 50 bytes for now
 205+ 843F 00 00 00...  HeapData				DS	50
 206+ 8471              ; Contains 				X 16 bit, Y ;MissileArmedStatus		DB	0				; 0344 MSAR   using MissileTarget, if missile is not armed tehn target is FF
 207+ 8471              ; TODO will need an read for a list of missiles, who they are targeting an the target current vector for AI persuit
 208+ 8471              ; i.e. a list of programmed missiles in universe slot list code
 209+ 8471 00 00 00...  DampingKeys				DS  7				; 0387 - 038D
 210+ 8478              ;  #&6 Does K toggle keyboard/joystick control -  03CD certainly makes keyboard not work anymore.
 211+ 8478              ;  #&5 Does J reverse both joystick channels
 212+ 8478              ;  #&4 Does Y reverse joystick Y channel			03CB
 213+ 8478              ;  #&2 Does X toggle startup message display ? PATG?	03C9
 214+ 8478              ;  #&3 Does F toggle flashing information			03CA
 215+ 8478              ;  #&1 Does A toggle keyboard auto-recentering ?
 216+ 8478              ;  #&0 Caps-lock toggles keyboard flight damping
 217+ 8478 00           NbrMissiles				DB	0				; 038B	Does this clash with Dampingkeys?
 218+ 8479 00           FugitiveInnocentStatus	DB	0				; 038C	FIST
 219+ 847A 00 00 00...  StockAvaliabiliy		DS 	16				; 038D - 039C Stock inventory in station
 220+ 848A 00           AlienItemsAvaliability  DB	0				; 039D
 221+ 848B 00           RandomMarketSeed		DB	0				; 039E   \ QQ26	\ random byte for each system vist (for market)
 222+ 848C 00 00        KillTally  				DW	0				; 039F - 03A0 \ TALLY   \ kills lo hi
 223+ 848E 00           COMP     				DB	0				; 03A1 2nd competion byte used for save integrity checks?
 224+ 848F              											;
 225+ 848F 00           MCH						DB	0				; 03A4  \ MCH  \ old message to erase
 226+ 8490 00           MarketPrice				DB	0				; 03AA QQ24
 227+ 8491 00           MaxStockAvaliable		DB  0				; 03AB   \ QQ25     \ max available
 228+ 8492 00           SystemEconomy			DB  0				; 03AC \ QQ28   \ the economy byte of present system (0 is Rich Ind.)
 229+ 8493 00           CargoItem				DB	0				; 03AD (I think its item type just scooped) QQ29
 230+ 8494 00 00        ShipLineStackPointer	DW	0				; 03B0 & 03B1 ship Lines pointer reset to top LS% = &0CFF (make DW for z80 and direct hl pointer)
 231+ 8496              											; this is ship lines stack pointer so may be redundant with paging
 232+ 8496              											; LS = line stack so we will have one for now to remove later
 233+ 8496 00           COK						DB	0				; 0366 Competition Byte what ? Does some file check and accelleration check
 234+ 8497 00           DisplayEcononmy			DB	0				; 03B8
 235+ 8498 00           DisplayGovernment		DB  0				; 03B9 Is it target? 03B9 \ QQ4	 \ Government, 0 is Anarchy.
 236+ 8499 00           DisplayTekLevel			DB	0				; 03BA   \ QQ5	\ Tech
 237+ 849A 00 00        DisplayPopulation		DW	0				; 03BB \ QQ6  \ population*10
 238+ 849C 00 00        DisplayProductivity		DW	0				; 03BD \ QQ7   \ productivity*10
 239+ 849E 00 00        Distance          		DW	0				; 03BE \ QQ8 distince in 0.1LY units
 240+ 84A0 00 00        DisplayRadius			DW	0
 241+ 84A2              ; --- Used in creation of sun and planet----;
 242+ 84A2 00           PlanetXPos              DS  1
 243+ 84A3 00           PlanetYPos              DS  1
 244+ 84A4 00           PlanetZPos              DS  1
 245+ 84A5 00           PlanetType              DS  1
 246+ 84A6 00           SunXPos                 DS  1
 247+ 84A7 00           SunYPos                 DS  1
 248+ 84A8 00           SunZPos                 DS  1
 249+ 84A9              ; -- Current Missile Runbtime data
 250+ 84A9 00           CurrentMissileBank:     DB      0                                   ; used by missile logic as local copy of missile bank number
 251+ 84AA 00 00        MissileXPos             DW      0
 252+ 84AC 00           MissileXSgn             DB      0
 253+ 84AD 00 00        MissileYPos             DW      0
 254+ 84AF 00           MissileYSgn             DB      0
 255+ 84B0 00 00        MissileZPos             DW      0
 256+ 84B2 00           MissileZSgn             DB      0
 257+ 84B3 00 00        CurrentTargetXpos       DS      2
 258+ 84B5 00 00        CurrentTargetXsgn       DS      2
 259+ 84B7 00 00        CurrentTargetYpos       DS      2
 260+ 84B9 00 00        CurrentTargetYsgn       DS      2
 261+ 84BB 00 00        CurrentTargetZpos       DS      2
 262+ 84BD 00 00        CurrentTargetZsgn       DS      2
 263+ 84BF 00 00        TargetVectorXpos        DS      2
 264+ 84C1 00 00        TargetVectorXsgn        DS      2
 265+ 84C3 00 00        TargetVectorYpos        DS      2
 266+ 84C5 00 00        TargetVectorYsgn        DS      2
 267+ 84C7 00 00        TargetVectorZpos        DS      2
 268+ 84C9 00 00        TargetVectorZsgn        DS      2
 269+ 84CB 00           CurrentMissileBlastRange:      DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 270+ 84CC 00           CurrentMissileBlastDamage:     DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 271+ 84CD 00           CurrentMissileDetonateRange:   DB  0                       ; TODO Initi for runtime copied in when setting up a missile, allows for proximity missiles
 272+ 84CE 00           CurrentMissileDetonateDamage:  DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 273+ 84CF
 274+ 84CF              ; --- Main Loop Data -----------------------;
 275+ 84CF 00           CurrentUniverseAI       DB  0               ; current ship unviverse slot due an AI update
 276+ 84D0 00           SelectedUniverseSlot    DB  0
 277+ 84D1 00           SetStationAngryFlag     DB  0               ; used to semaphore angry space station
 278+ 84D2 00           ShipBlastCheckCounter   DB  0
 279+ 84D3 00           InnerHyperCount			DB 	0				; 2F QQ22+1
 280+ 84D4 00           OuterHyperCount			DB 	0				; 2E QQ22
 281+ 84D5 00           EventCounter            DB  0
 282+ 84D6 00           HyperCircle             DB  0
 283+ 84D7 00           MissJumpFlag            DB  0
 284+ 84D8 00           PlayerMisJump			DB	0				; $0341 witchspace misjump
 285+ 84D9 00           HyperSpaceFX			DB	0				; 0348 HFX (probabyl BBC specific
 286+ 84DA 00           ExtraVessels			DB	0				; 0349 EV Use d by cops, extra vessels still to spawn?
 287+ 84DB 00           Delay					DB	0				; 034A Delay general purpose eg. spawing EV or when printign messages
 288+ 84DC 00           CurrentMissileCheck:    DB  0               ; if > Universe Slot list then free for next missile
 289+ 84DD 00           MessageForDestroyed		DB	0				; 034B Message flag for item + destroyed
 290+ 84DE              UniverseSlotListSize    equ	12
 291+ 84DE 00 00 00...  UniverseSlotList        DS  UniverseSlotListSize
 292+ 84EA 00 00 00...  UniverseSlotType        DS  UniverseSlotListSize ; base type, e.g. missile, cargo etc,
 293+ 84F6              ; Probably not needed UniverseTypeCount       DS  UniverseSlotListSize
 294+ 84F6 04           ConsoleRefreshCounter   DB  ConsoleRefreshInterval ; Every 4 interations the console will update twice (once for primary and once for seconday buffer)
 295+ 84F7 00           ConsoleRedrawFlag       DB  0
 296+ 84F8 00           TextInputMode           DB  0
 297+ 84F9 00           CursorKeysPressed       DB  0               ; mapping of the current key presses
 298+ 84FA                                                          ; 7    6    5    4     3    2        1    0
 299+ 84FA                                                          ; Up   Down Left Right Home Recentre
 300+ 84FA 00           FireLaserPressed        DB  0
 301+ 84FB              ; --- Current System Data ------------------;
 302+ 84FB 00           SpaceStationSafeZone    DB  0               ; Flag to determine if we are in safe zone
 303+ 84FC 00           ExtraVesselsCounter     DB  0
 304+ 84FD 00           JunkCount				DB  0				; $033E
 305+ 84FE 00           AsteroidCount           DB  0               ; Not used as yet
 306+ 84FF 00           TransporterCount        DB  0
 307+ 8500 00           CopCount                DB  0
 308+ 8501 00           PirateCount             DB  0
 309+ 8502              ; --- Galaxy Data --------------------------;
 310+ 8502 00           Galaxy      			DB	0				; 0367 Galaxy (incremented with galactiv drive
 311+ 8503 00 00 00...  WorkingSeeds			DS	6
 312+ 8509 00 00 00...  PresentSystemSeeds		DS	6				; 03B2 - 03B7
 313+ 850F 00 00 00...  GalaxySeeds				DS	6				; 035B - 0360 QQ21
 314+ 8515 00           PresentSystemX			DB	0				; System we are currently in
 315+ 8516 00           PresentSystemY			DB  0				; System we are currently in
 316+ 8517 00           TargetSystemX			DB	0				; System we are targeting for jump
 317+ 8518 00           TargetSystemY			DB	0				; System we are targeting for jump
 318+ 8519 00           GovPresentSystem		DB	0				; 03AE Govenment
 319+ 851A 00           TekPresentSystem		DB	0				; 03AF Technology
 320+ 851B
 321+ 851B 00           CompassColor			DB	0				; 03C5
 322+ 851C 00           SoundToggle				DB	0				; 03C6
 323+ 851D 00           KeyboardRecenterToggle	DB	0				; 03C8
 324+ 851E 00           PATGMask				DB	0				; &03C9    \ PATG	\ Mask to scan keyboard X-key, for misjump
 325+ 851F 00           FlashToggle				DB  0				; 03CA \ FLH \ flash toggle
 326+ 8520 00           ReverseJoystick			DB	0				; 03CB \ JSTGY \ Y reverse joystick Y channel
 327+ 8521 00           JoystickToggle			DB	0				; 03CD  \ JSTK    \ K toggle keyboard/joystick
 328+ 8522 00           DigitalJoystick			DB	0				; 03CE \ JDB   \ . = toggle between keyboard and bitpaddle
 329+ 8523 00           DiskReadFailFlag		DB	0				; 03CF \ CATF \ Disk catalog fail flag
 330+ 8524
 331+ 8524              ; Working Data
 332+ 8524
 333+ 8524              ;UniverseTable			DS	26				; 1741  \ address pointers for 13 ships INF on pages &9. 37 bytes each.
 334+ 8524              ; $0900 =	EQUW page9+37* 0 \ copied to inner worskpace INWK on zero-page when needed
 335+ 8524              ; $0925 =	EQUW page9+37* 1
 336+ 8524              ; $094A =	EQUW page9+37* 2
 337+ 8524              ; $096F =	EQUW page9+37* 3
 338+ 8524              ; $0994 =	EQUW page9+37* 4
 339+ 8524              ; $09B9 =	EQUW page9+37* 5
 340+ 8524              ; $09DE =	EQUW page9+37* 6
 341+ 8524              ; $0A03 =	EQUW page9+37* 7
 342+ 8524              ; $0A28 =	EQUW page9+37* 8
 343+ 8524              ; $0A4D =	EQUW page9+37* 9
 344+ 8524              ; $0A72 =	EQUW page9+37*10
 345+ 8524              ; $0A97 =	EQUW page9+37*11
 346+ 8524              ; $0ABC =	EQUW page9+37*12 \ allwk up to &0ABC while heap for edges working down from &CFF.
 347+ 8524
 348+ 8524
 349+ 8524
 350+ 8524              ; 0b00 is start address of data to save
 351+ 8524              ; Now MissionData VarTP					DB	0				; 0358 TP? The Plan  \ mission uses lower 4 bits
 352+ 8524              											; Bit mask XXXX10XX - Thargoid plan mission
 353+ 8524
 354+ 8524 00           MissionData				DB	0				; &0B00	  \ look at data, first byte is TP mission bits
 355+ 8525
 356+ 8525 00 00        FileNameStringPointer	DW	0				;0C00	   \ pointer to filename string
 357+ 8527 00 00        CommanderLoadAddress	DW	0				;0C03
 358+ 8529 00 00        LengthOfFile			DW	0				;0C0B
 359+ 852B 00 00        SaveDataEndAddress		DW	0				;&0C0F	      \ &0C00 is end address of data to save
 360+ 852D
 361+ 852D 00 00 00...  EdgesBuffer				DS 50
 362+ 855F              EdgesBufferSP			equ	$				; Was $0CFF			; Heap pointer for edges buffer
 363+ 855F              ShipLinesBufferSP		equ EdgesBufferSP	; was $0CFF
 364+ 855F
 365+ 855F 00 00 00...  ShipLineStack			DS  70			; For now but will be in the page later
 366+ 85A5              ShipLineStackTop		equ $ - ShipLineStack
 367+ 85A5
 368+ 85A5 00 00 00...  LSO						DS 	$C0				;0E00 Line Buffer Solar of 192 lines (may be 191 in reality)
 369+ 8665              ; LSX vector overlaps with LSO
 370+ 8665 00           LSX2					DB	0				; &0EC0	    \ LSX2 bline buffer size?
 371+ 8666 00           LSY2					DB	0           	; &0F0E	    \ LSY2
 372+ 8667
 373+ 8667              ; Star Positions are 16 bit 3d coordinates
 374+ 8667 00 00 00...  varDust                 DS  MaxNumberOfStars * 6
 375+ 86A9 00 00 00...  varDustSceen            DS  MaxNumberOfStars * 2 ; To optimise star list to wipe from screen
 376+ 86BF 00           varStarX                DB  0
 377+ 86C0 00           varStarY                DB  0
 378+ 86C1 00 00 00...  varDustX                DS MaxNumberOfStars *2
 379+ 86D7 00 00 00...  varDustY                DS MaxNumberOfStars *2
 380+ 86ED 00 00 00...  varDustZ                DS MaxNumberOfStars *2
 381+ 8703              ; -- Player Runtime Data
 382+ 8703 00           GunTemperature          DB  0
 383+ 8704 00           CabinTemperature        DB  0
 384+ 8705 00           PlayerForwardSheild0	DB	0 ; ?????
 385+ 8706 00           PlayerForwardSheild1    DB	0
 386+ 8707 00           PlayerForwardSheild2    DB	0
 387+ 8708 00           ForeShield				DB	0				; 03A5
 388+ 8709 00           AftShield				DB	0				; 03A6
 389+ 870A 00           PlayerEnergy			DB	0				; 03A7
 390+ 870B 00           CompassX				DB	0				; 03A8
 391+ 870C 00           CompassY				DB	0				; 03A9
 392+ 870D 00           MissileTarget			DB  0				; 45
 393+ 870E 00           MissileLaunchFlag       DB  0
 394+ 870F 00 00 00...  CommanderName           DS  15
 395+ 871E 00           CommanderName0			DB	0				; Sneaky little 0 to allow use of print name directly
 396+ 871F 00           BadnessStatus           DB  0
 397+ 8720              ; need to add copy table routines
 398+ 8720 00           CurrLaserType           DB  0               ; current view laser type, copied in from LaserType array
 399+ 8721 00           CurrLaserDamage         DB  0               ; copied in from LaserDamagedFlag array
 400+ 8722 00           CurrLaserPulseRate      DB  0               ; current view laser amount of pulses
 401+ 8723 00           CurrLaserPulseOnTime    DB  0               ; how many cycles the laser is on
 402+ 8724 00           CurrLaserPulseOffTime   DB  0               ; how many cycles the laser is on
 403+ 8725 00           CurrLaserPulseRest      DB  0               ; current view laser delay setup between pulses
 404+ 8726              ; Count down timers must be aligned like this to work
 405+ 8726 00           CurrLaserPulseOnCount   DB  0               ; how many cycles the laser is on timer
 406+ 8727 00           CurrLaserPulseOffCount  DB  0               ; how many cycles the laser is on timer
 407+ 8728 00           CurrLaserPulseRestCount DB  0               ; countdown after shooting for next shot
 408+ 8729 00           CurrLaserPulseRateCount DB  0               ; current view laser current pulses fired
 409+ 872A              ;note rapidly changing views could reset these so need to consider it in an array
 410+ 872A
 411+ 872A              ; LaserType
 412+ 872A              ; LaserPulseRate                          ; how many pulses can be fired before long pause
 413+ 872A              ; LaserPulsePause                         ; time before next pulse - 0 = beam
 414+ 872A              ; LaserPulseRest                          ; time before pulse count resets to 0
 415+ 872A              ; LaserDamageOutput                       ; amount of damage for a laser hit
 416+ 872A              ; LaserEnergyDrain                        ; amount of energy drained by cycle
 417+ 872A              ; LaserHeat                               ; amount of heat generated
 418+ 872A              ; LaserDurability                         ; probabability out of 255 that a hit on unshielded will add random amount of damage
 419+ 872A              ; LaserDurabilityAmount                   ; max amount of damagage can be sustained in one damage hit
 420+ 872A              ; LaserInMarkets                          ; can this laser be purchased 0 = yes 1 = no
 421+ 872A              ; LaserTechLevel                          ; minimum tech level system to buy from
 422+ 872A
 423+ 872A 00           CurrLaserBurstRate      DB  0
 424+ 872B 00           CurrLaserBurstCount     DB  0
 425+ 872C 00           CurrLaserDamageOutput   DB  0
 426+ 872D 00           CurrLaserEnergyDrain    DB  0
 427+ 872E 00           CurrLaserHeat           DB  0
 428+ 872F 00           CurrLaserDurability     DB  0
 429+ 8730 00           CurrLaserDurabilityAmount DB  0
 430+ 8731
 431+ 8731              ; -- Input variables
 432+ 8731 00           JoystickX				DB	0				; 034C JSTX
 433+ 8732 00           JoystickY				DB	0				; 034D JSTY
 434+ 8733 00           XSAV2 					DB	0				; 034E used to temporary save 6502 X reg
 435+ 8734 00           YSAV2 					DB	0				; 034F used to temporary save 6502 Y reg
 436+ 8735
 437+ 8735              ; -- Console drawing data
 438+ 8735              FShieldStart            equ $8410
 439+ 8735              AShieldStart            equ $8D10
 440+ 8735              FuelStart               equ $9410
 441+ 8735
 442+ 8735              EnergyBar4Start         equ $A5D5
 443+ 8735              EnergyBar3Start         equ $ADD5
 444+ 8735              EnergyBar2Start         equ $B5D5
 445+ 8735              EnergyBar1Start         equ $BDD5
 446+ 8735              ; 70 /2 = 35 values
 447+ 8735              ;                            0                             1                             2                             3
 448+ 8735              ;                            0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6
 449+ 8735 01 02 02 03  FuelMapping             DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,19,20,21,21,22,23,24,25,26,27,28,30,31,31
 449+ 8739 04 04 05 06
 449+ 873D 06 07 08 09
 449+ 8741 0A 0A 0B 0C
 449+ 8745 0D 0E 0E 0F
 449+ 8749 10 10 11 13
 449+ 874D 14 15 15 16
 449+ 8751 17 18 19 1A
 449+ 8755 1B 1C 1E 1F
 449+ 8759 1F
 450+ 875A              SpeedoStart             equ $84D1
 451+ 875A              ;                            0                             1                             2                             3                             4
 452+ 875A              ;                            0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0
 453+ 875A 01 02 02 03  SpeedoMapping           DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,18,19,20,20,21,22,23,24,24,25,26,26,27,28,28,29,30,31
 453+ 875E 04 04 05 06
 453+ 8762 06 07 08 09
 453+ 8766 0A 0A 0B 0C
 453+ 876A 0D 0E 0E 0F
 453+ 876E 10 10 11 12
 453+ 8772 13 14 14 15
 453+ 8776 16 17 18 18
 453+ 877A 19 1A 1A 1B
 453+ 877E 1C 1C 1D 1E
 453+ 8782 1F
 454+ 8783
 455+ 8783              DialMiddleXPos          equ $E1
 456+ 8783              RollMiddle              equ $8CE0
 457+ 8783              PitchMiddle             equ $94E0
 458+ 8783
 459+ 8783
 460+ 8783              LaserDrainSystems:      DrainSystem PlayerEnergy, CurrLaserEnergyDrain
 460+ 8783 3A 2D 87    >                        ld      a,(CurrLaserEnergyDrain)
 460+ 8786 47          >                        ld      b,a
 460+ 8787 3A 0A 87    >                        ld      a,(PlayerEnergy)
 460+ 878A 90          >                        sub     a,b
 460+ 878B 32 0A 87    >                        ld      (PlayerEnergy),a
 460+ 878E 38 03       >                        jr      c,.ZeroSystem
 460+ 8790 C3 97 87    >                        jp      .ExitPoint
 460+ 8793             >.ZeroSystem:            ZeroA
 460+ 8793 AF          >                        xor a
 460+ 8794 32 0A 87    >                        ld      (PlayerEnergy),a
 460+ 8797             >.ExitPoint
 461+ 8797                                      BoostSystem GunTemperature, CurrLaserHeat
 461+ 8797 3A 2E 87    >                        ld      a,(CurrLaserHeat)
 461+ 879A 47          >                        ld      b,a
 461+ 879B 3A 03 87    >                        ld      a,(GunTemperature)
 461+ 879E 80          >                        add     b
 461+ 879F 32 03 87    >                        ld      (GunTemperature),a
 461+ 87A2 38 03       >                        jr      c, .MaxSystem
 461+ 87A4 C3 AC 87    >                        jp      .ExitPoint
 461+ 87A7 3E FF       >.MaxSystem:             ld      a,255
 461+ 87A9 32 03 87    >                        ld      (GunTemperature),a
 461+ 87AC             >.ExitPoint
 462+ 87AC C9                                   ret
 463+ 87AD
 464+ 87AD
 465+ 87AD              ResetPlayerShip:        ZeroThrottle
 465+ 87AD AF          >                        xor     a
 465+ 87AE 32 09 84    >                        ld      (DELTA),a
 465+ 87B1 32 0A 84    >                        ld      (DELT4Lo),a
 465+ 87B4 32 0B 84    >                        ld      (DELT4Lo+1),a
 466+ 87B7                                      ZeroPitch
 466+ 87B7 AF          >                        xor     a
 466+ 87B8 32 18 83    >                        ld      (BET2),a
 466+ 87BB 32 19 83    >                        ld      (BET2FLIP),a
 466+ 87BE 32 16 83    >                        ld      (JSTY),a
 466+ 87C1 32 15 83    >                        ld      (BETA),a
 467+ 87C4                                      ZeroRoll
 467+ 87C4 AF          >                        xor     a                              ; zero roll and climb
 467+ 87C5 32 25 83    >                        ld      (ALP2),a
 467+ 87C8 32 26 83    >                        ld      (ALP2FLIP),a
 467+ 87CB 32 21 83    >                        ld      (JSTX),a
 467+ 87CE 32 23 83    >                        ld      (ALPHA),a
 468+ 87D1                                      ClearMissileTarget
 468+ 87D1 AF          >                        xor     a                           ; Set missile target to FF
 468+ 87D2 3D          >                        dec     a
 468+ 87D3 32 0D 87    >                        ld      (MissileTarget),a
 468+ 87D6             >                        SetMemFalse MissileLaunchFlag
 468+ 87D6 3E FF       >                        ld      a,$FF
 468+ 87D8 32 0E 87    >                        ld      (MissileLaunchFlag),a
 469+ 87DB                                      ClearECM
 469+ 87DB AF          >                        xor     a
 469+ 87DC 32 1F 83    >                        ld      (ECMLoopA),a
 469+ 87DF 32 20 83    >                        ld      (ECMLoopB),a
 470+ 87E2                                      ChargeEnergyAndShields
 470+ 87E2 3E FF       >                        ld      a,$FF
 470+ 87E4 32 0A 87    >                        ld      (PlayerEnergy),a
 470+ 87E7 32 08 87    >                        ld      (ForeShield),a
 470+ 87EA 32 09 87    >                        ld      (AftShield),a
 471+ 87ED                                      ClearTemperatures
 471+ 87ED AF          >                        xor     a
 471+ 87EE 32 04 87    >                        ld      (CabinTemperature),a
 471+ 87F1 32 03 87    >                        ld      (GunTemperature),a
 472+ 87F4 CD 00 88                             call    IsLaserUseable
 473+ 87F7                                      MMUSelectCommander
 473+ 87F7 ED 91 57 38 >                     nextreg CommanderMMU,       BankCommander
 474+ 87FB CD DA E2                             call    LoadLaserToCurrent
 475+ 87FE C8                                   ret     z
 476+ 87FF
 477+ 87FF C9                                   ret
 478+ 8800
 479+ 8800 3A 20 87     IsLaserUseable:         ld      a,(CurrLaserType)
 480+ 8803 FE FF                                cp      255
 481+ 8805 C8                                   ret     z
 482+ 8806 3A 21 87                             ld      a,(CurrLaserDamage)
 483+ 8809 FE FF                                cp      255
 484+ 880B C9                                   ret
 485+ 880C
 486+ 880C CD 59 88     InitMainLoop:           call    ClearUnivSlotList
 487+ 880F AF                                   xor     a
 488+ 8810 32 CF 84                             ld      (CurrentUniverseAI),a
 489+ 8813 32 D1 84                             ld      (SetStationAngryFlag),a
 490+ 8816 3E 03                                ld      a,3
 491+ 8818 32 18 84                             ld      (MenuIdMax),a
 492+ 881B                                      SetMemFalse DockedFlag
 492+ 881B 3E FF       >                        ld      a,$FF
 492+ 881D 32 1C 84    >                        ld      (DockedFlag),a
 493+ 8820              ;                        call    InitialiseFrontView
general_variables.asm(494): error: Label not found: InitialiseCommander
 494+ 8820 CD 00 00                             call    InitialiseCommander
 495+ 8823                                      MMUSelectUniverseN 2
 495+ 8823 ED 91 56 48 >                     nextreg UniverseMMU,       BankUNIVDATA0+2
general_variables.asm(496): error: Label not found: SetInitialShipPosition
 496+ 8827 CD 00 00                             call    SetInitialShipPosition
 497+ 882A              ; Initialist screen refresh
 498+ 882A 3E 04                                ld      a, ConsoleRefreshInterval
 499+ 882C 32 F6 84                             ld      (ConsoleRefreshCounter),a
 500+ 882F                                      SetMemFalse    ConsoleRedrawFlag
 500+ 882F 3E FF       >                        ld      a,$FF
 500+ 8831 32 F7 84    >                        ld      (ConsoleRedrawFlag),a
 501+ 8834                                      MMUSelectStockTable
 501+ 8834 ED 91 57 37 >                     nextreg StockTableMMU,     BankStockTable
general_variables.asm(502): error: Label not found: generate_stock_market
 502+ 8838 CD 00 00                             call    generate_stock_market
general_variables.asm(503): error: Label not found: ResetMessageQueue
 503+ 883B CD 00 00                             call    ResetMessageQueue
 504+ 883E                                      InitEventCounter
 504+ 883E AF          >                        xor     a
 504+ 883F 32 D5 84    >                        ld      (EventCounter),a
 505+ 8842                                      ClearMissJump
 505+ 8842 3E FF       >                        ld      a,$FF
 505+ 8844 32 D7 84    >                        ld      (MissJumpFlag),a
 506+ 8847                                      SetMemFalse TextInputMode
 506+ 8847 3E FF       >                        ld      a,$FF
 506+ 8849 32 F8 84    >                        ld      (TextInputMode),a
 507+ 884C C9                                   ret
 508+ 884D
 509+ 884D
# file closed: ../Variables/general_variables.asm
 106  884D                  INCLUDE "../Variables/UniverseSlotRoutines.asm"
# file opened: ../Variables/UniverseSlotRoutines.asm
   1+ 884D AF           ClearSlotCount:         xor     a
   2+ 884E 21 DE 84                             ld      hl,UniverseSlotList
   3+ 8851 06 0C                                ld      b, UniverseSlotListSize ; prbably not needed + UniverseSlotTypeSize
   4+ 8853 77           .fillLoop:              ld      (hl),a
   5+ 8854 23                                   inc     hl
   6+ 8855 10 FC                                djnz    .fillLoop
   7+ 8857 C9                                   ret
   8+ 8858
   9+ 8858              ; Initialises all types to a count of 1 where there is an occupied universe slot
  10+ 8858              ; this needs expanding to cater for a missing type, find type and increment count (use cpir?)
  11+ 8858              ; DOE NOT WORK CorrectSlotCount:       call    ClearSlotCount
  12+ 8858              ; DOE NOT WORK                         ld      hl,UniverseSlotCount
  13+ 8858              ; DOE NOT WORK                         ld      de,UniverseSlotList
  14+ 8858              ; DOE NOT WORK                         ld      b,UniverseSlotListSize
  15+ 8858              ; DOE NOT WORK .fillLoop:              ld      a,(de)
  16+ 8858              ; DOE NOT WORK                         cp      $FF
  17+ 8858              ; DOE NOT WORK                         jr      z,.SkipSlot
  18+ 8858              ; DOE NOT WORK .CorrectSlot:           ld      (hl),a
  19+ 8858              ; DOE NOT WORK                         inc     hl
  20+ 8858              ; DOE NOT WORK                         ld      (hl),1
  21+ 8858              ; DOE NOT WORK                         inc     hl
  22+ 8858              ; DOE NOT WORK                         inc     hl
  23+ 8858              ; DOE NOT WORK .SkipSlot               inc     de
  24+ 8858              ; DOE NOT WORK                         djnz    .fillLoop
  25+ 8858 C9                                   ret
  26+ 8859              ; Wipe all items
  27+ 8859 3E FF        ClearUnivSlotList:      ld      a,$FF
  28+ 885B 21 DE 84                             ld      hl,UniverseSlotList
  29+ 885E 06 18                                ld      b, UniverseSlotListSize * 2
  30+ 8860 77           .fillLoop:              ld      (hl),a
  31+ 8861 23                                   inc     hl
  32+ 8862 10 FC                                djnz    .fillLoop
  33+ 8864 C9                                   ret
  34+ 8865
  35+ 8865 21 DE 84     SetSlot0ToSpaceStation: ld      hl,UniverseSlotList
  36+ 8868 36 02                                ld      (hl),ShipTypeStation
  37+ 886A 21 EA 84                             ld      hl,UniverseSlotType
  38+ 886D 36 02                                ld      (hl),ShipTypeStation
  39+ 886F C9                                   ret
  40+ 8870
  41+ 8870 21 DE 84     SetSlotAToTypeB:        ld      hl,UniverseSlotList
  42+ 8873 ED 31                                add     hl,a
  43+ 8875 70                                   ld      (hl),b
  44+ 8876 C9                                   ret
  45+ 8877
  46+ 8877 21 EA 84     SetSlotAToClassB:       ld      hl,UniverseSlotType
  47+ 887A ED 31                                add     hl,a
  48+ 887C 70                                   ld      (hl),b
  49+ 887D C9                                   ret
  50+ 887E
  51+ 887E              ; Clears all except slot A, used when say restarting a space station post launch
  52+ 887E 57           ClearFreeSlotListSaveA: ld      d,a
  53+ 887F 0E 00                                ld      c,0
  54+ 8881 21 DE 84                             ld      hl,UniverseSlotList
  55+ 8884 06 18                                ld      b, UniverseSlotListSize * 2
  56+ 8886 79           .fillLoop:              ld      a,c
  57+ 8887 BA                                   cp      d
  58+ 8888 28 03                                jr      z,.SkipSlot
  59+ 888A 3E FF                                ld      a,$FF
  60+ 888C 77                                   ld      (hl),a
  61+ 888D 23           .SkipSlot:              inc     hl
  62+ 888E 23                                   inc     hl
  63+ 888F 10 F5                                djnz    .fillLoop
  64+ 8891 C9                                   ret
  65+ 8892
  66+ 8892 21 DE 84     ClearSlotA:             ld      hl,UniverseSlotList
  67+ 8895 ED 31                                add     hl,a
  68+ 8897 36 FF                                ld      (hl),$FF
  69+ 8899 3E 0C                                ld      a,UniverseSlotListSize  ; move to types
  70+ 889B ED 31                                add     hl,a
  71+ 889D 36 FF                                ld      (hl),$FF
  72+ 889F C9                                   ret
  73+ 88A0              ; Space Station will always be slot 0
  74+ 88A0
  75+ 88A0 21 EB 84     AreShipsPresent:        ld      hl,UniverseSlotType+1
  76+ 88A3 06 0B                                ld      b,UniverseSlotListSize -1      ; ignore space station
  77+ 88A5 7E           .NextShip:              ld      a,(hl)
  78+ 88A6 FE 00                                cp      ShipTypeNormal
  79+ 88A8                                      ClearCarryFlag
  79+ 88A8 B7          >                        or a
  80+ 88A9 C8                                   ret     z
  81+ 88AA 23                                   inc     hl
  82+ 88AB 10 F8                                djnz    .NextShip
  83+ 88AD                                      SetCarryFlag
  83+ 88AD 37          >                        scf
  84+ 88AE C9                                   ret
  85+ 88AF
  86+ 88AF 21 DE 84     IsSpaceStationPresent:  ld      hl,UniverseSlotList
  87+ 88B2                                      ClearCarryFlag
  87+ 88B2 B7          >                        or a
  88+ 88B3 7E           .SearchLoop:            ld      a,(hl)
  89+ 88B4                                      ReturnIfAEqNusng ShipTypeStation
  89+ 88B4 FE 02       >                        cp      ShipTypeStation
  89+ 88B6 C8          >                        ret     z
  90+ 88B7                                      SetCarryFlag
  90+ 88B7 37          >                        scf
  91+ 88B8 C9                                   ret
  92+ 88B9
  93+ 88B9 21 DE 84     GetTypeAtSlotA:         ld      hl,UniverseSlotList
  94+ 88BC ED 31                                add     hl,a
  95+ 88BE 7E                                   ld      a,(hl)
  96+ 88BF C9                                   ret
  97+ 88C0
  98+ 88C0 21 DF 84     IsPlanetOrSpaceStation: ld      hl,UniverseSlotList+1
  99+ 88C3 7E                                   ld      a,(hl)
 100+ 88C4 C9                                   ret
 101+ 88C5
 102+ 88C5 21 DE 84     FindNextFreeSlotInC:    ld      hl,UniverseSlotList
 103+ 88C8 06 0C                                ld      b, UniverseSlotListSize
 104+ 88CA 0E 00                                ld      c, 0
 105+ 88CC 7E           .SearchLoop:            ld      a,(hl)
 106+ 88CD                                      JumpIfAEqNusng $FF, .FoundSlot
 106+ 88CD FE FF       >                        cp     $FF
 106+ 88CF CA D8 88    >                        jp      z,.FoundSlot
 107+ 88D2 0C                                   inc     c
 108+ 88D3 23                                   inc     hl
 109+ 88D4 10 F6                                djnz    .SearchLoop
 110+ 88D6                                      SetCarryFlag
 110+ 88D6 37          >                        scf
 111+ 88D7 C9                                   ret
 112+ 88D8              .FoundSlot:             ClearCarryFlag
 112+ 88D8 B7          >                        or a
 113+ 88D9 C9                                   ret
 114+ 88DA
 115+ 88DA
 116+ 88DA CD C5 88     FindNextFreeSlotInA:    call    FindNextFreeSlotInC
 117+ 88DD 79                                   ld      a,c
 118+ 88DE C9                                   ret
 119+ 88DF
# file closed: ../Variables/UniverseSlotRoutines.asm
 107  88DF                  INCLUDE "../Variables/EquipmentVariables.asm"
# file opened: ../Variables/EquipmentVariables.asm
   1+ 88DF 00           AutoDocking				DB	0				; $033F
   2+ 88E0 00           PlayerECM				DB	0				; $0340
   3+ 88E1 00           Laser2					DB	0				; 0343 laser Power? Not sure
   4+ 88E2 00           LaserCount				DB	0				; 0346  LASCT  \ laser count =9 for pulse, cooled off?
   5+ 88E3 00 00 00 00  Cash					DB  0,0,0,0			; 0361 - 0364 Cash now litte endian
   6+ 88E7 19           Fuel					DB	25				; 0365  QQ14
   7+ 88E8 46           CargoBaySize			DB	70				; 036E
   8+ 88E9 00           CargoRunningLoad        DB  0
   9+ 88EA 00 00 00 00  CargoTonnes             DB  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   9+ 88EE 00 00 00 00
   9+ 88F2 00 00 00 00
   9+ 88F6 00 00 00 00
  10+ 88FA              ;CargoTonnes		    DB	16,1,2,3,4,5,6,7,6,9,10,11,12,13,14,15			; 036F - 037F	QQ20
  11+ 88FA              SlaveCargoTonnes		equ CargoTonnes+3
  12+ 88FA              NarcoticsCargoTonnes	equ CargoTonnes+6
  13+ 88FA              FirearmsCargoTonnes		equ CargoTonnes+10
  14+ 88FA              ; For each view laser a localised copy of the stats
  15+ 88FA              ; TODO - need to add code to maintain on load/save/equipment transactions
  16+ 88FA 00 00 00 00  LaserType               DS  4               ; quick reference to laser type
  17+ 88FE 00 00 00 00  LaserDamagedFlag        DS  4               ; probabiliy out of 255 that it will no fire, 0 = good, 255 = will not fire
  18+ 8902              ; dont need as static from table LaserPulseRate          DS  4               ; how many pulses can be fired before long pause
  19+ 8902              ; dont need as static from table LaserPulsePause         DS  4               ; time before next pulse - 0 = beam
  20+ 8902              ; dont need as static from table LaserPulseRest          DS  4               ; time before pulse count resets to 0
  21+ 8902              ; dont need as static from table LaserDamageOutput       DS  4               ; amount of damage for a laser hit
  22+ 8902              ; dont need as static from table LaserEnergyDrain        DS  4               ; amount of energy drained by cycle
  23+ 8902              ; dont need as static from table LaserHeat               DS  4               ; amount of heat generated
  24+ 8902              ; dont need as static from table LaserDurability         DS  4               ; probabability out of 255 that a hit on it unshielded will add random amount of damage
  25+ 8902              ; dont need as static from table LaserDurabilityAmount   DS  4               ; max amount of damagage can be sustained in one damage hit
  26+ 8902
  27+ 8902
  28+ 8902              QQ20                    equ CargoTonnes
EquipmentVariables.asm(29): error: Label not found: EQ_ITEM_COUNT
  29+ 8902              EquipmentFitted         DS  EQ_ITEM_COUNT    ; Series of flags for if each item is fitted
EquipmentVariables.asm(30): error: Label not found: EQ_ECM
  30+ 8902              ECMPresent				EQU EquipmentFitted + EQ_ECM				; 0380
EquipmentVariables.asm(31): error: Label not found: EQ_ENERGY_BOMB
  31+ 8902              EnergyBomb				EQU EquipmentFitted + EQ_ENERGY_BOMB		; 0382	Also random hyperspeace in Elite A
EquipmentVariables.asm(32): error: Label not found: EQ_ENERGY_UNIT
  32+ 8902              ExtraEnergyUnit			EQU EquipmentFitted + EQ_ENERGY_UNIT        ; 0383
EquipmentVariables.asm(33): error: Label not found: EQ_DOCK_COMP
  33+ 8902              DockingComputer 		EQU EquipmentFitted + EQ_DOCK_COMP    		; 0384
EquipmentVariables.asm(34): error: Label not found: EQ_GAL_DRIVE
  34+ 8902              GalacticHyperDrive		EQU EquipmentFitted + EQ_GAL_DRIVE   		; 0385
EquipmentVariables.asm(35): error: Label not found: EQ_ESCAPE_POD
  35+ 8902              EscapePod				EQU EquipmentFitted + EQ_ESCAPE_POD  		; 0386
  36+ 8902 01           FuelScoopsBarrelStatus	DB	1				; 0381
  37+ 8903
# file closed: ../Variables/EquipmentVariables.asm
 108  8903                  INCLUDE "../Variables/random_number.asm"
# file opened: ../Variables/random_number.asm
   1+ 8903              doRandom2:									; .DORND2	\ -> &3F85 \ Restricted for explosion dust.
   2+ 8903              doRND2:
   3+ 8903 A7           	and		a								; fast clear carry  leave bit0 of RAND+2 at 0.
   4+ 8904              doRandom:									;.DORND	\ -> &3F86 \ do random, new A, X.
   5+ 8904              ; "doRandom, Random Seed update, new value in A & B)"
   6+ 8904 3A 03 83     doRND:                  ld		a,(RandomSeed)					; Get Seed 0
   7+ 8907 CB 17                                rl		a								; Rotate L including carry
   8+ 8909 4F                                   ld		c,a								; c =  double lo
   9+ 890A 21 05 83     .AddSeed2:              ld		hl,RandomSeed2
  10+ 890D 8E                                   adc		a,(hl)							; RAND+2
  11+ 890E 32 03 83     .SaveAtoSeed:           ld		(RandomSeed),a					; and save RAND
  12+ 8911 08           .SaveBtoSeed2:          ex		af,af'
  13+ 8912 79                                   ld		a,c
  14+ 8913 32 05 83                             ld		(RandomSeed2),a
  15+ 8916 08                                   ex		af,af'
  16+ 8917 3A 04 83                             ld		a,(RandomSeed1)
  17+ 891A 4F                                   ld		c,a								; C = Seed1
  18+ 891B 21 06 83     .AddSeed3:              ld		hl,RandomSeed3
  19+ 891E 8E                                   adc		a,(hl)
  20+ 891F 32 04 83                             ld		(RandomSeed1),a
  21+ 8922 08                                   ex		af,af'
  22+ 8923 79                                   ld		a,c
  23+ 8924 32 06 83                             ld		(RandomSeed3),a
  24+ 8927 08                                   ex		af,af'
  25+ 8928 C9                                   ret
  26+ 8929
  27+ 8929              fillHeapRandom4Points:                      ; counter Y, 4 rnd bytes to edge heap
  28+ 8929 06 04        	ld		b,4
random_number.asm(29): error: Label not found: UbnkLineArray
  29+ 892B 21 00 00     	ld		hl,UbnkLineArray				; line data
  30+ 892E              FillRandom:                                 ; Writes random bytes hl = start address, b = nbr bytes to fill
  31+ 892E              EE55:
  32+ 892E CD 04 89     	call	doRND							; get random
  33+ 8931 77           	ld		(hl),a							; (XX19),Y
  34+ 8932 23           	inc		hl
  35+ 8933 10 F9        	djnz	FillRandom						; 3to6 = random bytes for seed
  36+ 8935 C9               ret
  37+ 8936
# file closed: ../Variables/random_number.asm
 109  8936                  INCLUDE "../Variables/galaxy_seed.asm"
# file opened: ../Variables/galaxy_seed.asm
   1+ 8936 47 41 4C 41  GALAXYSEED DB "GALAXYSEED"
   1+ 893A 58 59 53 45
   1+ 893E 45 44
   2+ 8940 21 0F 85     copy_galaxy_to_system:  ld		hl,GalaxySeeds
   3+ 8943 11 F9 83                             ld		de,SystemSeed
   4+ 8946 ED A0        copy_seed:		        ldi
   5+ 8948 ED A0                                ldi
   6+ 894A ED A0                                ldi
   7+ 894C ED A0                                ldi
   8+ 894E ED A0                                ldi
   9+ 8950 ED A0                                ldi
  10+ 8952 C9                                   ret
  11+ 8953
  12+ 8953 21 F9 83     copy_system_to_galaxy:  ld		hl,SystemSeed
  13+ 8956 11 0F 85                             ld		de,GalaxySeeds
  14+ 8959 18 EB                                jr		copy_seed
  15+ 895B
  16+ 895B 21 0F 85     copy_galaxy_to_working: ld		hl,GalaxySeeds
  17+ 895E 11 03 85                             ld		de,WorkingSeeds
  18+ 8961 18 E3                                jr		copy_seed
  19+ 8963
  20+ 8963 21 03 85     copy_working_to_galaxy: ld		hl,WorkingSeeds
  21+ 8966 11 0F 85                             ld		de,GalaxySeeds
  22+ 8969 18 DB                                jr		copy_seed
  23+ 896B
  24+ 896B 21 03 85     copy_working_to_system: ld		hl,WorkingSeeds
  25+ 896E 11 F9 83                             ld		de,SystemSeed
  26+ 8971 18 D3                                jr		copy_seed
  27+ 8973
  28+ 8973 21 F9 83     copy_system_to_working: ld		hl,SystemSeed
  29+ 8976 11 03 85                             ld		de,WorkingSeeds
  30+ 8979 18 CB                                jr		copy_seed
  31+ 897B
  32+ 897B              next_system_seed:							;.TT20	\ -> &2B0E  \ TWIST on QQ15 to next system
  33+ 897B CD 7E 89     		call	.NextStep					; This logic means we hard code x4
  34+ 897E              .NextStep:
  35+ 897E CD 81 89     		call	process_seed				; This logic means we hard code x2
  36+ 8981              process_seed:								; TT54	\ -> &2637 \ Twist seed for next digram in QQ15
  37+ 8981 3A F9 83     		ld		a,(SystemSeed)				; QQ15
  38+ 8984 B7           		or		a							; clear carry flag
  39+ 8985 21 FB 83     		ld		hl,SystemSeed+2				; hl -> qq+2
  40+ 8988 86           		add		a,(hl)						; a= QQ15 + QQ152
  41+ 8989 47           		ld		b,a							; partial sum lo
  42+ 898A 3A FA 83     		ld		a,(SystemSeed+1)
  43+ 898D 21 FC 83     		ld		hl,SystemSeed+3				; HL -> QQ+3 )we don't inc as it affects carry)
  44+ 8990 8E           		adc		a,(hl)						; note add with carry
  45+ 8991 4F           		ld		c,a  						; c = QQ1+QQ3+carry bit parial sum hi
  46+ 8992 3A FB 83     		ld		a,(SystemSeed+2)
  47+ 8995 32 F9 83     		ld		(SystemSeed+0),a			; copy qq152 to qq150
  48+ 8998 3A FC 83     		ld		a,(SystemSeed+3)
  49+ 899B 32 FA 83     		ld		(SystemSeed+1),a			; copy qq153 to qq151
  50+ 899E 3A FE 83     		ld		a,(SystemSeed+5)
  51+ 89A1 32 FC 83     		ld		(SystemSeed+3),a			; copy qq155 to qq153
  52+ 89A4 3A FD 83     		ld		a,(SystemSeed+4)
  53+ 89A7 32 FB 83     		ld		(SystemSeed+2),a			; copy qq154 to qq152
  54+ 89AA B7           		or		a
  55+ 89AB 78           		ld		a,b
  56+ 89AC 21 FB 83     		ld		hl,SystemSeed+2				; hl -> qq+2
  57+ 89AF 86           		add	    a,(hl)
  58+ 89B0 32 FD 83     		ld		(SystemSeed+4),a
  59+ 89B3 79           		ld		a,c
  60+ 89B4 21 FC 83     		ld		hl,SystemSeed+3				; HL -> QQ+3 )we don't inc as it affects carry)
  61+ 89B7 8E           		adc		a,(hl)
  62+ 89B8 32 FE 83     		ld		(SystemSeed+5),a
  63+ 89BB C9           		ret
  64+ 89BC
  65+ 89BC              next_working_seed:							;.TT20	\ -> &2B0E  \ TWIST on QQ15 to next system
  66+ 89BC CD BF 89     		call	.NextStep					; This logic means we hard code x4
  67+ 89BF              .NextStep:
  68+ 89BF CD C2 89     		call	working_seed				; This logic means we hard code x2
  69+ 89C2              working_seed:								; TT54	\ -> &2637 \ Twist seed for next digram in QQ15
  70+ 89C2              ; x = a + c
  71+ 89C2 3A 03 85     		ld		a,(WorkingSeeds)			; QQ15
  72+ 89C5 B7           		or		a							; clear carry flag
  73+ 89C6 21 05 85     		ld		hl,WorkingSeeds+2			; hl -> qq+2 [c]
  74+ 89C9 86           		add		a,(hl)						; a= QQ15 [a]+ QQ15 [c]
  75+ 89CA 47           		ld		b,a							; partial sum lo [x]
  76+ 89CB              ; y = b + d	+ carry
  77+ 89CB 3A 04 85     		ld		a,(WorkingSeeds+1)          ; [b]
  78+ 89CE 21 06 85     		ld		hl,WorkingSeeds+3			; HL -> QQ+3 [d] we don't inc as it affects carry)
  79+ 89D1 8E           		adc		a,(hl)						; note add with carry
  80+ 89D2 4F           		ld		c,a  						; c = QQ1+QQ3+carry bit parial sum hi
  81+ 89D3 3A 05 85     		ld		a,(WorkingSeeds+2)
  82+ 89D6 32 03 85     		ld		(WorkingSeeds+0),a			; copy qq152 to qq150 [a] = [c]
  83+ 89D9 3A 06 85     		ld		a,(WorkingSeeds+3)
  84+ 89DC 32 04 85     		ld		(WorkingSeeds+1),a			; copy qq153 to qq151 [b] = [d]
  85+ 89DF 3A 08 85     		ld		a,(WorkingSeeds+5)
  86+ 89E2 32 06 85     		ld		(WorkingSeeds+3),a			; copy qq155 to qq153 [d] = [f]
  87+ 89E5 3A 07 85     		ld		a,(WorkingSeeds+4)
  88+ 89E8 32 05 85     		ld		(WorkingSeeds+2),a			; copy qq154 to qq152 [c] = [e]
  89+ 89EB B7           		or		a
  90+ 89EC 78           		ld		a,b
  91+ 89ED 21 05 85     		ld		hl,WorkingSeeds+2		    ; hl -> qq+2
  92+ 89F0 86           		add	    a,(hl)
  93+ 89F1 32 07 85     		ld		(WorkingSeeds+4),a			; e = x + [c]
  94+ 89F4 79           		ld		a,c
  95+ 89F5 21 06 85     		ld		hl,WorkingSeeds+3			; HL -> QQ+3 )we don't inc as it affects carry)
  96+ 89F8 8E           		adc		a,(hl)
  97+ 89F9 32 08 85     		ld		(WorkingSeeds+5),a			; f = y + [d] + carry
  98+ 89FC C9           		ret
  99+ 89FD
 100+ 89FD 32           working_distX	DB 50
 101+ 89FE 32           working_distY	DB 50
 102+ 89FF 00           current_distY	DB 0
 103+ 8A00
 104+ 8A00 AF           find_present_system:    xor		a
 105+ 8A01 32 12 84                             ld		(XSAV),a
 106+ 8A04 3A FA 83     .CounterLoop:           ld		a,(SystemSeed+1)				; QQ15+1 \ seed Ycoord of star
 107+ 8A07 4F                                   ld		c,a
 108+ 8A08 3A 16 85     .calcLocaldy:           ld		a,(PresentSystemY)
 109+ 8A0B 47                                   ld		b,a								; so b holds Y ccord
 110+ 8A0C 79                                   ld		a,c
 111+ 8A0D 90                                   sub		b
 112+ 8A0E CB 7F                                bit		7,a
 113+ 8A10 28 02                                jr		z,.positivedy
 114+ 8A12 ED 44        .negativedy:            neg
 115+ 8A14 32 FF 89     .positivedy:            ld		(current_distY),a				; save cuirrent_dist Y as we need it maybe
 116+ 8A17 ED 5B FD 89                          ld		de,(working_distX)
 117+ 8A1B BA                                   cp		d
 118+ 8A1C 30 24                                jr		nc,.toofar
 119+ 8A1E 3A FC 83     .calcLocaldx:           ld		a,(SystemSeed+3)				; QQ15+3 \ seed Xcoord of star
 120+ 8A21 4F                                   ld		c,a
 121+ 8A22 3A 15 85                             ld		a,(PresentSystemX)
 122+ 8A25 47                                   ld		b,a								; so b holds Y ccord
 123+ 8A26 79                                   ld		a,c
 124+ 8A27 90                                   sub		b
 125+ 8A28 CB 7F                                bit		7,a
 126+ 8A2A 28 02                                jr		z,.positivedx
 127+ 8A2C ED 44        .negativedx:            neg
 128+ 8A2E 4F           .positivedx:            ld		c,a
 129+ 8A2F BB                                   cp		e
 130+ 8A30 30 10                                jr		nc,.toofar
 131+ 8A32 3A FF 89     .Nearer:			    ld		a,(current_distY) 				; we have a closer system
 132+ 8A35 47                                   ld		b,a								; we have c to recall Y into b
 133+ 8A36 ED 43 FD 89                          ld		(working_distX),bc
 134+ 8A3A C5                                   push	bc
 135+ 8A3B CD 73 89                             call 	copy_system_to_working
 136+ 8A3E C1                                   pop		bc
 137+ 8A3F 78                                   ld		a,b								;
 138+ 8A40 B1                                   or		c								;
 139+ 8A41 C8                                   ret		z								; if we have distance 0 then bang on
 140+ 8A42 CD 7B 89     .toofar:                call	next_system_seed
 141+ 8A45 3A 12 84                             ld		a,(XSAV)
 142+ 8A48 3D                                   dec		a
 143+ 8A49 FE 00                                cp		0
 144+ 8A4B C8                                   ret		z
 145+ 8A4C 32 12 84                             ld		(XSAV),a
 146+ 8A4F 18 B3                                jr		.CounterLoop
 147+ 8A51
 148+ 8A51              get_planet_data_working_seed:
 149+ 8A51 3A 04 85     		ld		a, (WorkingSeeds+1)
 150+ 8A54 E6 07        		and		7
 151+ 8A56 32 97 84     		ld		(DisplayEcononmy),a
 152+ 8A59 3A 05 85     		ld		a, (WorkingSeeds+2)
 153+ 8A5C CB 3F        		srl	a
 154+ 8A5E CB 3F        		srl	a
 155+ 8A60 CB 3F        		srl	a
 156+ 8A62 CB 3F        		srl	a								; c/8
 157+ 8A64 E6 07        		and		7
 158+ 8A66 32 98 84     		ld		(DisplayGovernment),a
 159+ 8A69 CB 3F        		srl	a
 160+ 8A6B FE 00        		cp		0
 161+ 8A6D 20 08        		jr		nz,.CanBeRich
 162+ 8A6F              .Fedual:
 163+ 8A6F 3A 97 84     		ld		a,(DisplayEcononmy)
 164+ 8A72 F6 02        		or		2							; Adjust Eco for Anarchy and Feudal, set bit 1.
 165+ 8A74 32 97 84     		ld		(DisplayEcononmy),a
 166+ 8A77              .CanBeRich:
 167+ 8A77 3A 97 84     		ld		a,(DisplayEcononmy)
 168+ 8A7A EE 07        		xor		7							; flip economy so Rich is now 7
 169+ 8A7C 32 99 84     		ld		(DisplayTekLevel),a			; Flipped Eco, EcoEOR7, Rich Ind = 7
 170+ 8A7F 47           		ld		b,a
 171+ 8A80 3A 06 85     		ld		a,(WorkingSeeds+3)
 172+ 8A83 E6 03        		and		3
 173+ 8A85 80           		add		a,b
 174+ 8A86 32 99 84     		ld		(DisplayTekLevel),a			; Tek Level += seed d & 3
 175+ 8A89 3A 98 84     		ld		a,(DisplayGovernment)		; Government, 0 is Anarchy
 176+ 8A8C CB 3F        		srl		a 							; gov/2
 177+ 8A8E 47           		ld		b,a
 178+ 8A8F 3A 99 84     		ld		a,(DisplayTekLevel)
 179+ 8A92 80           		add		a,b
 180+ 8A93 32 99 84     		ld		(DisplayTekLevel),a			; Tek += gov /2
 181+ 8A96 CB 27        		sla		a
 182+ 8A98 CB 27        		sla		a							; Onto Population (TL-1)*= 4
 183+ 8A9A 47           		ld		b,a
 184+ 8A9B 3A 97 84     		ld		a,(DisplayEcononmy)
 185+ 8A9E 80           		add		a,b                  		; TechLevel*4 + Eco   7-56
 186+ 8A9F 47           		ld		b,a
 187+ 8AA0 3A 98 84     		ld		a,(DisplayGovernment)
 188+ 8AA3 3C           		inc		a  							; +Government, 0 is Anarchy + 1
 189+ 8AA4 32 9A 84     		ld		(DisplayPopulation),a
 190+ 8AA7 3A 97 84     		ld		a,(DisplayEcononmy)
 191+ 8AAA EE 07        		xor		7							; Onto productivity
 192+ 8AAC C6 03        		add		3							;  (Flipped eco +3)
 193+ 8AAE 57           		ld		d,a
 194+ 8AAF 3A 98 84     		ld		a,(DisplayGovernment)		; Government, 0 is Anarchy
 195+ 8AB2 C6 04        		add		4
 196+ 8AB4 5F           		ld		e,a
 197+ 8AB5 ED 30        		mul									; ; DE = d*e, Productivity part 1. has hsb in A, lsb in P.
 198+ 8AB7 3A 9A 84     		ld		a,(DisplayPopulation)		; then we use d for radius
 199+ 8ABA 57           		ld		d,a
 200+ 8ABB ED 30        		mul
 201+ 8ABD CB 23        		sla		e
 202+ 8ABF CB 1A        		rr		d
 203+ 8AC1 CB 23        		sla		e
 204+ 8AC3 CB 1A        		rr		d
 205+ 8AC5 CB 23        		sla		e
 206+ 8AC7 CB 1A        		rr		d							; de * 8
 207+ 8AC9 ED 53 9C 84  		ld		(DisplayProductivity),de
 208+ 8ACD              .DoRadius:
 209+ 8ACD 3A 06 85     		ld		a,(WorkingSeeds+3)
 210+ 8AD0 4F           		ld		c,a
 211+ 8AD1 3A 08 85     		ld		a,(WorkingSeeds+5)
 212+ 8AD4 E6 0F        		and		$0F							;  lower 4 bits of w2_h determine planet radius
 213+ 8AD6 C6 0B        		add		11							;  radius min = 256*11 = 2816 km
 214+ 8AD8 47           		ld		b,a							;
 215+ 8AD9 ED 43 A0 84  		ld		(DisplayRadius),bc
 216+ 8ADD C9           		ret
 217+ 8ADE
# file closed: ../Variables/galaxy_seed.asm
 110  8ADE                  INCLUDE "../Tables/text_tables.asm"
# file opened: ../Tables/text_tables.asm
   1+ 8ADE 50 75 6C 73  StatusLaserName1	DB	"Pulse",0
   1+ 8AE2 65 00
   2+ 8AE4 42 65 61 6D  StatusLaserName2	DB	"Beam",0
   2+ 8AE8 00
   3+ 8AE9 4D 69 6C 69  StatusLaserName3    DB  "Military",0
   3+ 8AED 74 61 72 79
   3+ 8AF1 00
   4+ 8AF2 4D 69 6E 69  StatusLaserName4    DB  "Mining",0
   4+ 8AF6 6E 67 00
   5+ 8AF9 43 75 73 74  StatusLaserName5    DB  "Custom",0
   5+ 8AFD 6F 6D 00
   6+ 8B00
   7+ 8B00 DE 8A E4 8A  StatusLaserNameIdx	DW	StatusLaserName1,StatusLaserName2,StatusLaserName3,StatusLaserName4,StatusLaserName5
   7+ 8B04 E9 8A F2 8A
   7+ 8B08 F9 8A
   8+ 8B0A              StatusLaserNameIdxLen EQU $ - StatusLaserNameIdx
   9+ 8B0A
  10+ 8B0A 44 6F 63 6B  ConditionName1		DB "Docked",0
  10+ 8B0E 65 64 00
  11+ 8B11 47 72 65 65  ConditionName2		DB "Green",0
  11+ 8B15 6E 00
  12+ 8B17 59 65 6C 6C  ConditionName3		DB "Yellow",0
  12+ 8B1B 6F 77 00
  13+ 8B1E 52 65 64 00  ConditionName4		DB "Red",0
  14+ 8B22
  15+ 8B22 0A 8B 11 8B  ConditionNameIdx	DW ConditionName1,ConditionName2,ConditionName3,ConditionName4
  15+ 8B26 17 8B 1E 8B
  16+ 8B2A              ConditionNameIdxLen EQU $ - ConditionNameIdx
  17+ 8B2A
  18+ 8B2A 41 42 4F 55  StatusDiagrams		DB "ABOUSEITILETSTONLONUTHNOALLEXEGEZACEBISOUSESARMAINDIREA?ERATENBERALAVETIEDORQUANTEISRION",0
  18+ 8B2E 53 45 49 54
  18+ 8B32 49 4C 45 54
  18+ 8B36 53 54 4F 4E
  18+ 8B3A 4C 4F 4E 55
  18+ 8B3E 54 48 4E 4F
  18+ 8B42 41 4C 4C 45
  18+ 8B46 58 45 47 45
  18+ 8B4A 5A 41 43 45
  18+ 8B4E 42 49 53 4F
  18+ 8B52 55 53 45 53
  18+ 8B56 41 52 4D 41
  18+ 8B5A 49 4E 44 49
  18+ 8B5E 52 45 41 3F
  18+ 8B62 45 52 41 54
  18+ 8B66 45 4E 42 45
  18+ 8B6A 52 41 4C 41
  18+ 8B6E 56 45 54 49
  18+ 8B72 45 44 4F 52
  18+ 8B76 51 55 41 4E
  18+ 8B7A 54 45 49 53
  18+ 8B7E 52 49 4F 4E
  18+ 8B82 00
  19+ 8B83
  20+ 8B83 00 00 08 00  RankingTable		DW	$0000,$0008,$0010,$0020,$0040,$0080,$0200,$0A00,$1900,$4900,$FFFF
  20+ 8B87 10 00 20 00
  20+ 8B8B 40 00 80 00
  20+ 8B8F 00 02 00 0A
  20+ 8B93 00 19 00 49
  20+ 8B97 FF FF
  21+ 8B99
  22+ 8B99 48 61 72 6D  RankingName1		DB 	"Harmless",0
  22+ 8B9D 6C 65 73 73
  22+ 8BA1 00
  23+ 8BA2 4D 6F 73 74  RankingName2		DB 	"Mostly Harmless",0
  23+ 8BA6 6C 79 20 48
  23+ 8BAA 61 72 6D 6C
  23+ 8BAE 65 73 73 00
  24+ 8BB2 50 6F 6F 72  RankingName3		DB 	"Poor",0
  24+ 8BB6 00
  25+ 8BB7 41 76 65 72  RankingName4		DB 	"Average",0
  25+ 8BBB 61 67 65 00
  26+ 8BBF 41 62 6F 76  RankingName5		DB 	"Above Average",0
  26+ 8BC3 65 20 41 76
  26+ 8BC7 65 72 61 67
  26+ 8BCB 65 00
  27+ 8BCD 43 6F 6D 70  RankingName6		DB 	"Competent",0
  27+ 8BD1 65 74 65 6E
  27+ 8BD5 74 00
  28+ 8BD7 44 61 6E 67  RankingName7		DB 	"Dangerous",0
  28+ 8BDB 65 72 6F 75
  28+ 8BDF 73 00
  29+ 8BE1 44 65 61 64  RankingName8		DB 	"Deadly",0
  29+ 8BE5 6C 79 00
  30+ 8BE8 2D 2D 2D 2D  RankingName9		DB 	"---- E L I T E ---",0
  30+ 8BEC 20 45 20 4C
  30+ 8BF0 20 49 20 54
  30+ 8BF4 20 45 20 2D
  30+ 8BF8 2D 2D 00
  31+ 8BFB 53 6B 6F 6C  RankingName10		DB 	"Skollobsgod",0
  31+ 8BFF 6C 6F 62 73
  31+ 8C03 67 6F 64 00
  32+ 8C07 4E 75 74 74  RankingName11		DB 	"Nutter",0
  32+ 8C0B 65 72 00
  33+ 8C0E
  34+ 8C0E 99 8B A2 8B  RankingNameIdx		dw RankingName1,RankingName2,RankingName3,RankingName4,RankingName5,RankingName6,RankingName7,RankingName8,RankingName9,RankingName10,RankingName11
  34+ 8C12 B2 8B B7 8B
  34+ 8C16 BF 8B CD 8B
  34+ 8C1A D7 8B E1 8B
  34+ 8C1E E8 8B FB 8B
  34+ 8C22 07 8C
  35+ 8C24              RankingNameIdxLen EQU $ - RankingNameIdx
  36+ 8C24
  37+ 8C24
  38+ 8C24              getTableText:
  39+ 8C24              ; ">getTableText, hl = indexlist, a = textnbr, returns with hl = porinter to head of text"
  40+ 8C24              ; ">Note for ranking first 2 bytes are target rank"
  41+ 8C24 D5           	push	de								; save DE as we will likley need it in caller
  42+ 8C25 ED 31        	add		hl,a							; 0 based ref, and its 2 bytes
  43+ 8C27 ED 31        	add		hl,a
  44+ 8C29 5E           	ld		e,(hl)
  45+ 8C2A 23           	inc		hl
  46+ 8C2B 56           	ld		d,(hl)							; de = indexed address
  47+ 8C2C EB           	ex		de,hl							; flip it to hl
  48+ 8C2D D1           	pop		de								; retrieve de
  49+ 8C2E C9           	ret										; return with hl as start entry
  50+ 8C2F
  51+ 8C2F
  52+ 8C2F              ;               CF      ZF      Result
  53+ 8C2F              ;               -----------------------------------
  54+ 8C2F              ;               0       0       HL > DE
  55+ 8C2F              ;               0       1       HL == DE
  56+ 8C2F              ;               1       0       HL < DE
  57+ 8C2F              ;               1       1       Impossible
  58+ 8C2F              getRankIndex:
  59+ 8C2F              ; ">getRank, de = kill count, returns a = index,hl destroyed"
  60+ 8C2F              ; ">Note for ranking first 2 bytes are target rank"
  61+ 8C2F 7A           	ld		a,d
  62+ 8C30 B3           	or		e
  63+ 8C31 FE 00        	cp		0
  64+ 8C33 C8           	ret		z								; quicks skip for 0 kills
  65+ 8C34 AF           	xor 	a
  66+ 8C35 21 83 8B     	ld		hl,RankingTable
  67+ 8C38              .testLoop:
  68+ 8C38 4E           	ld		c,(hl)
  69+ 8C39 23           	inc		hl
  70+ 8C3A 46           	ld		b,(hl)							; bc = ranking
  71+ 8C3B E5           	push	hl
  72+ 8C3C 60           	ld		h,b
  73+ 8C3D 69           	ld		l,c
  74+ 8C3E CD A4 98     	call	compare16HLDE
  75+ 8C41 38 06        	jr		c,.HLLTDE
  76+ 8C43              .HLGTEDE									; Found the correct rank
  77+ 8C43 E1           	pop		hl
  78+ 8C44 23           	inc		hl								; move to next value
  79+ 8C45 23           	inc		hl
  80+ 8C46 3C           	inc		a								; we canloop forever as if kills was $FFFF then hits nutter rank but also +1 = 0000 as its 16 bit
  81+ 8C47 18 EF        	jr		.testLoop
  82+ 8C49              .HLLTDE:									; HL < Kills so found correct rank
  83+ 8C49 E1           	pop		hl
  84+ 8C4A C9           	ret
  85+ 8C4B
# file closed: ../Tables/text_tables.asm
 111  8C4B                  INCLUDE "../Tables/dictionary.asm"
# file opened: ../Tables/dictionary.asm
   1+ 8C4B 58 00        WordDummy					DB  "X",0
   2+ 8C4D 46 72 6F 6E  WordFront					DB	"Front",0              ;1
   2+ 8C51 74 00
   3+ 8C53 52 69 67 68  WordRight					DB	"Right",0              ;2
   3+ 8C57 74 00
   4+ 8C59 4C 65 66 74  WordLeft 					DB	"Left",0               ;3
   4+ 8C5D 00
   5+ 8C5E 52 65 61 72  WordRear   	 				DB	"Rear",0               ;4
   5+ 8C62 00
   6+ 8C63 4C 61 72 67  WordLarge           		DB  "Large",0              ;5
   6+ 8C67 65 00
   7+ 8C69 45 73 63 61  WordEscape          		DB  "Escape",0             ;6
   7+ 8C6D 70 65 00
   8+ 8C70 50 6F 64 00  WordPod             		DB  "Pod",0                ;7
   9+ 8C74 43 61 72 67  WordCargo           		DB  "Cargo",0              ;8
   9+ 8C78 6F 00
  10+ 8C7A 42 61 79 00  WordBay             		DB  "Bay",0                ;9
  11+ 8C7E 46 75 65 6C  WordFuel            		DB  "Fuel",0               ;10
  11+ 8C82 00
  12+ 8C83 53 63 6F 6F  WordScoops          		DB  "Scoops",0             ;11
  12+ 8C87 70 73 00
  13+ 8C8A 45 2E 43 2E  WordECM             		DB  "E.C.M.",0             ;12
  13+ 8C8E 4D 2E 00
  14+ 8C91 53 79 73 74  WordSystem          		DB  "System",0             ;13
  14+ 8C95 65 6D 00
  15+ 8C98 45 6E 65 72  WordEnergy					DB  "Energy",0             ;14
  15+ 8C9C 67 79 00
  16+ 8C9F 42 6F 6D 62  WordBomb					DB  "Bomb",0               ;15
  16+ 8CA3 00
  17+ 8CA4 4C 61 73 65  WordLaser					DB  "Laser",0              ;16
  17+ 8CA8 72 00
  18+ 8CAA 50 75 6C 73  WordPulse           		DB  "Pulse",0              ;17
  18+ 8CAE 65 00
  19+ 8CB0 42 65 61 6D  WordBeam            		DB  "Beam",0               ;18
  19+ 8CB4 00
  20+ 8CB5 4D 69 6C 69  WordMiliary         		DB  "Miliary",0            ;19
  20+ 8CB9 61 72 79 00
  21+ 8CBD 4D 69 6E 69  WordMining          		DB  "Mining",0             ;20
  21+ 8CC1 6E 67 00
  22+ 8CC4 43 75 73 74  WordCustom          		DB  "Custom",0             ;21
  22+ 8CC8 6F 6D 00
  23+ 8CCB 55 6E 69 74  WordUnit            		DB  "Unit",0               ;22
  23+ 8CCF 00
  24+ 8CD0 53 68 69 65  WordShield          		DB  "Shield",0             ;23
  24+ 8CD4 6C 64 00
  25+ 8CD7 44 6F 63 6B  WordDocking         		DB  "Docking",0            ;24
  25+ 8CDB 69 6E 67 00
  26+ 8CDF 43 6F 6D 70  WordComputers       		DB  "Computers",0          ;25
  26+ 8CE3 75 74 65 72
  26+ 8CE7 73 00
  27+ 8CE9 48 79 70 65  WordHyperspace      		DB  "Hyperspace",0         ;26
  27+ 8CED 72 73 70 61
  27+ 8CF1 63 65 00
  28+ 8CF4 47 61 6C 61  WordGalactic        		DB  "Galactic",0           ;27
  28+ 8CF8 63 74 69 63
  28+ 8CFC 00
  29+ 8CFD 45 78 74 72  WordExtra           		DB  "Extra",0              ;28
  29+ 8D01 61 00
  30+ 8D03 43 6C 65 61  WordClean           		DB  "Clean",0              ;29
  30+ 8D07 6E 00
  31+ 8D09 4F 66 66 65  WordOffender        		DB  "Offender",0           ;30
  31+ 8D0D 6E 64 65 72
  31+ 8D11 00
  32+ 8D12 46 75 67 69  WordFugitive        		DB  "Fugitive",0           ;31
  32+ 8D16 74 69 76 65
  32+ 8D1A 00
  33+ 8D1B 46 6F 6F 64  WordFood					DB	"Food",0               ;32
  33+ 8D1F 00
  34+ 8D20 54 65 78 74  WordTextiles				DB 	"Textiles",0           ;33
  34+ 8D24 69 6C 65 73
  34+ 8D28 00
  35+ 8D29 52 61 64 69  WordRadioactives			DB  "Radioactives",0       ;34
  35+ 8D2D 6F 61 63 74
  35+ 8D31 69 76 65 73
  35+ 8D35 00
  36+ 8D36 53 6C 61 76  WordSlaves					DB  "Slaves",0             ;35
  36+ 8D3A 65 73 00
  37+ 8D3D 4C 69 71 75  WordLiquorWines     		DB  "Liquor/Wines",0       ;36
  37+ 8D41 6F 72 2F 57
  37+ 8D45 69 6E 65 73
  37+ 8D49 00
  38+ 8D4A 4C 75 78 75  WordLuxuries  	    		DB  "Luxuries",0	       ;37
  38+ 8D4E 72 69 65 73
  38+ 8D52 00
  39+ 8D53 4E 61 72 63  WordNarcotics  	    		DB  "Narcotics",0	       ;38
  39+ 8D57 6F 74 69 63
  39+ 8D5B 73 00
  40+ 8D5D 4D 61 63 68  WordMachinery  	    		DB  "Machinery",0	       ;39
  40+ 8D61 69 6E 65 72
  40+ 8D65 79 00
  41+ 8D67 41 6C 6C 6F  WordAlloys  				DB  "Alloys",0		       ;40
  41+ 8D6B 79 73 00
  42+ 8D6E 46 69 72 65  WordFirearms  	    		DB  "Firearms",0	       ;41
  42+ 8D72 61 72 6D 73
  42+ 8D76 00
  43+ 8D77 46 75 72 73  WordFurs  		    		DB  "Furs",0	           ;42
  43+ 8D7B 00
  44+ 8D7C 4D 69 6E 65  WordMinerals  	    		DB  "Minerals",0           ;43
  44+ 8D80 72 61 6C 73
  44+ 8D84 00
  45+ 8D85 47 6F 6C 64  WordGold  		    		DB  "Gold",0	           ;44
  45+ 8D89 00
  46+ 8D8A 50 6C 61 74  WordPlatinum  	    		DB  "Platinum",0           ;45
  46+ 8D8E 69 6E 75 6D
  46+ 8D92 00
  47+ 8D93 47 65 6D 2D  WordGemStones  				DB  "Gem-Stones",0         ;46
  47+ 8D97 53 74 6F 6E
  47+ 8D9B 65 73 00
  48+ 8D9E 41 6C 69 65  WordAlienItems      		DB  "Alien Items",0        ;47
  48+ 8DA2 6E 20 49 74
  48+ 8DA6 65 6D 73 00
  49+ 8DAA 54 6F 6E 6E  WordTonnes          		DB  "Tonnes",0             ;48
  49+ 8DAE 65 73 00
  50+ 8DB1 4B 69 6C 6F  WordKilograms       		DB  "Kilograms",0          ;49
  50+ 8DB5 67 72 61 6D
  50+ 8DB9 73 00
  51+ 8DBB 47 72 61 6D  WordGrams           		DB  "Grams",0			   ;50
  51+ 8DBF 73 00
  52+ 8DC1 53 68 6F 72  WordShort           		DB  "Short",0			   ;51
  52+ 8DC5 74 00
  53+ 8DC7 52 61 6E 67  WordRange           		DB  "Range",0			   ;52
  53+ 8DCB 65 00
  54+ 8DCD 43 68 61 72  WordChart	        		DB  "Chart",0			   ;53
  54+ 8DD1 74 00
  55+ 8DD3 44 61 74 61  WordData					DB	"Data",0			   ;54
  55+ 8DD7 00
  56+ 8DD8 4F 6E 00     WordOn						DB  "On",0                 ;55
  57+ 8DDB 44 69 73 74  WordDistance        		DB  "Distance",0           ;56
  57+ 8DDF 61 6E 63 65
  57+ 8DE3 00
  58+ 8DE4 45 63 6F 6E  WordEconomy         		DB  "Economy",0            ;57
  58+ 8DE8 6F 6D 79 00
  59+ 8DEC 47 6F 76 65  WordGovernment      		DB  "Government",0         ;58
  59+ 8DF0 72 6E 6D 65
  59+ 8DF4 6E 74 00
  60+ 8DF7 54 65 63 68  WordTechLevel       		DB  "TechLevel",0          ;59
  60+ 8DFB 4C 65 76 65
  60+ 8DFF 6C 00
  61+ 8E01 50 6F 70 75  WordPopulation      		DB  "Population",0         ;60
  61+ 8E05 6C 61 74 69
  61+ 8E09 6F 6E 00
  62+ 8E0C 4D 69 6C 6C  WordMillion         		DB  "Million",0            ;61
  62+ 8E10 69 6F 6E 00
  63+ 8E14 42 69 6C 6C  WordBillion         		DB  "Billion",0            ;62
  63+ 8E18 69 6F 6E 00
  64+ 8E1C 47 72 6F 73  WordGross           		DB  "Gross",0              ;63
  64+ 8E20 73 00
  65+ 8E22 50 72 6F 64  WordProductivity    		DB  "Productivity",0       ;64
  65+ 8E26 75 63 74 69
  65+ 8E2A 76 69 74 79
  65+ 8E2E 00
  66+ 8E2F 41 76 65 72  WordAverage         		DB  "Average",0            ;65
  66+ 8E33 61 67 65 00
  67+ 8E37 52 61 64 69  WordRadius          		DB  "Radius",0             ;66
  67+ 8E3B 75 73 00
  68+ 8E3E 4B 4D 00     WordKM              		DB  "KM",0                 ;67
  69+ 8E41 4D 20 43 52  WordMCR             		DB  "M CR",0               ;68
  69+ 8E45 00
  70+ 8E46 52 69 63 68  WordRich					DB  "Rich",0               ;69
  70+ 8E4A 00
  71+ 8E4B 41 76 67 00  WordAvg         			DB  "Avg",0            	   ;70
  72+ 8E4F 4D 61 69 6E  WordMainly          		DB  "Mainly",0             ;71
  72+ 8E53 6C 79 00
  73+ 8E56 50 6F 6F 72  WordPoor            		DB  "Poor",0               ;72
  73+ 8E5A 00
  74+ 8E5B 49 6E 64 75  WordIndustrial      		DB  "Industrial",0         ;73
  74+ 8E5F 73 74 72 69
  74+ 8E63 61 6C 00
  75+ 8E66 41 67 72 69  WordAgricultural    		DB  "Agricultural",0       ;74
  75+ 8E6A 63 75 6C 74
  75+ 8E6E 75 72 61 6C
  75+ 8E72 00
  76+ 8E73 41 6E 61 72  WordAnarchy                 DB  "Anarchy",0            ;75
  76+ 8E77 63 68 79 00
  77+ 8E7B 46 65 75 64  WordFeudal                  DB  "Feudal",0             ;76
  77+ 8E7F 61 6C 00
  78+ 8E82 4D 75 6C 74  WordMultiGovernment         DB  "Multi-Government",0   ;77
  78+ 8E86 69 2D 47 6F
  78+ 8E8A 76 65 72 6E
  78+ 8E8E 6D 65 6E 74
  78+ 8E92 00
  79+ 8E93 44 69 63 74  WordDictatorship            DB  "Dictatorship",0       ;78
  79+ 8E97 61 74 6F 72
  79+ 8E9B 73 68 69 70
  79+ 8E9F 00
  80+ 8EA0 43 6F 6D 6D  WordCommunist               DB  "Communist",0          ;79
  80+ 8EA4 75 6E 69 73
  80+ 8EA8 74 00
  81+ 8EAA 43 6F 6E 66  WordConfederacy             DB  "Confederacy",0        ;80
  81+ 8EAE 65 64 65 72
  81+ 8EB2 61 63 79 00
  82+ 8EB6 44 65 6D 6F  WordDemocracy               DB  "Democracy",0          ;81
  82+ 8EBA 63 72 61 63
  82+ 8EBE 79 00
  83+ 8EC0 43 6F 72 70  WordCorporate               DB  "Corporate State",0    ;82
  83+ 8EC4 6F 72 61 74
  83+ 8EC8 65 20 53 74
  83+ 8ECC 61 74 65 00
  84+ 8ED0 53 74 61 74  WordState 					DB  "State",0              ;83
  84+ 8ED4 65 00
  85+ 8ED6 4C 69 67 68  WordLight 					DB  "Light",0              ;84
  85+ 8EDA 74 00
  86+ 8EDC 59 65 61 72  WordYears 					DB  "Years",0              ;85
  86+ 8EE0 73 00
  87+ 8EE2 30 00        Word0						DB  "0",0				   ;86
  88+ 8EE4 4D 61 72 6B  WordMarket					DB  "Market",0			   ;87
  88+ 8EE8 65 74 00
  89+ 8EEB 50 72 69 63  WordPrices					DB  "Prices",0			   ;88
  89+ 8EEF 65 73 00
  90+ 8EF2 50 72 6F 64  WordProduct    				DB  "Product",0  		   ;89
  90+ 8EF6 75 63 74 00
  91+ 8EFA 55 6F 4D 00  WordUoM						DB  "UoM",0                ;90
  92+ 8EFE 50 72 69 63  WordPrice					DB  "Price",0              ;91
  92+ 8F02 65 00
  93+ 8F04 46 6F 72 00  WordFor                     DB  "For",0                ;92
  94+ 8F08 53 61 6C 65  WordSale                    DB  "Sale",0               ;93
  94+ 8F0C 00
  95+ 8F0D 74 00        Wordt						DB  "t",0                  ;94
  96+ 8F0F 6B 67 00     Wordkg						DB  "kg",0                 ;95
  97+ 8F12 67 00        Wordg						DB  "g",0                  ;96
  98+ 8F14 51 75 61 6E  WordQuantity				DB  "Quanitity",0		   ;97
  98+ 8F18 69 74 69 74
  98+ 8F1C 79 00
  99+ 8F1E 49 6E 76 00  WordInv                     DB  "Inv",0                ;98
 100+ 8F22 53 74 6F 63  WordStock                   DB  "Stock",0              ;99
 100+ 8F26 6B 00
 101+ 8F28 45 71 75 69  WordEquip                   DB  "Equip",0              ;100
 101+ 8F2C 70 00
 102+ 8F2E 53 68 69 70  WordShip                    DB  "Ship",0               ;101
 102+ 8F32 00
 103+ 8F33 4D 69 73 73  WordMissile                 DB  "Missile",0            ;102
 103+ 8F37 69 6C 65 00
 104+ 8F3B 48 79 70 65  WordHyperdrive              DB  "Hyperdrive",0
 104+ 8F3F 72 64 72 69
 104+ 8F43 76 65 00
 105+ 8F46 4D 69 6C 69  WordMilitary                DB  "Military",0
 105+ 8F4A 74 61 72 79
 105+ 8F4E 00
 106+ 8F4F
 107+ 8F4F 4B 8C 4D 8C  WordIdx				DW  WordDummy,          WordFront,        WordRight,        WordLeft		;0-3
 107+ 8F53 53 8C 59 8C
 108+ 8F57 5E 8C 63 8C  					DW  WordRear,           WordLarge,        WordEscape,       WordPod      	;4-7
 108+ 8F5B 69 8C 70 8C
 109+ 8F5F 74 8C 7A 8C  					DW  WordCargo,          WordBay,          WordFuel,         WordScoops   	;8
 109+ 8F63 7E 8C 83 8C
 110+ 8F67 8A 8C 91 8C  					DW  WordECM,            WordSystem,       WordEnergy,       WordBomb     	;12
 110+ 8F6B 98 8C 9F 8C
 111+ 8F6F A4 8C AA 8C  					DW  WordLaser,          WordPulse,        WordBeam,         WordMiliary  	;16
 111+ 8F73 B0 8C B5 8C
 112+ 8F77 BD 8C C4 8C  					DW  WordMining,         WordCustom,       WordUnit,         WordShield   	;20
 112+ 8F7B CB 8C D0 8C
 113+ 8F7F D7 8C DF 8C  					DW  WordDocking,        WordComputers,    WordHyperspace,   WordGalactic 	;24
 113+ 8F83 E9 8C F4 8C
 114+ 8F87 FD 8C 03 8D  					DW  WordExtra,          WordClean,        WordOffender,     WordFugitive	;28
 114+ 8F8B 09 8D 12 8D
 115+ 8F8F 1B 8D 20 8D  					DW  WordFood,           WordTextiles,     WordRadioactives, WordSlaves		;32
 115+ 8F93 29 8D 36 8D
 116+ 8F97 3D 8D 4A 8D  					DW  WordLiquorWines,    WordLuxuries,     WordNarcotics,    WordMachinery   ;36
 116+ 8F9B 53 8D 5D 8D
 117+ 8F9F 67 8D 6E 8D  					DW  WordAlloys,         WordFirearms,     WordFurs,         WordMinerals    ;40
 117+ 8FA3 77 8D 7C 8D
 118+ 8FA7 85 8D 8A 8D  					DW  WordGold,           WordPlatinum,     WordGemStones,    WordAlienItems  ;44               ;
 118+ 8FAB 93 8D 9E 8D
 119+ 8FAF AA 8D B1 8D  WordIdxUoMFull		DW  WordTonnes,         WordKilograms,    WordGrams,		WordShort		;48
 119+ 8FB3 BB 8D C1 8D
 120+ 8FB7 C7 8D CD 8D  					DW	WordRange,		    WordChart,        WordData,         WordOn          ;52
 120+ 8FBB D3 8D D8 8D
 121+ 8FBF DB 8D E4 8D  					DW  WordDistance,       WordEconomy,      WordGovernment,   WordTechLevel   ;56
 121+ 8FC3 EC 8D F7 8D
 122+ 8FC7 01 8E 0C 8E  					DW  WordPopulation,     WordMillion,      WordBillion,      WordGross       ;60
 122+ 8FCB 14 8E 1C 8E
 123+ 8FCF 22 8E 2F 8E  					DW  WordProductivity,   WordAverage,      WordRadius,       WordKM          ;64
 123+ 8FD3 37 8E 3E 8E
 124+ 8FD7 41 8E        					DW  WordMCR																	;68
 125+ 8FD9 46 8E 4B 8E  WordIdxEconomy		DW  WordRich,           WordAvg,      	  WordMainly,       WordPoor        ;69
 125+ 8FDD 4F 8E 56 8E
 126+ 8FE1 5B 8E 66 8E                      DW  WordIndustrial,     WordAgricultural									;73
 127+ 8FE5 73 8E 7B 8E  WordIdxGovernment	DW  WordAnarchy,        WordFeudal,       WordMultiGovernment, WordDictatorship ;75
 127+ 8FE9 82 8E 93 8E
 128+ 8FED A0 8E AA 8E                      DW  WordCommunist,      WordConfederacy,  WordDemocracy,       WordCorporate ;79
 128+ 8FF1 B6 8E C0 8E
 129+ 8FF5 D0 8E D6 8E  					DW  WordState,          WordLight,        WordYears,           Word0         ; 83
 129+ 8FF9 DC 8E E2 8E
 130+ 8FFD E4 8E EB 8E  WordIdxMarketmenu	DW  WordMarket,         WordPrices,       WordProduct,         WordUoM	    ;87
 130+ 9001 F2 8E FA 8E
 131+ 9005 FE 8E 04 8F                      DW  WordPrice,          WordFor,          WordSale                          ;91
 131+ 9009 08 8F
 132+ 900B 0D 8F 0F 8F  WordIdxUomAbbrev	DW	Wordt,				Wordkg,           Wordg                 		    ;94
 132+ 900F 12 8F
 133+ 9011 14 8F 1E 8F  					DW  WordQuantity,       WordInv,          WordStock,           WordEquip	;97
 133+ 9015 22 8F 28 8F
 134+ 9019 2E 8F 33 8F                      DW  WordShip,           WordMissile       ; 101
 135+ 901D
 136+ 901D              ; Phrases
 137+ 901D 05 08 09 00  TextLargeCargoBay			DB 	5,8,9,0          ;0
 138+ 9021 06 07 00     TextEscapePod				DB	6,7,0            ;1
 139+ 9024 0A 0B 00     TextFuelScoops				DB	10,11,0          ;2
 140+ 9027 0C 0D 00     TextECMSystem				DB	12,13,0          ;3
 141+ 902A 0E 0F 00     TextEnergyBomb				DB	14,15,0          ;4
 142+ 902D 0E 16 00     TextEnergyUnit				DB	14,22,0          ;5
 143+ 9030 18 19 00     TextDockingComp     		DB  24,25,0          ;6
 144+ 9033 1B 1A 00     TextGalacticHyper			DB	27,26,0          ;7
 145+ 9036 01 12 10 00  TextFrontLaser      		DB  01,18,16,0       ;8
 146+ 903A 03 12 10 00  TextLeftLaser       		DB  03,18,16,0       ;9
 147+ 903E 02 12 10 00  TextRightLaser      		DB  02,18,16,0       ;10
 148+ 9042 04 12 10 00  TextRearLaser       		DB  04,18,16,0       ;11
 149+ 9046 33 34 35 00  TextShortRangeChart 		DB	51,52,53,0       ;12
 150+ 904A 1B 35 00     TextGalacticChart   		DB	27,53,0          ;13
 151+ 904D 36 37 00     TextDataOn					DB	54,55,0          ;14
 152+ 9050 45 49 00     TextRichIndustrial          DB  69,73,0          ;15
 153+ 9053 46 49 00     TextAvgIndustrial           DB  70,73,0			 ;16
 154+ 9056 47 49 00     TextMainIndustrial          DB  71,73,0          ;17
 155+ 9059 48 49 00     TextPoorIndustrial          DB  72,73,0          ;18
 156+ 905C 45 4A 00     TextRichAgricultural        DB  69,74,0          ;19
 157+ 905F 46 4A 00     TextAvgAgricultural         DB  70,74,0          ;20
 158+ 9062 47 4A 00     TextMainAgricultural        DB  71,74,0          ;21
 159+ 9065 48 4A 00     TextPoorAgricultural        DB  72,74,0          ;22
 160+ 9068 54 55 00     TextLightYears				DB  84,85,0			 ;23
 161+ 906B 56 54 55 00  Text0LightYears				DB  86,84,85,0		 ;24
 162+ 906F 57 58 00     TextMarketPrices			DB  87,88,0			 ;25
 163+ 9072 64 65        TextEquipShip               DB  100,101          ;26
 164+ 9074
 165+ 9074 00           TextDummy					DB  0
 166+ 9075
 167+ 9075 1D 90 21 90  TextTokens			DW  TextLargeCargoBay, TextEscapePod, TextFuelScoops				; 0 2
 167+ 9079 24 90
 168+ 907B 27 90 2A 90  					DW  TextECMSystem, TextEnergyBomb, TextEnergyUnit					; 3 5
 168+ 907F 2D 90
 169+ 9081 30 90 33 90  					DW  TextDockingComp, TextGalacticHyper  							; 6 7
 170+ 9085 36 90 3A 90  					DW	TextFrontLaser, TextLeftLaser, TextRightLaser, TextRearLaser	; 8 11
 170+ 9089 3E 90 42 90
 171+ 908D 46 90 4A 90  					DW  TextShortRangeChart, TextGalacticChart, TextDataOn				; 12 14
 171+ 9091 4D 90
 172+ 9093 50 90 53 90  TextTokenEconomy	DW  TextRichIndustrial, TextAvgIndustrial, TextPoorIndustrial, TextMainIndustrial, TextMainAgricultural, TextRichAgricultural, TextAvgAgricultural,  TextPoorAgricultural
 172+ 9097 59 90 56 90
 172+ 909B 62 90 5C 90
 172+ 909F 5F 90 65 90
 173+ 90A3 68 90        					DW  TextLightYears		                                            ; 21 23
 174+ 90A5 6B 90 6F 90  					DW  Text0LightYears, TextMarketPrices
 175+ 90A9 74 90        					DW  TextDummy;  25
 176+ 90AB 00 00 00...  TextBuffer			DS	33
 177+ 90CC
 178+ 90CC              TextEconomyOffset   EQU (TextTokenEconomy - TextTokens)/2
 179+ 90CC              TextGovOffset       EQU (WordIdxGovernment - WordIdx)/2
 180+ 90CC
 181+ 90CC              CapitaliseString:
 182+ 90CC              ; ">CapitaliseString hl = address"
 183+ 90CC              .CapLoop:
 184+ 90CC 23           	inc		hl
 185+ 90CD 7E           	ld		a,(hl)
 186+ 90CE FE 00        	cp		0
 187+ 90D0 C8           	ret		z
 188+ 90D1 FE 5B        	cp		'Z'+1
 189+ 90D3 30 F7        	jr		nc,.CapLoop
 190+ 90D5 FE 41        	cp		'A'
 191+ 90D7 38 F3        	jr		c,.CapLoop
 192+ 90D9              .LowerCase:
 193+ 90D9 C6 20        	add		a,'a'-'A'
 194+ 90DB 77           	ld		(hl),a
 195+ 90DC 18 EE        	jr		.CapLoop
 196+ 90DE
 197+ 90DE              WordIndexToAddress:
 198+ 90DE 21 4F 8F     	ld		hl,WordIdx
 199+ 90E1 ED 31        	add		hl,a
 200+ 90E3 ED 31        	add		hl,a
 201+ 90E5 D5           	push	de
 202+ 90E6 5E           	ld		e,(hl)
 203+ 90E7 23           	inc		hl
 204+ 90E8 56           	ld		d,(hl)
 205+ 90E9 EB           	ex		de,hl
 206+ 90EA D1           	pop		de
 207+ 90EB C9           	ret
 208+ 90EC
 209+ 90EC
 210+ 90EC              expandTokenToString:
 211+ 90EC              ; ">expandTokenToString a = texttoken"
 212+ 90EC 21 75 90     	ld		hl,TextTokens
 213+ 90EF CD 24 8C     	call	getTableText
 214+ 90F2 11 AB 90     	ld		de,TextBuffer
 215+ 90F5              .ReadLoop:
 216+ 90F5 7E           	ld		a,(hl)
 217+ 90F6 FE 00        	cp		0
 218+ 90F8 28 1B        	jr		z,.ReadDone
 219+ 90FA E5           	push	hl
 220+ 90FB D5           	push	de
 221+ 90FC 21 4F 8F     	ld		hl,WordIdx
 222+ 90FF CD 24 8C     	call	getTableText
 223+ 9102 D1           	pop		de
 224+ 9103              .WordExpandLoop:
 225+ 9103 7E           	ld		a,(hl)
 226+ 9104 FE 00        	cp		0
 227+ 9106 28 05        	jr		z,.AddSpace
 228+ 9108              ;.GetChar:
 229+ 9108 12           	ld		(de),a
 230+ 9109 13           	inc		de
 231+ 910A 23           	inc		hl
 232+ 910B 18 F6        	jr		.WordExpandLoop
 233+ 910D              .AddSpace:
 234+ 910D 3E 20        	ld		a,' '
 235+ 910F 12           	ld		(de),a
 236+ 9110 13           	inc		de
 237+ 9111 E1           	pop		hl
 238+ 9112 23           	inc		hl
 239+ 9113 18 E0        	jr		.ReadLoop
 240+ 9115              .ReadDone:
 241+ 9115 1B           	dec		de
 242+ 9116 AF           	xor		a
 243+ 9117 12           	ld		(de),a
 244+ 9118 C9           	ret
 245+ 9119
# file closed: ../Tables/dictionary.asm
 112  9119                  INCLUDE "../Tables/name_digrams.asm"
# file opened: ../Tables/name_digrams.asm
   1+ 9119 41 42 4F 55  name_digrams	DB "ABOUSEITILETSTONLONUTHNO"
   1+ 911D 53 45 49 54
   1+ 9121 49 4C 45 54
   1+ 9125 53 54 4F 4E
   1+ 9129 4C 4F 4E 55
   1+ 912D 54 48 4E 4F
   2+ 9131 41 4C 4C     name_digrams2   DB "ALL"
   3+ 9134 45 58 45 47  				DB "EXEGEZACEBISOUSESARMAINDIREA"
   3+ 9138 45 5A 41 43
   3+ 913C 45 42 49 53
   3+ 9140 4F 55 53 45
   3+ 9144 53 41 52 4D
   3+ 9148 41 49 4E 44
   3+ 914C 49 52 45 41
   4+ 9150 3F 45 52 41  				DB "?ERATENBERALAVETIEDORQUANTEISRION"
   4+ 9154 54 45 4E 42
   4+ 9158 45 52 41 4C
   4+ 915C 41 56 45 54
   4+ 9160 49 45 44 4F
   4+ 9164 52 51 55 41
   4+ 9168 4E 54 45 49
   4+ 916C 53 52 49 4F
   4+ 9170 4E
   5+ 9171
   6+ 9171              ; TODO Moveinto galaxy data module
   7+ 9171 00 00 00...  name_expanded	DS 32
   8+ 9191 00           				DB 0
   9+ 9192
  10+ 9192
  11+ 9192
  12+ 9192              NamingLoop:
  13+ 9192 3A 08 85     	ld		a,(WorkingSeeds+5)	; a = first byte of name seed
  14+ 9195 E6 1F        	and 	$1F					; Keep bottom 5 bits only
  15+ 9197 FE 00        	cp		0					; 0 = skip 2 chars
  16+ 9199 28 12        	jr		z,.SkipPhrase
  17+ 919B C6 0C        	add		a,12
  18+ 919D CB 27        	sla		a					; phrase = (a+12)*2
  19+ 919F 21 19 91     	ld		hl,name_digrams
  20+ 91A2 ED 31        	add		hl,a
  21+ 91A4 ED A0        	ldi
  22+ 91A6 7E           	ld		a,(hl)
  23+ 91A7 FE 3F        	cp		'?'
  24+ 91A9 28 02        	jr		z,.SkipPhrase
  25+ 91AB              .AddExtra:
  26+ 91AB ED A0        	ldi
  27+ 91AD              .SkipPhrase:
  28+ 91AD D5           	push	de
  29+ 91AE CD C2 89     	call	working_seed
  30+ 91B1 D1           	pop		de
  31+ 91B2 C9           	ret
  32+ 91B3
  33+ 91B3              ;GetDigramGalaxySeed:
  34+ 91B3              ;	call	copy_galaxy_to_working
  35+ 91B3              ;	jr		GetDigramWorkingSeed
  36+ 91B3              ;GetDigramSystemSeed:
  37+ 91B3              ;	call	copy_system_to_working
  38+ 91B3              ;GetDigramWorkingSeed:
  39+ 91B3              ;; ">GetDigram a = digram seed"
  40+ 91B3              ;	ld		de,name_expanded
  41+ 91B3              ;	ld		b,3
  42+ 91B3              ;	ld		a,(WorkingSeeds)
  43+ 91B3              ;	and		$40
  44+ 91B3              ;	jr		z,.SmallSizeName
  45+ 91B3              ;.LargeSizeName:
  46+ 91B3              ;	call	NamingLoop
  47+ 91B3              ;.SmallSizeName:
  48+ 91B3              ;	call	NamingLoop
  49+ 91B3              ;	call	NamingLoop
  50+ 91B3              ;	call	NamingLoop
  51+ 91B3              ;.DoneName:
  52+ 91B3              ;	ex		de,hl
  53+ 91B3              ;	ld		(hl),0
  54+ 91B3              ;	ex		de,hl
  55+ 91B3              ;	ret
  56+ 91B3
  57+ 91B3
  58+ 91B3
  59+ 91B3              ;GetDigramWorkingSeed:
  60+ 91B3              ;	MESSAGE ">GetDigram a = digram seed b = length"
  61+ 91B3              ;	ld		b,5					; working seed
  62+ 91B3              ;	ld		de,name_expanded
  63+ 91B3              ;.ExpansionLoop:
  64+ 91B3              ;	push	bc
  65+ 91B3              ;	ld		hl,WorkingSeeds
  66+ 91B3              ;	ld		a,b
  67+ 91B3              ;	add		hl,a
  68+ 91B3              ;	ld		a,(hl)	; a = first byte of name seed
  69+ 91B3              ;	and 	$1F					; Keep bottom 5 bits only
  70+ 91B3              ;	cp		0					; 0 = skip 2 chars
  71+ 91B3              ;	jr		z,.SkipPhrase
  72+ 91B3              ;	or		&80					; set buit 7 high (probabtyl capitalisation)
  73+ 91B3              ;	call	TT27
  74+ 91B3              ;.SkipPhrase:
  75+ 91B3              ;	push	de
  76+ 91B3              ;	call	next_working_seed
  77+ 91B3              ;	pop		de
  78+ 91B3              ;	pop		bc
  79+ 91B3              ;	djnz	GetDigramWorkingSeed
  80+ 91B3              ;.DoneName:
  81+ 91B3              ;	ex		de,hl
  82+ 91B3              ;	ld		(hl),0
  83+ 91B3              ;	ex		de,hl
  84+ 91B3              ;	ret
  85+ 91B3              ;
  86+ 91B3              ;ExpandToken:
  87+ 91B3              ;	DE = target
  88+ 91B3              ;	a = token
  89+ 91B3              ;
  90+ 91B3              ;PlanetDigram:
  91+ 91B3              ;	cp		&A0							; >- 160
  92+ 91B3              ;	jr		c,MorePage4
  93+ 91B3              ;	and		$7F							; 128 to 159 now 0 to 31
  94+ 91B3              ;	asl		2							; Multiply by 2
  95+ 91B3              ;	ld		hl, name_digrams2
  96+ 91B3              ;	add		hl,a
  97+ 91B3              ;	ld		a,(hl)
  98+ 91B3              ;	call	ProcessTextToken
  99+ 91B3              ;	inc		hl
 100+ 91B3              ;	ld		a,(hl)
 101+ 91B3              ;	cp		'?'
 102+ 91B3              ;	ret		z
 103+ 91B3              ;	call	ProcessTextToken
 104+ 91B3              ;	ret
 105+ 91B3              ;MorePage4:
 106+ 91B3              ;	sub		$A0
 107+ 91B3              ;ExtraTokenCheck:
 108+ 91B3              ;	push	de							; save target address
 109+ 91B3              ;	push	bc
 110+ 91B3              ;	ld		b,a
 111+ 91B3              ;	ld		hl,varV
 112+ 91B3              ;	ld		(VarV),0400
 113+ 91B3              ;	ld		(varV),a
 114+ 91B3              ;	ld
 115+ 91B3              ;
 116+ 91B3              ;		.TT43	\ Token > 127 page4 token or planet digram.
 117+ 91B3              ;C9 A0                   CMP #&A0	      \ >= #160 ?
 118+ 91B3              ;B0 14                   BCS TT47	      \ more page4, subtract #160
 119+ 91B3              ;29 7F                   AND #&7F	      \ else token 128to159  -> 0 to 31
 120+ 91B3              ;0A                      ASL A		      \ *= 2
 121+ 91B3              ;A8                      TAY 		      \ digram index = 0to62
 122+ 91B3              ;B9 80 08                LDA &0880,Y \ QQ16,Y  \ ALLEXEGEZACEBISOUSESARMAINDIREA?ER  etc.
 123+ 91B3              ;20 9A 33                JSR &339A   \ TT27    \ process text token
 124+ 91B3              ;B9 81 08                LDA &0881,Y \ QQ16+1,Y \ 2nd character of diagram. Flight copied down from docked code.
 125+ 91B3              ;C9 3F                   CMP #&3F	      \ is second letter '?'
 126+ 91B3              ;F0 40                   BEQ TT48    	      \ rts, name has odd-number of letters.
 127+ 91B3              ;4C 9A 33                JMP &339A   \ TT27    \ process text token
 128+ 91B3              ;
 129+ 91B3              ;	.TT47	\ more page4, subtract #160
 130+ 91B3              ;E9 A0                   SBC #&A0	\ -= 160
 131+ 91B3              ;	.ex	\ -> &342D \ extra, token >= 96 or Acc = 128to145 or -=160
 132+ 91B3              ;AA                      TAX 		\ copy of word index
 133+ 91B3              ;A9 00                   LDA #0		\ page 4 words lo  #QQ18 MOD 256
 134+ 91B3              ;85 22                   STA &22		\ V
 135+ 91B3              ;A9 04                   LDA #4		\ page 4 words hi  #QQ18 DIV 256
 136+ 91B3              ;85 23                   STA &23		\ V+1
 137+ 91B3              ;A0 00                   LDY #0
 138+ 91B3              ;8A                      TXA 		\ token = word index
 139+ 91B3              ;F0 13                   BEQ TT50	\ if X=0 then Y offset to word correct
 140+ 91B3              ;	.TT51	\ counters Y letter, X token
 141+ 91B3              ;B1 22                   LDA (&22),Y	\ (V),Y
 142+ 91B3              ;F0 07                   BEQ TT49	\ exit as word ended
 143+ 91B3              ;C8                      INY 		\ letter count
 144+ 91B3              ;D0 F9                   BNE TT51	\ loop Y
 145+ 91B3              ;E6 23                   INC &23	  \ V+1 \ next page as Y reached 256
 146+ 91B3              ;D0 F5                   BNE TT51    	\ guaranteed, loop Y letter
 147+ 91B3              ;	.TT49	\ word ended
 148+ 91B3              ;C8                      INY
 149+ 91B3              ;D0 02                   BNE TT59    	\ next word
 150+ 91B3              ;E6 23                   INC &23	  \ V+1	\ next page as Y reached 256
 151+ 91B3              ;	.TT59	\ next word
 152+ 91B3              ;CA                      DEX 		\ token count
 153+ 91B3              ;D0 ED                   BNE TT51	\ loop X token
 154+ 91B3              ;	.TT50	\ token X = 0, counter Y offset to word correct
 155+ 91B3              ;98                      TYA
 156+ 91B3              ;48                      PHA 		\ store Yindex
 157+ 91B3              ;A5 23                   LDA &23		\ V+1
 158+ 91B3              ;48                      PHA 		\ correct pointer hi
 159+ 91B3              ;B1 22                   LDA (&22),Y 	\ (V),Y
 160+ 91B3              ;49 23                   EOR #&23	\ decode '#'
 161+ 91B3              ;20 9A 33                JSR &339A \ TT27 \ process text token to next depth
 162+ 91B3              ;68                      PLA 		\ restore this depth's Vhi
 163+ 91B3              ;85 23                   STA &23		\ V+1
 164+ 91B3              ;68                      PLA
 165+ 91B3              ;A8                      TAY 		\ restore this depth's Yindex
 166+ 91B3              ;C8                      INY 		\ next letter
 167+ 91B3              ;D0 02                   BNE P%+4	\ not zero so skip next page
 168+ 91B3              ;E6 23                   INC &23		\ V+1
 169+ 91B3              ;B1 22                   LDA (&22),Y	\ (V),Y
 170+ 91B3              ;D0 E6                   BNE TT50    	\ loop Y for next letter of page4 token
 171+ 91B3              ;	.TT48 	\ rts
 172+ 91B3              ;60                      RTS 		\ end of flight token printing TT27
 173+ 91B3              ;
 174+ 91B3              ;
 175+ 91B3              ;
 176+ 91B3              ;
 177+ 91B3              ;
 178+ 91B3              ;
 179+ 91B3              ;		.TT27	\ -> &36E0 \ process flight text Token in Acc
 180+ 91B3              ;;AA                      TAX		\ copy token to count down
 181+ 91B3              ;;F0 DE                   BEQ csh		\ Acc = 0, up to Cash
 182+ 91B3              ;30 74                   BMI TT43	\ if token is >  127 down, page4 token or digram
 183+ 91B3              ;CA                      DEX
 184+ 91B3              ;F0 BC                   BEQ tal		\ Acc == 1, up, print Galaxy number.
 185+ 91B3              ;CA                      DEX
 186+ 91B3              ;F0 A3                   BEQ ypl		\ Acc == 2, up, present planet in QQ2.
 187+ 91B3              ;CA                      DEX
 188+ 91B3              ;D0 03                   BNE P%+5	\ hop over, else X == 0
 189+ 91B3              ;4C 0A 33                JMP &330A \ cpl \ Acc = 3 print Planet name for seed QQ15
 190+ 91B3              ;CA                      DEX
 191+ 91B3              ;F0 8A                   BEQ cmn		\ Acc == 4, up, commander name.
 192+ 91B3              ;CA                      DEX
 193+ 91B3              ;F0 B5                   BEQ fwl		\ Acc == 5, up, fuel followed by cash.
 194+ 91B3              ;CA                      DEX
 195+ 91B3              ;D0 05                   BNE  P%+7	\ hop over, else X == 0
 196+ 91B3              ;A9 80                   LDA #&80	\ Acc == 6, set bit 7 TT27m
 197+ 91B3              ;85 72                   STA &72	 	\ QQ17
 198+ 91B3              ;60                      RTS
 199+ 91B3              ;CA                      DEX 		\ skip Acc ==7
 200+ 91B3              ;CA                      DEX
 201+ 91B3              ;D0 03                   BNE P%+5	\ hop over to continue Acc 9to127
 202+ 91B3              ;86 72                   STX &72	 \ QQ17	\ else Acc ==8, QQ17 set to X = 0
 203+ 91B3              ;60                      RTS
 204+ 91B3              ;CA                      DEX 		\ continue 9to127 tokens
 205+ 91B3              ;F0 38                   BEQ crlf	\ Acc == 9, down, colon on right.
 206+ 91B3              ;C9 60                   CMP #&60	\ discard X, look at Acc = token >= 96
 207+ 91B3              ;B0 66                   BCS ex   	\ extra >= #&60, far down
 208+ 91B3              ;C9 0E                   CMP #14		\ < 14 ?
 209+ 91B3              ;90 04                   BCC P%+6	\ goes to Token < 14 or > 31
 210+ 91B3              ;C9 20                   CMP #32		\ < 32 ?
 211+ 91B3              ;90 28                   BCC qw   	\ 14 <= token A < 32 becomes 128to145 page4 digram
 212+ 91B3              ;		\ Token  < 14 or > 31
 213+ 91B3              ;A6 72                   LDX &72	 	\ QQ17
 214+ 91B3              ;F0 3D                   BEQ TT74 	\ if QQ17 = 0 Upper case, jmp TT26, print character.
 215+ 91B3              ;30 11                   BMI TT41 	\ if bit7 set
 216+ 91B3              ;24 72                   BIT &72		\ QQ17 has bit6 set too
 217+ 91B3              ;70 30                   BVS TT46 	\ If only bit6 set, clear bit6 and print as Upper
 218+ 91B3              ;	.TT42	\ Uppercase to lowercase
 219+ 91B3              ;C9 41                   CMP #&41	\ < ascii 'A'
 220+ 91B3              ;90 06                   BCC TT44 	\ jmp TT26, print character
 221+ 91B3              ;C9 5B                   CMP #&5B	\ >= ascii 'Z'+1
 222+ 91B3              ;B0 02                   BCS TT44 	\ jmp TT26, print character
 223+ 91B3              ;69 20                   ADC #&20	\ else Upper to lowercase
 224+ 91B3              ;	.TT44	\ print character as is with TT26
 225+ 91B3              ;4C FC 1E                JMP &1EFC \ TT26 \ print character
 226+ 91B3              ;
 227+ 91B3              ;	.TT41	\ QQ17 bit7 set
 228+ 91B3              ;24 72                   BIT &72		\ QQ17
 229+ 91B3              ;70 17                   BVS TT45	\ bit6 set too, Nothing or lower.
 230+ 91B3              ;C9 41                   CMP #&41	\ < ascii 'A'
 231+ 91B3              ;90 22                   BCC TT74 	\ print as is using TT26
 232+ 91B3              ;48                      PHA 		\ else store token Acc
 233+ 91B3              ;8A                      TXA 		\ QQ17 copy
 234+ 91B3              ;09 40                   ORA #&40	\ set bit6 in QQ17 so subsequent ones lower
 235+ 91B3              ;85 72                   STA &72	 	\ QQ17
 236+ 91B3              ;68                      PLA 		\ restore token
 237+ 91B3              ;D0 EC                   BNE TT44	\ guaranteed up, print as Uppercase with TT26.
 238+ 91B3              ;
 239+ 91B3              ;	.qw	\ Acc = 14to31 becomes 128to145 page4 digram
 240+ 91B3              ;69 72                   ADC #&72	\ A+=114 becomes 128to145 page4 digram
 241+ 91B3              ;D0 32                   BNE ex		\ guaranteed down, extra.
 242+ 91B3              ;
 243+ 91B3              ;	.crlf	\ Acc == 9,  colon on right
 244+ 91B3              ;A9 15                   LDA #21		\ on right
 245+ 91B3              ;85 2C                   STA &2C		\ XC
 246+ 91B3              ;D0 97                   BNE TT73	\ guaranteed up, print colon.
 247+ 91B3              ;
 248+ 91B3              ;	.TT45	\ QQ17 bits 7,6 set. Nothing or lower.
 249+ 91B3              ;E0 FF                   CPX #&FF	\ if QQ17 = #&FF
 250+ 91B3              ;F0 63                   BEQ TT48	\ rts
 251+ 91B3              ;C9 41                   CMP #&41	\ >= ascii 'A' ?
 252+ 91B3              ;B0 D0                   BCS TT42	\ Uppercase to lowercase, up.
 253+ 91B3              ;	.TT46	\ clear bit6 QQ17 and print as is using TT26
 254+ 91B3              ;48                      PHA 		\ push token
 255+ 91B3              ;8A                      TXA 		\ QQ17 copy
 256+ 91B3              ;29 BF                   AND #&BF	\ clear bit6
 257+ 91B3              ;85 72                   STA &72	 	\ QQ17
 258+ 91B3              ;68                      PLA 		\ pull token
 259+ 91B3              ;	.TT74	\ TT26, print character.
 260+ 91B3              ;4C FC 1E                JMP &1EFC	\ TT26
 261+ 91B3              ;
 262+ 91B3              ;	.TT43	\ Token > 127 page4 token or planet digram.
 263+ 91B3              ;C9 A0                   CMP #&A0	      \ >= #160 ?
 264+ 91B3              ;B0 14                   BCS TT47	      \ more page4, subtract #160
 265+ 91B3              ;29 7F                   AND #&7F	      \ else token 128to159  -> 0 to 31
 266+ 91B3              ;0A                      ASL A		      \ *= 2
 267+ 91B3              ;A8                      TAY 		      \ digram index = 0to62
 268+ 91B3              ;B9 80 08                LDA &0880,Y \ QQ16,Y  \ ALLEXEGEZACEBISOUSESARMAINDIREA?ER  etc.
 269+ 91B3              ;20 9A 33                JSR &339A   \ TT27    \ process text token
 270+ 91B3              ;B9 81 08                LDA &0881,Y \ QQ16+1,Y \ 2nd character of diagram. Flight copied down from docked code.
 271+ 91B3              ;C9 3F                   CMP #&3F	      \ is second letter '?'
 272+ 91B3              ;F0 40                   BEQ TT48    	      \ rts, name has odd-number of letters.
 273+ 91B3              ;4C 9A 33                JMP &339A   \ TT27    \ process text token
 274+ 91B3              ;
 275+ 91B3              ;	.TT47	\ more page4, subtract #160
 276+ 91B3              ;E9 A0                   SBC #&A0	\ -= 160
 277+ 91B3              ;	.ex	\ -> &342D \ extra, token >= 96 or Acc = 128to145 or -=160
 278+ 91B3              ;AA                      TAX 		\ copy of word index
 279+ 91B3              ;A9 00                   LDA #0		\ page 4 words lo  #QQ18 MOD 256
 280+ 91B3              ;85 22                   STA &22		\ V
 281+ 91B3              ;A9 04                   LDA #4		\ page 4 words hi  #QQ18 DIV 256
 282+ 91B3              ;85 23                   STA &23		\ V+1
 283+ 91B3              ;A0 00                   LDY #0
 284+ 91B3              ;8A                      TXA 		\ token = word index
 285+ 91B3              ;F0 13                   BEQ TT50	\ if X=0 then Y offset to word correct
 286+ 91B3              ;	.TT51	\ counters Y letter, X token
 287+ 91B3              ;B1 22                   LDA (&22),Y	\ (V),Y
 288+ 91B3              ;F0 07                   BEQ TT49	\ exit as word ended
 289+ 91B3              ;C8                      INY 		\ letter count
 290+ 91B3              ;D0 F9                   BNE TT51	\ loop Y
 291+ 91B3              ;E6 23                   INC &23	  \ V+1 \ next page as Y reached 256
 292+ 91B3              ;D0 F5                   BNE TT51    	\ guaranteed, loop Y letter
 293+ 91B3              ;	.TT49	\ word ended
 294+ 91B3              ;C8                      INY
 295+ 91B3              ;D0 02                   BNE TT59    	\ next word
 296+ 91B3              ;E6 23                   INC &23	  \ V+1	\ next page as Y reached 256
 297+ 91B3              ;	.TT59	\ next word
 298+ 91B3              ;CA                      DEX 		\ token count
 299+ 91B3              ;D0 ED                   BNE TT51	\ loop X token
 300+ 91B3              ;	.TT50	\ token X = 0, counter Y offset to word correct
 301+ 91B3              ;98                      TYA
 302+ 91B3              ;48                      PHA 		\ store Yindex
 303+ 91B3              ;A5 23                   LDA &23		\ V+1
 304+ 91B3              ;48                      PHA 		\ correct pointer hi
 305+ 91B3              ;B1 22                   LDA (&22),Y 	\ (V),Y
 306+ 91B3              ;49 23                   EOR #&23	\ decode '#'
 307+ 91B3              ;20 9A 33                JSR &339A \ TT27 \ process text token to next depth
 308+ 91B3              ;68                      PLA 		\ restore this depth's Vhi
 309+ 91B3              ;85 23                   STA &23		\ V+1
 310+ 91B3              ;68                      PLA
 311+ 91B3              ;A8                      TAY 		\ restore this depth's Yindex
 312+ 91B3              ;C8                      INY 		\ next letter
 313+ 91B3              ;D0 02                   BNE P%+4	\ not zero so skip next page
 314+ 91B3              ;E6 23                   INC &23		\ V+1
 315+ 91B3              ;B1 22                   LDA (&22),Y	\ (V),Y
 316+ 91B3              ;D0 E6                   BNE TT50    	\ loop Y for next letter of page4 token
 317+ 91B3              ;	.TT48 	\ rts
 318+ 91B3              ;60                      RTS 		\ end of flight token printing TT27
 319+ 91B3              ;
 320+ 91B3              ;
 321+ 91B3              ;
# file closed: ../Tables/name_digrams.asm
 113  91B3                  INCLUDE "../Maths/addhldesigned.asm"
# file opened: ../Maths/addhldesigned.asm
   1+ 91B3 CB 7C        addhldesigned:          bit     7,h
   2+ 91B5 20 03                                jr      nz,.noneghl
   3+ 91B7 CD BA 98                             call    negate16hl
   4+ 91BA CB 7A        .noneghl:               bit     7,d
   5+ 91BC 20 03                                jr      nz,.nonegde
   6+ 91BE CD C1 98                             call    negate16de
   7+ 91C1 19           .nonegde:               add     hl,de                       ; do 2'd c add
   8+ 91C2 AF                                   xor     a                           ; assume positive
   9+ 91C3 CB 7C                                bit     7,h
  10+ 91C5 C8                                   ret     z                           ; if not set then can exit early
  11+ 91C6 CD BA 98                             call    negate16hl
  12+ 91C9 3E FF                                ld      a,$FF
  13+ 91CB C9                                   ret
  14+ 91CC
# file closed: ../Maths/addhldesigned.asm
 114  91CC                  INCLUDE "../Maths/asm_add.asm"
# file opened: ../Maths/asm_add.asm
   1+ 91CC
   2+ 91CC              ; HL(2sc) = HL (signed) + A (unsigned), uses HL, DE, A
   3+ 91CC 16 00        HL2cEquHLSgnPlusAusgn:  ld      d,0
   4+ 91CE 5F                                   ld      e,a                         ; set up DE = A
   5+ 91CF 7C                                   ld      a,h
   6+ 91D0 E6 7F                                and     SignMask8Bit
   7+ 91D2 28 07                                jr      z,.HLPositive               ; if HL is negative then do HL - A
   8+ 91D4 67           .HLNegative:            ld      h,a                         ; hl = ABS (HL)
   9+ 91D5                                      NegHL                               ; hl = - hl
   9+ 91D5 AF          >                    xor a
   9+ 91D6 95          >                    sub l
   9+ 91D7 6F          >                    ld l,a
   9+ 91D8 9F          >                    sbc a,a
   9+ 91D9 94          >                    sub h
   9+ 91DA 67          >                    ld h,a
  10+ 91DB              .HLPositive:            ClearCarryFlag                      ; now do adc hl,de
  10+ 91DB B7          >                        or a
  11+ 91DC ED 5A                                adc     hl,de                       ; aftert his hl will be 2's c
  12+ 91DE C9                                   ret
  13+ 91DF
  14+ 91DF 5F           HLEquHLSgnPlusAusgn:    ld      e,a
  15+ 91E0 7C                                   ld      a,h
  16+ 91E1 E6 7F                                and     SignMask8Bit
  17+ 91E3 20 04                                jr      nz,.HLNegative              ; if HL is negative then do HL - A
  18+ 91E5 7B           .HLPositive:            ld      a,e                         ; else its HL + A
  19+ 91E6 ED 31                                add     hl,a
  20+ 91E8 C9                                   ret
  21+ 91E9              .HLNegative:            ClearSignBit    h                   ; Clear sign of HL
  21+ 91E9 7C          >                        ld      a,h
  21+ 91EA E6 7F       >                        and     SignMask8Bit
  21+ 91EC 67          >                        ld      h,a
  22+ 91ED                                      NegHL                               ; and convert to 2's C
  22+ 91ED AF          >                    xor a
  22+ 91EE 95          >                    sub l
  22+ 91EF 6F          >                    ld l,a
  22+ 91F0 9F          >                    sbc a,a
  22+ 91F1 94          >                    sub h
  22+ 91F2 67          >                    ld h,a
  23+ 91F3 16 00                                ld      d,0
  24+ 91F5                                      ClearCarryFlag
  24+ 91F5 B7          >                        or a
  25+ 91F6 ED 52                                sbc     hl,de                       ; now add a to -ve HL , add does not do 2's c
  26+ 91F8 FA 00 92                             jp      m,.FlipResult               ; if it was negative then its really positive
  27+ 91FB                                      SetSignBit      h
  27+ 91FB 7C          >                        ld      a,h
  27+ 91FC F6 80       >                        or      SignOnly8Bit
  27+ 91FE 67          >                        ld      h,a
  28+ 91FF C9                                   ret
  29+ 9200              .FlipResult:            NegHL                               ; so if -hl + A => HL - A => HL - DE is negative then the actual result is +ve
  29+ 9200 AF          >                    xor a
  29+ 9201 95          >                    sub l
  29+ 9202 6F          >                    ld l,a
  29+ 9203 9F          >                    sbc a,a
  29+ 9204 94          >                    sub h
  29+ 9205 67          >                    ld h,a
  30+ 9206 C9                                   ret
  31+ 9207
  32+ 9207
  33+ 9207
  34+ 9207              ; HL = HL (signed) + A (unsigned), uses HL, DE, A
  35+ 9207 57           AddAusngToHLsng:        ld      d,a
  36+ 9208 5C                                   ld      e,h
  37+ 9209 7C                                   ld      a,h
  38+ 920A E6 7F                                and     SignMask8Bit
  39+ 920C 67                                   ld      h,a
  40+ 920D 7A                                   ld      a,d
  41+ 920E ED 31                                add     hl,a
  42+ 9210 7B                                   ld      a,e
  43+ 9211 E6 80                                and     SignOnly8Bit
  44+ 9213 B4                                   or      h
  45+ 9214 C9                                   ret
  46+ 9215              ; HL = A (unsigned) - HL (signed), uses HL, DE, BC, A
  47+ 9215 44           HLEequAusngMinusHLsng:  ld      b,h
  48+ 9216 4F                                   ld      c,a
  49+ 9217 78                                   ld      a,b
  50+ 9218 E6 80                                and     SignOnly8Bit
  51+ 921A 20 08                                jr      nz,.DoAdd
  52+ 921C EB           .DoSubtract:            ex      de,hl               ; move hl into de
  53+ 921D 26 00                                ld      h,0                 ; hl = a
  54+ 921F 69                                   ld      l,c
  55+ 9220                                      ClearCarryFlag
  55+ 9220 B7          >                        or a
  56+ 9221 ED 52                                sbc     hl,de               ; hl = a - hl
  57+ 9223 C9                                   ret
  58+ 9224 79           .DoAdd:                 ld      a,c
  59+ 9225 ED 31                                add hl,a
  60+ 9227 C9                                   ret
  61+ 9228              ;tested mathstestsun2
  62+ 9228              ; DEL = DEL + BCH signed, uses BC, DE, HL, IY, A
  63+ 9228 78           AddBCHtoDELsigned:      ld      a,b                 ; Are the values both the same sign?
  64+ 9229 AA                                   xor     d                   ; .
  65+ 922A E6 80                                and     SignOnly8Bit        ; .
  66+ 922C 20 19                                jr      nz,.SignDifferent   ; .
  67+ 922E 78           .SignSame:              ld      a,b                 ; if they are then we only need 1 signe
  68+ 922F E6 80                                and     SignOnly8Bit        ; so store it in iyh
  69+ 9231 FD 67                                ld      iyh,a               ;
  70+ 9233 78                                   ld      a,b                 ; bch = abs bch
  71+ 9234 E6 7F                                and     SignMask8Bit        ; .
  72+ 9236 47                                   ld      b,a                 ; .
  73+ 9237 7A                                   ld      a,d                 ; del = abs del
  74+ 9238 E6 7F                                and     SignMask8Bit        ; .
  75+ 923A 57                                   ld      d,a                 ; .
  76+ 923B 7C                                   ld      a,h                 ; l = h + l
  77+ 923C 85                                   add     l                   ; .
  78+ 923D 6F                                   ld      l,a                 ; .
  79+ 923E 79                                   ld      a,c                 ; e = e + c + carry
  80+ 923F 8B                                   adc     e                   ; .
  81+ 9240 5F                                   ld      e,a                 ; .
  82+ 9241 78                                   ld      a,b                 ; d = b + d + carry (signed)
  83+ 9242 8A                                   adc     d                   ;
  84+ 9243 FD B4                                or      iyh                 ; d = or back in sign bit
  85+ 9245 57                                   ld      d,a                 ;
  86+ 9246 C9                                   ret                         ; done
  87+ 9247 78           .SignDifferent:         ld      a,b                 ; bch = abs bch
  88+ 9248 FD 67                                ld      iyh,a               ; iyh = b sign
  89+ 924A E6 7F                                and     SignMask8Bit        ; .
  90+ 924C 47                                   ld      b,a                 ; .
  91+ 924D 7A                                   ld      a,d                 ; del = abs del
  92+ 924E FD 6F                                ld      iyl,a               ; iyl = d sign
  93+ 9250 E6 7F                                and     SignMask8Bit        ; .
  94+ 9252 57                                   ld      d,a                 ; .
  95+ 9253 E5                                   push    hl                  ; hl = bc - de
  96+ 9254 60 69                                ld      hl,bc               ; if bc < de then there is a carry
  97+ 9256 ED 52                                sbc     hl,de               ;
  98+ 9258 E1                                   pop     hl                  ;
  99+ 9259 38 0E                                jr      c,.BCHltDEL
 100+ 925B 20 1C                                jr      nz,.DELltBCH        ; if the result was not zero then DEL > BCH
 101+ 925D 7C           .BCeqDE:                ld      a,h                 ; if the result was zero then check lowest bits
 102+ 925E                                      JumpIfALTNusng l,.BCHltDEL
 102+ 925E BD          >                        cp      l
 102+ 925F DA 69 92    >                        jp		c, .BCHltDEL
 103+ 9262 20 15                                jr      nz,.DELltBCH
 104+ 9264              ; The same so its just zero
 105+ 9264 AF           .BCHeqDEL:              xor     a                  ; its just zero
 106+ 9265 57                                   ld      d,a                ; .
 107+ 9266 5F                                   ld      e,a                ; .
 108+ 9267 6F                                   ld      l,a                ; .
 109+ 9268 C9                                   ret                        ; .
 110+ 9269              ;BCH is less than DEL so its DEL - BCH the sort out sign
 111+ 9269 7D           .BCHltDEL:              ld      a,l                ; l = l - h                      ; ex
 112+ 926A 94                                   sub     h                  ; .                              ;   01D70F DEL
 113+ 926B 6F                                   ld      l,a                ; .                              ;  -000028 BCH
 114+ 926C 7B                                   ld      a,e                ; e = e - c - carry              ;1.
 115+ 926D 99                                   sbc     c                  ; .                              ;
 116+ 926E 5F                                   ld      e,a                ; .                              ;
 117+ 926F 7A                                   ld      a,d                ; d = d - b - carry              ;
 118+ 9270 98                                   sbc     b                  ; .                              ;
 119+ 9271 57                                   ld      d,a                ; .                              ;
 120+ 9272 FD 7D                                ld      a,iyl              ; as d was larger, take d sign
 121+ 9274 E6 80                                and     SignOnly8Bit       ;
 122+ 9276 B2                                   or      d                  ;
 123+ 9277 57                                   ld      d,a                ;
 124+ 9278 C9                                   ret
 125+ 9279 7C           .DELltBCH:              ld      a,h                ; l = h - l
 126+ 927A 95                                   sub     l                  ;
 127+ 927B 6F                                   ld      l,a                ;
 128+ 927C 79                                   ld      a,c                ; e = c - e - carry
 129+ 927D 9B                                   sbc     e                  ;
 130+ 927E 5F                                   ld      e,a                ;
 131+ 927F 78                                   ld      a,b                ; d = b - d - carry
 132+ 9280 9A                                   sbc     d                  ;
 133+ 9281 57                                   ld      d,a                ;
 134+ 9282 FD 7C                                ld      a,iyh              ; as b was larger, take b sign into d
 135+ 9284 E6 80                                and     SignOnly8Bit       ;
 136+ 9286 B2                                   or      d                  ;
 137+ 9287 57                                   ld      d,a                ;
 138+ 9288 C9                                   ret
 139+ 9289
 140+ 9289
 141+ 9289              ;BHL = AHL + DE where AHL = 16 bit + A sign and DE = 15 bit signed
 142+ 9289 47           AddAHLtoDEsigned:       ld      b,a                     ; B = A , C = D (save sign bytes)
 143+ 928A 4A                                   ld      c,d                     ; .
 144+ 928B A9                                   xor     c                       ; A = A xor C
 145+ 928C CB BA                                res     7,d                     ; clear sign bit of D
 146+ 928E 20 02                                jr nz,  .OppositeSigns          ; if A xor C is opposite signs job to A0A1
 147+ 9290 19                                   add     hl,de                   ; HL = HL + DE
 148+ 9291 C9                                   ret                             ; return
 149+ 9292 ED 52        .OppositeSigns:         sbc     hl,de                   ; HL = HL -DE
 150+ 9294 D0                                   ret     nc                      ; if no carry return
 151+ 9295 19                                   add     hl,de                   ; else HL = HL + DE
 152+ 9296 EB                                   ex      de,hl                   ;      swap HL and DE
 153+ 9297 A7                                   and     a                       ;      reset carry
 154+ 9298 ED 52                                sbc     hl,de                   ;      HL = DE - HL (as they were swapped)
 155+ 929A 41                                   ld      b,c                     ;      B = sign of C
 156+ 929B C9                                   ret                             ;      ret
 157+ 929C
 158+ 929C
 159+ 929C
 160+ 929C              ; a = value to add
 161+ 929C              ; b = offset (equivalent to regX)
 162+ 929C              ; returns INWK [x] set to new value
 163+ 929C              addINWKbasigned:
asm_add.asm(164): error: Label not found: UBnKxlo
 164+ 929C 21 00 00     		ld 		hl,UBnKxlo                  ; hl = INWK 0
 165+ 929F 4F           		ld      c,a                         ; preserve a
 166+ 92A0 78           		ld		a,b
 167+ 92A1 ED 31        		add		hl,a                        ; hl = INWK[x]
 168+ 92A3 79                   ld      a,c                         ; get back a value
 169+ 92A4 E6 80                and     $80                         ; get sign bit from a
 170+ 92A6 47                   ld      b,a                         ; now b = sign bit of a
 171+ 92A7 79                   ld      a,c                         ; a = original value
 172+ 92A8 E6 7F                and     SignMask8Bit                ; a = unsigned version of original value
 173+ 92AA              ; hl = unsigned version of INWK0[b]
 174+ 92AA              ; a = value to add, also in c which will optimise later code
 175+ 92AA              ; b = sign bit of a ( in old code was varT)
 176+ 92AA              addhlcsigned:
 177+ 92AA 5E                   ld      e,(hl)                      ; de = INKK value
 178+ 92AB 23                   inc     hl
 179+ 92AC 56                   ld      d,(hl)
 180+ 92AD 23                   inc     hl                          ; now pointing a sign
 181+ 92AE 7E                   ld      a,(hl)                      ; a = sign bit
 182+ 92AF EB                   ex      de,hl                       ; hl = value now and de = pointer to sign
 183+ 92B0 A8                   xor     b                           ; a = resultant sign
 184+ 92B1 CB 7F                bit     7,a                         ; is it negative?
 185+ 92B3 28 28                jr      z,.postivecalc
 186+ 92B5              .negativecalc:
 187+ 92B5 7C                   ld      a,h
 188+ 92B6 E6 7F                and     SignMask8Bit
 189+ 92B8 67                   ld      h,a                         ; strip high bit
 190+ 92B9 DD 68                ld      ixl,b                       ; save sign bit from b into d
 191+ 92BB 06 00                ld      b,0                         ; c = value to subtract so now bc = value to subtract
 192+ 92BD ED 42                sbc     hl,bc
 193+ 92BF DD 45                ld      b,ixl                       ; get sign back
 194+ 92C1 EB                   ex      de,hl                       ; de = value hl = pointer to sign
 195+ 92C2 7E                   ld      a,(hl)                      ;
 196+ 92C3 E6 7F                and     SignMask8Bit
 197+ 92C5 DE 00                sbc     a,0                         ; subtract carry which could flip sign bit
 198+ 92C7 F6 80                or      $80                         ; set bit 0
 199+ 92C9 A8                   xor     b                           ; flip bit on sign (var T)
 200+ 92CA 77                   ld      (hl),a
 201+ 92CB 2B                   dec     hl
 202+ 92CC 72                   ld      (hl),d
 203+ 92CD 2B                   dec     hl
 204+ 92CE 73                   ld      (hl),e                      ; write out DE to INKW[x]0,1
 205+ 92CF EB                   ex      de,hl                       ; hl = value de = pointer to start if INKW[x]
 206+ 92D0 D8                   ret     c                           ; if carry was set then we can exit now
 207+ 92D1              .nocarry:
 208+ 92D1 CD BA 98             call    negate16hl                  ; get hl back to positive, a is still inkw+2
 209+ 92D4 B0                   or      b                           ; b is still varT
 210+ 92D5 EB                   ex      de,hl                       ; de = value hl = pointer to start if INKW[x]
 211+ 92D6 73                   ld      (hl),e
 212+ 92D7 23                   inc     hl
 213+ 92D8 72                   ld      (hl),d
 214+ 92D9 23                   inc     hl
 215+ 92DA 77                   ld      (hl),a                      ; set sign bit in INKK[x]+2
 216+ 92DB EB                   ex      de,hl                       ; hl = value de = pointer to sign
 217+ 92DC C9                   ret
 218+ 92DD              .postivecalc:
 219+ 92DD DD 68                ld      ixl,b
 220+ 92DF 06 00                ld      b,0
 221+ 92E1 19                   add     hl,de
 222+ 92E2 EB                   ex      de,hl
 223+ 92E3 DD B5                or      ixl                         ; we don;t need to recover b here
 224+ 92E5 77                   ld      (hl),a                      ; push sign into INWK[x]
 225+ 92E6 2B                   dec     hl
 226+ 92E7 72                   ld      (hl),d
 227+ 92E8 2B                   dec     hl
 228+ 92E9 73                   ld      (hl),e
 229+ 92EA C9                   ret
 230+ 92EB
 231+ 92EB              ;a = a AND 80 (i.e. bit 7) =>carry       so value is -
 232+ 92EB              ;MVT1
 233+ 92EB              ;    S = bits 6 to 0 of A
 234+ 92EB              ;    A = sign bit => T
 235+ 92EB              ;    xor sign bit with ink[x] Sign
 236+ 92EB              ;    if negative thn its not an add
 237+ 92EB              ;
 238+ 92EB              ;        and h, 7F
 239+ 92EB              ;        b = 0
 240+ 92EB              ;        c = varS
 241+ 92EB              ;        subtract INW[X]hilo, bc
 242+ 92EB              ;        retain carry
 243+ 92EB              ;        get INKW[x]Sign
 244+ 92EB              ;        and 7F
 245+ 92EB              ;        subtract carry (so will go negtive if negative)
 246+ 92EB              ;        xor bit 7 of h with T to flip bit
 247+ 92EB              ;        write to INKW[x]Sign
 248+ 92EB              ;
 249+ 92EB              ;    else
 250+ 92EB              ;MV10.
 251+ 92EB              ;        add INWK[x]hi,lo, varS
 252+ 92EB              ;        or      sign bit
 253+ 92EB
 254+ 92EB
# file closed: ../Maths/asm_add.asm
 115  92EB                  INCLUDE "../Maths/Utilities/AddDEToCash.asm"
# file opened: ../Maths/Utilities/AddDEToCash.asm
   1+ 92EB              ; Note its big endian
   2+ 92EB 2A E3 88     addDEtoCash:            ld      hl,(Cash)
   3+ 92EE 19                                   add     hl,de
   4+ 92EF 22 E3 88                             ld      (Cash),hl
   5+ 92F2 11 00 00                             ld      de,0
   6+ 92F5 2A E5 88                             ld      hl,(Cash+2)
   7+ 92F8 ED 5A                                adc     hl,de
   8+ 92FA 22 E5 88                             ld      (Cash+2),hl
   9+ 92FD C9                                   ret
  10+ 92FE
  11+ 92FE 2A E3 88     subDEfromCash:          ld      hl,(Cash)
  12+ 9301 7C                                   ld      a,h
  13+ 9302 B5                                   or      l
  14+ 9303 2A E5 88                             ld      hl,(Cash+2)
  15+ 9306 B4                                   or      h
  16+ 9307 B5                                   or      l
  17+ 9308 C8                                   ret     z               ; No cash return
  18+ 9309 B7                                   or      a
  19+ 930A 2A E3 88                             ld      hl,(Cash)
  20+ 930D ED 52                                sbc     hl,de
  21+ 930F 22 E3 88                             ld      (Cash),hl
  22+ 9312 11 00 00                             ld      de,0
  23+ 9315 2A E5 88                             ld      hl,(Cash+2)
  24+ 9318 ED 52                                sbc     hl,de
  25+ 931A 22 E5 88                             ld      (Cash+2),hl
  26+ 931D                                      JumpOnBitSet h,7,.ZeroCash
  26+ 931D CB 7C       >                        bit 	7,h
  26+ 931F C2 23 93    >                        jp      nz,.ZeroCash
  27+ 9322 C9                                   ret
  28+ 9323 21 00 00     .ZeroCash:              ld      hl,0
  29+ 9326 22 E3 88                             ld      (Cash),hl
  30+ 9329 22 E5 88                             ld      (Cash+2),hl
  31+ 932C C9                                   ret
  32+ 932D
# file closed: ../Maths/Utilities/AddDEToCash.asm
 116  932D                  INCLUDE "../Maths/DIVD3B2.asm"
# file opened: ../Maths/DIVD3B2.asm
   1+ 932D              ;INPUTS: ahl = dividend cde = divisor
   2+ 932D              ;OUTPUTS: cde = quotient ahl = remainder
   3+ 932D 47           Div24by24:              ld b,a
   4+ 932E E5                                   push hl
   5+ 932F DD E1                                pop ix
   6+ 9331 2E 18                                ld l,24
   7+ 9333 E5                                   push hl
   8+ 9334 AF                                   xor a
   9+ 9335 67                                   ld h,a
  10+ 9336 6F                                   ld l,a
  11+ 9337 DD 29        .Div24by24loop:         add ix,ix
  12+ 9339 CB 10                                rl b
  13+ 933B ED 6A                                adc hl,hl
  14+ 933D 17                                   rla
  15+ 933E B9                                   cp c
  16+ 933F 38 0C                                jr c,.Div24by24skip
  17+ 9341 20 05                                jr nz,.Div24by24setbit
  18+ 9343 ED 52                                sbc hl,de
  19+ 9345 19                                   add hl,de
  20+ 9346 38 05                                jr c,.Div24by24skip
  21+ 9348 ED 52        .Div24by24setbit:       sbc hl,de
  22+ 934A 99                                   sbc a,c
  23+ 934B DD 23                                inc ix
  24+ 934D E3           .Div24by24skip:         ex (sp),hl
  25+ 934E 2D                                   dec l
  26+ 934F E3                                   ex (sp),hl
  27+ 9350 20 E5                                jr nz,.Div24by24loop
  28+ 9352 D1                                   pop de
  29+ 9353 48                                   ld c,b
  30+ 9354 DD E5                                push ix
  31+ 9356 D1                                   pop de
  32+ 9357 C9                                   ret
  33+ 9358
  34+ 9358 FD 67        Div24by24ASigned:       ld      iyh,a
  35+ 935A E6 7F                                and     SignMask8Bit
  36+ 935C CD 2D 93                             call    Div24by24
  37+ 935F F5                                   push    af
  38+ 9360 FD 7C                                ld      a,iyh
  39+ 9362 E6 80                                and     SignOnly8Bit
  40+ 9364 B1                                   or      c
  41+ 9365 4F                                   ld      c,a
  42+ 9366 F1                                   pop     af
  43+ 9367 C9                                   ret
  44+ 9368
  45+ 9368                                      ; CDE = AHL/CDE, AHL = remainder
  46+ 9368 FD 67        Div24by24LeadSign:      ld      iyh,a           ; Preserve signed in IYL
  47+ 936A A9                                   xor     c               ; flip sign if negative
  48+ 936B E6 80                                and     SignOnly8Bit    ; .
  49+ 936D FD 6F                                ld      iyl,a           ; .
  50+ 936F 79                                   ld      a,c             ; make both values ABS
  51+ 9370 E6 7F                                and     SignMask8Bit    ; .
  52+ 9372 4F                                   ld      c,a             ; .
  53+ 9373 FD 7C                                ld      a,iyh           ; .
  54+ 9375 E6 7F                                and     SignMask8Bit    ; .
  55+ 9377 CD 2D 93                             call    Div24by24       ; do abs divide
  56+ 937A FD B5                                or      iyl             ; bring in sign bit
  57+ 937C FD 67                                ld      iyh,a           ; save a
  58+ 937E 79                                   ld      a,c             ; sort sign for c
  59+ 937F FD B5                                or      iyl             ;
  60+ 9381 4F                                   ld      c,a             ;
  61+ 9382 FD 7C                                ld      a,iyh           ; sort sign of a
  62+ 9384 C9                                   ret
  63+ 9385
  64+ 9385              ; --------------------------------------------------------------
  65+ 9385              ;divdide by 16 using undocumented instrunctions
  66+ 9385              ;Input: BC = Dividend, DE = Divisor, HL = 0
  67+ 9385              ;Output: BC = Quotient, HL = Remainder
  68+ 9385 47           PROJ256mulAdivQ:        ld      b,a
  69+ 9386 0E 00                                ld      c,0
  70+ 9388 16 00                                ld      d,0
  71+ 938A 3A 0D 84                             ld      a,(varQ)
  72+ 938D 5F                                   ld      e,a
  73+ 938E 21 00 00     PROJDIV16UNDOC:         ld      hl,0
  74+ 9391 78                                   ld      a,b
  75+ 9392 06 10                                ld      b,16
  76+ 9394 CB 31        PROJDIV16UNDOCLOOP:     sll     c       ; unroll 16 times
  77+ 9396 17                                   rla             ; ...
  78+ 9397 ED 6A                                adc     hl,hl       ; ...
  79+ 9399 ED 52                                sbc     hl,de       ; ...
  80+ 939B 30 02                                jr      nc,PROJDIV16UNDOCSKIP       ; ...
  81+ 939D 19                                   add     hl,de       ; ...
  82+ 939E 0D                                   dec     c       ; ...
  83+ 939F 10 F3        PROJDIV16UNDOCSKIP:     djnz    PROJDIV16UNDOCLOOP
  84+ 93A1 79                                   ld      a,c
  85+ 93A2 32 0E 84                             ld      (varR),a
  86+ 93A5 C9                                   ret
  87+ 93A6
  88+ 93A6              ;INPUTS:    bhl = dividend  cde = divisor where b and c are sign bytes
  89+ 93A6              ;OUTPUTS:   cahl = quotient cde = divisor
  90+ 93A6 32 0C 83     DVID3B2:                ld      (varPhi2),a                     ;DVID3B2 \ Divide 3 bytes by 2, K = [P(HiLo).A]/[INWK_z HiLo], for planet radius, Xreg protected. ; P+2    \ num sg
  91+ 93A9                                      ldCopy2Byte UBnKzlo, varQ               ; [QR} = Ubnk zlohi  (i.e. Inwk_z HiLo)
ldCopyMacros.asm(72): error: Label not found: UBnKzlo
DIVD3B2.asm(91): ^ emitted from here
ldCopyMacros.asm(72): warning[rdlow]: Reading memory at low address: 0
DIVD3B2.asm(91): ^ emitted from here
  91+ 93A9 2A 00 00    >                        ld       hl,(UBnKzlo)
  91+ 93AC 22 0D 84    >                        ld       (varQ),hl
DIVD3B2.asm(92): error: Label not found: UBnKzsgn
DIVD3B2.asm(92): warning[rdlow]: Reading memory at low address: 0
  92+ 93AF 3A 00 00                             ld      a,(UBnKzsgn)                    ;
  93+ 93B2 32 0F 84                             ld      (varS),a                        ; S = inkw z sign
  94+ 93B5 ED 5B 0A 83  DVID3B:                 ld      de,(varP)                       ; K (3bytes)=P(Lo Hi Hi2)/S.R.Q approx  Acc equiv K(0).; get P and P+1 into de
  95+ 93B9 7B                                   ld      a,e                             ; num lo
  96+ 93BA F6 01                                or      1                               ; must be at least 1
  97+ 93BC 32 0A 83                             ld      (varP),a                        ; store
  98+ 93BF 5F                                   ld      e,a                             ; update DE too
  99+ 93C0 3A 0C 83                             ld      a,(varPhi2)                     ; varP Sign     E.D.A = P Lo Hi Hi2
 100+ 93C3 21 0F 84                             ld      hl,varS                         ; hl = address of VarS
 101+ 93C6 AE                                   xor     (hl)                            ; A = PHi2 Xor S Signs
 102+ 93C7 E6 80                                and     $80                             ;
 103+ 93C9 32 29 84                             ld      (varT),a                        ; T = Sign bit of A
 104+ 93CC FD 2E 00                             ld      iyl,0                           ; iyl = yReg = counter
 105+ 93CF 3A 0C 83                             ld      a,(varPhi2)                     ;
 106+ 93D2 E6 7F                                and     $7F                             ; A = Ph2 again but minus sign bit
 107+ 93D4              DVL9:                   JumpIfAGTENusng $40,DV14                ; counter Y up; if object is over $40 away then scaled and exit Y count
 107+ 93D4 FE 40       >                        cp     $40
 107+ 93D6 D2 E4 93    >                        jp		nc,DV14
 108+ 93D9                                      ShiftDELeft1                            ; de (or P,P1) > 1
 108+ 93D9 CB 23       >			   sla e
 108+ 93DB CB 12       >			   rl  d
 109+ 93DD CB 17                                rl      a                               ; and accumulator as 3rd byte
 110+ 93DF FD 2C                                inc     iyl
 111+ 93E1 C2 D4 93                             jp      nz,DVL9                         ; loop again with a max of 256 iterations
 112+ 93E4 32 0C 83     DV14:                   ld      (varPhi2),a                     ; scaled, exited Ycount
 113+ 93E7 ED 53 0A 83                          ld      (varP),de                       ; store off the value so far
 114+ 93EB 3A 0F 84                             ld      a,(varS)                        ; zsign
 115+ 93EE E6 7F                                and     $7F                             ; denom sg7
 116+ 93F0                                      ; jp mi,DV9                             ; this can never happen as bit 7 is and'ed out
 117+ 93F0 2A 0D 84                             ld      hl,(varQ)                       ; demon lo
 118+ 93F3 FD 2D        DVL6:                   dec     iyl                             ; counter Y back down, roll S. ;  scale Y back
 119+ 93F5                                      ShiftHLLeft1
 119+ 93F5 CB 25       >			   sla l
 119+ 93F7 CB 14       >			   rl  h
 120+ 93F9 CB 17                                rl      a                               ; mulitply QRS by 2
 121+ 93FB F2 F3 93                             jp      p,DVL6                          ; loop roll S until Abit7 set.
 122+ 93FE 22 0D 84     DV9:                    ld      (varQ),hl                       ; bmi cant enter here from above ; save off so far
 123+ 9401 32 0D 84                             ld      (varQ),a                        ; Q \ mostly empty so now reuse as hi denom
 124+ 9404 3E FE                                ld      a,$FE                           ;  Xreg protected so can't LL28+4
 125+ 9406 32 0E 84                             ld      (varR),a                        ;  R
 126+ 9409 3A 0C 83                             ld      a,(varPhi2)                     ; P+2 \ big numerator
 127+ 940C CD 85 93                             call    PROJ256mulAdivQ                 ; TODO LL31\ R now =A*256/Q
 128+ 940F 3E 00                                ld      a,0
 129+ 9411 32 21 84                             ld      (varKp1),a
 130+ 9414 32 22 84                             ld      (varKp2),a
 131+ 9417 32 23 84                             ld      (varKp3),a                      ; clear out K+1 to K+3
 132+ 941A FD 7D                                ld      a,iyl                           ; Y counter for scale
 133+ 941C                                      JumpOnBitClear a,7,DV12                 ; Ycount +ve
 133+ 941C CB 7F       >                        bit 	7,a
 133+ 941E CA 49 94    >                        jp      z,DV12
 134+ 9421 3A 0E 84                             ld      a,(varR)                        ; R     \ else Y count is -ve, Acc = remainder.
 135+ 9424 ED 5B 20 84                          ld      de,(varK)                       ; d= k1
 136+ 9428 2A 24 84                             ld      hl,(varK2)                      ; h = k3, l = k2
 137+ 942B 5F                                   ld      e,a                             ; use e to hold K0 pulled from a
 138+ 942C CB 27        DVL8:                   sla     a                               ; boost up a                     ;  counter Y up
 139+ 942E CB 12                                rl      d                               ; k1
 140+ 9430 CB 15                                rl      l                               ; k2
 141+ 9432 CB 14                                rl      h                               ; k3
 142+ 9434 FD 2C                                inc     iyl
 143+ 9436 20 F4                                jr      nz,DVL8                         ;
 144+ 9438 ED 53 20 84  DVL8Save:               ld      (varK),de
 145+ 943C 22 24 84                             ld      (varK2),hl                      ; save back K0 to k3
 146+ 943F 3A 29 84                             ld      a,(varT)
 147+ 9442 4F                                   ld      c,a                             ; get varT into c reg
 148+ 9443 7C                                   ld      a,h                             ; a= k3 (sign)
 149+ 9444 B1                                   or      c                               ; merge in varT (sign)that was saved much earlier up)
 150+ 9445 32 33 84                             ld      (varK3),a                       ; load sign bit back into K3
 151+ 9448 C9                                   ret
 152+ 9449              DV12:                   JumpIfAIsZero   DV13                    ; Y Count zerp, go to DV13
 152+ 9449 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 152+ 944A CA 61 94    >                        jp	z, DV13
 153+ 944D 3A 0E 84                             ld      a,(varR)                        ; Reduce Remainder
 154+ 9450 CB 3F        DVL10:                  srl     a                               ; divide by 2                     ; counter Y reduce
 155+ 9452 FD 2D                                dec     iyl
 156+ 9454 C2 50 94                             jp      nz,DVL10                        ; loop y reduce until y is zero
 157+ 9457 32 20 84                             ld      (varK),a                        ; k Lo
 158+ 945A                                      ldCopyByte  varT,varKp3                 ; Copy sign to K+3
 158+ 945A 3A 29 84    >                        ld       a,(varT)
 158+ 945D 32 23 84    >                        ld       (varKp3),a
 159+ 9460 C9                                   ret
 160+ 9461              DV13:                   ldCopyByte  varR,varK                   ; R \ already correct so copy to K lo;DV13   \ Ycount zero \ K(1to2) already = 0
 160+ 9461 3A 0E 84    >                        ld       a,(varR)
 160+ 9464 32 20 84    >                        ld       (varK),a
 161+ 9467                                      ldCopyByte  varT,varKp3                 ; Copy sign to K+3
 161+ 9467 3A 29 84    >                        ld       a,(varT)
 161+ 946A 32 23 84    >                        ld       (varKp3),a
 162+ 946D C9                                   ret
 163+ 946E
 164+ 946E
 165+ 946E CD A6 93     PLS6:                   call    DVID3B2                         ; Returns AHL K ( 2 1 0 )
 166+ 9471 3A 23 84                             ld      a,(varKp3)
 167+ 9474 E6 7F                                and     $7F
 168+ 9476 21 22 84                             ld      hl,varKp2
 169+ 9479 B6                                   or      (hl)
 170+ 947A C2 8F 94                             jp      nz,PL44TooBig
 171+ 947D 3A 21 84                             ld      a,(varKp1)
 172+ 9480 FE 04                                cp      4                               ; if high byte > 4 then total > 1024 so too big
 173+ 9482 30 0B                                jr      nc,PL44TooBig
 174+ 9484                                      ClearCarryFlag                          ; we have a good result regardless
 174+ 9484 B7          >                        or a
 175+ 9485 2A 20 84                             ld      hl,(varK)                       ; get K (0 1)
 176+ 9488 3A 23 84                             ld      a,(varKp3)                      ; if sign bit high?
 177+ 948B CB 7F                                bit     7,a
 178+ 948D C8                                   ret     z                               ; no so we can just return
 179+ 948E C9           PL44:                   ret
 180+ 948F 37           PL44TooBig:             scf
 181+ 9490 C9                                   ret
 182+ 9491
# file closed: ../Maths/DIVD3B2.asm
 117  9491                  INCLUDE "../Maths/multiply.asm"
# file opened: ../Maths/multiply.asm
   1+ 9491              HLequSRmulQdiv256:      ;X.Y=x1lo.S*M/256  	\ where M/256 is gradient
   2+ 9491 2A 0E 84                             ld  hl,(varRS)
   3+ 9494 3A 0D 84                             ld  a,(varQ)
   4+ 9497 C5 D5        HLeqyHLmulAdiv256:      push    bc,,de
   5+ 9499 11 00 00                             ld  de,0        ; de = XY
   6+ 949C 47                                   ld  b,a         ; b = Q
   7+ 949D                                      ShiftHLRight1
   7+ 949D CB 3C       >			   srl h
   7+ 949F CB 1D       >			   rr  l
   8+ 94A1 CB 20                                sla b
   9+ 94A3 30 03                                jr  nc,.LL126
  10+ 94A5 EB           .LL125:                 ex de,hl
  11+ 94A6 19                                   add hl,de
  12+ 94A7 EB                                   ex  de,hl       ; de = de + rs
  13+ 94A8              .LL126:                 ShiftHLRight1
  13+ 94A8 CB 3C       >			   srl h
  13+ 94AA CB 1D       >			   rr  l
  14+ 94AC CB 20                                sla b
  15+ 94AE 38 F5                                jr      c,.LL125
  16+ 94B0 20 F6                                jr      nz,.LL126
  17+ 94B2 EB                                   ex      de,hl   ; hl = result
  18+ 94B3 D1 C1                                pop     bc,,de
  19+ 94B5 C9                                   ret
  20+ 94B6
  21+ 94B6
  22+ 94B6              MacroDEEquQmulASigned:  MACRO
  23+ 94B6 ~                                    ld      d,a                         ; save a into d
  24+ 94B6 ~                                    ld      a,(varQ)
  25+ 94B6 ~                                    ld      e,a
  26+ 94B6 ~                                    xor     d                           ; a = a xor var Q
  27+ 94B6 ~                                    and     SignOnly8Bit
  28+ 94B6 ~                                    ld      b,a                         ; b = sign of a xor q
  29+ 94B6 ~                                    ld      a,d                         ; d = abs d (or a reg)
  30+ 94B6 ~                                    and     SignMask8Bit
  31+ 94B6 ~                                    ld      d,a
  32+ 94B6 ~                                    ld      a,e                         ; e = abs e (or varQ)
  33+ 94B6 ~                                    and     SignMask8Bit
  34+ 94B6 ~                                    ld      e,a
  35+ 94B6 ~                                    mul                                 ; de = a * Q
  36+ 94B6 ~                                    ld      a,d
  37+ 94B6 ~                                    or      b                           ; de = a * Q leading sign bit
  38+ 94B6 ~                                    ld      d,a
  39+ 94B6                                      ENDM
  40+ 94B6
  41+ 94B6
  42+ 94B6
  43+ 94B6                                 ; .MAD	\ -> &22AD  \ Multiply and Add  (DE also) X.A(Lo.Hi) = Q*A + R.S (Lo.Hi)
  44+ 94B6              madXAequQmulAaddRS:     MacroDEEquQmulASigned
  44+ 94B6 57          >                        ld      d,a                         ; save a into d
  44+ 94B7 3A 0D 84    >                        ld      a,(varQ)
  44+ 94BA 5F          >                        ld      e,a
  44+ 94BB AA          >                        xor     d                           ; a = a xor var Q
  44+ 94BC E6 80       >                        and     SignOnly8Bit
  44+ 94BE 47          >                        ld      b,a                         ; b = sign of a xor q
  44+ 94BF 7A          >                        ld      a,d                         ; d = abs d (or a reg)
  44+ 94C0 E6 7F       >                        and     SignMask8Bit
  44+ 94C2 57          >                        ld      d,a
  44+ 94C3 7B          >                        ld      a,e                         ; e = abs e (or varQ)
  44+ 94C4 E6 7F       >                        and     SignMask8Bit
  44+ 94C6 5F          >                        ld      e,a
  44+ 94C7 ED 30       >                        mul                                 ; de = a * Q
  44+ 94C9 7A          >                        ld      a,d
  44+ 94CA B0          >                        or      b                           ; de = a * Q leading sign bit
  44+ 94CB 57          >                        ld      d,a
  45+ 94CC 2A 0E 84     madDEaddRS:             ld		hl,(varR)
  46+ 94CF CD D8 94                             call	madXAAddHLDESigned
  47+ 94D2 EB                                   ex      de,hl                       ; de = R.S + DE
  48+ 94D3                                      ClearCarryFlag
  48+ 94D3 B7          >                        or a
  49+ 94D4 DD 6B                                ld      ixl,e
  50+ 94D6 7A                                   ld      a,d
  51+ 94D7 C9                                   ret
  52+ 94D8
  53+ 94D8
  54+ 94D8 7C           madXAAddHLDESigned:     ld      a,h
  55+ 94D9 E6 80                                and     SignOnly8Bit
  56+ 94DB 47                                   ld      b,a                         ;save sign bit in b
  57+ 94DC AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
  58+ 94DD                                      JumpIfNegative .ADDHLDEOppSGN        ;Signs are opposite there fore we can subtract to get difference
  58+ 94DD FA F5 94    >                        jp		m, .ADDHLDEOppSGN
  59+ 94E0 78           .ADDHLDESameSigns:       ld      a,b
  60+ 94E1 B2                                   or      d
  61+ 94E2                                      JumpIfNegative .ADDHLDESameNeg       ; optimisation so we can just do simple add if both positive
  61+ 94E2 FA E7 94    >                        jp		m, .ADDHLDESameNeg
  62+ 94E5 19                                   add     hl,de
  63+ 94E6 C9                                   ret
  64+ 94E7 7C           .ADDHLDESameNeg:         ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
  65+ 94E8 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
  66+ 94EA 67                                   ld      h,a
  67+ 94EB 7A                                   ld      a,d
  68+ 94EC E6 7F                                and     SignMask8Bit
  69+ 94EE 57                                   ld      d,a
  70+ 94EF 19                                   add     hl,de
  71+ 94F0 3E 80                                ld      a,SignOnly8Bit
  72+ 94F2 B4                                   or      h                           ; now set bit for negative value, we won't bother with overflow for now TODO
  73+ 94F3 67                                   ld      h,a
  74+ 94F4 C9                                   ret
  75+ 94F5 7C           .ADDHLDEOppSGN:          ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit                     ; here HL and DE are opposite
  76+ 94F6 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
  77+ 94F8 67                                   ld      h,a
  78+ 94F9 7A                                   ld      a,d
  79+ 94FA E6 7F                                and     SignMask8Bit
  80+ 94FC 57                                   ld      d,a
  81+ 94FD B7                                   or      a
  82+ 94FE ED 52                                sbc     hl,de
  83+ 9500 38 04                                jr      c,.ADDHLDEOppInvert
  84+ 9502 78           .ADDHLDEOppSGNNoCarry:   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
  85+ 9503 B4                                   or      h
  86+ 9504 67                                   ld      h,a                         ; set the previou sign value
  87+ 9505 C9                                   ret
  88+ 9506              .ADDHLDEOppInvert:       NegHL                                                   ; we need to flip the sign and 2'c the Hl result
  88+ 9506 AF          >                    xor a
  88+ 9507 95          >                    sub l
  88+ 9508 6F          >                    ld l,a
  88+ 9509 9F          >                    sbc a,a
  88+ 950A 94          >                    sub h
  88+ 950B 67          >                    ld h,a
  89+ 950C 78                                   ld      a,b
  90+ 950D EE 80                                xor     SignOnly8Bit                ; flip sign bit
  91+ 950F B4                                   or      h
  92+ 9510 67                                   ld      h,a                         ; recover sign
  93+ 9511 C9                                   ret
  94+ 9512
  95+ 9512
  96+ 9512                  ; multiplication of 16-bit number and 8-bit number into a 24-bit product
  97+ 9512                  ;
  98+ 9512                  ; enter : hl = 16-bit multiplier   = x
  99+ 9512                  ;          e =  8-bit multiplicand = y
 100+ 9512                  ;
 101+ 9512                  ; exit  : ahl = 24-bit product
 102+ 9512                  ;         carry reset
 103+ 9512                  ;
 104+ 9512                  ; uses  : af, de, hl
 105+ 9512 54           AHLequHLmulE:           ld d,h                      ; xh
 106+ 9513 63                                   ld h,e                      ; yl
 107+ 9514 ED 30                                mul de                      ; xh*yl
 108+ 9516 EB                                   ex de,hl
 109+ 9517 ED 30                                mul de                      ; yl*xl, hl = xh*yl
 110+ 9519
 111+ 9519 7A                                   ld  a,d                     ; sum products
 112+ 951A 85                                   add a,l
 113+ 951B 57                                   ld  d,a
 114+ 951C EB                                   ex de,hl
 115+ 951D
 116+ 951D 7A                                   ld  a,d
 117+ 951E CE 00                                adc a,0
 118+ 9520 C9                                   ret
 119+ 9521
 120+ 9521
 121+ 9521
 122+ 9521                 ; multiplication of two 16-bit numbers into a 32-bit product
 123+ 9521                 ;
 124+ 9521                 ; enter : de = 16-bit multiplicand = y
 125+ 9521                 ;         hl = 16-bit multiplicand = x
 126+ 9521                 ;
 127+ 9521                 ; exit  : dehl = 32-bit product
 128+ 9521                 ;         carry reset
 129+ 9521                 ;
 130+ 9521                 ; uses  : af, bc, de, hl
 131+ 9521
 132+ 9521
 133+ 9521
 134+ 9521 45           DEHLequDEmulHL:         ld b,l                      ; x0
 135+ 9522 4B                                   ld c,e                      ; y0
 136+ 9523 5D                                   ld e,l                      ; x0
 137+ 9524 6A                                   ld l,d
 138+ 9525 E5                                   push hl                     ; x1 y1
 139+ 9526 69                                   ld l,c                      ; y0
 140+ 9527              ; bc = x0 y0, de = y1 x0,  hl = x1 y0,  stack = x1 y1
 141+ 9527 ED 30                                mul de                      ; y1*x0
 142+ 9529 EB                                   ex de,hl
 143+ 952A ED 30                                mul de                      ; x1*y0
 144+ 952C
 145+ 952C AF                                   xor a                       ; zero A
 146+ 952D 19                                   add hl,de                   ; sum cross products p2 p1
 147+ 952E 8F                                   adc a,a                     ; capture carry p3
 148+ 952F
 149+ 952F 59                                   ld e,c                      ; x0
 150+ 9530 50                                   ld d,b                      ; y0
 151+ 9531 ED 30                                mul de                      ; y0*x0
 152+ 9533
 153+ 9533 47                                   ld b,a                      ; carry from cross products
 154+ 9534 4C                                   ld c,h                      ; LSB of MSW from cross products
 155+ 9535
 156+ 9535 7A                                   ld a,d
 157+ 9536 85                                   add a,l
 158+ 9537 67                                   ld h,a
 159+ 9538 6B                                   ld l,e                      ; LSW in HL p1 p0
 160+ 9539
 161+ 9539 D1                                   pop de
 162+ 953A ED 30                                mul de                      ; x1*y1
 163+ 953C
 164+ 953C EB                                   ex de,hl
 165+ 953D ED 4A                                adc hl,bc
 166+ 953F EB                                   ex de,hl                    ; de = final MSW
 167+ 9540
 168+ 9540 C9                                   ret
 169+ 9541
 170+ 9541              ; multiplication of two 16-bit numbers into a 16-bit product
 171+ 9541              ; enter : de = 16-bit multiplicand
 172+ 9541              ;         hl = 16-bit multiplicand
 173+ 9541              ; exit  : hl = 16-bit product
 174+ 9541              ;         carry reset
 175+ 9541              ; maths is
 176+ 9541              ;        hl = y , de= x
 177+ 9541              ;        hl = xhi,ylo + (yhigh * xlow)
 178+ 9541              ;        hl = yhih & xlo + x
 179+ 9541              ;
 180+ 9541              ;
 181+ 9541              ; uses  : af, bc, de, hl
 182+ 9541 C5           mulDEbyHL:              push    bc
 183+ 9542 7A                                   ld a,d                      ; a = xh
 184+ 9543 54                                   ld d,h                      ; d = yh
 185+ 9544 67                                   ld h,a                      ; h = xh
 186+ 9545 4B                                   ld c,e                      ; c = xl
 187+ 9546 45                                   ld b,l                      ; b = yl
 188+ 9547 ED 30                                mul                         ; yh * yl
 189+ 9549 EB                                   ex de,hl
 190+ 954A ED 30                                mul                         ; xh * yl
 191+ 954C 19                                   add hl,de                   ; add cross products
 192+ 954D 59                                   ld e,c
 193+ 954E 50                                   ld d,b
 194+ 954F ED 30                                mul                         ; yl * xl
 195+ 9551 7D                                   ld a,l                      ; cross products lsb
 196+ 9552 82                                   add a,d                     ; add to msb final
 197+ 9553 67                                   ld h,a
 198+ 9554 6B                                   ld l,e                      ; hl = final
 199+ 9555                                      ; 83 cycles, 19 bytes
 200+ 9555 AF                                   xor a                       ; reset carry
 201+ 9556 C1                                   pop     bc
 202+ 9557 C9                                   ret
 203+ 9558
 204+ 9558
 205+ 9558              ; CHL = multiplicand D = multiplier
 206+ 9558              ; DCHL = CHL * D
 207+ 9558 7A           mulCHLbyDSigned:        ld      a,d                 ; get sign from d
 208+ 9559 AC                                   xor     h                   ; xor with h to get resultant sign
 209+ 955A E6 80                                and     SignOnly8Bit        ; .
 210+ 955C FD 67                                ld      iyh,a               ; iyh = copy of sign
 211+ 955E 79                                   ld      a,c                 ; now CHL = ABS (CHL)
 212+ 955F E6 7F                                and     SignMask8Bit        ; .
 213+ 9561 4F                                   ld      c,a                 ; .
 214+ 9562 7A                                   ld      a,d                 ; d = ABS D
 215+ 9563 E6 7F                                and     SignMask8Bit        ; .
 216+ 9565              ; At this point CHL = ABS (HLE), A = ABS(D)
 217+ 9565 57           .mul1:                  ld      d,a                 ; first do D * L
 218+ 9566 5D                                   ld      e,l                 ; .
 219+ 9567 ED 30                                mul     de                  ; DE = L * D
 220+ 9569 08                                   ex      af,af'              ; save multiplier
 221+ 956A 6B                                   ld      l,e                 ; L = p0
 222+ 956B 7A                                   ld      a,d                 ; carry byte
 223+ 956C 08                                   ex      af,af'              ; retrieve muliplier and save carry byte along with flags
 224+ 956D 5C           .mul2:                  ld      e,h                 ; byte 2 of multiplicand
 225+ 956E 57                                   ld      d,a                 ; and multiplier
 226+ 956F ED 30                                mul     de                  ; now its D & L
 227+ 9571 08                                   ex      af,af'              ; get back carry byte with flags
 228+ 9572 83           .carrybyte1:            add     a,e                 ; add low byte carry to result and retain carry too through next instructions
 229+ 9573 67                                   ld      h,a                 ; h = P1
 230+ 9574 7A                                   ld      a,d                 ; a = carry byte
 231+ 9575 08                                   ex      af,af'              ; save carry byte and get back multiplier with flags
 232+ 9576 59           .mul3:                  ld      e,c                 ; byte 3 of multiplicand
 233+ 9577 57                                   ld      d,a                 ;
 234+ 9578 ED 30                                mul     de                  ;
 235+ 957A 08                                   ex      af,af'              ; get back carry byte and carry prior to first add
 236+ 957B 8B                                   adc     a,e                 ;
 237+ 957C FD B4                                or      iyh                 ; recover saved resultant sign
 238+ 957E 4F                                   ld      c,a                 ; c byte 3. Note the value range allowed can never cause a byte 3 carry
 239+ 957F C9                                   ret
 240+ 9580
 241+ 9580              ;  CHL = 53456 D = 1E
 242+ 9580              ;  56 * 1E = A14 L = 14 carry = 0A
 243+ 9580              ;  34 * 1E = 618 H = 18 +A = 22 carry = 6
 244+ 9580              ;  5  * 1E = 096 C = 96 + 6 = 9C
 245+ 9580              ;  CHL = 9C2214
 246+ 9580
 247+ 9580              ; DELC = HLE * D, uses HL, DE, C , A , IYH
 248+ 9580              ; HLE = multiplicand D = multiplier
 249+ 9580              ; tested by mathstestsun.asm all passed
 250+ 9580 7A           mulHLEbyDSigned:        ld      a,d                 ; get sign from d
 251+ 9581 AC                                   xor     h                   ; xor with h to get resultant sign
 252+ 9582 E6 80                                and     SignOnly8Bit        ; .
 253+ 9584 FD 67                                ld      iyh,a               ; iyh = copy of sign
 254+ 9586 7C                                   ld      a,h                 ; now HLE = ABS (HLE)
 255+ 9587 E6 7F                                and     SignMask8Bit        ; .
 256+ 9589 67                                   ld      h,a                 ; .
 257+ 958A 7A                                   ld      a,d                 ; d = ABS D
 258+ 958B E6 7F                                and     SignMask8Bit        ; .
 259+ 958D 57                                   ld      d,a                 ; .
 260+ 958E              ; At this point HLE = ABS (HLE), A = ABS(D)
 261+ 958E ED 30        .mul1:                  mul     de                  ; C = E * D
 262+ 9590 08                                   ex      af,af'              ; save mulitplier
 263+ 9591 4B                                   ld      c,e                 ; C = p0
 264+ 9592 7A                                   ld      a,d                 ; save carry and get back multiplier
 265+ 9593 08                                   ex      af,af'
 266+ 9594 5D           .mul2:                  ld      e,l                 ; L = L * D
 267+ 9595 57                                   ld      d,a                 ; .
 268+ 9596 ED 30                                mul     de                  ; .
 269+ 9598 08                                   ex      af,af'              ; .
 270+ 9599 83           .carrybyte1:            add     a,e                 ; L = L + carry byte
 271+ 959A 6F                                   ld      l,a                 ; .
 272+ 959B 7A                                   ld      a,d
 273+ 959C 08                                   ex      af,af'              ; save new carry byte
 274+ 959D 5C           .mul3:                  ld      e,h                 ; e = H * D
 275+ 959E 57                                   ld      d,a
 276+ 959F ED 30                                mul     de
 277+ 95A1 08                                   ex      af,af'
 278+ 95A2 8B                                   adc     a,e                 ;
 279+ 95A3 5F                                   ld      e,a
 280+ 95A4 FD 54                                ld      d,iyh
 281+ 95A6 C9                                   ret
 282+ 95A7
 283+ 95A7
 284+ 95A7              ; multiplication of two S156-bit numbers into a 16-bit 2'd compliment product
 285+ 95A7              ; enter : de = 16-bit multiplicand
 286+ 95A7              ;         hl = 16-bit multiplicand
 287+ 95A7              ; exit  : hl = 16-bit product
 288+ 95A7              ;         carry reset
 289+ 95A7              ;
 290+ 95A7              ; uses  : af, bc, de, hl
 291+ 95A7 00           mulDEbyHLSignByte       DB      0
 292+ 95A8 AF           mulDEbyHLSgnTo2c:       xor     a
 293+ 95A9 32 A7 95                             ld      (mulDEbyHLSignByte),a
 294+ 95AC 7A           .SignDE:                ld      a,d
 295+ 95AD ED 27 80                             test    $80
 296+ 95B0 28 08                                jr      z,.SignHL
 297+ 95B2 E6 7F        .NegativeDE:            and     $7F
 298+ 95B4 57                                   ld      d,a
 299+ 95B5 3E 80                                ld      a,$80
 300+ 95B7 32 A7 95                             ld      (mulDEbyHLSignByte),a
 301+ 95BA 7C           .SignHL:                ld      a,h
 302+ 95BB ED 27 80                             test    $80
 303+ 95BE 28 0B                                jr      z,.AbsoluteMultiply
 304+ 95C0 E6 7F        .NegativeHL:            and     $7F
 305+ 95C2 67                                   ld      h,a
 306+ 95C3 3A A7 95                             ld      a,(mulDEbyHLSignByte)
 307+ 95C6 EE 80                                xor     $80
 308+ 95C8 32 A7 95                             ld      (mulDEbyHLSignByte),a
 309+ 95CB CD 41 95     .AbsoluteMultiply:      call    mulDEbyHL
 310+ 95CE 3A A7 95     .RecoverSign:           ld      a,(mulDEbyHLSignByte)
 311+ 95D1 ED 27 80                             test    $80
 312+ 95D4 C8                                   ret     z
 313+ 95D5 AF           .Negateghl: 			xor 	a
 314+ 95D6 95                                   sub 	l
 315+ 95D7 6F                                   ld 		l,a
 316+ 95D8 9F                                   sbc 	a,a
 317+ 95D9 94                                   sub 	h
 318+ 95DA 67                                   ld 		h,a
 319+ 95DB C9                                   ret
 320+ 95DC
 321+ 95DC AF           mulDESgnbyHLUnsgnTo2c:  xor     a
 322+ 95DD 32 A7 95                             ld      (mulDEbyHLSignByte),a
 323+ 95E0 7A           .SignDE:                ld      a,d
 324+ 95E1 ED 27 80                             test    $80
 325+ 95E4 28 08                                jr      z,.AbsoluteMultiply
 326+ 95E6 E6 7F        .NegativeDE:            and     $7F
 327+ 95E8 57                                   ld      d,a
 328+ 95E9 3E 80                                ld      a,$80
 329+ 95EB 32 A7 95                             ld      (mulDEbyHLSignByte),a
 330+ 95EE CD 41 95     .AbsoluteMultiply:      call    mulDEbyHL
 331+ 95F1 3A A7 95     .RecoverSign:           ld      a,(mulDEbyHLSignByte)
 332+ 95F4 ED 27 80                             test    $80
 333+ 95F7 C8                                   ret     z
 334+ 95F8 AF           .Negateghl:             xor 	a
 335+ 95F9 95                                   sub 	l
 336+ 95FA 6F                                   ld 		l,a
 337+ 95FB 9F                                   sbc 	a,a
 338+ 95FC 94                                   sub 	h
 339+ 95FD 67                                   ld 		h,a
 340+ 95FE C9                                   ret
 341+ 95FF
 342+ 95FF
# file closed: ../Maths/multiply.asm
 118  95FF                  INCLUDE "../Maths/asm_square.asm"
# file opened: ../Maths/asm_square.asm
   1+ 95FF              ; "ASM_SQUA : TESTGOOD"
   2+ 95FF              ; "AP = A^2 A = low,P = hi"
   3+ 95FF
   4+ 95FF              inline_squde: MACRO
   5+ 95FF ~            			ld	e,a
   6+ 95FF ~            			ld  d,a
   7+ 95FF ~            			mul
   8+ 95FF              			ENDM
   9+ 95FF
  10+ 95FF              inline_squa: MACRO
  11+ 95FF ~            			ld	e,a
  12+ 95FF ~            			ld  d,a
  13+ 95FF ~            			mul
  14+ 95FF ~            			ld	a,e
  15+ 95FF              			ENDM
  16+ 95FF
  17+ 95FF
  18+ 95FF              asm_squa:
  19+ 95FF E6 7F        	and SignMask8Bit
  20+ 9601              ; "ASM SQUA2 : TESTGOOD"
  21+ 9601              ; "AP = A^2 A = low,P = hi singed"
  22+ 9601              asm_squa2:
  23+ 9601 5F           	ld e, a
  24+ 9602 57           	ld d,a
  25+ 9603 ED 30        	mul
  26+ 9605 ED 53 0A 83  	ld (varP),de
  27+ 9609 7B           	ld a,e
  28+ 960A C9           	ret
# file closed: ../Maths/asm_square.asm
 119  960B                  INCLUDE "../Maths/asm_sqrt.asm"
# file opened: ../Maths/asm_sqrt.asm
   1+ 960B              ; "ASM SQRT : TESTGOOD"
   2+ 960B              ; "16-bit integer square root"
   3+ 960B              ; "call with de = number to square root"
   4+ 960B              ; "returns   hl = square root"
   5+ 960B              ; "corrupts  bc, de"
   6+ 960B              asm_sqrt:
   7+ 960B 01 00 80     	ld bc,$8000
   8+ 960E 61           	ld h,c
   9+ 960F 69           	ld l,c
  10+ 9610              .sqrloop:
  11+ 9610 CB 38        	srl b
  12+ 9612 CB 19        	rr c
  13+ 9614 09           	add hl,bc
  14+ 9615 EB           	ex de,hl
  15+ 9616 ED 52        	sbc hl,de
  16+ 9618 38 04        	jr c,.sqrbit
  17+ 961A EB           	ex de,hl
  18+ 961B 09           	add hl,bc
  19+ 961C 18 05        	jr .sqrfi
  20+ 961E              .sqrbit:
  21+ 961E 19           	add hl,de
  22+ 961F EB           	ex de,hl
  23+ 9620 B7           	or a
  24+ 9621 ED 42        	sbc hl,bc
  25+ 9623              .sqrfi:
  26+ 9623 CB 3C        	srl h
  27+ 9625 CB 1D        	rr l
  28+ 9627 CB 38        	srl b
  29+ 9629 CB 19        	rr c
  30+ 962B 30 E3        	jr nc,.sqrloop
  31+ 962D C9           	ret
  32+ 962E
  33+ 962E
  34+ 962E              sqrtQR:					; Q = SQR(Qlo.Rhi) Q <~127
  35+ 962E 3A 0D 84     	ld		a,(varQ)
  36+ 9631 5F           	ld		e,a
  37+ 9632 3A 0E 84     	ld		a,(varR)
  38+ 9635 57           	ld		d,a
  39+ 9636 CD 0B 96     	call	asm_sqrt
  40+ 9639 7D               ld      a,l
  41+ 963A 32 0D 84     	ld		(varQ),a
  42+ 963D C9           	ret
  43+ 963E
# file closed: ../Maths/asm_sqrt.asm
 120  963E                  INCLUDE "../Maths/asm_divide.asm"
# file opened: ../Maths/asm_divide.asm
   1+ 963E              ;
   2+ 963E              ;   Set flags E to 11111110
   3+ 963E              ;   Loop:   A << 2
   4+ 963E              ;           if carry was 0
   5+ 963E              ;               if a >= D
   6+ 963E              ;                   A = A - D
   7+ 963E              ;                   clear carry (probably irrelevant really)
   8+ 963E              ;           else
   9+ 963E
  10+ 963E              ;               sla flags << bringing in carry of 1
  11+ 963E              ;               if bit 7 of flag was set then loop
  12+ 963E              ;                                        elase a = e and exit
  13+ 963E              ;
  14+ 963E              ;
  15+ 963E
  16+ 963E
  17+ 963E              AEquAmul256DivD:        JumpIfAGTENusng  d, .Ll28Exit255
  17+ 963E BA          >                        cp     d
  17+ 963F D2 5D 96    >                        jp		nc,.Ll28Exit255
  18+ 9642 1E FE                                ld      e,%11111110                 ; Set R to have bits 1-7 set, so we can rotate through 7
  19+ 9644 CB 27        .DivideLoop:            sla     a
  20+ 9646 38 0D                                jr      c,.LL29
  21+ 9648                                      JumpIfALTNusng  d, .SkipSub         ; will jump if carry set, so we need to reset on the rol
  21+ 9648 BA          >                        cp      d
  21+ 9649 DA 4E 96    >                        jp		c, .SkipSub
  22+ 964C 92                                   sub     d
  23+ 964D                                      ClearCarryFlag                      ; reset clarry as it will be complimented for rotate as 6502 does carry flags inverted
  23+ 964D B7          >                        or a
  24+ 964E              .SkipSub:               FlipCarryFlag                       ; if we did the subtract the carry will be clear so we need to invert to roll in.
  24+ 964E 3F          >                        ccf
  25+ 964F CB 13                                rl      e
  26+ 9651 38 F1                                jr      c,.DivideLoop
  27+ 9653 7B                                   ld      a,e
  28+ 9654 C9                                   ret
  29+ 9655 92           .LL29:                  sub     d                           ; A >= Q, so set A = A - Q
  30+ 9656                                      SetCarryFlag                        ; Set the C flag to rotate into the result in R
  30+ 9656 37          >                        scf
  31+ 9657 CB 13                                rl      e                           ; rotate counter e left
  32+ 9659 38 E9                                jr      c,.DivideLoop               ; if a bit was spat off teh end then loop
  33+ 965B 7B                                   ld      a,e                         ; stick result in a
  34+ 965C C9                                   ret
  35+ 965D 3E FF        .Ll28Exit255:           ld  a,255                           ; Fail with FF as result
  36+ 965F C9                                   ret
  37+ 9660
  38+ 9660
  39+ 9660              ; Divide 8-bit values
  40+ 9660              ; In: Divide E by divider C
  41+ 9660              ; Out: A = result, B = rest
  42+ 9660              ;
  43+ 9660              ;;;Div8:
  44+ 9660              ;;;    xor a
  45+ 9660              ;;;    ld b,8
  46+ 9660              ;;;Div8_Loop:
  47+ 9660              ;;;    rl e
  48+ 9660              ;;;    rla
  49+ 9660              ;;;    sub c
  50+ 9660              ;;;    jr nc,Div8_NoAdd
  51+ 9660              ;;;    add a,c
  52+ 9660              ;;;Div8_NoAdd:
  53+ 9660              ;;;    djnz Div8_Loop
  54+ 9660              ;;;    ld b,a0
  55+ 9660              ;;;    ld a,e
  56+ 9660              ;;;    rla
  57+ 9660              ;;;    cpl
  58+ 9660              ;;;    ret
  59+ 9660
  60+ 9660              ;;Inputs: DE is the numerator, BC is the divisor
  61+ 9660              ;;Outputs: DE is the result
  62+ 9660              ;;         A is a copy of E
  63+ 9660              ;;         HL is the remainder
  64+ 9660              ;;         BC is not changed
  65+ 9660              ;; so DE = DE /BC
  66+ 9660              ;140 bytes
  67+ 9660              ;145cc
  68+ 9660
  69+ 9660              MacroDEDivBC:       MACRO
  70+ 9660 ~                                rla
  71+ 9660 ~                                adc     hl,hl
  72+ 9660 ~                                sbc     hl,bc
  73+ 9660 ~                                jr      nc,$+3
  74+ 9660 ~                                add     hl,bc
  75+ 9660                                  ENDM
  76+ 9660
  77+ 9660              DEequDEDivBC:
  78+ 9660 AF               xor a
  79+ 9661 ED 62            sbc hl,hl
  80+ 9663 7A               ld a,d
  81+ 9664                  MacroDEDivBC
  81+ 9664 17          >                    rla
  81+ 9665 ED 6A       >                    adc     hl,hl
  81+ 9667 ED 42       >                    sbc     hl,bc
  81+ 9669 30 01       >                    jr      nc,$+3
  81+ 966B 09          >                    add     hl,bc
  82+ 966C                  MacroDEDivBC
  82+ 966C 17          >                    rla
  82+ 966D ED 6A       >                    adc     hl,hl
  82+ 966F ED 42       >                    sbc     hl,bc
  82+ 9671 30 01       >                    jr      nc,$+3
  82+ 9673 09          >                    add     hl,bc
  83+ 9674                  MacroDEDivBC
  83+ 9674 17          >                    rla
  83+ 9675 ED 6A       >                    adc     hl,hl
  83+ 9677 ED 42       >                    sbc     hl,bc
  83+ 9679 30 01       >                    jr      nc,$+3
  83+ 967B 09          >                    add     hl,bc
  84+ 967C                  MacroDEDivBC
  84+ 967C 17          >                    rla
  84+ 967D ED 6A       >                    adc     hl,hl
  84+ 967F ED 42       >                    sbc     hl,bc
  84+ 9681 30 01       >                    jr      nc,$+3
  84+ 9683 09          >                    add     hl,bc
  85+ 9684                  MacroDEDivBC
  85+ 9684 17          >                    rla
  85+ 9685 ED 6A       >                    adc     hl,hl
  85+ 9687 ED 42       >                    sbc     hl,bc
  85+ 9689 30 01       >                    jr      nc,$+3
  85+ 968B 09          >                    add     hl,bc
  86+ 968C                  MacroDEDivBC
  86+ 968C 17          >                    rla
  86+ 968D ED 6A       >                    adc     hl,hl
  86+ 968F ED 42       >                    sbc     hl,bc
  86+ 9691 30 01       >                    jr      nc,$+3
  86+ 9693 09          >                    add     hl,bc
  87+ 9694                  MacroDEDivBC
  87+ 9694 17          >                    rla
  87+ 9695 ED 6A       >                    adc     hl,hl
  87+ 9697 ED 42       >                    sbc     hl,bc
  87+ 9699 30 01       >                    jr      nc,$+3
  87+ 969B 09          >                    add     hl,bc
  88+ 969C                  MacroDEDivBC
  88+ 969C 17          >                    rla
  88+ 969D ED 6A       >                    adc     hl,hl
  88+ 969F ED 42       >                    sbc     hl,bc
  88+ 96A1 30 01       >                    jr      nc,$+3
  88+ 96A3 09          >                    add     hl,bc
  89+ 96A4 17               rla
  90+ 96A5 2F               cpl
  91+ 96A6 57               ld d,a
  92+ 96A7
  93+ 96A7 7B               ld a,e
  94+ 96A8                  MacroDEDivBC
  94+ 96A8 17          >                    rla
  94+ 96A9 ED 6A       >                    adc     hl,hl
  94+ 96AB ED 42       >                    sbc     hl,bc
  94+ 96AD 30 01       >                    jr      nc,$+3
  94+ 96AF 09          >                    add     hl,bc
  95+ 96B0                  MacroDEDivBC
  95+ 96B0 17          >                    rla
  95+ 96B1 ED 6A       >                    adc     hl,hl
  95+ 96B3 ED 42       >                    sbc     hl,bc
  95+ 96B5 30 01       >                    jr      nc,$+3
  95+ 96B7 09          >                    add     hl,bc
  96+ 96B8                  MacroDEDivBC
  96+ 96B8 17          >                    rla
  96+ 96B9 ED 6A       >                    adc     hl,hl
  96+ 96BB ED 42       >                    sbc     hl,bc
  96+ 96BD 30 01       >                    jr      nc,$+3
  96+ 96BF 09          >                    add     hl,bc
  97+ 96C0                  MacroDEDivBC
  97+ 96C0 17          >                    rla
  97+ 96C1 ED 6A       >                    adc     hl,hl
  97+ 96C3 ED 42       >                    sbc     hl,bc
  97+ 96C5 30 01       >                    jr      nc,$+3
  97+ 96C7 09          >                    add     hl,bc
  98+ 96C8                  MacroDEDivBC
  98+ 96C8 17          >                    rla
  98+ 96C9 ED 6A       >                    adc     hl,hl
  98+ 96CB ED 42       >                    sbc     hl,bc
  98+ 96CD 30 01       >                    jr      nc,$+3
  98+ 96CF 09          >                    add     hl,bc
  99+ 96D0                  MacroDEDivBC
  99+ 96D0 17          >                    rla
  99+ 96D1 ED 6A       >                    adc     hl,hl
  99+ 96D3 ED 42       >                    sbc     hl,bc
  99+ 96D5 30 01       >                    jr      nc,$+3
  99+ 96D7 09          >                    add     hl,bc
 100+ 96D8                  MacroDEDivBC
 100+ 96D8 17          >                    rla
 100+ 96D9 ED 6A       >                    adc     hl,hl
 100+ 96DB ED 42       >                    sbc     hl,bc
 100+ 96DD 30 01       >                    jr      nc,$+3
 100+ 96DF 09          >                    add     hl,bc
 101+ 96E0                  MacroDEDivBC
 101+ 96E0 17          >                    rla
 101+ 96E1 ED 6A       >                    adc     hl,hl
 101+ 96E3 ED 42       >                    sbc     hl,bc
 101+ 96E5 30 01       >                    jr      nc,$+3
 101+ 96E7 09          >                    add     hl,bc
 102+ 96E8 17               rla
 103+ 96E9 2F               cpl
 104+ 96EA 5F               ld e,a
 105+ 96EB C9               ret
 106+ 96EC
 107+ 96EC
 108+ 96EC
 109+ 96EC              ;divdide by 16 using undocumented instrunctions
 110+ 96EC              ;Input: BC = Dividend, DE = Divisor, HL = 0
 111+ 96EC              ;Output: BC = Quotient, HL = Remainder
 112+ 96EC              ; Our use
 113+ 96EC              ; BC = A0
 114+ 96EC              ; DE = 0C
 115+ 96EC              ; so BC = a * 256 / C
 116+ 96EC              DIV16Amul256dCUNDOC:    JumpIfAGTENusng	  c,DEV16ATooLarge                                          ; first off if a > c ten return 255
 116+ 96EC B9          >                        cp     c
 116+ 96ED D2 18 97    >                        jp		nc,DEV16ATooLarge
 117+ 96F0 47                                   ld      b,a
 118+ 96F1 59                                   ld      e,c
 119+ 96F2 0E 00                                ld      c,0
 120+ 96F4 16 00                                ld      d,0
 121+ 96F6 C3 03 97                             jp      DIV16UNDOC
 122+ 96F9 47           DIV16Amul256dQUNDOC:    ld      b,a
 123+ 96FA 0E 00                                ld      c,0
 124+ 96FC 21 0D 84                             ld      hl,varQ
 125+ 96FF 7E                                   ld      a,(hl)
 126+ 9700 16 00                                ld      d,0
 127+ 9702 5F                                   ld      e,a
 128+ 9703              DIV16BCDivDEUNDOC:
 129+ 9703 21 00 00     DIV16UNDOC:             ld      hl,0
 130+ 9706 78                                   ld      a,b
 131+ 9707 06 10                                ld      b,16
 132+ 9709 CB 31        DIV16UNDOCLOOP:         sll	c		; unroll 16 times
 133+ 970B 17                                   rla			; ...
 134+ 970C ED 6A                                adc	hl,hl		; ...
 135+ 970E ED 52                                sbc	hl,de		; ...
 136+ 9710 30 02                                jr	nc,DIV16UNDOCSKIP		; ...
 137+ 9712 19                                   add	hl,de		; ...
 138+ 9713 0D                                   dec	c		; ...
 139+ 9714 10 F3        DIV16UNDOCSKIP:         djnz DIV16UNDOCLOOP
 140+ 9716 47                                   ld   b,a
 141+ 9717 C9                                   ret
 142+ 9718 01 FF 00     DEV16ATooLarge:         ld     bc,$00FF
 143+ 971B C9                                   ret
 144+ 971C
 145+ 971C              ; "> asm_div8 C_Div_D - C is the numerator, D is the denominator, A is the remainder, B is 0, C is the result of C/D,D,E,H,L are not changed"
 146+ 971C 06 08        asm_div8:               ld b,8
 147+ 971E AF                                   xor a
 148+ 971F CB 21        .div8_loop:	            sla c
 149+ 9721 17                                   rla
 150+ 9722 BA                                   cp d
 151+ 9723 38 02                                jr c,.div8_skip
 151+ 9725
 152+ 9725 0C                                   inc c
 153+ 9726 92                                   sub d
 154+ 9727 10 F6        .div8_skip:	            djnz .div8_loop
 155+ 9729 C9                                   ret
 156+ 972A              ; ">asm_div16: HL_Div_C: HL is the numerator,  C is the denominator, output A is the remainder, B is 0, C,DE is not changedHL is the quotient"
 157+ 972A 06 10        asm_div16:              ld b,16
 158+ 972C AF                                   xor a
 159+ 972D CB 25        div16_loop:	            sla l
 160+ 972F CB 14                                rl	h
 161+ 9731              ;    add hl,hl
 162+ 9731 17                                   rla
 163+ 9732 B9                                   cp c
 164+ 9733 38 02                                jr c,div16_skip
 165+ 9735 2C                                   inc l
 166+ 9736 91                                   sub c
 167+ 9737 10 F4        div16_skip:		        djnz div16_loop
 168+ 9739 C9                                   ret
 169+ 973A              ;
 170+ 973A              ; Divide 16-bit values (with 16-bit result)
 171+ 973A              ; In: Divide BC by divider DE
 172+ 973A              ; Out: BC = result, HL = rest
 173+ 973A              ;
 174+ 973A              HLDivC_Iteration: 	MACRO
 175+ 973A ~            					add	hl,hl		; unroll 16 times
 176+ 973A ~            					rla				; ...
 177+ 973A ~            					cp	c			; ...
 178+ 973A ~            					jr	1F
 179+ 973A ~            					sub	c			; ...
 180+ 973A ~            1:
 181+ 973A ~            					inc	l			; ...
 182+ 973A              					ENDM
 183+ 973A
 184+ 973A
 185+ 973A
 186+ 973A              ; ">div1616: BC = BC / DE. HL = remainder"
 187+ 973A 21 00 00     Div1616:            ld hl,0
 188+ 973D 78                               ld a,b
 189+ 973E 06 08                            ld b,8
 190+ 9740 17           .Div16_Loop1:       rla
 191+ 9741 ED 6A                            adc hl,hl
 192+ 9743 ED 52                            sbc hl,de
 193+ 9745 30 01                            jr nc,.Div16_NoAdd1
 194+ 9747 19                               add hl,de
 195+ 9748 10 F6        .Div16_NoAdd1:      djnz .Div16_Loop1
 196+ 974A 17                               rla
 197+ 974B 2F                               cpl
 198+ 974C 47                               ld b,a
 199+ 974D 79                               ld a,c
 200+ 974E 48                               ld c,b
 201+ 974F 06 08                            ld b,8
 202+ 9751 17           .Div16_Loop2:       rla
 203+ 9752 ED 6A                            adc hl,hl
 204+ 9754 ED 52                            sbc hl,de
 205+ 9756 30 01                            jr nc,.Div16_NoAdd2
 206+ 9758 19                               add hl,de
 207+ 9759 10 F6        .Div16_NoAdd2:      djnz .Div16_Loop2
 208+ 975B 17                               rla
 209+ 975C 2F                               cpl
 210+ 975D 41                               ld b,c
 211+ 975E 4F                               ld c,a
 212+ 975F C9                               ret
 213+ 9760
 214+ 9760
 215+ 9760
 216+ 9760              BCDIVDE_Iteration: MACRO
 217+ 9760 ~            				   rla
 218+ 9760 ~            				   adc	hl,hl
 219+ 9760 ~            				   add	hl,de
 220+ 9760 ~            				   jr	c,1F
 221+ 9760 ~            				   sbc	hl,de
 222+ 9760 ~            1:
 223+ 9760              				   ENDM
 224+ 9760
 225+ 9760
 226+ 9760              ; ">BC_Div_DE: BC = BC / DE. HL = remainder fast divide with unrolled loop"
 227+ 9760              ;BC/DE ==> BC, remainder in HL
 228+ 9760              ;NOTE: BC/0 returns 0 as the quotient.
 229+ 9760              ;min: 738cc
 230+ 9760              ;max: 898cc
 231+ 9760              ;avg: 818cc
 232+ 9760              ;144 bytes
 233+ 9760 AF           BC_Div_DE:              xor a
 234+ 9761 67                                   ld h,a
 235+ 9762 6F                                   ld l,a
 236+ 9763 93                                   sub e
 237+ 9764 5F                                   ld e,a
 238+ 9765 9F                                   sbc a,a
 239+ 9766 92                                   sub d
 240+ 9767 57                                   ld d,a
 241+ 9768 78                                   ld a,b
 242+ 9769                                      BCDIVDE_Iteration
 242+ 9769 17          >				   rla
 242+ 976A ED 6A       >				   adc	hl,hl
 242+ 976C 19          >				   add	hl,de
 242+ 976D 38 02       >				   jr	c,1F
 242+ 976F ED 52       >				   sbc	hl,de
 242+ 9771             >1:
 243+ 9771                                      BCDIVDE_Iteration
 243+ 9771 17          >				   rla
 243+ 9772 ED 6A       >				   adc	hl,hl
 243+ 9774 19          >				   add	hl,de
 243+ 9775 38 02       >				   jr	c,1F
 243+ 9777 ED 52       >				   sbc	hl,de
 243+ 9779             >1:
 244+ 9779                                      BCDIVDE_Iteration
 244+ 9779 17          >				   rla
 244+ 977A ED 6A       >				   adc	hl,hl
 244+ 977C 19          >				   add	hl,de
 244+ 977D 38 02       >				   jr	c,1F
 244+ 977F ED 52       >				   sbc	hl,de
 244+ 9781             >1:
 245+ 9781                                      BCDIVDE_Iteration
 245+ 9781 17          >				   rla
 245+ 9782 ED 6A       >				   adc	hl,hl
 245+ 9784 19          >				   add	hl,de
 245+ 9785 38 02       >				   jr	c,1F
 245+ 9787 ED 52       >				   sbc	hl,de
 245+ 9789             >1:
 246+ 9789                                      BCDIVDE_Iteration
 246+ 9789 17          >				   rla
 246+ 978A ED 6A       >				   adc	hl,hl
 246+ 978C 19          >				   add	hl,de
 246+ 978D 38 02       >				   jr	c,1F
 246+ 978F ED 52       >				   sbc	hl,de
 246+ 9791             >1:
 247+ 9791                                      BCDIVDE_Iteration
 247+ 9791 17          >				   rla
 247+ 9792 ED 6A       >				   adc	hl,hl
 247+ 9794 19          >				   add	hl,de
 247+ 9795 38 02       >				   jr	c,1F
 247+ 9797 ED 52       >				   sbc	hl,de
 247+ 9799             >1:
 248+ 9799                                      BCDIVDE_Iteration
 248+ 9799 17          >				   rla
 248+ 979A ED 6A       >				   adc	hl,hl
 248+ 979C 19          >				   add	hl,de
 248+ 979D 38 02       >				   jr	c,1F
 248+ 979F ED 52       >				   sbc	hl,de
 248+ 97A1             >1:
 249+ 97A1                                      BCDIVDE_Iteration
 249+ 97A1 17          >				   rla
 249+ 97A2 ED 6A       >				   adc	hl,hl
 249+ 97A4 19          >				   add	hl,de
 249+ 97A5 38 02       >				   jr	c,1F
 249+ 97A7 ED 52       >				   sbc	hl,de
 249+ 97A9             >1:
 250+ 97A9 17                                   rla
 251+ 97AA 47                                   ld b,a
 252+ 97AB
 253+ 97AB 79                                   ld a,c
 254+ 97AC                                      BCDIVDE_Iteration
 254+ 97AC 17          >				   rla
 254+ 97AD ED 6A       >				   adc	hl,hl
 254+ 97AF 19          >				   add	hl,de
 254+ 97B0 38 02       >				   jr	c,1F
 254+ 97B2 ED 52       >				   sbc	hl,de
 254+ 97B4             >1:
 255+ 97B4                                      BCDIVDE_Iteration
 255+ 97B4 17          >				   rla
 255+ 97B5 ED 6A       >				   adc	hl,hl
 255+ 97B7 19          >				   add	hl,de
 255+ 97B8 38 02       >				   jr	c,1F
 255+ 97BA ED 52       >				   sbc	hl,de
 255+ 97BC             >1:
 256+ 97BC                                      BCDIVDE_Iteration
 256+ 97BC 17          >				   rla
 256+ 97BD ED 6A       >				   adc	hl,hl
 256+ 97BF 19          >				   add	hl,de
 256+ 97C0 38 02       >				   jr	c,1F
 256+ 97C2 ED 52       >				   sbc	hl,de
 256+ 97C4             >1:
 257+ 97C4                                      BCDIVDE_Iteration
 257+ 97C4 17          >				   rla
 257+ 97C5 ED 6A       >				   adc	hl,hl
 257+ 97C7 19          >				   add	hl,de
 257+ 97C8 38 02       >				   jr	c,1F
 257+ 97CA ED 52       >				   sbc	hl,de
 257+ 97CC             >1:
 258+ 97CC                                      BCDIVDE_Iteration
 258+ 97CC 17          >				   rla
 258+ 97CD ED 6A       >				   adc	hl,hl
 258+ 97CF 19          >				   add	hl,de
 258+ 97D0 38 02       >				   jr	c,1F
 258+ 97D2 ED 52       >				   sbc	hl,de
 258+ 97D4             >1:
 259+ 97D4                                      BCDIVDE_Iteration
 259+ 97D4 17          >				   rla
 259+ 97D5 ED 6A       >				   adc	hl,hl
 259+ 97D7 19          >				   add	hl,de
 259+ 97D8 38 02       >				   jr	c,1F
 259+ 97DA ED 52       >				   sbc	hl,de
 259+ 97DC             >1:
 260+ 97DC                                      BCDIVDE_Iteration
 260+ 97DC 17          >				   rla
 260+ 97DD ED 6A       >				   adc	hl,hl
 260+ 97DF 19          >				   add	hl,de
 260+ 97E0 38 02       >				   jr	c,1F
 260+ 97E2 ED 52       >				   sbc	hl,de
 260+ 97E4             >1:
 261+ 97E4                                      BCDIVDE_Iteration
 261+ 97E4 17          >				   rla
 261+ 97E5 ED 6A       >				   adc	hl,hl
 261+ 97E7 19          >				   add	hl,de
 261+ 97E8 38 02       >				   jr	c,1F
 261+ 97EA ED 52       >				   sbc	hl,de
 261+ 97EC             >1:
 262+ 97EC 17                                   rla
 263+ 97ED 4F                                   ld c,a
 264+ 97EE C9                                   ret
 265+ 97EF
 266+ 97EF              ;Inputs:
 267+ 97EF              ;     DE,BC are 8.8 Fixed Point numbers
 268+ 97EF              ;Outputs:
 269+ 97EF              ;     DE is the 8.8 Fixed Point result (rounded to the least significant bit)
 270+ 97EF              ;if DE is 0 : 122cc or 136cc if BC is negative
 271+ 97EF              ;if |BC|>=128*|DE| : 152cc or 166cc if BC is negative
 272+ 97EF              ;Otherwise:
 273+ 97EF              ;min: 1107cc
 274+ 97EF              ;max: 1319cc
 275+ 97EF              ;avg: 1201cc
 276+ 97EF 78           BC_Div_DE_88:           ld a,b  ; First, find out if the output is positive or negative
 277+ 97F0 AA                                   xor d
 278+ 97F1 F5                                   push af   ;sign bit is the result sign bit
 279+ 97F2              ; Now make sure the inputs are positive
 280+ 97F2 A8                                   xor b     ;A now has the value of B, since I XORed it with D twice (cancelling)
 281+ 97F3 F2 FC 97                             jp p,BC_Div_DE_88_lbl1   ;if Positive, don't negate
 282+ 97F6 AF                                   xor a
 283+ 97F7 91                                   sub c
 284+ 97F8 4F                                   ld c,a
 285+ 97F9 9F                                   sbc a,a
 286+ 97FA 90                                   sub b
 287+ 97FB 47                                   ld b,a
 288+ 97FC 7A           BC_Div_DE_88_lbl1:      ld a,d  ;now make DE negative to optimize the remainder comparison
 289+ 97FD B2                                   or d
 290+ 97FE FA 07 98                             jp m,BC_Div_DE_88_lbl2
 291+ 9801 AF                                   xor a
 292+ 9802 93                                   sub e
 293+ 9803 5F                                   ld e,a
 294+ 9804 9F                                   sbc a,a
 295+ 9805 92                                   sub d
 296+ 9806 57                                   ld d,a
 297+ 9807 B3           BC_Div_DE_88_lbl2:      or e      ;if DE is 0, we can call it an overflow ;A is the current value of D
 298+ 9808 28 1D                                jr z,div_fixed88_overflow
 299+ 980A 26 00                                ld h,0          ;The accumulator gets set to B if no overflow.;We can use H=0 to save a few cc in the meantime
 300+ 980C 78                                   ld a,b;if B+DE>=0, then we'll have overflow
 301+ 980D 83                                   add a,e
 302+ 980E 7A                                   ld a,d
 303+ 980F 8C                                   adc a,h
 304+ 9810 38 15                                jr c,div_fixed88_overflow
 305+ 9812 68                                   ld l,b  ;Now we can load the accumulator/remainder with B;H is already 0
 306+ 9813 79                                   ld a,c
 307+ 9814 CD 2F 98                             call div_fixed88_sub
 308+ 9817 4F                                   ld c,a
 309+ 9818 78                                   ld a,b      ;A is now 0
 310+ 9819 CD 2F 98                             call div_fixed88_sub
 311+ 981C 51                                   ld d,c
 312+ 981D 5F                                   ld e,a
 313+ 981E F1                                   pop af
 314+ 981F F0                                   ret p
 315+ 9820 AF                                   xor a
 316+ 9821 93                                   sub e
 317+ 9822 5F                                   ld e,a
 318+ 9823 9F                                   sbc a,a
 319+ 9824 92                                   sub d
 320+ 9825 57                                   ld d,a
 321+ 9826 C9                                   ret
 322+ 9827
 323+ 9827 11 FF 7F     div_fixed88_overflow:   ld de,$7FFF
 324+ 982A F1                                   pop af
 325+ 982B F0                                   ret p
 326+ 982C 13                                   inc de
 327+ 982D 1C                                   inc e
 328+ 982E C9                                   ret
 329+ 982F
 330+ 982F              ;min: 456cc
 331+ 982F              ;max: 536cc
 332+ 982F              ;avg: 496cc
 333+ 982F 06 08        div_fixed88_sub:        ld b,8
 334+ 9831 17           BC_Div_DE_88_lbl3:      rla
 335+ 9832 ED 6A                                adc hl,hl
 336+ 9834 19                                   add hl,de
 337+ 9835 38 02                                jr c,$+4
 338+ 9837 ED 52                                sbc hl,de
 339+ 9839 10 F6                                djnz BC_Div_DE_88_lbl3
 340+ 983B 8F                                   adc a,a
 341+ 983C C9                                   ret
 342+ 983D
# file closed: ../Maths/asm_divide.asm
 121  983D                  INCLUDE "../Maths/asm_unitvector.asm"
# file opened: ../Maths/asm_unitvector.asm
   1+ 983D              asm_tis2:
   2+ 983D              ; ">TIS2 A = (A / Q * 96) so A = -96 ---- 96  range "
   3+ 983D              ; ">DOES NOT DO SIGNED YET"
   4+ 983D F5           	push af
   5+ 983E E6 7F            and SignMask8Bit
   6+ 9840 57           	ld d,a				;; d = A
   7+ 9841 3A 0D 84     	ld a,(varQ)
   8+ 9844 5F           	ld e,a
   9+ 9845 7A           	ld a,d
  10+ 9846 BB           	cp e
  11+ 9847 30 11        	jr nc, .tis2_set96	;; jump if a >= Q
  12+ 9849 1E 60        	ld e, 96
  13+ 984B ED 30        	mul				; de = d * 96 (also a * 96 )
  14+ 984D EB           	ex de,hl
  15+ 984E 3A 0D 84     	ld a,(varQ)
  16+ 9851 4F           	ld c,a
  17+ 9852 CD 2A 97     	call asm_div16
  18+ 9855 F1           	pop af
  19+ 9856 E6 80        	and $80
  20+ 9858 B5           	or l
  21+ 9859 C9           	ret
  22+ 985A              .tis2_set96:
  23+ 985A F1           	pop af
  24+ 985B E6 80        	and $80
  25+ 985D F6 96        	or $96
  26+ 985F C9           	ret
  27+ 9860
  28+ 9860
  29+ 9860              asm_unit_vector:
  30+ 9860              squareregfx:
asm_unitvector.asm(31): error: Label not found: UBnkXScaled
asm_unitvector.asm(31): warning[rdlow]: Reading memory at low address: 0
  31+ 9860 3A 00 00     	ld a,(UBnkXScaled)
  32+ 9863 57           	ld d,a
  33+ 9864 5F           	ld e,a
  34+ 9865 ED 30        	mul
  35+ 9867 EB           	ex de,hl
  36+ 9868              squareregfy:
asm_unitvector.asm(37): error: Label not found: UBnkYScaled
asm_unitvector.asm(37): warning[rdlow]: Reading memory at low address: 0
  37+ 9868 3A 00 00     	ld a, (UBnkYScaled)
  38+ 986B 57           	ld d,a
  39+ 986C 5F           	ld e,a
  40+ 986D ED 30        	mul
  41+ 986F 19           	add hl,de
  42+ 9870              squareregfz:
asm_unitvector.asm(43): error: Label not found: UBnkZScaled
asm_unitvector.asm(43): warning[rdlow]: Reading memory at low address: 0
  43+ 9870 3A 00 00     	ld a, (UBnkZScaled)
  44+ 9873 57           	ld d,a
  45+ 9874 5F           	ld e,a
  46+ 9875 ED 30        	mul
  47+ 9877 19           	add hl,de
  48+ 9878 EB           	ex de,hl			; de de to number to root
  49+ 9879              hlequsquareroot:
  50+ 9879 CD 0B 96     	call asm_sqrt		; hl = sqrt (fx^2 + fy^2 + fx^2)
  51+ 987C E5           	push hl				; save it for work 3 copies
  52+ 987D E5           	push hl				; save it for work
  53+ 987E E5           	push hl				; save it for work
  54+ 987F              normfx:
asm_unitvector.asm(55): error: Label not found: UBnkXScaled
asm_unitvector.asm(55): warning[rdlow]: Reading memory at low address: 0
  55+ 987F 3A 00 00     	ld a,(UBnkXScaled)
  56+ 9882 E1           	pop hl				; get copy #1
  57+ 9883 7D           	ld a,l				; we assume only l had worthwhile data but could spill into h
  58+ 9884 4F           	ld c,a
  59+ 9885 CD 3D 98     	call asm_tis2
asm_unitvector.asm(60): error: Label not found: UBnkXScaled
  60+ 9888 32 00 00     	ld (UBnkXScaled),a
  61+ 988B              normfy:
asm_unitvector.asm(62): error: Label not found: UBnkYScaled
asm_unitvector.asm(62): warning[rdlow]: Reading memory at low address: 0
  62+ 988B 3A 00 00     	ld a,(UBnkYScaled)
  63+ 988E E1           	pop hl				; get copy #2
  64+ 988F 7D           	ld a,l
  65+ 9890 4F           	ld c,a
  66+ 9891 CD 3D 98     	call asm_tis2
asm_unitvector.asm(67): error: Label not found: UBnkYScaled
  67+ 9894 32 00 00     	ld (UBnkYScaled),a
  68+ 9897              normfz:
asm_unitvector.asm(69): error: Label not found: UBnkZScaled
asm_unitvector.asm(69): warning[rdlow]: Reading memory at low address: 0
  69+ 9897 3A 00 00     	ld a,(UBnkZScaled)
  70+ 989A E1           	pop hl				; get copy #2
  71+ 989B 7D           	ld a,l
  72+ 989C 4F           	ld c,a
  73+ 989D CD 3D 98     	call asm_tis2
asm_unitvector.asm(74): error: Label not found: UBnkZScaled
  74+ 98A0 32 00 00     	ld (UBnkZScaled),a
  75+ 98A3              asm_unit_vector_end:
  76+ 98A3 C9           	ret
  77+ 98A4
# file closed: ../Maths/asm_unitvector.asm
 122  98A4                  INCLUDE "../Maths/compare16.asm"
# file opened: ../Maths/compare16.asm
   1+ 98A4              ; Input:
   2+ 98A4              ;       HL = 1st value
   3+ 98A4              ;       DE = 2nd value
   4+ 98A4              ; Output:
   5+ 98A4              ;       CF, ZF = results of comparison:
   6+ 98A4              ;
   7+ 98A4              ;               CF      ZF      Result
   8+ 98A4              ;               -----------------------------------
   9+ 98A4              ;               0       0       HL > DE
  10+ 98A4              ;               0       1       HL == DE
  11+ 98A4              ;               1       0       HL < DE
  12+ 98A4              ;               1       1       Impossible
  13+ 98A4              ;
  14+ 98A4
  15+ 98A4 E5           compare16HLDE:      push    hl
  16+ 98A5 A7                               and     a
  17+ 98A6 ED 52                            sbc     hl,de
  18+ 98A8 E1                               pop     hl
  19+ 98A9 C9                               ret
  20+ 98AA
  21+ 98AA              ; With compare signed we do ABS comparison
  22+ 98AA              ; this is used for view ports as we just want to know if its +/- out side of 90 degrees
  23+ 98AA
  24+ 98AA E5 D5        compare16HLDEABS:   push    hl,,de
  25+ 98AC 7C                               ld      a,h                                     ; Quick pass see of both the same sign
  26+ 98AD E6 7F                            and     SignMask8Bit
  27+ 98AF 67                               ld      h,a
  28+ 98B0 7A                               ld      a,d                                     ; Quick pass see of both the same sign
  29+ 98B1 E6 7F                            and     SignMask8Bit
  30+ 98B3 57                               ld      d,a
  31+ 98B4 A7                               and     a
  32+ 98B5 ED 52                            sbc     hl,de
  33+ 98B7 D1 E1                            pop     hl,,de
  34+ 98B9 C9                               ret
  35+ 98BA
  36+ 98BA
# file closed: ../Maths/compare16.asm
 123  98BA                  INCLUDE "../Maths/negate16.asm"
# file opened: ../Maths/negate16.asm
   1+ 98BA              ;;----------------------------------------------------------------------------------------------------------------------
   2+ 98BA              ;; 16-bit negate
   3+ 98BA              negate16:
   4+ 98BA              negate16hl:
   5+ 98BA                      ; Input:
   6+ 98BA                      ;       HL = value
   7+ 98BA                      ; Output:
   8+ 98BA                      ;       HL = -value
   9+ 98BA                      ; Destroys:
  10+ 98BA                      ;       AF
  11+ 98BA                      ;
  12+ 98BA AF           	xor 	a
  13+ 98BB 95           	sub 	l
  14+ 98BC 6F           	ld 		l,a
  15+ 98BD 9F           	sbc 	a,a
  16+ 98BE 94           	sub 	h
  17+ 98BF 67           	ld 		h,a
  18+ 98C0 C9           	ret
  19+ 98C1
  20+ 98C1              negate16de:
  21+ 98C1 AF           	xor 	a
  22+ 98C2 93           	sub 	e
  23+ 98C3 5F           	ld 		e,a
  24+ 98C4 9F           	sbc 	a,a
  25+ 98C5 92           	sub 	d
  26+ 98C6 57           	ld 		d,a
  27+ 98C7 C9           	ret
  28+ 98C8
  29+ 98C8              negate16bc:
  30+ 98C8 AF           	xor 	a
  31+ 98C9 91           	sub 	c
  32+ 98CA 4F           	ld 		c,a
  33+ 98CB 9F           	sbc 	a,a
  34+ 98CC 90           	sub 	b
  35+ 98CD 47           	ld 		b,a
  36+ 98CE C9           	ret
  37+ 98CF
  38+ 98CF
  39+ 98CF              macronegate16hl:	MACRO
  40+ 98CF ~            					xor 	a
  41+ 98CF ~            					sub 	l
  42+ 98CF ~            					ld 		l,a
  43+ 98CF ~            					sbc 	a,a
  44+ 98CF ~            					sub 	h
  45+ 98CF ~            					ld 		h,a
  46+ 98CF              					ENDM
  47+ 98CF
  48+ 98CF              macronegate16de:	MACRO
  49+ 98CF ~            					xor 	a
  50+ 98CF ~                                sub 	e
  51+ 98CF ~                                ld 		e,a
  52+ 98CF ~                                sbc 	a,a
  53+ 98CF ~                                sub 	d
  54+ 98CF ~                                ld 		d,a
  55+ 98CF              					ENDM
  56+ 98CF              macronegate16bc:	MACRO
  57+ 98CF ~            					xor 	a
  58+ 98CF ~                                sub 	c
  59+ 98CF ~                                ld 		c,a
  60+ 98CF ~                                sbc 	a,a
  61+ 98CF ~                                sub 	b
  62+ 98CF ~                                ld 		b,a
  63+ 98CF              					ENDM
  64+ 98CF
  65+ 98CF              macronegate16ix:	MACRO
  66+ 98CF ~            					xor 	a
  67+ 98CF ~                                sub 	ixl
  68+ 98CF ~                                ld 		ixl,a
  69+ 98CF ~                                sbc 	a,a
  70+ 98CF ~                                sub 	ixh
  71+ 98CF ~                                ld 		ixh,a
  72+ 98CF              					ENDM
# file closed: ../Maths/negate16.asm
 124  98CF                  INCLUDE "../Maths/normalise96.asm"
# file opened: ../Maths/normalise96.asm
   1+ 98CF DD 68        AequAdivDmul96Unsg:     ld			ixl,b						; Get sign bit passed in as bit 7 in b
   2+ 98D1                                      JumpIfAGTENusng d, TISXAccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
   2+ 98D1 BA          >                        cp     d
   2+ 98D2 D2 E7 98    >                        jp		nc,TISXAccGTEQ
   3+ 98D5 4F                                   ld			c,a
   4+ 98D6 CD 1C 97                             call		asm_div8
   5+ 98D9 79                                   ld			a,c							; a = result
   6+ 98DA CB 3F                                srl			a							; result / 4
   7+ 98DC 47                                   ld			b,a							; t = t /4
   8+ 98DD CB 3F                                srl			a							; result / 8
   9+ 98DF 80                                   add			a,b							; result /8 + result /4
  10+ 98E0 47                                   ld			b,a							; b = 3/8*Acc (max = 96)
  11+ 98E1 DD 7D                                ld			a,ixl						; copy of Acc to look at sign bit
  12+ 98E3 E6 80                                and			$80							; recover sign only
  13+ 98E5 B0                                   or			b							; now put b back in so we have a leading sign bit (note not 2's compliment)
  14+ 98E6 C9                                   ret
  15+ 98E7              TISXAccGTEQ:
  16+ 98E7              ;TI4:										;\ clean to +/- unity
  17+ 98E7 DD 7D                                ld			a,ixl     					; get saved sign from b
  18+ 98E9 E6 80                                and			$80							; copy of Acc
  19+ 98EB F6 60                                or			$60							; unity
  20+ 98ED C9                                   ret
  21+ 98EE
  22+ 98EE
  23+ 98EE
  24+ 98EE
  25+ 98EE              normaliseXX1596fast:
  26+ 98EE                  ; .NORM	\ -> &3BD6 \ Normalize 3-vector length of XX15
normalise96.asm(27): error: Label not found: XX15
normalise96.asm(27): warning[rdlow]: Reading memory at low address: 0
  27+ 98EE 3A 00 00     	ld		a,(XX15)		    ; XX15+0
  28+ 98F1 DD 67        	ld		ixh,a               ; ixh = signed x component
  29+ 98F3 E6 7F        	and		SignMask8Bit                 ; a = unsigned version
  30+ 98F5              N96SQX:
  31+ 98F5              	inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
  31+ 98F5 5F          >			ld	e,a
  31+ 98F6 57          >			ld  d,a
  31+ 98F7 ED 30       >			mul
  32+ 98F9 62           	ld		h,d					; h == varR d = varO e= varA
  33+ 98FA 6B           	ld		l,e					; l == varQ  															:: so HL = XX15[x]^2
  34+ 98FB              N96SQY:
normalise96.asm(35): error: Label not found: XX15
normalise96.asm(35): warning[rdlow]: Reading memory at low address: 1
  35+ 98FB 3A 01 00     	ld		a,(XX15+1)
  36+ 98FE DD 6F        	ld		ixl,a               ; ixl = signed y componet
  37+ 9900 E6 7F        	and		SignMask8Bit                 ; = abs
  38+ 9902              	inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2		:: so DE = XX15[y]^2
  38+ 9902 5F          >			ld	e,a
  38+ 9903 57          >			ld  d,a
  38+ 9904 ED 30       >			mul
  39+ 9906 19           	add		hl,de				; hl = XX15[x]^2 + XX15[y]^2
  40+ 9907              N96SQZ:
normalise96.asm(41): error: Label not found: XX15
normalise96.asm(41): warning[rdlow]: Reading memory at low address: 2
  41+ 9907 3A 02 00     	ld		a,(XX15+2)			; Note comments say \ ZZ15+2  should be \ XX15+2 as per code
  42+ 990A FD 67        	ld		iyh,a               ; iyh = signed
  43+ 990C E6 7F        	and		SignMask8Bit                 ; unsigned
  44+ 990E              	inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2		:: so DE = XX15[z]^2
  44+ 990E 5F          >			ld	e,a
  44+ 990F 57          >			ld  d,a
  44+ 9910 ED 30       >			mul
  45+ 9912              N96SQADD:
  46+ 9912 19           	add		hl,de				; hl = XX15[x]^2 + XX15[y]^2 + XX15[z]^2
  47+ 9913 EB           	ex		de,hl				; hl => de ready for square root
  48+ 9914              N96SQRT:
  49+ 9914 CD 0B 96     	call	asm_sqrt			; hl = sqrt(XX15[x]^2 + XX15[y]^2 + XX15[z]^2), we just are interested in l which is the new Q
  50+ 9917              N96NORMX:
normalise96.asm(51): error: Label not found: XX15
normalise96.asm(51): warning[rdlow]: Reading memory at low address: 0
  51+ 9917 3A 00 00     	ld		a,(XX15+0)
  52+ 991A E6 7F        	and		SignMask8Bit
  53+ 991C 4F           	ld		c,a
  54+ 991D 55           	ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  55+ 991E CD 45 9B     	call	AequAdivDmul96	; does not use HL so we can retain it
  56+ 9921 47           	ld		b,a				;++SGN
  57+ 9922 DD 7C        	ld		a,ixh			;++SGN
  58+ 9924 E6 80        	and		$80				;++SGN
  59+ 9926 B0           	or		b				;++SGN
normalise96.asm(60): error: Label not found: XX15
  60+ 9927 32 00 00     	ld		(XX15+0),a
  61+ 992A              N96NORMY:
normalise96.asm(62): error: Label not found: XX15
normalise96.asm(62): warning[rdlow]: Reading memory at low address: 1
  62+ 992A 3A 01 00     	ld		a,(XX15+1)
  63+ 992D E6 7F        	and		SignMask8Bit
  64+ 992F 4F           	ld		c,a
  65+ 9930 55           	ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  66+ 9931 CD 45 9B     	call	AequAdivDmul96     	; does not use HL so we can retain it
  67+ 9934 47           	ld		b,a				;++SGN
  68+ 9935 DD 7D        	ld		a,ixl			;++SGN
  69+ 9937 E6 80        	and		$80				;++SGN
  70+ 9939 B0           	or		b				;++SGN
normalise96.asm(71): error: Label not found: XX15
  71+ 993A 32 01 00     	ld		(XX15+1),a
  72+ 993D              N96NORMZ:
normalise96.asm(73): error: Label not found: XX15
normalise96.asm(73): warning[rdlow]: Reading memory at low address: 2
  73+ 993D 3A 02 00     	ld		a,(XX15+2)
  74+ 9940 E6 7F        	and		SignMask8Bit
  75+ 9942 4F           	ld		c,a
  76+ 9943 55           	ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  77+ 9944 CD 45 9B     	call	AequAdivDmul96	; does not use HL so we can retain it
  78+ 9947 47           	ld		b,a				;++SGN
  79+ 9948 FD 7C        	ld		a,iyh			;++SGN
  80+ 994A E6 80        	and		$80				;++SGN
  81+ 994C B0           	or		b				;++SGN
normalise96.asm(82): error: Label not found: XX15
  82+ 994D 32 02 00     	ld		(XX15+2),a
  83+ 9950 C9           	ret
  84+ 9951
  85+ 9951              ; Normalise vector
  86+ 9951              ; scale Q = Sqrt (X^2 + Y^2 + Z^2)
  87+ 9951              ; X = X / Q with 96 = 1 , i.e X = X / Q * 3/8
  88+ 9951              ; Y = Y / Q with 96 = 1 , i.e Y = Y / Q * 3/8
  89+ 9951              ; Z = Z / Q with 96 = 1 , i.e Z = Z / Q * 3/8
  90+ 9951              ;
  91+ 9951              ;
  92+ 9951              ;
  93+ 9951
  94+ 9951              ; .NORM	\ -> &3BD6 \ Normalize 3-vector length of XX15
normalise96.asm(95): error: Label not found: XX15
normalise96.asm(95): warning[rdlow]: Reading memory at low address: 0
  95+ 9951 3A 00 00     normaliseXX1596:        ld		a,(XX15)		    ; XX15+0
  96+ 9954                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
  96+ 9954 5F          >			ld	e,a
  96+ 9955 57          >			ld  d,a
  96+ 9956 ED 30       >			mul
  97+ 9958 7A                                   ld		a,d
  98+ 9959 32 0E 84                             ld		(varR),a			; R	 \ hi sum later use b
  99+ 995C 7B                                   ld		a,e
 100+ 995D 32 0D 84                             ld		(varQ),a			; Q	 \ lo sum later use c
 101+ 9960 32 0A 83                             ld		(varP),a			; P	 \ lo sum later just drop
normalise96.asm(102): error: Label not found: XX15
normalise96.asm(102): warning[rdlow]: Reading memory at low address: 1
 102+ 9963 3A 01 00                             ld		a,(XX15+1)
 103+ 9966                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
 103+ 9966 5F          >			ld	e,a
 103+ 9967 57          >			ld  d,a
 103+ 9968 ED 30       >			mul
 104+ 996A 7A                                   ld		a,d
 105+ 996B 32 29 84                             ld		(varT),a			; T	 \ hi sum
 106+ 996E 7B                                   ld		a,e
 107+ 996F 32 0A 83                             ld		(varP),a			; P	 \ lo sum
 108+ 9972 21 0D 84                             ld		hl,varQ
 109+ 9975 8E                                   adc		a,(hl)				; +Q
 110+ 9976 32 0D 84                             ld		(varQ),a			; =>Q
 111+ 9979 3A 29 84                             ld		a,(varT)			;
 112+ 997C 21 0E 84                             ld		hl,varR
 113+ 997F 8E                                   adc		a,(hl)				;  R
 114+ 9980 32 0E 84                             ld		(varR),a			; R
normalise96.asm(115): error: Label not found: XX15
normalise96.asm(115): warning[rdlow]: Reading memory at low address: 2
 115+ 9983 3A 02 00                             ld		a,(XX15+2)			; Note comments say \ ZZ15+2  should be \ XX15+2 as per code
 116+ 9986                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
 116+ 9986 5F          >			ld	e,a
 116+ 9987 57          >			ld  d,a
 116+ 9988 ED 30       >			mul
 117+ 998A 7A                                   ld		a,d
 118+ 998B 32 29 84                             ld		(varT),a			; T	 \ hi sum
 119+ 998E 7B                                   ld		a,e
 120+ 998F 32 0A 83                             ld		(varP),a			; P	 \ lo sum
 121+ 9992 21 0D 84                             ld		hl,varQ
 122+ 9995 8E                                   adc		a,(hl)				; +Q
 123+ 9996 32 0D 84                             ld		(varQ),a			; =>Q  xlo2 + ylo2 + zlo2
 124+ 9999 3A 29 84                             ld		a,(varT)			; T temp Hi
 125+ 999C 21 0E 84                             ld		hl,varR
 126+ 999F 8E                                   adc		a,(hl)				; +R
 127+ 99A0 32 0E 84                             ld		(varR),a			; R
 128+ 99A3 CD 2E 96                             call	sqrtQR				; Q = SQR(Qlo.Rhi) Q <~127
normalise96.asm(129): error: Label not found: XX15
normalise96.asm(129): warning[rdlow]: Reading memory at low address: 0
 129+ 99A6 3A 00 00                             ld		a,(XX15+0)
 130+ 99A9 CD 3F 9B                             call	AequAdivQmul96		;  TIS2 \ *96/Q
normalise96.asm(131): error: Label not found: XX15
 131+ 99AC 32 00 00                             ld		(XX15+0),a
normalise96.asm(132): error: Label not found: XX15
normalise96.asm(132): warning[rdlow]: Reading memory at low address: 1
 132+ 99AF 3A 01 00                             ld		a,(XX15+1)
 133+ 99B2 CD 3F 9B                             call	AequAdivQmul96		;  TIS2 \ *96/Q
normalise96.asm(134): error: Label not found: XX15
 134+ 99B5 32 01 00                             ld		(XX15+1),a
normalise96.asm(135): error: Label not found: XX15
normalise96.asm(135): warning[rdlow]: Reading memory at low address: 1
 135+ 99B8 3A 01 00                             ld		a,(XX15+1)
 136+ 99BB CD 3F 9B                             call	AequAdivQmul96		;  TIS2 \ *96/Q
normalise96.asm(137): error: Label not found: XX15
 137+ 99BE 32 01 00                             ld		(XX15+1),a
 138+ 99C1 C9                                   ret
 139+ 99C2
 140+ 99C2
# file closed: ../Maths/normalise96.asm
 125  99C2                  INCLUDE "../Maths/binary_to_decimal.asm"
# file opened: ../Maths/binary_to_decimal.asm
   1+ 99C2              ;Number in hl to decimal ASCII
   2+ 99C2              ;Thanks to z80 Bits
   3+ 99C2              ;inputs:	hl = number to ASCII
   4+ 99C2              ;example: hl=300 outputs '00300'
   5+ 99C2              ;destroys: af, bc, hl, de used
   6+ 99C2              DispHLtoDE:
   7+ 99C2              ; "DispHL, writes HL to DE address"
   8+ 99C2 01 F0 D8     	ld	bc,-10000
   9+ 99C5 CD DB 99     	call	Num1
  10+ 99C8 01 18 FC     	ld	bc,-1000
  11+ 99CB CD DB 99     	call	Num1
  12+ 99CE 01 9C FF     	ld	bc,-100
  13+ 99D1 CD DB 99     	call	Num1
  14+ 99D4 0E F6        	ld	c,-10
  15+ 99D6 CD DB 99     	call	Num1
  16+ 99D9 0E FF        	ld	c,-1
  17+ 99DB              Num1:
  18+ 99DB 3E 2F        	ld	a,'0'-1
  19+ 99DD              .Num2:
  20+ 99DD 3C           	inc	a
  21+ 99DE 09           	add	hl,bc
  22+ 99DF 38 FC        	jr	c,.Num2
  23+ 99E1 ED 42        	sbc	hl,bc
  24+ 99E3 12           	ld	(de),a
  25+ 99E4 13           	inc	de
  26+ 99E5 C9           	ret
  27+ 99E6
  28+ 99E6              DispAtoDE:
  29+ 99E6 26 00        	ld h,0
  30+ 99E8 6F           	ld l,a
  31+ 99E9 C3 C2 99     	jp DispHLtoDE
  32+ 99EC
  33+ 99EC              DispPriceAtoDE:
  34+ 99EC 26 00        	ld h,0
  35+ 99EE 6F           	ld l,a
  36+ 99EF 01 9C FF     	ld	bc,-100
  37+ 99F2 CD 02 9A     	call	.NumLeadBlank1
  38+ 99F5 0E F6        	ld	c,-10
  39+ 99F7 CD DB 99     	call	Num1
  40+ 99FA 3E 2E        	ld		a,'.'					; we could assume preformat but
  41+ 99FC 12           	ld		(de),a					; we can optimse that later TODO
  42+ 99FD 13           	inc		de						; with just an inc De
  43+ 99FE 0E FF        	ld	c,-1
  44+ 9A00 18 D9        	jr		Num1
  45+ 9A02              .NumLeadBlank1:
  46+ 9A02 3E 2F        	ld	a,'0'-1
  47+ 9A04              .NumLeadBlank2:
  48+ 9A04 3C           	inc	a
  49+ 9A05 09           	add	hl,bc
  50+ 9A06 38 FC        	jr	c,.NumLeadBlank2
  51+ 9A08 FE 30        	cp	'0'
  52+ 9A0A 20 02        	jr	nz,.DontBlank
  53+ 9A0C              .Blank:
  54+ 9A0C 3E 20        	ld	a,' '
  55+ 9A0E              .DontBlank:
  56+ 9A0E ED 42        	sbc	hl,bc
  57+ 9A10 12           	ld	(de),a
  58+ 9A11 13           	inc	de
  59+ 9A12 C9           	ret
  60+ 9A13
  61+ 9A13              DispQtyAtoDE:
  62+ 9A13 FE 00        	cp	0
  63+ 9A15 28 23        	jr	z,.NoStock
  64+ 9A17 26 00        	ld h,0
  65+ 9A19 6F           	ld l,a
  66+ 9A1A 01 9C FF     	ld	bc,-100
  67+ 9A1D CD 29 9A     	call	.NumLeadBlank1
  68+ 9A20 0E F6        	ld	c,-10
  69+ 9A22 CD 29 9A     	call	.NumLeadBlank1
  70+ 9A25 0E FF        	ld	c,-1
  71+ 9A27 18 B2        	jr		Num1
  72+ 9A29              .NumLeadBlank1:
  73+ 9A29 3E 2F        	ld	a,'0'-1
  74+ 9A2B              .NumLeadBlank2:
  75+ 9A2B 3C           	inc	a
  76+ 9A2C 09           	add	hl,bc
  77+ 9A2D 38 FC        	jr	c,.NumLeadBlank2
  78+ 9A2F FE 30        	cp	'0'
  79+ 9A31 20 02        	jr	nz,.DontBlank
  80+ 9A33              .Blank:
  81+ 9A33 3E 20        	ld	a,' '
  82+ 9A35              .DontBlank:
  83+ 9A35 ED 42        	sbc	hl,bc
  84+ 9A37 12           	ld	(de),a
  85+ 9A38 13           	inc	de
  86+ 9A39 C9           	ret
  87+ 9A3A              .NoStock:
  88+ 9A3A 3E 20        	ld	a,' '
  89+ 9A3C 12           	ld	(de),a
  90+ 9A3D 13           	inc	de
  91+ 9A3E 12           	ld	(de),a
  92+ 9A3F 13           	inc	de
  93+ 9A40 3E 2D        	ld	a,'-'
  94+ 9A42 12           	ld	(de),a
  95+ 9A43 13           	inc de
  96+ 9A44 C9           	ret
  97+ 9A45
  98+ 9A45
  99+ 9A45              ;### CLCN32 -> Converts 32Bit-Value in ASCII-String (terminated by 0)
 100+ 9A45              ;### Input      DE,IX=32bit value, IY=destination address
 101+ 9A45              ;### Output     IY=last char in destination string
 102+ 9A45              ;### Destroyed AF,BC,DE,HL,IX
 103+ 9A45 01 00 00 00  clcn32t dw 1,0,     10,0,     100,0,     1000,0,       10000,0
 103+ 9A49 0A 00 00 00
 103+ 9A4D 64 00 00 00
 103+ 9A51 E8 03 00 00
 103+ 9A55 10 27 00 00
 104+ 9A59 A0 86 01 00          dw $86a0,1, $4240,$0f, $9680,$98, $e100,$05f5, $ca00,$3b9a
 104+ 9A5D 40 42 0F 00
 104+ 9A61 80 96 98 00
 104+ 9A65 00 E1 F5 05
 104+ 9A69 00 CA 9A 3B
 105+ 9A6D 00 00 00 00  clcn32z ds 4
 106+ 9A71
 107+ 9A71              ; As per display but shifts final digit by 1 and puts in "." for 1 decimal place
 108+ 9A71 CD 80 9A     DispDEIXtoIY1DP:        call    DispDEIXtoIY
 109+ 9A74 FD 7E 00                             ld      a,(IY+0)
 110+ 9A77 FD 77 01                             ld      (IY+1),a
 111+ 9A7A 3E 2E                                ld      a,"."
 112+ 9A7C FD 77 00                             ld      (IY+0),a
 113+ 9A7F C9                                   ret
 114+ 9A80
 115+ 9A80 DD 22 6D 9A  DispDEIXtoIY:           ld (clcn32z),ix
 116+ 9A84 ED 53 6F 9A                          ld (clcn32z+2),de
 117+ 9A88 DD 21 69 9A                          ld ix,clcn32t+36
 118+ 9A8C 06 09                                ld b,9
 119+ 9A8E 0E 00                                ld c,0
 120+ 9A90 3E 30        .clcn321:               ld a,'0'
 121+ 9A92 B7                                   or a
 122+ 9A93 DD 5E 00     .clcn322:               ld e,(ix+0)
 123+ 9A96 DD 56 01                             ld d,(ix+1)
 124+ 9A99 2A 6D 9A                             ld hl,(clcn32z)
 125+ 9A9C ED 52                                sbc hl,de
 126+ 9A9E 22 6D 9A                             ld (clcn32z),hl
 127+ 9AA1 DD 5E 02                             ld e,(ix+2)
 128+ 9AA4 DD 56 03                             ld d,(ix+3)
 129+ 9AA7 2A 6F 9A                             ld hl,(clcn32z+2)
 130+ 9AAA ED 52                                sbc hl,de
 131+ 9AAC 22 6F 9A                             ld (clcn32z+2),hl
 132+ 9AAF 38 04                                jr c,.clcn325
 133+ 9AB1 0C                                   inc c
 134+ 9AB2 3C                                   inc a
 135+ 9AB3 18 DE                                jr .clcn322
 136+ 9AB5 DD 5E 00     .clcn325:               ld e,(ix+0)
 137+ 9AB8 DD 56 01                             ld d,(ix+1)
 138+ 9ABB 2A 6D 9A                             ld hl,(clcn32z)
 139+ 9ABE 19                                   add hl,de
 140+ 9ABF 22 6D 9A                             ld (clcn32z),hl
 141+ 9AC2 DD 5E 02                             ld e,(ix+2)
 142+ 9AC5 DD 56 03                             ld d,(ix+3)
 143+ 9AC8 2A 6F 9A                             ld hl,(clcn32z+2)
 144+ 9ACB ED 5A                                adc hl,de
 145+ 9ACD 22 6F 9A                             ld (clcn32z+2),hl
 146+ 9AD0 11 FC FF                             ld de,-4
 147+ 9AD3 DD 19                                add ix,de
 148+ 9AD5 0C                                   inc c
 149+ 9AD6 0D                                   dec c
 150+ 9AD7 28 05                                jr z,.clcn323
 151+ 9AD9 FD 77 00                             ld (iy+0),a
 152+ 9ADC FD 23                                inc iy
 153+ 9ADE 10 B0        .clcn323:               djnz .clcn321
 154+ 9AE0 3A 6D 9A                             ld a,(clcn32z)
 155+ 9AE3 C6 30                                add A,'0'
 156+ 9AE5 FD 77 00                             ld (iy+0),a
 157+ 9AE8 FD 36 01 00                          ld (iy+1),0
 158+ 9AEC C9                                   ret
 159+ 9AED
# file closed: ../Maths/binary_to_decimal.asm
 126  9AED                  include "../Maths/ADDHLDESignBC.asm"
# file opened: ../Maths/ADDHLDESignBC.asm
   1+ 9AED              ;; calcs HLB + DEC where B and C are signs
   2+ 9AED              ;; result HL with A as sign
   3+ 9AED              ;; special handling if result is zero forcign sign bit to be zero
   4+ 9AED 78           ADDHLDESignBC:          ld      a,b
   5+ 9AEE E6 80                                and     SignOnly8Bit
   6+ 9AF0 A9                                   xor     c                           ;if b sign and c sign were different then bit 7 of a will be 1 which means
   7+ 9AF1                                      JumpIfNegative ADDHLDEsBCOppSGN     ;Signs are opposite there fore we can subtract to get difference
   7+ 9AF1 FA FF 9A    >                        jp		m, ADDHLDEsBCOppSGN
   8+ 9AF4 78           ADDHLDEsBCSameSigns:    ld      a,b
   9+ 9AF5 B1                                   or      c
  10+ 9AF6                                      JumpIfNegative ADDHLDEsBCSameNeg        ; optimisation so we can just do simple add if both positive
  10+ 9AF6 FA FB 9A    >                        jp		m, ADDHLDEsBCSameNeg
  11+ 9AF9 19                                   add     hl,de                       ; both positive so a will already be zero
  12+ 9AFA C9                                   ret
  13+ 9AFB 19           ADDHLDEsBCSameNeg:      add     hl,de
  14+ 9AFC 78                                   ld      a,b
  15+ 9AFD B1                                   or      c                           ; now set bit for negative value, we won't bother with overflow for now TODO
  16+ 9AFE C9                                   ret
  17+ 9AFF B7           ADDHLDEsBCOppSGN:       or      a
  18+ 9B00 ED 52                                sbc     hl,de
  19+ 9B02 38 02                                jr      c,ADDHLDEsBCOppInvert
  20+ 9B04 78           ADDHLDEsBCOppSGNNoCarry: ld      a,b                                               ; we got here so hl > de therefore we can just take hl's previous sign bit
  21+ 9B05 C9                                   ret
  22+ 9B06              ADDHLDEsBCOppInvert:    NegHL                         ; if result was zero then set sign to zero (which doing h or l will give us for free)
  22+ 9B06 AF          >                    xor a
  22+ 9B07 95          >                    sub l
  22+ 9B08 6F          >                    ld l,a
  22+ 9B09 9F          >                    sbc a,a
  22+ 9B0A 94          >                    sub h
  22+ 9B0B 67          >                    ld h,a
  23+ 9B0C 78                                   ld      a,b
  24+ 9B0D EE 80                                xor     SignOnly8Bit                ; flip sign bit
  25+ 9B0F C9                                   ret
  26+ 9B10
# file closed: ../Maths/ADDHLDESignBC.asm
 127  9B10                  INCLUDE "../Maths/Utilities/AequAdivQmul96-TIS2.asm"
# file opened: ../Maths/Utilities/AequAdivQmul96-TIS2.asm
   1+ 9B10              AequAdivQmul96ABS:      JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
   1+ 9B10 BA          >                        cp     d
   1+ 9B11 D2 2C 9B    >                        jp		nc,.TIS2AccGTEQ
   2+ 9B14 06 FE                                ld			b,$FE						; division roll (replaced varT)
   3+ 9B16 CB 27        .TIS2RollTLoop:			sla			a
   4+ 9B18                                      JumpIfALTNusng d,.TIS2SkipSub           ; a < d so don;t subtract
   4+ 9B18 BA          >                        cp      d
   4+ 9B19 DA 2F 9B    >                        jp		c, .TIS2SkipSub
   5+ 9B1C 9A                                   sbc			a,d							; do subtraction with carry
   6+ 9B1D 37                                   scf
   7+ 9B1E CB 10                                rl			b							; T rolled left to push bit out the end
   8+ 9B20 38 F4                                jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
   9+ 9B22 78           .TIS2SKIPCont:	        ld			a,b							; T
  10+ 9B23 CB 3F                                srl			a							; result / 2
  11+ 9B25 CB 3F                                srl			a							; result / 4
  12+ 9B27 47                                   ld			b,a							; t = t /4
  13+ 9B28 CB 3F                                srl			a							; result / 8
  14+ 9B2A 80                                   add			a,b							; result /8 + result /4
  15+ 9B2B C9                                   ret
  16+ 9B2C 3E 60        .TIS2AccGTEQ:           ld			a,$60							; unity
  17+ 9B2E C9                                   ret
  18+ 9B2F B7           .TIS2SkipSub:           or			a
  19+ 9B30 CB 10                                rl			b							; T rolled left to push bit out the end
  20+ 9B32 38 E2                                jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
  21+ 9B34 C3 22 9B                             jp			.TIS2SKIPCont
  22+ 9B37
  23+ 9B37
  24+ 9B37              ; USES 			A DE BC
  25+ 9B37              ; DOES NOT USE 	HL
  26+ 9B37              TIS2962C:		; two's compliment entry point, exits not 2's compliment
  27+ 9B37 CB 7F        	bit			7,a
  28+ 9B39 28 04        	jr			z,AequAdivQmul96
  29+ 9B3B ED 44        	neg										; revers 2s'c and just set neg bit
  30+ 9B3D CB FF        	set			7,a
  31+ 9B3F              ; Note negative numbers are bit 7 set not 2's compliment
  32+ 9B3F              AequAdivQmul96:								; TIS296:			; .tis2 A = A /Q *96 (or A = A * 3/8 * Q) Reduce Acc in NORM routine i.e. *96/Q clamps at +- 96
  33+ 9B3F              TIS2:
  34+ 9B3F 4F           	ld			c,a							; copy of Acc
  35+ 9B40 3A 0D 84     	ld			a,(varQ)
  36+ 9B43 57           	ld			d,a							; d = varQ
  37+ 9B44 79           	ld			a,c							; recover a
  38+ 9B45              AequAdivDmul96:
  39+ 9B45 4F           	ld			c,a							; copy of Acc as we need the sign, alternate entry point assuming D preloaded, wastes an "ld c,a" but simplifies code
  40+ 9B46 E6 7F        	and			SignMask8Bit				; ignore sign
  41+ 9B48              	JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
  41+ 9B48 BA          >                        cp     d
  41+ 9B49 D2 69 9B    >                        jp		nc,.TIS2AccGTEQ
  42+ 9B4C 06 FE        	ld			b,$FE						; division roll (replaced varT)
  43+ 9B4E              .TIS2RollTLoop:									; .TIL2	; roll T
  44+ 9B4E CB 27        	sla			a
  45+ 9B50              	JumpIfALTNusng d,.TIS2SkipSub            ; a < d so don;t subtract
  45+ 9B50 BA          >                        cp      d
  45+ 9B51 DA 6F 9B    >                        jp		c, .TIS2SkipSub
  46+ 9B54 9A           	sbc			a,d							; do subtraction with carry
  47+ 9B55 37           	scf
  48+ 9B56 CB 10        	rl			b							; T rolled left to push bit out the end
  49+ 9B58 38 F4        	jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
  50+ 9B5A              .TIS2SKIPCont:
  51+ 9B5A 78           	ld			a,b							; T
  52+ 9B5B CB 3F        	srl			a							; result / 2
  53+ 9B5D CB 3F        	srl			a							; result / 4
  54+ 9B5F 47           	ld			b,a							; t = t /4
  55+ 9B60 CB 3F        	srl			a							; result / 8
  56+ 9B62 80           	add			a,b							; result /8 + result /4
  57+ 9B63 47           	ld			b,a							; b = 3/8*Acc (max = 96)
  58+ 9B64 79           	ld			a,c							; copy of Acc to look at sign bit
  59+ 9B65 E6 80        	and			$80							; recover sign only
  60+ 9B67 B0           	or			b							; now put b back in so we have a leading sign bit (note not 2's compliment)
  61+ 9B68 C9           	ret
  62+ 9B69              .TIS2AccGTEQ:
  63+ 9B69              ;TI4:										;\ clean to +/- unity
  64+ 9B69 79           	ld			a,c
  65+ 9B6A E6 80        	and			$80							; copy of Acc
  66+ 9B6C F6 60        	or			$60							; unity
  67+ 9B6E C9           	ret
  68+ 9B6F              .TIS2SkipSub:
  69+ 9B6F B7           	or			a
  70+ 9B70 CB 10        	rl			b							; T rolled left to push bit out the end
  71+ 9B72 38 DA        	jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
  72+ 9B74 C3 5A 9B     	jp			.TIS2SKIPCont
  73+ 9B77
# file closed: ../Maths/Utilities/AequAdivQmul96-TIS2.asm
 128  9B77                  INCLUDE "../Maths/Utilities/AequAmulQdiv256-FMLTU.asm"
# file opened: ../Maths/Utilities/AequAmulQdiv256-FMLTU.asm
   1+ 9B77              fmltu:
   2+ 9B77              AequAmulQdiv256:
   3+ 9B77              ; "ASM_FMUTKL .FMLTU	\ -> &2847  \ A=A*Q/256unsg  Fast multiply"
   4+ 9B77 57           	ld	d,a
   5+ 9B78 3A 0D 84     	ld	a,(varQ)
   6+ 9B7B 5F           	ld	e,a
   7+ 9B7C ED 30        	mul
   8+ 9B7E 7A           	ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
   9+ 9B7F C9           	ret
  10+ 9B80
# file closed: ../Maths/Utilities/AequAmulQdiv256-FMLTU.asm
 129  9B80                  INCLUDE "../Maths/Utilities/PRequSpeedDivZZdiv8-DV42-DV42IYH.asm"
# file opened: ../Maths/Utilities/PRequSpeedDivZZdiv8-DV42-DV42IYH.asm
   1+ 9B80              ; "DV42,DV42IYH DE = P.R, c = R"
   2+ 9B80              DV42IYH:									; as per DV42 but using iyl for Y reg
   3+ 9B80 21 ED 86     		ld		hl,varDustZ
   4+ 9B83 FD 7D        		ld		a,iyl
   5+ 9B85 ED 31        		add		hl,a
   6+ 9B87 7E           		ld		a,(hl)
   7+ 9B88 C3 94 9B     		jp		DV41
   8+ 9B8B              DV42:										; travel step of dust particle front/rear
   9+ 9B8B 21 ED 86     		ld		hl,varDustZ
  10+ 9B8E 3A F8 82     		ld		a,(regY)
  11+ 9B91 ED 31        		add		hl,a
  12+ 9B93 7E           		ld		a,(hl)						; a = SZ[y]
  13+ 9B94              DV41:										; P.R = speed/ (ZZ/8) dust left/right
  14+ 9B94 5F           		ld		e,a							; using E as Q var replacement
  15+ 9B95 3A 09 84     		ld		a,(DELTA)					; DELTA \ speed, how far has dust moved based on its z-coord.
  16+ 9B98              DVID4:										; P-R=A/Qunsg  \P.R = A/Q unsigned called by Hall
  17+ 9B98 06 08        		ld		b,8							; counter
  18+ 9B9A CB 27        		sla		a							;
  19+ 9B9C 57           		ld		d,a							; use d for - p = delta * 2
  20+ 9B9D AF           		xor		a
  21+ 9B9E              DVL4:										; counter x loop (b reg)
  22+ 9B9E CB 17        		rl		a							; a = a * 2
  23+ 9BA0 38 03        		jr		c,DV8						; jump on carry
  24+ 9BA2 BB           		cp		e							; var Q
  25+ 9BA3 38 02        		jr		c,DV5						; skip subtraction
  26+ 9BA5              DV8:
  27+ 9BA5 9B           		sbc		a,e							; a = a - q (with carry)
  28+ 9BA6 37           		scf									;  carry gets set
  29+ 9BA7              DV5:										; skipped subtraction
  30+ 9BA7 CB 12        		rl		d							; d (P hi)
  31+ 9BA9 10 F3        		djnz	DVL4						; dec b and loop loop X, hi left in P.
  32+ 9BAB              .CalcRemainder:								; BFRDIV R=A*256/Q
  33+ 9BAB              ; Note we are not going to call LL28+4 but inline code here:
  34+ 9BAB 06 FE        		ld		b,$FE						; remainder R for AofQ *256/Q
  35+ 9BAD 4F           		ld		c,a							; use c as R var
  36+ 9BAE              .RollRemainder:
  37+ 9BAE CB 27        		sla		a
  38+ 9BB0 38 11        		jr		c,.Reduce					; if a >> generates carry reduce
  39+ 9BB2 B8           		cp		b							; a < q?
  40+ 9BB3 30 01        		jr		nc,.DontSBC
  41+ 9BB5              .DoSBC:										; a is < q
  42+ 9BB5 98           		sbc		a,b							; 	a -= q
  43+ 9BB6              .DontSBC:
  44+ 9BB6 CB 11        		rl		c							; r << 1
  45+ 9BB8 38 F4        		jr		c, .RollRemainder			; if rol generated a carry, continue
  46+ 9BBA 79           		ld		a,c
  47+ 9BBB 32 0E 84     		ld		(varR),a					; for backwards compat
  48+ 9BBE 7A           		ld		a,d
  49+ 9BBF 32 0A 83     		ld		(varP),a
  50+ 9BC2 C9           		ret									; R (c) left with remainder
  51+ 9BC3              .Reduce:									; a geneated a carry
  52+ 9BC3 98           		sbc		a,b							; a = a - (q +1)
  53+ 9BC4 37           		scf									; set carry flag for rl
  54+ 9BC5 CB 11        		rl		c							; r << 1 briging in carry
  55+ 9BC7 38 E5        		jr		c,	.RollRemainder			; if a carry fell off bit 7 then repeat
  56+ 9BC9 79           		ld		a,c
  57+ 9BCA 32 0E 84     		ld		(varR),a					; for backwards compat
  58+ 9BCD 7A           		ld		a,d
  59+ 9BCE 32 0A 83     		ld		(varP),a
  60+ 9BD1 C9           		ret
  61+ 9BD2              .AnswerTooBig:
  62+ 9BD2 0E FF        		ld		c,$FF						; arse its too big
  63+ 9BD4 79           		ld		a,c
  64+ 9BD5 32 0E 84     		ld		(varR),a					; for backwards compat
  65+ 9BD8 7A           		ld		a,d
  66+ 9BD9 32 0A 83     		ld		(varP),a
  67+ 9BDC C9           		ret
  68+ 9BDD
# file closed: ../Maths/Utilities/PRequSpeedDivZZdiv8-DV42-DV42IYH.asm
 130  9BDD                  INCLUDE "../Maths/Utilities/AequDmulEdiv256usgn-DEFMUTL.asm"
# file opened: ../Maths/Utilities/AequDmulEdiv256usgn-DEFMUTL.asm
   1+ 9BDD
   2+ 9BDD              asm_defmutl:
   3+ 9BDD              AequDmulEdiv256usgn:
   4+ 9BDD              ; "ASM_FMUTKL .FMLTU	\ -> &2847  \ A=D*E/256unsg  Fast multiply"
   5+ 9BDD ED 30        	mul
   6+ 9BDF 7A           	ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
   7+ 9BE0 C9           	ret
   8+ 9BE1
   9+ 9BE1
# file closed: ../Maths/Utilities/AequDmulEdiv256usgn-DEFMUTL.asm
 131  9BE1                  INCLUDE "../Maths/Utilities/APequQmulA-MULT1.asm"
# file opened: ../Maths/Utilities/APequQmulA-MULT1.asm
   1+ 9BE1              APequQmulA:
   2+ 9BE1              asm_mult1:
   3+ 9BE1              ; "ASM_MULT1 (DE) A(hi).P(lo) = Q * A first part of MAD, multiply and add. Visited Quite often. A=hi P = lo also returns result in DE"
   4+ 9BE1 FE 00        	cp	0
   5+ 9BE3 28 1F        	jr	z,.mul0			; quick exit if its Q * 0
   6+ 9BE5 5F           	ld	e,a
   7+ 9BE6 3A 0D 84     	ld	a,(varQ)
   8+ 9BE9 57           	ld	d,a
   9+ 9BEA FE 00        	cp	0				; compare a
  10+ 9BEC 28 16        	jr	z,.mul0			; quick exit if its 0 * a
  11+ 9BEE AB           	xor	e				; -- = + +- = - -+ = - ++ = +
  12+ 9BEF E6 80        	and $80				; get the resultant sign and save into b
  13+ 9BF1 47           	ld	b,a
  14+ 9BF2 7A           	ld	a,d
  15+ 9BF3 E6 7F        	and	SignMask8Bit	; now strip off sign bits
  16+ 9BF5 57           	ld	d,a
  17+ 9BF6 7B           	ld	a,e
  18+ 9BF7 E6 7F        	and SignMask8Bit
  19+ 9BF9 5F           	ld	e,a
  20+ 9BFA ED 30        	mul					; zxn de = d * e
  21+ 9BFC 7B           	ld	a,e
  22+ 9BFD 32 0A 83     	ld	(varP),a		; p = lo
  23+ 9C00 7A           	ld	a,d				; a = hi
  24+ 9C01 B0           	or	b				; de goes to a and varP also re-do sign bit
  25+ 9C02 57           	ld	d,a				; we will work with de having result as we may bin vars later
  26+ 9C03 C9           	ret
  27+ 9C04              .mul0:
  28+ 9C04 AF           	xor	a
  29+ 9C05 32 0A 83     	ld	(varP),a
  30+ 9C08 57           	ld	d,a
  31+ 9C09 5F           	ld  e,a
  32+ 9C0A C9           	ret
  33+ 9C0B
# file closed: ../Maths/Utilities/APequQmulA-MULT1.asm
 132  9C0B                  INCLUDE "../Maths/Utilities/badd_ll38.asm"
# file opened: ../Maths/Utilities/badd_ll38.asm
   1+ 9C0B              baddll38:				;.LL38	\ -> &4812 \ BADD(S)A=R+Q(SA) \ byte add (subtract)   (Sign S)A = R + Q*(Sign from A^S)
   2+ 9C0B              SAEquSRPlusAQ:
   3+ 9C0B              ; Calculate the following between sign-magnitude numbers:
   4+ 9C0B              ;   (S A) = (S R) + (A Q)
   5+ 9C0B              ; where the sign bytes only contain the sign bits, not magnitudes.
   6+ 9C0B              ; note goes wrong at <-127 >128 so need 16 bit version
   7+ 9C0B              ; so need to fix the issue with carry flag not returning a fault correctly
   8+ 9C0B              LL38:
   9+ 9C0B              ;	ld		d,a
  10+ 9C0B              ;	ld		a,(varQ)
  11+ 9C0B              ;	ld		e,a
  12+ 9C0B              ;	ld		a,(varS)
  13+ 9C0B              ;	ld		h,a
  14+ 9C0B              ;	ld		a,(varR)
  15+ 9C0B              ;	ld		l,a
  16+ 9C0B              ;	call	ADDHLDESignedv3
  17+ 9C0B              ;	ld		a,h
  18+ 9C0B              ;	ld		(varS),a
  19+ 9C0B              ;	ld		a,l
  20+ 9C0B              ;	ret
  21+ 9C0B              ; calculation table
  22+ 9C0B              ;   R     Q    Op            Sign calc
  23+ 9C0B              ;	10    5    Add           +    sign same add R sign
  24+ 9C0B              ;   -10   5    ABS Sub       -    sign diff ABS R > S sub R sign
  25+ 9C0B              ;   10   -5    ABS sub       +    sign diff ABS R > S sub R sign
  26+ 9C0B              ;	-10  -5    ABS Add       -    sign same add R sign
  27+ 9C0B              ;   5    10    Add           +    sign same add R sign
  28+ 9C0B              ;   -5   10    Swap ABS SUB  +    sign diff ABS Q > R swap SUB Q sign
  29+ 9C0B              ;   5    -10   swap ABS Sub  -    sign diff ABS Q > R swap SUB R sign
  30+ 9C0B              ;   -5   -10   ABS  add      -    sign same add R sign
  31+ 9C0B
  32+ 9C0B              ;   -10   5    ABS Sub       -    sign diff ABS R > S sub R sign
  33+ 9C0B              ;   10   -5    ABS sub       +    sign diff ABS R > S sub R sign
  34+ 9C0B              ;   -5   10    Swap ABS SUB  +    sign diff ABS Q > R swap SUB Q sign
  35+ 9C0B              ;   5    -10   swap ABS Sub  -    sign diff ABS Q > R swap SUB R sign
  36+ 9C0B
  37+ 9C0B
  38+ 9C0B              ; Calculate sign for Q from A and varS
  39+ 9C0B 21 0F 84     	ld		hl,varS							;
  40+ 9C0E AE           	xor		(hl)							;  EOR &83		\ S	\ sign of operator is A xor S
  41+ 9C0F FA 1A 9C     	jp		m,.LL39Subtraction  			; if signs are different then we have subtraction
  42+ 9C12 3A 0D 84     	ld		a,(varQ)						; Q	\ else addition, S already correct
  43+ 9C15 21 0E 84     	ld		hl,varR
  44+ 9C18 86           	add		a,(hl)							; a = Q + R
  45+ 9C19 C9           	ret										; Done carry set if overflow
  46+ 9C1A              .LL39Subtraction:							; 1 byte subtraction (S)A = R-Q
  47+ 9C1A 3A 0E 84     	ld		a,(varR)						; a = R
  48+ 9C1D 21 0D 84     	ld		hl,varQ                         ; Q
  49+ 9C20              ;--	JumpIfALTMemHLusng LL39SwapSubtraction	; if a < (hl) then do LL39SwapSubtraction
  50+ 9C20              	ClearCarryFlag                          ; we need to not use carry (6502 is different that it uses the compliement)
  50+ 9C20 B7          >                        or a
  51+ 9C21 9E           	sbc		a,(hl)							; A = R - Q which as R >= Q will always be a positive result
  52+ 9C22 38 01            jr      c,.LL39SignCorrection
  53+ 9C24              ;--    jr      a,.LL39ResultZero
  54+ 9C24              ;--   JumpIfNegative LL39SignCorrection		; if there was underflow we have to correct sign
  55+ 9C24              ;--	or		a								; Clear carry flag to say result is correct
  56+ 9C24 C9           	ret
  57+ 9C25              .LL39SignCorrection:
  58+ 9C25 FE 00            cp      0                               ; if its 0 then neg will affect flag so we just zero result to save compute
  59+ 9C27 28 0E            jr      z,.LL39ResultZero
  60+ 9C29 ED 44            neg                                     ; flip A 2'c value to positive
  61+ 9C2B 08           	ex		af,af'							; save A temporarily
  62+ 9C2C 3A 0F 84     	ld		a,(varS)						; Flip Sign bit in varS
  63+ 9C2F EE 80        	xor		$80							    ;
  64+ 9C31 32 0F 84     	ld		(varS),a                        ; flip sign bit of a
  65+ 9C34 08           	ex		af,af'                          ; get back a which is the result
  66+ 9C35                  ClearCarryFlag                          ; clear carry as NEG instrunction sets it for non zero
  66+ 9C35 B7          >                        or a
  67+ 9C36 C9           	ret
  68+ 9C37              .LL39ResultZero:
  69+ 9C37 32 0F 84         ld      (varS),a                        ; a is zero at this stage so set sign as well
  70+ 9C3A                  ClearCarryFlag                          ; clear carry
  70+ 9C3A B7          >                        or a
  71+ 9C3B C9               ret
  72+ 9C3C              ;--LL39SwapSubtraction:
  73+ 9C3C              ;--	push	bc
  74+ 9C3C              ;--	ld		b,a
  75+ 9C3C              ;--	ld		a,(hl)
  76+ 9C3C              ;--	sub		b
  77+ 9C3C              ;--	pop		bc
  78+ 9C3C              ;--	ex		af,af'							; do we flip here or negate. i think its flip as its overflowed unsigned
  79+ 9C3C              ;--	ld		a,(varS)
  80+ 9C3C              ;--	xor		$80
  81+ 9C3C              ;--	ld		(varS),a
  82+ 9C3C              ;--	ex		af,af'
  83+ 9C3C              ;--	ret
  84+ 9C3C
  85+ 9C3C              ;;;;	baddll38:				;.LL38	\ -> &4812 \ BADD(S)A=R+Q(SA) \ byte add (subtract)   (Sign S)A = R + Q*(Sign from A^S)
  86+ 9C3C              ;;;;; Calculate the following between sign-magnitude numbers:
  87+ 9C3C              ;;;;;   (S A) = (S R) + (A Q)
  88+ 9C3C              ;;;;; where the sign bytes only contain the sign bits, not magnitudes.
  89+ 9C3C              ;;;;; note goes wrong at <-127 >128 so need 16 bit version
  90+ 9C3C              ;;;;LL38:
  91+ 9C3C              ;;;;; Calculate sign for Q from A and varS
  92+ 9C3C              ;;;;	ld		hl,varS							;
  93+ 9C3C              ;;;;	xor		(hl)							;  EOR &83		\ S	\ sign of operator is A xor S
  94+ 9C3C              ;;;;	jp		m,.LL39Subtraction  			; if signs are different then we have subtraction
  95+ 9C3C              ;;;;	ld		a,(varQ)						; Q	\ else addition, S already correct
  96+ 9C3C              ;;;;	ld		hl,varR
  97+ 9C3C              ;;;;	add		a,(hl)							; a = Q + R
  98+ 9C3C              ;;;;	ret										; Done
  99+ 9C3C              ;;;;.LL39Subtraction:							; 1 byte subtraction (S)A = R-Q
 100+ 9C3C              ;;;;	ld		hl,varQ                         ;
 101+ 9C3C              ;;;;	ld		a,(hl)
 102+ 9C3C              ;;;;	JumpIfAGTENusng 128,LL39Sub16bit		; does this need to be 16 bit
 103+ 9C3C              ;;;;	ld		a,(varR)						;
 104+ 9C3C              ;;;;	ClearCarryFlag                          ; we need to not use carry (6502 is different that it uses the compliement)
 105+ 9C3C              ;;;;	sbc		a,(hl)							; A = R - Q
 106+ 9C3C              ;;;;	jr		c,.SignCorrection				; if there was underflow we have to correct sign
 107+ 9C3C              ;;;;	or		a								; Clear carry flag to say result is correct
 108+ 9C3C              ;;;;	ret
 109+ 9C3C              ;;;;.SignCorrection:
 110+ 9C3C              ;;;;    neg                                     ; flip A 2'c value to positive
 111+ 9C3C              ;;;;	ex		af,af'							; save A temporarily
 112+ 9C3C              ;;;;	ld		a,(varS)						; Flip Sign bit in varS
 113+ 9C3C              ;;;;	xor		$80							    ;
 114+ 9C3C              ;;;;	ld		(varS),a                        ; flip sign bit of a
 115+ 9C3C              ;;;;	ex		af,af'                          ; get back a which is the result
 116+ 9C3C              ;;;;	ret
 117+ 9C3C              ;;;;LL39Sub16Bit:
 118+ 9C3C              ;;;;	ld		e,a
 119+ 9C3C              ;;;;	ld		d,0
 120+ 9C3C              ;;;;	ld		a,(varR)
 121+ 9C3C              ;;;;	ld		l,a
 122+ 9C3C              ;;;;	ld		h,0
 123+ 9C3C              ;;;;	ClearCarryFlag
 124+ 9C3C              ;;;;	sbc		hl,de
 125+ 9C3C              ;;;;	jr		c,.SignCorrection16bit
 126+ 9C3C              ;;;;	bit		7,h
 127+ 9C3C              ;;;;	jr		z,.GoodToReturn
 128+ 9C3C              ;;;;.Needtonegate:
 129+ 9C3C              ;;;;	macronegate16hl
 130+ 9C3C              ;;;;.GoodToReturn
 131+ 9C3C              ;;;;	ld		a,l
 132+ 9C3C              ;;;;	or		a
 133+ 9C3C              ;;;;	ret
 134+ 9C3C              ;;;;.SignCorrection16bit:
 135+ 9C3C              ;;;;	macronegate16hl
 136+ 9C3C              ;;;;	ld		a,(varS)						; Flip Sign bit in varS
 137+ 9C3C              ;;;;	xor		$80							    ;
 138+ 9C3C              ;;;;	ld		(varS),a                        ; flip sign bit of a
 139+ 9C3C              ;;;;	ld		a,l
 140+ 9C3C              ;;;;	ret
 141+ 9C3C
 142+ 9C3C
# file closed: ../Maths/Utilities/badd_ll38.asm
 133  9C3C                  INCLUDE "../Maths/Utilities/moveship4-MVS4.asm"
# file opened: ../Maths/Utilities/moveship4-MVS4.asm
   1+ 9C3C              ; Note comparing hl vs iY, you need at least 3 incs or decs for hl to be slower
   2+ 9C3C              ; it may be faster though if we can use hl to avoid memory actions if needed
   3+ 9C3C              ; need to optimise mad as push hl pop hl and use de doesn't really improve speed
   4+ 9C3C
   5+ 9C3C
   6+ 9C3C              moveship4Yreg:
   7+ 9C3C 3A F8 82     		ld		a,(regY)
   8+ 9C3F 47           		ld		b,a
   9+ 9C40              moveship4breg:
  10+ 9C40              		; b = Y index, 9 = nosev, 15 = roofv 21 = sidev
  11+ 9C40              MVS4PitchAlphaRollBeta:
  12+ 9C40              MVS4:										;.MVS4	\ -> &52A1 \ Moveship4, Y is matrix row, pitch&roll update to coordinates
  13+ 9C40 3A 23 83     		ld		a,(ALPHA)					;  ALPHA
  14+ 9C43 32 0D 84     		ld		(varQ),a					; player ship's roll Q = Alpha
moveship4-MVS4.asm(15): error: Label not found: UBnKxsgn
  15+ 9C46 21 00 00     		ld		hl,UBnKxsgn
  16+ 9C49 78           		ld		a,b							; from
  17+ 9C4A ED 31        		add		hl,a
  18+ 9C4C 7E           		ld		a,(hl)						; INWK+2,Y
  19+ 9C4D 32 0E 84     		ld		(varR),a					; R  \ lo
  20+ 9C50 23           		inc		hl
  21+ 9C51 7E           		ld		a,(hl)						; INWK+3,Y
  22+ 9C52 32 0F 84     		ld		(varS),a					; S  \ hi		SR = nosev_y (or axis y)
  23+ 9C55 2B           		dec		hl
  24+ 9C56 2B           		dec		hl
  25+ 9C57 2B           		dec		hl							;
  26+ 9C58 7E           		ld		a,(hl)						; INWK+0,Y
  27+ 9C59 32 0A 83     		ld		(varP),a					; P  \ over-written	 P = nosevx lo
  28+ 9C5C 23           		inc		hl
  29+ 9C5D 7E           		ld		a,(hl)						; INWK+1,Y
  30+ 9C5E EE 80        		xor		$80							; flip sign  AP = nosevx * - 1
  31+ 9C60 CD B6 94     		call	madXAequQmulAaddRS			; MAD	\ DE = X.A = alpha*INWK+1,Y + INWK+2to3,Y
  32+ 9C63 23                   inc     hl
  33+ 9C64 23                   inc     hl
  34+ 9C65 77                   ld      (hl),a                      ; INWK+3,Y \ hi
  35+ 9C66 2B                   dec     hl
  36+ 9C67 3A F7 82             ld      a,(regX)
  37+ 9C6A 77                   ld      (hl),a                      ; INWK+2,Y \ Y=Y-aX   \ their comment
  38+ 9C6B 32 0A 83             ld      (varP),a                    ;  P
  39+ 9C6E 2B                   dec     hl
  40+ 9C6F 2B                   dec     hl
  41+ 9C70 7E                   ld      a,(hl)                      ; INWK+0,Y
  42+ 9C71 32 0E 84             ld      (varR),a                    ;  R	\ lo
  43+ 9C74 23                   inc     hl
  44+ 9C75 7E                   ld      a,(hl)                      ;  INWK+1,Y
  45+ 9C76 32 0F 84             ld      (varS),a                    ; S	\ hi
  46+ 9C79 23                   inc     hl
  47+ 9C7A 23                   inc     hl
  48+ 9C7B 7E                   ld      a,(hl)                      ; INWK+3,Y
  49+ 9C7C CD B6 94             call    madXAequQmulAaddRS          ; MAD	\ X.A = alpha*INWK+3,Y + INWK+0to1,Y
  50+ 9C7F 2B                   dec     hl
  51+ 9C80 2B                   dec     hl
  52+ 9C81 77                   ld      (hl),a                      ; INWK+1,Y  \ hi
  53+ 9C82 3A F7 82             ld      a,(regX)
  54+ 9C85 2B                   dec     hl
  55+ 9C86 77                   ld      (hl),a                      ; INWK+0,Y  \ X=X+aY   \ their comment
  56+ 9C87 32 0A 83             ld      (varP),a                    ; P
  57+ 9C8A 3A 15 83             ld      a,(BETA)                    ; BETA
  58+ 9C8D 32 0D 84             ld      (varQ),a                    ; Q	\ player ship's pitch
  59+ 9C90 23                   inc     hl
  60+ 9C91 23                   inc     hl
  61+ 9C92 7E                   ld      a,(hl)                      ; INWK+2,Y
  62+ 9C93 32 0E 84             ld      (varR),a                    ; R	\ lo
  63+ 9C96 23                   inc     hl
  64+ 9C97 7E                   ld      a,(hl)                      ; INWK+3,Y
  65+ 9C98 32 0F 84             ld      (varS),a                    ; S	\ hi
  66+ 9C9B 23                   inc     hl
  67+ 9C9C 7E                   ld      a,(hl)                      ; INWK+4,Y
  68+ 9C9D 32 0A 83             ld      (varP),a                    ; P	\ lo
  69+ 9CA0 23                   inc     hl
  70+ 9CA1 7E                   ld      a,(hl)                      ; INWK+5,Y
  71+ 9CA2 EE 80                xor     $80                         ; flip sign hi
  72+ 9CA4 CD B6 94             call    madXAequQmulAaddRS          ; MAD	\ X.A =-beta*INWK+5,Y + INWK+2to3,Y
  73+ 9CA7 2B                   dec     hl
  74+ 9CA8 2B                   dec     hl
  75+ 9CA9 77                   ld      (hl),a                      ; INWK+3,Y \ hi
  76+ 9CAA 3A F7 82             ld      a,(regX)
  77+ 9CAD 2B                   dec     hl
  78+ 9CAE 77                   ld      (hl),a                      ; INWK+2,Y \ Y=Y-bZ  \ their comment
  79+ 9CAF 32 0A 83             ld      (varP),a                    ; P
  80+ 9CB2 23                   inc     hl
  81+ 9CB3 23                   inc     hl
  82+ 9CB4 7E                   ld      a,(hl)                      ; INWK+4,Y
  83+ 9CB5 32 0E 84             ld      (varR),a                    ; R	\ lo
  84+ 9CB8 23                   inc     hl
  85+ 9CB9 7E                   ld      a,(hl)                      ; INWK+5,Y
  86+ 9CBA 32 0F 84             ld      (varS),a                    ; S	\ hi
  87+ 9CBD 2B                   dec     hl
  88+ 9CBE 2B                   dec     hl
  89+ 9CBF 7E                   ld      a,(hl)                      ; INWK+3,Y
  90+ 9CC0 CD B6 94             call    madXAequQmulAaddRS          ; MAD	\ X.A = beta*INWK+3,Y + INWK+4,5,Y
  91+ 9CC3 23                   inc     hl
  92+ 9CC4 23                   inc     hl
  93+ 9CC5 77                   ld      (hl),a                      ; INWK+5,Y \ hi
  94+ 9CC6 3A F7 82             ld      a,(regX)
  95+ 9CC9 2B                   dec     hl
  96+ 9CCA 77                   ld      (hl),a                      ; INWK+4,Y \ Z=Z+bY   \ their comment
  97+ 9CCB C9                   ret
  98+ 9CCC
  99+ 9CCC
# file closed: ../Maths/Utilities/moveship4-MVS4.asm
 134  9CCC                  INCLUDE "../Maths/Utilities/RequAmul256divQ-BFRDIV.asm"
# file opened: ../Maths/Utilities/RequAmul256divQ-BFRDIV.asm
   1+ 9CCC              ;;;LL28:
   2+ 9CCC              ;;;    ld      c,a                         ;
   3+ 9CCC              ;;;    ld      a,(varQ)                    ;
   4+ 9CCC              ;;;    ld      b,a                         ;
   5+ 9CCC              ;;;    ld      a,c                         ; Get varQ into b and retain c
   6+ 9CCC              ;;;RequAmul256divB:                        ;
   7+ 9CCC              ;;;LL28Breg:
   8+ 9CCC              ;;;; "BFRDIV R = (A * 256 / Q)  byte from remainder of division, not signed a = a, b = q, c = r"
   9+ 9CCC              ;;;	cp		b							; Check A >= Q
  10+ 9CCC              ;;;	jr		nc, .AnswerTooBig			; A >= Q? yes too big
  11+ 9CCC              ;;;.CalcRemainder:
  12+ 9CCC              ;;;	ld		c, 	$FE						; set R to $FE
  13+ 9CCC              ;;;.RollRemainder:
  14+ 9CCC              ;;;	sla		a
  15+ 9CCC              ;;;	jr		c,.Reduce					; if a >> generates carry reduce
  16+ 9CCC              ;;;	cp		b							; a < q?
  17+ 9CCC              ;;;	jr		nc,.DontSBC
  18+ 9CCC              ;;;.DoSBC:									; a is < q
  19+ 9CCC              ;;;	sbc		a,b							; 	a -= q
  20+ 9CCC              ;;;.DontSBC:
  21+ 9CCC              ;;;	rl		c							; r << 1
  22+ 9CCC              ;;;	jr		c, .RollRemainder			; if rol generated a carry, continue
  23+ 9CCC              ;;;    ld      a,c
  24+ 9CCC              ;;;    ld      (varR),a
  25+ 9CCC              ;;;	ret									; R (c) left with remainder
  26+ 9CCC              ;;;.Reduce:								; a geneated a carry
  27+ 9CCC              ;;;	sbc		a,b							; a = a - (q +1)
  28+ 9CCC              ;;;	scf									; set carry flag for rl
  29+ 9CCC              ;;;	rl		c							; r << 1 briging in carry
  30+ 9CCC              ;;;	jr		c,	.RollRemainder			; if a carry fell off bit 7 then repeat
  31+ 9CCC              ;;;    ld      a,c
  32+ 9CCC              ;;;    ld      (varR),a
  33+ 9CCC              ;;;	ret
  34+ 9CCC              ;;;.AnswerTooBig:
  35+ 9CCC              ;;;	ld	    c,$FF							; arse its too big
  36+ 9CCC              ;;;    ld      a,c
  37+ 9CCC              ;;;    ld      (varR),a
  38+ 9CCC              ;;;	ret
  39+ 9CCC
  40+ 9CCC              BCequAmul256DivC:
  41+ 9CCC 59             ld    e,c
  42+ 9CCD 67             ld    h,a
  43+ 9CCE 2E 00          ld    l,0
  44+ 9CD0              AdivEDivide:                             ; this routine performs the operation BC=HL/E
  45+ 9CD0 7B             ld a,e                                 ; checking the divisor; returning if it is zero
  46+ 9CD1 B7             or a                                   ; from this time on the carry is cleared
  47+ 9CD2 C8             ret z
  48+ 9CD3 01 FF FF       ld bc,-1                               ; BC is used to accumulate the result
  49+ 9CD6 16 00          ld d,0                                 ; clearing D, so DE holds the divisor
  50+ 9CD8              AdivEDivLoop:                            ; subtracting DE from HL until the first overflow
  51+ 9CD8 ED 52          sbc hl,de                              ; since the carry is zero, SBC works as if it was a SUB
  52+ 9CDA 03             inc bc                                 ;  note that this instruction does not alter the flags
  53+ 9CDB 30 FB          jr nc,AdivEDivLoop                     ; no carry means that there was no overflow
  54+ 9CDD C9             ret
  55+ 9CDE
  56+ 9CDE              HL_Div_C:
  57+ 9CDE              ; Integer divides HL by C
  58+ 9CDE              ; Result in HL, remainder in A
  59+ 9CDE              ; Clobbers F, B
  60+ 9CDE 06 10                ld b,16
  61+ 9CE0 AF                   xor a
  62+ 9CE1              HL_Div_C_Loop:
  63+ 9CE1 29                   add hl,hl
  64+ 9CE2 17                   rla
  65+ 9CE3 B9                   cp c
  66+ 9CE4 38 02                jr c,HL_DivC_Skip
  67+ 9CE6 91                   sub c
  68+ 9CE7 2C                   inc l
  69+ 9CE8              HL_DivC_Skip:
  70+ 9CE8 10 F7                djnz HL_Div_C_Loop
  71+ 9CEA 7D                   ld   a,l
  72+ 9CEB 32 0E 84             ld  (varR),a
  73+ 9CEE C9                   ret
  74+ 9CEF
  75+ 9CEF
  76+ 9CEF
  77+ 9CEF              ; Entry point if varQ is populated with demoninator
  78+ 9CEF              RequAmul256divQ:
  79+ 9CEF              BFRDIV:
  80+ 9CEF F5           		push	af
  81+ 9CF0 3A 0D 84     		ld		a,(varQ)
  82+ 9CF3 4F           		ld		c,a
  83+ 9CF4 F1           		pop		af
  84+ 9CF5 FE 00        		cp		0
  85+ 9CF7 CA 0E 9D     		jp		z, HLDIVC_0_BY	; fast exit if numerator is 0
  86+ 9CFA              RequAmul256divC:
  87+ 9CFA 2E 00        		ld		l,0
  88+ 9CFC 67           		ld		h,a
  89+ 9CFD              HL_Div_Cold:						; fast entry point if C and HL are already set
  90+ 9CFD 06 10        		ld b,16
  91+ 9CFF AF           		xor a
  92+ 9D00              LOOPPOINT:
  93+ 9D00 29           		add hl,hl
  94+ 9D01 17           		rla
  95+ 9D02 B9           		cp c
  96+ 9D03 38 02        		jr c,SKIPINCSUB
  97+ 9D05 2C           		inc l
  98+ 9D06 91           		sub c
  99+ 9D07              SKIPINCSUB:
 100+ 9D07 10 F7        		djnz LOOPPOINT
 101+ 9D09 7D           		ld		a,l
 102+ 9D0A 32 0E 84     		ld 		(varR),a
 103+ 9D0D C9           		ret
 104+ 9D0E              HLDIVC_0_BY:
 105+ 9D0E 32 0E 84     		ld		(varR),a
 106+ 9D11 C9           		ret
 107+ 9D12              ;	push	af
 108+ 9D12              ;	ld		a,b
 109+ 9D12              ;	ld		(varQ),a
 110+ 9D12              ;	pop		af
 111+ 9D12              ;RequAmul256divQ:
 112+ 9D12              ;BFRDIV:									;BFRDIV R=A*256/Q   byte from remainder of division
 113+ 9D12              ;	ld		hl,varQ
 114+ 9D12              ;	JumpIfAGTENusng	(hl),LL2			;  is A >=  Q ?, if yes, answer too big for 1 byte, R=#&FF
 115+ 9D12              ;	ld		b,$FE						; b = X
 116+ 9D12              ;	ld		c,a							; c = R	div roll counter
 117+ 9D12              ;LL31:									; roll R
 118+ 9D12              ;	sla		a
 119+ 9D12              ;	jr		c,LL29						; hop to Reduce
 120+ 9D12              ;	JumpIfALTNusng (hl)					; Q skip sbc if a < Q
 121+ 9D12              ;	sbc		a,(hl)						; a = a - Q
 122+ 9D12              ;	rl		c							; rotate R left
 123+ 9D12              ;	jr		c,LL31						; loop if R poped out a carry bit
 124+ 9D12              ;	jr		LL2Good
 125+ 9D12              ;LL29:									; Reduce
 126+ 9D12              ;	sbc		a,(hl)
 127+ 9D12              ;	scf
 128+ 9D12              ;	rl		c							; roll a carry flag into R
 129+ 9D12              ;	jr		c,LL31						;  loop R
 130+ 9D12              ;	jr		LL2Good
 131+ 9D12              ;LL2:
 132+ 9D12              ;	ld		c,$FF
 133+ 9D12              ;LL2Good:
 134+ 9D12              ;	ld		a,c
 135+ 9D12              ;	ld		(varR),a
 136+ 9D12              ;	ret
 137+ 9D12
# file closed: ../Maths/Utilities/RequAmul256divQ-BFRDIV.asm
 135  9D12                  INCLUDE "../Maths/Utilities/RequAdivQ-LL61.asm"
# file opened: ../Maths/Utilities/RequAdivQ-LL61.asm
   1+ 9D12              RequAdivQ:
   2+ 9D12              	; R = A/Q, U = remainder, code looked a little odd as if R is reminader and U = result
   3+ 9D12              LL61:										; Handling division R=A/Q for case further down
   4+ 9D12 4F           	ld		c,a								; c = A
   5+ 9D13 3A 0D 84     	ld		a,(varQ)						; test for divide by 0
   6+ 9D16 FE 00        	cp		0
   7+ 9D18 28 16        	jr		z,LL84							; divide by zero error
   8+ 9D1A 57           	ld		d,a								; now we can do C/D
   9+ 9D1B 06 08            ld b,8
  10+ 9D1D AF               xor a
  11+ 9D1E              LL63:										; roll divide loop
  12+ 9D1E CB 21            sla c
  13+ 9D20 17               rla
  14+ 9D21 BA               cp d
  15+ 9D22 38 02            jr c,LL64
  16+ 9D24 0C               inc c
  17+ 9D25 92               sub d
  18+ 9D26              LL64:
  19+ 9D26 10 F6            djnz LL63
  20+ 9D28 32 0C 84     	ld	(varU),a							; store remainder in U
  21+ 9D2B 79           	ld	a,c
  22+ 9D2C 32 0E 84     	ld	(varR),a							; store remainder in R
  23+ 9D2F C9               ret
  24+ 9D30              LL84:										; div error  R=U=#5
  25+ 9D30 3E 32        	ld		a,50
  26+ 9D32 32 0E 84     	ld		(varR),a
  27+ 9D35 32 0C 84     	ld		(varU),a
  28+ 9D38 C9           	ret
  29+ 9D39
# file closed: ../Maths/Utilities/RequAdivQ-LL61.asm
 136  9D39                  INCLUDE "../Maths/Utilities/RSequQmulA-MULT12.asm"
# file opened: ../Maths/Utilities/RSequQmulA-MULT12.asm
   1+ 9D39              asm_mult12:
   2+ 9D39              RSequQmulA:
   3+ 9D39              ; "asm_ult12  R.S = Q * A \ visited quite often S = hi, R = lo, odd that its opposite to mult1"
   4+ 9D39 CD E1 9B     	call APequQmulA
   5+ 9D3C 08           	ex 	af,af'
   6+ 9D3D 7A           	ld	a,d
   7+ 9D3E 32 0F 84     	ld	(varS),a
   8+ 9D41 7B           	ld	a,e
   9+ 9D42 32 0E 84     	ld	(varR),a
  10+ 9D45 08           	ex 	af,af'
  11+ 9D46 C9           	ret
  12+ 9D47
# file closed: ../Maths/Utilities/RSequQmulA-MULT12.asm
 137  9D47                  INCLUDE "../Maths/Utilities/LL28AequAmul256DivD.asm"
# file opened: ../Maths/Utilities/LL28AequAmul256DivD.asm
   1+ 9D47
   2+ 9D47              LL28Amul256DivD:        JumpIfAGTENusng  d, .Ll28Exit255
   2+ 9D47 BA          >                        cp     d
   2+ 9D48 D2 66 9D    >                        jp		nc,.Ll28Exit255
   3+ 9D4B 1E FE                                ld      e,%11111110                 ; Set R to have bits 1-7 set, so we can rotate through 7
   4+ 9D4D CB 27        .LL31:                  sla     a
   5+ 9D4F 38 0D                                jr      c,.LL29
   6+ 9D51                                      JumpIfALTNusng  d, .SkipSub         ; will jump if carry set, so we need to reset on the rol
   6+ 9D51 BA          >                        cp      d
   6+ 9D52 DA 57 9D    >                        jp		c, .SkipSub
   7+ 9D55 92                                   sub     d
   8+ 9D56                                      ClearCarryFlag                      ; reset clarry as it will be complimented for rotate as 6502 does carry flags inverted
   8+ 9D56 B7          >                        or a
   9+ 9D57 3F           .SkipSub:               ccf                                 ; if we did the subtract the carry will be clear so we need to invert to roll in.
  10+ 9D58 CB 13                                rl      e
  11+ 9D5A 38 F1                                jr      c,.LL31
  12+ 9D5C 7B                                   ld      a,e
  13+ 9D5D C9                                   ret
  14+ 9D5E 92           .LL29:                  sub     d                           ; A >= Q, so set A = A - Q
  15+ 9D5F 37                                   scf                                 ; Set the C flag to rotate into the result in R
  16+ 9D60 CB 13                                rl      e                           ; rotate counter e left
  17+ 9D62 38 E9                                jr      c,.LL31                     ; if a bit was spat off teh end then loop
  18+ 9D64 7B                                   ld      a,e                         ; stick result in a
  19+ 9D65 C9                                   ret
  20+ 9D66 3E FF        .Ll28Exit255:           ld  a,255                           ; Fail with FF as result
  21+ 9D68 C9                                   ret
  22+ 9D69
# file closed: ../Maths/Utilities/LL28AequAmul256DivD.asm
 138  9D69                  INCLUDE "../Maths/Utilities/XAequMinusXAPplusRSdiv96-TIS1.asm"
# file opened: ../Maths/Utilities/XAequMinusXAPplusRSdiv96-TIS1.asm
   1+ 9D69              XAequMinusXAplusRSdiv96:					;.TIS1	\ -> &293B  \ Tidy subroutine 1  X.A =  (-X*A  + (R.S))/96
   2+ 9D69              TIS1:
   3+ 9D69 08           		ex		af,af'
   4+ 9D6A 3A F7 82     		ld		a,(regX)
   5+ 9D6D 47           		ld		b,a
   6+ 9D6E 08           		ex		af,af'
   7+ 9D6F              BAequMinusBAplusRSdiv96:					;.TIS1	\ -> &293B  \ Tidy subroutine 1 using B register = X
   8+ 9D6F 08           		ex		af,af'
   9+ 9D70 78           		ld		a,b
  10+ 9D71 32 0D 84     		ld		(varQ),a
  11+ 9D74 08           		ex		af,af'
  12+ 9D75 EE 80        		xor		$80							;	 flip sign of Acc
  13+ 9D77 CD B6 94     		call	madXAequQmulAaddRS			; \ MAD \ multiply and add (X,A) =  -X*A  + (R,S)
  14+ 9D7A              ; USES 				A BC E
  15+ 9D7A              ; DOES NOT USE		D HL
  16+ 9D7A              Div96:										; .DVID96	\ Their comment A=A/96: answer is A*255/96
  17+ 9D7A 47           		ld		b,a
  18+ 9D7B E6 80        		and		$80							;	hi sign
  19+ 9D7D 5F           		ld		e,a							;   e = varT
  20+ 9D7E 78           		ld		a,b
  21+ 9D7F E6 7F        		and		$7F							;	hi A7
  22+ 9D81 06 FE        		ld		b,$FE						;   slide counter
  23+ 9D83 48           		ld		c,b							;   c == T1 ::  T1
  24+ 9D84              .DVL3:										;   roll T1  clamp Acc to #96 for rotation matrix unity
  25+ 9D84 CB 27        		sla		a
  26+ 9D86 FE 60        		cp		$60							; max 96
  27+ 9D88 30 02        		jr		nc,.DV4
  28+ 9D8A DE 60        		sbc		a,$60							;  SBC #&60
  29+ 9D8C              .DV4:										; skip subtraction
  30+ 9D8C CB 11        		rl		c							;  T1
  31+ 9D8E 38 F4        		jr		c,.DVL3
  32+ 9D90 79           		ld		a,c							;   T1
  33+ 9D91 B3           		or		e							;   restore T sign
  34+ 9D92 C9           		ret
  35+ 9D93
# file closed: ../Maths/Utilities/XAequMinusXAPplusRSdiv96-TIS1.asm
 139  9D93
 140  9D93
 141  9D93                  SLOT    LAYER2Addr
 142  9D93                  PAGE    BankLAYER2
 143  9D93                  ORG     LAYER2Addr
 144  E000
 145  E000                  INCLUDE "../Layer2Graphics/layer2_bank_select.asm"
# file opened: ../Layer2Graphics/layer2_bank_select.asm
   1+ E000
   2+ E000 00           varL2_BANK_SELECTED			 DB	0
   3+ E001 00           varL2_BUFFER_MODE            DB 0
   4+ E002 00           varL2_ACCESS_MODE            DB 0
   5+ E003
   6+ E003 3E 08        asm_l2_double_buffer_on:    ld      a,8
   7+ E005 32 01 E0                                 ld      (varL2_BUFFER_MODE),a
   8+ E008 C9                                       ret
   9+ E009
  10+ E009 AF           asm_l2_double_buffer_off:   xor     a
  11+ E00A 32 01 E0                                 ld      (varL2_BUFFER_MODE),a
  12+ E00D C9                                       ret
  13+ E00E
  14+ E00E 01 3B 12     asm_disable_l2_readwrite:   ld      bc, IO_LAYER2_PORT
  15+ E011 ED 70                                    in      (c)
  16+ E013 32 02 E0                                 ld      (varL2_ACCESS_MODE),a
  17+ E016 E6 FA                                    and     LAYER2_DISABLE_MEM_ACCESS
  18+ E018 ED 79                                    out     (c),a
  19+ E01A C9                                       ret
  20+ E01B
  21+ E01B 3A 02 E0     asm_restore_l2_readwrite:   ld      a,(varL2_ACCESS_MODE)
  22+ E01E E6 05                                    and     LAYER2_READ_WRITE_MASK
  23+ E020 57                                       ld      d,a
  24+ E021 01 3B 12                                 ld      bc, IO_LAYER2_PORT
  25+ E024 ED 70                                    in      (c)
  26+ E026 32 02 E0                                 ld      (varL2_ACCESS_MODE),a
  27+ E029 A2                                       and     d
  28+ E02A ED 79                                    out     (c),a
  29+ E02C C9                                       ret
  30+ E02D
  31+ E02D 01 3B 12     asm_enable_l2_readwrite:    ld      bc, IO_LAYER2_PORT
  32+ E030 ED 70                                    in      (c)
  33+ E032 F6 05                                    or      LAYER2_READ_WRITE_MASK
  34+ E034 ED 79                                    out     (c),a
  35+ E036 C9                                       ret
  36+ E037
  37+ E037              ; "asm_l2_bank_select"
  38+ E037              ; " a = sepecific bank mask value to select, does not set varL2_BANK_SELECTED"
  39+ E037 57           asm_l2_bank_select:         ld      d,a
  40+ E038 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
  41+ E03B F6 03                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK
  42+ E03D B2                                       or      d; | LAYER2_SHADOW_SCREEN_MASK
  43+ E03E 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
  44+ E041 ED 79                                    out 	(c),a
  45+ E043 C9                                       ret
  46+ E044              ;  "asm_l2_bank_select a = sepecific bank number to select, dsets varL2_BANK_SELECTED"
  47+ E044 32 00 E0     asm_l2_bank_n_select:       ld		(varL2_BANK_SELECTED),a
  48+ E047 FE 00                                    cp		0
  49+ E049 20 04                                    jr 		nz,.nottopbank
  50+ E04B 3E 00        .topbank:                   ld		a,LAYER2_SHIFTED_SCREEN_TOP
  51+ E04D 18 E8                                    jr		asm_l2_bank_select
  52+ E04F FE 01        .nottopbank:                cp		1
  53+ E051 20 04                                    jr 		nz,.notmiddlebank
  54+ E053 3E 40        .middlebank:                ld		a,LAYER2_SHIFTED_SCREEN_MIDDLE
  55+ E055 18 E0                                    jr		asm_l2_bank_select
  56+ E057 3E 80        .notmiddlebank:             ld		a,LAYER2_SHIFTED_SCREEN_BOTTOM ; default to bottom
  57+ E059 18 DC                                    jr		asm_l2_bank_select
  58+ E05B              		; Note no ret as its handled by above routines
  59+ E05B
  60+ E05B              ; "asm_l2_row_bank_select"
  61+ E05B              ; "A (unsinged) = y row of pixel line from top, sets the bank to top middle or bottom and adjusts a reg to row memory address"
  62+ E05B              ; "Could optimise by holding the previous bank but given its only an out statement it may not save T states at all"
  63+ E05B              ; "destroys BC call de is safe a = adjusted poke pixel row"
  64+ E05B FE 40        asm_l2_row_bank_select:     cp 		64			; row < 64?
  65+ E05D 30 11                                    jr 		nc, .l2rowGTE64
  66+ E05F 08           .l2rowLT64:                 ex		af,af'
  67+ E060                                          ;ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP | LAYER2_SHADOW_SCREEN_MASK
  68+ E060 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
  69+ E063 F6 03                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
  70+ E065 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
  71+ E068 ED 79                                    out 	(c),a
  72+ E06A AF                                       xor		a						; set a to 0
  73+ E06B 32 00 E0                                 ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  74+ E06E 08                                       ex		af,af'					; return pixel poke unharmed
  75+ E06F C9                                       ret
  76+ E070 FE 80        .l2rowGTE64:                cp 		128
  77+ E072 30 14                                    jr 		nc, .l2rowGTE128
  78+ E074 08           .l2row64to127:              ex		af,af'
  79+ E075                                  ;		ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE | LAYER2_SHADOW_SCREEN_MASK
  80+ E075 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
  81+ E078 F6 43                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
  82+ E07A 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
  83+ E07D ED 79                                    out 	(c),a
  84+ E07F 3E 01                                    ld		a,1						; set a to 1
  85+ E081 32 00 E0                                 ld		(varL2_BANK_SELECTED),a	; save selected bank
  86+ E084 08                                       ex		af,af'
  87+ E085 D6 40                                    sub		64
  88+ E087 C9                                       ret
  89+ E088 08           .l2rowGTE128:               ex		af,af'
  90+ E089                                  ;		ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM | LAYER2_SHADOW_SCREEN_MASK
  91+ E089 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
  92+ E08C F6 83                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
  93+ E08E
  94+ E08E 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
  95+ E091 ED 79                                    out 	(c),a
  96+ E093 3E 01                                    ld		a,1						; set a to 2
  97+ E095 32 00 E0                                 ld		(varL2_BANK_SELECTED),a	; save selected bank
  98+ E098 08                                       ex		af,af'
  99+ E099 D6 80                                    sub		128
 100+ E09B C9                                       ret
 101+ E09C
# file closed: ../Layer2Graphics/layer2_bank_select.asm
 146  E09C                  INCLUDE "../Layer2Graphics/layer2_cls.asm"
# file opened: ../Layer2Graphics/layer2_cls.asm
   1+ E09C
   2+ E09C 00           l2_cls_byte	            DB 0
   3+ E09D              ; ">DMA Command BLOCK"
   4+ E09D
   5+ E09D 83 C3 C7 CB  l2_fill                 DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   5+ E0A1 7D
   6+ E0A2 9C E0        l2_fill_astrt           DW l2_cls_byte
   7+ E0A4 00 40        l2_fill_length          DB $00,$40
   8+ E0A6 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
   9+ E0A9 00 00        l2_fill_bstrt           DB $00,$00
  10+ E0AB 82 CF B3 87                          DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
  11+ E0AF              l2_fill_cmd_len	        EQU $ - l2_fill
  12+ E0AF
  13+ E0AF              l2_cls_dma_bank:
  14+ E0AF              ; ">l2_cls_dma_bank"
  15+ E0AF              ; ">sets a bank to"
  16+ E0AF 32 9C E0     .set_colour:            ld (l2_cls_byte),a
  17+ E0B2 21 9D E0     .write_dma:             ld hl, l2_fill
  18+ E0B5 06 12                                ld b, l2_fill_cmd_len
  19+ E0B7 0E 6B                                ld	c,IO_DATAGEAR_DMA_PORT
  20+ E0B9 ED B3                                otir
  21+ E0BB C9                                   ret
  22+ E0BC
  23+ E0BC 3E 00        l2_set_color_upper2:    ld      a,0
  24+ E0BE CD 5B E0                             call asm_l2_row_bank_select
  25+ E0C1 3A 9C E0                             ld      a,(l2_cls_byte)
  26+ E0C4 CD AF E0                             call l2_cls_dma_bank
  27+ E0C7 3E 40                                ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
  28+ E0C9 CD 5B E0                             call asm_l2_row_bank_select
  29+ E0CC 3A 9C E0                             ld      a,(l2_cls_byte)
  30+ E0CF CD AF E0                             call l2_cls_dma_bank
  31+ E0D2 C9                                   ret
  32+ E0D3
  33+ E0D3
  34+ E0D3 3E 00        l2_cls_upper_two_thirds:ld a,0								; pretend we are plotting pixel on row 0 to force top selection
  35+ E0D5 CD 5B E0                             call asm_l2_row_bank_select
  36+ E0D8 3E E3                                ld 	a,COLOUR_TRANSPARENT
  37+ E0DA CD AF E0                             call l2_cls_dma_bank
  38+ E0DD 3E 40                                ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
  39+ E0DF CD 5B E0                             call asm_l2_row_bank_select
  40+ E0E2 3E E3                                ld 	a,COLOUR_TRANSPARENT
  41+ E0E4 CD AF E0                             call l2_cls_dma_bank
  42+ E0E7 C9                                   ret
  43+ E0E8
  44+ E0E8 3E 80        l2_cls_lower_third:     ld a,128							; pretend we are plotting pixel on row 64 to force mid selection
  45+ E0EA CD 5B E0                             call asm_l2_row_bank_select
  46+ E0ED 3E E3                                ld 	a,COLOUR_TRANSPARENT
  47+ E0EF CD AF E0                             call l2_cls_dma_bank
  48+ E0F2 C9                                   ret
  49+ E0F3
  50+ E0F3 CD D3 E0     l2_cls:                 call l2_cls_upper_two_thirds
  51+ E0F6 CD E8 E0                             call l2_cls_lower_third
  52+ E0F9 C9                                   ret
  53+ E0FA
# file closed: ../Layer2Graphics/layer2_cls.asm
 147  E0FA                  INCLUDE "../Layer2Graphics/layer2_initialise.asm"
# file opened: ../Layer2Graphics/layer2_initialise.asm
   1+ E0FA
   2+ E0FA ED 91 12 08  l2_initialise:          nextreg		LAYER2_RAM_PAGE_REGISTER,          	LAYER2_SCREEN_BANK1
   3+ E0FE ED 91 13 0B                          nextreg		LAYER2_RAM_SHADOW_REGISTER,     	LAYER2_SHADOW_BANK1
   4+ E102 ED 91 14 E3                          nextreg		TRANSPARENCY_COLOUR_REGISTER, 		COLOUR_TRANSPARENT
   5+ E106 C9                                   ret
   6+ E107
# file closed: ../Layer2Graphics/layer2_initialise.asm
 148  E107                  INCLUDE "../Layer2Graphics/l2_flip_buffers.asm"
# file opened: ../Layer2Graphics/l2_flip_buffers.asm
   1+ E107              l2_flip_buffers:        GetNextReg LAYER2_RAM_PAGE_REGISTER
   1+ E107 C5          >            push bc
   1+ E108 01 3B 24    >                ld bc,$243B
   1+ E10B 3E 12       >                    ld a,LAYER2_RAM_PAGE_REGISTER
   1+ E10D ED 79       >                    out (c),a
   1+ E10F 04          >                    inc b
   1+ E110 ED 78       >                in a,(c)
   1+ E112 C1          >            pop bc
   2+ E113 57                                   ld      d,a
   3+ E114                                      GetNextReg LAYER2_RAM_SHADOW_REGISTER
   3+ E114 C5          >            push bc
   3+ E115 01 3B 24    >                ld bc,$243B
   3+ E118 3E 13       >                    ld a,LAYER2_RAM_SHADOW_REGISTER
   3+ E11A ED 79       >                    out (c),a
   3+ E11C 04          >                    inc b
   3+ E11D ED 78       >                in a,(c)
   3+ E11F C1          >            pop bc
   4+ E120 5F                                   ld      e,a
   5+ E121 ED 92 12                             nextreg LAYER2_RAM_PAGE_REGISTER, a
   6+ E124 7A                                   ld      a,d
   7+ E125 ED 92 13                             nextreg LAYER2_RAM_SHADOW_REGISTER, a
   8+ E128 C9                                   ret
   9+ E129
# file closed: ../Layer2Graphics/l2_flip_buffers.asm
 149  E129                  INCLUDE "../Layer2Graphics/layer2_plot_pixel.asm"
# file opened: ../Layer2Graphics/layer2_plot_pixel.asm
   1+ E129              l2_plot_pixel:
   2+ E129              ; ">l2_plot_pixel b= row number, c = column number, a = pixel col"
   3+ E129 F5           	push    af
   4+ E12A 78               ld      a,b
   5+ E12B              l2_pp_row_valid:
   6+ E12B                  JumpIfAGTENusng ScreenHeight,l2_pp_dont_plot
   6+ E12B FE C0       >                        cp     ScreenHeight
   6+ E12D D2 3B E1    >                        jp		nc,l2_pp_dont_plot
   7+ E130 C5           	push    bc								; bank select destroys bc so need to save it
   8+ E131              ;	ld      a,b
   9+ E131 CD 5B E0     	call    asm_l2_row_bank_select
  10+ E134 C1           	pop     bc
  11+ E135 47           	ld      b,a
  12+ E136 60           	ld      h,b								; hl now holds ram address after bank select
  13+ E137 69           	ld      l,c
  14+ E138 F1           	pop     af								; a = colour to plott
  15+ E139 77           	ld      (hl),a
  16+ E13A C9           	ret
  17+ E13B              l2_pp_dont_plot:
  18+ E13B F1               pop     af
  19+ E13C C9               ret
  20+ E13D
  21+ E13D              l2_plot_pixel_no_bank:
  22+ E13D              ; ">l2_plot_pixel_no_bank b= row number, c = column number, a = pixel col"
  23+ E13D              ; This version assues pixel is in the same bank as previously plotted ones. optimised for horizontal lines
  24+ E13D E5           	push 	hl
  25+ E13E 60           	ld 		h,b								; hl now holds ram address after bank select
  26+ E13F 69           	ld 		l,c
  27+ E140 77           	ld 		(hl),a
  28+ E141 E1           	pop		hl
  29+ E142 C9           	ret
  30+ E143
  31+ E143              l2_plot_pixel_y_test:
  32+ E143 F5           	push	af
  33+ E144 78           	ld		a,b
  34+ E145 FE C0        	cp		192
  35+ E147 30 03        	jr		nc,.clearup
  36+ E149 F1           	pop		af
  37+ E14A 18 DD        	jr		l2_plot_pixel
  38+ E14C              .clearup:
  39+ E14C F1           	pop		af
  40+ E14D C9           	ret
  41+ E14E
  42+ E14E              l2_point_pixel_y_safe:	MACRO
  43+ E14E ~            						push	hl
  44+ E14E ~            						push	bc
  45+ E14E ~            						call	l2_plot_pixel
  46+ E14E ~            						pop		bc
  47+ E14E ~            						pop		hl
  48+ E14E              						ENDM
  49+ E14E
# file closed: ../Layer2Graphics/layer2_plot_pixel.asm
 150  E14E                  INCLUDE "../Layer2Graphics/layer2_print_character.asm"
# file opened: ../Layer2Graphics/layer2_print_character.asm
   1+ E14E
   2+ E14E              l2_print_chr_at:
   3+ E14E              ; "l2_print_chr_at, bc = col,row, d= character, e = colour"
   4+ E14E              ; "Need a version that also prints absence of character"
   5+ E14E 7A           	ld		a,d
   6+ E14F FE 20        	cp		32
   7+ E151 38 3F        	jr		c,.InvalidCharacter		; Must be between 32 and 127
   8+ E153 FE 7F        	cp		127
   9+ E155 30 3B        	jr		nc,.InvalidCharacter
  10+ E157              .ValidCharater:
  11+ E157 26 00        	ld		h,0
  12+ E159 6A           	ld		l,d
  13+ E15A 29           	add		hl,hl						; * 2
  14+ E15B 29           	add		hl,hl						; * 4
  15+ E15C 29           	add		hl,hl						; * 8 to get byte address
  16+ E15D ED 34 00 3C  	add		hl,charactersetaddr			; hl = address of rom char
  17+ E161 04           	inc		b							; start + 1 pixel x and y as we only print 7x7
  18+ E162 23           	inc		hl							; skip first byte
  19+ E163 16 07        	ld		d,7
  20+ E165              .PrintCharLoop:
  21+ E165 D5           	push	de
  22+ E166 7E           	ld		a,(hl)
  23+ E167 FE 00        	cp		0
  24+ E169 28 21        	jr		z,.NextRowNoBCPop
  25+ E16B              .PrintARow:
  26+ E16B C5           	push	bc							; save row col
  27+ E16C 16 07        	ld		d,7							; d is loop row number now
  28+ E16E              .PrintPixelLoop:
  29+ E16E 0C           	inc		c							; we start at col 1 not 0 so can move inc here
  30+ E16F              .PrintTheRow:
  31+ E16F CB 27        	sla		a							; scroll char 1 pixel as we read from bit 7
  32+ E171 F5           	push	af							; save character byte
  33+ E172 CB 7F        	bit		7,a							; If left most pixel set then plot
  34+ E174 20 04        	jr		nz,.PixelToPrint
  35+ E176              .NoPixelToPrint:
  36+ E176 3E E3        	ld		a,$E3
  37+ E178 18 01        	jr		.HaveSetPixelColour
  38+ E17A              .PixelToPrint:
  39+ E17A 7B           	ld		a,e							; Get Colour
  40+ E17B              .HaveSetPixelColour
  41+ E17B E5           	push	hl
  42+ E17C              ;	push	bc							; at the moment we don't do paging on first plot so need to preserve BC
  43+ E17C              .BankOnFirstOnly:
  44+ E17C F5           	push	af
  45+ E17D 7A           	ld		a,d
  46+ E17E FE 07        	cp		7
  47+ E180 28 11        	jr		z,.PlotWithBank
  48+ E182              .PlotNoBank:
  49+ E182 F1           	pop		af
  50+ E183 60           	ld 		h,b								; hl now holds ram address after bank select
  51+ E184 69           	ld 		l,c
  52+ E185 77           	ld 		(hl),a
  53+ E186              .IterateLoop:
  54+ E186              ;	pop		bc
  55+ E186 E1           	pop		hl
  56+ E187 F1           	pop		af							; a= current byte shifted
  57+ E188 15           	dec		d						 	; do dec after inc as we amy
  58+ E189 20 E3        	jr		nz,.PrintPixelLoop
  59+ E18B              .NextRow:
  60+ E18B C1           	pop		bc							; Current Col Row
  61+ E18C              .NextRowNoBCPop:
  62+ E18C D1           	pop		de							; d= row loop
  63+ E18D 04           	inc		b							; Down 1 row
  64+ E18E 23           	inc		hl							; Next character byte
  65+ E18F 15           	dec		d							; 1 done now
  66+ E190 20 D3        	jr		nz,.PrintCharLoop
  67+ E192              .InvalidCharacter:
  68+ E192 C9           	ret
  69+ E193              .PlotWithBank:
  70+ E193 F1           	pop		af
  71+ E194 CD 29 E1     	call	l2_plot_pixel				; This will shift bc to poke row
  72+ E197 18 ED        	jr		.IterateLoop
  73+ E199
  74+ E199              l2_print_at:
  75+ E199              ; "l2_print_at bc= colrow, hl = addr of message, e = colour"
  76+ E199              ; "No error trapping, if there is no null is will just cycle on the line"
  77+ E199 7E           	ld	a,(hl)							; Return if empty string
  78+ E19A FE 00        	cp	0
  79+ E19C C8           	ret	z
  80+ E19D E5           	push	hl
  81+ E19E D5           	push	de
  82+ E19F C5           	push	bc
  83+ E1A0 57           	ld		d,a							; bc = pos, de = char and colour
  84+ E1A1 CD 4E E1     	call 	l2_print_chr_at
  85+ E1A4 C1           	pop		bc
  86+ E1A5 D1           	pop		de
  87+ E1A6 E1           	pop		hl
  88+ E1A7              .Move8Pixlestoright:
  89+ E1A7 08           	ex		af,af'
  90+ E1A8 79           	ld		a,c
  91+ E1A9 C6 08        	add		8
  92+ E1AB 4F           	ld		c,a
  93+ E1AC 08           	ex		af,af'
  94+ E1AD 23           	inc		hl
  95+ E1AE 18 E9        	jr		l2_print_at					; Just loop until 0 found
  96+ E1B0
  97+ E1B0
  98+ E1B0              ; "l2_print_chr_at, bc = col,row, d= character, e = colour"
  99+ E1B0              ; "Need a version that also prints absence of character"
 100+ E1B0              ; removed blank line optimisation as we need spaces printed
 101+ E1B0 7A           l2_print_7chr_at:       ld		a,d
 102+ E1B1 FE 1F                                cp		31
 103+ E1B3 38 3D                                jr		c,.InvalidCharacter		; Must be between 32 and 127
 104+ E1B5 FE 7F                                cp		127
 105+ E1B7 30 39                                jr		nc,.InvalidCharacter
 106+ E1B9 26 00        .ValidCharater:         ld		h,0
 107+ E1BB 6A                                   ld		l,d
 108+ E1BC 29                                   add		hl,hl						; * 2
 109+ E1BD 29                                   add		hl,hl						; * 4
 110+ E1BE 29                                   add		hl,hl						; * 8 to get byte address
 111+ E1BF ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
 112+ E1C3 04                                   inc		b							; start + 1 pixel x and y as we only print 7x7
 113+ E1C4 23                                   inc		hl							; skip first byte
 114+ E1C5 16 07                                ld		d,7
 115+ E1C7 D5           .PrintCharLoop:         push	de
 116+ E1C8 7E                                   ld		a,(hl)
 117+ E1C9                                      ;cp		0
 118+ E1C9                                      ;jr		z,.NextRowNoBCPop
 119+ E1C9 C5           .PrintARow:             push	bc							; save row col
 120+ E1CA 16 06                                ld		d,6							; d is loop row number now
 121+ E1CC 0C           .PrintPixelLoop:        inc		c							; we start at col 1 not 0 so can move inc here
 122+ E1CD 28 1C                                jr		z,.NextRow
 123+ E1CF CB 27                                sla		a							; scroll char 1 pixel as we read from bit 7
 124+ E1D1 F5                                   push	af							; save character byte
 125+ E1D2 CB 7F                                bit		7,a							; If left most pixel set then plot
 126+ E1D4 20 04                                jr		nz,.PixelToPrint
 127+ E1D6 3E E3        .NoPixelToPrint:        ld		a,$E3
 128+ E1D8 18 01                                jr		.HaveSetPixelColour
 129+ E1DA 7B           .PixelToPrint:          ld		a,e							; Get Colour
 130+ E1DB E5           .HaveSetPixelColour		push	hl
 131+ E1DC                                      ;	push	bc							; at the moment we don't do paging on first plot so need to preserve BC
 132+ E1DC F5           .BankOnFirstOnly:       push	af
 133+ E1DD 7A                                   ld		a,d
 134+ E1DE FE 06                                cp		6
 135+ E1E0 28 11                                jr		z,.PlotWithBank
 136+ E1E2 F1           .PlotNoBank:            pop		af
 137+ E1E3 60                                   ld 		h,b								; hl now holds ram address after bank select
 138+ E1E4 69                                   ld 		l,c
 139+ E1E5 77                                   ld 		(hl),a
 140+ E1E6              .IterateLoop:	        ;	pop		bc
 141+ E1E6 E1                                   pop		hl
 142+ E1E7 F1                                   pop		af							; a= current byte shifted
 143+ E1E8 15                                   dec		d						 	; do dec after inc as we amy
 144+ E1E9 20 E1                                jr		nz,.PrintPixelLoop
 145+ E1EB C1           .NextRow:               pop		bc							; Current Col Row
 146+ E1EC D1           .NextRowNoBCPop:	    pop		de							; d= row loop
 147+ E1ED 04                                   inc		b							; Down 1 row
 148+ E1EE 23                                   inc		hl							; Next character byte
 149+ E1EF 15                                   dec		d							; 1 done now
 150+ E1F0 20 D5                                jr		nz,.PrintCharLoop
 151+ E1F2 C9           .InvalidCharacter:      ret
 152+ E1F3 F1           .PlotWithBank:          pop		af
 153+ E1F4 CD 29 E1                             call	l2_plot_pixel				; This will shift bc to poke row
 154+ E1F7 18 ED                                jr		.IterateLoop
 155+ E1F9
 156+ E1F9              ; "l2_print_7at bc= colrow, hl = addr of message, e = colour"
 157+ E1F9              ; "No error trapping, if there is no null is will just cycle on the line"
 158+ E1F9 7E           l2_print_7at:           ld	a,(hl)							; Return if empty string
 159+ E1FA FE 00                                cp	0
 160+ E1FC C8                                   ret	z
 161+ E1FD E5                                   push	hl
 162+ E1FE D5                                   push	de
 163+ E1FF C5                                   push	bc
 164+ E200 57                                   ld		d,a							; bc = pos, de = char and colour
 165+ E201 CD B0 E1                             call 	l2_print_7chr_at
 166+ E204 C1                                   pop		bc
 167+ E205 D1                                   pop		de
 168+ E206 E1                                   pop		hl
 169+ E207 08           .Move7Pixlestoright:	ex		af,af'
 170+ E208 79                                   ld		a,c
 171+ E209 C6 07                                add		7
 172+ E20B 4F                                   ld		c,a
 173+ E20C 08                                   ex		af,af'
 174+ E20D 23                                   inc		hl
 175+ E20E 18 E9                                jr		l2_print_7at					; Just loop until 0 found
 176+ E210
 177+ E210
# file closed: ../Layer2Graphics/layer2_print_character.asm
 151  E210                  INCLUDE "../Layer2Graphics/layer2_draw_box.asm"
# file opened: ../Layer2Graphics/layer2_draw_box.asm
   1+ E210              ; "l2_draw_thick_box bc=rowcol, de=heightwidth h=color"
   2+ E210              ; TODO DMA Optimise
   3+ E210 C5 D5 E5     l2_draw_fill_box:       push    bc,,de,,hl
   4+ E213 53                                   ld      d,e
   5+ E214 5C                                   ld      e,h
   6+ E215 CD 8A E2                             call    l2_draw_horz_line           ; "bc = left side row,col, d = length, e = color"
   7+ E218 E1 D1 C1                             pop     bc,,de,,hl
   8+ E21B 04                                   inc     b
   9+ E21C 15                                   dec     d
  10+ E21D C8                                   ret     z
  11+ E21E 18 F0                                jr      l2_draw_fill_box
  12+ E220
  13+ E220              ; "l2_draw_box bc=rowcol, de=heightwidth a=color"
  14+ E220 C5 D5 F5     l2_draw_box:            push	bc,,de,,af
  15+ E223 53                                   ld		d,e
  16+ E224 5F                                   ld		e,a
  17+ E225 14                                   inc		d
  18+ E226 CD 8A E2                             call	l2_draw_horz_line
  19+ E229 F1 D1 C1                             pop		bc,,de,,af
  20+ E22C C5 D5 F5     .bottomhorzline:	    push	bc,,de,,af
  21+ E22F 67                                   ld		h,a							;save color whilst b = row + height
  22+ E230 78                                   ld		a,b
  23+ E231 82                                   add		a,d
  24+ E232 47                                   ld		b,a
  25+ E233 53                                   ld		d,e							; d = width
  26+ E234 14                                   inc		d							; Extra pixel for width
  27+ E235 5C                                   ld		e,h							; e = colour
  28+ E236 CD 8A E2                             call	l2_draw_horz_line
  29+ E239 F1 D1 C1                             pop		bc,,de,,af
  30+ E23C C5 D5 F5     .leftvertline:          push	bc,,de,,af
  31+ E23F 04                                   inc		b							; save 2 pixles
  32+ E240 15                                   dec		d
  33+ E241 5F                                   ld		e,a							; e = color
  34+ E242 CD DB E2                             call	l2_draw_vert_line
  35+ E245 F1 D1 C1                             pop		bc,,de,,af
  36+ E248 04           .rightvertline:         inc		b							; save 2 pixles
  37+ E249 15                                   dec		d
  38+ E24A 67                                   ld		h,a							;save color whilst c = col + width
  39+ E24B 79                                   ld		a,c
  40+ E24C 83                                   add		a,e
  41+ E24D 4F                                   ld		c,a
  42+ E24E 5C                                   ld		e,h							; e = color
  43+ E24F CD DB E2                             call	l2_draw_vert_line
  44+ E252 C9                                   ret
  45+ E253
# file closed: ../Layer2Graphics/layer2_draw_box.asm
 152  E253                  INCLUDE "../Layer2Graphics/asm_l2_plot_horizontal.asm"
# file opened: ../Layer2Graphics/asm_l2_plot_horizontal.asm
   1+ E253
   2+ E253              ;; NOTE DMA is little endian
   3+ E253 00           l2_horz_pixel           DB 0
   4+ E254
   5+ E254 83 C3 C7 CB  l2_horz_line            DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   5+ E258 7D
   6+ E259 53 E2        l2_horz_colr            DW l2_horz_pixel
   7+ E25B 00           l2_horz_lenlo           DB 0
   8+ E25C 00           l2_horz_lenhi           DB 0
   9+ E25D 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY, DMA_WR2_P2INC_MEMORY, DMA_WR4_CONT_MODE
  10+ E260 00 00        l2_horz_target          DB $00, $00
  11+ E262 CF 87                                DB DMA_LOAD, DMA_ENABLE
  12+ E264              l2_horz_cmd_len	        EQU $ - l2_horz_line
  13+ E264
  14+ E264
  15+ E264              ; "l2_draw_horz_dma"
  16+ E264              ; "plot at bc for length d colour e using dma, assumes bank already selected"
  17+ E264 7B           l2_draw_horz_dma:       ld		a,e                                               ; T=4      ;
  18+ E265 32 53 E2                             ld		(l2_horz_pixel),a                                 ; T=13     ;
  19+ E268 5A                                   ld      e,d ; saved 3 t states ld		a,d                                               ; T=4      ; e=d   4
  20+ E269 16 00                                ld      d,0; saved 3 t states ld 		(l2_horz_lenlo),a                                 ; T=13     ; d = 0  7
  21+ E26B ED 53 5B E2                          ld      (l2_horz_lenlo),de; saved 3 t states xor 	a                                                 ; T=4      ; t 20  31
  22+ E26F                                      ; saved 3 t states ld ld 		(l2_horz_lenhi),a                                 ; T=13     ;
  23+ E26F                                    ; saved 4 t states  ld		h,b                           ;          ;
  24+ E26F                                    ; saved 4 t states  ld		l,c                           ;          ;
  25+ E26F ED 43 60 E2                          ld      (l2_horz_target),bc ; saved 4 t states  was , hl  ; T=20     ;
  26+ E273 21 54 E2     .write_dma:             ld 		hl, l2_horz_line                                  ;          ;
  27+ E276 06 10                                ld 		b, l2_horz_cmd_len                                ;
  28+ E278 0E 6B                                ld		c,IO_DATAGEAR_DMA_PORT                            ;
  29+ E27A ED B3                                otir                                                      ;
  30+ E27C C9                                   ret
  31+ E27D
  32+ E27D              ; "bc = left side row,col, d = length, e = color"
  33+ E27D D5           l2_draw_horz_dma_bank:  push 	de							; save length and colour
  34+ E27E C5                                   push 	bc							; save row col
  35+ E27F 78                                   ld   	a,b
  36+ E280 CD 5B E0                             call 	asm_l2_row_bank_select		; now we have the correct bank, its a horizontal line so bank will not shift
  37+ E283 C1                                   pop  	bc
  38+ E284 47                                   ld	 	b,a	       					; fixed row by the call we can go straight into HL with row col
  39+ E285 D1                                   pop  	de							; get length back
  40+ E286 CD 64 E2                             call    l2_draw_horz_dma
  41+ E289 C9                                   ret
  42+ E28A
  43+ E28A              ; "l2_draw_horz_line"
  44+ E28A              ; "bc = left side row,col, d = length, e = color"
  45+ E28A              ; "optimisation if above min pix is will use dma call SCREEN_HOZ_MIN_PIX not implemented yet"
  46+ E28A 7A           l2_draw_horz_line:      ld		a,d
  47+ E28B FE 00                                cp 		0							; if its zero length then just return
  48+ E28D C8           .zerolengthexit:        ret		z
  49+ E28E FE 01        .isitlen1:              cp 		1
  50+ E290 CA B2 E2                             jp 		z,.l2_draw_horz_line_1
  51+ E293 FE 0A        .longenoughtfordma:     cp  10
  52+ E295 C3 7D E2                             jp  l2_draw_horz_dma_bank
  53+ E298 D5 C5        .plottableline:         push 	de,,bc  					; save length and colour an d row col
  54+ E29A 78                                   ld   	a,b
  55+ E29B CD 5B E0                             call 	asm_l2_row_bank_select		; now we have the correct bank, its a horizontal line so bank will not shift
  56+ E29E C1                                   pop  	bc
  57+ E29F 67                                   ld	 	h,a	       					; fixed row by the call we can go straight into HL with row col
  58+ E2A0 69                                   ld   	l,c
  59+ E2A1 D1                                   pop  	de							; get length back
  60+ E2A2 79           .cliptest:              ld	 	a,c							; get column + length
  61+ E2A3 42                                   ld  	b,d  						; speculate that we don't clip by pre-loading b with length
  62+ E2A4 82                                   add  	a,d
  63+ E2A5 30 06                                jr   	nc, .l2_draw_horz_plot_loop	; if carry is set c+d > 255
  64+ E2A7 3E FF        .clipat255:             ld   	a,$FF
  65+ E2A9 91                                   sub  	c							; a holds clipped length
  66+ E2AA 47                                   ld 		b, a 						; so now hl holds poke address  b = clipped length e = colour
  67+ E2AB 18 00                                jr		.l2_draw_horz_plot_loop
  68+ E2AD 73           .l2_draw_horz_plot_loop:ld (hl),e							; loop poking hl with e for b pixels
  69+ E2AE 23                                   inc hl
  70+ E2AF 10 FC                                djnz .l2_draw_horz_plot_loop
  71+ E2B1 C9                                   ret
  72+ E2B2 7B           .l2_draw_horz_line_1:   ld		a,e
  73+ E2B3 C3 29 E1                             jp		l2_plot_pixel				; hijack return
  74+ E2B6
  75+ E2B6              ; "l2_draw_horz_line_to"
  76+ E2B6              ; "bc = left side row,col, d right pixel, e = color"
  77+ E2B6 7A           l2_draw_horz_line_to:   ld 		a,d
  78+ E2B7 B9                                   cp 		c
  79+ E2B8 30 04                                jr		nc, .noswap
  80+ E2BA 28 07                                jr      z, .singlepixel
  81+ E2BC 51           .swap:                  ld		d,c
  82+ E2BD 4F                                   ld		c,a
  83+ E2BE 7A           .noswap:                ld		a,d
  84+ E2BF 91                                   sub		c
  85+ E2C0              ;                        dec		a							; so now its length not offset
  86+ E2C0 57                                   ld		d,a
  87+ E2C1 18 C7                                jr 		l2_draw_horz_line			; hijack routine and return statements
  88+ E2C3 7B           .singlepixel:           ld		a,e
  89+ E2C4 C3 29 E1                             jp		l2_plot_pixel				; hijack return
  90+ E2C7
# file closed: ../Layer2Graphics/asm_l2_plot_horizontal.asm
 153  E2C7                  INCLUDE "../Layer2Graphics/asm_l2_plot_vertical.asm"
# file opened: ../Layer2Graphics/asm_l2_plot_vertical.asm
   1+ E2C7              ; ">l2_draw_vert_segment"
   2+ E2C7              ; ">hl = bank adjusted pixel poke address d = length, e = color"
   3+ E2C7              ; ">will always clip once h = 64 even if length > 64 destroys a and hl, d = resudual length not plotted"
   4+ E2C7 7A           l2_draw_vert_segment:   ld		a,d
   5+ E2C8 FE 00        .emptylinecheck:	    cp 		0
   6+ E2CA C8                                   ret		z
   7+ E2CB FE 01        .justonepixel	        cp		1
   8+ E2CD 20 02                                jr		nz, .multiplepixelsLoop
   9+ E2CF 73                                   ld		(hl),e
  10+ E2D0 C9                                   ret
  11+ E2D1              .multiplepixelsLoop:
  12+ E2D1 7C           .endofbankcheck:        ld   	a,h
  13+ E2D2 FE 40                                cp   	64
  14+ E2D4 D0                                   ret		nc							; check before we poke data if we have hit a boundary
  15+ E2D5 73           .canplotapixel:         ld   	(hl),e						; set colour
  16+ E2D6 24                                   inc 	h							; we don't check here else we would need a dec d on ret could do for optimisation of loop though
  17+ E2D7 15                                   dec		d
  18+ E2D8 C8                                   ret		z
  19+ E2D9 18 F6                                jr		.multiplepixelsLoop
  20+ E2DB
  21+ E2DB              ; ">l2_draw_vert_line"
  22+ E2DB              ; ">bc = row col d = length, e = color"
  23+ E2DB 78           l2_draw_vert_line:      ld 		a,b
  24+ E2DC FE C0        .offscreencheck:        cp 		SCREEN_HEIGHT
  25+ E2DE D0                                   ret 	nc							; can't start off the screen
  26+ E2DF 7A           .emptylinecheck:        ld		a,d
  27+ E2E0 FE 00                                cp		0
  28+ E2E2 C8                                   ret		z
  29+ E2E3 FE 01                                cp		1
  30+ E2E5 20 04                                jr		nz,.multiplepixels
  31+ E2E7 CD 29 E1     .itsonepixel:           call	l2_plot_pixel
  32+ E2EA C9                                   ret
  33+ E2EB              .multiplepixels:						; so now we have at least 2 pixels to plot
  34+ E2EB 7A           .clipto192:             ld		a,d							; get length
  35+ E2EC 80                                   add		a,b							; a= row + length
  36+ E2ED 38 04                                jr		c,.needtoclip				; if it was > 255 then there is a definite need
  37+ E2EF FE C0                                cp		SCREEN_HEIGHT
  38+ E2F1 38 08                                jr		c, .noclipneeded
  39+ E2F3 78           .needtoclip             ld		a,b
  40+ E2F4 82                                   add		a,d
  41+ E2F5 D6 C0                                sub		SCREEN_HEIGHT
  42+ E2F7 67                                   ld		h,a							; use h as a temp holding for (row + length) - 192
  43+ E2F8 7A                                   ld		a,d
  44+ E2F9 94                                   sub		h
  45+ E2FA 57                                   ld		d,a							; d = length - ((row + length) - 192)
  46+ E2FB              ; so now BC = row col, d = length clipped, e = color
  47+ E2FB 78           .noclipneeded:          ld		a,b
  48+ E2FC C5 D5                                push	bc,,de
  49+ E2FE CD 5B E0                             call 	asm_l2_row_bank_select
  49+ E301               	 	; we now have poke address and a variable holding current bank number
  50+ E301 D1 C1                                pop		bc,,de
  51+ E303 67                                   ld		h,a							; b now tolds target pixel for first plot
  52+ E304 69                                   ld		l,c  						; and c holds pixel column for plotting
  53+ E305 CD C7 E2                             call 	l2_draw_vert_segment		; draw seg, d = pixels remaining
  54+ E308 7A                                   ld		a,d							; a and d = nbr pixels remaining
  55+ E309 FE 00                                cp		0
  56+ E30B 28 27                                jr		z, .doneplotting
  57+ E30D 3A 00 E0     .anotherbank:           ld		a, (varL2_BANK_SELECTED)
  58+ E310 3C                                   inc		a
  59+ E311 06 00                                ld		b,0
  60+ E313 C5 D5                                push	bc,,de
  61+ E315 CD 44 E0                             call 	asm_l2_bank_n_select
  62+ E318 D1 C1                                pop     bc,,de
  63+ E31A 60                                   ld		h,b							; b now tolds target pixel for first plot
  64+ E31B 69                                   ld		l,c  						; and c holds pixel column for plotting
  65+ E31C CD C7 E2                             call	l2_draw_vert_segment
  66+ E31F 7A                                   ld		a,d
  67+ E320 FE 00                                cp		0
  68+ E322 28 10                                jr		z,.doneplotting
  69+ E324 3A 00 E0     .yetanotherbank:        ld		a, (varL2_BANK_SELECTED)
  70+ E327 3C                                   inc		a
  71+ E328 06 00                                ld		b,0
  72+ E32A C5 D5                                push	bc,,de
  73+ E32C CD 44 E0                             call 	asm_l2_bank_n_select
  74+ E32F D1                                   pop		de
  75+ E330 E1                                   pop		hl							; hl = bc
  76+ E331 CD C7 E2                             call	l2_draw_vert_segment		; we have now hit 192 pixels so done
  77+ E334 C9           .doneplotting:	        ret
  78+ E335
  79+ E335              ; ">l2_draw_vert_line_to"
  80+ E335              ; ">bc = row col d = to position, e = color"
  81+ E335 78           l2_draw_vert_line_to:   ld		a,b
  82+ E336 BA                                   cp		d
  83+ E337 38 02                                jr		c, .noyswap
  84+ E339 42           .yswap:                 ld		b,d			; Swap round row numbers so we are always incrementing
  85+ E33A 57                                   ld		d,a			; now we have a top to bottom to we we can calc length from bc
  86+ E33B 7A           .noyswap:               ld		a,d 		; we still may have d in a but only if it was bottom to top
  87+ E33C 90                                   sub		b
  88+ E33D 3C                                   inc		a			; so now its length not offset
  89+ E33E 57                                   ld		d,a
  90+ E33F 18 9A                                jr		l2_draw_vert_line	; we can hijack its clipping, 0 check and return logic
  91+ E341                                      ; no return needed
  92+ E341
# file closed: ../Layer2Graphics/asm_l2_plot_vertical.asm
 154  E341                  INCLUDE "../Layer2Graphics/layer2_plot_diagonal.asm"
# file opened: ../Layer2Graphics/layer2_plot_diagonal.asm
   1+ E341
   2+ E341              l2_draw_box_to:
   3+ E341              ; ">l2_draw_box_to bc=rowcol, de=torowcol a=color"
   4+ E341              ; ">NOT IMPLEMENTED YET"
   5+ E341 C9           	ret
   6+ E342
   7+ E342              ;; Note l2stepx is done via self modifying code rather than an if for speed
   8+ E342              ;; l2stepx1 and l2stepx2 are the addresses to stick the inc or dec in
   9+ E342              l2decbstep	EQU $05
  10+ E342              l2incbstep	EQU	$04
  11+ E342              l2deccstep	EQU $0D
  12+ E342              l2inccstep	EQU	$0C
  13+ E342              		; l2 deltas are signed
  14+ E342 00 00        l2deltaY	DW	0
  15+ E344 00 00        l2deltaX	DW	0
  16+ E346 00           l2deltaYsq	db	0
  17+ E347 00           l2deltaXsq	db	0
  18+ E348 00           l2deltaYn	db	0
  19+ E349 00           l2deltaXn	db	0
  20+ E34A 00           l2deltaYsqn	db	0
  21+ E34B 00           l2deltaXsqn	db	0
  22+ E34C 00           l2linecolor	db	0
  23+ E34D 00 00        l2fraction	dw	0
  24+ E34F 00 00        l2e2		dw	0
  25+ E351 00           l2way		db	0
  26+ E352 00 00        l2targetPtr	dw	0
  27+ E354              ;; These arrays should be 192 but if we use 256 then getting array2 value is just inc h rather than indexing again.
  28+ E354 00 00 00...  l2targetArray1 ds	256
  29+ E454 00 00 00...  l2targetArray2 ds	256
  30+ E554              ;; Using Bresenham Algorithm draw a diagonal line top to bottom. First we must sort of course
  31+ E554              ;;plotLine(int x0, int y0, int x1, int y1)
  32+ E554              ;;    dx =  abs(x1-x0);
  33+ E554              ;;    sx = x0<x1 ? 1 : -1;
  34+ E554              ;;    dy = -abs(y1-y0);
  35+ E554              ;;    sy = y0<y1 ? 1 : -1;
  36+ E554              ;;    err = dx+dy;  /* error value e_xy */
  37+ E554              ;;    while (true)   /* loop */
  38+ E554              ;;        plot(x0, y0);
  39+ E554              ;;        if (x0==x1 && y0==y1) break;
  40+ E554              ;;        e2 = 2*err;
  41+ E554              ;;        if (e2 >= dy) /* e_xy+e_x > 0 */
  42+ E554              ;;            err += dy;
  43+ E554              ;;            x0 += sx;
  44+ E554              ;;        end if
  45+ E554              ;;        if (e2 <= dx) /* e_xy+e_y < 0 */
  46+ E554              ;;            err += dx;
  47+ E554              ;;            y0 += sy;
  48+ E554              ;;        end if
  49+ E554              ;;    end while
  50+ E554              ; ">l2_draw_diagonal_save, bc = y0,x0 de=y1,x1,a=array nbr ESOURCE LL30 or LION"
  51+ E554              ; ">hl will be either l2targetArray1 or 2"
  52+ E554              ; NOTE IF WE INTERLEAVE THESE TWO TABLES WE COUDL READ BOTH X POS as a 16 bit read
  53+ E554 FE 01        l2_draw_diagonal_save:  cp		1
  54+ E556 28 06                                jr		z,l2S_ItsArray1
  55+ E558 21 54 E4                             ld		hl,l2targetArray2
  56+ E55B C3 61 E5                             jp		l2S_setTarget
  57+ E55E 21 54 E3     l2S_ItsArray1:	        ld		hl,l2targetArray1
  58+ E561 22 52 E3     l2S_setTarget:	        ld		(l2targetPtr),hl
  59+ E564              ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
  60+ E564 32 4C E3                             ld		(l2linecolor),a					;save colour for later
  61+ E567 21 00 00                             ld		hl,0                            ;
  62+ E56A 22 44 E3                             ld		(l2deltaX),hl                   ;
  63+ E56D 22 42 E3                             ld		(l2deltaY),hl                   ; initlaise deltas as we will only be loading 8 bit in there but workign in 16 bit later
  64+ E570 78           l2S_preSort:            ld		a,b								;
  65+ E571                                      JumpIfALTNusng	d,l2S_noYSort			; we must have Y1 < Y2 (if eqyal then verical line picked up earlier
  65+ E571 BA          >                        cp      d
  65+ E572 DA 7A E5    >                        jp		c, l2S_noYSort
  66+ E575              l2S_SortBasedOnY:	    ldhlbc									;
  66+ E575 60          >                        ld		h,b
  66+ E576 69          >                        ld		l,c
  67+ E577 EB                                   ex		de,hl                           ;
  68+ E578                                      ldbchl									; swap over bc and de using hl as an intermediate
  68+ E578 44          >                        ld		b,h
  68+ E579 4D          >                        ld		c,l
  69+ E57A DD 62        l2S_noYSort:		    ld		ixh,d							; ixh now holds target Y coord post sorting
  70+ E57C DD 6B                                ld		ixl,e							; ixl now holds target X coord post sorting
  71+ E57E 79           l2S_setXLen:            ld		a,c                             ;
  72+ E57F                                      JumpIfALTNusng e,l2S_PosXLen			; if x1 < x2 then we have a positive increment
  72+ E57F BB          >                        cp      e
  72+ E580 DA 8C E5    >                        jp		c, l2S_PosXLen
  73+ E583 79           l2S_NegXLen:            ld		a,c                             ;
  74+ E584 93                                   sub     e                               ;
  75+ E585 32 44 E3                             ld		(l2deltaX),a					; As x1 > x2 we do deltaX = X1 - X2
  76+ E588 3E 0D                                ld		a,l2deccstep					; and set the value for inc dec self modifying to Dec
  77+ E58A 18 07                                jr		l2S_XINCDEC
  78+ E58C 7B           l2S_PosXLen:	        ld		a,e                             ;
  79+ E58D 91                                   sub		c                               ;
  80+ E58E 32 44 E3                             ld 		(l2deltaX),a                    ; As x1 < x2 we do deltaX = X2 - X1
  81+ E591 3E 0C                                ld		a,l2inccstep                    ; and set the value for inc dec self modifying to Inc
  82+ E593              l2S_XINCDEC:
  83+ E593 32 FF E5     	ld		(l2S_adjustCol),a				;
  84+ E596 32 2F E6     	ld		(l2S_adjustCol2),a				; update self modifying code for X update with inc or dec from above
  85+ E599              l2S_setYLen
  86+ E599 7A           	ld		a,d							 	; presorted on Y so it is now always positive
  87+ E59A 90           	sub		b
  88+ E59B 32 42 E3     	ld 		(l2deltaY),a					; DeltaY = Y2 - Y1
  89+ E59E              l2S_setErr:									;  LD H  := (D'-E')/2    round up if +ve or down if -ve
  90+ E59E              ldS_FracDYltDX:								;
  91+ E59E 2A 42 E3     	ld		hl,(l2deltaY)					; Fraction = dY - dX
  92+ E5A1 ED 5B 44 E3  	ld		de,(l2deltaX)
  93+ E5A5              	ClearCarryFlag
  93+ E5A5 B7          >                        or a
  94+ E5A6 ED 52        	sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
  95+ E5A8 EB           	ex		de,hl
  96+ E5A9 FD 62        	ld		iyh,d							; we will use IY reg for fractions
  97+ E5AB FD 6B        	ld		iyl,e
  98+ E5AD F2 D2 E5     	jp		p,l2S_fracIsPositive
  99+ E5B0              l2S_fracIsNegative:
 100+ E5B0              	NegIY
 100+ E5B0 AF          >                    xor a
 100+ E5B1 FD 95       >                    sub iyl
 100+ E5B3 FD 6F       >                    ld iyl,a
 100+ E5B5 9F          >                    sbc a,a
 100+ E5B6 FD 94       >                    sub iyh
 100+ E5B8 FD 67       >                    ld iyh,a
 101+ E5BA              	ShiftIYRight1
 101+ E5BA FD 7C       >			   ld 	a,iyh
 101+ E5BC CB 3F       >			   srl 	a
 101+ E5BE FD 67       >			   ld	iyh,a
 101+ E5C0 FD 7D       >			   ld 	a,iyl
 101+ E5C2 1F          >			   rra
 101+ E5C3 FD 6F       >			   ld	iyl,a
 102+ E5C5              	NegIY
 102+ E5C5 AF          >                    xor a
 102+ E5C6 FD 95       >                    sub iyl
 102+ E5C8 FD 6F       >                    ld iyl,a
 102+ E5CA 9F          >                    sbc a,a
 102+ E5CB FD 94       >                    sub iyh
 102+ E5CD FD 67       >                    ld iyh,a
 103+ E5CF C3 DD E5     	jp		l2S_SkipCalcInc					; so we have a negative frac
 104+ E5D2              l2S_fracIsPositive:
 105+ E5D2              	ShiftIYRight1
 105+ E5D2 FD 7C       >			   ld 	a,iyh
 105+ E5D4 CB 3F       >			   srl 	a
 105+ E5D6 FD 67       >			   ld	iyh,a
 105+ E5D8 FD 7D       >			   ld 	a,iyl
 105+ E5DA 1F          >			   rra
 105+ E5DB FD 6F       >			   ld	iyl,a
 106+ E5DD              l2S_SkipCalcInc:
 107+ E5DD              l2S_Loop:									; As we loop, bc = to plot current XY
 108+ E5DD 2A 52 E3     	ld		hl,(l2targetPtr)				; Insert into respective array
 109+ E5E0 78           	ld		a,b
 110+ E5E1 ED 31        	add		hl,a
 111+ E5E3 71           	ld		(hl),c
 112+ E5E4              l2S_CheckIfEnd:
 113+ E5E4 DD 7C        	ld		a,ixh
 114+ E5E6              	JumpIfAGTENusng	  b,l2S_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
 114+ E5E6 B8          >                        cp     b
 114+ E5E7 D2 ED E5    >                        jp		nc,l2S_CheckXPos
 115+ E5EA C3 F1 E5     	jp		l2S_Continue
 116+ E5ED              l2S_CheckXPos:
 117+ E5ED 79           	ld		a,c
 118+ E5EE              	ReturnIfAGTENusng ixl					; if X1 has reached or exceeded X2 then we are done
 118+ E5EE DD BD       >                        cp    ixl
 118+ E5F0 D0          >                        ret	 nc
 119+ E5F1              l2S_Continue:
 120+ E5F1              l2S_HNegative:
 121+ E5F1 FD 7C        	ld		a,iyh
 122+ E5F3 CB 7F        	bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
 123+ E5F5 28 0B        	jr		z,l2S_ErrNotNegative			;
 124+ E5F7              l2S_ErrNegative:								; if its a negative error update X
 125+ E5F7 3A 42 E3     	ld		a,(l2deltaY)
 126+ E5FA 16 00        	ld		d,0
 127+ E5FC 5F           	ld		e,a
 128+ E5FD FD 19        	add		iy,de							; add deltaY(unsinged) to l2fraction
 129+ E5FF              l2S_adjustCol:
 130+ E5FF 00           	nop										; this is our inc/dec of X
 131+ E600 18 DB        	jr		l2S_Loop							; repeat loop
 132+ E602              l2S_ErrNotNegative:
 133+ E602 FD 7C        	ld		a,iyh
 134+ E604 FD B5        	or		iyl
 135+ E606              	JumpIfAIsZero l2S_ErrZero					; if there is no error then goto zeroerror
 135+ E606 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 135+ E607 CA 20 E6    >                        jp	z, l2S_ErrZero
 136+ E60A              l2S_ErrPositive:								; if its a positive error then we update Y
 137+ E60A              	lddeiy
 137+ E60A FD 54       >                        ld		d,iyh
 137+ E60C FD 5D       >                        ld		e,iyl
 138+ E60E EB           	ex		de,hl
 139+ E60F 16 00        	ld		d,0
 140+ E611 3A 44 E3     	ld		a,(l2deltaX)
 141+ E614 5F           	ld		e,a
 142+ E615              	ClearCarryFlag
 142+ E615 B7          >                        or a
 143+ E616 ED 52        	sbc		hl,de
 144+ E618 EB           	ex		de,hl
 145+ E619              	ldiyde
 145+ E619 FD 62       >                        ld		iyh,d
 145+ E61B FD 6B       >                        ld		iyl,e
 146+ E61D              l2S_adjustRow:									; move Y down by one
 147+ E61D 04           	inc		b
 148+ E61E 18 BD        	jr		l2S_Loop
 149+ E620              l2S_ErrZero:
 150+ E620 2A 44 E3     	ld		hl,(l2deltaX)
 151+ E623 EB           	ex		de,hl
 152+ E624 2A 42 E3     	ld		hl,(l2deltaY)
 153+ E627              	ClearCarryFlag
 153+ E627 B7          >                        or a
 154+ E628 ED 52        	sbc		hl,de
 155+ E62A EB           	ex		de,hl
 156+ E62B              	ldiyde
 156+ E62B FD 62       >                        ld		iyh,d
 156+ E62D FD 6B       >                        ld		iyl,e
 157+ E62F              l2S_adjustCol2:
 158+ E62F 00           	nop										; update X and Y
 159+ E630 04           	inc		b
 160+ E631 18 AA        	jr		l2S_Loop
 161+ E633
 162+ E633              ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
 163+ E633 32 4C E3     l2_draw_diagonal:       ld		(l2linecolor),a					;save colour for later
 164+ E636 21 00 00                             ld		hl,0                            ;
 165+ E639 22 44 E3                             ld		(l2deltaX),hl                   ;
 166+ E63C 22 42 E3                             ld		(l2deltaY),hl                   ; initlaise deltas as we will only be loading 8 bit in there but workign in 16 bit later
 167+ E63F 78           l2D_preSort:            ld		a,b								;
 168+ E640                                      JumpIfALTNusng	d,l2D_noYSort			; we must have Y1 < Y2 (if equal then verical line picked up earlier
 168+ E640 BA          >                        cp      d
 168+ E641 DA 49 E6    >                        jp		c, l2D_noYSort
 169+ E644              l2D_SortBasedOnY:	    ldhlbc									;
 169+ E644 60          >                        ld		h,b
 169+ E645 69          >                        ld		l,c
 170+ E646 EB                                   ex		de,hl                           ;
 171+ E647                                      ldbchl									; swap over bc and de using hl as an intermediate
 171+ E647 44          >                        ld		b,h
 171+ E648 4D          >                        ld		c,l
 172+ E649 DD 62        l2D_noYSort:		    ld		ixh,d							; ixh now holds target Y coord post sorting
 173+ E64B DD 6B                                ld		ixl,e							; ixl now holds target X coord post sorting
 174+ E64D 79           l2D_setXLen:            ld		a,c                             ;
 175+ E64E                                      JumpIfALTNusng e,l2D_PosXLen			; if x1 < x2 then we have a positive increment
 175+ E64E BB          >                        cp      e
 175+ E64F DA 5B E6    >                        jp		c, l2D_PosXLen
 176+ E652 79           l2D_NegXLen:            ld		a,c                             ;
 177+ E653 93                                   sub     e                               ;
 178+ E654 32 44 E3                             ld		(l2deltaX),a					; As x1 > x2 we do deltaX = X1 - X2
 179+ E657 3E 0D                                ld		a,l2deccstep					; and set the value for inc dec self modifying to Dec
 180+ E659 18 07                                jr		l2D_XINCDEC
 181+ E65B 7B           l2D_PosXLen:	        ld		a,e                             ;
 182+ E65C 91                                   sub		c                               ;
 183+ E65D 32 44 E3                             ld 		(l2deltaX),a                    ; As x1 < x2 we do deltaX = X2 - X1
 184+ E660 3E 0C                                ld		a,l2inccstep                    ; and set the value for inc dec self modifying to Inc
 185+ E662 32 D1 E6     l2D_XINCDEC:	        ld		(l2D_adjustCol),a				;
 186+ E665 32 01 E7                             ld		(l2D_adjustCol2),a				; update self modifying code for X update with inc or dec from above
 187+ E668 7A           l2D_setYLen				ld		a,d							 	; presorted on Y so it is now always positive
 188+ E669 90                                   sub		b
 189+ E66A 32 42 E3                             ld 		(l2deltaY),a					; DeltaY = Y2 - Y1
 190+ E66D              l2D_setErr:									;  LD H  := (D'-E')/2    round up if +ve or down if -ve
 191+ E66D 2A 42 E3     ldD_FracDYltDX:			ld		hl,(l2deltaY)					; Fraction = dY - dX
 192+ E670 ED 5B 44 E3                          ld		de,(l2deltaX)
 193+ E674                                      ClearCarryFlag
 193+ E674 B7          >                        or a
 194+ E675 ED 52                                sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
 195+ E677 EB                                   ex		de,hl
 196+ E678 FD 62                                ld		iyh,d							; we will use IY reg for fractions
 197+ E67A FD 6B                                ld		iyl,e
 198+ E67C F2 A1 E6                             jp		p,l2D_fracIsPositive
 199+ E67F              l2D_fracIsNegative:     NegIY
 199+ E67F AF          >                    xor a
 199+ E680 FD 95       >                    sub iyl
 199+ E682 FD 6F       >                    ld iyl,a
 199+ E684 9F          >                    sbc a,a
 199+ E685 FD 94       >                    sub iyh
 199+ E687 FD 67       >                    ld iyh,a
 200+ E689                                      ShiftIYRight1
 200+ E689 FD 7C       >			   ld 	a,iyh
 200+ E68B CB 3F       >			   srl 	a
 200+ E68D FD 67       >			   ld	iyh,a
 200+ E68F FD 7D       >			   ld 	a,iyl
 200+ E691 1F          >			   rra
 200+ E692 FD 6F       >			   ld	iyl,a
 201+ E694                                      NegIY
 201+ E694 AF          >                    xor a
 201+ E695 FD 95       >                    sub iyl
 201+ E697 FD 6F       >                    ld iyl,a
 201+ E699 9F          >                    sbc a,a
 201+ E69A FD 94       >                    sub iyh
 201+ E69C FD 67       >                    ld iyh,a
 202+ E69E C3 AC E6                             jp		l2D_SkipCalcInc					; so we have a negative frac
 203+ E6A1              l2D_fracIsPositive:     ShiftIYRight1
 203+ E6A1 FD 7C       >			   ld 	a,iyh
 203+ E6A3 CB 3F       >			   srl 	a
 203+ E6A5 FD 67       >			   ld	iyh,a
 203+ E6A7 FD 7D       >			   ld 	a,iyl
 203+ E6A9 1F          >			   rra
 203+ E6AA FD 6F       >			   ld	iyl,a
 204+ E6AC              l2D_SkipCalcInc:
 205+ E6AC C5 D5        l2D_Loop:				push	bc,,de                 			; l2DeltaY and l2DeltaX are set
 206+ E6AE 3A 4C E3                             ld		a,(l2linecolor)     			;
 207+ E6B1 CD 29 E1                             call	l2_plot_pixel       			; Plot Pixel
 208+ E6B4 D1 C1                                pop     bc,,de
 209+ E6B6 DD 7C        l2D_CheckIfEnd:	        ld		a,ixh
 210+ E6B8                                      JumpIfAGTENusng	  b,l2D_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
 210+ E6B8 B8          >                        cp     b
 210+ E6B9 D2 BF E6    >                        jp		nc,l2D_CheckXPos
 211+ E6BC C3 C3 E6                             jp		l2D_Continue
 212+ E6BF 79           l2D_CheckXPos:          ld		a,c
 213+ E6C0                                      ReturnIfAEqNusng ixl					; if X1 has reached or exceeded X2 then we are done
 213+ E6C0 DD BD       >                        cp      ixl
 213+ E6C2 C8          >                        ret     z
 214+ E6C3              l2D_Continue:
 215+ E6C3 FD 7C        l2D_HNegative:			ld		a,iyh
 216+ E6C5 CB 7F                                bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
 217+ E6C7 28 0B                                jr		z,l2D_ErrNotNegative			;
 218+ E6C9 3A 42 E3     l2D_ErrNegative:		ld		a,(l2deltaY)
 219+ E6CC 16 00                                ld		d,0
 220+ E6CE 5F                                   ld		e,a
 221+ E6CF FD 19                                add		iy,de							; add deltaY(unsinged) to l2fraction
 222+ E6D1 00           l2D_adjustCol:          nop										; this is our inc/dec of X
 223+ E6D2 18 D8                                jr		l2D_Loop							; repeat loop
 224+ E6D4 FD 7C        l2D_ErrNotNegative:     ld		a,iyh
 225+ E6D6 FD B5                                or		iyl
 226+ E6D8                                      JumpIfAIsZero l2D_ErrZero					; if there is no error then goto zeroerror
 226+ E6D8 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 226+ E6D9 CA F2 E6    >                        jp	z, l2D_ErrZero
 227+ E6DC              l2D_ErrPositive:		lddeiy
 227+ E6DC FD 54       >                        ld		d,iyh
 227+ E6DE FD 5D       >                        ld		e,iyl
 228+ E6E0 EB                                   ex		de,hl
 229+ E6E1 16 00                                ld		d,0
 230+ E6E3 3A 44 E3                             ld		a,(l2deltaX)
 231+ E6E6 5F                                   ld		e,a
 232+ E6E7                                      ClearCarryFlag
 232+ E6E7 B7          >                        or a
 233+ E6E8 ED 52                                sbc		hl,de
 234+ E6EA EB                                   ex		de,hl
 235+ E6EB                                      ldiyde
 235+ E6EB FD 62       >                        ld		iyh,d
 235+ E6ED FD 6B       >                        ld		iyl,e
 236+ E6EF 04           l2D_adjustRow:			inc		b
 237+ E6F0 18 BA                                jr		l2D_Loop
 238+ E6F2 2A 44 E3     l2D_ErrZero:            ld		hl,(l2deltaX)
 239+ E6F5 EB                                   ex		de,hl
 240+ E6F6 2A 42 E3                             ld		hl,(l2deltaY)
 241+ E6F9                                      ClearCarryFlag
 241+ E6F9 B7          >                        or a
 242+ E6FA ED 52                                sbc		hl,de
 243+ E6FC EB                                   ex		de,hl
 244+ E6FD                                      ldiyde
 244+ E6FD FD 62       >                        ld		iyh,d
 244+ E6FF FD 6B       >                        ld		iyl,e
 245+ E701 00           l2D_adjustCol2:         nop										; update X and Y
 246+ E702 04                                   inc		b
 247+ E703 18 A7                                jr		l2D_Loop
 248+ E705              ;----------------------------------------------------------------------------------------------------------------------------------
 249+ E705
 250+ E705
 251+ E705
 252+ E705
 253+ E705              ;Loin:				; BBC version of line draw
 254+ E705              ;; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color)"
 255+ E705              ;	ld		(l2linecolor),a					; save colour as a reg gets used alot, coudl move this into interrupt flag and disable interrups
 256+ E705              ;	ld		ixh,0							; ixh = s
 257+ E705              ;	ld		iyh,0							; iyh = swap
 258+ E705              ;	ld		l,0								; l will hold delta sign flags
 259+ E705              ;LoinCalcDeltaX:
 260+ E705              ;	ld		a,e
 261+ E705              ;	sub		c								; a = deltaX
 262+ E705              ;	JumpIfPositive LoinPosDx
 263+ E705              ;LoinNegDx:
 264+ E705              ;	neg										; carry flag will indicate deltaX was negative
 265+ E705              ;	ld		l,$80							; set bit 7 of l for negative
 266+ E705              ;LoinPosDx:
 267+ E705              ;	ld		ixl,a							; ixl = varP = deltaX
 268+ E705              ;LoinCalcDeltaY:
 269+ E705              ;	ld		a,d
 270+ E705              ;	sub		b								; a= deltaY
 271+ E705              ;	JumpIfPositive LoinPosDy
 272+ E705              ;LoinNegDy:
 273+ E705              ;	neg
 274+ E705              ;	set		6,l								; set bit 6 of l for negative deltaY
 275+ E705              ;LoinPosDy:
 276+ E705              ;	ld		iyl,a							; iyl = varQ = deltaY
 277+ E705              ;	JumpIfAGTENusng ixl, LoinSTPy			; if deltaY >= DeltaX then step along Y
 278+ E705              ;LoinSTPx:									; step along X
 279+ E705              ;	JumpOnBitClear l,7						; if l flags were clear then X2 < X2
 280+ E705              ;LoinSTPxSwapCoords:
 281+ E705              ;	dec		iyh								; swap flag now becomes FF
 282+ E705              ;	ld		a,l								; save l flags
 283+ E705              ;	ex		de,hl							; save de to hl
 284+ E705              ;	lddebc									; Point2 = point1
 285+ E705              ;	ldbchl									; Point1 = point2 that was saved
 286+ E705              ;	ld		l,a								; get back l flags
 287+ E705              ;LoinSTPxCorrectOrder:
 288+ E705              ;	l2_point_pixel_y_safe					; call plot pixel preseving bc hl
 289+ E705              ;	ld		a,iyl							; get delta Y back
 290+ E705              ;	ld		iy1,$FE							; roll counter
 291+ E705              ;LionSTPxRollQ:
 292+ E705              ;	sla		a								; highest bit of delta-Y
 293+ E705              ;	jp		c,LoinSTPxSteep
 294+ E705              ;	cp		ixl								; compare with DeltaX
 295+ E705              ;	jp		cs,LoinSTPxShallow
 296+ E705              ;LoinSTPxSteep:								;; LI4
 297+ E705              ;	sbc		a,ixl							; deltaYwork -= (deltaX+1)
 298+ E705              ;	scf										; force carry flag set
 299+ E705              ;LoinSTPxShallow:							;; LI5
 300+ E705              ;	rl		iyl								; rotate iyl which started as FE
 301+ E705              ;	jp		c,LionSTPxRollQ					; so we are doing a 6 bit loop
 302+ E705              ;	inc		ihl								; DeltaX += 1
 303+ E705              ;LoinSTPxYDirection:							; change this to self modifying code
 304+ E705              ;	ld		a,d
 305+ E705              ;	JumpIfAGTEn	b,LionDOWN:
 306+ E705              ;	ld		a,iyh							; swap flag
 307+ E705              ;	JumpIfANotZero	X1Inc  					; if swap flag was not set then no need to update R
 308+ E705              ;LoinSTPxX1Dec:
 309+ E705              ;	dec		c								; move left 1 pixel as we sawped
 310+ E705              ;LoinSTPxXCounter:							;; LIL2
 311+ E705              ;	sub		b
 312+ E705              ;	if
 313+ E705              ;
 314+ E705              ;85 82                   STA &82	   \ R	\ mask byte
 315+ E705              ;A5 81                   LDA &81	   \ Q	\ delta-Y
 316+ E705              ;A2 FE                   LDX #&FE	\ roll counter
 317+ E705              ;86 81                   STX &81		\ Q
 318+ E705              ;.LIL1	\ roll Q
 319+ E705              ;0A                      ASL A		\ highest bit of delta-Y
 320+ E705              ;B0 04                   BCS LI4		\ steep
 321+ E705              ;C5 1B                   CMP &1B	   \ P	\ delta-X
 322+ E705              ;90 03                   BCC LI5		\ shallow
 323+ E705              ;.LI4	\ steep
 324+ E705              ;E5 1B                   SBC &1B		\ P
 325+ E705              ;38                      SEC
 326+ E705              ;.LI5	\ shallow
 327+ E705              ;26 81                   ROL &81	   \ Q	\ #&FE
 328+ E705              ;B0 F2                   BCS LIL1 	\ loop Q, end with some low bits in Q
 329+ E705              ;A6 1B                   LDX &1B		\ P
 330+ E705              ;E8                      INX 		\ Xreg is width
 331+ E705              ;A5 37                   LDA &37		\ Y2
 332+ E705              ;E5 35                   SBC &35		\ Y1
 333+ E705              ;B0 2C                   BCS DOWN	\ draw line to the right and down
 334+ E705              ;A5 90                   LDA &90		\ SWAP
 335+ E705              ;D0 07                   BNE LI6		\ else Xreg was correct after all, no need to update R
 336+ E705              ;CA                      DEX
 337+ E705              ;.LIL2	\ counter X width
 338+ E705              ;A5 82                   LDA &82	   \ R	\ mask byte
 339+ E705              ;51 07                   EOR (&07),Y	\ (SC),Y
 340+ E705              ;91 07                   STA (&07),Y	\ (SC),Y
 341+ E705              ;.LI6	\ Xreg correct
 342+ E705              ;46 82                   LSR &82	   \ R	\ mask byte
 343+ E705              ;90 08                   BCC LI7   	\ else moving to next column to right. Bring carry in back
 344+ E705              ;66 82                   ROR &82		\ R
 345+ E705              ;A5 07                   LDA &07		\ SC
 346+ E705              ;69 08                   ADC #8		\ next column
 347+ E705              ;85 07                   STA &07		\ SC
 348+ E705              ;.LI7	\ S += Q. this is like an overflow monitor to update Y
 349+ E705              ;A5 83                   LDA &83		\ S
 350+ E705              ;65 81                   ADC &81	   \ Q	\ some low bits
 351+ E705              ;85 83                   STA &83		\ S
 352+ E705              ;90 07                   BCC LIC2	\ skip Y adjustment
 353+ E705              ;88                      DEY
 354+ E705              ;10 04                   BPL LIC2	\ skip Y adjustment
 355+ E705              ;C6 08                   DEC &08		\ SC+1
 356+ E705              ;A0 07                   LDY #7
 357+ E705              ;.LIC2	\ skip Y adjustment
 358+ E705              ;CA                      DEX
 359+ E705              ;D0 DC                   BNE LIL2	\ loop X width
 360+ E705              ;A4 85                   LDY &85	 \ YSAV \ restore Yreg
 361+ E705              ;60                      RTS
 362+ E705              ;
 363+ E705              ;.DOWN	\ Line is going to the right and down
 364+ E705              ;A5 90                   LDA &90		\ SWAP
 365+ E705              ;F0 07                   BEQ LI9		\ no swap
 366+ E705              ;CA                      DEX
 367+ E705              ;.LIL3	\ counter X width
 368+ E705              ;A5 82                   LDA &82	    \ R \ mask byte
 369+ E705              ;51 07                   EOR (&07),Y	\ (SC),Y
 370+ E705              ;91 07                   STA (&07),Y	\ (SC),Y
 371+ E705              ;.LI9	\ no swap
 372+ E705              ;46 82                   LSR &82		\ R
 373+ E705              ;90 08                   BCC LI10	\ still in correct column, hop
 374+ E705              ;66 82                   ROR &82		\ R
 375+ E705              ;A5 07                   LDA &07		\ SC
 376+ E705              ;69 08                   ADC #8		\ next column
 377+ E705              ;85 07                   STA &07		\ SC
 378+ E705              ;.LI10	\ this is like an overflow monitor to update Y
 379+ E705              ;A5 83                   LDA &83		\ S
 380+ E705              ;65 81                   ADC &81		\ Q
 381+ E705              ;85 83                   STA &83		\ S
 382+ E705              ;90 09                   BCC LIC3	\ skip Y adjustment
 383+ E705              ;C8                      INY
 384+ E705              ;C0 08                   CPY #8
 385+ E705              ;D0 04                   BNE LIC3	\ have not reached bottom byte of char, hop
 386+ E705              ;E6 08                   INC &08		\ SC+1
 387+ E705              ;A0 00                   LDY #0
 388+ E705              ;.LIC3	\ skipped Y adjustment
 389+ E705              ;CA                      DEX
 390+ E705              ;D0 DA                   BNE LIL3	\ loop X width
 391+ E705              ;A4 85                   LDY &85	 \ YSAV \ restore Yreg
 392+ E705              ;60                      RTS
 393+ E705              ;
 394+ E705              ;.STPY	\ -> &1797 \ Step along y for line, goes down and to right
 395+ E705              ;A4 35                   LDY &35		\ Y1
 396+ E705              ;98                      TYA
 397+ E705              ;A6 34                   LDX &34		\ X1
 398+ E705              ;C4 37                   CPY &37		\ Y2
 399+ E705              ;B0 10                   BCS LI15	\ skip swap if Y1 >= Y2
 400+ E705              ;C6 90                   DEC &90		\ SWAP
 401+ E705              ;A5 36                   LDA &36		\ X2
 402+ E705              ;85 34                   STA &34		\ X1
 403+ E705              ;86 36                   STX &36		\ X2
 404+ E705              ;AA                      TAX
 405+ E705              ;A5 37                   LDA &37		\ Y2
 406+ E705              ;85 35                   STA &35		\ Y1
 407+ E705              ;84 37                   STY &37		\ Y2
 408+ E705              ;A8                      TAY
 409+ E705              ;.LI15	\ Y1 Y2 order is now correct
 410+ E705              ;4A                      LSR A
 411+ E705              ;4A                      LSR A
 412+ E705              ;4A                      LSR A
 413+ E705              ;09 60                   ORA #&60
 414+ E705              ;85 08                   STA &08	 \ SC+1	\ screen hi
 415+ E705              ;8A                      TXA 		\ X1
 416+ E705              ;29 F8                   AND #&F8
 417+ E705              ;85 07                   STA &07	  \ SC	\ screen lo
 418+ E705              ;8A                      TXA
 419+ E705              ;29 07                   AND #7		\ mask index
 420+ E705              ;AA                      TAX
 421+ E705              ;BD AF 16                LDA &16AF,X \ TWOS,X \ Mode4 single pixel
 422+ E705              ;85 82                   STA &82	    \ R	\ mask
 423+ E705              ;A5 35                   LDA &35		\ Y1
 424+ E705              ;29 07                   AND #7
 425+ E705              ;A8                      TAY
 426+ E705              ;A5 1B                   LDA &1B	    \ P	\ delta-X
 427+ E705              ;A2 01                   LDX #1		\ roll counter
 428+ E705              ;86 1B                   STX &1B	    	\ P
 429+ E705              ;.LIL4	\ roll P
 430+ E705              ;0A                      ASL A
 431+ E705              ;B0 04                   BCS LI13	\ do subtraction
 432+ E705              ;C5 81                   CMP &81	    \ Q	\ delta-Y
 433+ E705              ;90 03                   BCC LI14	\ less than Q
 434+ E705              ;.LI13	\ do subtraction
 435+ E705              ;E5 81                   SBC &81		\ Q
 436+ E705              ;38                      SEC
 437+ E705              ;.LI14	\ less than Q
 438+ E705              ;26 1B                   ROL &1B		\ P
 439+ E705              ;90 F2                   BCC LIL4	\ loop P, end with some low bits in P
 440+ E705              ;A6 81                   LDX &81		\ Q
 441+ E705              ;E8                      INX 		\ adjust height
 442+ E705              ;A5 36                   LDA &36		\ X2
 443+ E705              ;E5 34                   SBC &34		\ X1
 444+ E705              ;90 2D                   BCC LFT		\ if C cleared then line moving to the left - hop down
 445+ E705              ;18                      CLC
 446+ E705              ;A5 90                   LDA &90		\ SWAP
 447+ E705              ;F0 07                   BEQ LI17 	\ skip first point
 448+ E705              ;CA                      DEX
 449+ E705              ;.LIL5	\ skipped first point, counter X
 450+ E705              ;A5 82                   LDA &82	    \ R \ mask byte
 451+ E705              ;51 07                   EOR (&07),Y	\ (SC),Y
 452+ E705              ;91 07                   STA (&07),Y	\ (SC),Y
 453+ E705              ;.LI17	\ skipped first point
 454+ E705              ;88                      DEY
 455+ E705              ;10 04                   BPL LI16	\ skip hi adjust
 456+ E705              ;C6 08                   DEC &08		\ SC+1
 457+ E705              ;A0 07                   LDY #7		\ new char
 458+ E705              ;	.LI16	\ skipped hi adjust
 459+ E705              ;A5 83                   LDA &83		\ S
 460+ E705              ;65 1B                   ADC &1B		\ P
 461+ E705              ;85 83                   STA &83		\ S
 462+ E705              ;90 0C                   BCC LIC5	\ skip, still in same column
 463+ E705              ;46 82                   LSR &82	  \ R	\ mask
 464+ E705              ;90 08                   BCC LIC5  	\ no mask bit hop
 465+ E705              ;66 82                   ROR &82   \ R	\ else moved over to next column, reset mask
 466+ E705              ;A5 07                   LDA &07	  \ SC  \ screen lo
 467+ E705              ;69 08                   ADC #8		\ next char below
 468+ E705              ;85 07                   STA &07		\ SC
 469+ E705              ;.LIC5	\ same column
 470+ E705              ;CA                      DEX
 471+ E705              ;D0 DC                   BNE LIL5	\ loop X height
 472+ E705              ;A4 85                   LDY &85	 \ YSAV	\ restore Yreg
 473+ E705              ;60                      RTS
 474+ E705              ;
 475+ E705              ;.LFT	\ going left
 476+ E705              ;A5 90                   LDA &90		\ SWAP
 477+ E705              ;F0 07                   BEQ LI18	\ skip first point
 478+ E705              ;CA                      DEX 		\ reduce height
 479+ E705              ;.LIL6	\ counter X height
 480+ E705              ;A5 82                   LDA &82	   \ R	\ mask byte
 481+ E705              ;51 07                   EOR (&07),Y	\ (SC),Y
 482+ E705              ;91 07                   STA (&07),Y	\ (SC),Y
 483+ E705              ;.LI18
 484+ E705              ;88                      DEY
 485+ E705              ;10 04                   BPL LI19	\ skip hi adjust
 486+ E705              ;C6 08                   DEC &08		\ SC+1
 487+ E705              ;A0 07                   LDY #7		\ rest char row
 488+ E705              ;.LI19	\ skipped hi adjust
 489+ E705              ;A5 83                   LDA &83		\ S
 490+ E705              ;65 1B                   ADC &1B	    \ P \ some low bits
 491+ E705              ;85 83                   STA &83		\ S
 492+ E705              ;90 0D                   BCC LIC6	\ no overflow
 493+ E705              ;06 82                   ASL &82	    \ R \ else move byte mask to the left
 494+ E705              ;90 09                   BCC LIC6	\ no overflow
 495+ E705              ;26 82                   ROL &82		\ R
 496+ E705              ;A5 07                   LDA &07		\ SC
 497+ E705              ;E9 07                   SBC #7		\ down 1 char
 498+ E705              ;85 07                   STA &07		\ SC
 499+ E705              ;18                      CLC
 500+ E705              ;.LIC6	\ no overflow
 501+ E705              ;CA                      DEX 		\ height
 502+ E705              ;D0 DB                   BNE LIL6	\ loop X
 503+ E705              ;A4 85                   LDY &85	 \ YSAV	\ restore Yreg
 504+ E705              ;.HL6
 505+ E705              ;60                      RTS 		\ end Line drawing
 506+ E705
 507+ E705
 508+ E705              ;;l2_draw_diagonalopt:
 509+ E705              	; ">TODO l2_draw_diagonalopt fast horz vert optmisation"
 510+ E705              ;;	push	af
 511+ E705              ;;	ld		a,b
 512+ E705              ;;	cp		d
 513+ E705              ;;	jr		z,.RegularDiagnonal
 514+ E705              ;;.CheckHorz:
 515+ E705              ;;	ld		a,c
 516+ E705              ;;	cp		e
 517+ E705              ;;	jr		z,.horizontalLine
 518+ E705              ;;.RegularDiagnonal:
 519+ E705              ;;	pop		af
 520+ E705              ;;	call diag
 521+ E705
 522+ E705
 523+ E705              ;;l2_signed_mul2a:
 524+ E705              ;;; ">l2_signed_mul2a - Signed a = a * 2 using shift)"
 525+ E705              ;;	TEST	$80
 526+ E705              ;;	jr		nz, .negativecalc
 527+ E705              ;;.positivecalc:
 528+ E705              ;;	ccf
 529+ E705              ;;	rla
 530+ E705              ;;	ret
 531+ E705              ;;.negativecalc:
 532+ E705              ;;	neg
 533+ E705              ;;	ccf
 534+ E705              ;;	rla
 535+ E705              ;;	neg
 536+ E705              ;;	ret
 537+ E705              ;;
 538+ E705              ;;l2_signed_mul2atohl:
 539+ E705              ;;; ">l2_signed_mul2ahl - Signed hl = a * 2 using shift)"
 540+ E705              ;;	TEST	$80
 541+ E705              ;;	jr		nz, .negativecalc
 542+ E705              ;;.positivecalc:
 543+ E705              ;;	ld		hl,0
 544+ E705              ;;	ld		l,a
 545+ E705              ;;	add		hl,a
 546+ E705              ;;	ret
 547+ E705              ;;.negativecalc:
 548+ E705              ;;	neg
 549+ E705              ;;	ld		hl,0
 550+ E705              ;;	ld		l,a
 551+ E705              ;;	neghl
 552+ E705              ;;	ret
 553+ E705              ;;
 554+ E705              ;;l2_e2fractionby2:
 555+ E705              ;;	ld 		hl,(l2fraction)
 556+ E705              ;;	push	de
 557+ E705              ;;	ld		d,h
 558+ E705              ;;	ld		e,l
 559+ E705              ;;	add		hl,de
 560+ E705              ;;	pop		de
 561+ E705              ;;	ld		(l2e2),hl
 562+ E705              ;;	ret
 563+ E705
 564+ E705
 565+ E705
 566+ E705
 567+ E705
 568+ E705              ;;//	ld		(l2linecolor),a   			; could do an ex but it will be needed multiple times between many uses of a reg
 569+ E705              ;;//.catchLoop:
 570+ E705              ;;//	jp .catchLoop
 571+ E705              ;;//.continue:
 572+ E705              ;;//    ld      A,D
 573+ E705              ;;//    sub     H
 574+ E705              ;;//    jr      NC,.DXpositive    ;delta_x > 0
 575+ E705              ;;//.DXNegative:
 576+ E705              ;;//    neg
 577+ E705              ;;//.DXPositive:
 578+ E705              ;;//    ld      B,A              ;B <- |delta_x|
 579+ E705              ;;//    ld      A,E
 580+ E705              ;;//    sub     L
 581+ E705              ;;//    jr      NC,.DYpositive    ;delta_y > 0
 582+ E705              ;;//.DYNegative:
 583+ E705              ;;//    neg
 584+ E705              ;;//.DYPositive:
 585+ E705              ;;//    sub     B               ;|delta_y|
 586+ E705              ;;//	push	af
 587+ E705              ;;//	jr		c,.DeltaX
 588+ E705              ;;//.DeltaY
 589+ E705              ;;//	ld      A,H             			;if |delta_x| < |delta_y| then
 590+ E705              ;;//    ld      H,L             			;then values x and y are swapped
 591+ E705              ;;//    ld      L,A             			;so the loop will always be performed on the
 592+ E705              ;;//    ld      A,D             			;x value. A flag must be set to
 593+ E705              ;;//    ld      D,E             			;remind that data must be drawn (y,x)
 594+ E705              ;;//    ld      E,A             			;instead of (x,y)
 595+ E705              ;;//.DeltaX:
 596+ E705              ;;//	ld		a,d
 597+ E705              ;;//	sub		h
 598+ E705              ;;//	jr		nc,.TestDY					; x1 < x2
 599+ E705              ;;//.TestDX:
 600+ E705              ;;//	ex		de,hl
 601+ E705              ;;//.TestDY:
 602+ E705              ;;//	ld		a,e
 603+ E705              ;;//	sub		l
 604+ E705              ;;//    ld      A,$01
 605+ E705              ;;//    jr      NC,.StoreA
 606+ E705              ;;//    neg                     ;y1 > y2 : in case2 the 'y' variable
 607+ E705              ;;//.StoreA:
 608+ E705              ;;//        ld      (l2way),A
 609+ E705              ;;//.InitLine:
 610+ E705              ;;//        ld      B,H
 611+ E705              ;;//        ld      C,L
 612+ E705              ;;//        ld      A,E
 613+ E705              ;;//        sub     L
 614+ E705              ;;//        jr      NC,.EndInit
 615+ E705              ;;//        ld      A,L
 616+ E705              ;;//        ld      L,E
 617+ E705              ;;//        ld      E,A
 618+ E705              ;;//.EndInit:
 619+ E705              ;;//        ld      A,E
 620+ E705              ;;//        sub     L
 621+ E705              ;;//        rla
 622+ E705              ;;//        ld      L,A             ;value to add in case1 (d < 0)
 623+ E705              ;;//        add     A,H
 624+ E705              ;;//        sub     D
 625+ E705              ;;//        ld      E,A             ;'d' variable is initialised
 626+ E705              ;;//        add     A,H
 627+ E705              ;;//        sub     D
 628+ E705              ;;//        ld      H,A             ;value to add in case2 (d >= 0)
 629+ E705              ;;//.Loop:
 630+ E705              ;;//        ld      A,B
 631+ E705              ;;//        sub     D
 632+ E705              ;;//        jr      NC,.EndLine       ;the line is completely drawn.
 633+ E705              ;;//        pop     AF
 634+ E705              ;;//        bit     7,A
 635+ E705              ;;//        push    AF
 636+ E705              ;;//        push    AF
 637+ E705              ;;//        push    BC
 638+ E705              ;;//        jr      Z,.DrawPoint
 639+ E705              ;;//        ld      A,B
 640+ E705              ;;//        ld      B,C
 641+ E705              ;;//        ld      C,A
 642+ E705              ;;//.DrawPoint:
 643+ E705              ;;//		push	hl
 644+ E705              ;;//		pushbcdeaf
 645+ E705              ;;//		ld		b,e
 646+ E705              ;;//		ld		c,d
 647+ E705              ;;//	ld 		a,(l2linecolor)
 648+ E705              ;;//	call	l2_plot_pixel
 649+ E705              ;;//		popafdebc
 650+ E705              ;;//		pop		hl
 651+ E705              ;;//        pop     BC
 652+ E705              ;;//        pop     AF
 653+ E705              ;;//.TestD:
 654+ E705              ;;//        bit     7,E
 655+ E705              ;;//        jr      NZ,.Case1
 656+ E705              ;;//.Case2:                          ;d >= 0
 657+ E705              ;;//        ld      A,E
 658+ E705              ;;//        add     A,H
 659+ E705              ;;//        ld      E,A
 660+ E705              ;;//        ld      A,(l2way)
 661+ E705              ;;//        add     A,C
 662+ E705              ;;//        ld      C,A
 663+ E705              ;;//        jr      .EndLoop
 664+ E705              ;;//.Case1:                          ;d < 0
 665+ E705              ;;//        ld      A,E
 666+ E705              ;;//        add     A,L
 667+ E705              ;;//        ld      E,A
 668+ E705              ;;//.EndLoop:
 669+ E705              ;;//        inc     B
 670+ E705              ;;//        jr      .Loop
 671+ E705              ;;//.EndLine:
 672+ E705              ;;//        pop     AF              ;MUST NOT BE REMOVED
 673+ E705              ;;//        pop     HL              ;can be removed
 674+ E705              ;;//        pop     DE              ;can be removed
 675+ E705              ;;//        ret
 676+ E705
 677+ E705              ;;	ld		(.l2yadjust),a
 678+ E705              ;;	call	calcdeltax:
 679+ E705              ;;	ld		(.l2xadjust),a
 680+ E705              ;;.calcfraction:							; err(or fraction) = dx+dy;
 681+ E705              ;;	push	hl
 682+ E705              ;;	push	de
 683+ E705              ;;	ld		hl,(l2deltaX)
 684+ E705              ;;	ld		de,(l2deltaY)
 685+ E705              ;;	add		hl,de
 686+ E705              ;;	ld		(l2fraction),hl
 687+ E705              ;;	pop		de
 688+ E705              ;;	pop		hl
 689+ E705              ;;.mainloop:
 690+ E705              ;;	push	bc
 691+ E705              ;;	push	de
 692+ E705              ;;	ld 		a,(l2linecolor)
 693+ E705              ;;	call	l2_plot_pixel
 694+ E705              ;;	pop		de
 695+ E705              ;;	pop		bc
 696+ E705              ;;.arewefinishedtest
 697+ E705              ;;	ld		a,b
 698+ E705              ;;	cp		d
 699+ E705              ;;	jr		nz,.notthereyet
 700+ E705              ;;	ld		a,c
 701+ E705              ;;	cp		e
 702+ E705              ;;	ret		z
 703+ E705              ;;.notthereyet:
 704+ E705              ;;	push	de
 705+ E705              ;;	call	l2_e2fractionby2			; e2 = 2*err;
 706+ E705              ;;	pop		de
 707+ E705              ;;.e2dytest:								; if (e2 >= dy) /* e_xy+e_x > 0 */  then S and P/V are the same
 708+ E705              ;;	push	de							; so if m & pe  or p & po calc (m = sign set p = 0)
 709+ E705              ;;	ld		de,(l2deltaY)				;    if m & po  or p & pe skip  (pe = pv set po = pv 0)
 710+ E705              ;;	or		a							;
 711+ E705              ;;	sbc		hl,de						;
 712+ E705              ;;	pop		de
 713+ E705              ;;	jr		z,  .dodycalc				; if equal then calc
 714+ E705              ;;	jp		p,	.dodycalc				; sign clear to H>D even with negtives
 715+ E705              ;;	jr		.skipdycalc         		; sign = 0     so  skip as pe
 716+ E705              ;;.dodycalc:
 717+ E705              ;;	ld		hl,(l2fraction)
 718+ E705              ;;	push	de
 719+ E705              ;;	ld		de,(l2deltaY)
 720+ E705              ;;	add		hl,de
 721+ E705              ;;	ld		(l2fraction),de
 722+ E705              ;;	pop		de
 723+ E705              ;;.l2yadjust:
 724+ E705              ;;	nop
 725+ E705              ;;.skipdycalc:
 726+ E705              ;;.e2dxtest:								;  if (e2 <= dx) /* e_xy+e_y < 0 */ then S and P/V are different.
 727+ E705              ;;	ld		hl,(l2e2)
 728+ E705              ;;	push	de							;
 729+ E705              ;;	ld		de,(l2deltaX)				;
 730+ E705              ;;	or		a							; clear carry flag
 731+ E705              ;;	sbc		hl,de						; hl = hl - de is if de > hl will get pv and signed different?
 732+ E705              ;;	pop		de
 733+ E705              ;;	jr		z,.dodxcalc					; e2 == dx so do calc
 734+ E705              ;;	jp		m,.dodxcalc					; was sign bit set
 735+ E705              ;;	jr		.skipdxcalc         	    ; diff so skip ; pvclear = po        pvset = pe
 736+ E705              ;;.dodxcalc:
 737+ E705              ;;	ld		hl,(l2fraction)
 738+ E705              ;;	push	de
 739+ E705              ;;	ld		de,(l2deltaX)
 740+ E705              ;;	add		hl,de
 741+ E705              ;;	ld		(l2fraction),de
 742+ E705              ;;	pop		de
 743+ E705              ;;.l2xadjust:
 744+ E705              ;;	nop
 745+ E705              ;;.skipdxcalc:
 746+ E705              ;;	jr 		.mainloop
 747+ E705
 748+ E705
 749+ E705              ;;/l2_draw_diagonalold:
 750+ E705              ;;/MESSAGE ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color)"
 751+ E705              ;;/	ld		(l2linecolor),a   			; could do an ex but it will be needed multiple times between many uses of a reg
 752+ E705              ;;/.sortycoords:
 753+ E705              ;;/	ld		a,b							; Sort to Y0 is always > y1 so we don't have to deal with step y and only step x
 754+ E705              ;;/	cp		d
 755+ E705              ;;/	jr		nc, .nocoordswap
 756+ E705              ;;/.swapcoords:
 757+ E705              ;;/	ex		de,hl						; save de to hl ! effective code line 98 after macros
 758+ E705              ;;/	lddebc
 759+ E705              ;;/	ldbchl
 760+ E705              ;;/.nocoordswap:
 761+ E705              ;;/	ld		a,d							; l2_dy = -ABS(l2_vy1 - l2_vy0)
 762+ E705              ;;/	sub		b							; we have already sorted  so y1 > y0
 763+ E705              ;;/	ld		(l2deltaY),a
 764+ E705              ;;/	neg									; DEBUG
 765+ E705              ;;/	ld		(l2deltaYn),a				; DEBUG
 766+ E705              ;;/	neg									; DEBUG
 767+ E705              ;;/.deltaxequABSx0Minusx1:						; we need to set l2dx to abs x1-x0 and set
 768+ E705              ;;/    ld		a,c
 769+ E705              ;;/	cp		e
 770+ E705              ;;/	jr		c, .x1GTx0
 771+ E705              ;;/.x1LTx0
 772+ E705              ;;/	ld		a,c
 773+ E705              ;;/	sub		e
 774+ E705              ;;/	ld		(l2deltaX),a				; just 8 bit for now should it be 16?
 775+ E705              ;;/	neg									; DEBUG
 776+ E705              ;;/	ld		(l2deltaXn),a				; DEBUG
 777+ E705              ;;/	neg									; DEBUG
 778+ E705              ;;/	ld		a,l2incbstep
 779+ E705              ;;/	jr		.setlayershift0
 780+ E705              ;;/.x1GTx0:
 781+ E705              ;;/	ld		a,e
 782+ E705              ;;/	sub		c
 783+ E705              ;;/	ld		(l2deltaX),a					; just 8 bit for now should it be 16?
 784+ E705              ;;/	neg									; DEBUG
 785+ E705              ;;/	ld		(l2deltaXn),a				; DEBUG
 786+ E705              ;;/	neg									; DEBUG
 787+ E705              ;;/	ld		a,l2decbstep
 788+ E705              ;;/.setlayershift0:
 789+ E705              ;;/	ld		a,0
 790+ E705              ;;/	pushbcde
 791+ E705              ;;/	call	asm_l2_bank_n_select		; l2_layer_shift = 0 and bank 0 selected
 792+ E705              ;;/	popdebc
 793+ E705              ;;/; so now we have set inc or dec instruction, l2dy, l2dx and on bank 0,
 794+ E705              ;;/.dymuliplyby2:
 795+ E705              ;;/	ld		a, (l2deltaY)				; dy *= 2
 796+ E705              ;;/	call	l2_signed_mul2a
 797+ E705              ;;/	ld		(l2deltaYsq),a
 798+ E705              ;;/	neg									; DEBUG
 799+ E705              ;;/	ld		(l2deltaYsqn),a				; DEBUG
 800+ E705              ;;/	neg									; DEBUG
 801+ E705              ;;/.dxmuliplyby2:
 802+ E705              ;;/	ld		a, (l2deltaX)				; dx *= 2
 803+ E705              ;;/	call	l2_signed_mul2a
 804+ E705              ;;/	ld		(l2deltaXsq),a
 805+ E705              ;;/	neg									; DEBUG
 806+ E705              ;;/	ld		(l2deltaXsqn),a				; DEBUG
 807+ E705              ;;/	neg									; DEBUG
 808+ E705              ;;/.plotfirstpixel:
 809+ E705              ;;/	pushbcde
 810+ E705              ;;/	ld a,(l2linecolor)
 811+ E705              ;;/	call	l2_plot_pixel
 812+ E705              ;;/	popdebc
 813+ E705              ;;/.mainloop:								; if (l2_dx > l2_dy) signed
 814+ E705              ;;/	ld		a,(l2deltaX)				;If A < N, then S and P/V are different.
 815+ E705              ;;/	ld		hl,l2deltaY					;A >= N, then S and P/V are the same
 816+ E705              ;;/	cp		(hl)
 817+ E705              ;;/	jp		m,	.signset
 818+ E705              ;;/.signclear:
 819+ E705              ;;/	jp		pe,	.dxLTEdybranch
 820+ E705              ;;/	jr		.dxGTdybranch
 821+ E705              ;;/.signset:
 822+ E705              ;;/	jp		po,	.dxLTEdybranch
 823+ E705              ;;/.dxGTdybranch:
 824+ E705              ;;/	ld		a,(l2deltaYsq)
 825+ E705              ;;/	ld		hl,l2deltaX
 826+ E705              ;;/	sub		(hl)
 827+ E705              ;;/	ld		(l2fraction),a				; faction = dy - 1/2 dx
 828+ E705              ;;/.BranchAwhile							; while (l2_vx0 != l2_vx1)
 829+ E705              ;;/	ld		a,c
 830+ E705              ;;/	cp		e
 831+ E705              ;;/	ret		z							; if x0 = x1 then done
 832+ E705              ;;/.BranchAtestfraction:					; if (l2_fraction >= 0)
 833+ E705              ;;/	ld		a,(l2fraction)
 834+ E705              ;;/	TEST	$80
 835+ E705              ;;/	jr		nz,.BranchAskipYstep
 836+ E705              ;;/	inc		b							; 		++l2_vy0;
 837+ E705              ;;/	ld		hl,l2deltaXsq
 838+ E705              ;;/	sub		(hl)						; 		l2_fraction -= l2_dx;
 839+ E705              ;;/	ld		(l2fraction),a
 840+ E705              ;;/.BranchAskipYstep:
 841+ E705              ;;/.l2stepx1:
 842+ E705              ;;/	inc		b							; this is self modifying code point 1 l2_vx0 += l2_stepx
 843+ E705              ;;/	ld		a,(l2fraction)				; l2_fraction += l2_dy can optimise later as a already has this?
 844+ E705              ;;/	ld		hl,l2deltaYsq
 845+ E705              ;;/	add		a,(hl)
 846+ E705              ;;/	ld		(l2fraction),a
 847+ E705              ;;/.BranchAplotBCColA:						; l2_plot_pixel(l2_vx0,l2_vy0,color);
 848+ E705              ;;/	pushbcde
 849+ E705              ;;/	ld a,(l2linecolor)
 850+ E705              ;;/	call	l2_plot_pixel
 851+ E705              ;;/	popdebc
 852+ E705              ;;/.BranchAloop:
 853+ E705              ;;/	jr		.BranchAwhile
 854+ E705              ;;/.dxLTEdybranch:
 855+ E705              ;;/	ld		a,(l2deltaXsq)				; l2_fraction = l2_dx - (l2_dy >> 1);
 856+ E705              ;;/	ld		hl, l2deltaY
 857+ E705              ;;/	sub		(hl)
 858+ E705              ;;/	ld		(l2fraction),a				; faction = dy - 1/2 d
 859+ E705              ;;/.BranchBwhile:							; while (l2_vy0 != l2_vy1)
 860+ E705              ;;/	ld		a,b
 861+ E705              ;;/	cp		d
 862+ E705              ;;/	ret		z							; if x0 = x1 then done
 863+ E705              ;;/.BranchBtestfraction:					; if (l2_fraction >= 0)
 864+ E705              ;;/	ld		a,(l2fraction)
 865+ E705              ;;/	TEST	$80
 866+ E705              ;;/	jr		nz,.BranchBskipYstep
 867+ E705              ;;/.l2stepx2
 868+ E705              ;;/	inc		b							; l2_vx0 += l2_stepx; this is self modifying code point 2
 869+ E705              ;;/	ld		a,(l2fraction)				; l2_fraction -= l2_dy
 870+ E705              ;;/	ld		hl,l2deltaYsq
 871+ E705              ;;/	sub		(hl)
 872+ E705              ;;/	ld		(l2fraction),a
 873+ E705              ;;/.BranchBskipYstep:
 874+ E705              ;;/	ld		hl, l2deltaYsq
 875+ E705              ;;/	add		a,(hl)
 876+ E705              ;;/	ld		(l2fraction),a
 877+ E705              ;;/	inc		b							; ++l2_vy0;
 878+ E705              ;;/.BranchBplotBCColA:
 879+ E705              ;;/	pushbcde
 880+ E705              ;;/	ld a,(l2linecolor)
 881+ E705              ;;/	call	l2_plot_pixel
 882+ E705              ;;/	popdebc
 883+ E705              ;;/.BranchBloop:
 884+ E705              ;;/	jr		.BranchBwhile
 885+ E705
# file closed: ../Layer2Graphics/layer2_plot_diagonal.asm
 155  E705                  INCLUDE "../Layer2Graphics/asm_l2_plot_triangle.asm"
# file opened: ../Layer2Graphics/asm_l2_plot_triangle.asm
   1+ E705
   2+ E705
   3+ E705
   4+ E705 00 00        l2trianglebc	        DW 0
   5+ E707 00 00        l2trianglede	        DW 0
   6+ E709 00 00        l2trianglehl	        DW 0
   7+ E70B
   8+ E70B              ; "l2_draw_triangle, BC = y1x1, DE=y2x2, HL=y3x3 a = Color"
   9+ E70B C5 D5 E5 F5  l2_draw_triangle:       push	bc,,de,,hl,,af
  10+ E70F CD 33 E6                             call	l2_draw_diagonal		; BC to DE
  11+ E712 F1                                   pop		af
  12+ E713 D1                                   pop		de						; swap DE and HL
  13+ E714 E1                                   pop		hl						; so BC to DE is really to HL
  14+ E715 C1                                   pop		bc
  15+ E716 D5 E5                                push    de,,hl                    ; which is pushing original hl then original de
  16+ E718 F5                                   push	af
  17+ E719 CD 33 E6                             call	l2_draw_diagonal		; BC to HL (leaving DE and HL swapped)
  18+ E71C F1                                   pop		af
  19+ E71D C1                                   pop		bc						; Now bc = original de
  20+ E71E D1                                   pop		de						; de = original hl
  21+ E71F CD 33 E6                             call	l2_draw_diagonal		; BC to HL (leaving DE and HL swapped)
  22+ E722 C9                                   ret
  23+ E723
  24+ E723
  25+ E723
  26+ E723
  27+ E723
# file closed: ../Layer2Graphics/asm_l2_plot_triangle.asm
 156  E723                  INCLUDE "../Layer2Graphics/asm_l2_fill_triangle.asm"
# file opened: ../Layer2Graphics/asm_l2_fill_triangle.asm
   1+ E723              ; ">l2_fillBottomFlatTriangle BC y0x0 DE x1x2, H YCommon, L Colour"
   2+ E723              ; "note >l2_draw_diagonal_save, bc = y0,x0 de=y1,x1,a=array nbr ESOURCE LL30 or LION"
   3+ E723              ; "note line to   bc = left side row,col, d right pixel, e = color"
   4+ E723 DD 01        l2_fillBottomFlatTriangle:break
   5+ E725 7D                                   ld		a,l
   6+ E726 32 4C E3                             ld		(l2linecolor),a
   7+ E729 79                                   ld		a,c
   8+ E72A BB                                   cp		e
   9+ E72B 30 08                                jr		nc, .x2gtex1
  10+ E72D DD 26 01     .x1ltx2:                ld		ixh,1                           ; list 1 holds x0 down to x1
  11+ E730 DD 2E 02                             ld		ixl,2                           ; list 2 hols  x0 down to x2
  12+ E733 18 06                                jr		.storepoints
  13+ E735 DD 26 02     .x2gtex1:               ld		ixh,2
  14+ E738 DD 2E 01                             ld		ixl,1
  15+ E73B C5 D5 E5     .storepoints:           push	bc,,de,,hl
  16+ E73E DD 7C                                ld		a,ixh
  17+ E740 5A                                   ld		e,d                             ; we alreay have bc so its now bc -> hd
  18+ E741 54                                   ld		d,h
  19+ E742 CD 54 E5                             call	l2_draw_diagonal_save			;l2_store_diagonal(x0,y0,x1,ycommon,l2_LineMinX);
  20+ E745 E1 D1 C1                             pop		bc,,de,,hl
  21+ E748 C5 E5                                push	bc,,hl
  22+ E74A 54                                   ld		d,h                             ; now its bc -> he
  23+ E74B DD 7D                                ld		a,ixl
  24+ E74D CD 54 E5                             call	l2_draw_diagonal_save			;l2_store_diagonal(x0,y0,x2,ycommon,l2_LineMaxX);
  25+ E750 E1 C1                                pop		bc,,hl
  26+ E752 50           .SaveForLoop:           ld		d,b
  27+ E753 5C                                   ld		e,h								; save loop counters
  28+ E754 D5                                   push	de								; de = y0ycommon
  29+ E755 21 54 E3     .GetFirstHorizontalRow:	ld		hl,l2targetArray1               ; get first row for loop
  30+ E758 78                                   ld		a,b
  31+ E759 ED 31                                add		hl,a							; hl = l2targetArray1 row b
  32+ E75B 7E                                   ld		a,(hl)							;
  33+ E75C 4F                                   ld		c,a								; c = col1 i.e. l2targetarray1[b]
  34+ E75D 21 54 E4                             ld      hl,l2targetArray2
  35+ E760 78                                   ld      a,b
  36+ E761 ED 31                                add     hl,a
  37+ E763              ;                        inc		h								; hl = l2targetArray2 row b if we interleave
  38+ E763 7E                                   ld		a,(hl)
  39+ E764 57                                   ld		d,a								; d = col2 i.e. l2targetarray2[b]
  40+ E765 3A 4C E3     .SetColour:             ld		a,(l2linecolor)
  41+ E768 5F                                   ld		e,a								; de = to colour
  42+ E769 C5           .SavePoints:            push	bc								; bc = rowcol
  43+ E76A 25                                   dec		h
  44+ E76B E5                                   push	hl								; hl = l2targetArray1[b]
  45+ E76C CD B6 E2     .DoLine:	            call	l2_draw_horz_line_to
  46+ E76F E1                                   pop		hl
  47+ E770 C1                                   pop		bc
  48+ E771 04                                   inc		b								; down a rowc
  49+ E772 D1                                   pop		de								; de = from to (and b also = current)
  50+ E773 14                                   inc		d
  51+ E774 7B                                   ld		a,e								; while e >= d
  52+ E775 BA                                   cp		d
  53+ E776 30 DA                                jr 		nc,.SaveForLoop					; Is this the right point??
  54+ E778 C9                                   ret
  55+ E779
# file closed: ../Layer2Graphics/asm_l2_fill_triangle.asm
 157  E779                  INCLUDE "../Layer2Graphics/layer2_plot_circle.asm"
# file opened: ../Layer2Graphics/layer2_plot_circle.asm
   1+ E779
   2+ E779 00 00        l2_circle_pos		DW 0
   3+ E77B 00           l2_circle_colour	DB 0
   4+ E77C 00           l2_circle_radius	DB 0
   5+ E77D 00           l2_circle_x			DB 0
   6+ E77E 00           l2_circle_y			DB 0
   7+ E77F 00           l2_circle_d			DB 0
   8+ E780
   9+ E780              ; ">l2_draw_circle BC = center row col, d = radius, e = colour"
  10+ E780 7B           l2_draw_circle:     ld		a,e
  11+ E781 32 27 E8                         ld		(.PlotPixel+1),a
  12+ E784 7A                               ld		a,d								; get radius
  13+ E785 A7                               and		a
  14+ E786 C8                               ret		z
  15+ E787 FE 01                            cp		1
  16+ E789 CA 32 E8                         jp		z,CircleSinglepixel
  17+ E78C ED 43 B6 E7                      ld		(.Plot1+1),bc					; save origin into DE reg in code
  18+ E790 DD 67                            ld		ixh,a							; ixh = raidus
  19+ E792 DD 2E 00                         ld		ixl,0
  20+ E795 26 00        .calcd:	            ld		h,0
  21+ E797 6F                               ld		l,a
  22+ E798 29                               add		hl,hl							; hl = r * 2
  23+ E799 EB                               ex		de,hl							; de = r * 2
  24+ E79A 21 03 00                         ld		hl,3
  25+ E79D A7                               and		a
  26+ E79E ED 52                            sbc		hl,de							; hl = 3 - (r * 2)
  27+ E7A0 44                               ld		b,h
  28+ E7A1 4D                               ld		c,l								; bc = 3 - (r * 2)
  29+ E7A2 21 01 00     .calcdelta:         ld		hl,1
  30+ E7A5 16 00                            ld		d,0
  31+ E7A7 DD 5D                            ld		e,ixl
  32+ E7A9 A7                               and		a
  33+ E7AA ED 52                            sbc		hl,de
  34+ E7AC 11 01 00     .Setde1:            ld		de,1
  35+ E7AF DD 7C        .CircleLoop:        ld		a,ixh
  36+ E7B1 DD BD                            cp		ixl
  37+ E7B3 D8                               ret		c
  38+ E7B4 D9           .ProcessLoop:	    exx
  39+ E7B5 11 00 00     .Plot1:             ld		de,0
  40+ E7B8 7B                               ld		a,e
  41+ E7B9 DD 85                            add		a,ixl
  42+ E7BB 4F                               ld		c,a
  43+ E7BC 7A                               ld		a,d
  44+ E7BD DD 84                            add		a,ixh
  45+ E7BF 47                               ld		b,a
  46+ E7C0 CD 26 E8                         call	.PlotPixel			;CX+X,CY+Y
  47+ E7C3 7B           .Plot2:             ld 		a,e
  48+ E7C4 DD 95                            sub 	ixl
  49+ E7C6 4F                               ld 		c,a
  50+ E7C7 7A                               ld 		a,d
  51+ E7C8 DD 84                            add 	a,ixh
  52+ E7CA 47                               ld		b,a
  53+ E7CB CD 26 E8                         call	.PlotPixel			;CX-X,CY+Y
  54+ E7CE 7B           .Plot3:             ld 		a,e
  55+ E7CF DD 85                            add		a,ixl
  56+ E7D1 4F                               ld 		c,a
  57+ E7D2 7A                               ld 		a,d
  58+ E7D3 DD 94                            sub 	ixh
  59+ E7D5 47                               ld 		b,a
  60+ E7D6 CD 26 E8                         call	.PlotPixel			;CX+X,CY-Y
  61+ E7D9 7B           .Plot4:             ld 		a,e
  62+ E7DA DD 95                            sub 	ixl
  63+ E7DC 4F                               ld 		c,a
  64+ E7DD 7A                               ld 		a,d
  65+ E7DE DD 94                            sub 	ixh
  66+ E7E0 47                               ld 		b,a
  67+ E7E1 CD 26 E8                         call	.PlotPixel			;CY+X,CX-Y
  68+ E7E4 7A           .Plot5:	            ld 		a,d
  69+ E7E5 DD 85                            add 	a,ixl
  70+ E7E7 47                               ld 		b,a
  71+ E7E8 7B                               ld 		a,e
  72+ E7E9 DD 84                            add 	a,ixh
  73+ E7EB 4F                               ld 		c,a
  74+ E7EC CD 26 E8                         call	.PlotPixel			;CY+X,CX+Y
  75+ E7EF 7A           .Plot6:	            ld 		a,d
  76+ E7F0 DD 95                            sub 	ixl
  77+ E7F2 47                               ld 		b,a
  78+ E7F3 7B                               ld 		a,e
  79+ E7F4 DD 84                            add 	a,ixh
  80+ E7F6 4F                               ld 		c,a
  81+ E7F7 CD 26 E8                         call	.PlotPixel			;CY-X,CX+Y
  82+ E7FA 7A           .Plot7:	            ld 		a,d
  83+ E7FB DD 85                            add 	a,ixl
  84+ E7FD 47                               ld 		b,a
  85+ E7FE 7B                               ld 		a,e
  86+ E7FF DD 94                            sub 	ixh
  87+ E801 4F                               ld 		c,a
  88+ E802 CD 26 E8                         call	.PlotPixel			;CY+X,CX-Y
  89+ E805 7A           .Plot8:	            ld 		a,d
  90+ E806 DD 95                            sub 	ixl
  91+ E808 47                               ld		b,a
  92+ E809 7B                               ld 		a,e
  93+ E80A DD 94                            sub 	ixh
  94+ E80C 4F                               ld 		c,a
  95+ E80D CD 26 E8                         call	.PlotPixel			;CX+X,CY-Y
  96+ E810 D9                               exx
  97+ E811 CB 7C        .IncrementCircle:	bit     7,h				; Check for Hl<=0
  98+ E813 28 03                            jr z,   .draw_circle_1
  99+ E815 19                               add hl,de			; Delta=Delta+D1
 100+ E816 18 05                            jr      .draw_circle_2		;
 101+ E818 09           .draw_circle_1:		add     hl,bc			; Delta=Delta+D2
 102+ E819 03                               inc     bc
 103+ E81A 03                               inc     bc				; D2=D2+2
 104+ E81B DD 25                            dec     ixh				; Y=Y-1
 105+ E81D 03           .draw_circle_2:		inc bc				; D2=D2+2
 106+ E81E 03                               inc bc
 107+ E81F 13                               inc de				; D1=D1+2
 108+ E820 13                               inc de
 109+ E821 DD 2C                            inc ixl				; X=X+1
 110+ E823 C3 AF E7                         jp      .CircleLoop
 111+ E826 3E 00        .PlotPixel:         ld		a,0                  ; This was originally indirect, where as it neeed to be value
 112+ E828 D5 C5 E5                         push	de,,bc,,hl
 113+ E82B CD 43 E1                         call 	l2_plot_pixel_y_test
 114+ E82E E1 C1 D1                         pop		de,,bc,,hl
 115+ E831 C9                               ret
 116+ E832 7B           CircleSinglepixel:  ld		a,e
 117+ E833 CD 43 E1                         call	l2_plot_pixel_y_test
 118+ E836 C9                               ret
 119+ E837
# file closed: ../Layer2Graphics/layer2_plot_circle.asm
 158  E837                  INCLUDE "../Layer2Graphics/layer2_plot_circle_fill.asm"
# file opened: ../Layer2Graphics/layer2_plot_circle_fill.asm
   1+ E837
   2+ E837 00           l2_circle_dblx		DB 0
   3+ E838 00           l2_circle_dbly		DB 0
   4+ E839
   5+ E839              ; ">l2_draw_circle_fill BC = center row col, d = radius, e = colour"
   6+ E839              ; Note this code currently does not process BC
   7+ E839 7B           l2_draw_circle_fill:    ld		a,e
   8+ E83A 32 D0 E8                             ld		(.LineColour+1),a
   9+ E83D 7A                                   ld		a,d								; get radius
  10+ E83E A7                                   and		a
  11+ E83F C8                                   ret		z
  12+ E840 FE 01                                cp		1
  13+ E842 CA 32 E8                             jp		z,CircleSinglepixel
  14+ E845 ED 43 6F E8                          ld		(.Line1+1),bc					; save origin into DE reg in code
  15+ E849 DD 67                                ld		ixh,a							; ixh = raidus (x)
  16+ E84B DD 2E 00                             ld		ixl,0							; ihy = y
  17+ E84E 26 00        .calcd:	                ld		h,0
  18+ E850 6F                                   ld		l,a
  19+ E851 29                                   add		hl,hl							; hl = r * 2
  20+ E852 EB                                   ex		de,hl							; de = r * 2
  21+ E853 21 03 00                             ld		hl,3
  22+ E856 A7                                   and		a
  23+ E857 ED 52                                sbc		hl,de							; hl = 3 - (r * 2)
  24+ E859 44                                   ld		b,h
  25+ E85A 4D                                   ld		c,l								; bc = 3 - (r * 2)
  26+ E85B 21 01 00     .calcdelta              ld		hl,1
  27+ E85E 16 00                                ld		d,0
  28+ E860 DD 5D                                ld		e,ixl
  29+ E862 A7                                   and		a
  30+ E863 ED 52                                sbc		hl,de
  31+ E865 11 01 00     .Setde1	                ld		de,1
  32+ E868 DD 7C        .CircleLoop:            ld		a,ixh
  33+ E86A DD BD                                cp		ixl
  34+ E86C D8                                   ret		c
  35+ E86D D9           .ProcessLoop:	        exx
  36+ E86E 11 00 00     .Line1:                 ld		de,0
  37+ E871 7B                                   ld 		a,e
  38+ E872 DD 95                                sub 	ixl
  39+ E874 4F                                   ld 		c,a
  40+ E875 7A                                   ld 		a,d
  41+ E876 DD 84                                add 	a,ixh
  42+ E878 47                                   ld		b,a
  43+ E879                                      ;; TODO ADD DOUBLE X CALC
  44+ E879 D5                                   push	de
  45+ E87A DD 55                                ld		d,ixl
  46+ E87C CB 22                                sla		d
  47+ E87E CD CB E8                             call	.PlotLine			;CX-X,CY+Y
  48+ E881 D1                                   pop		de
  49+ E882 7B           .Line2:                 ld 		a,e
  50+ E883 DD 95                                sub		ixl
  51+ E885 4F                                   ld 		c,a
  52+ E886 7A                                   ld 		a,d
  53+ E887 DD 94                                sub 	ixh
  54+ E889 47                                   ld 		b,a
  55+ E88A                                      ;; TODO ADD DOUBLE X CALC
  56+ E88A D5                                   push	de
  57+ E88B DD 55                                ld		d,ixl
  58+ E88D CB 22                                sla		d
  59+ E88F CD CB E8                             call	.PlotLine			;CX-X,CY-Y
  60+ E892 D1                                   pop		de
  61+ E893 7B           .Line3:	                ld 		a,e
  62+ E894 DD 94                                sub		ixh
  63+ E896 4F                                   ld 		c,a
  64+ E897 7A                                   ld 		a,d
  65+ E898 DD 85                                add 	a,ixl
  66+ E89A 47                                   ld 		b,a
  67+ E89B                                      ;; TODO ADD DOUBLE Y CALC
  68+ E89B D5                                   push	de
  69+ E89C DD 54                                ld		d,ixh
  70+ E89E CB 22                                sla		d
  71+ E8A0 CD CB E8                             call	.PlotLine			;CX-Y,CY+x
  72+ E8A3 D1                                   pop		de
  73+ E8A4 7B           .Line4:	                ld 		a,e
  74+ E8A5 DD 94                                sub		ixh
  75+ E8A7 4F                                   ld 		c,a
  76+ E8A8 7A                                   ld 		a,d
  77+ E8A9 DD 95                                sub 	ixl
  78+ E8AB 47                                   ld 		b,a
  79+ E8AC                                      ;; TODO ADD DOUBLE Y CALC
  80+ E8AC D5                                   push	de
  81+ E8AD DD 54                                ld		d,ixh
  82+ E8AF CB 22                                sla		d
  83+ E8B1 CD CB E8                             call	.PlotLine			;CX-Y,CY+x
  84+ E8B4 D1                                   pop		de
  85+ E8B5 D9                                   exx
  86+ E8B6 CB 7C        .IncrementCircle:	    bit 7,h				; Check for Hl<=0
  87+ E8B8 28 03                                jr z,.draw_circle_1
  88+ E8BA 19                                   add hl,de			; Delta=Delta+D1
  89+ E8BB 18 05                                jr .draw_circle_2		;
  90+ E8BD 09           .draw_circle_1:		    add hl,bc			; Delta=Delta+D2
  91+ E8BE 03                                   inc bc
  92+ E8BF 03                                   inc bc				; D2=D2+2
  93+ E8C0 DD 25                                dec ixh				; Y=Y-1
  94+ E8C2 03           .draw_circle_2:		    inc bc				; D2=D2+2
  95+ E8C3 03                                   inc bc
  96+ E8C4 13                                   inc de				; D1=D1+2
  97+ E8C5 13                                   inc de
  98+ E8C6 DD 2C                                inc ixl				; X=X+1
  99+ E8C8 C3 68 E8                             jp .CircleLoop
 100+ E8CB D5 C5 E5 F5  .PlotLine:              push	de,,bc,,hl,,af
 101+ E8CF 3E 00        .LineColour:	        ld		a,0         ; circle colur
 102+ E8D1 5F                                   ld      e,a
 103+ E8D2 CD 8A E2                             call 	l2_draw_horz_line
 104+ E8D5 F1 E1 C1 D1                          pop     de,,bc,,hl,,af
 105+ E8D9 C9                                   ret
 106+ E8DA
# file closed: ../Layer2Graphics/layer2_plot_circle_fill.asm
 159  E8DA                  INCLUDE "../Layer2Graphics/l2_draw_any_line.asm"
# file opened: ../Layer2Graphics/l2_draw_any_line.asm
   1+ E8DA              ; ">l2_draw_any_line, bc = y0,x0 de=y1,x1,a=color: determines if its horizontal, vertical or diagonal then hands off the work"
   2+ E8DA 08           l2_draw_any_line:       ex		af,af'              ; save colour into a'
   3+ E8DB 79                                   ld		a,c                 ; if x and e are the same its horizontal
   4+ E8DC BB                                   cp		e
   5+ E8DD 28 08                                jr		z,.HorizontalLineCheck
   6+ E8DF 78                                   ld		a,b                 ; if b and d are the same its vertica;
   7+ E8E0 BA                                   cp		d
   8+ E8E1 28 0E                                jr		z,.VerticalLine
   9+ E8E3              ; use jp and get a free ret instruction optimisation
  10+ E8E3 08           .DiagonalLine:		    ex		af,af'			     ; get colour back into a
  11+ E8E4 C3 33 E6                             jp		l2_draw_diagonal
  12+ E8E7
  13+ E8E7 78           .HorizontalLineCheck:   ld      a,b
  14+ E8E8 BA                                   cp      d
  15+ E8E9 28 0B                                jr      z, .SinglePixel
  16+ E8EB 08           .HorizontalLine:        ex		af,af'              ; get colour back into a
  17+ E8EC 53                                   ld		d,e				    ; set d as target right pixel
  18+ E8ED 5F                                   ld		e,a				    ; e holds colour on this call
  19+ E8EE C3 B6 E2                             jp		l2_draw_horz_line_to
  20+ E8F1 08           .VerticalLine:          ex		af,af'
  21+ E8F2 5F                                   ld		e,a				    ; e holds colour on this call
  22+ E8F3 C3 35 E3                             jp		l2_draw_vert_line_to
  23+ E8F6 08           .SinglePixel:           ex		af,af'              ; get colour back into a
  24+ E8F7 C3 29 E1                             jp      l2_plot_pixel
  25+ E8FA              ;......................................................
  26+ E8FA
# file closed: ../Layer2Graphics/l2_draw_any_line.asm
 160  E8FA                  INCLUDE "../Layer2Graphics/clearLines-LL155.asm"
# file opened: ../Layer2Graphics/clearLines-LL155.asm
   1+ E8FA              ; ClearLines (LL155)
   2+ E8FA              ;   y = 0
   3+ E8FA              ; 	XX20 = UbnkEdgeHeapSize
   4+ E8FA              ;   exit if XX20 < 4
   5+ E8FA              ;   ++y
   6+ E8FA              ;   do
   7+ E8FA              ;		X1 = XX19(Y) ;	Y1 = XX19(++Y) ;	X2 = XX19(++Y);	Y2 = XX19(++Y)
   8+ E8FA              ;   	call DrawLine (x1,y1 to x2,y2) two's compliment (we will do 0)
   9+ E8FA              ;		++y
  10+ E8FA              ;	until Y > XX20
  11+ E8FA
  12+ E8FA              clearLines:
  13+ E8FA              layer2_clearLines:
clearLines-LL155.asm(14): error: Label not found: UbnkLineArrayLen
clearLines-LL155.asm(14): warning[rdlow]: Reading memory at low address: 0
  14+ E8FA 3A 00 00     LL155cl:                ld		a,(UbnkLineArrayLen)
  15+ E8FD 47                                   ld		b,a
clearLines-LL155.asm(16): error: Label not found: UbnkLineArray
  16+ E8FE 21 00 00                             ld		hl,UbnkLineArray
  17+ E901 C5           clearLinesLoop:         push	bc
  18+ E902 7E                                   ld		a,(hl)
  19+ E903 23                                   inc		hl
  20+ E904 4F                                   ld		c,a
  21+ E905 7E                                   ld		a,(hl)
  22+ E906 23                                   inc		hl
  23+ E907 47                                   ld		b,a
  24+ E908 7E                                   ld		a,(hl)
  25+ E909 23                                   inc		hl
  26+ E90A 5F                                   ld		e,a
  27+ E90B 7E                                   ld		a,(hl)
  28+ E90C 23                                   inc		hl
  29+ E90D 57                                   ld		d,a
  30+ E90E 3E E3                                ld		a,COLOUR_TRANSPARENT		; we erase here
  31+ E910 E5                                   push	hl
  32+ E911 CD DA E8                             call    l2_draw_any_line
  33+ E914 E1                                   pop		hl
  34+ E915 C1                                   pop		bc
  35+ E916 10 E9                                djnz	clearLinesLoop
  36+ E918 C9                                   ret
  37+ E919
# file closed: ../Layer2Graphics/clearLines-LL155.asm
 161  E919                  INCLUDE "../Layer2Graphics/l2_draw_line_v2.asm"
# file opened: ../Layer2Graphics/l2_draw_line_v2.asm
   1+ E919              ; ******************************************************************************
   2+ E919              ;
   3+ E919              ;	Draw a pixel line from (x0,y0) defined in (COORDS) - the current plot
   4+ E919              ;	coordinate, to the relative distance points (x0+x,y0+y).
   5+ E919              ;
   6+ E919              ;	Design & programming by Gunther Strube,	Copyright (C) InterLogic 1995
   7+ E919              ;
   8+ E919              ;	The (COORDS+0)	pointer contains the current y coordinate, (COORDS+1) the
   9+ E919              ;	current x coordinate. The main program should reset the (COORDS) variables
  10+ E919              ;	before using line drawing.
  11+ E919              ;
  12+ E919              ;	The routine checks the range of specified coordinates which is the
  13+ E919              ;	boundaries of the graphics area (256x64	pixels).
  14+ E919              ;	If a boundary error occurs the routine exits automatically.	This may be
  15+ E919              ;	useful if you are trying to draw a line longer than allowed. Only the
  16+ E919              ;	visible part will be drawn.
  17+ E919              ;
  18+ E919              ;	The hardware graphics memory is organized as (0,0) in the top left corner.
  19+ E919              ;
  20+ E919              ;	The plot routine is	defined by an address pointer	in IX.
  21+ E919              ;
  22+ E919              ;	IN:	HL =	move	relative x horisontal points (maximum +/- 255).
  23+ E919              ;		DE =	move	relative y vertical	points (maximum +/-	255).
  24+ E919              ;		IX =	pointer to plot routine that uses HL = (x,y)	of plot coordinate.
  25+ E919              ;
  26+ E919              ;	OUT:	None.
  27+ E919              ;
  28+ E919              ;	Registers	used	by routine:
  29+ E919              ;		   N	:	B, loop counter
  30+ E919              ;		   i	:	line	balance variable
  31+ E919              ;		   x	:	H/L,	horisontal, vertical distance	variables
  32+ E919              ;		   y	:	H/L,	horisontal, vertical distance	variables
  33+ E919              ;	  (x0,y0)	:	(h,l)
  34+ E919              ;	  direc_x	:	d, horisontal step increment
  35+ E919              ;	  direc_y	:	e, vertical step increment
  36+ E919              ;		 ddx	:	b, horisontal step increment
  37+ E919              ;		 ddy	:	c, vertical step increment
  38+ E919              ;
  39+ E919              ;		DE, A work registers.
  40+ E919              ;
  41+ E919              ; The algorithm in pseudo-code:
  42+ E919              ;
  43+ E919              ;	direc_x =	SGN x: direc_y	= SGN y
  44+ E919              ;	x = ABS x: y =	ABS y
  45+ E919              ;
  46+ E919              ;	if x	>= y
  47+ E919              ;		if x+y=0 then return
  48+ E919              ;		H = x
  49+ E919              ;		L = y
  50+ E919              ;		ddx = direc_x
  51+ E919              ;		ddy = 0
  52+ E919              ;	else
  53+ E919              ;		H = y
  54+ E919              ;		L = x
  55+ E919              ;		ddx = 0
  56+ E919              ;		ddy = direc_y
  57+ E919              ;	endif
  58+ E919              ;
  59+ E919              ;	B = H
  60+ E919              ;	i = INT(B/2)
  61+ E919              ;	FOR N=B TO 1 STEP -1
  62+ E919              ;		i = i + L
  63+ E919              ;		if i	< H
  64+ E919              ;			ix =	ddx
  65+ E919              ;			iy =	ddy
  66+ E919              ;		else
  67+ E919              ;			i = i - H
  68+ E919              ;			ix =	direc_x
  69+ E919              ;			iy =	direc_y
  70+ E919              ;		endif
  71+ E919              ;		x0 =	x0 +	ix
  72+ E919              ;		y0 =	y0 +	iy
  73+ E919              ;		plot	(x0,y0)
  74+ E919              ;	NEXT	N
  75+ E919              ;
  76+ E919              ;
  77+ E919              ;	Registers	changed after return:
  78+ E919              ;		..BCDEHL/IXIY/af......	same
  79+ E919              ;		AF....../..../..bcdehl	different
  80+ E919              ;
  81+ E919 DF           line_gfx_colour db $DF
  82+ E91A 00 00        line_gfx_coords	dw 0
  83+ E91C              LineHLtoDE:
  84+ E91C 7C           TestMaxY:               ld	a,h ; were h = y or l = y?
  85+ E91D FE C0                                cp	192
  86+ E91F 30 26                                jr	nc, exit_line		; y0	coordinate out	of range
  87+ E921 7A                                   ld	a,d
  88+ E922 FE C0                                cp	192
  89+ E924 30 21                                jr	nc, exit_line		; y1	coordinate out	of range
  90+ E926 22 1A E9                             ld	(line_gfx_coords),hl		; the starting	point is now default
  91+ E929 E5                                   push	hl
  92+ E92A D5                                   push	de
  93+ E92B 6C                                   ld	l,h				; L = x0
  94+ E92C 62                                   ld	h,d				; H = x1
  95+ E92D 7C           distanceX:		        ld	a,h
  96+ E92E 95                                   sub	l
  97+ E92F 6F                                   ld	l,a
  98+ E930 26 00                                ld	h,0
  99+ E932 30 02                                jr	nc, distanceXDone
 100+ E934 26 FF                                ld	h,-1
 101+ E936 D1           distanceXDone:          pop	de
 102+ E937 E3                                   ex	(sp),hl			; L = y0
 103+ E938 63                                   ld	h,e				; H = y1
 104+ E939 7C           distanceY:		        ld	a,h
 105+ E93A 95                                   sub	l
 106+ E93B 6F                                   ld	l,a
 107+ E93C 26 00                                ld	h,0
 108+ E93E 30 02                                jr	nc, distanceYDone
 109+ E940 26 FF                                ld	h,-1
 110+ E942 D1           distanceYDone:          pop	de
 111+ E943 EB                                   ex	de,hl			; h.dist.	= HL, v.dist. = DE
 112+ E944 CD 48 E9                             call	DrawLineRelative			; draw line...
 113+ E947 C9           exit_line:              ret
 114+ E948
 115+ E948              ; ***************************************************************************
 116+ E948              ;
 117+ E948              ;	IN:	HL =	move	relative x horisontal points (maximum +/- 255).
 118+ E948              ;		DE =	move	relative y vertical	points (maximum +/-	255).
 119+ E948              ;
 120+ E948              ; OUT: h - l distance in	HL
 121+ E948              ;
 122+ E948
 123+ E948 D5           DrawLineRelative:       push	de
 124+ E949 E5                                   push	hl
 125+ E94A D9                                   exx
 126+ E94B E1                                   pop	hl					; get relative	horisontal movement
 127+ E94C CD B7 E9                             call	sgn
 128+ E94F 57                                   ld	d,a					; direc_x	= SGN(x) installed d = +/-1 for horizontal update
 129+ E950 CD C4 E9                             call	absValue
 130+ E953 45                                   ld	b,l					; x = ABS(x)
 131+ E954 E1           DrawLineGetVertRelative:pop	hl					; get relative	vertical movement
 132+ E955 CD B7 E9                             call	sgn
 133+ E958 5F                                   ld	e,a					; direc_y	= SGN(y) installed  = +/-1 for vertical update
 134+ E959 CD C4 E9                             call	absValue
 135+ E95C 4D                                   ld	c,l					; y = ABS(y) so now bc = dxdy
 136+ E95D              ; so by here BC = dx dy HL in increment/decrement x y
 137+ E95D C5                                   push	bc
 138+ E95E D9                                   exx
 139+ E95F E1                                   pop	hl					; H = absolute	x dist., L = absolute y distance
 140+ E960 7C                                   ld	a,h
 141+ E961 BD                                   cp	l
 142+ E962 38 0A                                jr	c, x_smaller_y		; if	x >=	y
 143+ E964 B4           areXandYZero:           or	h					;	if x+y = 0
 144+ E965 28 4F                                jr	z, exit_draw		;		return
 145+ E967 D9           y_lessorequal_x:        exx						;	else
 146+ E968 42                                   ld	b,d					;		ddx = direc_x
 147+ E969 0E 00                                ld	c,0					;		ddy = 0
 148+ E96B D9                                   exx
 149+ E96C 18 08                                jr	init_drawloop		; else
 150+ E96E 7C           x_smaller_y:	        ld	a,h
 151+ E96F 65                                   ld	h,l					;	H = y
 152+ E970 6F                                   ld	l,a					;	L = x
 153+ E971 D9                                   exx
 154+ E972 06 00                                ld	b,0					;	ddx = 0
 155+ E974 4B                                   ld	c,e					;	ddy = direc_y
 156+ E975 D9                                   exx
 157+ E976 44           init_drawloop:	        ld	b,h
 158+ E977 4C                                   ld	c,h					; B = H
 159+ E978 CB 39                                srl	c					; i = INT(B/2)
 160+ E97A              										; FOR N=B	TO 1	STEP	-1
 161+ E97A 79           drawloop:		        ld	a,c
 162+ E97B 85                                   add	a,l
 163+ E97C 38 09                                jr	c, i_greater		;	i + L > 255  (i > H)
 164+ E97E BC                                   cp	h
 165+ E97F 30 06                                jr	nc, i_greater		;	if i	< H
 166+ E981 4F                                   ld	c,a					;		i = i + L
 167+ E982 D9                                   exx
 168+ E983 C5                                   push	bc				;		ix =	ddx:	iy =	ddy
 169+ E984 D9                                   exx
 170+ E985 18 05                                jr	check_plot			;	else
 171+ E987 94           i_greater:		        sub	h					;		i = i - H
 172+ E988 4F                                   ld	c,a
 173+ E989 D9                                   exx
 174+ E98A D5                                   push	de				;		ix =	direc_x: iy = direc_y
 175+ E98B D9                                   exx						;	endif
 176+ E98C E3           check_plot:		        ex	(sp),hl				;	preserve H,L distances on stack
 177+ E98D EB                                   ex	de,hl				;	D,E = ix,	iy
 178+ E98E 2A 1A E9                             ld	hl,(line_gfx_coords)
 179+ E991 7D                                   ld	a,l
 180+ E992 83                                   add	a,e					;
 181+ E993 6F                                   ld	l,a					;	y0 =	y0 +	iy (y0 is	checked by plot)
 182+ E994 7A                                   ld	a,d
 183+ E995 3C                                   inc	a
 184+ E996 84                                   add	a,h
 185+ E997 38 04                                jr	c, check_range		;	check out	of range
 186+ E999 28 1A                                jr	z, range_error		;	Fz=1	& Fc=0 denotes	x0 <	0
 187+ E99B 18 02                                jr	plot_point
 188+ E99D 20 16        check_range:            jr	nz, range_error	;	Fz=0	& Fc=1 denotes	x0 >	255
 189+ E99F
 190+ E99F 3D           plot_point:             dec	a
 191+ E9A0 C5                                   push	bc
 192+ E9A1 F5                                   push	af
 193+ E9A2 47                                   ld	    b,a					;	x0 =	x0 +	ix
 194+ E9A3 4D                                   ld		c,l
 195+ E9A4 3A 19 E9                             ld		a,(line_gfx_colour)
 196+ E9A7 ED 43 1A E9                          ld      (line_gfx_coords),bc
 197+ E9AB CD 29 E1                             call	l2_plot_pixel
 197+ E9AE
 198+ E9AE F1                                   pop		af
 199+ E9AF C1                                   pop		bc
 200+ E9B0 E1           plot_RET:		        pop	hl					;	restore H,L distances...
 201+ E9B1 10 C7                                djnz	drawloop		; NEXT N
 202+ E9B3 18 01                                jr	exit_draw
 203+ E9B5
 204+ E9B5 E1           range_error:	        pop	hl					; remove H,L distances...
 205+ E9B6 C9           exit_draw:		        ret
 206+ E9B7
 207+ E9B7
 208+ E9B7              ; ******************************************************************************
 209+ E9B7              ;
 210+ E9B7              ;	SGN (Signum value) of 16	bit signed integer.
 211+ E9B7              ;
 212+ E9B7              ;	IN:		HL =	integer
 213+ E9B7              ;	OUT:		A = result: 0,1,-1 (if zero, positive, negative)
 214+ E9B7              ;
 215+ E9B7              ;	Registers	changed after return:
 216+ E9B7              ;	..BCDEHL/IXIY	same
 217+ E9B7              ;	AF....../....	different
 218+ E9B7              ;
 219+ E9B7 7C           sgn:				    ld	a,h
 220+ E9B8 B5                                   or	l
 221+ E9B9 C8                                   ret	z				; integer	is zero, return 0...
 222+ E9BA CB 7C                                bit	7,h
 223+ E9BC 20 03                                jr	nz, negative_int
 224+ E9BE 3E 01                                ld	a,1
 225+ E9C0 C9                                   ret
 226+ E9C1 3E FF        negative_int:		    ld	a,-1
 227+ E9C3 C9                                   ret
 228+ E9C4
 229+ E9C4
 230+ E9C4              ; ******************************************************************************
 231+ E9C4              ;
 232+ E9C4              ;	ABS (Absolute value) of 16 bit signed integer.
 233+ E9C4              ;
 234+ E9C4              ;	IN:		HL =	integer
 235+ E9C4              ;	OUT:		HL =	converted	integer
 236+ E9C4              ;
 237+ E9C4              ;	Registers	changed after return:
 238+ E9C4              ;	A.BCDE../IXIY	same
 239+ E9C4              ;	.F....HL/....	different
 240+ E9C4              ;
 241+ E9C4 CB 7C        absValue:			    bit	7,h
 242+ E9C6 C8                                   ret	z				; integer	is positive...
 243+ E9C7 D5                                   push	de
 244+ E9C8 EB                                   ex	de,hl
 245+ E9C9 21 00 00                             ld	hl,0
 246+ E9CC BF                                   cp	a				; Fc	= 0,	may not be used...
 247+ E9CD ED 52                                sbc	hl,de			; convert	negative integer
 248+ E9CF D1                                   pop	de
 249+ E9D0 C9                                   ret
 250+ E9D1
# file closed: ../Layer2Graphics/l2_draw_line_v2.asm
 162  E9D1              ; Bank 56  ------------------------------------------------------------------------------------------------------------------------
 163  E9D1                  SLOT    CommanderAddr
 164  E9D1                  PAGE    BankCommander
 165  E9D1                  ORG     CommanderAddr, BankCommander
 166  E000                  INCLUDE "../Commander/commanderData.asm"
# file opened: ../Commander/commanderData.asm
   1+ E000 43 4F 4D 4D  commanderPage           DB  "COMMANDERPAGE 56"
   1+ E004 41 4E 44 45
   1+ E008 52 50 41 47
   1+ E00C 45 20 35 36
   2+ E010 4A 41 4D 45  defaultName		        DB	"JAMESON",0
   2+ E014 53 4F 4E 00
   3+ E018 10 0F 11 00  defaultStock	        DB $10, $0F, $11, $00, $03, $1C,$0E, $00, $00, $0A, $00, $11,$3A, $07, $09, $08, $00
   3+ E01C 03 1C 0E 00
   3+ E020 00 0A 00 11
   3+ E024 3A 07 09 08
   3+ E028 00
   4+ E029 4A 5A 48 02  defaultSeeds	        DB $4a, $5a, $48, $02, $53, $b7
   4+ E02D 53 B7
   5+ E02F 14           defaultHomeX	        DB $14
   6+ E030 AD           defaultHomeY	        DB $AD
   7+ E031 44 65 66 61  defaultSaveName         DB "Default.SAV",0,0,0,0
   7+ E035 75 6C 74 2E
   7+ E039 53 41 56 00
   7+ E03D 00 00 00
   8+ E040
   9+ E040              ; Gun and cabin temps are not saved as can only be saved in dock
  10+ E040              ; Note Can only save whilst docked
  11+ E040 43 4F 4D 4D  SaveCommanderHeader     DB  "COMMANDERSAVE..."
  11+ E044 41 4E 44 45
  11+ E048 52 53 41 56
  11+ E04C 45 2E 2E 2E
  12+ E050 00 00 00...  SaveFilename            DS  15
  13+ E05F 00 00 00...  SaveCommanderName       DS  15
  14+ E06E 00 00 00...  SaveSeeds               DS  06
  15+ E074 00 00 00...  SaveStockAvaliabiliy    DS  17
  16+ E085 00 00 00...  SaveCargo               DS  16
commanderData.asm(17): error: Label not found: EQ_ITEM_COUNT
  17+ E095              SaveEquipmentFitted     DS  EQ_ITEM_COUNT
  18+ E095 00 00 00 00  SaveLaserType           DS  4
  19+ E099 00 00 00 00  SaveLaserDamagedFlag    DS  4
  20+ E09D 00           SavePresentSystemX      DS  1
  21+ E09E 00           SavePresentSystemY      DS  1
  22+ E09F 00           SaveTargetSystemX       DS  1
  23+ E0A0 00           SaveTargetSystemY       DS  1
  24+ E0A1 00 00 00 00  SaveCash                DS  4
  25+ E0A5 00           SaveFuel                DS  1
  26+ E0A6 00           SaveFugitiveInnocentStatus DS 1
  27+ E0A7 00 00        SaveKillTally           DS  2
  28+ E0A9 00           SaveOuterHyperCount     DS  1
  29+ E0AA 00           SaveInnerHyperCount     DS  1
  30+ E0AB 00           SaveForeShield          DS  1
  31+ E0AC 00           SaveAftShield           DS  1
  32+ E0AD 00           SavePlayerEnergy        DS  1
  33+ E0AE 00           SaveCargoBaySize        DS  1
  34+ E0AF 00           SaveFuelScoopStatus     DS  1
  35+ E0B0              SaveSize                equ $ - SaveCommanderHeader
  36+ E0B0
  37+ E0B0              copyCommanderToSave:    ldCopyStringLen CommanderName,      SaveCommanderName, 15
  37+ E0B0 21 0F 87    >                        ld      hl,CommanderName
  37+ E0B3 11 5F E0    >                        ld      de, SaveCommanderName
  37+ E0B6 01 0F 00    >                        ld      bc, 15
  37+ E0B9 ED B0       >                        ldir
  38+ E0BB                                      ldCopyStringLen GalaxySeeds,        SaveSeeds, 6
  38+ E0BB 21 0F 85    >                        ld      hl,GalaxySeeds
  38+ E0BE 11 6E E0    >                        ld      de, SaveSeeds
  38+ E0C1 01 06 00    >                        ld      bc, 6
  38+ E0C4 ED B0       >                        ldir
  39+ E0C6                                      ldCopyStringLen StockAvaliabiliy,   SaveStockAvaliabiliy, 16
  39+ E0C6 21 7A 84    >                        ld      hl,StockAvaliabiliy
  39+ E0C9 11 74 E0    >                        ld      de, SaveStockAvaliabiliy
  39+ E0CC 01 10 00    >                        ld      bc, 16
  39+ E0CF ED B0       >                        ldir
  40+ E0D1                                      ldCopyStringLen CargoTonnes,        SaveCargo, 16
  40+ E0D1 21 EA 88    >                        ld      hl,CargoTonnes
  40+ E0D4 11 85 E0    >                        ld      de, SaveCargo
  40+ E0D7 01 10 00    >                        ld      bc, 16
  40+ E0DA ED B0       >                        ldir
  41+ E0DC                                      ldCopyStringLen EquipmentFitted,    SaveEquipmentFitted, EQ_ITEM_COUNT
  41+ E0DC 21 02 89    >                        ld      hl,EquipmentFitted
  41+ E0DF 11 95 E0    >                        ld      de, SaveEquipmentFitted
ldCopyMacros.asm(31): error: Label not found: EQ_ITEM_COUNT
commanderData.asm(41): ^ emitted from here
  41+ E0E2 01 00 00    >                        ld      bc, EQ_ITEM_COUNT
  41+ E0E5 ED B0       >                        ldir
  42+ E0E7                                      ldCopyStringLen LaserType,          SaveLaserType, 4
  42+ E0E7 21 FA 88    >                        ld      hl,LaserType
  42+ E0EA 11 95 E0    >                        ld      de, SaveLaserType
  42+ E0ED 01 04 00    >                        ld      bc, 4
  42+ E0F0 ED B0       >                        ldir
  43+ E0F2                                      ldCopyStringLen LaserDamagedFlag,   SaveLaserDamagedFlag, 4
  43+ E0F2 21 FE 88    >                        ld      hl,LaserDamagedFlag
  43+ E0F5 11 99 E0    >                        ld      de, SaveLaserDamagedFlag
  43+ E0F8 01 04 00    >                        ld      bc, 4
  43+ E0FB ED B0       >                        ldir
  44+ E0FD                                      ldCopy2Byte     PresentSystemX,     SavePresentSystemX
  44+ E0FD 2A 15 85    >                        ld       hl,(PresentSystemX)
  44+ E100 22 9D E0    >                        ld       (SavePresentSystemX),hl
  45+ E103                                      ldCopy2Byte     TargetSystemX,      SaveTargetSystemX
  45+ E103 2A 17 85    >                        ld       hl,(TargetSystemX)
  45+ E106 22 9F E0    >                        ld       (SaveTargetSystemX),hl
  46+ E109                                      ldCopyStringLen Cash,               SaveCash, 6
  46+ E109 21 E3 88    >                        ld      hl,Cash
  46+ E10C 11 A1 E0    >                        ld      de, SaveCash
  46+ E10F 01 06 00    >                        ld      bc, 6
  46+ E112 ED B0       >                        ldir
  47+ E114                                      ldCopyByte      Fuel,               SaveFuel
  47+ E114 3A E7 88    >                        ld       a,(Fuel)
  47+ E117 32 A5 E0    >                        ld       (SaveFuel),a
  48+ E11A                                      ldCopyByte      FugitiveInnocentStatus,  SaveFugitiveInnocentStatus
  48+ E11A 3A 79 84    >                        ld       a,(FugitiveInnocentStatus)
  48+ E11D 32 A6 E0    >                        ld       (SaveFugitiveInnocentStatus),a
  49+ E120                                      ldCopy2Byte     KillTally           ,SaveKillTally
  49+ E120 2A 8C 84    >                        ld       hl,(KillTally)
  49+ E123 22 A7 E0    >                        ld       (SaveKillTally),hl
  50+ E126                                      ldCopyByte      OuterHyperCount     ,SaveOuterHyperCount
  50+ E126 3A D4 84    >                        ld       a,(OuterHyperCount)
  50+ E129 32 A9 E0    >                        ld       (SaveOuterHyperCount),a
  51+ E12C                                      ldCopyByte      InnerHyperCount     ,SaveInnerHyperCount
  51+ E12C 3A D3 84    >                        ld       a,(InnerHyperCount)
  51+ E12F 32 AA E0    >                        ld       (SaveInnerHyperCount),a
  52+ E132                                      ldCopyByte      ForeShield          ,SaveForeShield
  52+ E132 3A 08 87    >                        ld       a,(ForeShield)
  52+ E135 32 AB E0    >                        ld       (SaveForeShield),a
  53+ E138                                      ldCopyByte      AftShield           ,SaveAftShield
  53+ E138 3A 09 87    >                        ld       a,(AftShield)
  53+ E13B 32 AC E0    >                        ld       (SaveAftShield),a
  54+ E13E                                      ldCopyByte      PlayerEnergy        ,SavePlayerEnergy
  54+ E13E 3A 0A 87    >                        ld       a,(PlayerEnergy)
  54+ E141 32 AD E0    >                        ld       (SavePlayerEnergy),a
  55+ E144                                      ldCopyByte      CargoBaySize        ,SaveCargoBaySize
  55+ E144 3A E8 88    >                        ld       a,(CargoBaySize)
  55+ E147 32 AE E0    >                        ld       (SaveCargoBaySize),a
  56+ E14A                                      ldCopyByte      FuelScoopsBarrelStatus     ,SaveFuelScoopStatus
  56+ E14A 3A 02 89    >                        ld       a,(FuelScoopsBarrelStatus)
  56+ E14D 32 AF E0    >                        ld       (SaveFuelScoopStatus),a
  57+ E150 C9                                   ret
  58+ E151
  59+ E151              copyCommanderFromSave:  ldCopyStringLen SaveCommanderName,      CommanderName, 15
  59+ E151 21 5F E0    >                        ld      hl,SaveCommanderName
  59+ E154 11 0F 87    >                        ld      de, CommanderName
  59+ E157 01 0F 00    >                        ld      bc, 15
  59+ E15A ED B0       >                        ldir
  60+ E15C                                      ldCopyStringLen SaveSeeds,              GalaxySeeds, 6
  60+ E15C 21 6E E0    >                        ld      hl,SaveSeeds
  60+ E15F 11 0F 85    >                        ld      de, GalaxySeeds
  60+ E162 01 06 00    >                        ld      bc, 6
  60+ E165 ED B0       >                        ldir
  61+ E167                                      ldCopyStringLen SaveStockAvaliabiliy,   StockAvaliabiliy, 16
  61+ E167 21 74 E0    >                        ld      hl,SaveStockAvaliabiliy
  61+ E16A 11 7A 84    >                        ld      de, StockAvaliabiliy
  61+ E16D 01 10 00    >                        ld      bc, 16
  61+ E170 ED B0       >                        ldir
  62+ E172                                      ldCopyStringLen SaveCargo,              CargoTonnes, 16
  62+ E172 21 85 E0    >                        ld      hl,SaveCargo
  62+ E175 11 EA 88    >                        ld      de, CargoTonnes
  62+ E178 01 10 00    >                        ld      bc, 16
  62+ E17B ED B0       >                        ldir
  63+ E17D                                      ldCopyStringLen SaveEquipmentFitted,    EquipmentFitted, EQ_ITEM_COUNT
  63+ E17D 21 95 E0    >                        ld      hl,SaveEquipmentFitted
  63+ E180 11 02 89    >                        ld      de, EquipmentFitted
ldCopyMacros.asm(31): error: Label not found: EQ_ITEM_COUNT
commanderData.asm(63): ^ emitted from here
  63+ E183 01 00 00    >                        ld      bc, EQ_ITEM_COUNT
  63+ E186 ED B0       >                        ldir
  64+ E188                                      ldCopyStringLen SaveLaserType,          LaserType, 4
  64+ E188 21 95 E0    >                        ld      hl,SaveLaserType
  64+ E18B 11 FA 88    >                        ld      de, LaserType
  64+ E18E 01 04 00    >                        ld      bc, 4
  64+ E191 ED B0       >                        ldir
  65+ E193                                      ldCopyStringLen SaveLaserDamagedFlag,    LaserDamagedFlag, 4
  65+ E193 21 99 E0    >                        ld      hl,SaveLaserDamagedFlag
  65+ E196 11 FE 88    >                        ld      de, LaserDamagedFlag
  65+ E199 01 04 00    >                        ld      bc, 4
  65+ E19C ED B0       >                        ldir
  66+ E19E                                      ldCopy2Byte     SavePresentSystemX,     PresentSystemX
  66+ E19E 2A 9D E0    >                        ld       hl,(SavePresentSystemX)
  66+ E1A1 22 15 85    >                        ld       (PresentSystemX),hl
  67+ E1A4                                      ldCopy2Byte     SaveTargetSystemX,      TargetSystemX
  67+ E1A4 2A 9F E0    >                        ld       hl,(SaveTargetSystemX)
  67+ E1A7 22 17 85    >                        ld       (TargetSystemX),hl
  68+ E1AA 21 D3 83                             ld		hl,IndexedWork              ; not sure yet why thisis done here
  69+ E1AD CD 40 89                             call	        copy_galaxy_to_system
  70+ E1B0 CD 00 8A                             call	        find_present_system
  71+ E1B3 CD 63 89                             call	        copy_working_to_galaxy
  72+ E1B6                                      ldCopyStringLen SaveCash,               Cash, 6
  72+ E1B6 21 A1 E0    >                        ld      hl,SaveCash
  72+ E1B9 11 E3 88    >                        ld      de, Cash
  72+ E1BC 01 06 00    >                        ld      bc, 6
  72+ E1BF ED B0       >                        ldir
  73+ E1C1                                      ldCopyByte      SaveFuel,               Fuel
  73+ E1C1 3A A5 E0    >                        ld       a,(SaveFuel)
  73+ E1C4 32 E7 88    >                        ld       (Fuel),a
  74+ E1C7                                      ldCopyByte      SaveFugitiveInnocentStatus,  FugitiveInnocentStatus
  74+ E1C7 3A A6 E0    >                        ld       a,(SaveFugitiveInnocentStatus)
  74+ E1CA 32 79 84    >                        ld       (FugitiveInnocentStatus),a
  75+ E1CD                                      ldCopy2Byte     SaveKillTally           ,KillTally
  75+ E1CD 2A A7 E0    >                        ld       hl,(SaveKillTally)
  75+ E1D0 22 8C 84    >                        ld       (KillTally),hl
  76+ E1D3                                      ldCopyByte      SaveOuterHyperCount     ,OuterHyperCount
  76+ E1D3 3A A9 E0    >                        ld       a,(SaveOuterHyperCount)
  76+ E1D6 32 D4 84    >                        ld       (OuterHyperCount),a
  77+ E1D9                                      ldCopyByte      SaveInnerHyperCount     ,InnerHyperCount
  77+ E1D9 3A AA E0    >                        ld       a,(SaveInnerHyperCount)
  77+ E1DC 32 D3 84    >                        ld       (InnerHyperCount),a
  78+ E1DF                                      ldCopyByte      SaveForeShield          ,ForeShield
  78+ E1DF 3A AB E0    >                        ld       a,(SaveForeShield)
  78+ E1E2 32 08 87    >                        ld       (ForeShield),a
  79+ E1E5                                      ldCopyByte      SaveAftShield           ,AftShield
  79+ E1E5 3A AC E0    >                        ld       a,(SaveAftShield)
  79+ E1E8 32 09 87    >                        ld       (AftShield),a
  80+ E1EB                                      ldCopyByte      SavePlayerEnergy        ,PlayerEnergy
  80+ E1EB 3A AD E0    >                        ld       a,(SavePlayerEnergy)
  80+ E1EE 32 0A 87    >                        ld       (PlayerEnergy),a
  81+ E1F1                                      ldCopyByte      SaveCargoBaySize        ,CargoBaySize
  81+ E1F1 3A AE E0    >                        ld       a,(SaveCargoBaySize)
  81+ E1F4 32 E8 88    >                        ld       (CargoBaySize),a
  82+ E1F7                                      ldCopyByte      SaveFuelScoopStatus     ,FuelScoopsBarrelStatus
  82+ E1F7 3A AF E0    >                        ld       a,(SaveFuelScoopStatus)
  82+ E1FA 32 02 89    >                        ld       (FuelScoopsBarrelStatus),a
  83+ E1FD C9                                   ret
  84+ E1FE
  85+ E1FE CD B0 E0     saveCommander:          call    copyCommanderToSave
  86+ E201                                      ldCopyStringLen defaultSaveName, SaveFilename, 15
  86+ E201 21 31 E0    >                        ld      hl,defaultSaveName
  86+ E204 11 50 E0    >                        ld      de, SaveFilename
  86+ E207 01 0F 00    >                        ld      bc, 15
  86+ E20A ED B0       >                        ldir
  87+ E20C 21 31 E0                             ld      hl, defaultSaveName             ; default debug name
  88+ E20F DD 21 40 E0                          ld      ix, SaveCommanderHeader
  89+ E213 01 70 00                             ld      bc, SaveSize
commanderData.asm(90): error: Label not found: FileSave
  90+ E216 CD 00 00                             call    FileSave
  91+ E219 C9                                   ret
  92+ E21A
  93+ E21A 21 31 E0     loadCommander:          ld      hl, defaultSaveName             ; default debug name
  94+ E21D DD 21 40 E0                          ld      ix, SaveCommanderHeader
  95+ E221 01 70 00                             ld      bc, SaveSize
commanderData.asm(96): error: Label not found: FileLoad
  96+ E224 CD 00 00                             call    FileLoad
  97+ E227 CD 51 E1                             call    copyCommanderFromSave
  98+ E22A C9                                   ret
  99+ E22B
 100+ E22B               ; For now hard laod, later correctlt sequence gneeral vars and dma fill with 0 for a start
 101+ E22B              defaultCommander:       ldCopyStringLen defaultName, CommanderName, 8
 101+ E22B 21 10 E0    >                        ld      hl,defaultName
 101+ E22E 11 0F 87    >                        ld      de, CommanderName
 101+ E231 01 08 00    >                        ld      bc, 8
 101+ E234 ED B0       >                        ldir
 102+ E236                                      ldCopyStringLen defaultSeeds, GalaxySeeds, 6
 102+ E236 21 29 E0    >                        ld      hl,defaultSeeds
 102+ E239 11 0F 85    >                        ld      de, GalaxySeeds
 102+ E23C 01 06 00    >                        ld      bc, 6
 102+ E23F ED B0       >                        ldir
 103+ E241                                      ldCopy2Byte defaultHomeX, PresentSystemX
 103+ E241 2A 2F E0    >                        ld       hl,(defaultHomeX)
 103+ E244 22 15 85    >                        ld       (PresentSystemX),hl
 104+ E247                                      ldCopy2Byte defaultHomeX, TargetSystemX
 104+ E247 2A 2F E0    >                        ld       hl,(defaultHomeX)
 104+ E24A 22 17 85    >                        ld       (TargetSystemX),hl
 105+ E24D 21 D3 83                             ld		hl,IndexedWork              ; not sure yet why thisis done here
 106+ E250 CD 40 89                             call	copy_galaxy_to_system
 107+ E253 CD 00 8A                             call	find_present_system
 108+ E256 CD 63 89                             call	copy_working_to_galaxy
 109+ E259 01 60 EA                             ld      bc,60000
 110+ E25C ED 43 E3 88                          ld      (Cash),bc
 111+ E260 01 00 00                             ld		bc,0
 112+ E263 ED 43 E5 88                          ld		(Cash+2), bc                    ; cash no longer big endian
 113+ E267 3E 46                                ld		a,MaxFuelLevel
 114+ E269 32 E7 88                             ld		(Fuel),a
 115+ E26C 3E 5B                                ld      a,BankGalaxyData0
 116+ E26E 32 02 85                             ld		(Galaxy),a
 117+ E271 AF                                   xor		a
 118+ E272 21 02 89                             ld      hl,EquipmentFitted
commanderData.asm(119): error: Label not found: EQ_ITEM_COUNT
 119+ E275 06 00                                ld      b, EQ_ITEM_COUNT
 120+ E277 77           .ClearFittedLooop:      ld      (hl),a
 121+ E278 23                                   inc     hl
 122+ E279 10 FC                                djnz    .ClearFittedLooop
 123+ E27B                                      SetAFalse
 123+ E27B 3E FF       >                        ld      a,$FF
commanderData.asm(124): error: Label not found: EQ_FRONT_BEAM
 124+ E27D 32 02 89                             ld      (EquipmentFitted+EQ_FRONT_BEAM),a
 125+ E280 32 24 85                             ld		(MissionData),a						;The Plan/Mission
 126+ E283 3E 04                                ld      a,4                                  ; a = 0 = pulse laser
 127+ E285 32 FA 88                             ld		(LaserType),a
 128+ E288 3E FF                                ld      a,$FF                                 ; a = 255
 129+ E28A 32 FB 88                             ld		(LaserType+1),a
 130+ E28D 32 FC 88                             ld		(LaserType+2),a
 131+ E290 32 FD 88                             ld		(LaserType+3),a
 132+ E293 AF                                   xor     a                                  ; a= 0
 133+ E294 32 FE 88                             ld      (LaserDamagedFlag),a
 134+ E297 32 FF 88                             ld      (LaserDamagedFlag+1),a
 135+ E29A 32 00 89                             ld      (LaserDamagedFlag+2),a
 136+ E29D 32 01 89                             ld      (LaserDamagedFlag+3),a
 137+ E2A0              ; REMOVE?             ld      a,EQ_FRONT_PULSE
 138+ E2A0 AF                                   xor     a
 139+ E2A1 32 02 89                             ld		(ECMPresent),a
 140+ E2A4 32 02 89                             ld		(FuelScoopsBarrelStatus),a
 141+ E2A7 32 02 89                             ld		(EnergyBomb),a
 142+ E2AA 32 02 89                             ld		(ExtraEnergyUnit),a
 143+ E2AD 32 02 89                             ld		(DockingComputer),a
 144+ E2B0 32 02 89                             ld		(GalacticHyperDrive),a
 145+ E2B3 32 02 89                             ld		(EscapePod),a
 146+ E2B6 32 79 84                             ld      (FugitiveInnocentStatus),a
 147+ E2B9 32 8C 84                             ld		(KillTally),a
 148+ E2BC 32 D4 84                             ld      (OuterHyperCount),a
 149+ E2BF 32 D3 84                             ld      (InnerHyperCount),a
 150+ E2C2 3D                                   dec		a								; now a = 255
 151+ E2C3 32 08 87                             ld		(ForeShield),a
 152+ E2C6 32 09 87                             ld		(AftShield),a
 153+ E2C9 32 0A 87                             ld		(PlayerEnergy),a
 154+ E2CC 3E 14                                ld		a,20
 155+ E2CE 32 E8 88                             ld		(CargoBaySize),a
 156+ E2D1 CD 44 E3                             call	ZeroCargo						; Clear out cargo
 157+ E2D4 3E 00        .SetLasers:             ld      a,0                             ; we start on Front view
 158+ E2D6 CD DA E2                             call    LoadLaserToCurrent
 159+ E2D9 C9                                   ret
 160+ E2DA
 161+ E2DA
 162+ E2DA              ; a = current view number
 163+ E2DA 21 FA 88     LoadLaserToCurrent:     ld      hl,LaserType                    ; .
 164+ E2DD ED 31                                add     hl,a                            ; .
 165+ E2DF 7E                                   ld      a,(hl)                          ; .
 166+ E2E0 47                                   ld      b,a                             ; first off is there a laser present in current view
 167+ E2E1 32 20 87                             ld      (CurrLaserType),a               ; set type
 168+ E2E4 FE FF                                cp      255                             ; .
 169+ E2E6 C8                                   ret     z                               ; we can then drop out early if nothing fitted
 170+ E2E7 3E 04                                ld      a,4                             ; Damage state is in next variable in memory
 171+ E2E9 ED 31                                add     hl,a
 172+ E2EB 7E                                   ld      a,(hl)
 173+ E2EC 32 21 87                             ld      (CurrLaserDamage),a             ; copy over current laser's damage
 174+ E2EF 50                                   ld      d,b                             ; get table index
commanderData.asm(175): error: Label not found: LaserStatsTableWidth
 175+ E2F0 1E 00                                ld      e,LaserStatsTableWidth          ;
 176+ E2F2 ED 30                                mul     de                              ;
commanderData.asm(177): error: Label not found: LaserStatsTable
 177+ E2F4 21 00 00                             ld      hl,LaserStatsTable              ;
 178+ E2F7 19                                   add     hl,de                           ;
 179+ E2F8 23                                   inc     hl                              ; we already have type
 180+ E2F9                                      ldAtHLtoMem CurrLaserPulseRate          ; table [1]
 180+ E2F9 7E          >                        ld      a,(hl)
 180+ E2FA 32 22 87    >                        ld      (CurrLaserPulseRate),a
 181+ E2FD 23                                   inc     hl                              ; table [2]
 182+ E2FE                                      ldAtHLtoMem CurrLaserPulseOnTime
 182+ E2FE 7E          >                        ld      a,(hl)
 182+ E2FF 32 23 87    >                        ld      (CurrLaserPulseOnTime),a
 183+ E302 23                                   inc     hl                              ; table [3]
 184+ E303                                      ldAtHLtoMem CurrLaserPulseOffTime
 184+ E303 7E          >                        ld      a,(hl)
 184+ E304 32 24 87    >                        ld      (CurrLaserPulseOffTime),a
 185+ E307 23                                   inc     hl                              ; table [4]
 186+ E308                                      ldAtHLtoMem CurrLaserPulseRest
 186+ E308 7E          >                        ld      a,(hl)
 186+ E309 32 25 87    >                        ld      (CurrLaserPulseRest),a
 187+ E30C 23                                   inc     hl                              ; table [5]
 188+ E30D                                      ldAtHLtoMem CurrLaserDamageOutput
 188+ E30D 7E          >                        ld      a,(hl)
 188+ E30E 32 2C 87    >                        ld      (CurrLaserDamageOutput),a
 189+ E311 23                                   inc     hl                              ; table [6]
 190+ E312                                      ldAtHLtoMem CurrLaserEnergyDrain
 190+ E312 7E          >                        ld      a,(hl)
 190+ E313 32 2D 87    >                        ld      (CurrLaserEnergyDrain),a
 191+ E316 23                                   inc     hl                              ; table [7]
 192+ E317                                      ldAtHLtoMem CurrLaserHeat
 192+ E317 7E          >                        ld      a,(hl)
 192+ E318 32 2E 87    >                        ld      (CurrLaserHeat),a
 193+ E31B 23                                   inc     hl                              ; table [8]
 194+ E31C                                      ldAtHLtoMem CurrLaserDurability
 194+ E31C 7E          >                        ld      a,(hl)
 194+ E31D 32 2F 87    >                        ld      (CurrLaserDurability),a
 195+ E320 23                                   inc     hl                              ; table [9]
 196+ E321                                      ldAtHLtoMem CurrLaserDurabilityAmount   ; we don't need tech level etc for in game run only markets so stop here
 196+ E321 7E          >                        ld      a,(hl)
 196+ E322 32 30 87    >                        ld      (CurrLaserDurabilityAmount),a
 197+ E325 C9                                   ret
 198+ E326
 199+ E326              ; Set a = 2 * (slaves + narcotics) + firearms
 200+ E326 3A ED 88     calculateBadness:       ld      a,(SlaveCargoTonnes)            ; Badness = 2(slaves + narcotics)
 201+ E329 47                                   ld      b,a                             ; .
 202+ E32A 3A F0 88                             ld      a,(NarcoticsCargoTonnes)        ; .
 203+ E32D 80                                   add     b                               ; .
 204+ E32E CB 27                                sla     a                               ; .
 205+ E330 47                                   ld      b,a                             ;
 206+ E331 3A F4 88                             ld      a,(FirearmsCargoTonnes)         ; Badness += firearms tonns
 207+ E334 80                                   add     b
 208+ E335 C9                                   ret
 209+ E336
 210+ E336 CD 51 E1     PlayerDeath:            call    copyCommanderFromSave           ; load last loaded/saved commander
 211+ E339                                      ZeroA                                   ; set current laser to front
 211+ E339 AF          >                        xor a
 212+ E33A CD DA E2                             call    LoadLaserToCurrent
 213+ E33D CD 0C 88                             call    InitMainLoop
 214+ E340 CD AD 87                             call    ResetPlayerShip
 215+ E343 C9                                   ret
 216+ E344                                  ;    clear out all other objects
 217+ E344                                  ;    create debris
 218+ E344                                  ;    if cargo presetn then create a cargo
 219+ E344                                  ;
 220+ E344                                  ;    enqueve message game over
 221+ E344                                  ;    go to load commander page
# file closed: ../Commander/commanderData.asm
 167  E344                  INCLUDE "../Commander/zero_player_cargo.asm"
# file opened: ../Commander/zero_player_cargo.asm
   1+ E344              ZeroCargo:
   2+ E344 AF           		xor		a							;zero-out cargo, including gems.
   3+ E345 06 10        		ld		b,16						;all the way up to alien items
   4+ E347 21 EA 88     		ld		hl,CargoTonnes   			; cargo levels
   5+ E34A              .ZeroLoop:
   6+ E34A 77                   ld      (hl),a
   7+ E34B 23           		inc		hl
   8+ E34C 10 FC        		djnz	.ZeroLoop
   9+ E34E C9           		ret
  10+ E34F
# file closed: ../Commander/zero_player_cargo.asm
 168  E34F                  ; Bank 58  ------------------------------------------------------------------------------------------------------------------------
 169  E34F                  SLOT    LAYER1Addr
 170  E34F                  PAGE    BankLAYER1
 171  E34F                  ORG     LAYER1Addr, BankLAYER1
 172  E000
 173  E000                  INCLUDE "../Layer1Graphics/layer1_attr_utils.asm"
# file opened: ../Layer1Graphics/layer1_attr_utils.asm
   1+ E000
   2+ E000 00 58        L1AttrRow00:            DW $5800                    ;Row 1    */
   3+ E002 20 58        L1AttrRow01:            DW $5820                    ;Row 2    */
   4+ E004 40 58        L1AttrRow02:            DW $5840                    ;Row 3    */
   5+ E006 60 58        L1AttrRow03:            DW $5860                    ;Row 4    */
   6+ E008 80 58        L1AttrRow04:            DW $5880                    ;Row 5    */
   7+ E00A A0 58        L1AttrRow05:            DW $58A0                    ;Row 6    */
   8+ E00C C0 58        L1AttrRow06:            DW $58C0                    ;Row 7    */
   9+ E00E E0 58        L1AttrRow07:            DW $58E0                    ;Row 8    */
  10+ E010 00 59        L1AttrRow08:            DW $5900                    ;Row 9    */
  11+ E012 20 59        L1AttrRow09:            DW $5920                    ;Row 10   */
  12+ E014 40 59        L1AttrRow10:            DW $5940                    ;Row 11   */
  13+ E016 60 59        L1AttrRow11:            DW $5960                    ;Row 12   */
  14+ E018 80 59        L1AttrRow12:            DW $5980                    ;Row 13   */
  15+ E01A A0 59        L1AttrRow13:            DW $59A0                    ;Row 14   */
  16+ E01C C0 59        L1AttrRow14:            DW $59C0                    ;Row 15   */
  17+ E01E E0 59        L1AttrRow15:            DW $59E0                    ;Row 16   */
  18+ E020 00 5A        L1AttrRow16:            DW $5A00                    ;Row 17   */
  19+ E022 20 5A        L1AttrRow17:            DW $5A20                    ;Row 18   */
  20+ E024 40 5A        L1AttrRow18:            DW $5A40                    ;Row 19   */
  21+ E026 60 5A        L1AttrRow19:            DW $5A60                    ;Row 20   */
  22+ E028 80 5A        L1AttrRow20:            DW $5A80                    ;Row 21   */
  23+ E02A A0 5A        L1AttrRow21:            DW $5AA0                    ;Row 22   */
  24+ E02C C0 5A        L1AttrRow22:            DW $5AC0                    ;Row 23   */
  25+ E02E E0 5A        L1AttrRow23:            DW $5AE0                    ;Row 23   */
  26+ E030
  27+ E030              ; "l2_hilight_row, d = row, e = colour"
  28+ E030 21 00 E0     l1_hilight_row:         ld      hl, L1AttrRow00
  29+ E033 4B                                   ld      c,e
  30+ E034 7A                                   ld      a,d
  31+ E035 CB 27                                sla     a
  32+ E037 ED 31                                add     hl,a
  33+ E039 7E                                   ld      a,(hl)
  34+ E03A 5F                                   ld      e,a
  35+ E03B 23                                   inc     hl
  36+ E03C 7E                                   ld      a,(hl)
  37+ E03D 57                                   ld      d,a
  38+ E03E EB                                   ex      hl,de
  39+ E03F 79                                   ld		a,c
  40+ E040 11 20 00                             ld		de, 32
layer1_attr_utils.asm(41): error: Label not found: memfill_dma
  41+ E043 CD 00 00                             call	memfill_dma
  42+ E046 C9                                   ret
  43+ E047
# file closed: ../Layer1Graphics/layer1_attr_utils.asm
 174  E047                  INCLUDE "../Layer1Graphics/layer1_cls.asm"
# file opened: ../Layer1Graphics/layer1_cls.asm
   1+ E047 AF           l1_cls_top:             xor     a
   2+ E048 21 00 40                             ld      hl, $4000
   3+ E04B 11 00 08                             ld      de, $0800
layer1_cls.asm(4): error: Label not found: memfill_dma
   4+ E04E CD 00 00                             call    memfill_dma
   5+ E051 C9                                   ret
   6+ E052
   7+ E052 AF           l1_cls_mid:             xor     a
   8+ E053 21 00 48                             ld      hl, $4800
   9+ E056 11 00 08                             ld      de, $0800
layer1_cls.asm(10): error: Label not found: memfill_dma
  10+ E059 CD 00 00                             call    memfill_dma
  11+ E05C C9                                   ret
  12+ E05D
  13+ E05D AF           l1_cls_bottom:          xor     a
  14+ E05E 21 00 50                             ld      hl, $5000
  15+ E061 11 00 08                             ld      de, $0800
layer1_cls.asm(16): error: Label not found: memfill_dma
  16+ E064 CD 00 00                             call    memfill_dma
  17+ E067 C9                                   ret
  18+ E068
  19+ E068              ; Designed specifically to clear a whole character aligned line
  20+ E068 1E 00        l1_cls_line_d:          ld      e,0
  21+ E06A ED 94                                pixelad
  22+ E06C 11 00 01                             ld      de,32 * 8
  23+ E06F AF                                   xor     a
layer1_cls.asm(24): error: Label not found: memfill_dma
  24+ E070 CD 00 00                             call    memfill_dma
  25+ E073 C9                                   ret
  26+ E074
  27+ E074              ; Designed specifically to clear a whole character aligned 2 lines line, used for say clearing hyperspace message
  28+ E074 1E 00        l1_cls_2_lines_d:       ld      e,0
  29+ E076 ED 94                                pixelad
  30+ E078 11 00 02                             ld      de,32 * 16
  31+ E07B AF                                   xor     a
layer1_cls.asm(32): error: Label not found: memfill_dma
  32+ E07C CD 00 00                             call    memfill_dma
  33+ E07F C9                                   ret
  34+ E080
  35+ E080 AF           l1_cls:                 xor		a
  36+ E081 21 00 40     l1_cls_to_a:            ld		hl,	$4000
  37+ E084 11 00 18                             ld		de, $1800
layer1_cls.asm(38): error: Label not found: memfill_dma
  38+ E087 CD 00 00                             call	memfill_dma
  39+ E08A C9                                   ret
  40+ E08B
  41+ E08B 21 00 58     l1_attr_cls_2DlinesA:   ld		hl,	$5800
  42+ E08E 1E 20                                ld      e,32
  43+ E090 ED 30                                mul
  44+ E092 19                                   add     hl,de
  45+ E093 11 40 00                             ld		de, 32 * 2
layer1_cls.asm(46): error: Label not found: memfill_dma
  46+ E096 CD 00 00                             call	memfill_dma
  47+ E099 C9                                   ret
  48+ E09A
  49+ E09A
  50+ E09A AF           l1_attr_cls:            xor		a
  51+ E09B 21 00 58     l1_attr_cls_to_a:       ld		hl,	$5800
  52+ E09E 11 00 03                             ld		de, $0300
layer1_cls.asm(53): error: Label not found: memfill_dma
  53+ E0A1 CD 00 00                             call	memfill_dma
  54+ E0A4 C9                                   ret
  55+ E0A5
  56+ E0A5 01 FE FE     l1_set_border:          ld	    bc, 0xFEFE
  57+ E0A8 ED 79                                out		(c),a
  58+ E0AA C9                                   ret
# file closed: ../Layer1Graphics/layer1_cls.asm
 175  E0AB                  INCLUDE "../Layer1Graphics/layer1_print_at.asm"
# file opened: ../Layer1Graphics/layer1_print_at.asm
   1+ E0AB              ; "l1 print char a = character, de = Ypixel Xchar of print"
   2+ E0AB D5 E5        l1_print_char:          push	de,,hl
   3+ E0AD ED 94                                pixelad								; hl = address of de
   4+ E0AF E5                                   push	hl							; save hl for loop
   5+ E0B0 26 00                                ld		h,0
   6+ E0B2 6F                                   ld		l,a
   7+ E0B3 29                                   add		hl,hl						; * 2
   8+ E0B4 29                                   add		hl,hl						; * 4
   9+ E0B5 29                                   add		hl,hl						; * 8 to get byte address
  10+ E0B6 ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
  11+ E0BA EB                                   ex		de,hl						; save address into de
  12+ E0BB E1                                   pop		hl							; get back hl for loop
  13+ E0BC 06 08                                ld		b,8							; do 8 rows
  14+ E0BE 1A           .PrintCharLoop:         ld		a,(de)						; row byte
  15+ E0BF 13                                   inc		de							; next byte
  16+ E0C0 77                                   ld		(hl),a						; poke to screen
  17+ E0C1 ED 93                                pixeldn								; Down 1 row
  18+ E0C3 10 F9                                djnz	.PrintCharLoop				; loop for 8 bytes
  19+ E0C5 E1 D1                                pop		de,,hl					    ; restore hl
  20+ E0C7 C9                                   ret
  21+ E0C8
  22+ E0C8              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
  23+ E0C8              ; now skips ascii code < 32 but moves on cursor by 1 char
  24+ E0C8              l1_print_at:
  25+ E0C8 7E           .PrintLoop:             ld		a,(hl)
  26+ E0C9 FE 00                                cp		0
  27+ E0CB C8                                   ret		z
  28+ E0CC                                      CallIfAGTENusng " ", l1_print_char
  28+ E0CC FE 20       >                        cp      " "
  28+ E0CE D4 AB E0    >                        call	nc,l1_print_char
  29+ E0D1 23                                   inc		hl							; move 1 message character right
  30+ E0D2 7B                                   ld		a,e
  31+ E0D3 C6 08                                add		a,8
  32+ E0D5 5F                                   ld		e,a							; move 1 screen character right
  33+ E0D6 18 F0                                jr		.PrintLoop
  34+ E0D8              .Clearstackandfinish:   ;pop		de                      ; TODO LOOOKS TO BE A ROGUE POPDE
  35+ E0D8 C9                                   ret
  36+ E0D9
  37+ E0D9              ;l1_print_at_wrap:
  38+ E0D9              ;; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
  39+ E0D9              ;	ld      iyh,e
  40+ E0D9              ;.PrintLoop:
  41+ E0D9              ;	ld		a,(hl)
  42+ E0D9              ;	cp		0
  43+ E0D9              ;	ret		z
  44+ E0D9              ;.CountWordCharLen
  45+ E0D9              ;; Need to change to word wrap, so it will loop through string as before
  46+ E0D9              ;; but read up until a null or space, take the character count * 8 for pixels
  47+ E0D9              ;; if that is > 238 then force a premature line wrap
  48+ E0D9              ;
  49+ E0D9              ;
  50+ E0D9              ;    push    iy
  51+ E0D9              ;    call	l1_print_char
  52+ E0D9              ;    pop     iy
  53+ E0D9              ;	inc		hl							; move 1 message character right
  54+ E0D9              ;	ld		a,e
  55+ E0D9              ;    cp      238
  56+ E0D9              ;    jr      nc,.NextLine
  57+ E0D9              ;	add		a,8
  58+ E0D9              ;	ld		e,a							; move 1 screen character right
  59+ E0D9              ;	jr		.PrintLoop
  60+ E0D9              ;.Clearstackandfinish:
  61+ E0D9              ;	pop		de
  62+ E0D9              ;	ret
  63+ E0D9              ;.NextLine:
  64+ E0D9              ;    ld      a,(hl)
  65+ E0D9              ;    cp      " "
  66+ E0D9              ;    ld      e,iyh
  67+ E0D9              ;    ld      a,d
  68+ E0D9              ;    add     a,8
  69+ E0D9              ;    ld      d,a
  70+ E0D9              ;    jr		.PrintLoop
  71+ E0D9
  72+ E0D9              ; Counts next word at hl, uses e and forces a wrap if it would over flow puts value in c
  73+ E0D9 E5           L1LenWordAtHL:          push    hl
  74+ E0DA D5                                   push    de
  75+ E0DB 7E           .CountLoop:             ld      a,(hl)
  76+ E0DC FE 00                                cp      0
  77+ E0DE 28 0F                                jr      z,.CountDone
  78+ E0E0 FE 20                                cp      32
  79+ E0E2 28 0B                                jr      z,.CountDone
  80+ E0E4 7B                                   ld      a,e
  81+ E0E5 C6 08                                add     a,8
  82+ E0E7 5F                                   ld      e,a
  83+ E0E8 FE EE                                cp      238
  84+ E0EA 30 07                                jr      nc,.TooLong
  85+ E0EC 23                                   inc     hl
  86+ E0ED 18 EC                                jr      .CountLoop
  87+ E0EF D1           .CountDone:             pop     de
  88+ E0F0 E1                                   pop     hl
  89+ E0F1 AF                                   xor     a
  90+ E0F2 C9                                   ret
  91+ E0F3 D1           .TooLong                pop     de
  92+ E0F4 E1                                   pop     hl
  93+ E0F5 3E FF                                ld      a,$FF
  94+ E0F7 C9                                   ret
  95+ E0F8
  96+ E0F8 7E           L1PrintWordAtHL:        ld      a,(hl)
  97+ E0F9 FE 00                                cp      0
  98+ E0FB C8                                   ret     z
  99+ E0FC FE 20                                cp      32
 100+ E0FE 28 0F                                jr      z,.ItsASpace
 101+ E100 FD E5                                push    iy
 102+ E102 CD AB E0                             call	l1_print_char
 103+ E105 FD E1                                pop     iy
 104+ E107 7B                                   ld      a,e
 105+ E108 C6 08                                add     a,8
 106+ E10A 5F                                   ld      e,a
 107+ E10B 23                                   inc     hl
 108+ E10C C3 F8 E0                             jp      L1PrintWordAtHL
 109+ E10F 23           .ItsASpace:             inc     hl      ;  Just a bodge for now
 110+ E110 7B                                   ld      a,e
 111+ E111 C6 08                                add     a,8
 112+ E113 5F                                   ld      e,a
 113+ E114 C9                                   ret
 114+ E115
 115+ E115
 116+ E115              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
 117+ E115              ; Now has full word level wrapping
 118+ E115 FD 63        l1_print_at_wrap:       ld      iyh,e
 119+ E117 7E           .PrintLoop:             ld		a,(hl)
 120+ E118 FE 00                                cp		0
 121+ E11A C8                                   ret		z
 122+ E11B CD D9 E0     .CountWordCharLen:      call    L1LenWordAtHL
 123+ E11E FE FF                                cp      $FF
 124+ E120 28 06                                jr      z,.WrapNextLine
 125+ E122 CD F8 E0     .NotTooLong:            call    L1PrintWordAtHL
 126+ E125              ; Need to change to word wrap, so it will loop through string as before
 127+ E125              ; but read up until a null or space, take the character count * 8 for pixels
 128+ E125              ; if that is > 238 then force a premature line wrap
 129+ E125 18 F0                                jr		.PrintLoop
 130+ E127              .Clearstackandfinish:   ;op		de
 131+ E127 C9                                   ret
 132+ E128              .WrapNextLine:
 133+ E128 FD 5C        .NextLine:              ld      e,iyh
 134+ E12A 7A                                   ld      a,d
 135+ E12B C6 08                                add     a,8
 136+ E12D 57                                   ld      d,a
 137+ E12E 18 E7                                jr		.PrintLoop
 138+ E130
 139+ E130
# file closed: ../Layer1Graphics/layer1_print_at.asm
 176  E130              ; Bank 83  ------------------------------------------------------------------------------------------------------------------------
 177  E130                  SLOT    SunBankAddr
 178  E130                  PAGE    BankSunData
 179  E130              	ORG	    SunBankAddr,BankSunData
 180  C000                  INCLUDE "../Universe/Sun/sun_data.asm"
# file opened: ../Universe/Sun/sun_data.asm
   1+ C000              ; In  flight ship data tables
   2+ C000              ; In  flight ship data tables
   3+ C000              ; In  flight ship data tables
   4+ C000              ; There can be upto &12 objects in flight.
   5+ C000              ; To avoid hassle of memory heap managment, the free list
   6+ C000              ; will correspond to a memory bank offset so data will be held in
   7+ C000              ; 1 bank per universe object. Its a waste of a lot of memory but really
   8+ C000              ; 1 bank per universe object. Its a waste of a lot of memory but really
   9+ C000              ; simple that way. Each bank will be 8K and swapped on 8K slot 7 $E000 to $FFFF
  10+ C000              ; This means each gets its own line list, inwork etc
  11+ C000
  12+ C000              ; "Runtime Ship Data paged into in Bank 7"
  13+ C000 53 75 6E 20  StartOfSun:        DB "Sun and Planet X"
  13+ C004 61 6E 64 20
  13+ C008 50 6C 61 6E
  13+ C00C 65 74 20 58
  14+ C010              ; NOTE we can cheat and pre allocate segs just using a DS for now
  15+ C010              CheckRowHLOnScreen:     MACRO   failtarget
  16+ C010 ~                                    ld      a,h                             ; is h byte set, i.e > 256 or < 0
  17+ C010 ~                                    and     a                               ; .
  18+ C010 ~                                    jr      nz,failtarget                   ; h <> 0 so fails (covers <0 and > 255
  19+ C010 ~                                    ld      a,l                             ; l bit 7 0?
  20+ C010 ~                                    and     Bit7Only                        ; covers l > 127 (screen draw area is 0 to 192 / 3 * 2 (128)
  21+ C010 ~                                    jr      nz,failtarget                   ;
  22+ C010                                      ENDM
  23+ C010
  24+ C010              ; IY = SBnKLineArray + rowValue*2
  25+ C010              IYEquRowN:              MACRO   rowValue                        ; set up iy as target address
  26+ C010 ~                                    ld      a,rowValue
  27+ C010 ~                                    ld      hl,SBnKLineArray
  28+ C010 ~                                    add     hl,a
  29+ C010 ~                                    add     hl,a
  30+ C010 ~                                    push    hl
  31+ C010 ~                                    pop     iy
  32+ C010                                      ENDM
  33+ C010              ;   \ -> & 565D \ See ship data files chosen and loaded after flight code starts running.
  34+ C010              ; Universe map substibute for INWK
  35+ C010              ;-Camera Position of Ship----------------------------------------------------------------------------------------------------------
  36+ C010              SBnKDataBlock:
  37+ C010                                      INCLUDE "../Universe/Sun/SunPosVars.asm"
# file opened: ./../Universe/Sun/SunPosVars.asm
   1++C010              ;-Camera Position of Ship----------------------------------------------------------------------------------------------------------
   2++C010 00           SBnKxlo                     DB  0                       ; INWK+0
   3++C011 00           SBnKxhi                     DB  0                       ; there are hi medium low as some times these are 24 bit
   4++C012 00           SBnKxsgn                    DB  0                       ; INWK+2
   5++C013 00           SBnKylo                     DB  0                       ; INWK+3 \ ylo
   6++C014 00           SBnKyhi                     DB  0                       ; INWK+4 \ yHi
   7++C015 00           SBnKysgn                    DB  0                       ; INWK +5
   8++C016 00           SBnKzlo                     DB  0                       ; INWK +6
   9++C017 00           SBnKzhi                     DB  0                       ; INWK +7
  10++C018 00           SBnKzsgn                    DB  0                       ; INWK +8
  11++C019
# file closed: ./../Universe/Sun/SunPosVars.asm
  38+ C019                                      INCLUDE "../Universe/Sun/SunRotationMatrixVars.asm"
# file opened: ./../Universe/Sun/SunRotationMatrixVars.asm
   1++C019              ;-Rotation Matrix of Ship----------------------------------------------------------------------------------------------------------
   2++C019              ; Rotation data is stored as lohi, but only 15 bits with 16th bit being  a sign bit. Note this is NOT 2'c compliment
   3++C019 00 00        SBnKrotmatSidevX            DW  0                       ; INWK +21
   4++C01B              SBnKrotmatSidev             equ SBnKrotmatSidevX
   5++C01B 00 00        SBnKrotmatSidevY            DW  0                       ; INWK +23
   6++C01D 00 00        SBnKrotmatSidevZ            DW  0                       ; INWK +25
   7++C01F 00 00        SBnKrotmatRoofvX            DW  0                       ; INWK +15
   8++C021              SBnKrotmatRoofv             equ SBnKrotmatRoofvX
   9++C021 00 00        SBnKrotmatRoofvY            DW  0                       ; INWK +17
  10++C023 00 00        SBnKrotmatRoofvZ            DW  0                       ; INWK +19
  11++C025 00 00        SBnKrotmatNosevX            DW  0                       ; INWK +9
  12++C027              SBnKrotmatNosev             EQU SBnKrotmatNosevX
  13++C027 00 00        SBnKrotmatNosevY            DW  0                       ; INWK +11
  14++C029 00 00        SBnKrotmatNosevZ            DW  0                       ; INWK +13
  15++C02B
# file closed: ./../Universe/Sun/SunRotationMatrixVars.asm
  39+ C02B                                      INCLUDE "../Universe/Sun/SunAIRuntimeData.asm"
# file opened: ./../Universe/Sun/SunAIRuntimeData.asm
   1++C02B              ; -- Ship AI data
   2++C02B 00           SBnKRotXCounter             DB  0                       ; INWK +29
   3++C02C 00           SBnKRotZCounter             DB  0                       ; INWK +30
   4++C02D 00           SBnkCam0yLo                 DB  0                       ; INWK +33 ????
   5++C02E 00           SBnkCam0yHi                 DB  0                       ; INWK +34?????
   6++C02F
# file closed: ./../Universe/Sun/SunAIRuntimeData.asm
  40+ C02F
  41+ C02F
  42+ C02F                                      INCLUDE "../Universe/Sun/SunXX16Vars.asm"
# file opened: ./../Universe/Sun/SunXX16Vars.asm
   1++C02F              ;-- XX16 --------------------------------------------------------------------------------------------------------------------------
   2++C02F 00 00        SBnkTransmatSidevX          DW  0               ; XX16+0
   3++C031              SBnkTransmatSidev           EQU SBnkTransmatSidevX
   4++C031 00 00        SBnkTransmatSidevY          DW 0                ; XX16+2
   5++C033 00 00        SBnkTransmatSidevZ          DW 0                ; XX16+2
   6++C035 00 00        SBnkTransmatRoofvX          DW 0
   7++C037              SBnkTransmatRoofv           EQU SBnkTransmatRoofvX
   8++C037 00 00        SBnkTransmatRoofvY          DW 0                ; XX16+2
   9++C039 00 00        SBnkTransmatRoofvZ          DW 0                ; XX16+2
  10++C03B 00 00        SBnkTransmatNosevX          DW 0
  11++C03D              SBnkTransmatNosev           EQU SBnkTransmatNosevX
  12++C03D 00 00        SBnkTransmatNosevY          DW 0                ; XX16+2
  13++C03F 00 00        SBnkTransmatNosevZ          DW 0                ; XX16+2
  14++C041 00 00        SBnkTransmatTransX          DW 0
  15++C043 00 00        SBnkTransmatTransY          DW 0
  16++C045 00 00        SBnkTransmatTransZ          DW 0
  17++C047              SunXX16                      equ SBnkTransmatSidev
  18++C047              ;-- XX16Inv --------------------------------------------------------------------------------------------------------------------------
  19++C047 00 00        SBnkTransInvRow0x0          DW 0
  20++C049 00 00        SBnkTransInvRow0x1          DW 0
  21++C04B 00 00        SBnkTransInvRow0x2          DW 0
  22++C04D 00 00        SBnkTransInvRow0x3          DW 0
  23++C04F 00 00        SBnkTransInvRow1y0          DW 0
  24++C051 00 00        SBnkTransInvRow1y1          DW 0
  25++C053 00 00        SBnkTransInvRow1y2          DW 0
  26++C055 00 00        SBnkTransInvRow1y3          DW 0
  27++C057 00 00        SBnkTransInvRow2z0          DW 0
  28++C059 00 00        SBnkTransInvRow2z1          DW 0
  29++C05B 00 00        SBnkTransInvRow2z2          DW 0
  30++C05D 00 00        SBnkTransInvRow2z3          DW 0
  31++C05F
  32++C05F              SunXX16Inv             equ SBnkTransInvRow0x0
  33++C05F
# file closed: ./../Universe/Sun/SunXX16Vars.asm
  43+ C05F                                      INCLUDE "../Universe/Sun/SunXX25Vars.asm"
# file opened: ./../Universe/Sun/SunXX25Vars.asm
   1++C05F              ;-- XX25 --------------------------------------------------------------------------------------------------------------------------
   2++C05F 00           SBnKProjxLo                 DB  0
   3++C060 00           SBnKProjxHi                 DB  0
   4++C061 00           SBnKProjxSgn                DB  0
   5++C062              SBnKProjx                   EQU SBnKProjxLo
   6++C062 00           SBnKProjyLo                 DB  0
   7++C063 00           SBnKProjyHi                 DB  0
   8++C064 00           SBnKProjySgn                DB  0
   9++C065              SBnKProjy                   EQU SBnKProjyLo
  10++C065 00           SBnKProjzLo                 DB  0
  11++C066 00           SBnKProjzHi                 DB  0
  12++C067 00           SBnKProjzSgn                DB  0
  13++C068              SBnKProjz                   EQU SBnKProjzLo
  14++C068              SXX25                       EQU SBnKProjxLo
  15++C068
# file closed: ./../Universe/Sun/SunXX25Vars.asm
  44+ C068                                      INCLUDE "../Universe/Sun/SunXX18Vars.asm"
# file opened: ./../Universe/Sun/SunXX18Vars.asm
   1++C068              ;-- XX18 --------------------------------------------------------------------------------------------------------------------------
   2++C068 00           SBnKDrawCam0xLo             DB  0               ; XX18+0
   3++C069 00           SBnKDrawCam0xHi             DB  0               ; XX18+1
   4++C06A 00           SBnKDrawCam0xSgn            DB  0               ; XX18+2
   5++C06B              SBnKDrawCam0x               equ SBnKDrawCam0xLo
   6++C06B 00           SBnKDrawCam0yLo             DB  0               ; XX18+3
   7++C06C 00           SBnKDrawCam0yHi             DB  0               ; XX18+4
   8++C06D 00           SBnKDrawCam0ySgn            DB  0               ; XX18+5
   9++C06E              SBnKDrawCam0y               equ SBnKDrawCam0yLo
  10++C06E 00           SBnKDrawCam0zLo             DB  0               ; XX18+6
  11++C06F 00           SBnKDrawCam0zHi             DB  0               ; XX18+7
  12++C070 00           SBnKDrawCam0zSgn            DB  0               ; XX18+8
  13++C071              SBnKDrawCam0z               equ SBnKDrawCam0zLo
  14++C071              SXX18                       equ SBnKDrawCam0xLo
  15++C071
# file closed: ./../Universe/Sun/SunXX18Vars.asm
sun_data.asm(45): error: Unrecognized instruction: .
  45+ C071                                                .
  46+ C071              ; Used to make 16 bit reads a little cleaner in source code
  47+ C071 00 00 00     SBnKzPoint                  DS  3
  48+ C074              SBnKzPointLo                equ SBnKzPoint
  49+ C074              SBnKzPointHi                equ SBnKzPoint+1
  50+ C074              SBnKzPointSign              equ SBnKzPoint+2
  51+ C074                                      INCLUDE "../Universe/Sun/SunXX15Vars.asm"
# file opened: ./../Universe/Sun/SunXX15Vars.asm
   1++C074              ;-- XX15 --------------------------------------------------------------------------------------------------------------------------
   2++C074 00           SBnKXScaled                 DB  0               ; XX15+0Xscaled
   3++C075 00           SBnKXScaledSign             DB  0               ; XX15+1xsign
   4++C076 00           SBnKYScaled                 DB  0               ; XX15+2yscaled
   5++C077 00           SBnKYScaledSign             DB  0               ; XX15+3ysign
   6++C078 00           SBnKZScaled                 DB  0               ; XX15+4zscaled
   7++C079 00           SBnKZScaledSign             DB  0               ; XX15+5zsign
   8++C07A
   9++C07A              SXX15                       equ SBnKXScaled
  10++C07A              SXX15VecX                   equ SXX15
  11++C07A              SXX15VecY                   equ SXX15+1
  12++C07A              SXX15VecZ                   equ SXX15+2
  13++C07A              SBnKXPoint                  equ SXX15
  14++C07A              SBnKXPointLo                equ SXX15+0
  15++C07A              SBnKXPointHi                equ SXX15+1
  16++C07A              SBnKXPointSign              equ SXX15+2
  17++C07A              SBnKYPoint                  equ SXX15+3
  18++C07A              SBnKYPointLo                equ SXX15+3
  19++C07A              SBnKYPointHi                equ SXX15+4
  20++C07A              SBnKYPointSign              equ SXX15+5
  21++C07A
# file closed: ./../Universe/Sun/SunXX15Vars.asm
  52+ C07A                                      INCLUDE "../Universe/Sun/SunXX12Vars.asm"
# file opened: ./../Universe/Sun/SunXX12Vars.asm
   1++C07A              ;-- transmat0 --------------------------------------------------------------------------------------------------------------------------
   2++C07A              ; Note XX12 comes after as some logic in normal processing uses XX15 and XX12 combines
   3++C07A 00           SBnKXX12xLo                 DB  0               ; XX12+0
   4++C07B 00           SBnKXX12xSign               DB  0               ; XX12+1
   5++C07C 00           SBnKXX12yLo                 DB  0               ; XX12+2
   6++C07D 00           SBnKXX12ySign               DB  0               ; XX12+3
   7++C07E 00           SBnKXX12zLo                 DB  0               ; XX12+4
   8++C07F 00           SBnKXX12zSign               DB  0               ; XX12+5
   9++C080 00 00 00...  SXX12Save                   DS  6
  10++C086 00 00 00...  SXX12Save2                  DS  6
  11++C08C              SXX12                       equ SBnKXX12xLo
  12++C08C              varSXX12                    equ SBnKXX12xLo
  13++C08C              ; Repurposed XX12 when plotting lines
  14++C08C              SBnkY2                      equ SXX12+0
  15++C08C              SbnKy2Lo                    equ SXX12+0
  16++C08C              SBnkY2Hi                    equ SXX12+1
  17++C08C              SBnkDeltaXLo                equ SXX12+2
  18++C08C              SBnkDeltaXHi                equ SXX12+3
  19++C08C              SBnkDeltaYLo                equ SXX12+4
  20++C08C              SBnkDeltaYHi                equ SXX12+5
  21++C08C              SbnkGradient                equ SXX12+2
  22++C08C              SBnkTemp1                   equ SXX12+2
  23++C08C              SBnkTemp1Lo                 equ SXX12+2
  24++C08C              SBnkTemp1Hi                 equ SXX12+3
  25++C08C              SBnkTemp2                   equ SXX12+3
  26++C08C              SBnkTemp2Lo                 equ SXX12+3
  27++C08C              SBnkTemp2Hi                 equ SXX12+4
  28++C08C
# file closed: ./../Universe/Sun/SunXX12Vars.asm
  53+ C08C
  54+ C08C
  55+ C08C              ; Post clipping the results are now 8 bit
  56+ C08C 00           SBnKVisibility              DB  0               ; replaces general purpose xx4 in rendering
  57+ C08D 00           SBnKProjectedY              DB  0
  58+ C08E 00           SBnKProjectedX              DB  0
  59+ C08F              SBnKProjected               equ SBnKProjectedY  ; resultant projected position
  60+ C08F 00 00 00...  SunXX15Save                 DS  8
  61+ C097 00 00 00...  SunXX15Save2                DS  8
  62+ C09F              ; Heap (or array) information for lines and normals
  63+ C09F              ; Coords are stored XY,XY,XY,XY
  64+ C09F              ; Normals
  65+ C09F              ; This needs re-oprganising now.
  66+ C09F              ; Runtime Calculation Store
  67+ C09F
  68+ C09F              SunLineArraySize            equ 128 * 2
  69+ C09F              ; Storage arrays for data
  70+ C09F
  71+ C09F 00 00 00...  SBnKLineArray               DS SunLineArraySize ; XX19 Holds the clipped line details
  72+ C19F              SBnKLinesHeapMax            EQU $ - SBnKLineArray
  73+ C19F
  74+ C19F 00 00        LineArrayPtr                DW  0
  75+ C1A1
  76+ C1A1              SBnK_Data_len               EQU $ - SBnKDataBlock
  77+ C1A1
  78+ C1A1              ; --------------------------------------------------------------
  79+ C1A1 21 10 C0     ResetSBnKData:          ld      hl,SBnKDataBlock
  80+ C1A4 11 91 01                             ld      de,SBnK_Data_len
  81+ C1A7 AF                                   xor     a
sun_data.asm(82): error: Label not found: memfill_dma
  82+ C1A8 CD 00 00                             call    memfill_dma
  83+ C1AB C9                                   ret
  84+ C1AC              ; --------------------------------------------------------------
  85+ C1AC 21 10 C0     ResetSBnKPosition:      ld      hl,SBnKxlo
  86+ C1AF 06 09                                ld      b, 3*3
  87+ C1B1 AF                                   xor     a
  88+ C1B2 77           .zeroLoop:              ld      (hl),a
  89+ C1B3 23                                   inc     hl
  90+ C1B4 10 FC                                djnz    .zeroLoop
  91+ C1B6 C9                                   ret
  92+ C1B7              ; This uses UBNKNodeArray as the list
  93+ C1B7              ; the array is 256 * 2 bytes
  94+ C1B7              ; counter is current row y pos
  95+ C1B7              ; byte 1 is start x pos
  96+ C1B7              ; byte 2 is end x pos
  97+ C1B7              ; if they are both 0 then skip
  98+ C1B7              ; its always horizontal, yellow
  99+ C1B7
 100+ C1B7              ; PLANET
 101+ C1B7
 102+ C1B7
 103+ C1B7              .SunNoDraw:             SetCarryFlag                    ; ship is behind so do not draw, so we don't care abour draw as dot
 103+ C1B7 37          >                        scf
 104+ C1B8 C9                                   ret
 105+ C1B9
 106+ C1B9
 107+ C1B9
 108+ C1B9              SunBankDraw:            MACRO
 109+ C1B9 ~            .drawLoop               ld      a,(hl)
 110+ C1B9 ~                                    ld      c,a                     ; c = left column
 111+ C1B9 ~                                    inc     hl
 112+ C1B9 ~                                    ld      d,(hl)                  ; d = right col
 113+ C1B9 ~                                    inc     hl                      ; now ready for next linel
 114+ C1B9 ~                                    push    hl,,bc
 115+ C1B9 ~                                    cp      d                       ; if both points are the same then no line (we will ignore single pixel as it can't happen at this stage other than tips of circles)
 116+ C1B9 ~                                    IfResultZeroGoto .NoLineDraw
 117+ C1B9 ~                                    ld      a,d                     ; get right col back
 118+ C1B9 ~                                    sub     c                       ; subtract left so a = length
 119+ C1B9 ~                                    inc     a                       ; so its at least 1 , TODO add cp jr c logic in dma routine so that it does non dma if line < x
 120+ C1B9 ~                                    call    z, .FixWidth
 121+ C1B9 ~                                    ld      d,a                     ; de = length (e - d)
 122+ C1B9 ~                                    ld      e,216                   ; yellow
 123+ C1B9 ~                                    call    l2_draw_horz_dma        ; draw without bank switch
 124+ C1B9 ~            .NoLineDraw:            pop     hl,,bc
 125+ C1B9 ~                                    inc     b
 126+ C1B9 ~                                    dec     iyh
 127+ C1B9 ~                                    IfResultNotZeroGoto  .drawLoop
 128+ C1B9                                      ENDM
 129+ C1B9
 130+ C1B9
 131+ C1B9
 132+ C1B9              SunDraw:                MMUSelectLayer2
 132+ C1B9 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 133+ C1BD 3A 26 C5     .OptimiseStartPos:      ld      a,(MinYOffset)
 134+ C1C0                                      JumpIfAIsZero .OffsetIsZero     ; if offset is 0 then just initate as normal
 134+ C1C0 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 134+ C1C1 CA D1 C1    >                        jp	z, .OffsetIsZero
 135+ C1C4                                      JumpIfALTNusng 64, .OffsetLT64  ; if offset >=64 then we adjust and mve to bank 0
 135+ C1C4 FE 40       >                        cp      64
 135+ C1C6 DA DE C1    >                        jp		c, .OffsetLT64
 136+ C1C9 D6 40        .OffsetGTE64:           sub     64
 137+ C1CB 32 26 C5                             ld      (MinYOffset),a          ; adjust offset for bank 2
 138+ C1CE C3 16 C2                             jp      .StartBank2
 139+ C1D1 06 00        .OffsetIsZero:          ld      b,0                     ; row
 140+ C1D3 FD 26 40                             ld      iyh,64                  ; counter
 141+ C1D6 21 9F C0                             ld      hl,SBnKLineArray        ; set hl to start of array
 142+ C1D9 C3 F0 C1                             jp      .StartBank1
 143+ C1DC              ;-- Snuck routine in here so that the macro will be happier
 144+ C1DC 3D           .FixWidth:              dec     a                       ; if carry resulted in a value of zero then correct
 145+ C1DD C9                                   ret
 146+ C1DE 21 9F C0     .OffsetLT64:            ld      hl,SBnKLineArray        ; adjust hl for line array offset
 147+ C1E1 ED 31                                add     hl,a                    ; .
 148+ C1E3 ED 31                                add     hl,a                    ; .
 149+ C1E5 47                                   ld      b,a                     ; set b row to the actual offset
 150+ C1E6 4F                                   ld      c,a                     ; iyh = 64 - Y offset
 151+ C1E7 3E 40                                ld      a,64                    ; .
 152+ C1E9 91                                   sub     c                       ; .
 153+ C1EA FD 67                                ld      iyh,a
 154+ C1EC AF                                   xor     a                       ; Ready bank 2 with no offset
 155+ C1ED 32 26 C5                             ld      (MinYOffset),a          ; .
 156+ C1F0 D9           .StartBank1:            exx
 157+ C1F1 3E 00                                ld      a,LAYER2_SHIFTED_SCREEN_TOP
 158+ C1F3 CD 37 E0                             call    asm_l2_bank_select      ; get in the first bank, we will only then bank select when needed
 159+ C1F6 D9                                   exx
 160+ C1F7                                      SunBankDraw
 160+ C1F7 7E          >.drawLoop               ld      a,(hl)
 160+ C1F8 4F          >                        ld      c,a                     ; c = left column
 160+ C1F9 23          >                        inc     hl
 160+ C1FA 56          >                        ld      d,(hl)                  ; d = right col
 160+ C1FB 23          >                        inc     hl                      ; now ready for next linel
 160+ C1FC E5 C5       >                        push    hl,,bc
 160+ C1FE BA          >                        cp      d                       ; if both points are the same then no line (we will ignore single pixel as it can't happen at this stage other than tips of circles)
 160+ C1FF             >                        IfResultZeroGoto .NoLineDraw
 160+ C1FF CA 0E C2    >                        jp	z,.NoLineDraw
 160+ C202 7A          >                        ld      a,d                     ; get right col back
 160+ C203 91          >                        sub     c                       ; subtract left so a = length
 160+ C204 3C          >                        inc     a                       ; so its at least 1 , TODO add cp jr c logic in dma routine so that it does non dma if line < x
 160+ C205 CC DC C1    >                        call    z, .FixWidth
 160+ C208 57          >                        ld      d,a                     ; de = length (e - d)
 160+ C209 1E D8       >                        ld      e,216                   ; yellow
 160+ C20B CD 64 E2    >                        call    l2_draw_horz_dma        ; draw without bank switch
 160+ C20E C1 E1       >.NoLineDraw:            pop     hl,,bc
 160+ C210 04          >                        inc     b
 160+ C211 FD 25       >                        dec     iyh
 160+ C213             >                        IfResultNotZeroGoto  .drawLoop
 160+ C213 C2 F7 C1    >                        jp	nz,.drawLoop
 161+ C216 3A 26 C5     .StartBank2:            ld      a,(MinYOffset)
 162+ C219                                      JumpIfAIsZero .OffsetBank2IsZero; if offset is 0 then we just continue, offset can never be >127 else there would be no draw
 162+ C219 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 162+ C21A CA 2E C2    >                        jp	z, .OffsetBank2IsZero
 163+ C21D 21 1F C1     .NotZeroOffset:         ld      hl,SBnKLineArray + (64 * 2); adjust to correct offset
 164+ C220 ED 31                                add     hl,a
 165+ C222 ED 31                                add     hl,a
 166+ C224 4F                                   ld      c,a                     ; iyh = 64 - offset
 167+ C225 3E 40                                ld      a,64                    ; .
 168+ C227 91                                   sub     c                       ; .
 169+ C228 FD 67                                ld      iyh,a                   ; .
 170+ C22A 41                                   ld      b,c                     ; b = offset row
 171+ C22B C3 36 C2                             jp      .drawLineBank2
 172+ C22E 21 1F C1     .OffsetBank2IsZero:     ld      hl,SBnKLineArray + (64 * 2); start with offset adjusted
 173+ C231 06 00                                ld      b,0
 174+ C233 FD 26 40                             ld      iyh,64
 175+ C236 D9           .drawLineBank2:         exx
 176+ C237 3E 40                                ld      a,LAYER2_SHIFTED_SCREEN_MIDDLE
 177+ C239 CD 37 E0                             call    asm_l2_bank_select      ; now do the lower bank
 178+ C23C D9                                   exx
 179+ C23D              ; Could make this a sub routine but unwrapping saves a call
 180+ C23D                                      SunBankDraw
 180+ C23D 7E          >.drawLoop               ld      a,(hl)
 180+ C23E 4F          >                        ld      c,a                     ; c = left column
 180+ C23F 23          >                        inc     hl
 180+ C240 56          >                        ld      d,(hl)                  ; d = right col
 180+ C241 23          >                        inc     hl                      ; now ready for next linel
 180+ C242 E5 C5       >                        push    hl,,bc
 180+ C244 BA          >                        cp      d                       ; if both points are the same then no line (we will ignore single pixel as it can't happen at this stage other than tips of circles)
 180+ C245             >                        IfResultZeroGoto .NoLineDraw
 180+ C245 CA 54 C2    >                        jp	z,.NoLineDraw
 180+ C248 7A          >                        ld      a,d                     ; get right col back
 180+ C249 91          >                        sub     c                       ; subtract left so a = length
 180+ C24A 3C          >                        inc     a                       ; so its at least 1 , TODO add cp jr c logic in dma routine so that it does non dma if line < x
 180+ C24B CC DC C1    >                        call    z, .FixWidth
 180+ C24E 57          >                        ld      d,a                     ; de = length (e - d)
 180+ C24F 1E D8       >                        ld      e,216                   ; yellow
 180+ C251 CD 64 E2    >                        call    l2_draw_horz_dma        ; draw without bank switch
 180+ C254 C1 E1       >.NoLineDraw:            pop     hl,,bc
 180+ C256 04          >                        inc     b
 180+ C257 FD 25       >                        dec     iyh
 180+ C259             >                        IfResultNotZeroGoto  .drawLoop
 180+ C259 C2 3D C2    >                        jp	nz,.drawLoop
 181+ C25C C9                                   ret
 182+ C25D
 183+ C25D              ; --------------------------------------------------------------
 184+ C25D              ; This sets current universe object to a star / sun, they use sign + 23 bit positions
 185+ C25D CD A1 C1     CreateSun:              call    ResetSBnKData
 186+ C260 3A 06 85                             ld      a,(WorkingSeeds+3)
 187+ C263 E6 07                                and     %00000111
 188+ C265 F6 81                                or      %10000001
 189+ C267 32 18 C0                             ld      (SBnKzsgn),a
 190+ C26A 3A 08 85                             ld      a,(WorkingSeeds+5)
 191+ C26D E6 03                                and     %00000011
 192+ C26F 32 12 C0                             ld      (SBnKxsgn),a
 193+ C272 32 15 C0                             ld      (SBnKysgn),a
 194+ C275                                   ; DEBUG   ld      hl, $0000
 195+ C275                                   ; DEBUG   ld      (SBnKzhi),hl
 196+ C275                                   ; DEBUG   ld      a, $E3
 197+ C275                                   ; DEBUG   ld      (SBnKzlo),a
 198+ C275 C9                                   ret
 199+ C276              ; --------------------------------------------------------------
 200+ C276              ; This sets current universe object to a planet,they use sign + 23 bit positions
 201+ C276              ;;TODOCreatePlanet:           call    ResetSBnKData
 202+ C276              ;;TODO                        ld      a,(DisplayTekLevel)
 203+ C276              ;;TODO                        and     $00000010               ; Set A = 128 or 130 depending on bit 1 of the system's tech level
 204+ C276              ;;TODO                        or      $10000000
 205+ C276              ;;TODO                        ld      (SBnKShipType),a
 206+ C276              ;;TODO                        xor     a
 207+ C276              ;;TODO                        ld      (SBnKaiatkecm),a
 208+ C276              ;;TODO                        MaxUnivPitchAndRoll
 209+ C276              ;;TODO                        ld      a,(WorkingSeeds+1)      ; a= bits 1 and 0 of working seed1 + 3 + carry
 210+ C276              ;;TODO                        and     %00000011               ; .
 211+ C276              ;;TODO                        adc     3                       ; .
 212+ C276              ;;TODO                        ld      (SBnKzsgn),a            ; set z sign to 3 + C + 0..3 bits
 213+ C276              ;;TODO                        rr      a
 214+ C276              ;;TODO                        ld      (PlanetXsgn),a
 215+ C276              ;;TODO                        ld      (PlanetYsgn),a
 216+ C276              ;;TODO                        ret
 217+ C276
 218+ C276
 219+ C276                                 ;     include "./Maths/ADDHLDESignBC.asm"
 220+ C276
 221+ C276 7C           SunADDHLDESignedv3:     ld      a,h
 222+ C277 E6 80                                and     SignOnly8Bit
 223+ C279 47                                   ld      b,a                         ;save sign bit in b
 224+ C27A AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
 225+ C27B                                      JumpIfNegative .SunADDHLDEOppSGN    ;Signs are opposite there fore we can subtract to get difference
 225+ C27B FA 96 C2    >                        jp		m, .SunADDHLDEOppSGN
 226+ C27E 78           .SunADDHLDESameSigns:   ld      a,b
 227+ C27F B2                                   or      d
 228+ C280                                      JumpIfNegative .SunADDHLDESameNeg   ; optimisation so we can just do simple add if both positive
 228+ C280 FA 88 C2    >                        jp		m, .SunADDHLDESameNeg
 229+ C283                                      JumpIfNegative .SunADDHLDESameNeg   ; optimisation so we can just do simple add if both positive
 229+ C283 FA 88 C2    >                        jp		m, .SunADDHLDESameNeg
 230+ C286 19                                   add     hl,de
 231+ C287 C9                                   ret
 232+ C288 7C           .SunADDHLDESameNeg:     ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 233+ C289 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 234+ C28B 67                                   ld      h,a
 235+ C28C 7A                                   ld      a,d
 236+ C28D E6 7F                                and     SignMask8Bit
 237+ C28F 57                                   ld      d,a
 238+ C290 19                                   add     hl,de
 239+ C291 3E 80                                ld      a,SignOnly8Bit
 240+ C293 B4                                   or      h                           ; now set bit for negative value, we won't bother with overflow for now TODO
 241+ C294 67                                   ld      h,a
 242+ C295 C9                                   ret
 243+ C296 7C           .SunADDHLDEOppSGN:      ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit                     ; here HL and DE are opposite
 244+ C297 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 245+ C299 67                                   ld      h,a
 246+ C29A 7A                                   ld      a,d
 247+ C29B E6 7F                                and     SignMask8Bit
 248+ C29D 57                                   ld      d,a
 249+ C29E B7                                   or      a
 250+ C29F ED 52                                sbc     hl,de
 251+ C2A1 38 04                                jr      c,.SunADDHLDEOppInvert
 252+ C2A3 78           .SunADDHLDEOppSGNNoCarry:   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
 253+ C2A4 B4                                   or      h
 254+ C2A5 67                                   ld      h,a                         ; set the previou sign value
 255+ C2A6 C9                                   ret
 256+ C2A7              .SunADDHLDEOppInvert:       NegHL                                                   ; we need to flip the sign and 2'c the Hl result
 256+ C2A7 AF          >                    xor a
 256+ C2A8 95          >                    sub l
 256+ C2A9 6F          >                    ld l,a
 256+ C2AA 9F          >                    sbc a,a
 256+ C2AB 94          >                    sub h
 256+ C2AC 67          >                    ld h,a
 257+ C2AD 78                                   ld      a,b
 258+ C2AE EE 80                                xor     SignOnly8Bit                ; flip sign bit
 259+ C2B0 B4                                   or      h
 260+ C2B1 67                                   ld      h,a                         ; recover sign
 261+ C2B2 C9                                   ret
 262+ C2B3
 263+ C2B3              ; we could cheat, flip the sign of DE and just add but its not very optimised
 264+ C2B3 7C           .SunSUBHLDESignedv3:        ld      a,h
 265+ C2B4 E6 80                                and     SignOnly8Bit
 266+ C2B6 47                                   ld      b,a                         ;save sign bit in b
 267+ C2B7 AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
 268+ C2B8                                      JumpIfNegative .SunSUBHLDEOppSGN        ;Signs are opposite therefore we can add
 268+ C2B8 FA E6 C2    >                        jp		m, .SunSUBHLDEOppSGN
 269+ C2BB 78           .SunSUBHLDESameSigns:       ld      a,b
 270+ C2BC B2                                   or      d
 271+ C2BD                                      JumpIfNegative .SunSUBHLDESameNeg       ; optimisation so we can just do simple add if both positive
 271+ C2BD FA C7 C2    >                        jp		m, .SunSUBHLDESameNeg
 272+ C2C0 B7                                   or      a
 273+ C2C1 ED 52                                sbc     hl,de
 274+ C2C3                                      JumpIfNegative .SunSUBHLDESameOvrFlw
 274+ C2C3 FA DA C2    >                        jp		m, .SunSUBHLDESameOvrFlw
 275+ C2C6 C9                                   ret
 276+ C2C7 7C           .SunSUBHLDESameNeg:         ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 277+ C2C8 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 278+ C2CA 67                                   ld      h,a
 279+ C2CB 7A                                   ld      a,d
 280+ C2CC E6 7F                                and     SignMask8Bit
 281+ C2CE 57                                   ld      d,a
 282+ C2CF B7                                   or      a
 283+ C2D0 ED 52                                sbc     hl,de
 284+ C2D2                                      JumpIfNegative .SunSUBHLDESameOvrFlw
 284+ C2D2 FA DA C2    >                        jp		m, .SunSUBHLDESameOvrFlw
 285+ C2D5 7C                                   ld      a,h                         ; now set bit for negative value, we won't bother with overflow for now TODO
 286+ C2D6 F6 80                                or      SignOnly8Bit
 287+ C2D8 67                                   ld      h,a
 288+ C2D9 C9                                   ret
 289+ C2DA              .SunSUBHLDESameOvrFlw:      NegHL                                                        ; we need to flip the sign and 2'c the Hl result
 289+ C2DA AF          >                    xor a
 289+ C2DB 95          >                    sub l
 289+ C2DC 6F          >                    ld l,a
 289+ C2DD 9F          >                    sbc a,a
 289+ C2DE 94          >                    sub h
 289+ C2DF 67          >                    ld h,a
 290+ C2E0 78                                   ld      a,b
 291+ C2E1 EE 80                                xor     SignOnly8Bit                ; flip sign bit
 292+ C2E3 B4                                   or      h
 293+ C2E4 67                                   ld      h,a                         ; recover sign
 294+ C2E5 C9                                   ret
 295+ C2E6 B7           .SunSUBHLDEOppSGN:          or      a                                               ; here HL and DE are opposite so we can add the values
 296+ C2E7 7C                                   ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 297+ C2E8 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 298+ C2EA 67                                   ld      h,a
 299+ C2EB 7A                                   ld      a,d
 300+ C2EC E6 7F                                and     SignMask8Bit
 301+ C2EE 57                                   ld      d,a
 302+ C2EF 19                                   add     hl,de
 303+ C2F0 78                                   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
 304+ C2F1 B4                                   or      h
 305+ C2F2 67                                   ld      h,a                         ; set the previou sign value
 306+ C2F3 C9                                   ret
 307+ C2F4
 308+ C2F4
 309+ C2F4              .SunSBCHLDESigned:      JumpOnBitSet h,7,.SunSBCHLDEhlNeg
 309+ C2F4 CB 7C       >                        bit 	7,h
 309+ C2F6 C2 07 C3    >                        jp      nz,.SunSBCHLDEhlNeg
 310+ C2F9              .SunSBCHLDEhlPos:       JumpOnBitSet h,7,.SunSBCHLDEhlNeg
 310+ C2F9 CB 7C       >                        bit 	7,h
 310+ C2FB C2 07 C3    >                        jp      nz,.SunSBCHLDEhlNeg
 311+ C2FE ED 52        .SunSBCHLDEhlPosDePos:  sbc     hl,de                           ; ignore overflow for now will sort later TODO
 312+ C300 C9                                   ret
 313+ C301 CB BA        .SunSBCHLDEhlPosDeNeg:  res     7,d
 314+ C303 19                                   add     hl,de                           ; ignore overflow for now will sort later TODO
 315+ C304 CB FA                                set     7,d
 316+ C306 C9                                   ret
 317+ C307 CB BC        .SunSBCHLDEhlNeg:       res     7,h
 318+ C309                                      JumpOnBitSet d,7,.SunSBCHLDEhlNegdeNeg
 318+ C309 CB 7A       >                        bit 	7,d
 318+ C30B C2 13 C3    >                        jp      nz,.SunSBCHLDEhlNegdeNeg
 319+ C30E ED 52        .SunSBCHLDEhlNegdePos:  sbc     hl,de                       ; ignore overflow for now will sort later TODO
 320+ C310 CB FC                                set     7,h
 321+ C312 C9                                   ret
 322+ C313 CB BA        .SunSBCHLDEhlNegdeNeg:      res     7,d
 323+ C315 19                                   add     hl,de                   ; ignore overflow for now will sort later TODO
 324+ C316 CB FA                                set     7,d
 325+ C318 CB FC                                set     7,h
 326+ C31A C9                                   ret
 327+ C31B
 328+ C31B
 329+ C31B
 330+ C31B              ;                    include "Universe/InitialiseOrientation.asm"
 331+ C31B              ;----------------------------------------------------------------------------------------------------------------------------------
 332+ C31B              ;;;
 333+ C31B              ;;;Project:
 334+ C31B              ;;;PROJ:                   ld      hl,(SBnKxlo)                    ; Project K+INWK(x,y)/z to K3,K4 for center to screen
 335+ C31B              ;;;                        ld      (varP),hl
 336+ C31B              ;;;                        ld      a,(SBnKxsgn)
 337+ C31B              ;;;                        call    PLS6                            ; returns result in K (0 1) (unsigned) and K (3) = sign note to no longer does 2's C
 338+ C31B              ;;;                        ret     c                               ; carry means don't print
 339+ C31B              ;;;                        ld      hl,(varK)                       ; hl = k (0 1)
 340+ C31B              ;;;                        ; Now the question is as hl is the fractional part, should this be multiplied by 127 to get the actual range
 341+ C31B              ;;;                        ld      a,ViewCenterX
 342+ C31B              ;;;                        add     hl,a                            ; add unsigned a to the 2's C HL to get pixel position
 343+ C31B              ;;;                        ld      (varK3),hl                      ; K3 = X position on screen
 344+ C31B              ;;;ProjectY:               ld      hl,(SBnKylo)
 345+ C31B              ;;;                        ld      (varP),hl
 346+ C31B              ;;;                        ld      a,(SBnKysgn)
 347+ C31B              ;;;                        call    PLS6
 348+ C31B              ;;;                        ret     c
 349+ C31B              ;;;                        ld      hl,(varK)                       ; hl = k (0 1)
 350+ C31B              ;;;                        ld      a,ViewCenterY
 351+ C31B              ;;;                        add     hl,a                            ; add unsigned a to the 2's C HL to get pixel position
 352+ C31B              ;;;                        ld      (varK4),hl                      ; K3 = X position on screen
 353+ C31B              ;;;                        ret
 354+ C31B              ;--------------------------------------------------------------------------------------------------------
 355+ C31B              ;                        include "./ModelRender/EraseOldLines-EE51.asm"
 356+ C31B              ;                        include "./ModelRender/TrimToScreenGrad-LL118.asm"
 357+ C31B              ;                        include "./ModelRender/CLIP-LL145.asm"
 358+ C31B              ;--------------------------------------------------------------------------------------------------------
 359+ C31B              ;                        include "./Variables/CopyRotmatToTransMat.asm"
 360+ C31B                                      include "../Universe/Sun/TransposeSunXX12BySunToSunXX15.asm"
# file opened: ./../Universe/Sun/TransposeSunXX12BySunToSunXX15.asm
   1++C31B              TransposeSXX12BySunToSXX15:
   2++C31B 2A 7A C0                             ld		hl,(SBnKXX12xLo)					; get X into HL
   3++C31E 7C                                   ld		a,h			                        ; get XX12 Sign
   4++C31F E6 80                                and		$80									; check sign bit on high byte
   5++C321 47                                   ld		b,a									; and put it in of 12xlo in b
   6++C322                                      ;110921 debugld      h,0
   7++C322 7C                                   ld      a,h
   8++C323 E6 7F                                and     $7F
   9++C325 67                                   ld      h,a
  10++C326                                      ;110921 debugld      h,0
  11++C326 ED 5B 10 C0                          ld		de,(SBnKxlo)						;
  12++C32A 3A 12 C0                             ld		a,(SBnKxsgn)						; get Ship Pos (low,high,sign)
  13++C32D E6 80                                and		$80									; make sure we only have bit 7
  14++C32F 4F                                   ld		c,a									; and put sign of unkxsgn c
  15++C330 CD ED 9A                             call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC		; this will result in HL = result and A = sign
  16++C333 B4                                   or		h									; combine sign in A with H to give 15 bit signed (*NOT* 2's c)
  17++C334 67                                   ld		h,a
  18++C335 22 74 C0                             ld		(SBnKXScaled),hl					; now write it out to XX15 X pos
  19++C338              ; ..................................
  20++C338 2A 7C C0                             ld		hl,(SBnKXX12yLo)					; Repeat above for Y coordinate
  21++C33B 7C                                   ld		a,h
  22++C33C E6 80                                and		$80
  23++C33E 47                                   ld		b,a
  24++C33F                                      ;110921 debugld      h,0
  25++C33F 7C                                   ld      a,h
  26++C340 E6 7F                                and     $7F
  27++C342 67                                   ld      h,a
  28++C343                                      ;110921 debugld      h,0
  29++C343 ED 5B 13 C0                          ld		de,(SBnKylo)
  30++C347 3A 15 C0                             ld		a,(SBnKysgn)
  31++C34A E6 80                                and		$80									; make sure we only have bit 7
  32++C34C 4F                                   ld		c,a
  33++C34D CD ED 9A                             call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC
  34++C350 B4                                   or		h									; combine sign in A with H
  35++C351 67                                   ld		h,a
  36++C352 22 76 C0                             ld		(SBnKYScaled),hl
  37++C355              ; ..................................
  38++C355 2A 7E C0                             ld		hl,(SBnKXX12zLo)					; and now repeat for Z cooord
  39++C358 7C                                   ld		a,h
  40++C359 E6 80                                and		$80
  41++C35B 47                                   ld		b,a
  42++C35C                                      ;110921 debugld      h,0
  43++C35C 7C                                   ld      a,h
  44++C35D E6 7F                                and     $7F
  45++C35F 67                                   ld      h,a
  46++C360                                      ;110921 debugld      h,0
  47++C360 ED 5B 16 C0                          ld		de,(SBnKzlo)
  48++C364 3A 18 C0                             ld		a,(SBnKzsgn)
  49++C367 E6 80                                and		$80									; make sure we only have bit 7
  50++C369 4F                                   ld		c,a
  51++C36A CD ED 9A                             call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC
  52++C36D B4                                   or		h									; combine sign in A with H
  53++C36E 67                                   ld		h,a
  54++C36F CB 7C                                bit		7,h                                 ; if sign if positive then we don't need to do the clamp so we ony jump
  55++C371 20 16                                jr		nz,.ClampZto4                        ; result was negative so we need to clamp to 4
  56++C373 E6 7F                                and     $7F                                 ; a = value unsigned
  57++C375 20 06                                jr      nz,.NoClampZto4                      ; if high byte was 0 then we could need to clamp still by this stage its +v but and will set z flag if high byte is zero
  58++C377 7D                                   ld      a,l                                 ; get low byte now
  59++C378                                      JumpIfALTNusng 4,.ClampZto4					; if its < 4 then fix at 4
  59++C378 FE 04       >                        cp      4
  59++C37A DA 89 C3    >                        jp		c, .ClampZto4
  60++C37D 22 78 C0     .NoClampZto4:           ld		(SBnKZScaled),hl					; hl = signed calculation and > 4
  61++C380 7D                                   ld		a,l									; in addition write out the z cooord to UT for now for backwards compat (DEBUG TODO remove later)
  62++C381 32 29 84                             ld      (varT),a
  63++C384 7C                                   ld		a,h
  64++C385 32 0C 84                             ld      (varU),a
  65++C388 C9                                   ret
  66++C389              ; This is where we limit 4 to a minimum of 4
  67++C389 21 04 00     .ClampZto4:             ld		hl,4
  68++C38C 22 78 C0                             ld		(SBnKZScaled),hl; BODGE FOR NOW
  69++C38F 7D                                   ld		a,l
  70++C390 32 29 84                             ld      (varT),a                            ;                                                                           ;;;
  71++C393 7C                                   ld		a,h
  72++C394 32 0C 84                             ld      (varU),a 						; compatibility for now
  73++C397 C9                                   ret
  74++C398
# file closed: ./../Universe/Sun/TransposeSunXX12BySunToSunXX15.asm
 361+ C398
 362+ C398
 363+ C398 ED 4B 78 C0  ScaleSunTo8Bit:			ld			bc,(SBnKZScaled)
 364+ C39C 2A 74 C0                             ld			hl,(SBnKXScaled)
 365+ C39F ED 5B 76 C0                          ld			de,(SBnKYScaled)
 366+ C3A3 78           .SetABSbc:              ld			a,b
 367+ C3A4 DD 67                                ld			ixh,a
 368+ C3A6 E6 7F                                and			SignMask8Bit
 369+ C3A8 47                                   ld			b,a									; bc = ABS bc
 370+ C3A9 7C           .SetABShl:              ld			a,h
 371+ C3AA DD 6F                                ld			ixl,a
 372+ C3AC E6 7F                                and			SignMask8Bit
 373+ C3AE 67                                   ld			h,a									; hl = ABS hl
 374+ C3AF 7A           .SetABSde:              ld			a,d
 375+ C3B0 FD 67                                ld			iyh,a
 376+ C3B2 E6 7F                                and			SignMask8Bit
 377+ C3B4 57                                   ld			d,a									; de = ABS de
 378+ C3B5 78           .ScaleNodeTo8BitLoop:   ld          a,b		                            ; U	\ z hi
 379+ C3B6 B4                                   or			h                                   ; XX15+1	\ x hi
 380+ C3B7 B2                                   or			d                                   ; XX15+4	\ y hi
 381+ C3B8 28 0F                                jr          z,.ScaleNodeDone                   ; if X, Y, Z = 0  exit loop down once hi U rolled to 0
 382+ C3BA                                      ShiftHLRight1
 382+ C3BA CB 3C       >			   srl h
 382+ C3BC CB 1D       >			   rr  l
 383+ C3BE                                      ShiftDERight1
 383+ C3BE CB 3A       >			   srl d
 383+ C3C0 CB 1B       >			   rr  e
 384+ C3C2                                      ShiftBCRight1
 384+ C3C2 CB 38       >			   srl b
 384+ C3C4 CB 19       >			   rr  c
 385+ C3C6 C3 B5 C3                             jp          .ScaleNodeTo8BitLoop
 386+ C3C9              ; now we have scaled values we have to deal with sign
 387+ C3C9 DD 7C        .ScaleNodeDone:          ld			a,ixh								; get sign bit and or with b
 388+ C3CB E6 80                                and			SignOnly8Bit
 389+ C3CD B0                                   or			b
 390+ C3CE 47                                   ld			b,a
 391+ C3CF DD 7D        .SignforHL:              ld			a,ixl								; get sign bit and or with b
 392+ C3D1 E6 80                                and			SignOnly8Bit
 393+ C3D3 B4                                   or			h
 394+ C3D4 67                                   ld			h,a
 395+ C3D5 FD 7C        .SignforDE:              ld			a,iyh								; get sign bit and or with b
 396+ C3D7 E6 80                                and			SignOnly8Bit
 397+ C3D9 B2                                   or			d
 398+ C3DA 57                                   ld			d,a
 399+ C3DB ED 43 78 C0  .SignsDoneSaveResult:	ld			(SBnKZScaled),bc
 400+ C3DF 22 74 C0                             ld			(SBnKXScaled),hl
 401+ C3E2 ED 53 76 C0                          ld			(SBnKYScaled),de
 402+ C3E6 78                                   ld			a,b
 403+ C3E7 32 0C 84                             ld			(varU),a
 404+ C3EA 79                                   ld			a,c
 405+ C3EB 32 29 84                             ld			(varT),a
 406+ C3EE C9                                   ret
 407+ C3EF
 408+ C3EF              ;--------------------------------------------------------------------------------------------------------
 409+ C3EF              ;;;;X = normal scale
 410+ C3EF              ;;;;ZtempHi = zhi
 411+ C3EF              ;;;;......................................................
 412+ C3EF              ;;;; if ztemp hi <> 0                                   ::Scale Object Distance
 413+ C3EF              ;;;;  Loop                                              ::LL90
 414+ C3EF              ;;;;     inc X
 415+ C3EF              ;;;;     divide X, Y & ZtempHiLo by 2
 416+ C3EF              ;;;;  Until ZtempHi = 0
 417+ C3EF              ;;;;......................................................
 418+ C3EF              ;-LL21---------------------------------------------------------------------------------------------------
 419+ C3EF              ;                        include "./Universe/NormaliseTransMat.asm"
 420+ C3EF              ;-LL91---------------------------------------------------------------------------------------------------
 421+ C3EF
 422+ C3EF              ; Now we have
 423+ C3EF              ;   * XX18(2 1 0) = (x_sign x_hi x_lo)
 424+ C3EF              ;   * XX18(5 4 3) = (y_sign y_hi y_lo)
 425+ C3EF              ;   * XX18(8 7 6) = (z_sign z_hi z_lo)
 426+ C3EF              ;
 427+ C3EF              ;--------------------------------------------------------------------------------------------------------
 428+ C3EF              ;--------------------------------------------------------------------------------------------------------
 429+ C3EF              ;   XX12(1 0) = [x y z] . sidev  = (dot_sidev_sign dot_sidev_lo)  = dot_sidev
 430+ C3EF              ;   XX12(3 2) = [x y z] . roofv  = (dot_roofv_sign dot_roofv_lo)  = dot_roofv
 431+ C3EF              ;   XX12(5 4) = [x y z] . nosev  = (dot_nosev_sign dot_nosev_lo)  = dot_nosev
 432+ C3EF              ; Returns
 433+ C3EF              ;
 434+ C3EF              ;   XX12(1 0)            The dot product of [x y z] vector with the sidev (or _x)
 435+ C3EF              ;                        vector, with the sign in XX12+1 and magnitude in XX12
 436+ C3EF              ;
 437+ C3EF              ;   XX12(3 2)            The dot product of [x y z] vector with the roofv (or _y)
 438+ C3EF              ;                        vector, with the sign in XX12+3 and magnitude in XX12+2
 439+ C3EF              ;
 440+ C3EF              ;   XX12(5 4)            The dot product of [x y z] vector with the nosev (or _z)
 441+ C3EF              ;                        vector, with the sign in XX12+5 and magnitude in XX12+4
 442+ C3EF
 443+ C3EF
 444+ C3EF               ; TESTEDOK
 445+ C3EF              SXX12DotOneRow:
sun_data.asm(446): error: Unrecognized instruction: N0equN1byN2div256 varT, (hl), (SBnKXScaled)
 446+ C3EF              SXX12CalcX:              N0equN1byN2div256 varT, (hl), (SBnKXScaled)       ; T = (hl) * regSunXX15fx /256
 447+ C3EF 23                                   inc     hl                                  ; move to sign byte
sun_data.asm(448): error: Unrecognized instruction: AequN1xorN2 SBnKXScaledSign,(hl)
 448+ C3F0              SXX12CalcXSign:          AequN1xorN2 SBnKXScaledSign,(hl)             ;
 449+ C3F0 32 0F 84                             ld      (varS),a                            ; Set S to the sign of x_sign * sidev_x
 450+ C3F3 23                                   inc     hl
sun_data.asm(451): error: Unrecognized instruction: N0equN1byN2div256 varQ, (hl),(SBnKYScaled)
 451+ C3F4              SXX12CalcY:              N0equN1byN2div256 varQ, (hl),(SBnKYScaled)       ; Q = XX16 * SunXX15 /256 using varQ to hold regSunXX15fx
 452+ C3F4                                      ldCopyByte varT,varR                        ; R = T =  |sidev_x| * x_lo / 256
 452+ C3F4 3A 29 84    >                        ld       a,(varT)
 452+ C3F7 32 0E 84    >                        ld       (varR),a
 453+ C3FA 23                                   inc     hl
sun_data.asm(454): error: Unrecognized instruction: AequN1xorN2 SBnKYScaledSign,(hl)
 454+ C3FB                                      AequN1xorN2 SBnKYScaledSign,(hl)             ; Set A to the sign of y_sign * sidev_y
 455+ C3FB              ; (S)A = |sidev_x| * x_lo / 256  = |sidev_x| * x_lo + |sidev_y| * y_lo
 456+ C3FB E5           SSTequSRplusAQ           push    hl
 457+ C3FC CD 0B 9C                             call    baddll38                            ; JSR &4812 \ LL38   \ BADD(S)A=R+Q(SA) \ 1byte add (subtract)
 458+ C3FF E1                                   pop     hl
 459+ C400 32 29 84                             ld      (varT),a                            ; T = |sidev_x| * x_lo + |sidev_y| * y_lo
 460+ C403 23                                   inc     hl
sun_data.asm(461): error: Unrecognized instruction: N0equN1byN2div256 varQ,(hl),(SBnKZScaled)
 461+ C404              SXX12CalcZ:              N0equN1byN2div256 varQ,(hl),(SBnKZScaled)       ; Q = |sidev_z| * z_lo / 256
 462+ C404                                      ldCopyByte varT,varR                        ; R = |sidev_x| * x_lo + |sidev_y| * y_lo
 462+ C404 3A 29 84    >                        ld       a,(varT)
 462+ C407 32 0E 84    >                        ld       (varR),a
 463+ C40A 23                                   inc     hl
sun_data.asm(464): error: Unrecognized instruction: AequN1xorN2 SBnKZScaledSign,(hl)
 464+ C40B                                      AequN1xorN2 SBnKZScaledSign,(hl)             ; A = sign of z_sign * sidev_z
 465+ C40B              ; (S)A= |sidev_x| * x_lo + |sidev_y| * y_lo + |sidev_z| * z_lo
 466+ C40B CD 0B 9C                             call    baddll38                            ; JSR &4812 \ LL38   \ BADD(S)A=R+Q(SA)   \ 1byte add (subtract)
 467+ C40E              ; Now we exit with A = result S = Sign
 468+ C40E C9                                   ret
 469+ C40F
 470+ C40F
 471+ C40F
 472+ C40F              ;--------------------------------------------------------------------------------------------------------
 473+ C40F                                      include "../Universe/Sun/CopySunXX12ScaledToSunXX18.asm"
# file opened: ./../Universe/Sun/CopySunXX12ScaledToSunXX18.asm
   1++C40F              CopySXX12ScaledToSXX18:
   2++C40F              CopyResultToSDrawCam:
   3++C40F                      ldCopyByte SXX12         ,SXX18             ; XX12+0 => XX18+0  Set XX18(2 0) = dot_sidev
   3++C40F 3A 7A C0    >                        ld       a,(SXX12)
   3++C412 32 68 C0    >                        ld       (SXX18),a
   4++C415                      ldCopyByte SXX12+1       ,SXX18+2           ; XX12+1 => XX18+2
   4++C415 3A 7B C0    >                        ld       a,(SXX12+1)
   4++C418 32 6A C0    >                        ld       (SXX18+2),a
   5++C41B                      ldCopyByte SXX12+2       ,SXX18+3           ; XX12+2 => XX18+3  Set XX12+1 => XX18+2
   5++C41B 3A 7C C0    >                        ld       a,(SXX12+2)
   5++C41E 32 6B C0    >                        ld       (SXX18+3),a
   6++C421                      ldCopyByte SXX12+3       ,SXX18+5           ; XX12+3 => XX18+5
   6++C421 3A 7D C0    >                        ld       a,(SXX12+3)
   6++C424 32 6D C0    >                        ld       (SXX18+5),a
   7++C427                      ldCopyByte SXX12+4       ,SXX18+6           ; XX12+4 => XX18+6  Set XX18(8 6) = dot_nosev
   7++C427 3A 7E C0    >                        ld       a,(SXX12+4)
   7++C42A 32 6E C0    >                        ld       (SXX18+6),a
   8++C42D                      ldCopyByte SXX12+5       ,SXX18+8           ; XX12+5 => XX18+8
   8++C42D 3A 7F C0    >                        ld       a,(SXX12+5)
   8++C430 32 70 C0    >                        ld       (SXX18+8),a
   9++C433 C9                   ret
  10++C434
# file closed: ./../Universe/Sun/CopySunXX12ScaledToSunXX18.asm
 474+ C434              ;                        include "./Variables/CopySunXX12toSunXX15.asm"
 475+ C434              ;                       include "./Variables/CopySunXX18toSunXX15.asm"
 476+ C434              ;                       include "./Variables/CopySunXX18ScaledToSunXX15.asm"
 477+ C434              ;                       include "./Variables/CopySunXX12ToScaled.asm"
 478+ C434              ;--------------------------------------------------------------------------------------------------------
 479+ C434              ;                        include "./Maths/Utilities/DotProductXX12SunXX15.asm"
 480+ C434              ;--------------------------------------------------------------------------------------------------------
 481+ C434
 482+ C434 DD 25        ScaleDownSXX15byIXH:    dec     ixh
 483+ C436 F8                                   ret     m
 484+ C437 21 74 C0                             ld      hl,SBnKXScaled
 485+ C43A CB 3E                                srl     (hl)                        ; SunXX15  \ xnormal lo/2 \ LL93+3 \ counter X
 486+ C43C 23                                   inc     hl                          ; looking at SunXX15 x sign now
 487+ C43D 23                                   inc     hl                          ; looking at SunXX15 y Lo now
 488+ C43E CB 3E                                srl     (hl)                        ; SunXX15+2    \ ynormal lo/2
 489+ C440 23                                   inc     hl                          ; looking at SunXX15 y sign now
 490+ C441 23                                   inc     hl                          ; looking at SunXX15 z Lo now
 491+ C442 CB 3E                                srl     (hl)
 492+ C444 C3 34 C4                             jp      ScaleDownSXX15byIXH
 493+ C447 C9                                   ret
 494+ C448
 495+ C448 21 68 C0     DivideSXX18By2:         ld      hl,SBnKDrawCam0xLo
 496+ C44B CB 3E                                srl     (hl)                        ; XX18  \ xnormal lo/2 \ LL93+3 \ counter X
 497+ C44D 23                                   inc     hl                          ; looking at XX18 x sign now
 498+ C44E 23                                   inc     hl                          ; looking at XX18 y Lo now
 499+ C44F CB 3E                                srl     (hl)                        ; XX18+2    \ ynormal lo/2
 500+ C451 23                                   inc     hl                          ; looking at XX18 y sign now
 501+ C452 23                                   inc     hl                          ; looking at XX18 z Lo now
 502+ C453 CB 3E                                srl     (hl)
 503+ C455 C9                                   ret
 504+ C456
 505+ C456              ; ......................................................                                                         ;;;
 506+ C456
 507+ C456
 508+ C456
 509+ C456
 510+ C456              ; Pitch and roll are 2 phases
 511+ C456              ; 1 - we apply our pitch and roll to the ship position
 512+ C456              ;       x -> x + alpha * (y - alpha * x)
 513+ C456              ;       y -> y - alpha * x - beta * z
 514+ C456              ;       z -> z + beta * (y - alpha * x - beta * z)
 515+ C456              ; which can be simplified as:
 516+ C456              ;       1. K2 = y - alpha * x
 517+ C456              ;       2. z = z + beta * K2
 518+ C456              ;       3. y = K2 - beta * z
 519+ C456              ;       4. x = x + alpha * y
 520+ C456              ; 2 - we apply our patch and roll to the ship orientation
 521+ C456              ;      Roll calculations:
 522+ C456              ;
 523+ C456              ;        nosev_y = nosev_y - alpha * nosev_x_hi
 524+ C456              ;        nosev_x = nosev_x + alpha * nosev_y_hi
 525+ C456              ;      Pitch calculations:
 526+ C456              ;
 527+ C456              ;        nosev_y = nosev_y - beta * nosev_z_hi
 528+ C456              ;        nosev_z = nosev_z + beta * nosev_y_hi
 529+ C456
 530+ C456
 531+ C456                          INCLUDE "../Universe/Sun/SunApplyMyRollAndPitch.asm"
# file opened: ./../Universe/Sun/SunApplyMyRollAndPitch.asm
   1++C456
   2++C456              ; Full version
   3++C456              ; 1. K2 = y - alpha * x
   4++C456              ; 2. z = z + beta * K2
   5++C456              ; 3. y = K2 - beta * z
   6++C456              ; 4. x = x + alpha * y
   7++C456
   8++C456
   9++C456
  10++C456              ; SunrollWork holds Alpha intermidate results
  11++C456 00 00 00     SunRollResult:          DS 3                    ; equivalent of K
  12++C459              SunRollResultp1         equ SunRollResult
  13++C459              SunRollResultp2         equ SunRollResult+1
  14++C459              SunRollResultp3         equ SunRollResult+2
  15++C459 00           SunRollResultp4         DB 0
  16++C45A              ;SunRollResult2:         DS 3                    ; do we need this? TODO
  17++C45A 00 00 00     SunZResult:             DS 3
  18++C45D              ;  1. K2 = y - alpha * x
  19++C45D              ;  2. z = z + beta * K2
  20++C45D              ;  3. y = K2 - beta * z
  21++C45D              ;  4. x = x + alpha * y
  22++C45D              ;.... or
  23++C45D              ;  2. z = z + (beta * (y - alpha * x))
  24++C45D              ;  3. y = (y - alpha * x) - (beta * z)
  25++C45D              ;  4. x = x + (alpha * y)
  26++C45D
  27++C45D
  28++C45D              ;----------------------------------------------------------------------------------------------------------------------------------
  29++C45D              ; Sun version of pitch and roll is a 24 bit calculation 1 bit sign + 23 bit value
  30++C45D 3A 23 83     SunApplyMyRollAndPitch: ld      a,(ALPHA)                   ; no roll or pitch, no calc needed
  31++C460 21 15 83                             ld      hl,BETA
  32++C463 B6                                   or      (hl)
  33++C464 E6 7F                                and     SignMask8Bit
  34++C466 CA 02 C5                             jp      z,.NoRotation
  35++C469              .CalcZ:                 ;break
  36++C469 3A 23 83                             ld      a,(ALPHA)                   ; get roll magnitude
  37++C46C FE 00                                cp      0
  38++C46E 20 0B                                jr      nz,.ApplyAlpha
  39++C470 ED 5B 14 C0  .NoAlpha:               ld      de,(SBnKyhi)                ; here we have no roll so
  40++C474 3A 13 C0                             ld      a,(SBnKylo)                 ; store untouched in SunRollResult
  41++C477 6F                                   ld      l,a                         ; .
  42++C478 C3 97 C4                             jp      .SaveResult1                ; .
  43++C47B EE 80        .ApplyAlpha:            xor     SignOnly8Bit                ; d = -alpha (Q value)
  44++C47D 57                                   ld      d,a                         ;
  45++C47E 3A 10 C0                             ld      a,(SBnKxlo)                 ; HLE = x sgn, hi, lo
  46++C481 5F                                   ld      e,a                         ; .
  47++C482 2A 11 C0                             ld      hl,(SBnKxhi)                ; .
  48++C485 CD 80 95                             call    mulHLEbyDSigned             ; DELC = x * -alpha, so DEL = X * -alpha / 256 where d = sign byte
  49++C488 7A           .SkipAlphaMultiply:     ld      a,d
  50++C489 32 59 C4                             ld      (SunRollResultp4),a         ; save sign from result, ELC holds actual result
  51++C48C 3A 13 C0     .CalcYPlusDEL:          ld      a,(SBnKylo)                 ; BCH = Y sgn, hi, lo, we loose the C from result
  52++C48F 67                                   ld      h,a                         ; .
  53++C490 ED 4B 14 C0                          ld      bc,(SBnKyhi)                ; .
  54++C494 CD 28 92                             call    AddBCHtoDELsigned           ; DEL = Y - ( X *  alpha /256) (which is K2)
  55++C497 7A           .SaveResult1:           ld      a,d                         ; SunPitchWork = AHL = DEL
  56++C498 63                                   ld      h,e                         ;
  57++C499 32 58 C4     .CopyResultTo2:         ld      (SunRollResult+2),a         ; .
  58++C49C 22 56 C4                             ld      (SunRollResult) ,hl         ; .
  59++C49F 5D           .CalcY:                 ld      e,l                         ; HLE = result (K2)
  60++C4A0 6C                                   ld      l,h                         ; .
  61++C4A1 67                                   ld      h,a                         ; .
  62++C4A2 3A 15 83                             ld      a,(BETA)                    ; get pitch
  63++C4A5 57                                   ld      d,a                         ; now D = BETA
  64++C4A6 CD 80 95                             call    mulHLEbyDSigned             ; DELC = (y - alpha * x /256 ) * Beta or K2 * beta
  65++C4A9 ED 4B 17 C0                          ld      bc,(SBnKzhi)                ; BCH = z
  66++C4AD 3A 16 C0                             ld      a,(SBnKzlo)                 ; .
  67++C4B0 67                                   ld      h,a                         ; .
  68++C4B1 CD 28 92                             call    AddBCHtoDELsigned           ; DEL = z + ((y - alpha * x /256 ) * Beta) /256
  69++C4B4 ED 53 5B C4  .SaveZResult:           ld      (SunZResult+1),de           ; We now have a z result which we save
  70++C4B8 ED 53 17 C0                          ld      (SBnKzhi),de                ; .
  71++C4BC 7D                                   ld      a,l                         ; .
  72++C4BD 32 5A C4                             ld      (SunZResult),a              ; .
  73++C4C0 32 16 C0                             ld      (SBnKzlo),a                 ; .
  74++C4C3 EB           .CalcMinusBetaMulZ:     ex      de,hl                       ; HLE = DEL = z post calculation
  75++C4C4                                      ; not needed bugld      e,l                         ; .
  76++C4C4 3A 15 83                             ld      a,(BETA)                    ; d = - BETA
  77++C4C7 EE 80                                xor     SignOnly8Bit                ; .
  78++C4C9 57                                   ld      d,a                         ; .
  79++C4CA CD 80 95                             call    mulHLEbyDSigned             ; DELC = z * - BETA
  80++C4CD ED 4B 57 C4                          ld      bc, (SunRollResult+1)       ; BCH = (y - alpha * x) (or K2)
  81++C4D1 3A 56 C4                             ld      a,(SunRollResult)           ; .
  82++C4D4 67                                   ld      h,a                         ; .
  83++C4D5 CD 28 92                             call    AddBCHtoDELsigned           ; DEL = (y - alpha * x) - (Z * BETA) (K2+ (Z * -BETA)
  84++C4D8 ED 53 14 C0                          ld      (SBnKyhi),de                ; y = (y - alpha * x) - (Z * BETA)
  85++C4DC 7D                                   ld      a,l                         ; .
  86++C4DD 32 13 C0                             ld      (SBnKylo),a                 ; .
  87++C4E0 EB           .CalcX:                 ex      de,hl                       ; HLE = DEL = Y
  88++C4E1 5D                                   ld      e,l                         ; .
  89++C4E2 3A 23 83                             ld      a,(ALPHA)                   ; D = alpha
  90++C4E5 FE 00                                cp      0                           ; if alpha is 0 then don't update x
  91++C4E7 CA 02 C5                             jp      z,.NoRotation
  92++C4EA 57                                   ld      d,a                         ; .
  93++C4EB CD 80 95                             call    mulHLEbyDSigned             ; DELC = Y * alpha
  94++C4EE ED 4B 11 C0                          ld      bc,(SBnKxhi)                ; BCH = x
  95++C4F2 3A 10 C0                             ld      a,(SBnKxlo)                 ; .
  96++C4F5 67                                   ld      h,a                         ; .
  97++C4F6 CD 28 92                             call    AddBCHtoDELsigned           ; DEL = x + (alpha * y /256 )
  98++C4F9 ED 53 11 C0                          ld      (SBnKxhi),de                ; x = x + (alpha * y /256 )
  99++C4FD 7C                                   ld      a,h                         ; .
 100++C4FE 32 10 C0                             ld      (SBnKxlo),a                 ; .
 101++C501 C9                                   ret
 102++C502 3A 09 84     .NoRotation:            ld      a,(DELTA)                   ; BCH = - Delta
 103++C505 FE 00                                cp      0
 104++C507 C8                                   ret     z
 105++C508 0E 00                                ld      c,0                         ;
 106++C50A 67                                   ld      h,a                         ;
 107++C50B 06 80                                ld      b,$80                       ;
 108++C50D ED 5B 17 C0                          ld      de,(SBnKzhi)                ; DEL = z position
 109++C511 3A 16 C0                             ld      a,(SBnKzlo)                 ; .
 110++C514 6F                                   ld      l,a                         ; .
 111++C515 CD 28 92                             call    AddBCHtoDELsigned           ; update speed
 112++C518 ED 53 17 C0                          ld      (SBnKzhi),DE                ; write back to zpos
 113++C51C 7D                                   ld      a,l
 114++C51D 32 16 C0                             ld      (SBnKzlo),a                ;
 115++C520 C9                                   ret
 116++C521
 117++C521              ;
 118++C521              ;SunApplyMyRollAndPitch: ld      a,(ALPHA)                   ; no roll or pitch, no calc needed
 119++C521              ;                        ld      hl,BETA
 120++C521              ;                        or      (hl)
 121++C521              ;                        and     SignMask8Bit
 122++C521              ;                        ret     z
 123++C521              ;.CalcZ:                 ;break
 124++C521              ;                        ld      a,(ALPHA)                   ; get roll magnitude
 125++C521              ;                        xor     SignOnly8Bit                ; get Q = -alpha
 126++C521              ;                        ld      d,a                         ; d reg represents Q (abount to roll)
 127++C521              ;                        ld      a,(SBnKxlo)                 ; HLE = x sgn, hi, lo
 128++C521              ;                        ld      e,a                         ;
 129++C521              ;                        ld      hl,(SBnKxhi)                ;
 130++C521              ;                        call    mulHLEbyDSigned             ; DELC = x * -alpha, so DEL = X * -alpha / 256
 131++C521              ;                        ld      a,d
 132++C521              ;                        ld      (SunRollResultp4),a         ; save D (I guess we need the sign?)
 133++C521              ;.CalcYPlusDEL:          ld      a,(SBnKylo)                 ; BCH = Y sgn, hi, lo
 134++C521              ;                        ld      h,a
 135++C521              ;                        ld      bc,(SBnKyhi)
 136++C521              ;                        call    AddBCHtoDELsigned           ; DEL = Y - ( X *  alpha /256)
 137++C521              ;.SaveResult1:           ld      a,l                         ; SunPitchWork = DEL
 138++C521              ;                        ;ld      (SunRollResult), a          ; SunPitchWork + 0 = L
 139++C521              ;                        ex      de,hl                       ; SunPitchWork + 1 = E
 140++C521              ;.CopyResultTo2:         ld      (SunRollResult+1),a         ; SunPitchWork + 2 = D
 141++C521              ;                        ld      (SunRollResult+1) ,hl       ; Copy K to K2 (y - alpha * x)
 142++C521              ;                        ;ld      (SunRollResult2+1),hl       ; also HLA = result
 143++C521              ;                        ld      a,(SunRollResult)           ; .
 144++C521              ;                        ;ld      (SunRollResult2),a          ; .
 145++C521              ;.CalcY:                 ld      e,a                         ; so now HLE = result
 146++C521              ;                        ld      a,(BETA)                    ; get pitch
 147++C521              ;                        ld      d,a                         ; now D = BETA
 148++C521              ;                        call    mulHLEbyDSigned             ; DELC = (y - alpha * x /256 ) * Beta
 149++C521              ;                        ld      bc,(SBnKzhi)                ; BCH = z
 150++C521              ;                        ld      a,(SBnKzlo)                 ;
 151++C521              ;                        ld      h,a                         ;
 152++C521              ;                        call    AddBCHtoDELsigned           ; DEL = z + ((y - alpha * x /256 ) * Beta) /256
 153++C521              ;.SaveZResult:           ld      (SunZResult+1),de           ; We now have a z result which we save
 154++C521              ;                        ld      (SBnKzhi),de                ; .
 155++C521              ;                        ld      a,l                         ; .
 156++C521              ;                        ld      (SunZResult),a              ; .
 157++C521              ;                        ld      (SBnKzlo),a                 ; .
 158++C521              ;.CalcMinusBetaMulZ:     ex      de,hl                       ; HLE = DEL = z post calculation
 159++C521              ;                        ld      e,l                         ;
 160++C521              ;                        ld      a,(BETA)                    ; d = - BETA
 161++C521              ;                        ld      d,a                         ;
 162++C521              ;                        xor     SignOnly8Bit                ;
 163++C521              ;                        call    mulHLEbyDSigned             ; DELC = z * - BETA
 164++C521              ;                        ld      bc, (SunRollResult+1)       ; BCH = (y - alpha * x) (or K2)
 165++C521              ;                        ld      a,(SunRollResult)           ;
 166++C521              ;                        ld      h,a                         ;
 167++C521              ;                        call    AddBCHtoDELsigned           ; DEL = (y - alpha * x) - (Z * BETA)
 168++C521              ;                        ld      (SBnKyhi),de                ; y = (y - alpha * x) - (Z * BETA)
 169++C521              ;                        ld      a,l                         ;
 170++C521              ;                        ld      (SBnKylo),a                 ;
 171++C521              ;.CalcX:                 ex      de,hl                       ; HLE = DEL = Y
 172++C521              ;                        ld      e,l                         ;
 173++C521              ;                        ld      a,(ALPHA)
 174++C521              ;                        ld      d,a                         ; D = alpha
 175++C521              ;                        call    mulHLEbyDSigned             ; DELC = Y * alpha
 176++C521              ;                        ld      bc,(SBnKxhi)                ; BCH = x
 177++C521              ;                        ld      a,(SBnKxlo)                 ;
 178++C521              ;                        ld      h,a                         ;
 179++C521              ;                        call    AddBCHtoDELsigned           ; DEL = x + (alpha * y /256 )
 180++C521              ;                        ld      (SBnKxhi),de                ; x = x + (alpha * y /256 )
 181++C521              ;                        ld      a,h                         ;
 182++C521              ;                        ld      (SBnKxlo),a                 ;
 183++C521              ;                        ret
 184++C521              ;
# file closed: ./../Universe/Sun/SunApplyMyRollAndPitch.asm
 532+ C521              ;            INCLUDE "./Universe/SunApplyShipRollAndPitch.asm"
 533+ C521
 534+ C521 00           SunOnScreen             DB 0
 535+ C522 00 00        cLineArrayPtr            DW 0
 536+ C524 00           LineCount               DB 0
 537+ C525 00           RaggedSize              DB 0
 538+ C526 00           MinYOffset              DB 0
 539+ C527 00           MaxYOffSet              DB 0
 540+ C528 00 00        SunScrnX                DW  0       ; signed
 541+ C52A 00 00        SunScrnY                DW  0       ; signed
 542+ C52C 00           SunRadius               DB  0       ; unsigned
 543+ C52D              ; draw circle
 544+ C52D
 545+ C52D              ;
 546+ C52D              ;DIVD3B2 K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
 547+ C52D
 548+ C52D 00 00 00 00  SunVarK                 DS 4
 549+ C531 00 00 00     SunVarP                 DS 3
 550+ C534 00           SunVarQ                 DS 1
 551+ C535 00           SunVarR                 DS 1
 552+ C536 00           SunVarS                 DS 1
 553+ C537 00           SunVarT                 DS 1
 554+ C538
 555+ C538              ; Needs tuning for registers vs memroy
 556+ C538 22 31 C5     SunKEquAHLDivCDE:       ld      (SunVarP),hl
 557+ C53B 32 33 C5                             ld      (SunVarP+2),a
 558+ C53E ED 53 34 C5                          ld      (SunVarQ),de
 559+ C542 79                                   ld      a,c
 560+ C543 32 36 C5                             ld      (SunVarS),a
 561+ C546 3A 31 C5     SunDivD3B:              ld      a,(SunVarP)                 ; Ensure P is at least 1
 562+ C549 F6 01                                or      1
 563+ C54B 32 31 C5                             ld      (SunVarP),a
 564+ C54E 3A 33 C5                             ld      a,(SunVarP+2)               ; T = Sign xor Sign
 565+ C551 21 36 C5                             ld      hl,SunVarS
 566+ C554 AE                                   xor     (hl)
 567+ C555 E6 80                                and     SignOnly8Bit
 568+ C557 32 37 C5                             ld      (SunVarT),a
 569+ C55A 06 00                                ld      b,0                         ; b = y counter
 570+ C55C 3A 33 C5                             ld      a,(SunVarP+2)               ; a = abs high byte of p
 571+ C55F E6 7F                                and     SignMask8Bit                ; .
 572+ C561 2A 31 C5                             ld      hl,(SunVarP)                ; shift P left
 573+ C564              .SunDVL9:               JumpIfAGTENusng   64, .SunDV14      ; if high p > 64 then go to DV14
 573+ C564 FE 40       >                        cp     64
 573+ C566 D2 73 C5    >                        jp		nc,.SunDV14
 574+ C569                                      ShiftHLLeft1                        ;
 574+ C569 CB 25       >			   sla l
 574+ C56B CB 14       >			   rl  h
 575+ C56D CB 17                                rl      a                           ;
 576+ C56F 04                                   inc     b                           ; increase shift count
 577+ C570 C3 64 C5                             jp      .SunDVL9
 578+ C573 22 31 C5     .SunDV14:               ld      (SunVarP),hl                ; save off var P
 579+ C576 32 33 C5                             ld      (SunVarP+2),a
 580+ C579 3A 36 C5                             ld      a,(SunVarS)                 ; a= ABS varS
 581+ C57C E6 7F                                and     SignMask8Bit
 582+ C57E 2A 34 C5                             ld      hl,(SunVarQ)                ; HL = vars Q & R
 583+ C581 05           .SunDVL6:               dec     b                           ; reduce b counter by 1
 584+ C582                                      ShiftHLLeft1                        ; varQRA  shift left
 584+ C582 CB 25       >			   sla l
 584+ C584 CB 14       >			   rl  h
 585+ C586 CB 17                                rl      a                           ;
 586+ C588 F2 81 C5                             jp      p, .SunDVL6                 ; keep shifting until bit 7 of a is set
 587+ C58B 22 34 C5                             ld      (SunVarQ),hl                ; save QR
 588+ C58E 32 36 C5     .SunDV9:                ld      (SunVarS),a                 ; save S
 589+ C591                                      ;ld      a,h
 590+ C591                                      ;ld      (varQ),a
 591+ C591 4F                                   ld      c,a
 592+ C592 3A 33 C5                             ld      a,(SunVarP+2)
 593+ C595 C5                                   push    bc                          ; save shift counter in b
 594+ C596 CD EC 96                             call    DIV16Amul256dCUNDOC
 595+ C599                                      ;call    RequAmul256divQ
 596+ C599 79                                   ld      a, c
 597+ C59A 32 0E 84                             ld      (varR),a
 598+ C59D C1                                   pop     bc                          ; retrieve shift counter
 599+ C59E 21 00 00                             ld      hl,0                        ; set K to 0
 600+ C5A1 22 2D C5                             ld      (SunVarK),hl                ; .
 601+ C5A4 22 2F C5                             ld      (SunVarK+2),hl              ; .
 602+ C5A7 CB 78                                bit     7,b                         ; is counter positive
 603+ C5A9 28 32                                jr      z,.SunDV12                  ; .
 604+ C5AB 3A 0E 84                             ld      a,(varR)                    ;
 605+ C5AE CB 27        .SunDVL8:               sla     a                           ; Shift K by 1 left
 606+ C5B0 21 2E C5                             ld      hl,SunVarK+1                ; .
 607+ C5B3 CB 16                                rl      (hl)                        ; .
 608+ C5B5 23                                   inc     hl                          ; .
 609+ C5B6 CB 16                                rl      (hl)                        ; .
 610+ C5B8 23                                   inc     hl                          ; .
 611+ C5B9 CB 16                                rl      (hl)                        ; .
 612+ C5BB 04                                   inc     b
 613+ C5BC 20 F0                                jr      nz,.SunDVL8                 ; loop until K is shifted
 614+ C5BE 32 2D C5                             ld      (SunVarK),a
 615+ C5C1 3A 30 C5                             ld      a,(SunVarK+3)
 616+ C5C4 21 37 C5                             ld      hl,SunVarT
 617+ C5C7 B6                                   or      (hl)
 618+ C5C8 32 30 C5                             ld      (SunVarK+3),a
 619+ C5CB C9                                   ret
 620+ C5CC 3A 0E 84     .SunDV13:               ld      a,(varR)                    ; when we get here, shift is zero
 621+ C5CF 32 2D C5                             ld      (SunVarK),a
 622+ C5D2 3A 30 C5                             ld      a,(SunVarK+3)
 623+ C5D5 21 37 C5                             ld      hl,SunVarT
 624+ C5D8 B6                                   or      (hl)
 625+ C5D9 32 30 C5                             ld      (SunVarK+3),a
 626+ C5DC C9                                   ret
 627+ C5DD 78           .SunDV12:               ld      a,b
 628+ C5DE A7                                   and     a
 629+ C5DF 28 EB                                jr      z,.SunDV13
 630+ C5E1 3A 0E 84                             ld      a,(varR)                    ; it probably is already R so need to test
 631+ C5E4 CB 2F        .SunDVL10:              sra     a                           ; Shift K by 1 left
 632+ C5E6 05                                   dec     b
 633+ C5E7 20 FB                                jr      nz,.SunDVL10
 634+ C5E9 32 2D C5                             ld      (SunVarK),a                 ; as original divide was onyl 8 bits K 1,2,3 don;t matter
 635+ C5EC 3A 37 C5                             ld      a,(SunVarT)
 636+ C5EF 32 30 C5                             ld      (SunVarK+3),a
 637+ C5F2 C9                                   ret
 638+ C5F3
 639+ C5F3
 640+ C5F3
 641+ C5F3              SunProcessVertex:       MACRO   vertlo, vertsgn
 642+ C5F3 ~            .SunProjectToEye:       ld      de,(SBnKzlo)                ; X Pos = X / Z
 643+ C5F3 ~                                    ld      a,(SBnKzsgn)                ; CDE = z
 644+ C5F3 ~                                    ld      c,a                         ;
 645+ C5F3 ~                                    ld      hl,(vertlo)                ; AHL = x
 646+ C5F3 ~                                    ld      a,(vertsgn)                ;
 647+ C5F3 ~                                    call    SunKEquAHLDivCDE            ; result in sunvarK to K + 3
 648+ C5F3 ~                                    ld      hl,(SunVarK)                ; result is in DEHL (high to low)
 649+ C5F3 ~                                    ld      de,(SunVarK+2)
 650+ C5F3 ~            .CheckPosOnScreenX:     ld      a,d                         ; a= abs highest byte (k+3)  or k+2
 651+ C5F3 ~                                    and     SignMask8Bit                ;
 652+ C5F3 ~                                    or      e                           ;
 653+ C5F3 ~                                    ret     nz                          ; off screen
 654+ C5F3 ~                                    ld      a,h                         ; a = k + 1 can do this as ABS
 655+ C5F3 ~                                    ReturnIfAGTEusng 4                  ; if > 1024 then return
 656+ C5F3 ~                                    ld      a,d                         ; get sign back
 657+ C5F3 ~                                    and     SignOnly8Bit                ; if positive then we are good
 658+ C5F3 ~                                    jr      z,.calculatedVert
 659+ C5F3 ~            .XIsNegative:           NegHL                               ; make 2's c as negative
 660+ C5F3 ~            .calculatedVert:
 661+ C5F3                                      ENDM
 662+ C5F3
 663+ C5F3
 664+ C5F3
 665+ C5F3                                 ; could probabyl set a variable say "varGood", default as 1 then set to 0 if we end up with a good calulation?? may not need it as we draw here
 666+ C5F3 CD 5D C4     SunUpdateAndRender:     call    SunApplyMyRollAndPitch
 667+ C5F6 3A 18 C0     .CheckDrawable:         ld      a,(SBnKzsgn)
 668+ C5F9 E6 80                                and     SignOnly8Bit
 669+ C5FB C0                                   ret     nz
 670+ C5FC              .CheckDist48:           ReturnIfAGTENusng 48                ; at a distance over 48 its too far away
 670+ C5FC FE 30       >                        cp    48
 670+ C5FE D0          >                        ret	 nc
 671+ C5FF 21 17 C0                             ld      hl,SBnKzhi                  ; if the two high bytes are zero then its too close
 672+ C602 B6                                   or      (hl)
 673+ C603                                      ReturnIfAIsZero
 673+ C603 A7          >                        and     a
 673+ C604 C8          >                        ret     z
 674+ C605              .calculateX:            SunProcessVertex SBnKxlo, SBnKxsgn
 674+ C605 ED 5B 16 C0 >.SunProjectToEye:       ld      de,(SBnKzlo)                ; X Pos = X / Z
 674+ C609 3A 18 C0    >                        ld      a,(SBnKzsgn)                ; CDE = z
 674+ C60C 4F          >                        ld      c,a                         ;
 674+ C60D 2A 10 C0    >                        ld      hl,(SBnKxlo)                ; AHL = x
 674+ C610 3A 12 C0    >                        ld      a,(SBnKxsgn)                ;
 674+ C613 CD 38 C5    >                        call    SunKEquAHLDivCDE            ; result in sunvarK to K + 3
 674+ C616 2A 2D C5    >                        ld      hl,(SunVarK)                ; result is in DEHL (high to low)
 674+ C619 ED 5B 2F C5 >                        ld      de,(SunVarK+2)
 674+ C61D 7A          >.CheckPosOnScreenX:     ld      a,d                         ; a= abs highest byte (k+3)  or k+2
 674+ C61E E6 7F       >                        and     SignMask8Bit                ;
 674+ C620 B3          >                        or      e                           ;
 674+ C621 C0          >                        ret     nz                          ; off screen
 674+ C622 7C          >                        ld      a,h                         ; a = k + 1 can do this as ABS
 674+ C623             >                        ReturnIfAGTEusng 4                  ; if > 1024 then return
 674+ C623 FE 04       >                        cp    4
 674+ C625 D0          >                        ret	 nc
 674+ C626 7A          >                        ld      a,d                         ; get sign back
 674+ C627 E6 80       >                        and     SignOnly8Bit                ; if positive then we are good
 674+ C629 28 06       >                        jr      z,.calculatedVert
 674+ C62B             >.XIsNegative:           NegHL                               ; make 2's c as negative
 674+ C62B AF          >                    xor a
 674+ C62C 95          >                    sub l
 674+ C62D 6F          >                    ld l,a
 674+ C62E 9F          >                    sbc a,a
 674+ C62F 94          >                    sub h
 674+ C630 67          >                    ld h,a
 674+ C631             >.calculatedVert:
 675+ C631 3E 80        .calculatedX:           ld      a,ScreenCenterX
 676+ C633 CD CC 91                             call    HL2cEquHLSgnPlusAusgn       ; correct to center of screen
 677+ C636 22 28 C5                             ld      (SunScrnX),hl               ; save projected X Position, 2's compliment
 678+ C639              .calculateY:            SunProcessVertex SBnKylo, SBnKysgn
 678+ C639 ED 5B 16 C0 >.SunProjectToEye:       ld      de,(SBnKzlo)                ; X Pos = X / Z
 678+ C63D 3A 18 C0    >                        ld      a,(SBnKzsgn)                ; CDE = z
 678+ C640 4F          >                        ld      c,a                         ;
 678+ C641 2A 13 C0    >                        ld      hl,(SBnKylo)                ; AHL = x
 678+ C644 3A 15 C0    >                        ld      a,(SBnKysgn)                ;
 678+ C647 CD 38 C5    >                        call    SunKEquAHLDivCDE            ; result in sunvarK to K + 3
 678+ C64A 2A 2D C5    >                        ld      hl,(SunVarK)                ; result is in DEHL (high to low)
 678+ C64D ED 5B 2F C5 >                        ld      de,(SunVarK+2)
 678+ C651 7A          >.CheckPosOnScreenX:     ld      a,d                         ; a= abs highest byte (k+3)  or k+2
 678+ C652 E6 7F       >                        and     SignMask8Bit                ;
 678+ C654 B3          >                        or      e                           ;
 678+ C655 C0          >                        ret     nz                          ; off screen
 678+ C656 7C          >                        ld      a,h                         ; a = k + 1 can do this as ABS
 678+ C657             >                        ReturnIfAGTEusng 4                  ; if > 1024 then return
 678+ C657 FE 04       >                        cp    4
 678+ C659 D0          >                        ret	 nc
 678+ C65A 7A          >                        ld      a,d                         ; get sign back
 678+ C65B E6 80       >                        and     SignOnly8Bit                ; if positive then we are good
 678+ C65D 28 06       >                        jr      z,.calculatedVert
 678+ C65F             >.XIsNegative:           NegHL                               ; make 2's c as negative
 678+ C65F AF          >                    xor a
 678+ C660 95          >                    sub l
 678+ C661 6F          >                    ld l,a
 678+ C662 9F          >                    sbc a,a
 678+ C663 94          >                    sub h
 678+ C664 67          >                    ld h,a
 678+ C665             >.calculatedVert:
 679+ C665 3E 60        .calculatedY:           ld      a,ScreenCenterY
 680+ C667 CD CC 91                             call    HL2cEquHLSgnPlusAusgn       ; correct to center of screen
 681+ C66A 22 2A C5                             ld      (SunScrnY),hl               ; save projected Y Position, 2's compliment
 682+ C66D              ; .........................................................................................................................
 683+ C66D ED 5B 16 C0  .CalculateRadius:       ld      de,(SBnKzlo)
 684+ C671 3A 18 C0                             ld      a,(SBnKzsgn)
 685+ C674 4F                                   ld      c,a
 686+ C675 21 00 60                             ld      hl,$6000  ; was hl          ; planet radius at Z = 1 006000
 687+ C678 AF                                   xor     a
 688+ C679 CD 68 93                             call    Div24by24LeadSign           ; radius = AHL/CDE = 24576 / distance z
 689+ C67C 7A                                   ld      a,d                         ; if high byte (d) = 0 then e contains radius
 690+ C67D                                      JumpIfAIsZero  .SaveRadius
 690+ C67D A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 690+ C67E CA 83 C6    >                        jp	z, .SaveRadius
 691+ C681 1E F8        .MaxRadius:             ld      e,248                       ;set radius to 248 as maxed out
 692+ C683 7B           .SaveRadius:            ld      a,e
 693+ C684 32 2C C5                             ld      (SunRadius),a               ; save a copy of radius now for later
 694+ C687              ; .........................................................................................................................
 695+ C687 2A 28 C5     .CheckIfSunOnScreen:    ld      hl,(SunScrnX)               ; get x pixel position
 696+ C68A FD 26 00                             ld      iyh,0                       ; iyh holds draw status, 0= OK
 697+ C68D 16 00                                ld      d,0                         ; e still holds radius
 698+ C68F 7C                                   ld      a,h
 699+ C690                                      JumpOnLeadSignSet   h,.CheckXNegative
 699+ C690 7C          >                        ld      a,h
 699+ C691 E6 80       >                        and     SignOnly8Bit
 699+ C693 C2 A9 C6    >                        jp      nz,.CheckXNegative
 700+ C696 7C           .CheckXPositive:        ld      a,h
 701+ C697                                      JumpIfAIsZero   .XOnScreen          ; if high byte of h is not zero its definitly on screen
 701+ C697 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 701+ C698 CA B2 C6    >                        jp	z, .XOnScreen
 702+ C69B 16 00                                ld      d,0                         ; de = radius
 703+ C69D                                      ClearCarryFlag
 703+ C69D B7          >                        or a
 704+ C69E ED 52                                sbc     hl,de
 705+ C6A0 FA B2 C6                             jp      m   ,.XOnScreen             ; if result was negative then it spans screen
 706+ C6A3 7C                                   ld      a,h
 707+ C6A4                                      JumpIfAIsZero   .XOnScreen          ; if high byte of h is not zero then its partially on screen at least
 707+ C6A4 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 707+ C6A5 CA B2 C6    >                        jp	z, .XOnScreen
 708+ C6A8 C9                                   ret                                 ; None of the X coordinates are on screen
 709+ C6A9 16 00        .CheckXNegative:        ld      d,0                         ; de = radius
 710+ C6AB                                      ClearCarryFlag
 710+ C6AB B7          >                        or a
 711+ C6AC ED 5A                                adc     hl,de                       ; so we have hl - de
 712+ C6AE F2 B2 C6                             jp      p,.XOnScreen                ; if result was positive then it spans screen so we are good
 713+ C6B1 C9                                   ret                                 ; else x is totally off the left side of the screen
 714+ C6B2              ; .........................................................................................................................
 715+ C6B2 2A 2A C5     .XOnScreen:             ld      hl,(SunScrnY)               ; now Check Y coordinate
 716+ C6B5                                      JumpOnLeadSignSet   h,.CheckYNegative
 716+ C6B5 7C          >                        ld      a,h
 716+ C6B6 E6 80       >                        and     SignOnly8Bit
 716+ C6B8 C2 DA C6    >                        jp      nz,.CheckYNegative
 717+ C6BB 7C           .CheckYPositive:        ld      a,h
 718+ C6BC                                      JumpIfAIsNotZero   .PosYCheck2
 718+ C6BC FE 00       >                        cp	0
 718+ C6BE C2 C7 C6    >                        jp	nz,.PosYCheck2
 719+ C6C1 7D                                   ld      a,l
 720+ C6C2 E6 80                                and     %10000000
 721+ C6C4 CA E3 C6                             jp      z,.YOnScreen                ; at least 1 row is on screen as > 128
 722+ C6C7 16 00        .PosYCheck2:            ld      d,0                         ; de = radius
 723+ C6C9                                      ClearCarryFlag
 723+ C6C9 B7          >                        or a
 724+ C6CA ED 52                                sbc     hl,de
 725+ C6CC FA E3 C6                             jp      m,.YOnScreen                ; so if its -ve then it spans screen
 726+ C6CF 7C                                   ld      a,h                         ; if h > 0 then off screen so did not span
 727+ C6D0                                      ReturnIfANotZero                    ; .
 727+ C6D0 A7          >                        and     a
 727+ C6D1 C0          >                        ret     nz
 728+ C6D2 7D                                   ld      a,l                         ; if l > 128 then off screen so did not span
 729+ C6D3 E6 80                                and     %10000000                   ; .
 730+ C6D5                                      ReturnIfANotZero                    ; .
 730+ C6D5 A7          >                        and     a
 730+ C6D6 C0          >                        ret     nz
 731+ C6D7 C3 E3 C6                             jp      .YOnScreen                  ; so Y at least spans
 732+ C6DA 16 00        .CheckYNegative:        ld      d,0                         ; de = radius
 733+ C6DC                                      ClearCarryFlag
 733+ C6DC B7          >                        or a
 734+ C6DD ED 5A                                adc     hl,de                       ; so we have hl - de
 735+ C6DF F2 E3 C6                             jp      p,.YOnScreen                ; if result was positive then it spans screen so we are good
 736+ C6E2 C9                                   ret                                 ; else never gets above 0 so return
 737+ C6E3              ; .........................................................................................................................
 738+ C6E3 21 9F C0     .YOnScreen:             ld      hl,SBnKLineArray            ; we load start and end as 0
 739+ C6E6 11 00 01                             ld		de, SunLineArraySize        ; just if we get a 0,0 genuine we will not plot it
 740+ C6E9 3E 00                                ld		a,0
sun_data.asm(741): error: Label not found: memfill_dma
 741+ C6EB CD 00 00                             call	memfill_dma
 742+ C6EE              ; .........................................................................................................................
 743+ C6EE 11 00 00     .SetRaggedEdgeMax:      ld      de,0
 744+ C6F1 3A 2C C5                             ld      a,(SunRadius)               ; get readius
 745+ C6F4 FE 60                                cp      96                          ; if > 96 then roll carry flag into e
 746+ C6F6                                      FlipCarryFlag
 746+ C6F6 3F          >                        ccf
 747+ C6F7 CB 13                                rl      e                           ; if > 40 then roll carry flag into e
 748+ C6F9 FE 28                                cp      40
 749+ C6FB                                      FlipCarryFlag
 749+ C6FB 3F          >                        ccf
 750+ C6FC CB 13                                rl      e
 751+ C6FE FE 10                                cp      16                          ; if > 16 then roll carry flag into e
 752+ C700                                      FlipCarryFlag
 752+ C700 3F          >                        ccf
 753+ C701 CB 13                                rl     e
 754+ C703 7B                                   ld      a,e                         ; a = ragged size from %00000111 to %00000000
 755+ C704 32 25 C5                             ld      (RaggedSize),a
 756+ C707              ; .........................................................................................................................
 757+ C707 21 9F C0     .SkipSetK:              ld      hl,SBnKLineArray            ; prep line array details ready for filling
 758+ C70A 22 9F C1                             ld      (LineArrayPtr),hl
 759+ C70D AF                                   xor     a
 760+ C70E 32 24 C5                             ld      (LineCount),a
 761+ C711 16 00                                ld      d,0
 762+ C713              ; .........................................................................................................................
 763+ C713 2A 2A C5     .GetMinY:               ld      hl,(SunScrnY)               ; now calculate start Y position
 764+ C716 3A 2C C5                             ld      a,(SunRadius)
 765+ C719 5F                                   ld      e,a
 766+ C71A 57                                   ld      d,a
 767+ C71B                                      ClearCarryFlag
 767+ C71B B7          >                        or a
 768+ C71C ED 52                                sbc     hl,de
 769+ C71E F2 24 C7                             jp      p,.DoneMinY
 770+ C721 21 00 00                             ld      hl,0                        ; if its negative then we start with 0 as it can only go up screen after radius
 771+ C724              .DoneMinY:              ReturnIfRegNotZero h                ; if h > 0 then off the screen
 771+ C724 7C          >                        ld      a, h
 771+ C725 A7          >                        and     a
 771+ C726 C0          >                        ret     nz
 772+ C727 7D                                   ld      a,l                         ; check if l > 127
 773+ C728 E6 80                                and     SignOnly8Bit                ; .
 774+ C72A C0                                   ret     nz                          ; if bit is set then > 128
 775+ C72B 7D           .SetMinY:               ld      a,l
 776+ C72C 32 26 C5                             ld      (MinYOffset),a              ; so now we have Y top of screen
 777+ C72F 2A 2A C5     .GetMaxY:               ld      hl,(SunScrnY)               ; get hl = Y + radius, note if we got here then this can never be a negative result but can go from -ve hl to +ve result
 778+ C732 3A 2C C5                             ld      a,(SunRadius)               ; hl = hl + radius
 779+ C735 16 00                                ld      d,0                         ; .
 780+ C737 5F                                   ld      e,a                         ; .
 781+ C738                                      ClearCarryFlag                      ; .
 781+ C738 B7          >                        or a
 782+ C739 ED 5A                                adc     hl,de                       ; .
 783+ C73B 7C                                   ld      a,h
 784+ C73C A7                                   and     a
 785+ C73D 28 06                                jr      z,.YHiOK
 786+ C73F 21 7F 00     .YHiGTE127:             ld      hl,127
 787+ C742 C3 4E C7                             jp      .SetMaxY
 788+ C745 7D           .YHiOK:                 ld      a,l                         ; clamp at 127
 789+ C746 E6 80                                and     SignOnly8Bit                ; .
 790+ C748 CA 4E C7                             jp      z,.SetMaxY
 791+ C74B 21 7F 00                             ld      hl,127
 792+ C74E 7D           .SetMaxY                ld      a,l
 793+ C74F 32 27 C5                             ld      (MaxYOffSet),a              ; so now we have min and max Y coordinates and SunScrnX & Y holds center
 794+ C752 CD 59 C7                             call    SunDrawCircle
 795+ C755 CD B9 C1                             call    SunDraw
 796+ C758 C9                                   ret
 797+ C759                                      ; b8 04 00 02 00 00 60 01 00 gives a 0.5 so we have the cal wrong as its +-1 so should be * result of divide by 128
 798+ C759              ;.. Now we caluclate the circle of the star
 799+ C759              ;.. its from MinY down the screen to MaxY center ProjX,ProjY.
 800+ C759              ;.. We can use the circle draw logic gtom Bressenham's algorithm
 801+ C759              ; so now there are the following conditions to consider
 802+ C759              ; y min = 0   y center is negative radius <= ABS (Y center)             => Don't draw
 803+ C759              ; y min = 0   y center is negative radius > ABS (Y center)+1            => Draw bottom half only
 804+ C759              ; y max = 127 y center is > 127    radius <= y center - 127             => Don't draw
 805+ C759              ; y max = 127 y center is > 127    radius > y center - 127              => Draw top half only
 806+ C759              ; y min >= 0  y center > y min     we don't need to worry about radius  => Draw both halves
 807+ C759              ; x center + radius < 0                                                 => Don't draw
 808+ C759              ; x center - radius > 255                                               => Don't draw
 809+ C759              ; we won't consider x more here as the driver is the y coordinate but we will check if x is vaiable
 810+ C759              ; x point = max (x point, 0)   on left
 811+ C759              ; x point = min (x point, 255) on right
 812+ C759
 813+ C759              SetIYPlusOffset:        MACRO   reg
 814+ C759 ~                                    push    hl,,iy                          ; save hl, then hl = iy
 815+ C759 ~                                    pop     hl                              ;
 816+ C759 ~                                    ld      a,reg
 817+ C759 ~                                    add     hl,a
 818+ C759 ~                                    add     hl,a
 819+ C759 ~                                    push    hl
 820+ C759 ~                                    pop     iy
 821+ C759 ~                                    pop     hl
 822+ C759                                      ENDM
 823+ C759
 824+ C759              SetIYMinusOffset:       MACRO   reg
 825+ C759 ~                                    push    de,,hl,,iy                      ; save hl, then hl = iy
 826+ C759 ~                                    pop     hl                              ;
 827+ C759 ~                                    ld      a,reg
 828+ C759 ~                                    add     a,a
 829+ C759 ~                                    ld      e,a
 830+ C759 ~                                    ld      d,0
 831+ C759 ~                                    ClearCarryFlag
 832+ C759 ~                                    sbc     hl,de
 833+ C759 ~                                    push    hl
 834+ C759 ~                                    pop     iy
 835+ C759 ~                                    pop     de,,hl
 836+ C759                                      ENDM
 837+ C759
 838+ C759
 839+ C759 3A 2C C5     SunDrawCircle:          ld      a,(SunRadius)
 840+ C75C              .CheckRadius:           ReturnIfAIsZero                         ; elimiate zero or single pixel
 840+ C75C A7          >                        and     a
 840+ C75D C8          >                        ret     z
 841+ C75E                                      JumpIfAEqNusng  1, SunCircleSinglePixel
 841+ C75E FE 01       >                        cp     1
 841+ C760 CA A0 C8    >                        jp      z,SunCircleSinglePixel
 842+ C763                                     ; JumpIfAGTENusng 127, SunFullScreen      ; if its covering whole then just make it yellow
 843+ C763              ; already done .MakeCentreX2C:         MemSignedTo2C SunScrnX                   ; convert 16 bit signed to 2's compliment
 844+ C763              ; already done .MakeCentreY2C:         MemSignedTo2C SunScrnY                   ; .
 845+ C763 2A 2A C5     .BoundsCheck            ld      hl,(SunScrnY)
 846+ C766 E5                                   push    hl
 847+ C767 3A 2C C5                             ld      a,(SunRadius)
 848+ C76A ED 31                                add     hl,a
 849+ C76C CB 7C                                bit     7,h
 850+ C76E C0                                   ret     nz                              ; if Y + radius is negative then off the screen
 851+ C76F E1                                   pop     hl
 852+ C770 16 00                                ld      d,0
 853+ C772 5F                                   ld      e,a
 854+ C773                                      ClearCarryFlag
 854+ C773 B7          >                        or a
 855+ C774 ED 52                                sbc     hl,de
 856+ C776 7C                                   ld      a,h
 857+ C777                                      ReturnIfAGTENusng  1                     ; really shoudl be signed TODO
 857+ C777 FE 01       >                        cp    1
 857+ C779 D0          >                        ret	 nc
 858+ C77A
 859+ C77A 2A 28 C5                             ld      hl,(SunScrnX)
 860+ C77D E5                                   push    hl
 861+ C77E 3A 2C C5                             ld      a,(SunRadius)
 862+ C781 ED 31                                add     hl,a
 863+ C783 CB 7C                                bit     7,h
 864+ C785 C0                                   ret     nz                              ; if Y + radius is negative then off the screen
 865+ C786 E1                                   pop     hl
 866+ C787 16 00                                ld      d,0
 867+ C789 5F                                   ld      e,a
 868+ C78A                                      ClearCarryFlag
 868+ C78A B7          >                        or a
 869+ C78B ED 52                                sbc     hl,de
 870+ C78D 7C                                   ld      a,h
 871+ C78E
 872+ C78E                                      ReturnIfAGTENusng 1                      ; really shoudl be signed TODO
 872+ C78E FE 01       >                        cp    1
 872+ C790 D0          >                        ret	 nc
 873+ C791
 874+ C791                                      ; ** BNOTE Ptuichj abnd roll has a bug as piitch increases z axis value
 875+ C791              .PrepCircleData:       ; ld      ixl,0
 876+ C791                                     ; ld		(.Plot1+1),bc			        ; save origin into DE reg in code
 877+ C791 3A 2C C5                            ld      a,(SunRadius)
 878+ C794 DD 67                                ld		ixh,a							; ixh = radius
 879+ C796
 880+ C796
 881+ C796 DD 2E 00                             ld		ixl,0						    ; ixl = delta (y)
 882+ C799 26 00        .calcd:	                ld		h,0                             ; de = radius * 2
 883+ C79B 6F                                   ld		l,a                             ; .
 884+ C79C 29                                   add		hl,hl							; .
 885+ C79D EB                                   ex		de,hl							; .
 886+ C79E 21 03 00                             ld		hl,3                            ; hl = 3 - (r * 2)
 887+ C7A1 A7                                   and		a                               ; .
 888+ C7A2 ED 52                                sbc		hl,de							; .
 889+ C7A4 44                                   ld		b,h                             ; bc = 3 - (r * 2) : d = 3 - 2r
 890+ C7A5 4D                                   ld		c,l								; .
 891+ C7A6 21 01 00     .calcdelta:             ld		hl,1                            ; set hl to 1
 892+ C7A9 16 00                                ld		d,0                             ; de = ixl
 893+ C7AB DD 5D                                ld		e,ixl                           ;
 894+ C7AD                                      ClearCarryFlag                          ;
 894+ C7AD B7          >                        or a
 895+ C7AE ED 52                                sbc		hl,de                           ; hl = 1 - ixl
 896+ C7B0 11 01 00     .Setde1:                ld		de,1                            ; del = 1
 897+ C7B3 DD 7C        .CircleLoop:            ld		a,ixh                           ; if x = y then exit
 898+ C7B5 DD BD                                cp		ixl                             ;
 899+ C7B7 D8                                   ret		c                               ;
 900+ C7B8 D9           .ProcessLoop:	        exx                                     ; save out registers
 901+ C7B9              ; Process CY+Y CX+X & CY+Y CX-X..................................
 902+ C7B9 2A 2A C5     .Plot1:                 ld      hl, (SunScrnY)
 903+ C7BC DD 7C        .Get1YRow:              ld      a,ixh
 904+ C7BE ED 31                                add     hl,a                            ; Check to see if CY+Y (note is add hl ,a usginedf only??)
 905+ C7C0              .Check1YRowOnScreen:    CheckRowHLOnScreen .NoTopPixelPair
 905+ C7C0 7C          >                        ld      a,h                             ; is h byte set, i.e > 256 or < 0
 905+ C7C1 A7          >                        and     a                               ; .
 905+ C7C2 20 26       >                        jr      nz,.NoTopPixelPair                   ; h <> 0 so fails (covers <0 and > 255
 905+ C7C4 7D          >                        ld      a,l                             ; l bit 7 0?
 905+ C7C5 E6 80       >                        and     Bit7Only                        ; covers l > 127 (screen draw area is 0 to 192 / 3 * 2 (128)
 905+ C7C7 20 21       >                        jr      nz,.NoTopPixelPair                   ;
 906+ C7C9              .Write1YCoord:          SetIYPlusOffset ixh                     ; IY = IY + ixh
 906+ C7C9 E5 FD E5    >                        push    hl,,iy                          ; save hl, then hl = iy
 906+ C7CC E1          >                        pop     hl                              ;
 906+ C7CD DD 7C       >                        ld      a,ixh
 906+ C7CF ED 31       >                        add     hl,a
 906+ C7D1 ED 31       >                        add     hl,a
 906+ C7D3 E5          >                        push    hl
 906+ C7D4 FD E1       >                        pop     iy
 906+ C7D6 E1          >                        pop     hl
 907+ C7D7                                      IYEquRowN l                             ; IY = SBnkLineArray + (2 * l) - set up iy as target address
 907+ C7D7 7D          >                        ld      a,l
 907+ C7D8 21 9F C0    >                        ld      hl,SBnKLineArray
 907+ C7DB ED 31       >                        add     hl,a
 907+ C7DD ED 31       >                        add     hl,a
 907+ C7DF E5          >                        push    hl
 907+ C7E0 FD E1       >                        pop     iy
 908+ C7E2 DD 7D                                ld      a,ixl
 909+ C7E4 CD B7 C8                             call    ProcessXRowA
 910+ C7E7 C3 EA C7                             jp      .Plot2
 911+ C7EA              .NoTopPixelPair:        ;break
 912+ C7EA              ; Process CY-Y CX+X & CY-Y CX-X..................................
 913+ C7EA 2A 2A C5     .Plot2:                 ld      hl, (SunScrnY)
 914+ C7ED 16 00        .Get2YRow:              ld      d,0
 915+ C7EF DD 5C                                ld      e,ixh
 916+ C7F1                                      ClearCarryFlag
 916+ C7F1 B7          >                        or a
 917+ C7F2 ED 52                                sbc     hl,de
 918+ C7F4              .Check2YRowOnScreen:    CheckRowHLOnScreen .NoBottomPixelPair
 918+ C7F4 7C          >                        ld      a,h                             ; is h byte set, i.e > 256 or < 0
 918+ C7F5 A7          >                        and     a                               ; .
 918+ C7F6 20 2B       >                        jr      nz,.NoBottomPixelPair                   ; h <> 0 so fails (covers <0 and > 255
 918+ C7F8 7D          >                        ld      a,l                             ; l bit 7 0?
 918+ C7F9 E6 80       >                        and     Bit7Only                        ; covers l > 127 (screen draw area is 0 to 192 / 3 * 2 (128)
 918+ C7FB 20 26       >                        jr      nz,.NoBottomPixelPair                   ;
 919+ C7FD                                      SetIYMinusOffset ixh
 919+ C7FD D5 E5 FD E5 >                        push    de,,hl,,iy                      ; save hl, then hl = iy
 919+ C801 E1          >                        pop     hl                              ;
 919+ C802 DD 7C       >                        ld      a,ixh
 919+ C804 87          >                        add     a,a
 919+ C805 5F          >                        ld      e,a
 919+ C806 16 00       >                        ld      d,0
 919+ C808             >                        ClearCarryFlag
 919+ C808 B7          >                        or a
 919+ C809 ED 52       >                        sbc     hl,de
 919+ C80B E5          >                        push    hl
 919+ C80C FD E1       >                        pop     iy
 919+ C80E E1 D1       >                        pop     de,,hl
 920+ C810              .Write2YCoord:          IYEquRowN l                             ; set up iy as target address
 920+ C810 7D          >                        ld      a,l
 920+ C811 21 9F C0    >                        ld      hl,SBnKLineArray
 920+ C814 ED 31       >                        add     hl,a
 920+ C816 ED 31       >                        add     hl,a
 920+ C818 E5          >                        push    hl
 920+ C819 FD E1       >                        pop     iy
 921+ C81B DD 7D                                ld      a,ixl
 922+ C81D CD B7 C8                             call    ProcessXRowA
 923+ C820 C3 23 C8                             jp      .Plot3
 924+ C823              .NoBottomPixelPair:     ;break
 925+ C823              ; Process CY+X CX+Y & CY+X CX-Y..................................
 926+ C823 2A 2A C5     .Plot3:                 ld      hl, (SunScrnY)
 927+ C826 DD 7D        .Get3YRow:              ld      a,ixl
 928+ C828 ED 31                                add     hl,a                            ; Check to see if CY+Y
 929+ C82A              .Check3YRowOnScreen:    CheckRowHLOnScreen .NoTop3PixelPair
 929+ C82A 7C          >                        ld      a,h                             ; is h byte set, i.e > 256 or < 0
 929+ C82B A7          >                        and     a                               ; .
 929+ C82C 20 26       >                        jr      nz,.NoTop3PixelPair                   ; h <> 0 so fails (covers <0 and > 255
 929+ C82E 7D          >                        ld      a,l                             ; l bit 7 0?
 929+ C82F E6 80       >                        and     Bit7Only                        ; covers l > 127 (screen draw area is 0 to 192 / 3 * 2 (128)
 929+ C831 20 21       >                        jr      nz,.NoTop3PixelPair                   ;
 930+ C833                                      SetIYPlusOffset ixl
 930+ C833 E5 FD E5    >                        push    hl,,iy                          ; save hl, then hl = iy
 930+ C836 E1          >                        pop     hl                              ;
 930+ C837 DD 7D       >                        ld      a,ixl
 930+ C839 ED 31       >                        add     hl,a
 930+ C83B ED 31       >                        add     hl,a
 930+ C83D E5          >                        push    hl
 930+ C83E FD E1       >                        pop     iy
 930+ C840 E1          >                        pop     hl
 931+ C841              .Write3YCoord:          IYEquRowN l                             ; set up iy as target address
 931+ C841 7D          >                        ld      a,l
 931+ C842 21 9F C0    >                        ld      hl,SBnKLineArray
 931+ C845 ED 31       >                        add     hl,a
 931+ C847 ED 31       >                        add     hl,a
 931+ C849 E5          >                        push    hl
 931+ C84A FD E1       >                        pop     iy
 932+ C84C DD 7C                                ld      a,ixh
 933+ C84E CD B7 C8                             call    ProcessXRowA
 934+ C851 C3 54 C8                             jp      .Plot4
 935+ C854              .NoTop3PixelPair:       ;break
 936+ C854              ; Process CY-X CX+Y & CY-X CX-Y..................................
 937+ C854 2A 2A C5     .Plot4:                 ld      hl, (SunScrnY)
 938+ C857 16 00        .Get4YRow:              ld      d,0
 939+ C859 DD 5D                                ld      e,ixl
 940+ C85B                                      ClearCarryFlag
 940+ C85B B7          >                        or a
 941+ C85C ED 52                                sbc     hl,de
 942+ C85E              .Check4YRowOnScreen:    CheckRowHLOnScreen .NoBottom4PixelPair
 942+ C85E 7C          >                        ld      a,h                             ; is h byte set, i.e > 256 or < 0
 942+ C85F A7          >                        and     a                               ; .
 942+ C860 20 28       >                        jr      nz,.NoBottom4PixelPair                   ; h <> 0 so fails (covers <0 and > 255
 942+ C862 7D          >                        ld      a,l                             ; l bit 7 0?
 942+ C863 E6 80       >                        and     Bit7Only                        ; covers l > 127 (screen draw area is 0 to 192 / 3 * 2 (128)
 942+ C865 20 23       >                        jr      nz,.NoBottom4PixelPair                   ;
 943+ C867                                      SetIYMinusOffset ixl
 943+ C867 D5 E5 FD E5 >                        push    de,,hl,,iy                      ; save hl, then hl = iy
 943+ C86B E1          >                        pop     hl                              ;
 943+ C86C DD 7D       >                        ld      a,ixl
 943+ C86E 87          >                        add     a,a
 943+ C86F 5F          >                        ld      e,a
 943+ C870 16 00       >                        ld      d,0
 943+ C872             >                        ClearCarryFlag
 943+ C872 B7          >                        or a
 943+ C873 ED 52       >                        sbc     hl,de
 943+ C875 E5          >                        push    hl
 943+ C876 FD E1       >                        pop     iy
 943+ C878 E1 D1       >                        pop     de,,hl
 944+ C87A              .Write4YCoord:          IYEquRowN l                             ; set up iy as target address
 944+ C87A 7D          >                        ld      a,l
 944+ C87B 21 9F C0    >                        ld      hl,SBnKLineArray
 944+ C87E ED 31       >                        add     hl,a
 944+ C880 ED 31       >                        add     hl,a
 944+ C882 E5          >                        push    hl
 944+ C883 FD E1       >                        pop     iy
 945+ C885 DD 7C                                ld      a,ixh
 946+ C887 CD B7 C8                             call    ProcessXRowA
 947+ C88A              .NoBottom4PixelPair:
 948+ C88A              ; Completed one iteration........................................
 949+ C88A D9                                   exx
 950+ C88B CB 7C        .IncrementCircle:	    bit     7,h				; Check for Hl<=0
 951+ C88D 28 03                                jr z,   .draw_circle_1
 952+ C88F 19                                   add hl,de			; Delta=Delta+D1
 953+ C890 18 05                                jr      .draw_circle_2		;
 954+ C892 09           .draw_circle_1:		    add     hl,bc			; Delta=Delta+D2
 955+ C893 03                                   inc     bc
 956+ C894 03                                   inc     bc				; D2=D2+2
 957+ C895 DD 25                                dec     ixh				; Y=Y-1
 958+ C897 03           .draw_circle_2:		    inc bc				    ; D2=D2+2
 959+ C898 03                                   inc bc
 960+ C899 13                                   inc de				    ; D1=D1+2
 961+ C89A 13                                   inc de
 962+ C89B DD 2C                                inc ixl				    ; X=X+1
 963+ C89D C3 B3 C7                             jp      .CircleLoop
 964+ C8A0 2A 28 C5     SunCircleSinglePixel:     ld      hl,(SunScrnX)
 965+ C8A3 7C                                   ld      a,h
 966+ C8A4 A7                                   and     a
 967+ C8A5 C0                                   ret     nz                  ; if the high byte is set then no pixel
 968+ C8A6 4D                                   ld      c,l
 969+ C8A7 2A 2A C5                             ld      hl,(SunScrnY)
 970+ C8AA 7C                                   ld      a,h
 971+ C8AB A7                                   and     a
 972+ C8AC C0                                   ret     nz                  ; if the high byte is set then no pixel
 973+ C8AD 7D                                   ld      a,l
 974+ C8AE CB 7F                                bit     7,a
 975+ C8B0 C0                                   ret     nz                  ; if l > 127 then no pixel
 976+ C8B1 47                                   ld      b,a
 977+ C8B2 7B                                   ld		a,e
 978+ C8B3 CD 43 E1                             call	l2_plot_pixel_y_test
 979+ C8B6 C9                                   ret
 980+ C8B7
 981+ C8B7              ProcessXRowA:           ;break
 982+ C8B7 2A 28 C5                             ld      hl,(SunScrnX)                    ; get X Center
 983+ C8BA F5                                   push    af                              ; save A (curent offset +/- value
 984+ C8BB ED 31                                add     hl,a                            ; Hl = HL + offset
 985+ C8BD 7C                                   ld      a,h                             ; is HL negative?, if so then set C to 0
 986+ C8BE CB 7F                                bit     7,a                             ;
 987+ C8C0 20 14                                jr      nz,.XCoordNegative              ; We can have this for non X + Radius i.e. the equater
 988+ C8C2 A7                                   and     a                               ; if H <> 0? (why by here must be +ve), set c to $FF
 989+ C8C3 20 16                                jr      nz,.XCoordMaxed                 ; .
 990+ C8C5 4D                                   ld      c,l                             ; else set c to l and do the -ve offset
 991+ C8C6 C5           .AddFuzz:               push    bc
 992+ C8C7 CD 04 89                             call    doRandom                        ; c = c - random AND ragged Size
 993+ C8CA C1                                   pop     bc
 994+ C8CB 21 25 C5                             ld      hl,RaggedSize                   ;
 995+ C8CE A6                                   and     (hl)                            ;
 996+ C8CF 81                                   add     c                               ;
 997+ C8D0 4F                                   ld      c,a                             ;
 998+ C8D1 38 08                                jr      c,.XCoordMaxed                  ; has fuzz caused a carry, if so > 255 to make 255
 999+ C8D3 C3 DD C8                             jp      .ProcessSubtract                ;
1000+ C8D6 0E 00        .XCoordNegative:        ld      c,0                             ; if it was negative then 0
1001+ C8D8 C3 DD C8                             jp      .ProcessSubtract
1002+ C8DB 0E FF        .XCoordMaxed:           ld      c,255                           ; if it was +ve then 255
1003+ C8DD F1           .ProcessSubtract:       pop     af                              ; get offset back
1004+ C8DE 5F                                   ld      e,a                             ; but goes into DE as its a subtract
1005+ C8DF 16 00                                ld      d,0
1006+ C8E1 2A 28 C5                             ld      hl,(SunScrnX)                    ; so do subtract
1007+ C8E4                                      ClearCarryFlag                          ; .
1007+ C8E4 B7          >                        or a
1008+ C8E5 ED 52                                sbc     hl,de                           ; .
1009+ C8E7 FA 04 C9                             jp      m,.XCoordLeftNegative           ; again test for min max
1010+ C8EA E5 C5        .AddFuzzSubtract:       push    hl,,bc
1011+ C8EC CD 04 89                             call    doRandom                        ; c = c - random AND ragged Size
1012+ C8EF C1                                   pop     bc
1013+ C8F0 21 25 C5                             ld      hl,RaggedSize                   ;
1014+ C8F3 A6                                   and     (hl)                            ;
1015+ C8F4 5F                                   ld      e,a
1016+ C8F5 E1                                   pop     hl
1017+ C8F6 ED 52                                sbc     hl,de
1018+ C8F8 FA 04 C9                             jp      m,.XCoordLeftNegative           ; again test for min max
1019+ C8FB 7C                                   ld      a,h
1020+ C8FC A7                                   and     a
1021+ C8FD C2 09 C9                             jp      nz,.XCordLeftMaxed
1022+ C900 45                                   ld      b,l
1023+ C901 C3 0B C9                             jp      .CompletedXCoords
1024+ C904 06 00        .XCoordLeftNegative:    ld      b,0
1025+ C906 C3 0B C9                             jp      .CompletedXCoords
1026+ C909 06 FF        .XCordLeftMaxed:        ld      b,255
1027+ C90B 78           .CompletedXCoords:      ld      a,b
1028+ C90C FD 77 00     .RowSaveIY1             ld      (iy+0),a                        ; iy holds current line array index
1029+ C90F 79                                   ld      a,c
1030+ C910 FD 77 01     .RowSaveIY3             ld      (iy+1),a
1031+ C913 C9                                   ret
1032+ C914
1033+ C914              ; .....................................................
1034+ C914              ; if the universe object is a planet or sun then do that instead
1035+ C914              ;;TODOProcessPlanet:          cp      129
1036+ C914              ;;TODO                        jr      nz, .ItsAPlanet
1037+ C914              ;;TODO.ItsAStar:              ld      a,(SBnKzsgn)
1038+ C914              ;;TODO                        cp      48                               ; if z > 48 (it must be positive to enter this routine)
1039+ C914
1040+ C914
1041+ C914              ; Square Root using tables
1042+ C914              ; DE = number to find
1043+ C914 21 34 CB     SunLookupSqrtDE:        ld      hl,SunSquareRootTable
1044+ C917 7A           .LookupCorseJump:       ld      a,d
1045+ C918 ED 31                                add     hl,a
1046+ C91A ED 31                                add     hl,a
1047+ C91C 7E                                   ld      a,(hl)
1048+ C91D 23                                   inc     hl
1049+ C91E 66                                   ld      h,(hl)
1050+ C91F 6F                                   ld      l,a
1051+ C920 7E           .FineSearchLoop:        ld      a,(hl)
1052+ C921                                      JumpIfAEqNusng  e, .FoundByte
1052+ C921 BB          >                        cp     e
1052+ C922 CA 2E C9    >                        jp      z,.FoundByte
1053+ C925                                      JumpIfAGTENusng e, .PreviousByte
1053+ C925 BB          >                        cp     e
1053+ C926 D2 31 C9    >                        jp		nc,.PreviousByte
1054+ C929 23           .NotFound:              inc     hl
1055+ C92A 23                                   inc     hl
1056+ C92B C3 20 C9                             jp      .FineSearchLoop
1057+ C92E 23           .FoundByte:             inc     hl
1058+ C92F 7E                                   ld      a,(hl)
1059+ C930 C9                                   ret
1060+ C931 2B           .PreviousByte:          dec     hl
1061+ C932 7E                                   ld      a,(hl)
1062+ C933 C9                                   ret
1063+ C934
1064+ C934 34 CB 46 CB  SunRootHighIndex:       DW SunSqr00,SunSqr01,SunSqr02,SunSqr03,SunSqr04,SunSqr05,SunSqr06,SunSqr07,SunSqr08,SunSqr09,SunSqr0A,SunSqr0B,SunSqr0C,SunSqr0D,SunSqr0E,SunSqr0F
1064+ C938 54 CB 60 CB
1064+ C93C 6A CB 72 CB
1064+ C940 7A CB 82 CB
1064+ C944 8A CB 90 CB
1064+ C948 98 CB 9E CB
1064+ C94C A2 CB A8 CB
1064+ C950 AE CB B4 CB
1065+ C954 BA CB C0 CB                          DW SunSqr10,SunSqr11,SunSqr12,SunSqr13,SunSqr14,SunSqr15,SunSqr16,SunSqr17,SunSqr18,SunSqr19,SunSqr1A,SunSqr1B,SunSqr1C,SunSqr1D,SunSqr1E,SunSqr1F
1065+ C958 C6 CB CC CB
1065+ C95C D2 CB D6 CB
1065+ C960 DA CB DC CB
1065+ C964 E0 CB E4 CB
1065+ C968 E8 CB EC CB
1065+ C96C F0 CB F4 CB
1065+ C970 F6 CB FA CB
1066+ C974 FC CB 00 CC                          DW SunSqr20,SunSqr21,SunSqr22,SunSqr23,SunSqr24,SunSqr25,SunSqr26,SunSqr27,SunSqr28,SunSqr29,SunSqr2A,SunSqr2B,SunSqr2C,SunSqr2D,SunSqr2E,SunSqr2F
1066+ C978 04 CC 06 CC
1066+ C97C 08 CC 0C CC
1066+ C980 0E CC 10 CC
1066+ C984 14 CC 16 CC
1066+ C988 18 CC 1A CC
1066+ C98C 1E CC 20 CC
1066+ C990 22 CC 26 CC
1067+ C994 2A CC 2E CC                          DW SunSqr30,SunSqr31,SunSqr32,SunSqr33,SunSqr34,SunSqr35,SunSqr36,SunSqr37,SunSqr38,SunSqr39,SunSqr3A,SunSqr3B,SunSqr3C,SunSqr3D,SunSqr3E,SunSqr3F
1067+ C998 32 CC 36 CC
1067+ C99C 38 CC 3C CC
1067+ C9A0 40 CC 44 CC
1067+ C9A4 46 CC 4A CC
1067+ C9A8 4E CC 52 CC
1067+ C9AC 56 CC 5A CC
1067+ C9B0 5E CC 62 CC
1068+ C9B4 66 CC 6A CC                          DW SunSqr40,SunSqr41,SunSqr42,SunSqr43,SunSqr44,SunSqr45,SunSqr46,SunSqr47,SunSqr48,SunSqr49,SunSqr4A,SunSqr4B,SunSqr4C,SunSqr4D,SunSqr4E,SunSqr4F
1068+ C9B8 6E CC 72 CC
1068+ C9BC 76 CC 7A CC
1068+ C9C0 7E CC 82 CC
1068+ C9C4 86 CC 8A CC
1068+ C9C8 8E CC 92 CC
1068+ C9CC 96 CC 9A CC
1068+ C9D0 9E CC A2 CC
1069+ C9D4 A6 CC A8 CC                          DW SunSqr50,SunSqr51,SunSqr52,SunSqr53,SunSqr54,SunSqr55,SunSqr56,SunSqr57,SunSqr58,SunSqr59,SunSqr5A,SunSqr5B,SunSqr5C,SunSqr5D,SunSqr5E,SunSqr5F
1069+ C9D8 AC CC B0 CC
1069+ C9DC B4 CC B8 CC
1069+ C9E0 BC CC C0 CC
1069+ C9E4 C4 CC C6 CC
1069+ C9E8 CA CC CE CC
1069+ C9EC D2 CC D6 CC
1069+ C9F0 DA CC DC CC
1070+ C9F4 E0 CC E4 CC                          DW SunSqr60,SunSqr61,SunSqr62,SunSqr63,SunSqr64,SunSqr65,SunSqr66,SunSqr67,SunSqr68,SunSqr69,SunSqr6A,SunSqr6B,SunSqr6C,SunSqr6D,SunSqr6E,SunSqr6F
1070+ C9F8 E8 CC EC CC
1070+ C9FC EE CC F2 CC
1070+ CA00 F6 CC FA CC
1070+ CA04 FE CC 00 CD
1070+ CA08 04 CD 08 CD
1070+ CA0C 0C CD 0E CD
1070+ CA10 10 CD 14 CD
1071+ CA14 18 CD 1C CD                          DW SunSqr70,SunSqr71,SunSqr72,SunSqr73,SunSqr74,SunSqr75,SunSqr76,SunSqr77,SunSqr78,SunSqr79,SunSqr7A,SunSqr7B,SunSqr7C,SunSqr7D,SunSqr7E,SunSqr7F
1071+ CA18 20 CD 24 CD
1071+ CA1C 28 CD 2C CD
1071+ CA20 2E CD 32 CD
1071+ CA24 36 CD 38 CD
1071+ CA28 3C CD 40 CD
1071+ CA2C 44 CD 46 CD
1071+ CA30 4A CD 4E CD
1072+ CA34 52 CD 54 CD                          DW SunSqr80,SunSqr81,SunSqr82,SunSqr83,SunSqr84,SunSqr85,SunSqr86,SunSqr87,SunSqr88,SunSqr89,SunSqr8A,SunSqr8B,SunSqr8C,SunSqr8D,SunSqr8E,SunSqr8F
1072+ CA38 58 CD 5A CD
1072+ CA3C 5E CD 62 CD
1072+ CA40 66 CD 68 CD
1072+ CA44 6C CD 70 CD
1072+ CA48 72 CD 76 CD
1072+ CA4C 7A CD 7C CD
1072+ CA50 80 CD 84 CD
1073+ CA54 86 CD 8A CD                          DW SunSqr90,SunSqr91,SunSqr92,SunSqr93,SunSqr94,SunSqr95,SunSqr96,SunSqr97,SunSqr98,SunSqr99,SunSqr9A,SunSqr9B,SunSqr9C,SunSqr9D,SunSqr9E,SunSqr9F
1073+ CA58 8E CD 90 CD
1073+ CA5C 94 CD 98 CD
1073+ CA60 9A CD 9E CD
1073+ CA64 A2 CD A4 CD
1073+ CA68 A8 CD AC CD
1073+ CA6C AE CD B2 CD
1073+ CA70 B6 CD B8 CD
1074+ CA74 BC CD C0 CD                          DW SunSqrA0,SunSqrA1,SunSqrA2,SunSqrA3,SunSqrA4,SunSqrA5,SunSqrA6,SunSqrA7,SunSqrA8,SunSqrA9,SunSqrAA,SunSqrAB,SunSqrAC,SunSqrAD,SunSqrAE,SunSqrAF
1074+ CA78 C2 CD C6 CD
1074+ CA7C C8 CD CC CD
1074+ CA80 D0 CD D2 CD
1074+ CA84 D6 CD D8 CD
1074+ CA88 DC CD E0 CD
1074+ CA8C E2 CD E6 CD
1074+ CA90 EA CD EC CD
1075+ CA94 EE CD F0 CD                          DW SunSqrB0,SunSqrB1,SunSqrB2,SunSqrB3,SunSqrB4,SunSqrB5,SunSqrB6,SunSqrB7,SunSqrB8,SunSqrB9,SunSqrBA,SunSqrBB,SunSqrBC,SunSqrBD,SunSqrBE,SunSqrBF
1075+ CA98 F4 CD F8 CD
1075+ CA9C FA CD FE CD
1075+ CAA0 00 CE 04 CE
1075+ CAA4 08 CE 0C CE
1075+ CAA8 0E CE 10 CE
1075+ CAAC 14 CE 16 CE
1075+ CAB0 1A CE 1E CE
1076+ CAB4 20 CE 24 CE                          DW SunSqrC0,SunSqrC1,SunSqrC2,SunSqrC3,SunSqrC4,SunSqrC5,SunSqrC6,SunSqrC7,SunSqrC8,SunSqrC9,SunSqrCA,SunSqrCB,SunSqrCC,SunSqrCD,SunSqrCE,SunSqrCF
1076+ CAB8 26 CE 2A CE
1076+ CABC 2C CE 30 CE
1076+ CAC0 34 CE 36 CE
1076+ CAC4 38 CE 3A CE
1076+ CAC8 3E CE 40 CE
1076+ CACC 44 CE 48 CE
1076+ CAD0 4A CE 4E CE
1077+ CAD4 50 CE 54 CE                          DW SunSqrD0,SunSqrD1,SunSqrD2,SunSqrD3,SunSqrD4,SunSqrD5,SunSqrD6,SunSqrD7,SunSqrD8,SunSqrD9,SunSqrDA,SunSqrDB,SunSqrDC,SunSqrDD,SunSqrDE,SunSqrDF
1077+ CAD8 56 CE 5A CE
1077+ CADC 5C CE 60 CE
1077+ CAE0 64 CE 66 CE
1077+ CAE4 6A CE 6C CE
1077+ CAE8 70 CE 72 CE
1077+ CAEC 76 CE 78 CE
1077+ CAF0 7A CE 7C CE
1078+ CAF4 80 CE 84 CE                          DW SunSqrE0,SunSqrE1,SunSqrE2,SunSqrE3,SunSqrE4,SunSqrE5,SunSqrE6,SunSqrE7,SunSqrE8,SunSqrE9,SunSqrEA,SunSqrEB,SunSqrEC,SunSqrED,SunSqrEE,SunSqrEF
1078+ CAF8 88 CE 8C CE
1078+ CAFC 90 CE 94 CE
1078+ CB00 96 CE 9A CE
1078+ CB04 9E CE A2 CE
1078+ CB08 A4 CE A8 CE
1078+ CB0C AA CE AC CE
1078+ CB10 AE CE B2 CE
1079+ CB14 B4 CE B6 CE                          DW SunSqrF0,SunSqrF1,SunSqrF2,SunSqrF3,SunSqrF4,SunSqrF5,SunSqrF6,SunSqrF7,SunSqrF8,SunSqrF9,SunSqrFA,SunSqrFB,SunSqrFC,SunSqrFD,SunSqrFE,SunSqrFF
1079+ CB18 B8 CE BC CE
1079+ CB1C BE CE C2 CE
1079+ CB20 C4 CE C8 CE
1079+ CB24 CA CE CE CE
1079+ CB28 D0 CE D4 CE
1079+ CB2C D6 CE DA CE
1079+ CB30 DC CE DE CE
1080+ CB34
1081+ CB34              SunSquareRootTable:
1082+ CB34 00 00        SunSqr00:               DB $00,   0
1083+ CB36 04 02                                DB $04,   2
1084+ CB38 10 04                                DB $10,   4
1085+ CB3A 24 06                                DB $24,   6
1086+ CB3C 40 08                                DB $40,   8
1087+ CB3E 64 0A                                DB $64,  10
1088+ CB40 90 0C                                DB $90,  12
1089+ CB42 C4 0E                                DB $C4,  14
1090+ CB44 FF 0F                                DB $FF,  15
1091+ CB46 00 10        SunSqr01:               DB $00,  16
1092+ CB48 21 11                                DB $21,  17
1093+ CB4A 44 12                                DB $44,  18
1094+ CB4C 69 13                                DB $69,  19
1095+ CB4E 90 14                                DB $90,  20
1096+ CB50 B9 15                                DB $B9,  21
1097+ CB52 FF 16                                DB $FF,  22
1098+ CB54 11 17        SunSqr02:               DB $11,  23
1099+ CB56 40 18                                DB $40,  24
1100+ CB58 71 19                                DB $71,  25
1101+ CB5A A4 1A                                DB $A4,  26
1102+ CB5C D9 1B                                DB $D9,  27
1103+ CB5E FF 1B                                DB $FF,  27
1104+ CB60 10 1C        SunSqr03:               DB $10,  28
1105+ CB62 49 1D                                DB $49,  29
1106+ CB64 84 1E                                DB $84,  30
1107+ CB66 C1 1F                                DB $C1,  31
1108+ CB68 FF 1F                                DB $FF,  31
1109+ CB6A 00 20        SunSqr04:               DB $00,  32
1110+ CB6C 41 21                                DB $41,  33
1111+ CB6E 84 22                                DB $84,  34
1112+ CB70 FF 23                                DB $FF,  35
1113+ CB72 10 24        SunSqr05:               DB $10,  36
1114+ CB74 59 25                                DB $59,  37
1115+ CB76 A4 26                                DB $A4,  38
1116+ CB78 FF 27                                DB $FF,  39
1117+ CB7A 40 28        SunSqr06:               DB $40,  40
1118+ CB7C 91 29                                DB $91,  41
1119+ CB7E E4 2A                                DB $E4,  42
1120+ CB80 FF 2A                                DB $FF,  42
1121+ CB82 39 2B        SunSqr07:               DB $39,  43
1122+ CB84 90 2C                                DB $90,  44
1123+ CB86 E9 2D                                DB $E9,  45
1124+ CB88 FF 2D                                DB $FF,  45
1125+ CB8A 44 2E        SunSqr08:               DB $44,  46
1126+ CB8C A1 2F                                DB $A1,  47
1127+ CB8E FF 2F                                DB $FF,  47
1128+ CB90 00 30        SunSqr09:               DB $00,  48
1129+ CB92 61 31                                DB $61,  49
1130+ CB94 C4 32                                DB $C4,  50
1131+ CB96 FF 32                                DB $FF,  50
1132+ CB98 29 33        SunSqr0A:               DB $29,  51
1133+ CB9A 90 34                                DB $90,  52
1134+ CB9C FF 35                                DB $FF,  53
1135+ CB9E 64 36        SunSqr0B:               DB $64,  54
1136+ CBA0 FF 37                                DB $FF,  55
1137+ CBA2 40 38        SunSqr0C:               DB $40,  56
1138+ CBA4 B1 39                                DB $B1,  57
1139+ CBA6 FF 39                                DB $FF,  57
1140+ CBA8 24 3A        SunSqr0D:               DB $24,  58
1141+ CBAA 99 3B                                DB $99,  59
1142+ CBAC FF 3B                                DB $FF,  59
1143+ CBAE 10 3C        SunSqr0E:               DB $10,  60
1144+ CBB0 89 3D                                DB $89,  61
1145+ CBB2 FF 3D                                DB $FF,  61
1146+ CBB4 04 3E        SunSqr0F:               DB $04,  62
1147+ CBB6 81 3F                                DB $81,  63
1148+ CBB8 FF 3F                                DB $FF,  63
1149+ CBBA 00 40        SunSqr10:               DB $00,  64
1150+ CBBC 81 41                                DB $81,  65
1151+ CBBE FF 41                                DB $FF,  65
1152+ CBC0 04 42        SunSqr11:               DB $04,  66
1153+ CBC2 89 43                                DB $89,  67
1154+ CBC4 FF 43                                DB $FF,  67
1155+ CBC6 10 44        SunSqr12:               DB $10,  68
1156+ CBC8 99 45                                DB $99,  69
1157+ CBCA FF 45                                DB $FF,  69
1158+ CBCC 24 46        SunSqr13:               DB $24,  70
1159+ CBCE B1 47                                DB $B1,  71
1160+ CBD0 FF 47                                DB $FF,  71
1161+ CBD2 40 48        SunSqr14:               DB $40,  72
1162+ CBD4 FF 49                                DB $FF,  73
1163+ CBD6 64 4A        SunSqr15:               DB $64,  74
1164+ CBD8 FF 4B                                DB $FF,  75
1165+ CBDA FF 4C        SunSqr16:               DB $FF,  76
1166+ CBDC C4 4D        SunSqr17:               DB $C4,  77
1167+ CBDE FF 4E                                DB $FF,  78
1168+ CBE0 61 4F        SunSqr18:               DB $61,  79
1169+ CBE2 FF 4F                                DB $FF,  79
1170+ CBE4 00 50        SunSqr19:               DB $00,  80
1171+ CBE6 FF 51                                DB $FF,  81
1172+ CBE8 44 52        SunSqr1A:               DB $44,  82
1173+ CBEA FF 53                                DB $FF,  83
1174+ CBEC 90 54        SunSqr1B:               DB $90,  84
1175+ CBEE FF 54                                DB $FF,  84
1176+ CBF0 39 55        SunSqr1C:               DB $39,  85
1177+ CBF2 FF 56                                DB $FF,  86
1178+ CBF4 FF 57        SunSqr1D:               DB $FF,  87
1179+ CBF6 40 58        SunSqr1E:               DB $40,  88
1180+ CBF8 FF 59                                DB $FF,  89
1181+ CBFA FF 5A        SunSqr1F:               DB $FF,  90
1182+ CBFC 59 5B        SunSqr20:               DB $59,  91
1183+ CBFE FF 5B                                DB $FF,  91
1184+ CC00 10 5C        SunSqr21:               DB $10,  92
1185+ CC02 FF 5D                                DB $FF,  93
1186+ CC04 FF 5E        SunSqr22:               DB $FF,  94
1187+ CC06 FF 5F        SunSqr23:               DB $FF,  95
1188+ CC08 00 60        SunSqr24:               DB $00,  96
1189+ CC0A FF 61                                DB $FF,  97
1190+ CC0C 84 62        SunSqr25:               DB $84,  98
1191+ CC0E 49 63        SunSqr26:               DB $49,  99
1192+ CC10 10 64        SunSqr27:               DB $10, 100
1193+ CC12 FF 65                                DB $FF, 101
1194+ CC14 FF 66        SunSqr28:               DB $FF, 102
1195+ CC16 FF 67        SunSqr29:               DB $FF, 103
1196+ CC18 FF 68        SunSqr2A:               DB $FF, 104
1197+ CC1A 11 69        SunSqr2B:               DB $11, 105
1198+ CC1C FF 6A                                DB $FF, 106
1199+ CC1E FF 6B        SunSqr2C:               DB $FF, 107
1200+ CC20 FF 6C        SunSqr2D:               DB $FF, 108
1201+ CC22 69 6D        SunSqr2E:               DB $69, 109
1202+ CC24 FF 6E                                DB $FF, 110
1203+ CC26 44 6E        SunSqr2F:               DB $44, 110
1204+ CC28 FF 6F                                DB $FF, 111
1205+ CC2A 21 6F        SunSqr30:               DB $21, 111
1206+ CC2C FF 70                                DB $FF, 112
1207+ CC2E 00 70        SunSqr31:               DB $00, 112
1208+ CC30 FF 71                                DB $FF, 113
1209+ CC32 C4 72        SunSqr32:               DB $C4, 114
1210+ CC34 FF 72                                DB $FF, 114
1211+ CC36 FF 73        SunSqr33:               DB $FF, 115
1212+ CC38 90 74        SunSqr34:               DB $90, 116
1213+ CC3A FF 75                                DB $FF, 117
1214+ CC3C 79 75        SunSqr35:               DB $79, 117
1215+ CC3E FF 76                                DB $FF, 118
1216+ CC40 64 76        SunSqr36:               DB $64, 118
1217+ CC42 64 77                                DB $64, 119
1218+ CC44 51 77        SunSqr37:               DB $51, 119
1219+ CC46 40 78        SunSqr38:               DB $40, 120
1220+ CC48 FF 79                                DB $FF, 121
1221+ CC4A 31 79        SunSqr39:               DB $31, 121
1222+ CC4C FF 7A                                DB $FF, 122
1223+ CC4E 24 7A        SunSqr3A:               DB $24, 122
1224+ CC50 FF 7B                                DB $FF, 123
1225+ CC52 19 7B        SunSqr3B:               DB $19, 123
1226+ CC54 FF 7C                                DB $FF, 124
1227+ CC56 10 7C        SunSqr3C:               DB $10, 124
1228+ CC58 FF 7D                                DB $FF, 125
1229+ CC5A 09 7D        SunSqr3D:               DB $09, 125
1230+ CC5C FF 7D                                DB $FF, 125
1231+ CC5E 04 7E        SunSqr3E:               DB $04, 126
1232+ CC60 FF 7E                                DB $FF, 126
1233+ CC62 01 7F        SunSqr3F:               DB $01, 127
1234+ CC64 FF 7F                                DB $FF, 127
1235+ CC66 00 80        SunSqr40:               DB $00, 128
1236+ CC68 FF 80                                DB $FF, 128
1237+ CC6A 01 81        SunSqr41:               DB $01, 129
1238+ CC6C FF 82                                DB $FF, 130
1239+ CC6E 04 82        SunSqr42:               DB $04, 130
1240+ CC70 FF 83                                DB $FF, 131
1241+ CC72 09 83        SunSqr43:               DB $09, 131
1242+ CC74 FF 84                                DB $FF, 132
1243+ CC76 10 84        SunSqr44:               DB $10, 132
1244+ CC78 FF 85                                DB $FF, 133
1245+ CC7A 19 85        SunSqr45:               DB $19, 133
1246+ CC7C FF 86                                DB $FF, 134
1247+ CC7E 24 86        SunSqr46:               DB $24, 134
1248+ CC80 FF 87                                DB $FF, 135
1249+ CC82 31 87        SunSqr47:               DB $31, 135
1250+ CC84 FF 88                                DB $FF, 136
1251+ CC86 40 88        SunSqr48:               DB $40, 136
1252+ CC88 FF 89                                DB $FF, 137
1253+ CC8A 51 89        SunSqr49:               DB $51, 137
1254+ CC8C FF 8A                                DB $FF, 138
1255+ CC8E 64 8A        SunSqr4A:               DB $64, 138
1256+ CC90 FF 8A                                DB $FF, 138
1257+ CC92 79 8B        SunSqr4B:               DB $79, 139
1258+ CC94 FF 8B                                DB $FF, 139
1259+ CC96 90 8C        SunSqr4C:               DB $90, 140
1260+ CC98 FF 8C                                DB $FF, 140
1261+ CC9A A9 8D        SunSqr4D:               DB $A9, 141
1262+ CC9C FF 8D                                DB $FF, 141
1263+ CC9E C4 8E        SunSqr4E:               DB $C4, 142
1264+ CCA0 FF 8E                                DB $FF, 142
1265+ CCA2 E1 8F        SunSqr4F:               DB $E1, 143
1266+ CCA4 FF 8F                                DB $FF, 143
1267+ CCA6 FF 8F        SunSqr50:               DB $FF, 143
1268+ CCA8 00 90        SunSqr51:               DB $00, 144
1269+ CCAA FF 90                                DB $FF, 144
1270+ CCAC 21 91        SunSqr52:               DB $21, 145
1271+ CCAE FF 91                                DB $FF, 145
1272+ CCB0 44 92        SunSqr53:               DB $44, 146
1273+ CCB2 FF 92                                DB $FF, 146
1274+ CCB4 69 93        SunSqr54:               DB $69, 147
1275+ CCB6 FF 93                                DB $FF, 147
1276+ CCB8 90 94        SunSqr55:               DB $90, 148
1277+ CCBA FF 94                                DB $FF, 148
1278+ CCBC B9 95        SunSqr56:               DB $B9, 149
1279+ CCBE FF 95                                DB $FF, 149
1280+ CCC0 E4 96        SunSqr57:               DB $E4, 150
1281+ CCC2 FF 96                                DB $FF, 150
1282+ CCC4 FF 96        SunSqr58:               DB $FF, 150
1283+ CCC6 11 97        SunSqr59:               DB $11, 151
1284+ CCC8 FF 97                                DB $FF, 151
1285+ CCCA 40 98        SunSqr5A:               DB $40, 152
1286+ CCCC FF 98                                DB $FF, 152
1287+ CCCE 71 99        SunSqr5B:               DB $71, 153
1288+ CCD0 FF 99                                DB $FF, 153
1289+ CCD2 A4 9A        SunSqr5C:               DB $A4, 154
1290+ CCD4 FF 9A                                DB $FF, 154
1291+ CCD6 D9 9B        SunSqr5D:               DB $D9, 155
1292+ CCD8 FF 9B                                DB $FF, 155
1293+ CCDA FF 9B        SunSqr5E:               DB $FF, 155
1294+ CCDC 10 9C        SunSqr5F:               DB $10, 156
1295+ CCDE FF 9C                                DB $FF, 156
1296+ CCE0 49 9D        SunSqr60:               DB $49, 157
1297+ CCE2 FF 9D                                DB $FF, 157
1298+ CCE4 84 9E        SunSqr61:               DB $84, 158
1299+ CCE6 FF 9E                                DB $FF, 158
1300+ CCE8 C1 9F        SunSqr62:               DB $C1, 159
1301+ CCEA FF 9F                                DB $FF, 159
1302+ CCEC FF 9F        SunSqr63:               DB $FF, 159
1303+ CCEE 00 A0        SunSqr64:               DB $00, 160
1304+ CCF0 FF A0                                DB $FF, 160
1305+ CCF2 41 A1        SunSqr65:               DB $41, 161
1306+ CCF4 FF A1                                DB $FF, 161
1307+ CCF6 84 A2        SunSqr66:               DB $84, 162
1308+ CCF8 FF A2                                DB $FF, 162
1309+ CCFA C9 A3        SunSqr67:               DB $C9, 163
1310+ CCFC FF A3                                DB $FF, 163
1311+ CCFE FF A3        SunSqr68:               DB $FF, 163
1312+ CD00 10 A4        SunSqr69:               DB $10, 164
1313+ CD02 FF A4                                DB $FF, 164
1314+ CD04 59 A5        SunSqr6A:               DB $59, 165
1315+ CD06 FF A5                                DB $FF, 165
1316+ CD08 A4 A6        SunSqr6B:               DB $A4, 166
1317+ CD0A FF A6                                DB $FF, 166
1318+ CD0C FF A7        SunSqr6C:               DB $FF, 167
1319+ CD0E FF A7        SunSqr6D:               DB $FF, 167
1320+ CD10 40 A8        SunSqr6E:               DB $40, 168
1321+ CD12 FF A8                                DB $FF, 168
1322+ CD14 91 A9        SunSqr6F:               DB $91, 169
1323+ CD16 FF A9                                DB $FF, 169
1324+ CD18 E4 AA        SunSqr70:               DB $E4, 170
1325+ CD1A FF AA                                DB $FF, 170
1326+ CD1C 00 AA        SunSqr71:               DB $00, 170
1327+ CD1E FF AA                                DB $FF, 170
1328+ CD20 39 AB        SunSqr72:               DB $39, 171
1329+ CD22 FF AB                                DB $FF, 171
1330+ CD24 90 AC        SunSqr73:               DB $90, 172
1331+ CD26 FF AC                                DB $FF, 172
1332+ CD28 E9 AD        SunSqr74:               DB $E9, 173
1333+ CD2A FF AD                                DB $FF, 173
1334+ CD2C FF AD        SunSqr75:               DB $FF, 173
1335+ CD2E 44 AE        SunSqr76:               DB $44, 174
1336+ CD30 FF AE                                DB $FF, 174
1337+ CD32 A1 AF        SunSqr77:               DB $A1, 175
1338+ CD34 FF AF                                DB $FF, 175
1339+ CD36 FF AF        SunSqr78:               DB $FF, 175
1340+ CD38 00 B0        SunSqr79:               DB $00, 176
1341+ CD3A FF B0                                DB $FF, 176
1342+ CD3C 61 B1        SunSqr7A:               DB $61, 177
1343+ CD3E FF B1                                DB $FF, 177
1344+ CD40 C4 B2        SunSqr7B:               DB $C4, 178
1345+ CD42 FF B2                                DB $FF, 178
1346+ CD44 FF B2        SunSqr7C:               DB $FF, 178
1347+ CD46 29 B3        SunSqr7D:               DB $29, 179
1348+ CD48 FF B3                                DB $FF, 179
1349+ CD4A 90 B4        SunSqr7E:               DB $90, 180
1350+ CD4C FF B4                                DB $FF, 180
1351+ CD4E F9 B5        SunSqr7F:               DB $F9, 181
1352+ CD50 FF B5                                DB $FF, 181
1353+ CD52 FF B5        SunSqr80:               DB $FF, 181
1354+ CD54 64 B6        SunSqr81:               DB $64, 182
1355+ CD56 FF B6                                DB $FF, 182
1356+ CD58 D1 B7        SunSqr82:               DB $D1, 183
1357+ CD5A FF B7        SunSqr83:               DB $FF, 183
1358+ CD5C FF B7                                DB $FF, 183
1359+ CD5E 40 B8        SunSqr84:               DB $40, 184
1360+ CD60 FF B8                                DB $FF, 184
1361+ CD62 B1 B9        SunSqr85:               DB $B1, 185
1362+ CD64 FF B9                                DB $FF, 185
1363+ CD66 FF B9        SunSqr86:               DB $FF, 185
1364+ CD68 24 BA        SunSqr87:               DB $24, 186
1365+ CD6A FF BA                                DB $FF, 186
1366+ CD6C 99 BB        SunSqr88:               DB $99, 187
1367+ CD6E FF BB                                DB $FF, 187
1368+ CD70 FF BB        SunSqr89:               DB $FF, 187
1369+ CD72 10 BC        SunSqr8A:               DB $10, 188
1370+ CD74 FF BC                                DB $FF, 188
1371+ CD76 89 BD        SunSqr8B:               DB $89, 189
1372+ CD78 FF BD                                DB $FF, 189
1373+ CD7A FF BD        SunSqr8C:               DB $FF, 189
1374+ CD7C 04 BE        SunSqr8D:               DB $04, 190
1375+ CD7E FF BE                                DB $FF, 190
1376+ CD80 81 BF        SunSqr8E:               DB $81, 191
1377+ CD82 FF BF                                DB $FF, 191
1378+ CD84 FF BF        SunSqr8F:               DB $FF, 191
1379+ CD86 00 C0        SunSqr90:               DB $00, 192
1380+ CD88 FF C0                                DB $FF, 192
1381+ CD8A 81 C1        SunSqr91:               DB $81, 193
1382+ CD8C FF C1                                DB $FF, 193
1383+ CD8E FF C1        SunSqr92:               DB $FF, 193
1384+ CD90 04 C2        SunSqr93:               DB $04, 194
1385+ CD92 FF C2                                DB $FF, 194
1386+ CD94 89 C3        SunSqr94:               DB $89, 195
1387+ CD96 FF C3                                DB $FF, 195
1388+ CD98 FF C3        SunSqr95:               DB $FF, 195
1389+ CD9A 10 C4        SunSqr96:               DB $10, 196
1390+ CD9C FF C4                                DB $FF, 196
1391+ CD9E 99 C5        SunSqr97:               DB $99, 197
1392+ CDA0 FF C5                                DB $FF, 197
1393+ CDA2 FF C5        SunSqr98:               DB $FF, 197
1394+ CDA4 24 C6        SunSqr99:               DB $24, 198
1395+ CDA6 FF C6                                DB $FF, 198
1396+ CDA8 B1 C7        SunSqr9A:               DB $B1, 199
1397+ CDAA FF C7                                DB $FF, 199
1398+ CDAC FF C7        SunSqr9B:               DB $FF, 199
1399+ CDAE 40 C8        SunSqr9C:               DB $40, 200
1400+ CDB0 FF C8                                DB $FF, 200
1401+ CDB2 D1 C9        SunSqr9D:               DB $D1, 201
1402+ CDB4 FF C9                                DB $FF, 201
1403+ CDB6 FF C9        SunSqr9E:               DB $FF, 201
1404+ CDB8 64 CA        SunSqr9F:               DB $64, 202
1405+ CDBA FF CA                                DB $FF, 202
1406+ CDBC F9 CB        SunSqrA0:               DB $F9, 203
1407+ CDBE FF CB                                DB $FF, 203
1408+ CDC0 FF CB        SunSqrA1:               DB $FF, 203
1409+ CDC2 90 CC        SunSqrA2:               DB $90, 204
1410+ CDC4 FF CC                                DB $FF, 204
1411+ CDC6 FF CC        SunSqrA3:               DB $FF, 204
1412+ CDC8 29 CD        SunSqrA4:               DB $29, 205
1413+ CDCA FF CD                                DB $FF, 205
1414+ CDCC C4 CE        SunSqrA5:               DB $C4, 206
1415+ CDCE FF CE                                DB $FF, 206
1416+ CDD0 FF CE        SunSqrA6:               DB $FF, 206
1417+ CDD2 61 CF        SunSqrA7:               DB $61, 207
1418+ CDD4 FF CF                                DB $FF, 207
1419+ CDD6 FF CF        SunSqrA8:               DB $FF, 207
1420+ CDD8 00 D0        SunSqrA9:               DB $00, 208
1421+ CDDA FF D0                                DB $FF, 208
1422+ CDDC A1 D1        SunSqrAA:               DB $A1, 209
1423+ CDDE FF D1                                DB $FF, 209
1424+ CDE0 FF D1        SunSqrAB:               DB $FF, 209
1425+ CDE2 44 D2        SunSqrAC:               DB $44, 210
1426+ CDE4 FF D2                                DB $FF, 210
1427+ CDE6 E9 D3        SunSqrAD:               DB $E9, 211
1428+ CDE8 FF D3                                DB $FF, 211
1429+ CDEA FF D3        SunSqrAE:               DB $FF, 211
1430+ CDEC 90 D4        SunSqrAF:               DB $90, 212
1431+ CDEE FF D4        SunSqrB0:               DB $FF, 212
1432+ CDF0 39 D5        SunSqrB1:               DB $39, 213
1433+ CDF2 FF D5                                DB $FF, 213
1434+ CDF4 E4 D6        SunSqrB2:               DB $E4, 214
1435+ CDF6 FF D6                                DB $FF, 214
1436+ CDF8 FF D6        SunSqrB3:               DB $FF, 214
1437+ CDFA 91 D7        SunSqrB4:               DB $91, 215
1438+ CDFC FF D7                                DB $FF, 215
1439+ CDFE FF D7        SunSqrB5:               DB $FF, 215
1440+ CE00 40 D8        SunSqrB6:               DB $40, 216
1441+ CE02 FF D8                                DB $FF, 216
1442+ CE04 F1 D9        SunSqrB7:               DB $F1, 217
1443+ CE06 FF D9                                DB $FF, 217
1444+ CE08 FF D9        SunSqrB8:               DB $FF, 217
1445+ CE0A FF D9                                DB $FF, 217
1446+ CE0C A4 DA        SunSqrB9:               DB $A4, 218
1447+ CE0E FF DA        SunSqrBA:               DB $FF, 218 ; we can reuse SunSeqrBA as  $FF for B9 terminator as well as they have the same target
1448+ CE10 59 DB        SunSqrBB:               DB $59, 219
1449+ CE12 FF DB                                DB $FF, 219
1450+ CE14 FF DB        SunSqrBC:               DB $FF, 219
1451+ CE16 10 DC        SunSqrBD:               DB $10, 220
1452+ CE18 FF DC                                DB $FF, 220
1453+ CE1A C9 DD        SunSqrBE:               DB $C9, 221
1454+ CE1C FF DD                                DB $FF, 221
1455+ CE1E FF DD        SunSqrBF:               DB $FF, 221
1456+ CE20 84 DE        SunSqrC0:               DB $84, 222
1457+ CE22 FF DE                                DB $FF, 222
1458+ CE24 FF DE        SunSqrC1:               DB $FF, 222
1459+ CE26 41 DF        SunSqrC2:               DB $41, 223
1460+ CE28 FF DF                                DB $FF, 223
1461+ CE2A FF DF        SunSqrC3:               DB $FF, 223
1462+ CE2C 00 E0        SunSqrC4:               DB $00, 224
1463+ CE2E FF E0                                DB $FF, 224
1464+ CE30 C1 E1        SunSqrC5:               DB $C1, 225
1465+ CE32 FF E1                                DB $FF, 225
1466+ CE34 FF E1        SunSqrC6:               DB $FF, 225
1467+ CE36 84 E2        SunSqrC7:               DB $84, 226
1468+ CE38 FF E2        SunSqrC8:               DB $FF, 226
1469+ CE3A 49 E3        SunSqrC9:               DB $49, 227
1470+ CE3C FF E3                                DB $FF, 227
1471+ CE3E FF E4        SunSqrCA:               DB $FF, 228
1472+ CE40 10 E4        SunSqrCB:               DB $10, 228
1473+ CE42 FF E4                                DB $FF, 228
1474+ CE44 D9 E5        SunSqrCC:               DB $D9, 229
1475+ CE46 FF E5                                DB $FF, 229
1476+ CE48 FF E5        SunSqrCD:               DB $FF, 229
1477+ CE4A A4 E6        SunSqrCE:               DB $A4, 230
1478+ CE4C FF E6                                DB $FF, 230
1479+ CE4E FF E6        SunSqrCF:               DB $FF, 230
1480+ CE50 71 E7        SunSqrD0:               DB $71, 231
1481+ CE52 FF E7                                DB $FF, 231
1482+ CE54 FF E7        SunSqrD1:               DB $FF, 231
1483+ CE56 40 E8        SunSqrD2:               DB $40, 232
1484+ CE58 FF E8                                DB $FF, 232
1485+ CE5A FF E8        SunSqrD3:               DB $FF, 232
1486+ CE5C 11 E9        SunSqrD4:               DB $11, 233
1487+ CE5E FF E9                                DB $FF, 233
1488+ CE60 E4 EA        SunSqrD5:               DB $E4, 234
1489+ CE62 FF EA                                DB $FF, 234
1490+ CE64 FF EA        SunSqrD6:               DB $FF, 234
1491+ CE66 B9 EB        SunSqrD7:               DB $B9, 235
1492+ CE68 FF EB                                DB $FF, 235
1493+ CE6A FF EB        SunSqrD8:               DB $FF, 235
1494+ CE6C 90 EC        SunSqrD9:               DB $90, 236
1495+ CE6E FF EC                                DB $FF, 236
1496+ CE70 FF EC        SunSqrDA:               DB $FF, 236
1497+ CE72 69 ED        SunSqrDB:               DB $69, 237
1498+ CE74 FF ED                                DB $FF, 237
1499+ CE76 FF ED        SunSqrDC:               DB $FF, 237
1500+ CE78 44 EE        SunSqrDD:               DB $44, 238
1501+ CE7A FF EE        SunSqrDE:               DB $FF, 238
1502+ CE7C 21 EF        SunSqrDF:               DB $21, 239
1503+ CE7E FF EF                                DB $FF, 239
1504+ CE80 00 F0        SunSqrE0:               DB $00, 240
1505+ CE82 FF F0                                DB $FF, 240
1506+ CE84 00 F0        SunSqrE1:               DB $00, 240
1507+ CE86 FF F0                                DB $FF, 240
1508+ CE88 E1 F1        SunSqrE2:               DB $E1, 241
1509+ CE8A FF F1                                DB $FF, 241
1510+ CE8C E1 F1        SunSqrE3:               DB $E1, 241
1511+ CE8E FF F1                                DB $FF, 241
1512+ CE90 C4 F2        SunSqrE4:               DB $C4, 242
1513+ CE92 FF F2                                DB $FF, 242
1514+ CE94 FF F2        SunSqrE5:               DB $FF, 242
1515+ CE96 A9 F3        SunSqrE6:               DB $A9, 243
1516+ CE98 FF F3                                DB $FF, 243
1517+ CE9A FF F3        SunSqrE7:               DB $FF, 243
1518+ CE9C FF F3                                DB $FF, 243
1519+ CE9E 90 F3        SunSqrE8:               DB $90, 243
1520+ CEA0 FF F4                                DB $FF, 244
1521+ CEA2 FF F4        SunSqrE9:               DB $FF, 244
1522+ CEA4 79 F5        SunSqrEA:               DB $79, 245
1523+ CEA6 FF F5                                DB $FF, 245
1524+ CEA8 FF F5        SunSqrEB:               DB $FF, 245
1525+ CEAA 64 F6        SunSqrEC:               DB $64, 246
1526+ CEAC FF F6        SunSqrED:               DB $FF, 246
1527+ CEAE 51 F7        SunSqrEE:               DB $51, 247
1528+ CEB0 FF F7                                DB $FF, 247
1529+ CEB2 FF F7        SunSqrEF:               DB $FF, 247
1530+ CEB4 40 F8        SunSqrF0:               DB $40, 248
1531+ CEB6 FF F8        SunSqrF1:               DB $FF, 248
1532+ CEB8 31 F9        SunSqrF2:               DB $31, 249
1533+ CEBA FF F9                                DB $FF, 249
1534+ CEBC FF F9        SunSqrF3:               DB $FF, 249
1535+ CEBE 24 FA        SunSqrF4:               DB $24, 250
1536+ CEC0 FF FA                                DB $FF, 250
1537+ CEC2 FF FA        SunSqrF5:               DB $FF, 250
1538+ CEC4 19 FB        SunSqrF6:               DB $19, 251
1539+ CEC6 FF FB                                DB $FF, 251
1540+ CEC8 FF FB        SunSqrF7:               DB $FF, 251
1541+ CECA 10 FC        SunSqrF8:               DB $10, 252
1542+ CECC FF FC                                DB $FF, 252
1543+ CECE FF FC        SunSqrF9:               DB $FF, 252
1544+ CED0 09 FD        SunSqrFA:               DB $09, 253
1545+ CED2 FF FD                                DB $FF, 253
1546+ CED4 FF FD        SunSqrFB:               DB $FF, 253
1547+ CED6 04 FE        SunSqrFC:               DB $04, 254
1548+ CED8 FF FE                                DB $FF, 254
1549+ CEDA FF FE        SunSqrFD:               DB $FF, 254
1550+ CEDC 01 FF        SunSqrFE:               DB $01, 255
1551+ CEDE FF FF        SunSqrFF:               DB $FF, 255
1552+ CEE0
1553+ CEE0
1554+ CEE0
1555+ CEE0              SunBankSize  EQU $ - StartOfSun
1556+ CEE0
1557+ CEE0
# file closed: ../Universe/Sun/sun_data.asm
 181  CEE0
 182  CEE0                  SAVENEX OPEN "TestSunRender.nex", $8000 , $7F00
 183  CEE0                  SAVENEX CFG  0,0,0,1
 184  CEE0                  SAVENEX AUTO
 185  CEE0                  SAVENEX CLOSE
 186  CEE0
# file closed: TestSunRender.asm
