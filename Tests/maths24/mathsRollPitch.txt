# file opened: mathsRollPitch.asm
  1   0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
  2   0000                              DISPLAY "mathsRollPitch test"
  3   0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
  4   0000
  5   0000
  6   0000                  DEFINE DEBUGMODE 1
  7   0000                  DEVICE ZXSPECTRUMNEXT
  8   0000                  SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
  9   0000                  ;DEFINE  TESTING_MATHS_DIVIDE 1
 10   0000                  DEFINE  TESTING_ROLL_PITCH 1
 11   0000               CSPECTMAP mathsRollPitch.map
 12   0000               OPT --zxnext=cspect --syntax=a --reversepop
 13   0000                              DEFINE  SOUNDPACE 3
 14   0000              ;                DEFINE  ENABLE_SOUND 1
 15   0000                             DEFINE     MAIN_INTERRUPTENABLE 1
 16   0000              ;               DEFINE INTERRUPT_BLOCKER 1
 17   0000              DEBUGSEGSIZE   equ 1
 18   0000              DEBUGLOGSUMMARY equ 1
 19   0000              ;DEBUGLOGDETAIL equ 1
 20   0000
 21   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 22   0000              ; Game Defines
 23   0000              ScreenLocal      EQU 0
 24   0000              ScreenGalactic   EQU ScreenLocal + 1
 25   0000              ScreenMarket     EQU ScreenGalactic + 1
 26   0000              ScreenMarketDsp  EQU ScreenMarket + 1
 27   0000              ScreenStatus     EQU ScreenMarketDsp + 1
 28   0000              ScreenInvent     EQU ScreenStatus + 1
 29   0000              ScreenPlanet     EQU ScreenInvent + 1
 30   0000              ScreenEquip      EQU ScreenPlanet + 1
 31   0000              ScreenLaunch     EQU ScreenEquip + 1
 32   0000              ScreenFront      EQU ScreenLaunch + 1
 33   0000              ScreenAft        EQU ScreenFront+1
 34   0000              ScreenLeft       EQU ScreenAft+1
 35   0000              ScreenRight      EQU ScreenLeft+1
 36   0000              ScreenDocking    EQU ScreenRight+1
 37   0000              ScreenHyperspace EQU ScreenDocking+1
 38   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 39   0000              ; Colour Defines
 40   0000              SignMask8Bit		equ %01111111
 41   0000              SignMask16Bit		equ %0111111111111111
 42   0000              SignOnly8Bit		equ $80
 43   0000              SignOnly16Bit		equ $8000
 44   0000
 45   0000              Bit7Only            equ %10000000
 46   0000              Bit6Only            equ %01000000
 47   0000              Bit5Only            equ %00100000
 48   0000              Bit4Only            equ %00010000
 49   0000              Bit3Only            equ %00001000
 50   0000              Bit2Only            equ %00000100
 51   0000              Bit1Only            equ %00000010
 52   0000              Bit0Only            equ %00000001
 53   0000              Bit7Clear           equ %01111111
 54   0000              Bit6Clear           equ %10111111
 55   0000              Bit5Clear           equ %11011111
 56   0000              Bit4Clear           equ %11101111
 57   0000              Bit3Clear           equ %11110111
 58   0000              Bit2Clear           equ %11111011
 59   0000              Bit1Clear           equ %11111101
 60   0000              Bit0Clear           equ %11111110
 61   0000              ConstPi				equ $80
 62   0000              ConstNorm           equ 197
 63   0000
 64   0000
 65   0000
 66   0000                                      INCLUDE "../../Macros/jumpMacros.asm"
# file opened: jumpMacros.asm
  1+  0000              JumpIfHLNegative:       MACRO target
  2+  0000 ~                                    bit     7,h
  3+  0000 ~                                    jp      nz,target
  4+  0000                                      ENDM
  5+  0000
  6+  0000              JumpIfPositive:	        MACRO target
  7+  0000 ~                                    jp		p, target
  8+  0000                                      ENDM
  9+  0000
 10+  0000              JumpIfNegative:	        MACRO target
 11+  0000 ~                                    jp		m, target
 12+  0000                                      ENDM
 13+  0000
 14+  0000
 15+  0000              JumpIfUnderflow:	    MACRO target
 16+  0000 ~                                    jp		po, target
 17+  0000                                      ENDM
 18+  0000
 19+  0000              JumpIfOverflow:	        MACRO target
 20+  0000 ~                                    jp		po, target
 21+  0000                                      ENDM
 22+  0000
 23+  0000
 24+  0000              JumpIfNotZero:	        MACRO target
 25+  0000 ~                                    jp	nz,target
 26+  0000                                      ENDM
 27+  0000
 28+  0000              JumpIfZero:	            MACRO target
 29+  0000 ~                                    jp	z,target
 30+  0000                                      ENDM
 31+  0000
 32+  0000              ;.. Bit routines
 33+  0000              JumpOnLeadSignSet:      MACRO   reg, target
 34+  0000 ~                                    ld      a,reg
 35+  0000 ~                                    and     SignOnly8Bit
 36+  0000 ~                                    jp      nz,target
 37+  0000                                      ENDM
 38+  0000
 39+  0000              JumpOnLeadSignClear:    MACRO   reg, target
 40+  0000 ~                                    ld      a,reg
 41+  0000 ~                                    and     SignOnly8Bit
 42+  0000 ~                                    jp      z,target
 43+  0000                                      ENDM
 44+  0000
 45+  0000              JumpOnLeadSignSetA:     MACRO   target
 46+  0000 ~                                    and     SignOnly8Bit
 47+  0000 ~                                    jp      nz,target
 48+  0000                                      ENDM
 49+  0000
 50+  0000              JumpOnLeadSignClearA:   MACRO   target
 51+  0000 ~                                    and     SignOnly8Bit
 52+  0000 ~                                    jp      z,target
 53+  0000                                      ENDM
 54+  0000
 55+  0000              JumpOnMemBitSet:        MACRO mem, bitnbr, target
 56+  0000 ~                                    ld      a,(mem)
 57+  0000 ~                                    bit 	bitnbr,a
 58+  0000 ~                                    jp      nz,target
 59+  0000                                      ENDM
 60+  0000
 61+  0000              JumpOnMemBitClear:      MACRO mem, bitnbr, target
 62+  0000 ~                                    ld      a,(mem)
 63+  0000 ~                                    bit 	bitnbr,a
 64+  0000 ~                                    jp      z,target
 65+  0000                                      ENDM
 66+  0000
 67+  0000
 68+  0000              JumpOnABitSet:          MACRO   bitnbr, target
 69+  0000 ~                                    bit 	bitnbr, a
 70+  0000 ~                                    jp      nz,target
 71+  0000                                      ENDM
 72+  0000
 73+  0000              JumpOnABitClear:        MACRO   bitnbr, target
 74+  0000 ~                                    bit 	bitnbr, a
 75+  0000 ~                                    jp      z,target
 76+  0000                                      ENDM
 77+  0000
 78+  0000              JumpOnABit5Set:         MACRO   target
 79+  0000 ~                                    and     Bit5Only
 80+  0000 ~                                    jp      nz,target
 81+  0000                                      ENDM
 82+  0000
 83+  0000              JumpOnABit5Clear:       MACRO   target
 84+  0000 ~                                    and     Bit5Only
 85+  0000 ~                                    jp      z,target
 86+  0000                                      ENDM
 87+  0000
 88+  0000              JumpOnBitMaskSet:       MACRO   bitmask, target
 89+  0000 ~                                    and     bitmask
 90+  0000 ~                                    jp      nz,target
 91+  0000                                      ENDM
 92+  0000
 93+  0000              JumpOnBitMaskClear:     MACRO   bitmask, target
 94+  0000 ~                                    and     bitmask
 95+  0000 ~                                    jp      z,target
 96+  0000                                      ENDM
 97+  0000
 98+  0000              JumpOnMemBitMaskSet:    MACRO   mem, bitmask, target
 99+  0000 ~                                    ld      a,(mem)
100+  0000 ~                                    and     bitmask
101+  0000 ~                                    jp      nz,target
102+  0000                                      ENDM
103+  0000
104+  0000              JumpOnMemBitMaskClear:  MACRO   mem, bitmask, target
105+  0000 ~                                    ld      a,(mem)
106+  0000 ~                                    and     bitmask
107+  0000 ~                                    jp      z,target
108+  0000                                      ENDM
109+  0000
110+  0000              JumpOnBitSet:           MACRO  reg, bitnbr, target
111+  0000 ~                                    bit 	bitnbr,reg
112+  0000 ~                                    jp      nz,target
113+  0000                                      ENDM
114+  0000
115+  0000              JumpOnBitClear:         MACRO  reg, bitnbr, target
116+  0000 ~                                    bit 	bitnbr,reg
117+  0000 ~                                    jp      z,target
118+  0000                                      ENDM
119+  0000
120+  0000              ; Comparison Routines
121+  0000              JumpIfAGTEusng:         MACRO
122+  0000 ~                                    jp		nc,target
123+  0000                                      ENDM
124+  0000
125+  0000              JumpIfAGTENusng:        MACRO reg,target
126+  0000 ~                                    cp     reg
127+  0000 ~                                    jp		nc,target
128+  0000                                      ENDM
129+  0000
130+  0000              JumpIfAGTEMemusng:      MACRO mem,target
131+  0000 ~                                    ld      hl,mem
132+  0000 ~                                    cp      (hl)
133+  0000 ~                                    jp		nc,target
134+  0000                                      ENDM
135+  0000              JumpIfMemGTENusng:      MACRO mem, value, target
136+  0000 ~                                    ld     a,(mem)
137+  0000 ~                                    cp     value
138+  0000 ~                                    jp	  nc,target
139+  0000                                      ENDM
140+  0000
141+  0000              JumpIfMemGTEMemusng:    MACRO mem, address, target
142+  0000 ~                                    ld   a,(mem)
143+  0000 ~                                    ld   hl,address
144+  0000 ~                                    cp   (hl)
145+  0000 ~                                    jp	  nc,target
146+  0000                                      ENDM
147+  0000
148+  0000              JumpIfMemEqMemusng:     MACRO mem, address, target
149+  0000 ~                                    ld   a,(mem)
150+  0000 ~                                    ld   hl,address
151+  0000 ~                                    cp   (hl)
152+  0000 ~                                    jp	  z,target
153+  0000                                      ENDM
154+  0000
155+  0000              JumpIfMemNeMemusng:     MACRO mem, address, target
156+  0000 ~                                    ld   a,(mem)
157+  0000 ~                                    ld   hl,address
158+  0000 ~                                    cp   (hl)
159+  0000 ~                                    jp	  nz,target
160+  0000                                      ENDM
161+  0000
162+  0000              JumpIfMemTrue:          MACRO mem, target
163+  0000 ~                                    ld      a,(mem)
164+  0000 ~                                    and     a
165+  0000 ~                                    jp      z, target
166+  0000                                      ENDM
167+  0000
168+  0000              JumpIfMemFalse:         MACRO mem, target
169+  0000 ~                                    ld      a,(mem)
170+  0000 ~                                    and     a
171+  0000 ~                                    jp      nz, target
172+  0000                                      ENDM
173+  0000
174+  0000              JumpIfATrue:            MACRO target
175+  0000 ~                                    and     a
176+  0000 ~                                    jp      z, target
177+  0000                                      ENDM
178+  0000
179+  0000              JumpIfAFalse:           MACRO target
180+  0000 ~                                    and     a
181+  0000 ~                                    jp      nz, target
182+  0000                                      ENDM
183+  0000
184+  0000              JumpIfANotFalse:        MACRO target
185+  0000 ~                                    cp      $FF
186+  0000 ~                                    jp      nz, target
187+  0000                                      ENDM
188+  0000
189+  0000              ;-- Less than Macros -------------------------------------------
190+  0000              JumpIfALTMemHLusng:     MACRO target
191+  0000 ~                                    cp    (hl)
192+  0000 ~                                    jp	  c,target
193+  0000                                      ENDM
194+  0000
195+  0000              JumpIfRegLTE:           MACRO   reg, value, target
196+  0000 ~                                    ld      a,reg
197+  0000 ~                                    cp      value
198+  0000 ~                                    jp	    z,target
199+  0000 ~                                    jp		c, target
200+  0000                                      ENDM
201+  0000
202+  0000              JumpIfALTMemusng:       MACRO mem,target
203+  0000 ~                                    ld      hl,mem
204+  0000 ~                                    cp      (hl)
205+  0000 ~                                    jp		c,target
206+  0000                                      ENDM
207+  0000
208+  0000
209+  0000              JumpIfALTusng:          MACRO target
210+  0000 ~                                    jp		c,target
211+  0000                                      ENDM
212+  0000
213+  0000              JumpIfALTNusng:         MACRO value, target
214+  0000 ~                                    cp      value
215+  0000 ~                                    jp		c, target
216+  0000                                      ENDM
217+  0000
218+  0000              JumpIfALTNsigned:       MACRO   value, target
219+  0000 ~                                    cp      value
220+  0000 ~                                    jp      m,.SignSet
221+  0000 ~            .SignClear:             jp      pe,target       ; Sign (0), P/V (1)
222+  0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (0)
223+  0000 ~            .SignSet:               jp      po,target
224+  0000 ~            .CheckComplete:
225+  0000                                      ENDM
226+  0000
227+  0000              JumpIfMemLTNusng:       MACRO mem, value, target
228+  0000 ~                                    ld      a,(mem)
229+  0000 ~                                    cp      value
230+  0000 ~                                    jp	  c,target
231+  0000                                      ENDM
232+  0000
233+  0000              JumpIfMemLTMemusng:     MACRO mem, value, target
234+  0000 ~                                    ld    a,(mem)
235+  0000 ~                                    ld    hl,value
236+  0000 ~                                    cp    (hl)
237+  0000 ~                                    jp	  c,target
238+  0000                                      ENDM
239+  0000              ;-- ------------------------------------------------------------
240+  0000              JumpIfAGTENsigned       MACRO   value, target
241+  0000 ~                                    cp      value
242+  0000 ~                                    jp      m,.SignSet
243+  0000 ~            .SignClear:             jp      po,target       ; Sign (0), P/V (0)
244+  0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (1)
245+  0000 ~            .SignSet:               jp      pe,target
246+  0000 ~            .CheckComplete:
247+  0000                                      ENDM
248+  0000
249+  0000              JumpIfMemEqNusng:       MACRO mem,value,target
250+  0000 ~                                    ld  a,(mem)
251+  0000 ~                                    cp  value
252+  0000 ~                                    jp  z,target
253+  0000                                      ENDM
254+  0000
255+  0000              JumpIfMemNeNusng:       MACRO mem,value,target
256+  0000 ~                                    ld  a,(mem)
257+  0000 ~                                    cp  value
258+  0000 ~                                    jp  nz,target
259+  0000                                      ENDM
260+  0000
261+  0000              JumpIfMemZero:          MACRO mem,target
262+  0000 ~                                    ld  a,(mem)
263+  0000 ~                                    and a
264+  0000 ~                                    jp  z,target
265+  0000                                      ENDM
266+  0000
267+  0000              JumpIfMemNotZero:       MACRO mem,target
268+  0000 ~                                    ld  a,(mem)
269+  0000 ~                                    and a
270+  0000 ~                                    jp  nz,target
271+  0000                                      ENDM
272+  0000
273+  0000              JumpIfANENusng:         MACRO value, target
274+  0000 ~                                    cp     value
275+  0000 ~                                    jp      nz,target
276+  0000                                      ENDM
277+  0000
278+  0000              JumpIfANEquNusng:       MACRO value, target
279+  0000 ~                                    cp     value
280+  0000 ~                                    jp     z,target
281+  0000                                      ENDM
282+  0000
283+  0000              JumpIfANEMemusng:       MACRO  value, target
284+  0000 ~                                    ld    hl,value
285+  0000 ~                                    cp    (hl)
286+  0000 ~                                    jp      nz,target
287+  0000                                      ENDM
288+  0000
289+  0000              JumpIfAEqNusng:         MACRO value, target
290+  0000 ~                                    cp     value
291+  0000 ~                                    jp      z,target
292+  0000                                      ENDM
293+  0000
294+  0000              JumpIfAIsZero:	        MACRO target
295+  0000 ~                                    and     a   ; cp 0 - changed to and a for optimisation but affects other flags
296+  0000 ~                                    jp	    z, target
297+  0000                                      ENDM
298+  0000
299+  0000              JumpIfRegIsNotZero:     MACRO   reg, target
300+  0000 ~                                    ld      a,reg
301+  0000 ~                                    and     a
302+  0000 ~                                    jp	    nz,target
303+  0000                                      ENDM
304+  0000
305+  0000
306+  0000              JumpIfAIsNotZero:       MACRO target
307+  0000 ~                                    and     a
308+  0000 ~                                    jp	    nz,target
309+  0000                                      ENDM
310+  0000
311+  0000              JumpIfMemIsNotZero:     MACRO value, target
312+  0000 ~                                    ld      a,(value)
313+  0000 ~                                    and     a
314+  0000 ~                                    jp	    nz,target
315+  0000                                      ENDM
316+  0000              IfResultZeroGoto:	    MACRO target
317+  0000 ~                                    jp	z,target
318+  0000                                      ENDM
319+  0000
320+  0000              IfResultNotZeroGoto:    MACRO target
321+  0000 ~                                    jp	nz,target
322+  0000                                      ENDM
323+  0000
# file closed: jumpMacros.asm
 67   0000                                      INCLUDE "../../Macros/MathsMacros.asm"
# file opened: MathsMacros.asm
  1+  0000              ZeroA:		            MACRO
  2+  0000 ~                                    xor a
  3+  0000                                      ENDM
  4+  0000              ; sets z flag is HL less than 255 else sets it to nz (note opposite of GT127)
  5+  0000              IsHLGT255:              MACRO
  6+  0000 ~                                    bit     7,h
  7+  0000 ~                                    ret     z
  8+  0000 ~                                    ld      a,h
  9+  0000 ~                                    and     a
 10+  0000                                      ENDM
 11+  0000
 12+  0000              ; Sets z flat if HL = 255 else sets it to nz
 13+  0000              IsHLEqu255:             MACRO
 14+  0000 ~                                    ld      a,h
 15+  0000 ~                                    and     a               ; if its non zero then it can't be 255
 16+  0000 ~                                    ret     nz
 17+  0000 ~                                    ld      a,l
 18+  0000 ~                                    inc     a               ; if it was 255 the inc will set it to zero
 19+  0000                                      ENDM
 20+  0000
 21+  0000              ; Sets Z flag if GT 127 else nz
 22+  0000              IsHLGT127:              MACRO
 23+  0000 ~                                    bit     7,h             ; -ve?
 24+  0000 ~                                    jr      nz,.DoneCheck
 25+  0000 ~                                    ld      a,h             ; +ve > 256?
 26+  0000 ~                                    and     a
 27+  0000 ~                                    jr      nz,.DoneCheck
 28+  0000 ~                                    ld      a,l
 29+  0000 ~                                    and     $80             ; this will set z to false if bit 7 set and clear lower bits
 30+  0000 ~                                    cp      $80             ; this will set z to true if bit 7 set
 31+  0000 ~            .DoneCheck:
 32+  0000                                      ENDM
 33+  0000
 34+  0000              ReturnIfHLGT127:        MACRO
 35+  0000 ~                                    bit     7,h             ; -ve?
 36+  0000 ~                                    jr      nz,.DoneCheck   ; forces check complete
 37+  0000 ~                                    ld      a,h             ; +ve > 256?
 38+  0000 ~                                    and     a               ;
 39+  0000 ~                                    ret     nz              ; forces a return
 40+  0000 ~                                    bit     7,l             ; bit 7 of lower set?
 41+  0000 ~                                    ret     nz              ; forces a return
 42+  0000 ~            .DoneCheck:
 43+  0000                                      ENDM
 44+  0000
 45+  0000              IsDEGT127:              MACRO
 46+  0000 ~                                    bit     7,d
 47+  0000 ~                                    jr      nz,.DoneCheck
 48+  0000 ~                                    ld      a,d
 49+  0000 ~                                    jr      nz,.DoneCheck
 50+  0000 ~                                    ld      a,e
 51+  0000 ~                                    and     $80
 52+  0000 ~            .DoneCheck:
 53+  0000                                      ENDM
 54+  0000
 55+  0000              ABSa2c:                 MACRO
 56+  0000 ~                                    bit     7,a
 57+  0000 ~                                    jp      z,.DoneABSa
 58+  0000 ~                                    neg
 59+  0000 ~            .DoneABSa:
 60+  0000                                      ENDM
 61+  0000
 62+  0000              DEEquSquareA:           MACRO
 63+  0000 ~                                    ld  d,a
 64+  0000 ~                                    ld  e,a
 65+  0000 ~                                    mul de
 66+  0000                                      ENDM
 67+  0000
 68+  0000              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
 69+  0000 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
 70+  0000 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
 71+  0000 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
 72+  0000 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
 73+  0000 ~                                    xor $80                             ;
 74+  0000 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
 75+  0000 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
 76+  0000 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
 77+  0000 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
 78+  0000 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
 79+  0000 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
 80+  0000                                      ENDM
 81+  0000
 82+  0000              SignedHLTo2C:           MACRO
 83+  0000 ~                                    bit     7,h
 84+  0000 ~                                    jr      z,.Done2c
 85+  0000 ~                                    ld      a,h
 86+  0000 ~                                    and     SignMask8Bit
 87+  0000 ~                                    ld      h,a
 88+  0000 ~                                    NegHL
 89+  0000 ~            .Done2c:
 90+  0000                                      ENDM
 91+  0000
 92+  0000              MemSignedTo2C:          MACRO   memfrom
 93+  0000 ~                                    ld      hl,(memfrom)
 94+  0000 ~                                    bit     7,h
 95+  0000 ~                                    jr      z,.Done2c
 96+  0000 ~                                    ld      a,h
 97+  0000 ~                                    and     SignMask8Bit
 98+  0000 ~                                    ld      h,a
 99+  0000 ~            .Done2c:                ld      (memfrom),hl
100+  0000                                      ENDM
101+  0000
102+  0000
103+  0000                  ;returns result in H
104+  0000              EDiv10Inline:           MACRO
105+  0000 ~                                    ld      d,0
106+  0000 ~                                    ld      hl,de
107+  0000 ~                                    add     hl,hl
108+  0000 ~                                    add     hl,de
109+  0000 ~                                    add     hl,hl
110+  0000 ~                                    add     hl,hl
111+  0000 ~                                    add     hl,de
112+  0000 ~                                    add     hl,hl
113+  0000                                      ENDM
114+  0000
115+  0000              cpHLDE:                 MACRO
116+  0000 ~                                    push    hl
117+  0000 ~                                    and     a
118+  0000 ~                                    sbc     hl,de
119+  0000 ~                                    pop     hl
120+  0000                                      ENDM
121+  0000
122+  0000              cpABSDEHL:              MACRO
123+  0000 ~                                    push     hl,,de
124+  0000 ~                                    ld      a,h
125+  0000 ~                                    and     $7F
126+  0000 ~                                    ld      h,a
127+  0000 ~                                    ld      a,d
128+  0000 ~                                    and     $7F
129+  0000 ~                                    ld      d,a
130+  0000 ~                                    ex      de,hl
131+  0000 ~                                    sbc     hl,de
132+  0000 ~                                    pop     hl,,de
133+  0000                                      ENDM
134+  0000
135+  0000              ; Simple are they both the same setting z if they are
136+  0000              ; tehcicall this works but it measn the final ret z is alwys done
137+  0000              ; so jp needs to be to a target
138+  0000              cpHLEquDE:              MACRO   passedCheck
139+  0000 ~                                    ld      a,h
140+  0000 ~                                    cp      d
141+  0000 ~                                    jp      nz, passedCheck
142+  0000 ~                                    ld      a,l
143+  0000 ~                                    cp      e
144+  0000 ~            .NoTheSame:
145+  0000                                      ENDM
146+  0000
147+  0000              cpHLEquBC:              MACRO   passedCheck
148+  0000 ~                                    ld      a,h
149+  0000 ~                                    cp      b
150+  0000 ~                                    jp      nz, passedCheck
151+  0000 ~                                    ld      a,l
152+  0000 ~                                    cp      c
153+  0000 ~            .NoTheSame:
154+  0000                                      ENDM
155+  0000
156+  0000              cpDEEquBC:              MACRO   passedCheck
157+  0000 ~                                    ld      a,d
158+  0000 ~                                    cp      b
159+  0000 ~                                    jp      nz, passedCheck
160+  0000 ~                                    ld      a,e
161+  0000 ~                                    cp      c
162+  0000 ~            .NoTheSame:
163+  0000                                      ENDM
164+  0000              ; Simple version just sets carry if HL < DE reset, does an initial compare for z
165+  0000              cpHLDELeadSign:         MACRO
166+  0000 ~                                    ld      a,h
167+  0000 ~                                    cp      d
168+  0000 ~                                    jr      nz,.FullCompare
169+  0000 ~                                    ld      a,l
170+  0000 ~                                    cp      e
171+  0000 ~                                    ret     z
172+  0000 ~            .FullCompare:           ld      a,h
173+  0000 ~                                    xor     d
174+  0000 ~                                    and     $80
175+  0000 ~                                    jr      nz,.OppositeSigns   ; If opposite signs is a simple sign test
176+  0000 ~                                    ld      a,h                 ; same signs so a little simpler
177+  0000 ~                                    and     $80
178+  0000 ~                                    jp      z,cpHLDE            ; if h is positive then both are positive by here so just cpHLDE
179+  0000 ~                                    jp      cpABSDEHL           ; else we have to do ABScpDEHL
180+  0000 ~            .OppositeSigns:         ld      a,h
181+  0000 ~                                    and     $80
182+  0000 ~                                    and     $80
183+  0000 ~                                    jp      z,.HLGTDE
184+  0000 ~            .HLLTDE:                SetCarryFlag
185+  0000 ~                                    ret
186+  0000 ~            .HLGTDE:                ClearCarryFlag
187+  0000 ~                                    ret
188+  0000                                      ENDM
189+  0000
190+  0000              ;Unsigned
191+  0000              ;If HL == DE, then Z flag is set.
192+  0000              ;If HL != DE, then Z flag is reset.
193+  0000              ;If HL <  DE, then C flag is set.
194+  0000              ;If HL >= DE, then C flag is reset.
195+  0000              ;
196+  0000              ;Signed
197+  0000              ;If HL == DE, then Z flag is set.
198+  0000              ;If HL != DE, then Z flag is reset.
199+  0000              ;If HL <  DE, then S and P/V are different.
200+  0000              ;If HL >= DE, then S and P/V are the same.
201+  0000
202+  0000
203+  0000              N0equN1byN2div256:      MACRO param1,param2,param3
204+  0000 ~                                    ld      a,param3                        ;
205+  0000 ~                                    ld      e,a                         ; use e as var Q = value of XX15 [n] lo
206+  0000 ~                                    ld      a,param2                        ; A = XX16 element
207+  0000 ~                                    ld      d,a
208+  0000 ~                                    mul
209+  0000 ~                                    ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
210+  0000 ~                                    ld      (param1),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
211+  0000                                      ENDM
212+  0000
213+  0000              AequN1xorN2:            MACRO  param1,param2
214+  0000 ~                                    ld      a,(param1)
215+  0000 ~                                    xor     param2
216+  0000                                      ENDM
217+  0000
218+  0000              SpeedMulAxis:           MACRO   speedreg, axis
219+  0000 ~                                    ld      e,speedreg
220+  0000 ~                                    ld      hl,(axis)
221+  0000 ~                                    ld      a,h
222+  0000 ~                                    ClearSignBitA
223+  0000 ~                                    ld      d,a
224+  0000 ~                                    mul     de
225+  0000 ~                                    ld      a,h
226+  0000 ~                                    SignBitOnlyA
227+  0000 ~                                    ld      b,a;ld      c,a
228+  0000 ~                                    ld      h,d;ld      e,d
229+  0000 ~                                    ld      c,0;ld      d,0
230+  0000                                      ENDM
231+  0000
232+  0000              ; Adds speed (8 bit) to vertex (24 bit signed)
233+  0000              AddSpeedToVert:         MACRO   vertex
234+  0000 ~                                    ld      de,(vertex+1)
235+  0000 ~                                    ld      a,(vertex)
236+  0000 ~                                    ld      l,a
237+  0000 ~                                    call    AddBCHtoDELsigned               ; DEL = DEL + BCH
238+  0000 ~                                    ld      a,l
239+  0000 ~                                    ld      (vertex),a
240+  0000 ~                                    ld      (vertex+1),de
241+  0000                                      ENDM
# file closed: MathsMacros.asm
 68   0000                                      INCLUDE "../../Macros/ShiftMacros.asm"
# file opened: ShiftMacros.asm
  1+  0000              ShiftIYRight1: MACRO
  2+  0000 ~                           ld   a,iyh
  3+  0000 ~                           srl  a
  4+  0000 ~                           ld   iyh,a
  5+  0000 ~                           ld   a,iyl
  6+  0000 ~                           rra
  7+  0000 ~                           ld   iyl,a
  8+  0000                             ENDM
  9+  0000
 10+  0000              ShiftIXRight1: MACRO
 11+  0000 ~                           ld   a,ixh
 12+  0000 ~                           srl  a
 13+  0000 ~                           ld   ixh,a
 14+  0000 ~                           ld   a,ixl
 15+  0000 ~                           rra
 16+  0000 ~                           ld   ixl,a
 17+  0000                             ENDM
 18+  0000
 19+  0000              ShiftIXhHLRight1: MACRO
 20+  0000 ~                           ld  a,ixh
 21+  0000 ~                           srl a
 22+  0000 ~                           ld  ixh,a
 23+  0000 ~                           rr  h
 24+  0000 ~                           rr  l
 25+  0000                             ENDM
 26+  0000
 27+  0000              ShiftIYhDERight1: MACRO
 28+  0000 ~                           ld  a,iyh
 29+  0000 ~                           srl a
 30+  0000 ~                           ld  iyh,a
 31+  0000 ~                           rr  d
 32+  0000 ~                           rr  e
 33+  0000                             ENDM
 34+  0000
 35+  0000              ShiftIYlBCRight1: MACRO
 36+  0000 ~                           ld  a,iyl
 37+  0000 ~                           srl a
 38+  0000 ~                           ld  iyl,a
 39+  0000 ~                           rr  b
 40+  0000 ~                           rr  c
 41+  0000                             ENDM
 42+  0000
 43+  0000              ShiftIXlBCRight1: MACRO
 44+  0000 ~                           ld  a,ixl
 45+  0000 ~                           srl a
 46+  0000 ~                           ld  ixl,a
 47+  0000 ~                           rr  b
 48+  0000 ~                           rr  c
 49+  0000                             ENDM
 50+  0000
 51+  0000              ShiftHLRight1: MACRO
 52+  0000 ~                           srl h
 53+  0000 ~                           rr  l
 54+  0000                             ENDM
 55+  0000
 56+  0000              ShiftBHLRight1:MACRO
 57+  0000 ~                           srl b
 58+  0000 ~                           rr h
 59+  0000 ~                           rr  l
 60+  0000                             ENDM
 61+  0000
 62+  0000              ShiftCDERight1:MACRO
 63+  0000 ~                           srl c
 64+  0000 ~                           rr  d
 65+  0000 ~                           rr  e
 66+  0000                             ENDM
 67+  0000
 68+  0000
 69+  0000              SRAHLRight1: MACRO
 70+  0000 ~                           sra h
 71+  0000 ~                           rr  l
 72+  0000                             ENDM
 73+  0000
 74+  0000              ShiftDERight1: MACRO
 75+  0000 ~                           srl d
 76+  0000 ~                           rr  e
 77+  0000                             ENDM
 78+  0000
 79+  0000              ShiftBCRight1: MACRO
 80+  0000 ~                           srl b
 81+  0000 ~                           rr  c
 82+  0000                             ENDM
 83+  0000
 84+  0000
 85+  0000              ShiftHLDiv8:   MACRO
 86+  0000 ~                           srl h
 87+  0000 ~                           rr  l
 88+  0000 ~                           srl h
 89+  0000 ~                           rr  l
 90+  0000 ~                           srl h
 91+  0000 ~                           rr  l
 92+  0000                             ENDM
 93+  0000
 94+  0000              ShiftBHLLeft1:  MACRO
 95+  0000 ~                            sla l
 96+  0000 ~                            rl  h
 97+  0000 ~                            rl  b
 98+  0000                              ENDM
 99+  0000
100+  0000              ShiftCDELeft1:  MACRO
101+  0000 ~                            sla e
102+  0000 ~                            rl  d
103+  0000 ~                            rl  c
104+  0000                              ENDM
105+  0000
106+  0000              ShiftHLLeft1:  MACRO    ; 16 T states
107+  0000 ~                           sla l
108+  0000 ~                           rl  h
109+  0000                             ENDM
110+  0000
111+  0000              ShiftDELeft1:  MACRO    ; 16 T states
112+  0000 ~                           sla e
113+  0000 ~                           rl  d
114+  0000                             ENDM
115+  0000
116+  0000              BarrelHLLeft3: MACRO
117+  0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
118+  0000 ~                           push     bc      ; 10
119+  0000 ~                           ld       b,3     ; 7
120+  0000 ~                           bsrl     de,b    ; 8
121+  0000 ~                           pop      bc      ; 10
122+  0000 ~                           ex       de,hl   ; 4
123+  0000                             ENDM
124+  0000
125+  0000              BarrelHLRight3: MACRO
126+  0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
127+  0000 ~                           push     bc      ; 10
128+  0000 ~                           ld       b,3     ; 7
129+  0000 ~                           bsrl     de,b    ; 8
130+  0000 ~                           pop      bc      ; 10
131+  0000 ~                           ex       de,hl   ; 4
132+  0000                             ENDM
133+  0000
134+  0000              RollBCLeft1:   MACRO    ; 16 T states
135+  0000 ~                           rl  c
136+  0000 ~                           rl  b
137+  0000                             ENDM
138+  0000
139+  0000              RollDELeft1:   MACRO    ; 16 T states
140+  0000 ~                           rl  e
141+  0000 ~                           rl  d
142+  0000                             ENDM
143+  0000
144+  0000              ShiftBCLeft1:  MACRO    ; 16 T states
145+  0000 ~                           sla c
146+  0000 ~                           rl  b
147+  0000                             ENDM
148+  0000
149+  0000              ShiftLeftMem:       MACRO   reg
150+  0000 ~                                ld      hl,reg
151+  0000 ~                                sla     (hl)
152+  0000                                  ENDM
153+  0000
154+  0000
155+  0000
156+  0000              ShiftMem16Right1:   MACRO memaddr
157+  0000 ~                                ld    hl,(memaddr)
158+  0000 ~                                srl   h
159+  0000 ~                                rr    l
160+  0000 ~                                ld    (memaddr),hl
161+  0000                                  ENDM
162+  0000
163+  0000              ShiftMem8Right1:    MACRO memaddr
164+  0000 ~                                ld      a,(memaddr)
165+  0000 ~                                srl     a
166+  0000 ~                                ld      (memaddr),a
167+  0000                                  ENDM
168+  0000
169+  0000
170+  0000              ShiftMem8Left1A:    MACRO memaddr
171+  0000 ~                                ld      a,(memaddr)
172+  0000 ~                                sla     a
173+  0000 ~                                ld      (memaddr),a
174+  0000                                  ENDM
175+  0000
# file closed: ShiftMacros.asm
 69   0000                                      INCLUDE "../../Macros/NegateMacros.asm"
# file opened: NegateMacros.asm
  1+  0000
  2+  0000              macronegate16hl:	MACRO
  3+  0000 ~            					xor 	a
  4+  0000 ~            					sub 	l
  5+  0000 ~            					ld 		l,a
  6+  0000 ~            					sbc 	a,a
  7+  0000 ~            					sub 	h
  8+  0000 ~            					ld 		h,a
  9+  0000              					ENDM
 10+  0000
 11+  0000
 12+  0000              macroAbsHL:         MACRO
 13+  0000 ~                                bit     7,h
 14+  0000 ~                                jp      z,.alreadyABS
 15+  0000 ~            					xor 	a
 16+  0000 ~            					sub 	l
 17+  0000 ~            					ld 		l,a
 18+  0000 ~            					sbc 	a,a
 19+  0000 ~            					sub 	h
 20+  0000 ~            					ld 		h,a
 21+  0000 ~            .alreadyABS:
 22+  0000                                  ENDM
 23+  0000
 24+  0000              macronegate16de:	MACRO
 25+  0000 ~            					xor 	a
 26+  0000 ~                                sub 	e
 27+  0000 ~                                ld 		e,a
 28+  0000 ~                                sbc 	a,a
 29+  0000 ~                                sub 	d
 30+  0000 ~                                ld 		d,a
 31+  0000              					ENDM
 32+  0000
 33+  0000              macronegate16bc:	MACRO
 34+  0000 ~            					xor 	a
 35+  0000 ~                                sub 	c
 36+  0000 ~                                ld 		c,a
 37+  0000 ~                                sbc 	a,a
 38+  0000 ~                                sub 	b
 39+  0000 ~                                ld 		b,a
 40+  0000              					ENDM
 41+  0000
 42+  0000              macronegate16ix:	MACRO
 43+  0000 ~            					xor 	a
 44+  0000 ~                                sub 	ixl
 45+  0000 ~                                ld 		ixl,a
 46+  0000 ~                                sbc 	a,a
 47+  0000 ~                                sub 	ixh
 48+  0000 ~                                ld 		ixh,a
 49+  0000              					ENDM
 50+  0000
 51+  0000
 52+  0000              NegIY:			    MACRO
 53+  0000 ~                                xor a
 54+  0000 ~                                sub iyl
 55+  0000 ~                                ld iyl,a
 56+  0000 ~                                sbc a,a
 57+  0000 ~                                sub iyh
 58+  0000 ~                                ld iyh,a
 59+  0000                                  ENDM
 60+  0000
 61+  0000              NegHL:			    MACRO
 62+  0000 ~                                xor     a
 63+  0000 ~                                sub     l
 64+  0000 ~                                ld      l,a
 65+  0000 ~                                sbc     a,a
 66+  0000 ~                                sub     h
 67+  0000 ~                                ld      h,a
 68+  0000                                  ENDM
 69+  0000
 70+  0000              NegAHL:			    MACRO
 71+  0000 ~                                ld      b,a         ; save a in b
 72+  0000 ~                                xor     a           ; l = 0 - l
 73+  0000 ~                                sub     l
 74+  0000 ~                                ld      l,a
 75+  0000 ~                                sbc     a,a         ; h = 0 - h
 76+  0000 ~                                sub     h
 77+  0000 ~                                ld      h,a
 78+  0000 ~                                sbc     a,a         ; a= 0 - b
 79+  0000 ~                                sub     b
 80+  0000                                  ENDM
 81+  0000
 82+  0000              NegDE:			    MACRO
 83+  0000 ~                                xor a
 84+  0000 ~                                sub e
 85+  0000 ~                                ld e,a
 86+  0000 ~                                sbc a,a
 87+  0000 ~                                sub d
 88+  0000 ~                                ld d,a
 89+  0000                                  ENDM
 90+  0000
 91+  0000              NegBC:			    MACRO
 92+  0000 ~                                xor a
 93+  0000 ~                                sub c
 94+  0000 ~                                ld c,a
 95+  0000 ~                                sbc a,a
 96+  0000 ~                                sub  b
 97+  0000 ~                                ld b,a
 98+  0000                                  ENDM
 99+  0000
100+  0000              NegH                MACRO
101+  0000 ~                                ld      a,h
102+  0000 ~                                neg
103+  0000 ~                                ld      h,a
104+  0000                                  ENDM
105+  0000
106+  0000              NegD                MACRO
107+  0000 ~                                ld      a,d
108+  0000 ~                                neg
109+  0000 ~                                ld      d,a
110+  0000                                  ENDM
111+  0000
112+  0000              NegB                MACRO
113+  0000 ~                                ld      a,b
114+  0000 ~                                neg
115+  0000 ~                                ld      b,a
116+  0000                                  ENDM
117+  0000
# file closed: NegateMacros.asm
 70   0000                                      INCLUDE "../../Macros/carryFlagMacros.asm"
# file opened: carryFlagMacros.asm
  1+  0000
  2+  0000              SetCarryFlag:           MACRO
  3+  0000 ~                                    scf
  4+  0000                                      ENDM
  5+  0000
  6+  0000              ClearCarryFlag:	        MACRO
  7+  0000 ~                                    or a
  8+  0000                                      ENDM
  9+  0000
 10+  0000              FlipCarryFlag:          MACRO
 11+  0000 ~                                    ccf
 12+  0000                                      ENDM
 13+  0000
# file closed: carryFlagMacros.asm
 71   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 72   0000              ; Total screen list
 73   0000              ; Local Chart
 74   0000              ; Galactic Chart
 75   0000              ; Market Prices
 76   0000              ; Inventory
 77   0000              ; Comander status
 78   0000              ; System Data
 79   0000              ; Mission Briefing
 80   0000              ; missio completion
 81   0000              ; Docked  Menu (only place otehr than pause you can load and save)
 82   0000              ; Pause Menu (only place you can load from )
 83   0000              ; byint and selling equipment
 84   0000              ; bying and selling stock
 85   0000
 86   0000              TopOfStack              equ $5CCB ;$6100
 87   0000
 88   0000                                      ORG $5DCB;      $6200
 89   5DCB F3           EliteNextStartup:       di
 90   5DCC FD 00                                break
 91   5DCE
 92   5DCE
 93   5DCE 2A 93 5E     MyRollAndPitch24Bit:    ld      hl,(ALPHA)
 94   5DD1 7C                                   ld      a,h
 95   5DD2 B5                                   or      l
 96   5DD3 C2 D6 5D                             jp      nz,.NotZero
 97   5DD6                                      ;break
 98   5DD6              .NotZero:
 99   5DD6              ;   1. K2 = y - alpha * x
100   5DD6 3A 93 5E     .Step1:                 ld      a,(ALPHA)                   ; Calc alpha * x
101   5DD9 57                                   ld      d,a                         ;
102   5DDA 2A 8B 5E                             ld      hl,(UBnKxhi)                ;
103   5DDD 3A 8A 5E                             ld      a,(UBnKxlo)                 ;
104   5DE0 5F                                   ld      e,a                         ;
105   5DE1                                      ;break
106   5DE1 CD ED 5E                             call    DEHLequHLEmulDs             ; DELC = alpha * x so DEL is what we want
107   5DE4 22 7E 5E                             ld      (Ax),hl                     ;
108   5DE7 ED 53 80 5E                          ld      (Ax+2),de                   ;
109   5DEB 4C           .YMinusAx:              ld      c,h
110   5DEC 3A 8F 5E                             ld      a,(UBnKysgn)
111   5DEF 47                                   ld      b,a
112   5DF0 2A 8D 5E                             ld      hl,(UBnKylo)
113   5DF3                                      ;break
114   5DF3 CD 0F 61                             call    AHLequBHLminusDEC           ; K2 = y - alpha * x
115   5DF6 22 86 5E                             ld      (K2),hl
116   5DF9 32 88 5E                             ld      (K2+2),a
117   5DFC              ;   2. z = z + beta * K2
118   5DFC 5D           .Step2:                 ld      e,l                         ; HEL = AHL
119   5DFD 6C                                   ld      l,h
120   5DFE 67                                   ld      h,a
121   5DFF 3A 94 5E                             ld      a,(BETA)
122   5E02 57                                   ld      d,a
123   5E03                                      ;break
124   5E03 CD ED 5E                             call    DEHLequHLEmulDs             ; DELC = beta * K2 so DEL is what we want
125   5E06 22 7A 5E                             ld      (Bk),hl                     ;
126   5E09 ED 53 7C 5E                          ld      (Bk+2),de                   ;
127   5E0D 4C           .ZPlusBk:               ld      c,h
128   5E0E 2A 90 5E                             ld      hl,(UBnKzlo)
129   5E11 3A 92 5E                             ld      a,(UBnKzsgn)
130   5E14 47                                   ld      b,a
131   5E15                                      ;break
132   5E15                                      DISPLAY "OPTIMISE TO AHL = BHL + DEC to improv post multiply"
133   5E15 CD 01 61                             call    AHLequBHLplusDEC
134   5E18 22 90 5E     .SetZ:                  ld      (UBnKzlo),hl
135   5E1B 32 92 5E                             ld      (UBnKzsgn),a
136   5E1E              ;   3. y = K2 - beta * z
137   5E1E 3A 94 5E     .Step3:                 ld      a,(BETA)
138   5E21 57                                   ld      d,a
139   5E22 2A 91 5E     .GetZBack:              ld      hl,(UBnKzhi)
140   5E25 3A 90 5E                             ld      a,(UBnKzlo)
141   5E28 5F                                   ld      e,a
142   5E29                                      ;break
143   5E29 CD ED 5E                             call    DEHLequHLEmulDs             ; DELC = beta * K2 so DEL is what we want
144   5E2C
145   5E2C 22 76 5E     .K2MinusBZ:             ld      (Bz),hl
146   5E2F ED 53 78 5E                          ld      (Bz+2),de
147   5E33 45                                   ld      b,l
148   5E34 4C                                   ld      c,h
149   5E35 2A 86 5E                             ld      hl,(K2)
150   5E38 3A 88 5E                             ld      a,(K2+2) ; will it go wrong if K2 negative?
151   5E3B 47                                   ld      b,a
152   5E3C                                      ;break
153   5E3C CD 0F 61                             call    AHLequBHLminusDEC          ; y = K2 -Bz
154   5E3F 22 8D 5E     .SetY:                  ld      (UBnKylo),hl
155   5E42 32 8F 5E                             ld      (UBnKysgn),a
156   5E45              ;   4. x = x + alpha * y
157   5E45 FD 00        .Step4:                 break
158   5E47 3A 93 5E                             ld      a,(ALPHA)                   ; Calc alpha * x
159   5E4A 57                                   ld      d,a                         ;
160   5E4B 2A 8E 5E     .GetYBack:              ld      hl,(UBnKyhi)                ;
161   5E4E 3A 8D 5E                             ld      a,(UBnKylo)                 ;
162   5E51 5F                                   ld      e,a                         ;
163   5E52 FD 00                                break
164   5E54 CD ED 5E                             call    DEHLequHLEmulDs             ; DELC = alpha * x so DEL is what we want
165   5E57 22 82 5E                             ld      (Ay),hl                     ;
166   5E5A ED 53 84 5E                          ld      (Ay+2),de                   ;
167   5E5E                                      ; now DEHL holds DELC so we can use that but shift by 8 bits to get correct value to add
168   5E5E                                      ; now d holds sign so we need to pull that back in and get HL into DE  as DE should only ever be S000
169   5E5E 4C           .XPlusAx:               ld      c,h
170   5E5F 3A 8C 5E     .GetXBack:              ld      a,(UBnKxsgn)
171   5E62 47                                   ld      b,a
172   5E63 2A 8A 5E                             ld      hl,(UBnKxlo)
173   5E66 FD 00                                break
174   5E68 CD 01 61                             call    AHLequBHLplusDEC           ; x+ alpha * x
175   5E6B 22 8A 5E     .SetX:                  ld      (UBnKxlo),hl
176   5E6E 32 8C 5E                             ld      (UBnKxsgn),a
177   5E71 FD 00                                break
178   5E73 C3 D6 5D                             jp      .NotZero
179   5E76
180   5E76 00 00 00 00  Bz                      DS  4
181   5E7A 00 00 00 00  Bk                      DS  4
182   5E7E 00 00 00 00  Ax                      DS  4
183   5E82 00 00 00 00  Ay                      DS  4
184   5E86 00 00 00 00  K2                      DS  4
185   5E8A 00           UBnKxlo                 DB  0
186   5E8B 00           UBnKxhi                 DB  0
187   5E8C 00           UBnKxsgn                DB  0
188   5E8D 79           UBnKylo                 DB  $79
189   5E8E 05           UBnKyhi                 DB  $05
190   5E8F 00           UBnKysgn                DB  0
191   5E90 10           UBnKzlo                 DB  $10
192   5E91 64           UBnKzhi                 DB  $64
193   5E92 80           UBnKzsgn                DB  $80
194   5E93 01           ALPHA                   DB  1
195   5E94 00           BETA                    DB  0
196   5E95 00           varQ                    DB  0
197   5E96 00           varRS                   DB  0
198   5E97 C9                                   ret
199   5E98
200   5E98              ;--------------------------------------------------------------------------------------
201   5E98                  INCLUDE	"../../MathsFPS78/asm_multiply_S78.asm"
# file opened: asm_multiply_S78.asm
  1+  5E98              ; asm_mulitply_S78
  2+  5E98              ; Multiplcation routines for Lead sign 7.8 format, adapted based on Q88 format but only respresents negatives by sign bit
  3+  5E98
  4+  5E98              ; replaces all maths multplication
  5+  5E98
  6+  5E98              ; DE = D (S7) * E (S7)
  7+  5E98              ; Optimised mulitploy routines S7 by S7 signed
  8+  5E98              ; muliptiply S7.0 bu ny S7e signed
  9+  5E98              ; used A and B registers
 10+  5E98              ; result in DE
 11+  5E98              ; This replaces DEequDmulEs
 12+  5E98              ; 16 bit HL * DE
 13+  5E98              ; start with lower and help with add sequence           ; all with carry flag (as lower case target reg)
 14+  5E98              ;        L *     E   X0mulY0 1>> 1>>  shift >> 16       ;     HL = L * E
 15+  5E98              ;        L *   D     Y1mulX0 0   1>>  shift >> 8        ;   DEHL = 00HL  + 0[L*D]0
 16+  5E98              ;      H   *     E   X1mulY0 0   1>>  shift >> 8        ;   DEHL = DEHL  + 0[H*E]0 = DEH + 0[H*E]
 17+  5E98              ;      H   *   D     X1mulY1 0   0    shift 0           ;  CDE   = CDE   + 0[H*D]
 18+  5E98              ; 16 bit HL *  E
 19+  5E98              ; start with lower and help with add sequence           ; all with carry flag (as lower case target reg)
 20+  5E98              ;        L *     E   X0mulY0 1>> 1>>  shift >> 16       ;     HL = L * E
 21+  5E98              ;        L *   D     Y1mulX0 0   1>>  shift >> 8        ;   DEHL = 00HL  + 0[L*D]0
 22+  5E98              ;      H   *     E   X1mulY0 0   1>>  shift >> 8        ;   DEHL = DEHL  + 0[H*E]0 = DEH + 0[H*E]
 23+  5E98              ;      H   *   D     X1mulY1 0   0    shift 0           ;  CDE   = CDE   + 0[H*D]
 24+  5E98
 25+  5E98
 26+  5E98
 27+  5E98 7A           DEequDmulEs:        ld      a,d                     ; work out resultant sign and load into b
 28+  5E99 AB                               xor     e                       ; .
 29+  5E9A E6 80                            and     SignOnly8Bit            ; .
 30+  5E9C 47                               ld      b,a                     ; .
 31+  5E9D 7A                               ld      a,d                     ; now clear d sign bit
 32+  5E9E E6 7F                            and     SignMask8Bit            ; .
 33+  5EA0 57                               ld      d,a                     ; .
 34+  5EA1 7B                               ld      a,e                     ; now clear e sign bit
 35+  5EA2 E6 7F                            and     SignMask8Bit            ; .
 36+  5EA4 5F                               ld      e,a                     ; .
 37+  5EA5 ED 30                            mul     de                      ; do mulitply
 38+  5EA7 7A                               ld      a,d                     ; get sign bit from b and re0introduce it
 39+  5EA8 B0                               or      b                       ; .
 40+  5EA9 57                               ld      d,a                     ; .
 41+  5EAA C9                               ret
 42+  5EAB
 43+  5EAB              fixedS158_muls:
 44+  5EAB              ;HL.0 = BH.L * CD.E, does this by scaling down to BH * CD then scaled result up by a word
 45+  5EAB 6C                               ld      l,h
 46+  5EAC 60                               ld      h,b
 47+  5EAD 5A                               ld      e,d
 48+  5EAE 51                               ld      d,c
 49+  5EAF C3 A4 5F                         jp      fixedS78_muls
 50+  5EB2
 51+  5EB2 57           AequAmulEdiv256u:   ld      d,a
 52+  5EB3 ED 30                            mul     de
 53+  5EB5 7A                               ld      a,d
 54+  5EB6 C9                               ret
 55+  5EB7
 56+  5EB7 57           AequAmulQdiv256u:   ld      d,a
 57+  5EB8 3A 95 5E                         ld      a,(varQ)
 58+  5EBB 5F                               ld      e,a
 59+  5EBC ED 30                            mul     de
 60+  5EBE 7A                               ld      a,d
 61+  5EBF C9                               ret
 62+  5EC0
 63+  5EC0              ;HL = HL * DE in 2's compliment
 64+  5EC0 7A           HLequHLmulDE2sc:        ld      a,d
 65+  5EC1 AC                                   xor     h
 66+  5EC2 E6 80                                and     SignOnly8Bit
 67+  5EC4 FD 67                                ld      iyh,a               ; save sign bit for result
 68+  5EC6 7C                                   ld      a,h
 69+  5EC7 E6 80                                and     SignOnly8Bit
 70+  5EC9 28 06                                jr      z,.HLPositive
 71+  5ECB              .HLNegative:            NegHL
 71+  5ECB AF          >                    xor     a
 71+  5ECC 95          >                    sub     l
 71+  5ECD 6F          >                    ld      l,a
 71+  5ECE 9F          >                    sbc     a,a
 71+  5ECF 94          >                    sub     h
 71+  5ED0 67          >                    ld      h,a
 72+  5ED1 7A           .HLPositive:            ld      a,d
 73+  5ED2 E6 80                                and     SignOnly8Bit
 74+  5ED4 28 06                                jr      z,.DEPositive
 75+  5ED6              .DENegative:            NegDE
 75+  5ED6 AF          >                    xor a
 75+  5ED7 93          >                    sub e
 75+  5ED8 5F          >                    ld e,a
 75+  5ED9 9F          >                    sbc a,a
 75+  5EDA 92          >                    sub d
 75+  5EDB 57          >                    ld d,a
 76+  5EDC CD 9E 5F     .DEPositive:            call    HLequHLmulDEu         ; now do calc
 77+  5EDF FD 7C                                ld      a,iyh
 78+  5EE1 A7                                   and     a                   ; if its 0 then we are good
 79+  5EE2 C8                                   ret     z
 80+  5EE3
 81+  5EE3              ; "ASM_FMUTKL .FMLTU	\ -> &2847  \ A=D*E/256unsg  Fast multiply"
 82+  5EE3 ED 30        AequDmulEdiv256u:   mul     de
 83+  5EE5 7A                               ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
 84+  5EE6 C9                               ret
 85+  5EE7              ; DE.LC = HL.E by .D leading Sign (replaces mulHLEbyDSigned)
 86+  5EE7 CD ED 5E     DELCequHLEmulDs:    call    DEHLequHLEmulDs     ; Retained for backwards compatibility until swapped
 87+  5EEA 4D                               ld      c,l                 ; to DEHLequHLEmulDs in all code
 88+  5EEB 6C                               ld      l,h
 89+  5EEC C9                               ret
 90+  5EED
 91+  5EED              ; DE.HL = HL.E by .D leading Sign (replaces mulHLEbyDSigned)
 92+  5EED 7A           DEHLequHLEmulDs:    ld      a,d                 ; get sign from d
 93+  5EEE AC                               xor     h                   ; xor with h to get resultant sign
 94+  5EEF E6 80                            and     SignOnly8Bit        ; .
 95+  5EF1 FD 67                            ld      iyh,a               ; iyh = copy of sign
 96+  5EF3 CB BC                            res     7,h                 ; clear sign bit to get ABS values
 97+  5EF5 CB BA                            res     7,d                 ;
 98+  5EF7 7A           .ChecForZero:       ld      a,d                 ; quick test for d
 99+  5EF8 A7                               and     a
100+  5EF9 28 12                            jr      z,.ResultZero       ; now test HLE
101+  5EFB 7C                               ld      a,h                 ;
102+  5EFC B5                               or      l                   ;
103+  5EFD B3                               or      e                   ;
104+  5EFE 28 0D                            jr      z,.ResultZero       ;
105+  5F00 7A           .LoadForDEHLmulAu:  ld      a,d                 ; we now have divisor set
106+  5F01 53                               ld      d,e
107+  5F02 5C                               ld      e,h
108+  5F03 65                               ld      h,l
109+  5F04 6A                               ld      l,d
110+  5F05 CD 13 5F                         call    DEHLequEHLmulAu
111+  5F08 7A                               ld      a,d
112+  5F09 FD B4                            or      iyh                 ;
113+  5F0B 57                               ld      d,a                 ; d is set , now need to shift about HL into LC (later we will change calls)
114+  5F0C C9                               ret
115+  5F0D              .ResultZero:        ZeroA
115+  5F0D AF          >                        xor a
116+  5F0E 57                               ld      d,a
117+  5F0F 5F                               ld      e,a
118+  5F10 6F                               ld      l,a
119+  5F11 4F                               ld      c,a
120+  5F12 C9                               ret
121+  5F13
122+  5F13
123+  5F13              ; adehl = ehl * a , we will simplify this down to ehl * a (or d?)
124+  5F13              DEHLequEHLmulAu:    ;ld      b,0 ; N/A ld      b,d                       ; relocate DE
125+  5F13 4B                               ld      c,e                 ; x2
126+  5F14 5D                               ld      e,l                 ; x0
127+  5F15 57                               ld      d,a                 ; y0
128+  5F16 ED 30                            mul     de                  ; de = y0*x0
129+  5F18 08                               ex      af,af               ; save y0 'accumulator
130+  5F19 6B                               ld      l,e                 ; l = p0
131+  5F1A 7A                               ld      a,d                 ; a = p1 carry
132+  5F1B 08                               ex      af,af               ; get back y0
133+  5F1C 5C                               ld      e,h                 ; x1
134+  5F1D 57                               ld      d,a                 ; y0
135+  5F1E ED 30                            mul     de                  ; y0*x1
136+  5F20 08                               ex      af,af               ; get back carry
137+  5F21 83                               add     a,e                 ; h = carry + LSW of y0 & x1
138+  5F22 67                               ld      h,a                 ; .
139+  5F23 7A                               ld      a,d                 ; a = p2 carry
140+  5F24 08                               ex      af,af               ; get back y0
141+  5F25 59                               ld      e,c                 ; y0*x2
142+  5F26 57                               ld      d,a                 ; .
143+  5F27 ED 30                            mul     de                  ; .
144+  5F29 08                               ex      af,af               ; get back p2 carry
145+  5F2A 8B                               adc     a,e                 ; and add LWS of y0*x2
146+  5F2B 5F                               ld      e,a                 ; e = p3 so its set
147+  5F2C 7A                               ld      a,d
148+  5F2D CE 00                            adc     a,0                 ; and set d to the carry bit if there was one
149+  5F2F 57                               ld      d,a                 ; d = carry, so the result is DEHL
150+  5F30 C9                               ret
151+  5F31              ; ahl = hl * e simplified 16x8 muliplication
152+  5F31 54           AHLequHLmulE:       ld      d,h                 ; x1
153+  5F32 63                               ld      h,e                 ; y0
154+  5F33 ED 30                            mul     de                  ; x1*y0
155+  5F35 EB                               ex      de,hl
156+  5F36 ED 30                            mul     de                  ; y0*xl, hl = x1*y0l
157+  5F38 7A                               ld      a,d                 ; sum products
158+  5F39 85                               add     a,l
159+  5F3A 57                               ld      d,a
160+  5F3B EB                               ex      de,hl
161+  5F3C 7A                               ld      a,d
162+  5F3D CE 00                            adc     a,0
163+  5F3F C9                               ret
164+  5F40
165+  5F40
166+  5F40                                  DISPLAY "TO DO TEST IF this gets D correct"
167+  5F40                                  ;ld      c,a                 ; c = p2
168+  5F40                                  ;ld      a,d                 ; a = p3 carry
169+  5F40                                  ;ex      af,af
170+  5F40                                  ;ld e,b                     we don;t have x3
171+  5F40                                  ;ld d,a
172+  5F40                                  ;mul de                       ; y*x3
173+  5F40                                  ;ex af,af
174+  5F40                                  ;adc a,e
175+  5F40                                  ;ld b,a                       ;'p3
176+  5F40                                  ;ld a,d                       ;'p4 carry
177+  5F40                                  ;adc a,0                      ;'final carry
178+  5F40
179+  5F40                                  ;ld d,b                       ; return DE
180+  5F40                                  ;ld e,c
181+  5F40
182+  5F40              ; kept for now but think its good to delete
183+  5F40              ;
184+  5F40              ;                    ld      b,d                 ; save Quotient y0
185+  5F40              ;.mul1:              mul     de                  ; [IYL]C = E * D    (p1) (p0) x0 * y0
186+  5F40              ;                    ld      c,e                 ; .
187+  5F40              ;                    ld      iyl,d               ; .
188+  5F40              ;.mul2:              ld      e,l                 ; de = x1 * y0
189+  5F40              ;                    ld      d,b                 ; .
190+  5F40              ;                    mul     de                  ; .
191+  5F40              ;                    ld      a,iyl               ; get back p1 (carry)
192+  5F40              ;.carrybyte1:        add     a,e                 ; l = p1 = p1 + LSW of x1 * y0 and we are doen with carry
193+  5F40              ;                    ld      l,a                 ; .
194+  5F40              ;                    ld      iyl,d               ; save new carry byte MSW of x1 * y0
195+  5F40              ;.mul3:              ld      e,h                 ; E = H * D
196+  5F40              ;                    ld      d,b                 ; .
197+  5F40              ;                    mul     de                  ; .
198+  5F40              ;                    ld      a,iyl
199+  5F40              ;                    adc     a,e                 ; .
200+  5F40              ;                    ld      e,a                 ; .
201+  5F40              ;.ItsNotZero:        ld      a,d                 ;
202+  5F40              ;                    adc     a,0                 ; final carry bit
203+  5F40              ;                    or      iyh                 ; bring back sign
204+  5F40              ;                    ld      d,a                 ; s = sign
205+  5F40              ;                    ret
206+  5F40              ;.ResultZero:        ld      de,0
207+  5F40              ;                    ZeroA
208+  5F40              ;                    ld      c,a
209+  5F40              ;                    ld      l,a
210+  5F40              ;                    ret
211+  5F40                  DISPLAY "TODO replace this with non memory access version"
212+  5F40              HLequSRmulQdiv256:  ;X.Y=x1 lo.S*M/256  	\ where M/256 is gradient replaces HLequSRmulQdiv256
213+  5F40 2A 96 5E                         ld      hl,(varRS)
214+  5F43 3A 95 5E                         ld      a,(varQ)
215+  5F46 C5 D5        HLeqyHLmulAdiv256:  push    bc,,de
216+  5F48 11 00 00                         ld      de,0        ; de = XY
217+  5F4B 47                               ld      b,a         ; b = Q
218+  5F4C                                  ShiftHLRight1
218+  5F4C CB 3C       >               srl h
218+  5F4E CB 1D       >               rr  l
219+  5F50 CB 20                            sla     b
220+  5F52 30 03                            jr      nc,.LL126
221+  5F54 EB           .LL125:             ex      de,hl
222+  5F55 19                               add     hl,de
223+  5F56 EB                               ex      de,hl       ; de = de + rs
224+  5F57              .LL126:             ShiftHLRight1
224+  5F57 CB 3C       >               srl h
224+  5F59 CB 1D       >               rr  l
225+  5F5B CB 20                            sla b
226+  5F5D 38 F5                            jr      c,.LL125
227+  5F5F 20 F6                            jr      nz,.LL126
228+  5F61 EB                               ex      de,hl   ; hl = result
229+  5F62 D1 C1                            pop     bc,,de
230+  5F64 C9                               ret
231+  5F65
232+  5F65              ; AHL = HL * E unsigned, in effect X1 X0 * Y0
233+  5F65 AB           AHLequHLmulEu:      xor     e                       ; .
234+  5F66 E6 80                            and     SignOnly8Bit            ; .
235+  5F68 47                               ld      b,a                     ; .
236+  5F69 7A                               ld      a,d                     ; now clear d sign bit
237+  5F6A E6 7F                            and     SignMask8Bit            ; .
238+  5F6C 57                               ld      d,a                     ; .
239+  5F6D 7B                               ld      a,e                     ; now clear e sign bit
240+  5F6E E6 7F                            and     SignMask8Bit            ; .
241+  5F70 5F                               ld      e,a                     ; .
242+  5F71 ED 30                            mul     de                      ; do mulitply
243+  5F73 7A                               ld      a,d                     ; get sign bit from b and re0introduce it
244+  5F74 B0                               or      b                       ; .
245+  5F75 57                               ld      d,a                     ; .
246+  5F76 C9                               ret
247+  5F77 54           .performMultiplyU:  ld      d,h                     ; de = x1 y0
248+  5F78 63                               ld      h,e                     ; save y0 into h
249+  5F79 ED 30                            mul     de                      ; de = x1 * y0
250+  5F7B EB                               ex      de,hl                   ; de = y0 x0, hl = x1 * y0 (p2 p1)
251+  5F7C ED 30                            mul     de                      ; de = y0 * x0
252+  5F7E 7A                               ld      a,d                     ; sum products y0 * x0 upper byte + x1 * y0 lower byte
253+  5F7F 85                               add     a,l                     ; .
254+  5F80 57                               ld      d,a                     ; d = result (p1)
255+  5F81 EB                               ex      de,hl                   ; hl = p1 p0
256+  5F82 7A                               ld      a,d                     ; a = p2 + carry from add above
257+  5F83 CE 00                            adc     a,0                     ;
258+  5F85 EB                               ex      de,hl                   ; now result is in ADE
259+  5F86 C9                               ret
260+  5F87              ; hl = de * hl where de & hl are small enough to always ne 16 bit result, replaces mulDEbyHL
261+  5F87 C5           HLequDEmulHL:       push    bc
262+  5F88 7A                               ld      a,d                     ; a = x1
263+  5F89 54                               ld      d,h                     ; d = y1
264+  5F8A 67                               ld      h,a                     ; h = x1
265+  5F8B 4B                               ld      c,e                     ; c = x0
266+  5F8C 45                               ld      b,l                     ; b = y0
267+  5F8D ED 30                            mul     de                      ; y1 * y0
268+  5F8F EB                               ex      de,hl
269+  5F90 ED 30                            mul     de                      ; x1 * y0
270+  5F92 19                               add     hl,de                   ; add cross products
271+  5F93 59                               ld      e,c
272+  5F94 50                               ld      d,b
273+  5F95 ED 30                            mul     de                      ; y0 * x0
274+  5F97 7D                               ld      a,l                     ; cross products lsb
275+  5F98 82                               add     a,d                     ; add to msb final
276+  5F99 67                               ld      h,a
277+  5F9A 6B                               ld      l,e                     ; hl = final
278+  5F9B                                  ; 83 cycles, 19 bytes
279+  5F9B AF                               xor     a                       ; reset carry
280+  5F9C C1                               pop     bc
281+  5F9D C9                               ret
282+  5F9E              HLequHLmulDEu:
283+  5F9E              ;H.L = H.L * D.E unsigned S7.8 format, just skips signed bit check
284+  5F9E CD B8 5F                         call    fixedS78_mulu
285+  5FA1 6C                               ld      l,h
286+  5FA2 67                               ld      h,a
287+  5FA3 C9                               ret
288+  5FA4              fixedS78_muls:
289+  5FA4              ;H.L = D.E * H.L as S7.8 Fixed Point maths, when doing 24 bit maths scale down to 8.8 as its accurate enough
290+  5FA4              HL_Mul_DE_88:
291+  5FA4 7A           .checkSigns:        ld      a,d
292+  5FA5 AC                               xor     h
293+  5FA6 E6 80                            and     $80
294+  5FA8 FD 6F                            ld      iyl,a               ; sign bit is the result sign bit held in iy as we want to optimise
295+  5FAA CB BA        .forcePositiveOnly: res     7,d                 ; de = abs de
296+  5FAC CB BC                            res     7,h                 ; hl = abs hl
297+  5FAE CD B8 5F                         call    fixedS78_mulu       ; DEHL = DE * HL,
298+  5FB1 6C           .getS88Result:      ld      l,h                 ; we want to lose D and L as part of return so put EH into HL
299+  5FB2 63                               ld      h,e                 ; .
300+  5FB3 7C                               ld      a,h                 ; now return result with sign bit, if the result over flowed into S88 then it will be out
301+  5FB4 FD B5                            or      iyl                 ;
302+  5FB6 67                               ld      h,a                 ;
303+  5FB7 C9                               ret                         ;
304+  5FB8              ;DE.HL = D.E * H.L as  7.8 Fixed Point unsigned maths, when doing 24 bit maths scale down to 8.8 as its accurate enough
305+  5FB8              fixedS78_mulu:      ;
306+  5FB8 7A           .checkZeroMul:      ld      a,d
307+  5FB9 B3                               or      e
308+  5FBA CA E2 5F                         jp      z,.resultIsZero
309+  5FBD 7C                               ld      a,h
310+  5FBE B5                               or      l
311+  5FBF CA E2 5F                         jp      z, .resultIsZero
312+  5FC2 45           .performMultiplyU:  ld      b,l                 ; b = x0
313+  5FC3 4B                               ld      c,e                 ; c =  y0
314+  5FC4 5D                               ld      e,l                 ; e = x0
315+  5FC5 6A                               ld      l,d                 ; l = y1 d is already y1
316+  5FC6 E5                               push    hl                  ; save x1 y1 to stack
317+  5FC7 69                               ld      l,c                 ; l = y0
318+  5FC8 ED 30                            mul     de                  ; hl  = y1 * x0
319+  5FCA EB                               ex      de,hl               ; . also setting de to x1 y0 as we prepped them in advance
320+  5FCB ED 30                            mul     de                  ; x1*y0
321+  5FCD                                  ZeroA
321+  5FCD AF          >                        xor a
322+  5FCE 19                               add     hl,de               ; sum cross products of y1*x0, x1 * y0 as they require no shifting
323+  5FCF 8F                               adc     a,a                 ; and capture carry bit ready for p3
324+  5FD0 59                               ld      e,c                 ; de = x0 * y0
325+  5FD1 50                               ld      d,b                 ; .
326+  5FD2 ED 30                            mul     de                  ; .
327+  5FD4 47                               ld      b,a                 ; carry from cross products setting bc to <c>h  (where <c> is carry flag)
328+  5FD5 4C                               ld      c,h                 ; .
329+  5FD6 7A                               ld      a,d                 ; h = high byte of x0 * y 0 _ lower byte of cross product of y1 * x0
330+  5FD7 85                               add     a,l                 ; .
331+  5FD8 67                               ld      h,a                 ; .)
332+  5FD9 6B                               ld      l,e                 ; so now we have lower btwo bytes of result in HL (p1 p0)
333+  5FDA D1                               pop de                      ; get x1 and y1 back from stack into de ready for multiply
334+  5FDB ED 30                            mul de                      ; hl = x1*y1 and de = p1 p0
335+  5FDD EB                               ex de,hl                    ; .
336+  5FDE ED 4A                            adc hl,bc                   ; hl = (x1 * y1) + <c>h (where h is upper byte of cross product from above)
337+  5FE0 EB                               ex de,hl                    ; swap over de and hl for final result
338+  5FE1 C9                               ret
339+  5FE2 11 00 00     .resultIsZero:      ld      de,0
340+  5FE5 21 00 00                         ld      hl,0
341+  5FE8 C9                               ret
342+  5FE9
# file closed: asm_multiply_S78.asm
202   5FE9                  INCLUDE	"../../MathsFPS78/asm_divide_S78.asm"
# file opened: asm_divide_S78.asm
  1+  5FE9              ; asm_divide_S78
  2+  5FE9              ; Division routines for Lead sign 7.8 format, adapted based on Q88 format but only respresents negatives by sign bit
  3+  5FE9
  4+  5FE9                  DISPLAY "TODO: Still need an S15.8 / S0.8 which in effect increases the value"
  5+  5FE9              FP88DIVITER:        MACRO
  6+  5FE9 ~                                rla
  7+  5FE9 ~                                adc hl,hl
  8+  5FE9 ~                                add hl,de
  9+  5FE9 ~                                jr c,.NoSubtract
 10+  5FE9 ~                                sbc hl,de
 11+  5FE9 ~            .NoSubtract:
 12+  5FE9                                  ENDM
 13+  5FE9              ;HL = DE/BC as S7.8 Fixed Point maths, when doing 24 bit maths scale down to 8.8 as its accurate enough
 14+  5FE9              ;AHL = BHL/CDE, performed by scaling down BHL and CDE into two S8.8 values then calling fixedS7_8
 15+  5FE9              ; its an approximate as by the time we need a 24 bit divide it will be for objects a long way away
 16+  5FE9 78           fixedS23_8_divs:    ld      a,b               ; prep by saving off sign bit before shifting
 17+  5FEA A9                               xor     c
 18+  5FEB E6 80                            and     $80
 19+  5FED FD 6F                            ld      iyl,a
 20+  5FEF CB B8                            res     7,b                ; clear sign bits of and a
 21+  5FF1 CB B9                            res     7,c                ;
 22+  5FF3 78           .shiftRight24Loop:  ld      a,b                ; scaled down BHL and CDE to just HL and DE
 23+  5FF4 B1                               or      c                  ;
 24+  5FF5 CA 07 60                         jp      z,.ShiftRight16    ; if b and c are clear then we can just do 16 bit shift
 25+  5FF8                                  ShiftBHLRight1             ;
 25+  5FF8 CB 38       >               srl b
 25+  5FFA CB 1C       >               rr h
 25+  5FFC CB 1D       >               rr  l
 26+  5FFE                                  ShiftCDERight1             ;
 26+  5FFE CB 39       >               srl c
 26+  6000 CB 1A       >               rr  d
 26+  6002 CB 1B       >               rr  e
 27+  6004 C3 F3 5F                         jp      .shiftRight24Loop  ;
 28+  6007              .ShiftRight16:
 29+  6007 7C           .ShiftRight16Loop:  ld      a,h                ; scale now just HL and DE
 30+  6008 B2                               or      d                  ; .
 31+  6009 E6 80                            and     $80                ; .
 32+  600B CA 19 60                         jp      z,.ShiftComplete   ; .
 33+  600E                                  ShiftHLRight1              ; .
 33+  600E CB 3C       >               srl h
 33+  6010 CB 1D       >               rr  l
 34+  6012                                  ShiftDERight1              ; .
 34+  6012 CB 3A       >               srl d
 34+  6014 CB 1B       >               rr  e
 35+  6016 C3 07 60                         jp      .ShiftRight16Loop  ; .
 36+  6019 CB C1        .ShiftComplete:     set     0,c                ; fast way to ensure BC is at least not zero, in this case 0.0039 which means we can never have divide by 0
 37+  601B 7C           .checkZeroDivide:   ld      a,h                ; use the result is zero from below to save some code space
 38+  601C B7                               or      a                  ; .
 39+  601D CA 76 60                         jp      z,BC_Div_DE_88.resultIsZero ; as this already zeros A we can use it
 40+  6020 CD 3F 60                         call    BC_Div_DE_88.NegateDE ; now we can just fall into a fixed S7.8 but after all the inital checks have been done
 41+  6023 7C                               ld      a,h                ; now shift result from HL to AHL
 42+  6024 E6 80                            and     $80                ; so A only holds sign bit
 43+  6026 65                               ld      h,l                ;
 44+  6027 CB BC                            res     7,h                ; h will be the abs version
 45+  6029 2E 00                            ld      l,0                ; and decimal will always be 0
 46+  602B C9                               ret                        ;
 47+  602C
 48+  602C
 49+  602C              ;HL = DE/BC as S7.8 Fixed Point maths, when doing 24 bit maths scale down to 8.8 as its accurate enough
 50+  602C 44 4D        fixedS7_8_divs:     ld      bc,hl
 51+  602E              BC_Div_DE_88:
 52+  602E 78           .checkSigns:        ld      a,b
 53+  602F AA                               xor     d
 54+  6030 E6 80                            and     $80
 55+  6032 FD 6F                            ld      iyl,a               ; sign bit is the result sign bit held in iy as we want to optimise
 56+  6034 CB B8        .forcePositiveOnly: res     7,b                ; bc = abs b
 57+  6036 B1           .checkZeroDivide:   or      c                   ; optimisation, if bc was zero then result will be zero
 58+  6037 28 3D                            jr      z,.resultIsZero     ; .
 59+  6039 CB BA        .forceNegativeDW:   res     7,d                 ; first force it positive
 60+  603B 7A           .checkDivideZero:   ld      a,d
 61+  603C B3                               or      e                   ; as we are going to wipe a, do the divide by zero check here as an optimisation
 62+  603D 28 2E                            jr      z,.divideOverflow    ; .
 63+  603F              .NegateDE:          ZeroA                       ; now negate DE
 63+  603F AF          >                        xor a
 64+  6040 93                               sub     e                   ; .
 65+  6041 5F                               ld 		e,a                 ; .
 66+  6042 9F                               sbc 	a,a                 ; .
 67+  6043 92                               sub 	d                   ; .
 68+  6044 57                               ld 		d,a                 ; .
 69+  6045 26 00        .overflowCheck:     ld      h,0                 ; prepare h = 0 for a slight optimise
 70+  6047 78                               ld      a,b                 ; if B+DE>=0, then we'll have overflow
 71+  6048 83                               add     e                   ; .
 72+  6049 7A                               ld      a,d                 ; .
 73+  604A CE 00                            adc     a,0                 ; .
 74+  604C 78                               ld a,b
 75+  604D 83                               add a,e
 76+  604E 7A                               ld a,d
 77+  604F 8C                               adc a,h
 78+  6050 38 1B                            jr c,.divideOverflow
 79+  6052 68           .prepRemainder:     ld      l,b                 ; h is already 0 from overflow Check so now hl = 0b
 80+  6053 79                               ld      a,c                 ; and a = c
 81+  6054 CD 7A 60                         call    div_S88_sub
 82+  6057 4F                               ld      c,a
 83+  6058 78                               ld      a,b      ;A is now 0
 84+  6059 CD 7A 60                         call    div_S88_sub
 85+  605C 29           .CheckRounding:     add     hl,hl; if 2HL+DE>=0, increment result to round.
 86+  605D 19                               add     hl,de
 87+  605E 61                               ld      h,c
 88+  605F 6F                               ld      l,a
 89+  6060 30 01                            jr      nc,.NoIncrementNeeded
 90+  6062 23                               inc     hl
 91+  6063 CB 7C        .NoIncrementNeeded: bit 7,h                     ; Now check if H is overflowed
 92+  6065 20 06                            jr nz,.divideOverflow
 93+  6067 FD 7D                            ld      a,iyl               ; get back sign bit
 94+  6069 B4                               or      h
 95+  606A 67                               ld      h,a                 ; now set h to correct sign
 96+  606B                                  ClearCarryFlag              ; and we have a success
 96+  606B B7          >                        or a
 97+  606C C9                               ret
 98+  606D 2E FF        .divideOverflow:    ld      l,$FF               ; hl = +/-128.255 signed
 99+  606F FD 7D                            ld      a,iyl               ; .
100+  6071 F6 7F                            or      $7F                 ; .
101+  6073 67                               ld      h,a
102+  6074                                  SetCarryFlag
102+  6074 37          >                        scf
103+  6075 C9                               ret
104+  6076              .resultIsZero       ZeroA                       ; doign it this way saves a couple of clock cycles as we get the carry clear for free even if setting hl takes an extra 2 cycles
104+  6076 AF          >                        xor a
105+  6077 67                               ld      h,a
106+  6078 6F                               ld      l,a
107+  6079 C9                               ret
108+  607A              div_S88_sub:        FP88DIVITER
108+  607A 17          >                    rla
108+  607B ED 6A       >                    adc hl,hl
108+  607D 19          >                    add hl,de
108+  607E 38 02       >                    jr c,.NoSubtract
108+  6080 ED 52       >                    sbc hl,de
108+  6082             >.NoSubtract:
109+  6082                                  FP88DIVITER
109+  6082 17          >                    rla
109+  6083 ED 6A       >                    adc hl,hl
109+  6085 19          >                    add hl,de
109+  6086 38 02       >                    jr c,.NoSubtract
109+  6088 ED 52       >                    sbc hl,de
109+  608A             >.NoSubtract:
110+  608A                                  FP88DIVITER
110+  608A 17          >                    rla
110+  608B ED 6A       >                    adc hl,hl
110+  608D 19          >                    add hl,de
110+  608E 38 02       >                    jr c,.NoSubtract
110+  6090 ED 52       >                    sbc hl,de
110+  6092             >.NoSubtract:
111+  6092                                  FP88DIVITER
111+  6092 17          >                    rla
111+  6093 ED 6A       >                    adc hl,hl
111+  6095 19          >                    add hl,de
111+  6096 38 02       >                    jr c,.NoSubtract
111+  6098 ED 52       >                    sbc hl,de
111+  609A             >.NoSubtract:
112+  609A                                  FP88DIVITER
112+  609A 17          >                    rla
112+  609B ED 6A       >                    adc hl,hl
112+  609D 19          >                    add hl,de
112+  609E 38 02       >                    jr c,.NoSubtract
112+  60A0 ED 52       >                    sbc hl,de
112+  60A2             >.NoSubtract:
113+  60A2                                  FP88DIVITER
113+  60A2 17          >                    rla
113+  60A3 ED 6A       >                    adc hl,hl
113+  60A5 19          >                    add hl,de
113+  60A6 38 02       >                    jr c,.NoSubtract
113+  60A8 ED 52       >                    sbc hl,de
113+  60AA             >.NoSubtract:
114+  60AA                                  FP88DIVITER
114+  60AA 17          >                    rla
114+  60AB ED 6A       >                    adc hl,hl
114+  60AD 19          >                    add hl,de
114+  60AE 38 02       >                    jr c,.NoSubtract
114+  60B0 ED 52       >                    sbc hl,de
114+  60B2             >.NoSubtract:
115+  60B2                                  FP88DIVITER
115+  60B2 17          >                    rla
115+  60B3 ED 6A       >                    adc hl,hl
115+  60B5 19          >                    add hl,de
115+  60B6 38 02       >                    jr c,.NoSubtract
115+  60B8 ED 52       >                    sbc hl,de
115+  60BA             >.NoSubtract:
116+  60BA 8F                               adc a,a
117+  60BB C9                               ret
118+  60BC
119+  60BC
# file closed: asm_divide_S78.asm
203   60BC                  INCLUDE	"../../Maths24/asm_addition24.asm"
# file opened: asm_addition24.asm
  1+  60BC              ; Addition---------------------------------------------------
  2+  60BC              ; BAHL = BHL+CDE Lead Sign bit - If overflows AHL then carry will be set resulting in B holding sign and rest of value, else AHL holds value
  3+  60BC              ; in reality will we aim for all values being S14.8 so bit 15 is always clear for overflow
  4+  60BC 78           AHLequBHLplusCDE:       ld      a,b                          ; if b sign and c sign were different then bit 7 of a will be 1 which means
  5+  60BD E6 80                                and     $80                          ; Signs are opposite there fore we can subtract to get difference
  6+  60BF A9                                   xor     c                            ;
  7+  60C0                                      JumpIfNegative .OppositeSigns        ;
  7+  60C0 FA E1 60    >                        jp		m, .OppositeSigns
  8+  60C3 78           .SameSigns:             ld      a,b                          ; if they are both negative
  9+  60C4 B1                                   or      c                            ; then we can do an add but also set the sign bit
 10+  60C5                                      JumpIfNegative .BothNegative         ; optimisation so we can just do simple add if both positive
 10+  60C5 FA D0 60    >                        jp		m, .BothNegative
 11+  60C8 ED 5A        .BothPositive:          adc     hl,de                        ; both positive so a will already be zero
 12+  60CA 78                                   ld      a,b                          ; a = b + c + an carry from HL + DE
 13+  60CB 89                                   adc     c                            ;
 14+  60CC D0                                   ret     nc                           ; fi there was no carry then we are good
 15+  60CD 06 01        .OverFlowPositive:      ld      b,1                          ; if we overflow from +BHL +  +CDE then we already have sign cleared in A and only 1 bit to roll into B + no sign bit
 16+  60CF C9                                   ret
 17+  60D0 CB B8        .BothNegative:          res     7,b                          ; clear sign bits for both values
 18+  60D2 CB B9                                res     7,c                          ; .
 19+  60D4 ED 5A                                adc     hl,de                        ; now behave like they are both positive
 20+  60D6 78                                   ld      a,b
 21+  60D7 89                                   adc     c
 22+  60D8 DA DE 60                             jp      c,.OverFlowNegative          ; if there was carry we need to overflow into b
 23+  60DB F6 80                                or      %10000000                    ; set bit 7 of A for negative
 24+  60DD C9                                   ret
 25+  60DE 06 81        .OverFlowNegative:      ld      b,%10000001                  ; carry over the bit but also set the sign bit
 26+  60E0 C9                                   ret
 27+  60E1 CB 78        .OppositeSigns:         bit     7,b                         ; if BHL was negative then
 28+  60E3 C2 EC 60                             jp      nz,.CDEMinusBHL             ; its CDE - BHL
 29+  60E6 CB B9        .BHLMinusCDE:           res     7,c
 30+  60E8 EB                                   ex      hl,de                       ; it must be BHL - CDE  so we swap registers and just treat it as CDE-BHL
 31+  60E9 78                                   ld      a,b                         ; and we have to use a when swapping b and c
 32+  60EA 41                                   ld      b,c                         ; .
 33+  60EB 4F                                   ld      c,a                         ; .
 34+  60EC CB B8        .CDEMinusBHL:           res     7,b
 35+  60EE                                      ClearCarryFlag                      ; now its just common CDE-BHL
 35+  60EE B7          >                        or a
 36+  60EF 79                                   ld      a,c                         ; a= c - b
 37+  60F0 98                                   sbc     b
 38+  60F1 EB                                   ex      hl,de                       ; hl = DE-hl by swapping them round
 39+  60F2 ED 52                                sbc     hl,de                       ; now AHL is result
 40+  60F4 D0                                   ret     nc                          ; if there was no carry then we are good
 41+  60F5              .CDEFlipSign:           NegAHL                              ; as CDE-BHL became negative we make result lead sign negativce
 41+  60F5 47          >                    ld      b,a         ; save a in b
 41+  60F6 AF          >                    xor     a           ; l = 0 - l
 41+  60F7 95          >                    sub     l
 41+  60F8 6F          >                    ld      l,a
 41+  60F9 9F          >                    sbc     a,a         ; h = 0 - h
 41+  60FA 94          >                    sub     h
 41+  60FB 67          >                    ld      h,a
 41+  60FC 9F          >                    sbc     a,a         ; a= 0 - b
 41+  60FD 90          >                    sub     b
 42+  60FE F6 80                                or      %10000000                   ; flip the lead bit of A
 43+  6100 C9                                   ret
 44+  6101              SwapViaA:               MACRO   r1, r2
 45+  6101 ~                                    ld      a,r1
 46+  6101 ~                                    ld      r1,r2
 47+  6101 ~                                    ld      r2,a
 48+  6101                                      ENDM
 49+  6101              AHLequHLAddCarryAViaDE: MACRO
 50+  6101 ~                                    ld      d,0                         ; de = P1 carry
 51+  6101 ~                                    ld      e,a                         ; .
 52+  6101 ~                                    xor     a                           ; Clear carry and prep a for P2 carry
 53+  6101 ~                                    add     hl,de                       ; .
 54+  6101 ~                                    adc     a,a                         ; .
 55+  6101                                      ENDM
 56+  6101
 57+  6101              ; variant on above for simplifying post multiply
 58+  6101              ; AHL = BHL-DEC Lead Sign bit
 59+  6101              ; here we just fip C sign and call add DEC => CDE
 60+  6101              ; A = D     D = E   E = C   C = A
 61+  6101 7A           AHLequBHLplusDEC:       ld      a,d
 62+  6102 53                                   ld      d,e
 63+  6103 59                                   ld      e,c
 64+  6104 4F                                   ld      c,a
 65+  6105 C3 BC 60                             jp      AHLequBHLplusCDE
 66+  6108
 67+  6108              ; AHL = BHL-CDE Lead Sign bit
 68+  6108              ; here we just fip C sign and call add
 69+  6108 79           AHLequBHLminusCDE:      ld      a,c
 70+  6109 EE 80                                xor     %10000000
 71+  610B 4F                                   ld      c,a
 72+  610C C3 BC 60                             jp      AHLequBHLplusCDE
 73+  610F
 74+  610F
 75+  610F              ; variant on above for simplifying post multiply
 76+  610F              ; AHL = BHL-DEC Lead Sign bit
 77+  610F              ; here we just fip C sign and call add DEC => CDE
 78+  610F              ; A = D     D = E   E = C   C = A
 79+  610F 7A           AHLequBHLminusDEC:      ld      a,d
 80+  6110 F6 80                                or      %10000000
 81+  6112 53                                   ld      d,e
 82+  6113 59                                   ld      e,c
 83+  6114 4F                                   ld      c,a
 84+  6115 C3 BC 60                             jp      AHLequBHLplusCDE
 85+  6118
 86+  6118              ; If it will fit
 87+  6118              ;  HLBC = BHL * CDE  Lead Sign bit, carry Clear
 88+  6118              ; else
 89+  6118              ;  AHLBC = BHL * CDE Lead sign bit , carry set
 90+  6118              ; performs p0 = x0*y0                               L*E
 91+  6118              ;          p1 = x1*y0 + x0*y1 + p0 carry            H*E + D*L
 92+  6118              ;          p2 = x2*y0 + x0*y2 + x1*y1 + p1 carry    B*E + L*C + H*D
 93+  6118              ;          p3 = x2*y1 + x1 * y2 + p2 carry          B*D + H*C
 94+  6118              ;          p4 = x2* y2                              B*C
 95+  6118              ; reverse order for stack retrival                                                                                              B H L  C D E
 96+  6118              ; performs p4 = x2* y2                              B*C                B*C                     leave as is           BHL*CDE   020305 01040A 0201            02                  P4 = 2
 97+  6118              ;          p3 = x2*y1 + x1 * y2 + p2 carry          B*D + H*C          Swap B<>E and C<>L      E*D + H * L           EHC*LDB    E H C  L D B 0204 0301       08+03 = 0B          P3 = B
 98+  6118              ;          p2 = x2*y0 + x0*y2 + x1*y1 + p1 carry    E*B + C*L + H*D    Swap B<>D and C<>H      E*D + H * L + C * B   ECH*LBD    E C H  L B D 020A 0501 0304  14+05+0C=25         P2 = 25
 99+  6118              ;          p1 = x1*y0 + x0*y1                       C*D + H*B          Swap C<>E and L<>B      E*D + H * L           CEH*BLD    C E H  B L D 030A 0504       1E+14 = 32          P1 = 32 carry = 0
100+  6118              ;          p0 = x0*y0                               C*B                Swap E,H, ex hl,de in calc                    CHE*BDL                 050A            32                  P0 = 32 Carry = 0
101+  6118 78           HLBCequBHLmulCDE:       ld      a,b                         ; multiply is simpler as same signs is always positive
102+  6119 A9                                   xor     c                           ; opposite is always negative
103+  611A E6 80                                and     $80                         ; .
104+  611C F5           .SaveSign:              push    af                          ; save a to the stack that will now hold 0 or $80,
105+  611D CB B8        .ClearSignBits:         res     7,b
106+  611F CB B9                                res     7,c
107+  6121 C5           .PrepP4:                push    bc                          ; save registers for p4 = x2*y2 p3 carry > BC = x0 y0
108+  6122              .PrepP3:                SwapViaA b,e                        ; save registers for p3  = x2*y1 + x1*y2 + p2 carry
108+  6122 78          >                        ld      a,b
108+  6123 43          >                        ld      b,e
108+  6124 5F          >                        ld      e,a
109+  6125                                      SwapViaA c,l
109+  6125 79          >                        ld      a,c
109+  6126 4D          >                        ld      c,l
109+  6127 6F          >                        ld      l,a
110+  6128 D5 E5                                push    de,,hl                      ; DE = X2 Y1 HL = X1 Y2
111+  612A              .PrepP2:                SwapViaA d,b                         ; save registers for p2  = x2*y0 + x0*y2 + x1*y1 + p1 carry
111+  612A 7A          >                        ld      a,d
111+  612B 50          >                        ld      d,b
111+  612C 47          >                        ld      b,a
112+  612D                                      SwapViaA c,h
112+  612D 79          >                        ld      a,c
112+  612E 4C          >                        ld      c,h
112+  612F 67          >                        ld      h,a
113+  6130 D5 E5 C5                             push    de,,hl,,bc                  ; save registers for p1 = x1*y0 + x0*y1 + p0 carry
114+  6133              .PrepP1:                SwapViaA c,e
114+  6133 79          >                        ld      a,c
114+  6134 4B          >                        ld      c,e
114+  6135 5F          >                        ld      e,a
115+  6136                                      SwapViaA l,b
115+  6136 7D          >                        ld      a,l
115+  6137 68          >                        ld      l,b
115+  6138 47          >                        ld      b,a
116+  6139 D5 E5                                push    de,,hl
117+  613B              .PrepP0:                SwapViaA e,h                        ; we don't care about original values now as they are on the stack
117+  613B 7B          >                        ld      a,e
117+  613C 5C          >                        ld      e,h
117+  613D 67          >                        ld      h,a
118+  613E ED 30        .CalcP0:                mul     de                          ; de = x0 * y0 no need for carry logic as even FF*FF = FE01
119+  6140 42 4B                                ld      bc,de                       ; so b = P0 carry,c = P0
120+  6142 D1           .CalcP1:                pop     de                          ; get P1 components off stack
121+  6143 ED 30                                mul     de                          ; hl = x1*y0
122+  6145 EB                                   ex      de,hl                       ; so de = P1c P1 b =P0c P0
123+  6146 AF           .AddP0Carry:            xor     a                           ; hl = x1*y0 + P0 carry
124+  6147 16 00                                ld      d,0                         ; .
125+  6149 58                                   ld      e,b                         ; .
126+  614A 19                                   add     hl,de                       ; .
127+  614B 8F                                   adc     a,a                         ; a = carry
128+  614C D1                                   pop     de
129+  614D ED 30                                mul     de                          ; de = x0*y1
130+  614F A7                                   and     a                           ; clear carry flag whilst retaining a
131+  6150 19                                   add     hl,de                       ; hl = x1*y0 + x0*y1
132+  6151 CE 00        .CalcP1Carry:           adc     a,0                         ;
133+  6153 84                                   add     h                           ; a = P1 carry
134+  6154 45                                   ld      b,l                         ; A = P1 carry bc = P1 P0
135+  6155 D1           .CalcP2:                pop     de                          ; we pull in bc later directly into de
136+  6156 ED 30                                mul     de                          ; hl = x2*y0
137+  6158 EB                                   ex      hl,de                       ; .
138+  6159              .AddP1Carry:            AHLequHLAddCarryAViaDE
138+  6159 16 00       >                        ld      d,0                         ; de = P1 carry
138+  615B 5F          >                        ld      e,a                         ; .
138+  615C AF          >                        xor     a                           ; Clear carry and prep a for P2 carry
138+  615D 19          >                        add     hl,de                       ; .
138+  615E 8F          >                        adc     a,a                         ; .
139+  615F D1           .CalcP2Pt2:             pop     de                          ; de = x0*y2
140+  6160 ED 30                                mul     de                          ; .
141+  6162 A7                                   and     a                           ; Clear carry preserve a
142+  6163 19                                   add     hl,de                       ; hl = x2*y0 + x0*y2
143+  6164 8F                                   adc     a,a                         ; a = new carry
144+  6165 D1           .CalcP2Pt3:             pop     de                          ; de = x1*y1
145+  6166 ED 30                                mul     de                          ; .
146+  6168 A7                                   and     a                           ; hl = x2*y0 + x0*y2 + x1*y1, preserve carry flag
147+  6169 19                                   add     hl,de                       ; so we have hl = P2c P2 BC = P1P1
148+  616A CE 00        .CalcP2Carry:           adc     a,0                         ; A = calc carry + P2 carry in h
149+  616C 84                                   add     a,h                         ; l = P2 bc = P1 P0
150+  616D 5D                                   ld      e,l                         ; ixl = l (via e as you can't do hl to ix direct)
151+  616E DD 6B        .SaveP2:                ld      ixl,e                       ; a = P2 carry ixl:bc = P2 P1 P0
152+  6170 D1           .CalcP3                 pop     de                          ; hl = x2*y1
153+  6171 ED 30                                mul     de                          ; .
154+  6173 EB                                   ex      de,hl                       ; .
155+  6174              .AddP2Carry:            AHLequHLAddCarryAViaDE
155+  6174 16 00       >                        ld      d,0                         ; de = P1 carry
155+  6176 5F          >                        ld      e,a                         ; .
155+  6177 AF          >                        xor     a                           ; Clear carry and prep a for P2 carry
155+  6178 19          >                        add     hl,de                       ; .
155+  6179 8F          >                        adc     a,a                         ; .
156+  617A D1           .CalcP3Pt2:             pop     de                          ; de =  x1*y2
157+  617B ED 30                                mul     de                          ; .
158+  617D A7                                   and     a                           ; Clear carry preserve a
159+  617E 19                                   add     hl,de                       ; hl = x2*y1 + x1*y2
160+  617F CE 00                                adc     a,0                         ; a = new carry for P3, l = p3
161+  6181 84                                   add     a,h                         ; .
162+  6182 5D           .SaveP3:                ld      e,l                         ; load ixh via e
163+  6183 DD 63                                ld      ixh,e                       ; so we now have a = P3 carry ix P3P2 bc = P1P0
164+  6185 D1           .CalcP4:                pop     de                          ; de = x2* y2 + P3 carry
165+  6186 ED 30                                mul     de                          ; .
166+  6188 EB                                   ex      de,hl                       ;
167+  6189              .AddP3Carry:            AHLequHLAddCarryAViaDE              ; hl ix bc = P5P4 P3P2 P1P0
167+  6189 16 00       >                        ld      d,0                         ; de = P1 carry
167+  618B 5F          >                        ld      e,a                         ; .
167+  618C AF          >                        xor     a                           ; Clear carry and prep a for P2 carry
167+  618D 19          >                        add     hl,de                       ; .
167+  618E 8F          >                        adc     a,a                         ; .
168+  618F 7D           .RecoverSignBit:        ld      a,l                         ; Is P4 populated,
169+  6190 A7                                   and     a
170+  6191 CA 9A 61                             jp      z,.P3toP0                   ; if not then we have result P3P2P1P0
171+  6194 F1           .P4toP0:                pop     af                          ; else return with AHLBC
172+  6195 B5                                   or      l
173+  6196 DD E5 E1                             ld      hl,ix
174+  6199 C9                                   ret
175+  619A F1           .P3toP0:                pop     af
176+  619B DD E5 E1                             ld      hl,ix                       ; move P2P2 into hl
177+  619E B4                                   or      h
178+  619F 67                                   ld      h,a
179+  61A0 AF                                   xor     a                           ; return result in hlbc with CarryClear
180+  61A1 C9                                   ret
181+  61A2
182+  61A2 F1           ResultIsZero:           pop     af                          ; get rid of unwanted sign bits
183+  61A3 4B                                   ld      c,e                         ; CDE = EHL as remainder
184+  61A4 EB                                   ex      hl,de
185+  61A5 AF                                   xor     a                           ; result AHL = $0
186+  61A6 67                                   ld      h,a
187+  61A7 6F                                   ld      l,a                         ; .
188+  61A8 C9                                   ret
189+  61A9
190+  61A9 F1           DivideByZero:           pop     af                          ; get rid of unwanted sign bits
191+  61AA 4B                                   ld      c,e                         ; CDE = EHL as remainder
192+  61AB EB                                   ex      hl,de
193+  61AC 3E FF                                ld      a,$FF                       ; result AHL = $FFFFFF
194+  61AE 21 FF FF                             ld      hl,$FFFF                    ; .
195+  61B1                                      SetCarryFlag                        ; and carry set
195+  61B1 37          >                        scf
196+  61B2 C9                                   ret
197+  61B3
198+  61B3
199+  61B3              ; AHL = EHL / DBC  Lead Sign bit; CDE = remainder carry clear, divide by 0 gives AHL $FFFFFF, carry set
200+  61B3 7B           AHLequEHLdivDBC:        ld      a,e                         ; divide is simpler as same signs is always positive
201+  61B4 AA                                   xor     d                           ; opposite is always negative
202+  61B5 E6 80                                and     $80                         ; .
203+  61B7 F5           .SaveSign:              push    af                          ; save a to the stack that will now hold 0 or $80,
204+  61B8 CB BB        .ClearSignBits:         res     7,e
205+  61BA CB BA                                res     7,d
206+  61BC 7A           .CheckDivideByZero:     ld      a,d
207+  61BD B0                                   or      b
208+  61BE B1                                   or      c
209+  61BF 28 E8                                jr      z,DivideByZero
210+  61C1                                      ;DEBUG jp      Perform_24x24   ; forece 24 bit
211+  61C1              ; Now determine the scale down, e.g. can we do smaller divides than just 24x24
212+  61C1              ; Patterns              24x24 OK                         1C
213+  61C1              ;                       24x16 OK                         1E
214+  61C1              ;                       24x8  OK                         1F
215+  61C1              ;                       16x24 0                          1I
216+  61C1              ;                       16x16 OK                         1J
217+  61C1              ;                       16x8  OK                         1L
218+  61C1              ;                       8x24  0                          1N
219+  61C1              ;                       8x16  0                          1N
220+  61C1              ;                       8x8   OK                         1O
221+  61C1              ; flow is               check if its 24 / ?              1A
222+  61C1              ;                       Y > test 24/24                   1B
223+  61C1              ;                           Y > Perform 24x24            1C
224+  61C1              ;                           N > Check   24x16            1D
225+  61C1              ;                               Y > Perform 24x16        1E
226+  61C1              ;                               N > Perform 24x8         1F
227+  61C1              ;                       N > test 16/ ?                   1G
228+  61C1              ;                           Y > Check 16/24              1H
229+  61C1              ;                               Y > Result 0             1I
230+  61C1              ;                               N > Check 16/16          1J
231+  61C1              ;                                   Y > Perform 16/16    1K
232+  61C1              ;                                   N > Perform 16/8     1L
233+  61C1              ;                           N > Check 08/24 or 08/16     1M
234+  61C1              ;                               Y > Result is 0          1N
235+  61C1              ;                               N > Perform 8/8          1O
236+  61C1 1C           .ValidDivide:           inc     e
237+  61C2 1D                                   dec     e
238+  61C3 20 1E                                jr      nz,Try_24xAnything         ; its at least ehl / something
239+  61C5 24           .Test_16x:              inc     h
240+  61C6 25                                   dec     h
241+  61C7 20 0D                                jr      nz, .Try_16xAnything        ; its at least hl / something
242+  61C9 14           .Try_8xAnything:        inc     d
243+  61CA 15                                   dec     d
244+  61CB C2 A2 61                             jp      nz, ResultIsZero            ; its l / dbc which is always zero
245+  61CE 05                                   dec     b
246+  61CF 04                                   inc     b
247+  61D0 C2 A2 61                             jp      nz, ResultIsZero            ; its l / bc which is always zero
248+  61D3 C3 2D 65                             jp      Perform_8x8
248+  61D6                               ; its l/b
249+  61D6 14           .Try_16xAnything:       inc     d
250+  61D7 15                                   dec     d
251+  61D8 C2 A2 61                             jp      nz, ResultIsZero            ; its hl / dbc which is always zero
252+  61DB 05                                   dec     b
253+  61DC 04                                   inc     b
254+  61DD C2 6D 64                             jp      nz, Perform_16x16           ; its hl/bc
255+  61E0 C3 BC 64                             jp      Perform_16x8                ; so it must be hl/c
256+  61E3              ;--------------------------------------------------------------------------------------------------
257+  61E3              ; Div 24x24 iteration
258+  61E3
259+  61E3              ;--------------------------------------------------------------------------------------------------
260+  61E3              ; AHL = EHL/DBC, EHL > DBC both >= 01 00 00
261+  61E3                  DISPLAY "24x24 Actual internal result currently is 0L.D so need to rationalise it to AHL"
262+  61E3                  DISPLAY "Working on one 24x24 only"
263+  61E3                  DISPLAY "In effect 24x24 where E and D are both > 0 means e/d"
264+  61E3              Try_24xAnything:        ;inc     d
265+  61E3                                      ;dec     d
266+  61E3                                      ;jp      nz,Perform_24x24           ; if d was not zero then its ehl/dbc
267+  61E3                                      ;ld      a,b
268+  61E3                                      ;and     $80
269+  61E3                                      ;dec     b
270+  61E3                                      ;inc     b
271+  61E3                                      ;jp      z,Perform_24x8              ; if b was zero then its ehl/00c
272+  61E3                                      ;jp      Perform_24x16               ; else it leaves us with ehl/0bc
273+  61E3              ; {er
274+  61E3 7B           Perform_24x24:          ld      a,e                         ; EHL => HLE  AHL
275+  61E4 5D                                   ld      e,l                         ;             AHE
276+  61E5 6C                                   ld      l,h                         ;             ALE
277+  61E6 67                                   ld      h,a                         ;             HLE
278+  61E7 AF                                   xor     a                           ;             A = 0 Celar carry flag
279+  61E8              .eliminateLeadingZeros:
280+  61E8 CB 13        .loop_00:               rl e                                ; HLE << 1
281+  61EA ED 6A                                adc hl,hl                           ;
282+  61EC 38 36                                jr c, .loop_10                      ; if HLE bit 7 was set prior to shift goto loop_10  HLE was %1XXXXXXX XXXXXXXX XXXXXXX
283+  61EE CB 13                                rl e                                ; (HLE << 1) + 1
284+  61F0 1C                                   inc e                               ;
285+  61F1 ED 6A                                adc hl,hl                           ;
286+  61F3 38 3B                                jr c, .loop_20                      ; if HLE bit 6 was set prior to shift goto loop_20  HLE was %01XXXXXX XXXXXXXX XXXXXXX
287+  61F5 CB 13                                rl e                                ; (HLE << 1) + 1
288+  61F7 1C                                   inc e                               ;
289+  61F8 ED 6A                                adc hl,hl                           ;
290+  61FA 38 40                                jr c, .loop_30                      ; if HLE bit 5 was set prior to shift goto loop_30  HLE was %001XXXXX XXXXXXXX XXXXXXX
291+  61FC CB 13                                rl e                                ; (HLE << 1) + 1
292+  61FE 1C                                   inc e                               ;
293+  61FF ED 6A                                adc hl,hl                           ;
294+  6201 38 45                                jr c, .loop_40                      ; if HLE bit 4 was set prior to shift goto loop_40  HLE was %0001XXXX XXXXXXXX XXXXXXX
295+  6203 CB 13                                rl e                                ; (HLE << 1) + 1
296+  6205 1C                                   inc e                               ;
297+  6206 ED 6A                                adc hl,hl                           ;
298+  6208 38 4A                                jr c, .loop_50                      ; if HLE bit 3 was set prior to shift goto loop_50  HLE was %00001XXX XXXXXXXX XXXXXXX
299+  620A CB 13                                rl e                                ; (HLE << 1) + 1
300+  620C 1C                                   inc e                               ;
301+  620D ED 6A                                adc hl,hl                           ;
302+  620F 38 4F                                jr c, .loop_60                      ; if HLE bit 2 was set prior to shift goto loop_50  HLE was %000001XX XXXXXXXX XXXXXXX
303+  6211 CB 13                                rl e                                ; (HLE << 1) + 1
304+  6213 1C                                   inc e                               ;
305+  6214 ED 6A                                adc hl,hl                           ;
306+  6216 38 54                                jr c, .loop_70                      ; if HLE bit 1 was set prior to shift goto loop_50  HLE was %0000001X XXXXXXXX XXXXXXX
307+  6218 37                                   scf                                 ; set carry and jump to loop 7 as bit 0 of HLE must have been set
308+  6219 CB 13                                rl e                                ; (HLE << 1) + 1
309+  621B 1C                                   inc e                               ;
310+  621C ED 6A                                adc hl,hl                           ;
311+  621E 38 58                                jr c, .loop_80                      ; if HLE bit 0 was set prior to shift goto loop_50  HLE was %0000001X XXXXXXXX XXXXXXX
312+  6220 37                                   scf                                 ; set carry and jump to loop 7 as bit 0 of HLE must have been set
313+  6221 C3 74 62                             jp .loop_7
314+  6224 17           .loop_10:               rla                                 ; A = A *2 + carry from  HLE * 2 (on first pass A = 0)
315+  6225 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
316+  6227 9A                                   sbc a,d                             ;
317+  6228 30 02                                jr nc, .loop_1                      ; if AHL is negative
318+  622A 09                                   add hl,bc                           ;   revert AHL back to prior value
319+  622B 8A                                   adc a,d                             ;   .
320+  622C CB 13        .loop_1:                rl e                                ; else
321+  622E ED 6A                                adc hl,hl                           ;   HLE = HLE * 2
322+  6230 17           .loop_20:               rla                                 ; A = carry from  HLE * 2
323+  6231 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
324+  6233 9A                                   sbc a,d                             ;
325+  6234 30 02                                jr nc, .loop_2                       ; if AHL is negative
326+  6236 09                                   add hl,bc                           ;   revert AHL back to prior value
327+  6237 8A                                   adc a,d                             ;   .
328+  6238 CB 13        .loop_2:                rl e                                ; else
329+  623A ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
330+  623C 17           .loop_30:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
331+  623D ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
332+  623F 9A                                   sbc a,d                             ;
333+  6240 30 02                                jr nc, .loop_3                       ; if AHL is negative
334+  6242 09                                   add hl,bc                           ;   revert AHL back to prior value
335+  6243 8A                                   adc a,d                             ;   .
336+  6244 CB 13        .loop_3:                rl e                                ; else
337+  6246 ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
338+  6248 17           .loop_40:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
339+  6249 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
340+  624B 9A                                   sbc a,d                             ;
341+  624C 30 02                                jr nc, .loop_4                       ; if AHL is negative
342+  624E 09                                   add hl,bc                           ;   revert AHL back to prior value
343+  624F 8A                                   adc a,d                             ;   .
344+  6250 CB 13        .loop_4:                rl e                                ; else
345+  6252 ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
346+  6254 17           .loop_50:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
347+  6255 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
348+  6257 9A                                   sbc a,d                             ;
349+  6258 30 02                                jr nc, .loop_5                       ; if AHL is negative
350+  625A 09                                   add hl,bc                           ;   revert AHL back to prior value
351+  625B 8A                                   adc a,d                             ;   .
352+  625C CB 13        .loop_5:                rl e                                ; else
353+  625E ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
354+  6260 17           .loop_60:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
355+  6261 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
356+  6263 9A                                   sbc a,d                             ;
357+  6264 30 02                                jr nc, .loop_6                       ; if AHL is negative
358+  6266 09                                   add hl,bc                           ;   revert AHL back to prior value
359+  6267 8A                                   adc a,d                             ;   .
360+  6268 CB 13        .loop_6:                rl e                                ; else
361+  626A ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
362+  626C 17           .loop_70:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
363+  626D ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
364+  626F 9A                                   sbc a,d                             ;
365+  6270 30 02                                jr nc, .loop_7                       ; if AHL is negative
366+  6272 09                                   add hl,bc                           ;   revert AHL back to prior value
367+  6273 8A                                   adc a,d                             ;   .
368+  6274 CB 13        .loop_7:                rl e                                ; else
369+  6276 ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
370+  6278 17           .loop_80:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
371+  6279 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
372+  627B 9A                                   sbc a,d                             ;
373+  627C 30 02                                jr nc, .loop_8                       ; if AHL is negative
374+  627E 09                                   add hl,bc                           ;   revert AHL back to prior value
375+  627F 8A                                   adc a,d                             ;   .
376+  6280 CB 13        .loop_8:                rl e                                ; else
377+  6282 ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
378+  6284
379+  6284
380+  6284
381+  6284 17                                   rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
382+  6285 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
383+  6287 9A                                   sbc a,d                             ;
384+  6288 30 02                                jr nc, .exit_loop                    ; if AHL is negative
385+  628A 09                                   add hl,bc                           ;   revert AHL back to prior value
386+  628B 8A                                   adc a,d                             ;   .
387+  628C              ; quotient  = ~e[hl'] remainder =  ahl  one more shift left on quotient
388+  628C EB           .exit_loop:             ex de,hl                            ; ADE = AHL  HL = DE
389+  628D 4F                                   ld c,a                              ; CDE = ADE
390+  628E 7D                                   ld a,l                              ; L = (L*2) * -1 (as we reach here via jr nc then carry is 0
391+  628F 17                                   rla                                 ; .
392+  6290 2F                                   cpl                                 ; .
393+  6291 6F                                   ld l,a                              ; .
394+  6292 AF                                   xor a                               ; h = 0
395+  6293 67                                   ld h,a
396+  6294 C3 69 64                             jp      HandleSign
397+  6297              ;-----------------------------------------------------------------------------------------------------
398+  6297              ; AHL = HLE/BC, where A is always 0 return EHL > DBC EHL >= 01 00 00 DBC >= 00 01 00
399+  6297              ; inside loop computation is ehl / c  hl = remainder
400+  6297 50           Perform_24x16:          ld      d,b                         ; HLE/BC => HLE/DC
401+  6298 7B                                   ld      a,e                         ;           HLA/DC
402+  6299 59                                   ld      e,c                         ;           HLA/DE
403+  629A 4D                                   ld      c,l                         ;           HCA/DE
404+  629B 6F                                   ld      l,a                         ;           HCL/DE
405+  629C 7C                                   ld      a,h                         ;           ACL/DE
406+  629D 26 00                                ld      h,0                         ;           ACL/DE
407+  629F 06 02                                ld      b,2                         ;           ACB/DE (B = 2)
408+  62A1 CB 11        .eliminateLeadingZeros: rl c
409+  62A3 17                                   rla
410+  62A4 ED 6A                                adc hl,hl
411+  62A6 24                                   inc h
412+  62A7 25                                   dec h
413+  62A8 20 47                                jr nz, .loop_00
414+  62AA CB 11                                rl c
415+  62AC 0C                                   inc c
416+  62AD 17                                   rla
417+  62AE ED 6A                                adc hl,hl
418+  62B0 24                                   inc h
419+  62B1 25                                   dec h
420+  62B2 20 49                                jr nz, .loop_11
421+  62B4 CB 11                                rl c
422+  62B6 0C                                   inc c
423+  62B7 17                                   rla
424+  62B8 ED 6A                                adc hl,hl
425+  62BA 24                                   inc h
426+  62BB 25                                   dec h
427+  62BC 20 4B                                jr nz, .loop_22
428+  62BE CB 11                                rl c
429+  62C0 0C                                   inc c
430+  62C1 17                                   rla
431+  62C2 ED 6A                                adc hl,hl
432+  62C4 24                                   inc h
433+  62C5 25                                   dec h
434+  62C6 20 4D                                jr nz, .loop_33
435+  62C8 CB 11                                rl c
436+  62CA 0C                                   inc c
437+  62CB 17                                   rla
438+  62CC ED 6A                                adc hl,hl
439+  62CE 24                                   inc h
440+  62CF 25                                   dec h
441+  62D0 20 4F                                jr nz, .loop_44
442+  62D2 CB 11                                rl c
443+  62D4 0C                                   inc c
444+  62D5 17                                   rla
445+  62D6 ED 6A                                adc hl,hl
446+  62D8 24                                   inc h
447+  62D9 25                                   dec h
448+  62DA 20 51                                jr nz, .loop_55
449+  62DC CB 11                                rl c
450+  62DE 0C                                   inc c
451+  62DF 17                                   rla
452+  62E0 ED 6A                                adc hl,hl
453+  62E2 24                                   inc h
454+  62E3 25                                   dec h
455+  62E4 20 53                                jr nz, .loop_66
456+  62E6 37                                   scf
457+  62E7 C3 3E 63                             jp .loop_7
458+  62EA CB 11        .loop_0:                rl c
459+  62EC 17                                   rla
460+  62ED ED 6A                                adc hl,hl
461+  62EF 38 68                                jr c, .loop_000
462+  62F1 ED 52        .loop_00:               sbc hl,de
463+  62F3 30 01                                jr nc, .loop_1
464+  62F5 19                                   add hl,de
465+  62F6 CB 11        .loop_1:                rl c
466+  62F8 17                                   rla
467+  62F9 ED 6A                                adc hl,hl
468+  62FB 38 63                                jr c, .loop_111
469+  62FD ED 52        .loop_11:               sbc hl,de
470+  62FF 30 01                                jr nc, .loop_2
471+  6301 19                                   add hl,de
472+  6302 CB 11        .loop_2:                rl c
473+  6304 17                                   rla
474+  6305 ED 6A                                adc hl,hl
475+  6307 38 5E                                jr c, .loop_222
476+  6309 ED 52        .loop_22:               sbc hl,de
477+  630B 30 01                                jr nc, .loop_3
478+  630D 19                                   add hl,de
479+  630E CB 11        .loop_3:                rl c
480+  6310 17                                   rla
481+  6311 ED 6A                                adc hl,hl
482+  6313 38 59                                jr c, .loop_333
483+  6315 ED 52        .loop_33:               sbc hl,de
484+  6317 30 01                                jr nc, .loop_4
485+  6319 19                                   add hl,de
486+  631A CB 11        .loop_4:                rl c
487+  631C 17                                   rla
488+  631D ED 6A                                adc hl,hl
489+  631F 38 54                                jr c, .loop_444
490+  6321 ED 52        .loop_44:               sbc hl,de
491+  6323 30 01                                jr nc, .loop_5
492+  6325 19                                   add hl,de
493+  6326 CB 11        .loop_5:                rl c
494+  6328 17                                   rla
495+  6329 ED 6A                                adc hl,hl
496+  632B 38 4F                                jr c, .loop_555
497+  632D ED 52        .loop_55:               sbc hl,de
498+  632F 30 01                                jr nc, .loop_6
499+  6331 19                                   add hl,de
500+  6332 CB 11        .loop_6:                rl c
501+  6334 17                                   rla
502+  6335 ED 6A                                adc hl,hl
503+  6337 38 4A                                jr c, .loop_666
504+  6339 ED 52        .loop_66:               sbc hl,de
505+  633B 30 01                                jr nc, .loop_7
506+  633D 19                                   add hl,de
507+  633E CB 11        .loop_7:                rl c
508+  6340 17                                   rla
509+  6341 ED 6A                                adc hl,hl
510+  6343 38 45                                jr c, .loop_777
511+  6345 ED 52        .loop_77:               sbc hl,de
512+  6347 30 01                                jr nc, .loop_8
513+  6349 19                                   add hl,de
514+  634A 10 9E        .loop_8:                djnz .loop_0
515+  634C CB 11        .exit_loop:             rl c
516+  634E 17                                   rla
517+  634F                                      ; ac = ~quotient, hl = remainder
518+  634F EB                                   ex de,hl
519+  6350 2F                                   cpl
520+  6351 67                                   ld h,a
521+  6352 79                                   ld a,c
522+  6353 2F                                   cpl
523+  6354 6F                                   ld l,a
524+  6355 AF                                   xor a
525+  6356 C3 69 64                             jp      HandleSign
526+  6359 B7           .loop_000:              or a
527+  635A ED 52                                sbc hl,de
528+  635C B7                                   or a
529+  635D C3 F6 62                             jp .loop_1
530+  6360 B7           .loop_111:              or a
531+  6361 ED 52                                sbc hl,de
532+  6363 B7                                   or a
533+  6364 C3 02 63                             jp .loop_2
534+  6367 B7           .loop_222:              or a
535+  6368 ED 52                                sbc hl,de
536+  636A B7                                   or a
537+  636B C3 0E 63                             jp .loop_3
538+  636E B7           .loop_333:              or a
539+  636F ED 52                                sbc hl,de
540+  6371 B7                                   or a
541+  6372 C3 1A 63                             jp .loop_4
542+  6375 B7           .loop_444:              or a
543+  6376 ED 52                                sbc hl,de
544+  6378 B7                                   or a
545+  6379 C3 26 63                             jp .loop_5
546+  637C B7           .loop_555:              or a
547+  637D ED 52                                sbc hl,de
548+  637F B7                                   or a
549+  6380 C3 32 63                             jp .loop_6
550+  6383 B7           .loop_666:              or a
551+  6384 ED 52                                sbc hl,de
552+  6386 B7                                   or a
553+  6387 C3 3E 63                             jp .loop_7
554+  638A B7           .loop_777:              or a
555+  638B ED 52                                sbc hl,de
556+  638D B7                                   or a
557+  638E C3 4A 63                             jp .loop_8
558+  6391              ;-----------------------------------------------------------------------------------------------------
559+  6391              ; AHL = HLE/BC, where A is always 0 return EHL > DBC EHL >= 01 00 00 DBC >= 00 00 01
560+  6391              ; inside loop computation is abc/de, hl = remainder
561+  6391              ; EHL: = EHL/C
562+  6391              ;so currerntly thsi can't hadnle c > 127 so need to understand lead sign at lower bit levels on c
563+  6391              ;so could just do 24 bit and process lead zeros in h and hope that is enough? or have a special case
564+  6391              ;for collapsing lead zeros in dbc too
565+  6391 79           Perform_24x8:           ld      a,c
566+  6392 E6 80                                and     $80
567+  6394 CA BD 63                             jp      z,Perform_24x7
568+  6397 DD 26 18                             ld      ixh,24              ; from ehl/c to ABC/E
569+  639A 7B                                   ld      a,e
570+  639B 44                                   ld      b,h
571+  639C 51                                   ld      d,c
572+  639D 4D                                   ld      c,l
573+  639E 5A                                   ld      e,d
574+  639F 16 00                                ld      d,0
575+  63A1 21 00 00                             ld      hl,0                ;
576+  63A4                                      ; with c being 8 bit we need to do
577+  63A4 CB 21        .loop1:                 sla     c                   ; unroll 24 times
578+  63A6 CB 10                                rl      b                   ; ...
579+  63A8 17                                   rla                         ; ...
580+  63A9 ED 6A                                adc     hl,hl               ; ...
581+  63AB ED 52                                sbc     hl,de               ; ...
582+  63AD 30 02                                jr      nc,.Skip1           ; ...
583+  63AF 19                                   add     hl,de               ; ...
584+  63B0 0D                                   dec     c                   ; ...
585+  63B1 DD 25        .Skip1:                 dec     ixh
586+  63B3 FD 00                                break
587+  63B5 C2 A4 63                             jp      nz,.loop1
588+  63B8 FD 00                                break
589+  63BA C3 69 64                             jp      HandleSign
590+  63BD 06 18        Perform_24x7:           ld b,24
591+  63BF AF                                   xor a
592+  63C0 29           .loop1:                 add hl,hl
593+  63C1 CB 13                                rl e
594+  63C3 17                                   rla
595+  63C4                                      ;rl d
596+  63C4                                      ;rla
597+  63C4 B9                                   cp c
598+  63C5 38 02                                jr c, .Skip1
599+  63C7 91                                   sub c
600+  63C8 2C                                   inc l
601+  63C9 10 F5        .Skip1:                 djnz .loop1
602+  63CB FD 00                                break
603+  63CD C3 69 64                             jp      HandleSign
604+  63D0
605+  63D0                 ;   a = remainder
606+  63D0                 ; ehl = quotient
607+  63D0
608+  63D0 4F              ld c,a
609+  63D1 7B              ld a,e
610+  63D2 59              ld e,c
611+  63D3 50              ld d,b
612+  63D4
613+  63D4 B7              or a
614+  63D5 C9              ret
615+  63D6
616+  63D6
617+  63D6              ;.slow32x8:              ld      d,h ; do dehl / c
618+  63D6              ;                        ld      e,l
619+  63D6              ;                        ld      h,e
620+  63D6              ;                        ld      l,0
621+  63D6              ;                        xor     a
622+  63D6              ;.looping:               ld b,2
623+  63D6              ;.loop_11:               add hl,hl
624+  63D6              ;                        rl e
625+  63D6              ;                        rl d
626+  63D6              ;.loop_01:               rla
627+  63D6              ;                        jr c, .loop_02
628+  63D6              ;                        cp c
629+  63D6              ;                        jr c, .loop_03
630+  63D6              ;.loop_02:               sub c
631+  63D6              ;                        inc l
632+  63D6              ;.loop_03:               djnz .loop_11
633+  63D6 B7                                   or a
634+  63D7              ; result dehl = 32-bit quotient
635+  63D7              ;.slow:                  ld      b,24
636+  63D7              ;.loop_11:               add     hl,hl
637+  63D7              ;                        rl      e
638+  63D7              ;.loop_01:               rla
639+  63D7              ;                        jr      c, .loop_02
640+  63D7              ;                        cp      c
641+  63D7              ;                        jr      c, .loop_03
642+  63D7              ;.loop_02:               sub 01010c
643+  63D7              ;                        inc 01010l
644+  63D7              ;.loop_03:               djnz .loop_11
645+  63D7              ;                        ld c,a
646+  63D7              ;                        ld a,e
647+  63D7              ;                        ld e,c
648+  63D7              ;                        ld d,b
649+  63D7              ;                        or a
650+  63D7 C3 69 64                             jp      HandleSign
651+  63DA
652+  63DA AF           DEBUG:                        xor     a                           ;             A = 0 Clear carry flag
653+  63DB 06 03                                ld b,3
654+  63DD              .eliminateLeadingZeros:
655+  63DD 29           .loop_00:               add hl,hl
656+  63DE CB 13                                rl e
657+  63E0 38 2B                                jr c, .loop_10
658+  63E2 29                                   add hl,hl
659+  63E3 CB 13                                rl e
660+  63E5 38 31                                jr c, .loop_20
661+  63E7 29                                   add hl,hl
662+  63E8 CB 13                                rl e
663+  63EA 38 37                                jr c, .loop_30
664+  63EC 29                                   add hl,hl
665+  63ED CB 13                                rl e
666+  63EF 38 3D                                jr c, .loop_40
667+  63F1 29                                   add hl,hl
668+  63F2 CB 13                                rl e
669+  63F4 38 43                                jr c, .loop_50
670+  63F6 29                                   add hl,hl
671+  63F7 CB 13                                rl e
672+  63F9 38 49                                jr c, .loop_60
673+  63FB 29                                   add hl,hl
674+  63FC CB 13                                rl e
675+  63FE 38 4F                                jr c, .loop_70
676+  6400 29                                   add hl,hl
677+  6401 CB 13                                rl e
678+  6403 17                                   rla
679+  6404 B9                                   cp c
680+  6405 38 02                                jr c, .loop_80
681+  6407 91                                   sub c
682+  6408 2C                                   inc l
683+  6409 05           .loop_80:               dec b
684+  640A                 ; general divide loop
685+  640A 29           .loop_0:                add     hl,hl
686+  640B CB 13                                rl      e
687+  640D 17           .loop_10:               rla
688+  640E 38 03                                jr      c, .loop_101
689+  6410 B9                                   cp      c
690+  6411 38 02                                jr      c, .loop_1
691+  6413 91           .loop_101:              sub     c
692+  6414 2C                                   inc     l
693+  6415 29           .loop_1:                add     hl,hl
694+  6416 CB 13                                rl      e
695+  6418 17           .loop_20:               rla
696+  6419 38 03                                jr      c, .loop_201
697+  641B B9                                   cp      c
698+  641C 38 02                                jr      c, .loop_2
699+  641E 91           .loop_201:              sub     c
700+  641F 2C                                   inc     l
701+  6420 29           .loop_2:                add     hl,hl
702+  6421 CB 13                                rl      e
703+  6423 17           .loop_30:               rla
704+  6424 38 03                                jr      c, .loop_301
705+  6426 B9                                   cp      c
706+  6427 38 02                                jr      c, .loop_3
707+  6429 91           .loop_301:              sub     c
708+  642A 2C                                   inc     l
709+  642B 29           .loop_3:                add     hl,hl
710+  642C CB 13                                rl      e
711+  642E 17           .loop_40:               rla
712+  642F 38 03                                jr      c, .loop_401
713+  6431 B9                                   cp      c
714+  6432 38 02                                jr      c, .loop_4
715+  6434 91           .loop_401:              sub     c
716+  6435 2C                                   inc     l
717+  6436 29           .loop_4:                add     hl,hl
718+  6437 CB 13                                rl      e
719+  6439 17           .loop_50:               rla
720+  643A 38 03                                jr      c, .loop_501
721+  643C B9                                   cp      c
722+  643D 38 02                                jr      c, .loop_5
723+  643F 91           .loop_501:              sub     c
724+  6440 2C                                   inc     l
725+  6441 29           .loop_5:                add     hl,hl
726+  6442 CB 13                                rl      e
727+  6444 17           .loop_60:               rla
728+  6445 38 03                                jr      c, .loop_601
729+  6447 B9                                   cp      c
730+  6448 38 02                                jr      c, .loop_6
731+  644A 91           .loop_601:              sub     c
732+  644B 2C                                   inc     l
733+  644C 29           .loop_6:                add     hl,hl
734+  644D CB 13                                rl      e
735+  644F 17           .loop_70:               rla
736+  6450 38 03                                jr      c, .loop_701
737+  6452 B9                                   cp      c
738+  6453 38 02                                jr      c, .loop_7
739+  6455 91           .loop_701:              sub     c
740+  6456 2C                                   inc     l
741+  6457 29           .loop_7:                add     hl,hl
742+  6458 CB 13                                rl      e
743+  645A 17                                   rla
744+  645B 38 03                                jr      c, .loop_801
745+  645D B9                                   cp      c
746+  645E 38 02                                jr      c, .loop_8
747+  6460 91           .loop_801:              sub     c
748+  6461 2C                                   inc     l
749+  6462 10 A6        .loop_8:                djnz    .loop_0
750+  6464 4F           .exit_loop:             ld      c,a
751+  6465 7B                                   ld      a,e
752+  6466 59                                   ld      e,c
753+  6467 50                                   ld      d,b
754+  6468 B7                                   or      a
755+  6469 47           HandleSign:             ld      b,a ; save the a value      ; now deal with prior sign
756+  646A F1                                   pop     af
757+  646B B0                                   or      b                           ; now a holds saved sign and b result so now lead sign S15.8
758+  646C C9                                   ret
759+  646D              ;-----------------------------------------------------------------------------------------------------
760+  646D              ; AHL = HL/BC, EHL > DBC both >= 00 01 00
761+  646D 50 59        Perform_16x16:          ld      de,bc                       ; get to AHL= 0HL/0BC
762+  646F 7D                                   ld      a,l                         ;hl >= $1000 de >= $1000 so max quotient is 255
763+  6470 6C                                   ld      l,h                         ; which means the loop computation is a[c] / de hl = remainder
764+  6471 26 00                                ld      h,0                         ; so we can initialise as if 8 iterations are done
765+  6473              ; unrolling divide 8 time, eliminating leading zeros is only marginal gain
766+  6473 17           .loop_0:                rla
767+  6474 ED 6A                                adc     hl,hl
768+  6476 ED 52        .loop_00:               sbc     hl,de
769+  6478 30 01                                jr      nc, .loop_1
770+  647A 19                                   add     hl,de
771+  647B 17           .loop_1:                rla
772+  647C ED 6A                                adc     hl,hl
773+  647E ED 52        .loop_11:               sbc     hl,de
774+  6480 30 01                                jr      nc, .loop_2
775+  6482 19                                   add     hl,de
776+  6483 17           .loop_2:                rla
777+  6484 ED 6A                                adc     hl,hl
778+  6486 ED 52        .loop_22:               sbc     hl,de
779+  6488 30 01                                jr      nc, .loop_3
780+  648A 19                                   add     hl,de
781+  648B 17           .loop_3:                rla
782+  648C ED 6A                                adc     hl,hl
783+  648E ED 52        .loop_33:               sbc     hl,de
784+  6490 30 01                                jr      nc, .loop_4
785+  6492 19                                   add     hl,de
786+  6493 17           .loop_4:                rla
787+  6494 ED 6A                                adc     hl,hl
788+  6496 ED 52        .loop_44:               sbc     hl,de
789+  6498 30 01                                jr      nc, .loop_5
790+  649A 19                                   add     hl,de
791+  649B              .loop_5:
792+  649B 17                                   rla
793+  649C ED 6A                                adc     hl,hl
794+  649E              .loop_55:
795+  649E ED 52                                sbc     hl,de
796+  64A0 30 01                                jr      nc, .loop_6
797+  64A2 19                                   add     hl,de
798+  64A3              .loop_6:
799+  64A3 17                                   rla
800+  64A4 ED 6A                                adc     hl,hl
801+  64A6              .loop_66:
802+  64A6 ED 52                                sbc     hl,de
803+  64A8 30 01                                jr      nc, .loop_7
804+  64AA 19                                   add     hl,de
805+  64AB              .loop_7:
806+  64AB 17                                   rla
807+  64AC ED 6A                                adc     hl,hl
808+  64AE ED 52        .loop_77:               sbc     hl,de
809+  64B0 30 01                                jr      nc, .exit_loop
810+  64B2 19                                   add     hl,de
811+  64B3 17           .exit_loop:             rla                ; a = ~quotient, hl = remainder
812+  64B4 2F                                   cpl
813+  64B5 5F                                   ld      e,a
814+  64B6 AF                                   xor     a
815+  64B7 57                                   ld      d,a
816+  64B8 EB                                   ex      de,hl
817+  64B9 C3 69 64                             jp      HandleSign
818+  64BC              ;-----------------------------------------------------------------------------------------------------
819+  64BC              ; AHL = HL/C, where A is always 0 return EHL > DBC both >= 00 01 00, internally does HL/E
820+  64BC 59           Perform_16x8:           ld      e,c                          ; get to AHL= 0HL/00C
821+  64BD AF                                   xor a
822+  64BE 57                                   ld      d,a
823+  64BF 06 02                                ld      b,2
824+  64C1 29           .loop_00:               add     hl,hl                       ; eliminate leading zeroes
825+  64C2 38 1B                                jr      c, .loop_10
826+  64C4 29                                   add     hl,hl
827+  64C5 38 21                                jr      c, .loop_20
828+  64C7 29                                   add     hl,hl
829+  64C8 38 27                                jr      c, .loop_30
830+  64CA 29                                   add     hl,hl
831+  64CB 38 2D                                jr      c, .loop_40
832+  64CD 29                                   add     hl,hl
833+  64CE 38 33                                jr      c, .loop_50
834+  64D0 29                                   add     hl,hl
835+  64D1 38 39                                jr      c, .loop_60
836+  64D3 29                                   add     hl,hl
837+  64D4 38 3F                                jr      c, .loop_70
838+  64D6 29                                   add     hl,hl
839+  64D7 17                                   rla
840+  64D8 BB                                   cp      e
841+  64D9 38 02                                jr      c, .loop_80
842+  64DB 93                                   sub     e
843+  64DC 2C                                   inc     l
844+  64DD 05           .loop_80:               dec     b
845+  64DE 29           .loop_0:                add     hl,hl
846+  64DF 17           .loop_10:               rla
847+  64E0 38 03                                jr      c, .loop_101
848+  64E2 BB                                   cp      e
849+  64E3 38 02                                jr      c, .loop_1
850+  64E5 93           .loop_101:              sub     e
851+  64E6 2C                                   inc     l
852+  64E7 29           .loop_1:                add     hl,hl
853+  64E8 17           .loop_20:               rla
854+  64E9 38 03                                jr      c, .loop_201
855+  64EB BB                                   cp      e
856+  64EC 38 02                                jr      c, .loop_2
857+  64EE 93           .loop_201:              sub     e
858+  64EF 2C                                   inc     l
859+  64F0 29           .loop_2:                add     hl,hl
860+  64F1 17           .loop_30:               rla
861+  64F2 38 03                                jr      c, .loop_301
862+  64F4 BB                                   cp      e
863+  64F5 38 02                                jr      c, .loop_3
864+  64F7 93           .loop_301:              sub     e
865+  64F8 2C                                   inc     l
866+  64F9 29           .loop_3:                add     hl,hl
867+  64FA 17           .loop_40:               rla
868+  64FB 38 03                                jr      c, .loop_401
869+  64FD BB                                   cp      e
870+  64FE 38 02                                jr      c, .loop_4
871+  6500 93           .loop_401:              sub     e
872+  6501 2C                                   inc     l
873+  6502 29           .loop_4:                add     hl,hl
874+  6503 17           .loop_50:               rla
875+  6504 38 03                                jr      c, .loop_501
876+  6506 BB                                   cp      e
877+  6507 38 02                                jr      c, .loop_5
878+  6509 93           .loop_501:               sub     e
879+  650A 2C                                   inc     l
880+  650B 29           .loop_5:                 add     hl,hl
881+  650C 17           .loop_60:                rla
882+  650D 38 03                                jr      c, .loop_601
883+  650F BB                                   cp      e
884+  6510 38 02                                jr      c, .loop_6
885+  6512 93           .loop_601:               sub     e
886+  6513 2C                                   inc     l
887+  6514 29           .loop_6:                 add     hl,hl
888+  6515 17           .loop_70:                rla
889+  6516 38 03                                jr      c, .loop_701
890+  6518 BB                                   cp      e
891+  6519 38 02                                jr      c, .loop_7
892+  651B 93           .loop_701:               sub     e
893+  651C 2C                                   inc     l
894+  651D 29           .loop_7:                 add     hl,hl
895+  651E 17                                   rla
896+  651F 38 03                                jr      c, .loop_801
897+  6521 BB                                   cp      e
898+  6522 38 02                                jr      c, .loop_8
899+  6524 93           .loop_801:               sub     e
900+  6525 2C                                   inc     l
901+  6526 10 B6        .loop_8:                 djnz    .loop_0
902+  6528              .exit_loop:              ;AHL = quotient CDE = remainder
903+  6528 5F                                   ld e,a
904+  6529 AF                                   xor a
905+  652A C3 69 64                             jp      HandleSign
906+  652D              ;-----------------------------------------------------------------------------------------------------
907+  652D              ; AHL = L/C, where A is always 0 return EHL > DBC both >= 00 01 00, internally does L/E
908+  652D AF           Perform_8x8:            xor     a
909+  652E 57                                   ld      d,a
910+  652F 67                                   ld      h,a
911+  6530 59                                   ld      e,c
912+  6531 CB 25        .loop_00:               sla     l
913+  6533 38 1B                                jr      c, .loop_10
914+  6535 CB 25                                sla     l
915+  6537 38 1F                                jr      c, .loop_20
916+  6539 CB 25                                sla     l
917+  653B 38 23                                jr      c, .loop_30
918+  653D CB 25                                sla     l
919+  653F 38 27                                jr      c, .loop_40
920+  6541 CB 25                                sla     l
921+  6543 38 2B                                jr      c, .loop_50
922+  6545 CB 25                                sla     l
923+  6547 38 2F                                jr      c, .loop_60
924+  6549 CB 25                                sla     l
925+  654B 38 33                                jr      c, .loop_70
926+  654D C3 86 65                             jp      .loop_17
927+  6550 17           .loop_10:               rla
928+  6551 BB                                   cp      e
929+  6552 38 02                                jr      c, .loop_11
930+  6554 93                                   sub     e
931+  6555 2C                                   inc     l
932+  6556 CB 25        .loop_11:               sla     l
933+  6558 17           .loop_20:               rla
934+  6559 BB                                   cp      e
935+  655A 38 02                                jr      c, .loop_12
936+  655C 93                                   sub     e
937+  655D 2C                                   inc     l
938+  655E CB 25        .loop_12:               sla     l
939+  6560 17           .loop_30:               rla
940+  6561 BB                                   cp      e
941+  6562 38 02                                jr      c, .loop_13
942+  6564 93                                   sub     e
943+  6565 2C                                   inc     l
944+  6566 CB 25        .loop_13:               sla     l
945+  6568 17           .loop_40:               rla
946+  6569 BB                                   cp      e
947+  656A 38 02                                jr      c, .loop_14
948+  656C 93                                   sub     e
949+  656D 2C                                   inc     l
950+  656E CB 25        .loop_14:               sla     l
951+  6570 17           .loop_50:               rla
952+  6571 BB                                   cp      e
953+  6572 38 02                                jr      c, .loop_15
954+  6574 93                                   sub     e
955+  6575 2C                                   inc     l
956+  6576 CB 25        .loop_15:               sla     l
957+  6578 17           .loop_60:               rla
958+  6579 BB                                   cp      e
959+  657A 38 02                                jr      c, .loop_16
960+  657C 93                                   sub     e
961+  657D 2C                                   inc     l
962+  657E CB 25        .loop_16:               sla     l
963+  6580 17           .loop_70:               rla
964+  6581 BB                                   cp      e
965+  6582 38 02                                jr      c, .loop_17
966+  6584 93                                   sub     e
967+  6585 2C                                   inc     l
968+  6586 CB 25        .loop_17:               sla     l
969+  6588 17                                   rla
970+  6589 BB                                   cp      e
971+  658A 38 02                                jr      c, .exit_loop
972+  658C 93                                   sub     e
973+  658D 2C                                   inc     l
974+  658E              .exit_loop:
975+  658E                                      ; a = remainder
976+  658E                                      ; l = quotient
977+  658E 5F                                   ld      e,a
978+  658F AF                                   xor     a
979+  6590 C3 69 64                             jp      HandleSign
980+  6593
981+  6593              ;
982+  6593              ; AHL = 24bit at IX + 24 bit at IY
983+  6593
984+  6593              ; AHL = 24bit at IX - 24 bit at IY
985+  6593
986+  6593              ; BAHL = 24bit at IX * 24 bit at IY  Lead Sign bit
987+  6593
988+  6593              ; AHL = 24bit at IX / 24 bit at IY  Lead Sign bit
989+  6593
# file closed: asm_addition24.asm
204   6593
205   6593
206   6593
207   6593
208   6593                  SAVENEX OPEN "mathsRollPitch.nex", EliteNextStartup , TopOfStack
209   6593                  SAVENEX CFG  0,0,0,1
210   6593                  SAVENEX AUTO
211   6593                  SAVENEX CLOSE
212   6593
213   6593
# file closed: mathsRollPitch.asm
