# file opened: mathsRollPitch.asm
  1   0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
  2   0000                              DISPLAY "mathsRollPitch test"
  3   0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
  4   0000
  5   0000
  6   0000                  DEFINE DEBUGMODE 1
  7   0000                  DEVICE ZXSPECTRUMNEXT
  8   0000                  SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
  9   0000                  ;DEFINE  TESTING_MATHS_DIVIDE 1
 10   0000                  DEFINE  TESTING_ROLL_PITCH 1
 11   0000               CSPECTMAP mathsRollPitch.map
 12   0000               OPT --zxnext=cspect --syntax=a --reversepop
 13   0000                              DEFINE  SOUNDPACE 3
 14   0000              ;                DEFINE  ENABLE_SOUND 1
 15   0000                             DEFINE     MAIN_INTERRUPTENABLE 1
 16   0000              ;               DEFINE INTERRUPT_BLOCKER 1
 17   0000              DEBUGSEGSIZE   equ 1
 18   0000              DEBUGLOGSUMMARY equ 1
 19   0000              ;DEBUGLOGDETAIL equ 1
 20   0000
 21   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 22   0000              ; Game Defines
 23   0000              ScreenLocal      EQU 0
 24   0000              ScreenGalactic   EQU ScreenLocal + 1
 25   0000              ScreenMarket     EQU ScreenGalactic + 1
 26   0000              ScreenMarketDsp  EQU ScreenMarket + 1
 27   0000              ScreenStatus     EQU ScreenMarketDsp + 1
 28   0000              ScreenInvent     EQU ScreenStatus + 1
 29   0000              ScreenPlanet     EQU ScreenInvent + 1
 30   0000              ScreenEquip      EQU ScreenPlanet + 1
 31   0000              ScreenLaunch     EQU ScreenEquip + 1
 32   0000              ScreenFront      EQU ScreenLaunch + 1
 33   0000              ScreenAft        EQU ScreenFront+1
 34   0000              ScreenLeft       EQU ScreenAft+1
 35   0000              ScreenRight      EQU ScreenLeft+1
 36   0000              ScreenDocking    EQU ScreenRight+1
 37   0000              ScreenHyperspace EQU ScreenDocking+1
 38   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 39   0000              ; Colour Defines
 40   0000              SignMask8Bit		equ %01111111
 41   0000              SignMask16Bit		equ %0111111111111111
 42   0000              SignOnly8Bit		equ $80
 43   0000              SignOnly16Bit		equ $8000
 44   0000
 45   0000              Bit7Only            equ %10000000
 46   0000              Bit6Only            equ %01000000
 47   0000              Bit5Only            equ %00100000
 48   0000              Bit4Only            equ %00010000
 49   0000              Bit3Only            equ %00001000
 50   0000              Bit2Only            equ %00000100
 51   0000              Bit1Only            equ %00000010
 52   0000              Bit0Only            equ %00000001
 53   0000              Bit7Clear           equ %01111111
 54   0000              Bit6Clear           equ %10111111
 55   0000              Bit5Clear           equ %11011111
 56   0000              Bit4Clear           equ %11101111
 57   0000              Bit3Clear           equ %11110111
 58   0000              Bit2Clear           equ %11111011
 59   0000              Bit1Clear           equ %11111101
 60   0000              Bit0Clear           equ %11111110
 61   0000              ConstPi				equ $80
 62   0000              ConstNorm           equ 197
 63   0000
 64   0000
 65   0000
 66   0000                                      INCLUDE "../../Macros/jumpMacros.asm"
# file opened: jumpMacros.asm
  1+  0000              JumpIfHLNegative:       MACRO target
  2+  0000 ~                                    bit     7,h
  3+  0000 ~                                    jp      nz,target
  4+  0000                                      ENDM
  5+  0000
  6+  0000              JumpIfPositive:	        MACRO target
  7+  0000 ~                                    jp		p, target
  8+  0000                                      ENDM
  9+  0000
 10+  0000              JumpIfNegative:	        MACRO target
 11+  0000 ~                                    jp		m, target
 12+  0000                                      ENDM
 13+  0000
 14+  0000
 15+  0000              JumpIfUnderflow:	    MACRO target
 16+  0000 ~                                    jp		po, target
 17+  0000                                      ENDM
 18+  0000
 19+  0000              JumpIfOverflow:	        MACRO target
 20+  0000 ~                                    jp		po, target
 21+  0000                                      ENDM
 22+  0000
 23+  0000
 24+  0000              JumpIfNotZero:	        MACRO target
 25+  0000 ~                                    jp	nz,target
 26+  0000                                      ENDM
 27+  0000
 28+  0000              JumpIfZero:	            MACRO target
 29+  0000 ~                                    jp	z,target
 30+  0000                                      ENDM
 31+  0000
 32+  0000              ;.. Bit routines
 33+  0000              JumpOnLeadSignSet:      MACRO   reg, target
 34+  0000 ~                                    ld      a,reg
 35+  0000 ~                                    and     SignOnly8Bit
 36+  0000 ~                                    jp      nz,target
 37+  0000                                      ENDM
 38+  0000
 39+  0000              JumpOnLeadSignClear:    MACRO   reg, target
 40+  0000 ~                                    ld      a,reg
 41+  0000 ~                                    and     SignOnly8Bit
 42+  0000 ~                                    jp      z,target
 43+  0000                                      ENDM
 44+  0000
 45+  0000              JumpOnLeadSignSetA:     MACRO   target
 46+  0000 ~                                    and     SignOnly8Bit
 47+  0000 ~                                    jp      nz,target
 48+  0000                                      ENDM
 49+  0000
 50+  0000              JumpOnLeadSignClearA:   MACRO   target
 51+  0000 ~                                    and     SignOnly8Bit
 52+  0000 ~                                    jp      z,target
 53+  0000                                      ENDM
 54+  0000
 55+  0000              JumpOnMemBitSet:        MACRO mem, bitnbr, target
 56+  0000 ~                                    ld      a,(mem)
 57+  0000 ~                                    bit 	bitnbr,a
 58+  0000 ~                                    jp      nz,target
 59+  0000                                      ENDM
 60+  0000
 61+  0000              JumpOnMemBitClear:      MACRO mem, bitnbr, target
 62+  0000 ~                                    ld      a,(mem)
 63+  0000 ~                                    bit 	bitnbr,a
 64+  0000 ~                                    jp      z,target
 65+  0000                                      ENDM
 66+  0000
 67+  0000
 68+  0000              JumpOnABitSet:          MACRO   bitnbr, target
 69+  0000 ~                                    bit 	bitnbr, a
 70+  0000 ~                                    jp      nz,target
 71+  0000                                      ENDM
 72+  0000
 73+  0000              JumpOnABitClear:        MACRO   bitnbr, target
 74+  0000 ~                                    bit 	bitnbr, a
 75+  0000 ~                                    jp      z,target
 76+  0000                                      ENDM
 77+  0000
 78+  0000              JumpOnABit5Set:         MACRO   target
 79+  0000 ~                                    and     Bit5Only
 80+  0000 ~                                    jp      nz,target
 81+  0000                                      ENDM
 82+  0000
 83+  0000              JumpOnABit5Clear:       MACRO   target
 84+  0000 ~                                    and     Bit5Only
 85+  0000 ~                                    jp      z,target
 86+  0000                                      ENDM
 87+  0000
 88+  0000              JumpOnBitMaskSet:       MACRO   bitmask, target
 89+  0000 ~                                    and     bitmask
 90+  0000 ~                                    jp      nz,target
 91+  0000                                      ENDM
 92+  0000
 93+  0000              JumpOnBitMaskClear:     MACRO   bitmask, target
 94+  0000 ~                                    and     bitmask
 95+  0000 ~                                    jp      z,target
 96+  0000                                      ENDM
 97+  0000
 98+  0000              JumpOnMemBitMaskSet:    MACRO   mem, bitmask, target
 99+  0000 ~                                    ld      a,(mem)
100+  0000 ~                                    and     bitmask
101+  0000 ~                                    jp      nz,target
102+  0000                                      ENDM
103+  0000
104+  0000              JumpOnMemBitMaskClear:  MACRO   mem, bitmask, target
105+  0000 ~                                    ld      a,(mem)
106+  0000 ~                                    and     bitmask
107+  0000 ~                                    jp      z,target
108+  0000                                      ENDM
109+  0000
110+  0000              JumpOnBitSet:           MACRO  reg, bitnbr, target
111+  0000 ~                                    bit 	bitnbr,reg
112+  0000 ~                                    jp      nz,target
113+  0000                                      ENDM
114+  0000
115+  0000              JumpOnBitClear:         MACRO  reg, bitnbr, target
116+  0000 ~                                    bit 	bitnbr,reg
117+  0000 ~                                    jp      z,target
118+  0000                                      ENDM
119+  0000
120+  0000              ; Comparison Routines
121+  0000              JumpIfAGTEusng:         MACRO
122+  0000 ~                                    jp		nc,target
123+  0000                                      ENDM
124+  0000
125+  0000              JumpIfAGTENusng:        MACRO reg,target
126+  0000 ~                                    cp     reg
127+  0000 ~                                    jp		nc,target
128+  0000                                      ENDM
129+  0000
130+  0000              JumpIfAGTEMemusng:      MACRO mem,target
131+  0000 ~                                    ld      hl,mem
132+  0000 ~                                    cp      (hl)
133+  0000 ~                                    jp		nc,target
134+  0000                                      ENDM
135+  0000              JumpIfMemGTENusng:      MACRO mem, value, target
136+  0000 ~                                    ld     a,(mem)
137+  0000 ~                                    cp     value
138+  0000 ~                                    jp	  nc,target
139+  0000                                      ENDM
140+  0000
141+  0000              JumpIfMemGTEMemusng:    MACRO mem, address, target
142+  0000 ~                                    ld   a,(mem)
143+  0000 ~                                    ld   hl,address
144+  0000 ~                                    cp   (hl)
145+  0000 ~                                    jp	  nc,target
146+  0000                                      ENDM
147+  0000
148+  0000              JumpIfMemEqMemusng:     MACRO mem, address, target
149+  0000 ~                                    ld   a,(mem)
150+  0000 ~                                    ld   hl,address
151+  0000 ~                                    cp   (hl)
152+  0000 ~                                    jp	  z,target
153+  0000                                      ENDM
154+  0000
155+  0000              JumpIfMemNeMemusng:     MACRO mem, address, target
156+  0000 ~                                    ld   a,(mem)
157+  0000 ~                                    ld   hl,address
158+  0000 ~                                    cp   (hl)
159+  0000 ~                                    jp	  nz,target
160+  0000                                      ENDM
161+  0000
162+  0000              JumpIfMemTrue:          MACRO mem, target
163+  0000 ~                                    ld      a,(mem)
164+  0000 ~                                    and     a
165+  0000 ~                                    jp      z, target
166+  0000                                      ENDM
167+  0000
168+  0000              JumpIfMemFalse:         MACRO mem, target
169+  0000 ~                                    ld      a,(mem)
170+  0000 ~                                    and     a
171+  0000 ~                                    jp      nz, target
172+  0000                                      ENDM
173+  0000
174+  0000              JumpIfATrue:            MACRO target
175+  0000 ~                                    and     a
176+  0000 ~                                    jp      z, target
177+  0000                                      ENDM
178+  0000
179+  0000              JumpIfAFalse:           MACRO target
180+  0000 ~                                    and     a
181+  0000 ~                                    jp      nz, target
182+  0000                                      ENDM
183+  0000
184+  0000              JumpIfANotFalse:        MACRO target
185+  0000 ~                                    cp      $FF
186+  0000 ~                                    jp      nz, target
187+  0000                                      ENDM
188+  0000
189+  0000              ;-- Less than Macros -------------------------------------------
190+  0000              JumpIfALTMemHLusng:     MACRO target
191+  0000 ~                                    cp    (hl)
192+  0000 ~                                    jp	  c,target
193+  0000                                      ENDM
194+  0000
195+  0000              JumpIfRegLTE:           MACRO   reg, value, target
196+  0000 ~                                    ld      a,reg
197+  0000 ~                                    cp      value
198+  0000 ~                                    jp	    z,target
199+  0000 ~                                    jp		c, target
200+  0000                                      ENDM
201+  0000
202+  0000              JumpIfALTMemusng:       MACRO mem,target
203+  0000 ~                                    ld      hl,mem
204+  0000 ~                                    cp      (hl)
205+  0000 ~                                    jp		c,target
206+  0000                                      ENDM
207+  0000
208+  0000
209+  0000              JumpIfALTusng:          MACRO target
210+  0000 ~                                    jp		c,target
211+  0000                                      ENDM
212+  0000
213+  0000              JumpIfALTNusng:         MACRO value, target
214+  0000 ~                                    cp      value
215+  0000 ~                                    jp		c, target
216+  0000                                      ENDM
217+  0000
218+  0000              JumpIfALTNsigned:       MACRO   value, target
219+  0000 ~                                    cp      value
220+  0000 ~                                    jp      m,.SignSet
221+  0000 ~            .SignClear:             jp      pe,target       ; Sign (0), P/V (1)
222+  0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (0)
223+  0000 ~            .SignSet:               jp      po,target
224+  0000 ~            .CheckComplete:
225+  0000                                      ENDM
226+  0000
227+  0000              JumpIfMemLTNusng:       MACRO mem, value, target
228+  0000 ~                                    ld      a,(mem)
229+  0000 ~                                    cp      value
230+  0000 ~                                    jp	  c,target
231+  0000                                      ENDM
232+  0000
233+  0000              JumpIfMemLTMemusng:     MACRO mem, value, target
234+  0000 ~                                    ld    a,(mem)
235+  0000 ~                                    ld    hl,value
236+  0000 ~                                    cp    (hl)
237+  0000 ~                                    jp	  c,target
238+  0000                                      ENDM
239+  0000              ;-- ------------------------------------------------------------
240+  0000              JumpIfAGTENsigned       MACRO   value, target
241+  0000 ~                                    cp      value
242+  0000 ~                                    jp      m,.SignSet
243+  0000 ~            .SignClear:             jp      po,target       ; Sign (0), P/V (0)
244+  0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (1)
245+  0000 ~            .SignSet:               jp      pe,target
246+  0000 ~            .CheckComplete:
247+  0000                                      ENDM
248+  0000
249+  0000              JumpIfMemEqNusng:       MACRO mem,value,target
250+  0000 ~                                    ld  a,(mem)
251+  0000 ~                                    cp  value
252+  0000 ~                                    jp  z,target
253+  0000                                      ENDM
254+  0000
255+  0000              JumpIfMemNeNusng:       MACRO mem,value,target
256+  0000 ~                                    ld  a,(mem)
257+  0000 ~                                    cp  value
258+  0000 ~                                    jp  nz,target
259+  0000                                      ENDM
260+  0000
261+  0000              JumpIfMemZero:          MACRO mem,target
262+  0000 ~                                    ld  a,(mem)
263+  0000 ~                                    and a
264+  0000 ~                                    jp  z,target
265+  0000                                      ENDM
266+  0000
267+  0000              JumpIfMemNotZero:       MACRO mem,target
268+  0000 ~                                    ld  a,(mem)
269+  0000 ~                                    and a
270+  0000 ~                                    jp  nz,target
271+  0000                                      ENDM
272+  0000
273+  0000              JumpIfANENusng:         MACRO value, target
274+  0000 ~                                    cp     value
275+  0000 ~                                    jp      nz,target
276+  0000                                      ENDM
277+  0000
278+  0000              JumpIfANEquNusng:       MACRO value, target
279+  0000 ~                                    cp     value
280+  0000 ~                                    jp     z,target
281+  0000                                      ENDM
282+  0000
283+  0000              JumpIfANEMemusng:       MACRO  value, target
284+  0000 ~                                    ld    hl,value
285+  0000 ~                                    cp    (hl)
286+  0000 ~                                    jp      nz,target
287+  0000                                      ENDM
288+  0000
289+  0000              JumpIfAEqNusng:         MACRO value, target
290+  0000 ~                                    cp     value
291+  0000 ~                                    jp      z,target
292+  0000                                      ENDM
293+  0000
294+  0000              JumpIfAIsZero:	        MACRO target
295+  0000 ~                                    and     a   ; cp 0 - changed to and a for optimisation but affects other flags
296+  0000 ~                                    jp	    z, target
297+  0000                                      ENDM
298+  0000
299+  0000              JumpIfRegIsNotZero:     MACRO   reg, target
300+  0000 ~                                    ld      a,reg
301+  0000 ~                                    and     a
302+  0000 ~                                    jp	    nz,target
303+  0000                                      ENDM
304+  0000
305+  0000
306+  0000              JumpIfAIsNotZero:       MACRO target
307+  0000 ~                                    and     a
308+  0000 ~                                    jp	    nz,target
309+  0000                                      ENDM
310+  0000
311+  0000              JumpIfMemIsNotZero:     MACRO value, target
312+  0000 ~                                    ld      a,(value)
313+  0000 ~                                    and     a
314+  0000 ~                                    jp	    nz,target
315+  0000                                      ENDM
316+  0000              IfResultZeroGoto:	    MACRO target
317+  0000 ~                                    jp	z,target
318+  0000                                      ENDM
319+  0000
320+  0000              IfResultNotZeroGoto:    MACRO target
321+  0000 ~                                    jp	nz,target
322+  0000                                      ENDM
323+  0000
# file closed: jumpMacros.asm
 67   0000                                      INCLUDE "../../Macros/MathsMacros.asm"
# file opened: MathsMacros.asm
  1+  0000              ZeroA:		            MACRO
  2+  0000 ~                                    xor a
  3+  0000                                      ENDM
  4+  0000              ; sets z flag is HL less than 255 else sets it to nz (note opposite of GT127)
  5+  0000              IsHLGT255:              MACRO
  6+  0000 ~                                    bit     7,h
  7+  0000 ~                                    ret     z
  8+  0000 ~                                    ld      a,h
  9+  0000 ~                                    and     a
 10+  0000                                      ENDM
 11+  0000
 12+  0000              ; Sets z flat if HL = 255 else sets it to nz
 13+  0000              IsHLEqu255:             MACRO
 14+  0000 ~                                    ld      a,h
 15+  0000 ~                                    and     a               ; if its non zero then it can't be 255
 16+  0000 ~                                    ret     nz
 17+  0000 ~                                    ld      a,l
 18+  0000 ~                                    inc     a               ; if it was 255 the inc will set it to zero
 19+  0000                                      ENDM
 20+  0000
 21+  0000              ; Sets Z flag if GT 127 else nz
 22+  0000              IsHLGT127:              MACRO
 23+  0000 ~                                    bit     7,h             ; -ve?
 24+  0000 ~                                    jr      nz,.DoneCheck
 25+  0000 ~                                    ld      a,h             ; +ve > 256?
 26+  0000 ~                                    and     a
 27+  0000 ~                                    jr      nz,.DoneCheck
 28+  0000 ~                                    ld      a,l
 29+  0000 ~                                    and     $80             ; this will set z to false if bit 7 set and clear lower bits
 30+  0000 ~                                    cp      $80             ; this will set z to true if bit 7 set
 31+  0000 ~            .DoneCheck:
 32+  0000                                      ENDM
 33+  0000
 34+  0000              ReturnIfHLGT127:        MACRO
 35+  0000 ~                                    bit     7,h             ; -ve?
 36+  0000 ~                                    jr      nz,.DoneCheck   ; forces check complete
 37+  0000 ~                                    ld      a,h             ; +ve > 256?
 38+  0000 ~                                    and     a               ;
 39+  0000 ~                                    ret     nz              ; forces a return
 40+  0000 ~                                    bit     7,l             ; bit 7 of lower set?
 41+  0000 ~                                    ret     nz              ; forces a return
 42+  0000 ~            .DoneCheck:
 43+  0000                                      ENDM
 44+  0000
 45+  0000              IsDEGT127:              MACRO
 46+  0000 ~                                    bit     7,d
 47+  0000 ~                                    jr      nz,.DoneCheck
 48+  0000 ~                                    ld      a,d
 49+  0000 ~                                    jr      nz,.DoneCheck
 50+  0000 ~                                    ld      a,e
 51+  0000 ~                                    and     $80
 52+  0000 ~            .DoneCheck:
 53+  0000                                      ENDM
 54+  0000
 55+  0000              ABSa2c:                 MACRO
 56+  0000 ~                                    bit     7,a
 57+  0000 ~                                    jp      z,.DoneABSa
 58+  0000 ~                                    neg
 59+  0000 ~            .DoneABSa:
 60+  0000                                      ENDM
 61+  0000
 62+  0000              DEEquSquareA:           MACRO
 63+  0000 ~                                    ld  d,a
 64+  0000 ~                                    ld  e,a
 65+  0000 ~                                    mul de
 66+  0000                                      ENDM
 67+  0000
 68+  0000              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
 69+  0000 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
 70+  0000 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
 71+  0000 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
 72+  0000 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
 73+  0000 ~                                    xor $80                             ;
 74+  0000 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
 75+  0000 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
 76+  0000 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
 77+  0000 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
 78+  0000 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
 79+  0000 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
 80+  0000                                      ENDM
 81+  0000
 82+  0000              SignedHLTo2C:           MACRO
 83+  0000 ~                                    bit     7,h
 84+  0000 ~                                    jr      z,.Done2c
 85+  0000 ~                                    ld      a,h
 86+  0000 ~                                    and     SignMask8Bit
 87+  0000 ~                                    ld      h,a
 88+  0000 ~                                    NegHL
 89+  0000 ~            .Done2c:
 90+  0000                                      ENDM
 91+  0000
 92+  0000              MemSignedTo2C:          MACRO   memfrom
 93+  0000 ~                                    ld      hl,(memfrom)
 94+  0000 ~                                    bit     7,h
 95+  0000 ~                                    jr      z,.Done2c
 96+  0000 ~                                    ld      a,h
 97+  0000 ~                                    and     SignMask8Bit
 98+  0000 ~                                    ld      h,a
 99+  0000 ~            .Done2c:                ld      (memfrom),hl
100+  0000                                      ENDM
101+  0000
102+  0000
103+  0000                  ;returns result in H
104+  0000              EDiv10Inline:           MACRO
105+  0000 ~                                    ld      d,0
106+  0000 ~                                    ld      hl,de
107+  0000 ~                                    add     hl,hl
108+  0000 ~                                    add     hl,de
109+  0000 ~                                    add     hl,hl
110+  0000 ~                                    add     hl,hl
111+  0000 ~                                    add     hl,de
112+  0000 ~                                    add     hl,hl
113+  0000                                      ENDM
114+  0000
115+  0000              cpHLDE:                 MACRO
116+  0000 ~                                    push    hl
117+  0000 ~                                    and     a
118+  0000 ~                                    sbc     hl,de
119+  0000 ~                                    pop     hl
120+  0000                                      ENDM
121+  0000
122+  0000              cpABSDEHL:              MACRO
123+  0000 ~                                    push     hl,,de
124+  0000 ~                                    ld      a,h
125+  0000 ~                                    and     $7F
126+  0000 ~                                    ld      h,a
127+  0000 ~                                    ld      a,d
128+  0000 ~                                    and     $7F
129+  0000 ~                                    ld      d,a
130+  0000 ~                                    ex      de,hl
131+  0000 ~                                    sbc     hl,de
132+  0000 ~                                    pop     hl,,de
133+  0000                                      ENDM
134+  0000
135+  0000              ; Simple are they both the same setting z if they are
136+  0000              ; tehcicall this works but it measn the final ret z is alwys done
137+  0000              ; so jp needs to be to a target
138+  0000              cpHLEquDE:              MACRO   passedCheck
139+  0000 ~                                    ld      a,h
140+  0000 ~                                    cp      d
141+  0000 ~                                    jp      nz, passedCheck
142+  0000 ~                                    ld      a,l
143+  0000 ~                                    cp      e
144+  0000 ~            .NoTheSame:
145+  0000                                      ENDM
146+  0000
147+  0000              cpHLEquBC:              MACRO   passedCheck
148+  0000 ~                                    ld      a,h
149+  0000 ~                                    cp      b
150+  0000 ~                                    jp      nz, passedCheck
151+  0000 ~                                    ld      a,l
152+  0000 ~                                    cp      c
153+  0000 ~            .NoTheSame:
154+  0000                                      ENDM
155+  0000
156+  0000              cpDEEquBC:              MACRO   passedCheck
157+  0000 ~                                    ld      a,d
158+  0000 ~                                    cp      b
159+  0000 ~                                    jp      nz, passedCheck
160+  0000 ~                                    ld      a,e
161+  0000 ~                                    cp      c
162+  0000 ~            .NoTheSame:
163+  0000                                      ENDM
164+  0000              ; Simple version just sets carry if HL < DE reset, does an initial compare for z
165+  0000              cpHLDELeadSign:         MACRO
166+  0000 ~                                    ld      a,h
167+  0000 ~                                    cp      d
168+  0000 ~                                    jr      nz,.FullCompare
169+  0000 ~                                    ld      a,l
170+  0000 ~                                    cp      e
171+  0000 ~                                    ret     z
172+  0000 ~            .FullCompare:           ld      a,h
173+  0000 ~                                    xor     d
174+  0000 ~                                    and     $80
175+  0000 ~                                    jr      nz,.OppositeSigns   ; If opposite signs is a simple sign test
176+  0000 ~                                    ld      a,h                 ; same signs so a little simpler
177+  0000 ~                                    and     $80
178+  0000 ~                                    jp      z,cpHLDE            ; if h is positive then both are positive by here so just cpHLDE
179+  0000 ~                                    jp      cpABSDEHL           ; else we have to do ABScpDEHL
180+  0000 ~            .OppositeSigns:         ld      a,h
181+  0000 ~                                    and     $80
182+  0000 ~                                    and     $80
183+  0000 ~                                    jp      z,.HLGTDE
184+  0000 ~            .HLLTDE:                SetCarryFlag
185+  0000 ~                                    ret
186+  0000 ~            .HLGTDE:                ClearCarryFlag
187+  0000 ~                                    ret
188+  0000                                      ENDM
189+  0000
190+  0000              ;Unsigned
191+  0000              ;If HL == DE, then Z flag is set.
192+  0000              ;If HL != DE, then Z flag is reset.
193+  0000              ;If HL <  DE, then C flag is set.
194+  0000              ;If HL >= DE, then C flag is reset.
195+  0000              ;
196+  0000              ;Signed
197+  0000              ;If HL == DE, then Z flag is set.
198+  0000              ;If HL != DE, then Z flag is reset.
199+  0000              ;If HL <  DE, then S and P/V are different.
200+  0000              ;If HL >= DE, then S and P/V are the same.
201+  0000
202+  0000
203+  0000              N0equN1byN2div256:      MACRO param1,param2,param3
204+  0000 ~                                    ld      a,param3                        ;
205+  0000 ~                                    ld      e,a                         ; use e as var Q = value of XX15 [n] lo
206+  0000 ~                                    ld      a,param2                        ; A = XX16 element
207+  0000 ~                                    ld      d,a
208+  0000 ~                                    mul
209+  0000 ~                                    ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
210+  0000 ~                                    ld      (param1),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
211+  0000                                      ENDM
212+  0000
213+  0000              AequN1xorN2:            MACRO  param1,param2
214+  0000 ~                                    ld      a,(param1)
215+  0000 ~                                    xor     param2
216+  0000                                      ENDM
217+  0000
218+  0000              SpeedMulAxis:           MACRO   speedreg, axis
219+  0000 ~                                    ld      e,speedreg
220+  0000 ~                                    ld      hl,(axis)
221+  0000 ~                                    ld      a,h
222+  0000 ~                                    ClearSignBitA
223+  0000 ~                                    ld      d,a
224+  0000 ~                                    mul     de
225+  0000 ~                                    ld      a,h
226+  0000 ~                                    SignBitOnlyA
227+  0000 ~                                    ld      b,a;ld      c,a
228+  0000 ~                                    ld      h,d;ld      e,d
229+  0000 ~                                    ld      c,0;ld      d,0
230+  0000                                      ENDM
231+  0000
232+  0000              ; Adds speed (8 bit) to vertex (24 bit signed)
233+  0000              AddSpeedToVert:         MACRO   vertex
234+  0000 ~                                    ld      de,(vertex+1)
235+  0000 ~                                    ld      a,(vertex)
236+  0000 ~                                    ld      l,a
237+  0000 ~                                    call    AddBCHtoDELsigned               ; DEL = DEL + BCH
238+  0000 ~                                    ld      a,l
239+  0000 ~                                    ld      (vertex),a
240+  0000 ~                                    ld      (vertex+1),de
241+  0000                                      ENDM
# file closed: MathsMacros.asm
 68   0000                                      INCLUDE "../../Macros/ShiftMacros.asm"
# file opened: ShiftMacros.asm
  1+  0000              ShiftIYRight1: MACRO
  2+  0000 ~                           ld   a,iyh
  3+  0000 ~                           srl  a
  4+  0000 ~                           ld   iyh,a
  5+  0000 ~                           ld   a,iyl
  6+  0000 ~                           rra
  7+  0000 ~                           ld   iyl,a
  8+  0000                             ENDM
  9+  0000
 10+  0000              ShiftIXRight1: MACRO
 11+  0000 ~                           ld   a,ixh
 12+  0000 ~                           srl  a
 13+  0000 ~                           ld   ixh,a
 14+  0000 ~                           ld   a,ixl
 15+  0000 ~                           rra
 16+  0000 ~                           ld   ixl,a
 17+  0000                             ENDM
 18+  0000
 19+  0000              ShiftIXhHLRight1: MACRO
 20+  0000 ~                           ld  a,ixh
 21+  0000 ~                           srl a
 22+  0000 ~                           ld  ixh,a
 23+  0000 ~                           rr  h
 24+  0000 ~                           rr  l
 25+  0000                             ENDM
 26+  0000
 27+  0000              ShiftIYhDERight1: MACRO
 28+  0000 ~                           ld  a,iyh
 29+  0000 ~                           srl a
 30+  0000 ~                           ld  iyh,a
 31+  0000 ~                           rr  d
 32+  0000 ~                           rr  e
 33+  0000                             ENDM
 34+  0000
 35+  0000              ShiftIYlBCRight1: MACRO
 36+  0000 ~                           ld  a,iyl
 37+  0000 ~                           srl a
 38+  0000 ~                           ld  iyl,a
 39+  0000 ~                           rr  b
 40+  0000 ~                           rr  c
 41+  0000                             ENDM
 42+  0000
 43+  0000              ShiftIXlBCRight1: MACRO
 44+  0000 ~                           ld  a,ixl
 45+  0000 ~                           srl a
 46+  0000 ~                           ld  ixl,a
 47+  0000 ~                           rr  b
 48+  0000 ~                           rr  c
 49+  0000                             ENDM
 50+  0000
 51+  0000              ShiftHLRight1: MACRO
 52+  0000 ~                           srl h
 53+  0000 ~                           rr  l
 54+  0000                             ENDM
 55+  0000
 56+  0000              ShiftBHLRight1:MACRO
 57+  0000 ~                           srl b
 58+  0000 ~                           rr h
 59+  0000 ~                           rr  l
 60+  0000                             ENDM
 61+  0000
 62+  0000              ShiftCDERight1:MACRO
 63+  0000 ~                           srl c
 64+  0000 ~                           rr  d
 65+  0000 ~                           rr  e
 66+  0000                             ENDM
 67+  0000
 68+  0000
 69+  0000              SRAHLRight1: MACRO
 70+  0000 ~                           sra h
 71+  0000 ~                           rr  l
 72+  0000                             ENDM
 73+  0000
 74+  0000              ShiftDERight1: MACRO
 75+  0000 ~                           srl d
 76+  0000 ~                           rr  e
 77+  0000                             ENDM
 78+  0000
 79+  0000              ShiftBCRight1: MACRO
 80+  0000 ~                           srl b
 81+  0000 ~                           rr  c
 82+  0000                             ENDM
 83+  0000
 84+  0000
 85+  0000              ShiftHLDiv8:   MACRO
 86+  0000 ~                           srl h
 87+  0000 ~                           rr  l
 88+  0000 ~                           srl h
 89+  0000 ~                           rr  l
 90+  0000 ~                           srl h
 91+  0000 ~                           rr  l
 92+  0000                             ENDM
 93+  0000
 94+  0000              ShiftBHLLeft1:  MACRO
 95+  0000 ~                            sla l
 96+  0000 ~                            rl  h
 97+  0000 ~                            rl  b
 98+  0000                              ENDM
 99+  0000
100+  0000              ShiftCDELeft1:  MACRO
101+  0000 ~                            sla e
102+  0000 ~                            rl  d
103+  0000 ~                            rl  c
104+  0000                              ENDM
105+  0000
106+  0000              ShiftHLLeft1:  MACRO    ; 16 T states
107+  0000 ~                           sla l
108+  0000 ~                           rl  h
109+  0000                             ENDM
110+  0000
111+  0000              ShiftDELeft1:  MACRO    ; 16 T states
112+  0000 ~                           sla e
113+  0000 ~                           rl  d
114+  0000                             ENDM
115+  0000
116+  0000              BarrelHLLeft3: MACRO
117+  0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
118+  0000 ~                           push     bc      ; 10
119+  0000 ~                           ld       b,3     ; 7
120+  0000 ~                           bsrl     de,b    ; 8
121+  0000 ~                           pop      bc      ; 10
122+  0000 ~                           ex       de,hl   ; 4
123+  0000                             ENDM
124+  0000
125+  0000              BarrelHLRight3: MACRO
126+  0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
127+  0000 ~                           push     bc      ; 10
128+  0000 ~                           ld       b,3     ; 7
129+  0000 ~                           bsrl     de,b    ; 8
130+  0000 ~                           pop      bc      ; 10
131+  0000 ~                           ex       de,hl   ; 4
132+  0000                             ENDM
133+  0000
134+  0000              RollBCLeft1:   MACRO    ; 16 T states
135+  0000 ~                           rl  c
136+  0000 ~                           rl  b
137+  0000                             ENDM
138+  0000
139+  0000              RollDELeft1:   MACRO    ; 16 T states
140+  0000 ~                           rl  e
141+  0000 ~                           rl  d
142+  0000                             ENDM
143+  0000
144+  0000              ShiftBCLeft1:  MACRO    ; 16 T states
145+  0000 ~                           sla c
146+  0000 ~                           rl  b
147+  0000                             ENDM
148+  0000
149+  0000              ShiftLeftMem:       MACRO   reg
150+  0000 ~                                ld      hl,reg
151+  0000 ~                                sla     (hl)
152+  0000                                  ENDM
153+  0000
154+  0000
155+  0000
156+  0000              ShiftMem16Right1:   MACRO memaddr
157+  0000 ~                                ld    hl,(memaddr)
158+  0000 ~                                srl   h
159+  0000 ~                                rr    l
160+  0000 ~                                ld    (memaddr),hl
161+  0000                                  ENDM
162+  0000
163+  0000              ShiftMem8Right1:    MACRO memaddr
164+  0000 ~                                ld      a,(memaddr)
165+  0000 ~                                srl     a
166+  0000 ~                                ld      (memaddr),a
167+  0000                                  ENDM
168+  0000
169+  0000
170+  0000              ShiftMem8Left1A:    MACRO memaddr
171+  0000 ~                                ld      a,(memaddr)
172+  0000 ~                                sla     a
173+  0000 ~                                ld      (memaddr),a
174+  0000                                  ENDM
175+  0000
# file closed: ShiftMacros.asm
 69   0000                                      INCLUDE "../../Macros/NegateMacros.asm"
# file opened: NegateMacros.asm
  1+  0000
  2+  0000              macronegate16hl:	MACRO
  3+  0000 ~            					xor 	a
  4+  0000 ~            					sub 	l
  5+  0000 ~            					ld 		l,a
  6+  0000 ~            					sbc 	a,a
  7+  0000 ~            					sub 	h
  8+  0000 ~            					ld 		h,a
  9+  0000              					ENDM
 10+  0000
 11+  0000
 12+  0000              macroAbsHL:         MACRO
 13+  0000 ~                                bit     7,h
 14+  0000 ~                                jp      z,.alreadyABS
 15+  0000 ~            					xor 	a
 16+  0000 ~            					sub 	l
 17+  0000 ~            					ld 		l,a
 18+  0000 ~            					sbc 	a,a
 19+  0000 ~            					sub 	h
 20+  0000 ~            					ld 		h,a
 21+  0000 ~            .alreadyABS:
 22+  0000                                  ENDM
 23+  0000
 24+  0000              macronegate16de:	MACRO
 25+  0000 ~            					xor 	a
 26+  0000 ~                                sub 	e
 27+  0000 ~                                ld 		e,a
 28+  0000 ~                                sbc 	a,a
 29+  0000 ~                                sub 	d
 30+  0000 ~                                ld 		d,a
 31+  0000              					ENDM
 32+  0000
 33+  0000              macronegate16bc:	MACRO
 34+  0000 ~            					xor 	a
 35+  0000 ~                                sub 	c
 36+  0000 ~                                ld 		c,a
 37+  0000 ~                                sbc 	a,a
 38+  0000 ~                                sub 	b
 39+  0000 ~                                ld 		b,a
 40+  0000              					ENDM
 41+  0000
 42+  0000              macronegate16ix:	MACRO
 43+  0000 ~            					xor 	a
 44+  0000 ~                                sub 	ixl
 45+  0000 ~                                ld 		ixl,a
 46+  0000 ~                                sbc 	a,a
 47+  0000 ~                                sub 	ixh
 48+  0000 ~                                ld 		ixh,a
 49+  0000              					ENDM
 50+  0000
 51+  0000
 52+  0000              NegIY:			    MACRO
 53+  0000 ~                                xor a
 54+  0000 ~                                sub iyl
 55+  0000 ~                                ld iyl,a
 56+  0000 ~                                sbc a,a
 57+  0000 ~                                sub iyh
 58+  0000 ~                                ld iyh,a
 59+  0000                                  ENDM
 60+  0000
 61+  0000              NegHL:			    MACRO
 62+  0000 ~                                xor     a
 63+  0000 ~                                sub     l
 64+  0000 ~                                ld      l,a
 65+  0000 ~                                sbc     a,a
 66+  0000 ~                                sub     h
 67+  0000 ~                                ld      h,a
 68+  0000                                  ENDM
 69+  0000
 70+  0000              NegAHL:			    MACRO
 71+  0000 ~                                ld      b,a         ; save a in b
 72+  0000 ~                                xor     a           ; l = 0 - l
 73+  0000 ~                                sub     l
 74+  0000 ~                                ld      l,a
 75+  0000 ~                                sbc     a,a         ; h = 0 - h
 76+  0000 ~                                sub     h
 77+  0000 ~                                ld      h,a
 78+  0000 ~                                sbc     a,a         ; a= 0 - b
 79+  0000 ~                                sub     b
 80+  0000                                  ENDM
 81+  0000
 82+  0000              NegDE:			    MACRO
 83+  0000 ~                                xor a
 84+  0000 ~                                sub e
 85+  0000 ~                                ld e,a
 86+  0000 ~                                sbc a,a
 87+  0000 ~                                sub d
 88+  0000 ~                                ld d,a
 89+  0000                                  ENDM
 90+  0000
 91+  0000              NegBC:			    MACRO
 92+  0000 ~                                xor a
 93+  0000 ~                                sub c
 94+  0000 ~                                ld c,a
 95+  0000 ~                                sbc a,a
 96+  0000 ~                                sub  b
 97+  0000 ~                                ld b,a
 98+  0000                                  ENDM
 99+  0000
100+  0000              NegH                MACRO
101+  0000 ~                                ld      a,h
102+  0000 ~                                neg
103+  0000 ~                                ld      h,a
104+  0000                                  ENDM
105+  0000
106+  0000              NegD                MACRO
107+  0000 ~                                ld      a,d
108+  0000 ~                                neg
109+  0000 ~                                ld      d,a
110+  0000                                  ENDM
111+  0000
112+  0000              NegB                MACRO
113+  0000 ~                                ld      a,b
114+  0000 ~                                neg
115+  0000 ~                                ld      b,a
116+  0000                                  ENDM
117+  0000
# file closed: NegateMacros.asm
 70   0000                                      INCLUDE "../../Macros/carryFlagMacros.asm"
# file opened: carryFlagMacros.asm
  1+  0000
  2+  0000              SetCarryFlag:           MACRO
  3+  0000 ~                                    scf
  4+  0000                                      ENDM
  5+  0000
  6+  0000              ClearCarryFlag:	        MACRO
  7+  0000 ~                                    or a
  8+  0000                                      ENDM
  9+  0000
 10+  0000              FlipCarryFlag:          MACRO
 11+  0000 ~                                    ccf
 12+  0000                                      ENDM
 13+  0000
# file closed: carryFlagMacros.asm
 71   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 72   0000              ; Total screen list
 73   0000              ; Local Chart
 74   0000              ; Galactic Chart
 75   0000              ; Market Prices
 76   0000              ; Inventory
 77   0000              ; Comander status
 78   0000              ; System Data
 79   0000              ; Mission Briefing
 80   0000              ; missio completion
 81   0000              ; Docked  Menu (only place otehr than pause you can load and save)
 82   0000              ; Pause Menu (only place you can load from )
 83   0000              ; byint and selling equipment
 84   0000              ; bying and selling stock
 85   0000
 86   0000              TopOfStack              equ $5CCB ;$6100
 87   0000
 88   0000                                      ORG $5DCB;      $6200
 89   5DCB F3           EliteNextStartup:       di
 90   5DCC FD 00                                break
 91   5DCE
 92   5DCE
 93   5DCE 2A 93 5E     MyRollAndPitch24Bit:    ld      hl,(ALPHA)
 94   5DD1 7C                                   ld      a,h
 95   5DD2 B5                                   or      l
 96   5DD3 C2 D6 5D                             jp      nz,.NotZero
 97   5DD6                                      ;break
 98   5DD6              .NotZero:
 99   5DD6              ;   1. K2 = y - alpha * x
100   5DD6 3A 93 5E     .Step1:                 ld      a,(ALPHA)                   ; Calc alpha * x
101   5DD9 57                                   ld      d,a                         ;
102   5DDA 2A 8B 5E                             ld      hl,(UBnKxhi)                ;
103   5DDD 3A 8A 5E                             ld      a,(UBnKxlo)                 ;
104   5DE0 5F                                   ld      e,a                         ;
105   5DE1                                      ;break
106   5DE1 CD ED 5E                             call    DEHLequHLEmulDs             ; DELC = alpha * x so DEL is what we want
107   5DE4 22 7E 5E                             ld      (Ax),hl                     ;
108   5DE7 ED 53 80 5E                          ld      (Ax+2),de                   ;
109   5DEB 4C           .YMinusAx:              ld      c,h
110   5DEC 3A 8F 5E                             ld      a,(UBnKysgn)
111   5DEF 47                                   ld      b,a
112   5DF0 2A 8D 5E                             ld      hl,(UBnKylo)
113   5DF3                                      ;break
114   5DF3 CD 0F 61                             call    AHLequBHLminusDEC           ; K2 = y - alpha * x
115   5DF6 22 86 5E                             ld      (K2),hl
116   5DF9 32 88 5E                             ld      (K2+2),a
117   5DFC              ;   2. z = z + beta * K2
118   5DFC 5D           .Step2:                 ld      e,l                         ; HEL = AHL
119   5DFD 6C                                   ld      l,h
120   5DFE 67                                   ld      h,a
121   5DFF 3A 94 5E                             ld      a,(BETA)
122   5E02 57                                   ld      d,a
123   5E03                                      ;break
124   5E03 CD ED 5E                             call    DEHLequHLEmulDs             ; DELC = beta * K2 so DEL is what we want
125   5E06 22 7A 5E                             ld      (Bk),hl                     ;
126   5E09 ED 53 7C 5E                          ld      (Bk+2),de                   ;
127   5E0D 4C           .ZPlusBk:               ld      c,h
128   5E0E 2A 90 5E                             ld      hl,(UBnKzlo)
129   5E11 3A 92 5E                             ld      a,(UBnKzsgn)
130   5E14 47                                   ld      b,a
131   5E15                                      ;break
132   5E15                                      DISPLAY "OPTIMISE TO AHL = BHL + DEC to improv post multiply"
133   5E15 CD 01 61                             call    AHLequBHLplusDEC
134   5E18 22 90 5E     .SetZ:                  ld      (UBnKzlo),hl
135   5E1B 32 92 5E                             ld      (UBnKzsgn),a
136   5E1E              ;   3. y = K2 - beta * z
137   5E1E 3A 94 5E     .Step3:                 ld      a,(BETA)
138   5E21 57                                   ld      d,a
139   5E22 2A 91 5E     .GetZBack:              ld      hl,(UBnKzhi)
140   5E25 3A 90 5E                             ld      a,(UBnKzlo)
141   5E28 5F                                   ld      e,a
142   5E29                                      ;break
143   5E29 CD ED 5E                             call    DEHLequHLEmulDs             ; DELC = beta * K2 so DEL is what we want
144   5E2C
145   5E2C 22 76 5E     .K2MinusBZ:             ld      (Bz),hl
146   5E2F ED 53 78 5E                          ld      (Bz+2),de
147   5E33 45                                   ld      b,l
148   5E34 4C                                   ld      c,h
149   5E35 2A 86 5E                             ld      hl,(K2)
150   5E38 3A 88 5E                             ld      a,(K2+2) ; will it go wrong if K2 negative?
151   5E3B 47                                   ld      b,a
152   5E3C                                      ;break
153   5E3C CD 0F 61                             call    AHLequBHLminusDEC          ; y = K2 -Bz
154   5E3F 22 8D 5E     .SetY:                  ld      (UBnKylo),hl
155   5E42 32 8F 5E                             ld      (UBnKysgn),a
156   5E45              ;   4. x = x + alpha * y
157   5E45 FD 00        .Step4:                 break
158   5E47 3A 93 5E                             ld      a,(ALPHA)                   ; Calc alpha * x
159   5E4A 57                                   ld      d,a                         ;
160   5E4B 2A 8E 5E     .GetYBack:              ld      hl,(UBnKyhi)                ;
161   5E4E 3A 8D 5E                             ld      a,(UBnKylo)                 ;
162   5E51 5F                                   ld      e,a                         ;
163   5E52 FD 00                                break
164   5E54 CD ED 5E                             call    DEHLequHLEmulDs             ; DELC = alpha * x so DEL is what we want
165   5E57 22 82 5E                             ld      (Ay),hl                     ;
166   5E5A ED 53 84 5E                          ld      (Ay+2),de                   ;
167   5E5E                                      ; now DEHL holds DELC so we can use that but shift by 8 bits to get correct value to add
168   5E5E                                      ; now d holds sign so we need to pull that back in and get HL into DE  as DE should only ever be S000
169   5E5E 4C           .XPlusAx:               ld      c,h
170   5E5F 3A 8C 5E     .GetXBack:              ld      a,(UBnKxsgn)
171   5E62 47                                   ld      b,a
172   5E63 2A 8A 5E                             ld      hl,(UBnKxlo)
173   5E66 FD 00                                break
174   5E68 CD 01 61                             call    AHLequBHLplusDEC           ; x+ alpha * x
175   5E6B 22 8A 5E     .SetX:                  ld      (UBnKxlo),hl
176   5E6E 32 8C 5E                             ld      (UBnKxsgn),a
177   5E71 FD 00                                break
178   5E73 C3 D6 5D                             jp      .NotZero
179   5E76
180   5E76 00 00 00 00  Bz                      DS  4
181   5E7A 00 00 00 00  Bk                      DS  4
182   5E7E 00 00 00 00  Ax                      DS  4
183   5E82 00 00 00 00  Ay                      DS  4
184   5E86 00 00 00 00  K2                      DS  4
185   5E8A 00           UBnKxlo                 DB  0
186   5E8B 00           UBnKxhi                 DB  0
187   5E8C 00           UBnKxsgn                DB  0
188   5E8D 79           UBnKylo                 DB  $79
189   5E8E 05           UBnKyhi                 DB  $05
190   5E8F 00           UBnKysgn                DB  0
191   5E90 10           UBnKzlo                 DB  $10
192   5E91 64           UBnKzhi                 DB  $64
193   5E92 80           UBnKzsgn                DB  $80
194   5E93 01           ALPHA                   DB  1
195   5E94 00           BETA                    DB  0
196   5E95 00           varQ                    DB  0
197   5E96 00           varRS                   DB  0
198   5E97 C9                                   ret
199   5E98
200   5E98              ;--------------------------------------------------------------------------------------
201   5E98                  INCLUDE	"../../MathsFPS78/asm_multiply_S78.asm"
# file opened: asm_multiply_S78.asm
  1+  5E98              ; asm_mulitply_S78
  2+  5E98              ; Multiplcation routines for Lead sign 7.8 format, adapted based on Q88 format but only respresents negatives by sign bit
  3+  5E98
  4+  5E98              ; replaces all maths multplication
  5+  5E98
  6+  5E98              ; DE = D (S7) * E (S7)
  7+  5E98              ; Optimised mulitploy routines S7 by S7 signed
  8+  5E98              ; muliptiply S7.0 bu ny S7e signed
  9+  5E98              ; used A and B registers
 10+  5E98              ; result in DE
 11+  5E98              ; This replaces DEequDmulEs
 12+  5E98              ; 16 bit HL * DE
 13+  5E98              ; start with lower and help with add sequence           ; all with carry flag (as lower case target reg)
 14+  5E98              ;        L *     E   X0mulY0 1>> 1>>  shift >> 16       ;     HL = L * E
 15+  5E98              ;        L *   D     Y1mulX0 0   1>>  shift >> 8        ;   DEHL = 00HL  + 0[L*D]0
 16+  5E98              ;      H   *     E   X1mulY0 0   1>>  shift >> 8        ;   DEHL = DEHL  + 0[H*E]0 = DEH + 0[H*E]
 17+  5E98              ;      H   *   D     X1mulY1 0   0    shift 0           ;  CDE   = CDE   + 0[H*D]
 18+  5E98              ; 16 bit HL *  E
 19+  5E98              ; start with lower and help with add sequence           ; all with carry flag (as lower case target reg)
 20+  5E98              ;        L *     E   X0mulY0 1>> 1>>  shift >> 16       ;     HL = L * E
 21+  5E98              ;        L *   D     Y1mulX0 0   1>>  shift >> 8        ;   DEHL = 00HL  + 0[L*D]0
 22+  5E98              ;      H   *     E   X1mulY0 0   1>>  shift >> 8        ;   DEHL = DEHL  + 0[H*E]0 = DEH + 0[H*E]
 23+  5E98              ;      H   *   D     X1mulY1 0   0    shift 0           ;  CDE   = CDE   + 0[H*D]
 24+  5E98
 25+  5E98
 26+  5E98
 27+  5E98 7A           DEequDmulEs:        ld      a,d                     ; work out resultant sign and load into b
 28+  5E99 AB                               xor     e                       ; .
 29+  5E9A E6 80                            and     SignOnly8Bit            ; .
 30+  5E9C 47                               ld      b,a                     ; .
 31+  5E9D 7A                               ld      a,d                     ; now clear d sign bit
 32+  5E9E E6 7F                            and     SignMask8Bit            ; .
 33+  5EA0 57                               ld      d,a                     ; .
 34+  5EA1 7B                               ld      a,e                     ; now clear e sign bit
 35+  5EA2 E6 7F                            and     SignMask8Bit            ; .
 36+  5EA4 5F                               ld      e,a                     ; .
 37+  5EA5 ED 30                            mul     de                      ; do mulitply
 38+  5EA7 7A                               ld      a,d                     ; get sign bit from b and re0introduce it
 39+  5EA8 B0                               or      b                       ; .
 40+  5EA9 57                               ld      d,a                     ; .
 41+  5EAA C9                               ret
 42+  5EAB
 43+  5EAB              fixedS158_muls:
 44+  5EAB              ;HL.0 = BH.L * CD.E, does this by scaling down to BH * CD then scaled result up by a word
 45+  5EAB 6C                               ld      l,h
 46+  5EAC 60                               ld      h,b
 47+  5EAD 5A                               ld      e,d
 48+  5EAE 51                               ld      d,c
 49+  5EAF C3 A4 5F                         jp      fixedS78_muls
 50+  5EB2
 51+  5EB2 57           AequAmulEdiv256u:   ld      d,a
 52+  5EB3 ED 30                            mul     de
 53+  5EB5 7A                               ld      a,d
 54+  5EB6 C9                               ret
 55+  5EB7
 56+  5EB7 57           AequAmulQdiv256u:   ld      d,a
 57+  5EB8 3A 95 5E                         ld      a,(varQ)
 58+  5EBB 5F                               ld      e,a
 59+  5EBC ED 30                            mul     de
 60+  5EBE 7A                               ld      a,d
 61+  5EBF C9                               ret
 62+  5EC0
 63+  5EC0              ;HL = HL * DE in 2's compliment
 64+  5EC0 7A           HLequHLmulDE2sc:        ld      a,d
 65+  5EC1 AC                                   xor     h
 66+  5EC2 E6 80                                and     SignOnly8Bit
 67+  5EC4 FD 67                                ld      iyh,a               ; save sign bit for result
 68+  5EC6 7C                                   ld      a,h
 69+  5EC7 E6 80                                and     SignOnly8Bit
 70+  5EC9 28 06                                jr      z,.HLPositive
 71+  5ECB              .HLNegative:            NegHL
 71+  5ECB AF          >                    xor     a
 71+  5ECC 95          >                    sub     l
 71+  5ECD 6F          >                    ld      l,a
 71+  5ECE 9F          >                    sbc     a,a
 71+  5ECF 94          >                    sub     h
 71+  5ED0 67          >                    ld      h,a
 72+  5ED1 7A           .HLPositive:            ld      a,d
 73+  5ED2 E6 80                                and     SignOnly8Bit
 74+  5ED4 28 06                                jr      z,.DEPositive
 75+  5ED6              .DENegative:            NegDE
 75+  5ED6 AF          >                    xor a
 75+  5ED7 93          >                    sub e
 75+  5ED8 5F          >                    ld e,a
 75+  5ED9 9F          >                    sbc a,a
 75+  5EDA 92          >                    sub d
 75+  5EDB 57          >                    ld d,a
 76+  5EDC CD 9E 5F     .DEPositive:            call    HLequHLmulDEu         ; now do calc
 77+  5EDF FD 7C                                ld      a,iyh
 78+  5EE1 A7                                   and     a                   ; if its 0 then we are good
 79+  5EE2 C8                                   ret     z
 80+  5EE3
 81+  5EE3              ; "ASM_FMUTKL .FMLTU	\ -> &2847  \ A=D*E/256unsg  Fast multiply"
 82+  5EE3 ED 30        AequDmulEdiv256u:   mul     de
 83+  5EE5 7A                               ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
 84+  5EE6 C9                               ret
 85+  5EE7              ; DE.LC = HL.E by .D leading Sign (replaces mulHLEbyDSigned)
 86+  5EE7 CD ED 5E     DELCequHLEmulDs:    call    DEHLequHLEmulDs     ; Retained for backwards compatibility until swapped
 87+  5EEA 4D                               ld      c,l                 ; to DEHLequHLEmulDs in all code
 88+  5EEB 6C                               ld      l,h
 89+  5EEC C9                               ret
 90+  5EED
 91+  5EED              ; DE.HL = HL.E by .D leading Sign (replaces mulHLEbyDSigned)
 92+  5EED 7A           DEHLequHLEmulDs:    ld      a,d                 ; get sign from d
 93+  5EEE AC                               xor     h                   ; xor with h to get resultant sign
 94+  5EEF E6 80                            and     SignOnly8Bit        ; .
 95+  5EF1 FD 67                            ld      iyh,a               ; iyh = copy of sign
 96+  5EF3 CB BC                            res     7,h                 ; clear sign bit to get ABS values
 97+  5EF5 CB BA                            res     7,d                 ;
 98+  5EF7 7A           .ChecForZero:       ld      a,d                 ; quick test for d
 99+  5EF8 A7                               and     a
100+  5EF9 28 12                            jr      z,.ResultZero       ; now test HLE
101+  5EFB 7C                               ld      a,h                 ;
102+  5EFC B5                               or      l                   ;
103+  5EFD B3                               or      e                   ;
104+  5EFE 28 0D                            jr      z,.ResultZero       ;
105+  5F00 7A           .LoadForDEHLmulAu:  ld      a,d                 ; we now have divisor set
106+  5F01 53                               ld      d,e
107+  5F02 5C                               ld      e,h
108+  5F03 65                               ld      h,l
109+  5F04 6A                               ld      l,d
110+  5F05 CD 13 5F                         call    DEHLequEHLmulAu
111+  5F08 7A                               ld      a,d
112+  5F09 FD B4                            or      iyh                 ;
113+  5F0B 57                               ld      d,a                 ; d is set , now need to shift about HL into LC (later we will change calls)
114+  5F0C C9                               ret
115+  5F0D              .ResultZero:        ZeroA
115+  5F0D AF          >                        xor a
116+  5F0E 57                               ld      d,a
117+  5F0F 5F                               ld      e,a
118+  5F10 6F                               ld      l,a
119+  5F11 4F                               ld      c,a
120+  5F12 C9                               ret
121+  5F13
122+  5F13
123+  5F13              ; adehl = ehl * a , we will simplify this down to ehl * a (or d?)
124+  5F13              DEHLequEHLmulAu:    ;ld      b,0 ; N/A ld      b,d                       ; relocate DE
125+  5F13 4B                               ld      c,e                 ; x2
126+  5F14 5D                               ld      e,l                 ; x0
127+  5F15 57                               ld      d,a                 ; y0
128+  5F16 ED 30                            mul     de                  ; de = y0*x0
129+  5F18 08                               ex      af,af               ; save y0 'accumulator
130+  5F19 6B                               ld      l,e                 ; l = p0
131+  5F1A 7A                               ld      a,d                 ; a = p1 carry
132+  5F1B 08                               ex      af,af               ; get back y0
133+  5F1C 5C                               ld      e,h                 ; x1
134+  5F1D 57                               ld      d,a                 ; y0
135+  5F1E ED 30                            mul     de                  ; y0*x1
136+  5F20 08                               ex      af,af               ; get back carry
137+  5F21 83                               add     a,e                 ; h = carry + LSW of y0 & x1
138+  5F22 67                               ld      h,a                 ; .
139+  5F23 7A                               ld      a,d                 ; a = p2 carry
140+  5F24 08                               ex      af,af               ; get back y0
141+  5F25 59                               ld      e,c                 ; y0*x2
142+  5F26 57                               ld      d,a                 ; .
143+  5F27 ED 30                            mul     de                  ; .
144+  5F29 08                               ex      af,af               ; get back p2 carry
145+  5F2A 8B                               adc     a,e                 ; and add LWS of y0*x2
146+  5F2B 5F                               ld      e,a                 ; e = p3 so its set
147+  5F2C 7A                               ld      a,d
148+  5F2D CE 00                            adc     a,0                 ; and set d to the carry bit if there was one
149+  5F2F 57                               ld      d,a                 ; d = carry, so the result is DEHL
150+  5F30 C9                               ret
151+  5F31              ; ahl = hl * e simplified 16x8 muliplication
152+  5F31 54           AHLequHLmulE:       ld      d,h                 ; x1
153+  5F32 63                               ld      h,e                 ; y0
154+  5F33 ED 30                            mul     de                  ; x1*y0
155+  5F35 EB                               ex      de,hl
156+  5F36 ED 30                            mul     de                  ; y0*xl, hl = x1*y0l
157+  5F38 7A                               ld      a,d                 ; sum products
158+  5F39 85                               add     a,l
159+  5F3A 57                               ld      d,a
160+  5F3B EB                               ex      de,hl
161+  5F3C 7A                               ld      a,d
162+  5F3D CE 00                            adc     a,0
163+  5F3F C9                               ret
164+  5F40
165+  5F40
166+  5F40                                  DISPLAY "TO DO TEST IF this gets D correct"
167+  5F40                                  ;ld      c,a                 ; c = p2
168+  5F40                                  ;ld      a,d                 ; a = p3 carry
169+  5F40                                  ;ex      af,af
170+  5F40                                  ;ld e,b                     we don;t have x3
171+  5F40                                  ;ld d,a
172+  5F40                                  ;mul de                       ; y*x3
173+  5F40                                  ;ex af,af
174+  5F40                                  ;adc a,e
175+  5F40                                  ;ld b,a                       ;'p3
176+  5F40                                  ;ld a,d                       ;'p4 carry
177+  5F40                                  ;adc a,0                      ;'final carry
178+  5F40
179+  5F40                                  ;ld d,b                       ; return DE
180+  5F40                                  ;ld e,c
181+  5F40
182+  5F40              ; kept for now but think its good to delete
183+  5F40              ;
184+  5F40              ;                    ld      b,d                 ; save Quotient y0
185+  5F40              ;.mul1:              mul     de                  ; [IYL]C = E * D    (p1) (p0) x0 * y0
186+  5F40              ;                    ld      c,e                 ; .
187+  5F40              ;                    ld      iyl,d               ; .
188+  5F40              ;.mul2:              ld      e,l                 ; de = x1 * y0
189+  5F40              ;                    ld      d,b                 ; .
190+  5F40              ;                    mul     de                  ; .
191+  5F40              ;                    ld      a,iyl               ; get back p1 (carry)
192+  5F40              ;.carrybyte1:        add     a,e                 ; l = p1 = p1 + LSW of x1 * y0 and we are doen with carry
193+  5F40              ;                    ld      l,a                 ; .
194+  5F40              ;                    ld      iyl,d               ; save new carry byte MSW of x1 * y0
195+  5F40              ;.mul3:              ld      e,h                 ; E = H * D
196+  5F40              ;                    ld      d,b                 ; .
197+  5F40              ;                    mul     de                  ; .
198+  5F40              ;                    ld      a,iyl
199+  5F40              ;                    adc     a,e                 ; .
200+  5F40              ;                    ld      e,a                 ; .
201+  5F40              ;.ItsNotZero:        ld      a,d                 ;
202+  5F40              ;                    adc     a,0                 ; final carry bit
203+  5F40              ;                    or      iyh                 ; bring back sign
204+  5F40              ;                    ld      d,a                 ; s = sign
205+  5F40              ;                    ret
206+  5F40              ;.ResultZero:        ld      de,0
207+  5F40              ;                    ZeroA
208+  5F40              ;                    ld      c,a
209+  5F40              ;                    ld      l,a
210+  5F40              ;                    ret
211+  5F40                  DISPLAY "TODO replace this with non memory access version"
212+  5F40              HLequSRmulQdiv256:  ;X.Y=x1 lo.S*M/256  	\ where M/256 is gradient replaces HLequSRmulQdiv256
213+  5F40 2A 96 5E                         ld      hl,(varRS)
214+  5F43 3A 95 5E                         ld      a,(varQ)
215+  5F46 C5 D5        HLeqyHLmulAdiv256:  push    bc,,de
216+  5F48 11 00 00                         ld      de,0        ; de = XY
217+  5F4B 47                               ld      b,a         ; b = Q
218+  5F4C                                  ShiftHLRight1
218+  5F4C CB 3C       >               srl h
218+  5F4E CB 1D       >               rr  l
219+  5F50 CB 20                            sla     b
220+  5F52 30 03                            jr      nc,.LL126
221+  5F54 EB           .LL125:             ex      de,hl
222+  5F55 19                               add     hl,de
223+  5F56 EB                               ex      de,hl       ; de = de + rs
224+  5F57              .LL126:             ShiftHLRight1
224+  5F57 CB 3C       >               srl h
224+  5F59 CB 1D       >               rr  l
225+  5F5B CB 20                            sla b
226+  5F5D 38 F5                            jr      c,.LL125
227+  5F5F 20 F6                            jr      nz,.LL126
228+  5F61 EB                               ex      de,hl   ; hl = result
229+  5F62 D1 C1                            pop     bc,,de
230+  5F64 C9                               ret
231+  5F65
232+  5F65              ; AHL = HL * E unsigned, in effect X1 X0 * Y0
233+  5F65 AB           AHLequHLmulEu:      xor     e                       ; .
234+  5F66 E6 80                            and     SignOnly8Bit            ; .
235+  5F68 47                               ld      b,a                     ; .
236+  5F69 7A                               ld      a,d                     ; now clear d sign bit
237+  5F6A E6 7F                            and     SignMask8Bit            ; .
238+  5F6C 57                               ld      d,a                     ; .
239+  5F6D 7B                               ld      a,e                     ; now clear e sign bit
240+  5F6E E6 7F                            and     SignMask8Bit            ; .
241+  5F70 5F                               ld      e,a                     ; .
242+  5F71 ED 30                            mul     de                      ; do mulitply
243+  5F73 7A                               ld      a,d                     ; get sign bit from b and re0introduce it
244+  5F74 B0                               or      b                       ; .
245+  5F75 57                               ld      d,a                     ; .
246+  5F76 C9                               ret
247+  5F77 54           .performMultiplyU:  ld      d,h                     ; de = x1 y0
248+  5F78 63                               ld      h,e                     ; save y0 into h
249+  5F79 ED 30                            mul     de                      ; de = x1 * y0
250+  5F7B EB                               ex      de,hl                   ; de = y0 x0, hl = x1 * y0 (p2 p1)
251+  5F7C ED 30                            mul     de                      ; de = y0 * x0
252+  5F7E 7A                               ld      a,d                     ; sum products y0 * x0 upper byte + x1 * y0 lower byte
253+  5F7F 85                               add     a,l                     ; .
254+  5F80 57                               ld      d,a                     ; d = result (p1)
255+  5F81 EB                               ex      de,hl                   ; hl = p1 p0
256+  5F82 7A                               ld      a,d                     ; a = p2 + carry from add above
257+  5F83 CE 00                            adc     a,0                     ;
258+  5F85 EB                               ex      de,hl                   ; now result is in ADE
259+  5F86 C9                               ret
260+  5F87              ; hl = de * hl where de & hl are small enough to always ne 16 bit result, replaces mulDEbyHL
261+  5F87 C5           HLequDEmulHL:       push    bc
262+  5F88 7A                               ld      a,d                     ; a = x1
263+  5F89 54                               ld      d,h                     ; d = y1
264+  5F8A 67                               ld      h,a                     ; h = x1
265+  5F8B 4B                               ld      c,e                     ; c = x0
266+  5F8C 45                               ld      b,l                     ; b = y0
267+  5F8D ED 30                            mul     de                      ; y1 * y0
268+  5F8F EB                               ex      de,hl
269+  5F90 ED 30                            mul     de                      ; x1 * y0
270+  5F92 19                               add     hl,de                   ; add cross products
271+  5F93 59                               ld      e,c
272+  5F94 50                               ld      d,b
273+  5F95 ED 30                            mul     de                      ; y0 * x0
274+  5F97 7D                               ld      a,l                     ; cross products lsb
275+  5F98 82                               add     a,d                     ; add to msb final
276+  5F99 67                               ld      h,a
277+  5F9A 6B                               ld      l,e                     ; hl = final
278+  5F9B                                  ; 83 cycles, 19 bytes
279+  5F9B AF                               xor     a                       ; reset carry
280+  5F9C C1                               pop     bc
281+  5F9D C9                               ret
282+  5F9E              HLequHLmulDEu:
283+  5F9E              ;H.L = H.L * D.E unsigned S7.8 format, just skips signed bit check
284+  5F9E CD B8 5F                         call    fixedS78_mulu
285+  5FA1 6C                               ld      l,h
286+  5FA2 67                               ld      h,a
287+  5FA3 C9                               ret
288+  5FA4              fixedS78_muls:
289+  5FA4              ;H.L = D.E * H.L as S7.8 Fixed Point maths, when doing 24 bit maths scale down to 8.8 as its accurate enough
290+  5FA4              HL_Mul_DE_88:
291+  5FA4 7A           .checkSigns:        ld      a,d
292+  5FA5 AC                               xor     h
293+  5FA6 E6 80                            and     $80
294+  5FA8 FD 6F                            ld      iyl,a               ; sign bit is the result sign bit held in iy as we want to optimise
295+  5FAA CB BA        .forcePositiveOnly: res     7,d                 ; de = abs de
296+  5FAC CB BC                            res     7,h                 ; hl = abs hl
297+  5FAE CD B8 5F                         call    fixedS78_mulu       ; DEHL = DE * HL,
298+  5FB1 6C           .getS88Result:      ld      l,h                 ; we want to lose D and L as part of return so put EH into HL
299+  5FB2 63                               ld      h,e                 ; .
300+  5FB3 7C                               ld      a,h                 ; now return result with sign bit, if the result over flowed into S88 then it will be out
301+  5FB4 FD B5                            or      iyl                 ;
302+  5FB6 67                               ld      h,a                 ;
303+  5FB7 C9                               ret                         ;
304+  5FB8              ;DE.HL = D.E * H.L as  7.8 Fixed Point unsigned maths, when doing 24 bit maths scale down to 8.8 as its accurate enough
305+  5FB8              fixedS78_mulu:      ;
306+  5FB8 7A           .checkZeroMul:      ld      a,d
307+  5FB9 B3                               or      e
308+  5FBA CA E2 5F                         jp      z,.resultIsZero
309+  5FBD 7C                               ld      a,h
310+  5FBE B5                               or      l
311+  5FBF CA E2 5F                         jp      z, .resultIsZero
312+  5FC2 45           .performMultiplyU:  ld      b,l                 ; b = x0
313+  5FC3 4B                               ld      c,e                 ; c =  y0
314+  5FC4 5D                               ld      e,l                 ; e = x0
315+  5FC5 6A                               ld      l,d                 ; l = y1 d is already y1
316+  5FC6 E5                               push    hl                  ; save x1 y1 to stack
317+  5FC7 69                               ld      l,c                 ; l = y0
318+  5FC8 ED 30                            mul     de                  ; hl  = y1 * x0
319+  5FCA EB                               ex      de,hl               ; . also setting de to x1 y0 as we prepped them in advance
320+  5FCB ED 30                            mul     de                  ; x1*y0
321+  5FCD                                  ZeroA
321+  5FCD AF          >                        xor a
322+  5FCE 19                               add     hl,de               ; sum cross products of y1*x0, x1 * y0 as they require no shifting
323+  5FCF 8F                               adc     a,a                 ; and capture carry bit ready for p3
324+  5FD0 59                               ld      e,c                 ; de = x0 * y0
325+  5FD1 50                               ld      d,b                 ; .
326+  5FD2 ED 30                            mul     de                  ; .
327+  5FD4 47                               ld      b,a                 ; carry from cross products setting bc to <c>h  (where <c> is carry flag)
328+  5FD5 4C                               ld      c,h                 ; .
329+  5FD6 7A                               ld      a,d                 ; h = high byte of x0 * y 0 _ lower byte of cross product of y1 * x0
330+  5FD7 85                               add     a,l                 ; .
331+  5FD8 67                               ld      h,a                 ; .)
332+  5FD9 6B                               ld      l,e                 ; so now we have lower btwo bytes of result in HL (p1 p0)
333+  5FDA D1                               pop de                      ; get x1 and y1 back from stack into de ready for multiply
334+  5FDB ED 30                            mul de                      ; hl = x1*y1 and de = p1 p0
335+  5FDD EB                               ex de,hl                    ; .
336+  5FDE ED 4A                            adc hl,bc                   ; hl = (x1 * y1) + <c>h (where h is upper byte of cross product from above)
337+  5FE0 EB                               ex de,hl                    ; swap over de and hl for final result
338+  5FE1 C9                               ret
339+  5FE2 11 00 00     .resultIsZero:      ld      de,0
340+  5FE5 21 00 00                         ld      hl,0
341+  5FE8 C9                               ret
342+  5FE9
# file closed: asm_multiply_S78.asm
202   5FE9                  INCLUDE	"../../MathsFPS78/asm_divide_S78.asm"
# file opened: asm_divide_S78.asm
  1+  5FE9              ; asm_divide_S78
  2+  5FE9              ; Division routines for Lead sign 7.8 format, adapted based on Q88 format but only respresents negatives by sign bit
  3+  5FE9
  4+  5FE9                  DISPLAY "TODO: Still need an S15.8 / S0.8 which in effect increases the value"
  5+  5FE9              FP88DIVITER:        MACRO
  6+  5FE9 ~                                rla
  7+  5FE9 ~                                adc hl,hl
  8+  5FE9 ~                                add hl,de
  9+  5FE9 ~                                jr c,.NoSubtract
 10+  5FE9 ~                                sbc hl,de
 11+  5FE9 ~            .NoSubtract:
 12+  5FE9                                  ENDM
 13+  5FE9              ;HL = DE/BC as S7.8 Fixed Point maths, when doing 24 bit maths scale down to 8.8 as its accurate enough
 14+  5FE9              ;AHL = BHL/CDE, performed by scaling down BHL and CDE into two S8.8 values then calling fixedS7_8
 15+  5FE9              ; its an approximate as by the time we need a 24 bit divide it will be for objects a long way away
 16+  5FE9 78           fixedS23_8_divs:    ld      a,b               ; prep by saving off sign bit before shifting
 17+  5FEA A9                               xor     c
 18+  5FEB E6 80                            and     $80
 19+  5FED FD 6F                            ld      iyl,a
 20+  5FEF CB B8                            res     7,b                ; clear sign bits of and a
 21+  5FF1 CB B9                            res     7,c                ;
 22+  5FF3 78           .shiftRight24Loop:  ld      a,b                ; scaled down BHL and CDE to just HL and DE
 23+  5FF4 B1                               or      c                  ;
 24+  5FF5 CA 07 60                         jp      z,.ShiftRight16    ; if b and c are clear then we can just do 16 bit shift
 25+  5FF8                                  ShiftBHLRight1             ;
 25+  5FF8 CB 38       >               srl b
 25+  5FFA CB 1C       >               rr h
 25+  5FFC CB 1D       >               rr  l
 26+  5FFE                                  ShiftCDERight1             ;
 26+  5FFE CB 39       >               srl c
 26+  6000 CB 1A       >               rr  d
 26+  6002 CB 1B       >               rr  e
 27+  6004 C3 F3 5F                         jp      .shiftRight24Loop  ;
 28+  6007              .ShiftRight16:
 29+  6007 7C           .ShiftRight16Loop:  ld      a,h                ; scale now just HL and DE
 30+  6008 B2                               or      d                  ; .
 31+  6009 E6 80                            and     $80                ; .
 32+  600B CA 19 60                         jp      z,.ShiftComplete   ; .
 33+  600E                                  ShiftHLRight1              ; .
 33+  600E CB 3C       >               srl h
 33+  6010 CB 1D       >               rr  l
 34+  6012                                  ShiftDERight1              ; .
 34+  6012 CB 3A       >               srl d
 34+  6014 CB 1B       >               rr  e
 35+  6016 C3 07 60                         jp      .ShiftRight16Loop  ; .
 36+  6019 CB C1        .ShiftComplete:     set     0,c                ; fast way to ensure BC is at least not zero, in this case 0.0039 which means we can never have divide by 0
 37+  601B 7C           .checkZeroDivide:   ld      a,h                ; use the result is zero from below to save some code space
 38+  601C B7                               or      a                  ; .
 39+  601D CA 76 60                         jp      z,BC_Div_DE_88.resultIsZero ; as this already zeros A we can use it
 40+  6020 CD 3F 60                         call    BC_Div_DE_88.NegateDE ; now we can just fall into a fixed S7.8 but after all the inital checks have been done
 41+  6023 7C                               ld      a,h                ; now shift result from HL to AHL
 42+  6024 E6 80                            and     $80                ; so A only holds sign bit
 43+  6026 65                               ld      h,l                ;
 44+  6027 CB BC                            res     7,h                ; h will be the abs version
 45+  6029 2E 00                            ld      l,0                ; and decimal will always be 0
 46+  602B C9                               ret                        ;
 47+  602C
 48+  602C
 49+  602C              ;HL = DE/BC as S7.8 Fixed Point maths, when doing 24 bit maths scale down to 8.8 as its accurate enough
 50+  602C 44 4D        fixedS7_8_divs:     ld      bc,hl
 51+  602E              BC_Div_DE_88:
 52+  602E 78           .checkSigns:        ld      a,b
 53+  602F AA                               xor     d
 54+  6030 E6 80                            and     $80
 55+  6032 FD 6F                            ld      iyl,a               ; sign bit is the result sign bit held in iy as we want to optimise
 56+  6034 CB B8        .forcePositiveOnly: res     7,b                ; bc = abs b
 57+  6036 B1           .checkZeroDivide:   or      c                   ; optimisation, if bc was zero then result will be zero
 58+  6037 28 3D                            jr      z,.resultIsZero     ; .
 59+  6039 CB BA        .forceNegativeDW:   res     7,d                 ; first force it positive
 60+  603B 7A           .checkDivideZero:   ld      a,d
 61+  603C B3                               or      e                   ; as we are going to wipe a, do the divide by zero check here as an optimisation
 62+  603D 28 2E                            jr      z,.divideOverflow    ; .
 63+  603F              .NegateDE:          ZeroA                       ; now negate DE
 63+  603F AF          >                        xor a
 64+  6040 93                               sub     e                   ; .
 65+  6041 5F                               ld 		e,a                 ; .
 66+  6042 9F                               sbc 	a,a                 ; .
 67+  6043 92                               sub 	d                   ; .
 68+  6044 57                               ld 		d,a                 ; .
 69+  6045 26 00        .overflowCheck:     ld      h,0                 ; prepare h = 0 for a slight optimise
 70+  6047 78                               ld      a,b                 ; if B+DE>=0, then we'll have overflow
 71+  6048 83                               add     e                   ; .
 72+  6049 7A                               ld      a,d                 ; .
 73+  604A CE 00                            adc     a,0                 ; .
 74+  604C 78                               ld a,b
 75+  604D 83                               add a,e
 76+  604E 7A                               ld a,d
 77+  604F 8C                               adc a,h
 78+  6050 38 1B                            jr c,.divideOverflow
 79+  6052 68           .prepRemainder:     ld      l,b                 ; h is already 0 from overflow Check so now hl = 0b
 80+  6053 79                               ld      a,c                 ; and a = c
 81+  6054 CD 7A 60                         call    div_S88_sub
 82+  6057 4F                               ld      c,a
 83+  6058 78                               ld      a,b      ;A is now 0
 84+  6059 CD 7A 60                         call    div_S88_sub
 85+  605C 29           .CheckRounding:     add     hl,hl; if 2HL+DE>=0, increment result to round.
 86+  605D 19                               add     hl,de
 87+  605E 61                               ld      h,c
 88+  605F 6F                               ld      l,a
 89+  6060 30 01                            jr      nc,.NoIncrementNeeded
 90+  6062 23                               inc     hl
 91+  6063 CB 7C        .NoIncrementNeeded: bit 7,h                     ; Now check if H is overflowed
 92+  6065 20 06                            jr nz,.divideOverflow
 93+  6067 FD 7D                            ld      a,iyl               ; get back sign bit
 94+  6069 B4                               or      h
 95+  606A 67                               ld      h,a                 ; now set h to correct sign
 96+  606B                                  ClearCarryFlag              ; and we have a success
 96+  606B B7          >                        or a
 97+  606C C9                               ret
 98+  606D 2E FF        .divideOverflow:    ld      l,$FF               ; hl = +/-128.255 signed
 99+  606F FD 7D                            ld      a,iyl               ; .
100+  6071 F6 7F                            or      $7F                 ; .
101+  6073 67                               ld      h,a
102+  6074                                  SetCarryFlag
102+  6074 37          >                        scf
103+  6075 C9                               ret
104+  6076              .resultIsZero       ZeroA                       ; doign it this way saves a couple of clock cycles as we get the carry clear for free even if setting hl takes an extra 2 cycles
104+  6076 AF          >                        xor a
105+  6077 67                               ld      h,a
106+  6078 6F                               ld      l,a
107+  6079 C9                               ret
108+  607A              div_S88_sub:        FP88DIVITER
108+  607A 17          >                    rla
108+  607B ED 6A       >                    adc hl,hl
108+  607D 19          >                    add hl,de
108+  607E 38 02       >                    jr c,.NoSubtract
108+  6080 ED 52       >                    sbc hl,de
108+  6082             >.NoSubtract:
109+  6082                                  FP88DIVITER
109+  6082 17          >                    rla
109+  6083 ED 6A       >                    adc hl,hl
109+  6085 19          >                    add hl,de
109+  6086 38 02       >                    jr c,.NoSubtract
109+  6088 ED 52       >                    sbc hl,de
109+  608A             >.NoSubtract:
110+  608A                                  FP88DIVITER
110+  608A 17          >                    rla
110+  608B ED 6A       >                    adc hl,hl
110+  608D 19          >                    add hl,de
110+  608E 38 02       >                    jr c,.NoSubtract
110+  6090 ED 52       >                    sbc hl,de
110+  6092             >.NoSubtract:
111+  6092                                  FP88DIVITER
111+  6092 17          >                    rla
111+  6093 ED 6A       >                    adc hl,hl
111+  6095 19          >                    add hl,de
111+  6096 38 02       >                    jr c,.NoSubtract
111+  6098 ED 52       >                    sbc hl,de
111+  609A             >.NoSubtract:
112+  609A                                  FP88DIVITER
112+  609A 17          >                    rla
112+  609B ED 6A       >                    adc hl,hl
112+  609D 19          >                    add hl,de
112+  609E 38 02       >                    jr c,.NoSubtract
112+  60A0 ED 52       >                    sbc hl,de
112+  60A2             >.NoSubtract:
113+  60A2                                  FP88DIVITER
113+  60A2 17          >                    rla
113+  60A3 ED 6A       >                    adc hl,hl
113+  60A5 19          >                    add hl,de
113+  60A6 38 02       >                    jr c,.NoSubtract
113+  60A8 ED 52       >                    sbc hl,de
113+  60AA             >.NoSubtract:
114+  60AA                                  FP88DIVITER
114+  60AA 17          >                    rla
114+  60AB ED 6A       >                    adc hl,hl
114+  60AD 19          >                    add hl,de
114+  60AE 38 02       >                    jr c,.NoSubtract
114+  60B0 ED 52       >                    sbc hl,de
114+  60B2             >.NoSubtract:
115+  60B2                                  FP88DIVITER
115+  60B2 17          >                    rla
115+  60B3 ED 6A       >                    adc hl,hl
115+  60B5 19          >                    add hl,de
115+  60B6 38 02       >                    jr c,.NoSubtract
115+  60B8 ED 52       >                    sbc hl,de
115+  60BA             >.NoSubtract:
116+  60BA 8F                               adc a,a
117+  60BB C9                               ret
118+  60BC
119+  60BC
# file closed: asm_divide_S78.asm
203   60BC                  INCLUDE	"../../Maths24/asm_addition24.asm"
# file opened: asm_addition24.asm
  1+  60BC              ; Addition---------------------------------------------------
  2+  60BC              ; BAHL = BHL+CDE Lead Sign bit - If overflows AHL then carry will be set resulting in B holding sign and rest of value, else AHL holds value
  3+  60BC              ; in reality will we aim for all values being S14.8 so bit 15 is always clear for overflow
  4+  60BC 78           AHLequBHLplusCDE:       ld      a,b                          ; if b sign and c sign were different then bit 7 of a will be 1 which means
  5+  60BD E6 80                                and     $80                          ; Signs are opposite there fore we can subtract to get difference
  6+  60BF A9                                   xor     c                            ;
  7+  60C0                                      JumpIfNegative .OppositeSigns        ;
  7+  60C0 FA E1 60    >                        jp		m, .OppositeSigns
  8+  60C3 78           .SameSigns:             ld      a,b                          ; if they are both negative
  9+  60C4 B1                                   or      c                            ; then we can do an add but also set the sign bit
 10+  60C5                                      JumpIfNegative .BothNegative         ; optimisation so we can just do simple add if both positive
 10+  60C5 FA D0 60    >                        jp		m, .BothNegative
 11+  60C8 ED 5A        .BothPositive:          adc     hl,de                        ; both positive so a will already be zero
 12+  60CA 78                                   ld      a,b                          ; a = b + c + an carry from HL + DE
 13+  60CB 89                                   adc     c                            ;
 14+  60CC D0                                   ret     nc                           ; fi there was no carry then we are good
 15+  60CD 06 01        .OverFlowPositive:      ld      b,1                          ; if we overflow from +BHL +  +CDE then we already have sign cleared in A and only 1 bit to roll into B + no sign bit
 16+  60CF C9                                   ret
 17+  60D0 CB B8        .BothNegative:          res     7,b                          ; clear sign bits for both values
 18+  60D2 CB B9                                res     7,c                          ; .
 19+  60D4 ED 5A                                adc     hl,de                        ; now behave like they are both positive
 20+  60D6 78                                   ld      a,b
 21+  60D7 89                                   adc     c
 22+  60D8 DA DE 60                             jp      c,.OverFlowNegative          ; if there was carry we need to overflow into b
 23+  60DB F6 80                                or      %10000000                    ; set bit 7 of A for negative
 24+  60DD C9                                   ret
 25+  60DE 06 81        .OverFlowNegative:      ld      b,%10000001                  ; carry over the bit but also set the sign bit
 26+  60E0 C9                                   ret
 27+  60E1 CB 78        .OppositeSigns:         bit     7,b                         ; if BHL was negative then
 28+  60E3 C2 EC 60                             jp      nz,.CDEMinusBHL             ; its CDE - BHL
 29+  60E6 CB B9        .BHLMinusCDE:           res     7,c
 30+  60E8 EB                                   ex      hl,de                       ; it must be BHL - CDE  so we swap registers and just treat it as CDE-BHL
 31+  60E9 78                                   ld      a,b                         ; and we have to use a when swapping b and c
 32+  60EA 41                                   ld      b,c                         ; .
 33+  60EB 4F                                   ld      c,a                         ; .
 34+  60EC CB B8        .CDEMinusBHL:           res     7,b
 35+  60EE                                      ClearCarryFlag                      ; now its just common CDE-BHL
 35+  60EE B7          >                        or a
 36+  60EF 79                                   ld      a,c                         ; a= c - b
 37+  60F0 98                                   sbc     b
 38+  60F1 EB                                   ex      hl,de                       ; hl = DE-hl by swapping them round
 39+  60F2 ED 52                                sbc     hl,de                       ; now AHL is result
 40+  60F4 D0                                   ret     nc                          ; if there was no carry then we are good
 41+  60F5              .CDEFlipSign:           NegAHL                              ; as CDE-BHL became negative we make result lead sign negativce
 41+  60F5 47          >                    ld      b,a         ; save a in b
 41+  60F6 AF          >                    xor     a           ; l = 0 - l
 41+  60F7 95          >                    sub     l
 41+  60F8 6F          >                    ld      l,a
 41+  60F9 9F          >                    sbc     a,a         ; h = 0 - h
 41+  60FA 94          >                    sub     h
 41+  60FB 67          >                    ld      h,a
 41+  60FC 9F          >                    sbc     a,a         ; a= 0 - b
 41+  60FD 90          >                    sub     b
 42+  60FE F6 80                                or      %10000000                   ; flip the lead bit of A
 43+  6100 C9                                   ret
 44+  6101              SwapViaA:               MACRO   r1, r2
 45+  6101 ~                                    ld      a,r1
 46+  6101 ~                                    ld      r1,r2
 47+  6101 ~                                    ld      r2,a
 48+  6101                                      ENDM
 49+  6101              AHLequHLAddCarryAViaDE: MACRO
 50+  6101 ~                                    ld      d,0                         ; de = P1 carry
 51+  6101 ~                                    ld      e,a                         ; .
 52+  6101 ~                                    xor     a                           ; Clear carry and prep a for P2 carry
 53+  6101 ~                                    add     hl,de                       ; .
 54+  6101 ~                                    adc     a,a                         ; .
 55+  6101                                      ENDM
 56+  6101              ; variants on AHLequBHLplusCDE
 57+  6101              ; AHL = BHL+DEC Lead Sign bit
 58+  6101 7A           AHLequBHLplusDEC:       ld      a,d                         ; d = e (saving d)
 59+  6102 53                                   ld      d,e                         ; .
 60+  6103 59                                   ld      e,c                         ; e = c
 61+  6104 4F                                   ld      c,a                         ; c = d (orginal value)
 62+  6105 C3 BC 60                             jp      AHLequBHLplusCDE
 63+  6108
 64+  6108              ; AHL = BHL-CDE Lead Sign bit
 65+  6108 79           AHLequBHLminusCDE:      ld      a,c
 66+  6109 EE 80                                xor     %10000000
 67+  610B 4F                                   ld      c,a
 68+  610C C3 BC 60                             jp      AHLequBHLplusCDE
 69+  610F
 70+  610F              ; variant on above for simplifying post multiply           ; d = e (saving d)
 71+  610F 7A           AHLequBHLminusDEC:      ld      a,d                        ; .
 72+  6110 F6 80                                or      %10000000                  ; but we also flip the sign on the saved D
 73+  6112 53                                   ld      d,e                        ; .
 74+  6113 59                                   ld      e,c                        ; e = c
 75+  6114 4F                                   ld      c,a                        ; c = d (orginal value)
 76+  6115 C3 BC 60                             jp      AHLequBHLplusCDE
 77+  6118
 78+  6118              ; If it will fit
 79+  6118              ;  HLBC = BHL * CDE  Lead Sign bit, carry Clear
 80+  6118              ; else
 81+  6118              ;  AHLBC = BHL * CDE Lead sign bit , carry set
 82+  6118              ; performs p0 = x0*y0                               L*E
 83+  6118              ;          p1 = x1*y0 + x0*y1 + p0 carry            H*E + D*L
 84+  6118              ;          p2 = x2*y0 + x0*y2 + x1*y1 + p1 carry    B*E + L*C + H*D
 85+  6118              ;          p3 = x2*y1 + x1 * y2 + p2 carry          B*D + H*C
 86+  6118              ;          p4 = x2* y2                              B*C
 87+  6118              ; reverse order for stack retrival                                                                                              B H L  C D E
 88+  6118              ; performs p4 = x2* y2                              B*C                B*C                     leave as is           BHL*CDE   020305 01040A 0201            02                  P4 = 2
 89+  6118              ;          p3 = x2*y1 + x1 * y2 + p2 carry          B*D + H*C          Swap B<>E and C<>L      E*D + H * L           EHC*LDB    E H C  L D B 0204 0301       08+03 = 0B          P3 = B
 90+  6118              ;          p2 = x2*y0 + x0*y2 + x1*y1 + p1 carry    E*B + C*L + H*D    Swap B<>D and C<>H      E*D + H * L + C * B   ECH*LBD    E C H  L B D 020A 0501 0304  14+05+0C=25         P2 = 25
 91+  6118              ;          p1 = x1*y0 + x0*y1                       C*D + H*B          Swap C<>E and L<>B      E*D + H * L           CEH*BLD    C E H  B L D 030A 0504       1E+14 = 32          P1 = 32 carry = 0
 92+  6118              ;          p0 = x0*y0                               C*B                Swap E,H, ex hl,de in calc                    CHE*BDL                 050A            32                  P0 = 32 Carry = 0
 93+  6118 78           HLBCequBHLmulCDE:       ld      a,b                         ; multiply is simpler as same signs is always positive
 94+  6119 A9                                   xor     c                           ; opposite is always negative
 95+  611A E6 80                                and     $80                         ; .
 96+  611C F5           .SaveSign:              push    af                          ; save a to the stack that will now hold 0 or $80,
 97+  611D CB B8        .ClearSignBits:         res     7,b
 98+  611F CB B9                                res     7,c
 99+  6121 C5           .PrepP4:                push    bc                          ; save registers for p4 = x2*y2 p3 carry > BC = x0 y0
100+  6122              .PrepP3:                SwapViaA b,e                        ; save registers for p3  = x2*y1 + x1*y2 + p2 carry
100+  6122 78          >                        ld      a,b
100+  6123 43          >                        ld      b,e
100+  6124 5F          >                        ld      e,a
101+  6125                                      SwapViaA c,l
101+  6125 79          >                        ld      a,c
101+  6126 4D          >                        ld      c,l
101+  6127 6F          >                        ld      l,a
102+  6128 D5 E5                                push    de,,hl                      ; DE = X2 Y1 HL = X1 Y2
103+  612A              .PrepP2:                SwapViaA d,b                         ; save registers for p2  = x2*y0 + x0*y2 + x1*y1 + p1 carry
103+  612A 7A          >                        ld      a,d
103+  612B 50          >                        ld      d,b
103+  612C 47          >                        ld      b,a
104+  612D                                      SwapViaA c,h
104+  612D 79          >                        ld      a,c
104+  612E 4C          >                        ld      c,h
104+  612F 67          >                        ld      h,a
105+  6130 D5 E5 C5                             push    de,,hl,,bc                  ; save registers for p1 = x1*y0 + x0*y1 + p0 carry
106+  6133              .PrepP1:                SwapViaA c,e
106+  6133 79          >                        ld      a,c
106+  6134 4B          >                        ld      c,e
106+  6135 5F          >                        ld      e,a
107+  6136                                      SwapViaA l,b
107+  6136 7D          >                        ld      a,l
107+  6137 68          >                        ld      l,b
107+  6138 47          >                        ld      b,a
108+  6139 D5 E5                                push    de,,hl
109+  613B              .PrepP0:                SwapViaA e,h                        ; we don't care about original values now as they are on the stack
109+  613B 7B          >                        ld      a,e
109+  613C 5C          >                        ld      e,h
109+  613D 67          >                        ld      h,a
110+  613E ED 30        .CalcP0:                mul     de                          ; de = x0 * y0 no need for carry logic as even FF*FF = FE01
111+  6140 42 4B                                ld      bc,de                       ; so b = P0 carry,c = P0
112+  6142 D1           .CalcP1:                pop     de                          ; get P1 components off stack
113+  6143 ED 30                                mul     de                          ; hl = x1*y0
114+  6145 EB                                   ex      de,hl                       ; so de = P1c P1 b =P0c P0
115+  6146 AF           .AddP0Carry:            xor     a                           ; hl = x1*y0 + P0 carry
116+  6147 16 00                                ld      d,0                         ; .
117+  6149 58                                   ld      e,b                         ; .
118+  614A 19                                   add     hl,de                       ; .
119+  614B 8F                                   adc     a,a                         ; a = carry
120+  614C D1                                   pop     de
121+  614D ED 30                                mul     de                          ; de = x0*y1
122+  614F A7                                   and     a                           ; clear carry flag whilst retaining a
123+  6150 19                                   add     hl,de                       ; hl = x1*y0 + x0*y1
124+  6151 CE 00        .CalcP1Carry:           adc     a,0                         ;
125+  6153 84                                   add     h                           ; a = P1 carry
126+  6154 45                                   ld      b,l                         ; A = P1 carry bc = P1 P0
127+  6155 D1           .CalcP2:                pop     de                          ; we pull in bc later directly into de
128+  6156 ED 30                                mul     de                          ; hl = x2*y0
129+  6158 EB                                   ex      hl,de                       ; .
130+  6159              .AddP1Carry:            AHLequHLAddCarryAViaDE
130+  6159 16 00       >                        ld      d,0                         ; de = P1 carry
130+  615B 5F          >                        ld      e,a                         ; .
130+  615C AF          >                        xor     a                           ; Clear carry and prep a for P2 carry
130+  615D 19          >                        add     hl,de                       ; .
130+  615E 8F          >                        adc     a,a                         ; .
131+  615F D1           .CalcP2Pt2:             pop     de                          ; de = x0*y2
132+  6160 ED 30                                mul     de                          ; .
133+  6162 A7                                   and     a                           ; Clear carry preserve a
134+  6163 19                                   add     hl,de                       ; hl = x2*y0 + x0*y2
135+  6164 8F                                   adc     a,a                         ; a = new carry
136+  6165 D1           .CalcP2Pt3:             pop     de                          ; de = x1*y1
137+  6166 ED 30                                mul     de                          ; .
138+  6168 A7                                   and     a                           ; hl = x2*y0 + x0*y2 + x1*y1, preserve carry flag
139+  6169 19                                   add     hl,de                       ; so we have hl = P2c P2 BC = P1P1
140+  616A CE 00        .CalcP2Carry:           adc     a,0                         ; A = calc carry + P2 carry in h
141+  616C 84                                   add     a,h                         ; l = P2 bc = P1 P0
142+  616D 5D                                   ld      e,l                         ; ixl = l (via e as you can't do hl to ix direct)
143+  616E DD 6B        .SaveP2:                ld      ixl,e                       ; a = P2 carry ixl:bc = P2 P1 P0
144+  6170 D1           .CalcP3                 pop     de                          ; hl = x2*y1
145+  6171 ED 30                                mul     de                          ; .
146+  6173 EB                                   ex      de,hl                       ; .
147+  6174              .AddP2Carry:            AHLequHLAddCarryAViaDE
147+  6174 16 00       >                        ld      d,0                         ; de = P1 carry
147+  6176 5F          >                        ld      e,a                         ; .
147+  6177 AF          >                        xor     a                           ; Clear carry and prep a for P2 carry
147+  6178 19          >                        add     hl,de                       ; .
147+  6179 8F          >                        adc     a,a                         ; .
148+  617A D1           .CalcP3Pt2:             pop     de                          ; de =  x1*y2
149+  617B ED 30                                mul     de                          ; .
150+  617D A7                                   and     a                           ; Clear carry preserve a
151+  617E 19                                   add     hl,de                       ; hl = x2*y1 + x1*y2
152+  617F CE 00                                adc     a,0                         ; a = new carry for P3, l = p3
153+  6181 84                                   add     a,h                         ; .
154+  6182 5D           .SaveP3:                ld      e,l                         ; load ixh via e
155+  6183 DD 63                                ld      ixh,e                       ; so we now have a = P3 carry ix P3P2 bc = P1P0
156+  6185 D1           .CalcP4:                pop     de                          ; de = x2* y2 + P3 carry
157+  6186 ED 30                                mul     de                          ; .
158+  6188 EB                                   ex      de,hl                       ;
159+  6189              .AddP3Carry:            AHLequHLAddCarryAViaDE              ; hl ix bc = P5P4 P3P2 P1P0
159+  6189 16 00       >                        ld      d,0                         ; de = P1 carry
159+  618B 5F          >                        ld      e,a                         ; .
159+  618C AF          >                        xor     a                           ; Clear carry and prep a for P2 carry
159+  618D 19          >                        add     hl,de                       ; .
159+  618E 8F          >                        adc     a,a                         ; .
160+  618F 7D           .RecoverSignBit:        ld      a,l                         ; Is P4 populated,
161+  6190 A7                                   and     a
162+  6191 CA 9A 61                             jp      z,.P3toP0                   ; if not then we have result P3P2P1P0
163+  6194 F1           .P4toP0:                pop     af                          ; else return with AHLBC
164+  6195 B5                                   or      l
165+  6196 DD E5 E1                             ld      hl,ix
166+  6199 C9                                   ret
167+  619A F1           .P3toP0:                pop     af
168+  619B DD E5 E1                             ld      hl,ix                       ; move P2P2 into hl
169+  619E B4                                   or      h
170+  619F 67                                   ld      h,a
171+  61A0 AF                                   xor     a                           ; return result in hlbc with CarryClear
172+  61A1 C9                                   ret
173+  61A2
174+  61A2 F1           ResultIsZero:           pop     af                          ; get rid of unwanted sign bits
175+  61A3 4B                                   ld      c,e                         ; CDE = EHL as remainder
176+  61A4 EB                                   ex      hl,de
177+  61A5 AF                                   xor     a                           ; result AHL = $0
178+  61A6 67                                   ld      h,a
179+  61A7 6F                                   ld      l,a                         ; .
180+  61A8 C9                                   ret
181+  61A9
182+  61A9 F1           DivideByZero:           pop     af                          ; get rid of unwanted sign bits
183+  61AA 4B                                   ld      c,e                         ; CDE = EHL as remainder
184+  61AB EB                                   ex      hl,de
185+  61AC 3E FF                                ld      a,$FF                       ; result AHL = $FFFFFF
186+  61AE 21 FF FF                             ld      hl,$FFFF                    ; .
187+  61B1                                      SetCarryFlag                        ; and carry set
187+  61B1 37          >                        scf
188+  61B2 C9                                   ret
189+  61B3
190+  61B3
191+  61B3              ; AHL = EHL / DBC  Lead Sign bit; CDE = remainder carry clear, divide by 0 gives AHL $FFFFFF, carry set
192+  61B3 7B           AHLequEHLdivDBC:        ld      a,e                         ; divide is simpler as same signs is always positive
193+  61B4 AA                                   xor     d                           ; opposite is always negative
194+  61B5 E6 80                                and     $80                         ; .
195+  61B7 F5           .SaveSign:              push    af                          ; save a to the stack that will now hold 0 or $80,
196+  61B8 CB BB        .ClearSignBits:         res     7,e
197+  61BA CB BA                                res     7,d
198+  61BC 7A           .CheckDivideByZero:     ld      a,d
199+  61BD B0                                   or      b
200+  61BE B1                                   or      c
201+  61BF 28 E8                                jr      z,DivideByZero
202+  61C1                                      ;DEBUG jp      Perform_24x24   ; forece 24 bit
203+  61C1              ; Now determine the scale down, e.g. can we do smaller divides than just 24x24
204+  61C1              ; Patterns              24x24 OK                         1C
205+  61C1              ;                       24x16 OK                         1E
206+  61C1              ;                       24x8  OK                         1F
207+  61C1              ;                       16x24 0                          1I
208+  61C1              ;                       16x16 OK                         1J
209+  61C1              ;                       16x8  OK                         1L
210+  61C1              ;                       8x24  0                          1N
211+  61C1              ;                       8x16  0                          1N
212+  61C1              ;                       8x8   OK                         1O
213+  61C1              ; flow is               check if its 24 / ?              1A
214+  61C1              ;                       Y > test 24/24                   1B
215+  61C1              ;                           Y > Perform 24x24            1C
216+  61C1              ;                           N > Check   24x16            1D
217+  61C1              ;                               Y > Perform 24x16        1E
218+  61C1              ;                               N > Perform 24x8         1F
219+  61C1              ;                       N > test 16/ ?                   1G
220+  61C1              ;                           Y > Check 16/24              1H
221+  61C1              ;                               Y > Result 0             1I
222+  61C1              ;                               N > Check 16/16          1J
223+  61C1              ;                                   Y > Perform 16/16    1K
224+  61C1              ;                                   N > Perform 16/8     1L
225+  61C1              ;                           N > Check 08/24 or 08/16     1M
226+  61C1              ;                               Y > Result is 0          1N
227+  61C1              ;                               N > Perform 8/8          1O
228+  61C1 1C           .ValidDivide:           inc     e
229+  61C2 1D                                   dec     e
230+  61C3 20 1E                                jr      nz,Try_24xAnything         ; its at least ehl / something
231+  61C5 24           .Test_16x:              inc     h
232+  61C6 25                                   dec     h
233+  61C7 20 0D                                jr      nz, .Try_16xAnything        ; its at least hl / something
234+  61C9 14           .Try_8xAnything:        inc     d
235+  61CA 15                                   dec     d
236+  61CB C2 A2 61                             jp      nz, ResultIsZero            ; its l / dbc which is always zero
237+  61CE 05                                   dec     b
238+  61CF 04                                   inc     b
239+  61D0 C2 A2 61                             jp      nz, ResultIsZero            ; its l / bc which is always zero
240+  61D3 C3 2D 65                             jp      Perform_8x8
240+  61D6                               ; its l/b
241+  61D6 14           .Try_16xAnything:       inc     d
242+  61D7 15                                   dec     d
243+  61D8 C2 A2 61                             jp      nz, ResultIsZero            ; its hl / dbc which is always zero
244+  61DB 05                                   dec     b
245+  61DC 04                                   inc     b
246+  61DD C2 6D 64                             jp      nz, Perform_16x16           ; its hl/bc
247+  61E0 C3 BC 64                             jp      Perform_16x8                ; so it must be hl/c
248+  61E3              ;--------------------------------------------------------------------------------------------------
249+  61E3              ; Div 24x24 iteration
250+  61E3
251+  61E3              ;--------------------------------------------------------------------------------------------------
252+  61E3              ; AHL = EHL/DBC, EHL > DBC both >= 01 00 00
253+  61E3                  DISPLAY "24x24 Actual internal result currently is 0L.D so need to rationalise it to AHL"
254+  61E3                  DISPLAY "Working on one 24x24 only"
255+  61E3                  DISPLAY "In effect 24x24 where E and D are both > 0 means e/d"
256+  61E3              Try_24xAnything:        ;inc     d
257+  61E3                                      ;dec     d
258+  61E3                                      ;jp      nz,Perform_24x24           ; if d was not zero then its ehl/dbc
259+  61E3                                      ;ld      a,b
260+  61E3                                      ;and     $80
261+  61E3                                      ;dec     b
262+  61E3                                      ;inc     b
263+  61E3                                      ;jp      z,Perform_24x8              ; if b was zero then its ehl/00c
264+  61E3                                      ;jp      Perform_24x16               ; else it leaves us with ehl/0bc
265+  61E3              ; {er
266+  61E3 7B           Perform_24x24:          ld      a,e                         ; EHL => HLE  AHL
267+  61E4 5D                                   ld      e,l                         ;             AHE
268+  61E5 6C                                   ld      l,h                         ;             ALE
269+  61E6 67                                   ld      h,a                         ;             HLE
270+  61E7 AF                                   xor     a                           ;             A = 0 Celar carry flag
271+  61E8              .eliminateLeadingZeros:
272+  61E8 CB 13        .loop_00:               rl e                                ; HLE << 1
273+  61EA ED 6A                                adc hl,hl                           ;
274+  61EC 38 36                                jr c, .loop_10                      ; if HLE bit 7 was set prior to shift goto loop_10  HLE was %1XXXXXXX XXXXXXXX XXXXXXX
275+  61EE CB 13                                rl e                                ; (HLE << 1) + 1
276+  61F0 1C                                   inc e                               ;
277+  61F1 ED 6A                                adc hl,hl                           ;
278+  61F3 38 3B                                jr c, .loop_20                      ; if HLE bit 6 was set prior to shift goto loop_20  HLE was %01XXXXXX XXXXXXXX XXXXXXX
279+  61F5 CB 13                                rl e                                ; (HLE << 1) + 1
280+  61F7 1C                                   inc e                               ;
281+  61F8 ED 6A                                adc hl,hl                           ;
282+  61FA 38 40                                jr c, .loop_30                      ; if HLE bit 5 was set prior to shift goto loop_30  HLE was %001XXXXX XXXXXXXX XXXXXXX
283+  61FC CB 13                                rl e                                ; (HLE << 1) + 1
284+  61FE 1C                                   inc e                               ;
285+  61FF ED 6A                                adc hl,hl                           ;
286+  6201 38 45                                jr c, .loop_40                      ; if HLE bit 4 was set prior to shift goto loop_40  HLE was %0001XXXX XXXXXXXX XXXXXXX
287+  6203 CB 13                                rl e                                ; (HLE << 1) + 1
288+  6205 1C                                   inc e                               ;
289+  6206 ED 6A                                adc hl,hl                           ;
290+  6208 38 4A                                jr c, .loop_50                      ; if HLE bit 3 was set prior to shift goto loop_50  HLE was %00001XXX XXXXXXXX XXXXXXX
291+  620A CB 13                                rl e                                ; (HLE << 1) + 1
292+  620C 1C                                   inc e                               ;
293+  620D ED 6A                                adc hl,hl                           ;
294+  620F 38 4F                                jr c, .loop_60                      ; if HLE bit 2 was set prior to shift goto loop_50  HLE was %000001XX XXXXXXXX XXXXXXX
295+  6211 CB 13                                rl e                                ; (HLE << 1) + 1
296+  6213 1C                                   inc e                               ;
297+  6214 ED 6A                                adc hl,hl                           ;
298+  6216 38 54                                jr c, .loop_70                      ; if HLE bit 1 was set prior to shift goto loop_50  HLE was %0000001X XXXXXXXX XXXXXXX
299+  6218 37                                   scf                                 ; set carry and jump to loop 7 as bit 0 of HLE must have been set
300+  6219 CB 13                                rl e                                ; (HLE << 1) + 1
301+  621B 1C                                   inc e                               ;
302+  621C ED 6A                                adc hl,hl                           ;
303+  621E 38 58                                jr c, .loop_80                      ; if HLE bit 0 was set prior to shift goto loop_50  HLE was %0000001X XXXXXXXX XXXXXXX
304+  6220 37                                   scf                                 ; set carry and jump to loop 7 as bit 0 of HLE must have been set
305+  6221 C3 74 62                             jp .loop_7
306+  6224 17           .loop_10:               rla                                 ; A = A *2 + carry from  HLE * 2 (on first pass A = 0)
307+  6225 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
308+  6227 9A                                   sbc a,d                             ;
309+  6228 30 02                                jr nc, .loop_1                      ; if AHL is negative
310+  622A 09                                   add hl,bc                           ;   revert AHL back to prior value
311+  622B 8A                                   adc a,d                             ;   .
312+  622C CB 13        .loop_1:                rl e                                ; else
313+  622E ED 6A                                adc hl,hl                           ;   HLE = HLE * 2
314+  6230 17           .loop_20:               rla                                 ; A = carry from  HLE * 2
315+  6231 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
316+  6233 9A                                   sbc a,d                             ;
317+  6234 30 02                                jr nc, .loop_2                       ; if AHL is negative
318+  6236 09                                   add hl,bc                           ;   revert AHL back to prior value
319+  6237 8A                                   adc a,d                             ;   .
320+  6238 CB 13        .loop_2:                rl e                                ; else
321+  623A ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
322+  623C 17           .loop_30:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
323+  623D ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
324+  623F 9A                                   sbc a,d                             ;
325+  6240 30 02                                jr nc, .loop_3                       ; if AHL is negative
326+  6242 09                                   add hl,bc                           ;   revert AHL back to prior value
327+  6243 8A                                   adc a,d                             ;   .
328+  6244 CB 13        .loop_3:                rl e                                ; else
329+  6246 ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
330+  6248 17           .loop_40:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
331+  6249 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
332+  624B 9A                                   sbc a,d                             ;
333+  624C 30 02                                jr nc, .loop_4                       ; if AHL is negative
334+  624E 09                                   add hl,bc                           ;   revert AHL back to prior value
335+  624F 8A                                   adc a,d                             ;   .
336+  6250 CB 13        .loop_4:                rl e                                ; else
337+  6252 ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
338+  6254 17           .loop_50:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
339+  6255 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
340+  6257 9A                                   sbc a,d                             ;
341+  6258 30 02                                jr nc, .loop_5                       ; if AHL is negative
342+  625A 09                                   add hl,bc                           ;   revert AHL back to prior value
343+  625B 8A                                   adc a,d                             ;   .
344+  625C CB 13        .loop_5:                rl e                                ; else
345+  625E ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
346+  6260 17           .loop_60:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
347+  6261 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
348+  6263 9A                                   sbc a,d                             ;
349+  6264 30 02                                jr nc, .loop_6                       ; if AHL is negative
350+  6266 09                                   add hl,bc                           ;   revert AHL back to prior value
351+  6267 8A                                   adc a,d                             ;   .
352+  6268 CB 13        .loop_6:                rl e                                ; else
353+  626A ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
354+  626C 17           .loop_70:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
355+  626D ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
356+  626F 9A                                   sbc a,d                             ;
357+  6270 30 02                                jr nc, .loop_7                       ; if AHL is negative
358+  6272 09                                   add hl,bc                           ;   revert AHL back to prior value
359+  6273 8A                                   adc a,d                             ;   .
360+  6274 CB 13        .loop_7:                rl e                                ; else
361+  6276 ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
362+  6278 17           .loop_80:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
363+  6279 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
364+  627B 9A                                   sbc a,d                             ;
365+  627C 30 02                                jr nc, .loop_8                       ; if AHL is negative
366+  627E 09                                   add hl,bc                           ;   revert AHL back to prior value
367+  627F 8A                                   adc a,d                             ;   .
368+  6280 CB 13        .loop_8:                rl e                                ; else
369+  6282 ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
370+  6284
371+  6284
372+  6284
373+  6284 17                                   rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
374+  6285 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
375+  6287 9A                                   sbc a,d                             ;
376+  6288 30 02                                jr nc, .exit_loop                    ; if AHL is negative
377+  628A 09                                   add hl,bc                           ;   revert AHL back to prior value
378+  628B 8A                                   adc a,d                             ;   .
379+  628C              ; quotient  = ~e[hl'] remainder =  ahl  one more shift left on quotient
380+  628C EB           .exit_loop:             ex de,hl                            ; ADE = AHL  HL = DE
381+  628D 4F                                   ld c,a                              ; CDE = ADE
382+  628E 7D                                   ld a,l                              ; L = (L*2) * -1 (as we reach here via jr nc then carry is 0
383+  628F 17                                   rla                                 ; .
384+  6290 2F                                   cpl                                 ; .
385+  6291 6F                                   ld l,a                              ; .
386+  6292 AF                                   xor a                               ; h = 0
387+  6293 67                                   ld h,a
388+  6294 C3 69 64                             jp      HandleSign
389+  6297              ;-----------------------------------------------------------------------------------------------------
390+  6297              ; AHL = HLE/BC, where A is always 0 return EHL > DBC EHL >= 01 00 00 DBC >= 00 01 00
391+  6297              ; inside loop computation is ehl / c  hl = remainder
392+  6297 50           Perform_24x16:          ld      d,b                         ; HLE/BC => HLE/DC
393+  6298 7B                                   ld      a,e                         ;           HLA/DC
394+  6299 59                                   ld      e,c                         ;           HLA/DE
395+  629A 4D                                   ld      c,l                         ;           HCA/DE
396+  629B 6F                                   ld      l,a                         ;           HCL/DE
397+  629C 7C                                   ld      a,h                         ;           ACL/DE
398+  629D 26 00                                ld      h,0                         ;           ACL/DE
399+  629F 06 02                                ld      b,2                         ;           ACB/DE (B = 2)
400+  62A1 CB 11        .eliminateLeadingZeros: rl c
401+  62A3 17                                   rla
402+  62A4 ED 6A                                adc hl,hl
403+  62A6 24                                   inc h
404+  62A7 25                                   dec h
405+  62A8 20 47                                jr nz, .loop_00
406+  62AA CB 11                                rl c
407+  62AC 0C                                   inc c
408+  62AD 17                                   rla
409+  62AE ED 6A                                adc hl,hl
410+  62B0 24                                   inc h
411+  62B1 25                                   dec h
412+  62B2 20 49                                jr nz, .loop_11
413+  62B4 CB 11                                rl c
414+  62B6 0C                                   inc c
415+  62B7 17                                   rla
416+  62B8 ED 6A                                adc hl,hl
417+  62BA 24                                   inc h
418+  62BB 25                                   dec h
419+  62BC 20 4B                                jr nz, .loop_22
420+  62BE CB 11                                rl c
421+  62C0 0C                                   inc c
422+  62C1 17                                   rla
423+  62C2 ED 6A                                adc hl,hl
424+  62C4 24                                   inc h
425+  62C5 25                                   dec h
426+  62C6 20 4D                                jr nz, .loop_33
427+  62C8 CB 11                                rl c
428+  62CA 0C                                   inc c
429+  62CB 17                                   rla
430+  62CC ED 6A                                adc hl,hl
431+  62CE 24                                   inc h
432+  62CF 25                                   dec h
433+  62D0 20 4F                                jr nz, .loop_44
434+  62D2 CB 11                                rl c
435+  62D4 0C                                   inc c
436+  62D5 17                                   rla
437+  62D6 ED 6A                                adc hl,hl
438+  62D8 24                                   inc h
439+  62D9 25                                   dec h
440+  62DA 20 51                                jr nz, .loop_55
441+  62DC CB 11                                rl c
442+  62DE 0C                                   inc c
443+  62DF 17                                   rla
444+  62E0 ED 6A                                adc hl,hl
445+  62E2 24                                   inc h
446+  62E3 25                                   dec h
447+  62E4 20 53                                jr nz, .loop_66
448+  62E6 37                                   scf
449+  62E7 C3 3E 63                             jp .loop_7
450+  62EA CB 11        .loop_0:                rl c
451+  62EC 17                                   rla
452+  62ED ED 6A                                adc hl,hl
453+  62EF 38 68                                jr c, .loop_000
454+  62F1 ED 52        .loop_00:               sbc hl,de
455+  62F3 30 01                                jr nc, .loop_1
456+  62F5 19                                   add hl,de
457+  62F6 CB 11        .loop_1:                rl c
458+  62F8 17                                   rla
459+  62F9 ED 6A                                adc hl,hl
460+  62FB 38 63                                jr c, .loop_111
461+  62FD ED 52        .loop_11:               sbc hl,de
462+  62FF 30 01                                jr nc, .loop_2
463+  6301 19                                   add hl,de
464+  6302 CB 11        .loop_2:                rl c
465+  6304 17                                   rla
466+  6305 ED 6A                                adc hl,hl
467+  6307 38 5E                                jr c, .loop_222
468+  6309 ED 52        .loop_22:               sbc hl,de
469+  630B 30 01                                jr nc, .loop_3
470+  630D 19                                   add hl,de
471+  630E CB 11        .loop_3:                rl c
472+  6310 17                                   rla
473+  6311 ED 6A                                adc hl,hl
474+  6313 38 59                                jr c, .loop_333
475+  6315 ED 52        .loop_33:               sbc hl,de
476+  6317 30 01                                jr nc, .loop_4
477+  6319 19                                   add hl,de
478+  631A CB 11        .loop_4:                rl c
479+  631C 17                                   rla
480+  631D ED 6A                                adc hl,hl
481+  631F 38 54                                jr c, .loop_444
482+  6321 ED 52        .loop_44:               sbc hl,de
483+  6323 30 01                                jr nc, .loop_5
484+  6325 19                                   add hl,de
485+  6326 CB 11        .loop_5:                rl c
486+  6328 17                                   rla
487+  6329 ED 6A                                adc hl,hl
488+  632B 38 4F                                jr c, .loop_555
489+  632D ED 52        .loop_55:               sbc hl,de
490+  632F 30 01                                jr nc, .loop_6
491+  6331 19                                   add hl,de
492+  6332 CB 11        .loop_6:                rl c
493+  6334 17                                   rla
494+  6335 ED 6A                                adc hl,hl
495+  6337 38 4A                                jr c, .loop_666
496+  6339 ED 52        .loop_66:               sbc hl,de
497+  633B 30 01                                jr nc, .loop_7
498+  633D 19                                   add hl,de
499+  633E CB 11        .loop_7:                rl c
500+  6340 17                                   rla
501+  6341 ED 6A                                adc hl,hl
502+  6343 38 45                                jr c, .loop_777
503+  6345 ED 52        .loop_77:               sbc hl,de
504+  6347 30 01                                jr nc, .loop_8
505+  6349 19                                   add hl,de
506+  634A 10 9E        .loop_8:                djnz .loop_0
507+  634C CB 11        .exit_loop:             rl c
508+  634E 17                                   rla
509+  634F                                      ; ac = ~quotient, hl = remainder
510+  634F EB                                   ex de,hl
511+  6350 2F                                   cpl
512+  6351 67                                   ld h,a
513+  6352 79                                   ld a,c
514+  6353 2F                                   cpl
515+  6354 6F                                   ld l,a
516+  6355 AF                                   xor a
517+  6356 C3 69 64                             jp      HandleSign
518+  6359 B7           .loop_000:              or a
519+  635A ED 52                                sbc hl,de
520+  635C B7                                   or a
521+  635D C3 F6 62                             jp .loop_1
522+  6360 B7           .loop_111:              or a
523+  6361 ED 52                                sbc hl,de
524+  6363 B7                                   or a
525+  6364 C3 02 63                             jp .loop_2
526+  6367 B7           .loop_222:              or a
527+  6368 ED 52                                sbc hl,de
528+  636A B7                                   or a
529+  636B C3 0E 63                             jp .loop_3
530+  636E B7           .loop_333:              or a
531+  636F ED 52                                sbc hl,de
532+  6371 B7                                   or a
533+  6372 C3 1A 63                             jp .loop_4
534+  6375 B7           .loop_444:              or a
535+  6376 ED 52                                sbc hl,de
536+  6378 B7                                   or a
537+  6379 C3 26 63                             jp .loop_5
538+  637C B7           .loop_555:              or a
539+  637D ED 52                                sbc hl,de
540+  637F B7                                   or a
541+  6380 C3 32 63                             jp .loop_6
542+  6383 B7           .loop_666:              or a
543+  6384 ED 52                                sbc hl,de
544+  6386 B7                                   or a
545+  6387 C3 3E 63                             jp .loop_7
546+  638A B7           .loop_777:              or a
547+  638B ED 52                                sbc hl,de
548+  638D B7                                   or a
549+  638E C3 4A 63                             jp .loop_8
550+  6391              ;-----------------------------------------------------------------------------------------------------
551+  6391              ; AHL = HLE/BC, where A is always 0 return EHL > DBC EHL >= 01 00 00 DBC >= 00 00 01
552+  6391              ; inside loop computation is abc/de, hl = remainder
553+  6391              ; EHL: = EHL/C
554+  6391              ;so currerntly thsi can't hadnle c > 127 so need to understand lead sign at lower bit levels on c
555+  6391              ;so could just do 24 bit and process lead zeros in h and hope that is enough? or have a special case
556+  6391              ;for collapsing lead zeros in dbc too
557+  6391 79           Perform_24x8:           ld      a,c
558+  6392 E6 80                                and     $80
559+  6394 CA BD 63                             jp      z,Perform_24x7
560+  6397 DD 26 18                             ld      ixh,24              ; from ehl/c to ABC/E
561+  639A 7B                                   ld      a,e
562+  639B 44                                   ld      b,h
563+  639C 51                                   ld      d,c
564+  639D 4D                                   ld      c,l
565+  639E 5A                                   ld      e,d
566+  639F 16 00                                ld      d,0
567+  63A1 21 00 00                             ld      hl,0                ;
568+  63A4                                      ; with c being 8 bit we need to do
569+  63A4 CB 21        .loop1:                 sla     c                   ; unroll 24 times
570+  63A6 CB 10                                rl      b                   ; ...
571+  63A8 17                                   rla                         ; ...
572+  63A9 ED 6A                                adc     hl,hl               ; ...
573+  63AB ED 52                                sbc     hl,de               ; ...
574+  63AD 30 02                                jr      nc,.Skip1           ; ...
575+  63AF 19                                   add     hl,de               ; ...
576+  63B0 0D                                   dec     c                   ; ...
577+  63B1 DD 25        .Skip1:                 dec     ixh
578+  63B3 FD 00                                break
579+  63B5 C2 A4 63                             jp      nz,.loop1
580+  63B8 FD 00                                break
581+  63BA C3 69 64                             jp      HandleSign
582+  63BD 06 18        Perform_24x7:           ld b,24
583+  63BF AF                                   xor a
584+  63C0 29           .loop1:                 add hl,hl
585+  63C1 CB 13                                rl e
586+  63C3 17                                   rla
587+  63C4                                      ;rl d
588+  63C4                                      ;rla
589+  63C4 B9                                   cp c
590+  63C5 38 02                                jr c, .Skip1
591+  63C7 91                                   sub c
592+  63C8 2C                                   inc l
593+  63C9 10 F5        .Skip1:                 djnz .loop1
594+  63CB FD 00                                break
595+  63CD C3 69 64                             jp      HandleSign
596+  63D0
597+  63D0                 ;   a = remainder
598+  63D0                 ; ehl = quotient
599+  63D0
600+  63D0 4F              ld c,a
601+  63D1 7B              ld a,e
602+  63D2 59              ld e,c
603+  63D3 50              ld d,b
604+  63D4
605+  63D4 B7              or a
606+  63D5 C9              ret
607+  63D6
608+  63D6
609+  63D6              ;.slow32x8:              ld      d,h ; do dehl / c
610+  63D6              ;                        ld      e,l
611+  63D6              ;                        ld      h,e
612+  63D6              ;                        ld      l,0
613+  63D6              ;                        xor     a
614+  63D6              ;.looping:               ld b,2
615+  63D6              ;.loop_11:               add hl,hl
616+  63D6              ;                        rl e
617+  63D6              ;                        rl d
618+  63D6              ;.loop_01:               rla
619+  63D6              ;                        jr c, .loop_02
620+  63D6              ;                        cp c
621+  63D6              ;                        jr c, .loop_03
622+  63D6              ;.loop_02:               sub c
623+  63D6              ;                        inc l
624+  63D6              ;.loop_03:               djnz .loop_11
625+  63D6 B7                                   or a
626+  63D7              ; result dehl = 32-bit quotient
627+  63D7              ;.slow:                  ld      b,24
628+  63D7              ;.loop_11:               add     hl,hl
629+  63D7              ;                        rl      e
630+  63D7              ;.loop_01:               rla
631+  63D7              ;                        jr      c, .loop_02
632+  63D7              ;                        cp      c
633+  63D7              ;                        jr      c, .loop_03
634+  63D7              ;.loop_02:               sub 01010c
635+  63D7              ;                        inc 01010l
636+  63D7              ;.loop_03:               djnz .loop_11
637+  63D7              ;                        ld c,a
638+  63D7              ;                        ld a,e
639+  63D7              ;                        ld e,c
640+  63D7              ;                        ld d,b
641+  63D7              ;                        or a
642+  63D7 C3 69 64                             jp      HandleSign
643+  63DA
644+  63DA AF           DEBUG:                        xor     a                           ;             A = 0 Clear carry flag
645+  63DB 06 03                                ld b,3
646+  63DD              .eliminateLeadingZeros:
647+  63DD 29           .loop_00:               add hl,hl
648+  63DE CB 13                                rl e
649+  63E0 38 2B                                jr c, .loop_10
650+  63E2 29                                   add hl,hl
651+  63E3 CB 13                                rl e
652+  63E5 38 31                                jr c, .loop_20
653+  63E7 29                                   add hl,hl
654+  63E8 CB 13                                rl e
655+  63EA 38 37                                jr c, .loop_30
656+  63EC 29                                   add hl,hl
657+  63ED CB 13                                rl e
658+  63EF 38 3D                                jr c, .loop_40
659+  63F1 29                                   add hl,hl
660+  63F2 CB 13                                rl e
661+  63F4 38 43                                jr c, .loop_50
662+  63F6 29                                   add hl,hl
663+  63F7 CB 13                                rl e
664+  63F9 38 49                                jr c, .loop_60
665+  63FB 29                                   add hl,hl
666+  63FC CB 13                                rl e
667+  63FE 38 4F                                jr c, .loop_70
668+  6400 29                                   add hl,hl
669+  6401 CB 13                                rl e
670+  6403 17                                   rla
671+  6404 B9                                   cp c
672+  6405 38 02                                jr c, .loop_80
673+  6407 91                                   sub c
674+  6408 2C                                   inc l
675+  6409 05           .loop_80:               dec b
676+  640A                 ; general divide loop
677+  640A 29           .loop_0:                add     hl,hl
678+  640B CB 13                                rl      e
679+  640D 17           .loop_10:               rla
680+  640E 38 03                                jr      c, .loop_101
681+  6410 B9                                   cp      c
682+  6411 38 02                                jr      c, .loop_1
683+  6413 91           .loop_101:              sub     c
684+  6414 2C                                   inc     l
685+  6415 29           .loop_1:                add     hl,hl
686+  6416 CB 13                                rl      e
687+  6418 17           .loop_20:               rla
688+  6419 38 03                                jr      c, .loop_201
689+  641B B9                                   cp      c
690+  641C 38 02                                jr      c, .loop_2
691+  641E 91           .loop_201:              sub     c
692+  641F 2C                                   inc     l
693+  6420 29           .loop_2:                add     hl,hl
694+  6421 CB 13                                rl      e
695+  6423 17           .loop_30:               rla
696+  6424 38 03                                jr      c, .loop_301
697+  6426 B9                                   cp      c
698+  6427 38 02                                jr      c, .loop_3
699+  6429 91           .loop_301:              sub     c
700+  642A 2C                                   inc     l
701+  642B 29           .loop_3:                add     hl,hl
702+  642C CB 13                                rl      e
703+  642E 17           .loop_40:               rla
704+  642F 38 03                                jr      c, .loop_401
705+  6431 B9                                   cp      c
706+  6432 38 02                                jr      c, .loop_4
707+  6434 91           .loop_401:              sub     c
708+  6435 2C                                   inc     l
709+  6436 29           .loop_4:                add     hl,hl
710+  6437 CB 13                                rl      e
711+  6439 17           .loop_50:               rla
712+  643A 38 03                                jr      c, .loop_501
713+  643C B9                                   cp      c
714+  643D 38 02                                jr      c, .loop_5
715+  643F 91           .loop_501:              sub     c
716+  6440 2C                                   inc     l
717+  6441 29           .loop_5:                add     hl,hl
718+  6442 CB 13                                rl      e
719+  6444 17           .loop_60:               rla
720+  6445 38 03                                jr      c, .loop_601
721+  6447 B9                                   cp      c
722+  6448 38 02                                jr      c, .loop_6
723+  644A 91           .loop_601:              sub     c
724+  644B 2C                                   inc     l
725+  644C 29           .loop_6:                add     hl,hl
726+  644D CB 13                                rl      e
727+  644F 17           .loop_70:               rla
728+  6450 38 03                                jr      c, .loop_701
729+  6452 B9                                   cp      c
730+  6453 38 02                                jr      c, .loop_7
731+  6455 91           .loop_701:              sub     c
732+  6456 2C                                   inc     l
733+  6457 29           .loop_7:                add     hl,hl
734+  6458 CB 13                                rl      e
735+  645A 17                                   rla
736+  645B 38 03                                jr      c, .loop_801
737+  645D B9                                   cp      c
738+  645E 38 02                                jr      c, .loop_8
739+  6460 91           .loop_801:              sub     c
740+  6461 2C                                   inc     l
741+  6462 10 A6        .loop_8:                djnz    .loop_0
742+  6464 4F           .exit_loop:             ld      c,a
743+  6465 7B                                   ld      a,e
744+  6466 59                                   ld      e,c
745+  6467 50                                   ld      d,b
746+  6468 B7                                   or      a
747+  6469 47           HandleSign:             ld      b,a ; save the a value      ; now deal with prior sign
748+  646A F1                                   pop     af
749+  646B B0                                   or      b                           ; now a holds saved sign and b result so now lead sign S15.8
750+  646C C9                                   ret
751+  646D              ;-----------------------------------------------------------------------------------------------------
752+  646D              ; AHL = HL/BC, EHL > DBC both >= 00 01 00
753+  646D 50 59        Perform_16x16:          ld      de,bc                       ; get to AHL= 0HL/0BC
754+  646F 7D                                   ld      a,l                         ;hl >= $1000 de >= $1000 so max quotient is 255
755+  6470 6C                                   ld      l,h                         ; which means the loop computation is a[c] / de hl = remainder
756+  6471 26 00                                ld      h,0                         ; so we can initialise as if 8 iterations are done
757+  6473              ; unrolling divide 8 time, eliminating leading zeros is only marginal gain
758+  6473 17           .loop_0:                rla
759+  6474 ED 6A                                adc     hl,hl
760+  6476 ED 52        .loop_00:               sbc     hl,de
761+  6478 30 01                                jr      nc, .loop_1
762+  647A 19                                   add     hl,de
763+  647B 17           .loop_1:                rla
764+  647C ED 6A                                adc     hl,hl
765+  647E ED 52        .loop_11:               sbc     hl,de
766+  6480 30 01                                jr      nc, .loop_2
767+  6482 19                                   add     hl,de
768+  6483 17           .loop_2:                rla
769+  6484 ED 6A                                adc     hl,hl
770+  6486 ED 52        .loop_22:               sbc     hl,de
771+  6488 30 01                                jr      nc, .loop_3
772+  648A 19                                   add     hl,de
773+  648B 17           .loop_3:                rla
774+  648C ED 6A                                adc     hl,hl
775+  648E ED 52        .loop_33:               sbc     hl,de
776+  6490 30 01                                jr      nc, .loop_4
777+  6492 19                                   add     hl,de
778+  6493 17           .loop_4:                rla
779+  6494 ED 6A                                adc     hl,hl
780+  6496 ED 52        .loop_44:               sbc     hl,de
781+  6498 30 01                                jr      nc, .loop_5
782+  649A 19                                   add     hl,de
783+  649B              .loop_5:
784+  649B 17                                   rla
785+  649C ED 6A                                adc     hl,hl
786+  649E              .loop_55:
787+  649E ED 52                                sbc     hl,de
788+  64A0 30 01                                jr      nc, .loop_6
789+  64A2 19                                   add     hl,de
790+  64A3              .loop_6:
791+  64A3 17                                   rla
792+  64A4 ED 6A                                adc     hl,hl
793+  64A6              .loop_66:
794+  64A6 ED 52                                sbc     hl,de
795+  64A8 30 01                                jr      nc, .loop_7
796+  64AA 19                                   add     hl,de
797+  64AB              .loop_7:
798+  64AB 17                                   rla
799+  64AC ED 6A                                adc     hl,hl
800+  64AE ED 52        .loop_77:               sbc     hl,de
801+  64B0 30 01                                jr      nc, .exit_loop
802+  64B2 19                                   add     hl,de
803+  64B3 17           .exit_loop:             rla                ; a = ~quotient, hl = remainder
804+  64B4 2F                                   cpl
805+  64B5 5F                                   ld      e,a
806+  64B6 AF                                   xor     a
807+  64B7 57                                   ld      d,a
808+  64B8 EB                                   ex      de,hl
809+  64B9 C3 69 64                             jp      HandleSign
810+  64BC              ;-----------------------------------------------------------------------------------------------------
811+  64BC              ; AHL = HL/C, where A is always 0 return EHL > DBC both >= 00 01 00, internally does HL/E
812+  64BC 59           Perform_16x8:           ld      e,c                          ; get to AHL= 0HL/00C
813+  64BD AF                                   xor a
814+  64BE 57                                   ld      d,a
815+  64BF 06 02                                ld      b,2
816+  64C1 29           .loop_00:               add     hl,hl                       ; eliminate leading zeroes
817+  64C2 38 1B                                jr      c, .loop_10
818+  64C4 29                                   add     hl,hl
819+  64C5 38 21                                jr      c, .loop_20
820+  64C7 29                                   add     hl,hl
821+  64C8 38 27                                jr      c, .loop_30
822+  64CA 29                                   add     hl,hl
823+  64CB 38 2D                                jr      c, .loop_40
824+  64CD 29                                   add     hl,hl
825+  64CE 38 33                                jr      c, .loop_50
826+  64D0 29                                   add     hl,hl
827+  64D1 38 39                                jr      c, .loop_60
828+  64D3 29                                   add     hl,hl
829+  64D4 38 3F                                jr      c, .loop_70
830+  64D6 29                                   add     hl,hl
831+  64D7 17                                   rla
832+  64D8 BB                                   cp      e
833+  64D9 38 02                                jr      c, .loop_80
834+  64DB 93                                   sub     e
835+  64DC 2C                                   inc     l
836+  64DD 05           .loop_80:               dec     b
837+  64DE 29           .loop_0:                add     hl,hl
838+  64DF 17           .loop_10:               rla
839+  64E0 38 03                                jr      c, .loop_101
840+  64E2 BB                                   cp      e
841+  64E3 38 02                                jr      c, .loop_1
842+  64E5 93           .loop_101:              sub     e
843+  64E6 2C                                   inc     l
844+  64E7 29           .loop_1:                add     hl,hl
845+  64E8 17           .loop_20:               rla
846+  64E9 38 03                                jr      c, .loop_201
847+  64EB BB                                   cp      e
848+  64EC 38 02                                jr      c, .loop_2
849+  64EE 93           .loop_201:              sub     e
850+  64EF 2C                                   inc     l
851+  64F0 29           .loop_2:                add     hl,hl
852+  64F1 17           .loop_30:               rla
853+  64F2 38 03                                jr      c, .loop_301
854+  64F4 BB                                   cp      e
855+  64F5 38 02                                jr      c, .loop_3
856+  64F7 93           .loop_301:              sub     e
857+  64F8 2C                                   inc     l
858+  64F9 29           .loop_3:                add     hl,hl
859+  64FA 17           .loop_40:               rla
860+  64FB 38 03                                jr      c, .loop_401
861+  64FD BB                                   cp      e
862+  64FE 38 02                                jr      c, .loop_4
863+  6500 93           .loop_401:              sub     e
864+  6501 2C                                   inc     l
865+  6502 29           .loop_4:                add     hl,hl
866+  6503 17           .loop_50:               rla
867+  6504 38 03                                jr      c, .loop_501
868+  6506 BB                                   cp      e
869+  6507 38 02                                jr      c, .loop_5
870+  6509 93           .loop_501:               sub     e
871+  650A 2C                                   inc     l
872+  650B 29           .loop_5:                 add     hl,hl
873+  650C 17           .loop_60:                rla
874+  650D 38 03                                jr      c, .loop_601
875+  650F BB                                   cp      e
876+  6510 38 02                                jr      c, .loop_6
877+  6512 93           .loop_601:               sub     e
878+  6513 2C                                   inc     l
879+  6514 29           .loop_6:                 add     hl,hl
880+  6515 17           .loop_70:                rla
881+  6516 38 03                                jr      c, .loop_701
882+  6518 BB                                   cp      e
883+  6519 38 02                                jr      c, .loop_7
884+  651B 93           .loop_701:               sub     e
885+  651C 2C                                   inc     l
886+  651D 29           .loop_7:                 add     hl,hl
887+  651E 17                                   rla
888+  651F 38 03                                jr      c, .loop_801
889+  6521 BB                                   cp      e
890+  6522 38 02                                jr      c, .loop_8
891+  6524 93           .loop_801:               sub     e
892+  6525 2C                                   inc     l
893+  6526 10 B6        .loop_8:                 djnz    .loop_0
894+  6528              .exit_loop:              ;AHL = quotient CDE = remainder
895+  6528 5F                                   ld e,a
896+  6529 AF                                   xor a
897+  652A C3 69 64                             jp      HandleSign
898+  652D              ;-----------------------------------------------------------------------------------------------------
899+  652D              ; AHL = L/C, where A is always 0 return EHL > DBC both >= 00 01 00, internally does L/E
900+  652D AF           Perform_8x8:            xor     a
901+  652E 57                                   ld      d,a
902+  652F 67                                   ld      h,a
903+  6530 59                                   ld      e,c
904+  6531 CB 25        .loop_00:               sla     l
905+  6533 38 1B                                jr      c, .loop_10
906+  6535 CB 25                                sla     l
907+  6537 38 1F                                jr      c, .loop_20
908+  6539 CB 25                                sla     l
909+  653B 38 23                                jr      c, .loop_30
910+  653D CB 25                                sla     l
911+  653F 38 27                                jr      c, .loop_40
912+  6541 CB 25                                sla     l
913+  6543 38 2B                                jr      c, .loop_50
914+  6545 CB 25                                sla     l
915+  6547 38 2F                                jr      c, .loop_60
916+  6549 CB 25                                sla     l
917+  654B 38 33                                jr      c, .loop_70
918+  654D C3 86 65                             jp      .loop_17
919+  6550 17           .loop_10:               rla
920+  6551 BB                                   cp      e
921+  6552 38 02                                jr      c, .loop_11
922+  6554 93                                   sub     e
923+  6555 2C                                   inc     l
924+  6556 CB 25        .loop_11:               sla     l
925+  6558 17           .loop_20:               rla
926+  6559 BB                                   cp      e
927+  655A 38 02                                jr      c, .loop_12
928+  655C 93                                   sub     e
929+  655D 2C                                   inc     l
930+  655E CB 25        .loop_12:               sla     l
931+  6560 17           .loop_30:               rla
932+  6561 BB                                   cp      e
933+  6562 38 02                                jr      c, .loop_13
934+  6564 93                                   sub     e
935+  6565 2C                                   inc     l
936+  6566 CB 25        .loop_13:               sla     l
937+  6568 17           .loop_40:               rla
938+  6569 BB                                   cp      e
939+  656A 38 02                                jr      c, .loop_14
940+  656C 93                                   sub     e
941+  656D 2C                                   inc     l
942+  656E CB 25        .loop_14:               sla     l
943+  6570 17           .loop_50:               rla
944+  6571 BB                                   cp      e
945+  6572 38 02                                jr      c, .loop_15
946+  6574 93                                   sub     e
947+  6575 2C                                   inc     l
948+  6576 CB 25        .loop_15:               sla     l
949+  6578 17           .loop_60:               rla
950+  6579 BB                                   cp      e
951+  657A 38 02                                jr      c, .loop_16
952+  657C 93                                   sub     e
953+  657D 2C                                   inc     l
954+  657E CB 25        .loop_16:               sla     l
955+  6580 17           .loop_70:               rla
956+  6581 BB                                   cp      e
957+  6582 38 02                                jr      c, .loop_17
958+  6584 93                                   sub     e
959+  6585 2C                                   inc     l
960+  6586 CB 25        .loop_17:               sla     l
961+  6588 17                                   rla
962+  6589 BB                                   cp      e
963+  658A 38 02                                jr      c, .exit_loop
964+  658C 93                                   sub     e
965+  658D 2C                                   inc     l
966+  658E              .exit_loop:
967+  658E                                      ; a = remainder
968+  658E                                      ; l = quotient
969+  658E 5F                                   ld      e,a
970+  658F AF                                   xor     a
971+  6590 C3 69 64                             jp      HandleSign
972+  6593
973+  6593              ;
974+  6593              ; AHL = 24bit at IX + 24 bit at IY
975+  6593
976+  6593              ; AHL = 24bit at IX - 24 bit at IY
977+  6593
978+  6593              ; BAHL = 24bit at IX * 24 bit at IY  Lead Sign bit
979+  6593
980+  6593              ; AHL = 24bit at IX / 24 bit at IY  Lead Sign bit
981+  6593
# file closed: asm_addition24.asm
204   6593
205   6593
206   6593
207   6593
208   6593                  SAVENEX OPEN "mathsRollPitch.nex", EliteNextStartup , TopOfStack
209   6593                  SAVENEX CFG  0,0,0,1
210   6593                  SAVENEX AUTO
211   6593                  SAVENEX CLOSE
212   6593
213   6593
# file closed: mathsRollPitch.asm
