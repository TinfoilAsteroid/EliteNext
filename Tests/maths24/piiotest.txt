# file opened: m24test.asm
  1   0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
  2   0000                              DISPLAY "m24test test"
  3   0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
  4   0000
  5   0000
  6   0000                  DEFINE DEBUGMODE 1
  7   0000                  DEVICE ZXSPECTRUMNEXT
  8   0000                  SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
  9   0000                  ;DEFINE  TESTING_MATHS_DIVIDE 1
 10   0000               CSPECTMAP m24test.map
 11   0000               OPT --zxnext=cspect --syntax=a --reversepop
 12   0000                             DEFINE     MAIN_INTERRUPTENABLE 1
 13   0000              DEBUGSEGSIZE   equ 1
 14   0000              DEBUGLOGSUMMARY equ 1
 15   0000
 16   0000
 17   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 18   0000              ; Game Defines
 19   0000              ScreenLocal      EQU 0
 20   0000              ScreenGalactic   EQU ScreenLocal + 1
 21   0000              ScreenMarket     EQU ScreenGalactic + 1
 22   0000              ScreenMarketDsp  EQU ScreenMarket + 1
 23   0000              ScreenStatus     EQU ScreenMarketDsp + 1
 24   0000              ScreenInvent     EQU ScreenStatus + 1
 25   0000              ScreenPlanet     EQU ScreenInvent + 1
 26   0000              ScreenEquip      EQU ScreenPlanet + 1
 27   0000              ScreenLaunch     EQU ScreenEquip + 1
 28   0000              ScreenFront      EQU ScreenLaunch + 1
 29   0000              ScreenAft        EQU ScreenFront+1
 30   0000              ScreenLeft       EQU ScreenAft+1
 31   0000              ScreenRight      EQU ScreenLeft+1
 32   0000              ScreenDocking    EQU ScreenRight+1
 33   0000              ScreenHyperspace EQU ScreenDocking+1
 34   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 35   0000              ; Colour Defines
 36   0000              SignMask8Bit		equ %01111111
 37   0000              SignMask16Bit		equ %0111111111111111
 38   0000              SignOnly8Bit		equ $80
 39   0000              SignOnly16Bit		equ $8000
 40   0000
 41   0000              Bit7Only            equ %10000000
 42   0000              Bit6Only            equ %01000000
 43   0000              Bit5Only            equ %00100000
 44   0000              Bit4Only            equ %00010000
 45   0000              Bit3Only            equ %00001000
 46   0000              Bit2Only            equ %00000100
 47   0000              Bit1Only            equ %00000010
 48   0000              Bit0Only            equ %00000001
 49   0000              Bit7Clear           equ %01111111
 50   0000              Bit6Clear           equ %10111111
 51   0000              Bit5Clear           equ %11011111
 52   0000              Bit4Clear           equ %11101111
 53   0000              Bit3Clear           equ %11110111
 54   0000              Bit2Clear           equ %11111011
 55   0000              Bit1Clear           equ %11111101
 56   0000              Bit0Clear           equ %11111110
 57   0000              ConstPi				equ $80
 58   0000              ConstNorm           equ 197
 59   0000
 60   0000
 61   0000
 62   0000                                      INCLUDE "../../Macros/jumpMacros.asm"
# file opened: jumpMacros.asm
  1+  0000              JumpIfHLNegative:       MACRO target
  2+  0000 ~                                    bit     7,h
  3+  0000 ~                                    jp      nz,target
  4+  0000                                      ENDM
  5+  0000
  6+  0000              JumpIfPositive:	        MACRO target
  7+  0000 ~                                    jp		p, target
  8+  0000                                      ENDM
  9+  0000
 10+  0000              JumpIfNegative:	        MACRO target
 11+  0000 ~                                    jp		m, target
 12+  0000                                      ENDM
 13+  0000
 14+  0000
 15+  0000              JumpIfUnderflow:	    MACRO target
 16+  0000 ~                                    jp		po, target
 17+  0000                                      ENDM
 18+  0000
 19+  0000              JumpIfOverflow:	        MACRO target
 20+  0000 ~                                    jp		po, target
 21+  0000                                      ENDM
 22+  0000
 23+  0000
 24+  0000              JumpIfNotZero:	        MACRO target
 25+  0000 ~                                    jp	nz,target
 26+  0000                                      ENDM
 27+  0000
 28+  0000              JumpIfZero:	            MACRO target
 29+  0000 ~                                    jp	z,target
 30+  0000                                      ENDM
 31+  0000
 32+  0000              ;.. Bit routines
 33+  0000              JumpOnLeadSignSet:      MACRO   reg, target
 34+  0000 ~                                    ld      a,reg
 35+  0000 ~                                    and     SignOnly8Bit
 36+  0000 ~                                    jp      nz,target
 37+  0000                                      ENDM
 38+  0000
 39+  0000              JumpOnLeadSignClear:    MACRO   reg, target
 40+  0000 ~                                    ld      a,reg
 41+  0000 ~                                    and     SignOnly8Bit
 42+  0000 ~                                    jp      z,target
 43+  0000                                      ENDM
 44+  0000
 45+  0000              JumpOnLeadSignSetA:     MACRO   target
 46+  0000 ~                                    and     SignOnly8Bit
 47+  0000 ~                                    jp      nz,target
 48+  0000                                      ENDM
 49+  0000
 50+  0000              JumpOnLeadSignClearA:   MACRO   target
 51+  0000 ~                                    and     SignOnly8Bit
 52+  0000 ~                                    jp      z,target
 53+  0000                                      ENDM
 54+  0000
 55+  0000              JumpOnMemBitSet:        MACRO mem, bitnbr, target
 56+  0000 ~                                    ld      a,(mem)
 57+  0000 ~                                    bit 	bitnbr,a
 58+  0000 ~                                    jp      nz,target
 59+  0000                                      ENDM
 60+  0000
 61+  0000              JumpOnMemBitClear:      MACRO mem, bitnbr, target
 62+  0000 ~                                    ld      a,(mem)
 63+  0000 ~                                    bit 	bitnbr,a
 64+  0000 ~                                    jp      z,target
 65+  0000                                      ENDM
 66+  0000
 67+  0000
 68+  0000              JumpOnABitSet:          MACRO   bitnbr, target
 69+  0000 ~                                    bit 	bitnbr, a
 70+  0000 ~                                    jp      nz,target
 71+  0000                                      ENDM
 72+  0000
 73+  0000              JumpOnABitClear:        MACRO   bitnbr, target
 74+  0000 ~                                    bit 	bitnbr, a
 75+  0000 ~                                    jp      z,target
 76+  0000                                      ENDM
 77+  0000
 78+  0000              JumpOnABit5Set:         MACRO   target
 79+  0000 ~                                    and     Bit5Only
 80+  0000 ~                                    jp      nz,target
 81+  0000                                      ENDM
 82+  0000
 83+  0000              JumpOnABit5Clear:       MACRO   target
 84+  0000 ~                                    and     Bit5Only
 85+  0000 ~                                    jp      z,target
 86+  0000                                      ENDM
 87+  0000
 88+  0000              JumpOnBitMaskSet:       MACRO   bitmask, target
 89+  0000 ~                                    and     bitmask
 90+  0000 ~                                    jp      nz,target
 91+  0000                                      ENDM
 92+  0000
 93+  0000              JumpOnBitMaskClear:     MACRO   bitmask, target
 94+  0000 ~                                    and     bitmask
 95+  0000 ~                                    jp      z,target
 96+  0000                                      ENDM
 97+  0000
 98+  0000              JumpOnMemBitMaskSet:    MACRO   mem, bitmask, target
 99+  0000 ~                                    ld      a,(mem)
100+  0000 ~                                    and     bitmask
101+  0000 ~                                    jp      nz,target
102+  0000                                      ENDM
103+  0000
104+  0000              JumpOnMemBitMaskClear:  MACRO   mem, bitmask, target
105+  0000 ~                                    ld      a,(mem)
106+  0000 ~                                    and     bitmask
107+  0000 ~                                    jp      z,target
108+  0000                                      ENDM
109+  0000
110+  0000              JumpOnBitSet:           MACRO  reg, bitnbr, target
111+  0000 ~                                    bit 	bitnbr,reg
112+  0000 ~                                    jp      nz,target
113+  0000                                      ENDM
114+  0000
115+  0000              JumpOnBitClear:         MACRO  reg, bitnbr, target
116+  0000 ~                                    bit 	bitnbr,reg
117+  0000 ~                                    jp      z,target
118+  0000                                      ENDM
119+  0000
120+  0000              ; Comparison Routines
121+  0000              JumpIfAGTEusng:         MACRO
122+  0000 ~                                    jp		nc,target
123+  0000                                      ENDM
124+  0000
125+  0000              JumpIfAGTENusng:        MACRO reg,target
126+  0000 ~                                    cp     reg
127+  0000 ~                                    jp		nc,target
128+  0000                                      ENDM
129+  0000
130+  0000              JumpIfAGTEMemusng:      MACRO mem,target
131+  0000 ~                                    ld      hl,mem
132+  0000 ~                                    cp      (hl)
133+  0000 ~                                    jp		nc,target
134+  0000                                      ENDM
135+  0000              JumpIfMemGTENusng:      MACRO mem, value, target
136+  0000 ~                                    ld     a,(mem)
137+  0000 ~                                    cp     value
138+  0000 ~                                    jp	  nc,target
139+  0000                                      ENDM
140+  0000
141+  0000              JumpIfMemGTEMemusng:    MACRO mem, address, target
142+  0000 ~                                    ld   a,(mem)
143+  0000 ~                                    ld   hl,address
144+  0000 ~                                    cp   (hl)
145+  0000 ~                                    jp	  nc,target
146+  0000                                      ENDM
147+  0000
148+  0000              JumpIfMemEqMemusng:     MACRO mem, address, target
149+  0000 ~                                    ld   a,(mem)
150+  0000 ~                                    ld   hl,address
151+  0000 ~                                    cp   (hl)
152+  0000 ~                                    jp	  z,target
153+  0000                                      ENDM
154+  0000
155+  0000              JumpIfMemNeMemusng:     MACRO mem, address, target
156+  0000 ~                                    ld   a,(mem)
157+  0000 ~                                    ld   hl,address
158+  0000 ~                                    cp   (hl)
159+  0000 ~                                    jp	  nz,target
160+  0000                                      ENDM
161+  0000
162+  0000              JumpIfMemTrue:          MACRO mem, target
163+  0000 ~                                    ld      a,(mem)
164+  0000 ~                                    and     a
165+  0000 ~                                    jp      z, target
166+  0000                                      ENDM
167+  0000
168+  0000              JumpIfMemFalse:         MACRO mem, target
169+  0000 ~                                    ld      a,(mem)
170+  0000 ~                                    and     a
171+  0000 ~                                    jp      nz, target
172+  0000                                      ENDM
173+  0000
174+  0000              JumpIfATrue:            MACRO target
175+  0000 ~                                    and     a
176+  0000 ~                                    jp      z, target
177+  0000                                      ENDM
178+  0000
179+  0000              JumpIfAFalse:           MACRO target
180+  0000 ~                                    and     a
181+  0000 ~                                    jp      nz, target
182+  0000                                      ENDM
183+  0000
184+  0000              JumpIfANotFalse:        MACRO target
185+  0000 ~                                    cp      $FF
186+  0000 ~                                    jp      nz, target
187+  0000                                      ENDM
188+  0000
189+  0000              ;-- Less than Macros -------------------------------------------
190+  0000              JumpIfALTMemHLusng:     MACRO target
191+  0000 ~                                    cp    (hl)
192+  0000 ~                                    jp	  c,target
193+  0000                                      ENDM
194+  0000
195+  0000              JumpIfRegLTE:           MACRO   reg, value, target
196+  0000 ~                                    ld      a,reg
197+  0000 ~                                    cp      value
198+  0000 ~                                    jp	    z,target
199+  0000 ~                                    jp		c, target
200+  0000                                      ENDM
201+  0000
202+  0000              JumpIfALTMemusng:       MACRO mem,target
203+  0000 ~                                    ld      hl,mem
204+  0000 ~                                    cp      (hl)
205+  0000 ~                                    jp		c,target
206+  0000                                      ENDM
207+  0000
208+  0000
209+  0000              JumpIfALTusng:          MACRO target
210+  0000 ~                                    jp		c,target
211+  0000                                      ENDM
212+  0000
213+  0000              JumpIfALTNusng:         MACRO value, target
214+  0000 ~                                    cp      value
215+  0000 ~                                    jp		c, target
216+  0000                                      ENDM
217+  0000
218+  0000              JumpIfALTNsigned:       MACRO   value, target
219+  0000 ~                                    cp      value
220+  0000 ~                                    jp      m,.SignSet
221+  0000 ~            .SignClear:             jp      pe,target       ; Sign (0), P/V (1)
222+  0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (0)
223+  0000 ~            .SignSet:               jp      po,target
224+  0000 ~            .CheckComplete:
225+  0000                                      ENDM
226+  0000
227+  0000              JumpIfMemLTNusng:       MACRO mem, value, target
228+  0000 ~                                    ld      a,(mem)
229+  0000 ~                                    cp      value
230+  0000 ~                                    jp	  c,target
231+  0000                                      ENDM
232+  0000
233+  0000              JumpIfMemLTMemusng:     MACRO mem, value, target
234+  0000 ~                                    ld    a,(mem)
235+  0000 ~                                    ld    hl,value
236+  0000 ~                                    cp    (hl)
237+  0000 ~                                    jp	  c,target
238+  0000                                      ENDM
239+  0000              ;-- ------------------------------------------------------------
240+  0000              JumpIfAGTENsigned       MACRO   value, target
241+  0000 ~                                    cp      value
242+  0000 ~                                    jp      m,.SignSet
243+  0000 ~            .SignClear:             jp      po,target       ; Sign (0), P/V (0)
244+  0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (1)
245+  0000 ~            .SignSet:               jp      pe,target
246+  0000 ~            .CheckComplete:
247+  0000                                      ENDM
248+  0000
249+  0000              JumpIfMemEqNusng:       MACRO mem,value,target
250+  0000 ~                                    ld  a,(mem)
251+  0000 ~                                    cp  value
252+  0000 ~                                    jp  z,target
253+  0000                                      ENDM
254+  0000
255+  0000              JumpIfMemNeNusng:       MACRO mem,value,target
256+  0000 ~                                    ld  a,(mem)
257+  0000 ~                                    cp  value
258+  0000 ~                                    jp  nz,target
259+  0000                                      ENDM
260+  0000
261+  0000              JumpIfMemZero:          MACRO mem,target
262+  0000 ~                                    ld  a,(mem)
263+  0000 ~                                    and a
264+  0000 ~                                    jp  z,target
265+  0000                                      ENDM
266+  0000
267+  0000              JumpIfMemNotZero:       MACRO mem,target
268+  0000 ~                                    ld  a,(mem)
269+  0000 ~                                    and a
270+  0000 ~                                    jp  nz,target
271+  0000                                      ENDM
272+  0000
273+  0000              JumpIfANENusng:         MACRO value, target
274+  0000 ~                                    cp     value
275+  0000 ~                                    jp      nz,target
276+  0000                                      ENDM
277+  0000
278+  0000              JumpIfANEquNusng:       MACRO value, target
279+  0000 ~                                    cp     value
280+  0000 ~                                    jp     z,target
281+  0000                                      ENDM
282+  0000
283+  0000              JumpIfANEMemusng:       MACRO  value, target
284+  0000 ~                                    ld    hl,value
285+  0000 ~                                    cp    (hl)
286+  0000 ~                                    jp      nz,target
287+  0000                                      ENDM
288+  0000
289+  0000              JumpIfAEqNusng:         MACRO value, target
290+  0000 ~                                    cp     value
291+  0000 ~                                    jp      z,target
292+  0000                                      ENDM
293+  0000
294+  0000              JumpIfAIsZero:	        MACRO target
295+  0000 ~                                    and     a   ; cp 0 - changed to and a for optimisation but affects other flags
296+  0000 ~                                    jp	    z, target
297+  0000                                      ENDM
298+  0000
299+  0000              JumpIfRegIsNotZero:     MACRO   reg, target
300+  0000 ~                                    ld      a,reg
301+  0000 ~                                    and     a
302+  0000 ~                                    jp	    nz,target
303+  0000                                      ENDM
304+  0000
305+  0000
306+  0000              JumpIfAIsNotZero:       MACRO target
307+  0000 ~                                    and     a
308+  0000 ~                                    jp	    nz,target
309+  0000                                      ENDM
310+  0000
311+  0000              JumpIfMemIsNotZero:     MACRO value, target
312+  0000 ~                                    ld      a,(value)
313+  0000 ~                                    and     a
314+  0000 ~                                    jp	    nz,target
315+  0000                                      ENDM
316+  0000              IfResultZeroGoto:	    MACRO target
317+  0000 ~                                    jp	z,target
318+  0000                                      ENDM
319+  0000
320+  0000              IfResultNotZeroGoto:    MACRO target
321+  0000 ~                                    jp	nz,target
322+  0000                                      ENDM
323+  0000
# file closed: jumpMacros.asm
 63   0000                                      INCLUDE "../../Macros/MathsMacros.asm"
# file opened: MathsMacros.asm
  1+  0000              ZeroA:		            MACRO
  2+  0000 ~                                    xor a
  3+  0000                                      ENDM
  4+  0000              ; sets z flag is HL less than 255 else sets it to nz (note opposite of GT127)
  5+  0000              IsHLGT255:              MACRO
  6+  0000 ~                                    bit     7,h
  7+  0000 ~                                    ret     z
  8+  0000 ~                                    ld      a,h
  9+  0000 ~                                    and     a
 10+  0000                                      ENDM
 11+  0000
 12+  0000              ; Sets z flat if HL = 255 else sets it to nz
 13+  0000              IsHLEqu255:             MACRO
 14+  0000 ~                                    ld      a,h
 15+  0000 ~                                    and     a               ; if its non zero then it can't be 255
 16+  0000 ~                                    ret     nz
 17+  0000 ~                                    ld      a,l
 18+  0000 ~                                    inc     a               ; if it was 255 the inc will set it to zero
 19+  0000                                      ENDM
 20+  0000
 21+  0000              ; Sets Z flag if GT 127 else nz
 22+  0000              IsHLGT127:              MACRO
 23+  0000 ~                                    bit     7,h             ; -ve?
 24+  0000 ~                                    jr      nz,.DoneCheck
 25+  0000 ~                                    ld      a,h             ; +ve > 256?
 26+  0000 ~                                    and     a
 27+  0000 ~                                    jr      nz,.DoneCheck
 28+  0000 ~                                    ld      a,l
 29+  0000 ~                                    and     $80             ; this will set z to false if bit 7 set and clear lower bits
 30+  0000 ~                                    cp      $80             ; this will set z to true if bit 7 set
 31+  0000 ~            .DoneCheck:
 32+  0000                                      ENDM
 33+  0000
 34+  0000              ReturnIfHLGT127:        MACRO
 35+  0000 ~                                    bit     7,h             ; -ve?
 36+  0000 ~                                    jr      nz,.DoneCheck   ; forces check complete
 37+  0000 ~                                    ld      a,h             ; +ve > 256?
 38+  0000 ~                                    and     a               ;
 39+  0000 ~                                    ret     nz              ; forces a return
 40+  0000 ~                                    bit     7,l             ; bit 7 of lower set?
 41+  0000 ~                                    ret     nz              ; forces a return
 42+  0000 ~            .DoneCheck:
 43+  0000                                      ENDM
 44+  0000
 45+  0000              IsDEGT127:              MACRO
 46+  0000 ~                                    bit     7,d
 47+  0000 ~                                    jr      nz,.DoneCheck
 48+  0000 ~                                    ld      a,d
 49+  0000 ~                                    jr      nz,.DoneCheck
 50+  0000 ~                                    ld      a,e
 51+  0000 ~                                    and     $80
 52+  0000 ~            .DoneCheck:
 53+  0000                                      ENDM
 54+  0000
 55+  0000              ABSa2c:                 MACRO
 56+  0000 ~                                    bit     7,a
 57+  0000 ~                                    jp      z,.DoneABSa
 58+  0000 ~                                    neg
 59+  0000 ~            .DoneABSa:
 60+  0000                                      ENDM
 61+  0000
 62+  0000              DEEquSquareA:           MACRO
 63+  0000 ~                                    ld  d,a
 64+  0000 ~                                    ld  e,a
 65+  0000 ~                                    mul de
 66+  0000                                      ENDM
 67+  0000
 68+  0000              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
 69+  0000 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
 70+  0000 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
 71+  0000 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
 72+  0000 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
 73+  0000 ~                                    xor $80                             ;
 74+  0000 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
 75+  0000 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
 76+  0000 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
 77+  0000 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
 78+  0000 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
 79+  0000 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
 80+  0000                                      ENDM
 81+  0000
 82+  0000              SignedHLTo2C:           MACRO
 83+  0000 ~                                    bit     7,h
 84+  0000 ~                                    jr      z,.Done2c
 85+  0000 ~                                    ld      a,h
 86+  0000 ~                                    and     SignMask8Bit
 87+  0000 ~                                    ld      h,a
 88+  0000 ~                                    NegHL
 89+  0000 ~            .Done2c:
 90+  0000                                      ENDM
 91+  0000
 92+  0000              MemSignedTo2C:          MACRO   memfrom
 93+  0000 ~                                    ld      hl,(memfrom)
 94+  0000 ~                                    bit     7,h
 95+  0000 ~                                    jr      z,.Done2c
 96+  0000 ~                                    ld      a,h
 97+  0000 ~                                    and     SignMask8Bit
 98+  0000 ~                                    ld      h,a
 99+  0000 ~            .Done2c:                ld      (memfrom),hl
100+  0000                                      ENDM
101+  0000
102+  0000
103+  0000                  ;returns result in H
104+  0000              EDiv10Inline:           MACRO
105+  0000 ~                                    ld      d,0
106+  0000 ~                                    ld      hl,de
107+  0000 ~                                    add     hl,hl
108+  0000 ~                                    add     hl,de
109+  0000 ~                                    add     hl,hl
110+  0000 ~                                    add     hl,hl
111+  0000 ~                                    add     hl,de
112+  0000 ~                                    add     hl,hl
113+  0000                                      ENDM
114+  0000
115+  0000              cpHLDE:                 MACRO
116+  0000 ~                                    push    hl
117+  0000 ~                                    and     a
118+  0000 ~                                    sbc     hl,de
119+  0000 ~                                    pop     hl
120+  0000                                      ENDM
121+  0000
122+  0000              cpABSDEHL:              MACRO
123+  0000 ~                                    push     hl,,de
124+  0000 ~                                    ld      a,h
125+  0000 ~                                    and     $7F
126+  0000 ~                                    ld      h,a
127+  0000 ~                                    ld      a,d
128+  0000 ~                                    and     $7F
129+  0000 ~                                    ld      d,a
130+  0000 ~                                    ex      de,hl
131+  0000 ~                                    sbc     hl,de
132+  0000 ~                                    pop     hl,,de
133+  0000                                      ENDM
134+  0000
135+  0000              ; Simple are they both the same setting z if they are
136+  0000              ; tehcicall this works but it measn the final ret z is alwys done
137+  0000              ; so jp needs to be to a target
138+  0000              cpHLEquDE:              MACRO   passedCheck
139+  0000 ~                                    ld      a,h
140+  0000 ~                                    cp      d
141+  0000 ~                                    jp      nz, passedCheck
142+  0000 ~                                    ld      a,l
143+  0000 ~                                    cp      e
144+  0000 ~            .NoTheSame:
145+  0000                                      ENDM
146+  0000
147+  0000              cpHLEquBC:              MACRO   passedCheck
148+  0000 ~                                    ld      a,h
149+  0000 ~                                    cp      b
150+  0000 ~                                    jp      nz, passedCheck
151+  0000 ~                                    ld      a,l
152+  0000 ~                                    cp      c
153+  0000 ~            .NoTheSame:
154+  0000                                      ENDM
155+  0000
156+  0000              cpDEEquBC:              MACRO   passedCheck
157+  0000 ~                                    ld      a,d
158+  0000 ~                                    cp      b
159+  0000 ~                                    jp      nz, passedCheck
160+  0000 ~                                    ld      a,e
161+  0000 ~                                    cp      c
162+  0000 ~            .NoTheSame:
163+  0000                                      ENDM
164+  0000              ; Simple version just sets carry if HL < DE reset, does an initial compare for z
165+  0000              cpHLDELeadSign:         MACRO
166+  0000 ~                                    ld      a,h
167+  0000 ~                                    cp      d
168+  0000 ~                                    jr      nz,.FullCompare
169+  0000 ~                                    ld      a,l
170+  0000 ~                                    cp      e
171+  0000 ~                                    ret     z
172+  0000 ~            .FullCompare:           ld      a,h
173+  0000 ~                                    xor     d
174+  0000 ~                                    and     $80
175+  0000 ~                                    jr      nz,.OppositeSigns   ; If opposite signs is a simple sign test
176+  0000 ~                                    ld      a,h                 ; same signs so a little simpler
177+  0000 ~                                    and     $80
178+  0000 ~                                    jp      z,cpHLDE            ; if h is positive then both are positive by here so just cpHLDE
179+  0000 ~                                    jp      cpABSDEHL           ; else we have to do ABScpDEHL
180+  0000 ~            .OppositeSigns:         ld      a,h
181+  0000 ~                                    and     $80
182+  0000 ~                                    and     $80
183+  0000 ~                                    jp      z,.HLGTDE
184+  0000 ~            .HLLTDE:                SetCarryFlag
185+  0000 ~                                    ret
186+  0000 ~            .HLGTDE:                ClearCarryFlag
187+  0000 ~                                    ret
188+  0000                                      ENDM
189+  0000
190+  0000              ;Unsigned
191+  0000              ;If HL == DE, then Z flag is set.
192+  0000              ;If HL != DE, then Z flag is reset.
193+  0000              ;If HL <  DE, then C flag is set.
194+  0000              ;If HL >= DE, then C flag is reset.
195+  0000              ;
196+  0000              ;Signed
197+  0000              ;If HL == DE, then Z flag is set.
198+  0000              ;If HL != DE, then Z flag is reset.
199+  0000              ;If HL <  DE, then S and P/V are different.
200+  0000              ;If HL >= DE, then S and P/V are the same.
201+  0000
202+  0000
203+  0000              N0equN1byN2div256:      MACRO param1,param2,param3
204+  0000 ~                                    ld      a,param3                        ;
205+  0000 ~                                    ld      e,a                         ; use e as var Q = value of XX15 [n] lo
206+  0000 ~                                    ld      a,param2                        ; A = XX16 element
207+  0000 ~                                    ld      d,a
208+  0000 ~                                    mul
209+  0000 ~                                    ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
210+  0000 ~                                    ld      (param1),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
211+  0000                                      ENDM
212+  0000
213+  0000              AequN1xorN2:            MACRO  param1,param2
214+  0000 ~                                    ld      a,(param1)
215+  0000 ~                                    xor     param2
216+  0000                                      ENDM
217+  0000
218+  0000              SpeedMulAxis:           MACRO   speedreg, axis
219+  0000 ~                                    ld      e,speedreg
220+  0000 ~                                    ld      hl,(axis)
221+  0000 ~                                    ld      a,h
222+  0000 ~                                    ClearSignBitA
223+  0000 ~                                    ld      d,a
224+  0000 ~                                    mul     de
225+  0000 ~                                    ld      a,h
226+  0000 ~                                    SignBitOnlyA
227+  0000 ~                                    ld      b,a;ld      c,a
228+  0000 ~                                    ld      h,d;ld      e,d
229+  0000 ~                                    ld      c,0;ld      d,0
230+  0000                                      ENDM
231+  0000
232+  0000              ; Adds speed (8 bit) to vertex (24 bit signed)
233+  0000              AddSpeedToVert:         MACRO   vertex
234+  0000 ~                                    ld      de,(vertex+1)
235+  0000 ~                                    ld      a,(vertex)
236+  0000 ~                                    ld      l,a
237+  0000 ~                                    call    AddBCHtoDELsigned               ; DEL = DEL + BCH
238+  0000 ~                                    ld      a,l
239+  0000 ~                                    ld      (vertex),a
240+  0000 ~                                    ld      (vertex+1),de
241+  0000                                      ENDM
# file closed: MathsMacros.asm
 64   0000                                      INCLUDE "../../Macros/ShiftMacros.asm"
# file opened: ShiftMacros.asm
  1+  0000              ShiftIYRight1: MACRO
  2+  0000 ~                           ld   a,iyh
  3+  0000 ~                           srl  a
  4+  0000 ~                           ld   iyh,a
  5+  0000 ~                           ld   a,iyl
  6+  0000 ~                           rra
  7+  0000 ~                           ld   iyl,a
  8+  0000                             ENDM
  9+  0000
 10+  0000              ShiftIXRight1: MACRO
 11+  0000 ~                           ld   a,ixh
 12+  0000 ~                           srl  a
 13+  0000 ~                           ld   ixh,a
 14+  0000 ~                           ld   a,ixl
 15+  0000 ~                           rra
 16+  0000 ~                           ld   ixl,a
 17+  0000                             ENDM
 18+  0000
 19+  0000              ShiftIXhHLRight1: MACRO
 20+  0000 ~                           ld  a,ixh
 21+  0000 ~                           srl a
 22+  0000 ~                           ld  ixh,a
 23+  0000 ~                           rr  h
 24+  0000 ~                           rr  l
 25+  0000                             ENDM
 26+  0000
 27+  0000              ShiftIYhDERight1: MACRO
 28+  0000 ~                           ld  a,iyh
 29+  0000 ~                           srl a
 30+  0000 ~                           ld  iyh,a
 31+  0000 ~                           rr  d
 32+  0000 ~                           rr  e
 33+  0000                             ENDM
 34+  0000
 35+  0000              ShiftIYlBCRight1: MACRO
 36+  0000 ~                           ld  a,iyl
 37+  0000 ~                           srl a
 38+  0000 ~                           ld  iyl,a
 39+  0000 ~                           rr  b
 40+  0000 ~                           rr  c
 41+  0000                             ENDM
 42+  0000
 43+  0000              ShiftIXlBCRight1: MACRO
 44+  0000 ~                           ld  a,ixl
 45+  0000 ~                           srl a
 46+  0000 ~                           ld  ixl,a
 47+  0000 ~                           rr  b
 48+  0000 ~                           rr  c
 49+  0000                             ENDM
 50+  0000
 51+  0000              ShiftHLRight1: MACRO
 52+  0000 ~                           srl h
 53+  0000 ~                           rr  l
 54+  0000                             ENDM
 55+  0000
 56+  0000              ShiftBHLRight1:MACRO
 57+  0000 ~                           srl b
 58+  0000 ~                           rr h
 59+  0000 ~                           rr  l
 60+  0000                             ENDM
 61+  0000
 62+  0000              ShiftCDERight1:MACRO
 63+  0000 ~                           srl c
 64+  0000 ~                           rr  d
 65+  0000 ~                           rr  e
 66+  0000                             ENDM
 67+  0000
 68+  0000
 69+  0000              SRAHLRight1: MACRO
 70+  0000 ~                           sra h
 71+  0000 ~                           rr  l
 72+  0000                             ENDM
 73+  0000
 74+  0000              ShiftDERight1: MACRO
 75+  0000 ~                           srl d
 76+  0000 ~                           rr  e
 77+  0000                             ENDM
 78+  0000
 79+  0000              ShiftBCRight1: MACRO
 80+  0000 ~                           srl b
 81+  0000 ~                           rr  c
 82+  0000                             ENDM
 83+  0000
 84+  0000
 85+  0000              ShiftHLDiv8:   MACRO
 86+  0000 ~                           srl h
 87+  0000 ~                           rr  l
 88+  0000 ~                           srl h
 89+  0000 ~                           rr  l
 90+  0000 ~                           srl h
 91+  0000 ~                           rr  l
 92+  0000                             ENDM
 93+  0000
 94+  0000              ShiftBHLLeft1:  MACRO
 95+  0000 ~                            sla l
 96+  0000 ~                            rl  h
 97+  0000 ~                            rl  b
 98+  0000                              ENDM
 99+  0000
100+  0000              ShiftCDELeft1:  MACRO
101+  0000 ~                            sla e
102+  0000 ~                            rl  d
103+  0000 ~                            rl  c
104+  0000                              ENDM
105+  0000
106+  0000              ShiftHLLeft1:  MACRO    ; 16 T states
107+  0000 ~                           sla l
108+  0000 ~                           rl  h
109+  0000                             ENDM
110+  0000
111+  0000              ShiftDELeft1:  MACRO    ; 16 T states
112+  0000 ~                           sla e
113+  0000 ~                           rl  d
114+  0000                             ENDM
115+  0000
116+  0000              BarrelHLLeft3: MACRO
117+  0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
118+  0000 ~                           push     bc      ; 10
119+  0000 ~                           ld       b,3     ; 7
120+  0000 ~                           bsrl     de,b    ; 8
121+  0000 ~                           pop      bc      ; 10
122+  0000 ~                           ex       de,hl   ; 4
123+  0000                             ENDM
124+  0000
125+  0000              BarrelHLRight3: MACRO
126+  0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
127+  0000 ~                           push     bc      ; 10
128+  0000 ~                           ld       b,3     ; 7
129+  0000 ~                           bsrl     de,b    ; 8
130+  0000 ~                           pop      bc      ; 10
131+  0000 ~                           ex       de,hl   ; 4
132+  0000                             ENDM
133+  0000
134+  0000              RollBCLeft1:   MACRO    ; 16 T states
135+  0000 ~                           rl  c
136+  0000 ~                           rl  b
137+  0000                             ENDM
138+  0000
139+  0000              RollDELeft1:   MACRO    ; 16 T states
140+  0000 ~                           rl  e
141+  0000 ~                           rl  d
142+  0000                             ENDM
143+  0000
144+  0000              ShiftBCLeft1:  MACRO    ; 16 T states
145+  0000 ~                           sla c
146+  0000 ~                           rl  b
147+  0000                             ENDM
148+  0000
149+  0000              ShiftLeftMem:       MACRO   reg
150+  0000 ~                                ld      hl,reg
151+  0000 ~                                sla     (hl)
152+  0000                                  ENDM
153+  0000
154+  0000
155+  0000
156+  0000              ShiftMem16Right1:   MACRO memaddr
157+  0000 ~                                ld    hl,(memaddr)
158+  0000 ~                                srl   h
159+  0000 ~                                rr    l
160+  0000 ~                                ld    (memaddr),hl
161+  0000                                  ENDM
162+  0000
163+  0000              ShiftMem8Right1:    MACRO memaddr
164+  0000 ~                                ld      a,(memaddr)
165+  0000 ~                                srl     a
166+  0000 ~                                ld      (memaddr),a
167+  0000                                  ENDM
168+  0000
169+  0000
170+  0000              ShiftMem8Left1A:    MACRO memaddr
171+  0000 ~                                ld      a,(memaddr)
172+  0000 ~                                sla     a
173+  0000 ~                                ld      (memaddr),a
174+  0000                                  ENDM
175+  0000
# file closed: ShiftMacros.asm
 65   0000                                      INCLUDE "../../Macros/NegateMacros.asm"
# file opened: NegateMacros.asm
  1+  0000
  2+  0000              macronegate16hl:	MACRO
  3+  0000 ~            					xor 	a
  4+  0000 ~            					sub 	l
  5+  0000 ~            					ld 		l,a
  6+  0000 ~            					sbc 	a,a
  7+  0000 ~            					sub 	h
  8+  0000 ~            					ld 		h,a
  9+  0000              					ENDM
 10+  0000
 11+  0000
 12+  0000              macroAbsHL:         MACRO
 13+  0000 ~                                bit     7,h
 14+  0000 ~                                jp      z,.alreadyABS
 15+  0000 ~            					xor 	a
 16+  0000 ~            					sub 	l
 17+  0000 ~            					ld 		l,a
 18+  0000 ~            					sbc 	a,a
 19+  0000 ~            					sub 	h
 20+  0000 ~            					ld 		h,a
 21+  0000 ~            .alreadyABS:
 22+  0000                                  ENDM
 23+  0000
 24+  0000              macronegate16de:	MACRO
 25+  0000 ~            					xor 	a
 26+  0000 ~                                sub 	e
 27+  0000 ~                                ld 		e,a
 28+  0000 ~                                sbc 	a,a
 29+  0000 ~                                sub 	d
 30+  0000 ~                                ld 		d,a
 31+  0000              					ENDM
 32+  0000
 33+  0000              macronegate16bc:	MACRO
 34+  0000 ~            					xor 	a
 35+  0000 ~                                sub 	c
 36+  0000 ~                                ld 		c,a
 37+  0000 ~                                sbc 	a,a
 38+  0000 ~                                sub 	b
 39+  0000 ~                                ld 		b,a
 40+  0000              					ENDM
 41+  0000
 42+  0000              macronegate16ix:	MACRO
 43+  0000 ~            					xor 	a
 44+  0000 ~                                sub 	ixl
 45+  0000 ~                                ld 		ixl,a
 46+  0000 ~                                sbc 	a,a
 47+  0000 ~                                sub 	ixh
 48+  0000 ~                                ld 		ixh,a
 49+  0000              					ENDM
 50+  0000
 51+  0000
 52+  0000              NegIY:			    MACRO
 53+  0000 ~                                xor a
 54+  0000 ~                                sub iyl
 55+  0000 ~                                ld iyl,a
 56+  0000 ~                                sbc a,a
 57+  0000 ~                                sub iyh
 58+  0000 ~                                ld iyh,a
 59+  0000                                  ENDM
 60+  0000
 61+  0000              NegHL:			    MACRO
 62+  0000 ~                                xor     a
 63+  0000 ~                                sub     l
 64+  0000 ~                                ld      l,a
 65+  0000 ~                                sbc     a,a
 66+  0000 ~                                sub     h
 67+  0000 ~                                ld      h,a
 68+  0000                                  ENDM
 69+  0000
 70+  0000              NegAHL:			    MACRO
 71+  0000 ~                                ld      b,a         ; save a in b
 72+  0000 ~                                xor     a           ; l = 0 - l
 73+  0000 ~                                sub     l
 74+  0000 ~                                ld      l,a
 75+  0000 ~                                sbc     a,a         ; h = 0 - h
 76+  0000 ~                                sub     h
 77+  0000 ~                                ld      h,a
 78+  0000 ~                                sbc     a,a         ; a= 0 - b
 79+  0000 ~                                sub     b
 80+  0000                                  ENDM
 81+  0000
 82+  0000              NegDE:			    MACRO
 83+  0000 ~                                xor a
 84+  0000 ~                                sub e
 85+  0000 ~                                ld e,a
 86+  0000 ~                                sbc a,a
 87+  0000 ~                                sub d
 88+  0000 ~                                ld d,a
 89+  0000                                  ENDM
 90+  0000
 91+  0000              NegBC:			    MACRO
 92+  0000 ~                                xor a
 93+  0000 ~                                sub c
 94+  0000 ~                                ld c,a
 95+  0000 ~                                sbc a,a
 96+  0000 ~                                sub  b
 97+  0000 ~                                ld b,a
 98+  0000                                  ENDM
 99+  0000
100+  0000              NegH                MACRO
101+  0000 ~                                ld      a,h
102+  0000 ~                                neg
103+  0000 ~                                ld      h,a
104+  0000                                  ENDM
105+  0000
106+  0000              NegD                MACRO
107+  0000 ~                                ld      a,d
108+  0000 ~                                neg
109+  0000 ~                                ld      d,a
110+  0000                                  ENDM
111+  0000
112+  0000              NegB                MACRO
113+  0000 ~                                ld      a,b
114+  0000 ~                                neg
115+  0000 ~                                ld      b,a
116+  0000                                  ENDM
117+  0000
# file closed: NegateMacros.asm
 66   0000                                      INCLUDE "../../Macros/carryFlagMacros.asm"
# file opened: carryFlagMacros.asm
  1+  0000
  2+  0000              SetCarryFlag:           MACRO
  3+  0000 ~                                    scf
  4+  0000                                      ENDM
  5+  0000
  6+  0000              ClearCarryFlag:	        MACRO
  7+  0000 ~                                    or a
  8+  0000                                      ENDM
  9+  0000
 10+  0000              FlipCarryFlag:          MACRO
 11+  0000 ~                                    ccf
 12+  0000                                      ENDM
 13+  0000
# file closed: carryFlagMacros.asm
 67   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 68   0000              ; Total screen list
 69   0000              ; Local Chart
 70   0000              ; Galactic Chart
 71   0000              ; Market Prices
 72   0000              ; Inventory
 73   0000              ; Comander status
 74   0000              ; System Data
 75   0000              ; Mission Briefing
 76   0000              ; missio completion
 77   0000              ; Docked  Menu (only place otehr than pause you can load and save)
 78   0000              ; Pause Menu (only place you can load from )
 79   0000              ; byint and selling equipment
 80   0000              ; bying and selling stock
 81   0000
 82   0000              TopOfStack              equ $5CCB ;$6100
 83   0000
 84   0000                                      ORG $5DCB;      $6200
 85   5DCB F3           EliteNextStartup:       di
 86   5DCC FD 00                                break
 87   5DCE FD 21 ED 5D                          ld      iy,Test1
 88   5DD2 06 0B                                ld      b,11
 89   5DD4 FD E5 C5     .testloop:              push    iy,,bc
 90   5DD7 CD 9D 5E                             call    TestMult
 91   5DDA C1 FD E1                             pop     iy,,bc
 92   5DDD FD E5 E1                             ld      hl,iy
 93   5DE0 3E 10                                ld      a,$10
 94   5DE2 ED 31                                add     hl,a
 95   5DE4 E5 FD E1                             ld      iy,hl
 96   5DE7 10 EB                                djnz    .testloop
 97   5DE9 FD 00                                break
 98   5DEB
 99   5DEB 00 00        ErrorCount:             DW  0
100   5DED
101   5DED                                      ;  X............  Y............   Fill Expected (hlbc)...  Actual............  Pass/Fail
102   5DED                                      ;   0    1    2    3    4    5    6    7,   8,   9,   A,   B,   C,   D,   E,   F
103   5DED 00 FA C0 00  Test1:                   DB $00, $FA, $C0, $00, $4B, $00, $00, $49, $76, $40, $00, $00, $00, $00, $00, $11
103   5DF1 4B 00 00 49
103   5DF5 76 40 00 00
103   5DF9 00 00 00 11
104   5DFD 04 00 C0 00  Test2:                   DB $04, $00, $C0, $00, $00, $C0, $00, $03, $00, $90, $00, $00, $00, $00, $00, $11
104   5E01 00 C0 00 03
104   5E05 00 90 00 00
104   5E09 00 00 00 11
105   5E0D 00 FA B3 00  Test3:                   DB $00, $FA, $B3, $00, $4B, $00, $00, $49, $72, $80, $00, $00, $00, $00, $00, $11
105   5E11 4B 00 00 49
105   5E15 72 80 00 00
105   5E19 00 00 00 11
106   5E1D 00 4D 6E 00  Test4:                   DB $00, $4D, $6E, $00, $4D, $6E, $00, $17, $6B, $67, $00, $00, $00, $00, $00, $11
106   5E21 4D 6E 00 17
106   5E25 6B 67 00 00
106   5E29 00 00 00 11
107   5E2D 00 73 00 00  Test5:                   DB $00, $73, $00, $00, $D7, $00, $00, $60, $95, $00, $00, $00, $00, $00, $00, $11
107   5E31 D7 00 00 60
107   5E35 95 00 00 00
107   5E39 00 00 00 11
108   5E3D 0B 00 00 00  Test6:                   DB $0B, $00, $00, $00, $00, $C0, $00, $08, $40, $00, $00, $00, $00, $00, $00, $11
108   5E41 00 C0 00 08
108   5E45 40 00 00 00
108   5E49 00 00 00 11
109   5E4D 02 54 40 00  Test7:                   DB $02, $54, $40, $00, $0E, $80, $00, $21, $C5, $A0, $00, $00, $00, $00, $00, $11
109   5E51 0E 80 00 21
109   5E55 C5 A0 00 00
109   5E59 00 00 00 11
110   5E5D 00 00 C0 00  Test8:                   DB $00, $00, $C0, $00, $02, $00, $00, $00, $01, $80, $00, $00, $00, $00, $00, $11
110   5E61 02 00 00 00
110   5E65 01 80 00 00
110   5E69 00 00 00 11
111   5E6D 00 00 40 00  Test9:                   DB $00, $00, $40, $00, $02, $00, $00, $00, $00, $80, $00, $00, $00, $00, $00, $11
111   5E71 02 00 00 00
111   5E75 00 80 00 00
111   5E79 00 00 00 11
112   5E7D 05 06 80 00  TestA:                   DB $05, $06, $80, $00, $02, $00, $00, $0A, $0D, $00, $00, $00, $00, $00, $00, $11
112   5E81 02 00 00 0A
112   5E85 0D 00 00 00
112   5E89 00 00 00 11
113   5E8D 04 00 C0 00  TestB:                   DB $04, $00, $C0, $00, $00, $C0, $00, $03, $00, $90, $00, $00, $00, $00, $00, $11
113   5E91 00 C0 00 03
113   5E95 00 90 00 00
113   5E99 00 00 00 11
114   5E9D
115   5E9D                                      ;  Dividend.....  Divisor......                                                                             E H  L    B  C
116   5E9D
117   5E9D
118   5E9D FD 6E 00 FD  TestMult:               ld      hl,(iy+0)           ; bhl = X
118   5EA1 66 01
119   5EA3 FD 7E 02                             ld      a,(iy+2)            ; .
120   5EA6 47                                   ld      b,a                 ; .
121   5EA7 FD 5E 03 FD                          ld      de,(iy+3)           ; cde = Y
121   5EAB 56 04
122   5EAD FD 7E 05                             ld      a,(iy+5)            ;
123   5EB0 4F                                   ld      c,a                 ;
124   5EB1 CD EA 5E                             call    BCDEHLequBHLmulCDEs ; BCDEHL = result is BCDE.HL
125   5EB4 7C                                   ld      a,h                 ; save result but we only care about de.h
126   5EB5 FD 77 0B                             ld      (iy+$0B),a          ; .
127   5EB8 FD 73 0C FD                          ld      (iy+$0C),de         ; .
127   5EBC 72 0D
128   5EBE FD 7E 07     .CheckResult:           ld      a,(iy+$07)
129   5EC1 B9                                   cp      c
130   5EC2 C2 E0 5E                             jp      nz,.Fail
131   5EC5 FD 7E 08                             ld      a,(iy+$08)
132   5EC8 B8                                   cp      b
133   5EC9 C2 E0 5E                             jp      nz,.Fail
134   5ECC FD 7E 09                             ld      a,(iy+$09)
135   5ECF BD                                   cp      l
136   5ED0 C2 E0 5E                             jp      nz,.Fail
137   5ED3 FD 7E 0A                             ld      a,(iy+$0A)
138   5ED6 BC                                   cp      h
139   5ED7 C2 E0 5E                             jp      nz,.Fail
140   5EDA 3E FF                                ld      a,$FF
141   5EDC FD 77 0F                             ld      (iy+$0F),a
142   5EDF C9                                   ret
143   5EE0 3E 00        .Fail:                  ld      a,$00
144   5EE2 FD 77 0F                             ld      (iy+$0F),a
145   5EE5 21 EB 5D                             ld      hl,ErrorCount
146   5EE8 34                                   inc     (hl)
147   5EE9 C9                                   ret
148   5EEA
149   5EEA              ;--------------------------------------------------------------------------------------
150   5EEA                  INCLUDE	"../../Maths24/asm_multiply24.asm"
# file opened: asm_multiply24.asm
  1+  5EEA              ;   For divide
  2+  5EEA              ;   Split BHL/CDE into
  3+  5EEA              ;         BCDE.HL = HL/CD + BCDE.HL = BHL*1/E
  4+  5EEA              ;         ; for 24 bit divide
  5+  5EEA              ;         ; if both BC are non zero, to BH.0/CD.0
  6+  5EEA              ;         ; if CD = 0 do BH.L/00.L
  7+  5EEA              ;         ; if B = 0 & C != 0 then result is B*256/C >> 8
  8+  5EEA              ; Table B   H   L   C   D   E                                    HLD.E
  9+  5EEA              ;       !   !   !   !   !   !       BH.0/CD.0 (16/16) => HL/DE  =>00D.0
 10+  5EEA              ;       !   !   !   0   !   !       BH.0/D.0 (16/8)      BHL/DE =>0LD.0 (result << 8)
 11+  5EEA              ;       0   !   !   !   !   !       0
 12+  5EEA              ;       0   !   !   0   !   !       H.L/D.E (16 bit)  => HL/DE  =>00D.E (result >> 8)
 13+  5EEA              ;       0   !   !   0   0   !       H.L/0.E (16 bit)  => HL/DE  =>00D.E (result >> 8)
 14+  5EEA              ;       0   0   !   !   !   !       0
 15+  5EEA              ;       0   0   !   0   !   !       0
 16+  5EEA              ;       0   0   !   0   0   !       00.L/00.E
 17+  5EEA              ;       0   0   0   X   X   X       0
 18+  5EEA              ;       X   X   X   0   0   0       carry set
 19+  5EEA              ; Fixed  24 bit maths S48.16 = BDE * AHL where A=S BCDE=48 HL=16, used by other routines which drop unneeded bytes
 20+  5EEA              ;  X 2 1 0 Y 2 1 0
 21+  5EEA              ;    B H L   C D E
 22+  5EEA              ; 24 bit multiply
 23+  5EEA              ; start with lower and help with add sequence           ; all with carry flag (as lower case target reg)
 24+  5EEA              ;        L *     E   X0mulY0 1>> 1>>  shift >> 16       ;     HL = L * E
 25+  5EEA              ;        L *   D     Y1mulX0 0   1>>  shift >> 8        ;   DEHL = 00HL  + 0[L*D]0
 26+  5EEA              ;      H   *     E   X1mulY0 0   1>>  shift >> 8        ;   DEHL = DEHL  + 0[H*E]0 = DEH + 0[H*E]
 27+  5EEA              ;    B     *     E   X2mulY0 1<< 1>>  shift 0           ;  CDE   = 0DE   + 0[B*E]
 28+  5EEA              ;        L * C       Y2mulX0 1<< 1>>  shift 0           ;  CDE   = CDE   + 0[L*C]
 29+  5EEA              ;      H   *   D     X1mulY1 0   0    shift 0           ;  CDE   = CDE   + 0[H*D]
 30+  5EEA              ;    B     *   D     X2mulY1 1<< 0<<  shift << 8        ; BCD    = 0CD   + 0[B*D]
 31+  5EEA              ;      H   * C       Y2mulX1 1<< 0    shift << 8        ; BCD    = 0CD   + 0[H*C]
 32+  5EEA              ;    B     * C       X2mulY2 1<< 1<<  shift <<16        ; BC     = BC    + [B*C]
 33+  5EEA              ; 16 bit multiply
 34+  5EEA              ; start with lower and help with add sequence           ; all with carry flag (as lower case target reg)
 35+  5EEA              ;        L *     E   X0mulY0 1>> 1>>  shift >> 16       ;     HL = L * E
 36+  5EEA              ;        L *   D     Y1mulX0 0   1>>  shift >> 8        ;   DEHL = 00HL  + 0[L*D]0
 37+  5EEA              ;      H   *     E   X1mulY0 0   1>>  shift >> 8        ;   DEHL = DEHL  + 0[H*E]0 = DEH + 0[H*E]
 38+  5EEA              ;      H   *   D     X1mulY1 0   0    shift 0           ;  CDE   = CDE   + 0[H*D]
 39+  5EEA              ;                                                       ; Result BCDE.HL
 40+  5EEA
 41+  5EEA              ; most likley optimisation will be the value is 8.8 so we can quickly eliminate this
 42+  5EEA              ; then will be a 0.8 when we are doing things like docking so objects will be close and large
 43+  5EEA              ; 8.0 will be unlikley so we will just optimise on 78.8, 8.8, 0.8
 44+  5EEA              ; we can also optimise code size if only one side is 08.8 etc by swapping over BHL and CDE as needed
 45+  5EEA 78           BCDEHLequBHLmulCDEs:    ld      a,b
 46+  5EEB A9                                   xor     c
 47+  5EEC E6 80                                and     0x80
 48+  5EEE CB B8                                res     7,b                     ; clear sign bits
 49+  5EF0 CB B9                                res     7,c                     ; res does not affect flags
 50+  5EF2 CA FD 5E                             jp      z,BCDEHLequBHLmulCDEu   ; can just jp as is also sets A to 0 for sign
 51+  5EF5 CD FD 5E     .BCDEHLNegative:        call    BCDEHLequBHLmulCDEu     ; do unsigned maths
 52+  5EF8 3E 80                                ld      a,0x80                  ; set a = sign bit
 53+  5EFA CB F8                                set     7,b                     ; and set sign bit on b
 54+  5EFC C9                                   ret
 55+  5EFD
 56+  5EFD              BCDEHLequBHLmulCDEu:    ZeroA
 56+  5EFD AF          >                        xor a
 57+  5EFE B0                                   or      b
 58+  5EFF CA 0A 5F                             jp      z,.X2Zero               ; first pass check X2 = 0?
 59+  5F02              .X2checkY2:             ZeroA                           ; now check Y2 = 0?
 59+  5F02 AF          >                        xor a
 60+  5F03 B1                                   or      c
 61+  5F04 CA 84 5F                             jp      z,BCDEHLequ24mul24u     ;  fro nwo ignore optimsation X2 is non 0, Y2 is zero eliminating 3 mulitplies
 62+  5F07 C3 84 5F     .Do24BitMul:            jp      BCDEHLequ24mul24u       ; X2 and Y2 are non zero so in most cases it will be a regular 78.8 x 78.8 so just do 24 bit mul
 63+  5F0A B1           .X2Zero:                or      c
 64+  5F0B CA 11 5F                             jp      z,.checkFor8BitMul      ; X2 and Y2 are both 0 eliminating 5 multiplies with 8.8 now check for 0.8
 65+  5F0E C3 84 5F     .Do16Bitmul24Bit:       jp      BCDEHLequ24mul24u       ; for now ignore optimisation X2 is zero Y2 is non zero eliminating 3 muliplies
 66+  5F11 B4           .checkFor8BitMul:       or      h
 67+  5F12 C2 19 5F     .Do16BitMul:            jp      nz, BCHLDEequ16mul16u   ; X1 is non zero so we will assume Y1 is also non zero and do a 16 bit muliply
 68+  5F15 B2           .X2X1Zero:              or      d
 69+  5F16 CA 7A 5F     .Do8BitMul              jp      z, BCHLDEequ8mul8u      ; X1 and Y1 are both zero so its now just a simple mul de
 70+  5F19                                      ; else we fall into a 16 bit multiply
 71+  5F19              BCHLDEequ16mul16u:
 72+  5F19 7D           .PrepSelfModifying:     ld      a,l
 73+  5F1A 32 37 5F                             ld      (.Y1mulX0L+1),a         ; Y1mulX0 L (we can skip X0mulY0 as we will already have L)
 74+  5F1D 7A                                   ld      a,d
 75+  5F1E 32 35 5F                             ld      (.Y1mulX0D+1),a         ; Y1mulX0 D
 76+  5F21 32 69 5F                             ld      (.X1mulY1D+1),a         ; X1mulY1 D
 77+  5F24 7B                                   ld      a,e
 78+  5F25 32 4E 5F                             ld      (.X1mulY0E+1),a         ; X1mulY0 E (we can skip X0mulY0 as we will already have E)
 79+  5F28 78                                   ld      a,b
 80+  5F29 7C                                   ld      a,h
 81+  5F2A 32 4C 5F                             ld      (.X1mulY0+1),a          ; X1mulY0 H
 82+  5F2D 32 67 5F                             ld      (.X1mulY1H+1),a         ; X1mulY1 H
 83+  5F30                                      ; now we don't have to worry about setting up multiplies, just the adds and result
 84+  5F30                                      ; we can freely use AF, BC, HL, IX, IY and alternate registers
 85+  5F30              .X0mulY0
 85+  5F30 55                          ld      d,l                     ; HL = L * E
 86+  5F31 ED 30                                mul     de                      ; .
 87+  5F33 EB                                   ex      de,hl                   ; .
 88+  5F34              .Y1mulX0:                                               ; [L*D]
 89+  5F34 16 00        .Y1mulX0D:              ld      d,0x00
 90+  5F36 1E 00        .Y1mulX0L:              ld      e,0x00                  ; DE = L * D
 91+  5F38 ED 30                                mul     de                      ;
 92+  5F3A                                      ; DEHL = 00HL  + 0[L*D]0        ; as 0FF+FF0 is a 3 byte result + carry bit
 93+  5F3A EB           .AHLequ0HLaddDE0:       ex      de,hl                   ; AHL = [L*D][0], DE = [0][L*E]
 94+  5F3B                                      ZeroA                           ; A = 0 and clear carry Flag
 94+  5F3B AF          >                        xor a
 95+  5F3C 7C                                   ld      a,h                     ; .
 96+  5F3D 65                                   ld      h,l                     ; .
 97+  5F3E 2E 00                                ld      l,0                     ; .
 98+  5F40 ED 5A                                adc     hl,de                   ; carryHL  = L0 + DE
 99+  5F42 CE 00                                adc     a,0                     ; <cary>A = H+carry so <carry>AHL = [L*D][0] + [0][L*E]
100+  5F44 5F                                   ld      e,a                     ; .
101+  5F45 3E 00                                ld      a,0                     ; .
102+  5F47 8F                                   adc     a,a                     ; . *as a is 0 we can do this and save 3 T states
103+  5F48 16 00                                ld      d,0                     ; now DEHL = [L*D][0] + [0][L*E]
104+  5F4A D9                                   exx                             ; now 'DEHL = [L*D][0] + [0][L*E]
105+  5F4B              .X1mulY0:               ; [H*E]
106+  5F4B 16 00        .X1mulY0H:              ld      d,0x00
107+  5F4D 1E 00        .X1mulY0E:              ld      e,0x00
108+  5F4F ED 30                                mul     de                      ; DE = [H * E]
109+  5F51                                      ;break
110+  5F51                                      ; DEHL = DEHL + 0[H*E]0 = DEH + 0[H*E] or  <carry>HL += E0 <carry?> DE += 0H + carry
111+  5F51 D5                                   push    de                      ; Stack + 1
112+  5F52 D9                                   exx                             ; DEHL = previous [0][L*D][0] + [00][L*E]
113+  5F53 C1                                   pop     bc                      ; Stack + 0
114+  5F54                                      ClearCarryFlag                  ; 'DEHL = DEHL + [00]BC (or [0][H*E][0]
114+  5F54 B7          >                        or a
115+  5F55 78                                   ld      a,b                     ; copy b as we need it again
116+  5F56 41                                   ld      b,c                     ; now bc = E[0] from calc above
117+  5F57 0E 00                                ld      c,0                     ; .
118+  5F59 ED 4A                                adc     hl,bc                   ; HL += E[0] from calc above
119+  5F5B 06 00                                ld      b,0                     ; bc = [0]D from calc above
120+  5F5D 4F                                   ld      c,a                     ;
121+  5F5E EB                                   ex      de,hl                   ; get de into HL for add
122+  5F5F ED 4A                                adc     hl,bc                   ;
123+  5F61 EB                                   ex      de,hl                   ; get DEHL back into correct order
124+  5F62 01 00 00                             ld      bc,0                    ; as we don't have X2Y2 we just set BC to 0
125+  5F65 D9                                   exx                             ; now P3 P2 are loaded with working values, 'HL holds P1 P0 that are now fixed values
126+  5F66              .X1mulY1:               ; [H*D]
127+  5F66 16 00        .X1mulY1H:              ld      d,0x00                  ; X2mulY0 H
128+  5F68 1E 00        .X1mulY1D:              ld      e,0x00                  ; X2mulY0 E
129+  5F6A ED 30                                mul     de
130+  5F6C                                      ;  CDE   = CDE   + [H*D]
131+  5F6C D5                                   push    de                      ; Stack + 1 swap in results
132+  5F6D D9                                   exx                             ; BC = [H*D]
133+  5F6E C1                                   pop     bc                      ; Stack + 0
134+  5F6F EB                                   ex      de,hl                   ; DE = DE + [H*D]
135+  5F70                                      ZeroA                           ; A = 0 and clear carry Flag
135+  5F70 AF          >                        xor a
136+  5F71 ED 4A                                adc     hl,bc                   ; .
137+  5F73 EB                                   ex      de,hl                   ; get HL and DE back to correct positions (we may leave them like this later for optimisation but debug first)
138+  5F74 89                                   adc     a,c                     ; a += c + carry
139+  5F75 4F                                   ld      c,a                     ; so now we have 'CDE.HL as results
140+  5F76                                      ZeroA                           ; assume sign in A is positive
140+  5F76 AF          >                        xor a
141+  5F77 06 00                                ld      b,0                     ; and we need b to be 0
142+  5F79 C9                                   ret
143+  5F7A
144+  5F7A                                      ; 8 bit multiply
145+  5F7A 55           BCHLDEequ8mul8u:        ld      d,l                     ; so now BCHLDE = 00L * 00D
146+  5F7B ED 30                                mul     de                      ; so we just do L*D which loads de
147+  5F7D EB                                   ex      de,hl
148+  5F7E                                      ZeroA                           ; and set BCHL to 0
148+  5F7E AF          >                        xor a
149+  5F7F 47                                   ld      b,a
150+  5F80 4F                                   ld      c,a
151+  5F81 57                                   ld      d,a
152+  5F82 5F                                   ld      e,a
153+  5F83 C9                                   ret
154+  5F84
155+  5F84              BCDEHLequ24mul24u:
156+  5F84 7D           .PrepSelfModifying:     ld      a,l
157+  5F85 32 C1 5F                             ld      (.Y1mulX0L+1),a         ; Y1mulX0 L (we can skip X0mulY0 as we will already have L)
158+  5F88 32 01 60                             ld      (.Y2mulX0L+1),a         ; Y2mulX0 L
159+  5F8B 7A                                   ld      a,d
160+  5F8C 32 BF 5F                             ld      (.Y1mulX0D+1),a         ; Y1mulX0 D
161+  5F8F 32 12 60                             ld      (.X1mulY1D+1),a         ; X1mulY1 D
162+  5F92 32 23 60                             ld      (.X2mulY1D+1),a         ; X2mulY1 D
163+  5F95 7B                                   ld      a,e
164+  5F96 32 D8 5F                             ld      (.X1mulY0E+1),a         ; X1mulY0 E (we can skip X0mulY0 as we will already have E)
165+  5F99 32 F0 5F                             ld      (.X2mulY0E+1),a         ; X2mulY0 E
166+  5F9C 78                                   ld      a,b
167+  5F9D 32 EE 5F                             ld      (.X2mulY0B+1),a         ; X2mulY0 B
168+  5FA0 32 21 60                             ld      (.X2mulY1B+1),a         ; X2mulY1 B
169+  5FA3 32 4B 60                             ld      (.X2mulY2B+1),a         ; X2mulY2 B
170+  5FA6 7C                                   ld      a,h
171+  5FA7 32 D6 5F                             ld      (.X1mulY0+1),a          ; X1mulY0 H
172+  5FAA 32 39 60                             ld      (.Y2mulX1H+1),a         ; Y2mulX1 H
173+  5FAD 32 10 60                             ld      (.X1mulY1H+1),a         ; X1mulY1 H
174+  5FB0 79                                   ld      a,c
175+  5FB1 32 FF 5F                             ld      (.Y2mulX0C+1),a         ; Y2mulX0 C
176+  5FB4 32 37 60                             ld      (.Y2mulX1C+1),a         ; Y2mulX1 C
177+  5FB7 32 4D 60                             ld      (.X2mulY2C+1),a         ; X2mulY2 C
178+  5FBA                                      ; now we don't have to worry about setting up multiplies, just the adds and result
179+  5FBA                                      ; we can freely use AF, BC, HL, IX, IY and alternate registers
180+  5FBA              .X0mulY0
180+  5FBA 55                          ld      d,l                     ; HL = L * E
181+  5FBB ED 30                                mul     de                      ; .
182+  5FBD EB                                   ex      de,hl                   ; .
183+  5FBE              .Y1mulX0:                                               ; [L*D]
184+  5FBE 16 00        .Y1mulX0D:              ld      d,0x00
185+  5FC0 1E 00        .Y1mulX0L:              ld      e,0x00                  ; DE = L * D
186+  5FC2 ED 30                                mul     de                      ;
187+  5FC4                                      ; DEHL = 00HL  + 0[L*D]0        ; as 0FF+FF0 is a 3 byte result + carry bit
188+  5FC4 EB           .AHLequ0HLaddDE0:       ex      de,hl                   ; AHL = [L*D][0], DE = [0][L*E]
189+  5FC5                                      ZeroA                           ; A = 0 and clear carry Flag
189+  5FC5 AF          >                        xor a
190+  5FC6 7C                                   ld      a,h                     ; .
191+  5FC7 65                                   ld      h,l                     ; .
192+  5FC8 2E 00                                ld      l,0                     ; .
193+  5FCA ED 5A                                adc     hl,de                   ; carryHL  = L0 + DE
194+  5FCC CE 00                                adc     a,0                     ; <cary>A = H+carry so <carry>AHL = [L*D][0] + [0][L*E]
195+  5FCE 5F                                   ld      e,a                     ; .
196+  5FCF 3E 00                                ld      a,0                     ; .
197+  5FD1 8F                                   adc     a,a                     ; . *as a is 0 we can do this and save 3 T states
198+  5FD2 16 00                                ld      d,0                     ; now DEHL = [L*D][0] + [0][L*E]
199+  5FD4 D9                                   exx                             ; now 'DEHL = [L*D][0] + [0][L*E]
200+  5FD5              .X1mulY0:               ; [H*E]
201+  5FD5 16 00        .X1mulY0H:              ld      d,0x00
202+  5FD7 1E 00        .X1mulY0E:              ld      e,0x00
203+  5FD9 ED 30                                mul     de                      ; DE = [H * E]
204+  5FDB                                      ;break
205+  5FDB                                      ; DEHL = DEHL + 0[H*E]0 = DEH + 0[H*E] or  <carry>HL += E0 <carry?> DE += 0H + carry
206+  5FDB D5                                   push    de                      ; Stack + 1
207+  5FDC D9                                   exx                             ; DEHL = previous [0][L*D][0] + [00][L*E]
208+  5FDD C1                                   pop     bc                      ; Stack + 0
209+  5FDE                                      ClearCarryFlag                  ; 'DEHL = DEHL + [00]BC (or [0][H*E][0]
209+  5FDE B7          >                        or a
210+  5FDF 78                                   ld      a,b                     ; copy b as we need it again
211+  5FE0 41                                   ld      b,c                     ; now bc = E[0] from calc above
212+  5FE1 0E 00                                ld      c,0                     ; .
213+  5FE3 ED 4A                                adc     hl,bc                   ; HL += E[0] from calc above
214+  5FE5 06 00                                ld      b,0                     ; bc = [0]D from calc above
215+  5FE7 4F                                   ld      c,a                     ;
216+  5FE8 EB                                   ex      de,hl                   ; get de into HL for add
217+  5FE9 ED 4A                                adc     hl,bc                   ;
218+  5FEB EB                                   ex      de,hl                   ; get DEHL back into correct order
219+  5FEC D9                                   exx                             ; now P3 P2 are loaded with working values, 'HL holds P1 P0 that are now fixed values
220+  5FED              .X2mulY0                ; [B*E]
221+  5FED 16 00        .X2mulY0B:              ld      d,0x00                  ; X2mulY0 B
222+  5FEF 1E 00        .X2mulY0E:              ld      e,0x00                  ; X2mulY0 E
223+  5FF1 ED 30                                mul     de
224+  5FF3                                      ;  CDE   = DE   + [B*E]
225+  5FF3 D5                                   push    de                      ; swap in results Stack + 1
226+  5FF4 D9                                   exx                             ; BC = [B*E]
227+  5FF5 C1                                   pop     bc                      ; Stack + 0
228+  5FF6 EB                                   ex      de,hl                   ; DE = DE + [B*E]
229+  5FF7                                      ZeroA                           ; A = 0 and clear carry Flag
229+  5FF7 AF          >                        xor a
230+  5FF8 ED 4A                                adc     hl,bc                   ; .
231+  5FFA EB                                   ex      de,hl                   ; get HL and DE back to correct positions (we may leave them like this later for optimisation but debug first)
232+  5FFB 8F                                   adc     a,a                     ; a += 0 + carry
233+  5FFC 4F                                   ld      c,a                     ; so now we have 'CDE.HL as results
234+  5FFD D9                                   exx                             ; .
235+  5FFE              .Y2mulX0:               ; [L*C]
236+  5FFE 16 00        .Y2mulX0C:              ld      d,0x00                  ; X2mulY0 C
237+  6000 1E 00        .Y2mulX0L:              ld      e,0x00                  ; X2mulY0 L
238+  6002 ED 30                                mul     de
239+  6004                                      ;  CDE   = CDE   + [L*C]
240+  6004 D5                                   push    de                      ; Stack + 1 swap in results
241+  6005 D9                                   exx                             ; BC = [L*C]
242+  6006 C1                                   pop     bc                      ; Stack + 0
243+  6007 EB                                   ex      de,hl                   ; DE = DE + [L*C]
244+  6008                                      ZeroA                           ; A = 0 and clear carry Flag
244+  6008 AF          >                        xor a
245+  6009 ED 4A                                adc     hl,bc                   ; .
246+  600B EB                                   ex      de,hl                   ; get HL and DE back to correct positions (we may leave them like this later for optimisation but debug first)
247+  600C 89                                   adc     a,c                     ; a += c + carry
248+  600D 4F                                   ld      c,a                     ; so now we have 'CDE.HL as results
249+  600E D9                                   exx                             ; .
250+  600F              .X1mulY1:               ; [H*D]
251+  600F 16 00        .X1mulY1H:              ld      d,0x00                  ; X2mulY0 H
252+  6011 1E 00        .X1mulY1D:              ld      e,0x00                  ; X2mulY0 E
253+  6013 ED 30                                mul     de
254+  6015                                      ;  CDE   = CDE   + [H*D]
255+  6015 D5                                   push    de                      ; Stack + 1 swap in results
256+  6016 D9                                   exx                             ; BC = [H*D]
257+  6017 C1                                   pop     bc                      ; Stack + 0
258+  6018 EB                                   ex      de,hl                   ; DE = DE + [H*D]
259+  6019                                      ZeroA                           ; A = 0 and clear carry Flag
259+  6019 AF          >                        xor a
260+  601A ED 4A                                adc     hl,bc                   ; .
261+  601C EB                                   ex      de,hl                   ; get HL and DE back to correct positions (we may leave them like this later for optimisation but debug first)
262+  601D 89                                   adc     a,c                     ; a += c + carry
263+  601E 4F                                   ld      c,a                     ; so now we have 'CDE.HL as results
264+  601F D9                                   exx                             ; .
265+  6020              .X2mulY1:               ; [B*D]
266+  6020 16 00        .X2mulY1B               ld      d,0x00                  ; X2mulY2 B
267+  6022 1E 00        .X2mulY1D:              ld      e,0x00                  ; X2mulY0 E
268+  6024 ED 30                                mul     de
269+  6026                                      ; BCD    = CD   + [B*D]         now is startes to get more tricky as we are spanning register pairs
270+  6026 D5                                   push    de                      ; Stack + 1 swap in results
271+  6027 D9                                   exx                             ; BC = [H*D]
272+  6028 E5 DD E1                             ld      ix,hl                   ; preserve HL during calculations
273+  602B 61                                   ld      h,c                     ;
274+  602C 6A                                   ld      l,d                     ;
275+  602D C1                                   pop     bc                      ;
276+  602E                                      ZeroA                           ; A = 0 and clear carry Flag
276+  602E AF          >                        xor a
277+  602F ED 4A                                adc     hl,bc                   ; .
278+  6031 4C                                   ld      c,h
279+  6032 55                                   ld      d,l
280+  6033 8F                                   adc     a,a                     ; a += c + carry
281+  6034 47                                   ld      b,a                     ; so now we have 'BCDE.HL as results
282+  6035 D9                                   exx                             ; .
283+  6036              .Y2mulX1:               ; [H*C]
284+  6036 16 00        .Y2mulX1C:              ld      d,0x00                  ; X2mulY0 E
285+  6038 1E 00        .Y2mulX1H:              ld      e,0x00                  ; X2mulY0 E
286+  603A ED 30                                mul     de
287+  603C                                      ; BCD    = CD   + [H*C]
288+  603C D5                                   push    de                      ; Stack + 1 swap in results
289+  603D D9                                   exx                             ; BC = [H*C]
290+  603E 61                                   ld      h,c
291+  603F 6A                                   ld      l,d
292+  6040 C1                                   pop     bc                      ; Stack + 0
293+  6041                                      ZeroA                           ; A = 0 and clear carry Flag
293+  6041 AF          >                        xor a
294+  6042 ED 4A                                adc     hl,bc                   ; .
295+  6044 4C                                   ld      c,h
296+  6045 55                                   ld      d,l
297+  6046 8F                                   adc     a,a                     ; a += c + carry
298+  6047 47                                   ld      b,a                     ; so now we have 'BCDE.HL as results
299+  6048 C5                                   push    bc                      ; get bc on stack for final add Stack + 1
300+  6049 D9                                   exx                             ; .
301+  604A              .X2mulY2:               ; [B*C]
302+  604A 16 00        .X2mulY2B               ld      d,0x00                  ; X2mulY2 B
303+  604C 1E 00        .X2mulY2C               ld      e,0x00                  ; X2mulY2 C
304+  604E ED 30                                mul     de
305+  6050                                      ; BC     = BC   + [B*C]
306+  6050 E1                                   pop     hl                      ; Get Saved BC into HL
307+  6051 19                                   add     hl,de                   ; hl = bc + [B*C]
308+  6052 E5                                   push    hl                      ; and save on stack to read into bc
309+  6053 D9                                   exx                             ; get back result
310+  6054 DD E5 E1                             ld      hl,ix                   ; restore hl we saved earlier
311+  6057 C1                                   pop     bc                      ; now we have 'BCDE.HL as final result
312+  6058                                      ZeroA                           ; assume sign in A is positive
312+  6058 AF          >                        xor a
313+  6059 C9                                   ret
314+  605A
# file closed: asm_multiply24.asm
151   605A
152   605A                  SAVENEX OPEN "m24test.nex", EliteNextStartup , TopOfStack
153   605A                  SAVENEX CFG  0,0,0,1
154   605A                  SAVENEX AUTO
155   605A                  SAVENEX CLOSE
156   605A
157   605A
# file closed: m24test.asm
