# file opened: m24test.asm
  1   0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
  2   0000                              DISPLAY "m24test test"
  3   0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
  4   0000
  5   0000
  6   0000                  DEFINE DEBUGMODE 1
  7   0000                  DEVICE ZXSPECTRUMNEXT
  8   0000                  SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
  9   0000                  ;DEFINE  TESTING_MATHS_DIVIDE 1
 10   0000               CSPECTMAP m24test.map
 11   0000               OPT --zxnext=cspect --syntax=a --reversepop
 12   0000                             DEFINE     MAIN_INTERRUPTENABLE 1
 13   0000              DEBUGSEGSIZE   equ 1
 14   0000              DEBUGLOGSUMMARY equ 1
 15   0000
 16   0000
 17   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 18   0000              ; Game Defines
 19   0000              ScreenLocal      EQU 0
 20   0000              ScreenGalactic   EQU ScreenLocal + 1
 21   0000              ScreenMarket     EQU ScreenGalactic + 1
 22   0000              ScreenMarketDsp  EQU ScreenMarket + 1
 23   0000              ScreenStatus     EQU ScreenMarketDsp + 1
 24   0000              ScreenInvent     EQU ScreenStatus + 1
 25   0000              ScreenPlanet     EQU ScreenInvent + 1
 26   0000              ScreenEquip      EQU ScreenPlanet + 1
 27   0000              ScreenLaunch     EQU ScreenEquip + 1
 28   0000              ScreenFront      EQU ScreenLaunch + 1
 29   0000              ScreenAft        EQU ScreenFront+1
 30   0000              ScreenLeft       EQU ScreenAft+1
 31   0000              ScreenRight      EQU ScreenLeft+1
 32   0000              ScreenDocking    EQU ScreenRight+1
 33   0000              ScreenHyperspace EQU ScreenDocking+1
 34   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 35   0000              ; Colour Defines
 36   0000              SignMask8Bit		equ %01111111
 37   0000              SignMask16Bit		equ %0111111111111111
 38   0000              SignOnly8Bit		equ $80
 39   0000              SignOnly16Bit		equ $8000
 40   0000
 41   0000              Bit7Only            equ %10000000
 42   0000              Bit6Only            equ %01000000
 43   0000              Bit5Only            equ %00100000
 44   0000              Bit4Only            equ %00010000
 45   0000              Bit3Only            equ %00001000
 46   0000              Bit2Only            equ %00000100
 47   0000              Bit1Only            equ %00000010
 48   0000              Bit0Only            equ %00000001
 49   0000              Bit7Clear           equ %01111111
 50   0000              Bit6Clear           equ %10111111
 51   0000              Bit5Clear           equ %11011111
 52   0000              Bit4Clear           equ %11101111
 53   0000              Bit3Clear           equ %11110111
 54   0000              Bit2Clear           equ %11111011
 55   0000              Bit1Clear           equ %11111101
 56   0000              Bit0Clear           equ %11111110
 57   0000              ConstPi				equ $80
 58   0000              ConstNorm           equ 197
 59   0000
 60   0000
 61   0000
 62   0000                                      INCLUDE "../../Macros/jumpMacros.asm"
# file opened: jumpMacros.asm
  1+  0000              JumpIfHLNegative:       MACRO target
  2+  0000 ~                                    bit     7,h
  3+  0000 ~                                    jp      nz,target
  4+  0000                                      ENDM
  5+  0000
  6+  0000              JumpIfPositive:	        MACRO target
  7+  0000 ~                                    jp		p, target
  8+  0000                                      ENDM
  9+  0000
 10+  0000              JumpIfNegative:	        MACRO target
 11+  0000 ~                                    jp		m, target
 12+  0000                                      ENDM
 13+  0000
 14+  0000
 15+  0000              JumpIfUnderflow:	    MACRO target
 16+  0000 ~                                    jp		po, target
 17+  0000                                      ENDM
 18+  0000
 19+  0000              JumpIfOverflow:	        MACRO target
 20+  0000 ~                                    jp		po, target
 21+  0000                                      ENDM
 22+  0000
 23+  0000
 24+  0000              JumpIfNotZero:	        MACRO target
 25+  0000 ~                                    jp	nz,target
 26+  0000                                      ENDM
 27+  0000
 28+  0000              JumpIfZero:	            MACRO target
 29+  0000 ~                                    jp	z,target
 30+  0000                                      ENDM
 31+  0000
 32+  0000              ;.. Bit routines
 33+  0000              JumpOnLeadSignSet:      MACRO   reg, target
 34+  0000 ~                                    ld      a,reg
 35+  0000 ~                                    and     SignOnly8Bit
 36+  0000 ~                                    jp      nz,target
 37+  0000                                      ENDM
 38+  0000
 39+  0000              JumpOnLeadSignClear:    MACRO   reg, target
 40+  0000 ~                                    ld      a,reg
 41+  0000 ~                                    and     SignOnly8Bit
 42+  0000 ~                                    jp      z,target
 43+  0000                                      ENDM
 44+  0000
 45+  0000              JumpOnLeadSignSetA:     MACRO   target
 46+  0000 ~                                    and     SignOnly8Bit
 47+  0000 ~                                    jp      nz,target
 48+  0000                                      ENDM
 49+  0000
 50+  0000              JumpOnLeadSignClearA:   MACRO   target
 51+  0000 ~                                    and     SignOnly8Bit
 52+  0000 ~                                    jp      z,target
 53+  0000                                      ENDM
 54+  0000
 55+  0000              JumpOnMemBitSet:        MACRO mem, bitnbr, target
 56+  0000 ~                                    ld      a,(mem)
 57+  0000 ~                                    bit 	bitnbr,a
 58+  0000 ~                                    jp      nz,target
 59+  0000                                      ENDM
 60+  0000
 61+  0000              JumpOnMemBitClear:      MACRO mem, bitnbr, target
 62+  0000 ~                                    ld      a,(mem)
 63+  0000 ~                                    bit 	bitnbr,a
 64+  0000 ~                                    jp      z,target
 65+  0000                                      ENDM
 66+  0000
 67+  0000
 68+  0000              JumpOnABitSet:          MACRO   bitnbr, target
 69+  0000 ~                                    bit 	bitnbr, a
 70+  0000 ~                                    jp      nz,target
 71+  0000                                      ENDM
 72+  0000
 73+  0000              JumpOnABitClear:        MACRO   bitnbr, target
 74+  0000 ~                                    bit 	bitnbr, a
 75+  0000 ~                                    jp      z,target
 76+  0000                                      ENDM
 77+  0000
 78+  0000              JumpOnABit5Set:         MACRO   target
 79+  0000 ~                                    and     Bit5Only
 80+  0000 ~                                    jp      nz,target
 81+  0000                                      ENDM
 82+  0000
 83+  0000              JumpOnABit5Clear:       MACRO   target
 84+  0000 ~                                    and     Bit5Only
 85+  0000 ~                                    jp      z,target
 86+  0000                                      ENDM
 87+  0000
 88+  0000              JumpOnBitMaskSet:       MACRO   bitmask, target
 89+  0000 ~                                    and     bitmask
 90+  0000 ~                                    jp      nz,target
 91+  0000                                      ENDM
 92+  0000
 93+  0000              JumpOnBitMaskClear:     MACRO   bitmask, target
 94+  0000 ~                                    and     bitmask
 95+  0000 ~                                    jp      z,target
 96+  0000                                      ENDM
 97+  0000
 98+  0000              JumpOnMemBitMaskSet:    MACRO   mem, bitmask, target
 99+  0000 ~                                    ld      a,(mem)
100+  0000 ~                                    and     bitmask
101+  0000 ~                                    jp      nz,target
102+  0000                                      ENDM
103+  0000
104+  0000              JumpOnMemBitMaskClear:  MACRO   mem, bitmask, target
105+  0000 ~                                    ld      a,(mem)
106+  0000 ~                                    and     bitmask
107+  0000 ~                                    jp      z,target
108+  0000                                      ENDM
109+  0000
110+  0000              JumpOnBitSet:           MACRO  reg, bitnbr, target
111+  0000 ~                                    bit 	bitnbr,reg
112+  0000 ~                                    jp      nz,target
113+  0000                                      ENDM
114+  0000
115+  0000              JumpOnBitClear:         MACRO  reg, bitnbr, target
116+  0000 ~                                    bit 	bitnbr,reg
117+  0000 ~                                    jp      z,target
118+  0000                                      ENDM
119+  0000
120+  0000              ; Comparison Routines
121+  0000              JumpIfAGTEusng:         MACRO
122+  0000 ~                                    jp		nc,target
123+  0000                                      ENDM
124+  0000
125+  0000              JumpIfAGTENusng:        MACRO reg,target
126+  0000 ~                                    cp     reg
127+  0000 ~                                    jp		nc,target
128+  0000                                      ENDM
129+  0000
130+  0000              JumpIfAGTEMemusng:      MACRO mem,target
131+  0000 ~                                    ld      hl,mem
132+  0000 ~                                    cp      (hl)
133+  0000 ~                                    jp		nc,target
134+  0000                                      ENDM
135+  0000              JumpIfMemGTENusng:      MACRO mem, value, target
136+  0000 ~                                    ld     a,(mem)
137+  0000 ~                                    cp     value
138+  0000 ~                                    jp	  nc,target
139+  0000                                      ENDM
140+  0000
141+  0000              JumpIfMemGTEMemusng:    MACRO mem, address, target
142+  0000 ~                                    ld   a,(mem)
143+  0000 ~                                    ld   hl,address
144+  0000 ~                                    cp   (hl)
145+  0000 ~                                    jp	  nc,target
146+  0000                                      ENDM
147+  0000
148+  0000              JumpIfMemEqMemusng:     MACRO mem, address, target
149+  0000 ~                                    ld   a,(mem)
150+  0000 ~                                    ld   hl,address
151+  0000 ~                                    cp   (hl)
152+  0000 ~                                    jp	  z,target
153+  0000                                      ENDM
154+  0000
155+  0000              JumpIfMemNeMemusng:     MACRO mem, address, target
156+  0000 ~                                    ld   a,(mem)
157+  0000 ~                                    ld   hl,address
158+  0000 ~                                    cp   (hl)
159+  0000 ~                                    jp	  nz,target
160+  0000                                      ENDM
161+  0000
162+  0000              JumpIfMemTrue:          MACRO mem, target
163+  0000 ~                                    ld      a,(mem)
164+  0000 ~                                    and     a
165+  0000 ~                                    jp      z, target
166+  0000                                      ENDM
167+  0000
168+  0000              JumpIfMemFalse:         MACRO mem, target
169+  0000 ~                                    ld      a,(mem)
170+  0000 ~                                    and     a
171+  0000 ~                                    jp      nz, target
172+  0000                                      ENDM
173+  0000
174+  0000              JumpIfATrue:            MACRO target
175+  0000 ~                                    and     a
176+  0000 ~                                    jp      z, target
177+  0000                                      ENDM
178+  0000
179+  0000              JumpIfAFalse:           MACRO target
180+  0000 ~                                    and     a
181+  0000 ~                                    jp      nz, target
182+  0000                                      ENDM
183+  0000
184+  0000              JumpIfANotFalse:        MACRO target
185+  0000 ~                                    cp      $FF
186+  0000 ~                                    jp      nz, target
187+  0000                                      ENDM
188+  0000
189+  0000              ;-- Less than Macros -------------------------------------------
190+  0000              JumpIfALTMemHLusng:     MACRO target
191+  0000 ~                                    cp    (hl)
192+  0000 ~                                    jp	  c,target
193+  0000                                      ENDM
194+  0000
195+  0000              JumpIfRegLTE:           MACRO   reg, value, target
196+  0000 ~                                    ld      a,reg
197+  0000 ~                                    cp      value
198+  0000 ~                                    jp	    z,target
199+  0000 ~                                    jp		c, target
200+  0000                                      ENDM
201+  0000
202+  0000              JumpIfALTMemusng:       MACRO mem,target
203+  0000 ~                                    ld      hl,mem
204+  0000 ~                                    cp      (hl)
205+  0000 ~                                    jp		c,target
206+  0000                                      ENDM
207+  0000
208+  0000
209+  0000              JumpIfALTusng:          MACRO target
210+  0000 ~                                    jp		c,target
211+  0000                                      ENDM
212+  0000
213+  0000              JumpIfALTNusng:         MACRO value, target
214+  0000 ~                                    cp      value
215+  0000 ~                                    jp		c, target
216+  0000                                      ENDM
217+  0000
218+  0000              JumpIfALTNsigned:       MACRO   value, target
219+  0000 ~                                    cp      value
220+  0000 ~                                    jp      m,.SignSet
221+  0000 ~            .SignClear:             jp      pe,target       ; Sign (0), P/V (1)
222+  0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (0)
223+  0000 ~            .SignSet:               jp      po,target
224+  0000 ~            .CheckComplete:
225+  0000                                      ENDM
226+  0000
227+  0000              JumpIfMemLTNusng:       MACRO mem, value, target
228+  0000 ~                                    ld      a,(mem)
229+  0000 ~                                    cp      value
230+  0000 ~                                    jp	  c,target
231+  0000                                      ENDM
232+  0000
233+  0000              JumpIfMemLTMemusng:     MACRO mem, value, target
234+  0000 ~                                    ld    a,(mem)
235+  0000 ~                                    ld    hl,value
236+  0000 ~                                    cp    (hl)
237+  0000 ~                                    jp	  c,target
238+  0000                                      ENDM
239+  0000              ;-- ------------------------------------------------------------
240+  0000              JumpIfAGTENsigned       MACRO   value, target
241+  0000 ~                                    cp      value
242+  0000 ~                                    jp      m,.SignSet
243+  0000 ~            .SignClear:             jp      po,target       ; Sign (0), P/V (0)
244+  0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (1)
245+  0000 ~            .SignSet:               jp      pe,target
246+  0000 ~            .CheckComplete:
247+  0000                                      ENDM
248+  0000
249+  0000              JumpIfMemEqNusng:       MACRO mem,value,target
250+  0000 ~                                    ld  a,(mem)
251+  0000 ~                                    cp  value
252+  0000 ~                                    jp  z,target
253+  0000                                      ENDM
254+  0000
255+  0000              JumpIfMemNeNusng:       MACRO mem,value,target
256+  0000 ~                                    ld  a,(mem)
257+  0000 ~                                    cp  value
258+  0000 ~                                    jp  nz,target
259+  0000                                      ENDM
260+  0000
261+  0000              JumpIfMemZero:          MACRO mem,target
262+  0000 ~                                    ld  a,(mem)
263+  0000 ~                                    and a
264+  0000 ~                                    jp  z,target
265+  0000                                      ENDM
266+  0000
267+  0000              JumpIfMemNotZero:       MACRO mem,target
268+  0000 ~                                    ld  a,(mem)
269+  0000 ~                                    and a
270+  0000 ~                                    jp  nz,target
271+  0000                                      ENDM
272+  0000
273+  0000              JumpIfANENusng:         MACRO value, target
274+  0000 ~                                    cp     value
275+  0000 ~                                    jp      nz,target
276+  0000                                      ENDM
277+  0000
278+  0000              JumpIfANEquNusng:       MACRO value, target
279+  0000 ~                                    cp     value
280+  0000 ~                                    jp     z,target
281+  0000                                      ENDM
282+  0000
283+  0000              JumpIfANEMemusng:       MACRO  value, target
284+  0000 ~                                    ld    hl,value
285+  0000 ~                                    cp    (hl)
286+  0000 ~                                    jp      nz,target
287+  0000                                      ENDM
288+  0000
289+  0000              JumpIfAEqNusng:         MACRO value, target
290+  0000 ~                                    cp     value
291+  0000 ~                                    jp      z,target
292+  0000                                      ENDM
293+  0000
294+  0000              JumpIfAIsZero:	        MACRO target
295+  0000 ~                                    and     a   ; cp 0 - changed to and a for optimisation but affects other flags
296+  0000 ~                                    jp	    z, target
297+  0000                                      ENDM
298+  0000
299+  0000              JumpIfRegIsNotZero:     MACRO   reg, target
300+  0000 ~                                    ld      a,reg
301+  0000 ~                                    and     a
302+  0000 ~                                    jp	    nz,target
303+  0000                                      ENDM
304+  0000
305+  0000
306+  0000              JumpIfAIsNotZero:       MACRO target
307+  0000 ~                                    and     a
308+  0000 ~                                    jp	    nz,target
309+  0000                                      ENDM
310+  0000
311+  0000              JumpIfMemIsNotZero:     MACRO value, target
312+  0000 ~                                    ld      a,(value)
313+  0000 ~                                    and     a
314+  0000 ~                                    jp	    nz,target
315+  0000                                      ENDM
316+  0000              IfResultZeroGoto:	    MACRO target
317+  0000 ~                                    jp	z,target
318+  0000                                      ENDM
319+  0000
320+  0000              IfResultNotZeroGoto:    MACRO target
321+  0000 ~                                    jp	nz,target
322+  0000                                      ENDM
323+  0000
# file closed: jumpMacros.asm
 63   0000                                      INCLUDE "../../Macros/MathsMacros.asm"
# file opened: MathsMacros.asm
  1+  0000              ZeroA:		            MACRO
  2+  0000 ~                                    xor a
  3+  0000                                      ENDM
  4+  0000              ; sets z flag is HL less than 255 else sets it to nz (note opposite of GT127)
  5+  0000              IsHLGT255:              MACRO
  6+  0000 ~                                    bit     7,h
  7+  0000 ~                                    ret     z
  8+  0000 ~                                    ld      a,h
  9+  0000 ~                                    and     a
 10+  0000                                      ENDM
 11+  0000
 12+  0000              ; Sets z flat if HL = 255 else sets it to nz
 13+  0000              IsHLEqu255:             MACRO
 14+  0000 ~                                    ld      a,h
 15+  0000 ~                                    and     a               ; if its non zero then it can't be 255
 16+  0000 ~                                    ret     nz
 17+  0000 ~                                    ld      a,l
 18+  0000 ~                                    inc     a               ; if it was 255 the inc will set it to zero
 19+  0000                                      ENDM
 20+  0000
 21+  0000              ; Sets Z flag if GT 127 else nz
 22+  0000              IsHLGT127:              MACRO
 23+  0000 ~                                    bit     7,h             ; -ve?
 24+  0000 ~                                    jr      nz,.DoneCheck
 25+  0000 ~                                    ld      a,h             ; +ve > 256?
 26+  0000 ~                                    and     a
 27+  0000 ~                                    jr      nz,.DoneCheck
 28+  0000 ~                                    ld      a,l
 29+  0000 ~                                    and     $80             ; this will set z to false if bit 7 set and clear lower bits
 30+  0000 ~                                    cp      $80             ; this will set z to true if bit 7 set
 31+  0000 ~            .DoneCheck:
 32+  0000                                      ENDM
 33+  0000
 34+  0000              ReturnIfHLGT127:        MACRO
 35+  0000 ~                                    bit     7,h             ; -ve?
 36+  0000 ~                                    jr      nz,.DoneCheck   ; forces check complete
 37+  0000 ~                                    ld      a,h             ; +ve > 256?
 38+  0000 ~                                    and     a               ;
 39+  0000 ~                                    ret     nz              ; forces a return
 40+  0000 ~                                    bit     7,l             ; bit 7 of lower set?
 41+  0000 ~                                    ret     nz              ; forces a return
 42+  0000 ~            .DoneCheck:
 43+  0000                                      ENDM
 44+  0000
 45+  0000              IsDEGT127:              MACRO
 46+  0000 ~                                    bit     7,d
 47+  0000 ~                                    jr      nz,.DoneCheck
 48+  0000 ~                                    ld      a,d
 49+  0000 ~                                    jr      nz,.DoneCheck
 50+  0000 ~                                    ld      a,e
 51+  0000 ~                                    and     $80
 52+  0000 ~            .DoneCheck:
 53+  0000                                      ENDM
 54+  0000
 55+  0000              ABSa2c:                 MACRO
 56+  0000 ~                                    bit     7,a
 57+  0000 ~                                    jp      z,.DoneABSa
 58+  0000 ~                                    neg
 59+  0000 ~            .DoneABSa:
 60+  0000                                      ENDM
 61+  0000
 62+  0000              DEEquSquareA:           MACRO
 63+  0000 ~                                    ld  d,a
 64+  0000 ~                                    ld  e,a
 65+  0000 ~                                    mul de
 66+  0000                                      ENDM
 67+  0000
 68+  0000              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
 69+  0000 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
 70+  0000 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
 71+  0000 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
 72+  0000 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
 73+  0000 ~                                    xor $80                             ;
 74+  0000 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
 75+  0000 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
 76+  0000 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
 77+  0000 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
 78+  0000 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
 79+  0000 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
 80+  0000                                      ENDM
 81+  0000
 82+  0000              SignedHLTo2C:           MACRO
 83+  0000 ~                                    bit     7,h
 84+  0000 ~                                    jr      z,.Done2c
 85+  0000 ~                                    ld      a,h
 86+  0000 ~                                    and     SignMask8Bit
 87+  0000 ~                                    ld      h,a
 88+  0000 ~                                    NegHL
 89+  0000 ~            .Done2c:
 90+  0000                                      ENDM
 91+  0000
 92+  0000              MemSignedTo2C:          MACRO   memfrom
 93+  0000 ~                                    ld      hl,(memfrom)
 94+  0000 ~                                    bit     7,h
 95+  0000 ~                                    jr      z,.Done2c
 96+  0000 ~                                    ld      a,h
 97+  0000 ~                                    and     SignMask8Bit
 98+  0000 ~                                    ld      h,a
 99+  0000 ~            .Done2c:                ld      (memfrom),hl
100+  0000                                      ENDM
101+  0000
102+  0000
103+  0000                  ;returns result in H
104+  0000              EDiv10Inline:           MACRO
105+  0000 ~                                    ld      d,0
106+  0000 ~                                    ld      hl,de
107+  0000 ~                                    add     hl,hl
108+  0000 ~                                    add     hl,de
109+  0000 ~                                    add     hl,hl
110+  0000 ~                                    add     hl,hl
111+  0000 ~                                    add     hl,de
112+  0000 ~                                    add     hl,hl
113+  0000                                      ENDM
114+  0000
115+  0000              cpHLDE:                 MACRO
116+  0000 ~                                    push    hl
117+  0000 ~                                    and     a
118+  0000 ~                                    sbc     hl,de
119+  0000 ~                                    pop     hl
120+  0000                                      ENDM
121+  0000
122+  0000              cpABSDEHL:              MACRO
123+  0000 ~                                    push     hl,,de
124+  0000 ~                                    ld      a,h
125+  0000 ~                                    and     $7F
126+  0000 ~                                    ld      h,a
127+  0000 ~                                    ld      a,d
128+  0000 ~                                    and     $7F
129+  0000 ~                                    ld      d,a
130+  0000 ~                                    ex      de,hl
131+  0000 ~                                    sbc     hl,de
132+  0000 ~                                    pop     hl,,de
133+  0000                                      ENDM
134+  0000
135+  0000              ; Simple are they both the same setting z if they are
136+  0000              ; tehcicall this works but it measn the final ret z is alwys done
137+  0000              ; so jp needs to be to a target
138+  0000              cpHLEquDE:              MACRO   passedCheck
139+  0000 ~                                    ld      a,h
140+  0000 ~                                    cp      d
141+  0000 ~                                    jp      nz, passedCheck
142+  0000 ~                                    ld      a,l
143+  0000 ~                                    cp      e
144+  0000 ~            .NoTheSame:
145+  0000                                      ENDM
146+  0000
147+  0000              cpHLEquBC:              MACRO   passedCheck
148+  0000 ~                                    ld      a,h
149+  0000 ~                                    cp      b
150+  0000 ~                                    jp      nz, passedCheck
151+  0000 ~                                    ld      a,l
152+  0000 ~                                    cp      c
153+  0000 ~            .NoTheSame:
154+  0000                                      ENDM
155+  0000
156+  0000              cpDEEquBC:              MACRO   passedCheck
157+  0000 ~                                    ld      a,d
158+  0000 ~                                    cp      b
159+  0000 ~                                    jp      nz, passedCheck
160+  0000 ~                                    ld      a,e
161+  0000 ~                                    cp      c
162+  0000 ~            .NoTheSame:
163+  0000                                      ENDM
164+  0000              ; Simple version just sets carry if HL < DE reset, does an initial compare for z
165+  0000              cpHLDELeadSign:         MACRO
166+  0000 ~                                    ld      a,h
167+  0000 ~                                    cp      d
168+  0000 ~                                    jr      nz,.FullCompare
169+  0000 ~                                    ld      a,l
170+  0000 ~                                    cp      e
171+  0000 ~                                    ret     z
172+  0000 ~            .FullCompare:           ld      a,h
173+  0000 ~                                    xor     d
174+  0000 ~                                    and     $80
175+  0000 ~                                    jr      nz,.OppositeSigns   ; If opposite signs is a simple sign test
176+  0000 ~                                    ld      a,h                 ; same signs so a little simpler
177+  0000 ~                                    and     $80
178+  0000 ~                                    jp      z,cpHLDE            ; if h is positive then both are positive by here so just cpHLDE
179+  0000 ~                                    jp      cpABSDEHL           ; else we have to do ABScpDEHL
180+  0000 ~            .OppositeSigns:         ld      a,h
181+  0000 ~                                    and     $80
182+  0000 ~                                    and     $80
183+  0000 ~                                    jp      z,.HLGTDE
184+  0000 ~            .HLLTDE:                SetCarryFlag
185+  0000 ~                                    ret
186+  0000 ~            .HLGTDE:                ClearCarryFlag
187+  0000 ~                                    ret
188+  0000                                      ENDM
189+  0000
190+  0000              ;Unsigned
191+  0000              ;If HL == DE, then Z flag is set.
192+  0000              ;If HL != DE, then Z flag is reset.
193+  0000              ;If HL <  DE, then C flag is set.
194+  0000              ;If HL >= DE, then C flag is reset.
195+  0000              ;
196+  0000              ;Signed
197+  0000              ;If HL == DE, then Z flag is set.
198+  0000              ;If HL != DE, then Z flag is reset.
199+  0000              ;If HL <  DE, then S and P/V are different.
200+  0000              ;If HL >= DE, then S and P/V are the same.
201+  0000
202+  0000
203+  0000              N0equN1byN2div256:      MACRO param1,param2,param3
204+  0000 ~                                    ld      a,param3                        ;
205+  0000 ~                                    ld      e,a                         ; use e as var Q = value of XX15 [n] lo
206+  0000 ~                                    ld      a,param2                        ; A = XX16 element
207+  0000 ~                                    ld      d,a
208+  0000 ~                                    mul
209+  0000 ~                                    ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
210+  0000 ~                                    ld      (param1),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
211+  0000                                      ENDM
212+  0000
213+  0000              AequN1xorN2:            MACRO  param1,param2
214+  0000 ~                                    ld      a,(param1)
215+  0000 ~                                    xor     param2
216+  0000                                      ENDM
217+  0000
218+  0000              SpeedMulAxis:           MACRO   speedreg, axis
219+  0000 ~                                    ld      e,speedreg
220+  0000 ~                                    ld      hl,(axis)
221+  0000 ~                                    ld      a,h
222+  0000 ~                                    ClearSignBitA
223+  0000 ~                                    ld      d,a
224+  0000 ~                                    mul     de
225+  0000 ~                                    ld      a,h
226+  0000 ~                                    SignBitOnlyA
227+  0000 ~                                    ld      b,a;ld      c,a
228+  0000 ~                                    ld      h,d;ld      e,d
229+  0000 ~                                    ld      c,0;ld      d,0
230+  0000                                      ENDM
231+  0000
232+  0000              ; Adds speed (8 bit) to vertex (24 bit signed)
233+  0000              AddSpeedToVert:         MACRO   vertex
234+  0000 ~                                    ld      de,(vertex+1)
235+  0000 ~                                    ld      a,(vertex)
236+  0000 ~                                    ld      l,a
237+  0000 ~                                    call    AddBCHtoDELsigned               ; DEL = DEL + BCH
238+  0000 ~                                    ld      a,l
239+  0000 ~                                    ld      (vertex),a
240+  0000 ~                                    ld      (vertex+1),de
241+  0000                                      ENDM
# file closed: MathsMacros.asm
 64   0000                                      INCLUDE "../../Macros/ShiftMacros.asm"
# file opened: ShiftMacros.asm
  1+  0000              ShiftIYRight1: MACRO
  2+  0000 ~                           ld   a,iyh
  3+  0000 ~                           srl  a
  4+  0000 ~                           ld   iyh,a
  5+  0000 ~                           ld   a,iyl
  6+  0000 ~                           rra
  7+  0000 ~                           ld   iyl,a
  8+  0000                             ENDM
  9+  0000
 10+  0000              ShiftIXRight1: MACRO
 11+  0000 ~                           ld   a,ixh
 12+  0000 ~                           srl  a
 13+  0000 ~                           ld   ixh,a
 14+  0000 ~                           ld   a,ixl
 15+  0000 ~                           rra
 16+  0000 ~                           ld   ixl,a
 17+  0000                             ENDM
 18+  0000
 19+  0000              ShiftIXhHLRight1: MACRO
 20+  0000 ~                           ld  a,ixh
 21+  0000 ~                           srl a
 22+  0000 ~                           ld  ixh,a
 23+  0000 ~                           rr  h
 24+  0000 ~                           rr  l
 25+  0000                             ENDM
 26+  0000
 27+  0000              ShiftIYhDERight1: MACRO
 28+  0000 ~                           ld  a,iyh
 29+  0000 ~                           srl a
 30+  0000 ~                           ld  iyh,a
 31+  0000 ~                           rr  d
 32+  0000 ~                           rr  e
 33+  0000                             ENDM
 34+  0000
 35+  0000              ShiftIYlBCRight1: MACRO
 36+  0000 ~                           ld  a,iyl
 37+  0000 ~                           srl a
 38+  0000 ~                           ld  iyl,a
 39+  0000 ~                           rr  b
 40+  0000 ~                           rr  c
 41+  0000                             ENDM
 42+  0000
 43+  0000              ShiftIXlBCRight1: MACRO
 44+  0000 ~                           ld  a,ixl
 45+  0000 ~                           srl a
 46+  0000 ~                           ld  ixl,a
 47+  0000 ~                           rr  b
 48+  0000 ~                           rr  c
 49+  0000                             ENDM
 50+  0000
 51+  0000              ShiftHLRight1: MACRO
 52+  0000 ~                           srl h
 53+  0000 ~                           rr  l
 54+  0000                             ENDM
 55+  0000
 56+  0000              ShiftBHLRight1:MACRO
 57+  0000 ~                           srl b
 58+  0000 ~                           rr h
 59+  0000 ~                           rr  l
 60+  0000                             ENDM
 61+  0000
 62+  0000              ShiftCDERight1:MACRO
 63+  0000 ~                           srl c
 64+  0000 ~                           rr  d
 65+  0000 ~                           rr  e
 66+  0000                             ENDM
 67+  0000
 68+  0000
 69+  0000              SRAHLRight1: MACRO
 70+  0000 ~                           sra h
 71+  0000 ~                           rr  l
 72+  0000                             ENDM
 73+  0000
 74+  0000              ShiftDERight1: MACRO
 75+  0000 ~                           srl d
 76+  0000 ~                           rr  e
 77+  0000                             ENDM
 78+  0000
 79+  0000              ShiftBCRight1: MACRO
 80+  0000 ~                           srl b
 81+  0000 ~                           rr  c
 82+  0000                             ENDM
 83+  0000
 84+  0000
 85+  0000              ShiftHLDiv8:   MACRO
 86+  0000 ~                           srl h
 87+  0000 ~                           rr  l
 88+  0000 ~                           srl h
 89+  0000 ~                           rr  l
 90+  0000 ~                           srl h
 91+  0000 ~                           rr  l
 92+  0000                             ENDM
 93+  0000
 94+  0000              ShiftBHLLeft1:  MACRO
 95+  0000 ~                            sla l
 96+  0000 ~                            rl  h
 97+  0000 ~                            rl  b
 98+  0000                              ENDM
 99+  0000
100+  0000              ShiftCDELeft1:  MACRO
101+  0000 ~                            sla e
102+  0000 ~                            rl  d
103+  0000 ~                            rl  c
104+  0000                              ENDM
105+  0000
106+  0000              ShiftHLLeft1:  MACRO    ; 16 T states
107+  0000 ~                           sla l
108+  0000 ~                           rl  h
109+  0000                             ENDM
110+  0000
111+  0000              ShiftDELeft1:  MACRO    ; 16 T states
112+  0000 ~                           sla e
113+  0000 ~                           rl  d
114+  0000                             ENDM
115+  0000
116+  0000              BarrelHLLeft3: MACRO
117+  0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
118+  0000 ~                           push     bc      ; 10
119+  0000 ~                           ld       b,3     ; 7
120+  0000 ~                           bsrl     de,b    ; 8
121+  0000 ~                           pop      bc      ; 10
122+  0000 ~                           ex       de,hl   ; 4
123+  0000                             ENDM
124+  0000
125+  0000              BarrelHLRight3: MACRO
126+  0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
127+  0000 ~                           push     bc      ; 10
128+  0000 ~                           ld       b,3     ; 7
129+  0000 ~                           bsrl     de,b    ; 8
130+  0000 ~                           pop      bc      ; 10
131+  0000 ~                           ex       de,hl   ; 4
132+  0000                             ENDM
133+  0000
134+  0000              RollBCLeft1:   MACRO    ; 16 T states
135+  0000 ~                           rl  c
136+  0000 ~                           rl  b
137+  0000                             ENDM
138+  0000
139+  0000              RollDELeft1:   MACRO    ; 16 T states
140+  0000 ~                           rl  e
141+  0000 ~                           rl  d
142+  0000                             ENDM
143+  0000
144+  0000              ShiftBCLeft1:  MACRO    ; 16 T states
145+  0000 ~                           sla c
146+  0000 ~                           rl  b
147+  0000                             ENDM
148+  0000
149+  0000              ShiftLeftMem:       MACRO   reg
150+  0000 ~                                ld      hl,reg
151+  0000 ~                                sla     (hl)
152+  0000                                  ENDM
153+  0000
154+  0000
155+  0000
156+  0000              ShiftMem16Right1:   MACRO memaddr
157+  0000 ~                                ld    hl,(memaddr)
158+  0000 ~                                srl   h
159+  0000 ~                                rr    l
160+  0000 ~                                ld    (memaddr),hl
161+  0000                                  ENDM
162+  0000
163+  0000              ShiftMem8Right1:    MACRO memaddr
164+  0000 ~                                ld      a,(memaddr)
165+  0000 ~                                srl     a
166+  0000 ~                                ld      (memaddr),a
167+  0000                                  ENDM
168+  0000
169+  0000
170+  0000              ShiftMem8Left1A:    MACRO memaddr
171+  0000 ~                                ld      a,(memaddr)
172+  0000 ~                                sla     a
173+  0000 ~                                ld      (memaddr),a
174+  0000                                  ENDM
175+  0000
# file closed: ShiftMacros.asm
 65   0000                                      INCLUDE "../../Macros/NegateMacros.asm"
# file opened: NegateMacros.asm
  1+  0000
  2+  0000              macronegate16hl:	MACRO
  3+  0000 ~            					xor 	a
  4+  0000 ~            					sub 	l
  5+  0000 ~            					ld 		l,a
  6+  0000 ~            					sbc 	a,a
  7+  0000 ~            					sub 	h
  8+  0000 ~            					ld 		h,a
  9+  0000              					ENDM
 10+  0000
 11+  0000
 12+  0000              macroAbsHL:         MACRO
 13+  0000 ~                                bit     7,h
 14+  0000 ~                                jp      z,.alreadyABS
 15+  0000 ~            					xor 	a
 16+  0000 ~            					sub 	l
 17+  0000 ~            					ld 		l,a
 18+  0000 ~            					sbc 	a,a
 19+  0000 ~            					sub 	h
 20+  0000 ~            					ld 		h,a
 21+  0000 ~            .alreadyABS:
 22+  0000                                  ENDM
 23+  0000
 24+  0000              macronegate16de:	MACRO
 25+  0000 ~            					xor 	a
 26+  0000 ~                                sub 	e
 27+  0000 ~                                ld 		e,a
 28+  0000 ~                                sbc 	a,a
 29+  0000 ~                                sub 	d
 30+  0000 ~                                ld 		d,a
 31+  0000              					ENDM
 32+  0000
 33+  0000              macronegate16bc:	MACRO
 34+  0000 ~            					xor 	a
 35+  0000 ~                                sub 	c
 36+  0000 ~                                ld 		c,a
 37+  0000 ~                                sbc 	a,a
 38+  0000 ~                                sub 	b
 39+  0000 ~                                ld 		b,a
 40+  0000              					ENDM
 41+  0000
 42+  0000              macronegate16ix:	MACRO
 43+  0000 ~            					xor 	a
 44+  0000 ~                                sub 	ixl
 45+  0000 ~                                ld 		ixl,a
 46+  0000 ~                                sbc 	a,a
 47+  0000 ~                                sub 	ixh
 48+  0000 ~                                ld 		ixh,a
 49+  0000              					ENDM
 50+  0000
 51+  0000
 52+  0000              NegIY:			    MACRO
 53+  0000 ~                                xor a
 54+  0000 ~                                sub iyl
 55+  0000 ~                                ld iyl,a
 56+  0000 ~                                sbc a,a
 57+  0000 ~                                sub iyh
 58+  0000 ~                                ld iyh,a
 59+  0000                                  ENDM
 60+  0000
 61+  0000              NegHL:			    MACRO
 62+  0000 ~                                xor     a
 63+  0000 ~                                sub     l
 64+  0000 ~                                ld      l,a
 65+  0000 ~                                sbc     a,a
 66+  0000 ~                                sub     h
 67+  0000 ~                                ld      h,a
 68+  0000                                  ENDM
 69+  0000
 70+  0000              NegAHL:			    MACRO
 71+  0000 ~                                ld      b,a         ; save a in b
 72+  0000 ~                                xor     a           ; l = 0 - l
 73+  0000 ~                                sub     l
 74+  0000 ~                                ld      l,a
 75+  0000 ~                                sbc     a,a         ; h = 0 - h
 76+  0000 ~                                sub     h
 77+  0000 ~                                ld      h,a
 78+  0000 ~                                sbc     a,a         ; a= 0 - b
 79+  0000 ~                                sub     b
 80+  0000                                  ENDM
 81+  0000
 82+  0000              NegDE:			    MACRO
 83+  0000 ~                                xor a
 84+  0000 ~                                sub e
 85+  0000 ~                                ld e,a
 86+  0000 ~                                sbc a,a
 87+  0000 ~                                sub d
 88+  0000 ~                                ld d,a
 89+  0000                                  ENDM
 90+  0000
 91+  0000              NegBC:			    MACRO
 92+  0000 ~                                xor a
 93+  0000 ~                                sub c
 94+  0000 ~                                ld c,a
 95+  0000 ~                                sbc a,a
 96+  0000 ~                                sub  b
 97+  0000 ~                                ld b,a
 98+  0000                                  ENDM
 99+  0000
100+  0000              NegH                MACRO
101+  0000 ~                                ld      a,h
102+  0000 ~                                neg
103+  0000 ~                                ld      h,a
104+  0000                                  ENDM
105+  0000
106+  0000              NegD                MACRO
107+  0000 ~                                ld      a,d
108+  0000 ~                                neg
109+  0000 ~                                ld      d,a
110+  0000                                  ENDM
111+  0000
112+  0000              NegB                MACRO
113+  0000 ~                                ld      a,b
114+  0000 ~                                neg
115+  0000 ~                                ld      b,a
116+  0000                                  ENDM
117+  0000
# file closed: NegateMacros.asm
 66   0000                                      INCLUDE "../../Macros/carryFlagMacros.asm"
# file opened: carryFlagMacros.asm
  1+  0000
  2+  0000              SetCarryFlag:           MACRO
  3+  0000 ~                                    scf
  4+  0000                                      ENDM
  5+  0000
  6+  0000              ClearCarryFlag:	        MACRO
  7+  0000 ~                                    or a
  8+  0000                                      ENDM
  9+  0000
 10+  0000              FlipCarryFlag:          MACRO
 11+  0000 ~                                    ccf
 12+  0000                                      ENDM
 13+  0000
# file closed: carryFlagMacros.asm
 67   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 68   0000              ; Total screen list
 69   0000              ; Local Chart
 70   0000              ; Galactic Chart
 71   0000              ; Market Prices
 72   0000              ; Inventory
 73   0000              ; Comander status
 74   0000              ; System Data
 75   0000              ; Mission Briefing
 76   0000              ; missio completion
 77   0000              ; Docked  Menu (only place otehr than pause you can load and save)
 78   0000              ; Pause Menu (only place you can load from )
 79   0000              ; byint and selling equipment
 80   0000              ; bying and selling stock
 81   0000
 82   0000              TopOfStack              equ $5CCB ;$6100
 83   0000
 84   0000                                      ORG $5DCB;      $6200
 85   5DCB F3           EliteNextStartup:       di
 86   5DCC FD 00                                break
 87   5DCE FD 21 FD 5D                          ld      iy,Test1
 88   5DD2 06 0F                                ld      b,15
 89   5DD4 FD E5 C5     .testloop:              push    iy,,bc
 90   5DD7 CD 56 5F                             call    TestMult
 91   5DDA C1 FD E1                             pop     iy,,bc
 92   5DDD FD E5 E1                             ld      hl,iy
 93   5DE0 3E 10                                ld      a,$10
 94   5DE2 ED 31                                add     hl,a
 95   5DE4 E5 FD E1                             ld      iy,hl
 96   5DE7 10 EB                                djnz    .testloop
 97   5DE9 FD 00                                break
 98   5DEB
 99   5DEB 00 00        ErrorCount:             DW  0
100   5DED
101   5DED 00 00 00...  MultiplyResult:         DS  16  ; reserve 6 bytes for maths result, little endian rest is padding for console display alignment
102   5DFD
103   5DFD
104   5DFD                                      ;  X............  Y............   Fill Expected (hlbc)...  Actual............  Pass/Fail
105   5DFD                                      ;   0    1    2    3    4    5    6    7,   8,   9,   A,   B,   C,   D,   E,   F
106   5DFD C0 FA 00 00  Test1:                   DB $C0, $FA, $00, $00, $4B, $00, $00, $40, $76, $49, $00, $00, $00, $00, $00, $11 ;
106   5E01 4B 00 00 40
106   5E05 76 49 00 00
106   5E09 00 00 00 11
107   5E0D C0 00 04 C0  Test2:                   DB $C0, $00, $04, $C0, $00, $00, $00, $90, $00, $03, $00, $00, $00, $00, $00, $11
107   5E11 00 00 00 90
107   5E15 00 03 00 00
107   5E19 00 00 00 11
108   5E1D B3 FA 00 00  Test3:                   DB $B3, $FA, $00, $00, $4B, $00, $00, $71, $72, $49, $00, $00, $00, $00, $00, $11 ; 250.6692 * 75 = 18802.44
108   5E21 4B 00 00 71
108   5E25 72 49 00 00
108   5E29 00 00 00 11
109   5E2D 6E 4D 00 6E  Test4:                   DB $6E, $4D, $00, $6E, $4B, $00, $00, $7F, $D0, $16, $00, $00, $00, $00, $00, $11 ; 77.4296875 * 75.4296875 = 5840.497131
109   5E31 4B 00 00 7F
109   5E35 D0 16 00 00
109   5E39 00 00 00 11
110   5E3D 00 73 00 00  Test5:                   DB $00, $73, $00, $00, $D7, $00, $00, $00, $95, $60, $00, $00, $00, $00, $00, $11
110   5E41 D7 00 00 00
110   5E45 95 60 00 00
110   5E49 00 00 00 11
111   5E4D 00 00 0B C0  Test6:                   DB $00, $00, $0B, $C0, $00, $00, $00, $00, $40, $08, $00, $00, $00, $00, $00, $11
111   5E51 00 00 00 00
111   5E55 40 08 00 00
111   5E59 00 00 00 11
112   5E5D 40 54 02 80  Test7:                   DB $40, $54, $02, $80, $0E, $00, $00, $A0, $C5, $21, $00, $00, $00, $00, $00, $11
112   5E61 0E 00 00 A0
112   5E65 C5 21 00 00
112   5E69 00 00 00 11
113   5E6D C0 00 00 00  Test8:                   DB $C0, $00, $00, $00, $02, $00, $00, $80, $01, $00, $00, $00, $00, $00, $00, $11
113   5E71 02 00 00 80
113   5E75 01 00 00 00
113   5E79 00 00 00 11
114   5E7D 40 00 00 00  Test9:                   DB $40, $00, $00, $00, $02, $00, $00, $80, $00, $00, $00, $00, $00, $00, $00, $11
114   5E81 02 00 00 80
114   5E85 00 00 00 00
114   5E89 00 00 00 11
115   5E8D 80 06 05 00  TestA:                   DB $80, $06, $05, $00, $02, $00, $00, $00, $0D, $0A, $00, $00, $00, $00, $00, $11
115   5E91 02 00 00 00
115   5E95 0D 0A 00 00
115   5E99 00 00 00 11
116   5E9D C0 00 04 C0  TestB:                   DB $C0, $00, $04, $C0, $00, $00, $00, $90, $00, $03, $00, $00, $00, $00, $00, $11
116   5EA1 00 00 00 90
116   5EA5 00 03 00 00
116   5EA9 00 00 00 11
117   5EAD C0 00 04 C0  TestC:                   DB $C0, $00, $04, $C0, $00, $04, $00, $90, $00, $06, $10, $00, $00, $00, $00, $11
117   5EB1 00 04 00 90
117   5EB5 00 06 10 00
117   5EB9 00 00 00 11
118   5EBD 40 00 02 80  TestD:                   DB $40, $00, $02, $80, $00, $00, $00, $20, $00, $01, $00, $00, $00, $00, $00, $11
118   5EC1 00 00 00 20
118   5EC5 00 01 00 00
118   5EC9 00 00 00 11
119   5ECD C0 00 04 80  TestE:                   DB $C0, $00, $04, $80, $61, $00, $00, $20, $49, $86, $01, $00, $00, $00, $00, $11
119   5ED1 61 00 00 20
119   5ED5 49 86 01 00
119   5ED9 00 00 00 11
120   5EDD 66 12 06 80  TestF:                   DB $66, $12, $06, $80, $61, $00, $00, $D9, $01, $50, $02, $00, $00, $00, $00, $11
120   5EE1 61 00 00 D9
120   5EE5 01 50 02 00
120   5EE9 00 00 00 11
121   5EED
122   5EED FD 6E 00 FD  TestMult64:             ld      hl,(iy+0)           ; dehl = X
122   5EF1 66 01
123   5EF3 FD 7E 02                             ld      a,(iy+2)            ; .
124   5EF6 5F                                   ld      e,a                 ; .
125   5EF7 16 00                                ld      d,0
126   5EF9 D9                                   exx                         ; de'hl' = X
127   5EFA FD 6E 03 FD                          ld      hl,(iy+3)           ; dehl = Y
127   5EFE 66 04
128   5F00 FD 7E 05                             ld      a,(iy+5)            ;
129   5F03 5F                                   ld      e,a                 ;
130   5F04 16 00                                ld      d,0
131   5F06 D9                                   exx
132   5F07 CD 7E 60                             call    mul24
133   5F0A                                      ;call    mulu_64             ; result of dehl de'hl' = dehl * dehl'
134   5F0A D9                                   exx                         ; so now we have l'de.h to consdier                     ; we only care about lde'.h' in the resul
135   5F0B 7C                                   ld      a,h                 ; we only care about lde'.h' in the resul
136   5F0C FD 77 0B                             ld      (iy+$0B),a          ; .
137   5F0F FD 73 0C FD                          ld      (iy+$0C),de         ; .
137   5F13 72 0D
138   5F15 D9                                   exx
139   5F16 7D                                   ld      a,l
140   5F17 FD 77 0E                             ld      (iy+$0E),a          ; and finally l
141   5F1A FD 7E 07     .CheckResult:           ld      a,(iy+$07)
142   5F1D 47                                   ld      b,a
143   5F1E FD 7E 0B                             ld      a,(iy+$0B)
144   5F21 B8                                   cp      b
145   5F22 C2 4C 5F                             jp      nz,.Fail
146   5F25
147   5F25 FD 7E 08                             ld      a,(iy+$08)
148   5F28 47                                   ld      b,a
149   5F29 FD 7E 0C                             ld      a,(iy+$0C)
150   5F2C B8                                   cp      b
151   5F2D C2 4C 5F                             jp      nz,.Fail
152   5F30
153   5F30 FD 7E 09                             ld      a,(iy+$09)
154   5F33 47                                   ld      b,a
155   5F34 FD 7E 0D                             ld      a,(iy+$0D)
156   5F37 B8                                   cp      b
157   5F38 C2 4C 5F                             jp      nz,.Fail
158   5F3B
159   5F3B FD 7E 0A                             ld      a,(iy+$0A)
160   5F3E 47                                   ld      b,a
161   5F3F FD 7E 0E                             ld      a,(iy+$0E)
162   5F42 B8                                   cp      b
163   5F43 C2 4C 5F                             jp      nz,.Fail
164   5F46
165   5F46 3E FF                                ld      a,$FF
166   5F48 FD 77 0F                             ld      (iy+$0F),a
167   5F4B C9                                   ret
168   5F4C 3E 00        .Fail:                  ld      a,$00
169   5F4E FD 77 0F                             ld      (iy+$0F),a
170   5F51 21 EB 5D                             ld      hl,ErrorCount
171   5F54 34                                   inc     (hl)
172   5F55 C9                                   ret
173   5F56
174   5F56
175   5F56 FD 6E 00 FD  TestMult:               ld      hl,(iy+0)           ; dehl = X
175   5F5A 66 01
176   5F5C FD 7E 02                             ld      a,(iy+2)            ; .
177   5F5F 47                                   ld      b,a                 ; .
178   5F60 FD 5E 03 FD                          ld      de,(iy+3)           ; dehl = Y
178   5F64 56 04
179   5F66 FD 7E 05                             ld      a,(iy+5)            ;
180   5F69 4F                                   ld      c,a                 ;
181   5F6A FD 00                                break
182   5F6C CD 7E 60                             call    mul24               ; BH.L by CD.E putting result in BCDE.HL
183   5F6F 7C                                   ld      a,h
184   5F70 FD 77 0B                             ld      (iy+$0B),a          ; .
185   5F73 FD 73 0C FD                          ld      (iy+$0C),de         ; .
185   5F77 72 0D
186   5F79                                      ZeroA
186   5F79 AF          >                        xor a
187   5F7A FD 77 0E                             ld      (iy+$0E),a          ; and finally l
188   5F7D FD 7E 07     .CheckResult:           ld      a,(iy+$07)
189   5F80 47                                   ld      b,a
190   5F81 FD 7E 0B                             ld      a,(iy+$0B)
191   5F84 B8                                   cp      b
192   5F85 C2 AF 5F                             jp      nz,.Fail
193   5F88
194   5F88 FD 7E 08                             ld      a,(iy+$08)
195   5F8B 47                                   ld      b,a
196   5F8C FD 7E 0C                             ld      a,(iy+$0C)
197   5F8F B8                                   cp      b
198   5F90 C2 AF 5F                             jp      nz,.Fail
199   5F93
200   5F93 FD 7E 09                             ld      a,(iy+$09)
201   5F96 47                                   ld      b,a
202   5F97 FD 7E 0D                             ld      a,(iy+$0D)
203   5F9A B8                                   cp      b
204   5F9B C2 AF 5F                             jp      nz,.Fail
205   5F9E
206   5F9E FD 7E 0A                             ld      a,(iy+$0A)
207   5FA1 47                                   ld      b,a
208   5FA2 FD 7E 0E                             ld      a,(iy+$0E)
209   5FA5 B8                                   cp      b
210   5FA6 C2 AF 5F                             jp      nz,.Fail
211   5FA9
212   5FA9 3E FF                                ld      a,$FF
213   5FAB FD 77 0F                             ld      (iy+$0F),a
214   5FAE C9                                   ret
215   5FAF 3E 00        .Fail:                  ld      a,$00
216   5FB1 FD 77 0F                             ld      (iy+$0F),a
217   5FB4 21 EB 5D                             ld      hl,ErrorCount
218   5FB7 34                                   inc     (hl)
219   5FB8 C9                                   ret
220   5FB9
221   5FB9              ;--------------------------------------------------------------------------------------
222   5FB9                  INCLUDE	"../../Maths24/asm_multiply24.asm"
# file opened: asm_multiply24.asm
  1+  5FB9              ;; perform dehl & de'hl' with d and d' always being 0
  2+  5FB9              ;mulu_48:    ld bc,hl                    ; prep de'de bc'bc
  3+  5FB9              ;            push de                     ;
  4+  5FB9              ;            exx                         ;
  5+  5FB9              ;            pop bc                      ;
  6+  5FB9              ;            push hl                     ;
  7+  5FB9              ;            exx                         ;
  8+  5FB9              ;            pop de                      ;
  9+  5FB9              ;            ; perform multipication as 0e'de * 0c'bc
 10+  5FB9              ;mulu_64debc:exx                         ; save material for the byte p7 p6 = x3*y3 + p5 carry
 11+  5FB9              ;            ld h,d
 12+  5FB9              ;            ld l,b
 13+  5FB9              ;            push hl                     ;'x3 y3                                 SP + 1 X
 14+  5FB9              ;
 15+  5FB9              ;
 16+  5FB9              ;            ld l,c                      ; save material for the byte p5 = x3*y2 + x2*y3 + p4 carry
 17+  5FB9              ;            push hl                     ;'x3 y2                                 SP + 2 X
 18+  5FB9              ;            ld h,b
 19+  5FB9              ;            ld l,e
 20+  5FB9              ;            push hl                     ;'y3 x2                                 SP + 3 X
 21+  5FB9              ;
 22+  5FB9              ;
 23+  5FB9              ;            ld h,e                      ; save material for the byte p4 = x3*y1 + x2*y2 + x1*y3 + p3 carry
 24+  5FB9              ;            ld l,c
 25+  5FB9              ;            push hl                     ;'x2 y2                                 SP + 4
 26+  5FB9              ;            ld h,d
 27+  5FB9              ;            ld l,b
 28+  5FB9              ;            push hl                     ;'x3 y3                                 SP + 5 X
 29+  5FB9              ;            exx                         ; Now we have the alternate register pairs we can start optimising by binning off d' and b' calculations
 30+  5FB9              ;
 31+  5FB9              ;            ld l,b
 32+  5FB9              ;            ld h,d
 33+  5FB9              ;            push hl                     ; x1 y1                                 SP + 6
 34+  5FB9              ;
 35+  5FB9              ;
 36+  5FB9              ;            push bc                     ; save material for the byte p3 = x3*y0 + x2*y1 + x1*y2 + x0*y3 + p2 carry y1 y0
 37+  5FB9              ;            exx                         ;'
 38+  5FB9              ;            push de                     ;'x3 x2                                 SP + 7 X
 39+  5FB9              ;            push bc                     ;'y3 y2                                 SP + 8 X
 40+  5FB9              ;            exx                         ;
 41+  5FB9              ;            push de                     ; x1 x0                                 SP + 9
 42+  5FB9              ;
 43+  5FB9              ;
 44+  5FB9              ;            exx                         ; save material for the byte p2 = x2*y0 + x0*y2 + x1*y1 + p1 carry start of 32_32x32
 45+  5FB9              ;            ld h,e
 46+  5FB9              ;            ld l,c
 47+  5FB9              ;            push hl                     ;'x2 y2                                 SP + 10
 48+  5FB9              ;
 49+  5FB9              ;            exx                         ;
 50+  5FB9              ;            ld h,e
 51+  5FB9              ;            ld l,c
 52+  5FB9              ;            push hl                     ; x0 y0                                 SP + 11
 53+  5FB9              ;
 54+  5FB9              ;
 55+  5FB9              ;            ;
 56+  5FB9              ;
 57+  5FB9              ;            ld h,d                      ; start of 32_16x16          p1 = x1*y0 + x0*y1 + p0 carry  p0 = x0*y0
 58+  5FB9              ;            ld l,b
 59+  5FB9              ;            push hl                     ; x1 y1                                 SP + 12
 60+  5FB9              ;
 61+  5FB9              ;            ld h,d                      ; x1
 62+  5FB9              ;            ld d,b                      ; y1
 63+  5FB9              ;            ld l,c                      ; y0
 64+  5FB9              ;            ld b,e                      ; x0
 65+  5FB9              ;            mul de                       ; bc = x0 y0 de = y1 x0 hl = x1 y0 stack = x1 y1, y1*x0
 66+  5FB9              ;            ex de,hl
 67+  5FB9              ;            mul de                      ; x1*y0
 68+  5FB9              ;
 69+  5FB9              ;            xor a                       ; zero A
 70+  5FB9              ;            add hl,de                   ; sum cross products p2 p1
 71+  5FB9              ;            adc a,a                     ; capture carry p3
 72+  5FB9              ;
 73+  5FB9              ;            ld e,c                      ; x0
 74+  5FB9              ;            ld d,b                      ; y0
 75+  5FB9              ;            mul de                      ; y0*x0
 76+  5FB9              ;
 77+  5FB9              ;            ld b,a                      ; carry from cross products
 78+  5FB9              ;            ld c,h                      ; LSB of MSW from cross products
 79+  5FB9              ;
 80+  5FB9              ;            ld a,d
 81+  5FB9              ;            add a,l
 82+  5FB9              ;            ld h,a
 83+  5FB9              ;            ld l,e                      ; LSW in HL p1 p0
 84+  5FB9              ;
 85+  5FB9              ;            pop de                      ;                                       SP + 11
 86+  5FB9              ;            mul de                      ; x1*y1
 87+  5FB9              ;
 88+  5FB9              ;            ex de,hl
 89+  5FB9              ;            adc hl,bc                   ; HL = interim MSW p3 p2
 90+  5FB9              ;            ex de,hl                    ; DEHL = 32_16x16
 91+  5FB9              ;
 92+  5FB9              ;            push de                     ; stack interim p3 p2                   SP + 12
 93+  5FB9              ;
 94+  5FB9              ;
 95+  5FB9              ;            exx                         ; continue doing the p2 byte
 96+  5FB9              ;            pop bc                      ;'recover interim p3 p2                 SP + 11
 97+  5FB9              ;
 98+  5FB9              ;            pop hl                      ;'x0 y0                                 SP + 10
 99+  5FB9              ;            pop de                      ;'x2 y2                                 SP + 9
100+  5FB9              ;            ld a,h
101+  5FB9              ;            ld h,d
102+  5FB9              ;            ld d,a
103+  5FB9              ;            mul de                      ;'x0*y2
104+  5FB9              ;            ex de,hl
105+  5FB9              ;            mul de                      ;'x2*y0
106+  5FB9              ;
107+  5FB9              ;            xor a
108+  5FB9              ;            add hl,bc
109+  5FB9              ;            adc a,a                     ;'capture carry p4
110+  5FB9              ;            add hl,de
111+  5FB9              ;            adc a,0                     ;'capture carry p4
112+  5FB9              ;
113+  5FB9              ;            push hl                     ;                                       SP + 10
114+  5FB9              ;            exx
115+  5FB9              ;            pop de                      ; save p2 in E'                         SP + 9
116+  5FB9              ;            exx                         ;'
117+  5FB9              ;
118+  5FB9              ;            ld c,h                      ;'promote BC p4 p3
119+  5FB9              ;            ld b,a
120+  5FB9              ;
121+  5FB9              ;            pop hl                      ; start doing the p3 byte, 'x1 x0       SP + 9
122+  5FB9              ;            pop de                      ;'y3 y2                                 SP + 8 X
123+  5FB9              ;            ld a,h
124+  5FB9              ;            ld h,d
125+  5FB9              ;            ld d,a
126+  5FB9              ;            mul de                      ;'y3*x0                                        X
127+  5FB9              ;            ex de,hl
128+  5FB9              ;            mul de                      ;'x1*y2
129+  5FB9              ;
130+  5FB9              ;            xor a                       ;'zero A
131+  5FB9              ;            add hl,de                   ;'p4 p3
132+  5FB9              ;            adc a,a                     ;'p5
133+  5FB9              ;            add hl,bc                   ;'p4 p3
134+  5FB9              ;            adc a,0
135+  5FB9              ;            ld b,h
136+  5FB9              ;            ld c,l
137+  5FB9              ;            ex af,af
138+  5FB9              ;
139+  5FB9              ;            pop hl                      ;'x3 x2                                 SP + 7 X
140+  5FB9              ;            pop de                      ;'y1 y0                                 SP + 6
141+  5FB9              ;            ld a,h
142+  5FB9              ;            ld h,d
143+  5FB9              ;            ld d,a
144+  5FB9              ;            mul de                      ;'x3*y0                                        X
145+  5FB9              ;            ex de,hl
146+  5FB9              ;            mul de                      ;'y1*x2
147+  5FB9              ;
148+  5FB9              ;            ex af,af
149+  5FB9              ;            add hl,de                   ;'p4 p3
150+  5FB9              ;            adc a,0                     ;'p5
151+  5FB9              ;            add hl,bc                   ;'p4 p3
152+  5FB9              ;            adc a,0                     ;'p5
153+  5FB9              ;
154+  5FB9              ;            push hl                     ;'leave final p3 in L                   SP + 7
155+  5FB9              ;            exx                         ;
156+  5FB9              ;            pop bc                      ;                                       SP + 6
157+  5FB9              ;            ld d,c                      ; put final p3 in D
158+  5FB9              ;            exx                         ;'low 32bits in DEHL
159+  5FB9              ;
160+  5FB9              ;            ld c,h                      ;'prepare BC for next cycle
161+  5FB9              ;            ld b,a                      ;'promote BC p5 p4
162+  5FB9              ;
163+  5FB9              ;            ; start doing the p4 byte
164+  5FB9              ;
165+  5FB9              ;            pop hl                      ;'x1 y1                                 SP + 5
166+  5FB9              ;            pop de                      ;'x3 y3                                 SP + 4 X
167+  5FB9              ;            ld a,h
168+  5FB9              ;            ld h,d
169+  5FB9              ;            ld d,a
170+  5FB9              ;            mul de                      ;'x1*y3                                        X
171+  5FB9              ;            ex de,hl
172+  5FB9              ;            mul de                      ;'x3*y1
173+  5FB9              ;
174+  5FB9              ;
175+  5FB9              ;            xor a                       ;'zero A
176+  5FB9              ;            add hl,de                   ;'p5 p4
177+  5FB9              ;            adc a,a                     ;'p6
178+  5FB9              ;            add hl,bc                   ;'p5 p4
179+  5FB9              ;            adc a,0                     ;'p6
180+  5FB9              ;
181+  5FB9              ;            pop de                      ;'x2 y2                                 SP + 3
182+  5FB9              ;            mul de                      ;'x2*y2
183+  5FB9              ;
184+  5FB9              ;            add hl,de                   ;'p5 p4
185+  5FB9              ;            adc a,0                     ;'p6
186+  5FB9              ;
187+  5FB9              ;            ld c,l                      ;'final p4 byte in C
188+  5FB9              ;            ld l,h                      ;'prepare HL for next cycle
189+  5FB9              ;            ld h,a                      ;'promote HL p6 p5
190+  5FB9              ;
191+  5FB9              ;            ; start doing the p5 byte
192+  5FB9              ;
193+  5FB9              ;            pop de                      ;'y3 x2                                 SP + 2 X
194+  5FB9              ;            mul de                      ;'y3*x2                                        X
195+  5FB9              ;
196+  5FB9              ;            xor a                       ;'zero A
197+  5FB9              ;            add hl,de                   ;'p6 p5
198+  5FB9              ;            adc a,a                     ;'p7
199+  5FB9              ;
200+  5FB9              ;            pop de                      ;'x3 y2                                 SP + 1
201+  5FB9              ;            mul de                      ;'x3*y2
202+  5FB9              ;
203+  5FB9              ;            add hl,de                   ;'p6 p5
204+  5FB9              ;            adc a,0                     ;'p7
205+  5FB9              ;
206+  5FB9              ;            ld b,l                      ;'final p5 byte in B
207+  5FB9              ;            ld l,h                      ;'prepare HL for next cycle
208+  5FB9              ;            ld h,a                      ;'promote HL p7 p6
209+  5FB9              ;
210+  5FB9              ;            ; start doing the p6 p7 bytes
211+  5FB9              ;            pop de                      ;'y3 x3                                 SP + 0
212+  5FB9              ;            mul de                      ;'y3*x3
213+  5FB9              ;
214+  5FB9              ;            add hl,de                   ;'p7 p6
215+  5FB9              ;            ex de,hl                    ;'p7 p6
216+  5FB9              ;            ld h,b                      ;'p5
217+  5FB9              ;            ld l,c                      ;'p4
218+  5FB9              ;
219+  5FB9              ;            ret                         ;'exit  : DEHL DEHL' = 64-bit product
220+  5FB9
221+  5FB9              ; dehl dehl' = dehl * dehl'
222+  5FB9 44 4D        mulu_64:    ld bc,hl                    ; prep de'de bc'bc
223+  5FBB D5                       push de                     ;
224+  5FBC D9                       exx                         ;
225+  5FBD C1                       pop bc                      ;
226+  5FBE E5                       push hl                     ;
227+  5FBF D9                       exx                         ;
228+  5FC0 D1                       pop de                      ;
229+  5FC1 D9           mulu_64debc:exx                         ; save material for the byte p7 p6 = x3*y3 + p5 carry
230+  5FC2 62                       ld h,d
231+  5FC3 68                       ld l,b
232+  5FC4 E5                       push hl                     ;'x3 y3
233+  5FC5
234+  5FC5
235+  5FC5 69                       ld l,c                      ; save material for the byte p5 = x3*y2 + x2*y3 + p4 carry
236+  5FC6 E5                       push hl                     ;'x3 y2
237+  5FC7 60                       ld h,b
238+  5FC8 6B                       ld l,e
239+  5FC9 E5                       push hl                     ;'y3 x2
240+  5FCA
241+  5FCA
242+  5FCA 63                       ld h,e                      ; save material for the byte p4 = x3*y1 + x2*y2 + x1*y3 + p3 carry
243+  5FCB 69                       ld l,c
244+  5FCC E5                       push hl                     ;'x2 y2
245+  5FCD 62                       ld h,d
246+  5FCE 68                       ld l,b
247+  5FCF E5                       push hl                     ;'x3 y3
248+  5FD0 D9                       exx                         ;
249+  5FD1 68                       ld l,b
250+  5FD2 62                       ld h,d
251+  5FD3 E5                       push hl                     ; x1 y1
252+  5FD4
253+  5FD4
254+  5FD4 C5                       push bc                     ; ; save material for the byte p3 = x3*y0 + x2*y1 + x1*y2 + x0*y3 + p2 carry y1 y0
255+  5FD5 D9                       exx                         ;'
256+  5FD6 D5                       push de                     ;'x3 x2
257+  5FD7 C5                       push bc                     ;'y3 y2
258+  5FD8 D9                       exx                         ;
259+  5FD9 D5                       push de                     ; x1 x0
260+  5FDA
261+  5FDA
262+  5FDA D9                       exx                         ; save material for the byte p2 = x2*y0 + x0*y2 + x1*y1 + p1 carry start of 32_32x32
263+  5FDB 63                       ld h,e
264+  5FDC 69                       ld l,c
265+  5FDD E5                       push hl                     ;'x2 y2
266+  5FDE
267+  5FDE D9                       exx                         ;
268+  5FDF 63                       ld h,e
269+  5FE0 69                       ld l,c
270+  5FE1 E5                       push hl                     ; x0 y0
271+  5FE2
272+  5FE2
273+  5FE2                          ;
274+  5FE2
275+  5FE2 62                       ld h,d                      ; start of 32_16x16          p1 = x1*y0 + x0*y1 + p0 carry  p0 = x0*y0
276+  5FE3 68                       ld l,b
277+  5FE4 E5                       push hl                     ; x1 y1
278+  5FE5
279+  5FE5 62                       ld h,d                      ; x1
280+  5FE6 50                       ld d,b                      ; y1
281+  5FE7 69                       ld l,c                      ; y0
282+  5FE8 43                       ld b,e                      ; x0
283+  5FE9 ED 30                    mul de                       ; bc = x0 y0 de = y1 x0 hl = x1 y0 stack = x1 y1, y1*x0
284+  5FEB EB                       ex de,hl
285+  5FEC ED 30                    mul de                      ; x1*y0
286+  5FEE
287+  5FEE AF                       xor a                       ; zero A
288+  5FEF 19                       add hl,de                   ; sum cross products p2 p1
289+  5FF0 8F                       adc a,a                     ; capture carry p3
290+  5FF1
291+  5FF1 59                       ld e,c                      ; x0
292+  5FF2 50                       ld d,b                      ; y0
293+  5FF3 ED 30                    mul de                      ; y0*x0
294+  5FF5
295+  5FF5 47                       ld b,a                      ; carry from cross products
296+  5FF6 4C                       ld c,h                      ; LSB of MSW from cross products
297+  5FF7
298+  5FF7 7A                       ld a,d
299+  5FF8 85                       add a,l
300+  5FF9 67                       ld h,a
301+  5FFA 6B                       ld l,e                      ; LSW in HL p1 p0
302+  5FFB
303+  5FFB D1                       pop de
304+  5FFC ED 30                    mul de                      ; x1*y1
305+  5FFE
306+  5FFE EB                       ex de,hl
307+  5FFF ED 4A                    adc hl,bc                   ; HL = interim MSW p3 p2
308+  6001 EB                       ex de,hl                    ; DEHL = 32_16x16
309+  6002
310+  6002 D5                       push de                     ; stack interim p3 p2
311+  6003
312+  6003
313+  6003 D9                       exx                         ; continue doing the p2 byte
314+  6004 C1                       pop bc                      ;'recover interim p3 p2
315+  6005
316+  6005 E1                       pop hl                      ;'x0 y0
317+  6006 D1                       pop de                      ;'x2 y2
318+  6007 7C                       ld a,h
319+  6008 62                       ld h,d
320+  6009 57                       ld d,a
321+  600A ED 30                    mul de                      ;'x0*y2
322+  600C EB                       ex de,hl
323+  600D ED 30                    mul de                      ;'x2*y0
324+  600F
325+  600F AF                       xor a
326+  6010 09                       add hl,bc
327+  6011 8F                       adc a,a                     ;'capture carry p4
328+  6012 19                       add hl,de
329+  6013 CE 00                    adc a,0                     ;'capture carry p4
330+  6015
331+  6015 E5                       push hl
332+  6016 D9                       exx
333+  6017 D1                       pop de                      ; save p2 in E'
334+  6018 D9                       exx                         ;'
335+  6019
336+  6019 4C                       ld c,h                      ;'promote BC p4 p3
337+  601A 47                       ld b,a
338+  601B
339+  601B E1                       pop hl                      ; start doing the p3 byte, 'x1 x0
340+  601C D1                       pop de                      ;'y3 y2
341+  601D 7C                       ld a,h
342+  601E 62                       ld h,d
343+  601F 57                       ld d,a
344+  6020 ED 30                    mul de                      ;'y3*x0
345+  6022 EB                       ex de,hl
346+  6023 ED 30                    mul de                      ;'x1*y2
347+  6025
348+  6025 AF                       xor a                       ;'zero A
349+  6026 19                       add hl,de                   ;'p4 p3
350+  6027 8F                       adc a,a                     ;'p5
351+  6028 09                       add hl,bc                   ;'p4 p3
352+  6029 CE 00                    adc a,0
353+  602B 44                       ld b,h
354+  602C 4D                       ld c,l
355+  602D 08                       ex af,af
356+  602E
357+  602E E1                       pop hl                      ;'x3 x2
358+  602F D1                       pop de                      ;'y1 y0
359+  6030 7C                       ld a,h
360+  6031 62                       ld h,d
361+  6032 57                       ld d,a
362+  6033 ED 30                    mul de                      ;'x3*y0
363+  6035 EB                       ex de,hl
364+  6036 ED 30                    mul de                      ;'y1*x2
365+  6038
366+  6038 08                       ex af,af
367+  6039 19                       add hl,de                   ;'p4 p3
368+  603A CE 00                    adc a,0                     ;'p5
369+  603C 09                       add hl,bc                   ;'p4 p3
370+  603D CE 00                    adc a,0                     ;'p5
371+  603F
372+  603F E5                       push hl                     ;'leave final p3 in L
373+  6040 D9                       exx                         ;
374+  6041 C1                       pop bc
375+  6042 51                       ld d,c                      ; put final p3 in D
376+  6043 D9                       exx                         ;'low 32bits in DEHL
377+  6044
378+  6044 4C                       ld c,h                      ;'prepare BC for next cycle
379+  6045 47                       ld b,a                      ;'promote BC p5 p4
380+  6046
381+  6046                          ; start doing the p4 byte
382+  6046
383+  6046 E1                       pop hl                      ;'x1 y1
384+  6047 D1                       pop de                      ;'x3 y3
385+  6048 7C                       ld a,h
386+  6049 62                       ld h,d
387+  604A 57                       ld d,a
388+  604B ED 30                    mul de                      ;'x1*y3
389+  604D EB                       ex de,hl
390+  604E ED 30                    mul de                      ;'x3*y1
391+  6050
392+  6050
393+  6050 AF                       xor a                       ;'zero A
394+  6051 19                       add hl,de                   ;'p5 p4
395+  6052 8F                       adc a,a                     ;'p6
396+  6053 09                       add hl,bc                   ;'p5 p4
397+  6054 CE 00                    adc a,0                     ;'p6
398+  6056
399+  6056 D1                       pop de                      ;'x2 y2
400+  6057 ED 30                    mul de                      ;'x2*y2
401+  6059
402+  6059 19                       add hl,de                   ;'p5 p4
403+  605A CE 00                    adc a,0                     ;'p6
404+  605C
405+  605C 4D                       ld c,l                      ;'final p4 byte in C
406+  605D 6C                       ld l,h                      ;'prepare HL for next cycle
407+  605E 67                       ld h,a                      ;'promote HL p6 p5
408+  605F
409+  605F                          ; start doing the p5 byte
410+  605F
411+  605F D1                       pop de                      ;'y3 x2
412+  6060 ED 30                    mul de                      ;'y3*x2
413+  6062
414+  6062 AF                       xor a                       ;'zero A
415+  6063 19                       add hl,de                   ;'p6 p5
416+  6064 8F                       adc a,a                     ;'p7
417+  6065
418+  6065 D1                       pop de                      ;'x3 y2
419+  6066 ED 30                    mul de                      ;'x3*y2
420+  6068
421+  6068 19                       add hl,de                   ;'p6 p5
422+  6069 CE 00                    adc a,0                     ;'p7
423+  606B
424+  606B 45                       ld b,l                      ;'final p5 byte in B
425+  606C 6C                       ld l,h                      ;'prepare HL for next cycle
426+  606D 67                       ld h,a                      ;'promote HL p7 p6
427+  606E
428+  606E                          ; start doing the p6 p7 bytes
429+  606E D1                       pop de                      ;'y3 x3
430+  606F ED 30                    mul de                      ;'y3*x3
431+  6071
432+  6071 19                       add hl,de                   ;'p7 p6
433+  6072 EB                       ex de,hl                    ;'p7 p6
434+  6073 60                       ld h,b                      ;'p5
435+  6074 69                       ld l,c                      ;'p4
436+  6075
437+  6075 C9                       ret                         ;'exit  : DEHL DEHL' = 64-bit product
438+  6076
439+  6076
440+  6076              ;   For divide
441+  6076              ;   Split BHL/CDE into
442+  6076              ;         BCDE.HL = HL/CD + BCDE.HL = BHL*1/E
443+  6076              ;         ; for 24 bit divide
444+  6076              ;         ; if both BC are non zero, to BH.0/CD.0
445+  6076              ;         ; if CD = 0 do BH.L/00.L
446+  6076              ;         ; if B = 0 & C != 0 then result is B*256/C >> 8
447+  6076              ; Table B   H   L   C   D   E                                    HLD.E
448+  6076              ;       !   !   !   !   !   !       BH.0/CD.0 (16/16) => HL/DE  =>00D.0
449+  6076              ;       !   !   !   0   !   !       BH.0/D.0 (16/8)      BHL/DE =>0LD.0 (result << 8)
450+  6076              ;       0   !   !   !   !   !       0
451+  6076              ;       0   !   !   0   !   !       H.L/D.E (16 bit)  => HL/DE  =>00D.E (result >> 8)
452+  6076              ;       0   !   !   0   0   !       H.L/0.E (16 bit)  => HL/DE  =>00D.E (result >> 8)
453+  6076              ;       0   0   !   !   !   !       0
454+  6076              ;       0   0   !   0   !   !       0
455+  6076              ;       0   0   !   0   0   !       00.L/00.E
456+  6076              ;       0   0   0   X   X   X       0
457+  6076              ;       X   X   X   0   0   0       carry set
458+  6076              ; Fixed  24 bit maths S48.16 = BDE * AHL where A=S BCDE=48 HL=16, used by other routines which drop unneeded bytes
459+  6076              ;  X 2 1 0 Y 2 1 0
460+  6076              ;    B H L   C D E
461+  6076              ; 24 bit multiply
462+  6076              ; start with lower and help with add sequence           ; all with carry flag (as lower case target reg)
463+  6076              ;        L *     E   X0mulY0 1>> 1>>  shift >> 16       ;     HL = L * E
464+  6076              ;        L *   D     Y1mulX0 0   1>>  shift >> 8        ;   DEHL = 00HL  + 0[L*D]0
465+  6076              ;      H   *     E   X1mulY0 0   1>>  shift >> 8        ;   DEHL = DEHL  + 0[H*E]0 = DEH + 0[H*E]
466+  6076              ;    B     *     E   X2mulY0 1<< 1>>  shift 0           ;  CDE   = 0DE   + 0[B*E]
467+  6076              ;        L * C       Y2mulX0 1<< 1>>  shift 0           ;  CDE   = CDE   + 0[L*C]
468+  6076              ;      H   *   D     X1mulY1 0   0    shift 0           ;  CDE   = CDE   + 0[H*D]
469+  6076              ;    B     *   D     X2mulY1 1<< 0<<  shift << 8        ; BCD    = 0CD   + 0[B*D]
470+  6076              ;      H   * C       Y2mulX1 1<< 0    shift << 8        ; BCD    = 0CD   + 0[H*C]
471+  6076              ;    B     * C       X2mulY2 1<< 1<<  shift <<16        ; BC     = BC    + [B*C]
472+  6076              ; 16 bit multiply
473+  6076              ; start with lower and help with add sequence           ; all with carry flag (as lower case target reg)
474+  6076              ;        L *     E   X0mulY0 1>> 1>>  shift >> 16       ;     HL = L * E
475+  6076              ;        L *   D     Y1mulX0 0   1>>  shift >> 8        ;   DEHL = 00HL  + 0[L*D]0
476+  6076              ;      H   *     E   X1mulY0 0   1>>  shift >> 8        ;   DEHL = DEHL  + 0[H*E]0 = DEH + 0[H*E]
477+  6076              ;      H   *   D     X1mulY1 0   0    shift 0           ;  CDE   = CDE   + 0[H*D]
478+  6076              ;                                                       ; Result BCDE.HL
479+  6076
480+  6076              ; so in our calcs we have
481+  6076              ;     bhl  *  cde
482+  6076              ;     HLD1    HLD2
483+  6076              ; which maps to bytes 5 4 3 2 1 0
484+  6076              ;  D1 * D2                    X X  1    de = l * e   (D1 * D2)
485+  6076              ;  L1 * D2                  X X    2    hl = h * e   (L1 * D2)  e = d, d = 0 add hl,de and move carry to a (result ahl)
486+  6076              ;  D1 * L2                  X X    3    de = l * d   (D1 * L2)  add hl,de and adc a,0                      (result ahl) with l being final ".h" A is starter for e so we now have l spare
487+  6076              ;  D1 * H2                X X      4    de = l * c   (D1 * H2)
488+  6076              ;  L1 * L2                X X      5    hl = h * d   (L1 * L2)
489+  6076              ;  H1 * D2                X X      6    bc = b * e   (H1 * D2)  add hl,de,bc, a (from previous carry)      (result ahl) with l being final "e." h is starter for d and a is starter for c
490+  6076              ;  L1 * H2              X X        7    de = h * c   (L1 * H2)
491+  6076              ;  H1 * L2              X X        8    bc = b * d   (H1 * L2)  add de,bc, ah                              (result ahl) with l being final "d"  h is starter for c and a is starter for b
492+  6076              ;  H1 * H2            X X          9    bc = b * c   (H1 * H2)  add bc,ah,c                                (result ahl) with hl being
493+  6076              ;                     b c d e h l for result we only care about cde.h
494+  6076              ;signed muliply
495+  6076
496+  6076              ; dehl dehl' = 0ehl * 0ehl'
497+  6076
498+  6076
499+  6076              mul24bit:
500+  6076 7B                                   ld      a,e
501+  6077 D9                                   exx
502+  6078 D5                                   push    de
503+  6079 E5                                   push    hl
504+  607A D9                                   exx
505+  607B D1                                   pop     de
506+  607C C1                                   pop     bc
507+  607D 47                                   ld      b,a
508+  607E              ;BH.L by CD.E putting result in BCDE.HL and put the resullt in MulitplyResults then puyll teh actual result to BCDE.HL
509+  607E 7A           mul24:                  ld      a,d                 ; preserve L2 for later
510+  607F 55                                   ld      d,l
511+  6080 ED 53 AF 60                          ld      (.mul24_1+1),de     ; write to D1 * D2 calc 1
512+  6084 54                                   ld      d,h
513+  6085 ED 53 BC 60                          ld      (.mul24_2+1),de     ; write to L1 * D2 calc 2
514+  6089 50                                   ld      d,b
515+  608A ED 53 E0 60                          ld      (.mul24_6+1),de     ; write to H1 * D2 calc 6
516+  608E 57                                   ld      d,a                 ; get back L2
517+  608F 5D                                   ld      e,l
518+  6090 ED 53 C4 60                          ld      (.mul24_3+1),de     ; (D1 * L2)   3
519+  6094 5C                                   ld      e,h
520+  6095 ED 53 D8 60                          ld      (.mul24_5+1),de     ; (L1 * L2)   5
521+  6099 58                                   ld      e,b
522+  609A ED 53 F5 60                          ld      (.mul24_8+1),de     ; (H1 * L2)   8
523+  609E 50 59                                ld      de,bc
524+  60A0 ED 53 02 61                          ld      (.mul24_9+1),de     ; (H1 * H2)   9
525+  60A4 55                                   ld      d,l
526+  60A5 ED 53 D0 60                          ld      (.mul24_4+1),de     ; (D1 * H2)   4
527+  60A9 54                                   ld      d,h
528+  60AA ED 53 ED 60                          ld      (.mul24_7+1),de     ; (L1 * H2)   7
529+  60AE 11 00 00     .mul24_1:               ld      de,$0000            ; D1 * D2 for lowest 16 bites
530+  60B1 ED 30                                mul     de
531+  60B3 ED 53 ED 5D                          ld      (MultiplyResult),de ; save result as we have a completed byte 0 of result
532+  60B7 6A                                   ld      l,d                 ; now we have thbe shifed result for step 2
533+  60B8 26 00                                ld      h,0                 ;
534+  60BA                                      ZeroA                       ; clear accumulator for carry bit
534+  60BA AF          >                        xor a
535+  60BB 11 00 00     .mul24_2:               ld      de,$0000            ; L1 * D2
536+  60BE ED 30                                mul     de
537+  60C0 19                                   add     hl,de               ; hl = (L1 * D2) + (D1*D2)high byte with a carry
538+  60C1 CE 00                                adc     a,0                 ; a holds carry incase of any overflow
539+  60C3 11 00 00     .mul24_3:               ld      de,$0000            ; now add in D1 * L2
540+  60C6 ED 30                                mul     de                  ; so we have a completed byte 1 of result
541+  60C8 19                                   add     hl,de               ;
542+  60C9 8F                                   adc     a,a                 ; So now we hbave byte 1 complete and ahl holding current bytes 321
543+  60CA 22 EE 5D                             ld      (MultiplyResult+1),hl; save byte 1 (in l) of result
544+  60CD 6C                                   ld      l,h                 ; prep carry over for step 4
545+  60CE 67                                   ld      h,a                 ; .
546+  60CF 11 00 00     .mul24_4:               ld      de,$0000            ; now (D1 * H2)
547+  60D2 ED 30                                mul     de                  ; .
548+  60D4                                      ZeroA
548+  60D4 AF          >                        xor a
549+  60D5 19                                   add     hl,de               ; and bring in carry over from step 3
550+  60D6 8F                                   adc     a,a                 ; so ahl is the result
551+  60D7 11 00 00     .mul24_5:               ld      de,$0000            ; now (D1 * H2)
552+  60DA ED 30                                mul     de                  ; .
553+  60DC B7                                   or      a                   ; clear carry flag
554+  60DD 19                                   add     hl,de               ; and bring in carry over from step 4
555+  60DE 8F                                   adc     a,a                 ; so ahl is the result
556+  60DF 11 00 00     .mul24_6:               ld      de,$0000            ; now (D1 * H2)
557+  60E2 ED 30                                mul     de                  ; .
558+  60E4 B7                                   or      a                   ; clear carry flag
559+  60E5 19                                   add     hl,de               ; and bring in carry over from step 5
560+  60E6 8F                                   adc     a,a                 ; so ahl is the result of bytes 654
561+  60E7 22 EF 5D                             ld      (MultiplyResult+2),hl; save byte 2 (in l) of result
562+  60EA 6C                                   ld      l,h                 ; prep carry over for step 7
563+  60EB 67                                   ld      h,a                 ; .
564+  60EC 11 00 00     .mul24_7:               ld      de,$0000            ; now (D1 * H2)
565+  60EF ED 30                                mul     de                  ; .
566+  60F1 B7                                   or      a                   ; clear carry flag
567+  60F2 19                                   add     hl,de               ; and bring in carry over from step 6
568+  60F3 8F                                   adc     a,a                 ; so ahl is the result
569+  60F4 11 00 00     .mul24_8:               ld      de,$0000            ; now (D1 * H2)
570+  60F7 ED 30                                mul     de                  ; .
571+  60F9 B7                                   or      a                   ; clear carry flag
572+  60FA 19                                   add     hl,de               ; and bring in carry over from step 7
573+  60FB 8F                                   adc     a,a                 ; so ahl is the result
574+  60FC 22 F0 5D                             ld      (MultiplyResult+3),hl; save byte 3 (in l) of result
575+  60FF 6C                                   ld      l,h                 ; prep carry over for step 8
576+  6100 67                                   ld      h,a                 ; .
577+  6101 11 00 00     .mul24_9:               ld      de,$0000            ; now (D1 * H2)
578+  6104 ED 30                                mul     de                  ; .
579+  6106 19                                   add     hl,de               ; and bring in carry over from step 7
580+  6107 8F                                   adc     a,a                 ; so ahl is the result
581+  6108 22 F1 5D                             ld      (MultiplyResult+4),hl; save bytes 4 5 of result
582+  610B 2A ED 5D                             ld      hl,(MultiplyResult)
583+  610E ED 5B EF 5D                          ld      de,(MultiplyResult+2)
584+  6112 ED 4B F1 5D                          ld      bc,(MultiplyResult+4)
585+  6116 C9                                   ret
586+  6117
587+  6117
588+  6117              ;  D1 * H2                X X      4    de = l * c   (D1 * H2)
589+  6117              ;  L1 * L2                X X      5    hl = h * d   (L1 * L2)
590+  6117              ;  H1 * D2                X X      6    bc = b * e   (H1 * D2)  add hl,de,bc, a (from previous carry)      (result ahl) with l being final "e." h is starter for d and a is starter for c
591+  6117              ;  L1 * H2              X X        7    de = h * c   (L1 * H2)
592+  6117              ;  H1 * L2              X X        8    bc = b * d   (H1 * L2)  add de,bc, ah                              (result ahl) with l being final "d"  h is starter for c and a is starter for b
593+  6117              ;  H1 * H2            X X          9    bc = b * c   (H1 * H2)  add bc,ah,c                                (result ahl) with hl being
594+  6117
595+  6117
596+  6117              ; optimisations
597+  6117
598+  6117              ;   check for 08.8 * 08.8 as the most common unsigned mulitiply so we can skip all "H" calculations for
599+  6117              ;  D1 * D2                    X X  1    de = l * e   (D1 * D2)
600+  6117              ;  L1 * D2                  X X    2    hl = h * e   (L1 * D2)  e = d, d = 0 add hl,de and move carry to a (result ahl)
601+  6117              ;  D1 * L2                  X X    3    de = l * d   (D1 * L2)  add hl,de and adc a,0                      (result ahl) with l being final ".h" A is starter for e so we now have l spare
602+  6117              ;  D1 * 00                0 0      4    de = l * c   (D1 * H2)
603+  6117              ;  L1 * L2                X X      5    hl = h * d   (L2 * L2)
604+  6117              ;  00 * D2                0 0      6    bc = b * e   (H1 * D2)  add hl, a (from previous carry)            (result <carry>hl) with l being final "e." h is starter for d and a is starter for c
605+  6117              ;  L1 * 00              0 0        7    de = h * c   (L1 * H2)
606+  6117              ;  00 * L2              0 0        8    bc = b * d   (H1 * L2)  ah                                         (result 0ah) with h being final "d"  a is starter for c
607+  6117              ;  00 * 00            0 0          9    bc = b * c   (H1 * L2)  0c                                         (result 0c) w ith hl being
608+  6117              ;                     b c d e h l for result we only care about cde.h
609+  6117              ; Usigned optimisation multipy 0H.L by 0D.E butting result in BCHE.HL
610+  6117              mul16Unsigned:
611+  6117
612+  6117              ;   check for 08.8 * 88.8
613+  6117              ;  D1 * D2                    X X  1    de = l * e   (D1 * D2)
614+  6117              ;  L1 * D2                  X X    2    hl = h * e   (L1 * D2)  e = d, d = 0 add hl,de and move carry to a (result ahl)
615+  6117              ;  D1 * L2                  X X    3    de = l * d   (D1 * L2)  add hl,de and adc a,0                      (result ahl) with l being final ".h" A is starter for e so we now have l spare
616+  6117              ;  D1 * H2                X X      4    de = l * c   (D1 * H2)
617+  6117              ;  L1 * L2                X X      5    hl = h * d   (L2 * L2)  add hl,de,a (from previous carry)          (result ahl) with l being final "e." h is starter for d and a is starter for c
618+  6117              ;  L1 * H2              X X        7    de = h * c   (L1 * H2)  add de, ah                                 (result ahl) with l being final "d"  h is starter for c and a is starter for b
619+  6117              ;                     b c d e h l for result we only care about cde.h
620+  6117
621+  6117              ;   check for 88.8 * 08.8 as the most common unsigned mulitiply so we can skip all "H" calculations for
622+  6117              ;  D1 * D2                    X X  1    de = l * e   (D1 * D2)
623+  6117              ;  L1 * D2                  X X    2    hl = h * e   (L1 * D2)  e = d, d = 0 add hl,de and move carry to a (result ahl)
624+  6117              ;  D1 * L2                  X X    3    de = l * d   (D1 * L2)  add hl,de and adc a,0                      (result ahl) with l being final ".h" A is starter for e so we now have l spare
625+  6117              ;  L1 * L2                X X      5    hl = h * d   (L2 * L2)
626+  6117              ;  H1 * D2                X X      6    bc = b * e   (H1 * D2)  add hl,bc, a (from previous carry)      (result ahl) with l being final "e." h is starter for d and a is starter for c
627+  6117              ;  H1 * L2              X X        8    bc = b * d   (H1 * L2)  add bc, ah                              (result ahl) with l being final "d"  h is starter for c and a is starter for b
628+  6117
629+  6117
630+  6117              ;
631+  6117              ; most likley optimisation will be the value is 8.8 so we can quickly eliminate this
632+  6117              ; then will be a 0.8 when we are doing things like docking so objects will be close and large
633+  6117              ; 8.0 will be unlikley so we will just optimise on 78.8, 8.8, 0.8
634+  6117              ; we can also optimise code size if only one side is 08.8 etc by swapping over BHL and CDE as needed
635+  6117 78           BCDEHLequBHLmulCDEs:    ld      a,b
636+  6118 A9                                   xor     c
637+  6119 E6 80                                and     0x80
638+  611B CB B8                                res     7,b                     ; clear sign bits
639+  611D CB B9                                res     7,c                     ; res does not affect flags
640+  611F CA 2A 61                             jp      z,BCDEHLequBHLmulCDEu   ; can just jp as is also sets A to 0 for sign
641+  6122 CD 2A 61     .BCDEHLNegative:        call    BCDEHLequBHLmulCDEu     ; do unsigned maths
642+  6125 3E 80                                ld      a,0x80                  ; set a = sign bit
643+  6127 CB F8                                set     7,b                     ; and set sign bit on b
644+  6129 C9                                   ret
645+  612A
646+  612A              BCDEHLequBHLmulCDEu:    ZeroA
646+  612A AF          >                        xor a
647+  612B B0                                   or      b
648+  612C CA 37 61                             jp      z,.X2Zero               ; first pass check X2 = 0?
649+  612F              .X2checkY2:             ZeroA                           ; now check Y2 = 0?
649+  612F AF          >                        xor a
650+  6130 B1                                   or      c
651+  6131 CA B1 61                             jp      z,BCDEHLequ24mul24u     ; fro nwo ignore optimsation X2 is non 0, Y2 is zero eliminating 3 mulitplies
652+  6134 C3 B1 61     .Do24BitMul:            jp      BCDEHLequ24mul24u       ; X2 and Y2 are non zero so in most cases it will be a regular 78.8 x 78.8 so just do 24 bit mul
653+  6137 B1           .X2Zero:                or      c
654+  6138 CA 3E 61                             jp      z,.checkFor8BitMul      ; X2 and Y2 are both 0 eliminating 5 multiplies with 8.8 now check for 0.8
655+  613B C3 B1 61     .Do16Bitmul24Bit:       jp      BCDEHLequ24mul24u       ; for now ignore optimisation X2 is zero Y2 is non zero eliminating 3 muliplies
656+  613E B4           .checkFor8BitMul:       or      h
657+  613F C2 46 61     .Do16BitMul:            jp      nz, BCHLDEequ16mul16u   ; X1 is non zero so we will assume Y1 is also non zero and do a 16 bit muliply
658+  6142 B2           .X2X1Zero:              or      d
659+  6143 CA A7 61     .Do8BitMul              jp      z, BCHLDEequ8mul8u      ; X1 and Y1 are both zero so its now just a simple mul de
660+  6146                                      ; else we fall into a 16 bit multiply
661+  6146              BCHLDEequ16mul16u:
662+  6146 7D           .PrepSelfModifying:     ld      a,l
663+  6147 32 64 61                             ld      (.Y1mulX0L+1),a         ; Y1mulX0 L (we can skip X0mulY0 as we will already have L)
664+  614A 7A                                   ld      a,d
665+  614B 32 62 61                             ld      (.Y1mulX0D+1),a         ; Y1mulX0 D
666+  614E 32 96 61                             ld      (.X1mulY1D+1),a         ; X1mulY1 D
667+  6151 7B                                   ld      a,e
668+  6152 32 7B 61                             ld      (.X1mulY0E+1),a         ; X1mulY0 E (we can skip X0mulY0 as we will already have E)
669+  6155 78                                   ld      a,b
670+  6156 7C                                   ld      a,h
671+  6157 32 79 61                             ld      (.X1mulY0+1),a          ; X1mulY0 H
672+  615A 32 94 61                             ld      (.X1mulY1H+1),a         ; X1mulY1 H
673+  615D                                      ; now we don't have to worry about setting up multiplies, just the adds and result
674+  615D                                      ; we can freely use AF, BC, HL, IX, IY and alternate registers
675+  615D              .X0mulY0
675+  615D 55                          ld      d,l                     ; HL = L * E
676+  615E ED 30                                mul     de                      ; .
677+  6160 EB                                   ex      de,hl                   ; .
678+  6161              .Y1mulX0:                                               ; [L*D]
679+  6161 16 00        .Y1mulX0D:              ld      d,0x00
680+  6163 1E 00        .Y1mulX0L:              ld      e,0x00                  ; DE = L * D
681+  6165 ED 30                                mul     de                      ;
682+  6167                                      ; DEHL = 00HL  + 0[L*D]0        ; as 0FF+FF0 is a 3 byte result + carry bit
683+  6167 EB           .AHLequ0HLaddDE0:       ex      de,hl                   ; AHL = [L*D][0], DE = [0][L*E]
684+  6168                                      ZeroA                           ; A = 0 and clear carry Flag
684+  6168 AF          >                        xor a
685+  6169 7C                                   ld      a,h                     ; .
686+  616A 65                                   ld      h,l                     ; .
687+  616B 2E 00                                ld      l,0                     ; .
688+  616D ED 5A                                adc     hl,de                   ; carryHL  = L0 + DE
689+  616F CE 00                                adc     a,0                     ; <cary>A = H+carry so <carry>AHL = [L*D][0] + [0][L*E]
690+  6171 5F                                   ld      e,a                     ; .
691+  6172 3E 00                                ld      a,0                     ; .
692+  6174 8F                                   adc     a,a                     ; . *as a is 0 we can do this and save 3 T states
693+  6175 16 00                                ld      d,0                     ; now DEHL = [L*D][0] + [0][L*E]
694+  6177 D9                                   exx                             ; now 'DEHL = [L*D][0] + [0][L*E]
695+  6178              .X1mulY0:               ; [H*E]
696+  6178 16 00        .X1mulY0H:              ld      d,0x00
697+  617A 1E 00        .X1mulY0E:              ld      e,0x00
698+  617C ED 30                                mul     de                      ; DE = [H * E]
699+  617E                                      ;break
700+  617E                                      ; DEHL = DEHL + 0[H*E]0 = DEH + 0[H*E] or  <carry>HL += E0 <carry?> DE += 0H + carry
701+  617E D5                                   push    de                      ; Stack + 1
702+  617F D9                                   exx                             ; DEHL = previous [0][L*D][0] + [00][L*E]
703+  6180 C1                                   pop     bc                      ; Stack + 0
704+  6181                                      ClearCarryFlag                  ; 'DEHL = DEHL + [00]BC (or [0][H*E][0]
704+  6181 B7          >                        or a
705+  6182 78                                   ld      a,b                     ; copy b as we need it again
706+  6183 41                                   ld      b,c                     ; now bc = E[0] from calc above
707+  6184 0E 00                                ld      c,0                     ; .
708+  6186 ED 4A                                adc     hl,bc                   ; HL += E[0] from calc above
709+  6188 06 00                                ld      b,0                     ; bc = [0]D from calc above
710+  618A 4F                                   ld      c,a                     ;
711+  618B EB                                   ex      de,hl                   ; get de into HL for add
712+  618C ED 4A                                adc     hl,bc                   ;
713+  618E EB                                   ex      de,hl                   ; get DEHL back into correct order
714+  618F 01 00 00                             ld      bc,0                    ; as we don't have X2Y2 we just set BC to 0
715+  6192 D9                                   exx                             ; now P3 P2 are loaded with working values, 'HL holds P1 P0 that are now fixed values
716+  6193              .X1mulY1:               ; [H*D]
717+  6193 16 00        .X1mulY1H:              ld      d,0x00                  ; X2mulY0 H
718+  6195 1E 00        .X1mulY1D:              ld      e,0x00                  ; X2mulY0 E
719+  6197 ED 30                                mul     de
720+  6199                                      ;  CDE   = CDE   + [H*D]
721+  6199 D5                                   push    de                      ; Stack + 1 swap in results
722+  619A D9                                   exx                             ; BC = [H*D]
723+  619B C1                                   pop     bc                      ; Stack + 0
724+  619C EB                                   ex      de,hl                   ; DE = DE + [H*D]
725+  619D                                      ZeroA                           ; A = 0 and clear carry Flag
725+  619D AF          >                        xor a
726+  619E ED 4A                                adc     hl,bc                   ; .
727+  61A0 EB                                   ex      de,hl                   ; get HL and DE back to correct positions (we may leave them like this later for optimisation but debug first)
728+  61A1 89                                   adc     a,c                     ; a += c + carry
729+  61A2 4F                                   ld      c,a                     ; so now we have 'CDE.HL as results
730+  61A3                                      ZeroA                           ; assume sign in A is positive
730+  61A3 AF          >                        xor a
731+  61A4 06 00                                ld      b,0                     ; and we need b to be 0
732+  61A6 C9                                   ret
733+  61A7
734+  61A7                                      ; 8 bit multiply
735+  61A7 55           BCHLDEequ8mul8u:        ld      d,l                     ; so now BCHLDE = 00L * 00D
736+  61A8 ED 30                                mul     de                      ; so we just do L*D which loads de
737+  61AA EB                                   ex      de,hl
738+  61AB                                      ZeroA                           ; and set BCHL to 0
738+  61AB AF          >                        xor a
739+  61AC 47                                   ld      b,a
740+  61AD 4F                                   ld      c,a
741+  61AE 57                                   ld      d,a
742+  61AF 5F                                   ld      e,a
743+  61B0 C9                                   ret
744+  61B1
745+  61B1              BCDEHLequ24mul24u:
746+  61B1 7D           .PrepSelfModifying:     ld      a,l
747+  61B2 32 EE 61                             ld      (.Y1mulX0L+1),a         ; Y1mulX0 L (we can skip X0mulY0 as we will already have L)
748+  61B5 32 2E 62                             ld      (.Y2mulX0L+1),a         ; Y2mulX0 L
749+  61B8 7A                                   ld      a,d
750+  61B9 32 EC 61                             ld      (.Y1mulX0D+1),a         ; Y1mulX0 D
751+  61BC 32 3F 62                             ld      (.X1mulY1D+1),a         ; X1mulY1 D
752+  61BF 32 50 62                             ld      (.X2mulY1D+1),a         ; X2mulY1 D
753+  61C2 7B                                   ld      a,e
754+  61C3 32 05 62                             ld      (.X1mulY0E+1),a         ; X1mulY0 E (we can skip X0mulY0 as we will already have E)
755+  61C6 32 1D 62                             ld      (.X2mulY0E+1),a         ; X2mulY0 E
756+  61C9 78                                   ld      a,b
757+  61CA 32 1B 62                             ld      (.X2mulY0B+1),a         ; X2mulY0 B
758+  61CD 32 4E 62                             ld      (.X2mulY1B+1),a         ; X2mulY1 B
759+  61D0 32 78 62                             ld      (.X2mulY2B+1),a         ; X2mulY2 B
760+  61D3 7C                                   ld      a,h
761+  61D4 32 03 62                             ld      (.X1mulY0+1),a          ; X1mulY0 H
762+  61D7 32 66 62                             ld      (.Y2mulX1H+1),a         ; Y2mulX1 H
763+  61DA 32 3D 62                             ld      (.X1mulY1H+1),a         ; X1mulY1 H
764+  61DD 79                                   ld      a,c
765+  61DE 32 2C 62                             ld      (.Y2mulX0C+1),a         ; Y2mulX0 C
766+  61E1 32 64 62                             ld      (.Y2mulX1C+1),a         ; Y2mulX1 C
767+  61E4 32 7A 62                             ld      (.X2mulY2C+1),a         ; X2mulY2 C
768+  61E7                                      ; now we don't have to worry about setting up multiplies, just the adds and result
769+  61E7                                      ; we can freely use AF, BC, HL, IX, IY and alternate registers
770+  61E7              .X0mulY0
770+  61E7 55                          ld      d,l                     ; HL = L * E
771+  61E8 ED 30                                mul     de                      ; .
772+  61EA EB                                   ex      de,hl                   ; .
773+  61EB              .Y1mulX0:                                               ; [L*D]
774+  61EB 16 00        .Y1mulX0D:              ld      d,0x00
775+  61ED 1E 00        .Y1mulX0L:              ld      e,0x00                  ; DE = L * D
776+  61EF ED 30                                mul     de                      ;
777+  61F1                                      ; DEHL = 00HL  + 0[L*D]0        ; as 0FF+FF0 is a 3 byte result + carry bit
778+  61F1 EB           .AHLequ0HLaddDE0:       ex      de,hl                   ; AHL = [L*D][0], DE = [0][L*E]
779+  61F2                                      ZeroA                           ; A = 0 and clear carry Flag
779+  61F2 AF          >                        xor a
780+  61F3 7C                                   ld      a,h                     ; .
781+  61F4 65                                   ld      h,l                     ; .
782+  61F5 2E 00                                ld      l,0                     ; .
783+  61F7 ED 5A                                adc     hl,de                   ; carryHL  = L0 + DE
784+  61F9 CE 00                                adc     a,0                     ; <cary>A = H+carry so <carry>AHL = [L*D][0] + [0][L*E]
785+  61FB 5F                                   ld      e,a                     ; .
786+  61FC 3E 00                                ld      a,0                     ; .
787+  61FE 8F                                   adc     a,a                     ; . *as a is 0 we can do this and save 3 T states
788+  61FF 16 00                                ld      d,0                     ; now DEHL = [L*D][0] + [0][L*E]
789+  6201 D9                                   exx                             ; now 'DEHL = [L*D][0] + [0][L*E]
790+  6202              .X1mulY0:               ; [H*E]
791+  6202 16 00        .X1mulY0H:              ld      d,0x00
792+  6204 1E 00        .X1mulY0E:              ld      e,0x00
793+  6206 ED 30                                mul     de                      ; DE = [H * E]
794+  6208                                      ;break
795+  6208                                      ; DEHL = DEHL + 0[H*E]0 = DEH + 0[H*E] or  <carry>HL += E0 <carry?> DE += 0H + carry
796+  6208 D5                                   push    de                      ; Stack + 1
797+  6209 D9                                   exx                             ; DEHL = previous [0][L*D][0] + [00][L*E]
798+  620A C1                                   pop     bc                      ; Stack + 0
799+  620B                                      ClearCarryFlag                  ; 'DEHL = DEHL + [00]BC (or [0][H*E][0]
799+  620B B7          >                        or a
800+  620C 78                                   ld      a,b                     ; copy b as we need it again
801+  620D 41                                   ld      b,c                     ; now bc = E[0] from calc above
802+  620E 0E 00                                ld      c,0                     ; .
803+  6210 ED 4A                                adc     hl,bc                   ; HL += E[0] from calc above
804+  6212 06 00                                ld      b,0                     ; bc = [0]D from calc above
805+  6214 4F                                   ld      c,a                     ;
806+  6215 EB                                   ex      de,hl                   ; get de into HL for add
807+  6216 ED 4A                                adc     hl,bc                   ;
808+  6218 EB                                   ex      de,hl                   ; get DEHL back into correct order
809+  6219 D9                                   exx                             ; now P3 P2 are loaded with working values, 'HL holds P1 P0 that are now fixed values
810+  621A              .X2mulY0                ; [B*E]
811+  621A 16 00        .X2mulY0B:              ld      d,0x00                  ; X2mulY0 B
812+  621C 1E 00        .X2mulY0E:              ld      e,0x00                  ; X2mulY0 E
813+  621E ED 30                                mul     de
814+  6220                                      ;  CDE   = DE   + [B*E]
815+  6220 D5                                   push    de                      ; swap in results Stack + 1
816+  6221 D9                                   exx                             ; BC = [B*E]
817+  6222 C1                                   pop     bc                      ; Stack + 0
818+  6223 EB                                   ex      de,hl                   ; DE = DE + [B*E]
819+  6224                                      ZeroA                           ; A = 0 and clear carry Flag
819+  6224 AF          >                        xor a
820+  6225 ED 4A                                adc     hl,bc                   ; .
821+  6227 EB                                   ex      de,hl                   ; get HL and DE back to correct positions (we may leave them like this later for optimisation but debug first)
822+  6228 8F                                   adc     a,a                     ; a += 0 + carry
823+  6229 4F                                   ld      c,a                     ; so now we have 'CDE.HL as results
824+  622A D9                                   exx                             ; .
825+  622B              .Y2mulX0:               ; [L*C]
826+  622B 16 00        .Y2mulX0C:              ld      d,0x00                  ; X2mulY0 C
827+  622D 1E 00        .Y2mulX0L:              ld      e,0x00                  ; X2mulY0 L
828+  622F ED 30                                mul     de
829+  6231                                      ;  CDE   = CDE   + [L*C]
830+  6231 D5                                   push    de                      ; Stack + 1 swap in results
831+  6232 D9                                   exx                             ; BC = [L*C]
832+  6233 C1                                   pop     bc                      ; Stack + 0
833+  6234 EB                                   ex      de,hl                   ; DE = DE + [L*C]
834+  6235                                      ZeroA                           ; A = 0 and clear carry Flag
834+  6235 AF          >                        xor a
835+  6236 ED 4A                                adc     hl,bc                   ; .
836+  6238 EB                                   ex      de,hl                   ; get HL and DE back to correct positions (we may leave them like this later for optimisation but debug first)
837+  6239 89                                   adc     a,c                     ; a += c + carry
838+  623A 4F                                   ld      c,a                     ; so now we have 'CDE.HL as results
839+  623B D9                                   exx                             ; .
840+  623C              .X1mulY1:               ; [H*D]
841+  623C 16 00        .X1mulY1H:              ld      d,0x00                  ; X2mulY0 H
842+  623E 1E 00        .X1mulY1D:              ld      e,0x00                  ; X2mulY0 E
843+  6240 ED 30                                mul     de
844+  6242                                      ;  CDE   = CDE   + [H*D]
845+  6242 D5                                   push    de                      ; Stack + 1 swap in results
846+  6243 D9                                   exx                             ; BC = [H*D]
847+  6244 C1                                   pop     bc                      ; Stack + 0
848+  6245 EB                                   ex      de,hl                   ; DE = DE + [H*D]
849+  6246                                      ZeroA                           ; A = 0 and clear carry Flag
849+  6246 AF          >                        xor a
850+  6247 ED 4A                                adc     hl,bc                   ; .
851+  6249 EB                                   ex      de,hl                   ; get HL and DE back to correct positions (we may leave them like this later for optimisation but debug first)
852+  624A 89                                   adc     a,c                     ; a += c + carry
853+  624B 4F                                   ld      c,a                     ; so now we have 'CDE.HL as results
854+  624C D9                                   exx                             ; .
855+  624D              .X2mulY1:               ; [B*D]
856+  624D 16 00        .X2mulY1B               ld      d,0x00                  ; X2mulY2 B
857+  624F 1E 00        .X2mulY1D:              ld      e,0x00                  ; X2mulY0 E
858+  6251 ED 30                                mul     de
859+  6253                                      ; BCD    = CD   + [B*D]         now is startes to get more tricky as we are spanning register pairs
860+  6253 D5                                   push    de                      ; Stack + 1 swap in results
861+  6254 D9                                   exx                             ; BC = [H*D]
862+  6255 E5 DD E1                             ld      ix,hl                   ; preserve HL during calculations
863+  6258 61                                   ld      h,c                     ;
864+  6259 6A                                   ld      l,d                     ;
865+  625A C1                                   pop     bc                      ;
866+  625B                                      ZeroA                           ; A = 0 and clear carry Flag
866+  625B AF          >                        xor a
867+  625C ED 4A                                adc     hl,bc                   ; .
868+  625E 4C                                   ld      c,h
869+  625F 55                                   ld      d,l
870+  6260 8F                                   adc     a,a                     ; a += c + carry
871+  6261 47                                   ld      b,a                     ; so now we have 'BCDE.HL as results
872+  6262 D9                                   exx                             ; .
873+  6263              .Y2mulX1:               ; [H*C]
874+  6263 16 00        .Y2mulX1C:              ld      d,0x00                  ; X2mulY0 E
875+  6265 1E 00        .Y2mulX1H:              ld      e,0x00                  ; X2mulY0 E
876+  6267 ED 30                                mul     de
877+  6269                                      ; BCD    = CD   + [H*C]
878+  6269 D5                                   push    de                      ; Stack + 1 swap in results
879+  626A D9                                   exx                             ; BC = [H*C]
880+  626B 61                                   ld      h,c
881+  626C 6A                                   ld      l,d
882+  626D C1                                   pop     bc                      ; Stack + 0
883+  626E                                      ZeroA                           ; A = 0 and clear carry Flag
883+  626E AF          >                        xor a
884+  626F ED 4A                                adc     hl,bc                   ; .
885+  6271 4C                                   ld      c,h
886+  6272 55                                   ld      d,l
887+  6273 8F                                   adc     a,a                     ; a += c + carry
888+  6274 47                                   ld      b,a                     ; so now we have 'BCDE.HL as results
889+  6275 C5                                   push    bc                      ; get bc on stack for final add Stack + 1
890+  6276 D9                                   exx                             ; .
891+  6277              .X2mulY2:               ; [B*C]
892+  6277 16 00        .X2mulY2B               ld      d,0x00                  ; X2mulY2 B
893+  6279 1E 00        .X2mulY2C               ld      e,0x00                  ; X2mulY2 C
894+  627B ED 30                                mul     de
895+  627D                                      ; BC     = BC   + [B*C]
896+  627D E1                                   pop     hl                      ; Get Saved BC into HL
897+  627E 19                                   add     hl,de                   ; hl = bc + [B*C]
898+  627F E5                                   push    hl                      ; and save on stack to read into bc
899+  6280 D9                                   exx                             ; get back result
900+  6281 DD E5 E1                             ld      hl,ix                   ; restore hl we saved earlier
901+  6284 C1                                   pop     bc                      ; now we have 'BCDE.HL as final result
902+  6285                                      ZeroA                           ; assume sign in A is positive
902+  6285 AF          >                        xor a
903+  6286 C9                                   ret
904+  6287
# file closed: asm_multiply24.asm
223   6287
224   6287                  SAVENEX OPEN "m24test.nex", EliteNextStartup , TopOfStack
225   6287                  SAVENEX CFG  0,0,0,1
226   6287                  SAVENEX AUTO
227   6287                  SAVENEX CLOSE
228   6287
229   6287
# file closed: m24test.asm
