# file opened: maths24test.asm
  1   0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
  2   0000                              DISPLAY "maths24test test"
  3   0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
  4   0000
  5   0000
  6   0000                  DEFINE DEBUGMODE 1
  7   0000                  DEVICE ZXSPECTRUMNEXT
  8   0000                  SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
  9   0000                  DEFINE  TESTING_MATHS_DIVIDE 1
 10   0000               CSPECTMAP maths24test.map
 11   0000               OPT --zxnext=cspect --syntax=a --reversepop
 12   0000                              DEFINE  SOUNDPACE 3
 13   0000              ;                DEFINE  ENABLE_SOUND 1
 14   0000                             DEFINE     MAIN_INTERRUPTENABLE 1
 15   0000              ;               DEFINE INTERRUPT_BLOCKER 1
 16   0000              DEBUGSEGSIZE   equ 1
 17   0000              DEBUGLOGSUMMARY equ 1
 18   0000              ;DEBUGLOGDETAIL equ 1
 19   0000
 20   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 21   0000              ; Game Defines
 22   0000              ScreenLocal      EQU 0
 23   0000              ScreenGalactic   EQU ScreenLocal + 1
 24   0000              ScreenMarket     EQU ScreenGalactic + 1
 25   0000              ScreenMarketDsp  EQU ScreenMarket + 1
 26   0000              ScreenStatus     EQU ScreenMarketDsp + 1
 27   0000              ScreenInvent     EQU ScreenStatus + 1
 28   0000              ScreenPlanet     EQU ScreenInvent + 1
 29   0000              ScreenEquip      EQU ScreenPlanet + 1
 30   0000              ScreenLaunch     EQU ScreenEquip + 1
 31   0000              ScreenFront      EQU ScreenLaunch + 1
 32   0000              ScreenAft        EQU ScreenFront+1
 33   0000              ScreenLeft       EQU ScreenAft+1
 34   0000              ScreenRight      EQU ScreenLeft+1
 35   0000              ScreenDocking    EQU ScreenRight+1
 36   0000              ScreenHyperspace EQU ScreenDocking+1
 37   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 38   0000              ; Colour Defines
 39   0000              SignMask8Bit		equ %01111111
 40   0000              SignMask16Bit		equ %0111111111111111
 41   0000              SignOnly8Bit		equ $80
 42   0000              SignOnly16Bit		equ $8000
 43   0000
 44   0000              Bit7Only            equ %10000000
 45   0000              Bit6Only            equ %01000000
 46   0000              Bit5Only            equ %00100000
 47   0000              Bit4Only            equ %00010000
 48   0000              Bit3Only            equ %00001000
 49   0000              Bit2Only            equ %00000100
 50   0000              Bit1Only            equ %00000010
 51   0000              Bit0Only            equ %00000001
 52   0000              Bit7Clear           equ %01111111
 53   0000              Bit6Clear           equ %10111111
 54   0000              Bit5Clear           equ %11011111
 55   0000              Bit4Clear           equ %11101111
 56   0000              Bit3Clear           equ %11110111
 57   0000              Bit2Clear           equ %11111011
 58   0000              Bit1Clear           equ %11111101
 59   0000              Bit0Clear           equ %11111110
 60   0000              ConstPi				equ $80
 61   0000              ConstNorm           equ 197
 62   0000
 63   0000
 64   0000
 65   0000                                      INCLUDE "../../Macros/jumpMacros.asm"
# file opened: ../../Macros/jumpMacros.asm
  1+  0000              JumpIfHLNegative:       MACRO target
  2+  0000 ~                                    bit     7,h
  3+  0000 ~                                    jp      nz,target
  4+  0000                                      ENDM
  5+  0000
  6+  0000              JumpIfPositive:	        MACRO target
  7+  0000 ~                                    jp		p, target
  8+  0000                                      ENDM
  9+  0000
 10+  0000              JumpIfNegative:	        MACRO target
 11+  0000 ~                                    jp		m, target
 12+  0000                                      ENDM
 13+  0000
 14+  0000
 15+  0000              JumpIfUnderflow:	    MACRO target
 16+  0000 ~                                    jp		po, target
 17+  0000                                      ENDM
 18+  0000
 19+  0000              JumpIfOverflow:	        MACRO target
 20+  0000 ~                                    jp		po, target
 21+  0000                                      ENDM
 22+  0000
 23+  0000
 24+  0000              JumpIfNotZero:	        MACRO target
 25+  0000 ~                                    jp	nz,target
 26+  0000                                      ENDM
 27+  0000
 28+  0000              JumpIfZero:	            MACRO target
 29+  0000 ~                                    jp	z,target
 30+  0000                                      ENDM
 31+  0000
 32+  0000              ;.. Bit routines
 33+  0000              JumpOnLeadSignSet:      MACRO   reg, target
 34+  0000 ~                                    ld      a,reg
 35+  0000 ~                                    and     SignOnly8Bit
 36+  0000 ~                                    jp      nz,target
 37+  0000                                      ENDM
 38+  0000
 39+  0000              JumpOnLeadSignClear:    MACRO   reg, target
 40+  0000 ~                                    ld      a,reg
 41+  0000 ~                                    and     SignOnly8Bit
 42+  0000 ~                                    jp      z,target
 43+  0000                                      ENDM
 44+  0000
 45+  0000              JumpOnLeadSignSetA:     MACRO   target
 46+  0000 ~                                    and     SignOnly8Bit
 47+  0000 ~                                    jp      nz,target
 48+  0000                                      ENDM
 49+  0000
 50+  0000              JumpOnLeadSignClearA:   MACRO   target
 51+  0000 ~                                    and     SignOnly8Bit
 52+  0000 ~                                    jp      z,target
 53+  0000                                      ENDM
 54+  0000
 55+  0000              JumpOnMemBitSet:        MACRO mem, bitnbr, target
 56+  0000 ~                                    ld      a,(mem)
 57+  0000 ~                                    bit 	bitnbr,a
 58+  0000 ~                                    jp      nz,target
 59+  0000                                      ENDM
 60+  0000
 61+  0000              JumpOnMemBitClear:      MACRO mem, bitnbr, target
 62+  0000 ~                                    ld      a,(mem)
 63+  0000 ~                                    bit 	bitnbr,a
 64+  0000 ~                                    jp      z,target
 65+  0000                                      ENDM
 66+  0000
 67+  0000
 68+  0000              JumpOnABitSet:          MACRO   bitnbr, target
 69+  0000 ~                                    bit 	bitnbr, a
 70+  0000 ~                                    jp      nz,target
 71+  0000                                      ENDM
 72+  0000
 73+  0000              JumpOnABitClear:        MACRO   bitnbr, target
 74+  0000 ~                                    bit 	bitnbr, a
 75+  0000 ~                                    jp      z,target
 76+  0000                                      ENDM
 77+  0000
 78+  0000              JumpOnABit5Set:         MACRO   target
 79+  0000 ~                                    and     Bit5Only
 80+  0000 ~                                    jp      nz,target
 81+  0000                                      ENDM
 82+  0000
 83+  0000              JumpOnABit5Clear:       MACRO   target
 84+  0000 ~                                    and     Bit5Only
 85+  0000 ~                                    jp      z,target
 86+  0000                                      ENDM
 87+  0000
 88+  0000              JumpOnBitMaskSet:       MACRO   bitmask, target
 89+  0000 ~                                    and     bitmask
 90+  0000 ~                                    jp      nz,target
 91+  0000                                      ENDM
 92+  0000
 93+  0000              JumpOnBitMaskClear:     MACRO   bitmask, target
 94+  0000 ~                                    and     bitmask
 95+  0000 ~                                    jp      z,target
 96+  0000                                      ENDM
 97+  0000
 98+  0000              JumpOnMemBitMaskSet:    MACRO   mem, bitmask, target
 99+  0000 ~                                    ld      a,(mem)
100+  0000 ~                                    and     bitmask
101+  0000 ~                                    jp      nz,target
102+  0000                                      ENDM
103+  0000
104+  0000              JumpOnMemBitMaskClear:  MACRO   mem, bitmask, target
105+  0000 ~                                    ld      a,(mem)
106+  0000 ~                                    and     bitmask
107+  0000 ~                                    jp      z,target
108+  0000                                      ENDM
109+  0000
110+  0000              JumpOnBitSet:           MACRO  reg, bitnbr, target
111+  0000 ~                                    bit 	bitnbr,reg
112+  0000 ~                                    jp      nz,target
113+  0000                                      ENDM
114+  0000
115+  0000              JumpOnBitClear:         MACRO  reg, bitnbr, target
116+  0000 ~                                    bit 	bitnbr,reg
117+  0000 ~                                    jp      z,target
118+  0000                                      ENDM
119+  0000
120+  0000              ; Comparison Routines
121+  0000              JumpIfAGTEusng:         MACRO
122+  0000 ~                                    jp		nc,target
123+  0000                                      ENDM
124+  0000
125+  0000              JumpIfAGTENusng:        MACRO reg,target
126+  0000 ~                                    cp     reg
127+  0000 ~                                    jp		nc,target
128+  0000                                      ENDM
129+  0000
130+  0000              JumpIfAGTEMemusng:      MACRO mem,target
131+  0000 ~                                    ld      hl,mem
132+  0000 ~                                    cp      (hl)
133+  0000 ~                                    jp		nc,target
134+  0000                                      ENDM
135+  0000              JumpIfMemGTENusng:      MACRO mem, value, target
136+  0000 ~                                    ld     a,(mem)
137+  0000 ~                                    cp     value
138+  0000 ~                                    jp	  nc,target
139+  0000                                      ENDM
140+  0000
141+  0000              JumpIfMemGTEMemusng:    MACRO mem, address, target
142+  0000 ~                                    ld   a,(mem)
143+  0000 ~                                    ld   hl,address
144+  0000 ~                                    cp   (hl)
145+  0000 ~                                    jp	  nc,target
146+  0000                                      ENDM
147+  0000
148+  0000              JumpIfMemEqMemusng:     MACRO mem, address, target
149+  0000 ~                                    ld   a,(mem)
150+  0000 ~                                    ld   hl,address
151+  0000 ~                                    cp   (hl)
152+  0000 ~                                    jp	  z,target
153+  0000                                      ENDM
154+  0000
155+  0000              JumpIfMemNeMemusng:     MACRO mem, address, target
156+  0000 ~                                    ld   a,(mem)
157+  0000 ~                                    ld   hl,address
158+  0000 ~                                    cp   (hl)
159+  0000 ~                                    jp	  nz,target
160+  0000                                      ENDM
161+  0000
162+  0000              JumpIfMemTrue:          MACRO mem, target
163+  0000 ~                                    ld      a,(mem)
164+  0000 ~                                    and     a
165+  0000 ~                                    jp      z, target
166+  0000                                      ENDM
167+  0000
168+  0000              JumpIfMemFalse:         MACRO mem, target
169+  0000 ~                                    ld      a,(mem)
170+  0000 ~                                    and     a
171+  0000 ~                                    jp      nz, target
172+  0000                                      ENDM
173+  0000
174+  0000              JumpIfATrue:            MACRO target
175+  0000 ~                                    and     a
176+  0000 ~                                    jp      z, target
177+  0000                                      ENDM
178+  0000
179+  0000              JumpIfAFalse:           MACRO target
180+  0000 ~                                    and     a
181+  0000 ~                                    jp      nz, target
182+  0000                                      ENDM
183+  0000
184+  0000              JumpIfANotFalse:        MACRO target
185+  0000 ~                                    cp      $FF
186+  0000 ~                                    jp      nz, target
187+  0000                                      ENDM
188+  0000
189+  0000              ;-- Less than Macros -------------------------------------------
190+  0000              JumpIfALTMemHLusng:     MACRO target
191+  0000 ~                                    cp    (hl)
192+  0000 ~                                    jp	  c,target
193+  0000                                      ENDM
194+  0000
195+  0000              JumpIfRegLTE:           MACRO   reg, value, target
196+  0000 ~                                    ld      a,reg
197+  0000 ~                                    cp      value
198+  0000 ~                                    jp	    z,target
199+  0000 ~                                    jp		c, target
200+  0000                                      ENDM
201+  0000
202+  0000              JumpIfALTMemusng:       MACRO mem,target
203+  0000 ~                                    ld      hl,mem
204+  0000 ~                                    cp      (hl)
205+  0000 ~                                    jp		c,target
206+  0000                                      ENDM
207+  0000
208+  0000
209+  0000              JumpIfALTusng:          MACRO target
210+  0000 ~                                    jp		c,target
211+  0000                                      ENDM
212+  0000
213+  0000              JumpIfALTNusng:         MACRO value, target
214+  0000 ~                                    cp      value
215+  0000 ~                                    jp		c, target
216+  0000                                      ENDM
217+  0000
218+  0000              JumpIfALTNsigned:       MACRO   value, target
219+  0000 ~                                    cp      value
220+  0000 ~                                    jp      m,.SignSet
221+  0000 ~            .SignClear:             jp      pe,target       ; Sign (0), P/V (1)
222+  0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (0)
223+  0000 ~            .SignSet:               jp      po,target
224+  0000 ~            .CheckComplete:
225+  0000                                      ENDM
226+  0000
227+  0000              JumpIfMemLTNusng:       MACRO mem, value, target
228+  0000 ~                                    ld      a,(mem)
229+  0000 ~                                    cp      value
230+  0000 ~                                    jp	  c,target
231+  0000                                      ENDM
232+  0000
233+  0000              JumpIfMemLTMemusng:     MACRO mem, value, target
234+  0000 ~                                    ld    a,(mem)
235+  0000 ~                                    ld    hl,value
236+  0000 ~                                    cp    (hl)
237+  0000 ~                                    jp	  c,target
238+  0000                                      ENDM
239+  0000              ;-- ------------------------------------------------------------
240+  0000              JumpIfAGTENsigned       MACRO   value, target
241+  0000 ~                                    cp      value
242+  0000 ~                                    jp      m,.SignSet
243+  0000 ~            .SignClear:             jp      po,target       ; Sign (0), P/V (0)
244+  0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (1)
245+  0000 ~            .SignSet:               jp      pe,target
246+  0000 ~            .CheckComplete:
247+  0000                                      ENDM
248+  0000
249+  0000              JumpIfMemEqNusng:       MACRO mem,value,target
250+  0000 ~                                    ld  a,(mem)
251+  0000 ~                                    cp  value
252+  0000 ~                                    jp  z,target
253+  0000                                      ENDM
254+  0000
255+  0000              JumpIfMemNeNusng:       MACRO mem,value,target
256+  0000 ~                                    ld  a,(mem)
257+  0000 ~                                    cp  value
258+  0000 ~                                    jp  nz,target
259+  0000                                      ENDM
260+  0000
261+  0000              JumpIfMemZero:          MACRO mem,target
262+  0000 ~                                    ld  a,(mem)
263+  0000 ~                                    and a
264+  0000 ~                                    jp  z,target
265+  0000                                      ENDM
266+  0000
267+  0000              JumpIfMemNotZero:       MACRO mem,target
268+  0000 ~                                    ld  a,(mem)
269+  0000 ~                                    and a
270+  0000 ~                                    jp  nz,target
271+  0000                                      ENDM
272+  0000
273+  0000              JumpIfANENusng:         MACRO value, target
274+  0000 ~                                    cp     value
275+  0000 ~                                    jp      nz,target
276+  0000                                      ENDM
277+  0000
278+  0000              JumpIfANEquNusng:       MACRO value, target
279+  0000 ~                                    cp     value
280+  0000 ~                                    jp     z,target
281+  0000                                      ENDM
282+  0000
283+  0000              JumpIfANEMemusng:       MACRO  value, target
284+  0000 ~                                    ld    hl,value
285+  0000 ~                                    cp    (hl)
286+  0000 ~                                    jp      nz,target
287+  0000                                      ENDM
288+  0000
289+  0000              JumpIfAEqNusng:         MACRO value, target
290+  0000 ~                                    cp     value
291+  0000 ~                                    jp      z,target
292+  0000                                      ENDM
293+  0000
294+  0000              JumpIfAIsZero:	        MACRO target
295+  0000 ~                                    and     a   ; cp 0 - changed to and a for optimisation but affects other flags
296+  0000 ~                                    jp	    z, target
297+  0000                                      ENDM
298+  0000
299+  0000              JumpIfRegIsNotZero:     MACRO   reg, target
300+  0000 ~                                    ld      a,reg
301+  0000 ~                                    and     a
302+  0000 ~                                    jp	    nz,target
303+  0000                                      ENDM
304+  0000
305+  0000
306+  0000              JumpIfAIsNotZero:       MACRO target
307+  0000 ~                                    and     a
308+  0000 ~                                    jp	    nz,target
309+  0000                                      ENDM
310+  0000
311+  0000              JumpIfMemIsNotZero:     MACRO value, target
312+  0000 ~                                    ld      a,(value)
313+  0000 ~                                    and     a
314+  0000 ~                                    jp	    nz,target
315+  0000                                      ENDM
316+  0000              IfResultZeroGoto:	    MACRO target
317+  0000 ~                                    jp	z,target
318+  0000                                      ENDM
319+  0000
320+  0000              IfResultNotZeroGoto:    MACRO target
321+  0000 ~                                    jp	nz,target
322+  0000                                      ENDM
323+  0000
# file closed: ../../Macros/jumpMacros.asm
 66   0000                                      INCLUDE "../../Macros/MathsMacros.asm"
# file opened: ../../Macros/MathsMacros.asm
  1+  0000              ZeroA:		            MACRO
  2+  0000 ~                                    xor a
  3+  0000                                      ENDM
  4+  0000              ; sets z flag is HL less than 255 else sets it to nz (note opposite of GT127)
  5+  0000              IsHLGT255:              MACRO
  6+  0000 ~                                    bit     7,h
  7+  0000 ~                                    ret     z
  8+  0000 ~                                    ld      a,h
  9+  0000 ~                                    and     a
 10+  0000                                      ENDM
 11+  0000
 12+  0000              ; Sets z flat if HL = 255 else sets it to nz
 13+  0000              IsHLEqu255:             MACRO
 14+  0000 ~                                    ld      a,h
 15+  0000 ~                                    and     a               ; if its non zero then it can't be 255
 16+  0000 ~                                    ret     nz
 17+  0000 ~                                    ld      a,l
 18+  0000 ~                                    inc     a               ; if it was 255 the inc will set it to zero
 19+  0000                                      ENDM
 20+  0000
 21+  0000              ; Sets Z flag if GT 127 else nz
 22+  0000              IsHLGT127:              MACRO
 23+  0000 ~                                    bit     7,h             ; -ve?
 24+  0000 ~                                    jr      nz,.DoneCheck
 25+  0000 ~                                    ld      a,h             ; +ve > 256?
 26+  0000 ~                                    and     a
 27+  0000 ~                                    jr      nz,.DoneCheck
 28+  0000 ~                                    ld      a,l
 29+  0000 ~                                    and     $80             ; this will set z to false if bit 7 set and clear lower bits
 30+  0000 ~                                    cp      $80             ; this will set z to true if bit 7 set
 31+  0000 ~            .DoneCheck:
 32+  0000                                      ENDM
 33+  0000
 34+  0000              ReturnIfHLGT127:        MACRO
 35+  0000 ~                                    bit     7,h             ; -ve?
 36+  0000 ~                                    jr      nz,.DoneCheck   ; forces check complete
 37+  0000 ~                                    ld      a,h             ; +ve > 256?
 38+  0000 ~                                    and     a               ;
 39+  0000 ~                                    ret     nz              ; forces a return
 40+  0000 ~                                    bit     7,l             ; bit 7 of lower set?
 41+  0000 ~                                    ret     nz              ; forces a return
 42+  0000 ~            .DoneCheck:
 43+  0000                                      ENDM
 44+  0000
 45+  0000              IsDEGT127:              MACRO
 46+  0000 ~                                    bit     7,d
 47+  0000 ~                                    jr      nz,.DoneCheck
 48+  0000 ~                                    ld      a,d
 49+  0000 ~                                    jr      nz,.DoneCheck
 50+  0000 ~                                    ld      a,e
 51+  0000 ~                                    and     $80
 52+  0000 ~            .DoneCheck:
 53+  0000                                      ENDM
 54+  0000
 55+  0000              ABSa2c:                 MACRO
 56+  0000 ~                                    bit     7,a
 57+  0000 ~                                    jp      z,.DoneABSa
 58+  0000 ~                                    neg
 59+  0000 ~            .DoneABSa:
 60+  0000                                      ENDM
 61+  0000
 62+  0000              DEEquSquareA:           MACRO
 63+  0000 ~                                    ld  d,a
 64+  0000 ~                                    ld  e,a
 65+  0000 ~                                    mul de
 66+  0000                                      ENDM
 67+  0000
 68+  0000              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
 69+  0000 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
 70+  0000 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
 71+  0000 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
 72+  0000 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
 73+  0000 ~                                    xor $80                             ;
 74+  0000 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
 75+  0000 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
 76+  0000 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
 77+  0000 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
 78+  0000 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
 79+  0000 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
 80+  0000                                      ENDM
 81+  0000
 82+  0000              SignedHLTo2C:           MACRO
 83+  0000 ~                                    bit     7,h
 84+  0000 ~                                    jr      z,.Done2c
 85+  0000 ~                                    ld      a,h
 86+  0000 ~                                    and     SignMask8Bit
 87+  0000 ~                                    ld      h,a
 88+  0000 ~                                    NegHL
 89+  0000 ~            .Done2c:
 90+  0000                                      ENDM
 91+  0000
 92+  0000              MemSignedTo2C:          MACRO   memfrom
 93+  0000 ~                                    ld      hl,(memfrom)
 94+  0000 ~                                    bit     7,h
 95+  0000 ~                                    jr      z,.Done2c
 96+  0000 ~                                    ld      a,h
 97+  0000 ~                                    and     SignMask8Bit
 98+  0000 ~                                    ld      h,a
 99+  0000 ~            .Done2c:                ld      (memfrom),hl
100+  0000                                      ENDM
101+  0000
102+  0000
103+  0000                  ;returns result in H
104+  0000              EDiv10Inline:           MACRO
105+  0000 ~                                    ld      d,0
106+  0000 ~                                    ld      hl,de
107+  0000 ~                                    add     hl,hl
108+  0000 ~                                    add     hl,de
109+  0000 ~                                    add     hl,hl
110+  0000 ~                                    add     hl,hl
111+  0000 ~                                    add     hl,de
112+  0000 ~                                    add     hl,hl
113+  0000                                      ENDM
114+  0000
115+  0000              cpHLDE:                 MACRO
116+  0000 ~                                    push    hl
117+  0000 ~                                    and     a
118+  0000 ~                                    sbc     hl,de
119+  0000 ~                                    pop     hl
120+  0000                                      ENDM
121+  0000
122+  0000              cpABSDEHL:              MACRO
123+  0000 ~                                    push     hl,,de
124+  0000 ~                                    ld      a,h
125+  0000 ~                                    and     $7F
126+  0000 ~                                    ld      h,a
127+  0000 ~                                    ld      a,d
128+  0000 ~                                    and     $7F
129+  0000 ~                                    ld      d,a
130+  0000 ~                                    ex      de,hl
131+  0000 ~                                    sbc     hl,de
132+  0000 ~                                    pop     hl,,de
133+  0000                                      ENDM
134+  0000
135+  0000              ; Simple are they both the same setting z if they are
136+  0000              ; tehcicall this works but it measn the final ret z is alwys done
137+  0000              ; so jp needs to be to a target
138+  0000              cpHLEquDE:              MACRO   passedCheck
139+  0000 ~                                    ld      a,h
140+  0000 ~                                    cp      d
141+  0000 ~                                    jp      nz, passedCheck
142+  0000 ~                                    ld      a,l
143+  0000 ~                                    cp      e
144+  0000 ~            .NoTheSame:
145+  0000                                      ENDM
146+  0000
147+  0000              cpHLEquBC:              MACRO   passedCheck
148+  0000 ~                                    ld      a,h
149+  0000 ~                                    cp      b
150+  0000 ~                                    jp      nz, passedCheck
151+  0000 ~                                    ld      a,l
152+  0000 ~                                    cp      c
153+  0000 ~            .NoTheSame:
154+  0000                                      ENDM
155+  0000
156+  0000              cpDEEquBC:              MACRO   passedCheck
157+  0000 ~                                    ld      a,d
158+  0000 ~                                    cp      b
159+  0000 ~                                    jp      nz, passedCheck
160+  0000 ~                                    ld      a,e
161+  0000 ~                                    cp      c
162+  0000 ~            .NoTheSame:
163+  0000                                      ENDM
164+  0000              ; Simple version just sets carry if HL < DE reset, does an initial compare for z
165+  0000              cpHLDELeadSign:         MACRO
166+  0000 ~                                    ld      a,h
167+  0000 ~                                    cp      d
168+  0000 ~                                    jr      nz,.FullCompare
169+  0000 ~                                    ld      a,l
170+  0000 ~                                    cp      e
171+  0000 ~                                    ret     z
172+  0000 ~            .FullCompare:           ld      a,h
173+  0000 ~                                    xor     d
174+  0000 ~                                    and     $80
175+  0000 ~                                    jr      nz,.OppositeSigns   ; If opposite signs is a simple sign test
176+  0000 ~                                    ld      a,h                 ; same signs so a little simpler
177+  0000 ~                                    and     $80
178+  0000 ~                                    jp      z,cpHLDE            ; if h is positive then both are positive by here so just cpHLDE
179+  0000 ~                                    jp      cpABSDEHL           ; else we have to do ABScpDEHL
180+  0000 ~            .OppositeSigns:         ld      a,h
181+  0000 ~                                    and     $80
182+  0000 ~                                    and     $80
183+  0000 ~                                    jp      z,.HLGTDE
184+  0000 ~            .HLLTDE:                SetCarryFlag
185+  0000 ~                                    ret
186+  0000 ~            .HLGTDE:                ClearCarryFlag
187+  0000 ~                                    ret
188+  0000                                      ENDM
189+  0000
190+  0000              ;Unsigned
191+  0000              ;If HL == DE, then Z flag is set.
192+  0000              ;If HL != DE, then Z flag is reset.
193+  0000              ;If HL <  DE, then C flag is set.
194+  0000              ;If HL >= DE, then C flag is reset.
195+  0000              ;
196+  0000              ;Signed
197+  0000              ;If HL == DE, then Z flag is set.
198+  0000              ;If HL != DE, then Z flag is reset.
199+  0000              ;If HL <  DE, then S and P/V are different.
200+  0000              ;If HL >= DE, then S and P/V are the same.
201+  0000
202+  0000
203+  0000              N0equN1byN2div256:      MACRO param1,param2,param3
204+  0000 ~                                    ld      a,param3                        ;
205+  0000 ~                                    ld      e,a                         ; use e as var Q = value of XX15 [n] lo
206+  0000 ~                                    ld      a,param2                        ; A = XX16 element
207+  0000 ~                                    ld      d,a
208+  0000 ~                                    mul
209+  0000 ~                                    ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
210+  0000 ~                                    ld      (param1),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
211+  0000                                      ENDM
212+  0000
213+  0000              AequN1xorN2:            MACRO  param1,param2
214+  0000 ~                                    ld      a,(param1)
215+  0000 ~                                    xor     param2
216+  0000                                      ENDM
217+  0000
218+  0000              SpeedMulAxis:           MACRO   speedreg, axis
219+  0000 ~                                    ld      e,speedreg
220+  0000 ~                                    ld      hl,(axis)
221+  0000 ~                                    ld      a,h
222+  0000 ~                                    ClearSignBitA
223+  0000 ~                                    ld      d,a
224+  0000 ~                                    mul     de
225+  0000 ~                                    ld      a,h
226+  0000 ~                                    SignBitOnlyA
227+  0000 ~                                    ld      b,a;ld      c,a
228+  0000 ~                                    ld      h,d;ld      e,d
229+  0000 ~                                    ld      c,0;ld      d,0
230+  0000                                      ENDM
231+  0000
232+  0000              ; Adds speed (8 bit) to vertex (24 bit signed)
233+  0000              AddSpeedToVert:         MACRO   vertex
234+  0000 ~                                    ld      de,(vertex+1)
235+  0000 ~                                    ld      a,(vertex)
236+  0000 ~                                    ld      l,a
237+  0000 ~                                    call    AddBCHtoDELsigned               ; DEL = DEL + BCH
238+  0000 ~                                    ld      a,l
239+  0000 ~                                    ld      (vertex),a
240+  0000 ~                                    ld      (vertex+1),de
241+  0000                                      ENDM
# file closed: ../../Macros/MathsMacros.asm
 67   0000                                      INCLUDE "../../Macros/ShiftMacros.asm"
# file opened: ../../Macros/ShiftMacros.asm
  1+  0000              ShiftIYRight1: MACRO
  2+  0000 ~                           ld   a,iyh
  3+  0000 ~                           srl  a
  4+  0000 ~                           ld   iyh,a
  5+  0000 ~                           ld   a,iyl
  6+  0000 ~                           rra
  7+  0000 ~                           ld   iyl,a
  8+  0000                             ENDM
  9+  0000
 10+  0000              ShiftIXRight1: MACRO
 11+  0000 ~                           ld   a,ixh
 12+  0000 ~                           srl  a
 13+  0000 ~                           ld   ixh,a
 14+  0000 ~                           ld   a,ixl
 15+  0000 ~                           rra
 16+  0000 ~                           ld   ixl,a
 17+  0000                             ENDM
 18+  0000
 19+  0000              ShiftIXhHLRight1: MACRO
 20+  0000 ~                           ld  a,ixh
 21+  0000 ~                           srl a
 22+  0000 ~                           ld  ixh,a
 23+  0000 ~                           rr  h
 24+  0000 ~                           rr  l
 25+  0000                             ENDM
 26+  0000
 27+  0000              ShiftIYhDERight1: MACRO
 28+  0000 ~                           ld  a,iyh
 29+  0000 ~                           srl a
 30+  0000 ~                           ld  iyh,a
 31+  0000 ~                           rr  d
 32+  0000 ~                           rr  e
 33+  0000                             ENDM
 34+  0000
 35+  0000              ShiftIYlBCRight1: MACRO
 36+  0000 ~                           ld  a,iyl
 37+  0000 ~                           srl a
 38+  0000 ~                           ld  iyl,a
 39+  0000 ~                           rr  b
 40+  0000 ~                           rr  c
 41+  0000                             ENDM
 42+  0000
 43+  0000              ShiftIXlBCRight1: MACRO
 44+  0000 ~                           ld  a,ixl
 45+  0000 ~                           srl a
 46+  0000 ~                           ld  ixl,a
 47+  0000 ~                           rr  b
 48+  0000 ~                           rr  c
 49+  0000                             ENDM
 50+  0000
 51+  0000              ShiftHLRight1: MACRO
 52+  0000 ~                           srl h
 53+  0000 ~                           rr  l
 54+  0000                             ENDM
 55+  0000
 56+  0000              SRAHLRight1: MACRO
 57+  0000 ~                           sra h
 58+  0000 ~                           rr  l
 59+  0000                             ENDM
 60+  0000
 61+  0000              ShiftDERight1: MACRO
 62+  0000 ~                           srl d
 63+  0000 ~                           rr  e
 64+  0000                             ENDM
 65+  0000
 66+  0000              ShiftBCRight1: MACRO
 67+  0000 ~                           srl b
 68+  0000 ~                           rr  c
 69+  0000                             ENDM
 70+  0000
 71+  0000
 72+  0000              ShiftHLDiv8:   MACRO
 73+  0000 ~                           srl h
 74+  0000 ~                           rr  l
 75+  0000 ~                           srl h
 76+  0000 ~                           rr  l
 77+  0000 ~                           srl h
 78+  0000 ~                           rr  l
 79+  0000                             ENDM
 80+  0000
 81+  0000              ShiftBHLLeft1:  MACRO
 82+  0000 ~                            sla l
 83+  0000 ~                            rl  h
 84+  0000 ~                            rl  b
 85+  0000                              ENDM
 86+  0000
 87+  0000              ShiftCDELeft1:  MACRO
 88+  0000 ~                            sla e
 89+  0000 ~                            rl  d
 90+  0000 ~                            rl  c
 91+  0000                              ENDM
 92+  0000
 93+  0000              ShiftHLLeft1:  MACRO    ; 16 T states
 94+  0000 ~                           sla l
 95+  0000 ~                           rl  h
 96+  0000                             ENDM
 97+  0000
 98+  0000              ShiftDELeft1:  MACRO    ; 16 T states
 99+  0000 ~                           sla e
100+  0000 ~                           rl  d
101+  0000                             ENDM
102+  0000
103+  0000              BarrelHLLeft3: MACRO
104+  0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
105+  0000 ~                           push     bc      ; 10
106+  0000 ~                           ld       b,3     ; 7
107+  0000 ~                           bsrl     de,b    ; 8
108+  0000 ~                           pop      bc      ; 10
109+  0000 ~                           ex       de,hl   ; 4
110+  0000                             ENDM
111+  0000
112+  0000              BarrelHLRight3: MACRO
113+  0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
114+  0000 ~                           push     bc      ; 10
115+  0000 ~                           ld       b,3     ; 7
116+  0000 ~                           bsrl     de,b    ; 8
117+  0000 ~                           pop      bc      ; 10
118+  0000 ~                           ex       de,hl   ; 4
119+  0000                             ENDM
120+  0000
121+  0000              RollBCLeft1:   MACRO    ; 16 T states
122+  0000 ~                           rl  c
123+  0000 ~                           rl  b
124+  0000                             ENDM
125+  0000
126+  0000              RollDELeft1:   MACRO    ; 16 T states
127+  0000 ~                           rl  e
128+  0000 ~                           rl  d
129+  0000                             ENDM
130+  0000
131+  0000              ShiftBCLeft1:  MACRO    ; 16 T states
132+  0000 ~                           sla c
133+  0000 ~                           rl  b
134+  0000                             ENDM
135+  0000
136+  0000              ShiftLeftMem:       MACRO   reg
137+  0000 ~                                ld      hl,reg
138+  0000 ~                                sla     (hl)
139+  0000                                  ENDM
140+  0000
141+  0000
142+  0000
143+  0000              ShiftMem16Right1:   MACRO memaddr
144+  0000 ~                                ld    hl,(memaddr)
145+  0000 ~                                srl   h
146+  0000 ~                                rr    l
147+  0000 ~                                ld    (memaddr),hl
148+  0000                                  ENDM
149+  0000
150+  0000              ShiftMem8Right1:    MACRO memaddr
151+  0000 ~                                ld      a,(memaddr)
152+  0000 ~                                srl     a
153+  0000 ~                                ld      (memaddr),a
154+  0000                                  ENDM
155+  0000
156+  0000
157+  0000              ShiftMem8Left1A:    MACRO memaddr
158+  0000 ~                                ld      a,(memaddr)
159+  0000 ~                                sla     a
160+  0000 ~                                ld      (memaddr),a
161+  0000                                  ENDM
162+  0000
# file closed: ../../Macros/ShiftMacros.asm
 68   0000                                      INCLUDE "../../Macros/carryFlagMacros.asm"
# file opened: ../../Macros/carryFlagMacros.asm
  1+  0000
  2+  0000              SetCarryFlag:           MACRO
  3+  0000 ~                                    scf
  4+  0000                                      ENDM
  5+  0000
  6+  0000              ClearCarryFlag:	        MACRO
  7+  0000 ~                                    or a
  8+  0000                                      ENDM
  9+  0000
 10+  0000              FlipCarryFlag:          MACRO
 11+  0000 ~                                    ccf
 12+  0000                                      ENDM
 13+  0000
# file closed: ../../Macros/carryFlagMacros.asm
 69   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 70   0000              ; Total screen list
 71   0000              ; Local Chart
 72   0000              ; Galactic Chart
 73   0000              ; Market Prices
 74   0000              ; Inventory
 75   0000              ; Comander status
 76   0000              ; System Data
 77   0000              ; Mission Briefing
 78   0000              ; missio completion
 79   0000              ; Docked  Menu (only place otehr than pause you can load and save)
 80   0000              ; Pause Menu (only place you can load from )
 81   0000              ; byint and selling equipment
 82   0000              ; bying and selling stock
 83   0000
 84   0000              TopOfStack              equ $5CCB ;$6100
 85   0000
 86   0000                                      ORG $5DCB;      $6200
 87   5DCB F3           EliteNextStartup:       di
 88   5DCC DD 01                                break
 89   5DCE                              IFDEF TESTING_MATHS_MULTIPLY
 90   5DCE ~                                    ld      iy,Test1
 91   5DCE ~                                    call    TestMult
 92   5DCE ~                                    break
 93   5DCE ~                                    ld      iy,Test2
 94   5DCE ~                                    call    TestMult
 95   5DCE ~                                    break
 96   5DCE ~                                    ld      iy,Test3
 97   5DCE ~                                    call    TestMult
 98   5DCE ~                                    break
 99   5DCE ~                                    ld      iy,Test4
100   5DCE ~                                    call    TestMult
101   5DCE ~                                    break
102   5DCE ~                                    ld      iy,Test5
103   5DCE ~                                    call    TestMult
104   5DCE ~                                    break
105   5DCE ~                                    ld      iy,Test6
106   5DCE ~                                    call    TestMult
107   5DCE ~                                    break
108   5DCE ~                                    ld      iy,Test7
109   5DCE ~                                    call    TestMult
110   5DCE ~                                    break
111   5DCE ~                                    ld      iy,Test8
112   5DCE ~                                    call    TestMult
113   5DCE ~                                    break
114   5DCE ~                                    ld      iy,Test9
115   5DCE ~                                    call    TestMult
116   5DCE ~                                    break
117   5DCE ~                                    ld      iy,TestA
118   5DCE ~                                    call    TestMult
119   5DCE ~                                    break
120   5DCE ~                                    ld      iy,TestB
121   5DCE ~
122   5DCE ~
123   5DCE ~                           call    TestMult
124   5DCE ~                                    break
125   5DCE ~                                    ld      iy,TestC
126   5DCE ~                                    call    TestMult
127   5DCE ~                                    break
128   5DCE ~                                    ld      iy,TestD
129   5DCE ~                                    call    TestMult
130   5DCE ~                                    break
131   5DCE                              ENDIF
132   5DCE                              IFDEF TESTING_MATHS_DIVIDE
133   5DCE FD 21 9D 5F                          ld      iy,TestD12424
134   5DD2 CD 7D 61                             call    TestDivide
135   5DD5 DD 01                                break
136   5DD7 FD 21 BD 5F                          ld      iy,TestD22424
137   5DDB CD 7D 61                             call    TestDivide
138   5DDE DD 01                                break
139   5DE0 FD 21 DD 5F                          ld      iy,TestD32424
140   5DE4 CD 7D 61                             call    TestDivide
141   5DE7 DD 01                                break
142   5DE9 FD 21 FD 5F                          ld      iy,TestD42424
143   5DED CD 7D 61                             call    TestDivide
144   5DF0 DD 01                                break
145   5DF2 FD 21 BD 60                          ld      iy,TestD52416
146   5DF6 CD 7D 61                             call    TestDivide
147   5DF9 DD 01                                break
148   5DFB                              ENDIF
149   5DFB 00 00        ErrorCount:             DW  0
150   5DFD                                      ;  X              Y              Filler....Result...........................
151   5DFD                                      ;    0    1    2    3    4    5    6    7,   8,   9,   A,   B,   C,   D,   E,   F
152   5DFD 00 10 00 01  Test1:                  DB $00, $10, $00, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
152   5E01 00 00 00 00
152   5E05 00 00 00 00
152   5E09 00 00 00 00
153   5E0D                                      ;  Pass/Fail (00/FF)                       Answer.........................  ...
154   5E0D                                      ;                                           24   25   26   27   28   29   30   31
155   5E0D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $00, $10, $00, $00, $00, $00, $00, $00
155   5E11 00 00 00 00
155   5E15 00 10 00 00
155   5E19 00 00 00 00
156   5E1D 05 03 02 0A  Test2:                  DB $05, $03, $02, $0A, $04, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
156   5E21 04 01 00 00
156   5E25 00 00 00 00
156   5E29 00 00 00 00
157   5E2D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $32, $32, $25, $0B, $02, $00, $00, $00
157   5E31 00 00 00 00
157   5E35 32 32 25 0B
157   5E39 02 00 00 00
158   5E3D 05 03 02 00  Test3:                  DB $05, $03, $02, $00, $0A, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
158   5E41 0A 00 00 00
158   5E45 00 00 00 00
158   5E49 00 00 00 00
159   5E4D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $00, $32, $1E, $14, $00, $00, $00, $00
159   5E51 00 00 00 00
159   5E55 00 32 1E 14
159   5E59 00 00 00 00
160   5E5D FF 03 02 FF  Test4:                  DB $FF, $03, $02, $FF, $0A, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
160   5E61 0A 00 00 00
160   5E65 00 00 00 00
160   5E69 00 00 00 00
161   5E6D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $01, $F1, $29, $16, $00, $00, $00, $00
161   5E71 00 00 00 00
161   5E75 01 F1 29 16
161   5E79 00 00 00 00
162   5E7D 05 FF 02 00  Test5:                  DB $05, $FF, $02, $00, $FF, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
162   5E81 FF 00 00 00
162   5E85 00 00 00 00
162   5E89 00 00 00 00
163   5E8D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $00, $FB, $05, $FC, $02, $00, $00, $00
163   5E91 00 00 00 00
163   5E95 00 FB 05 FC
163   5E99 02 00 00 00
164   5E9D FF 03 07 FF  Test6:                  DB $FF, $03, $07, $FF, $07, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
164   5EA1 07 00 00 00
164   5EA5 00 00 00 00
164   5EA9 00 00 00 00
165   5EAD FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $01, $F4, $18, $38, $00, $00, $00, $00
165   5EB1 00 00 00 00
165   5EB5 01 F4 18 38
165   5EB9 00 00 00 00
166   5EBD FF 03 07 FF  Test7:                  DB $FF, $03, $07, $FF, $0A, $07, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
166   5EC1 0A 07 00 00
166   5EC5 00 00 00 00
166   5EC9 00 00 00 00
167   5ECD FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $01, $F1, $1D, $69, $31, $00, $00, $00
167   5ED1 00 00 00 00
167   5ED5 01 F1 1D 69
167   5ED9 31 00 00 00
168   5EDD 05 03 82 0A  Test8:                  DB $05, $03, $82, $0A, $04, $81, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
168   5EE1 04 81 00 00
168   5EE5 00 00 00 00
168   5EE9 00 00 00 00
169   5EED FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $32, $32, $25, $0B, $02, $00, $00, $00
169   5EF1 00 00 00 00
169   5EF5 32 32 25 0B
169   5EF9 02 00 00 00
170   5EFD 05 03 82 00  Test9:                  DB $05, $03, $82, $00, $0A, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
170   5F01 0A 00 00 00
170   5F05 00 00 00 00
170   5F09 00 00 00 00
171   5F0D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $00, $32, $1E, $94, $00, $00, $00, $00
171   5F11 00 00 00 00
171   5F15 00 32 1E 94
171   5F19 00 00 00 00
172   5F1D FF 03 02 FF  TestA:                  DB $FF, $03, $02, $FF, $0A, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
172   5F21 0A 80 00 00
172   5F25 00 00 00 00
172   5F29 00 00 00 00
173   5F2D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $01, $F1, $29, $96, $00, $00, $00, $00
173   5F31 00 00 00 00
173   5F35 01 F1 29 96
173   5F39 00 00 00 00
174   5F3D 05 FF 82 00  TestB:                  DB $05, $FF, $82, $00, $FF, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
174   5F41 FF 00 00 00
174   5F45 00 00 00 00
174   5F49 00 00 00 00
175   5F4D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $00, $FB, $05, $FC, $82, $00, $00, $00
175   5F51 00 00 00 00
175   5F55 00 FB 05 FC
175   5F59 82 00 00 00
176   5F5D FF 03 07 FF  TestC:                  DB $FF, $03, $07, $FF, $07, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
176   5F61 07 80 00 00
176   5F65 00 00 00 00
176   5F69 00 00 00 00
177   5F6D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $01, $F4, $18, $B8, $00, $00, $00, $00
177   5F71 00 00 00 00
177   5F75 01 F4 18 B8
177   5F79 00 00 00 00
178   5F7D FF 03 00 FF  TestD:                  DB $FF, $03, $00, $FF, $0A, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
178   5F81 0A 80 00 00
178   5F85 00 00 00 00
178   5F89 00 00 00 00
179   5F8D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $01, $F1, $1D, $69, $B1, $00, $00, $00
179   5F91 00 00 00 00
179   5F95 01 F1 1D 69
179   5F99 B1 00 00 00
180   5F9D                                      ;  Dividend.....  Divisor......                                                                             E H  L    B  C
181   5F9D 80 7F 00 80  TestD12424:             DB $80, $7F, $00, $80, $02, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ; 128.5 / 2.5 = 51 Pass
181   5FA1 02 00 00 00
181   5FA5 00 00 00 00
181   5FA9 00 00 00 00
182   5FAD FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
182   5FB1 00 00 00 00
182   5FB5 00 00 00 00
182   5FB9 00 00 00 00
183   5FBD 40 7F 00 40  TestD22424:             DB $40, $7F, $00, $40, $05, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ; 127.25/5.25=24.238	Pass
183   5FC1 05 00 00 00
183   5FC5 00 00 00 00
183   5FC9 00 00 00 00
184   5FCD FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $01, $00, $00, $00, $00, $00, $00, $00
184   5FD1 00 00 00 00
184   5FD5 01 00 00 00
184   5FD9 00 00 00 00
185   5FDD 80 F7 00 80  TestD32424:             DB $80, $F7, $00, $80, $0A, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ; -119.5/10.5=-11.3809 Pass
185   5FE1 0A 00 00 00
185   5FE5 00 00 00 00
185   5FE9 00 00 00 00
186   5FED FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $01, $00, $00, $00, $00, $00, $00, $00
186   5FF1 00 00 00 00
186   5FF5 01 00 00 00
186   5FF9 00 00 00 00
187   5FFD FF 03 00 00  TestD42424:             DB $FF, $03, $00, $00, $8A, $10, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ; 3.996 / -10 = -0.3996
187   6001 8A 10 00 00
187   6005 00 00 00 00
187   6009 00 00 00 00
188   600D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $01, $01, $00, $00, $8F, $04, $00, $00, $00, $00, $00, $00
188   6011 01 01 00 00
188   6015 8F 04 00 00
188   6019 00 00 00 00
189   601D FF 01 01 8F  TestD52424:             DB $FF, $01, $01, $8F, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
189   6021 00 00 00 00
189   6025 00 00 00 00
189   6029 00 00 00 00
190   602D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $CD, $01 ,$00, $00, $00, $00, $00, $00
190   6031 00 00 00 00
190   6035 CD 01 00 00
190   6039 00 00 00 00
191   603D 02 01 01 02  TestD12416:             DB $02, $01, $01, $02, $10, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
191   6041 10 00 00 00
191   6045 00 00 00 00
191   6049 00 00 00 00
192   604D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $81, $80, $00, $00, $00, $00, $00, $00
192   6051 00 00 00 00
192   6055 81 80 00 00
192   6059 00 00 00 00
193   605D 00 80 01 8F  TestD22416:             DB $00, $80, $01, $8F, $01, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
193   6061 01 00 00 00
193   6065 00 00 00 00
193   6069 00 00 00 00
194   606D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $AF, $02, $00, $00, $00, $00, $00, $00
194   6071 00 00 00 00
194   6075 AF 02 00 00
194   6079 00 00 00 00
195   607D 80 03 01 6B  TestD32416:             DB $80, $03, $01, $6B, $C0, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
195   6081 C0 00 00 00
195   6085 00 00 00 00
195   6089 00 00 00 00
196   608D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $6B, $02, $00, $00, $00, $00, $00, $00
196   6091 00 00 00 00
196   6095 6B 02 00 00
196   6099 00 00 00 00
197   609D FF 03 01 39  TestD42416:             DB $FF, $03, $01, $39, $24, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
197   60A1 24 00 00 00
197   60A5 00 00 00 00
197   60A9 00 00 00 00
198   60AD FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $8F, $04, $00, $00, $00, $00, $00, $00
198   60B1 00 00 00 00
198   60B5 8F 04 00 00
198   60B9 00 00 00 00
199   60BD FF 01 01 8F  TestD52416:             DB $FF, $01, $01, $8F, $00, $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
199   60C1 00 80 00 00
199   60C5 00 00 00 00
199   60C9 00 00 00 00
200   60CD FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $CD, $01 ,$00, $00, $00, $00, $00, $00
200   60D1 00 00 00 00
200   60D5 CD 01 00 00
200   60D9 00 00 00 00
201   60DD 02 01 01 02  TestD12408:             DB $02, $01, $01, $02, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
201   60E1 00 00 00 00
201   60E5 00 00 00 00
201   60E9 00 00 00 00
202   60ED FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $81, $80, $00, $00, $00, $00, $00, $00
202   60F1 00 00 00 00
202   60F5 81 80 00 00
202   60F9 00 00 00 00
203   60FD 00 80 01 8F  TestD22408:             DB $00, $80, $01, $8F, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
203   6101 00 00 00 00
203   6105 00 00 00 00
203   6109 00 00 00 00
204   610D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $AF, $02, $00, $00, $00, $00, $00, $00
204   6111 00 00 00 00
204   6115 AF 02 00 00
204   6119 00 00 00 00
205   611D 80 03 01 6B  TestD32408:             DB $80, $03, $01, $6B, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
205   6121 00 00 00 00
205   6125 00 00 00 00
205   6129 00 00 00 00
206   612D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $6B, $02, $00, $00, $00, $00, $00, $00
206   6131 00 00 00 00
206   6135 6B 02 00 00
206   6139 00 00 00 00
207   613D FF 03 01 39  TestD42408:             DB $FF, $03, $01, $39, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
207   6141 00 00 00 00
207   6145 00 00 00 00
207   6149 00 00 00 00
208   614D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $8F, $04, $00, $00, $00, $00, $00, $00
208   6151 00 00 00 00
208   6155 8F 04 00 00
208   6159 00 00 00 00
209   615D FF 01 01 8F  TestD52408:             DB $FF, $01, $01, $8F, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
209   6161 00 00 00 00
209   6165 00 00 00 00
209   6169 00 00 00 00
210   616D FF FF FF FF                          DB $FF, $FF, $FF, $FF, $00, $00, $00, $00, $CD, $01 ,$00, $00, $00, $00, $00, $00
210   6171 00 00 00 00
210   6175 CD 01 00 00
210   6179 00 00 00 00
211   617D FD 6E 00 FD  TestDivide:             ld      hl,(iy+0)   ; BHL = IY [0,1,2]
211   6181 66 01
212   6183 FD 5E 03 FD                          ld      de,(iy+3)   ; BHL = IY [0,1,2]
212   6187 56 04
213   6189 CD 65 63                             call    fixedS88_divs; BHLequBHLdivCDEs
214   618C
215   618C C9                                   ret
216   618D
217   618D FD 6E 00 FD  TestMult:               ld      hl,(iy+0)
217   6191 66 01
218   6193 FD 7E 02                             ld      a,(iy+2)
219   6196 47                                   ld      b,a
220   6197 FD 5E 03 FD                          ld      de,(iy+3)
220   619B 56 04
221   619D FD 7E 05                             ld      a,(iy+5)
222   61A0 4F                                   ld      c,a
223   61A1 CD 39 67                             call    HLBCequBHLmulCDE
224   61A4 FD 71 08 FD                          ld      (iy+8),bc
224   61A8 70 09
225   61AA FD 75 0A FD                          ld      (iy+10),hl
225   61AE 74 0B
226   61B0 FD 77 0C                             ld      (iy+12),a
227   61B3 79           .CheckResult:           ld      a,c
228   61B4 FD BE 18                             cp      (iy+24)
229   61B7 C2 D4 61                             jp      nz,.Fail
230   61BA 78                                   ld      a,b
231   61BB FD BE 19                             cp      (iy+25)
232   61BE C2 D4 61                             jp      nz,.Fail
233   61C1 7D                                   ld      a,l
234   61C2 FD BE 1A                             cp      (iy+26)
235   61C5 C2 D4 61                             jp      nz,.Fail
236   61C8 7C                                   ld      a,h
237   61C9 FD BE 1B                             cp      (iy+27)
238   61CC C2 D4 61                             jp      nz,.Fail
239   61CF AF                                   xor     a
240   61D0 FD 77 10                             ld      (iy+16),a
241   61D3 C9                                   ret
242   61D4 3E 01        .Fail:                  ld      a,$01
243   61D6 FD 77 10                             ld      (iy+16),a
244   61D9 21 FB 5D                             ld      hl,ErrorCount
245   61DC 34                                   inc     (hl)
246   61DD C9                                   ret
247   61DE
248   61DE              ;--------------------------------------------------------------------------------------
249   61DE                  INCLUDE	"../../Maths24/asm_mulitply24.asm"
# file opened: ../../Maths24/asm_mulitply24.asm
  1+  61DE              ;   For divide
  2+  61DE              ;   Split BHL/CDE into
  3+  61DE              ;         BCDE.HL = HL/CD + BCDE.HL = BHL*1/E
  4+  61DE              ;         ; for 24 bit divide
  5+  61DE              ;         ; if both BC are non zero, to BH.0/CD.0
  6+  61DE              ;         ; if CD = 0 do BH.L/00.L
  7+  61DE              ;         ; if B = 0 & C != 0 then result is B*256/C >> 8
  8+  61DE              ; Table B   H   L   C   D   E                                    HLD.E
  9+  61DE              ;       !   !   !   !   !   !       BH.0/CD.0 (16/16) => HL/DE  =>00D.0
 10+  61DE              ;       !   !   !   0   !   !       BH.0/D.0 (16/8)      BHL/DE =>0LD.0 (result << 8)
 11+  61DE              ;       0   !   !   !   !   !       0
 12+  61DE              ;       0   !   !   0   !   !       H.L/D.E (16 bit)  => HL/DE  =>00D.E (result >> 8)
 13+  61DE              ;       0   !   !   0   0   !       H.L/0.E (16 bit)  => HL/DE  =>00D.E (result >> 8)
 14+  61DE              ;       0   0   !   !   !   !       0
 15+  61DE              ;       0   0   !   0   !   !       0
 16+  61DE              ;       0   0   !   0   0   !       00.L/00.E
 17+  61DE              ;       0   0   0   X   X   X       0
 18+  61DE              ;       X   X   X   0   0   0       carry set
 19+  61DE              ; Fixed  24 bit maths S48.16 = BDE * AHL where A=S BCDE=48 HL=16, used by other routines which drop unneeded bytes
 20+  61DE              ;  X 2 1 0 Y 2 1 0
 21+  61DE              ;    B H L   C D E
 22+  61DE              ; 24 bit multiply
 23+  61DE              ; start with lower and help with add sequence           ; all with carry flag (as lower case target reg)
 24+  61DE              ;        L *     E   X0mulY0 1>> 1>>  shift >> 16       ;     HL = L * E
 25+  61DE              ;        L *   D     Y1mulX0 0   1>>  shift >> 8        ;   DEHL = 00HL  + 0[L*D]0
 26+  61DE              ;      H   *     E   X1mulY0 0   1>>  shift >> 8        ;   DEHL = DEHL  + 0[H*E]0 = DEH + 0[H*E]
 27+  61DE              ;    B     *     E   X2mulY0 1<< 1>>  shift 0           ;  CDE   = 0DE   + 0[B*E]
 28+  61DE              ;        L * C       Y2mulX0 1<< 1>>  shift 0           ;  CDE   = CDE   + 0[L*C]
 29+  61DE              ;      H   *   D     X1mulY1 0   0    shift 0           ;  CDE   = CDE   + 0[H*D]
 30+  61DE              ;    B     *   D     X2mulY1 1<< 0<<  shift << 8        ; BCD    = 0CD   + 0[B*D]
 31+  61DE              ;      H   * C       Y2mulX1 1<< 0    shift << 8        ; BCD    = 0CD   + 0[H*C]
 32+  61DE              ;    B     * C       X2mulY2 1<< 1<<  shift <<16        ; BC     = BC    + [B*C]
 33+  61DE              ; 16 bit multiply
 34+  61DE              ; start with lower and help with add sequence           ; all with carry flag (as lower case target reg)
 35+  61DE              ;        L *     E   X0mulY0 1>> 1>>  shift >> 16       ;     HL = L * E
 36+  61DE              ;        L *   D     Y1mulX0 0   1>>  shift >> 8        ;   DEHL = 00HL  + 0[L*D]0
 37+  61DE              ;      H   *     E   X1mulY0 0   1>>  shift >> 8        ;   DEHL = DEHL  + 0[H*E]0 = DEH + 0[H*E]
 38+  61DE              ;      H   *   D     X1mulY1 0   0    shift 0           ;  CDE   = CDE   + 0[H*D]
 39+  61DE              ;                                                       ; Result BCDE.HL
 40+  61DE
 41+  61DE              ; most likley optimisation will be the value is 8.8 so we can quickly eliminate this
 42+  61DE              ; then will be a 0.8 when we are doing things like docking so objects will be close and large
 43+  61DE              ; 8.0 will be unlikley so we will just optimise on 78.8, 8.8, 0.8
 44+  61DE              ; we can also optimise code size if only one side is 08.8 etc by swapping over BHL and CDE as needed
 45+  61DE 78           BCDEHLequBHLmulCDEs:    ld      a,b
 46+  61DF A9                                   xor     c
 47+  61E0 E6 80                                and     0x80
 48+  61E2 CB B8                                res     7,b                     ; clear sign bits
 49+  61E4 CB B9                                res     7,c                     ; res does not affect flags
 50+  61E6 CA F1 61                             jp      z,BCDEHLequBHLmulCDEu   ; can just jp as is also sets A to 0 for sign
 51+  61E9 CD F1 61     .BCDEHLNegative:        call    BCDEHLequBHLmulCDEu     ; do unsigned maths
 52+  61EC 3E 80                                ld      a,0x80                  ; set a = sign bit
 53+  61EE CB F8                                set     7,b                     ; and set sign bit on b
 54+  61F0 C9                                   ret
 55+  61F1
 56+  61F1              BCDEHLequBHLmulCDEu:    ZeroA
 56+  61F1 AF          >                        xor a
 57+  61F2 B0                                   or      b
 58+  61F3 CA FE 61                             jp      z,.X2Zero               ; first pass check X2 = 0?
 59+  61F6              .X2checkY2:             ZeroA                           ; now check Y2 = 0?
 59+  61F6 AF          >                        xor a
 60+  61F7 B1                                   or      c
 61+  61F8 CA 7A 62                             jp      z,BCDEHLequ24mul24u     ;  fro nwo ignore optimsation X2 is non 0, Y2 is zero eliminating 3 mulitplies
 62+  61FB C3 7A 62     .Do24BitMul:            jp      BCDEHLequ24mul24u       ; X2 and Y2 are non zero so in most cases it will be a regular 78.8 x 78.8 so just do 24 bit mul
 63+  61FE B1           .X2Zero:                or      c
 64+  61FF CA 05 62                             jp      z,.checkFor8BitMul      ; X2 and Y2 are both 0 eliminating 5 multiplies with 8.8 now check for 0.8
 65+  6202 C3 7A 62     .Do16Bitmul24Bit:       jp      BCDEHLequ24mul24u       ; for now ignore optimisation X2 is zero Y2 is non zero eliminating 3 muliplies
 66+  6205 B4           .checkFor8BitMul:       or      h
 67+  6206 C2 0D 62     .Do16BitMul:            jp      nz, BCHLDEequ16mul16u   ; X1 is non zero so we will assume Y1 is also non zero and do a 16 bit muliply
 68+  6209 B2           .X2X1Zero:              or      d
 69+  620A CA 70 62     .Do8BitMul              jp      z, BCHLDEequ8mul8u      ; X1 and Y1 are both zero so its now just a simple mul de
 70+  620D                                      ; else we fall into a 16 bit multiply
 71+  620D              BCHLDEequ16mul16u:
 72+  620D 7D           .PrepSelfModifying:     ld      a,l
 73+  620E 32 2B 62                             ld      (.Y1mulX0L+1),a         ; Y1mulX0 L (we can skip X0mulY0 as we will already have L)
 74+  6211 7A                                   ld      a,d
 75+  6212 32 29 62                             ld      (.Y1mulX0D+1),a         ; Y1mulX0 D
 76+  6215 32 5F 62                             ld      (.X1mulY1D+1),a         ; X1mulY1 D
 77+  6218 7B                                   ld      a,e
 78+  6219 32 42 62                             ld      (.X1mulY0E+1),a         ; X1mulY0 E (we can skip X0mulY0 as we will already have E)
 79+  621C 78                                   ld      a,b
 80+  621D 7C                                   ld      a,h
 81+  621E 32 40 62                             ld      (.X1mulY0+1),a          ; X1mulY0 H
 82+  6221 32 5D 62                             ld      (.X1mulY1H+1),a         ; X1mulY1 H
 83+  6224                                      ; now we don't have to worry about setting up multiplies, just the adds and result
 84+  6224                                      ; we can freely use AF, BC, HL, IX, IY and alternate registers
 85+  6224              .X0mulY0
 85+  6224 55                          ld      d,l                     ; HL = L * E
 86+  6225 ED 30                                mul     de                      ; .
 87+  6227 EB                                   ex      de,hl                   ; .
 88+  6228              .Y1mulX0:                                               ; [L*D]
 89+  6228 16 00        .Y1mulX0D:              ld      d,0x00
 90+  622A 1E 00        .Y1mulX0L:              ld      e,0x00                  ; DE = L * D
 91+  622C ED 30                                mul     de                      ;
 92+  622E                                      ; DEHL = 00HL  + 0[L*D]0        ; as 0FF+FF0 is a 3 byte result + carry bit
 93+  622E EB           .AHLequ0HLaddDE0:       ex      de,hl                   ; AHL = [L*D][0], DE = [0][L*E]
 94+  622F                                      ZeroA                           ; A = 0 and clear carry Flag
 94+  622F AF          >                        xor a
 95+  6230 7C                                   ld      a,h                     ; .
 96+  6231 65                                   ld      h,l                     ; .
 97+  6232 2E 00                                ld      l,0                     ; .
 98+  6234 ED 5A                                adc     hl,de                   ; carryHL  = L0 + DE
 99+  6236 CE 00                                adc     a,0                     ; <cary>A = H+carry so <carry>AHL = [L*D][0] + [0][L*E]
100+  6238 5F                                   ld      e,a                     ; .
101+  6239 3E 00                                ld      a,0                     ; .
102+  623B 8F                                   adc     a,a                     ; . *as a is 0 we can do this and save 3 T states
103+  623C 16 00                                ld      d,0                     ; now DEHL = [L*D][0] + [0][L*E]
104+  623E D9                                   exx                             ; now 'DEHL = [L*D][0] + [0][L*E]
105+  623F              .X1mulY0:               ; [H*E]
106+  623F 16 00        .X1mulY0H:              ld      d,0x00
107+  6241 1E 00        .X1mulY0E:              ld      e,0x00
108+  6243 ED 30                                mul     de                      ; DE = [H * E]
109+  6245 DD 01                                break
110+  6247                                      ; DEHL = DEHL + 0[H*E]0 = DEH + 0[H*E] or  <carry>HL += E0 <carry?> DE += 0H + carry
111+  6247 D5                                   push    de                      ; Stack + 1
112+  6248 D9                                   exx                             ; DEHL = previous [0][L*D][0] + [00][L*E]
113+  6249 C1                                   pop     bc                      ; Stack + 0
114+  624A                                      ClearCarryFlag                  ; 'DEHL = DEHL + [00]BC (or [0][H*E][0]
114+  624A B7          >                        or a
115+  624B 78                                   ld      a,b                     ; copy b as we need it again
116+  624C 41                                   ld      b,c                     ; now bc = E[0] from calc above
117+  624D 0E 00                                ld      c,0                     ; .
118+  624F ED 4A                                adc     hl,bc                   ; HL += E[0] from calc above
119+  6251 06 00                                ld      b,0                     ; bc = [0]D from calc above
120+  6253 4F                                   ld      c,a                     ;
121+  6254 EB                                   ex      de,hl                   ; get de into HL for add
122+  6255 ED 4A                                adc     hl,bc                   ;
123+  6257 EB                                   ex      de,hl                   ; get DEHL back into correct order
124+  6258 01 00 00                             ld      bc,0                    ; as we don't have X2Y2 we just set BC to 0
125+  625B D9                                   exx                             ; now P3 P2 are loaded with working values, 'HL holds P1 P0 that are now fixed values
126+  625C              .X1mulY1:               ; [H*D]
127+  625C 16 00        .X1mulY1H:              ld      d,0x00                  ; X2mulY0 H
128+  625E 1E 00        .X1mulY1D:              ld      e,0x00                  ; X2mulY0 E
129+  6260 ED 30                                mul     de
130+  6262                                      ;  CDE   = CDE   + [H*D]
131+  6262 D5                                   push    de                      ; Stack + 1 swap in results
132+  6263 D9                                   exx                             ; BC = [H*D]
133+  6264 C1                                   pop     bc                      ; Stack + 0
134+  6265 EB                                   ex      de,hl                   ; DE = DE + [H*D]
135+  6266                                      ZeroA                           ; A = 0 and clear carry Flag
135+  6266 AF          >                        xor a
136+  6267 ED 4A                                adc     hl,bc                   ; .
137+  6269 EB                                   ex      de,hl                   ; get HL and DE back to correct positions (we may leave them like this later for optimisation but debug first)
138+  626A 89                                   adc     a,c                     ; a += c + carry
139+  626B 4F                                   ld      c,a                     ; so now we have 'CDE.HL as results
140+  626C                                      ZeroA                           ; assume sign in A is positive
140+  626C AF          >                        xor a
141+  626D 06 00                                ld      b,0                     ; and we need b to be 0
142+  626F C9                                   ret
143+  6270
144+  6270                                      ; 8 bit multiply
145+  6270 55           BCHLDEequ8mul8u:        ld      d,l                     ; so now BCHLDE = 00L * 00D
146+  6271 ED 30                                mul     de                      ; so we just do L*D which loads de
147+  6273 EB                                   ex      de,hl
148+  6274                                      ZeroA                           ; and set BCHL to 0
148+  6274 AF          >                        xor a
149+  6275 47                                   ld      b,a
150+  6276 4F                                   ld      c,a
151+  6277 57                                   ld      d,a
152+  6278 5F                                   ld      e,a
153+  6279 C9                                   ret
154+  627A
155+  627A              BCDEHLequ24mul24u:
156+  627A 7D           .PrepSelfModifying:     ld      a,l
157+  627B 32 B7 62                             ld      (.Y1mulX0L+1),a         ; Y1mulX0 L (we can skip X0mulY0 as we will already have L)
158+  627E 32 F9 62                             ld      (.Y2mulX0L+1),a         ; Y2mulX0 L
159+  6281 7A                                   ld      a,d
160+  6282 32 B5 62                             ld      (.Y1mulX0D+1),a         ; Y1mulX0 D
161+  6285 32 0A 63                             ld      (.X1mulY1D+1),a         ; X1mulY1 D
162+  6288 32 1B 63                             ld      (.X2mulY1D+1),a         ; X2mulY1 D
163+  628B 7B                                   ld      a,e
164+  628C 32 CE 62                             ld      (.X1mulY0E+1),a         ; X1mulY0 E (we can skip X0mulY0 as we will already have E)
165+  628F 32 E8 62                             ld      (.X2mulY0E+1),a         ; X2mulY0 E
166+  6292 78                                   ld      a,b
167+  6293 32 E6 62                             ld      (.X2mulY0B+1),a         ; X2mulY0 B
168+  6296 32 19 63                             ld      (.X2mulY1B+1),a         ; X2mulY1 B
169+  6299 32 43 63                             ld      (.X2mulY2B+1),a         ; X2mulY2 B
170+  629C 7C                                   ld      a,h
171+  629D 32 CC 62                             ld      (.X1mulY0+1),a          ; X1mulY0 H
172+  62A0 32 31 63                             ld      (.Y2mulX1H+1),a         ; Y2mulX1 H
173+  62A3 32 08 63                             ld      (.X1mulY1H+1),a         ; X1mulY1 H
174+  62A6 79                                   ld      a,c
175+  62A7 32 F7 62                             ld      (.Y2mulX0C+1),a         ; Y2mulX0 C
176+  62AA 32 2F 63                             ld      (.Y2mulX1C+1),a         ; Y2mulX1 C
177+  62AD 32 45 63                             ld      (.X2mulY2C+1),a         ; X2mulY2 C
178+  62B0                                      ; now we don't have to worry about setting up multiplies, just the adds and result
179+  62B0                                      ; we can freely use AF, BC, HL, IX, IY and alternate registers
180+  62B0              .X0mulY0
180+  62B0 55                          ld      d,l                     ; HL = L * E
181+  62B1 ED 30                                mul     de                      ; .
182+  62B3 EB                                   ex      de,hl                   ; .
183+  62B4              .Y1mulX0:                                               ; [L*D]
184+  62B4 16 00        .Y1mulX0D:              ld      d,0x00
185+  62B6 1E 00        .Y1mulX0L:              ld      e,0x00                  ; DE = L * D
186+  62B8 ED 30                                mul     de                      ;
187+  62BA                                      ; DEHL = 00HL  + 0[L*D]0        ; as 0FF+FF0 is a 3 byte result + carry bit
188+  62BA EB           .AHLequ0HLaddDE0:       ex      de,hl                   ; AHL = [L*D][0], DE = [0][L*E]
189+  62BB                                      ZeroA                           ; A = 0 and clear carry Flag
189+  62BB AF          >                        xor a
190+  62BC 7C                                   ld      a,h                     ; .
191+  62BD 65                                   ld      h,l                     ; .
192+  62BE 2E 00                                ld      l,0                     ; .
193+  62C0 ED 5A                                adc     hl,de                   ; carryHL  = L0 + DE
194+  62C2 CE 00                                adc     a,0                     ; <cary>A = H+carry so <carry>AHL = [L*D][0] + [0][L*E]
195+  62C4 5F                                   ld      e,a                     ; .
196+  62C5 3E 00                                ld      a,0                     ; .
197+  62C7 8F                                   adc     a,a                     ; . *as a is 0 we can do this and save 3 T states
198+  62C8 16 00                                ld      d,0                     ; now DEHL = [L*D][0] + [0][L*E]
199+  62CA D9                                   exx                             ; now 'DEHL = [L*D][0] + [0][L*E]
200+  62CB              .X1mulY0:               ; [H*E]
201+  62CB 16 00        .X1mulY0H:              ld      d,0x00
202+  62CD 1E 00        .X1mulY0E:              ld      e,0x00
203+  62CF ED 30                                mul     de                      ; DE = [H * E]
204+  62D1 DD 01                                break
205+  62D3                                      ; DEHL = DEHL + 0[H*E]0 = DEH + 0[H*E] or  <carry>HL += E0 <carry?> DE += 0H + carry
206+  62D3 D5                                   push    de                      ; Stack + 1
207+  62D4 D9                                   exx                             ; DEHL = previous [0][L*D][0] + [00][L*E]
208+  62D5 C1                                   pop     bc                      ; Stack + 0
209+  62D6                                      ClearCarryFlag                  ; 'DEHL = DEHL + [00]BC (or [0][H*E][0]
209+  62D6 B7          >                        or a
210+  62D7 78                                   ld      a,b                     ; copy b as we need it again
211+  62D8 41                                   ld      b,c                     ; now bc = E[0] from calc above
212+  62D9 0E 00                                ld      c,0                     ; .
213+  62DB ED 4A                                adc     hl,bc                   ; HL += E[0] from calc above
214+  62DD 06 00                                ld      b,0                     ; bc = [0]D from calc above
215+  62DF 4F                                   ld      c,a                     ;
216+  62E0 EB                                   ex      de,hl                   ; get de into HL for add
217+  62E1 ED 4A                                adc     hl,bc                   ;
218+  62E3 EB                                   ex      de,hl                   ; get DEHL back into correct order
219+  62E4 D9                                   exx                             ; now P3 P2 are loaded with working values, 'HL holds P1 P0 that are now fixed values
220+  62E5              .X2mulY0                ; [B*E]
221+  62E5 16 00        .X2mulY0B:              ld      d,0x00                  ; X2mulY0 B
222+  62E7 1E 00        .X2mulY0E:              ld      e,0x00                  ; X2mulY0 E
223+  62E9 ED 30                                mul     de
224+  62EB                                      ;  CDE   = DE   + [B*E]
225+  62EB D5                                   push    de                      ; swap in results Stack + 1
226+  62EC D9                                   exx                             ; BC = [B*E]
227+  62ED C1                                   pop     bc                      ; Stack + 0
228+  62EE EB                                   ex      de,hl                   ; DE = DE + [B*E]
229+  62EF                                      ZeroA                           ; A = 0 and clear carry Flag
229+  62EF AF          >                        xor a
230+  62F0 ED 4A                                adc     hl,bc                   ; .
231+  62F2 EB                                   ex      de,hl                   ; get HL and DE back to correct positions (we may leave them like this later for optimisation but debug first)
232+  62F3 8F                                   adc     a,a                     ; a += 0 + carry
233+  62F4 4F                                   ld      c,a                     ; so now we have 'CDE.HL as results
234+  62F5 D9                                   exx                             ; .
235+  62F6              .Y2mulX0:               ; [L*C]
236+  62F6 16 00        .Y2mulX0C:              ld      d,0x00                  ; X2mulY0 C
237+  62F8 1E 00        .Y2mulX0L:              ld      e,0x00                  ; X2mulY0 L
238+  62FA ED 30                                mul     de
239+  62FC                                      ;  CDE   = CDE   + [L*C]
240+  62FC D5                                   push    de                      ; Stack + 1 swap in results
241+  62FD D9                                   exx                             ; BC = [L*C]
242+  62FE C1                                   pop     bc                      ; Stack + 0
243+  62FF EB                                   ex      de,hl                   ; DE = DE + [L*C]
244+  6300                                      ZeroA                           ; A = 0 and clear carry Flag
244+  6300 AF          >                        xor a
245+  6301 ED 4A                                adc     hl,bc                   ; .
246+  6303 EB                                   ex      de,hl                   ; get HL and DE back to correct positions (we may leave them like this later for optimisation but debug first)
247+  6304 89                                   adc     a,c                     ; a += c + carry
248+  6305 4F                                   ld      c,a                     ; so now we have 'CDE.HL as results
249+  6306 D9                                   exx                             ; .
250+  6307              .X1mulY1:               ; [H*D]
251+  6307 16 00        .X1mulY1H:              ld      d,0x00                  ; X2mulY0 H
252+  6309 1E 00        .X1mulY1D:              ld      e,0x00                  ; X2mulY0 E
253+  630B ED 30                                mul     de
254+  630D                                      ;  CDE   = CDE   + [H*D]
255+  630D D5                                   push    de                      ; Stack + 1 swap in results
256+  630E D9                                   exx                             ; BC = [H*D]
257+  630F C1                                   pop     bc                      ; Stack + 0
258+  6310 EB                                   ex      de,hl                   ; DE = DE + [H*D]
259+  6311                                      ZeroA                           ; A = 0 and clear carry Flag
259+  6311 AF          >                        xor a
260+  6312 ED 4A                                adc     hl,bc                   ; .
261+  6314 EB                                   ex      de,hl                   ; get HL and DE back to correct positions (we may leave them like this later for optimisation but debug first)
262+  6315 89                                   adc     a,c                     ; a += c + carry
263+  6316 4F                                   ld      c,a                     ; so now we have 'CDE.HL as results
264+  6317 D9                                   exx                             ; .
265+  6318              .X2mulY1:               ; [B*D]
266+  6318 16 00        .X2mulY1B               ld      d,0x00                  ; X2mulY2 B
267+  631A 1E 00        .X2mulY1D:              ld      e,0x00                  ; X2mulY0 E
268+  631C ED 30                                mul     de
269+  631E                                      ; BCD    = CD   + [B*D]         now is startes to get more tricky as we are spanning register pairs
270+  631E D5                                   push    de                      ; Stack + 1 swap in results
271+  631F D9                                   exx                             ; BC = [H*D]
272+  6320 E5 DD E1                             ld      ix,hl                   ; preserve HL during calculations
273+  6323 61                                   ld      h,c                     ;
274+  6324 6A                                   ld      l,d                     ;
275+  6325 C1                                   pop     bc                      ;
276+  6326                                      ZeroA                           ; A = 0 and clear carry Flag
276+  6326 AF          >                        xor a
277+  6327 ED 4A                                adc     hl,bc                   ; .
278+  6329 4C                                   ld      c,h
279+  632A 55                                   ld      d,l
280+  632B 8F                                   adc     a,a                     ; a += c + carry
281+  632C 47                                   ld      b,a                     ; so now we have 'BCDE.HL as results
282+  632D D9                                   exx                             ; .
283+  632E              .Y2mulX1:               ; [H*C]
284+  632E 16 00        .Y2mulX1C:              ld      d,0x00                  ; X2mulY0 E
285+  6330 1E 00        .Y2mulX1H:              ld      e,0x00                  ; X2mulY0 E
286+  6332 ED 30                                mul     de
287+  6334                                      ; BCD    = CD   + [H*C]
288+  6334 D5                                   push    de                      ; Stack + 1 swap in results
289+  6335 D9                                   exx                             ; BC = [H*C]
290+  6336 61                                   ld      h,c
291+  6337 6A                                   ld      l,d
292+  6338 C1                                   pop     bc                      ; Stack + 0
293+  6339                                      ZeroA                           ; A = 0 and clear carry Flag
293+  6339 AF          >                        xor a
294+  633A ED 4A                                adc     hl,bc                   ; .
295+  633C 4C                                   ld      c,h
296+  633D 55                                   ld      d,l
297+  633E 8F                                   adc     a,a                     ; a += c + carry
298+  633F 47                                   ld      b,a                     ; so now we have 'BCDE.HL as results
299+  6340 C5                                   push    bc                      ; get bc on stack for final add Stack + 1
300+  6341 D9                                   exx                             ; .
301+  6342              .X2mulY2:               ; [B*C]
302+  6342 16 00        .X2mulY2B               ld      d,0x00                  ; X2mulY2 B
303+  6344 1E 00        .X2mulY2C               ld      e,0x00                  ; X2mulY2 C
304+  6346 ED 30                                mul     de
305+  6348                                      ; BC     = BC   + [B*C]
306+  6348 E1                                   pop     hl                      ; Get Saved BC into HL
307+  6349 19                                   add     hl,de                   ; hl = bc + [B*C]
308+  634A E5                                   push    hl                      ; and save on stack to read into bc
309+  634B D9                                   exx                             ; get back result
310+  634C DD E5 E1                             ld      hl,ix                   ; restore hl we saved earlier
311+  634F C1                                   pop     bc                      ; now we have 'BCDE.HL as final result
312+  6350                                      ZeroA                           ; assume sign in A is positive
312+  6350 AF          >                        xor a
313+  6351 C9                                   ret
314+  6352              ; Optimised mulitploy routines
315+  6352              ; muliptiply S7d ny S7e signed
316+  6352              ; used A and B registers
317+  6352              ; result in DE
318+  6352              ; This replaces DEequDmulEs
319+  6352 7A           DEequDmulEs:            ld      a,d                     ; work out resultant sign and load into b
320+  6353 AB                                   xor     e                       ; .
321+  6354 E6 80                                and     SignOnly8Bit            ; .
322+  6356 47                                   ld      b,a                     ; .
323+  6357 7A                                   ld      a,d                     ; now clear d sign bit
324+  6358 E6 7F                                and     SignMask8Bit            ; .
325+  635A 57                                   ld      d,a                     ; .
326+  635B 7B                                   ld      a,e                     ; now clear e sign bit
327+  635C E6 7F                                and     SignMask8Bit            ; .
328+  635E 5F                                   ld      e,a                     ; .
329+  635F ED 30                                mul     de                      ; do mulitply
330+  6361 7A                                   ld      a,d                     ; get sign bit from b and re0introduce it
331+  6362 B0                                   or      b                       ; .
332+  6363 57                                   ld      d,a                     ; .
333+  6364 C9                                   ret
334+  6365
# file closed: ../../Maths24/asm_mulitply24.asm
250   6365                  INCLUDE	"../../Maths24/asm_divide24.asm"
# file opened: ../../Maths24/asm_divide24.asm
  1+  6365
  2+  6365
  3+  6365              FP88DIVITER:        MACRO
  4+  6365 ~                                rla
  5+  6365 ~                                adc hl,hl
  6+  6365 ~                                add hl,de
  7+  6365 ~                                jr c,.NoSubtract
  8+  6365 ~                                sbc hl,de
  9+  6365 ~            .NoSubtract:
 10+  6365                                  ENDM
 11+  6365
 12+  6365 44 4D        fixedS88_divs:      ld      bc,hl
 13+  6367              ;HL = DE/BC as Q8.8 Fixed Point maths, when doing 24 bit maths scale down to 8.8 as its accurate enough
 14+  6367              BC_Div_DE_88:
 15+  6367 78           .checkSigns:        ld      a,b
 16+  6368 AA                               xor     d
 17+  6369 E6 80                            and     $80
 18+  636B FD 6F                            ld      iyl,a               ; sign bit is the result sign bit held in iy as we want to optimise
 19+  636D 78           .forcePositiveOnly: ld      a,b                 ; bc = abs b
 20+  636E E6 7F                            and     $7F                 ; .
 21+  6370 47                               ld      b,a                 ; .
 22+  6371 B1           .checkZeroDivide:   or      c                   ; optimisation, if bc was zero then result will be zero
 23+  6372 28 3E                            jr      z,.resultIsZero     ; .
 24+  6374 7A           .forceNegativeDW:   ld      a,d                 ; first force it positive
 25+  6375 E6 7F                            and     $7F                 ; .
 26+  6377 57                               ld      d,a
 27+  6378 B3           .checDivideZero     or      e                   ; as we are going to wipe a, do the divide by zero check here as an optimisation
 28+  6379 28 2E                            jr      z,.divideOverflow    ; .
 29+  637B                                  ZeroA                       ; now negate DE
 29+  637B AF          >                        xor a
 30+  637C 93                               sub     e                   ; .
 31+  637D 5F                               ld 		e,a                 ; .
 32+  637E 9F                               sbc 	a,a                 ; .
 33+  637F 92                               sub 	d                   ; .
 34+  6380 57                               ld 		d,a                 ; .
 35+  6381 26 00        .overflowCheck:     ld      h,0                 ; prepare h = 0 for a slight optimise
 36+  6383 78                               ld      a,b                 ; if B+DE>=0, then we'll have overflow
 37+  6384 83                               add     e                   ; .
 38+  6385 7A                               ld      a,d                 ; .
 39+  6386 CE 00                            adc     a,0                 ; .
 40+  6388 78                               ld a,b
 41+  6389 83                               add a,e
 42+  638A 7A                               ld a,d
 43+  638B 8C                               adc a,h
 44+  638C 38 1B                            jr c,.divideOverflow
 45+  638E 68           .prepRemainder:     ld      l,b                 ; h is already 0 from overflow Check so now hl = 0b
 46+  638F 79                               ld      a,c                 ; and a = c
 47+  6390 CD B6 63                         call div_S88_sub
 48+  6393 4F                               ld      c,a
 49+  6394 78                               ld      a,b      ;A is now 0
 50+  6395 CD B6 63                         call div_S88_sub
 51+  6398 29           .CheckRounding:     add     hl,hl; if 2HL+DE>=0, increment result to round.
 52+  6399 19                               add     hl,de
 53+  639A 61                               ld      h,c
 54+  639B 6F                               ld      l,a
 55+  639C 30 01                            jr      nc,.NoIncrementNeeded
 56+  639E 23                               inc     hl
 57+  639F CB 7C        .NoIncrementNeeded: bit 7,h                     ; Now check if H is overflowed
 58+  63A1 20 06                            jr nz,.divideOverflow
 59+  63A3 FD 7D                            ld      a,iyl               ; get back sign bit
 60+  63A5 B4                               or      h
 61+  63A6 67                               ld      h,a                 ; now set h to correct sign
 62+  63A7                                  ClearCarryFlag              ; and we have a success
 62+  63A7 B7          >                        or a
 63+  63A8 C9                               ret
 64+  63A9 2E FF        .divideOverflow:    ld      l,$FF               ; hl = +/-128.255 signed
 65+  63AB FD 7D                            ld      a,iyl               ; .
 66+  63AD F6 7F                            or      $7F                 ; .
 67+  63AF 67                               ld      h,a
 68+  63B0                                  SetCarryFlag
 68+  63B0 37          >                        scf
 69+  63B1 C9                               ret
 70+  63B2              .resultIsZero       ZeroA                       ; doign it this way saves a couple of clock cycles as we get the carry clear for free even if setting hl takes an extra 2 cycles
 70+  63B2 AF          >                        xor a
 71+  63B3 67                               ld      h,a
 72+  63B4 6F                               ld      l,a
 73+  63B5 C9                               ret
 74+  63B6              div_S88_sub:        FP88DIVITER
 74+  63B6 17          >                    rla
 74+  63B7 ED 6A       >                    adc hl,hl
 74+  63B9 19          >                    add hl,de
 74+  63BA 38 02       >                    jr c,.NoSubtract
 74+  63BC ED 52       >                    sbc hl,de
 74+  63BE             >.NoSubtract:
 75+  63BE                                  FP88DIVITER
 75+  63BE 17          >                    rla
 75+  63BF ED 6A       >                    adc hl,hl
 75+  63C1 19          >                    add hl,de
 75+  63C2 38 02       >                    jr c,.NoSubtract
 75+  63C4 ED 52       >                    sbc hl,de
 75+  63C6             >.NoSubtract:
 76+  63C6                                  FP88DIVITER
 76+  63C6 17          >                    rla
 76+  63C7 ED 6A       >                    adc hl,hl
 76+  63C9 19          >                    add hl,de
 76+  63CA 38 02       >                    jr c,.NoSubtract
 76+  63CC ED 52       >                    sbc hl,de
 76+  63CE             >.NoSubtract:
 77+  63CE                                  FP88DIVITER
 77+  63CE 17          >                    rla
 77+  63CF ED 6A       >                    adc hl,hl
 77+  63D1 19          >                    add hl,de
 77+  63D2 38 02       >                    jr c,.NoSubtract
 77+  63D4 ED 52       >                    sbc hl,de
 77+  63D6             >.NoSubtract:
 78+  63D6                                  FP88DIVITER
 78+  63D6 17          >                    rla
 78+  63D7 ED 6A       >                    adc hl,hl
 78+  63D9 19          >                    add hl,de
 78+  63DA 38 02       >                    jr c,.NoSubtract
 78+  63DC ED 52       >                    sbc hl,de
 78+  63DE             >.NoSubtract:
 79+  63DE                                  FP88DIVITER
 79+  63DE 17          >                    rla
 79+  63DF ED 6A       >                    adc hl,hl
 79+  63E1 19          >                    add hl,de
 79+  63E2 38 02       >                    jr c,.NoSubtract
 79+  63E4 ED 52       >                    sbc hl,de
 79+  63E6             >.NoSubtract:
 80+  63E6                                  FP88DIVITER
 80+  63E6 17          >                    rla
 80+  63E7 ED 6A       >                    adc hl,hl
 80+  63E9 19          >                    add hl,de
 80+  63EA 38 02       >                    jr c,.NoSubtract
 80+  63EC ED 52       >                    sbc hl,de
 80+  63EE             >.NoSubtract:
 81+  63EE                                  FP88DIVITER
 81+  63EE 17          >                    rla
 81+  63EF ED 6A       >                    adc hl,hl
 81+  63F1 19          >                    add hl,de
 81+  63F2 38 02       >                    jr c,.NoSubtract
 81+  63F4 ED 52       >                    sbc hl,de
 81+  63F6             >.NoSubtract:
 82+  63F6 8F                               adc a,a
 83+  63F7 C9                               ret
 84+  63F8
 85+  63F8
 86+  63F8              BCDIVDE_MACRO:      MACRO
 87+  63F8 ~                                rla
 88+  63F8 ~                                adc	    hl,hl
 89+  63F8 ~                                add	    hl,de
 90+  63F8 ~                                jr	    c,.NoSubtract
 91+  63F8 ~                                sbc	    hl,de
 92+  63F8 ~            .NoSubtract:
 93+  63F8                                  ENDM
 94+  63F8
 95+  63F8              HLDIVC_MACRO: 	    MACRO
 96+  63F8 ~                                add	    hl,hl		; unroll 16 times
 97+  63F8 ~                                rla				; ...
 98+  63F8 ~                                jr      c,      .DoSubInc
 99+  63F8 ~                                cp	    c			; ...
100+  63F8 ~                                jr      c,      .NoSubInc
101+  63F8 ~            .DoSubInc:          sub	c			; ...
102+  63F8 ~                                inc	l			; ...
103+  63F8 ~            .NoSubInc:
104+  63F8                                  ENDM
105+  63F8
106+  63F8              DDIVIDEE_MACRO:     MACRO
107+  63F8 ~                                rl      e
108+  63F8 ~                                rla
109+  63F8 ~                                sub     c
110+  63F8 ~                                jr      nc,.NoAdd
111+  63F8 ~                                add     a,c
112+  63F8 ~            .NoAdd:
113+  63F8                                  ENDM
114+  63F8
115+  63F8              ; TO ADD
116+  63F8
117+  63F8              ; Perform BHL = BHL/CDE generally the result will be 0HL but we have to provision for extreme results
118+  63F8              ; the division will at most be 16/16 but optimised for 16/8 and 8/8. If we get 8/16 that is always 0
119+  63F8              BHLequBHLdivCDEu:
120+  63F8              ; Check for divide by 0
121+  63F8 79           .checkDiv0:         ld      a,c
122+  63F9 B2                               or      d
123+  63FA B3                               or      e
124+  63FB CA 35 64                         jp      z,.divideByZero
125+  63FE FD 2E 00                         ld      iyl,0           ; set up counter in iyl
126+  6401 7D                               ld      a,l
127+  6402              ; Check for 0 divided by value
128+  6402 78           .check0Div:         ld      a,b
129+  6403 B4                               or      h
130+  6404 B5                               or      l
131+  6405 CA 3C 64                         jp      z,.resultIsZero
132+  6408              ; Bit shift to retain accuracy at this point we are gauranteed that BHL and CDE are both != 0 so we don't have to worry about infinite shifts
133+  6408 78           .ShiftLoop:         ld      a,b
134+  6409 B1                               or      c
135+  640A E6 40                            and     %01000000       ; once we get to 7th bit of B then we are good
136+  640C C2 20 64                         jp      nz,.DoneShift
137+  640F                                  ShiftBHLLeft1
137+  640F CB 25       >                sla l
137+  6411 CB 14       >                rl  h
137+  6413 CB 10       >                rl  b
138+  6415                                  ShiftCDELeft1
138+  6415 CB 23       >                sla e
138+  6417 CB 12       >                rl  d
138+  6419 CB 11       >                rl  c
139+  641B FD 2C                            inc     iyl
140+  641D C3 08 64                         jp      .ShiftLoop
141+  6420              .DoneShift:
142+  6420 7C           .CheckFor8BitDivide:ld      a,h             ; if H and D are zero then we can just do 8 bit divide
143+  6421 B1                               or      c
144+  6422 CA 6F 65                         jp      z, SetupDdivE
145+  6425 79           .CheckFor16Div8:    ld      a,c             ; now at least one of H and D are non zero so can we do 16 bit divide 8 bit
146+  6426 A7                               and     a
147+  6427 CA D7 64                         jp      z, SetupHLDivC
148+  642A 7C           .CheckFor8Div16:    ld      a,h             ; so if we are divding 8 bit by 16 bit its always 0
149+  642B A7                               and     a               ; we we set it to 0x00.0x01 or 0.00390625
150+  642C C2 41 64                         jp      nz, SetupBCdivDE; so its definitly 16/16 divide
151+  642F              .ResultIsTooLow:    ZeroA                   ; clears carry flag and makes loading b quicker
151+  642F AF          >                        xor a
152+  6430 47                               ld      b,a             ; load bhl with 0x00001 in 16 t states
153+  6431 67                               ld      h,a             ;
154+  6432 6F                               ld      l,a             ;
155+  6433 2C                               inc     l               ;
156+  6434 C9                               ret
157+  6435              .divideByZero:      ZeroA                   ; Sets carry to mark failure
157+  6435 AF          >                        xor a
158+  6436 3D                               dec     a
159+  6437 47                               ld      b,a             ; load bhl with 0xFFFFFF in 16 t states
160+  6438 67                               ld      h,a             ;
161+  6439 6F                               ld      l,a             ;
162+  643A                                  SetCarryFlag
162+  643A 37          >                        scf
163+  643B C9                               ret
164+  643C              .resultIsZero:      ZeroA
164+  643C AF          >                        xor a
165+  643D 47                               ld      b,a             ; load bhl with 0x00001 in 16 t states
166+  643E 67                               ld      h,a             ;
167+  643F 6F                               ld      l,a             ;
168+  6440 C9                               ret
169+  6441              ; now we have interested values in BH and CD so move them into BC and DE
170+  6441 5A           SetupBCdivDE:       ld      e,d             ; set up DE by moving CD there
171+  6442 51                               ld      d,c             ; .
172+  6443 4C                               ld      c,h             ; b is already set so just do C to get BC
173+  6444              ; BE = BC = BC / DE. HL = remainder fast divide with unrolled loop"
174+  6444              BHLequBCdivDE:      ZeroA
174+  6444 AF          >                        xor a
175+  6445 67                               ld      h,a
176+  6446 6F                               ld      l,a
177+  6447 93                               sub     e
178+  6448 5F                               ld      e,a
179+  6449 9F                               sbc     a,a
180+  644A 92                               sub     d
181+  644B 57                               ld      d,a
182+  644C 78                               ld      a,b
183+  644D              counter = 0
184+  644D                              WHILE counter < 8 , 8
185+  644D             >                    BCDIVDE_MACRO
185+  644D 17          >                    rla
185+  644E ED 6A       >                    adc	    hl,hl
185+  6450 19          >                    add	    hl,de
185+  6451 38 02       >                    jr	    c,.NoSubtract
185+  6453 ED 52       >                    sbc	    hl,de
185+  6455             >.NoSubtract:
186+  6455             >counter = counter + 1
185+  6455             >                    BCDIVDE_MACRO
185+  6455 17          >                    rla
185+  6456 ED 6A       >                    adc	    hl,hl
185+  6458 19          >                    add	    hl,de
185+  6459 38 02       >                    jr	    c,.NoSubtract
185+  645B ED 52       >                    sbc	    hl,de
185+  645D             >.NoSubtract:
186+  645D             >counter = counter + 1
185+  645D             >                    BCDIVDE_MACRO
185+  645D 17          >                    rla
185+  645E ED 6A       >                    adc	    hl,hl
185+  6460 19          >                    add	    hl,de
185+  6461 38 02       >                    jr	    c,.NoSubtract
185+  6463 ED 52       >                    sbc	    hl,de
185+  6465             >.NoSubtract:
186+  6465             >counter = counter + 1
185+  6465             >                    BCDIVDE_MACRO
185+  6465 17          >                    rla
185+  6466 ED 6A       >                    adc	    hl,hl
185+  6468 19          >                    add	    hl,de
185+  6469 38 02       >                    jr	    c,.NoSubtract
185+  646B ED 52       >                    sbc	    hl,de
185+  646D             >.NoSubtract:
186+  646D             >counter = counter + 1
185+  646D             >                    BCDIVDE_MACRO
185+  646D 17          >                    rla
185+  646E ED 6A       >                    adc	    hl,hl
185+  6470 19          >                    add	    hl,de
185+  6471 38 02       >                    jr	    c,.NoSubtract
185+  6473 ED 52       >                    sbc	    hl,de
185+  6475             >.NoSubtract:
186+  6475             >counter = counter + 1
185+  6475             >                    BCDIVDE_MACRO
185+  6475 17          >                    rla
185+  6476 ED 6A       >                    adc	    hl,hl
185+  6478 19          >                    add	    hl,de
185+  6479 38 02       >                    jr	    c,.NoSubtract
185+  647B ED 52       >                    sbc	    hl,de
185+  647D             >.NoSubtract:
186+  647D             >counter = counter + 1
185+  647D             >                    BCDIVDE_MACRO
185+  647D 17          >                    rla
185+  647E ED 6A       >                    adc	    hl,hl
185+  6480 19          >                    add	    hl,de
185+  6481 38 02       >                    jr	    c,.NoSubtract
185+  6483 ED 52       >                    sbc	    hl,de
185+  6485             >.NoSubtract:
186+  6485             >counter = counter + 1
185+  6485             >                    BCDIVDE_MACRO
185+  6485 17          >                    rla
185+  6486 ED 6A       >                    adc	    hl,hl
185+  6488 19          >                    add	    hl,de
185+  6489 38 02       >                    jr	    c,.NoSubtract
185+  648B ED 52       >                    sbc	    hl,de
185+  648D             >.NoSubtract:
186+  648D             >counter = counter + 1
187+  648D                              ENDW
188+  648D 17                               rla
189+  648E 47                               ld      b,a
190+  648F 79                               ld      a,c
191+  6490              counter = 0
192+  6490                              WHILE counter < 8 , 8
193+  6490             >                    BCDIVDE_MACRO
193+  6490 17          >                    rla
193+  6491 ED 6A       >                    adc	    hl,hl
193+  6493 19          >                    add	    hl,de
193+  6494 38 02       >                    jr	    c,.NoSubtract
193+  6496 ED 52       >                    sbc	    hl,de
193+  6498             >.NoSubtract:
194+  6498             >counter = counter + 1
193+  6498             >                    BCDIVDE_MACRO
193+  6498 17          >                    rla
193+  6499 ED 6A       >                    adc	    hl,hl
193+  649B 19          >                    add	    hl,de
193+  649C 38 02       >                    jr	    c,.NoSubtract
193+  649E ED 52       >                    sbc	    hl,de
193+  64A0             >.NoSubtract:
194+  64A0             >counter = counter + 1
193+  64A0             >                    BCDIVDE_MACRO
193+  64A0 17          >                    rla
193+  64A1 ED 6A       >                    adc	    hl,hl
193+  64A3 19          >                    add	    hl,de
193+  64A4 38 02       >                    jr	    c,.NoSubtract
193+  64A6 ED 52       >                    sbc	    hl,de
193+  64A8             >.NoSubtract:
194+  64A8             >counter = counter + 1
193+  64A8             >                    BCDIVDE_MACRO
193+  64A8 17          >                    rla
193+  64A9 ED 6A       >                    adc	    hl,hl
193+  64AB 19          >                    add	    hl,de
193+  64AC 38 02       >                    jr	    c,.NoSubtract
193+  64AE ED 52       >                    sbc	    hl,de
193+  64B0             >.NoSubtract:
194+  64B0             >counter = counter + 1
193+  64B0             >                    BCDIVDE_MACRO
193+  64B0 17          >                    rla
193+  64B1 ED 6A       >                    adc	    hl,hl
193+  64B3 19          >                    add	    hl,de
193+  64B4 38 02       >                    jr	    c,.NoSubtract
193+  64B6 ED 52       >                    sbc	    hl,de
193+  64B8             >.NoSubtract:
194+  64B8             >counter = counter + 1
193+  64B8             >                    BCDIVDE_MACRO
193+  64B8 17          >                    rla
193+  64B9 ED 6A       >                    adc	    hl,hl
193+  64BB 19          >                    add	    hl,de
193+  64BC 38 02       >                    jr	    c,.NoSubtract
193+  64BE ED 52       >                    sbc	    hl,de
193+  64C0             >.NoSubtract:
194+  64C0             >counter = counter + 1
193+  64C0             >                    BCDIVDE_MACRO
193+  64C0 17          >                    rla
193+  64C1 ED 6A       >                    adc	    hl,hl
193+  64C3 19          >                    add	    hl,de
193+  64C4 38 02       >                    jr	    c,.NoSubtract
193+  64C6 ED 52       >                    sbc	    hl,de
193+  64C8             >.NoSubtract:
194+  64C8             >counter = counter + 1
193+  64C8             >                    BCDIVDE_MACRO
193+  64C8 17          >                    rla
193+  64C9 ED 6A       >                    adc	    hl,hl
193+  64CB 19          >                    add	    hl,de
193+  64CC 38 02       >                    jr	    c,.NoSubtract
193+  64CE ED 52       >                    sbc	    hl,de
193+  64D0             >.NoSubtract:
194+  64D0             >counter = counter + 1
195+  64D0                              ENDW
196+  64D0 17                               rla
197+  64D1 6F                               ld      l,a             ; now load into BHL
198+  64D2 60                               ld      h,b             ;
199+  64D3 06 00                            ld      b,0             ;
200+  64D5                                  ClearCarryFlag
200+  64D5 B7          >                        or a
201+  64D6 C9                               ret
202+  64D7              ; bc and de hold values to move into correct registers so we need to move to hl and c to optimise loops
203+  64D7 60 69        SetupHLDivC:        ld      hl,bc
204+  64D9 4B                               ld      c,e
205+  64DA              BHLEquHLdivC:       ZeroA
205+  64DA AF          >                        xor a
206+  64DB              counter=0
207+  64DB                              WHILE counter < 16 , 16
208+  64DB             >                    HLDIVC_MACRO
208+  64DB 29          >                    add	    hl,hl		; unroll 16 times
208+  64DC 17          >                    rla				; ...
208+  64DD 38 03       >                    jr      c,      .DoSubInc
208+  64DF B9          >                    cp	    c			; ...
208+  64E0 38 02       >                    jr      c,      .NoSubInc
208+  64E2 91          >.DoSubInc:          sub	c			; ...
208+  64E3 2C          >                    inc	l			; ...
208+  64E4             >.NoSubInc:
209+  64E4             >counter = counter + 1
208+  64E4             >                    HLDIVC_MACRO
208+  64E4 29          >                    add	    hl,hl		; unroll 16 times
208+  64E5 17          >                    rla				; ...
208+  64E6 38 03       >                    jr      c,      .DoSubInc
208+  64E8 B9          >                    cp	    c			; ...
208+  64E9 38 02       >                    jr      c,      .NoSubInc
208+  64EB 91          >.DoSubInc:          sub	c			; ...
208+  64EC 2C          >                    inc	l			; ...
208+  64ED             >.NoSubInc:
209+  64ED             >counter = counter + 1
208+  64ED             >                    HLDIVC_MACRO
208+  64ED 29          >                    add	    hl,hl		; unroll 16 times
208+  64EE 17          >                    rla				; ...
208+  64EF 38 03       >                    jr      c,      .DoSubInc
208+  64F1 B9          >                    cp	    c			; ...
208+  64F2 38 02       >                    jr      c,      .NoSubInc
208+  64F4 91          >.DoSubInc:          sub	c			; ...
208+  64F5 2C          >                    inc	l			; ...
208+  64F6             >.NoSubInc:
209+  64F6             >counter = counter + 1
208+  64F6             >                    HLDIVC_MACRO
208+  64F6 29          >                    add	    hl,hl		; unroll 16 times
208+  64F7 17          >                    rla				; ...
208+  64F8 38 03       >                    jr      c,      .DoSubInc
208+  64FA B9          >                    cp	    c			; ...
208+  64FB 38 02       >                    jr      c,      .NoSubInc
208+  64FD 91          >.DoSubInc:          sub	c			; ...
208+  64FE 2C          >                    inc	l			; ...
208+  64FF             >.NoSubInc:
209+  64FF             >counter = counter + 1
208+  64FF             >                    HLDIVC_MACRO
208+  64FF 29          >                    add	    hl,hl		; unroll 16 times
208+  6500 17          >                    rla				; ...
208+  6501 38 03       >                    jr      c,      .DoSubInc
208+  6503 B9          >                    cp	    c			; ...
208+  6504 38 02       >                    jr      c,      .NoSubInc
208+  6506 91          >.DoSubInc:          sub	c			; ...
208+  6507 2C          >                    inc	l			; ...
208+  6508             >.NoSubInc:
209+  6508             >counter = counter + 1
208+  6508             >                    HLDIVC_MACRO
208+  6508 29          >                    add	    hl,hl		; unroll 16 times
208+  6509 17          >                    rla				; ...
208+  650A 38 03       >                    jr      c,      .DoSubInc
208+  650C B9          >                    cp	    c			; ...
208+  650D 38 02       >                    jr      c,      .NoSubInc
208+  650F 91          >.DoSubInc:          sub	c			; ...
208+  6510 2C          >                    inc	l			; ...
208+  6511             >.NoSubInc:
209+  6511             >counter = counter + 1
208+  6511             >                    HLDIVC_MACRO
208+  6511 29          >                    add	    hl,hl		; unroll 16 times
208+  6512 17          >                    rla				; ...
208+  6513 38 03       >                    jr      c,      .DoSubInc
208+  6515 B9          >                    cp	    c			; ...
208+  6516 38 02       >                    jr      c,      .NoSubInc
208+  6518 91          >.DoSubInc:          sub	c			; ...
208+  6519 2C          >                    inc	l			; ...
208+  651A             >.NoSubInc:
209+  651A             >counter = counter + 1
208+  651A             >                    HLDIVC_MACRO
208+  651A 29          >                    add	    hl,hl		; unroll 16 times
208+  651B 17          >                    rla				; ...
208+  651C 38 03       >                    jr      c,      .DoSubInc
208+  651E B9          >                    cp	    c			; ...
208+  651F 38 02       >                    jr      c,      .NoSubInc
208+  6521 91          >.DoSubInc:          sub	c			; ...
208+  6522 2C          >                    inc	l			; ...
208+  6523             >.NoSubInc:
209+  6523             >counter = counter + 1
208+  6523             >                    HLDIVC_MACRO
208+  6523 29          >                    add	    hl,hl		; unroll 16 times
208+  6524 17          >                    rla				; ...
208+  6525 38 03       >                    jr      c,      .DoSubInc
208+  6527 B9          >                    cp	    c			; ...
208+  6528 38 02       >                    jr      c,      .NoSubInc
208+  652A 91          >.DoSubInc:          sub	c			; ...
208+  652B 2C          >                    inc	l			; ...
208+  652C             >.NoSubInc:
209+  652C             >counter = counter + 1
208+  652C             >                    HLDIVC_MACRO
208+  652C 29          >                    add	    hl,hl		; unroll 16 times
208+  652D 17          >                    rla				; ...
208+  652E 38 03       >                    jr      c,      .DoSubInc
208+  6530 B9          >                    cp	    c			; ...
208+  6531 38 02       >                    jr      c,      .NoSubInc
208+  6533 91          >.DoSubInc:          sub	c			; ...
208+  6534 2C          >                    inc	l			; ...
208+  6535             >.NoSubInc:
209+  6535             >counter = counter + 1
208+  6535             >                    HLDIVC_MACRO
208+  6535 29          >                    add	    hl,hl		; unroll 16 times
208+  6536 17          >                    rla				; ...
208+  6537 38 03       >                    jr      c,      .DoSubInc
208+  6539 B9          >                    cp	    c			; ...
208+  653A 38 02       >                    jr      c,      .NoSubInc
208+  653C 91          >.DoSubInc:          sub	c			; ...
208+  653D 2C          >                    inc	l			; ...
208+  653E             >.NoSubInc:
209+  653E             >counter = counter + 1
208+  653E             >                    HLDIVC_MACRO
208+  653E 29          >                    add	    hl,hl		; unroll 16 times
208+  653F 17          >                    rla				; ...
208+  6540 38 03       >                    jr      c,      .DoSubInc
208+  6542 B9          >                    cp	    c			; ...
208+  6543 38 02       >                    jr      c,      .NoSubInc
208+  6545 91          >.DoSubInc:          sub	c			; ...
208+  6546 2C          >                    inc	l			; ...
208+  6547             >.NoSubInc:
209+  6547             >counter = counter + 1
208+  6547             >                    HLDIVC_MACRO
208+  6547 29          >                    add	    hl,hl		; unroll 16 times
208+  6548 17          >                    rla				; ...
208+  6549 38 03       >                    jr      c,      .DoSubInc
208+  654B B9          >                    cp	    c			; ...
208+  654C 38 02       >                    jr      c,      .NoSubInc
208+  654E 91          >.DoSubInc:          sub	c			; ...
208+  654F 2C          >                    inc	l			; ...
208+  6550             >.NoSubInc:
209+  6550             >counter = counter + 1
208+  6550             >                    HLDIVC_MACRO
208+  6550 29          >                    add	    hl,hl		; unroll 16 times
208+  6551 17          >                    rla				; ...
208+  6552 38 03       >                    jr      c,      .DoSubInc
208+  6554 B9          >                    cp	    c			; ...
208+  6555 38 02       >                    jr      c,      .NoSubInc
208+  6557 91          >.DoSubInc:          sub	c			; ...
208+  6558 2C          >                    inc	l			; ...
208+  6559             >.NoSubInc:
209+  6559             >counter = counter + 1
208+  6559             >                    HLDIVC_MACRO
208+  6559 29          >                    add	    hl,hl		; unroll 16 times
208+  655A 17          >                    rla				; ...
208+  655B 38 03       >                    jr      c,      .DoSubInc
208+  655D B9          >                    cp	    c			; ...
208+  655E 38 02       >                    jr      c,      .NoSubInc
208+  6560 91          >.DoSubInc:          sub	c			; ...
208+  6561 2C          >                    inc	l			; ...
208+  6562             >.NoSubInc:
209+  6562             >counter = counter + 1
208+  6562             >                    HLDIVC_MACRO
208+  6562 29          >                    add	    hl,hl		; unroll 16 times
208+  6563 17          >                    rla				; ...
208+  6564 38 03       >                    jr      c,      .DoSubInc
208+  6566 B9          >                    cp	    c			; ...
208+  6567 38 02       >                    jr      c,      .NoSubInc
208+  6569 91          >.DoSubInc:          sub	c			; ...
208+  656A 2C          >                    inc	l			; ...
208+  656B             >.NoSubInc:
209+  656B             >counter = counter + 1
210+  656B                              ENDW
211+  656B 06 00                            ld      b,0             ; now we have BHL as result
212+  656D                                  ClearCarryFlag
212+  656D B7          >                        or a
213+  656E C9                               ret
214+  656F              SetupDdivE:
215+  656F              ; Performs BC = D / E, B will always be zero we don't care about remainder
216+  656F              ; we have BC/DE prepped so we can just move tehm
217+  656F              BCequDdivE:         ZeroA
217+  656F AF          >                        xor a
218+  6570 67                               ld      h,a             ; bh is always 0
219+  6571 47                               ld      b,a             ;
220+  6572              counter = 0
221+  6572                              WHILE counter < 16 , 16
222+  6572             >                    DDIVIDEE_MACRO
222+  6572 CB 13       >                    rl      e
222+  6574 17          >                    rla
222+  6575 91          >                    sub     c
222+  6576 30 01       >                    jr      nc,.NoAdd
222+  6578 81          >                    add     a,c
222+  6579             >.NoAdd:
223+  6579             >counter = counter + 1
222+  6579             >                    DDIVIDEE_MACRO
222+  6579 CB 13       >                    rl      e
222+  657B 17          >                    rla
222+  657C 91          >                    sub     c
222+  657D 30 01       >                    jr      nc,.NoAdd
222+  657F 81          >                    add     a,c
222+  6580             >.NoAdd:
223+  6580             >counter = counter + 1
222+  6580             >                    DDIVIDEE_MACRO
222+  6580 CB 13       >                    rl      e
222+  6582 17          >                    rla
222+  6583 91          >                    sub     c
222+  6584 30 01       >                    jr      nc,.NoAdd
222+  6586 81          >                    add     a,c
222+  6587             >.NoAdd:
223+  6587             >counter = counter + 1
222+  6587             >                    DDIVIDEE_MACRO
222+  6587 CB 13       >                    rl      e
222+  6589 17          >                    rla
222+  658A 91          >                    sub     c
222+  658B 30 01       >                    jr      nc,.NoAdd
222+  658D 81          >                    add     a,c
222+  658E             >.NoAdd:
223+  658E             >counter = counter + 1
222+  658E             >                    DDIVIDEE_MACRO
222+  658E CB 13       >                    rl      e
222+  6590 17          >                    rla
222+  6591 91          >                    sub     c
222+  6592 30 01       >                    jr      nc,.NoAdd
222+  6594 81          >                    add     a,c
222+  6595             >.NoAdd:
223+  6595             >counter = counter + 1
222+  6595             >                    DDIVIDEE_MACRO
222+  6595 CB 13       >                    rl      e
222+  6597 17          >                    rla
222+  6598 91          >                    sub     c
222+  6599 30 01       >                    jr      nc,.NoAdd
222+  659B 81          >                    add     a,c
222+  659C             >.NoAdd:
223+  659C             >counter = counter + 1
222+  659C             >                    DDIVIDEE_MACRO
222+  659C CB 13       >                    rl      e
222+  659E 17          >                    rla
222+  659F 91          >                    sub     c
222+  65A0 30 01       >                    jr      nc,.NoAdd
222+  65A2 81          >                    add     a,c
222+  65A3             >.NoAdd:
223+  65A3             >counter = counter + 1
222+  65A3             >                    DDIVIDEE_MACRO
222+  65A3 CB 13       >                    rl      e
222+  65A5 17          >                    rla
222+  65A6 91          >                    sub     c
222+  65A7 30 01       >                    jr      nc,.NoAdd
222+  65A9 81          >                    add     a,c
222+  65AA             >.NoAdd:
223+  65AA             >counter = counter + 1
222+  65AA             >                    DDIVIDEE_MACRO
222+  65AA CB 13       >                    rl      e
222+  65AC 17          >                    rla
222+  65AD 91          >                    sub     c
222+  65AE 30 01       >                    jr      nc,.NoAdd
222+  65B0 81          >                    add     a,c
222+  65B1             >.NoAdd:
223+  65B1             >counter = counter + 1
222+  65B1             >                    DDIVIDEE_MACRO
222+  65B1 CB 13       >                    rl      e
222+  65B3 17          >                    rla
222+  65B4 91          >                    sub     c
222+  65B5 30 01       >                    jr      nc,.NoAdd
222+  65B7 81          >                    add     a,c
222+  65B8             >.NoAdd:
223+  65B8             >counter = counter + 1
222+  65B8             >                    DDIVIDEE_MACRO
222+  65B8 CB 13       >                    rl      e
222+  65BA 17          >                    rla
222+  65BB 91          >                    sub     c
222+  65BC 30 01       >                    jr      nc,.NoAdd
222+  65BE 81          >                    add     a,c
222+  65BF             >.NoAdd:
223+  65BF             >counter = counter + 1
222+  65BF             >                    DDIVIDEE_MACRO
222+  65BF CB 13       >                    rl      e
222+  65C1 17          >                    rla
222+  65C2 91          >                    sub     c
222+  65C3 30 01       >                    jr      nc,.NoAdd
222+  65C5 81          >                    add     a,c
222+  65C6             >.NoAdd:
223+  65C6             >counter = counter + 1
222+  65C6             >                    DDIVIDEE_MACRO
222+  65C6 CB 13       >                    rl      e
222+  65C8 17          >                    rla
222+  65C9 91          >                    sub     c
222+  65CA 30 01       >                    jr      nc,.NoAdd
222+  65CC 81          >                    add     a,c
222+  65CD             >.NoAdd:
223+  65CD             >counter = counter + 1
222+  65CD             >                    DDIVIDEE_MACRO
222+  65CD CB 13       >                    rl      e
222+  65CF 17          >                    rla
222+  65D0 91          >                    sub     c
222+  65D1 30 01       >                    jr      nc,.NoAdd
222+  65D3 81          >                    add     a,c
222+  65D4             >.NoAdd:
223+  65D4             >counter = counter + 1
222+  65D4             >                    DDIVIDEE_MACRO
222+  65D4 CB 13       >                    rl      e
222+  65D6 17          >                    rla
222+  65D7 91          >                    sub     c
222+  65D8 30 01       >                    jr      nc,.NoAdd
222+  65DA 81          >                    add     a,c
222+  65DB             >.NoAdd:
223+  65DB             >counter = counter + 1
222+  65DB             >                    DDIVIDEE_MACRO
222+  65DB CB 13       >                    rl      e
222+  65DD 17          >                    rla
222+  65DE 91          >                    sub     c
222+  65DF 30 01       >                    jr      nc,.NoAdd
222+  65E1 81          >                    add     a,c
222+  65E2             >.NoAdd:
223+  65E2             >counter = counter + 1
224+  65E2                              ENDW
225+  65E2 7B                               ld      a,e             ; e = result, so *2 and compliment to get actual result
226+  65E3 17                               rla
227+  65E4 2F                               cpl
228+  65E5 6F                               ld      l,a             ; sets up bhl to return
229+  65E6                                  ClearCarryFlag
229+  65E6 B7          >                        or a
230+  65E7 C9                               ret
231+  65E8
232+  65E8              ; performsn BHL/CDE signed, in which case we take signs, load then into iy do unsigned divide and recover sign
233+  65E8 78           BHLequBHLdivCDEs:   ld      a,b
234+  65E9 A9                               xor     c
235+  65EA E6 80                            and     $80
236+  65EC FD 6F                            ld      iyl,a           ; save resultant sign
237+  65EE CD F8 63                         call    BHLequBHLdivCDEu
238+  65F1 78                               ld      a,b
239+  65F2 FD B5                            or      iyl
240+  65F4 47                               ld      b,a             ; now bhl = S15.8 value
241+  65F5 C9                               ret
242+  65F6
243+  65F6              ; performs (256*B)/C i.e. HL/C or B0/C unsigned
244+  65F6 60           BHLequ256mulBdivCu: ld      h,b             ; now hl = B*256 or B0
245+  65F7 2E 00                            ld      l,0             ; as c is already loaded we can just jp to divide
246+  65F9 C3 DA 64                         jp      BHLEquHLdivC    ; b will always result in 0
247+  65FC
248+  65FC
249+  65FC
250+  65FC
251+  65FC
252+  65FC                 ; unsigned division of 24-bit number by 16-bit number
253+  65FC                 ;
254+  65FC                 ; enter : ehl = 24-bit dividend
255+  65FC                 ;          bc = 16-bit divisor
256+  65FC                 ;
257+  65FC                 ; exit  : success
258+  65FC                 ;
259+  65FC                 ;            ahl = ehl / bc
260+  65FC                 ;             de = ehl % bc
261+  65FC                 ;            carry reset
262+  65FC                 ;
263+  65FC                 ;         divide by zero
264+  65FC                 ;
265+  65FC                 ;            ahl = $fffff = UINT_MAX
266+  65FC                 ;            cde = dividend
267+  65FC                 ;            carry set, errno = EDOM
268+  65FC                 ;
269+  65FC                 ; uses  : af, bc, de, hl
270+  65FC
271+  65FC                 ; test for divide by zero will be doen outside the call
272+  65FC              ; to get to here it must be 24x16
273+  65FC              l_fast_divu_24_24x16:
274+  65FC                 ; ehl >= $ 01 00 00 bc >= $    01 00
275+  65FC                 ;
276+  65FC                 ; this means the results of the first eight iterations of the division loop are known
277+  65FC                 ;
278+  65FC                 ; inside the loop the computation is ac[b] / de, hl = remainder so initialize as if eight iterations done
279+  65FC 50                                   ld d,b
280+  65FD 7B                                   ld a,e
281+  65FE 59                                   ld e,c
282+  65FF 4D                                   ld c,l
283+  6600 6F                                   ld l,a
284+  6601 7C                                   ld a,h
285+  6602 26 00                                ld h,0
286+  6604                                      ; unroll divide eight times
287+  6604
288+  6604 06 02                                ld b,2
289+  6606                                      ; eliminating leading zeroes
290+  6606
291+  6606 CB 11                                rl c
292+  6608 17                                   rla
293+  6609 ED 6A                                adc hl,hl
294+  660B 24                                   inc h
295+  660C 25                                   dec h
296+  660D C2 5D 66                             jp nz, loop2416_00
297+  6610
298+  6610 CB 11                                rl c
299+  6612 0C                                   inc c
300+  6613 17                                   rla
301+  6614 ED 6A                                adc hl,hl
302+  6616 24                                   inc h
303+  6617 25                                   dec h
304+  6618 C2 69 66                             jp nz, loop2416_11
305+  661B
306+  661B CB 11                                rl c
307+  661D 0C                                   inc c
308+  661E 17                                   rla
309+  661F ED 6A                                adc hl,hl
310+  6621 24                                   inc h
311+  6622 25                                   dec h
312+  6623 C2 75 66                             jp nz, loop2416_22
313+  6626
314+  6626 CB 11                                rl c
315+  6628 0C                                   inc c
316+  6629 17                                   rla
317+  662A ED 6A                                adc hl,hl
318+  662C 24                                   inc h
319+  662D 25                                   dec h
320+  662E C2 81 66                             jp nz, loop2416_33
321+  6631
322+  6631 CB 11                                rl c
323+  6633 0C                                   inc c
324+  6634 17                                   rla
325+  6635 ED 6A                                adc hl,hl
326+  6637 24                                   inc h
327+  6638 25                                   dec h
328+  6639 C2 8D 66                             jp nz, loop2416_44
329+  663C
330+  663C CB 11                                rl c
331+  663E 0C                                   inc c
332+  663F 17                                   rla
333+  6640 ED 6A                                adc hl,hl
334+  6642 24                                   inc h
335+  6643 25                                   dec h
336+  6644 C2 99 66                             jp nz, loop2416_55
337+  6647
338+  6647 CB 11                                rl c
339+  6649 0C                                   inc c
340+  664A 17                                   rla
341+  664B ED 6A                                adc hl,hl
342+  664D 24                                   inc h
343+  664E 25                                   dec h
344+  664F C2 A5 66                             jp nz, loop2416_66
345+  6652
346+  6652 37                                   scf
347+  6653 C3 AA 66                             jp loop2416_7
348+  6656                                      ; general divide loop
349+  6656 CB 11        loop2416_0:                 rl c
350+  6658 17                                   rla
351+  6659 ED 6A                                adc hl,hl
352+  665B 38 65                                jr c, loop2416_000
353+  665D
354+  665D ED 52        loop2416_00:                sbc hl,de
355+  665F 30 01                                jr nc, loop2416_1
356+  6661 19                                   add hl,de
357+  6662
358+  6662 CB 11        loop2416_1:                 rl c
359+  6664 17                                   rla
360+  6665 ED 6A                                adc hl,hl
361+  6667 38 60                                jr c, loop2416_111
362+  6669
363+  6669 ED 52        loop2416_11:            sbc hl,de
364+  666B 30 01                                jr nc, loop2416_2
365+  666D 19                                   add hl,de
366+  666E
367+  666E CB 11        loop2416_2:                 rl c
368+  6670 17                                   rla
369+  6671 ED 6A                                adc hl,hl
370+  6673 38 5B                                jr c, loop2416_222
371+  6675
372+  6675 ED 52        loop2416_22:                sbc hl,de
373+  6677 30 01                                jr nc, loop2416_3
374+  6679 19                                   add hl,de
375+  667A
376+  667A CB 11        loop2416_3:                 rl c
377+  667C 17                                   rla
378+  667D ED 6A                                adc hl,hl
379+  667F 38 56                                jr c, loop2416_333
380+  6681
381+  6681 ED 52        loop2416_33:                sbc hl,de
382+  6683 30 01                                jr nc, loop2416_4
383+  6685 19                                   add hl,de
384+  6686
385+  6686 CB 11        loop2416_4:                 rl c
386+  6688 17                                   rla
387+  6689 ED 6A                                adc hl,hl
388+  668B 38 51                                jr c, loop2416_444
389+  668D
390+  668D ED 52        loop2416_44:                sbc hl,de
391+  668F 30 01                                jr nc, loop2416_5
392+  6691 19                                   add hl,de
393+  6692
394+  6692 CB 11        loop2416_5:                 rl c
395+  6694 17                                   rla
396+  6695 ED 6A                                adc hl,hl
397+  6697 38 4C                                jr c, loop2416_555
398+  6699
399+  6699 ED 52        loop2416_55:                sbc hl,de
400+  669B 30 01                                jr nc, loop2416_6
401+  669D 19                                   add hl,de
402+  669E
403+  669E CB 11        loop2416_6:                 rl c
404+  66A0 17                                   rla
405+  66A1 ED 6A                                adc hl,hl
406+  66A3 38 47                                jr c, loop2416_666
407+  66A5
408+  66A5 ED 52        loop2416_66:                sbc hl,de
409+  66A7 30 01                                jr nc, loop2416_7
410+  66A9 19                                   add hl,de
411+  66AA
412+  66AA CB 11        loop2416_7:                 rl c
413+  66AC 17                                   rla
414+  66AD ED 6A                                adc hl,hl
415+  66AF 38 42                                jr c, loop2416_777
416+  66B1
417+  66B1 ED 52        loop2416_77:                sbc hl,de
418+  66B3 30 01                                jr nc, loop2416_8
419+  66B5 19                                   add hl,de
420+  66B6
421+  66B6 10 9E        loop2416_8:                 djnz loop2416_0
422+  66B8
423+  66B8 CB 11        exit_loop:              rl c
424+  66BA 17                                   rla
425+  66BB                                      ; ac = ~quotient, hl = remainder
426+  66BB EB                                   ex de,hl
427+  66BC 2F                                   cpl
428+  66BD 67                                   ld h,a
429+  66BE 79                                   ld a,c
430+  66BF 2F                                   cpl
431+  66C0 AF                                   xor a
432+  66C1 C9                                   ret
433+  66C2 B7           loop2416_000:               or a
434+  66C3 ED 52                                sbc hl,de
435+  66C5 B7                                   or a
436+  66C6 C3 62 66                             jp loop2416_1
437+  66C9 B7           loop2416_111:               or a
438+  66CA ED 52                                sbc hl,de
439+  66CC B7                                   or a
440+  66CD C3 6E 66                             jp loop2416_2
441+  66D0 B7           loop2416_222:               or a
442+  66D1 ED 52                                sbc hl,de
443+  66D3 B7                                   or a
444+  66D4 C3 7A 66                             jp loop2416_3
445+  66D7 B7           loop2416_333:               or a
446+  66D8 ED 52                                sbc hl,de
447+  66DA B7                                   or a
448+  66DB C3 86 66                             jp loop2416_4
449+  66DE B7           loop2416_444:               or a
450+  66DF ED 52                                sbc hl,de
451+  66E1 B7                                   or a
452+  66E2 C3 92 66                             jp loop2416_5
453+  66E5 B7           loop2416_555:               or a
454+  66E6 ED 52                                sbc hl,de
455+  66E8 B7                                   or a
456+  66E9 C3 9E 66                             jp loop2416_6
457+  66EC B7           loop2416_666:               or a
458+  66ED ED 52                                sbc hl,de
459+  66EF B7                                   or a
460+  66F0 C3 AA 66                             jp loop2416_7
461+  66F3 B7           loop2416_777:               or a
462+  66F4 ED 52                                sbc hl,de
463+  66F6 B7                                   or a
464+  66F7 C3 B6 66                             jp loop2416_8
465+  66FA              ;
# file closed: ../../Maths24/asm_divide24.asm
251   66FA                  INCLUDE	"../../Maths24/asm_addition24.asm"
# file opened: ../../Maths24/asm_addition24.asm
  1+  66FA              ; Addition---------------------------------------------------
  2+  66FA              ; BAHL = BHL+CDE Lead Sign bit - If overflows AHL then carry will be set resulting in B holding sign and rest of value, else AHL holds value
  3+  66FA              ; in reality will we aim for all values being S14.8 so bit 15 is always clear for overflow
  4+  66FA 78           AHLequBHLplusCDE:       ld      a,b                          ; if b sign and c sign were different then bit 7 of a will be 1 which means
  5+  66FB E6 80                                and     $80                          ; Signs are opposite there fore we can subtract to get difference
  6+  66FD A9                                   xor     c                            ;
  7+  66FE                                      JumpIfNegative .OppositeSigns        ;
  7+  66FE FA 1F 67    >                        jp		m, .OppositeSigns
  8+  6701 78           .SameSigns:             ld      a,b                          ; if they are both negative
  9+  6702 B1                                   or      c                            ; then we can do an add but also set the sign bit
 10+  6703                                      JumpIfNegative .BothNegative         ; optimisation so we can just do simple add if both positive
 10+  6703 FA 0E 67    >                        jp		m, .BothNegative
 11+  6706 ED 5A        .BothPositive:          adc     hl,de                        ; both positive so a will already be zero
 12+  6708 78                                   ld      a,b                          ; a = b + c + an carry from HL + DE
 13+  6709 89                                   adc     c                            ;
 14+  670A D0                                   ret     nc                           ; fi there was no carry then we are good
 15+  670B 06 01        .OverFlowPositive:      ld      b,1                          ; if we overflow from +BHL +  +CDE then we already have sign cleared in A and only 1 bit to roll into B + no sign bit
 16+  670D C9                                   ret
 17+  670E CB B8        .BothNegative:          res     7,b                          ; clear sign bits for both values
 18+  6710 CB B9                                res     7,c                          ; .
 19+  6712 ED 5A                                adc     hl,de                        ; now behave like they are both positive
 20+  6714 78                                   ld      a,b
 21+  6715 89                                   adc     c
 22+  6716 DA 1C 67                             jp      c,.OverFlowNegative          ; if there was carry we need to overflow into b
 23+  6719 F6 80                                or      %10000000                    ; set bit 7 of A for negative
 24+  671B C9                                   ret
 25+  671C 06 81        .OverFlowNegative:      ld      b,%10000001                  ; carry over the bit but also set the sign bit
 26+  671E C9                                   ret
 27+  671F CB 78        .OppositeSigns:         bit     7,b                         ; if BHL was negative then
 28+  6721 C2 28 67                             jp      nz,.CDEMinusBHL             ; its CDE - BHL
 29+  6724 EB           .BHLMinusCDE:           ex      hl,de                       ; it must be BHL - CDE  so we swap registers and just treat it as CDE-BHL
 30+  6725 78                                   ld      a,b                         ; and we have to use a when swapping b and c
 31+  6726 41                                   ld      b,c                         ; .
 32+  6727 4F                                   ld      c,a                         ; .
 33+  6728              .CDEMinusBHL:           ClearCarryFlag                      ; now its just common CDE-BHL
 33+  6728 B7          >                        or a
 34+  6729 79                                   ld      a,c                         ; a= c - b
 35+  672A 98                                   sbc     b
 36+  672B EB                                   ex      hl,de                       ; hl = DE-hl by swapping them round
 37+  672C ED 52                                sbc     hl,de                       ; now AHL is result
 38+  672E D0                                   ret     nc                          ; if there was no carry then we are good
 39+  672F F6 80        .CDEFlipSign:           or      %10000000                   ; as CDE-BHL became negative we flip the lead bit of A
 40+  6731 C9                                   ret
 41+  6732              SwapViaA:               MACRO   r1, r2
 42+  6732 ~                                    ld      a,r1
 43+  6732 ~                                    ld      r1,r2
 44+  6732 ~                                    ld      r2,a
 45+  6732                                      ENDM
 46+  6732              AHLequHLAddCarryAViaDE: MACRO
 47+  6732 ~                                    ld      d,0                         ; de = P1 carry
 48+  6732 ~                                    ld      e,a                         ; .
 49+  6732 ~                                    xor     a                           ; Clear carry and prep a for P2 carry
 50+  6732 ~                                    add     hl,de                       ; .
 51+  6732 ~                                    adc     a,a                         ; .
 52+  6732                                      ENDM
 53+  6732
 54+  6732              ; AHL = BHL-CDE Lead Sign bit
 55+  6732              ; here we just fip C sign and call add
 56+  6732 79           AHLequBHLminusCDE:      ld      a,c
 57+  6733 EE 80                                xor     %10000000
 58+  6735 4F                                   ld      c,a
 59+  6736 C3 FA 66                             jp      AHLequBHLplusCDE
 60+  6739              ; If it will fit
 61+  6739              ;  HLBC = BHL * CDE  Lead Sign bit, carry Clear
 62+  6739              ; else
 63+  6739              ;  AHLBC = BHL * CDE Lead sign bit , carry set
 64+  6739              ; performs p0 = x0*y0                               L*E
 65+  6739              ;          p1 = x1*y0 + x0*y1 + p0 carry            H*E + D*L
 66+  6739              ;          p2 = x2*y0 + x0*y2 + x1*y1 + p1 carry    B*E + L*C + H*D
 67+  6739              ;          p3 = x2*y1 + x1 * y2 + p2 carry          B*D + H*C
 68+  6739              ;          p4 = x2* y2                              B*C
 69+  6739              ; reverse order for stack retrival                                                                                              B H L  C D E
 70+  6739              ; performs p4 = x2* y2                              B*C                B*C                     leave as is           BHL*CDE   020305 01040A 0201            02                  P4 = 2
 71+  6739              ;          p3 = x2*y1 + x1 * y2 + p2 carry          B*D + H*C          Swap B<>E and C<>L      E*D + H * L           EHC*LDB    E H C  L D B 0204 0301       08+03 = 0B          P3 = B
 72+  6739              ;          p2 = x2*y0 + x0*y2 + x1*y1 + p1 carry    E*B + C*L + H*D    Swap B<>D and C<>H      E*D + H * L + C * B   ECH*LBD    E C H  L B D 020A 0501 0304  14+05+0C=25         P2 = 25
 73+  6739              ;          p1 = x1*y0 + x0*y1                       C*D + H*B          Swap C<>E and L<>B      E*D + H * L           CEH*BLD    C E H  B L D 030A 0504       1E+14 = 32          P1 = 32 carry = 0
 74+  6739              ;          p0 = x0*y0                               C*B                Swap E,H, ex hl,de in calc                    CHE*BDL                 050A            32                  P0 = 32 Carry = 0
 75+  6739 78           HLBCequBHLmulCDE:       ld      a,b                         ; multiply is simpler as same signs is always positive
 76+  673A A9                                   xor     c                           ; opposite is always negative
 77+  673B E6 80                                and     $80                         ; .
 78+  673D F5           .SaveSign:              push    af                          ; save a to the stack that will now hold 0 or $80,
 79+  673E CB B8        .ClearSignBits:         res     7,b
 80+  6740 CB B9                                res     7,c
 81+  6742 C5           .PrepP4:                push    bc                          ; save registers for p4 = x2*y2 p3 carry > BC = x0 y0
 82+  6743              .PrepP3:                SwapViaA b,e                        ; save registers for p3  = x2*y1 + x1*y2 + p2 carry
 82+  6743 78          >                        ld      a,b
 82+  6744 43          >                        ld      b,e
 82+  6745 5F          >                        ld      e,a
 83+  6746                                      SwapViaA c,l
 83+  6746 79          >                        ld      a,c
 83+  6747 4D          >                        ld      c,l
 83+  6748 6F          >                        ld      l,a
 84+  6749 D5 E5                                push    de,,hl                      ; DE = X2 Y1 HL = X1 Y2
 85+  674B              .PrepP2:                SwapViaA d,b                         ; save registers for p2  = x2*y0 + x0*y2 + x1*y1 + p1 carry
 85+  674B 7A          >                        ld      a,d
 85+  674C 50          >                        ld      d,b
 85+  674D 47          >                        ld      b,a
 86+  674E                                      SwapViaA c,h
 86+  674E 79          >                        ld      a,c
 86+  674F 4C          >                        ld      c,h
 86+  6750 67          >                        ld      h,a
 87+  6751 D5 E5 C5                             push    de,,hl,,bc                  ; save registers for p1 = x1*y0 + x0*y1 + p0 carry
 88+  6754              .PrepP1:                SwapViaA c,e
 88+  6754 79          >                        ld      a,c
 88+  6755 4B          >                        ld      c,e
 88+  6756 5F          >                        ld      e,a
 89+  6757                                      SwapViaA l,b
 89+  6757 7D          >                        ld      a,l
 89+  6758 68          >                        ld      l,b
 89+  6759 47          >                        ld      b,a
 90+  675A D5 E5                                push    de,,hl
 91+  675C              .PrepP0:                SwapViaA e,h                        ; we don't care about original values now as they are on the stack
 91+  675C 7B          >                        ld      a,e
 91+  675D 5C          >                        ld      e,h
 91+  675E 67          >                        ld      h,a
 92+  675F ED 30        .CalcP0:                mul     de                          ; de = x0 * y0 no need for carry logic as even FF*FF = FE01
 93+  6761 42 4B                                ld      bc,de                       ; so b = P0 carry,c = P0
 94+  6763 D1           .CalcP1:                pop     de                          ; get P1 components off stack
 95+  6764 ED 30                                mul     de                          ; hl = x1*y0
 96+  6766 EB                                   ex      de,hl                       ; so de = P1c P1 b =P0c P0
 97+  6767 AF           .AddP0Carry:            xor     a                           ; hl = x1*y0 + P0 carry
 98+  6768 16 00                                ld      d,0                         ; .
 99+  676A 58                                   ld      e,b                         ; .
100+  676B 19                                   add     hl,de                       ; .
101+  676C 8F                                   adc     a,a                         ; a = carry
102+  676D D1                                   pop     de
103+  676E ED 30                                mul     de                          ; de = x0*y1
104+  6770 A7                                   and     a                           ; clear carry flag whilst retaining a
105+  6771 19                                   add     hl,de                       ; hl = x1*y0 + x0*y1
106+  6772 CE 00        .CalcP1Carry:           adc     a,0                         ;
107+  6774 84                                   add     h                           ; a = P1 carry
108+  6775 45                                   ld      b,l                         ; A = P1 carry bc = P1 P0
109+  6776 D1           .CalcP2:                pop     de                          ; we pull in bc later directly into de
110+  6777 ED 30                                mul     de                          ; hl = x2*y0
111+  6779 EB                                   ex      hl,de                       ; .
112+  677A              .AddP1Carry:            AHLequHLAddCarryAViaDE
112+  677A 16 00       >                        ld      d,0                         ; de = P1 carry
112+  677C 5F          >                        ld      e,a                         ; .
112+  677D AF          >                        xor     a                           ; Clear carry and prep a for P2 carry
112+  677E 19          >                        add     hl,de                       ; .
112+  677F 8F          >                        adc     a,a                         ; .
113+  6780 D1           .CalcP2Pt2:             pop     de                          ; de = x0*y2
114+  6781 ED 30                                mul     de                          ; .
115+  6783 A7                                   and     a                           ; Clear carry preserve a
116+  6784 19                                   add     hl,de                       ; hl = x2*y0 + x0*y2
117+  6785 8F                                   adc     a,a                         ; a = new carry
118+  6786 D1           .CalcP2Pt3:             pop     de                          ; de = x1*y1
119+  6787 ED 30                                mul     de                          ; .
120+  6789 A7                                   and     a                           ; hl = x2*y0 + x0*y2 + x1*y1, preserve carry flag
121+  678A 19                                   add     hl,de                       ; so we have hl = P2c P2 BC = P1P1
122+  678B CE 00        .CalcP2Carry:           adc     a,0                         ; A = calc carry + P2 carry in h
123+  678D 84                                   add     a,h                         ; l = P2 bc = P1 P0
124+  678E 5D                                   ld      e,l                         ; ixl = l (via e as you can't do hl to ix direct)
125+  678F DD 6B        .SaveP2:                ld      ixl,e                       ; a = P2 carry ixl:bc = P2 P1 P0
126+  6791 D1           .CalcP3                 pop     de                          ; hl = x2*y1
127+  6792 ED 30                                mul     de                          ; .
128+  6794 EB                                   ex      de,hl                       ; .
129+  6795              .AddP2Carry:            AHLequHLAddCarryAViaDE
129+  6795 16 00       >                        ld      d,0                         ; de = P1 carry
129+  6797 5F          >                        ld      e,a                         ; .
129+  6798 AF          >                        xor     a                           ; Clear carry and prep a for P2 carry
129+  6799 19          >                        add     hl,de                       ; .
129+  679A 8F          >                        adc     a,a                         ; .
130+  679B D1           .CalcP3Pt2:             pop     de                          ; de =  x1*y2
131+  679C ED 30                                mul     de                          ; .
132+  679E A7                                   and     a                           ; Clear carry preserve a
133+  679F 19                                   add     hl,de                       ; hl = x2*y1 + x1*y2
134+  67A0 CE 00                                adc     a,0                         ; a = new carry for P3, l = p3
135+  67A2 84                                   add     a,h                         ; .
136+  67A3 5D           .SaveP3:                ld      e,l                         ; load ixh via e
137+  67A4 DD 63                                ld      ixh,e                       ; so we now have a = P3 carry ix P3P2 bc = P1P0
138+  67A6 D1           .CalcP4:                pop     de                          ; de = x2* y2 + P3 carry
139+  67A7 ED 30                                mul     de                          ; .
140+  67A9 EB                                   ex      de,hl                       ;
141+  67AA              .AddP3Carry:            AHLequHLAddCarryAViaDE              ; hl ix bc = P5P4 P3P2 P1P0
141+  67AA 16 00       >                        ld      d,0                         ; de = P1 carry
141+  67AC 5F          >                        ld      e,a                         ; .
141+  67AD AF          >                        xor     a                           ; Clear carry and prep a for P2 carry
141+  67AE 19          >                        add     hl,de                       ; .
141+  67AF 8F          >                        adc     a,a                         ; .
142+  67B0 7D           .RecoverSignBit:        ld      a,l                         ; Is P4 populated,
143+  67B1 A7                                   and     a
144+  67B2 CA BB 67                             jp      z,.P3toP0                   ; if not then we have result P3P2P1P0
145+  67B5 F1           .P4toP0:                pop     af                          ; else return with AHLBC
146+  67B6 B5                                   or      l
147+  67B7 DD E5 E1                             ld      hl,ix
148+  67BA C9                                   ret
149+  67BB F1           .P3toP0:                pop     af
150+  67BC DD E5 E1                             ld      hl,ix                       ; move P2P2 into hl
151+  67BF B4                                   or      h
152+  67C0 67                                   ld      h,a
153+  67C1 AF                                   xor     a                           ; return result in hlbc with CarryClear
154+  67C2 C9                                   ret
155+  67C3
156+  67C3 F1           ResultIsZero:           pop     af                          ; get rid of unwanted sign bits
157+  67C4 4B                                   ld      c,e                         ; CDE = EHL as remainder
158+  67C5 EB                                   ex      hl,de
159+  67C6 AF                                   xor     a                           ; result AHL = $0
160+  67C7 67                                   ld      h,a
161+  67C8 6F                                   ld      l,a                         ; .
162+  67C9 C9                                   ret
163+  67CA
164+  67CA F1           DivideByZero:           pop     af                          ; get rid of unwanted sign bits
165+  67CB 4B                                   ld      c,e                         ; CDE = EHL as remainder
166+  67CC EB                                   ex      hl,de
167+  67CD 3E FF                                ld      a,$FF                       ; result AHL = $FFFFFF
168+  67CF 21 FF FF                             ld      hl,$FFFF                    ; .
169+  67D2                                      SetCarryFlag                        ; and carry set
169+  67D2 37          >                        scf
170+  67D3 C9                                   ret
171+  67D4
172+  67D4
173+  67D4              ; AHL = EHL / DBC  Lead Sign bit; CDE = remainder carry clear, divide by 0 gives AHL $FFFFFF, carry set
174+  67D4 7B           AHLequEHLdivDBC:        ld      a,e                         ; divide is simpler as same signs is always positive
175+  67D5 AA                                   xor     d                           ; opposite is always negative
176+  67D6 E6 80                                and     $80                         ; .
177+  67D8 F5           .SaveSign:              push    af                          ; save a to the stack that will now hold 0 or $80,
178+  67D9 CB BB        .ClearSignBits:         res     7,e
179+  67DB CB BA                                res     7,d
180+  67DD 7A           .CheckDivideByZero:     ld      a,d
181+  67DE B0                                   or      b
182+  67DF B1                                   or      c
183+  67E0 28 E8                                jr      z,DivideByZero
184+  67E2                                      ;DEBUG jp      Perform_24x24   ; forece 24 bit
185+  67E2              ; Now determine the scale down, e.g. can we do smaller divides than just 24x24
186+  67E2              ; Patterns              24x24 OK                         1C
187+  67E2              ;                       24x16 OK                         1E
188+  67E2              ;                       24x8  OK                         1F
189+  67E2              ;                       16x24 0                          1I
190+  67E2              ;                       16x16 OK                         1J
191+  67E2              ;                       16x8  OK                         1L
192+  67E2              ;                       8x24  0                          1N
193+  67E2              ;                       8x16  0                          1N
194+  67E2              ;                       8x8   OK                         1O
195+  67E2              ; flow is               check if its 24 / ?              1A
196+  67E2              ;                       Y > test 24/24                   1B
197+  67E2              ;                           Y > Perform 24x24            1C
198+  67E2              ;                           N > Check   24x16            1D
199+  67E2              ;                               Y > Perform 24x16        1E
200+  67E2              ;                               N > Perform 24x8         1F
201+  67E2              ;                       N > test 16/ ?                   1G
202+  67E2              ;                           Y > Check 16/24              1H
203+  67E2              ;                               Y > Result 0             1I
204+  67E2              ;                               N > Check 16/16          1J
205+  67E2              ;                                   Y > Perform 16/16    1K
206+  67E2              ;                                   N > Perform 16/8     1L
207+  67E2              ;                           N > Check 08/24 or 08/16     1M
208+  67E2              ;                               Y > Result is 0          1N
209+  67E2              ;                               N > Perform 8/8          1O
210+  67E2 1C           .ValidDivide:           inc     e
211+  67E3 1D                                   dec     e
212+  67E4 20 1E                                jr      nz,Try_24xAnything         ; its at least ehl / something
213+  67E6 24           .Test_16x:              inc     h
214+  67E7 25                                   dec     h
215+  67E8 20 0D                                jr      nz, .Try_16xAnything        ; its at least hl / something
216+  67EA 14           .Try_8xAnything:        inc     d
217+  67EB 15                                   dec     d
218+  67EC C2 C3 67                             jp      nz, ResultIsZero            ; its l / dbc which is always zero
219+  67EF 05                                   dec     b
220+  67F0 04                                   inc     b
221+  67F1 C2 C3 67                             jp      nz, ResultIsZero            ; its l / bc which is always zero
222+  67F4 C3 4E 6B                             jp      Perform_8x8
222+  67F7                               ; its l/b
223+  67F7 14           .Try_16xAnything:       inc     d
224+  67F8 15                                   dec     d
225+  67F9 C2 C3 67                             jp      nz, ResultIsZero            ; its hl / dbc which is always zero
226+  67FC 05                                   dec     b
227+  67FD 04                                   inc     b
228+  67FE C2 8E 6A                             jp      nz, Perform_16x16           ; its hl/bc
229+  6801 C3 DD 6A                             jp      Perform_16x8                ; so it must be hl/c
230+  6804              ;--------------------------------------------------------------------------------------------------
231+  6804              ; Div 24x24 iteration
232+  6804
233+  6804              ;--------------------------------------------------------------------------------------------------
234+  6804              ; AHL = EHL/DBC, EHL > DBC both >= 01 00 00
235+  6804                  DISPLAY "24x24 Actual internal result currently is 0L.D so need to rationalise it to AHL"
236+  6804                  DISPLAY "Working on one 24x24 only"
237+  6804                  DISPLAY "In effect 24x24 where E and D are both > 0 means e/d"
238+  6804              Try_24xAnything:        ;inc     d
239+  6804                                      ;dec     d
240+  6804                                      ;jp      nz,Perform_24x24           ; if d was not zero then its ehl/dbc
241+  6804                                      ;ld      a,b
242+  6804                                      ;and     $80
243+  6804                                      ;dec     b
244+  6804                                      ;inc     b
245+  6804                                      ;jp      z,Perform_24x8              ; if b was zero then its ehl/00c
246+  6804                                      ;jp      Perform_24x16               ; else it leaves us with ehl/0bc
247+  6804              ; {er
248+  6804 7B           Perform_24x24:          ld      a,e                         ; EHL => HLE  AHL
249+  6805 5D                                   ld      e,l                         ;             AHE
250+  6806 6C                                   ld      l,h                         ;             ALE
251+  6807 67                                   ld      h,a                         ;             HLE
252+  6808 AF                                   xor     a                           ;             A = 0 Celar carry flag
253+  6809              .eliminateLeadingZeros:
254+  6809 CB 13        .loop_00:               rl e                                ; HLE << 1
255+  680B ED 6A                                adc hl,hl                           ;
256+  680D 38 36                                jr c, .loop_10                      ; if HLE bit 7 was set prior to shift goto loop_10  HLE was %1XXXXXXX XXXXXXXX XXXXXXX
257+  680F CB 13                                rl e                                ; (HLE << 1) + 1
258+  6811 1C                                   inc e                               ;
259+  6812 ED 6A                                adc hl,hl                           ;
260+  6814 38 3B                                jr c, .loop_20                      ; if HLE bit 6 was set prior to shift goto loop_20  HLE was %01XXXXXX XXXXXXXX XXXXXXX
261+  6816 CB 13                                rl e                                ; (HLE << 1) + 1
262+  6818 1C                                   inc e                               ;
263+  6819 ED 6A                                adc hl,hl                           ;
264+  681B 38 40                                jr c, .loop_30                      ; if HLE bit 5 was set prior to shift goto loop_30  HLE was %001XXXXX XXXXXXXX XXXXXXX
265+  681D CB 13                                rl e                                ; (HLE << 1) + 1
266+  681F 1C                                   inc e                               ;
267+  6820 ED 6A                                adc hl,hl                           ;
268+  6822 38 45                                jr c, .loop_40                      ; if HLE bit 4 was set prior to shift goto loop_40  HLE was %0001XXXX XXXXXXXX XXXXXXX
269+  6824 CB 13                                rl e                                ; (HLE << 1) + 1
270+  6826 1C                                   inc e                               ;
271+  6827 ED 6A                                adc hl,hl                           ;
272+  6829 38 4A                                jr c, .loop_50                      ; if HLE bit 3 was set prior to shift goto loop_50  HLE was %00001XXX XXXXXXXX XXXXXXX
273+  682B CB 13                                rl e                                ; (HLE << 1) + 1
274+  682D 1C                                   inc e                               ;
275+  682E ED 6A                                adc hl,hl                           ;
276+  6830 38 4F                                jr c, .loop_60                      ; if HLE bit 2 was set prior to shift goto loop_50  HLE was %000001XX XXXXXXXX XXXXXXX
277+  6832 CB 13                                rl e                                ; (HLE << 1) + 1
278+  6834 1C                                   inc e                               ;
279+  6835 ED 6A                                adc hl,hl                           ;
280+  6837 38 54                                jr c, .loop_70                      ; if HLE bit 1 was set prior to shift goto loop_50  HLE was %0000001X XXXXXXXX XXXXXXX
281+  6839 37                                   scf                                 ; set carry and jump to loop 7 as bit 0 of HLE must have been set
282+  683A CB 13                                rl e                                ; (HLE << 1) + 1
283+  683C 1C                                   inc e                               ;
284+  683D ED 6A                                adc hl,hl                           ;
285+  683F 38 58                                jr c, .loop_80                      ; if HLE bit 0 was set prior to shift goto loop_50  HLE was %0000001X XXXXXXXX XXXXXXX
286+  6841 37                                   scf                                 ; set carry and jump to loop 7 as bit 0 of HLE must have been set
287+  6842 C3 95 68                             jp .loop_7
288+  6845 17           .loop_10:               rla                                 ; A = A *2 + carry from  HLE * 2 (on first pass A = 0)
289+  6846 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
290+  6848 9A                                   sbc a,d                             ;
291+  6849 30 02                                jr nc, .loop_1                      ; if AHL is negative
292+  684B 09                                   add hl,bc                           ;   revert AHL back to prior value
293+  684C 8A                                   adc a,d                             ;   .
294+  684D CB 13        .loop_1:                rl e                                ; else
295+  684F ED 6A                                adc hl,hl                           ;   HLE = HLE * 2
296+  6851 17           .loop_20:               rla                                 ; A = carry from  HLE * 2
297+  6852 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
298+  6854 9A                                   sbc a,d                             ;
299+  6855 30 02                                jr nc, .loop_2                       ; if AHL is negative
300+  6857 09                                   add hl,bc                           ;   revert AHL back to prior value
301+  6858 8A                                   adc a,d                             ;   .
302+  6859 CB 13        .loop_2:                rl e                                ; else
303+  685B ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
304+  685D 17           .loop_30:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
305+  685E ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
306+  6860 9A                                   sbc a,d                             ;
307+  6861 30 02                                jr nc, .loop_3                       ; if AHL is negative
308+  6863 09                                   add hl,bc                           ;   revert AHL back to prior value
309+  6864 8A                                   adc a,d                             ;   .
310+  6865 CB 13        .loop_3:                rl e                                ; else
311+  6867 ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
312+  6869 17           .loop_40:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
313+  686A ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
314+  686C 9A                                   sbc a,d                             ;
315+  686D 30 02                                jr nc, .loop_4                       ; if AHL is negative
316+  686F 09                                   add hl,bc                           ;   revert AHL back to prior value
317+  6870 8A                                   adc a,d                             ;   .
318+  6871 CB 13        .loop_4:                rl e                                ; else
319+  6873 ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
320+  6875 17           .loop_50:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
321+  6876 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
322+  6878 9A                                   sbc a,d                             ;
323+  6879 30 02                                jr nc, .loop_5                       ; if AHL is negative
324+  687B 09                                   add hl,bc                           ;   revert AHL back to prior value
325+  687C 8A                                   adc a,d                             ;   .
326+  687D CB 13        .loop_5:                rl e                                ; else
327+  687F ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
328+  6881 17           .loop_60:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
329+  6882 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
330+  6884 9A                                   sbc a,d                             ;
331+  6885 30 02                                jr nc, .loop_6                       ; if AHL is negative
332+  6887 09                                   add hl,bc                           ;   revert AHL back to prior value
333+  6888 8A                                   adc a,d                             ;   .
334+  6889 CB 13        .loop_6:                rl e                                ; else
335+  688B ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
336+  688D 17           .loop_70:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
337+  688E ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
338+  6890 9A                                   sbc a,d                             ;
339+  6891 30 02                                jr nc, .loop_7                       ; if AHL is negative
340+  6893 09                                   add hl,bc                           ;   revert AHL back to prior value
341+  6894 8A                                   adc a,d                             ;   .
342+  6895 CB 13        .loop_7:                rl e                                ; else
343+  6897 ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
344+  6899 17           .loop_80:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
345+  689A ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
346+  689C 9A                                   sbc a,d                             ;
347+  689D 30 02                                jr nc, .loop_8                       ; if AHL is negative
348+  689F 09                                   add hl,bc                           ;   revert AHL back to prior value
349+  68A0 8A                                   adc a,d                             ;   .
350+  68A1 CB 13        .loop_8:                rl e                                ; else
351+  68A3 ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
352+  68A5
353+  68A5
354+  68A5
355+  68A5 17                                   rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
356+  68A6 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
357+  68A8 9A                                   sbc a,d                             ;
358+  68A9 30 02                                jr nc, .exit_loop                    ; if AHL is negative
359+  68AB 09                                   add hl,bc                           ;   revert AHL back to prior value
360+  68AC 8A                                   adc a,d                             ;   .
361+  68AD              ; quotient  = ~e[hl'] remainder =  ahl  one more shift left on quotient
362+  68AD EB           .exit_loop:             ex de,hl                            ; ADE = AHL  HL = DE
363+  68AE 4F                                   ld c,a                              ; CDE = ADE
364+  68AF 7D                                   ld a,l                              ; L = (L*2) * -1 (as we reach here via jr nc then carry is 0
365+  68B0 17                                   rla                                 ; .
366+  68B1 2F                                   cpl                                 ; .
367+  68B2 6F                                   ld l,a                              ; .
368+  68B3 AF                                   xor a                               ; h = 0
369+  68B4 67                                   ld h,a
370+  68B5 C3 8A 6A                             jp      HandleSign
371+  68B8              ;-----------------------------------------------------------------------------------------------------
372+  68B8              ; AHL = HLE/BC, where A is always 0 return EHL > DBC EHL >= 01 00 00 DBC >= 00 01 00
373+  68B8              ; inside loop computation is ehl / c  hl = remainder
374+  68B8 50           Perform_24x16:          ld      d,b                         ; HLE/BC => HLE/DC
375+  68B9 7B                                   ld      a,e                         ;           HLA/DC
376+  68BA 59                                   ld      e,c                         ;           HLA/DE
377+  68BB 4D                                   ld      c,l                         ;           HCA/DE
378+  68BC 6F                                   ld      l,a                         ;           HCL/DE
379+  68BD 7C                                   ld      a,h                         ;           ACL/DE
380+  68BE 26 00                                ld      h,0                         ;           ACL/DE
381+  68C0 06 02                                ld      b,2                         ;           ACB/DE (B = 2)
382+  68C2 CB 11        .eliminateLeadingZeros: rl c
383+  68C4 17                                   rla
384+  68C5 ED 6A                                adc hl,hl
385+  68C7 24                                   inc h
386+  68C8 25                                   dec h
387+  68C9 20 47                                jr nz, .loop_00
388+  68CB CB 11                                rl c
389+  68CD 0C                                   inc c
390+  68CE 17                                   rla
391+  68CF ED 6A                                adc hl,hl
392+  68D1 24                                   inc h
393+  68D2 25                                   dec h
394+  68D3 20 49                                jr nz, .loop_11
395+  68D5 CB 11                                rl c
396+  68D7 0C                                   inc c
397+  68D8 17                                   rla
398+  68D9 ED 6A                                adc hl,hl
399+  68DB 24                                   inc h
400+  68DC 25                                   dec h
401+  68DD 20 4B                                jr nz, .loop_22
402+  68DF CB 11                                rl c
403+  68E1 0C                                   inc c
404+  68E2 17                                   rla
405+  68E3 ED 6A                                adc hl,hl
406+  68E5 24                                   inc h
407+  68E6 25                                   dec h
408+  68E7 20 4D                                jr nz, .loop_33
409+  68E9 CB 11                                rl c
410+  68EB 0C                                   inc c
411+  68EC 17                                   rla
412+  68ED ED 6A                                adc hl,hl
413+  68EF 24                                   inc h
414+  68F0 25                                   dec h
415+  68F1 20 4F                                jr nz, .loop_44
416+  68F3 CB 11                                rl c
417+  68F5 0C                                   inc c
418+  68F6 17                                   rla
419+  68F7 ED 6A                                adc hl,hl
420+  68F9 24                                   inc h
421+  68FA 25                                   dec h
422+  68FB 20 51                                jr nz, .loop_55
423+  68FD CB 11                                rl c
424+  68FF 0C                                   inc c
425+  6900 17                                   rla
426+  6901 ED 6A                                adc hl,hl
427+  6903 24                                   inc h
428+  6904 25                                   dec h
429+  6905 20 53                                jr nz, .loop_66
430+  6907 37                                   scf
431+  6908 C3 5F 69                             jp .loop_7
432+  690B CB 11        .loop_0:                rl c
433+  690D 17                                   rla
434+  690E ED 6A                                adc hl,hl
435+  6910 38 68                                jr c, .loop_000
436+  6912 ED 52        .loop_00:               sbc hl,de
437+  6914 30 01                                jr nc, .loop_1
438+  6916 19                                   add hl,de
439+  6917 CB 11        .loop_1:                rl c
440+  6919 17                                   rla
441+  691A ED 6A                                adc hl,hl
442+  691C 38 63                                jr c, .loop_111
443+  691E ED 52        .loop_11:               sbc hl,de
444+  6920 30 01                                jr nc, .loop_2
445+  6922 19                                   add hl,de
446+  6923 CB 11        .loop_2:                rl c
447+  6925 17                                   rla
448+  6926 ED 6A                                adc hl,hl
449+  6928 38 5E                                jr c, .loop_222
450+  692A ED 52        .loop_22:               sbc hl,de
451+  692C 30 01                                jr nc, .loop_3
452+  692E 19                                   add hl,de
453+  692F CB 11        .loop_3:                rl c
454+  6931 17                                   rla
455+  6932 ED 6A                                adc hl,hl
456+  6934 38 59                                jr c, .loop_333
457+  6936 ED 52        .loop_33:               sbc hl,de
458+  6938 30 01                                jr nc, .loop_4
459+  693A 19                                   add hl,de
460+  693B CB 11        .loop_4:                rl c
461+  693D 17                                   rla
462+  693E ED 6A                                adc hl,hl
463+  6940 38 54                                jr c, .loop_444
464+  6942 ED 52        .loop_44:               sbc hl,de
465+  6944 30 01                                jr nc, .loop_5
466+  6946 19                                   add hl,de
467+  6947 CB 11        .loop_5:                rl c
468+  6949 17                                   rla
469+  694A ED 6A                                adc hl,hl
470+  694C 38 4F                                jr c, .loop_555
471+  694E ED 52        .loop_55:               sbc hl,de
472+  6950 30 01                                jr nc, .loop_6
473+  6952 19                                   add hl,de
474+  6953 CB 11        .loop_6:                rl c
475+  6955 17                                   rla
476+  6956 ED 6A                                adc hl,hl
477+  6958 38 4A                                jr c, .loop_666
478+  695A ED 52        .loop_66:               sbc hl,de
479+  695C 30 01                                jr nc, .loop_7
480+  695E 19                                   add hl,de
481+  695F CB 11        .loop_7:                rl c
482+  6961 17                                   rla
483+  6962 ED 6A                                adc hl,hl
484+  6964 38 45                                jr c, .loop_777
485+  6966 ED 52        .loop_77:               sbc hl,de
486+  6968 30 01                                jr nc, .loop_8
487+  696A 19                                   add hl,de
488+  696B 10 9E        .loop_8:                djnz .loop_0
489+  696D CB 11        .exit_loop:             rl c
490+  696F 17                                   rla
491+  6970                                      ; ac = ~quotient, hl = remainder
492+  6970 EB                                   ex de,hl
493+  6971 2F                                   cpl
494+  6972 67                                   ld h,a
495+  6973 79                                   ld a,c
496+  6974 2F                                   cpl
497+  6975 6F                                   ld l,a
498+  6976 AF                                   xor a
499+  6977 C3 8A 6A                             jp      HandleSign
500+  697A B7           .loop_000:              or a
501+  697B ED 52                                sbc hl,de
502+  697D B7                                   or a
503+  697E C3 17 69                             jp .loop_1
504+  6981 B7           .loop_111:              or a
505+  6982 ED 52                                sbc hl,de
506+  6984 B7                                   or a
507+  6985 C3 23 69                             jp .loop_2
508+  6988 B7           .loop_222:              or a
509+  6989 ED 52                                sbc hl,de
510+  698B B7                                   or a
511+  698C C3 2F 69                             jp .loop_3
512+  698F B7           .loop_333:              or a
513+  6990 ED 52                                sbc hl,de
514+  6992 B7                                   or a
515+  6993 C3 3B 69                             jp .loop_4
516+  6996 B7           .loop_444:              or a
517+  6997 ED 52                                sbc hl,de
518+  6999 B7                                   or a
519+  699A C3 47 69                             jp .loop_5
520+  699D B7           .loop_555:              or a
521+  699E ED 52                                sbc hl,de
522+  69A0 B7                                   or a
523+  69A1 C3 53 69                             jp .loop_6
524+  69A4 B7           .loop_666:              or a
525+  69A5 ED 52                                sbc hl,de
526+  69A7 B7                                   or a
527+  69A8 C3 5F 69                             jp .loop_7
528+  69AB B7           .loop_777:              or a
529+  69AC ED 52                                sbc hl,de
530+  69AE B7                                   or a
531+  69AF C3 6B 69                             jp .loop_8
532+  69B2              ;-----------------------------------------------------------------------------------------------------
533+  69B2              ; AHL = HLE/BC, where A is always 0 return EHL > DBC EHL >= 01 00 00 DBC >= 00 00 01
534+  69B2              ; inside loop computation is abc/de, hl = remainder
535+  69B2              ; EHL: = EHL/C
536+  69B2              ;so currerntly thsi can't hadnle c > 127 so need to understand lead sign at lower bit levels on c
537+  69B2              ;so could just do 24 bit and process lead zeros in h and hope that is enough? or have a special case
538+  69B2              ;for collapsing lead zeros in dbc too
539+  69B2 79           Perform_24x8:           ld      a,c
540+  69B3 E6 80                                and     $80
541+  69B5 CA DE 69                             jp      z,Perform_24x7
542+  69B8 DD 26 18                             ld      ixh,24              ; from ehl/c to ABC/E
543+  69BB 7B                                   ld      a,e
544+  69BC 44                                   ld      b,h
545+  69BD 51                                   ld      d,c
546+  69BE 4D                                   ld      c,l
547+  69BF 5A                                   ld      e,d
548+  69C0 16 00                                ld      d,0
549+  69C2 21 00 00                             ld      hl,0                ;
550+  69C5                                      ; with c being 8 bit we need to do
551+  69C5 CB 21        .loop1:                 sla     c                   ; unroll 24 times
552+  69C7 CB 10                                rl      b                   ; ...
553+  69C9 17                                   rla                         ; ...
554+  69CA ED 6A                                adc     hl,hl               ; ...
555+  69CC ED 52                                sbc     hl,de               ; ...
556+  69CE 30 02                                jr      nc,.Skip1           ; ...
557+  69D0 19                                   add     hl,de               ; ...
558+  69D1 0D                                   dec     c                   ; ...
559+  69D2 DD 25        .Skip1:                 dec     ixh
560+  69D4 DD 01                                break
561+  69D6 C2 C5 69                             jp      nz,.loop1
562+  69D9 DD 01                                break
563+  69DB C3 8A 6A                             jp      HandleSign
564+  69DE 06 18        Perform_24x7:           ld b,24
565+  69E0 AF                                   xor a
566+  69E1 29           .loop1:                 add hl,hl
567+  69E2 CB 13                                rl e
568+  69E4 17                                   rla
569+  69E5                                      ;rl d
570+  69E5                                      ;rla
571+  69E5 B9                                   cp c
572+  69E6 38 02                                jr c, .Skip1
573+  69E8 91                                   sub c
574+  69E9 2C                                   inc l
575+  69EA 10 F5        .Skip1:                 djnz .loop1
576+  69EC DD 01                                break
577+  69EE C3 8A 6A                             jp      HandleSign
578+  69F1
579+  69F1                 ;   a = remainder
580+  69F1                 ; ehl = quotient
581+  69F1
582+  69F1 4F              ld c,a
583+  69F2 7B              ld a,e
584+  69F3 59              ld e,c
585+  69F4 50              ld d,b
586+  69F5
587+  69F5 B7              or a
588+  69F6 C9              ret
589+  69F7
590+  69F7
591+  69F7              ;.slow32x8:              ld      d,h ; do dehl / c
592+  69F7              ;                        ld      e,l
593+  69F7              ;                        ld      h,e
594+  69F7              ;                        ld      l,0
595+  69F7              ;                        xor     a
596+  69F7              ;.looping:               ld b,2
597+  69F7              ;.loop_11:               add hl,hl
598+  69F7              ;                        rl e
599+  69F7              ;                        rl d
600+  69F7              ;.loop_01:               rla
601+  69F7              ;                        jr c, .loop_02
602+  69F7              ;                        cp c
603+  69F7              ;                        jr c, .loop_03
604+  69F7              ;.loop_02:               sub c
605+  69F7              ;                        inc l
606+  69F7              ;.loop_03:               djnz .loop_11
607+  69F7 B7                                   or a
608+  69F8              ; result dehl = 32-bit quotient
609+  69F8              ;.slow:                  ld      b,24
610+  69F8              ;.loop_11:               add     hl,hl
611+  69F8              ;                        rl      e
612+  69F8              ;.loop_01:               rla
613+  69F8              ;                        jr      c, .loop_02
614+  69F8              ;                        cp      c
615+  69F8              ;                        jr      c, .loop_03
616+  69F8              ;.loop_02:               sub 01010c
617+  69F8              ;                        inc 01010l
618+  69F8              ;.loop_03:               djnz .loop_11
619+  69F8              ;                        ld c,a
620+  69F8              ;                        ld a,e
621+  69F8              ;                        ld e,c
622+  69F8              ;                        ld d,b
623+  69F8              ;                        or a
624+  69F8 C3 8A 6A                             jp      HandleSign
625+  69FB
626+  69FB AF           DEBUG:                        xor     a                           ;             A = 0 Clear carry flag
627+  69FC 06 03                                ld b,3
628+  69FE              .eliminateLeadingZeros:
629+  69FE 29           .loop_00:               add hl,hl
630+  69FF CB 13                                rl e
631+  6A01 38 2B                                jr c, .loop_10
632+  6A03 29                                   add hl,hl
633+  6A04 CB 13                                rl e
634+  6A06 38 31                                jr c, .loop_20
635+  6A08 29                                   add hl,hl
636+  6A09 CB 13                                rl e
637+  6A0B 38 37                                jr c, .loop_30
638+  6A0D 29                                   add hl,hl
639+  6A0E CB 13                                rl e
640+  6A10 38 3D                                jr c, .loop_40
641+  6A12 29                                   add hl,hl
642+  6A13 CB 13                                rl e
643+  6A15 38 43                                jr c, .loop_50
644+  6A17 29                                   add hl,hl
645+  6A18 CB 13                                rl e
646+  6A1A 38 49                                jr c, .loop_60
647+  6A1C 29                                   add hl,hl
648+  6A1D CB 13                                rl e
649+  6A1F 38 4F                                jr c, .loop_70
650+  6A21 29                                   add hl,hl
651+  6A22 CB 13                                rl e
652+  6A24 17                                   rla
653+  6A25 B9                                   cp c
654+  6A26 38 02                                jr c, .loop_80
655+  6A28 91                                   sub c
656+  6A29 2C                                   inc l
657+  6A2A 05           .loop_80:               dec b
658+  6A2B                 ; general divide loop
659+  6A2B 29           .loop_0:                add     hl,hl
660+  6A2C CB 13                                rl      e
661+  6A2E 17           .loop_10:               rla
662+  6A2F 38 03                                jr      c, .loop_101
663+  6A31 B9                                   cp      c
664+  6A32 38 02                                jr      c, .loop_1
665+  6A34 91           .loop_101:              sub     c
666+  6A35 2C                                   inc     l
667+  6A36 29           .loop_1:                add     hl,hl
668+  6A37 CB 13                                rl      e
669+  6A39 17           .loop_20:               rla
670+  6A3A 38 03                                jr      c, .loop_201
671+  6A3C B9                                   cp      c
672+  6A3D 38 02                                jr      c, .loop_2
673+  6A3F 91           .loop_201:              sub     c
674+  6A40 2C                                   inc     l
675+  6A41 29           .loop_2:                add     hl,hl
676+  6A42 CB 13                                rl      e
677+  6A44 17           .loop_30:               rla
678+  6A45 38 03                                jr      c, .loop_301
679+  6A47 B9                                   cp      c
680+  6A48 38 02                                jr      c, .loop_3
681+  6A4A 91           .loop_301:              sub     c
682+  6A4B 2C                                   inc     l
683+  6A4C 29           .loop_3:                add     hl,hl
684+  6A4D CB 13                                rl      e
685+  6A4F 17           .loop_40:               rla
686+  6A50 38 03                                jr      c, .loop_401
687+  6A52 B9                                   cp      c
688+  6A53 38 02                                jr      c, .loop_4
689+  6A55 91           .loop_401:              sub     c
690+  6A56 2C                                   inc     l
691+  6A57 29           .loop_4:                add     hl,hl
692+  6A58 CB 13                                rl      e
693+  6A5A 17           .loop_50:               rla
694+  6A5B 38 03                                jr      c, .loop_501
695+  6A5D B9                                   cp      c
696+  6A5E 38 02                                jr      c, .loop_5
697+  6A60 91           .loop_501:              sub     c
698+  6A61 2C                                   inc     l
699+  6A62 29           .loop_5:                add     hl,hl
700+  6A63 CB 13                                rl      e
701+  6A65 17           .loop_60:               rla
702+  6A66 38 03                                jr      c, .loop_601
703+  6A68 B9                                   cp      c
704+  6A69 38 02                                jr      c, .loop_6
705+  6A6B 91           .loop_601:              sub     c
706+  6A6C 2C                                   inc     l
707+  6A6D 29           .loop_6:                add     hl,hl
708+  6A6E CB 13                                rl      e
709+  6A70 17           .loop_70:               rla
710+  6A71 38 03                                jr      c, .loop_701
711+  6A73 B9                                   cp      c
712+  6A74 38 02                                jr      c, .loop_7
713+  6A76 91           .loop_701:              sub     c
714+  6A77 2C                                   inc     l
715+  6A78 29           .loop_7:                add     hl,hl
716+  6A79 CB 13                                rl      e
717+  6A7B 17                                   rla
718+  6A7C 38 03                                jr      c, .loop_801
719+  6A7E B9                                   cp      c
720+  6A7F 38 02                                jr      c, .loop_8
721+  6A81 91           .loop_801:              sub     c
722+  6A82 2C                                   inc     l
723+  6A83 10 A6        .loop_8:                djnz    .loop_0
724+  6A85 4F           .exit_loop:             ld      c,a
725+  6A86 7B                                   ld      a,e
726+  6A87 59                                   ld      e,c
727+  6A88 50                                   ld      d,b
728+  6A89 B7                                   or      a
729+  6A8A 47           HandleSign:             ld      b,a ; save the a value      ; now deal with prior sign
730+  6A8B F1                                   pop     af
731+  6A8C B0                                   or      b                           ; now a holds saved sign and b result so now lead sign S15.8
732+  6A8D C9                                   ret
733+  6A8E              ;-----------------------------------------------------------------------------------------------------
734+  6A8E              ; AHL = HL/BC, EHL > DBC both >= 00 01 00
735+  6A8E 50 59        Perform_16x16:          ld      de,bc                       ; get to AHL= 0HL/0BC
736+  6A90 7D                                   ld      a,l                         ;hl >= $1000 de >= $1000 so max quotient is 255
737+  6A91 6C                                   ld      l,h                         ; which means the loop computation is a[c] / de hl = remainder
738+  6A92 26 00                                ld      h,0                         ; so we can initialise as if 8 iterations are done
739+  6A94              ; unrolling divide 8 time, eliminating leading zeros is only marginal gain
740+  6A94 17           .loop_0:                rla
741+  6A95 ED 6A                                adc     hl,hl
742+  6A97 ED 52        .loop_00:               sbc     hl,de
743+  6A99 30 01                                jr      nc, .loop_1
744+  6A9B 19                                   add     hl,de
745+  6A9C 17           .loop_1:                rla
746+  6A9D ED 6A                                adc     hl,hl
747+  6A9F ED 52        .loop_11:               sbc     hl,de
748+  6AA1 30 01                                jr      nc, .loop_2
749+  6AA3 19                                   add     hl,de
750+  6AA4 17           .loop_2:                rla
751+  6AA5 ED 6A                                adc     hl,hl
752+  6AA7 ED 52        .loop_22:               sbc     hl,de
753+  6AA9 30 01                                jr      nc, .loop_3
754+  6AAB 19                                   add     hl,de
755+  6AAC 17           .loop_3:                rla
756+  6AAD ED 6A                                adc     hl,hl
757+  6AAF ED 52        .loop_33:               sbc     hl,de
758+  6AB1 30 01                                jr      nc, .loop_4
759+  6AB3 19                                   add     hl,de
760+  6AB4 17           .loop_4:                rla
761+  6AB5 ED 6A                                adc     hl,hl
762+  6AB7 ED 52        .loop_44:               sbc     hl,de
763+  6AB9 30 01                                jr      nc, .loop_5
764+  6ABB 19                                   add     hl,de
765+  6ABC              .loop_5:
766+  6ABC 17                                   rla
767+  6ABD ED 6A                                adc     hl,hl
768+  6ABF              .loop_55:
769+  6ABF ED 52                                sbc     hl,de
770+  6AC1 30 01                                jr      nc, .loop_6
771+  6AC3 19                                   add     hl,de
772+  6AC4              .loop_6:
773+  6AC4 17                                   rla
774+  6AC5 ED 6A                                adc     hl,hl
775+  6AC7              .loop_66:
776+  6AC7 ED 52                                sbc     hl,de
777+  6AC9 30 01                                jr      nc, .loop_7
778+  6ACB 19                                   add     hl,de
779+  6ACC              .loop_7:
780+  6ACC 17                                   rla
781+  6ACD ED 6A                                adc     hl,hl
782+  6ACF ED 52        .loop_77:               sbc     hl,de
783+  6AD1 30 01                                jr      nc, .exit_loop
784+  6AD3 19                                   add     hl,de
785+  6AD4 17           .exit_loop:             rla                ; a = ~quotient, hl = remainder
786+  6AD5 2F                                   cpl
787+  6AD6 5F                                   ld      e,a
788+  6AD7 AF                                   xor     a
789+  6AD8 57                                   ld      d,a
790+  6AD9 EB                                   ex      de,hl
791+  6ADA C3 8A 6A                             jp      HandleSign
792+  6ADD              ;-----------------------------------------------------------------------------------------------------
793+  6ADD              ; AHL = HL/C, where A is always 0 return EHL > DBC both >= 00 01 00, internally does HL/E
794+  6ADD 59           Perform_16x8:           ld      e,c                          ; get to AHL= 0HL/00C
795+  6ADE AF                                   xor a
796+  6ADF 57                                   ld      d,a
797+  6AE0 06 02                                ld      b,2
798+  6AE2 29           .loop_00:               add     hl,hl                       ; eliminate leading zeroes
799+  6AE3 38 1B                                jr      c, .loop_10
800+  6AE5 29                                   add     hl,hl
801+  6AE6 38 21                                jr      c, .loop_20
802+  6AE8 29                                   add     hl,hl
803+  6AE9 38 27                                jr      c, .loop_30
804+  6AEB 29                                   add     hl,hl
805+  6AEC 38 2D                                jr      c, .loop_40
806+  6AEE 29                                   add     hl,hl
807+  6AEF 38 33                                jr      c, .loop_50
808+  6AF1 29                                   add     hl,hl
809+  6AF2 38 39                                jr      c, .loop_60
810+  6AF4 29                                   add     hl,hl
811+  6AF5 38 3F                                jr      c, .loop_70
812+  6AF7 29                                   add     hl,hl
813+  6AF8 17                                   rla
814+  6AF9 BB                                   cp      e
815+  6AFA 38 02                                jr      c, .loop_80
816+  6AFC 93                                   sub     e
817+  6AFD 2C                                   inc     l
818+  6AFE 05           .loop_80:               dec     b
819+  6AFF 29           .loop_0:                add     hl,hl
820+  6B00 17           .loop_10:               rla
821+  6B01 38 03                                jr      c, .loop_101
822+  6B03 BB                                   cp      e
823+  6B04 38 02                                jr      c, .loop_1
824+  6B06 93           .loop_101:              sub     e
825+  6B07 2C                                   inc     l
826+  6B08 29           .loop_1:                add     hl,hl
827+  6B09 17           .loop_20:               rla
828+  6B0A 38 03                                jr      c, .loop_201
829+  6B0C BB                                   cp      e
830+  6B0D 38 02                                jr      c, .loop_2
831+  6B0F 93           .loop_201:              sub     e
832+  6B10 2C                                   inc     l
833+  6B11 29           .loop_2:                add     hl,hl
834+  6B12 17           .loop_30:               rla
835+  6B13 38 03                                jr      c, .loop_301
836+  6B15 BB                                   cp      e
837+  6B16 38 02                                jr      c, .loop_3
838+  6B18 93           .loop_301:              sub     e
839+  6B19 2C                                   inc     l
840+  6B1A 29           .loop_3:                add     hl,hl
841+  6B1B 17           .loop_40:               rla
842+  6B1C 38 03                                jr      c, .loop_401
843+  6B1E BB                                   cp      e
844+  6B1F 38 02                                jr      c, .loop_4
845+  6B21 93           .loop_401:              sub     e
846+  6B22 2C                                   inc     l
847+  6B23 29           .loop_4:                add     hl,hl
848+  6B24 17           .loop_50:               rla
849+  6B25 38 03                                jr      c, .loop_501
850+  6B27 BB                                   cp      e
851+  6B28 38 02                                jr      c, .loop_5
852+  6B2A 93           .loop_501:               sub     e
853+  6B2B 2C                                   inc     l
854+  6B2C 29           .loop_5:                 add     hl,hl
855+  6B2D 17           .loop_60:                rla
856+  6B2E 38 03                                jr      c, .loop_601
857+  6B30 BB                                   cp      e
858+  6B31 38 02                                jr      c, .loop_6
859+  6B33 93           .loop_601:               sub     e
860+  6B34 2C                                   inc     l
861+  6B35 29           .loop_6:                 add     hl,hl
862+  6B36 17           .loop_70:                rla
863+  6B37 38 03                                jr      c, .loop_701
864+  6B39 BB                                   cp      e
865+  6B3A 38 02                                jr      c, .loop_7
866+  6B3C 93           .loop_701:               sub     e
867+  6B3D 2C                                   inc     l
868+  6B3E 29           .loop_7:                 add     hl,hl
869+  6B3F 17                                   rla
870+  6B40 38 03                                jr      c, .loop_801
871+  6B42 BB                                   cp      e
872+  6B43 38 02                                jr      c, .loop_8
873+  6B45 93           .loop_801:               sub     e
874+  6B46 2C                                   inc     l
875+  6B47 10 B6        .loop_8:                 djnz    .loop_0
876+  6B49              .exit_loop:              ;AHL = quotient CDE = remainder
877+  6B49 5F                                   ld e,a
878+  6B4A AF                                   xor a
879+  6B4B C3 8A 6A                             jp      HandleSign
880+  6B4E              ;-----------------------------------------------------------------------------------------------------
881+  6B4E              ; AHL = L/C, where A is always 0 return EHL > DBC both >= 00 01 00, internally does L/E
882+  6B4E AF           Perform_8x8:            xor     a
883+  6B4F 57                                   ld      d,a
884+  6B50 67                                   ld      h,a
885+  6B51 59                                   ld      e,c
886+  6B52 CB 25        .loop_00:               sla     l
887+  6B54 38 1B                                jr      c, .loop_10
888+  6B56 CB 25                                sla     l
889+  6B58 38 1F                                jr      c, .loop_20
890+  6B5A CB 25                                sla     l
891+  6B5C 38 23                                jr      c, .loop_30
892+  6B5E CB 25                                sla     l
893+  6B60 38 27                                jr      c, .loop_40
894+  6B62 CB 25                                sla     l
895+  6B64 38 2B                                jr      c, .loop_50
896+  6B66 CB 25                                sla     l
897+  6B68 38 2F                                jr      c, .loop_60
898+  6B6A CB 25                                sla     l
899+  6B6C 38 33                                jr      c, .loop_70
900+  6B6E C3 A7 6B                             jp      .loop_17
901+  6B71 17           .loop_10:               rla
902+  6B72 BB                                   cp      e
903+  6B73 38 02                                jr      c, .loop_11
904+  6B75 93                                   sub     e
905+  6B76 2C                                   inc     l
906+  6B77 CB 25        .loop_11:               sla     l
907+  6B79 17           .loop_20:               rla
908+  6B7A BB                                   cp      e
909+  6B7B 38 02                                jr      c, .loop_12
910+  6B7D 93                                   sub     e
911+  6B7E 2C                                   inc     l
912+  6B7F CB 25        .loop_12:               sla     l
913+  6B81 17           .loop_30:               rla
914+  6B82 BB                                   cp      e
915+  6B83 38 02                                jr      c, .loop_13
916+  6B85 93                                   sub     e
917+  6B86 2C                                   inc     l
918+  6B87 CB 25        .loop_13:               sla     l
919+  6B89 17           .loop_40:               rla
920+  6B8A BB                                   cp      e
921+  6B8B 38 02                                jr      c, .loop_14
922+  6B8D 93                                   sub     e
923+  6B8E 2C                                   inc     l
924+  6B8F CB 25        .loop_14:               sla     l
925+  6B91 17           .loop_50:               rla
926+  6B92 BB                                   cp      e
927+  6B93 38 02                                jr      c, .loop_15
928+  6B95 93                                   sub     e
929+  6B96 2C                                   inc     l
930+  6B97 CB 25        .loop_15:               sla     l
931+  6B99 17           .loop_60:               rla
932+  6B9A BB                                   cp      e
933+  6B9B 38 02                                jr      c, .loop_16
934+  6B9D 93                                   sub     e
935+  6B9E 2C                                   inc     l
936+  6B9F CB 25        .loop_16:               sla     l
937+  6BA1 17           .loop_70:               rla
938+  6BA2 BB                                   cp      e
939+  6BA3 38 02                                jr      c, .loop_17
940+  6BA5 93                                   sub     e
941+  6BA6 2C                                   inc     l
942+  6BA7 CB 25        .loop_17:               sla     l
943+  6BA9 17                                   rla
944+  6BAA BB                                   cp      e
945+  6BAB 38 02                                jr      c, .exit_loop
946+  6BAD 93                                   sub     e
947+  6BAE 2C                                   inc     l
948+  6BAF              .exit_loop:
949+  6BAF                                      ; a = remainder
950+  6BAF                                      ; l = quotient
951+  6BAF 5F                                   ld      e,a
952+  6BB0 AF                                   xor     a
953+  6BB1 C3 8A 6A                             jp      HandleSign
954+  6BB4
955+  6BB4              ;
956+  6BB4              ; AHL = 24bit at IX + 24 bit at IY
957+  6BB4
958+  6BB4              ; AHL = 24bit at IX - 24 bit at IY
959+  6BB4
960+  6BB4              ; BAHL = 24bit at IX * 24 bit at IY  Lead Sign bit
961+  6BB4
962+  6BB4              ; AHL = 24bit at IX / 24 bit at IY  Lead Sign bit
963+  6BB4
# file closed: ../../Maths24/asm_addition24.asm
252   6BB4
253   6BB4
254   6BB4
255   6BB4
256   6BB4                  SAVENEX OPEN "maths24test.nex", EliteNextStartup , TopOfStack
257   6BB4                  SAVENEX CFG  0,0,0,1
258   6BB4                  SAVENEX AUTO
259   6BB4                  SAVENEX CLOSE
260   6BB4
261   6BB4
# file closed: maths24test.asm
