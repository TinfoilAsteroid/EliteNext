# file opened: n24test.asm
   1  0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
   2  0000                              DISPLAY "n24test test"
   3  0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
   4  0000
   5  0000
   6  0000                  DEFINE DEBUGMODE 1
   7  0000                  DEVICE ZXSPECTRUMNEXT
   8  0000                  SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
   9  0000                  ;DEFINE  TESTING_MATHS_DIVIDE 1
  10  0000               CSPECTMAP n24test.map
  11  0000               OPT --zxnext=cspect --syntax=a --reversepop
  12  0000                             DEFINE     MAIN_INTERRUPTENABLE 1
  13  0000              DEBUGSEGSIZE   equ 1
  14  0000              DEBUGLOGSUMMARY equ 1
  15  0000
  16  0000
  17  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  18  0000              ; Game Defines
  19  0000              ScreenLocal      EQU 0
  20  0000              ScreenGalactic   EQU ScreenLocal + 1
  21  0000              ScreenMarket     EQU ScreenGalactic + 1
  22  0000              ScreenMarketDsp  EQU ScreenMarket + 1
  23  0000              ScreenStatus     EQU ScreenMarketDsp + 1
  24  0000              ScreenInvent     EQU ScreenStatus + 1
  25  0000              ScreenPlanet     EQU ScreenInvent + 1
  26  0000              ScreenEquip      EQU ScreenPlanet + 1
  27  0000              ScreenLaunch     EQU ScreenEquip + 1
  28  0000              ScreenFront      EQU ScreenLaunch + 1
  29  0000              ScreenAft        EQU ScreenFront+1
  30  0000              ScreenLeft       EQU ScreenAft+1
  31  0000              ScreenRight      EQU ScreenLeft+1
  32  0000              ScreenDocking    EQU ScreenRight+1
  33  0000              ScreenHyperspace EQU ScreenDocking+1
  34  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  35  0000              ; Colour Defines
  36  0000              SignMask8Bit		equ %01111111
  37  0000              SignMask16Bit		equ %0111111111111111
  38  0000              SignOnly8Bit		equ $80
  39  0000              SignOnly16Bit		equ $8000
  40  0000
  41  0000              Bit7Only            equ %10000000
  42  0000              Bit6Only            equ %01000000
  43  0000              Bit5Only            equ %00100000
  44  0000              Bit4Only            equ %00010000
  45  0000              Bit3Only            equ %00001000
  46  0000              Bit2Only            equ %00000100
  47  0000              Bit1Only            equ %00000010
  48  0000              Bit0Only            equ %00000001
  49  0000              Bit7Clear           equ %01111111
  50  0000              Bit6Clear           equ %10111111
  51  0000              Bit5Clear           equ %11011111
  52  0000              Bit4Clear           equ %11101111
  53  0000              Bit3Clear           equ %11110111
  54  0000              Bit2Clear           equ %11111011
  55  0000              Bit1Clear           equ %11111101
  56  0000              Bit0Clear           equ %11111110
  57  0000              ConstPi				equ $80
  58  0000              ConstNorm           equ 197
  59  0000
  60  0000
  61  0000
  62  0000                                      INCLUDE "../../Macros/jumpMacros.asm"
# file opened: jumpMacros.asm
   1+ 0000              JumpIfHLNegative:       MACRO target
   2+ 0000 ~                                    bit     7,h
   3+ 0000 ~                                    jp      nz,target
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              JumpIfPositive:	        MACRO target
   7+ 0000 ~                                    jp		p, target
   8+ 0000                                      ENDM
   9+ 0000
  10+ 0000              JumpIfNegative:	        MACRO target
  11+ 0000 ~                                    jp		m, target
  12+ 0000                                      ENDM
  13+ 0000
  14+ 0000
  15+ 0000              JumpIfUnderflow:	    MACRO target
  16+ 0000 ~                                    jp		po, target
  17+ 0000                                      ENDM
  18+ 0000
  19+ 0000              JumpIfOverflow:	        MACRO target
  20+ 0000 ~                                    jp		po, target
  21+ 0000                                      ENDM
  22+ 0000
  23+ 0000
  24+ 0000              JumpIfNotZero:	        MACRO target
  25+ 0000 ~                                    jp	nz,target
  26+ 0000                                      ENDM
  27+ 0000
  28+ 0000              JumpIfZero:	            MACRO target
  29+ 0000 ~                                    jp	z,target
  30+ 0000                                      ENDM
  31+ 0000
  32+ 0000              ;.. Bit routines
  33+ 0000              JumpOnLeadSignSet:      MACRO   reg, target
  34+ 0000 ~                                    ld      a,reg
  35+ 0000 ~                                    and     SignOnly8Bit
  36+ 0000 ~                                    jp      nz,target
  37+ 0000                                      ENDM
  38+ 0000
  39+ 0000              JumpOnLeadSignClear:    MACRO   reg, target
  40+ 0000 ~                                    ld      a,reg
  41+ 0000 ~                                    and     SignOnly8Bit
  42+ 0000 ~                                    jp      z,target
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              JumpOnLeadSignSetA:     MACRO   target
  46+ 0000 ~                                    and     SignOnly8Bit
  47+ 0000 ~                                    jp      nz,target
  48+ 0000                                      ENDM
  49+ 0000
  50+ 0000              JumpOnLeadSignClearA:   MACRO   target
  51+ 0000 ~                                    and     SignOnly8Bit
  52+ 0000 ~                                    jp      z,target
  53+ 0000                                      ENDM
  54+ 0000
  55+ 0000              JumpOnMemBitSet:        MACRO mem, bitnbr, target
  56+ 0000 ~                                    ld      a,(mem)
  57+ 0000 ~                                    bit 	bitnbr,a
  58+ 0000 ~                                    jp      nz,target
  59+ 0000                                      ENDM
  60+ 0000
  61+ 0000              JumpOnMemBitClear:      MACRO mem, bitnbr, target
  62+ 0000 ~                                    ld      a,(mem)
  63+ 0000 ~                                    bit 	bitnbr,a
  64+ 0000 ~                                    jp      z,target
  65+ 0000                                      ENDM
  66+ 0000
  67+ 0000
  68+ 0000              JumpOnABitSet:          MACRO   bitnbr, target
  69+ 0000 ~                                    bit 	bitnbr, a
  70+ 0000 ~                                    jp      nz,target
  71+ 0000                                      ENDM
  72+ 0000
  73+ 0000              JumpOnABitClear:        MACRO   bitnbr, target
  74+ 0000 ~                                    bit 	bitnbr, a
  75+ 0000 ~                                    jp      z,target
  76+ 0000                                      ENDM
  77+ 0000
  78+ 0000              JumpOnABit5Set:         MACRO   target
  79+ 0000 ~                                    and     Bit5Only
  80+ 0000 ~                                    jp      nz,target
  81+ 0000                                      ENDM
  82+ 0000
  83+ 0000              JumpOnABit5Clear:       MACRO   target
  84+ 0000 ~                                    and     Bit5Only
  85+ 0000 ~                                    jp      z,target
  86+ 0000                                      ENDM
  87+ 0000
  88+ 0000              JumpOnBitMaskSet:       MACRO   bitmask, target
  89+ 0000 ~                                    and     bitmask
  90+ 0000 ~                                    jp      nz,target
  91+ 0000                                      ENDM
  92+ 0000
  93+ 0000              JumpOnBitMaskClear:     MACRO   bitmask, target
  94+ 0000 ~                                    and     bitmask
  95+ 0000 ~                                    jp      z,target
  96+ 0000                                      ENDM
  97+ 0000
  98+ 0000              JumpOnMemBitMaskSet:    MACRO   mem, bitmask, target
  99+ 0000 ~                                    ld      a,(mem)
 100+ 0000 ~                                    and     bitmask
 101+ 0000 ~                                    jp      nz,target
 102+ 0000                                      ENDM
 103+ 0000
 104+ 0000              JumpOnMemBitMaskClear:  MACRO   mem, bitmask, target
 105+ 0000 ~                                    ld      a,(mem)
 106+ 0000 ~                                    and     bitmask
 107+ 0000 ~                                    jp      z,target
 108+ 0000                                      ENDM
 109+ 0000
 110+ 0000              JumpOnBitSet:           MACRO  reg, bitnbr, target
 111+ 0000 ~                                    bit 	bitnbr,reg
 112+ 0000 ~                                    jp      nz,target
 113+ 0000                                      ENDM
 114+ 0000
 115+ 0000              JumpOnBitClear:         MACRO  reg, bitnbr, target
 116+ 0000 ~                                    bit 	bitnbr,reg
 117+ 0000 ~                                    jp      z,target
 118+ 0000                                      ENDM
 119+ 0000
 120+ 0000              ; Comparison Routines
 121+ 0000              JumpIfAGTEusng:         MACRO
 122+ 0000 ~                                    jp		nc,target
 123+ 0000                                      ENDM
 124+ 0000
 125+ 0000              JumpIfAGTENusng:        MACRO reg,target
 126+ 0000 ~                                    cp     reg
 127+ 0000 ~                                    jp		nc,target
 128+ 0000                                      ENDM
 129+ 0000
 130+ 0000              JumpIfAGTEMemusng:      MACRO mem,target
 131+ 0000 ~                                    ld      hl,mem
 132+ 0000 ~                                    cp      (hl)
 133+ 0000 ~                                    jp		nc,target
 134+ 0000                                      ENDM
 135+ 0000              JumpIfMemGTENusng:      MACRO mem, value, target
 136+ 0000 ~                                    ld     a,(mem)
 137+ 0000 ~                                    cp     value
 138+ 0000 ~                                    jp	  nc,target
 139+ 0000                                      ENDM
 140+ 0000
 141+ 0000              JumpIfMemGTEMemusng:    MACRO mem, address, target
 142+ 0000 ~                                    ld   a,(mem)
 143+ 0000 ~                                    ld   hl,address
 144+ 0000 ~                                    cp   (hl)
 145+ 0000 ~                                    jp	  nc,target
 146+ 0000                                      ENDM
 147+ 0000
 148+ 0000              JumpIfMemEqMemusng:     MACRO mem, address, target
 149+ 0000 ~                                    ld   a,(mem)
 150+ 0000 ~                                    ld   hl,address
 151+ 0000 ~                                    cp   (hl)
 152+ 0000 ~                                    jp	  z,target
 153+ 0000                                      ENDM
 154+ 0000
 155+ 0000              JumpIfMemNeMemusng:     MACRO mem, address, target
 156+ 0000 ~                                    ld   a,(mem)
 157+ 0000 ~                                    ld   hl,address
 158+ 0000 ~                                    cp   (hl)
 159+ 0000 ~                                    jp	  nz,target
 160+ 0000                                      ENDM
 161+ 0000
 162+ 0000              JumpIfMemTrue:          MACRO mem, target
 163+ 0000 ~                                    ld      a,(mem)
 164+ 0000 ~                                    and     a
 165+ 0000 ~                                    jp      z, target
 166+ 0000                                      ENDM
 167+ 0000
 168+ 0000              JumpIfMemFalse:         MACRO mem, target
 169+ 0000 ~                                    ld      a,(mem)
 170+ 0000 ~                                    and     a
 171+ 0000 ~                                    jp      nz, target
 172+ 0000                                      ENDM
 173+ 0000
 174+ 0000              JumpIfATrue:            MACRO target
 175+ 0000 ~                                    and     a
 176+ 0000 ~                                    jp      z, target
 177+ 0000                                      ENDM
 178+ 0000
 179+ 0000              JumpIfAFalse:           MACRO target
 180+ 0000 ~                                    and     a
 181+ 0000 ~                                    jp      nz, target
 182+ 0000                                      ENDM
 183+ 0000
 184+ 0000              JumpIfANotFalse:        MACRO target
 185+ 0000 ~                                    cp      $FF
 186+ 0000 ~                                    jp      nz, target
 187+ 0000                                      ENDM
 188+ 0000
 189+ 0000              ;-- Less than Macros -------------------------------------------
 190+ 0000              JumpIfALTMemHLusng:     MACRO target
 191+ 0000 ~                                    cp    (hl)
 192+ 0000 ~                                    jp	  c,target
 193+ 0000                                      ENDM
 194+ 0000
 195+ 0000              JumpIfRegLTE:           MACRO   reg, value, target
 196+ 0000 ~                                    ld      a,reg
 197+ 0000 ~                                    cp      value
 198+ 0000 ~                                    jp	    z,target
 199+ 0000 ~                                    jp		c, target
 200+ 0000                                      ENDM
 201+ 0000
 202+ 0000              JumpIfALTMemusng:       MACRO mem,target
 203+ 0000 ~                                    ld      hl,mem
 204+ 0000 ~                                    cp      (hl)
 205+ 0000 ~                                    jp		c,target
 206+ 0000                                      ENDM
 207+ 0000
 208+ 0000
 209+ 0000              JumpIfALTusng:          MACRO target
 210+ 0000 ~                                    jp		c,target
 211+ 0000                                      ENDM
 212+ 0000
 213+ 0000              JumpIfALTNusng:         MACRO value, target
 214+ 0000 ~                                    cp      value
 215+ 0000 ~                                    jp		c, target
 216+ 0000                                      ENDM
 217+ 0000
 218+ 0000              JumpIfALTNsigned:       MACRO   value, target
 219+ 0000 ~                                    cp      value
 220+ 0000 ~                                    jp      m,.SignSet
 221+ 0000 ~            .SignClear:             jp      pe,target       ; Sign (0), P/V (1)
 222+ 0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (0)
 223+ 0000 ~            .SignSet:               jp      po,target
 224+ 0000 ~            .CheckComplete:
 225+ 0000                                      ENDM
 226+ 0000
 227+ 0000              JumpIfMemLTNusng:       MACRO mem, value, target
 228+ 0000 ~                                    ld      a,(mem)
 229+ 0000 ~                                    cp      value
 230+ 0000 ~                                    jp	  c,target
 231+ 0000                                      ENDM
 232+ 0000
 233+ 0000              JumpIfMemLTMemusng:     MACRO mem, value, target
 234+ 0000 ~                                    ld    a,(mem)
 235+ 0000 ~                                    ld    hl,value
 236+ 0000 ~                                    cp    (hl)
 237+ 0000 ~                                    jp	  c,target
 238+ 0000                                      ENDM
 239+ 0000              ;-- ------------------------------------------------------------
 240+ 0000              JumpIfAGTENsigned       MACRO   value, target
 241+ 0000 ~                                    cp      value
 242+ 0000 ~                                    jp      m,.SignSet
 243+ 0000 ~            .SignClear:             jp      po,target       ; Sign (0), P/V (0)
 244+ 0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (1)
 245+ 0000 ~            .SignSet:               jp      pe,target
 246+ 0000 ~            .CheckComplete:
 247+ 0000                                      ENDM
 248+ 0000
 249+ 0000              JumpIfMemEqNusng:       MACRO mem,value,target
 250+ 0000 ~                                    ld  a,(mem)
 251+ 0000 ~                                    cp  value
 252+ 0000 ~                                    jp  z,target
 253+ 0000                                      ENDM
 254+ 0000
 255+ 0000              JumpIfMemNeNusng:       MACRO mem,value,target
 256+ 0000 ~                                    ld  a,(mem)
 257+ 0000 ~                                    cp  value
 258+ 0000 ~                                    jp  nz,target
 259+ 0000                                      ENDM
 260+ 0000
 261+ 0000              JumpIfMemZero:          MACRO mem,target
 262+ 0000 ~                                    ld  a,(mem)
 263+ 0000 ~                                    and a
 264+ 0000 ~                                    jp  z,target
 265+ 0000                                      ENDM
 266+ 0000
 267+ 0000              JumpIfMemNotZero:       MACRO mem,target
 268+ 0000 ~                                    ld  a,(mem)
 269+ 0000 ~                                    and a
 270+ 0000 ~                                    jp  nz,target
 271+ 0000                                      ENDM
 272+ 0000
 273+ 0000              JumpIfANENusng:         MACRO value, target
 274+ 0000 ~                                    cp     value
 275+ 0000 ~                                    jp      nz,target
 276+ 0000                                      ENDM
 277+ 0000
 278+ 0000              JumpIfANEquNusng:       MACRO value, target
 279+ 0000 ~                                    cp     value
 280+ 0000 ~                                    jp     z,target
 281+ 0000                                      ENDM
 282+ 0000
 283+ 0000              JumpIfANEMemusng:       MACRO  value, target
 284+ 0000 ~                                    ld    hl,value
 285+ 0000 ~                                    cp    (hl)
 286+ 0000 ~                                    jp      nz,target
 287+ 0000                                      ENDM
 288+ 0000
 289+ 0000              JumpIfAEqNusng:         MACRO value, target
 290+ 0000 ~                                    cp     value
 291+ 0000 ~                                    jp      z,target
 292+ 0000                                      ENDM
 293+ 0000
 294+ 0000              JumpIfAIsZero:	        MACRO target
 295+ 0000 ~                                    and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 296+ 0000 ~                                    jp	    z, target
 297+ 0000                                      ENDM
 298+ 0000
 299+ 0000              JumpIfRegIsNotZero:     MACRO   reg, target
 300+ 0000 ~                                    ld      a,reg
 301+ 0000 ~                                    and     a
 302+ 0000 ~                                    jp	    nz,target
 303+ 0000                                      ENDM
 304+ 0000
 305+ 0000
 306+ 0000              JumpIfAIsNotZero:       MACRO target
 307+ 0000 ~                                    and     a
 308+ 0000 ~                                    jp	    nz,target
 309+ 0000                                      ENDM
 310+ 0000
 311+ 0000              JumpIfMemIsNotZero:     MACRO value, target
 312+ 0000 ~                                    ld      a,(value)
 313+ 0000 ~                                    and     a
 314+ 0000 ~                                    jp	    nz,target
 315+ 0000                                      ENDM
 316+ 0000              IfResultZeroGoto:	    MACRO target
 317+ 0000 ~                                    jp	z,target
 318+ 0000                                      ENDM
 319+ 0000
 320+ 0000              IfResultNotZeroGoto:    MACRO target
 321+ 0000 ~                                    jp	nz,target
 322+ 0000                                      ENDM
 323+ 0000
# file closed: jumpMacros.asm
  63  0000                                      INCLUDE "../../Macros/MathsMacros.asm"
# file opened: MathsMacros.asm
   1+ 0000              ZeroA:		            MACRO
   2+ 0000 ~                                    xor a
   3+ 0000                                      ENDM
   4+ 0000              ; sets z flag is HL less than 255 else sets it to nz (note opposite of GT127)
   5+ 0000              IsHLGT255:              MACRO
   6+ 0000 ~                                    bit     7,h
   7+ 0000 ~                                    ret     z
   8+ 0000 ~                                    ld      a,h
   9+ 0000 ~                                    and     a
  10+ 0000                                      ENDM
  11+ 0000
  12+ 0000              ; Sets z flat if HL = 255 else sets it to nz
  13+ 0000              IsHLEqu255:             MACRO
  14+ 0000 ~                                    ld      a,h
  15+ 0000 ~                                    and     a               ; if its non zero then it can't be 255
  16+ 0000 ~                                    ret     nz
  17+ 0000 ~                                    ld      a,l
  18+ 0000 ~                                    inc     a               ; if it was 255 the inc will set it to zero
  19+ 0000                                      ENDM
  20+ 0000
  21+ 0000              ; Sets Z flag if GT 127 else nz
  22+ 0000              IsHLGT127:              MACRO
  23+ 0000 ~                                    bit     7,h             ; -ve?
  24+ 0000 ~                                    jr      nz,.DoneCheck
  25+ 0000 ~                                    ld      a,h             ; +ve > 256?
  26+ 0000 ~                                    and     a
  27+ 0000 ~                                    jr      nz,.DoneCheck
  28+ 0000 ~                                    ld      a,l
  29+ 0000 ~                                    and     $80             ; this will set z to false if bit 7 set and clear lower bits
  30+ 0000 ~                                    cp      $80             ; this will set z to true if bit 7 set
  31+ 0000 ~            .DoneCheck:
  32+ 0000                                      ENDM
  33+ 0000
  34+ 0000              ReturnIfHLGT127:        MACRO
  35+ 0000 ~                                    bit     7,h             ; -ve?
  36+ 0000 ~                                    jr      nz,.DoneCheck   ; forces check complete
  37+ 0000 ~                                    ld      a,h             ; +ve > 256?
  38+ 0000 ~                                    and     a               ;
  39+ 0000 ~                                    ret     nz              ; forces a return
  40+ 0000 ~                                    bit     7,l             ; bit 7 of lower set?
  41+ 0000 ~                                    ret     nz              ; forces a return
  42+ 0000 ~            .DoneCheck:
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              IsDEGT127:              MACRO
  46+ 0000 ~                                    bit     7,d
  47+ 0000 ~                                    jr      nz,.DoneCheck
  48+ 0000 ~                                    ld      a,d
  49+ 0000 ~                                    jr      nz,.DoneCheck
  50+ 0000 ~                                    ld      a,e
  51+ 0000 ~                                    and     $80
  52+ 0000 ~            .DoneCheck:
  53+ 0000                                      ENDM
  54+ 0000
  55+ 0000              ABSa2c:                 MACRO
  56+ 0000 ~                                    bit     7,a
  57+ 0000 ~                                    jp      z,.DoneABSa
  58+ 0000 ~                                    neg
  59+ 0000 ~            .DoneABSa:
  60+ 0000                                      ENDM
  61+ 0000
  62+ 0000              DEEquSquareA:           MACRO
  63+ 0000 ~                                    ld  d,a
  64+ 0000 ~                                    ld  e,a
  65+ 0000 ~                                    mul de
  66+ 0000                                      ENDM
  67+ 0000
  68+ 0000              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
  69+ 0000 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
  70+ 0000 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
  71+ 0000 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
  72+ 0000 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
  73+ 0000 ~                                    xor $80                             ;
  74+ 0000 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
  75+ 0000 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
  76+ 0000 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
  77+ 0000 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
  78+ 0000 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
  79+ 0000 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
  80+ 0000                                      ENDM
  81+ 0000
  82+ 0000              SignedHLTo2C:           MACRO
  83+ 0000 ~                                    bit     7,h
  84+ 0000 ~                                    jr      z,.Done2c
  85+ 0000 ~                                    ld      a,h
  86+ 0000 ~                                    and     SignMask8Bit
  87+ 0000 ~                                    ld      h,a
  88+ 0000 ~                                    NegHL
  89+ 0000 ~            .Done2c:
  90+ 0000                                      ENDM
  91+ 0000
  92+ 0000              MemSignedTo2C:          MACRO   memfrom
  93+ 0000 ~                                    ld      hl,(memfrom)
  94+ 0000 ~                                    bit     7,h
  95+ 0000 ~                                    jr      z,.Done2c
  96+ 0000 ~                                    ld      a,h
  97+ 0000 ~                                    and     SignMask8Bit
  98+ 0000 ~                                    ld      h,a
  99+ 0000 ~            .Done2c:                ld      (memfrom),hl
 100+ 0000                                      ENDM
 101+ 0000
 102+ 0000
 103+ 0000                  ;returns result in H
 104+ 0000              EDiv10Inline:           MACRO
 105+ 0000 ~                                    ld      d,0
 106+ 0000 ~                                    ld      hl,de
 107+ 0000 ~                                    add     hl,hl
 108+ 0000 ~                                    add     hl,de
 109+ 0000 ~                                    add     hl,hl
 110+ 0000 ~                                    add     hl,hl
 111+ 0000 ~                                    add     hl,de
 112+ 0000 ~                                    add     hl,hl
 113+ 0000                                      ENDM
 114+ 0000
 115+ 0000              cpHLDE:                 MACRO
 116+ 0000 ~                                    push    hl
 117+ 0000 ~                                    and     a
 118+ 0000 ~                                    sbc     hl,de
 119+ 0000 ~                                    pop     hl
 120+ 0000                                      ENDM
 121+ 0000
 122+ 0000              cpABSDEHL:              MACRO
 123+ 0000 ~                                    push     hl,,de
 124+ 0000 ~                                    ld      a,h
 125+ 0000 ~                                    and     $7F
 126+ 0000 ~                                    ld      h,a
 127+ 0000 ~                                    ld      a,d
 128+ 0000 ~                                    and     $7F
 129+ 0000 ~                                    ld      d,a
 130+ 0000 ~                                    ex      de,hl
 131+ 0000 ~                                    sbc     hl,de
 132+ 0000 ~                                    pop     hl,,de
 133+ 0000                                      ENDM
 134+ 0000
 135+ 0000              ; Simple are they both the same setting z if they are
 136+ 0000              ; tehcicall this works but it measn the final ret z is alwys done
 137+ 0000              ; so jp needs to be to a target
 138+ 0000              cpHLEquDE:              MACRO   passedCheck
 139+ 0000 ~                                    ld      a,h
 140+ 0000 ~                                    cp      d
 141+ 0000 ~                                    jp      nz, passedCheck
 142+ 0000 ~                                    ld      a,l
 143+ 0000 ~                                    cp      e
 144+ 0000 ~            .NoTheSame:
 145+ 0000                                      ENDM
 146+ 0000
 147+ 0000              cpHLEquBC:              MACRO   passedCheck
 148+ 0000 ~                                    ld      a,h
 149+ 0000 ~                                    cp      b
 150+ 0000 ~                                    jp      nz, passedCheck
 151+ 0000 ~                                    ld      a,l
 152+ 0000 ~                                    cp      c
 153+ 0000 ~            .NoTheSame:
 154+ 0000                                      ENDM
 155+ 0000
 156+ 0000              cpDEEquBC:              MACRO   passedCheck
 157+ 0000 ~                                    ld      a,d
 158+ 0000 ~                                    cp      b
 159+ 0000 ~                                    jp      nz, passedCheck
 160+ 0000 ~                                    ld      a,e
 161+ 0000 ~                                    cp      c
 162+ 0000 ~            .NoTheSame:
 163+ 0000                                      ENDM
 164+ 0000              ; Simple version just sets carry if HL < DE reset, does an initial compare for z
 165+ 0000              cpHLDELeadSign:         MACRO
 166+ 0000 ~                                    ld      a,h
 167+ 0000 ~                                    cp      d
 168+ 0000 ~                                    jr      nz,.FullCompare
 169+ 0000 ~                                    ld      a,l
 170+ 0000 ~                                    cp      e
 171+ 0000 ~                                    ret     z
 172+ 0000 ~            .FullCompare:           ld      a,h
 173+ 0000 ~                                    xor     d
 174+ 0000 ~                                    and     $80
 175+ 0000 ~                                    jr      nz,.OppositeSigns   ; If opposite signs is a simple sign test
 176+ 0000 ~                                    ld      a,h                 ; same signs so a little simpler
 177+ 0000 ~                                    and     $80
 178+ 0000 ~                                    jp      z,cpHLDE            ; if h is positive then both are positive by here so just cpHLDE
 179+ 0000 ~                                    jp      cpABSDEHL           ; else we have to do ABScpDEHL
 180+ 0000 ~            .OppositeSigns:         ld      a,h
 181+ 0000 ~                                    and     $80
 182+ 0000 ~                                    and     $80
 183+ 0000 ~                                    jp      z,.HLGTDE
 184+ 0000 ~            .HLLTDE:                SetCarryFlag
 185+ 0000 ~                                    ret
 186+ 0000 ~            .HLGTDE:                ClearCarryFlag
 187+ 0000 ~                                    ret
 188+ 0000                                      ENDM
 189+ 0000
 190+ 0000              ;Unsigned
 191+ 0000              ;If HL == DE, then Z flag is set.
 192+ 0000              ;If HL != DE, then Z flag is reset.
 193+ 0000              ;If HL <  DE, then C flag is set.
 194+ 0000              ;If HL >= DE, then C flag is reset.
 195+ 0000              ;
 196+ 0000              ;Signed
 197+ 0000              ;If HL == DE, then Z flag is set.
 198+ 0000              ;If HL != DE, then Z flag is reset.
 199+ 0000              ;If HL <  DE, then S and P/V are different.
 200+ 0000              ;If HL >= DE, then S and P/V are the same.
 201+ 0000
 202+ 0000
 203+ 0000              N0equN1byN2div256:      MACRO param1,param2,param3
 204+ 0000 ~                                    ld      a,param3                        ;
 205+ 0000 ~                                    ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 206+ 0000 ~                                    ld      a,param2                        ; A = XX16 element
 207+ 0000 ~                                    ld      d,a
 208+ 0000 ~                                    mul
 209+ 0000 ~                                    ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 210+ 0000 ~                                    ld      (param1),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 211+ 0000                                      ENDM
 212+ 0000
 213+ 0000              AequN1xorN2:            MACRO  param1,param2
 214+ 0000 ~                                    ld      a,(param1)
 215+ 0000 ~                                    xor     param2
 216+ 0000                                      ENDM
 217+ 0000
 218+ 0000              SpeedMulAxis:           MACRO   speedreg, axis
 219+ 0000 ~                                    ld      e,speedreg
 220+ 0000 ~                                    ld      hl,(axis)
 221+ 0000 ~                                    ld      a,h
 222+ 0000 ~                                    ClearSignBitA
 223+ 0000 ~                                    ld      d,a
 224+ 0000 ~                                    mul     de
 225+ 0000 ~                                    ld      a,h
 226+ 0000 ~                                    SignBitOnlyA
 227+ 0000 ~                                    ld      b,a;ld      c,a
 228+ 0000 ~                                    ld      h,d;ld      e,d
 229+ 0000 ~                                    ld      c,0;ld      d,0
 230+ 0000                                      ENDM
 231+ 0000
 232+ 0000              ; Adds speed (8 bit) to vertex (24 bit signed)
 233+ 0000              AddSpeedToVert:         MACRO   vertex
 234+ 0000 ~                                    ld      de,(vertex+1)
 235+ 0000 ~                                    ld      a,(vertex)
 236+ 0000 ~                                    ld      l,a
 237+ 0000 ~                                    call    AddBCHtoDELsigned               ; DEL = DEL + BCH
 238+ 0000 ~                                    ld      a,l
 239+ 0000 ~                                    ld      (vertex),a
 240+ 0000 ~                                    ld      (vertex+1),de
 241+ 0000                                      ENDM
# file closed: MathsMacros.asm
  64  0000                                      INCLUDE "../../Macros/ShiftMacros.asm"
# file opened: ShiftMacros.asm
   1+ 0000              ShiftIYRight1: MACRO
   2+ 0000 ~                           ld   a,iyh
   3+ 0000 ~                           srl  a
   4+ 0000 ~                           ld   iyh,a
   5+ 0000 ~                           ld   a,iyl
   6+ 0000 ~                           rra
   7+ 0000 ~                           ld   iyl,a
   8+ 0000                             ENDM
   9+ 0000
  10+ 0000              ShiftIXRight1: MACRO
  11+ 0000 ~                           ld   a,ixh
  12+ 0000 ~                           srl  a
  13+ 0000 ~                           ld   ixh,a
  14+ 0000 ~                           ld   a,ixl
  15+ 0000 ~                           rra
  16+ 0000 ~                           ld   ixl,a
  17+ 0000                             ENDM
  18+ 0000
  19+ 0000              ShiftIXhHLRight1: MACRO
  20+ 0000 ~                           ld  a,ixh
  21+ 0000 ~                           srl a
  22+ 0000 ~                           ld  ixh,a
  23+ 0000 ~                           rr  h
  24+ 0000 ~                           rr  l
  25+ 0000                             ENDM
  26+ 0000
  27+ 0000              ShiftIYhDERight1: MACRO
  28+ 0000 ~                           ld  a,iyh
  29+ 0000 ~                           srl a
  30+ 0000 ~                           ld  iyh,a
  31+ 0000 ~                           rr  d
  32+ 0000 ~                           rr  e
  33+ 0000                             ENDM
  34+ 0000
  35+ 0000              ShiftIYlBCRight1: MACRO
  36+ 0000 ~                           ld  a,iyl
  37+ 0000 ~                           srl a
  38+ 0000 ~                           ld  iyl,a
  39+ 0000 ~                           rr  b
  40+ 0000 ~                           rr  c
  41+ 0000                             ENDM
  42+ 0000
  43+ 0000              ShiftIXlBCRight1: MACRO
  44+ 0000 ~                           ld  a,ixl
  45+ 0000 ~                           srl a
  46+ 0000 ~                           ld  ixl,a
  47+ 0000 ~                           rr  b
  48+ 0000 ~                           rr  c
  49+ 0000                             ENDM
  50+ 0000
  51+ 0000              ShiftHLRight1: MACRO
  52+ 0000 ~                           srl h
  53+ 0000 ~                           rr  l
  54+ 0000                             ENDM
  55+ 0000
  56+ 0000              ShiftBHLRight1:MACRO
  57+ 0000 ~                           srl b
  58+ 0000 ~                           rr h
  59+ 0000 ~                           rr  l
  60+ 0000                             ENDM
  61+ 0000
  62+ 0000              ShiftCDERight1:MACRO
  63+ 0000 ~                           srl c
  64+ 0000 ~                           rr  d
  65+ 0000 ~                           rr  e
  66+ 0000                             ENDM
  67+ 0000
  68+ 0000
  69+ 0000              SRAHLRight1: MACRO
  70+ 0000 ~                           sra h
  71+ 0000 ~                           rr  l
  72+ 0000                             ENDM
  73+ 0000
  74+ 0000              ShiftDERight1: MACRO
  75+ 0000 ~                           srl d
  76+ 0000 ~                           rr  e
  77+ 0000                             ENDM
  78+ 0000
  79+ 0000              ShiftBCRight1: MACRO
  80+ 0000 ~                           srl b
  81+ 0000 ~                           rr  c
  82+ 0000                             ENDM
  83+ 0000
  84+ 0000
  85+ 0000              ShiftHLDiv8:   MACRO
  86+ 0000 ~                           srl h
  87+ 0000 ~                           rr  l
  88+ 0000 ~                           srl h
  89+ 0000 ~                           rr  l
  90+ 0000 ~                           srl h
  91+ 0000 ~                           rr  l
  92+ 0000                             ENDM
  93+ 0000
  94+ 0000              ShiftBHLLeft1:  MACRO
  95+ 0000 ~                            sla l
  96+ 0000 ~                            rl  h
  97+ 0000 ~                            rl  b
  98+ 0000                              ENDM
  99+ 0000
 100+ 0000              ShiftCDELeft1:  MACRO
 101+ 0000 ~                            sla e
 102+ 0000 ~                            rl  d
 103+ 0000 ~                            rl  c
 104+ 0000                              ENDM
 105+ 0000
 106+ 0000              ShiftHLLeft1:  MACRO    ; 16 T states
 107+ 0000 ~                           sla l
 108+ 0000 ~                           rl  h
 109+ 0000                             ENDM
 110+ 0000
 111+ 0000              ShiftDELeft1:  MACRO    ; 16 T states
 112+ 0000 ~                           sla e
 113+ 0000 ~                           rl  d
 114+ 0000                             ENDM
 115+ 0000
 116+ 0000              BarrelHLLeft3: MACRO
 117+ 0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
 118+ 0000 ~                           push     bc      ; 10
 119+ 0000 ~                           ld       b,3     ; 7
 120+ 0000 ~                           bsrl     de,b    ; 8
 121+ 0000 ~                           pop      bc      ; 10
 122+ 0000 ~                           ex       de,hl   ; 4
 123+ 0000                             ENDM
 124+ 0000
 125+ 0000              BarrelHLRight3: MACRO
 126+ 0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
 127+ 0000 ~                           push     bc      ; 10
 128+ 0000 ~                           ld       b,3     ; 7
 129+ 0000 ~                           bsrl     de,b    ; 8
 130+ 0000 ~                           pop      bc      ; 10
 131+ 0000 ~                           ex       de,hl   ; 4
 132+ 0000                             ENDM
 133+ 0000
 134+ 0000              RollBCLeft1:   MACRO    ; 16 T states
 135+ 0000 ~                           rl  c
 136+ 0000 ~                           rl  b
 137+ 0000                             ENDM
 138+ 0000
 139+ 0000              RollDELeft1:   MACRO    ; 16 T states
 140+ 0000 ~                           rl  e
 141+ 0000 ~                           rl  d
 142+ 0000                             ENDM
 143+ 0000
 144+ 0000              ShiftBCLeft1:  MACRO    ; 16 T states
 145+ 0000 ~                           sla c
 146+ 0000 ~                           rl  b
 147+ 0000                             ENDM
 148+ 0000
 149+ 0000              ShiftLeftMem:       MACRO   reg
 150+ 0000 ~                                ld      hl,reg
 151+ 0000 ~                                sla     (hl)
 152+ 0000                                  ENDM
 153+ 0000
 154+ 0000
 155+ 0000
 156+ 0000              ShiftMem16Right1:   MACRO memaddr
 157+ 0000 ~                                ld    hl,(memaddr)
 158+ 0000 ~                                srl   h
 159+ 0000 ~                                rr    l
 160+ 0000 ~                                ld    (memaddr),hl
 161+ 0000                                  ENDM
 162+ 0000
 163+ 0000              ShiftMem8Right1:    MACRO memaddr
 164+ 0000 ~                                ld      a,(memaddr)
 165+ 0000 ~                                srl     a
 166+ 0000 ~                                ld      (memaddr),a
 167+ 0000                                  ENDM
 168+ 0000
 169+ 0000
 170+ 0000              ShiftMem8Left1A:    MACRO memaddr
 171+ 0000 ~                                ld      a,(memaddr)
 172+ 0000 ~                                sla     a
 173+ 0000 ~                                ld      (memaddr),a
 174+ 0000                                  ENDM
 175+ 0000
# file closed: ShiftMacros.asm
  65  0000                                      INCLUDE "../../Macros/NegateMacros.asm"
# file opened: NegateMacros.asm
   1+ 0000
   2+ 0000              macronegate16hl:	MACRO
   3+ 0000 ~            					xor 	a
   4+ 0000 ~            					sub 	l
   5+ 0000 ~            					ld 		l,a
   6+ 0000 ~            					sbc 	a,a
   7+ 0000 ~            					sub 	h
   8+ 0000 ~            					ld 		h,a
   9+ 0000              					ENDM
  10+ 0000
  11+ 0000
  12+ 0000              macroAbsHL:         MACRO
  13+ 0000 ~                                bit     7,h
  14+ 0000 ~                                jp      z,.alreadyABS
  15+ 0000 ~            					xor 	a
  16+ 0000 ~            					sub 	l
  17+ 0000 ~            					ld 		l,a
  18+ 0000 ~            					sbc 	a,a
  19+ 0000 ~            					sub 	h
  20+ 0000 ~            					ld 		h,a
  21+ 0000 ~            .alreadyABS:
  22+ 0000                                  ENDM
  23+ 0000
  24+ 0000              macronegate16de:	MACRO
  25+ 0000 ~            					xor 	a
  26+ 0000 ~                                sub 	e
  27+ 0000 ~                                ld 		e,a
  28+ 0000 ~                                sbc 	a,a
  29+ 0000 ~                                sub 	d
  30+ 0000 ~                                ld 		d,a
  31+ 0000              					ENDM
  32+ 0000
  33+ 0000              macronegate16bc:	MACRO
  34+ 0000 ~            					xor 	a
  35+ 0000 ~                                sub 	c
  36+ 0000 ~                                ld 		c,a
  37+ 0000 ~                                sbc 	a,a
  38+ 0000 ~                                sub 	b
  39+ 0000 ~                                ld 		b,a
  40+ 0000              					ENDM
  41+ 0000
  42+ 0000              macronegate16ix:	MACRO
  43+ 0000 ~            					xor 	a
  44+ 0000 ~                                sub 	ixl
  45+ 0000 ~                                ld 		ixl,a
  46+ 0000 ~                                sbc 	a,a
  47+ 0000 ~                                sub 	ixh
  48+ 0000 ~                                ld 		ixh,a
  49+ 0000              					ENDM
  50+ 0000
  51+ 0000
  52+ 0000              NegIY:			    MACRO
  53+ 0000 ~                                xor a
  54+ 0000 ~                                sub iyl
  55+ 0000 ~                                ld iyl,a
  56+ 0000 ~                                sbc a,a
  57+ 0000 ~                                sub iyh
  58+ 0000 ~                                ld iyh,a
  59+ 0000                                  ENDM
  60+ 0000
  61+ 0000              NegHL:			    MACRO
  62+ 0000 ~                                xor     a
  63+ 0000 ~                                sub     l
  64+ 0000 ~                                ld      l,a
  65+ 0000 ~                                sbc     a,a
  66+ 0000 ~                                sub     h
  67+ 0000 ~                                ld      h,a
  68+ 0000                                  ENDM
  69+ 0000
  70+ 0000              NegBHL:             MACRO
  71+ 0000 ~                                ld      a,l
  72+ 0000 ~                                cpl
  73+ 0000 ~                                add     a,1
  74+ 0000 ~                                ld      l,a
  75+ 0000 ~                                ld      a,h
  76+ 0000 ~                                cpl
  77+ 0000 ~                                adc     a,0
  78+ 0000 ~                                ld      h,a
  79+ 0000 ~                                ld      a,b
  80+ 0000 ~                                cpl
  81+ 0000 ~                                adc     a,0
  82+ 0000 ~                                ld      b,a
  83+ 0000                                  ENDM
  84+ 0000
  85+ 0000              NegCDE:             MACRO
  86+ 0000 ~                                ld      a,e
  87+ 0000 ~                                cpl
  88+ 0000 ~                                add     a,1
  89+ 0000 ~                                ld      e,a
  90+ 0000 ~                                ld      a,d
  91+ 0000 ~                                cpl
  92+ 0000 ~                                adc     a,0
  93+ 0000 ~                                ld      d,a
  94+ 0000 ~                                ld      a,c
  95+ 0000 ~                                cpl
  96+ 0000 ~                                adc     a,0
  97+ 0000 ~                                ld      c,a
  98+ 0000                                  ENDM
  99+ 0000
 100+ 0000              NegAHL:			    MACRO
 101+ 0000 ~                                ld      b,a
 102+ 0000 ~                                ld      a,l
 103+ 0000 ~                                cpl
 104+ 0000 ~                                add     a,1
 105+ 0000 ~                                ld      l,a
 106+ 0000 ~                                ld      a,h
 107+ 0000 ~                                cpl
 108+ 0000 ~                                adc     a,0
 109+ 0000 ~                                ld      h,a
 110+ 0000 ~                                ld      a,b
 111+ 0000 ~                                cpl
 112+ 0000 ~                                adc     a,0
 113+ 0000                                  ENDM
 114+ 0000
 115+ 0000
 116+ 0000              NegDE:			    MACRO
 117+ 0000 ~                                xor     a
 118+ 0000 ~                                sub     e
 119+ 0000 ~                                ld      e,a
 120+ 0000 ~                                sbc     a,a
 121+ 0000 ~                                sub     d
 122+ 0000 ~                                ld      d,a
 123+ 0000                                  ENDM
 124+ 0000
 125+ 0000              NegBC:			    MACRO
 126+ 0000 ~                                xor     a
 127+ 0000 ~                                sub     c
 128+ 0000 ~                                ld      c,a
 129+ 0000 ~                                sbc     a,a
 130+ 0000 ~                                sub     b
 131+ 0000 ~                                ld      b,a
 132+ 0000                                  ENDM
 133+ 0000
 134+ 0000              NegH                MACRO
 135+ 0000 ~                                ld      a,h
 136+ 0000 ~                                neg
 137+ 0000 ~                                ld      h,a
 138+ 0000                                  ENDM
 139+ 0000
 140+ 0000              NegD                MACRO
 141+ 0000 ~                                ld      a,d
 142+ 0000 ~                                neg
 143+ 0000 ~                                ld      d,a
 144+ 0000                                  ENDM
 145+ 0000
 146+ 0000              NegB                MACRO
 147+ 0000 ~                                ld      a,b
 148+ 0000 ~                                neg
 149+ 0000 ~                                ld      b,a
 150+ 0000                                  ENDM
 151+ 0000
# file closed: NegateMacros.asm
  66  0000                                      INCLUDE "../../Macros/carryFlagMacros.asm"
# file opened: carryFlagMacros.asm
   1+ 0000
   2+ 0000              SetCarryFlag:           MACRO
   3+ 0000 ~                                    scf
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              ClearCarryFlag:	        MACRO
   7+ 0000 ~                                    or a
   8+ 0000                                      ENDM
   9+ 0000
  10+ 0000              FlipCarryFlag:          MACRO
  11+ 0000 ~                                    ccf
  12+ 0000                                      ENDM
  13+ 0000
# file closed: carryFlagMacros.asm
  67  0000                                      INCLUDE "../../Macros/UniverseObjectPosMacros.asm"
# file opened: UniverseObjectPosMacros.asm
   1+ 0000              ; Universe position data manipulation
   2+ 0000              ;------------------------------------------------------------------------------
   3+ 0000              ; Sets IYH to sign bits, bit 7 = x, bit 6 = y bit 5 = z
   4+ 0000              SetIYHToSignBits:       MACRO
   5+ 0000 ~                                    ld      a,(ix+8)                ; get Z sign
   6+ 0000 ~                                    and     $80                     ; and shift it via A into IYH bit 7
   7+ 0000 ~                                    sra     a                       ;
   8+ 0000 ~                                    ld      iyh,a                   ;
   9+ 0000 ~                                    ld      a,(ix+5)                ; get Y sign
  10+ 0000 ~                                    and     $80                     ; and shift it via A into IYH bit 7
  11+ 0000 ~                                    or      iyh                     ; which moves Z into IYH bit 6
  12+ 0000 ~                                    sra     a                       ;
  13+ 0000 ~                                    ld      iyh,a                   ;
  14+ 0000 ~                                    ld      a,(ix+2)                ; get X sign
  15+ 0000 ~                                    and     $80                     ; and shift it via A into IYH bit 7
  16+ 0000 ~                                    or      iyh                     ; which moves Y into IYH bit 6 and Z into IYH bit 5
  17+ 0000 ~                                    ld      iyh,a                   ;
  18+ 0000                                      ENDM
  19+ 0000              ;------------------------------------------------------------------------------
  20+ 0000              ; gets high bytes of vector at IX
  21+ 0000              ; sets h = abs x sign, l = abs y sgn d and a to abs z|y|x sgn
  22+ 0000              SetAHLDToABSXYZSgn      MACRO
  23+ 0000 ~                                    ld      a,(ix+2)
  24+ 0000 ~                                    and     $7F
  25+ 0000 ~                                    ld      h,a
  26+ 0000 ~                                    ld      a,(ix+5)
  27+ 0000 ~                                    and     $7F
  28+ 0000 ~                                    ld      l,a
  29+ 0000 ~                                    ld      a,(ix+8)
  30+ 0000 ~                                    and     $7F
  31+ 0000 ~                                    ld      d,a
  32+ 0000 ~                                    or      h
  33+ 0000 ~                                    or      l
  34+ 0000                                      ENDM
  35+ 0000              ;------------------------------------------------------------------------------
  36+ 0000              SetAHLDToABSXYZHi       MACRO
  37+ 0000 ~                                    ld      a,(ix+1)
  38+ 0000 ~                                    ld      h,a
  39+ 0000 ~                                    ld      a,(ix+4)
  40+ 0000 ~                                    ld      l,a
  41+ 0000 ~                                    ld      a,(ix+7)
  42+ 0000 ~                                    ld      d,a
  43+ 0000 ~                                    or      h
  44+ 0000 ~                                    or      l
  45+ 0000                                      ENDM
  46+ 0000              ;------------------------------------------------------------------------------
  47+ 0000              SetAHLDToABSXYZLo       MACRO
  48+ 0000 ~                                    ld      a,(ix+0)
  49+ 0000 ~                                    ld      h,a
  50+ 0000 ~                                    ld      a,(ix+3)
  51+ 0000 ~                                    ld      l,a
  52+ 0000 ~                                    ld      a,(ix+6)
  53+ 0000 ~                                    ld      d,a
  54+ 0000 ~                                    or      h
  55+ 0000 ~                                    or      l
  56+ 0000                                      ENDM
  57+ 0000              ;------------------------------------------------------------------------------
  58+ 0000              SetBHLtoX:              MACRO
  59+ 0000 ~                                    ld      b,(ix+2)
  60+ 0000 ~                                    ld      hl,(ix)
  61+ 0000                                      ENDM
  62+ 0000              ;------------------------------------------------------------------------------
  63+ 0000              SetCDEtoX:              MACRO
  64+ 0000 ~                                    ld      c,(ix+2)
  65+ 0000 ~                                    ld      de,(ix)
  66+ 0000                                      ENDM
  67+ 0000              ;------------------------------------------------------------------------------
  68+ 0000              SaveDEHToX:             MACRO
  69+ 0000 ~                                    ld      (ix+2),d                ; save DE.H into Zd
  70+ 0000 ~                                    ld      (ix+1),e                ; .
  71+ 0000 ~                                    ld      (ix),h                  ; .
  72+ 0000                                      ENDM
  73+ 0000              ;------------------------------------------------------------------------------
  74+ 0000              SaveAHLToX:             MACRO
  75+ 0000 ~                                    ld      (ix+2),a                ; save DE.H into Zd
  76+ 0000 ~                                    ld      (ix+1),h                ; .
  77+ 0000 ~                                    ld      (ix),l                  ; .
  78+ 0000                                      ENDM
  79+ 0000              ;------------------------------------------------------------------------------
  80+ 0000              SetCDEtoY:              MACRO
  81+ 0000 ~                                    ld      c,(ix+5)
  82+ 0000 ~                                    ld      de,(ix+3)
  83+ 0000                                      ENDM
  84+ 0000              ;------------------------------------------------------------------------------
  85+ 0000              SetBHLtoY:              MACRO
  86+ 0000 ~                                    ld      b,(ix+5)
  87+ 0000 ~                                    ld      hl,(ix+3)
  88+ 0000                                      ENDM
  89+ 0000              ;------------------------------------------------------------------------------
  90+ 0000              SaveDEHToY:             MACRO
  91+ 0000 ~                                    ld      (ix+5),d                ; save DE.H into Zd
  92+ 0000 ~                                    ld      (ix+4),e                ; .
  93+ 0000 ~                                    ld      (ix+3),h                ; .
  94+ 0000                                      ENDM
  95+ 0000              ;------------------------------------------------------------------------------
  96+ 0000              SaveAHLToY:             MACRO
  97+ 0000 ~                                    ld      (ix+5),a                ; save DE.H into Zd
  98+ 0000 ~                                    ld      (ix+4),h                ; .
  99+ 0000 ~                                    ld      (ix+3),l                ; .
 100+ 0000                                      ENDM
 101+ 0000              ;------------------------------------------------------------------------------
 102+ 0000              SetCDEtoZ:              MACRO
 103+ 0000 ~                                    ld      c,(ix+8)
 104+ 0000 ~                                    ld      de,(ix+6)
 105+ 0000                                      ENDM
 106+ 0000              ;------------------------------------------------------------------------------
 107+ 0000              SetBHLtoZ:              MACRO
 108+ 0000 ~                                    ld      b,(ix+8)
 109+ 0000 ~                                    ld      hl,(ix+6)
 110+ 0000                                      ENDM
 111+ 0000              ;------------------------------------------------------------------------------
 112+ 0000              SaveDEHToZ:             MACRO
 113+ 0000 ~                                    ld      (ix+8),d                ; save DE.H into Zd
 114+ 0000 ~                                    ld      (ix+7),e                ; .
 115+ 0000 ~                                    ld      (ix+6),h                ; .
 116+ 0000                                      ENDM
 117+ 0000              ;------------------------------------------------------------------------------
 118+ 0000              SaveAHLToZ:             MACRO
 119+ 0000 ~                                    ld      (ix+8),a                ; save DE.H into Zd
 120+ 0000 ~                                    ld      (ix+7),h                ; .
 121+ 0000 ~                                    ld      (ix+6),l                ; .
 122+ 0000                                      ENDM
 123+ 0000              ;------------------------------------------------------------------------------
 124+ 0000              SetDEAtoABSX:           MACRO
 125+ 0000 ~                                    ld      de,(ix+1)
 126+ 0000 ~                                    ld      a,(ix+0)
 127+ 0000 ~                                    res     7,d
 128+ 0000                                      ENDM
 129+ 0000              ;------------------------------------------------------------------------------
 130+ 0000              SetDEAtoABSY:           MACRO
 131+ 0000 ~                                    ld      de,(ix+4)
 132+ 0000 ~                                    ld      a,(ix+3)
 133+ 0000 ~                                    res     7,d
 134+ 0000                                      ENDM
 135+ 0000              ;------------------------------------------------------------------------------
 136+ 0000              SetDEAtoABSZ:           MACRO
 137+ 0000 ~                                    ld      de,(ix+7)
 138+ 0000 ~                                    ld      a,(ix+6)
 139+ 0000 ~                                    res     7,d
 140+ 0000                                      ENDM
 141+ 0000              ;------------------------------------------------------------------------------
 142+ 0000              SetHLtoABSXHiLo:        MACRO
 143+ 0000 ~                                    ld      hl,(ix)
 144+ 0000                                      ENDM
 145+ 0000              ;------------------------------------------------------------------------------
 146+ 0000              SetDEtoABSYHiLo:        MACRO
 147+ 0000 ~                                    ld      de,(ix+3)
 148+ 0000                                      ENDM
 149+ 0000              ;------------------------------------------------------------------------------
 150+ 0000              SetBCtoABSZHiLo:        MACRO
 151+ 0000 ~                                    ld      bc,(ix+6)
 152+ 0000                                      ENDM
 153+ 0000              ;------------------------------------------------------------------------------
 154+ 0000              SetHLtoABSXSgnHi:       MACRO
 155+ 0000 ~                                    ld      hl,(ix+1)
 156+ 0000 ~                                    ld      a, h
 157+ 0000 ~                                    and     $7F
 158+ 0000 ~                                    ld      h,a
 159+ 0000                                      ENDM
 160+ 0000              ;------------------------------------------------------------------------------
 161+ 0000              SetDEtoABSYSgnHi:       MACRO
 162+ 0000 ~                                    ld      de,(ix+4)
 163+ 0000 ~                                    ld      a, d
 164+ 0000 ~                                    and     $7F
 165+ 0000 ~                                    ld      d,a
 166+ 0000                                      ENDM
 167+ 0000              ;------------------------------------------------------------------------------
 168+ 0000              SetBCtoABSZSgnHi:       MACRO
 169+ 0000 ~                                    ld      bc,(ix+7)
 170+ 0000 ~                                    ld      a, b
 171+ 0000 ~                                    and     $7F
 172+ 0000 ~                                    ld      b,a
 173+ 0000                                      ENDM
 174+ 0000              ;------------------------------------------------------------------------------
 175+ 0000              SetNormXToHL:           MACRO
 176+ 0000 ~                                    ld     (ix+20),hl
 177+ 0000                                      ENDM
 178+ 0000              ;------------------------------------------------------------------------------
 179+ 0000              SetNormX96ToDE:         MACRO
 180+ 0000 ~                                    ld     (ix+20),de
 181+ 0000                                      ENDM
 182+ 0000              ;------------------------------------------------------------------------------
 183+ 0000              SetNormY96ToDE:         MACRO
 184+ 0000 ~                                    ld     (ix+22),de
 185+ 0000                                      ENDM
 186+ 0000              ;------------------------------------------------------------------------------
 187+ 0000              SetNormZ96ToBC:         MACRO
 188+ 0000 ~                                    ld     (ix+24),bc
 189+ 0000                                      ENDM
 190+ 0000              ;------------------------------------------------------------------------------
 191+ 0000              SetNormZ96ToDE:         MACRO
 192+ 0000 ~                                    ld     (ix+24),de
 193+ 0000                                      ENDM
 194+ 0000              ;------------------------------------------------------------------------------
 195+ 0000              ; IYH holds sign bits so we need bit 7 for x
 196+ 0000              SetABSNormXToDE:        MACRO
 197+ 0000 ~            .skipSign:              ld     (ix+26),de
 198+ 0000                                      ENDM
 199+ 0000              ;------------------------------------------------------------------------------
 200+ 0000              ; IYH holds sign bits so we need bit 6 for y
 201+ 0000              SetABSNormYToDE:        MACRO
 202+ 0000 ~                                    ld     (ix+28),de
 203+ 0000                                      ENDM
 204+ 0000              ;------------------------------------------------------------------------------
 205+ 0000              ; IYH holds sign bits so we need bit 5 for z
 206+ 0000              SetABSNormZToBC:        MACRO
 207+ 0000 ~                                    ld     (ix+30),bc
 208+ 0000                                      ENDM
 209+ 0000              ;------------------------------------------------------------------------------
 210+ 0000              ; IYH holds sign bits so we need bit 5 for z
 211+ 0000              SetABSNormZToDE:        MACRO
 212+ 0000 ~                                    ld     (ix+30),de
 213+ 0000                                      ENDM
 214+ 0000              ;------------------------------------------------------------------------------
 215+ 0000              NormXMul96:             MACRO
 216+ 0000 ~                                    ld      e,a
 217+ 0000 ~                                    ld      d,96
 218+ 0000 ~                                    mul     de
 219+ 0000 ~                                    ld      a,d                 ; is norm 0,
 220+ 0000 ~                                    or      e                   ; if so we can skip
 221+ 0000 ~                                    jp      z,.DoneNorm96X      ; sign check
 222+ 0000 ~                                    ld      a,(ix+2)            ;
 223+ 0000 ~                                    and     $80                 ;
 224+ 0000 ~                                    or      d
 225+ 0000 ~                                    ld      d,a
 226+ 0000 ~            .DoneNorm96X:
 227+ 0000                                      ENDM
 228+ 0000              ;------------------------------------------------------------------------------
 229+ 0000              NormYMul96:             MACRO
 230+ 0000 ~                                    ld      e,a
 231+ 0000 ~                                    ld      d,96
 232+ 0000 ~                                    mul     de
 233+ 0000 ~                                    ld      a,d                 ; is norm 0,
 234+ 0000 ~                                    or      e                   ; if so we can skip
 235+ 0000 ~                                    jp      z,.DoneNorm96Y      ; sign check
 236+ 0000 ~                                    ld      a,(ix+5)            ;
 237+ 0000 ~                                    and     $80                 ;
 238+ 0000 ~                                    or      d
 239+ 0000 ~                                    ld      d,a
 240+ 0000 ~            .DoneNorm96Y:
 241+ 0000                                      ENDM
 242+ 0000              ;------------------------------------------------------------------------------
 243+ 0000              NormZMul96:             MACRO
 244+ 0000 ~                                    ld      e,a
 245+ 0000 ~                                    ld      d,96
 246+ 0000 ~                                    mul     de
 247+ 0000 ~                                    ld      a,d                 ; is norm 0,
 248+ 0000 ~                                    or      e                   ; if so we can skip
 249+ 0000 ~                                    jp      z,.DoneNorm96Z      ; sign check
 250+ 0000 ~                                    ld      a,(ix+8)            ;
 251+ 0000 ~                                    and     $80                 ;
 252+ 0000 ~                                    or      d
 253+ 0000 ~                                    ld      d,a
 254+ 0000 ~            .DoneNorm96Z:
 255+ 0000                                      ENDM
 256+ 0000              ;------------------------------------------------------------------------------
 257+ 0000
# file closed: UniverseObjectPosMacros.asm
  68  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  69  0000              ; Total screen list
  70  0000              ; Local Chart
  71  0000              ; Galactic Chart
  72  0000              ; Market Prices
  73  0000              ; Inventory
  74  0000              ; Comander status
  75  0000              ; System Data
  76  0000              ; Mission Briefing
  77  0000              ; missio completion
  78  0000              ; Docked  Menu (only place otehr than pause you can load and save)
  79  0000              ; Pause Menu (only place you can load from )
  80  0000              ; byint and selling equipment
  81  0000              ; bying and selling stock
  82  0000
  83  0000              TopOfStack              equ $5CCB ;$6100
  84  0000
  85  0000                                      ORG $5DCB;      $6200
  86  5DCB F3           EliteNextStartup:       di
  87  5DCC FD 00                                break
  88  5DCE DD 21 FF 5D                          ld      ix,Test1
  89  5DD2 06 0F                                ld      b,15
  90  5DD4 DD E5 C5     .testloop:              push    ix,,bc
  91  5DD7 CD DF 5F                             call    TestNormalise
  92  5DDA C1 DD E1                             pop     ix,,bc
  93  5DDD DD E5 E1                             ld      hl,ix
  94  5DE0 3E 20                                ld      a,$20
  95  5DE2 ED 31                                add     hl,a
  96  5DE4 E5 DD E1                             ld      ix,hl
  97  5DE7 10 EB                                djnz    .testloop
  98  5DE9 FD 00                                break
  99  5DEB
 100  5DEB 00 00        ErrorCount:             DW  0
 101  5DED 00           varQ                    DB  0
 102  5DEE 00           varR                    DB  0
 103  5DEF
 104  5DEF
 105  5DEF 00 00 00...  MultiplyResult:         DS  16  ; reserve 6 bytes for maths result, little endian rest is padding for console display alignment
 106  5DFF
 107  5DFF
 108  5DFF                                      ;  X............  Y............   Y............  Fill.......... Actual.......  Pass/Fail
 109  5DFF                                      ;   0    1    2    3    4    5    6    7,   8,   9,   A,   B,   C,   D,   E,   F    0    1    2    3    4    5    6    7,   8,   9,   A,   B,   C,   D,   E,   F
 110  5DFF 0C FA 00 00  Test1:                   DB $0C, $FA, $00, $00, $7C, $00, $C0, $45, $00, $01, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ;
 110  5E03 7C 00 C0 45
 110  5E07 00 01 00 00
 110  5E0B 00 00 00 11
 110  5E0F 00 00 00 00
 110  5E13 00 00 00 00
 110  5E17 00 00 00 00
 110  5E1B 00 00 00 00
 111  5E1F C0 00 04 C0  Test2:                   DB $C0, $00, $04, $C0, $00, $00, $00, $80, $01, $04, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ;
 111  5E23 00 00 00 80
 111  5E27 01 04 00 00
 111  5E2B 00 00 00 11
 111  5E2F 00 00 00 00
 111  5E33 00 00 00 00
 111  5E37 00 00 00 00
 111  5E3B 00 00 00 00
 112  5E3F B3 FA 02 00  Test3:                   DB $B3, $FA, $02, $00, $4B, $00, $00, $B3, $45, $03, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ;
 112  5E43 4B 00 00 B3
 112  5E47 45 03 00 00
 112  5E4B 00 00 00 11
 112  5E4F 00 00 00 00
 112  5E53 00 00 00 00
 112  5E57 00 00 00 00
 112  5E5B 00 00 00 00
 113  5E5F 6E 4D 00 6E  Test4:                   DB $6E, $4D, $00, $6E, $4B, $80, $00, $00, $02, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ;
 113  5E63 4B 80 00 00
 113  5E67 02 00 00 00
 113  5E6B 00 00 00 11
 113  5E6F 00 00 00 00
 113  5E73 00 00 00 00
 113  5E77 00 00 00 00
 113  5E7B 00 00 00 00
 114  5E7F 00 73 80 00  Test5:                   DB $00, $73, $80, $00, $D7, $00, $00, $00, $64, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ;
 114  5E83 D7 00 00 00
 114  5E87 64 00 00 00
 114  5E8B 00 00 00 11
 114  5E8F 00 00 00 00
 114  5E93 00 00 00 00
 114  5E97 00 00 00 00
 114  5E9B 00 00 00 00
 115  5E9F 00 00 8B C0  Test6:                   DB $00, $00, $8B, $C0, $00, $80, $00, $C0, $00, $8B, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ;
 115  5EA3 00 80 00 C0
 115  5EA7 00 8B 00 00
 115  5EAB 00 00 00 11
 115  5EAF 00 00 00 00
 115  5EB3 00 00 00 00
 115  5EB7 00 00 00 00
 115  5EBB 00 00 00 00
 116  5EBF 40 54 02 80  Test7:                   DB $40, $54, $02, $80, $0E, $00, $00, $C0, $62, $02, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ;
 116  5EC3 0E 00 00 C0
 116  5EC7 62 02 00 00
 116  5ECB 00 00 00 11
 116  5ECF 00 00 00 00
 116  5ED3 00 00 00 00
 116  5ED7 00 00 00 00
 116  5EDB 00 00 00 00
 117  5EDF C0 00 80 00  Test8:                   DB $C0, $00, $80, $00, $02, $80, $00, $C0, $02, $80, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ;
 117  5EE3 02 80 00 C0
 117  5EE7 02 80 00 00
 117  5EEB 00 00 00 11
 117  5EEF 00 00 00 00
 117  5EF3 00 00 00 00
 117  5EF7 00 00 00 00
 117  5EFB 00 00 00 00
 118  5EFF 40 00 00 00  Test9:                   DB $40, $00, $00, $00, $02, $00, $00, $40, $02, $00, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ;
 118  5F03 02 00 00 40
 118  5F07 02 00 00 00
 118  5F0B 00 00 00 11
 118  5F0F 00 00 00 00
 118  5F13 00 00 00 00
 118  5F17 00 00 00 00
 118  5F1B 00 00 00 00
 119  5F1F 80 06 05 00  TestA:                   DB $80, $06, $05, $00, $02, $80, $00, $80, $04, $05, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ;
 119  5F23 02 80 00 80
 119  5F27 04 05 00 00
 119  5F2B 00 00 00 11
 119  5F2F 00 00 00 00
 119  5F33 00 00 00 00
 119  5F37 00 00 00 00
 119  5F3B 00 00 00 00
 120  5F3F C0 00 80 C0  TestB:                   DB $C0, $00, $80, $C0, $00, $03, $00, $00, $00, $03, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ;
 120  5F43 00 03 00 00
 120  5F47 00 03 00 00
 120  5F4B 00 00 00 11
 120  5F4F 00 00 00 00
 120  5F53 00 00 00 00
 120  5F57 00 00 00 00
 120  5F5B 00 00 00 00
 121  5F5F C0 00 04 C0  TestC:                   DB $C0, $00, $04, $C0, $00, $04, $00, $80, $01, $08, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ;
 121  5F63 00 04 00 80
 121  5F67 01 08 00 00
 121  5F6B 00 00 00 11
 121  5F6F 00 00 00 00
 121  5F73 00 00 00 00
 121  5F77 00 00 00 00
 121  5F7B 00 00 00 00
 122  5F7F 40 00 02 80  TestD:                   DB $40, $00, $02, $80, $00, $00, $00, $C0, $00, $02, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ;
 122  5F83 00 00 00 C0
 122  5F87 00 02 00 00
 122  5F8B 00 00 00 11
 122  5F8F 00 00 00 00
 122  5F93 00 00 00 00
 122  5F97 00 00 00 00
 122  5F9B 00 00 00 00
 123  5F9F C0 00 04 80  TestE:                   DB $C0, $00, $04, $80, $61, $00, $00, $40, $62, $04, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ;
 123  5FA3 61 00 00 40
 123  5FA7 62 04 00 00
 123  5FAB 00 00 00 11
 123  5FAF 00 00 00 00
 123  5FB3 00 00 00 00
 123  5FB7 00 00 00 00
 123  5FBB 00 00 00 00
 124  5FBF 66 12 06 80  TestF:                   DB $66, $12, $06, $80, $61, $00, $00, $E6, $73, $06, $00, $00, $00, $00, $00, $11, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ;
 124  5FC3 61 00 00 E6
 124  5FC7 73 06 00 00
 124  5FCB 00 00 00 11
 124  5FCF 00 00 00 00
 124  5FD3 00 00 00 00
 124  5FD7 00 00 00 00
 124  5FDB 00 00 00 00
 125  5FDF
 126  5FDF CD A5 6B     TestNormalise:          call    Normalise24IX         ; BH.L by CD.E putting result in BCDE.HL
 127  5FE2 C9                                   ret
 128  5FE3
 129  5FE3              ;--------------------------------------------------------------------------------------
 130  5FE3                  INCLUDE	"../../Maths24/asm_addition24.asm"
# file opened: asm_addition24.asm
   1+ 5FE3              ; Bodge 2';s c
   2+ 5FE3 78           AHLequBHLplusCDE:       ld      a,b                             ; if BHL is negative
   3+ 5FE4 CB 78                                bit     7,b                             ; then
   4+ 5FE6 CA FA 5F                             jp      z,.CheckCDE                     ;
   5+ 5FE9              .NegBHL:                ;ld      a,b                             ; clear sign bit
   6+ 5FE9                                      ;and     $80                             ; and 2's c BHL
   7+ 5FE9 CB B8                                res     7,b
   8+ 5FEB                                      NegBHL                                  ;
   8+ 5FEB 7D          >                    ld      a,l
   8+ 5FEC 2F          >                    cpl
   8+ 5FED C6 01       >                    add     a,1
   8+ 5FEF 6F          >                    ld      l,a
   8+ 5FF0 7C          >                    ld      a,h
   8+ 5FF1 2F          >                    cpl
   8+ 5FF2 CE 00       >                    adc     a,0
   8+ 5FF4 67          >                    ld      h,a
   8+ 5FF5 78          >                    ld      a,b
   8+ 5FF6 2F          >                    cpl
   8+ 5FF7 CE 00       >                    adc     a,0
   8+ 5FF9 47          >                    ld      b,a
   9+ 5FFA                                      ;ld      b,a                             ;
  10+ 5FFA CB 79        .CheckCDE               bit     7,c                             ; if CDE is negative
  11+ 5FFC CA 10 60                             jp      z,.PerformAdd                   ;
  12+ 5FFF              .NegCDE:               ;push    af,,hl                          ;
  13+ 5FFF                                      ;ld      a,c                             ; set up AHL as CDE
  14+ 5FFF                                      ;ex      de,hl                           ; preserving old HL
  15+ 5FFF CB B9                                res     7,c
  16+ 6001                                      NegCDE                                  ; in DE
  16+ 6001 7B          >                    ld      a,e
  16+ 6002 2F          >                    cpl
  16+ 6003 C6 01       >                    add     a,1
  16+ 6005 5F          >                    ld      e,a
  16+ 6006 7A          >                    ld      a,d
  16+ 6007 2F          >                    cpl
  16+ 6008 CE 00       >                    adc     a,0
  16+ 600A 57          >                    ld      d,a
  16+ 600B 79          >                    ld      a,c
  16+ 600C 2F          >                    cpl
  16+ 600D CE 00       >                    adc     a,0
  16+ 600F 4F          >                    ld      c,a
  17+ 6010                                      ;ld      c,a                             ; then negate
  18+ 6010                                      ;ex      de,hl                           ; and restore
  19+ 6010                                      ;pop     af,,hl                          ; BHL
  20+ 6010              .PerformAdd:            ClearCarryFlag
  20+ 6010 B7          >                        or a
  21+ 6011 ED 5A                                adc     hl,de
  22+ 6013 78                                   ld      a,b
  23+ 6014 89                                   adc     c
  24+ 6015 CB 7F                                bit     7,a
  25+ 6017 C8                                   ret     z
  26+ 6018                                      NegAHL
  26+ 6018 47          >                    ld      b,a
  26+ 6019 7D          >                    ld      a,l
  26+ 601A 2F          >                    cpl
  26+ 601B C6 01       >                    add     a,1
  26+ 601D 6F          >                    ld      l,a
  26+ 601E 7C          >                    ld      a,h
  26+ 601F 2F          >                    cpl
  26+ 6020 CE 00       >                    adc     a,0
  26+ 6022 67          >                    ld      h,a
  26+ 6023 78          >                    ld      a,b
  26+ 6024 2F          >                    cpl
  26+ 6025 CE 00       >                    adc     a,0
  27+ 6027 F6 80                                or      $80
  28+ 6029 C9                                   ret
  29+ 602A              ;;-;-- Addition---------------------------------------------------
  30+ 602A              ;;-; BAHL = BHL+CDE Lead Sign bit - If overflows AHL then carry will be set resulting in B holding sign and rest of value, else AHL holds value
  31+ 602A              ;;-; in reality will we aim for all values being S14.8 so bit 15 is always clear for overflow
  32+ 602A              ;;-AHLequBHLplusCDEX:       ld      a,b                          ; if b sign and c sign were different then bit 7 of a will be 1 which means
  33+ 602A              ;;-                        and     $80                          ; Signs are opposite there fore we can subtract to get difference
  34+ 602A              ;;-                        xor     c                            ;
  35+ 602A              ;;-                        JumpIfNegative .OppositeSigns        ;
  36+ 602A              ;;-.SameSigns:             ld      a,b                          ; if they are both negative
  37+ 602A              ;;-                        or      c                            ; then we can do an add but also set the sign bit
  38+ 602A              ;;-                        JumpIfNegative .BothNegative         ; optimisation so we can just do simple add if both positive
  39+ 602A              ;;-                        ;-------Perform Both Positive Add ----
  40+ 602A              ;;-.BothPositive:          adc     hl,de                        ; both positive so a will already be zero, OR will hnave cleared carry
  41+ 602A              ;;-                        ld      a,b                          ; a = b + c + an carry from HL + DE
  42+ 602A              ;;-                        adc     c                            ;
  43+ 602A              ;;-                        ret     nc                           ; if there was no carry then we are good
  44+ 602A              ;;-                        ;-------Done Both Positive Add -------
  45+ 602A              ;;-.OverFlowPositive:      ld      b,1                          ; if we overflow from +BHL +  +CDE then we already have sign cleared in A and only 1 bit to roll into B + no sign bit
  46+ 602A              ;;-                        ret
  47+ 602A              ;;-                        ;-------Perform Both Negative Add ----
  48+ 602A              ;;-.BothNegative:          res     7,b                          ; clear sign bits for both values
  49+ 602A              ;;-                        res     7,c                          ; .
  50+ 602A              ;;-                        adc     hl,de                        ; now behave like they are both positive
  51+ 602A              ;;-                        ld      a,b
  52+ 602A              ;;-                        adc     c
  53+ 602A              ;;-                        jp      c,.OverFlowNegative          ; if there was carry we need to overflow into b
  54+ 602A              ;;-                        or      %10000000                    ; set bit 7 of A for negative
  55+ 602A              ;;-                        ret
  56+ 602A              ;;-                        ;-------Done Both Negative Add -------
  57+ 602A              ;;-.OverFlowNegative:      ld      b,%10000001                  ; carry over the bit but also set the sign bit
  58+ 602A              ;;-                        ret
  59+ 602A              ;;-.OppositeSigns:         bit     7,b                          ; if BHL was negative then CDE is positive
  60+ 602A              ;;-                        jp      nz,.CDEMinusBHL              ; so perform CDE - BHL
  61+ 602A              ;;-                        ;-------Prep BHL - CDE (CDE -ve)------
  62+ 602A              ;;-.BHLMinusCDE:           res     7,c                          ; we have just one subtract routine
  63+ 602A              ;;-                        ex      hl,de                        ; so we swap registers and just treat it as CDE-BHL
  64+ 602A              ;;-                        ld      a,b                          ; and we have to use a when swapping b and c
  65+ 602A              ;;-                        ld      b,c                          ; .
  66+ 602A              ;;-                        ld      c,a                          ; .
  67+ 602A              ;;-                        ;-------Perform CDE - BHL (BHL -ve)---
  68+ 602A              ;;-.CDEMinusBHL:           res     7,b                          ; B is now ABS (B)
  69+ 602A              ;;-                        ClearCarryFlag                       ; now its just common CDE-BHL
  70+ 602A              ;;-                        ex      hl,de                        ; hl = de-hl by swapping them round
  71+ 602A              ;;-                        sbc     hl,de                        ;
  72+ 602A              ;;-                        ld      a,c                          ; a= c - b
  73+ 602A              ;;-                        sbc     b                            ; now AHL is result
  74+ 602A              ;;-                        ret     nc                           ; if there was no carry then we are good and it didn't end up 2's c
  75+ 602A              ;;-.CDEFlipSign:           NegAHL                               ; as CDE-BHL became negative we make result lead sign negativce
  76+ 602A              ;;-                        or      %10000000                    ; flip the lead bit of A
  77+ 602A              ;;-                        ret
  78+ 602A              SwapViaA:               MACRO   r1, r2
  79+ 602A ~                                    ld      a,r1
  80+ 602A ~                                    ld      r1,r2
  81+ 602A ~                                    ld      r2,a
  82+ 602A                                      ENDM
  83+ 602A              AHLequHLAddCarryAViaDE: MACRO
  84+ 602A ~                                    ld      d,0                         ; de = P1 carry
  85+ 602A ~                                    ld      e,a                         ; .
  86+ 602A ~                                    xor     a                           ; Clear carry and prep a for P2 carry
  87+ 602A ~                                    add     hl,de                       ; .
  88+ 602A ~                                    adc     a,a                         ; .
  89+ 602A                                      ENDM
  90+ 602A              ; variants on AHLequBHLplusCDE
  91+ 602A              ; AHL = BHL+DEC Lead Sign bit
  92+ 602A 7A           AHLequBHLplusDEC:       ld      a,d                         ; d = e (saving d)
  93+ 602B 53                                   ld      d,e                         ; .
  94+ 602C 59                                   ld      e,c                         ; e = c
  95+ 602D 4F                                   ld      c,a                         ; c = d (orginal value)
  96+ 602E C3 E3 5F                             jp      AHLequBHLplusCDE
  97+ 6031
  98+ 6031              ; AHL = BHL-CDE Lead Sign bit
  99+ 6031 79           AHLequBHLminusCDE:      ld      a,c
 100+ 6032 EE 80                                xor     %10000000
 101+ 6034 4F                                   ld      c,a
 102+ 6035 C3 E3 5F                             jp      AHLequBHLplusCDE
 103+ 6038
 104+ 6038              ; variant on above for simplifying post multiply           ; d = e (saving d)
 105+ 6038 7A           AHLequBHLminusDEC:      ld      a,d                        ; .
 106+ 6039 F6 80                                or      %10000000                  ; but we also flip the sign on the saved D
 107+ 603B 53                                   ld      d,e                        ; .
 108+ 603C 59                                   ld      e,c                        ; e = c
 109+ 603D 4F                                   ld      c,a                        ; c = d (orginal value)
 110+ 603E C3 E3 5F                             jp      AHLequBHLplusCDE
 111+ 6041
 112+ 6041              ; If it will fit
 113+ 6041              ;  HLBC = BHL * CDE  Lead Sign bit, carry Clear
 114+ 6041              ; else
 115+ 6041              ;  AHLBC = BHL * CDE Lead sign bit , carry set
 116+ 6041              ; performs p0 = x0*y0                               L*E
 117+ 6041              ;          p1 = x1*y0 + x0*y1 + p0 carry            H*E + D*L
 118+ 6041              ;          p2 = x2*y0 + x0*y2 + x1*y1 + p1 carry    B*E + L*C + H*D
 119+ 6041              ;          p3 = x2*y1 + x1 * y2 + p2 carry          B*D + H*C
 120+ 6041              ;          p4 = x2* y2                              B*C
 121+ 6041              ; reverse order for stack retrival                                                                                              B H L  C D E
 122+ 6041              ; performs p4 = x2* y2                              B*C                B*C                     leave as is           BHL*CDE   020305 01040A 0201            02                  P4 = 2
 123+ 6041              ;          p3 = x2*y1 + x1 * y2 + p2 carry          B*D + H*C          Swap B<>E and C<>L      E*D + H * L           EHC*LDB    E H C  L D B 0204 0301       08+03 = 0B          P3 = B
 124+ 6041              ;          p2 = x2*y0 + x0*y2 + x1*y1 + p1 carry    E*B + C*L + H*D    Swap B<>D and C<>H      E*D + H * L + C * B   ECH*LBD    E C H  L B D 020A 0501 0304  14+05+0C=25         P2 = 25
 125+ 6041              ;          p1 = x1*y0 + x0*y1                       C*D + H*B          Swap C<>E and L<>B      E*D + H * L           CEH*BLD    C E H  B L D 030A 0504       1E+14 = 32          P1 = 32 carry = 0
 126+ 6041              ;          p0 = x0*y0                               C*B                Swap E,H, ex hl,de in calc                    CHE*BDL                 050A            32                  P0 = 32 Carry = 0
 127+ 6041 78           HLBCequBHLmulCDE:       ld      a,b                         ; multiply is simpler as same signs is always positive
 128+ 6042 A9                                   xor     c                           ; opposite is always negative
 129+ 6043 E6 80                                and     $80                         ; .
 130+ 6045 F5           .SaveSign:              push    af                          ; save a to the stack that will now hold 0 or $80,
 131+ 6046 CB B8        .ClearSignBits:         res     7,b
 132+ 6048 CB B9                                res     7,c
 133+ 604A C5           .PrepP4:                push    bc                          ; save registers for p4 = x2*y2 p3 carry > BC = x0 y0
 134+ 604B              .PrepP3:                SwapViaA b,e                        ; save registers for p3  = x2*y1 + x1*y2 + p2 carry
 134+ 604B 78          >                        ld      a,b
 134+ 604C 43          >                        ld      b,e
 134+ 604D 5F          >                        ld      e,a
 135+ 604E                                      SwapViaA c,l
 135+ 604E 79          >                        ld      a,c
 135+ 604F 4D          >                        ld      c,l
 135+ 6050 6F          >                        ld      l,a
 136+ 6051 D5 E5                                push    de,,hl                      ; DE = X2 Y1 HL = X1 Y2
 137+ 6053              .PrepP2:                SwapViaA d,b                         ; save registers for p2  = x2*y0 + x0*y2 + x1*y1 + p1 carry
 137+ 6053 7A          >                        ld      a,d
 137+ 6054 50          >                        ld      d,b
 137+ 6055 47          >                        ld      b,a
 138+ 6056                                      SwapViaA c,h
 138+ 6056 79          >                        ld      a,c
 138+ 6057 4C          >                        ld      c,h
 138+ 6058 67          >                        ld      h,a
 139+ 6059 D5 E5 C5                             push    de,,hl,,bc                  ; save registers for p1 = x1*y0 + x0*y1 + p0 carry
 140+ 605C              .PrepP1:                SwapViaA c,e
 140+ 605C 79          >                        ld      a,c
 140+ 605D 4B          >                        ld      c,e
 140+ 605E 5F          >                        ld      e,a
 141+ 605F                                      SwapViaA l,b
 141+ 605F 7D          >                        ld      a,l
 141+ 6060 68          >                        ld      l,b
 141+ 6061 47          >                        ld      b,a
 142+ 6062 D5 E5                                push    de,,hl
 143+ 6064              .PrepP0:                SwapViaA e,h                        ; we don't care about original values now as they are on the stack
 143+ 6064 7B          >                        ld      a,e
 143+ 6065 5C          >                        ld      e,h
 143+ 6066 67          >                        ld      h,a
 144+ 6067 ED 30        .CalcP0:                mul     de                          ; de = x0 * y0 no need for carry logic as even FF*FF = FE01
 145+ 6069 42 4B                                ld      bc,de                       ; so b = P0 carry,c = P0
 146+ 606B D1           .CalcP1:                pop     de                          ; get P1 components off stack
 147+ 606C ED 30                                mul     de                          ; hl = x1*y0
 148+ 606E EB                                   ex      de,hl                       ; so de = P1c P1 b =P0c P0
 149+ 606F AF           .AddP0Carry:            xor     a                           ; hl = x1*y0 + P0 carry
 150+ 6070 16 00                                ld      d,0                         ; .
 151+ 6072 58                                   ld      e,b                         ; .
 152+ 6073 19                                   add     hl,de                       ; .
 153+ 6074 8F                                   adc     a,a                         ; a = carry
 154+ 6075 D1                                   pop     de
 155+ 6076 ED 30                                mul     de                          ; de = x0*y1
 156+ 6078 A7                                   and     a                           ; clear carry flag whilst retaining a
 157+ 6079 19                                   add     hl,de                       ; hl = x1*y0 + x0*y1
 158+ 607A CE 00        .CalcP1Carry:           adc     a,0                         ;
 159+ 607C 84                                   add     h                           ; a = P1 carry
 160+ 607D 45                                   ld      b,l                         ; A = P1 carry bc = P1 P0
 161+ 607E D1           .CalcP2:                pop     de                          ; we pull in bc later directly into de
 162+ 607F ED 30                                mul     de                          ; hl = x2*y0
 163+ 6081 EB                                   ex      hl,de                       ; .
 164+ 6082              .AddP1Carry:            AHLequHLAddCarryAViaDE
 164+ 6082 16 00       >                        ld      d,0                         ; de = P1 carry
 164+ 6084 5F          >                        ld      e,a                         ; .
 164+ 6085 AF          >                        xor     a                           ; Clear carry and prep a for P2 carry
 164+ 6086 19          >                        add     hl,de                       ; .
 164+ 6087 8F          >                        adc     a,a                         ; .
 165+ 6088 D1           .CalcP2Pt2:             pop     de                          ; de = x0*y2
 166+ 6089 ED 30                                mul     de                          ; .
 167+ 608B A7                                   and     a                           ; Clear carry preserve a
 168+ 608C 19                                   add     hl,de                       ; hl = x2*y0 + x0*y2
 169+ 608D 8F                                   adc     a,a                         ; a = new carry
 170+ 608E D1           .CalcP2Pt3:             pop     de                          ; de = x1*y1
 171+ 608F ED 30                                mul     de                          ; .
 172+ 6091 A7                                   and     a                           ; hl = x2*y0 + x0*y2 + x1*y1, preserve carry flag
 173+ 6092 19                                   add     hl,de                       ; so we have hl = P2c P2 BC = P1P1
 174+ 6093 CE 00        .CalcP2Carry:           adc     a,0                         ; A = calc carry + P2 carry in h
 175+ 6095 84                                   add     a,h                         ; l = P2 bc = P1 P0
 176+ 6096 5D                                   ld      e,l                         ; ixl = l (via e as you can't do hl to ix direct)
 177+ 6097 DD 6B        .SaveP2:                ld      ixl,e                       ; a = P2 carry ixl:bc = P2 P1 P0
 178+ 6099 D1           .CalcP3                 pop     de                          ; hl = x2*y1
 179+ 609A ED 30                                mul     de                          ; .
 180+ 609C EB                                   ex      de,hl                       ; .
 181+ 609D              .AddP2Carry:            AHLequHLAddCarryAViaDE
 181+ 609D 16 00       >                        ld      d,0                         ; de = P1 carry
 181+ 609F 5F          >                        ld      e,a                         ; .
 181+ 60A0 AF          >                        xor     a                           ; Clear carry and prep a for P2 carry
 181+ 60A1 19          >                        add     hl,de                       ; .
 181+ 60A2 8F          >                        adc     a,a                         ; .
 182+ 60A3 D1           .CalcP3Pt2:             pop     de                          ; de =  x1*y2
 183+ 60A4 ED 30                                mul     de                          ; .
 184+ 60A6 A7                                   and     a                           ; Clear carry preserve a
 185+ 60A7 19                                   add     hl,de                       ; hl = x2*y1 + x1*y2
 186+ 60A8 CE 00                                adc     a,0                         ; a = new carry for P3, l = p3
 187+ 60AA 84                                   add     a,h                         ; .
 188+ 60AB 5D           .SaveP3:                ld      e,l                         ; load ixh via e
 189+ 60AC DD 63                                ld      ixh,e                       ; so we now have a = P3 carry ix P3P2 bc = P1P0
 190+ 60AE D1           .CalcP4:                pop     de                          ; de = x2* y2 + P3 carry
 191+ 60AF ED 30                                mul     de                          ; .
 192+ 60B1 EB                                   ex      de,hl                       ;
 193+ 60B2              .AddP3Carry:            AHLequHLAddCarryAViaDE              ; hl ix bc = P5P4 P3P2 P1P0
 193+ 60B2 16 00       >                        ld      d,0                         ; de = P1 carry
 193+ 60B4 5F          >                        ld      e,a                         ; .
 193+ 60B5 AF          >                        xor     a                           ; Clear carry and prep a for P2 carry
 193+ 60B6 19          >                        add     hl,de                       ; .
 193+ 60B7 8F          >                        adc     a,a                         ; .
 194+ 60B8 7D           .RecoverSignBit:        ld      a,l                         ; Is P4 populated,
 195+ 60B9 A7                                   and     a
 196+ 60BA CA C3 60                             jp      z,.P3toP0                   ; if not then we have result P3P2P1P0
 197+ 60BD F1           .P4toP0:                pop     af                          ; else return with AHLBC
 198+ 60BE B5                                   or      l
 199+ 60BF DD E5 E1                             ld      hl,ix
 200+ 60C2 C9                                   ret
 201+ 60C3 F1           .P3toP0:                pop     af
 202+ 60C4 DD E5 E1                             ld      hl,ix                       ; move P2P2 into hl
 203+ 60C7 B4                                   or      h
 204+ 60C8 67                                   ld      h,a
 205+ 60C9 AF                                   xor     a                           ; return result in hlbc with CarryClear
 206+ 60CA C9                                   ret
 207+ 60CB
 208+ 60CB F1           ResultIsZero:           pop     af                          ; get rid of unwanted sign bits
 209+ 60CC 4B                                   ld      c,e                         ; CDE = EHL as remainder
 210+ 60CD EB                                   ex      hl,de
 211+ 60CE AF                                   xor     a                           ; result AHL = $0
 212+ 60CF 67                                   ld      h,a
 213+ 60D0 6F                                   ld      l,a                         ; .
 214+ 60D1 C9                                   ret
 215+ 60D2
 216+ 60D2 F1           DivideByZero:           pop     af                          ; get rid of unwanted sign bits
 217+ 60D3 4B                                   ld      c,e                         ; CDE = EHL as remainder
 218+ 60D4 EB                                   ex      hl,de
 219+ 60D5 3E FF                                ld      a,$FF                       ; result AHL = $FFFFFF
 220+ 60D7 21 FF FF                             ld      hl,$FFFF                    ; .
 221+ 60DA                                      SetCarryFlag                        ; and carry set
 221+ 60DA 37          >                        scf
 222+ 60DB C9                                   ret
 223+ 60DC
 224+ 60DC
 225+ 60DC              ; AHL = EHL / DBC  Lead Sign bit; CDE = remainder carry clear, divide by 0 gives AHL $FFFFFF, carry set
 226+ 60DC 7B           AHLequEHLdivDBC:        ld      a,e                         ; divide is simpler as same signs is always positive
 227+ 60DD AA                                   xor     d                           ; opposite is always negative
 228+ 60DE E6 80                                and     $80                         ; .
 229+ 60E0 F5           .SaveSign:              push    af                          ; save a to the stack that will now hold 0 or $80,
 230+ 60E1 CB BB        .ClearSignBits:         res     7,e
 231+ 60E3 CB BA                                res     7,d
 232+ 60E5 7A           .CheckDivideByZero:     ld      a,d
 233+ 60E6 B0                                   or      b
 234+ 60E7 B1                                   or      c
 235+ 60E8 28 E8                                jr      z,DivideByZero
 236+ 60EA                                      ;DEBUG jp      Perform_24x24   ; forece 24 bit
 237+ 60EA              ; Now determine the scale down, e.g. can we do smaller divides than just 24x24
 238+ 60EA              ; Patterns              24x24 OK                         1C
 239+ 60EA              ;                       24x16 OK                         1E
 240+ 60EA              ;                       24x8  OK                         1F
 241+ 60EA              ;                       16x24 0                          1I
 242+ 60EA              ;                       16x16 OK                         1J
 243+ 60EA              ;                       16x8  OK                         1L
 244+ 60EA              ;                       8x24  0                          1N
 245+ 60EA              ;                       8x16  0                          1N
 246+ 60EA              ;                       8x8   OK                         1O
 247+ 60EA              ; flow is               check if its 24 / ?              1A
 248+ 60EA              ;                       Y > test 24/24                   1B
 249+ 60EA              ;                           Y > Perform 24x24            1C
 250+ 60EA              ;                           N > Check   24x16            1D
 251+ 60EA              ;                               Y > Perform 24x16        1E
 252+ 60EA              ;                               N > Perform 24x8         1F
 253+ 60EA              ;                       N > test 16/ ?                   1G
 254+ 60EA              ;                           Y > Check 16/24              1H
 255+ 60EA              ;                               Y > Result 0             1I
 256+ 60EA              ;                               N > Check 16/16          1J
 257+ 60EA              ;                                   Y > Perform 16/16    1K
 258+ 60EA              ;                                   N > Perform 16/8     1L
 259+ 60EA              ;                           N > Check 08/24 or 08/16     1M
 260+ 60EA              ;                               Y > Result is 0          1N
 261+ 60EA              ;                               N > Perform 8/8          1O
 262+ 60EA 1C           .ValidDivide:           inc     e
 263+ 60EB 1D                                   dec     e
 264+ 60EC 20 1E                                jr      nz,Try_24xAnything         ; its at least ehl / something
 265+ 60EE 24           .Test_16x:              inc     h
 266+ 60EF 25                                   dec     h
 267+ 60F0 20 0D                                jr      nz, .Try_16xAnything        ; its at least hl / something
 268+ 60F2 14           .Try_8xAnything:        inc     d
 269+ 60F3 15                                   dec     d
 270+ 60F4 C2 CB 60                             jp      nz, ResultIsZero            ; its l / dbc which is always zero
 271+ 60F7 05                                   dec     b
 272+ 60F8 04                                   inc     b
 273+ 60F9 C2 CB 60                             jp      nz, ResultIsZero            ; its l / bc which is always zero
 274+ 60FC C3 56 64                             jp      Perform_8x8
 274+ 60FF                               ; its l/b
 275+ 60FF 14           .Try_16xAnything:       inc     d
 276+ 6100 15                                   dec     d
 277+ 6101 C2 CB 60                             jp      nz, ResultIsZero            ; its hl / dbc which is always zero
 278+ 6104 05                                   dec     b
 279+ 6105 04                                   inc     b
 280+ 6106 C2 96 63                             jp      nz, Perform_16x16           ; its hl/bc
 281+ 6109 C3 E5 63                             jp      Perform_16x8                ; so it must be hl/c
 282+ 610C              ;--------------------------------------------------------------------------------------------------
 283+ 610C              ; Div 24x24 iteration
 284+ 610C
 285+ 610C              ;--------------------------------------------------------------------------------------------------
 286+ 610C              ; AHL = EHL/DBC, EHL > DBC both >= 01 00 00
 287+ 610C                  DISPLAY "24x24 Actual internal result currently is 0L.D so need to rationalise it to AHL"
 288+ 610C                  DISPLAY "Working on one 24x24 only"
 289+ 610C                  DISPLAY "In effect 24x24 where E and D are both > 0 means e/d"
 290+ 610C              Try_24xAnything:        ;inc     d
 291+ 610C                                      ;dec     d
 292+ 610C                                      ;jp      nz,Perform_24x24           ; if d was not zero then its ehl/dbc
 293+ 610C                                      ;ld      a,b
 294+ 610C                                      ;and     $80
 295+ 610C                                      ;dec     b
 296+ 610C                                      ;inc     b
 297+ 610C                                      ;jp      z,Perform_24x8              ; if b was zero then its ehl/00c
 298+ 610C                                      ;jp      Perform_24x16               ; else it leaves us with ehl/0bc
 299+ 610C              ; {er
 300+ 610C 7B           Perform_24x24:          ld      a,e                         ; EHL => HLE  AHL
 301+ 610D 5D                                   ld      e,l                         ;             AHE
 302+ 610E 6C                                   ld      l,h                         ;             ALE
 303+ 610F 67                                   ld      h,a                         ;             HLE
 304+ 6110 AF                                   xor     a                           ;             A = 0 Celar carry flag
 305+ 6111              .eliminateLeadingZeros:
 306+ 6111 CB 13        .loop_00:               rl e                                ; HLE << 1
 307+ 6113 ED 6A                                adc hl,hl                           ;
 308+ 6115 38 36                                jr c, .loop_10                      ; if HLE bit 7 was set prior to shift goto loop_10  HLE was %1XXXXXXX XXXXXXXX XXXXXXX
 309+ 6117 CB 13                                rl e                                ; (HLE << 1) + 1
 310+ 6119 1C                                   inc e                               ;
 311+ 611A ED 6A                                adc hl,hl                           ;
 312+ 611C 38 3B                                jr c, .loop_20                      ; if HLE bit 6 was set prior to shift goto loop_20  HLE was %01XXXXXX XXXXXXXX XXXXXXX
 313+ 611E CB 13                                rl e                                ; (HLE << 1) + 1
 314+ 6120 1C                                   inc e                               ;
 315+ 6121 ED 6A                                adc hl,hl                           ;
 316+ 6123 38 40                                jr c, .loop_30                      ; if HLE bit 5 was set prior to shift goto loop_30  HLE was %001XXXXX XXXXXXXX XXXXXXX
 317+ 6125 CB 13                                rl e                                ; (HLE << 1) + 1
 318+ 6127 1C                                   inc e                               ;
 319+ 6128 ED 6A                                adc hl,hl                           ;
 320+ 612A 38 45                                jr c, .loop_40                      ; if HLE bit 4 was set prior to shift goto loop_40  HLE was %0001XXXX XXXXXXXX XXXXXXX
 321+ 612C CB 13                                rl e                                ; (HLE << 1) + 1
 322+ 612E 1C                                   inc e                               ;
 323+ 612F ED 6A                                adc hl,hl                           ;
 324+ 6131 38 4A                                jr c, .loop_50                      ; if HLE bit 3 was set prior to shift goto loop_50  HLE was %00001XXX XXXXXXXX XXXXXXX
 325+ 6133 CB 13                                rl e                                ; (HLE << 1) + 1
 326+ 6135 1C                                   inc e                               ;
 327+ 6136 ED 6A                                adc hl,hl                           ;
 328+ 6138 38 4F                                jr c, .loop_60                      ; if HLE bit 2 was set prior to shift goto loop_50  HLE was %000001XX XXXXXXXX XXXXXXX
 329+ 613A CB 13                                rl e                                ; (HLE << 1) + 1
 330+ 613C 1C                                   inc e                               ;
 331+ 613D ED 6A                                adc hl,hl                           ;
 332+ 613F 38 54                                jr c, .loop_70                      ; if HLE bit 1 was set prior to shift goto loop_50  HLE was %0000001X XXXXXXXX XXXXXXX
 333+ 6141 37                                   scf                                 ; set carry and jump to loop 7 as bit 0 of HLE must have been set
 334+ 6142 CB 13                                rl e                                ; (HLE << 1) + 1
 335+ 6144 1C                                   inc e                               ;
 336+ 6145 ED 6A                                adc hl,hl                           ;
 337+ 6147 38 58                                jr c, .loop_80                      ; if HLE bit 0 was set prior to shift goto loop_50  HLE was %0000001X XXXXXXXX XXXXXXX
 338+ 6149 37                                   scf                                 ; set carry and jump to loop 7 as bit 0 of HLE must have been set
 339+ 614A C3 9D 61                             jp .loop_7
 340+ 614D 17           .loop_10:               rla                                 ; A = A *2 + carry from  HLE * 2 (on first pass A = 0)
 341+ 614E ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
 342+ 6150 9A                                   sbc a,d                             ;
 343+ 6151 30 02                                jr nc, .loop_1                      ; if AHL is negative
 344+ 6153 09                                   add hl,bc                           ;   revert AHL back to prior value
 345+ 6154 8A                                   adc a,d                             ;   .
 346+ 6155 CB 13        .loop_1:                rl e                                ; else
 347+ 6157 ED 6A                                adc hl,hl                           ;   HLE = HLE * 2
 348+ 6159 17           .loop_20:               rla                                 ; A = carry from  HLE * 2
 349+ 615A ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
 350+ 615C 9A                                   sbc a,d                             ;
 351+ 615D 30 02                                jr nc, .loop_2                       ; if AHL is negative
 352+ 615F 09                                   add hl,bc                           ;   revert AHL back to prior value
 353+ 6160 8A                                   adc a,d                             ;   .
 354+ 6161 CB 13        .loop_2:                rl e                                ; else
 355+ 6163 ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
 356+ 6165 17           .loop_30:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
 357+ 6166 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
 358+ 6168 9A                                   sbc a,d                             ;
 359+ 6169 30 02                                jr nc, .loop_3                       ; if AHL is negative
 360+ 616B 09                                   add hl,bc                           ;   revert AHL back to prior value
 361+ 616C 8A                                   adc a,d                             ;   .
 362+ 616D CB 13        .loop_3:                rl e                                ; else
 363+ 616F ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
 364+ 6171 17           .loop_40:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
 365+ 6172 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
 366+ 6174 9A                                   sbc a,d                             ;
 367+ 6175 30 02                                jr nc, .loop_4                       ; if AHL is negative
 368+ 6177 09                                   add hl,bc                           ;   revert AHL back to prior value
 369+ 6178 8A                                   adc a,d                             ;   .
 370+ 6179 CB 13        .loop_4:                rl e                                ; else
 371+ 617B ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
 372+ 617D 17           .loop_50:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
 373+ 617E ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
 374+ 6180 9A                                   sbc a,d                             ;
 375+ 6181 30 02                                jr nc, .loop_5                       ; if AHL is negative
 376+ 6183 09                                   add hl,bc                           ;   revert AHL back to prior value
 377+ 6184 8A                                   adc a,d                             ;   .
 378+ 6185 CB 13        .loop_5:                rl e                                ; else
 379+ 6187 ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
 380+ 6189 17           .loop_60:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
 381+ 618A ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
 382+ 618C 9A                                   sbc a,d                             ;
 383+ 618D 30 02                                jr nc, .loop_6                       ; if AHL is negative
 384+ 618F 09                                   add hl,bc                           ;   revert AHL back to prior value
 385+ 6190 8A                                   adc a,d                             ;   .
 386+ 6191 CB 13        .loop_6:                rl e                                ; else
 387+ 6193 ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
 388+ 6195 17           .loop_70:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
 389+ 6196 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
 390+ 6198 9A                                   sbc a,d                             ;
 391+ 6199 30 02                                jr nc, .loop_7                       ; if AHL is negative
 392+ 619B 09                                   add hl,bc                           ;   revert AHL back to prior value
 393+ 619C 8A                                   adc a,d                             ;   .
 394+ 619D CB 13        .loop_7:                rl e                                ; else
 395+ 619F ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
 396+ 61A1 17           .loop_80:               rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
 397+ 61A2 ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
 398+ 61A4 9A                                   sbc a,d                             ;
 399+ 61A5 30 02                                jr nc, .loop_8                       ; if AHL is negative
 400+ 61A7 09                                   add hl,bc                           ;   revert AHL back to prior value
 401+ 61A8 8A                                   adc a,d                             ;   .
 402+ 61A9 CB 13        .loop_8:                rl e                                ; else
 403+ 61AB ED 6A                                adc hl,hl                           ;   AHL = HLE = HLE * 2
 404+ 61AD
 405+ 61AD
 406+ 61AD
 407+ 61AD 17                                   rla                                 ;   . (also AHL = HLE = HLE * 2 from entry point above if skipping lead zeros)
 408+ 61AE ED 42                                sbc hl,bc                           ; AHL = AHL - DBC
 409+ 61B0 9A                                   sbc a,d                             ;
 410+ 61B1 30 02                                jr nc, .exit_loop                    ; if AHL is negative
 411+ 61B3 09                                   add hl,bc                           ;   revert AHL back to prior value
 412+ 61B4 8A                                   adc a,d                             ;   .
 413+ 61B5              ; quotient  = ~e[hl'] remainder =  ahl  one more shift left on quotient
 414+ 61B5 EB           .exit_loop:             ex de,hl                            ; ADE = AHL  HL = DE
 415+ 61B6 4F                                   ld c,a                              ; CDE = ADE
 416+ 61B7 7D                                   ld a,l                              ; L = (L*2) * -1 (as we reach here via jr nc then carry is 0
 417+ 61B8 17                                   rla                                 ; .
 418+ 61B9 2F                                   cpl                                 ; .
 419+ 61BA 6F                                   ld l,a                              ; .
 420+ 61BB AF                                   xor a                               ; h = 0
 421+ 61BC 67                                   ld h,a
 422+ 61BD C3 92 63                             jp      HandleSign
 423+ 61C0              ;-----------------------------------------------------------------------------------------------------
 424+ 61C0              ; AHL = HLE/BC, where A is always 0 return EHL > DBC EHL >= 01 00 00 DBC >= 00 01 00
 425+ 61C0              ; inside loop computation is ehl / c  hl = remainder
 426+ 61C0 50           Perform_24x16:          ld      d,b                         ; HLE/BC => HLE/DC
 427+ 61C1 7B                                   ld      a,e                         ;           HLA/DC
 428+ 61C2 59                                   ld      e,c                         ;           HLA/DE
 429+ 61C3 4D                                   ld      c,l                         ;           HCA/DE
 430+ 61C4 6F                                   ld      l,a                         ;           HCL/DE
 431+ 61C5 7C                                   ld      a,h                         ;           ACL/DE
 432+ 61C6 26 00                                ld      h,0                         ;           ACL/DE
 433+ 61C8 06 02                                ld      b,2                         ;           ACB/DE (B = 2)
 434+ 61CA CB 11        .eliminateLeadingZeros: rl c
 435+ 61CC 17                                   rla
 436+ 61CD ED 6A                                adc hl,hl
 437+ 61CF 24                                   inc h
 438+ 61D0 25                                   dec h
 439+ 61D1 20 47                                jr nz, .loop_00
 440+ 61D3 CB 11                                rl c
 441+ 61D5 0C                                   inc c
 442+ 61D6 17                                   rla
 443+ 61D7 ED 6A                                adc hl,hl
 444+ 61D9 24                                   inc h
 445+ 61DA 25                                   dec h
 446+ 61DB 20 49                                jr nz, .loop_11
 447+ 61DD CB 11                                rl c
 448+ 61DF 0C                                   inc c
 449+ 61E0 17                                   rla
 450+ 61E1 ED 6A                                adc hl,hl
 451+ 61E3 24                                   inc h
 452+ 61E4 25                                   dec h
 453+ 61E5 20 4B                                jr nz, .loop_22
 454+ 61E7 CB 11                                rl c
 455+ 61E9 0C                                   inc c
 456+ 61EA 17                                   rla
 457+ 61EB ED 6A                                adc hl,hl
 458+ 61ED 24                                   inc h
 459+ 61EE 25                                   dec h
 460+ 61EF 20 4D                                jr nz, .loop_33
 461+ 61F1 CB 11                                rl c
 462+ 61F3 0C                                   inc c
 463+ 61F4 17                                   rla
 464+ 61F5 ED 6A                                adc hl,hl
 465+ 61F7 24                                   inc h
 466+ 61F8 25                                   dec h
 467+ 61F9 20 4F                                jr nz, .loop_44
 468+ 61FB CB 11                                rl c
 469+ 61FD 0C                                   inc c
 470+ 61FE 17                                   rla
 471+ 61FF ED 6A                                adc hl,hl
 472+ 6201 24                                   inc h
 473+ 6202 25                                   dec h
 474+ 6203 20 51                                jr nz, .loop_55
 475+ 6205 CB 11                                rl c
 476+ 6207 0C                                   inc c
 477+ 6208 17                                   rla
 478+ 6209 ED 6A                                adc hl,hl
 479+ 620B 24                                   inc h
 480+ 620C 25                                   dec h
 481+ 620D 20 53                                jr nz, .loop_66
 482+ 620F 37                                   scf
 483+ 6210 C3 67 62                             jp .loop_7
 484+ 6213 CB 11        .loop_0:                rl c
 485+ 6215 17                                   rla
 486+ 6216 ED 6A                                adc hl,hl
 487+ 6218 38 68                                jr c, .loop_000
 488+ 621A ED 52        .loop_00:               sbc hl,de
 489+ 621C 30 01                                jr nc, .loop_1
 490+ 621E 19                                   add hl,de
 491+ 621F CB 11        .loop_1:                rl c
 492+ 6221 17                                   rla
 493+ 6222 ED 6A                                adc hl,hl
 494+ 6224 38 63                                jr c, .loop_111
 495+ 6226 ED 52        .loop_11:               sbc hl,de
 496+ 6228 30 01                                jr nc, .loop_2
 497+ 622A 19                                   add hl,de
 498+ 622B CB 11        .loop_2:                rl c
 499+ 622D 17                                   rla
 500+ 622E ED 6A                                adc hl,hl
 501+ 6230 38 5E                                jr c, .loop_222
 502+ 6232 ED 52        .loop_22:               sbc hl,de
 503+ 6234 30 01                                jr nc, .loop_3
 504+ 6236 19                                   add hl,de
 505+ 6237 CB 11        .loop_3:                rl c
 506+ 6239 17                                   rla
 507+ 623A ED 6A                                adc hl,hl
 508+ 623C 38 59                                jr c, .loop_333
 509+ 623E ED 52        .loop_33:               sbc hl,de
 510+ 6240 30 01                                jr nc, .loop_4
 511+ 6242 19                                   add hl,de
 512+ 6243 CB 11        .loop_4:                rl c
 513+ 6245 17                                   rla
 514+ 6246 ED 6A                                adc hl,hl
 515+ 6248 38 54                                jr c, .loop_444
 516+ 624A ED 52        .loop_44:               sbc hl,de
 517+ 624C 30 01                                jr nc, .loop_5
 518+ 624E 19                                   add hl,de
 519+ 624F CB 11        .loop_5:                rl c
 520+ 6251 17                                   rla
 521+ 6252 ED 6A                                adc hl,hl
 522+ 6254 38 4F                                jr c, .loop_555
 523+ 6256 ED 52        .loop_55:               sbc hl,de
 524+ 6258 30 01                                jr nc, .loop_6
 525+ 625A 19                                   add hl,de
 526+ 625B CB 11        .loop_6:                rl c
 527+ 625D 17                                   rla
 528+ 625E ED 6A                                adc hl,hl
 529+ 6260 38 4A                                jr c, .loop_666
 530+ 6262 ED 52        .loop_66:               sbc hl,de
 531+ 6264 30 01                                jr nc, .loop_7
 532+ 6266 19                                   add hl,de
 533+ 6267 CB 11        .loop_7:                rl c
 534+ 6269 17                                   rla
 535+ 626A ED 6A                                adc hl,hl
 536+ 626C 38 45                                jr c, .loop_777
 537+ 626E ED 52        .loop_77:               sbc hl,de
 538+ 6270 30 01                                jr nc, .loop_8
 539+ 6272 19                                   add hl,de
 540+ 6273 10 9E        .loop_8:                djnz .loop_0
 541+ 6275 CB 11        .exit_loop:             rl c
 542+ 6277 17                                   rla
 543+ 6278                                      ; ac = ~quotient, hl = remainder
 544+ 6278 EB                                   ex de,hl
 545+ 6279 2F                                   cpl
 546+ 627A 67                                   ld h,a
 547+ 627B 79                                   ld a,c
 548+ 627C 2F                                   cpl
 549+ 627D 6F                                   ld l,a
 550+ 627E AF                                   xor a
 551+ 627F C3 92 63                             jp      HandleSign
 552+ 6282 B7           .loop_000:              or a
 553+ 6283 ED 52                                sbc hl,de
 554+ 6285 B7                                   or a
 555+ 6286 C3 1F 62                             jp .loop_1
 556+ 6289 B7           .loop_111:              or a
 557+ 628A ED 52                                sbc hl,de
 558+ 628C B7                                   or a
 559+ 628D C3 2B 62                             jp .loop_2
 560+ 6290 B7           .loop_222:              or a
 561+ 6291 ED 52                                sbc hl,de
 562+ 6293 B7                                   or a
 563+ 6294 C3 37 62                             jp .loop_3
 564+ 6297 B7           .loop_333:              or a
 565+ 6298 ED 52                                sbc hl,de
 566+ 629A B7                                   or a
 567+ 629B C3 43 62                             jp .loop_4
 568+ 629E B7           .loop_444:              or a
 569+ 629F ED 52                                sbc hl,de
 570+ 62A1 B7                                   or a
 571+ 62A2 C3 4F 62                             jp .loop_5
 572+ 62A5 B7           .loop_555:              or a
 573+ 62A6 ED 52                                sbc hl,de
 574+ 62A8 B7                                   or a
 575+ 62A9 C3 5B 62                             jp .loop_6
 576+ 62AC B7           .loop_666:              or a
 577+ 62AD ED 52                                sbc hl,de
 578+ 62AF B7                                   or a
 579+ 62B0 C3 67 62                             jp .loop_7
 580+ 62B3 B7           .loop_777:              or a
 581+ 62B4 ED 52                                sbc hl,de
 582+ 62B6 B7                                   or a
 583+ 62B7 C3 73 62                             jp .loop_8
 584+ 62BA              ;-----------------------------------------------------------------------------------------------------
 585+ 62BA              ; AHL = HLE/BC, where A is always 0 return EHL > DBC EHL >= 01 00 00 DBC >= 00 00 01
 586+ 62BA              ; inside loop computation is abc/de, hl = remainder
 587+ 62BA              ; EHL: = EHL/C
 588+ 62BA              ;so currerntly thsi can't hadnle c > 127 so need to understand lead sign at lower bit levels on c
 589+ 62BA              ;so could just do 24 bit and process lead zeros in h and hope that is enough? or have a special case
 590+ 62BA              ;for collapsing lead zeros in dbc too
 591+ 62BA 79           Perform_24x8:           ld      a,c
 592+ 62BB E6 80                                and     $80
 593+ 62BD CA E6 62                             jp      z,Perform_24x7
 594+ 62C0 DD 26 18                             ld      ixh,24              ; from ehl/c to ABC/E
 595+ 62C3 7B                                   ld      a,e
 596+ 62C4 44                                   ld      b,h
 597+ 62C5 51                                   ld      d,c
 598+ 62C6 4D                                   ld      c,l
 599+ 62C7 5A                                   ld      e,d
 600+ 62C8 16 00                                ld      d,0
 601+ 62CA 21 00 00                             ld      hl,0                ;
 602+ 62CD                                      ; with c being 8 bit we need to do
 603+ 62CD CB 21        .loop1:                 sla     c                   ; unroll 24 times
 604+ 62CF CB 10                                rl      b                   ; ...
 605+ 62D1 17                                   rla                         ; ...
 606+ 62D2 ED 6A                                adc     hl,hl               ; ...
 607+ 62D4 ED 52                                sbc     hl,de               ; ...
 608+ 62D6 30 02                                jr      nc,.Skip1           ; ...
 609+ 62D8 19                                   add     hl,de               ; ...
 610+ 62D9 0D                                   dec     c                   ; ...
 611+ 62DA DD 25        .Skip1:                 dec     ixh
 612+ 62DC FD 00                                break
 613+ 62DE C2 CD 62                             jp      nz,.loop1
 614+ 62E1 FD 00                                break
 615+ 62E3 C3 92 63                             jp      HandleSign
 616+ 62E6 06 18        Perform_24x7:           ld b,24
 617+ 62E8 AF                                   xor a
 618+ 62E9 29           .loop1:                 add hl,hl
 619+ 62EA CB 13                                rl e
 620+ 62EC 17                                   rla
 621+ 62ED                                      ;rl d
 622+ 62ED                                      ;rla
 623+ 62ED B9                                   cp c
 624+ 62EE 38 02                                jr c, .Skip1
 625+ 62F0 91                                   sub c
 626+ 62F1 2C                                   inc l
 627+ 62F2 10 F5        .Skip1:                 djnz .loop1
 628+ 62F4 FD 00                                break
 629+ 62F6 C3 92 63                             jp      HandleSign
 630+ 62F9
 631+ 62F9                 ;   a = remainder
 632+ 62F9                 ; ehl = quotient
 633+ 62F9
 634+ 62F9 4F              ld c,a
 635+ 62FA 7B              ld a,e
 636+ 62FB 59              ld e,c
 637+ 62FC 50              ld d,b
 638+ 62FD
 639+ 62FD B7              or a
 640+ 62FE C9              ret
 641+ 62FF
 642+ 62FF
 643+ 62FF              ;.slow32x8:              ld      d,h ; do dehl / c
 644+ 62FF              ;                        ld      e,l
 645+ 62FF              ;                        ld      h,e
 646+ 62FF              ;                        ld      l,0
 647+ 62FF              ;                        xor     a
 648+ 62FF              ;.looping:               ld b,2
 649+ 62FF              ;.loop_11:               add hl,hl
 650+ 62FF              ;                        rl e
 651+ 62FF              ;                        rl d
 652+ 62FF              ;.loop_01:               rla
 653+ 62FF              ;                        jr c, .loop_02
 654+ 62FF              ;                        cp c
 655+ 62FF              ;                        jr c, .loop_03
 656+ 62FF              ;.loop_02:               sub c
 657+ 62FF              ;                        inc l
 658+ 62FF              ;.loop_03:               djnz .loop_11
 659+ 62FF B7                                   or a
 660+ 6300              ; result dehl = 32-bit quotient
 661+ 6300              ;.slow:                  ld      b,24
 662+ 6300              ;.loop_11:               add     hl,hl
 663+ 6300              ;                        rl      e
 664+ 6300              ;.loop_01:               rla
 665+ 6300              ;                        jr      c, .loop_02
 666+ 6300              ;                        cp      c
 667+ 6300              ;                        jr      c, .loop_03
 668+ 6300              ;.loop_02:               sub 01010c
 669+ 6300              ;                        inc 01010l
 670+ 6300              ;.loop_03:               djnz .loop_11
 671+ 6300              ;                        ld c,a
 672+ 6300              ;                        ld a,e
 673+ 6300              ;                        ld e,c
 674+ 6300              ;                        ld d,b
 675+ 6300              ;                        or a
 676+ 6300 C3 92 63                             jp      HandleSign
 677+ 6303
 678+ 6303 AF           DEBUG:                        xor     a                           ;             A = 0 Clear carry flag
 679+ 6304 06 03                                ld b,3
 680+ 6306              .eliminateLeadingZeros:
 681+ 6306 29           .loop_00:               add hl,hl
 682+ 6307 CB 13                                rl e
 683+ 6309 38 2B                                jr c, .loop_10
 684+ 630B 29                                   add hl,hl
 685+ 630C CB 13                                rl e
 686+ 630E 38 31                                jr c, .loop_20
 687+ 6310 29                                   add hl,hl
 688+ 6311 CB 13                                rl e
 689+ 6313 38 37                                jr c, .loop_30
 690+ 6315 29                                   add hl,hl
 691+ 6316 CB 13                                rl e
 692+ 6318 38 3D                                jr c, .loop_40
 693+ 631A 29                                   add hl,hl
 694+ 631B CB 13                                rl e
 695+ 631D 38 43                                jr c, .loop_50
 696+ 631F 29                                   add hl,hl
 697+ 6320 CB 13                                rl e
 698+ 6322 38 49                                jr c, .loop_60
 699+ 6324 29                                   add hl,hl
 700+ 6325 CB 13                                rl e
 701+ 6327 38 4F                                jr c, .loop_70
 702+ 6329 29                                   add hl,hl
 703+ 632A CB 13                                rl e
 704+ 632C 17                                   rla
 705+ 632D B9                                   cp c
 706+ 632E 38 02                                jr c, .loop_80
 707+ 6330 91                                   sub c
 708+ 6331 2C                                   inc l
 709+ 6332 05           .loop_80:               dec b
 710+ 6333                 ; general divide loop
 711+ 6333 29           .loop_0:                add     hl,hl
 712+ 6334 CB 13                                rl      e
 713+ 6336 17           .loop_10:               rla
 714+ 6337 38 03                                jr      c, .loop_101
 715+ 6339 B9                                   cp      c
 716+ 633A 38 02                                jr      c, .loop_1
 717+ 633C 91           .loop_101:              sub     c
 718+ 633D 2C                                   inc     l
 719+ 633E 29           .loop_1:                add     hl,hl
 720+ 633F CB 13                                rl      e
 721+ 6341 17           .loop_20:               rla
 722+ 6342 38 03                                jr      c, .loop_201
 723+ 6344 B9                                   cp      c
 724+ 6345 38 02                                jr      c, .loop_2
 725+ 6347 91           .loop_201:              sub     c
 726+ 6348 2C                                   inc     l
 727+ 6349 29           .loop_2:                add     hl,hl
 728+ 634A CB 13                                rl      e
 729+ 634C 17           .loop_30:               rla
 730+ 634D 38 03                                jr      c, .loop_301
 731+ 634F B9                                   cp      c
 732+ 6350 38 02                                jr      c, .loop_3
 733+ 6352 91           .loop_301:              sub     c
 734+ 6353 2C                                   inc     l
 735+ 6354 29           .loop_3:                add     hl,hl
 736+ 6355 CB 13                                rl      e
 737+ 6357 17           .loop_40:               rla
 738+ 6358 38 03                                jr      c, .loop_401
 739+ 635A B9                                   cp      c
 740+ 635B 38 02                                jr      c, .loop_4
 741+ 635D 91           .loop_401:              sub     c
 742+ 635E 2C                                   inc     l
 743+ 635F 29           .loop_4:                add     hl,hl
 744+ 6360 CB 13                                rl      e
 745+ 6362 17           .loop_50:               rla
 746+ 6363 38 03                                jr      c, .loop_501
 747+ 6365 B9                                   cp      c
 748+ 6366 38 02                                jr      c, .loop_5
 749+ 6368 91           .loop_501:              sub     c
 750+ 6369 2C                                   inc     l
 751+ 636A 29           .loop_5:                add     hl,hl
 752+ 636B CB 13                                rl      e
 753+ 636D 17           .loop_60:               rla
 754+ 636E 38 03                                jr      c, .loop_601
 755+ 6370 B9                                   cp      c
 756+ 6371 38 02                                jr      c, .loop_6
 757+ 6373 91           .loop_601:              sub     c
 758+ 6374 2C                                   inc     l
 759+ 6375 29           .loop_6:                add     hl,hl
 760+ 6376 CB 13                                rl      e
 761+ 6378 17           .loop_70:               rla
 762+ 6379 38 03                                jr      c, .loop_701
 763+ 637B B9                                   cp      c
 764+ 637C 38 02                                jr      c, .loop_7
 765+ 637E 91           .loop_701:              sub     c
 766+ 637F 2C                                   inc     l
 767+ 6380 29           .loop_7:                add     hl,hl
 768+ 6381 CB 13                                rl      e
 769+ 6383 17                                   rla
 770+ 6384 38 03                                jr      c, .loop_801
 771+ 6386 B9                                   cp      c
 772+ 6387 38 02                                jr      c, .loop_8
 773+ 6389 91           .loop_801:              sub     c
 774+ 638A 2C                                   inc     l
 775+ 638B 10 A6        .loop_8:                djnz    .loop_0
 776+ 638D 4F           .exit_loop:             ld      c,a
 777+ 638E 7B                                   ld      a,e
 778+ 638F 59                                   ld      e,c
 779+ 6390 50                                   ld      d,b
 780+ 6391 B7                                   or      a
 781+ 6392 47           HandleSign:             ld      b,a ; save the a value      ; now deal with prior sign
 782+ 6393 F1                                   pop     af
 783+ 6394 B0                                   or      b                           ; now a holds saved sign and b result so now lead sign S15.8
 784+ 6395 C9                                   ret
 785+ 6396              ;-----------------------------------------------------------------------------------------------------
 786+ 6396              ; AHL = HL/BC, EHL > DBC both >= 00 01 00
 787+ 6396 50 59        Perform_16x16:          ld      de,bc                       ; get to AHL= 0HL/0BC
 788+ 6398 7D                                   ld      a,l                         ;hl >= $1000 de >= $1000 so max quotient is 255
 789+ 6399 6C                                   ld      l,h                         ; which means the loop computation is a[c] / de hl = remainder
 790+ 639A 26 00                                ld      h,0                         ; so we can initialise as if 8 iterations are done
 791+ 639C              ; unrolling divide 8 time, eliminating leading zeros is only marginal gain
 792+ 639C 17           .loop_0:                rla
 793+ 639D ED 6A                                adc     hl,hl
 794+ 639F ED 52        .loop_00:               sbc     hl,de
 795+ 63A1 30 01                                jr      nc, .loop_1
 796+ 63A3 19                                   add     hl,de
 797+ 63A4 17           .loop_1:                rla
 798+ 63A5 ED 6A                                adc     hl,hl
 799+ 63A7 ED 52        .loop_11:               sbc     hl,de
 800+ 63A9 30 01                                jr      nc, .loop_2
 801+ 63AB 19                                   add     hl,de
 802+ 63AC 17           .loop_2:                rla
 803+ 63AD ED 6A                                adc     hl,hl
 804+ 63AF ED 52        .loop_22:               sbc     hl,de
 805+ 63B1 30 01                                jr      nc, .loop_3
 806+ 63B3 19                                   add     hl,de
 807+ 63B4 17           .loop_3:                rla
 808+ 63B5 ED 6A                                adc     hl,hl
 809+ 63B7 ED 52        .loop_33:               sbc     hl,de
 810+ 63B9 30 01                                jr      nc, .loop_4
 811+ 63BB 19                                   add     hl,de
 812+ 63BC 17           .loop_4:                rla
 813+ 63BD ED 6A                                adc     hl,hl
 814+ 63BF ED 52        .loop_44:               sbc     hl,de
 815+ 63C1 30 01                                jr      nc, .loop_5
 816+ 63C3 19                                   add     hl,de
 817+ 63C4              .loop_5:
 818+ 63C4 17                                   rla
 819+ 63C5 ED 6A                                adc     hl,hl
 820+ 63C7              .loop_55:
 821+ 63C7 ED 52                                sbc     hl,de
 822+ 63C9 30 01                                jr      nc, .loop_6
 823+ 63CB 19                                   add     hl,de
 824+ 63CC              .loop_6:
 825+ 63CC 17                                   rla
 826+ 63CD ED 6A                                adc     hl,hl
 827+ 63CF              .loop_66:
 828+ 63CF ED 52                                sbc     hl,de
 829+ 63D1 30 01                                jr      nc, .loop_7
 830+ 63D3 19                                   add     hl,de
 831+ 63D4              .loop_7:
 832+ 63D4 17                                   rla
 833+ 63D5 ED 6A                                adc     hl,hl
 834+ 63D7 ED 52        .loop_77:               sbc     hl,de
 835+ 63D9 30 01                                jr      nc, .exit_loop
 836+ 63DB 19                                   add     hl,de
 837+ 63DC 17           .exit_loop:             rla                ; a = ~quotient, hl = remainder
 838+ 63DD 2F                                   cpl
 839+ 63DE 5F                                   ld      e,a
 840+ 63DF AF                                   xor     a
 841+ 63E0 57                                   ld      d,a
 842+ 63E1 EB                                   ex      de,hl
 843+ 63E2 C3 92 63                             jp      HandleSign
 844+ 63E5              ;-----------------------------------------------------------------------------------------------------
 845+ 63E5              ; AHL = HL/C, where A is always 0 return EHL > DBC both >= 00 01 00, internally does HL/E
 846+ 63E5 59           Perform_16x8:           ld      e,c                          ; get to AHL= 0HL/00C
 847+ 63E6 AF                                   xor a
 848+ 63E7 57                                   ld      d,a
 849+ 63E8 06 02                                ld      b,2
 850+ 63EA 29           .loop_00:               add     hl,hl                       ; eliminate leading zeroes
 851+ 63EB 38 1B                                jr      c, .loop_10
 852+ 63ED 29                                   add     hl,hl
 853+ 63EE 38 21                                jr      c, .loop_20
 854+ 63F0 29                                   add     hl,hl
 855+ 63F1 38 27                                jr      c, .loop_30
 856+ 63F3 29                                   add     hl,hl
 857+ 63F4 38 2D                                jr      c, .loop_40
 858+ 63F6 29                                   add     hl,hl
 859+ 63F7 38 33                                jr      c, .loop_50
 860+ 63F9 29                                   add     hl,hl
 861+ 63FA 38 39                                jr      c, .loop_60
 862+ 63FC 29                                   add     hl,hl
 863+ 63FD 38 3F                                jr      c, .loop_70
 864+ 63FF 29                                   add     hl,hl
 865+ 6400 17                                   rla
 866+ 6401 BB                                   cp      e
 867+ 6402 38 02                                jr      c, .loop_80
 868+ 6404 93                                   sub     e
 869+ 6405 2C                                   inc     l
 870+ 6406 05           .loop_80:               dec     b
 871+ 6407 29           .loop_0:                add     hl,hl
 872+ 6408 17           .loop_10:               rla
 873+ 6409 38 03                                jr      c, .loop_101
 874+ 640B BB                                   cp      e
 875+ 640C 38 02                                jr      c, .loop_1
 876+ 640E 93           .loop_101:              sub     e
 877+ 640F 2C                                   inc     l
 878+ 6410 29           .loop_1:                add     hl,hl
 879+ 6411 17           .loop_20:               rla
 880+ 6412 38 03                                jr      c, .loop_201
 881+ 6414 BB                                   cp      e
 882+ 6415 38 02                                jr      c, .loop_2
 883+ 6417 93           .loop_201:              sub     e
 884+ 6418 2C                                   inc     l
 885+ 6419 29           .loop_2:                add     hl,hl
 886+ 641A 17           .loop_30:               rla
 887+ 641B 38 03                                jr      c, .loop_301
 888+ 641D BB                                   cp      e
 889+ 641E 38 02                                jr      c, .loop_3
 890+ 6420 93           .loop_301:              sub     e
 891+ 6421 2C                                   inc     l
 892+ 6422 29           .loop_3:                add     hl,hl
 893+ 6423 17           .loop_40:               rla
 894+ 6424 38 03                                jr      c, .loop_401
 895+ 6426 BB                                   cp      e
 896+ 6427 38 02                                jr      c, .loop_4
 897+ 6429 93           .loop_401:              sub     e
 898+ 642A 2C                                   inc     l
 899+ 642B 29           .loop_4:                add     hl,hl
 900+ 642C 17           .loop_50:               rla
 901+ 642D 38 03                                jr      c, .loop_501
 902+ 642F BB                                   cp      e
 903+ 6430 38 02                                jr      c, .loop_5
 904+ 6432 93           .loop_501:               sub     e
 905+ 6433 2C                                   inc     l
 906+ 6434 29           .loop_5:                 add     hl,hl
 907+ 6435 17           .loop_60:                rla
 908+ 6436 38 03                                jr      c, .loop_601
 909+ 6438 BB                                   cp      e
 910+ 6439 38 02                                jr      c, .loop_6
 911+ 643B 93           .loop_601:               sub     e
 912+ 643C 2C                                   inc     l
 913+ 643D 29           .loop_6:                 add     hl,hl
 914+ 643E 17           .loop_70:                rla
 915+ 643F 38 03                                jr      c, .loop_701
 916+ 6441 BB                                   cp      e
 917+ 6442 38 02                                jr      c, .loop_7
 918+ 6444 93           .loop_701:               sub     e
 919+ 6445 2C                                   inc     l
 920+ 6446 29           .loop_7:                 add     hl,hl
 921+ 6447 17                                   rla
 922+ 6448 38 03                                jr      c, .loop_801
 923+ 644A BB                                   cp      e
 924+ 644B 38 02                                jr      c, .loop_8
 925+ 644D 93           .loop_801:               sub     e
 926+ 644E 2C                                   inc     l
 927+ 644F 10 B6        .loop_8:                 djnz    .loop_0
 928+ 6451              .exit_loop:              ;AHL = quotient CDE = remainder
 929+ 6451 5F                                   ld e,a
 930+ 6452 AF                                   xor a
 931+ 6453 C3 92 63                             jp      HandleSign
 932+ 6456              ;-----------------------------------------------------------------------------------------------------
 933+ 6456              ; AHL = L/C, where A is always 0 return EHL > DBC both >= 00 01 00, internally does L/E
 934+ 6456 AF           Perform_8x8:            xor     a
 935+ 6457 57                                   ld      d,a
 936+ 6458 67                                   ld      h,a
 937+ 6459 59                                   ld      e,c
 938+ 645A CB 25        .loop_00:               sla     l
 939+ 645C 38 1B                                jr      c, .loop_10
 940+ 645E CB 25                                sla     l
 941+ 6460 38 1F                                jr      c, .loop_20
 942+ 6462 CB 25                                sla     l
 943+ 6464 38 23                                jr      c, .loop_30
 944+ 6466 CB 25                                sla     l
 945+ 6468 38 27                                jr      c, .loop_40
 946+ 646A CB 25                                sla     l
 947+ 646C 38 2B                                jr      c, .loop_50
 948+ 646E CB 25                                sla     l
 949+ 6470 38 2F                                jr      c, .loop_60
 950+ 6472 CB 25                                sla     l
 951+ 6474 38 33                                jr      c, .loop_70
 952+ 6476 C3 AF 64                             jp      .loop_17
 953+ 6479 17           .loop_10:               rla
 954+ 647A BB                                   cp      e
 955+ 647B 38 02                                jr      c, .loop_11
 956+ 647D 93                                   sub     e
 957+ 647E 2C                                   inc     l
 958+ 647F CB 25        .loop_11:               sla     l
 959+ 6481 17           .loop_20:               rla
 960+ 6482 BB                                   cp      e
 961+ 6483 38 02                                jr      c, .loop_12
 962+ 6485 93                                   sub     e
 963+ 6486 2C                                   inc     l
 964+ 6487 CB 25        .loop_12:               sla     l
 965+ 6489 17           .loop_30:               rla
 966+ 648A BB                                   cp      e
 967+ 648B 38 02                                jr      c, .loop_13
 968+ 648D 93                                   sub     e
 969+ 648E 2C                                   inc     l
 970+ 648F CB 25        .loop_13:               sla     l
 971+ 6491 17           .loop_40:               rla
 972+ 6492 BB                                   cp      e
 973+ 6493 38 02                                jr      c, .loop_14
 974+ 6495 93                                   sub     e
 975+ 6496 2C                                   inc     l
 976+ 6497 CB 25        .loop_14:               sla     l
 977+ 6499 17           .loop_50:               rla
 978+ 649A BB                                   cp      e
 979+ 649B 38 02                                jr      c, .loop_15
 980+ 649D 93                                   sub     e
 981+ 649E 2C                                   inc     l
 982+ 649F CB 25        .loop_15:               sla     l
 983+ 64A1 17           .loop_60:               rla
 984+ 64A2 BB                                   cp      e
 985+ 64A3 38 02                                jr      c, .loop_16
 986+ 64A5 93                                   sub     e
 987+ 64A6 2C                                   inc     l
 988+ 64A7 CB 25        .loop_16:               sla     l
 989+ 64A9 17           .loop_70:               rla
 990+ 64AA BB                                   cp      e
 991+ 64AB 38 02                                jr      c, .loop_17
 992+ 64AD 93                                   sub     e
 993+ 64AE 2C                                   inc     l
 994+ 64AF CB 25        .loop_17:               sla     l
 995+ 64B1 17                                   rla
 996+ 64B2 BB                                   cp      e
 997+ 64B3 38 02                                jr      c, .exit_loop
 998+ 64B5 93                                   sub     e
 999+ 64B6 2C                                   inc     l
1000+ 64B7              .exit_loop:
1001+ 64B7                                      ; a = remainder
1002+ 64B7                                      ; l = quotient
1003+ 64B7 5F                                   ld      e,a
1004+ 64B8 AF                                   xor     a
1005+ 64B9 C3 92 63                             jp      HandleSign
1006+ 64BC
1007+ 64BC              ;
1008+ 64BC              ; AHL = 24bit at IX + 24 bit at IY
1009+ 64BC
1010+ 64BC              ; AHL = 24bit at IX - 24 bit at IY
1011+ 64BC
1012+ 64BC              ; BAHL = 24bit at IX * 24 bit at IY  Lead Sign bit
1013+ 64BC
1014+ 64BC              ; AHL = 24bit at IX / 24 bit at IY  Lead Sign bit
1015+ 64BC
# file closed: asm_addition24.asm
 131  64BC                  INCLUDE	"../../Maths24/asm_divide24.asm"
# file opened: asm_divide24.asm
   1+ 64BC              ; unsigned division dehl = dehl / dehl' dehl' = remainder carry clear,  div  by 0 = carry set everyhthing else untouched
   2+ 64BC
   3+ 64BC              ; ahl  = EHL/DBC CARRY OVERFLOW FLAG
   4+ 64BC              ; dehl = dehl / dehjl'
   5+ 64BC
   6+ 64BC              divu32smallloop         MACRO
   7+ 64BC ~
   8+ 64BC ~                                    exx
   9+ 64BC ~                                    rl      c                 ; bcbc << 1
  10+ 64BC ~                                    rl      b
  11+ 64BC ~                                    exx
  12+ 64BC ~                                    rl      c
  13+ 64BC ~                                    rla
  14+ 64BC ~
  15+ 64BC ~                                    exx
  16+ 64BC ~                                    adc     hl,hl            ; hlhl << 1
  17+ 64BC ~                                    exx
  18+ 64BC ~                                    adc     hl,hl
  19+ 64BC ~
  20+ 64BC ~                                    exx
  21+ 64BC ~                                    sbc     hl,de            ; if hlhl > dede
  22+ 64BC ~                                    exx
  23+ 64BC ~                                    sbc     hl,de
  24+ 64BC ~                                    jr nc,  .skip_loop        ;   hlhl -= dede
  25+ 64BC ~
  26+ 64BC ~                                    exx                  ;
  27+ 64BC ~                                    add     hl,de
  28+ 64BC ~                                    exx
  29+ 64BC ~                                    adc     hl,de
  30+ 64BC ~            .skip_loop:             ccf
  31+ 64BC                                      ENDM
  32+ 64BC
  33+ 64BC
  34+ 64BC              ;INPUTS: ahl = dividend cde = divisor
  35+ 64BC              ;OUTPUTS: cde = quotient ahl = remainder
  36+ 64BC              ;  = AHL/CDE
  37+ 64BC                  DISPLAY "Needs ficxing for proper S15.8 result"
  38+ 64BC 47           divs24:                 ld      b,a             ; preserve dividend sign
  39+ 64BD A9                                   xor     c               ; now a holds sign bit
  40+ 64BE E6 80                                and     $80             ;
  41+ 64C0 08                                   ex      af,af'          ; save sign bit
  42+ 64C1 CB B8                                res     7,b             ; now force an ABS divide
  43+ 64C3 CB B9                                res     7,c
  44+ 64C5 C5 D5                                push    bc,,de          ; save divisor
  45+ 64C7 50           .prepdivisor:           ld      d,b             ; prep DEHL'
  46+ 64C8 5C                                   ld      e,h             ; which trashes divisor
  47+ 64C9 65                                   ld      h,l             ; .
  48+ 64CA 2E 00                                ld      l,0             ; .
  49+ 64CC D9                                   exx                     ; now save it over into dehl;
  50+ 64CD E1 D1                                pop     de,,hl          ; force 0cde into dehl
  51+ 64CF 16 00                                ld      d,0
  52+ 64D1 CD E7 64                             call    divu32          ; bcde.hl = dehl' / dehl
  53+ 64D4 08                                   ex      af,af'          ; get sign back
  54+ 64D5 B2                                   or      d               ; set de.h to signed divide
  55+ 64D6 C9                                   ret
  56+ 64D7
  57+ 64D7 D9           divs32swap:             exx                     ;
  58+ 64D8              ; dehl = dehl' / dehl in our case it will be S78.0/ 0S78.0 to give us 0S78.0
  59+ 64D8 7B           divs32:                 ld      a,e             ; get sign bit from divisor
  60+ 64D9 D9                                   exx                     ; swap to get dividend sign bit
  61+ 64DA AA                                   xor     d               ; .
  62+ 64DB D9                                   exx                     ; then swap back for normal compute
  63+ 64DC E6 80                                and     $80             ; but we can then save sign bit to stack
  64+ 64DE F5                                   push    af              ; .
  65+ 64DF CD E7 64                             call    divu32          ; perform divide
  66+ 64E2 F1                                   pop     af              ; get sign bit
  67+ 64E3 B3                                   or      e               ; as result will be in ehl that we want
  68+ 64E4 5F                                   ld      e,a             ; we ignore d reg
  69+ 64E5 C9                                   ret
  70+ 64E6
  71+ 64E6 D9           divu32swap:             exx
  72+ 64E7              ; dehl = dehl' / dehl in our case it will be 78.80 / 078.8 to give us 078.8
  73+ 64E7 7A           divu32:                 ld a,d
  74+ 64E8 B3                                   or e
  75+ 64E9 B4                                   or h
  76+ 64EA B5                                   or l
  77+ 64EB CA AF 68                             jp z, divide_by_zero
  78+ 64EE                 ; try to reduce the division
  79+ 64EE              begin:
  80+ 64EE AF                                   xor     a
  81+ 64EF E5                                   push    hl
  82+ 64F0 D9                                   exx
  83+ 64F1 44 4D                                ld      bc,hl
  84+ 64F3 E1                                   pop     hl
  85+ 64F4 D5                                   push    de
  86+ 64F5 EB                                   ex      de,hl
  87+ 64F6 6F                                   ld      l,a
  88+ 64F7 67                                   ld      h,a
  89+ 64F8 D9                                   exx
  90+ 64F9 C1                                   pop     bc
  91+ 64FA 6F                                   ld      l,a
  92+ 64FB 67                                   ld      h,a
  93+ 64FC
  94+ 64FC              l1_small_divu_32_32x32: ; dede' = 32-bit divisor, bcbc' = 32-bit dividend, hlhl' = 0
  95+ 64FC 78                                   ld      a,b
  96+ 64FD             > divu32smallloop
  96+ 64FD             >
  96+ 64FD D9          >                        exx
  96+ 64FE CB 11       >                        rl      c                 ; bcbc << 1
  96+ 6500 CB 10       >                        rl      b
  96+ 6502 D9          >                        exx
  96+ 6503 CB 11       >                        rl      c
  96+ 6505 17          >                        rla
  96+ 6506             >
  96+ 6506 D9          >                        exx
  96+ 6507 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 6509 D9          >                        exx
  96+ 650A ED 6A       >                        adc     hl,hl
  96+ 650C             >
  96+ 650C D9          >                        exx
  96+ 650D ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 650F D9          >                        exx
  96+ 6510 ED 52       >                        sbc     hl,de
  96+ 6512 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 6514             >
  96+ 6514 D9          >                        exx                  ;
  96+ 6515 19          >                        add     hl,de
  96+ 6516 D9          >                        exx
  96+ 6517 ED 5A       >                        adc     hl,de
  96+ 6519 3F          >.skip_loop:             ccf
  96+ 651A             > divu32smallloop
  96+ 651A             >
  96+ 651A D9          >                        exx
  96+ 651B CB 11       >                        rl      c                 ; bcbc << 1
  96+ 651D CB 10       >                        rl      b
  96+ 651F D9          >                        exx
  96+ 6520 CB 11       >                        rl      c
  96+ 6522 17          >                        rla
  96+ 6523             >
  96+ 6523 D9          >                        exx
  96+ 6524 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 6526 D9          >                        exx
  96+ 6527 ED 6A       >                        adc     hl,hl
  96+ 6529             >
  96+ 6529 D9          >                        exx
  96+ 652A ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 652C D9          >                        exx
  96+ 652D ED 52       >                        sbc     hl,de
  96+ 652F 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 6531             >
  96+ 6531 D9          >                        exx                  ;
  96+ 6532 19          >                        add     hl,de
  96+ 6533 D9          >                        exx
  96+ 6534 ED 5A       >                        adc     hl,de
  96+ 6536 3F          >.skip_loop:             ccf
  96+ 6537             > divu32smallloop
  96+ 6537             >
  96+ 6537 D9          >                        exx
  96+ 6538 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 653A CB 10       >                        rl      b
  96+ 653C D9          >                        exx
  96+ 653D CB 11       >                        rl      c
  96+ 653F 17          >                        rla
  96+ 6540             >
  96+ 6540 D9          >                        exx
  96+ 6541 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 6543 D9          >                        exx
  96+ 6544 ED 6A       >                        adc     hl,hl
  96+ 6546             >
  96+ 6546 D9          >                        exx
  96+ 6547 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 6549 D9          >                        exx
  96+ 654A ED 52       >                        sbc     hl,de
  96+ 654C 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 654E             >
  96+ 654E D9          >                        exx                  ;
  96+ 654F 19          >                        add     hl,de
  96+ 6550 D9          >                        exx
  96+ 6551 ED 5A       >                        adc     hl,de
  96+ 6553 3F          >.skip_loop:             ccf
  96+ 6554             > divu32smallloop
  96+ 6554             >
  96+ 6554 D9          >                        exx
  96+ 6555 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 6557 CB 10       >                        rl      b
  96+ 6559 D9          >                        exx
  96+ 655A CB 11       >                        rl      c
  96+ 655C 17          >                        rla
  96+ 655D             >
  96+ 655D D9          >                        exx
  96+ 655E ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 6560 D9          >                        exx
  96+ 6561 ED 6A       >                        adc     hl,hl
  96+ 6563             >
  96+ 6563 D9          >                        exx
  96+ 6564 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 6566 D9          >                        exx
  96+ 6567 ED 52       >                        sbc     hl,de
  96+ 6569 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 656B             >
  96+ 656B D9          >                        exx                  ;
  96+ 656C 19          >                        add     hl,de
  96+ 656D D9          >                        exx
  96+ 656E ED 5A       >                        adc     hl,de
  96+ 6570 3F          >.skip_loop:             ccf
  96+ 6571             > divu32smallloop
  96+ 6571             >
  96+ 6571 D9          >                        exx
  96+ 6572 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 6574 CB 10       >                        rl      b
  96+ 6576 D9          >                        exx
  96+ 6577 CB 11       >                        rl      c
  96+ 6579 17          >                        rla
  96+ 657A             >
  96+ 657A D9          >                        exx
  96+ 657B ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 657D D9          >                        exx
  96+ 657E ED 6A       >                        adc     hl,hl
  96+ 6580             >
  96+ 6580 D9          >                        exx
  96+ 6581 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 6583 D9          >                        exx
  96+ 6584 ED 52       >                        sbc     hl,de
  96+ 6586 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 6588             >
  96+ 6588 D9          >                        exx                  ;
  96+ 6589 19          >                        add     hl,de
  96+ 658A D9          >                        exx
  96+ 658B ED 5A       >                        adc     hl,de
  96+ 658D 3F          >.skip_loop:             ccf
  96+ 658E             > divu32smallloop
  96+ 658E             >
  96+ 658E D9          >                        exx
  96+ 658F CB 11       >                        rl      c                 ; bcbc << 1
  96+ 6591 CB 10       >                        rl      b
  96+ 6593 D9          >                        exx
  96+ 6594 CB 11       >                        rl      c
  96+ 6596 17          >                        rla
  96+ 6597             >
  96+ 6597 D9          >                        exx
  96+ 6598 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 659A D9          >                        exx
  96+ 659B ED 6A       >                        adc     hl,hl
  96+ 659D             >
  96+ 659D D9          >                        exx
  96+ 659E ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 65A0 D9          >                        exx
  96+ 65A1 ED 52       >                        sbc     hl,de
  96+ 65A3 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 65A5             >
  96+ 65A5 D9          >                        exx                  ;
  96+ 65A6 19          >                        add     hl,de
  96+ 65A7 D9          >                        exx
  96+ 65A8 ED 5A       >                        adc     hl,de
  96+ 65AA 3F          >.skip_loop:             ccf
  96+ 65AB             > divu32smallloop
  96+ 65AB             >
  96+ 65AB D9          >                        exx
  96+ 65AC CB 11       >                        rl      c                 ; bcbc << 1
  96+ 65AE CB 10       >                        rl      b
  96+ 65B0 D9          >                        exx
  96+ 65B1 CB 11       >                        rl      c
  96+ 65B3 17          >                        rla
  96+ 65B4             >
  96+ 65B4 D9          >                        exx
  96+ 65B5 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 65B7 D9          >                        exx
  96+ 65B8 ED 6A       >                        adc     hl,hl
  96+ 65BA             >
  96+ 65BA D9          >                        exx
  96+ 65BB ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 65BD D9          >                        exx
  96+ 65BE ED 52       >                        sbc     hl,de
  96+ 65C0 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 65C2             >
  96+ 65C2 D9          >                        exx                  ;
  96+ 65C3 19          >                        add     hl,de
  96+ 65C4 D9          >                        exx
  96+ 65C5 ED 5A       >                        adc     hl,de
  96+ 65C7 3F          >.skip_loop:             ccf
  96+ 65C8             > divu32smallloop
  96+ 65C8             >
  96+ 65C8 D9          >                        exx
  96+ 65C9 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 65CB CB 10       >                        rl      b
  96+ 65CD D9          >                        exx
  96+ 65CE CB 11       >                        rl      c
  96+ 65D0 17          >                        rla
  96+ 65D1             >
  96+ 65D1 D9          >                        exx
  96+ 65D2 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 65D4 D9          >                        exx
  96+ 65D5 ED 6A       >                        adc     hl,hl
  96+ 65D7             >
  96+ 65D7 D9          >                        exx
  96+ 65D8 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 65DA D9          >                        exx
  96+ 65DB ED 52       >                        sbc     hl,de
  96+ 65DD 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 65DF             >
  96+ 65DF D9          >                        exx                  ;
  96+ 65E0 19          >                        add     hl,de
  96+ 65E1 D9          >                        exx
  96+ 65E2 ED 5A       >                        adc     hl,de
  96+ 65E4 3F          >.skip_loop:             ccf
  96+ 65E5             > divu32smallloop
  96+ 65E5             >
  96+ 65E5 D9          >                        exx
  96+ 65E6 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 65E8 CB 10       >                        rl      b
  96+ 65EA D9          >                        exx
  96+ 65EB CB 11       >                        rl      c
  96+ 65ED 17          >                        rla
  96+ 65EE             >
  96+ 65EE D9          >                        exx
  96+ 65EF ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 65F1 D9          >                        exx
  96+ 65F2 ED 6A       >                        adc     hl,hl
  96+ 65F4             >
  96+ 65F4 D9          >                        exx
  96+ 65F5 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 65F7 D9          >                        exx
  96+ 65F8 ED 52       >                        sbc     hl,de
  96+ 65FA 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 65FC             >
  96+ 65FC D9          >                        exx                  ;
  96+ 65FD 19          >                        add     hl,de
  96+ 65FE D9          >                        exx
  96+ 65FF ED 5A       >                        adc     hl,de
  96+ 6601 3F          >.skip_loop:             ccf
  96+ 6602             > divu32smallloop
  96+ 6602             >
  96+ 6602 D9          >                        exx
  96+ 6603 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 6605 CB 10       >                        rl      b
  96+ 6607 D9          >                        exx
  96+ 6608 CB 11       >                        rl      c
  96+ 660A 17          >                        rla
  96+ 660B             >
  96+ 660B D9          >                        exx
  96+ 660C ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 660E D9          >                        exx
  96+ 660F ED 6A       >                        adc     hl,hl
  96+ 6611             >
  96+ 6611 D9          >                        exx
  96+ 6612 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 6614 D9          >                        exx
  96+ 6615 ED 52       >                        sbc     hl,de
  96+ 6617 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 6619             >
  96+ 6619 D9          >                        exx                  ;
  96+ 661A 19          >                        add     hl,de
  96+ 661B D9          >                        exx
  96+ 661C ED 5A       >                        adc     hl,de
  96+ 661E 3F          >.skip_loop:             ccf
  96+ 661F             > divu32smallloop
  96+ 661F             >
  96+ 661F D9          >                        exx
  96+ 6620 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 6622 CB 10       >                        rl      b
  96+ 6624 D9          >                        exx
  96+ 6625 CB 11       >                        rl      c
  96+ 6627 17          >                        rla
  96+ 6628             >
  96+ 6628 D9          >                        exx
  96+ 6629 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 662B D9          >                        exx
  96+ 662C ED 6A       >                        adc     hl,hl
  96+ 662E             >
  96+ 662E D9          >                        exx
  96+ 662F ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 6631 D9          >                        exx
  96+ 6632 ED 52       >                        sbc     hl,de
  96+ 6634 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 6636             >
  96+ 6636 D9          >                        exx                  ;
  96+ 6637 19          >                        add     hl,de
  96+ 6638 D9          >                        exx
  96+ 6639 ED 5A       >                        adc     hl,de
  96+ 663B 3F          >.skip_loop:             ccf
  96+ 663C             > divu32smallloop
  96+ 663C             >
  96+ 663C D9          >                        exx
  96+ 663D CB 11       >                        rl      c                 ; bcbc << 1
  96+ 663F CB 10       >                        rl      b
  96+ 6641 D9          >                        exx
  96+ 6642 CB 11       >                        rl      c
  96+ 6644 17          >                        rla
  96+ 6645             >
  96+ 6645 D9          >                        exx
  96+ 6646 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 6648 D9          >                        exx
  96+ 6649 ED 6A       >                        adc     hl,hl
  96+ 664B             >
  96+ 664B D9          >                        exx
  96+ 664C ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 664E D9          >                        exx
  96+ 664F ED 52       >                        sbc     hl,de
  96+ 6651 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 6653             >
  96+ 6653 D9          >                        exx                  ;
  96+ 6654 19          >                        add     hl,de
  96+ 6655 D9          >                        exx
  96+ 6656 ED 5A       >                        adc     hl,de
  96+ 6658 3F          >.skip_loop:             ccf
  96+ 6659             > divu32smallloop
  96+ 6659             >
  96+ 6659 D9          >                        exx
  96+ 665A CB 11       >                        rl      c                 ; bcbc << 1
  96+ 665C CB 10       >                        rl      b
  96+ 665E D9          >                        exx
  96+ 665F CB 11       >                        rl      c
  96+ 6661 17          >                        rla
  96+ 6662             >
  96+ 6662 D9          >                        exx
  96+ 6663 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 6665 D9          >                        exx
  96+ 6666 ED 6A       >                        adc     hl,hl
  96+ 6668             >
  96+ 6668 D9          >                        exx
  96+ 6669 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 666B D9          >                        exx
  96+ 666C ED 52       >                        sbc     hl,de
  96+ 666E 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 6670             >
  96+ 6670 D9          >                        exx                  ;
  96+ 6671 19          >                        add     hl,de
  96+ 6672 D9          >                        exx
  96+ 6673 ED 5A       >                        adc     hl,de
  96+ 6675 3F          >.skip_loop:             ccf
  96+ 6676             > divu32smallloop
  96+ 6676             >
  96+ 6676 D9          >                        exx
  96+ 6677 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 6679 CB 10       >                        rl      b
  96+ 667B D9          >                        exx
  96+ 667C CB 11       >                        rl      c
  96+ 667E 17          >                        rla
  96+ 667F             >
  96+ 667F D9          >                        exx
  96+ 6680 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 6682 D9          >                        exx
  96+ 6683 ED 6A       >                        adc     hl,hl
  96+ 6685             >
  96+ 6685 D9          >                        exx
  96+ 6686 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 6688 D9          >                        exx
  96+ 6689 ED 52       >                        sbc     hl,de
  96+ 668B 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 668D             >
  96+ 668D D9          >                        exx                  ;
  96+ 668E 19          >                        add     hl,de
  96+ 668F D9          >                        exx
  96+ 6690 ED 5A       >                        adc     hl,de
  96+ 6692 3F          >.skip_loop:             ccf
  96+ 6693             > divu32smallloop
  96+ 6693             >
  96+ 6693 D9          >                        exx
  96+ 6694 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 6696 CB 10       >                        rl      b
  96+ 6698 D9          >                        exx
  96+ 6699 CB 11       >                        rl      c
  96+ 669B 17          >                        rla
  96+ 669C             >
  96+ 669C D9          >                        exx
  96+ 669D ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 669F D9          >                        exx
  96+ 66A0 ED 6A       >                        adc     hl,hl
  96+ 66A2             >
  96+ 66A2 D9          >                        exx
  96+ 66A3 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 66A5 D9          >                        exx
  96+ 66A6 ED 52       >                        sbc     hl,de
  96+ 66A8 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 66AA             >
  96+ 66AA D9          >                        exx                  ;
  96+ 66AB 19          >                        add     hl,de
  96+ 66AC D9          >                        exx
  96+ 66AD ED 5A       >                        adc     hl,de
  96+ 66AF 3F          >.skip_loop:             ccf
  96+ 66B0             > divu32smallloop
  96+ 66B0             >
  96+ 66B0 D9          >                        exx
  96+ 66B1 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 66B3 CB 10       >                        rl      b
  96+ 66B5 D9          >                        exx
  96+ 66B6 CB 11       >                        rl      c
  96+ 66B8 17          >                        rla
  96+ 66B9             >
  96+ 66B9 D9          >                        exx
  96+ 66BA ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 66BC D9          >                        exx
  96+ 66BD ED 6A       >                        adc     hl,hl
  96+ 66BF             >
  96+ 66BF D9          >                        exx
  96+ 66C0 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 66C2 D9          >                        exx
  96+ 66C3 ED 52       >                        sbc     hl,de
  96+ 66C5 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 66C7             >
  96+ 66C7 D9          >                        exx                  ;
  96+ 66C8 19          >                        add     hl,de
  96+ 66C9 D9          >                        exx
  96+ 66CA ED 5A       >                        adc     hl,de
  96+ 66CC 3F          >.skip_loop:             ccf
  96+ 66CD             > divu32smallloop
  96+ 66CD             >
  96+ 66CD D9          >                        exx
  96+ 66CE CB 11       >                        rl      c                 ; bcbc << 1
  96+ 66D0 CB 10       >                        rl      b
  96+ 66D2 D9          >                        exx
  96+ 66D3 CB 11       >                        rl      c
  96+ 66D5 17          >                        rla
  96+ 66D6             >
  96+ 66D6 D9          >                        exx
  96+ 66D7 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 66D9 D9          >                        exx
  96+ 66DA ED 6A       >                        adc     hl,hl
  96+ 66DC             >
  96+ 66DC D9          >                        exx
  96+ 66DD ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 66DF D9          >                        exx
  96+ 66E0 ED 52       >                        sbc     hl,de
  96+ 66E2 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 66E4             >
  96+ 66E4 D9          >                        exx                  ;
  96+ 66E5 19          >                        add     hl,de
  96+ 66E6 D9          >                        exx
  96+ 66E7 ED 5A       >                        adc     hl,de
  96+ 66E9 3F          >.skip_loop:             ccf
  96+ 66EA             > divu32smallloop
  96+ 66EA             >
  96+ 66EA D9          >                        exx
  96+ 66EB CB 11       >                        rl      c                 ; bcbc << 1
  96+ 66ED CB 10       >                        rl      b
  96+ 66EF D9          >                        exx
  96+ 66F0 CB 11       >                        rl      c
  96+ 66F2 17          >                        rla
  96+ 66F3             >
  96+ 66F3 D9          >                        exx
  96+ 66F4 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 66F6 D9          >                        exx
  96+ 66F7 ED 6A       >                        adc     hl,hl
  96+ 66F9             >
  96+ 66F9 D9          >                        exx
  96+ 66FA ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 66FC D9          >                        exx
  96+ 66FD ED 52       >                        sbc     hl,de
  96+ 66FF 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 6701             >
  96+ 6701 D9          >                        exx                  ;
  96+ 6702 19          >                        add     hl,de
  96+ 6703 D9          >                        exx
  96+ 6704 ED 5A       >                        adc     hl,de
  96+ 6706 3F          >.skip_loop:             ccf
  96+ 6707             > divu32smallloop
  96+ 6707             >
  96+ 6707 D9          >                        exx
  96+ 6708 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 670A CB 10       >                        rl      b
  96+ 670C D9          >                        exx
  96+ 670D CB 11       >                        rl      c
  96+ 670F 17          >                        rla
  96+ 6710             >
  96+ 6710 D9          >                        exx
  96+ 6711 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 6713 D9          >                        exx
  96+ 6714 ED 6A       >                        adc     hl,hl
  96+ 6716             >
  96+ 6716 D9          >                        exx
  96+ 6717 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 6719 D9          >                        exx
  96+ 671A ED 52       >                        sbc     hl,de
  96+ 671C 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 671E             >
  96+ 671E D9          >                        exx                  ;
  96+ 671F 19          >                        add     hl,de
  96+ 6720 D9          >                        exx
  96+ 6721 ED 5A       >                        adc     hl,de
  96+ 6723 3F          >.skip_loop:             ccf
  96+ 6724             > divu32smallloop
  96+ 6724             >
  96+ 6724 D9          >                        exx
  96+ 6725 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 6727 CB 10       >                        rl      b
  96+ 6729 D9          >                        exx
  96+ 672A CB 11       >                        rl      c
  96+ 672C 17          >                        rla
  96+ 672D             >
  96+ 672D D9          >                        exx
  96+ 672E ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 6730 D9          >                        exx
  96+ 6731 ED 6A       >                        adc     hl,hl
  96+ 6733             >
  96+ 6733 D9          >                        exx
  96+ 6734 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 6736 D9          >                        exx
  96+ 6737 ED 52       >                        sbc     hl,de
  96+ 6739 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 673B             >
  96+ 673B D9          >                        exx                  ;
  96+ 673C 19          >                        add     hl,de
  96+ 673D D9          >                        exx
  96+ 673E ED 5A       >                        adc     hl,de
  96+ 6740 3F          >.skip_loop:             ccf
  96+ 6741             > divu32smallloop
  96+ 6741             >
  96+ 6741 D9          >                        exx
  96+ 6742 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 6744 CB 10       >                        rl      b
  96+ 6746 D9          >                        exx
  96+ 6747 CB 11       >                        rl      c
  96+ 6749 17          >                        rla
  96+ 674A             >
  96+ 674A D9          >                        exx
  96+ 674B ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 674D D9          >                        exx
  96+ 674E ED 6A       >                        adc     hl,hl
  96+ 6750             >
  96+ 6750 D9          >                        exx
  96+ 6751 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 6753 D9          >                        exx
  96+ 6754 ED 52       >                        sbc     hl,de
  96+ 6756 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 6758             >
  96+ 6758 D9          >                        exx                  ;
  96+ 6759 19          >                        add     hl,de
  96+ 675A D9          >                        exx
  96+ 675B ED 5A       >                        adc     hl,de
  96+ 675D 3F          >.skip_loop:             ccf
  96+ 675E             > divu32smallloop
  96+ 675E             >
  96+ 675E D9          >                        exx
  96+ 675F CB 11       >                        rl      c                 ; bcbc << 1
  96+ 6761 CB 10       >                        rl      b
  96+ 6763 D9          >                        exx
  96+ 6764 CB 11       >                        rl      c
  96+ 6766 17          >                        rla
  96+ 6767             >
  96+ 6767 D9          >                        exx
  96+ 6768 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 676A D9          >                        exx
  96+ 676B ED 6A       >                        adc     hl,hl
  96+ 676D             >
  96+ 676D D9          >                        exx
  96+ 676E ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 6770 D9          >                        exx
  96+ 6771 ED 52       >                        sbc     hl,de
  96+ 6773 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 6775             >
  96+ 6775 D9          >                        exx                  ;
  96+ 6776 19          >                        add     hl,de
  96+ 6777 D9          >                        exx
  96+ 6778 ED 5A       >                        adc     hl,de
  96+ 677A 3F          >.skip_loop:             ccf
  96+ 677B             > divu32smallloop
  96+ 677B             >
  96+ 677B D9          >                        exx
  96+ 677C CB 11       >                        rl      c                 ; bcbc << 1
  96+ 677E CB 10       >                        rl      b
  96+ 6780 D9          >                        exx
  96+ 6781 CB 11       >                        rl      c
  96+ 6783 17          >                        rla
  96+ 6784             >
  96+ 6784 D9          >                        exx
  96+ 6785 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 6787 D9          >                        exx
  96+ 6788 ED 6A       >                        adc     hl,hl
  96+ 678A             >
  96+ 678A D9          >                        exx
  96+ 678B ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 678D D9          >                        exx
  96+ 678E ED 52       >                        sbc     hl,de
  96+ 6790 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 6792             >
  96+ 6792 D9          >                        exx                  ;
  96+ 6793 19          >                        add     hl,de
  96+ 6794 D9          >                        exx
  96+ 6795 ED 5A       >                        adc     hl,de
  96+ 6797 3F          >.skip_loop:             ccf
  96+ 6798             > divu32smallloop
  96+ 6798             >
  96+ 6798 D9          >                        exx
  96+ 6799 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 679B CB 10       >                        rl      b
  96+ 679D D9          >                        exx
  96+ 679E CB 11       >                        rl      c
  96+ 67A0 17          >                        rla
  96+ 67A1             >
  96+ 67A1 D9          >                        exx
  96+ 67A2 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 67A4 D9          >                        exx
  96+ 67A5 ED 6A       >                        adc     hl,hl
  96+ 67A7             >
  96+ 67A7 D9          >                        exx
  96+ 67A8 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 67AA D9          >                        exx
  96+ 67AB ED 52       >                        sbc     hl,de
  96+ 67AD 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 67AF             >
  96+ 67AF D9          >                        exx                  ;
  96+ 67B0 19          >                        add     hl,de
  96+ 67B1 D9          >                        exx
  96+ 67B2 ED 5A       >                        adc     hl,de
  96+ 67B4 3F          >.skip_loop:             ccf
  96+ 67B5             > divu32smallloop
  96+ 67B5             >
  96+ 67B5 D9          >                        exx
  96+ 67B6 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 67B8 CB 10       >                        rl      b
  96+ 67BA D9          >                        exx
  96+ 67BB CB 11       >                        rl      c
  96+ 67BD 17          >                        rla
  96+ 67BE             >
  96+ 67BE D9          >                        exx
  96+ 67BF ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 67C1 D9          >                        exx
  96+ 67C2 ED 6A       >                        adc     hl,hl
  96+ 67C4             >
  96+ 67C4 D9          >                        exx
  96+ 67C5 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 67C7 D9          >                        exx
  96+ 67C8 ED 52       >                        sbc     hl,de
  96+ 67CA 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 67CC             >
  96+ 67CC D9          >                        exx                  ;
  96+ 67CD 19          >                        add     hl,de
  96+ 67CE D9          >                        exx
  96+ 67CF ED 5A       >                        adc     hl,de
  96+ 67D1 3F          >.skip_loop:             ccf
  96+ 67D2             > divu32smallloop
  96+ 67D2             >
  96+ 67D2 D9          >                        exx
  96+ 67D3 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 67D5 CB 10       >                        rl      b
  96+ 67D7 D9          >                        exx
  96+ 67D8 CB 11       >                        rl      c
  96+ 67DA 17          >                        rla
  96+ 67DB             >
  96+ 67DB D9          >                        exx
  96+ 67DC ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 67DE D9          >                        exx
  96+ 67DF ED 6A       >                        adc     hl,hl
  96+ 67E1             >
  96+ 67E1 D9          >                        exx
  96+ 67E2 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 67E4 D9          >                        exx
  96+ 67E5 ED 52       >                        sbc     hl,de
  96+ 67E7 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 67E9             >
  96+ 67E9 D9          >                        exx                  ;
  96+ 67EA 19          >                        add     hl,de
  96+ 67EB D9          >                        exx
  96+ 67EC ED 5A       >                        adc     hl,de
  96+ 67EE 3F          >.skip_loop:             ccf
  96+ 67EF             > divu32smallloop
  96+ 67EF             >
  96+ 67EF D9          >                        exx
  96+ 67F0 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 67F2 CB 10       >                        rl      b
  96+ 67F4 D9          >                        exx
  96+ 67F5 CB 11       >                        rl      c
  96+ 67F7 17          >                        rla
  96+ 67F8             >
  96+ 67F8 D9          >                        exx
  96+ 67F9 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 67FB D9          >                        exx
  96+ 67FC ED 6A       >                        adc     hl,hl
  96+ 67FE             >
  96+ 67FE D9          >                        exx
  96+ 67FF ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 6801 D9          >                        exx
  96+ 6802 ED 52       >                        sbc     hl,de
  96+ 6804 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 6806             >
  96+ 6806 D9          >                        exx                  ;
  96+ 6807 19          >                        add     hl,de
  96+ 6808 D9          >                        exx
  96+ 6809 ED 5A       >                        adc     hl,de
  96+ 680B 3F          >.skip_loop:             ccf
  96+ 680C             > divu32smallloop
  96+ 680C             >
  96+ 680C D9          >                        exx
  96+ 680D CB 11       >                        rl      c                 ; bcbc << 1
  96+ 680F CB 10       >                        rl      b
  96+ 6811 D9          >                        exx
  96+ 6812 CB 11       >                        rl      c
  96+ 6814 17          >                        rla
  96+ 6815             >
  96+ 6815 D9          >                        exx
  96+ 6816 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 6818 D9          >                        exx
  96+ 6819 ED 6A       >                        adc     hl,hl
  96+ 681B             >
  96+ 681B D9          >                        exx
  96+ 681C ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 681E D9          >                        exx
  96+ 681F ED 52       >                        sbc     hl,de
  96+ 6821 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 6823             >
  96+ 6823 D9          >                        exx                  ;
  96+ 6824 19          >                        add     hl,de
  96+ 6825 D9          >                        exx
  96+ 6826 ED 5A       >                        adc     hl,de
  96+ 6828 3F          >.skip_loop:             ccf
  96+ 6829             > divu32smallloop
  96+ 6829             >
  96+ 6829 D9          >                        exx
  96+ 682A CB 11       >                        rl      c                 ; bcbc << 1
  96+ 682C CB 10       >                        rl      b
  96+ 682E D9          >                        exx
  96+ 682F CB 11       >                        rl      c
  96+ 6831 17          >                        rla
  96+ 6832             >
  96+ 6832 D9          >                        exx
  96+ 6833 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 6835 D9          >                        exx
  96+ 6836 ED 6A       >                        adc     hl,hl
  96+ 6838             >
  96+ 6838 D9          >                        exx
  96+ 6839 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 683B D9          >                        exx
  96+ 683C ED 52       >                        sbc     hl,de
  96+ 683E 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 6840             >
  96+ 6840 D9          >                        exx                  ;
  96+ 6841 19          >                        add     hl,de
  96+ 6842 D9          >                        exx
  96+ 6843 ED 5A       >                        adc     hl,de
  96+ 6845 3F          >.skip_loop:             ccf
  96+ 6846             > divu32smallloop
  96+ 6846             >
  96+ 6846 D9          >                        exx
  96+ 6847 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 6849 CB 10       >                        rl      b
  96+ 684B D9          >                        exx
  96+ 684C CB 11       >                        rl      c
  96+ 684E 17          >                        rla
  96+ 684F             >
  96+ 684F D9          >                        exx
  96+ 6850 ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 6852 D9          >                        exx
  96+ 6853 ED 6A       >                        adc     hl,hl
  96+ 6855             >
  96+ 6855 D9          >                        exx
  96+ 6856 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 6858 D9          >                        exx
  96+ 6859 ED 52       >                        sbc     hl,de
  96+ 685B 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 685D             >
  96+ 685D D9          >                        exx                  ;
  96+ 685E 19          >                        add     hl,de
  96+ 685F D9          >                        exx
  96+ 6860 ED 5A       >                        adc     hl,de
  96+ 6862 3F          >.skip_loop:             ccf
  96+ 6863             > divu32smallloop
  96+ 6863             >
  96+ 6863 D9          >                        exx
  96+ 6864 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 6866 CB 10       >                        rl      b
  96+ 6868 D9          >                        exx
  96+ 6869 CB 11       >                        rl      c
  96+ 686B 17          >                        rla
  96+ 686C             >
  96+ 686C D9          >                        exx
  96+ 686D ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 686F D9          >                        exx
  96+ 6870 ED 6A       >                        adc     hl,hl
  96+ 6872             >
  96+ 6872 D9          >                        exx
  96+ 6873 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 6875 D9          >                        exx
  96+ 6876 ED 52       >                        sbc     hl,de
  96+ 6878 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 687A             >
  96+ 687A D9          >                        exx                  ;
  96+ 687B 19          >                        add     hl,de
  96+ 687C D9          >                        exx
  96+ 687D ED 5A       >                        adc     hl,de
  96+ 687F 3F          >.skip_loop:             ccf
  96+ 6880             > divu32smallloop
  96+ 6880             >
  96+ 6880 D9          >                        exx
  96+ 6881 CB 11       >                        rl      c                 ; bcbc << 1
  96+ 6883 CB 10       >                        rl      b
  96+ 6885 D9          >                        exx
  96+ 6886 CB 11       >                        rl      c
  96+ 6888 17          >                        rla
  96+ 6889             >
  96+ 6889 D9          >                        exx
  96+ 688A ED 6A       >                        adc     hl,hl            ; hlhl << 1
  96+ 688C D9          >                        exx
  96+ 688D ED 6A       >                        adc     hl,hl
  96+ 688F             >
  96+ 688F D9          >                        exx
  96+ 6890 ED 52       >                        sbc     hl,de            ; if hlhl > dede
  96+ 6892 D9          >                        exx
  96+ 6893 ED 52       >                        sbc     hl,de
  96+ 6895 30 05       >                        jr nc,  .skip_loop        ;   hlhl -= dede
  96+ 6897             >
  96+ 6897 D9          >                        exx                  ;
  96+ 6898 19          >                        add     hl,de
  96+ 6899 D9          >                        exx
  96+ 689A ED 5A       >                        adc     hl,de
  96+ 689C 3F          >.skip_loop:             ccf
  97+ 689D
  98+ 689D D9                                   exx
  99+ 689E CB 11                                rl c
 100+ 68A0 CB 10                                rl b
 101+ 68A2 D9                                   exx
 102+ 68A3 CB 11                                rl c
 103+ 68A5 17                                   rla
 104+ 68A6
 105+ 68A6                 ; quotient  = acbc'
 106+ 68A6                 ; remainder = hlhl'
 107+ 68A6
 108+ 68A6 E5                                   push    hl
 109+ 68A7 D9                                   exx
 110+ 68A8 D1                                   pop     de
 111+ 68A9 C5                                   push    bc
 112+ 68AA D9                                   exx
 113+ 68AB E1                                   pop     hl
 114+ 68AC 59                                   ld      e,c
 115+ 68AD 57                                   ld      d,a
 116+ 68AE
 117+ 68AE C9                                   ret
 118+ 68AF
 119+ 68AF
 120+ 68AF              divide_by_zero:
 121+ 68AF
 122+ 68AF                                  SetCarryFlag
 122+ 68AF 37          >                        scf
 123+ 68B0 C9                               ret
 124+ 68B1
# file closed: asm_divide24.asm
 132  68B1                  INCLUDE	"../../Maths24/asm_divide_helpers.asm"
# file opened: asm_divide_helpers.asm
   1+ 68B1              ; BC = BC / DE
   2+ 68B1              ; HL = BC % DE
   3+ 68B1              ; if HL > 0 BC -= 1
   4+ 68B1 78           Floor_DivQ:             ld      a,b
   5+ 68B2 B1                                   or      c
   6+ 68B3 28 26                                jr      z, .divide0By   ; if bc is zero just return as result will be zero
   7+ 68B5 7A                                   ld      a,d
   8+ 68B6 B3                                   or      e
   9+ 68B7 28 26                                jr      z, .divideBy0
  10+ 68B9 D5                                   push    de
  11+ 68BA CD E6 68     .DoDivide:              call    BC_Div_DE       ; bc(q0) = bc / de , hl(r0) = bc %de
  12+ 68BD D1                                   pop     de              ; get divisor back to test
  13+ 68BE CB 7A                                bit     7,d             ; if divisor <0 or = 0 goto else branch
  14+ 68C0 C2 D0 68                             jp      nz,.deLTE0
  15+ 68C3 7A                                   ld      a,d
  16+ 68C4 B3                                   or      e
  17+ 68C5 CA D0 68                             jp      z,.deLTE0
  18+ 68C8 CB 7C        .deGT0:                 bit     7,h             ; if remainder >=0 return with no adjustment
  19+ 68CA C8                                   ret     z               ; if remainder was not negative then all done
  20+ 68CB 0B                                   dec     bc              ; else q --
  21+ 68CC                                      ClearCarryFlag          ;      r += b
  21+ 68CC B7          >                        or a
  22+ 68CD ED 5A                                adc     hl,de           ;      .
  23+ 68CF C9                                   ret
  24+ 68D0 CB 7C        .deLTE0:                bit     7,h             ; if remainder <= 0 retun with no adjustment
  25+ 68D2 C8                                   ret     z               ; (return if negative)
  26+ 68D3 7C                                   ld      a,h
  27+ 68D4 B5                                   or      l               ; (return if zero)
  28+ 68D5 C8                                   ret     z
  29+ 68D6 0B                                   dec     bc              ; else q --
  30+ 68D7                                      ClearCarryFlag          ;      r += b
  30+ 68D7 B7          >                        or a
  31+ 68D8 ED 5A                                adc     hl,de           ;      .
  32+ 68DA C9                                   ret
  33+ 68DB 21 00 00     .divide0By:             ld      hl,0            ; hl = 0, bc is already 0
  34+ 68DE C9                                   ret
  35+ 68DF 21 00 00     .divideBy0:             ld      hl,0
  36+ 68E2 01 01 00                             ld      bc,1
  37+ 68E5 C9                                   ret
  38+ 68E6              ; BC = BC/DE (ceheck this is correctg wording)
  39+ 68E6              BCDIVDE_Iteration:      MACRO
  40+ 68E6 ~                                    rla
  41+ 68E6 ~                                    adc	    hl,hl
  42+ 68E6 ~                                    add	    hl,de
  43+ 68E6 ~                                    jr	    c,1F
  44+ 68E6 ~                                    sbc	    hl,de
  45+ 68E6 ~            1:
  46+ 68E6                                      ENDM
  47+ 68E6
  48+ 68E6 AF           BC_Div_DE:              xor a
  49+ 68E7 67                                   ld h,a
  50+ 68E8 6F                                   ld l,a
  51+ 68E9 93                                   sub e
  52+ 68EA 5F                                   ld e,a
  53+ 68EB 9F                                   sbc a,a
  54+ 68EC 92                                   sub d
  55+ 68ED 57                                   ld d,a
  56+ 68EE 78                                   ld a,b
  57+ 68EF                                      BCDIVDE_Iteration
  57+ 68EF 17          >                        rla
  57+ 68F0 ED 6A       >                        adc	    hl,hl
  57+ 68F2 19          >                        add	    hl,de
  57+ 68F3 38 02       >                        jr	    c,1F
  57+ 68F5 ED 52       >                        sbc	    hl,de
  57+ 68F7             >1:
  58+ 68F7                                      BCDIVDE_Iteration
  58+ 68F7 17          >                        rla
  58+ 68F8 ED 6A       >                        adc	    hl,hl
  58+ 68FA 19          >                        add	    hl,de
  58+ 68FB 38 02       >                        jr	    c,1F
  58+ 68FD ED 52       >                        sbc	    hl,de
  58+ 68FF             >1:
  59+ 68FF                                      BCDIVDE_Iteration
  59+ 68FF 17          >                        rla
  59+ 6900 ED 6A       >                        adc	    hl,hl
  59+ 6902 19          >                        add	    hl,de
  59+ 6903 38 02       >                        jr	    c,1F
  59+ 6905 ED 52       >                        sbc	    hl,de
  59+ 6907             >1:
  60+ 6907                                      BCDIVDE_Iteration
  60+ 6907 17          >                        rla
  60+ 6908 ED 6A       >                        adc	    hl,hl
  60+ 690A 19          >                        add	    hl,de
  60+ 690B 38 02       >                        jr	    c,1F
  60+ 690D ED 52       >                        sbc	    hl,de
  60+ 690F             >1:
  61+ 690F                                      BCDIVDE_Iteration
  61+ 690F 17          >                        rla
  61+ 6910 ED 6A       >                        adc	    hl,hl
  61+ 6912 19          >                        add	    hl,de
  61+ 6913 38 02       >                        jr	    c,1F
  61+ 6915 ED 52       >                        sbc	    hl,de
  61+ 6917             >1:
  62+ 6917                                      BCDIVDE_Iteration
  62+ 6917 17          >                        rla
  62+ 6918 ED 6A       >                        adc	    hl,hl
  62+ 691A 19          >                        add	    hl,de
  62+ 691B 38 02       >                        jr	    c,1F
  62+ 691D ED 52       >                        sbc	    hl,de
  62+ 691F             >1:
  63+ 691F                                      BCDIVDE_Iteration
  63+ 691F 17          >                        rla
  63+ 6920 ED 6A       >                        adc	    hl,hl
  63+ 6922 19          >                        add	    hl,de
  63+ 6923 38 02       >                        jr	    c,1F
  63+ 6925 ED 52       >                        sbc	    hl,de
  63+ 6927             >1:
  64+ 6927                                      BCDIVDE_Iteration
  64+ 6927 17          >                        rla
  64+ 6928 ED 6A       >                        adc	    hl,hl
  64+ 692A 19          >                        add	    hl,de
  64+ 692B 38 02       >                        jr	    c,1F
  64+ 692D ED 52       >                        sbc	    hl,de
  64+ 692F             >1:
  65+ 692F 17                                   rla
  66+ 6930 47                                   ld b,a
  67+ 6931 79                                   ld a,c
  68+ 6932                                      BCDIVDE_Iteration
  68+ 6932 17          >                        rla
  68+ 6933 ED 6A       >                        adc	    hl,hl
  68+ 6935 19          >                        add	    hl,de
  68+ 6936 38 02       >                        jr	    c,1F
  68+ 6938 ED 52       >                        sbc	    hl,de
  68+ 693A             >1:
  69+ 693A                                      BCDIVDE_Iteration
  69+ 693A 17          >                        rla
  69+ 693B ED 6A       >                        adc	    hl,hl
  69+ 693D 19          >                        add	    hl,de
  69+ 693E 38 02       >                        jr	    c,1F
  69+ 6940 ED 52       >                        sbc	    hl,de
  69+ 6942             >1:
  70+ 6942                                      BCDIVDE_Iteration
  70+ 6942 17          >                        rla
  70+ 6943 ED 6A       >                        adc	    hl,hl
  70+ 6945 19          >                        add	    hl,de
  70+ 6946 38 02       >                        jr	    c,1F
  70+ 6948 ED 52       >                        sbc	    hl,de
  70+ 694A             >1:
  71+ 694A                                      BCDIVDE_Iteration
  71+ 694A 17          >                        rla
  71+ 694B ED 6A       >                        adc	    hl,hl
  71+ 694D 19          >                        add	    hl,de
  71+ 694E 38 02       >                        jr	    c,1F
  71+ 6950 ED 52       >                        sbc	    hl,de
  71+ 6952             >1:
  72+ 6952                                      BCDIVDE_Iteration
  72+ 6952 17          >                        rla
  72+ 6953 ED 6A       >                        adc	    hl,hl
  72+ 6955 19          >                        add	    hl,de
  72+ 6956 38 02       >                        jr	    c,1F
  72+ 6958 ED 52       >                        sbc	    hl,de
  72+ 695A             >1:
  73+ 695A                                      BCDIVDE_Iteration
  73+ 695A 17          >                        rla
  73+ 695B ED 6A       >                        adc	    hl,hl
  73+ 695D 19          >                        add	    hl,de
  73+ 695E 38 02       >                        jr	    c,1F
  73+ 6960 ED 52       >                        sbc	    hl,de
  73+ 6962             >1:
  74+ 6962                                      BCDIVDE_Iteration
  74+ 6962 17          >                        rla
  74+ 6963 ED 6A       >                        adc	    hl,hl
  74+ 6965 19          >                        add	    hl,de
  74+ 6966 38 02       >                        jr	    c,1F
  74+ 6968 ED 52       >                        sbc	    hl,de
  74+ 696A             >1:
  75+ 696A                                      BCDIVDE_Iteration
  75+ 696A 17          >                        rla
  75+ 696B ED 6A       >                        adc	    hl,hl
  75+ 696D 19          >                        add	    hl,de
  75+ 696E 38 02       >                        jr	    c,1F
  75+ 6970 ED 52       >                        sbc	    hl,de
  75+ 6972             >1:
  76+ 6972 17                                   rla
  77+ 6973 4F                                   ld c,a
  78+ 6974 C9                                   ret
  79+ 6975 78           Floor_DivQSigned:       ld      a,b             ; save resultant sign
  80+ 6976 AA                                   xor     d               ;
  81+ 6977 E6 80                                and     $80             ;
  82+ 6979 DD 67                                ld      ixh,a           ;
  83+ 697B 78                                   ld      a,b
  84+ 697C E6 7F                                and     $7F
  85+ 697E 47                                   ld      b,a
  86+ 697F 7A                                   ld      a,d
  87+ 6980 E6 7F                                and     $7F
  88+ 6982 57                                   ld      d,a
  89+ 6983 CD B1 68                             call    Floor_DivQ
  90+ 6986 78                                   ld      a,b
  91+ 6987 DD B4                                or      ixh
  92+ 6989 47                                   ld      b,a
  93+ 698A C9                                   ret
  94+ 698B              ; BC = A0 / C
  95+ 698B 16 00        div_a256_div_c:         ld      d,0
  96+ 698D 59                                   ld      e,c
  97+ 698E 47                                   ld      b,a
  98+ 698F 0E 00                                ld      c,0
  99+ 6991 CD E6 68                             call    BC_Div_DE
 100+ 6994 C9                                   ret
 101+ 6995
 102+ 6995              ;Inputs: DE is the numerator, BC is the divisor
 103+ 6995              ;;Outputs: DE is the result
 104+ 6995              ;;         A is a copy of E
 105+ 6995              ;;         HL is the remainder
 106+ 6995              ;;         BC is not changed
 107+ 6995              ;; so DE = DE /BC
 108+ 6995              ;140 bytes
 109+ 6995              ;145cc
 110+ 6995              ; DE = DE/BC
 111+ 6995              MacroDEDivBC:       MACRO
 112+ 6995 ~                                rla
 113+ 6995 ~                                adc     hl,hl
 114+ 6995 ~                                sbc     hl,bc
 115+ 6995 ~                                jr      nc,$+3
 116+ 6995 ~                                add     hl,bc
 117+ 6995                                  ENDM
 118+ 6995
 119+ 6995 AF           DEequDEDivBC:       xor a
 120+ 6996 ED 62                            sbc hl,hl
 121+ 6998 7A                               ld a,d
 122+ 6999                                  MacroDEDivBC
 122+ 6999 17          >                    rla
 122+ 699A ED 6A       >                    adc     hl,hl
 122+ 699C ED 42       >                    sbc     hl,bc
 122+ 699E 30 01       >                    jr      nc,$+3
 122+ 69A0 09          >                    add     hl,bc
 123+ 69A1                                  MacroDEDivBC
 123+ 69A1 17          >                    rla
 123+ 69A2 ED 6A       >                    adc     hl,hl
 123+ 69A4 ED 42       >                    sbc     hl,bc
 123+ 69A6 30 01       >                    jr      nc,$+3
 123+ 69A8 09          >                    add     hl,bc
 124+ 69A9                                  MacroDEDivBC
 124+ 69A9 17          >                    rla
 124+ 69AA ED 6A       >                    adc     hl,hl
 124+ 69AC ED 42       >                    sbc     hl,bc
 124+ 69AE 30 01       >                    jr      nc,$+3
 124+ 69B0 09          >                    add     hl,bc
 125+ 69B1                                  MacroDEDivBC
 125+ 69B1 17          >                    rla
 125+ 69B2 ED 6A       >                    adc     hl,hl
 125+ 69B4 ED 42       >                    sbc     hl,bc
 125+ 69B6 30 01       >                    jr      nc,$+3
 125+ 69B8 09          >                    add     hl,bc
 126+ 69B9                                  MacroDEDivBC
 126+ 69B9 17          >                    rla
 126+ 69BA ED 6A       >                    adc     hl,hl
 126+ 69BC ED 42       >                    sbc     hl,bc
 126+ 69BE 30 01       >                    jr      nc,$+3
 126+ 69C0 09          >                    add     hl,bc
 127+ 69C1                                  MacroDEDivBC
 127+ 69C1 17          >                    rla
 127+ 69C2 ED 6A       >                    adc     hl,hl
 127+ 69C4 ED 42       >                    sbc     hl,bc
 127+ 69C6 30 01       >                    jr      nc,$+3
 127+ 69C8 09          >                    add     hl,bc
 128+ 69C9                                  MacroDEDivBC
 128+ 69C9 17          >                    rla
 128+ 69CA ED 6A       >                    adc     hl,hl
 128+ 69CC ED 42       >                    sbc     hl,bc
 128+ 69CE 30 01       >                    jr      nc,$+3
 128+ 69D0 09          >                    add     hl,bc
 129+ 69D1                                  MacroDEDivBC
 129+ 69D1 17          >                    rla
 129+ 69D2 ED 6A       >                    adc     hl,hl
 129+ 69D4 ED 42       >                    sbc     hl,bc
 129+ 69D6 30 01       >                    jr      nc,$+3
 129+ 69D8 09          >                    add     hl,bc
 130+ 69D9 17                               rla
 131+ 69DA 2F                               cpl
 132+ 69DB 57                               ld d,a
 133+ 69DC
 134+ 69DC 7B                               ld a,e
 135+ 69DD                                  MacroDEDivBC
 135+ 69DD 17          >                    rla
 135+ 69DE ED 6A       >                    adc     hl,hl
 135+ 69E0 ED 42       >                    sbc     hl,bc
 135+ 69E2 30 01       >                    jr      nc,$+3
 135+ 69E4 09          >                    add     hl,bc
 136+ 69E5                                  MacroDEDivBC
 136+ 69E5 17          >                    rla
 136+ 69E6 ED 6A       >                    adc     hl,hl
 136+ 69E8 ED 42       >                    sbc     hl,bc
 136+ 69EA 30 01       >                    jr      nc,$+3
 136+ 69EC 09          >                    add     hl,bc
 137+ 69ED                                  MacroDEDivBC
 137+ 69ED 17          >                    rla
 137+ 69EE ED 6A       >                    adc     hl,hl
 137+ 69F0 ED 42       >                    sbc     hl,bc
 137+ 69F2 30 01       >                    jr      nc,$+3
 137+ 69F4 09          >                    add     hl,bc
 138+ 69F5                                  MacroDEDivBC
 138+ 69F5 17          >                    rla
 138+ 69F6 ED 6A       >                    adc     hl,hl
 138+ 69F8 ED 42       >                    sbc     hl,bc
 138+ 69FA 30 01       >                    jr      nc,$+3
 138+ 69FC 09          >                    add     hl,bc
 139+ 69FD                                  MacroDEDivBC
 139+ 69FD 17          >                    rla
 139+ 69FE ED 6A       >                    adc     hl,hl
 139+ 6A00 ED 42       >                    sbc     hl,bc
 139+ 6A02 30 01       >                    jr      nc,$+3
 139+ 6A04 09          >                    add     hl,bc
 140+ 6A05                                  MacroDEDivBC
 140+ 6A05 17          >                    rla
 140+ 6A06 ED 6A       >                    adc     hl,hl
 140+ 6A08 ED 42       >                    sbc     hl,bc
 140+ 6A0A 30 01       >                    jr      nc,$+3
 140+ 6A0C 09          >                    add     hl,bc
 141+ 6A0D                                  MacroDEDivBC
 141+ 6A0D 17          >                    rla
 141+ 6A0E ED 6A       >                    adc     hl,hl
 141+ 6A10 ED 42       >                    sbc     hl,bc
 141+ 6A12 30 01       >                    jr      nc,$+3
 141+ 6A14 09          >                    add     hl,bc
 142+ 6A15                                  MacroDEDivBC
 142+ 6A15 17          >                    rla
 142+ 6A16 ED 6A       >                    adc     hl,hl
 142+ 6A18 ED 42       >                    sbc     hl,bc
 142+ 6A1A 30 01       >                    jr      nc,$+3
 142+ 6A1C 09          >                    add     hl,bc
 143+ 6A1D 17                               rla
 144+ 6A1E 2F                               cpl
 145+ 6A1F 5F                               ld e,a
 146+ 6A20 C9                               ret
 147+ 6A21
 148+ 6A21              ; ">asm_div16: HL_Div_C: HL is the numerator,  C is the denominator, output A is the remainder, B is 0, C,DE is not changedHL is the quotient"
 149+ 6A21 06 10        div_hl_div_c:           ld b,16
 150+ 6A23 AF                                   xor a
 151+ 6A24 CB 25        div16_loop:	            sla l
 152+ 6A26 CB 14                                rl	h
 153+ 6A28              ;    add hl,hl
 154+ 6A28 17                                   rla
 155+ 6A29 B9                                   cp c
 156+ 6A2A 38 02                                jr c,div16_skip
 157+ 6A2C 2C                                   inc l
 158+ 6A2D 91                                   sub c
 159+ 6A2E 10 F4        div16_skip:		        djnz div16_loop
 160+ 6A30 C9                                   ret
 161+ 6A31
 162+ 6A31
 163+ 6A31              EDivC_Iteration:        MACRO
 164+ 6A31 ~                                    rl  e
 165+ 6A31 ~                                    rla
 166+ 6A31 ~                                    sub c
 167+ 6A31 ~                                    jr  nc,.Div8_NoAdd
 168+ 6A31 ~                                    add a,c
 169+ 6A31 ~            .Div8_NoAdd:
 170+ 6A31                                      ENDM
 171+ 6A31
 172+ 6A31              ; Switch to a logarithm version
 173+ 6A31              ; Divide E by divider C Out: A = result, B = rest
 174+ 6A31              div_e_div_c:            ZeroA
 174+ 6A31 AF          >                        xor a
 175+ 6A32                                      EDivC_Iteration
 175+ 6A32 CB 13       >                        rl  e
 175+ 6A34 17          >                        rla
 175+ 6A35 91          >                        sub c
 175+ 6A36 30 01       >                        jr  nc,.Div8_NoAdd
 175+ 6A38 81          >                        add a,c
 175+ 6A39             >.Div8_NoAdd:
 176+ 6A39                                      EDivC_Iteration
 176+ 6A39 CB 13       >                        rl  e
 176+ 6A3B 17          >                        rla
 176+ 6A3C 91          >                        sub c
 176+ 6A3D 30 01       >                        jr  nc,.Div8_NoAdd
 176+ 6A3F 81          >                        add a,c
 176+ 6A40             >.Div8_NoAdd:
 177+ 6A40                                      EDivC_Iteration
 177+ 6A40 CB 13       >                        rl  e
 177+ 6A42 17          >                        rla
 177+ 6A43 91          >                        sub c
 177+ 6A44 30 01       >                        jr  nc,.Div8_NoAdd
 177+ 6A46 81          >                        add a,c
 177+ 6A47             >.Div8_NoAdd:
 178+ 6A47                                      EDivC_Iteration
 178+ 6A47 CB 13       >                        rl  e
 178+ 6A49 17          >                        rla
 178+ 6A4A 91          >                        sub c
 178+ 6A4B 30 01       >                        jr  nc,.Div8_NoAdd
 178+ 6A4D 81          >                        add a,c
 178+ 6A4E             >.Div8_NoAdd:
 179+ 6A4E                                      EDivC_Iteration
 179+ 6A4E CB 13       >                        rl  e
 179+ 6A50 17          >                        rla
 179+ 6A51 91          >                        sub c
 179+ 6A52 30 01       >                        jr  nc,.Div8_NoAdd
 179+ 6A54 81          >                        add a,c
 179+ 6A55             >.Div8_NoAdd:
 180+ 6A55                                      EDivC_Iteration
 180+ 6A55 CB 13       >                        rl  e
 180+ 6A57 17          >                        rla
 180+ 6A58 91          >                        sub c
 180+ 6A59 30 01       >                        jr  nc,.Div8_NoAdd
 180+ 6A5B 81          >                        add a,c
 180+ 6A5C             >.Div8_NoAdd:
 181+ 6A5C                                      EDivC_Iteration
 181+ 6A5C CB 13       >                        rl  e
 181+ 6A5E 17          >                        rla
 181+ 6A5F 91          >                        sub c
 181+ 6A60 30 01       >                        jr  nc,.Div8_NoAdd
 181+ 6A62 81          >                        add a,c
 181+ 6A63             >.Div8_NoAdd:
 182+ 6A63                                      EDivC_Iteration
 182+ 6A63 CB 13       >                        rl  e
 182+ 6A65 17          >                        rla
 182+ 6A66 91          >                        sub c
 182+ 6A67 30 01       >                        jr  nc,.Div8_NoAdd
 182+ 6A69 81          >                        add a,c
 182+ 6A6A             >.Div8_NoAdd:
 183+ 6A6A 47                                   ld      b,a
 184+ 6A6B 7B                                   ld      a,e
 185+ 6A6C 17                                   rla
 186+ 6A6D 2F                                   cpl
 187+ 6A6E C9                                   ret
 188+ 6A6F              ; Entry point if varQ is populated with demoninator
 189+ 6A6F              RequAmul256divQ:
 190+ 6A6F F5           BFRDIV:                 push	af
 191+ 6A70 3A ED 5D                             ld		a,(varQ)
 192+ 6A73 4F                                   ld		c,a
 193+ 6A74 F1                                   pop		af
 194+ 6A75 FE 00                                cp		0
 195+ 6A77 CA 8E 6A                             jp		z, HLDIVC_0_BY	; fast exit if numerator is 0
 196+ 6A7A 2E 00        RequAmul256divC:        ld		l,0
 197+ 6A7C 67                                   ld		h,a
 198+ 6A7D 06 10        HL_Div_Cold:			ld b,16			; fast entry point if C and HL are already set
 199+ 6A7F AF                                   xor a
 200+ 6A80 29           LOOPPOINT:	            add hl,hl
 201+ 6A81 17                                   rla
 202+ 6A82 B9                                   cp c
 203+ 6A83 38 02                                jr c,SKIPINCSUB
 204+ 6A85 2C                                   inc l
 205+ 6A86 91                                   sub c
 206+ 6A87 10 F7        SKIPINCSUB:             djnz LOOPPOINT
 207+ 6A89 7D                                   ld		a,l
 208+ 6A8A 32 EE 5D                             ld 		(varR),a
 209+ 6A8D C9                                   ret
 210+ 6A8E 32 EE 5D     HLDIVC_0_BY:            ld		(varR),a
 211+ 6A91 C9                                   ret
 212+ 6A92
 213+ 6A92
 214+ 6A92 BA           AEquAmul256DivD:        cp      d
 215+ 6A93 28 1D                                jr      z,.BothSame
 216+ 6A95 30 1E                                jr      nc,.DgtA
 217+ 6A97 1E FE                                ld      e,%11111110                 ; Set R to have bits 1-7 set, so we can rotate through 7
 218+ 6A99 CB 27        .DivideLoop:            sla     a
 219+ 6A9B 38 0D                                jr      c,.LL29
 220+ 6A9D                                      JumpIfALTNusng  d, .SkipSub         ; will jump if carry set, so we need to reset on the rol
 220+ 6A9D BA          >                        cp      d
 220+ 6A9E DA A3 6A    >                        jp		c, .SkipSub
 221+ 6AA1 92                                   sub     d
 222+ 6AA2                                      ClearCarryFlag                      ; reset clarry as it will be complimented for rotate as 6502 does carry flags inverted
 222+ 6AA2 B7          >                        or a
 223+ 6AA3              .SkipSub:               FlipCarryFlag                       ; if we did the subtract the carry will be clear so we need to invert to roll in.
 223+ 6AA3 3F          >                        ccf
 224+ 6AA4 CB 13                                rl      e
 225+ 6AA6 38 F1                                jr      c,.DivideLoop
 226+ 6AA8 7B                                   ld      a,e
 227+ 6AA9 C9                                   ret
 228+ 6AAA 92           .LL29:                  sub     d                           ; A >= Q, so set A = A - Q
 229+ 6AAB                                      SetCarryFlag                        ; Set the C flag to rotate into the result in R
 229+ 6AAB 37          >                        scf
 230+ 6AAC CB 13                                rl      e                           ; rotate counter e left
 231+ 6AAE 38 E9                                jr      c,.DivideLoop               ; if a bit was spat off teh end then loop
 232+ 6AB0 7B                                   ld      a,e                         ; stick result in a
 233+ 6AB1 C9                                   ret
 234+ 6AB2 3E FF        .BothSame:              ld  a,255
 235+ 6AB4 C9                                   ret
 236+ 6AB5 3E FF        .DgtA:                  ld  a,255                           ; Fail with FF as result
 237+ 6AB7 C9                                   ret
 238+ 6AB8
 239+ 6AB8              ;divdide by 16 using undocumented instrunctions
 240+ 6AB8              ;Input: BC = Dividend, DE = Divisor, HL = 0
 241+ 6AB8              ;Output: BC = Quotient, HL = Remainder
 242+ 6AB8              ; Our use
 243+ 6AB8              ; BC = A0
 244+ 6AB8              ; DE = 0C
 245+ 6AB8              ; so BC = a * 256 / C
 246+ 6AB8              DIV16Amul256dCUNDOC:    JumpIfAGTENusng	  c,DEV16ATooLarge                                          ; first off if a > c ten return 255
 246+ 6AB8 B9          >                        cp     c
 246+ 6AB9 D2 E4 6A    >                        jp		nc,DEV16ATooLarge
 247+ 6ABC 47                                   ld      b,a
 248+ 6ABD 59                                   ld      e,c
 249+ 6ABE 0E 00                                ld      c,0
 250+ 6AC0 16 00                                ld      d,0
 251+ 6AC2 C3 CF 6A                             jp      DIV16UNDOC
 252+ 6AC5 47           DIV16Amul256dQUNDOC:    ld      b,a
 253+ 6AC6 0E 00                                ld      c,0
 254+ 6AC8 21 ED 5D                             ld      hl,varQ
 255+ 6ACB 7E                                   ld      a,(hl)
 256+ 6ACC 16 00                                ld      d,0
 257+ 6ACE 5F                                   ld      e,a
 258+ 6ACF              DIV16BCDivDEUNDOC:
 259+ 6ACF 21 00 00     DIV16UNDOC:             ld      hl,0
 260+ 6AD2 78                                   ld      a,b
 261+ 6AD3 06 10                                ld      b,16
 262+ 6AD5 CB 31        DIV16UNDOCLOOP:         sll	c		; unroll 16 times
 263+ 6AD7 17                                   rla			; ...
 264+ 6AD8 ED 6A                                adc	hl,hl		; ...
 265+ 6ADA ED 52                                sbc	hl,de		; ...
 266+ 6ADC 30 02                                jr	nc,DIV16UNDOCSKIP		; ...
 267+ 6ADE 19                                   add	hl,de		; ...
 268+ 6ADF 0D                                   dec	c		; ...
 269+ 6AE0 10 F3        DIV16UNDOCSKIP:         djnz DIV16UNDOCLOOP
 270+ 6AE2 47                                   ld   b,a
 271+ 6AE3 C9                                   ret
 272+ 6AE4 01 FF 00     DEV16ATooLarge:         ld     bc,$00FF
 273+ 6AE7 C9                                   ret
 274+ 6AE8              ; switch to logarithm version
 275+ 6AE8              ; "> asm_div8 C_Div_D - C is the numerator, D is the denominator, A is the remainder, B is 0, C is the result of C/D,D,E,H,L are not changed"
 276+ 6AE8 06 08        asm_div8:               ld b,8
 277+ 6AEA AF                                   xor a
 278+ 6AEB CB 21        .div8_loop:	            sla c
 279+ 6AED 17                                   rla
 280+ 6AEE BA                                   cp d
 281+ 6AEF 38 02                                jr c,.div8_skip
 281+ 6AF1
 282+ 6AF1 0C                                   inc c
 283+ 6AF2 92                                   sub d
 284+ 6AF3 10 F6        .div8_skip:	            djnz .div8_loop
 285+ 6AF5 C9                                   ret
 286+ 6AF6
 287+ 6AF6 14           Div16by24usgn:          inc     d                           ; can we fast retu
 288+ 6AF7 15                                   dec     d
 289+ 6AF8 20 13                                jr      nz,.ResultZero
 290+ 6AFA 50 59                                ld      de,bc                       ; so prep for bc/de
 291+ 6AFC 44 4D                                ld      bc,hl
 292+ 6AFE 7A           .div16by16usng:         ld      a,d
 293+ 6AFF B3                                   or      e
 294+ 6B00 28 10                                jr      z,.DivideByZero
 295+ 6B02 14                                   inc     d
 296+ 6B03 15                                   dec     d
 297+ 6B04 CD E6 68                             call    BC_Div_DE
 298+ 6B07                                      ZeroA
 298+ 6B07 AF          >                        xor a
 299+ 6B08 EB                                   ex      de,hl                       ; de = remainder (need to fix c after hl = nothing of worth)
 300+ 6B09 60 69                                ld      hl,bc                       ; hl = result (a is zero from above)
 301+ 6B0B 4F                                   ld      c,a                         ; now fix c
 302+ 6B0C C9                                   ret
 303+ 6B0D AF           .ResultZero:            xor     a                           ; set AHL to 0 as d was 0 so h is zero
 304+ 6B0E 4F                                   ld      c,a                         ; c = 0
 305+ 6B0F 67                                   ld      h,a
 306+ 6B10 6F                                   ld      l,a
 307+ 6B11 C9                                   ret
 308+ 6B12 3E FF        .DivideByZero:          ld      a,$FF
 309+ 6B14 67                                   ld      h,a
 310+ 6B15 6F                                   ld      l,a
 311+ 6B16                                      SetCarryFlag
 311+ 6B16 37          >                        scf
 312+ 6B17 C9                                   ret
 313+ 6B18
 314+ 6B18
 315+ 6B18 21 ED 5D     Amul256DivQ:            ld      hl,varQ                 ; CMP Q                  \ If A >= Q, then the answer will not fit in one byte,
 316+ 6B1B 4E                                   ld      c,(hl)                  ; using c as Q var
 317+ 6B1C B9                                   cp      c
 318+ 6B1D                                      FlipCarryFlag
 318+ 6B1D 3F          >                        ccf
 319+ 6B1E DA 46 6B                             jp      c, .LL2_6502            ; BCS LL2                \ so jump to LL2 to return 255
 320+ 6B21 06 FE                                ld      b,$FE                   ; LDX #%11111110         \ Set R to have bits 1-7 set, so we can rotate through 7 loop iterations, getting a 1 each time, and then we use b as Rvar
 321+ 6B23 CB 27        .LL31_6502:             sla     a                       ; ASL A                  \ Shift A to the left
 322+ 6B25 DA 3A 6B                             jp      c,.LL29_6502            ; BCS LL29               \ If bit 7 of A was set, then jump straight to the subtraction
 323+ 6B28                                      FlipCarryFlag                   ;                          If A < N, then C flag is set.
 323+ 6B28 3F          >                        ccf
 324+ 6B29                                      JumpIfALTNusng c, .LL31_SKIPSUB_6502 ; CMP Q              \ If A < Q, skip the following subtraction
 324+ 6B29 B9          >                        cp      c
 324+ 6B2A DA 2F 6B    >                        jp		c, .LL31_SKIPSUB_6502
 325+ 6B2D                                                                      ; BCC P%+4
 326+ 6B2D 91                                   sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
 327+ 6B2E                                      ClearCarryFlag
 327+ 6B2E B7          >                        or a
 328+ 6B2F              .LL31_SKIPSUB_6502:     FlipCarryFlag
 328+ 6B2F 3F          >                        ccf
 329+ 6B30 CB 10                                rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
 330+ 6B32 DA 23 6B                             jp      c, .LL31_6502           ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
 331+ 6B35 78                                   ld      a,b
 332+ 6B36 32 EE 5D                             ld      (varR),a
 333+ 6B39 C9                                   ret                             ; RTS                    \ R left with remainder of division
 334+ 6B3A 91           .LL29_6502:             sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
 335+ 6B3B                                      SetCarryFlag                    ; SEC                    \ Set the C flag to rotate into the result in R
 335+ 6B3B 37          >                        scf
 336+ 6B3C CB 10                                rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
 337+ 6B3E DA 23 6B                             jp      c, .LL31_6502           ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
 338+ 6B41 78                                   ld      a,b                     ; RTS                    \ Return from the subroutine with R containing the
 339+ 6B42 32 EE 5D                             ld      (varR),a                ; .
 340+ 6B45 C9                                   ret                             ; .                      \ remainder of the division
 341+ 6B46 3E FF        .LL2_6502:              ld      a,$FF                   ; LDA #255               \ The division is very close to 1, so return the closest
 342+ 6B48 32 EE 5D                             ld      (varR),a                ; STA R                  \ possible answer to 256, i.e. R = 255
 343+ 6B4B                                      SetCarryFlag                    ; we failed so need carry flag set
 343+ 6B4B 37          >                        scf
 344+ 6B4C C9                                   ret                             ; RTS                    \ Return from the subroutine
 345+ 6B4D
# file closed: asm_divide_helpers.asm
 133  6B4D                  INCLUDE	"../../Maths24/asm_sqrt24.asm"
# file opened: asm_sqrt24.asm
   1+ 6B4D              ; fast 16-bit isqrt by Zeda Thomas
   2+ 6B4D              ;Feel free to use for whatever :)
   3+ 6B4D
   4+ 6B4D              sqrtHL:
   5+ 6B4D              ;Input: HL
   6+ 6B4D              ;Output: A is the integer square root of HL
   7+ 6B4D              ;Destroys: HL,DE (D is actually 0)
   8+ 6B4D              ;min: 343cc
   9+ 6B4D              ;max: 380cc
  10+ 6B4D              ;avg: 361.5cc
  11+ 6B4D              ;88 bytes
  12+ 6B4D 11 40 50                             ld de,05040h                ; 10
  13+ 6B50 7C                                   ld a,h                      ; 4
  14+ 6B51 93                                   sub e                       ; 4
  15+ 6B52 30 03                                jr nc,sq7                   ;\
  16+ 6B54 83                                   add a,e                     ; | branch 1: 12cc
  17+ 6B55 16 10                                ld d,16                     ; | branch 2: 18cc
  18+ 6B57 BA           sq7:                    cp d                        ; 4
  19+ 6B58 38 03                                jr c,sq6                    ;\
  20+ 6B5A 92                                   sub d                       ; | branch 1: 12cc
  21+ 6B5B CB EA                                set 5,d                     ; | branch 2: 19cc
  22+ 6B5D CB A2        sq6:                    res 4,d                     ; 8
  23+ 6B5F CB 3A                                srl d                       ; 8
  24+ 6B61 CB D2                                set 2,d                     ; 8
  25+ 6B63 BA                                   cp d                        ; 4
  26+ 6B64 38 03                                jr c,sq5                    ;\
  27+ 6B66 92                                   sub d                       ; | branch 1: 12cc
  28+ 6B67 CB DA                                set 3,d                     ; | branch 2: 19cc
  29+ 6B69 CB 3A        sq5:                    srl d                       ; 8
  30+ 6B6B 3C                                   inc a                       ; 4
  31+ 6B6C 92                                   sub d                       ; 4
  32+ 6B6D 30 03                                jr nc,sq4                   ;\
  33+ 6B6F 15                                   dec d                       ; | branch 1: 12cc
  34+ 6B70 82                                   add a,d                     ; | branch 2: 19cc
  35+ 6B71 15                                   dec d                       ; | <-- this resets the low bit of D, so `srl d` resets carry.
  36+ 6B72 CB 3A        sq4:                     srl d                      ; 8
  37+ 6B74 67                                   ld h,a                      ; 4
  38+ 6B75 7B                                   ld a,e                      ; 4
  39+ 6B76 ED 52                                sbc hl,de                   ; 15
  40+ 6B78 30 01                                jr nc,sq3                   ;\
  41+ 6B7A 19                                   add hl,de                   ; | 12cc or 18cc
  42+ 6B7B 3F           sq3:                    ccf                         ; 4
  43+ 6B7C 1F                                   rra                         ; 4
  44+ 6B7D CB 3A                                srl d                       ; 8
  45+ 6B7F 1F                                   rra                         ; 4
  46+ 6B80 5F                                   ld e,a                      ; 4
  47+ 6B81 ED 52                                sbc hl,de                   ; 15
  48+ 6B83 38 03                                jr c,sq2                    ;\
  49+ 6B85 F6 20                                or 20h                      ; | branch 1: 23cc
  50+ 6B87 FE                                   db 254                      ; |   <-- start of `cp *` which is 7cc to skip the next byte.
  51+ 6B88 19           sq2:                    add hl,de                   ;/
  52+ 6B89 EE 18                                xor 18h                     ; 7
  53+ 6B8B CB 3A                                srl d                       ; 8
  54+ 6B8D 1F                                   rra                         ; 4
  55+ 6B8E 5F                                   ld e,a                      ; 4
  56+ 6B8F ED 52                                sbc hl,de                   ; 15
  57+ 6B91 38 03                                jr c,sq1                    ;\
  58+ 6B93 F6 08                                or 8                        ; | branch 1: 23cc
  59+ 6B95 FE                                   db 254                      ; |   <-- start of `cp *` which is 7cc to skip the next byte.
  60+ 6B96 19           sq1:                    add hl,de                   ;/
  61+ 6B97 EE 06                                xor 6                       ; 7
  62+ 6B99 CB 3A                                srl d                       ; 8
  63+ 6B9B 1F                                   rra                         ; 4
  64+ 6B9C 5F                                   ld e,a                      ; 4
  65+ 6B9D ED 52                                sbc hl,de                   ; 15
  66+ 6B9F DE FF                                sbc a,255                   ; 7
  67+ 6BA1 CB 3A                                srl d                       ; 8
  68+ 6BA3 1F                                   rra                         ; 4
  69+ 6BA4 C9                                   ret                         ; 10
# file closed: asm_sqrt24.asm
 134  6BA5                  INCLUDE	"../../Maths24/asm_normalise24.asm"
# file opened: asm_normalise24.asm
   1+ 6BA5
   2+ 6BA5              ; takes a 3x24 bit vector and normalilses them, this is done by taking the ABS values scaling down into a maxioum of a 15 bit number
   3+ 6BA5
   4+ 6BA5              PrepScale:              MACRO                       ;setg [A IYH] to or'ed all bytes of ABS X,Y,Z
   5+ 6BA5 ~                                    ld      a,h
   6+ 6BA5 ~                                    or      d
   7+ 6BA5 ~                                    or      c
   8+ 6BA5 ~                                    ld      iyh,a
   9+ 6BA5 ~                                    ld      a,l
  10+ 6BA5 ~                                    or      e
  11+ 6BA5 ~                                    or      c
  12+ 6BA5 ~                                    or      1                   ; we can never have a status where hl,de,bc are 0 but we will force bit 1 to be safe
  13+ 6BA5                                      ENDM
  14+ 6BA5
  15+ 6BA5              ScaleHLD:               MACRO
  16+ 6BA5 ~                                    ld      a,h
  17+ 6BA5 ~                                    or      l
  18+ 6BA5 ~                                    or      d
  19+ 6BA5 ~                                    jp      nz,.StartShift      ; if its zero then we need to set to at least 1 to avoid infinite loop and hence divide by 0 later
  20+ 6BA5 ~                                    ld      a,1
  21+ 6BA5 ~                                    ld      h,a
  22+ 6BA5 ~                                    ld      l,a
  23+ 6BA5 ~                                    ld      d,a
  24+ 6BA5 ~                                    jp      .DoneShift
  25+ 6BA5 ~            .StartShift:            bit     7,a                 ; if its already 7 bit then shift right one
  26+ 6BA5 ~                                    jp      z,.ShiftLoop
  27+ 6BA5 ~            .ShiftRight:            srl     h
  28+ 6BA5 ~                                    srl     l
  29+ 6BA5 ~                                    srl     d
  30+ 6BA5 ~                                    jp      .DoneShift
  31+ 6BA5 ~            .ShiftLoop:             sla     a
  32+ 6BA5 ~                                    jp      m,.DoneShift        ; so if a bit ends up in bit 7 that measn that its negative so we can stop now leavign HLD as 7 bit
  33+ 6BA5 ~                                    sla     h
  34+ 6BA5 ~                                    sla     l
  35+ 6BA5 ~                                    sla     d
  36+ 6BA5 ~                                    jp      .ShiftLoop
  37+ 6BA5 ~            .DoneShift:
  38+ 6BA5                                      ENDM
  39+ 6BA5
  40+ 6BA5              CalculateScale:         MACRO
  41+ 6BA5 ~                                    ld      iyl,a
  42+ 6BA5 ~                                    exx                         ; save off registers so we can use altgernates for barrel shift calc
  43+ 6BA5 ~                                    ld      b,0
  44+ 6BA5 ~                                    ld      de,iy               ; moving iy to de for faster bit and shift operations
  45+ 6BA5 ~                                    ; as we ABS then bit 7 can never have been set anmd we want to stop after setting bit 6 so max range is 16129 (127 ^ 2)
  46+ 6BA5 ~            .ScaleLoop:             bit     6,d                 ; this loop will find the minium number of shifts requried
  47+ 6BA5 ~                                    jp      nz,.DoneShift       ; if bit 6 is set then we have done enough shifts
  48+ 6BA5 ~                                    ShiftDELeft1
  49+ 6BA5 ~                                    inc     b
  50+ 6BA5 ~                                    jp      .ScaleLoop
  51+ 6BA5 ~            .DoneShift              ld      a,b                 ; b is all we are interestred in so save it in IYL
  52+ 6BA5 ~                                    exx                         ; now we have the vector coords recovered
  53+ 6BA5                                      ENDM
  54+ 6BA5              ScaleY:                 MACRO
  55+ 6BA5 ~                                    ld      b,a                 ; shift de
  56+ 6BA5 ~                                    bsrl    de,b
  57+ 6BA5                                      ENDM
  58+ 6BA5              ScaleX:                 MACRO                       ; as b is already loaded we can just swap over de,hl and do the shift
  59+ 6BA5 ~                                    ex      de,hl
  60+ 6BA5 ~                                    bsrl    de,b
  61+ 6BA5                                      ENDM
  62+ 6BA5              ScaleZ:                 MACRO                       ; as b is already loaded we can just swap over de,hl and do the shift
  63+ 6BA5 ~                                    push    de                  ; we need DE spare
  64+ 6BA5 ~                                    ld      de,bc
  65+ 6BA5 ~                                    ld      b,a
  66+ 6BA5 ~                                    bsrl    de,b
  67+ 6BA5 ~                                    ld      bc,de
  68+ 6BA5 ~                                    pop     de
  69+ 6BA5                                      ENDM
  70+ 6BA5              SquareX:                MACRO
  71+ 6BA5 ~                                    ex      de,hl
  72+ 6BA5 ~                                    mul     de
  73+ 6BA5 ~                                    ex      de,hl
  74+ 6BA5                                      ENDM
  75+ 6BA5              SquareY:                MACRO
  76+ 6BA5 ~                                    mul     de
  77+ 6BA5                                      ENDM
  78+ 6BA5              SquareZ:                MACRO
  79+ 6BA5 ~                                    ld      de,bc
  80+ 6BA5 ~                                    mul     de                  ; d * e
  81+ 6BA5                                      ENDM
  82+ 6BA5
  83+ 6BA5 06 00        Normalise24IX:          ld      b,0                 ; B = 0
  84+ 6BA7              .GetAllSignBytes:       SetIYHToSignBits            ; bit 7 = sign X, bit 6 sign Y, bit 5 sign Z
  84+ 6BA7 DD 7E 08    >                        ld      a,(ix+8)                ; get Z sign
  84+ 6BAA E6 80       >                        and     $80                     ; and shift it via A into IYH bit 7
  84+ 6BAC CB 2F       >                        sra     a                       ;
  84+ 6BAE FD 67       >                        ld      iyh,a                   ;
  84+ 6BB0 DD 7E 05    >                        ld      a,(ix+5)                ; get Y sign
  84+ 6BB3 E6 80       >                        and     $80                     ; and shift it via A into IYH bit 7
  84+ 6BB5 FD B4       >                        or      iyh                     ; which moves Z into IYH bit 6
  84+ 6BB7 CB 2F       >                        sra     a                       ;
  84+ 6BB9 FD 67       >                        ld      iyh,a                   ;
  84+ 6BBB DD 7E 02    >                        ld      a,(ix+2)                ; get X sign
  84+ 6BBE E6 80       >                        and     $80                     ; and shift it via A into IYH bit 7
  84+ 6BC0 FD B4       >                        or      iyh                     ; which moves Y into IYH bit 6 and Z into IYH bit 5
  84+ 6BC2 FD 67       >                        ld      iyh,a                   ;
  85+ 6BC4                                      SetAHLDToABSXYZSgn          ; get ABS X,Y,Z Sign into H L D and set a to X|Y|Z (abs values), will also set or flags
  85+ 6BC4 DD 7E 02    >                        ld      a,(ix+2)
  85+ 6BC7 E6 7F       >                        and     $7F
  85+ 6BC9 67          >                        ld      h,a
  85+ 6BCA DD 7E 05    >                        ld      a,(ix+5)
  85+ 6BCD E6 7F       >                        and     $7F
  85+ 6BCF 6F          >                        ld      l,a
  85+ 6BD0 DD 7E 08    >                        ld      a,(ix+8)
  85+ 6BD3 E6 7F       >                        and     $7F
  85+ 6BD5 57          >                        ld      d,a
  85+ 6BD6 B4          >                        or      h
  85+ 6BD7 B5          >                        or      l
  86+ 6BD8 C2 FD 6B                             jp      nz,.PerformShift    ; if we have values in sign then we use that for divide
  87+ 6BDB              .HiLoOnly:              SetAHLDToABSXYZHi
  87+ 6BDB DD 7E 01    >                        ld      a,(ix+1)
  87+ 6BDE 67          >                        ld      h,a
  87+ 6BDF DD 7E 04    >                        ld      a,(ix+4)
  87+ 6BE2 6F          >                        ld      l,a
  87+ 6BE3 DD 7E 07    >                        ld      a,(ix+7)
  87+ 6BE6 57          >                        ld      d,a
  87+ 6BE7 B4          >                        or      h
  87+ 6BE8 B5          >                        or      l
  88+ 6BE9 CA EF 6B                             jp      z,.LoOnly           ; Signs are all 0
  89+ 6BEC C3 FD 6B                             jp      .PerformShift
  90+ 6BEF              .LoOnly:                SetAHLDToABSXYZLo           ; High bytes are all 0 so we use lo bytes
  90+ 6BEF DD 7E 00    >                        ld      a,(ix+0)
  90+ 6BF2 67          >                        ld      h,a
  90+ 6BF3 DD 7E 03    >                        ld      a,(ix+3)
  90+ 6BF6 6F          >                        ld      l,a
  90+ 6BF7 DD 7E 06    >                        ld      a,(ix+6)
  90+ 6BFA 57          >                        ld      d,a
  90+ 6BFB B4          >                        or      h
  90+ 6BFC B5          >                        or      l
  91+ 6BFD              .PerformShift:          ScaleHLD                    ; now scale all teh values so we have H = X, L = Y, D = Z
  91+ 6BFD 7C          >                        ld      a,h
  91+ 6BFE B5          >                        or      l
  91+ 6BFF B2          >                        or      d
  91+ 6C00 C2 0B 6C    >                        jp      nz,.StartShift      ; if its zero then we need to set to at least 1 to avoid infinite loop and hence divide by 0 later
  91+ 6C03 3E 01       >                        ld      a,1
  91+ 6C05 67          >                        ld      h,a
  91+ 6C06 6F          >                        ld      l,a
  91+ 6C07 57          >                        ld      d,a
  91+ 6C08 C3 27 6C    >                        jp      .DoneShift
  91+ 6C0B CB 7F       >.StartShift:            bit     7,a                 ; if its already 7 bit then shift right one
  91+ 6C0D CA 19 6C    >                        jp      z,.ShiftLoop
  91+ 6C10 CB 3C       >.ShiftRight:            srl     h
  91+ 6C12 CB 3D       >                        srl     l
  91+ 6C14 CB 3A       >                        srl     d
  91+ 6C16 C3 27 6C    >                        jp      .DoneShift
  91+ 6C19 CB 27       >.ShiftLoop:             sla     a
  91+ 6C1B FA 27 6C    >                        jp      m,.DoneShift        ; so if a bit ends up in bit 7 that measn that its negative so we can stop now leavign HLD as 7 bit
  91+ 6C1E CB 24       >                        sla     h
  91+ 6C20 CB 25       >                        sla     l
  91+ 6C22 CB 22       >                        sla     d
  91+ 6C24 C3 19 6C    >                        jp      .ShiftLoop
  91+ 6C27             >.DoneShift:
  92+ 6C27 5A                                   ld      e,d                 ; prep for squares
  93+ 6C28 E5 D5                                push    hl,,de              ; and save off current values
  94+ 6C2A D9                                   exx                         ; and work from alternates for squares
  95+ 6C2B D1 E1                                pop     hl,,de
  96+ 6C2D ED 30                                mul     de                  ; Z^2
  97+ 6C2F EB                                   ex      de,hl               ; how de = X Y
  98+ 6C30 7A                                   ld      a,d                 ; a = X
  99+ 6C31 53                                   ld      d,e                 ; Y^2
 100+ 6C32 ED 30                                mul     de                  ;
 101+ 6C34 42 4B                                ld      bc,de               ; bc = Y^2
 102+ 6C36 57                                   ld      d,a                 ; X^2
 103+ 6C37 5F                                   ld      e,a                 ;
 104+ 6C38 ED 30                                mul     de                  ;
 105+ 6C3A 19                                   add     hl,de               ; hl = x^2 + z^2 + y ^2
 106+ 6C3B 09                                   add     hl,bc               ; .
 107+ 6C3C CD 4D 6B                             call    sqrtHL              ; a = sqrt (hl)
 108+ 6C3F D9                                   exx                         ; now get back HLD for XYZ
 109+ 6C40 FD 67        .performNorm:           ld      iyh,a               ; save a copy of sqrt
 110+ 6C42 7A           .NormaliseZ:            ld      a,d                 ; divide X by sqrt
 111+ 6C43 FD 54                                ld      d,iyh               ;
 112+ 6C45 CD 92 6A                             call    AEquAmul256DivD
 113+ 6C48                                      SetABSNormZToDE
 113+ 6C48 DD 73 1E DD >                        ld     (ix+30),de
 113+ 6C4C 72 1F       >
 114+ 6C4E                                      NormZMul96
 114+ 6C4E 5F          >                        ld      e,a
 114+ 6C4F 16 60       >                        ld      d,96
 114+ 6C51 ED 30       >                        mul     de
 114+ 6C53 7A          >                        ld      a,d                 ; is norm 0,
 114+ 6C54 B3          >                        or      e                   ; if so we can skip
 114+ 6C55 CA 5F 6C    >                        jp      z,.DoneNorm96Z      ; sign check
 114+ 6C58 DD 7E 08    >                        ld      a,(ix+8)            ;
 114+ 6C5B E6 80       >                        and     $80                 ;
 114+ 6C5D B2          >                        or      d
 114+ 6C5E 57          >                        ld      d,a
 114+ 6C5F             >.DoneNorm96Z:
 115+ 6C5F                                      SetNormZ96ToDE                ;
 115+ 6C5F DD 73 18 DD >                        ld     (ix+24),de
 115+ 6C63 72 19       >
 116+ 6C65 7D           .NormaliseY:            ld      a,l
 117+ 6C66 FD 54                                ld      d,iyh
 118+ 6C68 CD 92 6A                             call    AEquAmul256DivD
 119+ 6C6B                                      SetABSNormYToDE
 119+ 6C6B DD 73 1C DD >                        ld     (ix+28),de
 119+ 6C6F 72 1D       >
 120+ 6C71                                      NormYMul96
 120+ 6C71 5F          >                        ld      e,a
 120+ 6C72 16 60       >                        ld      d,96
 120+ 6C74 ED 30       >                        mul     de
 120+ 6C76 7A          >                        ld      a,d                 ; is norm 0,
 120+ 6C77 B3          >                        or      e                   ; if so we can skip
 120+ 6C78 CA 82 6C    >                        jp      z,.DoneNorm96Y      ; sign check
 120+ 6C7B DD 7E 05    >                        ld      a,(ix+5)            ;
 120+ 6C7E E6 80       >                        and     $80                 ;
 120+ 6C80 B2          >                        or      d
 120+ 6C81 57          >                        ld      d,a
 120+ 6C82             >.DoneNorm96Y:
 121+ 6C82                                      SetNormY96ToDE
 121+ 6C82 DD 73 16 DD >                        ld     (ix+22),de
 121+ 6C86 72 17       >
 122+ 6C88 7C           .NormaliseX:            ld      a,h
 123+ 6C89 FD 54                                ld      d,iyh
 124+ 6C8B CD 92 6A                             call    AEquAmul256DivD
 125+ 6C8E                                      SetABSNormXToDE
 125+ 6C8E DD 73 1A DD >.skipSign:              ld     (ix+26),de
 125+ 6C92 72 1B       >
 126+ 6C94                                      NormXMul96
 126+ 6C94 5F          >                        ld      e,a
 126+ 6C95 16 60       >                        ld      d,96
 126+ 6C97 ED 30       >                        mul     de
 126+ 6C99 7A          >                        ld      a,d                 ; is norm 0,
 126+ 6C9A B3          >                        or      e                   ; if so we can skip
 126+ 6C9B CA A5 6C    >                        jp      z,.DoneNorm96X      ; sign check
 126+ 6C9E DD 7E 02    >                        ld      a,(ix+2)            ;
 126+ 6CA1 E6 80       >                        and     $80                 ;
 126+ 6CA3 B2          >                        or      d
 126+ 6CA4 57          >                        ld      d,a
 126+ 6CA5             >.DoneNorm96X:
 127+ 6CA5                                      SetNormX96ToDE
 127+ 6CA5 DD 73 14 DD >                        ld     (ix+20),de
 127+ 6CA9 72 15       >
 128+ 6CAB C9                                   ret
 129+ 6CAC
# file closed: asm_normalise24.asm
 135  6CAC                  SAVENEX OPEN "n24test.nex", EliteNextStartup , TopOfStack
 136  6CAC                  SAVENEX CFG  0,0,0,1
 137  6CAC                  SAVENEX AUTO
 138  6CAC                  SAVENEX CLOSE
 139  6CAC
 140  6CAC
# file closed: n24test.asm
