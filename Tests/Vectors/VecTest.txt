# file opened: VecTest.asm
   1  0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
   2  0000                              DISPLAY "3D Test Code"
   3  0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
   4  0000                              DISPLAY "TODO: Odd Single pixel bug "
   5  0000                  DEVICE ZXSPECTRUMNEXT
   6  0000                  SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
   7  0000
   8  0000
   9  0000                  DEFINE  SHIP_DRAW_FULL_SCREEN 1
  10  0000                  DEFINE  USE_NORMALISE_IX  1
  11  0000                  DEFINE  INTERRUPS_DISABLE 1
  12  0000                  DEFINE  DEBUG_NO_TACTICS_CODE 1
  13  0000               CSPECTMAP VecTest.map
  14  0000               OPT --zxnext=cspect --syntax=a --reversepop
  15  0000              ;-- Key Definitions
  16  0000              ;   Q/A pitch       O/P roll        W/A Thrust
  17  0000              ;   T/G ship pitch, F/H ship roll   U/J Ship Thrust
  18  0000              ;   P   Cycle through ships
  19  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  20  0000              ; Game Defines
  21  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  22  0000              ; Colour Defines
  23  0000                                      INCLUDE "../../Hardware/L1ColourDefines.asm"
# file opened: ../../Hardware/L1ColourDefines.asm
   1+ 0000
   2+ 0000              L1ColourInkBlack        EQU %00000000
   3+ 0000              L1ColourInkBlue         EQU %00000001
   4+ 0000              L1ColourInkRed          EQU %00000010
   5+ 0000              L1ColourInkMagenta      EQU %00000011
   6+ 0000              L1ColourInkGreen        EQU %00000100
   7+ 0000              L1ColourInkCyan         EQU %00000101
   8+ 0000              L1ColourInkYellow       EQU %00000110
   9+ 0000              L1ColourInkWhite        EQU %00000111
  10+ 0000              L1ColourPaperBlack      EQU %00000000
  11+ 0000              L1ColourPaperBlue       EQU %00001000
  12+ 0000              L1ColourPaperRed        EQU %00010000
  13+ 0000              L1ColourPaperMagenta    EQU %00011000
  14+ 0000              L1ColourPaperGreen      EQU %00100000
  15+ 0000              L1ColourPaperCyan       EQU %00101000
  16+ 0000              L1ColourPaperYellow     EQU %00110000
  17+ 0000              L1ColourPaperWhite      EQU %00111000
  18+ 0000              L1ColourFlash           EQU %10000000
  19+ 0000              L1ColourBright          EQU %01000000
  20+ 0000              ;----------------------------------------------------------------------------------------------------------------------------------
  21+ 0000              ; Screen Specific Colour Defines
  22+ 0000              L1InvHighlight          EQU L1ColourBright | L1ColourPaperRed   | L1ColourInkYellow
  23+ 0000              L1InvLowlight           EQU                  L1ColourPaperBlack | L1ColourInkWhite
# file closed: ../../Hardware/L1ColourDefines.asm
  24  0000                                      INCLUDE "../../Hardware/L2ColourDefines.asm"
# file opened: ../../Hardware/L2ColourDefines.asm
   1+ 0000              L2ColourBLACK           EQU   0
   2+ 0000              L2ColourRED_1           EQU 224                 ; RGB 255,  0,  0
   3+ 0000              L2ColourRED_2           EQU 192                 ; RGB 218,  0,  0
   4+ 0000              L2ColourRED_3           EQU 160                 ; RGB 182,  0,  0
   5+ 0000              L2ColourRED_4           EQU 128                 ; RGB 145,  0,  0
   6+ 0000              L2ColourRED_5           EQU  96                 ; RGB 109,  0,  0
   7+ 0000              L2ColourRED_6           EQU  64                 ; RGB  72,  0,  0
   8+ 0000              L2ColourRED_7           EQU  32                 ; RGB  36,  0,  0
   9+ 0000              L2ColourYELLOW_1        EQU 252                 ; RGB 255,255,  0
  10+ 0000              L2ColourYELLOW_2        EQU 216                 ; RGB 218,218,  0
  11+ 0000              L2ColourYELLOW_3        EQU 180                 ; RGB 182,182,  0
  12+ 0000              L2ColourYELLOW_4        EQU 144                 ; RGB 145,145,  0
  13+ 0000              L2ColourYELLOW_5        EQU 108                 ; RGB 109.109,  0
  14+ 0000              L2ColourYELLOW_6        EQU  72                 ; RGB  72, 72,  0
  15+ 0000              L2ColourYELLOW_7        EQU  36                 ; RGB  36, 36,  0
  16+ 0000              L2ColourGREEN_1		    EQU  28                 ; RGB   0,255,  0
  17+ 0000              L2ColourGREEN_2		    EQU  24                 ; RGB   0,218,  0
  18+ 0000              L2ColourGREEN_3		    EQU  16                 ; RGB   0,145,  0
  19+ 0000              L2ColourGREEN_4         EQU  12                 ; RGB   0,109,  0
  20+ 0000              L2ColourGREEN_5         EQU   8                 ; RGB   0, 72,  0
  21+ 0000              L2ColourGREEN_6         EQU   4                 ; RGB   0, 36,  0
  22+ 0000              L2ColourBLUE_1          EQU   3                 ; RGB 0,0,255
  23+ 0000              L2ColourBLUE_2          EQU   2                 ; RGB 0,0,170
  24+ 0000              L2ColourBLUE_3          EQU   1                 ; RGB 0,0,85
  25+ 0000
  26+ 0000
  27+ 0000              L2ColourWHITE_1         EQU 255                 ; RGB 255,255,255
  28+ 0000              L2ColourWHITE_2         EQU 146
  29+ 0000              L2ColourGREY_1		    EQU L2ColourWHITE_2
  30+ 0000              L2ColourGREY_2		    EQU 109
  31+ 0000              L2ColourGREY_3		    EQU  73
  32+ 0000              L2ColourGREY_4		    EQU  37
  33+ 0000
  34+ 0000              L2ColourGREEN_MB        EQU  29                 ;RGB 0,255,85
  35+ 0000              L2ColourGREEN_MR        EQU 124                 ;RGB 109.255,0
  36+ 0000              L2ColourCREAM_1         EQU 218                 ; RGB 218,218,170
  37+ 0000              L2ColourCREAM_2         EQU 182                 ; RGB 182,182,170
  38+ 0000              L2ColourCREAM_3         EQU 146                 ; RGB 145,145,170
  39+ 0000
  40+ 0000              L2ColourTRANSPARENT     EQU 227                 ; RGB 255,  0,255
  41+ 0000              L2ColourMAGENTA_1       EQU 162                 ; RGB 182,  0,170
  42+ 0000              L2ColourMAGENTA_2       EQU 130                 ; RGB 145,  0,170
  43+ 0000              L2ColourMAGENTA_3       EQU  97                 ; RGB 109,  0, 85
  44+ 0000              L2ColourMAGENTA_4       EQU  65                 ; RGB  72,  0, 85
  45+ 0000              L2ColourORANGE_1        EQU 236                 ; RGB
  46+ 0000              L2ColourORANGE_2        EQU 168                 ; RGB
  47+ 0000              L2ColourORANGE_3        EQU  68                 ; RGB
  48+ 0000              L2ColourCYAN_1          EQU  31                 ; RGB   0,255, 255
  49+ 0000              L2ColourCYAN_2          EQU  18                 ; RGB
  50+ 0000              L2ColourCYAN_3          EQU   9                 ; RGB
  51+ 0000              L2ColourPURPLE_1        EQU 109                 ; RGB
  52+ 0000              L2ColourPURPLE_2        EQU  66                 ; RGB
  53+ 0000              L2ColourPURPLE_3        EQU  33                 ; RGB
  54+ 0000              L2ColourPINK_1		    EQU 231                 ; RGB
  55+ 0000              L2ColourPINK_2		    EQU 226                 ; RGB
  56+ 0000              L2ColourPINK_3		    EQU 225                 ; RGB
  57+ 0000              L2ColourPINK_4		    EQU 224                 ; RGB
  58+ 0000
# file closed: ../../Hardware/L2ColourDefines.asm
  25  0000                                      INCLUDE "../../Hardware/register_defines.asm"
# file opened: ../../Hardware/register_defines.asm
   1+ 0000              ; Peripheral 2
   2+ 0000              ENABLE_CPU_SPEED_MODE                   EQU %10000000
   3+ 0000              DIVERT_BEEP_ONLY                        EQU %01000000
   4+ 0000              ENABLE_50_60_SWITCH                     EQU %00100000
   5+ 0000              ENABLE_MMCAUTO_SWITCH                   EQU %00010000
   6+ 0000              ENABLE_MULTIFACE_M1                     EQU %00001000
   7+ 0000              PS2MODE_KEYBOARD                        EQU %00000000
   8+ 0000              PS2MODE_MOUSE                           EQU %00000100
   9+ 0000              AUDIO_CHIPMODE_YM                       EQU %00000000
  10+ 0000              AUDIO_CHIPMODE_AY                       EQU %00000001
  11+ 0000              AUDIO_CHIPMODE_DISABLED                 EQU %00000010
  12+ 0000              INTERNAL_SPEAKER_ENABLE                 EQU %00010000
  13+ 0000              ; Peripheral 3
  14+ 0000              UNLOCK_PORT_7FFD_PAGING                 EQU %10000000
  15+ 0000              DISABLE_RAM_IO_CONTENTION               EQU %01000000
  16+ 0000              AY_STEREO_MODE_ACB                      EQU %00100000
  17+ 0000              INTERNAL_SPEAKER                        EQU %00010000
  18+ 0000              ENABLE_DACS                             EQU %00001000
  19+ 0000              ENABLE_TIMEX_VIDEO_MODE                 EQU %00000100
  20+ 0000              ENABLE_TURBO_SOUND                      EQU %00000010
  21+ 0000              ENABLE_ISSUE2_KEYBOARD                  EQU %00000001
  22+ 0000              ; Peripheral 4
  23+ 0000              ENABLE_AY2_MONO                         EQU %10000000
  24+ 0000              ENABLE_AY1_MONO                         EQU %01000000
  25+ 0000              ENABLE_AY0_MONO                         EQU %00100000
  26+ 0000              SPRITE_ID_LOCKSTEP                      EQU %00010000
  27+ 0000              RESET_DIVMMC_MAPRAM                     EQU %00001000
  28+ 0000              SILENCE_HDMI_AUDIO                      EQU %00000100
  29+ 0000              SCALLINES_50PCT                         EQU %00000001
  30+ 0000              SCANLINES_25PCT                         EQU %00000010
  31+ 0000              SCANLINES_125PCT                        EQU %00000011
  32+ 0000              ; Audio Registers
  33+ 0000              CHANNEL_A_FINE                          EQU 0
  34+ 0000              CHANNEL_A_COARSE                        EQU 1
  35+ 0000              CHANNEL_B_FINE                          EQU 2
  36+ 0000              CHANNEL_B_COARSE                        EQU 3
  37+ 0000              CHANNEL_C_FINE                          EQU 4
  38+ 0000              CHANNEL_C_COARSE                        EQU 5
  39+ 0000              NOISE_PERIOD                            EQU 6
  40+ 0000              TONE_ENABLE                             EQU 7
  41+ 0000              CHANNEL_A_AMPLITUDE                     EQU 8
  42+ 0000              CHANNEL_B_AMPLITUDE                     EQU 9
  43+ 0000              CHANNEL_C_AMPLITUDE                     EQU 10
  44+ 0000              ENVELOPE_PERIOD_FINE                    EQU 11
  45+ 0000              ENVELOPE_PERIOD_COARSE                  EQU 12
  46+ 0000              ENVELOPE_SHAPE                          EQU 13
  47+ 0000
  48+ 0000              ENVELOPE_HOLD_ON                        EQU 1
  49+ 0000              ENVELOPE_ALTERNATE_ON                   EQU 2
  50+ 0000              ENVELOPE_ATTACK_ON                      EQU 4
  51+ 0000              ENVELOPE_CONTINUE_ON                    EQU 8
  52+ 0000
  53+ 0000              ENVELOPE_SHAPE_SINGLE_DECAY             EQU 0                                                                                    ; \____________
  54+ 0000              ENVELOPE_SHAPE_SINGLE_ATTACK            EQU                        ENVELOPE_ATTACK_ON                                            ; /|___________
  55+ 0000              ENVELOPE_SHAPE_REPEAT_DECAY             EQU ENVELOPE_CONTINUE_ON                                                                 ; \|\|\|\|\|\|\
  56+ 0000              ENVELOPE_SHAPE_REPEAT_DECAY_ATTACK      EQU ENVELOPE_CONTINUE_ON |                      ENVELOPE_ALTERNATE_ON                    ; \/\/\/\/\/\/\
  57+ 0000              ENVELOPE_SHAPE_SINGLE_DECAY_HOLD        EQU ENVELOPE_CONTINUE_ON |                      ENVELOPE_ALTERNATE_ON | ENVELOPE_HOLD_ON ; \|-----------
  58+ 0000              ENVELOPE_SHAPE_REPEAT_ATTACK            EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON                                            ; /|/|/|/|/|/|/|
  59+ 0000              ENVELOPE_SHAPE_SINGLE_ATTACK_HOLD       EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON |                         ENVELOPE_HOLD_ON ; /------------
  60+ 0000              ENVELOPE_SHAPE_REPEAT_ATTACK_DECAY      EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON | ENVELOPE_ALTERNATE_ON                    ; /\/\/\/\/\/\/
  61+ 0000
  62+ 0000              ENVELOPE_HOLD                           EQU %00000001
  63+ 0000              ENVELOPE_ALTERNATE                      EQU %00000010
  64+ 0000              ENVELOPE_ATTACK                         EQU %00000010
  65+ 0000              ENVELOPE_CONTINUE                       EQU %00000010
  66+ 0000              ; Sound Control
  67+ 0000              TONE_CHANNEL_A                          EQU %00000001
  68+ 0000              TONE_CHANNEL_B                          EQU %00000010
  69+ 0000              TONE_CHANNEL_C                          EQU %00000100
  70+ 0000              NOISE_CHANNEL_A                         EQU %00001000
  71+ 0000              NOISE_CHANNEL_B                         EQU %00010000
  72+ 0000              NOISE_CHANNEL_C                         EQU %00100000
  73+ 0000              ; Version for AND to enabled (its inverted)
  74+ 0000              TONE_CHANNEL_A_ON                       EQU %11111110
  75+ 0000              TONE_CHANNEL_B_ON                       EQU %11111101
  76+ 0000              TONE_CHANNEL_C_ON                       EQU %11111011
  77+ 0000              NOISE_CHANNEL_A_ON                      EQU %11110111
  78+ 0000              NOISE_CHANNEL_B_ON                      EQU %11101111
  79+ 0000              NOISE_CHANNEL_C_ON                      EQU %11011111
  80+ 0000
  81+ 0000              ; Turbo Sound Control
  82+ 0000              TURBO_MANDATORY                         EQU %10011100
  83+ 0000              TURBO_LEFT                              EQU %01000000
  84+ 0000              TURBO_RIGHT                             EQU %00100000
  85+ 0000              TURBO_CHIP_AY3                          EQU %00000011
  86+ 0000              TURBO_CHIP_AY2                          EQU %00000010
  87+ 0000              TURBO_CHIP_AY1                          EQU %00000001
  88+ 0000
  89+ 0000              IO_LAYER2_PORT                          EQU $123B
  90+ 0000              IO_EXT_BANK_PORT 			            EQU $DFFD ; 57341
  91+ 0000              IO_BANK_PORT                            EQU $7FFD ; 32765
  92+ 0000              REGISTER_NUMBER_PORT					EQU $243B
  93+ 0000              REGISTER_VALUE_PORT						EQU $253B
  94+ 0000              SPRITE_SLOT_PORT						EQU $303B ; port for sprite and pattern index
  95+ 0000              SPRITE_INFO_PORT                        EQU $0057
  96+ 0000              SPRITE_PATTERN_UPLOAD_PORT				EQU $005B
  97+ 0000              TURBO_SOUND_NEXT_CONTROL                EQU $FFFD
  98+ 0000              SOUND_CHIP_REGISTER_WRITE               EQU $BFFD
  99+ 0000              IO_KEYBOARD_PORT                        EQU $FE
 100+ 0000              IO_DATAGEAR_DMA_PORT 		            EQU $6B
 101+ 0000              UART_TX_PORT_PORT                       EQU $133B
 102+ 0000              UART_RX_PORT_PORT                       EQU $143B
 103+ 0000              UART_CONTROL_PORT                       EQU $153B
 104+ 0000              UART_FRAME_PORT                         EQU $163B
 105+ 0000              CTC_CHANNEL1_PORT                       EQU $183B
 106+ 0000              CTC_CHANNEL2_PORT                       EQU $193B
 107+ 0000              CTC_CHANNEL3_PORT                       EQU $1A3B
 108+ 0000              CTC_CHANNEL4_PORT                       EQU $1B3B
 109+ 0000              PLUS_3_MEMORY_PAGING_CONTROL_PORT       EQU $1FFD
 110+ 0000              MB02_DMA_PORT                           EQU $0B
 111+ 0000              SPECDRUM_DAC_OUTPUT                     EQU $DF
 112+ 0000
 113+ 0000              Speed_3_5MHZ                            EQU 0
 114+ 0000              Speed_7MHZ                              EQU 1
 115+ 0000              Speed_14MHZ                             EQU 2
 116+ 0000              Speed_28MHZ                             EQU 3
 117+ 0000
 118+ 0000
 119+ 0000              MACHINE_ID_REGISTER						EQU $00
 120+ 0000              VERSION_REGISTER						EQU $01
 121+ 0000              RESET_REGISTER		    				EQU $02
 122+ 0000              MACHINE_TYPE_REGISTER					EQU $03
 123+ 0000              PAGE_RAM_REGISTER						EQU $04
 124+ 0000              PERIPHERAL_1_REGISTER					EQU $05   ; Sets joystick mode, video frequency and Scandoubler
 125+ 0000              PERIPHERAL_2_REGISTER					EQU $06   ; Enables CPU Speed key, DivMMC, Multiface, Mouse and AY audio.
 126+ 0000              TURBO_MODE_REGISTER						EQU $07
 127+ 0000              PERIPHERAL_3_REGISTER					EQU $08   ; ABC/ACB Stereo, Internal Speaker, SpecDrum, Timex Video Modes, Turbo Sound Next, RAM contention and [un]lock 128k paging
 128+ 0000              PERIPHERAL_4_REGISTER                   EQU $09   ; Sets scanlines, AY mono output, Sprite-id lockstep, reset DivMMC mapram and disable HDMI audio
 129+ 0000              PERIPHERAL_5_REGISTER                   EQU $0A  ; Mouse
 130+ 0000              CORE_VERSION_REGISTER                   EQU $0E
 131+ 0000              ANTI_BRICK_SYSTEM_REGISTER				EQU $10
 132+ 0000              VIDEO_TIMING_REGISTER                   EQU $11
 133+ 0000              LAYER2_RAM_PAGE_REGISTER				EQU $12
 134+ 0000              LAYER2_RAM_SHADOW_REGISTER      		EQU $13
 135+ 0000              TRANSPARENCY_COLOUR_REGISTER			EQU $14
 136+ 0000              SPRITE_LAYERS_SYSTEM_REGISTER			EQU $15
 137+ 0000              LAYER2_OFFSET_X_REGISTER				EQU $16
 138+ 0000              LAYER2_OFFSET_Y_REGISTER				EQU $17
 139+ 0000              CLIP_WINDOW_LAYER2_REGISTER				EQU $18
 140+ 0000              CLIP_WINDOW_SPRITES_REGISTER			EQU $19
 141+ 0000              CLIP_WINDOW_ULA_REGISTER				EQU $1A
 142+ 0000              CLIP_WINDOW_TILEMAP_REGISTER            EQU $1B
 143+ 0000              CLIP_WINDOW_CONTROL_REGISTER			EQU $1C
 144+ 0000              ;29 not used
 145+ 0000              ACTIVE_VIDEO_LINE_MSB_REGISTER			EQU $1E
 146+ 0000              ACTIVE_VIDEO_LINE_LSB_REGISTER			EQU $1F
 147+ 0000              ; 32 to 34 not used
 148+ 0000              LINE_INTERRUPT_CONTROL_REGISTER			EQU $22
 149+ 0000              LINE_INTERRUPT_VALUE_LSB_REGISTER		EQU $23
 150+ 0000              ULA_X_OFFSET_REGISTER                   EQU $26
 151+ 0000              ULA_Y_OFFSET_REGSITER                   EQU $27
 152+ 0000              KEYMAP_HIGH_ADDRESS_REGISTER			EQU $28
 153+ 0000              KEYMAP_LOW_ADDRESS_REGISTER				EQU $29
 154+ 0000              KEYMAP_HIGH_DATA_REGISTER				EQU $2A
 155+ 0000              KEYMAP_LOW_DATA_REGISTER				EQU $2B
 156+ 0000              DAC_B_MIRROR_REGISTER                   EQU $2C
 157+ 0000              DAC_AB_MIRROR_REGISTER                  EQU $2D
 158+ 0000              DAC_C_MORROR_REGISTER                   EQU $2E
 159+ 0000              TILEMAP_OFFSET_XMSB_REGISTER            EQU $2F
 160+ 0000              TILEMAP_OFFSET_XLSB_REGISTER            EQU $30
 161+ 0000              TILEMAP_OFFSET_YMSB_REGISTER            EQU $31
 162+ 0000              LORES_OFFSET_X_REGISTER					EQU $32
 163+ 0000              LORES_OFFSET_Y_REGISTER					EQU $33
 164+ 0000              SPRITE_PORT_INDEX_REGISTER              EQU $34
 165+ 0000              SPRITE_PORT_ATTR0_REGISTER              EQU $35
 166+ 0000              SPRITE_PORT_ATTR1_REGISTER              EQU $36
 167+ 0000              SPRITE_PORT_ATTR2_REGISTER              EQU $37
 168+ 0000              SPRITE_PORT_ATTR3_REGISTER              EQU $38
 169+ 0000              SPRITE_PORT_ATTR4_REGISTER              EQU $39
 170+ 0000              PALETTE_INDEX_REGISTER					EQU $40
 171+ 0000              PALETTE_VALUE_8BIT_REGISTER				EQU $41
 172+ 0000              PALETTE_FORMAT_REGISTER					EQU $42
 173+ 0000              PALETTE_CONTROL_REGISTER				EQU $43
 174+ 0000              PALETTE_VALUE_9BIT_REGISTER				EQU $44
 175+ 0000              TRANSPARENCY_COLOUR_FALLBACK_REGISTER   EQU $4A
 176+ 0000              SPRITES_TRANSPARENCY_INDEX_REGISTER     EQU $4B
 177+ 0000              TILEMAP_TRANSPARENCY_INDEX_REGISTER     EQU $4C
 178+ 0000              ; 72 to 79 unused
 179+ 0000              MMU_SLOT_0_REGISTER						EQU $50
 180+ 0000              MMU_SLOT_1_REGISTER						EQU $51
 181+ 0000              MMU_SLOT_2_REGISTER						EQU $52
 182+ 0000              MMU_SLOT_3_REGISTER						EQU $53
 183+ 0000              MMU_SLOT_4_REGISTER						EQU $54
 184+ 0000              MMU_SLOT_5_REGISTER						EQU $55
 185+ 0000              MMU_SLOT_6_REGISTER						EQU $56
 186+ 0000              MMU_SLOT_7_REGISTER						EQU $57
 187+ 0000              ; 88 to 95 unused
 188+ 0000              COPPER_DATA_REGISTER					EQU $60
 189+ 0000              COPPER_CONTROL_LOW_REGISTER				EQU $61
 190+ 0000              COPPER_CONTROL_HIGH_REGISTER			EQU $62
 191+ 0000              COPPER_DATA_16BIT_WRITE_REGISTER        EQU $63
 192+ 0000              VERTICAL_VIDEO_LINE_OFFSET_REGISTER     EQU $64
 193+ 0000              ULA_CONTROL_REGISTER                    EQU $68
 194+ 0000              DISPLAY_CONTROL_1_REGISTER              EQU $69
 195+ 0000              LORES_CONTROL_REGISTER                  EQU $6A
 196+ 0000              TILEMAP_CONTROL_REGISTER                EQU $6B
 197+ 0000              DEFAULT_TILEMAP_ATTRIBUTE_REGISTER      EQU $6C
 198+ 0000              ; 109 unused
 199+ 0000              TILEMAP_BASE_ADDRESS_REGISTER           EQU $6E
 200+ 0000              TILE_DEFINITIONS_BASE_ADDRESS_REGISTER  EQU $6F
 201+ 0000              LAYER_2_CONTROL_REGISTER                EQU $70
 202+ 0000              LAYER_2_X_OFFSET_MSB_REGISTER           EQU $71
 203+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_0_WITH_INC EQU $75
 204+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_1_WITH_INC EQU $76
 205+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_2_WITH_INC EQU $77
 206+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_3_WITH_INC EQU $78
 207+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_4_WITH_INC EQU $79
 208+ 0000              USER_STORAGE_0_REGISTER                 EQU $7F ; general purpose variable, e.g. for copper
 209+ 0000              EXPANSION_BUS_ENABLE_REGISTER           EQU $80
 210+ 0000              EXPANSION_BUS_CONTROL_REGISTER          EQU $81
 211+ 0000              INTERNAL_PORT_DECODING_B0_7_REGISTER    EQU $82
 212+ 0000              INTERNAL_PORT_DECODING_B8_15_REGISTER   EQU $83
 213+ 0000              INTERNAL_PORT_DECODING_B16_23_REGISTER  EQU $84
 214+ 0000              INTERNAL_PORT_DECODING_B24_31_REGISTER  EQU $85
 215+ 0000              EXPANSION_BUS_DECODING_B0_7_REGISTER    EQU $86
 216+ 0000              EXPANSION_BUS_DECODING_B8_15_REGISTER   EQU $87
 217+ 0000              EXPANSION_BUS_DECODING_B16_23_REGISTER  EQU $88
 218+ 0000              EXPANSION_BUS_DECODING_B24_31_REGISTER  EQU $89
 219+ 0000              EXPANSION_BUS_IO_PROPAGE_REGISTER       EQU $8A
 220+ 0000              ALTERNATE_ROM_REGISTER                  EQU $8C
 221+ 0000              MEMORY_MAPPING_REGISTER                 EQU $8E
 222+ 0000              PI_GPI_OUTPUT_ENABLE_0_REIGISTER        EQU $98
 223+ 0000              PI_GPI_OUTPUT_ENABLE_1_REIGISTER        EQU $99
 224+ 0000              PI_GPI_OUTPUT_ENABLE_2_REIGISTER        EQU $9A
 225+ 0000              PI_GPI_OUTPUT_ENABLE_3_REIGISTER        EQU $9B
 226+ 0000              PI_PERPIPHERAL_ENABLE_REGISTER          EQU $A0
 227+ 0000              PI_I2S_AUDIO_CONTROL_REGISTER           EQU $A2
 228+ 0000              PI_I2S_CLOCK_DIVIDE_REGISTER            EQU $A3
 229+ 0000              ESP_WIFI_GPIO_OUTPUT_REGISTER           EQU $A8
 230+ 0000              ESP_WIFI_GPIO_REGISTER                  EQU $A9
 231+ 0000              EXTENDED_KEYS_0_REGISTER                EQU $B0
 232+ 0000              EXTENDED_KEYS_1_REGISTER                EQU $B1
 233+ 0000              DIVMMC_TRAP_ENABLE_1                    EQU $B2
 234+ 0000              DIVMMC_TRAP_ENABLE_2                    EQU $B4
 235+ 0000              DEBUG_LED_CONTROL_REGISTER              EQU $FF
 236+ 0000
 237+ 0000              INTERUPT_CONTROL                        EQU $0C ; Interrupt control
 238+ 0000              NMI_RETURN_LSB				            EQU	$0C2	; NMI Return Address LSB
 239+ 0000              NMI_RETURN_MSB				            EQU	$0C3	; NMI Return Address MSB
 240+ 0000              INTERRUPT_EN0				            EQU	$0C4	; INT EN 0
 241+ 0000              INTERRUPT_EN1				            EQU	$0C5	; INT EN 1
 242+ 0000              INTERRUPT_EN2				            EQU	$0C6	; INT EN 2
 243+ 0000              INTERRUPT_ST0				            EQU	$0C8	; INT status 0
 244+ 0000              INTERRUPT_ST1				            EQU	$0C9	; INT status 1
 245+ 0000              INTERRUPT_ST2				            EQU	$0CA	; INT status 2
 246+ 0000              INTERRUPT_DM0				            EQU	$0CC	; INT DMA EN 0
 247+ 0000              INTERRUPT_DM1				            EQU	$0CD	; INT DMA EN 1
 248+ 0000              INTERRUPT_DM2				            EQU	$0CE	; INT DMA EN 2
 249+ 0000              CTC_CHANNEL_0				            EQU	$183B	; CTC channel 0 port
 250+ 0000              CTC_CHANNEL_1				            EQU	$193B	; CTC channel 1 port
 251+ 0000              CTC_CHANNEL_2				            EQU	$1A3B	; CTC channel 2 port
 252+ 0000              CTC_CHANNEL_3				            EQU	$1B3B	; CTC channel 3 port
 253+ 0000              CTC_CHANNEL_4				            EQU	$1C3B	; CTC channel 4 port
 254+ 0000              CTC_CHANNEL_5				            EQU	$1D3B	; CTC channel 5 port
 255+ 0000              CTC_CHANNEL_6				            EQU	$1E3B	; CTC channel 6 port
 256+ 0000              CTC_CHANNEL_7				            EQU	$1F3B	; CTC channel 7 port
 257+ 0000              CTCBASE                                 EQU $c0		; MSB Base address of buffer
 258+ 0000              CTCSIZE                                 EQU $04 	; MSB buffer length
 259+ 0000              CTCEND                                  EQU CTCBASE+(CTCSIZE*2)
 260+ 0000
 261+ 0000
 262+ 0000              DEBUG_LEDS_REGISTER						EQU 255
 263+ 0000
 264+ 0000
 265+ 0000              GetNextRegSaveBC:	MACRO register
 266+ 0000 ~                                push bc
 267+ 0000 ~                                ld bc,$243B
 268+ 0000 ~                                ld a,register
 269+ 0000 ~                                out (c),a
 270+ 0000 ~                                inc b
 271+ 0000 ~                                in a,(c)
 272+ 0000 ~                                pop bc
 273+ 0000                                  ENDM
 274+ 0000
 275+ 0000              GetNextReg:	MACRO register
 276+ 0000 ~                        ld bc,$243B
 277+ 0000 ~                        ld a,register
 278+ 0000 ~                        out (c),a
 279+ 0000 ~                        inc b
 280+ 0000 ~                        in a,(c)
 281+ 0000                          ENDM
 282+ 0000
# file closed: ../../Hardware/register_defines.asm
  26  0000                                      INCLUDE "../../Layer2Graphics/layer2_defines.asm"
# file opened: ../../Layer2Graphics/layer2_defines.asm
   1+ 0000
   2+ 0000
   3+ 0000              LAYER2_SHIFTED_SCREEN_TOP  	 equ 0
   4+ 0000              LAYER2_SHIFTED_SCREEN_MIDDLE equ $40
   5+ 0000              LAYER2_SHIFTED_SCREEN_BOTTOM equ $80
   6+ 0000
   7+ 0000              ; note hi byte is not decoded on DMA port so can out OUTIR
   8+ 0000
   9+ 0000              IO_SPRITE_SLOT_PORT 		 equ 12347
  10+ 0000              IO_SPRITE_PATTERN_PORT       equ 91
  11+ 0000              IO_SPRITE_ATTRIBUTES_PORT    equ 87
  12+ 0000
  13+ 0000              LAYER2_VISIBLE_MASK 		equ $02
  14+ 0000              ; DEBUG 0 for always write to primary 08 for double buffering
  15+ 0000                  IFDEF DOUBLEBUFFER
  16+ 0000 ~            LAYER2_SHADOW_SCREEN_MASK 	equ $08
  17+ 0000                  ELSE
  18+ 0000              LAYER2_SHADOW_SCREEN_MASK 	equ $00
  19+ 0000                  ENDIF
  20+ 0000              LAYER2_READ_ENABLE_MASK 	equ %00000100
  21+ 0000              LAYER2_WRITE_ENABLE_MASK 	equ %00000001
  22+ 0000              LAYER2_READ_WRITE_MASK      equ %00000101
  23+ 0000              LAYER2_SCREEN_SECTION_MASK 	equ $03
  24+ 0000              LAYER2_SCREEN_SECTION_SHIFT equ 6
  25+ 0000
  26+ 0000              LAYER2_DISABLE_MEM_WRITE    equ %11111110
  27+ 0000              LAYER2_DISABLE_MEM_READ     equ %11111011
  28+ 0000              LAYER2_DISABLE_MEM_ACCESS   equ %11111010
  29+ 0000
  30+ 0000              LAYER2_SCREEN_BANK1          equ 8
  31+ 0000              LAYER2_SCREEN_BANK2          equ 9
  32+ 0000              LAYER2_SCREEN_BANK3          equ 10
  33+ 0000              LAYER2_SCREEN_BANK4          equ 11     ; used by 320 and 640 mode
  34+ 0000              LAYER2_SCREEN_BANK5          equ 12     ; used by 320 and 640 mode
  35+ 0000              LAYER2_SHADOW_BANK1          equ 13
  36+ 0000              LAYER2_SHADOW_BANK2          equ 14
  37+ 0000              LAYER2_SHADOW_BANK3          equ 15
  38+ 0000              LAYER2_SHADOW_BANK4          equ 16     ; used by 320 and 640 mode
  39+ 0000              LAYER2_SHADOW_BANK5          equ 17     ; used by 320 and 640 mode
  40+ 0000
  41+ 0000              SCREEN_HEIGHT 				 equ 192
  42+ 0000              SCREEN_RAM_BASE				 equ $0000
  43+ 0000              SCREEN_HOZ_MIN_PIX		     equ 10
  44+ 0000
  45+ 0000              SPRITES_VISIBLE_MASK         equ $01
  46+ 0000              SPRITES_ON_BORDER_MASK       equ $02
  47+ 0000              LAYER_PRIORITIES_MASK        equ $07
  48+ 0000              LORES_MODE_MASK              equ $80
  49+ 0000              LAYER_PRIORITIES_SHIFT       equ 2
  50+ 0000
  51+ 0000              LAYER_PRIORITIES_S_L_U 		equ 0
  52+ 0000              LAYER_PRIORITIES_L_S_U 		equ 1
  53+ 0000              LAYER_PRIORITIES_S_U_L  	equ 2
  54+ 0000              LAYER_PRIORITIES_L_U_S 		equ 3
  55+ 0000              LAYER_PRIORITIES_U_S_L 		equ 4
  56+ 0000              LAYER_PRIORITIES_U_L_S 		equ 5
  57+ 0000
  58+ 0000              DMA_WRO_BLOCK_PORTA_A2B_XFR  equ $7D
  59+ 0000              DMA_WRO_BLOCK_PORTA_B2A_XFR  equ $79
  60+ 0000              DMA_WR1_P1FIXED_MEMORY       equ $24
  61+ 0000              DMA_WR1_P1DEC_MEMORY         equ $04
  62+ 0000              DMA_WR1_P1INC_MEMORY         equ $14
  63+ 0000              DMA_WR2_P2FIXED_MEMORY       equ $20
  64+ 0000              DMA_WR2_P2DEC_MEMORY         equ $00
  65+ 0000              DMA_WR2_P2INC_MEMORY         equ $10
  66+ 0000              DMA_WR4_CONT_MODE            equ $AD
  67+ 0000              DMA_WR4_BURST_MODE           equ $CD
  68+ 0000              DMA_RESET                    equ $c3
  69+ 0000              DMA_RESET_PORT_A_TIMING      equ $c7
  70+ 0000              DMA_RESET_PORT_B_TIMING      equ $cb
  71+ 0000              DMA_LOAD                     equ $cf
  72+ 0000              DMA_CONTINUE                 equ $d3
  73+ 0000              DMA_DISABLE_INTERUPTS        equ $af
  74+ 0000              DMA_ENABLE_INTERUPTS         equ $ab
  75+ 0000              DMA_RESET_DISABLE_INTERUPTS  equ $a3
  76+ 0000              DMA_ENABLE_AFTER_RETI        equ $b7
  77+ 0000              DMA_READ_STATUS_BYTE         equ $bf
  78+ 0000              DMA_REINIT_STATUS_BYTE       equ $8b
  79+ 0000              DMA_START_READ_SEQUENCE      equ $a7
  80+ 0000              DMA_FORCE_READY              equ $b3
  81+ 0000              DMA_STOP_AT_END			     equ $82
  82+ 0000              DMA_DISABLE                  equ $83
  83+ 0000              DMA_ENABLE                   equ $87
  84+ 0000              DMA_WRITE_REGISTER_COMMAND   equ $bb
  85+ 0000              DMA_BURST                    equ $cd
  86+ 0000              DMA_CONTINUOUS               equ $ad
  87+ 0000              ZXN_DMA_PORT                 equ $6b
  88+ 0000
  89+ 0000
  90+ 0000              COLOUR_TRANSPARENT			 equ $E3
  91+ 0000
  92+ 0000
  93+ 0000
  94+ 0000
# file closed: ../../Layer2Graphics/layer2_defines.asm
  27  0000                                      INCLUDE	"../../Hardware/memory_bank_defines.asm"
# file opened: ../../Hardware/memory_bank_defines.asm
   1+ 0000
   2+ 0000              membanksize			    equ	$1FFF
   3+ 0000
   4+ 0000              StartOfBank     	    equ $0000
   5+ 0000
   6+ 0000              membank0 			    equ $0000
   7+ 0000              dmaCopySrcAddr		    equ	$0000
   8+ 0000              MathsTablesAddr         equ $0000
   9+ 0000              membank1 			    equ $2000
  10+ 0000              membank2 			    equ $4000
  11+ 0000              membank3 			    equ $6000
  12+ 0000              membank4 			    equ $8000
  13+ 0000              membank5 			    equ $a000
  14+ 0000              membank6 			    equ $c000
  15+ 0000              ScreenBank              equ $c000
  16+ 0000              MenuGalChtAddr          equ $c000
  17+ 0000              MenuEquipSAddr          equ $c000
  18+ 0000              MenuInventAddr          equ $c000
  19+ 0000              MenuMarketAddr          equ $c000
  20+ 0000              DispMarketAddr          equ $c000
  21+ 0000              MenuShrChtAddr          equ $c000
  22+ 0000              MenuStatusAddr          equ $c000
  23+ 0000              MenuSystemAddr          equ $c000
  24+ 0000              ViewFrontAddr           equ $c000
  25+ 0000              SunBankAddr             equ $c000
  26+ 0000              PlanetBankAddr          equ $c000
  27+ 0000              SpaceStationBankAddr    equ $c000
  28+ 0000              UniverseBankAddr	    equ $c000
  29+ 0000              LaunchShipAddr          equ $c000
  30+ 0000              membank7 			    equ $e000
  31+ 0000              L1membankAddr   	    equ $e000
  32+ 0000              L2membankAddr   	    equ $e000
  33+ 0000              ShipModelsAddr	        equ $e000
  34+ 0000              SpritemembankAddr       equ $e000
  35+ 0000              ResetUniverseAddr       equ $e000
  36+ 0000              StockTableAddr	        equ $e000
  37+ 0000              CommanderAddr           equ $e000
  38+ 0000              LAYER2Addr              equ $e000
  39+ 0000              LAYER1Addr              equ $e000
  40+ 0000              SPRITEAddr              equ $e000
  41+ 0000              ConsoleImageAddr        equ $e000
  42+ 0000              GalaxyDataAddr          equ $e000
  43+ 0000              SoundAddr               equ $e000
  44+ 0000              KeyboardAddr            equ $e000
  45+ 0000              MathsBankedFnsAddr      equ $0000
  46+ 0000
  47+ 0000              EXSDOSMMU0              equ MMU_SLOT_0_REGISTER
  48+ 0000              MathsTablesMMU          equ MMU_SLOT_0_REGISTER
  49+ 0000              MathsBankedFnsMMU       equ MMU_SLOT_0_REGISTER
  50+ 0000              ShipReadMMU             equ MMU_SLOT_0_REGISTER
  51+ 0000              DMACpySourceMMU		    equ	MMU_SLOT_0_REGISTER
  52+ 0000              EXSDOSMMU1              equ MMU_SLOT_1_REGISTER
  53+ 0000              SunMMU 		            equ MMU_SLOT_6_REGISTER
  54+ 0000              PlanetMMU 		        equ MMU_SLOT_6_REGISTER
  55+ 0000              UniverseMMU 		    equ MMU_SLOT_6_REGISTER
  56+ 0000              SpaceStationMMU         equ MMU_SLOT_6_REGISTER
  57+ 0000              ScreenBankMMU           equ MMU_SLOT_6_REGISTER
  58+ 0000              MenuEquipSMMU           equ MMU_SLOT_6_REGISTER
  59+ 0000              MenuShrChtMMU           equ MMU_SLOT_6_REGISTER
  60+ 0000              MenuGalChtMMU           equ MMU_SLOT_6_REGISTER
  61+ 0000              MenuInventMMU           equ MMU_SLOT_6_REGISTER
  62+ 0000              MenuSystemMMU           equ MMU_SLOT_6_REGISTER
  63+ 0000              MenuMarketMMU           equ MMU_SLOT_6_REGISTER
  64+ 0000              DispMarketMMU           equ MMU_SLOT_6_REGISTER
  65+ 0000              MenuStatusMMU           equ MMU_SLOT_6_REGISTER
  66+ 0000              LaunchShipMMU           equ MMU_SLOT_6_REGISTER
  67+ 0000              L1memMMU       		    equ MMU_SLOT_7_REGISTER
  68+ 0000              L2memMMU       		    equ MMU_SLOT_7_REGISTER
  69+ 0000              SpritememMMU   		    equ MMU_SLOT_7_REGISTER
  70+ 0000              ShipModelMMU  		    equ MMU_SLOT_7_REGISTER
  71+ 0000              ResetUniverseMMU	    equ MMU_SLOT_7_REGISTER
  72+ 0000              CommanderMMU	        equ MMU_SLOT_7_REGISTER
  73+ 0000              StockTableMMU		    equ MMU_SLOT_7_REGISTER
  74+ 0000              ConsoleImageDataMMU	    equ MMU_SLOT_7_REGISTER
  75+ 0000              GalaxyDataMMU	        equ MMU_SLOT_7_REGISTER
  76+ 0000              SoundMMU                equ MMU_SLOT_7_REGISTER
  77+ 0000              KeyboardMMU             equ MMU_SLOT_7_REGISTER
  78+ 0000
  79+ 0000              ; banks 8 to 17 are reserved for layer 2 memory
  80+ 0000              BankResetUniv           equ 49
  81+ 0000              BankMenuShrCht          equ 50
  82+ 0000              BankMenuGalCht          equ 51
  83+ 0000              BankMenuInvent          equ 52
  84+ 0000              BankMenuSystem          equ 53
  85+ 0000              BankMenuMarket          equ 54
  86+ 0000              BankStockTable          equ 55
  87+ 0000              BankCommander           equ 56
  88+ 0000              BankLAYER2              equ 57
  89+ 0000              BankLAYER1              equ 58
  90+ 0000              BankShipModels1         equ 59
  91+ 0000              BankSPRITE              equ 60
  92+ 0000              BankConsole             equ 61
  93+ 0000              BankFrontView           equ 62
  94+ 0000              BankMenuStatus          equ 63
  95+ 0000              BankMenuEquipS          equ 64
  96+ 0000              BankLaunchShip          equ 65
  97+ 0000              BankDispMarket          equ 66
  98+ 0000              BankShipModels2         equ 67
  99+ 0000              BankShipModels3         equ 68
 100+ 0000              BankShipModels4         equ 69
 101+ 0000
 102+ 0000              BankUNIVDATA0           equ 70
 103+ 0000              BankSpaceStationData    equ 70
 104+ 0000              BankUNIVDATA1           equ 71
 105+ 0000              BankUNIVDATA2           equ 72
 106+ 0000              BankUNIVDATA3           equ 73
 107+ 0000              BankUNIVDATA4           equ 74
 108+ 0000              BankUNIVDATA5           equ 75
 109+ 0000              BankUNIVDATA6           equ 76
 110+ 0000              BankUNIVDATA7           equ 77
 111+ 0000              BankUNIVDATA8           equ 78
 112+ 0000              BankUNIVDATA9           equ 79
 113+ 0000              BankUNIVDATA10          equ 80
 114+ 0000              BankUNIVDATA11          equ 81
 115+ 0000              BankUNIVDATA12          equ 82
 116+ 0000              BankSunData             equ 83
 117+ 0000              BankPlanetData          equ 84
 118+ 0000
 119+ 0000              BankGalaxyData0         equ 91
 120+ 0000              BankGalaxyData1         equ 92
 121+ 0000              BankGalaxyData2         equ 93
 122+ 0000              BankGalaxyData3         equ 94
 123+ 0000              BankGalaxyData4         equ 95
 124+ 0000              BankGalaxyData5         equ 96
 125+ 0000              BankGalaxyData6         equ 97
 126+ 0000              BankGalaxyData7         equ 98
 127+ 0000
 128+ 0000              BankMathsTables         equ 99
 129+ 0000              BankSound               equ 100
 130+ 0000              BankKeyboard            equ 101
 131+ 0000              BankMathsBankedFns      equ 102
 132+ 0000
 133+ 0000              BankROM                 equ 255
 134+ 0000
 135+ 0000
# file closed: ../../Hardware/memory_bank_defines.asm
  28  0000                                      INCLUDE "../../Hardware/screen_equates.asm"
# file opened: ../../Hardware/screen_equates.asm
   1+ 0000              ScreenHeight 		equ 192
   2+ 0000              ScreenLastRow       equ ScreenHeight -1
   3+ 0000              ScreenWidth  		equ 256
   4+ 0000              ScreenLastCol       equ ScreenWidth -1
   5+ 0000              ScreenHeightHalf	equ 96
   6+ 0000              ScreenWidthHalf  	equ 128
   7+ 0000              ScreenCenterY		equ 96
   8+ 0000              ScreenCenterX       equ 128
   9+ 0000              ViewHeight          equ 128
  10+ 0000              ViewHeightPlus1     equ 128+1
  11+ 0000              ViewLastRow       	equ ViewHeight -1
  12+ 0000              ViewWidth  			equ 256
  13+ 0000              ViewLastCol         equ ViewWidth -1
  14+ 0000              ViewHeightHalf      equ 63
  15+ 0000              ViewWidthHalf       equ 127
  16+ 0000              ViewCenterY         equ 64
  17+ 0000              ViewCenterX         equ 128
  18+ 0000                                      DISPLAY "TODO: place odler for debugging"
  19+ 0000              ShipColour			equ $FF		; place holder for debugging TODO
  20+ 0000              ScreenL1Bottom      equ $5000
  21+ 0000              ScreenL1BottomLen   equ 32 * 8 * 8
  22+ 0000              ScreenL1AttrBtm     equ $5A00
  23+ 0000              ScreenL1AttrBtmLen  equ 32 * 8
  24+ 0000
# file closed: ../../Hardware/screen_equates.asm
  29  0000                                      INCLUDE "../../Data/ShipModelEquates.asm"
# file opened: ../../Data/ShipModelEquates.asm
   1+ 0000              ScoopDebrisOffset	        equ	0                               ; hull byte#0 high nibble is scoop info, lower nibble is debris spin info
   2+ 0000              MissileLockLoOffset	        equ 1
   3+ 0000              MissileLockHiOffset	        equ 2
   4+ 0000              EdgeAddyOffset		        equ 3
   5+ 0000              LineX4Offset		        equ 5
   6+ 0000              GunVertexOffset		        equ 6
   7+ 0000              ExplosionCtOffset	        equ 7
   8+ 0000              VertexCountOffset           equ 8
   9+ 0000              VertexCtX6Offset	        equ 9
  10+ 0000              EdgeCountOffset		        equ 10
  11+ 0000              BountyLoOffset		        equ 11
  12+ 0000              BountyHiOffset		        equ 12
  13+ 0000              FaceCtX4Offset		        equ 13
  14+ 0000              DotOffset			        equ 14
  15+ 0000              EnergyOffset		        equ 15
  16+ 0000              SpeedOffset			        equ 16
  17+ 0000              FaceAddyOffset		        equ 17
  18+ 0000              QOffset				        equ 19
  19+ 0000              LaserOffset			        equ 20
  20+ 0000              VerticiesAddyOffset         equ 21
  21+ 0000              ShipTypeOffset              equ 23
  22+ 0000              ShipNewBitsOffset           equ 24
  23+ 0000              ShipAIFlagsOffset           equ 25
  24+ 0000              ShipECMFittedChanceOffset   equ 26
  25+ 0000              ShipSolidFlagOffset         equ 27 ; Intially for non cargo these will be garbage
  26+ 0000              ShipSolidFillOffset         equ 28
  27+ 0000              ShipSolidLenOffset          equ 29
  28+ 0000              ShipDataLength              equ ShipECMFittedChanceOffset+1
  29+ 0000
  30+ 0000              CobraTablePointer           equ 43
  31+ 0000              ;29 faulty
  32+ 0000              BankThreshold               equ 16
  33+ 0000
  34+ 0000              ShipTableALast              equ 23
  35+ 0000              ShipTableBLast              equ 39
  36+ 0000              ShipTableCLast              equ 55
  37+ 0000
# file closed: ../../Data/ShipModelEquates.asm
  30  0000                                      INCLUDE "../../Macros/graphicsMacros.asm"
# file opened: ../../Macros/graphicsMacros.asm
   1+ 0000              ; General Graphics macros
   2+ 0000              DoubleBufferIfPossible: MACRO
   3+ 0000 ~                                    IFDEF DOUBLEBUFFER
   4+ 0000 ~                                        MMUSelectLayer2
   5+ 0000 ~                                        call  l2_cls
   6+ 0000 ~                                        call  l2_flip_buffers
   7+ 0000 ~                                    ENDIF
   8+ 0000                                      ENDM
   9+ 0000
  10+ 0000              DoubleBuffer320IfPossible: MACRO
  11+ 0000 ~                                    IFDEF DOUBLEBUFFER
  12+ 0000 ~                                        MMUSelectLayer2
  13+ 0000 ~                                        call  l2_320_cls
  14+ 0000 ~                                        call  l2_flip_buffers
  15+ 0000 ~                                    ENDIF
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              DoubleBuffer640IfPossible: MACRO
  19+ 0000 ~                                    IFDEF DOUBLEBUFFER
  20+ 0000 ~                                        MMUSelectLayer2
  21+ 0000 ~                                        call  l2_640_cls
  22+ 0000 ~                                        call  l2_flip_buffers
  23+ 0000 ~                                    ENDIF
  24+ 0000                                      ENDM
  25+ 0000
  26+ 0000
  27+ 0000
  28+ 0000              ErrorEquStepMinusDelta: MACRO   delta_step, delta_value
  29+ 0000 ~                                    ld      hl,(delta_step)
  30+ 0000 ~                                    ld      de,(delta_value)
  31+ 0000 ~                                    ClearCarryFlag
  32+ 0000 ~                                    sbc     hl,de
  33+ 0000 ~                                    ld      (error),hl
  34+ 0000                                      ENDM
  35+ 0000
  36+ 0000              ; we could hold steps and deltas in alternate registers later
  37+ 0000              ErrorPlusStep:          MACRO   delta_step
  38+ 0000 ~                                    ld      hl,(error)
  39+ 0000 ~                                    ld      de,(delta_step)
  40+ 0000 ~                                    add     hl,de
  41+ 0000 ~                                    ld      (error),hl
  42+ 0000                                      ENDM
  43+ 0000
  44+ 0000              ErrorMinusStep:         MACRO   delta_step
  45+ 0000 ~                                    ld      hl,(error)
  46+ 0000 ~                                    ld      de,(delta_step)
  47+ 0000 ~                                    ClearCarryFlag
  48+ 0000 ~                                    sbc     hl,de
  49+ 0000 ~                                    ld      (error),hl
  50+ 0000                                      ENDM
  51+ 0000
  52+ 0000              SetExitFalse:           MACRO
  53+ 0000 ~                                    xor     a
  54+ 0000 ~                                    ld      (set_exit),a
  55+ 0000                                      ENDM
  56+ 0000
  57+ 0000              ; pulls axis high byte to a, returns nz if negative, z if positive
  58+ 0000              IsAxisLT0:              MACRO   axis
  59+ 0000 ~                                    ld      a,(axis+1)
  60+ 0000 ~                                    and     $80
  61+ 0000                                      ENDM
  62+ 0000
  63+ 0000              ; modifies HL, loaded with register, returns z if >=0, nz if negative
  64+ 0000              IsMemld16GTE0           MACRO   mem
  65+ 0000 ~                                    ld      hl, (mem)
  66+ 0000 ~                                    bit     7,h
  67+ 0000                                      ENDM
  68+ 0000
  69+ 0000              IsMemNegative8JumpFalse:MACRO   mem, target
  70+ 0000 ~                                    ld      a,(mem)
  71+ 0000 ~                                    and     $80
  72+ 0000 ~                                    jp      z, target
  73+ 0000                                      ENDM
  74+ 0000
  75+ 0000              IsMem16GT0JumpFalse:    MACRO   mem, target
  76+ 0000 ~                                    ld      hl, (mem)
  77+ 0000 ~                                    bit     7,h
  78+ 0000 ~                                    jp      nz, target
  79+ 0000 ~                                    ld      a,h
  80+ 0000 ~                                    or      l
  81+ 0000 ~                                    jp      z,  target
  82+ 0000                                      ENDM
  83+ 0000
  84+ 0000              FloorHLdivDETarget:     MACRO   target
  85+ 0000 ~                                    call    l_div                   ;       .  (so we swap and call l_div) HL = DE / HL, DE = DE % HL
  86+ 0000 ~                                    ld      a,d                     ;       .  get bit 7 into carry (set if negative)
  87+ 0000 ~                                    sla     a                       ;
  88+ 0000 ~                                    jr      nc,.FloorIsOK           ;
  89+ 0000 ~            .FloorAdjust:           dec     hl                      ;       .  if remainder >= adjust by 1 for negative
  90+ 0000 ~            .FloorIsOK:             ld      (target),hl             ;       .  now save the msd value
  91+ 0000                                      ENDM
  92+ 0000
# file closed: ../../Macros/graphicsMacros.asm
  31  0000                                      INCLUDE "../../Macros/callMacros.asm"
# file opened: ../../Macros/callMacros.asm
   1+ 0000
   2+ 0000              CallIfAEqNusng:         MACRO   reg,target
   3+ 0000 ~                                    cp      reg
   4+ 0000 ~                                    call	z,target
   5+ 0000                                      ENDM
   6+ 0000
   7+ 0000              CallIfAGTENusng:        MACRO   reg,target
   8+ 0000 ~                                    cp      reg
   9+ 0000 ~                                    call	nc,target
  10+ 0000                                      ENDM
  11+ 0000
  12+ 0000              CallIfAGTEMemusng:      MACRO   reg,target
  13+ 0000 ~                                    ld      hl,reg
  14+ 0000 ~                                    cp      (hl)
  15+ 0000 ~                                    call	nc,target
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              CallIfALTMemusng:       MACRO   reg,target
  19+ 0000 ~                                    ld      hl,reg
  20+ 0000 ~                                    cp      (hl)
  21+ 0000 ~                                    call	c,target
  22+ 0000                                      ENDM
  23+ 0000
  24+ 0000              CallIfALTNusng:         MACRO   reg,target
  25+ 0000 ~                                    cp      reg
  26+ 0000 ~                                    call	c,target
  27+ 0000                                      ENDM
  28+ 0000
  29+ 0000              CallIfMemEqMemusng:     MACRO mem, address, target
  30+ 0000 ~                                    ld      a,(mem)
  31+ 0000 ~                                    ld      hl,address
  32+ 0000 ~                                    cp      (hl)
  33+ 0000 ~                                    call    z,target
  34+ 0000                                      ENDM
  35+ 0000
  36+ 0000              CallIfMemEqNusng:       MACRO mem, value, target
  37+ 0000 ~                                    ld      a,(mem)
  38+ 0000 ~                                    cp      value
  39+ 0000 ~                                    call    z,target
  40+ 0000                                      ENDM
  41+ 0000
  42+ 0000
  43+ 0000              CallIfMemGTENusng:      MACRO mem, value, target
  44+ 0000 ~                                    ld      a,(mem)
  45+ 0000 ~                                    cp      value
  46+ 0000 ~                                    call    nc,target
  47+ 0000                                      ENDM
  48+ 0000
  49+ 0000              CallIfMemTrue:          MACRO mem, target
  50+ 0000 ~                                    ld      a,(mem)
  51+ 0000 ~                                    and     a
  52+ 0000 ~                                    call    z, target
  53+ 0000                                      ENDM
  54+ 0000
  55+ 0000              CallIfMemFalse:         MACRO mem, target
  56+ 0000 ~                                    ld      a,(mem)
  57+ 0000 ~                                    and     a
  58+ 0000 ~                                    call    nz, target
  59+ 0000                                      ENDM
  60+ 0000
  61+ 0000              CallIfMemZero:          MACRO mem, target
  62+ 0000 ~                                    ld      a,(mem)
  63+ 0000 ~                                    and     a
  64+ 0000 ~                                    call    z, target
  65+ 0000                                      ENDM
  66+ 0000
  67+ 0000              CallIfMemNotZero:       MACRO mem, target
  68+ 0000 ~                                    ld      a,(mem)
  69+ 0000 ~                                    and     a
  70+ 0000 ~                                    call    nz, target
  71+ 0000                                      ENDM
  72+ 0000              CallIfATrue:            MACRO target
  73+ 0000 ~                                    and     a
  74+ 0000 ~                                    call    z, target
  75+ 0000                                      ENDM
  76+ 0000
  77+ 0000              CallIfAFalse:           MACRO target
  78+ 0000 ~                                    and     a
  79+ 0000 ~                                    call    nz, target
  80+ 0000                                      ENDM
  81+ 0000
  82+ 0000              CallIfAZero:            MACRO target
  83+ 0000 ~                                    and     a
  84+ 0000 ~                                    call    z, target
  85+ 0000                                      ENDM
  86+ 0000
  87+ 0000              CallIfANotZero:         MACRO target
  88+ 0000 ~                                    and     a
  89+ 0000 ~                                    call    nz, target
  90+ 0000                                      ENDM
# file closed: ../../Macros/callMacros.asm
  32  0000                                      INCLUDE "../../Macros/carryFlagMacros.asm"
# file opened: ../../Macros/carryFlagMacros.asm
   1+ 0000
   2+ 0000              SetCarryFlag:           MACRO
   3+ 0000 ~                                    scf
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              ClearCarryFlag:	        MACRO
   7+ 0000 ~                                    or a
   8+ 0000                                      ENDM
   9+ 0000
  10+ 0000              FlipCarryFlag:          MACRO
  11+ 0000 ~                                    ccf
  12+ 0000                                      ENDM
  13+ 0000
# file closed: ../../Macros/carryFlagMacros.asm
  33  0000                                      INCLUDE "../../Macros/CopyByteMacros.asm"
# file opened: ../../Macros/CopyByteMacros.asm
   1+ 0000              CopyByteAtHLixToA:		MACRO memloc
   2+ 0000 ~            						ex          de,hl                               ; save hl
   3+ 0000 ~            						ld          hl,memloc
   4+ 0000 ~            						add         hl,a
   5+ 0000 ~            						ld          a,(hl)                              ; get XX2[x]
   6+ 0000 ~            						ex          de,hl                               ; get hl back as we need it in loop
   7+ 0000              						ENDM
   8+ 0000
   9+ 0000              ; Increments IYL
  10+ 0000              ; Increments IHL
  11+ 0000              ; Gets value at hl and loads into Parameter 1 address
  12+ 0000
  13+ 0000              CopyByteAtNextHLiyl: 	MACRO memloc
  14+ 0000 ~            						inc         iyl                                 ;
  15+ 0000 ~            						inc         hl                                  ; vertex byte#1
  16+ 0000 ~            						ld          a,(hl)                              ;
  17+ 0000 ~            						ld          (memloc),a                     ; XX15+2 = (V),Y
  18+ 0000              						ENDM
  19+ 0000
  20+ 0000              ;------------------------------------------------------------------------------------------------------------------------------
  21+ 0000              CopyByteAtNextHL:   MACRO targetaddr
  22+ 0000 ~                                inc         hl                                  ; vertex byte#1
  23+ 0000 ~                                ld          a,(hl)                              ;
  24+ 0000 ~                                ld          (targetaddr),a                     ; SunXX15+2 = (V),Y
  25+ 0000                                  ENDM
# file closed: ../../Macros/CopyByteMacros.asm
  34  0000                                      INCLUDE "../../Macros/ldCopyMacros.asm"
# file opened: ../../Macros/ldCopyMacros.asm
   1+ 0000              ZeroA:		            MACRO
   2+ 0000 ~                                    xor a
   3+ 0000                                      ENDM
   4+ 0000
   5+ 0000              SetATrue:               MACRO
   6+ 0000 ~                                    xor     a
   7+ 0000                                      ENDM
   8+ 0000
   9+ 0000              SetAFalse:              MACRO
  10+ 0000 ~                                    ld      a,$FF
  11+ 0000                                      ENDM
  12+ 0000
  13+ 0000              SetMemFalse             MACRO   mem
  14+ 0000 ~                                    ld      a,$FF
  15+ 0000 ~                                    ld      (mem),a
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              SetMemTrue              MACRO   mem
  19+ 0000 ~                                    xor     a
  20+ 0000 ~                                    ld      (mem),a
  21+ 0000                                      ENDM
  22+ 0000
  23+ 0000              SetMemZero:             MACRO   mem
  24+ 0000 ~                                    xor     a
  25+ 0000 ~                                    ld      (mem),a
  26+ 0000                                      ENDM
  27+ 0000
  28+ 0000              SetMemToN:              MACRO   mem,value
  29+ 0000 ~                                    ld      a,value
  30+ 0000 ~                                    ld      (mem),a
  31+ 0000                                      ENDM
  32+ 0000
  33+ 0000              ldCopyStringLen:        MACRO   source, target, strlen
  34+ 0000 ~                                    ld      hl,source
  35+ 0000 ~                                    ld      de, target
  36+ 0000 ~                                    ld      bc, strlen
  37+ 0000 ~                                    ldir
  38+ 0000                                      ENDM
  39+ 0000
  40+ 0000              ldCopyTextAtHLtoDE:     MACRO
  41+ 0000 ~            .CopyLoop:              ld      a,(hl)
  42+ 0000 ~                                    ld      (de),a
  43+ 0000 ~                                    cp      0
  44+ 0000 ~                                    jp      z,.DoneCopy
  45+ 0000 ~                                    inc     hl
  46+ 0000 ~                                    inc     de
  47+ 0000 ~                                    jr      .CopyLoop
  48+ 0000 ~            .DoneCopy:
  49+ 0000                                      ENDM
  50+ 0000
  51+ 0000              ldClearTextLoop:        MACRO   TextSize
  52+ 0000 ~                                    ld      b,a
  53+ 0000 ~                                    ld      a,TextSize
  54+ 0000 ~            .ClearLoop:             ld      (hl),a
  55+ 0000 ~                                    inc     hl
  56+ 0000 ~                                    djnz    .ClearLoop
  57+ 0000                                      ENDM
  58+ 0000
  59+ 0000              ldCopyByte:             MACRO memfrom, memto
  60+ 0000 ~                                    ld       a,(memfrom)
  61+ 0000 ~                                    ld       (memto),a
  62+ 0000                                      ENDM
  63+ 0000
  64+ 0000
  65+ 0000              ldCopyByteABS:          MACRO memfrom, memto
  66+ 0000 ~                                    ld       a,(memfrom)
  67+ 0000 ~                                    and		$7F
  68+ 0000 ~                                    ld       (memto),a
  69+ 0000                                      ENDM
  70+ 0000
  71+ 0000              ldAtHLtoMem:            MACRO   memto
  72+ 0000 ~                                    ld      a,(hl)
  73+ 0000 ~                                    ld      (memto),a
  74+ 0000                                      ENDM
  75+ 0000
  76+ 0000              ldCopyWord:             MACRO memfrom, memto
  77+ 0000 ~                                    ldCopy2Byte memfrom, memto
  78+ 0000                                      ENDM
  79+ 0000
  80+ 0000              ldCopy2Byte:            MACRO  memfrom, memto
  81+ 0000 ~                                    ld       hl,(memfrom)
  82+ 0000 ~                                    ld       (memto),hl
  83+ 0000                                      ENDM
  84+ 0000
  85+ 0000              ldWriteConst            MACRO  memfrom, memto
  86+ 0000 ~                                    ld       a,memfrom
  87+ 0000 ~                                    ld       (memto),a
  88+ 0000                                      ENDM
  89+ 0000
  90+ 0000              ldWriteZero             MACRO  memto
  91+ 0000 ~                                    xor      a
  92+ 0000 ~                                    ld       (memto),a
  93+ 0000                                      ENDM
  94+ 0000
  95+ 0000              ldIXLaFromN:	        MACRO memfrom
  96+ 0000 ~                                    ld		a,(memfrom)
  97+ 0000 ~                                    ld		ixl,a
  98+ 0000                                      ENDM
  99+ 0000
 100+ 0000              ldIXHaFromN:	        MACRO memfrom
 101+ 0000 ~                                    ld		a,(memfrom)
 102+ 0000 ~                                    ld		ixh,a
 103+ 0000                                      ENDM
 104+ 0000
 105+ 0000              ldIYLaFromN:	        MACRO memfrom
 106+ 0000 ~                                    ld		a,(memfrom)
 107+ 0000 ~                                    ld		iyl,a
 108+ 0000                                      ENDM
 109+ 0000
 110+ 0000              ldIYHaFromN:	        MACRO memfrom
 111+ 0000 ~                                    ld		a,(memfrom)
 112+ 0000 ~                                    ld		iyh,a
 113+ 0000                                      ENDM
 114+ 0000
 115+ 0000              ; Read a 32 bit value from address HL into BCDE
 116+ 0000              ldBCDEatHL:             MACRO
 117+ 0000 ~                                    ld      e,(hl)
 118+ 0000 ~                                    inc     hl
 119+ 0000 ~                                    ld      d,(hl)
 120+ 0000 ~                                    inc     hl
 121+ 0000 ~                                    ld      c,(hl)
 122+ 0000 ~                                    inc     hl
 123+ 0000 ~                                    ld      b,(hl)
 124+ 0000 ~                                    inc     hl
 125+ 0000                                      ENDM
 126+ 0000
 127+ 0000              ldBCatHL:               MACRO
 128+ 0000 ~                                    ld      c,(hl)
 129+ 0000 ~                                    inc     hl
 130+ 0000 ~                                    ld      b,(hl)
 131+ 0000 ~                                    inc     hl
 132+ 0000                                      ENDM
 133+ 0000
 134+ 0000              ldhlde:			        MACRO
 135+ 0000 ~                                    ld		h,d
 136+ 0000 ~                                    ld		l,e
 137+ 0000                                      ENDM
 138+ 0000
 139+ 0000              ldhlbc:			        MACRO
 140+ 0000 ~                                    ld		h,b
 141+ 0000 ~                                    ld		l,c
 142+ 0000                                      ENDM
 143+ 0000
 144+ 0000              ldbcde:			        MACRO
 145+ 0000 ~                                    ld		b,d
 146+ 0000 ~                                    ld		c,e
 147+ 0000                                      ENDM
 148+ 0000
 149+ 0000              lddebc:			        MACRO
 150+ 0000 ~                                    ld		d,b
 151+ 0000 ~                                    ld		e,c
 152+ 0000                                      ENDM
 153+ 0000
 154+ 0000              ldbchl:			        MACRO
 155+ 0000 ~                                    ld		b,h
 156+ 0000 ~                                    ld		c,l
 157+ 0000                                      ENDM
 158+ 0000
 159+ 0000              lddeiy:			        MACRO
 160+ 0000 ~                                    ld		d,iyh
 161+ 0000 ~                                    ld		e,iyl
 162+ 0000                                      ENDM
 163+ 0000
 164+ 0000              ldiyde:			        MACRO
 165+ 0000 ~                                    ld		iyh,d
 166+ 0000 ~                                    ld		iyl,e
 167+ 0000                                      ENDM
 168+ 0000
 169+ 0000
 170+ 0000              FourLDIInstrunctions:   MACRO
 171+ 0000 ~                                    ldi
 172+ 0000 ~                                    ldi
 173+ 0000 ~                                    ldi
 174+ 0000 ~                                    ldi
 175+ 0000                                      ENDM
 176+ 0000
 177+ 0000              FiveLDIInstrunctions:   MACRO
 178+ 0000 ~                                    ldi
 179+ 0000 ~                                    ldi
 180+ 0000 ~                                    ldi
 181+ 0000 ~                                    ldi
 182+ 0000 ~                                    ldi
 183+ 0000                                      ENDM
 184+ 0000
 185+ 0000              SixLDIInstrunctions:    MACRO
 186+ 0000 ~                                    ldi
 187+ 0000 ~                                    ldi
 188+ 0000 ~                                    ldi
 189+ 0000 ~                                    ldi
 190+ 0000 ~                                    ldi
 191+ 0000 ~                                    ldi
 192+ 0000                                      ENDM
 193+ 0000
 194+ 0000              EightLDIInstrunctions:  MACRO
 195+ 0000 ~            		                ldi
 196+ 0000 ~            		                ldi
 197+ 0000 ~            		                ldi
 198+ 0000 ~            		                ldi
 199+ 0000 ~            		                ldi
 200+ 0000 ~            		                ldi
 201+ 0000 ~            		                ldi
 202+ 0000 ~            		                ldi
 203+ 0000                                      ENDM
 204+ 0000
 205+ 0000              NineLDIInstrunctions:  MACRO
 206+ 0000 ~            		                ldi
 207+ 0000 ~            		                ldi
 208+ 0000 ~            		                ldi
 209+ 0000 ~            		                ldi
 210+ 0000 ~            		                ldi
 211+ 0000 ~            		                ldi
 212+ 0000 ~            		                ldi
 213+ 0000 ~            		                ldi
 214+ 0000 ~            		                ldi
 215+ 0000                                      ENDM
# file closed: ../../Macros/ldCopyMacros.asm
  35  0000                                      INCLUDE "../../Macros/ldIndexedMacros.asm"
# file opened: ../../Macros/ldIndexedMacros.asm
   1+ 0000              GetByteAInTable:    MACRO table
   2+ 0000 ~                                ld          hl,table
   3+ 0000 ~                                add         hl,a
   4+ 0000 ~                                ld          a,(hl)
   5+ 0000                                  ENDM
   6+ 0000
   7+ 0000              HLWordAInTable:     MACRO table
   8+ 0000 ~                                ld          hl,table
   9+ 0000 ~                                sla         a
  10+ 0000 ~                                add         hl,a
  11+ 0000 ~                                ld          a,(hl)
  12+ 0000 ~                                inc         hl
  13+ 0000 ~                                ld          h,(hl)
  14+ 0000 ~                                ld          l,a
  15+ 0000                                  ENDM
  16+ 0000
  17+ 0000
  18+ 0000              ldAToHLixl:			MACRO value
  19+ 0000 ~            					ld          hl,value
  20+ 0000 ~            					ex          af,af'
  21+ 0000 ~            					ld          a,ixl
  22+ 0000 ~            					add         hl,a
  23+ 0000 ~            					ex          af,af'
  24+ 0000 ~            					ld          (hl),a
  25+ 0000              					ENDM
  26+ 0000
  27+ 0000              ldAToHLiyl:			MACRO value
  28+ 0000 ~            					ld          hl,value
  29+ 0000 ~            					ex          af,af'
  30+ 0000 ~            					ld          a,iyl
  31+ 0000 ~            					add         hl,a
  32+ 0000 ~            					ex          af,af'
  33+ 0000 ~            					ld          (hl),a
  34+ 0000              					ENDM
  35+ 0000
  36+ 0000
  37+ 0000              ldHLixlToA:         MACRO value
  38+ 0000 ~                                ld          hl,value
  39+ 0000 ~                                ex          af,af'
  40+ 0000 ~                                ld          a,ixl
  41+ 0000 ~                                add         hl,a
  42+ 0000 ~                                ld          a,(hl)
  43+ 0000                                  ENDM
  44+ 0000
  45+ 0000              ldHLiylToA:         MACRO value
  46+ 0000 ~                                ld          hl,value
  47+ 0000 ~                                ex          af,af'
  48+ 0000 ~                                ld          a,iyl
  49+ 0000 ~                                add         hl,a
  50+ 0000 ~                                ld          a,(hl)
  51+ 0000                                  ENDM
  52+ 0000
  53+ 0000              ldHLIdxAToA:        MACRO value
  54+ 0000 ~                                ld          hl,value
  55+ 0000 ~                                add         hl,a
  56+ 0000 ~                                ld          a,(hl)
  57+ 0000                                  ENDM
  58+ 0000
  59+ 0000              HLEquAddrAtHLPlusA: MACRO
  60+ 0000 ~                                sla         a
  61+ 0000 ~                                add         hl,a
  62+ 0000 ~                                ld          a,(hl)
  63+ 0000 ~                                inc         hl
  64+ 0000 ~                                ld          h,(hl)
  65+ 0000 ~                                ld          l,a
  66+ 0000                                  ENDM
  67+ 0000
  68+ 0000              ;-- Performs HL = |HL| - 1
  69+ 0000              DecHLABS:           MACRO
  70+ 0000 ~                                bit         7,h
  71+ 0000 ~                                jp          nz,.NegativeDec
  72+ 0000 ~            .IsHLZero:          ld          a,h                 ; if its zero it becomes negative
  73+ 0000 ~                                or          l
  74+ 0000 ~                                jp          z,.HLZero
  75+ 0000 ~            .PositiveDec:       dec         hl
  76+ 0000 ~                                jp          .Done
  77+ 0000 ~            .NegativeDec:       ld          a,h
  78+ 0000 ~                                and         $7F
  79+ 0000 ~                                ld          h,a
  80+ 0000 ~                                dec         hl
  81+ 0000 ~                                set         7,h
  82+ 0000 ~                                jp          .Done
  83+ 0000 ~            .HLZero:            ld          hl,$8001
  84+ 0000 ~            .Done:
  85+ 0000                                  ENDM
  86+ 0000
  87+ 0000              ;-- Performs HL = HL - 1
  88+ 0000              DecHLSigned:        MACRO
  89+ 0000 ~                                bit         7,h
  90+ 0000 ~                                jp          nz,.NegativeDec
  91+ 0000 ~            .IsHLZero:          ld          a,h                 ; if its zero it becomes negative
  92+ 0000 ~                                or          l
  93+ 0000 ~                                jp          z,.HLZero
  94+ 0000 ~            .PositiveDec:       dec         hl
  95+ 0000 ~                                jp          .Done
  96+ 0000 ~            .NegativeDec:       ld          a,h
  97+ 0000 ~                                and         $7F
  98+ 0000 ~                                ld          h,a
  99+ 0000 ~                                inc         hl                  ; if its already negative then add 1 to make it further
 100+ 0000 ~                                set         7,h
 101+ 0000 ~                                jp          .Done
 102+ 0000 ~            .HLZero:            ld          hl,$8001
 103+ 0000 ~            .Done:
 104+ 0000                                  ENDM
 105+ 0000
# file closed: ../../Macros/ldIndexedMacros.asm
  36  0000                                      INCLUDE "../../Macros/jumpMacros.asm"
# file opened: ../../Macros/jumpMacros.asm
   1+ 0000              JumpIfHLNegative:       MACRO target
   2+ 0000 ~                                    bit     7,h
   3+ 0000 ~                                    jp      nz,target
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              JumpIfPositive:	        MACRO target
   7+ 0000 ~                                    jp		p, target
   8+ 0000                                      ENDM
   9+ 0000
  10+ 0000              JumpIfNegative:	        MACRO target
  11+ 0000 ~                                    jp		m, target
  12+ 0000                                      ENDM
  13+ 0000
  14+ 0000
  15+ 0000              JumpIfUnderflow:	    MACRO target
  16+ 0000 ~                                    jp		po, target
  17+ 0000                                      ENDM
  18+ 0000
  19+ 0000              JumpIfOverflow:	        MACRO target
  20+ 0000 ~                                    jp		po, target
  21+ 0000                                      ENDM
  22+ 0000
  23+ 0000
  24+ 0000              JumpIfNotZero:	        MACRO target
  25+ 0000 ~                                    jp	nz,target
  26+ 0000                                      ENDM
  27+ 0000
  28+ 0000              JumpIfZero:	            MACRO target
  29+ 0000 ~                                    jp	z,target
  30+ 0000                                      ENDM
  31+ 0000
  32+ 0000              ;.. Bit routines
  33+ 0000              JumpOnLeadSignSet:      MACRO   reg, target
  34+ 0000 ~                                    ld      a,reg
  35+ 0000 ~                                    and     SignOnly8Bit
  36+ 0000 ~                                    jp      nz,target
  37+ 0000                                      ENDM
  38+ 0000
  39+ 0000              JumpOnLeadSignClear:    MACRO   reg, target
  40+ 0000 ~                                    ld      a,reg
  41+ 0000 ~                                    and     SignOnly8Bit
  42+ 0000 ~                                    jp      z,target
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              JumpOnLeadSignSetA:     MACRO   target
  46+ 0000 ~                                    and     SignOnly8Bit
  47+ 0000 ~                                    jp      nz,target
  48+ 0000                                      ENDM
  49+ 0000
  50+ 0000              JumpOnLeadSignClearA:   MACRO   target
  51+ 0000 ~                                    and     SignOnly8Bit
  52+ 0000 ~                                    jp      z,target
  53+ 0000                                      ENDM
  54+ 0000
  55+ 0000              JumpOnMemBitSet:        MACRO mem, bitnbr, target
  56+ 0000 ~                                    ld      a,(mem)
  57+ 0000 ~                                    bit 	bitnbr,a
  58+ 0000 ~                                    jp      nz,target
  59+ 0000                                      ENDM
  60+ 0000
  61+ 0000              JumpOnMemBitClear:      MACRO mem, bitnbr, target
  62+ 0000 ~                                    ld      a,(mem)
  63+ 0000 ~                                    bit 	bitnbr,a
  64+ 0000 ~                                    jp      z,target
  65+ 0000                                      ENDM
  66+ 0000
  67+ 0000
  68+ 0000              JumpOnABitSet:          MACRO   bitnbr, target
  69+ 0000 ~                                    bit 	bitnbr, a
  70+ 0000 ~                                    jp      nz,target
  71+ 0000                                      ENDM
  72+ 0000
  73+ 0000              JumpOnABitClear:        MACRO   bitnbr, target
  74+ 0000 ~                                    bit 	bitnbr, a
  75+ 0000 ~                                    jp      z,target
  76+ 0000                                      ENDM
  77+ 0000
  78+ 0000              JumpOnABit5Set:         MACRO   target
  79+ 0000 ~                                    and     Bit5Only
  80+ 0000 ~                                    jp      nz,target
  81+ 0000                                      ENDM
  82+ 0000
  83+ 0000              JumpOnABit5Clear:       MACRO   target
  84+ 0000 ~                                    and     Bit5Only
  85+ 0000 ~                                    jp      z,target
  86+ 0000                                      ENDM
  87+ 0000
  88+ 0000              JumpOnBitMaskSet:       MACRO   bitmask, target
  89+ 0000 ~                                    and     bitmask
  90+ 0000 ~                                    jp      nz,target
  91+ 0000                                      ENDM
  92+ 0000
  93+ 0000              JumpOnBitMaskClear:     MACRO   bitmask, target
  94+ 0000 ~                                    and     bitmask
  95+ 0000 ~                                    jp      z,target
  96+ 0000                                      ENDM
  97+ 0000
  98+ 0000              JumpOnMemBitMaskSet:    MACRO   mem, bitmask, target
  99+ 0000 ~                                    ld      a,(mem)
 100+ 0000 ~                                    and     bitmask
 101+ 0000 ~                                    jp      nz,target
 102+ 0000                                      ENDM
 103+ 0000
 104+ 0000              JumpOnMemBitMaskClear:  MACRO   mem, bitmask, target
 105+ 0000 ~                                    ld      a,(mem)
 106+ 0000 ~                                    and     bitmask
 107+ 0000 ~                                    jp      z,target
 108+ 0000                                      ENDM
 109+ 0000
 110+ 0000              JumpOnBitSet:           MACRO  reg, bitnbr, target
 111+ 0000 ~                                    bit 	bitnbr,reg
 112+ 0000 ~                                    jp      nz,target
 113+ 0000                                      ENDM
 114+ 0000
 115+ 0000              JumpOnBitClear:         MACRO  reg, bitnbr, target
 116+ 0000 ~                                    bit 	bitnbr,reg
 117+ 0000 ~                                    jp      z,target
 118+ 0000                                      ENDM
 119+ 0000
 120+ 0000              ; Comparison Routines
 121+ 0000              JumpIfAGTEusng:         MACRO
 122+ 0000 ~                                    jp		nc,target
 123+ 0000                                      ENDM
 124+ 0000
 125+ 0000              JumpIfAGTENusng:        MACRO reg,target
 126+ 0000 ~                                    cp     reg
 127+ 0000 ~                                    jp		nc,target
 128+ 0000                                      ENDM
 129+ 0000
 130+ 0000              JumpIfAGTEMemusng:      MACRO mem,target
 131+ 0000 ~                                    ld      hl,mem
 132+ 0000 ~                                    cp      (hl)
 133+ 0000 ~                                    jp		nc,target
 134+ 0000                                      ENDM
 135+ 0000              JumpIfMemGTENusng:      MACRO mem, value, target
 136+ 0000 ~                                    ld     a,(mem)
 137+ 0000 ~                                    cp     value
 138+ 0000 ~                                    jp	  nc,target
 139+ 0000                                      ENDM
 140+ 0000
 141+ 0000              JumpIfMemGTEMemusng:    MACRO mem, address, target
 142+ 0000 ~                                    ld   a,(mem)
 143+ 0000 ~                                    ld   hl,address
 144+ 0000 ~                                    cp   (hl)
 145+ 0000 ~                                    jp	  nc,target
 146+ 0000                                      ENDM
 147+ 0000
 148+ 0000              JumpIfMemEqMemusng:     MACRO mem, address, target
 149+ 0000 ~                                    ld   a,(mem)
 150+ 0000 ~                                    ld   hl,address
 151+ 0000 ~                                    cp   (hl)
 152+ 0000 ~                                    jp	  z,target
 153+ 0000                                      ENDM
 154+ 0000
 155+ 0000              JumpIfMemNeMemusng:     MACRO mem, address, target
 156+ 0000 ~                                    ld   a,(mem)
 157+ 0000 ~                                    ld   hl,address
 158+ 0000 ~                                    cp   (hl)
 159+ 0000 ~                                    jp	  nz,target
 160+ 0000                                      ENDM
 161+ 0000
 162+ 0000              JumpIfMemTrue:          MACRO mem, target
 163+ 0000 ~                                    ld      a,(mem)
 164+ 0000 ~                                    and     a
 165+ 0000 ~                                    jp      z, target
 166+ 0000                                      ENDM
 167+ 0000
 168+ 0000              JumpIfMemFalse:         MACRO mem, target
 169+ 0000 ~                                    ld      a,(mem)
 170+ 0000 ~                                    and     a
 171+ 0000 ~                                    jp      nz, target
 172+ 0000                                      ENDM
 173+ 0000
 174+ 0000              JumpIfATrue:            MACRO target
 175+ 0000 ~                                    and     a
 176+ 0000 ~                                    jp      z, target
 177+ 0000                                      ENDM
 178+ 0000
 179+ 0000              JumpIfAFalse:           MACRO target
 180+ 0000 ~                                    and     a
 181+ 0000 ~                                    jp      nz, target
 182+ 0000                                      ENDM
 183+ 0000
 184+ 0000              JumpIfANotFalse:        MACRO target
 185+ 0000 ~                                    cp      $FF
 186+ 0000 ~                                    jp      nz, target
 187+ 0000                                      ENDM
 188+ 0000
 189+ 0000              ;-- Less than Macros -------------------------------------------
 190+ 0000              JumpIfALTMemHLusng:     MACRO target
 191+ 0000 ~                                    cp    (hl)
 192+ 0000 ~                                    jp	  c,target
 193+ 0000                                      ENDM
 194+ 0000
 195+ 0000              JumpIfRegLTE:           MACRO   reg, value, target
 196+ 0000 ~                                    ld      a,reg
 197+ 0000 ~                                    cp      value
 198+ 0000 ~                                    jp	    z,target
 199+ 0000 ~                                    jp		c, target
 200+ 0000                                      ENDM
 201+ 0000
 202+ 0000              JumpIfALTMemusng:       MACRO mem,target
 203+ 0000 ~                                    ld      hl,mem
 204+ 0000 ~                                    cp      (hl)
 205+ 0000 ~                                    jp		c,target
 206+ 0000                                      ENDM
 207+ 0000
 208+ 0000
 209+ 0000              JumpIfALTusng:          MACRO target
 210+ 0000 ~                                    jp		c,target
 211+ 0000                                      ENDM
 212+ 0000
 213+ 0000              JumpIfALTNusng:         MACRO value, target
 214+ 0000 ~                                    cp      value
 215+ 0000 ~                                    jp		c, target
 216+ 0000                                      ENDM
 217+ 0000
 218+ 0000              JumpIfALTNsigned:       MACRO   value, target
 219+ 0000 ~                                    cp      value
 220+ 0000 ~                                    jp      m,.SignSet
 221+ 0000 ~            .SignClear:             jp      pe,target       ; Sign (0), P/V (1)
 222+ 0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (0)
 223+ 0000 ~            .SignSet:               jp      po,target
 224+ 0000 ~            .CheckComplete:
 225+ 0000                                      ENDM
 226+ 0000
 227+ 0000              JumpIfMemLTNusng:       MACRO mem, value, target
 228+ 0000 ~                                    ld      a,(mem)
 229+ 0000 ~                                    cp      value
 230+ 0000 ~                                    jp	  c,target
 231+ 0000                                      ENDM
 232+ 0000
 233+ 0000              JumpIfMemLTMemusng:     MACRO mem, value, target
 234+ 0000 ~                                    ld    a,(mem)
 235+ 0000 ~                                    ld    hl,value
 236+ 0000 ~                                    cp    (hl)
 237+ 0000 ~                                    jp	  c,target
 238+ 0000                                      ENDM
 239+ 0000              ;-- ------------------------------------------------------------
 240+ 0000              JumpIfAGTENsigned       MACRO   value, target
 241+ 0000 ~                                    cp      value
 242+ 0000 ~                                    jp      m,.SignSet
 243+ 0000 ~            .SignClear:             jp      po,target       ; Sign (0), P/V (0)
 244+ 0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (1)
 245+ 0000 ~            .SignSet:               jp      pe,target
 246+ 0000 ~            .CheckComplete:
 247+ 0000                                      ENDM
 248+ 0000
 249+ 0000              JumpIfMemEqNusng:       MACRO mem,value,target
 250+ 0000 ~                                    ld  a,(mem)
 251+ 0000 ~                                    cp  value
 252+ 0000 ~                                    jp  z,target
 253+ 0000                                      ENDM
 254+ 0000
 255+ 0000              JumpIfMemNeNusng:       MACRO mem,value,target
 256+ 0000 ~                                    ld  a,(mem)
 257+ 0000 ~                                    cp  value
 258+ 0000 ~                                    jp  nz,target
 259+ 0000                                      ENDM
 260+ 0000
 261+ 0000              JumpIfMemZero:          MACRO mem,target
 262+ 0000 ~                                    ld  a,(mem)
 263+ 0000 ~                                    and a
 264+ 0000 ~                                    jp  z,target
 265+ 0000                                      ENDM
 266+ 0000
 267+ 0000              JumpIfMemNotZero:       MACRO mem,target
 268+ 0000 ~                                    ld  a,(mem)
 269+ 0000 ~                                    and a
 270+ 0000 ~                                    jp  nz,target
 271+ 0000                                      ENDM
 272+ 0000
 273+ 0000              JumpIfANENusng:         MACRO value, target
 274+ 0000 ~                                    cp     value
 275+ 0000 ~                                    jp      nz,target
 276+ 0000                                      ENDM
 277+ 0000
 278+ 0000              JumpIfANEquNusng:       MACRO value, target
 279+ 0000 ~                                    cp     value
 280+ 0000 ~                                    jp     z,target
 281+ 0000                                      ENDM
 282+ 0000
 283+ 0000              JumpIfANEMemusng:       MACRO  value, target
 284+ 0000 ~                                    ld    hl,value
 285+ 0000 ~                                    cp    (hl)
 286+ 0000 ~                                    jp      nz,target
 287+ 0000                                      ENDM
 288+ 0000
 289+ 0000              JumpIfAEqNusng:         MACRO value, target
 290+ 0000 ~                                    cp     value
 291+ 0000 ~                                    jp      z,target
 292+ 0000                                      ENDM
 293+ 0000
 294+ 0000              JumpIfAIsZero:	        MACRO target
 295+ 0000 ~                                    and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 296+ 0000 ~                                    jp	    z, target
 297+ 0000                                      ENDM
 298+ 0000
 299+ 0000              JumpIfRegIsNotZero:     MACRO   reg, target
 300+ 0000 ~                                    ld      a,reg
 301+ 0000 ~                                    and     a
 302+ 0000 ~                                    jp	    nz,target
 303+ 0000                                      ENDM
 304+ 0000
 305+ 0000
 306+ 0000              JumpIfAIsNotZero:       MACRO target
 307+ 0000 ~                                    and     a
 308+ 0000 ~                                    jp	    nz,target
 309+ 0000                                      ENDM
 310+ 0000
 311+ 0000              JumpIfMemIsNotZero:     MACRO value, target
 312+ 0000 ~                                    ld      a,(value)
 313+ 0000 ~                                    and     a
 314+ 0000 ~                                    jp	    nz,target
 315+ 0000                                      ENDM
 316+ 0000              IfResultZeroGoto:	    MACRO target
 317+ 0000 ~                                    jp	z,target
 318+ 0000                                      ENDM
 319+ 0000
 320+ 0000              IfResultNotZeroGoto:    MACRO target
 321+ 0000 ~                                    jp	nz,target
 322+ 0000                                      ENDM
 323+ 0000
# file closed: ../../Macros/jumpMacros.asm
  37  0000                                      INCLUDE "../../Macros/MathsMacros.asm"
# file opened: ../../Macros/MathsMacros.asm
   1+ 0000              ; sets z flag is HL less than 255 else sets it to nz (note opposite of GT127)
   2+ 0000              IsHLGT255:              MACRO
   3+ 0000 ~                                    bit     7,h
   4+ 0000 ~                                    ret     z
   5+ 0000 ~                                    ld      a,h
   6+ 0000 ~                                    and     a
   7+ 0000                                      ENDM
   8+ 0000
   9+ 0000              ; Sets z flat if HL = 255 else sets it to nz
  10+ 0000              IsHLEqu255:             MACRO
  11+ 0000 ~                                    ld      a,h
  12+ 0000 ~                                    and     a               ; if its non zero then it can't be 255
  13+ 0000 ~                                    ret     nz
  14+ 0000 ~                                    ld      a,l
  15+ 0000 ~                                    inc     a               ; if it was 255 the inc will set it to zero
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              ; Sets Z flag if GT 127 else nz
  19+ 0000              IsHLGT127:              MACRO
  20+ 0000 ~                                    bit     7,h             ; -ve?
  21+ 0000 ~                                    jr      nz,.DoneCheck
  22+ 0000 ~                                    ld      a,h             ; +ve > 256?
  23+ 0000 ~                                    and     a
  24+ 0000 ~                                    jr      nz,.DoneCheck
  25+ 0000 ~                                    ld      a,l
  26+ 0000 ~                                    and     $80             ; this will set z to false if bit 7 set and clear lower bits
  27+ 0000 ~                                    cp      $80             ; this will set z to true if bit 7 set
  28+ 0000 ~            .DoneCheck:
  29+ 0000                                      ENDM
  30+ 0000
  31+ 0000              ReturnIfHLGT127:        MACRO
  32+ 0000 ~                                    bit     7,h             ; -ve?
  33+ 0000 ~                                    jr      nz,.DoneCheck   ; forces check complete
  34+ 0000 ~                                    ld      a,h             ; +ve > 256?
  35+ 0000 ~                                    and     a               ;
  36+ 0000 ~                                    ret     nz              ; forces a return
  37+ 0000 ~                                    bit     7,l             ; bit 7 of lower set?
  38+ 0000 ~                                    ret     nz              ; forces a return
  39+ 0000 ~            .DoneCheck:
  40+ 0000                                      ENDM
  41+ 0000
  42+ 0000              IsDEGT127:              MACRO
  43+ 0000 ~                                    bit     7,d
  44+ 0000 ~                                    jr      nz,.DoneCheck
  45+ 0000 ~                                    ld      a,d
  46+ 0000 ~                                    jr      nz,.DoneCheck
  47+ 0000 ~                                    ld      a,e
  48+ 0000 ~                                    and     $80
  49+ 0000 ~            .DoneCheck:
  50+ 0000                                      ENDM
  51+ 0000
  52+ 0000              ABSa2c:                 MACRO
  53+ 0000 ~                                    bit     7,a
  54+ 0000 ~                                    jp      z,.DoneABSa
  55+ 0000 ~                                    neg
  56+ 0000 ~            .DoneABSa:
  57+ 0000                                      ENDM
  58+ 0000
  59+ 0000              DEEquSquareA:           MACRO
  60+ 0000 ~                                    ld  d,a
  61+ 0000 ~                                    ld  e,a
  62+ 0000 ~                                    mul de
  63+ 0000                                      ENDM
  64+ 0000
  65+ 0000              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
  66+ 0000 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
  67+ 0000 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
  68+ 0000 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
  69+ 0000 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
  70+ 0000 ~                                    xor $80                             ;
  71+ 0000 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
  72+ 0000 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
  73+ 0000 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
  74+ 0000 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
  75+ 0000 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
  76+ 0000 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
  77+ 0000                                      ENDM
  78+ 0000
  79+ 0000              SignedHLTo2C:           MACRO
  80+ 0000 ~                                    bit     7,h
  81+ 0000 ~                                    jr      z,.Done2c
  82+ 0000 ~                                    ld      a,h
  83+ 0000 ~                                    and     SignMask8Bit
  84+ 0000 ~                                    ld      h,a
  85+ 0000 ~                                    NegHL
  86+ 0000 ~            .Done2c:
  87+ 0000                                      ENDM
  88+ 0000
  89+ 0000              MemSignedTo2C:          MACRO   memfrom
  90+ 0000 ~                                    ld      hl,(memfrom)
  91+ 0000 ~                                    bit     7,h
  92+ 0000 ~                                    jr      z,.Done2c
  93+ 0000 ~                                    ld      a,h
  94+ 0000 ~                                    and     SignMask8Bit
  95+ 0000 ~                                    ld      h,a
  96+ 0000 ~            .Done2c:                ld      (memfrom),hl
  97+ 0000                                      ENDM
  98+ 0000
  99+ 0000
 100+ 0000                  ;returns result in H
 101+ 0000              EDiv10Inline:           MACRO
 102+ 0000 ~                                    ld      d,0
 103+ 0000 ~                                    ld      hl,de
 104+ 0000 ~                                    add     hl,hl
 105+ 0000 ~                                    add     hl,de
 106+ 0000 ~                                    add     hl,hl
 107+ 0000 ~                                    add     hl,hl
 108+ 0000 ~                                    add     hl,de
 109+ 0000 ~                                    add     hl,hl
 110+ 0000                                      ENDM
 111+ 0000
 112+ 0000              cpHLDE:                 MACRO
 113+ 0000 ~                                    push    hl
 114+ 0000 ~                                    and     a
 115+ 0000 ~                                    sbc     hl,de
 116+ 0000 ~                                    pop     hl
 117+ 0000                                      ENDM
 118+ 0000
 119+ 0000              cpABSDEHL:              MACRO
 120+ 0000 ~                                    push     hl,,de
 121+ 0000 ~                                    ld      a,h
 122+ 0000 ~                                    and     $7F
 123+ 0000 ~                                    ld      h,a
 124+ 0000 ~                                    ld      a,d
 125+ 0000 ~                                    and     $7F
 126+ 0000 ~                                    ld      d,a
 127+ 0000 ~                                    ex      de,hl
 128+ 0000 ~                                    sbc     hl,de
 129+ 0000 ~                                    pop     hl,,de
 130+ 0000                                      ENDM
 131+ 0000
 132+ 0000              ; Simple are they both the same setting z if they are
 133+ 0000              ; tehcicall this works but it measn the final ret z is alwys done
 134+ 0000              ; so jp needs to be to a target
 135+ 0000              cpHLEquDE:              MACRO   passedCheck
 136+ 0000 ~                                    ld      a,h
 137+ 0000 ~                                    cp      d
 138+ 0000 ~                                    jp      nz, passedCheck
 139+ 0000 ~                                    ld      a,l
 140+ 0000 ~                                    cp      e
 141+ 0000 ~            .NoTheSame:
 142+ 0000                                      ENDM
 143+ 0000
 144+ 0000              cpHLEquBC:              MACRO   passedCheck
 145+ 0000 ~                                    ld      a,h
 146+ 0000 ~                                    cp      b
 147+ 0000 ~                                    jp      nz, passedCheck
 148+ 0000 ~                                    ld      a,l
 149+ 0000 ~                                    cp      c
 150+ 0000 ~            .NoTheSame:
 151+ 0000                                      ENDM
 152+ 0000
 153+ 0000              cpDEEquBC:              MACRO   passedCheck
 154+ 0000 ~                                    ld      a,d
 155+ 0000 ~                                    cp      b
 156+ 0000 ~                                    jp      nz, passedCheck
 157+ 0000 ~                                    ld      a,e
 158+ 0000 ~                                    cp      c
 159+ 0000 ~            .NoTheSame:
 160+ 0000                                      ENDM
 161+ 0000              ; Simple version just sets carry if HL < DE reset, does an initial compare for z
 162+ 0000              cpHLDELeadSign:         MACRO
 163+ 0000 ~                                    ld      a,h
 164+ 0000 ~                                    cp      d
 165+ 0000 ~                                    jr      nz,.FullCompare
 166+ 0000 ~                                    ld      a,l
 167+ 0000 ~                                    cp      e
 168+ 0000 ~                                    ret     z
 169+ 0000 ~            .FullCompare:           ld      a,h
 170+ 0000 ~                                    xor     d
 171+ 0000 ~                                    and     $80
 172+ 0000 ~                                    jr      nz,.OppositeSigns   ; If opposite signs is a simple sign test
 173+ 0000 ~                                    ld      a,h                 ; same signs so a little simpler
 174+ 0000 ~                                    and     $80
 175+ 0000 ~                                    jp      z,cpHLDE            ; if h is positive then both are positive by here so just cpHLDE
 176+ 0000 ~                                    jp      cpABSDEHL           ; else we have to do ABScpDEHL
 177+ 0000 ~            .OppositeSigns:         ld      a,h
 178+ 0000 ~                                    and     $80
 179+ 0000 ~                                    and     $80
 180+ 0000 ~                                    jp      z,.HLGTDE
 181+ 0000 ~            .HLLTDE:                SetCarryFlag
 182+ 0000 ~                                    ret
 183+ 0000 ~            .HLGTDE:                ClearCarryFlag
 184+ 0000 ~                                    ret
 185+ 0000                                      ENDM
 186+ 0000
 187+ 0000              ;Unsigned
 188+ 0000              ;If HL == DE, then Z flag is set.
 189+ 0000              ;If HL != DE, then Z flag is reset.
 190+ 0000              ;If HL <  DE, then C flag is set.
 191+ 0000              ;If HL >= DE, then C flag is reset.
 192+ 0000              ;
 193+ 0000              ;Signed
 194+ 0000              ;If HL == DE, then Z flag is set.
 195+ 0000              ;If HL != DE, then Z flag is reset.
 196+ 0000              ;If HL <  DE, then S and P/V are different.
 197+ 0000              ;If HL >= DE, then S and P/V are the same.
 198+ 0000
 199+ 0000
 200+ 0000              N0equN1byN2div256:      MACRO param1,param2,param3
 201+ 0000 ~                                    ld      a,param3                        ;
 202+ 0000 ~                                    ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 203+ 0000 ~                                    ld      a,param2                        ; A = XX16 element
 204+ 0000 ~                                    ld      d,a
 205+ 0000 ~                                    mul
 206+ 0000 ~                                    ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 207+ 0000 ~                                    ld      (param1),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 208+ 0000                                      ENDM
 209+ 0000
 210+ 0000              AequN1xorN2:            MACRO  param1,param2
 211+ 0000 ~                                    ld      a,(param1)
 212+ 0000 ~                                    xor     param2
 213+ 0000                                      ENDM
 214+ 0000
 215+ 0000              SpeedMulAxis:           MACRO   speedreg, axis
 216+ 0000 ~                                    ld      e,speedreg
 217+ 0000 ~                                    ld      hl,(axis)
 218+ 0000 ~                                    ld      a,h
 219+ 0000 ~                                    ClearSignBitA
 220+ 0000 ~                                    ld      d,a
 221+ 0000 ~                                    mul     de
 222+ 0000 ~                                    ld      a,h
 223+ 0000 ~                                    SignBitOnlyA
 224+ 0000 ~                                    ld      b,a;ld      c,a
 225+ 0000 ~                                    ld      h,d;ld      e,d
 226+ 0000 ~                                    ld      c,0;ld      d,0
 227+ 0000                                      ENDM
 228+ 0000
 229+ 0000              ; Adds speed (8 bit) to vertex (24 bit signed)
 230+ 0000              AddSpeedToVert:         MACRO   vertex
 231+ 0000 ~                                    ld      de,(vertex+1)
 232+ 0000 ~                                    ld      a,(vertex)
 233+ 0000 ~                                    ld      l,a
 234+ 0000 ~                                    call    AddBCHtoDELsigned               ; DEL = DEL + BCH
 235+ 0000 ~                                    ld      a,l
 236+ 0000 ~                                    ld      (vertex),a
 237+ 0000 ~                                    ld      (vertex+1),de
 238+ 0000                                      ENDM
# file closed: ../../Macros/MathsMacros.asm
  38  0000                                      INCLUDE "../../Macros/MMUMacros.asm"
# file opened: ../../Macros/MMUMacros.asm
   1+ 0000              MMUSelectROM0:       MACRO
   2+ 0000 ~                                 nextreg EXSDOSMMU0,        BankROM
   3+ 0000                                   ENDM
   4+ 0000
   5+ 0000              MMUSelectROMS:       MACRO
   6+ 0000 ~                                 nextreg EXSDOSMMU0,        BankROM
   7+ 0000 ~                                 nextreg EXSDOSMMU1,        BankROM
   8+ 0000                                   ENDM
   9+ 0000
  10+ 0000              MMUSelectMathsTables:MACRO
  11+ 0000 ~                                 nextreg MathsTablesMMU,    BankMathsTables
  12+ 0000                                   ENDM
  13+ 0000
  14+ 0000              MMUSelectKeyboard:   MACRO
  15+ 0000 ~                                 nextreg KeyboardMMU,       BankKeyboard
  16+ 0000                                   ENDM
  17+ 0000
  18+ 0000              MMUSelectSpriteBank: MACRO
  19+ 0000 ~            					 nextreg SpritememMMU,	    BankSPRITE
  20+ 0000              					 ENDM
  21+ 0000
  22+ 0000              MMUSelectConsoleBank: MACRO
  23+ 0000 ~            					 nextreg ConsoleImageDataMMU,  BankConsole
  24+ 0000              					 ENDM
  25+ 0000
  26+ 0000              MMUSelectLayer1: 	 MACRO
  27+ 0000 ~            					 nextreg L1memMMU,		    BankLAYER1
  28+ 0000              					 ENDM
  29+ 0000
  30+ 0000              MMUSelectLayer2: 	 MACRO
  31+ 0000 ~            					 nextreg L2memMMU,		    BankLAYER2
  32+ 0000              					 ENDM
  33+ 0000
  34+ 0000              MMUSelectResetUniv:  MACRO
  35+ 0000 ~                                 nextreg ResetUniverseMMU, BankResetUniv
  36+ 0000                                   ENDM
  37+ 0000
  38+ 0000              MMUSelectShipARead:  MACRO
  39+ 0000 ~                                 add    a,BankUNIVDATA0
  40+ 0000 ~                                 nextreg ShipReadMMU,       a
  41+ 0000                                   ENDM
  42+ 0000
  43+ 0000              MMUSelectShipBank1:  MACRO
  44+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels1
  45+ 0000              					 ENDM
  46+ 0000              MMUSelectShipBank2:  MACRO
  47+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels2
  48+ 0000              					 ENDM
  49+ 0000              MMUSelectShipBank3:  MACRO
  50+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels3
  51+ 0000              					 ENDM
  52+ 0000              MMUSelectShipBank4:  MACRO
  53+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels4
  54+ 0000              					 ENDM
  55+ 0000
  56+ 0000              MMUSelectShipBankA   MACRO
  57+ 0000 ~            					 nextreg ShipModelMMU,	    a
  58+ 0000              					 ENDM
  59+ 0000
  60+ 0000              MMUSelectShipBankN:  MACRO value
  61+ 0000 ~            					 nextreg ShipModelMMU,	    value
  62+ 0000              					 ENDM
  63+ 0000
  64+ 0000              MMUSelectCommander:	 MACRO
  65+ 0000 ~                                 nextreg CommanderMMU,       BankCommander
  66+ 0000              					 ENDM
  67+ 0000
  68+ 0000              MMUSelectStockTable: MACRO
  69+ 0000 ~                                 nextreg StockTableMMU,     BankStockTable
  70+ 0000              					 ENDM
  71+ 0000
  72+ 0000              MMUSelectCpySrcA:    MACRO
  73+ 0000 ~                                 nextreg DMACpySourceMMU,	a
  74+ 0000              					 ENDM
  75+ 0000
  76+ 0000              MMUSelectCpySrcN:    MACRO value
  77+ 0000 ~                                 nextreg DMACpySourceMMU,	value
  78+ 0000              					 ENDM
  79+ 0000
  80+ 0000              MMUSelectSun:        MACRO
  81+ 0000 ~                                 nextreg SunMMU,            BankSunData
  82+ 0000                                   ENDM
  83+ 0000
  84+ 0000              MMUSelectPlanet:     MACRO
  85+ 0000 ~                                 nextreg PlanetMMU,         BankPlanetData
  86+ 0000                                   ENDM
  87+ 0000
  88+ 0000              MMUSelectUniverseA:  MACRO
  89+ 0000 ~                                 add    a,BankUNIVDATA0
  90+ 0000 ~                                 nextreg UniverseMMU,       a
  91+ 0000                                   ENDM
  92+ 0000              ;Version that assumes a pre calulated A, used whn optimising many switches
  93+ 0000              MMUSelectUnivBankA:  MACRO
  94+ 0000 ~                                 nextreg UniverseMMU,       a
  95+ 0000                                   ENDM
  96+ 0000
  97+ 0000              MMUSelectUniverseN:  MACRO value
  98+ 0000 ~                                 nextreg UniverseMMU,       BankUNIVDATA0+value
  99+ 0000                                   ENDM
 100+ 0000
 101+ 0000              MMUSelectSpaceStation: MACRO
 102+ 0000 ~                                 nextreg SpaceStationMMU,   BankSpaceStationData
 103+ 0000                                   ENDM
 104+ 0000
 105+ 0000              MMUSelectMathsBankedFns   MACRO
 106+ 0000 ~                                 nextreg MathsBankedFnsMMU, BankMathsBankedFns
 107+ 0000                                   ENDM
 108+ 0000
 109+ 0000              MMUSelectGalaxyA:    MACRO
 110+ 0000 ~                                 nextreg GalaxyDataMMU,     a
 111+ 0000                                   ENDM
 112+ 0000
 113+ 0000              MMUSelectGalaxyN:    MACRO value
 114+ 0000 ~                                 nextreg GalaxyDataMMU,     BankGalaxyData0+value
 115+ 0000                                   ENDM
 116+ 0000              MMUSelectGalaxyACopy:MACRO
 117+ 0000 ~                                 nextreg UniverseMMU,       a
 118+ 0000                                   ENDM
 119+ 0000
 120+ 0000              MMUSelectUniverseAbs:MACRO value
 121+ 0000 ~                                 nextreg UniverseMMU,       value
 122+ 0000                                   ENDM
 123+ 0000
 124+ 0000              MMUSelectMenuGalCht: MACRO
 125+ 0000 ~                                 nextreg MenuGalChtMMU,		BankMenuGalCht
 126+ 0000              					 ENDM
 127+ 0000
 128+ 0000              MMUSelectMenuShrCht: MACRO
 129+ 0000 ~            					 nextreg MenuShrChtMMU,		BankMenuShrCht
 130+ 0000              					 ENDM
 131+ 0000
 132+ 0000              MMUSelectMenuInvent: MACRO
 133+ 0000 ~                                 nextreg MenuInventMMU,		BankMenuInvent
 134+ 0000              					 ENDM
 135+ 0000
 136+ 0000              MMUSelectMenuSystem: MACRO
 137+ 0000 ~                                 nextreg MenuSystemMMU,		BankMenuSystem
 138+ 0000              					 ENDM
 139+ 0000
 140+ 0000              MMUSelectMenuMarket: MACRO
 141+ 0000 ~                                 nextreg MenuMarketMMU,		BankMenuMarket
 142+ 0000              					 ENDM
 143+ 0000
 144+ 0000              MMUSelectMenuStatus: MACRO
 145+ 0000 ~                                 nextreg MenuStatusMMU,		BankMenuStatus
 146+ 0000              					 ENDM
 147+ 0000
 148+ 0000              MMUSelectViewFront:  MACRO
 149+ 0000 ~                                 nextreg ScreenBankMMU,		BankFrontView
 150+ 0000              					 ENDM
 151+ 0000
 152+ 0000              MMUSelectScreenA:    MACRO
 153+ 0000 ~                                 nextreg ScreenBankMMU,		a
 154+ 0000              					 ENDM
 155+ 0000
 156+ 0000              MMUSelectSound:      MACRO
 157+ 0000 ~                                 nextreg SoundMMU,		    BankSound
 158+ 0000              					 ENDM
 159+ 0000
 160+ 0000
 161+ 0000
 162+ 0000              SaveMMU6:           MACRO
 163+ 0000 ~                                GetNextReg  MMU_SLOT_6_REGISTER
 164+ 0000 ~                                ld      (SavedMMU6),a
 165+ 0000                                  ENDM
 166+ 0000
 167+ 0000              RestoreMMU6:        MACRO
 168+ 0000 ~                                ld      a,(SavedMMU6)               ; now restore up post interrupt
 169+ 0000 ~                                nextreg MMU_SLOT_6_REGISTER,a       ; Restore MMU7
 170+ 0000                                  ENDM
 171+ 0000
 172+ 0000              SaveMMU7:           MACRO
 173+ 0000 ~                                GetNextReg  MMU_SLOT_7_REGISTER
 174+ 0000 ~                                ld      (SavedMMU7),a
 175+ 0000                                  ENDM
 176+ 0000
 177+ 0000              RestoreMMU7:        MACRO
 178+ 0000 ~                                ld      a,(SavedMMU7)               ; now restore up post interrupt
 179+ 0000 ~                                nextreg MMU_SLOT_7_REGISTER,a       ; Restore MMU7
 180+ 0000                                  ENDM
# file closed: ../../Macros/MMUMacros.asm
  39  0000                                      INCLUDE "../../Macros/returnMacros.asm"
# file opened: ../../Macros/returnMacros.asm
   1+ 0000              ReturnIfHLNegative:     MACRO   target
   2+ 0000 ~                                    bit     7,h
   3+ 0000 ~                                    ret     nz
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              ReturnIfDENegative:     MACRO   target
   7+ 0000 ~                                    bit     7,d
   8+ 0000 ~                                    ret     nz
   9+ 0000                                      ENDM
  10+ 0000
  11+ 0000              ReturnOnBitSet:         MACRO  reg, bitnbr
  12+ 0000 ~                                    bit 	bitnbr,reg
  13+ 0000 ~                                    ret     nz
  14+ 0000                                      ENDM
  15+ 0000
  16+ 0000              ReturnOnMemBitSet:      MACRO mem, bitnbr
  17+ 0000 ~                                    ld   a,(mem)
  18+ 0000 ~                                    bit 	bitnbr,a
  19+ 0000 ~                                    ret     nz
  20+ 0000                                      ENDM
  21+ 0000
  22+ 0000              ReturnOnBitClear:       MACRO reg, bitnbr
  23+ 0000 ~                                    bit 	bitnbr,reg
  24+ 0000 ~                                    ret		z
  25+ 0000                                      ENDM
  26+ 0000
  27+ 0000              ReturnOnMemBitClear:    MACRO mem, bitnbr
  28+ 0000 ~                                    ld     a,(mem)
  29+ 0000 ~                                    bit 	bitnbr,a
  30+ 0000 ~                                    ret		z
  31+ 0000                                      ENDM
  32+ 0000
  33+ 0000              ReturnIfMemFalse:       MACRO   mem
  34+ 0000 ~                                    ld      a,(mem)
  35+ 0000 ~                                    and     a
  36+ 0000 ~                                    ret     nz
  37+ 0000                                      ENDM
  38+ 0000
  39+ 0000              ReturnIfMemTrue:        MACRO   mem
  40+ 0000 ~                                    ld      a,(mem)
  41+ 0000 ~                                    and     a
  42+ 0000 ~                                    ret     z
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              ReturnIfAIsZero:        MACRO
  46+ 0000 ~                                    and     a
  47+ 0000 ~                                    ret     z
  48+ 0000                                      ENDM
  49+ 0000
  50+ 0000              ReturnIfMemisZero:      MACRO mem
  51+ 0000 ~                                    ld   a,(mem)
  52+ 0000 ~                                    and a
  53+ 0000 ~                                    ret    z
  54+ 0000                                      ENDM
  55+ 0000
  56+ 0000              ReturnIfMemIsNegative:  MACRO mem
  57+ 0000 ~                                    ld      a,(mem)
  58+ 0000 ~                                    and     $80
  59+ 0000 ~                                    ret     nz
  60+ 0000                                      ENDM
  61+ 0000
  62+ 0000              ReturnIfBitMaskClear    MACRO   bitmask
  63+ 0000 ~                                    and     bitmask
  64+ 0000 ~                                    ret     z
  65+ 0000                                      ENDM
  66+ 0000
  67+ 0000              ReturnIfBitMaskSet      MACRO   bitmask
  68+ 0000 ~                                    and     bitmask
  69+ 0000 ~                                    ret     nz
  70+ 0000                                      ENDM
  71+ 0000
  72+ 0000              ReturnIfMemEquN:        MACRO mem, value
  73+ 0000 ~                                    ld     a,(mem)
  74+ 0000 ~                                    cp     value
  75+ 0000 ~                                    ret    nz
  76+ 0000                                      ENDM
  77+ 0000
  78+ 0000              ReturnIfMemNeNusng:     MACRO mem, value
  79+ 0000 ~                                    ld   a,(mem)
  80+ 0000 ~                                    cp     value
  81+ 0000 ~                                    ret    z
  82+ 0000                                      ENDM
  83+ 0000
  84+ 0000              ReturnIfRegNotZero:     MACRO reg
  85+ 0000 ~                                    ld      a, reg
  86+ 0000 ~                                    and     a
  87+ 0000 ~                                    ret     nz
  88+ 0000                                      ENDM
  89+ 0000
  90+ 0000              ReturnIfANotZero:       MACRO
  91+ 0000 ~                                    and     a
  92+ 0000 ~                                    ret     nz
  93+ 0000                                      ENDM
  94+ 0000
  95+ 0000              ReturnIfNotZero:        MACRO
  96+ 0000 ~                                    ret     nz
  97+ 0000                                      ENDM
  98+ 0000
  99+ 0000              ReturnIfZero:           MACRO
 100+ 0000 ~                                    ret     z
 101+ 0000                                      ENDM
 102+ 0000
 103+ 0000              ReturnIfNegative:       MACRO
 104+ 0000 ~                                    ret     m
 105+ 0000                                      ENDM
 106+ 0000
 107+ 0000
 108+ 0000              ReturnIfMemNotZero:     MACRO mem
 109+ 0000 ~                                    ld     a,(mem)
 110+ 0000 ~                                    and     a
 111+ 0000 ~                                    ret    nz
 112+ 0000                                      ENDM
 113+ 0000
 114+ 0000              ReturnIfAGTEusng:       MACRO value
 115+ 0000 ~                                    cp    value
 116+ 0000 ~                                    ret	 nc
 117+ 0000                                      ENDM
 118+ 0000
 119+ 0000              ReturnIfRegLTNusng:     MACRO reg, value
 120+ 0000 ~                                    ld      a,reg
 121+ 0000 ~                                    cp      value
 122+ 0000 ~                                    ret	    c
 123+ 0000                                      ENDM
 124+ 0000
 125+ 0000              ReturnIfALTNusng:       MACRO value
 126+ 0000 ~                                    cp    value
 127+ 0000 ~                                    ret	 c
 128+ 0000                                      ENDM
 129+ 0000
 130+ 0000              ReturnIfAGTENusng:      MACRO value
 131+ 0000 ~                                    cp    value
 132+ 0000 ~                                    ret	 nc
 133+ 0000                                      ENDM
 134+ 0000
 135+ 0000              ReturnIfAGTEMemusng:    MACRO value
 136+ 0000 ~                                    ld      hl,value
 137+ 0000 ~                                    cp      (hl)
 138+ 0000 ~                                    ret	    nc
 139+ 0000                                      ENDM
 140+ 0000
 141+ 0000              ReturnIfANENusng:       MACRO value
 142+ 0000 ~                                    cp      value
 143+ 0000 ~                                    ret     nz
 144+ 0000                                      ENDM
 145+ 0000
 146+ 0000              ReturnIfAEqNusng:       MACRO value
 147+ 0000 ~                                    cp      value
 148+ 0000 ~                                    ret     z
 149+ 0000                                      ENDM
 150+ 0000
# file closed: ../../Macros/returnMacros.asm
  40  0000                                      INCLUDE "../../Macros/NegateMacros.asm"
# file opened: ../../Macros/NegateMacros.asm
   1+ 0000
   2+ 0000              macronegate16hl:	MACRO
   3+ 0000 ~            					xor 	a
   4+ 0000 ~            					sub 	l
   5+ 0000 ~            					ld 		l,a
   6+ 0000 ~            					sbc 	a,a
   7+ 0000 ~            					sub 	h
   8+ 0000 ~            					ld 		h,a
   9+ 0000              					ENDM
  10+ 0000
  11+ 0000
  12+ 0000              macroAbsHL:         MACRO
  13+ 0000 ~                                bit     7,h
  14+ 0000 ~                                jp      z,.alreadyABS
  15+ 0000 ~            					xor 	a
  16+ 0000 ~            					sub 	l
  17+ 0000 ~            					ld 		l,a
  18+ 0000 ~            					sbc 	a,a
  19+ 0000 ~            					sub 	h
  20+ 0000 ~            					ld 		h,a
  21+ 0000 ~            .alreadyABS:
  22+ 0000                                  ENDM
  23+ 0000
  24+ 0000              macronegate16de:	MACRO
  25+ 0000 ~            					xor 	a
  26+ 0000 ~                                sub 	e
  27+ 0000 ~                                ld 		e,a
  28+ 0000 ~                                sbc 	a,a
  29+ 0000 ~                                sub 	d
  30+ 0000 ~                                ld 		d,a
  31+ 0000              					ENDM
  32+ 0000
  33+ 0000              macronegate16bc:	MACRO
  34+ 0000 ~            					xor 	a
  35+ 0000 ~                                sub 	c
  36+ 0000 ~                                ld 		c,a
  37+ 0000 ~                                sbc 	a,a
  38+ 0000 ~                                sub 	b
  39+ 0000 ~                                ld 		b,a
  40+ 0000              					ENDM
  41+ 0000
  42+ 0000              macronegate16ix:	MACRO
  43+ 0000 ~            					xor 	a
  44+ 0000 ~                                sub 	ixl
  45+ 0000 ~                                ld 		ixl,a
  46+ 0000 ~                                sbc 	a,a
  47+ 0000 ~                                sub 	ixh
  48+ 0000 ~                                ld 		ixh,a
  49+ 0000              					ENDM
  50+ 0000
  51+ 0000
  52+ 0000              NegIY:			    MACRO
  53+ 0000 ~                                xor a
  54+ 0000 ~                                sub iyl
  55+ 0000 ~                                ld iyl,a
  56+ 0000 ~                                sbc a,a
  57+ 0000 ~                                sub iyh
  58+ 0000 ~                                ld iyh,a
  59+ 0000                                  ENDM
  60+ 0000
  61+ 0000              NegHL:			    MACRO
  62+ 0000 ~                                xor a
  63+ 0000 ~                                sub l
  64+ 0000 ~                                ld l,a
  65+ 0000 ~                                sbc a,a
  66+ 0000 ~                                sub h
  67+ 0000 ~                                ld h,a
  68+ 0000                                  ENDM
  69+ 0000
  70+ 0000              NegDE:			    MACRO
  71+ 0000 ~                                xor a
  72+ 0000 ~                                sub e
  73+ 0000 ~                                ld e,a
  74+ 0000 ~                                sbc a,a
  75+ 0000 ~                                sub d
  76+ 0000 ~                                ld d,a
  77+ 0000                                  ENDM
  78+ 0000
  79+ 0000              NegBC:			    MACRO
  80+ 0000 ~                                xor a
  81+ 0000 ~                                sub c
  82+ 0000 ~                                ld c,a
  83+ 0000 ~                                sbc a,a
  84+ 0000 ~                                sub  b
  85+ 0000 ~                                ld b,a
  86+ 0000                                  ENDM
  87+ 0000
  88+ 0000              NegH                MACRO
  89+ 0000 ~                                ld      a,h
  90+ 0000 ~                                neg
  91+ 0000 ~                                ld      h,a
  92+ 0000                                  ENDM
  93+ 0000
  94+ 0000              NegD                MACRO
  95+ 0000 ~                                ld      a,d
  96+ 0000 ~                                neg
  97+ 0000 ~                                ld      d,a
  98+ 0000                                  ENDM
  99+ 0000
 100+ 0000              NegB                MACRO
 101+ 0000 ~                                ld      a,b
 102+ 0000 ~                                neg
 103+ 0000 ~                                ld      b,a
 104+ 0000                                  ENDM
 105+ 0000
# file closed: ../../Macros/NegateMacros.asm
  41  0000                                      INCLUDE "../../Macros/ShiftMacros.asm"
# file opened: ../../Macros/ShiftMacros.asm
   1+ 0000              ShiftIYRight1: MACRO
   2+ 0000 ~            			   ld 	a,iyh
   3+ 0000 ~            			   srl 	a
   4+ 0000 ~            			   ld	iyh,a
   5+ 0000 ~            			   ld 	a,iyl
   6+ 0000 ~            			   rra
   7+ 0000 ~            			   ld	iyl,a
   8+ 0000              			   ENDM
   9+ 0000
  10+ 0000              ShiftIXRight1: MACRO
  11+ 0000 ~            			   ld 	a,ixh
  12+ 0000 ~            			   srl 	a
  13+ 0000 ~            			   ld	ixh,a
  14+ 0000 ~            			   ld 	a,ixl
  15+ 0000 ~            			   rra
  16+ 0000 ~            			   ld	ixl,a
  17+ 0000              			   ENDM
  18+ 0000
  19+ 0000              ShiftIXhHLRight1: MACRO
  20+ 0000 ~                           ld  a,ixh
  21+ 0000 ~                           srl a
  22+ 0000 ~                           ld  ixh,a
  23+ 0000 ~            			   rr  h
  24+ 0000 ~            			   rr  l
  25+ 0000              			   ENDM
  26+ 0000
  27+ 0000              ShiftIYhDERight1: MACRO
  28+ 0000 ~                           ld  a,iyh
  29+ 0000 ~                           srl a
  30+ 0000 ~                           ld  iyh,a
  31+ 0000 ~                           rr  d
  32+ 0000 ~            			   rr  e
  33+ 0000              			   ENDM
  34+ 0000
  35+ 0000              ShiftIYlBCRight1: MACRO
  36+ 0000 ~                           ld  a,iyl
  37+ 0000 ~                           srl a
  38+ 0000 ~                           ld  iyl,a
  39+ 0000 ~            			   rr  b
  40+ 0000 ~                           rr  c
  41+ 0000              			   ENDM
  42+ 0000
  43+ 0000              ShiftIXlBCRight1: MACRO
  44+ 0000 ~                           ld  a,ixl
  45+ 0000 ~                           srl a
  46+ 0000 ~                           ld  ixl,a
  47+ 0000 ~            			   rr  b
  48+ 0000 ~                           rr  c
  49+ 0000              			   ENDM
  50+ 0000
  51+ 0000              ShiftHLRight1: MACRO
  52+ 0000 ~            			   srl h
  53+ 0000 ~            			   rr  l
  54+ 0000              			   ENDM
  55+ 0000
  56+ 0000              ShiftDERight1: MACRO
  57+ 0000 ~            			   srl d
  58+ 0000 ~            			   rr  e
  59+ 0000              			   ENDM
  60+ 0000
  61+ 0000              ShiftBCRight1: MACRO
  62+ 0000 ~            			   srl b
  63+ 0000 ~            			   rr  c
  64+ 0000              			   ENDM
  65+ 0000
  66+ 0000
  67+ 0000
  68+ 0000              ShiftHLDiv8:   MACRO
  69+ 0000 ~            			   srl h
  70+ 0000 ~            			   rr  l
  71+ 0000 ~            			   srl h
  72+ 0000 ~            			   rr  l
  73+ 0000 ~            			   srl h
  74+ 0000 ~            			   rr  l
  75+ 0000              			   ENDM
  76+ 0000
  77+ 0000              ShiftHLLeft1:  MACRO    ; 16 T states
  78+ 0000 ~            			   sla l
  79+ 0000 ~            			   rl  h
  80+ 0000              			   ENDM
  81+ 0000
  82+ 0000              ShiftDELeft1:  MACRO    ; 16 T states
  83+ 0000 ~            			   sla e
  84+ 0000 ~            			   rl  d
  85+ 0000              			   ENDM
  86+ 0000
  87+ 0000              BarrelHLLeft3: MACRO
  88+ 0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
  89+ 0000 ~                           push     bc      ; 10
  90+ 0000 ~                           ld       b,3     ; 7
  91+ 0000 ~                           bsrl     de,b    ; 8
  92+ 0000 ~                           pop      bc      ; 10
  93+ 0000 ~                           ex       de,hl   ; 4
  94+ 0000                             ENDM
  95+ 0000
  96+ 0000              BarrelHLRight3: MACRO
  97+ 0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
  98+ 0000 ~                           push     bc      ; 10
  99+ 0000 ~                           ld       b,3     ; 7
 100+ 0000 ~                           bsrl     de,b    ; 8
 101+ 0000 ~                           pop      bc      ; 10
 102+ 0000 ~                           ex       de,hl   ; 4
 103+ 0000                             ENDM
 104+ 0000
 105+ 0000              RollBCLeft1:   MACRO	; 16 T states
 106+ 0000 ~                           rl  c
 107+ 0000 ~                           rl  b
 108+ 0000                             ENDM
 109+ 0000
 110+ 0000              RollDELeft1:   MACRO	; 16 T states
 111+ 0000 ~                           rl  e
 112+ 0000 ~                           rl  d
 113+ 0000                             ENDM
 114+ 0000
 115+ 0000              ShiftBCLeft1:  MACRO    ; 16 T states
 116+ 0000 ~            			   sla c
 117+ 0000 ~            			   rl  b
 118+ 0000              			   ENDM
 119+ 0000
 120+ 0000              ShiftLeftMem:       MACRO   reg
 121+ 0000 ~                                ld      hl,reg
 122+ 0000 ~                                sla     (hl)
 123+ 0000                                  ENDM
 124+ 0000
 125+ 0000
 126+ 0000
 127+ 0000              ShiftMem16Right1:   MACRO memaddr
 128+ 0000 ~                                ld    hl,(memaddr)
 129+ 0000 ~                                srl   h
 130+ 0000 ~                                rr    l
 131+ 0000 ~                                ld    (memaddr),hl
 132+ 0000                                  ENDM
 133+ 0000
 134+ 0000              ShiftMem8Right1:    MACRO memaddr
 135+ 0000 ~                                ld      a,(memaddr)
 136+ 0000 ~                                srl     a
 137+ 0000 ~                                ld      (memaddr),a
 138+ 0000                                  ENDM
 139+ 0000
 140+ 0000
 141+ 0000              ShiftMem8Left1A:    MACRO memaddr
 142+ 0000 ~                                ld      a,(memaddr)
 143+ 0000 ~                                sla     a
 144+ 0000 ~                                ld      (memaddr),a
 145+ 0000                                  ENDM
 146+ 0000
# file closed: ../../Macros/ShiftMacros.asm
  42  0000                                      INCLUDE "../../Macros/signBitMacros.asm"
# file opened: ../../Macros/signBitMacros.asm
   1+ 0000              SetMemBitN              MACRO mem,bitnbr
   2+ 0000 ~                                    ld      hl,mem
   3+ 0000 ~                                    set     bitnbr,(hl)
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              ClearMemBitN            MACRO mem,bitnbr
   7+ 0000 ~                                    ld      hl,mem
   8+ 0000 ~                                    res     bitnbr,(hl)
   9+ 0000                                      ENDM
  10+ 0000
  11+ 0000
  12+ 0000              ClearSignBitMem:        MACRO mem
  13+ 0000 ~                                    ld      a,(mem)
  14+ 0000 ~                                    and     SignMask8Bit
  15+ 0000 ~                                    ld      (mem),a
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              SetSignBitMem:          MACRO   mem
  19+ 0000 ~                                    ld      a,(mem)
  20+ 0000 ~                                    or      SignOnly8Bit
  21+ 0000 ~                                    ld      (mem),a
  22+ 0000                                      ENDM
  23+ 0000
  24+ 0000              FlipSignMem:            MACRO mem
  25+ 0000 ~                                    ld  a,(mem)
  26+ 0000 ~                                    xor SignOnly8Bit
  27+ 0000 ~                                    ld  (mem),a
  28+ 0000                                      ENDM
  29+ 0000
  30+ 0000              SignBitOnlyMem:         MACRO mem
  31+ 0000 ~                                    ld      a, (mem)
  32+ 0000 ~                                    and     SignOnly8Bit
  33+ 0000 ~                                    ld      (mem),a
  34+ 0000                                      ENDM
  35+ 0000
  36+ 0000              ClearSignBit:           MACRO reg
  37+ 0000 ~                                    ld      a,reg
  38+ 0000 ~                                    and     SignMask8Bit
  39+ 0000 ~                                    ld      reg,a
  40+ 0000                                      ENDM
  41+ 0000
  42+ 0000              SetSignBit:             MACRO   reg
  43+ 0000 ~                                    ld      a,reg
  44+ 0000 ~                                    or      SignOnly8Bit
  45+ 0000 ~                                    ld      reg,a
  46+ 0000                                      ENDM
  47+ 0000
  48+ 0000              FlipSignBit:            MACRO   reg
  49+ 0000 ~                                    ld      a, reg
  50+ 0000 ~                                    xor     SignOnly8Bit
  51+ 0000 ~                                    ld      reg,a
  52+ 0000                                      ENDM
  53+ 0000
  54+ 0000              SignBitOnly:            MACRO   reg
  55+ 0000 ~                                    ld      a, reg
  56+ 0000 ~                                    and     SignOnly8Bit
  57+ 0000 ~                                    ld      reg,a
  58+ 0000                                      ENDM
  59+ 0000
  60+ 0000              ClearSignBitA:          MACRO
  61+ 0000 ~                                    and     SignMask8Bit
  62+ 0000                                      ENDM
  63+ 0000
  64+ 0000              SetSignBitA:            MACRO
  65+ 0000 ~                                    or      SignOnly8Bit
  66+ 0000                                      ENDM
  67+ 0000
  68+ 0000              FlipSignBitA:           MACRO
  69+ 0000 ~                                    xor     SignOnly8Bit
  70+ 0000                                      ENDM
  71+ 0000
  72+ 0000              SignBitOnlyA:           MACRO
  73+ 0000 ~                                    and     SignOnly8Bit
  74+ 0000                                      ENDM
# file closed: ../../Macros/signBitMacros.asm
  43  0000                                      INCLUDE "../../Macros/KeyboardMacros.asm"
# file opened: ../../Macros/KeyboardMacros.asm
   1+ 0000              MacroIsKeyPressed:      MACRO C_Pressed_keycode
   2+ 0000 ~                                    ld      a,C_Pressed_keycode
   3+ 0000 ~                                    MMUSelectKeyboard
   4+ 0000 ~                                    call    is_key_pressed
   5+ 0000                                      ENDM
   6+ 0000
   7+ 0000              MacroInitkeyboard:      MACRO
   8+ 0000 ~                                    MMUSelectKeyboard
   9+ 0000 ~                                    call    init_keyboard
  10+ 0000                                      ENDM
  11+ 0000
# file closed: ../../Macros/KeyboardMacros.asm
  44  0000                                      INCLUDE "../../Universe/UniverseMacros/asm_linedraw.asm"
# file opened: ../../Universe/UniverseMacros/asm_linedraw.asm
   1+ 0000              ClippingVarsMacro:   MACRO   prefix1?
   2+ 0000 ~            ;-- Clipping code for universe objects -------------------------------------------
   3+ 0000 ~            prefix1?_XX13        DB 0
   4+ 0000 ~
   5+ 0000 ~
   6+ 0000 ~            prefix1?_varK3		 DS	4				; D2
   7+ 0000 ~            prefix1?_centreX     equ prefix1?_varK3
   8+ 0000 ~            prefix1?_varK3p2	 DB	0				; 42
   9+ 0000 ~            prefix1?_varK3p3	 DB	0				; 43
  10+ 0000 ~            prefix1?_varK3p1	 equ prefix1?_varK3+1			; D3
  11+ 0000 ~            prefix1?_varK4		 DS	4				; E0
  12+ 0000 ~            prefix1?_centreY     equ prefix1?_varK4
  13+ 0000 ~            prefix1?_varK4p1	 equ prefix1?_varK4+1			; D3
  14+ 0000 ~            prefix1?_varK5       DS  6
  15+ 0000 ~            prefix1?_varK5p2     equ prefix1?_varK5+2
  16+ 0000 ~            prefix1?_varK6       DS  6
  17+ 0000 ~            prefix1?_varK6p2     equ prefix1?_varK6+2
  18+ 0000 ~
  19+ 0000 ~            prefix1?_XX12p2      DB 0    ; The line's gradient * 256 (so 1.0 = 256)
  20+ 0000 ~            prefix1?_XX12p3      DB 0    ; The direction of slope ; + LT to BR; - TR to BL
  21+ 0000 ~            prefix1?_XX12p4      DB 0
  22+ 0000 ~            prefix1?_XX12p5      DB 0
  23+ 0000 ~            prefix1?_Delta_x     EQU prefix1?_XX12p2
  24+ 0000 ~            prefix1?_Delta_y     EQU prefix1?_XX12p4
  25+ 0000 ~            prefix1?_Tvar        DB 0    ; The gradient of slope ; 0 if it's a shallow slope (DX > DY) ; &FF if it's a steep slope (DY > DX) Returns:  XX15        m         x1 as an 8-bit coordinate XX15+2               y1 as an 8-bit coordinate
  26+ 0000 ~            prefix1?_Qvar        DB 0
  27+ 0000 ~            prefix1?_Rvar        DB 0    ; general purpose for calcs  Paired with S must be done this way round for SUBHeightFromY1 etc to work
  28+ 0000 ~            prefix1?_Svar        DB 0    ; sign variable
  29+ 0000 ~            prefix1?_SRvarPair   EQU prefix1?_Rvar
  30+ 0000 ~            prefix1?_Xreg        DB 0
  31+ 0000 ~            prefix1?_Yreg        DB 0
  32+ 0000 ~            prefix1?_YXregPair   EQU prefix1?_Xreg
  33+ 0000                                   ENDM
  34+ 0000
  35+ 0000              ;-- Name: LL28 Calculate R = 256 * A / Q
  36+ 0000              ;-- LL28+4              Skips the A >= Q check and always returns with C flag cleared, so this can be called if we know the division will work
  37+ 0000              ;-- LL31                Skips the A >= Q check and does not set the R counter, so this can be used for jumping straight into the division loop if R is already set to 254 and we know the division will work
  38+ 0000              ;   Reg mapping 6502  Z80
  39+ 0000              ;               a     a
  40+ 0000              ;               b     x
  41+ 0000              ;               c     q
  42+ 0000              ;               d     r
  43+ 0000              ;
  44+ 0000              ClippingCodeLL28Macro:      MACRO   prefix1?
  45+ 0000 ~            prefix1?_LL28_6502:         ld      hl,Qvar                 ; CMP Q                  \ If A >= Q, then the answer will not fit in one byte,
  46+ 0000 ~                                        ld      c,(hl)                  ; using c as Q var
  47+ 0000 ~                                        cp      c
  48+ 0000 ~                                        FlipCarryFlag
  49+ 0000 ~                                        jp      c, prefix1?_LL2_6502    ; BCS LL2                \ so jump to LL2 to return 255
  50+ 0000 ~                                        ld      b,$FE                   ; LDX #%11111110         \ Set R to have bits 1-7 set, so we can rotate through 7 loop iterations, getting a 1 each time, and then we use b as Rvar
  51+ 0000 ~            prefix1?_LL31_6502:          sla     a                       ; ASL A                  \ Shift A to the left
  52+ 0000 ~                                        jp      c, prefix1?_LL29_6502             ; BCS LL29               \ If bit 7 of A was set, then jump straight to the subtraction
  53+ 0000 ~                                        FlipCarryFlag                   ;                          If A < N, then C flag is set.
  54+ 0000 ~                                        JumpIfALTNusng c, prefix1?_LL31_SKIPSUB_6502 ; CMP Q              \ If A < Q, skip the following subtraction
  55+ 0000 ~                                                                            ; BCC P%+4
  56+ 0000 ~                                        sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  57+ 0000 ~                                        ClearCarryFlag
  58+ 0000 ~            prefix1?_LL31_SKIPSUB_6502:  FlipCarryFlag
  59+ 0000 ~                                        rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  60+ 0000 ~                                        jp      c, prefix1?_LL31_6502            ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  61+ 0000 ~                                        ld      a,b
  62+ 0000 ~                                        ld      (Rvar),a
  63+ 0000 ~                                        ret                             ; RTS                    \ R left with remainder of division
  64+ 0000 ~            prefix1?_LL29_6502:          sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  65+ 0000 ~                                        SetCarryFlag                    ; SEC                    \ Set the C flag to rotate into the result in R
  66+ 0000 ~                                        rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  67+ 0000 ~                                        jp      c, prefix1?_LL31_6502            ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  68+ 0000 ~                                        ld      a,b                     ; RTS                    \ Return from the subroutine with R containing the
  69+ 0000 ~                                        ld      (Rvar),a                ; .
  70+ 0000 ~                                        ret                             ; .                      \ remainder of the division
  71+ 0000 ~            prefix1?_LL2_6502:          ld      a,$FF                   ; LDA #255               \ The division is very close to 1, so return the closest
  72+ 0000 ~                                        ld      (Rvar),a                ; STA R                  \ possible answer to 256, i.e. R = 255
  73+ 0000 ~                                        SetCarryFlag                    ; we failed so need carry flag set
  74+ 0000 ~                                        ret                             ; RTS                    \ Return from the subroutine
  75+ 0000 ~
  76+ 0000 ~            prefix1?_ADDXRegtoY1:       ld      a,(Xreg)                ; Set y1 = y1 + (Y X)
  77+ 0000 ~                                        ld      c,a
  78+ 0000 ~                                        ld      b,0
  79+ 0000 ~                                        ld      hl,(prefix1?_XX1532)
  80+ 0000 ~                                        ClearCarryFlag
  81+ 0000 ~                                        adc     hl,bc
  82+ 0000 ~                                        ld      (prefix1?_XX1532),hl
  83+ 0000 ~                                        ret
  84+ 0000 ~
  85+ 0000 ~            prefix1?_ADDYXRegtoY1:      ld      bc,(YXregPair)          ; Set y1 = y1 + (Y X)
  86+ 0000 ~                                        ld      hl,(prefix1?_XX1532)
  87+ 0000 ~                                        ClearCarryFlag
  88+ 0000 ~                                        adc     hl,bc
  89+ 0000 ~                                        ld      (prefix1?_XX1532),hl
  90+ 0000 ~                                        ret
  91+ 0000 ~
  92+ 0000 ~            prefix1?_ADDYXRegtoX1:      ld      bc,(YXregPair)          ; Set x1 = x1 + (Y X)
  93+ 0000 ~                                        ld      hl,(prefix1?_XX1510)
  94+ 0000 ~                                        ClearCarryFlag
  95+ 0000 ~                                        adc     hl,bc
  96+ 0000 ~                                        ld      (prefix1?_XX1510),hl
  97+ 0000 ~                                        ret
  98+ 0000 ~
  99+ 0000 ~            prefix1?_SUBBCFromY1:       ld      hl,(prefix1?_XX1532)             ; Set (S R) = (y1_hi y1_lo) - BC where BC can be say screen height
 100+ 0000 ~                                        ClearCarryFlag
 101+ 0000 ~                                        sbc     hl,bc
 102+ 0000 ~                                        ld      (SRvarPair),hl
 103+ 0000 ~                                        ret
 104+ 0000 ~
 105+ 0000 ~            prefix1?_AddSRToYX:         ld      hl,(YXregPair)
 106+ 0000 ~                                        ld      de,(SRvarPair)
 107+ 0000 ~                                        ClearCarryFlag
 108+ 0000 ~                                        adc     hl,de
 109+ 0000 ~                                        ld      (YXregPair),hl
 110+ 0000 ~                                        ret
 111+ 0000 ~
 112+ 0000 ~            prefix1?_ClampX:            ld      a,h
 113+ 0000 ~                                        and     a
 114+ 0000 ~                                        ld      a,l
 115+ 0000 ~                                        ret     z
 116+ 0000 ~                                        jp      p,.Max255
 117+ 0000 ~            .ClampXMin0:                ZeroA
 118+ 0000 ~                                        ret
 119+ 0000 ~            .Max255:                    ld      a,$FF
 120+ 0000 ~                                        ret
 121+ 0000 ~
 122+ 0000 ~            prefix1?_ClampY:            ld      a,h
 123+ 0000 ~                                        and     a
 124+ 0000 ~                                        jp      z,.ClampYlo
 125+ 0000 ~                                        jp      p,.Max127
 126+ 0000 ~            .ClampYMin0:                ZeroA
 127+ 0000 ~                                        ret
 128+ 0000 ~            .Max127:                    ld      a,127
 129+ 0000 ~                                        ret
 130+ 0000 ~            .ClampYlo:                  ld      a,l
 131+ 0000 ~                                        and     a
 132+ 0000 ~                                        ret     p
 133+ 0000 ~                                        ld      a,127
 134+ 0000 ~                                        ret
 135+ 0000                                          ENDM
 136+ 0000              ;-- Rountes to code:
 137+ 0000              ;-- LL118
 138+ 0000              ;-- LL120   Done
 139+ 0000              ;-- LL129   Done
 140+ 0000              ;-- LL123   Done
 141+ 0000                             ; NOTE DOES ABS ONLY
 142+ 0000
 143+ 0000
 144+ 0000                              ;--- LL118 Move along a point until on screen
 145+ 0000              ; In XX1510 x1 as a 16-bit coordinate (x1_hi x1_lo)
 146+ 0000              ;    XX1532 y1 as a 16-bit coordinate (y1_hi y1_lo)
 147+ 0000              ;    XX12p2 The line's gradient * 256 (so 1.0 = 256)
 148+ 0000              ;    XX12p3 The direction of slope: * Positive = top left to bottom right * Negative (bit 7 set) = top right to bottom left
 149+ 0000              ;    T      The gradient of slope:* 0 if it's a shallow slope * &FF if it's a steep slope
 150+ 0000              ;  Out  XX150               x1 as an 8-bit coordinate
 151+ 0000              ;       XX152               y1 as an 8-bit coordinate
 152+ 0000              ;----------------------------------------------------------------------------------------------------------------
 153+ 0000
 154+ 0000
 155+ 0000              ;---------------------------------------------------------------------------------------------------------------------
 156+ 0000              ;--  Calculate the following:
 157+ 0000              ;--   * If T = 0, this is a shallow slope, so calculate (Y X) = (S x1_lo) * XX12+2
 158+ 0000              ;--   * If T <> 0, this is a steep slope, so calculate (Y X) = (S x1_lo) / XX12+2
 159+ 0000              ;-- giving (Y X) the opposite sign to the slope direction in XX12+3.
 160+ 0000              ;---------------------------------------------------------------------------------------------------------------------
 161+ 0000              ClippingCodeLL120Macro:     MACRO   prefix1?
 162+ 0000 ~            prefix1?_LL120_6502:        ld      a,(prefix1?_XX1510)              ;LDA XX15               \ Set R = x1_lo
 163+ 0000 ~                                        ld      (Rvar),a                ;STA R
 164+ 0000 ~                                        call    prefix1?_LL129_6502              ;JSR LL129              \ Call LL129 to do the following:  Q = XX12+2 = line gradient, A = S EOR XX12+3 = S EOR slope direction  (S R) = |S R|
 165+ 0000 ~                                        push    af                      ;PHA                    \ Store A on the stack so we can use it later
 166+ 0000 ~            ; DONT NEED PLUS MESSES UP FLAGS                    push    af                      ;LDX T                  \ If T is non-zero, then it's a steep slope, so jump
 167+ 0000 ~                                        ld      a,(Tvar)                ; .
 168+ 0000 ~                                        ld      (Xreg),a                ;. REDUNDANT REMOVE IN OPTIMISATION
 169+ 0000 ~                                        and     a                       ;BNE LL121              \ down to LL121 to calculate this instead (Y X) = (S R) / Q
 170+ 0000 ~            ; DONT NEED PLUS MESSES UP FLAGS                    pop     af                      ;.                      (recover teh saved A before the cp)
 171+ 0000 ~                                        jr      nz,prefix1?_LL121_6502           ;.
 172+ 0000 ~            ;..   (Y X) = (S R) * Q - must be ABS, sign determined by opposite of the sign of the value on top of stack
 173+ 0000 ~            prefix1?_LL122_6502:         ZeroA                           ;LDA #0                 \ Set A = 0
 174+ 0000 ~
 175+ 0000 ~                                        IFDEF DEBUG_LL122_DIRECT"
 176+ 0000 ~                                              DISPLAY "DIRECT CALL TO LL122 so dummy push a to stack with 0"
 177+ 0000 ~                                              push    af
 178+ 0000 ~                                        ENDIF
 179+ 0000 ~                                        ld      (Xreg),a                ;TAX                    \ Set (Y X) = 0 so we can start building the answer here
 180+ 0000 ~                                        ld      (Yreg),a                ;TAY
 181+ 0000 ~                                        ld      hl,Svar
 182+ 0000 ~                                        ld      bc,(SRvarPair)          ;LSR S                  \ Shift (S R) to the right, so we extract bit 0 of (S R)
 183+ 0000 ~                                        ShiftBCRight1                   ;ROR R                  \ into the C flag
 184+ 0000 ~                                        ld      (SRvarPair),bc
 185+ 0000 ~                                        ld      hl, Qvar                ;ASL Q                  \ Shift Q to the left, catching bit 7 in the C flag
 186+ 0000 ~                                        sla     (hl)                    ;.
 187+ 0000 ~                                        jr      nc, prefix1?_LL126_6502          ;BCC LL126              \ If C (i.e. the next bit from Q) is clear, do not do
 188+ 0000 ~            ; the addition for this bit of Q, and instead skip to LL126 to just do the shifts
 189+ 0000 ~            prefix1?_LL125_6502:        call    AddSRToYX               ;TXA                    \ Set (Y X) = (Y X) + (S R)  starting with the low bytes And then doing the high bytes
 190+ 0000 ~            prefix1?_LL126_6502:        ld      bc,(SRvarPair)          ;LSR S                  \ Shift (S R) to the right
 191+ 0000 ~                                        ShiftBCRight1                   ;ROR R
 192+ 0000 ~                                        ld      (SRvarPair),bc          ;.
 193+ 0000 ~                                        ld      hl, Qvar                ;ASL Q                  \ Shift Q to the left, catching bit 7 in the C flag
 194+ 0000 ~                                        sla     (hl)                    ;.
 195+ 0000 ~                                        jr      c,prefix1?_LL125_6502            ;BCS LL125              \ If C (i.e. the next bit from Q) is set, loop back to LL125 to do the addition for this bit of Q
 196+ 0000 ~                                        jr      nz,prefix1?_LL126_6502           ;BNE LL126              \ If Q has not yet run out of set bits, loop back to LL126 to do the \"shift\" part of shift-and-add until we have done additions for all the set bits in Q, to give us our multiplication result
 197+ 0000 ~                                        pop     af                      ;PLA                    \ Restore A, which we calculated above, from the stack
 198+ 0000 ~                                        and     a                       ;BPL LL133              \ If A is positive jump to LL133 to negate (Y X) and
 199+ 0000 ~                                        jp      p,prefix1?_LL133_6502            ;.
 200+ 0000 ~                                        ;.. return from the subroutine using a tail call
 201+ 0000 ~                                        ret                             ;RTS                    \ Return from the subroutine
 202+ 0000                                  ENDM
 203+ 0000              ;----------------------------------------------------------------------------------------------------------------------------
 204+ 0000              ;-- Calculate the following:
 205+ 0000              ;--         * If T = 0, this is a shallow slope, so calculate (Y X) = (S R) / XX12+2 (does not use X1lo but directly SR)
 206+ 0000              ;--         * If T <> 0, this is a steep slope, so calculate (Y X) = (S R) * XX12+2  (does not use X1lo but directly SR)
 207+ 0000              ;--             giving (Y X) the opposite sign to the slope direction in XX12+3.
 208+ 0000              ClippingCodeLL122Macro:      MACRO   prefix1?
 209+ 0000 ~            prefix1?_LL123_6502:         call    prefix1?_LL129_6502              ;JSR LL129              \ Call LL129 to do the following   Q = XX12+2   = line gradient
 210+ 0000 ~                                         push    af                      ;PHA                    \ Store A on the stack so we can use it later
 211+ 0000 ~            ; DONT NEED PLUS MESSES UP FLAGS                    push    af                      ;LDX T                  \ If T is non-zero, then it's a steep slope, so jump up
 212+ 0000 ~                                         ld      a,(Tvar)                ; .
 213+ 0000 ~                                         ld      (Xreg),a                ;BNE LL122              \ to LL122 to calculate this instead:
 214+ 0000 ~                                         and     a                       ;.
 215+ 0000 ~            ;  DONT NEED PLUS MESSES UP FLAGS                    pop     af                      ;.
 216+ 0000 ~                                         jr      nz,prefix1?_LL122_6502           ;.
 217+ 0000 ~            ;--  The following calculates: (Y X) = (S R) / Q using the same shift-and-subtract algorithm that's documented in TIS2
 218+ 0000 ~            prefix1?_LL121_6502:         ld      a,$FF                   ;LDA #%11111111         \ Set Y = %11111111
 219+ 0000 ~                                         ld      (Yreg),a                ;TAY
 220+ 0000 ~                                         sla     a                       ;ASL A                  \ Set X = %11111110
 221+ 0000 ~                                         ld      (Xreg),a                ;TAX
 222+ 0000 ~            ;--  This sets (Y X) = %1111111111111110, so we can rotate through 15 loop iterations, getting a 1 each time, and then getting a 0 on the 16th iteration... and we can also use it to catch our result bits into bit 0 each time
 223+ 0000 ~            prefix1?_LL130_6502:         ld      bc,(SRvarPair)          ;ASL R                  \ Shift (S R) to the left
 224+ 0000 ~                                        ShiftBCLeft1                    ;.
 225+ 0000 ~                                        ld      (SRvarPair),bc          ;ROL S
 226+ 0000 ~                                        ld      a,(Svar)                ;LDA S                  \ Set A = S
 227+ 0000 ~                                        jr      c, prefix1?_LL131_6502           ;BCS LL131              \ If bit 7 of S was set, then jump straight to the subtraction
 228+ 0000 ~                                        ld      hl,Qvar                 ;CMP Q                  \ If A < Q (i.e. S < Q), skip the following subtractions
 229+ 0000 ~                                        cp      (hl)
 230+ 0000 ~                                        FlipCarryFlag                   ; note flip carry flag here to simulate 6502 operation
 231+ 0000 ~                                        jr      nc,prefix1?_LL132A_6502          ;BCC LL132  (NOTE Carry flag reversed in Z80 for CP)
 232+ 0000 ~            prefix1?_LL131_6502:         FlipCarryFlag                   ;flip carry to make it act like a 6502 borrow
 233+ 0000 ~                                        sbc     (hl)                    ;SBC Q                  \ A >= Q (i.e. S >= Q) so set:
 234+ 0000 ~                                        ld      (Svar),a                ;STA S
 235+ 0000 ~                                        ld      a,(Rvar)                ;LDA R                  \ And then doing the high bytes
 236+ 0000 ~                                        ClearCarryFlag                  ;\   S = (A R) - Q  = (S R) - Q starting with the low bytes (we know the C flag is set so the subtraction will be correct)
 237+ 0000 ~                                        sbc     0                       ;SBC #0
 238+ 0000 ~                                        ld      (Rvar),a                ;STA R
 239+ 0000 ~                                        SetCarryFlag                    ;SEC                    \ Set the C flag to rotate into the result in (Y X)
 240+ 0000 ~                                        jp      prefix1?_LL132_6502              ;added so that we can do a 6502 style carry above
 241+ 0000 ~            prefix1?_LL132A_6502:        nop; FlipCarryFlag
 242+ 0000 ~            prefix1?_LL132_6502:         ld      bc,(YXregPair)          ; Rotate the counter in (Y X) to the left, and catch the
 243+ 0000 ~                                        RollBCLeft1                     ; ROL A                  \ result bit into bit 0 (which will be a 0 if we didn't
 244+ 0000 ~                                        ld      (YXregPair),bc          ; TAX                    \ do the subtraction, or 1 if we did)
 245+ 0000 ~                                        jr      c, prefix1?_LL130_6502           ; BCS LL130              \ If we still have set bits in (Y X), loop back to LL130 to do the next iteration of 15, until we have done the whole division
 246+ 0000 ~                    IFDEF DEBUG_LL121_DIRECT
 247+ 0000 ~                          DISPLAY "DIRECT CALL TO LL121 so dummy push"
 248+ 0000 ~                                        push    af
 249+ 0000 ~                    ENDIF
 250+ 0000 ~                                        pop     af                      ; PLA                    \ Restore A, which we calculated above, from the stack
 251+ 0000 ~                                        and     a                       ; BMI LL128              \ If A is negative jump to LL128 to return from the
 252+ 0000 ~                                        jp      m, prefix1?_LL128_6502           ; .                      \ subroutine with (Y X) as is
 253+ 0000 ~            prefix1?_LL133_6502:          ld      bc,(YXregPair)          ; TXA                    \ Otherwise negate (Y X) using two's complement by first
 254+ 0000 ~                                        macronegate16bc                 ; EOR #%11111111         \ setting the low byte to ~X + 1
 255+ 0000 ~                                        ld      (YXregPair),bc          ; ADC #1                 \ The addition works as we know the C flag is clear from\ when we passed through the BCS above
 256+ 0000 ~            prefix1?_LL128_6502:          ret                             ; RTS                    \ Return from the subroutine
 257+ 0000 ~            ;-------------------------------------------------------------------------------------------------------
 258+ 0000 ~            ;..  Do the following, in this order: Q = XX12+2 A = S EOR XX12+3 (S R) = |S R|
 259+ 0000 ~            ;..  This sets up the variables required above to calculate (S R) / XX12+2 and give the result the opposite sign to XX13+3.
 260+ 0000 ~            prefix1?_LL129_6502:        push    af                      ;LDX XX12+2             \ Set Q = XX12+2
 261+ 0000 ~                                        ld      a,(prefix1?_XX12p2)              ;.
 262+ 0000 ~                                        ld      (Xreg),a                ;.
 263+ 0000 ~                                        ld      (Qvar),a                ;STX Q
 264+ 0000 ~                                        pop     af                      ;.
 265+ 0000 ~                                        ld      a,(Svar)                ;LDA S                  \ If S is positive, jump to LL127
 266+ 0000 ~                                        and     a                       ;BPL LL127
 267+ 0000 ~                                        jp      p,prefix1?_LL127_6502            ;.
 268+ 0000 ~                                        ZeroA                           ;.LDA #0                \ Otherwise set R = -R
 269+ 0000 ~                                        ClearCarryFlag                  ;SEC
 270+ 0000 ~                                        ld      hl, Rvar                ;SBC R
 271+ 0000 ~                                        sbc     (hl)                    ;.
 272+ 0000 ~                                        ld      (Rvar),a                ;STA R
 273+ 0000 ~                                        ld      a,(Svar)                ;LDA S                  \ Push S onto the stack
 274+ 0000 ~                                        push    af                      ;PHA
 275+ 0000 ~                                        xor     $FF                     ;EOR #%11111111         \ Set S = ~S + 1 + C  ?? is this all just doing |Svar|?
 276+ 0000 ~                                        adc     0                       ;ADC #0
 277+ 0000 ~                                        ld      (Svar),a                ;STA S
 278+ 0000 ~                                        pop     af                      ;PLA                    \ Pull the original, negative S from the stack into A
 279+ 0000 ~            prefix1?_LL127_6502:        ld      hl,prefix1?_XX12p3               ;EOR XX12+3             \ Set A = original argument S EOR'd with XX12+3
 280+ 0000 ~                                        xor     (hl)                    ;.
 281+ 0000 ~                                        ret                             ;RTS                    \ Return from the subroutine
 282+ 0000 ~            ;----------------------------------------------------------------------------------------------------------------
 283+ 0000 ~            ;--- LL118 Move along a point until on screen
 284+ 0000 ~            ; In XX1510 x1 as a 16-bit coordinate (x1_hi x1_lo)
 285+ 0000 ~            ;    XX1532 y1 as a 16-bit coordinate (y1_hi y1_lo)
 286+ 0000 ~            ;    XX12p2 The line's gradient * 256 (so 1.0 = 256)
 287+ 0000 ~            ;    XX12p3 The direction of slope: * Positive = top left to bottom right * Negative (bit 7 set) = top right to bottom left
 288+ 0000 ~            ;    T      The gradient of slope:* 0 if it's a shallow slope * &FF if it's a steep slope
 289+ 0000 ~            ;  Out  XX150               x1 as an 8-bit coordinate
 290+ 0000 ~            ;       XX152               y1 as an 8-bit coordinate
 291+ 0000 ~            ;----------------------------------------------------------------------------------------------------------------
 292+ 0000 ~
 293+ 0000 ~            prefix1?_LL118_6502:         ld      a,(prefix1?_XX1510+1)            ; LDA XX15+1             \ If x1_hi is positive, jump down to LL119 to skip the
 294+ 0000 ~                                        and     a                       ; BPL LL119              \ .
 295+ 0000 ~                                        jp      p, prefix1?_LL119_6502           ;                        \ following
 296+ 0000 ~            .X1Negative:                ld      (Svar),a                ; STA S                  \ Otherwise x1_hi is negative, i.e. off the left of the screen, so set S = x1_hi
 297+ 0000 ~                                        call    prefix1?_LL120_6502              ; Call LL120 to calculate:  (Y X) = (S x1_lo) * XX12+2      if T = 0   = x1 * gradient
 298+ 0000 ~                                                                ;                            (Y X) = (S x1_lo) / XX12+2      if T <> 0  = x1 / gradient
 299+ 0000 ~                                                                ; with the sign of (Y X) set to the opposite of the line's direction of slope
 300+ 0000 ~                                        call    ADDYXRegtoY1             ; Set y1 = y1 + (Y X)
 301+ 0000 ~                                        ld      (prefix1?_XX1532),hl             ; .
 302+ 0000 ~                                        ld      hl,0                    ; Set x1 = 0
 303+ 0000 ~                                        ld      (prefix1?_XX1510),hl             ; .
 304+ 0000 ~                                        ld      a,0                     ; set 0 up for replacemetn of the TAX and BEQ bit
 305+ 0000 ~                                        ld      (Xreg),a                ; TAX                    \ Set X = 0 so the next BEQ becomes a jmp but we will do it anyway in next line
 306+ 0000 ~                                        jp      prefix1?_LL134_6502              ; just do the jump to LL134 rather than setting to equal flag and then jumping
 307+ 0000 ~            ;-- Entering LL119 a will always be the value of X1 Hi byte
 308+ 0000 ~            prefix1?_LL119_6502:         jp      z,prefix1?_LL134_6502            ; BEQ LL134              \ x1_hi = 0 then jump down to LL134 to skip the following, as the x-coordinate is already on-screen
 309+ 0000 ~                                                                        ;                        \ (as 0 <= (x_hi x_lo) <= 255)
 310+ 0000 ~                                        ld      (Svar),a                ; STA S                  \ Otherwise x1_hi is positive, i.e. x1 >= 256 and off
 311+ 0000 ~                                        dec     a                       ; DEC S                  \ the right side of the screen, so set S = x1_hi - 1
 312+ 0000 ~                                        ld      (Svar),a                ;
 313+ 0000 ~                                        call    prefix1?_LL120_6502              ; JSR LL120              \ Call LL120 to calculate:  (Y X) = (S x1_lo) * XX12+2      if T = 0   = (x1 - 256) * gradient
 314+ 0000 ~                                                                        ;                        \                           (Y X) = (S x1_lo) / XX12+2      if T <> 0 = (x1 - 256) / gradient
 315+ 0000 ~                                                                        ;                        \ with the sign of (Y X) set to the opposite of the line's direction of slope
 316+ 0000 ~                                        call    ADDYXRegtoY1             ; TXA                    \ Set y1 = y1 + (Y X)
 317+ 0000 ~                                        ld      hl,255                  ; LDX #255               \ Set x1 = 255
 318+ 0000 ~                                        ld      ( prefix1?_XX1510 ),hl             ; STX XX15 ;INX; STX XX15+1
 319+ 0000 ~            ;--  We have moved the point so the x-coordinate is on  screen (i.e. in the range 0-255), so now for the  y-coordinate
 320+ 0000 ~            prefix1?_LL134_6502:        ld      a,(prefix1?_XX1532+1)            ; LDA XX15+3             \ If y1_hi is positive, jump down to LL119 to skip
 321+ 0000 ~                                        and     a                       ; BPL LL135              \ the following
 322+ 0000 ~                                        jp      p, prefix1?_LL135_6502           ; .
 323+ 0000 ~                                        ld      (Svar),a                ; STA S                  \ Otherwise y1_hi is negative, i.e. off the top of the screen, so set S = y1_hi
 324+ 0000 ~                                        ld      a, ( prefix1?_XX1532)             ; LDA XX15+2             \ Set R = y1_lo
 325+ 0000 ~                                        ld      (Rvar),a                ; STA R
 326+ 0000 ~                                        call    prefix1?_LL123_6502              ; JSR LL123              \ Call LL123 to calculate:  (Y X) = (S R) / XX12+2      if T = 0 = y1 / gradient
 327+ 0000 ~                                                                        ;                        \                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
 328+ 0000 ~                                                                        ;                         with the sign of (Y X) set to the opposite of the line's direction of slope
 329+ 0000 ~                                        call    ADDYXRegtoX1            ; TXA                    \ Set x1 = x1 + (Y X)
 330+ 0000 ~                                        ld      hl,0                    ; LDA #0                 \ Set y1 = 0
 331+ 0000 ~                                        ld      ( prefix1?_XX1532),hl             ; STA XX15+2, XX15+3
 332+ 0000 ~            prefix1?_LL135_6502:         ld      bc,128                  ; LDA XX15+2             \ Set (S R) = (y1_hi y1_lo) - screen height
 333+ 0000 ~                                        call    SUBBCFromY1             ; .                      \ .
 334+ 0000 ~                                        jr      c, prefix1?_LL136_6502           ; BCC LL136              \ If the subtraction underflowed, i.e. if y1 < screen height, then y1 is already on-screen, so jump to LL136
 335+ 0000 ~                                                                ;                        \ to return from the subroutine, as we are done
 336+ 0000 ~            ;;-   If we get here then y1 >= screen height, i.e. off the bottom of the screen
 337+ 0000 ~            prefix1?_LL139_6502:         call    prefix1?_LL123_6502              ; JSR LL123              \ Call LL123 to calculate:   (Y X) = (S R) / XX12+2      if T = 0  = (y1 - screen height) / gradient
 338+ 0000 ~            ;                        \                            (Y X) = (S R) * XX12+2      if T <> 0 = (y1 - screen height) * gradient
 339+ 0000 ~            ;                          with the sign of (Y X) set to the opposite of the line's direction of slope
 340+ 0000 ~                                        call    ADDYXRegtoX1            ; TXA                    \ Set x1 = x1 + (Y X)
 341+ 0000 ~                                        ld      hl, 127                 ; LDA #Y*2-1             \ Set y1 = 2 * #Y - 1. The constant #Y is 96, the y-coordinate of the mid-point of the space view (or in our case 127)
 342+ 0000 ~                                        ld      (prefix1?_XX1532),hl             ; STA XX15+3             \ pixel row of the space view
 343+ 0000 ~            prefix1?_LL136_6502:         ret                             ; RTS                    \ Return from the subroutine
 344+ 0000 ~            ;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 345+ 0000 ~            ;-- LL145 LINE CLIP
 346+ 0000 ~            ;-- OPTISIATIONS - VERTICAL HORZONTAL POINT |DX| = |DY| (and all the veriants for +/-)
 347+ 0000 ~            ;-- This routine clips the line from (x1, y1) to (x2, y2) so it fits on-screen, or returns an error if it can't be clipped to fit. The arguments are 16-bit coordinates, and the clipped line is returned using 8-bit screen coordinates.
 348+ 0000 ~            ;-- This part sets XX13 to reflect which of the two points are on-screen and off-screen.
 349+ 0000 ~            ;-- IN  : XX15(1 0) x1 XX15(3 2) y1 XX15(5 4) x2 XX12(1 0) y2
 350+ 0000 ~            ;-- OUT : (X1, Y1), (X2, Y2) Screen coordinate C flag  Clear if the clipped line fits on-screen, set if itdoesn't
 351+ 0000 ~            ;         XX13 The state of the original coordinates on-screen:* 0   = (x2, y2) on-screen* 95(64)  = (x1, y1) on-screen,  (x2, y2) off-screen* 191(128) = (x1, y1) off-screen, (x2, y2) off-screen
 352+ 0000 ~            ;              So XX13 is non-zero if the end of the line was clipped,meaning the next line sent to BLINE can't join onto the end but has to start a new segment
 353+ 0000 ~            ;         SWAP The swap status of the returned coordinates:* &FF if we swapped the values of (x1, y1) and(x2, y2) as part of the clipping process* 0 if the coordinates are still in the same order
 354+ 0000 ~            ; TODO treat horizonal/vert and single pixel as special cases
 355+ 0000                                  ENDM
 356+ 0000
 357+ 0000              ClippingCodeLL145Macro:     MACRO   prefix1?
 358+ 0000 ~            prefix1?_LL145_6502:        ZeroA                           ; LDA #0                 \ Set SWAP = 0
 359+ 0000 ~                                        ld      (SWAP),a                ; STA SWAP
 360+ 0000 ~                                        ld      a,(prefix1?_XX15X2hi)            ; LDA XX15+5             \ Set A = x2_hi (use b as a substibute for a)
 361+ 0000 ~                                        ld      b,a                     ; .
 362+ 0000 ~            ; Note that as we are interested in the sign of XX113 then this needs to be >= 128 or < 128 or 0, we will use 191 as per bbc for now
 363+ 0000 ~            ; for the screen coord we will use 127 though, we use c as a temporay X register
 364+ 0000 ~            prefix1?_LL147_6502:        ld      a,191                   ; LDX #Y*2-1             \ Set X = #Y * 2 - 1. The constant #Y is 96, the y-coordinate of the mid-point of the space view, so this sets Y2 to 191, the y-coordinate of the bottom pixel row of the space view
 365+ 0000 ~                                        ld      (Xreg),a                ; .
 366+ 0000 ~            ;                    ld      a,127
 367+ 0000 ~            ;                    ld      c,a
 368+ 0000 ~            .CheckX2Y2High:             ld      a,b                     ; ORA XX12+1             \ If one or both of x2_hi and y2_hi are non-zero, jump
 369+ 0000 ~                                        ld      hl,prefix1?_XX15Y2hi    ; .
 370+ 0000 ~                                        or      (hl)                    ; .
 371+ 0000 ~                                        jp      nz,prefix1?_LL107_6502  ; BNE LL107              \ to LL107 to skip the following, leaving X at 191
 372+ 0000 ~            .CheckY2Lo:                 ld      a,127 ;,c               ; get back the temporary x reg from c
 373+ 0000 ~                                        ld      hl,prefix1?_XX15Y2lo    ; CPX XX12               \ If y2_lo > the y-coordinate of the bottom of screen (a is being used as X at this point still)
 374+ 0000 ~                                        cp      (hl)                    ; .
 375+ 0000 ~                                        jp      c,prefix1?_LL107_6502   ; BCC LL107              \ then (x2, y2) is off the bottom of the screen, so skip the following instruction, leaving X at 127
 376+ 0000 ~                                        ZeroA                           ; LDX #0                 \ Set X = 0
 377+ 0000 ~                                        ld      (Xreg),a
 378+ 0000 ~            prefix1?_LL107_6502:        ld      a,(Xreg)                ; STX XX13               \ Set XX13 = X, so we have * XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen* XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lois off the bottom of the screen
 379+ 0000 ~                                        ld      ( prefix1?_XX13),a      ; now c is released as a temporary x reg
 380+ 0000 ~                                        ld      a,(prefix1?_XX15X1hi)   ; LDA XX15+1             \ If one or both of x1_hi and y1_hi are non-zero, jump
 381+ 0000 ~                                        ld      hl,prefix1?_XX15Y1hi    ; ORA XX15+3             \ to LL83
 382+ 0000 ~                                        or      (hl)                    ; .
 383+ 0000 ~                                        jp      nz,prefix1?_LL83_6502            ; BNE LL83
 384+ 0000 ~            ; DEBUG SIMPLIFIED CODE, now we just compare y1 lo > 127
 385+ 0000 ~                                        ld      a,(XX1532)              ; If y1_lo > the y-coordinate of the bottom of screen (If A >= N, then C flag is reset.) ;ld      a,127                   ; LDA #Y*2-1             \ If y1_lo > the y-coordinate of the bottom of screen (If A >= N, then C flag is reset.)
 386+ 0000 ~                                        ld      h,127                   ; then (x1, y1) is off the bottom of the screen, so jump                                 ;ld      hl,XX1532               ; CMP XX15+2             \ then (x1, y1) is off the bottom of the screen, so jump
 387+ 0000 ~                                        cp      h                       ; to LL83                                                                                ;cp      (hl)                    ; .                      \ to LL83
 388+ 0000 ~                                        jp      nc, prefix1?_LL83_6502         ; BCC LL83               \ . (y1 > 127 jump, i.e. 127 <= y1 )
 389+ 0000 ~                                        ld      a,( prefix1?_XX13)                ; LDA XX13               \ If we get here, (x1, y1) is on-screen. If XX13 is non-zero, i.e. (x2, y2) is off-screen, jump
 390+ 0000 ~                                        and     a                       ; BNE LL108              \ to LL108 to halve it before continuing at LL83
 391+ 0000 ~                                        jp      nz,prefix1?_LL108_6502
 392+ 0000 ~            ; If we get here, the high bytes are all zero, which means the x-coordinates are < 256 and therefore fit on screen, and neither coordinate is off the bottom of the screen. That means both coordinates are already on
 393+ 0000 ~            ; screen, so we don't need to do any clipping, all weneed to do is move the low bytes into (X1, Y1) and X2, Y2) and return
 394+ 0000 ~            ; X1 = XX15 (10)  Y1 = XX15+1 X2 = XX15+2 Y2 = XX15+3
 395+ 0000 ~            prefix1?_LL146_6502:        ld      hl,(prefix1?_XX15X1lo)           ;  Save X1 to XX1510
 396+ 0000 ~                                        call    prefix1?_ClampX
 397+ 0000 ~                                        ld      (prefix1?_XX15X1lo),a
 398+ 0000 ~                                        ld      hl,(prefix1?_XX15Y1lo)           ;  hl = y1
 399+ 0000 ~                                        call    prefix1?_ClampY
 400+ 0000 ~                                        ld      (prefix1?_XX1510+1),a            ;  XX1510... = [X1][Y1]
 401+ 0000 ~
 402+ 0000 ~                                        ld      hl,(prefix1?_XX15X2lo)           ;  de = x2
 403+ 0000 ~                                        call    prefix1?_ClampX
 404+ 0000 ~                                        ld      (prefix1?_XX1510+2),a            ;  XX1510... = [X1][Y1][X2]
 405+ 0000 ~
 406+ 0000 ~                                        ld      hl,(prefix1?_XX15Y2lo)           ;  bc = y2
 407+ 0000 ~                                        call    prefix1?_ClampY
 408+ 0000 ~                                        ld      (prefix1?_XX1510+3),a            ;  XX1510... = [X1][Y1][X2][Y2]
 409+ 0000 ~                                        ClearCarryFlag                  ; CLC                    \ Clear the C flag as the clipped line fits on-screen
 410+ 0000 ~                                        ret                             ; RTS                    \ Return from the subroutine
 411+ 0000 ~            prefix1?_LL109_6502:        SetCarryFlag                    ; SEC                    \ Set the C flag to indicate the clipped line does not fit on-screen
 412+ 0000 ~                                        ret                             ; RTS                    \ Return from the subroutine
 413+ 0000 ~            prefix1?_LL108_6502:        ld      hl, prefix1?_XX13                 ; LSR XX13               \ If we get here then (x2, y2) is off-screen and XX13 is
 414+ 0000 ~                                        srl     (hl)                    ;                        \ 191, (128)  so shift XX13 right to halve it to 95 (64)
 415+ 0000 ~            ;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 416+ 0000 ~            ;-- LL145 (Part 2 of 4)
 417+ 0000 ~            prefix1?_LL83_6502:         ld      a,( prefix1?_XX13)               ; LDA XX13               \ If XX13 < 128 then only one of the points is on-screen
 418+ 0000 ~                                        and     a                                ; BPL LL115              \ so jump down to LL115 to skip the checks of whether
 419+ 0000 ~                                        jp      p,prefix1?_LL115_6502            ;                        \ both points are in the strips to the right or bottom of the screen
 420+ 0000 ~            ;-- If we get here, both points are off-screen
 421+ 0000 ~                                        ld      a,(prefix1?_XX15X1hi)            ; LDA XX15+1             \ If both x1_hi and x2_hi have bit 7 set, jump to LL109
 422+ 0000 ~                                        ld      hl,prefix1?_XX15X2hi             ; AND XX15+5             \ to return from the subroutine with the C flag set, as
 423+ 0000 ~                                        and     (hl)
 424+ 0000 ~                                        jp      m, prefix1?_LL109_6502           ; BMI LL109              \ the entire line is above the top of the screen
 425+ 0000 ~                                        ld      a,(prefix1?_XX15Y1hi)            ; LDA XX15+3             \ If both y1_hi and y2_hi have bit 7 set, jump to LL109
 426+ 0000 ~                                        ld      hl,prefix1?_XX15Y2hi             ; AND XX12+1             \ to return from the subroutine with the C flag set, as
 427+ 0000 ~                                        and     (hl)                             ; BMI LL109              \ the entire line is to the left of the screen
 428+ 0000 ~                                        jp      m,prefix1?_LL109_6502            ; .
 429+ 0000 ~                                        ld      a,(prefix1?_XX15X1hi)            ; LDX XX15+1             \ Set A = X = x1_hi - 1
 430+ 0000 ~                                        dec     a                                ; DEX
 431+ 0000 ~                                        ld      (Xreg),a                         ; TXA
 432+ 0000 ~                                        push    af                               ; LDX XX15+5     SP+1    \ Set XX12+2 = x2_hi - 1, we need to save a register first
 433+ 0000 ~                                        ld      a,(prefix1?_XX15X2hi)            ; .
 434+ 0000 ~                                        dec     a                                ; DEX
 435+ 0000 ~                                        ld      (Xreg),a                         ; STX XX12+2
 436+ 0000 ~                                        pop     af                               ; .              SP+0    restore a register
 437+ 0000 ~                                        ld      hl,prefix1?_XX15Y2hi             ; ORA XX12+2             \ If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set,
 438+ 0000 ~                                        or      (hl)                             ; .
 439+ 0000 ~                                        jp      p, prefix1?_LL109_6502           ; BPL LL109              \ jump to LL109 to return from the subroutine with the C flag set, as the line doesn't fit on-screen
 440+ 0000 ~            ; for this bit, while z80 uses carry the opposite way to 6502, 6502 uses borrow, in effect inverting the flip
 441+ 0000 ~            ;NOTEFOUND A PATH WHERE IT DOES NOT DO THIS CHECK e.g. 90 B2 8D A2
 442+ 0000 ~            prefix1?_LL83_DEBUG:          ld      a,(prefix1?_XX1532)              ; LDA XX15+2             \ If y1_lo < y-coordinate of screen bottom, clear the C
 443+ 0000 ~                                        cp      128                     ; CMP #Y*2               \ flag, otherwise set it (NOTE FLIPPED IN z80)
 444+ 0000 ~                                        ld      a,(prefix1?_XX1532+1)            ; LDA XX15+3             \ Set XX12+2 = y1_hi - (1 - C), so:
 445+ 0000 ~                                        sbc     0                       ; SBC #0                 \ .
 446+ 0000 ~                                        ld      (prefix1?_XX12p2),a              ; STA XX12+2             \  * Set XX12+2 = y1_hi - 1 if y1_lo is on-screen * Set XX12+2 = y1_hi  otherwise We do this subtraction because we are only interested
 447+ 0000 ~                                        ld      a,(prefix1?_XX1576)              ; LDA XX12               \ If y2_lo < y-coordinate of screen bottom, clear the C
 448+ 0000 ~                                        cp      128                     ; CMP #Y*2               \ flag, otherwise set it
 449+ 0000 ~                                        ld      a,(prefix1?_XX1576+1)            ; LDA XX12+1             \ Set XX12+2 = y2_hi - (1 - C), so:
 450+ 0000 ~                                        sbc     0                       ; SBC #0                   * Set XX12+1 = y2_hi - 1 if y2_lo is on-screen  * Set XX12+1 = y2_hi     otherwise
 451+ 0000 ~                                        ld      hl,prefix1?_XX12p2               ; ORA XX12+2             \ If neither XX12+1 or XX12+2 have bit 7 set, jump to
 452+ 0000 ~                                        or      (hl)                    ; .
 453+ 0000 ~                                        jp      p,prefix1?_LL109_6502            ; BPL LL109              \ LL109 to return from the subroutine with the C flag set, as the line doesn't fit on-screen
 454+ 0000 ~            ;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 455+ 0000 ~            ;-- LL145 (Part 3 of 4) Summary: Clip line: Calculate the line's gradient
 456+ 0000 ~            prefix1?_LL115_6502:        ld      a,(Yreg)                ; TYA                    \ Store Y on the stack so we can preserve it through the call to this routine
 457+ 0000 ~                                        push    af                      ; PHA            SP+1    \ call to this subroutine
 458+ 0000 ~                                        ld      hl,(prefix1?_XX15X2lo)             ; LDA XX15+4             \ Set XX12+2 = x2_lo - x1_lo
 459+ 0000 ~                                        ld      de,(prefix1?_XX15X1lo)             ; LDA XX15+5             \ Set XX12+3 = x2_hi - x1_hi
 460+ 0000 ~                                        ClearCarryFlag                  ; SBC XX15+1
 461+ 0000 ~                                        sbc     hl,de                   ; .
 462+ 0000 ~                                        ld      (delta_x),hl            ; .
 463+ 0000 ~                                        ld      hl,(prefix1?_XX15Y2lo)             ; LDA XX12               \ Set XX12+4 = y2_lo - y1_lo
 464+ 0000 ~                                        ld      de,(prefix1?_XX15Y1lo)             ;
 465+ 0000 ~                                        ClearCarryFlag                  ; SBC XX15+2
 466+ 0000 ~                                        sbc     hl,de                   ; .
 467+ 0000 ~                                        ld      (delta_y),hl            ; .
 468+ 0000 ~            ; So we now have:  delta_x in XX12(3 2)  delta_y in XX12(5 4) where the delta is (x1, y1) - (x2, y2))
 469+ 0000 ~                                        ld      a,(delta_y+1)           ; EOR XX12+3             \ Set S = the sign of delta_x * the sign of delta_y, so
 470+ 0000 ~                                        ld      hl,delta_x+1
 471+ 0000 ~                                        xor     (hl)
 472+ 0000 ~                                        ld      (Svar),a                ; STA S                  \ if bit 7 of S is set, the deltas have different signs (perhaps we should do bit 7 mask ?????????
 473+ 0000 ~                                        ld      hl,(delta_y)            ; LDA XX12+5             \ If delta_y_hi is positive, jump down to LL110 to skip
 474+ 0000 ~                                        ld      a,h
 475+ 0000 ~                                        and     a
 476+ 0000 ~                                        jp      p, prefix1?_LL110_6502  ; BPL LL110              \ the following
 477+ 0000 ~                                        NegHL                           ; LDA #0                 \ Otherwise flip the sign of delta_y to make it
 478+ 0000 ~                                        ld      (delta_y),hl            ; positive, starting with the low bytes
 479+ 0000 ~            prefix1?_LL110_6502:        ld      hl,(delta_x)            ; LDA XX12+3             \ If delta_x_hi is positive, jump down to LL111 to skip
 480+ 0000 ~                                        ld      a,h                     ; BPL LL111              \ the following
 481+ 0000 ~                                        and     a                       ; .
 482+ 0000 ~                                        jp      p,prefix1?_LL111_6502            ; .
 483+ 0000 ~                                        NegHL                           ; SEC                    \ Otherwise flip the sign of delta_x to make it
 484+ 0000 ~                                        ld      (delta_x),hl            ; LDA #0                 \ positive, starting with the low bytes
 485+ 0000 ~            ;--  We now keep halving |delta_x| and |delta_y| until both of them have zero in their high bytes
 486+ 0000 ~            prefix1?_LL111_6502:        ld      hl,(delta_x)
 487+ 0000 ~                                        ld      de,(delta_y)
 488+ 0000 ~                                        ld      a,h                     ; TAX                    \ If |delta_x_hi| is non-zero, skip the following
 489+ 0000 ~                                        or      d                       ; BNE LL112
 490+ 0000 ~                                        jp      z,prefix1?_LL113_6502            ; LDX XX12+5             \ If |delta_y_hi| = 0, jump down to LL113 (as both |delta_x_hi| and |delta_y_hi| are 0)
 491+ 0000 ~            prefix1?_LL112_6502:        ShiftHLRight1                   ; LSR A                  \ Halve the value of delta_x in (A XX12+2)
 492+ 0000 ~                                        ShiftDERight1                   ; LSR XX12+5             \ Halve the value of delta_y XX12(5 4)
 493+ 0000 ~                                        ld      (delta_x),hl
 494+ 0000 ~                                        ld      (delta_y),de            ; write them back so we don't end up in an infinite loop
 495+ 0000 ~                                        jp       prefix1?_LL111_6502                  ; JMP LL111              \ Loop back to LL111
 496+ 0000 ~            ;-- By now, the high bytes of both |delta_x| and |delta_y| are zero
 497+ 0000 ~            prefix1?_LL113_6502:        ZeroA                           ; STX T                  \ We know that X = 0 as that's what we tested with a BEQ  above, so this sets T = 0
 498+ 0000 ~                                        ld      (Tvar),a
 499+ 0000 ~                                        ld      a,(delta_x)             ; LDA XX12+2             \ If delta_x_lo < delta_y_lo, so our line is more
 500+ 0000 ~                                        ld      hl,delta_y              ; CMP XX12+4             \ vertical than horizontal, jump to LL114
 501+ 0000 ~                                        cp      (hl)
 502+ 0000 ~                                        jp      c, prefix1?_LL114_6502  ; BCC LL114              ; if delta y > delta x then its a steep slope so we do 256*dy/dx
 503+ 0000 ~            ;-- If we get here then our line is more horizontal than vertical, so it is a shallow slope
 504+ 0000 ~                                        ld      a,(delta_x)             ; STA Q                  \ Set Q = delta_x_lo
 505+ 0000 ~                                        ld      (Qvar),a                ; .
 506+ 0000 ~                                        ld      a,(delta_y)             ; LDA XX12+4             \ Set A = delta_y_lo
 507+ 0000 ~                                        call    prefix1?_LL28_6502      ; JSR LL28               \ Call LL28 to calculate: R = 256 * A / Q = 256 * delta_y_lo / delta_x_lo
 508+ 0000 ~                                        jp      prefix1?_LL116_6502     ; JMP LL116              \ Jump to LL116, as we now have the line's gradient in R
 509+ 0000 ~            ;-- If we get here then our line is more vertical than horizontal, so it is a steep slope
 510+ 0000 ~            prefix1?_LL114_6502:        ld      a,(delta_y)             ; LDA XX12+4             \ Set Q = delta_y_lo
 511+ 0000 ~                                        ld      (Qvar),a                ; STA Q
 512+ 0000 ~                                        ld      a,(delta_x)             ; LDA XX12+2             \ Set A = delta_x_lo
 513+ 0000 ~                                        call    prefix1?_LL28_6502               ; JSR LL28               \ Call LL28 to calculate: R = 256 * A / Q = 256 * delta_x_lo / delta_y_lo
 514+ 0000 ~                                        ld      a,$FF                   ; DEC T                  \ T was set to 0 above, so this sets T = &FF when our
 515+ 0000 ~                                        ld      (Tvar),a                ;                        \ line is steep
 516+ 0000 ~            ;----------------------------------------------------------------------------------------------------------------
 517+ 0000 ~            ;--- LL116 This part sets things up to call the routine in LL188, which does the actual clipping.
 518+ 0000 ~            ;--  If we get here, then R has been set to the gradient of the line (x1, y1) to(x2, y2), with T indicating the gradient of slope: * 0   = shallow slope (more horizontal than vertical)
 519+ 0000 ~            ;--                                                                                                                                * &FF = steep slope (more vertical than horizontal)
 520+ 0000 ~            ;-- XX13 has been set as follows: * 0   = (x1, y1) off-screen, (x2, y2) on-screen * 95(64)  = (x1, y1) on-screen,  (x2, y2) off-screen * 191(128) = (x1, y1) off-screen, (x2, y2) off-screen
 521+ 0000 ~            prefix1?_LL116_6502:        ld      a,(Rvar)                ; LDA R                  \ Store the gradient in XX12+2
 522+ 0000 ~                                        ld      (prefix1?_XX12p2),a     ; STA XX12+2
 523+ 0000 ~                                        ld      a,(Svar)                ; LDA S                  \ Store the type of slope in XX12+3, bit 7 clear means
 524+ 0000 ~                                        ld      (prefix1?_XX12p3),a              ; STA XX12+3             \ top left to bottom right, bit 7 set means top right to bottom left
 525+ 0000 ~                                        ld      a,( prefix1?_XX13)                ; LDA XX13               \ If XX13 = 0, skip the following instruction
 526+ 0000 ~                                        cp      0                       ; BEQ LL138
 527+ 0000 ~                                        jp      z,prefix1?_LL138_6502            ; .
 528+ 0000 ~                                        jp      p, prefix1?_LLX117_6502          ; If XX13 is positive, it must be 95 (64) as 128 would be negative). This means (x1, y1) is on-screen but (x2, y2) isn't, so we jump
 529+ 0000 ~            ;-- If we get here, XX13 = 0 or 191, so (x1, y1) is off-screen and needs clipping
 530+ 0000 ~            prefix1?_LL138_6502:          call    prefix1?_LL118_6502              ; JSR LL118              \ Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 531+ 0000 ~                                        ld      a,( prefix1?_XX13)                ; LDA XX13               \ If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to
 532+ 0000 ~                                        and     a
 533+ 0000 ~                                        jp      p,prefix1?_LL124_6502            ; BPL LL124              \ LL124 to return with a successfully clipped line
 534+ 0000 ~            ;-- If we get here, XX13 = 191 (128) (both coordinates areoff-screen)
 535+ 0000 ~            prefix1?_LL117_6502:          ld      a,(prefix1?_XX1510+1)            ; LDA XX15+1             \ If either of x1_hi or y1_hi are non-zero, jump to
 536+ 0000 ~                                        ld      hl,prefix1?_XX1532+1             ; ORA XX15+3             \ LL137 to return from the subroutine with the C flag
 537+ 0000 ~                                        or      (hl)
 538+ 0000 ~                                        jp      nz, prefix1?_LL137_6502          ; BNE LL137              \ set, as the line doesn't fit on-screen
 539+ 0000 ~                                        ld      a,(prefix1?_XX1532)              ; LDA XX15+2             \ If y1_lo > y-coordinate of the bottom of the screen
 540+ 0000 ~                                        cp      128                     ; CMP #Y*2               \ jump to LL137 to return from the subroutine with the
 541+ 0000 ~                                        jp      nc, prefix1?_LL137_6502          ; BCS LL137              \ C flag set, as the line doesn't fit on-screen
 542+ 0000 ~            ;-- If we get here, XX13 = 95 or 191, and in both cases (x2, y2) is off-screen, so we now need to swap the (x1, y1) and (x2, y2) coordinates around before doing the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
 543+ 0000 ~            prefix1?_LLX117_6502:         ld      hl,( prefix1?_XX1510)             ; LDX XX15               \ Swap x1_lo = x2_lo
 544+ 0000 ~                                        ld      de,( prefix1?_XX1554)
 545+ 0000 ~                                        ld      ( prefix1?_XX1510),de
 546+ 0000 ~                                        ld      ( prefix1?_XX1554),hl
 547+ 0000 ~                                        ld      hl,( prefix1?_XX1532)             ; LDX XX15+2             \ Swap y1_lo = y2_lo
 548+ 0000 ~                                        ld      de,( prefix1?_XX1576)
 549+ 0000 ~                                        ld      ( prefix1?_XX1532),de
 550+ 0000 ~                                        ld      ( prefix1?_XX1576),hl
 551+ 0000 ~                                        call    prefix1?_LL118_6502              ; JSR LL118              \ Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 552+ 0000 ~                                        ld      hl,SWAP
 553+ 0000 ~                                        dec     (hl)                    ; DEC SWAP               \ Set SWAP = &FF to indicate that we just clipped the line at the (x2, y2) end by swapping the coordinates (the DEC does this as we set SWAP to 0 at the start of this subroutine)
 554+ 0000 ~            prefix1?_LL124_6502:          pop     af                      ; PLA            SP+0    \ Restore Y from the stack so it gets preserved through
 555+ 0000 ~                                        ld      (Yreg),a                ; TAY                    \ the call to this subroutine
 556+ 0000 ~                                        call    prefix1?_LL146_6502              ; JMP LL146              \ Jump up to LL146 to move the low bytes of (x1, y1) and (x2, y2) into (X1, Y1) and (X2, Y2), and return from the subroutine with a successfully clipped line
 557+ 0000 ~                                        ret                             ; then exit so we don't pop it twice
 558+ 0000 ~            prefix1?_LL137_6502:          pop     af                      ; PLA            SP+0    \ Restore Y from the stack so it gets preserved through
 559+ 0000 ~                                        ld      (Yreg),a                ; TAY                    \ the call to this subroutine
 560+ 0000 ~                                        SetCarryFlag                    ; SEC                    \ Set the C flag to indicate the clipped line does not fit on-screen
 561+ 0000 ~                                        ret                             ; RTS                    \ Return from the subroutine
 562+ 0000 ~
 563+ 0000 ~
 564+ 0000 ~            prefix1?_l2_draw_6502_line:   ld      hl,x1                           ; copy from currnet position to 6502 variables
 565+ 0000 ~                                        ld      de, prefix1?_XX1510
 566+ 0000 ~                                        ld      bc,4*2
 567+ 0000 ~                                        ldir
 568+ 0000 ~                                        call    prefix1?_LL145_6502                      ; perform 6502 version
 569+ 0000 ~                                        ret     c                               ; returns if carry is set as its a no draw
 570+ 0000 ~            .CopyBackResults:           ld      hl,0
 571+ 0000 ~                                        ld      (x1),hl
 572+ 0000 ~                                        ld      (y1),hl
 573+ 0000 ~                                        ld      (x2),hl
 574+ 0000 ~                                        ld      (y2),hl
 575+ 0000 ~                                        ld      a,( prefix1?_XX1510)
 576+ 0000 ~                                        ld      (x1),a
 577+ 0000 ~                                        ld      c,a
 578+ 0000 ~                                        ld      a,( prefix1?_XX1510+1)
 579+ 0000 ~                                        ld      (y1),a
 580+ 0000 ~                                        ld      b,a
 581+ 0000 ~                                        ld      a,( prefix1?_XX1510+2)
 582+ 0000 ~                                        ld      (x2),a
 583+ 0000 ~                                        ld      e,a
 584+ 0000 ~                                        ld      a,( prefix1?_XX1510+3)
 585+ 0000 ~                                        ld      (y2),a
 586+ 0000 ~                                        ld      d,a
 587+ 0000 ~                                        ld      a,$FF
 588+ 0000 ~                                        ClearCarryFlag
 589+ 0000 ~                                        ret
 590+ 0000                      ENDM
# file closed: ../../Universe/UniverseMacros/asm_linedraw.asm
  45  0000                                      INCLUDE "../../Universe/UniverseMacros/UniverseVarsDefineMacro.asm"
# file opened: ../../Universe/UniverseMacros/UniverseVarsDefineMacro.asm
   1+ 0000              ; -- AI Core data
   2+ 0000              UnivCoreAIVarsMacro:        MACRO  prefix1?
   3+ 0000 ~            prefix1?_BnKRotXCounter             DB  0                       ; INWK +29
   4+ 0000 ~            prefix1?_BnKRotZCounter             DB  0                       ; INWK +30
   5+ 0000 ~            prefix1?_BnkCam0yLo                 DB  0                       ; INWK +33 ????
   6+ 0000 ~            prefix1?_BnkCam0yHi                 DB  0                       ; INWK +34?????
   7+ 0000 ~            prefix1?_BnKShipType                DB  0
   8+ 0000 ~
   9+ 0000 ~            ; Used to make 16 bit reads a little cleaner in source code
  10+ 0000 ~            prefix1?_BnKzPoint                  DS  3
  11+ 0000 ~            prefix1?_BnKzPointLo                equ prefix1?_BnKzPoint
  12+ 0000 ~            prefix1?_BnKzPointHi                equ prefix1?_BnKzPoint+1
  13+ 0000 ~            prefix1?_BnKzPointSign              equ prefix1?_BnKzPoint+2
  14+ 0000 ~
  15+ 0000 ~            ; Used for medridan drawing routines
  16+ 0000 ~            prefix1?_BnKCx                      DW  0
  17+ 0000 ~            prefix1?_BnKCxSign                  EQU prefix1?_BnKCx+1
  18+ 0000 ~            prefix1?_BnKCy                      DW  0
  19+ 0000 ~            prefix1?_BnKCySign                  EQU prefix1?_BnKCy+1
  20+ 0000 ~            prefix1?_BnKUx                      DW  0
  21+ 0000 ~            prefix1?_BnKUxSign                  EQU prefix1?_BnKUx+1
  22+ 0000 ~            prefix1?_BnKUy                      DW  0
  23+ 0000 ~            prefix1?_BnKUySign                  EQU prefix1?_BnKUy+1
  24+ 0000 ~            prefix1?_BnKVx                      DW  0
  25+ 0000 ~            prefix1?_BnKVxSign                  EQU prefix1?_BnKVx+1
  26+ 0000 ~            prefix1?_BnKVy                      DW  0
  27+ 0000 ~            prefix1?_BnKVySign                  EQU prefix1?_BnKVy+1
  28+ 0000 ~            prefix1?_BnKSinCNT2                 DB  0
  29+ 0000 ~            prefix1?_BnKSinCNT2Sign             DB  0
  30+ 0000 ~            prefix1?_BnKCosCNT2                 DB  0
  31+ 0000 ~            prefix1?_BnKCosCNT2Sign             DB  0
  32+ 0000 ~            prefix1?_BnKUxCos                   DB  0
  33+ 0000 ~            prefix1?_BnKUxCosSign               DB  0
  34+ 0000 ~            prefix1?_BnKUyCos                   DB  0
  35+ 0000 ~            prefix1?_BnKUyCosSign               DB  0
  36+ 0000 ~            prefix1?_BnKVxSin                   DB  0
  37+ 0000 ~            prefix1?_BnKVxSinSign               DB  0
  38+ 0000 ~            prefix1?_BnKVySin                   DB  0
  39+ 0000 ~            prefix1?_BnKVySinSign               DB  0
  40+ 0000 ~            prefix1?_BnKVxVySinSign             DB  0
  41+ 0000 ~            prefix1?_BnKUxUyCosSign             DB  0
  42+ 0000 ~            prefix1?_BnKUxCosAddVxSin           DW  0
  43+ 0000 ~            prefix1?_BnKUyCosSubVySin           DW  0
  44+ 0000 ~            prefix1?_BnKAngle                   DB  0
  45+ 0000 ~            s
  46+ 0000 ~
  47+ 0000 ~            ; General local variables used in universe object
  48+ 0000 ~            prefix1?_BnKTGT                     DB  0
  49+ 0000 ~            prefix1?_BnKSTP                     DB  0
  50+ 0000 ~            prefix1?_BnKLSP                     DS  50              ; move to planet or L2 code ?
  51+ 0000 ~            prefix1?_BnKCNT                     DB  0               ; 93
  52+ 0000 ~            prefix1?_BnKCNT2                    DB  0               ; 93
  53+ 0000 ~            ; Replaced LSX2 and LSY2 with plot heaps of 64 x 2 bytes each + 1 pair for initial point
  54+ 0000 ~                IFDEF MERIDANLINEDEBUG
  55+ 0000 ~            prefix1?_BnKPlotXHeap               DS  $82			   ; &0EC0	    \ LSX2 bline buffer size?
  56+ 0000 ~            prefix1?_BnKPlotYHeap               DS  $82            ; &0F0E	    \ LSY2
  57+ 0000 ~                ENDIF
  58+ 0000 ~            prefix1?_BnKPlotIndex               DB  0
  59+ 0000 ~                DISPLAY "TODO can we remove this and just use BnkCNT = 0 as the same thing?"
  60+ 0000 ~            prefix1?_BnKFlag					DB  0
  61+ 0000 ~
  62+ 0000 ~            ; Post clipping the results are now 8 bit
  63+ 0000 ~            prefix1?_BnKVisibility              DB  0               ; replaces general purpose xx4 in renderingW
  64+ 0000 ~            prefix1?_BnKProjectedY              DB  0
  65+ 0000 ~            prefix1?_BnKProjectedX              DB  0
  66+ 0000 ~            prefix1?_BnKProjected               equ prefix1?_BnKProjectedY  ; resultant projected position
  67+ 0000 ~            prefix1?_XX15Save                   DS  8
  68+ 0000 ~            prefix1?_XX15Save2                  DS  8
  69+ 0000 ~            prefix1?_Radius                     DB  0
  70+ 0000 ~            ; Used when drawing curves for the end value from previous calls to BLINE
  71+ 0000 ~            ; held as 16 bit values pre clipping
  72+ 0000 ~            prefix1?_PrevXPos                   DW 0
  73+ 0000 ~            prefix1?_PrevYPos                   DW 0
  74+ 0000 ~            prefix1?_NewXPos                    DW 0
  75+ 0000 ~            prefix1?_NewYPos                    DW 0
  76+ 0000 ~
  77+ 0000 ~            ; Colouration
  78+ 0000 ~            ; For planets, Colour 1 is main colour, Colour 2 is outer rim
  79+ 0000 ~            ; if we are going to do outer rim then may have colour thickeness as number of pixels to simulat atmosphere
  80+ 0000 ~            prefix1?_Colour1                    DB 0
  81+ 0000 ~            prefix1?_Colour2                    DB 0
  82+ 0000 ~            prefix1?_Colour2Thickness           DB 0
  83+ 0000 ~
  84+ 0000 ~            ;        -- _pl(prf .. "Radius                     DW  0
  85+ 0000 ~            ;        -- _pl(prf .. "RadiusHigh                 equ prefix1?_Radius+1
  86+ 0000                                           ENDM
  87+ 0000
  88+ 0000              UnivPosVarsMacro:            MACRO  prefix1?
  89+ 0000 ~            prefix1?_BnKxlo                     DB  0                       ; INWK+0
  90+ 0000 ~            prefix1?_BnKxhi                     DB  0                       ; there are hi medium low as some times these are 24 bit
  91+ 0000 ~            prefix1?_BnKxsgn                    DB  0                       ; INWK+2
  92+ 0000 ~            prefix1?_BnKylo                     DB  0                       ; INWK+3 \ ylo
  93+ 0000 ~            prefix1?_BnKyhi                     DB  0                       ; INWK+4 \ yHi
  94+ 0000 ~            prefix1?_BnKysgn                    DB  0                       ; INWK +5
  95+ 0000 ~            prefix1?_BnKzlo                     DB  0                       ; INWK +6
  96+ 0000 ~            prefix1?_BnKzhi                     DB  0                       ; INWK +7
  97+ 0000 ~            prefix1?_BnKzsgn                    DB  0                       ; INWK +8
  98+ 0000 ~            prefix1?_CompassX                   DW  0
  99+ 0000 ~            prefix1?_CompassY                   DW  0
 100+ 0000 ~            prefix1?_BnKElipseCenterX           DW  0
 101+ 0000 ~            prefix1?_BnKElipseCenterY           DW  0
 102+ 0000 ~            prefix1?_BnKElipseRadiusU           DW  0
 103+ 0000 ~            prefix1?_BnKElipseRadiusV           DW  0
 104+ 0000                                          ENDM
 105+ 0000
 106+ 0000              ; Rotation data is stored as lohi, but only 15 bits with 16th bit being  a sign bit. Note this is NOT 2'c compliment
 107+ 0000              ;-Rotation Matrix of Universe Object-----------------------------------------------------------------------------------------------
 108+ 0000              UnivRotationVarsMacro:      MACRO prefix1?
 109+ 0000 ~            prefix1?_BnKrotmatSidevX            DW  0                       ; INWK +21
 110+ 0000 ~            prefix1?_BnKrotmatSidev             equ prefix1?_BnKrotmatSidevX
 111+ 0000 ~            prefix1?_BnKrotmatSidevY            DW  0                       ; INWK +23
 112+ 0000 ~            prefix1?_BnKrotmatSidevZ            DW  0                       ; INWK +25
 113+ 0000 ~            prefix1?_BnKrotmatRoofvX            DW  0                       ; INWK +15
 114+ 0000 ~            prefix1?_BnKrotmatRoofv             equ prefix1?_BnKrotmatRoofvX
 115+ 0000 ~            prefix1?_BnKrotmatRoofvY            DW  0                       ; INWK +17
 116+ 0000 ~            prefix1?_BnKrotmatRoofvZ            DW  0                       ; INWK +19
 117+ 0000 ~            prefix1?_BnKrotmatNosevX            DW  0                       ; INWK +9
 118+ 0000 ~            prefix1?_BnKrotmatNosev             EQU prefix1?_BnKrotmatNosevX
 119+ 0000 ~            prefix1?_BnKrotmatNosevY            DW  0                       ; INWK +11
 120+ 0000 ~            prefix1?_BnKrotmatNosevZ            DW  0                       ; INWK +13
 121+ 0000                                          ENDM
 122+ 0000
 123+ 0000
 124+ 0000              XX15DefineMacro: MACRO   prefix1?
 125+ 0000 ~
 126+ 0000 ~            prefix1?_BnKXScaled                  DB  0               ; XX15+0Xscaled
 127+ 0000 ~            prefix1?_BnKXScaledSign              DB  0               ; XX15+1xsign
 128+ 0000 ~            prefix1?_BnKYScaled                  DB  0               ; XX15+2yscaled
 129+ 0000 ~            prefix1?_BnKYScaledSign              DB  0               ; XX15+3ysign
 130+ 0000 ~            prefix1?_BnKZScaled                  DB  0               ; XX15+4zscaled
 131+ 0000 ~            prefix1?_BnKZScaledSign              DB  0               ; XX15+5zsign
 132+ 0000 ~            prefix1?_XX1576                      DW  0    ; y2
 133+ 0000 ~
 134+ 0000 ~            prefix1?_XX15:                       equ prefix1?_BnKXScaled
 135+ 0000 ~            prefix1?_XX15VecX:                   equ prefix1?_XX15
 136+ 0000 ~            prefix1?_XX15VecY:                   equ prefix1?_XX15+1
 137+ 0000 ~            prefix1?_XX15VecZ:                   equ prefix1?_XX15+2
 138+ 0000 ~            prefix1?_BnKXPoint:                  equ prefix1?_XX15
 139+ 0000 ~            prefix1?_BnKXPointLo:                equ prefix1?_XX15+0
 140+ 0000 ~            prefix1?_BnKXPointHi:                equ prefix1?_XX15+1
 141+ 0000 ~            prefix1?_BnKXPointSign:              equ prefix1?_XX15+2
 142+ 0000 ~            prefix1?_BnKYPoint:                  equ prefix1?_XX15+3
 143+ 0000 ~            prefix1?_BnKYPointLo:                equ prefix1?_XX15+3
 144+ 0000 ~            prefix1?_BnKYPointHi:                equ prefix1?_XX15+4
 145+ 0000 ~            prefix1?_BnKYPointSign:              equ prefix1?_XX15+5
 146+ 0000 ~
 147+ 0000 ~            prefix1?_XX1510                      EQU prefix1?_BnKXScaled    ; x1 as a 16-bit coordinate (x1_hi x1_lo)
 148+ 0000 ~            prefix1?_XX1532                      EQU prefix1?_BnKYScaled   ; y1 as a 16-bit coordinate (y1_hi y1_lo)
 149+ 0000 ~            prefix1?_XX1554                      EQU prefix1?_BnKZScaled   ; x2
 150+ 0000 ~            prefix1?_XX1554p1                    EQU prefix1?_XX1554+1
 151+ 0000 ~            prefix1?_XX15X1lo                    EQU prefix1?_XX1510
 152+ 0000 ~            prefix1?_XX15X1hi                    EQU prefix1?_XX1510+1
 153+ 0000 ~            prefix1?_XX15Y1lo                    EQU prefix1?_XX1532
 154+ 0000 ~            prefix1?_XX15Y1hi                    EQU prefix1?_XX1532+1
 155+ 0000 ~            prefix1?_XX15X2lo                    EQU prefix1?_XX1554
 156+ 0000 ~            prefix1?_XX15X2hi                    EQU prefix1?_XX1554+1
 157+ 0000 ~            prefix1?_XX15Y2lo                    EQU prefix1?_XX1210
 158+ 0000 ~            prefix1?_XX15Y2hi                    EQU prefix1?_XX1210+1
 159+ 0000 ~            prefix1?_XX15PlotX1                  EQU prefix1?_XX15
 160+ 0000 ~            prefix1?_XX15PlotY1                  EQU prefix1?_XX15+1
 161+ 0000 ~            prefix1?_XX15PlotX2                  EQU prefix1?_XX15+2
 162+ 0000 ~            prefix1?_XX15PlotY2                  EQU prefix1?_XX15+3
 163+ 0000                          ENDM
 164+ 0000
 165+ 0000              XX12DefineMacro: MACRO   prefix1?
 166+ 0000 ~            ;-- transmat0 --------------------------------------------------------------------------------------------------------------------------
 167+ 0000 ~            ; Note XX12 comes after as some logic in normal processing uses XX15 and XX12 combines
 168+ 0000 ~
 169+ 0000 ~            prefix1?_XX1210                     EQU prefix1?_XX1576
 170+ 0000 ~            prefix1?_XX12p1                     EQU prefix1?_XX1210+1
 171+ 0000 ~            prefix1?_XX12                       EQU prefix1?_XX1210
 172+ 0000 ~
 173+ 0000 ~
 174+ 0000 ~            prefix1?_BnKXX12xLo                 EQU prefix1?_XX12               ; XX12+0
 175+ 0000 ~            prefix1?_BnKXX12xSign               EQU prefix1?_XX12+1   ; XX12+1
 176+ 0000 ~            prefix1?_BnKXX12yLo                 EQU prefix1?_XX12+2   ; XX12+2
 177+ 0000 ~            prefix1?_BnKXX12ySign               EQU prefix1?_XX12+3   ; XX12+3
 178+ 0000 ~            prefix1?_BnKXX12zLo                 EQU prefix1?_XX12+4   ; XX12+4
 179+ 0000 ~            prefix1?_BnKXX12zSign               EQU prefix1?_XX12+5   ; XX12+5
 180+ 0000 ~            prefix1?_XX12Save                   DS  6
 181+ 0000 ~            prefix1?_XX12Save2                  DS  6
 182+ 0000 ~
 183+ 0000 ~            prefix1?_varXX12                    EQU prefix1?_XX12
 184+ 0000 ~            ; Repurposed XX12 when plotting lines
 185+ 0000 ~            prefix1?_BnkY2                      equ prefix1?_XX12+0
 186+ 0000 ~            prefix1?_BnKy2Lo                    equ prefix1?_XX12+0
 187+ 0000 ~            prefix1?_BnkY2Hi                    equ prefix1?_XX12+1
 188+ 0000 ~            prefix1?_BnkDeltaXLo                equ prefix1?_XX12+2
 189+ 0000 ~            prefix1?_BnkDeltaXHi                equ prefix1?_XX12+3
 190+ 0000 ~            prefix1?_BnkDeltaYLo                equ prefix1?_XX12+4
 191+ 0000 ~            prefix1?_BnkDeltaYHi                equ prefix1?_XX12+5
 192+ 0000 ~            prefix1?_BnkGradient                equ prefix1?_XX12+2
 193+ 0000 ~            prefix1?_BnkTemp1                   equ prefix1?_XX12+2
 194+ 0000 ~            prefix1?_BnkTemp1Lo                 equ prefix1?_XX12+2
 195+ 0000 ~            prefix1?_BnkTemp1Hi                 equ prefix1?_XX12+3
 196+ 0000 ~            prefix1?_BnkTemp2                   equ prefix1?_XX12+3
 197+ 0000 ~            prefix1?_BnkTemp2Lo                 equ prefix1?_XX12+3
 198+ 0000 ~            prefix1?_BnkTemp2Hi                 equ prefix1?_XX12+4
 199+ 0000                                          ENDM
 200+ 0000
 201+ 0000              XX16DefineMacro: MACRO   prefix1?
 202+ 0000 ~            ;-- XX16 --------------------------------------------------------------------------------------------------------------------------
 203+ 0000 ~            prefix1?_BnkTransmatSidevX          DW  0               ; XX16+0
 204+ 0000 ~            prefix1?_BnkTransmatSidev           EQU prefix1?_BnkTransmatSidevX
 205+ 0000 ~            prefix1?_BnkTransmatSidevY          DW 0                ; XX16+2
 206+ 0000 ~            prefix1?_BnkTransmatSidevZ          DW 0                ; XX16+2
 207+ 0000 ~            prefix1?_BnkTransmatRoofvX          DW 0
 208+ 0000 ~            prefix1?_BnkTransmatRoofv           EQU prefix1?_BnkTransmatRoofvX
 209+ 0000 ~            prefix1?_BnkTransmatRoofvY          DW 0                ; XX16+2
 210+ 0000 ~            prefix1?_BnkTransmatRoofvZ          DW 0                ; XX16+2
 211+ 0000 ~            prefix1?_BnkTransmatNosevX          DW 0
 212+ 0000 ~            prefix1?_BnkTransmatNosev           EQU prefix1?_BnkTransmatNosevX
 213+ 0000 ~            prefix1?_BnkTransmatNosevY          DW 0                ; XX16+2
 214+ 0000 ~            prefix1?_BnkTransmatNosevZ          DW 0                ; XX16+2
 215+ 0000 ~            prefix1?_BnkTransmatTransX          DW 0
 216+ 0000 ~            prefix1?_BnkTransmatTransY          DW 0
 217+ 0000 ~            prefix1?_BnkTransmatTransZ          DW 0
 218+ 0000 ~            prefix1?_XX16                       equ prefix1?_BnkTransmatSidev
 219+ 0000 ~            ;-- XX16Inv --------------------------------------------------------------------------------------------------------------------------
 220+ 0000 ~            prefix1?_BnkTransInvRow0x0          DW 0
 221+ 0000 ~            prefix1?_BnkTransInvRow0x1          DW 0
 222+ 0000 ~            prefix1?_BnkTransInvRow0x2          DW 0
 223+ 0000 ~            prefix1?_BnkTransInvRow0x3          DW 0
 224+ 0000 ~            prefix1?_BnkTransInvRow1y0          DW 0
 225+ 0000 ~            prefix1?_BnkTransInvRow1y1          DW 0
 226+ 0000 ~            prefix1?_BnkTransInvRow1y2          DW 0
 227+ 0000 ~            prefix1?_BnkTransInvRow1y3          DW 0
 228+ 0000 ~            prefix1?_BnkTransInvRow2z0          DW 0
 229+ 0000 ~            prefix1?_BnkTransInvRow2z1          DW 0
 230+ 0000 ~            prefix1?_BnkTransInvRow2z2          DW 0
 231+ 0000 ~            prefix1?_BnkTransInvRow2z3          DW 0
 232+ 0000 ~
 233+ 0000 ~            prefix1?_XX16Inv                    equ prefix1?_BnkTransInvRow0x0
 234+ 0000                                          ENDM
 235+ 0000
 236+ 0000              XX18DefineMacro: MACRO   prefix1?
 237+ 0000 ~            ;-- XX18 --------------------------------------------------------------------------------------------------------------------------
 238+ 0000 ~            prefix1?_BnkDrawCam0xLo             DB  0               ; XX18+0
 239+ 0000 ~            prefix1?_BnkDrawCam0xHi             DB  0               ; XX18+1
 240+ 0000 ~            prefix1?_BnkDrawCam0xSgn            DB  0               ; XX18+2
 241+ 0000 ~            prefix1?_BnkDrawCam0x               equ prefix1?_BnkDrawCam0xLo
 242+ 0000 ~            prefix1?_BnkDrawCam0yLo             DB  0               ; XX18+3
 243+ 0000 ~            prefix1?_BnkDrawCam0yHi             DB  0               ; XX18+4
 244+ 0000 ~            prefix1?_BnkDrawCam0ySgn            DB  0               ; XX18+5
 245+ 0000 ~            prefix1?_BnkDrawCam0y               equ prefix1?_BnkDrawCam0yLo
 246+ 0000 ~            prefix1?_BnkDrawCam0zLo             DB  0               ; XX18+6
 247+ 0000 ~            prefix1?_BnkDrawCam0zHi             DB  0               ; XX18+7
 248+ 0000 ~            prefix1?_BnkDrawCam0zSgn            DB  0               ; XX18+8
 249+ 0000 ~            prefix1?_BnkDrawCam0z               equ prefix1?_BnkDrawCam0zLo
 250+ 0000 ~            prefix1?_XX18                       equ prefix1?_BnkDrawCam0xLo
 251+ 0000                                          ENDM
 252+ 0000
 253+ 0000              XX25DefineMacro: MACRO   prefix1?
 254+ 0000 ~            ;-- XX25 --------------------------------------------------------------------------------------------------------------------------
 255+ 0000 ~            prefix1?_BnKProjxLo                 DB  0
 256+ 0000 ~            prefix1?_BnKProjxHi                 DB  0
 257+ 0000 ~            prefix1?_BnKProjxSgn                DB  0
 258+ 0000 ~            prefix1?_BnKProjx                   EQU prefix1?_BnKProjxLo
 259+ 0000 ~            prefix1?_BnKProjyLo                 DB  0
 260+ 0000 ~            prefix1?_BnKProjyHi                 DB  0
 261+ 0000 ~            prefix1?_BnKProjySgn                DB  0
 262+ 0000 ~            prefix1?_BnKProjy                   EQU prefix1?_BnKProjyLo
 263+ 0000 ~            prefix1?_BnKProjzLo                 DB  0
 264+ 0000 ~            prefix1?_BnKProjzHi                 DB  0
 265+ 0000 ~            prefix1?_BnKProjzSgn                DB  0
 266+ 0000 ~            prefix1?_BnKProjz                   EQU prefix1?_BnKProjzLo
 267+ 0000 ~            prefix1?_XX25                       EQU prefix1?_BnKProjxLo
 268+ 0000                                          ENDM
 269+ 0000
 270+ 0000              CopyPosToXX15Macro: MACRO   prefix1?
 271+ 0000 ~
 272+ 0000 ~            prefix1?_CopyPosToXX15:    ld hl,prefix1?_Bnkxhi
 273+ 0000 ~                                       ld de,prefix1?_BnkXScaled
 274+ 0000 ~                                       ldi
 275+ 0000 ~                                       ldi
 276+ 0000 ~                                       inc hl ; skip to y high
 277+ 0000 ~                                       ldi
 278+ 0000 ~                                       ldi
 279+ 0000 ~                                       inc hl ; skip to z hig
 280+ 0000 ~                                       ldi
 281+ 0000 ~                                       ldi
 282+ 0000 ~                                       ret
 283+ 0000                                  ENDM
 284+ 0000
 285+ 0000              CopyXX12ScaledToXX18Macro:  MACRO    prefix1?
 286+ 0000 ~            prefix1?_CopyXX12ScaledToXX18:
 287+ 0000 ~            prefix1?_CopyResultToDrawCam:    ld      hl, prefix1?_XX12
 288+ 0000 ~                                             ld      de, prefix1?_XX18
 289+ 0000 ~                                             ldi    ; X12+0 => XX18+0  Set XX18(2 0) = dot_sidev
 290+ 0000 ~                                             inc de ; skip to XX18+2 as it will be on XX18+1
 291+ 0000 ~                                             ldi    ; XX12+1 => XX18+2
 292+ 0000 ~                                             ldi    ; XX12+2 => XX18+3 Set XX12+1 => XX18+2
 293+ 0000 ~                                             inc de ; skip to XX18+5 as it will be on XX18+4
 294+ 0000 ~                                             ldi    ; XX12+3 => XX18+5
 295+ 0000 ~                                             ldi    ; XX12+4 => XX18+6 Set XX18(8 6) = dot_nosev
 296+ 0000 ~                                             inc de ; skip to XX18+8 as it will be on XX18+7
 297+ 0000 ~                                             ldi    ; XX12+5 => XX18+8
 298+ 0000 ~                                             ret
 299+ 0000                                          ENDM
 300+ 0000
 301+ 0000              CopyXX12toXX15Macro:        MACRO    prefix1?
 302+ 0000 ~            prefix1?_CopyXX12toXX15:         ld      hl, prefix1?_BnkXX12xLo
 303+ 0000 ~                                             ld      de, prefix1?_XX18
 304+ 0000 ~                                             ldi      ; xlo
 305+ 0000 ~                                             ldi      ; xsg
 306+ 0000 ~                                             ldi      ; xlo
 307+ 0000 ~                                             ldi      ; xsg
 308+ 0000 ~                                             ldi      ; xlo
 309+ 0000 ~                                             ldi      ; xsg
 310+ 0000 ~                                             ret
 311+ 0000                                          ENDM
 312+ 0000
 313+ 0000              InitialiseUniverseObjMacro: MACRO   prefix1?
 314+ 0000 ~            prefix1?_InitRotMat:    ld      hl, 0
 315+ 0000 ~                                    ld      (prefix1?_BnKrotmatSidevY),hl       ; set the zeroes
 316+ 0000 ~                                    ld      (prefix1?_BnKrotmatSidevZ),hl       ; set the zeroes
 317+ 0000 ~                                    ld      (prefix1?_BnKrotmatRoofvX),hl       ; set the zeroes
 318+ 0000 ~                                    ld      (prefix1?_BnKrotmatRoofvZ),hl       ; set the zeroes
 319+ 0000 ~                                    ld      (prefix1?_BnKrotmatNosevX),hl       ; set the zeroes
 320+ 0000 ~                                    ld      (prefix1?_BnKrotmatNosevY),hl       ; set the zeroes
 321+ 0000 ~            ; Optimised as already have 0 in l
 322+ 0000 ~                                    ld      h, $60	             				; 96 in hi byte
 323+ 0000 ~                                    ;ld      hl,1
 324+ 0000 ~                                    ld      (prefix1?_BnKrotmatSidevX),hl
 325+ 0000 ~                                    ld      (prefix1?_BnKrotmatRoofvY),hl
 326+ 0000 ~            ; Optimised as already have 0 in l
 327+ 0000 ~                                    ld      h, $E0					            ; -96 in hi byte which is +96 with hl bit 7 set
 328+ 0000 ~                                    ld      (prefix1?_BnKrotmatNosevZ),hl
 329+ 0000 ~                                    ret
 330+ 0000                                          ENDM
 331+ 0000
# file closed: ../../Universe/UniverseMacros/UniverseVarsDefineMacro.asm
  46  0000                                      INCLUDE "../../Variables/general_variables_macros.asm"
# file opened: ../../Variables/general_variables_macros.asm
   1+ 0000              ; limited to 255 character length
   2+ 0000              CountLengthHL:          MACRO   Limiter
   3+ 0000 ~                                    ld      de,hl
   4+ 0000 ~                                    ld      bc,Limiter
   5+ 0000 ~                                    xor     a
   6+ 0000 ~                                    cpir
   7+ 0000 ~                                    ClearCarryFlag
   8+ 0000 ~                                    sbc     hl,de
   9+ 0000 ~                                    ld      a,l
  10+ 0000 ~                                    ret
  11+ 0000                                      ENDM
  12+ 0000
  13+ 0000              IncMemMaxN:             MACRO   mem, maxvalue
  14+ 0000 ~                                    ld      a,(mem)
  15+ 0000 ~                                    cp      maxvalue
  16+ 0000 ~                                    jr      c,.IncMaxed
  17+ 0000 ~                                    inc     a
  18+ 0000 ~                                    ld      (mem),a
  19+ 0000 ~            .IncMaxed:
  20+ 0000                                      ENDM
  21+ 0000
  22+ 0000              IncMemMaxNCycle:        MACRO   mem, cyclevalue
  23+ 0000 ~                                    ld      a,(mem)
  24+ 0000 ~                                    inc     a
  25+ 0000 ~                                    cp      cyclevalue
  26+ 0000 ~                                    jr      c,.IncMaxed
  27+ 0000 ~                                    xor     a
  28+ 0000 ~            .IncMaxed:              ld      (mem),a
  29+ 0000                                      ENDM
  30+ 0000
  31+ 0000
  32+ 0000              HalfLengthHL:           MACRO
  33+ 0000 ~                                    ld      b,0
  34+ 0000 ~            .CountLenLoop:          ld      a,(hl)
  35+ 0000 ~                                    cp      0
  36+ 0000 ~                                    jr      z,.DoneCount
  37+ 0000 ~                                    inc     b
  38+ 0000 ~                                    inc     hl
  39+ 0000 ~                                    jr      .CountLenLoop
  40+ 0000 ~            .DoneCount:             ld      a,32
  41+ 0000 ~                                    sub     b
  42+ 0000 ~                                    sra     a
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              MakeInnocentMacro:		MACRO
  46+ 0000 ~            						xor		a
  47+ 0000 ~            						ld		(FugitiveInnocentStatus),a
  48+ 0000              						ENDM
  49+ 0000
  50+ 0000              NoEscapePodMacro:		MACRO
  51+ 0000 ~            						xor		a
  52+ 0000 ~            						ld		(EscapePod),a
  53+ 0000              						ENDM
  54+ 0000
  55+ 0000              MaxFuelLevel            EQU     70              ; 7.0 light years max
  56+ 0000              MaxFuelMacro:			MACRO
  57+ 0000 ~            						ld		a,MaxFuelLevel
  58+ 0000 ~            						ld		(Fuel),a
  59+ 0000              						ENDM
  60+ 0000
  61+ 0000              MaxThrottle:            MACRO
  62+ 0000 ~                                    ld      a,(SHIPMAXSPEED)
  63+ 0000 ~                                    ld      (DELTA),a
  64+ 0000 ~                                    ld      d,a
  65+ 0000 ~                                    ld      e,4
  66+ 0000 ~                                    mul
  67+ 0000 ~                                    ld      (DELT4Lo),de
  68+ 0000                                      ENDM
  69+ 0000
  70+ 0000              ZeroThrottle:           MACRO
  71+ 0000 ~                                    xor     a
  72+ 0000 ~                                    ld      (DELTA),a
  73+ 0000 ~                                    ld      (DELT4Lo),a
  74+ 0000 ~                                    ld      (DELT4Lo+1),a
  75+ 0000                                      ENDM
  76+ 0000
  77+ 0000              ZeroPitch:              MACRO
  78+ 0000 ~                                    xor     a
  79+ 0000 ~                                    ld      (BET2),a
  80+ 0000 ~                                    ld      (BET2FLIP),a
  81+ 0000 ~                                    ld      (JSTY),a
  82+ 0000 ~                                    ld      (BETA),a
  83+ 0000                                      ENDM
  84+ 0000
  85+ 0000              ZeroRoll:               MACRO
  86+ 0000 ~                                    xor     a                              ; zero roll and climb
  87+ 0000 ~                                    ld      (ALP2),a
  88+ 0000 ~                                    ld      (ALP2FLIP),a
  89+ 0000 ~                                    ld      (JSTX),a
  90+ 0000 ~                                    ld      (ALPHA),a
  91+ 0000                                      ENDM
  92+ 0000
  93+ 0000              CorrectPostJumpFuel:    MACRO
  94+ 0000 ~                                    ld      a,(Fuel)
  95+ 0000 ~                                    ld      hl,Distance
  96+ 0000 ~                                    sub     a,(hl)
  97+ 0000 ~                                    ld      (Fuel),a
  98+ 0000                                      ENDM
  99+ 0000
 100+ 0000              AnyMissilesLeft:        MACRO
 101+ 0000 ~                                    ld      a,(NbrMissiles)
 102+ 0000 ~                                    and     a
 103+ 0000                                      ENDM
 104+ 0000
 105+ 0000              SetMissileTargetA:      MACRO
 106+ 0000 ~                                    ld      (MissileTargettingFlag),a   ; Set to slot number clearing bit 7
 107+ 0000                                      ENDM
 108+ 0000
 109+ 0000              IsMissileLaunchFlagged: MACRO
 110+ 0000 ~                                    ld      a,(MissileTargettingFlag)
 111+ 0000 ~                                    and     $80
 112+ 0000                                      ENDM
 113+ 0000
 114+ 0000              SetMissileTargetting:   MACRO
 115+ 0000 ~                                    ld      a,StageMissileTargeting
 116+ 0000 ~                                    ld      (MissileTargettingFlag),a
 117+ 0000                                      ENDM
 118+ 0000
 119+ 0000              ClearMissileTargetting: MACRO
 120+ 0000 ~                                    ld      a,StageMissileNotTargeting
 121+ 0000 ~                                    ld      (MissileTargettingFlag),a
 122+ 0000                                      ENDM
 123+ 0000
 124+ 0000
 125+ 0000              ; Clear targetting bits which signals launch if lower nibble has selected target
 126+ 0000              SetMissileLaunch:       MACRO
 127+ 0000 ~                                    ld      a,(MissileTargettingFlag)
 128+ 0000 ~                                    and     $0F
 129+ 0000 ~                                    ld      (MissileTargettingFlag),a
 130+ 0000                                      ENDM
 131+ 0000
 132+ 0000              LockMissileToA:         MACRO
 133+ 0000 ~                                    or      $80
 134+ 0000 ~                                    ld      (MissileTargettingFlag),a
 135+ 0000                                      ENDM
 136+ 0000
 137+ 0000              ClearECM:               MACRO
 138+ 0000 ~                                    xor     a
 139+ 0000 ~                                    ld      (ECMCountDown),a
 140+ 0000                                      ENDM
 141+ 0000
 142+ 0000
 143+ 0000              ; Will check to see if bit 2 is set, if it is clear, then friendly hence z is set
 144+ 0000              ;                                    if it is set    then hostile hence z is not set
 145+ 0000              IsShipHostile:          MACRO
 146+ 0000 ~                                    ld      a,(ShipNewBitsAddr)
 147+ 0000 ~                                    and     ShipIsHostile
 148+ 0000                                      ENDM
 149+ 0000              ; Will check to see if docking is set, if docking     z flag is clear
 150+ 0000              ;                                      if not docking z flag is set
 151+ 0000              IsShipDocking:          MACRO
 152+ 0000 ~                                    ld      a,(ShipNewBitsAddr)
 153+ 0000 ~                                    and     ShipIsDocking
 154+ 0000                                      ENDM
 155+ 0000
 156+ 0000              ; Will check to see if bit 2 is set, if it is clear, then friendly hence z is set
 157+ 0000              ;                                    if hit is set then hostile hence z is not set
 158+ 0000              IsShipFriendly:         MACRO
 159+ 0000 ~                                    ld      a,(ShipNewBitsAddr)
 160+ 0000 ~                                    and     ShipNotHostile                  ; mask so we only have hostile bit
 161+ 0000                                      ENDM
 162+ 0000
 163+ 0000              ; Will check to see if bit 5 is set, if clear, then not exploding z clear
 164+ 0000              ;                                    if set    then exploding     z set
 165+ 0000              IsShipExploding:        MACRO
 166+ 0000 ~                                    ld      a,(UBnkaiatkecm)
 167+ 0000 ~                                    and     ShipExploding
 168+ 0000                                      ENDM
 169+ 0000
 170+ 0000              ; Checks if ship is a trader, if ship is a trader then z flag is clear
 171+ 0000              ;                             if ship isn't a trader then z flag is set
 172+ 0000              IsShipTrader:           MACRO
 173+ 0000 ~                                    ld      a,(ShipNewBitsAddr)
 174+ 0000 ~                                    and     ShipIsTrader
 175+ 0000                                      ENDM
 176+ 0000              ; Will check if the AI bit is set, if set then z is clear, if clear then z is set
 177+ 0000              IsAIEnabled:            MACRO
 178+ 0000 ~                                    ld      hl, UBnkaiatkecm
 179+ 0000 ~                                    bit 	ShipAIEnabledBitNbr,(hl)
 180+ 0000                                      ENDM
 181+ 0000
 182+ 0000              UpdateLaserOnCounter:   MACRO
 183+ 0000 ~                                    ld      a,(CurrLaserPulseOnCount)
 184+ 0000 ~                                    and     a
 185+ 0000 ~                                    jr      z,.LaserOnIsDone
 186+ 0000 ~                                    dec     a
 187+ 0000 ~                                    ld      (CurrLaserPulseOnCount),a
 188+ 0000 ~                                    jr      z,.LaserOnIsDone
 189+ 0000 ~                                    ldCopyByte CurrLaserPulseOffTime, CurrLaserPulseOffCount
 190+ 0000 ~            .LaserOnIsDone:
 191+ 0000                                      ENDM
 192+ 0000
 193+ 0000              UpdateLaserOffCounter:  MACRO
 194+ 0000 ~                                    ld      a,(CurrLaserPulseOffTime)
 195+ 0000 ~                                    and     a
 196+ 0000 ~                                    jr      z,.LaserOffIsDone
 197+ 0000 ~                                    dec     a
 198+ 0000 ~                                    ld      (CurrLaserPulseOffTime),a
 199+ 0000 ~                                    jr      z,.LaserOffIsDone
 200+ 0000 ~                                    ldCopyByte CurrLaserPulseRest, CurrLaserPulseRestCount
 201+ 0000 ~            .LaserOffIsDone:
 202+ 0000                                      ENDM
 203+ 0000
 204+ 0000              UpdateLaserRestCounter: MACRO
 205+ 0000 ~                                    ld      a,(CurrLaserPulseRestCount)
 206+ 0000 ~                                    and     a
 207+ 0000 ~                                    jr      z,.LaserRestIsDone
 208+ 0000 ~                                    dec     a
 209+ 0000 ~                                    ld      (CurrLaserPulseRestCount),a
 210+ 0000 ~                                    jr      z,.LaserRestIsDone
 211+ 0000 ~                                    ZeroA                                                                           ;    then pulse rate count = 0
 212+ 0000 ~                                    ld      (CurrLaserPulseRateCount),a                                             ;    .
 213+ 0000 ~            .LaserRestIsDone
 214+ 0000                                      ENDM
 215+ 0000
 216+ 0000              ChargeEnergyAndShields: MACRO
 217+ 0000 ~                                    ld      a,$FF
 218+ 0000 ~                                    ld      (PlayerEnergy),a
 219+ 0000 ~                                    ld      (ForeShield),a
 220+ 0000 ~                                    ld      (AftShield),a
 221+ 0000                                      ENDM
 222+ 0000
 223+ 0000              CopyPresentSystemToTarget: MACRO
 224+ 0000 ~                                    ld      hl,(PresentSystemX)
 225+ 0000 ~                                    ld      (TargetSystemX),hl
 226+ 0000                                      ENDM
 227+ 0000
 228+ 0000              CopyTargetSystemToPresent: MACRO
 229+ 0000 ~                                    ld      hl,(TargetSystemX)
 230+ 0000 ~                                    ld      (PresentSystemX),hl
 231+ 0000                                      ENDM
 232+ 0000
 233+ 0000              HalveFugitiveStatus:    MACRO
 234+ 0000 ~                                    ld      hl,FugitiveInnocentStatus
 235+ 0000 ~                                    srl     (hl)
 236+ 0000                                      ENDM
 237+ 0000
 238+ 0000              ClearForceTransition    MACRO
 239+ 0000 ~                                    ld      a,$FF
 240+ 0000 ~                                    ld      (ScreenTransitionForced),a
 241+ 0000                                      ENDM
 242+ 0000
 243+ 0000              ForceTransition:        MACRO newScreen
 244+ 0000 ~                                    ld      a,newScreen
 245+ 0000 ~                                    ld      (ScreenTransitionForced), a
 246+ 0000                                      ENDM
 247+ 0000
 248+ 0000              IsSpaceStationPresent:  MACRO
 249+ 0000 ~                                    ld      a,(SpaceStationSafeZone)
 250+ 0000 ~                                    and     a
 251+ 0000                                      ENDM
 252+ 0000
 253+ 0000              SetSafeZone:            MACRO
 254+ 0000 ~                                    xor     a
 255+ 0000 ~                                    ld      (SpaceStationSafeZone),a
 256+ 0000                                      ENDM
 257+ 0000
 258+ 0000              ClearSafeZone:          MACRO
 259+ 0000 ~                                    ld      a,$FF
 260+ 0000 ~                                    ld      (SpaceStationSafeZone),a
 261+ 0000                                      ENDM
 262+ 0000
 263+ 0000              ClearTemperatures:      MACRO
 264+ 0000 ~                                    xor     a
 265+ 0000 ~                                    ld      (CabinTemperature),a
 266+ 0000 ~                                    ld      (GunTemperature),a
 267+ 0000                                      ENDM
 268+ 0000
 269+ 0000              ClearWarpPressed:       MACRO
 270+ 0000 ~                                    SetMemFalse WarpPressed
 271+ 0000                                      ENDM
 272+ 0000
 273+ 0000              CoolCabin:              MACRO
 274+ 0000 ~                                    ld      a,(CabinTemperature)
 275+ 0000 ~                                    and     a
 276+ 0000 ~                                    jr      z,.AlreadyCool
 277+ 0000 ~                                    dec     a
 278+ 0000 ~                                    ld      (CabinTemperature),a
 279+ 0000 ~            .AlreadyCool:
 280+ 0000                                      ENDM
 281+ 0000
 282+ 0000              CoolLasers:             MACRO
 283+ 0000 ~                                    ld      a,(GunTemperature)
 284+ 0000 ~                                    and     a
 285+ 0000 ~                                    jr      z,.AlreadyCool
 286+ 0000 ~                                    dec     a
 287+ 0000 ~                                    ld      (GunTemperature),a
 288+ 0000 ~            .AlreadyCool:
 289+ 0000                                      ENDM
 290+ 0000
 291+ 0000              ; type 255 is "not fitted"
 292+ 0000
 293+ 0000
 294+ 0000              InitEventCounter:       MACRO
 295+ 0000 ~                                    xor     a
 296+ 0000 ~                                    ld      (EventCounter),a
 297+ 0000                                      ENDM
 298+ 0000
 299+ 0000              ClearMissJump:          MACRO
 300+ 0000 ~                                    ld      a,$FF
 301+ 0000 ~                                    ld      (MissJumpFlag),a
 302+ 0000                                      ENDM
 303+ 0000
 304+ 0000
 305+ 0000              DrainSystem:            MACRO   SystemMem, DrainMem
 306+ 0000 ~                                    ld      a,(DrainMem)
 307+ 0000 ~                                    ld      b,a
 308+ 0000 ~                                    ld      a,(SystemMem)
 309+ 0000 ~                                    sub     a,b
 310+ 0000 ~                                    ld      (SystemMem),a
 311+ 0000 ~                                    jr      c,.ZeroSystem
 312+ 0000 ~                                    jp      .ExitPoint
 313+ 0000 ~            .ZeroSystem:            ZeroA
 314+ 0000 ~                                    ld      (SystemMem),a
 315+ 0000 ~            .ExitPoint
 316+ 0000                                      ENDM
 317+ 0000
 318+ 0000              BoostSystem:            MACRO   SystemMem, BoostMem
 319+ 0000 ~                                    ld      a,(BoostMem)
 320+ 0000 ~                                    ld      b,a
 321+ 0000 ~                                    ld      a,(SystemMem)
 322+ 0000 ~                                    add     b
 323+ 0000 ~                                    ld      (SystemMem),a
 324+ 0000 ~                                    jr      c, .MaxSystem
 325+ 0000 ~                                    jp      .ExitPoint
 326+ 0000 ~            .MaxSystem:             ld      a,255
 327+ 0000 ~                                    ld      (SystemMem),a
 328+ 0000 ~            .ExitPoint
 329+ 0000                                      ENDM
 330+ 0000
 331+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER HasEngineSoundChanged:  MACRO
 332+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ld      a,(EngineSoundChanged)
 333+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         and     a
 334+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ENDM
 335+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER
 336+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER ClearEngineSoundChanged:MACRO
 337+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         xor      a
 338+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ld      (EngineSoundChanged),a
 339+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ENDM
 340+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER
 341+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER SetEngineSoundChanged:  MACRO
 342+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ld      a,$FF
 343+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ld      (EngineSoundChanged),a
 344+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ENDM
 345+ 0000
# file closed: ../../Variables/general_variables_macros.asm
  47  0000                                      INCLUDE "../../Variables/UniverseSlot_macros.asm"
# file opened: ../../Variables/UniverseSlot_macros.asm
   1+ 0000
   2+ 0000              AddJunkCount:           MACRO
   3+ 0000 ~                                    ld      hl,JunkCount
   4+ 0000 ~                                    inc     (hl)
   5+ 0000                                      ENDM
   6+ 0000
   7+ 0000              SubJunkCount:           MACRO
   8+ 0000 ~                                    ld      hl,JunkCount
   9+ 0000 ~                                    dec     (hl)
  10+ 0000                                      ENDM
  11+ 0000
  12+ 0000              ClearJunkCount:         MACRO
  13+ 0000 ~                                    ZeroA
  14+ 0000 ~                                    ld      (JunkCount),a
  15+ 0000                                      ENDM
  16+ 0000
  17+ 0000              AddCop:                 MACRO
  18+ 0000 ~                                    ld      hl,CopCount
  19+ 0000 ~                                    inc     (hl)
  20+ 0000                                      ENDM
  21+ 0000
  22+ 0000              SubCop:                 MACRO
  23+ 0000 ~                                    ld      hl,CopCount
  24+ 0000 ~                                    dec     (hl)
  25+ 0000                                      ENDM
  26+ 0000
  27+ 0000              AddPirateCount:         MACRO
  28+ 0000 ~                                    ld      hl,PirateCount
  29+ 0000 ~                                    inc     (hl)
  30+ 0000                                      ENDM
  31+ 0000
  32+ 0000              SubPirateCount:         MACRO
  33+ 0000 ~                                    ld      hl,PirateCount
  34+ 0000 ~                                    inc     (hl)
  35+ 0000                                      ENDM
  36+ 0000
  37+ 0000              AreCopsPresent:         MACRO
  38+ 0000 ~                                    ld      a,(CopCount)
  39+ 0000 ~                                    and     a
  40+ 0000                                      ENDM
  41+ 0000
  42+ 0000              ; Class == shiptype
  43+ 0000              SetSlotAToUnivClass:    MACRO
  44+ 0000 ~                                    ex      af,af'
  45+ 0000 ~                                    ld      a,(ShipTypeAddr)
  46+ 0000 ~                                    ld      b,a
  47+ 0000 ~                                    ex      af,af'
  48+ 0000 ~                                    call    SetSlotAToClassB
  49+ 0000                                      ENDM
  50+ 0000
  51+ 0000              TestRoomForJunk:        MACRO   Target
  52+ 0000 ~                                    ld      a,3
  53+ 0000 ~                                    JumpIfMemTrue  SpaceStationSafeZone, .DoTest
  54+ 0000 ~                                    add     a,2
  55+ 0000 ~            .DoTest                 JumpIfALTMemusng    JunkCount, Target
  56+ 0000                                      ENDM
  57+ 0000
  58+ 0000              JumpIfSpaceStation:     MACRO   Target
  59+ 0000 ~                                    ld      hl,UniverseSlotType
  60+ 0000 ~                                    ld      a,(hl)
  61+ 0000 ~                                    cp      ShipTypeStation
  62+ 0000                                      ENDM
  63+ 0000
  64+ 0000              ClearSlotMem:           MACRO   mem
  65+ 0000 ~                                    ld      a,(mem)
  66+ 0000 ~                                    call    ClearSlotA
  67+ 0000                                      ENDM
  68+ 0000
  69+ 0000              IsSlotEmpty:            MACRO
  70+ 0000 ~                                    ld      hl,UniverseSlotList
  71+ 0000 ~                                    add     hl,a
  72+ 0000 ~                                    ld      a,(hl)
  73+ 0000 ~                                    cp      0
  74+ 0000                                      ENDM
  75+ 0000
  76+ 0000              IsSlotMissile:          MACRO
  77+ 0000 ~                                    ld      hl,UniverseSlotType
  78+ 0000 ~                                    add     hl,a
  79+ 0000 ~                                    ld      a,(hl)
  80+ 0000 ~                                    cp      ShipTypeMissile
  81+ 0000                                      ENDM
  82+ 0000
  83+ 0000
  84+ 0000              ; Checks if slot is empty else A = ship type
  85+ 0000              ReturnIfSlotAEmpty:     MACRO
  86+ 0000 ~                                    ld      hl,UniverseSlotList
  87+ 0000 ~                                    add     hl,a
  88+ 0000 ~                                    ld      a,(hl)
  89+ 0000 ~                                    inc     a
  90+ 0000 ~                                    ret     z           ; if slot was ff inc would make it 0
  91+ 0000 ~                                    dec     a           ; get original value back for later
  92+ 0000                                      ENDM
  93+ 0000
  94+ 0000              JumpIfSlotAEmpty:       MACRO   Target
  95+ 0000 ~                                    ld      hl,UniverseSlotList
  96+ 0000 ~                                    add     hl,a
  97+ 0000 ~                                    ld      a,(hl)
  98+ 0000 ~                                    inc     a
  99+ 0000 ~                                    jp      z,Target    ; if slot was ff inc would make it 0
 100+ 0000 ~                                    dec     a           ; get original value back for later
 101+ 0000                                      ENDM
 102+ 0000
 103+ 0000              JumpIfSlotHLEmpty:      MACRO   Target
 104+ 0000 ~                                    ld      a,(hl)
 105+ 0000 ~                                    and     a
 106+ 0000 ~                                    jr      nz,Target
 107+ 0000                                      ENDM
# file closed: ../../Variables/UniverseSlot_macros.asm
  48  0000                                      INCLUDE "../../Data/ShipIdEquates.asm"
# file opened: ../../Data/ShipIdEquates.asm
   1+ 0000
   2+ 0000
   3+ 0000
   4+ 0000              ShipID_Adder            EQU 00
   5+ 0000              ShipID_Anaconda         EQU 01
   6+ 0000              ShipID_Asp_Mk_2         EQU 02
   7+ 0000              ShipID_Boa              EQU 03
   8+ 0000              ShipID_CargoType5       EQU 04
   9+ 0000              ShipID_Boulder          EQU 05
  10+ 0000              ShipID_Asteroid         EQU 06
  11+ 0000              ShipID_Bushmaster       EQU 07
  12+ 0000              ShipID_Chameleon        EQU 08
  13+ 0000              ShipID_CobraMk3         EQU 09
  14+ 0000              ShipID_Cobra_Mk_1       EQU 10
  15+ 0000              ShipID_Cobra_Mk_3_P     EQU 11
  16+ 0000              ShipID_Constrictor      EQU 12
  17+ 0000              ShipID_Coriolis         EQU 13
  18+ 0000              ShipID_Cougar           EQU 14
  19+ 0000              ShipID_Dodo             EQU 15
  20+ 0000              ShipID_Dragon           EQU 16
  21+ 0000              ShipID_Escape_Pod       EQU 17
  22+ 0000              ShipID_Fer_De_Lance     EQU 18
  23+ 0000              ShipID_Gecko            EQU 19
  24+ 0000              ShipID_Ghavial          EQU 20
  25+ 0000              ShipID_Iguana           EQU 21
  26+ 0000              ShipID_Krait            EQU 22
  27+ 0000              ShipID_Logo             EQU 23
  28+ 0000              ShipID_Mamba            EQU 24
  29+ 0000              ShipID_Missile          EQU 25
  30+ 0000              ShipID_Monitor          EQU 26
  31+ 0000              ShipID_Moray            EQU 27
  32+ 0000              ShipID_Ophidian         EQU 28
  33+ 0000              ShipID_Plate            EQU 29
  34+ 0000              ShipID_Python           EQU 30
  35+ 0000              ShipID_Python_P         EQU 31
  36+ 0000              ShipID_Rock_Hermit      EQU 32
  37+ 0000              ShipID_ShuttleType9     EQU 33
  38+ 0000              ShipID_Shuttle_Mk_2     EQU 34
  39+ 0000              ShipID_Sidewinder       EQU 35
  40+ 0000              ShipID_Splinter         EQU 36
  41+ 0000              ShipID_TestVector       EQU 37
  42+ 0000              ShipID_Thargoid         EQU 38
  43+ 0000              ShipID_Thargon          EQU 39
  44+ 0000              ShipID_TransportType10  EQU 40
  45+ 0000              ShipID_Viper            EQU 41
  46+ 0000              ShipID_Worm             EQU 42
  47+ 0000              ShipID_Rattler          EQU 43
  48+ 0000
# file closed: ../../Data/ShipIdEquates.asm
  49  0000
  50  0000              SetBorder:              MACRO   value
  51  0000 ~                                    MMUSelectLayer1
  52  0000 ~                                    ld          a,value
  53  0000 ~                                    call        l1_set_border
  54  0000                                      ENDM
  55  0000
  56  0000              charactersetaddr		equ 15360
  57  0000              STEPDEBUG               equ 1
  58  0000
  59  0000              TopOfStack              equ $5CCB ;$6100
  60  0000
  61  0000                                      ORG $5DCB;      $6200
  62  5DCB F3           EliteNextStartup:       di
  63  5DCC ED 91 07 03  .InitialiseClockSpeed:  nextreg     TURBO_MODE_REGISTER,Speed_28MHZ
  64  5DD0 ED 91 69 00  .InitialiseLayerOrder:  nextreg     DISPLAY_CONTROL_1_REGISTER, 0   ; no layer 2
  65  5DD4                                      DISPLAY "Starting Assembly At ", EliteNextStartup
  66  5DD4                                      ; "STARTUP"
  67  5DD4                                      ; Make sure  rom is in page 0 during load
  68  5DD4                                      MMUSelectROMS
  68  5DD4 ED 91 50 FF >                     nextreg EXSDOSMMU0,        BankROM
  68  5DD8 ED 91 51 FF >                     nextreg EXSDOSMMU1,        BankROM
  69  5DDC                                      MMUSelectLayer1
  69  5DDC ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
  70  5DE0 CD 8F E0                             call		l1_cls
  71  5DE3 3E 38                                ld			a,L1ColourInkBlack | L1ColourPaperWhite
  72  5DE5 CD AA E0                             call		l1_attr_cls_to_a
  73  5DE8                                      SetBorder   $FF
  73  5DE8             >                        MMUSelectLayer1
  73  5DE8 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
  73  5DEC 3E FF       >                        ld          a,$FF
  73  5DEE CD B4 E0    >                        call        l1_set_border
  74  5DF1              .InitialisingMessage:   MMUSelectUniverseN  0
  74  5DF1 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
  75  5DF5 CD D9 68                             call        ResetUniv
  76  5DF8 CD 3D 6F     InitialiseMainLoop:     call        ClearUnivSlotList
  77  5DFB                                      MMUSelectKeyboard
  77  5DFB ED 91 57 65 >                     nextreg KeyboardMMU,       BankKeyboard
  78  5DFF CD F7 E0                             call        init_keyboard
  79  5E02                                      ZeroA
  79  5E02 AF          >                        xor a
  80  5E03 32 2D 6B                             ld          (JSTX),a
  81  5E06 32 23 6B                             ld          (JSTY),a
  82  5E09 CD C7 62     .CreateMissle:          call        CreateMissile
  83  5E0C CD D9 62     .CreateTarget:          call        CreateTarget
  84  5E0F              ;...................................................................................................................................
  85  5E0F CD 53 68                             call        DisplayBoiler
  86  5E12              ;...................................................................................................................................
  87  5E12              InitMainLoop:           ZeroA
  87  5E12 AF          >                        xor a
  88  5E13 32 2F 6B                             ld      (ALPHA),a
  89  5E16 32 22 6B                             ld      (BETA),a
  90  5E19              MainLoop:	            MMUSelectMathsBankedFns                                         ; make sure we are in maths routines in case a save paged out
  90  5E19 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
  91  5E1D              ;                        break
  92  5E1D              ;TestAdd:                ld      hl, 20
  93  5E1D              ;                        ld      de, 20
  94  5E1D              ;                        ld      bc, $00
  95  5E1D              ;                        call    ADDHLDESignBC
  96  5E1D              ;                        ld      hl, 10
  97  5E1D              ;                        ld      de, 20
  98  5E1D              ;                        ld      bc, $8000
  99  5E1D              ;                        call    ADDHLDESignBC
 100  5E1D              ;                        ld      hl, 20
 101  5E1D              ;                        ld      de, 10
 102  5E1D              ;                        ld      bc, $0080
 103  5E1D              ;                        call    ADDHLDESignBC
 104  5E1D              ;                        ld      hl, 10
 105  5E1D              ;                        ld      de, 10
 106  5E1D              ;                        ld      bc, $8080
 107  5E1D              ;                        call    ADDHLDESignBC
 108  5E1D              ;                        ld      hl, 20
 109  5E1D              ;                        ld      de, 10
 110  5E1D              ;                        ld      bc, $8000
 111  5E1D              ;                        call    ADDHLDESignBC
 112  5E1D              ;                        ld      hl, 10
 113  5E1D              ;                        ld      de, 20
 114  5E1D              ;                        ld      bc, $0080
 115  5E1D              ;                        call    ADDHLDESignBC
 116  5E1D              ;                        break
 117  5E1D CD 19 70                             call    doRandom
 118  5E20                                                              ; redo the seeds every frame
 119  5E20              ;.. Check if keyboard scanning is allowed by screen. If this is set then skip all keyboard and AI..................................
 120  5E20              InputBlockerCheck:      MMUSelectKeyboard
 120  5E20 ED 91 57 65 >                     nextreg KeyboardMMU,       BankKeyboard
 121  5E24 CD 03 E1                             call    scan_keyboard
 122  5E27              ;-- Key Definitions
 123  5E27              ; Player Pitcn and Roll
 124  5E27              ;   Q/A pitch       O/P roll        W/A Thrust
 125  5E27              ;  Kill Missile and launch from 0,0,0
 126  5E27 3E 22                                ld      a,VK_H
 127  5E29 CD 8D E1                             call    is_vkey_pressed
 128  5E2C CC CB 5E                             call    z, HomeMissile
 129  5E2F              ;  Kill Missile and launch new one
 130  5E2F 3E 26                                ld      a,VK_N
 131  5E31 CD 8D E1                             call    is_vkey_pressed
 132  5E34 CC FC 5E                             call    z, RandomMissile
 133  5E37              ; Reset missile to identity matrix
 134  5E37 3E 1B                                ld      a,VK_I
 135  5E39 CD 8D E1                             call    is_vkey_pressed
 136  5E3C CC AD 5E                             call    z, IdentityMissile
 137  5E3F              ; Tidy and Normalise Vector
 138  5E3F 3E 04                                ld      a,VK_V
 139  5E41 CD 8D E1                             call    is_vkey_pressed
 140  5E44 CC 03 5F                             call    z, TidyMissile
 141  5E47              ; Randomise Target Position
 142  5E47 3E 0E                                ld      a,VK_T
 143  5E49 CD 8D E1                             call    is_vkey_pressed
 144  5E4C CC 0B 5F                             call    z, RandomTarget
 145  5E4F              ; Run or pause missile
 146  5E4F 3E 19                                ld      a,VK_P
 147  5E51 CD 8D E1                             call    is_vkey_pressed
 148  5E54 CC B7 5E                             call    z, ToggleMissileState
 149  5E57
 150  5E57 3E 06                                ld      a,VK_S
 151  5E59 CD 8D E1                             call    is_vkey_pressed
 152  5E5C CC C0 5E                             call    z, StepMissileState
 153  5E5F
 154  5E5F              ;.. Update values based on movekey keys, may likley need damping as this coudl be very fast
 155  5E5F
 156  5E5F 3A B6 5E     .UpdateShipsControl:    ld      a,(MissileState)
 157  5E62 A7                                   and     a
 158  5E63 CA 7E 5E                             jp      z,.NotRunning
 159  5E66 FE 01                                cp      1
 160  5E68 C2 6F 5E                             jp      nz,.CalcValues
 161  5E6B                                      ZeroA
 161  5E6B AF          >                        xor a
 162  5E6C 32 B6 5E                             ld      (MissileState),a
 163  5E6F CD 14 5F     .CalcValues:            call    UpdateTacticsVars
 164  5E72 CD 84 5E                             call    RenderActions
 165  5E75 CD 61 5F     .Running:               call    UpdateUniverseObjects
 166  5E78 CD 91 5E                             call    RenderPositions
 167  5E7B C3 19 5E                             jp      MainLoop
 168  5E7E              ;.. Render Ship ...................................................................................................................
 169  5E7E CD 91 5E     .NotRunning:            call    RenderPositions
 170  5E81              ;.. Flip Buffer ..................................................................................................................
 171  5E81 C3 19 5E                             jp      MainLoop
 172  5E84
 173  5E84 CD EA 65     RenderActions:          call    DisplayAccellSpeed
 174  5E87 CD 01 66                             call    DisplayRollPitch
 175  5E8A CD 3C 65                             call    DisplayDotProduct
 176  5E8D CD 98 64                             call    DisplayActionStatus
 177  5E90 C9                                   ret
 178  5E91
 179  5E91              RenderPositions:        DISPLAY "TODO Copy missile and target to buffers to print"
 180  5E91                                      MMUSelectUniverseN 2
 180  5E91 ED 91 56 48 >                     nextreg UniverseMMU,       BankUNIVDATA0+2
 181  5E95 16 0A                                ld      d,RowTarget
 182  5E97 CD B4 64                             call    DisplayPosition
 183  5E9A                                      MMUSelectUniverseN 1
 183  5E9A ED 91 56 47 >                     nextreg UniverseMMU,       BankUNIVDATA0+1
 184  5E9E 16 02                                ld      d,RowMissle
 185  5EA0 CD B4 64                             call    DisplayPosition
 186  5EA3 CD CE 65                             call    DisplayMatrix
 187  5EA6 CD F8 64                             call    DisplayRelative
 188  5EA9 CD 1A 65                             call    DisplayDirection
 189  5EAC C9                                   ret
 190  5EAD
 191  5EAD              IdentityMissile:        MMUSelectUniverseN 1
 191  5EAD ED 91 56 47 >                     nextreg UniverseMMU,       BankUNIVDATA0+1
 192  5EB1 CD CB C7                             call    InitialiseOrientation
 193  5EB4 C9                                   ret
 194  5EB5
 195  5EB5 00           CalcState               DB      0
 196  5EB6 00           MissileState            DB      0
 197  5EB7
 198  5EB7 3A B6 5E     ToggleMissileState:     ld      a,(MissileState)
 199  5EBA EE 80                                xor     $80                 ; bit 7 controlls constant run  bit 1 step
 200  5EBC 32 B6 5E                             ld      (MissileState),a
 201  5EBF C9                                   ret
 202  5EC0
 203  5EC0 3A B6 5E     StepMissileState:       ld      a,(MissileState)
 204  5EC3 A7                                   and     a
 205  5EC4 C0                                   ret     nz  ; Can not step in running mode
 206  5EC5 3E 01                                ld      a,1
 207  5EC7 32 B6 5E                             ld      (MissileState),a
 208  5ECA C9                                   ret
 209  5ECB
 210  5ECB              ;-- Home Missile Position ---------------------------------------------------------------------------------------------------------
 211  5ECB              HomeMissile:            MMUSelectUniverseN 1
 211  5ECB ED 91 56 47 >                     nextreg UniverseMMU,       BankUNIVDATA0+1
 212  5ECF 21 20 C0                             ld      hl,UBnKxlo
 213  5ED2 36 00                                ld      (hl),0
 214  5ED4 11 21 C0                             ld      de,UBnKxlo+1
 215  5ED7 01 08 00                             ld      bc,8
 216  5EDA ED B0                                ldir
 217  5EDC C9                                   ret
 218  5EDD
 219  5EDD DD 21 20 C0  RandomPosition:         ld      ix,UBnKxlo
 220  5EE1 CD EF 5E                             call    SetS24Random
 221  5EE4 DD 21 23 C0                          ld      ix,UBnKylo
 222  5EE8 CD EF 5E                             call    SetS24Random
 223  5EEB DD 21 26 C0                          ld      ix,UBnKzlo
 224  5EEF CD 08 70     SetS24Random:           call    doRandomS24
 225  5EF2 DD 77 00                             ld      (ix+0),a
 226  5EF5 DD 73 01                             ld      (ix+1),e
 227  5EF8 DD 72 02                             ld      (ix+2),d
 228  5EFB C9                                   ret
 229  5EFC              ;-- Random Missile Position -------------------------------------------------------------------------------------------------------
 230  5EFC              RandomMissile:          MMUSelectUniverseN 1
 230  5EFC ED 91 56 47 >                     nextreg UniverseMMU,       BankUNIVDATA0+1
 231  5F00 C3 DD 5E                             jp      RandomPosition
 232  5F03              ;-- Tidy Missile Vectors ---------------------------------------------------------------------------------------------------------
 233  5F03              TidyMissile:            MMUSelectUniverseN 1
 233  5F03 ED 91 56 47 >                     nextreg UniverseMMU,       BankUNIVDATA0+1
 234  5F07 CD 2D 7E                             call    TidyVectorsIX
 235  5F0A C9                                   ret
 236  5F0B              ;-- Random Target Position --------------------------------------------------------------------------------------------------------
 237  5F0B              RandomTarget:           MMUSelectUniverseN 2
 237  5F0B ED 91 56 48 >                     nextreg UniverseMMU,       BankUNIVDATA0+2
 238  5F0F C3 DD 5E                             jp      RandomPosition
 239  5F12 C9                                   ret
 240  5F13              ;.. Keyboard Routines .............................................................................................................
 241  5F13
 242  5F13
 243  5F13              ;..Update Universe Objects.........................................................................................................
 244  5F13              ;..................................................................................................................................
 245  5F13              ;                           DEFINE ROTATIONDEBUG 1
 246  5F13              ;                           DEFINE CLIPDEBUG 1
 247  5F13 00           CurrentShipUniv:        DB      0
 248  5F14              ;..................................................................................................................................
 249  5F14              ; if ship is destroyed or exploding then z flag is clear, else z flag is set
 250  5F14              ;..................................................................................................................................
 251  5F14              ; calculate details of direction and dot products
 252  5F14              UpdateTacticsVars:      MMUSelectUniverseN      1
 252  5F14 ED 91 56 47 >                     nextreg UniverseMMU,       BankUNIVDATA0+1
 253  5F18 CD 6E 62                             call    LoadTargetData              ; Target position to UBnKTarget Pos
 254  5F1B CD 8D 62                             call    CalculateRelativePos        ; Target - missile to UBnKOffset
 255  5F1E CD 37 62                             call    CheckDistance               ; Calculate distance, near far
 256  5F21 CD EB 60                             call    CopyOffsetToDirection       ; Copy UBnKOffset to UBnKDirection
 257  5F24 CD FB 60                             call    NormaliseDirection          ; Normalise Direction into UBnKDirNorm
 258  5F27 21 36 C0                             ld      hl,UBnkrotmatNosev          ; Copy nose to tactics matrix and calculate dot product in a
 259  5F2A CD F2 61                             call    CalculateDotProducts        ; AHL = dot product of missile pos and nose
 260  5F2D 22 7D C0                             ld      (UBnKDotProductNose),hl     ; .
 261  5F30 32 7F C0                             ld      (UBnKDotProductNoseSign),a  ; .
 262  5F33                                      ;and     $80; THSI MAY BE THE FIX BUT ROOF DO PRODUCT IS GIVING WHACKY VALUES
 263  5F33 CA 3F 5F                             jp      z,.PositiveNose
 264  5F36 CD A1 66     .NegativeNose:          call    SetStatusBehind
 265  5F39 CD DD 66                             call    ClearStatusForward
 266  5F3C C3 45 5F                             jp      .DoRoofDot
 267  5F3F CD D7 66     .PositiveNose:          call    ClearStatusBehind
 268  5F42 CD A7 66                             call    SetStatusForward
 269  5F45 21 30 C0     .DoRoofDot:             ld      hl,UBnkrotmatRoofv          ; Copy roof to tactics matrix and calculate dot product in a
 270  5F48 CD F2 61                             call    CalculateDotProducts        ; AHL = dot product of missile pos and roof
 271  5F4B                                      ;ld      a,h
 272  5F4B                                      ;xor     $80
 273  5F4B                                      ;ld      h,a
 274  5F4B 22 80 C0                             ld      (UBnKDotProductRoof),hl     ; .
 275  5F4E 32 82 C0                             ld      (UBnKDotProductRoofSign),a  ; .
 276  5F51 21 2A C0     .DoSideDot:             ld      hl,UBnkrotmatSidev          ; Copy roof to tactics matrix and calculate dot product in a
 277  5F54 CD F2 61                             call    CalculateDotProducts        ; AHL = dot product of missile pos and roof
 278  5F57 22 83 C0                             ld      (UBnKDotProductSide),hl     ; .
 279  5F5A 32 85 C0                             ld      (UBnKDotProductSideSign),a  ; .
 280  5F5D                                      ; as we calculate target - missile the signs are already reversed
 281  5F5D                                      ;call    FlipDirectionSigns          ; Now the target is looking at the missile rather than missile at target
 282  5F5D              ;.. Missile Tactics ...............................................................................................................
 283  5F5D CD 6F 5F                             call    SeekingLogic
 284  5F60 C9                                   ret
 285  5F61              ;..................................................................................................................................
 286  5F61              ; Replacement for MVEIT routine
 287  5F61              UpdateUniverseObjects:  MMUSelectUniverseN      1
 287  5F61 ED 91 56 47 >                     nextreg UniverseMMU,       BankUNIVDATA0+1
 288  5F65              ;.. Update Position ................................................................................................................................
 289  5F65 CD 78 D6                             call    ApplyShipRollAndPitch
 290  5F68 CD BE D7                             call    ApplyShipSpeed
 291  5F6B CD 0F C7                             call    UpdateSpeedAndPitch                             ; update based on rates of speed roll and pitch accelleration/decelleration
 292  5F6E C9                                   ret
 293  5F6F              ;..................................................................................................................................
 294  5F6F              ; For now no random numbers
 295  5F6F              ;  later random < 16 do nothing
 296  5F6F              ; if dot product for nose is negative then its over 90 degrees off
 297  5F6F
 298  5F6F              ; dot product of 36 is direct facing (96*96/256)
 299  5F6F              ; Angle table    +                  -
 300  5F6F              ;             36 =  0 (head on)  36 = 180
 301  5F6F              ;             35 = 15            35 = 166
 302  5F6F              ;             31 = 30            31 = 149
 303  5F6F              ;             27 = 41            27 = 138
 304  5F6F              ;             25 = 45            25 = 133
 305  5F6F              ;             22 = 52            22 = 127
 306  5F6F              ;             18 = 60            18 = 120
 307  5F6F              ;             15 = 65            15 = 114
 308  5F6F              ;             10 = 73            10 = 106
 309  5F6F              ;              8 = 77             8 = 102
 310  5F6F              ;              7 = 78             7 = 101
 311  5F6F              ;              3 = 85             3 = 94
 312  5F6F              ;              0 = 90             0 = 90
 313  5F6F              ; Using nose dot product (in original CNT is nose dot product
 314  5F6F              ; it nose is pointing at target then accellerate to max speed
 315  5F6F              ; if nose is pointing > +/- 45 then then slow down slightly
 316  5F6F              ; if nose is pointing > +/- 90 then then slow down hard
 317  5F6F              ; Note impact is 0000.XX on all points
 318  5F6F              ; if nose angle to left roll right, if nose angle is right roll left
 319  5F6F              ; Pitch counter sign = xor roof sign
 320  5F6F              ; roll counter sign =
 321  5F6F
 322  5F6F              ; Original    CNT = NoseDot bit flipped
 323  5F6F              ;             AX  = RoofDot
 324  5F6F              ;             pitch counter = 3 or  AX Sign flipped
 325  5F6F              ;             A  = abs (roll counter)
 326  5F6F              ;             if a < 16
 327  5F6F              ;                  AX = SideDot
 328  5F6F              ;                  roll counter = 5 or (pitch counter sign xdor sidedot sign)
 329  5F6F              ;             get back nosedot is used to control speed
 330  5F6F              ;             if its positive & nosedot >= 22
 331  5F6F              ;                 accelleration = 3
 332  5F6F              ;             else
 333  5F6F              ;                 a = abs (a)
 334  5F6F              ;                 if a >= 18
 335  5F6F              ;                     accelleration = - 2
 336  5F6F              ; we want roof and side to be 90 degrees to the target position with nose pointing at it
 337  5F6F              ; so we pitch until 90 degrees
 338  5F6F
 339  5F6F              SeekingLogic:
 340  5F6F              ; If the roof dot product is positive then its pointing 0 to 90 degrees to target so needs to pull up
 341  5F6F              ;                         if negative then its pointing 0 to -90 degrees (or over 90 degrees) then pitch down
 342  5F6F              ;                         so it will dither around 90 degrees eventually
 343  5F6F 2A 81 C0     .calculatePitch:        ld      hl,(UBnKDotProductRoof+1)   ; get l roof and h sign
 344  5F72 7C                                   ld      a,h                         ; a = sign of dot product
 345  5F73 F6 03                                or      3                           ; a = sign of dot product or 3
 346  5F75 EE 80                                xor     $80
 347  5F77 32 89 C0     .donePitch:             ld      (UBnKPitchCounter),a         ; Save to z rotation (pitch)
 348  5F7A FA 83 5F                             jp      m,.negativePitch            ; sort out diag flags
 349  5F7D CD 95 66                             call    SetStatusPitchPlus          ;
 350  5F80 C3 86 5F                             jp      .processRoll                ;
 351  5F83 CD 9B 66     .negativePitch:         call    SetStatusPitchMinus         ;
 352  5F86              ; Check current roll counter if its > 16 then already rolling so do nothing
 353  5F86              ; else get the side dot product, again if its positive then its 0 to 90 degrees to target,
 354  5F86              ;                                                           so it should roll right to correct
 355  5F86 3A 88 C0     .processRoll:           ld      a,(UBnKRollCounter)         ;
 356  5F89 47                                   ld      b,a                         ; save counter for laterd
 357  5F8A E6 7F                                and     $7F                         ; a = abs roll counter
 358  5F8C                                      JumpIfAGTENusng 16, .processAcceleration ; if a >= 16 skip roll block
 358  5F8C FE 10       >                        cp     16
 358  5F8E D2 AB 5F    >                        jp		nc,.processAcceleration
 359  5F91 2A 84 C0                             ld      hl,(UBnKDotProductSide+1)   ; l = roof dot h = sign
 360  5F94 3A 89 C0                             ld      a,(UBnKPitchCounter)        ; so if the pitch and side product have oposite signs then + roll, else - roll
 361  5F97 AC                                   xor     h
 362  5F98 E6 80                                and     $80                         ; then filter to just sign bit
 363  5F9A              ;                        xor     $80                         ; if the signs were the same then anti clockwise, if different then clockwise
 364  5F9A F6 05                                or      5                           ; and bring in 5
 365  5F9C 32 88 C0                             ld      (UBnKRollCounter),a         ; and set counter for roll
 366  5F9F FA A8 5F                             jp      m,.NegativeRoll
 367  5FA2 CD 89 66                             call    SetStatusRollPlus
 368  5FA5 C3 AB 5F                             jp      .processAcceleration
 369  5FA8 CD 8F 66     .NegativeRoll:          call    SetStatusRollMinus
 370  5FAB              ; Check the nose dot product, if facing accellerate, if not facing  then slow down, but if its way off just coast
 371  5FAB 2A 7E C0     .processAcceleration:   ld      hl,(UBnKDotProductNose+1)   ; fetch nose dot product
 372  5FAE 7C                                   ld      a,h
 373  5FAF A7                                   and     a
 374  5FB0 FA C5 5F                             jp      m,.processDeceleration      ; if the dot product is neagtive handl deceleration
 375  5FB3 7D                                   ld      a,l                         ; if its less than 22 also process deceleration
 376  5FB4                                      JumpIfALTNusng 22 ,.processDeceleration
 376  5FB4 FE 16       >                        cp      22
 376  5FB6 DA C5 5F    >                        jp		c, .processDeceleration
 377  5FB9 3E 03        .ItsAcceleration:       ld      a,3
 378  5FBB 32 87 C0                             ld      (UBnKAccel),a
 379  5FBE CD 83 66                             call    SetStatusFast
 380  5FC1 CD BF 66                             call    ClearStatusSlow
 381  5FC4 C9                                   ret
 382  5FC5 7D           .processDeceleration:   ld      a,l                         ; a = abs dot product
 383  5FC6                                      ReturnIfALTNusng 18                 ; if its < 18 then way off so coast
 383  5FC6 FE 12       >                        cp    18
 383  5FC8 D8          >                        ret	 c
 384  5FC9 3E FE                                ld      a,-2                        ; else missiles slow by -2
 385  5FCB 32 87 C0                             ld      (UBnKAccel),a
 386  5FCE CD 7D 66                             call    SetStatusSlow
 387  5FD1 CD C5 66                             call    ClearStatusFast
 388  5FD4 C9                                   ret
 389  5FD5              .NoSpeed:               ZeroA
 389  5FD5 AF          >                        xor a
 390  5FD6 32 87 C0                             ld      (UBnKAccel),a
 391  5FD9 CD BF 66                             call    ClearStatusSlow
 392  5FDC CD C5 66                             call    ClearStatusFast
 393  5FDF C9                                   ret
 394  5FE0
 395  5FE0
 396  5FE0 3A 89 C0     oldseekinglogic:        ld      a,(UBnKPitchCounter)
 397  5FE3 A7                                   and     a
 398  5FE4 CC F6 5F                             call    z, AdjustPitch              ; only call if there are no existing pitch orders
 399  5FE7 3A 88 C0                             ld      a,(UBnKRollCounter)
 400  5FEA A7                                   and     a
 401  5FEB CC 31 60                             call    z, AdjustRoll               ; only call if there are no existing roll orders
 402  5FEE 3A 87 C0                             ld      a,(UBnKAccel)
 403  5FF1 A7                                   and     a
 404  5FF2 CC 6C 60                             call    z, AdjustSpeed
 405  5FF5 C9                                   ret
 406  5FF6              ;..................................................................................................................................
 407  5FF6 3A 82 C0     AdjustPitch:            ld      a,(UBnKDotProductRoofSign)  ; if its negative then its over 90 degrees
 408  5FF9 67                                   ld      h,a                         ; .
 409  5FFA A7                                   and     a                           ; .
 410  5FFB CA 28 60                             jp      z,.Over90Degrees            ; .
 411  5FFE 3A 81 C0     .Under90Degrees:        ld      a,(UBnKDotProductRoof+1)    ; get High byte of dot product
 412  6001                                      JumpIfAGTENusng   35, .pitchZero    ; within 13 degees don't steer as proximity blast will do
 412  6001 FE 23       >                        cp     35
 412  6003 D2 0E 60    >                        jp		nc,.pitchZero
 413  6006                                      JumpIfAGTENusng   22, .pitchBySmall
 413  6006 FE 16       >                        cp     22
 413  6008 D2 1F 60    >                        jp		nc,.pitchBySmall
 414  600B C3 16 60                             jp      .pitchNormal
 415  600E              .pitchZero:             ZeroA
 415  600E AF          >                        xor a
 416  600F 32 89 C0                             ld      (UBnKPitchCounter),a
 417  6012 CD D1 66                             call    ClearStatusPitch
 418  6015 C9                                   ret
 419  6016 3E 02        .pitchNormal:           ld      a,2
 420  6018                                      ;ZeroA
 421  6018 32 89 C0                             ld      (UBnKPitchCounter),a     ; max climb (we will randomly choose +/- later but need to consider stick bit 8)
 422  601B CD 95 66                             call    SetStatusPitchPlus
 423  601E C9                                   ret
 424  601F 3E 01        .pitchBySmall:          ld      a,1
 425  6021                                      ;ZeroA
 426  6021 32 89 C0                             ld      (UBnKPitchCounter),a     ; max climb (we will randomly choose +/- later but need to consider stick bit 8)
 427  6024 CD 95 66                             call    SetStatusPitchPlus
 428  6027 C9                                   ret
 429  6028 3E 05        .Over90Degrees:         ld      a,5
 430  602A                                      ;ZeroA
 431  602A 32 89 C0                             ld      (UBnKPitchCounter),a     ; max climb (we will randomly choose +/- later but need to consider stick bit 8)
 432  602D CD 95 66                             call    SetStatusPitchPlus
 433  6030 C9                                   ret
 434  6031              ;..................................................................................................................................
 435  6031 3A 7F C0     AdjustRoll:             ld      a,(UBnKDotProductNoseSign)  ; if its negative then its over 90 degrees
 436  6034 67                                   ld      h,a                         ; .
 437  6035 A7                                   and     a                           ; .
 438  6036 CA 63 60                             jp      z,.Over90Degrees            ; .
 439  6039 3A 7E C0     .Under90Degrees:        ld      a,(UBnKDotProductNose+1)    ; get High byte of dot product
 440  603C                                      JumpIfAGTENusng   30, .rollZero    ; within 13 degees don't steer as proximity blast will do
 440  603C FE 1E       >                        cp     30
 440  603E D2 49 60    >                        jp		nc,.rollZero
 441  6041                                      JumpIfAGTENusng   22, .rollBySmall
 441  6041 FE 16       >                        cp     22
 441  6043 D2 5A 60    >                        jp		nc,.rollBySmall
 442  6046 C3 51 60                             jp      .rollNormal
 443  6049              .rollZero:              ZeroA
 443  6049 AF          >                        xor a
 444  604A 32 88 C0                             ld      (UBnKRollCounter),a
 445  604D CD CB 66                             call    ClearStatusRoll
 446  6050 C9                                   ret
 447  6051 3E 02        .rollNormal:            ld      a,2
 448  6053                                      ;ZeroA
 449  6053 32 88 C0                             ld      (UBnKRollCounter),a     ; max climb (we will randomly choose +/- later but need to consider stick bit 8)
 450  6056 CD 89 66                             call    SetStatusRollPlus
 451  6059 C9                                   ret
 452  605A 3E 01        .rollBySmall:           ld      a,1
 453  605C                                      ;ZeroA
 454  605C 32 88 C0                             ld      (UBnKRollCounter),a     ; max climb (we will randomly choose +/- later but need to consider stick bit 8)
 455  605F CD 89 66                             call    SetStatusRollPlus
 456  6062 C9                                   ret
 457  6063 3E 05        .Over90Degrees:         ld      a,5
 458  6065                                      ;ZeroA
 459  6065 32 88 C0                             ld      (UBnKRollCounter),a     ; max climb (we will randomly choose +/- later but need to consider stick bit 8)
 460  6068 CD 89 66                             call    SetStatusRollPlus
 461  606B C9                                   ret
 462  606C              ;..................................................................................................................................
 463  606C 3A 7F C0     AdjustSpeed:            ld      a,(UBnKDotProductNoseSign)          ; if negative facing away so slow
 464  606F A7                                   and     a
 465  6070 20 1D                                jr      nz,.SlowDown
 466  6072 3A 7E C0                             ld      a,(UBnKDotProductNose+1)
 467  6075                                      JumpIfAGTENusng   30, .Accelerate           ; close enough to accellerate
 467  6075 FE 1E       >                        cp     30
 467  6077 D2 82 60    >                        jp		nc,.Accelerate
 468  607A                                      JumpIfALTNusng  22,.SmallSlow               ; if nose < 22  (over 50 degrees ) then small slow down
 468  607A FE 16       >                        cp      22
 468  607C DA A1 60    >                        jp		c, .SmallSlow
 469  607F C3 AE 60                             jp      .NoSpeedChange                      ; between 22 and 30 coast
 470  6082              .Accelerate
 470  6082 3E 03                    ld      a,3                                 ; else on target so power on
 471  6084                                      ZeroA
 471  6084 AF          >                        xor a
 472  6085 32 87 C0                             ld      (UBnKAccel),a                       ;  accelleration = 3
 473  6088 CD 83 66                             call    SetStatusFast
 474  608B CD BF 66                             call    ClearStatusSlow
 475  608E C9                                   ret
 476  608F              .SlowDown:              JumpIfALTNusng 18, .SmallSlow              ; if its < 18 then its within 120 degrees so small slow
 476  608F FE 12       >                        cp      18
 476  6091 DA A1 60    >                        jp		c, .SmallSlow
 477  6094 3E FB        .Deccelerate:           ld      a,-5                               ; else faster Slow
 478  6096                                      ZeroA
 478  6096 AF          >                        xor a
 479  6097 32 87 C0                             ld      (UBnKAccel),a
 480  609A CD C5 66                             call    ClearStatusFast
 481  609D CD 7D 66                             call    SetStatusSlow
 482  60A0 C9                                   ret
 483  60A1 3E FE        .SmallSlow:             ld      a,-2
 484  60A3                                      ZeroA
 484  60A3 AF          >                        xor a
 485  60A4 32 87 C0                             ld      (UBnKAccel),a
 486  60A7 CD C5 66                             call    ClearStatusFast
 487  60AA CD 7D 66                             call    SetStatusSlow
 488  60AD C9                                   ret
 489  60AE              .NoSpeedChange:         ZeroA                                       ; else no change
 489  60AE AF          >                        xor a
 490  60AF 32 87 C0                             ld      (UBnKAccel),a
 491  60B2 CD C5 66                             call    ClearStatusFast
 492  60B5 CD BF 66                             call    ClearStatusSlow
 493  60B8 C9                                   ret
 494  60B9
 495  60B9              ;..................................................................................................................................
 496  60B9 3A 78 C0     FlipDirectionSigns:     ld      a,(UBnKDirNormXSign)
 497  60BC EE 80                                xor     $80
 498  60BE 32 78 C0                             ld      (UBnKDirNormXSign),a
 499  60C1 3A 7A C0                             ld      a,(UBnKDirNormYSign)
 500  60C4 EE 80                                xor     $80
 501  60C6 32 7A C0                             ld      (UBnKDirNormYSign),a
 502  60C9 3A 7C C0                             ld      a,(UBnKDirNormZSign)
 503  60CC EE 80                                xor     $80
 504  60CE 32 7C C0                             ld      (UBnKDirNormZSign),a
 505  60D1 C9                                   ret
 506  60D2 3A 7F C0                             ld      a,(UBnKDotProductNoseSign)
 507  60D5 EE 80                                xor     $80
 508  60D7 32 7F C0                             ld      (UBnKDotProductNoseSign),a
 509  60DA 3A 82 C0                             ld      a,(UBnKDotProductRoofSign)
 510  60DD EE 80                                xor     $80
 511  60DF 32 82 C0                             ld      (UBnKDotProductRoofSign),a
 512  60E2 3A 85 C0                             ld      a,(UBnKDotProductSideSign)
 513  60E5 EE 80                                xor     $80
 514  60E7 32 85 C0                             ld      (UBnKDotProductSideSign),a
 515  60EA C9                                   ret
 516  60EB              ;..................................................................................................................................
 517  60EB              CopyOffsetToDirection:  MMUSelectUniverseN 1
 517  60EB ED 91 56 47 >                     nextreg UniverseMMU,       BankUNIVDATA0+1
 518  60EF 21 65 C0                             ld      hl,UBnKOffset
 519  60F2 11 6E C0                             ld      de,UBnKDirection
 520  60F5 01 09 00                             ld      bc,9
 521  60F8 ED B0                                ldir
 522  60FA C9                                   ret
 523  60FB              ;..................................................................................................................................
 524  60FB              ; Normalises UBnKDirection into UBnKDirNorm with Sign byte and 7 bit normal
 525  60FB              ; result of 36 means they are directly in align + at - away
 526  60FB              NormaliseDirection:     MMUSelectUniverseN 1
 526  60FB ED 91 56 47 >                     nextreg UniverseMMU,       BankUNIVDATA0+1
 527  60FF 3A 70 C0                             ld      a,(UBnKDirectionXSign)      ; Direction x = abs Direction X , b bit 7 = sign of X
 528  6102 4F                                   ld      c,a                         ; .
 529  6103 E6 80                                and     $80                         ; .
 530  6105 32 78 C0                             ld      (UBnKDirNormXSign),a        ; Save sign into NormSign
 531  6108 79                                   ld      a,c                         ; .
 532  6109 E6 7F                                and     $7F                         ; .
 533  610B 32 70 C0                             ld      (UBnKDirectionXSign),a      ; .
 534  610E 3A 73 C0     .ABSYComponenet:        ld      a,(UBnKDirectionYSign)      ; Direction y = abs Direction y , b bit 6 = sign of y
 535  6111 4F                                   ld      c,a                         ; .
 536  6112 E6 80                                and     $80                         ;  get sign bit from a
 537  6114 32 7A C0                             ld      (UBnKDirNormYSign),a        ; Save sign into NormSign
 538  6117 79                                   ld      a,c
 539  6118 E6 7F                                and     $7F                         ; .
 540  611A 32 73 C0                             ld      (UBnKDirectionYSign),a      ; .
 541  611D 3A 76 C0     .ABSXZomponenet:        ld      a,(UBnKDirectionZSign)      ; Direction y = abs Direction y , b bit 6 = sign of y
 542  6120 4F                                   ld      c,a                         ; .
 543  6121 E6 80                                and     $80                         ;  get sign bit from a
 544  6123 32 7C C0                             ld      (UBnKDirNormZSign),a        ; Save sign into NormSign
 545  6126 79                                   ld      a,c
 546  6127 E6 7F                                and     $7F                         ; .
 547  6129 32 76 C0                             ld      (UBnKDirectionZSign),a      ; .
 548  612C              ;.. When we hit here the UBnKTargetX,Y and Z are 24 bit abs values to simplify scaling
 549  612C 2A 6E C0     .Scale:                 ld      hl, (UBnKDirectionX)        ; [ixh h l]  = X
 550  612F 3A 70 C0                             ld      a,(UBnKDirectionXSign)      ; .
 551  6132 DD 67                                ld      ixh,a                       ; .
 552  6134 ED 5B 71 C0                          ld      de, (UBnKDirectionY)        ; [iyh d e ] = Y
 553  6138 3A 73 C0                             ld      a,(UBnKDirectionYSign)      ; .
 554  613B FD 67                                ld      iyh,a                       ; .
 555  613D ED 4B 74 C0                          ld      bc, (UBnKDirectionZ)        ; [iyl b c ] = Z
 556  6141 3A 76 C0                             ld      a,(UBnKDirectionZSign)      ; .
 557  6144 FD 6F                                ld      iyl,a                       ; .
 558  6146 DD 7C        .ScaleLoop1:            ld      a,ixh                       ; first pass get to 16 bit leaving hl = X de = Y bc = Z
 559  6148 FD B4                                or      iyh                         ;
 560  614A FD B5                                or      iyl                         ;
 561  614C CA 70 61                             jp      z,.DoneScaling1             ; .
 562  614F                                      ShiftIXhHLRight1                    ; .
 562  614F DD 7C       >               ld  a,ixh
 562  6151 CB 3F       >               srl a
 562  6153 DD 67       >               ld  ixh,a
 562  6155 CB 1C       >			   rr  h
 562  6157 CB 1D       >			   rr  l
 563  6159                                      ShiftIYhDERight1                    ; .
 563  6159 FD 7C       >               ld  a,iyh
 563  615B CB 3F       >               srl a
 563  615D FD 67       >               ld  iyh,a
 563  615F CB 1A       >               rr  d
 563  6161 CB 1B       >			   rr  e
 564  6163                                      ShiftIYlBCRight1                    ; .
 564  6163 FD 7D       >               ld  a,iyl
 564  6165 CB 3F       >               srl a
 564  6167 FD 6F       >               ld  iyl,a
 564  6169 CB 18       >			   rr  b
 564  616B CB 19       >               rr  c
 565  616D C3 46 61                             jp      .ScaleLoop1
 566  6170              .DoneScaling1:          ;-- Now we have got here hl = X, de = Y, bc = Z
 567  6170                                      ;-- we cal just jump into the Normalize Tactics code
 568  6170 7C           .ScaleLoop2:            ld      a,h                         ; Now scale down to 8 bit
 569  6171 B2                                   or      d                           ; so l = X e = Y c = Z
 570  6172 B0                                   or      b                           ; .
 571  6173 28 0F                                jr      z,.DoneScaling2             ; .
 572  6175                                      ShiftHLRight1                       ; .
 572  6175 CB 3C       >			   srl h
 572  6177 CB 1D       >			   rr  l
 573  6179                                      ShiftDERight1                       ; .
 573  6179 CB 3A       >			   srl d
 573  617B CB 1B       >			   rr  e
 574  617D                                      ShiftBCRight1                       ; .
 574  617D CB 38       >			   srl b
 574  617F CB 19       >			   rr  c
 575  6181 C3 70 61                             jp      .ScaleLoop2                 ; .
 576  6184              ;-- Now we are down to 8 bit values, so we need to scale again to get S7
 577  6184              .DoneScaling2:          ShiftHLRight1                       ; Scale once again to 7 bit with no sign
 577  6184 CB 3C       >			   srl h
 577  6186 CB 1D       >			   rr  l
 578  6188                                      ShiftDERight1                       ; l = X e = Y c = Z
 578  6188 CB 3A       >			   srl d
 578  618A CB 1B       >			   rr  e
 579  618C                                      ShiftBCRight1                       ; .
 579  618C CB 38       >			   srl b
 579  618E CB 19       >			   rr  c
 580  6190 E5 D5 C5     .CalculateLength:       push    hl,,de,,bc                  ; save vector x y and z nwo they are scaled to 1 byte
 581  6193 53                                   ld      d,e                         ; hl = y ^ 2
 582  6194 ED 30                                mul     de                          ; .
 583  6196 EB                                   ex      de,hl                       ; .
 584  6197 53                                   ld      d,e                         ; de = x ^ 2
 585  6198 ED 30                                mul     de                          ; .
 586  619A 19                                   add     hl,de                       ; hl = y^ 2 + x ^ 2
 587  619B 51                                   ld      d,c                         ; de = z * 2
 588  619C 59                                   ld      e,c                         ; .
 589  619D ED 30                                mul     de                          ; .
 590  619F 19                                   add     hl,de                       ; hl =  y^ 2 + x ^ 2 + z ^ 2
 591  61A0 EB                                   ex      de,hl                       ; fix as hl was holding square
 592  61A1 CD A7 72                             call    asm_sqrt                    ; hl = sqrt (de) = sqrt (x ^ 2 + y ^ 2 + z ^ 2)
 593  61A4                                      ; add in logic if h is low then use lower bytes for all
 594  61A4              ;.RetrieveSignBits:      ld      a,(UBnKDirectionSignPacked) ; load sign bits to iyl
 595  61A4              ;                        ld      iyl,a                       ;
 596  61A4 7D           .NormaliseZ:            ld      a,l                         ; save length into iyh
 597  61A5 FD 67                                ld      iyh,a                       ; .
 598  61A7 57                                   ld      d,a                         ; and also into d
 599  61A8 C1                                   pop     bc                          ; retrive z scaled
 600  61A9 79                                   ld      a,c                         ; a = scaled byte
 601  61AA CD 65 7C                             call    AequAdivDmul967Bit          ; a = z*96/Length
 602  61AD 32 7B C0                             ld      (UBnKDirNormZ),a            ; now Tactics Vector Z byte 1 is value
 603  61B0 D1           .NormaliseY:            pop     de                          ; retrive y scaled
 604  61B1 7B                                   ld      a,e                         ; a = scaled byte
 605  61B2 FD 54                                ld      d,iyh                       ; d = length
 606  61B4 CD 65 7C                             call    AequAdivDmul967Bit          ; a = z*96/Length
 607  61B7 32 79 C0                             ld      (UBnKDirNormY),a            ; now Tactics Vector Y byte 1 is value
 608  61BA E1           .NormaliseX:            pop     hl                          ; retrive x scaled
 609  61BB 7D                                   ld      a,l                         ; a = scaled byte
 610  61BC FD 54                                ld      d,iyh                       ; d = length
 611  61BE CD 65 7C                             call    AequAdivDmul967Bit          ; a = z*96/Length
 612  61C1 32 77 C0                             ld      (UBnKDirNormX),a            ; now Tactics Vector X byte 1 is value
 613  61C4 C9                                   ret
 614  61C5              ;..................................................................................................................................
 615  61C5              ; copy nose and side rotation matricies
 616  61C5 23           CopyRotmatToTactics:    inc     hl                                  ; optimise later by starting at x hi
 617  61C6 7E                                   ld      a,(hl)
 618  61C7 47                                   ld      b,a
 619  61C8 E6 80                                and     $80
 620  61CA 32 60 C0                             ld      (UBnKTacticsRotMatXSign),a
 621  61CD 78                                   ld      a,b
 622  61CE E6 7F                                and     $7F
 623  61D0 32 5F C0                             ld      (UBnKTacticsRotMatX),a
 624  61D3 23                                   inc     hl
 625  61D4 23                                   inc     hl
 626  61D5 7E                                   ld      a,(hl)
 627  61D6 47                                   ld      b,a
 628  61D7 E6 80                                and     $80
 629  61D9 32 62 C0                             ld      (UBnKTacticsRotMatYSign),a
 630  61DC 78                                   ld      a,b
 631  61DD E6 7F                                and     $7F
 632  61DF 32 61 C0                             ld      (UBnKTacticsRotMatY),a
 633  61E2 23                                   inc     hl
 634  61E3 23                                   inc     hl
 635  61E4 7E                                   ld      a,(hl)
 636  61E5 47                                   ld      b,a
 637  61E6 E6 80                                and     $80
 638  61E8 32 64 C0                             ld      (UBnKTacticsRotMatZSign),a
 639  61EB 78                                   ld      a,b
 640  61EC E6 7F                                and     $7F
 641  61EE 32 63 C0                             ld      (UBnKTacticsRotMatZ),a
 642  61F1 C9                                   ret
 643  61F2
 644  61F2              ;..................................................................................................................................
 645  61F2              ; Calculate dot products of roof and side against UBnKDirNorm
 646  61F2              ; UBnKDotProductNose = nose . direction = nose.x * dir x + nose.y * diry + nose.z * dirz
 647  61F2              ; UBnKDotProductSide = side . direction = side.x * dir x + side.y * diry + side.z * dirz
 648  61F2 CD C5 61     CalculateDotProducts:   call    CopyRotmatToTactics                 ; get matrix to work area
 649  61F5 3A 5F C0     .CalcXValue:            ld      a,(UBnKTacticsRotMatX)              ; stack value of rotmatx & dir x
 650  61F8 57                                   ld      d,a                                 ; .
 651  61F9 3A 77 C0                             ld      a,(UBnKDirNormX)                    ; .
 652  61FC 5F                                   ld      e,a                                 ; .
 653  61FD ED 30                                mul     de                                  ; .
 654  61FF D5                                   push    de                                  ; save to stack for pulling into hl
 655  6200 3A 61 C0     .CalcYValue:            ld      a,(UBnKTacticsRotMatY)              ; de = rotmaty & dir y
 656  6203 57                                   ld      d,a                                 ; .
 657  6204 3A 79 C0                             ld      a,(UBnKDirNormY)                    ; .
 658  6207 5F                                   ld      e,a                                 ; .
 659  6208 ED 30                                mul     de                                  ; .
 660  620A 3A 78 C0     .CalcXSign:             ld      a,(UBnKDirNormXSign)                ; B  = A = Sign VecX xor sign RotMatX
 661  620D 21 60 C0                             ld      hl,UBnKTacticsRotMatXSign           ; .
 662  6210 AE                                   xor     (hl)                                ; .
 663  6211 47                                   ld      b,a                                 ; .
 664  6212 3A 7A C0     .CalcYSign:             ld      a,(UBnKDirNormYSign)                ; B  = C = Sign VecY xor sign RotMatY
 665  6215 21 62 C0                             ld      hl,UBnKTacticsRotMatYSign           ; .
 666  6218 AE                                   xor     (hl)                                ; .
 667  6219 4F                                   ld      c,a                                 ; .
 668  621A E1           .SumSoFar:              pop     hl                                  ; hl = vecx * dirx
 669  621B CD 33 00                             call    ADDHLDESignBC                       ; AHL = vecx*dirx + vecy*diry
 670  621E 47                                   ld      b,a                                 ; BHL = AHL
 671  621F 3A 63 C0     .CalcZValue:            ld      a,(UBnKTacticsRotMatZ)              ; de = rotmatz & dir z
 672  6222 57                                   ld      d,a                                 ; .
 673  6223 3A 7B C0                             ld      a,(UBnKDirNormZ)                    ; .
 674  6226 5F                                   ld      e,a                                 ; .
 675  6227 ED 30                                mul     de
 676  6229 E5           .CalcZSign:             push    hl
 677  622A 3A 7C C0                             ld      a,(UBnKDirNormZSign)                ; B  = C = Sign VecY xor sign RotMatY
 678  622D 21 64 C0                             ld      hl,UBnKTacticsRotMatZSign           ; .
 679  6230 AE                                   xor     (hl)                                ; .
 680  6231 4F                                   ld      c,a                                 ; so now CDE = z
 681  6232 E1                                   pop     hl
 682  6233 CD 33 00     .SumUp:                 call    ADDHLDESignBC                       ; AHL = vecx*dirx + vecy*diry + vecz*dirz
 683  6236 C9                                   ret
 684  6237              ;..................................................................................................................................
 685  6237 2A 66 C0     CheckDistance:          ld      hl,(UBnKOffsetXHi)                 ; test if high bytes are set (value is assumed to be 24 bit, though calcs are only 16 so this is uneeded)
 686  623A ED 5B 69 C0                          ld      de,(UBnKOffsetYHi)                 ; .
 687  623E ED 4B 6C C0                          ld      bc,(UBnKOffsetZHi)                 ; .
 688  6242              ; If the sign and high of X Y and Z are all zero then hit else still travelling
 689  6242 7C                                   ld      a,h                                ; sign bytes only ignoring sign bit
 690  6243 B2                                   or      d                                  ; .
 691  6244 B0                                   or      b                                  ; .
 692  6245                                      ClearSignBitA                              ; .
 692  6245 E6 7F       >                        and     SignMask8Bit
 693  6247                                      JumpIfNotZero       .FarAway               ; if upper byte is non zero then very far away
 693  6247 C2 64 62    >                        jp	nz,.FarAway
 694  624A B5                                   or      l                                  ; test for low byte bit 7, i.e high of 16 bit values
 695  624B B3                                   or      e                                  ; .
 696  624C B1                                   or      c                                  ; .
 697  624D                                      JumpIfNotZero       .Near                  ; if mid byte is non zero then in near distance
 697  624D C2 5A 62    >                        jp	nz,.Near
 698  6250 CD AD 66     .Hit                    call    SetStatusHit                       ; which means if all mid bytes are zero then hit
 699  6253 CD E9 66                             call    ClearStatusNear
 700  6256 CD EF 66                             call    ClearStatusFar
 701  6259 C9                                   ret
 702  625A CD B3 66     .Near:                  call    SetStatusNear
 703  625D CD EF 66                             call    ClearStatusFar
 704  6260 CD E3 66                             call    ClearStatusHit
 705  6263 C9                                   ret
 706  6264 CD B9 66     .FarAway:               call    SetStatusFar
 707  6267 CD E9 66                             call    ClearStatusNear
 708  626A CD E3 66                             call    ClearStatusHit
 709  626D C9                                   ret
 710  626E              ;..................................................................................................................................
 711  626E              LoadTargetData:         MMUSelectUniverseN 2                        ;
 711  626E ED 91 56 48 >                     nextreg UniverseMMU,       BankUNIVDATA0+2
 712  6272 21 20 C0                             ld      hl,UBnKxlo
 713  6275 11 15 6D                             ld      de,CurrentTargetXpos
 714  6278 01 09 00                             ld      bc,9
 715  627B ED B0                                ldir
 716  627D                                      MMUSelectUniverseN 1
 716  627D ED 91 56 47 >                     nextreg UniverseMMU,       BankUNIVDATA0+1
 717  6281 21 15 6D                             ld      hl,CurrentTargetXpos
 718  6284 11 47 C0                             ld      de,UBnKTargetXPos
 719  6287 01 09 00                             ld      bc,9
 720  628A ED B0                                ldir
 721  628C C9                                   ret
 722  628D              ;..................................................................................................................................
 723  628D FD 21 20 C0  CalculateRelativePos:   ld      iy,UBnKxlo
 724  6291 DD 21 47 C0                          ld      ix,UBnKTargetXPos
 725  6295 CD F3 00                             call    SubDELequAtIXMinusAtIY24Signed
 726  6298 7D                                   ld      a,l
 727  6299 32 65 C0                             ld      (UBnKOffset),a
 728  629C ED 53 66 C0                          ld      (UBnKOffset+1),de
 729  62A0 FD 21 23 C0  .RelativeY:             ld      iy,UBnKylo
 730  62A4 DD 21 4A C0                          ld      ix,UBnKTargetYPos
 731  62A8 CD F3 00                             call    SubDELequAtIXMinusAtIY24Signed
 732  62AB 7D                                   ld      a,l
 733  62AC 32 68 C0                             ld      (UBnKOffset+3),a
 734  62AF ED 53 69 C0                          ld      (UBnKOffset+4),de
 735  62B3 FD 21 26 C0  .RelativeZ:             ld      iy,UBnKzlo
 736  62B7 DD 21 4D C0                          ld      ix,UBnKTargetZPos
 737  62BB CD F3 00                             call    SubDELequAtIXMinusAtIY24Signed
 738  62BE 7D                                   ld      a,l
 739  62BF 32 6B C0                             ld      (UBnKOffset+6),a
 740  62C2 ED 53 6C C0                          ld      (UBnKOffset+7),de
 741  62C6 C9                                   ret
 742  62C7              ;..................................................................................................................................
 743  62C7              CreateMissile:          MMUSelectUniverseN  1
 743  62C7 ED 91 56 47 >                     nextreg UniverseMMU,       BankUNIVDATA0+1
 744  62CB 3E 02                                ld      a,2
 745  62CD 32 46 C0                             ld      (UBnKMissileTarget),a               ; load target Data
 746  62D0 CD D3 C6                             call    UnivSetPlayerMissile                ; .
 747  62D3 3E 1F                                ld          a,$1F
 748  62D5 32 47 C4                             ld          (SpeedAddr),a
 749  62D8 C9                                   ret
 750  62D9
 751  62D9              CreateTarget:           MMUSelectUniverseN  2
 751  62D9 ED 91 56 48 >                     nextreg UniverseMMU,       BankUNIVDATA0+2
 752  62DD CD BF C7                             call    UnivInitRuntime
 753  62E0 CD 6B C7                             call    UnivSetSpawnPosition
 754  62E3 C9                                   ret
 755  62E4
 756  62E4              ;----------------------------------------------------------------------------------------------------------------------------------
 757  62E4              ; Display Stats - go for 320 mode to test code
 758  62E4              ; Left side                         Right Side
 759  62E4              ;0123456789012345678901234567890123456789
 760  62E4              ;1Missile
 761  62E4              ;2     X        Y       Z
 762  62E4              ;3+FFFF.FF +FFFF.FF +FFFF.FF
 763  62E4              ;4Matrix    X        Y        Z
 764  62E4              ;5Side +FFFF.FF +FFFF.FF +FFFF.FF
 765  62E4              ;6Roof +FFFF.FF +FFFF.FF +FFFF.FF
 766  62E4              ;7Nose +FFFF.FF +FFFF.FF +FFFF.FF
 767  62E4              ;8
 768  62E4              ;9Speed Roll Pitch
 769  62E4              ;0+FF   +FF  +FF
 770  62E4              ;1Target
 771  62E4              ;2     X        Y       Z
 772  62E4              ;3+FFFF.FF +FFFF.FF +FFFF.FF
 773  62E4              ;4Dot Product
 774  62E4              ;5+FFFF
 775  62E4              ;6Actions
 776  62E4              ;7
 777  62E4              ;8
 778  62E4              ;9
 779  62E4 00 01 4D 69  BoilerPlate1:           DB      00 ,01,  "Missile   X        Y        Z",0
 779  62E8 73 73 69 6C
 779  62EC 65 20 20 20
 779  62F0 58 20 20 20
 779  62F4 20 20 20 20
 779  62F8 20 59 20 20
 779  62FC 20 20 20 20
 779  6300 20 20 5A 00
 780  6304 00 03 4D 61  BoilerPlate2:           DB      00 ,03,  "Matrix    X        Y        Z",0
 780  6308 74 72 69 78
 780  630C 20 20 20 20
 780  6310 58 20 20 20
 780  6314 20 20 20 20
 780  6318 20 59 20 20
 780  631C 20 20 20 20
 780  6320 20 20 5A 00
 781  6324 00 04 53 69  BoilerPlate3:           DB      00 ,04,  "Side",0
 781  6328 64 65 00
 782  632B 00 05 52 6F  BoilerPlate4:           DB      00 ,05,  "Roof",0
 782  632F 6F 66 00
 783  6332 00 06 4E 6F  BoilerPlate5:           DB      00 ,06,  "Nose",0
 783  6336 73 65 00
 784  6339 00 07 41 63  BoilerPlate6:           DB      00 ,07,  "Accell             Speed",0
 784  633D 63 65 6C 6C
 784  6341 20 20 20 20
 784  6345 20 20 20 20
 784  6349 20 20 20 20
 784  634D 20 53 70 65
 784  6351 65 64 00
 785  6354 00 08 52 6F  BoilerPlate7:           DB      00 ,08,  "Roll               Pitch",0
 785  6358 6C 6C 20 20
 785  635C 20 20 20 20
 785  6360 20 20 20 20
 785  6364 20 20 20 20
 785  6368 20 50 69 74
 785  636C 63 68 00
 786  636F 00 09 54 61  BoilerPlate8:           DB      00 ,09,  "Target    X        Y        Z",0
 786  6373 72 67 65 74
 786  6377 20 20 20 20
 786  637B 58 20 20 20
 786  637F 20 20 20 20
 786  6383 20 59 20 20
 786  6387 20 20 20 20
 786  638B 20 20 5A 00
 787  638F 00 0B 54 61  BoilerPlate9:           DB      00 ,11,  "Tactics",0
 787  6393 63 74 69 63
 787  6397 73 00
 788  6399 00 0C 52 65  BoilerPlate10:          DB      00, 12,  "Relative  X        Y        Z",0
 788  639D 6C 61 74 69
 788  63A1 76 65 20 20
 788  63A5 58 20 20 20
 788  63A9 20 20 20 20
 788  63AD 20 59 20 20
 788  63B1 20 20 20 20
 788  63B5 20 20 5A 00
 789  63B9 00 0E 44 69  BoilerPlate11           DB      00 ,14,  "Direction X        Y        Z",0
 789  63BD 72 65 63 74
 789  63C1 69 6F 6E 20
 789  63C5 58 20 20 20
 789  63C9 20 20 20 20
 789  63CD 20 59 20 20
 789  63D1 20 20 20 20
 789  63D5 20 20 5A 00
 790  63D9 00 10 44 6F  BoilerPlate12:          DB      00 ,16,  "Dot Nose XXX Roof XXX Side XXX",0
 790  63DD 74 20 4E 6F
 790  63E1 73 65 20 58
 790  63E5 58 58 20 52
 790  63E9 6F 6F 66 20
 790  63ED 58 58 58 20
 790  63F1 53 69 64 65
 790  63F5 20 58 58 58
 790  63F9 00
 791  63FA 00 11 20 20  BoilerPlate13:          DB      00 ,17,  "    Nose XX  Roof XX  Side XX ",0
 791  63FE 20 20 4E 6F
 791  6402 73 65 20 58
 791  6406 58 20 20 52
 791  640A 6F 6F 66 20
 791  640E 58 58 20 20
 791  6412 53 69 64 65
 791  6416 20 58 58 20
 791  641A 00
 792  641B 00 12 41 63  BoilerPlate14:          DB      00 ,18,  "Actions",0
 792  641F 74 69 6F 6E
 792  6423 73 00
 793  6425 00 13 20 20  BoilerPlate15:          DB      00 ,19,  "   Speed:   Pitch:    Roll:",0
 793  6429 20 53 70 65
 793  642D 65 64 3A 20
 793  6431 20 20 50 69
 793  6435 74 63 68 3A
 793  6439 20 20 20 20
 793  643D 52 6F 6C 6C
 793  6441 3A 00
 794  6443 00 14 42 65  ActionTextBehind:       DB      00 ,20,  "Behind",0
 794  6447 68 69 6E 64
 794  644B 00
 795  644C 0A 14 46 6F  ActionTextForward:      DB      10 ,20,  "Forward",0
 795  6450 72 77 61 72
 795  6454 64 00
 796  6456 00 15 4E 65  ActionTextNear          DB      00 ,21,  "Near",0
 796  645A 61 72 00
 797  645D 0A 15 46 61  ActionTextFar           DB      10 ,21,  "Far",0
 797  6461 72 00
 798  6463 14 15 48 69  ActionTextHit:          DB      20 ,21,  "Hit",0
 798  6467 74 00
 799  6469 00 14 20 20  ClearTextBehind:        DB      00 ,20,  "      ",0
 799  646D 20 20 20 20
 799  6471 00
 800  6472 0A 14 20 20  ClearTextForward:       DB      10 ,20,  "       ",0
 800  6476 20 20 20 20
 800  647A 20 00
 801  647C 14 15 20 20  ClearTextHit:           DB      20 ,21,  "   ",0
 801  6480 20 00
 802  6482 00 15 20 20  ClearTextNear           DB      00 ,21,  "    ",0
 802  6486 20 20 00
 803  6489 0A 15 20 20  ClearTextFar            DB      10 ,21,  "   ",0
 803  648D 20 00
 804  648F
 805  648F 00           StatusSlow              DB      0
 806  6490 00           StatusFast              DB      0
 807  6491 00           StatusRoll              DB      0
 808  6492 00           StatusPitch             DB      0
 809  6493 00           StatusBehind            DB      0
 810  6494 00           StatusForward           DB      0
 811  6495 00           StatusNear              DB      0
 812  6496 00           StatusFar               DB      0
 813  6497 00           StatusHit               DB      0
 814  6498              ;                                         0123456789ABCDEF0123456789AB
 815  6498              XPosX                   equ     $06
 816  6498              XPosY                   equ     $0F
 817  6498              XPosZ                   equ     $18
 818  6498              XNoseDP                 equ     9
 819  6498              XRoofDP                 equ     18
 820  6498              XSideDP                 equ     27
 821  6498              XSpeed                  equ     9
 822  6498              XPitch                  equ     19
 823  6498              XRoll                   equ     28
 824  6498              RowMissle               equ     02
 825  6498              RowMatrix1              equ     04
 826  6498              RowMatrix2              equ     05
 827  6498              RowMatrix3              equ     06
 828  6498              RowAccellSpeed          equ     07
 829  6498              RowPitchRoll            equ     08
 830  6498              RowTarget               equ     10
 831  6498              RowRelative             equ     13
 832  6498              RowDirection            equ     15
 833  6498              RowDotProduct           equ     16
 834  6498              RowDotDegrees           equ     17
 835  6498
 836  6498 CD F5 66     DisplayActionStatus:    call    UpdateStatusSlow
 837  649B CD FF 66                             call    UpdateStatusFast
 838  649E CD 09 67                             call    UpdateStatusRoll
 839  64A1 CD 18 67                             call    UpdateStatusPitch
 840  64A4 CD 27 67                             call    UpdateStatusBehind
 841  64A7 CD 31 67                             call    UpdateStatusForward
 842  64AA CD 3B 67                             call    UpdateStatusHit
 843  64AD CD 45 67                             call    UpdateStatusNear
 844  64B0 CD 4F 67                             call    UpdateStatusFar
 845  64B3 C9                                   ret
 846  64B4
 847  64B4 D5           DisplayPosition:        push    de
 848  64B5 1E 06                                ld      e,XPosX
 849  64B7 DD 21 20 C0                          ld      ix,UBnKxlo
 850  64BB CD 29 66                             call    DisplayS24
 851  64BE D1                                   pop     de
 852  64BF D5                                   push    de
 853  64C0 1E 0F                                ld      e,XPosY
 854  64C2 DD 21 23 C0                          ld      ix,UBnKylo
 855  64C6 CD 29 66                             call    DisplayS24
 856  64C9 D1                                   pop     de
 857  64CA 1E 18                                ld      e,XPosZ
 858  64CC DD 21 26 C0                          ld      ix,UBnKzlo
 859  64D0 CD 29 66                             call    DisplayS24
 860  64D3 C9                                   ret
 861  64D4
 862  64D4 D5           DisplayMatrixRow:       push    de
 863  64D5 1E 06                                ld      e,XPosX
 864  64D7 DD E5                                push    ix
 865  64D9 CD 3C 66                             call    DisplayS16
 866  64DC DD E1                                pop     ix
 867  64DE D1                                   pop     de
 868  64DF D5                                   push    de
 869  64E0 1E 0F                                ld      e,XPosY
 870  64E2 DD 23                                inc     ix
 871  64E4 DD 23                                inc     ix
 872  64E6 DD E5                                push    ix
 873  64E8 CD 3C 66                             call    DisplayS16
 874  64EB DD E1                                pop     ix
 875  64ED D1                                   pop     de
 876  64EE 1E 18                                ld      e,XPosZ
 877  64F0 DD 23                                inc     ix
 878  64F2 DD 23                                inc     ix
 879  64F4 CD 3C 66                             call    DisplayS16
 880  64F7 C9                                   ret
 881  64F8
 882  64F8 16 0D        DisplayRelative:        ld      d,RowRelative
 883  64FA 1E 06                                ld      e,XPosX
 884  64FC DD 21 65 C0                          ld      ix,UBnKOffset
 885  6500 CD 29 66                             call    DisplayS24
 886  6503 16 0D                                ld      d,RowRelative
 887  6505 1E 0F                                ld      e,XPosY
 888  6507 DD 21 68 C0                          ld      ix,UBnKOffset+3
 889  650B CD 29 66                             call    DisplayS24
 890  650E 16 0D                                ld      d,RowRelative
 891  6510 1E 18                                ld      e,XPosZ
 892  6512 DD 21 6B C0                          ld      ix,UBnKOffset+6
 893  6516 CD 29 66                             call    DisplayS24
 894  6519 C9                                   ret
 895  651A
 896  651A 16 0F        DisplayDirection:       ld      d,RowDirection
 897  651C 1E 06                                ld      e,XPosX
 898  651E DD 21 77 C0                          ld      ix,UBnKDirNormX
 899  6522 CD 62 66                             call    DisplayS08
 900  6525 16 0F                                ld      d,RowDirection
 901  6527 1E 0F                                ld      e,XPosY
 902  6529 DD 21 79 C0                          ld      ix,UBnKDirNormY
 903  652D CD 62 66                             call    DisplayS08
 904  6530 16 0F                                ld      d,RowDirection
 905  6532 1E 18                                ld      e,XPosZ
 906  6534 DD 21 7B C0                          ld      ix,UBnKDirNormZ
 907  6538 CD 62 66                             call    DisplayS08
 908  653B C9                                   ret
 909  653C
 910  653C
 911  653C
 912  653C 3A 7F C0     DisplayDotProduct:      ld      a,(UBnKDotProductNoseSign)
 913  653F 16 10                                ld      d,RowDotProduct
 914  6541 1E 09                                ld      e,XNoseDP
 915  6543 CD 0F E2                             call    l1_printSignByte
 916  6546 3A 82 C0                             ld      a,(UBnKDotProductRoofSign)
 917  6549 16 10                                ld      d,RowDotProduct
 918  654B 1E 12                                ld      e,XRoofDP
 919  654D CD 0F E2                             call    l1_printSignByte
 920  6550 3A 85 C0                             ld      a,(UBnKDotProductSideSign)
 921  6553 16 10                                ld      d,RowDotProduct
 922  6555 1E 1B                                ld      e,XSideDP
 923  6557 CD 0F E2                             call    l1_printSignByte
 924  655A 16 10                                ld      d,RowDotProduct
 925  655C 1E 0A                                ld      e,XNoseDP+1
 926  655E DD 21 7E C0                          ld      ix,UBnKDotProductNose+1
 927  6562 CD 72 66                             call    DisplayU8
 928  6565 16 10                                ld      d,RowDotProduct
 929  6567 1E 13                                ld      e,XRoofDP+1
 930  6569 DD 21 81 C0                          ld      ix,UBnKDotProductRoof+1
 931  656D CD 72 66                             call    DisplayU8
 932  6570 16 10                                ld      d,RowDotProduct
 933  6572 1E 1C                                ld      e,XSideDP+1
 934  6574 DD 21 84 C0                          ld      ix,UBnKDotProductSide+1
 935  6578 CD 72 66                             call    DisplayU8
 936  657B 3A 7F C0     .DisplayNoseDegrees:    ld      a,(UBnKDotProductNoseSign)
 937  657E 47                                   ld      b,a
 938  657F 3A 7E C0                             ld      a,(UBnKDotProductNose+1)
 939  6582 CD 49 73                             call    ArcCos
 940  6585 16 11                                ld      d,RowDotDegrees
 941  6587 1E 09                                ld      e,XNoseDP
 942  6589 FE FF                                cp      $FF
 943  658B CA 94 65                             jp      z,.NaNNose
 944  658E CD FB E1                             call    l1_print_u8_hex_at_char
 945  6591 C3 97 65                             jp      .PrintRoofDegrees
 946  6594 CD 2E E2     .NaNNose:               call    l1_print_u8_nan_at_char
 947  6597 3A 82 C0     .PrintRoofDegrees:      ld      a,(UBnKDotProductRoofSign)
 948  659A 47                                   ld      b,a
 949  659B 3A 81 C0                             ld      a,(UBnKDotProductRoof+1)
 950  659E CD 49 73                             call    ArcCos
 951  65A1 16 11                                ld      d,RowDotDegrees
 952  65A3 1E 12                                ld      e,XRoofDP
 953  65A5 FE FF                                cp      $FF
 954  65A7 CA B0 65                             jp      z,.NaNRoof
 955  65AA CD FB E1                             call    l1_print_u8_hex_at_char
 956  65AD C3 B3 65                             jp      .PrintSideDegrees
 957  65B0 CD 2E E2     .NaNRoof:               call    l1_print_u8_nan_at_char
 958  65B3 3A 85 C0     .PrintSideDegrees:      ld      a,(UBnKDotProductSideSign)
 959  65B6 47                                   ld      b,a
 960  65B7 3A 81 C0                             ld      a,(UBnKDotProductRoof+1)
 961  65BA CD 49 73                             call    ArcCos
 962  65BD 16 11                                ld      d,RowDotDegrees
 963  65BF 1E 1B                                ld      e,XSideDP
 964  65C1 FE FF                                cp      $FF
 965  65C3 CA CA 65                             jp      z,.NaNSide
 966  65C6 CD FB E1                             call    l1_print_u8_hex_at_char
 967  65C9 C9                                   ret
 968  65CA CD 2E E2     .NaNSide:               call    l1_print_u8_nan_at_char
 969  65CD C9                                   ret
 970  65CE
 971  65CE 16 04        DisplayMatrix:          ld      d,  RowMatrix1
 972  65D0 DD 21 2A C0                          ld      ix, UBnkrotmatSidevX
 973  65D4 CD D4 64                             call    DisplayMatrixRow
 974  65D7 16 05                                ld      d,  RowMatrix2
 975  65D9 DD 21 30 C0                          ld      ix, UBnkrotmatRoofvX
 976  65DD CD D4 64                             call    DisplayMatrixRow
 977  65E0 16 06                                ld      d,  RowMatrix3
 978  65E2 DD 21 36 C0                          ld      ix, UBnkrotmatNosevX
 979  65E6 CD D4 64                             call    DisplayMatrixRow
 980  65E9 C9                                   ret
 981  65EA
 982  65EA DD 21 87 C0  DisplayAccellSpeed:     ld      ix,UBnKAccel
 983  65EE 16 07                                ld      d, RowAccellSpeed
 984  65F0 1E 06                                ld      e,XPosX
 985  65F2 CD 4C 66                             call    Display82C
 986  65F5 DD 21 86 C0                          ld      ix,UBnKSpeed
 987  65F9 16 07                                ld      d, RowAccellSpeed
 988  65FB 1E 18                                ld      e,XPosZ
 989  65FD CD 57 66                             call    DisplayS8
 990  6600 C9                                   ret
 991  6601
 992  6601 DD 21 88 C0  DisplayRollPitch:       ld      ix,UBnKRollCounter
 993  6605 16 08                                ld      d, RowPitchRoll
 994  6607 1E 06                                ld      e,XPosX
 995  6609 CD 57 66                             call    DisplayS8
 996  660C DD 21 89 C0                          ld      ix,UBnKPitchCounter
 997  6610 16 08                                ld      d, RowPitchRoll
 998  6612 1E 18                                ld      e,XPosZ
 999  6614 DD 7E 00                             ld      a,(ix+0)
1000  6617              ;                        cp      3
1001  6617              ;                        jp      z,.OK
1002  6617              ;                        break
1003  6617 CD 57 66     .OK                     call    DisplayS8
1004  661A C9                                   ret
1005  661B
1006  661B              DisplayBoilerLine:      MMUSelectLayer1
1006  661B ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1007  661F 7E                                   ld      a,(hl)
1008  6620 5F                                   ld      e,a
1009  6621 23                                   inc     hl
1010  6622 7E                                   ld      a,(hl)
1011  6623 57                                   ld      d,a
1012  6624 23                                   inc     hl
1013  6625 CD D7 E0                             call    l1_print_at_char
1014  6628 C9                                   ret
1015  6629
1016  6629              ; Display S24 value at address IX at position DE
1017  6629              DisplayS24:             MMUSelectLayer1
1017  6629 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1018  662D DD 7E 02                             ld      a,(ix+2)
1019  6630 67                                   ld      h,a
1020  6631 DD 7E 01                             ld      a,(ix+1)
1021  6634 6F                                   ld      l,a
1022  6635 DD 7E 00                             ld      a,(ix+0)
1023  6638 CD 52 E1                             call    l1_print_s24_hex_at_char
1024  663B C9                                   ret
1025  663C
1026  663C              DisplayS16:             MMUSelectLayer1
1026  663C ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1027  6640 DD 7E 01                             ld      a,(ix+1)
1028  6643 67                                   ld      h,a
1029  6644 DD 7E 00                             ld      a,(ix+0)
1030  6647 6F                                   ld      l,a
1031  6648 CD 7E E1                             call    l1_print_s16_hex_at_char
1032  664B C9                                   ret
1033  664C
1034  664C              Display82C:             MMUSelectLayer1
1034  664C ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1035  6650 DD 7E 00                             ld      a,(ix+0)
1036  6653 CD CB E1                             call    l1_print_82c_hex_at_char
1037  6656 C9                                   ret
1038  6657
1039  6657              DisplayS8:              MMUSelectLayer1
1039  6657 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1040  665B DD 7E 00                             ld      a,(ix+0)
1041  665E CD B4 E1                             call    l1_print_s8_hex_at_char
1042  6661 C9                                   ret
1043  6662              ; As per S8 but sign is a separate lead byte
1044  6662              DisplayS08:             MMUSelectLayer1
1044  6662 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1045  6666 DD 7E 00                             ld      a,(ix+0)
1046  6669 6F                                   ld      l,a
1047  666A DD 7E 01                             ld      a,(ix+1)
1048  666D 67                                   ld      h,a
1049  666E CD E7 E1                             call    l1_print_s08_hex_at_char
1050  6671 C9                                   ret
1051  6672
1052  6672              DisplayU8:              MMUSelectLayer1
1052  6672 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1053  6676 DD 7E 00                             ld      a,(ix+0)
1054  6679 CD FB E1                             call    l1_print_u8_hex_at_char
1055  667C C9                                   ret
1056  667D
1057  667D 3E FF        SetStatusSlow:          ld      a,$FF
1057  667F 32 8F 64       ld      (StatusSlow),a
1057  6682 C9             ret
1058  6683 3E FF        SetStatusFast:          ld      a,$FF
1058  6685 32 90 64       ld      (StatusFast),a
1058  6688 C9             ret
1059  6689 3E 00        SetStatusRollPlus:      ld      a,$00
1059  668B 32 91 64       ld      (StatusRoll),a
1059  668E C9             ret
1060  668F 3E 80        SetStatusRollMinus:     ld      a,$80
1060  6691 32 91 64       ld      (StatusRoll),a
1060  6694 C9             ret
1061  6695 3E 00        SetStatusPitchPlus:     ld      a,$00
1061  6697 32 92 64       ld      (StatusPitch),a
1061  669A C9             ret
1062  669B 3E 80        SetStatusPitchMinus:    ld      a,$80
1062  669D 32 92 64       ld      (StatusPitch),a
1062  66A0 C9             ret
1063  66A1 3E FF        SetStatusBehind:        ld      a,$FF
1063  66A3 32 93 64       ld      (StatusBehind),a
1063  66A6 C9             ret
1064  66A7 3E FF        SetStatusForward:       ld      a,$FF
1064  66A9 32 94 64       ld      (StatusForward),a
1064  66AC C9             ret
1065  66AD 3E FF        SetStatusHit:           ld      a,$FF
1065  66AF 32 97 64       ld      (StatusHit),a
1065  66B2 C9             ret
1066  66B3 3E FF        SetStatusNear:          ld      a,$FF
1066  66B5 32 95 64       ld      (StatusNear),a
1066  66B8 C9             ret
1067  66B9 3E FF        SetStatusFar:           ld      a,$FF
1067  66BB 32 96 64       ld      (StatusFar),a
1067  66BE C9             ret
1068  66BF
1069  66BF 3E 00        ClearStatusSlow:        ld      a,$00
1069  66C1 32 8F 64       ld      (StatusSlow),a
1069  66C4 C9             ret
1070  66C5 3E 00        ClearStatusFast:        ld      a,$00
1070  66C7 32 90 64       ld      (StatusFast),a
1070  66CA C9             ret
1071  66CB 3E 01        ClearStatusRoll:        ld      a,$01
1071  66CD 32 91 64       ld      (StatusRoll),a
1071  66D0 C9             ret
1072  66D1 3E 01        ClearStatusPitch:       ld      a,$01
1072  66D3 32 92 64       ld      (StatusPitch),a
1072  66D6 C9             ret
1073  66D7 3E 00        ClearStatusBehind:      ld      a,$00
1073  66D9 32 93 64       ld      (StatusBehind),a
1073  66DC C9             ret
1074  66DD 3E 00        ClearStatusForward:     ld      a,$00
1074  66DF 32 94 64       ld      (StatusForward),a
1074  66E2 C9             ret
1075  66E3 3E 00        ClearStatusHit:         ld      a,$00
1075  66E5 32 97 64       ld      (StatusHit),a
1075  66E8 C9             ret
1076  66E9 3E 00        ClearStatusNear:        ld      a,$00
1076  66EB 32 95 64       ld      (StatusNear),a
1076  66EE C9             ret
1077  66EF 3E 00        ClearStatusFar:         ld      a,$00
1077  66F1 32 96 64       ld      (StatusFar),a
1077  66F4 C9             ret
1078  66F5
1079  66F5 3A 8F 64     UpdateStatusSlow:       ld      a,(StatusSlow)
1080  66F8 A7                                   and     a
1081  66F9 CA 67 67                             jp      z,HideSlow
1082  66FC C3 59 67                             jp      DisplaySlow
1083  66FF                                      ; Implicit Return
1084  66FF 3A 90 64     UpdateStatusFast:       ld      a,(StatusFast)
1085  6702 A7                                   and     a
1086  6703 CA 83 67                             jp      z,HideFast
1087  6706 C3 75 67                             jp      DisplayFast
1088  6709                                      ; Implicit Return
1089  6709 3A 91 64     UpdateStatusRoll:       ld      a,(StatusRoll)
1090  670C A7                                   and     a
1091  670D CA AD 67                             jp      z,HideRoll
1092  6710 FE 80                                cp      $80
1093  6712 CA 9F 67                             jp      z,DisplayRollMinus
1094  6715 C3 91 67                             jp      DisplayRollPlus
1095  6718                                      ; Implicit Return
1096  6718 3A 92 64     UpdateStatusPitch:      ld      a,(StatusPitch)
1097  671B A7                                   and     a
1098  671C CA D7 67                             jp      z,HidePitch
1099  671F FE 80                                cp      $80
1100  6721 CA C9 67                             jp      z,DisplayPitchMinus
1101  6724 C3 BB 67                             jp      DisplayPitchPlus
1102  6727                                      ; Implicit Return
1103  6727 3A 93 64     UpdateStatusBehind:     ld      a,(StatusBehind)
1104  672A A7                                   and     a
1105  672B CA F0 67                             jp      z,HideBehind
1106  672E C3 E5 67                             jp      DisplayBehind
1107  6731                                      ; Implicit Return
1108  6731 3A 94 64     UpdateStatusForward:    ld      a,(StatusForward)
1109  6734 A7                                   and     a
1110  6735 CA 06 68                             jp      z,HideForward
1111  6738 C3 FB 67                             jp      DisplayForward
1112  673B                                      ; Implicit Return
1113  673B 3A 97 64     UpdateStatusHit:        ld      a,(StatusHit)
1114  673E A7                                   and     a
1115  673F CA 1C 68                             jp      z,HideHit
1116  6742 C3 11 68                             jp      DisplayHit
1117  6745                                      ; Implicit Return
1118  6745 3A 95 64     UpdateStatusNear:       ld      a,(StatusNear)
1119  6748 A7                                   and     a
1120  6749 CA 32 68                             jp      z,HideNear
1121  674C C3 27 68                             jp      DisplayNear
1122  674F                                      ; Implicit Return
1123  674F 3A 96 64     UpdateStatusFar:        ld      a,(StatusFar)
1124  6752 A7                                   and     a
1125  6753 CA 48 68                             jp      z,HideFar
1126  6756 C3 3D 68                             jp      DisplayFar
1127  6759                                      ; Implicit Return
1128  6759
1129  6759              DisplaySlow             MMUSelectLayer1
1129  6759 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1130  675D 16 13                                ld      d,19
1131  675F 1E 09                                ld      e,XSpeed
1132  6761 3E 80                                ld      a,$80
1133  6763 CD 0F E2                             call    l1_printSignByte
1134  6766 C9                                   ret
1135  6767
1136  6767              HideSlow                MMUSelectLayer1
1136  6767 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1137  676B 16 13                                ld      d,19
1138  676D 1E 09                                ld      e,XSpeed
1139  676F 3E 01                                ld      a,$01
1140  6771 CD 0F E2                             call    l1_printSignByte
1141  6774 C9                                   ret
1142  6775
1143  6775              DisplayFast             MMUSelectLayer1
1143  6775 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1144  6779 16 13                                ld      d,19
1145  677B 1E 09                                ld      e,XSpeed
1146  677D 3E 00                                ld      a,$00
1147  677F CD 0F E2                             call    l1_printSignByte
1148  6782 C9                                   ret
1149  6783
1150  6783              HideFast                MMUSelectLayer1
1150  6783 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1151  6787 16 13                                ld      d,19
1152  6789 1E 09                                ld      e,XSpeed
1153  678B 3E 01                                ld      a,$01
1154  678D CD 0F E2                             call    l1_printSignByte
1155  6790 C9                                   ret
1156  6791
1157  6791              DisplayRollPlus         MMUSelectLayer1
1157  6791 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1158  6795 16 13                                ld      d,19
1159  6797 1E 1C                                ld      e,XRoll
1160  6799 3E 00                                ld      a,$00
1161  679B CD 0F E2                             call    l1_printSignByte
1162  679E C9                                   ret
1163  679F
1164  679F              DisplayRollMinus        MMUSelectLayer1
1164  679F ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1165  67A3 16 13                                ld      d,19
1166  67A5 1E 1C                                ld      e,XRoll
1167  67A7 3E 08                                ld      a,$08
1168  67A9 CD 0F E2                             call    l1_printSignByte
1169  67AC C9                                   ret
1170  67AD
1171  67AD              HideRoll                MMUSelectLayer1
1171  67AD ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1172  67B1 16 13                                ld      d,19
1173  67B3 1E 1C                                ld      e,XRoll
1174  67B5 3E 01                                ld      a,$01
1175  67B7 CD 0F E2                             call    l1_printSignByte
1176  67BA C9                                   ret
1177  67BB
1178  67BB              DisplayPitchPlus        MMUSelectLayer1
1178  67BB ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1179  67BF 16 13                                ld      d,19
1180  67C1 1E 13                                ld      e,XPitch
1181  67C3 3E 00                                ld      a,$00
1182  67C5 CD 0F E2                             call    l1_printSignByte
1183  67C8 C9                                   ret
1184  67C9
1185  67C9              DisplayPitchMinus       MMUSelectLayer1
1185  67C9 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1186  67CD 16 13                                ld      d,19
1187  67CF 1E 13                                ld      e,XPitch
1188  67D1 3E 80                                ld      a,$80
1189  67D3 CD 0F E2                             call    l1_printSignByte
1190  67D6 C9                                   ret
1191  67D7
1192  67D7              HidePitch               MMUSelectLayer1
1192  67D7 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1193  67DB 16 13                                ld      d,19
1194  67DD 1E 13                                ld      e,XPitch
1195  67DF 3E 01                                ld      a,$01
1196  67E1 CD 0F E2                             call    l1_printSignByte
1197  67E4 C9                                   ret
1198  67E5
1199  67E5              DisplayBehind           MMUSelectLayer1
1199  67E5 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1200  67E9 21 43 64                             ld      hl,ActionTextBehind
1201  67EC CD 1B 66                             call    DisplayBoilerLine
1202  67EF C9                                   ret
1203  67F0
1204  67F0              HideBehind              MMUSelectLayer1
1204  67F0 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1205  67F4 21 69 64                             ld      hl,ClearTextBehind
1206  67F7 CD 1B 66                             call    DisplayBoilerLine
1207  67FA C9                                   ret
1208  67FB
1209  67FB              DisplayForward          MMUSelectLayer1
1209  67FB ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1210  67FF 21 4C 64                             ld      hl,ActionTextForward
1211  6802 CD 1B 66                             call    DisplayBoilerLine
1212  6805 C9                                   ret
1213  6806
1214  6806              HideForward             MMUSelectLayer1
1214  6806 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1215  680A 21 72 64                             ld      hl,ClearTextForward
1216  680D CD 1B 66                             call    DisplayBoilerLine
1217  6810 C9                                   ret
1218  6811
1219  6811              DisplayHit:             MMUSelectLayer1
1219  6811 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1220  6815 21 63 64                             ld      hl,ActionTextHit
1221  6818 CD 1B 66                             call    DisplayBoilerLine
1222  681B C9                                   ret
1223  681C
1224  681C              HideHit:                MMUSelectLayer1
1224  681C ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1225  6820 21 7C 64                             ld      hl,ClearTextHit
1226  6823 CD 1B 66                             call    DisplayBoilerLine
1227  6826 C9                                   ret
1228  6827
1229  6827              DisplayNear:            MMUSelectLayer1
1229  6827 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1230  682B 21 56 64                             ld      hl,ActionTextNear
1231  682E CD 1B 66                             call    DisplayBoilerLine
1232  6831 C9                                   ret
1233  6832
1234  6832              HideNear:               MMUSelectLayer1
1234  6832 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1235  6836 21 82 64                             ld      hl,ClearTextNear
1236  6839 CD 1B 66                             call    DisplayBoilerLine
1237  683C C9                                   ret
1238  683D
1239  683D              DisplayFar:             MMUSelectLayer1
1239  683D ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1240  6841 21 5D 64                             ld      hl,ActionTextFar
1241  6844 CD 1B 66                             call    DisplayBoilerLine
1242  6847 C9                                   ret
1243  6848
1244  6848              HideFar:                MMUSelectLayer1
1244  6848 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
1245  684C 21 89 64                             ld      hl,ClearTextFar
1246  684F CD 1B 66                             call    DisplayBoilerLine
1247  6852 C9                                   ret
1248  6853
1249  6853 21 E4 62     DisplayBoiler:          ld      hl, BoilerPlate1
1250  6856 CD 1B 66                             call    DisplayBoilerLine
1251  6859 21 04 63                             ld      hl, BoilerPlate2
1252  685C CD 1B 66                             call    DisplayBoilerLine
1253  685F 21 24 63                             ld      hl, BoilerPlate3
1254  6862 CD 1B 66                             call    DisplayBoilerLine
1255  6865 21 2B 63                             ld      hl, BoilerPlate4
1256  6868 CD 1B 66                             call    DisplayBoilerLine
1257  686B 21 32 63                             ld      hl, BoilerPlate5
1258  686E CD 1B 66                             call    DisplayBoilerLine
1259  6871 21 39 63                             ld      hl, BoilerPlate6
1260  6874 CD 1B 66                             call    DisplayBoilerLine
1261  6877 21 54 63                             ld      hl, BoilerPlate7
1262  687A CD 1B 66                             call    DisplayBoilerLine
1263  687D 21 6F 63                             ld      hl, BoilerPlate8
1264  6880 CD 1B 66                             call    DisplayBoilerLine
1265  6883 21 8F 63                             ld      hl, BoilerPlate9
1266  6886 CD 1B 66                             call    DisplayBoilerLine
1267  6889 21 99 63                             ld      hl, BoilerPlate10
1268  688C CD 1B 66                             call    DisplayBoilerLine
1269  688F 21 B9 63                             ld      hl, BoilerPlate11
1270  6892 CD 1B 66                             call    DisplayBoilerLine
1271  6895 21 D9 63                             ld      hl, BoilerPlate12
1272  6898 CD 1B 66                             call    DisplayBoilerLine
1273  689B 21 FA 63                             ld      hl, BoilerPlate13
1274  689E CD 1B 66                             call    DisplayBoilerLine
1275  68A1 21 1B 64                             ld      hl, BoilerPlate14
1276  68A4 CD 1B 66                             call    DisplayBoilerLine
1277  68A7 21 25 64                             ld      hl, BoilerPlate15
1278  68AA CD 1B 66                             call    DisplayBoilerLine
1279  68AD C9                                   ret
1280  68AE
1281  68AE              ;----------------------------------------------------------------------------------------------------------------------------------
1282  68AE              ; Set initial ship position as X,Y,Z 000,000,03B4
1283  68AE 21 00 00     SetInitialShipPosition: ld      hl,$0000
1284  68B1 22 20 C0                             ld      (UBnKxlo),hl
1285  68B4 21 00 00                             ld      hl,$0000
1286  68B7 22 23 C0                             ld      (UBnKylo),hl
1287  68BA 21 B4 03                             ld      hl,$03B4
1288  68BD 22 26 C0                             ld      (UBnKzlo),hl
1289  68C0 AF                                   xor     a
1290  68C1 32 22 C0                             ld      (UBnKxsgn),a
1291  68C4 32 25 C0                             ld      (UBnKysgn),a
1292  68C7 32 28 C0                             ld      (UBnKzsgn),a
1293  68CA CD CB C7                             call	InitialiseOrientation            ;#00;
1294  68CD 3E 01                                ld      a,1
1295  68CF 32 10 6C                             ld      (DELTA),a
1296  68D2 21 04 00                             ld      hl,4
1297  68D5 22 11 6C                             ld      (DELTA4),hl
1298  68D8 C9                                   ret
1299  68D9
1300  68D9              ; Use bank 0 as source and bank 7 as write target
1301  68D9              ResetUniv:              MMUSelectCpySrcN BankUNIVDATA0	         ; master universe def in bank 0
1301  68D9 ED 91 50 46 >                     nextreg DMACpySourceMMU,	BankUNIVDATA0
1302  68DD 3E 01                                ld		a,1             				 ; we can read bank 0 as if it was rom
1303  68DF 06 0C                                ld		b,12
1304  68E1 C5 F5        .ResetCopyLoop:         push	bc,,af
1305  68E3                                      MMUSelectUniverseA			             ; copy from bank 0 to 71 to 12
1305  68E3 C6 46       >                     add    a,BankUNIVDATA0
1305  68E5 ED 92 56    >                     nextreg UniverseMMU,       a
1306  68E8 21 00 C0                             ld		hl,UniverseBankAddr
1307  68EB 11 00 00                             ld		de,dmaCopySrcAddr
1308  68EE 01 66 19                             ld		bc,UnivBankSize
1309  68F1 CD B8 6A                             call	memcopy_dma
1310  68F4 F1 C1                                pop		bc,,af
1311  68F6 57                                   ld      d,a
1312  68F7 C6 41                                add     "A"
1313  68F9 32 0B C0                             ld      (StartOfUnivN),a
1314  68FC 7A                                   ld      a,d
1315  68FD 3C                                   inc		a
1316  68FE 10 E1                                djnz	.ResetCopyLoop
1317  6900 C9                                   ret
1318  6901
1319  6901                          DISPLAY "../../Maths/Utilities/XX12EquNodeDotOrientation.asm"
1320  6901                          include "../../Maths/Utilities/XX12EquNodeDotOrientation.asm"
# file opened: ../../Maths/Utilities/XX12EquNodeDotOrientation.asm
   1+ 6901              ; We enter here with hl pointing at XX16 and bc = XX15 value
   2+ 6901              ; so xx12 = XX15 * XX16 row
   3+ 6901              XX12ProcessOneRow:
   4+ 6901              XX12CalcXCell:
   5+ 6901 ED 4B E7 C0          ld		bc,(UBnkXScaled)
   6+ 6905 5E           		ld		e,(hl)								    ; get orientation ZX
   7+ 6906 23           		inc		hl
   8+ 6907 56           		ld		d,(hl)                                  ; so now e = xx16 value d = xx16 sign
   9+ 6908 7A           		ld		a,d
  10+ 6909 A8                   xor     b
  11+ 690A E6 80        		and		SignOnly8Bit                            ; a = XX 16 sign
  12+ 690C DD 67        		ld		ixh,a								    ; orientation sign to ixh
  13+ 690E 78           		ld		a,b                                     ; now make bc abs bc
  14+ 690F E6 7F        		and		SignMask8Bit
  15+ 6911 47           		ld		b,a                                     ; bc = abs(bc) now
  16+ 6912 E5           		push	hl
  17+ 6913 16 00                ld      d,0                                     ; d = value
  18+ 6915 60           		ld		h,b
  19+ 6916 69           		ld		l,c
  20+ 6917 CD 72 71     		call	mulDEbyHL							    ; hl = |orientation| * |x pos)
  21+ 691A 22 D3 6A     		ld		(XX12PVarResult1),hl				    ; T = 16 bit result, we only want to use high byte later
  22+ 691D DD 7C        		ld		a,ixh
  23+ 691F 32 DA 6A     		ld		(XX12PVarSign1),a					    ; S = sign  not sign 1 and 2 are reversed in memory so that fetchign back will put 1 in high byte 2 in low byte
  24+ 6922 E1           		pop		hl
  25+ 6923              XX12CalcYCell:
  26+ 6923 ED 4B E9 C0          ld		bc,(UBnkYScaled)
  27+ 6927 23           		inc		hl
  28+ 6928 5E           		ld		e,(hl)							    	; get orientation ZX
  29+ 6929 23           		inc		hl
  30+ 692A 56           		ld		d,(hl)
  31+ 692B 7A           		ld		a,d
  32+ 692C A8                   xor     b
  33+ 692D E6 80        		and		SignOnly8Bit
  34+ 692F DD 67        		ld		ixh,a								    ; XX16 orientation sign to ixh
  35+ 6931 78           		ld		a,b                                     ; now make bc abs bc
  36+ 6932 E6 7F        		and		SignMask8Bit
  37+ 6934 47           		ld		b,a                                     ; bc = abs(bc) now
  38+ 6935 E5           		push	hl
  39+ 6936 16 00                ld      d,0                                     ; d = value
  40+ 6938 60           		ld		h,b
  41+ 6939 69           		ld		l,c
  42+ 693A CD 72 71     		call	mulDEbyHL							    ; hl = |orientation| * |x pos)
  43+ 693D 22 D5 6A     		ld		(XX12PVarResult2),hl				    ; T = 16 bit result
  44+ 6940 DD 7C        		ld		a,ixh
  45+ 6942 32 D9 6A     		ld		(XX12PVarSign2),a					    ; S = sign
  46+ 6945 E1           		pop		hl
  47+ 6946              XX12CalcZCell:
  48+ 6946 ED 4B EB C0          ld		bc,(UBnkZScaled)
  49+ 694A 23           		inc		hl
  50+ 694B 5E           		ld		e,(hl)								    ; get orientation ZX
  51+ 694C 23           		inc		hl
  52+ 694D 56           		ld		d,(hl)
  53+ 694E 7A           		ld		a,d
  54+ 694F A8                   xor     b
  55+ 6950 E6 80        		and		SignOnly8Bit
  56+ 6952 DD 67        		ld		ixh,a								    ; orientation sign to ixh
  57+ 6954 78           		ld		a,b                                     ; now make bc abs bc
  58+ 6955 E6 7F        		and		SignMask8Bit
  59+ 6957 47           		ld		b,a                                     ; bc = abs(bc) now
  60+ 6958 16 00                ld      d,0                                     ; d = value
  61+ 695A 60           		ld		h,b
  62+ 695B 69           		ld		l,c
  63+ 695C CD 72 71     		call	mulDEbyHL							    ; hl = |orientation| * |x pos)
  64+ 695F 22 D7 6A     		ld		(XX12PVarResult3),hl				    ; T = 16 bit result
  65+ 6962 DD 7C        		ld		a,ixh
  66+ 6964 32 DB 6A     		ld		(XX12PVarSign3),a					    ; S = sign
  67+ 6967              XX12CalcCellResult:
  68+ 6967 2A D3 6A     		ld		hl,(XX12PVarResult1)				    ; X Cell Result
  69+ 696A ED 5B D5 6A  		ld		de,(XX12PVarResult2)				    ; Y Cell Result
  70+ 696E ED 4B D9 6A  		ld		bc,(XX12PVarSign2)					    ; b = var 1 result sign c = var 2 result signs
  71+ 6972              XX12MSBOnly:
  72+ 6972 6C           		ld		l,h									    ; now move results into lower byte so / 256
  73+ 6973 5A           		ld		e,d									    ; for both results
  74+ 6974 AF           		xor		a									    ;
  75+ 6975 67           		ld		h,a									    ;
  76+ 6976 57           		ld		d,a									    ; so set high byte to 0
  77+ 6977 CD 33 00     		call	ADDHLDESignBC                           ;  XX12ProcessCalcHLPlusDESignBC		; returns with HL = result1 + result 2 signed in a
  78+ 697A 47           		ld		b,a									    ; move sign into b ready for next calc
  79+ 697B 3A DB 6A     		ld		a,(XX12PVarSign3)					    ; result of the calcZ cell
  80+ 697E 4F           		ld		c,a									    ; goes into c to align with DE
  81+ 697F ED 5B D7 6A  		ld		de,(XX12PVarResult3)				    ; now add result to Result 3
  82+ 6983 5A           		ld		e,d                                     ; d = result /256
  83+ 6984 16 00        		ld		d,0									    ; and only us high byte
  84+ 6986 CD 33 00     		call	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC		; returns with HL = result and a = sign
  85+ 6989 C9           		ret											    ; hl = result, a = sign
  86+ 698A              								    ; hl = result, a = sign
  87+ 698A
  88+ 698A              XX12EquNodeDotTransMat:							    ; .LL51	\ -> &4832 \ XX12=XX15.XX16  each vector is 16-bit x,y,z **** ACTUALLY XX16 is value in low sign bit in high
  89+ 698A              ;...X cell
  90+ 698A 21 BA C0     		ld		hl,UbnkTransInvRow0x0     			; process orientation matrix row 0
  91+ 698D CD 01 69             call    XX12ProcessOneRow                   ; hl = result, a = sign
  92+ 6990 47           		ld		b,a                                 ; b = sign
  93+ 6991 7C           		ld		a,h                                 ; a = high byte
  94+ 6992 B0           		or		b
  95+ 6993 32 EE C0     		ld		(UBnkXX12xSign),a					; a = result with sign in bit 7
  96+ 6996 7D           		ld		a,l                                 ; the result will be in the lower byte now
  97+ 6997 32 ED C0             ld      (UBnkXX12xLo),a						; that is result done for
  98+ 699A              ;...Y cell
  99+ 699A 21 C2 C0     		ld		hl,UbnkTransInvRow1y0     			; process orientation matrix row 1
 100+ 699D CD 01 69             call    XX12ProcessOneRow
 101+ 69A0 47           		ld		b,a
 102+ 69A1 7C           		ld		a,h
 103+ 69A2              ;		ld		a,l
 104+ 69A2 B0           		or		b
 105+ 69A3 32 F0 C0     		ld		(UBnkXX12ySign),a					; a = result with sign in bit 7
 106+ 69A6 7D           		ld		a,l                                 ; the result will be in the lower byte now
 107+ 69A7 32 EF C0             ld      (UBnkXX12yLo),a						; that is result done for
 108+ 69AA              ;...Z cell
 109+ 69AA 21 CA C0     		ld		hl,UbnkTransInvRow2z0     			; process orientation matrix row 1
 110+ 69AD CD 01 69             call    XX12ProcessOneRow
 111+ 69B0 47           		ld		b,a
 112+ 69B1 7C                   ld		a,h
 113+ 69B2              ;		ld		a,l
 114+ 69B2 B0           		or		b
 115+ 69B3 32 F2 C0     		ld		(UBnkXX12zSign),a					; a = result with sign in bit 7
 116+ 69B6 7D           		ld		a,l                                 ; the result will be in the lower byte now
 117+ 69B7 32 F1 C0             ld      (UBnkXX12zLo),a						; that is result done for
 118+ 69BA C9                   ret
 119+ 69BB
 120+ 69BB              XX12EquNodeDotOrientation:							; .LL51	\ -> &4832 \ XX12=XX15.XX16  each vector is 16-bit x,y,z **** ACTUALLY XX16 is value in low sign bit in high
 121+ 69BB              ;...X cell
 122+ 69BB 21 BA C0     		ld		hl,UbnkTransInvRow0x0     			; process orientation matrix row 0
 123+ 69BE CD 01 69             call    XX12ProcessOneRow                   ; hl = result, a = sign
 124+ 69C1 47           		ld		b,a                                 ; b = sign
 125+ 69C2 7C           		ld		a,h                                 ; a = high byte
 126+ 69C3 B0           		or		b
 127+ 69C4 32 EE C0     		ld		(UBnkXX12xSign),a					; a = result with sign in bit 7
 128+ 69C7 7D           		ld		a,l                                 ; the result will be in the lower byte now
 129+ 69C8 32 ED C0             ld      (UBnkXX12xLo),a						; that is result done for
 130+ 69CB              ;...Y cell
 131+ 69CB 21 C2 C0     		ld		hl,UbnkTransInvRow1y0     			; process orientation matrix row 1
 132+ 69CE CD 01 69             call    XX12ProcessOneRow
 133+ 69D1 47           		ld		b,a
 134+ 69D2 7C           		ld		a,h
 135+ 69D3              ;		ld		a,l
 136+ 69D3 B0           		or		b
 137+ 69D4 32 F0 C0     		ld		(UBnkXX12ySign),a					; a = result with sign in bit 7
 138+ 69D7 7D           		ld		a,l                                 ; the result will be in the lower byte now
 139+ 69D8 32 EF C0             ld      (UBnkXX12yLo),a						; that is result done for
 140+ 69DB              ;...Z cell
 141+ 69DB 21 CA C0     		ld		hl,UbnkTransInvRow2z0     			; process orientation matrix row 1
 142+ 69DE CD 01 69             call    XX12ProcessOneRow
 143+ 69E1 47           		ld		b,a
 144+ 69E2 7C                   ld		a,h
 145+ 69E3              ;		ld		a,l
 146+ 69E3 B0           		or		b
 147+ 69E4 32 F2 C0     		ld		(UBnkXX12zSign),a					; a = result with sign in bit 7
 148+ 69E7 7D           		ld		a,l                                 ; the result will be in the lower byte now
 149+ 69E8 32 F1 C0             ld      (UBnkXX12zLo),a						; that is result done for
 150+ 69EB C9                   ret
 151+ 69EC
 152+ 69EC              XX12EquNodeDotXX16:					         		; .LL51	\ -> &4832 \ XX12=XX15.XX16  each vector is 16-bit x,y,z **** ACTUALLY XX16 is value in low sign bit in high
 153+ 69EC              ;...X cell
 154+ 69EC 21 A2 C0     		ld		hl,UBnkTransmatSidevX     			; process orientation matrix row 0
 155+ 69EF CD 01 69             call    XX12ProcessOneRow                   ; hl = result, a = sign
 156+ 69F2 47           		ld		b,a                                 ; b = sign
 157+ 69F3 7C           		ld		a,h                                 ; a = high byte
 158+ 69F4 B0           		or		b
 159+ 69F5 32 EE C0     		ld		(UBnkXX12xSign),a					; a = result with sign in bit 7
 160+ 69F8 7D           		ld		a,l                                 ; the result will be in the lower byte now
 161+ 69F9 32 ED C0             ld      (UBnkXX12xLo),a						; that is result done for
 162+ 69FC              ;...Y cell
 163+ 69FC 21 A8 C0     		ld		hl,UBnkTransmatRoofvX     			; process orientation matrix row 1
 164+ 69FF CD 01 69             call    XX12ProcessOneRow
 165+ 6A02 47           		ld		b,a
 166+ 6A03 7C           		ld		a,h
 167+ 6A04              ;		ld		a,l
 168+ 6A04 B0           		or		b
 169+ 6A05 32 F0 C0     		ld		(UBnkXX12ySign),a					; a = result with sign in bit 7
 170+ 6A08 7D           		ld		a,l                                 ; the result will be in the lower byte now
 171+ 6A09 32 EF C0             ld      (UBnkXX12yLo),a						; that is result done for
 172+ 6A0C              ;...Z cell
 173+ 6A0C 21 AE C0     		ld		hl,UBnkTransmatNosevX     			; process orientation matrix row 1
 174+ 6A0F CD 01 69             call    XX12ProcessOneRow
 175+ 6A12 47           		ld		b,a
 176+ 6A13 7C                   ld		a,h
 177+ 6A14              ;		ld		a,l
 178+ 6A14 B0           		or		b
 179+ 6A15 32 F2 C0     		ld		(UBnkXX12zSign),a					; a = result with sign in bit 7
 180+ 6A18 7D           		ld		a,l                                 ; the result will be in the lower byte now
 181+ 6A19 32 F1 C0             ld      (UBnkXX12zLo),a						; that is result done for
 182+ 6A1C C9                   ret
# file closed: ../../Maths/Utilities/XX12EquNodeDotOrientation.asm
1321  6A1D                          DISPLAY "../../ModelRender/CopyXX12ToXX15.asm"
1322  6A1D                          include "../../ModelRender/CopyXX12ToXX15.asm"
# file opened: ../../ModelRender/CopyXX12ToXX15.asm
   1+ 6A1D 21 ED C0     CopyXX12ToXX15:         ld      hl,XX12
   2+ 6A20 11 E7 C0                             ld      de,XX15
   3+ 6A23 01 06 00                             ld      bc,6
   4+ 6A26 ED B0                                ldir
   5+ 6A28 C9                                   ret
   6+ 6A29
   7+ 6A29 21 ED C0     CopyXX12ToXX12Save:     ld      hl,XX12
   8+ 6A2C 11 F3 C0                             ld      de,XX12Save
   9+ 6A2F 01 06 00                             ld      bc,6
  10+ 6A32 ED B0                                ldir
  11+ 6A34 C9                                   ret
  12+ 6A35
  13+ 6A35 21 F3 C0     CopyXX12SaveToXX12:     ld      hl,XX12Save
  14+ 6A38 11 ED C0                             ld      de,XX12
  15+ 6A3B 01 06 00                             ld      bc,6
  16+ 6A3E ED B0                                ldir
  17+ 6A40 C9                                   ret
  18+ 6A41
  19+ 6A41 21 ED C0     CopyXX12ToXX12Save2:    ld      hl,XX12
  20+ 6A44 11 F9 C0                             ld      de,XX12Save2
  21+ 6A47 01 06 00                             ld      bc,6
  22+ 6A4A ED B0                                ldir
  23+ 6A4C C9                                   ret
  24+ 6A4D
  25+ 6A4D 21 F9 C0     CopyXX12Save2ToXX12:    ld      hl,XX12Save2
  26+ 6A50 11 ED C0                             ld      de,XX12
  27+ 6A53 01 06 00                             ld      bc,6
  28+ 6A56 ED B0                                ldir
  29+ 6A58 C9                                   ret
  30+ 6A59
# file closed: ../../ModelRender/CopyXX12ToXX15.asm
1323  6A59                          DISPLAY "../../Maths/Utilities/ScaleXX16Matrix197.asm"
1324  6A59                          include "../../Maths/Utilities/ScaleXX16Matrix197.asm"
# file opened: ../../Maths/Utilities/ScaleXX16Matrix197.asm
   1+ 6A59              ScaleXX16Matrix197:
   2+ 6A59                      IFDEF LOGMATHS
   3+ 6A59 ~                                    ld		b,9                 ; Interate though all 9 matrix elements
   4+ 6A59 ~                                    ld		hl,UBnkTransmatSidev ; within XX16 (transmat)
   5+ 6A59 ~                                    MMUSelectMathsTables
   6+ 6A59 ~            .ScaleXX16Loop:         ld		e,(hl)              ; set DE = matrix value              ;
   7+ 6A59 ~                                    inc		hl                  ;
   8+ 6A59 ~                                    ld		a,(hl)              ;
   9+ 6A59 ~                                    ld		d,a                 ;
  10+ 6A59 ~                                    and     SignOnly8Bit        ; A holds high still to we can strip out sign bit
  11+ 6A59 ~                                    ld		ixl,a				; retain for sign bit
  12+ 6A59 ~                                    ShiftDELeft1				; carry now holds sign bit and DE = De * 2, this will in effect strip off the sign bit automatically
  13+ 6A59 ~                                    ld      a,d                 ; a = high byte after x 2
  14+ 6A59 ~                                    push	bc                  ; save BC  counter and constant 197
  15+ 6A59 ~                                    push	hl                  ; save HL
  16+ 6A59 ~                                    call    AEquAmul256Div197Log;
  17+ 6A59 ~                                    pop		hl
  18+ 6A59 ~                                    dec     hl                  ; move back to low byte
  19+ 6A59 ~                                    ld      (hl),a              ; save result in low byte as we want to preserve high byte sign
  20+ 6A59 ~                                    inc     hl                  ; move back to high byte
  21+ 6A59 ~                                    ld      a,ixl
  22+ 6A59 ~                                    ld      (hl),a              ; write back just sign bit
  23+ 6A59 ~                                    pop		bc                  ; retrieve both counter and constant 197
  24+ 6A59 ~                                    inc     hl                  ; no to next vertex value
  25+ 6A59 ~                                    djnz	.ScaleXX16Loop
  26+ 6A59 ~                                    MMUSelectROM0
  27+ 6A59 ~                                    ret
  28+ 6A59                      ELSE
  29+ 6A59 06 09                                ld		b,9                 ; Interate though all 9 matrix elements
  30+ 6A5B 0E C5                                ld		c,ConstNorm         ; c = 197
  31+ 6A5D 21 A2 C0                             ld		hl,UBnkTransmatSidev ; within XX16 (transmat)
  32+ 6A60 7E           .ScaleXX16Loop:         ld		a,(hl)              ; set DE = matrix value
  33+ 6A61 5F                                   ld		e,a                 ;
  34+ 6A62 23                                   inc		hl                  ;
  35+ 6A63 7E                                   ld		a,(hl)              ;
  36+ 6A64 57                                   ld		d,a                 ;
  37+ 6A65 E6 80                                and     SignOnly8Bit        ; A holds high still to we can strip out sign bit
  38+ 6A67 DD 6F                                ld		ixl,a				; retain for sign bit
  39+ 6A69                                      ShiftDELeft1				; carry now holds sign bit and DE = De * 2, this will in effect strip off the sign bit automatically
  39+ 6A69 CB 23       >			   sla e
  39+ 6A6B CB 12       >			   rl  d
  40+ 6A6D 7A                                   ld      a,d                 ; a = high byte after x 2
  41+ 6A6E C5                                   push	bc                  ; save BC  counter and constant 197
  42+ 6A6F E5                                   push	hl                  ; save HL
  43+ 6A70 CD A7 76                             call	DIV16Amul256dCUNDOC; AEquAmul256DivD; DIV16Amul256dCUNDOC	; result in BC = A*256 / 197 or D *512 / 197 = 2.6 * vector element, effectivley the result will always be in c
  44+ 6A73 E1                                   pop		hl
  45+ 6A74 2B                                   dec     hl                  ; move back to low byte
  46+ 6A75 71                                   ld      (hl),c              ; save result in low byte as we want to preserve high byte sign
  47+ 6A76 23                                   inc     hl                  ; move back to high byte
  48+ 6A77                                  ;    ld      a,(hl)
  49+ 6A77                                  ;    and     $80
  50+ 6A77 DD 7D                                ld      a,ixl
  51+ 6A79 77                                   ld      (hl),a              ; write back just sign bit
  52+ 6A7A C1                                   pop		bc                  ; retrieve both counter and constant 197
  53+ 6A7B 23                                   inc     hl                  ; no to next vertex value
  54+ 6A7C 10 E2                                djnz	.ScaleXX16Loop
  55+ 6A7E C9                                   ret
  56+ 6A7F                      ENDIF
# file closed: ../../Maths/Utilities/ScaleXX16Matrix197.asm
1325  6A7F
1326  6A7F                          ;nclude "../../Universe/StarDust/StarRoutines.asm"
1327  6A7F
1328  6A7F                          INCLUDE	"../../Hardware/memfill_dma.asm"
# file opened: ../../Hardware/memfill_dma.asm
   1+ 6A7F
   2+ 6A7F 00           memfillvalue		DB 0
   3+ 6A80 83 C3 C7 CB  memfill        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   3+ 6A84 7D
   4+ 6A85 7F 6A        memfill_astrt  		DW memfillvalue
   5+ 6A87 00 40        memfill_length 		DB $00,$40
   6+ 6A89 24 10 AD     					DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
   7+ 6A8C 00 00        memfill_bstrt  		DB $00,$00
   8+ 6A8E 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
   9+ 6A92              memfill_cmd_len	  	EQU $ - memfill
  10+ 6A92
  11+ 6A92              memfill_dma:
  12+ 6A92              ; "memfill_dma, hl = address to fill, a = value, de = length"
  13+ 6A92              .set_fill_value:
  14+ 6A92 32 7F 6A     	ld 		(memfillvalue),a
  15+ 6A95              .set_target:
  16+ 6A95 22 8C 6A     	ld		(memfill_bstrt),hl
  17+ 6A98              .set_length:
  18+ 6A98 ED 53 87 6A  	ld		(memfill_length),de
  19+ 6A9C              .write_dma:
  20+ 6A9C 21 80 6A     	ld 		hl, memfill
  21+ 6A9F 06 12        	ld 		b, memfill_cmd_len
  22+ 6AA1 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
  23+ 6AA3 ED B3        	otir
  24+ 6AA5 C9           	ret
  25+ 6AA6
# file closed: ../../Hardware/memfill_dma.asm
1329  6AA6                          INCLUDE	"../../Hardware/memcopy_dma.asm"
# file opened: ../../Hardware/memcopy_dma.asm
   1+ 6AA6
   2+ 6AA6 83 C3 C7 CB  memcopy        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   2+ 6AAA 7D
   3+ 6AAB 00 00        memcopy_astrt  		DB $00,$00
   4+ 6AAD 00 40        memcopy_length 		DB $00,$40
   5+ 6AAF 14 10 CD     					DB DMA_WR1_P1INC_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_BURST_MODE;DMA_WR4_CONT_MODE
   6+ 6AB2 00 00        memcopy_bstrt  		DB $00,$00
   7+ 6AB4 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
   8+ 6AB8              memcopy_cmd_len	  	equ $ - memcopy
   9+ 6AB8
  10+ 6AB8              memcopy_dma:
  11+ 6AB8              ; "memcopy_dma, hl = target address de = source address to copy, bc = length"
  12+ 6AB8              .set_target:
  13+ 6AB8 22 B2 6A     	ld		(memcopy_bstrt),hl
  14+ 6ABB              .set_source:
  15+ 6ABB ED 53 AB 6A  	ld		(memcopy_astrt),de
  16+ 6ABF              .set_length:
  17+ 6ABF ED 43 AD 6A  	ld		(memcopy_length),bc
  18+ 6AC3              .write_dma:
  19+ 6AC3 21 A6 6A     	ld 		hl, memcopy
  20+ 6AC6 06 12        	ld 		b, memcopy_cmd_len
  21+ 6AC8 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
  22+ 6ACA ED B3        	otir
  23+ 6ACC C9           	ret
  24+ 6ACD
# file closed: ../../Hardware/memcopy_dma.asm
1330  6ACD 00 00        XX12PVarQ			DW 0
1331  6ACF 00 00        XX12PVarR			DW 0
1332  6AD1 00 00        XX12PVarS			DW 0
1333  6AD3 00 00        XX12PVarResult1		DW 0
1334  6AD5 00 00        XX12PVarResult2		DW 0
1335  6AD7 00 00        XX12PVarResult3		DW 0
1336  6AD9 00           XX12PVarSign2		DB 0
1337  6ADA 00           XX12PVarSign1		DB 0								; Note reversed so BC can do a little endian fetch
1338  6ADB 00           XX12PVarSign3		DB 0
1339  6ADC                  INCLUDE "../../Variables/constant_equates.asm"
# file opened: ../../Variables/constant_equates.asm
   1+ 6ADC              ;Contants
   2+ 6ADC
   3+ 6ADC              SignMask8Bit		equ %01111111
   4+ 6ADC              SignMask16Bit		equ %0111111111111111
   5+ 6ADC              SignOnly8Bit		equ $80
   6+ 6ADC              SignOnly16Bit		equ $8000
   7+ 6ADC
   8+ 6ADC              Bit7Only            equ %10000000
   9+ 6ADC              Bit6Only            equ %01000000
  10+ 6ADC              Bit5Only            equ %00100000
  11+ 6ADC              Bit4Only            equ %00010000
  12+ 6ADC              Bit3Only            equ %00001000
  13+ 6ADC              Bit2Only            equ %00000100
  14+ 6ADC              Bit1Only            equ %00000010
  15+ 6ADC              Bit0Only            equ %00000001
  16+ 6ADC              Bit7Clear           equ %01111111
  17+ 6ADC              Bit6Clear           equ %10111111
  18+ 6ADC              Bit5Clear           equ %11011111
  19+ 6ADC              Bit4Clear           equ %11101111
  20+ 6ADC              Bit3Clear           equ %11110111
  21+ 6ADC              Bit2Clear           equ %11111011
  22+ 6ADC              Bit1Clear           equ %11111101
  23+ 6ADC              Bit0Clear           equ %11111110
  24+ 6ADC              ConstPi				equ $80
  25+ 6ADC              ConstNorm           equ 197
  26+ 6ADC              ;OpCodes
  27+ 6ADC              OpCodeSCF           equ $37
  28+ 6ADC              OpCodeCCF           equ $3F
  29+ 6ADC              OpCodeAndA          equ $A7
  30+ 6ADC              OpCodeClearCarryFlag equ OpCodeAndA
  31+ 6ADC
  32+ 6ADC              TidyInterval        equ 16
  33+ 6ADC
  34+ 6ADC              ;Text Tokens
  35+ 6ADC              EliteToken			equ $1E			; Token ID for text messsage ---- E L I T E ----
  36+ 6ADC              BrabenBellToken 	equ $0D
  37+ 6ADC              AcorToken			equ $0C
  38+ 6ADC              ; Cursor Bits
  39+ 6ADC              CursorClimb         equ %10000000
  40+ 6ADC              CursorDive          equ %01000000
  41+ 6ADC              CursorLeft          equ %00100000
  42+ 6ADC              CursorRight         equ %00010000
  43+ 6ADC              CursorHome          equ %00001000
  44+ 6ADC              CursorRecenter      equ %00000100
  45+ 6ADC
  46+ 6ADC              ; Intro Screen
  47+ 6ADC              TitleShip			equ	$8C
  48+ 6ADC              RotationUnity		equ $60
  49+ 6ADC              DBCheckCode			equ $DB
  50+ 6ADC              MaxVisibility		equ $1F
  51+ 6ADC              FarInFront			equ $C0
  52+ 6ADC              ; Equipment Flags
  53+ 6ADC              EquipmentItemFitted     equ $FF
  54+ 6ADC              EquipmentItemNotFitted  equ 0
  55+ 6ADC              ; Universe Managment
  56+ 6ADC              PlanetTypeMeridian      equ 128
  57+ 6ADC              PlanetMinRadius         equ 6
  58+ 6ADC
  59+ 6ADC              ShipTotalModelCount     equ 44
  60+ 6ADC              ShipTypeNormal          equ 0
  61+ 6ADC              ShipTypeMissile         equ 1
  62+ 6ADC              ShipTypeStation         equ 2
  63+ 6ADC              ShipTypeJunk            equ 3
  64+ 6ADC              ShipTypeScoopable       equ 4         ; a sub set of junk
  65+ 6ADC              ShipTypeTargoid         equ 5
  66+ 6ADC              ShipTypeUndefined1      equ 6
  67+ 6ADC              ShipTypeUndefined2      equ 7
  68+ 6ADC              ShipTypeUndefined3      equ 8
  69+ 6ADC              ShipTypeUndefined4      equ 9
  70+ 6ADC              ShipTypeUndefined5      equ 10
  71+ 6ADC              ShipTypeUndefined6      equ 11
  72+ 6ADC              ShipTypeUndefined7      equ 12
  73+ 6ADC              ShipTypeUndefined8      equ 13
  74+ 6ADC              ShipTypeUndefined9      equ 14
  75+ 6ADC              ShipTypeUndefined10      equ 15
  76+ 6ADC              ShipTypeNoAI            equ 16
  77+ 6ADC
  78+ 6ADC              ShipTypeText            equ 253
  79+ 6ADC              ShipTypeDebug           equ 254
  80+ 6ADC              ShipTypeEmpty           equ 255
  81+ 6ADC
  82+ 6ADC              SpawnTypeStation        EQU 0
  83+ 6ADC              SpawnTypeBodies         EQU SpawnTypeStation        + 1
  84+ 6ADC              SpawnTypeJunk           EQU SpawnTypeBodies         + 1
  85+ 6ADC              SpawnTypeCop            EQU SpawnTypeJunk           + 1
  86+ 6ADC              SpawnTypeTrader         EQU SpawnTypeCop            + 1
  87+ 6ADC              SpawnTypeNonTrader      EQU SpawnTypeTrader         + 1
  88+ 6ADC              SpawnTypePirate         EQU SpawnTypeNonTrader      + 1
  89+ 6ADC              SpawnTypeHunter         EQU SpawnTypePirate         + 1
  90+ 6ADC              SpawnTypeThargoid       EQU SpawnTypeHunter         + 1
  91+ 6ADC              SpawnTypeMission        EQU SpawnTypeThargoid       + 1
  92+ 6ADC              SpawnTypeStationDebris  EQU SpawnTypeMission        + 1
  93+ 6ADC              SpawnTypeMissionEvent   EQU SpawnTypeStationDebris  + 1
  94+ 6ADC              SpawnTypeDoNotSpawn     EQU SpawnTypeMissionEvent   + 1
  95+ 6ADC
  96+ 6ADC
  97+ 6ADC              ; Laser and Missile Settings
  98+ 6ADC              ; Laser and Missile
  99+ 6ADC              ShipLaserPower          equ %11110000
 100+ 6ADC              ShipMissileCount        equ %00001111
 101+ 6ADC              ShipMissiles1           equ %00000001
 102+ 6ADC              ShipMissiles2           equ %00000010
 103+ 6ADC              ShipMissiles3           equ %00000011
 104+ 6ADC              ShipMissiles4           equ %00000100
 105+ 6ADC              ShipMissiles5           equ %00000101
 106+ 6ADC              ShipMissiles6           equ %00000110
 107+ 6ADC              ShipMissiles7           equ %00000111
 108+ 6ADC              ShipMissiles8           equ %00001000
 109+ 6ADC              ShipMissiles9           equ %00001001
 110+ 6ADC              ShipMissiles10          equ %00001010
 111+ 6ADC              ShipMissiles11          equ %00001011
 112+ 6ADC              ShipMissiles12          equ %00001100
 113+ 6ADC              ShipMissiles13          equ %00001101
 114+ 6ADC              ShipMissiles14          equ %00001110
 115+ 6ADC              ShipMissiles15          equ %00001111
 116+ 6ADC              ; AI Flags  UniverseAIControl
 117+ 6ADC              ShipCanAnger            equ %10000000   ; Yes or no
 118+ 6ADC              ShipFighterBaySize      equ %01110000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 119+ 6ADC              ShipFighterBaySize1     equ %00010000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 120+ 6ADC              ShipFighterBaySize2     equ %00100000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 121+ 6ADC              ShipFighterBaySize3     equ %00110000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 122+ 6ADC              ShipFighterBaySize4     equ %01000000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 123+ 6ADC              ShipFighterBaySize5     equ %01010000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 124+ 6ADC              ShipFighterBaySizeInf   equ %01110000   ; Infinite fighters (well 255 as thats enough)
 125+ 6ADC              ShipFighterType         equ %00001100   ; 4 types 0 = Worm, 1 = Sidewinder, 2 = Viper, 3 = Thargon
 126+ 6ADC              ShipFighterWorm         equ %00000000
 127+ 6ADC              ShipFighterSidewinder   equ %00000100
 128+ 6ADC              ShipFighterViper        equ %00001000
 129+ 6ADC              ShipFighterThargon      equ %00001100
 130+ 6ADC              ShipUltraHostile        equ %00000010   ; If ultra hostile, will never back down so behaves like a missile
 131+ 6ADC              ShipFree                equ $00000011   ; Unused bits at present for later
 132+ 6ADC              ; NewBTactics
 133+ 6ADC              ShipIsTrader            equ Bit0Only   ; Trader flag  80% are peaceful 20% also have Bounty Hunter flag
 134+ 6ADC              ShipIsBountyHunter      equ Bit1Only   ;
 135+ 6ADC              ShipIsHostile           equ Bit2Only   ; Also used as Angry flag now
 136+ 6ADC              ShipIsPirate            equ Bit3Only   ;
 137+ 6ADC              ShipIsDocking           equ Bit4Only   ;
 138+ 6ADC              ShipIsBystander         equ Bit5Only   ;
 139+ 6ADC              ShipIsCop               equ Bit6Only   ;
 140+ 6ADC              ShipHasEscapePod        equ Bit7Only   ;
 141+ 6ADC              ShipHostileNewBitNbr    equ 2
 142+ 6ADC                      DISPLAY "TODO: Add bravery based on rank, new bits and type of ship"
 143+ 6ADC
 144+ 6ADC              ; UBnkaiatkecm
 145+ 6ADC              ;Unused                 equ Bit0Only
 146+ 6ADC              ;Unused                 equ Bit1Only
 147+ 6ADC              ;Unused                 equ Bit2Only
 148+ 6ADC              ShipIsDot               equ Bit3Only
 149+ 6ADC              ShipKilled              equ Bit4Only    ; Ship has just been marked as killed so initiate cloud of debris
 150+ 6ADC              ShipExploding           equ Bit5Only
 151+ 6ADC              ShipIsVisible           equ Bit6Only
 152+ 6ADC              ShipAIEnabled           equ Bit7Only   ;
 153+ 6ADC
 154+ 6ADC
 155+ 6ADC              ; UBnkaiakecm 2
 156+ 6ADC              ;ShipAngryNewBitNbr      equ 4
 157+ 6ADC              ShipExplosionDuration   equ 75         ; amount of frames an explosion lasts for
 158+ 6ADC              ShipNotHostile          equ Bit2Clear   ;
 159+ 6ADC              ShipIsNotDot            equ Bit3Clear
 160+ 6ADC              ShipIsDotBitNbr         equ 3
 161+ 6ADC              ShipKilledBitNbr        equ 4
 162+ 6ADC              ShipIsVisibleBitNbr     equ 6
 163+ 6ADC              ShipIsScoopDockEsc      equ Bit7Only   ;
 164+ 6ADC              ShipAIDisabled          equ Bit7Clear
 165+ 6ADC              ShipAIEnabledBitNbr     equ 7
 166+ 6ADC              ShipExplodingBitNbr     equ 5
 167+ 6ADC              ; Equipment Defaults
 168+ 6ADC              ECMCounterMax           equ $80
 169+ 6ADC              ; Main Loop State
 170+ 6ADC              StatePlayerDocked       equ $FF
 171+ 6ADC              StateCompletedLaunch    equ $FD
 172+ 6ADC              StateInTransition       equ $FE
 173+ 6ADC              StateHJumping           equ $FC
 174+ 6ADC              StateHEntering          equ $FB
 175+ 6ADC              StateCompletedHJump     equ $FA
 176+ 6ADC              StateNormal             equ 0
 177+ 6ADC              ; Missile Stage flags , $8x = locked to ship id x, $0x = fire at ship id x requested
 178+ 6ADC              StageMissileNotTargeting equ $FF
 179+ 6ADC              StageMissileTargeting   equ $FE
 180+ 6ADC
 181+ 6ADC
 182+ 6ADC              ShipMaxDistance     equ 192
 183+ 6ADC              HyperSpaceTimers    equ $0B0B
 184+ 6ADC
 185+ 6ADC              ; -- game limts
 186+ 6ADC              MaxNumberOfStars	equ 11
 187+ 6ADC              ConsoleRefreshInterval  equ 5
 188+ 6ADC              MaxJunkStation      equ 3
 189+ 6ADC              MaxJunkFreeSpace    equ 5
 190+ 6ADC              WarpCoolDownPeriod  equ 90
 191+ 6ADC
 192+ 6ADC              ShipTypeSize		equ	32 			;??????? just a guess for now
 193+ 6ADC              ShipSST				equ 4			; its a space station
 194+ 6ADC              UniverseBasePage 	equ 70			; Base memory bank for universe Item #0
 195+ 6ADC              ShipDataBasePage	equ	90			; Needs 2mb upgrade but what the heck
 196+ 6ADC              ShipCountMax		equ	2			; For now just 2 ships to debug
 197+ 6ADC              LineLimitPerShip	equ 70			; Max lines per ship
 198+ 6ADC              FaceLimitPerShip	equ	70			; Same as line limit to simplify some logic
 199+ 6ADC              ; "NEED TO DEFINE SHIPTYPESIZE TODO"
 200+ 6ADC
 201+ 6ADC              ; Memory page managment	(Refers to a memory slot as a place to access data)
 202+ 6ADC              ShipDataSlot		equ	6			; this may move into rom swap out space later
 203+ 6ADC              UniverseObjectSlot	equ	7
 204+ 6ADC
 205+ 6ADC              KeyForwardsView		equ	$20
 206+ 6ADC              ; Game specific equates
 207+ 6ADC              MissileDropHeight   equ 5           ; how far the missile is ejected on launch in y axis
 208+ 6ADC              WarpSequenceCount   equ 50
 209+ 6ADC
 210+ 6ADC              ;...Game Colour Mapping
 211+ 6ADC              L2DustColour        equ L2ColourGREY_1
 212+ 6ADC              L2SunScannerBright  equ 252
 213+ 6ADC              L2SunScanner        equ 180
 214+ 6ADC              L2DebrisColour      equ L2ColourYELLOW_1
 215+ 6ADC
 216+ 6ADC
 217+ 6ADC              ; Ship Data
 218+ 6ADC              ;;;;	.XX21	\ -> &5600 \ Table of pointers to ships' data given to XX0
 219+ 6ADC              ;;;;00 7F			 EQUW &7F00 \ type  1 is #MSL  Missile data on page off bottom of screen
 220+ 6ADC              ;;;;00 00			 EQUW 0     \ type  2 is #SST  Space Station, Coriolis or Dodo.
 221+ 6ADC              ;;;;00 00			 EQUW 0     \ type  3 is #ESC  Escape capsule
 222+ 6ADC              ;;;;00 00			 EQUW 0     \ type  4 is #PLT  Plate, alloys
 223+ 6ADC              ;;;;00 00			 EQUW 0     \ type  5 is #OIL  Cargo cannister
 224+ 6ADC              ;;;;00 00			 EQUW 0     \ type  6 is       Boulder
 225+ 6ADC              ;;;;00 00			 EQUW 0     \ type  7 is #AST  Asteroid
 226+ 6ADC              ;;;;00 00			 EQUW 0     \ type  8 is #SPL  Splinter, rock.
 227+ 6ADC              ;;;;00 00			 EQUW 0     \ type  9 is #SHU  Shuttle
 228+ 6ADC              ;;;;00 00			 EQUW 0     \ type 10 is       Transporter
 229+ 6ADC              ;;;;00 00			 EQUW 0     \ type 11 is #CYL  Cobra Mk III,  Boa
 230+ 6ADC              ;;;;00 00			 EQUW 0     \ type 12 is       Python
 231+ 6ADC              ;;;;00 00			 EQUW 0     \ type 13 is       Last of three traders
 232+ 6ADC              ;;;;00 00			 EQUW 0     \ type 14 is #ANA  Anaconda
 233+ 6ADC              ;;;;00 00			 EQUW 0     \ type 15 is #WRM  Worm with Anaconda
 234+ 6ADC              ;;;;00 00			 EQUW 0     \ type 16 is #COP  Viper
 235+ 6ADC              ;;;;00 00			 EQUW 0     \ type 17 is       First pirate
 236+ 6ADC              ;;;;00 00			 EQUW 0     \ type 18 is
 237+ 6ADC              ;;;;00 00			 EQUW 0     \ type 19 is #KRA  Krait small pirate
 238+ 6ADC              ;;;;00 00			 EQUW 0     \ type 20 is #ADA  Adder
 239+ 6ADC              ;;;;00 00			 EQUW 0     \ type 21 is
 240+ 6ADC              ;;;;00 00			 EQUW 0     \ type 22 is
 241+ 6ADC              ;;;;00 00			 EQUW 0     \ type 23 is
 242+ 6ADC              ;;;;00 00			 EQUW 0     \ type 24 is #CYL2 Last strong pirate
 243+ 6ADC              ;;;;00 00			 EQUW 0     \ type 25 is #ASP  Asp Mk II
 244+ 6ADC              ;;;;00 00			 EQUW 0     \ type 26 is #FER  Fer de Lance
 245+ 6ADC              ;;;;00 00			 EQUW 0     \ type 27 is
 246+ 6ADC              ;;;;00 00			 EQUW 0     \ type 28 is	Last of three bounty hunters
 247+ 6ADC              ;;;;00 00			 EQUW 0     \ type 29 is #THG  Thargoid
 248+ 6ADC              ;;;;00 00			 EQUW 0     \ type 30 is #TGL  Thargon
 249+ 6ADC              ;;;;00 00			 EQUW 0     \ type 31 is #CON  Constrictor
 250+ 6ADC              ;;;;	.E%	\ -> &563E \ Hull NEWB bits are escpod, cop, inno, ?, pirate, angry, hunter, trader.
 251+ 6ADC              ;;;;			\ NEWB examples
 252+ 6ADC              ;;;;\ 21			EQUB &21    \ 0010 0001    9 Shuttle has no escape pod, inno, trader.
 253+ 6ADC              ;;;;\ 61			EQUB &61    \ 0110 0001   10 Tansporter no escape pod, Cop, inno, trader.
 254+ 6ADC              ;;;;\ A0			EQUB &A0    \ 1010 0000   11 Cobra has Escape pod, inno, not a trader.
 255+ 6ADC              ;;;;\ C2			EQUB &C2    \ 1100 0010   16 Viper has Escape pod, Cop, hunter.
 256+ 6ADC              ;;;;\ 8C			EQUB &8C    \ 1000 1100   19 Krait pirate has escape pod, is pirate and angry.
 257+ 6ADC
# file closed: ../../Variables/constant_equates.asm
1340  6ADC                  INCLUDE "../../Variables/general_variables.asm"
# file opened: ../../Variables/general_variables.asm
   1+ 6ADC                  IFNDEF LASER_V2
   2+ 6ADC                  DEFINE  LASER_V2    1
   3+ 6ADC                  ENDIF
   4+ 6ADC              ; Debugging data
   5+ 6ADC 00 00 00...  failureDiag DS  10              ; 10 bytes to log data before a failure
   6+ 6AE6
   7+ 6AE6              LogFailure:     MACRO messageAddress
   8+ 6AE6 ~                            ld      hl,messageAddress
   9+ 6AE6 ~                            ld      de,failureDiag
  10+ 6AE6 ~                            ld      bc,10
  11+ 6AE6 ~                            ldir
  12+ 6AE6                              ENDM
  13+ 6AE6              ;-- Memory management variables
  14+ 6AE6 00 00 00...  SaveMMU0Queue:          DS      5                   ; Allows up to 5 levels of depth for queue stacking
  15+ 6AEB 00 00 00...  SaveMMU6Queue:          DS      5                   ; Allows up to 5 levels of depth for queue stacking
  16+ 6AF0 00 00 00...  SaveMMU7Queue:          DS      5                   ; Allows up to 5 levels of depth for queue stacking
  17+ 6AF5              ;-- Note these are not counters but initialised to memory locations to simplify code
  18+ 6AF5              ;-- Point to the next free memory location to write to
  19+ 6AF5 E6 6A        SaveMMU0QueueHead:      DW      SaveMMU0Queue       ; Current last saved MMU Entry
  20+ 6AF7 EB 6A        SaveMMU6QueueHead:      DW      SaveMMU6Queue       ; Current last saved MMU Entry
  21+ 6AF9 F0 6A        SaveMMU7QueueHead:      DW      SaveMMU7Queue       ; Current last saved MMU Entry
  22+ 6AFB
  23+ 6AFB 00 00        varAxis1	DW 	0				; address of first axis in a rotation action
  24+ 6AFD 00 00        varAxis2	DW	0				; address of 2nd axis in a roation action
  25+ 6AFF              ; Variables to simulate 6502 registers until code fixed
  26+ 6AFF              ; These must be here in this order as reading Y and X can then be a 16 bit read
  27+ 6AFF 00           regX		DB	0               ; using 16 bit read into BC this would go into C
  28+ 6B00 00           regY		DB	0               ; using 16 bit read into BC this would go into B
  29+ 6B01 00           regA		DB	0
  30+ 6B02
  31+ 6B02
  32+ 6B02 00           varGPLoopA	DB	0				; General Purpose innermost loop variable
  33+ 6B03 00 00        INF			DW	0				; page 0 &20 Used to get address from UNIV array
  34+ 6B05 00 00        INF28		DW	0				; page 0 &20 Used to get address from UNIV array
  35+ 6B07
  36+ 6B07
  37+ 6B07
  38+ 6B07              ;XX16		DS	16				; 16 byte Matrix
  39+ 6B07
  40+ 6B07              P0INWK							; page 0 & 46
  41+ 6B07              p0INWK31						; page 0 & 65
  42+ 6B07              P0INWK36						; PAGE 0 &6A
  43+ 6B07
  44+ 6B07 00           XX4			DB	0				; XX4 page 0 &96 last Normal Found to be visible
  45+ 6B08              LastNormalVisible	equ	XX4
  46+ 6B08              varXX4              equ XX4
  47+ 6B08
  48+ 6B08
  49+ 6B08
  50+ 6B08 00           PATG		DB	0				; 6502 &03C9
  51+ 6B09 00 00        SLSP 		DW	0				; &03B0 \ SLSP \ ship lines pointer
  52+ 6B0B
  53+ 6B0B
  54+ 6B0B              ;UNIV		DS FreeListSize*2	; Array of Universe Pointers
  55+ 6B0B              ;HULLINDEX	DS ShipTypeSize*2	; hull index for table at XX21= &F XX21-1,Y
  56+ 6B0B
  57+ 6B0B              ; Present System Variables
  58+ 6B0B
  59+ 6B0B 2B           RandomSeed				DB	43			    ; 00 DEBUG JUST SOME START VALUES
  60+ 6B0C 20           RandomSeed1				DB	32	            ; 01
  61+ 6B0D 0C           RandomSeed2				DB	12			    ; 02
  62+ 6B0E 42           RandomSeed3				DB	66			    ; 03
  63+ 6B0F 00 00 00 00  RandomSeedSave          DS  4               ; used in explosion routine to save randoms
  64+ 6B13 00           varT1					DB	0				; 06
  65+ 6B14 00           SClo					DB 0				; 07
  66+ 6B15 00           SChi					DB 0				; 08
  67+ 6B16 00           varP					DB 0 				; 10	XX16+7
  68+ 6B17 00           varPhi					DB 0 				; 11	XX16+8
  69+ 6B18 00           varPhi2					DB 0 				; 12	XX16+9
  70+ 6B19 00           varPhiSign              DB 0
  71+ 6B1A              varPp1                  equ varPhi
  72+ 6B1A              varPp2                  equ varPhi2
  73+ 6B1A              varPp3                  equ varPhiSign
  74+ 6B1A 00           UnivPointerLo			DB	0				; 20		INF                 XX0+2
  75+ 6B1B 00           UnivPointerHi			DB	0				; 21      INF+1               XX0+3
  76+ 6B1C              UnivPointer				equ	UnivPointerLo
  77+ 6B1C 00           varV					DB 0				; 22                          XX0+4
  78+ 6B1D 00           varVHi					DB 0				; 23                          XX0+5
  79+ 6B1E 00           varXXlo                 DB 0                ; 24
  80+ 6B1F 00           varXXHi                 DB 0                ; 25
  81+ 6B20              varXX					equ	varXXlo
  82+ 6B20 00           YYlo                    DB 0                ; 26
  83+ 6B21 00           YYHi                    DB 0                ; 27
  84+ 6B22              varYY					equ	YYlo
  85+ 6B22              											;	28
  86+ 6B22              											;	29
  87+ 6B22              ;PlayerShipPositionData - Must be contiguous for setup
  88+ 6B22 00           BETA 					DB	0               ; 2A        (pitch done)
  89+ 6B23 00           JSTY                    DB  0               ; Joystick analog
  90+ 6B24 00           BET1 					DB	0               ; 2B        lower7 magnitude
  91+ 6B25 00           BET2                    DB  0               ;            climb sign
  92+ 6B26 00           BET2FLIP				DB	0				; 7C		BET 2 pitch Sign negated
  93+ 6B27 1F           BET1MAXC                DB  31              ; max climb
  94+ 6B28 E1           BET1MAXD                DB  -31             ; max dive
  95+ 6B29 00           XC						DB	0               ; 2C
  96+ 6B2A 00           YC						DB 	0               ; 2D
  97+ 6B2B              ;... ECM logic. If another ship adds ECM then we just set the loop A and B to starting values so they overlap
  98+ 6B2B 00           ECMCountDown            DB  0
  99+ 6B2C 00           ECMLoopB                DB  0
 100+ 6B2D 00 00        JSTX                    DW  0               ;           Joystick analog value
 101+ 6B2F 00           ALPHA					DB	0				; 8D        Alpha with bit 7 sign
 102+ 6B30 00           ALP1					DB 	0				; 31		ALP1	ABS Alpha
 103+ 6B31 00           ALP2					DB  0				; 32		ALP2	Roll Sign
 104+ 6B32 00           ALP2FLIP				DB  0				; 33		ALP2	negated roll sign
 105+ 6B33 1F           ALP1MAXR                DB  31               ;   Maximum roll, added becuase we may allow different ship types
 106+ 6B34 E1           ALP1MAXL                DB  -31             ;   Maximum roll, added becuase we may allow different ship types
 107+ 6B35
 108+ 6B35
 109+ 6B35              ;-- Message handler -----------------------------------------------------------------------------------------------------------------
 110+ 6B35              MAXMESSAGES             EQU 5
 111+ 6B35              MESSAGETIMELIMIT        EQU 20
 112+ 6B35              MESSAGESIZE             EQU 33
 113+ 6B35              MESSAGELINE             EQU $0001
 114+ 6B35
 115+ 6B35 00           MessageCount            DB  0                ; used for enquing messages later
 116+ 6B36 00           MessageCurrent          DB  0
 117+ 6B37 05 00        MessageIndex            DW  MAXMESSAGES
 118+ 6B39 00 00 00...  MessageQueue            DS  MAXMESSAGES * MESSAGESIZE
 119+ 6BDE 05           MessageTimeout          DB  MAXMESSAGES
 120+ 6BDF 00 00 00...  IndexedWork				DS	37				; General purpose work space when doing temp arrays
 121+ 6C04
 122+ 6C04              ; MOVED TO Universe XX19					DB	0				; page 0 &67
 123+ 6C04              ; MOVED TO Universe XX20					DB	0				; page 0 &67 also used as XX19+1 for XX19 being a word
 124+ 6C04              ;DEFUNCT EQUATE NormalCountCopyBy4		equ	XX20			; Also used for normal * 4 holding variable
 125+ 6C04 00           XX21					DB  0				; this may be part of XX20/xx21 accordign to spawn new shipXX21		DW	0				; Ah XX21 is hull pointer  hull pointer lo as it can;t hold HULLINDX as 16bit array
 126+ 6C05              ;XX21 is the pointer table to the pages for ship types. this will be repalaced by paging so just need an equate for first page
 127+ 6C05
 128+ 6C05
 129+ 6C05 00           QQ17					DB	0				;   72
 130+ 6C06 00           XX18xlo                 DB  0               ;	72		XX18   xlo
 131+ 6C07 00           XX18xhi                 DB  0               ;	73		XX18+1 xhi
 132+ 6C08 00           XX18xsg                 DB  0               ;	74		XX18+2 xsgn
 133+ 6C09 00           XX18ylo                 DB  0               ;	75		XX18   ylo
 134+ 6C0A 00           XX18yhi                 DB  0               ;	76		XX18+1 yhi
 135+ 6C0B 00           XX18ysg                 DB  0               ;	77		XX18+2 ysgn
 136+ 6C0C 00           XX18zlo                 DB  0               ;	78		XX18   zlo
 137+ 6C0D 00           XX18zhi                 DB  0               ;	79		XX18+1 zhi
 138+ 6C0E 00           XX18zsg                 DB  0               ;	7A		XX18+2 zsgn
 139+ 6C0F
 140+ 6C0F 28           SHIPMAXSPEED            DB  40              ; variable to facilitate ship editing later
 141+ 6C10 00           DELTA					DB 	0				; 7D 		DELTA  \ bpl -2 inserted here to stall from title code if byte check fails
 142+ 6C11 00           DELT4Lo					DB 	0				; 7E
 143+ 6C12 00           DELT4Hi					DB 	0				; 7F
 144+ 6C13              DELTA4                  equ                 DELT4Lo
 145+ 6C13
 146+ 6C13              ; SoundFX Variables -------------------------------------------------------------------------------------------
 147+ 6C13              ;DEFUNCT, uses DELTA/ LAST_DELTAEngineSoundChanged:     DB  0
 148+ 6C13 FF           SoundFxToEnqueue        DB  $FF             ; $FF No sound to enque,if it is $FF then next sound will not get enqued
 149+ 6C14 00           InterruptCounter        DB 0                ; simple marker updated once per IM2 event
 150+ 6C15
 151+ 6C15
 152+ 6C15              ; Not thise must be in this order else 16 bit fetches will fail
 153+ 6C15 00           varU                    DB  0               ;   80
 154+ 6C16 00           varQ					DB  0 				;	81
 155+ 6C17 00           varR					DB  0 				;	82
 156+ 6C18 00           varS					DB  0 				;	83
 157+ 6C19              varRS                   equ varR
 158+ 6C19
 159+ 6C19 00 00        varU16                  DW  0               ; 16 bit variant on varU as I can't use above for this
 160+ 6C1B
 161+ 6C1B 00           XSAV					DB	0				; 84	   XSAV usef for nearby ship count outer
 162+ 6C1C 00           YSAV                    DB  0               ; 85
 163+ 6C1D 00           XX17					DB	0				; 86
 164+ 6C1E              RequiredScale			equ  XX17			; use to hold calculated scale in drawing ship
 165+ 6C1E              varXX17                 equ  XX17
 166+ 6C1E 00           ScreenChanged           DB  0
 167+ 6C1F 00           ScreenIndex             DB  0
 168+ 6C20 00 00        ScreenIndexTablePointer DW  0
 169+ 6C22 00           InvertedYAxis           DB  0
 170+ 6C23 00           MenuIdMax				DB	0				;	87		MenuIdMax		QQ11
 171+ 6C24              											; Bit 7 Set  ShortRangeChart    $80
 172+ 6C24              											; Bit 6 Set  Galactic Chart     $40
 173+ 6C24              											; Bit 5 Set  Market Place       $20
 174+ 6C24              											; Bit 4 Set  Status Screen      $10
 175+ 6C24              											; Bit 3 Set  Display Inventory  $08
 176+ 6C24                                                          ; Bit 2 Set  Planet Data        $04
 177+ 6C24                                                          ; View bit combinations if the ones above not matched
 178+ 6C24                                                          ; bits 1 0
 179+ 6C24                                                          ;      1 1  Front view , i.e. $03
 180+ 6C24                                                          ;      1 0  Aft View          $02
 181+ 6C24                                                          ;      0 1  Left View         $01
 182+ 6C24                                                          ;      0 0  Right view        $00
 183+ 6C24              											; Bit 0 Set  Data On System
 184+ 6C24              											; 0  Space View (Not a menu)
 185+ 6C24 00           ZZDust					DB	0				;	88		ZZDust (Poss 16 bit need to check)
 186+ 6C25 00           XX13                    DB  0               ;   89
 187+ 6C26 00           TYPE					DB	0				; 8C used for ship type in drawing
 188+ 6C27              ;Docked flag = 00 = in free space
 189+ 6C27              ;              FF = Docked
 190+ 6C27              ;              FE = transition
 191+ 6C27              ;              FD = Setup open space and transition to not docked
 192+ 6C27              ;              FC = Hyperspace manimation
 193+ 6C27              ;              FB = Hyperspace complete
 194+ 6C27 00           varSWAP                 DB  0               ; 90 , general purpose swap variable
 195+ 6C28 00           varCNT                  DB  0               ; 93
 196+ 6C29
 197+ 6C29 00           varK					DB	0				; 40
 198+ 6C2A 00           varKp1					DB	0				; 41
 199+ 6C2B 00           varKp2					DB	0				; 42
 200+ 6C2C 00           varKp3					DB	0				; 43
 201+ 6C2D
 202+ 6C2D 00           varK2                   DB  0               ; 9B
 203+ 6C2E 00           varK2p1                 DB  0               ; 9C K2 plus 1
 204+ 6C2F 00           varK2p2                 DB  0               ; 9D K2 plus 2
 205+ 6C30 00           varK2p3                 DB  0               ; 9E K2 plus 3
 206+ 6C31
 207+ 6C31 00           Point                   DB  0               ; 9F      POINT
 208+ 6C32
 209+ 6C32 00           varT					DB	0				; D1
 210+ 6C33 00           varTSign                DB  0               ; for teh odd need for a 16 bit varT
 211+ 6C34
 212+ 6C34 00 00 00...  varVector9ByteWork      DS  9
 213+ 6C3D
 214+ 6C3D 00 00 00 00  varK3					DS	4				; D2
 215+ 6C41 00           varK3p2					DB	0				; 42
 216+ 6C42 00           varK3p3					DB	0				; 43
 217+ 6C43              varK3p1					equ varK3+1			; D3
 218+ 6C43 00 00 00 00  varK4					DS	4				; E0
 219+ 6C47              varK4p1					equ varK4+1			; D3
 220+ 6C47 00 00 00...  varK5                   DS  6
 221+ 6C4D              varK5p2                 equ varK5+2
 222+ 6C4D 00 00 00...  varK6                   DS  6
 223+ 6C53              varK6p2                 equ varK6+2
 224+ 6C53              ;Heap
 225+ 6C53
 226+ 6C53 00 00        HeapStart				DS	2				; &0100 XX3 50 bytes for now
 227+ 6C55 00 00 00...  HeapData				DS	50
 228+ 6C87              ; Contains 				X 16 bit, Y ;MissileArmedStatus		DB	0				; 0344 MSAR   using MissileTarget, if missile is not armed tehn target is FF
 229+ 6C87              ; TODO will need an read for a list of missiles, who they are targeting an the target current vector for AI persuit
 230+ 6C87              ; i.e. a list of programmed missiles in universe slot list code
 231+ 6C87 00 00 00...  DampingKeys				DS  7				; 0387 - 038D
 232+ 6C8E              ;  #&6 Does K toggle keyboard/joystick control -  03CD certainly makes keyboard not work anymore.
 233+ 6C8E              ;  #&5 Does J reverse both joystick channels
 234+ 6C8E              ;  #&4 Does Y reverse joystick Y channel			03CB
 235+ 6C8E              ;  #&2 Does X toggle startup message display ? PATG?	03C9
 236+ 6C8E              ;  #&3 Does F toggle flashing information			03CA
 237+ 6C8E              ;  #&1 Does A toggle keyboard auto-recentering ?
 238+ 6C8E              ;  #&0 Caps-lock toggles keyboard flight damping
 239+ 6C8E
 240+ 6C8E              ;-- Galaxy and Universe Variables ----------------------------------------------------------------------------------------------------
 241+ 6C8E 00 00 00...  SystemSeed				DS  5				;	6C		QQ15	Current Galaxy Seed
 242+ 6C93 00 00 00...  StockAvaliabiliy		DS 	16				; 038D - 039C Stock inventory in station
 243+ 6CA3 00           AlienItemsAvaliability  DB	0				; 039D
 244+ 6CA4 00           RandomMarketSeed		DB	0				; 039E   \ QQ26	\ random byte for each system vist (for market)
 245+ 6CA5 00           Galaxy      			DB	0				; 0367 Galaxy (incremented with galactiv drive
 246+ 6CA6 00 00 00...  WorkingSeeds			DS	6
 247+ 6CAC 00 00 00...  PresentSystemSeeds		DS	6				; 03B2 - 03B7
 248+ 6CB2 00 00 00...  GalaxySeeds				DS	6				; 035B - 0360 QQ21
 249+ 6CB8 00           PresentSystemX			DB	0				; System we are currently in
 250+ 6CB9 00           PresentSystemY			DB  0				; System we are currently in
 251+ 6CBA 00           TargetSystemX			DB	0				; System we are targeting for jump
 252+ 6CBB 00           TargetSystemY			DB	0				; System we are targeting for jump
 253+ 6CBC              ; --- Current System Data ------------------------------------------------------------------------------------------------------------
 254+ 6CBC 00           GovPresentSystem		DB	0				; 03AE Govenment
 255+ 6CBD 00           TekPresentSystem		DB	0				; 03AF Technology
 256+ 6CBE 00           SpaceStationSafeZone    DB  0               ; Flag to determine if we are in safe zone
 257+ 6CBF 00           ExtraVesselsCounter     DB  0
 258+ 6CC0 00           JunkCount				DB  0				; $033E
 259+ 6CC1 00           AsteroidCount           DB  0               ; Not used as yet
 260+ 6CC2 00           TransporterCount        DB  0
 261+ 6CC3 00           CopCount                DB  0
 262+ 6CC4 00           PirateCount             DB  0
 263+ 6CC5              ;- commander and ship state variables ------------------------------------------------------------------------------------------------
 264+ 6CC5 00           NbrMissiles				DB	0				; 038B	Does this clash with Dampingkeys?
 265+ 6CC6 00           PlayerECMActiveCount    DB  0               ; Countdown for player ECM
 266+ 6CC7 00           FugitiveInnocentStatus	DB	0				; 038C	FIST
 267+ 6CC8 00 00        KillTally  				DW	0				; 039F - 03A0 \ TALLY   \ kills lo hi
 268+ 6CCA 00           CurrentRank             DB  0   			;
 269+ 6CCB 00           MarketPrice				DB	0				; 03AA QQ24
 270+ 6CCC 00           MaxStockAvaliable		DB  0				; 03AB   \ QQ25     \ max available
 271+ 6CCD 00           SystemEconomy			DB  0				; 03AC \ QQ28   \ the economy byte of present system (0 is Rich Ind.)
 272+ 6CCE 00           CargoItem				DB	0				; 03AD (I think its item type just scooped) QQ29
 273+ 6CCF 00 00        ShipLineStackPointer	DW	0				; 03B0 & 03B1 ship Lines pointer reset to top LS% = &0CFF (make DW for z80 and direct hl pointer)
 274+ 6CD1              											; this is ship lines stack pointer so may be redundant with paging
 275+ 6CD1              											; LS = line stack so we will have one for now to remove later
 276+ 6CD1              ; - no longer used, holding here intil its safe to delte
 277+ 6CD1 00           MCH						DB	0				; 03A4  \ MCH  \ old message to erase
 278+ 6CD2 00           COMP     				DB	0				; 03A1 2nd competion byte used for save integrity checks?
 279+ 6CD3              ; not needed as we don't do security on file COK						DB	0				; 0366 Competition Byte what ? Does some file check and accelleration check
 280+ 6CD3              ; - no longer used, holding here intil its safe to delte
 281+ 6CD3
 282+ 6CD3 00           DisplayEcononmy			DB	0				; 03B8
 283+ 6CD4 00           DisplayGovernment		DB  0				; 03B9 Is it target? 03B9 \ QQ4	 \ Government, 0 is Anarchy.
 284+ 6CD5 00           DisplayTekLevel			DB	0				; 03BA   \ QQ5	\ Tech
 285+ 6CD6 00 00        DisplayPopulation		DW	0				; 03BB \ QQ6  \ population*10
 286+ 6CD8 00 00        DisplayProductivity		DW	0				; 03BD \ QQ7   \ productivity*10
 287+ 6CDA 00 00        Distance          		DW	0				; 03BE \ QQ8 distince in 0.1LY units
 288+ 6CDC 00 00        DisplayRadius			DW	0
 289+ 6CDE              ; --- Used in creation of sun and planet and working out ship AI for travel direction ---------------------------------------------------
 290+ 6CDE 00 00 00     ParentPlanetX           DS  3               ; used when spawining space station to determine origin
 291+ 6CE1 00 00 00     ParentPlanetY           DS  3               ; provisioned for 24 bit values
 292+ 6CE4 00 00 00     ParentPlanetZ           DS  3               ; probably later on make station position an equate to planet
 293+ 6CE7 00 00 00     PlanetXPos              DS  3               ; .
 294+ 6CEA 00 00 00     PlanetYPos              DS  3               ; .
 295+ 6CED 00 00 00     PlanetZPos              DS  3               ; .
 296+ 6CF0 00 00 00     PlanetType              DS  3               ; .
 297+ 6CF3 00 00 00     SunXPos                 DS  3               ; .
 298+ 6CF6 00 00 00     SunYPos                 DS  3               ; .
 299+ 6CF9 00 00 00     SunZPos                 DS  3               ; .
 300+ 6CFC 00 00 00     StationXPos             DS  3               ; .
 301+ 6CFF 00 00 00     StationYPos             DS  3               ; .
 302+ 6D02 00 00 00     StationZPos             DS  3               ; .
 303+ 6D05 00 00        DirectionVectorX        DS  2               ; Direction vector from one point to another
 304+ 6D07 00 00        DirectionVectorY        DS  2               ; .
 305+ 6D09 00 00        DirectionVectorZ        DS  2               ; .
 306+ 6D0B              ; -- Current Missile Runbtime data ------------------------------------------------------------------------------------------------
 307+ 6D0B 00           CurrentMissileBank:     DB      0                                   ; used by missile logic as local copy of missile bank number
 308+ 6D0C 00 00        MissileXPos             DW      0
 309+ 6D0E 00           MissileXSgn             DB      0
 310+ 6D0F 00 00        MissileYPos             DW      0
 311+ 6D11 00           MissileYSgn             DB      0
 312+ 6D12 00 00        MissileZPos             DW      0
 313+ 6D14 00           MissileZSgn             DB      0
 314+ 6D15 00 00        CurrentTargetXpos       DS      2
 315+ 6D17 00 00        CurrentTargetXsgn       DS      2
 316+ 6D19 00 00        CurrentTargetYpos       DS      2
 317+ 6D1B 00 00        CurrentTargetYsgn       DS      2
 318+ 6D1D 00 00        CurrentTargetZpos       DS      2
 319+ 6D1F 00 00        CurrentTargetZsgn       DS      2
 320+ 6D21 00 00        TargetVectorXpos        DS      2
 321+ 6D23 00           TargetVectorXsgn        DS      1
 322+ 6D24 00 00        TargetVectorYpos        DS      2
 323+ 6D26 00 00        TargetVectorYsgn        DS      2
 324+ 6D28 00 00        TargetVectorZpos        DS      2
 325+ 6D2A 00 00        TargetVectorZsgn        DS      2
 326+ 6D2C 00           CurrentMissileBlastRange:      DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 327+ 6D2D 00           CurrentMissileBlastDamage:     DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 328+ 6D2E 00           CurrentMissileDetonateRange:   DB  0                       ; TODO Initi for runtime copied in when setting up a missile, allows for proximity missiles
 329+ 6D2F 00           CurrentMissileDetonateDamage:  DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 330+ 6D30              ; --- Spawn Probability Table ---------------------------------------------------------------------------------------------------
 331+ 6D30 00 00 00...  SpawnLowVssalue         DS 6                                ; Maxium of 6 entries in table
 332+ 6D36 00 00 00...  SpawnHighvalue          DS 6                                ; Maxium of 6 entries in table
 333+ 6D3C 00 00 00...  ShipClassId             DS 6
 334+ 6D42              ; --- Space dust ----------------------------------------------------------------------------------------------------------------
 335+ 6D42 00 00 00...  varDustWarpRender       DS MaxNumberOfStars * 2 ; Copy of base positions for warp
 336+ 6D58 00 00 00...  varDust                 DS MaxNumberOfStars * 6
 337+ 6D9A 00 00 00...  varDustSceen            DS MaxNumberOfStars * 2 ; To optimise star list to wipe from screen
 338+ 6DB0 00           varStarX                DB 0
 339+ 6DB1 00           varStarY                DB 0
 340+ 6DB2 00 00 00...  varDustX                DS MaxNumberOfStars *2
 341+ 6DC8 00 00 00...  varDustY                DS MaxNumberOfStars *2
 342+ 6DDE 00 00 00...  varDustZ                DS MaxNumberOfStars *2
 343+ 6DF4              ; --- Main Loop Data -------------------------------------------------------------------------------------------------------------
 344+ 6DF4 00           DockedFlag				DB	0				; 8E -
 345+ 6DF5 00           GamePaused              DB  0
 346+ 6DF6 00           CurrentUniverseAI       DB  0               ; current ship unviverse slot due an AI update
 347+ 6DF7 00           SelectedUniverseSlot    DB  0
 348+ 6DF8 00           SetStationHostileFlag   DB  0               ; used to semaphore angry space station
 349+ 6DF9 00           ShipBlastCheckCounter   DB  0
 350+ 6DFA 00           InnerHyperCount			DB 	0				; 2F QQ22+1 (will move to a CTC timer later)
 351+ 6DFB 00           OuterHyperCount			DB 	0				; 2E QQ22
 352+ 6DFC 00           WarpCooldown            DB  0
 353+ 6DFD 00           EventCounter            DB  0
 354+ 6DFE 00           HyperCircle             DB  0
 355+ 6DFF 00           MissJumpFlag            DB  0
 356+ 6E00 00           PlayerMisJump			DB	0				; $0341 witchspace misjump
 357+ 6E01 00           HyperSpaceFX			DB	0				; 0348 HFX (probabyl BBC specific
 358+ 6E02 00           ExtraVessels			DB	0				; 0349 EV Use d by cops, extra vessels still to spawn?
 359+ 6E03 00           Delay					DB	0				; 034A Delay general purpose eg. spawing EV or when printign messages
 360+ 6E04 00           CurrentMissileCheck:    DB  0               ; if > Universe Slot list then free for next missile
 361+ 6E05 00           MessageForDestroyed		DB	0				; 034B Message flag for item + destroyed
 362+ 6E06              UniverseSlotListSize    equ	12
 363+ 6E06 00 00 00...  UniverseSlotList        DS  UniverseSlotListSize
 364+ 6E12 00 00 00...  UniverseSlotType        DS  UniverseSlotListSize ; base type, e.g. missile, cargo etc,
 365+ 6E1E              ; Probably not needed UniverseTypeCount       DS  UniverseSlotListSize
 366+ 6E1E 05           ConsoleRefreshCounter   DB  ConsoleRefreshInterval ; Every 4 interations the console will update twice (once for primary and once for seconday buffer)
 367+ 6E1F 00           ConsoleRedrawFlag       DB  0
 368+ 6E20 00           TextInputMode           DB  0
 369+ 6E21 00           CursorKeysPressed       DB  0               ; mapping of the current key presses
 370+ 6E22                                                          ; 7    6    5    4     3    2        1    0
 371+ 6E22                                                          ; Up   Down Left Right Home Recentre
 372+ 6E22 00           FireLaserPressed        DB  0
 373+ 6E23 00           WarpPressed             DB  0
 374+ 6E24 00           CompassColor			DB	0				; 03C5
 375+ 6E25 00           SoundToggle				DB	0				; 03C6
 376+ 6E26 00           KeyboardRecenterToggle	DB	0				; 03C8
 377+ 6E27 00           PATGMask				DB	0				; &03C9    \ PATG	\ Mask to scan keyboard X-key, for misjump
 378+ 6E28 00           FlashToggle				DB  0				; 03CA \ FLH \ flash toggle
 379+ 6E29 00           ReverseJoystick			DB	0				; 03CB \ JSTGY \ Y reverse joystick Y channel
 380+ 6E2A 00           JoystickToggle			DB	0				; 03CD  \ JSTK    \ K toggle keyboard/joystick
 381+ 6E2B 00           DigitalJoystick			DB	0				; 03CE \ JDB   \ . = toggle between keyboard and bitpaddle
 382+ 6E2C 00           DiskReadFailFlag		DB	0				; 03CF \ CATF \ Disk catalog fail flag
 383+ 6E2D
 384+ 6E2D              ; Working Data
 385+ 6E2D
 386+ 6E2D              ;UniverseTable			DS	26				; 1741  \ address pointers for 13 ships INF on pages &9. 37 bytes each.
 387+ 6E2D              ; $0900 =	EQUW page9+37* 0 \ copied to inner worskpace INWK on zero-page when needed
 388+ 6E2D              ; $0925 =	EQUW page9+37* 1
 389+ 6E2D              ; $094A =	EQUW page9+37* 2
 390+ 6E2D              ; $096F =	EQUW page9+37* 3
 391+ 6E2D              ; $0994 =	EQUW page9+37* 4
 392+ 6E2D              ; $09B9 =	EQUW page9+37* 5
 393+ 6E2D              ; $09DE =	EQUW page9+37* 6
 394+ 6E2D              ; $0A03 =	EQUW page9+37* 7
 395+ 6E2D              ; $0A28 =	EQUW page9+37* 8
 396+ 6E2D              ; $0A4D =	EQUW page9+37* 9
 397+ 6E2D              ; $0A72 =	EQUW page9+37*10
 398+ 6E2D              ; $0A97 =	EQUW page9+37*11
 399+ 6E2D              ; $0ABC =	EQUW page9+37*12 \ allwk up to &0ABC while heap for edges working down from &CFF.
 400+ 6E2D
 401+ 6E2D
 402+ 6E2D
 403+ 6E2D              ; 0b00 is start address of data to save
 404+ 6E2D              ; Now MissionData VarTP					DB	0				; 0358 TP? The Plan  \ mission uses lower 4 bits
 405+ 6E2D              											; Bit mask XXXX10XX - Thargoid plan mission
 406+ 6E2D
 407+ 6E2D 00           MissionData				DB	0				; &0B00	  \ look at data, first byte is TP mission bits
 408+ 6E2E
 409+ 6E2E 00 00        FileNameStringPointer	DW	0				;0C00	   \ pointer to filename string
 410+ 6E30 00 00        CommanderLoadAddress	DW	0				;0C03
 411+ 6E32 00 00        LengthOfFile			DW	0				;0C0B
 412+ 6E34 00 00        SaveDataEndAddress		DW	0				;&0C0F	      \ &0C00 is end address of data to save
 413+ 6E36
 414+ 6E36 00 00 00...  EdgesBuffer				DS 50
 415+ 6E68              EdgesBufferSP			equ	$				; Was $0CFF			; Heap pointer for edges buffer
 416+ 6E68              ShipLinesBufferSP		equ EdgesBufferSP	; was $0CFF
 417+ 6E68
 418+ 6E68 00 00 00...  ShipLineStack			DS  70			; For now but will be in the page later
 419+ 6EAE              ShipLineStackTop		equ $ - ShipLineStack
 420+ 6EAE
 421+ 6EAE              ; No longer needed
 422+ 6EAE              ;LSO						DS 	$C0				;0E00 Line Buffer Solar of 192 lines (may be 191 in reality)
 423+ 6EAE              ; LSX vector overlaps with LSO
 424+ 6EAE              ;LSX2					DS	$C0				; &0EC0	    \ LSX2 bline buffer size?
 425+ 6EAE              ;LSY2					DS  $C)	           	; &0F0E	    \ LSY2
 426+ 6EAE
 427+ 6EAE              ; -- Player Runtime Data
 428+ 6EAE 00           GunTemperature          DB  0
 429+ 6EAF 00           CabinTemperature        DB  0
 430+ 6EB0 00           PlayerForwardSheild0	DB	0 ; ?????
 431+ 6EB1 00           PlayerForwardSheild1    DB	0
 432+ 6EB2 00           PlayerForwardSheild2    DB	0
 433+ 6EB3 00           ForeShield				DB	0				; These three must be contiguous
 434+ 6EB4 00           AftShield				DB	0				; .
 435+ 6EB5 00           PlayerEnergy			DB	0				; and in this order
 436+ 6EB6 00           CompassX				DB	0				; 03A8
 437+ 6EB7 00           CompassY				DB	0				; 03A9
 438+ 6EB8              ; Simplification of missile targetting
 439+ 6EB8              ; $FF no missile targettting enabled
 440+ 6EB8              ; $FE missile targetting, no target selected
 441+ 6EB8              ; bit 7 set then tagetting and lower nibble holds missile target and launching
 442+ 6EB8              ; bit 7 clear launch at selected target in lower nibble
 443+ 6EB8 00           MissileTargettingFlag   DB  0
 444+ 6EB9              ;;MissileTarget			DB  0				; 45
 445+ 6EB9              ;;MissileLaunchFlag       DB  0
 446+ 6EB9 00 00 00...  CommanderName           DS  15
 447+ 6EC8 00           CommanderName0			DB	0				; Sneaky little 0 to allow use of print name directly
 448+ 6EC9 00           BadnessStatus           DB  0
 449+ 6ECA              ;note rapidly changing views could reset these so need to consider it in an array
 450+ 6ECA              ; LaserType
 451+ 6ECA              ; LaserPulseRate                          ; how many pulses can be fired before long pause
 452+ 6ECA              ; LaserPulsePause                         ; time before next pulse - 0 = beam
 453+ 6ECA              ; LaserPulseRest                          ; time before pulse count resets to 0
 454+ 6ECA              ; LaserDamageOutput                       ; amount of damage for a laser hit
 455+ 6ECA              ; LaserEnergyDrain                        ; amount of energy drained by cycle
 456+ 6ECA              ; LaserHeat                               ; amount of heat generated
 457+ 6ECA              ; LaserDurability                         ; probabability out of 255 that a hit on unshielded will add random amount of damage
 458+ 6ECA              ; LaserDurabilityAmount                   ; max amount of damagage can be sustained in one damage hit
 459+ 6ECA              ; LaserInMarkets                          ; can this laser be purchased 0 = yes 1 = no
 460+ 6ECA              ; LaserTechLevel                          ; minimum tech level system to buy from
 461+ 6ECA              ; need to add copy table routines
 462+ 6ECA 00           CurrLaserType           DB  0               ; current view laser type, copied in from LaserType array
 463+ 6ECB 00           CurrLaserDamage         DB  0               ; copied in from LaserDamagedFlag array
 464+ 6ECC 00           CurrLaserPulseRate      DB  0               ; current view laser amount of pulses
 465+ 6ECD 00           CurrLaserPulseOnTime    DB  0               ; how many cycles the laser is on
 466+ 6ECE 00           CurrLaserPulseOffTime   DB  0               ; how many cycles the laser is on
 467+ 6ECF 00           CurrLaserPulseRest      DB  0               ; current view laser delay setup between pulses
 468+ 6ED0
 469+ 6ED0                  IFDEF LASER_V2
 470+ 6ED0 00           LaserBeamOn             DB  0
 471+ 6ED1 00           CurrLaserDuration       DB  0   ; == CurrLaserPulseOnTime
 472+ 6ED2 00           CurrentBurstPause       DB  0   ; == CurrLaserPulseOffTime
 473+ 6ED3 00           CurrentCooldown         DB  0   ; == CurrLaserPulseRest
 474+ 6ED4                  ENDIF
 475+ 6ED4 00           CurrLaserBurstRate      DB  0
 476+ 6ED5 00           CurrLaserBurstCount     DB  0   ; == LaserPulseRate
 477+ 6ED6 00           CurrLaserDamageOutput   DB  0
 478+ 6ED7 00           CurrLaserEnergyDrain    DB  0
 479+ 6ED8 00           CurrLaserHeat           DB  0
 480+ 6ED9 00           CurrLaserDurability     DB  0
 481+ 6EDA 00           CurrLaserDurabilityAmount DB  0
 482+ 6EDB
 483+ 6EDB              ; Count down timers must be aligned like this to work
 484+ 6EDB 00           CurrLaserPulseOnCount   DB  0               ; how many cycles the laser is on timer
 485+ 6EDC 00           CurrLaserPulseOffCount  DB  0               ; how many cycles the laser is on timer
 486+ 6EDD 00           CurrLaserPulseRestCount DB  0               ; countdown after shooting for next shot
 487+ 6EDE 00           CurrLaserPulseRateCount DB  0               ; current view laser current pulses fired
 488+ 6EDF
 489+ 6EDF              ; -- Input variables
 490+ 6EDF 00           JoystickX				DB	0				; 034C JSTX
 491+ 6EE0 00           JoystickY				DB	0				; 034D JSTY
 492+ 6EE1 00           XSAV2 					DB	0				; 034E used to temporary save 6502 X reg
 493+ 6EE2 00           YSAV2 					DB	0				; 034F used to temporary save 6502 Y reg
 494+ 6EE3
 495+ 6EE3              ; -- Console drawing data
 496+ 6EE3              FShieldStart            equ $8410
 497+ 6EE3              AShieldStart            equ $8D10
 498+ 6EE3              FuelStart               equ $9410
 499+ 6EE3
 500+ 6EE3              EnergyBar4Start         equ $A5D5
 501+ 6EE3              EnergyBar3Start         equ $ADD5
 502+ 6EE3              EnergyBar2Start         equ $B5D5
 503+ 6EE3              EnergyBar1Start         equ $BDD5
 504+ 6EE3              ; 70 /2 = 35 values
 505+ 6EE3              ;                            0                             1                             2                             3
 506+ 6EE3              ;                            0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6
 507+ 6EE3 01 02 02 03  FuelMapping             DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,19,20,21,21,22,23,24,25,26,27,28,30,31,31
 507+ 6EE7 04 04 05 06
 507+ 6EEB 06 07 08 09
 507+ 6EEF 0A 0A 0B 0C
 507+ 6EF3 0D 0E 0E 0F
 507+ 6EF7 10 10 11 13
 507+ 6EFB 14 15 15 16
 507+ 6EFF 17 18 19 1A
 507+ 6F03 1B 1C 1E 1F
 507+ 6F07 1F
 508+ 6F08              SpeedoStart             equ $84D1
 509+ 6F08              ;                            0                             1                             2                             3                             4
 510+ 6F08              ;                            0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0
 511+ 6F08 01 02 02 03  SpeedoMapping           DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,18,19,20,20,21,22,23,24,24,25,26,26,27,28,28,29,30,31
 511+ 6F0C 04 04 05 06
 511+ 6F10 06 07 08 09
 511+ 6F14 0A 0A 0B 0C
 511+ 6F18 0D 0E 0E 0F
 511+ 6F1C 10 10 11 12
 511+ 6F20 13 14 14 15
 511+ 6F24 16 17 18 18
 511+ 6F28 19 1A 1A 1B
 511+ 6F2C 1C 1C 1D 1E
 511+ 6F30 1F
 512+ 6F31
 513+ 6F31              DialMiddleXPos          equ $E1
 514+ 6F31              RollMiddle              equ $8CE0
 515+ 6F31              PitchMiddle             equ $94E0
 516+ 6F31
 517+ 6F31
 518+ 6F31
 519+ 6F31
 520+ 6F31
# file closed: ../../Variables/general_variables.asm
1341  6F31                  INCLUDE "../../Variables/UniverseSlotRoutines.asm"
# file opened: ../../Variables/UniverseSlotRoutines.asm
   1+ 6F31              ; Note this code is core code and can not be in a memory bank unless do explosion code is changed too
   2+ 6F31 AF           ClearSlotCount:         xor     a
   3+ 6F32 21 06 6E                             ld      hl,UniverseSlotList
   4+ 6F35 06 0C                                ld      b, UniverseSlotListSize ; prbably not needed + UniverseSlotTypeSize
   5+ 6F37 77           .fillLoop:              ld      (hl),a
   6+ 6F38 23                                   inc     hl
   7+ 6F39 10 FC                                djnz    .fillLoop
   8+ 6F3B C9                                   ret
   9+ 6F3C
  10+ 6F3C              ; Initialises all types to a count of 1 where there is an occupied universe slot
  11+ 6F3C              ; this needs expanding to cater for a missing type, find type and increment count (use cpir?)
  12+ 6F3C              ; DOE NOT WORK CorrectSlotCount:       call    ClearSlotCount
  13+ 6F3C              ; DOE NOT WORK                         ld      hl,UniverseSlotCount
  14+ 6F3C              ; DOE NOT WORK                         ld      de,UniverseSlotList
  15+ 6F3C              ; DOE NOT WORK                         ld      b,UniverseSlotListSize
  16+ 6F3C              ; DOE NOT WORK .fillLoop:              ld      a,(de)
  17+ 6F3C              ; DOE NOT WORK                         cp      $FF
  18+ 6F3C              ; DOE NOT WORK                         jr      z,.SkipSlot
  19+ 6F3C              ; DOE NOT WORK .CorrectSlot:           ld      (hl),a
  20+ 6F3C              ; DOE NOT WORK                         inc     hl
  21+ 6F3C              ; DOE NOT WORK                         ld      (hl),1
  22+ 6F3C              ; DOE NOT WORK                         inc     hl
  23+ 6F3C              ; DOE NOT WORK                         inc     hl
  24+ 6F3C              ; DOE NOT WORK .SkipSlot               inc     de
  25+ 6F3C              ; DOE NOT WORK                         djnz    .fillLoop
  26+ 6F3C C9                                   ret
  27+ 6F3D              ; Wipe all items
  28+ 6F3D 3E FF        ClearUnivSlotList:      ld      a,$FF
  29+ 6F3F 21 06 6E                             ld      hl,UniverseSlotList
  30+ 6F42 06 18                                ld      b, UniverseSlotListSize * 2
  31+ 6F44 77           .fillLoop:              ld      (hl),a
  32+ 6F45 23                                   inc     hl
  33+ 6F46 10 FC                                djnz    .fillLoop
  34+ 6F48 C9                                   ret
  35+ 6F49
  36+ 6F49 21 06 6E     SetSlot0ToSpaceStation: ld      hl,UniverseSlotList
  37+ 6F4C 36 02                                ld      (hl),ShipTypeStation
  38+ 6F4E 21 12 6E                             ld      hl,UniverseSlotType
  39+ 6F51 36 02                                ld      (hl),ShipTypeStation
  40+ 6F53 C9                                   ret
  41+ 6F54
  42+ 6F54 21 06 6E     SetSlotAToTypeB:        ld      hl,UniverseSlotList
  43+ 6F57 ED 31                                add     hl,a
  44+ 6F59 70                                   ld      (hl),b
  45+ 6F5A C9                                   ret
  46+ 6F5B
  47+ 6F5B 21 12 6E     SetSlotAToClassB:       ld      hl,UniverseSlotType
  48+ 6F5E ED 31                                add     hl,a
  49+ 6F60 70                                   ld      (hl),b
  50+ 6F61 C9                                   ret
  51+ 6F62
  52+ 6F62              ; Clears all except slot A, used when say restarting a space station post launch
  53+ 6F62 57           ClearFreeSlotListSaveA: ld      d,a
  54+ 6F63 0E 00                                ld      c,0
  55+ 6F65 21 06 6E                             ld      hl,UniverseSlotList
  56+ 6F68 06 18                                ld      b, UniverseSlotListSize * 2
  57+ 6F6A 79           .fillLoop:              ld      a,c
  58+ 6F6B BA                                   cp      d
  59+ 6F6C 28 03                                jr      z,.SkipSlot
  60+ 6F6E 3E FF                                ld      a,$FF
  61+ 6F70 77                                   ld      (hl),a
  62+ 6F71 23           .SkipSlot:              inc     hl
  63+ 6F72 23                                   inc     hl
  64+ 6F73 10 F5                                djnz    .fillLoop
  65+ 6F75 C9                                   ret
  66+ 6F76
  67+ 6F76 21 06 6E     ClearSlotA:             ld      hl,UniverseSlotList
  68+ 6F79 ED 31                                add     hl,a
  69+ 6F7B 36 FF                                ld      (hl),$FF
  70+ 6F7D 3E 0C                                ld      a,UniverseSlotListSize  ; move to types
  71+ 6F7F ED 31                                add     hl,a
  72+ 6F81 36 FF                                ld      (hl),$FF
  73+ 6F83 C9                                   ret
  74+ 6F84
  75+ 6F84              ; Space Station will always be slot 0
  76+ 6F84 21 13 6E     ClearJunk:              ld      hl,UniverseSlotType+1
  77+ 6F87 0E 01                                ld      c,1
  78+ 6F89 06 0B                                ld      b,UniverseSlotListSize -1      ; ignore space station
  79+ 6F8B 7E           .NextShip:              ld      a,(hl)
  80+ 6F8C FE 03                                cp      ShipTypeJunk
  81+ 6F8E CA 9F 6F                             jp      z,.ProcessJunk
  82+ 6F91 FE 04                                cp      ShipTypeScoopable
  83+ 6F93 CA 9F 6F                             jp      z,.ProcessJunk
  84+ 6F96 23           .DoneIteration:         inc     hl
  85+ 6F97 0C                                   inc     c
  86+ 6F98 10 F1                                djnz    .NextShip
  87+ 6F9A                                      ClearJunkCount
  87+ 6F9A             >                        ZeroA
  87+ 6F9A AF          >                        xor a
  87+ 6F9B 32 C0 6C    >                        ld      (JunkCount),a
  88+ 6F9E C9                                   ret
  89+ 6F9F 79           .ProcessJunk:           ld      a,c
  90+ 6FA0 CD 76 6F                             call    ClearSlotA
  91+ 6FA3 C3 96 6F                             jp      .DoneIteration
  92+ 6FA6
  93+ 6FA6
  94+ 6FA6 21 13 6E     WarpJunk:               ld      hl,UniverseSlotType+1
  95+ 6FA9 0E 01                                ld      c,1
  96+ 6FAB 06 0B                                ld      b,UniverseSlotListSize -1      ; ignore space station
  97+ 6FAD 7E           .NextShip:              ld      a,(hl)
  98+ 6FAE FE 03                                cp      ShipTypeJunk
  99+ 6FB0 CA BD 6F                             jp      z,.ProcessJunk
 100+ 6FB3 FE 04                                cp      ShipTypeScoopable
 101+ 6FB5 CA BD 6F                             jp      z,.ProcessJunk
 102+ 6FB8 23           .DoneIteration:         inc     hl
 103+ 6FB9 0C                                   inc     c
 104+ 6FBA 10 F1                                djnz    .NextShip
 105+ 6FBC C9                                   ret
 106+ 6FBD 79           .ProcessJunk:           ld      a,c
 107+ 6FBE                                      MMUSelectUniverseA
 107+ 6FBE C6 46       >                     add    a,BankUNIVDATA0
 107+ 6FC0 ED 92 56    >                     nextreg UniverseMMU,       a
 108+ 6FC3 CD 9D C6                             call    WarpOffset
 109+ 6FC6 C3 B8 6F                             jp      .DoneIteration
 110+ 6FC9
 111+ 6FC9 21 13 6E     AreShipsPresent:        ld      hl,UniverseSlotType+1
 112+ 6FCC 06 0B                                ld      b,UniverseSlotListSize -1      ; ignore space station
 113+ 6FCE 7E           .NextShip:              ld      a,(hl)
 114+ 6FCF FE 00                                cp      ShipTypeNormal
 115+ 6FD1                                      ClearCarryFlag
 115+ 6FD1 B7          >                        or a
 116+ 6FD2 C8                                   ret     z
 117+ 6FD3 23                                   inc     hl
 118+ 6FD4 10 F8                                djnz    .NextShip
 119+ 6FD6                                      SetCarryFlag
 119+ 6FD6 37          >                        scf
 120+ 6FD7 C9                                   ret
 121+ 6FD8
 122+ 6FD8 21 06 6E     IsSpaceStationPresent:  ld      hl,UniverseSlotList
 123+ 6FDB                                      ClearCarryFlag
 123+ 6FDB B7          >                        or a
 124+ 6FDC 7E           .SearchLoop:            ld      a,(hl)
 125+ 6FDD                                      ReturnIfAEqNusng ShipTypeStation
 125+ 6FDD FE 02       >                        cp      ShipTypeStation
 125+ 6FDF C8          >                        ret     z
 126+ 6FE0                                      SetCarryFlag
 126+ 6FE0 37          >                        scf
 127+ 6FE1 C9                                   ret
 128+ 6FE2
 129+ 6FE2 21 06 6E     GetTypeAtSlotA:         ld      hl,UniverseSlotList
 130+ 6FE5 ED 31                                add     hl,a
 131+ 6FE7 7E                                   ld      a,(hl)
 132+ 6FE8 C9                                   ret
 133+ 6FE9
 134+ 6FE9 21 07 6E     IsPlanetOrSpaceStation: ld      hl,UniverseSlotList+1
 135+ 6FEC 7E                                   ld      a,(hl)
 136+ 6FED C9                                   ret
 137+ 6FEE              ;-----------------------------------------------------------------------------
 138+ 6FEE              ;-- Search the slot list for a free slot and return the result in c register.
 139+ 6FEE              ;-- Carry is clear if successful, else carry is set if all slots full
 140+ 6FEE              ;-- uses hl, bc, a
 141+ 6FEE 21 06 6E     FindNextFreeSlotInC:    ld      hl,UniverseSlotList
 142+ 6FF1 06 0C                                ld      b, UniverseSlotListSize
 143+ 6FF3 0E 00                                ld      c, 0
 144+ 6FF5 7E           .SearchLoop:            ld      a,(hl)
 145+ 6FF6                                      JumpIfAEqNusng $FF, .FoundSlot
 145+ 6FF6 FE FF       >                        cp     $FF
 145+ 6FF8 CA 01 70    >                        jp      z,.FoundSlot
 146+ 6FFB 0C                                   inc     c
 147+ 6FFC 23                                   inc     hl
 148+ 6FFD 10 F6                                djnz    .SearchLoop
 149+ 6FFF                                      SetCarryFlag
 149+ 6FFF 37          >                        scf
 150+ 7000 C9                                   ret
 151+ 7001              .FoundSlot:             ClearCarryFlag
 151+ 7001 B7          >                        or a
 152+ 7002 C9                                   ret
 153+ 7003
 154+ 7003              ;-----------------------------------------------------------------------------
 155+ 7003              ;-- calls FindNextFreeSlotInC and returns the result in a and c registers.
 156+ 7003              ;-- Carry is clear if successful, else carry is set if all slots full
 157+ 7003              ;-- uses hl, bc, a
 158+ 7003 CD EE 6F     FindNextFreeSlotInA:    call    FindNextFreeSlotInC
 159+ 7006 79                                   ld      a,c
 160+ 7007 C9                                   ret
 161+ 7008
# file closed: ../../Variables/UniverseSlotRoutines.asm
1342  7008                  INCLUDE "../../Variables/random_number.asm"
# file opened: ../../Variables/random_number.asm
   1+ 7008              ; dea = random number
   2+ 7008 CD 19 70     doRandomS24:            call    doRandom
   3+ 700B 57                                   ld      d,a
   4+ 700C E5                                   push    hl
   5+ 700D CD 19 70                             call    doRandom
   6+ 7010 E1                                   pop     hl
   7+ 7011 5F                                   ld      e,a
   8+ 7012 E5                                   push    hl
   9+ 7013 CD 19 70                             call    doRandom
  10+ 7016 E1                                   pop     hl
  11+ 7017 C9                                   ret
  12+ 7018
  13+ 7018              doRandom2:									; .DORND2	\ -> &3F85 \ Restricted for explosion dust.
  14+ 7018              doRND2:
  15+ 7018 A7           	and		a								; fast clear carry  leave bit0 of RAND+2 at 0.
  16+ 7019              doRandom:									;.DORND	\ -> &3F86 \ do random, new A, X.
  17+ 7019              ; "doRandom, Random Seed update, new value in A & C)"
  18+ 7019              ; uses a 'a c h l registers, de not affected
  19+ 7019              doRND:                  ;exx                                     ; protect bc,de,hl
  20+ 7019 3A 0B 6B                             ld		a,(RandomSeed)					; Get Seed 0
  21+ 701C CB 17                                rl		a								; Rotate L including carry
  22+ 701E 4F                                   ld		c,a								; c =  double lo
  23+ 701F 21 0D 6B     .AddSeed2:              ld		hl,RandomSeed2
  24+ 7022 8E                                   adc		a,(hl)							; RAND+2
  25+ 7023 32 0B 6B     .SaveAtoSeed:           ld		(RandomSeed),a					; and save RAND
  26+ 7026 08           .SaveBtoSeed2:          ex		af,af'
  27+ 7027 79                                   ld		a,c
  28+ 7028 32 0D 6B                             ld		(RandomSeed2),a
  29+ 702B 08                                   ex		af,af'
  30+ 702C 3A 0C 6B                             ld		a,(RandomSeed1)
  31+ 702F 4F                                   ld		c,a								; C = Seed1
  32+ 7030 21 0E 6B     .AddSeed3:              ld		hl,RandomSeed3
  33+ 7033 8E                                   adc		a,(hl)
  34+ 7034 32 0C 6B                             ld		(RandomSeed1),a
  35+ 7037 08                                   ex		af,af'
  36+ 7038 79                                   ld		a,c
  37+ 7039 32 0E 6B                             ld		(RandomSeed3),a
  38+ 703C 08                                   ex		af,af'
  39+ 703D                                      ;exx                                     ; get bc,de,hl back
  40+ 703D C9                                   ret
  41+ 703E
  42+ 703E 21 0B 6B     saveRandomSeeds:        ld      hl,RandomSeed
  43+ 7041 11 0F 6B                             ld      de,RandomSeedSave
  44+ 7044 01 04 00                             ld      bc,4
  45+ 7047 ED A0                                ldi
  46+ 7049 ED A0                                ldi
  47+ 704B ED A0                                ldi
  48+ 704D ED A0                                ldi
  49+ 704F C9                                   ret
  50+ 7050
  51+ 7050 21 0F 6B     restoreRandomSeeds:     ld      hl,RandomSeedSave
  52+ 7053 11 0B 6B                             ld      de,RandomSeed
  53+ 7056 01 04 00                             ld      bc,4
  54+ 7059 ED A0                                ldi
  55+ 705B ED A0                                ldi
  56+ 705D ED A0                                ldi
  57+ 705F ED A0                                ldi
  58+ 7061 C9                                   ret
# file closed: ../../Variables/random_number.asm
1343  7062                  INCLUDE "../../Maths/asm_multiply.asm"
# file opened: ../../Maths/asm_multiply.asm
   1+ 7062              AequAdivDmul96Unsg:     JumpIfAGTENusng d, .Unity    			; if A >= Q then return with a 1 (unity i.e. 96)
   1+ 7062 BA          >                        cp     d
   1+ 7063 D2 7E 70    >                        jp		nc,.Unity
   2+ 7066 06 FF                                ld          b,%11111111                 ; Loop through 8 bits
   3+ 7068 CB 27        .DivLoop:               sla         a                           ; shift a left
   4+ 706A                                      JumpIfALTNusng d, .skipSubtract         ; if a < q skip the following
   4+ 706A BA          >                        cp      d
   4+ 706B DA 6F 70    >                        jp		c, .skipSubtract
   5+ 706E 92                                   sub         d
   6+ 706F              .skipSubtract:          FlipCarryFlag
   6+ 706F 3F          >                        ccf
   7+ 7070 CB 10                                rl          b
   8+ 7072 38 F4                                jr          c,.DivLoop
   9+ 7074 78                                   ld          a,b
  10+ 7075 CB 3F                                srl         a                  			; t = t /4
  11+ 7077 CB 3F                                srl			a							; result / 8
  12+ 7079 47                                   ld          b,a
  13+ 707A CB 3F                                srl         a
  14+ 707C 80                                   add			a,b							; result /8 + result /4
  15+ 707D C9                                   ret
  16+ 707E 3E 60        .Unity:                 ld			a,$60	    				; unity
  17+ 7080 C9                                   ret
  18+ 7081
  19+ 7081
  20+ 7081              HLequSRmulQdiv256:      ;X.Y=x1lo.S*M/256  	\ where M/256 is gradient
  21+ 7081 2A 17 6C                             ld  hl,(varRS)
  22+ 7084 3A 16 6C                             ld  a,(varQ)
  23+ 7087 C5 D5        HLeqyHLmulAdiv256:      push    bc,,de
  24+ 7089 11 00 00                             ld  de,0        ; de = XY
  25+ 708C 47                                   ld  b,a         ; b = Q
  26+ 708D                                      ShiftHLRight1
  26+ 708D CB 3C       >			   srl h
  26+ 708F CB 1D       >			   rr  l
  27+ 7091 CB 20                                sla b
  28+ 7093 30 03                                jr  nc,.LL126
  29+ 7095 EB           .LL125:                 ex de,hl
  30+ 7096 19                                   add hl,de
  31+ 7097 EB                                   ex  de,hl       ; de = de + rs
  32+ 7098              .LL126:                 ShiftHLRight1
  32+ 7098 CB 3C       >			   srl h
  32+ 709A CB 1D       >			   rr  l
  33+ 709C CB 20                                sla b
  34+ 709E 38 F5                                jr      c,.LL125
  35+ 70A0 20 F6                                jr      nz,.LL126
  36+ 70A2 EB                                   ex      de,hl   ; hl = result
  37+ 70A3 D1 C1                                pop     bc,,de
  38+ 70A5 C9                                   ret
  39+ 70A6
  40+ 70A6              ; FMLTU - A = A * Q / 256
  41+ 70A6 57           AequAmulQdiv256usgn:    ld      d,a
  42+ 70A7 3A 16 6C                             ld      a,(varQ)
  43+ 70AA 5F                                   ld      e,a
  44+ 70AB              asm_defmutl:
  45+ 70AB              ; "ASM_FMUTKL .FMLTU	\ -> &2847  \ A=D*E/256unsg  Fast multiply"
  46+ 70AB ED 30        AequDmulEdiv256usgn:    mul     de
  47+ 70AD 7A                                   ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
  48+ 70AE C9                                   ret
  49+ 70AF
  50+ 70AF
  51+ 70AF              ; muliptiply S7d ny S7e signed
  52+ 70AF              ; used A and B registers
  53+ 70AF              ; result in DE
  54+ 70AF 7A           mulDbyESigned:          ld      a,d
  55+ 70B0 AB                                   xor     e
  56+ 70B1 E6 80                                and     SignOnly8Bit
  57+ 70B3 47                                   ld      b,a
  58+ 70B4 7A                                   ld      a,d
  59+ 70B5 E6 7F                                and     SignMask8Bit
  60+ 70B7 57                                   ld      d,a
  61+ 70B8 7B                                   ld      a,e
  62+ 70B9 E6 7F                                and     SignMask8Bit
  63+ 70BB 5F                                   ld      e,a
  64+ 70BC ED 30                                mul     de
  65+ 70BE 7A                                   ld      a,d
  66+ 70BF B0                                   or      b
  67+ 70C0 57                                   ld      d,a
  68+ 70C1 C9                                   ret
  69+ 70C2
  70+ 70C2
  71+ 70C2
  72+ 70C2              MacroDEEquQmulASigned:  MACRO
  73+ 70C2 ~                                    ld      d,a                         ; save a into d
  74+ 70C2 ~                                    ld      a,(varQ)
  75+ 70C2 ~                                    ld      e,a
  76+ 70C2 ~                                    xor     d                           ; a = a xor var Q
  77+ 70C2 ~                                    and     SignOnly8Bit
  78+ 70C2 ~                                    ld      b,a                         ; b = sign of a xor q
  79+ 70C2 ~                                    ld      a,d                         ; d = abs d (or a reg)
  80+ 70C2 ~                                    and     SignMask8Bit
  81+ 70C2 ~                                    ld      d,a
  82+ 70C2 ~                                    ld      a,e                         ; e = abs e (or varQ)
  83+ 70C2 ~                                    and     SignMask8Bit
  84+ 70C2 ~                                    ld      e,a
  85+ 70C2 ~                                    mul                                 ; de = a * Q
  86+ 70C2 ~                                    ld      a,d
  87+ 70C2 ~                                    or      b                           ; de = a * Q leading sign bit
  88+ 70C2 ~                                    ld      d,a
  89+ 70C2                                      ENDM
  90+ 70C2
  91+ 70C2
  92+ 70C2
  93+ 70C2                                 ; .MAD	\ -> &22AD  \ Multiply and Add  (DE also) X.A(Lo.Hi) = Q*A + R.S (Lo.Hi)
  94+ 70C2              madXAequQmulAaddRS:     MacroDEEquQmulASigned
  94+ 70C2 57          >                        ld      d,a                         ; save a into d
  94+ 70C3 3A 16 6C    >                        ld      a,(varQ)
  94+ 70C6 5F          >                        ld      e,a
  94+ 70C7 AA          >                        xor     d                           ; a = a xor var Q
  94+ 70C8 E6 80       >                        and     SignOnly8Bit
  94+ 70CA 47          >                        ld      b,a                         ; b = sign of a xor q
  94+ 70CB 7A          >                        ld      a,d                         ; d = abs d (or a reg)
  94+ 70CC E6 7F       >                        and     SignMask8Bit
  94+ 70CE 57          >                        ld      d,a
  94+ 70CF 7B          >                        ld      a,e                         ; e = abs e (or varQ)
  94+ 70D0 E6 7F       >                        and     SignMask8Bit
  94+ 70D2 5F          >                        ld      e,a
  94+ 70D3 ED 30       >                        mul                                 ; de = a * Q
  94+ 70D5 7A          >                        ld      a,d
  94+ 70D6 B0          >                        or      b                           ; de = a * Q leading sign bit
  94+ 70D7 57          >                        ld      d,a
  95+ 70D8 2A 17 6C                             ld		hl,(varR)
  96+ 70DB CD 03 71                             call	madXAAddHLDESigned
  97+ 70DE EB                                   ex      de,hl                       ; de = R.S + DE
  98+ 70DF                                      ClearCarryFlag
  98+ 70DF B7          >                        or a
  99+ 70E0 DD 6B                                ld      ixl,e
 100+ 70E2 7A                                   ld      a,d
 101+ 70E3 C9                                   ret
 102+ 70E4
 103+ 70E4              madDEequQmulAaddRS:     MacroDEEquQmulASigned
 103+ 70E4 57          >                        ld      d,a                         ; save a into d
 103+ 70E5 3A 16 6C    >                        ld      a,(varQ)
 103+ 70E8 5F          >                        ld      e,a
 103+ 70E9 AA          >                        xor     d                           ; a = a xor var Q
 103+ 70EA E6 80       >                        and     SignOnly8Bit
 103+ 70EC 47          >                        ld      b,a                         ; b = sign of a xor q
 103+ 70ED 7A          >                        ld      a,d                         ; d = abs d (or a reg)
 103+ 70EE E6 7F       >                        and     SignMask8Bit
 103+ 70F0 57          >                        ld      d,a
 103+ 70F1 7B          >                        ld      a,e                         ; e = abs e (or varQ)
 103+ 70F2 E6 7F       >                        and     SignMask8Bit
 103+ 70F4 5F          >                        ld      e,a
 103+ 70F5 ED 30       >                        mul                                 ; de = a * Q
 103+ 70F7 7A          >                        ld      a,d
 103+ 70F8 B0          >                        or      b                           ; de = a * Q leading sign bit
 103+ 70F9 57          >                        ld      d,a
 104+ 70FA 2A 17 6C                             ld		hl,(varR)
 105+ 70FD CD 03 71                             call	madXAAddHLDESigned
 106+ 7100 EB                                   ex      de,hl                       ; de = R.S + DE
 107+ 7101                                      ClearCarryFlag
 107+ 7101 B7          >                        or a
 108+ 7102 C9                                   ret
 109+ 7103
 110+ 7103 7C           madXAAddHLDESigned:     ld      a,h
 111+ 7104 E6 80                                and     SignOnly8Bit
 112+ 7106 47                                   ld      b,a                         ;save sign bit in b
 113+ 7107 AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
 114+ 7108                                      JumpIfNegative .ADDHLDEOppSGN        ;Signs are opposite there fore we can subtract to get difference
 114+ 7108 FA 20 71    >                        jp		m, .ADDHLDEOppSGN
 115+ 710B 78           .ADDHLDESameSigns:       ld      a,b
 116+ 710C B2                                   or      d
 117+ 710D                                      JumpIfNegative .ADDHLDESameNeg       ; optimisation so we can just do simple add if both positive
 117+ 710D FA 12 71    >                        jp		m, .ADDHLDESameNeg
 118+ 7110 19                                   add     hl,de
 119+ 7111 C9                                   ret
 120+ 7112 7C           .ADDHLDESameNeg:         ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 121+ 7113 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 122+ 7115 67                                   ld      h,a
 123+ 7116 7A                                   ld      a,d
 124+ 7117 E6 7F                                and     SignMask8Bit
 125+ 7119 57                                   ld      d,a
 126+ 711A 19                                   add     hl,de
 127+ 711B 3E 80                                ld      a,SignOnly8Bit
 128+ 711D B4                                   or      h                           ; now set bit for negative value, we won't bother with overflow for now TODO
 129+ 711E 67                                   ld      h,a
 130+ 711F C9                                   ret
 131+ 7120 7C           .ADDHLDEOppSGN:          ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit                     ; here HL and DE are opposite
 132+ 7121 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 133+ 7123 67                                   ld      h,a
 134+ 7124 7A                                   ld      a,d
 135+ 7125 E6 7F                                and     SignMask8Bit
 136+ 7127 57                                   ld      d,a
 137+ 7128 B7                                   or      a
 138+ 7129 ED 52                                sbc     hl,de
 139+ 712B 38 04                                jr      c,.ADDHLDEOppInvert
 140+ 712D 78           .ADDHLDEOppSGNNoCarry:   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
 141+ 712E B4                                   or      h
 142+ 712F 67                                   ld      h,a                         ; set the previou sign value
 143+ 7130 C9                                   ret
 144+ 7131              .ADDHLDEOppInvert:       NegHL                                                   ; we need to flip the sign and 2'c the Hl result
 144+ 7131 AF          >                    xor a
 144+ 7132 95          >                    sub l
 144+ 7133 6F          >                    ld l,a
 144+ 7134 9F          >                    sbc a,a
 144+ 7135 94          >                    sub h
 144+ 7136 67          >                    ld h,a
 145+ 7137 78                                   ld      a,b
 146+ 7138 EE 80                                xor     SignOnly8Bit                ; flip sign bit
 147+ 713A B4                                   or      h
 148+ 713B 67                                   ld      h,a                         ; recover sign
 149+ 713C C9                                   ret
 150+ 713D
 151+ 713D
 152+ 713D                  ; multiplication of 16-bit number and 8-bit number into a 24-bit product
 153+ 713D                  ;
 154+ 713D                  ; enter : hl = 16-bit multiplier   = x
 155+ 713D                  ;          e =  8-bit multiplicand = y
 156+ 713D                  ;
 157+ 713D                  ; exit  : ahl = 24-bit product
 158+ 713D                  ;         carry reset
 159+ 713D                  ;
 160+ 713D                  ; uses  : af, de, hl
 161+ 713D 54           AHLequHLmulE:           ld d,h                      ; xh
 162+ 713E 63                                   ld h,e                      ; yl
 163+ 713F ED 30                                mul de                      ; xh*yl
 164+ 7141 EB                                   ex de,hl
 165+ 7142 ED 30                                mul de                      ; yl*xl, hl = xh*yl
 166+ 7144
 167+ 7144 7A                                   ld  a,d                     ; sum products
 168+ 7145 85                                   add a,l
 169+ 7146 57                                   ld  d,a
 170+ 7147 EB                                   ex de,hl
 171+ 7148
 172+ 7148 7A                                   ld  a,d
 173+ 7149 CE 00                                adc a,0
 174+ 714B C9                                   ret
 175+ 714C
 176+ 714C 54           HLE0quH0mulE:           ld      d,h                 ; .
 177+ 714D 63                                   ld      h,e                 ; .
 178+ 714E ED 30                                mul     de                  ; de = xh * yl
 179+ 7150 EB                                   ex      de,hl
 180+ 7151 C9                                   ret
 181+ 7152
 182+ 7152                 ; multiplication of two 16-bit numbers into a 32-bit product
 183+ 7152                 ;
 184+ 7152                 ; enter : de = 16-bit multiplicand = y
 185+ 7152                 ;         hl = 16-bit multiplicand = x
 186+ 7152                 ;
 187+ 7152                 ; exit  : dehl = 32-bit product
 188+ 7152                 ;         carry reset
 189+ 7152                 ;
 190+ 7152                 ; uses  : af, bc, de, hl
 191+ 7152
 192+ 7152
 193+ 7152
 194+ 7152 45           DEHLequDEmulHL:         ld b,l                      ; x0
 195+ 7153 4B                                   ld c,e                      ; y0
 196+ 7154 5D                                   ld e,l                      ; x0
 197+ 7155 6A                                   ld l,d
 198+ 7156 E5                                   push hl                     ; x1 y1
 199+ 7157 69                                   ld l,c                      ; y0
 200+ 7158              ; bc = x0 y0, de = y1 x0,  hl = x1 y0,  stack = x1 y1
 201+ 7158 ED 30                                mul de                      ; y1*x0
 202+ 715A EB                                   ex de,hl
 203+ 715B ED 30                                mul de                      ; x1*y0
 204+ 715D
 205+ 715D AF                                   xor a                       ; zero A
 206+ 715E 19                                   add hl,de                   ; sum cross products p2 p1
 207+ 715F 8F                                   adc a,a                     ; capture carry p3
 208+ 7160
 209+ 7160 59                                   ld e,c                      ; x0
 210+ 7161 50                                   ld d,b                      ; y0
 211+ 7162 ED 30                                mul de                      ; y0*x0
 212+ 7164
 213+ 7164 47                                   ld b,a                      ; carry from cross products
 214+ 7165 4C                                   ld c,h                      ; LSB of MSW from cross products
 215+ 7166
 216+ 7166 7A                                   ld a,d
 217+ 7167 85                                   add a,l
 218+ 7168 67                                   ld h,a
 219+ 7169 6B                                   ld l,e                      ; LSW in HL p1 p0
 220+ 716A
 221+ 716A D1                                   pop de
 222+ 716B ED 30                                mul de                      ; x1*y1
 223+ 716D
 224+ 716D EB                                   ex de,hl
 225+ 716E ED 4A                                adc hl,bc
 226+ 7170 EB                                   ex de,hl                    ; de = final MSW
 227+ 7171
 228+ 7171 C9                                   ret
 229+ 7172
 230+ 7172              ; multiplication of two 16-bit numbers into a 16-bit product
 231+ 7172              ; enter : de = 16-bit multiplicand
 232+ 7172              ;         hl = 16-bit multiplicand
 233+ 7172              ; exit  : hl = 16-bit product
 234+ 7172              ;         carry reset
 235+ 7172              ; maths is
 236+ 7172              ;        hl = y , de= x
 237+ 7172              ;        hl = xhi,ylo + (yhigh * xlow)
 238+ 7172              ;        hl = yhih & xlo + x
 239+ 7172              ;
 240+ 7172              ;
 241+ 7172              ; uses  : af, bc, de, hl
 242+ 7172 C5           mulDEbyHL:              push    bc
 243+ 7173 7A                                   ld a,d                      ; a = xh
 244+ 7174 54                                   ld d,h                      ; d = yh
 245+ 7175 67                                   ld h,a                      ; h = xh
 246+ 7176 4B                                   ld c,e                      ; c = xl
 247+ 7177 45                                   ld b,l                      ; b = yl
 248+ 7178 ED 30                                mul                         ; yh * yl
 249+ 717A EB                                   ex de,hl
 250+ 717B ED 30                                mul                         ; xh * yl
 251+ 717D 19                                   add hl,de                   ; add cross products
 252+ 717E 59                                   ld e,c
 253+ 717F 50                                   ld d,b
 254+ 7180 ED 30                                mul                         ; yl * xl
 255+ 7182 7D                                   ld a,l                      ; cross products lsb
 256+ 7183 82                                   add a,d                     ; add to msb final
 257+ 7184 67                                   ld h,a
 258+ 7185 6B                                   ld l,e                      ; hl = final
 259+ 7186                                      ; 83 cycles, 19 bytes
 260+ 7186 AF                                   xor a                       ; reset carry
 261+ 7187 C1                                   pop     bc
 262+ 7188 C9                                   ret
 263+ 7189
 264+ 7189              ; multiplication of 16-bit numbers by 8-bit product
 265+ 7189              ; enter : de = 16-bit multiplicand
 266+ 7189              ;          l = 8-bit multiplicand
 267+ 7189              ; exit  : hl = 16-bit product
 268+ 7189              ;         carry reset
 269+ 7189              ; maths is
 270+ 7189              ;        hl = y , de= x
 271+ 7189              ;        hl = xhi,ylo + (yhigh * xlow)
 272+ 7189              ;        hl = yhih & xlo + x
 273+ 7189              ;
 274+ 7189              ;
 275+ 7189              ; uses  : af, bc, de, hl
 276+ 7189 C5 E5 D5     mulDEbyLSigned:         push    bc,,hl,,de
 277+ 718C 7A                                   ld a,d                      ; a = xh
 278+ 718D 16 00                                ld d,0                      ; d = yh = 0
 279+ 718F 67                                   ld h,a                      ; h = xh
 280+ 7190 4B                                   ld c,e                      ; c = xl
 281+ 7191 45                                   ld b,l                      ; b = yl
 282+ 7192              ;                        mul                         ; yh * xl which will always be 0
 283+ 7192 EB                                   ex de,hl                    ; de = xh yl
 284+ 7193 ED 30                                mul                         ; xh * yl
 285+ 7195 EB                                   ex de,hl                    ; hl = xh * yl
 286+ 7196              ;                        add hl,de                   ; add cross products
 287+ 7196 59                                   ld e,c                      ; de = yl xl
 288+ 7197 50                                   ld d,b                      ; .
 289+ 7198 ED 30                                mul                         ; yl * xl
 290+ 719A 7D                                   ld a,l                      ; cross products lsb
 291+ 719B 82                                   add a,d                     ; add to msb final
 292+ 719C 67                                   ld h,a
 293+ 719D 6B                                   ld l,e                      ; hl = final
 294+ 719E AF                                   xor a                       ; reset carry
 295+ 719F C1                                   pop     bc                  ; get de for sign
 296+ 71A0 78                                   ld      a,b
 297+ 71A1 C1                                   pop     bc                  ; get hl for sign
 298+ 71A2 A8                                   xor     b
 299+ 71A3 E6 80                                and     $80                 ; so we now have the sign bit
 300+ 71A5 B4                                   or      h                   ; so set the sign
 301+ 71A6 67                                   ld      h,a                 ; .
 302+ 71A7 C1                                   pop     bc                  ; clear up stack
 303+ 71A8 C9                                   ret
 304+ 71A9
 305+ 71A9                  DISPLAY "TODO: TEST"
 306+ 71A9 7A           mulDEbyHLSigned:        ld  a,d                     ; de = abs de
 307+ 71AA 47                                   ld  b,a                     ;
 308+ 71AB E6 7F                                and     $7F                 ; .
 309+ 71AD 57                                   ld  d,a                     ; .
 310+ 71AE 7C                                   ld  a,h                     ; hl = abs hl
 311+ 71AF 4F                                   ld  c,a                     ; .
 312+ 71B0 E6 7F                                and     $7F                 ; .
 313+ 71B2 67                                   ld      h,a                 ; .
 314+ 71B3 79                                   ld      a,c                 ; ixl = target sign of de * hl
 315+ 71B4 AA                                   xor     d                   ;
 316+ 71B5 E6 80                                and     $80                 ;
 317+ 71B7 DD 6F                                ld      ixl,a               ;
 318+ 71B9 CD 72 71                             call    mulDEbyHL           ; calculate ABS(DE) * ABS(HL)
 319+ 71BC 7C                                   ld      a,h                 ; recover sign bit
 320+ 71BD DD B5                                or      ixl
 321+ 71BF 67                                   ld      h,a
 322+ 71C0 C9                                   ret
 323+ 71C1
 324+ 71C1              ; CHL = multiplicand D = multiplier
 325+ 71C1              ; DCHL = CHL * D
 326+ 71C1 7A           mulCHLbyDSigned:        ld      a,d                 ; get sign from d
 327+ 71C2 AC                                   xor     h                   ; xor with h to get resultant sign
 328+ 71C3 E6 80                                and     SignOnly8Bit        ; .
 329+ 71C5 FD 67                                ld      iyh,a               ; iyh = copy of sign
 330+ 71C7 79                                   ld      a,c                 ; now CHL = ABS (CHL)
 331+ 71C8 E6 7F                                and     SignMask8Bit        ; .
 332+ 71CA 4F                                   ld      c,a                 ; .
 333+ 71CB 7A                                   ld      a,d                 ; d = ABS D
 334+ 71CC E6 7F                                and     SignMask8Bit        ; .
 335+ 71CE              ; At this point CHL = ABS (HLE), A = ABS(D)
 336+ 71CE 57           .mul1:                  ld      d,a                 ; first do D * L
 337+ 71CF 5D                                   ld      e,l                 ; .
 338+ 71D0 ED 30                                mul     de                  ; DE = L * D
 339+ 71D2 08                                   ex      af,af'              ; save multiplier
 340+ 71D3 6B                                   ld      l,e                 ; L = p0
 341+ 71D4 7A                                   ld      a,d                 ; carry byte
 342+ 71D5 08                                   ex      af,af'              ; retrieve muliplier and save carry byte along with flags
 343+ 71D6 5C           .mul2:                  ld      e,h                 ; byte 2 of multiplicand
 344+ 71D7 57                                   ld      d,a                 ; and multiplier
 345+ 71D8 ED 30                                mul     de                  ; now its D & L
 346+ 71DA 08                                   ex      af,af'              ; get back carry byte with flags
 347+ 71DB 83           .carrybyte1:            add     a,e                 ; add low byte carry to result and retain carry too through next instructions
 348+ 71DC 67                                   ld      h,a                 ; h = P1
 349+ 71DD 7A                                   ld      a,d                 ; a = carry byte
 350+ 71DE 08                                   ex      af,af'              ; save carry byte and get back multiplier with flags
 351+ 71DF 59           .mul3:                  ld      e,c                 ; byte 3 of multiplicand
 352+ 71E0 57                                   ld      d,a                 ;
 353+ 71E1 ED 30                                mul     de                  ;
 354+ 71E3 08                                   ex      af,af'              ; get back carry byte and carry prior to first add
 355+ 71E4 8B                                   adc     a,e                 ;
 356+ 71E5 FD B4                                or      iyh                 ; recover saved resultant sign
 357+ 71E7 4F                                   ld      c,a                 ; c byte 3. Note the value range allowed can never cause a byte 3 carry
 358+ 71E8 C9                                   ret
 359+ 71E9
 360+ 71E9              ;  CHL = 53456 D = 1E
 361+ 71E9              ;  56 * 1E = A14 L = 14 carry = 0A
 362+ 71E9              ;  34 * 1E = 618 H = 18 +A = 22 carry = 6
 363+ 71E9              ;  5  * 1E = 096 C = 96 + 6 = 9C
 364+ 71E9              ;  CHL = 9C2214
 365+ 71E9              ;mult3
 366+ 71E9              ; DELC = HLE * D, uses HL, DE, C , A , IYH
 367+ 71E9              ; HLE = multiplicand D = multiplier
 368+ 71E9              ; tested by mathstestsun.asm all passed
 369+ 71E9              ; Algorithm
 370+ 71E9              ; AC =  E * D   (save carry)         H    L    E
 371+ 71E9              ; DE =  L * D                                  D
 372+ 71E9              ;  L =  A + E + carry                         E*D (lo)
 373+ 71E9              ; DE =  H * D                             L*D+ ^ (hi)
 374+ 71E9              ;  E =  A + E + carry                H*D (lo) + carry
 375+ 71E9              ;
 376+ 71E9              ;
 377+ 71E9 7A           mulHLbyDE2sc:           ld      a,d
 378+ 71EA AC                                   xor     h
 379+ 71EB E6 80                                and     SignOnly8Bit
 380+ 71ED FD 67                                ld      iyh,a               ; save sign bit for result
 381+ 71EF 7C                                   ld      a,h
 382+ 71F0 E6 80                                and     SignOnly8Bit
 383+ 71F2 28 06                                jr      z,.HLPositive
 384+ 71F4              .HLNegative:            NegHL
 384+ 71F4 AF          >                    xor a
 384+ 71F5 95          >                    sub l
 384+ 71F6 6F          >                    ld l,a
 384+ 71F7 9F          >                    sbc a,a
 384+ 71F8 94          >                    sub h
 384+ 71F9 67          >                    ld h,a
 385+ 71FA 7A           .HLPositive:            ld      a,d
 386+ 71FB E6 80                                and     SignOnly8Bit
 387+ 71FD 28 06                                jr      z,.DEPositive
 388+ 71FF              .DENegative:            NegDE
 388+ 71FF AF          >                    xor a
 388+ 7200 93          >                    sub e
 388+ 7201 5F          >                    ld e,a
 388+ 7202 9F          >                    sbc a,a
 388+ 7203 92          >                    sub d
 388+ 7204 57          >                    ld d,a
 389+ 7205 CD 72 71     .DEPositive:            call    mulDEbyHL           ; now do calc
 390+ 7208 FD 7C                                ld      a,iyh
 391+ 720A A7                                   and     a                   ; if its 0 then we are good
 392+ 720B C8                                   ret     z
 393+ 720C
 394+ 720C
 395+ 720C              ; Mulitply HLE by D leading Sign
 396+ 720C              ; used IY A BC
 397+ 720C              ; result it loaded to DELC
 398+ 720C 7A           mulHLEbyDSigned:        ld      a,d                 ; get sign from d
 399+ 720D AC                                   xor     h                   ; xor with h to get resultant sign
 400+ 720E E6 80                                and     SignOnly8Bit        ; .
 401+ 7210 FD 67                                ld      iyh,a               ; iyh = copy of sign
 402+ 7212 7C                                   ld      a,h                 ; now HLE = ABS (HLE)
 403+ 7213 E6 7F                                and     SignMask8Bit        ; .
 404+ 7215 67                                   ld      h,a                 ; .
 405+ 7216 7A                                   ld      a,d                 ; d = ABS D
 406+ 7217 E6 7F                                and     SignMask8Bit        ; .
 407+ 7219 57                                   ld      d,a                 ; .
 408+ 721A B7           .testEitherSideZero:    or      a
 409+ 721B 28 24                                jr      z,.ResultZero
 410+ 721D 7C                                   ld      a,h
 411+ 721E B5                                   or      l
 412+ 721F B3                                   or      e
 413+ 7220 28 1F                                jr      z,.ResultZero
 414+ 7222              ; At this point HLE = ABS (HLE), A = ABS(D)
 415+ 7222 42                                   ld      b,d                 ; save Quotient
 416+ 7223 ED 30        .mul1:                  mul     de                  ; C = E * D
 417+ 7225 4B                                   ld      c,e                 ; C = p0
 418+ 7226 FD 6A                                ld      iyl,d               ; save carry (p1)
 419+ 7228 5D           .mul2:                  ld      e,l                 ; L = L * D
 420+ 7229 50                                   ld      d,b                 ; .
 421+ 722A ED 30                                mul     de                  ; .
 422+ 722C FD 7D                                ld      a,iyl               ; get back p1
 423+ 722E 83           .carrybyte1:            add     a,e                 ; L = L + E
 424+ 722F 6F                                   ld      l,a                 ; .
 425+ 7230 FD 6A                                ld      iyl,d               ; save new carry byte
 426+ 7232 5C           .mul3:                  ld      e,h                 ; E = H * D
 427+ 7233 50                                   ld      d,b                 ; .
 428+ 7234 ED 30                                mul     de                  ; .
 429+ 7236 FD 7D                                ld      a,iyl
 430+ 7238 8B                                   adc     a,e                 ; .
 431+ 7239 5F                                   ld      e,a                 ; .
 432+ 723A 7A           .ItsNotZero:            ld      a,d                 ;
 433+ 723B CE 00                                adc     a,0                 ; final carry bit
 434+ 723D FD B4                                or      iyh                 ; bring back sign
 435+ 723F 57                                   ld      d,a                 ; s = sign
 436+ 7240 C9                                   ret
 437+ 7241 11 00 00     .ResultZero:            ld      de,0
 438+ 7244                                      ZeroA
 438+ 7244 AF          >                        xor a
 439+ 7245 4F                                   ld      c,a
 440+ 7246 6F                                   ld      l,a
 441+ 7247 C9                                   ret
 442+ 7248
 443+ 7248              ;;;
 444+ 7248              ;;;
 445+ 7248              ;;;mulHLEbyDSigned:        ld      a,d                 ; get sign from d
 446+ 7248              ;;;                        xor     h                   ; xor with h to get resultant sign
 447+ 7248              ;;;                        and     SignOnly8Bit        ; .
 448+ 7248              ;;;                        ld      iyh,a               ; iyh = copy of sign
 449+ 7248              ;;;                        ld      a,h                 ; now HLE = ABS (HLE)
 450+ 7248              ;;;                        and     SignMask8Bit        ; .
 451+ 7248              ;;;                        ld      h,a                 ; .
 452+ 7248              ;;;                        ld      a,d                 ; d = ABS D
 453+ 7248              ;;;                        and     SignMask8Bit        ; .
 454+ 7248              ;;;                        ld      d,a                 ; .
 455+ 7248              ;;;.testEitherSideZero:    or      a
 456+ 7248              ;;;                        jr      z,.ResultZero
 457+ 7248              ;;;                        ld      a,h
 458+ 7248              ;;;                        or      l
 459+ 7248              ;;;                        or      e
 460+ 7248              ;;;                        jr      z,.ResultZero
 461+ 7248              ;;;; At this point HLE = ABS (HLE), A = ABS(D)
 462+ 7248              ;;;.mul1:                  mul     de                  ; C = E * D
 463+ 7248              ;;;                        ex      af,af'              ; save mulitplier
 464+ 7248              ;;;                        ld      c,e                 ; C = p0
 465+ 7248              ;;;                        ld      a,d                 ; save carry (p1)
 466+ 7248              ;;;                        ex      af,af'              ; .
 467+ 7248              ;;;.mul2:                  ld      e,l                 ; L = L * D
 468+ 7248              ;;;                        ld      d,a                 ; .
 469+ 7248              ;;;                        mul     de                  ; .
 470+ 7248              ;;;                        ex      af,af'              ; .
 471+ 7248              ;;;.carrybyte1:            add     a,e                 ; L = L + E
 472+ 7248              ;;;                        ld      l,a                 ; .
 473+ 7248              ;;;                        ld      a,d
 474+ 7248              ;;;                        ex      af,af'              ; save new carry byte
 475+ 7248              ;;;.mul3:                  ld      e,h                 ; E = H * D
 476+ 7248              ;;;                        ld      d,a                 ; .
 477+ 7248              ;;;                        mul     de                  ; .
 478+ 7248              ;;;                        ex      af,af'              ; .
 479+ 7248              ;;;                        adc     a,e                 ; .
 480+ 7248              ;;;                        ld      e,a                 ; .
 481+ 7248              ;;;.ItsNotZero:            ld      a,d                 ;
 482+ 7248              ;;;                        adc     a,0                 ; final carry bit
 483+ 7248              ;;;                        or      iyh                 ; bring back sign
 484+ 7248              ;;;                        ld      d,a                 ; s = sign
 485+ 7248              ;;;                        ret
 486+ 7248              ;;;.ResultZero:            ld      de,0
 487+ 7248              ;;;                        ZeroA
 488+ 7248              ;;;                        ld      c,a
 489+ 7248              ;;;                        ld      l,a
 490+ 7248              ;;;                        ret
 491+ 7248
 492+ 7248              ; multiplication of two S156-bit numbers into a 16-bit 2'd compliment product
 493+ 7248              ; enter : de = 16-bit multiplicand
 494+ 7248              ;         hl = 16-bit multiplicand
 495+ 7248              ; exit  : hl = 16-bit product
 496+ 7248              ;         carry reset
 497+ 7248              ;
 498+ 7248              ; uses  : af, bc, de, hl
 499+ 7248 00           mulDEbyHLSignByte       DB      0
 500+ 7249 AF           mulDEbyHLSgnTo2c:       xor     a
 501+ 724A 32 48 72                             ld      (mulDEbyHLSignByte),a
 502+ 724D 7A           .SignDE:                ld      a,d
 503+ 724E ED 27 80                             test    $80
 504+ 7251 28 08                                jr      z,.SignHL
 505+ 7253 E6 7F        .NegativeDE:            and     $7F
 506+ 7255 57                                   ld      d,a
 507+ 7256 3E 80                                ld      a,$80
 508+ 7258 32 48 72                             ld      (mulDEbyHLSignByte),a
 509+ 725B 7C           .SignHL:                ld      a,h
 510+ 725C ED 27 80                             test    $80
 511+ 725F 28 0B                                jr      z,.AbsoluteMultiply
 512+ 7261 E6 7F        .NegativeHL:            and     $7F
 513+ 7263 67                                   ld      h,a
 514+ 7264 3A 48 72                             ld      a,(mulDEbyHLSignByte)
 515+ 7267 EE 80                                xor     $80
 516+ 7269 32 48 72                             ld      (mulDEbyHLSignByte),a
 517+ 726C CD 72 71     .AbsoluteMultiply:      call    mulDEbyHL
 518+ 726F 3A 48 72     .RecoverSign:           ld      a,(mulDEbyHLSignByte)
 519+ 7272 ED 27 80                             test    $80
 520+ 7275 C8                                   ret     z
 521+ 7276 AF           .Negateghl: 			xor 	a
 522+ 7277 95                                   sub 	l
 523+ 7278 6F                                   ld 		l,a
 524+ 7279 9F                                   sbc 	a,a
 525+ 727A 94                                   sub 	h
 526+ 727B 67                                   ld 		h,a
 527+ 727C C9                                   ret
 528+ 727D
 529+ 727D AF           mulDESgnbyHLUnsgnTo2c:  xor     a
 530+ 727E 32 48 72                             ld      (mulDEbyHLSignByte),a
 531+ 7281 7A           .SignDE:                ld      a,d
 532+ 7282 ED 27 80                             test    $80
 533+ 7285 28 08                                jr      z,.AbsoluteMultiply
 534+ 7287 E6 7F        .NegativeDE:            and     $7F
 535+ 7289 57                                   ld      d,a
 536+ 728A 3E 80                                ld      a,$80
 537+ 728C 32 48 72                             ld      (mulDEbyHLSignByte),a
 538+ 728F CD 72 71     .AbsoluteMultiply:      call    mulDEbyHL
 539+ 7292 3A 48 72     .RecoverSign:           ld      a,(mulDEbyHLSignByte)
 540+ 7295 ED 27 80                             test    $80
 541+ 7298 C8                                   ret     z
 542+ 7299 AF           .Negateghl:             xor 	a
 543+ 729A 95                                   sub 	l
 544+ 729B 6F                                   ld 		l,a
 545+ 729C 9F                                   sbc 	a,a
 546+ 729D 94                                   sub 	h
 547+ 729E 67                                   ld 		h,a
 548+ 729F C9                                   ret
 549+ 72A0
 550+ 72A0
# file closed: ../../Maths/asm_multiply.asm
1344  72A0                  INCLUDE "../../Maths/asm_square.asm"
# file opened: ../../Maths/asm_square.asm
   1+ 72A0              ; "ASM_SQUA : TESTGOOD"
   2+ 72A0              ; "AP = A^2 A = low,P = hi"
   3+ 72A0
   4+ 72A0              inline_squde: MACRO
   5+ 72A0 ~            			ld	e,a
   6+ 72A0 ~            			ld  d,a
   7+ 72A0 ~            			mul
   8+ 72A0              			ENDM
   9+ 72A0
  10+ 72A0              inline_squa: MACRO
  11+ 72A0 ~            			ld	e,a
  12+ 72A0 ~            			ld  d,a
  13+ 72A0 ~            			mul
  14+ 72A0 ~            			ld	a,e
  15+ 72A0              			ENDM
  16+ 72A0
# file closed: ../../Maths/asm_square.asm
1345  72A0                  INCLUDE "../../Maths/asm_sine.asm"
# file opened: ../../Maths/asm_sine.asm
   1+ 72A0              ;- MACROS
   2+ 72A0              LookupSineAMacro:       MACRO
   3+ 72A0 ~                                    ld      hl,SNE                      ; Set Q = sin(X)  = sin(CNT2 mod 32) = |sin(CNT2)|
   4+ 72A0 ~                                    add     hl, a
   5+ 72A0 ~                                    ld      a,(hl)
   6+ 72A0                                      ENDM
   7+ 72A0
   8+ 72A0              ; Gets the sine of A from the lookup table into A
   9+ 72A0              LookupSineA:            LookupSineAMacro
   9+ 72A0 21 65 73    >                        ld      hl,SNE                      ; Set Q = sin(X)  = sin(CNT2 mod 32) = |sin(CNT2)|
   9+ 72A3 ED 31       >                        add     hl, a
   9+ 72A5 7E          >                        ld      a,(hl)
  10+ 72A6 C9                                   ret
  11+ 72A7
# file closed: ../../Maths/asm_sine.asm
1346  72A7                  INCLUDE "../../Maths/asm_sqrt.asm"
# file opened: ../../Maths/asm_sqrt.asm
   1+ 72A7              ; "ASM SQRT : TESTGOOD"
   2+ 72A7              ; "16-bit integer square root"
   3+ 72A7              ; "call with de = number to square root"
   4+ 72A7              ; "returns   hl = square root"
   5+ 72A7              ; "corrupts  bc, de"
   6+ 72A7              asm_sqrt:
   7+ 72A7 01 00 80     	ld bc,$8000
   8+ 72AA 61           	ld h,c
   9+ 72AB 69           	ld l,c
  10+ 72AC              .sqrloop:
  11+ 72AC CB 38        	srl b
  12+ 72AE CB 19        	rr c
  13+ 72B0 09           	add hl,bc
  14+ 72B1 EB           	ex de,hl
  15+ 72B2 ED 52        	sbc hl,de
  16+ 72B4 38 04        	jr c,.sqrbit
  17+ 72B6 EB           	ex de,hl
  18+ 72B7 09           	add hl,bc
  19+ 72B8 18 05        	jr .sqrfi
  20+ 72BA              .sqrbit:
  21+ 72BA 19           	add hl,de
  22+ 72BB EB           	ex de,hl
  23+ 72BC B7           	or a
  24+ 72BD ED 42        	sbc hl,bc
  25+ 72BF              .sqrfi:
  26+ 72BF CB 3C        	srl h
  27+ 72C1 CB 1D        	rr l
  28+ 72C3 CB 38        	srl b
  29+ 72C5 CB 19        	rr c
  30+ 72C7 30 E3        	jr nc,.sqrloop
  31+ 72C9 C9           	ret
  32+ 72CA
  33+ 72CA
  34+ 72CA              sqrtQR:					; Q = SQR(Qlo.Rhi) Q <~127
  35+ 72CA 3A 16 6C     	ld		a,(varQ)
  36+ 72CD 5F           	ld		e,a
  37+ 72CE 3A 17 6C     	ld		a,(varR)
  38+ 72D1 57           	ld		d,a
  39+ 72D2 CD A7 72     	call	asm_sqrt
  40+ 72D5 7D               ld      a,l
  41+ 72D6 32 16 6C     	ld		(varQ),a
  42+ 72D9 C9           	ret
  43+ 72DA
# file closed: ../../Maths/asm_sqrt.asm
1347  72DA                  INCLUDE "../../Maths/asm_arctan.asm"
# file opened: ../../Maths/asm_arctan.asm
   1+ 72DA              ;Calculate A = arctan(P / Q)
   2+ 72DA              ; This finds the angle in the right-angled triangle where the opposite side to angle A is length P and the adjacent side to angle A has
   3+ 72DA              ; length Q, so:  tan(A) = P / Q
   4+ 72DA              ;
   5+ 72DA              ; The result in A is an integer representing the angle in radians. The routine returns values in the range 0 to 128,  (or 0 to PI radians).
   6+ 72DA 3A 16 6B     ARCTAN:                 ld      a,(varP)                    ; LDA P                  \ Set T1 = P EOR Q, which will have the sign of P * Q
   7+ 72DD 21 16 6C                             ld      hl,varQ                     ; EOR Q
   8+ 72E0 AE                                   xor     (hl)                        ; .
   9+ 72E1 32 13 6B                             ld      (varT1),a                   ; STA T1
  10+ 72E4 3A 16 6C                             ld      a,(varQ)                    ; LDA Q                  \ If Q = 0, jump to AR2 to return a right angle
  11+ 72E7 A7                                   and     a                           ; BEQ AR2
  12+ 72E8 CA 2A 73                             jp      z, .AR2                     ; .
  13+ 72EB CB 27                                sla     a                           ; ASL A                  \ Set Q = |Q| * 2 (this is a quick way of clearing the
  14+ 72ED 32 16 6C                             ld      (varQ),a                    ; STA Q                  \ sign bit, and we don't need to shift right again as we only ever use this value in the division with |P| * 2, which we set next)
  15+ 72F0 3A 16 6B                             ld      a,(varP)                    ; LDA P                  \ Set A = |P| * 2
  16+ 72F3 CB 27                                sla     a                           ; ASL A
  17+ 72F5 32 16 6B                             ld      (varP),a
  18+ 72F8 21 16 6C                             ld      hl,varQ
  19+ 72FB BE                                   cp      (hl)                        ; CMP Q                  \ If A >= Q, i.e. |P| > |Q|, jump to AR1 to swap P
  20+ 72FC D2 0E 73                             jp      nc, .AR1                    ; BCS AR1                \ and Q around, so we can still use the lookup table
  21+ 72FF CD 36 73                             call    ARS1                        ; JSR ARS1               \ Call ARS1 to set the following from the lookup table:  A = arctan(A / Q)  = arctan(|P / Q|)
  22+ 7302                                      ClearCarryFlag                      ; SEC                    \ Set the C flag so the SBC instruction in AR3 will be correct, should we jump there
  22+ 7302 B7          >                        or a
  23+ 7303 4F           .AR4:                   ld      c,a                         ; as we have to use a we use c as a temp, we can't push af as we would loose flags on pop
  24+ 7304 3A 13 6B                             ld      a,(varT1)                   ; LDX T1                 \ If T1 is negative, i.e. P and Q have different signs,
  25+ 7307 47                                   ld      b,a                         ; .
  26+ 7308 A7                                   and     a                           ; BMI AR3                \ jump down to AR3 to return arctan(-|P / Q|)
  27+ 7309 79                                   ld      a,c                         ; .                      \ we need to get a back before jump
  28+ 730A FA 2D 73                             jp      m, .AR3                     ; .
  29+ 730D C9                                   ret                                 ; RTS                    \ Otherwise P and Q have the same sign, so our result is correct and we can return from the subroutine
  30+ 730E              ; We want to calculate arctan(t) where |t| > 1, so we can use the calculation described in the documentation for the ACT table, i.e. 64 - arctan(1 / t)
  31+ 730E              ; In the 6502 verion it works with A already being P but we will fetch it
  32+ 730E 3A 16 6C     .AR1:                   ld      a,(varQ)                    ; LDX Q                  \ Swap the values in Q and P, using the fact that we
  33+ 7311 47                                   ld      b,a                         ; .
  34+ 7312 3A 16 6B                             ld      a,(varP)                    ; STA Q                  \ called AR1 with A = P
  35+ 7315 32 16 6C                             ld      (varQ),a                    ; .
  36+ 7318 78                                   ld      a,b                         ; TXA                    \ This also sets A = P (which now contains the original argument |Q|)
  37+ 7319 32 16 6B                             ld      (varP),a                    ; STX P                  \
  38+ 731C CD 36 73                             call    ARS1                        ; JSR ARS1               \ Call ARS1 to set the following from the lookup table: A = arctan(A / Q) = arctan(|Q / P|) = arctan(1 / |P / Q|)
  39+ 731F 32 32 6C                             ld      (varT),a                    ; STA T                  \ Set T = 64 - T, we use B as T (its not really that)
  40+ 7322 47                                   ld      b,a                         ; its actually t = a, a = 64-a
  41+ 7323 3E 40                                ld      a,64                        ; LDA #64 What is going on here is t = result
  42+ 7325                                      ClearCarryFlag                      ; SBC T                            a = 64- result
  42+ 7325 B7          >                        or a
  43+ 7326 98                                   sbc     a,b                         ; .
  44+ 7327 C3 03 73                             jp      .AR4                        ; BCS AR4                \ Jump to AR4 to continue the calculation (this BCS is effectively a JMP as the subtraction will never underflow, as ARS1 returns values in the range 0-31)
  45+ 732A              ; If we get here then Q = 0, so tan(A) = infinity and A is a right angle, or 0.25 of a circle. We allocate 255 to a full circle, so we should return 63 for a right angle
  46+ 732A 3E 3F        .AR2:                   ld      a,63                        ; LDA #63                \ Set A to 63, to represent a right angle
  47+ 732C C9                                   ret                                 ; RTS                    \ Return from the subroutine
  48+ 732D              ; A contains arctan(|P / Q|) but P and Q have different signs, so we need to return arctan(-|P / Q|), using the calculation described in the documentation for the ACT table, i.e. 128 - A
  49+ 732D 32 32 6C     .AR3:                   ld      (varT),a
  50+ 7330 47                                   ld      b,a                         ; STA T                  \ Set A = 128 - A, we use b as T
  51+ 7331 3E 80                                ld      a,128                       ; LDA #128               \
  52+ 7333                                      ClearCarryFlag                      ; SBC T                  \ The subtraction will work because we did a SEC before calling AR3
  52+ 7333 B7          >                        or a
  53+ 7334 98                                   sbc     a,b
  54+ 7335 C9                                   ret                                 ; RTS                    \ Return from the subroutine
  55+ 7336              ; This routine fetches arctan(A / Q) from the ACT table, so A will be set to an integer in the range 0 to 31 that represents an angle from 0 to 45 degrees (or 0 to \ PI / 4 radians)
  56+ 7336 CD 50 74     ARS1:                   call    Amul256DivQ                 ; JSR LL28               \ Call LL28 to calculate: R = 256 * A / Q
  57+ 7339 3A 17 6C                             ld      a,(varR)                    ; LDA R                  \ Set X = R / 8
  58+ 733C CB 3F                                srl     a                           ; LSR A                  \       = 32 * A / Q
  59+ 733E CB 3F                                srl     a                           ; LSR A                  \
  60+ 7340 CB 3F                                srl     a                           ; LSR A                  \ so X has the value t * 32 where t = A / Q, which is
  61+ 7342 21 85 73                             ld      hl,ACT                      ; TAX                    \ what we need to look up values in the ACT table
  62+ 7345 ED 31                                add     hl,a                        ; LDA ACT,X              \ Fetch ACT+X from the ACT table into A, so now:
  63+ 7347 7E                                   ld      a,(hl)                      ;                        \   A = value in ACT + X = value in ACT + (32 * A / Q)= arctan(A / Q)
  64+ 7348 C9                                   ret                                 ; RTS                    \ Return from the subroutine
  65+ 7349
  66+ 7349              ;;;arctan:										; .ARCTAN	\ -> &2A3C  \ A=TAN-1(P/Q) \ A=arctan (P/Q)  called from block E
  67+ 7349              ;;;		ld		a,(varP)					; a = var P
  68+ 7349              ;;;		ld		hl,varQ
  69+ 7349              ;;;		xor		(hl)						; a = var p XOR varQ
  70+ 7349              ;;;		ld		a,(varT1)					; \ T1	 \ quadrant info
  71+ 7349              ;;;		ld		c,a							; c = copy of T1
  72+ 7349              ;;;		ld		a,(hl)						; Q
  73+ 7349              ;;;		cp		0
  74+ 7349              ;;;		jr		z,.AR2						;  Q=0 so set angle to 63, pi/2
  75+ 7349              ;;;		ld		(varQ),a					; Q move to reg B?
  76+ 7349              ;;;		ld		d,a							; copy to reg d
  77+ 7349              ;;;		sla		a							; drop sign
  78+ 7349              ;;;		ld		a,(varP)					; P
  79+ 7349              ;;;		ld		e,a							; copy to reg e
  80+ 7349              ;;;		sla		a							; drop sign
  81+ 7349              ;;;		cp		d							; compare with b (unsigned varQ * 2)
  82+ 7349              ;;;		jr		nc, .ars1					; if q >  p then adjust  swop A and Q as A >= Q
  83+ 7349              ;;;		call	ars1						; \ ARS1 \ get Angle for A*32/Q from table.
  84+ 7349              ;;;		scf									; set carry flag
  85+ 7349              ;;;.ar4:										; sub o.k
  86+ 7349              ;;;		bit 	7,c							; is T1 (also in c) negative?
  87+ 7349              ;;;		jr		nz,.ar3						;  -ve quadrant
  88+ 7349              ;;;		ret
  89+ 7349              ;;;.ar1:										; swop A and Q entering here d = q and e = P
  90+ 7349              ;;;		ld		a,d							; a = varQ
  91+ 7349              ;;;		ld		d,e							; varQ = varP
  92+ 7349              ;;;		ld		e,a							; swap D and E around
  93+ 7349              ;;;		ld		(varP),a					; write to actual variables
  94+ 7349              ;;;		ld		a,d
  95+ 7349              ;;;		ld		(varQ),a					; write to actual variables
  96+ 7349              ;;;		call	.ars1
  97+ 7349              ;;;		ld		(varT),b
  98+ 7349              ;;;		ld		b,a							; B = T = angle
  99+ 7349              ;;;		ld		a,64						; next range of angle, pi/4 to pi/2
 100+ 7349              ;;;		sub		a,b							; a = 64 - T (or b)
 101+ 7349              ;;;		jr		nc,.ar4						;  sub o.k
 102+ 7349              ;;;.ar2:										; .AR2	\ set angle to 90 degrees
 103+ 7349              ;;;		ld 		a,&3F						;  #63
 104+ 7349              ;;;		ret
 105+ 7349              ;;;.ar3:										;.AR3	\ -ve quadrant
 106+ 7349              ;;;		ld		b,a							; b = T	= \ angle
 107+ 7349              ;;;		ld		a,ConstPi					; a = Pi
 108+ 7349              ;;;		sub		b,a							; A = 128-T, so now covering range pi/2 to pi correctly
 109+ 7349              ;;;		ret
 110+ 7349              ;;;.ars1:										; .ARS1	\ -> &2A75  \ get Angle for A*32/Q from table.
 111+ 7349              ;;;		call	RequAmul256divQ				;  LL28 \ BFRDIV R=A*256/Q
 112+ 7349              ;;;		ld		a,(regA)
 113+ 7349              ;;;		srl		a
 114+ 7349              ;;;		srl		a
 115+ 7349              ;;;		srl		a							;  31 max.
 116+ 7349              ;;;		ld		hl, ArcTanTable				; root of index into table at end of words data
 117+ 7349              ;;;		add		hl,a						; now at real data
 118+ 7349              ;;;		ld		a,(hl)						; a =  ACT[a]
 119+ 7349              ;;;.arsr:										; rts used by laser lines below (will not in later code)
 120+ 7349              ;;;		ret
 121+ 7349
 122+ 7349
 123+ 7349
# file closed: ../../Maths/asm_arctan.asm
1348  7349                  INCLUDE "../../Maths/asm_arccos.asm"
# file opened: ../../Maths/asm_arccos.asm
   1+ 7349              ;Calculate a = arccos (b a) where b is the sign and a is the value
   2+ 7349 CB 78        ArcCos:                 bit     7,b
   3+ 734B CA 54 73                             jp      z,.PositiveTable
   4+ 734E 21 CA 73     .NegativeTable:         ld      hl,ArcNegPosTable
   5+ 7351 C3 57 73                             jp      .LookupAngle
   6+ 7354 21 A5 73     .PositiveTable:         ld      hl,ArcCosPosTable
   7+ 7357              .LookupAngle:           JumpIfAGTENusng 37, .NaN
   7+ 7357 FE 25       >                        cp     37
   7+ 7359 D2 61 73    >                        jp		nc,.NaN
   8+ 735C ED 31                                add     hl,a
   9+ 735E 7E                                   ld      a,(hl)
  10+ 735F                                      ClearCarryFlag
  10+ 735F B7          >                        or a
  11+ 7360 C9                                   ret
  12+ 7361 3E FF        .NaN:                   ld      a,$FF
  13+ 7363                                      SetCarryFlag
  13+ 7363 37          >                        scf
  14+ 7364 C9                                   ret
  15+ 7365
# file closed: ../../Maths/asm_arccos.asm
1349  7365                  INCLUDE "../../Maths/SineTable.asm"
# file opened: ../../Maths/SineTable.asm
   1+ 7365              ;; PRINT "SIN TABLE"
   2+ 7365              ;; FOR I% =  0 TO  31
   3+ 7365              ;; N = ABS(SIN((I%/64)*2*PI))
   4+ 7365              ;; IF N >= 1 THEN B% = 255  ELSE B% = INT(256 * N + 0.5)
   5+ 7365              ;; PRINT B%
   6+ 7365              ;; NEXT I%
   7+ 7365
   8+ 7365
   9+ 7365 00 19 32 4A  SNE:            DB 000, 025, 050, 074, 098, 121, 142, 162
   9+ 7369 62 79 8E A2
  10+ 736D B5 C6 D5 E2                  DB 181, 198, 213, 226, 237, 245, 251, 255
  10+ 7371 ED F5 FB FF
  11+ 7375 FF FF FB F5                  DB 255, 255, 251, 245, 237, 226, 213, 198
  11+ 7379 ED E2 D5 C6
  12+ 737D B5 A2 8E 79                  DB 181, 162, 142, 121, 098, 074, 050, 025
  12+ 7381 62 4A 32 19
# file closed: ../../Maths/SineTable.asm
1350  7385                  INCLUDE "../../Maths/ArcTanTable.asm"
# file opened: ../../Maths/ArcTanTable.asm
   1+ 7385              ;PRINT "ARCTAN TABLE"
   2+ 7385              ;FOR I% = 0 TO 31
   3+ 7385              ;    PRINT INT((128/PI) * ATN(I%/32)+0.5)
   4+ 7385              ;NEXT I%
   5+ 7385
   6+ 7385 00 01 03 04  ACT:            DB 000, 001, 003, 004, 005, 006, 008, 009
   6+ 7389 05 06 08 09
   7+ 738D 0A 0B 0C 0D                  DB 010, 011, 012, 013, 015, 016, 017, 018
   7+ 7391 0F 10 11 12
   8+ 7395 13 14 15 16                  DB 019, 020, 021, 022, 023, 024, 025, 025
   8+ 7399 17 18 19 19
   9+ 739D 1A 1B 1C 1D                  DB 026, 027, 028, 029, 030, 031, 031, 031
   9+ 73A1 1E 1F 1F 1F
  10+ 73A5
# file closed: ../../Maths/ArcTanTable.asm
1351  73A5                  INCLUDE "../../Maths/ArcCosTable.asm"
# file opened: ../../Maths/ArcCosTable.asm
   1+ 73A5              ;                            0   1   2   3   4   5   6   7   8   9
   2+ 73A5 5A 58 56 55  ArcCosPosTable:	        db  90, 88, 86, 85, 83, 82, 80, 78, 77, 75
   2+ 73A9 53 52 50 4E
   2+ 73AD 4D 4B
   3+ 73AF 49 48 46 44                          db  73, 72, 70, 68, 67, 65, 63, 61, 60, 58
   3+ 73B3 43 41 3F 3D
   3+ 73B7 3C 3A
   4+ 73B9 38 36 34 32                          db  56, 54, 52, 50, 48, 46, 43, 41, 38, 36
   4+ 73BD 30 2E 2B 29
   4+ 73C1 26 24
   5+ 73C3 21 1E 1B 17                          db  33, 30, 27, 23, 19, 13, 0
   5+ 73C7 13 0D 00
   6+ 73CA
   7+ 73CA 5A 5B 5D 5E  ArcNegPosTable:	        db	90, 91, 93, 94, 96, 97, 99,101,102,104
   7+ 73CE 60 61 63 65
   7+ 73D2 66 68
   8+ 73D4 7B 7D 7F 81                          db 123,125,127,129,131,133,136,138,141,143
   8+ 73D8 83 85 88 8A
   8+ 73DC 8D 8F
   9+ 73DE 92 95 98 9C                          db 146,149,152,156,160,166,180
   9+ 73E2 A0 A6 B4
  10+ 73E5
# file closed: ../../Maths/ArcCosTable.asm
1352  73E5                  INCLUDE "../../Maths/negate16.asm"
# file opened: ../../Maths/negate16.asm
   1+ 73E5              ;;----------------------------------------------------------------------------------------------------------------------
   2+ 73E5              ;; 16-bit negate
   3+ 73E5                      ; Input:
   4+ 73E5                      ;       HL = value
   5+ 73E5                      ; Output:
   6+ 73E5                      ;       HL = -value
   7+ 73E5                      ; Destroys:
   8+ 73E5                      ;       AF
   9+ 73E5                      ;
  10+ 73E5              negate16:
  11+ 73E5 AF           negate16hl:         xor 	a
  12+ 73E6 95                               sub 	l
  13+ 73E7 6F                               ld 		l,a
  14+ 73E8 9F                               sbc 	a,a
  15+ 73E9 94                               sub 	h
  16+ 73EA 67                               ld 		h,a
  17+ 73EB C9                               ret
  18+ 73EC
  19+ 73EC AF           negate16de:         xor 	a
  20+ 73ED 93                               sub 	e
  21+ 73EE 5F                               ld 		e,a
  22+ 73EF 9F                               sbc 	a,a
  23+ 73F0 92                               sub 	d
  24+ 73F1 57                               ld 		d,a
  25+ 73F2 C9                               ret
  26+ 73F3
  27+ 73F3 AF           negate16bc:         xor 	a
  28+ 73F4 91                               sub 	c
  29+ 73F5 4F                               ld 		c,a
  30+ 73F6 9F                               sbc 	a,a
  31+ 73F7 90                               sub 	b
  32+ 73F8 47                               ld 		b,a
  33+ 73F9 C9                               ret
  34+ 73FA
# file closed: ../../Maths/negate16.asm
1353  73FA                  INCLUDE "../../Maths/asm_divide.asm"
# file opened: ../../Maths/asm_divide.asm
   1+ 73FA              ;   K(3 2 1 0)           The result of the division
   2+ 73FA              ;   X                    X is preserved
   3+ 73FA
   4+ 73FA              ; Calculate K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo) where zsign hi lo is in DE with zsign leading hi
   5+ 73FA 00 00 00 00  varQRS                 DS      4
   6+ 73FE 00 00 00     varAPP                 DS     3
   7+ 7401 00           Rvar                   DS     1
   8+ 7402
   9+ 7402                                  DISPLAY "TODO:  neds rewrite of whoel DIDV3B2"
  10+ 7402              ;; NEEDS REWRITE TODO OF WHOLE DIVD3B2
  11+ 7402              ;; NEEDS REWRITE TODO
  12+ 7402
  13+ 7402              ; b = varR, c= varQ
  14+ 7402              Requ256mulAdivQ_6502:
  15+ 7402 CB 27        .LL31_6502:             sla     a                       ; ASL A                   \ Shift A to the left
  16+ 7404 DA 19 74                             jp      c,.LL29_6502            ; BCS LL29               \ If bit 7 of A was set, then jump straight to the subtraction
  17+ 7407                                      FlipCarryFlag                   ;                          If A < N, then C flag is set.
  17+ 7407 3F          >                        ccf
  18+ 7408                                      JumpIfALTNusng c, .LL31_SKIPSUB_6502 ; CMP Q              \ If A < Q, skip the following subtraction
  18+ 7408 B9          >                        cp      c
  18+ 7409 DA 0E 74    >                        jp		c, .LL31_SKIPSUB_6502
  19+ 740C                                                                      ; BCC P%+4
  20+ 740C 91                                   sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  21+ 740D                                      ClearCarryFlag
  21+ 740D B7          >                        or a
  22+ 740E              .LL31_SKIPSUB_6502:     FlipCarryFlag
  22+ 740E 3F          >                        ccf
  23+ 740F CB 10                                rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  24+ 7411 DA 02 74                             jp      c, .LL31_6502            ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  25+ 7414 78                                   ld      a,b
  26+ 7415 32 01 74                             ld      (Rvar),a
  27+ 7418 C9                                   ret                             ; RTS                    \ R left with remainder of division
  28+ 7419 91           .LL29_6502:             sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  29+ 741A                                      SetCarryFlag                    ; SEC                    \ Set the C flag to rotate into the result in R
  29+ 741A 37          >                        scf
  30+ 741B CB 10                                rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  31+ 741D DA 02 74                             jp      c, .LL31_6502            ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  32+ 7420 78                                   ld      a,b                     ; RTS                    \ Return from the subroutine with R containing the
  33+ 7421 32 01 74                             ld      (Rvar),a                ; .
  34+ 7424 C9                                   ret                             ; .                      \ remainder of the division
  35+ 7425 3E FF        .LL2_6502:              ld      a,$FF                   ; LDA #255               \ The division is very close to 1, so return the closest
  36+ 7427 32 17 6C                             ld      (varR),a                ; STA R                  \ possible answer to 256, i.e. R = 255
  37+ 742A 47                                   ld      b,a                     ; as we are using b as varR
  38+ 742B                                      SetCarryFlag                    ; we failed so need carry flag set
  38+ 742B 37          >                        scf
  39+ 742C C9                                   ret                             ; RTS                    \ Return from the subroutine
  40+ 742D                             DISPLAY "TODO : Merge Requ256mulAdivQ_6502  RequAmul256divQ"
  41+ 742D              ; Entry point if varQ is populated with demoninator
  42+ 742D              RequAmul256divQ:
  43+ 742D F5           BFRDIV:                 push	af
  44+ 742E 3A 16 6C                             ld		a,(varQ)
  45+ 7431 4F                                   ld		c,a
  46+ 7432 F1                                   pop		af
  47+ 7433 FE 00                                cp		0
  48+ 7435 CA 4C 74                             jp		z, HLDIVC_0_BY	; fast exit if numerator is 0
  49+ 7438 2E 00        RequAmul256divC:        ld		l,0
  50+ 743A 67                                   ld		h,a
  51+ 743B 06 10        HL_Div_Cold:			ld b,16			; fast entry point if C and HL are already set
  52+ 743D AF                                   xor a
  53+ 743E 29           LOOPPOINT:	            add hl,hl
  54+ 743F 17                                   rla
  55+ 7440 B9                                   cp c
  56+ 7441 38 02                                jr c,SKIPINCSUB
  57+ 7443 2C                                   inc l
  58+ 7444 91                                   sub c
  59+ 7445 10 F7        SKIPINCSUB:             djnz LOOPPOINT
  60+ 7447 7D                                   ld		a,l
  61+ 7448 32 17 6C                             ld 		(varR),a
  62+ 744B C9                                   ret
  63+ 744C 32 17 6C     HLDIVC_0_BY:            ld		(varR),a
  64+ 744F C9                                   ret
  65+ 7450
  66+ 7450
  67+ 7450 21 16 6C     Amul256DivQ:            ld      hl,varQ                 ; CMP Q                  \ If A >= Q, then the answer will not fit in one byte,
  68+ 7453 4E                                   ld      c,(hl)                  ; using c as Q var
  69+ 7454 B9                                   cp      c
  70+ 7455                                      FlipCarryFlag
  70+ 7455 3F          >                        ccf
  71+ 7456 DA 7E 74                             jp      c, .LL2_6502            ; BCS LL2                \ so jump to LL2 to return 255
  72+ 7459 06 FE                                ld      b,$FE                   ; LDX #%11111110         \ Set R to have bits 1-7 set, so we can rotate through 7 loop iterations, getting a 1 each time, and then we use b as Rvar
  73+ 745B CB 27        .LL31_6502:             sla     a                       ; ASL A                  \ Shift A to the left
  74+ 745D DA 72 74                             jp      c,.LL29_6502            ; BCS LL29               \ If bit 7 of A was set, then jump straight to the subtraction
  75+ 7460                                      FlipCarryFlag                   ;                          If A < N, then C flag is set.
  75+ 7460 3F          >                        ccf
  76+ 7461                                      JumpIfALTNusng c, .LL31_SKIPSUB_6502 ; CMP Q              \ If A < Q, skip the following subtraction
  76+ 7461 B9          >                        cp      c
  76+ 7462 DA 67 74    >                        jp		c, .LL31_SKIPSUB_6502
  77+ 7465                                                                      ; BCC P%+4
  78+ 7465 91                                   sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  79+ 7466                                      ClearCarryFlag
  79+ 7466 B7          >                        or a
  80+ 7467              .LL31_SKIPSUB_6502:     FlipCarryFlag
  80+ 7467 3F          >                        ccf
  81+ 7468 CB 10                                rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  82+ 746A DA 5B 74                             jp      c, .LL31_6502           ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  83+ 746D 78                                   ld      a,b
  84+ 746E 32 17 6C                             ld      (varR),a
  85+ 7471 C9                                   ret                             ; RTS                    \ R left with remainder of division
  86+ 7472 91           .LL29_6502:             sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  87+ 7473                                      SetCarryFlag                    ; SEC                    \ Set the C flag to rotate into the result in R
  87+ 7473 37          >                        scf
  88+ 7474 CB 10                                rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  89+ 7476 DA 5B 74                             jp      c, .LL31_6502           ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  90+ 7479 78                                   ld      a,b                     ; RTS                    \ Return from the subroutine with R containing the
  91+ 747A 32 17 6C                             ld      (varR),a                ; .
  92+ 747D C9                                   ret                             ; .                      \ remainder of the division
  93+ 747E 3E FF        .LL2_6502:              ld      a,$FF                   ; LDA #255               \ The division is very close to 1, so return the closest
  94+ 7480 32 17 6C                             ld      (varR),a                ; STA R                  \ possible answer to 256, i.e. R = 255
  95+ 7483                                      SetCarryFlag                    ; we failed so need carry flag set
  95+ 7483 37          >                        scf
  96+ 7484 C9                                   ret                             ; RTS                    \ Return from the subroutine
  97+ 7485
  98+ 7485
  99+ 7485 00           DIVD3B_SHIFT_REG:       DB      0
 100+ 7486
 101+ 7486 7B           DIV3B2DE:               ld      a,e                         ; load QRS with Z sign hi lo
 102+ 7487 32 FC 73                             ld      (varQRS+2),a
 103+ 748A 7A                                   ld      a,d
 104+ 748B E6 7F                                and     $7F
 105+ 748D 32 FB 73                             ld      (varQRS+1),a
 106+ 7490 7A                                   ld      a,d
 107+ 7491 E6 80                                and     $80
 108+ 7493 32 FA 73                             ld      (varQRS),a
 109+ 7496 C3 9C 74                             jp      DVID3B
 110+ 7499              ; Calculate K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo) = A P[1 0 ] / (SRQ)
 111+ 7499              ; We don't use zlo and assume its already loaded into SRQ
 112+ 7499 32 18 6B     DVID3B2:                ld      (varP+2),a                  ;STA P+2                \ Set P+2 = A
 113+ 749C                                                                          ; LDA INWK+6             \ Set Q = z_lo
 114+ 749C                                                                          ; STA Q
 115+ 749C                                                                          ; LDA INWK+7             \ Set R = z_hi
 116+ 749C                                                                          ; STA R
 117+ 749C                                                                          ; LDA INWK+8             \ Set S = z_sign
 118+ 749C                                                                          ; STA S
 119+ 749C              ;  Given the above assignments, we now want to calculate K(3 2 1 0) = P(2 1 0) / (S R Q)
 120+ 749C 3A 16 6B     DVID3B:                 ld      a,(varP)                    ; LDA P                 \ Make sure P(2 1 0) is at least 1
 121+ 749F F6 01                                or      1                           ; ORA #1
 122+ 74A1 32 16 6B                             ld      (varP),a                    ; STA P
 123+ 74A4              ;--- t = sign of P2 xor S (i.e. sign of result) ------------;
 124+ 74A4 3A 18 6B                             ld      a,(varP+2)                  ; LDA P+2                \ Set T to the sign of P+2 * S (i.e. the sign of the
 125+ 74A7 21 18 6C                             ld      hl, varS                    ; EOR S                  \ result) and store it in T
 126+ 74AA AE                                   xor     (hl)
 127+ 74AB E6 80                                and     $80                         ; AND #%10000000
 128+ 74AD 32 32 6C                             ld      (varT),a                    ; STA T
 129+ 74B0              ;--- New bit added to aviod a divde by 0 -------------------;
 130+ 74B0 3A 16 6C     .CheckQRSAtLeast1:      ld      a,(varQ)                    ;
 131+ 74B3 21 17 6C                             ld      hl,varR                     ;
 132+ 74B6 B6                                   or      (hl)                        ;
 133+ 74B7 C2 BF 74                             jp      nz,.DVL9Prep                ;
 134+ 74BA 3E 01                                ld      a,1                         ;
 135+ 74BC 32 16 6C                             ld      (varQ),a                    ;
 136+ 74BF              ; A P(1) P(0) = ABS P(2 1 0)
 137+ 74BF 06 00        .DVL9Prep:              ld      b,0                         ; LDY #0                 \ Set Y = 0 to store the scale factor (use b as Y)
 138+ 74C1 3A 18 6B                             ld      a,(varP+2)                  ; LDA P+2                \ Clear the sign bit of P+2, so the division can be done
 139+ 74C4 E6 7F                                and     $7F                         ; AND #%01111111         \ with positive numbers and we'll set the correct sign below, once all the maths is done
 140+ 74C6              ; We now shift (A P+1 P) left until A >= 64, counting the number of shifts in Y. This makes the top part of the division as large as possible, thus retaining as
 141+ 74C6              ; much accuracy as we can.  When we come to return the final result, we shift the result by the number of places in Y, and in the correct direction
 142+ 74C6                                      DISPLAY "TODO DVL9 and DVL6 move P and QRS into registers for faster shift"
 143+ 74C6              ;-- while A < 64 shift A P(1) P(0) -------------------------;
 144+ 74C6 FE 40        .DVL9:                  cp      64                          ; CMP #64                \ If A >= 64, jump down to DV14
 145+ 74C8 D2 D9 74                             jp      nc, .DV14                   ; BCS DV14
 146+ 74CB 21 16 6B                             ld      hl,varP                     ; ASL P                  \ Shift (A P+1 P) to the left
 147+ 74CE CB 26                                sla     (hl)
 148+ 74D0 23                                   inc     hl                          ; ROL P+1
 149+ 74D1 CB 16                                rl      (hl)
 150+ 74D3 CB 17                                rl      a                           ; ROL A
 151+ 74D5 04                                   inc     b                           ; INY                    \ Increment the scale factor in Y
 152+ 74D6 C3 C6 74                             jp      .DVL9                       ; BNE DVL9               \ Loop up to DVL9 (this BNE is effectively a JMP, as Y will never be zero)
 153+ 74D9              ; If we get here, A >= 64 and contains the highest byte of the numerator, scaled up by the number of left shifts in Y (b in our code)
 154+ 74D9 32 18 6B     .DV14:                  ld      (varP+2),a                  ; Store A in P+2, so we now have the scaled value of the numerator in P(2 1 0)
 155+ 74DC 3A 18 6C                             ld      a,(varS)                    ; LDA S                  \ Set A = |S|
 156+ 74DF E6 7F                                and     $7F                         ; AND #%01111111
 157+ 74E1                                      ;nop                                ;  BMI DV9               \ If bit 7 of A is set, jump down to DV9 (which can never happen)
 158+ 74E1              ; We now shift (S R Q) left until bit 7 of S is set, reducing Y by the number of shifts. This makes the bottom part of the division as large as possible, thus
 159+ 74E1              ; retaining as much accuracy as we can. When we come to return the final result, we shift the result by the total number of places in Y, and in the correct
 160+ 74E1              ; direction, to give us the correct result
 161+ 74E1              ; We set A to |S| above, so the following actually shifts (A R Q)
 162+ 74E1 05           .DVL6:                  dec     b                           ; DEY                    \ Decrement the scale factor in Y (b)
 163+ 74E2 21 16 6C                             ld      hl,varQ                     ; ASL Q                  \ Shift (A R Q) to the left
 164+ 74E5 CB 26                                sla     (hl)                        ; .
 165+ 74E7 21 17 6C                             ld      hl,varR                     ; ROL R
 166+ 74EA CB 16                                rl      (hl)                        ; .
 167+ 74EC CB 17                                rl      a                           ; ROL A
 168+ 74EE F2 E1 74                             jp      p,.DVL6                     ; BPL DVL6               \ Loop up to DVL6 to do another shift, until bit 7 of A is set and we can't shift left any further
 169+ 74F1              ; We have now shifted both the numerator and denominator left as far as they will go, keeping a tally of the overall scale factor of the various shifts in Y. We
 170+ 74F1              ; can now divide just the two highest bytes to get our result
 171+ 74F1 32 16 6C     .DV9:                   ld      (varQ),a                    ; STA Q                  \ Set Q = A, the highest byte of the denominator
 172+ 74F4 4F                                   ld      c,a                         ; for Requ256mulAdivQ_6502 as it uses c as Q
 173+ 74F5 78                                   ld      a,b                         ; preserve shift register in DEVD3B_SHIFT_REG
 174+ 74F6 32 85 74                             ld      (DIVD3B_SHIFT_REG),a
 175+ 74F9              ; Note in Requ256mulAdivQ_6502 we use B as R Var for shift register
 176+ 74F9 06 FE                                ld      b,254                       ; LDA #254               \ Set R to have bits 1-7 set, so we can pass this to
 177+ 74FB 32 17 6C                             ld      (varR),a                    ; STA R                  \ LL31 to act as the bit counter in the division
 178+ 74FE 3A 18 6B                             ld      a,(varP+2)                  ; LDA P+2                \ Set A to the highest byte of the numerator
 179+ 7501 CD 02 74                             call    Requ256mulAdivQ_6502        ; JSR LL31               \ Call LL31 to calculate: R = 256 * A / Q which means result is in b
 180+ 7504              ; The result of our division is now in R, so we just need to shift it back by the scale factor in Y
 181+ 7504                                      ZeroA                               ; LDA #0                \ Set K(3 2 1) = 0 to hold the result (we populate K)
 181+ 7504 AF          >                        xor a
 182+ 7505 32 2A 6C                             ld      (varK+1),a                  ; STA K+1               \ next)
 183+ 7508 32 2B 6C                             ld      (varK+2),a                  ; STA K+2
 184+ 750B 32 2C 6C                             ld      (varK+3),a                  ; STA K+3
 185+ 750E 3A 85 74                             ld      a,(DIVD3B_SHIFT_REG)        ; TYA                   \ If Y (shift counter in b) is positive, jump to DV12
 186+ 7511 B7                                   or      a                           ; .                      we want to check the sign or if its zero
 187+ 7512 CA 3D 75                             jp      z,.DV13                     ; Optimisation to save a second jump from DV12 to DV13
 188+ 7515 F2 48 75                             jp      p,.DV12                     ; BPL DV12
 189+ 7518              ; If we get here then Y is negative, so we need to shift the result R to the left by Y places, and then set the correct sign for the result
 190+ 7518                                      DISPLAY "TODO check oprimisation here for var r  in b"
 191+ 7518 48                                   ld      c,b
 192+ 7519 3A 85 74                             ld      a,(DIVD3B_SHIFT_REG)
 193+ 751C 47                                   ld      b,a
 194+ 751D 79                                   ld      a,c
 195+ 751E                                      ; OPTIM ld      a,(varR)                    ; LDA R                  \ Set A = R
 196+ 751E CB 27        .DVL8:                  sla     a                           ; ASL A                  \ Shift (K+3 K+2 K+1 A) left
 197+ 7520 21 2A 6C                             ld      hl,varK+1                   ; ROL K+1
 198+ 7523 CB 16                                rl      (hl)                        ; .
 199+ 7525 23                                   inc     hl                          ; ROL K+2
 200+ 7526 CB 16                                rl      (hl)                        ; .
 201+ 7528 23                                   inc     hl                          ; ROL K+3
 202+ 7529 CB 16                                rl      (hl)                        ; .
 203+ 752B 04                                   inc     b                           ; INY                    \ Increment the scale factor in Y
 204+ 752C C2 1E 75                             jp      nz,.DVL8                    ; BNE DVL8               \ Loop back to DVL8 until we have shifted left by Y places
 205+ 752F 32 29 6C                             ld      (varK),a                    ; STA K                  \ Store A in K so the result is now in K(3 2 1 0)
 206+ 7532 3A 2C 6C                             ld      a,(varK+3)                  ; LDA K+3                \ Set K+3 to the sign in T, which we set above to the
 207+ 7535 21 32 6C                             ld      hl,varT                     ; ORA T                  \ correct sign for the result
 208+ 7538 B6                                   or      (hl)                        ; .
 209+ 7539 32 2C 6C                             ld      (varK+3),a                  ; STA K+3
 210+ 753C C9                                   ret                                 ; RTS                    \ Return from the subroutine
 211+ 753D              ; If we get here then Y is zero, so we don't need to shift the result R, we just need to set the correct sign for the result
 212+ 753D 78           .DV13:                  ld      a,b; varR)                  ; LDA R                  \ Store R in K so the result is now in K(3 2 1 0)
 213+ 753E 32 29 6C                             ld      (varK),a                    ; STA K
 214+ 7541 3A 32 6C                             ld      a,(varT)                    ; LDA T                  \ Set K+3 to the sign in T, which we set above to the
 215+ 7544 32 2C 6C                             ld      (varK+3),a                  ; STA K+3                \ correct sign for the result
 216+ 7547 C9                                   ret                                 ; RTS                    \ Return from the subroutine
 217+ 7548              ; if we get here U is positive but still could be zero, now this is handled in DV9
 218+ 7548              .DV12:                  ; nop                               ; BEQ DV13               \ We jumped here having set A to the scale factor in Y, so this jumps up to DV13 if Y = 0
 219+ 7548              ; If we get here then Y is positive and non-zero, so we need to shift the result R to the right by Y places and then set the correct sign for the result. We also
 220+ 7548              ; know that K(3 2 1) will stay 0, as we are shifting the lowest byte to the right, so no set bits will make their way into the top three bytes
 221+ 7548                                      ;ld      a,(varR)                    ; LDA R                  \ Set A = R
 222+ 7548 48                                   ld      c,b
 223+ 7549 3A 85 74                             ld      a,(DIVD3B_SHIFT_REG)
 224+ 754C 47                                   ld      b,a
 225+ 754D 79                                   ld      a,c
 226+ 754E CB 3F        .DVL10:                 srl     a                           ; LSR A                  \ Shift A right
 227+ 7550 05                                   dec     b                           ; DEY                    \ Decrement the scale factor in Y
 228+ 7551 C2 4E 75                             jp      nz,.DVL10                   ; BNE DVL10              \ Loop back to DVL10 until we have shifted right by Y places
 229+ 7554 32 29 6C                             ld      (varK),a                    ; STA K                  \ Store the shifted A in K so the result is now in K(3 2 1 0)
 230+ 7557 3A 32 6C                             ld      a,(varT)                    ; LDA T                  \ Set K+3 to the sign in T, which we set above to the
 231+ 755A 32 2C 6C                             ld      (varK+3),a                  ; STA K+3                \ correct sign for the result
 232+ 755D C9                                   ret                                 ; RTS                    \ Return from the subroutine
 233+ 755E              ;
 234+ 755E              ;   Set flags E to 11111110
 235+ 755E              ;   Loop:   A << 2
 236+ 755E              ;           if carry was 0
 237+ 755E              ;               if a >= D
 238+ 755E              ;                   A = A - D
 239+ 755E              ;                   clear carry (probably irrelevant really)
 240+ 755E              ;           else
 241+ 755E
 242+ 755E              ;               sla flags << bringing in carry of 1
 243+ 755E              ;               if bit 7 of flag was set then loop
 244+ 755E              ;                                        elase a = e and exit
 245+ 755E              ;
 246+ 755E              ; ">BC_Div_DE: BC = BC / DE. HL = remainder fast divide with unrolled loop BC/DE ==> BC, remainder in HL
 247+ 755E              ;
 248+ 755E              ;INPUTS: hl = dividend dbc = divisor
 249+ 755E              ;OUTPUTS: hl/de -> AHL = quotient CDE = remainder, Carryflag set if divide by 0
 250+ 755E
 251+ 755E 57           DVIDT:                  ld      d,a                     ; D = var P+1
 252+ 755F 3A 16 6C                             ld      a,(varQ)
 253+ 7562 4F                                   ld      c,a                     ; C = var Q
 254+ 7563 3A 16 6B                             ld      a,(varP)
 255+ 7566 5F                                   ld      e,a                     ; E = var P
 256+ 7567                                      ; Need fast exists on ABS values
 257+ 7567 7A           BAequDEdivC:            ld      a,d                     ; Fast exit is value is 0
 258+ 7568 B3                                   or      e                       ; .
 259+ 7569 28 2A                                jr      z,.ResultIsZero         ; .
 260+ 756B 79                                   ld      a,c                     ; Fast exit is divide by 0
 261+ 756C A7                                   and     a                       ;
 262+ 756D 28 29                                jr      z,.ResultIsFFFF         ;
 263+ 756F 7A           .SavSign:               ld      a,d                     ; preserve sign of result in var T
 264+ 7570 A9                                   xor     c                       ;
 265+ 7571 E6 80                                and     $80
 266+ 7573 6F                                   ld      l,a                     ; l = var T
 267+ 7574 3E 00                                ld      a,0
 268+ 7576 06 10                                ld      b,16
 269+ 7578                                      ShiftDELeft1
 269+ 7578 CB 23       >			   sla e
 269+ 757A CB 12       >			   rl  d
 270+ 757C CB 21                                sla     c                       ; c = abs c
 271+ 757E CB 39                                srl     c
 272+ 7580 CB 17        .DivideLoop:            rl      a
 273+ 7582                                      JumpIfALTNusng c, .SkipSubtract
 273+ 7582 B9          >                        cp      c
 273+ 7583 DA 89 75    >                        jp		c, .SkipSubtract
 274+ 7586                                      ClearCarryFlag
 274+ 7586 B7          >                        or a
 275+ 7587 99                                   sbc     c
 276+ 7588                                      ClearCarryFlag
 276+ 7588 B7          >                        or a
 277+ 7589 3F           .SkipSubtract:          ccf
 278+ 758A CB 13                                rl      e
 279+ 758C CB 12                                rl      d
 280+ 758E 05                                   dec     b
 281+ 758F 20 EF                                jr      nz,.DivideLoop
 282+ 7591 7B                                   ld      a,e
 283+ 7592 B5                                   or      l
 284+ 7593 42                                   ld      b,d
 285+ 7594 C9                                   ret
 286+ 7595              .ResultIsZero:          ZeroA
 286+ 7595 AF          >                        xor a
 287+ 7596 47                                   ld      b,a
 288+ 7597 C9                                   ret
 289+ 7598 3E FF        .ResultIsFFFF:          ld      a,$FF
 290+ 759A 47                                   ld      b,a
 291+ 759B C9                                   ret
 292+ 759C
 293+ 759C 57           DIV96:                  ld      d,a                     ; D = var P+1
 294+ 759D 3A 16 6C                             ld      a,(varQ)
 295+ 75A0 0E 60                                ld      c,96                    ; C = var Q
 296+ 75A2 3A 16 6B                             ld      a,(varP)
 297+ 75A5 5F                                   ld      e,a                     ; E = var P
 298+ 75A6                                      ; Need fast exists on ABS values
 299+ 75A6 7A           BAequDEdiv96            ld      a,d                     ; Fast exit is value is 0
 300+ 75A7 B3                                   or      e                       ; .
 301+ 75A8 28 26                                jr      z,.ResultIsZero         ; .
 302+ 75AA 7A           .SavSign:               ld      a,d                     ; preserve sign of result in var T
 303+ 75AB A9                                   xor     c                       ;
 304+ 75AC E6 80                                and     $80
 305+ 75AE 6F                                   ld      l,a                     ; l = var T
 306+ 75AF 3E 00                                ld      a,0
 307+ 75B1 06 10                                ld      b,16
 308+ 75B3                                      ShiftDELeft1
 308+ 75B3 CB 23       >			   sla e
 308+ 75B5 CB 12       >			   rl  d
 309+ 75B7 CB 21                                sla     c                       ; c = abs c
 310+ 75B9 CB 39                                srl     c
 311+ 75BB CB 17        .DivideLoop:            rl      a
 312+ 75BD                                      JumpIfALTNusng c, .SkipSubtract
 312+ 75BD B9          >                        cp      c
 312+ 75BE DA C4 75    >                        jp		c, .SkipSubtract
 313+ 75C1                                      ClearCarryFlag
 313+ 75C1 B7          >                        or a
 314+ 75C2 99                                   sbc     c
 315+ 75C3                                      ClearCarryFlag
 315+ 75C3 B7          >                        or a
 316+ 75C4 3F           .SkipSubtract:          ccf
 317+ 75C5 CB 13                                rl      e
 318+ 75C7 CB 12                                rl      d
 319+ 75C9 05                                   dec     b
 320+ 75CA 20 EF                                jr      nz,.DivideLoop
 321+ 75CC 7B                                   ld      a,e
 322+ 75CD B5                                   or      l
 323+ 75CE 42                                   ld      b,d
 324+ 75CF C9                                   ret
 325+ 75D0              .ResultIsZero:          ZeroA
 325+ 75D0 AF          >                        xor a
 326+ 75D1 47                                   ld      b,a
 327+ 75D2 C9                                   ret
 328+ 75D3
 329+ 75D3 14           Div16by24usgn:          inc     d                           ; can we fast retu
 330+ 75D4 15                                   dec     d
 331+ 75D5 20 13                                jr      nz,.ResultZero
 332+ 75D7 50 59                                ld      de,bc                       ; so prep for bc/de
 333+ 75D9 44 4D                                ld      bc,hl
 334+ 75DB 7A           .div16by16usng:         ld      a,d
 335+ 75DC B3                                   or      e
 336+ 75DD 28 10                                jr      z,.DivideByZero
 337+ 75DF 14                                   inc     d
 338+ 75E0 15                                   dec     d
 339+ 75E1 CD 33 77                             call    BC_Div_DE
 340+ 75E4                                      ZeroA
 340+ 75E4 AF          >                        xor a
 341+ 75E5 EB                                   ex      de,hl                       ; de = remainder (need to fix c after hl = nothing of worth)
 342+ 75E6 60 69                                ld      hl,bc                       ; hl = result (a is zero from above)
 343+ 75E8 4F                                   ld      c,a                         ; now fix c
 344+ 75E9 C9                                   ret
 345+ 75EA AF           .ResultZero:            xor     a                           ; set AHL to 0 as d was 0 so h is zero
 346+ 75EB 4F                                   ld      c,a                         ; c = 0
 347+ 75EC 67                                   ld      h,a
 348+ 75ED 6F                                   ld      l,a
 349+ 75EE C9                                   ret
 350+ 75EF 3E FF        .DivideByZero:          ld      a,$FF
 351+ 75F1 67                                   ld      h,a
 352+ 75F2 6F                                   ld      l,a
 353+ 75F3                                      SetCarryFlag
 353+ 75F3 37          >                        scf
 354+ 75F4 C9                                   ret
 355+ 75F5
 356+ 75F5              ;DIVD4 P-R=A/Qunsg  \P.R = A/Q unsigned called by Hall
 357+ 75F5                          IFDEF HLEquAmul256DivD_Used
 358+ 75F5 ~            HLEquAmul256DivD:       ld		b,8							; counter
 359+ 75F5 ~                                    sla		a							;
 360+ 75F5 ~                                    ld		h,a							; r a * 2 we will build result in hl
 361+ 75F5 ~            .DivideLoop:            rl		a							; a = a * 2
 362+ 75F5 ~                                    jr      c,.StraightToSubtraction    ; jump on carry to subtraction
 363+ 75F5 ~                                    cp      d                           ; what was var Q
 364+ 75F5 ~                                    jr		c,.SkipSubtraction	        ; if a < d skip subtraction, note this will come to skip subtraction with carry the wrong way round
 365+ 75F5 ~            .StraightToSubtraction: ClearCarryFlag                      ; in 6502 the borrow flag is inverted carry, z80 just uses carry so we need to clear it
 366+ 75F5 ~                                    sbc     a,d                         ; a = a - q
 367+ 75F5 ~                                    ClearCarryFlag                      ; set carry so it gets shifted into bit 0 of b. we do this as we have to flip carry due to jr c from earlier cp d
 368+ 75F5 ~            .SkipSubtraction:       ccf                                 ; we need to do this as 6502 does opposite on carry, i.e. if we jumped direct here then carry would be set in z80
 369+ 75F5 ~                                    rl      h                           ; roll d left bringing in carry if there was an sbc performed
 370+ 75F5 ~                                    djnz    .DivideLoop                 ; 8 cycles
 371+ 75F5 ~            .CalculateRemainder:    cp      d                           ; calulate 256 * a / d if q >= q then answer will not fit in one byte d is still set, a holds remainder to be subtracted
 372+ 75F5 ~                                    jr      nc, .RemainderTooBig
 373+ 75F5 ~                                    ClearCarryFlag                      ; remove carry as the previous cp will have set it and mess up the sla in the remainder loop
 374+ 75F5 ~            .InitRemainderLoop:     ld      b,%11111110                 ; loop for bits 1 to 7
 375+ 75F5 ~                                    ld      l,b                         ; and set l to capture result bits (R)
 376+ 75F5 ~            .RemainderLoop:         sla     a                           ; shift a left
 377+ 75F5 ~                                    jr      c, .RemainderSubtraction    ; if there was a carry go to subtraction
 378+ 75F5 ~                                    cp      d                           ; if a < d then skip subtraction
 379+ 75F5 ~                                    jr      c,.RemainderSkipSubtract    ; .
 380+ 75F5 ~                                    sbc     d                           ; a > q so a = a - q, carry will be clear here
 381+ 75F5 ~            .RemainderSkipSubtract: ccf                                 ; as the jr used z80 we need to flip the carry to behave like 6502
 382+ 75F5 ~                                    rl      l                           ; rotate counter to the left
 383+ 75F5 ~                                    jr      c, .RemainderLoop           ; if there was a bit pushed to carry then loop
 384+ 75F5 ~                                    ret
 385+ 75F5 ~            .RemainderSubtraction:  sbc     d                           ; as the carry came from an sla we want to retain it
 386+ 75F5 ~                                    SetCarryFlag                        ; roll in a carry bit to result
 387+ 75F5 ~                                    rl      l                           ;
 388+ 75F5 ~                                    jr      c, .RemainderLoop           ; and loop if there was a carry bit that came out
 389+ 75F5 ~                                    ret
 390+ 75F5 ~            .RemainderTooBig:       ld      l,$FF                       ; now hl = result
 391+ 75F5 ~                                    ret
 392+ 75F5                          ENDIF
 393+ 75F5
 394+ 75F5 BA           AEquAmul256DivD:        cp      d
 395+ 75F6 28 1D                                jr      z,.BothSame
 396+ 75F8 30 1E                                jr      nc,.DgtA
 397+ 75FA 1E FE                                ld      e,%11111110                 ; Set R to have bits 1-7 set, so we can rotate through 7
 398+ 75FC CB 27        .DivideLoop:            sla     a
 399+ 75FE 38 0D                                jr      c,.LL29
 400+ 7600                                      JumpIfALTNusng  d, .SkipSub         ; will jump if carry set, so we need to reset on the rol
 400+ 7600 BA          >                        cp      d
 400+ 7601 DA 06 76    >                        jp		c, .SkipSub
 401+ 7604 92                                   sub     d
 402+ 7605                                      ClearCarryFlag                      ; reset clarry as it will be complimented for rotate as 6502 does carry flags inverted
 402+ 7605 B7          >                        or a
 403+ 7606              .SkipSub:               FlipCarryFlag                       ; if we did the subtract the carry will be clear so we need to invert to roll in.
 403+ 7606 3F          >                        ccf
 404+ 7607 CB 13                                rl      e
 405+ 7609 38 F1                                jr      c,.DivideLoop
 406+ 760B 7B                                   ld      a,e
 407+ 760C C9                                   ret
 408+ 760D 92           .LL29:                  sub     d                           ; A >= Q, so set A = A - Q
 409+ 760E                                      SetCarryFlag                        ; Set the C flag to rotate into the result in R
 409+ 760E 37          >                        scf
 410+ 760F CB 13                                rl      e                           ; rotate counter e left
 411+ 7611 38 E9                                jr      c,.DivideLoop               ; if a bit was spat off teh end then loop
 412+ 7613 7B                                   ld      a,e                         ; stick result in a
 413+ 7614 C9                                   ret
 414+ 7615 3E 01        .BothSame:              ld  a,1
 415+ 7617 C9                                   ret
 416+ 7618 3E FF        .DgtA:                  ld  a,255                           ; Fail with FF as result
 417+ 761A C9                                   ret
 418+ 761B
 419+ 761B              ; Divide 8-bit values
 420+ 761B              ; In: Divide E by divider C
 421+ 761B              ; Out: A = result, B = rest
 422+ 761B              ;
 423+ 761B              ;;;Div8:
 424+ 761B              ;;;    xor a
 425+ 761B              ;;;    ld b,8
 426+ 761B              ;;;Div8_Loop:
 427+ 761B              ;;;    rl e
 428+ 761B              ;;;    rla
 429+ 761B              ;;;    sub c
 430+ 761B              ;;;    jr nc,Div8_NoAdd
 431+ 761B              ;;;    add a,c
 432+ 761B              ;;;Div8_NoAdd:
 433+ 761B              ;;;    djnz Div8_Loop
 434+ 761B              ;;;    ld b,a0
 435+ 761B              ;;;    ld a,e
 436+ 761B              ;;;    rla
 437+ 761B              ;;;    cpl
 438+ 761B              ;;;    ret
 439+ 761B
 440+ 761B              ;;Inputs: DE is the numerator, BC is the divisor
 441+ 761B              ;;Outputs: DE is the result
 442+ 761B              ;;         A is a copy of E
 443+ 761B              ;;         HL is the remainder
 444+ 761B              ;;         BC is not changed
 445+ 761B              ;; so DE = DE /BC
 446+ 761B              ;140 bytes
 447+ 761B              ;145cc
 448+ 761B
 449+ 761B              MacroDEDivBC:       MACRO
 450+ 761B ~                                rla
 451+ 761B ~                                adc     hl,hl
 452+ 761B ~                                sbc     hl,bc
 453+ 761B ~                                jr      nc,$+3
 454+ 761B ~                                add     hl,bc
 455+ 761B                                  ENDM
 456+ 761B
 457+ 761B AF           DEequDEDivBC:       xor a
 458+ 761C ED 62                            sbc hl,hl
 459+ 761E 7A                               ld a,d
 460+ 761F                                  MacroDEDivBC
 460+ 761F 17          >                    rla
 460+ 7620 ED 6A       >                    adc     hl,hl
 460+ 7622 ED 42       >                    sbc     hl,bc
 460+ 7624 30 01       >                    jr      nc,$+3
 460+ 7626 09          >                    add     hl,bc
 461+ 7627                                  MacroDEDivBC
 461+ 7627 17          >                    rla
 461+ 7628 ED 6A       >                    adc     hl,hl
 461+ 762A ED 42       >                    sbc     hl,bc
 461+ 762C 30 01       >                    jr      nc,$+3
 461+ 762E 09          >                    add     hl,bc
 462+ 762F                                  MacroDEDivBC
 462+ 762F 17          >                    rla
 462+ 7630 ED 6A       >                    adc     hl,hl
 462+ 7632 ED 42       >                    sbc     hl,bc
 462+ 7634 30 01       >                    jr      nc,$+3
 462+ 7636 09          >                    add     hl,bc
 463+ 7637                                  MacroDEDivBC
 463+ 7637 17          >                    rla
 463+ 7638 ED 6A       >                    adc     hl,hl
 463+ 763A ED 42       >                    sbc     hl,bc
 463+ 763C 30 01       >                    jr      nc,$+3
 463+ 763E 09          >                    add     hl,bc
 464+ 763F                                  MacroDEDivBC
 464+ 763F 17          >                    rla
 464+ 7640 ED 6A       >                    adc     hl,hl
 464+ 7642 ED 42       >                    sbc     hl,bc
 464+ 7644 30 01       >                    jr      nc,$+3
 464+ 7646 09          >                    add     hl,bc
 465+ 7647                                  MacroDEDivBC
 465+ 7647 17          >                    rla
 465+ 7648 ED 6A       >                    adc     hl,hl
 465+ 764A ED 42       >                    sbc     hl,bc
 465+ 764C 30 01       >                    jr      nc,$+3
 465+ 764E 09          >                    add     hl,bc
 466+ 764F                                  MacroDEDivBC
 466+ 764F 17          >                    rla
 466+ 7650 ED 6A       >                    adc     hl,hl
 466+ 7652 ED 42       >                    sbc     hl,bc
 466+ 7654 30 01       >                    jr      nc,$+3
 466+ 7656 09          >                    add     hl,bc
 467+ 7657                                  MacroDEDivBC
 467+ 7657 17          >                    rla
 467+ 7658 ED 6A       >                    adc     hl,hl
 467+ 765A ED 42       >                    sbc     hl,bc
 467+ 765C 30 01       >                    jr      nc,$+3
 467+ 765E 09          >                    add     hl,bc
 468+ 765F 17                               rla
 469+ 7660 2F                               cpl
 470+ 7661 57                               ld d,a
 471+ 7662
 472+ 7662 7B                               ld a,e
 473+ 7663                                  MacroDEDivBC
 473+ 7663 17          >                    rla
 473+ 7664 ED 6A       >                    adc     hl,hl
 473+ 7666 ED 42       >                    sbc     hl,bc
 473+ 7668 30 01       >                    jr      nc,$+3
 473+ 766A 09          >                    add     hl,bc
 474+ 766B                                  MacroDEDivBC
 474+ 766B 17          >                    rla
 474+ 766C ED 6A       >                    adc     hl,hl
 474+ 766E ED 42       >                    sbc     hl,bc
 474+ 7670 30 01       >                    jr      nc,$+3
 474+ 7672 09          >                    add     hl,bc
 475+ 7673                                  MacroDEDivBC
 475+ 7673 17          >                    rla
 475+ 7674 ED 6A       >                    adc     hl,hl
 475+ 7676 ED 42       >                    sbc     hl,bc
 475+ 7678 30 01       >                    jr      nc,$+3
 475+ 767A 09          >                    add     hl,bc
 476+ 767B                                  MacroDEDivBC
 476+ 767B 17          >                    rla
 476+ 767C ED 6A       >                    adc     hl,hl
 476+ 767E ED 42       >                    sbc     hl,bc
 476+ 7680 30 01       >                    jr      nc,$+3
 476+ 7682 09          >                    add     hl,bc
 477+ 7683                                  MacroDEDivBC
 477+ 7683 17          >                    rla
 477+ 7684 ED 6A       >                    adc     hl,hl
 477+ 7686 ED 42       >                    sbc     hl,bc
 477+ 7688 30 01       >                    jr      nc,$+3
 477+ 768A 09          >                    add     hl,bc
 478+ 768B                                  MacroDEDivBC
 478+ 768B 17          >                    rla
 478+ 768C ED 6A       >                    adc     hl,hl
 478+ 768E ED 42       >                    sbc     hl,bc
 478+ 7690 30 01       >                    jr      nc,$+3
 478+ 7692 09          >                    add     hl,bc
 479+ 7693                                  MacroDEDivBC
 479+ 7693 17          >                    rla
 479+ 7694 ED 6A       >                    adc     hl,hl
 479+ 7696 ED 42       >                    sbc     hl,bc
 479+ 7698 30 01       >                    jr      nc,$+3
 479+ 769A 09          >                    add     hl,bc
 480+ 769B                                  MacroDEDivBC
 480+ 769B 17          >                    rla
 480+ 769C ED 6A       >                    adc     hl,hl
 480+ 769E ED 42       >                    sbc     hl,bc
 480+ 76A0 30 01       >                    jr      nc,$+3
 480+ 76A2 09          >                    add     hl,bc
 481+ 76A3 17                               rla
 482+ 76A4 2F                               cpl
 483+ 76A5 5F                               ld e,a
 484+ 76A6 C9                               ret
 485+ 76A7              ;divdide by 16 using undocumented instrunctions
 486+ 76A7              ;Input: BC = Dividend, DE = Divisor, HL = 0
 487+ 76A7              ;Output: BC = Quotient, HL = Remainder
 488+ 76A7              ; Our use
 489+ 76A7              ; BC = A0
 490+ 76A7              ; DE = 0C
 491+ 76A7              ; so BC = a * 256 / C
 492+ 76A7              DIV16Amul256dCUNDOC:    JumpIfAGTENusng	  c,DEV16ATooLarge                                          ; first off if a > c ten return 255
 492+ 76A7 B9          >                        cp     c
 492+ 76A8 D2 D3 76    >                        jp		nc,DEV16ATooLarge
 493+ 76AB 47                                   ld      b,a
 494+ 76AC 59                                   ld      e,c
 495+ 76AD 0E 00                                ld      c,0
 496+ 76AF 16 00                                ld      d,0
 497+ 76B1 C3 BE 76                             jp      DIV16UNDOC
 498+ 76B4 47           DIV16Amul256dQUNDOC:    ld      b,a
 499+ 76B5 0E 00                                ld      c,0
 500+ 76B7 21 16 6C                             ld      hl,varQ
 501+ 76BA 7E                                   ld      a,(hl)
 502+ 76BB 16 00                                ld      d,0
 503+ 76BD 5F                                   ld      e,a
 504+ 76BE              DIV16BCDivDEUNDOC:
 505+ 76BE 21 00 00     DIV16UNDOC:             ld      hl,0
 506+ 76C1 78                                   ld      a,b
 507+ 76C2 06 10                                ld      b,16
 508+ 76C4 CB 31        DIV16UNDOCLOOP:         sll	c		; unroll 16 times
 509+ 76C6 17                                   rla			; ...
 510+ 76C7 ED 6A                                adc	hl,hl		; ...
 511+ 76C9 ED 52                                sbc	hl,de		; ...
 512+ 76CB 30 02                                jr	nc,DIV16UNDOCSKIP		; ...
 513+ 76CD 19                                   add	hl,de		; ...
 514+ 76CE 0D                                   dec	c		; ...
 515+ 76CF 10 F3        DIV16UNDOCSKIP:         djnz DIV16UNDOCLOOP
 516+ 76D1 47                                   ld   b,a
 517+ 76D2 C9                                   ret
 518+ 76D3 01 FF 00     DEV16ATooLarge:         ld     bc,$00FF
 519+ 76D6 C9                                   ret
 520+ 76D7              ; switch to logarithm version
 521+ 76D7              ; "> asm_div8 C_Div_D - C is the numerator, D is the denominator, A is the remainder, B is 0, C is the result of C/D,D,E,H,L are not changed"
 522+ 76D7 06 08        asm_div8:               ld b,8
 523+ 76D9 AF                                   xor a
 524+ 76DA CB 21        .div8_loop:	            sla c
 525+ 76DC 17                                   rla
 526+ 76DD BA                                   cp d
 527+ 76DE 38 02                                jr c,.div8_skip
 527+ 76E0
 528+ 76E0 0C                                   inc c
 529+ 76E1 92                                   sub d
 530+ 76E2 10 F6        .div8_skip:	            djnz .div8_loop
 531+ 76E4 C9                                   ret
 532+ 76E5              ; ">asm_div16: HL_Div_C: HL is the numerator,  C is the denominator, output A is the remainder, B is 0, C,DE is not changedHL is the quotient"
 533+ 76E5 06 10        asm_div16:              ld b,16
 534+ 76E7 AF                                   xor a
 535+ 76E8 CB 25        div16_loop:	            sla l
 536+ 76EA CB 14                                rl	h
 537+ 76EC              ;    add hl,hl
 538+ 76EC 17                                   rla
 539+ 76ED B9                                   cp c
 540+ 76EE 38 02                                jr c,div16_skip
 541+ 76F0 2C                                   inc l
 542+ 76F1 91                                   sub c
 543+ 76F2 10 F4        div16_skip:		        djnz div16_loop
 544+ 76F4 C9                                   ret
 545+ 76F5              ;
 546+ 76F5              ; Divide 16-bit values (with 16-bit result)
 547+ 76F5              ; In: Divide BC by divider DE
 548+ 76F5              ; Out: BC = result, HL = rest
 549+ 76F5              ;
 550+ 76F5              HLDivC_Iteration: 	    MACRO
 551+ 76F5 ~                                    add	hl,hl		; unroll 16 times
 552+ 76F5 ~                                    rla				; ...
 553+ 76F5 ~                                    cp	c			; ...
 554+ 76F5 ~                                    jr	1F
 555+ 76F5 ~                                    sub	c			; ...
 556+ 76F5 ~            1:
 557+ 76F5 ~                                    inc	l			; ...
 558+ 76F5                                      ENDM
 559+ 76F5
 560+ 76F5              EDivC_Iteration:        MACRO
 561+ 76F5 ~                                    rl  e
 562+ 76F5 ~                                    rla
 563+ 76F5 ~                                    sub c
 564+ 76F5 ~                                    jr  nc,.Div8_NoAdd
 565+ 76F5 ~                                    add a,c
 566+ 76F5 ~            .Div8_NoAdd:
 567+ 76F5                                      ENDM
 568+ 76F5
 569+ 76F5              ; Switch to a logarithm version
 570+ 76F5              ; Divide E by divider C Out: A = result, B = rest
 571+ 76F5              E_Div_C:                ZeroA
 571+ 76F5 AF          >                        xor a
 572+ 76F6                                      EDivC_Iteration
 572+ 76F6 CB 13       >                        rl  e
 572+ 76F8 17          >                        rla
 572+ 76F9 91          >                        sub c
 572+ 76FA 30 01       >                        jr  nc,.Div8_NoAdd
 572+ 76FC 81          >                        add a,c
 572+ 76FD             >.Div8_NoAdd:
 573+ 76FD                                      EDivC_Iteration
 573+ 76FD CB 13       >                        rl  e
 573+ 76FF 17          >                        rla
 573+ 7700 91          >                        sub c
 573+ 7701 30 01       >                        jr  nc,.Div8_NoAdd
 573+ 7703 81          >                        add a,c
 573+ 7704             >.Div8_NoAdd:
 574+ 7704                                      EDivC_Iteration
 574+ 7704 CB 13       >                        rl  e
 574+ 7706 17          >                        rla
 574+ 7707 91          >                        sub c
 574+ 7708 30 01       >                        jr  nc,.Div8_NoAdd
 574+ 770A 81          >                        add a,c
 574+ 770B             >.Div8_NoAdd:
 575+ 770B                                      EDivC_Iteration
 575+ 770B CB 13       >                        rl  e
 575+ 770D 17          >                        rla
 575+ 770E 91          >                        sub c
 575+ 770F 30 01       >                        jr  nc,.Div8_NoAdd
 575+ 7711 81          >                        add a,c
 575+ 7712             >.Div8_NoAdd:
 576+ 7712                                      EDivC_Iteration
 576+ 7712 CB 13       >                        rl  e
 576+ 7714 17          >                        rla
 576+ 7715 91          >                        sub c
 576+ 7716 30 01       >                        jr  nc,.Div8_NoAdd
 576+ 7718 81          >                        add a,c
 576+ 7719             >.Div8_NoAdd:
 577+ 7719                                      EDivC_Iteration
 577+ 7719 CB 13       >                        rl  e
 577+ 771B 17          >                        rla
 577+ 771C 91          >                        sub c
 577+ 771D 30 01       >                        jr  nc,.Div8_NoAdd
 577+ 771F 81          >                        add a,c
 577+ 7720             >.Div8_NoAdd:
 578+ 7720                                      EDivC_Iteration
 578+ 7720 CB 13       >                        rl  e
 578+ 7722 17          >                        rla
 578+ 7723 91          >                        sub c
 578+ 7724 30 01       >                        jr  nc,.Div8_NoAdd
 578+ 7726 81          >                        add a,c
 578+ 7727             >.Div8_NoAdd:
 579+ 7727                                      EDivC_Iteration
 579+ 7727 CB 13       >                        rl  e
 579+ 7729 17          >                        rla
 579+ 772A 91          >                        sub c
 579+ 772B 30 01       >                        jr  nc,.Div8_NoAdd
 579+ 772D 81          >                        add a,c
 579+ 772E             >.Div8_NoAdd:
 580+ 772E 47                                   ld      b,a
 581+ 772F 7B                                   ld      a,e
 582+ 7730 17                                   rla
 583+ 7731 2F                                   cpl
 584+ 7732 C9                                   ret
 585+ 7733
 586+ 7733
 587+ 7733              BCDIVDE_Iteration:      MACRO
 588+ 7733 ~                                    rla
 589+ 7733 ~                                    adc	    hl,hl
 590+ 7733 ~                                    add	    hl,de
 591+ 7733 ~                                    jr	    c,1F
 592+ 7733 ~                                    sbc	    hl,de
 593+ 7733 ~            1:
 594+ 7733                                      ENDM
 595+ 7733
 596+ 7733
 597+ 7733              ; ">BC_Div_DE: BC = BC / DE. HL = remainder fast divide with unrolled loop"
 598+ 7733              ;BC/DE ==> BC, remainder in HL
 599+ 7733              ;NOTE: BC/0 returns 0 as the quotient.
 600+ 7733              ;min: 738cc
 601+ 7733              ;max: 898cc
 602+ 7733              ;avg: 818cc
 603+ 7733              ;144 bytes
 604+ 7733 AF           BC_Div_DE:              xor a
 605+ 7734 67                                   ld h,a
 606+ 7735 6F                                   ld l,a
 607+ 7736 93                                   sub e
 608+ 7737 5F                                   ld e,a
 609+ 7738 9F                                   sbc a,a
 610+ 7739 92                                   sub d
 611+ 773A 57                                   ld d,a
 612+ 773B 78                                   ld a,b
 613+ 773C                                      BCDIVDE_Iteration
 613+ 773C 17          >                        rla
 613+ 773D ED 6A       >                        adc	    hl,hl
 613+ 773F 19          >                        add	    hl,de
 613+ 7740 38 02       >                        jr	    c,1F
 613+ 7742 ED 52       >                        sbc	    hl,de
 613+ 7744             >1:
 614+ 7744                                      BCDIVDE_Iteration
 614+ 7744 17          >                        rla
 614+ 7745 ED 6A       >                        adc	    hl,hl
 614+ 7747 19          >                        add	    hl,de
 614+ 7748 38 02       >                        jr	    c,1F
 614+ 774A ED 52       >                        sbc	    hl,de
 614+ 774C             >1:
 615+ 774C                                      BCDIVDE_Iteration
 615+ 774C 17          >                        rla
 615+ 774D ED 6A       >                        adc	    hl,hl
 615+ 774F 19          >                        add	    hl,de
 615+ 7750 38 02       >                        jr	    c,1F
 615+ 7752 ED 52       >                        sbc	    hl,de
 615+ 7754             >1:
 616+ 7754                                      BCDIVDE_Iteration
 616+ 7754 17          >                        rla
 616+ 7755 ED 6A       >                        adc	    hl,hl
 616+ 7757 19          >                        add	    hl,de
 616+ 7758 38 02       >                        jr	    c,1F
 616+ 775A ED 52       >                        sbc	    hl,de
 616+ 775C             >1:
 617+ 775C                                      BCDIVDE_Iteration
 617+ 775C 17          >                        rla
 617+ 775D ED 6A       >                        adc	    hl,hl
 617+ 775F 19          >                        add	    hl,de
 617+ 7760 38 02       >                        jr	    c,1F
 617+ 7762 ED 52       >                        sbc	    hl,de
 617+ 7764             >1:
 618+ 7764                                      BCDIVDE_Iteration
 618+ 7764 17          >                        rla
 618+ 7765 ED 6A       >                        adc	    hl,hl
 618+ 7767 19          >                        add	    hl,de
 618+ 7768 38 02       >                        jr	    c,1F
 618+ 776A ED 52       >                        sbc	    hl,de
 618+ 776C             >1:
 619+ 776C                                      BCDIVDE_Iteration
 619+ 776C 17          >                        rla
 619+ 776D ED 6A       >                        adc	    hl,hl
 619+ 776F 19          >                        add	    hl,de
 619+ 7770 38 02       >                        jr	    c,1F
 619+ 7772 ED 52       >                        sbc	    hl,de
 619+ 7774             >1:
 620+ 7774                                      BCDIVDE_Iteration
 620+ 7774 17          >                        rla
 620+ 7775 ED 6A       >                        adc	    hl,hl
 620+ 7777 19          >                        add	    hl,de
 620+ 7778 38 02       >                        jr	    c,1F
 620+ 777A ED 52       >                        sbc	    hl,de
 620+ 777C             >1:
 621+ 777C 17                                   rla
 622+ 777D 47                                   ld b,a
 623+ 777E 79                                   ld a,c
 624+ 777F                                      BCDIVDE_Iteration
 624+ 777F 17          >                        rla
 624+ 7780 ED 6A       >                        adc	    hl,hl
 624+ 7782 19          >                        add	    hl,de
 624+ 7783 38 02       >                        jr	    c,1F
 624+ 7785 ED 52       >                        sbc	    hl,de
 624+ 7787             >1:
 625+ 7787                                      BCDIVDE_Iteration
 625+ 7787 17          >                        rla
 625+ 7788 ED 6A       >                        adc	    hl,hl
 625+ 778A 19          >                        add	    hl,de
 625+ 778B 38 02       >                        jr	    c,1F
 625+ 778D ED 52       >                        sbc	    hl,de
 625+ 778F             >1:
 626+ 778F                                      BCDIVDE_Iteration
 626+ 778F 17          >                        rla
 626+ 7790 ED 6A       >                        adc	    hl,hl
 626+ 7792 19          >                        add	    hl,de
 626+ 7793 38 02       >                        jr	    c,1F
 626+ 7795 ED 52       >                        sbc	    hl,de
 626+ 7797             >1:
 627+ 7797                                      BCDIVDE_Iteration
 627+ 7797 17          >                        rla
 627+ 7798 ED 6A       >                        adc	    hl,hl
 627+ 779A 19          >                        add	    hl,de
 627+ 779B 38 02       >                        jr	    c,1F
 627+ 779D ED 52       >                        sbc	    hl,de
 627+ 779F             >1:
 628+ 779F                                      BCDIVDE_Iteration
 628+ 779F 17          >                        rla
 628+ 77A0 ED 6A       >                        adc	    hl,hl
 628+ 77A2 19          >                        add	    hl,de
 628+ 77A3 38 02       >                        jr	    c,1F
 628+ 77A5 ED 52       >                        sbc	    hl,de
 628+ 77A7             >1:
 629+ 77A7                                      BCDIVDE_Iteration
 629+ 77A7 17          >                        rla
 629+ 77A8 ED 6A       >                        adc	    hl,hl
 629+ 77AA 19          >                        add	    hl,de
 629+ 77AB 38 02       >                        jr	    c,1F
 629+ 77AD ED 52       >                        sbc	    hl,de
 629+ 77AF             >1:
 630+ 77AF                                      BCDIVDE_Iteration
 630+ 77AF 17          >                        rla
 630+ 77B0 ED 6A       >                        adc	    hl,hl
 630+ 77B2 19          >                        add	    hl,de
 630+ 77B3 38 02       >                        jr	    c,1F
 630+ 77B5 ED 52       >                        sbc	    hl,de
 630+ 77B7             >1:
 631+ 77B7                                      BCDIVDE_Iteration
 631+ 77B7 17          >                        rla
 631+ 77B8 ED 6A       >                        adc	    hl,hl
 631+ 77BA 19          >                        add	    hl,de
 631+ 77BB 38 02       >                        jr	    c,1F
 631+ 77BD ED 52       >                        sbc	    hl,de
 631+ 77BF             >1:
 632+ 77BF 17                                   rla
 633+ 77C0 4F                                   ld c,a
 634+ 77C1 C9                                   ret
 635+ 77C2 78           Floor_DivQSigned:       ld      a,b             ; save resultant sign
 636+ 77C3 AA                                   xor     d               ;
 637+ 77C4 E6 80                                and     $80             ;
 638+ 77C6 DD 67                                ld      ixh,a           ;
 639+ 77C8 78                                   ld      a,b
 640+ 77C9 E6 7F                                and     $7F
 641+ 77CB 47                                   ld      b,a
 642+ 77CC 7A                                   ld      a,d
 643+ 77CD E6 7F                                and     $7F
 644+ 77CF 57                                   ld      d,a
 645+ 77D0 CD D8 77                             call    Floor_DivQ
 646+ 77D3 78                                   ld      a,b
 647+ 77D4 DD B4                                or      ixh
 648+ 77D6 47                                   ld      b,a
 649+ 77D7 C9                                   ret
 650+ 77D8
 651+ 77D8
 652+ 77D8
 653+ 77D8              ; BC = BC / DE
 654+ 77D8              ; HL = BC % DE
 655+ 77D8              ; if HL > 0 BC -= 1
 656+ 77D8 78           Floor_DivQ:             ld      a,b
 657+ 77D9 B1                                   or      c
 658+ 77DA 28 26                                jr      z, .divide0By   ; if bc is zero just return as result will be zero
 659+ 77DC 7A                                   ld      a,d
 660+ 77DD B3                                   or      e
 661+ 77DE 28 26                                jr      z, .divideBy0
 662+ 77E0 D5                                   push    de
 663+ 77E1 CD 33 77     .DoDivide:              call    BC_Div_DE       ; bc(q0) = bc / de , hl(r0) = bc %de
 664+ 77E4 D1                                   pop     de              ; get divisor back to test
 665+ 77E5 CB 7A                                bit     7,d             ; if divisor <0 or = 0 goto else branch
 666+ 77E7 C2 F7 77                             jp      nz,.deLTE0
 667+ 77EA 7A                                   ld      a,d
 668+ 77EB B3                                   or      e
 669+ 77EC CA F7 77                             jp      z,.deLTE0
 670+ 77EF CB 7C        .deGT0:                 bit     7,h             ; if remainder >=0 return with no adjustment
 671+ 77F1 C8                                   ret     z               ; if remainder was not negative then all done
 672+ 77F2 0B                                   dec     bc              ; else q --
 673+ 77F3                                      ClearCarryFlag          ;      r += b
 673+ 77F3 B7          >                        or a
 674+ 77F4 ED 5A                                adc     hl,de           ;      .
 675+ 77F6 C9                                   ret
 676+ 77F7 CB 7C        .deLTE0:                bit     7,h             ; if remainder <= 0 retun with no adjustment
 677+ 77F9 C8                                   ret     z               ; (return if negative)
 678+ 77FA 7C                                   ld      a,h
 679+ 77FB B5                                   or      l               ; (return if zero)
 680+ 77FC C8                                   ret     z
 681+ 77FD 0B                                   dec     bc              ; else q --
 682+ 77FE                                      ClearCarryFlag          ;      r += b
 682+ 77FE B7          >                        or a
 683+ 77FF ED 5A                                adc     hl,de           ;      .
 684+ 7801 C9                                   ret
 685+ 7802 21 00 00     .divide0By:             ld      hl,0            ; hl = 0, bc is already 0
 686+ 7805 C9                                   ret
 687+ 7806 21 00 00     .divideBy0:             ld      hl,0
 688+ 7809 01 01 00                             ld      bc,1
 689+ 780C C9                                   ret
 690+ 780D
 691+ 780D
 692+ 780D              L_DIV_0_ITERATION:      MACRO
 693+ 780D ~                                    rl      de              ;left shift dividend + quotient carry
 694+ 780D ~                                    ex      de,hl
 695+ 780D ~                                    rl      de              ;left shift remainder + dividend carry
 696+ 780D ~                                    ex      de,hl
 697+ 780D ~                                    sub     hl,bc           ;substract divisor from remainder
 698+ 780D ~                                    jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 699+ 780D ~                                    add     hl,bc           ;revert subtraction of divisor
 700+ 780D ~            .skip_revert0:          ccf                     ;complement carry
 701+ 780D ~                                    rl      de              ;left shift dividend + quotient carry
 702+ 780D ~                                    ex      de,hl
 703+ 780D ~                                    rl      de              ;left shift remainder + dividend carry
 704+ 780D ~                                    ex      de,hl
 705+ 780D ~                                    sub     hl,bc           ;substract divisor from remainder
 706+ 780D ~                                    jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 707+ 780D ~                                    add     hl,bc           ;revert subtraction of divisor
 708+ 780D ~            .skip_revert1:          ccf                     ;complement carry
 709+ 780D                                      ENDM
 710+ 780D
 711+ 780D              ; HL = DE / BC, DE = DE % BC
 712+ 780D 21 00 00     l_div_0:                ld      hl,0            ;clear remainder
 713+ 7810                                      L_DIV_0_ITERATION
 713+ 7810 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 713+ 7814 EB          >                        ex      de,hl
 713+ 7815 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 713+ 7819 EB          >                        ex      de,hl
 713+ 781A B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 713+ 781D D2 21 78    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 713+ 7820 09          >                        add     hl,bc           ;revert subtraction of divisor
 713+ 7821 3F          >.skip_revert0:          ccf                     ;complement carry
 713+ 7822 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 713+ 7826 EB          >                        ex      de,hl
 713+ 7827 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 713+ 782B EB          >                        ex      de,hl
 713+ 782C B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 713+ 782F D2 33 78    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 713+ 7832 09          >                        add     hl,bc           ;revert subtraction of divisor
 713+ 7833 3F          >.skip_revert1:          ccf                     ;complement carry
 714+ 7834                                      L_DIV_0_ITERATION
 714+ 7834 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 714+ 7838 EB          >                        ex      de,hl
 714+ 7839 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 714+ 783D EB          >                        ex      de,hl
 714+ 783E B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 714+ 7841 D2 45 78    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 714+ 7844 09          >                        add     hl,bc           ;revert subtraction of divisor
 714+ 7845 3F          >.skip_revert0:          ccf                     ;complement carry
 714+ 7846 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 714+ 784A EB          >                        ex      de,hl
 714+ 784B CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 714+ 784F EB          >                        ex      de,hl
 714+ 7850 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 714+ 7853 D2 57 78    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 714+ 7856 09          >                        add     hl,bc           ;revert subtraction of divisor
 714+ 7857 3F          >.skip_revert1:          ccf                     ;complement carry
 715+ 7858                                      L_DIV_0_ITERATION
 715+ 7858 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 715+ 785C EB          >                        ex      de,hl
 715+ 785D CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 715+ 7861 EB          >                        ex      de,hl
 715+ 7862 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 715+ 7865 D2 69 78    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 715+ 7868 09          >                        add     hl,bc           ;revert subtraction of divisor
 715+ 7869 3F          >.skip_revert0:          ccf                     ;complement carry
 715+ 786A CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 715+ 786E EB          >                        ex      de,hl
 715+ 786F CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 715+ 7873 EB          >                        ex      de,hl
 715+ 7874 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 715+ 7877 D2 7B 78    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 715+ 787A 09          >                        add     hl,bc           ;revert subtraction of divisor
 715+ 787B 3F          >.skip_revert1:          ccf                     ;complement carry
 716+ 787C                                      L_DIV_0_ITERATION
 716+ 787C CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 716+ 7880 EB          >                        ex      de,hl
 716+ 7881 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 716+ 7885 EB          >                        ex      de,hl
 716+ 7886 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 716+ 7889 D2 8D 78    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 716+ 788C 09          >                        add     hl,bc           ;revert subtraction of divisor
 716+ 788D 3F          >.skip_revert0:          ccf                     ;complement carry
 716+ 788E CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 716+ 7892 EB          >                        ex      de,hl
 716+ 7893 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 716+ 7897 EB          >                        ex      de,hl
 716+ 7898 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 716+ 789B D2 9F 78    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 716+ 789E 09          >                        add     hl,bc           ;revert subtraction of divisor
 716+ 789F 3F          >.skip_revert1:          ccf                     ;complement carry
 717+ 78A0                                      L_DIV_0_ITERATION
 717+ 78A0 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 717+ 78A4 EB          >                        ex      de,hl
 717+ 78A5 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 717+ 78A9 EB          >                        ex      de,hl
 717+ 78AA B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 717+ 78AD D2 B1 78    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 717+ 78B0 09          >                        add     hl,bc           ;revert subtraction of divisor
 717+ 78B1 3F          >.skip_revert0:          ccf                     ;complement carry
 717+ 78B2 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 717+ 78B6 EB          >                        ex      de,hl
 717+ 78B7 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 717+ 78BB EB          >                        ex      de,hl
 717+ 78BC B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 717+ 78BF D2 C3 78    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 717+ 78C2 09          >                        add     hl,bc           ;revert subtraction of divisor
 717+ 78C3 3F          >.skip_revert1:          ccf                     ;complement carry
 718+ 78C4                                      L_DIV_0_ITERATION
 718+ 78C4 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 718+ 78C8 EB          >                        ex      de,hl
 718+ 78C9 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 718+ 78CD EB          >                        ex      de,hl
 718+ 78CE B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 718+ 78D1 D2 D5 78    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 718+ 78D4 09          >                        add     hl,bc           ;revert subtraction of divisor
 718+ 78D5 3F          >.skip_revert0:          ccf                     ;complement carry
 718+ 78D6 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 718+ 78DA EB          >                        ex      de,hl
 718+ 78DB CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 718+ 78DF EB          >                        ex      de,hl
 718+ 78E0 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 718+ 78E3 D2 E7 78    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 718+ 78E6 09          >                        add     hl,bc           ;revert subtraction of divisor
 718+ 78E7 3F          >.skip_revert1:          ccf                     ;complement carry
 719+ 78E8                                      L_DIV_0_ITERATION
 719+ 78E8 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 719+ 78EC EB          >                        ex      de,hl
 719+ 78ED CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 719+ 78F1 EB          >                        ex      de,hl
 719+ 78F2 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 719+ 78F5 D2 F9 78    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 719+ 78F8 09          >                        add     hl,bc           ;revert subtraction of divisor
 719+ 78F9 3F          >.skip_revert0:          ccf                     ;complement carry
 719+ 78FA CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 719+ 78FE EB          >                        ex      de,hl
 719+ 78FF CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 719+ 7903 EB          >                        ex      de,hl
 719+ 7904 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 719+ 7907 D2 0B 79    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 719+ 790A 09          >                        add     hl,bc           ;revert subtraction of divisor
 719+ 790B 3F          >.skip_revert1:          ccf                     ;complement carry
 720+ 790C                                      L_DIV_0_ITERATION
 720+ 790C CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 720+ 7910 EB          >                        ex      de,hl
 720+ 7911 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 720+ 7915 EB          >                        ex      de,hl
 720+ 7916 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 720+ 7919 D2 1D 79    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 720+ 791C 09          >                        add     hl,bc           ;revert subtraction of divisor
 720+ 791D 3F          >.skip_revert0:          ccf                     ;complement carry
 720+ 791E CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 720+ 7922 EB          >                        ex      de,hl
 720+ 7923 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 720+ 7927 EB          >                        ex      de,hl
 720+ 7928 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 720+ 792B D2 2F 79    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 720+ 792E 09          >                        add     hl,bc           ;revert subtraction of divisor
 720+ 792F 3F          >.skip_revert1:          ccf                     ;complement carry
 721+ 7930 CB 13 CB 12                          rl      de              ;left shift dividend + quotient carry
 722+ 7934 EB                                   ex      de,hl           ;dividend<>remainder
 723+ 7935 C9                                   ret
 724+ 7936
 725+ 7936
 726+ 7936
 727+ 7936
 728+ 7936 11 FE FF     LLHLdivC:               ld      de,$FFFE                    ; set XY to &FFFE at start, de holds XY
 729+ 7939              .LL130:                 ShiftHLLeft1                        ; RS *= 2
 729+ 7939 CB 25       >			   sla l
 729+ 793B CB 14       >			   rl  h
 730+ 793D 7C                                   ld      a,h
 731+ 793E 38 04                                jr      c,.LL131                    ; if S overflowed skip Q test and do subtractions
 732+ 7940                                      JumpIfALTNusng c, .LL132            ; if S <  Q = 256/gradient skip subtractions
 732+ 7940 B9          >                        cp      c
 732+ 7941 DA 4C 79    >                        jp		c, .LL132
 733+ 7944 3F           .LL131:                 ccf                                 ; compliment carry
 734+ 7945 99                                   sbc     a,c                         ; q
 735+ 7946 67                                   ld      h,a                         ; h (s)
 736+ 7947 7D                                   ld      a,l                         ; r
 737+ 7948 DE 00                                sbc     a,0                         ; 0 - so in effect SR - Q*256
 738+ 794A 37                                   scf                                 ; set carry for next rolls
 739+ 794B 3F                                   ccf
 740+ 794C              .LL132:                 RollDELeft1                         ; Rotate de bits left
 740+ 794C CB 13       >               rl  e
 740+ 794E CB 12       >               rl  d
 741+ 7950 38 E7                                jr      c,.LL130                    ;
 742+ 7952 EB                                   ex      de,hl                       ; hl = result
 743+ 7953 C9                                   ret
 744+ 7954
 745+ 7954
 746+ 7954 AF           div_hl_c:               xor	a
 747+ 7955 06 10                                ld	b, 16
 748+ 7957 29           .loop:                  add	hl, hl
 749+ 7958 17                                   rla
 750+ 7959 38 03                                jr	c, $+5
 751+ 795B B9                                   cp	c
 752+ 795C 38 02                                jr	c, $+4
 753+ 795E 91                                   sub	c
 754+ 795F 2C                                   inc	l
 755+ 7960 10 F5                                djnz	.loop
 756+ 7962 C9                                   ret
 757+ 7963              ;l_div, signed division
 758+ 7963              ; comes in with DE and HL
 759+ 7963              ; HL = DE / HL, DE = DE % HL
 760+ 7963 4A           l_div:                  ld      c,d             ;sign of dividend
 761+ 7964 44                                   ld      b,h             ;sign of divisor
 762+ 7965 C5                                   push    bc              ;save signs
 763+ 7966 4D                                   ld      c,l             ;divisor to bc
 764+ 7967 7A                                   ld      a,d
 765+ 7968 B7                                   or      a
 766+ 7969 F2 72 79                             jp      p,.NotDENeg
 767+ 796C              .DeNegate:              macronegate16de
 767+ 796C AF          >					xor 	a
 767+ 796D 93          >                    sub 	e
 767+ 796E 5F          >                    ld 		e,a
 767+ 796F 9F          >                    sbc 	a,a
 767+ 7970 92          >                    sub 	d
 767+ 7971 57          >                    ld 		d,a
 768+ 7972 78           .NotDENeg:              ld      a,b
 769+ 7973 B7                                   or      a
 770+ 7974 F2 7D 79                             jp      p,.NotBCNeg     ; if signs are opposite them flip
 771+ 7977                                      macronegate16bc
 771+ 7977 AF          >					xor 	a
 771+ 7978 91          >                    sub 	c
 771+ 7979 4F          >                    ld 		c,a
 771+ 797A 9F          >                    sbc 	a,a
 771+ 797B 90          >                    sub 	b
 771+ 797C 47          >                    ld 		b,a
 772+ 797D CD 0D 78     .NotBCNeg:              call    l_div_0         ;unsigned HL = DE / BC, DE = DE % BC
 773+ 7980                                      ; C standard requires that the result of division satisfy a = (a/b)*b + a%b emainder takes sign of the dividend
 774+ 7980 C1                                   pop     bc              ;restore sign info
 775+ 7981 78                                   ld      a,b
 776+ 7982 A9                                   xor     c               ;quotient, sign of dividend^divisor
 777+ 7983 F2 8C 79                             jp      p,.NotHLNeg
 778+ 7986                                      macronegate16hl
 778+ 7986 AF          >					xor 	a
 778+ 7987 95          >					sub 	l
 778+ 7988 6F          >					ld 		l,a
 778+ 7989 9F          >					sbc 	a,a
 778+ 798A 94          >					sub 	h
 778+ 798B 67          >					ld 		h,a
 779+ 798C 79           .NotHLNeg:              ld      a,c
 780+ 798D B7                                   or      a,a             ;remainder, sign of dividend
 781+ 798E F0                                   ret     p
 782+ 798F                                      macronegate16de
 782+ 798F AF          >					xor 	a
 782+ 7990 93          >                    sub 	e
 782+ 7991 5F          >                    ld 		e,a
 782+ 7992 9F          >                    sbc 	a,a
 782+ 7993 92          >                    sub 	d
 782+ 7994 57          >                    ld 		d,a
 783+ 7995 C9                                   ret
 784+ 7996
# file closed: ../../Maths/asm_divide.asm
1354  7996                  INCLUDE "../../Maths/asm_unitvector.asm"
# file opened: ../../Maths/asm_unitvector.asm
   1+ 7996              asm_tis2:
   2+ 7996              ; ">TIS2 A = (A / Q * 96) so A = -96 ---- 96  range "
   3+ 7996              ; ">DOES NOT DO SIGNED YET"
   4+ 7996 F5           	push af
   5+ 7997 E6 7F            and SignMask8Bit
   6+ 7999 57           	ld d,a				;; d = A
   7+ 799A 3A 16 6C     	ld a,(varQ)
   8+ 799D 5F           	ld e,a
   9+ 799E 7A           	ld a,d
  10+ 799F BB           	cp e
  11+ 79A0 30 11        	jr nc, .tis2_set96	;; jump if a >= Q
  12+ 79A2 1E 60        	ld e, 96
  13+ 79A4 ED 30        	mul				; de = d * 96 (also a * 96 )
  14+ 79A6 EB           	ex de,hl
  15+ 79A7 3A 16 6C     	ld a,(varQ)
  16+ 79AA 4F           	ld c,a
  17+ 79AB CD E5 76     	call asm_div16
  18+ 79AE F1           	pop af
  19+ 79AF E6 80        	and $80
  20+ 79B1 B5           	or l
  21+ 79B2 C9           	ret
  22+ 79B3              .tis2_set96:
  23+ 79B3 F1           	pop af
  24+ 79B4 E6 80        	and $80
  25+ 79B6 F6 96        	or $96
  26+ 79B8 C9           	ret
  27+ 79B9
  28+ 79B9
  29+ 79B9              asm_unit_vector:
  30+ 79B9              squareregfx:
  31+ 79B9 3A E7 C0     	ld a,(UBnkXScaled)
  32+ 79BC 57           	ld d,a
  33+ 79BD 5F           	ld e,a
  34+ 79BE ED 30        	mul
  35+ 79C0 EB           	ex de,hl
  36+ 79C1              squareregfy:
  37+ 79C1 3A E9 C0     	ld a, (UBnkYScaled)
  38+ 79C4 57           	ld d,a
  39+ 79C5 5F           	ld e,a
  40+ 79C6 ED 30        	mul
  41+ 79C8 19           	add hl,de
  42+ 79C9              squareregfz:
  43+ 79C9 3A EB C0     	ld a, (UBnkZScaled)
  44+ 79CC 57           	ld d,a
  45+ 79CD 5F           	ld e,a
  46+ 79CE ED 30        	mul
  47+ 79D0 19           	add hl,de
  48+ 79D1 EB           	ex de,hl			; de de to number to root
  49+ 79D2              hlequsquareroot:
  50+ 79D2 CD A7 72     	call asm_sqrt		; hl = sqrt (fx^2 + fy^2 + fx^2)
  51+ 79D5 E5           	push hl				; save it for work 3 copies
  52+ 79D6 E5           	push hl				; save it for work
  53+ 79D7 E5           	push hl				; save it for work
  54+ 79D8              normfx:
  55+ 79D8 3A E7 C0     	ld a,(UBnkXScaled)
  56+ 79DB E1           	pop hl				; get copy #1
  57+ 79DC 7D           	ld a,l				; we assume only l had worthwhile data but could spill into h
  58+ 79DD 4F           	ld c,a
  59+ 79DE CD 96 79     	call asm_tis2
  60+ 79E1 32 E7 C0     	ld (UBnkXScaled),a
  61+ 79E4              normfy:
  62+ 79E4 3A E9 C0     	ld a,(UBnkYScaled)
  63+ 79E7 E1           	pop hl				; get copy #2
  64+ 79E8 7D           	ld a,l
  65+ 79E9 4F           	ld c,a
  66+ 79EA CD 96 79     	call asm_tis2
  67+ 79ED 32 E9 C0     	ld (UBnkYScaled),a
  68+ 79F0              normfz:
  69+ 79F0 3A EB C0     	ld a,(UBnkZScaled)
  70+ 79F3 E1           	pop hl				; get copy #2
  71+ 79F4 7D           	ld a,l
  72+ 79F5 4F           	ld c,a
  73+ 79F6 CD 96 79     	call asm_tis2
  74+ 79F9 32 EB C0     	ld (UBnkZScaled),a
  75+ 79FC              asm_unit_vector_end:
  76+ 79FC C9           	ret
  77+ 79FD
# file closed: ../../Maths/asm_unitvector.asm
1355  79FD                  INCLUDE "../../Maths/compare16.asm"
# file opened: ../../Maths/compare16.asm
   1+ 79FD              ; Input:
   2+ 79FD              ;       HL = 1st value
   3+ 79FD              ;       DE = 2nd value
   4+ 79FD              ; Output:
   5+ 79FD              ;       CF, ZF = results of comparison:
   6+ 79FD              ;
   7+ 79FD              ;               CF      ZF      Result
   8+ 79FD              ;               -----------------------------------
   9+ 79FD              ;               0       0       HL > DE
  10+ 79FD              ;               0       1       HL == DE
  11+ 79FD              ;               1       0       HL < DE
  12+ 79FD              ;               1       1       Impossible
  13+ 79FD              ;
  14+ 79FD
  15+ 79FD
  16+ 79FD E5           CompareBCDESigned:  push    hl
  17+ 79FE A7                               and     a
  18+ 79FF 60 69                            ld      hl,bc
  19+ 7A01 ED 52                            sbc     hl,de
  20+ 7A03 E1                               pop     hl
  21+ 7A04 C9                               ret
  22+ 7A05
  23+ 7A05 E5           CompareDEBCSigned:  push    hl
  24+ 7A06 A7                               and     a
  25+ 7A07 62 6B                            ld      hl,de
  26+ 7A09 ED 42                            sbc     hl,bc
  27+ 7A0B E1                               pop     hl
  28+ 7A0C C9                               ret
  29+ 7A0D
  30+ 7A0D
  31+ 7A0D              ;### CMPGTE -> test if A>=B
  32+ 7A0D              ;### Input      HL=A, DE=B if hl=> de no carry else de > hl and set carry
  33+ 7A0D 7C           CompareHLDESgn:     ld a,h
  34+ 7A0E AA                               xor d
  35+ 7A0F FA 19 7A                         jp m, .cmpgte2
  36+ 7A12 ED 52                            sbc hl,de
  37+ 7A14 30 09                            jr nc, .cmpgte3
  38+ 7A16 19           .cmpgte1            add hl,de
  39+ 7A17                                  SetCarryFlag
  39+ 7A17 37          >                        scf
  40+ 7A18 C9                               ret
  41+ 7A19 CB 7A        .cmpgte2            bit 7,d
  42+ 7A1B 28 05                            jr z,.cmpgte4
  43+ 7A1D              .cmpgte5:           ClearCarryFlag
  43+ 7A1D B7          >                        or a
  44+ 7A1E C9                               ret
  45+ 7A1F 19           .cmpgte3            add hl,de
  46+ 7A20                                  ClearCarryFlag
  46+ 7A20 B7          >                        or a
  47+ 7A21 C9                               ret
  48+ 7A22              .cmpgte4:           SetCarryFlag
  48+ 7A22 37          >                        scf
  49+ 7A23 C9                               ret
  50+ 7A24
  51+ 7A24              ; Compares HL and DE sets z flag if same, else nz
  52+ 7A24 7C           CompareHLDESame:    ld  a,h
  53+ 7A25 BA                               cp  d
  54+ 7A26 C0                               ret nz
  55+ 7A27 7D                               ld  a,l
  56+ 7A28 BB                               cp  e
  57+ 7A29 C9                               ret
  58+ 7A2A
  59+ 7A2A
  60+ 7A2A
  61+ 7A2A 7C           CompareHLBCSgn:     ld a,h
  62+ 7A2B A8                               xor b
  63+ 7A2C FA 35 7A                         jp m, .cmpgte2
  64+ 7A2F ED 42                            sbc hl,bc
  65+ 7A31 30 06                            jr nc, .cmpgte3
  66+ 7A33              .cmpgte1            SetCarryFlag
  66+ 7A33 37          >                        scf
  67+ 7A34 C9                               ret
  68+ 7A35 CB 78        .cmpgte2            bit 7,b
  69+ 7A37 28 FA                            jr z,.cmpgte1
  70+ 7A39              .cmpgte3            ClearCarryFlag
  70+ 7A39 B7          >                        or a
  71+ 7A3A C9                               ret
  72+ 7A3B
  73+ 7A3B              CompareHLDESigned:
  74+ 7A3B E5           compare16HLDE:      push    hl
  75+ 7A3C A7                               and     a
  76+ 7A3D ED 52                            sbc     hl,de
  77+ 7A3F E1                               pop     hl
  78+ 7A40 C9                               ret
  79+ 7A41              CompareHLBCSigned:
  80+ 7A41 E5           CompareHLBC:        push    hl
  81+ 7A42 A7                               and     a
  82+ 7A43 ED 42                            sbc     hl,bc
  83+ 7A45 E1                               pop     hl
  84+ 7A46 C9                               ret
  85+ 7A47
  86+ 7A47              ; With compare signed we do ABS comparison
  87+ 7A47              ; this is used for view ports as we just want to know if its +/- out side of 90 degrees
  88+ 7A47
  89+ 7A47 E5 D5        compare16HLDEABS:   push    hl,,de
  90+ 7A49 7C                               ld      a,h                                     ; Quick pass see of both the same sign
  91+ 7A4A E6 7F                            and     SignMask8Bit
  92+ 7A4C 67                               ld      h,a
  93+ 7A4D 7A                               ld      a,d                                     ; Quick pass see of both the same sign
  94+ 7A4E E6 7F                            and     SignMask8Bit
  95+ 7A50 57                               ld      d,a
  96+ 7A51 A7                               and     a
  97+ 7A52 ED 52                            sbc     hl,de
  98+ 7A54 D1 E1                            pop     hl,,de
  99+ 7A56 C9                               ret
 100+ 7A57
 101+ 7A57
# file closed: ../../Maths/compare16.asm
1356  7A57                  INCLUDE "../../Maths/normalise96.asm"
# file opened: ../../Maths/normalise96.asm
   1+ 7A57              ; a equal a / d * 96
   2+ 7A57              ; Tested and works with signed numbers
   3+ 7A57 DD 7E 01     NormaliseIXVector:      ld		a,(ix+1)			; Vector X high
   4+ 7A5A E6 7F                                and		SignMask8Bit        ; a = abs X high
   5+ 7A5C 57                                   ld      d,a                 ; hl = abs X ^ 2
   6+ 7A5D 5F                                   ld      e,a                 ; .
   7+ 7A5E ED 30                                mul     de                  ; .
   8+ 7A60 EB                                   ex      de,hl               ; .
   9+ 7A61 DD 7E 03                             ld		a,(ix+3)			; vector = Y high
  10+ 7A64 E6 7F                                and		SignMask8Bit        ; unsigned
  11+ 7A66 57                                   ld      d,a                 ; de = abs Y ^ 2
  12+ 7A67 5F                                   ld      e,a                 ; .
  13+ 7A68 ED 30                                mul     de                  ; .
  14+ 7A6A 19                                   add     hl,de               ; hl = x^2 + y ^2
  15+ 7A6B DD 7E 05                             ld		a,(ix+5)			; vector = Z high
  16+ 7A6E E6 7F                                and		SignMask8Bit        ; unsigned
  17+ 7A70 57                                   ld      d,a                 ; de = abs Z ^ 2
  18+ 7A71 5F                                   ld      e,a                 ; .
  19+ 7A72 ED 30                                mul     de                  ; .
  20+ 7A74 19                                   add     hl,de               ; de = x^2 + y ^2 + z ^ 2
  21+ 7A75 EB                                   ex      de,hl               ; .
  22+ 7A76 CD A7 72     .n96SQRT:               call	asm_sqrt			; hl = sqrt de
  23+ 7A79 DD 7E 01     .n96NORMX:              ld		a,(ix+1)
  24+ 7A7C 55                                   ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  25+ 7A7D CD AF 7C                             call	AequAdivDmul96Q8    ; does not use HL so we can retain it
  26+ 7A80 47                                   ld		b,a				    ; Sort out restoring sign bit
  27+ 7A81 0E 00                                ld      c,0                 ; .
  28+ 7A83 DD 71 00 DD                          ld		(ix+0),bc           ; .
  28+ 7A87 70 01
  29+ 7A89 DD 7E 03     .n96NORMY:              ld		a,(ix+3)
  30+ 7A8C 55                                   ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  31+ 7A8D CD AF 7C                             call	AequAdivDmul96Q8	; does not use HL so we can retain it
  32+ 7A90 47                                   ld		b,a				    ; Sort out restoring sign bit
  33+ 7A91 0E 00                                ld      c,0                 ; .
  34+ 7A93 DD 71 02 DD                          ld		(ix+2),bc           ; .
  34+ 7A97 70 03
  35+ 7A99 DD 7E 05     .n96NORMZ:              ld		a,(ix+5)
  36+ 7A9C 55                                   ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  37+ 7A9D CD AF 7C                             call	AequAdivDmul96Q8 	; does not use HL so we can retain it
  38+ 7AA0 47                                   ld		b,a				    ; Sort out restoring sign bit
  39+ 7AA1 0E 00                                ld      c,0                 ; .
  40+ 7AA3 DD 71 04 DD                          ld		(ix+4),bc           ; .
  40+ 7AA7 70 05
  41+ 7AA9 C9                                   ret
  42+ 7AAA
  43+ 7AAA              ; .NORM	\ -> &3BD6 \ Normalize 3-vector length of XX15
  44+ 7AAA 3A E7 C0     normaliseXX1596S7:      ld		a,(XX15VecX)	    ; XX15+0
  45+ 7AAD DD 67                                ld		ixh,a               ; ixh = signed x component
  46+ 7AAF E6 7F                                and		SignMask8Bit        ; a = unsigned version
  47+ 7AB1              .n96SQX:	            inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
  47+ 7AB1 5F          >			ld	e,a
  47+ 7AB2 57          >			ld  d,a
  47+ 7AB3 ED 30       >			mul
  48+ 7AB5 62                                   ld		h,d					; h == varR d = varO e= varA
  49+ 7AB6 6B                                   ld		l,e					; l == varQ  															:: so HL = XX15[x]^2
  50+ 7AB7 3A E8 C0     .n96SQY:                ld		a,(XX15VecY)
  51+ 7ABA DD 6F                                ld		ixl,a               ; ixl = signed y componet
  52+ 7ABC E6 7F                                and		SignMask8Bit                 ; = abs
  53+ 7ABE                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2		:: so DE = XX15[y]^2
  53+ 7ABE 5F          >			ld	e,a
  53+ 7ABF 57          >			ld  d,a
  53+ 7AC0 ED 30       >			mul
  54+ 7AC2 19                                   add		hl,de				; hl = XX15[x]^2 + XX15[y]^2
  55+ 7AC3 3A E9 C0     .n96SQZ:                ld		a,(XX15VecZ)			; Note comments say \ ZZ15+2  should be \ XX15+2 as per code
  56+ 7AC6 FD 67                                ld		iyh,a               ; iyh = signed
  57+ 7AC8 E6 7F                                and		SignMask8Bit                 ; unsigned
  58+ 7ACA                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2		:: so DE = XX15[z]^2
  58+ 7ACA 5F          >			ld	e,a
  58+ 7ACB 57          >			ld  d,a
  58+ 7ACC ED 30       >			mul
  59+ 7ACE 19           .n96SQADD:              add		hl,de				; hl = XX15[x]^2 + XX15[y]^2 + XX15[z]^2
  60+ 7ACF EB                                   ex		de,hl				; hl => de ready for square root
  61+ 7AD0 CD A7 72     .n96SQRT:               call	asm_sqrt			; hl = de = sqrt(XX15[x]^2 + XX15[y]^2 + XX15[z]^2), we just are interested in l which is the new Q
  62+ 7AD3 3A E7 C0     .n96NORMX:              ld		a,(XX15VecX)
  63+ 7AD6 E6 7F                                and		SignMask8Bit
  64+ 7AD8 4F                                   ld		c,a
  65+ 7AD9 55                                   ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  66+ 7ADA CD 65 7C                             call	AequAdivDmul967Bit	; does not use HL so we can retain it
  67+ 7ADD 47                                   ld		b,a				    ;++SGN
  68+ 7ADE DD 7C                                ld		a,ixh			    ;++SGN
  69+ 7AE0 E6 80                                and		$80				    ;++SGN
  70+ 7AE2 B0                                   or		b				    ;++SGN
  71+ 7AE3 32 E7 C0                             ld		(XX15VecX),a
  72+ 7AE6 3A E8 C0     .n96NORMY:              ld		a,(XX15VecY)
  73+ 7AE9 E6 7F                                and		SignMask8Bit
  74+ 7AEB 4F                                   ld		c,a
  75+ 7AEC 55                                   ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  76+ 7AED CD 65 7C                             call	AequAdivDmul967Bit     	; does not use HL so we can retain it
  77+ 7AF0 47                                   ld		b,a				    ;++SGN
  78+ 7AF1 DD 7D                                ld		a,ixl			    ;++SGN
  79+ 7AF3 E6 80                                and		$80				    ;++SGN
  80+ 7AF5 B0                                   or		b				    ;++SGN
  81+ 7AF6 32 E8 C0                             ld		(XX15VecY),a
  82+ 7AF9 3A E9 C0     .n96NORMZ:              ld		a,(XX15VecZ)
  83+ 7AFC E6 7F                                and		SignMask8Bit
  84+ 7AFE 4F                                   ld		c,a
  85+ 7AFF 55                                   ld		d,l				; Q(i.e. l) => D, later we can just pop into de
  86+ 7B00 CD 65 7C                             call	AequAdivDmul967Bit;AequAdivDmul96	; does not use HL so we can retain it
  87+ 7B03 47                                   ld		b,a				    ;++SGN
  88+ 7B04 FD 7C                                ld		a,iyh			    ;++SGN
  89+ 7B06 E6 80                                and		$80				    ;++SGN
  90+ 7B08 B0                                   or		b				    ;++SGN
  91+ 7B09 32 E9 C0                             ld		(XX15VecZ),a
  92+ 7B0C C9                                   ret
  93+ 7B0D
  94+ 7B0D              ; Normalise vector
  95+ 7B0D              ; scale Q = Sqrt (X^2 + Y^2 + Z^2)
  96+ 7B0D              ; X = X / Q with 96 = 1 , i.e X = X / Q * 3/8
  97+ 7B0D              ; Y = Y / Q with 96 = 1 , i.e Y = Y / Q * 3/8
  98+ 7B0D              ; Z = Z / Q with 96 = 1 , i.e Z = Z / Q * 3/8
  99+ 7B0D
 100+ 7B0D                      IFNDEF DEBUG_NO_TACTICS_CODE
 101+ 7B0D ~            ;------------------------------------------------------------
 102+ 7B0D ~            ; To normalise the 24 bit version, bring out sign into TargetVectorxsgn
 103+ 7B0D ~            ; and make UBnKTargetXpos = abs (UBnKTargetXPos)
 104+ 7B0D ~            ; set up UBnKTarget[XYZ]Pos with 7 bit version of vector normalised
 105+ 7B0D ~            ; set up UBnKTargetpXYZ]Sgn with the sign bit
 106+ 7B0D ~            NormalseUnivTarget:     ld      a,(UBnKTargetXPos+2)
 107+ 7B0D ~                                    ld      b,a
 108+ 7B0D ~                                    and     $80
 109+ 7B0D ~                                    ld      (UBnKTargetXPosSgn),a        ; Split out the sign into byte 3
 110+ 7B0D ~                                    ld      a,b
 111+ 7B0D ~                                    and     $7F
 112+ 7B0D ~                                    ld      (UBnKTargetXPos+2),a
 113+ 7B0D ~            .ABSYComponenet:        ld      a,(UBnKTargetYPos+2)
 114+ 7B0D ~                                    ld      b,a
 115+ 7B0D ~                                    and     $80
 116+ 7B0D ~                                    ld      (UBnKTargetYPosSgn),a        ; Split out the sign into byte 3
 117+ 7B0D ~                                    ld      a,b
 118+ 7B0D ~                                    and     $7F
 119+ 7B0D ~                                    ld      (UBnKTargetYPos+2),a
 120+ 7B0D ~            .ABSXZomponenet:        ld      a,(UBnKTargetZPos+2)
 121+ 7B0D ~                                    ld      b,a
 122+ 7B0D ~                                    and     $80
 123+ 7B0D ~                                    ld      (UBnKTargetZPosSgn),a        ; Split out the sign into byte 3
 124+ 7B0D ~                                    ld      a,b
 125+ 7B0D ~                                    and     $7F
 126+ 7B0D ~                                    ld      (UBnKTargetZPos+2),a
 127+ 7B0D ~            ;.. When we hit here the UBnKTargetX,Y and Z are 24 bit abs values to simplify scaling
 128+ 7B0D ~            .Scale:                 ld      hl, (TacticsVectorX)        ; pull 24 bit into registers
 129+ 7B0D ~                                    ld      a,(TacticsVectorX+2)        ; h l ixH = X
 130+ 7B0D ~                                    ld      ixh,a                       ;
 131+ 7B0D ~                                    ld      de, (TacticsVectorY)        ; d e iyH = Y
 132+ 7B0D ~                                    ld      a,(TacticsVectorY+2)        ;
 133+ 7B0D ~                                    ld      iyh,a                       ;
 134+ 7B0D ~                                    ld      bc, (TacticsVectorZ)        ; b c iyL = Y
 135+ 7B0D ~                                    ld      a,(TacticsVectorZ+2)        ;
 136+ 7B0D ~                                    ld      iyl,a                       ;
 137+ 7B0D ~            .ScaleLoop1:            ld      a,ixh                       ; first pass get to 16 bit
 138+ 7B0D ~                                    or      iyh
 139+ 7B0D ~                                    or      iyl
 140+ 7B0D ~                                    or      iyh
 141+ 7B0D ~                                    jp      z,.DoneScaling1
 142+ 7B0D ~                                    ShiftIXhHLRight1
 143+ 7B0D ~                                    ShiftIYhDERight1
 144+ 7B0D ~                                    ShiftIYlBCRight1
 145+ 7B0D ~            .DoneScaling1:          ;-- Now we have got here hl = X, de = Y, bc = Z
 146+ 7B0D ~                                    ;-- we cal just jump into the Normalize Tactics code
 147+ 7B0D ~            .ScaleLoop2:            ld      a,h
 148+ 7B0D ~                                    or      d
 149+ 7B0D ~                                    or      b
 150+ 7B0D ~                                    jr      z,.DoneScaling2
 151+ 7B0D ~                                    ShiftHLRight1
 152+ 7B0D ~                                    ShiftDERight1
 153+ 7B0D ~                                    ShiftBCRight1
 154+ 7B0D ~                                    jp      .ScaleLoop2
 155+ 7B0D ~            ;-- Now we are down to 8 bit values, so we need to scale again to get S7
 156+ 7B0D ~            .DoneScaling2:          ShiftHLRight1
 157+ 7B0D ~                                    ShiftDERight1
 158+ 7B0D ~                                    ShiftBCRight1
 159+ 7B0D ~            .CalculateLength:       push    hl,,de,,bc                  ; save vecrtor x y and z nwo they are scaled to 1 byte
 160+ 7B0D ~                                    ld      d,e                         ; hl = y ^ 2
 161+ 7B0D ~                                    mul     de                          ; .
 162+ 7B0D ~                                    ex      de,hl                       ; .
 163+ 7B0D ~                                    ld      d,e                         ; de = x ^ 2
 164+ 7B0D ~                                    mul     de                          ; .
 165+ 7B0D ~                                    add     hl,de                       ; hl = y^ 2 + x ^ 2
 166+ 7B0D ~                                    ld      d,c
 167+ 7B0D ~                                    ld      e,c
 168+ 7B0D ~                                    mul     de
 169+ 7B0D ~                                    add     hl,de                       ; hl =  y^ 2 + x ^ 2 + z ^ 2
 170+ 7B0D ~                                    ex      de,hl                       ; fix as hl was holding square
 171+ 7B0D ~                                    call    asm_sqrt                    ; hl = sqrt (de) = sqrt (x ^ 2 + y ^ 2 + z ^ 2)
 172+ 7B0D ~                                    ; add in logic if h is low then use lower bytes for all
 173+ 7B0D ~            .NormaliseZ:            ld      a,l                         ; save length into iyh
 174+ 7B0D ~                                    ld      iyh,a                       ; .
 175+ 7B0D ~                                    ld      d,a                         ;
 176+ 7B0D ~                                    pop     bc                          ; retrive z scaled
 177+ 7B0D ~                                    ld      a,c                         ; a = scaled byte
 178+ 7B0D ~                                    call    AequAdivDmul967Bit
 179+ 7B0D ~                                    ld      (TacticsVectorZ),a          ; now Tactics Vector Z byte 1 is value
 180+ 7B0D ~            .NormaliseY:            pop     de
 181+ 7B0D ~                                    ld      a,e
 182+ 7B0D ~                                    ld      d,iyh
 183+ 7B0D ~                                    call    AequAdivDmul967Bit
 184+ 7B0D ~                                    ld      (TacticsVectorY),a
 185+ 7B0D ~            .NormaliseX:            pop     hl
 186+ 7B0D ~                                    ld      a,l
 187+ 7B0D ~                                    ld      d,iyh
 188+ 7B0D ~                                    call    AequAdivDmul967Bit
 189+ 7B0D ~                                    ld      (TacticsVectorX),a          ;
 190+ 7B0D ~                                    ret
 191+ 7B0D ~
 192+ 7B0D ~                        DISPLAY "TODO: Missle AI only works on S15 spread over 24 bits, i.e. ignores Sign byte 7 bits"
 193+ 7B0D ~            ;-- This norallises the Tactics vector in memory as much as possible, uses 16 bits
 194+ 7B0D ~            NormalizeTactics:       ld      hl, (TacticsVectorX)        ; pull XX15 into registers
 195+ 7B0D ~                                    ld      de, (TacticsVectorY)        ; .
 196+ 7B0D ~                                    ld      bc, (TacticsVectorZ)        ; .
 197+ 7B0D ~            .ScaleLoop:             ld      a,h
 198+ 7B0D ~                                    or      d
 199+ 7B0D ~                                    or      b
 200+ 7B0D ~                                    jr      z,.DoneScaling
 201+ 7B0D ~                                    ShiftHLRight1
 202+ 7B0D ~                                    ShiftDERight1
 203+ 7B0D ~                                    ShiftBCRight1
 204+ 7B0D ~                                    jp      .ScaleLoop
 205+ 7B0D ~            .DoneScaling:           ShiftHLRight1                       ; as the values now need to be sign magnitued
 206+ 7B0D ~                                    ShiftDERight1                       ; e.g. S + 7 bit we need an extra shift
 207+ 7B0D ~                                    ShiftBCRight1                       ; now values are in L E C
 208+ 7B0D ~                                    push    hl,,de,,bc                  ; save vecrtor x y and z nwo they are scaled to 1 byte
 209+ 7B0D ~                                    ld      d,e                         ; hl = y ^ 2
 210+ 7B0D ~                                    mul     de                          ; .
 211+ 7B0D ~                                    ex      de,hl                       ; .
 212+ 7B0D ~                                    ld      d,e                         ; de = x ^ 2
 213+ 7B0D ~                                    mul     de                          ; .
 214+ 7B0D ~                                    add     hl,de                       ; hl = y^ 2 + x ^ 2
 215+ 7B0D ~                                    ld      d,c
 216+ 7B0D ~                                    ld      e,c
 217+ 7B0D ~                                    mul     de
 218+ 7B0D ~                                    add     hl,de                       ; hl =  y^ 2 + x ^ 2 + z ^ 2
 219+ 7B0D ~                                    ex      de,hl                       ; fix as hl was holding square
 220+ 7B0D ~                                    call    asm_sqrt                    ; hl = sqrt (de) = sqrt (x ^ 2 + y ^ 2 + z ^ 2)
 221+ 7B0D ~                                    ; add in logic if h is low then use lower bytes for all
 222+ 7B0D ~                                    ld      a,l
 223+ 7B0D ~                                    ld      iyh,a
 224+ 7B0D ~                                    ld      d,a
 225+ 7B0D ~                                    pop     bc                          ; retrive tacticsvectorz scaled
 226+ 7B0D ~                                    ld      a,c                         ; a = scaled byte
 227+ 7B0D ~                                    call    AequAdivDmul967Bit;AequAdivDmul96Unsg          ; This rountine I think is wrong and retuins bad values
 228+ 7B0D ~                                    ld      (TacticsVectorZ),a
 229+ 7B0D ~                                    pop     de
 230+ 7B0D ~                                    ld      a,e
 231+ 7B0D ~                                    ld      d,iyh
 232+ 7B0D ~                                    call    AequAdivDmul967Bit;AequAdivDmul96Unsg
 233+ 7B0D ~                                    ld      (TacticsVectorY),a
 234+ 7B0D ~                                    pop     hl
 235+ 7B0D ~                                    ld      a,l
 236+ 7B0D ~                                    ld      d,iyh
 237+ 7B0D ~                                    call    AequAdivDmul967Bit;AequAdivDmul96Unsg
 238+ 7B0D ~                                    ld      (TacticsVectorX),a
 239+ 7B0D ~                                    ; BODGE FOR NOW
 240+ 7B0D ~                                    ZeroA                              ;; added to help debugging
 241+ 7B0D ~                                    ld      (TacticsVectorX+1),a       ;; added to help debugging
 242+ 7B0D ~                                    ld      (TacticsVectorY+1),a       ;; added to help debugging
 243+ 7B0D ~                                    ld      (TacticsVectorZ+1),a       ;; added to help debugging
 244+ 7B0D ~                                    SignBitOnlyMem TacticsVectorX+2     ; now upper byte is sign only
 245+ 7B0D ~                                    SignBitOnlyMem TacticsVectorY+2     ; (could move it to lower perhaps later if
 246+ 7B0D ~                                    SignBitOnlyMem TacticsVectorZ+2     ;  its worth it)
 247+ 7B0D ~                                  ;; oly using byte 2 for sign  ldCopyByte TacticsVectorX+2, TacticsVectorX+1
 248+ 7B0D ~                                  ;; oly using byte 2 for sign  ldCopyByte TacticsVectorY+2, TacticsVectorY+1
 249+ 7B0D ~                                  ;; oly using byte 2 for sign  ldCopyByte TacticsVectorZ+2, TacticsVectorZ+1
 250+ 7B0D ~                                  ;; oly using byte 2 for sign  SignBitOnlyMem TacticsVectorX+1     ; now upper byte is sign only
 251+ 7B0D ~                                  ;; oly using byte 2 for sign  SignBitOnlyMem TacticsVectorY+1     ; (could move it to lower perhaps later if
 252+ 7B0D ~                                  ;; oly using byte 2 for sign  SignBitOnlyMem TacticsVectorZ+1     ;  its worth it)
 253+ 7B0D ~                                    ret
 254+ 7B0D                      ENDIF
 255+ 7B0D
# file closed: ../../Maths/normalise96.asm
1357  7B0D                  INCLUDE "../../Maths/binary_to_decimal.asm"
# file opened: ../../Maths/binary_to_decimal.asm
   1+ 7B0D              ;Number in hl to decimal ASCII
   2+ 7B0D              ;Thanks to z80 Bits
   3+ 7B0D              ;inputs:	hl = number to ASCII
   4+ 7B0D              ;example: hl=300 outputs '00300'
   5+ 7B0D              ;destroys: af, bc, hl, de used
   6+ 7B0D              DispHLtoDE:
   7+ 7B0D              ; "DispHL, writes HL to DE address"
   8+ 7B0D 01 F0 D8     	ld	bc,-10000
   9+ 7B10 CD 26 7B     	call	Num1
  10+ 7B13 01 18 FC     	ld	bc,-1000
  11+ 7B16 CD 26 7B     	call	Num1
  12+ 7B19 01 9C FF     	ld	bc,-100
  13+ 7B1C CD 26 7B     	call	Num1
  14+ 7B1F 0E F6        	ld	c,-10
  15+ 7B21 CD 26 7B     	call	Num1
  16+ 7B24 0E FF        	ld	c,-1
  17+ 7B26              Num1:
  18+ 7B26 3E 2F        	ld	a,'0'-1
  19+ 7B28              .Num2:
  20+ 7B28 3C           	inc	a
  21+ 7B29 09           	add	hl,bc
  22+ 7B2A 38 FC        	jr	c,.Num2
  23+ 7B2C ED 42        	sbc	hl,bc
  24+ 7B2E 12           	ld	(de),a
  25+ 7B2F 13           	inc	de
  26+ 7B30 C9           	ret
  27+ 7B31
  28+ 7B31              DispAtoDE:
  29+ 7B31 26 00        	ld h,0
  30+ 7B33 6F           	ld l,a
  31+ 7B34 C3 0D 7B     	jp DispHLtoDE
  32+ 7B37
  33+ 7B37              DispPriceAtoDE:
  34+ 7B37 26 00        	ld h,0
  35+ 7B39 6F           	ld l,a
  36+ 7B3A 01 9C FF     	ld	bc,-100
  37+ 7B3D CD 4D 7B     	call	.NumLeadBlank1
  38+ 7B40 0E F6        	ld	c,-10
  39+ 7B42 CD 26 7B     	call	Num1
  40+ 7B45 3E 2E        	ld		a,'.'					; we could assume preformat but
  41+ 7B47                                  DISPLAY "TODO:  optimise "
  42+ 7B47 12           	ld		(de),a					; we can optimse that later TODO
  43+ 7B48 13           	inc		de						; with just an inc De
  44+ 7B49 0E FF        	ld	c,-1
  45+ 7B4B 18 D9        	jr		Num1
  46+ 7B4D              .NumLeadBlank1:
  47+ 7B4D 3E 2F        	ld	a,'0'-1
  48+ 7B4F              .NumLeadBlank2:
  49+ 7B4F 3C           	inc	a
  50+ 7B50 09           	add	hl,bc
  51+ 7B51 38 FC        	jr	c,.NumLeadBlank2
  52+ 7B53 FE 30        	cp	'0'
  53+ 7B55 20 02        	jr	nz,.DontBlank
  54+ 7B57              .Blank:
  55+ 7B57 3E 20        	ld	a,' '
  56+ 7B59              .DontBlank:
  57+ 7B59 ED 42        	sbc	hl,bc
  58+ 7B5B 12           	ld	(de),a
  59+ 7B5C 13           	inc	de
  60+ 7B5D C9           	ret
  61+ 7B5E
  62+ 7B5E              DispQtyAtoDE:
  63+ 7B5E FE 00        	cp	0
  64+ 7B60 28 23        	jr	z,.NoStock
  65+ 7B62 26 00        	ld h,0
  66+ 7B64 6F           	ld l,a
  67+ 7B65 01 9C FF     	ld	bc,-100
  68+ 7B68 CD 74 7B     	call	.NumLeadBlank1
  69+ 7B6B 0E F6        	ld	c,-10
  70+ 7B6D CD 74 7B     	call	.NumLeadBlank1
  71+ 7B70 0E FF        	ld	c,-1
  72+ 7B72 18 B2        	jr		Num1
  73+ 7B74              .NumLeadBlank1:
  74+ 7B74 3E 2F        	ld	a,'0'-1
  75+ 7B76              .NumLeadBlank2:
  76+ 7B76 3C           	inc	a
  77+ 7B77 09           	add	hl,bc
  78+ 7B78 38 FC        	jr	c,.NumLeadBlank2
  79+ 7B7A FE 30        	cp	'0'
  80+ 7B7C 20 02        	jr	nz,.DontBlank
  81+ 7B7E              .Blank:
  82+ 7B7E 3E 20        	ld	a,' '
  83+ 7B80              .DontBlank:
  84+ 7B80 ED 42        	sbc	hl,bc
  85+ 7B82 12           	ld	(de),a
  86+ 7B83 13           	inc	de
  87+ 7B84 C9           	ret
  88+ 7B85              .NoStock:
  89+ 7B85 3E 20        	ld	a,' '
  90+ 7B87 12           	ld	(de),a
  91+ 7B88 13           	inc	de
  92+ 7B89 12           	ld	(de),a
  93+ 7B8A 13           	inc	de
  94+ 7B8B 3E 2D        	ld	a,'-'
  95+ 7B8D 12           	ld	(de),a
  96+ 7B8E 13           	inc de
  97+ 7B8F C9           	ret
  98+ 7B90
  99+ 7B90
 100+ 7B90              ;### CLCN32 -> Converts 32Bit-Value in ASCII-String (terminated by 0)
 101+ 7B90              ;### Input      DE,IX=32bit value, IY=destination address
 102+ 7B90              ;### Output     IY=last char in destination string
 103+ 7B90              ;### Destroyed AF,BC,DE,HL,IX
 104+ 7B90 01 00 00 00  clcn32t dw 1,0,     10,0,     100,0,     1000,0,       10000,0
 104+ 7B94 0A 00 00 00
 104+ 7B98 64 00 00 00
 104+ 7B9C E8 03 00 00
 104+ 7BA0 10 27 00 00
 105+ 7BA4 A0 86 01 00          dw $86a0,1, $4240,$0f, $9680,$98, $e100,$05f5, $ca00,$3b9a
 105+ 7BA8 40 42 0F 00
 105+ 7BAC 80 96 98 00
 105+ 7BB0 00 E1 F5 05
 105+ 7BB4 00 CA 9A 3B
 106+ 7BB8 00 00 00 00  clcn32z ds 4
 107+ 7BBC
 108+ 7BBC              ; As per display but shifts final digit by 1 and puts in "." for 1 decimal place
 109+ 7BBC CD CB 7B     DispDEIXtoIY1DP:        call    DispDEIXtoIY
 110+ 7BBF FD 7E 00                             ld      a,(IY+0)
 111+ 7BC2 FD 77 01                             ld      (IY+1),a
 112+ 7BC5 3E 2E                                ld      a,"."
 113+ 7BC7 FD 77 00                             ld      (IY+0),a
 114+ 7BCA C9                                   ret
 115+ 7BCB
 116+ 7BCB DD 22 B8 7B  DispDEIXtoIY:           ld (clcn32z),ix
 117+ 7BCF ED 53 BA 7B                          ld (clcn32z+2),de
 118+ 7BD3 DD 21 B4 7B                          ld ix,clcn32t+36
 119+ 7BD7 06 09                                ld b,9
 120+ 7BD9 0E 00                                ld c,0
 121+ 7BDB 3E 30        .clcn321:               ld a,'0'
 122+ 7BDD B7                                   or a
 123+ 7BDE DD 5E 00     .clcn322:               ld e,(ix+0)
 124+ 7BE1 DD 56 01                             ld d,(ix+1)
 125+ 7BE4 2A B8 7B                             ld hl,(clcn32z)
 126+ 7BE7 ED 52                                sbc hl,de
 127+ 7BE9 22 B8 7B                             ld (clcn32z),hl
 128+ 7BEC DD 5E 02                             ld e,(ix+2)
 129+ 7BEF DD 56 03                             ld d,(ix+3)
 130+ 7BF2 2A BA 7B                             ld hl,(clcn32z+2)
 131+ 7BF5 ED 52                                sbc hl,de
 132+ 7BF7 22 BA 7B                             ld (clcn32z+2),hl
 133+ 7BFA 38 04                                jr c,.clcn325
 134+ 7BFC 0C                                   inc c
 135+ 7BFD 3C                                   inc a
 136+ 7BFE 18 DE                                jr .clcn322
 137+ 7C00 DD 5E 00     .clcn325:               ld e,(ix+0)
 138+ 7C03 DD 56 01                             ld d,(ix+1)
 139+ 7C06 2A B8 7B                             ld hl,(clcn32z)
 140+ 7C09 19                                   add hl,de
 141+ 7C0A 22 B8 7B                             ld (clcn32z),hl
 142+ 7C0D DD 5E 02                             ld e,(ix+2)
 143+ 7C10 DD 56 03                             ld d,(ix+3)
 144+ 7C13 2A BA 7B                             ld hl,(clcn32z+2)
 145+ 7C16 ED 5A                                adc hl,de
 146+ 7C18 22 BA 7B                             ld (clcn32z+2),hl
 147+ 7C1B 11 FC FF                             ld de,-4
 148+ 7C1E DD 19                                add ix,de
 149+ 7C20 0C                                   inc c
 150+ 7C21 0D                                   dec c
 151+ 7C22 28 05                                jr z,.clcn323
 152+ 7C24 FD 77 00                             ld (iy+0),a
 153+ 7C27 FD 23                                inc iy
 154+ 7C29 10 B0        .clcn323:               djnz .clcn321
 155+ 7C2B 3A B8 7B                             ld a,(clcn32z)
 156+ 7C2E C6 30                                add A,'0'
 157+ 7C30 FD 77 00                             ld (iy+0),a
 158+ 7C33 FD 36 01 00                          ld (iy+1),0
 159+ 7C37 C9                                   ret
 160+ 7C38
# file closed: ../../Maths/binary_to_decimal.asm
1358  7C38                  INCLUDE "../../Maths/asm_AequAdivQmul96.asm"
# file opened: ../../Maths/asm_AequAdivQmul96.asm
   1+ 7C38              AequAdivQmul96ABS:      JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
   1+ 7C38 BA          >                        cp     d
   1+ 7C39 D2 54 7C    >                        jp		nc,.TIS2AccGTEQ
   2+ 7C3C 06 FE                                ld			b,$FE						; division roll (replaced varT)
   3+ 7C3E CB 27        .TIS2RollTLoop:			sla			a
   4+ 7C40                                      JumpIfALTNusng d,.TIS2SkipSub           ; a < d so don;t subtract
   4+ 7C40 BA          >                        cp      d
   4+ 7C41 DA 57 7C    >                        jp		c, .TIS2SkipSub
   5+ 7C44 9A                                   sbc			a,d							; do subtraction with carry
   6+ 7C45 37                                   scf
   7+ 7C46 CB 10                                rl			b							; T rolled left to push bit out the end
   8+ 7C48 38 F4                                jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
   9+ 7C4A 78           .TIS2SKIPCont:	        ld			a,b							; T
  10+ 7C4B CB 3F                                srl			a							; result / 2
  11+ 7C4D CB 3F                                srl			a							; result / 4
  12+ 7C4F 47                                   ld			b,a							; t = t /4
  13+ 7C50 CB 3F                                srl			a							; result / 8
  14+ 7C52 80                                   add			a,b							; result /8 + result /4
  15+ 7C53 C9                                   ret
  16+ 7C54 3E 60        .TIS2AccGTEQ:           ld			a,$60							; unity
  17+ 7C56 C9                                   ret
  18+ 7C57 B7           .TIS2SkipSub:           or			a
  19+ 7C58 CB 10                                rl			b							; T rolled left to push bit out the end
  20+ 7C5A 38 E2                                jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
  21+ 7C5C C3 4A 7C                             jp			.TIS2SKIPCont
  22+ 7C5F
  23+ 7C5F
  24+ 7C5F              ;; USES 			A DE BC
  25+ 7C5F              ;; DOES NOT USE 	HL
  26+ 7C5F              ;TIS2962C:		; two's compliment entry point, exits not 2's compliment
  27+ 7C5F              ;	bit			        7,a
  28+ 7C5F              ;	jr			        z,AequAdivQmul96
  29+ 7C5F              ;	neg			        							; revers 2s'c and just set neg bit
  30+ 7C5F              ;	set			        7,a
  31+ 7C5F              ;; Note negative numbers are bit 7 set not 2's compliment
  32+ 7C5F              AequAdivQmul96:								; TIS296:			; .tis2 A = A /Q *96 (or A = A * 3/8 * Q) Reduce Acc in NORM routine i.e. *96/Q clamps at +- 96
  33+ 7C5F              TIS2:
  34+ 7C5F 4F                                   ld			c,a							; copy of Acc
  35+ 7C60 3A 16 6C                             ld			a,(varQ)
  36+ 7C63 57                                   ld			d,a							; d = varQ
  37+ 7C64 79                                   ld			a,c							; recover a
  38+ 7C65 4F           AequAdivDmul967Bit:     ld          c,a
  39+ 7C66 7A                                   ld          a,d
  40+ 7C67 CB 27                                sla         a       ; wipe sign bit
  41+ 7C69 C8                                   ret         z       ; quick exit if dividing 0 as a will have the result of 0
  42+ 7C6A 30 10                                jr          nc, .OKToDivide
  43+ 7C6C B7           .ScaleDown:             or          a       ; clear carry bit
  44+ 7C6D CB 3A                                srl         d       ; d >> 1 to get back to 7 bit value
  45+ 7C6F 79                                   ld          a,c
  46+ 7C70 E6 7F                                and         SignMask8Bit
  47+ 7C72 CB 3F                                srl         a
  48+ 7C74 47                                   ld          b,a
  49+ 7C75 79                                   ld          a,c
  50+ 7C76 E6 80                                and         $80
  51+ 7C78 B0                                   or          b
  52+ 7C79 C3 7D 7C                             jp          AequAdivDmul96
  53+ 7C7C 79           .OKToDivide:            ld          a,c
  54+ 7C7D 4F           AequAdivDmul96:         ld			c,a							; copy of Acc as we need the sign, alternate entry point assuming D preloaded, wastes an "ld c,a" but simplifies code
  55+ 7C7E E6 7F                                and			SignMask8Bit				; ignore sign
  56+ 7C80                                      JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
  56+ 7C80 BA          >                        cp     d
  56+ 7C81 D2 A1 7C    >                        jp		nc,.TIS2AccGTEQ
  57+ 7C84 06 FE                                ld			b,$FE						; division roll (replaced varT)
  58+ 7C86              .TIS2RollTLoop:									; .TIL2	; roll T
  59+ 7C86 CB 27                                sla			a
  60+ 7C88                                      JumpIfALTNusng d,.TIS2SkipSub           ; a < d so don;t subtract
  60+ 7C88 BA          >                        cp      d
  60+ 7C89 DA A7 7C    >                        jp		c, .TIS2SkipSub
  61+ 7C8C 9A                                   sbc			a,d							; do subtraction with carry
  62+ 7C8D 37                                   scf                                     ; set carrry to roll into b
  63+ 7C8E CB 10                                rl			b							; T rolled left to push bit out the end
  64+ 7C90 38 F4                                jr			c,.TIS2RollTLoop			; if we still have not hit the empty marker continue
  65+ 7C92 78           .TIS2SKIPCont:	        ld			a,b							; A = T = 4 / 4
  66+ 7C93 CB 3F                                srl			a							; .
  67+ 7C95 CB 3F                                srl			a							; .
  68+ 7C97 47                                   ld			b,a							; .
  69+ 7C98 CB 3F                                srl			a							; A = A / 2 (i.e. T /8)
  70+ 7C9A 80                                   add			a,b							; A = T/8 + T/4 (3T/8)
  71+ 7C9B 47                                   ld			b,a							; b = 3/8*Acc (max = 96)
  72+ 7C9C 79                                   ld			a,c							; copy of Acc to look at sign bit
  73+ 7C9D E6 80                                and			$80							; recover sign only
  74+ 7C9F B0                                   or			b							; now put b back in so we have a leading sign bit (note not 2's compliment)
  75+ 7CA0 C9                                   ret
  76+ 7CA1              ;TI4:										;\ clean to +/- unity
  77+ 7CA1 79           .TIS2AccGTEQ:           ld			a,c
  78+ 7CA2 E6 80                                and			$80							; copy of Acc
  79+ 7CA4 F6 60                                or			$60							; unity
  80+ 7CA6 C9                                   ret
  81+ 7CA7              .TIS2SkipSub:           ClearCarryFlag                          ; Clear carry as it needs to be empty to roll in 0
  81+ 7CA7 B7          >                        or a
  82+ 7CA8 CB 10                                rl			b							; T rolled left to push bit out the end
  83+ 7CAA 38 DA                                jr			c,.TIS2RollTLoop			; if we still have not hit the empty marker continue
  84+ 7CAC C3 92 7C                             jp			.TIS2SKIPCont
  85+ 7CAF
  86+ 7CAF
  87+ 7CAF
  88+ 7CAF              ; as per AequAdivDmul967Bit but Q is an 8 bit unsigned
  89+ 7CAF              ; a = a(S7)/Q(8u)*96
  90+ 7CAF 4F           AequAdivDmul96Q8:       ld          c,a                         ; c = a
  91+ 7CB0 7A           .CheckDivide0:          ld          a,d                         ; check if its a / 0
  92+ 7CB1 A7                                   and         a                           ; .
  93+ 7CB2 CA D9 7C                             jp          z,.TIS2AccGTEQ              ; .
  94+ 7CB5 79           .NotDivide0:            ld          a,c                         ; get back value of A
  95+ 7CB6 E6 7F                                and         SignMask8Bit                ; and make it abs, so a = abs(a) c = original a
  96+ 7CB8                                      JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
  96+ 7CB8 BA          >                        cp     d
  96+ 7CB9 D2 D9 7C    >                        jp		nc,.TIS2AccGTEQ
  97+ 7CBC 06 FE                                ld			b,$FE						; division roll (replaced varT)
  98+ 7CBE              .TIS2RollTLoop:									; .TIL2	; roll T
  99+ 7CBE CB 27                                sla			a
 100+ 7CC0                                      JumpIfALTNusng d,.TIS2SkipSub           ; a < d so don;t subtract
 100+ 7CC0 BA          >                        cp      d
 100+ 7CC1 DA DF 7C    >                        jp		c, .TIS2SkipSub
 101+ 7CC4 9A                                   sbc			a,d							; do subtraction with carry
 102+ 7CC5 37                                   scf                                     ; set carrry to roll into b
 103+ 7CC6 CB 10                                rl			b							; T rolled left to push bit out the end
 104+ 7CC8 38 F4                                jr			c,.TIS2RollTLoop			; if we still have not hit the empty marker continue
 105+ 7CCA 78           .TIS2SKIPCont:	        ld			a,b							; A = T = 4 / 4
 106+ 7CCB CB 3F                                srl			a							; .
 107+ 7CCD CB 3F                                srl			a							; .
 108+ 7CCF 47                                   ld			b,a							; .
 109+ 7CD0 CB 3F                                srl			a							; A = A / 2 (i.e. T /8)
 110+ 7CD2 80                                   add			a,b							; A = T/8 + T/4 (3T/8)
 111+ 7CD3 47                                   ld			b,a							; b = 3/8*Acc (max = 96)
 112+ 7CD4 79                                   ld			a,c							; copy of Acc to look at sign bit
 113+ 7CD5 E6 80                                and			SignOnly8Bit    			; recover sign only
 114+ 7CD7 B0                                   or			b							; now put b back in so we have a leading sign bit (note not 2's compliment)
 115+ 7CD8 C9                                   ret
 116+ 7CD9              ;TI4:										;\ clean to +/- unity
 117+ 7CD9 79           .TIS2AccGTEQ:           ld			a,c
 118+ 7CDA E6 80                                and			$80							; copy of Acc
 119+ 7CDC F6 60                                or			$60							; unity
 120+ 7CDE C9                                   ret
 121+ 7CDF              .TIS2SkipSub:           ClearCarryFlag                          ; Clear carry as it needs to be empty to roll in 0
 121+ 7CDF B7          >                        or a
 122+ 7CE0 CB 10                                rl			b							; T rolled left to push bit out the end
 123+ 7CE2 38 DA                                jr			c,.TIS2RollTLoop			; if we still have not hit the empty marker continue
 124+ 7CE4 C3 CA 7C                             jp			.TIS2SKIPCont
 125+ 7CE7
 126+ 7CE7
# file closed: ../../Maths/asm_AequAdivQmul96.asm
1359  7CE7                  INCLUDE "../../Maths/Utilities/AequAmulQdiv256-FMLTU.asm"
# file opened: ../../Maths/Utilities/AequAmulQdiv256-FMLTU.asm
   1+ 7CE7              ; "ASM_FMUTKL .FMLTU	\ -> &2847  \ A=A*Q/256unsg  Fast multiply"
   2+ 7CE7              fmltu:
   3+ 7CE7 57           AequAmulQdiv256:        ld	d,a
   4+ 7CE8 3A 16 6C                             ld	a,(varQ)
   5+ 7CEB 5F                                   ld	e,a
   6+ 7CEC ED 30                                mul
   7+ 7CEE 7A                                   ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
   8+ 7CEF C9                                   ret
   9+ 7CF0
  10+ 7CF0 5F           AequAmulDdiv256:        ld  e,a
  11+ 7CF1 ED 30                                mul
  12+ 7CF3 7A                                   ld  a,d
  13+ 7CF4 C9                                   ret
  14+ 7CF5
# file closed: ../../Maths/Utilities/AequAmulQdiv256-FMLTU.asm
1360  7CF5                  INCLUDE "../../Maths/Utilities/APequQmulA-MULT1.asm"
# file opened: ../../Maths/Utilities/APequQmulA-MULT1.asm
   1+ 7CF5              APequQmulA:
   2+ 7CF5              asm_mult1:
   3+ 7CF5              ; "ASM_MULT1 (DE) A(hi).P(lo) = Q * A first part of MAD, multiply and add. Visited Quite often. A=hi P = lo also returns result in DE"
   4+ 7CF5 FE 00        	cp	0
   5+ 7CF7 28 1F        	jr	z,.mul0			; quick exit if its Q * 0
   6+ 7CF9 5F           	ld	e,a
   7+ 7CFA 3A 16 6C     	ld	a,(varQ)
   8+ 7CFD 57           	ld	d,a
   9+ 7CFE FE 00        	cp	0				; compare a
  10+ 7D00 28 16        	jr	z,.mul0			; quick exit if its 0 * a
  11+ 7D02 AB           	xor	e				; -- = + +- = - -+ = - ++ = +
  12+ 7D03 E6 80        	and $80				; get the resultant sign and save into b
  13+ 7D05 47           	ld	b,a
  14+ 7D06 7A           	ld	a,d
  15+ 7D07 E6 7F        	and	SignMask8Bit	; now strip off sign bits
  16+ 7D09 57           	ld	d,a
  17+ 7D0A 7B           	ld	a,e
  18+ 7D0B E6 7F        	and SignMask8Bit
  19+ 7D0D 5F           	ld	e,a
  20+ 7D0E ED 30        	mul					; zxn de = d * e
  21+ 7D10 7B           	ld	a,e
  22+ 7D11 32 16 6B     	ld	(varP),a		; p = lo
  23+ 7D14 7A           	ld	a,d				; a = hi
  24+ 7D15 B0           	or	b				; de goes to a and varP also re-do sign bit
  25+ 7D16 57           	ld	d,a				; we will work with de having result as we may bin vars later
  26+ 7D17 C9           	ret
  27+ 7D18              .mul0:
  28+ 7D18 AF           	xor	a
  29+ 7D19 32 16 6B     	ld	(varP),a
  30+ 7D1C 57           	ld	d,a
  31+ 7D1D 5F           	ld  e,a
  32+ 7D1E C9           	ret
  33+ 7D1F
# file closed: ../../Maths/Utilities/APequQmulA-MULT1.asm
1361  7D1F                  INCLUDE "../../Maths/Utilities/badd_ll38.asm"
# file opened: ../../Maths/Utilities/badd_ll38.asm
   1+ 7D1F              baddll38:				;.LL38	\ -> &4812 \ BADD(S)A=R+Q(SA) \ byte add (subtract)   (Sign S)A = R + Q*(Sign from A^S)
   2+ 7D1F              SAEquSRPlusAQ:
   3+ 7D1F              ; Calculate the following between sign-magnitude numbers:
   4+ 7D1F              ;   (S A) = (S R) + (A Q)
   5+ 7D1F              ; where the sign bytes only contain the sign bits, not magnitudes.
   6+ 7D1F              ; note goes wrong at <-127 >128 so need 16 bit version
   7+ 7D1F              ; so need to fix the issue with carry flag not returning a fault correctly
   8+ 7D1F              LL38:
   9+ 7D1F              ;	ld		d,a
  10+ 7D1F              ;	ld		a,(varQ)
  11+ 7D1F              ;	ld		e,a
  12+ 7D1F              ;	ld		a,(varS)
  13+ 7D1F              ;	ld		h,a
  14+ 7D1F              ;	ld		a,(varR)
  15+ 7D1F              ;	ld		l,a
  16+ 7D1F              ;	call	ADDHLDESignedv3
  17+ 7D1F              ;	ld		a,h
  18+ 7D1F              ;	ld		(varS),a
  19+ 7D1F              ;	ld		a,l
  20+ 7D1F              ;	ret
  21+ 7D1F              ; calculation table
  22+ 7D1F              ;   R     Q    Op            Sign calc
  23+ 7D1F              ;	10    5    Add           +    sign same add R sign
  24+ 7D1F              ;   -10   5    ABS Sub       -    sign diff ABS R > S sub R sign
  25+ 7D1F              ;   10   -5    ABS sub       +    sign diff ABS R > S sub R sign
  26+ 7D1F              ;	-10  -5    ABS Add       -    sign same add R sign
  27+ 7D1F              ;   5    10    Add           +    sign same add R sign
  28+ 7D1F              ;   -5   10    Swap ABS SUB  +    sign diff ABS Q > R swap SUB Q sign
  29+ 7D1F              ;   5    -10   swap ABS Sub  -    sign diff ABS Q > R swap SUB R sign
  30+ 7D1F              ;   -5   -10   ABS  add      -    sign same add R sign
  31+ 7D1F
  32+ 7D1F              ;   -10   5    ABS Sub       -    sign diff ABS R > S sub R sign
  33+ 7D1F              ;   10   -5    ABS sub       +    sign diff ABS R > S sub R sign
  34+ 7D1F              ;   -5   10    Swap ABS SUB  +    sign diff ABS Q > R swap SUB Q sign
  35+ 7D1F              ;   5    -10   swap ABS Sub  -    sign diff ABS Q > R swap SUB R sign
  36+ 7D1F
  37+ 7D1F
  38+ 7D1F              ; Calculate sign for Q from A and varS
  39+ 7D1F 21 18 6C     	ld		hl,varS							;
  40+ 7D22 AE           	xor		(hl)							;  EOR &83		\ S	\ sign of operator is A xor S
  41+ 7D23 FA 2E 7D     	jp		m,.LL39Subtraction  			; if signs are different then we have subtraction
  42+ 7D26 3A 16 6C     	ld		a,(varQ)						; Q	\ else addition, S already correct
  43+ 7D29 21 17 6C     	ld		hl,varR
  44+ 7D2C 86           	add		a,(hl)							; a = Q + R
  45+ 7D2D C9           	ret										; Done carry set if overflow
  46+ 7D2E              .LL39Subtraction:							; 1 byte subtraction (S)A = R-Q
  47+ 7D2E 3A 17 6C     	ld		a,(varR)						; a = R
  48+ 7D31 21 16 6C     	ld		hl,varQ                         ; Q
  49+ 7D34              ;--	JumpIfALTMemHLusng LL39SwapSubtraction	; if a < (hl) then do LL39SwapSubtraction
  50+ 7D34              	ClearCarryFlag                          ; we need to not use carry (6502 is different that it uses the compliement)
  50+ 7D34 B7          >                        or a
  51+ 7D35 9E           	sbc		a,(hl)							; A = R - Q which as R >= Q will always be a positive result
  52+ 7D36 38 01            jr      c,.LL39SignCorrection
  53+ 7D38              ;--    jr      a,.LL39ResultZero
  54+ 7D38              ;--   JumpIfNegative LL39SignCorrection		; if there was underflow we have to correct sign
  55+ 7D38              ;--	or		a								; Clear carry flag to say result is correct
  56+ 7D38 C9           	ret
  57+ 7D39              .LL39SignCorrection:
  58+ 7D39 FE 00            cp      0                               ; if its 0 then neg will affect flag so we just zero result to save compute
  59+ 7D3B 28 0E            jr      z,.LL39ResultZero
  60+ 7D3D ED 44            neg                                     ; flip A 2'c value to positive
  61+ 7D3F 08           	ex		af,af'							; save A temporarily
  62+ 7D40 3A 18 6C     	ld		a,(varS)						; Flip Sign bit in varS
  63+ 7D43 EE 80        	xor		$80							    ;
  64+ 7D45 32 18 6C     	ld		(varS),a                        ; flip sign bit of a
  65+ 7D48 08           	ex		af,af'                          ; get back a which is the result
  66+ 7D49                  ClearCarryFlag                          ; clear carry as NEG instrunction sets it for non zero
  66+ 7D49 B7          >                        or a
  67+ 7D4A C9           	ret
  68+ 7D4B              .LL39ResultZero:
  69+ 7D4B 32 18 6C         ld      (varS),a                        ; a is zero at this stage so set sign as well
  70+ 7D4E                  ClearCarryFlag                          ; clear carry
  70+ 7D4E B7          >                        or a
  71+ 7D4F C9               ret
  72+ 7D50              ;--LL39SwapSubtraction:
  73+ 7D50              ;--	push	bc
  74+ 7D50              ;--	ld		b,a
  75+ 7D50              ;--	ld		a,(hl)
  76+ 7D50              ;--	sub		b
  77+ 7D50              ;--	pop		bc
  78+ 7D50              ;--	ex		af,af'							; do we flip here or negate. i think its flip as its overflowed unsigned
  79+ 7D50              ;--	ld		a,(varS)
  80+ 7D50              ;--	xor		$80
  81+ 7D50              ;--	ld		(varS),a
  82+ 7D50              ;--	ex		af,af'
  83+ 7D50              ;--	ret
  84+ 7D50
  85+ 7D50              ;;;;	baddll38:				;.LL38	\ -> &4812 \ BADD(S)A=R+Q(SA) \ byte add (subtract)   (Sign S)A = R + Q*(Sign from A^S)
  86+ 7D50              ;;;;; Calculate the following between sign-magnitude numbers:
  87+ 7D50              ;;;;;   (S A) = (S R) + (A Q)
  88+ 7D50              ;;;;; where the sign bytes only contain the sign bits, not magnitudes.
  89+ 7D50              ;;;;; note goes wrong at <-127 >128 so need 16 bit version
  90+ 7D50              ;;;;LL38:
  91+ 7D50              ;;;;; Calculate sign for Q from A and varS
  92+ 7D50              ;;;;	ld		hl,varS							;
  93+ 7D50              ;;;;	xor		(hl)							;  EOR &83		\ S	\ sign of operator is A xor S
  94+ 7D50              ;;;;	jp		m,.LL39Subtraction  			; if signs are different then we have subtraction
  95+ 7D50              ;;;;	ld		a,(varQ)						; Q	\ else addition, S already correct
  96+ 7D50              ;;;;	ld		hl,varR
  97+ 7D50              ;;;;	add		a,(hl)							; a = Q + R
  98+ 7D50              ;;;;	ret										; Done
  99+ 7D50              ;;;;.LL39Subtraction:							; 1 byte subtraction (S)A = R-Q
 100+ 7D50              ;;;;	ld		hl,varQ                         ;
 101+ 7D50              ;;;;	ld		a,(hl)
 102+ 7D50              ;;;;	JumpIfAGTENusng 128,LL39Sub16bit		; does this need to be 16 bit
 103+ 7D50              ;;;;	ld		a,(varR)						;
 104+ 7D50              ;;;;	ClearCarryFlag                          ; we need to not use carry (6502 is different that it uses the compliement)
 105+ 7D50              ;;;;	sbc		a,(hl)							; A = R - Q
 106+ 7D50              ;;;;	jr		c,.SignCorrection				; if there was underflow we have to correct sign
 107+ 7D50              ;;;;	or		a								; Clear carry flag to say result is correct
 108+ 7D50              ;;;;	ret
 109+ 7D50              ;;;;.SignCorrection:
 110+ 7D50              ;;;;    neg                                     ; flip A 2'c value to positive
 111+ 7D50              ;;;;	ex		af,af'							; save A temporarily
 112+ 7D50              ;;;;	ld		a,(varS)						; Flip Sign bit in varS
 113+ 7D50              ;;;;	xor		$80							    ;
 114+ 7D50              ;;;;	ld		(varS),a                        ; flip sign bit of a
 115+ 7D50              ;;;;	ex		af,af'                          ; get back a which is the result
 116+ 7D50              ;;;;	ret
 117+ 7D50              ;;;;LL39Sub16Bit:
 118+ 7D50              ;;;;	ld		e,a
 119+ 7D50              ;;;;	ld		d,0
 120+ 7D50              ;;;;	ld		a,(varR)
 121+ 7D50              ;;;;	ld		l,a
 122+ 7D50              ;;;;	ld		h,0
 123+ 7D50              ;;;;	ClearCarryFlag
 124+ 7D50              ;;;;	sbc		hl,de
 125+ 7D50              ;;;;	jr		c,.SignCorrection16bit
 126+ 7D50              ;;;;	bit		7,h
 127+ 7D50              ;;;;	jr		z,.GoodToReturn
 128+ 7D50              ;;;;.Needtonegate:
 129+ 7D50              ;;;;	macronegate16hl
 130+ 7D50              ;;;;.GoodToReturn
 131+ 7D50              ;;;;	ld		a,l
 132+ 7D50              ;;;;	or		a
 133+ 7D50              ;;;;	ret
 134+ 7D50              ;;;;.SignCorrection16bit:
 135+ 7D50              ;;;;	macronegate16hl
 136+ 7D50              ;;;;	ld		a,(varS)						; Flip Sign bit in varS
 137+ 7D50              ;;;;	xor		$80							    ;
 138+ 7D50              ;;;;	ld		(varS),a                        ; flip sign bit of a
 139+ 7D50              ;;;;	ld		a,l
 140+ 7D50              ;;;;	ret
 141+ 7D50
 142+ 7D50
# file closed: ../../Maths/Utilities/badd_ll38.asm
1362  7D50                  include "../../Universe/Ships/CopyRotMattoXX15.asm"
# file opened: ../../Universe/Ships/CopyRotMattoXX15.asm
   1+ 7D50              CopyRotMatNoseVtoXX15:
   2+ 7D50                      ldCopyByte  UBnkrotmatNosevX+1 ,XX15VecX
   2+ 7D50 3A 37 C0    >                        ld       a,(UBnkrotmatNosevX+1)
   2+ 7D53 32 E7 C0    >                        ld       (XX15VecX),a
   3+ 7D56                      ldCopyByte  UBnkrotmatNosevY+1, XX15VecY
   3+ 7D56 3A 39 C0    >                        ld       a,(UBnkrotmatNosevY+1)
   3+ 7D59 32 E8 C0    >                        ld       (XX15VecY),a
   4+ 7D5C                      ldCopyByte  UBnkrotmatNosevZ+1 ,XX15VecZ
   4+ 7D5C 3A 3B C0    >                        ld       a,(UBnkrotmatNosevZ+1)
   4+ 7D5F 32 E9 C0    >                        ld       (XX15VecZ),a
   5+ 7D62 C9                   ret
   6+ 7D63
   7+ 7D63              CopyRotMatRoofVtoXX15:
   8+ 7D63                      ldCopyByte  UBnkrotmatRoofvX+1 ,XX15VecX
   8+ 7D63 3A 31 C0    >                        ld       a,(UBnkrotmatRoofvX+1)
   8+ 7D66 32 E7 C0    >                        ld       (XX15VecX),a
   9+ 7D69                      ldCopyByte  UBnkrotmatRoofvY+1, XX15VecY
   9+ 7D69 3A 33 C0    >                        ld       a,(UBnkrotmatRoofvY+1)
   9+ 7D6C 32 E8 C0    >                        ld       (XX15VecY),a
  10+ 7D6F                      ldCopyByte  UBnkrotmatRoofvZ+1 ,XX15VecZ
  10+ 7D6F 3A 35 C0    >                        ld       a,(UBnkrotmatRoofvZ+1)
  10+ 7D72 32 E9 C0    >                        ld       (XX15VecZ),a
  11+ 7D75 C9                   ret
  12+ 7D76
  13+ 7D76              CopyRotMatSideVtoXX15:
  14+ 7D76                      ldCopyByte  UBnkrotmatSidevX+1 ,XX15VecX
  14+ 7D76 3A 2B C0    >                        ld       a,(UBnkrotmatSidevX+1)
  14+ 7D79 32 E7 C0    >                        ld       (XX15VecX),a
  15+ 7D7C                      ldCopyByte  UBnkrotmatSidevY+1, XX15VecY
  15+ 7D7C 3A 2D C0    >                        ld       a,(UBnkrotmatSidevY+1)
  15+ 7D7F 32 E8 C0    >                        ld       (XX15VecY),a
  16+ 7D82                      ldCopyByte  UBnkrotmatSidevZ+1 ,XX15VecZ
  16+ 7D82 3A 2F C0    >                        ld       a,(UBnkrotmatSidevZ+1)
  16+ 7D85 32 E9 C0    >                        ld       (XX15VecZ),a
  17+ 7D88 C9                   ret
  18+ 7D89
# file closed: ../../Universe/Ships/CopyRotMattoXX15.asm
1363  7D89                  include "../../Universe/Ships/CopyXX15toRotMat.asm"
# file opened: ../../Universe/Ships/CopyXX15toRotMat.asm
   1+ 7D89              CopyXX15toRotMatNoseV:
   2+ 7D89                      ldCopyByte  XX15VecX, UBnkrotmatNosevX+1
   2+ 7D89 3A E7 C0    >                        ld       a,(XX15VecX)
   2+ 7D8C 32 37 C0    >                        ld       (UBnkrotmatNosevX+1),a
   3+ 7D8F                      ldCopyByte  XX15VecY, UBnkrotmatNosevY+1
   3+ 7D8F 3A E8 C0    >                        ld       a,(XX15VecY)
   3+ 7D92 32 39 C0    >                        ld       (UBnkrotmatNosevY+1),a
   4+ 7D95                      ldCopyByte  XX15VecZ, UBnkrotmatNosevZ+1
   4+ 7D95 3A E9 C0    >                        ld       a,(XX15VecZ)
   4+ 7D98 32 3B C0    >                        ld       (UBnkrotmatNosevZ+1),a
   5+ 7D9B                      ZeroA
   5+ 7D9B AF          >                        xor a
   6+ 7D9C 32 36 C0             ld  (UBnkrotmatNosevX),a
   7+ 7D9F 32 38 C0             ld  (UBnkrotmatNosevY),a
   8+ 7DA2 32 3A C0             ld  (UBnkrotmatNosevZ),a
   9+ 7DA5 C9                   ret
  10+ 7DA6
  11+ 7DA6              CopyXX15toRotMatRoofV:
  12+ 7DA6                      ldCopyByte  XX15VecX, UBnkrotmatRoofvX+1
  12+ 7DA6 3A E7 C0    >                        ld       a,(XX15VecX)
  12+ 7DA9 32 31 C0    >                        ld       (UBnkrotmatRoofvX+1),a
  13+ 7DAC                      ldCopyByte  XX15VecY, UBnkrotmatRoofvY+1
  13+ 7DAC 3A E8 C0    >                        ld       a,(XX15VecY)
  13+ 7DAF 32 33 C0    >                        ld       (UBnkrotmatRoofvY+1),a
  14+ 7DB2                      ldCopyByte  XX15VecZ, UBnkrotmatRoofvZ+1
  14+ 7DB2 3A E9 C0    >                        ld       a,(XX15VecZ)
  14+ 7DB5 32 35 C0    >                        ld       (UBnkrotmatRoofvZ+1),a
  15+ 7DB8                      ZeroA
  15+ 7DB8 AF          >                        xor a
  16+ 7DB9 32 30 C0             ld  (UBnkrotmatRoofvX),a
  17+ 7DBC 32 32 C0             ld  (UBnkrotmatRoofvY),a
  18+ 7DBF 32 34 C0             ld  (UBnkrotmatRoofvZ),a
  19+ 7DC2 C9                   ret
  20+ 7DC3
  21+ 7DC3              CopyXX15toRotMatSideV:
  22+ 7DC3                      ldCopyByte  XX15VecX, UBnkrotmatSidevX+1
  22+ 7DC3 3A E7 C0    >                        ld       a,(XX15VecX)
  22+ 7DC6 32 2B C0    >                        ld       (UBnkrotmatSidevX+1),a
  23+ 7DC9                      ldCopyByte  XX15VecY, UBnkrotmatSidevY+1
  23+ 7DC9 3A E8 C0    >                        ld       a,(XX15VecY)
  23+ 7DCC 32 2D C0    >                        ld       (UBnkrotmatSidevY+1),a
  24+ 7DCF                      ldCopyByte  XX15VecZ, UBnkrotmatSidevZ+1
  24+ 7DCF 3A E9 C0    >                        ld       a,(XX15VecZ)
  24+ 7DD2 32 2F C0    >                        ld       (UBnkrotmatSidevZ+1),a
  25+ 7DD5                      ZeroA
  25+ 7DD5 AF          >                        xor a
  26+ 7DD6 32 2A C0             ld  (UBnkrotmatSidevX),a
  27+ 7DD9 32 2C C0             ld  (UBnkrotmatSidevY),a
  28+ 7DDC 32 2E C0             ld  (UBnkrotmatSidevZ),a
  29+ 7DDF C9                   ret
  30+ 7DE0
# file closed: ../../Universe/Ships/CopyXX15toRotMat.asm
1364  7DE0                  INCLUDE "../../Maths/asm_tidy.asm"
# file opened: ../../Maths/asm_tidy.asm
   1+ 7DE0              ; d = vector 1 e = vector 2 h = vector3 l = vector 4 b = vector 5
   2+ 7DE0              ; performs (d*e + h*l) / b and puts the result in de where e is 0
   3+ 7DE0 C5           TidyCalc:       push    bc
   4+ 7DE1 CD AF 70                     call    mulDbyESigned           ; de = vector 1 * vector 2
   5+ 7DE4 EB                           ex      hl,de                   ; get hl into de and save result of de
   6+ 7DE5 CD AF 70                     call    mulDbyESigned           ; de = vector 2 * vector 3
   7+ 7DE8 CD 04 00                     call    AddDEtoHLSigned         ; BC = HL = HL + DE
   8+ 7DEB D1                           pop     de                      ; DE = BC saved from earlier
   9+ 7DEC 7C                           ld      a,h                     ; check for result 0
  10+ 7DED B5                           or      l                       ; .
  11+ 7DEE CA 0F 7E                     jp      z,.ZeroResult           ; .
  12+ 7DF1 44 4D                        ld      bc,hl                   ; .
  13+ 7DF3 7A                           ld      a,d                     ; check for divide by zero
  14+ 7DF4 A7                           and     a                       ; .
  15+ 7DF5 CA 06 7E                     jp      z,.MaxedResult          ; .
  16+ 7DF8 5A                           ld      e,d                     ; now de = 0b (i.e. b register not hex value)
  17+ 7DF9 16 00                        ld      d,0                     ;
  18+ 7DFB CD C2 77                     call    Floor_DivQSigned        ; TO BE TESTED should do BC = BC / DE
  19+ 7DFE 78                           ld      a,b                     ; sign bit from b
  20+ 7DFF E6 80                        and     $80                     ; .
  21+ 7E01 B1                           or      c                       ; bring in the value
  22+ 7E02 57                           ld      d,a                     ; de = c0 (i.e. c register not hex value)
  23+ 7E03 1E 00                        ld      e,0                     ; .
  24+ 7E05 C9                           ret
  25+ 7E06 78           .MaxedResult:   ld      a,b                     ; make result signed unity (i.e. 1 or 96 in our case)
  26+ 7E07 EE 80                        xor     $80
  27+ 7E09 F6 60                        or      $60
  28+ 7E0B 57                           ld      d,a
  29+ 7E0C 1E 00                        ld      e,0
  30+ 7E0E C9                           ret
  31+ 7E0F 11 00 00     .ZeroResult:    ld      de,0
  32+ 7E12 C9                           ret
  33+ 7E13              ; as per tidy calc except
  34+ 7E13              ; d = vector 1 e = vector 2 h = vector3 l = vector 4
  35+ 7E13              ; performs (d*e - h*l) / 96 and puts the result in de where e is 0
  36+ 7E13
  37+ 7E13 CD AF 70     TidySide:       call    mulDbyESigned           ; de = vector 1 * vector 2
  38+ 7E16 EB                           ex      de,hl                   ; get hl = vector 1 * vector 2
  39+ 7E17 CD AF 70                     call    mulDbyESigned           ; de = vector 2 * vector 3
  40+ 7E1A CD 00 00                     call    SubDEfromHLSigned       ; BC = HL = HL - DE
  41+ 7E1D 44 4D                        ld      bc,hl                   ; .
  42+ 7E1F 11 60 00                     ld      de,$60                  ; now de = 96
  43+ 7E22 CD C2 77                     call    Floor_DivQSigned        ; TO BE TESTED should do BC = BC / DE
  44+ 7E25 78                           ld      a,b                     ; sign bit from b
  45+ 7E26 E6 80                        and     $80                     ; .
  46+ 7E28 B1                           or      c                       ; bring in the value
  47+ 7E29 57                           ld      d,a                     ; de = c0 (i.e. c register not hex value)
  48+ 7E2A 1E 00                        ld      e,0                     ; .
  49+ 7E2C C9                           ret
  50+ 7E2D
  51+ 7E2D              ;; orthonormalise vector for UBnK ship vector uses IX IT
  52+ 7E2D                  DISPLAY "TidyVectorsIX"
  53+ 7E2D DD 21 36 C0  TidyVectorsIX:  ld      ix,UBnkrotmatNosevX
  54+ 7E31 CD 57 7A                     call    NormaliseIXVector       ; initially we normalise the nose vector
  55+ 7E34 3A 37 C0     .CheckNoseXSize:ld      a,(UBnkrotmatNosevX+1)  ; a = nose x
  56+ 7E37 E6 30                        and     %00110000                ; if bits 7 and 6 are clear the work with nosey
  57+ 7E39 CA 6D 7E                     jp      z, .NoseXSmall
  58+ 7E3C              ;-- When nosex is large ------------------------  roofv_x =-(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
  59+ 7E3C 3A 39 C0     .NoseXLarge:    ld      a,(UBnkrotmatNosevY+1)  ; a = nose x
  60+ 7E3F 57                           ld      d,a
  61+ 7E40 3A 33 C0                     ld      a,(UBnkrotmatRoofvY+1)  ; hl = nosev_y * roofv_y
  62+ 7E43 5F                           ld      e,a                     ; we already have d so only need roofY
  63+ 7E44 3A 3B C0                     ld      a,(UBnkrotmatNosevZ+1)  ; de = nosev_z * roofv_z
  64+ 7E47 67                           ld      h,a                     ; .
  65+ 7E48 3A 35 C0                     ld      a,(UBnkrotmatRoofvZ+1)  ; .
  66+ 7E4B 6F                           ld      l,a                     ; .
  67+ 7E4C 3A 37 C0                     ld      a,(UBnkrotmatNosevX+1)
  68+ 7E4F 47                           ld      b,a
  69+ 7E50 CD E0 7D                     call    TidyCalc
  70+ 7E53 7A                           ld      a,d
  71+ 7E54 B3                           or      e
  72+ 7E55 CA 5C 7E                     jp      z,.NoRoofXFlip
  73+ 7E58 3E 80                        ld      a,$80                   ; flip sign bit if not zero
  74+ 7E5A AA                           xor     d
  75+ 7E5B 57                           ld      d,a
  76+ 7E5C ED 53 30 C0  .NoRoofXFlip:   ld      (UBnkrotmatRoofvX),de   ; write roofvx
  77+ 7E60 C3 C8 7E                     jp      .NormaliseRoofv
  78+ 7E63 11 00 E0     .MaxedRoofX:    ld      de,$E000                ; TEST if sign is correct for all of these if was divide by zero make it -1
  79+ 7E66 ED 53 30 C0                  ld      (UBnkrotmatRoofvX),de   ; write roofvx
  80+ 7E6A C3 C8 7E                     jp      .NormaliseRoofv
  81+ 7E6D              ;-- When noseX is small ------------------------ determine if we are doign roofz or roof y
  82+ 7E6D 3A 38 C0     .NoseXSmall:    ld      a,(UBnkrotmatNosevY)
  83+ 7E70 E6 60                        and     %01100000
  84+ 7E72 CA A0 7E                     jp      z,.NoseYSmall
  85+ 7E75              ;-- When noseY is large ------------------------ roofv_z = -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
  86+ 7E75 3A 37 C0     .NoseYLarge:    ld      a,(UBnkrotmatNosevX+1)
  87+ 7E78 57                           ld      d,a
  88+ 7E79 3A 31 C0                     ld      a,(UBnkrotmatRoofvX+1)
  89+ 7E7C 5F                           ld      e,a
  90+ 7E7D 3A 39 C0                     ld      a,(UBnkrotmatNosevY+1)
  91+ 7E80 67                           ld      h,a
  92+ 7E81 3A 33 C0                     ld      a,(UBnkrotmatRoofvY+1)
  93+ 7E84 6F                           ld      l,a
  94+ 7E85 3A 3B C0                     ld      a,(UBnkrotmatNosevZ+1)
  95+ 7E88 47                           ld      b,a
  96+ 7E89 CD E0 7D                     call    TidyCalc
  97+ 7E8C 7A                           ld      a,d
  98+ 7E8D B3                           or      e
  99+ 7E8E CA 99 7E                     jp      z,.NoRoofZFlip
 100+ 7E91 3E 80                        ld      a,$80                   ; flip sign bit if not zero
 101+ 7E93 AA                           xor     d
 102+ 7E94 57                           ld      d,a
 103+ 7E95 3E 80                        ld      a,$80                   ; flip sign bit
 104+ 7E97 AA                           xor     d
 105+ 7E98 57                           ld      d,a
 106+ 7E99 ED 53 34 C0  .NoRoofZFlip:   ld      (UBnkrotmatRoofvZ),de   ; write roofvz
 107+ 7E9D C3 C8 7E                     jp      .NormaliseRoofv
 108+ 7EA0              ;-- When noseY is large ------------------------ roofv_y = -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
 109+ 7EA0 3A 37 C0     .NoseYSmall:    ld      a,(UBnkrotmatNosevX+1)
 110+ 7EA3 57                           ld      d,a
 111+ 7EA4 3A 31 C0                     ld      a,(UBnkrotmatRoofvX+1)
 112+ 7EA7 5F                           ld      e,a
 113+ 7EA8 3A 3B C0                     ld      a,(UBnkrotmatNosevZ+1)
 114+ 7EAB 67                           ld      h,a
 115+ 7EAC 3A 35 C0                     ld      a,(UBnkrotmatRoofvZ+1)
 116+ 7EAF 6F                           ld      l,a
 117+ 7EB0 3A 39 C0                     ld      a,(UBnkrotmatNosevY+1)
 118+ 7EB3 47                           ld      b,a
 119+ 7EB4 CD E0 7D                     call    TidyCalc
 120+ 7EB7 7A                           ld      a,d
 121+ 7EB8 B3                           or      e
 122+ 7EB9 CA C4 7E                     jp      z,.NoRoofYFlip
 123+ 7EBC 3E 80                        ld      a,$80                   ; flip sign bit if not zero
 124+ 7EBE AA                           xor     d
 125+ 7EBF 57                           ld      d,a
 126+ 7EC0 3E 80                        ld      a,$80                   ; flip sign bit
 127+ 7EC2 AA                           xor     d
 128+ 7EC3 57                           ld      d,a
 129+ 7EC4 ED 53 32 C0  .NoRoofYFlip:   ld      (UBnkrotmatRoofvY),de   ; write roofvy
 130+ 7EC8 DD 21 30 C0  .NormaliseRoofv:ld      ix,UBnkrotmatRoofvX     ; now normalise roofv
 131+ 7ECC CD 57 7A                     call    NormaliseIXVector
 132+ 7ECF              ; -- sidev_x = (nosev_z * roofv_y - nosev_y * roofv_z) / 96
 133+ 7ECF 3A 3B C0     .CalcSidevX:    ld      a,(UBnkrotmatNosevZ+1)
 134+ 7ED2 57                           ld      d,a
 135+ 7ED3 3A 33 C0                     ld      a,(UBnkrotmatRoofvY+1)
 136+ 7ED6 5F                           ld      e,a
 137+ 7ED7 3A 39 C0                     ld      a,(UBnkrotmatNosevY+1)
 138+ 7EDA 67                           ld      h,a
 139+ 7EDB 3A 35 C0                     ld      a,(UBnkrotmatRoofvZ+1)
 140+ 7EDE 6F                           ld      l,a
 141+ 7EDF CD 13 7E                     call    TidySide
 142+ 7EE2 ED 53 2A C0                  ld      (UBnkrotmatSidevX),de   ; write sidevX
 143+ 7EE6              ; -- sidev_y = (nosev_x * roofv_z - nosev_z * roofv_x) / 96
 144+ 7EE6 3A 37 C0     .CalcSidevY:    ld      a,(UBnkrotmatNosevX+1)
 145+ 7EE9 57                           ld      d,a
 146+ 7EEA 3A 35 C0                     ld      a,(UBnkrotmatRoofvZ+1)
 147+ 7EED 5F                           ld      e,a
 148+ 7EEE 3A 3B C0                     ld      a,(UBnkrotmatNosevZ+1)
 149+ 7EF1 67                           ld      h,a
 150+ 7EF2 3A 31 C0                     ld      a,(UBnkrotmatRoofvX+1)
 151+ 7EF5 6F                           ld      l,a
 152+ 7EF6 CD 13 7E                     call    TidySide
 153+ 7EF9 ED 53 2C C0                  ld      (UBnkrotmatSidevY),de   ; write sidevX
 154+ 7EFD              ; -- sidev_z = (nosev_y * roofv_x - nosev_x * roofv_y) / 96
 155+ 7EFD 3A 39 C0     .CalcSidevZ:    ld      a,(UBnkrotmatNosevY+1)
 156+ 7F00 57                           ld      d,a
 157+ 7F01 3A 31 C0                     ld      a,(UBnkrotmatRoofvX+1)
 158+ 7F04 5F                           ld      e,a
 159+ 7F05 3A 37 C0                     ld      a,(UBnkrotmatNosevX+1)
 160+ 7F08 67                           ld      h,a
 161+ 7F09 3A 33 C0                     ld      a,(UBnkrotmatRoofvY+1)
 162+ 7F0C 6F                           ld      l,a
 163+ 7F0D CD 13 7E                     call    TidySide
 164+ 7F10 ED 53 2E C0                  ld      (UBnkrotmatSidevZ),de   ; write sidevX
 165+ 7F14                          IFDEF ROUND_ROLL_AND_PITCH
 166+ 7F14 ~            .ClearLowBytes: ld      hl,UBnkrotmatSidevX
 167+ 7F14 ~                            ZeroA
 168+ 7F14 ~                            ld      b,9
 169+ 7F14 ~            .WriteLoop:     ld      (hl),a
 170+ 7F14 ~                            inc     hl
 171+ 7F14 ~                            inc     hl
 172+ 7F14 ~                            djnz    .WriteLoop
 173+ 7F14                          ENDIF
 174+ 7F14 C9                           ret
 175+ 7F15
# file closed: ../../Maths/asm_tidy.asm
1365  7F15                  INCLUDE "../../Menus/common_menu.asm"
# file opened: ../../Menus/common_menu.asm
   1+ 7F15 43 4F 4D 4D  txt_commander 			DB "COMMANDER",0
   1+ 7F19 41 4E 44 45
   1+ 7F1D 52 00
   2+ 7F1F 49 4E 56 45  txt_inventory 			DB "INVENTORY",0
   2+ 7F23 4E 54 4F 52
   2+ 7F27 59 00
   3+ 7F29 50 72 65 73  txt_present_system		DB "Present System   :",0
   3+ 7F2D 65 6E 74 20
   3+ 7F31 53 79 73 74
   3+ 7F35 65 6D 20 20
   3+ 7F39 20 3A 00
   4+ 7F3C 48 79 70 65  txt_hyperspace_system	DB "Hyperspace System:",0
   4+ 7F40 72 73 70 61
   4+ 7F44 63 65 20 53
   4+ 7F48 79 73 74 65
   4+ 7F4C 6D 3A 00
   5+ 7F4F 43 6F 6E 64  txt_condition			DB "Condition   :",0
   5+ 7F53 69 74 69 6F
   5+ 7F57 6E 20 20 20
   5+ 7F5B 3A 00
   6+ 7F5D 46 75 65 6C  txt_fuel				DB "Fuel        :",0
   6+ 7F61 20 20 20 20
   6+ 7F65 20 20 20 20
   6+ 7F69 3A 00
   7+ 7F6B 43 61 73 68  txt_cash				DB "Cash        :",0
   7+ 7F6F 20 20 20 20
   7+ 7F73 20 20 20 20
   7+ 7F77 3A 00
   8+ 7F79 4C 65 67 61  txt_legal_status		DB "Legal Status:",0
   8+ 7F7D 6C 20 53 74
   8+ 7F81 61 74 75 73
   8+ 7F85 3A 00
   9+ 7F87 52 61 74 69  txt_rating				DB "Rating      :",0
   9+ 7F8B 6E 67 20 20
   9+ 7F8F 20 20 20 20
   9+ 7F93 3A 00
  10+ 7F95 45 51 55 49  txt_equipment			DB "EQUIPMENT:",0
  10+ 7F99 50 4D 45 4E
  10+ 7F9D 54 3A 00
  11+ 7FA0
  12+ 7FA0 30 30 2E 30  txt_fuel_level			DB "00.0 Light Years",0
  12+ 7FA4 20 4C 69 67
  12+ 7FA8 68 74 20 59
  12+ 7FAC 65 61 72 73
  12+ 7FB0 00
  13+ 7FB1 58 58 58 58  txt_cash_amount			DB "XXXXXXXXXX",0
  13+ 7FB5 58 58 58 58
  13+ 7FB9 58 58 00
  14+ 7FBC 2E           txt_cash_decimal        DB "."
  15+ 7FBD 58 20 43 72  txt_cash_fraction       DB "X Cr",0
  15+ 7FC1 00
  16+ 7FC2
  17+ 7FC2              txt_status_colour		equ $FF
  18+ 7FC2
  19+ 7FC2              ;;DEFUNCTprint_boiler_text_l2:
  20+ 7FC2              ;;DEFUNCT; ">print_boilder_text hl = text structure, b = message count"
  21+ 7FC2              ;;DEFUNCTBoilerTextLoop:
  22+ 7FC2              ;;DEFUNCT	push		bc			; Save Message Count loop value
  23+ 7FC2              ;;DEFUNCT	ld			c,(hl)		; Get Row into b
  24+ 7FC2              ;;DEFUNCT	inc			hl
  25+ 7FC2              ;;DEFUNCT	ld			b,(hl)		; Get Col into b
  26+ 7FC2              ;;DEFUNCT	inc			hl
  27+ 7FC2              ;;DEFUNCT	ld			e,(hl)		; Get text address Lo into E
  28+ 7FC2              ;;DEFUNCT	inc			hl
  29+ 7FC2              ;;DEFUNCT	ld			d,(hl)		; Get text address Hi into E
  30+ 7FC2              ;;DEFUNCT	inc			hl
  31+ 7FC2              ;;DEFUNCT	push		hl			; Save present HL to stack as this is the address for the next message
  32+ 7FC2              ;;DEFUNCT	ex			de,hl		; now hl = address of text data
  33+ 7FC2              ;;DEFUNCT	ld			e,txt_status_colour
  34+ 7FC2              ;;DEFUNCT    MMUSelectLayer2
  35+ 7FC2              ;;DEFUNCT	call		l1_print_at
  36+ 7FC2              ;;DEFUNCT	pop			hl
  37+ 7FC2              ;;DEFUNCT	pop			bc
  38+ 7FC2              ;;DEFUNCT	djnz		BoilerTextLoop
  39+ 7FC2              ;;DEFUNCT	ret
  40+ 7FC2
  41+ 7FC2
  42+ 7FC2              ;:DEFUNCT print_boiler_text:
  43+ 7FC2              ;:DEFUNCT ; ">print_boilder_text hl = text structure, b = message count"
  44+ 7FC2              ;:DEFUNCT .BoilerTextLoop:
  45+ 7FC2              ;:DEFUNCT 	push		bc			; Save Message Count loop value
  46+ 7FC2              ;:DEFUNCT 	ld			c,(hl)		; Get Row into b
  47+ 7FC2              ;:DEFUNCT 	inc			hl
  48+ 7FC2              ;:DEFUNCT 	ld			b,(hl)		; Get Col into b
  49+ 7FC2              ;:DEFUNCT 	inc			hl
  50+ 7FC2              ;:DEFUNCT 	ld			e,(hl)		; Get text address Lo into E
  51+ 7FC2              ;:DEFUNCT 	inc			hl
  52+ 7FC2              ;:DEFUNCT 	ld			d,(hl)		; Get text address Hi into E
  53+ 7FC2              ;:DEFUNCT 	inc			hl
  54+ 7FC2              ;:DEFUNCT 	push		hl			; Save present HL to stack as this is the address for the next message
  55+ 7FC2              ;:DEFUNCT 	ex			de,hl		; now hl = address of text data
  56+ 7FC2              ;:DEFUNCT 	ld			e,txt_status_colour
  57+ 7FC2              ;:DEFUNCT 	push		bc
  58+ 7FC2              ;:DEFUNCT 	pop			de
  59+ 7FC2              ;:DEFUNCT 	call		l1_print_at
  60+ 7FC2              ;:DEFUNCT 	pop			hl
  61+ 7FC2              ;:DEFUNCT 	pop			bc
  62+ 7FC2              ;:DEFUNCT 	djnz		.BoilerTextLoop
  63+ 7FC2              ;:DEFUNCT 	ret
  64+ 7FC2
  65+ 7FC2              ;;DEFUNCTGetFuelLevel:           INCLUDE "Menus/get_fuel_level_inlineinclude.asm"
  66+ 7FC2
  67+ 7FC2              ;;DEFUNCTGetCash:                ld      hl,(Cash)
  68+ 7FC2              ;;DEFUNCT                        ex      de,hl
  69+ 7FC2              ;;DEFUNCT                        ld      ix,(Cash+2)
  70+ 7FC2              ;;DEFUNCT                        ld		iy,txt_cash_amount
  71+ 7FC2              ;;DEFUNCT                        call 	DispDEIXtoIY	; This will write out with 0 termination after last digit
  72+ 7FC2              ;;DEFUNCT.ShiftDecimalDigit:     ld		a,(IY+0)				;Push last digit to post decimal
  73+ 7FC2              ;;DEFUNCT                        ld		(txt_cash_fraction),a
  74+ 7FC2              ;;DEFUNCT.UpdateInteger:         ld		hl,txt_cash_amount+1	; Now was there only 1 digit
  75+ 7FC2              ;;DEFUNCT                        ld		a,(hl)					; if so we leave it alone so its "0.0"
  76+ 7FC2              ;;DEFUNCT                        cp		0
  77+ 7FC2              ;;DEFUNCT                        ret		z
  78+ 7FC2              ;;DEFUNCT                        ld		(IY),0					; Else we erase last digit as it went to fraction
  79+ 7FC2              ;;DEFUNCT                        ret
  80+ 7FC2
# file closed: ../../Menus/common_menu.asm
1366  7FC2              MainNonBankedCodeEnd:
1367  7FC2                  DISPLAY "Main Non Banked Code Ends at ",$
1368  7FC2
1369  7FC2              ; Bank 58  ------------------------------------------------------------------------------------------------------------------------
1370  7FC2                  SLOT    LAYER1Addr
1371  7FC2                  PAGE    BankLAYER1
1372  7FC2                  ORG     LAYER1Addr, BankLAYER1
1373  E000 42 61 6E 6B  Layer1Header:  DB "Bank L1 Utils--"
1373  E004 20 4C 31 20
1373  E008 55 74 69 6C
1373  E00C 73 2D 2D
1374  E00F
1375  E00F                  INCLUDE "../../Layer1Graphics/layer1_attr_utils.asm"
# file opened: ../../Layer1Graphics/layer1_attr_utils.asm
   1+ E00F
   2+ E00F 00 58        L1AttrRow00:            DW $5800                    ;Row 1    */
   3+ E011 20 58        L1AttrRow01:            DW $5820                    ;Row 2    */
   4+ E013 40 58        L1AttrRow02:            DW $5840                    ;Row 3    */
   5+ E015 60 58        L1AttrRow03:            DW $5860                    ;Row 4    */
   6+ E017 80 58        L1AttrRow04:            DW $5880                    ;Row 5    */
   7+ E019 A0 58        L1AttrRow05:            DW $58A0                    ;Row 6    */
   8+ E01B C0 58        L1AttrRow06:            DW $58C0                    ;Row 7    */
   9+ E01D E0 58        L1AttrRow07:            DW $58E0                    ;Row 8    */
  10+ E01F 00 59        L1AttrRow08:            DW $5900                    ;Row 9    */
  11+ E021 20 59        L1AttrRow09:            DW $5920                    ;Row 10   */
  12+ E023 40 59        L1AttrRow10:            DW $5940                    ;Row 11   */
  13+ E025 60 59        L1AttrRow11:            DW $5960                    ;Row 12   */
  14+ E027 80 59        L1AttrRow12:            DW $5980                    ;Row 13   */
  15+ E029 A0 59        L1AttrRow13:            DW $59A0                    ;Row 14   */
  16+ E02B C0 59        L1AttrRow14:            DW $59C0                    ;Row 15   */
  17+ E02D E0 59        L1AttrRow15:            DW $59E0                    ;Row 16   */
  18+ E02F 00 5A        L1AttrRow16:            DW $5A00                    ;Row 17   */
  19+ E031 20 5A        L1AttrRow17:            DW $5A20                    ;Row 18   */
  20+ E033 40 5A        L1AttrRow18:            DW $5A40                    ;Row 19   */
  21+ E035 60 5A        L1AttrRow19:            DW $5A60                    ;Row 20   */
  22+ E037 80 5A        L1AttrRow20:            DW $5A80                    ;Row 21   */
  23+ E039 A0 5A        L1AttrRow21:            DW $5AA0                    ;Row 22   */
  24+ E03B C0 5A        L1AttrRow22:            DW $5AC0                    ;Row 23   */
  25+ E03D E0 5A        L1AttrRow23:            DW $5AE0                    ;Row 23   */
  26+ E03F
  27+ E03F              ; "l2_hilight_row, d = row, e = colour"
  28+ E03F 21 0F E0     l1_hilight_row:         ld      hl, L1AttrRow00
  29+ E042 4B                                   ld      c,e
  30+ E043 7A                                   ld      a,d
  31+ E044 CB 27                                sla     a
  32+ E046 ED 31                                add     hl,a
  33+ E048 7E                                   ld      a,(hl)
  34+ E049 5F                                   ld      e,a
  35+ E04A 23                                   inc     hl
  36+ E04B 7E                                   ld      a,(hl)
  37+ E04C 57                                   ld      d,a
  38+ E04D EB                                   ex      hl,de
  39+ E04E 79                                   ld		a,c
  40+ E04F 11 20 00                             ld		de, 32
  41+ E052 CD 92 6A                             call	memfill_dma
  42+ E055 C9                                   ret
  43+ E056
# file closed: ../../Layer1Graphics/layer1_attr_utils.asm
1376  E056                  INCLUDE "../../Layer1Graphics/layer1_cls.asm"
# file opened: ../../Layer1Graphics/layer1_cls.asm
   1+ E056 AF           l1_cls_top:             xor     a
   2+ E057 21 00 40                             ld      hl, $4000
   3+ E05A 11 00 08                             ld      de, $0800
   4+ E05D CD 92 6A                             call    memfill_dma
   5+ E060 C9                                   ret
   6+ E061
   7+ E061 AF           l1_cls_mid:             xor     a
   8+ E062 21 00 48                             ld      hl, $4800
   9+ E065 11 00 08                             ld      de, $0800
  10+ E068 CD 92 6A                             call    memfill_dma
  11+ E06B C9                                   ret
  12+ E06C
  13+ E06C AF           l1_cls_bottom:          xor     a
  14+ E06D 21 00 50                             ld      hl, $5000
  15+ E070 11 00 08                             ld      de, $0800
  16+ E073 CD 92 6A                             call    memfill_dma
  17+ E076 C9                                   ret
  18+ E077
  19+ E077              ; Designed specifically to clear a whole character aligned line
  20+ E077 1E 00        l1_cls_line_d:          ld      e,0
  21+ E079 ED 94                                pixelad
  22+ E07B 11 00 01                             ld      de,32 * 8
  23+ E07E AF                                   xor     a
  24+ E07F CD 92 6A                             call    memfill_dma
  25+ E082 C9                                   ret
  26+ E083
  27+ E083              ; Designed specifically to clear a whole character aligned 2 lines line, used for say clearing hyperspace message
  28+ E083 1E 00        l1_cls_2_lines_d:       ld      e,0
  29+ E085 ED 94                                pixelad
  30+ E087 11 00 02                             ld      de,32 * 16
  31+ E08A AF                                   xor     a
  32+ E08B CD 92 6A                             call    memfill_dma
  33+ E08E C9                                   ret
  34+ E08F
  35+ E08F AF           l1_cls:                 xor		a
  36+ E090 21 00 40     l1_cls_to_a:            ld		hl,	$4000
  37+ E093 11 00 18                             ld		de, $1800
  38+ E096 CD 92 6A                             call	memfill_dma
  39+ E099 C9                                   ret
  40+ E09A
  41+ E09A 21 00 58     l1_attr_cls_2DlinesA:   ld		hl,	$5800
  42+ E09D 1E 20                                ld      e,32
  43+ E09F ED 30                                mul
  44+ E0A1 19                                   add     hl,de
  45+ E0A2 11 40 00                             ld		de, 32 * 2
  46+ E0A5 CD 92 6A                             call	memfill_dma
  47+ E0A8 C9                                   ret
  48+ E0A9
  49+ E0A9
  50+ E0A9 AF           l1_attr_cls:            xor		a
  51+ E0AA 21 00 58     l1_attr_cls_to_a:       ld		hl,	$5800
  52+ E0AD 11 00 03                             ld		de, $0300
  53+ E0B0 CD 92 6A                             call	memfill_dma
  54+ E0B3 C9                                   ret
  55+ E0B4
  56+ E0B4 01 FE FE     l1_set_border:          ld	    bc, 0xFEFE
  57+ E0B7 ED 79                                out		(c),a
  58+ E0B9 C9                                   ret
# file closed: ../../Layer1Graphics/layer1_cls.asm
1377  E0BA                  INCLUDE "../../Layer1Graphics/layer1_print_at.asm"
# file opened: ../../Layer1Graphics/layer1_print_at.asm
   1+ E0BA              ; "l1 print char a = character, de = Ypixel Xpxiel rounded to char of print"
   2+ E0BA D5 E5        l1_print_char:          push	de,,hl
   3+ E0BC ED 94                                pixelad								; hl = address of de
   4+ E0BE E5                                   push	hl							; save hl for loop
   5+ E0BF 26 00                                ld		h,0
   6+ E0C1 6F                                   ld		l,a
   7+ E0C2 29                                   add		hl,hl						; * 2
   8+ E0C3 29                                   add		hl,hl						; * 4
   9+ E0C4 29                                   add		hl,hl						; * 8 to get byte address
  10+ E0C5 ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
  11+ E0C9 EB                                   ex		de,hl						; save address into de
  12+ E0CA E1                                   pop		hl							; get back hl for loop
  13+ E0CB 06 08                                ld		b,8							; do 8 rows
  14+ E0CD 1A           .PrintCharLoop:         ld		a,(de)						; row byte
  15+ E0CE 13                                   inc		de							; next byte
  16+ E0CF 77                                   ld		(hl),a						; poke to screen
  17+ E0D0 ED 93                                pixeldn								; Down 1 row
  18+ E0D2 10 F9                                djnz	.PrintCharLoop				; loop for 8 bytes
  19+ E0D4 E1 D1                                pop		de,,hl					    ; restore hl
  20+ E0D6 C9                                   ret
  21+ E0D7
  22+ E0D7              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
  23+ E0D7              ; now skips ascii code < 32 but moves on cursor by 1 char
  24+ E0D7              l1_print_at_char
  24+ E0D7 CB 22           sla     d       ; Convert D from char to pixel
  25+ E0D9 CB 22                                sla     d       ; by muliplying by 8
  26+ E0DB CB 22                                sla     d       ;
  27+ E0DD CB 23                                sla     e       ; Convert E from char to pixel
  28+ E0DF CB 23                                sla     e
  29+ E0E1 CB 23                                sla     e
  30+ E0E3              l1_print_at:
  31+ E0E3 7E           .PrintLoop:             ld		a,(hl)
  32+ E0E4 FE 00                                cp		0
  33+ E0E6 C8                                   ret		z
  34+ E0E7                                      CallIfAGTENusng " ", l1_print_char
  34+ E0E7 FE 20       >                        cp      " "
  34+ E0E9 D4 BA E0    >                        call	nc,l1_print_char
  35+ E0EC 23                                   inc		hl							; move 1 message character right
  36+ E0ED 7B                                   ld		a,e
  37+ E0EE C6 08                                add		a,8
  38+ E0F0 5F                                   ld		e,a							; move 1 screen character right
  39+ E0F1 18 F0                                jr		.PrintLoop
  40+ E0F3                                                      DISPLAY "TODO: looks liek rogue popde"
  41+ E0F3              .Clearstackandfinish:   ;pop		de                      ; TODO LOOOKS TO BE A ROGUE POPDE
  42+ E0F3 C9                                   ret
  43+ E0F4
  44+ E0F4
  45+ E0F4
  46+ E0F4 30 30 00     HexU8Char:       DB "00",0
  47+ E0F7 30 30 30 30  HexU16Char:      DB "0000",0
  47+ E0FB 00
  48+ E0FC 2B 30 30 00  HexS8Char:       DB "+00",0
  49+ E100 2B 30 30 30  HexS16Char:      DB "+0000",0
  49+ E104 30 00
  50+ E106 2B 30 30 30  HexS24Char:      DB "+0000.00",0
  50+ E10A 30 2E 30 30
  50+ E10E 00
  51+ E10F 2A 2A 00     HexU8NaN:        DB "**",0
  52+ E112
  53+ E112              ; prints + sign for bit 7 clear in a else - sign for bit 7 set, Load to buffer location in ix
  54+ E112 CB 7F        l1_buffer_sign_at_ix:   bit     7,a
  55+ E114 CA 1D E1                             jp      z,.PrintPlus
  56+ E117 3E 2D        .PrintMinus:            ld      a,"-"
  57+ E119 DD 77 00                             ld      (ix+0),a
  58+ E11C C9                                   ret
  59+ E11D 3E 2B        .PrintPlus:             ld      a,"+"
  60+ E11F DD 77 00                             ld      (ix+0),a
  61+ E122 C9                                   ret
  62+ E123
  63+ E123 30 31 32 33  HexMapping:     DB "0123456789ABCDEF"
  63+ E127 34 35 36 37
  63+ E12B 38 39 41 42
  63+ E12F 43 44 45 46
  64+ E133              ; writes hex 8 bit to ix buffer position
  65+ E133 C5 E5        l1_buffer_hex_8_at_ix:  push    bc,,hl
  66+ E135 47                                   ld      b,a
  67+ E136 ED 23                                swapnib
  68+ E138 E6 0F                                and     $0F
  69+ E13A 21 23 E1                             ld      hl,HexMapping
  70+ E13D ED 31                                add     hl,a
  71+ E13F 7E                                   ld      a,(hl)
  72+ E140 DD 77 00                             ld      (ix+0),a
  73+ E143 21 23 E1                             ld      hl,HexMapping
  74+ E146 78                                   ld      a,b
  75+ E147 E6 0F                                and     $0F
  76+ E149 ED 31                                add     hl,a
  77+ E14B 7E                                   ld      a,(hl)
  78+ E14C DD 77 01                             ld      (ix+1),a
  79+ E14F E1 C1                                pop     bc,,hl
  80+ E151 C9                                   ret
  81+ E152
  82+ E152              ; prints 16 bit lead sign hex value in HLA at char pos DE
  83+ E152 F5           l1_print_s24_hex_at_char: push  af                      ; first off do sign
  84+ E153 DD 21 06 E1                            ld    ix,HexS24Char
  85+ E157 7C                                     ld    a,h
  86+ E158 CD 12 E1                               call  l1_buffer_sign_at_ix
  87+ E15B F1                                     pop   af                      ; now do hl as an unsigned by clearing bit 7
  88+ E15C DD 23                                  inc   ix                      ; move to actual digits
  89+ E15E F5                                     push  af
  90+ E15F 7C                                     ld    a,h
  91+ E160 CB BF                                  res   7,a                     ; clear sign bit regardless
  92+ E162 CD 33 E1                               call  l1_buffer_hex_8_at_ix
  93+ E165 DD 23                                  inc   ix
  94+ E167 DD 23                                  inc   ix
  95+ E169 7D                                     ld    a,l
  96+ E16A CD 33 E1                               call  l1_buffer_hex_8_at_ix
  97+ E16D DD 23                                  inc   ix
  98+ E16F DD 23                                  inc   ix
  99+ E171 DD 23                                  inc   ix                      ; also skip decimal point
 100+ E173 F1                                     pop   af
 101+ E174 CD 33 E1                               call  l1_buffer_hex_8_at_ix
 102+ E177 21 06 E1                               ld    hl,HexS24Char           ; by here de is still unaffected
 103+ E17A CD D7 E0                               call  l1_print_at_char
 104+ E17D C9                                     ret
 105+ E17E              ; prints 16 bit lead sign hex value in HL at char pos DE
 106+ E17E DD 21 00 E1  l1_print_s16_hex_at_char: ld    ix,HexS16Char
 107+ E182 7C                                     ld    a,h
 108+ E183 CD 12 E1                               call  l1_buffer_sign_at_ix
 109+ E186 DD 23                                  inc   ix                      ; move to actual digits
 110+ E188 7C                                     ld    a,h
 111+ E189 CB BF                                  res   7,a
 112+ E18B CD 33 E1                               call  l1_buffer_hex_8_at_ix
 113+ E18E DD 23                                  inc   ix
 114+ E190 DD 23                                  inc   ix
 115+ E192 7D                                     ld    a,l
 116+ E193 CD 33 E1                               call  l1_buffer_hex_8_at_ix
 117+ E196 21 00 E1                               ld    hl,HexS16Char           ; by here de is still unaffected
 118+ E199 CD D7 E0                               call  l1_print_at_char
 119+ E19C C9                                     ret
 120+ E19D              ; prints 16 bit unsigned hext value in HL at char pos DE
 121+ E19D DD 21 F7 E0  l1_print_u16_hex_at_char: ld    ix,HexU16Char
 122+ E1A1 7C                                     ld    a,h
 123+ E1A2 CD 33 E1                               call  l1_buffer_hex_8_at_ix
 124+ E1A5 DD 23                                  inc   ix
 125+ E1A7 DD 23                                  inc   ix
 126+ E1A9 7D                                     ld    a,l
 127+ E1AA CD 33 E1                               call  l1_buffer_hex_8_at_ix
 128+ E1AD 21 F7 E0                               ld    hl,HexU16Char           ; by here de is still unaffected
 129+ E1B0 CD D7 E0                               call  l1_print_at_char
 130+ E1B3 C9                                     ret
 131+ E1B4              ; prints 8 bit signed hext value in a at char pos DE
 132+ E1B4 DD 21 FC E0  l1_print_s8_hex_at_char:  ld    ix,HexS8Char
 133+ E1B8 67                                     ld    h,a                     ; save a into h
 134+ E1B9 CD 12 E1                               call  l1_buffer_sign_at_ix
 135+ E1BC DD 23                                  inc   ix                      ; move to actual digits
 136+ E1BE 7C                                     ld    a,h                     ; get a back
 137+ E1BF CB BF                                  res   7,a                     ; clear sign bit regardless
 138+ E1C1 CD 33 E1                               call  l1_buffer_hex_8_at_ix
 139+ E1C4 21 FC E0                               ld    hl,HexS8Char           ; by here de is still unaffected
 140+ E1C7 CD D7 E0                               call  l1_print_at_char
 141+ E1CA C9                                     ret
 142+ E1CB              ; prints 8 bit 2s compliment value in a at char pos DE
 143+ E1CB DD 21 FC E0  l1_print_82c_hex_at_char: ld    ix,HexS8Char
 144+ E1CF 67                                     ld    h,a                     ; save a into h
 145+ E1D0 CD 12 E1                               call  l1_buffer_sign_at_ix
 146+ E1D3 DD 23                                  inc   ix                      ; move to actual digits
 147+ E1D5 7C                                     ld    a,h                     ; get a back
 148+ E1D6 CB 7F                                  bit   7,a
 149+ E1D8 CA DD E1                               jp    z,.NoNeg
 150+ E1DB ED 44                                  neg
 151+ E1DD CD 33 E1     .NoNeg:                   call  l1_buffer_hex_8_at_ix
 152+ E1E0 21 FC E0                               ld    hl,HexS8Char           ; by here de is still unaffected
 153+ E1E3 CD D7 E0                               call  l1_print_at_char
 154+ E1E6 C9                                     ret
 155+ E1E7
 156+ E1E7              ; prints Lead Sign byte 8 bit signed hex value in hl at char pos DE, reuse HexS8Char buffer
 157+ E1E7 DD 21 FC E0  l1_print_s08_hex_at_char: ld    ix,HexS8Char
 158+ E1EB CD 12 E1                               call  l1_buffer_sign_at_ix    ; h holds sign bit
 159+ E1EE DD 23                                  inc   ix                      ; move to actual digits
 160+ E1F0 7D                                     ld    a,l                     ; l holds value
 161+ E1F1 CD 33 E1                               call  l1_buffer_hex_8_at_ix
 162+ E1F4 21 FC E0                               ld    hl,HexS8Char           ; by here de is still unaffected
 163+ E1F7 CD D7 E0                               call  l1_print_at_char
 164+ E1FA C9                                     ret
 165+ E1FB              ; prints 8 bit signed hext value in a at char pos DE
 166+ E1FB DD 21 F4 E0  l1_print_u8_hex_at_char:  ld    ix,HexU8Char
 167+ E1FF CD 33 E1                               call  l1_buffer_hex_8_at_ix
 168+ E202 21 F4 E0                               ld    hl,HexU8Char           ; by here de is still unaffected
 169+ E205 CD D7 E0                               call  l1_print_at_char
 170+ E208 C9                                     ret
 171+ E209 2B 00        l1_PlusSign:              DB      "+",0
 172+ E20B 2D 00        l1_MinusSign:             DB      "-",0
 173+ E20D 20 00        l1_ClearSign:             DB      " ",0
 174+ E20F              ; Displays sign byte in A at DE
 175+ E20F FE 80        l1_printSignByte:         cp      $80
 176+ E211 C2 27 E2                               jp      nz,.DisplayPlus
 177+ E214 FE 01                                  cp      1
 178+ E216 C2 20 E2                               jp      nz,.DisplayMinus
 179+ E219 21 0D E2     .DisplayClear:            ld      hl,l1_ClearSign
 180+ E21C CD D7 E0                               call    l1_print_at_char
 181+ E21F C9                                     ret
 182+ E220 21 0B E2     .DisplayMinus             ld      hl,l1_MinusSign
 183+ E223 CD D7 E0                               call    l1_print_at_char
 184+ E226 C9                                     ret
 185+ E227 21 09 E2     .DisplayPlus:             ld      hl,l1_PlusSign
 186+ E22A CD D7 E0                               call    l1_print_at_char
 187+ E22D C9                                     ret
 188+ E22E
 189+ E22E 21 0F E1     l1_print_u8_nan_at_char:  ld    hl,HexU8NaN
 190+ E231 CD D7 E0                               call  l1_print_at_char
 191+ E234 C9                                     ret
 192+ E235
 193+ E235
 194+ E235              ;l1_print_at_wrap:
 195+ E235              ;; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
 196+ E235              ;	ld      iyh,e
 197+ E235              ;.PrintLoop:
 198+ E235              ;	ld		a,(hl)
 199+ E235              ;	cp		0
 200+ E235              ;	ret		z
 201+ E235              ;.CountWordCharLen
 202+ E235              ;; Need to change to word wrap, so it will loop through string as before
 203+ E235              ;; but read up until a null or space, take the character count * 8 for pixels
 204+ E235              ;; if that is > 238 then force a premature line wrap
 205+ E235              ;
 206+ E235              ;
 207+ E235              ;    push    iy
 208+ E235              ;    call	l1_print_char
 209+ E235              ;    pop     iy
 210+ E235              ;	inc		hl							; move 1 message character right
 211+ E235              ;	ld		a,e
 212+ E235              ;    cp      238
 213+ E235              ;    jr      nc,.NextLine
 214+ E235              ;	add		a,8
 215+ E235              ;	ld		e,a							; move 1 screen character right
 216+ E235              ;	jr		.PrintLoop
 217+ E235              ;.Clearstackandfinish:
 218+ E235              ;	pop		de
 219+ E235              ;	ret
 220+ E235              ;.NextLine:
 221+ E235              ;    ld      a,(hl)
 222+ E235              ;    cp      " "
 223+ E235              ;    ld      e,iyh
 224+ E235              ;    ld      a,d
 225+ E235              ;    add     a,8
 226+ E235              ;    ld      d,a
 227+ E235              ;    jr		.PrintLoop
 228+ E235
 229+ E235              ; Counts next word at hl, uses e and forces a wrap if it would over flow puts value in c
 230+ E235 E5           L1LenWordAtHL:          push    hl
 231+ E236 D5                                   push    de
 232+ E237 7E           .CountLoop:             ld      a,(hl)
 233+ E238 FE 00                                cp      0
 234+ E23A 28 0F                                jr      z,.CountDone
 235+ E23C FE 20                                cp      32
 236+ E23E 28 0B                                jr      z,.CountDone
 237+ E240 7B                                   ld      a,e
 238+ E241 C6 08                                add     a,8
 239+ E243 5F                                   ld      e,a
 240+ E244 FE EE                                cp      238
 241+ E246 30 07                                jr      nc,.TooLong
 242+ E248 23                                   inc     hl
 243+ E249 18 EC                                jr      .CountLoop
 244+ E24B D1           .CountDone:             pop     de
 245+ E24C E1                                   pop     hl
 246+ E24D AF                                   xor     a
 247+ E24E C9                                   ret
 248+ E24F D1           .TooLong                pop     de
 249+ E250 E1                                   pop     hl
 250+ E251 3E FF                                ld      a,$FF
 251+ E253 C9                                   ret
 252+ E254
 253+ E254 7E           L1PrintWordAtHL:        ld      a,(hl)
 254+ E255 FE 00                                cp      0
 255+ E257 C8                                   ret     z
 256+ E258 FE 20                                cp      32
 257+ E25A 28 0F                                jr      z,.ItsASpace
 258+ E25C FD E5                                push    iy
 259+ E25E CD BA E0                             call	l1_print_char
 260+ E261 FD E1                                pop     iy
 261+ E263 7B                                   ld      a,e
 262+ E264 C6 08                                add     a,8
 263+ E266 5F                                   ld      e,a
 264+ E267 23                                   inc     hl
 265+ E268 C3 54 E2                             jp      L1PrintWordAtHL
 266+ E26B 23           .ItsASpace:             inc     hl      ;  Just a bodge for now
 267+ E26C 7B                                   ld      a,e
 268+ E26D C6 08                                add     a,8
 269+ E26F 5F                                   ld      e,a
 270+ E270 C9                                   ret
 271+ E271
 272+ E271
 273+ E271              ; print at based whole character positions DE=yx, HL = message Addr
 274+ E271              ;
 275+ E271 CB 22        l1_print_at_char_wrap:  sla     d       ; Convert D from char to pixel
 276+ E273 CB 22                                sla     d       ; by muliplying by 8
 277+ E275 CB 22                                sla     d       ;
 278+ E277              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
 279+ E277              ; Now has full word level wrapping
 280+ E277 FD 63        l1_print_at_wrap:       ld      iyh,e
 281+ E279 7E           .PrintLoop:             ld		a,(hl)
 282+ E27A FE 00                                cp		0
 283+ E27C C8                                   ret		z
 284+ E27D CD 35 E2     .CountWordCharLen:      call    L1LenWordAtHL
 285+ E280 FE FF                                cp      $FF
 286+ E282 28 06                                jr      z,.WrapNextLine
 287+ E284 CD 54 E2     .NotTooLong:            call    L1PrintWordAtHL
 288+ E287              ; Need to change to word wrap, so it will loop through string as before
 289+ E287              ; but read up until a null or space, take the character count * 8 for pixels
 290+ E287              ; if that is > 238 then force a premature line wrap
 291+ E287 18 F0                                jr		.PrintLoop
 292+ E289              .Clearstackandfinish:   ;op		de
 293+ E289 C9                                   ret
 294+ E28A              .WrapNextLine:
 295+ E28A FD 5C        .NextLine:              ld      e,iyh
 296+ E28C 7A                                   ld      a,d
 297+ E28D C6 08                                add     a,8
 298+ E28F 57                                   ld      d,a
 299+ E290 18 E7                                jr		.PrintLoop
 300+ E292
 301+ E292
# file closed: ../../Layer1Graphics/layer1_print_at.asm
1378  E292                  DISPLAY "Bank ",BankLAYER1," - Bytes free ",/D, $2000 - ($-LAYER1Addr), " - BankLAYER1"
1379  E292
1380  E292                  DISPLAY "Bank ",BankShipModels1," - Bytes free ",/D, $2000 - ($-ShipModelsAddr), " - BankShipModels1"
1381  E292              ; Bank 70  ------------------------------------------------------------------------------------------------------------------------
1382  E292                                  SLOT    UniverseBankAddr
1383  E292                                  PAGE    BankUNIVDATA0
1384  E292                                  ORG	    UniverseBankAddr,BankUNIVDATA0
1385  C000                                  INCLUDE "../../Tests/Vectors/univ_ship_data.asm"
# file opened: ../../Tests/Vectors/univ_ship_data.asm
   1+ C000              ;    DEFINE DEBUGMISSILELAUNCH 1
   2+ C000              ;    DEFINE PLOTPOINTSONLY 1
   3+ C000              ;   DEFINE OVERLAYNODES 1
   4+ C000              ; In  flight ship data tables
   5+ C000              ; In  flight ship data tables
   6+ C000              ; There can be upto &12 objects in flight.
   7+ C000              ; To avoid hassle of memory heap managment, the free list
   8+ C000              ; will correspond to a memory bank offset so data will be held in
   9+ C000              ; 1 bank per universe object. Its a waste of a lot of memory but really
  10+ C000              ; 1 bank per universe object. Its a waste of a lot of memory but really
  11+ C000              ; simple that way. Each bank will be 8K and swapped on 8K slot 7 $E000 to $FFFF
  12+ C000              ; This means each gets its own line list, inwork etc
  13+ C000
  14+ C000              ; "Runtime Ship Data paged into in Bank 7"
  15+ C000              ;                       1234567890123456
  16+ C000 55 6E 69 76  StartOfUniv:        DB "Universe PG"
  16+ C004 65 72 73 65
  16+ C008 20 50 47
  17+ C00B 58           StartOfUnivN:       DB "X"
  18+ C00C 00 00        StartOfUnivPad:     DS 2
  19+ C00E 00           StartOfUnivM:       DB 0
  20+ C00F 00           StartOfUnivT        DB 0
  21+ C010 00 00 00...  StartOfUnivName     DS 16
  22+ C020              ;-Camera Position of Ship----------------------------------------------------------------------------------------------------------
  23+ C020                                     INCLUDE "../../Universe/Ships/AIRuntimeData.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/AIRuntimeData.asm
   1++C020              ;-Camera Position of Ship----------------------------------------------------------------------------------------------------------
   2++C020              ;--NOTE POSTITION AND MATRIX are loaded by a single LDIR in cases so must be contiguous
   3++C020              StartOfShipRuntimeData      EQU $
   4++C020 00           UBnKxlo                     DB  0                       ; INWK+0
   5++C021 00           UBnKxhi                     DB  0                       ; there are hi medium low as some times these are 24 bit
   6++C022 00           UBnKxsgn                    DB  0                       ; INWK+2
   7++C023 00           UBnKylo                     DB  0                       ; INWK+3 \ ylo
   8++C024 00           UBnKyhi                     DB  0                       ; INWK+4 \ yHi
   9++C025 00           UBnKysgn                    DB  0                       ; INWK +5
  10++C026 00           UBnKzlo                     DB  0                       ; INWK +6
  11++C027 00           UBnKzhi                     DB  0                       ; INWK +7
  12++C028 00           UBnKzsgn                    DB  0                       ; INWK +8
  13++C029              ;-Rotation Matrix of Ship----------------------------------------------------------------------------------------------------------
  14++C029              ; Rotation data is stored as lohi, but only 15 bits with 16th bit being  a sign bit. Note this is NOT 2'c compliment
  15++C029              ; Note they seem to have to be after camera position not quite found why yet, can only assume it does an iy or ix indexed copy? Bu oddly does not affect space station.
  16++C029 00           UBnkTidyCounter             DB  0                       ; every 16 iterations the rotation matrix is normalised
  17++C02A 00 00        UBnkrotmatSidevX            DW  0                       ; INWK +21
  18++C02C              UBnkrotmatSidev             equ UBnkrotmatSidevX
  19++C02C 00 00        UBnkrotmatSidevY            DW  0                       ; INWK +23
  20++C02E 00 00        UBnkrotmatSidevZ            DW  0                       ; INWK +25
  21++C030 00 00        UBnkrotmatRoofvX            DW  0                       ; INWK +15
  22++C032              UBnkrotmatRoofv             equ UBnkrotmatRoofvX
  23++C032 00 00        UBnkrotmatRoofvY            DW  0                       ; INWK +17
  24++C034 00 00        UBnkrotmatRoofvZ            DW  0                       ; INWK +19
  25++C036 00 00        UBnkrotmatNosevX            DW  0                       ; INWK +9
  26++C038              UBnkrotmatNosev             EQU UBnkrotmatNosevX
  27++C038 00 00        UBnkrotmatNosevY            DW  0                       ; INWK +11
  28++C03A 00 00        UBnkrotmatNosevZ            DW  0                       ; INWK +13
  29++C03C              ; -- Note these must be here for initialise blast as it does a 12 byte ldir
  30++C03C              ; . Note missile explosion will have to have logic to cause linger if a blast is to be enqued
  31++C03C 00           UBnKMissileBlastRange:      DB  0                       ; copied in when setting up a missile
  32++C03D 00           UBnKMissileBlastDamage:     DB  0                       ; copied in when setting up a missile
  33++C03E 00           UBnKMissileDetonateRange:   DB  0                       ; copied in when setting up a missile, allows for proximity missiles
  34++C03F 00           UBnKMissileDetonateDamage:  DB  0                       ; copied in when setting up a missile
  35++C040              ; -- Metadata for ship to help with bank managment
  36++C040              UBnKStartOfRuntimeData:
  37++C040 00           UBnKSlotNumber              DB  0
  38++C041 00           UbnKShipUnivBankNbr         DB  0                       ; Present ship universe bank number
  39++C042 00           UBnkShipModelBank           DB  0                       ; Bank nbr ship was from
  40++C043 00           UBnKShipModelNbr            DB  0                       ; Ship Id with in the bank
  41++C044 00           UBnKShipModelId             DB  0                       ; Absolute ship id
  42++C045              ; -- Ship AI data
  43++C045              ; -- Targetting runtime data
  44++C045 00           UBnKMissleHitToProcess      DB  0                       ; This is used for enquing missle blasts as we can only do one missile at a time, could make it multi but neeed to smooth CPU usage
  45++C046 00           UBnKMissileTarget           DB  0                       ; This is the ship slot number for the target from 0 to n if the missile is not hostile to us, if the target is $FF then its us
  46++C047 00 00 00     UBnKTargetXPos              DS  3                       ; target position for AI
  47++C04A 00 00 00     UBnKTargetYPos              DS  3                       ; .
  48++C04D 00 00 00     UBnKTargetZPos              DS  3                       ; .
  49++C050 00           UBnKTargetXPosSgn           DS  1                       ; target position sign for AI
  50++C051 00           UBnKTargetYPosSgn           DS  1                       ; .
  51++C052 00           UBnKTargetZPosSgn           DS  1                       ; .
  52++C053 00 00        UBnKTargetVectorX           DS  2                       ; target vector for AI
  53++C055 00 00        UBnKTargetVectorY           DS  2                       ; .
  54++C057 00 00        UBnKTargetVectorZ           DS  2                       ; .
  55++C059 00 00        UBnKTargetDotProduct1       DS  2
  56++C05B 00 00        UBnKTargetDotProduct2       DS  2
  57++C05D 00 00        UBnKTargetDotProduct3       DS  2
  58++C05F 00           UBnKTacticsRotMatX          DB  0
  59++C060 00           UBnKTacticsRotMatXSign      DB  0
  60++C061 00           UBnKTacticsRotMatY          DB  0
  61++C062 00           UBnKTacticsRotMatYSign      DB  0
  62++C063 00           UBnKTacticsRotMatZ          DB  0
  63++C064 00           UBnKTacticsRotMatZSign      DB  0
  64++C065 00 00 00...  UBnKOffset                  DS  3 * 3                   ; Offset position for target
  65++C06E              UBnKOffsetX                 equ UBnKOffset
  66++C06E              UBnKOffsetXHi               equ UBnKOffsetX+1
  67++C06E              UBnKOffsetXSign             equ UBnKOffsetX+2
  68++C06E              UBnKOffsetY                 equ UBnKOffset+3
  69++C06E              UBnKOffsetYHi               equ UBnKOffsetY+1
  70++C06E              UBnKOffsetYSign             equ UBnKOffsetY+2
  71++C06E              UBnKOffsetZ                 equ UBnKOffset+6
  72++C06E              UBnKOffsetZHi               equ UBnKOffsetZ+1
  73++C06E              UBnKOffsetZSign             equ UBnKOffsetZ+2
  74++C06E 00           UBnKDirectionX              DB  0
  75++C06F 00           UBnKDirectionXHi            DB  0
  76++C070 00           UBnKDirectionXSign          DB  0
  77++C071 00           UBnKDirectionY              DB  0
  78++C072 00           UBnKDirectionYHi            DB  0
  79++C073 00           UBnKDirectionYSign          DB  0
  80++C074 00           UBnKDirectionZ              DB  0
  81++C075 00           UBnKDirectionZHi            DB  0
  82++C076 00           UBnKDirectionZSign          DB  0
  83++C077 00           UBnKDirNormX                DB  0
  84++C078 00           UBnKDirNormXSign            DB  0
  85++C079 00           UBnKDirNormY                DB  0
  86++C07A 00           UBnKDirNormYSign            DB  0
  87++C07B 00           UBnKDirNormZ                DB  0
  88++C07C 00           UBnKDirNormZSign            DB  0
  89++C07D              UBnKDirection               equ UBnKDirectionX          ; Direction Vector
  90++C07D 00 00        UBnKDotProductNose          DW  0                       ; Dot Product
  91++C07F 00           UBnKDotProductNoseSign      DB  0
  92++C080 00 00        UBnKDotProductRoof          DW  0                       ; Dot Product
  93++C082 00           UBnKDotProductRoofSign      DB  0
  94++C083 00 00        UBnKDotProductSide          DW  0                       ; Dot Product
  95++C085 00           UBnKDotProductSideSign      DB  0
  96++C086 00           UBnKSpeed                   DB  0                       ; INWK +27
  97++C087 00           UBnKAccel                   DB  0                       ; INWK +28
  98++C088 00           UBnKRotXCounter             DB  0                       ; INWK +29
  99++C089              UBnKRollCounter             equ UBnKRotXCounter         ; change over to this in code
 100++C089 00           UBnKRotZCounter             DB  0                       ; INWK +30
 101++C08A              UBnKPitchCounter            equ UBnKRotZCounter
 102++C08A 00           UBnKRAT                     DB  0                       ; temporary for rotation magnitude or roll counter, for debugging state
 103++C08B 00           UBnKRAT2                    DB  0                       ; temporary for rotation threshold
 104++C08C 00           UBnKCNT                     DB  0                       ; temp for calculating roll and pitch
 105++C08D 00           UBnKCNT2                    DB  0                       ; roll threshold, max angle boynd ship will slow down
 106++C08E 00           univRAT                     DB  0               ; 99
 107++C08F 00           univRAT2                    DB  0               ; 9A
 108++C090 00           univRAT2Val                 DB  0               ; 9A
 109++C091 00           UBnKexplDsp                 DB  0                       ; INWK +31 clear exploding/display state|missiles
 110++C092 00           UBnkDrawAllFaces            DB  0
 111++C093 00           UBnKShipAggression          DB  0                       ; calculated agression factor
 112++C094 00           UBnkaiatkecm                DB  0                       ; INWK +32 ai_attack_univ_ecm i.e. AI type
 113++C095 00           UBnKSpawnObject             DB  0
 114++C096 00           UBnkCam0yLo                 DB  0                       ; INWK +33 ????
 115++C097 00           UBnkCam0yHi                 DB  0                       ; INWK +34?????
 116++C098 00           UBnKEnergy                  DB  0                       ; INWK +35
 117++C099 00           UBnKECMCountDown            DB  0                       ; counts down ECM usage if activated reducing energy too in update loop
 118++C09A 00           UBnKECMFitted               DB  0                       ; Does ship have ECM, true false
 119++C09B 00           UBnKLaserPower              DB  0                       ; Type of laser fitted
 120++C09C 00           UBnKMissilesLeft            DB  0
 121++C09D 00           UBnKFighterShipId           DB  0                       ; computed ship Id for any carriers
 122++C09E 00           UBnKFightersLeft            DB  0                       ; the number of ships left in hanger, 255 = infinite
 123++C09F 00           UBnKCloudCounter            DB  0                       ; cloud pixels
 124++C0A0 00           UBnKCloudRadius             DB  0                       ; cloud pixels
 125++C0A1 00           UBnKHeadingToPlanetOrSun    DB  0                       ; 0 = undefined 1 = heading to planet 2 = heading to sun, if it reaches planet then will move to docking, if it heads to sun then will jump
 126++C0A2
 127++C0A2              UBnKRuntimeSize             EQU $-UBnKStartOfRuntimeData
 128++C0A2              ; Flags work as follows:
 129++C0A2              ; UBnKSpawnObject - signals on death to spawn cargo items
 130++C0A2              ; 0 -                   Spawn Cargo 1
 131++C0A2              ; 1 -                   Spawn Cargo 2
 132++C0A2              ; 2 -                   Spawn Cargo 3
 133++C0A2              ; 3 -                   Spawn Cargo 4
 134++C0A2              ; 4 -                   Spawn Alloy 1
 135++C0A2              ; 5 -                   Spawn Alloy 2
 136++C0A2              ; 6 -                   Spawn Alloy 3
 137++C0A2              ; 7 -                   Spawn Alloy 4
 138++C0A2
 139++C0A2              ; UBnkaiatkecm
 140++C0A2              ; Bit	                Description
 141++C0A2              ; 7 -                   AI Enabled Flag
 142++C0A2              ; 6 -                   Ship Visible = ShipOnScreen/NotCloaked (cleared or set by check visible or cloaking override)
 143++C0A2              ; 5 -                   Ship is exploding if set, note if its a missile and one already equeued this will have to linger
 144++C0A2              ;                       linger can be done by not erasing ship unit missile equeue handled
 145++C0A2              ; 4 -                   Ship marked as exploded, cleared once aknowledged then bit 5 takes over and UBnKCloudCounter
 146++C0A2              ; 3 -                   Display state - Plot as a Dot
 147++C0A2              ; 2 -                   Nbr of Missiles bit 2
 148++C0A2              ; 1 -                   Nbr of Missiles bit 1
 149++C0A2              ; 0 -                   ECM present flag
 150++C0A2              ; ShipNewBitsAddr (in blueprint)
 151++C0A2              ;Bit	                Description
 152++C0A2              ;#0	Trader flag         * 0 = not a trader  * 1 = trader
 153++C0A2              ;                       80% of traders are peaceful and mind their own business plying their trade between the planet and space station, but 20% of them moonlight as bounty hunters (see bit #1)
 154++C0A2              ;                       Ships that are traders: Escape pod, Shuttle, Transporter, Anaconda, Rock hermit, Worm
 155++C0A2              ;#1 Bounty hunter flag  * 0 = not a bounty hunter* 1 = bounty hunter
 156++C0A2              ;                       If we are a fugitive or a serious offender and we bump into a bounty hunter, they will become hostile and attack us (see bit #2)
 157++C0A2              ;                       Ships that are bounty hunters: Viper, Fer-de-lance
 158++C0A2              ;#2	Hostile flag        * 0 = not hostile  * 1 = hostile
 159++C0A2              ;                       Hostile ships will attack us on sight; there are quite a few of them
 160++C0A2              ;                       Ships that are hostile: Sidewinder, Mamba, Krait, Adder, Gecko, Cobra Mk I, Worm, Cobra Mk III, Asp Mk II, Python (pirate), Moray, Thargoid, Thargon, Constrictor
 161++C0A2              ;#3	Pirate flag         * 0 = not a pirate * 1 = pirate
 162++C0A2              ;                       Hostile pirates will attack us on sight, but once we get inside the space station safe zone, they will stop
 163++C0A2              ;                       Ships that are pirates: Sidewinder, Mamba, Krait, Adder, Gecko, Cobra Mk I, Cobra Mk III, Asp Mk II, Python (pirate), Moray, Thargoid
 164++C0A2              ;#4	Docking flag        * 0 = not docking * 1 = docking
 165++C0A2              ;                       Traders with their docking flag set fly towards the space station to try to dock, otherwise they aim for the planet
 166++C0A2              ;                       This flag is randomly set for traders when they are spawned
 167++C0A2              ;                       Ships that can be docking: Escape pod, Shuttle, Transporter, Anaconda, Rock hermit, Worm
 168++C0A2              ;#5	Innocent bystander  * 0 = normal * 1 = innocent bystander
 169++C0A2              ;                       If we attack an innocent ship within the space station safe zone, then the station will get angry with us and start spawning cops
 170++C0A2              ;                       Ships that are innocent bystanders: Shuttle, Transporter, Cobra Mk III, Python, Boa, Anaconda, Rock hermit, Cougar
 171++C0A2              ;#6	Cop flag            * 0 = not a cop * 1 = cop
 172++C0A2              ;                       If we destroy a cop, then we instantly become a fugitive (the Transporter isn't actually a cop, but it's clearly under police protection)
 173++C0A2              ;                       Ships that are cops: Viper, Transporter
 174++C0A2              ;#7	Scooped, docked, escape pod flag
 175++C0A2              ;                       For spawned ships, this flag indicates that the ship been scooped or has docked (bit 7 is always clear on spawning)
 176++C0A2              ;                       For blueprints, this flag indicates whether the ship type has an escape pod fitted, so it can launch it when in dire straits
 177++C0A2              ;                       Ships that have escape pods: Cobra Mk III, Python, Boa, Anaconda, Rock hermit, Viper, Mamba, Krait, Adder, Cobra Mk I, Cobra Mk III (pirate), Asp Mk II, Python (pirate), Fer-de-lance
 178++C0A2
# file closed: ../../Tests/Vectors/../../Universe/Ships/AIRuntimeData.asm
  24+ C0A2                                      INCLUDE "../../Universe/Ships/XX16Vars.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/XX16Vars.asm
   1++C0A2              ;-- XX16 --------------------------------------------------------------------------------------------------------------------------
   2++C0A2 00 00        UBnkTransmatSidevX          DW  0               ; XX16+0
   3++C0A4              UBnkTransmatSidev           EQU UBnkTransmatSidevX
   4++C0A4 00 00        UBnkTransmatSidevY          DW 0                ; XX16+2
   5++C0A6 00 00        UBnkTransmatSidevZ          DW 0                ; XX16+2
   6++C0A8 00 00        UBnkTransmatRoofvX          DW 0
   7++C0AA              UBnkTransmatRoofv           EQU UBnkTransmatRoofvX
   8++C0AA 00 00        UBnkTransmatRoofvY          DW 0                ; XX16+2
   9++C0AC 00 00        UBnkTransmatRoofvZ          DW 0                ; XX16+2
  10++C0AE 00 00        UBnkTransmatNosevX          DW 0
  11++C0B0              UBnkTransmatNosev           EQU UBnkTransmatNosevX
  12++C0B0 00 00        UBnkTransmatNosevY          DW 0                ; XX16+2
  13++C0B2 00 00        UBnkTransmatNosevZ          DW 0                ; XX16+2
  14++C0B4 00 00        UbnkTransmatTransX          DW 0
  15++C0B6 00 00        UbnkTransmatTransY          DW 0
  16++C0B8 00 00        UbnkTransmatTransZ          DW 0
  17++C0BA              XX16                        equ UBnkTransmatSidev
  18++C0BA              ;-- XX16Inv --------------------------------------------------------------------------------------------------------------------------
  19++C0BA 00 00        UbnkTransInvRow0x0          DW 0
  20++C0BC 00 00        UbnkTransInvRow0x1          DW 0
  21++C0BE 00 00        UbnkTransInvRow0x2          DW 0
  22++C0C0 00 00        UbnkTransInvRow0x3          DW 0
  23++C0C2 00 00        UbnkTransInvRow1y0          DW 0
  24++C0C4 00 00        UbnkTransInvRow1y1          DW 0
  25++C0C6 00 00        UbnkTransInvRow1y2          DW 0
  26++C0C8 00 00        UbnkTransInvRow1y3          DW 0
  27++C0CA 00 00        UbnkTransInvRow2z0          DW 0
  28++C0CC 00 00        UbnkTransInvRow2z1          DW 0
  29++C0CE 00 00        UbnkTransInvRow2z2          DW 0
  30++C0D0 00 00        UbnkTransInvRow2z3          DW 0
  31++C0D2
  32++C0D2              XX16Inv             equ UbnkTransInvRow0x0
  33++C0D2
# file closed: ../../Tests/Vectors/../../Universe/Ships/XX16Vars.asm
  25+ C0D2                                      INCLUDE "../../Universe/Ships/XX25Vars.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/XX25Vars.asm
   1++C0D2              ;-- XX25 --------------------------------------------------------------------------------------------------------------------------
   2++C0D2 00           UbnkProjxLo                 DB  0
   3++C0D3 00           UbnkProjxHi                 DB  0
   4++C0D4 00           UbnkProjxSgn                DB  0
   5++C0D5              UbnkProjx                   EQU UbnkProjxLo
   6++C0D5 00           UbnkProjyLo                 DB  0
   7++C0D6 00           UbnkProjyHi                 DB  0
   8++C0D7 00           UbnkProjySgn                DB  0
   9++C0D8              UbnkProjy                   EQU UbnkProjyLo
  10++C0D8 00           UbnkProjzLo                 DB  0
  11++C0D9 00           UbnkProjzHi                 DB  0
  12++C0DA 00           UbnkProjzSgn                DB  0
  13++C0DB              UbnkProjz                   EQU UbnkProjzLo
  14++C0DB              XX25                        EQU UbnkProjxLo
  15++C0DB
# file closed: ../../Tests/Vectors/../../Universe/Ships/XX25Vars.asm
  26+ C0DB                                      INCLUDE "../../Universe/Ships/XX18Vars.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/XX18Vars.asm
   1++C0DB              ;-- XX18 --------------------------------------------------------------------------------------------------------------------------
   2++C0DB 00           UBnkDrawCam0xLo             DB  0               ; XX18+0
   3++C0DC 00           UBnkDrawCam0xHi             DB  0               ; XX18+1
   4++C0DD 00           UBnkDrawCam0xSgn            DB  0               ; XX18+2
   5++C0DE              UBnkDrawCam0x               equ UBnkDrawCam0xLo
   6++C0DE 00           UBnkDrawCam0yLo             DB  0               ; XX18+3
   7++C0DF 00           UBnkDrawCam0yHi             DB  0               ; XX18+4
   8++C0E0 00           UBnkDrawCam0ySgn            DB  0               ; XX18+5
   9++C0E1              UBnkDrawCam0y               equ UBnkDrawCam0yLo
  10++C0E1 00           UBnkDrawCam0zLo             DB  0               ; XX18+6
  11++C0E2 00           UBnkDrawCam0zHi             DB  0               ; XX18+7
  12++C0E3 00           UBnkDrawCam0zSgn            DB  0               ; XX18+8
  13++C0E4              UBnkDrawCam0z               equ UBnkDrawCam0zLo
  14++C0E4              XX18                        equ UBnkDrawCam0xLo
  15++C0E4
# file closed: ../../Tests/Vectors/../../Universe/Ships/XX18Vars.asm
  27+ C0E4
  28+ C0E4              ; Used to make 16 bit reads a little cleaner in source code
  29+ C0E4 00 00 00     UbnkZPoint                  DS  3
  30+ C0E7              UbnkZPointLo                equ UbnkZPoint
  31+ C0E7              UbnkZPointHi                equ UbnkZPoint+1
  32+ C0E7              UbnkZPointSign              equ UbnkZPoint+2
  33+ C0E7                                      INCLUDE "../../Universe/Ships/XX15Vars.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/XX15Vars.asm
   1++C0E7              ;-- XX15 --------------------------------------------------------------------------------------------------------------------------
   2++C0E7 00           UBnkXScaled                 DB  0               ; XX15+0Xscaled
   3++C0E8 00           UBnkXScaledSign             DB  0               ; XX15+1xsign
   4++C0E9 00           UBnkYScaled                 DB  0               ; XX15+2yscaled
   5++C0EA 00           UBnkYScaledSign             DB  0               ; XX15+3ysign
   6++C0EB 00           UBnkZScaled                 DB  0               ; XX15+4zscaled
   7++C0EC 00           UBnkZScaledSign             DB  0               ; XX15+5zsign
   8++C0ED
   9++C0ED              XX15                        equ UBnkXScaled
  10++C0ED              XX15VecX                    equ XX15
  11++C0ED              XX15VecY                    equ XX15+1
  12++C0ED              XX15VecZ                    equ XX15+2
  13++C0ED              UbnkXPoint                  equ XX15
  14++C0ED              UbnkXPointLo                equ XX15+0
  15++C0ED              UbnkXPointHi                equ XX15+1
  16++C0ED              UbnkXPointSign              equ XX15+2
  17++C0ED              UbnkYPoint                  equ XX15+3
  18++C0ED              UbnkYPointLo                equ XX15+3
  19++C0ED              UbnkYPointHi                equ XX15+4
  20++C0ED              UbnkYPointSign              equ XX15+5
  21++C0ED              ; Repurposed XX15 pre clip plines
  22++C0ED              UbnkPreClipX1               equ XX15+0
  23++C0ED              UbnkPreClipY1               equ XX15+2
  24++C0ED              UbnkPreClipX2               equ XX15+4
  25++C0ED              UbnkPreClipY2               equ XX15+6
  26++C0ED              ; Repurposed XX15 post clip lines
  27++C0ED              UBnkNewX1                   equ XX15+0
  28++C0ED              UBnkNewY1                   equ XX15+1
  29++C0ED              UBnkNewX2                   equ XX15+2
  30++C0ED              UBnkNewY2                   equ XX15+3
  31++C0ED              ; Repurposed XX15
  32++C0ED              regXX15fx                   equ UBnkXScaled
  33++C0ED              regXX15fxSgn                equ UBnkXScaledSign
  34++C0ED              regXX15fy                   equ UBnkYScaled
  35++C0ED              regXX15fySgn                equ UBnkYScaledSign
  36++C0ED              regXX15fz                   equ UBnkZScaled
  37++C0ED              regXX15fzSgn                equ UBnkZScaledSign
  38++C0ED              ; Repurposed XX15
  39++C0ED              varX1                       equ UBnkXScaled       ; Reused, verify correct position
  40++C0ED              varY1                       equ UBnkXScaledSign   ; Reused, verify correct position
  41++C0ED              varZ1                       equ UBnkYScaled       ; Reused, verify correct position
  42++C0ED              ; After clipping the coords are two 8 bit pairs
  43++C0ED              UBnkPoint1Clipped           equ UBnkXScaled
  44++C0ED              UBnkPoint2Clipped           equ UBnkYScaled
  45++C0ED              ; Repurposed XX15 when plotting lines
  46++C0ED              ; Repurposed XX15 before calling clip routine
  47++C0ED              UBnkX1                      equ XX15
  48++C0ED              UBnKx1Lo                    equ XX15
  49++C0ED              UBnKx1Hi                    equ XX15+1
  50++C0ED              UBnkY1                      equ XX15+2
  51++C0ED              UbnKy1Lo                    equ XX15+2
  52++C0ED              UBnkY1Hi                    equ XX15+3
  53++C0ED              UBnkX2                      equ XX15+4
  54++C0ED              UBnkX2Lo                    equ XX15+4
  55++C0ED              UBnkX2Hi                    equ XX15+5
  56++C0ED
# file closed: ../../Tests/Vectors/../../Universe/Ships/XX15Vars.asm
  34+ C0ED                                      INCLUDE "../../Universe/Ships/XX12Vars.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/XX12Vars.asm
   1++C0ED              ;-- transmat0 --------------------------------------------------------------------------------------------------------------------------
   2++C0ED              ; Note XX12 comes after as some logic in normal processing uses XX15 and XX12 combines
   3++C0ED 00           UBnkXX12xLo                 DB  0               ; XX12+0
   4++C0EE 00           UBnkXX12xSign               DB  0               ; XX12+1
   5++C0EF 00           UBnkXX12yLo                 DB  0               ; XX12+2
   6++C0F0 00           UBnkXX12ySign               DB  0               ; XX12+3
   7++C0F1 00           UBnkXX12zLo                 DB  0               ; XX12+4
   8++C0F2 00           UBnkXX12zSign               DB  0               ; XX12+5
   9++C0F3 00 00 00...  XX12Save                    DS  6
  10++C0F9 00 00 00...  XX12Save2                   DS  6
  11++C0FF              XX12                        equ UBnkXX12xLo
  12++C0FF              varXX12                     equ UBnkXX12xLo
  13++C0FF              ; Repurposed XX12 when plotting lines
  14++C0FF              UBnkY2                      equ XX12+0
  15++C0FF              UbnKy2Lo                    equ XX12+0
  16++C0FF              UBnkY2Hi                    equ XX12+1
  17++C0FF              UBnkDeltaXLo                equ XX12+2
  18++C0FF              UBnkDeltaXHi                equ XX12+3
  19++C0FF              UBnkDeltaYLo                equ XX12+4
  20++C0FF              UBnkDeltaYHi                equ XX12+5
  21++C0FF              UbnkGradient                equ XX12+2
  22++C0FF              UBnkTemp1                   equ XX12+2
  23++C0FF              UBnkTemp1Lo                 equ XX12+2
  24++C0FF              UBnkTemp1Hi                 equ XX12+3
  25++C0FF              UBnkTemp2                   equ XX12+3
  26++C0FF              UBnkTemp2Lo                 equ XX12+3
  27++C0FF              UBnkTemp2Hi                 equ XX12+4
  28++C0FF
# file closed: ../../Tests/Vectors/../../Universe/Ships/XX12Vars.asm
  35+ C0FF
  36+ C0FF
  37+ C0FF              ; Post clipping the results are now 8 bit
  38+ C0FF 00           UBnkVisibility              DB  0               ; replaces general purpose xx4 in rendering
  39+ C100 00           UBnkProjectedY              DB  0
  40+ C101 00           UBnkProjectedX              DB  0
  41+ C102              UBnkProjected               equ UBnkProjectedY  ; resultant projected position
  42+ C102 00 00 00...  XX15Save                    DS  8
  43+ C10A 00 00 00...  XX15Save2                   DS  8
  44+ C112 00           VarBackface                 DB 0
  45+ C113              ; Heap (or array) information for lines and normals
  46+ C113              ; Coords are stored XY,XY,XY,XY
  47+ C113              ; Normals
  48+ C113              ; This needs re-oprganising now.
  49+ C113              ; Runtime Calculation Store
  50+ C113
  51+ C113              FaceArraySize               equ 30
  52+ C113              EdgeHeapSize                equ 40
  53+ C113              NodeArraySize               equ 40
  54+ C113              LineArraySize               equ 50; incerased for max of 28 lines, of 4 points of 16 bits each
  55+ C113              ; ONLY IF TESTING SOLID FILL TraingleArraySize           equ 25
  56+ C113              ; Storage arrays for data
  57+ C113              ; Structure of arrays
  58+ C113              ; Visibility array  - 1 Byte per face/normal on ship model Bit 7 (or FF) visible, 0 Invisible
  59+ C113              ; Node array corresponds to a processed vertex from the ship model transformed into world coordinates and tracks the node list from model
  60+ C113              ; NodeArray         -  4 bytes per element      0           1            2          3
  61+ C113              ;                                               X Coord Lo  Y Coord Lo   Z CoordLo  Sign Bits 7 6 5 for X Y Z Signs (set = negative)
  62+ C113              ; Line Array        -  4 bytes per eleement     0           1            2          3
  63+ C113              ;                                               X1          Y1           X2         Y2
  64+ C113 00 00 00...  UbnkFaceVisArray            DS FaceArraySize            ; XX2 Up to 16 faces this may be normal list, each entry is controlled by bit 7, 1 visible, 0 hidden
  65+ C131              ; Node array holds the projected to screen position regardless of if its clipped or not
  66+ C131              ; When we use traingles we can cheat a bit on clipping as all lines will be horizontal so clipping is much simplified
  67+ C131 00 00 00...  UBnkNodeArray               DS NodeArraySize * 4        ; XX3 Holds the points as an array, its an array not a heap
  68+ C1D1 00 00 00...  UBnkNodeArray2              DS NodeArraySize * 4        ; XX3 Holds the points as an array, its an array not a heap
  69+ C271 00 00 00...  UbnkLineArray               DS LineArraySize * 8        ; XX19 Holds the clipped line details
  70+ C401              ; ONLY IF TESTING SOLID FILL UBnkTriangleOverspill       DS TraingleArraySize * 4    ; jsut a padding for testing
  71+ C401              UBnkLinesHeapMax            EQU $ - UbnkLineArray
  72+ C401 00 00 00...  UbnkEdgeProcessedList DS EdgeHeapSize
  73+ C429              ; Array current Lengths
  74+ C429 00           UbnkFaceVisArrayLen         DS 1
  75+ C42A 00           UBnkNodeArrayLen            DS 1
  76+ C42B 00           UbnkLineArrayLen            DS 1                        ; total number of lines loaded to array
  77+ C42C 00           UbnkLineArrayBytes          DS 1                        ; total number of bytes loaded to array  = array len * 4
  78+ C42D              XX20                        equ UbnkLineArrayLen
  79+ C42D              varXX20                     equ UbnkLineArrayLen
  80+ C42D
  81+ C42D 00           UbnkEdgeHeapSize            DS 1
  82+ C42E 00           UbnkEdgeHeapBytes           DS 1
  83+ C42F 00           UBnkLinesHeapLen            DS 1
  84+ C430 00           UbnKEdgeHeapCounter         DS 1
  85+ C431 00           UbnKEdgeRadius              DS 1
  86+ C432 00           UbnKEdgeShipType            DS 1
  87+ C433 00           UbnKEdgeExplosionType       DS 1
  88+ C434
  89+ C434              ; Node heap is used to write out transformed Vertexs
  90+ C434
  91+ C434              ; Lines
  92+ C434 00 00 00     UBnkXX19                    DS  3
  93+ C437
  94+ C437 00 00 00...  UBnkHullCopy                DS  ShipDataLength
  95+ C452              ScoopDebrisAddr             equ UBnkHullCopy + ScoopDebrisOffset
  96+ C452              MissileLockLoAddr           equ UBnkHullCopy + MissileLockLoOffset
  97+ C452              MissileLockHiAddr           equ UBnkHullCopy + MissileLockHiOffset
  98+ C452              EdgeAddyAddr                equ UBnkHullCopy + EdgeAddyOffset
  99+ C452              LineX4Addr                  equ UBnkHullCopy + LineX4Offset
 100+ C452              GunVertexAddr               equ UBnkHullCopy + GunVertexOffset
 101+ C452              ExplosionCtAddr             equ UBnkHullCopy + ExplosionCtOffset
 102+ C452              VertexCountAddr             equ UBnkHullCopy + VertexCountOffset
 103+ C452              VertexCtX6Addr              equ UBnkHullCopy + VertexCtX6Offset
 104+ C452              EdgeCountAddr               equ UBnkHullCopy + EdgeCountOffset
 105+ C452              BountyLoAddr                equ UBnkHullCopy + BountyLoOffset
 106+ C452              BountyHiAddr                equ UBnkHullCopy + BountyHiOffset
 107+ C452              FaceCtX4Addr                equ UBnkHullCopy + FaceCtX4Offset
 108+ C452              DotAddr                     equ UBnkHullCopy + DotOffset
 109+ C452              EnergyAddr                  equ UBnkHullCopy + EnergyOffset
 110+ C452              SpeedAddr                   equ UBnkHullCopy + SpeedOffset
 111+ C452              FaceAddyAddr                equ UBnkHullCopy + FaceAddyOffset
 112+ C452              QAddr                       equ UBnkHullCopy + QOffset
 113+ C452              LaserAddr                   equ UBnkHullCopy + LaserOffset
 114+ C452              VerticesAddyAddr            equ UBnkHullCopy + VerticiesAddyOffset
 115+ C452              ShipTypeAddr                equ UBnkHullCopy + ShipTypeOffset
 116+ C452              ShipNewBitsAddr             equ UBnkHullCopy + ShipNewBitsOffset
 117+ C452              ShipAIFlagsAddr             equ UBnkHullCopy + ShipAIFlagsOffset
 118+ C452              ShipECMFittedChanceAddr     equ UBnkHullCopy + ShipECMFittedChanceOffset
 119+ C452              ShipSolidFlagAddr           equ UBnkHullCopy + ShipSolidFlagOffset
 120+ C452              ShipSolidFillAddr           equ UBnkHullCopy + ShipSolidFillOffset
 121+ C452              ShipSolidLenAddr            equ UBnkHullCopy + ShipSolidLenOffset
 122+ C452              ; Static Ship Data. This is copied in when creating the universe object
 123+ C452              XX0                         equ UBnkHullCopy        ; general hull index pointer TODO find biggest ship design
 124+ C452
 125+ C452 00 00 00...  UBnkHullVerticies           DS  40 * 6              ; largetst is trasnport type 10 at 37 vericies so alows for 40 * 6 Bytes  =
 126+ C542 00 00 00...  UBnkHullEdges               DS  50 * 4              ; ype 10 is 46 edges so allow 50
 127+ C60A 00 00 00...  UBnkHullNormals             DS  20 * 4              ; type 10 is 14 edges so 20 to be safe
 128+ C65A                  IFDEF SOLIDHULLTEST
 129+ C65A ~            UBnkHullSolid               DS  100 * 4             ; Up to 100 triangles (May optimise so only loads non hidden faces later
 130+ C65A                  ENDIF
 131+ C65A 0C           OrthagCountdown             DB  12
 132+ C65B
 133+ C65B              UBnkShipCopy                equ UBnkHullVerticies               ; Buffer for copy of ship data, for speed will copy to a local memory block, Cobra is around 400 bytes on creation of a new ship so should be plenty
 134+ C65B              UBnk_Data_len               EQU $ - StartOfUniv
 135+ C65B
 136+ C65B
 137+ C65B              ZeroUnivPitch:          MACRO
 138+ C65B ~                                    xor     a
 139+ C65B ~                                    ld      (UBnKRotZCounter),a
 140+ C65B                                      ENDM
 141+ C65B
 142+ C65B              ZeroUnivRoll:           MACRO
 143+ C65B ~                                    xor     a
 144+ C65B ~                                    ld      (UBnKRotXCounter),a
 145+ C65B                                      ENDM
 146+ C65B
 147+ C65B              ZeroUnivPitchAndRoll:   MACRO
 148+ C65B ~                                    xor     a
 149+ C65B ~                                    ld      (UBnKRotXCounter),a
 150+ C65B ~                                    ld      (UBnKRotZCounter),a
 151+ C65B                                      ENDM
 152+ C65B
 153+ C65B
 154+ C65B              MaxUnivPitchAndRoll:    MACRO
 155+ C65B ~                                    ld      a,127
 156+ C65B ~                                    ld      (UBnKRotXCounter),a
 157+ C65B ~                                    ld      (UBnKRotZCounter),a
 158+ C65B                                      ENDM
 159+ C65B
 160+ C65B              InfinitePitch:          MACRO
 161+ C65B ~                                    ld      a,$FF
 162+ C65B ~                                    ld      (UBnKRotZCounter),a
 163+ C65B                                      ENDM
 164+ C65B
 165+ C65B              InfiniteRoll:           MACRO
 166+ C65B ~                                    ld      a,$FF
 167+ C65B ~                                    ld      (UBnKRotXCounter),a
 168+ C65B                                      ENDM
 169+ C65B
 170+ C65B              InfinitePitchAndRoll:    MACRO
 171+ C65B ~                                    ld      a,$FF
 172+ C65B ~                                    ld      (UBnKRotXCounter),a
 173+ C65B ~                                    ld      (UBnKRotZCounter),a
 174+ C65B                                      ENDM
 175+ C65B
 176+ C65B              RandomUnivPitchAndRoll: MACRO
 177+ C65B ~                                    call    doRandom
 178+ C65B ~                                    or      %01101111
 179+ C65B ~                                    ld      (UBnKRotXCounter),a
 180+ C65B ~                                    call    doRandom
 181+ C65B ~                                    or      %01101111
 182+ C65B ~                                    ld      (UBnKRotZCounter),a
 183+ C65B                                      ENDM
 184+ C65B
 185+ C65B              RandomUnivSpeed:        MACRO
 186+ C65B ~                                    call    doRandom
 187+ C65B ~                                    and     31
 188+ C65B ~                                    ld      (UBnKSpeed),a
 189+ C65B                                      ENDM
 190+ C65B
 191+ C65B              ZeroUnivSpeed:          MACRO
 192+ C65B ~                                    ld      a,0
 193+ C65B ~                                    ld      (UBnKSpeed),a
 194+ C65B                                      ENDM
 195+ C65B
 196+ C65B              MaxUnivSpeed:           MACRO
 197+ C65B ~                                    ld      a,31
 198+ C65B ~                                    ld      (UBnKSpeed),a
 199+ C65B                                      ENDM
 200+ C65B
 201+ C65B              ZeroUnivAccelleration:  MACRO
 202+ C65B ~                                    xor     a
 203+ C65B ~                                    ld      (UBnKAccel),a
 204+ C65B                                      ENDM
 205+ C65B
 206+ C65B 3A 4F C4     SetShipHostile:         ld      a,(ShipNewBitsAddr)
 207+ C65E F6 04                                or      ShipIsHostile
 208+ C660 32 4F C4                             ld      (ShipNewBitsAddr),a
 209+ C663 C9                                   ret
 210+ C664
 211+ C664 3A 4F C4     ClearShipHostile:       ld      a,(ShipNewBitsAddr)
 212+ C667 E6 FB                                and     ShipNotHostile
 213+ C669 32 4F C4                             ld      (ShipNewBitsAddr),a
 214+ C66C C9                                   ret
 215+ C66D
 216+ C66D                                      ; --------------------------------------------------------------
 217+ C66D              ; Sets visibile and not a dot
 218+ C66D 3A 94 C0     UnivVisibleNonDot:      ld      a,(UBnkaiatkecm)                ;  disable ship AI hostily and ECM
 219+ C670 F6 40                                or      ShipIsVisible
 220+ C672 E6 F7                                and     ShipIsNotDot
 221+ C674 32 94 C0                             ld      (UBnkaiatkecm),a                ;  .
 222+ C677 C9                                   ret
 223+ C678              ; --------------------------------------------------------------
 224+ C678              ; Sets visibile and  a dot
 225+ C678 3A 94 C0     UnivVisibleDot:         ld      a,(UBnkaiatkecm)                ;  disable ship AI hostily and ECM
 226+ C67B F6 48                                or      ShipIsVisible | ShipIsDot
 227+ C67D 32 94 C0                             ld      (UBnkaiatkecm),a                ;  .
 228+ C680 C9                                   ret
 229+ C681              ; --------------------------------------------------------------
 230+ C681              ; Sets invisibile
 231+ C681              UnivInvisible:          ClearMemBitN  UBnkaiatkecm  , ShipIsVisibleBitNbr ; Assume its hidden
 231+ C681 21 94 C0    >                        ld      hl,UBnkaiatkecm
 231+ C684 CB B6       >                        res     ShipIsVisibleBitNbr,(hl)
 232+ C686 C9                                   ret
 233+ C687              ; --------------------------------------------------------------
 234+ C687 21 00 C0     ResetUBnkData:          ld      hl,StartOfUniv
 235+ C68A 11 5B 06                             ld      de,UBnk_Data_len
 236+ C68D AF                                   xor     a
 237+ C68E CD 92 6A                             call    memfill_dma
 238+ C691 C9                                   ret
 239+ C692              ; --------------------------------------------------------------
 240+ C692 21 20 C0     ResetUbnkPosition:      ld      hl,UBnKxlo
 241+ C695 06 09                                ld      b, 3*3
 242+ C697 AF                                   xor     a
 243+ C698 77           .zeroLoop:              ld      (hl),a
 244+ C699 23                                   inc     hl
 245+ C69A 10 FC                                djnz    .zeroLoop
 246+ C69C C9                                   ret
 247+ C69D
 248+ C69D              ;-- This takes an Axis and subtracts 1, handles leading sign and boundary of 0 going negative
 249+ C69D              JumpOffSet:             MACRO   Axis
 250+ C69D ~                                    ld      hl,(Axis)
 251+ C69D ~                                    ld      a,h
 252+ C69D ~                                    and     SignOnly8Bit
 253+ C69D ~                                    jr      nz,.NegativeAxis
 254+ C69D ~            .PositiveAxis:          dec     l
 255+ C69D ~                                    jp      m,.MovingNegative
 256+ C69D ~                                    jp      .Done
 257+ C69D ~            .NegativeAxis:          inc     l                               ; negative means increment the z
 258+ C69D ~                                    jp      .Done
 259+ C69D ~            .MovingNegative:        ld      hl,$8001                        ; -1
 260+ C69D ~            .Done                   ld      (Axis),hl
 261+ C69D                                      ENDM
 262+ C69D
 263+ C69D
 264+ C69D              WarpOffset:             JumpOffSet  UBnKzhi                     ; we will simplify on just moving Z
 264+ C69D 2A 27 C0    >                        ld      hl,(UBnKzhi)
 264+ C6A0 7C          >                        ld      a,h
 264+ C6A1 E6 80       >                        and     SignOnly8Bit
 264+ C6A3 20 07       >                        jr      nz,.NegativeAxis
 264+ C6A5 2D          >.PositiveAxis:          dec     l
 264+ C6A6 FA B0 C6    >                        jp      m,.MovingNegative
 264+ C6A9 C3 B3 C6    >                        jp      .Done
 264+ C6AC 2C          >.NegativeAxis:          inc     l                               ; negative means increment the z
 264+ C6AD C3 B3 C6    >                        jp      .Done
 264+ C6B0 21 01 80    >.MovingNegative:        ld      hl,$8001                        ; -1
 264+ C6B3 22 27 C0    >.Done                   ld      (UBnKzhi),hl
 265+ C6B6 C9                                   ret
 266+ C6B7
 267+ C6B7 44           WarpUnivByHL:           ld      b,h
 268+ C6B8 4D                                   ld      c,l
 269+ C6B9 26 00                                ld      h,0
 270+ C6BB ED 5B 27 C0                          ld      de,(UBnKzhi)
 271+ C6BF 3A 26 C0                             ld      a,(UBnKzlo)
 272+ C6C2 6F                                   ld      l,a
 273+ C6C3                                      MMUSelectMathsBankedFns
 273+ C6C3 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 273+ C6C7 CD 10 01       call  SubBCHfromDELsigned
 274+ C6CA ED 53 27 C0                          ld      (UBnKzhi),de
 275+ C6CE 7D                                   ld      a,l
 276+ C6CF 32 26 C0                             ld      (UBnKzlo),a
 277+ C6D2 C9                                   ret
 278+ C6D3              ; --------------------------------------------------------------
 279+ C6D3              ; This sets the position of the current ship if its a player launched missile
 280+ C6D3 CD EE C7     UnivSetPlayerMissile:   call    InitialisePlayerMissileOrientation  ; Copy in Player  facing
 281+ C6D6 CD 92 C6                             call    ResetUbnkPosition               ; home position
 282+ C6D9 3E 05                                ld      a,MissileDropHeight             ; the missile launches from underneath
 283+ C6DB 32 23 C0                             ld      (UBnKylo),a                     ; so its -ve drop height
 284+ C6DE 3E 80                                ld      a,$80                           ;
 285+ C6E0 32 25 C0                             ld      (UBnKysgn),a                    ;
 286+ C6E3 3E 03                                ld      a,3                             ; set accelleration
 287+ C6E5 32 87 C0                             ld      (UBnKAccel),a                   ;
 288+ C6E8                                      ZeroA
 288+ C6E8 AF          >                        xor a
 289+ C6E9 32 88 C0                             ld      (UBnKRotXCounter),a
 290+ C6EC 32 89 C0                             ld      (UBnKRotZCounter),a
 291+ C6EF 3E 03                                ld      a,3                             ; these are max roll and pitch rates for later
 292+ C6F1 32 8A C0                             ld      (UBnKRAT),a
 293+ C6F4 3C                                   inc     a
 294+ C6F5 32 8B C0                             ld      (UBnKRAT2),a
 295+ C6F8 3E 16                                ld      a,22
 296+ C6FA 32 8D C0                             ld      (UBnKCNT2),a
 297+ C6FD                                      ZeroUnivAccelleration
 297+ C6FD AF          >                        xor     a
 297+ C6FE 32 87 C0    >                        ld      (UBnKAccel),a
 298+ C701                                      ZeroUnivSpeed
 298+ C701 3E 00       >                        ld      a,0
 298+ C703 32 86 C0    >                        ld      (UBnKSpeed),a
 299+ C706                                      ;MaxUnivSpeed                            ; and immediatley full speed (for now at least) TODO
 300+ C706                                      SetMemFalse UBnKMissleHitToProcess
 300+ C706 3E FF       >                        ld      a,$FF
 300+ C708 32 45 C0    >                        ld      (UBnKMissleHitToProcess),a
 301+ C70B CD 64 C6                             call    ClearShipHostile                ; its a player missile
 302+ C70E C9                                   ret
 303+ C70F
 304+ C70F              ; --------------------------------------------------------------
 305+ C70F              ; update ship speed and pitch based on adjustments from AI Tactics
 306+ C70F 3A 87 C0     UpdateSpeedAndPitch:    ld      a,(UBnKAccel)                   ; only apply non zero accelleration
 307+ C712                                      JumpIfAIsZero .SkipAccelleration
 307+ C712 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 307+ C713 CA 31 C7    >                        jp	    z, .SkipAccelleration
 308+ C716 47                                   ld      b,a                             ; b = accelleration in 2's c
 309+ C717 3A 86 C0                             ld      a,(UBnKSpeed)                   ; a = speed + accelleration
 310+ C71A                                      ClearCarryFlag
 310+ C71A B7          >                        or a
 311+ C71B 88                                   adc     a,b
 312+ C71C                                      JumpIfPositive  .DoneAccelleration      ; if speed < 0
 312+ C71C F2 20 C7    >                        jp		p, .DoneAccelleration
 313+ C71F              .SpeedNegative:         ZeroA                                   ;    then speed = 0
 313+ C71F AF          >                        xor a
 314+ C720 47           .DoneAccelleration:     ld      b,a                             ; if speed > speed limit
 315+ C721 3A 47 C4                             ld      a,(SpeedAddr)                   ;    speed = limit
 316+ C724                                      JumpIfAGTENusng b, .SpeedInLimits       ; .
 316+ C724 B8          >                        cp     b
 316+ C725 D2 29 C7    >                        jp		nc,.SpeedInLimits
 317+ C728 47                                   ld      b,a                             ; .
 318+ C729 78           .SpeedInLimits:         ld      a,b                             ; .
 319+ C72A 32 86 C0                             ld      (UBnKSpeed),a                   ; .
 320+ C72D                                      ZeroA                                   ; acclleration = 0
 320+ C72D AF          >                        xor a
 321+ C72E 32 87 C0                             ld      (UBnKAccel),a                   ; for next AI update
 322+ C731              .SkipAccelleration:     ; handle roll and pitch rates
 323+ C731 C9                                   ret
 324+ C732
 325+ C732
 326+ C732 CD 6B C7     UnivSetDemoPostion:     call    UnivSetSpawnPosition
 327+ C735 3E 81                                ld      a,%10000001                     ; AI Enabled has 1 missile
 328+ C737 32 94 C0                             ld      (UBnkaiatkecm),a                ; set hostinle, no AI, has ECM
 329+ C73A 32 4F C4                             ld      (ShipNewBitsAddr),a             ; initialise new bits logic
 330+ C73D 3E 00                                ld      a,0
 331+ C73F 32 89 C0                             ld      (UBnKRotZCounter),a             ; no pitch
 332+ C742 32 88 C0                             ld      (UBnKRotXCounter),a             ; set roll to maxi on station
 333+ C745                                      ZeroA
 333+ C745 AF          >                        xor a
 334+ C746 32 22 C0                             ld      (UBnKxsgn),a
 335+ C749 32 25 C0                             ld      (UBnKysgn),a
 336+ C74C 32 28 C0                             ld      (UBnKzsgn),a
 337+ C74F 21 00 00                             ld      hl,0
 338+ C752 22 20 C0                             ld      (UBnKxlo),hl
 339+ C755 22 23 C0                             ld      (UBnKylo),hl
 340+ C758 3A 4E C4                             ld      a,(ShipTypeAddr)
 341+ C75B 21 B0 05                             ld      hl,$05B0                            ; so its a negative distance behind
 342+ C75E                                      JumpIfANENusng ShipTypeStation, .SkipFurther
 342+ C75E FE 02       >                        cp     ShipTypeStation
 342+ C760 C2 67 C7    >                        jp      nz,.SkipFurther
 343+ C763 3E 05                                ld      a,5
 344+ C765 84                                   add     h
 345+ C766 67                                   ld      h,a
 346+ C767 22 26 C0     .SkipFurther            ld      (UBnKzlo),hl
 347+ C76A C9                                   ret
 348+ C76B                  DISPLAY "Tracing 1", $
 349+ C76B              ; --------------------------------------------------------------
 350+ C76B              ; This sets the position of the current ship randomly, called after spawing
 351+ C76B              ; Spawns in withink 16 bit range so 24 bit friendly
 352+ C76B CD CB C7     UnivSetSpawnPosition:   call    InitialiseOrientation
 353+ C76E                                      RandomUnivPitchAndRoll
 353+ C76E CD 19 70    >                        call    doRandom
 353+ C771 F6 6F       >                        or      %01101111
 353+ C773 32 88 C0    >                        ld      (UBnKRotXCounter),a
 353+ C776 CD 19 70    >                        call    doRandom
 353+ C779 F6 6F       >                        or      %01101111
 353+ C77B 32 89 C0    >                        ld      (UBnKRotZCounter),a
 354+ C77E CD 19 70                             call    doRandom                        ; set x lo and y lo to random
 355+ C781 32 20 C0     .setXlo:                ld      (UBnKxlo),a
 356+ C784 32 23 C0     .setYlo:                ld      (UBnKylo),a
 357+ C787 0F           .setXsign:              rrca                                    ; rotate by 1 bit right
 358+ C788 47                                   ld      b,a
 359+ C789 E6 80                                and     SignOnly8Bit
 360+ C78B 32 22 C0                             ld      (UBnKxsgn),a
 361+ C78E 78           .setYSign:              ld      a,b                             ; get random back again
 362+ C78F 0F                                   rrca                                    ; rotate by 1 bit right
 363+ C790 47                                   ld      b,a
 364+ C791 E6 80                                and     SignOnly8Bit                    ; and set y sign
 365+ C793 32 25 C0                             ld      (UBnKysgn),a
 366+ C796 CB 08        .setYHigh:              rrc     b                               ; as value is in b rotate again
 367+ C798 78                                   ld      a,b                             ;
 368+ C799 E6 1F                                and     31                              ; set y hi to random 0 to 31
 369+ C79B 32 24 C0                             ld      (UBnKyhi),a                     ;
 370+ C79E CB 08        .setXHigh:              rrc     b                               ; as value is in b rotate again
 371+ C7A0 78                                   ld      a,b
 372+ C7A1 E6 1F                                and     31                              ; set x hi to random 0 to 31
 373+ C7A3 4F                                   ld      c,a                             ; save shifted into c as well
 374+ C7A4 32 21 C0                             ld      (UBnKxhi),a
 375+ C7A7 3E 50        .setZHigh:              ld      a,80                            ; set z hi to 80 - xhi - yhi - carry
 376+ C7A9 98                                   sbc     b
 377+ C7AA 99                                   sbc     c
 378+ C7AB 32 27 C0                             ld      (UBnKzhi),a
 379+ C7AE 3A 4E C4     .CheckIfBodyOrJunk:     ld      a,(ShipTypeAddr)
 380+ C7B1                                      ReturnIfAEqNusng ShipTypeJunk
 380+ C7B1 FE 03       >                        cp      ShipTypeJunk
 380+ C7B3 C8          >                        ret     z
 381+ C7B4                                      ReturnIfAEqNusng ShipTypeScoopable
 381+ C7B4 FE 04       >                        cp      ShipTypeScoopable
 381+ C7B6 C8          >                        ret     z
 382+ C7B7 78                                   ld      a,b                             ; its not junk to set z sign
 383+ C7B8 0F                                   rrca                                    ; as it can jump in
 384+ C7B9 E6 80                                and     SignOnly8Bit
 385+ C7BB 32 28 C0                             ld      (UBnKzsgn),a
 386+ C7BE C9                                   ret
 387+ C7BF                  ;Input: BC = Dividend, DE = Divisor, HL = 0
 388+ C7BF              ;Output: BC = Quotient, HL = Remainder
 389+ C7BF
 390+ C7BF              ; Initialiase data, iyh must equal slot number
 391+ C7BF              ;                   iyl must be ship type
 392+ C7BF              ;                   a  = current bank number
 393+ C7BF 01 62 00     UnivInitRuntime:        ld      bc,UBnKRuntimeSize
 394+ C7C2 21 40 C0                             ld      hl,UBnKStartOfRuntimeData
 395+ C7C5                                      ZeroA
 395+ C7C5 AF          >                        xor a
 396+ C7C6 77           .InitLoop:              ld      (hl),a
 397+ C7C7 23                                   inc     hl
 398+ C7C8 10 FC                                djnz    .InitLoop
 399+ C7CA C9                                   ret
 400+ C7CB                  DISPLAY "Tracing 2", $
 401+ C7CB
 402+ C7CB                                      include "../../Universe/Ships/InitialiseOrientation.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/InitialiseOrientation.asm
   1++C7CB              ;  sidev = (1,  0,  0)  sidev = (&6000, 0, 0)
   2++C7CB              ;  roofv = (0,  1,  0)  roofv = (0, &6000, 0)
   3++C7CB              ;  nosev = (0,  0, -1)  nosev = (0, 0, &E000)   E000 = SignBit[96]
   4++C7CB              InitialiseOrientation:
   5++C7CB 21 00 00     ZI1:                    ld      hl, 0
   6++C7CE 22 2C C0                             ld      (UBnkrotmatSidevY),hl                ; set the zeroes
   7++C7D1 22 2E C0                             ld      (UBnkrotmatSidevZ),hl                ; set the zeroes
   8++C7D4 22 30 C0                             ld      (UBnkrotmatRoofvX),hl                ; set the zeroes
   9++C7D7 22 34 C0                             ld      (UBnkrotmatRoofvZ),hl                ; set the zeroes
  10++C7DA 22 36 C0                             ld      (UBnkrotmatNosevX),hl                ; set the zeroes
  11++C7DD 22 38 C0                             ld      (UBnkrotmatNosevY),hl                ; set the zeroes
  12++C7E0              ; Optimised as already have 0 in l
  13++C7E0 26 60                                ld      h, $60	             				; 96 in hi byte
  14++C7E2                                      ;ld      hl,1
  15++C7E2 22 2A C0                             ld      (UBnkrotmatSidevX),hl
  16++C7E5 22 32 C0                             ld      (UBnkrotmatRoofvY),hl
  17++C7E8              ; Optimised as already have 0 in l
  18++C7E8 26 E0                                ld      h, $E0					            ; -96 in hi byte which is +96 with hl bit 7 set
  19++C7EA 22 3A C0                             ld      (UBnkrotmatNosevZ),hl
  20++C7ED C9                                   ret
  21++C7EE
  22++C7EE              InitialisePlayerMissileOrientation:
  23++C7EE CD CB C7                             call    InitialiseOrientation
  24++C7F1 21 00 60                             ld      hl,$6000
  25++C7F4 22 3A C0                             ld      (UBnkrotmatNosevZ),hl           ; mius
  26++C7F7 C9                                   ret
  27++C7F8
  28++C7F8
  29++C7F8              ;  sidev = (1,  0,  0)  sidev = (&6000, 0, 0)
  30++C7F8              ;  roofv = (0,  1,  0)  roofv = (0, &6000, 0)
  31++C7F8              ;  nosev = (-0,  -0, 1) nosev = (0, 0, &6000)
  32++C7F8 CD CB C7     LaunchedOrientation:    call    InitialiseOrientation
  33++C7FB                                      FlipSignMem UBnkrotmatNosevX+1;  as its 0 flipping will make no difference
  33++C7FB 3A 37 C0    >                        ld  a,(UBnkrotmatNosevX+1)
  33++C7FE EE 80       >                        xor SignOnly8Bit
  33++C800 32 37 C0    >                        ld  (UBnkrotmatNosevX+1),a
  34++C803                                      FlipSignMem UBnkrotmatNosevY+1;  as its 0 flipping will make no difference
  34++C803 3A 39 C0    >                        ld  a,(UBnkrotmatNosevY+1)
  34++C806 EE 80       >                        xor SignOnly8Bit
  34++C808 32 39 C0    >                        ld  (UBnkrotmatNosevY+1),a
  35++C80B                                      FlipSignMem UBnkrotmatNosevZ+1
  35++C80B 3A 3B C0    >                        ld  a,(UBnkrotmatNosevZ+1)
  35++C80E EE 80       >                        xor SignOnly8Bit
  35++C810 32 3B C0    >                        ld  (UBnkrotmatNosevZ+1),a
  36++C813 C9                                   ret
  37++C814
# file closed: ../../Tests/Vectors/../../Universe/Ships/InitialiseOrientation.asm
 403+ C814
 404+ C814              ;--------------------------------------------------------------------------------------------------------
 405+ C814                                      INCLUDE "../../ModelRender/CLIP-LL145.asm"
# file opened: ../../Tests/Vectors/../../ModelRender/CLIP-LL145.asm
   1++C814              ;--------------------------------------------------------------------------------------------------------------------
   2++C814
   3++C814 00           clipDx                  DB      0           ; also XX12+2
   4++C815 00           clipDxHigh              DB      0           ; also XX12+3
   5++C816 00           clipDxHighNonABS        DB      0           ; also XX12+3
   6++C817 00           clipDy                  DB      0           ; also XX12+4
   7++C818 00           clipDyHigh              DB      0           ; also XX12+5
   8++C819 00           clipGradient            DB      0
   9++C81A 00           clipDxySign             DB      0
  10++C81B              varX12p3                equ     clipDxySign
  11++C81B 00           clipXGTY                DB      0
  12++C81C 00           clipFlags               DB      0
  13++C81D 00           SWAP                    DB      0
  14++C81E 00 00        varYX                   DW      0
  15++C820              ;varRegX                 DB      0
  16++C820              ;varXX12p2               DB      0
  17++C820 00           clipXX13                 DB      0
  18++C821 00           Gradient                DB      0
  19++C822              ; for start and end y. bit7 of lower determines its not been setup yet
  20++C822
  21++C822              ;--------------------------------------------------------------------------------------
  22++C822                      IFNDEF       CLIPVersion3
  23++C822 ED 4B E9 C0  ClipLine:               ld      bc,(UbnkPreClipY1)          ; bc - XX15(2,3) Y1
  24++C826 DD 2A ED C0                          ld      ix,(UbnkPreClipY2)          ; ix - XX12(0,1) Y2
  25++C82A 2A E7 C0                             ld      hl,(UbnkPreClipX1)          ; hl - XX15(0,1) X1
  26++C82D ED 5B EB C0                          ld      de,(UbnkPreClipX2)          ; de - XX15(4,5) X2
  27++C831 AF                                   xor     a
  28++C832 32 1D C8                             ld      (SWAP),a                    ; SWAP = 0
  29++C835 7A                                   ld      a,d                         ; A = X2Hi
  30++C836 FD 26 BF     .LL147:                 ld      iyh,$BF                     ; we need to be 191 as its 128 + another bit set from 0 to 6, we are using iyh as regX (128 will actually do)
  31++C839 DD B4                                or      ixh                         ; if (X2Hi L-OR Y2 Hi <> 0) goto LL107             -- X2Y2 off screen
  32++C83B 20 0A                                jr      nz, .LL107
  33++C83D DD 7D                                ld      a,ixl
  34++C83F ED 27 80                             test    $80                         ; if screen hight < y2 lo, i.e y2 lo >127 goto LL107,
  35++C842 20 03                                jr      nz,.LL107
  36++C844 FD 26 00                             ld      iyh, 0                      ; else iyh = regX = 0                                                                        -- X2Y2 on screen
  37++C847              ; XX13 = regX (i.e. iyh)      ( if XX13 = XX13 is 191 if (x2, y2) is off-screen else 0) we bin XX13 as not needed
  38++C847              ; so XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen,  XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lo is off the bottom of the screen
  39++C847 FD 7C        .LL107                  ld      a,iyh
  40++C849 32 20 C8                             ld      (clipXX13),a                ; debug copy iyh to xx13
  41++C84C 7C                                   ld      a,h                         ; If (X1 hi L-OR Y1) hi  goto LL83                   -- X1Y1 off screen and maybe X2Y2
  42++C84D B0                                   or      b                           ;
  43++C84E 20 27                                jr      nz,.LL83                    ;
  44++C850 79                                   ld      a,c                         ; or (y1 lo > bottom of screen)
  45++C851 ED 27 80                             test    $80                         ; i.e  screen height < y1)
  46++C854 20 21                                jr      nz,.LL83
  47++C856              ; If we get here, (x1, y1) is on-screen
  48++C856 FD 7C                                ld      a,iyh                       ; iyh = xx13 at this point if  XX13 <> 0 goto LL108                                                        -- X1Y1 on screen, if we flagged X2Y2 off screen goto LL108
  49++C858 FE 00                                cp      0
  50++C85A 20 15                                jr      nz, .LL108
  51++C85C              ; Finished clipping exit point ----------------------------------------------------------------------------------------
  52++C85C 79           .ClipDone:              ld      a,c                         ; LL146 (Clip Done)               Y1 = y1 lo, x2 = x2 lo, x1 = x1 lo y1 = y1 lo                                   -- Nothing off screen
  53++C85D 32 E8 C0                             ld      (UBnkNewY1),a
  54++C860 DD 7D                                ld      a,ixl
  55++C862 32 EA C0                             ld      (UBnkNewY2),a
  56++C865 7D                                   ld      a,l
  57++C866 32 E7 C0                             ld      (UBnkNewX1),a
  58++C869 7B                                   ld      a,e
  59++C86A 32 E9 C0                             ld      (UBnkNewX2),a
  60++C86D                                      ClearCarryFlag                      ; carry is clear so valid to plot is in XX15(0to3)
  60++C86D B7          >                        or a
  61++C86E C9                                   ret                                 ; 2nd pro different, it swops based on swop flag around here.
  62++C86F              ; Finished out of bounds exit point -----------------------------------------------------------------------------------
  63++C86F              .PointsOutofBounds:     SetCarryFlag                        ; LL109 (ClipFailed) carry flag set as not visible
  63++C86F 37          >                        scf
  64++C870 C9                                   ret
  65++C871 FD 7C        .LL108:                 ld      a,iyh
  66++C873 B7                                   or      a
  67++C874 1F                                   rra
  68++C875 FD 67                                ld      iyh,a                       ; (X2Y2 Off Screen)         XX13 = 95 (i.e. divide it by 2)                                                 -- X1Y1 on screen X2Y2 off screen
  69++C877 FD 7C        .LL83:                  ld      a,iyh                       ; (Line On screen Test)      if XX13 < 128 then only 1 point is on screen so goto LL115                      -- We only need to deal with X2Y2
  70++C879 ED 27 80                             test    $80                         ;
  71++C87C 28 28                                jr      z, .LL115                   ;
  72++C87E              ;                       Check for X1 and X2 negative
  73++C87E 7C                                   ld      a,h                         ; If both x1_hi and x2_hi have bit 7 set, jump to LL109  to return from the subroutine with the C flag set, as the entire line is above the top of the screen
  74++C87F A2                                   and     d
  75++C880                                      JumpIfNegative  .PointsOutofBounds
  75++C880 FA 6F C8    >                        jp		m, .PointsOutofBounds
  76++C883              ;                       Check for Y1 and Y2 negative
  77++C883 78                                   ld      a,b                         ; If both y1_hi and y2_hi have bit 7 set, jump to LL109  to return from the subroutine with the C flag set, as the entire line is above the top of the screen
  78++C884 DD A4                                and     ixh
  79++C886                                      JumpIfNegative  .PointsOutofBounds
  79++C886 FA 6F C8    >                        jp		m, .PointsOutofBounds
  80++C889              ;                       Check for X1 and X2 both > 255
  81++C889 7C                                   ld      a,h                         ; If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set, jump to LL109 to return from the subroutine with the C  flag set, as the line doesn't fit on-screen
  82++C88A 3D                                   dec     a
  83++C88B FD 6F                                ld      iyl,a                       ; using iyl as XX12+2 var
  84++C88D 7A                                   ld      a,d                         ; a = x2 hi
  85++C88E 3D                                   dec     a
  86++C88F FD B5                                or      iyl                         ; (x2 hi -1 ) or (x1 hi -1)
  87++C891                                      JumpIfPositive .PointsOutofBounds   ; if both x1 and x2hi were > 0 then subtracting 1 would result in 0..254 so either being negative means it was 0 before
  87++C891 F2 6F C8    >                        jp		p, .PointsOutofBounds
  88++C894              ; by here we have eliminated -ve Y1 bounds so can just test for positive high and bit 7 of lo
  89++C894 DD 7C                                ld      a,ixh
  90++C896 3D                                   dec     a
  91++C897 FD 6F                                ld      iyl,a
  92++C899 78                                   ld      a,b
  93++C89A 3D                                   dec     a
  94++C89B FD B5                                or      iyl
  95++C89D                                      JumpIfPositive .PointsOutofBounds   ; if both x1 and x2hi were > 0 then subtracting 1 would result in 0..254 so either being negative means it was 0 before
  95++C89D F2 6F C8    >                        jp		p, .PointsOutofBounds
  96++C8A0 79                                   ld      a,c
  97++C8A1 DD A5                                and     ixl
  98++C8A3                                      JumpIfNegative .PointsOutofBounds   ; really if both are > 127
  98++C8A3 FA 6F C8    >                        jp		m, .PointsOutofBounds
  99++C8A6              ; Clip line: calulate the line's gradient
 100++C8A6              ; here as an optimisation we make sure X1 is always < X2  later on
 101++C8A6              .LL115:                 ClearCarryFlag
 101++C8A6 B7          >                        or a
 102++C8A7 E5 D5        .CalcDX:                push    hl,,de
 103++C8A9 EB                                   ex      hl,de                       ; so hl is x2 and de = x1
 104++C8AA ED 52                                sbc     hl,de
 105++C8AC 22 14 C8                             ld      (clipDx),hl
 106++C8AF 7C                                   ld      a,h
 107++C8B0 32 16 C8                             ld      (clipDxHighNonABS),a
 108++C8B3              .CalcDy:                ClearCarryFlag
 108++C8B3 B7          >                        or a
 109++C8B4 DD E5 E1                             ld      hl,ix
 110++C8B7 ED 42                                sbc     hl,bc
 111++C8B9 54 5D                                ld      de,hl           ;;OPTIMISATION 6/11/21
 112++C8BB 22 17 C8                             ld      (clipDy),hl     ;OPTIMISATION 6/11/21 commented out
 113++C8BE 7C           .CalcQuadrant:          ld      a,h
 114++C8BF 32 18 C8                             ld      (clipDyHigh),a              ; so A = sign of deltay in effect
 115++C8C2              ; So we now have delta_x in XX12(3 2), delta_y in XX12(5 4)  where the delta is (x1, y1) - (x2, y2))
 116++C8C2 21 15 C8                             ld      hl,clipDxHigh
 117++C8C5 AE                                   xor     (hl)                        ; now a = sign dx xor sign dy
 118++C8C6 32 18 6C                             ld      (varS),a                    ; DEBGU putting it in var S too for now
 119++C8C9 32 1A C8                             ld      (clipDxySign),a
 120++C8CC 3A 18 C8     .AbsDy:                 ld      a,(clipDyHigh)
 121++C8CF ED 27 80                             test    $80
 122++C8D2 28 0E                                jr      z,.LL110                    ; If delta_y_hi is positive, jump down to LL110 to skip the following
 123++C8D4 ED 5B 17 C8                          ld      de,(clipDy)                 ;OPTIMISATION 6/11/21 commented out
 124++C8D8                                      macronegate16de                     ; Otherwise flip the sign of delta_y to make it  positive, starting with the low bytes
 124++C8D8 AF          >					xor 	a
 124++C8D9 93          >                    sub 	e
 124++C8DA 5F          >                    ld 		e,a
 124++C8DB 9F          >                    sbc 	a,a
 124++C8DC 92          >                    sub 	d
 124++C8DD 57          >                    ld 		d,a
 125++C8DE ED 53 17 C8                          ld      (clipDy),de                 ;OPTIMISATION 6/11/21 commented out
 126++C8E2 2A 14 C8     .LL110:                 ld      hl,(clipDx)
 127++C8E5 3A 15 C8                             ld      a,(clipDxHigh)
 128++C8E8 ED 27 80                             test    $80                         ; is it a negative X
 129++C8EB 28 06                                jr      z,.LL111                    ; If delta_x_hi is positive, jump down to LL110 to skip the following
 130++C8ED                                      ;ld      hl,(clipDx)                 ;OPTIMISATION 6/11/21 commented out
 131++C8ED                                      macronegate16hl                     ; Otherwise flip the sign of delta_y to make it  positive, starting with the low bytes
 131++C8ED AF          >					xor 	a
 131++C8EE 95          >					sub 	l
 131++C8EF 6F          >					ld 		l,a
 131++C8F0 9F          >					sbc 	a,a
 131++C8F1 94          >					sub 	h
 131++C8F2 67          >					ld 		h,a
 132++C8F3              .LL111:
 133++C8F3 7C           .ScaleLoop:             ld      a,h                         ; At this point DX and DY are ABS values
 134++C8F4 B2                                   or      d
 135++C8F5 28 0A                                jr      z,.CalculateDelta
 136++C8F7                                      ShiftDERight1
 136++C8F7 CB 3A       >			   srl d
 136++C8F9 CB 1B       >			   rr  e
 137++C8FB                                      ShiftHLRight1
 137++C8FB CB 3C       >			   srl h
 137++C8FD CB 1D       >			   rr  l
 138++C8FF 18 F2                                jr      .ScaleLoop                  ; scaled down Dx and Dy to 8 bit, Dy may have been negative
 139++C901              .CalculateDelta:
 140++C901              ; By now, the high bytes of both |delta_x| and |delta_y| are zero We know that h and d are both = 0 as that's what we tested with a BEQ
 141++C901 AF           .LL113:                 xor     a
 142++C902 32 32 6C                             ld      (varT),a                    ; t = 0
 143++C905 7D                                   ld      a,l                         ; If delta_x_lo < delta_y_lo, so our line is more vertical than horizontal, jump to LL114
 144++C906                                      JumpIfALTNusng  e, .LL114           ;
 144++C906 BB          >                        cp      e
 144++C907 DA 17 C9    >                        jp		c, .LL114
 145++C90A              ; Here Dx >= Dy sp calculate Delta Y / delta X
 146++C90A 32 16 6C     .DxGTEDy:               ld      (varQ),a                    ; Set Q = delta_x_lo
 147++C90D 57                                   ld      d,a                         ; d = also Q for calc
 148++C90E 7B                                   ld      a,e                         ; Set A = delta_y_lo
 149++C90F CD F5 75                             call    AEquAmul256DivD; LL28Amul256DivD             ; Call LL28 to calculate:  R (actually a reg) = 256 * A / Q   = 256 * delta_y_lo / delta_x_lo
 150++C912 32 17 6C                             ld      (varR),a                    ;
 151++C915 18 10                                jr      .LL116                      ; Jump to LL116, as we now have the line's gradient in R
 152++C917              ; Here Delta Y > Delta X so calulate delta X / delta Y
 153++C917 7B           .LL114:                 ld      a,e                         ; Set Q = delta_y_lo
 154++C918 57                                   ld      d,a
 155++C919 32 16 6C                             ld      (varQ),a
 156++C91C 7D                                   ld      a,l                         ; Set A = delta_x_lo
 157++C91D CD F5 75                             call    AEquAmul256DivD; LL28Amul256DivD             ; Call LL28 to calculate: R = 256 * A / Q  = 256 * delta_x_lo / delta_y_lo
 158++C920 32 17 6C                             ld      (varR),a                    ;
 159++C923 21 32 6C                             ld      hl,varT                     ; T was set to 0 above, so this sets T = &FF
 160++C926 35                                   dec     (hl)
 161++C927 D1           .LL116:                 pop     de                          ; get back X2
 162++C928 E1                                   pop     hl                          ; get back X1 into hl,
 163++C929 3A 17 6C                             ld      a,(varR)                    ; Store the gradient in XX12+2 this can be optimised later
 164++C92C 32 19 C8                             ld      (clipGradient),a
 165++C92F FD 6F                                ld      iyl,a
 166++C931 3A 18 6C                             ld      a,(varS)
 167++C934 32 1A C8                             ld      (clipDxySign),a             ;  Store the type of slope in XX12+3, bit 7 clear means ?Not needed as clipDxySign is used for varS earlier?
 168++C937                                                                          ; top left to bottom right, bit 7 set means top right to bottom left **CODE IS WRONG HERE A TEST IS BL to TR
 169++C937 FD 7C                                ld      a,iyh                       ; iyh was XX13 from earlier
 170++C939 FE 00                                cp      0                           ; If XX13 = 0, skip the following instruction
 171++C93B 28 05                                jr      z,.LL138                    ;
 172++C93D ED 27 80                             test    $80                         ; If XX13 is positive, it must be 95. This means (x1, y1) is on-screen but (x2, y2) isn't, so we jump to LLX117 to swap the (x1, y1) and (x2, y2)
 173++C940 28 13                                jr      z,.LLX117                   ; coordinates around before doing the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
 174++C942              ; If we get here, XX13 = 0 or 191, so (x1, y1) is off-screen and needs clipping
 175++C942 CD 69 C9     .LL138                  call    ClipPointHLBC               ; Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 176++C945 FD 7C                                ld      a,iyh                       ; If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to LL124 to return with a successfully clipped line
 177++C947 ED 27 80                             test    $80
 178++C94A 28 1A                                jr      z,.LL124
 179++C94C              ; If we get here, XX13 = 191 (both coordinates are off-screen)
 180++C94C 7C           .LL117:                 ld      a,h                         ; If either of x1_hi or y1_hi are non-zero, jump to
 181++C94D B0                                   or      b                           ; LL137 to return from the subroutine with the C flag
 182++C94E C2 6F C8                             jp      nz, .PointsOutofBounds      ; set, as the line doesn't fit on-screen
 183++C951 B1                                   or      c                           ; if x1 and y1 hi are both zero test bit 8 or Y1 to see if its > 128
 184++C952 FA 6F C8                             jp      m, .PointsOutofBounds       ; set, as the line doesn't fit on-screen
 185++C955              ; If we get here, XX13 = 95 or 191, and in both cases (x2, y2) is off-screen, so we now need to swap the (x1, y1) and (x2, y2) coordinates around before doing
 186++C955              ; the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
 187++C955 EB           .LLX117:                ex      de,hl                       ;  swap X1 and X2
 188++C956 DD E5                                push    ix                          ;  swap Y1 and Y2
 189++C958 C5                                   push    bc
 190++C959 DD E1                                pop     ix
 191++C95B C1                                   pop     bc
 192++C95C CD 69 C9                             call    ClipPointHLBC               ;  Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 193++C95F 3A 1D C8                             ld      a,(SWAP)
 194++C962 3D                                   dec     a
 195++C963 32 1D C8                             ld      (SWAP),a                    ; Set SWAP = &FF to indicate that we just clipped the line at the (x2, y2) end by swapping the coordinates (the DEC does this as we set SWAP to 0 at the start of this subroutine)
 196++C966 C3 5C C8     .LL124:                 jp      .ClipDone                    ; now put points in place
 197++C969              ; Move a point along a line until it is on-screen point is held in HL(X) BC(Y) LL118
 198++C969              ; iyh still holds XX13 iyl still holds gradient
 199++C969 7C           ClipPointHLBC:          ld      a,h                         ; If x1_hi is positive, jump down to LL119 to skip the following
 200++C96A ED 27 80                             test    $80
 201++C96D 28 17                                jr      z,.LL119
 202++C96F 32 18 6C     .X1isNegative:          ld      (varS),a                    ;  Otherwise x1_hi is negative, i.e. off the left of the screen, so set S = x1_hi
 203++C972 E5 D5 C5                             push    hl,,de,,bc
 204++C975 CD EB C9                             call    LL120                       ;  Call LL120 to calculate:   (Y X) = (S x1_lo) * XX12+2      if T = 0   = x1 * gradient
 205++C978                                                                          ;                             (Y X) = (S x1_lo) / XX12+2      if T <> 0  = x1 / gradient
 206++C978                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
 207++C978 C1 D1 E1                             pop    hl,,de,,bc                   ;  get coordinates back
 208++C97B 2A 1E C8                             ld      hl,(varYX)
 209++C97E 09                                   add     hl,bc                       ; y1 = y1 + varYX
 210++C97F 44 4D                                ld      bc,hl
 211++C981 21 00 00                             ld      hl,0                        ; Set x1 = 0
 212++C984 18 1A                                jr      .LL134                      ; in BBC is set x to 0 to force jump, we will just jump
 213++C986 FE 00        .LL119:                 cp      0
 214++C988 28 16                                jr      z,.LL134                    ;  If x1_hi = 0 then jump down to LL134 to skip the following, as the x-coordinate is already on-screen (as 0 <= (x_hi x_lo) <= 255)
 215++C98A 3D                                   dec     a
 216++C98B 32 18 6C                             ld      (varS),a                    ;  Otherwise x1_hi is positive, i.e. x1 >= 256 and off the right side of the screen, so set S = x1_hi - 1
 217++C98E E5 D5 C5                             push    hl,,de,,bc
 218++C991 CD EB C9                             call    LL120                      ;  Call LL120 to calculate: (Y X) = (S x1_lo) * XX12+2      if T = 0  = (x1 - 256) * gradient
 219++C994                                                                          ;                           (Y X) = (S x1_lo) / XX12+2      if T <> 0 = (x1 - 256) / gradient
 220++C994                                                                          ;  with the sign of (Y X) set to the opposite of theline's direction of slope
 221++C994 C1 D1 E1                             pop     hl,,de,,bc
 222++C997 2A 1E C8                             ld      hl,(varYX)
 223++C99A 09                                   add     hl,bc                        ;OPTIMISATION 6/11/21 simplfied post debug
 224++C99B 44 4D                                ld      bc,hl                        ;OPTIMISATION 6/11/21 simplfied post debug
 225++C99D 21 FF 00                             ld      hl,255                      ; Set x1 = 255
 226++C9A0              ; We have moved the point so the x-coordinate is on screen (i.e. in the range 0-255), so now for they-coordinate
 227++C9A0 78           .LL134:                 ld      a,b                         ; If y1_hi is positive, jump down to LL135  to skip the following
 228++C9A1 ED 27 80                             test    $80                         ;
 229++C9A4 28 1A                                jr      z,.LL135                    ;
 230++C9A6 32 18 6C                             ld      (varS),a                    ; Otherwise y1_hi is negative, i.e. off the top of the screen, so set S = y1_hi
 231++C9A9 79                                   ld      a,c                         ; Set R = y1_lo
 232++C9AA 32 17 6C                             ld      (varR),a                    ;
 233++C9AD E5 D5 C5                             push    hl,,de,,bc
 234++C9B0 CD 4C CA                             call    LL123                       ;  Call LL123 to calculate: (Y X) = (S R) / XX12+2      if T = 0  = y1 / gradient
 235++C9B3                                                                          ;                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
 236++C9B3                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
 237++C9B3 C1 D1 E1                             pop     hl,,de,,bc
 238++C9B6 D5                                   push    de
 239++C9B7 EB                                   ex      hl,de                       ; de = x1
 240++C9B8 2A 1E C8                             ld      hl,(varYX)                  ; hl = varYX
 241++C9BB 19                                   add     hl,de                       ; we don't need to swap back as its an add, Set x1 = x1 + (Y X)
 242++C9BC D1                                   pop     de                          ; de = x2 again
 243++C9BD 01 00 00                             ld      bc,0                        ; Set y1 = 0
 244++C9C0 79           .LL135:                 ld      a,c                         ; if bc < 128 then no work to do
 245++C9C1 E6 80                                and     $80
 246++C9C3 B0                                   or      b                           ; here we see if c bit 8 is set or anything in b as we know if its 0 this would mean there is no need to clip
 247++C9C4 C8                                   ret     z
 248++C9C5 E5                                   push    hl
 249++C9C6 60 69                                ld      hl,bc
 250++C9C8 01 80 00                             ld      bc,128
 251++C9CB B7                                   or      a
 252++C9CC ED 42                                sbc     hl,bc                       ; hl =  (S R) = (y1_hi y1_lo) - 128
 253++C9CE 22 17 6C                             ld      (varRS), hl                 ; and now RS (or SR)
 254++C9D1 7C                                   ld      a,h
 255++C9D2 E1                                   pop     hl
 256++C9D3 ED 27 80                             test    $80                         ; If the subtraction underflowed, i.e. if y1 < 192, then y1 is already on-screen, so jump to LL136 to return from the subroutine, as we are done
 257++C9D6 C0                                   ret     nz
 258++C9D7              ; If we get here then y1 >= 192, i.e. off the bottom of the screen
 259++C9D7 E5 D5 C5     .LL139:                 push    hl,,de,,bc
 260++C9DA CD 4C CA                             call    LL123                       ;  Call LL123 to calculate: (Y X) = (S R) / XX12+2      if T = 0  = y1 / gradient
 261++C9DD                                                                          ;                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
 262++C9DD                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
 263++C9DD C1 D1 E1                             pop     hl,,de,,bc
 264++C9E0 D5                                   push    de
 265++C9E1 EB                                   ex      hl,de
 266++C9E2 2A 1E C8                             ld      hl,(varYX)
 267++C9E5 19                                   add     hl,de                       ; we don't need to swap back as its an add, Set x1 = x1 + (Y X)
 268++C9E6 01 7F 00                             ld      bc,127                      ; set bc to 127 bottom of screen
 269++C9E9 D1                                   pop     de
 270++C9EA C9           .LL136:                 ret                                 ;  Return from the subroutine
 271++C9EB                      ENDIF
 272++C9EB
 273++C9EB              ; Calculate the following:   * If T = 0  (more vertical than horizontal), (Y X) = (S x1_lo) * XX12+2
 274++C9EB              ;                            * If T <> 0 (more horizontal than vertical), (Y X) = (S x1_lo) / XX12+2
 275++C9EB              ;                              giving (Y X) the opposite sign to the slope direction in XX12+3.
 276++C9EB              ; Other entry points        LL122                Calculate (Y X) = (S R) * Q and set the sign to the opposite of the top byte on the stack
 277++C9EB 7D           LL120:                  ld      a,l                          ; Set R = x1_lo
 278++C9EC 32 17 6C                             ld      (varR),a
 279++C9EF CD A9 CA                             call    LL129                        ;  Call LL129 to do the following:  Q = XX12+2   = line gradient  A = S EOR XX12+3 = S EOR slope direction (S R) = |S R| So A contains the sign of S * slope direction
 280++C9F2 F5                                   push    af                           ;  Store A on the stack so we can use it later
 281++C9F3 C5                                   push    bc
 282++C9F4 47                                   ld      b,a
 283++C9F5 3A 32 6C                             ld      a,(varT)                     ; instead : (Y X) = (S R ) / Q
 284++C9F8 FE 00                                cp      0
 285++C9FA 78                                   ld      a,b
 286++C9FB C1                                   pop     bc                           ; we can't use af as that would disrupt the flags
 287++C9FC C2 13 CA                             jp      nz, .LL121
 288++C9FF              ; The following calculates:  (Y X) = (S R) * Q using the same shift-and-add algorithm that's documented in MULT1
 289++C9FF 3A 19 C8     .LL122:                  ld      a,(clipGradient)
 290++CA02 32 16 6C                             ld      (varQ),a; optimise
 291++CA05 CD 81 70                             call    HLequSRmulQdiv256
 292++CA08 22 1E C8                             ld      (varYX),hl
 293++CA0B F1                                   pop     af
 294++CA0C ED 27 80                             test    $80
 295++CA0F CA 3F CA                             jp      z,.LL133
 296++CA12 C9                                   ret
 297++CA13 11 FE FF     .LL121:                  ld      de,$FFFE                    ; set XY to &FFFE at start, de holds XY
 298++CA16 2A 17 6C                             ld      hl,(varRS)                  ; hl = RS
 299++CA19 3A 16 6C                             ld      a,(varQ)
 300++CA1C 47                                   ld      b,a                         ; b = q
 301++CA1D              .LL130:                 ShiftHLLeft1                        ; RS *= 2
 301++CA1D CB 25       >			   sla l
 301++CA1F CB 14       >			   rl  h
 302++CA21 7C                                   ld      a,h
 303++CA22 38 04                                jr      c,.LL131                    ; if S overflowed skip Q test and do subtractions
 304++CA24                                      JumpIfALTNusng b, .LL132            ; if S <  Q = 256/gradient skip subtractions
 304++CA24 B8          >                        cp      b
 304++CA25 DA 30 CA    >                        jp		c, .LL132
 305++CA28 3F           .LL131:                 ccf                                 ; compliment carry
 306++CA29 98                                   sbc     a,b                         ; q
 307++CA2A 67                                   ld      h,a                         ; h (s)
 308++CA2B 7D                                   ld      a,l                         ; r
 309++CA2C DE 00                                sbc     a,0                         ; 0 - so in effect SR - Q*256
 310++CA2E 37                                   scf                                 ; set carry for next rolls
 311++CA2F 3F                                   ccf
 312++CA30              .LL132:                 RollDELeft1                         ; Rotate de bits left
 312++CA30 CB 13       >               rl  e
 312++CA32 CB 12       >               rl  d
 313++CA34 38 E7                                jr      c,.LL130                    ;
 314++CA36 ED 53 1E C8                          ld      (varYX),de
 315++CA3A F1                                   pop     af              ; get back sign
 316++CA3B ED 27 80                             test    $80
 317++CA3E C8                                   ret     z               ; if negative then return with value as is reversed sign
 318++CA3F 2A 1E C8     .LL133:                 ld      hl,(varYX)      ; may not actually need this?
 319++CA42                                      NegHL
 319++CA42 AF          >                    xor a
 319++CA43 95          >                    sub l
 319++CA44 6F          >                    ld l,a
 319++CA45 9F          >                    sbc a,a
 319++CA46 94          >                    sub h
 319++CA47 67          >                    ld h,a
 320++CA48 22 1E C8                             ld      (varYX),hl
 321++CA4B C9           .LL128:                 ret
 322++CA4C
 323++CA4C
 324++CA4C
 325++CA4C
 326++CA4C              ; Calculate the following: * If T = 0,  calculate (Y X) = (S R) / XX12+2 (actually SR & XX12+2 /256)
 327++CA4C              ;                          * If T <> 0, calculate (Y X) = (S R) * XX12+2
 328++CA4C              ;                          giving (Y X) the opposite sign to the slope direction in XX12+3.
 329++CA4C              ;
 330++CA4C              ; Other entry points:      LL121                Calculate (Y X) = (S R) / Q and set the sign to the opposite of the top byte on the stack
 331++CA4C              ;                          LL133                Negate (Y X) and return from the subroutine
 332++CA4C              ;                          LL128                Contains an RTS
 333++CA4C CD A9 CA     LL123:                  call    LL129                       ; Call LL129 to do the following: Q = XX12+2   = line gradient  A = S EOR XX12+3 = S EOR slope direction (S R) = |S R| So A contains the sign of S * slope direction
 334++CA4F F5                                   push    af                          ; Store A on the stack so we can use it later
 335++CA50 C5                                   push    bc                          ; If T is non-zero, so it's more horizontal than vertical, jump down to LL121 to calculate this
 336++CA51 47                                   ld      b,a
 337++CA52 3A 32 6C                             ld      a,(varT)                    ; instead : (Y X) = (S R) * Q *** this looks to be the wrong way roudn for Y!!!!
 338++CA55 FE 00                                cp      0
 339++CA57 78                                   ld      a,b
 340++CA58 C1                                   pop     bc
 341++CA59 C2 95 CA                             jp      nz, .LL122
 342++CA5C              ; The following calculates: (Y X) = (S R) / Q using the same shift-and-subtract algorithm that's documented in TIS2, its actually X.Y=R.S*256/Q
 343++CA5C 11 FE FF     .LL121:                 ld      de,$FFFE                    ; set XY to &FFFE at start, de holds XY
 344++CA5F 2A 17 6C                             ld      hl,(varRS)                  ; hl = RS
 345++CA62 3A 16 6C                             ld      a,(varQ)
 346++CA65 47                                   ld      b,a                         ; b = q
 347++CA66              .LL130:                 ShiftHLLeft1                        ; RS *= 2
 347++CA66 CB 25       >			   sla l
 347++CA68 CB 14       >			   rl  h
 348++CA6A 7C                                   ld      a,h
 349++CA6B 38 04                                jr      c,.LL131                    ; if S overflowed skip Q test and do subtractions
 350++CA6D                                      JumpIfALTNusng b, .LL132            ; if S <  Q = 256/gradient skip subtractions
 350++CA6D B8          >                        cp      b
 350++CA6E DA 79 CA    >                        jp		c, .LL132
 351++CA71 3F           .LL131:                 ccf                                 ; compliment carry
 352++CA72 98                                   sbc     a,b                         ; q
 353++CA73 67                                   ld      h,a                         ; h (s)
 354++CA74 7D                                   ld      a,l                         ; r
 355++CA75 DE 00                                sbc     a,0                         ; 0 - so in effect SR - Q*256
 356++CA77 37                                   scf                                 ; set carry for next rolls
 357++CA78 3F                                   ccf
 358++CA79              .LL132:                 RollDELeft1                         ; Rotate de bits left
 358++CA79 CB 13       >               rl  e
 358++CA7B CB 12       >               rl  d
 359++CA7D 38 E7                                jr      c,.LL130                    ;
 360++CA7F ED 53 1E C8                          ld      (varYX),de
 361++CA83 F1                                   pop     af              ; get back sign
 362++CA84 ED 27 80                             test    $80
 363++CA87 C8                                   ret     z               ; if negative then return with value as is reversed sign
 364++CA88 2A 1E C8     .LL133:                 ld      hl,(varYX)      ; may not actually need this?
 365++CA8B                                      NegHL
 365++CA8B AF          >                    xor a
 365++CA8C 95          >                    sub l
 365++CA8D 6F          >                    ld l,a
 365++CA8E 9F          >                    sbc a,a
 365++CA8F 94          >                    sub h
 365++CA90 67          >                    ld h,a
 366++CA91 22 1E C8                             ld      (varYX),hl
 367++CA94 C9           .LL128:                 ret
 368++CA95              ; The following calculates:  (Y X) = (S R) * Q using the same shift-and-add algorithm that's documented in MULT1
 369++CA95 3A 19 C8     .LL122:                 ld      a,(clipGradient)
 370++CA98 32 16 6C                             ld      (varQ),a; optimise
 371++CA9B CD 81 70                             call    HLequSRmulQdiv256
 372++CA9E 22 1E C8                             ld      (varYX),hl
 373++CAA1 F1                                   pop     af
 374++CAA2 ED 27 80                             test    $80
 375++CAA5 CA 88 CA                             jp      z,.LL133
 376++CAA8 C9                                   ret
 377++CAA9
 378++CAA9              ; Do the following, in this order:  Q = XX12+2
 379++CAA9              ;                                   A = S EOR XX12+3
 380++CAA9              ;                                   (S R) = |S R|
 381++CAA9              ; This sets up the variables required above to calculate (S R) / XX12+2 and give the result the opposite sign to XX13+3.
 382++CAA9 3A 19 C8     LL129:                  ld      a,(clipGradient)
 383++CAAC 32 16 6C                             ld      (varQ),a                    ; Set Q = XX12+2
 384++CAAF 3A 18 6C                             ld      a,(varS)                    ; If S is positive, jump to LL127
 385++CAB2 E5 F5                                push    hl,,af                      ; else
 386++CAB4 ED 27 80                             test    $80                         ;   if bit 7 is clear
 387++CAB7 28 0C                                jr      z,.LL127                    ;      RS = ABS RS
 388++CAB9 2A 17 6C                             ld      hl,(varRS)                  ;      .
 389++CABC                                      NegHL                               ;      .
 389++CABC AF          >                    xor a
 389++CABD 95          >                    sub l
 389++CABE 6F          >                    ld l,a
 389++CABF 9F          >                    sbc a,a
 389++CAC0 94          >                    sub h
 389++CAC1 67          >                    ld h,a
 390++CAC2 22 17 6C                             ld      (varRS),hl                  ;      .
 391++CAC5 21 1A C8     .LL127:                 ld      hl,clipDxySign              ;   hl = dxy sign
 392++CAC8 F1                                   pop     af                          ;
 393++CAC9 AE                                   xor     (hl)                        ; a = S XOR clipDxySign
 394++CACA E1                                   pop     hl
 395++CACB C9                                   ret
 396++CACC
 397++CACC              ;--------------------------------------------------------------------------------------
 398++CACC              ; Thow away out of bounds by more than 250
 399++CACC              ClipLineV3:             ;break
 400++CACC                      IFDEF       CLIPVersion3
 401++CACC ~            ;My logic version
 402++CACC ~            .CheckYorder:
 403++CACC ~                                    ld      hl,(UbnkPreClipY1)
 404++CACC ~                                    ld      de,(UbnkPreClipY2)
 405++CACC ~                                    call    CompareHLDESgn
 406++CACC ~                                    jr      c,.LineP1toP2                          ; if Y1 < Y2 then we can use the points as is else we have to swap
 407++CACC ~            .LineP2toP1:            ld      bc,(UbnkPreClipY2)                      ; fetch and write out in reverse
 408++CACC ~                                    ld      ix,(UbnkPreClipY1)
 409++CACC ~                                    ld      de,(UbnkPreClipX1)
 410++CACC ~                                    ld      hl,(UbnkPreClipX2)
 411++CACC ~                                    ld      (UbnkPreClipY1),bc                      ; bc - XX15(2,3) Y1
 412++CACC ~                                    ld      (UbnkPreClipY2),ix                      ; ix - XX12(0,1) Y2
 413++CACC ~                                    ld      (UbnkPreClipX1),hl                      ; hl - XX15(0,1) X1
 414++CACC ~                                    ld      (UbnkPreClipX2),de                      ;  de - XX15(4,5) X2
 415++CACC ~                                    jp      .CheckNoClip
 416++CACC ~            .LineP1toP2             ld      bc,(UbnkPreClipY1)                      ; bc - XX15(2,3) Y1
 417++CACC ~                                    ld      ix,(UbnkPreClipY2)                      ; ix - XX12(0,1) Y2
 418++CACC ~                                    ld      hl,(UbnkPreClipX1)                      ; hl - XX15(0,1) X1
 419++CACC ~                                    ld      de,(UbnkPreClipX2)                      ; de - XX15(4,5) X2
 420++CACC ~            .CheckNoClip:           ld      a,b
 421++CACC ~                                    or      d
 422++CACC ~                                    or      h
 423++CACC ~                                    or      ixh
 424++CACC ~                                    jp      nz,.CheckXOffScreen                 ; if both Y1 and y2 have bit 7 set
 425++CACC ~                                    ld      a,c                                 ; then we clip
 426++CACC ~                                    and     ixl
 427++CACC ~                                    test    $80
 428++CACC ~                                    jp      z, .ClipComplete
 429++CACC ~            ;if either x1hi x2hi are 0 then we clip. if both <> 0and both same sign exit
 430++CACC ~            .CheckXOffScreen:       ld      a,h
 431++CACC ~                                    xor     d
 432++CACC ~                                    test    $80                                 ; non descructive test of bit 7 is set
 433++CACC ~                                    jp      nz,.X1X2OppositeSign                ; if bit 7 was set then x1 and x2 must be opposite signs so its on screen
 434++CACC ~            .X1X2SameSigns:         ld      a,h                                 ; so to get there h and d must be the same sign
 435++CACC ~                                    test    $80                                 ; if they are the same sign and at x1 is negative then x2 must be negative so off screen
 436++CACC ~                                    JumpIfAIsZero .X1X2CheckIfBothRight
 437++CACC ~            .X1X2BothNegative:      SetCarryFlag                                ; to get to here x1 and x2 must be high and off the same sign so its not to draw
 438++CACC ~                                    ret
 439++CACC ~            .X1X2CheckIfBothRight:  and     a                                   ; we have h in a already
 440++CACC ~                                    jr      z,.X1OnScreen
 441++CACC ~                                    ld      a,d
 442++CACC ~                                    and     a
 443++CACC ~                                    jr      z,.X2OnScreen
 444++CACC ~            .X1X2OffRightSide:      SetCarryFlag                                ; to get to here x1 and x2 must be high and off the same sign so its not to draw
 445++CACC ~                                    ret
 446++CACC ~            ;                       to get to here x1 and x2 either span -ve to +ve or from on screen to off screen
 447++CACC ~            .X1OnScreen:
 448++CACC ~            .X2OnScreen:
 449++CACC ~            .X1X2OppositeSign:
 450++CACC ~            ;                       Now check to see if Y is off screen
 451++CACC ~            .CheckYOffScreen:       ld      a,b                                     ; Check if y1 and y2 are opposite signs, fi so it spans screen so we are good
 452++CACC ~            .CheckBothYNegative:    xor     ixh
 453++CACC ~                                    test    $80                                     ; if bit 7 is set then opposite signs
 454++CACC ~                                    jp      nz,.Y1Y2OppositeSign                    ; if y1 and y2 are opposite signs its on screen and spans at least one side
 455++CACC ~            .Y1Y2SameSign:          ld      a,b                                     ; if they are the same sign then if one is negative, so is the other so off screen
 456++CACC ~                                    test    $80
 457++CACC ~                                    jp      z,.Y1Y2Positive
 458++CACC ~            .Y1Y2Negative:          SetCarryFlag
 459++CACC ~                                    ret
 460++CACC ~            .Y1Y2Positive:          ld      a,c                                     ; if its the same sign y1 or y2 could be 0 and if they are
 461++CACC ~                                    and     $80                                     ; this will test to see if b >0 or c > 127
 462++CACC ~                                    or      b                                       ;
 463++CACC ~                                    jp      z,.Y1OnScreen
 464++CACC ~                                    ld      a,ixl
 465++CACC ~                                    and     $80
 466++CACC ~                                    or      ixh
 467++CACC ~                                    jp      z,.Y2OnScreen
 468++CACC ~            .Y1Y2OffBottomSide:     SetCarryFlag
 469++CACC ~                                    ret
 470++CACC ~            .Y1OnScreen:
 471++CACC ~            .Y2OnScreen:
 472++CACC ~            .Y1Y2OppositeSign:
 473++CACC ~            .StartProcessing:       ld      hl,(UbnkPreClipX1)                      ; Now we can test and Clip
 474++CACC ~                                    ld      de,(UbnkPreClipX2)                      ; de - XX15(4,5)
 475++CACC ~                                    ld      iyh,0                                   ; set iyh flags to 0
 476++CACC ~            ; if x1hi or y1 high <> 0 or y1 > 127 then set bit 1 of clipcoord       ; we can optimise this later
 477++CACC ~                                    ld      a,h
 478++CACC ~                                    or      b
 479++CACC ~                                    jr      z,.CheckP1Ylo
 480++CACC ~            ;                       iyh     bit 0 - P1 Needs Clipping
 481++CACC ~            ;                               bit 1 - P2 Needs Clipping
 482++CACC ~            ;                               bit 2 - x1 >= x2 (left to right)
 483++CACC ~            ;                               bit 3 - y1 >= y2 (top to bottom)
 484++CACC ~            ;                               bit 4 -  DY/DX (steep)
 485++CACC ~            .P1OffScreen:           ld      iyh,1                                   ; if either p1 x or y was off screen set bit 0 to 1
 486++CACC ~                                    jp      .CheckP2OffScreen                       ; .
 487++CACC ~            .CheckP1Ylo:            ld      a,c                                     ; .
 488++CACC ~                                    and     $80                                     ; .
 489++CACC ~                                    jr      z,.CheckP2OffScreen                     ; .
 490++CACC ~                                    ld      iyh,1                                   ; .
 491++CACC ~            .CheckP2OffScreen:      ld      a,d                                     ; if x2hi or y2 off screen then set bit 2 of clipcoord to 1
 492++CACC ~                                    or      ixh                                     ; .
 493++CACC ~                                    jr      z,.CheckP2Ylo                           ; .
 494++CACC ~            .P2OffScreen:           ld      a,iyh                                   ; .
 495++CACC ~                                    or      2                                       ; .
 496++CACC ~                                    ld      iyh,a                                   ; .
 497++CACC ~                                    jp      .CheckXDirection                        ; .
 498++CACC ~            .CheckP2Ylo:            ld      a,ixl                                   ; .
 499++CACC ~                                    and     $80                                     ; .
 500++CACC ~                                    jr      z,.CheckXDirection                      ; .
 501++CACC ~                                    ld      a,iyh                                   ; .
 502++CACC ~                                    or      2                                       ; .
 503++CACC ~                                    ld      iyh,a                                   ; .
 504++CACC ~            .CheckXDirection:       push    de,,hl
 505++CACC ~                                    call    CompareHLDESgn                          ; IF HL equals DE, Z=1,C=0, IF HL is less than DE, Z=0,C=1, IF HL is more than DE, Z=0,C=0
 506++CACC ~                                    pop     de,,hl
 507++CACC ~                                    jp      c,.CalculateDx                          ;
 508++CACC ~            .X1gteX2:               ld      a,iyh                                   ; if x1 >= x2 then set bit 3 to denote -ve x direction, note we will eliminate horziontal / vertical early as an optimisation
 509++CACC ~                                    or      4                                       ; .
 510++CACC ~                                    ld      iyh,a                                   ; .
 511++CACC ~                                    ; Y Direction is now always top to bottom
 512++CACC ~            .CalculateDx:           ClearCarryFlag                                  ;                       calculate DX
 513++CACC ~                                    sbc     hl,de                                   ; .
 514++CACC ~            .ABSDX:                 ld      a,h                                     ; HL = | HL - DE |
 515++CACC ~                                    test    $80                                     ; .
 516++CACC ~                                    jr      z,.DXPositive                           ; .
 517++CACC ~                                    macronegate16hl                                 ; .
 518++CACC ~            .DXPositive:            ex      de,hl                                   ; de = abs delta x
 519++CACC ~            .CalculateDy:           ClearCarryFlag                                  ; hl = Y2 -Y1 as its pre sorted its always positive if on screen
 520++CACC ~                                    ld      hl,ix                                   ; iy = hl = Y2 - Y1
 521++CACC ~                                    sbc     hl,bc                                   ; .
 522++CACC ~            .DYPositive:            ; Scale DX and DY to 8 bit, by here hl = abs dy, de = abs dx
 523++CACC ~            ;calculate DY
 524++CACC ~            .ScaleLoop:             ld      a,h                                     ; At this point DX and DY are ABS values
 525++CACC ~                                    or      d                                       ; .
 526++CACC ~                                    jr      z,.ScaleDone                            ; .
 527++CACC ~                                    ShiftDERight1                                   ; .
 528++CACC ~                                    ShiftHLRight1                                   ; .
 529++CACC ~                                    jr      .ScaleLoop                              ; scaled down Dx and Dy to 8 bit, Dy may have been;;                                                                                               negative
 530++CACC ~            .ScaleDone:             ; hl = ABS DY, DE = ABS DX,  bc = Y1, ix = Y2,   note H and D will be zero
 531++CACC ~            ; if Dx = 0 then horizontal line and clip X1 & X2 only then exit
 532++CACC ~            ; if Dy = 0 then vertical line and clip Y1 & Y2 only then exit
 533++CACC ~
 534++CACC ~            ; if DX < DY  gradient = 256 * delta_x_lo / delta_y_lo
 535++CACC ~            ;        else gradient = 256 * delta_y_lo / delta_x_lo, set bit 5 of clipcord
 536++CACC ~            .CalculateDelta:        ld      a,e                                     ; if DX < DY goto DX/DY
 537++CACC ~                                    JumpIfALTNusng l,.DXdivDY                       ; else do DY/DX
 538++CACC ~            .DYdivDX:               ld      a,l                                     ;    A = DY
 539++CACC ~                                    ld      d,e                                     ;    D = DX
 540++CACC ~                                    call    AEquAmul256DivD                         ;    A = R = 256 * DY / DX
 541++CACC ~            .SaveGradientDYDX:      ld      (Gradient),a
 542++CACC ~                                    ld      a,iyh                                   ;    bit 5 of iyh denotes that its a DX/DY (steep), if its clear its DY/DX (shallow)
 543++CACC ~                                    or      16                                      ;    .
 544++CACC ~                                    ld      iyh,a                                   ;    .
 545++CACC ~                                    jp      .ClipP1                                 ;    .
 546++CACC ~            .DXdivDY:               ld      a,e                                     ;    A = DX
 547++CACC ~                                    ld      d,l                                     ;    D = DY
 548++CACC ~                                    call    AEquAmul256DivD                         ;    A = R = 256 * DX / DY
 549++CACC ~            .SaveGradientDXDY:      ld      (Gradient),a
 550++CACC ~            ; if bit 1 of clipccord is set call    LL118
 551++CACC ~            .ClipP1:                ld      a,iyh                                   ; if bit 1 is clear to say no need to clip pont 1 we just jump to point 2
 552++CACC ~                                    test    1                                       ; .
 553++CACC ~                                    jp      z,.ClipP2                               ; .
 554++CACC ~                                    call    LL118v3                                 ; else clip P1 first
 555++CACC ~                                    ld      a,b                                     ;      and if b or h have a value its failed to totally clip  as it may be only in bounds on just x or y
 556++CACC ~                                    or      h                                       ;      .
 557++CACC ~                                    jr      z, .P1Ygt127Check                       ;      .
 558++CACC ~            .P1HighOutofBounds:     SetCarryFlag                                    ;      .
 559++CACC ~                                    ret                                             ;      .
 560++CACC ~            .P1Ygt127Check:         ld      a,c                                     ;      or if y > 127 its failed to totally clip
 561++CACC ~                                    test    $80                                     ;      .
 562++CACC ~                                    SetCarryFlag                                    ;      .
 563++CACC ~                                    ret     nz                                      ;      .
 564++CACC ~                                    ld      (UbnkPreClipY1), bc                     ;      else its valid and clipped point 1 so save ti back
 565++CACC ~                                    ld      (UbnkPreClipX1), hl
 566++CACC ~            ; if bit 2 of clipcoord is set
 567++CACC ~            ;        swap x1y1 with x2y2
 568++CACC ~            ;        call    LL118
 569++CACC ~            .ClipP2:                ld      a,iyh                                   ; so now repeat all that for point 2
 570++CACC ~                                    and     2
 571++CACC ~                                    jp      z,.ClipComplete
 572++CACC ~                                    call    LL118v3PreSwap                          ; now clip p2
 573++CACC ~                                    ld      a,b                                     ; if either high is set then it failed to properly clip
 574++CACC ~                                    or      h                                       ; .
 575++CACC ~                                    jr      z, .P2Ygt127Check                       ; .
 576++CACC ~            .P2HighOutofBounds:     SetCarryFlag                                    ; .
 577++CACC ~                                    ret                                             ; .
 578++CACC ~            .P2Ygt127Check:         ld      a,c                                     ; if c > 127 then it also failed to clip
 579++CACC ~                                    test    $80                                     ; .
 580++CACC ~                                    SetCarryFlag                                    ; .
 581++CACC ~                                    ret     nz                                      ; .
 582++CACC ~                                    ld      (UbnkPreClipY2), bc                     ; bc - XX15(2,3);;
 583++CACC ~                                    ld      (UbnkPreClipX2), hl
 584++CACC ~            ;clip compelte exit
 585++CACC ~            .ClipComplete:          ld      bc,(UbnkPreClipY1)                      ; bc - XX15(2,3);;
 586++CACC ~                                    ld      hl,(UbnkPreClipX1)
 587++CACC ~                                    ld      ix,(UbnkPreClipY2)                      ; bc - XX15(2,3);;
 588++CACC ~                                    ld      de,(UbnkPreClipX2)
 589++CACC ~            .SaveClippedLine:       ld      a,c                                     ; Y1 = y1 lo, x2 = x2 lo, x1 = x1 lo y1 = y1 lo                                   -- Nothing off screen
 590++CACC ~                                    ld      (UBnkNewY1),a
 591++CACC ~                                    ld      a,ixl
 592++CACC ~                                    ld      (UBnkNewY2),a
 593++CACC ~                                    ld      a,l
 594++CACC ~                                    ld      (UBnkNewX1),a
 595++CACC ~                                    ld      a,e
 596++CACC ~                                    ld      (UBnkNewX2),a
 597++CACC ~                                    ClearCarryFlag                              ; we have a success so not carry
 598++CACC ~                                    ret
 599++CACC ~            ;-----------------------------------------------------------------------------------------------------------------------------------
 600++CACC ~            LL118v3PreSwap:         ld      bc,(UbnkPreClipY2)                  ; bc - XX15(2,3);;
 601++CACC ~                                    ld      hl,(UbnkPreClipX2)
 602++CACC ~                                    jp      LL118v3Fetched
 603++CACC ~            ;-----------------------------------------------------------------------------------------------------------------------------------
 604++CACC ~            LL118v3:                ld      bc,(UbnkPreClipY1)                  ; bc - XX15(2,3);;
 605++CACC ~                                    ld      hl,(UbnkPreClipX1)
 606++CACC ~            ;-----------------------------------------------------------------------------------------------------------------------------------
 607++CACC ~            LL118v3Fetched:
 608++CACC ~            ;                       At this point bc = y position, hl = x position both 16 bit
 609++CACC ~            ;                       if x < 0 then x = 0
 610++CACC ~            ;                                     adjust = -x */ gradient depending on if its steep or shallow
 611++CACC ~            ;                                     y = y +- adjust depending on if we are going +ve direction or negative direction  (or simplify it, that it will always be + for x1y1 and - for x2y2 as we pre-sort)
 612++CACC ~            ;                       if x > 255 then x = 255
 613++CACC ~            ;                                     adjust = x-255 */ gradient
 614++CACC ~            ;                                     y = y +- adjust depending on if we are going +ve direction or negative direction  (or simplify it, that it will always be + for x1y1 and - for x2y2 as we pre-sort)
 615++CACC ~            ;                       if y < 0 then y = 0
 616++CACC ~            ;                                     adjust = -y */ gradient
 617++CACC ~            ;                                     x = x +- adjust depending on if we are going left to right or visa versa
 618++CACC ~            ;                       if y >127 then y = 127
 619++CACC ~            ;                                     adjust = y-127 */ gradient
 620++CACC ~            ;                                     x = x +- adjust depending on if we are going left to right or visa versa
 621++CACC ~            ;
 622++CACC ~            ;                       iyh     bit 0 - P1 Needs Clipping
 623++CACC ~            ;                               bit 1 - P2 Needs Clipping
 624++CACC ~            ;                               bit 2 - x1 >= x2 (left to right)
 625++CACC ~            ;                               bit 3 - y1 >= y2 (top to bottom)
 626++CACC ~            ;                               bit 4 -  DY/DX (steep)
 627++CACC ~            ; if X1 hi <> 0
 628++CACC ~            LL118:                  ;break
 629++CACC ~                                    ld      a,h                                     ; if x1 high is 0 then we don't need to clip x at all
 630++CACC ~                                    and     a
 631++CACC ~                                    jp      z,.X1NoClipNeeded
 632++CACC ~            ;                       if x1 hi bit 7 is set (so negative)
 633++CACC ~            .CalcBlockX:            test    $80                                     ; if h is postiive then jump to the XPositive Calc block
 634++CACC ~                                    jr      z,.CalcBlockXPositive
 635++CACC ~            ;                       if clipccord bit 5 is set Adjust = abs(X1) / Gradient (may need to swap bit check?)
 636++CACC ~            .CalcBlockXNegative:    ld      a,iyh                                   ;
 637++CACC ~                                    test    16                                      ; bit 5 of iyh denotes that its a DY/DX, if its clear its DX/DY
 638++CACC ~                                    jr      nz,.CalcBlockXNegMulGrad
 639++CACC ~            .CaclBlockXNegDivGrad:  macronegate16hl
 640++CACC ~                                    ld      a,(Gradient)
 641++CACC ~                                    push    bc                                      ; abs(X1) / Gradient
 642++CACC ~                                    ld      h,c                     ; move offset into high byte of h
 643++CACC ~                                    ld      l,0
 644++CACC ~                                    ld      c,a
 645++CACC ~                                    call    div_hl_c
 646++CACC ~                                    pop     bc
 647++CACC ~                                    jp      .DoneXNegCalc
 648++CACC ~            ;                       else set Adjust = abs(X1) * Gradient
 649++CACC ~            .CalcBlockXNegMulGrad:  push    bc                                      ; abs(X1) * Gradient
 650++CACC ~                                    macronegate16hl
 651++CACC ~                                    ld      a,(Gradient)
 652++CACC ~                                    call    HLeqyHLmulAdiv256
 653++CACC ~                                    pop     bc
 654++CACC ~            ;                       y1 += adjust * (-1 if bit 4 of clipcoord is set)
 655++CACC ~            ;                       x1 = 0 then call into DonrX1Calc
 656++CACC ~            ;                       we can skip the test for negative Y direection
 657++CACC ~            .DoneXNegCalc:          macronegate16hl
 658++CACC ~            .XNegSkipNegate:        ld      de,bc
 659++CACC ~                                    ex      hl,de
 660++CACC ~                                    add     hl,de
 661++CACC ~                                    ld      bc,hl
 662++CACC ~                                    ld      hl,0
 663++CACC ~                                    jp      .DoneXCalc
 664++CACC ~            ;                       else x1 hi is positive
 665++CACC ~            ;                       if clipccord bit 5 is set Adjust = X1 lo / Gradient (may need to swap bit check?)
 666++CACC ~            .CalcBlockXPositive:    ld      a,iyh
 667++CACC ~                                    test    16
 668++CACC ~                                    jr      nz,.CalcBlockXPosMulGrad
 669++CACC ~            .CalcBlockXPosDivGrad:  ld      a,(Gradient)            ;Q = gradient
 670++CACC ~                                    push    bc
 671++CACC ~                                    ld      c,a
 672++CACC ~                                    ld      de,255
 673++CACC ~                                    sub     hl,de
 674++CACC ~                                    ld      h,l
 675++CACC ~                                    ld      l,0
 676++CACC ~                                    call    div_hl_c
 677++CACC ~                                    pop     bc
 678++CACC ~                                    jp      .DoneX2Calc
 679++CACC ~            ;                                 else set Adjust = X1 lo * Gradient
 680++CACC ~            .CalcBlockXPosMulGrad:  push    bc
 681++CACC ~                                    ld      a,(Gradient)            ;Q = gradient
 682++CACC ~                                    ld      de,255
 683++CACC ~                                    sub     hl,de
 684++CACC ~                                    call    HLeqyHLmulAdiv256       ; hl = YX = SR / Q
 685++CACC ~                                    pop     bc
 686++CACC ~            ;                       y1 += adjust * (-1 if bit 4 of clipcoord is set)
 687++CACC ~            ;                       x1 = 255
 688++CACC ~            ;                       we can skip the test for negative Y direection
 689++CACC ~            .DoneX2Calc:            macronegate16hl
 690++CACC ~            .X2SkipNegate:          ex      de,hl
 691++CACC ~                                    ld      hl,bc
 692++CACC ~                                    add     hl,de
 693++CACC ~                                    ld      bc,hl
 694++CACC ~                                    ld      hl,255
 695++CACC ~            ;                       if Y1 hi <> 0 or Y1 low >= 128 then y coordinate is good
 696++CACC ~            .DoneXCalc:             ld      a,b
 697++CACC ~                                    and     a
 698++CACC ~                                    jr      nz,.CalcBlockY1Test
 699++CACC ~                                    ld      a,c
 700++CACC ~                                    and     $80
 701++CACC ~                                    ClearCarryFlag                  ; speculative clear of carry in case its good
 702++CACC ~                                    ret     z
 703++CACC ~            ;                       if Y1 hi bit 7 is set
 704++CACC ~            .X1NoClipNeeded:
 705++CACC ~            .CalcBlockY1Test:       ld      a,b
 706++CACC ~                                    test    $80
 707++CACC ~                                    jr      z,.CalcBlockYPos       ; if Y is positive jump forward
 708++CACC ~            ;                       if clipccord bit 5 is set Adjust = abs(Y1) / Gradient (may need to swap bit check?)
 709++CACC ~                                    break
 710++CACC ~            .CalcBlockY1:           ld      a,iyh
 711++CACC ~                                    test    16
 712++CACC ~                                    jr      nz,.CalcBlockYNegMulGrad
 713++CACC ~            .CalcBlockYNegDivGrad:  macronegate16bc
 714++CACC ~                                    ld      a,(Gradient)            ;Q = gradient
 715++CACC ~                                    push    hl
 716++CACC ~                                    ld      h,c                     ; move offset into high byte of h
 717++CACC ~                                    ld      l,0
 718++CACC ~                                    ld      c,a
 719++CACC ~                                    call    div_hl_c;LLHLdivC;div_hl_c
 720++CACC ~                                    pop     de
 721++CACC ~                                    ex      de,hl
 722++CACC ~                                    jp      .DoneBlockY1
 723++CACC ~            ;                                 else set Adjust = abs(Y1) * Gradient
 724++CACC ~            .CalcBlockYNegMulGrad:  macronegate16bc
 725++CACC ~                                    push    hl
 726++CACC ~                                    ld      hl,bc
 727++CACC ~                                    ld      a,(Gradient)            ;Q = gradient
 728++CACC ~                                    call    HLeqyHLmulAdiv256       ; hl = YX = SR / Q
 729++CACC ~                                    pop     de
 730++CACC ~                                    ex      de,hl
 731++CACC ~            ;                       x1 += adjust * (-1 if bit 3 of clipcoord is set)
 732++CACC ~            ;                       y1 = 0
 733++CACC ~            ;                       ret
 734++CACC ~            ;                       now we have done the adjustment, if y or x are off screen then the line spans screen in only 1 dimension so doesn't get drawn
 735++CACC ~            .DoneBlockY1:           ld      a,iyh
 736++CACC ~                                    test    4
 737++CACC ~                                    jr      z,.Y1SkipNegate
 738++CACC ~                                    macronegate16de
 739++CACC ~            .Y1SkipNegate:          add     hl,de
 740++CACC ~                                    ld      bc,0
 741++CACC ~                                    ret
 742++CACC ~            ;                       if clipccord bit 5 is set Adjust = Y1 lo / Gradient (may need to swap bit check?)
 743++CACC ~            .CalcBlockYPos:         ld      a,iyh
 744++CACC ~                                    test    16
 745++CACC ~                                    jr      z,.CalcBlockYPosMulGrad
 746++CACC ~            .CalcBlockYPosDivGrad:  ld      a,(Gradient)            ;Q = gradient
 747++CACC ~                                    push    hl
 748++CACC ~                                    ld      hl,bc
 749++CACC ~                                    ld      de,127
 750++CACC ~                                    sub     hl,de
 751++CACC ~                                    ld      h,l
 752++CACC ~                                    ld      l,0
 753++CACC ~                                    ld      c,a
 754++CACC ~                                    call    div_hl_c;LLHLdivC
 755++CACC ~                                    pop     de
 756++CACC ~                                    ex      de,hl
 757++CACC ~                                    jp      .DoneBlockY2
 758++CACC ~            ;                                 else set Adjust = Y1 lo * Gradient
 759++CACC ~            .CalcBlockYPosMulGrad:  push    hl
 760++CACC ~                                    ld      hl,bc
 761++CACC ~                                    ld      de,127
 762++CACC ~                                    sub     hl,de
 763++CACC ~                                    ld      a,(Gradient)
 764++CACC ~                                    call    HLeqyHLmulAdiv256       ; hl = YX = SR / Q
 765++CACC ~                                    pop     de
 766++CACC ~                                    ex      de,hl
 767++CACC ~            ;                x1 += adjust * (-1 if bit 3 of clipcoord is set)
 768++CACC ~            ;                y1 = 127
 769++CACC ~            .DoneBlockY2:           ld      a,iyh
 770++CACC ~                                    test    4
 771++CACC ~                                    jr      nz,.Y2SkipNegate
 772++CACC ~                                    macronegate16de
 773++CACC ~            .Y2SkipNegate:          add     hl,de
 774++CACC ~                                    ld      bc,127
 775++CACC ~                                    ret
 776++CACC                      ELSE
 777++CACC C9                       ret
 778++CACD                      ENDIF
 779++CACD              ; old code for on screen test
 780++CACD              ;;;;;;; if y1 > 127 and y2 > 127 then same sing and exit
 781++CACD              ;;;;;;
 782++CACD              ;;;;;;;if y1hi y2hi are <> 0 and both same sign exit
 783++CACD              ;;;;;;.CheckYOffScreen:       ld      a,b                                 ; y1 and y2 high tests
 784++CACD              ;;;;;;                        and     ixh
 785++CACD              ;;;;;;                        jp      .CheckYLow
 786++CACD              ;;;;;;                        ld
 787++CACD              ;;;;;;                        and     a                                   ; if either is zero then we can check for > 127
 788++CACD              ;;;;;;                        jr      z,.YHighNegativeCheck               ;
 789++CACD              ;;;;;;                        ld      a,ixh                               ;
 790++CACD              ;;;;;;                        and     a                                   ;
 791++CACD              ;;;;;;                        ret     nz                                  ;
 792++CACD              ;;;;;;;if y1h bit 7 and y2h bit 7 set then exit as both -ve
 793++CACD              ;;;;;;                        ld      a,b                                 ;
 794++CACD              ;;;;;;                        and     ixh                                 ;
 795++CACD              ;;;;;;                        and     $80                                 ;
 796++CACD              ;;;;;;                        ret     z                                   ;
 797++CACD              ;;;;;;;if y1h > 0 and y2h > 0 then exit as both are +ve high
 798++CACD              ;;;;;;                        ld      a,b                                 ;
 799++CACD              ;;;;;;                        and     ixh                                 ;
 800++CACD              ;;;;;;                        ret     nz                                  ;
 801++CACD              ;;;;;;;if y1h or y2h is not 0 then proceed to clip
 802++CACD              ;;;;;;                        ld      a,b
 803++CACD              ;;;;;;                        or      ixh
 804++CACD              ;;;;;;                        jr      nz,.StartProcessing
 805++CACD              ;;;;;;;if (y1l bit 7 is set and y1h is clear ) or (y2l bit 7 is set and y2h is clear) the proceed to clip
 806++CACD              ;;;;;;                        ld      a,c
 807++CACD              ;;;;;;                        or      ixl
 808++CACD              ;;;;;;                        and     $80
 809++CACD              ;;;;;;                        jr      z,.StartProcessing
 810++CACD              ;;;;;;
 811++CACD              ;;;;;;.CheckYOffScreen:       ld      a,b                                 ;
 812++CACD              ;;;;;;                        cp      0                                   ;
 813++CACD              ;;;;;;                        jr      z,.Y1HighIsZero                     ;
 814++CACD              ;;;;;;                        ld      a,ixh                               ; if we get here Y1 high <> 0
 815++CACD              ;;;;;;                        cp      0                                   ;
 816++CACD              ;;;;;;                        jr      z,.Y2HighIsZero                     ; if they are both non zero we can do a sign check
 817++CACD              ;;;;;;.CheckYSameSign:        ld      a,b                                 ; if we get here Y1 high and Y2 high are not zero
 818++CACD              ;;;;;;                        xor     ixh                                 ; so same sign then bail out if they are
 819++CACD              ;;;;;;                        and     $80                                 ;
 820++CACD              ;;;;;;                        ret     z                                   ;
 821++CACD              ;;;;;;;if we get here either y1hi or y2 hi are 0, now check and y1 low > 127 & y2 low > 127, exit
 822++CACD              ;;;;;;.Y1HighIsZero:          ld      a,ixh                               ; as y1h is zero, if y2h is zero we do y1 y2 test
 823++CACD              ;;;;;;                        cp      0                                   ;
 824++CACD              ;;;;;;                        jr      nz,.Startprocessing                 ;
 825++CACD              ;;;;;;                        ld      a,c                                 ; so by here y1h and y2h must be zero
 826++CACD              ;;;;;;                        and     ixl
 827++CACD              ;;;;;;
 828++CACD              ;;;;;;                        .CheckY2Lo                        ;
 829++CACD              ;;;;;;.CheckY1Lo:             ld      a,c
 830++CACD              ;;;;;;                        and     $80
 831++CACD              ;;;;;;                        jr      z,.StartProcessing
 832++CACD              ;;;;;;.CheckY2Lo:             ld      a,ixl
 833++CACD              ;;;;;;                        and     $80
 834++CACD              ;;;;;;                        ret     nz
 835++CACD              ;;;;;;;clip = 0
# file closed: ../../Tests/Vectors/../../ModelRender/CLIP-LL145.asm
 406+ CACD              ;--------------------------------------------------------------------------------------------------------
 407+ CACD                                      INCLUDE "../../Universe/Ships/CopyRotmatToTransMat.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/CopyRotmatToTransMat.asm
   1++CACD              ; Set TransMatTo
   2++CACD              ; XX16(1 0)   (3 2)   (5 4)   = sidev_x sidev_y sidev_z XX16(13,12) (15 14) (17 16)
   3++CACD              ; XX16(7 6)   (9 8)   (11 10) = roofv_x roofv_y roofv_z XX16(7 6)   (9 8)   (11 10)
   4++CACD              ; XX16(13 12) (15 14) (17 16) = nosev_x nosev_y nosev_z XX16(1 0)   (3 2)   (5 4)
   5++CACD              ; This moves Side XYZ to position 0, Roof XYZ to position 1 annd nose XYZ to position 2 as a copy of each batch of 6 bytes
   6++CACD              ; 18 byte fast copy
   7++CACD
   8++CACD              ; Fast copy using the stack                                                         ; T states
   9++CACD F3           CopyRotmatToTransMat:   di                                                          ; disable interrups to protect during copy
  10++CACE DD 21 00 00                          ld      ix,0                                                ; 14
  11++CAD2 DD 39                                add     ix,sp                                               ; 15
  12++CAD4 31 2A C0                             ld      sp,UBnkrotmatSidevX ; Source                        ; 10
  13++CAD7 E1                                   pop     hl                  ; UBnkrotmatSidevX              ; 10
  14++CAD8 D1                                   pop     de                  ; UBnkrotmatSidevY              ; 10
  15++CAD9 C1                                   pop     bc                  ; UBnkrotmatSidevZ              ; 10
  16++CADA D9                                   exx                                                         ; 4
  17++CADB E1                                   pop     hl                  ; UBnkrotmatRoofvX              ; 10
  18++CADC D1                                   pop     de                  ; UBnkrotmatRoofvY              ; 10
  19++CADD C1                                   pop     bc                  ; UBnkrotmatRoofvZ              ; 10
  20++CADE 31 AE C0                             ld      sp,UBnkTransmatRoofvZ+2 ; Target + 2 reversed       ; 10
  21++CAE1 C5                                   push    bc                                                  ; 10
  22++CAE2 D5                                   push    de                                                  ; 10
  23++CAE3 E5                                   push    hl                                                  ; 10
  24++CAE4 D9                                   exx                                                         ; 4
  25++CAE5 C5                                   push    bc                                                  ; 10
  26++CAE6 D5                                   push    de                                                  ; 10
  27++CAE7 E5                                   push    hl                                                  ; 10
  28++CAE8 31 36 C0                             ld      sp,UBnkrotmatNosevX ; Source                        ; 10
  29++CAEB E1                                   pop     hl                  ; UBnkrotmatSidevX              ; 10
  30++CAEC D1                                   pop     de                  ; UBnkrotmatSidevY              ; 10
  31++CAED C1                                   pop     bc                  ; UBnkrotmatSidevZ              ; 10
  32++CAEE 31 B4 C0                             ld      sp,UBnkTransmatNosevZ+2                             ; 10
  33++CAF1 C5                                   push    bc                                                  ; 10
  34++CAF2 D5                                   push    de                                                  ; 10
  35++CAF3 E5                                   push    hl                                                  ; 10
  36++CAF4 DD F9                                ld      sp,ix               ; restore stack                 ; 10
  37++CAF6                                  IFNDEF INTERRUPS_DISABLE
  38++CAF6 ~                                    ei
  39++CAF6                                  ENDIF
  40++CAF6 C9                                   ret                                                         ; 10 Total 267 (LDI version is 318)
  41++CAF7
  42++CAF7
  43++CAF7
  44++CAF7              ;CopyRotmatToTransMat:
  45++CAF7              ;                        ld      hl,UBnkrotmatSidevX
  46++CAF7              ;                        ld      de,UBnkTransmatSidevX
  47++CAF7              ;                        SixLDIInstrunctions
  48++CAF7              ;                        ld      hl,UBnkrotmatRoofvX
  49++CAF7              ;                        ld      de, UBnkTransmatRoofvX
  50++CAF7              ;                        SixLDIInstrunctions
  51++CAF7              ;                        ld      hl,UBnkrotmatNosevX
  52++CAF7              ;                        ld      de, UBnkTransmatNosevX
  53++CAF7              ;                        SixLDIInstrunctions
  54++CAF7              ;                        ret
  55++CAF7
  56++CAF7              CopyRotToTransMacro:    MACRO
  57++CAF7 ~                                    ld      hl,UBnkrotmatSidevX
  58++CAF7 ~                                    ld      de,UBnkTransmatSidevX
  59++CAF7 ~                                    SixLDIInstrunctions
  60++CAF7 ~                                    SixLDIInstrunctions
  61++CAF7 ~                                    SixLDIInstrunctions
  62++CAF7                                      ENDM
  63++CAF7
# file closed: ../../Tests/Vectors/../../Universe/Ships/CopyRotmatToTransMat.asm
 408+ CAF7                                      INCLUDE "../../Universe/Ships/TransposeXX12ByShipToXX15.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/TransposeXX12ByShipToXX15.asm
   1++CAF7              TransposeXX12ByShipToXX15:
   2++CAF7 2A ED C0             ld		hl,(UBnkXX12xLo)					; get X into HL
   3++CAFA 7C           		ld		a,h			                        ; get XX12 Sign
   4++CAFB E6 80        		and		$80									; check sign bit on high byte
   5++CAFD 47           		ld		b,a									; and put it in of 12xlo in b
   6++CAFE                      ;110921 debugld      h,0
   7++CAFE 7C                   ld      a,h
   8++CAFF E6 7F                and     $7F
   9++CB01 67                   ld      h,a
  10++CB02                      ;110921 debugld      h,0
  11++CB02 ED 5B 20 C0  		ld		de,(UBnKxlo)						;
  12++CB06 3A 22 C0     		ld		a,(UBnKxsgn)						; get Ship Pos (low,high,sign)
  13++CB09 E6 80        		and		$80									; make sure we only have bit 7
  14++CB0B 4F           		ld		c,a									; and put sign of unkxsgn c
  15++CB0C CD 33 00     		call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC		; this will result in HL = result and A = sign
  16++CB0F B4           		or		h									; combine sign in A with H to give 15 bit signed (*NOT* 2's c)
  17++CB10 67           		ld		h,a
  18++CB11 22 E7 C0     		ld		(UBnkXScaled),hl					; now write it out to XX15 X pos
  19++CB14              ; ..................................
  20++CB14 2A EF C0     		ld		hl,(UBnkXX12yLo)					; Repeat above for Y coordinate
  21++CB17 7C           		ld		a,h
  22++CB18 E6 80        		and		$80
  23++CB1A 47           		ld		b,a
  24++CB1B                      ;110921 debugld      h,0
  25++CB1B 7C                   ld      a,h
  26++CB1C E6 7F                and     $7F
  27++CB1E 67                   ld      h,a
  28++CB1F                      ;110921 debugld      h,0
  29++CB1F ED 5B 23 C0  		ld		de,(UBnKylo)
  30++CB23 3A 25 C0     		ld		a,(UBnKysgn)
  31++CB26 E6 80        		and		$80									; make sure we only have bit 7
  32++CB28 4F           		ld		c,a
  33++CB29 CD 33 00     		call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC
  34++CB2C B4           		or		h									; combine sign in A with H
  35++CB2D 67           		ld		h,a
  36++CB2E 22 E9 C0     		ld		(UBnkYScaled),hl
  37++CB31              ; ..................................
  38++CB31 2A F1 C0     		ld		hl,(UBnkXX12zLo)					; and now repeat for Z cooord
  39++CB34 7C           		ld		a,h
  40++CB35 E6 80        		and		$80
  41++CB37 47           		ld		b,a
  42++CB38                      ;110921 debugld      h,0
  43++CB38 7C                   ld      a,h
  44++CB39 E6 7F                and     $7F
  45++CB3B 67                   ld      h,a
  46++CB3C                      ;110921 debugld      h,0
  47++CB3C ED 5B 26 C0  		ld		de,(UBnKzlo)
  48++CB40 3A 28 C0     		ld		a,(UBnKzsgn)
  49++CB43 E6 80        		and		$80									; make sure we only have bit 7
  50++CB45 4F           		ld		c,a
  51++CB46 CD 33 00     		call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC
  52++CB49 B4           		or		h									; combine sign in A with H
  53++CB4A 67           		ld		h,a
  54++CB4B CB 7C        		bit		7,h                                 ; if sign if positive then we don't need to do the clamp so we ony jump
  55++CB4D 20 16        		jr		nz,ClampZto4                        ; result was negative so we need to clamp to 4
  56++CB4F E6 7F                and     $7F                                 ; a = value unsigned
  57++CB51 20 06                jr      nz,NoClampZto4                      ; if high byte was 0 then we could need to clamp still by this stage its +v but and will set z flag if high byte is zero
  58++CB53 7D                   ld      a,l                                 ; get low byte now
  59++CB54              		JumpIfALTNusng 4,ClampZto4					; if its < 4 then fix at 4
  59++CB54 FE 04       >                        cp      4
  59++CB56 DA 65 CB    >                        jp		c, ClampZto4
  60++CB59              NoClampZto4:
  61++CB59 22 EB C0     		ld		(UBnkZScaled),hl					; hl = signed calculation and > 4
  62++CB5C 7D           		ld		a,l									; in addition write out the z cooord to UT for now for backwards compat (DEBUG TODO remove later)
  63++CB5D 32 32 6C             ld      (varT),a
  64++CB60 7C           		ld		a,h
  65++CB61 32 15 6C             ld      (varU),a
  66++CB64 C9           		ret
  67++CB65              ClampZto4:											; This is where we limit 4 to a minimum of 4
  68++CB65 21 04 00     		ld		hl,4
  69++CB68 22 EB C0     		ld		(UBnkZScaled),hl; BODGE FOR NOW
  70++CB6B 7D           		ld		a,l
  71++CB6C 32 32 6C             ld      (varT),a                            ;                                                                           ;;;
  72++CB6F 7C           		ld		a,h
  73++CB70 32 15 6C             ld      (varU),a 						; compatibility for now
  74++CB73 C9           		ret
  75++CB74
# file closed: ../../Tests/Vectors/../../Universe/Ships/TransposeXX12ByShipToXX15.asm
 409+ CB74                                      INCLUDE "../../Maths/Utilities/ScaleNodeTo8Bit.asm"
# file opened: ../../Tests/Vectors/../../Maths/Utilities/ScaleNodeTo8Bit.asm
   1++CB74              ScaleNodeTo8Bit:								; TODO make signed
   2++CB74 ED 4B EB C0  	ld			bc,(UBnkZScaled)
   3++CB78 2A E7 C0     	ld			hl,(UBnkXScaled)
   4++CB7B ED 5B E9 C0  	ld			de,(UBnkYScaled)
   5++CB7F              SetABSbc:
   6++CB7F 78           	ld			a,b
   7++CB80 DD 67        	ld			ixh,a
   8++CB82 E6 7F        	and			SignMask8Bit
   9++CB84 47           	ld			b,a									; bc = ABS bc
  10++CB85              SetABShl:
  11++CB85 7C           	ld			a,h
  12++CB86 DD 6F        	ld			ixl,a
  13++CB88 E6 7F        	and			SignMask8Bit
  14++CB8A 67           	ld			h,a									; hl = ABS hl
  15++CB8B              SetABSde:
  16++CB8B 7A           	ld			a,d
  17++CB8C FD 67        	ld			iyh,a
  18++CB8E E6 7F        	and			SignMask8Bit
  19++CB90 57           	ld			d,a									; de = ABS de
  20++CB91              ScaleNodeTo8BitLoop:
  21++CB91 78               ld          a,b		                            ; U	\ z hi
  22++CB92 B4           	or			h                                   ; XX15+1	\ x hi
  23++CB93 B2           	or			d                                   ; XX15+4	\ y hi
  24++CB94 28 0F            jr          z,ScaleNodeDone                   ; if X, Y, Z = 0  exit loop down once hi U rolled to 0
  25++CB96                  ShiftHLRight1
  25++CB96 CB 3C       >			   srl h
  25++CB98 CB 1D       >			   rr  l
  26++CB9A                  ShiftDERight1
  26++CB9A CB 3A       >			   srl d
  26++CB9C CB 1B       >			   rr  e
  27++CB9E              	ShiftBCRight1
  27++CB9E CB 38       >			   srl b
  27++CBA0 CB 19       >			   rr  c
  28++CBA2 C3 91 CB         jp          ScaleNodeTo8BitLoop
  29++CBA5              ScaleNodeDone:										; now we have scaled values we have to deal with sign
  30++CBA5 DD 7C        	ld			a,ixh								; get sign bit and or with b
  31++CBA7 E6 80        	and			SignOnly8Bit
  32++CBA9 B0           	or			b
  33++CBAA 47           	ld			b,a
  34++CBAB              SignforHL:
  35++CBAB DD 7D        	ld			a,ixl								; get sign bit and or with b
  36++CBAD E6 80        	and			SignOnly8Bit
  37++CBAF B4           	or			h
  38++CBB0 67           	ld			h,a
  39++CBB1              SignforDE:
  40++CBB1 FD 7C        	ld			a,iyh								; get sign bit and or with b
  41++CBB3 E6 80        	and			SignOnly8Bit
  42++CBB5 B2           	or			d
  43++CBB6 57           	ld			d,a
  44++CBB7              SignsDoneSaveResult:
  45++CBB7 ED 43 EB C0  	ld			(UBnkZScaled),bc
  46++CBBB 22 E7 C0     	ld			(UBnkXScaled),hl
  47++CBBE ED 53 E9 C0  	ld			(UBnkYScaled),de
  48++CBC2 78           	ld			a,b
  49++CBC3 32 15 6C     	ld			(varU),a
  50++CBC6 79           	ld			a,c
  51++CBC7 32 32 6C     	ld			(varT),a
  52++CBCA C9           	ret
  53++CBCB
# file closed: ../../Tests/Vectors/../../Maths/Utilities/ScaleNodeTo8Bit.asm
 410+ CBCB
 411+ CBCB              ;--------------------------------------------------------------------------------------------------------
 412+ CBCB 21 13 C1     SetFaceAVisible:        ld      hl,UbnkFaceVisArray
 413+ CBCE ED 31                                add     hl,a
 414+ CBD0 3E FF                                ld      a,$FF
 415+ CBD2 77                                   ld      (hl),a
 416+ CBD3 C9                                   ret
 417+ CBD4              ;--------------------------------------------------------------------------------------------------------
 418+ CBD4 21 13 C1     SetFaceAHidden:         ld      hl,UbnkFaceVisArray
 419+ CBD7 ED 31                                add     hl,a
 420+ CBD9 AF                                   xor     a
 421+ CBDA 77                                   ld      (hl),a
 422+ CBDB C9                                   ret
 423+ CBDC              ;--------------------------------------------------------------------------------------------------------
 424+ CBDC 3A 44 C4     SetAllFacesVisible:     ld      a,(FaceCtX4Addr)            ; (XX0),Y which is XX0[0C] or UBnkHullCopy+FaceCtX4Addr                                 ;;; Faces count (previously loaded into b up front but no need to shave bytes for clarity
 425+ CBDF CB 3F                                srl     a                           ; else do explosion needs all vertices                                                  ;;;
 426+ CBE1 CB 3F                                srl     a                           ;  /=4  TODO add this into blueprint data for speed                                                           ;;; For loop = 15 to 0
 427+ CBE3 47                                   ld      b,a                         ; b = Xreg = number of normals, faces
 428+ CBE4 21 13 C1                             ld      hl,UbnkFaceVisArray
 429+ CBE7 3E FF                                ld      a,$FF
 430+ CBE9              SetAllFacesVisibleLoop:
 431+ CBE9 77           EE30:                   ld      (hl),a
 432+ CBEA 23                                   inc     hl
 433+ CBEB 10 FC                                djnz    SetAllFacesVisibleLoop
 434+ CBED C9                                   ret
 435+ CBEE              ;--------------------------------------------------------------------------------------------------------
 436+ CBEE 3A 44 C4     SetAllFacesHidden:      ld      a,(FaceCtX4Addr)            ; (XX0),Y which is XX0[0C] or UBnkHullCopy+ShipHullFacesCount                           ;;; Faces count (previously loaded into b up front but no need to shave bytes for clarity
 437+ CBF1 CB 3F                                srl     a                           ; else do explosion needs all vertices                                                  ;;;
 438+ CBF3 CB 3F                                srl     a                           ;  /=4                                                                                  ;;; For loop = 15 to 0
 439+ CBF5 47                                   ld      b,a                         ; b = Xreg = number of normals, faces
 440+ CBF6 06 10                                ld      b,16
 441+ CBF8 21 13 C1                             ld      hl,UbnkFaceVisArray
 442+ CBFB 3E 00                                ld      a,$00
 443+ CBFD 77           SetAllFacesHiddenLoop:  ld      (hl),a
 444+ CBFE 23                                   inc     hl
 445+ CBFF 10 FC                                djnz    SetAllFacesHiddenLoop
 446+ CC01 C9                                   ret
 447+ CC02              ;--------------------------------------------------------------------------------------------------------
 448+ CC02                                      include "../../Universe/Ships/NormaliseTransMat.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/NormaliseTransMat.asm
   1++CC02              ;divdide by 16 using undocumented instrunctions
   2++CC02 47           Norm256mulAdivQ:        ld      b,a
   3++CC03 0E 00                                ld      c,0
   4++CC05 16 00                                ld      d,0
   5++CC07 3A 16 6C                             ld      a,(varQ)
   6++CC0A 5F                                   ld      e,a
   7++CC0B              ;Input: BC = Dividend, DE = Divisor, HL = 0
   8++CC0B              ;Output: BC = Quotient, HL = Remainder
   9++CC0B 21 00 00     NormDIV16UNDOC:         ld      hl,0
  10++CC0E 78                                   ld      a,b
  11++CC0F 06 10                                ld      b,16
  12++CC11 CB 31        NormDIV16UNDOCLOOP:     sll	    c		; unroll 16 times
  13++CC13 17                                   rla	    		; ...
  14++CC14 ED 6A                                adc	    hl,hl		; ...
  15++CC16 ED 52                                sbc	    hl,de		; ...
  16++CC18 30 02                                jr	    nc,NormDIV16UNDOCSKIP		; ...
  17++CC1A 19                                   add	    hl,de		; ...
  18++CC1B 0D                                   dec	    c		; ...
  19++CC1C 10 F3        NormDIV16UNDOCSKIP:     djnz    NormDIV16UNDOCLOOP
  20++CC1E 79                                   ld      a,c
  21++CC1F 32 17 6C                             ld      (varR),a
  22++CC22 C9                                   ret
  23++CC23
  24++CC23 FD 67        Norm256mulAdivQSignA:   ld      iyh,a
  25++CC25                                      ClearSignBitA
  25++CC25 E6 7F       >                        and     SignMask8Bit
  26++CC27 CD 02 CC                             call    Norm256mulAdivQ              ; do 15 bit unsigned
  27++CC2A FD 7C                                ld      a,iyh                       ; now correct R reg
  28++CC2C                                      SignBitOnlyA
  28++CC2C E6 80       >                        and     SignOnly8Bit
  29++CC2E B1                                   or      c
  30++CC2F 32 17 6C                             ld      (varR),a
  31++CC32 C9                                   ret
  32++CC33
  33++CC33              ; Tested OK
  34++CC33              ;LL21
  35++CC33              NormaliseTransMat:
  36++CC33                      IFDEF LOGMATHS
  37++CC33 ~                            ld      hl,UBnkTransmatNosevZ+1     ; initialise loop
  38++CC33 ~                            ld      b,9                         ; total of 9 elements to transform
  39++CC33 ~                            MMUSelectMathsTables
  40++CC33 ~            .LL21Loop:      ld      d,(hl)
  41++CC33 ~                            dec     hl
  42++CC33 ~                            ld      e,(hl)                      ; de = hilo now   hl now = pointer to low byte
  43++CC33 ~                            ShiftDELeft1                        ; De = DE * 2
  44++CC33 ~                            ld      a,d                         ; a = hi byte after shifting
  45++CC33 ~                            push	hl
  46++CC33 ~                            push	bc
  47++CC33 ~                            call    AEquAmul256Div197Log        ; R = (2(hi).0)/ConstNorm - LL28 Optimised BFRDIV R=A*256/Q = delta_y / delta_x Use Y/X grad. as not steep
  48++CC33 ~                            ;ld      a,c                         ; BFRDIV returns R also in l reg
  49++CC33 ~                            pop		bc
  50++CC33 ~                            pop		hl							; bc gets wrecked by BFRDIV
  51++CC33 ~                            ld      (hl),a                      ; write low result to low byte so zlo = (zhl *2)/197, we keep hi byte in tact as we need the sign bit
  52++CC33 ~                            dec     hl                          ; now hl = hi byte of pre val e.g z->y->x
  53++CC33 ~                            djnz    .LL21Loop                   ; loop from 2zLo through to 0xLo
  54++CC33 ~                            MMUSelectROM0
  55++CC33 ~                            ret
  56++CC33                      ELSE
  57++CC33 21 B3 C0                     ld      hl,UBnkTransmatNosevZ+1         ; initialise loop
  58++CC36 0E C5                        ld      c,ConstNorm                 ; c = Q = norm = 197
  59++CC38 79                           ld      a,c
  60++CC39 32 16 6C                     ld      (varQ),a                    ; set up varQ
  61++CC3C 06 09                        ld      b,9                         ; total of 9 elements to transform
  62++CC3E 56           LL21Loop:       ld      d,(hl)
  63++CC3F 2B                           dec     hl
  64++CC40 5E                           ld      e,(hl)                      ; de = hilo now   hl now = pointer to low byte
  65++CC41                              ShiftDELeft1                        ; De = DE * 2
  65++CC41 CB 23       >			   sla e
  65++CC43 CB 12       >			   rl  d
  66++CC45 7A                           ld      a,d                         ; a = hi byte after shifting
  67++CC46 E5                           push	hl
  68++CC47 C5                           push	bc
  69++CC48 CD 02 CC                     call    Norm256mulAdivQ
  70++CC4B                              ;===call    RequAmul256divC				; R = (2(hi).0)/ConstNorm - LL28 Optimised BFRDIV R=A*256/Q = delta_y / delta_x Use Y/X grad. as not steep
  71++CC4B 79                           ld      a,c                         ; BFRDIV returns R also in l reg
  72++CC4C C1                           pop		bc
  73++CC4D E1                           pop		hl							; bc gets wrecked by BFRDIV
  74++CC4E 77                           ld      (hl),a                      ; write low result to low byte so zlo = (zhl *2)/197, we keep hi byte in tact as we need the sign bit
  75++CC4F 2B                           dec     hl                          ; now hl = hi byte of pre val e.g z->y->x
  76++CC50 10 EC                        djnz    LL21Loop                    ; loop from 2zLo through to 0xLo
  77++CC52 C9                           ret
  78++CC53                      ENDIF
# file closed: ../../Tests/Vectors/../../Universe/Ships/NormaliseTransMat.asm
 449+ CC53              ;--------------------------------------------------------------------------------------------------------
 450+ CC53                                      include "../../Universe/Ships/InverseXX16.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/InverseXX16.asm
   1++CC53              ; TESTEDOK
   2++CC53
   3++CC53              ;ScaleOrientationXX16:                       ; DEBUG TODO will combine with inverse later
   4++CC53              ;        ld      a,(XX17)
   5++CC53              ;        ld      ixl,a
   6++CC53              ;        ld      ixh,9
   7++CC53              ;        ld      hl,UBnkTransInv0x
   8++CC53              ;        ld      a,(hl)
   9++CC53              ;ScaleNode:
  10++CC53              ;        ld      b,ixl
  11++CC53              ;ScaleNodeLoop:
  12++CC53              ;        sla      a
  13++CC53              ;        djnz    ScaleNodeLoop
  14++CC53              ;        ld      (hl),a
  15++CC53              ;        inc     hl
  16++CC53              ;        inc     hl
  17++CC53              ;        dec     ixh
  18++CC53              ;        jr      nz,ScaleNode
  19++CC53              ;        ret
  20++CC53
  21++CC53
  22++CC53              InverseXX16:								; lead routine into .LL42	\ ->  &4B04 \ DO nodeX-Ycoords their comment  \  TrnspMat
  23++CC53              ; we coudl combine this with move to transmat later as an optimisation
  24++CC53              ; INPUT - All Scaled
  25++CC53              ;  They transmat has already been put into side, roof nose order
  26++CC53              ;  XX16   = |sidev_x| |sidev_y| |sidev_z|  1  0  3  2  5  4 note each bytepair is Scaled value in low and high byte just for sign
  27++CC53              ;  XX16   = |roofv_x| |roofv_y| |roofv_z|  7  6  8  9 11 10
  28++CC53              ;  XX16   = |nosev_x| |nosev_y| |nosev_z| 13 12 15 14 17 16
  29++CC53              ; OUTPUT
  30++CC53              ;  XX16(1 0)   ( 3 2) ( 5 4 ) =  sidev_x roofv_x nosev_x
  31++CC53              ;  XX16(7 6)   ( 8 9) (11 10) =  sidev_y roofv_y nosev_y
  32++CC53              ;  XX16(13 12) (15 14)(17 16) =  sidev_z roofv_z nosev_z
  33++CC53              ; First all side values become compoment 0 of each vector
  34++CC53 2A A2 C0             ld      hl,(UBnkTransmatSidevX)     ;
  35++CC56 ED 5B A8 C0          ld      de,(UBnkTransmatRoofvX)     ;
  36++CC5A ED 4B AE C0          ld      bc,(UBnkTransmatNosevX)     ;
  37++CC5E 22 BA C0             ld      (UbnkTransInvRow0x0),hl     ;
  38++CC61 ED 53 BC C0          ld      (UbnkTransInvRow0x1),de     ;
  39++CC65 ED 43 BE C0          ld      (UbnkTransInvRow0x2),bc     ;
  40++CC69 2A A4 C0             ld      hl,(UBnkTransmatSidevY)     ;
  41++CC6C ED 5B AA C0          ld      de,(UBnkTransmatRoofvY)     ;
  42++CC70 ED 4B B0 C0          ld      bc,(UBnkTransmatNosevY)     ;
  43++CC74 22 C2 C0             ld      (UbnkTransInvRow1y0),hl     ;
  44++CC77 ED 53 C4 C0          ld      (UbnkTransInvRow1y1),de     ;
  45++CC7B ED 43 C6 C0          ld      (UbnkTransInvRow1y2),bc     ;
  46++CC7F 2A A6 C0             ld      hl,(UBnkTransmatSidevZ)     ;
  47++CC82 ED 5B AC C0          ld      de,(UBnkTransmatRoofvZ)     ;
  48++CC86 ED 4B B2 C0          ld      bc,(UBnkTransmatNosevZ)     ;
  49++CC8A 22 CA C0             ld      (UbnkTransInvRow2z0),hl     ;
  50++CC8D ED 53 CC C0          ld      (UbnkTransInvRow2z1),de     ;
  51++CC91 ED 43 CE C0          ld      (UbnkTransInvRow2z2),bc     ;
  52++CC95 C9                   ret
  53++CC96
  54++CC96
# file closed: ../../Tests/Vectors/../../Universe/Ships/InverseXX16.asm
 451+ CC96              ;--------------------------------------------------------------------------------------------------------
 452+ CC96              XX12DotOneRow:
 453+ CC96              XX12CalcX:              N0equN1byN2div256 varT, (hl), (UBnkXScaled)       ; T = (hl) * regXX15fx /256
 453+ CC96 3A E7 C0    >                        ld      a,(UBnkXScaled)                        ;
 453+ CC99 5F          >                        ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 453+ CC9A 7E          >                        ld      a,(hl)                        ; A = XX16 element
 453+ CC9B 57          >                        ld      d,a
 453+ CC9C ED 30       >                        mul
 453+ CC9E 7A          >                        ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 453+ CC9F 32 32 6C    >                        ld      (varT),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 454+ CCA2 23                                   inc     hl                                  ; move to sign byte
 455+ CCA3              XX12CalcXSign:          AequN1xorN2 UBnkXScaledSign,(hl)             ;
 455+ CCA3 3A E8 C0    >                        ld      a,(UBnkXScaledSign)
 455+ CCA6 AE          >                        xor     (hl)
 456+ CCA7 32 18 6C                             ld      (varS),a                            ; Set S to the sign of x_sign * sidev_x
 457+ CCAA 23                                   inc     hl
 458+ CCAB              XX12CalcY:              N0equN1byN2div256 varQ, (hl),(UBnkYScaled)       ; Q = XX16 * XX15 /256 using varQ to hold regXX15fx
 458+ CCAB 3A E9 C0    >                        ld      a,(UBnkYScaled)                        ;
 458+ CCAE 5F          >                        ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 458+ CCAF 7E          >                        ld      a,(hl)                        ; A = XX16 element
 458+ CCB0 57          >                        ld      d,a
 458+ CCB1 ED 30       >                        mul
 458+ CCB3 7A          >                        ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 458+ CCB4 32 16 6C    >                        ld      (varQ),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 459+ CCB7                                      ldCopyByte varT,varR                        ; R = T =  |sidev_x| * x_lo / 256
 459+ CCB7 3A 32 6C    >                        ld       a,(varT)
 459+ CCBA 32 17 6C    >                        ld       (varR),a
 460+ CCBD 23                                   inc     hl
 461+ CCBE                                      AequN1xorN2 UBnkYScaledSign,(hl)             ; Set A to the sign of y_sign * sidev_y
 461+ CCBE 3A EA C0    >                        ld      a,(UBnkYScaledSign)
 461+ CCC1 AE          >                        xor     (hl)
 462+ CCC2              ; (S)A = |sidev_x| * x_lo / 256  = |sidev_x| * x_lo + |sidev_y| * y_lo
 463+ CCC2 E5           STequSRplusAQ           push    hl
 464+ CCC3 CD 1F 7D                             call    baddll38                            ; JSR &4812 \ LL38   \ BADD(S)A=R+Q(SA) \ 1byte add (subtract)
 465+ CCC6 E1                                   pop     hl
 466+ CCC7 32 32 6C                             ld      (varT),a                            ; T = |sidev_x| * x_lo + |sidev_y| * y_lo
 467+ CCCA 23                                   inc     hl
 468+ CCCB              XX12CalcZ:              N0equN1byN2div256 varQ,(hl),(UBnkZScaled)       ; Q = |sidev_z| * z_lo / 256
 468+ CCCB 3A EB C0    >                        ld      a,(UBnkZScaled)                        ;
 468+ CCCE 5F          >                        ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 468+ CCCF 7E          >                        ld      a,(hl)                        ; A = XX16 element
 468+ CCD0 57          >                        ld      d,a
 468+ CCD1 ED 30       >                        mul
 468+ CCD3 7A          >                        ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 468+ CCD4 32 16 6C    >                        ld      (varQ),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 469+ CCD7                                      ldCopyByte varT,varR                        ; R = |sidev_x| * x_lo + |sidev_y| * y_lo
 469+ CCD7 3A 32 6C    >                        ld       a,(varT)
 469+ CCDA 32 17 6C    >                        ld       (varR),a
 470+ CCDD 23                                   inc     hl
 471+ CCDE                                      AequN1xorN2 UBnkZScaledSign,(hl)             ; A = sign of z_sign * sidev_z
 471+ CCDE 3A EC C0    >                        ld      a,(UBnkZScaledSign)
 471+ CCE1 AE          >                        xor     (hl)
 472+ CCE2              ; (S)A= |sidev_x| * x_lo + |sidev_y| * y_lo + |sidev_z| * z_lo
 473+ CCE2 CD 1F 7D                             call    baddll38                            ; JSR &4812 \ LL38   \ BADD(S)A=R+Q(SA)   \ 1byte add (subtract)
 474+ CCE5              ; Now we exit with A = result S = Sign
 475+ CCE5 C9                                   ret
 476+ CCE6
 477+ CCE6
 478+ CCE6                  DISPLAY "Tracing 4", $
 479+ CCE6
 480+ CCE6              ;-- LL51---------------------------------------------------------------------------------------------------------------------------
 481+ CCE6              ;TESTED OK
 482+ CCE6              ;XX12EquScaleDotOrientation:                         ; .LL51 \ -> &4832 \ XX12=XX15.XX16  each vector is 16-bit x,y,z
 483+ CCE6              XX12EquXX15DotProductXX16:
 484+ CCE6 01 00 00                             ld      bc,0                                ; LDX, LDY 0
 485+ CCE9 21 A2 C0                             ld      hl,UBnkTransmatSidevX
 486+ CCEC CD 96 CC                             call    XX12DotOneRow
 487+ CCEF 32 ED C0                             ld      (UBnkXX12xLo),a
 488+ CCF2 3A 18 6C                             ld      a,(varS)
 489+ CCF5 32 EE C0                             ld      (UBnkXX12xSign),a
 490+ CCF8 21 A8 C0                             ld      hl,UBnkTransmatRoofvX
 491+ CCFB CD 96 CC                             call    XX12DotOneRow
 492+ CCFE 32 EF C0                             ld      (UBnkXX12yLo),a
 493+ CD01 3A 18 6C                             ld      a,(varS)
 494+ CD04 32 F0 C0                             ld      (UBnkXX12ySign),a
 495+ CD07 21 AE C0                             ld      hl,UBnkTransmatNosevX
 496+ CD0A CD 96 CC                             call    XX12DotOneRow
 497+ CD0D 32 F1 C0                             ld      (UBnkXX12zLo),a
 498+ CD10 3A 18 6C                             ld      a,(varS)
 499+ CD13 32 F2 C0                             ld      (UBnkXX12zSign),a
 500+ CD16 C9                                   ret
 501+ CD17              ;--------------------------------------------------------------------------------------------------------
 502+ CD17                                      INCLUDE "../../Universe/Ships/CopyXX12ScaledToXX18.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/CopyXX12ScaledToXX18.asm
   1++CD17              CopyXX12ScaledToXX18:
   2++CD17              CopyResultToDrawCam:
   3++CD17                      ldCopyByte XX12         ,XX18             ; XX12+0 => XX18+0  Set XX18(2 0) = dot_sidev
   3++CD17 3A ED C0    >                        ld       a,(XX12)
   3++CD1A 32 DB C0    >                        ld       (XX18),a
   4++CD1D                      ldCopyByte XX12+1       ,XX18+2           ; XX12+1 => XX18+2
   4++CD1D 3A EE C0    >                        ld       a,(XX12+1)
   4++CD20 32 DD C0    >                        ld       (XX18+2),a
   5++CD23                      ldCopyByte XX12+2       ,XX18+3           ; XX12+2 => XX18+3  Set XX12+1 => XX18+2
   5++CD23 3A EF C0    >                        ld       a,(XX12+2)
   5++CD26 32 DE C0    >                        ld       (XX18+3),a
   6++CD29                      ldCopyByte XX12+3       ,XX18+5           ; XX12+3 => XX18+5
   6++CD29 3A F0 C0    >                        ld       a,(XX12+3)
   6++CD2C 32 E0 C0    >                        ld       (XX18+5),a
   7++CD2F                      ldCopyByte XX12+4       ,XX18+6           ; XX12+4 => XX18+6  Set XX18(8 6) = dot_nosev
   7++CD2F 3A F1 C0    >                        ld       a,(XX12+4)
   7++CD32 32 E1 C0    >                        ld       (XX18+6),a
   8++CD35                      ldCopyByte XX12+5       ,XX18+8           ; XX12+5 => XX18+8
   8++CD35 3A F2 C0    >                        ld       a,(XX12+5)
   8++CD38 32 E3 C0    >                        ld       (XX18+8),a
   9++CD3B C9                   ret
  10++CD3C
# file closed: ../../Tests/Vectors/../../Universe/Ships/CopyXX12ScaledToXX18.asm
 503+ CD3C                                      INCLUDE "../../Universe/Ships/CopyXX12toXX15.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/CopyXX12toXX15.asm
   1++CD3C              CopyXX12toXX15:         ldCopyByte  UBnkXX12xLo     ,UBnkXScaled        ; xlo
   1++CD3C 3A ED C0    >                        ld       a,(UBnkXX12xLo)
   1++CD3F 32 E7 C0    >                        ld       (UBnkXScaled),a
   2++CD42                                      ldCopyByte  UBnkXX12xSign   ,UBnkXScaledSign    ; xsg
   2++CD42 3A EE C0    >                        ld       a,(UBnkXX12xSign)
   2++CD45 32 E8 C0    >                        ld       (UBnkXScaledSign),a
   3++CD48                                      ldCopyByte  UBnkXX12yLo     ,UBnkYScaled        ; xlo
   3++CD48 3A EF C0    >                        ld       a,(UBnkXX12yLo)
   3++CD4B 32 E9 C0    >                        ld       (UBnkYScaled),a
   4++CD4E                                      ldCopyByte  UBnkXX12ySign   ,UBnkYScaledSign    ; xsg
   4++CD4E 3A F0 C0    >                        ld       a,(UBnkXX12ySign)
   4++CD51 32 EA C0    >                        ld       (UBnkYScaledSign),a
   5++CD54                                      ldCopyByte  UBnkXX12zLo     ,UBnkZScaled        ; xlo
   5++CD54 3A F1 C0    >                        ld       a,(UBnkXX12zLo)
   5++CD57 32 EB C0    >                        ld       (UBnkZScaled),a
   6++CD5A                                      ldCopyByte  UBnkXX12zSign   ,UBnkZScaledSign    ; xsg
   6++CD5A 3A F2 C0    >                        ld       a,(UBnkXX12zSign)
   6++CD5D 32 EC C0    >                        ld       (UBnkZScaledSign),a
   7++CD60 C9                                   ret
   8++CD61
# file closed: ../../Tests/Vectors/../../Universe/Ships/CopyXX12toXX15.asm
 504+ CD61                                      INCLUDE "../../Universe/Ships/CopyXX18toXX15.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/CopyXX18toXX15.asm
   1++CD61              CopyXX18toXX15:
   2++CD61              CopyDrawCamToScaled:
   3++CD61                      ldCopyByte  UBnkDrawCam0xLo ,UBnkXScaled        ; xlo
   3++CD61 3A DB C0    >                        ld       a,(UBnkDrawCam0xLo)
   3++CD64 32 E7 C0    >                        ld       (UBnkXScaled),a
   4++CD67                      ldCopyByte  UBnkDrawCam0xSgn,UBnkXScaledSign    ; xsg
   4++CD67 3A DD C0    >                        ld       a,(UBnkDrawCam0xSgn)
   4++CD6A 32 E8 C0    >                        ld       (UBnkXScaledSign),a
   5++CD6D                      ldCopyByte  UBnkDrawCam0yLo ,UBnkYScaled        ; xlo
   5++CD6D 3A DE C0    >                        ld       a,(UBnkDrawCam0yLo)
   5++CD70 32 E9 C0    >                        ld       (UBnkYScaled),a
   6++CD73                      ldCopyByte  UBnkDrawCam0ySgn,UBnkYScaledSign    ; xsg
   6++CD73 3A E0 C0    >                        ld       a,(UBnkDrawCam0ySgn)
   6++CD76 32 EA C0    >                        ld       (UBnkYScaledSign),a
   7++CD79                      ldCopyByte  UBnkDrawCam0zLo ,UBnkZScaled        ; xlo
   7++CD79 3A E1 C0    >                        ld       a,(UBnkDrawCam0zLo)
   7++CD7C 32 EB C0    >                        ld       (UBnkZScaled),a
   8++CD7F                      ldCopyByte  UBnkDrawCam0zSgn,UBnkZScaledSign    ; xsg
   8++CD7F 3A E3 C0    >                        ld       a,(UBnkDrawCam0zSgn)
   8++CD82 32 EC C0    >                        ld       (UBnkZScaledSign),a
   9++CD85 C9                   ret
  10++CD86
# file closed: ../../Tests/Vectors/../../Universe/Ships/CopyXX18toXX15.asm
 505+ CD86                                      INCLUDE "../../Universe/Ships/CopyXX18ScaledToXX15.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/CopyXX18ScaledToXX15.asm
   1++CD86 2A 20 C0     LoadCraftToCamera:      ld      hl,(UBnKxlo)            ; UBnKxlo, UBnKxhi
   2++CD89 ED 5B 22 C0                          ld      de,(UBnKxsgn)           ; UBnKxsgn, UBnKylo
   3++CD8D ED 4B 24 C0                          ld      bc,(UBnKyhi)            ; UBnKyhi, UBnKysgn
   4++CD91 22 DB C0                             ld      (UBnkDrawCam0xLo),hl    ; UBnkDrawCam0xLo, UBnkDrawCam0xHi
   5++CD94 ED 53 DD C0                          ld      (UBnkDrawCam0xSgn),de   ; UBnkDrawCam0xSgn,UBnkDrawCam0yLo
   6++CD98 ED 43 DF C0                          ld      (UBnkDrawCam0yHi),bc    ; UBnkDrawCam0yHi, UBnkDrawCam0ySgn
   7++CD9C
   8++CD9C 2A 26 C0                             ld      hl,(UBnKzlo)            ; UBnKzlo, UBnKzhi
   9++CD9F 3A 28 C0                             ld      a,(UBnKzsgn)             ; UBnKzlo
  10++CDA2 22 E1 C0                             ld      (UBnkDrawCam0zLo),hl    ; UBnkDrawCam0zLo, UBnkDrawCam0zHi
  11++CDA5 32 E3 C0                             ld      (UBnkDrawCam0zSgn),a    ; UBnkDrawCam0zSgn
  12++CDA8 C9                                   ret
  13++CDA9              ;                       ld      hl,UBnKxlo
  14++CDA9              ;                       ld      de,UBnkDrawCam0xLo
  15++CDA9              ;                       NineLDIInstrunctions                ; transfer 9 bytes
  16++CDA9 C9                                   ret
  17++CDAA
  18++CDAA 2A DB C0     CopyCameraToXX15Signed: ld  hl,(UBnkDrawCam0xLo)
  19++CDAD 3A DD C0                             ld  a,(UBnkDrawCam0xSgn)
  20++CDB0 B4                                   or  h
  21++CDB1 67                                   ld  h,a
  22++CDB2 22 E7 C0                             ld  (UBnkXScaled),hl
  23++CDB5 2A DE C0                             ld  hl,(UBnkDrawCam0yLo)
  24++CDB8 3A E0 C0                             ld  a,(UBnkDrawCam0ySgn)
  25++CDBB B4                                   or  h
  26++CDBC 67                                   ld  h,a
  27++CDBD 22 E9 C0                             ld  (UBnkYScaled),hl
  28++CDC0 2A E1 C0                             ld  hl,(UBnkDrawCam0zLo)
  29++CDC3 3A E3 C0                             ld  a,(UBnkDrawCam0zSgn)
  30++CDC6 B4                                   or  h
  31++CDC7 67                                   ld  h,a
  32++CDC8 22 EB C0                             ld  (UBnkZScaled),hl
  33++CDCB C9                                   ret
  34++CDCC
  35++CDCC              ;;;CopyXX18ScaledToXX15:
  36++CDCC              ;;;CopyDrawCamToScaledMatrix:
  37++CDCC              ;;;        ldCopyByte  UBnkDrawCam0zSgn, UBnkZScaledSign   ; XX18+8 => XX15+5
  38++CDCC              ;;;        ldCopyByte  UBnkDrawCam0xLo,  UBnkXScaled       ; XX18+0 => XX15+0
  39++CDCC              ;;;        ldCopyByte  UBnkDrawCam0xSgn, UBnkXScaledSign   ; XX18+2 => XX15+1
  40++CDCC              ;;;        ldCopyByte  UBnkDrawCam0yLo,  UBnkYScaled       ; XX18+3 => XX15+2
  41++CDCC              ;;;        ldCopyByte  UBnkDrawCam0ySgn, UBnkYScaledSign   ; XX18+5 => XX15+3
  42++CDCC              ;;;        ldCopyByte  UBnkDrawCam0zLo,  UBnkZScaled       ; XX18+6 => XX15+4
  43++CDCC              ;;;        ret
  44++CDCC
  45++CDCC              ;;;CopyXX15ToXX18Scaled:
  46++CDCC              ;;;CopyScaledMatrixToDrawCam:
  47++CDCC              ;;;        ldCopyByte UBnkZScaledSign,   UBnkDrawCam0zSgn  ; XX15+5 => XX18+8
  48++CDCC              ;;;        ldCopyByte UBnkXScaled,       UBnkDrawCam0xLo   ; XX15+0 => XX18+0
  49++CDCC              ;;;        ldCopyByte UBnkXScaledSign,   UBnkDrawCam0xSgn  ; XX15+1 => XX18+2
  50++CDCC              ;;;        ldCopyByte UBnkYScaled,       UBnkDrawCam0yLo   ; XX15+2 => XX18+3
  51++CDCC              ;;;        ldCopyByte UBnkYScaledSign,   UBnkDrawCam0ySgn  ; XX15+3 => XX18+5
  52++CDCC              ;;;        ldCopyByte UBnkZScaled,       UBnkDrawCam0zLo   ; XX15+4 => XX18+6
  53++CDCC              ;;;        ret
  54++CDCC
  55++CDCC
  56++CDCC              XX15EquXX15AddXX18:
  57++CDCC              LL94Z:
  58++CDCC 26 00                ld      h,0                                                     ;           AddZ = FaceData (XX12)z +  ShipPos (XX18)z
  59++CDCE 16 00                ld      d,0                                                     ;
  60++CDD0 3A EB C0             ld      a,(UBnkZScaled)                                         ;
  61++CDD3 6F                   ld      l,a                                                     ;
  62++CDD4 3A EC C0             ld      a,(UBnkZScaledSign)                                     ;
  63++CDD7 47                   ld      b,a                                                     ;
  64++CDD8 3A E1 C0             ld      a,(UBnkDrawCam0zLo)                                     ;
  65++CDDB 5F                   ld      e,a                                                     ;
  66++CDDC 3A E3 C0             ld      a,(UBnkDrawCam0zSgn)                                    ;
  67++CDDF 4F                   ld      c,a                                                     ;
  68++CDE0 CD 33 00             call    ADDHLDESignBC                                           ;
  69++CDE3 47                   ld      b,a                                                     ;
  70++CDE4 7C                   ld      a,h                                                     ;
  71++CDE5 78                   ld      a,b                                                     ;           else  Scaled (XX15) Z = AddZ
  72++CDE6 32 EC C0             ld      (UBnkZScaledSign),a                                     ;
  73++CDE9 7D                   ld      a,l                                                     ;
  74++CDEA 32 EB C0             ld      (UBnkZScaled),a                                         ;           endif
  75++CDED              LL94X:
  76++CDED 26 00                ld      h,0                                                     ;           AddZ = FaceData (XX12)z +  ShipPos (XX18)z
  77++CDEF 16 00                ld      d,0                                                     ;
  78++CDF1 3A E7 C0             ld      a,(UBnkXScaled)                                         ;
  79++CDF4 6F                   ld      l,a                                                     ;
  80++CDF5 3A E8 C0             ld      a,(UBnkXScaledSign)                                     ;
  81++CDF8 47                   ld      b,a                                                     ;
  82++CDF9 3A DB C0             ld      a,(UBnkDrawCam0xLo)                                     ;
  83++CDFC 5F                   ld      e,a                                                     ;
  84++CDFD 3A DD C0             ld      a,(UBnkDrawCam0xSgn)                                    ;
  85++CE00 4F                   ld      c,a                                                     ;
  86++CE01 CD 33 00             call    ADDHLDESignBC                                           ;
  87++CE04 47                   ld      b,a                                                     ;
  88++CE05 7C                   ld      a,h                                                     ;
  89++CE06 78                   ld      a,b                                                     ;           else  Scaled (XX15) Z = AddZ
  90++CE07 32 E8 C0             ld      (UBnkXScaledSign),a                                     ;
  91++CE0A 7D                   ld      a,l                                                     ;
  92++CE0B 32 E7 C0             ld      (UBnkXScaled),a                                         ;           endif
  93++CE0E              LL94Y:
  94++CE0E 26 00                ld      h,0                                                     ;           AddZ = FaceData (XX12)z +  ShipPos (XX18)z
  95++CE10 16 00                ld      d,0                                                     ;
  96++CE12 3A E9 C0             ld      a,(UBnkYScaled)                                         ;
  97++CE15 6F                   ld      l,a                                                     ;
  98++CE16 3A EA C0             ld      a,(UBnkYScaledSign)                                     ;
  99++CE19 47                   ld      b,a                                                     ;
 100++CE1A 3A DE C0             ld      a,(UBnkDrawCam0yLo)                                     ;
 101++CE1D 5F                   ld      e,a                                                     ;
 102++CE1E 3A E0 C0             ld      a,(UBnkDrawCam0ySgn)                                    ;
 103++CE21 4F                   ld      c,a                                                     ;
 104++CE22 CD 33 00             call    ADDHLDESignBC                                           ;
 105++CE25 47                   ld      b,a                                                     ;
 106++CE26 7C                   ld      a,h                                                     ;
 107++CE27 78                   ld      a,b                                                     ;           else  Scaled (XX15) Z = AddZ
 108++CE28 32 EA C0             ld      (UBnkYScaledSign),a                                     ;
 109++CE2B 7D                   ld      a,l                                                     ;
 110++CE2C 32 E9 C0             ld      (UBnkYScaled),a                                         ;
 111++CE2F C9                   ret
 112++CE30
# file closed: ../../Tests/Vectors/../../Universe/Ships/CopyXX18ScaledToXX15.asm
 506+ CE30                                      INCLUDE "../../Universe/Ships/CopyXX12ToScaled.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/CopyXX12ToScaled.asm
   1++CE30              CopyXX12ToScaled:
   2++CE30              CopyResultToScaled:
   3++CE30                      ldCopyByte  XX12+0,UBnkXScaled      ; xnormal lo
   3++CE30 3A ED C0    >                        ld       a,(XX12+0)
   3++CE33 32 E7 C0    >                        ld       (UBnkXScaled),a
   4++CE36                      ldCopyByte  XX12+2,UBnkYScaled      ; ynormal lo
   4++CE36 3A EF C0    >                        ld       a,(XX12+2)
   4++CE39 32 E9 C0    >                        ld       (UBnkYScaled),a
   5++CE3C                      ldCopyByte  XX12+4,UBnkZScaled      ; znormal lo and leaves a holding zscaled normal
   5++CE3C 3A F1 C0    >                        ld       a,(XX12+4)
   5++CE3F 32 EB C0    >                        ld       (UBnkZScaled),a
   6++CE42 C9                   ret
   7++CE43
# file closed: ../../Tests/Vectors/../../Universe/Ships/CopyXX12ToScaled.asm
 507+ CE43              ;--------------------------------------------------------------------------------------------------------
 508+ CE43                                      INCLUDE "../../Maths/Utilities/DotProductXX12XX15.asm"
# file opened: ../../Tests/Vectors/../../Maths/Utilities/DotProductXX12XX15.asm
   1++CE43              ;;; Q = XX12 xLo ,A = XX15 xLo
   2++CE43              ;;; T = A * Q/256 Usgined  (FMLTU)
   3++CE43              ;;; S = XX12 XSign Xor XX15 XSign
   4++CE43              ;;; Q = XX12 Ynormal Lo, A = XX15+2 (y lo)
   5++CE43              ;;; Q = A * Q/256 Usigned (FMLTI)
   6++CE43              ;;; R = T
   7++CE43              ;;; A = XX12+3 (ySign) Xor XX15+3 (ySign)
   8++CE43              ;;; T = BADD s(A) = R + Q(SA) (xdot + ydot)
   9++CE43              ;;; Q = XX12+4 (znormal lo) A = XX15+4 z lo
  10++CE43              ;;; Q = A * Q /256 usigned (zdot)
  11++CE43              ;;; R = T
  12++CE43              ;;; A - XX15+ 5 Zsign Xor XX12+5 Z Sign
  13++CE43
  14++CE43
  15++CE43
  16++CE43
  17++CE43
  18++CE43              MacroAequDxEdiv256usgn:	MACRO
  19++CE43 ~            						mul
  20++CE43 ~            						ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
  21++CE43              						ENDM
  22++CE43              DotProductXX12XX15:
  23++CE43 3A ED C0             ld          a,(UBnkXX12xLo)         ; Use e as var Q for xnormal lo
  24++CE46                      JumpIfAIsZero dotxskipzero
  24++CE46 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  24++CE47 CA 64 CE    >                        jp	    z, dotxskipzero
  25++CE4A 5F                   ld          e,a
  26++CE4B 3A E7 C0             ld          a,(UBnkXScaled)         ; use d as XX12 world xform x, e = norm x
  27++CE4E 57                   ld          d,a                     ; de = xx12 x signed
  28++CE4F                      JumpIfAIsZero dotxskipzero
  28++CE4F A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  28++CE50 CA 64 CE    >                        jp	    z, dotxskipzero
  29++CE53 ED 30        		mul
  30++CE55 42                   ld          b,d                     ; b = result
  31++CE56 3A EE C0             ld          a,(UBnkXX12xSign)
  32++CE59 21 E8 C0             ld          hl,UBnkXScaledSign
  33++CE5C AE                   xor         (hl)
  34++CE5D E6 80                and         $80                     ; so sign bit only
  35++CE5F FD 67                ld          iyh ,a                   ; we actually need to preserve sign in iyh here
  36++CE61 C3 68 CE             jp          dotmuly
  37++CE64              dotxskipzero:
  38++CE64 AF                   xor         a
  39++CE65 47                   ld          b,a
  40++CE66 FD 67                ld          iyh,a
  41++CE68              dotmuly:
  42++CE68              ; now we have b = XX12 x &d  norm x signed
  43++CE68 3A EF C0             ld          a,(UBnkXX12yLo)
  44++CE6B                      JumpIfAIsZero dotyskipzero
  44++CE6B A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  44++CE6C CA 8B CE    >                        jp	    z, dotyskipzero
  45++CE6F 5F                   ld          e,a
  46++CE70 3A E9 C0             ld          a,(UBnkYScaled)         ; XX15+2
  47++CE73                      JumpIfAIsZero dotyskipzero
  47++CE73 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  47++CE74 CA 8B CE    >                        jp	    z, dotyskipzero
  48++CE77 57                   ld          d,a                     ; de = xx12 x signed
  49++CE78 ED 30                mul
  50++CE7A 4A                   ld          c,d                     ; c = result
  51++CE7B DD 69                ld          ixl,c
  52++CE7D 3A F0 C0             ld          a,(UBnkXX12ySign)       ; A = ysg
  53++CE80 21 EA C0             ld          hl, UBnkYScaledSign     ; a= y sign XOR Y scaled sign
  54++CE83 AE                   xor         (hl)                    ; XX15+3
  55++CE84 E6 80                and         $80                     ; do b = x mul c = y mul, iyh = sign for b and a = sign for c
  56++CE86 DD 67                ld          ixh,a
  57++CE88 C3 8F CE             jp          dotaddxy
  58++CE8B              dotyskipzero:
  59++CE8B AF                   xor         a
  60++CE8C 4F                   ld          c,a
  61++CE8D DD 67                ld          ixh,a
  62++CE8F              dotaddxy:
  63++CE8F              ; Optimise later as this is 16 bit
  64++CE8F 26 00                ld          h,0                     ;
  65++CE91 68                   ld          l,b                     ; hl = xlo + x scaled
  66++CE92 16 00                ld          d,0                     ;
  67++CE94 59                   ld          e,c                     ; de = ylo + yscaled
  68++CE95 FD 44                ld          b,iyh                   ; b = sign of xlo + xscaled
  69++CE97 4F                   ld          c,a                     ; c = sign of ylo + yscaled
  70++CE98 CD 33 00             call ADDHLDESignBC                  ; so now hl = result so will push sign to h
  71++CE9B 47                   ld          b,a                     ; b = resultant sign , hl = add so far
  72++CE9C 3A F1 C0             ld          a,(UBnkXX12zLo)         ;
  73++CE9F                      JumpIfAIsZero dotzskipzero
  73++CE9F A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  73++CEA0 CA C5 CE    >                        jp	    z, dotzskipzero
  74++CEA3 5F                   ld          e,a                     ;
  75++CEA4 3A EB C0             ld          a,(UBnkZScaled)         ;
  76++CEA7                      JumpIfAIsZero dotzskipzero
  76++CEA7 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  76++CEA8 CA C5 CE    >                        jp	    z, dotzskipzero
  77++CEAB 57                   ld          d,a
  78++CEAC ED 30                mul
  79++CEAE E5                   push        hl                      ; save prev result
  80++CEAF 3A EC C0             ld          a,(UBnkZScaledSign)
  81++CEB2 21 F2 C0             ld          hl, UBnkXX12zSign       ; XX15+5
  82++CEB5 AE                   xor         (hl)                    ; hi sign
  83++CEB6 E6 80                and         $80                     ; a = sign of multiply
  84++CEB8 4F                   ld          c,a                     ; c = sign of z lo & z scaled
  85++CEB9 E1                   pop         hl
  86++CEBA 5A                   ld          e,d
  87++CEBB 16 00                ld          d,0
  88++CEBD CD 33 00             call ADDHLDESignBC
  89++CEC0 32 18 6C             ld          (varS),a
  90++CEC3 7D                   ld          a,l
  91++CEC4 C9                   ret                                 ; returns with A = value, varS = sign
  92++CEC5              dotzskipzero:                               ; if we got here then z was zero so no component so just tidy up from last add
  93++CEC5 78                   ld          a,b
  94++CEC6 32 18 6C             ld          (varS),a
  95++CEC9 7D                   ld          a,l
  96++CECA C9                   ret
  97++CECB              ;;;;       DotProductXX12XX15:
  98++CECB              ;;;;       ld          a,(UBnkXX12xLo)         ; Use e as var Q for xnormal lo
  99++CECB              ;;;;       ld          e,a
 100++CECB              ;;;;       ld          a,(UBnkXScaled)         ; use d as XX12 world xform x, e = norm x
 101++CECB              ;;;;       ld          d,a                     ; de = xx12 x signed
 102++CECB              ;;;;		; FMLTU	\ A=A*Q/256unsg using D as A and E as Q
 103++CECB              ;;;;		mul
 104++CECB              ;;;;       ld          b,d                     ; b as var T
 105++CECB              ;;;;       ld          a,(UBnkXX12xSign)
 106++CECB              ;;;;       ld          hl,UBnkXScaledSign
 107++CECB              ;;;;       xor         (hl)
 108++CECB              ;;;;       and         $80                     ; so sign bit only
 109++CECB              ;;;;       ld          (varS),a                ; we did use c as S \ S	\ x-sign, but we actually need it in varS for BADD
 110++CECB              ;;;; now we have b = XX12 x & norm x signed
 111++CECB              ;;;; by here B = xlo & xscaled C = result sign
 112++CECB              ;;;;       ld          a,(UBnkXX12yLo)
 113++CECB              ;;;;       ld          e,a
 114++CECB              ;;;;       ld          a,(UBnkYScaled)         ; XX15+2
 115++CECB              ;;;;		ld          d,a						; MISSED THIS EARLIER BUG FIX
 116++CECB              ;;;;       mul
 117++CECB              ;;;;       ld          a,d
 118++CECB              ;;;;       ld          (varQ),a                ; Q = Y y-dot
 119++CECB              ;;;;       ld          a,b                     ; get back T from above held in b
 120++CECB              ;;;;       ld          (varR),a                ; R= b \ T	\ x-dot
 121++CECB              ;;;;       ld          a,(UBnkXX12ySign)       ; A = ysg
 122++CECB              ;;;;       ld          hl, UBnkYScaledSign     ; a= y sign XOR Y scaled sign
 123++CECB              ;;;;       xor         (hl)                    ; XX15+3
 124++CECB              ;;;;       and         $80
 125++CECB              ;;;;       call        baddll38                ; LL38	\ BADD(S)A=R+Q(SA)   \ 1byte add (subtract)
 126++CECB              ;;;;       ld          (varT),a                ; var T	\ xdot+ydot
 127++CECB              ;;;;       ld          a,(UBnkXX12zLo)         ; use d as  varQ        ; XX12+4	\ znormal lo to varQ
 128++CECB              ;;;;       ld          e,a                     ; use e as var Q
 129++CECB              ;;;;       ld          a,(UBnkZScaled)         ;
 130++CECB              ;;;;       ld          d,a
 131++CECB              ;;;;       mul
 132++CECB              ;;;;       ld          a,d
 133++CECB              ;;;;       ld          (varQ),a                ; Q	\ zdot
 134++CECB              ;;;;       ldCopyByte  varT,varR               ; copy T to R so R = resutl of previous calc
 135++CECB              ;;;;       ld          a,(UBnkZScaledSign)
 136++CECB              ;;;;       ld          hl, UBnkXX12zSign       ; XX15+5
 137++CECB              ;;;;       xor         (hl)                    ; hi sign
 138++CECB              ;;;;       and         $80
 139++CECB              ;;;;       call        baddll38                ; LL38	\ BADD(S)A=R+Q(SA)   \ 1byte add (subtract)
 140++CECB              ;;;;       ret                                 ; returns with A = value, varS = sign
 141++CECB
# file closed: ../../Tests/Vectors/../../Maths/Utilities/DotProductXX12XX15.asm
 509+ CECB              ;--------------------------------------------------------------------------------------------------------
 510+ CECB              ; scale Normal. IXL is xReg and A is loaded with XX17 holds the scale factor to apply
 511+ CECB              ; Not Used in code      include "Universe/Ships/ScaleNormal.asm"
 512+ CECB              ;--------------------------------------------------------------------------------------------------------
 513+ CECB                                      INCLUDE "../../Universe/Ships/ScaleObjectDistance.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/ScaleObjectDistance.asm
   1++CECB              ScaleObjectDistance:
   2++CECB              ; ">ScaleObjectDistance, scales camera location and returns c = scaling factor (equiv of X reg)"
   3++CECB 3A 4A C4             ld      a,(QAddr)                   ; Hull byte #18 normals scaled by 2^Q% DtProd^XX2  their comment   Dot product gives  normals' visibility in XX2
   4++CECE 4F                   ld      c,a                         ; c = Q factor for scaling of normals
   5++CECF              LL90:                                       ; scaling object distance
   6++CECF 3A E2 C0             ld      a,(UBnkDrawCam0zHi)         ; z_hi
   7++CED2 47                   ld      b,a                         ; z_hi (yReg)
   8++CED3                      ReturnIfAIsZero                     ; if zHi 0 test ifis object close/small, i.e. zhi already zero then we are done
   8++CED3 A7          >                        and     a
   8++CED4 C8          >                        ret     z
   9++CED5              LL90Loop:
  10++CED5              ; Loop dividing camera by 2 until zhi is 0 and updating scale factor
  11++CED5 0C                   inc     c                           ; LL90+3 \ repeat INWK z brought closer, take Qscale X up
  12++CED6                      ShiftMem16Right1 UBnkDrawCam0yLo    ; cam Y /= 2
  12++CED6 2A DE C0    >                    ld    hl,(UBnkDrawCam0yLo)
  12++CED9 CB 3C       >                    srl   h
  12++CEDB CB 1D       >                    rr    l
  12++CEDD 22 DE C0    >                    ld    (UBnkDrawCam0yLo),hl
  13++CEE0                      ShiftMem16Right1 UBnkDrawCam0xLo    ; cam X /= 2
  13++CEE0 2A DB C0    >                    ld    hl,(UBnkDrawCam0xLo)
  13++CEE3 CB 3C       >                    srl   h
  13++CEE5 CB 1D       >                    rr    l
  13++CEE7 22 DB C0    >                    ld    (UBnkDrawCam0xLo),hl
  14++CEEA                      ShiftMem16Right1 UBnkDrawCam0zLo    ; cam Z /= 2
  14++CEEA 2A E1 C0    >                    ld    hl,(UBnkDrawCam0zLo)
  14++CEED CB 3C       >                    srl   h
  14++CEEF CB 1D       >                    rr    l
  14++CEF1 22 E1 C0    >                    ld    (UBnkDrawCam0zLo),hl
  15++CEF4 7C                   ld      a,h                         ; last shift will result in zhi adjusted into h reg.
  16++CEF5                      JumpIfAIsNotZero LL90Loop           ; loop until z hi = 0 this gives scalinging in c
  16++CEF5 A7          >                        and     a
  16++CEF6 C2 D5 CE    >                        jp	    nz,LL90Loop
  17++CEF9 C9                   ret
  18++CEFA
# file closed: ../../Tests/Vectors/../../Universe/Ships/ScaleObjectDistance.asm
 514+ CEFA              ;--------------------------------------------------------------------------------------------------------
 515+ CEFA
 516+ CEFA              ; Backface cull
 517+ CEFA              ; is the angle between the ship -> camera vector and the normal of the face as long as both are unit vectors soo we can check that normal z > 0
 518+ CEFA              ; normal vector = cross product of ship ccordinates
 519+ CEFA              ;
 520+ CEFA                                      INCLUDE "../../Universe/Ships/CopyFaceToXX15.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/CopyFaceToXX15.asm
   1++CEFA 7E           CopyFaceToXX15:         ld      a,(hl)                      ; get Normal byte 0                                                                    ;;;     if visibility (bits 4 to 0 of byte 0) > XX4
   2++CEFB 47                                   ld      b,a                                                    ;;;
   3++CEFC E6 80                                and     SignOnly8Bit
   4++CEFE 32 E8 C0                             ld      (UBnkXScaledSign),a           ; write Sign bits to x sign                                                            ;;;
   5++CF01 78                                   ld      a,b
   6++CF02 CB 27                                sla     a                           ; move y sign to bit 7                                                                 ;;;   copy sign bits to XX12
   7++CF04 47                                   ld      b,a
   8++CF05 E6 80                                and     SignOnly8Bit
   9++CF07 32 EA C0                             ld      (UBnkYScaledSign),a           ;                                                                                      ;;;
  10++CF0A 78                                   ld      a,b
  11++CF0B CB 27                                sla     a                           ; move y sign to bit 7                                                                 ;;;   copy sign bits to XX12
  12++CF0D E6 80                                and     SignOnly8Bit
  13++CF0F 32 EC C0                             ld      (UBnkZScaledSign),a           ;                                                                                      ;;;
  14++CF12 23                                   inc     hl                          ; move to X ccord
  15++CF13 7E                                   ld      a,(hl)                      ;                                                                                      ;;;   XX12 x,y,z lo = Normal[loop].x,y,z
  16++CF14 32 E7 C0                             ld      (UBnkXScaled),a                                                                                                    ;;;
  17++CF17 23                                   inc     hl                                                                                                                 ;;;
  18++CF18 7E                                   ld      a,(hl)                      ;                                                                                      ;;;
  19++CF19 32 E9 C0                             ld      (UBnkYScaled),a                                                                                                    ;;;
  20++CF1C 23                                   inc     hl                                                                                                                 ;;;
  21++CF1D 7E                                   ld      a,(hl)                      ;                                                                                      ;;;
  22++CF1E 32 EB C0                             ld      (UBnkZScaled),a
  23++CF21 C9                                   ret
  24++CF22
# file closed: ../../Tests/Vectors/../../Universe/Ships/CopyFaceToXX15.asm
 521+ CF22                                      INCLUDE "../../Universe/Ships/CopyFaceToXX12.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/CopyFaceToXX12.asm
   1++CF22 7E           CopyFaceToXX12:         ld      a,(hl)                      ; get Normal byte 0                                                                    ;;;     if visibility (bits 4 to 0 of byte 0) > XX4
   2++CF23 47                                   ld      b,a                         ; save sign bits to b
   3++CF24 E6 80                                and     SignOnly8Bit
   4++CF26 32 EE C0                             ld      (UBnkXX12xSign),a           ; write Sign bits to x sign                                                            ;;;
   5++CF29 78                                   ld      a,b
   6++CF2A CB 27                                sla     a                           ; move y sign to bit 7                                                                 ;;;   copy sign bits to XX12
   7++CF2C 47                                   ld      b,a
   8++CF2D E6 80                                and     SignOnly8Bit
   9++CF2F 32 F0 C0                             ld      (UBnkXX12ySign),a           ;                                                                                      ;;;
  10++CF32 78                                   ld      a,b
  11++CF33 CB 27                                sla     a                           ; move y sign to bit 7                                                                 ;;;   copy sign bits to XX12
  12++CF35 E6 80                                and     SignOnly8Bit
  13++CF37 32 F2 C0                             ld      (UBnkXX12zSign),a           ;                                                                                      ;;;
  14++CF3A 23                                   inc     hl                          ; move to X ccord
  15++CF3B 7E                                   ld      a,(hl)                      ;                                                                                      ;;;   XX12 x,y,z lo = Normal[loop].x,y,z
  16++CF3C 32 ED C0                             ld      (UBnkXX12xLo),a                                                                                                    ;;;
  17++CF3F 23                                   inc     hl                                                                                                                 ;;;
  18++CF40 7E                                   ld      a,(hl)                      ;                                                                                      ;;;
  19++CF41 32 EF C0                             ld      (UBnkXX12yLo),a                                                                                                    ;;;
  20++CF44 23                                   inc     hl                                                                                                                 ;;;
  21++CF45 7E                                   ld      a,(hl)                      ;                                                                                      ;;;
  22++CF46 32 F1 C0                             ld      (UBnkXX12zLo),a
  23++CF49 C9                                   ret
  24++CF4A
# file closed: ../../Tests/Vectors/../../Universe/Ships/CopyFaceToXX12.asm
 522+ CF4A              ;--------------------------------------------------------------
 523+ CF4A              ;--------------------------------------------------------------
 524+ CF4A                                      INCLUDE "../../ModelRender/BackfaceCull.asm"
# file opened: ../../Tests/Vectors/../../ModelRender/BackfaceCull.asm
   1++CF4A              ;    DEFINE DEBUGDRAWDISTANCE 1
   2++CF4A                  DEFINE CHECKDOTSHIPDATA  1
   3++CF4A               ;   DEFINE DEBUGFORCEFACEDRAW 1
   4++CF4A 00           CurrentNormIdx  DB 0
   5++CF4B              ; SomeFacesVisible:
   6++CF4B              ; EE29:
   7++CF4B
   8++CF4B              ;   Backface cull logic  line of sight vector . face normal vector
   9++CF4B              ;       line of sight vector . face normal vector
  10++CF4B              ;       => line of sight vector = [x y z] + face normal vector
  11++CF4B              ;       Where [x y z] =
  12++CF4B              ;                                               [ [x y z] . sidev ]
  13++CF4B              ;                    projected [x y z] vector = [ [x y z] . roofv ]
  14++CF4B              ;                                               [ [x y z] . nosev ]
  15++CF4B              ;
  16++CF4B              ;   so project the [x y z] vector into the face's normal space
  17++CF4B              ;  line of sight vector = projected [x y z] vector + face normal vector
  18++CF4B              ;                         [ [x y z] . sidev ]   [ normal_x ]
  19++CF4B              ;                       = [ [x y z] . roofv ] + [ normal_y ]
  20++CF4B              ;                         [ [x y z] . nosev ]   [ normal_z ]
  21++CF4B              ;
  22++CF4B              ;                         [ [x y z] . sidev + normal_x ]
  23++CF4B              ;                       = [ [x y z] . roofv + normal_y ]
  24++CF4B              ;                         [ [x y z] . nosev + normal_z ]
  25++CF4B              ;
  26++CF4B              ; so
  27++CF4B              ;              visibility = [ [x y z] . sidev + normal_x ]   [ normal_x ]
  28++CF4B              ;                            [ [x y z] . roofv + normal_y ] . [ normal_y ]
  29++CF4B              ;                           [ [x y z] . nosev + normal_z ]   [ normal_z ]
  30++CF4B              ;
  31++CF4B              ; where face is visible if visibility < 0
  32++CF4B              ;
  33++CF4B              ;   so we set XX15 to [x y z] . sidev
  34++CF4B              ;                     [x y z] . roofv
  35++CF4B              ;                     [x y z] . nosev
  36++CF4B              ;
  37++CF4B
  38++CF4B
  39++CF4B
  40++CF4B 3A E2 C0     ScaleDrawcam:           ld      a,(UBnkDrawCam0zHi)         ; if z hi is 0 then we have scaled XX18
  41++CF4E                                      JumpIfAIsZero .ScaleDone            ;
  41++CF4E A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  41++CF4F CA 7B CF    >                        jp	    z, .ScaleDone
  42++CF52 2A DB C0                             ld      hl,(UBnkDrawCam0xLo)        ; pull postition into registers
  43++CF55 ED 5B DE C0                          ld      de,(UBnkDrawCam0yLo)        ; we only pull in if needed to save fetches
  44++CF59 ED 4B E1 C0                          ld      bc,(UBnkDrawCam0zLo)        ;
  45++CF5D FD 2C        .ScaleNormalLoop:       inc     iyl                         ; Q goes up by one
  46++CF5F                                      ShiftHLRight1                       ; divide cam position by 2
  46++CF5F CB 3C       >			   srl h
  46++CF61 CB 1D       >			   rr  l
  47++CF63                                      ShiftDERight1                       ;
  47++CF63 CB 3A       >			   srl d
  47++CF65 CB 1B       >			   rr  e
  48++CF67                                      ShiftBCRight1                       ;
  48++CF67 CB 38       >			   srl b
  48++CF69 CB 19       >			   rr  c
  49++CF6B 78                                   ld      a,b                         ; loop if not scaled down
  50++CF6C                                      JumpIfAIsNotZero .ScaleNormalLoop     ;
  50++CF6C A7          >                        and     a
  50++CF6D C2 5D CF    >                        jp	    nz,.ScaleNormalLoop
  51++CF70 22 DB C0                             ld      (UBnkDrawCam0xLo),hl        ; save position back to XX18
  52++CF73 ED 53 DE C0                          ld      (UBnkDrawCam0yLo),de        ;
  53++CF77 ED 43 E1 C0                          ld      (UBnkDrawCam0zLo),bc        ;
  54++CF7B FD 7D        .ScaleDone:             ld      a,iyl
  55++CF7D 32 1D 6C                             ld      (varXX17),a                  ; XX17 = normal scale factor for current ship adjusted for camera
  56++CF80 C9                                   ret
  57++CF81
  58++CF81 3A 28 C0     CheckVisible:           ld      a,(UBnKzsgn)                 ; Is the ship behind us
  59++CF84 E6 80        .CheckBehind:           and     SignOnly8Bit                 ; which means z sign is negative
  60++CF86 20 2A                                jr      nz,.ShipNoDraw               ; .
  61++CF88 2A 26 C0     .CheckViewPort:         ld      hl,(UBnKzlo)                 ; now check to see if its within 90 degree arc
  62++CF8B 7C                                   ld      a,h
  63++CF8C                                      JumpIfAGTENusng ShipMaxDistance, .ShipNoDraw
  63++CF8C FE C0       >                        cp     ShipMaxDistance
  63++CF8E D2 B2 CF    >                        jp		nc,.ShipNoDraw
  64++CF91 ED 5B 20 C0  .CheckXAxis:            ld      de,(UBnKxlo)                 ; if abs x > abx z then its out side of view port
  65++CF95 CD 3B 7A                             call    compare16HLDE
  66++CF98 38 18                                jr      c,.ShipNoDraw               ; ship is too far out on the X Axis
  67++CF9A ED 5B 23 C0  .CheckYAxis:            ld      de,(UBnKylo)                ; if abs y > abx z then its out side of view port
  68++CF9E CD 3B 7A                             call    compare16HLDE
  69++CFA1 38 0F                                jr      c,.ShipNoDraw               ; ship is too far out on the X Axis
  70++CFA3                                      IFDEF   CHECKDOTSHIPDATA
  71++CFA3 3A 45 C4     .CheckDotV2:                ld      a,(DotAddr)
  72++CFA6                                          JumpIfAGTENusng h, .DrawFull
  72++CFA6 BC          >                        cp     h
  72++CFA7 D2 AD CF    >                        jp		nc,.DrawFull
  73++CFAA C3 B6 CF                                 jp      .ShipIsADot
  74++CFAD CD 6D C6     .DrawFull:                  call    UnivVisibleNonDot           ;
  75++CFB0                                          ClearCarryFlag
  75++CFB0 B7          >                        or a
  76++CFB1 C9                                       ret
  77++CFB2                                      ELSE
  78++CFB2 ~            .CalculateXX4:              ShiftHLRight1                       ; hl = z pos / 8
  79++CFB2 ~                                        ShiftHLRight1                       ; .
  80++CFB2 ~                                        ShiftHLRight1                       ; .
  81++CFB2 ~                                        ld      a,h
  82++CFB2 ~                                        srl     a                           ; if a / 16 <> 0 then ship is a dot
  83++CFB2 ~            .DrawAsDotCheck:            JumpIfNotZero   .ShipIsADot
  84++CFB2 ~                                        ; Check visbility distance
  85++CFB2 ~            .SetXX4Dist:                ;break
  86++CFB2 ~                                        ld      a,l
  87++CFB2 ~                                        rra                                 ; l may have had bit 0 of h carried in
  88++CFB2 ~                                        srl     a                           ; so move it to bit 4 giving A as distance $000xxxxx
  89++CFB2 ~                                        srl     a
  90++CFB2 ~                                        srl     a
  91++CFB2 ~                                        ld      (UBnkDrawAllFaces),a        ; XX4 = "all faces" distance
  92++CFB2 ~                                        call    UnivVisibleNonDot               ;
  93++CFB2 ~                                        ClearCarryFlag
  94++CFB2 ~                                        ret
  95++CFB2                                      ENDIF
  96++CFB2 CD 81 C6     .ShipNoDraw:            call    UnivInvisible
  97++CFB5 C9                                   ret
  98++CFB6              .ShipIsADot:            IFDEF DEBUGDRAWDISTANCE
  99++CFB6 ~                                        call    UnivVisible  ;
 100++CFB6                                      ELSE
 101++CFB6 CD 78 C6                                 call    UnivVisibleDot
 102++CFB9                                      ENDIF
 103++CFB9 C9                                   ret
 104++CFBA
 105++CFBA                                                  DISPLAY "TODO:remove all teh processing of rotmat to load craft to camera as its already been done"
 106++CFBA              CullV2:                 ReturnIfMemisZero FaceCtX4Addr      ;
 106++CFBA 3A 44 C4    >                        ld   a,(FaceCtX4Addr)
 106++CFBD A7          >                        and a
 106++CFBE C8          >                        ret    z
 107++CFBF                                      ;break
 108++CFBF CD CD CA                             call    CopyRotmatToTransMat        ; XX16 = UBNKRotMat
 109++CFC2 CD 59 6A                             call    ScaleXX16Matrix197          ; scale rotation matrix in XX16
 110++CFC5 CD 86 CD                             call    LoadCraftToCamera           ; XX18 = camera
 111++CFC8                                      ;call    CopyCameraToXX15Signed      ; Copy the camera to XX15 as signed 15 bit
 112++CFC8 3A 4A C4     .BackfaceLoop:          ld      a,(QAddr)                   ;
 113++CFCB FD 6F                                ld      iyl,a                       ; iyl = scale factor
 114++CFCD              ; By this point XX18 = scaled draw cam and iyl = scale factor
 115++CFCD CD 4B CF                             call    ScaleDrawcam                ; XX18 = scaled camera XX17 = scale
 116++CFD0 CD AA CD                             call    CopyCameraToXX15Signed      ; Xx18 -> xx15 sign + 15 bit
 117++CFD3 CD EC 69     .LL91:                  call    XX12EquNodeDotXX16          ; xx12 = Scaled Camera . Rotation matrix (Note Xx16 no Xx16 inv)
 118++CFD6 CD 17 CD                             call    CopyXX12ScaledToXX18        ; now xx18 = XX12 = xx15.xx16
 119++CFD9 21 0A C6     .PrepNormals:           ld      hl,UBnkHullNormals                                                                                                 ;;; V = address of Normal start
 120++CFDC 22 1C 6B                             ld      (varV),hl
 121++CFDF 3A 44 C4                             ld      a,(FaceCtX4Addr)                                        ; For each face
 122++CFE2 CB 3F                                srl     a                                              ;
 123++CFE4 CB 3F                                srl     a                                              ;
 124++CFE6 47                                   ld      b,a                                            ;
 125++CFE7 AF                                   xor     a
 126++CFE8 32 4A CF                             ld      (CurrentNormIdx),a                                          ; used to increment up face incdex as b decrements
 127++CFEB E5           .ProcessNormalsLoop:    push    hl
 128++CFEC C5                                   push    bc
 129++CFED 7E           .LL86:                  ld      a,(hl)                                         ; Get Face sign and visibility distance byte
 130++CFEE E6 1F                                and     $1F                                            ; if normal visibility range  < XX4
 131++CFF0 E5                                   push    hl
 132++CFF1 21 92 C0                             ld      hl,UBnkDrawAllFaces
 133++CFF4 BE                                   cp      (hl)
 134++CFF5 E1                                   pop     hl
 135++CFF6                                      IFDEF DEBUGFORCEFACEDRAW
 136++CFF6 ~                                        jp      .FaceVisible
 137++CFF6                                      ELSE
 138++CFF6 DA 3B D1                                 jp      c,.FaceVisible              ; then we always draw
 139++CFF9                                      ENDIF
 140++CFF9              ; This bit needs to be added to force face visible
 141++CFF9 CD 22 CF     .LL87:                  call    CopyFaceToXX12              ; XX12 = normal (repolaced scale version) as a working copy
 142++CFFC 3A 1D 6C                             ld      a,(XX17)                    ; a = q scale XX17 cauclated by the call to ScaleDrawcam
 143++CFFF 47                                   ld      b,a
 144++D000                                      JumpIfALTNusng 4,.ScaleNormByXX17   ; if q >= 4 then is so big we don;t factor in + normal for dot product
 144++D000 FE 04       >                        cp      4
 144++D002 DA 3D D0    >                        jp		c, .ScaleNormByXX17
 145++D005 CD 61 CD     .LL143:                 call    CopyXX18toXX15              ; and we just set XX15 = scaled Camera dot rotation matrix
 146++D008 C3 CC D0                             jp      .DoneScalingIntoXX15        ; Now Process XX12 normal
 147++D00B 3A DB C0     .Ovflw:                 ld      a,(UBnkDrawCam0xLo)         ; divide camera by 2 if overflow
 148++D00E CB 3F                                srl     a                           ; which is held in XX18
 149++D010 32 DB C0                             ld      (UBnkDrawCam0xLo),a         ; .
 150++D013 3A E1 C0                             ld      a,(UBnkDrawCam0zLo)         ; .
 151++D016 CB 3F                                srl     a                           ; .
 152++D018 32 E1 C0                             ld      (UBnkDrawCam0zLo),a         ; .
 153++D01B 3A DE C0                             ld      a,(UBnkDrawCam0yLo)         ; .
 154++D01E CB 3F                                srl     a                           ; .
 155++D020 32 DE C0                             ld      (UBnkDrawCam0yLo),a        ; .
 156++D023 06 01        .ScaleXScaledAgain:     ld      b,1                         ; set scale to 1 so we divide original normal by 2 into face and try again and hope we didn't scaled down XX12 earlier so if we did then we must be in the do doo as the object was obscenely large and very close
 157++D025                                      ShiftMem8Right1 UBnkXScaled         ; Divide XX15 by 2^B
 157++D025 3A E7 C0    >                    ld      a,(UBnkXScaled)
 157++D028 CB 3F       >                    srl     a
 157++D02A 32 E7 C0    >                    ld      (UBnkXScaled),a
 158++D02D                                      ShiftMem8Right1 UBnkYScaled         ;
 158++D02D 3A E9 C0    >                    ld      a,(UBnkYScaled)
 158++D030 CB 3F       >                    srl     a
 158++D032 32 E9 C0    >                    ld      (UBnkYScaled),a
 159++D035                                      ShiftMem8Right1 UBnkZScaled         ;
 159++D035 3A EB C0    >                    ld      a,(UBnkZScaled)
 159++D038 CB 3F       >                    srl     a
 159++D03A 32 EB C0    >                    ld      (UBnkZScaled),a
 160++D03D              ; if we jumped to here scale factor < 4 so we copy in normal to XX15 (scaled) LL92
 161++D03D              .ScaleNormByXX17:       ;ld      b,a
 162++D03D CD 3C CD                             call    CopyXX12toXX15
 163++D040 05           .LL93                   dec     b
 164++D041 FA 60 D0                             jp      m, .ScaledNorm
 165++D044              .LL93Loop:              ShiftMem8Right1 UBnkXScaled        ; Divide XX15 by 2^B, I think this should be really XX12 and is a bug in the original code
 165++D044 3A E7 C0    >                    ld      a,(UBnkXScaled)
 165++D047 CB 3F       >                    srl     a
 165++D049 32 E7 C0    >                    ld      (UBnkXScaled),a
 166++D04C                                      ShiftMem8Right1 UBnkYScaled        ;
 166++D04C 3A E9 C0    >                    ld      a,(UBnkYScaled)
 166++D04F CB 3F       >                    srl     a
 166++D051 32 E9 C0    >                    ld      (UBnkYScaled),a
 167++D054                                      ShiftMem8Right1 UBnkZScaled        ;
 167++D054 3A EB C0    >                    ld      a,(UBnkZScaled)
 167++D057 CB 3F       >                    srl     a
 167++D059 32 EB C0    >                    ld      (UBnkZScaled),a
 168++D05C 05                                   dec     b                          ;
 169++D05D F2 44 D0                             jp      p,.LL93Loop                ; Now we have XX15 as scaled Normal, XX15 as camera, don;t really knwo why as cals work on XX12 and XX18
 170++D060              .ScaledNorm:            ;ORIG CODE DOES NOT HAVE THIS call    CopyXX15ToXX12 ; DEBUG as XX15 shoudl be a sacled nromal
 171++D060              ; Add normal to XX15
 172++D060              ; if we jumped here direct from LL143 then XX15 = drawcam scaled by Q, XX12 = face normal unscaled, XX18 = drawcam scaled also
 173++D060              ; if we jumped here via scaling       then XX15 = normal scaled by Q,  XX12 = face normal unscaled, XX16 = drawcam scaled
 174++D060              ; if we hit an overflow               then XX15 = drawcam scaled by Q  XX12 = face normal unscaled, XX18 = (drawcam scaled / 2 ) / 2^ nbr overflows (if we cam in vai scaling then its a mess?
 175++D060              ; So LL94 is wrong as it shoud be operating on XX12 not XX15
 176++D060              .LL94:                  ldCopyByte UBnkZScaled, varR        ; ldCopyByte  UBnkZScaled,     varR  ; if we jumped direct XX15 = drawcam scaled, Xx12 = normal xx18 = drawcam
 176++D060 3A EB C0    >                        ld       a,(UBnkZScaled)
 176++D063 32 17 6C    >                        ld       (varR),a
 177++D066                                      ldCopyByte UBnkXX12zSign, varS      ; ldCopyByte  UBnkYScaled,     varS  ; if we did scaling then xx15 = norm scaled XX18 = drawcam
 177++D066 3A F2 C0    >                        ld       a,(UBnkXX12zSign)
 177++D069 32 18 6C    >                        ld       (varS),a
 178++D06C                                      ldCopyByte  UBnkDrawCam0zLo, varQ   ; AQ = drawcam Z signed
 178++D06C 3A E1 C0    >                        ld       a,(UBnkDrawCam0zLo)
 178++D06F 32 16 6C    >                        ld       (varQ),a
 179++D072 3A E3 C0                             ld      a,(UBnkDrawCam0zSgn)        ; .
 180++D075 CD 1F 7D                             call    SAEquSRPlusAQ               ; SA = drawcam Z dot + z
 181++D078 DA 0B D0                             jp      c,.Ovflw
 182++D07B 32 EB C0                             ld      (UBnkZScaled),a             ; XX15Z = SA
 183++D07E                                      ldCopyByte  varS, UBnkZScaledSign   ;
 183++D07E 3A 18 6C    >                        ld       a,(varS)
 183++D081 32 EC C0    >                        ld       (UBnkZScaledSign),a
 184++D084                                      ldCopyByte  UBnkXScaled,     varR   ; SR = normal X
 184++D084 3A E7 C0    >                        ld       a,(UBnkXScaled)
 184++D087 32 17 6C    >                        ld       (varR),a
 185++D08A                                      ldCopyByte  UBnkXX12xSign,   varS   ; .
 185++D08A 3A EE C0    >                        ld       a,(UBnkXX12xSign)
 185++D08D 32 18 6C    >                        ld       (varS),a
 186++D090                                      ldCopyByte  UBnkDrawCam0xLo, varQ   ; AQ = drawcam x dot
 186++D090 3A DB C0    >                        ld       a,(UBnkDrawCam0xLo)
 186++D093 32 16 6C    >                        ld       (varQ),a
 187++D096 3A DD C0                             ld      a,(UBnkDrawCam0xSgn)        ; .
 188++D099 CD 1F 7D                             call    SAEquSRPlusAQ               ; SA = normal x + drawcam x dot
 189++D09C DA 0B D0                             jp      c,.Ovflw
 190++D09F 32 E7 C0                             ld      (UBnkXScaled),a             ; XX15Z = SA
 191++D0A2                                      ldCopyByte  varS, UBnkXScaledSign   ; .
 191++D0A2 3A 18 6C    >                        ld       a,(varS)
 191++D0A5 32 E8 C0    >                        ld       (UBnkXScaledSign),a
 192++D0A8                                      ldCopyByte  UBnkYScaled, varR       ; SR = normal Y
 192++D0A8 3A E9 C0    >                        ld       a,(UBnkYScaled)
 192++D0AB 32 17 6C    >                        ld       (varR),a
 193++D0AE                                      ldCopyByte  UBnkXX12ySign, varS     ; .
 193++D0AE 3A F0 C0    >                        ld       a,(UBnkXX12ySign)
 193++D0B1 32 18 6C    >                        ld       (varS),a
 194++D0B4                                      ldCopyByte  UBnkDrawCam0yLo, varQ   ; AQ = drawcam y dot
 194++D0B4 3A DE C0    >                        ld       a,(UBnkDrawCam0yLo)
 194++D0B7 32 16 6C    >                        ld       (varQ),a
 195++D0BA 3A E0 C0                             ld      a,(UBnkDrawCam0ySgn)        ; .
 196++D0BD CD 1F 7D                             call    SAEquSRPlusAQ               ; SA = normal y + drawcam y dot
 197++D0C0 DA 0B D0                             jp      c,.Ovflw                    ; .
 198++D0C3 32 E9 C0                             ld      (UBnkYScaled),a             ; XX15 Y = SA
 199++D0C6                                      ldCopyByte   varS, UBnkYScaledSign  ; .
 199++D0C6 3A 18 6C    >                        ld       a,(varS)
 199++D0C9 32 EA C0    >                        ld       (UBnkYScaledSign),a
 200++D0CC              ; calculate dot product LL89
 201++D0CC              .DoneScalingIntoXX15:   ldCopyByte  UBnkXX12xLo, varQ       ; Q = norm X XX12
 201++D0CC 3A ED C0    >                        ld       a,(UBnkXX12xLo)
 201++D0CF 32 16 6C    >                        ld       (varQ),a
 202++D0D2 3A E7 C0                             ld      a,(UBnkXScaled)             ; A = XX15 X
 203++D0D5 CD E7 7C                             call    AequAmulQdiv256             ; A = XX15 X * XX 12 X
 204++D0D8 32 32 6C                             ld      (varT),a                    ; T = XX15 X * XX 12 X
 205++D0DB 3A EE C0                             ld      a,(UBnkXX12xSign)           ; S = sign of XX15 X * XX12 X
 206++D0DE 21 E8 C0                             ld      hl,UBnkXScaledSign          ; .
 207++D0E1 AE                                   xor     (hl)                        ; .
 208++D0E2 32 18 6C                             ld      (varS),a                    ; .
 209++D0E5                                      ldCopyByte  UBnkXX12yLo, varQ       ; Q = norm Y XX12
 209++D0E5 3A EF C0    >                        ld       a,(UBnkXX12yLo)
 209++D0E8 32 16 6C    >                        ld       (varQ),a
 210++D0EB 3A E9 C0                             ld      a,(UBnkYScaled)             ; A = XX15 Y
 211++D0EE CD E7 7C                             call    AequAmulQdiv256             ; A = XX15 Y * XX 12 Y
 212++D0F1 32 16 6C                             ld      (varQ),a                    ; Q = XX15 Y * XX 12 Y
 213++D0F4                                      ldCopyByte  varT,varR               ; R = XX15 X * XX 12 X
 213++D0F4 3A 32 6C    >                        ld       a,(varT)
 213++D0F7 32 17 6C    >                        ld       (varR),a
 214++D0FA 3A F0 C0                             ld      a,  (UBnkXX12ySign)         ; A = sign of XX15 Y * XX 12 Y
 215++D0FD 21 EA C0                             ld      hl, UBnkYScaledSign         ; .
 216++D100 AE                                   xor     (hl)                        ; .
 217++D101 CD 1F 7D                             call    SAEquSRPlusAQ               ; SA = SR+AQ = (X calc) + (Y calc)
 218++D104 32 32 6C                             ld      (varT),a                    ; T = usigned (X calc) + (Y calc)
 219++D107                                      ldCopyByte  UBnkXX12zLo, varQ       ; Q = XX12 Z
 219++D107 3A F1 C0    >                        ld       a,(UBnkXX12zLo)
 219++D10A 32 16 6C    >                        ld       (varQ),a
 220++D10D 3A EB C0                             ld      a,  (UBnkZScaled)           ; A = XX15 Z
 221++D110 CD E7 7C                             call    AequAmulQdiv256             ; A = XX12 Z * XX15 Z
 222++D113 32 16 6C                             ld      (varQ),a                    ; Q = XX12 Z * XX15 Z
 223++D116                                      ldCopyByte  varT, varR              ; R = usigned (X calc) + (Y calc)
 223++D116 3A 32 6C    >                        ld       a,(varT)
 223++D119 32 17 6C    >                        ld       (varR),a
 224++D11C 3A EC C0                             ld      a,  (UBnkZScaledSign)       ; A = sign of XX12 Z * XX15 Z
 225++D11F 21 F2 C0                             ld      hl, UBnkXX12zSign           ; .
 226++D122 AE                                   xor     (hl)                        ; .
 227++D123 CD 1F 7D                             call    SAEquSRPlusAQ               ; SA = ((X+Y signed)) (Z signed)
 228++D126 FE 00                                cp      0                           ; was the result 0, if so then there are scenarios where SAEquSRPlusAQ can return -ve 0
 229++D128 28 08                                jr      z,.FaceNotVisible           ; in which case face is not visible
 230++D12A 3A 18 6C                             ld      a,(varS)                    ; if the cacl was a negative number then its visible
 231++D12D ED 27 80                             test    $80                         ; this should test S not A
 232++D130 20 09                                jr      nz,.FaceVisible                                      ;        if dot product < 0 set face visible
 233++D132 3A 4A CF     .FaceNotVisible:         ld          a,(CurrentNormIdx)
 234++D135 CD D4 CB                             call        SetFaceAHidden                                      ;           set face invisible
 235++D138 C3 41 D1                             jp          .ProcessNormalLoopEnd                                ;        end if
 236++D13B 3A 4A CF     .FaceVisible:            ld          a,(CurrentNormIdx)
 237++D13E CD CB CB                             call        SetFaceAVisible
 238++D141 21 4A CF     .ProcessNormalLoopEnd:  ld          hl, CurrentNormIdx
 239++D144 34                                   inc         (hl)                    ; move index pointer up by one
 240++D145 C1                                   pop         bc
 241++D146 E1                                   pop         hl                      ; get normal data pointer back
 242++D147 3E 04                                ld          a,4
 243++D149 ED 31                                add         hl,a                    ; move to next normal entry
 244++D14B 22 1C 6B                             ld          (varV),hl               ; save as we need it again
 245++D14E 05                                   dec         b
 246++D14F C2 EB CF                             jp          nz,.ProcessNormalsLoop
 247++D152 C9                                   ret
 248++D153
# file closed: ../../Tests/Vectors/../../ModelRender/BackfaceCull.asm
 525+ D153              ;--LL52 to LL55-----------------------------------------------------------------------------------------------------------------
 526+ D153
 527+ D153              TransposeXX12NodeToXX15:
 528+ D153                      ldCopyByte  UBnKxsgn,UbnkXPointSign           ; UBnkXSgn => XX15+2 x sign
 528+ D153 3A 22 C0    >                        ld       a,(UBnKxsgn)
 528+ D156 32 E9 C0    >                        ld       (UbnkXPointSign),a
 529+ D159 ED 4B ED C0          ld          bc,(UBnkXX12xLo)                   ; c = lo, b = sign   XX12XLoSign
 530+ D15D A8                   xor         b                                   ; a = UBnkKxsgn (or XX15+2) here and b = XX12xsign,  XX12+1 \ rotated xnode h                                                                             ;;;           a = a XOR XX12+1                              XCALC
 531+ D15E FA 74 D1             jp          m,NodeNegativeX                                                                                                                                                            ;;;           if sign is +ve                        ::LL52   XCALC
 532+ D161              ; XX15 [0,1] = INWK[0]+ XX12[0] + 256*INWK[1]                                                                                       ;;;          while any of x,y & z hi <> 0
 533+ D161              NodeXPositiveX:
 534+ D161 79                   ld          a,c                                 ; We picked up XX12+0 above in bc Xlo
 535+ D162 06 00                ld          b,0                                 ; but only want to work on xlo                                                           ;;;              XX15xHiLo = XX12HiLo + xpos lo             XCALC
 536+ D164 2A 20 C0             ld          hl,(UBnKxlo)                       ; hl = XX1 UBNKxLo
 537+ D167 26 00                ld          h,0                                 ; but we don;t want the sign
 538+ D169 09                   add         hl,bc                               ; its a 16 bit add
 539+ D16A 22 E7 C0             ld          (UbnkXPoint),hl                    ; And written to XX15 0,1
 540+ D16D AF                   xor         a                                   ; we want to write 0 as sign bit (not in original code)
 541+ D16E 32 E9 C0             ld          (UbnkXPointSign),a
 542+ D171 C3 90 D1             jp          FinishedThisNodeX
 543+ D174              ; If we get here then _sign and vertv_ have different signs so do subtract
 544+ D174              NodeNegativeX:
 545+ D174              LL52X:                                                 ;
 546+ D174 2A 20 C0             ld          hl,(UBnKxlo)                       ; Coord
 547+ D177 ED 4B ED C0          ld          bc,(UBnkXX12xLo)                   ; XX12
 548+ D17B 06 00                ld          b,0                                 ; XX12 lo byte only
 549+ D17D ED 42                sbc         hl,bc                               ; hl = UBnKx - UBnkXX12xLo
 550+ D17F F2 8D D1             jp          p,SetAndMopX                       ; if result is positive skip to write back
 551+ D182              NodeXNegSignChangeX:
 552+ D182              ; If we get here the result is 2'c compliment so we reverse it and flip sign
 553+ D182 CD E5 73             call        negate16hl                          ; Convert back to positive and flip sign
 554+ D185 3A E9 C0             ld          a,(UbnkXPointSign)                 ; XX15+2
 555+ D188 EE 80                xor         $80                                 ; Flip bit 7
 556+ D18A 32 E9 C0             ld          (UbnkXPointSign),a                 ; XX15+2
 557+ D18D              SetAndMopX:
 558+ D18D 22 20 C0             ld          (UBnKxlo),hl                       ; XX15+0
 559+ D190              FinishedThisNodeX:
 560+ D190
 561+ D190              LL53:
 562+ D190
 563+ D190                      ldCopyByte  UBnKysgn,UbnkYPointSign           ; UBnkXSgn => XX15+2 x sign
 563+ D190 3A 25 C0    >                        ld       a,(UBnKysgn)
 563+ D193 32 EC C0    >                        ld       (UbnkYPointSign),a
 564+ D196 ED 4B EF C0          ld          bc,(UBnkXX12yLo)                   ; c = lo, b = sign   XX12XLoSign
 565+ D19A A8                   xor         b                                   ; a = UBnkKxsgn (or XX15+2) here and b = XX12xsign,  XX12+1 \ rotated xnode h                                                                             ;;;           a = a XOR XX12+1                              XCALC
 566+ D19B FA B1 D1             jp          m,NodeNegativeY                                                                                                                                                            ;;;           if sign is +ve                        ::LL52   XCALC
 567+ D19E              ; XX15 [0,1] = INWK[0]+ XX12[0] + 256*INWK[1]                                                                                       ;;;          while any of x,y & z hi <> 0
 568+ D19E              NodeXPositiveY:
 569+ D19E 79                   ld          a,c                                 ; We picked up XX12+0 above in bc Xlo
 570+ D19F 06 00                ld          b,0                                 ; but only want to work on xlo                                                           ;;;              XX15xHiLo = XX12HiLo + xpos lo             XCALC
 571+ D1A1 2A 23 C0             ld          hl,(UBnKylo)                       ; hl = XX1 UBNKxLo
 572+ D1A4 26 00                ld          h,0                                 ; but we don;t want the sign
 573+ D1A6 09                   add         hl,bc                               ; its a 16 bit add
 574+ D1A7 22 EA C0             ld          (UbnkYPoint),hl                    ; And written to XX15 0,1
 575+ D1AA AF                   xor         a                                   ; we want to write 0 as sign bit (not in original code)
 576+ D1AB 32 E9 C0             ld          (UbnkXPointSign),a
 577+ D1AE C3 CD D1             jp          FinishedThisNodeY
 578+ D1B1              ; If we get here then _sign and vertv_ have different signs so do subtract
 579+ D1B1              NodeNegativeY:
 580+ D1B1              LL52Y:                                                 ;
 581+ D1B1 2A 23 C0             ld          hl,(UBnKylo)                       ; Coord
 582+ D1B4 ED 4B EF C0          ld          bc,(UBnkXX12yLo)                   ; XX12
 583+ D1B8 06 00                ld          b,0                                 ; XX12 lo byte only
 584+ D1BA ED 42                sbc         hl,bc                               ; hl = UBnKx - UBnkXX12xLo
 585+ D1BC F2 CA D1             jp          p,SetAndMopY                       ; if result is positive skip to write back
 586+ D1BF              NodeXNegSignChangeY:
 587+ D1BF              ; If we get here the result is 2'c compliment so we reverse it and flip sign
 588+ D1BF CD E5 73             call        negate16hl                          ; Convert back to positive and flip sign
 589+ D1C2 3A EC C0             ld          a,(UbnkYPointSign)                 ; XX15+2
 590+ D1C5 EE 80                xor         $80                                 ; Flip bit 7
 591+ D1C7 32 EC C0             ld          (UbnkYPointSign),a                 ; XX15+2
 592+ D1CA              SetAndMopY:
 593+ D1CA 22 23 C0             ld          (UBnKylo),hl                       ; XX15+0
 594+ D1CD              FinishedThisNodeY:
 595+ D1CD
 596+ D1CD                  DISPLAY "Tracing 5", $
 597+ D1CD
 598+ D1CD              TransposeZ:
 599+ D1CD              LL55:                                                   ; Both y signs arrive here, Onto z                                          ;;;
 600+ D1CD 3A F2 C0             ld          a,(UBnkXX12zSign)                   ; XX12+5    \ rotated znode hi                                              ;;;
 601+ D1D0                      JumpOnBitSet a,7,NegativeNodeZ                    ; LL56 -ve Z node                                                           ;;;
 601+ D1D0 CB 7F       >                        bit 	7,a
 601+ D1D2 C2 E6 D1    >                        jp      nz,NegativeNodeZ
 602+ D1D5 3A F1 C0             ld          a,(UBnkXX12zLo)                     ; XX12+4 \ rotated znode lo                                                 ;;;
 603+ D1D8 2A 26 C0             ld          hl,(UBnKzlo)                        ; INWK+6    \ zorg lo                                                       ;;;
 604+ D1DB ED 31                add         hl,a                                ; hl = INWKZ + XX12z                                                        ;;;
 605+ D1DD 7D                   ld          a,l
 606+ D1DE 32 32 6C             ld          (varT),a                            ;                                                                           ;;;
 607+ D1E1 7C                   ld          a,h
 608+ D1E2 32 15 6C             ld          (varU),a                            ; now z = hl or U(hi).T(lo)                                                 ;;;
 609+ D1E5 C9                   ret                                             ; LL57  \ Node additions done, z = U.T                                      ;;;
 610+ D1E6              ; Doing additions and scalings for each visible node around here                                                                    ;;;
 611+ D1E6              NegativeNodeZ:
 612+ D1E6              LL56:                                                   ; Enter XX12+5 -ve Z node case  from above                                  ;;;
 613+ D1E6 2A 26 C0             ld          hl,(UBnKzlo)                        ; INWK+6 \ z org lo                                                         ;;;
 614+ D1E9 ED 4B F1 C0          ld          bc,(UBnkXX12zLo)                    ; XX12+4    \ rotated z node lo                                                 ......................................................
 615+ D1ED 06 00                ld          b,0                                 ; upper byte will be garbage
 616+ D1EF                      ClearCarryFlag
 616+ D1EF B7          >                        or a
 617+ D1F0 ED 42                sbc         hl,bc                               ; 6502 used carry flag compliment
 618+ D1F2 7D                   ld          a,l
 619+ D1F3 32 32 6C             ld          (varT),a                            ; t = result low
 620+ D1F6 7C                   ld          a,h
 621+ D1F7 32 15 6C             ld          (varU),a                            ; u = result high
 622+ D1FA E2 07 D2             jp          po,MakeNodeClose                    ; no overflow to parity would be clear
 623+ D1FD              LL56Overflow:
 624+ D1FD FE 00                cp          0                                   ; is varU 0?
 625+ D1FF 20 16                jr          nz,NodeAdditionsDone                ; Enter Node additions done, UT=z
 626+ D201 3A 32 6C             ld          a,(varT)                            ; T \ restore z lo
 627+ D204                      ReturnIfAGTENusng 4                              ; >= 4 ? zlo big enough, Enter Node additions done.
 627+ D204 FE 04       >                        cp    4
 627+ D206 D0          >                        ret	 nc
 628+ D207              MakeNodeClose:
 629+ D207              LL140:                                                  ; else make node close
 630+ D207 AF                   xor         a                                   ; hi This needs tuning to use a 16 bit variable
 631+ D208 32 15 6C             ld          (varU),a                            ; U
 632+ D20B 3E 04                ld          a,4                                 ; lo
 633+ D20D 32 32 6C             ld          (varT),a                            ; T
 634+ D210 C9                   ret
 635+ D211              ;--LL49-------------------------------------------------------------------------------------------------------------------------
 636+ D211              ProcessVisibleNode:
 637+ D211              RotateNode:                                                                                                                         ;;;
 638+ D211 CD E6 CC             call        XX12EquXX15DotProductXX16                                                                                       ;;;           call      XX12=XX15.XX16
 639+ D214              LL52LL53LL54LL55
 640+ D214              TransposeNode:
 641+ D214 CD 53 D1             call        TransposeXX12NodeToXX15
 642+ D217
 643+ D217              ; ......................................................                                                         ;;;
 644+ D217              NodeAdditionsDone:
 645+ D217              Scale16BitTo8Bit:
 646+ D217              LL57:                                                   ; Enter Node additions done, z=T.U set up from LL55
 647+ D217 3A 15 6C             ld          a,(varU)                            ; U \ z hi
 648+ D21A 21 E8 C0             ld          hl,UbnkXPointHi
 649+ D21D B6                   or          (hl)                                ; XX15+1    \ x hi
 650+ D21E 21 EB C0             ld          hl,UbnkYPointHi
 651+ D221 B6                   or          (hl)                                ; XX15+4    \ y hi
 652+ D222              AreXYZHiAllZero:
 653+ D222 28 2B                jr          z,NodeScalingDone                   ; if X, Y, Z = 0  exit loop down once hi U rolled to 0
 654+ D224              DivideXYZBy2:
 655+ D224                      ShiftMem16Right1    UbnkXPoint                  ; XX15[0,1]
 655+ D224 2A E7 C0    >                    ld    hl,(UbnkXPoint)
 655+ D227 CB 3C       >                    srl   h
 655+ D229 CB 1D       >                    rr    l
 655+ D22B 22 E7 C0    >                    ld    (UbnkXPoint),hl
 656+ D22E                      ShiftMem16Right1    UbnkYPoint                  ; XX15[3,4]
 656+ D22E 2A EA C0    >                    ld    hl,(UbnkYPoint)
 656+ D231 CB 3C       >                    srl   h
 656+ D233 CB 1D       >                    rr    l
 656+ D235 22 EA C0    >                    ld    (UbnkYPoint),hl
 657+ D238 3A 15 6C             ld          a,(varU)                            ; U \ z hi
 658+ D23B 67                   ld          h,a
 659+ D23C 3A 32 6C             ld          a,(varT)                            ; T \ z lo
 660+ D23F 6F                   ld          l,a
 661+ D240                      ShiftHLRight1
 661+ D240 CB 3C       >			   srl h
 661+ D242 CB 1D       >			   rr  l
 662+ D244 7C                   ld          a,h
 663+ D245 32 15 6C             ld          (varU),a
 664+ D248 7D                   ld          a,l
 665+ D249 32 32 6C             ld          (varT),a                            ; T \ z lo
 666+ D24C C3 17 D2             jp          Scale16BitTo8Bit                    ; loop U
 667+ D24F              NodeScalingDone:
 668+ D24F              LL60:                                                   ; hi U rolled to 0, exited loop above.
 669+ D24F              ProjectNodeToScreen:
 670+ D24F                      ldCopyByte  varT,varQ                           ; T =>  Q   \ zdist lo
 670+ D24F 3A 32 6C    >                        ld       a,(varT)
 670+ D252 32 16 6C    >                        ld       (varQ),a
 671+ D255 3A E7 C0             ld          a,(UbnkXPointLo)                    ; XX15  \ rolled x lo
 672+ D258 21 16 6C             ld          hl,varQ
 673+ D25B BE                   cp          (hl)                                ; Q
 674+ D25C                      JumpIfALTusng DoSmallAngle                      ; LL69 if xdist < zdist hop over jmp to small x angle
 674+ D25C DA 65 D2    >                        jp		c,DoSmallAngle
 675+ D25F CD 2D 74             call        RequAmul256divQ; RequAdivQ                           ; LL61  \ visit up  R = A/Q = x/z
 676+ D262 C3 6D D2             jp          SkipSmallAngle                      ; LL65  \ hop over small xangle
 677+ D265              DoSmallAngle:                                           ; small x angle
 678+ D265              LL69:
 679+ D265              ; TODO check if we need to retain BC as this trashes it
 680+ D265              ;Input: BC = Dividend, DE = Divisor, HL = 0
 681+ D265              ;Output: BC = Quotient, HL = Remainder
 682+ D265 47                   ld      b,a
 683+ D266 CD BE 76             call    DIV16UNDOC
 684+ D269 79                   ld      a,c
 685+ D26A 32 17 6C             ld      (varR),a
 686+ D26D               ;;;       call        RequAmul256divQ                     ; LL28  \ BFRDIV R=A*256/Q byte for remainder of division
 687+ D26D              SkipSmallAngle:
 688+ D26D              ScaleX:
 689+ D26D              LL65:                                                   ; both continue for scaling based on z
 690+ D26D 3A E9 C0             ld          a,(UbnkXPointSign)                  ; XX15+2 \ sign of X dist
 691+ D270                      JumpOnBitSet a,7,NegativeXPoint                 ; LL62 up, -ve Xdist, RU screen onto XX3 heap
 691+ D270 CB 7F       >                        bit 	7,a
 691+ D272 C2 85 D2    >                        jp      nz,NegativeXPoint
 692+ D275              ; ......................................................
 693+ D275              PositiveXPoint:
 694+ D275 3A 17 6C             ld          a,(varR)
 695+ D278 6F                   ld          l,a
 696+ D279 3A 15 6C             ld          a,(varU)
 697+ D27C 67                   ld          h,a
 698+ D27D 3E 80                ld          a,ScreenCenterX
 699+ D27F ED 31                add         hl,a
 700+ D281 EB                   ex          de,hl
 701+ D282 C3 95 D2             jp          StoreXPoint
 702+ D285              NegativeXPoint:
 703+ D285              LL62:                                                   ; Arrive from LL65 just below, screen for -ve RU onto XX3 heap, index X=CNT ;;;
 704+ D285 3A 17 6C             ld          a,(varR)
 705+ D288 6F                   ld          l,a
 706+ D289 3A 15 6C             ld          a,(varU)
 707+ D28C 67                   ld          h,a
 708+ D28D 0E 80                ld          c,ScreenCenterX
 709+ D28F 06 00                ld          b,0
 710+ D291                      ClearCarryFlag
 710+ D291 B7          >                        or a
 711+ D292 ED 42                sbc         hl,bc                               ; hl = RU-ScreenCenterX
 712+ D294 EB                   ex          de,hl
 713+ D295              StoreXPoint:                                            ; also from LL62, XX3 node heap has xscreen node so far.
 714+ D295 FD 73 00             ld          (iy+0),e                            ; Update X Point
 715+ D298 FD 72 01             ld          (iy+1),d                            ; Update X Point
 716+ D29B FD 23                inc         iy
 717+ D29D FD 23                inc         iy
 718+ D29F              ; ......................................................
 719+ D29F              LL66:
 720+ D29F              ProcessYPoint:
 721+ D29F AF                   xor         a                                   ; y hi = 0
 722+ D2A0 32 15 6C             ld          (varU),a                            ; U
 723+ D2A3                      ldCopyByte  varT,varQ                           ; Q \ zdist lo
 723+ D2A3 3A 32 6C    >                        ld       a,(varT)
 723+ D2A6 32 16 6C    >                        ld       (varQ),a
 724+ D2A9 3A EA C0             ld          a,(UbnkYPointLo)                    ; XX15+3 \ rolled y low
 725+ D2AC 21 16 6C             ld          hl,varQ
 726+ D2AF BE                   cp          (hl)                                ; Q
 727+ D2B0                      JumpIfALTusng SmallYHop                         ; if ydist < zdist hop to small yangle
 727+ D2B0 DA B9 D2    >                        jp		c,SmallYHop
 728+ D2B3              SmallYPoint:
 729+ D2B3 CD 2D 74             call        RequAmul256divQ;RequAdivQ                           ; LL61  \ else visit up R = A/Q = y/z
 730+ D2B6 C3 BC D2             jp          SkipYScale                          ; LL68 hop over small y yangle
 731+ D2B9              SmallYHop:
 732+ D2B9              LL67:                                                   ; Arrive from LL66 above if XX15+3 < Q \ small yangle
 733+ D2B9 CD 2D 74             call        RequAmul256divQ                     ; LL28  \ BFRDIV R=A*256/Q byte for remainder of division
 734+ D2BC              SkipYScale:
 735+ D2BC              LL68:                                                   ; both carry on, also arrive from LL66, yscaled based on z
 736+ D2BC 3A EC C0             ld          a,(UbnkYPointSign)                  ; XX15+5 \ sign of X dist
 737+ D2BF CB 7F                bit         7,a
 738+ D2C1 C2 D4 D2             jp          nz,NegativeYPoint                   ; LL62 up, -ve Xdist, RU screen onto XX3 heap
 739+ D2C4              PositiveYPoint:
 740+ D2C4 3A 17 6C             ld          a,(varR)
 741+ D2C7 6F                   ld          l,a
 742+ D2C8 3A 15 6C             ld          a,(varU)
 743+ D2CB 67                   ld          h,a
 744+ D2CC 3E 60                ld          a,ScreenHeightHalf
 745+ D2CE ED 31                add         hl,a
 746+ D2D0 EB                   ex          de,hl
 747+ D2D1 C3 E4 D2             jp          LL50
 748+ D2D4              NegativeYPoint:
 749+ D2D4              LL70:                                                   ; Arrive from LL65 just below, screen for -ve RU onto XX3 heap, index X=CNT ;;;
 750+ D2D4 3A 17 6C             ld          a,(varR)
 751+ D2D7 6F                   ld          l,a
 752+ D2D8 3A 15 6C             ld          a,(varU)
 753+ D2DB 67                   ld          h,a
 754+ D2DC 0E 60                ld          c,ScreenHeightHalf
 755+ D2DE 06 00                ld          b,0
 756+ D2E0                      ClearCarryFlag
 756+ D2E0 B7          >                        or a
 757+ D2E1 ED 42                sbc         hl,bc                               ; hl = RU-ScreenCenterX
 758+ D2E3 EB                   ex          de,hl
 759+ D2E4              LL50:                                                   ; also from LL62, XX3 node heap has xscreen node so far.
 760+ D2E4 FD 73 00             ld          (iy+0),e                            ; Update X Point
 761+ D2E7 FD 72 01             ld          (iy+1),d                            ; Update X Point
 762+ D2EA FD 23                inc         iy
 763+ D2EC FD 23                inc         iy
 764+ D2EE C9                   ret
 765+ D2EF              ;--------------------------------------------------------------------------------------------------------
 766+ D2EF              ;;;     Byte 0 = X magnitide with origin at middle of ship
 767+ D2EF              ;;;     Byte 1 = Y magnitide with origin at middle of ship
 768+ D2EF              ;;;     Byte 2 = Z magnitide with origin at middle of ship
 769+ D2EF              ;;;     Byte 3 = Sign Bits of Vertex 7=X 6=Y 5 = Z 4 - 0 = visibility beyond which vertix is not shown
 770+ D2EF              CopyNodeToXX15:
 771+ D2EF                      ldCopyByte  hl, UBnkXScaled                     ; Load into XX15                                                                     Byte 0;;;     XX15 xlo   = byte 0
 771+ D2EF 7E          >                        ld       a,(hl)
 771+ D2F0 32 E7 C0    >                        ld       (UBnkXScaled),a
 772+ D2F3 23                   inc         hl
 773+ D2F4                      ldCopyByte  hl, UBnkYScaled                     ; Load into XX15                                                                     Byte 0;;;     XX15 xlo   = byte 0
 773+ D2F4 7E          >                        ld       a,(hl)
 773+ D2F5 32 E9 C0    >                        ld       (UBnkYScaled),a
 774+ D2F8 23                   inc         hl
 775+ D2F9                      ldCopyByte  hl, UBnkZScaled                     ; Load into XX15                                                                     Byte 0;;;     XX15 xlo   = byte 0
 775+ D2F9 7E          >                        ld       a,(hl)
 775+ D2FA 32 EB C0    >                        ld       (UBnkZScaled),a
 776+ D2FD 23                   inc         hl
 777+ D2FE              PopulateXX15SignBits:
 778+ D2FE              ; Simplfied for debugging, needs optimising back to original DEBUG TODO
 779+ D2FE 7E                   ld          a,(hl)
 780+ D2FF 4F                   ld          c,a                                 ; copy sign and visibility to c
 781+ D300 47                   ld          b,a
 782+ D301 E6 80                and         $80                                 ; keep high 3 bits
 783+ D303 32 E8 C0             ld          (UBnkXScaledSign),a                 ; Copy Sign Bits                                                            ;;;
 784+ D306 78                   ld          a,b
 785+ D307 E6 40                and         $40
 786+ D309 CB 27                sla         a                                   ; Copy Sign Bits                                                            ;;;
 787+ D30B 32 EA C0             ld          (UBnkYScaledSign),a                 ; Copy Sign Bits                                                            ;;;
 788+ D30E 78                   ld          a,b
 789+ D30F E6 20                and         $20
 790+ D311 CB 27                sla         a                                   ; Copy Sign Bits                                                            ;;;
 791+ D313 CB 27                sla         a                                   ; Copy Sign Bits                                                            ;;;
 792+ D315 32 EC C0             ld          (UBnkZScaledSign),a                 ; Copy Sign Bits                                                            ;;;
 793+ D318 79                   ld          a,c                                 ; returns a with visibility sign byte
 794+ D319 E6 1F                and         $1F                                 ; visibility is held in bits 0 to 4                                                              ;;;     A = XX15 Signs AND &1F (to get lower 5 visibility)
 795+ D31B 32 32 6C             ld          (varT),a                            ; and store in varT as its needed later
 796+ D31E C9                   ret
 797+ D31F
 798+ D31F              ;;;     Byte 4 = High 4 bits Face 2 Index Low 4 bits = Face 1 Index
 799+ D31F              ;;;     Byte 5 = High 4 bits Face 4 Index Low 4 bits = Face 3 Index
 800+ D31F              ;..............................................................................................................................
 801+ D31F              ProcessANode:                                           ; Start loop on Nodes for visibility, each node has 4 faces associated with ;;; For each node (point) in model                  ::LL48
 802+ D31F              LL48GetScale:
 803+ D31F 3A 07 6B             ld          a,(LastNormalVisible)               ; get Normal visible range into e before we copy node
 804+ D322 5F                   ld          e,a
 805+ D323 CD EF D2             call        CopyNodeToXX15
 806+ D326              LL48GetVertices:
 807+ D326              LL48GetVertSignAndVisDist:
 808+ D326                      JumpIfALTNusng e,NodeIsNotVisible               ; if XX4 > Visibility distance then vertext too far away , next vertex.                                             ;;;        goto LL50 (end of loop)
 808+ D326 BB          >                        cp      e
 808+ D327 DA 64 D3    >                        jp		c, NodeIsNotVisible
 809+ D32A              CheckFace1:                                                                                                                         ;;;     if all FaceVisile[point face any of idx1,2,3 or 4] = 0
 810+ D32A                      CopyByteAtNextHL varP                           ; vertex byte#4, first 2 faces two 4-bit indices 0:15 into XX2 for 2 of the ;;;     get point face idx from byte 4 & 5 of normal
 810+ D32A 23          >                    inc         hl                                  ; vertex byte#1
 810+ D32B 7E          >                    ld          a,(hl)                              ;
 810+ D32C 32 16 6B    >                    ld          (varP),a                     ; SunXX15+2 = (V),Y
 811+ D32F 57                   ld          d,a                                 ; use d to hold a as a temp                                                 ;;;
 812+ D330 E6 0F                and         $0F                                 ; face 1                                                                    ;;;
 813+ D332 E5                   push        hl                                  ; we need to save HL                                                        ;;;
 814+ D333                      ldHLIdxAToA UbnkFaceVisArray                    ; visibility at face 1                                                Byte 4;;;
 814+ D333 21 13 C1    >                    ld          hl,UbnkFaceVisArray
 814+ D336 ED 31       >                    add         hl,a
 814+ D338 7E          >                    ld          a,(hl)
 815+ D339 E1                   pop         hl                                  ;                                                                           ;;;
 816+ D33A                      JumpIfAIsNotZero NodeIsVisible                  ; is face 1 visible                                                         ;;;
 816+ D33A A7          >                        and     a
 816+ D33B C2 6A D3    >                        jp	    nz,NodeIsVisible
 817+ D33E              CheckFace2:                                                                                                                         ;;;
 818+ D33E 7A                   ld          a,d                                                                                                             ;;;
 819+ D33F ED 23                swapnib                                                                                                                     ;;;
 820+ D341 E6 0F                and         $0F                                 ; this is face 2                                                            ;;;
 821+ D343                      JumpIfAIsNotZero NodeIsVisible                  ; is face 1 visible                                                         ;;;
 821+ D343 A7          >                        and     a
 821+ D344 C2 6A D3    >                        jp	    nz,NodeIsVisible
 822+ D347              CheckFace3:                                                                                                                         ;;;
 823+ D347                      CopyByteAtNextHL varP                           ; vertex byte#4, first 2 faces two 4-bit indices 0:15 into XX2 for 2 of the ;;;
 823+ D347 23          >                    inc         hl                                  ; vertex byte#1
 823+ D348 7E          >                    ld          a,(hl)                              ;
 823+ D349 32 16 6B    >                    ld          (varP),a                     ; SunXX15+2 = (V),Y
 824+ D34C 57                   ld          d,a                                 ; use d to hold a as a temp                                                 ;;;
 825+ D34D E6 0F                and         $0F                                 ; face 1                                                                    ;;;
 826+ D34F E5                   push        hl                                  ; we need to save HL                                                        ;;;
 827+ D350                      ldHLIdxAToA UbnkFaceVisArray                  ; visibility at face 1                                                Byte 5;;;
 827+ D350 21 13 C1    >                    ld          hl,UbnkFaceVisArray
 827+ D353 ED 31       >                    add         hl,a
 827+ D355 7E          >                    ld          a,(hl)
 828+ D356 E1                   pop         hl                                  ;                                                                           ;;;
 829+ D357                      JumpIfAIsNotZero NodeIsVisible                  ; is face 1 visible                                                         ;;;
 829+ D357 A7          >                        and     a
 829+ D358 C2 6A D3    >                        jp	    nz,NodeIsVisible
 830+ D35B              CheckFace4:                                                                                                                         ;;;
 831+ D35B 7A                   ld          a,d                                                                                                             ;;;
 832+ D35C ED 23                swapnib                                                                                                                     ;;;
 833+ D35E E6 0F                and         $0F                                 ; this is face 2                                                            ;;;
 834+ D360                      JumpIfAIsNotZero NodeIsVisible                  ; is face 1 visible                                                         ;;;
 834+ D360 A7          >                        and     a
 834+ D361 C2 6A D3    >                        jp	    nz,NodeIsVisible
 835+ D364              NodeIsNotVisible:                                                                                                                   ;;;
 836+ D364 01 04 00             ld          bc,4
 837+ D367 FD 09                add         iy,bc                               ; if not visible then move to next element in array anyway                  ;;;
 838+ D369                      ;;; Should we be loading FFFFFFFF into 4 bytes or just ignore?
 839+ D369 C9                   ret                                                                                                      ;;;        goto LL50 (end of loop)
 840+ D36A              NodeIsVisible:
 841+ D36A              LL49:
 842+ D36A CD 11 D2             call        ProcessVisibleNode                  ; Process node to determine if it goes on heap
 843+ D36D C9                   ret
 844+ D36E
 845+ D36E                  DISPLAY "Tracing 6", $
 846+ D36E
 847+ D36E              ProjectNodeToEye:
 848+ D36E ED 4B EB C0      ld          bc,(UBnkZScaled)                    ; BC = Z Cordinate. By here it MUST be positive as its clamped to 4 min
 849+ D372 79               ld          a,c                                 ;  so no need for a negative check
 850+ D373 32 16 6C         ld          (varQ),a                            ; VarQ = z
 851+ D376 3A E7 C0         ld          a,(UBnkXScaled)                     ; XX15  \ rolled x lo which is signed
 852+ D379 CD A7 76         call        DIV16Amul256dCUNDOC                 ; result in BC which is 16 bit TODO Move to 16 bit below not just C reg
 853+ D37C 3A E8 C0         ld          a,(UBnkXScaledSign)                 ; XX15+2 \ sign of X dist
 854+ D37F                  JumpOnBitSet a,7,EyeNegativeXPoint             ; LL62 up, -ve Xdist, RU screen onto XX3 heap
 854+ D37F CB 7F       >                        bit 	7,a
 854+ D381 C2 8C D3    >                        jp      nz,EyeNegativeXPoint
 855+ D384              EyePositiveXPoint:                                  ; x was positive result
 856+ D384 2E 80            ld          l,ScreenCenterX                     ;
 857+ D386 26 00            ld          h,0
 858+ D388 09               add         hl,bc                               ; hl = Screen Centre + X
 859+ D389 C3 93 D3         jp          EyeStoreXPoint
 860+ D38C              EyeNegativeXPoint:                                 ; x < 0 so need to subtract from the screen centre position
 861+ D38C 2E 80            ld          l,ScreenCenterX
 862+ D38E 26 00            ld          h,0
 863+ D390                  ClearCarryFlag
 863+ D390 B7          >                        or a
 864+ D391 ED 42            sbc         hl,bc                               ; hl = Screen Centre - X
 865+ D393              EyeStoreXPoint:                                    ; also from LL62, XX3 node heap has xscreen node so far.
 866+ D393 EB               ex          de,hl
 867+ D394 FD 73 00         ld          (iy+0),e                            ; Update X Point TODO this bit is 16 bit aware just need to fix above bit
 868+ D397 FD 72 01         ld          (iy+1),d                            ; Update X Point
 869+ D39A              EyeProcessYPoint:
 870+ D39A ED 4B EB C0      ld          bc,(UBnkZScaled)                    ; Now process Y co-ordinate
 871+ D39E 79               ld          a,c
 872+ D39F 32 16 6C         ld          (varQ),a
 873+ D3A2 3A E9 C0         ld          a,(UBnkYScaled)                     ; XX15  \ rolled x lo
 874+ D3A5 CD A7 76         call        DIV16Amul256dCUNDOC                 ; a = Y scaled * 256 / zscaled
 875+ D3A8 3A EA C0         ld          a,(UBnkYScaledSign)                 ; XX15+2 \ sign of X dist
 876+ D3AB                  JumpOnBitSet a,7,EyeNegativeYPoint             ; LL62 up, -ve Xdist, RU screen onto XX3 heap top of screen is Y = 0
 876+ D3AB CB 7F       >                        bit 	7,a
 876+ D3AD C2 B8 D3    >                        jp      nz,EyeNegativeYPoint
 877+ D3B0              EyePositiveYPoint:                                  ; Y is positive so above the centre line
 878+ D3B0 2E 60            ld          l,ScreenCenterY
 879+ D3B2                  ClearCarryFlag
 879+ D3B2 B7          >                        or a
 880+ D3B3 ED 42            sbc         hl,bc                               ; hl = ScreenCentreY - Y coord (as screen is 0 at top)
 881+ D3B5 C3 BD D3         jp          EyeStoreYPoint
 882+ D3B8              EyeNegativeYPoint:                                  ; this bit is only 8 bit aware TODO FIX
 883+ D3B8 2E 60            ld          l,ScreenCenterY
 884+ D3BA 26 00            ld          h,0
 885+ D3BC 09               add         hl,bc                               ; hl = ScreenCenterY + Y as negative is below the center of screen
 886+ D3BD              EyeStoreYPoint:                                    ; also from LL62, XX3 node heap has xscreen node so far.
 887+ D3BD EB               ex          de,hl
 888+ D3BE FD 73 02         ld          (iy+2),e                            ; Update Y Point
 889+ D3C1 FD 72 03         ld          (iy+3),d                            ; Update Y Point
 890+ D3C4 C9               ret
 891+ D3C5              ; ---------------------------------------------------------------------------------------------------------------------------------
 892+ D3C5                          INCLUDE "../../Universe/Ships/ApplyMyRollAndPitch.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/ApplyMyRollAndPitch.asm
   1++D3C5
   2++D3C5              ; Full version
   3++D3C5              ; 1. K2 = y - alpha * x
   4++D3C5              ; 2. z = z + beta * K2
   5++D3C5              ; 3. y = K2 - beta * z
   6++D3C5              ; 4. x = x + alpha * y
   7++D3C5
   8++D3C5                  IFDEF USE_24BIT_ROLL_AND_PITCH
   9++D3C5 ~            UBnK24BitAlphaMulX      DB $00,$00, $00, $00
  10++D3C5 ~            UBnK24BitAlphaMulY      DB $00,$00, $00, $00
  11++D3C5 ~            UBnK24BitAlphaMulZ      DB $00,$00, $00, $00
  12++D3C5 ~            UBnK24BitBetaMulZ       DB $00,$00, $00, $00
  13++D3C5 ~            UBnK24BitBetaMulY       DB $00,$00, $00, $00
  14++D3C5 ~            UBnK24BitK2             DS 3
  15++D3C5 ~
  16++D3C5 ~            PitchBlock              DB  1
  17++D3C5 ~
  18++D3C5 ~            ApplyMyRollAndPitch:    ld      a,(ALPHA)                   ; no roll or pitch, no calc needed
  19++D3C5 ~            .CheckForRoll:          and		a
  20++D3C5 ~            						call	nz,UBnKRoll_24Bit
  21++D3C5 ~            .CheckForPitch:			ld		a,(BETA)
  22++D3C5 ~            						and		a
  23++D3C5 ~            						call	nz,UBnKPitch_24Bit
  24++D3C5 ~            .ApplySpeed:            ld      a,(DELTA)                   ; BCH = - Delta
  25++D3C5 ~                                    and     a
  26++D3C5 ~                                    jp      z,.ApplyOrientation
  27++D3C5 ~            						;ReturnIfAIsZero
  28++D3C5 ~            						ld      c,0                         ;
  29++D3C5 ~            						ld      h,a                         ;
  30++D3C5 ~            						ld      b,$80                       ;
  31++D3C5 ~            						ld      de,(UBnKzhi)                ; DEL = z position
  32++D3C5 ~            						ld      a,(UBnKzlo)                 ; .
  33++D3C5 ~            						ld      l,a                         ; .
  34++D3C5 ~            						call    AddBCHtoDELsigned           ; update speed
  35++D3C5 ~            						ld      (UBnKzhi),DE                ; write back to zpos
  36++D3C5 ~            						ld      a,l
  37++D3C5 ~                                    ld      (UBnKzlo),a                ;
  38++D3C5 ~            .ApplyOrientation:      ld      a,(ALPHA)
  39++D3C5 ~                                    ld      hl,BETA
  40++D3C5 ~                                    or      (hl)
  41++D3C5 ~                                    ret     z
  42++D3C5 ~                                    ld      a,(PitchBlock)
  43++D3C5 ~                                    and     a
  44++D3C5 ~                                    ret     z
  45++D3C5 ~                                    ;break
  46++D3C5 ~            PitchBreak:             ld      ix,UBnkrotmatSidevX
  47++D3C5 ~            DebugAlert1:            ld      a,(ix+1)
  48++D3C5 ~                                    ld      d,(ix+3)
  49++D3C5 ~                                    ld      e,(ix+5)
  50++D3C5 ~                                    or     d
  51++D3C5 ~                                    or     e
  52++D3C5 ~                                    and     $7F
  53++D3C5 ~                                    jp      nz,.NoBreak
  54++D3C5 ~                                    break
  55++D3C5 ~            .NoBreak
  56++D3C5 ~
  57++D3C5 ~                                    call    ApplyRollAndPitchToIX
  58++D3C5 ~            DebugAlert2:             ld      a,(ix+1)
  59++D3C5 ~                                    ld      d,(ix+3)
  60++D3C5 ~                                    ld      e,(ix+5)
  61++D3C5 ~                                    or     d
  62++D3C5 ~                                    or     e
  63++D3C5 ~                                    and     $7F
  64++D3C5 ~                                    jp      nz,.NoBreak
  65++D3C5 ~                                    break
  66++D3C5 ~            .NoBreak
  67++D3C5 ~                                    ld      ix,UBnkrotmatRoofvX
  68++D3C5 ~                                    call    ApplyRollAndPitchToIX
  69++D3C5 ~                                    ld      ix,UBnkrotmatNosevX
  70++D3C5 ~                                    call    ApplyRollAndPitchToIX
  71++D3C5 ~                                    ret
  72++D3C5 ~
  73++D3C5 ~            UBnKRoll_24Bit:			ld      a,(ALPHA)                   ; get roll value
  74++D3C5 ~            						and 	$7F
  75++D3C5 ~            						ld      d,a                         ; .
  76++D3C5 ~            						ld      a,(UBnKylo)                ; HLE = x sgn, hi, lo
  77++D3C5 ~            						ld      e,a                         ; .
  78++D3C5 ~            						ld      hl,(UBnKyhi)               ; .
  79++D3C5 ~            						call    mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * -alpha / 256
  80++D3C5 ~            						ld		a,l
  81++D3C5 ~            						ld		(UBnK24BitAlphaMulY),a			; save result
  82++D3C5 ~            						ld		(UBnK24BitAlphaMulY+1),de		; save result
  83++D3C5 ~            						ld      a,(ALPHA)                   ; get roll value
  84++D3C5 ~            						and 	$7F
  85++D3C5 ~            						ld      d,a                         ; .
  86++D3C5 ~            						ld      a,(UBnKxlo)                ; HLE = x sgn, hi, lo
  87++D3C5 ~            						ld      e,a                         ; .
  88++D3C5 ~            						ld      hl,(UBnKxhi)               ; .
  89++D3C5 ~            						call    mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * -alpha / 256
  90++D3C5 ~            						ld		a,l
  91++D3C5 ~            						ld		(UBnK24BitAlphaMulX),a			; save result
  92++D3C5 ~            						ld		(UBnK24BitAlphaMulX+1),de		; save result
  93++D3C5 ~            						ld		a,(ALPHA)
  94++D3C5 ~            						and		$80
  95++D3C5 ~            						jp		z,.RollingRight
  96++D3C5 ~            .RollingLeft:			ld		ix,UBnKxlo
  97++D3C5 ~            						ld		iy,UBnK24BitAlphaMulY
  98++D3C5 ~            						call	AddAtIXtoAtIY24Signed
  99++D3C5 ~            						ld		ix,UBnKylo
 100++D3C5 ~            						ld		iy,UBnK24BitAlphaMulX
 101++D3C5 ~            						call	SubAtIXtoAtIY24Signed
 102++D3C5 ~            						ret
 103++D3C5 ~            .RollingRight:			ld		ix,UBnKxlo
 104++D3C5 ~            						ld		iy,UBnK24BitAlphaMulY
 105++D3C5 ~            						call	SubAtIXtoAtIY24Signed
 106++D3C5 ~            						ld		ix,UBnKylo
 107++D3C5 ~            						ld		iy,UBnK24BitAlphaMulX
 108++D3C5 ~            						call	AddAtIXtoAtIY24Signed
 109++D3C5 ~            						ret
 110++D3C5 ~
 111++D3C5 ~            UBnKPitch_24Bit:		ld      a,(BETA)                   ; get roll value
 112++D3C5 ~            						and 	$7F
 113++D3C5 ~            						ld      d,a                         ; .
 114++D3C5 ~            						ld      a,(UBnKylo)                ; HLE = x sgn, hi, lo
 115++D3C5 ~            						ld      e,a                         ; .
 116++D3C5 ~            						ld      hl,(UBnKyhi)               ; .
 117++D3C5 ~            						call    mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * -alpha / 256
 118++D3C5 ~            						ld		a,l
 119++D3C5 ~            						ld		(UBnK24BitBetaMulY),a			; save result
 120++D3C5 ~            						ld		(UBnK24BitBetaMulY+1),de		; save result
 121++D3C5 ~            						ld      a,(BETA)                   ; get roll value
 122++D3C5 ~            						and 	$7F
 123++D3C5 ~            						ld      d,a                         ; .
 124++D3C5 ~            						ld      a,(UBnKzlo)                ; HLE = x sgn, hi, lo
 125++D3C5 ~            						ld      e,a                         ; .
 126++D3C5 ~            						ld      hl,(UBnKzhi)               ; .
 127++D3C5 ~            						call    mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * -alpha / 256
 128++D3C5 ~            						ld		a,l
 129++D3C5 ~            						ld		(UBnK24BitBetaMulZ),a			; save result
 130++D3C5 ~            						ld		(UBnK24BitBetaMulZ+1),de		; save result
 131++D3C5 ~            						ld		a,(BETA)
 132++D3C5 ~            						and		$80
 133++D3C5 ~            						jp		z,.Climbing
 134++D3C5 ~            .Diving:				ld		ix,UBnKylo
 135++D3C5 ~            						ld		iy,UBnK24BitBetaMulZ
 136++D3C5 ~            						call	AddAtIXtoAtIY24Signed
 137++D3C5 ~            						ld		ix,UBnKzlo
 138++D3C5 ~            						ld		iy,UBnK24BitBetaMulY
 139++D3C5 ~            						call	SubAtIXtoAtIY24Signed
 140++D3C5 ~            						ret
 141++D3C5 ~            .Climbing:		     	ld		ix,UBnKylo
 142++D3C5 ~            						ld		iy,UBnK24BitBetaMulZ
 143++D3C5 ~            						call	SubAtIXtoAtIY24Signed
 144++D3C5 ~            						ld		ix,UBnKzlo
 145++D3C5 ~            						ld		iy,UBnK24BitBetaMulY
 146++D3C5 ~            						call	AddAtIXtoAtIY24Signed
 147++D3C5 ~            						ret
 148++D3C5 ~
 149++D3C5                  ELSE
 150++D3C5              APPequPosPlusAPP:       MACRO    Position, PositionSign
 151++D3C5 ~                                    push    bc
 152++D3C5 ~                                    ld      c,a                         ; save original value of a into c
 153++D3C5 ~                                    ld      a,(PositionSign)
 154++D3C5 ~                                    ld      b,a
 155++D3C5 ~                                    ld      a,c
 156++D3C5 ~                                    xor     b                           ; a = a xor x postition sign
 157++D3C5 ~                                    jp      m,.MV50                     ; if the sign is negative then A and X are both opposite signs
 158++D3C5 ~            ; Signs are the same to we just add and take which ever sign
 159++D3C5 ~                                    ld      de,(varPp1)                  ; Note we take p+2,p+1 we we did a previous 24 bit mulitple
 160++D3C5 ~                                    ld      hl,(Position)
 161++D3C5 ~                                    add     hl,de
 162++D3C5 ~                                    ld      (varPp1),hl                  ; now we have P1 and p2 with lo hi and
 163++D3C5 ~                                    ld      a,c                         ; and a = original sign as they were both the same
 164++D3C5 ~                                    pop     bc
 165++D3C5 ~                                    ret
 166++D3C5 ~            ; Signs are opposite so we subtract
 167++D3C5 ~            .MV50:                  ld      de,(varPp1)
 168++D3C5 ~                                    ld      hl,(Position)
 169++D3C5 ~                                    or      a
 170++D3C5 ~                                    sbc     hl,de
 171++D3C5 ~                                    jr      c,.MV51                     ; if the result was negative then negate result
 172++D3C5 ~                                    ld      a,c                         ; get back the original sign
 173++D3C5 ~                                    ld      (varPp1),hl                 ; and save result to P[2][1]
 174++D3C5 ~                                    xor     SignOnly8Bit                ; flip sign and exit A = flip of a
 175++D3C5 ~                                    pop     bc
 176++D3C5 ~                                    ret
 177++D3C5 ~            .MV51:                  NegHL
 178++D3C5 ~                                    ld      (varPp1),hl
 179++D3C5 ~                                    ld      a,c                         ; the original sign will still be good
 180++D3C5 ~                                    pop     bc
 181++D3C5 ~                                    ret
 182++D3C5                                      ENDM
 183++D3C5
 184++D3C5
 185++D3C5              APPequXPosPlusAPP:     APPequPosPlusAPP UBnKxlo, UBnKxsgn
 185++D3C5 C5          >                        push    bc
 185++D3C6 4F          >                        ld      c,a                         ; save original value of a into c
 185++D3C7 3A 22 C0    >                        ld      a,(UBnKxsgn)
 185++D3CA 47          >                        ld      b,a
 185++D3CB 79          >                        ld      a,c
 185++D3CC A8          >                        xor     b                           ; a = a xor x postition sign
 185++D3CD FA DE D3    >                        jp      m,.MV50                     ; if the sign is negative then A and X are both opposite signs
 185++D3D0             >; Signs are the same to we just add and take which ever sign
 185++D3D0 ED 5B 17 6B >                        ld      de,(varPp1)                  ; Note we take p+2,p+1 we we did a previous 24 bit mulitple
 185++D3D4 2A 20 C0    >                        ld      hl,(UBnKxlo)
 185++D3D7 19          >                        add     hl,de
 185++D3D8 22 17 6B    >                        ld      (varPp1),hl                  ; now we have P1 and p2 with lo hi and
 185++D3DB 79          >                        ld      a,c                         ; and a = original sign as they were both the same
 185++D3DC C1          >                        pop     bc
 185++D3DD C9          >                        ret
 185++D3DE             >; Signs are opposite so we subtract
 185++D3DE ED 5B 17 6B >.MV50:                  ld      de,(varPp1)
 185++D3E2 2A 20 C0    >                        ld      hl,(UBnKxlo)
 185++D3E5 B7          >                        or      a
 185++D3E6 ED 52       >                        sbc     hl,de
 185++D3E8 38 08       >                        jr      c,.MV51                     ; if the result was negative then negate result
 185++D3EA 79          >                        ld      a,c                         ; get back the original sign
 185++D3EB 22 17 6B    >                        ld      (varPp1),hl                 ; and save result to P[2][1]
 185++D3EE EE 80       >                        xor     SignOnly8Bit                ; flip sign and exit A = flip of a
 185++D3F0 C1          >                        pop     bc
 185++D3F1 C9          >                        ret
 185++D3F2             >.MV51:                  NegHL
 185++D3F2 AF          >                    xor a
 185++D3F3 95          >                    sub l
 185++D3F4 6F          >                    ld l,a
 185++D3F5 9F          >                    sbc a,a
 185++D3F6 94          >                    sub h
 185++D3F7 67          >                    ld h,a
 185++D3F8 22 17 6B    >                        ld      (varPp1),hl
 185++D3FB 79          >                        ld      a,c                         ; the original sign will still be good
 185++D3FC C1          >                        pop     bc
 185++D3FD C9          >                        ret
 186++D3FE
 187++D3FE              APPequYPosPlusAPP:     APPequPosPlusAPP UBnKylo, UBnKysgn
 187++D3FE C5          >                        push    bc
 187++D3FF 4F          >                        ld      c,a                         ; save original value of a into c
 187++D400 3A 25 C0    >                        ld      a,(UBnKysgn)
 187++D403 47          >                        ld      b,a
 187++D404 79          >                        ld      a,c
 187++D405 A8          >                        xor     b                           ; a = a xor x postition sign
 187++D406 FA 17 D4    >                        jp      m,.MV50                     ; if the sign is negative then A and X are both opposite signs
 187++D409             >; Signs are the same to we just add and take which ever sign
 187++D409 ED 5B 17 6B >                        ld      de,(varPp1)                  ; Note we take p+2,p+1 we we did a previous 24 bit mulitple
 187++D40D 2A 23 C0    >                        ld      hl,(UBnKylo)
 187++D410 19          >                        add     hl,de
 187++D411 22 17 6B    >                        ld      (varPp1),hl                  ; now we have P1 and p2 with lo hi and
 187++D414 79          >                        ld      a,c                         ; and a = original sign as they were both the same
 187++D415 C1          >                        pop     bc
 187++D416 C9          >                        ret
 187++D417             >; Signs are opposite so we subtract
 187++D417 ED 5B 17 6B >.MV50:                  ld      de,(varPp1)
 187++D41B 2A 23 C0    >                        ld      hl,(UBnKylo)
 187++D41E B7          >                        or      a
 187++D41F ED 52       >                        sbc     hl,de
 187++D421 38 08       >                        jr      c,.MV51                     ; if the result was negative then negate result
 187++D423 79          >                        ld      a,c                         ; get back the original sign
 187++D424 22 17 6B    >                        ld      (varPp1),hl                 ; and save result to P[2][1]
 187++D427 EE 80       >                        xor     SignOnly8Bit                ; flip sign and exit A = flip of a
 187++D429 C1          >                        pop     bc
 187++D42A C9          >                        ret
 187++D42B             >.MV51:                  NegHL
 187++D42B AF          >                    xor a
 187++D42C 95          >                    sub l
 187++D42D 6F          >                    ld l,a
 187++D42E 9F          >                    sbc a,a
 187++D42F 94          >                    sub h
 187++D430 67          >                    ld h,a
 187++D431 22 17 6B    >                        ld      (varPp1),hl
 187++D434 79          >                        ld      a,c                         ; the original sign will still be good
 187++D435 C1          >                        pop     bc
 187++D436 C9          >                        ret
 188++D437
 189++D437              APPequZPosPlusAPP:     APPequPosPlusAPP UBnKzlo, UBnKzsgn
 189++D437 C5          >                        push    bc
 189++D438 4F          >                        ld      c,a                         ; save original value of a into c
 189++D439 3A 28 C0    >                        ld      a,(UBnKzsgn)
 189++D43C 47          >                        ld      b,a
 189++D43D 79          >                        ld      a,c
 189++D43E A8          >                        xor     b                           ; a = a xor x postition sign
 189++D43F FA 50 D4    >                        jp      m,.MV50                     ; if the sign is negative then A and X are both opposite signs
 189++D442             >; Signs are the same to we just add and take which ever sign
 189++D442 ED 5B 17 6B >                        ld      de,(varPp1)                  ; Note we take p+2,p+1 we we did a previous 24 bit mulitple
 189++D446 2A 26 C0    >                        ld      hl,(UBnKzlo)
 189++D449 19          >                        add     hl,de
 189++D44A 22 17 6B    >                        ld      (varPp1),hl                  ; now we have P1 and p2 with lo hi and
 189++D44D 79          >                        ld      a,c                         ; and a = original sign as they were both the same
 189++D44E C1          >                        pop     bc
 189++D44F C9          >                        ret
 189++D450             >; Signs are opposite so we subtract
 189++D450 ED 5B 17 6B >.MV50:                  ld      de,(varPp1)
 189++D454 2A 26 C0    >                        ld      hl,(UBnKzlo)
 189++D457 B7          >                        or      a
 189++D458 ED 52       >                        sbc     hl,de
 189++D45A 38 08       >                        jr      c,.MV51                     ; if the result was negative then negate result
 189++D45C 79          >                        ld      a,c                         ; get back the original sign
 189++D45D 22 17 6B    >                        ld      (varPp1),hl                 ; and save result to P[2][1]
 189++D460 EE 80       >                        xor     SignOnly8Bit                ; flip sign and exit A = flip of a
 189++D462 C1          >                        pop     bc
 189++D463 C9          >                        ret
 189++D464             >.MV51:                  NegHL
 189++D464 AF          >                    xor a
 189++D465 95          >                    sub l
 189++D466 6F          >                    ld l,a
 189++D467 9F          >                    sbc a,a
 189++D468 94          >                    sub h
 189++D469 67          >                    ld h,a
 189++D46A 22 17 6B    >                        ld      (varPp1),hl
 189++D46D 79          >                        ld      a,c                         ; the original sign will still be good
 189++D46E C1          >                        pop     bc
 189++D46F C9          >                        ret
 190++D470
 191++D470              ; rollWork holds Alpha intermidate results
 192++D470 00 00 00     rollWork      DS 3
 193++D473              rollWorkp1    equ rollWork
 194++D473              rollWorkp2    equ rollWork+1
 195++D473              rollWorkp3    equ rollWork+2
 196++D473
 197++D473              ;----------------------------------------------------------------------------------------------------------------------------------
 198++D473              ; based on MVEIT part 4 of 9
 199++D473 3A 30 6B     ApplyMyRollAndPitch:    ld      a,(ALP1)                    ; get roll magnitude
 200++D476 21 24 6B                             ld      hl,BET1                     ; and pitch
 201++D479 B6                                   or      (hl)
 202++D47A CA 38 D5                             jp      z,.NoRotation               ; if both zero then don't compute
 203++D47D              ; If the xsgn,ysng or zsng are not 0 or $80 then we use 24 bit routines
 204++D47D              ; else we can just continue to use 16 bit
 205++D47D                                     ;jp      ApplyMyRollAndPitch24Bit
 206++D47D
 207++D47D 3A 22 C0     .CheckFor24Bit:         ld      a,(UBnKxsgn)
 208++D480 21 25 C0                             ld      hl,UBnKysgn
 209++D483 B6                                   or      (hl)
 210++D484 21 28 C0                             ld      hl,UBnKzsgn
 211++D487 B6                                   or      (hl)
 212++D488 E6 7F                                and     $7F
 213++D48A C2 C2 D5                             jp      nz,ApplyMyRollAndPitch24Bit
 214++D48D                                      ;break
 215++D48D              ; P[210] = x * alph (we use P[2]P[1] later as result/256
 216++D48D 5F           .Not24BitCalcs:         ld      e,a                         ; e = roll magnitude
 217++D48E 2A 20 C0                             ld      hl,(UBnKxlo)                ; hl = ship x pos
 218++D491 CD 3D 71                             call    AHLequHLmulE                ; MULTU2-2 AHL = UbnkXlo * Alp1 both unsigned
 219++D494 32 18 6B                             ld      (varPhi2),a                 ; set P[2] to high byte to help with ./256
 220++D497 22 16 6B                             ld      (varP),hl                   ; P (2 1 0) = UbnkXlo * Alph1
 221++D49A              ; A = Flip sign
 222++D49A 3A 31 6B                             ld      a,(ALP2)                ; flip the current roll angle alpha and xor with x sign
 223++D49D 21 22 C0                             ld      hl,UBnKxsgn                 ; and xor with x pos sign
 224++D4A0 AE                                   xor     (hl)                        ; so now  (A P+2 P+1) = - (x_sign x_hi x_lo) * alpha / 256
 225++D4A1              ; AP[2]P[1] =Y + AP[2]P[1] (i.e. Previous APP/256)
 226++D4A1 CD FE D3                             call    APPequYPosPlusAPP           ; MVT6 calculate APP = y - (x * alpha / 256)
 227++D4A4              ; K2 = AP[2][1] K2(3 2 1) = (A P+2 P+1) = y - x * alpha / 256
 228++D4A4 32 72 D4                             ld      (rollWorkp3),a               ; k2+3 = sign of result
 229++D4A7 22 70 D4                             ld      (rollWorkp1),hl             ; k2+1,2 = result
 230++D4AA              ; P[210] = K2[2 1] * Beta  = (A ~P) * X
 231++D4AA 3A 24 6B                             ld      a,(BET1)                    ; a = magnitude of pitch
 232++D4AD 5F                                   ld      e,a
 233++D4AE CD 3D 71                             call    AHLequHLmulE                ; MLTU2-2 AHL = (P+2 P+1) * BET1 or by now ((UbnkXlo * Alph1)/256 * Bet1)
 234++D4B1 32 18 6B                             ld      (varPp2),a                   ; save highest byte in P2
 235++D4B4 22 16 6B                             ld      (varP),hl
 236++D4B7              ; Fetch sign of previosu cal and xor with BETA inverted
 237++D4B7 3A 72 D4                             ld      a,(rollWorkp3)
 238++D4BA 5F                                   ld      e,a
 239++D4BB 3A 25 6B                             ld      a,(BET2)
 240++D4BE AB                                   xor     e                           ; so we get the sign of K3 and xor with pitch sign
 241++D4BF              ; Z = P[210] =Z + APP
 242++D4BF CD 37 D4                             call    APPequZPosPlusAPP           ; MVT6
 243++D4C2 32 28 C0                             ld      (UBnKzsgn),a                ; save result back into z
 244++D4C5 22 26 C0                             ld      (UBnKzlo),hl
 245++D4C8              ; A[P1]P[0] = z * Beta
 246++D4C8 3A 24 6B                             ld      a,(BET1)                    ; get pitch back again for mulitply in original it was kept in Q so no fetch needed
 247++D4CB 5F                                   ld      e,a
 248++D4CC CD 3D 71                             call    AHLequHLmulE                ; MULTU2 P2 P1 was already in hl (A P+1 P) = (z_hi z_lo) * beta
 249++D4CF 32 18 6B                             ld      (varPp2),a                  ; P2 = high byte of result
 250++D4D2 22 16 6B                             ld      (varP),hl                   ; P (2 1 0) = UbnkXlo & Alph1
 251++D4D5              ; A xor BET2,Zsign
 252++D4D5 3A 72 D4                             ld      a,(rollWorkp3)               ; get K3 (sign of y) and store it in y pos
 253++D4D8 32 25 C0                             ld      (UBnKysgn),a                ; save result back into y
 254++D4DB 5F                                   ld      e,a                         ; a = y sign Xor pitch rate sign
 255++D4DC 3A 25 6B                             ld      a,(BET2)                    ;
 256++D4DF AB                                   xor     e                           ;
 257++D4E0 5F                                   ld      e,a                         ; now xor it with z sign too
 258++D4E1 3A 28 C0                             ld      a,(UBnKzsgn)                ;
 259++D4E4 AB                                   xor     e                           ; so now a = sign of y * beta * sign y * sign z
 260++D4E5 F2 F4 D4                             jp      p,.MV43                     ; if result is pve beta * z and y have differetn signs
 261++D4E8 2A 17 6B                             ld      hl,(varPp1)
 262++D4EB ED 5B 70 D4                          ld      de,(rollWorkp1)
 263++D4EF B7                                   or      a
 264++D4F0 19                                   add     hl,de
 265++D4F1 C3 0E D5                             jp      .MV44
 266++D4F4 2A 70 D4     .MV43:                  ld      hl,(rollWorkp1)
 267++D4F7 ED 5B 17 6B                          ld      de,(varPp1)
 268++D4FB B7                                   or      a
 269++D4FC ED 52                                sbc     hl,de                       ; (y_hi y_lo) = K2(2 1) - P(2 1)
 270++D4FE 30 0E                                jr      nc,.MV44                    ; if there was no over flow carry on
 271++D500                                      NegHL
 271++D500 AF          >                    xor a
 271++D501 95          >                    sub l
 271++D502 6F          >                    ld l,a
 271++D503 9F          >                    sbc a,a
 271++D504 94          >                    sub h
 271++D505 67          >                    ld h,a
 272++D506 3A 25 C0                             ld      a,(UBnKysgn)                ; flip sign bit TODO, we may have to remove xor as planets and Univs are sign + 23 bit xpos
 273++D509 EE 80                                xor     SignOnly8Bit
 274++D50B 32 25 C0                             ld      (UBnKysgn),a
 275++D50E              ; by here we have (y_sign y_hi y_lo) = K2(2 1) - P(2 1) = K2 - beta * z
 276++D50E 22 23 C0     .MV44:                  ld      (UBnKylo),hl                ; we do save here to avoid two writes if MV43 ended up with a 2s'c conversion
 277++D511 3A 30 6B                             ld      a,(ALP1)                    ; get roll magnitude
 278++D514 5F                                   ld      e,a
 279++D515 2A 23 C0                             ld      hl,(UBnKylo)
 280++D518 CD 3D 71                             call    AHLequHLmulE                ; MLTU2-2 AHL = (y_hi y_lo) * alpha
 281++D51B 32 18 6B                             ld      (varPp2),a                  ; store high byte P(2 1 0) = (y_hi y_lo) * alpha
 282++D51E 22 16 6B                             ld      (varP),hl
 283++D521 3A 32 6B                             ld      a,(ALP2FLIP)
 284++D524 5F                                   ld      e,a
 285++D525 3A 25 C0                             ld      a,(UBnKysgn)
 286++D528 AB                                   xor     e                           ; a = sign of roll xor y so now we have (A P+2 P+1) = (y_sign y_hi y_lo) * alpha / 256
 287++D529 CD C5 D3                             call    APPequXPosPlusAPP           ; MVT6 Set (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1) = x + y * alpha / 256
 288++D52C 32 22 C0                             ld      (UBnKxsgn),a                ; save resutl stright into X pos
 289++D52F 22 20 C0                             ld      (UBnKxlo),hl
 290++D532                                      ;break
 291++D532 CD 51 D5                             call    ApplyMyRollToOrientation
 292++D535 CD 80 D5                             call    ApplyMyPitchToOrientation
 293++D538                                      ; if its not a Univ then apply to local orientation
 294++D538 3A 10 6C     .NoRotation:            ld      a,(DELTA)                   ; get speed
 295++D53B 16 00                                ld      d,0
 296++D53D 5F                                   ld      e,a                         ; de = speed in low byte
 297++D53E 2A 26 C0                             ld      hl,(UBnKzlo)                ; hl = z position
 298++D541 3A 28 C0                             ld      a,(UBnKzsgn)                ; b = z sign
 299++D544 47                                   ld      b,a                         ;
 300++D545 0E 80                                ld      c,$80                       ; c = -ve as we are always moving forwards
 301++D547 CD 33 00                             call    ADDHLDESignBC               ; update speed
 302++D54A 22 26 C0                             ld      (UBnKzlo),hl                ; write back to zpos
 303++D54D 32 28 C0                             ld      (UBnKzsgn),a                ;
 304++D550 C9                                   ret
 305++D551
 306++D551                             DISPLAY "TODO: Looks like pitch is always being applied as positive"
 307++D551              ApplyMyRollToOrientation:MMUSelectMathsBankedFns
 307++D551 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 308++D555 3A 2F 6B                             ld      a,(ALPHA)
 308++D558 DD 21 36 C0    ld ix,UBnkrotmatNosevX
 308++D55C FD 21 38 C0    ld iy,UBnkrotmatNosevY
 308++D560 CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyRollToNosev:
 309++D563 3A 2F 6B                             ld      a,(ALPHA)
 309++D566 DD 21 2A C0    ld ix,UBnkrotmatSidevX
 309++D56A FD 21 2C C0    ld iy,UBnkrotmatSidevY
 309++D56E CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyRollToSidev:
 310++D571 3A 2F 6B                             ld      a,(ALPHA)
 310++D574 DD 21 30 C0    ld ix,UBnkrotmatRoofvX
 310++D578 FD 21 32 C0    ld iy,UBnkrotmatRoofvY
 310++D57C CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyRollToRoofv:
 311++D57F C9                                   ret
 312++D580
 313++D580              ApplyMyPitchToOrientation:
 314++D580 3A 22 6B                             ld      a,(BETA)
 314++D583 DD 21 3A C0    ld ix,UBnkrotmatNosevZ
 314++D587 FD 21 38 C0    ld iy,UBnkrotmatNosevY
 314++D58B CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyPitchToNosev:
 315++D58E 3A 22 6B                             ld      a,(BETA)
 315++D591 DD 21 2E C0    ld ix,UBnkrotmatSidevZ
 315++D595 FD 21 2C C0    ld iy,UBnkrotmatSidevY
 315++D599 CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyPitchToSidev:
 316++D59C 3A 22 6B                             ld      a,(BETA)
 316++D59F DD 21 34 C0    ld ix,UBnkrotmatRoofvZ
 316++D5A3 FD 21 32 C0    ld iy,UBnkrotmatRoofvY
 316++D5A7 CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyPitchToRoofv:
 317++D5AA C9                                   ret
 318++D5AB              ;----------------------------------------------------------------------------------------------------------------------------------
 319++D5AB              ; 24 bit version of pitch and roll is a 24 bit calculation 1 bit sign + 23 bit value
 320++D5AB              ; Need to write a test routine for roll and pitchs
 321++D5AB              ; Minsky Roll       Minsky Pitch
 322++D5AB              ;  y -= alpha * x    y -= beta * z
 323++D5AB              ;  x += alpha * y    z += beta * y
 324++D5AB              ; or once combined
 325++D5AB              ;   1. K2 = y - alpha * x
 326++D5AB              ;   2. z = z + beta * K2
 327++D5AB              ;   3. y = K2 - beta * z
 328++D5AB              ;   4. x = x + alpha * y
 329++D5AB              ;----------------------------------------------------------------------------------------------------------------------------------
 330++D5AB              ; Based on non optimised version of Planet pitch and roll is a 24 bit calculation 1 bit sign + 23 bit value
 331++D5AB              ; Now at least rolls the correct direction
 332++D5AB 00 00 00 00  UnivAlphaMulX               DB $00,$00, $00, $00
 333++D5AF 00 00 00 00  UnivAlphaMulY               DB $00,$00, $00, $00
 334++D5B3 00 00 00 00  UnivAlphaMulZ               DB $00,$00, $00, $00
 335++D5B7 00 00 00 00  UnivBetaMulZ                DB $00,$00, $00, $00
 336++D5BB 00 00 00 00  UnivBetaMulY                DB $00,$00, $00, $00
 337++D5BF 00 00 00     UnivK2                      DS 3
 338++D5C2
 339++D5C2 3A 2F 6B     ApplyMyRollAndPitch24Bit: 	 ld     a,(ALPHA)                   ; no roll or pitch, no calc needed
 340++D5C5 21 22 6B                                  ld     hl,BETA
 341++D5C8 B6                                        or     (hl)
 342++D5C9 C4 ED D5                                  call   nz, Univ_Roll_And_Pitch
 343++D5CC              ;.CheckForRoll:              and		a
 344++D5CC              ;							call	nz,Univ_Roll
 345++D5CC              ;.CheckForPitch:				ld		a,(BETA)
 346++D5CC              ;							and		a
 347++D5CC              ;							call	nz,Univ_Pitch
 348++D5CC 3A 10 6C     .ApplySpeed:            	ld      a,(DELTA)                   ; BCH = - Delta
 349++D5CF              							ReturnIfAIsZero
 349++D5CF A7          >                        and     a
 349++D5D0 C8          >                        ret     z
 350++D5D1 0E 00        							ld      c,0                         ;
 351++D5D3 67           							ld      h,a                         ;
 352++D5D4 06 80        							ld      b,$80                       ;
 353++D5D6 ED 5B 27 C0  							ld      de,(UBnKzhi)                ; DEL = z position
 354++D5DA 3A 26 C0     							ld      a,(UBnKzlo)                 ; .
 355++D5DD 6F           							ld      l,a                         ; .
 356++D5DE CD 14 01     							call    AddBCHtoDELsigned           ; update speed
 357++D5E1 ED 53 27 C0  							ld      (UBnKzhi),DE                ; write back to zpos
 358++D5E5 7D           							ld      a,l
 359++D5E6 32 26 C0     							ld      (UBnKzlo),a                ;
 360++D5E9 C9           							ret
 361++D5EA
 362++D5EA              ; Performs minsky rotation
 363++D5EA              ; Joystick left          Joystick right
 364++D5EA              ; ---------------------  ---------------------
 365++D5EA              ; x :=  x      + y / 64  x :=  x -  y / 64  so rather than /64  is z * alpha / 256
 366++D5EA              ; y :=  y      - x /64   y :=  y +  x / 64
 367++D5EA              ;
 368++D5EA              ; Joystick down          Joystick up
 369++D5EA              ; ---------------------  ---------------------
 370++D5EA              ; y :=  y      + z / 64  y :=  y - z / 64
 371++D5EA              ; z :=  z      - y / 64  z :=  z + y / 64
 372++D5EA              ;
 373++D5EA              ; get z, multiply by alpha, pick top 3 bytes with sign
 374++D5EA              ; get x, multiply by alpha, pick top 3 bytes with sign
 375++D5EA              ; if alpha +ve subtract x = x - z adj, z =z + x adj , else x += z adj z -= z adj
 376++D5EA              ; so we can assume 24 bit maths and just do 16 bit multiply of say HL = nosev x [sgn][hi] and de = [0][alpha] by calling AHLequHLmulE
 377++D5EA              ; for roll
 378++D5EA              ; nosev_y = nosev_y - alpha * nosev_x_hi
 379++D5EA              ; nosev_x = nosev_x + alpha * nosev_y_hi
 380++D5EA              ; and for pitch
 381++D5EA              ; nosev_y = nosev_y - beta * nosev_z_hi
 382++D5EA              ; nosev_z = nosev_z + beta * nosev_y_hi
 383++D5EA              ;  1. K2 = y - alpha * x
 384++D5EA              ;   2. z = z + beta * K2
 385++D5EA              ;   3. y = K2 - beta * z
 386++D5EA              ;   4. x = x + alpha * y
 387++D5EA              ;
 388++D5EA              ;   1a. K [3 2 1 0] = -alpha * (x sign hi lo)
 389++D5EA              ;   1b. K [3 2 1]   = y sign hi lo + K [321] (in effect y minus (alpha * x / 256)
 390++D5EA              ;   1c. K2 [3 2 1]  = k [3 2 1 ]
 391++D5EA              ;   2a. K[3 2 1 0]  = k2 [3 2 1] * beta
 392++D5EA              ;   2b. z sign hi lo += K[3 2 1] ( in effect z += (beta * K2)/256
 393++D5EA              ;   3a. K [3 2 1 0] = z sign hi lo * -beta
 394++D5EA              ;   3b. y sign hi lo = K2 [3 2 1] - K [3 2 1] ( in effect K2 - (beta * z) /256
 395++D5EA              ;
 396++D5EA              ;   4. x = x + alpha * y
 397++D5EA
 398++D5EA
 399++D5EA
 400++D5EA              ;-- Q = - ALPHA
 401++D5EA              ;-- A P[1 0] = xsign xhi xlo
 402++D5EA              ;-- call K[3 2 1 0] = A P[1 0] * Q which means  K(3 2 1) = (A P+1 P) * Q / 256 = x * -alpha / 256 = - alpha * x / 256
 403++D5EA              ;-- call K[3 2 1] = ysign hi lo + K[3 2 1] (= y - alpha * x / 256)
 404++D5EA              ;-- K2 [3 2 1 ] = K [ 3 2 1 ]
 405++D5EA              ;-- A P [1 0]   = K [3 2 1]
 406++D5EA              ;-- Q = BETA
 407++D5EA              ;-- K[3 2 1 0] = A P[1 0] * Q
 408++D5EA              ;-- K3[3 2 1] = z sign hi lo + K[3 2 1]
 409++D5EA              ;-- A P [1 0] = -K [3 2 1]
 410++D5EA              ;-- z sign hi lo = K[3 2 1]
 411++D5EA              ;-- K[3 2 1 0] = A P[1 0] * Q
 412++D5EA              ;-- T = K[3] sign bit
 413++D5EA              ;-- A = K[3] sign bit xor K2[3]
 414++D5EA              ;-- if positive A yhi lo - = K [3 2 1 0] + K2[3 2 1 0] so A yhi ylo = K + K2 /256 as we abandon low byte
 415++D5EA              ;-- if negative A yhi lo = (K - k2 )/256
 416++D5EA              ;-- A = A xor T
 417++D5EA              ;-- y sign = A
 418++D5EA              ;-- Q = alpha
 419++D5EA              ;-- A P(1 0) = y sign hi lo
 420++D5EA              ;-- K[3 2 1 0 ] A P[1 0] * Q
 421++D5EA              ;-- x sign hi lo = K[3 2 1] = xsign hi lo * K[3 2 1]
 422++D5EA
 423++D5EA 00 00 00     K2      DS  3
 424++D5ED
 425++D5ED 3A 2F 6B     Univ_Roll_And_Pitch:	    ld      a,(ALPHA)                   ; get roll value
 426++D5F0              ;** 1. K2 = y - alpha * x **************************************
 427++D5F0              ;-- DEL = alpha * (x sign hi lo) /256
 428++D5F0 57           							ld      d,a                         ; d = alpha
 429++D5F1 3A 20 C0     							ld      a,(UBnKxlo)                 ; HLE = x sgn, hi, lo
 430++D5F4 5F           							ld      e,a                         ; .
 431++D5F5 2A 21 C0     							ld      hl,(UBnKxhi)                ; hl = UBnKchi sgn
 432++D5F8 CD 0C 72     							call    mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * alpha / 256
 433++D5FB              ;-- DEL = K2 = y - alpha * x
 434++D5FB 42 4B                                    ld      bc,de                       ; transfer to BCH for now
 435++D5FD 65                                       ld      h,l
 436++D5FE ED 5B 24 C0                              ld      de,(UBnKyhi)
 437++D602 3A 23 C0                                 ld      a,(UBnKylo)
 438++D605 6F                                       ld      l,a
 439++D606 CD 10 01                                 call    SubBCHfromDELsigned
 440++D609 ED 53 EB D5                              ld      (K2+1),de
 441++D60D 7D                                       ld      a,l
 442++D60E 32 EA D5                                 ld      (K2),a
 443++D611              ;** 2. z = z + beta * K2 ***************************************
 444++D611              ;-- HLE = DEL ..................................................
 445++D611 EB                                       ex      de,hl                       ; will set hl to de and e to l in one go
 446++D612              ;-- DELC = beta * HLE, i.e. beta * K2
 447++D612 3A 22 6B                                 ld      a,(BETA)
 448++D615 57                                       ld      d,a
 449++D616 CD 0C 72                                 call    mulHLEbyDSigned             ; DELC = beta * K2
 450++D619              ;-- DEL = z + DEL, i.e. z + Beta * K2 /256
 451++D619 ED 4B 27 C0                              ld      bc,(UBnKzhi)                ; BCH = z
 452++D61D 3A 26 C0                                 ld      a,(UBnKzlo)                 ; .
 453++D620 67                                       ld      h,a                         ; .
 454++D621 CD 14 01                                 call    AddBCHtoDELsigned           ; DEL =z + (beta * K2)/256
 455++D624 ED 53 27 C0                              ld      (UBnKzhi),de                ; and save to Z
 456++D628 7D                                       ld      a,l                         ; .
 457++D629 32 26 C0                                 ld      (UBnKzlo),a                 ; .
 458++D62C              ;** 3. y = K2 - beta * z ***************************************
 459++D62C              ;-- DEL = beta * z / 256
 460++D62C 3A 22 6B                                 ld      a,(BETA)                    ; get pitch value
 461++D62F 57           							ld      d,a                         ; d = pitch
 462++D630 3A 26 C0     							ld      a,(UBnKzlo)                 ; HLE = z sgn, hi, lo
 463++D633 5F           							ld      e,a                         ; .
 464++D634 2A 27 C0     							ld      hl,(UBnKzhi)                ; hl = UBnKchi sgn
 465++D637 CD 0C 72     							call    mulHLEbyDSigned             ; DELC = z * beta, so DEL = z * beta / 256
 466++D63A              ;-- BCH = DEL ..................................................
 467++D63A 42 4B                                    ld      bc,de                       ; transfer to BCH for now
 468++D63C 65                                       ld      h,l
 469++D63D              ;-- y = DEL = K2 - beta * z = DEL - BCH
 470++D63D ED 5B EB D5                              ld      de,(K2+1)                   ; del = K2
 471++D641 3A EA D5                                 ld      a,(K2)                      ; .
 472++D644 6F                                       ld      l,a                         ; .
 473++D645 CD 10 01                                 call    SubBCHfromDELsigned         ; .
 474++D648 ED 53 24 C0                              ld      (UBnKyhi),de                ; and save to y
 475++D64C 7D                                       ld      a,l                         ; .
 476++D64D 32 23 C0                                 ld      (UBnKylo),a                 ; .
 477++D650              ;** 4. x = x + alpha * y ***************************************
 478++D650              ;-- DEL = alpha * y
 479++D650 3A 2F 6B                                 ld      a,(ALPHA)                   ; get roll value
 480++D653              ;-- DEL = alpha * (y sign hi lo) /256
 481++D653 57           							ld      d,a                         ; d = alpha
 482++D654 3A 23 C0     							ld      a,(UBnKylo)                 ; HLE = y sgn, hi, lo
 483++D657 5F           							ld      e,a                         ; .
 484++D658 2A 24 C0     							ld      hl,(UBnKyhi)                ; hl = UBnKyhi sgn
 485++D65B CD 0C 72     							call    mulHLEbyDSigned             ; DELC = y * alpha, so DEL = Y * alpha / 256
 486++D65E              ;-- DEL = x + alpha * y
 487++D65E 42 4B                                    ld      bc,de                       ; transfer to BCH for now
 488++D660 65                                       ld      h,l                         ; .
 489++D661 ED 5B 21 C0                              ld      de,(UBnKxhi)                ; del = x
 490++D665 3A 20 C0                                 ld      a,(UBnKxlo)                 ; .
 491++D668 6F                                       ld      l,a                         ; .
 492++D669 CD 14 01                                 call    AddBCHtoDELsigned           ; del = del + bch = x + alpha * y
 493++D66C ED 53 21 C0                              ld      (UBnKxhi),de                ; and save to x
 494++D670 7D                                       ld      a,l                         ; .
 495++D671 32 20 C0                                 ld      (UBnKxlo),a                 ; .
 496++D674              .ApplyRollToRight:          ;call    ApplyMyRollToOrientation
 497++D674 CD 80 D5     .ApplyPitchToClimb:         call    ApplyMyPitchToOrientation
 498++D677                                        ;  call    TidyVectorsIX ; doesn't work
 499++D677 C9           							ret
 500++D678                  ENDIF
 501++D678
# file closed: ../../Tests/Vectors/../../Universe/Ships/ApplyMyRollAndPitch.asm
 893+ D678                          INCLUDE "../../Universe/Ships/ApplyShipRollAndPitch.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/ApplyShipRollAndPitch.asm
   1++D678
   2++D678
   3++D678              ;----------------------------------------------------------------------------------------------------------------------------------
   4++D678              ; based on MVEIT part 4 of 9
   5++D678              ; x and z counters are proper 2's c values
   6++D678 3A 89 C0     ApplyShipRollAndPitch:  ld      a,(UBnKRotZCounter)
   7++D67B FE FF                                cp      $FF
   8++D67D 28 18                                jr      z,.PitchSAxes
   9++D67F 47           .splitAndDampenZ:       ld      b,a                     ; preserve S7 counter
  10++D680 E6 7F                                and     SignMask8Bit            ; if abs (Rotz) is 0 then skip pitch
  11++D682 CA C4 D6                             jp      z,.ProcessRoll
  12++D685 78                                   ld      a,b                     ; b = rotate counter S7
  13++D686 E6 80                                and     SignOnly8Bit            ; a = sign rat2 = c = sign
  14++D688 4F                                   ld      c,a                     ; .
  15++D689 32 8F C0                             ld      (univRAT2),a            ; .
  16++D68C 78                                   ld      a,b                     ; a = abs b
  17++D68D E6 7F                                and     SignMask8Bit            ; .
  18++D68F 3D                                   dec     a                       ; dampen
  19++D690 32 90 C0                             ld      (univRAT2Val),a
  20++D693 B1                                   or      c                       ; make S7 again after dampening
  21++D694 32 89 C0                             ld      (UBnKRotZCounter),a     ; Update Rotation Counter
  22++D697 21 30 C0     .PitchSAxes:            ld	    hl,UBnkrotmatRoofvX; UBnkrotmatSidevY
  23++D69A 22 FB 6A                             ld	    (varAxis1),hl
  24++D69D 21 36 C0                             ld	    hl,UBnkrotmatNosevX; UBnkrotmatSidevZ
  25++D6A0 22 FD 6A                             ld	    (varAxis2),hl
  26++D6A3 CD 10 D7                             call    MVS5RotateAxis
  27++D6A6 21 32 C0     .PitchRAxes:            ld	    hl,UBnkrotmatRoofvY
  28++D6A9 22 FB 6A                             ld	    (varAxis1),hl
  29++D6AC 21 38 C0                             ld	    hl,UBnkrotmatNosevY;UBnkrotmatRoofvZ
  30++D6AF 22 FD 6A                             ld	    (varAxis2),hl
  31++D6B2 CD 10 D7                             call    MVS5RotateAxis
  32++D6B5 21 34 C0     .PitchNAxes:            ld	    hl,UBnkrotmatRoofvZ; UBnkrotmatNosevY
  33++D6B8 22 FB 6A                             ld	    (varAxis1),hl
  34++D6BB 21 3A C0                             ld	    hl,UBnkrotmatNosevZ
  35++D6BE 22 FD 6A                             ld	    (varAxis2),hl
  36++D6C1 CD 10 D7                             call    MVS5RotateAxis
  37++D6C4 3A 88 C0     .ProcessRoll:           ld      a,(UBnKRotXCounter)
  38++D6C7 FE FF                                cp      $FF
  39++D6C9 28 17                                jr      z,.RollSAxis
  40++D6CB 47           .splitAndDampenX:       ld      b,a
  41++D6CC E6 7F                                and     SignMask8Bit            ; exit early is ABS = 0
  42++D6CE A7                                   and     a                       ; .
  43++D6CF C8                                   ret     z                       ; .
  44++D6D0 78                                   ld      a,b                     ; a = rotate counter S7
  45++D6D1 E6 80                                and     SignOnly8Bit            ; rat2 = c = sign
  46++D6D3 4F                                   ld      c,a                     ; .
  47++D6D4 32 8F C0                             ld      (univRAT2),a            ; .
  48++D6D7 78                                   ld      a,b                     ; a = abs b
  49++D6D8 E6 7F                                and     SignMask8Bit            ; .
  50++D6DA 3D                                   dec     a                       ; dampen
  51++D6DB 32 90 C0                             ld      (univRAT2Val),a
  52++D6DE B1                                   or      c                       ; make S7 again after dampening
  53++D6DF 32 88 C0                             ld      (UBnKRotXCounter),a
  54++D6E2 21 30 C0     .RollSAxis:           	ld	    hl,UBnkrotmatRoofvX; UBnkrotmatSidevX
  55++D6E5 22 FB 6A                             ld	    (varAxis1),hl
  56++D6E8 21 2A C0                             ld	    hl,UBnkrotmatSidevX; UBnkrotmatSidevY
  57++D6EB 22 FD 6A                             ld	    (varAxis2),hl
  58++D6EE CD 10 D7                             call    MVS5RotateAxis
  59++D6F1 21 32 C0     .RollRAxis:             ld	    hl,UBnkrotmatRoofvY; UBnkrotmatRoofvX
  60++D6F4 22 FB 6A                             ld	    (varAxis1),hl
  61++D6F7 21 2C C0                             ld	    hl,UBnkrotmatSidevY; UBnkrotmatRoofvY
  62++D6FA 22 FD 6A                             ld	    (varAxis2),hl
  63++D6FD CD 10 D7                             call    MVS5RotateAxis
  64++D700 21 34 C0     .RollNAxis:             ld	    hl,UBnkrotmatRoofvZ; UBnkrotmatNosevX
  65++D703 22 FB 6A                             ld	    (varAxis1),hl
  66++D706 21 2E C0                             ld	    hl,UBnkrotmatSidevZ; UBnkrotmatNosevY
  67++D709 22 FD 6A                             ld	    (varAxis2),hl
  68++D70C CD 10 D7                             call    MVS5RotateAxis
  69++D70F C9                                   ret
  70++D710
  71++D710
  72++D710
  73++D710              ; Roate around axis
  74++D710              ; varAxis1 and varAxis2 point to the address of the axis to rotate
  75++D710              ; so the axis x1 points to roofv  x , y or z
  76++D710              ;             x2           nosev or sidev  x, y or z
  77++D710              ;   Axis1 = Axis1 * (1 - 1/512)  + Axis2 / 16
  78++D710              ;   Axis2 = Axis2 * (1 - 1/512)  - Axis1 / 16
  79++D710              ; var RAT2 gives direction
  80++D710              ; for pitch x we come in with Axis1 = roofv_x and Axis2 = nosev_x
  81++D710              ;-Set up S R -----------------------------------------
  82++D710              ; optimised we don't deal with sign here just the value of roof axis / 512
  83++D710 2A FB 6A     MVS5RotateAxis:         ld      hl,(varAxis1)   ; work on roofv axis to get (1- 1/152) * roofv axis
  84++D713 5E                                   ld      e,(hl)
  85++D714 23                                   inc     hl
  86++D715 56                                   ld      d,(hl)          ; de = Axis1 (roofv x for pitch x)
  87++D716 EB                                   ex      de,hl           ; hl = Axis1 (roofv x for pitch x)
  88++D717 7C                                   ld      a,h
  89++D718 E6 80                                and     SignOnly8Bit
  90++D71A FD 67                                ld      iyh,a           ; iyh = sign Axis1
  91++D71C 7C                                   ld      a,h
  92++D71D E6 7F                                and     SignMask8Bit    ; a = Axis1 (roof hi axis  unsigned)
  93++D71F CB 3F                                srl     a               ; a = Axis1/2
  94++D721 5F                                   ld      e,a             ;
  95++D722 FD 7C                                ld      a,iyh           ; A = Axis 1 sign
  96++D724 57                                   ld      d,a             ; de = signed Axis1 / 512
  97++D725 B7                                   or      a               ; clear carry
  98++D726 CD 75 01                             call    subHLDES15      ; hl = roof axis - (roof axis /512) which in effect is roof * (1-1/512)
  99++D729              ;-Push to stack roof axis - (roofaxis/152)  ----------------------------------------------------------------------------------
 100++D729 E5                                   push    hl              ; save hl on stack PUSH ID 1 (roof axis - roofv aixs /512)
 101++D72A 7D                                   ld      a,l
 102++D72B 32 17 6C                             ld      (varR),a
 103++D72E 7C                                   ld      a,h
 104++D72F 32 18 6C                             ld      (varS),a        ;  RS now equals (1- 1/152) * roofv axis or (roof axis - roofv aixs /512)
 105++D732              ;-calculate roofv latter half of calc
 106++D732 2A FD 6A                             ld      hl,(varAxis2)   ; now work on nosev axis to get nosev axis / 16
 107++D735 5E                                   ld      e,(hl)
 108++D736 23                                   inc     hl
 109++D737 56                                   ld      d,(hl)          ; de = value of roof axis
 110++D738 7A                                   ld      a,d
 111++D739 E6 80                                and     SignOnly8Bit
 112++D73B FD 67                                ld      iyh,a           ; save sign
 113++D73D 7A                                   ld      a,d
 114++D73E E6 7F                                and     SignMask8Bit    ; a = nosev hi axis  unsigned
 115++D740 57                                   ld      d,a             ; de = abs (nosev)
 116++D741                                      ShiftDERight1
 116++D741 CB 3A       >			   srl d
 116++D743 CB 1B       >			   rr  e
 117++D745                                      ShiftDERight1
 117++D745 CB 3A       >			   srl d
 117++D747 CB 1B       >			   rr  e
 118++D749                                      ShiftDERight1
 118++D749 CB 3A       >			   srl d
 118++D74B CB 1B       >			   rr  e
 119++D74D                                      ShiftDERight1           ; de = nosev /16 unsigned
 119++D74D CB 3A       >			   srl d
 119++D74F CB 1B       >			   rr  e
 120++D751 3A 8F C0                             ld      a,(univRAT2)     ; need to consider direction, so by defautl we use rat2, but flip via sign bit
 121++D754 FD AC                                xor     iyh             ; get the sign back we saveded from DE in so de = nosev axis / 16 signed
 122++D756 E6 80                                and     SignOnly8Bit
 123++D758 B2                                   or      d
 124++D759 57                                   ld      d,a             ; de = nosev /16 signed and ready as if we were doing a + or - based on RAT2
 125++D75A              ;;; ld      a,e
 126++D75A              ;;;     or      iyh
 127++D75A              ;;; ld      (varP),a        ; PA now equals nosev axis / 16 signed
 128++D75A              ;-now AP = nosev /16  --------------------------------------------------------------------------------------------------------
 129++D75A E1                                   pop     hl              ; get back RS POP ID 1
 130++D75B                  ;ex     de,hl           ; swapping around so hl = AP and de = SR , shoud not matter though as its an add
 131++D75B              ;-now DE = (roofaxis/512) hl - abs(nosevaxis) --------------------------------------------------------------------------------
 132++D75B CD 56 00                             call    ADDHLDESignedV4 ; do add using hl and de
 133++D75E E5                                   push    hl              ; we use stack to represent var K here now varK = Nosev axis /16 + (1 - 1/512) * roofv axis PUSH ID 2
 134++D75F              ;-push to stack nosev axis + roofvaxis /512  which is what roofv axis will be ------------------------------------------------
 135++D75F              ;-- Set up SR = 1 - 1/512 * nosev-----------------------
 136++D75F 2A FD 6A                             ld      hl,(varAxis2)   ; work on nosev again to get nosev - novesv / 512
 137++D762 5E                                   ld      e,(hl)
 138++D763 23                                   inc     hl
 139++D764 56                                   ld      d,(hl)
 140++D765 EB                                   ex      de,hl
 141++D766 7C                                   ld      a,h
 142++D767 E6 80                                and     $80
 143++D769 FD 67                                ld      iyh,a
 144++D76B 7C                                   ld      a,h
 145++D76C E6 7F                                and     SignMask8Bit    ; a = roof hi axis  unsigned
 146++D76E CB 3F                                srl     a               ; now A = unsigned 15 bit nosev axis hi / 2 (or in effect nosev / 512
 147++D770 5F                                   ld      e,a
 148++D771 FD 7C                                ld      a,iyh
 149++D773 57                                   ld      d,a
 150++D774 B7                                   or      a               ; clear carry
 151++D775 CD 75 01                             call    subHLDES15
 152++D778              ;   sbc     hl,de           ; hl = nosev - novesv / 512
 153++D778 E5                                   push    hl              ; save hl on stack  PUSH ID 3
 154++D779 7D                                   ld      a,l
 155++D77A 32 16 6B                             ld      (varP),a        ; p = low of resuilt
 156++D77D 7C                                   ld      a,h
 157++D77E E6 7F                                and     SignMask8Bit    ; a = roof hi axis  unsigned
 158++D780 32 32 6C                             ld      (varT),a        ; t = high of result
 159++D783              ;-- Set up TQ
 160++D783 2A FB 6A                             ld      hl,(varAxis1)   ; now work on roofv axis / 16
 161++D786              ;   ld      hl,(varAxis2)   ; work on nosev again
 162++D786 5E                                   ld      e,(hl)
 163++D787 23                                   inc     hl
 164++D788 56                                   ld      d,(hl)
 165++D789 7A                                   ld      a,d
 166++D78A E6 80                                and     $80
 167++D78C FD 67                                ld      iyh,a           ; save sign
 168++D78E 7A                                   ld      a,d
 169++D78F E6 7F                                and     SignMask8Bit    ; a = nosev hi axis  unsigned
 170++D791 57                                   ld      d,a             ; de = abs (nosev)
 171++D792                                      ShiftDERight1
 171++D792 CB 3A       >			   srl d
 171++D794 CB 1B       >			   rr  e
 172++D796                                      ShiftDERight1
 172++D796 CB 3A       >			   srl d
 172++D798 CB 1B       >			   rr  e
 173++D79A                                      ShiftDERight1
 173++D79A CB 3A       >			   srl d
 173++D79C CB 1B       >			   rr  e
 174++D79E                                      ShiftDERight1           ; de = nosev /16 unsigned
 174++D79E CB 3A       >			   srl d
 174++D7A0 CB 1B       >			   rr  e
 175++D7A2 3A 8F C0                             ld      a,(univRAT2)
 176++D7A5 FD AC                                xor     iyh             ; get the sign back in so de = nosev axis / 16 signed
 177++D7A7 E6 80                                and     $80
 178++D7A9 B2                                   or      d
 179++D7AA 57                                   ld      d,a
 180++D7AB              ;;; ld      a,e
 181++D7AB              ;;;     or      iyh
 182++D7AB              ;;; ld      (varP),a        ; PA now equals nosev axis / 16 signed
 183++D7AB E1                                   pop     hl              ; get back RS   POP ID 3
 184++D7AC              ;   ex      de,hl           ; swapping around so hl = AP and de = SR , shoud not matter though as its an add
 185++D7AC CD 75 01                             call    subHLDES15 ; do add using hl and de
 186++D7AF              ;-- Update nosev ---------------------------------------
 187++D7AF EB                                   ex      de,hl           ; save hl to de
 188++D7B0 2A FD 6A                             ld      hl,(varAxis2)
 189++D7B3 73                                   ld      (hl),e
 190++D7B4 23                                   inc     hl
 191++D7B5 72                                   ld      (hl),d          ; copy result into nosev
 192++D7B6              ;-- Update roofv ---------------------------------------
 193++D7B6 D1                                   pop     de              ; get calc saved on stack POP ID 2
 194++D7B7 2A FB 6A                             ld      hl,(varAxis1)
 195++D7BA 73                                   ld      (hl),e
 196++D7BB 23                                   inc     hl
 197++D7BC 72                                   ld      (hl),d          ; copy result into nosev
 198++D7BD C9                                   ret
 199++D7BE
 200++D7BE
# file closed: ../../Tests/Vectors/../../Universe/Ships/ApplyShipRollAndPitch.asm
 894+ D7BE                          INCLUDE "../../Universe/Ships/ApplyShipSpeed.asm"
# file opened: ../../Tests/Vectors/../../Universe/Ships/ApplyShipSpeed.asm
   1++D7BE
   2++D7BE
   3++D7BE              ;AddSpeedToVert:         MACRO   vertex
   4++D7BE              ;                        ld      hl,(vertex)
   5++D7BE              ;                        ld      a,(vertex+2)
   6++D7BE              ;                        ld      b,a
   7++D7BE              ;                        call    AHLEquBHLaddCDE
   8++D7BE              ;                        ld      (vertex),hl
   9++D7BE              ;                        ld      (vertex+2),a
  10++D7BE              ;                        ENDM
  11++D7BE
  12++D7BE
  13++D7BE              ; ---------------------------------------------------------------------------------------------------------------------------------
  14++D7BE 3A 86 C0     ApplyShipSpeed:         ld      a,(UBnKSpeed)                   ; get speed * 4
  15++D7C1 FE 00                                cp      0
  16++D7C3 C8                                   ret     z
  17++D7C4 CB 27                                sla     a
  18++D7C6 CB 27                                sla     a
  19++D7C8 FD 6F                                ld      iyl,a                           ; save pre calculated speed
  20++D7CA              .ApplyToX:              SpeedMulAxis    a, UBnkrotmatNosevX     ; e =  ABS (nosev x hi) c = sign
  20++D7CA 5F          >                        ld      e,a
  20++D7CB 2A 36 C0    >                        ld      hl,(UBnkrotmatNosevX)
  20++D7CE 7C          >                        ld      a,h
  20++D7CF             >                        ClearSignBitA
  20++D7CF E6 7F       >                        and     SignMask8Bit
  20++D7D1 57          >                        ld      d,a
  20++D7D2 ED 30       >                        mul     de
  20++D7D4 7C          >                        ld      a,h
  20++D7D5             >                        SignBitOnlyA
  20++D7D5 E6 80       >                        and     SignOnly8Bit
  20++D7D7 47          >                        ld      b,a;ld      c,a
  20++D7D8 62          >                        ld      h,d;ld      e,d
  20++D7D9 0E 00       >                        ld      c,0;ld      d,0
  21++D7DB              .AddSpeedToX:           AddSpeedToVert UBnKxlo
  21++D7DB ED 5B 21 C0 >                        ld      de,(UBnKxlo+1)
  21++D7DF 3A 20 C0    >                        ld      a,(UBnKxlo)
  21++D7E2 6F          >                        ld      l,a
  21++D7E3 CD 14 01    >                        call    AddBCHtoDELsigned               ; DEL = DEL + BCH
  21++D7E6 7D          >                        ld      a,l
  21++D7E7 32 20 C0    >                        ld      (UBnKxlo),a
  21++D7EA ED 53 21 C0 >                        ld      (UBnKxlo+1),de
  22++D7EE              .ApplyToY:              SpeedMulAxis    iyl, UBnkrotmatNosevY
  22++D7EE FD 5D       >                        ld      e,iyl
  22++D7F0 2A 38 C0    >                        ld      hl,(UBnkrotmatNosevY)
  22++D7F3 7C          >                        ld      a,h
  22++D7F4             >                        ClearSignBitA
  22++D7F4 E6 7F       >                        and     SignMask8Bit
  22++D7F6 57          >                        ld      d,a
  22++D7F7 ED 30       >                        mul     de
  22++D7F9 7C          >                        ld      a,h
  22++D7FA             >                        SignBitOnlyA
  22++D7FA E6 80       >                        and     SignOnly8Bit
  22++D7FC 47          >                        ld      b,a;ld      c,a
  22++D7FD 62          >                        ld      h,d;ld      e,d
  22++D7FE 0E 00       >                        ld      c,0;ld      d,0
  23++D800              .AddSpeedToY:           AddSpeedToVert UBnKylo
  23++D800 ED 5B 24 C0 >                        ld      de,(UBnKylo+1)
  23++D804 3A 23 C0    >                        ld      a,(UBnKylo)
  23++D807 6F          >                        ld      l,a
  23++D808 CD 14 01    >                        call    AddBCHtoDELsigned               ; DEL = DEL + BCH
  23++D80B 7D          >                        ld      a,l
  23++D80C 32 23 C0    >                        ld      (UBnKylo),a
  23++D80F ED 53 24 C0 >                        ld      (UBnKylo+1),de
  24++D813              .ApplyToZ:              SpeedMulAxis    iyl, UBnkrotmatNosevZ
  24++D813 FD 5D       >                        ld      e,iyl
  24++D815 2A 3A C0    >                        ld      hl,(UBnkrotmatNosevZ)
  24++D818 7C          >                        ld      a,h
  24++D819             >                        ClearSignBitA
  24++D819 E6 7F       >                        and     SignMask8Bit
  24++D81B 57          >                        ld      d,a
  24++D81C ED 30       >                        mul     de
  24++D81E 7C          >                        ld      a,h
  24++D81F             >                        SignBitOnlyA
  24++D81F E6 80       >                        and     SignOnly8Bit
  24++D821 47          >                        ld      b,a;ld      c,a
  24++D822 62          >                        ld      h,d;ld      e,d
  24++D823 0E 00       >                        ld      c,0;ld      d,0
  25++D825              .AddSpeedToZ:           AddSpeedToVert UBnKzlo
  25++D825 ED 5B 27 C0 >                        ld      de,(UBnKzlo+1)
  25++D829 3A 26 C0    >                        ld      a,(UBnKzlo)
  25++D82C 6F          >                        ld      l,a
  25++D82D CD 14 01    >                        call    AddBCHtoDELsigned               ; DEL = DEL + BCH
  25++D830 7D          >                        ld      a,l
  25++D831 32 26 C0    >                        ld      (UBnKzlo),a
  25++D834 ED 53 27 C0 >                        ld      (UBnKzlo+1),de
  26++D838 C9                                   ret
  27++D839
# file closed: ../../Tests/Vectors/../../Universe/Ships/ApplyShipSpeed.asm
 895+ D839              ; ---------------------------------------------------------------------------------------------------------------------------------
 896+ D839              ; .....................................................
 897+ D839              ; Process Nodes does the following:
 898+ D839              ; for each node:
 899+ D839              ;     see if node >
 900+ D839 00           PNXX20DIV6          DB      0
 901+ D83A 00 00        PNVERTEXPTR         DW      0   ; DEBUG WILL USE LATER
 902+ D83C 00 00        PNNODEPRT           DW      0   ; DEBUG WILL USE LATER
 903+ D83E 00           PNLASTNORM          DB      0
 904+ D83F              ProcessNodes:           ZeroA
 904+ D83F AF          >                        xor a
 905+ D840 32 2B C4                             ld      (UbnkLineArrayLen),a
 906+ D843 CD CD CA                             call    CopyRotmatToTransMat ; CopyRotToTransMacro                      ;#01; Load to Rotation Matrix to XX16, 16th bit is sign bit
 907+ D846 CD 59 6A                             call    ScaleXX16Matrix197               ;#02; Normalise XX16
 908+ D849 CD 86 CD                             call    LoadCraftToCamera                ;#04; Load Ship Coords to XX18
 909+ D84C CD 53 CC                             call    InverseXX16                      ;#11; Invert rotation matrix
 910+ D84F 21 52 C4                             ld      hl,UBnkHullVerticies
 911+ D852 3A 40 C4                             ld      a,(VertexCtX6Addr)               ; get Hull byte#9 = number of vertices *6                                   ;;;
 912+ D855 4F           GetActualVertexCount:   ld      c,a                              ; XX20 also c = number of vertices * 6 (or XX20)
 913+ D856 4F                                   ld      c,a                              ; XX20 also c = number of vertices * 6 (or XX20)
 914+ D857 16 06                                ld      d,6
 915+ D859 CD D7 76                             call    asm_div8                         ; asm_div8 C_Div_D - C is the numerator, D is the denominator, A is the remainder, B is 0, C is the result of C/D,D,E,H,L are not changed"
 916+ D85C 41                                   ld      b,c                              ; c = number of vertices
 917+ D85D FD 21 31 C1                          ld      iy,UBnkNodeArray
 918+ D861              LL48:
 919+ D861 C5           PointLoop:              push    bc                                  ; save counters
 920+ D862 E5                                   push    hl                                  ; save verticies list pointer
 921+ D863 FD E5                                push    iy                                  ; save Screen plot array pointer
 922+ D865 78                                   ld      a,b
 923+ D866                                      ;break
 924+ D866 CD EF D2                             call    CopyNodeToXX15                      ; copy verices at hl to xx15
 925+ D869 3A E8 C0                             ld      a,(UBnkXScaledSign)
 926+ D86C CD BB 69                             call    XX12EquNodeDotOrientation
 927+ D86F CD F7 CA                             call    TransposeXX12ByShipToXX15
 928+ D872 CD 74 CB                             call    ScaleNodeTo8Bit                     ; scale to 8 bit values, why don't we hold the magnitude here?x
 929+ D875 FD E1                                pop     iy                                  ; get back screen plot array pointer
 930+ D877 CD 6E D3                             call    ProjectNodeToEye                     ; set up screen plot list entry
 931+ D87A                 ; ld      hl,UbnkLineArrayLen
 932+ D87A                ;  inc     (hl)                                ; another node done
 933+ D87A FD E5        ReadyForNextPoint:      push    iy                                  ; copy screen plot pointer to hl
 934+ D87C E1                                   pop     hl
 935+ D87D 3E 04                                ld      a,4
 936+ D87F ED 31                                add     hl,a
 937+ D881 E5                                   push    hl                                  ; write it back at iy + 4
 938+ D882 FD E1                                pop     iy                                  ; and put it in iy again
 939+ D884 E1                                   pop     hl                                  ; get hl back as vertex list
 940+ D885 3E 06                                ld      a,6
 941+ D887 ED 31                                add     hl,a                                ; and move to next vertex
 942+ D889 C1                                   pop     bc                                  ; get counter back
 943+ D88A 10 D5                                djnz    PointLoop
 944+ D88C              ; ......................................................
 945+ D88C                                      ClearCarryFlag
 945+ D88C B7          >                        or a
 946+ D88D C9                                   ret
 947+ D88E              ; ...........................................................
 948+ D88E CD 81 CF     ProcessShip:            call    CheckVisible                ; checks for z -ve and outside view frustrum, sets up flags for next bit
 949+ D891              ;............................................................
 950+ D891              .DetermineDrawType:     ReturnOnBitClear    a, ShipIsVisibleBitNbr          ; if its not visible exit early
 950+ D891 CB 77       >                        bit 	ShipIsVisibleBitNbr,a
 950+ D893 C8          >                        ret		z
 951+ D894              ;............................................................
 952+ D894 C9                                   ret
 953+ D895
 954+ D895                  ;INCLUDE "../../Universe/Ships/PrepLines.asm"
 955+ D895              ;--------------------------------------------------------------------------------------------------------
 956+ D895                      DISPLAY "Tracing 8", $
 957+ D895
 958+ D895                  INCLUDE "../../ModelRender/getVertexNodeAtAToX1Y1.asm"
# file opened: ../../Tests/Vectors/../../ModelRender/getVertexNodeAtAToX1Y1.asm
   1++D895              ;--------------------------------------------------------------------------------------------------------
   2++D895              ; a = byteoffset to node array as its pre computed to x4 bytes
   3++D895 21 31 C1     getVertexNodeAtAToDE:   ld          hl,UBnkNodeArray                    ; hl = edgelist  current pointer
   4++D898 ED 31                                add         hl,a                                ; hl = address of Node
   5++D89A 7E                                   ld          a,(hl)                              ; get edge list nbr 1 edge
   6++D89B ED A0                                ldi                                             ; x1 lo
   7++D89D ED A0                                ldi                                             ; x1 hi
   8++D89F ED A0                                ldi                                             ; y1 lo
   9++D8A1 ED A0                                ldi                                             ; y1 hi
  10++D8A3 C9                                   ret
  11++D8A4
  12++D8A4              ;getVertexNodeAtAToX1Y1: ld          hl,UBnkNodeArray                    ; hl = edgelist  current pointer
  13++D8A4              ;                        add         hl,a                                ; hl = address of Node
  14++D8A4              ;                        ld          a,(hl)                              ; get edge list nbr 1 edge
  15++D8A4              ;                        ld          de,UBnkX1
  16++D8A4              ;                        ldi                                             ; x1 lo
  17++D8A4              ;                        ldi                                             ; x1 hi
  18++D8A4              ;                        ldi                                             ; y1 lo
  19++D8A4              ;                        ldi                                             ; y1 hi
  20++D8A4              ;                        ret
  21++D8A4
# file closed: ../../Tests/Vectors/../../ModelRender/getVertexNodeAtAToX1Y1.asm
 959+ D8A4
 960+ D8A4                      DISPLAY "Tracing 9", $
 961+ D8A4
 962+ D8A4                  INCLUDE "../../ModelRender/getVertexNodeAtAToX2Y2.asm"
# file opened: ../../Tests/Vectors/../../ModelRender/getVertexNodeAtAToX2Y2.asm
   1++D8A4              ;--------------------------------------------------------------------------------------------------------
   2++D8A4              ; a = byteoffset to node array as its pre computed to x4 bytes
   3++D8A4              ;getVertexNodeAtAToX2Y2: ld          hl,UBnkNodeArray                    ; hl = edgelist  current pointer
   4++D8A4              ;                        add         hl,a                                ; hl = address of Node
   5++D8A4              ;                        ld          a,(hl)                              ; get edge list nbr 1 edge
   6++D8A4              ;                        ld          de,UBnkX2
   7++D8A4              ;                        ldi                                             ; x1 lo
   8++D8A4              ;                        ldi                                             ; x1 hi
   9++D8A4              ;                        ldi                                             ; y1 lo
  10++D8A4              ;                        ldi                                             ; y1 hi
  11++D8A4              ;                        ret
# file closed: ../../Tests/Vectors/../../ModelRender/getVertexNodeAtAToX2Y2.asm
 963+ D8A4                      DISPLAY "Tracing 10", $
 964+ D8A4
 965+ D8A4                  INCLUDE "../../ModelRender/GetFaceAtA.asm"
# file opened: ../../Tests/Vectors/../../ModelRender/GetFaceAtA.asm
   1++D8A4              ;--------------------------------------------------------------------------------------------------------
   2++D8A4              GetFaceAtA:         MACRO
   3++D8A4 ~                                ld          hl,UbnkFaceVisArray
   4++D8A4 ~                                add         hl,a
   5++D8A4 ~                                ld          a,(hl)                              ; get face visibility
   6++D8A4                                  ENDM
   7++D8A4
# file closed: ../../Tests/Vectors/../../ModelRender/GetFaceAtA.asm
 966+ D8A4                      DISPLAY "Tracing 11", $
 967+ D8A4
 968+ D8A4              ;--------------------------------------------------------------------------------------------------------
 969+ D8A4              ; LL72 Goes through each edge in to determine if they are on a visible face, if so load start and end to line array as clipped lines
 970+ D8A4               ;   DEFINE NOBACKFACECULL 1
 971+ D8A4 00           PLEDGECTR           DB          0
 972+ D8A5
 973+ D8A5              PrepLines:
 974+ D8A5              InitialiseLineRead:
 975+ D8A5                      ;break
 976+ D8A5                      ldWriteZero UbnkLineArrayLen                    ; current line array index = 0
 976+ D8A5 AF          >                        xor      a
 976+ D8A6 32 2B C4    >                        ld       (UbnkLineArrayLen),a
 977+ D8A9 32 2C C4             ld          (UbnkLineArrayBytes),a              ; UbnkLineArrayBytes= nbr of bytes of lines laoded = array len * 4
 978+ D8AC 32 A4 D8             ld          (PLEDGECTR),a
 979+ D8AF 3A 41 C4             ld          a,(EdgeCountAddr)
 980+ D8B2 DD 67                ld          ixh,a                               ; ixh = XX17 = Total number of edges to traverse
 981+ D8B4 FD 2E 00             ld          iyl,0                               ; ixl = current edge index
 982+ D8B7 21 71 C2             ld          hl,UbnkLineArray                    ; head of array
 983+ D8BA 22 19 6C             ld          (varU16),hl                         ; store current line array pointer un varU16
 984+ D8BD                      ldCopyByte  EdgeCountAddr, XX17                 ; XX17  = total number of edges to traverse edge counter
 984+ D8BD 3A 41 C4    >                        ld       a,(EdgeCountAddr)
 984+ D8C0 32 1D 6C    >                        ld       (XX17),a
 985+ D8C3 3A 91 C0             ld          a,(UBnKexplDsp)                     ; get explosion status
 986+ D8C6                      JumpOnBitClear a,6,CalculateNewLines            ; LL170 bit6 of display state clear (laser not firing) \ Calculate new lines
 986+ D8C6 CB 77       >                        bit 	6,a
 986+ D8C8 CA D0 D8    >                        jp      z,CalculateNewLines
 987+ D8CB E6 BF                and         $BF                                 ; else laser is firing, clear bit6.
 988+ D8CD 32 91 C0             ld          (UBnKexplDsp),a                     ; INWK+31
 989+ D8D0              ;   TODO commentedout as teh subroutine is a mess   call        AddLaserBeamLine                    ; add laser beam line to draw list
 990+ D8D0              ; NOw we can calculate hull after including laser line
 991+ D8D0              CalculateNewLines:
 992+ D8D0              LL170:                                                  ;(laser not firing) \ Calculate new lines   \ their comment
 993+ D8D0              CheckEdgesForVisibility:
 994+ D8D0 21 42 C5             ld          hl,UBnkHullEdges
 995+ D8D3                      ; TODO change heap to 3 separate arrays and break them down during copy of ship hull data
 996+ D8D3 22 1C 6B             ld          (varV),hl                           ; V \ is pointer to where edges data start
 997+ D8D6 3A 3C C4             ld          a,(LineX4Addr)
 998+ D8D9 47                   ld          b,a                                 ; nbr of bytes of edge data
 999+ D8DA              LL75Loop:                                               ; count Visible edges
1000+ D8DA              IsEdgeInVisibilityRange:
1001+ D8DA 2A 1C 6B             ld          hl,(varV)
1002+ D8DD E5                   push        hl
1003+ D8DE FD E1                pop         iy
1004+ D8E0 3A 07 6B             ld          a,(LastNormalVisible)               ; XX4 is visibility range
1005+ D8E3 57                   ld          d,a                                 ; d holds copy of XX4
1006+ D8E4              ; Get Edge Byte 0
1007+ D8E4 FD 7E 00             ld          a,(IY+0)                            ; edge data byte#0 is visibility distance
1008+ D8E7                      JumpIfALTNusng d,LL78EdgeNotVisible             ; XX4   \ visibility LLx78 edge not visible
1008+ D8E7 BA          >                        cp      d
1008+ D8E8 DA 43 D9    >                        jp		c, LL78EdgeNotVisible
1009+ D8EB              EdgeMayBeVisibile:
1010+ D8EB              ; Get Edge Byte 1
1011+ D8EB              IsFace1Visibile:                                        ; edges have 2 faces to test
1012+ D8EB FD 7E 01             ld          a,(IY+1)                            ; (V),Y \ edge data byte#1 bits 0 to 3 face 1 4 to 7 face 2
1013+ D8EE 4F                   ld          c,a                                 ;  c = a copy of byte 1
1014+ D8EF E6 0F                and         $0F                                 ;
1015+ D8F1                      GetFaceAtA
1015+ D8F1 21 13 C1    >                    ld          hl,UbnkFaceVisArray
1015+ D8F4 ED 31       >                    add         hl,a
1015+ D8F6 7E          >                    ld          a,(hl)                              ; get face visibility
1016+ D8F7              ;       jp  VisibileEdge; DEBUG BODGE TEST TODO
1017+ D8F7                      JumpIfAIsNotZero VisibileEdge                     ; LL70 visible edge
1017+ D8F7 A7          >                        and     a
1017+ D8F8 C2 0C D9    >                        jp	    nz,VisibileEdge
1018+ D8FB              IsFace2Visibile:
1019+ D8FB 79                   ld          a,c                                 ; restore byte 1 from c register
1020+ D8FC ED 23                swapnib                                         ;
1021+ D8FE E6 0F                and         $0F                                 ; swap high byte into low byte
1022+ D900 E5                   push        hl
1023+ D901                      GetFaceAtA
1023+ D901 21 13 C1    >                    ld          hl,UbnkFaceVisArray
1023+ D904 ED 31       >                    add         hl,a
1023+ D906 7E          >                    ld          a,(hl)                              ; get face visibility
1024+ D907 E1                   pop         hl
1025+ D908                      JumpIfAIsZero LL78EdgeNotVisible                ; edge not visible
1025+ D908 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
1025+ D909 CA 43 D9    >                        jp	    z, LL78EdgeNotVisible
1026+ D90C              VisibileEdge:                                           ; Now we need to node id from bytes 2 - start and 3 - end
1027+ D90C              ;LL79--Visible edge--------------------------------------
1028+ D90C              ; Get Edge Byte 2
1029+ D90C FD 7E 02             ld          a,(IY+2)                            ; get Node id
1030+ D90F 11 E7 C0             ld          de,UBnkX1
1031+ D912 CD 95 D8             call        getVertexNodeAtAToDE; getVertexNodeAtAToX1Y1              ; get the points X1Y1 from node
1032+ D915 FD 7E 03             ld          a,(IY+3)
1033+ D918 11 EB C0             ld          de,UBnkX2
1034+ D91B CD 95 D8             call        getVertexNodeAtAToDE; getVertexNodeAtAToX2Y2              ; get the points X2Y2 from node
1035+ D91E              LL80:                                                   ; ll80 \ Shove visible edge onto XX19 ship lines heap counter U
1036+ D91E ED 5B 19 6C          ld          de,(varU16)                         ; clipped edges heap address
1037+ D922 21 E7 C0             ld          hl,UbnkPreClipX1
1038+ D925                      FourLDIInstrunctions
1038+ D925 ED A0       >                        ldi
1038+ D927 ED A0       >                        ldi
1038+ D929 ED A0       >                        ldi
1038+ D92B ED A0       >                        ldi
1039+ D92D                      FourLDIInstrunctions
1039+ D92D ED A0       >                        ldi
1039+ D92F ED A0       >                        ldi
1039+ D931 ED A0       >                        ldi
1039+ D933 ED A0       >                        ldi
1040+ D935 ED 53 19 6C          ld          (varU16),de                         ; update U16 with current address
1041+ D939 21 2B C4             ld          hl,UbnkLineArrayLen                 ; we have loaded one line
1042+ D93C 34                   inc         (hl)
1043+ D93D 7E                   ld          a,(hl)
1044+ D93E                      JumpIfAGTENusng LineArraySize,CompletedLineGeneration   ; have we hit max lines for a model hop over jmp to Exit edge data loop
1044+ D93E FE 32       >                        cp     LineArraySize
1044+ D940 D2 59 D9    >                        jp		nc,CompletedLineGeneration
1045+ D943              ; If we hit here we skip the write of line arryay u16
1046+ D943              LL78EdgeNotVisible:                                     ; also arrive here if Edge not visible, loop next data edge.
1047+ D943              LL78:
1048+ D943 2A 1C 6B             ld          hl,(varV)                           ; varV is current edge address
1049+ D946 3E 04                ld          a,4
1050+ D948 ED 31                add         hl,a
1051+ D94A 22 1C 6B             ld          (varV),hl
1052+ D94D 21 A4 D8             ld          hl,PLEDGECTR                        ;
1053+ D950 34                   inc         (hl)                                ;
1054+ D951 7E                   ld          a,(hl)                              ; current edge index ++
1055+ D952                      JumpIfANEMemusng XX17,LL75Loop                  ; compare with total number of edges
1055+ D952 21 1D 6C    >                        ld    hl,XX17
1055+ D955 BE          >                        cp    (hl)
1055+ D956 C2 DA D8    >                        jp      nz,LL75Loop
1056+ D959              CompletedLineGeneration:
1057+ D959              LL81:
1058+ D959              LL81SHPPT:                                              ; SHPPT ship is a point arrives here with Acc=2, bottom entry in heap
1059+ D959 3A 2B C4             ld          a,(UbnkLineArrayLen)                ; UbnkLineArrayLen = nbr of lines loaded
1060+ D95C CB 27                sla         a
1061+ D95E CB 27                sla         a                                   ; multiple by 4 to equal number of bytes
1062+ D960 CB 27                sla         a                           ; multiple by 8 to equal number of bytes
1063+ D962 32 2C C4             ld          (UbnkLineArrayBytes),a              ; UbnkLineArrayBytes= nbr of bytes of lines laoded = array len * 4
1064+ D965              ExitEdgeDataLoop:
1065+ D965 C9                   ret
1066+ D966
1067+ D966
1068+ D966                  DISPLAY "Tracing XX", $
1069+ D966
1070+ D966              UnivBankSize  EQU $ - StartOfUniv
1071+ D966
# file closed: ../../Tests/Vectors/univ_ship_data.asm
1386  D966                                  DISPLAY "Sizing Bank ",BankUNIVDATA0," - Start ",UniverseBankAddr," End - ",$, "- Universe Data A"
1387  D966                                  DISPLAY "Bank ",BankUNIVDATA0," - Bytes free ",/D, $2000 - ($-UniverseBankAddr), "- Universe Data A"
1388  D966                                  ASSERT $-UniverseBankAddr <8912, Bank code leaks over 8K boundary
1389  D966              ; Bank 99  ------------------------------------------------------------------------------------------------------------------------
1390  D966                                  SLOT    MathsTablesAddr
1391  D966                                  PAGE    BankMathsTables
1392  D966                                  ORG     MathsTablesAddr,BankMathsTables
1393  0000                                  INCLUDE "../../Maths/logmaths.asm"
# file opened: ../../Maths/logmaths.asm
   1+ 0000 4C 6F 67 4D  logmaths_page_marker    DB "LogMaths   PG99"
   1+ 0004 61 74 68 73
   1+ 0008 20 20 20 50
   1+ 000C 47 39 39
   2+ 000F
   3+ 000F EB           AntiLogHL:              ex      de,hl
   4+ 0010 21 83 05                             ld      hl,LogReverseHighByte
   5+ 0013 01 14 02                             ld      bc,LogReverseTableLen
   6+ 0016 7A                                   ld      a,d
   7+ 0017 ED A1        .SearchLoop:            cpi                                     ; first pass index into high byte
   8+ 0019 28 03                                jr      z,.FoundHighByte
   9+ 001B 23                                   inc     hl
  10+ 001C 18 F9                                jr      .SearchLoop
  11+ 001E 23           .FoundHighByte:         inc     hl                              ; now we have high double it for table of words
  12+ 001F 7E                                   ld      a,(hl)                          ; .
  13+ 0020 21 83 03                             ld      hl,LogTable                     ; .
  14+ 0023 ED 31                                add     hl,a                            ; .
  15+ 0025 ED 31                                add     hl,a                            ; .
  16+ 0027 7A           .LookForLowByteLoop:    ld      a,d                             ; search for low byte or change in high byte
  17+ 0028 BE                                   cp      (hl)
  18+ 0029 20 09                                jr      nz,.SkippedPastHigh
  19+ 002B 23                                   inc     hl
  20+ 002C 7B                                   ld      a,e
  21+ 002D                                      JumpIfAGTENusng (hl), .SkippedPastLow
  21+ 002D BE          >                        cp     (hl)
  21+ 002E D2 35 00    >                        jp		nc,.SkippedPastLow
  22+ 0031 C3 27 00                             jp      .LookForLowByteLoop
  23+ 0034
  24+ 0034 2B           .SkippedPastHigh:       dec     hl                              ; for high we are on next word
  25+ 0035 2B           .SkippedPastLow:        dec     hl                              ; for low we are no next byte
  26+ 0036 EB                                   ex      de,hl                           ; move address to de for subtract
  27+ 0037 21 83 03                             ld      hl,LogTable                     ; subtract from log table address
  28+ 003A                                      ClearCarryFlag
  28+ 003A B7          >                        or a
  29+ 003B ED 52                                sbc     hl,de                           ; so nwo we have nbr of words, i.e anito log * 2
  30+ 003D                                      ShiftHLRight1                           ; now must be >= 255
  30+ 003D CB 3C       >			   srl h
  30+ 003F CB 1D       >			   rr  l
  31+ 0041 7D                                   ld      a,l
  32+ 0042 C9                                   ret
  33+ 0043
  34+ 0043              ; calculates R = 256 * A / Q
  35+ 0043              Requ256mulAdivQ_Log:    JumpIfAGTEMemusng varQ, LL2             ; If A >= Q, then the answer will not fit in one byte, return 255
  35+ 0043 21 16 6C    >                        ld      hl,varQ
  35+ 0046 BE          >                        cp      (hl)
  35+ 0047 D2 BB 00    >                        jp		nc,LL2
  36+ 004A FD 6F                                ld      iyl,a                           ; STA widget             \ Store A in widget, so now widget = argument A
  37+ 004C DD 67                                ld      ixh,a                           ; TAX                    \ Transfer A into X, so now X = argument A
  38+ 004E                                      JumpIfAIsZero LLfix                     ; If A = 0, jump to LLfix to return a result of 0
  38+ 004E A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  38+ 004F CA B7 00    >                        jp	    z, LLfix
  39+ 0052              ; calculate log(A) - log(Q), first adding the low bytes (from the logL table), and then the high bytes (from the log table)
  40+ 0052              ; this determins if we branch to antilog or antilogodd for negative value
  41+ 0052 21 83 03     .GetLogA:               ld      hl,LogTable                     ; LDA logL,X             \ e = low byte of log(X)
  42+ 0055 ED 31                                add     hl,a                            ; have to add twice as ist 8 bit so cant shift
  43+ 0057 ED 31                                add     hl,a                            ;
  44+ 0059 5E                                   ld      e,(hl)                          ;
  45+ 005A 23                                   inc     hl                              ;
  46+ 005B 56                                   ld      d,(hl)                          ; de = logH[X] logL[X]
  47+ 005C 21 83 03                             ld      hl,LogTable                     ;
  48+ 005F 3A 16 6C                             ld      a,(varQ)                        ;
  49+ 0062 ED 31                                add     hl,a                            ;
  50+ 0064 ED 31                                add     hl,a                            ;
  51+ 0066 4E                                   ld      c,(hl)                          ;
  52+ 0067 23                                   inc     hl                              ;
  53+ 0068 46                                   ld      b,(hl)                          ; bc = logH[X] logL[X]
  54+ 0069 7B                                   ld      a,e                             ; SBC logL,X             \       = low byte of log(A) - low byte of log(Q)
  55+ 006A                                      ClearCarryFlag                          ; .
  55+ 006A B7          >                        or a
  56+ 006B 99                                   sbc     a,c                             ; .
  57+ 006C D2 93 00                             jp      nc,NoCarryBranch
  58+ 006F FA 83 00     CarryBranch:            jp      m,.noddlog                     ; BMI noddlog            \ If the subtraction is negative, jump to noddlog
  59+ 0072 5F                                   ld      e,a                             ; save logL[A] - logL[Q] in e, probabyl dont need this
  60+ 0073 7A                                   ld      a,d                             ; a = logH(a)
  61+ 0074              .CarryFlagPoint1:       SetCarryFlag
  61+ 0074 37          >                        scf
  62+ 0075 98                                   sbc     a,b                             ; a = high byte of logH[A] - logH[Q] note carry is not affected from prev sbc
  63+ 0076 D2 BB 00                             jp      nc,LL2                          ; If the subtraction fitted into one byte and didn't underflow, then log(A) - log(Q) < 256, so we jump to LL2 return a result of 255
  64+ 0079 21 83 01                             ld      hl,AntiLogTable                 ; TAX                    \ Otherwise we return the A-th entry from the antilog
  65+ 007C ED 31                                add     hl,a                            ; LDA antilog,X          \ table
  66+ 007E 7E                                   ld      a,(hl)
  67+ 007F 32 17 6C                             ld      (varR),a                        ; STA R                  \ Set the result in R to the value of A
  68+ 0082 C9                                   ret                                     ; RTS                    \ Return from the subroutine
  69+ 0083 7A           .noddlog:               ld      a,d                             ; LDX widget             \ Set d = high byte of log(A) - high byte of log(Q)
  70+ 0084              .CarryFlagPoint2:       SetCarryFlag
  70+ 0084 37          >                        scf
  71+ 0085 98                                   sbc     a,b
  72+ 0086 D2 BB 00                             jp      nc,LL2                          ; BCS LL2                \ If the subtraction fitted into one byte and didn't underflow, then log(A) - log(Q) < 256, so we jump to LL2 to return a result of 255
  73+ 0089 21 83 02                             ld      hl, AnitLogODDTable             ; TAX                    \ Otherwise we return the A-th entry from the antilogODD
  74+ 008C ED 31                                add     hl,a                            ; LDA antilogODD,X       \ table
  75+ 008E 7E                                   ld      a,(hl)
  76+ 008F 32 17 6C                             ld      (varR),a                        ; STA R                  \ Set the result in R to the value of A
  77+ 0092 C9                                   ret                                     ; RTS                    \ Return from the subroutine
  78+ 0093 FA A7 00     NoCarryBranch:          jp      m,.noddlog                     ; BMI noddlog            \ If the subtraction is negative, jump to noddlog
  79+ 0096 5F                                   ld      e,a                             ; save logL[A] - logL[Q] in e, probabyl dont need this
  80+ 0097 7A                                   ld      a,d                             ; a = logH(a)
  81+ 0098              .CarryFlagPoint1:       ClearCarryFlag
  81+ 0098 B7          >                        or a
  82+ 0099 98                                   sbc     a,b                             ; a = high byte of logH[A] - logH[Q] note carry is not affected from prev sbc
  83+ 009A D2 BB 00                             jp      nc,LL2                          ; If the subtraction fitted into one byte and didn't underflow, then log(A) - log(Q) < 256, so we jump to LL2 return a result of 255
  84+ 009D 21 83 01                             ld      hl,AntiLogTable                 ; TAX                    \ Otherwise we return the A-th entry from the antilog
  85+ 00A0 ED 31                                add     hl,a                            ; LDA antilog,X          \ table
  86+ 00A2 7E                                   ld      a,(hl)
  87+ 00A3 32 17 6C                             ld      (varR),a                        ; STA R                  \ Set the result in R to the value of A
  88+ 00A6 C9                                   ret                                     ; RTS                    \ Return from the subroutine
  89+ 00A7 7A           .noddlog:               ld      a,d                             ; LDX widget             \ Set d = high byte of log(A) - high byte of log(Q)
  90+ 00A8              .CarryFlagPoint2:       ClearCarryFlag
  90+ 00A8 B7          >                        or a
  91+ 00A9 98                                   sbc     a,b
  92+ 00AA D2 BB 00                             jp      nc,LL2                          ; BCS LL2                \ If the subtraction fitted into one byte and didn't underflow, then log(A) - log(Q) < 256, so we jump to LL2 to return a result of 255
  93+ 00AD 21 83 02                             ld      hl, AnitLogODDTable             ; TAX                    \ Otherwise we return the A-th entry from the antilogODD
  94+ 00B0 ED 31                                add     hl,a                            ; LDA antilogODD,X       \ table
  95+ 00B2 7E                                   ld      a,(hl)
  96+ 00B3 32 17 6C                             ld      (varR),a                        ; STA R                  \ Set the result in R to the value of A
  97+ 00B6 C9                                   ret                                     ; RTS                    \ Return from the subroutine
  98+ 00B7 32 17 6C     LLfix:                  ld      (varR),a                        ; Set the result in R to the value of A
  99+ 00BA C9                                   ret                                     ; RTS                    \ Return from the subroutine
 100+ 00BB 3E FF        LL2:                    ld      a,$FF
 101+ 00BD 32 17 6C                             ld      (varR),a
 102+ 00C0 C9                                   ret
 103+ 00C1
 104+ 00C1
 105+ 00C1              AEquAmul256DivBLogLT:   JumpIfAIsZero   .ResultIsZero
 105+ 00C1 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 105+ 00C2 CA EA 00    >                        jp	    z, .ResultIsZero
 106+ 00C5 21 83 03                             ld      hl,LogTable                     ; de = log a
 107+ 00C8 ED 31                                add     hl,a                            ; .
 108+ 00CA ED 31                                add     hl,a                            ; .
 109+ 00CC 5E                                   ld      e,(hl)                          ; .
 110+ 00CD 23                                   inc     hl                              ; .
 111+ 00CE 56                                   ld      d,(hl)                          ; .
 112+ 00CF 21 83 03                             ld      hl,LogTable                     ; hl = log b
 113+ 00D2 78                                   ld      a,b                             ; .
 114+ 00D3 ED 31                                add     hl,a                            ; .
 115+ 00D5 ED 31                                add     hl,a                            ; .
 116+ 00D7 7E                                   ld      a,(hl)                          ; .
 117+ 00D8 23                                   inc     hl                              ; .
 118+ 00D9 66                                   ld      h,(hl)                          ; .
 119+ 00DA 6F                                   ld      l,a                             ; .
 120+ 00DB                                      ClearCarryFlag                          ;
 120+ 00DB B7          >                        or a
 121+ 00DC EB                                   ex      de,hl                           ; now hl = log a and de = log b
 122+ 00DD ED 52                                sbc     hl,de                           ; hl = log a - log b
 123+ 00DF 7C                                   ld      a,h                             ; .
 124+ 00E0 21 83 02                             ld      hl,AnitLogODDTable               ; hl = anti log (log a - log b)
 125+ 00E3 ED 31                                add     hl,a                            ; which is also a / b
 126+ 00E5 ED 31                                add     hl,a                            ; .
 127+ 00E7 7E                                   ld      a,(hl)                          ; .
 128+ 00E8                                      ClearCarryFlag                          ;
 128+ 00E8 B7          >                        or a
 129+ 00E9 C9                                   ret
 130+ 00EA              .ResultIsZero:          ClearCarryFlag
 130+ 00EA B7          >                        or a
 131+ 00EB                                      ZeroA
 131+ 00EB AF          >                        xor a
 132+ 00EC C9                                   ret
 133+ 00ED
 134+ 00ED              AEquAmul256DivBLog:     JumpIfAIsZero   .ResultIsZero
 134+ 00ED A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 134+ 00EE CA 24 01    >                        jp	    z, .ResultIsZero
 135+ 00F1                                      JumpIfAGTENusng d, AEquAmul256DivBLogLT
 135+ 00F1 BA          >                        cp     d
 135+ 00F2 D2 C1 00    >                        jp		nc,AEquAmul256DivBLogLT
 136+ 00F5 21 83 03                             ld      hl,LogTable                     ; de = log a
 137+ 00F8 ED 31                                add     hl,a                            ; .
 138+ 00FA ED 31                                add     hl,a                            ; .
 139+ 00FC 5E                                   ld      e,(hl)                          ; .
 140+ 00FD 23                                   inc     hl                              ; .
 141+ 00FE 56                                   ld      d,(hl)                          ; .
 142+ 00FF 21 83 03                             ld      hl,LogTable                     ; hl = log b
 143+ 0102 78                                   ld      a,b                             ; .
 144+ 0103 ED 31                                add     hl,a                            ; .
 145+ 0105 ED 31                                add     hl,a                            ; .
 146+ 0107 7E                                   ld      a,(hl)                          ; .
 147+ 0108 23                                   inc     hl                              ; .
 148+ 0109 66                                   ld      h,(hl)                          ; .
 149+ 010A 6F                                   ld      l,a                             ; .
 150+ 010B                                      ClearCarryFlag                          ;
 150+ 010B B7          >                        or a
 151+ 010C EB                                   ex      de,hl                           ; now hl = log a and de = log b
 152+ 010D ED 52                                sbc     hl,de                           ; hl = log a - log b
 153+ 010F 38 0B                                jr      c,.ResultIsOne                  ; .
 154+ 0111 7C                                   ld      a,h                             ; .
 155+ 0112 21 83 01                             ld      hl,AntiLogTable                 ; hl = anti log (log a - log b)
 156+ 0115 ED 31                                add     hl,a                            ; which is also a / b
 157+ 0117 ED 31                                add     hl,a                            ; .
 158+ 0119 7E                                   ld      a,(hl)                          ; .
 159+ 011A                                      ClearCarryFlag                          ;
 159+ 011A B7          >                        or a
 160+ 011B C9                                   ret
 161+ 011C              .ResultIsOne:           ClearCarryFlag
 161+ 011C B7          >                        or a
 162+ 011D 3E FF                                ld      a,$FF
 163+ 011F C9                                   ret
 164+ 0120              .ResultIsInfinte:       SetCarryFlag
 164+ 0120 37          >                        scf
 165+ 0121 3E FF                                ld      a,$FF
 166+ 0123 C9                                   ret
 167+ 0124              .ResultIsZero:          ClearCarryFlag
 167+ 0124 B7          >                        or a
 168+ 0125 C9                                   ret
 169+ 0126
 170+ 0126              AEquAmul256Div197LogLT: JumpIfAIsZero   .ResultIsZero
 170+ 0126 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 170+ 0127 CA 46 01    >                        jp	    z, .ResultIsZero
 171+ 012A 21 83 03                             ld      hl,LogTable                     ; point to log a in LogTable
 172+ 012D ED 31                                add     hl,a                            ; Note we can't sla in case a > 127
 173+ 012F ED 31                                add     hl,a
 174+ 0131 5E                                   ld      e,(hl)                          ; de = log a
 175+ 0132 23                                   inc     hl                              ; .
 176+ 0133 56                                   ld      d,(hl)                          ; .
 177+ 0134 21 A9 F3                             ld      hl,$F3A9                        ; hl = $F3A9 = log 197
 178+ 0137                                      ClearCarryFlag
 178+ 0137 B7          >                        or a
 179+ 0138 EB                                   ex      hl,de                           ; hl = log a, de = log 197
 180+ 0139 ED 52                                sbc     hl,de
 181+ 013B 7C                                   ld      a,h
 182+ 013C 21 83 02                             ld      hl,AnitLogODDTable
 183+ 013F ED 31                                add     hl,a
 184+ 0141 ED 31                                add     hl,a
 185+ 0143 7E                                   ld      a,(hl)
 186+ 0144                                      ClearCarryFlag
 186+ 0144 B7          >                        or a
 187+ 0145 C9                                   ret
 188+ 0146              .ResultIsZero:          ClearCarryFlag
 188+ 0146 B7          >                        or a
 189+ 0147                                      ZeroA
 189+ 0147 AF          >                        xor a
 190+ 0148 C9                                   ret
 191+ 0149
 192+ 0149
 193+ 0149              AEquAmul256Div197Log:   JumpIfAIsZero   .ResultIsZero
 193+ 0149 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 193+ 014A CA 73 01    >                        jp	    z, .ResultIsZero
 194+ 014D                                      JumpIfAGTENusng d, AEquAmul256Div197LogLT
 194+ 014D BA          >                        cp     d
 194+ 014E D2 26 01    >                        jp		nc,AEquAmul256Div197LogLT
 195+ 0151 21 83 03                             ld      hl,LogTable                     ; point to log a in LogTable
 196+ 0154 ED 31                                add     hl,a                            ; Note we can't sla in case a > 127
 197+ 0156 ED 31                                add     hl,a
 198+ 0158 5E                                   ld      e,(hl)                          ; de = log a
 199+ 0159 23                                   inc     hl                              ; .
 200+ 015A 56                                   ld      d,(hl)                          ; .
 201+ 015B 21 A9 F3                             ld      hl,$F3A9                        ; hl = $F3A9 = log 197
 202+ 015E                                      ClearCarryFlag
 202+ 015E B7          >                        or a
 203+ 015F EB                                   ex      hl,de                           ; hl = log a, de = log 197
 204+ 0160 ED 52                                sbc     hl,de
 205+ 0162 38 0B                                jr      c,.ResultIsOne
 206+ 0164 7C                                   ld      a,h
 207+ 0165 21 83 01                             ld      hl,AntiLogTable
 208+ 0168 ED 31                                add     hl,a
 209+ 016A ED 31                                add     hl,a
 210+ 016C 7E                                   ld      a,(hl)
 211+ 016D                                      ClearCarryFlag
 211+ 016D B7          >                        or a
 212+ 016E C9                                   ret
 213+ 016F              .ResultIsOne:           ClearCarryFlag
 213+ 016F B7          >                        or a
 214+ 0170 3E FF                                ld      a,$FF
 215+ 0172 C9                                   ret
 216+ 0173              .ResultIsZero:          ClearCarryFlag
 216+ 0173 B7          >                        or a
 217+ 0174 C9                                   ret
 218+ 0175
 219+ 0175              AEquAmul256Div197LogSignA:
 220+ 0175 FD 67                                ld      iyh,a
 221+ 0177                                      ClearSignBitA
 221+ 0177 E6 7F       >                        and     SignMask8Bit
 222+ 0179 CD 49 01                             call    AEquAmul256Div197Log
 223+ 017C 47                                   ld      b,a
 224+ 017D FD 7C                                ld      a,iyh
 225+ 017F                                      SignBitOnlyA
 225+ 017F E6 80       >                        and     SignOnly8Bit
 226+ 0181 B0                                   or      b
 227+ 0182 C9                                   ret
# file closed: ../../Maths/logmaths.asm
1394  0183                                  INCLUDE "../../Tables/antilogtable.asm"
# file opened: ../../Tables/antilogtable.asm
   1+ 0183 01 01 01 01  AntiLogTable:           DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 0 to 9
   1+ 0187 01 01 01 01
   1+ 018B 01 01
   2+ 018D 01 01 01 01                          DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 10 to 19
   2+ 0191 01 01 01 01
   2+ 0195 01 01
   3+ 0197 01 01 01 01                          DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 20 to 29
   3+ 019B 01 01 01 01
   3+ 019F 01 01
   4+ 01A1 01 01 02 02                          DB $01, $01, $02, $02, $02, $02, $02, $02, $02, $02 ; 30 to 39
   4+ 01A5 02 02 02 02
   4+ 01A9 02 02
   5+ 01AB 02 02 02 02                          DB $02, $02, $02, $02, $02, $02, $02, $02, $02, $02 ; 40 to 49
   5+ 01AF 02 02 02 02
   5+ 01B3 02 02
   6+ 01B5 02 03 03 03                          DB $02, $03, $03, $03, $03, $03, $03, $03, $03, $03 ; 50 to 59
   6+ 01B9 03 03 03 03
   6+ 01BD 03 03
   7+ 01BF 03 03 03 03                          DB $03, $03, $03, $03, $04, $04, $04, $04, $04, $04 ; 60 to 69
   7+ 01C3 04 04 04 04
   7+ 01C7 04 04
   8+ 01C9 04 04 04 04                          DB $04, $04, $04, $04, $04, $05, $05, $05, $05, $05 ; 70 to 79
   8+ 01CD 04 05 05 05
   8+ 01D1 05 05
   9+ 01D3 05 05 05 06                          DB $05, $05, $05, $06, $06, $06, $06, $06, $06, $06 ; 80 to 89
   9+ 01D7 06 06 06 06
   9+ 01DB 06 06
  10+ 01DD 07 07 07 07                          DB $07, $07, $07, $07, $07, $07, $08, $08, $08, $08 ; 90 to 99
  10+ 01E1 07 07 08 08
  10+ 01E5 08 08
  11+ 01E7 08 08 09 09                          DB $08, $08, $09, $09, $09, $09, $09, $0A, $0A, $0A ; 100 to 109
  11+ 01EB 09 09 09 0A
  11+ 01EF 0A 0A
  12+ 01F1 0A 0B 0B 0B                          DB $0A, $0B, $0B, $0B, $0B, $0C, $0C, $0C, $0C, $0D ; 110 to 119
  12+ 01F5 0B 0C 0C 0C
  12+ 01F9 0C 0D
  13+ 01FB 0D 0D 0E 0E                          DB $0D, $0D, $0E, $0E, $0E, $0E, $0F, $0F, $10, $10 ; 120 to 129
  13+ 01FF 0E 0E 0F 0F
  13+ 0203 10 10
  14+ 0205 10 11 11 11                          DB $10, $11, $11, $11, $12, $12, $13, $13, $13, $14 ; 130 to 139
  14+ 0209 12 12 13 13
  14+ 020D 13 14
  15+ 020F 14 15 15 16                          DB $14, $15, $15, $16, $16, $17, $17, $18, $18, $19 ; 140 to 149
  15+ 0213 16 17 17 18
  15+ 0217 18 19
  16+ 0219 19 1A 1A 1B                          DB $19, $1A, $1A, $1B, $1C, $1C, $1D, $1D, $1E, $1F ; 150 to 159
  16+ 021D 1C 1C 1D 1D
  16+ 0221 1E 1F
  17+ 0223 20 20 21 22                          DB $20, $20, $21, $22, $22, $23, $24, $25, $26, $26 ; 160 to 169
  17+ 0227 22 23 24 25
  17+ 022B 26 26
  18+ 022D 27 28 29 2A                          DB $27, $28, $29, $2A, $2B, $2C, $2D, $2E, $2F, $30 ; 170 to 179
  18+ 0231 2B 2C 2D 2E
  18+ 0235 2F 30
  19+ 0237 31 32 33 34                          DB $31, $32, $33, $34, $35, $36, $38, $39, $3A, $3B ; 180 to 189
  19+ 023B 35 36 38 39
  19+ 023F 3A 3B
  20+ 0241 3D 3E 40 41                          DB $3D, $3E, $40, $41, $42, $44, $45, $47, $48, $4A ; 190 to 199
  20+ 0245 42 44 45 47
  20+ 0249 48 4A
  21+ 024B 4C 4D 4F 51                          DB $4C, $4D, $4F, $51, $52, $54, $56, $58, $5A, $5C ; 200 to 219
  21+ 024F 52 54 56 58
  21+ 0253 5A 5C
  22+ 0255 5E 60 62 64                          DB $5E, $60, $62, $64, $67, $69, $6B, $6D, $70, $72 ; 210 to 229
  22+ 0259 67 69 6B 6D
  22+ 025D 70 72
  23+ 025F 75 77 7A 7D                          DB $75, $77, $7A, $7D, $80, $82, $85, $88, $8B, $8E ; 220 to 239
  23+ 0263 80 82 85 88
  23+ 0267 8B 8E
  24+ 0269 91 94 98 9B                          DB $91, $94, $98, $9B, $9E, $A2, $A5, $A9, $AD, $B1 ; 230 to 239
  24+ 026D 9E A2 A5 A9
  24+ 0271 AD B1
  25+ 0273 B5 B8 BD C1                          DB $B5, $B8, $BD, $C1, $C5, $C9, $CE, $D2, $D7, $DB ; 240 to 249
  25+ 0277 C5 C9 CE D2
  25+ 027B D7 DB
  26+ 027D E0 E5 EA EF                          DB $E0, $E5, $EA, $EF, $F5, $FA                     ; 250 to 255
  26+ 0281 F5 FA
  27+ 0283
  28+ 0283 01 01 01 01  AnitLogODDTable:        DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 0 to 9
  28+ 0287 01 01 01 01
  28+ 028B 01 01
  29+ 028D 01 01 01 01                          DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 10 to 19
  29+ 0291 01 01 01 01
  29+ 0295 01 01
  30+ 0297 01 01 01 01                          DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 20 to 29
  30+ 029B 01 01 01 01
  30+ 029F 01 01
  31+ 02A1 01 01 02 02                          DB $01, $01, $02, $02, $02, $02, $02, $02, $02, $02 ; 30 to 39
  31+ 02A5 02 02 02 02
  31+ 02A9 02 02
  32+ 02AB 02 02 02 02                          DB $02, $02, $02, $02, $02, $02, $02, $02, $02, $02 ; 40 to 49
  32+ 02AF 02 02 02 02
  32+ 02B3 02 02
  33+ 02B5 02 03 03 03                          DB $02, $03, $03, $03, $03, $03, $03, $03, $03, $03 ; 50 to 59
  33+ 02B9 03 03 03 03
  33+ 02BD 03 03
  34+ 02BF 03 03 03 03                          DB $03, $03, $03, $03, $04, $04, $04, $04, $04, $04 ; 60 to 69
  34+ 02C3 04 04 04 04
  34+ 02C7 04 04
  35+ 02C9 04 04 04 04                          DB $04, $04, $04, $04, $05, $05, $05, $05, $05, $05 ; 70 to 79
  35+ 02CD 05 05 05 05
  35+ 02D1 05 05
  36+ 02D3 05 05 05 06                          DB $05, $05, $05, $06, $06, $06, $06, $06, $06, $06 ; 80 to 89
  36+ 02D7 06 06 06 06
  36+ 02DB 06 06
  37+ 02DD 07 07 07 07                          DB $07, $07, $07, $07, $07, $07, $08, $08, $08, $08 ; 90 to 99
  37+ 02E1 07 07 08 08
  37+ 02E5 08 08
  38+ 02E7 08 09 09 09                          DB $08, $09, $09, $09, $09, $09, $0A, $0A, $0A, $0A ; 100 to 109
  38+ 02EB 09 09 0A 0A
  38+ 02EF 0A 0A
  39+ 02F1 0A 0B 0B 0B                          DB $0A, $0B, $0B, $0B, $0B, $0C, $0C, $0C, $0D, $0D ; 110 to 119
  39+ 02F5 0B 0C 0C 0C
  39+ 02F9 0D 0D
  40+ 02FB 0D 0D 0E 0E                          DB $0D, $0D, $0E, $0E, $0E, $0F, $0F, $0F, $10, $10 ; 120 to 129
  40+ 02FF 0E 0F 0F 0F
  40+ 0303 10 10
  41+ 0305 10 11 11 12                          DB $10, $11, $11, $12, $12, $12, $13, $13, $14, $14 ; 130 to 139
  41+ 0309 12 12 13 13
  41+ 030D 14 14
  42+ 030F 14 15 15 16                          DB $14, $15, $15, $16, $16, $17, $17, $18, $18, $19 ; 140 to 149
  42+ 0313 16 17 17 18
  42+ 0317 18 19
  43+ 0319 1A 1A 1B 1B                          DB $1A, $1A, $1B, $1B, $1C, $1D, $1D, $1E, $1E, $1F ; 150 to 159
  43+ 031D 1C 1D 1D 1E
  43+ 0321 1E 1F
  44+ 0323 20 21 21 22                          DB $20, $21, $21, $22, $23, $24, $24, $25, $26, $27 ; 160 to 169
  44+ 0327 23 24 24 25
  44+ 032B 26 27
  45+ 032D 28 29 29 2A                          DB $28, $29, $29, $2A, $2B, $2C, $2D, $2E, $2F, $30 ; 170 to 179
  45+ 0331 2B 2C 2D 2E
  45+ 0335 2F 30
  46+ 0337 31 32 34 35                          DB $31, $32, $34, $35, $36, $37, $38, $3A, $3B, $3C ; 180 to 189
  46+ 033B 36 37 38 3A
  46+ 033F 3B 3C
  47+ 0341 3D 3F 40 42                          DB $3D, $3F, $40, $42, $43, $45, $46, $48, $49, $4B ; 190 to 199
  47+ 0345 43 45 46 48
  47+ 0349 49 4B
  48+ 034B 4C 4E 50 52                          DB $4C, $4E, $50, $52, $53, $55, $57, $59, $5B, $5D ; 200 to 219
  48+ 034F 53 55 57 59
  48+ 0353 5B 5D
  49+ 0355 5F 61 63 65                          DB $5F, $61, $63, $65, $68, $6A, $6C, $6F, $71, $74 ; 210 to 229
  49+ 0359 68 6A 6C 6F
  49+ 035D 71 74
  50+ 035F 76 79 7B 7E                          DB $76, $79, $7B, $7E, $81, $84, $87, $8A, $8D, $90 ; 220 to 239
  50+ 0363 81 84 87 8A
  50+ 0367 8D 90
  51+ 0369 93 96 99 9D                          DB $93, $96, $99, $9D, $A0, $A4, $A7, $AB, $AF, $B3 ; 230 to 239
  51+ 036D A0 A4 A7 AB
  51+ 0371 AF B3
  52+ 0373 B6 BA BF C3                          DB $B6, $BA, $BF, $C3, $C7, $CB, $D0, $D4, $D9, $DE ; 240 to 249
  52+ 0377 C7 CB D0 D4
  52+ 037B D9 DE
  53+ 037D E3 E8 ED F2                          DB $E3, $E8, $ED, $F2, $F7, $FD                     ; 250 to 255
  53+ 0381 F7 FD
  54+ 0383
# file closed: ../../Tables/antilogtable.asm
1395  0383                                  INCLUDE "../../Tables/logtable.asm"
# file opened: ../../Tables/logtable.asm
   1+ 0383 00 00        LogTable:               DW $0000                                                                   ; 0
   2+ 0385 00 00 00 20                          DW $0000, $2000, $32B8, $4000, $4A4D, $52B8, $59D6, $6000, $6570, $6A4D    ;   1 TO  10
   2+ 0389 B8 32 00 40
   2+ 038D 4D 4A B8 52
   2+ 0391 D6 59 00 60
   2+ 0395 70 65 4D 6A
   3+ 0399 B4 6E B8 72                          DW $6EB4, $72B8, $766A, $79D6, $7D05, $8000, $82CC, $8570, $87EF, $8A4D    ;  11 TO  20
   3+ 039D 6A 76 D6 79
   3+ 03A1 05 7D 00 80
   3+ 03A5 CC 82 70 85
   3+ 03A9 EF 87 4D 8A
   4+ 03AD 8E 8C B4 8E                          DW $8C8E, $8EB4, $90C1, $92B8, $949A, $966A, $9828, $99D6, $9B75, $9D05    ;  21 TO  30
   4+ 03B1 C1 90 B8 92
   4+ 03B5 9A 94 6A 96
   4+ 03B9 28 98 D6 99
   4+ 03BD 75 9B 05 9D
   5+ 03C1 89 9E 00 A0                          DW $9E89, $A000, $A16C, $A2CC, $A423, $A570, $A6B4, $A7EF, $A922, $AA4D    ;  31 TO  40
   5+ 03C5 6C A1 CC A2
   5+ 03C9 23 A4 70 A5
   5+ 03CD B4 A6 EF A7
   5+ 03D1 22 A9 4D AA
   6+ 03D5 71 AB 8E AC                          DW $AB71, $AC8E, $ADA4, $AEB4, $AFBD, $B0C1, $B1BF, $B2B8, $B3AC, $B49A    ;  41 TO  50
   6+ 03D9 A4 AD B4 AE
   6+ 03DD BD AF C1 B0
   6+ 03E1 BF B1 B8 B2
   6+ 03E5 AC B3 9A B4
   7+ 03E9 85 B5 6A B6                          DW $B585, $B66A, $B74B, $B828, $B901, $B9D6, $BAA7, $BB75, $BC3F, $BD05    ;  51 TO  60
   7+ 03ED 4B B7 28 B8
   7+ 03F1 01 B9 D6 B9
   7+ 03F5 A7 BA 75 BB
   7+ 03F9 3F BC 05 BD
   8+ 03FD C9 BD 89 BE                          DW $BDC9, $BE89, $BF46, $C000, $C0B7, $C16C, $C21D, $C2CC, $C379, $C423    ;  61 TO  70
   8+ 0401 46 BF 00 C0
   8+ 0405 B7 C0 6C C1
   8+ 0409 1D C2 CC C2
   8+ 040D 79 C3 23 C4
   9+ 0411 CB C4 70 C5                          DW $C4CB, $C570, $C613, $C6B4, $C752, $C7EF, $C88A, $C922, $C9B9, $CA4D    ;  71 TO  80
   9+ 0415 13 C6 B4 C6
   9+ 0419 52 C7 EF C7
   9+ 041D 8A C8 22 C9
   9+ 0421 B9 C9 4D CA
  10+ 0425 E0 CA 71 CB                          DW $CAE0, $CB71, $CC00, $CC8E, $CD1A, $CDA4, $CE2D, $CEB4, $CF39, $CFBD    ;  81 TO  90
  10+ 0429 00 CC 8E CC
  10+ 042D 1A CD A4 CD
  10+ 0431 2D CE B4 CE
  10+ 0435 39 CF BD CF
  11+ 0439 40 D0 C1 D0                          DW $D040, $D0C1, $D141, $D1BF, $D23C, $D2B8, $D332, $D3AC, $D424, $D49A    ;  91 TO 100
  11+ 043D 41 D1 BF D1
  11+ 0441 3C D2 B8 D2
  11+ 0445 32 D3 AC D3
  11+ 0449 24 D4 9A D4
  12+ 044D 10 D5 85 D5                          DW $D510, $D585, $D5F8, $D66A, $D6DB, $D74B, $D7BA, $D828, $D895, $D901    ; 101 TO 110
  12+ 0451 F8 D5 6A D6
  12+ 0455 DB D6 4B D7
  12+ 0459 BA D7 28 D8
  12+ 045D 95 D8 01 D9
  13+ 0461 6C D9 D6 D9                          DW $D96C, $D9D6, $DA3F, $DAA7, $DB0E, $DB75, $DBDA, $DC3F, $DCA2, $DD05    ; 111 TO 120
  13+ 0465 3F DA A7 DA
  13+ 0469 0E DB 75 DB
  13+ 046D DA DB 3F DC
  13+ 0471 A2 DC 05 DD
  14+ 0475 67 DD C9 DD                          DW $DD67, $DDC9, $DE29, $DE89, $DEE8, $DF46, $DFA3, $E000, $E05C, $E0B7    ; 121 TO 130
  14+ 0479 29 DE 89 DE
  14+ 047D E8 DE 46 DF
  14+ 0481 A3 DF 00 E0
  14+ 0485 5C E0 B7 E0
  15+ 0489 12 E1 6C E1                          DW $E112, $E16C, $E1C5, $E21D, $E275, $E2CC, $E323, $E379, $E3CE, $E423    ; 131 TO 140
  15+ 048D C5 E1 1D E2
  15+ 0491 75 E2 CC E2
  15+ 0495 23 E3 79 E3
  15+ 0499 CE E3 23 E4
  16+ 049D 77 E4 CB E4                          DW $E477, $E4CB, $E51E, $E570, $E5C2, $E613, $E664, $E6B4, $E703, $E752    ; 141 TO 150
  16+ 04A1 1E E5 70 E5
  16+ 04A5 C2 E5 13 E6
  16+ 04A9 64 E6 B4 E6
  16+ 04AD 03 E7 52 E7
  17+ 04B1 A1 E7 EF E7                          DW $E7A1, $E7EF, $E83D, $E88A, $E8D6, $E922, $E96E, $E9B9, $EA03, $EA4D    ; 151 TO 160
  17+ 04B5 3D E8 8A E8
  17+ 04B9 D6 E8 22 E9
  17+ 04BD 6E E9 B9 E9
  17+ 04C1 03 EA 4D EA
  18+ 04C5 97 EA E0 EA                          DW $EA97, $EAE0, $EB29, $EB71, $EBB9, $EC00, $EC47, $EC8E, $ECD4, $ED1A    ; 161 TO 170
  18+ 04C9 29 EB 71 EB
  18+ 04CD B9 EB 00 EC
  18+ 04D1 47 EC 8E EC
  18+ 04D5 D4 EC 1A ED
  19+ 04D9 5F ED A4 ED                          DW $ED5F, $EDA4, $EDE8, $EE2D, $EE70, $EEB4, $EEF7, $EF39, $EF7B, $EFBD    ; 171 TO 180
  19+ 04DD E8 ED 2D EE
  19+ 04E1 70 EE B4 EE
  19+ 04E5 F7 EE 39 EF
  19+ 04E9 7B EF BD EF
  20+ 04ED FF EF 40 F0                          DW $EFFF, $F040, $F081, $F0C1, $F101, $F141, $F180, $F1BF, $F1FE, $F23C    ; 181 TO 190
  20+ 04F1 81 F0 C1 F0
  20+ 04F5 01 F1 41 F1
  20+ 04F9 80 F1 BF F1
  20+ 04FD FE F1 3C F2
  21+ 0501 7A F2 B8 F2                          DW $F27A, $F2B8, $F2F5, $F332, $F36F, $F3AC, $F3E8, $F424, $F45F, $F49A    ; 191 TO 290
  21+ 0505 F5 F2 32 F3
  21+ 0509 6F F3 AC F3
  21+ 050D E8 F3 24 F4
  21+ 0511 5F F4 9A F4
  22+ 0515 D5 F4 10 F5                          DW $F4D5, $F510, $F54A, $F585, $F5BE, $F5F8, $F631, $F66A, $F6A3, $F6DB    ; 201 TO 210
  22+ 0519 4A F5 85 F5
  22+ 051D BE F5 F8 F5
  22+ 0521 31 F6 6A F6
  22+ 0525 A3 F6 DB F6
  23+ 0529 13 F7 4B F7                          DW $F713, $F74B, $F783, $F7BA, $F7F1, $F828, $F85F, $F895, $F8CB, $F901    ; 211 TO 220
  23+ 052D 83 F7 BA F7
  23+ 0531 F1 F7 28 F8
  23+ 0535 5F F8 95 F8
  23+ 0539 CB F8 01 F9
  24+ 053D 36 F9 6C F9                          DW $F936, $F96C, $F9A1, $F9D6, $FA0A, $FA3F, $FA73, $FAA7, $FADB, $FB0E    ; 221 TO 230
  24+ 0541 A1 F9 D6 F9
  24+ 0545 0A FA 3F FA
  24+ 0549 73 FA A7 FA
  24+ 054D DB FA 0E FB
  25+ 0551 42 FB 75 FB                          DW $FB42, $FB75, $FBA7, $FBDA, $FC0C, $FC3F, $FC71, $FCA2, $FCD4, $FD05    ; 231 TO 240
  25+ 0555 A7 FB DA FB
  25+ 0559 0C FC 3F FC
  25+ 055D 71 FC A2 FC
  25+ 0561 D4 FC 05 FD
  26+ 0565 36 FD 67 FD                          DW $FD36, $FD67, $FD98, $FDC9, $FDF9, $FE29, $FE59, $FE89, $FEB8, $FEE8    ; 241 TO 250
  26+ 0569 98 FD C9 FD
  26+ 056D F9 FD 29 FE
  26+ 0571 59 FE 89 FE
  26+ 0575 B8 FE E8 FE
  27+ 0579 17 FF 46 FF                          DW $FF17, $FF46, $FF75, $FFA3, $FFA3                                       ; 251 TO 255
  27+ 057D 75 FF A3 FF
  27+ 0581 A3 FF
  28+ 0583
  29+ 0583
  30+ 0583
  31+ 0583 00 00 00 00  LogReverseHighByte:     DW $00, 000, $20, 002, $32, 003, $40, 004, $4A, 005, $52, 006
  31+ 0587 20 00 02 00
  31+ 058B 32 00 03 00
  31+ 058F 40 00 04 00
  31+ 0593 4A 00 05 00
  31+ 0597 52 00 06 00
  32+ 059B 59 00 07 00                          DW $59, 007, $60, 008, $65, 009, $6A, 010, $6E, 011, $72, 012
  32+ 059F 60 00 08 00
  32+ 05A3 65 00 09 00
  32+ 05A7 6A 00 0A 00
  32+ 05AB 6E 00 0B 00
  32+ 05AF 72 00 0C 00
  33+ 05B3 76 00 0D 00                          DW $76, 013, $79, 014, $7D, 015, $80, 016, $82, 017, $85, 018
  33+ 05B7 79 00 0E 00
  33+ 05BB 7D 00 0F 00
  33+ 05BF 80 00 10 00
  33+ 05C3 82 00 11 00
  33+ 05C7 85 00 12 00
  34+ 05CB 87 00 13 00                          DW $87, 019, $8A, 020, $8C, 021, $8E, 022, $90, 023, $92, 024
  34+ 05CF 8A 00 14 00
  34+ 05D3 8C 00 15 00
  34+ 05D7 8E 00 16 00
  34+ 05DB 90 00 17 00
  34+ 05DF 92 00 18 00
  35+ 05E3 94 00 19 00                          DW $94, 025, $96, 026, $98, 027, $99, 028, $9B, 029, $9D, 030
  35+ 05E7 96 00 1A 00
  35+ 05EB 98 00 1B 00
  35+ 05EF 99 00 1C 00
  35+ 05F3 9B 00 1D 00
  35+ 05F7 9D 00 1E 00
  36+ 05FB 9E 00 1F 00                          DW $9E, 031, $A0, 032, $A1, 033, $A2, 034, $A4, 035, $A5, 036
  36+ 05FF A0 00 20 00
  36+ 0603 A1 00 21 00
  36+ 0607 A2 00 22 00
  36+ 060B A4 00 23 00
  36+ 060F A5 00 24 00
  37+ 0613 A6 00 25 00                          DW $A6, 037, $A7, 038, $A9, 039, $AA, 040, $AB, 041, $AC, 042
  37+ 0617 A7 00 26 00
  37+ 061B A9 00 27 00
  37+ 061F AA 00 28 00
  37+ 0623 AB 00 29 00
  37+ 0627 AC 00 2A 00
  38+ 062B AD 00 2B 00                          DW $AD, 043, $AE, 044, $AF, 045, $B0, 046, $B1, 047, $B2, 048
  38+ 062F AE 00 2C 00
  38+ 0633 AF 00 2D 00
  38+ 0637 B0 00 2E 00
  38+ 063B B1 00 2F 00
  38+ 063F B2 00 30 00
  39+ 0643 B3 00 31 00                          DW $B3, 049, $B4, 050, $B5, 051, $B6, 052, $B7, 053, $B8, 054
  39+ 0647 B4 00 32 00
  39+ 064B B5 00 33 00
  39+ 064F B6 00 34 00
  39+ 0653 B7 00 35 00
  39+ 0657 B8 00 36 00
  40+ 065B B9 00 38 00                          DW $B9, 056, $B9, 056, $BA, 057, $BB, 058, $BC, 059, $BD, 060
  40+ 065F B9 00 38 00
  40+ 0663 BA 00 39 00
  40+ 0667 BB 00 3A 00
  40+ 066B BC 00 3B 00
  40+ 066F BD 00 3C 00
  41+ 0673 BE 00 3E 00                          DW $BE, 062, $BF, 063, $C0, 064, $C1, 066, $C2, 067, $C3, 069
  41+ 0677 BF 00 3F 00
  41+ 067B C0 00 40 00
  41+ 067F C1 00 42 00
  41+ 0683 C2 00 43 00
  41+ 0687 C3 00 45 00
  42+ 068B C4 00 46 00                          DW $C4, 070, $C5, 072, $C6, 072, $C7, 074, $C8, 076, $C9, 077
  42+ 068F C5 00 48 00
  42+ 0693 C6 00 48 00
  42+ 0697 C7 00 4A 00
  42+ 069B C8 00 4C 00
  42+ 069F C9 00 4D 00
  43+ 06A3 CA 00 50 00                          DW $CA, 080, $CB, 082, $CC, 083, $CD, 085, $CE, 087, $CF, 088
  43+ 06A7 CB 00 52 00
  43+ 06AB CC 00 53 00
  43+ 06AF CD 00 55 00
  43+ 06B3 CE 00 57 00
  43+ 06B7 CF 00 58 00
  44+ 06BB D0 00 5A 00                          DW $D0, 090, $D1, 092, $D2, 094, $D3, 097, $D4, 100, $D5, 102
  44+ 06BF D1 00 5C 00
  44+ 06C3 D2 00 5E 00
  44+ 06C7 D3 00 61 00
  44+ 06CB D4 00 64 00
  44+ 06CF D5 00 66 00
  45+ 06D3 D6 00 68 00                          DW $D6, 104, $D6, 105, $D7, 106, $D7, 107, $D8, 108, $D8, 109
  45+ 06D7 D6 00 69 00
  45+ 06DB D7 00 6A 00
  45+ 06DF D7 00 6B 00
  45+ 06E3 D8 00 6C 00
  45+ 06E7 D8 00 6D 00
  46+ 06EB D9 00 6E 00                          DW $D9, 110, $D9, 111, $D9, 112, $DA, 113, $DB, 114, $DC, 117
  46+ 06EF D9 00 6F 00
  46+ 06F3 D9 00 70 00
  46+ 06F7 DA 00 71 00
  46+ 06FB DB 00 72 00
  46+ 06FF DC 00 75 00
  47+ 0703 DD 00 78 00                          DW $DD, 120, $DE, 123, $DF, 126, $E0, 128, $E1, 131, $E2, 134
  47+ 0707 DE 00 7B 00
  47+ 070B DF 00 7E 00
  47+ 070F E0 00 80 00
  47+ 0713 E1 00 83 00
  47+ 0717 E2 00 86 00
  48+ 071B E3 00 89 00                          DW $E3, 137, $E4, 140, $E5, 143, $E6, 146, $E7, 149, $E8, 153
  48+ 071F E4 00 8C 00
  48+ 0723 E5 00 8F 00
  48+ 0727 E6 00 92 00
  48+ 072B E7 00 95 00
  48+ 072F E8 00 99 00
  49+ 0733 E9 00 9C 00                          DW $E9, 156, $EA, 159, $EB, 163, $EC, 166, $ED, 170, $EE, 174
  49+ 0737 EA 00 9F 00
  49+ 073B EB 00 A3 00
  49+ 073F EC 00 A6 00
  49+ 0743 ED 00 AA 00
  49+ 0747 EE 00 AE 00
  50+ 074B EF 00 B2 00                          DW $EF, 178, $F0, 182, $F1, 185, $F2, 190, $F3, 194, $F4, 198
  50+ 074F F0 00 B6 00
  50+ 0753 F1 00 B9 00
  50+ 0757 F2 00 BE 00
  50+ 075B F3 00 C2 00
  50+ 075F F4 00 C6 00
  51+ 0763 F5 00 CA 00                          DW $F5, 202, $F6, 207, $F7, 211, $F8, 216, $F8, 217, $F9, 220
  51+ 0767 F6 00 CF 00
  51+ 076B F7 00 D3 00
  51+ 076F F8 00 D8 00
  51+ 0773 F8 00 D9 00
  51+ 0777 F9 00 DC 00
  52+ 077B FA 00 E1 00                          DW $FA, 225, $FB, 230, $FB, 233, $FC, 235, $FD, 240, $FE, 246
  52+ 077F FB 00 E6 00
  52+ 0783 FB 00 E9 00
  52+ 0787 FC 00 EB 00
  52+ 078B FD 00 F0 00
  52+ 078F FE 00 F6 00
  53+ 0793 FF 00 FB 00                          DW $FF, 251
  54+ 0797              LogReverseTableLen:     EQU $ - LogReverseHighByte
# file closed: ../../Tables/logtable.asm
1396  0797                                  DISPLAY "Bank ",BankMathsTables," - Bytes free ",/D, $2000 - ($-MathsTablesAddr), " - BankMathsTables"
1397  0797                                  ASSERT $-MathsTablesAddr <8912, Bank code leaks over 8K boundary
1398  0797              ; Bank 100  -----------------------------------------------------------------------------------------------------------------------
1399  0797                                  SLOT    KeyboardAddr
1400  0797                                  PAGE    BankKeyboard
1401  0797                                  ORG SoundAddr, BankKeyboard
1402  E000                                  INCLUDE "../../Hardware/keyboard.asm"
# file opened: ../../Hardware/keyboard.asm
   1+ E000              ;
   2+ E000              ; $FEFE;65278 V, C, X, Z, Caps Shifts       4  3  2  1  0
   3+ E000              ; $FDFE;65022 G, F, D, S, A                 9  8  7  6  5
   4+ E000              ; $FBFE;64510 T, R, E, W, Q                14 13 12 11 10
   5+ E000              ; $F7FE;63486 5, 4, 3, 2, 1                19 18 17 16 15
   6+ E000              ; $EFFE;61438 6, 7, 8, 9, 0                24 23 22 23 20
   7+ E000              ; $DFFE;57342 Y, U, I, O, P                29 28 27 26 25
   8+ E000              ; $BFFE;49150 H, J, K, L, Enter            34 33 32 31 30
   9+ E000              ; $7FFE;32766 B, N, M, Symbol Shift, Space 39 38 37 36 35
  10+ E000              ;
  11+ E000              ; Keyboard
  12+ E000              ;
  13+ E000              ;   0      1       2       3       4       5        6       7       8       9
  14+ E000              ;  VK_CAPS, VK_Z,  VK_X,   VK_C,   VK_V,   VK_A,    VK_S,   VK_D,   VK_F,   VK_G
  15+ E000              ;   10     11      12      13      14      15       16      17      18      19
  16+ E000              ;  VK_Q,   VK_W,   VK_E,   VK_R,   VK_T,   VK_1,    VK_2,   VK_3,   VK_4,   VK_5
  17+ E000              ;   20     21      22      23      24      25       26      27      28      29
  18+ E000              ;  VK_0    VK_9,   VK_8,   VK_7,   VK_6,   VK_P ,    VK_O,  VK_I,   VK_U,   VK_Y
  19+ E000              ;   30     31      32      33      34      35       36      37      38      39
  20+ E000              ; VK_ENTER VK_L,   VK_K,   VK_J,   VK_H,   VK_SPACE VK_SYM, VK_M,   VK_N,   VK_B
  21+ E000              ;
  22+ E000              ; ZX Spectrum Next Compound keys
  23+ E000              ;   40     41       42       43      44      45       46       47
  24+ E000              ;  VK_SEMI VK_QUOTE VK_COMMA VK_STOP VK_UP   VK_DOWN  VK_LEFT  VK _RIGHT        $Register B0 bits 7 to 0    (Set to set ULA Register ($68) bit to to prevent default keystrokes
  25+ E000              ;   48       49      50       51         52          53       54      55
  26+ E000              ;  VK_DELETE VK_EDIT VK_BREAK VK_INV_VID VK_TRUE_VID VK_GRAPH VK_CAPS VK_EXTEND $Register B1 bits 7 to 0
  27+ E000              ; Default map
  28+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  29+ E000              ;   0          1           2             3              4           5           6           7           8           9
  30+ E000              ;   VK_CAPS    VK_Z        VK_X,         VK_C,          VK_V,       VK_A        VK_S,       VK_D,       VK_F,       VK_G
  31+ E000              ;              GameSkip                  Equip          SelLCargo   Climb       Decelerate  Recentre    FireM       HomeCursor
  32+ E000              ;                                                                                                       Find System
  33+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  34+ E000              ;   10         11          12            13             14          15          16          17          18          19
  35+ E000              ;   VK_Q       VK_W,       VK_E,         VK_R,          VK_T,       VK_1        VK_2        VK_3        VK_4        VK_5
  36+ E000              ;   Dive       Accelerate  ECM           UnarmMissile   TargetM     FrontV      AftV        LeftV       RightV      GalacticChart
  37+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  38+ E000              ;   20         Accel       22            23             24          25          26          27          28          29
  39+ E000              ;   VK_0       VK_9,       VK_8,         VK_7,          VK_6,       VK_P ,      VK_O,       VK_I,       VK_U,       VK_Y
  40+ E000              ;   EscapePod  Inventory   Status        MarketPrices   LocalChart  RollRight   RolLLeft                EnergyBomb  Quit
  41+ E000              ;   PlanetData                                                      PauseGame   SaveGame
  42+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  43+ E000              ;   30         31          32            33             34          Right       36          37          EnergyBomb  39
  44+ E000              ;   VK_ENTER   VK_L,       VK_K,         VK_J,          VK_H,       VK_SPACE    VK_SYM,     VK_M,       VK_N,       VK_B
  45+ E000              ;              Launch                    Distance       Hyperspace  Laser                               DockComp    BuyCargo
  46+ E000              ;              ResumeGame                WarpJump
  47+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  48+ E000              ;   40         41          42            43             44          45          46          47          48          49
  49+ E000              ;   VK_SEMI    VK_QUOTE    VK_COMMA      VK_STOP        VK_UP       VK_DOWN     VK_LEFT     VK _RIGHT   VK_DELETE   VK_EDIT
  50+ E000              ;   Market     EquipShip   PlanetData    NearestObject  Map Cursor no auto repeat....................   Delete      Find System
  51+ E000              ;
  52+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  53+ E000              ;   50         51          52            53             54          55
  54+ E000              ;   VK_BREAK   VK_INV_VID  VK_TRUE_VID   VK_GRAPH       VK_EXTCAPS  VK_EXTEND
  55+ E000              ;   EscapePod  Inventory   Status        GalacticChart  LocalChart  SystemJump
  56+ E000              ;
  57+ E000
  58+ E000              ; You can read address to check keystate by address KeyboardMap + c_Pressed corresponding key. There is also an addr_ helper too
  59+ E000
  60+ E000              c_Pressed_Front         equ 0  * 2
  61+ E000              c_Pressed_Aft           equ 1  * 2
  62+ E000              c_Pressed_Left          equ 2  * 2
  63+ E000              c_Pressed_Right         equ 3  * 2
  64+ E000              c_Pressed_RollLeft      equ 4  * 2
  65+ E000              c_Pressed_RollRight     equ 5  * 2
  66+ E000              c_Pressed_Dive          equ 6  * 2
  67+ E000              c_Pressed_Climb         equ 7  * 2
  68+ E000              c_Pressed_Accellerate   equ 8  * 2
  69+ E000              c_Pressed_Decellerate   equ 9  * 2
  70+ E000              c_Pressed_FireLaser     equ 10 * 2
  71+ E000              c_Pressed_TargetMissle  equ 11 * 2
  72+ E000              c_Pressed_FireMissile   equ 12 * 2
  73+ E000              c_Pressed_UnarmMissile  equ 13 * 2
  74+ E000              c_Pressed_ECM           equ 14 * 2
  75+ E000              c_Pressed_EnergyBomb    equ 15 * 2
  76+ E000              c_Pressed_EscapePod     equ 16 * 2
  77+ E000              c_Pressed_DockingComp   equ 17 * 2
  78+ E000              c_Pressed_Hyperspace    equ 18 * 2
  79+ E000              c_Pressed_Distance      equ 19 * 2
  80+ E000              c_Pressed_HomeCursor    equ 20 * 2
  81+ E000              c_Pressed_Launch        equ 21 * 2
  82+ E000              c_Pressed_BuyCargo      equ 22 * 2
  83+ E000              c_Pressed_SellCargo     equ 23 * 2
  84+ E000              c_Pressed_Equip         equ 24 * 2
  85+ E000              c_Pressed_GalacticChrt  equ 25 * 2
  86+ E000              c_Pressed_LocalChart    equ 26 * 2
  87+ E000              c_Pressed_MarketPrices  equ 27 * 2
  88+ E000              c_Pressed_Status        equ 28 * 2
  89+ E000              c_Pressed_Inventory     equ 29 * 2
  90+ E000              c_Pressed_GameSkip      equ 30 * 2
  91+ E000              c_Pressed_Save          equ 31 * 2
  92+ E000              c_Pressed_Freeze        equ 32 * 2
  93+ E000              c_Pressed_Resume        equ 33 * 2
  94+ E000              c_Pressed_Recentre      equ 34 * 2
  95+ E000              c_Pressed_Quit          equ 35 * 2
  96+ E000              c_Pressed_PlanetData    equ 36 * 2
  97+ E000              c_Pressed_CursorUp      equ 37 * 2
  98+ E000              c_Pressed_CursorDown    equ 38 * 2
  99+ E000              c_Pressed_Find          equ 39 * 2
 100+ E000              c_Pressed_Yes           equ 40 * 2
 101+ E000              c_Pressed_No            equ 41 * 2
 102+ E000              c_Pressed_Warp          equ 42 * 2
 103+ E000              c_Pressed_ExtMarket     equ 43 * 2
 104+ E000              c_Pressed_ExtEquip      equ 44 * 2
 105+ E000              c_Pressed_ExtPlanet     equ 45 * 2
 106+ E000              c_Pressed_ExtNearest    equ 46 * 2
 107+ E000              c_Pressed_ExtCurUp      equ 47 * 2
 108+ E000              c_Pressed_ExtCurDown    equ 48 * 2
 109+ E000              c_Pressed_ExtCurLeft    equ 49 * 2
 110+ E000              c_Pressed_ExtCurRight   equ 50 * 2
 111+ E000              c_Pressed_ExtDelete     equ 51 * 2
 112+ E000              c_Pressed_ExtFindSystem equ 52 * 2
 113+ E000              c_Pressed_ExtEscapePod  equ 53 * 2
 114+ E000              c_Pressed_ExtInventory  equ 54 * 2
 115+ E000              c_Pressed_ExtStatus     equ 55 * 2
 116+ E000              c_Pressed_ExtGlactic    equ 56 * 2
 117+ E000              c_Pressed_ExtLocal      equ 57 * 2
 118+ E000              c_Pressed_ExtSystemJump equ 58 * 2
 119+ E000
 120+ E000              ; half row 1
 121+ E000              VK_CAPS  				equ 0
 122+ E000              VK_Z  					equ 1
 123+ E000              VK_X  					equ 2
 124+ E000              VK_C  					equ 3
 125+ E000              VK_V  					equ 4
 126+ E000              ; half row 2
 127+ E000              VK_A  					equ 5
 128+ E000              VK_S  					equ 6
 129+ E000              VK_D  					equ 7
 130+ E000              VK_F					equ 8
 131+ E000              VK_G  					equ 9
 132+ E000              ; half row 3
 133+ E000              VK_Q  					equ 10
 134+ E000              VK_W  					equ 11
 135+ E000              VK_E  					equ 12
 136+ E000              VK_R  					equ 13
 137+ E000              VK_T  					equ 14
 138+ E000              ; half row 4
 139+ E000              VK_1  					equ 15
 140+ E000              VK_2  					equ 16
 141+ E000              VK_3  					equ 17
 142+ E000              VK_4  					equ 18
 143+ E000              VK_5  					equ 19
 144+ E000              ; half row 5
 145+ E000              VK_0 					equ 20
 146+ E000              VK_9 					equ 21
 147+ E000              VK_8 					equ 22
 148+ E000              VK_7 					equ 23
 149+ E000              VK_6 					equ 24
 150+ E000              ; half row 6
 151+ E000              VK_P  					equ 25
 152+ E000              VK_O  					equ 26
 153+ E000              VK_I  					equ 27
 154+ E000              VK_U  					equ 28
 155+ E000              VK_Y  					equ 29
 156+ E000              ; half row 7
 157+ E000              VK_ENTER 				equ 30
 158+ E000              VK_L  					equ 31
 159+ E000              VK_K  					equ 32
 160+ E000              VK_J  					equ 33
 161+ E000              VK_H  					equ 34
 162+ E000              ; half row 8
 163+ E000              VK_SPACE 				equ 35
 164+ E000              VK_SYM  				equ 36
 165+ E000              VK_M  					equ 37
 166+ E000              VK_N  					equ 38
 167+ E000              VK_B  					equ 39
 168+ E000              ; Extended Group B0
 169+ E000              VK_SEMI                 equ 40
 170+ E000              VK_QUOTE                equ 41
 171+ E000              VK_COMMA                equ 42
 172+ E000              VK_STOP                 equ 43
 173+ E000              VK_UP                   equ 44
 174+ E000              VK_DOWN                 equ 45
 175+ E000              VK_LEFT                 equ 46
 176+ E000              VK_RIGHT                equ 47
 177+ E000              ; Extended Group B1
 178+ E000              VK_DELETE               equ 48
 179+ E000              VK_EDIT                 equ 49
 180+ E000              VK_BREAK                equ 50
 181+ E000              VK_INV_VID              equ 51
 182+ E000              VK_TRUE_VID             equ 52
 183+ E000              VK_GRAPH                equ 53
 184+ E000              VK_EXTCAPS              equ 54
 185+ E000              VK_EXTEND               equ 55
 186+ E000              ;KeyboardMapping
 187+ E000              KeyCode_Front        	equ VK_1
 188+ E000              KeyCode_Aft          	equ VK_2
 189+ E000              KeyCode_Left         	equ VK_3
 190+ E000              KeyCode_Right        	equ VK_4
 191+ E000              KeyCode_RollLeft     	equ VK_O
 192+ E000              KeyCode_RollRight    	equ VK_P
 193+ E000              KeyCode_Dive         	equ VK_Q
 194+ E000              KeyCode_Climb        	equ VK_A
 195+ E000              KeyCode_Accellerate  	equ VK_W
 196+ E000              KeyCode_Decellerate  	equ VK_S
 197+ E000              KeyCode_FireLaser    	equ VK_SPACE
 198+ E000              KeyCode_TargetMissle 	equ VK_T
 199+ E000              KeyCode_FireMissile  	equ VK_STOP
 200+ E000              KeyCode_Find        	equ VK_F
 201+ E000              KeyCode_UnarmMissile 	equ VK_R
 202+ E000              KeyCode_ECM          	equ VK_E
 203+ E000              KeyCode_EnergyBomb   	equ VK_U
 204+ E000              KeyCode_EscapePod    	equ VK_CAPS
 205+ E000              KeyCode_DockingComp  	equ VK_N
 206+ E000              KeyCode_Hyperspace   	equ VK_H
 207+ E000              KeyCode_Distance     	equ VK_J
 208+ E000              KeyCode_HomeCursor   	equ VK_G
 209+ E000              KeyCode_Launch       	equ VK_L
 210+ E000              KeyCode_BuyCargo     	equ VK_B
 211+ E000              KeyCode_SellCargo    	equ VK_V
 212+ E000              KeyCode_Equip        	equ VK_C
 213+ E000              KeyCode_GalacticChrt 	equ VK_5
 214+ E000              KeyCode_LocalChart   	equ VK_6
 215+ E000              KeyCode_MarketPrices 	equ VK_7
 216+ E000              KeyCode_Status       	equ VK_8
 217+ E000              KeyCode_Inventory    	equ VK_9
 218+ E000              KeyCode_GameSkip     	equ VK_Z
 219+ E000              KeyCode_Save         	equ VK_O
 220+ E000              KeyCode_Freeze       	equ VK_B
 221+ E000              KeyCode_Resume       	equ VK_L
 222+ E000              KeyCode_Recentre     	equ VK_STOP
 223+ E000              KeyCode_Quit         	equ VK_Y
 224+ E000              KeyCode_PlanetData   	equ VK_0
 225+ E000              KeyCode_CursorUp        equ VK_Q
 226+ E000              KeyCode_CursorDown      equ VK_A
 227+ E000              KeyCode_PressedYes      equ VK_Y
 228+ E000              KeyCode_PressedNo       equ VK_N
 229+ E000              KeyCode_Warp            equ VK_J
 230+ E000              KeyCode_ExtMarket       equ VK_SEMI
 231+ E000              KeyCode_ExtEquip        equ VK_QUOTE
 232+ E000              KeyCode_ExtPlanet       equ VK_COMMA
 233+ E000              KeyCode_ExtNearest      equ VK_STOP
 234+ E000              KeyCode_ExtCurUp        equ VK_UP
 235+ E000              KeyCode_ExtCurDown      equ VK_DOWN
 236+ E000              KeyCode_ExtCurLeft      equ VK_LEFT
 237+ E000              KeyCode_ExtCurRight     equ VK_RIGHT
 238+ E000              KeyCode_ExtDelete       equ VK_DELETE
 239+ E000              KeyCode_ExtFindSystem   equ VK_EDIT
 240+ E000              KeyCode_ExtEscapePod    equ VK_BREAK
 241+ E000              KeyCode_ExtInventory    equ VK_INV_VID
 242+ E000              KeyCode_ExtStatus       equ VK_TRUE_VID
 243+ E000              KeyCode_ExtGlactic      equ VK_GRAPH
 244+ E000              KeyCode_ExtLocal        equ VK_EXTCAPS
 245+ E000              KeyCode_ExtSystemJump   equ VK_EXTEND
 246+ E000
 247+ E000 00 00 00...  Keys					DS	55          ; This is the list of key states for all the VK keys presssed i.e. VK_CAPS through to VK_B
 248+ E037              c_KeyBoardLen 			equ $ - Keys
 249+ E037 00 00 00...  RawKeys					DS	10          ; increased for extended keys
 250+ E041 FE FD FB F7  KeyAddrTab				DB	$FE, $FD, $FB, $F7, $EF, $DF, $BF, $7F
 250+ E045 EF DF BF 7F
 251+ E049              ; Now keyboard map lists each game key and the corresponding address in the Keys table to get the value. This way redefining keys is just a case
 252+ E049              ; of updating this table with the respective location to look up
 253+ E049              ; key list sequence is in table above
 254+ E049 0F E0 10 E0  KeyboardMap             DW  Keys+KeyCode_Front        ,Keys+KeyCode_Aft          ,Keys+KeyCode_Left         ,Keys+KeyCode_Right        ,Keys+KeyCode_RollLeft
 254+ E04D 11 E0 12 E0
 254+ E051 1A E0
 255+ E053 19 E0 0A E0                          DW  Keys+KeyCode_RollRight    ,Keys+KeyCode_Dive         ,Keys+KeyCode_Climb        ,Keys+KeyCode_Accellerate  ,Keys+KeyCode_Decellerate
 255+ E057 05 E0 0B E0
 255+ E05B 06 E0
 256+ E05D 23 E0 0E E0                          DW  Keys+KeyCode_FireLaser    ,Keys+KeyCode_TargetMissle ,Keys+KeyCode_FireMissile  ,Keys+KeyCode_UnarmMissile ,Keys+KeyCode_ECM
 256+ E061 2B E0 0D E0
 256+ E065 0C E0
 257+ E067 1C E0 00 E0                          DW  Keys+KeyCode_EnergyBomb   ,Keys+KeyCode_EscapePod    ,Keys+KeyCode_DockingComp  ,Keys+KeyCode_Hyperspace   ,Keys+KeyCode_Distance
 257+ E06B 26 E0 22 E0
 257+ E06F 21 E0
 258+ E071 09 E0 1F E0                          DW  Keys+KeyCode_HomeCursor   ,Keys+KeyCode_Launch       ,Keys+KeyCode_BuyCargo     ,Keys+KeyCode_SellCargo    ,Keys+KeyCode_Equip
 258+ E075 27 E0 04 E0
 258+ E079 03 E0
 259+ E07B 13 E0 18 E0                          DW  Keys+KeyCode_GalacticChrt ,Keys+KeyCode_LocalChart   ,Keys+KeyCode_MarketPrices ,Keys+KeyCode_Status       ,Keys+KeyCode_Inventory
 259+ E07F 17 E0 16 E0
 259+ E083 15 E0
 260+ E085 01 E0 1A E0                          DW  Keys+KeyCode_GameSkip     ,Keys+KeyCode_Save         ,Keys+KeyCode_Freeze       ,Keys+KeyCode_Resume       ,Keys+KeyCode_Recentre
 260+ E089 27 E0 1F E0
 260+ E08D 2B E0
 261+ E08F 1D E0 14 E0                          DW  Keys+KeyCode_Quit         ,Keys+KeyCode_PlanetData   ,Keys+KeyCode_CursorUp     ,Keys+KeyCode_CursorDown   ,Keys+KeyCode_Find
 261+ E093 0A E0 05 E0
 261+ E097 08 E0
 262+ E099 1D E0 26 E0                          DW  Keys+KeyCode_PressedYes   ,Keys+KeyCode_PressedNo    ,Keys+KeyCode_Warp         ,Keys+KeyCode_ExtMarket    ,Keys+KeyCode_ExtEquip
 262+ E09D 21 E0 28 E0
 262+ E0A1 29 E0
 263+ E0A3 2A E0 2B E0                          DW  Keys+KeyCode_ExtPlanet    ,Keys+KeyCode_ExtNearest   ,Keys+KeyCode_ExtCurUp     ,Keys+KeyCode_ExtCurDown   ,Keys+KeyCode_ExtCurLeft
 263+ E0A7 2C E0 2D E0
 263+ E0AB 2E E0
 264+ E0AD 2F E0 30 E0                          DW  Keys+KeyCode_ExtCurRight  ,Keys+KeyCode_ExtDelete    ,Keys+KeyCode_ExtFindSystem,Keys+KeyCode_ExtEscapePod ,Keys+KeyCode_ExtInventory
 264+ E0B1 31 E0 32 E0
 264+ E0B5 33 E0
 265+ E0B7 34 E0 35 E0                          DW  Keys+KeyCode_ExtStatus    ,Keys+KeyCode_ExtGlactic   ,Keys+KeyCode_ExtLocal     ,Keys+KeyCode_ExtSystemJump
 265+ E0BB 36 E0 37 E0
 266+ E0BF
 267+ E0BF
 268+ E0BF 3F 5A 58 43  ASCII_Map:              DB "?","Z","X","C","V"
 268+ E0C3 56
 269+ E0C4 41 53 44 46                          DB "A","S","D","F","G"
 269+ E0C8 47
 270+ E0C9 51 57 45 52                          DB "Q","W","E","R","T"
 270+ E0CD 54
 271+ E0CE 31 32 33 34                          DB "1","2","3","4","5"
 271+ E0D2 35
 272+ E0D3 30 39 38 37                          DB "0","9","8","7","6"
 272+ E0D7 36
 273+ E0D8 50 4F 49 55                          DB "P","O","I","U","Y"
 273+ E0DC 59
 274+ E0DD 3E 4C 4B 4A                          DB ">","L","K","J","H"
 274+ E0E1 48
 275+ E0E2 20 5E 4D 4E                          DB " ","^","M","N","B"
 275+ E0E6 42
 276+ E0E7 3B 22 2C 2E                          DB ";",'"',",",".","^","v","[","]"  ; Extended keys register 0 semicolon, quote, comman, fullstop, up, down, left, right
 276+ E0EB 5E 76 5B 5D
 277+ E0EF 23 65 62 69                          DB "#","e","b","i","t","g","c","x"  ; Extended keys register 1 delete, edit, break, inv video, true video graph, caps, extend
 277+ E0F3 74 67 63 78
 278+ E0F7              ; mapping of a code to the lookup table Keyboard map. So if you are using an addr_Pressed you can then fetch from KeyboardMap the address in Keys
 279+ E0F7              ; for the raw key press status
 280+ E0F7              addr_Pressed_Front         equ KeyboardMap+c_Pressed_Front
 281+ E0F7              addr_Pressed_Aft           equ KeyboardMap+c_Pressed_Aft
 282+ E0F7              addr_Pressed_Left          equ KeyboardMap+c_Pressed_Left
 283+ E0F7              addr_Pressed_Right         equ KeyboardMap+c_Pressed_Right
 284+ E0F7              addr_Pressed_RollLeft      equ KeyboardMap+c_Pressed_RollLeft
 285+ E0F7              addr_Pressed_RollRight     equ KeyboardMap+c_Pressed_RollRight
 286+ E0F7              addr_Pressed_Dive          equ KeyboardMap+c_Pressed_Dive
 287+ E0F7              addr_Pressed_Climb         equ KeyboardMap+c_Pressed_Climb
 288+ E0F7              addr_Pressed_Accellerate   equ KeyboardMap+c_Pressed_Accellerate
 289+ E0F7              addr_Pressed_Decellerate   equ KeyboardMap+c_Pressed_Decellerate
 290+ E0F7              addr_Pressed_FireLaser     equ KeyboardMap+c_Pressed_FireLaser
 291+ E0F7              addr_Pressed_TargetMissle  equ KeyboardMap+c_Pressed_TargetMissle
 292+ E0F7              addr_Pressed_FireMissile   equ KeyboardMap+c_Pressed_FireMissile
 293+ E0F7              addr_Pressed_UnarmMissile  equ KeyboardMap+c_Pressed_UnarmMissile
 294+ E0F7              addr_Pressed_ECM           equ KeyboardMap+c_Pressed_ECM
 295+ E0F7              addr_Pressed_EnergyBomb    equ KeyboardMap+c_Pressed_EnergyBomb
 296+ E0F7              addr_Pressed_EscapePod     equ KeyboardMap+c_Pressed_EscapePod
 297+ E0F7              addr_Pressed_DockingComp   equ KeyboardMap+c_Pressed_DockingComp
 298+ E0F7              addr_Pressed_Hyperspace    equ KeyboardMap+c_Pressed_Hyperspace
 299+ E0F7              addr_Pressed_Distance      equ KeyboardMap+c_Pressed_Distance
 300+ E0F7              addr_Pressed_HomeCursor    equ KeyboardMap+c_Pressed_HomeCursor
 301+ E0F7              addr_Pressed_Launch        equ KeyboardMap+c_Pressed_Launch
 302+ E0F7              addr_Pressed_BuyCargo      equ KeyboardMap+c_Pressed_BuyCargo
 303+ E0F7              addr_Pressed_SellCargo     equ KeyboardMap+c_Pressed_SellCargo
 304+ E0F7              addr_Pressed_Equip         equ KeyboardMap+c_Pressed_Equip
 305+ E0F7              addr_Pressed_GalacticChrt  equ KeyboardMap+c_Pressed_GalacticChrt
 306+ E0F7              addr_Pressed_LocalChart    equ KeyboardMap+c_Pressed_LocalChart
 307+ E0F7              addr_Pressed_MarketPrices  equ KeyboardMap+c_Pressed_MarketPrices
 308+ E0F7              addr_Pressed_Status        equ KeyboardMap+c_Pressed_Status
 309+ E0F7              addr_Pressed_Inventory     equ KeyboardMap+c_Pressed_Inventory
 310+ E0F7              addr_Pressed_GameSkip      equ KeyboardMap+c_Pressed_GameSkip
 311+ E0F7              addr_Pressed_Save          equ KeyboardMap+c_Pressed_Save
 312+ E0F7              addr_Pressed_Freeze        equ KeyboardMap+c_Pressed_Freeze
 313+ E0F7              addr_Pressed_Resume        equ KeyboardMap+c_Pressed_Resume
 314+ E0F7              addr_Pressed_Recentre      equ KeyboardMap+c_Pressed_Recentre
 315+ E0F7              addr_Pressed_Quit          equ KeyboardMap+c_Pressed_Quit
 316+ E0F7              addr_Pressed_PlanetData    equ KeyboardMap+c_Pressed_PlanetData
 317+ E0F7              addr_Pressed_CursorUp      equ KeyboardMap+c_Pressed_CursorUp
 318+ E0F7              addr_Pressed_CursorDown    equ KeyboardMap+c_Pressed_CursorDown
 319+ E0F7              addr_Pressed_Find          equ KeyboardMap+c_Pressed_Find
 320+ E0F7              addr_Pressed_Warp          equ KeyboardMap+c_Pressed_Warp
 321+ E0F7
 322+ E0F7
 323+ E0F7              MIsKeyPressed:          MACRO   keyaddress, misstarget
 324+ E0F7 ~                                    MMUSelectKeyboard
 325+ E0F7 ~                                    ld      hl,(keyaddress)
 326+ E0F7 ~                                    ld      a,(hl)
 327+ E0F7 ~                                    JumpIfAIsZero   misstarget
 328+ E0F7                                      ENDM
 329+ E0F7
 330+ E0F7
 331+ E0F7 21 00 E0     init_keyboard:          ld		hl,Keys                         ; no key s are pressed by default
 332+ E0FA 11 37 00                             ld		de, c_KeyBoardLen               ;
 333+ E0FD 3E 00                                ld		a,0                             ;
 334+ E0FF CD 92 6A                             call	memfill_dma                     ;
 335+ E102 C9                                   ret                                     ;
 336+ E103
 337+ E103
 338+ E103
 339+ E103 DD 21 37 E0  scan_keyboard:          ld		ix,RawKeys                      ; hl = table of raw IO port readings
 340+ E107 21 41 E0                             ld		hl,KeyAddrTab                   ; de = table of IO ports to read
 341+ E10A 0E 08                                ld		c,8                             ; 8 ports to ready
 342+ E10C 11 00 E0                             ld      de,Keys                         ; ix = table of key states from raw read
 343+ E10F 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
 344+ E110 DB FE                                in		a,($FE)							; read port to a
 345+ E112 DD 77 00                             ld      (ix+0),a                        ; save raw scan
 346+ E115 DD 23                                inc     ix
 347+ E117 23                                   inc		hl                              ; and ready for next read
 348+ E118 06 05        .ProcessInputBits:      ld		b,5								; loop all bits (there are only 5 keys to a group)
 349+ E11A 1F           .ProcessBitsLoop:       rra                                     ; shit bit 0 into carry
 350+ E11B 30 08                                jr      nc,.SetKeyPressed               ; low bit means it was pressed
 351+ E11D FD 6F                                ld      iyl,a
 352+ E11F                                      ZeroA
 352+ E11F AF          >                        xor a
 353+ E120 C3 2D E1                             jp      .SetKey
 354+ E123 20 0B                                jr		nz,.SkipKeySet
 355+ E125 FD 6F        .SetKeyPressed:	        ld      iyl,a                           ; save current input byte
 356+ E127 1A                                   ld      a,(de)                          ; get current keystate
 357+ E128 FE 02                                cp      2
 358+ E12A 28 02                                jr      z,.AlreadyHeld
 359+ E12C 3C                                   inc     a                               ; and increment by 1 as its moved from previous state
 360+ E12D 12           .SetKey:                ld		(de),a				  	        ; save key Pressed state
 361+ E12E FD 7D        .AlreadyHeld:           ld      a,iyl                           ; and retrieve the current input byte
 362+ E130 13           .SkipKeySet:	        inc		de								; move to next key
 363+ E131 10 E7                                djnz	.ProcessBitsLoop				; Process all key group bits
 364+ E133 0D                                   dec     c                               ; thats one row of bits all processed
 365+ E134 20 D9                                jr      nz,.PortReadLoop				; Read next input port
 366+ E136              .ReadExtend0:           GetNextReg EXTENDED_KEYS_0_REGISTER
 366+ E136 01 3B 24    >            ld bc,$243B
 366+ E139 3E B0       >            ld a,EXTENDED_KEYS_0_REGISTER
 366+ E13B ED 79       >            out (c),a
 366+ E13D 04          >            inc b
 366+ E13E ED 78       >            in a,(c)
 367+ E140 32 3F E0                             ld      (RawKeys+8),a                   ; save to extended slot
 368+ E143 06 08                                ld      b,8
 369+ E145 21 28 E0                             ld      hl,Keys + VK_SEMI
 370+ E148 17           .ProcessExtend0:        rla                                     ; shift bits left into carry for extended keys
 371+ E149 30 04                                jr      nc,.SetExtend0KeyPressed
 372+ E14B              .Extend0NotPressed:     ZeroA
 372+ E14B AF          >                        xor a
 373+ E14C C3 55 E1                             jp      .SetExtend0Key
 374+ E14F 7E           .SetExtend0KeyPressed:  ld      a,(hl)
 375+ E150 FE 02                                cp      2
 376+ E152 28 02                                jr      z,.Extend0AlreadyHeld
 377+ E154 3C                                   inc     a
 378+ E155 77           .SetExtend0Key:         ld      (hl),a
 379+ E156 23           .Extend0AlreadyHeld:    inc     hl
 380+ E157 10 EF                                djnz    .ProcessExtend0
 381+ E159              .ReadExtend1:           GetNextReg EXTENDED_KEYS_1_REGISTER
 381+ E159 01 3B 24    >            ld bc,$243B
 381+ E15C 3E B1       >            ld a,EXTENDED_KEYS_1_REGISTER
 381+ E15E ED 79       >            out (c),a
 381+ E160 04          >            inc b
 381+ E161 ED 78       >            in a,(c)
 382+ E163 32 40 E0                             ld      (RawKeys+9),a                      ; save to extended slot
 383+ E166 06 08                                ld      b,8
 384+ E168 21 30 E0                             ld      hl,Keys + VK_DELETE
 385+ E16B 17           .ProcessExtend1:        rla                                     ; shift bits left into carry for extended keys
 386+ E16C 30 04                                jr      nc,.SetExtend1KeyPressed
 387+ E16E              .Extend1NotPressed:     ZeroA
 387+ E16E AF          >                        xor a
 388+ E16F C3 78 E1                             jp      .SetExtend1Key
 389+ E172 7E           .SetExtend1KeyPressed:  ld      a,(hl)
 390+ E173 FE 02                                cp      2
 391+ E175 28 02                                jr      z,.Extend1AlreadyHeld
 392+ E177 3C                                   inc     a
 393+ E178 77           .SetExtend1Key:         ld      (hl),a
 394+ E179 23           .Extend1AlreadyHeld:    inc     hl
 395+ E17A 10 EF                                djnz    .ProcessExtend1
 396+ E17C C9                                   ret
 397+ E17D
 398+ E17D
 399+ E17D
 400+ E17D              GetKeyStateAddressDE:   MACRO
 401+ E17D ~                                    ld      hl,KeyboardMap                  ; work our address to read from
 402+ E17D ~                                    add     hl,a
 403+ E17D ~                                    ld      e,(hl)
 404+ E17D ~                                    inc     hl
 405+ E17D ~                                    ld      d,(hl)                          ; now de = address in keypress list
 406+ E17D                                      ENDM
 407+ E17D
 408+ E17D              GetKeyStateAddressHL:   MACRO
 409+ E17D ~                                    ld      hl,KeyboardMap                  ; work our address to read from
 410+ E17D ~                                    add     hl,a
 411+ E17D ~                                    ld      a,(hl)
 412+ E17D ~                                    inc     hl
 413+ E17D ~                                    ld      h,(hl)                          ; now hl = address in keypress list
 414+ E17D ~                                    ld      l,a
 415+ E17D                                      ENDM
 416+ E17D
 417+ E17D
 418+ E17D              ;;old debug codeCurrentX            DB 0
 419+ E17D              ;;old debug codeCurrentY            DB 0
 420+ E17D              ;;old debug code
 421+ E17D              ;;old debug codedisplayKeyStatus:       xor         a
 422+ E17D              ;;old debug code                        ld          (CurrentX),a
 423+ E17D              ;;old debug code                        ld          hl,RawKeys
 424+ E17D              ;;old debug code                        ld          a,(hl)
 425+ E17D              ;;old debug code                        and         %00011111
 426+ E17D              ;;old debug code                        ld          b,5
 427+ E17D              ;;old debug code.displayLoop:           push        bc,,hl
 428+ E17D              ;;old debug code                        rra
 429+ E17D              ;;old debug code                        jr          c,.displayNoPress
 430+ E17D              ;;old debug code.displayPress:          push        af
 431+ E17D              ;;old debug code                        ld          a,(CurrentX)
 432+ E17D              ;;old debug code                        ld          e,a
 433+ E17D              ;;old debug code                        ld          a,(CurrentY)
 434+ E17D              ;;old debug code                        ld          d,a
 435+ E17D              ;;old debug code                        ld          a,'*'
 436+ E17D              ;;old debug code                        MMUSelectLayer1
 437+ E17D              ;;old debug code                        call        l1_print_char
 438+ E17D              ;;old debug code                        ld          a,(CurrentX)
 439+ E17D              ;;old debug code                        add         a,8
 440+ E17D              ;;old debug code                        ld          (CurrentX),a
 441+ E17D              ;;old debug code                        pop         af
 442+ E17D              ;;old debug code                        pop         bc,,hl
 443+ E17D              ;;old debug code                        djnz        .displayLoop
 444+ E17D              ;;old debug code                        ret
 445+ E17D              ;;old debug code.displayNoPress:        push        af
 446+ E17D              ;;old debug code                        ld          a,(CurrentX)
 447+ E17D              ;;old debug code                        ld          e,a
 448+ E17D              ;;old debug code                        ld          a,(CurrentY)
 449+ E17D              ;;old debug code                        ld          d,a
 450+ E17D              ;;old debug code                        ld          a,'O'
 451+ E17D              ;;old debug code                        MMUSelectLayer1
 452+ E17D              ;;old debug code                        call        l1_print_char
 453+ E17D              ;;old debug code                        ld          a,(CurrentX)
 454+ E17D              ;;old debug code                        add         a,8
 455+ E17D              ;;old debug code                        ld          (CurrentX),a
 456+ E17D              ;;old debug code                        pop         af
 457+ E17D              ;;old debug code                        pop         bc,,hl
 458+ E17D              ;;old debug code                        djnz        .displayLoop
 459+ E17D              ;;old debug code                        ret
 460+ E17D              ;;old debug code
 461+ E17D              ;;old debug codedisplayDownStatus:      ld  a,(Keys+      KeyCode_CursorUp)
 462+ E17D              ;;old debug code                        cp  0
 463+ E17D              ;;old debug code                        jr      z,.displayNoUp
 464+ E17D              ;;old debug code                        cp  1
 465+ E17D              ;;old debug code                        jr      z,.displayUp
 466+ E17D              ;;old debug code.displayHeld:           ld      de,8*15
 467+ E17D              ;;old debug code                        ld      a,"*"
 468+ E17D              ;;old debug code                        MMUSelectLayer1
 469+ E17D              ;;old debug code                        call        l1_print_char
 470+ E17D              ;;old debug code                        ret
 471+ E17D              ;;old debug code.displayUp:             ld      de,8*15
 472+ E17D              ;;old debug code                        ld      a,"+"
 473+ E17D              ;;old debug code                        MMUSelectLayer1
 474+ E17D              ;;old debug code                        call        l1_print_char
 475+ E17D              ;;old debug code                        ret
 476+ E17D              ;;old debug code.displayNoUp:             ld      de,8*15
 477+ E17D              ;;old debug code                        ld      a,"O"
 478+ E17D              ;;old debug code                        MMUSelectLayer1
 479+ E17D              ;;old debug code                        call        l1_print_char
 480+ E17D              ;;old debug code                        ret
 481+ E17D              ;;old debug code
 482+ E17D
 483+ E17D
 484+ E17D              ; call with a = c_Pressed key, will then read mapping does this with keyboard scan, waits until key gets to state 1, if it was already held then#
 485+ E17D              ; it will have to be let go to reset of 0 and scan again
 486+ E17D              ; Deprecated as not used as yet
 487+ E17D              ;;;;;;wait_for_key_a_press:   GetKeyStateAddressHL
 488+ E17D              ;;;;;;                        push    hl
 489+ E17D              ;;;;;;.wait_loop:             call    scan_keyboard
 490+ E17D              ;;;;;;                        pop     hl                              ; get key address into hl
 491+ E17D              ;;;;;;                        push    hl
 492+ E17D              ;;;;;;                        ld      a,(hl)
 493+ E17D              ;;;;;;                        JumpIfANENusng  1,.wait_loop             ; will also loop if held down when entering this routine
 494+ E17D              ;;;;;;                        pop     hl                              ; tidy up rogue push, less t states than detecting if we want to push or not
 495+ E17D              ;;;;;;                        ret
 496+ E17D              ;;;;;;; call with a = c_Pressed key, will then read mapping does this with keyboard scan waits until key gets to state 2
 497+ E17D              ;;;;;;wait_for_key_a_held:    GetKeyStateAddressDE
 498+ E17D              ;;;;;;                        push    hl
 499+ E17D              ;;;;;;.wait_loop:             call    scan_keyboard
 500+ E17D              ;;;;;;                        pop     hl
 501+ E17D              ;;;;;;                        push    hl
 502+ E17D              ;;;;;;                        ld      a,(hl)
 503+ E17D              ;;;;;;                        JumpIfALTNusng  2, .wait_loop
 504+ E17D              ;;;;;;                        pop     hl
 505+ E17D              ;;;;;;                        ret
 506+ E17D
 507+ E17D              ; Gets the current keystate of the c_Pressed Key in a register
 508+ E17D 21 00 E0     get_vkey_a_state:       ld      hl,Keys
 509+ E180 ED 31                                add     hl,a
 510+ E182 7E                                   ld      a,(hl)
 511+ E183 C9                                   ret
 512+ E184
 513+ E184 21 00 E0     is_vkey_held:           ld      hl,Keys
 514+ E187 ED 31                                add     hl,a
 515+ E189 7E                                   ld      a,(hl)
 516+ E18A E6 02                                and     Bit1Only
 517+ E18C C9                                   ret
 518+ E18D
 519+ E18D 21 00 E0     is_vkey_pressed:        ld      hl,Keys
 520+ E190 ED 31                                add     hl,a
 521+ E192 7E                                   ld      a,(hl)
 522+ E193 FE 01                                cp      1
 523+ E195 C9                                   ret
 524+ E196
 525+ E196              get_key_a_state:        GetKeyStateAddressHL                    ; reads a mapped key and sets a to key staus, e.g. 0 1 or >=2 DOES NOT SCAN KEYBOARD
 525+ E196 21 49 E0    >                        ld      hl,KeyboardMap                  ; work our address to read from
 525+ E199 ED 31       >                        add     hl,a
 525+ E19B 7E          >                        ld      a,(hl)
 525+ E19C 23          >                        inc     hl
 525+ E19D 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 525+ E19E 6F          >                        ld      l,a
 526+ E19F 7E                                   ld      a,(hl)                          ; a = keystate
 527+ E1A0 C9                                   ret
 528+ E1A1
 529+ E1A1              ; sets they keystate of c pressed key in a register to 1 (pressed)
 530+ E1A1              ; This will be used by auto dock
 531+ E1A1              force_key_press:        GetKeyStateAddressHL                    ; read key locations
 531+ E1A1 21 49 E0    >                        ld      hl,KeyboardMap                  ; work our address to read from
 531+ E1A4 ED 31       >                        add     hl,a
 531+ E1A6 7E          >                        ld      a,(hl)
 531+ E1A7 23          >                        inc     hl
 531+ E1A8 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 531+ E1A9 6F          >                        ld      l,a
 532+ E1AA 3E 01                                ld      a,1
 533+ E1AC 77                                   ld      (hl),a
 534+ E1AD C9                                   ret
 535+ E1AE
 536+ E1AE              is_key_up_state:        GetKeyStateAddressHL
 536+ E1AE 21 49 E0    >                        ld      hl,KeyboardMap                  ; work our address to read from
 536+ E1B1 ED 31       >                        add     hl,a
 536+ E1B3 7E          >                        ld      a,(hl)
 536+ E1B4 23          >                        inc     hl
 536+ E1B5 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 536+ E1B6 6F          >                        ld      l,a
 537+ E1B7 7E                                   ld      a,(hl)
 538+ E1B8 FE 00                                cp      0
 539+ E1BA C9                                   ret
 540+ E1BB
 541+ E1BB              ; returns z is set if c_ key is pressed
 542+ E1BB              is_key_pressed:         GetKeyStateAddressHL
 542+ E1BB 21 49 E0    >                        ld      hl,KeyboardMap                  ; work our address to read from
 542+ E1BE ED 31       >                        add     hl,a
 542+ E1C0 7E          >                        ld      a,(hl)
 542+ E1C1 23          >                        inc     hl
 542+ E1C2 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 542+ E1C3 6F          >                        ld      l,a
 543+ E1C4 7E                                   ld      a,(hl)                          ; a = keystate
 544+ E1C5 FE 01                                cp      1                               ; we cant just test bit 0 as this may have been held long
 545+ E1C7 C9                                   ret
 546+ E1C8
 547+ E1C8              ; returns nz is set if c_ key is held, if key was held then keystate would be 2 or 3, i.e. bit 1 set
 548+ E1C8              is_key_held:            GetKeyStateAddressHL
 548+ E1C8 21 49 E0    >                        ld      hl,KeyboardMap                  ; work our address to read from
 548+ E1CB ED 31       >                        add     hl,a
 548+ E1CD 7E          >                        ld      a,(hl)
 548+ E1CE 23          >                        inc     hl
 548+ E1CF 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 548+ E1D0 6F          >                        ld      l,a
 549+ E1D1 7E                                   ld      a,(hl)                          ; a = keystate
 550+ E1D2 E6 02                                and     Bit1Only                        ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
 551+ E1D4 C9                                   ret
 552+ E1D5
 553+ E1D5              ; checks to see if any key is pressed in the key table
 554+ E1D5 21 00 E0     is_any_key_pressed:     ld      hl,Keys
 555+ E1D8 01 28 00                             ld      bc,40
 556+ E1DB 3E 01                                ld      a,1
 557+ E1DD ED B1                                cpir                                    ; search for the value 1
 558+ E1DF 28 03                                jr      z,.KeyPressed                   ; if a key was pressed then handle press
 559+ E1E1                                      SetAFalse
 559+ E1E1 3E FF       >                        ld      a,$FF
 560+ E1E3 C9                                   ret
 561+ E1E4 3E 27        .KeyPressed:            ld      a,39                            ; so c will be how many keys still to scan
 562+ E1E6 91                                   sub     c                               ; so a = 40 - c to get to result
 563+ E1E7 C9                                   ret
 564+ E1E8
 565+ E1E8 21 00 E0     is_any_key_held:        ld      hl,Keys
 566+ E1EB 06 28                                ld      b,40
 567+ E1ED 0E 00                                ld      c,0
 568+ E1EF 7E           .KeyReadLoop:           ld      a,(hl)
 569+ E1F0 E6 02                                and     Bit1Only                        ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
 570+ E1F2 C2 FC E1                             jp      nz,.KeyPressed
 571+ E1F5 23                                   inc     hl
 572+ E1F6 0C                                   inc     c
 573+ E1F7 10 F6                                djnz    .KeyReadLoop
 574+ E1F9                                      SetAFalse
 574+ E1F9 3E FF       >                        ld      a,$FF
 575+ E1FB C9                                   ret
 576+ E1FC 79           .KeyPressed:            ld      a,c
 577+ E1FD C9                                   ret
 578+ E1FE
 579+ E1FE
 580+ E1FE 21 41 E0     WaitForNoKey:           ld      hl,KeyAddrTab                   ; de = table of IO ports to read
 581+ E201 06 08                                ld		b,8                             ; 8 ports to ready
 582+ E203 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
 583+ E204 DB FE                                in		a,($FE)							; read port to a
 584+ E206 E6 1F                                and     %00011111
 585+ E208 FE 1F                                cp      %00011111
 586+ E20A 20 F2                                jr      nz ,WaitForNoKey
 587+ E20C 23                                   inc		hl                              ; and ready for next read
 588+ E20D 10 F4                                djnz    .PortReadLoop
 589+ E20F C9                                   ret
 590+ E210
 591+ E210 F5 D5 C5 E5  WaitForAnyKey:          push    af,,de,,bc,,hl
 592+ E214 CD FE E1                             call    WaitForNoKey
 593+ E217 21 41 E0     .waitKeyLoop:           ld		hl,KeyAddrTab                   ; de = table of IO ports to read
 594+ E21A 06 08                                ld		b,8                             ; 8 ports to ready
 595+ E21C 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
 596+ E21D DB FE                                in		a,($FE)							; read port to a
 597+ E21F E6 1F                                and     %00011111
 598+ E221 FE 1F                                cp      %00011111
 599+ E223 C2 2D E2                             jp      nz,.WaitComplete
 600+ E226 C0                                   ret     nz
 601+ E227 23                                   inc		hl                              ; and ready for next read
 602+ E228 10 F2                                djnz    .PortReadLoop
 603+ E22A C3 17 E2                             jp      .waitKeyLoop
 604+ E22D E1 C1 D1 F1  .WaitComplete:          pop     af,,de,,bc,,hl
 605+ E231 C9                                   ret
 606+ E232
 607+ E232
 608+ E232 00 00 00...  InputString             DS  30              ; used for a 30 character input buffer
 609+ E250 00                                   DB  0               ; end of string marker as a safety
 610+ E251 00           InputLength             DB  0               ; Current String length
 611+ E252 00           InputCursor             DB  0               ; Current Cursor Position
 612+ E253 00           EnterPressed            DB  0               ; zero notpressed FF pressed
 613+ E254 00           InputChanged            DB  0
 614+ E255 00           InsertMode              DB  0
 615+ E256              InputLimit              EQU 20
 616+ E256
 617+ E256 21 32 E2     keyboard_copy_input_to_de:  ld      hl,InputString
 618+ E259 3A 52 E2                                 ld      a,(InputCursor)
 619+ E25C FE 00                                    cp      0
 620+ E25E 28 05                                    jr      z,.NoString
 621+ E260 4F                                       ld      c,a
 622+ E261 06 00                                    ld      b,0
 623+ E263 ED B0                                    ldir
 624+ E265 3E 00        .NoString                   ld      a,0
 625+ E267 12                                       ld      (de),a
 626+ E268 C9                                       ret
 627+ E269
 628+ E269               ;Input routine logic
 629+ E269               ;Intialise input state
 630+ E269
 631+ E269              ; Scans the key pressed to determine if its an alpha, returns ascii code or 0 if not alpha
 632+ E269              ; Input a = key pressed, returns with carry set if no alpha else carry is clear
 633+ E269              isKeyAlpha:             JumpIfALTNusng  "A",   .NotAlpha
 633+ E269 FE 41       >                        cp      "A"
 633+ E26B DA 75 E2    >                        jp		c, .NotAlpha
 634+ E26E                                      JumpIfAGTENusng "Z"+1, .NotAlpha
 634+ E26E FE 5B       >                        cp     "Z"+1
 634+ E270 D2 75 E2    >                        jp		nc,.NotAlpha
 635+ E273                                      ClearCarryFlag
 635+ E273 B7          >                        or a
 636+ E274 C9                                   ret
 637+ E275              .NotAlpha               SetCarryFlag
 637+ E275 37          >                        scf
 638+ E276 C9                                   ret
 639+ E277
 640+ E277 3A 52 E2     InsertKeystroke:        ld      a,(InputCursor)                         ; Current Cursor position
 641+ E27A FE 1E                                cp      30                                      ; protect from buffer overflow
 642+ E27C C8                                   ret     z                                       ; .
 643+ E27D 21 32 E2                             ld      hl,InputString                          ; position hl to position in input string
 644+ E280 ED 31                                add     hl,a                                    ; .
 645+ E282 E5                                   push    hl                                      ; save current cursor position
 646+ E283 47                                   ld      b,a                                     ; as a quick optimisation
 647+ E284                                      JumpIfMemFalse InsertMode, .NoCopyNeeded        ; if we are in overtype mode skip copy
 647+ E284 3A 55 E2    >                        ld      a,(InsertMode)
 647+ E287 A7          >                        and     a
 647+ E288 C2 A8 E2    >                        jp      nz, .NoCopyNeeded
 648+ E28B 3A 51 E2                             ld      a,(InputLength)                         ; no need to shuffle string
 649+ E28E B8                                   cp      b                                       ; if we are at the end already
 650+ E28F 78                                   ld      a,b                                     ; .
 651+ E290 CA A8 E2                             jp      z,.NoCopyNeeded                         ; so we can behave like overtype mode
 652+ E293 11 4F E2                             ld      de,InputString+29                       ; now from the end of the string
 653+ E296 21 4E E2                             ld      hl,InputString+28                       ; .
 654+ E299 06 1D                                ld      b,29                                    ; for up to 29 characters
 655+ E29B 4F                                   ld      c,a                                     ; back to the current cursor position
 656+ E29C C5           .CopyLoop:              push    bc                                      ; save current position
 657+ E29D 7E                                   ld      a,(hl)                                  ; now suffle from left char to right char
 658+ E29E 12                                   ld      (de),a                                  ; .
 659+ E29F 2B                                   dec     hl                                      ; moving back one byte at a time
 660+ E2A0 1B                                   dec     de                                      ;
 661+ E2A1 05                                   dec     b                                       ; and reducing the current copy position
 662+ E2A2 79                                   ld      a,c                                     ; have we reached the input cursor pos
 663+ E2A3 B8                                   cp      b                                       ;
 664+ E2A4 C1                                   pop     bc
 665+ E2A5 C2 9C E2                             jp      nz,.CopyLoop
 666+ E2A8 E1           .NoCopyNeeded:          pop     hl
 667+ E2A9 3A B4 E2                             ld      a,(LastKeyPressed)
 668+ E2AC 77                                   ld      (hl),a
 669+ E2AD 21 51 E2                             ld      hl,InputLength
 670+ E2B0 34                                   inc     (hl)
 671+ E2B1 23                                   inc     hl                                      ;  to input cursor as a short cut to logic
 672+ E2B2 34                                   inc     (hl)
 673+ E2B3 C9                                   ret
 674+ E2B4
 675+ E2B4
 676+ E2B4              ; We won't have any auto repeat on input
 677+ E2B4 00           LastKeyPressed:         db 0
 678+ E2B5
 679+ E2B5              initInputText:          ZeroA
 679+ E2B5 AF          >                        xor a
 680+ E2B6 32 52 E2                             ld      (InputCursor),a
 681+ E2B9 32 B4 E2                             ld      (LastKeyPressed),a
 682+ E2BC 32 51 E2                             ld      (InputLength),a
 683+ E2BF                                      SetMemTrue  InsertMode
 683+ E2BF AF          >                        xor     a
 683+ E2C0 32 55 E2    >                        ld      (InsertMode),a
 684+ E2C3                                      SetMemFalse EnterPressed
 684+ E2C3 3E FF       >                        ld      a,$FF
 684+ E2C5 32 53 E2    >                        ld      (EnterPressed),a
 685+ E2C8                                      SetMemFalse InputChanged
 685+ E2C8 3E FF       >                        ld      a,$FF
 685+ E2CA 32 54 E2    >                        ld      (InputChanged),a
 686+ E2CD 21 32 E2                             ld      hl,InputString
 687+ E2D0 06 1E                                ld      b,30
 688+ E2D2 77           .wipeloop:              ld      (hl),a
 689+ E2D3 23                                   inc     hl
 690+ E2D4 10 FC                                djnz    .wipeloop
 691+ E2D6 C9                                   ret
 692+ E2D7
 693+ E2D7              ;;;InputNameV2:            call    is_any_key_pressed              ; scan for key states
 694+ E2D7              ;;;                        cp      $FF                             ; no key means we reset auto repeat
 695+ E2D7              ;;;                        jp      z,.NoKeyPressed                 ;
 696+ E2D7              ;;;.IsItLastKeyHeld:       ld      hl,LastKeyPressed               ; is it the same key as before
 697+ E2D7              ;;;                        cp      (hl)                            ;
 698+ E2D7              ;;;                        ret     z                               ; if so just ignore it to avoid auto repeat
 699+ E2D7              ;;;.SetNewAntiRepeat:      ld      (LastKeyPressed),a
 700+ E2D7              ;;;.CheckKeyPressed:       call    isKeyAlpha
 701+ E2D7              ;;;                        jp      nc,.AlphaKeyPressed
 702+ E2D7              ;;;.CheckSpaceKeyPressed:  cp      " "
 703+ E2D7              ;;;                        jp      z,.SpacePressed
 704+ E2D7              ;;;.CheckEnterPressed:     cp      ">"
 705+ E2D7              ;;;                        jp      z,.EnterPressed
 706+ E2D7              ;;;.CheckLeftPressed:      cp      "["
 707+ E2D7              ;;;                        jp      z,.LeftPressed
 708+ E2D7              ;;;.CheckRightPressed:     cp      "]"
 709+ E2D7              ;;;                        jp      z,.RightPressed
 710+ E2D7              ;;;.CheckDeletePressed:    cp      "#"
 711+ E2D7              ;;;                        jp      z,.DeletePressed
 712+ E2D7              ;;;.AnyOtherKeyIsIgnored:  ret
 713+ E2D7              ;;;.AlphaKeyPressed:       ld      a,(InputLength)
 714+ E2D7              ;;;                        JumpIfAGTENusng 30,.MaxInputReached
 715+ E2D7              ;;;.InsertKey:             call    InsertKeystroke
 716+ E2D7              ;;;                        ret
 717+ E2D7              ;;;.SpacePressed:          call    InsertKeystroke
 718+ E2D7              ;;;                        ret
 719+ E2D7              ;;;.EnterPressed:
 720+ E2D7              ;;;
 721+ E2D7              ;;;.LeftPressed:           ld      a,(InputCusor)
 722+ E2D7              ;;;                        JumpIfAIsZero, .MaxInputReached
 723+ E2D7              ;;;                        dec     a
 724+ E2D7              ;;;                        ld      (InputCursor),a
 725+ E2D7              ;;;                        ret
 726+ E2D7              ;;;.RightPressed:          ld      a,(InputLength)
 727+ E2D7              ;;;                        inc     a
 728+ E2D7              ;;;                        ld      b,a
 729+ E2D7              ;;;                        ld      a,(InputCursor)
 730+ E2D7              ;;;                        JumpIfMemGTENusng b, .MaxInputReached
 731+ E2D7              ;;;                        inc     a
 732+ E2D7              ;;;                        ld      (InputCursor),a
 733+ E2D7              ;;;                        ret
 734+ E2D7              ;;;.DeletaPressed:         ld      a,(InputCusor)
 735+ E2D7              ;;;                        ld      c,a
 736+ E2D7              ;;;                        JumpIfAisZero, .MaxInputReached
 737+ E2D7              ;;;                        ld      a,(InputLength)
 738+ E2D7              ;;;                        JumpIfAisZero, .MaxInputReached
 739+ E2D7              ;;;                        ld      de,InputString
 740+ E2D7              ;;;                        ld      hl,de
 741+ E2D7              ;;;                        inc     hl
 742+ E2D7              ;;;                        ld      a,(InputLength)                 ; copy backwards
 743+ E2D7              ;;;                        dec     c                               ; for string length - curretn cursor
 744+ E2D7              ;;;                        ld      c,a
 745+ E2D7              ;;;                        ld      b,0
 746+ E2D7              ;;;                        ldir
 747+ E2D7              ;;;                        ret
 748+ E2D7              ;;;GOTTOHERE
 749+ E2D7
 750+ E2D7
 751+ E2D7
 752+ E2D7 C9           .MaxInputReached:       ret ; will add a beep later
 753+ E2D8
 754+ E2D8
 755+ E2D8
 756+ E2D8
 757+ E2D8              .NoKeyPressed:          ZeroA
 757+ E2D8 AF          >                        xor a
 758+ E2D9 32 B4 E2                             ld      (LastKeyPressed),a              ; Clear last key pressed
 759+ E2DC
 760+ E2DC
 761+ E2DC              InputName:              SetMemFalse InputChanged
 761+ E2DC 3E FF       >                        ld      a,$FF
 761+ E2DE 32 54 E2    >                        ld      (InputChanged),a
 762+ E2E1 CD D5 E1                             call    is_any_key_pressed
 763+ E2E4 FE FF                                cp      $FF
 764+ E2E6 C8                                   ret     z
 765+ E2E7 4F           .KeyPressed:            ld      c,a
 766+ E2E8 3A 52 E2                             ld      a,(InputCursor)                 ; No key so we can now look at if we are at the end of the buffer
 767+ E2EB FE 14                                cp      InputLimit                      ; move to variable later and then cp (hl)
 768+ E2ED 28 0B                                jr      z,.DeleteOrEnterOnly            ;
 769+ E2EF 21 BF E0                             ld      hl,ASCII_Map
 770+ E2F2 79                                   ld      a,c
 771+ E2F3 ED 31                                add     hl,a
 772+ E2F5 7E                                   ld      a,(hl)
 773+ E2F6 FE 41                                cp      "A"
 774+ E2F8 30 09                                jr      nc,.AlphaPressed
 775+ E2FA              ; CAPS and Symbol act as delete for now
 776+ E2FA FE 23        .DeleteOrEnterOnly      cp      "#"                             ; if space was  pressed (mapped to Hash in ASCII table))
 777+ E2FC 28 31                                jr      z,.SpacePressed                 ; for now we will ignore the shift and just assume delete
 778+ E2FE FE 3E                                cp      ">"         ; ENTER
 779+ E300 28 17                                jr      z,.EnterPressed
 780+ E302 C9                                   ret
 781+ E303 47           .AlphaPressed:          ld      b,a
 782+ E304 3A 52 E2                             ld      a,(InputCursor)
 783+ E307 4F                                   ld      c,a
 784+ E308 21 32 E2                             ld      hl,InputString
 785+ E30B ED 31                                add     hl,a
 786+ E30D 78                                   ld      a,b
 787+ E30E 70                                   ld      (hl),b
 788+ E30F 79                                   ld      a,c
 789+ E310 21 52 E2                             ld      hl,InputCursor
 790+ E313 34                                   inc     (hl)
 791+ E314                                      SetMemTrue InputChanged
 791+ E314 AF          >                        xor     a
 791+ E315 32 54 E2    >                        ld      (InputChanged),a
 792+ E318 C9                                   ret
 793+ E319 3A 52 E2     .EnterPressed:          ld      a,(InputCursor)
 794+ E31C 21 32 E2                             ld      hl,InputString
 795+ E31F ED 31                                add     hl,a
 796+ E321                                      ZeroA
 796+ E321 AF          >                        xor a
 797+ E322 77                                   ld      (hl),a
 798+ E323                                      SetMemTrue EnterPressed
 798+ E323 AF          >                        xor     a
 798+ E324 32 53 E2    >                        ld      (EnterPressed),a
 799+ E327                                      SetMemTrue InputChanged
 799+ E327 AF          >                        xor     a
 799+ E328 32 54 E2    >                        ld      (InputChanged),a
 800+ E32B CD F7 E0                             call    init_keyboard           ; Flush keyboard status so futher inputs don't auto read the enter key as a second press
 801+ E32E C9                                   ret
 802+ E32F 3A 52 E2     .SpacePressed:          ld      a,(InputCursor)         ; Space = delete
 803+ E332 FE 00                                cp      0                       ; if input is zero length then can not delete
 804+ E334 C8                                   ret     z
 805+ E335 3D                                   dec     a                       ; move back one and update cursor pos
 806+ E336 32 52 E2                             ld      (InputCursor),a         ;
 807+ E339 21 32 E2                             ld      hl,InputString          ; now update end of line to null
 808+ E33C ED 31                                add     hl,a                    ; .
 809+ E33E                                      ZeroA                           ; .
 809+ E33E AF          >                        xor a
 810+ E33F 77                                   ld      (hl),a                  ; .
 811+ E340                                      SetMemTrue InputChanged
 811+ E340 AF          >                        xor     a
 811+ E341 32 54 E2    >                        ld      (InputChanged),a
 812+ E344 C9                                   ret
 813+ E345
 814+ E345              TargetMissileTest:      AnyMissilesLeft
 814+ E345 3A C5 6C    >                        ld      a,(NbrMissiles)
 814+ E348 A7          >                        and     a
 815+ E349                                      JumpIfZero      .ClearTargetting
 815+ E349 CA 60 E3    >                        jp	z,.ClearTargetting
 816+ E34C                                      IsMissileLaunchFlagged                      ; if we are comitted to launch
 816+ E34C 3A B8 6E    >                        ld      a,(MissileTargettingFlag)
 816+ E34F E6 80       >                        and     $80
 817+ E351 C8                                   ret             z                           ; then don't scan as it will be cleared on launch
 818+ E352 3E 16        .ScanForKey:            ld              a,c_Pressed_TargetMissle    ; if not pressed we are done
 819+ E354 CD BB E1                             call            is_key_pressed              ; .
 820+ E357 C0                                   ret             nz                          ; .
 821+ E358 3A B8 6E     .TargetPressed:         ld              a,(MissileTargettingFlag)   ; get flag back
 822+ E35B                                      JumpIfAEqNusng  StageMissileNotTargeting, .SetTargetting
 822+ E35B FE FF       >                        cp     StageMissileNotTargeting
 822+ E35D CA 66 E3    >                        jp      z,.SetTargetting
 823+ E360              .ClearTargetting:       ClearMissileTargetting
 823+ E360 3E FF       >                        ld      a,StageMissileNotTargeting
 823+ E362 32 B8 6E    >                        ld      (MissileTargettingFlag),a
 824+ E365 C9                                   ret
 825+ E366              .SetTargetting:         SetMissileTargetting
 825+ E366 3E FE       >                        ld      a,StageMissileTargeting
 825+ E368 32 B8 6E    >                        ld      (MissileTargettingFlag),a
 826+ E36B C9                                   ret
 827+ E36C
 828+ E36C AF           MovementKeyTest:        xor     a
 829+ E36D 32 21 6E                             ld      (CursorKeysPressed),a
 830+ E370 3A 23 6C                             ld      a,(MenuIdMax)
 831+ E373 E6 FC                                and     $FC
 832+ E375 20 26                                jr      nz,CursorKeys
 833+ E377 2A 57 E0     ClimbDiveKeys:          ld      hl,(addr_Pressed_Climb)                 ; Check for Climb
 834+ E37A 7E                                   ld      a,(hl)
 835+ E37B                                      JumpIfAIsZero ScanDiveKey
 835+ E37B A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 835+ E37C CA 8A E3    >                        jp	    z, ScanDiveKey
 836+ E37F 3A 21 6E                             ld      a,(CursorKeysPressed)
 837+ E382 F6 80                                or      CursorClimb
 838+ E384 32 21 6E                             ld      (CursorKeysPressed),a
 839+ E387 C3 C0 E3                             jp      ScanLeftKey
 840+ E38A 2A 55 E0     ScanDiveKey:            ld      hl,(addr_Pressed_Dive)                  ; Check for Dive
 841+ E38D 7E                                   ld      a,(hl)
 842+ E38E                                      JumpIfAIsZero ScanLeftKey
 842+ E38E A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 842+ E38F CA C0 E3    >                        jp	    z, ScanLeftKey
 843+ E392 3A 21 6E                             ld      a,(CursorKeysPressed)
 844+ E395 F6 40                                or      CursorDive
 845+ E397 32 21 6E                             ld      (CursorKeysPressed),a
 846+ E39A C3 C0 E3                             jp      ScanLeftKey
 847+ E39D 2A 93 E0     CursorKeys:             ld      hl,(addr_Pressed_CursorUp)              ; Check cursor keys
 848+ E3A0 7E                                   ld      a,(hl)
 849+ E3A1                                      JumpIfAIsZero ScanCursorDownKey
 849+ E3A1 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 849+ E3A2 CA B0 E3    >                        jp	    z, ScanCursorDownKey
 850+ E3A5 3A 21 6E                             ld      a,(CursorKeysPressed)
 851+ E3A8 F6 80                                or      CursorClimb
 852+ E3AA 32 21 6E                             ld      (CursorKeysPressed),a
 853+ E3AD C3 C0 E3                             jp      ScanLeftKey
 854+ E3B0 2A 95 E0     ScanCursorDownKey:      ld      hl,(addr_Pressed_CursorDown)
 855+ E3B3 7E                                   ld      a,(hl)
 856+ E3B4                                      JumpIfAIsZero ScanLeftKey
 856+ E3B4 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 856+ E3B5 CA C0 E3    >                        jp	    z, ScanLeftKey
 857+ E3B8 3A 21 6E                             ld      a,(CursorKeysPressed)
 858+ E3BB F6 40                                or      CursorDive
 859+ E3BD 32 21 6E                             ld      (CursorKeysPressed),a
 860+ E3C0 2A 51 E0     ScanLeftKey:            ld      hl,(addr_Pressed_RollLeft)
 861+ E3C3 7E                                   ld      a,(hl)
 862+ E3C4                                      JumpIfAIsZero ScanRightKey
 862+ E3C4 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 862+ E3C5 CA D1 E3    >                        jp	    z, ScanRightKey
 863+ E3C8 3A 21 6E                             ld      a,(CursorKeysPressed)
 864+ E3CB F6 20                                or      CursorLeft
 865+ E3CD 32 21 6E                             ld      (CursorKeysPressed),a
 866+ E3D0 C9                                   ret
 867+ E3D1 2A 53 E0     ScanRightKey:           ld      hl,(addr_Pressed_RollRight)
 868+ E3D4 7E                                   ld      a,(hl)
 869+ E3D5                                      JumpIfAIsZero ScanHomeKey
 869+ E3D5 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 869+ E3D6 CA E2 E3    >                        jp	    z, ScanHomeKey
 870+ E3D9 3A 21 6E                             ld      a,(CursorKeysPressed)
 871+ E3DC F6 10                                or      CursorRight
 872+ E3DE 32 21 6E                             ld      (CursorKeysPressed),a
 873+ E3E1 C9                                   ret
 874+ E3E2 2A 71 E0     ScanHomeKey:            ld      hl,(addr_Pressed_HomeCursor)
 875+ E3E5 7E                                   ld      a,(hl)
 876+ E3E6                                      JumpIfAIsZero ScanRecentreKey
 876+ E3E6 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 876+ E3E7 CA F3 E3    >                        jp	    z, ScanRecentreKey
 877+ E3EA 3A 21 6E                             ld      a,(CursorKeysPressed)
 878+ E3ED F6 08                                or      CursorHome
 879+ E3EF 32 21 6E                             ld      (CursorKeysPressed),a
 880+ E3F2 C9                                   ret
 881+ E3F3 2A 8D E0     ScanRecentreKey:        ld      hl,(addr_Pressed_Recentre)
 882+ E3F6 7E                                   ld      a,(hl)
 883+ E3F7                                      ReturnIfAIsZero
 883+ E3F7 A7          >                        and     a
 883+ E3F8 C8          >                        ret     z
 884+ E3F9 3A 21 6E                             ld      a,(CursorKeysPressed)
 885+ E3FC F6 04                                or      CursorRecenter
 886+ E3FE 32 21 6E                             ld      (CursorKeysPressed),a
 887+ E401 C9                                   ret
 888+ E402
 889+ E402
# file closed: ../../Hardware/keyboard.asm
1403  E402                                  DISPLAY "Keyboard ",BankKeyboard," - Bytes free ",/D, $2000 - ($-KeyboardAddr), " - BankKeyboard"
1404  E402                                  ASSERT $-KeyboardAddr <8912, Bank code leaks over 8K boundary
1405  E402               ; Bank 102  -----------------------------------------------------------------------------------------------------------------------
1406  E402                                  SLOT    MathsBankedFnsAddr
1407  E402                                  PAGE    BankMathsBankedFns
1408  E402                                  ORG     MathsBankedFnsAddr,BankMathsBankedFns
1409  0000                                  INCLUDE "../../Maths/MathsBankedFns.asm"
# file opened: ../../Maths/MathsBankedFns.asm
   1+ 0000              ;------------------------------------------------------------
   2+ 0000              ; HL Signed = HL - DE
   3+ 0000 7A           SubDEfromHLSigned:      ld      a,d
   4+ 0001 EE 80                                xor     $80
   5+ 0003 57                                   ld      d,a
   6+ 0004              ;------------------------------------------------------------
   7+ 0004              ; Adds DE to HL, in form S15 result will also be S15 rather than 2's C
   8+ 0004 7C           AddDEtoHLSigned:        ld      a,h                         ; extract h sign to b
   9+ 0005 E6 80                                and     $80                         ; hl = abs (hl)
  10+ 0007 47                                   ld      b,a
  11+ 0008 7C                                   ld      a,h
  12+ 0009 E6 7F                                and     $7F
  13+ 000B 67                                   ld      h,a
  14+ 000C 7A                                   ld      a,d                         ; extract d sign to c
  15+ 000D E6 80                                and     $80                         ; de = abs (de)
  16+ 000F 4F                                   ld      c,a
  17+ 0010 7A                                   ld      a,d
  18+ 0011 E6 7F                                and     $7F
  19+ 0013 57                                   ld      d,a
  20+ 0014 78                                   ld      a,b
  21+ 0015 A9                                   xor     c
  22+ 0016 C2 1E 00                             jp      nz,.OppositeSigns
  23+ 0019 19           .SameSigns              add     hl,de                       ; same signs so just add
  24+ 001A 78                                   ld      a,b                         ; and bring in the sign from b
  25+ 001B B4                                   or      h                           ; note this has to be 15 bit result
  26+ 001C 67                                   ld      h,a                         ; but we can assume that
  27+ 001D C9                                   ret
  28+ 001E              .OppositeSigns:         ClearCarryFlag
  28+ 001E B7          >                        or a
  29+ 001F ED 52                                sbc     hl,de
  30+ 0021 38 04                                jr      c,.OppsiteSignInvert
  31+ 0023 78           .OppositeSignNoInvert:  ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
  32+ 0024 B4                                   or      h
  33+ 0025 67                                   ld      h,a                         ; set the previou sign value
  34+ 0026 C9                                   ret
  35+ 0027              .OppsiteSignInvert:     NegHL                              ; we need to flip the sign and 2'c the Hl result
  35+ 0027 AF          >                    xor a
  35+ 0028 95          >                    sub l
  35+ 0029 6F          >                    ld l,a
  35+ 002A 9F          >                    sbc a,a
  35+ 002B 94          >                    sub h
  35+ 002C 67          >                    ld h,a
  36+ 002D 78                                   ld      a,b
  37+ 002E EE 80                                xor     SignOnly8Bit               ; flip sign bit
  38+ 0030 B4                                   or      h
  39+ 0031 67                                   ld      h,a                         ; recover sign
  40+ 0032 C9                                   ret
  41+ 0033
  42+ 0033              ;------------------------------------------------------------
  43+ 0033              ; AHL = BHL+CDE where signs are held in B and C
  44+ 0033 78           ADDHLDESignBC:          ld      a,b
  45+ 0034 E6 80                                and     SignOnly8Bit
  46+ 0036 A9                                   xor     c                           ;if b sign and c sign were different then bit 7 of a will be 1 which means
  47+ 0037                                      JumpIfNegative .ADDHLDEsBCOppSGN     ;Signs are opposite there fore we can subtract to get difference
  47+ 0037 FA 45 00    >                        jp		m, .ADDHLDEsBCOppSGN
  48+ 003A 78           .ADDHLDEsBCSameSigns:   ld      a,b
  49+ 003B B1                                   or      c
  50+ 003C                                      JumpIfNegative .ADDHLDEsBCSameNeg    ; optimisation so we can just do simple add if both positive
  50+ 003C FA 41 00    >                        jp		m, .ADDHLDEsBCSameNeg
  51+ 003F 19                                   add     hl,de                       ; both positive so a will already be zero
  52+ 0040 C9                                   ret
  53+ 0041 19           .ADDHLDEsBCSameNeg:      add     hl,de
  54+ 0042 78                                   ld      a,b
  55+ 0043                                      DISPLAY "TODO: don't bother with overflow for now"
  56+ 0043 B1                                   or      c                           ; now set bit for negative value, we won't bother with overflow for now TODO
  57+ 0044 C9                                   ret
  58+ 0045              .ADDHLDEsBCOppSGN:      ClearCarryFlag
  58+ 0045 B7          >                        or a
  59+ 0046 ED 52                                sbc     hl,de
  60+ 0048 38 02                                jr      c,.ADDHLDEsBCOppInvert
  61+ 004A 78           .ADDHLDEsBCOppSGNNoCarry:ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
  62+ 004B C9                                   ret
  63+ 004C              .ADDHLDEsBCOppInvert:   NegHL                               ; if result was zero then set sign to zero (which doing h or l will give us for free)
  63+ 004C AF          >                    xor a
  63+ 004D 95          >                    sub l
  63+ 004E 6F          >                    ld l,a
  63+ 004F 9F          >                    sbc a,a
  63+ 0050 94          >                    sub h
  63+ 0051 67          >                    ld h,a
  64+ 0052 78                                   ld      a,b
  65+ 0053 EE 80                                xor     SignOnly8Bit                ; flip sign bit
  66+ 0055 C9                                   ret
  67+ 0056                  DISPLAY "TODO: Check if ADDHLDESignedV4 is deprecated by AddDEtoHLSigned"
  68+ 0056 7C           ADDHLDESignedV4:        ld      a,h
  69+ 0057 E6 80                                and     SignOnly8Bit
  70+ 0059 47                                   ld      b,a                         ;save sign bit in b
  71+ 005A AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
  72+ 005B                                      JumpIfNegative .ADDHLDEOppSGN       ;Signs are opposite there fore we can subtract to get difference
  72+ 005B FA 73 00    >                        jp		m, .ADDHLDEOppSGN
  73+ 005E 78           .ADDHLDESameSigns:      ld      a,b
  74+ 005F B2                                   or      d
  75+ 0060                                      JumpIfNegative .ADDHLDESameNeg      ; optimisation so we can just do simple add if both positive
  75+ 0060 FA 65 00    >                        jp		m, .ADDHLDESameNeg
  76+ 0063 19                                   add     hl,de
  77+ 0064 C9                                   ret
  78+ 0065 7C           .ADDHLDESameNeg:        ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
  79+ 0066 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
  80+ 0068 67                                   ld      h,a
  81+ 0069 7A                                   ld      a,d
  82+ 006A E6 7F                                and     SignMask8Bit
  83+ 006C 57                                   ld      d,a
  84+ 006D 19                                   add     hl,de
  85+ 006E 3E 80                                ld      a,SignOnly8Bit
  86+ 0070                                      DISPLAY "TODO:  dont bother with overflow for now"
  87+ 0070 B4                                   or      h                           ; now set bit for negative value, we won't bother with overflow for now TODO
  88+ 0071 67                                   ld      h,a
  89+ 0072 C9                                   ret
  90+ 0073 7C           .ADDHLDEOppSGN:         ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit                     ; here HL and DE are opposite
  91+ 0074 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
  92+ 0076 67                                   ld      h,a
  93+ 0077 7A                                   ld      a,d
  94+ 0078 E6 7F                                and     SignMask8Bit
  95+ 007A 57                                   ld      d,a
  96+ 007B                                      ClearCarryFlag
  96+ 007B B7          >                        or a
  97+ 007C ED 52                                sbc     hl,de
  98+ 007E 38 04                                jr      c,.ADDHLDEOppInvert
  99+ 0080 78           .ADDHLDEOppSGNNoCarry:  ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
 100+ 0081 B4                                   or      h
 101+ 0082 67                                   ld      h,a                         ; set the previou sign value
 102+ 0083 C9                                   ret
 103+ 0084              .ADDHLDEOppInvert:      NegHL                                                   ; we need to flip the sign and 2'c the Hl result
 103+ 0084 AF          >                    xor a
 103+ 0085 95          >                    sub l
 103+ 0086 6F          >                    ld l,a
 103+ 0087 9F          >                    sbc a,a
 103+ 0088 94          >                    sub h
 103+ 0089 67          >                    ld h,a
 104+ 008A 78                                   ld      a,b
 105+ 008B EE 80                                xor     SignOnly8Bit                ; flip sign bit
 106+ 008D B4                                   or      h
 107+ 008E 67                                   ld      h,a                         ; recover sign
 108+ 008F C9                                   ret
 109+ 0090
 110+ 0090              ;------------------------------------------------------------
 111+ 0090              ; extension to AddBCHtoDELsigned
 112+ 0090              ; takes ix as the address of the values to load into DEL
 113+ 0090              ;       iy as the address of the values to load into BCH
 114+ 0090 DD 6E 00     AddAtIXtoAtIY24Signed:  ld      l,(ix+0)            ; del = ix (sign hi lo)
 115+ 0093 DD 5E 01                             ld      e,(ix+1)            ; .
 116+ 0096 DD 56 02                             ld      d,(ix+2)            ; .
 117+ 0099 FD 66 00                             ld      h,(iy+0)            ; bch = iy (sign, hi, lo)
 118+ 009C FD 4E 01                             ld      c,(iy+1)            ; .
 119+ 009F FD 46 02                             ld      b,(iy+2)            ; .
 120+ 00A2 FD E5                                push    iy                  ; save iy as add function changes is
 121+ 00A4 CD 14 01                             call    AddBCHtoDELsigned   ; Perform del += bch
 122+ 00A7 FD E1                                pop     iy                  ; get iy back
 123+ 00A9 DD 75 00                             ld      (ix+0),l            ; put result into (ix)
 124+ 00AC DD 73 01                             ld      (ix+1),e            ; .
 125+ 00AF DD 72 02                             ld      (ix+2),d            ; .
 126+ 00B2 C9                                   ret
 127+ 00B3              ;------------------------------------------------------------
 128+ 00B3              ; DEL = @IX + @IY 24 bit signed
 129+ 00B3              AddDELequAtIXPlusIY24Signed:
 130+ 00B3 DD 6E 00                             ld      l,(ix+0)            ; del = ix (sign hi lo)
 131+ 00B6 DD 5E 01                             ld      e,(ix+1)            ; .
 132+ 00B9 DD 56 02                             ld      d,(ix+2)            ; .
 133+ 00BC FD 66 00                             ld      h,(iy+0)            ; bch = iy (sign, hi, lo)
 134+ 00BF FD 4E 01                             ld      c,(iy+1)            ; .
 135+ 00C2 FD 46 02                             ld      b,(iy+2)            ; .
 136+ 00C5 FD E5                                push    iy                  ; save iy as add function changes is
 137+ 00C7 CD 14 01                             call    AddBCHtoDELsigned   ; Perform del += bch
 138+ 00CA FD E1                                pop     iy                  ; get iy back
 139+ 00CC C9                                   ret
 140+ 00CD              ;------------------------------------------------------------
 141+ 00CD              ; extension to AddBCHtoDELsigned
 142+ 00CD              ; takes ix as the address of the values to load into DEL
 143+ 00CD              ;       iy as the address of the values to load into BCH
 144+ 00CD              ; subtracts iy from ix putting result in ix
 145+ 00CD              ; DEL = @IX - @IY 24 bit signed
 146+ 00CD DD 6E 00     SubAtIXtoAtIY24Signed:  ld      l,(ix+0)            ; del = ix (sign hi lo)
 147+ 00D0 DD 5E 01                             ld      e,(ix+1)            ; .
 148+ 00D3 DD 56 02                             ld      d,(ix+2)            ; .
 149+ 00D6 FD 66 00                             ld      h,(iy+0)            ; bch = -iy (sign, hi, lo)
 150+ 00D9 FD 4E 01                             ld      c,(iy+1)            ; .
 151+ 00DC FD 7E 02                             ld      a,(iy+2)            ; .
 152+ 00DF EE 80                                xor     SignOnly8Bit        ; . this is where we flip sign to make add subtract
 153+ 00E1 47                                   ld      b,a                 ; .
 154+ 00E2 FD E5                                push    iy                  ; save iy as add function changes is
 155+ 00E4 CD 14 01                             call    AddBCHtoDELsigned   ; perform del += bch which as we flipped bch sign means (ix [210] -= iy [210])
 156+ 00E7 FD E1                                pop     iy                  ; get iy back
 157+ 00E9 DD 75 00                             ld      (ix+0),l            ; put result into (ix)
 158+ 00EC DD 73 01                             ld      (ix+1),e            ; .
 159+ 00EF DD 72 02                             ld      (ix+2),d            ; .
 160+ 00F2 C9                                   ret
 161+ 00F3              ;------------------------------------------------------------
 162+ 00F3              ; extension to AddBCHtoDELsigned
 163+ 00F3              ; takes ix as the address of the values to load into DEL
 164+ 00F3              ;       iy as the address of the values to load into BCH
 165+ 00F3              ; subtracts iy from ix leaving result in del
 166+ 00F3              SubDELequAtIXMinusAtIY24Signed:
 167+ 00F3 DD 6E 00                             ld      l,(ix+0)            ; del = ix (sign hi lo)
 168+ 00F6 DD 5E 01                             ld      e,(ix+1)            ; .
 169+ 00F9 DD 56 02                             ld      d,(ix+2)            ; .
 170+ 00FC FD 66 00                             ld      h,(iy+0)            ; bch = -iy (sign, hi, lo)
 171+ 00FF FD 4E 01                             ld      c,(iy+1)            ; .
 172+ 0102 FD 7E 02                             ld      a,(iy+2)            ; .
 173+ 0105 EE 80                                xor     SignOnly8Bit        ; . this is where we flip sign to make add subtract
 174+ 0107 47                                   ld      b,a                 ; .
 175+ 0108 FD E5                                push    iy                  ; save iy as add function changes is
 176+ 010A CD 14 01                             call    AddBCHtoDELsigned   ; perform del += bch which as we flipped bch sign means (ix [210] -= iy [210])
 177+ 010D FD E1                                pop     iy                  ; get iy back
 178+ 010F C9                                   ret
 179+ 0110              ;------------------------------------------------------------
 180+ 0110              ;tested mathstestsun2
 181+ 0110              ; DEL = DEL - BCH signed, uses BC, DE, HL, IY, A
 182+ 0110              ; Just flips sign on b then performs add
 183+ 0110 78           SubBCHfromDELsigned:    ld      a,b
 184+ 0111 EE 80                                xor     SignOnly8Bit
 185+ 0113 47                                   ld      b,a
 186+ 0114              ; DEL = DEL + BCH signed, uses BC, DE, HL, IY, A
 187+ 0114 78           AddBCHtoDELsigned:      ld      a,b                 ; Are the values both the same sign?
 188+ 0115 AA                                   xor     d                   ; .
 189+ 0116 E6 80                                and     SignOnly8Bit        ; .
 190+ 0118 20 19                                jr      nz,.SignDifferent   ; .
 191+ 011A 78           .SignSame:              ld      a,b                 ; if they are then we only need 1 signe
 192+ 011B E6 80                                and     SignOnly8Bit        ; so store it in iyh
 193+ 011D FD 67                                ld      iyh,a               ;
 194+ 011F 78                                   ld      a,b                 ; bch = abs bch
 195+ 0120 E6 7F                                and     SignMask8Bit        ; .
 196+ 0122 47                                   ld      b,a                 ; .
 197+ 0123 7A                                   ld      a,d                 ; del = abs del
 198+ 0124 E6 7F                                and     SignMask8Bit        ; .
 199+ 0126 57                                   ld      d,a                 ; .
 200+ 0127 7C                                   ld      a,h                 ; l = h + l
 201+ 0128 85                                   add     l                   ; .
 202+ 0129 6F                                   ld      l,a                 ; .
 203+ 012A 79                                   ld      a,c                 ; e = e + c + carry
 204+ 012B 8B                                   adc     e                   ; .
 205+ 012C 5F                                   ld      e,a                 ; .
 206+ 012D 78                                   ld      a,b                 ; d = b + d + carry (signed)
 207+ 012E 8A                                   adc     d                   ;
 208+ 012F FD B4                                or      iyh                 ; d = or back in sign bit
 209+ 0131 57                                   ld      d,a                 ;
 210+ 0132 C9                                   ret                         ; done
 211+ 0133 78           .SignDifferent:         ld      a,b                 ; bch = abs bch
 212+ 0134 FD 67                                ld      iyh,a               ; iyh = b sign
 213+ 0136 E6 7F                                and     SignMask8Bit        ; .
 214+ 0138 47                                   ld      b,a                 ; .
 215+ 0139 7A                                   ld      a,d                 ; del = abs del
 216+ 013A FD 6F                                ld      iyl,a               ; iyl = d sign
 217+ 013C E6 7F                                and     SignMask8Bit        ; .
 218+ 013E 57                                   ld      d,a                 ; .
 219+ 013F E5                                   push    hl                  ; save hl
 220+ 0140 60 69                                ld      hl,bc               ; hl = bc - de, if bc < de then there is a carry
 221+ 0142 ED 52                                sbc     hl,de               ;
 222+ 0144 E1                                   pop     hl                  ;
 223+ 0145 38 0E                                jr      c,.BCHltDEL
 224+ 0147 20 1C                                jr      nz,.DELltBCH        ; if the result was not zero then DEL > BCH
 225+ 0149 7C           .BCeqDE:                ld      a,h                 ; if the result was zero then check lowest bits
 226+ 014A                                      JumpIfALTNusng l,.BCHltDEL
 226+ 014A BD          >                        cp      l
 226+ 014B DA 55 01    >                        jp		c, .BCHltDEL
 227+ 014E 20 15                                jr      nz,.DELltBCH
 228+ 0150              ; The same so its just zero
 229+ 0150 AF           .BCHeqDEL:              xor     a                  ; its just zero
 230+ 0151 57                                   ld      d,a                ; .
 231+ 0152 5F                                   ld      e,a                ; .
 232+ 0153 6F                                   ld      l,a                ; .
 233+ 0154 C9                                   ret                        ; .
 234+ 0155              ;BCH is less than DEL so its DEL - BCH the sort out sign
 235+ 0155 7D           .BCHltDEL:              ld      a,l                ; l = l - h                      ; ex
 236+ 0156 94                                   sub     h                  ; .                              ;   01D70F DEL
 237+ 0157 6F                                   ld      l,a                ; .                              ;  -000028 BCH
 238+ 0158 7B                                   ld      a,e                ; e = e - c - carry              ;1.
 239+ 0159 99                                   sbc     c                  ; .                              ;
 240+ 015A 5F                                   ld      e,a                ; .                              ;
 241+ 015B 7A                                   ld      a,d                ; d = d - b - carry              ;
 242+ 015C 98                                   sbc     b                  ; .                              ;
 243+ 015D 57                                   ld      d,a                ; .                              ;
 244+ 015E FD 7D                                ld      a,iyl              ; as d was larger, take d sign
 245+ 0160 E6 80                                and     SignOnly8Bit       ;
 246+ 0162 B2                                   or      d                  ;
 247+ 0163 57                                   ld      d,a                ;
 248+ 0164 C9                                   ret
 249+ 0165 7C           .DELltBCH:              ld      a,h                ; l = h - l
 250+ 0166 95                                   sub     l                  ;
 251+ 0167 6F                                   ld      l,a                ;
 252+ 0168 79                                   ld      a,c                ; e = c - e - carry
 253+ 0169 9B                                   sbc     e                  ;
 254+ 016A 5F                                   ld      e,a                ;
 255+ 016B 78                                   ld      a,b                ; d = b - d - carry
 256+ 016C 9A                                   sbc     d                  ;
 257+ 016D 57                                   ld      d,a                ;
 258+ 016E FD 7C                                ld      a,iyh              ; as b was larger, take b sign into d
 259+ 0170 E6 80                                and     SignOnly8Bit       ;
 260+ 0172 B2                                   or      d                  ;
 261+ 0173 57                                   ld      d,a                ;
 262+ 0174 C9                                   ret
 263+ 0175              ;-----------------------------------------------------------------------------------------------------------
 264+ 0175              ; Subtract Functions
 265+ 0175              ;...subtract routines
 266+ 0175              ; we could cheat, flip the sign of DE and just add but its not very optimised
 267+ 0175 7C           subHLDES15:             ld      a,h
 268+ 0176 E6 80                                and     SignOnly8Bit
 269+ 0178 47                                   ld      b,a                         ;save sign bit in b
 270+ 0179 AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
 271+ 017A                                      JumpIfNegative .SUBHLDEOppSGN        ;Signs are opposite therefore we can add
 271+ 017A FA A8 01    >                        jp		m, .SUBHLDEOppSGN
 272+ 017D 78           .SUBHLDESameSigns:      ld      a,b
 273+ 017E B2                                   or      d
 274+ 017F                                      JumpIfNegative .SUBHLDESameNeg       ; optimisation so we can just do simple add if both positive
 274+ 017F FA 89 01    >                        jp		m, .SUBHLDESameNeg
 275+ 0182                                      ClearCarryFlag
 275+ 0182 B7          >                        or a
 276+ 0183 ED 52                                sbc     hl,de
 277+ 0185                                      JumpIfNegative .SUBHLDESameOvrFlw
 277+ 0185 FA 9C 01    >                        jp		m, .SUBHLDESameOvrFlw
 278+ 0188 C9                                   ret
 279+ 0189 7C           .SUBHLDESameNeg:        ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 280+ 018A E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 281+ 018C 67                                   ld      h,a
 282+ 018D 7A                                   ld      a,d
 283+ 018E E6 7F                                and     SignMask8Bit
 284+ 0190 57                                   ld      d,a
 285+ 0191                                      ClearCarryFlag
 285+ 0191 B7          >                        or a
 286+ 0192 ED 52                                sbc     hl,de
 287+ 0194                                      JumpIfNegative .SUBHLDESameOvrFlw
 287+ 0194 FA 9C 01    >                        jp		m, .SUBHLDESameOvrFlw
 288+ 0197                                                          DISPLAY "TODO:  don't bother with overflow for now"
 289+ 0197 7C                                   ld      a,h                         ; now set bit for negative value, we won't bother with overflow for now TODO
 290+ 0198 F6 80                                or      SignOnly8Bit
 291+ 019A 67                                   ld      h,a
 292+ 019B C9                                   ret
 293+ 019C              .SUBHLDESameOvrFlw:     NegHL
 293+ 019C AF          >                    xor a
 293+ 019D 95          >                    sub l
 293+ 019E 6F          >                    ld l,a
 293+ 019F 9F          >                    sbc a,a
 293+ 01A0 94          >                    sub h
 293+ 01A1 67          >                    ld h,a
 294+ 01A2 78                                   ld      a,b
 295+ 01A3 EE 80                                xor     SignOnly8Bit                ; flip sign bit
 296+ 01A5 B4                                   or      h
 297+ 01A6 67                                   ld      h,a                         ; recover sign
 298+ 01A7 C9                                   ret
 299+ 01A8 B7           .SUBHLDEOppSGN:         or      a
 300+ 01A9 7C                                   ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 301+ 01AA E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 302+ 01AC 67                                   ld      h,a
 303+ 01AD 7A                                   ld      a,d
 304+ 01AE E6 7F                                and     SignMask8Bit
 305+ 01B0 57                                   ld      d,a
 306+ 01B1 19                                   add     hl,de
 307+ 01B2 78                                   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
 308+ 01B3 B4                                   or      h
 309+ 01B4 67                                   ld      h,a                         ; set the previou sign value
 310+ 01B5 C9                                   ret
 311+ 01B6              ;------------------------------------------------------------------------------------------------
 312+ 01B6              ;-- checks to see if a postition is in range of another, e.g. missile hit
 313+ 01B6              ;-- ix = ship position    - pointer to xyz vector as 3 bytes per element
 314+ 01B6              ;-- oy = misisle position - pointer to xyz vector as 3 bytes per element
 315+ 01B6              ;-- sets carry if in blast range, else not carry
 316+ 01B6              ;-- blast range will always be an 8 bit value
 317+ 01B6              CheckInCollisionRange:
 318+ 01B6 CD F3 00     .CheckXDistance:        call    SubDELequAtIXMinusAtIY24Signed ; get distance between x coordinates
 319+ 01B9 7A                                   ld      a,d                 ; check abs distance
 320+ 01BA E6 7F                                and     SignMask8Bit        ; if high bytes are set
 321+ 01BC B3                                   or      e                   ; then no hit
 322+ 01BD C2 FC 01                             jp      nz,.NoCollision     ; if high bytes are set no collision
 323+ 01C0 7D                                   ld      a,l
 324+ 01C1                                      JumpIfAGTEMemusng  CurrentMissileBlastRange ,.NoCollision
 324+ 01C1 21 2C 6D    >                        ld      hl,CurrentMissileBlastRange
 324+ 01C4 BE          >                        cp      (hl)
 324+ 01C5 D2 FC 01    >                        jp		nc,.NoCollision
 325+ 01C8 01 03 00     .CheckYDistance:        ld      bc,3                ; move ix and iy
 326+ 01CB DD 09                                add     ix,bc               ; on 3 bytes
 327+ 01CD FD 09                                add     iy,bc               ;
 328+ 01CF CD F3 00                             call    SubDELequAtIXMinusAtIY24Signed ; get distance between x coordinates
 329+ 01D2 7A                                   ld      a,d                 ; check abs distance
 330+ 01D3 E6 7F                                and     SignMask8Bit        ; if high bytes are set
 331+ 01D5 B3                                   or      e                   ; then no hit
 332+ 01D6 C2 FC 01                             jp      nz,.NoCollision     ; if high bytes are set no collision
 333+ 01D9 7D                                   ld      a,l
 334+ 01DA                                      JumpIfAGTEMemusng  CurrentMissileBlastRange ,.NoCollision
 334+ 01DA 21 2C 6D    >                        ld      hl,CurrentMissileBlastRange
 334+ 01DD BE          >                        cp      (hl)
 334+ 01DE D2 FC 01    >                        jp		nc,.NoCollision
 335+ 01E1 01 03 00     .CheckZDistance:        ld      bc,3                ; move ix and iy
 336+ 01E4 DD 09                                add     ix,bc               ; on 3 bytes
 337+ 01E6 FD 09                                add     iy,bc               ;
 338+ 01E8 CD F3 00                             call    SubDELequAtIXMinusAtIY24Signed ; get distance between x coordinates
 339+ 01EB 7A                                   ld      a,d                 ; check abs distance
 340+ 01EC E6 7F                                and     SignMask8Bit        ; if high bytes are set
 341+ 01EE B3                                   or      e                   ; then no hit
 342+ 01EF C2 FC 01                             jp      nz,.NoCollision     ; if high bytes are set no collision
 343+ 01F2 7D                                   ld      a,l
 344+ 01F3                                      JumpIfAGTEMemusng  CurrentMissileBlastRange ,.NoCollision
 344+ 01F3 21 2C 6D    >                        ld      hl,CurrentMissileBlastRange
 344+ 01F6 BE          >                        cp      (hl)
 344+ 01F7 D2 FC 01    >                        jp		nc,.NoCollision
 345+ 01FA              .CollisionDetected:     SetCarryFlag                ; collision in blast range
 345+ 01FA 37          >                        scf
 346+ 01FB C9                                   ret
 347+ 01FC              .NoCollision:           ClearCarryFlag              ; no collision in blast range
 347+ 01FC B7          >                        or a
 348+ 01FD C9                                   ret
 349+ 01FE
 350+ 01FE              ;------------------------------------------------------------------------------------------------
 351+ 01FE              ; -- Checks if 24 bit value at ix > iy and returns ix pointing to the correct value
 352+ 01FE              ; -- Sets carryflag if a swap occured as part of the Jump If A LessThan check
 353+ 01FE FD 7E 02     CompareAtIXtoIYABS:     ld      a,(iy+2)
 354+ 0201 E6 7F        .CheckSignByte:         and     SignMask8Bit
 355+ 0203 47                                   ld      b,a
 356+ 0204 DD 7E 02                             ld      a,(ix+2)
 357+ 0207 E6 7F                                and     SignMask8Bit
 358+ 0209                                      JumpIfALTNusng b,.SwapIXIY
 358+ 0209 B8          >                        cp      b
 358+ 020A DA 22 02    >                        jp		c, .SwapIXIY
 359+ 020D DD 7E 01     .CheckHighByte:         ld      a,(ix+1)
 360+ 0210 FD BE 01                             cp      (iy+1)
 361+ 0213                                      JumpIfALTNusng b,.SwapIXIY
 361+ 0213 B8          >                        cp      b
 361+ 0214 DA 22 02    >                        jp		c, .SwapIXIY
 362+ 0217 DD 7E 00     .CheckLowByte:          ld      a,(ix+0)
 363+ 021A FD BE 00                             cp      (iy+0)
 364+ 021D                                      JumpIfALTNusng b,.SwapIXIY
 364+ 021D B8          >                        cp      b
 364+ 021E DA 22 02    >                        jp		c, .SwapIXIY
 365+ 0221 C9                                   ret
 366+ 0222 DD E5        .SwapIXIY               push    ix                  ; swap over ix and iy
 367+ 0224 FD E5                                push    iy                  ; this means that ix is always larger of two or ix if they are the same value
 368+ 0226 DD E1                                pop     ix                  ; iy is a smaller of the two values, or untouched in the same value
 369+ 0228 FD E1                                pop     iy                  ; Thsi means we can do a compare and pick which one we preferr after, carry says if swap occured if we need that
 370+ 022A C9                                   ret
 371+ 022B              ;------------------------------------------------------------------------------------------------
 372+ 022B              ; -- Manhattan distance
 373+ 022B              ; -- very quick distance calculation based on a cube
 374+ 022B              ; -- ix = pointer to vector of 3x3, iy = distance to check
 375+ 022B              ; simploy done by ABS (ix)
 376+ 022B              ; returns z if outside box, nz if inside box
 377+ 022B DD 6E 00     ManhattanDistanceIXIY:  ld      l,(ix+0)            ; del = abs ix (sign hi lo)
 378+ 022E DD 5E 01     .checkX:                ld      e,(ix+1)            ; .
 379+ 0231 DD 7E 02                             ld      a,(ix+2)            ; .
 380+ 0234 E6 7F                                and     SignMask8Bit        ;
 381+ 0236 57                                   ld      d,a                 ;
 382+ 0237 FD 66 00                             ld      h,(iy+0)            ; bch = distiance to check
 383+ 023A FD 4E 01                             ld      c,(iy+1)            ; .
 384+ 023D FD 7E 02                             ld      a,(iy+2)            ; .
 385+ 0240 EE 80                                xor     SignOnly8Bit        ; . this is where we flip sign to make add subtract
 386+ 0242 47                                   ld      b,a                 ; .
 387+ 0243 C5 E5                                push    bc,,hl              ; save this for 2nd and 3rd test
 388+ 0245 FD E5                                push    iy                  ; save iy as add function changes is
 389+ 0247 CD 14 01                             call    AddBCHtoDELsigned   ; perform del += bch which as we flipped bch sign means (ix [210] -= iy [210])
 390+ 024A FD E1                                pop     iy                  ; get iy back
 391+ 024C 7A                                   ld      a,d
 392+ 024D E6 80                                and     SignOnly8Bit
 393+ 024F CA 88 02                             jp      z,.ClearUp          ; so if its positive then outside boundary
 394+ 0252 E1 C1        .checkY:                pop     bc,,hl
 395+ 0254 C5 E5                                push    bc,,hl
 396+ 0256 DD 6E 03                             ld      l,(ix+3)            ; del = abs ix (sign hi lo)
 397+ 0259 DD 5E 04                             ld      e,(ix+4)            ; .
 398+ 025C DD 7E 05                             ld      a,(ix+5)            ; .
 399+ 025F E6 7F                                and     SignMask8Bit        ;
 400+ 0261 57                                   ld      d,a                 ;
 401+ 0262 FD E5                                push    iy                  ; save iy as add function changes is
 402+ 0264 CD 14 01                             call    AddBCHtoDELsigned   ; perform del += bch which as we flipped bch sign means (ix [210] -= iy [210])
 403+ 0267 FD E1                                pop     iy                  ; get iy back
 404+ 0269 7A                                   ld      a,d
 405+ 026A E6 80                                and     SignOnly8Bit
 406+ 026C CA 88 02                             jp      z,.ClearUp          ; so if its positive then outside boundary
 407+ 026F E1 C1        .checkZ:                pop     bc,,hl
 408+ 0271 DD 6E 06                             ld      l,(ix+6)            ; del = abs ix (sign hi lo)
 409+ 0274 DD 5E 07                             ld      e,(ix+7)            ; .
 410+ 0277 DD 7E 08                             ld      a,(ix+8)            ; .
 411+ 027A E6 7F                                and     SignMask8Bit        ;
 412+ 027C 57                                   ld      d,a                 ;
 413+ 027D FD E5                                push    iy                  ; save iy as add function changes is
 414+ 027F CD 14 01                             call    AddBCHtoDELsigned   ; perform del += bch which as we flipped bch sign means (ix [210] -= iy [210])
 415+ 0282 FD E1                                pop     iy                  ; get iy back
 416+ 0284 7A                                   ld      a,d
 417+ 0285 E6 80                                and     SignOnly8Bit
 418+ 0287 C9                                   ret
 419+ 0288 E1 C1        .ClearUp:               pop     bc,,hl
 420+ 028A C9                                   ret
 421+ 028B
 422+ 028B
 423+ 028B              ;------------------------------------------------------------
 424+ 028B              ; Note vectors are 2 byte lead sign, angle is 8 bit lead sign
 425+ 028B              ApplyMyAngleAToIXIY:    ;break
 426+ 028B F5                                   push    af                          ; save angle
 427+ 028C              ; Calculate Angle * vector /256, i.e take angle and mutiple by high byte of vector
 428+ 028C 5F           .processVector1:        ld      e,a                         ; e = angle
 429+ 028D DD 56 01                             ld      d,(ix+1)                    ; d = vector 1 / 256
 430+ 0290 CD AF 70                             call    mulDbyESigned               ; calcualte DE = Vector * angle /256
 431+ 0293 FD 6E 00 FD                          ld      hl,(iy+0)                   ; hl = vector 2
 431+ 0297 66 01
 432+ 0299 CD 00 00                             call    SubDEfromHLSigned           ; hl = vector 2 - (vector 1 * angle / 256)
 433+ 029C FD 75 00 FD                          ld      (iy+0),hl                   ; .
 433+ 02A0 74 01
 434+ 02A2 F1           .processVector2:        pop     af
 435+ 02A3 5F                                   ld      e,a                         ; e = angle
 436+ 02A4 FD 56 01                             ld      d,(iy+1)                    ; d = vector 2 / 256
 437+ 02A7 CD AF 70                             call    mulDbyESigned               ; de = vector 2 * angle /256
 438+ 02AA DD 6E 00 DD                          ld      hl,(ix+0)                   ; hl = vector 1
 438+ 02AE 66 01
 439+ 02B0 CD 04 00                             call    AddDEtoHLSigned             ; hl = hl + de
 440+ 02B3 DD 75 00 DD                          ld      (ix+0),hl                   ; .
 440+ 02B7 74 01
 441+ 02B9 C9                                   ret
 442+ 02BA              ;------------------------------------------------------------
 443+ 02BA              ; Applies Roll Alpha and Pitch Beta to vector at IX
 444+ 02BA              ApplyRollAndPitchToIX:
 445+ 02BA              ;-- y Vector = y - alpha * nosev_x_hi
 446+ 02BA DD 5E 01                             ld      e,(ix+1)                    ; e = X component hi
 447+ 02BD 3A 2F 6B                             ld      a,(ALPHA)                   ; alpha S7
 448+ 02C0 57                                   ld      d,a
 449+ 02C1 CD AF 70                             call    mulDbyESigned               ; d = X Vector * alpha / 256
 450+ 02C4 DD 6E 02                             ld      l,(ix+2)                    ; hl = Y Vector component
 451+ 02C7 DD 66 03                             ld      h,(ix+3)                    ;
 452+ 02CA CD 00 00                             call    SubDEfromHLSigned           ; hl = Y - (alpha * nosev x hi)
 453+ 02CD DD 75 02                             ld      (ix+2),l                    ; dont round Y up yet
 454+ 02D0 DD 74 03                             ld      (ix+3),h
 455+ 02D3              ;-- x Vector = x Vector + alpha * y_hi
 456+ 02D3 DD 5E 03                             ld      e,(ix+3)                    ; e = y component hi
 457+ 02D6 3A 2F 6B                             ld      a,(ALPHA)                   ; alpha S7
 458+ 02D9 57                                   ld      d,a
 459+ 02DA CD AF 70                             call    mulDbyESigned               ; d = y Vector * alpha / 256
 460+ 02DD DD 6E 00                             ld      l,(ix+0)                    ; hl = x Vector component
 461+ 02E0 DD 66 01                             ld      h,(ix+1)                    ;
 462+ 02E3 CD 04 00                             call    AddDEtoHLSigned             ; hl = x + (alpha * nosev x hi)
 463+ 02E6                                  IFDEF ROUND_ROLL_AND_PITCH
 464+ 02E6 ~                                    ld      l,0                         ; round up x
 465+ 02E6                                  ENDIF
 466+ 02E6 DD 75 00                             ld      (ix+0),l
 467+ 02E9 DD 74 01                             ld      (ix+1),h
 468+ 02EC              ;-- nosev_y = nosev_y - beta * nosev_z_hi
 469+ 02EC DD 5E 05                             ld      e,(ix+5)                    ; e = z component hi
 470+ 02EF 3A 22 6B                             ld      a,(BETA)                    ; beta S7
 471+ 02F2 57                                   ld      d,a
 472+ 02F3 CD AF 70                             call    mulDbyESigned               ; d = Z Vector * beta / 256
 473+ 02F6 DD 6E 02                             ld      l,(ix+2)                    ; hl = y Vector component
 474+ 02F9 DD 66 03                             ld      h,(ix+3)                    ;
 475+ 02FC CD 00 00                             call    SubDEfromHLSigned           ; hl = Y - (beta * nosev z hi)
 476+ 02FF                                  IFDEF ROUND_ROLL_AND_PITCH
 477+ 02FF ~                                    ld      l,0                         ; round up Y
 478+ 02FF                                  ENDIF
 479+ 02FF DD 75 02                             ld      (ix+2),l
 480+ 0302 DD 74 03                             ld      (ix+3),h
 481+ 0305              ;-- nosev_z = nosev_z + beta * nosev_y_hi
 482+ 0305 DD 5E 03                             ld      e,(ix+3)                    ; e = y component hi
 483+ 0308 3A 22 6B                             ld      a,(BETA)                    ; beta S7
 484+ 030B 57                                   ld      d,a
 485+ 030C CD AF 70                             call    mulDbyESigned               ; d = y Vector * beta / 256
 486+ 030F DD 6E 04                             ld      l,(ix+4)                    ; hl = z Vector component
 487+ 0312 DD 66 05                             ld      h,(ix+5)                    ;
 488+ 0315 CD 04 00                             call    AddDEtoHLSigned             ; hl = z + (beta * nosev z hi)
 489+ 0318                                  IFDEF ROUND_ROLL_AND_PITCH
 490+ 0318 ~                                    ld      l,0                         ; round up zwd
 491+ 0318                                  ENDIF
 492+ 0318 DD 75 04                             ld      (ix+4),l
 493+ 031B DD 74 05                             ld      (ix+5),h
 494+ 031E C9                                   ret
 495+ 031F              ;------------------------------------------------------------
 496+ 031F              ; Calculates the following:
 497+ 031F              ; loads UBnKTargetVector from UBnkPostion to IY as IY - position
 498+ 031F DD 21 20 C0  VectorUnivtoIY:     ld      ix,UBnKxlo                      ; target x = iy [x] - Univ XPos
 499+ 0323 CD F3 00                         call    SubDELequAtIXMinusAtIY24Signed  ; .
 500+ 0326 7D                               ld      a,l                             ; .
 501+ 0327 32 47 C0                         ld      (UBnKTargetXPos),a              ; .
 502+ 032A ED 53 48 C0                      ld      (UBnKTargetXPos+1),de           ; .
 503+ 032E DD 21 23 C0                      ld      ix,UBnKylo                      ; move to y component
 504+ 0332 01 03 00                         ld      bc,3                            ; .
 505+ 0335 FD 09                            add     iy,bc                           ; .
 506+ 0337 CD F3 00                         call    SubDELequAtIXMinusAtIY24Signed  ; target y = iy [y] - Univ YPos
 507+ 033A 7D                               ld      a,l                             ; .
 508+ 033B 32 4A C0                         ld      (UBnKTargetYPos),a              ; .
 509+ 033E ED 53 4B C0                      ld      (UBnKTargetYPos+1),de           ; .
 510+ 0342 DD 21 26 C0                      ld      ix,UBnKzlo                      ; move to y component
 511+ 0346 01 03 00                         ld      bc,3                            ; move to z component
 512+ 0349 FD 09                            add     iy,bc                           ; .
 513+ 034B CD F3 00                         call    SubDELequAtIXMinusAtIY24Signed  ; target z = iy [z] - Univ ZPos
 514+ 034E 7D                               ld      a,l                             ; .
 515+ 034F 32 4D C0                         ld      (UBnKTargetZPos),a              ; .
 516+ 0352 ED 53 4E C0                      ld      (UBnKTargetZPos+1),de           ; .
 517+ 0356 C9                               ret
 518+ 0357              ;------------------------------------------------------------
 519+ 0357              ; Takes the UBnKTarget position and works out if its ready for a docking routine or jump
 520+ 0357              ; returns carry flag if move to docking else leaves carry unset
 521+ 0357              UnivDistanceToTarget:DISPLAY "TODO : WRITE CODE FOR UnivDistanceToTarget"
 522+ 0357                                  ClearCarryFlag                              ; for now clear carry flag so its not at target
 522+ 0357 B7          >                        or a
 523+ 0358 C9                               ret
 524+ 0359              ;------------------------------------------------------------
 525+ 0359              ; Takes the UBnKTarget position and works out if its ready for a docking routine or jump
 526+ 0359
 527+ 0359
 528+ 0359                      IFNDEF  DEBUG_NO_TACTICS_CODE
 529+ 0359 ~
 530+ 0359 ~            TacticsVarResult        DW 0
 531+ 0359 ~            TacticsDotRoofv:        ld      hl,UBnkrotmatRoofvX
 532+ 0359 ~                                    jp      TacticsDotHL
 533+ 0359 ~
 534+ 0359 ~            TacticsDotSidev:        ld      hl,UBnkrotmatSidevX
 535+ 0359 ~                                    jp      TacticsDotHL
 536+ 0359 ~
 537+ 0359 ~            TacticsDotNosev:        call    CopyRotNoseToUBnKTacticsMat
 538+ 0359 ~            TacticsDotHL:           ld      hl,UBnKTacticsRotMatX; UBnkTransmatNosevX    ; ROTMATX HI
 539+ 0359 ~            .CalcXValue:            ld      a,(hl)                              ; DE = RotMatX & Vect X
 540+ 0359 ~                                    ld      e,a                                 ; .
 541+ 0359 ~                                    ld      a,(UBnKTargetVectorX)                  ; .
 542+ 0359 ~                                    ld      d,a                                 ; .
 543+ 0359 ~                                    mul                                         ; .
 544+ 0359 ~                                    ld      a,d                                 ; S = A = Hi (RotMatX & Vect X)
 545+ 0359 ~                                    ld      (varS),a                            ; .
 546+ 0359 ~                                    inc     hl                                  ; move to sign byte
 547+ 0359 ~            .CalcXSign:             ld      a,(UBnKTargetVectorX+2)                ; B  = A = Sign VecX xor sign RotMatX
 548+ 0359 ~                                    xor     (hl)                                ; .
 549+ 0359 ~                                    ld      b,a                                 ; .
 550+ 0359 ~            .MoveToY:               inc     hl                                  ; Move on to Y component
 551+ 0359 ~            .CalcYValue:            ld      a,(hl)                              ; D = 0, E = Hi (RotMatY & Vect Y)
 552+ 0359 ~                                    ld      e,a                                 ; .
 553+ 0359 ~                                    ld      a,(UBnKTargetVectorY)                  ; .
 554+ 0359 ~                                    ld      d,a                                 ; .
 555+ 0359 ~                                    mul     de                                  ; .
 556+ 0359 ~                                    ld      e,d                                 ; .
 557+ 0359 ~                                    ld      d,0                                 ; .
 558+ 0359 ~                                    inc     hl                                  ; move to sign byte
 559+ 0359 ~            .CalcYSign:             ld      a,(UBnKTargetVectorY+2)                ; c = sign of y_sign * sidev_y
 560+ 0359 ~                                    xor     (hl)                                ;
 561+ 0359 ~                                    ld      c,a                                 ;
 562+ 0359 ~            .MoveToZ:               inc     hl                                  ; Move on to Z component
 563+ 0359 ~            .AddXandY:              push    hl                                  ; but save HL as we need that
 564+ 0359 ~                                    ld      a,(varS)                            ; hl = Hi (RotMatX & Vect X) b= sign
 565+ 0359 ~                                    ld      h,0                                 ; de = Hi (RotMatY & Vect Y) c= sign
 566+ 0359 ~                                    ld      l,a                                 ;
 567+ 0359 ~                                    call    ADDHLDESignBC                       ; a(sign) hl = sum
 568+ 0359 ~                                    ld      b,a                                 ; b = sign of result
 569+ 0359 ~                                    ld      (TacticsVarResult),hl               ; save sub in TacticsVarResult
 570+ 0359 ~            .CalcZValue:            pop     hl                                  ; get back to the rotation mat z
 571+ 0359 ~                                    ld      a,(hl)                              ; D = 0, E = Hi (RotMatZ & Vect Z)
 572+ 0359 ~                                    ld      e,a                                 ; .
 573+ 0359 ~                                    ld      a,(UBnKTargetVectorZ)                  ; .
 574+ 0359 ~                                    ld      d,a                                 ; .
 575+ 0359 ~                                    mul     de                                  ; .
 576+ 0359 ~                                    ld      e,d                                 ; .
 577+ 0359 ~                                    ld      d,0                                 ; .
 578+ 0359 ~                                    inc     hl                                  ; move to sign byte
 579+ 0359 ~            .CalcZSign:             ld      a,(UBnKTargetVectorZ+2)
 580+ 0359 ~                                    xor     (hl)
 581+ 0359 ~                                    ld      c,a                                 ; Set C to the sign of z_sign * sidev_z
 582+ 0359 ~                                    ld      hl, (TacticsVarResult)              ; CHL = x + y, BDE = z products
 583+ 0359 ~                                    call    ADDHLDESignBC                       ; so AHL = X y z products
 584+ 0359 ~                                    ld      (varS),a                            ; for backwards compatibility
 585+ 0359 ~                                    ld      a,l                                  ; .
 586+ 0359 ~                                    ret
 587+ 0359 ~
 588+ 0359 ~            CopyRotSideToUBnKTacticsMat:ld      hl,UBnkrotmatSidevX+1
 589+ 0359 ~                                    jp      CopyRotmatToTacticsMat
 590+ 0359 ~
 591+ 0359 ~            CopyRotNoseToUBnKTacticsMat:ld      hl,UBnkrotmatNosevX+1
 592+ 0359 ~                                    jp      CopyRotmatToTacticsMat
 593+ 0359 ~
 594+ 0359 ~            CopyRotRoofToBnKTacticsMat:ld      hl,UBnkrotmatRoofvX+1
 595+ 0359 ~            ; Coy rotation matrix high byte to trans rot mat, strip off sign and separate to rotmat byte 2
 596+ 0359 ~            CopyRotmatToUBnKTacticsMat: ld      de,UBnKTacticsRotMatX
 597+ 0359 ~                                    ld      a,(hl)              ; matrix high byte of x
 598+ 0359 ~                                    ld      b,a
 599+ 0359 ~                                    and     SignMask8Bit
 600+ 0359 ~                                    ld      (de),a              ; set rot mat value
 601+ 0359 ~                                    inc     de
 602+ 0359 ~                                    ld      a,b
 603+ 0359 ~                                    and     SignOnly8Bit
 604+ 0359 ~                                    ld      (de),a              ; set rot mat sign
 605+ 0359 ~                                    inc     de                  ; move to next rot mat element
 606+ 0359 ~                                    inc     hl
 607+ 0359 ~                                    inc     hl                  ; matrix high byte of y
 608+ 0359 ~            .processYElement:       ld      a,(hl)              ; matrix high byte of y
 609+ 0359 ~                                    ld      b,a
 610+ 0359 ~                                    and     SignMask8Bit
 611+ 0359 ~                                    ld      (de),a              ; set rot mat value
 612+ 0359 ~                                    inc     de
 613+ 0359 ~                                    ld      a,b
 614+ 0359 ~                                    and     SignOnly8Bit
 615+ 0359 ~                                    ld      (de),a              ; set rot mat sign
 616+ 0359 ~                                    inc     de                  ; move to next rot mat element
 617+ 0359 ~                                    inc     hl
 618+ 0359 ~                                    inc     hl                  ; matrix high byte of z
 619+ 0359 ~            .ProcessZElement:       ld      a,(hl)              ; matrix high byte of z
 620+ 0359 ~                                    ld      b,a
 621+ 0359 ~                                    and     SignMask8Bit
 622+ 0359 ~                                    ld      (de),a              ; set rot mat value
 623+ 0359 ~                                    inc     de
 624+ 0359 ~                                    ld      a,b
 625+ 0359 ~                                    and     SignOnly8Bit
 626+ 0359 ~                                    ld      (de),a              ; set rot mat sign
 627+ 0359 ~                                    ret
 628+ 0359                      ENDIF
 629+ 0359
 630+ 0359
 631+ 0359
# file closed: ../../Maths/MathsBankedFns.asm
1410  0359                                  DISPLAY "Bank ",MathsBankedFnsAddr," - Bytes free ",/D, $2000 - ($-MathsBankedFnsAddr), " - BankMathsBankedAdd"
1411  0359                                  ASSERT $-MathsBankedFnsAddr <8912, Bank code leaks over 8K boundary
1412  0359
1413  0359                  SAVENEX OPEN "VecTest.nex", EliteNextStartup , TopOfStack
1414  0359                  SAVENEX CFG  0,0,0,1
1415  0359                  SAVENEX AUTO
1416  0359                  SAVENEX CLOSE
1417  0359                  DISPLAY "Main Non Banked Code End ", MainNonBankedCodeEnd , " Bytes free ", 0B000H - MainNonBankedCodeEnd
1418  0359                  ASSERT MainNonBankedCodeEnd < 0B000H, Program code leaks intot interrup vector table
1419  0359
# file closed: VecTest.asm
