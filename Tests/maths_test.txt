# file opened: maths_test.asm
  1   0000                                      DEVICE ZXSPECTRUMNEXT
  2   0000                                      DEFINE  DOUBLEBUFFER 1
  3   0000                                      CSPECTMAP  maths_test.map
  4   0000                                      OPT --zxnext=cspect --syntax=a --reversepop
  5   0000
  6   0000
  7   0000                                      INCLUDE "../Hardware/register_defines.asm"
# file opened: ../Hardware/register_defines.asm
  1+  0000              IO_LAYER2_PORT                          EQU $123B
  2+  0000              IO_EXT_BANK_PORT 			            EQU $DFFD ; 57341
  3+  0000              IO_BANK_PORT                            EQU $7FFD ; 32765
  4+  0000              REGISTER_NUMBER_PORT					EQU $243B
  5+  0000              REGISTER_VALUE_PORT						EQU $253B
  6+  0000              SPRITE_SLOT_PORT						EQU $303B ; port for sprite and pattern index
  7+  0000              SPRITE_INFO_PORT                        EQU $0057
  8+  0000              SPRITE_PATTERN_UPLOAD_PORT				EQU $005B
  9+  0000
 10+  0000              MACHINE_ID_REGISTER						EQU 0
 11+  0000              VERSION_REGISTER						EQU 1
 12+  0000              RESET_REGISTER		    				EQU 2
 13+  0000              MACHINE_TYPE_REGISTER					EQU 3
 14+  0000              PAGE_RAM_REGISTER						EQU 4
 15+  0000              PERIPHERAL_1_REGISTER					EQU 5
 16+  0000              PERIPHERAL_2_REGISTER					EQU 6
 17+  0000              TURBO_MODE_REGISTER						EQU 7
 18+  0000              PERIPHERAL_3_REGISTER					EQU 8
 19+  0000              ANTI_BRICK_SYSTEM_REGISTER				EQU 10
 20+  0000              LAYER2_RAM_PAGE_REGISTER				EQU 18
 21+  0000              LAYER2_RAM_SHADOW_REGISTER      		EQU 19
 22+  0000              TRANSPARENCY_COLOUR_REGISTER			EQU 20
 23+  0000              SPRITE_LAYERS_SYSTEM_REGISTER			EQU 21
 24+  0000              LAYER2_OFFSET_X_REGISTER				EQU 22
 25+  0000              LAYER2_OFFSET_Y_REGISTER				EQU 23
 26+  0000              CLIP_WINDOW_LAYER2_REGISTER				EQU 24
 27+  0000              CLIP_WINDOW_SPRITES_REGISTER			EQU 25
 28+  0000              CLIP_WINDOW_ULA_REGISTER				EQU 26
 29+  0000              CLIP_WINDOW_CONTROL_REGISTER			EQU 28
 30+  0000              ACTIVE_VIDEO_LINE_MSB_REGISTER			EQU 30
 31+  0000              ACTIVE_VIDEO_LINE_LSB_REGISTER			EQU 31
 32+  0000              LINE_INTERRUPT_CONTROL_REGISTER			EQU 34
 33+  0000              LINE_INTERRUPT_VALUE_LSB_REGISTER		EQU 35
 34+  0000              KEYMAP_HIGH_ADDRESS_REGISTER			EQU 40
 35+  0000              KEYMAP_LOW_ADDRESS_REGISTER				EQU 41
 36+  0000              KEYMAP_HIGH_DATA_REGISTER				EQU 42
 37+  0000              KEYMAP_LOW_DATA_REGISTER				EQU 43
 38+  0000              DAC_B_MIRROR_REGISTER                   EQU 44
 39+  0000              DAC_AB_MIRROR_REGISTER                  EQU 45
 40+  0000              DAC_C_MORROR_REGISTER                   EQU 46
 41+  0000              TILEMAP_OFFSET_XMSB_REGISTER            EQU 47
 42+  0000              TILEMAP_OFFSET_XLSB_REGISTER            EQU 48
 43+  0000              TILEMAP_OFFSET_YMSB_REGISTER            EQU 49
 44+  0000              LORES_OFFSET_X_REGISTER					EQU 50
 45+  0000              LORES_OFFSET_Y_REGISTER					EQU 51
 46+  0000              SPRITE_PORT_INDEX_REGISTER              EQU 52
 47+  0000              SPRITE_PORT_ATTR0_REGISTER              EQU 53
 48+  0000              SPRITE_PORT_ATTR1_REGISTER              EQU 54
 49+  0000              SPRITE_PORT_ATTR2_REGISTER              EQU 55
 50+  0000              SPRITE_PORT_ATTR3_REGISTER              EQU 56
 51+  0000              SPRITE_PORT_ATTR4_REGISTER              EQU 57
 52+  0000              PALETTE_INDEX_REGISTER					EQU 64
 53+  0000              PALETTE_VALUE_8BIT_REGISTER				EQU 65
 54+  0000              PALETTE_FORMAT_REGISTER					EQU 66
 55+  0000              PALETTE_CONTROL_REGISTER				EQU 67
 56+  0000              PALETTE_VALUE_9BIT_REGISTER				EQU 68
 57+  0000              MMU_SLOT_0_REGISTER						EQU 80
 58+  0000              MMU_SLOT_1_REGISTER						EQU 81
 59+  0000              MMU_SLOT_2_REGISTER						EQU 82
 60+  0000              MMU_SLOT_3_REGISTER						EQU 83
 61+  0000              MMU_SLOT_4_REGISTER						EQU 84
 62+  0000              MMU_SLOT_5_REGISTER						EQU 85
 63+  0000              MMU_SLOT_6_REGISTER						EQU 86
 64+  0000              MMU_SLOT_7_REGISTER						EQU 87
 65+  0000              COPPER_DATA_REGISTER					EQU 96
 66+  0000              COPPER_CONTROL_LOW_REGISTER				EQU 97
 67+  0000              COPPER_CONTROL_HIGH_REGISTER			EQU 98
 68+  0000              DISPLAY_CONTROL_1_REGISTER              EQU 105
 69+  0000              LAYER_2_CONTROL_REGISTER                EQU 112
 70+  0000              LAYER_2_X_OFFSET_MSB_REGISTER           EQU 113
 71+  0000              DEBUG_LEDS_REGISTER						EQU 255
 72+  0000
 73+  0000
 74+  0000              GetNextReg:	MACRO register
 75+  0000 ~                        push bc
 76+  0000 ~                            ld bc,$243B
 77+  0000 ~                                ld a,register
 78+  0000 ~                                out (c),a
 79+  0000 ~                                inc b
 80+  0000 ~                            in a,(c)
 81+  0000 ~                        pop bc
 82+  0000                          ENDM
 83+  0000
# file closed: ../Hardware/register_defines.asm
  8   0000                                      INCLUDE "../Hardware/L2ColourDefines.asm"
# file opened: ../Hardware/L2ColourDefines.asm
  1+  0000              L2ColourBLACK           EQU   0
  2+  0000              L2ColourRED_1           EQU 224                 ; RGB 255,  0,  0
  3+  0000              L2ColourRED_2           EQU 192                 ; RGB 218,  0,  0
  4+  0000              L2ColourRED_3           EQU 160                 ; RGB 182,  0,  0
  5+  0000              L2ColourRED_4           EQU 128                 ; RGB 145,  0,  0
  6+  0000              L2ColourRED_5           EQU  96                 ; RGB 109,  0,  0
  7+  0000              L2ColourRED_6           EQU  64                 ; RGB  72,  0,  0
  8+  0000              L2ColourRED_7           EQU  32                 ; RGB  36,  0,  0
  9+  0000              L2ColourYELLOW_1        EQU 252                 ; RGB 255,255,  0
 10+  0000              L2ColourYELLOW_2        EQU 216                 ; RGB 218,218,  0
 11+  0000              L2ColourYELLOW_3        EQU 180                 ; RGB 182,182,  0
 12+  0000              L2ColourYELLOW_4        EQU 144                 ; RGB 145,145,  0
 13+  0000              L2ColourYELLOW_5        EQU 108                 ; RGB 109.109,  0
 14+  0000              L2ColourYELLOW_6        EQU  72                 ; RGB  72, 72,  0
 15+  0000              L2ColourYELLOW_7        EQU  36                 ; RGB  36, 36,  0
 16+  0000              L2ColourGREEN_1		    EQU  28                 ; RGB   0,255,  0
 17+  0000              L2ColourGREEN_2		    EQU  24                 ; RGB   0,218,  0
 18+  0000              L2ColourGREEN_3		    EQU  16                 ; RGB   0,145,  0
 19+  0000              L2ColourGREEN_4         EQU  12                 ; RGB   0,109,  0
 20+  0000              L2ColourGREEN_5         EQU   8                 ; RGB   0, 72,  0
 21+  0000              L2ColourGREEN_6         EQU   4                 ; RGB   0, 36,  0
 22+  0000              L2ColourBLUE_1          EQU   3                 ; RGB 0,0,255
 23+  0000              L2ColourBLUE_2          EQU   2                 ; RGB 0,0,170
 24+  0000              L2ColourBLUE_3          EQU   1                 ; RGB 0,0,85
 25+  0000
 26+  0000
 27+  0000              L2ColourWHITE_1         EQU 255                 ; RGB 255,255,255
 28+  0000              L2ColourWHITE_2         EQU 146
 29+  0000              L2ColourGREY_1		    EQU L2ColourWHITE_2
 30+  0000              L2ColourGREY_2		    EQU 109
 31+  0000              L2ColourGREY_3		    EQU  73
 32+  0000              L2ColourGREY_4		    EQU  37
 33+  0000
 34+  0000              L2ColourGREEN_MB        EQU  29                 ;RGB 0,255,85
 35+  0000              L2ColourGREEN_MR        EQU 124                 ;RGB 109.255,0
 36+  0000              L2ColourCREAM_1         EQU 218                 ; RGB 218,218,170
 37+  0000              L2ColourCREAM_2         EQU 182                 ; RGB 182,182,170
 38+  0000              L2ColourCREAM_3         EQU 146                 ; RGB 145,145,170
 39+  0000
 40+  0000              L2ColourTRANSPARENT     EQU 227                 ; RGB 255,  0,255
 41+  0000              L2ColourMAGENTA_1       EQU 162                 ; RGB 182,  0,170
 42+  0000              L2ColourMAGENTA_2       EQU 130                 ; RGB 145,  0,170
 43+  0000              L2ColourMAGENTA_3       EQU  97                 ; RGB 109,  0, 85
 44+  0000              L2ColourMAGENTA_4       EQU  65                 ; RGB  72,  0, 85
 45+  0000              L2ColourORANGE_1        EQU 236                 ; RGB
 46+  0000              L2ColourORANGE_2        EQU 168                 ; RGB
 47+  0000              L2ColourORANGE_3        EQU  68                 ; RGB
 48+  0000              L2ColourCYAN_1          EQU  31                 ; RGB   0,255, 255
 49+  0000              L2ColourCYAN_2          EQU  18                 ; RGB
 50+  0000              L2ColourCYAN_3          EQU   9                 ; RGB
 51+  0000              L2ColourPURPLE_1        EQU 109                 ; RGB
 52+  0000              L2ColourPURPLE_2        EQU  66                 ; RGB
 53+  0000              L2ColourPURPLE_3        EQU  33                 ; RGB
 54+  0000              L2ColourPINK_1		    EQU 231                 ; RGB
 55+  0000              L2ColourPINK_2		    EQU 226                 ; RGB
 56+  0000              L2ColourPINK_3		    EQU 225                 ; RGB
 57+  0000              L2ColourPINK_4		    EQU 224                 ; RGB
 58+  0000
# file closed: ../Hardware/L2ColourDefines.asm
  9   0000                                      INCLUDE "../Layer2Graphics/layer2_defines.asm"
# file opened: ../Layer2Graphics/layer2_defines.asm
  1+  0000
  2+  0000
  3+  0000              LAYER2_SHIFTED_SCREEN_TOP  	 equ 0
  4+  0000              LAYER2_SHIFTED_SCREEN_MIDDLE equ $40
  5+  0000              LAYER2_SHIFTED_SCREEN_BOTTOM equ $80
  6+  0000
  7+  0000              ; note hi byte is not decoded on DMA port so can out OUTIR
  8+  0000              IO_DATAGEAR_DMA_PORT 		 equ 107
  9+  0000              IO_SPRITE_SLOT_PORT 		 equ 12347
 10+  0000              IO_SPRITE_PATTERN_PORT       equ 91
 11+  0000              IO_SPRITE_ATTRIBUTES_PORT    equ 87
 12+  0000
 13+  0000              LAYER2_VISIBLE_MASK 		equ $02
 14+  0000              ; DEBUG 0 for always write to primary 08 for double buffering
 15+  0000                  IFDEF DOUBLEBUFFER
 16+  0000              LAYER2_SHADOW_SCREEN_MASK 	equ $08
 17+  0000                  ELSE
 18+  0000 ~            LAYER2_SHADOW_SCREEN_MASK 	equ $00
 19+  0000                  ENDIF
 20+  0000              LAYER2_READ_ENABLE_MASK 	equ %00000100
 21+  0000              LAYER2_WRITE_ENABLE_MASK 	equ %00000001
 22+  0000              LAYER2_READ_WRITE_MASK      equ %00000101
 23+  0000              LAYER2_SCREEN_SECTION_MASK 	equ $03
 24+  0000              LAYER2_SCREEN_SECTION_SHIFT equ 6
 25+  0000
 26+  0000              LAYER2_DISABLE_MEM_WRITE    equ %11111110
 27+  0000              LAYER2_DISABLE_MEM_READ     equ %11111011
 28+  0000              LAYER2_DISABLE_MEM_ACCESS   equ %11111010
 29+  0000
 30+  0000              LAYER2_SCREEN_BANK1          equ 8
 31+  0000              LAYER2_SCREEN_BANK2          equ 9
 32+  0000              LAYER2_SCREEN_BANK3          equ 10
 33+  0000              LAYER2_SHADOW_BANK1          equ 11
 34+  0000              LAYER2_SHADOW_BANK2          equ 12
 35+  0000              LAYER2_SHADOW_BANK3          equ 13
 36+  0000
 37+  0000              SCREEN_HEIGHT 				 equ 192
 38+  0000              SCREEN_RAM_BASE				 equ $0000
 39+  0000              SCREEN_HOZ_MIN_PIX		     equ 10
 40+  0000
 41+  0000              SPRITES_VISIBLE_MASK         equ $01
 42+  0000              SPRITES_ON_BORDER_MASK       equ $02
 43+  0000              LAYER_PRIORITIES_MASK        equ $07
 44+  0000              LORES_MODE_MASK              equ $80
 45+  0000              LAYER_PRIORITIES_SHIFT       equ 2
 46+  0000
 47+  0000              LAYER_PRIORITIES_S_L_U 		equ 0
 48+  0000              LAYER_PRIORITIES_L_S_U 		equ 1
 49+  0000              LAYER_PRIORITIES_S_U_L  	equ 2
 50+  0000              LAYER_PRIORITIES_L_U_S 		equ 3
 51+  0000              LAYER_PRIORITIES_U_S_L 		equ 4
 52+  0000              LAYER_PRIORITIES_U_L_S 		equ 5
 53+  0000
 54+  0000              DMA_WRO_BLOCK_PORTA_A2B_XFR  equ $7D
 55+  0000              DMA_WRO_BLOCK_PORTA_B2A_XFR  equ $79
 56+  0000              DMA_WR1_P1FIXED_MEMORY       equ $24
 57+  0000              DMA_WR1_P1DEC_MEMORY         equ $04
 58+  0000              DMA_WR1_P1INC_MEMORY         equ $14
 59+  0000              DMA_WR2_P2FIXED_MEMORY       equ $20
 60+  0000              DMA_WR2_P2DEC_MEMORY         equ $00
 61+  0000              DMA_WR2_P2INC_MEMORY         equ $10
 62+  0000              DMA_WR4_CONT_MODE            equ $AD
 63+  0000              DMA_RESET                    equ $c3
 64+  0000              DMA_RESET_PORT_A_TIMING      equ $c7
 65+  0000              DMA_RESET_PORT_B_TIMING      equ $cb
 66+  0000              DMA_LOAD                     equ $cf
 67+  0000              DMA_CONTINUE                 equ $d3
 68+  0000              DMA_DISABLE_INTERUPTS        equ $af
 69+  0000              DMA_ENABLE_INTERUPTS         equ $ab
 70+  0000              DMA_RESET_DISABLE_INTERUPTS  equ $a3
 71+  0000              DMA_ENABLE_AFTER_RETI        equ $b7
 72+  0000              DMA_READ_STATUS_BYTE         equ $bf
 73+  0000              DMA_REINIT_STATUS_BYTE       equ $8b
 74+  0000              DMA_START_READ_SEQUENCE      equ $a7
 75+  0000              DMA_FORCE_READY              equ $b3
 76+  0000              DMA_STOP_AT_END			     equ $82
 77+  0000              DMA_DISABLE                  equ $83
 78+  0000              DMA_ENABLE                   equ $87
 79+  0000              DMA_WRITE_REGISTER_COMMAND   equ $bb
 80+  0000              DMA_BURST                    equ $cd
 81+  0000              DMA_CONTINUOUS               equ $ad
 82+  0000              ZXN_DMA_PORT                 equ $6b
 83+  0000
 84+  0000
 85+  0000              COLOUR_TRANSPARENT			 equ $E3
 86+  0000
 87+  0000
 88+  0000
 89+  0000
# file closed: ../Layer2Graphics/layer2_defines.asm
 10   0000                                      INCLUDE	"../Hardware/memory_bank_defines.asm"
# file opened: ../Hardware/memory_bank_defines.asm
  1+  0000
  2+  0000              membanksize			    equ	$1FFF
  3+  0000
  4+  0000              StartOfBank     	    equ $0000
  5+  0000
  6+  0000              membank0 			    equ $0000
  7+  0000              dmaCopySrcAddr		    equ	$0000
  8+  0000              MathsTablesAddr         equ $0000
  9+  0000              membank1 			    equ $2000
 10+  0000              membank2 			    equ $4000
 11+  0000              membank3 			    equ $6000
 12+  0000              membank4 			    equ $8000
 13+  0000              membank5 			    equ $a000
 14+  0000              membank6 			    equ $c000
 15+  0000              ScreenBank              equ $c000
 16+  0000              MenuGalChtAddr          equ $c000
 17+  0000              MenuEquipSAddr          equ $c000
 18+  0000              MenuInventAddr          equ $c000
 19+  0000              MenuMarketAddr          equ $c000
 20+  0000              DispMarketAddr          equ $c000
 21+  0000              MenuShrChtAddr          equ $c000
 22+  0000              MenuStatusAddr          equ $c000
 23+  0000              MenuSystemAddr          equ $c000
 24+  0000              ViewFrontAddr           equ $c000
 25+  0000              SunBankAddr             equ $c000
 26+  0000              PlanetBankAddr          equ $c000
 27+  0000              UniverseBankAddr	    equ $c000
 28+  0000              LaunchShipAddr          equ $c000
 29+  0000              membank7 			    equ $e000
 30+  0000              L1membankAddr   	    equ $e000
 31+  0000              L2membankAddr   	    equ $e000
 32+  0000              ShipModelsAddr	        equ $e000
 33+  0000              SpritemembankAddr       equ $e000
 34+  0000              ResetUniverseAddr       equ $e000
 35+  0000              StockTableAddr	        equ $e000
 36+  0000              CommanderAddr           equ $e000
 37+  0000              LAYER2Addr              equ $e000
 38+  0000              LAYER1Addr              equ $e000
 39+  0000              SPRITEAddr              equ $e000
 40+  0000              ConsoleImageAddr        equ $e000
 41+  0000              GalaxyDataAddr          equ $e000
 42+  0000
 43+  0000              EXSDOSMMU0              equ MMU_SLOT_0_REGISTER
 44+  0000              MathsTablesMMU          equ MMU_SLOT_0_REGISTER
 45+  0000              ShipReadMMU             equ MMU_SLOT_0_REGISTER
 46+  0000              DMACpySourceMMU		    equ	MMU_SLOT_0_REGISTER
 47+  0000              EXSDOSMMU1              equ MMU_SLOT_1_REGISTER
 48+  0000              SunMMU 		            equ MMU_SLOT_6_REGISTER
 49+  0000              PlanetMMU 		        equ MMU_SLOT_6_REGISTER
 50+  0000              UniverseMMU 		    equ MMU_SLOT_6_REGISTER
 51+  0000              ScreenBankMMU           equ MMU_SLOT_6_REGISTER
 52+  0000              MenuEquipSMMU           equ MMU_SLOT_6_REGISTER
 53+  0000              MenuShrChtMMU           equ MMU_SLOT_6_REGISTER
 54+  0000              MenuGalChtMMU           equ MMU_SLOT_6_REGISTER
 55+  0000              MenuInventMMU           equ MMU_SLOT_6_REGISTER
 56+  0000              MenuSystemMMU           equ MMU_SLOT_6_REGISTER
 57+  0000              MenuMarketMMU           equ MMU_SLOT_6_REGISTER
 58+  0000              DispMarketMMU           equ MMU_SLOT_6_REGISTER
 59+  0000              MenuStatusMMU           equ MMU_SLOT_6_REGISTER
 60+  0000              LaunchShipMMU           equ MMU_SLOT_6_REGISTER
 61+  0000              L1memMMU       		    equ MMU_SLOT_7_REGISTER
 62+  0000              L2memMMU       		    equ MMU_SLOT_7_REGISTER
 63+  0000              SpritememMMU   		    equ MMU_SLOT_7_REGISTER
 64+  0000              ShipModelMMU  		    equ MMU_SLOT_7_REGISTER
 65+  0000              ResetUniverseMMU	    equ MMU_SLOT_7_REGISTER
 66+  0000              CommanderMMU	        equ MMU_SLOT_7_REGISTER
 67+  0000              StockTableMMU		    equ MMU_SLOT_7_REGISTER
 68+  0000              ConsoleImageDataMMU	    equ MMU_SLOT_7_REGISTER
 69+  0000              GalaxyDataMMU	        equ MMU_SLOT_7_REGISTER
 70+  0000
 71+  0000              BankResetUniv           equ 49
 72+  0000              BankMenuShrCht          equ 50
 73+  0000              BankMenuGalCht          equ 51
 74+  0000              BankMenuInvent          equ 52
 75+  0000              BankMenuSystem          equ 53
 76+  0000              BankMenuMarket          equ 54
 77+  0000              BankStockTable          equ 55
 78+  0000              BankCommander           equ 56
 79+  0000              BankLAYER2              equ 57
 80+  0000              BankLAYER1              equ 58
 81+  0000              BankShipModels1         equ 59
 82+  0000              BankSPRITE              equ 60
 83+  0000              BankConsole             equ 61
 84+  0000              BankFrontView           equ 62
 85+  0000              BankMenuStatus          equ 63
 86+  0000              BankMenuEquipS          equ 64
 87+  0000              BankLaunchShip          equ 65
 88+  0000              BankDispMarket          equ 66
 89+  0000              BankShipModels2         equ 67
 90+  0000              BankShipModels3         equ 68
 91+  0000              BankShipModels4         equ 69
 92+  0000
 93+  0000              BankUNIVDATA0           equ 70
 94+  0000              BankUNIVDATA1           equ 71
 95+  0000              BankUNIVDATA2           equ 72
 96+  0000              BankUNIVDATA3           equ 73
 97+  0000              BankUNIVDATA4           equ 74
 98+  0000              BankUNIVDATA5           equ 75
 99+  0000              BankUNIVDATA6           equ 76
100+  0000              BankUNIVDATA7           equ 77
101+  0000              BankUNIVDATA8           equ 78
102+  0000              BankUNIVDATA9           equ 79
103+  0000              BankUNIVDATA10          equ 80
104+  0000              BankUNIVDATA11          equ 81
105+  0000              BankUNIVDATA12          equ 82
106+  0000              BankSunData             equ 83
107+  0000              BankPlanetData          equ 84
108+  0000
109+  0000              BankGalaxyData0         equ 91
110+  0000              BankGalaxyData1         equ 92
111+  0000              BankGalaxyData2         equ 93
112+  0000              BankGalaxyData3         equ 94
113+  0000              BankGalaxyData4         equ 95
114+  0000              BankGalaxyData5         equ 96
115+  0000              BankGalaxyData6         equ 97
116+  0000              BankGalaxyData7         equ 98
117+  0000
118+  0000              BankMathsTables         equ 99
119+  0000
120+  0000              BankROM                 equ 255
121+  0000
# file closed: ../Hardware/memory_bank_defines.asm
 11   0000                                      INCLUDE "../Hardware/screen_equates.asm"
# file opened: ../Hardware/screen_equates.asm
  1+  0000              ScreenHeight 		equ 192
  2+  0000              ScreenLastRow       equ ScreenHeight -1
  3+  0000              ScreenWidth  		equ 256
  4+  0000              ScreenLastCol       equ ScreenWidth -1
  5+  0000              ScreenHeightHalf	equ 96
  6+  0000              ScreenWidthHalf  	equ 128
  7+  0000              ScreenCenterY		equ 96
  8+  0000              ScreenCenterX       equ 128
  9+  0000              ViewHeight          equ 128
 10+  0000              ViewHeightPlus1     equ 128+1
 11+  0000              ViewLastRow       	equ ViewHeight -1
 12+  0000              ViewWidth  			equ 256
 13+  0000              ViewLastCol         equ ViewWidth -1
 14+  0000              ViewHeightHalf      equ 63
 15+  0000              ViewWidthHalf       equ 127
 16+  0000              ViewCenterY         equ 64
 17+  0000              ViewCenterX         equ 128
 18+  0000              ShipColour			equ $FF		; place holder for debugging TODO
 19+  0000              ScreenL1Bottom      equ $5000
 20+  0000              ScreenL1BottomLen   equ 32 * 8 * 8
 21+  0000              ScreenL1AttrBtm     equ $5A00
 22+  0000              ScreenL1AttrBtmLen  equ 32 * 8
 23+  0000
# file closed: ../Hardware/screen_equates.asm
 12   0000                                      INCLUDE "../Data/ShipModelEquates.asm"
# file opened: ../Data/ShipModelEquates.asm
  1+  0000              ScoopDebrisOffset	    equ	0                               ; hull byte#0 high nibble is scoop info, lower nibble is debris spin info
  2+  0000              MissileLockLoOffset	    equ 1
  3+  0000              MissileLockHiOffset	    equ 2
  4+  0000              EdgeAddyOffset		    equ 3
  5+  0000              LineX4Offset		    equ 5
  6+  0000              GunVertexOffset		    equ 6
  7+  0000              ExplosionCtOffset	    equ 7
  8+  0000              VertexCountOffset       equ 8
  9+  0000              VertexCtX6Offset	    equ 9
 10+  0000              EdgeCountOffset		    equ 10
 11+  0000              BountyLoOffset		    equ 11
 12+  0000              BountyHiOffset		    equ 12
 13+  0000              FaceCtX4Offset		    equ 13
 14+  0000              DotOffset			    equ 14
 15+  0000              EnergyOffset		    equ 15
 16+  0000              SpeedOffset			    equ 16
 17+  0000              FaceAddyOffset		    equ 17
 18+  0000              QOffset				    equ 19
 19+  0000              LaserOffset			    equ 20
 20+  0000              VerticiesAddyOffset     equ 21
 21+  0000              ShipTypeOffset          equ 23
 22+  0000              ShipNewBitsOffset       equ 24
 23+  0000              ShipAIFlagsOffset       equ 25
 24+  0000              ShipECMFittedChanceOffset     equ 26
 25+  0000              ShipDataLength          equ ShipECMFittedChanceOffset+1
 26+  0000
 27+  0000              CobraTablePointer       equ 43
 28+  0000              ;29 faulty
 29+  0000              BankThreshold           equ 16
 30+  0000
 31+  0000              ShipTableALast          equ 23
 32+  0000              ShipTableBLast          equ 39
 33+  0000              ShipTableCLast          equ 55
 34+  0000
# file closed: ../Data/ShipModelEquates.asm
 13   0000                                      INCLUDE "../Menus/clear_screen_inline_no_double_buffer.asm"
# file opened: ../Menus/clear_screen_inline_no_double_buffer.asm
  1+  0000              InitNoDoubleBuffer:         MACRO
  2+  0000 ~                                        MMUSelectLayer1
  3+  0000 ~                                        call	l1_cls
  4+  0000 ~                                        ld		a,7
  5+  0000 ~                                        call	l1_attr_cls_to_a
  6+  0000 ~                                        MMUSelectLayer2
  7+  0000 ~                                        call    asm_l2_double_buffer_off
  8+  0000 ~                                        call	l2_cls	; Get some space
  9+  0000 ~                                        MMUSelectSpriteBank
 10+  0000 ~                                        call    sprite_cls_cursors
 11+  0000                                          ENDM
 12+  0000
 13+  0000
# file closed: ../Menus/clear_screen_inline_no_double_buffer.asm
 14   0000                                      INCLUDE "../Macros/graphicsMacros.asm"
# file opened: ../Macros/graphicsMacros.asm
  1+  0000              ; General Graphics macros
  2+  0000              DoubleBufferIfPossible: MACRO
  3+  0000 ~                                    IFDEF DOUBLEBUFFER
  4+  0000 ~                                        MMUSelectLayer2
  5+  0000 ~                                        call  l2_cls
  6+  0000 ~                                        call  l2_flip_buffers
  7+  0000 ~                                    ENDIF
  8+  0000                                      ENDM
# file closed: ../Macros/graphicsMacros.asm
 15   0000                                      INCLUDE "../Macros/callMacros.asm"
# file opened: ../Macros/callMacros.asm
  1+  0000
  2+  0000              CallIfAEqNusng:         MACRO   reg,target
  3+  0000 ~                                    cp      reg
  4+  0000 ~                                    call	z,target
  5+  0000                                      ENDM
  6+  0000
  7+  0000              CallIfAGTENusng:        MACRO   reg,target
  8+  0000 ~                                    cp      reg
  9+  0000 ~                                    call	nc,target
 10+  0000                                      ENDM
 11+  0000
 12+  0000              CallIfAGTEMemusng:      MACRO   reg,target
 13+  0000 ~                                    ld      hl,reg
 14+  0000 ~                                    cp      (hl)
 15+  0000 ~                                    call	nc,target
 16+  0000                                      ENDM
 17+  0000
 18+  0000              CallIfALTNusng:         MACRO   reg,target
 19+  0000 ~                                    cp      reg
 20+  0000 ~                                    call	c,target
 21+  0000                                      ENDM
 22+  0000
 23+  0000              CallIfMemEqMemusng:     MACRO mem, address, target
 24+  0000 ~                                    ld   a,(mem)
 25+  0000 ~                                    ld   hl,address
 26+  0000 ~                                    cp   (hl)
 27+  0000 ~                                    call    z,target
 28+  0000                                      ENDM
 29+  0000
 30+  0000              CallIfMemEqNusng:       MACRO mem, value, target
 31+  0000 ~                                    ld   a,(mem)
 32+  0000 ~                                    cp   value
 33+  0000 ~                                    call    z,target
 34+  0000                                      ENDM
 35+  0000
 36+  0000              CallIfMemTrue:          MACRO mem, target
 37+  0000 ~                                    ld      a,(mem)
 38+  0000 ~                                    and     a
 39+  0000 ~                                    call    z, target
 40+  0000                                      ENDM
 41+  0000
 42+  0000              CallIfMemFalse:         MACRO mem, target
 43+  0000 ~                                    ld      a,(mem)
 44+  0000 ~                                    and     a
 45+  0000 ~                                    call    nz, target
 46+  0000                                      ENDM
 47+  0000
 48+  0000              CallIfMemZero:          MACRO mem, target
 49+  0000 ~                                    ld      a,(mem)
 50+  0000 ~                                    and     a
 51+  0000 ~                                    call    z, target
 52+  0000                                      ENDM
 53+  0000
 54+  0000              CallIfMemNotZero:       MACRO mem, target
 55+  0000 ~                                    ld      a,(mem)
 56+  0000 ~                                    and     a
 57+  0000 ~                                    call    nz, target
 58+  0000                                      ENDM
 59+  0000              CallIfATrue:            MACRO target
 60+  0000 ~                                    and     a
 61+  0000 ~                                    call    z, target
 62+  0000                                      ENDM
 63+  0000
 64+  0000              CallIfAFalse:           MACRO target
 65+  0000 ~                                    and     a
 66+  0000 ~                                    call    nz, target
 67+  0000                                      ENDM
 68+  0000
 69+  0000              CallIfAZero:            MACRO target
 70+  0000 ~                                    and     a
 71+  0000 ~                                    call    z, target
 72+  0000                                      ENDM
 73+  0000
 74+  0000              CallIfANotZero:         MACRO target
 75+  0000 ~                                    and     a
 76+  0000 ~                                    call    nz, target
 77+  0000                                      ENDM
# file closed: ../Macros/callMacros.asm
 16   0000                                      INCLUDE "../Macros/carryFlagMacros.asm"
# file opened: ../Macros/carryFlagMacros.asm
  1+  0000
  2+  0000              SetCarryFlag:           MACRO
  3+  0000 ~                                    scf
  4+  0000                                      ENDM
  5+  0000
  6+  0000              ClearCarryFlag:	        MACRO
  7+  0000 ~                                    or a
  8+  0000                                      ENDM
  9+  0000
 10+  0000              FlipCarryFlag:          MACRO
 11+  0000 ~                                    ccf
 12+  0000                                      ENDM
 13+  0000
# file closed: ../Macros/carryFlagMacros.asm
 17   0000                                      INCLUDE "../Macros/CopyByteMacros.asm"
# file opened: ../Macros/CopyByteMacros.asm
  1+  0000              CopyByteAtHLixToA:		MACRO memloc
  2+  0000 ~            						ex          de,hl                               ; save hl
  3+  0000 ~            						ld          hl,memloc
  4+  0000 ~            						add         hl,a
  5+  0000 ~            						ld          a,(hl)                              ; get XX2[x]
  6+  0000 ~            						ex          de,hl                               ; get hl back as we need it in loop
  7+  0000              						ENDM
  8+  0000
  9+  0000              ; Increments IYL
 10+  0000              ; Increments IHL
 11+  0000              ; Gets value at hl and loads into Parameter 1 address
 12+  0000
 13+  0000              CopyByteAtNextHLiyl: 	MACRO memloc
 14+  0000 ~            						inc         iyl                                 ;
 15+  0000 ~            						inc         hl                                  ; vertex byte#1
 16+  0000 ~            						ld          a,(hl)                              ;
 17+  0000 ~            						ld          (memloc),a                     ; XX15+2 = (V),Y
 18+  0000              						ENDM
 19+  0000
 20+  0000              ;------------------------------------------------------------------------------------------------------------------------------
 21+  0000              CopyByteAtNextHL:   MACRO targetaddr
 22+  0000 ~                                inc         hl                                  ; vertex byte#1
 23+  0000 ~                                ld          a,(hl)                              ;
 24+  0000 ~                                ld          (targetaddr),a                     ; SunXX15+2 = (V),Y
 25+  0000                                  ENDM
# file closed: ../Macros/CopyByteMacros.asm
 18   0000                                      INCLUDE "../Macros/ldCopyMacros.asm"
# file opened: ../Macros/ldCopyMacros.asm
  1+  0000              ZeroA:		            MACRO
  2+  0000 ~                                    xor a
  3+  0000                                      ENDM
  4+  0000
  5+  0000              SetATrue:               MACRO
  6+  0000 ~                                    xor     a
  7+  0000                                      ENDM
  8+  0000
  9+  0000              SetAFalse:              MACRO
 10+  0000 ~                                    ld      a,$FF
 11+  0000                                      ENDM
 12+  0000
 13+  0000              SetMemFalse             MACRO   mem
 14+  0000 ~                                    ld      a,$FF
 15+  0000 ~                                    ld      (mem),a
 16+  0000                                      ENDM
 17+  0000
 18+  0000              SetMemTrue              MACRO   mem
 19+  0000 ~                                    xor     a
 20+  0000 ~                                    ld      (mem),a
 21+  0000                                      ENDM
 22+  0000
 23+  0000              SetMemToN:              MACRO   mem,value
 24+  0000 ~                                    ld      a,value
 25+  0000 ~                                    ld      (mem),a
 26+  0000                                      ENDM
 27+  0000
 28+  0000              ldCopyStringLen:        MACRO   source, target, strlen
 29+  0000 ~                                    ld      hl,source
 30+  0000 ~                                    ld      de, target
 31+  0000 ~                                    ld      bc, strlen
 32+  0000 ~                                    ldir
 33+  0000                                      ENDM
 34+  0000
 35+  0000              ldCopyTextAtHLtoDE:     MACRO
 36+  0000 ~            .CopyLoop:              ld      a,(hl)
 37+  0000 ~                                    ld      (de),a
 38+  0000 ~                                    cp      0
 39+  0000 ~                                    jp      z,.DoneCopy
 40+  0000 ~                                    inc     hl
 41+  0000 ~                                    inc     de
 42+  0000 ~                                    jr      .CopyLoop
 43+  0000 ~            .DoneCopy:
 44+  0000                                      ENDM
 45+  0000
 46+  0000              ldClearTextLoop:        MACRO   TextSize
 47+  0000 ~                                    ld      b,a
 48+  0000 ~                                    ld      a,TextSize
 49+  0000 ~            .ClearLoop:             ld      (hl),a
 50+  0000 ~                                    inc     hl
 51+  0000 ~                                    djnz    .ClearLoop
 52+  0000                                      ENDM
 53+  0000
 54+  0000              ldCopyByte:             MACRO memfrom, memto
 55+  0000 ~                                    ld       a,(memfrom)
 56+  0000 ~                                    ld       (memto),a
 57+  0000                                      ENDM
 58+  0000
 59+  0000
 60+  0000              ldCopyByteABS:          MACRO memfrom, memto
 61+  0000 ~                                    ld       a,(memfrom)
 62+  0000 ~                                    and		$7F
 63+  0000 ~                                    ld       (memto),a
 64+  0000                                      ENDM
 65+  0000
 66+  0000              ldAtHLtoMem:            MACRO   memto
 67+  0000 ~                                    ld      a,(hl)
 68+  0000 ~                                    ld      (memto),a
 69+  0000                                      ENDM
 70+  0000
 71+  0000              ldCopy2Byte             MACRO  memfrom, memto
 72+  0000 ~                                    ld       hl,(memfrom)
 73+  0000 ~                                    ld       (memto),hl
 74+  0000                                      ENDM
 75+  0000
 76+  0000              ldWriteConst            MACRO  memfrom, memto
 77+  0000 ~                                    ld       a,memfrom
 78+  0000 ~                                    ld       (memto),a
 79+  0000                                      ENDM
 80+  0000
 81+  0000              ldWriteZero             MACRO  memto
 82+  0000 ~                                    xor      a
 83+  0000 ~                                    ld       (memto),a
 84+  0000                                      ENDM
 85+  0000
 86+  0000              ldIXLaFromN:	        MACRO memfrom
 87+  0000 ~                                    ld		a,(memfrom)
 88+  0000 ~                                    ld		ixl,a
 89+  0000                                      ENDM
 90+  0000
 91+  0000              ldIXHaFromN:	        MACRO memfrom
 92+  0000 ~                                    ld		a,(memfrom)
 93+  0000 ~                                    ld		ixh,a
 94+  0000                                      ENDM
 95+  0000
 96+  0000              ldIYLaFromN:	        MACRO memfrom
 97+  0000 ~                                    ld		a,(memfrom)
 98+  0000 ~                                    ld		iyl,a
 99+  0000                                      ENDM
100+  0000
101+  0000              ldIYHaFromN:	        MACRO memfrom
102+  0000 ~                                    ld		a,(memfrom)
103+  0000 ~                                    ld		iyh,a
104+  0000                                      ENDM
105+  0000
106+  0000              ; Read a 32 bit value from address HL into BCDE
107+  0000              ldBCDEatHL:             MACRO
108+  0000 ~                                    ld      e,(hl)
109+  0000 ~                                    inc     hl
110+  0000 ~                                    ld      d,(hl)
111+  0000 ~                                    inc     hl
112+  0000 ~                                    ld      c,(hl)
113+  0000 ~                                    inc     hl
114+  0000 ~                                    ld      b,(hl)
115+  0000 ~                                    inc     hl
116+  0000                                      ENDM
117+  0000
118+  0000              ldBCatHL:               MACRO
119+  0000 ~                                    ld      c,(hl)
120+  0000 ~                                    inc     hl
121+  0000 ~                                    ld      b,(hl)
122+  0000 ~                                    inc     hl
123+  0000                                      ENDM
124+  0000
125+  0000              ldhlde:			        MACRO
126+  0000 ~                                    ld		h,d
127+  0000 ~                                    ld		l,e
128+  0000                                      ENDM
129+  0000
130+  0000              ldhlbc:			        MACRO
131+  0000 ~                                    ld		h,b
132+  0000 ~                                    ld		l,c
133+  0000                                      ENDM
134+  0000
135+  0000              ldbcde:			        MACRO
136+  0000 ~                                    ld		b,d
137+  0000 ~                                    ld		c,e
138+  0000                                      ENDM
139+  0000
140+  0000              lddebc:			        MACRO
141+  0000 ~                                    ld		d,b
142+  0000 ~                                    ld		e,c
143+  0000                                      ENDM
144+  0000
145+  0000              ldbchl:			        MACRO
146+  0000 ~                                    ld		b,h
147+  0000 ~                                    ld		c,l
148+  0000                                      ENDM
149+  0000
150+  0000              lddeiy:			        MACRO
151+  0000 ~                                    ld		d,iyh
152+  0000 ~                                    ld		e,iyl
153+  0000                                      ENDM
154+  0000
155+  0000              ldiyde:			        MACRO
156+  0000 ~                                    ld		iyh,d
157+  0000 ~                                    ld		iyl,e
158+  0000                                      ENDM
159+  0000
160+  0000
161+  0000              FourLDIInstrunctions:   MACRO
162+  0000 ~                                    ldi
163+  0000 ~                                    ldi
164+  0000 ~                                    ldi
165+  0000 ~                                    ldi
166+  0000                                      ENDM
167+  0000
168+  0000              FiveLDIInstrunctions:   MACRO
169+  0000 ~                                    ldi
170+  0000 ~                                    ldi
171+  0000 ~                                    ldi
172+  0000 ~                                    ldi
173+  0000 ~                                    ldi
174+  0000                                      ENDM
175+  0000
176+  0000              SixLDIInstrunctions:    MACRO
177+  0000 ~                                    ldi
178+  0000 ~                                    ldi
179+  0000 ~                                    ldi
180+  0000 ~                                    ldi
181+  0000 ~                                    ldi
182+  0000 ~                                    ldi
183+  0000                                      ENDM
184+  0000
185+  0000              EightLDIInstrunctions:  MACRO
186+  0000 ~            		                ldi
187+  0000 ~            		                ldi
188+  0000 ~            		                ldi
189+  0000 ~            		                ldi
190+  0000 ~            		                ldi
191+  0000 ~            		                ldi
192+  0000 ~            		                ldi
193+  0000 ~            		                ldi
194+  0000                                      ENDM
195+  0000
196+  0000              NineLDIInstrunctions:  MACRO
197+  0000 ~            		                ldi
198+  0000 ~            		                ldi
199+  0000 ~            		                ldi
200+  0000 ~            		                ldi
201+  0000 ~            		                ldi
202+  0000 ~            		                ldi
203+  0000 ~            		                ldi
204+  0000 ~            		                ldi
205+  0000 ~            		                ldi
206+  0000                                      ENDM
# file closed: ../Macros/ldCopyMacros.asm
 19   0000                                      INCLUDE "../Macros/ldIndexedMacros.asm"
# file opened: ../Macros/ldIndexedMacros.asm
  1+  0000              GetByteAInTable:    MACRO table
  2+  0000 ~                                ld          hl,table
  3+  0000 ~                                add         hl,a
  4+  0000 ~                                ld          a,(hl)
  5+  0000                                  ENDM
  6+  0000
  7+  0000              HLWordAInTable:     MACRO table
  8+  0000 ~                                ld          hl,table
  9+  0000 ~                                sla         a
 10+  0000 ~                                add         hl,a
 11+  0000 ~                                ld          a,(hl)
 12+  0000 ~                                inc         hl
 13+  0000 ~                                ld          h,(hl)
 14+  0000 ~                                ld          l,a
 15+  0000                                  ENDM
 16+  0000
 17+  0000
 18+  0000              ldAToHLixl:			MACRO value
 19+  0000 ~            					ld          hl,value
 20+  0000 ~            					ex          af,af'
 21+  0000 ~            					ld          a,ixl
 22+  0000 ~            					add         hl,a
 23+  0000 ~            					ex          af,af'
 24+  0000 ~            					ld          (hl),a
 25+  0000              					ENDM
 26+  0000
 27+  0000              ldAToHLiyl:			MACRO value
 28+  0000 ~            					ld          hl,value
 29+  0000 ~            					ex          af,af'
 30+  0000 ~            					ld          a,iyl
 31+  0000 ~            					add         hl,a
 32+  0000 ~            					ex          af,af'
 33+  0000 ~            					ld          (hl),a
 34+  0000              					ENDM
 35+  0000
 36+  0000
 37+  0000              ldHLixlToA:         MACRO value
 38+  0000 ~                                ld          hl,value
 39+  0000 ~                                ex          af,af'
 40+  0000 ~                                ld          a,ixl
 41+  0000 ~                                add         hl,a
 42+  0000 ~                                ld          a,(hl)
 43+  0000                                  ENDM
 44+  0000
 45+  0000              ldHLiylToA:         MACRO value
 46+  0000 ~                                ld          hl,value
 47+  0000 ~                                ex          af,af'
 48+  0000 ~                                ld          a,iyl
 49+  0000 ~                                add         hl,a
 50+  0000 ~                                ld          a,(hl)
 51+  0000                                  ENDM
 52+  0000
 53+  0000              ldHLIdxAToA:        MACRO value
 54+  0000 ~                                ld          hl,value
 55+  0000 ~                                add         hl,a
 56+  0000 ~                                ld          a,(hl)
 57+  0000                                  ENDM
 58+  0000
 59+  0000              HLEquAddrAtHLPlusA: MACRO
 60+  0000 ~                                sla         a
 61+  0000 ~                                add         hl,a
 62+  0000 ~                                ld          a,(hl)
 63+  0000 ~                                inc         hl
 64+  0000 ~                                ld          h,(hl)
 65+  0000 ~                                ld          l,a
 66+  0000                                  ENDM
# file closed: ../Macros/ldIndexedMacros.asm
 20   0000                                      INCLUDE "../Macros/jumpMacros.asm"
# file opened: ../Macros/jumpMacros.asm
  1+  0000              JumpIfPositive:	        MACRO target
  2+  0000 ~                                    jp		p, target
  3+  0000                                      ENDM
  4+  0000
  5+  0000              JumpIfNegative:	        MACRO target
  6+  0000 ~                                    jp		m, target
  7+  0000                                      ENDM
  8+  0000
  9+  0000
 10+  0000              JumpIfUnderflow:	    MACRO target
 11+  0000 ~                                    jp		po, target
 12+  0000                                      ENDM
 13+  0000
 14+  0000              JumpIfOverflow:	        MACRO target
 15+  0000 ~                                    jp		po, target
 16+  0000                                      ENDM
 17+  0000
 18+  0000
 19+  0000              JumpIfNotZero:	        MACRO target
 20+  0000 ~                                    jp	nz,target
 21+  0000                                      ENDM
 22+  0000
 23+  0000              JumpIfZero:	            MACRO target
 24+  0000 ~                                    jp	z,target
 25+  0000                                      ENDM
 26+  0000
 27+  0000              ;.. Bit routines
 28+  0000              JumpOnLeadSignSet:      MACRO   reg, target
 29+  0000 ~                                    ld      a,reg
 30+  0000 ~                                    and     SignOnly8Bit
 31+  0000 ~                                    jp      nz,target
 32+  0000                                      ENDM
 33+  0000
 34+  0000              JumpOnLeadSignClear:    MACRO   reg, target
 35+  0000 ~                                    ld      a,reg
 36+  0000 ~                                    and     SignOnly8Bit
 37+  0000 ~                                    jp      z,target
 38+  0000                                      ENDM
 39+  0000
 40+  0000              JumpOnLeadSignSetA:     MACRO   target
 41+  0000 ~                                    and     SignOnly8Bit
 42+  0000 ~                                    jp      nz,target
 43+  0000                                      ENDM
 44+  0000
 45+  0000              JumpOnLeadSignClearA:   MACRO   target
 46+  0000 ~                                    and     SignOnly8Bit
 47+  0000 ~                                    jp      z,target
 48+  0000                                      ENDM
 49+  0000
 50+  0000              JumpOnMemBitSet:        MACRO mem, bitnbr, target
 51+  0000 ~                                    ld      a,(mem)
 52+  0000 ~                                    bit 	bitnbr,a
 53+  0000 ~                                    jp      nz,target
 54+  0000                                      ENDM
 55+  0000
 56+  0000              JumpOnMemBitClear:      MACRO mem, bitnbr, target
 57+  0000 ~                                    ld      a,(mem)
 58+  0000 ~                                    bit 	bitnbr,a
 59+  0000 ~                                    jp      z,target
 60+  0000                                      ENDM
 61+  0000
 62+  0000
 63+  0000              JumpOnABitSet:          MACRO   bitnbr, target
 64+  0000 ~                                    bit 	bitnbr, a
 65+  0000 ~                                    jp      nz,target
 66+  0000                                      ENDM
 67+  0000
 68+  0000              JumpOnABitClear:        MACRO   bitnbr, target
 69+  0000 ~                                    bit 	bitnbr, a
 70+  0000 ~                                    jp      z,target
 71+  0000                                      ENDM
 72+  0000
 73+  0000              JumpOnABit5Set:         MACRO   target
 74+  0000 ~                                    and     Bit5Only
 75+  0000 ~                                    jp      nz,target
 76+  0000                                      ENDM
 77+  0000
 78+  0000              JumpOnABit5Clear:       MACRO   target
 79+  0000 ~                                    and     Bit5Only
 80+  0000 ~                                    jp      z,target
 81+  0000                                      ENDM
 82+  0000
 83+  0000              JumpOnBitMaskSet:       MACRO   bitmask, target
 84+  0000 ~                                    and     bitmask
 85+  0000 ~                                    jp      nz,target
 86+  0000                                      ENDM
 87+  0000
 88+  0000              JumpOnBitMaskClear:     MACRO   bitmask, target
 89+  0000 ~                                    and     bitmask
 90+  0000 ~                                    jp      z,target
 91+  0000                                      ENDM
 92+  0000
 93+  0000              JumpOnMemBitMaskSet:    MACRO   mem, bitmask, target
 94+  0000 ~                                    ld      a,(mem)
 95+  0000 ~                                    and     bitmask
 96+  0000 ~                                    jp      nz,target
 97+  0000                                      ENDM
 98+  0000
 99+  0000              JumpOnMemBitMaskClear:  MACRO   mem, bitmask, target
100+  0000 ~                                    ld      a,(mem)
101+  0000 ~                                    and     bitmask
102+  0000 ~                                    jp      z,target
103+  0000                                      ENDM
104+  0000
105+  0000              JumpOnBitSet:           MACRO  reg, bitnbr, target
106+  0000 ~                                    bit 	bitnbr,reg
107+  0000 ~                                    jp      nz,target
108+  0000                                      ENDM
109+  0000
110+  0000              JumpOnBitClear:         MACRO  reg, bitnbr, target
111+  0000 ~                                    bit 	bitnbr,reg
112+  0000 ~                                    jp      z,target
113+  0000                                      ENDM
114+  0000
115+  0000              ; Comparison Routines
116+  0000              JumpIfAGTEusng:         MACRO
117+  0000 ~                                    jp		nc,target
118+  0000                                      ENDM
119+  0000
120+  0000              JumpIfAGTENusng:        MACRO reg,target
121+  0000 ~                                    cp     reg
122+  0000 ~                                    jp		nc,target
123+  0000                                      ENDM
124+  0000
125+  0000              JumpIfAGTEMemusng:      MACRO mem,target
126+  0000 ~                                    ld      hl,mem
127+  0000 ~                                    cp      (hl)
128+  0000 ~                                    jp		nc,target
129+  0000                                      ENDM
130+  0000
131+  0000              JumpIfALTMemusng:       MACRO mem,target
132+  0000 ~                                    ld      hl,mem
133+  0000 ~                                    cp      (hl)
134+  0000 ~                                    jp		c,target
135+  0000                                      ENDM
136+  0000
137+  0000              JumpIfMemGTENusng:      MACRO mem, value, target
138+  0000 ~                                    ld     a,(mem)
139+  0000 ~                                    cp     value
140+  0000 ~                                    jp	  nc,target
141+  0000                                      ENDM
142+  0000
143+  0000              JumpIfMemGTEMemusng:    MACRO mem, address, target
144+  0000 ~                                    ld   a,(mem)
145+  0000 ~                                    ld   hl,address
146+  0000 ~                                    cp   (hl)
147+  0000 ~                                    jp	  nc,target
148+  0000                                      ENDM
149+  0000
150+  0000              JumpIfMemEqMemusng:     MACRO mem, address, target
151+  0000 ~                                    ld   a,(mem)
152+  0000 ~                                    ld   hl,address
153+  0000 ~                                    cp   (hl)
154+  0000 ~                                    jp	  z,target
155+  0000                                      ENDM
156+  0000
157+  0000              JumpIfMemNeMemusng:     MACRO mem, address, target
158+  0000 ~                                    ld   a,(mem)
159+  0000 ~                                    ld   hl,address
160+  0000 ~                                    cp   (hl)
161+  0000 ~                                    jp	  nz,target
162+  0000                                      ENDM
163+  0000
164+  0000              JumpIfMemTrue:          MACRO mem, target
165+  0000 ~                                    ld      a,(mem)
166+  0000 ~                                    and     a
167+  0000 ~                                    jp      z, target
168+  0000                                      ENDM
169+  0000
170+  0000              JumpIfMemFalse:         MACRO mem, target
171+  0000 ~                                    ld      a,(mem)
172+  0000 ~                                    and     a
173+  0000 ~                                    jp      nz, target
174+  0000                                      ENDM
175+  0000
176+  0000              JumpIfATrue:            MACRO target
177+  0000 ~                                    and     a
178+  0000 ~                                    jp      z, target
179+  0000                                      ENDM
180+  0000
181+  0000              JumpIfAFalse:           MACRO target
182+  0000 ~                                    and     a
183+  0000 ~                                    jp      nz, target
184+  0000                                      ENDM
185+  0000
186+  0000              JumpIfANotFalse:        MACRO target
187+  0000 ~                                    cp      $FF
188+  0000 ~                                    jp      nz, target
189+  0000                                      ENDM
190+  0000
191+  0000              JumpIfALTusng:          MACRO target
192+  0000 ~                                    jp		c,target
193+  0000                                      ENDM
194+  0000
195+  0000              JumpIfALTNusng:         MACRO value, target
196+  0000 ~                                    cp      value
197+  0000 ~                                    jp		c, target
198+  0000                                      ENDM
199+  0000
200+  0000              JumpIfMemLTNusng:       MACRO mem, value, target
201+  0000 ~                                    ld      a,(mem)
202+  0000 ~                                    cp      value
203+  0000 ~                                    jp	  c,target
204+  0000                                      ENDM
205+  0000
206+  0000              JumpIfMemLTMemusng:     MACRO mem, value, target
207+  0000 ~                                    ld    a,(mem)
208+  0000 ~                                    ld    hl,value
209+  0000 ~                                    cp    (hl)
210+  0000 ~                                    jp	  c,target
211+  0000                                      ENDM
212+  0000
213+  0000              JumpIfMemEqNusng:       MACRO mem,value,target
214+  0000 ~                                    ld  a,(mem)
215+  0000 ~                                    cp  value
216+  0000 ~                                    jp  z,target
217+  0000                                      ENDM
218+  0000
219+  0000              JumpIfMemNeNusng:       MACRO mem,value,target
220+  0000 ~                                    ld  a,(mem)
221+  0000 ~                                    cp  value
222+  0000 ~                                    jp  nz,target
223+  0000                                      ENDM
224+  0000
225+  0000              JumpIfMemZero:          MACRO mem,target
226+  0000 ~                                    ld  a,(mem)
227+  0000 ~                                    and a
228+  0000 ~                                    jp  z,target
229+  0000                                      ENDM
230+  0000
231+  0000              JumpIfMemNotZero:       MACRO mem,target
232+  0000 ~                                    ld  a,(mem)
233+  0000 ~                                    and a
234+  0000 ~                                    jp  nz,target
235+  0000                                      ENDM
236+  0000
237+  0000              JumpIfALTMemHLusng:     MACRO target
238+  0000 ~                                    cp    (hl)
239+  0000 ~                                    jp	  c,target
240+  0000                                      ENDM
241+  0000
242+  0000              JumpIfANENusng:         MACRO value, target
243+  0000 ~                                    cp     value
244+  0000 ~                                    jp      nz,target
245+  0000                                      ENDM
246+  0000
247+  0000              JumpIfANEquNusng:       MACRO value, target
248+  0000 ~                                    cp     value
249+  0000 ~                                    jp     z,target
250+  0000                                      ENDM
251+  0000
252+  0000              JumpIfANEMemusng:       MACRO  value, target
253+  0000 ~                                    ld    hl,value
254+  0000 ~                                    cp    (hl)
255+  0000 ~                                    jp      nz,target
256+  0000                                      ENDM
257+  0000
258+  0000              JumpIfAEqNusng:         MACRO value, target
259+  0000 ~                                    cp     value
260+  0000 ~                                    jp      z,target
261+  0000                                      ENDM
262+  0000
263+  0000              JumpIfAIsZero:	        MACRO target
264+  0000 ~                                    and     a   ; cp 0 - changed to and a for optimisation but affects other flags
265+  0000 ~                                    jp	    z, target
266+  0000                                      ENDM
267+  0000
268+  0000              JumpIfRegIsNotZero:     MACRO   reg, target
269+  0000 ~                                    ld      a,reg
270+  0000 ~                                    and     a
271+  0000 ~                                    jp	    nz,target
272+  0000                                      ENDM
273+  0000
274+  0000              JumpIfAIsNotZero:       MACRO target
275+  0000 ~                                    and     a
276+  0000 ~                                    jp	    nz,target
277+  0000                                      ENDM
278+  0000
279+  0000              JumpIfMemIsNotZero:     MACRO value, target
280+  0000 ~                                    ld      a,(value)
281+  0000 ~                                    and     a
282+  0000 ~                                    jp	    nz,target
283+  0000                                      ENDM
284+  0000              IfResultZeroGoto:	    MACRO target
285+  0000 ~                                    jp	z,target
286+  0000                                      ENDM
287+  0000
288+  0000              IfResultNotZeroGoto:    MACRO target
289+  0000 ~                                    jp	nz,target
290+  0000                                      ENDM
291+  0000
# file closed: ../Macros/jumpMacros.asm
 21   0000                                      INCLUDE "../Macros/MathsMacros.asm"
# file opened: ../Macros/MathsMacros.asm
  1+  0000
  2+  0000              ABSa2c:                 MACRO
  3+  0000 ~                                    bit     7,a
  4+  0000 ~                                    jp      z,.DoneABSa
  5+  0000 ~                                    neg
  6+  0000 ~            .DoneABSa:
  7+  0000                                      ENDM
  8+  0000
  9+  0000              DEEquSquareA:           MACRO
 10+  0000 ~                                    ld  d,a
 11+  0000 ~                                    ld  e,a
 12+  0000 ~                                    mul de
 13+  0000                                      ENDM
 14+  0000
 15+  0000              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
 16+  0000 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
 17+  0000 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
 18+  0000 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
 19+  0000 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
 20+  0000 ~                                    xor $80                             ;
 21+  0000 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
 22+  0000 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
 23+  0000 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
 24+  0000 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
 25+  0000 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
 26+  0000 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
 27+  0000                                      ENDM
 28+  0000
 29+  0000              SignedHLTo2C:           MACRO
 30+  0000 ~                                    bit     7,h
 31+  0000 ~                                    jr      z,.Done2c
 32+  0000 ~                                    ld      a,h
 33+  0000 ~                                    and     SignMask8Bit
 34+  0000 ~                                    ld      h,a
 35+  0000 ~                                    NegHL
 36+  0000 ~            .Done2c:
 37+  0000                                      ENDM
 38+  0000
 39+  0000              MemSignedTo2C:          MACRO   memfrom
 40+  0000 ~                                    ld      hl,(memfrom)
 41+  0000 ~                                    bit     7,h
 42+  0000 ~                                    jr      z,.Done2c
 43+  0000 ~                                    ld      a,h
 44+  0000 ~                                    and     SignMask8Bit
 45+  0000 ~                                    ld      h,a
 46+  0000 ~            .Done2c:                ld      (memfrom),hl
 47+  0000                                      ENDM
 48+  0000
 49+  0000
 50+  0000                  ;returns result in H
 51+  0000              EDiv10Inline:           MACRO
 52+  0000 ~                                    ld      d,0
 53+  0000 ~                                    ld      hl,de
 54+  0000 ~                                    add     hl,hl
 55+  0000 ~                                    add     hl,de
 56+  0000 ~                                    add     hl,hl
 57+  0000 ~                                    add     hl,hl
 58+  0000 ~                                    add     hl,de
 59+  0000 ~                                    add     hl,hl
 60+  0000                                      ENDM
 61+  0000
 62+  0000              cpHLDE:                 MACRO
 63+  0000 ~                                    push    hl
 64+  0000 ~                                    and     a
 65+  0000 ~                                    sbc     hl,de
 66+  0000 ~                                    pop     hl
 67+  0000                                      ENDM
 68+  0000
 69+  0000              ;Unsigned
 70+  0000              ;If HL == DE, then Z flag is set.
 71+  0000              ;If HL != DE, then Z flag is reset.
 72+  0000              ;If HL <  DE, then C flag is set.
 73+  0000              ;If HL >= DE, then C flag is reset.
 74+  0000              ;
 75+  0000              ;Signed
 76+  0000              ;If HL == DE, then Z flag is set.
 77+  0000              ;If HL != DE, then Z flag is reset.
 78+  0000              ;If HL <  DE, then S and P/V are different.
 79+  0000              ;If HL >= DE, then S and P/V are the same.
 80+  0000
 81+  0000
 82+  0000              N0equN1byN2div256:      MACRO param1,param2,param3
 83+  0000 ~                                    ld      a,param3                        ;
 84+  0000 ~                                    ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 85+  0000 ~                                    ld      a,param2                        ; A = XX16 element
 86+  0000 ~                                    ld      d,a
 87+  0000 ~                                    mul
 88+  0000 ~                                    ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 89+  0000 ~                                    ld      (param1),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 90+  0000                                      ENDM
 91+  0000
 92+  0000              AequN1xorN2:            MACRO  param1,param2
 93+  0000 ~                                    ld      a,(param1)
 94+  0000 ~                                    xor     param2
 95+  0000                                      ENDM
 96+  0000
# file closed: ../Macros/MathsMacros.asm
 22   0000                                      INCLUDE "../Macros/MMUMacros.asm"
# file opened: ../Macros/MMUMacros.asm
  1+  0000              MMUSelectROM0:       MACRO
  2+  0000 ~                                 nextreg EXSDOSMMU0,        BankROM
  3+  0000                                   ENDM
  4+  0000
  5+  0000              MMUSelectROMS:       MACRO
  6+  0000 ~                                 nextreg EXSDOSMMU0,        BankROM
  7+  0000 ~                                 nextreg EXSDOSMMU1,        BankROM
  8+  0000                                   ENDM
  9+  0000
 10+  0000              MMUSelectMathsTables:MACRO
 11+  0000 ~                                 nextreg MathsTablesMMU,    BankMathsTables
 12+  0000                                   ENDM
 13+  0000
 14+  0000              MMUSelectSpriteBank: MACRO
 15+  0000 ~            					 nextreg SpritememMMU,	    BankSPRITE
 16+  0000              					 ENDM
 17+  0000
 18+  0000              MMUSelectConsoleBank: MACRO
 19+  0000 ~            					 nextreg ConsoleImageDataMMU,  BankConsole
 20+  0000              					 ENDM
 21+  0000
 22+  0000              MMUSelectLayer1: 	 MACRO
 23+  0000 ~            					 nextreg L1memMMU,		    BankLAYER1
 24+  0000              					 ENDM
 25+  0000
 26+  0000              MMUSelectLayer2: 	 MACRO
 27+  0000 ~            					 nextreg L2memMMU,		    BankLAYER2
 28+  0000              					 ENDM
 29+  0000
 30+  0000              MMUSelectResetUniv:  MACRO
 31+  0000 ~                                 nextreg ResetUniverseMMU, BankResetUniv
 32+  0000                                   ENDM
 33+  0000
 34+  0000              MMUSelectShipARead:  MACRO
 35+  0000 ~                                 add    a,BankUNIVDATA0
 36+  0000 ~                                 nextreg ShipReadMMU,       a
 37+  0000                                   ENDM
 38+  0000
 39+  0000              MMUSelectShipBank1:  MACRO
 40+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModels1
 41+  0000              					 ENDM
 42+  0000              MMUSelectShipBank2:  MACRO
 43+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModels2
 44+  0000              					 ENDM
 45+  0000              MMUSelectShipBank3:  MACRO
 46+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModels3
 47+  0000              					 ENDM
 48+  0000              MMUSelectShipBank4:  MACRO
 49+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModels4
 50+  0000              					 ENDM
 51+  0000
 52+  0000              MMUSelectShipBankA   MACRO
 53+  0000 ~            					 nextreg ShipModelMMU,	    a
 54+  0000              					 ENDM
 55+  0000
 56+  0000              MMUSelectShipBankN:  MACRO value
 57+  0000 ~            					 nextreg ShipModelMMU,	    value
 58+  0000              					 ENDM
 59+  0000
 60+  0000              MMUSelectCommander:	 MACRO
 61+  0000 ~                                 nextreg CommanderMMU,       BankCommander
 62+  0000              					 ENDM
 63+  0000
 64+  0000              MMUSelectStockTable: MACRO
 65+  0000 ~                                 nextreg StockTableMMU,     BankStockTable
 66+  0000              					 ENDM
 67+  0000
 68+  0000              MMUSelectCpySrcA:    MACRO
 69+  0000 ~                                 nextreg DMACpySourceMMU,	a
 70+  0000              					 ENDM
 71+  0000
 72+  0000              MMUSelectCpySrcN:    MACRO value
 73+  0000 ~                                 nextreg DMACpySourceMMU,	value
 74+  0000              					 ENDM
 75+  0000
 76+  0000              MMUSelectSun:        MACRO
 77+  0000 ~                                 nextreg SunMMU,            BankSunData
 78+  0000                                   ENDM
 79+  0000
 80+  0000              MMUSelectPlanet:     MACRO
 81+  0000 ~                                 nextreg PlanetMMU,         BankPlanetData
 82+  0000                                   ENDM
 83+  0000
 84+  0000              MMUSelectUniverseA:  MACRO
 85+  0000 ~                                 add    a,BankUNIVDATA0
 86+  0000 ~                                 nextreg UniverseMMU,       a
 87+  0000                                   ENDM
 88+  0000              ;Version that assumes a pre calulated A, used whn optimising many switches
 89+  0000              MMUSelectUnivBankA:  MACRO
 90+  0000 ~                                 nextreg UniverseMMU,       a
 91+  0000                                   ENDM
 92+  0000
 93+  0000              MMUSelectUniverseN:  MACRO value
 94+  0000 ~                                 nextreg UniverseMMU,       BankUNIVDATA0+value
 95+  0000                                   ENDM
 96+  0000
 97+  0000              MMUSelectGalaxyA:    MACRO
 98+  0000 ~                                 nextreg GalaxyDataMMU,       a
 99+  0000                                   ENDM
100+  0000
101+  0000              MMUSelectGalaxyN:    MACRO value
102+  0000 ~                                 nextreg GalaxyDataMMU,     BankGalaxyData0+value
103+  0000                                   ENDM
104+  0000              MMUSelectGalaxyACopy:MACRO
105+  0000 ~                                 nextreg UniverseMMU,       a
106+  0000                                   ENDM
107+  0000
108+  0000              MMUSelectUniverseAbs:MACRO value
109+  0000 ~                                 nextreg UniverseMMU,       value
110+  0000                                   ENDM
111+  0000
112+  0000              MMUSelectMenuGalCht: MACRO
113+  0000 ~                                 nextreg MenuGalChtMMU,		BankMenuGalCht
114+  0000              					 ENDM
115+  0000
116+  0000              MMUSelectMenuShrCht: MACRO
117+  0000 ~            					 nextreg MenuShrChtMMU,		BankMenuShrCht
118+  0000              					 ENDM
119+  0000
120+  0000              MMUSelectMenuInvent: MACRO
121+  0000 ~                                 nextreg MenuInventMMU,		BankMenuInvent
122+  0000              					 ENDM
123+  0000
124+  0000              MMUSelectMenuSystem: MACRO
125+  0000 ~                                 nextreg MenuSystemMMU,		BankMenuSystem
126+  0000              					 ENDM
127+  0000
128+  0000              MMUSelectMenuMarket: MACRO
129+  0000 ~                                 nextreg MenuMarketMMU,		BankMenuMarket
130+  0000              					 ENDM
131+  0000
132+  0000              MMUSelectMenuStatus: MACRO
133+  0000 ~                                 nextreg MenuStatusMMU,		BankMenuStatus
134+  0000              					 ENDM
135+  0000
136+  0000              MMUSelectViewFront:  MACRO
137+  0000 ~                                 nextreg ScreenBankMMU,		BankFrontView
138+  0000              					 ENDM
139+  0000
140+  0000              MMUSelectScreenA:    MACRO
141+  0000 ~                                 nextreg ScreenBankMMU,		a
142+  0000              					 ENDM
143+  0000
# file closed: ../Macros/MMUMacros.asm
 23   0000                                      INCLUDE "../Macros/NegateMacros.asm"
# file opened: ../Macros/NegateMacros.asm
  1+  0000
  2+  0000              NegIY:			    MACRO
  3+  0000 ~                                xor a
  4+  0000 ~                                sub iyl
  5+  0000 ~                                ld iyl,a
  6+  0000 ~                                sbc a,a
  7+  0000 ~                                sub iyh
  8+  0000 ~                                ld iyh,a
  9+  0000                                  ENDM
 10+  0000
 11+  0000              NegHL:			    MACRO
 12+  0000 ~                                xor a
 13+  0000 ~                                sub l
 14+  0000 ~                                ld l,a
 15+  0000 ~                                sbc a,a
 16+  0000 ~                                sub h
 17+  0000 ~                                ld h,a
 18+  0000                                  ENDM
 19+  0000
 20+  0000              NegDE:			    MACRO
 21+  0000 ~                                xor a
 22+  0000 ~                                sub e
 23+  0000 ~                                ld e,a
 24+  0000 ~                                sbc a,a
 25+  0000 ~                                sub d
 26+  0000 ~                                ld d,a
 27+  0000                                  ENDM
 28+  0000
 29+  0000              NegBC:			    MACRO
 30+  0000 ~                                xor a
 31+  0000 ~                                sub c
 32+  0000 ~                                ld c,a
 33+  0000 ~                                sbc a,a
 34+  0000 ~                                sub  b
 35+  0000 ~                                ld b,a
 36+  0000                                  ENDM
 37+  0000
 38+  0000              NegH                MACRO
 39+  0000 ~                                ld      a,h
 40+  0000 ~                                neg
 41+  0000 ~                                ld      h,a
 42+  0000                                  ENDM
 43+  0000
 44+  0000              NegD                MACRO
 45+  0000 ~                                ld      a,d
 46+  0000 ~                                neg
 47+  0000 ~                                ld      d,a
 48+  0000                                  ENDM
 49+  0000
 50+  0000              NegB                MACRO
 51+  0000 ~                                ld      a,b
 52+  0000 ~                                neg
 53+  0000 ~                                ld      b,a
 54+  0000                                  ENDM
 55+  0000
# file closed: ../Macros/NegateMacros.asm
 24   0000                                      INCLUDE "../Macros/returnMacros.asm"
# file opened: ../Macros/returnMacros.asm
  1+  0000              ReturnOnBitSet:         MACRO  reg, bitnbr
  2+  0000 ~                                    bit 	bitnbr,reg
  3+  0000 ~                                    ret     nz
  4+  0000                                      ENDM
  5+  0000
  6+  0000              ReturnOnMemBitSet:      MACRO mem, bitnbr
  7+  0000 ~                                    ld   a,(mem)
  8+  0000 ~                                    bit 	bitnbr,a
  9+  0000 ~                                    ret     nz
 10+  0000                                      ENDM
 11+  0000
 12+  0000              ReturnOnBitClear:       MACRO reg, bitnbr
 13+  0000 ~                                    bit 	bitnbr,reg
 14+  0000 ~                                    ret		z
 15+  0000                                      ENDM
 16+  0000
 17+  0000              ReturnOnMemBitClear:    MACRO mem, bitnbr
 18+  0000 ~                                    ld     a,(mem)
 19+  0000 ~                                    bit 	bitnbr,a
 20+  0000 ~                                    ret		z
 21+  0000                                      ENDM
 22+  0000
 23+  0000              ReturnIfMemFalse:       MACRO   mem
 24+  0000 ~                                    ld      a,(mem)
 25+  0000 ~                                    and     a
 26+  0000 ~                                    ret     nz
 27+  0000                                      ENDM
 28+  0000
 29+  0000              ReturnIfMemTrue:        MACRO   mem
 30+  0000 ~                                    ld      a,(mem)
 31+  0000 ~                                    and     a
 32+  0000 ~                                    ret     z
 33+  0000                                      ENDM
 34+  0000
 35+  0000              ReturnIfAIsZero:        MACRO
 36+  0000 ~                                    and     a
 37+  0000 ~                                    ret     z
 38+  0000                                      ENDM
 39+  0000
 40+  0000              ReturnIfMemisZero:      MACRO mem
 41+  0000 ~                                    ld   a,(mem)
 42+  0000 ~                                    and a
 43+  0000 ~                                    ret    z
 44+  0000                                      ENDM
 45+  0000
 46+  0000              ReturnIfMemIsNegative:  MACRO mem
 47+  0000 ~                                    ld      a,(mem)
 48+  0000 ~                                    and     $80
 49+  0000 ~                                    ret     nz
 50+  0000                                      ENDM
 51+  0000
 52+  0000              ReturnIfBitMaskClear    MACRO   bitmask
 53+  0000 ~                                    and     bitmask
 54+  0000 ~                                    ret     z
 55+  0000                                      ENDM
 56+  0000
 57+  0000              ReturnIfBitMaskSet      MACRO   bitmask
 58+  0000 ~                                    and     bitmask
 59+  0000 ~                                    ret     nz
 60+  0000                                      ENDM
 61+  0000
 62+  0000              ReturnIfMemEquN:        MACRO mem, value
 63+  0000 ~                                    ld     a,(mem)
 64+  0000 ~                                    cp     value
 65+  0000 ~                                    ret    nz
 66+  0000                                      ENDM
 67+  0000
 68+  0000              ReturnIfMemNeNusng:     MACRO mem, value
 69+  0000 ~                                    ld   a,(mem)
 70+  0000 ~                                    cp     value
 71+  0000 ~                                    ret    z
 72+  0000                                      ENDM
 73+  0000
 74+  0000              ReturnIfRegNotZero:     MACRO reg
 75+  0000 ~                                    ld      a, reg
 76+  0000 ~                                    and     a
 77+  0000 ~                                    ret     nz
 78+  0000                                      ENDM
 79+  0000
 80+  0000              ReturnIfANotZero:       MACRO
 81+  0000 ~                                    and     a
 82+  0000 ~                                    ret     nz
 83+  0000                                      ENDM
 84+  0000
 85+  0000              ReturnIfNotZero:        MACRO
 86+  0000 ~                                    ret     nz
 87+  0000                                      ENDM
 88+  0000
 89+  0000
 90+  0000              ReturnIfNegative:       MACRO
 91+  0000 ~                                    ret     m
 92+  0000                                      ENDM
 93+  0000
 94+  0000
 95+  0000              ReturnIfMemNotZero:     MACRO mem
 96+  0000 ~                                    ld     a,(mem)
 97+  0000 ~                                    and     a
 98+  0000 ~                                    ret    nz
 99+  0000                                      ENDM
100+  0000
101+  0000              ReturnIfAGTEusng:       MACRO value
102+  0000 ~                                    cp    value
103+  0000 ~                                    ret	 nc
104+  0000                                      ENDM
105+  0000
106+  0000              ReturnIfRegLTNusng:     MACRO reg, value
107+  0000 ~                                    ld      a,reg
108+  0000 ~                                    cp      value
109+  0000 ~                                    ret	    c
110+  0000                                      ENDM
111+  0000
112+  0000              ReturnIfALTNusng:       MACRO value
113+  0000 ~                                    cp    value
114+  0000 ~                                    ret	 c
115+  0000                                      ENDM
116+  0000
117+  0000              ReturnIfAGTENusng:      MACRO value
118+  0000 ~                                    cp    value
119+  0000 ~                                    ret	 nc
120+  0000                                      ENDM
121+  0000
122+  0000              ReturnIfAGTEMemusng:    MACRO value
123+  0000 ~                                    ld      hl,value
124+  0000 ~                                    cp      (hl)
125+  0000 ~                                    ret	    nc
126+  0000                                      ENDM
127+  0000
128+  0000              ReturnIfANENusng:       MACRO value
129+  0000 ~                                    cp      value
130+  0000 ~                                    ret     nz
131+  0000                                      ENDM
132+  0000
133+  0000              ReturnIfAEqNusng:       MACRO value
134+  0000 ~                                    cp      value
135+  0000 ~                                    ret     z
136+  0000                                      ENDM
137+  0000
# file closed: ../Macros/returnMacros.asm
 25   0000                                      INCLUDE "../Macros/ShiftMacros.asm"
# file opened: ../Macros/ShiftMacros.asm
  1+  0000              ShiftIYRight1: MACRO
  2+  0000 ~            			   ld 	a,iyh
  3+  0000 ~            			   srl 	a
  4+  0000 ~            			   ld	iyh,a
  5+  0000 ~            			   ld 	a,iyl
  6+  0000 ~            			   rra
  7+  0000 ~            			   ld	iyl,a
  8+  0000              			   ENDM
  9+  0000
 10+  0000              ShiftHLRight1: MACRO
 11+  0000 ~            			   srl h
 12+  0000 ~            			   rr  l
 13+  0000              			   ENDM
 14+  0000
 15+  0000              ShiftDERight1: MACRO
 16+  0000 ~            			   srl d
 17+  0000 ~            			   rr  e
 18+  0000              			   ENDM
 19+  0000
 20+  0000              ShiftBCRight1: MACRO
 21+  0000 ~            			   srl b
 22+  0000 ~            			   rr  c
 23+  0000              			   ENDM
 24+  0000
 25+  0000
 26+  0000
 27+  0000              ShiftHLDiv8:   MACRO
 28+  0000 ~            			   srl h
 29+  0000 ~            			   rr  l
 30+  0000 ~            			   srl h
 31+  0000 ~            			   rr  l
 32+  0000 ~            			   srl h
 33+  0000 ~            			   rr  l
 34+  0000              			   ENDM
 35+  0000
 36+  0000              ShiftHLLeft1:  MACRO
 37+  0000 ~            			   sla l
 38+  0000 ~            			   rl  h
 39+  0000              			   ENDM
 40+  0000
 41+  0000              ShiftDELeft1:  MACRO
 42+  0000 ~            			   sla e
 43+  0000 ~            			   rl  d
 44+  0000              			   ENDM
 45+  0000
 46+  0000
 47+  0000              RollDELeft1:   MACRO
 48+  0000 ~                           rl  e
 49+  0000 ~                           rl  d
 50+  0000                             ENDM
 51+  0000
 52+  0000              ShiftBCLeft1:  MACRO
 53+  0000 ~            			   sla c
 54+  0000 ~            			   rl  b
 55+  0000              			   ENDM
 56+  0000
 57+  0000              ShiftMem16Right1:   MACRO memaddr
 58+  0000 ~                                ld    hl,(memaddr)
 59+  0000 ~                                srl   h
 60+  0000 ~                                rr    l
 61+  0000 ~                                ld    (memaddr),hl
 62+  0000                                  ENDM
 63+  0000
 64+  0000              ShiftMem8Right1:    MACRO memaddr
 65+  0000 ~                                ld      a,(memaddr)
 66+  0000 ~                                srl     a
 67+  0000 ~                                ld      (memaddr),a
 68+  0000                                  ENDM
 69+  0000
 70+  0000
 71+  0000              ShiftMem8Left1A:    MACRO memaddr
 72+  0000 ~                                ld      a,(memaddr)
 73+  0000 ~                                sla     a
 74+  0000 ~                                ld      (memaddr),a
 75+  0000                                  ENDM
 76+  0000
# file closed: ../Macros/ShiftMacros.asm
 26   0000                                      INCLUDE "../Macros/signBitMacros.asm"
# file opened: ../Macros/signBitMacros.asm
  1+  0000              SetMemBitN              MACRO mem,bitnbr
  2+  0000 ~                                    ld      hl,mem
  3+  0000 ~                                    set     bitnbr,(hl)
  4+  0000                                      ENDM
  5+  0000
  6+  0000              ClearMemBitN            MACRO mem,bitnbr
  7+  0000 ~                                    ld      hl,mem
  8+  0000 ~                                    res     bitnbr,(hl)
  9+  0000                                      ENDM
 10+  0000
 11+  0000
 12+  0000              ClearSignBitMem:        MACRO mem
 13+  0000 ~                                    ld      a,(mem)
 14+  0000 ~                                    and     SignMask8Bit
 15+  0000 ~                                    ld      (mem),a
 16+  0000                                      ENDM
 17+  0000
 18+  0000              SetSignBitMem:          MACRO   mem
 19+  0000 ~                                    ld      a,(mem)
 20+  0000 ~                                    or      SignOnly8Bit
 21+  0000 ~                                    ld      (mem),a
 22+  0000                                      ENDM
 23+  0000
 24+  0000              FlipSignMem:            MACRO mem
 25+  0000 ~                                    ld  a,(mem)
 26+  0000 ~                                    xor SignOnly8Bit
 27+  0000 ~                                    ld  (mem),a
 28+  0000                                      ENDM
 29+  0000
 30+  0000              SignBitOnlyMem:         MACRO mem
 31+  0000 ~                                    ld      a, (mem)
 32+  0000 ~                                    and     SignOnly8Bit
 33+  0000 ~                                    ld      (mem),a
 34+  0000                                      ENDM
 35+  0000
 36+  0000              ClearSignBit:           MACRO reg
 37+  0000 ~                                    ld      a,reg
 38+  0000 ~                                    and     SignMask8Bit
 39+  0000 ~                                    ld      reg,a
 40+  0000                                      ENDM
 41+  0000
 42+  0000              SetSignBit:             MACRO   reg
 43+  0000 ~                                    ld      a,reg
 44+  0000 ~                                    or      SignOnly8Bit
 45+  0000 ~                                    ld      reg,a
 46+  0000                                      ENDM
 47+  0000
 48+  0000              FlipSignBit:            MACRO   reg
 49+  0000 ~                                    ld      a, reg
 50+  0000 ~                                    xor     SignOnly8Bit
 51+  0000 ~                                    ld      reg,a
 52+  0000                                      ENDM
 53+  0000
 54+  0000              SignBitOnly:            MACRO   reg
 55+  0000 ~                                    ld      a, reg
 56+  0000 ~                                    and     SignOnly8Bit
 57+  0000 ~                                    ld      reg,a
 58+  0000                                      ENDM
 59+  0000
 60+  0000              ClearSignBitA:          MACRO
 61+  0000 ~                                    and     SignMask8Bit
 62+  0000                                      ENDM
 63+  0000
 64+  0000              SetSignBitA:            MACRO
 65+  0000 ~                                    or      SignOnly8Bit
 66+  0000                                      ENDM
 67+  0000
 68+  0000              FlipSignBitA:           MACRO
 69+  0000 ~                                    xor     SignOnly8Bit
 70+  0000                                      ENDM
 71+  0000
 72+  0000              SignBitOnlyA:           MACRO
 73+  0000 ~                                    and     SignOnly8Bit
 74+  0000                                      ENDM
# file closed: ../Macros/signBitMacros.asm
 27   0000                                      INCLUDE "../Tables/message_queue_macros.asm"
# file opened: ../Tables/message_queue_macros.asm
  1+  0000
  2+  0000              AnyMessagesMacro:       MACRO   NoMessageTarget
  3+  0000 ~                                    ld      a, (MessageCount)
  4+  0000 ~                                    and     a
  5+  0000 ~                                    jr      z, NoMessageTarget
  6+  0000                                      ENDM
  7+  0000
  8+  0000              AnyHyperSpaceMacro:     MACRO   NoMessageText
  9+  0000 ~                                    ld      hl,(InnerHyperCount)
 10+  0000 ~                                    ld      a,h
 11+  0000 ~                                    or      l
 12+  0000 ~                                    jr      z, NoMessageText
 13+  0000                                      ENDM
 14+  0000
# file closed: ../Tables/message_queue_macros.asm
 28   0000                                      INCLUDE "../Variables/general_variables_macros.asm"
# file opened: ../Variables/general_variables_macros.asm
  1+  0000              ; limited to 255 character length
  2+  0000              CountLengthHL:          MACRO   Limiter
  3+  0000 ~                                    ld      de,hl
  4+  0000 ~                                    ld      bc,Limiter
  5+  0000 ~                                    xor     a
  6+  0000 ~                                    cpir
  7+  0000 ~                                    ClearCarryFlag
  8+  0000 ~                                    sbc     hl,de
  9+  0000 ~                                    ld      a,l
 10+  0000 ~                                    ret
 11+  0000                                      ENDM
 12+  0000
 13+  0000              IncMemMaxN:             MACRO   mem, maxvalue
 14+  0000 ~                                    ld      a,(mem)
 15+  0000 ~                                    cp      maxvalue
 16+  0000 ~                                    jr      c,.IncMaxed
 17+  0000 ~                                    inc     a
 18+  0000 ~                                    ld      (mem),a
 19+  0000 ~            .IncMaxed:
 20+  0000                                      ENDM
 21+  0000
 22+  0000              IncMemMaxNCycle:        MACRO   mem, cyclevalue
 23+  0000 ~                                    ld      a,(mem)
 24+  0000 ~                                    inc     a
 25+  0000 ~                                    cp      cyclevalue
 26+  0000 ~                                    jr      c,.IncMaxed
 27+  0000 ~                                    xor     a
 28+  0000 ~            .IncMaxed:              ld      (mem),a
 29+  0000                                      ENDM
 30+  0000
 31+  0000
 32+  0000              HalfLengthHL:           MACRO
 33+  0000 ~                                    ld      b,0
 34+  0000 ~            .CountLenLoop:          ld      a,(hl)
 35+  0000 ~                                    cp      0
 36+  0000 ~                                    jr      z,.DoneCount
 37+  0000 ~                                    inc     b
 38+  0000 ~                                    inc     hl
 39+  0000 ~                                    jr      .CountLenLoop
 40+  0000 ~            .DoneCount:             ld      a,32
 41+  0000 ~                                    sub     b
 42+  0000 ~                                    sra     a
 43+  0000                                      ENDM
 44+  0000
 45+  0000              MakeInnocentMacro:		MACRO
 46+  0000 ~            						xor		a
 47+  0000 ~            						ld		(FugitiveInnocentStatus),a
 48+  0000              						ENDM
 49+  0000
 50+  0000              NoEscapePodMacro:		MACRO
 51+  0000 ~            						xor		a
 52+  0000 ~            						ld		(EscapePod),a
 53+  0000              						ENDM
 54+  0000
 55+  0000              MaxFuelLevel            EQU     70              ; 7.0 light years max
 56+  0000              MaxFuelMacro:			MACRO
 57+  0000 ~            						ld		a,MaxFuelLevel
 58+  0000 ~            						ld		(Fuel),a
 59+  0000              						ENDM
 60+  0000
 61+  0000              MaxThrottle:            MACRO
 62+  0000 ~                                    ld      a,(SHIPMAXSPEED)
 63+  0000 ~                                    ld      (DELTA),a
 64+  0000 ~                                    ld      d,a
 65+  0000 ~                                    ld      e,4
 66+  0000 ~                                    mul
 67+  0000 ~                                    ld      (DELT4Lo),de
 68+  0000                                      ENDM
 69+  0000
 70+  0000              ZeroThrottle:           MACRO
 71+  0000 ~                                    xor     a
 72+  0000 ~                                    ld      (DELTA),a
 73+  0000 ~                                    ld      (DELT4Lo),a
 74+  0000 ~                                    ld      (DELT4Lo+1),a
 75+  0000                                      ENDM
 76+  0000
 77+  0000              ZeroPitch:              MACRO
 78+  0000 ~                                    xor     a
 79+  0000 ~                                    ld      (BET2),a
 80+  0000 ~                                    ld      (BET2FLIP),a
 81+  0000 ~                                    ld      (JSTY),a
 82+  0000 ~                                    ld      (BETA),a
 83+  0000                                      ENDM
 84+  0000
 85+  0000              ZeroRoll:               MACRO
 86+  0000 ~                                    xor     a                              ; zero roll and climb
 87+  0000 ~                                    ld      (ALP2),a
 88+  0000 ~                                    ld      (ALP2FLIP),a
 89+  0000 ~                                    ld      (JSTX),a
 90+  0000 ~                                    ld      (ALPHA),a
 91+  0000                                      ENDM
 92+  0000
 93+  0000              CorrectPostJumpFuel:    MACRO
 94+  0000 ~                                    ld      a,(Fuel)
 95+  0000 ~                                    ld      hl,Distance
 96+  0000 ~                                    sub     a,(hl)
 97+  0000 ~                                    ld      (Fuel),a
 98+  0000                                      ENDM
 99+  0000
100+  0000              AnyMissilesLeft:        MACRO
101+  0000 ~                                    ld      a,(NbrMissiles)
102+  0000 ~                                    and     a
103+  0000                                      ENDM
104+  0000
105+  0000              SetMissileTargetA:      MACRO
106+  0000 ~                                    ld      (MissileTargettingFlag),a   ; Set to slot number clearing bit 7
107+  0000                                      ENDM
108+  0000
109+  0000              IsMissileLaunchFlagged: MACRO
110+  0000 ~                                    ld      a,(MissileTargettingFlag)
111+  0000 ~                                    and     $80
112+  0000                                      ENDM
113+  0000
114+  0000              SetMissileTargetting:   MACRO
115+  0000 ~                                    ld      a,StageMissileTargeting
116+  0000 ~                                    ld      (MissileTargettingFlag),a
117+  0000                                      ENDM
118+  0000
119+  0000              ClearMissileTargetting: MACRO
120+  0000 ~                                    ld      a,StageMissileNotTargeting
121+  0000 ~                                    ld      (MissileTargettingFlag),a
122+  0000                                      ENDM
123+  0000
124+  0000
125+  0000              ; Clear targetting bits which signals launch if lower nibble has selected target
126+  0000              SetMissileLaunch:       MACRO
127+  0000 ~                                    ld      a,(MissileTargettingFlag)
128+  0000 ~                                    and     $0F
129+  0000 ~                                    ld      (MissileTargettingFlag),a
130+  0000                                      ENDM
131+  0000
132+  0000              LockMissileToA:         MACRO
133+  0000 ~                                    or      $80
134+  0000 ~                                    ld      (MissileTargettingFlag),a
135+  0000                                      ENDM
136+  0000
137+  0000              ClearECM:               MACRO
138+  0000 ~                                    xor     a
139+  0000 ~                                    ld      (ECMCountDown),a
140+  0000                                      ENDM
141+  0000
142+  0000
143+  0000              ; Will check to see if bit 2 is set, if it is clear, then friendly hence z is set
144+  0000              ;                                    if hit is set then hostile hence z is not set
145+  0000              IsShipFriendly:         MACRO
146+  0000 ~                                    ld      a,(ShipNewBitsAddr)
147+  0000 ~                                    and     ShipNotHostile                  ; mask so we only have hostile bit
148+  0000                                      ENDM
149+  0000
150+  0000              ; Will check to see if bit 5 is set, if clear, then not exploding z clear
151+  0000              ;                                    if set    then exploding     z set
152+  0000              IsShipExploding:        MACRO
153+  0000 ~                                    ld      a,(UBnkaiatkecm)
154+  0000 ~                                    and     ShipExploding
155+  0000                                      ENDM
156+  0000
157+  0000              UpdateLaserOnCounter:   MACRO
158+  0000 ~                                    ld      a,(CurrLaserPulseOnCount)
159+  0000 ~                                    and     a
160+  0000 ~                                    jr      z,.LaserOnIsDone
161+  0000 ~                                    dec     a
162+  0000 ~                                    ld      (CurrLaserPulseOnCount),a
163+  0000 ~                                    jr      z,.LaserOnIsDone
164+  0000 ~                                    ldCopyByte CurrLaserPulseOffTime, CurrLaserPulseOffCount
165+  0000 ~            .LaserOnIsDone:
166+  0000                                      ENDM
167+  0000
168+  0000              UpdateLaserOffCounter:  MACRO
169+  0000 ~                                    ld      a,(CurrLaserPulseOffTime)
170+  0000 ~                                    and     a
171+  0000 ~                                    jr      z,.LaserOffIsDone
172+  0000 ~                                    dec     a
173+  0000 ~                                    ld      (CurrLaserPulseOffTime),a
174+  0000 ~                                    jr      z,.LaserOffIsDone
175+  0000 ~                                    ldCopyByte CurrLaserPulseRest, CurrLaserPulseRestCount
176+  0000 ~            .LaserOffIsDone:
177+  0000                                      ENDM
178+  0000
179+  0000              UpdateLaserRestCounter: MACRO
180+  0000 ~                                    ld      a,(CurrLaserPulseRestCount)
181+  0000 ~                                    and     a
182+  0000 ~                                    jr      z,.LaserRestIsDone
183+  0000 ~                                    dec     a
184+  0000 ~                                    ld      (CurrLaserPulseRestCount),a
185+  0000 ~                                    jr      z,.LaserRestIsDone
186+  0000 ~                                    ZeroA                                                                           ;    then pulse rate count = 0
187+  0000 ~                                    ld      (CurrLaserPulseRateCount),a                                             ;    .
188+  0000 ~            .LaserRestIsDone
189+  0000                                      ENDM
190+  0000
191+  0000              ChargeEnergyAndShields: MACRO
192+  0000 ~                                    ld      a,$FF
193+  0000 ~                                    ld      (PlayerEnergy),a
194+  0000 ~                                    ld      (ForeShield),a
195+  0000 ~                                    ld      (AftShield),a
196+  0000                                      ENDM
197+  0000
198+  0000              CopyPresentSystemToTarget: MACRO
199+  0000 ~                                    ld      hl,(PresentSystemX)
200+  0000 ~                                    ld      (TargetSystemX),hl
201+  0000                                      ENDM
202+  0000
203+  0000              CopyTargetSystemToPresent: MACRO
204+  0000 ~                                    ld      hl,(TargetSystemX)
205+  0000 ~                                    ld      (PresentSystemX),hl
206+  0000                                      ENDM
207+  0000
208+  0000              HalveFugitiveStatus:    MACRO
209+  0000 ~                                    ld      hl,FugitiveInnocentStatus
210+  0000 ~                                    srl     (hl)
211+  0000                                      ENDM
212+  0000
213+  0000              ClearForceTransition    MACRO
214+  0000 ~                                    ld      a,$FF
215+  0000 ~                                    ld      (ScreenTransitionForced),a
216+  0000                                      ENDM
217+  0000
218+  0000              ForceTransition:        MACRO newScreen
219+  0000 ~                                    ld      a,newScreen
220+  0000 ~                                    ld      (ScreenTransitionForced), a
221+  0000                                      ENDM
222+  0000
223+  0000              IsSpaceStationPresent:  MACRO
224+  0000 ~                                    ld      a,(SpaceStationSafeZone)
225+  0000 ~                                    and     a
226+  0000                                      ENDM
227+  0000
228+  0000              SetSafeZone:            MACRO
229+  0000 ~                                    xor     a
230+  0000 ~                                    ld      (SpaceStationSafeZone),a
231+  0000                                      ENDM
232+  0000
233+  0000              ClearSafeZone:          MACRO
234+  0000 ~                                    ld      a,$FF
235+  0000 ~                                    ld      (SpaceStationSafeZone),a
236+  0000                                      ENDM
237+  0000
238+  0000              ClearTemperatures:      MACRO
239+  0000 ~                                    xor     a
240+  0000 ~                                    ld      (CabinTemperature),a
241+  0000 ~                                    ld      (GunTemperature),a
242+  0000                                      ENDM
243+  0000
244+  0000              CoolCabin:              MACRO
245+  0000 ~                                    ld      a,(CabinTemperature)
246+  0000 ~                                    and     a
247+  0000 ~                                    jr      z,.AlreadyCool
248+  0000 ~                                    dec     a
249+  0000 ~                                    ld      (CabinTemperature),a
250+  0000 ~            .AlreadyCool:
251+  0000                                      ENDM
252+  0000
253+  0000              CoolLasers:             MACRO
254+  0000 ~                                    ld      a,(GunTemperature)
255+  0000 ~                                    and     a
256+  0000 ~                                    jr      z,.AlreadyCool
257+  0000 ~                                    dec     a
258+  0000 ~                                    ld      (GunTemperature),a
259+  0000 ~            .AlreadyCool:
260+  0000                                      ENDM
261+  0000
262+  0000              ; type 255 is "not fitted"
263+  0000
264+  0000
265+  0000              InitEventCounter:       MACRO
266+  0000 ~                                    xor     a
267+  0000 ~                                    ld      (EventCounter),a
268+  0000                                      ENDM
269+  0000
270+  0000              ClearMissJump:          MACRO
271+  0000 ~                                    ld      a,$FF
272+  0000 ~                                    ld      (MissJumpFlag),a
273+  0000                                      ENDM
274+  0000
275+  0000
276+  0000              DrainSystem:            MACRO   SystemMem, DrainMem
277+  0000 ~                                    ld      a,(DrainMem)
278+  0000 ~                                    ld      b,a
279+  0000 ~                                    ld      a,(SystemMem)
280+  0000 ~                                    sub     a,b
281+  0000 ~                                    ld      (SystemMem),a
282+  0000 ~                                    jr      c,.ZeroSystem
283+  0000 ~                                    jp      .ExitPoint
284+  0000 ~            .ZeroSystem:            ZeroA
285+  0000 ~                                    ld      (SystemMem),a
286+  0000 ~            .ExitPoint
287+  0000                                      ENDM
288+  0000
289+  0000              BoostSystem:            MACRO   SystemMem, BoostMem
290+  0000 ~                                    ld      a,(BoostMem)
291+  0000 ~                                    ld      b,a
292+  0000 ~                                    ld      a,(SystemMem)
293+  0000 ~                                    add     b
294+  0000 ~                                    ld      (SystemMem),a
295+  0000 ~                                    jr      c, .MaxSystem
296+  0000 ~                                    jp      .ExitPoint
297+  0000 ~            .MaxSystem:             ld      a,255
298+  0000 ~                                    ld      (SystemMem),a
299+  0000 ~            .ExitPoint
300+  0000                                      ENDM
301+  0000
# file closed: ../Variables/general_variables_macros.asm
 29   0000                                      INCLUDE "../Variables/UniverseSlot_macros.asm"
# file opened: ../Variables/UniverseSlot_macros.asm
  1+  0000
  2+  0000              AddJunkCount:           MACRO
  3+  0000 ~                                    ld      hl,JunkCount
  4+  0000 ~                                    inc     (hl)
  5+  0000                                      ENDM
  6+  0000
  7+  0000              SubJunkCount:           MACRO
  8+  0000 ~                                    ld      hl,JunkCount
  9+  0000 ~                                    dec     (hl)
 10+  0000                                      ENDM
 11+  0000
 12+  0000              AddCop:                 MACRO
 13+  0000 ~                                    ld      hl,CopCount
 14+  0000 ~                                    inc     (hl)
 15+  0000                                      ENDM
 16+  0000
 17+  0000              SubCop:                 MACRO
 18+  0000 ~                                    ld      hl,CopCount
 19+  0000 ~                                    dec     (hl)
 20+  0000                                      ENDM
 21+  0000
 22+  0000              AddPirateCount:         MACRO
 23+  0000 ~                                    ld      hl,PirateCount
 24+  0000 ~                                    inc     (hl)
 25+  0000                                      ENDM
 26+  0000
 27+  0000              SubPirateCount:         MACRO
 28+  0000 ~                                    ld      hl,PirateCount
 29+  0000 ~                                    inc     (hl)
 30+  0000                                      ENDM
 31+  0000
 32+  0000              AreCopsPresent:         MACRO
 33+  0000 ~                                    ld      a,(CopCount)
 34+  0000 ~                                    and     a
 35+  0000                                      ENDM
 36+  0000
 37+  0000              ; Class == shiptype
 38+  0000              SetSlotAToUnivClass:    MACRO
 39+  0000 ~                                    ex      af,af'
 40+  0000 ~                                    ld      a,(ShipTypeAddr)
 41+  0000 ~                                    ld      b,a
 42+  0000 ~                                    ex      af,af'
 43+  0000 ~                                    call    SetSlotAToClassB
 44+  0000                                      ENDM
 45+  0000
 46+  0000              TestRoomForJunk:        MACRO   Target
 47+  0000 ~                                    ld      a,3
 48+  0000 ~                                    JumpIfALTMemusng    JunkCount, Target
 49+  0000                                      ENDM
 50+  0000
 51+  0000              JumpIfSpaceStation:     MACRO   Target
 52+  0000 ~                                    ld      hl,UniverseSlotType
 53+  0000 ~                                    ld      a,(hl)
 54+  0000 ~                                    cp      ShipTypeStation
 55+  0000                                      ENDM
 56+  0000
 57+  0000              ClearSlotMem:           MACRO   mem
 58+  0000 ~                                    ld      a,(mem)
 59+  0000 ~                                    call    ClearSlotA
 60+  0000                                      ENDM
 61+  0000
 62+  0000              IsSlotEmpty:            MACRO
 63+  0000 ~                                    ld      hl,UniverseSlotList
 64+  0000 ~                                    add     hl,a
 65+  0000 ~                                    ld      a,(hl)
 66+  0000 ~                                    cp      0
 67+  0000                                      ENDM
 68+  0000
 69+  0000              IsSlotMissile:          MACRO
 70+  0000 ~                                    ld      hl,UniverseSlotType
 71+  0000 ~                                    add     hl,a
 72+  0000 ~                                    ld      a,(hl)
 73+  0000 ~                                    cp      ShipTypeMissile
 74+  0000                                      ENDM
 75+  0000
 76+  0000
 77+  0000              ; Checks if slot is empty else A = ship type
 78+  0000              ReturnIfSlotAEmpty:     MACRO
 79+  0000 ~                                    ld      hl,UniverseSlotList
 80+  0000 ~                                    add     hl,a
 81+  0000 ~                                    ld      a,(hl)
 82+  0000 ~                                    inc     a
 83+  0000 ~                                    ret     z           ; if slot was ff inc would make it 0
 84+  0000 ~                                    dec     a           ; get original value back for later
 85+  0000                                      ENDM
 86+  0000
 87+  0000              JumpIfSlotAEmpty:       MACRO   Target
 88+  0000 ~                                    ld      hl,UniverseSlotList
 89+  0000 ~                                    add     hl,a
 90+  0000 ~                                    ld      a,(hl)
 91+  0000 ~                                    inc     a
 92+  0000 ~                                    jp      z,Target    ; if slot was ff inc would make it 0
 93+  0000 ~                                    dec     a           ; get original value back for later
 94+  0000                                      ENDM
 95+  0000
 96+  0000              JumpIfSlotHLEmpty:      MACRO   Target
 97+  0000 ~                                    ld      a,(hl)
 98+  0000 ~                                    and     a
 99+  0000 ~                                    jr      nz,Target
100+  0000                                      ENDM
# file closed: ../Variables/UniverseSlot_macros.asm
 30   0000                                      INCLUDE "../Variables/constant_equates.asm"
# file opened: ../Variables/constant_equates.asm
  1+  0000              ;Contants
  2+  0000
  3+  0000              SignMask8Bit		equ %01111111
  4+  0000              SignMask16Bit		equ %0111111111111111
  5+  0000              SignOnly8Bit		equ $80
  6+  0000              SignOnly16Bit		equ $8000
  7+  0000
  8+  0000              Bit7Only            equ %10000000
  9+  0000              Bit6Only            equ %01000000
 10+  0000              Bit5Only            equ %00100000
 11+  0000              Bit4Only            equ %00010000
 12+  0000              Bit3Only            equ %00001000
 13+  0000              Bit2Only            equ %00000100
 14+  0000              Bit1Only            equ %00000010
 15+  0000              Bit0Only            equ %00000001
 16+  0000              Bit7Clear           equ %01111111
 17+  0000              Bit6Clear           equ %10111111
 18+  0000              Bit5Clear           equ %11011111
 19+  0000              Bit4Clear           equ %11101111
 20+  0000              Bit3Clear           equ %11110111
 21+  0000              Bit2Clear           equ %11111011
 22+  0000              Bit1Clear           equ %11111101
 23+  0000              Bit0Clear           equ %11111110
 24+  0000              ConstPi				equ $80
 25+  0000              ConstNorm           equ 197
 26+  0000
 27+  0000              ;Text Tokens
 28+  0000              EliteToken			equ $1E			; Token ID for text messsage ---- E L I T E ----
 29+  0000              BrabenBellToken 	equ $0D
 30+  0000              AcorToken			equ $0C
 31+  0000              ; Cursor Bits
 32+  0000              CursorClimb         equ %10000000
 33+  0000              CursorDive          equ %01000000
 34+  0000              CursorLeft          equ %00100000
 35+  0000              CursorRight         equ %00010000
 36+  0000              CursorHome          equ %00001000
 37+  0000              CursorRecenter      equ %00000100
 38+  0000
 39+  0000              ; Intro Screen
 40+  0000              TitleShip			equ	$8C
 41+  0000              RotationUnity		equ $60
 42+  0000              DBCheckCode			equ $DB
 43+  0000              MaxVisibility		equ $1F
 44+  0000              FarInFront			equ $C0
 45+  0000              ; Equipment Flags
 46+  0000              EquipmentItemFitted     equ $FF
 47+  0000              EquipmentItemNotFitted  equ 0
 48+  0000              ; Universe Managment
 49+  0000              ShipTotalModelCount     equ 44
 50+  0000              ShipTypeScoopable       equ 4         ; a sub set of junk
 51+  0000              ShipTypeJunk            equ 3
 52+  0000              ShipTypeStation         equ 2
 53+  0000              ShipTypeMissile         equ 1
 54+  0000              ShipTypeNormal          equ 0
 55+  0000              ShipTypeText            equ 253
 56+  0000              ShipTypeDebug           equ 254
 57+  0000              ShipTypeEmpty           equ 255
 58+  0000              ; TacticsControl
 59+  0000              ShipAngryNewBitNbr      equ 4
 60+  0000              ShipExplosionDuration   equ 75         ; amount of frames an explosion lasts for
 61+  0000              ShipIsTrader            equ Bit0Only   ; Trader flag  80% are peaceful 20% also have Bounty Hunter flag
 62+  0000              ShipIsBountyHunter      equ Bit1Only   ;
 63+  0000              ShipIsHostile           equ Bit2Only   ;
 64+  0000              ShipNotHostile          equ Bit2Clear   ;
 65+  0000              ShipIsPirate            equ Bit3Only   ;
 66+  0000              ShipIsDot               equ Bit3Only
 67+  0000              ShipIsNotDot            equ Bit3Clear
 68+  0000              ShipIsDotBitNbr         equ 3
 69+  0000              ShipKilled              equ Bit4Only    ; Ship has just been marked as killed so initiate cloud of debris
 70+  0000              ShipKilledBitNbr        equ 4
 71+  0000              ShipIsDocking           equ Bit4Only   ;
 72+  0000              ShipIsBystander         equ Bit5Only   ;
 73+  0000              ShipIsVisible           equ Bit6Only
 74+  0000              ShipIsVisibleBitNbr     equ 6
 75+  0000              ShipIsCop               equ Bit6Only   ;
 76+  0000              ShipIsScoopDockEsc      equ Bit7Only   ;
 77+  0000              ShipAIEnabled           equ Bit7Only   ;
 78+  0000              ShipAIDisabled          equ Bit7Clear
 79+  0000              ShipAIEnabledBitNbr     equ 7
 80+  0000              ShipExploding           equ Bit5Only
 81+  0000              ShipExplodingBitNbr     equ 5
 82+  0000              ; Equipment Defaults
 83+  0000              ECMCounterMax           equ $80
 84+  0000              ; Main Loop State
 85+  0000              StatePlayerDocked       equ $FF
 86+  0000              StateCompletedLaunch    equ $FD
 87+  0000              StateInTransition       equ $FE
 88+  0000              StateHJumping           equ $FC
 89+  0000              StateHEntering          equ $FB
 90+  0000              StateCompletedHJump     equ $FA
 91+  0000              StateNormal             equ 0
 92+  0000              ; Missile Stage flags , $8x = locked to ship id x, $0x = fire at ship id x requested
 93+  0000              StageMissileNotTargeting equ $FF
 94+  0000              StageMissileTargeting   equ $FE
 95+  0000              ; UniverseAIControl
 96+  0000              ShipCanAnger        equ %00000001
 97+  0000
 98+  0000
 99+  0000              ShipMaxDistance     equ 192
100+  0000              HyperSpaceTimers    equ $0B0B
101+  0000
102+  0000
103+  0000              MaxNumberOfStars	equ 11
104+  0000              ConsoleRefreshInterval  equ 5
105+  0000
106+  0000              ShipTypeSize		equ	32 			;??????? just a guess for now
107+  0000              ShipSST				equ 4			; its a space station
108+  0000              UniverseBasePage 	equ 70			; Base memory bank for universe Item #0
109+  0000              ShipDataBasePage	equ	90			; Needs 2mb upgrade but what the heck
110+  0000              ShipCountMax		equ	2			; For now just 2 ships to debug
111+  0000              LineLimitPerShip	equ 70			; Max lines per ship
112+  0000              FaceLimitPerShip	equ	70			; Same as line limit to simplify some logic
113+  0000              ; "NEED TO DEFINE SHIPTYPESIZE TODO"
114+  0000
115+  0000              ; Memory page managment	(Refers to a memory slot as a place to access data)
116+  0000              ShipDataSlot		equ	6			; this may move into rom swap out space later
117+  0000              UniverseObjectSlot	equ	7
118+  0000
119+  0000              KeyForwardsView		equ	$20
120+  0000              ; Game specific equates
121+  0000              MissileDropHeight   equ 5           ; how far the missile is ejected on launch in y axis
122+  0000
123+  0000              ;...Game Colour Mapping
124+  0000              L2DustColour        equ L2ColourGREY_1
125+  0000              L2SunScannerBright  equ 252
126+  0000              L2SunScanner        equ 180
127+  0000              L2DebrisColour      equ L2ColourYELLOW_1
128+  0000
129+  0000
130+  0000              ; Ship Data
131+  0000              ;;;;	.XX21	\ -> &5600 \ Table of pointers to ships' data given to XX0
132+  0000              ;;;;00 7F			 EQUW &7F00 \ type  1 is #MSL  Missile data on page off bottom of screen
133+  0000              ;;;;00 00			 EQUW 0     \ type  2 is #SST  Space Station, Coriolis or Dodo.
134+  0000              ;;;;00 00			 EQUW 0     \ type  3 is #ESC  Escape capsule
135+  0000              ;;;;00 00			 EQUW 0     \ type  4 is #PLT  Plate, alloys
136+  0000              ;;;;00 00			 EQUW 0     \ type  5 is #OIL  Cargo cannister
137+  0000              ;;;;00 00			 EQUW 0     \ type  6 is       Boulder
138+  0000              ;;;;00 00			 EQUW 0     \ type  7 is #AST  Asteroid
139+  0000              ;;;;00 00			 EQUW 0     \ type  8 is #SPL  Splinter, rock.
140+  0000              ;;;;00 00			 EQUW 0     \ type  9 is #SHU  Shuttle
141+  0000              ;;;;00 00			 EQUW 0     \ type 10 is       Transporter
142+  0000              ;;;;00 00			 EQUW 0     \ type 11 is #CYL  Cobra Mk III,  Boa
143+  0000              ;;;;00 00			 EQUW 0     \ type 12 is       Python
144+  0000              ;;;;00 00			 EQUW 0     \ type 13 is       Last of three traders
145+  0000              ;;;;00 00			 EQUW 0     \ type 14 is #ANA  Anaconda
146+  0000              ;;;;00 00			 EQUW 0     \ type 15 is #WRM  Worm with Anaconda
147+  0000              ;;;;00 00			 EQUW 0     \ type 16 is #COP  Viper
148+  0000              ;;;;00 00			 EQUW 0     \ type 17 is       First pirate
149+  0000              ;;;;00 00			 EQUW 0     \ type 18 is
150+  0000              ;;;;00 00			 EQUW 0     \ type 19 is #KRA  Krait small pirate
151+  0000              ;;;;00 00			 EQUW 0     \ type 20 is #ADA  Adder
152+  0000              ;;;;00 00			 EQUW 0     \ type 21 is
153+  0000              ;;;;00 00			 EQUW 0     \ type 22 is
154+  0000              ;;;;00 00			 EQUW 0     \ type 23 is
155+  0000              ;;;;00 00			 EQUW 0     \ type 24 is #CYL2 Last strong pirate
156+  0000              ;;;;00 00			 EQUW 0     \ type 25 is #ASP  Asp Mk II
157+  0000              ;;;;00 00			 EQUW 0     \ type 26 is #FER  Fer de Lance
158+  0000              ;;;;00 00			 EQUW 0     \ type 27 is
159+  0000              ;;;;00 00			 EQUW 0     \ type 28 is	Last of three bounty hunters
160+  0000              ;;;;00 00			 EQUW 0     \ type 29 is #THG  Thargoid
161+  0000              ;;;;00 00			 EQUW 0     \ type 30 is #TGL  Thargon
162+  0000              ;;;;00 00			 EQUW 0     \ type 31 is #CON  Constrictor
163+  0000              ;;;;	.E%	\ -> &563E \ Hull NEWB bits are escpod, cop, inno, ?, pirate, angry, hunter, trader.
164+  0000              ;;;;			\ NEWB examples
165+  0000              ;;;;\ 21			EQUB &21    \ 0010 0001    9 Shuttle has no escape pod, inno, trader.
166+  0000              ;;;;\ 61			EQUB &61    \ 0110 0001   10 Tansporter no escape pod, Cop, inno, trader.
167+  0000              ;;;;\ A0			EQUB &A0    \ 1010 0000   11 Cobra has Escape pod, inno, not a trader.
168+  0000              ;;;;\ C2			EQUB &C2    \ 1100 0010   16 Viper has Escape pod, Cop, hunter.
169+  0000              ;;;;\ 8C			EQUB &8C    \ 1000 1100   19 Krait pirate has escape pod, is pirate and angry.
170+  0000
# file closed: ../Variables/constant_equates.asm
 31   0000
 32   0000              testStartup:            ORG         $8000
 33   8000
 34   8000              SetXX15:            MACRO val1, val2,val3
 35   8000 ~                                ld  a,val1
 36   8000 ~                                ld  (XX15VecX),a
 37   8000 ~                                ld  a,val2
 38   8000 ~                                ld  (XX15VecY),a
 39   8000 ~                                ld  a,val3
 40   8000 ~                                ld  (XX15VecZ),a
 41   8000                                  ENDM
 42   8000
 43   8000              testMaths:
 44   8000              ; "Testing Maths"
 45   8000              ;16 0A DD -> 22  10 -93
 46   8000              ; 93 60 E0 -> 23  55 -96
 47   8000
 48   8000              test1:
 49   8000                              SetXX15 16,32,$80 | 1           ; 57 2B 91 -> 87  43 -1 Seems wrong X & Y wrong way round?
 49   8000 3E 10       >                    ld  a,16
 49   8002 32 0F 81    >                    ld  (XX15VecX),a
 49   8005 3E 20       >                    ld  a,32
 49   8007 32 10 81    >                    ld  (XX15VecY),a
 49   800A 3E 81       >                    ld  a,$80 | 1
 49   800C 32 11 81    >                    ld  (XX15VecZ),a
 50   800F CD 61 83                     call NormalizeXX15
 51   8012 DD 01                        break
 52   8014                              SetXX15 $80 | 16,37,$80 | 1     ; 90 37 91 -> 23  55 -1
 52   8014 3E 90       >                    ld  a,$80 | 16
 52   8016 32 0F 81    >                    ld  (XX15VecX),a
 52   8019 3E 25       >                    ld  a,37
 52   801B 32 10 81    >                    ld  (XX15VecY),a
 52   801E 3E 81       >                    ld  a,$80 | 1
 52   8020 32 11 81    >                    ld  (XX15VecZ),a
 53   8023 CD 61 83                     call NormalizeXX15
 54   8026 DD 01                        break
 55   8028                              SetXX15 0,0,96                  ; 00 00 60 -> 00  00 96 Good
 55   8028 3E 00       >                    ld  a,0
 55   802A 32 0F 81    >                    ld  (XX15VecX),a
 55   802D 3E 00       >                    ld  a,0
 55   802F 32 10 81    >                    ld  (XX15VecY),a
 55   8032 3E 60       >                    ld  a,96
 55   8034 32 11 81    >                    ld  (XX15VecZ),a
 56   8037 CD 61 83                     call NormalizeXX15
 57   803A DD 01                        break
 58   803C                              SetXX15 0,0,$E0                 ; 00 60 9F -> 00  96 -31 Error
 58   803C 3E 00       >                    ld  a,0
 58   803E 32 0F 81    >                    ld  (XX15VecX),a
 58   8041 3E 00       >                    ld  a,0
 58   8043 32 10 81    >                    ld  (XX15VecY),a
 58   8046 3E E0       >                    ld  a,$E0
 58   8048 32 11 81    >                    ld  (XX15VecZ),a
 59   804B CD 61 83                     call NormalizeXX15
 60   804E DD 01                        break
 61   8050                              SetXX15 0,96,0                  ; 60 00 60 -> 96  00  96 Error
 61   8050 3E 00       >                    ld  a,0
 61   8052 32 0F 81    >                    ld  (XX15VecX),a
 61   8055 3E 60       >                    ld  a,96
 61   8057 32 10 81    >                    ld  (XX15VecY),a
 61   805A 3E 00       >                    ld  a,0
 61   805C 32 11 81    >                    ld  (XX15VecZ),a
 62   805F CD 61 83                     call NormalizeXX15
 63   8062 DD 01                        break
 64   8064                              SetXX15 $E0,0,0                 ; 80 00 60 -> -0  96  0 Error
 64   8064 3E E0       >                    ld  a,$E0
 64   8066 32 0F 81    >                    ld  (XX15VecX),a
 64   8069 3E 00       >                    ld  a,0
 64   806B 32 10 81    >                    ld  (XX15VecY),a
 64   806E 3E 00       >                    ld  a,0
 64   8070 32 11 81    >                    ld  (XX15VecZ),a
 65   8073 CD 61 83                     call NormalizeXX15
 66   8076 DD 01                        break
 67   8078                              SetXX15 $80 | 48,0,0            ; 80 00 60 -> -0  96  0 Error
 67   8078 3E B0       >                    ld  a,$80 | 48
 67   807A 32 0F 81    >                    ld  (XX15VecX),a
 67   807D 3E 00       >                    ld  a,0
 67   807F 32 10 81    >                    ld  (XX15VecY),a
 67   8082 3E 00       >                    ld  a,0
 67   8084 32 11 81    >                    ld  (XX15VecZ),a
 68   8087 CD 61 83                     call NormalizeXX15
 69   808A DD 01                        break
 70   808C                              SetXX15 $80 | 60,$80 | 48,$80 | 48            ; 80 00 60 -> -0  96  0 Error
 70   808C 3E BC       >                    ld  a,$80 | 60
 70   808E 32 0F 81    >                    ld  (XX15VecX),a
 70   8091 3E B0       >                    ld  a,$80 | 48
 70   8093 32 10 81    >                    ld  (XX15VecY),a
 70   8096 3E B0       >                    ld  a,$80 | 48
 70   8098 32 11 81    >                    ld  (XX15VecZ),a
 71   809B CD 61 83                     call NormalizeXX15
 72   809E DD 01                        break
 73   80A0
 74   80A0
 75   80A0
 76   80A0
 77   80A0 00           varP            DB 0
 78   80A1 00           varU                    DB  0               ;   80
 79   80A2 00           varQ					DB  0 				;	81
 80   80A3 00           varR					DB  0 				;	82
 81   80A4 00           varS					DB  0 				;	83
 82   80A5 00           varT					DB  0 				;	83
 83   80A6              varRS                   equ varR
 84   80A6
 85   80A6                  INCLUDE "../Maths/asm_square.asm"
# file opened: ../Maths/asm_square.asm
  1+  80A6              ; "ASM_SQUA : TESTGOOD"
  2+  80A6              ; "AP = A^2 A = low,P = hi"
  3+  80A6
  4+  80A6              inline_squde: MACRO
  5+  80A6 ~            			ld	e,a
  6+  80A6 ~            			ld  d,a
  7+  80A6 ~            			mul
  8+  80A6              			ENDM
  9+  80A6
 10+  80A6              inline_squa: MACRO
 11+  80A6 ~            			ld	e,a
 12+  80A6 ~            			ld  d,a
 13+  80A6 ~            			mul
 14+  80A6 ~            			ld	a,e
 15+  80A6              			ENDM
 16+  80A6
 17+  80A6
 18+  80A6              asm_squa:
 19+  80A6 E6 7F        	and SignMask8Bit
 20+  80A8              ; "ASM SQUA2 : TESTGOOD"
 21+  80A8              ; "AP = A^2 A = low,P = hi singed"
 22+  80A8              asm_squa2:
 23+  80A8 5F           	ld e, a
 24+  80A9 57           	ld d,a
 25+  80AA ED 30        	mul
 26+  80AC ED 53 A0 80  	ld (varP),de
 27+  80B0 7B           	ld a,e
 28+  80B1 C9           	ret
# file closed: ../Maths/asm_square.asm
 86   80B2                  INCLUDE "../Maths/Utilities/APequQmulA-MULT1.asm"
# file opened: ../Maths/Utilities/APequQmulA-MULT1.asm
  1+  80B2              APequQmulA:
  2+  80B2              asm_mult1:
  3+  80B2              ; "ASM_MULT1 (DE) A(hi).P(lo) = Q * A first part of MAD, multiply and add. Visited Quite often. A=hi P = lo also returns result in DE"
  4+  80B2 FE 00        	cp	0
  5+  80B4 28 1F        	jr	z,.mul0			; quick exit if its Q * 0
  6+  80B6 5F           	ld	e,a
  7+  80B7 3A A2 80     	ld	a,(varQ)
  8+  80BA 57           	ld	d,a
  9+  80BB FE 00        	cp	0				; compare a
 10+  80BD 28 16        	jr	z,.mul0			; quick exit if its 0 * a
 11+  80BF AB           	xor	e				; -- = + +- = - -+ = - ++ = +
 12+  80C0 E6 80        	and $80				; get the resultant sign and save into b
 13+  80C2 47           	ld	b,a
 14+  80C3 7A           	ld	a,d
 15+  80C4 E6 7F        	and	SignMask8Bit	; now strip off sign bits
 16+  80C6 57           	ld	d,a
 17+  80C7 7B           	ld	a,e
 18+  80C8 E6 7F        	and SignMask8Bit
 19+  80CA 5F           	ld	e,a
 20+  80CB ED 30        	mul					; zxn de = d * e
 21+  80CD 7B           	ld	a,e
 22+  80CE 32 A0 80     	ld	(varP),a		; p = lo
 23+  80D1 7A           	ld	a,d				; a = hi
 24+  80D2 B0           	or	b				; de goes to a and varP also re-do sign bit
 25+  80D3 57           	ld	d,a				; we will work with de having result as we may bin vars later
 26+  80D4 C9           	ret
 27+  80D5              .mul0:
 28+  80D5 AF           	xor	a
 29+  80D6 32 A0 80     	ld	(varP),a
 30+  80D9 57           	ld	d,a
 31+  80DA 5F           	ld  e,a
 32+  80DB C9           	ret
 33+  80DC
# file closed: ../Maths/Utilities/APequQmulA-MULT1.asm
 87   80DC                  INCLUDE "../Maths/asm_sqrt.asm"
# file opened: ../Maths/asm_sqrt.asm
  1+  80DC              ; "ASM SQRT : TESTGOOD"
  2+  80DC              ; "16-bit integer square root"
  3+  80DC              ; "call with de = number to square root"
  4+  80DC              ; "returns   hl = square root"
  5+  80DC              ; "corrupts  bc, de"
  6+  80DC              asm_sqrt:
  7+  80DC 01 00 80     	ld bc,$8000
  8+  80DF 61           	ld h,c
  9+  80E0 69           	ld l,c
 10+  80E1              .sqrloop:
 11+  80E1 CB 38        	srl b
 12+  80E3 CB 19        	rr c
 13+  80E5 09           	add hl,bc
 14+  80E6 EB           	ex de,hl
 15+  80E7 ED 52        	sbc hl,de
 16+  80E9 38 04        	jr c,.sqrbit
 17+  80EB EB           	ex de,hl
 18+  80EC 09           	add hl,bc
 19+  80ED 18 05        	jr .sqrfi
 20+  80EF              .sqrbit:
 21+  80EF 19           	add hl,de
 22+  80F0 EB           	ex de,hl
 23+  80F1 B7           	or a
 24+  80F2 ED 42        	sbc hl,bc
 25+  80F4              .sqrfi:
 26+  80F4 CB 3C        	srl h
 27+  80F6 CB 1D        	rr l
 28+  80F8 CB 38        	srl b
 29+  80FA CB 19        	rr c
 30+  80FC 30 E3        	jr nc,.sqrloop
 31+  80FE C9           	ret
 32+  80FF
 33+  80FF
 34+  80FF              sqrtQR:					; Q = SQR(Qlo.Rhi) Q <~127
 35+  80FF 3A A2 80     	ld		a,(varQ)
 36+  8102 5F           	ld		e,a
 37+  8103 3A A3 80     	ld		a,(varR)
 38+  8106 57           	ld		d,a
 39+  8107 CD DC 80     	call	asm_sqrt
 40+  810A 7D               ld      a,l
 41+  810B 32 A2 80     	ld		(varQ),a
 42+  810E C9           	ret
 43+  810F
# file closed: ../Maths/asm_sqrt.asm
 88   810F                  include "../Universe/Ships/XX15Vars.asm"
# file opened: ../Universe/Ships/XX15Vars.asm
  1+  810F              ;-- XX15 --------------------------------------------------------------------------------------------------------------------------
  2+  810F 00           UBnkXScaled                 DB  0               ; XX15+0Xscaled
  3+  8110 00           UBnkXScaledSign             DB  0               ; XX15+1xsign
  4+  8111 00           UBnkYScaled                 DB  0               ; XX15+2yscaled
  5+  8112 00           UBnkYScaledSign             DB  0               ; XX15+3ysign
  6+  8113 00           UBnkZScaled                 DB  0               ; XX15+4zscaled
  7+  8114 00           UBnkZScaledSign             DB  0               ; XX15+5zsign
  8+  8115
  9+  8115              XX15                        equ UBnkXScaled
 10+  8115              XX15VecX                    equ XX15
 11+  8115              XX15VecY                    equ XX15+1
 12+  8115              XX15VecZ                    equ XX15+2
 13+  8115              UbnkXPoint                  equ XX15
 14+  8115              UbnkXPointLo                equ XX15+0
 15+  8115              UbnkXPointHi                equ XX15+1
 16+  8115              UbnkXPointSign              equ XX15+2
 17+  8115              UbnkYPoint                  equ XX15+3
 18+  8115              UbnkYPointLo                equ XX15+3
 19+  8115              UbnkYPointHi                equ XX15+4
 20+  8115              UbnkYPointSign              equ XX15+5
 21+  8115              ; Repurposed XX15 pre clip plines
 22+  8115              UbnkPreClipX1               equ XX15+0
 23+  8115              UbnkPreClipY1               equ XX15+2
 24+  8115              UbnkPreClipX2               equ XX15+4
 25+  8115              UbnkPreClipY2               equ XX15+6
 26+  8115              ; Repurposed XX15 post clip lines
 27+  8115              UBnkNewX1                   equ XX15+0
 28+  8115              UBnkNewY1                   equ XX15+1
 29+  8115              UBnkNewX2                   equ XX15+2
 30+  8115              UBnkNewY2                   equ XX15+3
 31+  8115              ; Repurposed XX15
 32+  8115              regXX15fx                   equ UBnkXScaled
 33+  8115              regXX15fxSgn                equ UBnkXScaledSign
 34+  8115              regXX15fy                   equ UBnkYScaled
 35+  8115              regXX15fySgn                equ UBnkYScaledSign
 36+  8115              regXX15fz                   equ UBnkZScaled
 37+  8115              regXX15fzSgn                equ UBnkZScaledSign
 38+  8115              ; Repurposed XX15
 39+  8115              varX1                       equ UBnkXScaled       ; Reused, verify correct position
 40+  8115              varY1                       equ UBnkXScaledSign   ; Reused, verify correct position
 41+  8115              varZ1                       equ UBnkYScaled       ; Reused, verify correct position
 42+  8115              ; After clipping the coords are two 8 bit pairs
 43+  8115              UBnkPoint1Clipped           equ UBnkXScaled
 44+  8115              UBnkPoint2Clipped           equ UBnkYScaled
 45+  8115              ; Repurposed XX15 when plotting lines
 46+  8115              ; Repurposed XX15 before calling clip routine
 47+  8115              UBnkX1                      equ XX15
 48+  8115              UBnKx1Lo                    equ XX15
 49+  8115              UBnKx1Hi                    equ XX15+1
 50+  8115              UBnkY1                      equ XX15+2
 51+  8115              UbnKy1Lo                    equ XX15+2
 52+  8115              UBnkY1Hi                    equ XX15+3
 53+  8115              UBnkX2                      equ XX15+4
 54+  8115              UBnkX2Lo                    equ XX15+4
 55+  8115              UBnkX2Hi                    equ XX15+5
 56+  8115
# file closed: ../Universe/Ships/XX15Vars.asm
 89   8115                  include "../Universe/Ships/AIRuntimeData.asm"
# file opened: ../Universe/Ships/AIRuntimeData.asm
  1+  8115              ;-Camera Position of Ship----------------------------------------------------------------------------------------------------------
  2+  8115              StartOfShipRuntimeData      EQU $
  3+  8115 00           UBnKxlo                     DB  0                       ; INWK+0
  4+  8116 00           UBnKxhi                     DB  0                       ; there are hi medium low as some times these are 24 bit
  5+  8117 00           UBnKxsgn                    DB  0                       ; INWK+2
  6+  8118 00           UBnKylo                     DB  0                       ; INWK+3 \ ylo
  7+  8119 00           UBnKyhi                     DB  0                       ; INWK+4 \ yHi
  8+  811A 00           UBnKysgn                    DB  0                       ; INWK +5
  9+  811B 00           UBnKzlo                     DB  0                       ; INWK +6
 10+  811C 00           UBnKzhi                     DB  0                       ; INWK +7
 11+  811D 00           UBnKzsgn                    DB  0                       ; INWK +8
 12+  811E              ;-Rotation Matrix of Ship----------------------------------------------------------------------------------------------------------
 13+  811E              ; Rotation data is stored as lohi, but only 15 bits with 16th bit being  a sign bit. Note this is NOT 2'c compliment
 14+  811E              ; Note they seem to have to be after camera position not quite found why yet, can only assume it does an iy or ix indexed copy? Bu oddly does not affect space station.
 15+  811E 00 00        UBnkrotmatSidevX            DW  0                       ; INWK +21
 16+  8120              UBnkrotmatSidev             equ UBnkrotmatSidevX
 17+  8120 00 00        UBnkrotmatSidevY            DW  0                       ; INWK +23
 18+  8122 00 00        UBnkrotmatSidevZ            DW  0                       ; INWK +25
 19+  8124 00 00        UBnkrotmatRoofvX            DW  0                       ; INWK +15
 20+  8126              UBnkrotmatRoofv             equ UBnkrotmatRoofvX
 21+  8126 00 00        UBnkrotmatRoofvY            DW  0                       ; INWK +17
 22+  8128 00 00        UBnkrotmatRoofvZ            DW  0                       ; INWK +19
 23+  812A 00 00        UBnkrotmatNosevX            DW  0                       ; INWK +9
 24+  812C              UBnkrotmatNosev             EQU UBnkrotmatNosevX
 25+  812C 00 00        UBnkrotmatNosevY            DW  0                       ; INWK +11
 26+  812E 00 00        UBnkrotmatNosevZ            DW  0                       ; INWK +13
 27+  8130              ; -- Note these must be here for initialise blast as it does a 12 byte ldir
 28+  8130              ; . Note missile explosion will have to have logic to cause linger if a blast is to be enqued
 29+  8130 00           UBnKMissileBlastRange:      DB  0                       ; copied in when setting up a missile
 30+  8131 00           UBnKMissileBlastDamage:     DB  0                       ; copied in when setting up a missile
 31+  8132 00           UBnKMissileDetonateRange:   DB  0                       ; copied in when setting up a missile, allows for proximity missiles
 32+  8133 00           UBnKMissileDetonateDamage:  DB  0                       ; copied in when setting up a missile
 33+  8134              ; -- Metadata for ship to help with bank managment
 34+  8134              UBnKStartOfRuntimeData:
 35+  8134 00           UBnKSlotNumber              DB  0
 36+  8135 00           UbnKShipUnivBankNbr         DB  0                       ; Present ship universe bank number
 37+  8136 00           UBnkShipModelBank           DB  0                       ; Bank nbr ship was from
 38+  8137 00           UBnKShipModelNbr            DB  0                       ; Ship Id with in the bank
 39+  8138 00           UBnKShipModeID              DB  0                       ; Absolute ship id
 40+  8139              ; -- Ship AI data
 41+  8139 00           UBnKMissleHitToProcess      DB  0                       ; This is used for enquing missle blasts as we can only do one missile at a time, could make it multi but neeed to smooth CPU usage
 42+  813A 00           UBnKMissileTarget           DB  0                       ; This is the ship slot number for the target from 0 to n if the missile is not hostile to us, if the target is $FF then its us
 43+  813B 00           UBnKSpeed                   DB  0                       ; INWK +27
 44+  813C 00           UBnKAccel                   DB  0                       ; INWK +28
 45+  813D 00           UBnKRotXCounter             DB  0                       ; INWK +29
 46+  813E 00           UBnKRotZCounter             DB  0                       ; INWK +30
 47+  813F 00           UBnKRAT                     DB  0                       ; temporary for rotation magnitude or roll counter, for debugging state
 48+  8140 00           UBnKRAT2                    DB  0                       ; temporary for rotation threshold
 49+  8141 00           UBnKCNT                     DB  0                       ; temp for calculating roll and pitch
 50+  8142 00           UBnKCNT2                    DB  0                       ; roll threshold, max angle boynd ship will slow down
 51+  8143 00           univRAT                     DB  0               ; 99
 52+  8144 00           univRAT2                    DB  0               ; 9A
 53+  8145 00           univRAT2Val                 DB  0               ; 9A
 54+  8146 00           UBnKexplDsp                 DB  0                       ; INWK +31 clear exploding/display state|missiles
 55+  8147 00           UBnkDrawAllFaces            DB  0
 56+  8148 00           UBnkaiatkecm                DB  0                       ; INWK +32 ai_attack_univ_ecm i.e. AI type
 57+  8149 00           UBnKSpawnObject             DB  0
 58+  814A 00           UBnkCam0yLo                 DB  0                       ; INWK +33 ????
 59+  814B 00           UBnkCam0yHi                 DB  0                       ; INWK +34?????
 60+  814C 00           UBnKEnergy                  DB  0                       ; INWK +35
 61+  814D 00           UBnKECMCountDown            DB  0                       ; counts down ECM usage if activated reducing energy too in update loop
 62+  814E 00           UBnKECMFitted               DB  0                       ; Does ship have ECM, true false
 63+  814F 00           UBnKMissilesLeft            DB  0
 64+  8150 00           UBnKCloudCounter            DB  0                       ; cloud pixels
 65+  8151 00           UBnKCloudRadius             DB  0                       ; cloud pixels
 66+  8152              UBnKRuntimeSize             EQU $-UBnKStartOfRuntimeData
 67+  8152              ; Flags work as follows:
 68+  8152              ; UBnKSpawnObject - signals on death to spawn cargo items
 69+  8152              ; 0 -                   Spawn Cargo 1
 70+  8152              ; 1 -                   Spawn Cargo 2
 71+  8152              ; 2 -                   Spawn Cargo 3
 72+  8152              ; 3 -                   Spawn Cargo 4
 73+  8152              ; 4 -                   Spawn Alloy 1
 74+  8152              ; 5 -                   Spawn Alloy 2
 75+  8152              ; 6 -                   Spawn Alloy 3
 76+  8152              ; 7 -                   Spawn Alloy 4
 77+  8152
 78+  8152              ; UBnkaiatkecm
 79+  8152              ; Bit	                Description
 80+  8152              ; 7 -                   AI Enabled Flag
 81+  8152              ; 6 -                   Ship Visible = ShipOnScreen/NotCloaked (cleared or set by check visible or cloaking override)
 82+  8152              ; 5 -                   Ship is exploding if set, note if its a missile and one already equeued this will have to linger
 83+  8152              ;                       linger can be done by not erasing ship unit missile equeue handled
 84+  8152              ; 4 -                   Ship marked as exploded, cleared once aknowledged then bit 5 takes over and UBnKCloudCounter
 85+  8152              ; 3 -                   Display state - Plot as a Dot
 86+  8152              ; 2 -                   Nbr of Missiles bit 2
 87+  8152              ; 1 -                   Nbr of Missiles bit 1
 88+  8152              ; 0 -                   ECM present flag
 89+  8152              ; ShipNewBitsAddr (in blueprint)
 90+  8152              ;Bit	                Description
 91+  8152              ;#0	Trader flag         * 0 = not a trader  * 1 = trader
 92+  8152              ;                       80% of traders are peaceful and mind their own business plying their trade between the planet and space station, but 20% of them moonlight as bounty hunters (see bit #1)
 93+  8152              ;                       Ships that are traders: Escape pod, Shuttle, Transporter, Anaconda, Rock hermit, Worm
 94+  8152              ;#1 Bounty hunter flag  * 0 = not a bounty hunter* 1 = bounty hunter
 95+  8152              ;                       If we are a fugitive or a serious offender and we bump into a bounty hunter, they will become hostile and attack us (see bit #2)
 96+  8152              ;                       Ships that are bounty hunters: Viper, Fer-de-lance
 97+  8152              ;#2	Hostile flag        * 0 = not hostile  * 1 = hostile
 98+  8152              ;                       Hostile ships will attack us on sight; there are quite a few of them
 99+  8152              ;                       Ships that are hostile: Sidewinder, Mamba, Krait, Adder, Gecko, Cobra Mk I, Worm, Cobra Mk III, Asp Mk II, Python (pirate), Moray, Thargoid, Thargon, Constrictor
100+  8152              ;#3	Pirate flag         * 0 = not a pirate * 1 = pirate
101+  8152              ;                       Hostile pirates will attack us on sight, but once we get inside the space station safe zone, they will stop
102+  8152              ;                       Ships that are pirates: Sidewinder, Mamba, Krait, Adder, Gecko, Cobra Mk I, Cobra Mk III, Asp Mk II, Python (pirate), Moray, Thargoid
103+  8152              ;#4	Docking flag        * 0 = not docking * 1 = docking
104+  8152              ;                       Traders with their docking flag set fly towards the space station to try to dock, otherwise they aim for the planet
105+  8152              ;                       This flag is randomly set for traders when they are spawned
106+  8152              ;                       Ships that can be docking: Escape pod, Shuttle, Transporter, Anaconda, Rock hermit, Worm
107+  8152              ;#5	Innocent bystander  * 0 = normal * 1 = innocent bystander
108+  8152              ;                       If we attack an innocent ship within the space station safe zone, then the station will get angry with us and start spawning cops
109+  8152              ;                       Ships that are innocent bystanders: Shuttle, Transporter, Cobra Mk III, Python, Boa, Anaconda, Rock hermit, Cougar
110+  8152              ;#6	Cop flag            * 0 = not a cop * 1 = cop
111+  8152              ;                       If we destroy a cop, then we instantly become a fugitive (the Transporter isn't actually a cop, but it's clearly under police protection)
112+  8152              ;                       Ships that are cops: Viper, Transporter
113+  8152              ;#7	Scooped, docked, escape pod flag
114+  8152              ;                       For spawned ships, this flag indicates that the ship been scooped or has docked (bit 7 is always clear on spawning)
115+  8152              ;                       For blueprints, this flag indicates whether the ship type has an escape pod fitted, so it can launch it when in dire straits
116+  8152              ;                       Ships that have escape pods: Cobra Mk III, Python, Boa, Anaconda, Rock hermit, Viper, Mamba, Krait, Adder, Cobra Mk I, Cobra Mk III (pirate), Asp Mk II, Python (pirate), Fer-de-lance
117+  8152
# file closed: ../Universe/Ships/AIRuntimeData.asm
 90   8152                  include "../Universe/Ships/CopyRotMattoXX15.asm"
# file opened: ../Universe/Ships/CopyRotMattoXX15.asm
  1+  8152              CopyRotMatNoseVtoXX15:
  2+  8152                      ldCopyByte  UBnkrotmatNosevX+1 ,XX15VecX
  2+  8152 3A 2B 81    >                        ld       a,(UBnkrotmatNosevX+1)
  2+  8155 32 0F 81    >                        ld       (XX15VecX),a
  3+  8158                      ldCopyByte  UBnkrotmatNosevY+1, XX15VecY
  3+  8158 3A 2D 81    >                        ld       a,(UBnkrotmatNosevY+1)
  3+  815B 32 10 81    >                        ld       (XX15VecY),a
  4+  815E                      ldCopyByte  UBnkrotmatNosevZ+1 ,XX15VecZ
  4+  815E 3A 2F 81    >                        ld       a,(UBnkrotmatNosevZ+1)
  4+  8161 32 11 81    >                        ld       (XX15VecZ),a
  5+  8164 C9                   ret
  6+  8165
  7+  8165              CopyRotMatRoofVtoXX15:
  8+  8165                      ldCopyByte  UBnkrotmatRoofvX+1 ,XX15VecX
  8+  8165 3A 25 81    >                        ld       a,(UBnkrotmatRoofvX+1)
  8+  8168 32 0F 81    >                        ld       (XX15VecX),a
  9+  816B                      ldCopyByte  UBnkrotmatRoofvY+1, XX15VecY
  9+  816B 3A 27 81    >                        ld       a,(UBnkrotmatRoofvY+1)
  9+  816E 32 10 81    >                        ld       (XX15VecY),a
 10+  8171                      ldCopyByte  UBnkrotmatRoofvZ+1 ,XX15VecZ
 10+  8171 3A 29 81    >                        ld       a,(UBnkrotmatRoofvZ+1)
 10+  8174 32 11 81    >                        ld       (XX15VecZ),a
 11+  8177 C9                   ret
 12+  8178
 13+  8178              CopyRotMatSideVtoXX15:
 14+  8178                      ldCopyByte  UBnkrotmatSidevX+1 ,XX15VecX
 14+  8178 3A 1F 81    >                        ld       a,(UBnkrotmatSidevX+1)
 14+  817B 32 0F 81    >                        ld       (XX15VecX),a
 15+  817E                      ldCopyByte  UBnkrotmatSidevY+1, XX15VecY
 15+  817E 3A 21 81    >                        ld       a,(UBnkrotmatSidevY+1)
 15+  8181 32 10 81    >                        ld       (XX15VecY),a
 16+  8184                      ldCopyByte  UBnkrotmatSidevZ+1 ,XX15VecZ
 16+  8184 3A 23 81    >                        ld       a,(UBnkrotmatSidevZ+1)
 16+  8187 32 11 81    >                        ld       (XX15VecZ),a
 17+  818A C9                   ret
 18+  818B
# file closed: ../Universe/Ships/CopyRotMattoXX15.asm
 91   818B                  include "../Universe/Ships/CopyXX15toRotMat.asm"
# file opened: ../Universe/Ships/CopyXX15toRotMat.asm
  1+  818B              CopyXX15toRotMatNoseV:
  2+  818B                      ldCopyByte  XX15VecX, UBnkrotmatNosevX+1
  2+  818B 3A 0F 81    >                        ld       a,(XX15VecX)
  2+  818E 32 2B 81    >                        ld       (UBnkrotmatNosevX+1),a
  3+  8191                      ldCopyByte  XX15VecY, UBnkrotmatNosevY+1
  3+  8191 3A 10 81    >                        ld       a,(XX15VecY)
  3+  8194 32 2D 81    >                        ld       (UBnkrotmatNosevY+1),a
  4+  8197                      ldCopyByte  XX15VecZ, UBnkrotmatNosevZ+1
  4+  8197 3A 11 81    >                        ld       a,(XX15VecZ)
  4+  819A 32 2F 81    >                        ld       (UBnkrotmatNosevZ+1),a
  5+  819D                      ZeroA
  5+  819D AF          >                        xor a
  6+  819E 32 2A 81             ld  (UBnkrotmatNosevX),a
  7+  81A1 32 2C 81             ld  (UBnkrotmatNosevY),a
  8+  81A4 32 2E 81             ld  (UBnkrotmatNosevZ),a
  9+  81A7 C9                   ret
 10+  81A8
 11+  81A8              CopyXX15toRotMatRoofV:
 12+  81A8                      ldCopyByte  XX15VecX, UBnkrotmatRoofvX+1
 12+  81A8 3A 0F 81    >                        ld       a,(XX15VecX)
 12+  81AB 32 25 81    >                        ld       (UBnkrotmatRoofvX+1),a
 13+  81AE                      ldCopyByte  XX15VecY, UBnkrotmatRoofvY+1
 13+  81AE 3A 10 81    >                        ld       a,(XX15VecY)
 13+  81B1 32 27 81    >                        ld       (UBnkrotmatRoofvY+1),a
 14+  81B4                      ldCopyByte  XX15VecZ, UBnkrotmatRoofvZ+1
 14+  81B4 3A 11 81    >                        ld       a,(XX15VecZ)
 14+  81B7 32 29 81    >                        ld       (UBnkrotmatRoofvZ+1),a
 15+  81BA                      ZeroA
 15+  81BA AF          >                        xor a
 16+  81BB 32 24 81             ld  (UBnkrotmatRoofvX),a
 17+  81BE 32 26 81             ld  (UBnkrotmatRoofvY),a
 18+  81C1 32 28 81             ld  (UBnkrotmatRoofvZ),a
 19+  81C4 C9                   ret
 20+  81C5
 21+  81C5              CopyXX15toRotMatSideV:
 22+  81C5                      ldCopyByte  XX15VecX, UBnkrotmatSidevX+1
 22+  81C5 3A 0F 81    >                        ld       a,(XX15VecX)
 22+  81C8 32 1F 81    >                        ld       (UBnkrotmatSidevX+1),a
 23+  81CB                      ldCopyByte  XX15VecY, UBnkrotmatSidevY+1
 23+  81CB 3A 10 81    >                        ld       a,(XX15VecY)
 23+  81CE 32 21 81    >                        ld       (UBnkrotmatSidevY+1),a
 24+  81D1                      ldCopyByte  XX15VecZ, UBnkrotmatSidevZ+1
 24+  81D1 3A 11 81    >                        ld       a,(XX15VecZ)
 24+  81D4 32 23 81    >                        ld       (UBnkrotmatSidevZ+1),a
 25+  81D7                      ZeroA
 25+  81D7 AF          >                        xor a
 26+  81D8 32 1E 81             ld  (UBnkrotmatSidevX),a
 27+  81DB 32 20 81             ld  (UBnkrotmatSidevY),a
 28+  81DE 32 22 81             ld  (UBnkrotmatSidevZ),a
 29+  81E1 C9                   ret
 30+  81E2
# file closed: ../Universe/Ships/CopyXX15toRotMat.asm
 92   81E2                  include "../Maths/Utilities/AequAdivQmul96-TIS2.asm"
# file opened: ../Maths/Utilities/AequAdivQmul96-TIS2.asm
  1+  81E2              AequAdivQmul96ABS:      JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
  1+  81E2 BA          >                        cp     d
  1+  81E3 D2 FE 81    >                        jp		nc,.TIS2AccGTEQ
  2+  81E6 06 FE                                ld			b,$FE						; division roll (replaced varT)
  3+  81E8 CB 27        .TIS2RollTLoop:			sla			a
  4+  81EA                                      JumpIfALTNusng d,.TIS2SkipSub           ; a < d so don;t subtract
  4+  81EA BA          >                        cp      d
  4+  81EB DA 01 82    >                        jp		c, .TIS2SkipSub
  5+  81EE 9A                                   sbc			a,d							; do subtraction with carry
  6+  81EF 37                                   scf
  7+  81F0 CB 10                                rl			b							; T rolled left to push bit out the end
  8+  81F2 38 F4                                jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
  9+  81F4 78           .TIS2SKIPCont:	        ld			a,b							; T
 10+  81F5 CB 3F                                srl			a							; result / 2
 11+  81F7 CB 3F                                srl			a							; result / 4
 12+  81F9 47                                   ld			b,a							; t = t /4
 13+  81FA CB 3F                                srl			a							; result / 8
 14+  81FC 80                                   add			a,b							; result /8 + result /4
 15+  81FD C9                                   ret
 16+  81FE 3E 60        .TIS2AccGTEQ:           ld			a,$60							; unity
 17+  8200 C9                                   ret
 18+  8201 B7           .TIS2SkipSub:           or			a
 19+  8202 CB 10                                rl			b							; T rolled left to push bit out the end
 20+  8204 38 E2                                jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
 21+  8206 C3 F4 81                             jp			.TIS2SKIPCont
 22+  8209
 23+  8209
 24+  8209              ; USES 			A DE BC
 25+  8209              ; DOES NOT USE 	HL
 26+  8209              TIS2962C:		; two's compliment entry point, exits not 2's compliment
 27+  8209 CB 7F        	bit			7,a
 28+  820B 28 04        	jr			z,AequAdivQmul96
 29+  820D ED 44        	neg										; revers 2s'c and just set neg bit
 30+  820F CB FF        	set			7,a
 31+  8211              ; Note negative numbers are bit 7 set not 2's compliment
 32+  8211              AequAdivQmul96:								; TIS296:			; .tis2 A = A /Q *96 (or A = A * 3/8 * Q) Reduce Acc in NORM routine i.e. *96/Q clamps at +- 96
 33+  8211              TIS2:
 34+  8211 4F           	ld			c,a							; copy of Acc
 35+  8212 3A A2 80     	ld			a,(varQ)
 36+  8215 57           	ld			d,a							; d = varQ
 37+  8216 79           	ld			a,c							; recover a
 38+  8217              AequAdivDmul967Bit:
 39+  8217 4F               ld          c,a
 40+  8218 7A               ld          a,d
 41+  8219 CB 27            sla         a
 42+  821B 30 10            jr          nc, .OKToDivide
 43+  821D              .ScaleDown:
 44+  821D B7               or          a
 45+  821E CB 3A            srl         d
 46+  8220
 47+  8220 79               ld          a,c
 48+  8221 E6 7F            and         SignMask8Bit
 49+  8223 CB 3F            srl         a
 50+  8225 47               ld          b,a
 51+  8226 79               ld          a,c
 52+  8227 E6 80            and         $80
 53+  8229 B0               or          b
 54+  822A C3 2E 82         jp          AequAdivDmul96
 55+  822D              .OKToDivide:
 56+  822D 79               ld          a,c
 57+  822E              AequAdivDmul96:
 58+  822E 4F           	ld			c,a							; copy of Acc as we need the sign, alternate entry point assuming D preloaded, wastes an "ld c,a" but simplifies code
 59+  822F E6 7F        	and			SignMask8Bit				; ignore sign
 60+  8231              	JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
 60+  8231 BA          >                        cp     d
 60+  8232 D2 52 82    >                        jp		nc,.TIS2AccGTEQ
 61+  8235 06 FE        	ld			b,$FE						; division roll (replaced varT)
 62+  8237              .TIS2RollTLoop:									; .TIL2	; roll T
 63+  8237 CB 27        	sla			a
 64+  8239              	JumpIfALTNusng d,.TIS2SkipSub           ; a < d so don;t subtract
 64+  8239 BA          >                        cp      d
 64+  823A DA 58 82    >                        jp		c, .TIS2SkipSub
 65+  823D 9A           	sbc			a,d							; do subtraction with carry
 66+  823E 37           	scf                                     ; set carrry to roll into b
 67+  823F CB 10        	rl			b							; T rolled left to push bit out the end
 68+  8241 38 F4        	jr			c,.TIS2RollTLoop			; if we still have not hit the empty marker continue
 69+  8243              .TIS2SKIPCont:
 70+  8243 78           	ld			a,b							; A = T = 4 / 4
 71+  8244 CB 3F        	srl			a							; .
 72+  8246 CB 3F        	srl			a							; .
 73+  8248 47           	ld			b,a							; .
 74+  8249 CB 3F        	srl			a							; A = A / 2 (i.e. T /8)
 75+  824B 80           	add			a,b							; A = T/8 + T/4 (3T/8)
 76+  824C 47           	ld			b,a							; b = 3/8*Acc (max = 96)
 77+  824D 79           	ld			a,c							; copy of Acc to look at sign bit
 78+  824E E6 80        	and			$80							; recover sign only
 79+  8250 B0           	or			b							; now put b back in so we have a leading sign bit (note not 2's compliment)
 80+  8251 C9           	ret
 81+  8252              .TIS2AccGTEQ:
 82+  8252              ;TI4:										;\ clean to +/- unity
 83+  8252 79           	ld			a,c
 84+  8253 E6 80        	and			$80							; copy of Acc
 85+  8255 F6 60        	or			$60							; unity
 86+  8257 C9           	ret
 87+  8258              .TIS2SkipSub:
 88+  8258              	ClearCarryFlag                          ; Clear carry as it needs to be empty to roll in 0
 88+  8258 B7          >                        or a
 89+  8259 CB 10        	rl			b							; T rolled left to push bit out the end
 90+  825B 38 DA        	jr			c,.TIS2RollTLoop			; if we still have not hit the empty marker continue
 91+  825D C3 43 82     	jp			.TIS2SKIPCont
 92+  8260
# file closed: ../Maths/Utilities/AequAdivQmul96-TIS2.asm
 93   8260                  include "../Maths/Utilities/RSequQmulA-MULT12.asm"
# file opened: ../Maths/Utilities/RSequQmulA-MULT12.asm
  1+  8260              asm_mult12:
  2+  8260              RSequQmulA:
  3+  8260              ; "asm_ult12  R.S = Q * A \ visited quite often S = hi, R = lo, odd that its opposite to mult1"
  4+  8260 CD B2 80     	call APequQmulA
  5+  8263 08           	ex 	af,af'
  6+  8264 7A           	ld	a,d
  7+  8265 32 A4 80     	ld	(varS),a
  8+  8268 7B           	ld	a,e
  9+  8269 32 A3 80     	ld	(varR),a
 10+  826C 08           	ex 	af,af'
 11+  826D C9           	ret
 12+  826E
# file closed: ../Maths/Utilities/RSequQmulA-MULT12.asm
 94   826E                  include "../Maths/normalise96.asm"
# file opened: ../Maths/normalise96.asm
  1+  826E              AequAdivDmul96Unsg:     JumpIfAGTENusng d, .Unity    			; if A >= Q then return with a 1 (unity i.e. 96)
  1+  826E BA          >                        cp     d
  1+  826F D2 8A 82    >                        jp		nc,.Unity
  2+  8272 06 FF                                ld          b,%11111111                 ; Loop through 8 bits
  3+  8274 CB 27        .DivLoop:               sla         a                           ; shift a left
  4+  8276                                      JumpIfALTNusng d, .skipSubtract         ; if a < q skip the following
  4+  8276 BA          >                        cp      d
  4+  8277 DA 7B 82    >                        jp		c, .skipSubtract
  5+  827A 92                                   sub         d
  6+  827B              .skipSubtract:          FlipCarryFlag
  6+  827B 3F          >                        ccf
  7+  827C CB 10                                rl          b
  8+  827E 38 F4                                jr          c,.DivLoop
  9+  8280 78                                   ld          a,b
 10+  8281 CB 3F                                srl         a                  			; t = t /4
 11+  8283 CB 3F                                srl			a							; result / 8
 12+  8285 47                                   ld          b,a
 13+  8286 CB 3F                                srl         a
 14+  8288 80                                   add			a,b							; result /8 + result /4
 15+  8289 C9                                   ret
 16+  828A 3E 60        .Unity:                 ld			a,$60	    				; unity
 17+  828C C9                                   ret
 18+  828D
 19+  828D
 20+  828D
 21+  828D
 22+  828D              normaliseXX1596fast:
 23+  828D                  ; .NORM	\ -> &3BD6 \ Normalize 3-vector length of XX15
 24+  828D 3A 0F 81     	ld		a,(XX15)		    ; XX15+0
 25+  8290 DD 67        	ld		ixh,a               ; ixh = signed x component
 26+  8292 E6 7F        	and		SignMask8Bit                 ; a = unsigned version
 27+  8294              N96SQX:
 28+  8294              	inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
 28+  8294 5F          >			ld	e,a
 28+  8295 57          >			ld  d,a
 28+  8296 ED 30       >			mul
 29+  8298 62           	ld		h,d					; h == varR d = varO e= varA
 30+  8299 6B           	ld		l,e					; l == varQ  															:: so HL = XX15[x]^2
 31+  829A              N96SQY:
 32+  829A 3A 10 81     	ld		a,(XX15+1)
 33+  829D DD 6F        	ld		ixl,a               ; ixl = signed y componet
 34+  829F E6 7F        	and		SignMask8Bit                 ; = abs
 35+  82A1              	inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2		:: so DE = XX15[y]^2
 35+  82A1 5F          >			ld	e,a
 35+  82A2 57          >			ld  d,a
 35+  82A3 ED 30       >			mul
 36+  82A5 19           	add		hl,de				; hl = XX15[x]^2 + XX15[y]^2
 37+  82A6              N96SQZ:
 38+  82A6 3A 11 81     	ld		a,(XX15+2)			; Note comments say \ ZZ15+2  should be \ XX15+2 as per code
 39+  82A9 FD 67        	ld		iyh,a               ; iyh = signed
 40+  82AB E6 7F        	and		SignMask8Bit                 ; unsigned
 41+  82AD              	inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2		:: so DE = XX15[z]^2
 41+  82AD 5F          >			ld	e,a
 41+  82AE 57          >			ld  d,a
 41+  82AF ED 30       >			mul
 42+  82B1              N96SQADD:
 43+  82B1 19           	add		hl,de				; hl = XX15[x]^2 + XX15[y]^2 + XX15[z]^2
 44+  82B2 EB           	ex		de,hl				; hl => de ready for square root
 45+  82B3              N96SQRT:
 46+  82B3 CD DC 80     	call	asm_sqrt			; hl = sqrt(XX15[x]^2 + XX15[y]^2 + XX15[z]^2), we just are interested in l which is the new Q
 47+  82B6              N96NORMX:
 48+  82B6 3A 0F 81     	ld		a,(XX15+0)
 49+  82B9 E6 7F        	and		SignMask8Bit
 50+  82BB 4F           	ld		c,a
 51+  82BC 55           	ld		d,l					; Q(i.e. l) => D, later we can just pop into de
 52+  82BD CD 2E 82     	call	AequAdivDmul96	; does not use HL so we can retain it
 53+  82C0 47           	ld		b,a				;++SGN
 54+  82C1 DD 7C        	ld		a,ixh			;++SGN
 55+  82C3 E6 80        	and		$80				;++SGN
 56+  82C5 B0           	or		b				;++SGN
 57+  82C6 32 0F 81     	ld		(XX15+0),a
 58+  82C9              N96NORMY:
 59+  82C9 3A 10 81     	ld		a,(XX15+1)
 60+  82CC E6 7F        	and		SignMask8Bit
 61+  82CE 4F           	ld		c,a
 62+  82CF 55           	ld		d,l					; Q(i.e. l) => D, later we can just pop into de
 63+  82D0 CD 2E 82     	call	AequAdivDmul96     	; does not use HL so we can retain it
 64+  82D3 47           	ld		b,a				;++SGN
 65+  82D4 DD 7D        	ld		a,ixl			;++SGN
 66+  82D6 E6 80        	and		$80				;++SGN
 67+  82D8 B0           	or		b				;++SGN
 68+  82D9 32 10 81     	ld		(XX15+1),a
 69+  82DC              N96NORMZ:
 70+  82DC 3A 11 81     	ld		a,(XX15+2)
 71+  82DF E6 7F        	and		SignMask8Bit
 72+  82E1 4F           	ld		c,a
 73+  82E2 55           	ld		d,l					; Q(i.e. l) => D, later we can just pop into de
 74+  82E3 CD 2E 82     	call	AequAdivDmul96	; does not use HL so we can retain it
 75+  82E6 47           	ld		b,a				;++SGN
 76+  82E7 FD 7C        	ld		a,iyh			;++SGN
 77+  82E9 E6 80        	and		$80				;++SGN
 78+  82EB B0           	or		b				;++SGN
 79+  82EC 32 11 81     	ld		(XX15+2),a
 80+  82EF C9           	ret
 81+  82F0
 82+  82F0              ; Normalise vector
 83+  82F0              ; scale Q = Sqrt (X^2 + Y^2 + Z^2)
 84+  82F0              ; X = X / Q with 96 = 1 , i.e X = X / Q * 3/8
 85+  82F0              ; Y = Y / Q with 96 = 1 , i.e Y = Y / Q * 3/8
 86+  82F0              ; Z = Z / Q with 96 = 1 , i.e Z = Z / Q * 3/8
 87+  82F0              ;
 88+  82F0              ;
 89+  82F0              ;
 90+  82F0
 91+  82F0              ; .NORM	\ -> &3BD6 \ Normalize 3-vector length of XX15
 92+  82F0 3A 0F 81     normaliseXX1596:        ld		a,(XX15)		    ; XX15+0
 93+  82F3                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
 93+  82F3 5F          >			ld	e,a
 93+  82F4 57          >			ld  d,a
 93+  82F5 ED 30       >			mul
 94+  82F7 7A                                   ld		a,d
 95+  82F8 32 A3 80                             ld		(varR),a			; R	 \ hi sum later use b
 96+  82FB 7B                                   ld		a,e
 97+  82FC 32 A2 80                             ld		(varQ),a			; Q	 \ lo sum later use c
 98+  82FF 32 A0 80                             ld		(varP),a			; P	 \ lo sum later just drop
 99+  8302 3A 10 81                             ld		a,(XX15+1)
100+  8305                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
100+  8305 5F          >			ld	e,a
100+  8306 57          >			ld  d,a
100+  8307 ED 30       >			mul
101+  8309 7A                                   ld		a,d
102+  830A 32 A5 80                             ld		(varT),a			; T	 \ hi sum
103+  830D 7B                                   ld		a,e
104+  830E 32 A0 80                             ld		(varP),a			; P	 \ lo sum
105+  8311 21 A2 80                             ld		hl,varQ
106+  8314 8E                                   adc		a,(hl)				; +Q
107+  8315 32 A2 80                             ld		(varQ),a			; =>Q
108+  8318 3A A5 80                             ld		a,(varT)			;
109+  831B 21 A3 80                             ld		hl,varR
110+  831E 8E                                   adc		a,(hl)				;  R
111+  831F 32 A3 80                             ld		(varR),a			; R
112+  8322 3A 11 81                             ld		a,(XX15+2)			; Note comments say \ ZZ15+2  should be \ XX15+2 as per code
113+  8325                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
113+  8325 5F          >			ld	e,a
113+  8326 57          >			ld  d,a
113+  8327 ED 30       >			mul
114+  8329 7A                                   ld		a,d
115+  832A 32 A5 80                             ld		(varT),a			; T	 \ hi sum
116+  832D 7B                                   ld		a,e
117+  832E 32 A0 80                             ld		(varP),a			; P	 \ lo sum
118+  8331 21 A2 80                             ld		hl,varQ
119+  8334 8E                                   adc		a,(hl)				; +Q
120+  8335 32 A2 80                             ld		(varQ),a			; =>Q  xlo2 + ylo2 + zlo2
121+  8338 3A A5 80                             ld		a,(varT)			; T temp Hi
122+  833B 21 A3 80                             ld		hl,varR
123+  833E 8E                                   adc		a,(hl)				; +R
124+  833F 32 A3 80                             ld		(varR),a			; R
125+  8342 CD FF 80                             call	sqrtQR				; Q = SQR(Qlo.Rhi) Q <~127
126+  8345 3A 0F 81                             ld		a,(XX15+0)
127+  8348 CD 11 82                             call	AequAdivQmul96		;  TIS2 \ *96/Q
128+  834B 32 0F 81                             ld		(XX15+0),a
129+  834E 3A 10 81                             ld		a,(XX15+1)
130+  8351 CD 11 82                             call	AequAdivQmul96		;  TIS2 \ *96/Q
131+  8354 32 10 81                             ld		(XX15+1),a
132+  8357 3A 10 81                             ld		a,(XX15+1)
133+  835A CD 11 82                             call	AequAdivQmul96		;  TIS2 \ *96/Q
134+  835D 32 10 81                             ld		(XX15+1),a
135+  8360 C9                                   ret
136+  8361
137+  8361
# file closed: ../Maths/normalise96.asm
 95   8361                  include "../Maths/Utilities/tidy.asm"
# file opened: ../Maths/Utilities/tidy.asm
  1+  8361              ;rotmap0xLo: DB	0				; INWK +9
  2+  8361              ;rotmap0xHi: DB	0				; INWK +10
  3+  8361              ;rotmat0yLo: DB	0				; INWK +11
  4+  8361              ;rotmat0yHi: DB	0				; INWK +12
  5+  8361              ;rotmat0zLo:	DB 	0				; INWK +13
  6+  8361              ;rotmat0zHi:	DB 	0				; INWK +14
  7+  8361              ;rotmap1xLo: DB	0				; INWK +15
  8+  8361              ;rotmap1xHi:	DB	0				; INWK +16
  9+  8361              ;rotmat1yLo:	DB	0				; INWK +17
 10+  8361              ;rotmat1yHi:	DB	0				; INWK +18
 11+  8361              ;rotmat1zLo:	DB	0				; INWK +19
 12+  8361              ;rotmat1zHi:	DB	0				; INWK +20
 13+  8361              ;rotmat2xLo: DB	0				; INWK +21
 14+  8361              ;rotmat2xHi:	DB	0				; INWK +22
 15+  8361              ;rotmat2yLo:	DB	0				; INWK +23
 16+  8361              ;rotmat2yHi:	DB	0				; INWK +24
 17+  8361              ;rotmat2zLo:	DB	0				; INWK +25
 18+  8361              ;rotmat2zHi:	DB	0				; INWK +26
 19+  8361              ;
 20+  8361              ;rotmatFx	equ	rotmat0xHi
 21+  8361              ;rotmatFy	equ	rotmat0yHi
 22+  8361              ;rotmatFz	equ	rotmat0zHi
 23+  8361              ;rotmatUx	equ	rotmat1xHi
 24+  8361              ;rotmatUy	equ	rotmat1yHi
 25+  8361              ;rotmatUz	equ	rotmat1zHi
 26+  8361              ;
 27+  8361              ;inwkarray			equ		INWK+10
 28+  8361
 29+  8361
 30+  8361
 31+  8361
 32+  8361              ; Divide that sets value to FFFF if divide by 0 unless main value is 0, then 0
 33+  8361
 34+  8361              ; (P+1 A) = (A P) / Q
 35+  8361              ;  B A    = (A P) / Q
 36+  8361              ; TESTED OK
 37+  8361
 38+  8361
 39+  8361 2A 0F 81     NormalizeXX15:          ld      hl, (XX15VecX)              ; h= VecX, l = VecY
 40+  8364 3A 11 81                             ld      a,  (XX15VecZ)              ; a = VecZ, d we don't care
 41+  8367 E6 7F        .ABSZ:                  and     SignMask8Bit
 42+  8369 FD 67                                ld      iyh,a                       ; iyh = abs z
 43+  836B 57           .ZSquared:              ld      d,a
 44+  836C 5F                                   ld      e,a
 45+  836D ED 30                                mul     de
 46+  836F 42 4B                                ld      bc,de                       ; bc = z squared
 47+  8371 7D           .ABSX:                  ld      a,l
 48+  8372 E6 7F        .XSquared:              and     SignMask8Bit
 49+  8374 DD 67                                ld      ixh,a                       ; ixh = abs x
 50+  8376 57                                   ld      d,a
 51+  8377 5F                                   ld      e,a
 52+  8378 ED 30                                mul     de
 53+  837A EB                                   ex      de,hl                       ; hl = x squared
 54+  837B 7A           .ABSY:                  ld      a,d                         ; as h was swapped into d
 55+  837C E6 7F                                and     SignMask8Bit
 56+  837E DD 6F                                ld      ixl,a                       ; ixl = abs y
 57+  8380 5F           .YSquared:              ld      e,a
 58+  8381 57                                   ld      d,a
 59+  8382 ED 30                                mul     de                          ; de = y squared
 60+  8384 19                                   add     hl,de                       ; hl = hl + de + bc
 61+  8385 09                                   add     hl,bc                       ;
 62+  8386 EB                                   ex      de,hl
 63+  8387 CD DC 80                             call    asm_sqrt                    ; d = iyl =hl = sqrt (de) = sqrt (x ^ 2 + y ^ 2 + z ^ 2)
 64+  838A 55                                   ld      d,l
 65+  838B FD 6A                                ld      iyl,d
 66+  838D DD 7C        .NormaliseX:            ld      a,ixh                       ; normalise x
 67+  838F CD 17 82                             call    AequAdivDmul967Bit
 68+  8392 57                                   ld      d,a
 69+  8393 3A 0F 81                             ld      a,(XX15VecX)
 70+  8396 E6 80                                and     SignOnly8Bit
 71+  8398 B2                                   or      d
 72+  8399 32 0F 81                             ld      (XX15VecX),a
 73+  839C DD 7D        .NormaliseY:            ld      a,ixl                       ; normalise y
 74+  839E 55                                   ld      d,l
 75+  839F CD 17 82                             call    AequAdivDmul967Bit
 76+  83A2 57                                   ld      d,a
 77+  83A3 3A 10 81                             ld      a,(XX15VecY)
 78+  83A6 E6 80                                and     SignOnly8Bit
 79+  83A8 B2                                   or      d
 80+  83A9 32 10 81                             ld      (XX15VecY),a
 81+  83AC FD 7C        .NormaliseZ:            ld      a,iyh                       ; normalise z
 82+  83AE 55                                   ld      d,l
 83+  83AF CD 17 82                             call    AequAdivDmul967Bit
 84+  83B2 57                                   ld      d,a
 85+  83B3 3A 11 81                             ld      a,(XX15VecZ)
 86+  83B6 E6 80                                and     SignOnly8Bit
 87+  83B8 B2                                   or      d
 88+  83B9 32 11 81                             ld      (XX15VecZ),a
 89+  83BC C9                                   ret
 90+  83BD
 91+  83BD
 92+  83BD CD 52 81     TidyUbnK:               call	CopyRotMatNoseVtoXX15
 93+  83C0 CD 61 83                             call	NormalizeXX15			; normalise z hi, its really TIS3
 94+  83C3 CD 8B 81                             call	CopyXX15toRotMatNoseV
 95+  83C6 3A 2B 81                             ld      a,(UBnkrotmatNosevX+1)
 96+  83C9 E6 60                                and     %01100000
 97+  83CB 28 67                                jr      z,.XIsSmall
 98+  83CD 3A 2D 81                             ld      a,(UBnkrotmatNosevY+1)
 99+  83D0 28 31                                jr      z,.YIsSmall
100+  83D2              ;...roofv_z´ = -(nosev_x´ * roofv_x + nosev_y´ * roofv_y) / nosev_z´
101+  83D2 3A 2B 81     .ZIsSmall:              ld		a,(UBnkrotmatNosevX+1)
102+  83D5 32 A2 80                             ld		(varQ),a					; q = nosev_y
103+  83D8 3A 25 81                             ld		a,(UBnkrotmatRoofvX+1)	     ;roov z
104+  83DB CD 60 82                             call	RSequQmulA
105+  83DE 3A 2D 81                             ld		a,(UBnkrotmatNosevY+1)		; nosev z
106+  83E1 32 A2 80                             ld		(varQ),a							; b = regX for now
107+  83E4 3A 27 81                             ld		a,(UBnkrotmatRoofvY+1)	    ; roofv y
108+  83E7 CD BB 89                             call	madDEequQmulAaddRS
109+  83EA 7A                                   ld      a,d                         ; flip sign bit
110+  83EB EE 80                                xor     SignOnly8Bit
111+  83ED 57                                   ld      d,a
112+  83EE 3A 2F 81                             ld      a,(UBnkrotmatNosevZ+1)
113+  83F1 32 A2 80                             ld      (varQ),a
114+  83F4 7B                                   ld      a,e
115+  83F5 32 A0 80                             ld      (varP),a
116+  83F8 7A                                   ld      a,d
117+  83F9 CD 69 86                             call    DVIDT
118+  83FC 78                                   ld      a,b
119+  83FD 32 29 81                             ld      (UBnkrotmatRoofvZ+1),a
120+  8400 C3 62 84                             jp      .DoneRoof
121+  8403              ;...roofv_y´ = -(nosev_x´ * roofv_x + nosev_z´ * roofv_z) / nosev_y´
122+  8403 3A 2B 81     .YIsSmall:              ld		a,(UBnkrotmatNosevX+1)
123+  8406 32 A2 80                             ld		(varQ),a					; q = nosev_y
124+  8409 3A 25 81                             ld		a,(UBnkrotmatRoofvX+1)	     ;roov z
125+  840C CD 60 82                             call	RSequQmulA
126+  840F 3A 2F 81                             ld		a,(UBnkrotmatNosevZ+1)		; nosev z
127+  8412 32 A2 80                             ld		(varQ),a							; b = regX for now
128+  8415 3A 29 81                             ld		a,(UBnkrotmatRoofvZ+1)	    ; roofv y
129+  8418 CD BB 89                             call	madDEequQmulAaddRS
130+  841B 7A                                   ld      a,d                         ; flip sign bit
131+  841C EE 80                                xor     SignOnly8Bit
132+  841E 57                                   ld      d,a
133+  841F 3A 2D 81                             ld      a,(UBnkrotmatNosevY+1)
134+  8422 32 A2 80                             ld      (varQ),a
135+  8425 7B                                   ld      a,e
136+  8426 32 A0 80                             ld      (varP),a
137+  8429 7A                                   ld      a,d
138+  842A CD 69 86                             call    DVIDT
139+  842D 78                                   ld      a,b
140+  842E 32 27 81                             ld      (UBnkrotmatRoofvY+1),a
141+  8431 C3 62 84                             jp      .DoneRoof
142+  8434              ;...roofv_x´ = -(nosev_y´ * roofv_y + nosev_z´ * roofv_z) / nosev_x´
143+  8434 3A 2D 81     .XIsSmall:              ld		a,(UBnkrotmatNosevY+1)
144+  8437 32 A2 80                             ld		(varQ),a					; q = nosev_y
145+  843A 3A 27 81                             ld		a,(UBnkrotmatRoofvY+1)	     ;roov z
146+  843D CD 60 82                             call	RSequQmulA
147+  8440 3A 2F 81                             ld		a,(UBnkrotmatNosevZ+1)		; nosev z
148+  8443 32 A2 80                             ld		(varQ),a							; b = regX for now
149+  8446 3A 29 81                             ld		a,(UBnkrotmatRoofvZ+1)	    ; roofv y
150+  8449 CD BB 89                             call	madDEequQmulAaddRS
151+  844C 7A                                   ld      a,d                         ; flip sign bit
152+  844D EE 80                                xor     SignOnly8Bit
153+  844F 57                                   ld      d,a
154+  8450 3A 2B 81                             ld      a,(UBnkrotmatNosevX+1)
155+  8453 32 A2 80                             ld      (varQ),a
156+  8456 7B                                   ld      a,e
157+  8457 32 A0 80                             ld      (varP),a
158+  845A 7A                                   ld      a,d
159+  845B CD 69 86                             call    DVIDT
160+  845E 78                                   ld      a,b
161+  845F 32 25 81                             ld      (UBnkrotmatRoofvX+1),a
162+  8462 CD 65 81     .DoneRoof:              call	CopyRotMatRoofVtoXX15
163+  8465 CD 61 83                             call	NormalizeXX15			; normalise z hi, its really TIS3
164+  8468 CD A8 81                             call	CopyXX15toRotMatRoofV
165+  846B 3A 2F 81     .DoSidevX:              ld		a,(UBnkrotmatNosevZ+1)      ;  -(-nosev_z * roofv_y + nosev_y * roofv_z) / 96
166+  846E EE 80                                xor     SignOnly8Bit
167+  8470 32 A2 80                             ld		(varQ),a					; q = nosev_y
168+  8473 3A 27 81                             ld		a,(UBnkrotmatRoofvY+1)	     ;roov z
169+  8476 CD 60 82                             call	RSequQmulA
170+  8479 3A 2D 81                             ld		a,(UBnkrotmatNosevY+1)		; nosev z
171+  847C 32 A2 80                             ld		(varQ),a							; b = regX for now
172+  847F 3A 29 81                             ld		a,(UBnkrotmatRoofvZ+1)	    ; roofv y
173+  8482 CD BB 89                             call	madDEequQmulAaddRS
174+  8485 CD B1 86                             call    BAequDEdiv96
175+  8488 78                                   ld      a,b
176+  8489 32 1F 81                             ld      (UBnkrotmatSidevX+1),a
177+  848C 3A 2B 81     .DoSidevY:              ld		a,(UBnkrotmatNosevX+1)      ; -(-nosev_x * roofv_z - nosev_z * roofv_x) / 96
178+  848F EE 80                                xor     SignOnly8Bit
179+  8491 32 A2 80                             ld		(varQ),a					; q = nosev_y
180+  8494 3A 29 81                             ld		a,(UBnkrotmatRoofvZ+1)	    ;roov z
181+  8497 CD 60 82                             call	RSequQmulA
182+  849A 3A 2F 81                             ld		a,(UBnkrotmatNosevZ+1)		; nosev z
183+  849D 32 A2 80                             ld		(varQ),a							; b = regX for now
184+  84A0 3A 29 81                             ld		a,(UBnkrotmatRoofvZ+1)	    ; roofv y
185+  84A3 CD BB 89                             call	madDEequQmulAaddRS
186+  84A6 CD B1 86                             call    BAequDEdiv96
187+  84A9 78                                   ld      a,b
188+  84AA 32 21 81                             ld      (UBnkrotmatSidevY+1),a         ;-(-nosev_y * roofv_x + nosev_x * roofv_y) / 96
189+  84AD 3A 2D 81     .DoSidevZ:              ld		a,(UBnkrotmatNosevY+1)      ;
190+  84B0 EE 80                                xor     SignOnly8Bit
191+  84B2 32 A2 80                             ld		(varQ),a					; q = nosev_y
192+  84B5 3A 29 81                             ld		a,(UBnkrotmatRoofvZ+1)	     ;roov z
193+  84B8 CD 60 82                             call	RSequQmulA
194+  84BB 3A 2B 81                             ld		a,(UBnkrotmatNosevX+1)		; nosev z
195+  84BE 32 A2 80                             ld		(varQ),a							; b = regX for now
196+  84C1 3A 27 81                             ld		a,(UBnkrotmatRoofvY+1)	    ; roofv y
197+  84C4 CD BB 89                             call	madDEequQmulAaddRS
198+  84C7 CD B1 86                             call    BAequDEdiv96
199+  84CA 78                                   ld      a,b
200+  84CB 32 23 81                             ld      (UBnkrotmatSidevZ+1),a
201+  84CE                                      ZeroA
201+  84CE AF          >                        xor a
202+  84CF 32 1E 81                             ld      (UBnkrotmatSidevX),a
203+  84D2 32 20 81                             ld      (UBnkrotmatSidevY),a
204+  84D5 32 22 81                             ld      (UBnkrotmatSidevZ),a
205+  84D8 C9                                   ret
206+  84D9
207+  84D9
208+  84D9              TidySub1:									;.TIS1	\ -> &293B  \ Tidy subroutine 1  X.A =  (-X*A  + (R.S))/96
209+  84D9              		; b = regX on entry
210+  84D9              TIS1Prep:									;.TIS1	\ -> &293B  \ Tidy subroutine 1 using B register = X
211+  84D9 08           		ex		af,af'
212+  84DA 78           		ld		a,b
213+  84DB 32 A2 80     		ld		(varQ),a
214+  84DE 08           		ex		af,af'
215+  84DF EE 80        		xor		$80							;	 flip sign of Acc
216+  84E1 CD 99 89     		call	madXAequQmulAaddRS			; \ MAD \ multiply and add (X,A) =  -X*A  + (R,S)
217+  84E4              ; USES 				A BC E
218+  84E4              ; DOES NOT USE		D HL
219+  84E4              Tis1Div96:							   		; .DVID96	\ Their comment A=A/96: answer is A*255/96
220+  84E4 4F           		ld		c,a							; Store sign bit in  ct (we use e reg for that)
221+  84E5 E6 80        		and		SignOnly8Bit						; ..
222+  84E7 5F           		ld		e,a							; ..
223+  84E8 79           		ld		a,c							; a = high byte again with sign bit cleared
224+  84E9 E6 7F        		and		SignMask8Bit							; ..
225+  84EB 06 FE        		ld		b,$FE						; slide counter T1
226+  84ED              TIS1RollTLoop								; roll T1  clamp Acc to #96 for rotation matrix unity
227+  84ED CB 27        		sla		a
228+  84EF              		JumpIfALTNusng $60, TIS1SkipSub
228+  84EF FE 60       >                        cp      $60
228+  84F1 DA FE 84    >                        jp		c, TIS1SkipSub
229+  84F4 DE 60        		sbc		a,$60							; subtract 96
230+  84F6 37           		scf
231+  84F7 CB 10        		rl		b							;  T1
232+  84F9 38 F2        		jr		c,TIS1RollTLoop
233+  84FB              TIS1KIPCont:
234+  84FB 78           		ld		a,b							;   T1
235+  84FC B3           		or		e							;   restore T sign
236+  84FD C9           		ret
237+  84FE              TIS1SkipSub:
238+  84FE B7           	or			a
239+  84FF CB 10        	rl			b							; T rolled left to push bit out the end
240+  8501 38 EA        	jr			c,TIS1RollTLoop				; if we still have not hit the empty marker continue
241+  8503 C3 FB 84     	jp			TIS1KIPCont
242+  8506
243+  8506              ;.TIDY	\ -> &4679 \ Orthogonalize rotation matrix that uses 0x60 as unity returns INWK(16,18,20) = INWK(12*18+14*20, 10*16+14*20, 10*16+12*18) / INWK(10,12,14)
244+  8506              ; Ux,Uy,Uz = -(FyUy+FzUz, FxUx+FzUz, FxUx+FyUy)/ Fx,Fy,Fz
245+  8506
246+  8506
247+  8506
248+  8506
249+  8506              TidyRotYSmall:
250+  8506 CD 2F 86     		call	CalcRoofvZ
251+  8509 32 29 81     		ld		(UBnkrotmatRoofvZ+1),a			; set roofvy hi?? Says roofz TODO
252+  850C C3 40 85     		jp		NormaliseRoofV
253+  850F
254+  850F              TidyRotXSmall:
255+  850F AF           		xor		a
256+  8510 47           		ld		b,a
257+  8511 3A 2D 81     		ld		a,(UBnkrotmatNosevY+1)			; nosev_y
258+  8514 E6 60        		and		%01100000
259+  8516 CA 06 85     		jp		z,TidyRotYSmall
260+  8519 3A 2F 81     		ld		a,(UBnkrotmatNosevZ+1)			; nosev z
261+  851C 47           		ld		b,a							; b = regX for now
262+  851D 3A 27 81     		ld		a,(UBnkrotmatRoofvY+1)			; roofv y
263+  8520 CD F5 85     		call	CalcRoofvY					; Set (roofvy= (nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y, Q -= nosev_z
264+  8523 32 27 81     		ld		(UBnkrotmatRoofvY+1),a			; set roofvy hi
265+  8526 C3 40 85     		jp		NormaliseRoofV
266+  8529              ; TIDY is broken
267+  8529
268+  8529
269+  8529              TIDY:
270+  8529
271+  8529              ORTHOGALISE:
272+  8529              ;-- NormaliseNosev
273+  8529 CD 52 81     		call	CopyRotMatNoseVtoXX15
274+  852C CD 8D 82     		call	normaliseXX1596fast			; normalise z hi, its really TIS3
275+  852F CD 8B 81     		call	CopyXX15toRotMatNoseV
276+  8532              .CheckNXSmall:
277+  8532 3A 2B 81     		ld		a,(UBnkrotmatNosevX+1)
278+  8535 E6 60        		and		%01100000					; check top two magnitude bits
279+  8537 CA 0F 85     		jp		z,TidyRotXSmall
280+  853A              .RotXIsBig:
281+  853A CD BB 85             call	CalcRoofvX
282+  853D 32 25 81     		ld		(UBnkrotmatRoofvX+1),a    	; set roofvx hi
283+  8540              NormaliseRoofV:
284+  8540 CD 65 81     		call	CopyRotMatRoofVtoXX15		; xx15 = roofv
285+  8543 CD 8D 82     		call	normaliseXX1596fast			; normalise roof
286+  8546              ;calc sidev x
287+  8546 CD A8 81     		call	CopyXX15toRotMatRoofV		; get back normalised version
288+  8549 3A 2B 81     		ld		a,(UBnkrotmatNosevX+1)
289+  854C 32 A2 80     		ld		(varQ),a					; q = nosev_y
290+  854F 3A 29 81     		ld		a,(UBnkrotmatRoofvZ+1)	     ;roov z
291+  8552 CD 60 82     		call	RSequQmulA
292+  8555 3A 2F 81     		ld		a,(UBnkrotmatNosevZ+1)		; nosev z
293+  8558 47           		ld		b,a							; b = regX for now
294+  8559 3A 27 81     		ld		a,(UBnkrotmatRoofvY+1)	    ; roofv y
295+  855C CD D9 84     		call	TidySub1					; Set (A ?)= (-nosev_z * roofv_y + nosev_y * roofv_z) / 96, Q -= nosev_z
296+  855F                      JumpIfAIsZero NormSideXNoNeg
296+  855F A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
296+  8560 CA 65 85    >                        jp	    z, NormSideXNoNeg
297+  8563 EE 80        		xor		$80							; flip a to get -sidev_x
298+  8565              NormSideXNoNeg:
299+  8565 32 1F 81     		ld		(UBnkrotmatSidevX+1),a
300+  8568              ;calc sidev y
301+  8568 3A 2F 81     		ld		a,(UBnkrotmatNosevZ+1)			; nosev z
302+  856B 32 A2 80     		ld		(varQ),a
303+  856E 3A 25 81     		ld		a,(UBnkrotmatRoofvX+1)			; roofv x
304+  8571 CD 60 82     		call	RSequQmulA
305+  8574 3A 2B 81     		ld		a,(UBnkrotmatNosevX+1)			        ; nosev x
306+  8577 47           		ld		b,a							; b = regX for now
307+  8578 3A 29 81     		ld		a,(UBnkrotmatRoofvZ+1)			; roofv z
308+  857B CD D9 84     		call	TidySub1					; Set (A ?)= (-nosev_z * roofv_y + nosev_y * roofv_z) / 96, Q -= nosev_z
309+  857E                      JumpIfAIsZero NormSideYNoNeg
309+  857E A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
309+  857F CA 84 85    >                        jp	    z, NormSideYNoNeg
310+  8582 EE 80        		xor		$80							; flip a to get -sidev_y
311+  8584              NormSideYNoNeg:
312+  8584 32 2D 81     		ld		(UBnkrotmatNosevY+1),a
313+  8587              ;calc sidev z
314+  8587 3A 2B 81     		ld		a,(UBnkrotmatNosevX+1)			; nosev x
315+  858A 32 A2 80     		ld		(varQ),a
316+  858D 3A 27 81     		ld		a,(UBnkrotmatRoofvY+1)			; roofv y
317+  8590 CD 60 82     		call	RSequQmulA
318+  8593 3A 2D 81     		ld		a,(UBnkrotmatNosevY+1)			; nosev y
319+  8596 47           		ld		b,a							; b = regX for now
320+  8597 3A 25 81     		ld		a,(UBnkrotmatRoofvX+1)			; roofv x
321+  859A CD D9 84     		call	TidySub1					; Set (A ?)= (-nosev_z * roofv_y + nosev_y * roofv_z) / 96, Q -= nosev_z
322+  859D                      JumpIfAIsZero NormSideZNoNeg
322+  859D A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
322+  859E CA A3 85    >                        jp	    z, NormSideZNoNeg
323+  85A1 EE 80        		xor		$80							; flip a to get -sidev_y
324+  85A3              NormSideZNoNeg:
325+  85A3 32 21 81     		ld		(UBnkrotmatSidevY+1),a ;TODO SHoudl this be Y??
326+  85A6              .ClearLoBytes:
327+  85A6 21 2A 81     		ld		hl,UBnkrotmatNosevX
328+  85A9 06 09        		ld		b,9
329+  85AB AF                   xor     a
330+  85AC              .ClearLoLoop:
331+  85AC 77           		ld		(hl),a						; zero out lo bytes
332+  85AD 23           		inc		hl
333+  85AE 23           		inc		hl
334+  85AF 10 FB        		djnz	.ClearLoLoop
335+  85B1 CD 78 81     		call	CopyRotMatSideVtoXX15		; xx15 = roofv
336+  85B4 CD 8D 82     		call	normaliseXX1596fast			; normalise roof
337+  85B7              ;calc sidev x
338+  85B7 CD C5 81     		call	CopyXX15toRotMatSideV		; get back normalised version
339+  85BA
340+  85BA C9           		ret
341+  85BB
342+  85BB
343+  85BB
344+  85BB              ;;;;;;;;.CheckNYSmall:
345+  85BB              ;;;;;;;;		ld		a,(XX15+2)					; first check z zero, if so we have to do Y
346+  85BB              ;;;;;;;;		and		$7F
347+  85BB              ;;;;;;;;		cp		0
348+  85BB              ;;;;;;;;		jp		z,Tidy1RZ
349+  85BB              ;;;;;;;;		ld		a,(XX15+1)					; now we can do a realistic check of RY
350+  85BB              ;;;;;;;;		cp 		0							; we can't end up with divide by 0 for RY
351+  85BB              ;;;;;;;;		jp		z,Tidy1RZ					; We can't have all values of vector 0 so we must do RZ
352+  85BB              ;;;;;;;;		and		%01100000					; check top two magnitude bits
353+  85BB              ;;;;;;;;		jp		z,Tidy1RY					; and tidy based on roofy
354+  85BB              ;;;;;;;;.DoNZ:
355+  85BB              ;;;;;;;;		jp		Tidy1RZ						; else we tidy based on roofz
356+  85BB              ;;;;;;;;;---RE ENTRY POINT -------------------------------------
357+  85BB              ;;;;;;;;NormaliseRoofv:
358+  85BB              ;;;;;;;;		call	CopyRotMatRoofVtoXX15		; xx15 = roofv
359+  85BB              ;;;;;;;;		push	bc
360+  85BB              ;;;;;;;;		call	normaliseXX1596fast			; normalise
361+  85BB              ;;;;;;;;		pop		bc
362+  85BB              ;;;;;;;;		call	CopyXX15toRotMatRoofV		; get back normalised version
363+  85BB              ;;;;;;;;ProcessSidev:
364+  85BB              ;;;;;;;;; -- SIDEV X
365+  85BB              ;;;;;;;;		ldCopyByte	nosev_z+1, varQ         ; use ixh as Q later
366+  85BB              ;;;;;;;;		ld		a,(UBnkrotmatRoofvY+1)				; a = roofv_hi
367+  85BB              ;;;;;;;;		push	bc
368+  85BB              ;;;;;;;;		call	RSequQmulA					; RS = Q * A MULT12
369+  85BB              ;;;;;;;;		pop		bc
370+  85BB              ;;;;;;;;		ld		a,(UBnkrotmatNosevY+1)
371+  85BB              ;;;;;;;;		ld		b,a							; set x (b) to value of nosev_z
372+  85BB              ;;;;;;;;		ld		a,(UBnkrotmatRoofvZ+1)				; a = roofv_y hi
373+  85BB              ;;;;;;;;		push	bc
374+  85BB              ;;;;;;;;		call	TidySub1					; set A (-nosev_z * roofv_y + nosev_y * roofv_z) / 96, This also sets Q = nosev_z TIS1
375+  85BB              ;;;;;;;;		pop		bc
376+  85BB              ;;;;;;;;		ld		(UBnkrotmatSidevX+1),a				; sidev_x = = (nosev_z * roofv_y - nosev_y * roofv_z) / 96
377+  85BB              ;;;;;;;;; -- SIDEV Y
378+  85BB              ;;;;;;;;		ldCopyByte	UBnkrotmatNosevX+1, varQ         ; use ixh as Q later
379+  85BB              ;;;;;;;;		ld		a,(UBnkrotmatRoofvZ+1)				;
380+  85BB              ;;;;;;;;		push	bc
381+  85BB              ;;;;;;;;		call	RSequQmulA					; RS = Q * A MULT12 MULT12
382+  85BB              ;;;;;;;;		pop		bc
383+  85BB              ;;;;;;;;		ld		a,(UBnkrotmatNosevZ+1)
384+  85BB              ;;;;;;;;		ld		b,a
385+  85BB              ;;;;;;;;		ld		a,(UBnkrotmatRoofvX+1)
386+  85BB              ;;;;;;;;		push	bc
387+  85BB              ;;;;;;;;		call	TidySub1						; set A (-nosev_z * roofv_y + nosev_y * roofv_z) / 96, This also sets Q = nosev_z
388+  85BB              ;;;;;;;;		pop		bc
389+  85BB              ;;;;;;;;		ld		(sidev_y+1),a				; sidev_y  = (nosev_x * roofv_z - nosev_z * roofv_x) / 96
390+  85BB              ;;;;;;;;		ld		a,(UBnkrotmatRoofvY+1)
391+  85BB              ;;;;;;;;		push	bc
392+  85BB              ;;;;;;;;; -- SIDEV Z
393+  85BB              ;;;;;;;;		ldCopyByte	UBnkrotmatNosevY+1, varQ         ; use ixh as Q later
394+  85BB              ;;;;;;;;		ld		a,(UBnkrotmatRoofvX+1)				;
395+  85BB              ;;;;;;;;		call	RSequQmulA					; RS = Q * A MULT12
396+  85BB              ;;;;;;;;		pop		bc
397+  85BB              ;;;;;;;;		ld		a,(UBnkrotmatNosevX+1)
398+  85BB              ;;;;;;;;		ld		b,a
399+  85BB              ;;;;;;;;		ld		a,(UBnkrotmatRoofvY+1)
400+  85BB              ;;;;;;;;		push	bc
401+  85BB              ;;;;;;;;		call	TidySub1						; set A (-nosev_z * roofv_y + nosev_y * roofv_z) / 96, This also sets Q = nosev_z
402+  85BB              ;;;;;;;;		pop		bc
403+  85BB              ;;;;;;;;		ld		(sidev_z+1),a
404+  85BB              ;;;;;;;;		xor		a							; set a = 0 so we can clear orientation low bytes
405+  85BB              ;;;;;;;;		ld		hl,sidev_z
406+  85BB              ;;;;;;;;		ld		b,9							; only on 6 cells (3 x row 0 and row 1)
407+  85BB              ;;;;;;;;		ld		hl,UBnkrotmatNosevX
408+  85BB              ;;;;;;;;NormaliseSideV:
409+  85BB              ;;;;;;;;		call	CopyRotMatSideVtoXX15		; xx15 = roofv
410+  85BB              ;;;;;;;;		push	bc
411+  85BB              ;;;;;;;;		call	normaliseXX1596fast			; normalise
412+  85BB              ;;;;;;;;		pop		bc
413+  85BB              ;;;;;;;;		call	CopyXX15toRotMatSideV		; get back normalised version
414+  85BB              ;;;;;;;;
415+  85BB
416+  85BB
417+  85BB              CalcRoofvX:
418+  85BB              Tidy1RX:										; roofv_x´ = -(nosev_y´ * roofv_y + nosev_z´ * roofv_z) / nosev_x´
419+  85BB              		ldCopyByte UBnkrotmatNosevZ+1,varQ
419+  85BB 3A 2F 81    >                        ld       a,(UBnkrotmatNosevZ+1)
419+  85BE 32 A2 80    >                        ld       (varQ),a
420+  85C1 3A 29 81     		ld		a,(UBnkrotmatRoofvZ+1)
421+  85C4 CD 60 82     		call	RSequQmulA						; rs = nosez hi * roofz hi
422+  85C7              		ldCopyByte UBnkrotmatNosevY+1,varQ
422+  85C7 3A 2D 81    >                        ld       a,(UBnkrotmatNosevY+1)
422+  85CA 32 A2 80    >                        ld       (varQ),a
423+  85CD 3A 27 81     		ld		a,(UBnkrotmatRoofvY+1)
424+  85D0 CD 99 89     		call	madXAequQmulAaddRS				; DE = nosey hi * roofy hi + rs
425+  85D3 7A           		ld		a,d
426+  85D4 E6 80        		and 	$80
427+  85D6 FD 67        		ld		iyh,a
428+  85D8              ;DEBUG		ld		c,a
429+  85D8 3A 2B 81     		ld		a,(UBnkrotmatNosevX+1)					; get nosev x sign
430+  85DB 4F           		ld		c,a								; temp save
431+  85DC E6 80        		and		$80
432+  85DE FD AC        		xor		iyh								; flip from saved multiply sign result
433+  85E0 FD 67        		ld		iyh,a							; save nosesev sign to iyh
434+  85E2 79           		ld		a,c								; recover a
435+  85E3 E6 7F        		and		$7F								; a is unsigned nosev x
436+  85E5 42           		ld		b,d
437+  85E6 4B           		ld		c,e								; bc = nosev_y´ * roofv_y + nosev_z´ * roofv_z
438+  85E7 57           		ld		d,a								; de = nosev x hi
439+  85E8 1E 00        		ld		e,0
440+  85EA CD 97 88     		call	BC_Div_DE
441+  85ED FD 7C        		ld		a,iyh							; get back sign from nosevx
442+  85EF EE 80        		xor		$80								; flip sign
443+  85F1 E6 80        		and		$80								; keep sign bit only
444+  85F3 B0           		or		b
445+  85F4 C9           		ret
446+  85F5
447+  85F5
448+  85F5              CalcRoofvY:
449+  85F5              Tidy1RY:										; roofv_y´ = -(nosev_x´ * roofv_x + nosev_z´ * roofv_z) / nosev_y´
450+  85F5              		ldCopyByte UBnkrotmatNosevZ+1,varQ				;                  A        Q              RS
450+  85F5 3A 2F 81    >                        ld       a,(UBnkrotmatNosevZ+1)
450+  85F8 32 A2 80    >                        ld       (varQ),a
451+  85FB 3A 29 81     		ld		a,(UBnkrotmatRoofvZ+1)
452+  85FE CD 60 82     		call	RSequQmulA
453+  8601              		ldCopyByte UBnkrotmatNosevX+1,varQ
453+  8601 3A 2B 81    >                        ld       a,(UBnkrotmatNosevX+1)
453+  8604 32 A2 80    >                        ld       (varQ),a
454+  8607 3A 25 81     		ld		a,(UBnkrotmatRoofvX+1)
455+  860A CD 99 89     		call	madXAequQmulAaddRS
456+  860D 7A           		ld		a,d
457+  860E E6 80        		and 	$80
458+  8610 FD 67        		ld		iyh,a
459+  8612 3A 2D 81     		ld		a,(UBnkrotmatNosevY+1)					; get nosev x sign
460+  8615 4F           		ld		c,a								; temp save
461+  8616 E6 80        		and		$80
462+  8618 FD AC        		xor		iyh								; flip from saved multiply sign result
463+  861A FD 67        		ld		iyh,a							; save nosesev sign to iyh
464+  861C 79           		ld		a,c								; recover a
465+  861D E6 7F        		and		$7F								; a is unsigned nosev x
466+  861F 42           		ld		b,d
467+  8620 4B           		ld		c,e								; bc = nosev_y´ * roofv_y + nosev_z´ * roofv_z
468+  8621 57           		ld		d,a								; de = nosev x hi
469+  8622 1E 00        		ld		e,0
470+  8624 CD 97 88     		call	BC_Div_DE
471+  8627 FD 7C        		ld		a,iyh
472+  8629 EE 80        		xor		$80
473+  862B E6 80        		and		$80
474+  862D B0           		or		b
475+  862E C9           		ret
476+  862F
477+  862F              CalcRoofvZ:
478+  862F              Tidy1RZ:										; roofv_z´ = -(nosev_x´ * roofv_x + nosev_y´ * roofv_y) / nosev_z´
479+  862F              		ldCopyByte UBnkrotmatNosevY+1,varQ
479+  862F 3A 2D 81    >                        ld       a,(UBnkrotmatNosevY+1)
479+  8632 32 A2 80    >                        ld       (varQ),a
480+  8635 3A 27 81     		ld		a,(UBnkrotmatRoofvY+1)
481+  8638 CD 60 82     		call	RSequQmulA						; rs = NOSEy * ROOFy
482+  863B              		ldCopyByte UBnkrotmatNosevX+1,varQ
482+  863B 3A 2B 81    >                        ld       a,(UBnkrotmatNosevX+1)
482+  863E 32 A2 80    >                        ld       (varQ),a
483+  8641 3A 25 81     		ld		a,(UBnkrotmatRoofvX+1)
484+  8644 CD 99 89     		call	madXAequQmulAaddRS				; de (A,ixl) = NOSEx * ROOFx + RS
485+  8647 7A           		ld		a,d
486+  8648 E6 80        		and 	$80
487+  864A FD 67        		ld		iyh,a
488+  864C 3A 2F 81     		ld		a,(UBnkrotmatNosevZ+1)					; get nosev x sign
489+  864F 4F           		ld		c,a								; temp save
490+  8650 E6 80        		and		$80
491+  8652 FD AC        		xor		iyh								; flip from saved multiply sign result
492+  8654 FD 67        		ld		iyh,a							; save nosesev sign to iyh
493+  8656 79           		ld		a,c								; recover a
494+  8657 E6 7F        		and		$7F								; a is unsigned nosev x
495+  8659 42           		ld		b,d
496+  865A 4B           		ld		c,e								; bc = nosev_y´ * roofv_y + nosev_z´ * roofv_z
497+  865B 57           		ld		d,a								; de = nosev x hi
498+  865C 1E 00        		ld		e,0
499+  865E CD 97 88     		call	BC_Div_DE
500+  8661 FD 7C        		ld		a,iyh
501+  8663 EE 80        		xor		$80
502+  8665 E6 80        		and		$80
503+  8667 B0           		or		b
504+  8668 C9           		ret
505+  8669
506+  8669
507+  8669
508+  8669              ;;ProcessSidev:
509+  8669              ;;		ldCopyByte	UBnkrotmatNosevZ+1, varQ         ; use ixh as Q later
510+  8669              ;;		ld		a,(UBnkrotmatRoofvY+1)				; a = roofv_hi
511+  8669              ;;		push	bc
512+  8669              ;;		call	RSequQmulA					; RS = Q * A MULT12
513+  8669              ;;		pop		bc
514+  8669              ;;		ld		a,(UBnkrotmatNosevY+1)
515+  8669              ;;		ld		b,a							; set x (b) to value of nosev_z
516+  8669              ;;		ld		a,(UBnkrotmatRoofvZ+1)				; a = roofv_y hi
517+  8669              ;;		push	bc
518+  8669              ;;		call	TidySub1					; set A (-nosev_z * roofv_y + nosev_y * roofv_z) / 96, This also sets Q = nosev_z TIS1
519+  8669              ;;		pop		bc
520+  8669              ;;		xor		$80							; sidev_x = -a by flipping sign bit
521+  8669              ;;		ld		(UBnkrotmatSidevX+1),a				; sidev_x = = (nosev_z * roofv_y - nosev_y * roofv_z) / 96
522+  8669              ;;		ldCopyByte	UBnkrotmatNosevX+1, varQ         ; use ixh as Q later
523+  8669              ;;		ld		a,(UBnkrotmatRoofvZ+1)				;
524+  8669              ;;		push	bc
525+  8669              ;;		call	RSequQmulA					; RS = Q * A MULT12 MULT12
526+  8669              ;;		pop		bc
527+  8669              ;;		ld		a,(UBnkrotmatNosevZ+1)
528+  8669              ;;		ld		b,a
529+  8669              ;;		ld		a,(UBnkrotmatNosevY+1)
530+  8669              ;;		push	bc
531+  8669              ;;		call	TidySub1						; set A (-nosev_z * roofv_y + nosev_y * roofv_z) / 96, This also sets Q = nosev_z
532+  8669              ;;		pop		bc
533+  8669              ;;		xor		$80							; a *= -1
534+  8669              ;;		ld		(UBnkrotmatSidevY+1),a				; sidev_y  = (nosev_x * roofv_z - nosev_z * roofv_x) / 96
535+  8669              ;;		ld		a,(UBnkrotmatRoofvY+1)
536+  8669              ;;		push	bc
537+  8669              ;;		ldCopyByte	UBnkrotmatNosevY+1, varQ         ; use ixh as Q later
538+  8669              ;;		ld		a,(UBnkrotmatRoofvX+1)				;
539+  8669              ;;		call	RSequQmulA					; RS = Q * A MULT12
540+  8669              ;;		pop		bc
541+  8669              ;;		ld		a,(UBnkrotmatNosevX+1)
542+  8669              ;;		ld		b,a
543+  8669              ;;		ld		a,(UBnkrotmatRoofvY+1)
544+  8669              ;;		push	bc
545+  8669              ;;		call	TidySub1						; set A (-nosev_z * roofv_y + nosev_y * roofv_z) / 96, This also sets Q = nosev_z
546+  8669              ;;		pop		bc
547+  8669              ;;		xor		$80
548+  8669              ;;		ld		(UBnkrotmatSidevZ+1),a
549+  8669              ;;		xor		a							; set a = 0 so we can clear orientation low bytes
550+  8669              ;;		ld		hl,UBnkrotmatSidevZ
551+  8669              ;;		ld		b,9							; only on 6 cells (3 x row 0 and row 1)
552+  8669              ;;		ld		hl,UBnkrotmatNosevX
553+  8669
554+  8669
555+  8669
556+  8669
557+  8669
558+  8669
559+  8669              ;;;;;;;;;-- Check to see if the top two magnitude bits are clear in nosev_x, if so jump to TI1
560+  8669              ;;;;;;;;.ProcessRoofv:
561+  8669              ;;;;;;;;		call	CopyRotMatRoofVtoXX15		; xx15 = roofv
562+  8669              ;;;;;;;;		push	bc
563+  8669              ;;;;;;;;		call	normaliseXX1596fast			; normalise roof
564+  8669              ;;;;;;;;		pop		bc
565+  8669              ;;;;;;;;		call	CopyXX15toRotMatRoofV		; get back normalised version
566+  8669              ;;;;;;;;.ProcessSidev:
567+  8669              ;;;;;;;;		call	CopyRotMatSideVtoXX15		; xx15 = roofv
568+  8669              ;;;;;;;;		push	bc
569+  8669              ;;;;;;;;		call	normaliseXX1596fast			; normalise roof
570+  8669              ;;;;;;;;		pop		bc
571+  8669              ;;;;;;;;		call	CopyXX15toRotMatSideV		; get back normalised version
572+  8669
# file closed: ../Maths/Utilities/tidy.asm
 96   8669                  include "../Maths/asm_divide.asm"
# file opened: ../Maths/asm_divide.asm
  1+  8669
  2+  8669
  3+  8669
  4+  8669              ;
  5+  8669              ;   Set flags E to 11111110
  6+  8669              ;   Loop:   A << 2
  7+  8669              ;           if carry was 0
  8+  8669              ;               if a >= D
  9+  8669              ;                   A = A - D
 10+  8669              ;                   clear carry (probably irrelevant really)
 11+  8669              ;           else
 12+  8669
 13+  8669              ;               sla flags << bringing in carry of 1
 14+  8669              ;               if bit 7 of flag was set then loop
 15+  8669              ;                                        elase a = e and exit
 16+  8669              ;
 17+  8669              ; ">BC_Div_DE: BC = BC / DE. HL = remainder fast divide with unrolled loop BC/DE ==> BC, remainder in HL
 18+  8669              ;
 19+  8669              ;INPUTS: hl = dividend dbc = divisor
 20+  8669              ;OUTPUTS: hl/de -> AHL = quotient CDE = remainder, Carryflag set if divide by 0
 21+  8669
 22+  8669 57           DVIDT:                  ld      d,a                     ; D = var P+1
 23+  866A 3A A2 80                             ld      a,(varQ)
 24+  866D 4F                                   ld      c,a                     ; C = var Q
 25+  866E 3A A0 80                             ld      a,(varP)
 26+  8671 5F                                   ld      e,a                     ; E = var P
 27+  8672                                      ; Need fast exists on ABS values
 28+  8672 7A           BAequDEdivC:            ld      a,d                     ; Fast exit is value is 0
 29+  8673 B3                                   or      e                       ; .
 30+  8674 28 2A                                jr      z,.ResultIsZero         ; .
 31+  8676 79                                   ld      a,c                     ; Fast exit is divide by 0
 32+  8677 A7                                   and     a                       ;
 33+  8678 28 29                                jr      z,.ResultIsFFFF         ;
 34+  867A 7A           .SavSign:               ld      a,d                     ; preserve sign of result in var T
 35+  867B A9                                   xor     c                       ;
 36+  867C E6 80                                and     $80
 37+  867E 6F                                   ld      l,a                     ; l = var T
 38+  867F 3E 00                                ld      a,0
 39+  8681 06 10                                ld      b,16
 40+  8683                                      ShiftDELeft1
 40+  8683 CB 23       >			   sla e
 40+  8685 CB 12       >			   rl  d
 41+  8687 CB 21                                sla     c                       ; c = abs c
 42+  8689 CB 39                                srl     c
 43+  868B CB 17        .DivideLoop:            rl      a
 44+  868D                                      JumpIfALTNusng c, .SkipSubtract
 44+  868D B9          >                        cp      c
 44+  868E DA 94 86    >                        jp		c, .SkipSubtract
 45+  8691                                      ClearCarryFlag
 45+  8691 B7          >                        or a
 46+  8692 99                                   sbc     c
 47+  8693                                      ClearCarryFlag
 47+  8693 B7          >                        or a
 48+  8694 3F           .SkipSubtract:          ccf
 49+  8695 CB 13                                rl      e
 50+  8697 CB 12                                rl      d
 51+  8699 05                                   dec     b
 52+  869A 20 EF                                jr      nz,.DivideLoop
 53+  869C 7B                                   ld      a,e
 54+  869D B5                                   or      l
 55+  869E 42                                   ld      b,d
 56+  869F C9                                   ret
 57+  86A0              .ResultIsZero:          ZeroA
 57+  86A0 AF          >                        xor a
 58+  86A1 47                                   ld      b,a
 59+  86A2 C9                                   ret
 60+  86A3 3E FF        .ResultIsFFFF:          ld      a,$FF
 61+  86A5 47                                   ld      b,a
 62+  86A6 C9                                   ret
 63+  86A7
 64+  86A7 57           DIV96:                  ld      d,a                     ; D = var P+1
 65+  86A8 3A A2 80                             ld      a,(varQ)
 66+  86AB 0E 60                                ld      c,96                    ; C = var Q
 67+  86AD 3A A0 80                             ld      a,(varP)
 68+  86B0 5F                                   ld      e,a                     ; E = var P
 69+  86B1                                      ; Need fast exists on ABS values
 70+  86B1 7A           BAequDEdiv96            ld      a,d                     ; Fast exit is value is 0
 71+  86B2 B3                                   or      e                       ; .
 72+  86B3 28 26                                jr      z,.ResultIsZero         ; .
 73+  86B5 7A           .SavSign:               ld      a,d                     ; preserve sign of result in var T
 74+  86B6 A9                                   xor     c                       ;
 75+  86B7 E6 80                                and     $80
 76+  86B9 6F                                   ld      l,a                     ; l = var T
 77+  86BA 3E 00                                ld      a,0
 78+  86BC 06 10                                ld      b,16
 79+  86BE                                      ShiftDELeft1
 79+  86BE CB 23       >			   sla e
 79+  86C0 CB 12       >			   rl  d
 80+  86C2 CB 21                                sla     c                       ; c = abs c
 81+  86C4 CB 39                                srl     c
 82+  86C6 CB 17        .DivideLoop:            rl      a
 83+  86C8                                      JumpIfALTNusng c, .SkipSubtract
 83+  86C8 B9          >                        cp      c
 83+  86C9 DA CF 86    >                        jp		c, .SkipSubtract
 84+  86CC                                      ClearCarryFlag
 84+  86CC B7          >                        or a
 85+  86CD 99                                   sbc     c
 86+  86CE                                      ClearCarryFlag
 86+  86CE B7          >                        or a
 87+  86CF 3F           .SkipSubtract:          ccf
 88+  86D0 CB 13                                rl      e
 89+  86D2 CB 12                                rl      d
 90+  86D4 05                                   dec     b
 91+  86D5 20 EF                                jr      nz,.DivideLoop
 92+  86D7 7B                                   ld      a,e
 93+  86D8 B5                                   or      l
 94+  86D9 42                                   ld      b,d
 95+  86DA C9                                   ret
 96+  86DB              .ResultIsZero:          ZeroA
 96+  86DB AF          >                        xor a
 97+  86DC 47                                   ld      b,a
 98+  86DD C9                                   ret
 99+  86DE
100+  86DE 14           Div16by24usgn:          inc     d                           ; can we fast retu
101+  86DF 15                                   dec     d
102+  86E0 20 13                                jr      nz,.ResultZero
103+  86E2 50 59                                ld      de,bc                       ; so prep for bc/de
104+  86E4 44 4D                                ld      bc,hl
105+  86E6 7A           .div16by16usng:         ld      a,d
106+  86E7 B3                                   or      e
107+  86E8 28 10                                jr      z,.DivideByZero
108+  86EA 14                                   inc     d
109+  86EB 15                                   dec     d
110+  86EC CD 97 88                             call    BC_Div_DE
111+  86EF                                      ZeroA
111+  86EF AF          >                        xor a
112+  86F0 EB                                   ex      de,hl                       ; de = remainder (need to fix c after hl = nothing of worth)
113+  86F1 60 69                                ld      hl,bc                       ; hl = result (a is zero from above)
114+  86F3 4F                                   ld      c,a                         ; now fix c
115+  86F4 C9                                   ret
116+  86F5 AF           .ResultZero:            xor     a                           ; set AHL to 0 as d was 0 so h is zero
117+  86F6 4F                                   ld      c,a                         ; c = 0
118+  86F7 67                                   ld      h,a
119+  86F8 6F                                   ld      l,a
120+  86F9 C9                                   ret
121+  86FA 3E FF        .DivideByZero:          ld      a,$FF
122+  86FC 67                                   ld      h,a
123+  86FD 6F                                   ld      l,a
124+  86FE                                      SetCarryFlag
124+  86FE 37          >                        scf
125+  86FF C9                                   ret
126+  8700
127+  8700              ;DIVD4 P-R=A/Qunsg  \P.R = A/Q unsigned called by Hall
128+  8700 06 08        HLEquAmul256DivD:       ld		b,8							; counter
129+  8702 CB 27                                sla		a							;
130+  8704 67                                   ld		h,a							; r a * 2 we will build result in hl
131+  8705 CB 17        .DivideLoop:            rl		a							; a = a * 2
132+  8707 38 03                                jr      c,.StraightToSubtraction    ; jump on carry to subtraction
133+  8709 BA                                   cp      d                           ; what was var Q
134+  870A 38 03                                jr		c,.SkipSubtraction	        ; if a < d skip subtraction, note this will come to skip subtraction with carry the wrong way round
135+  870C              .StraightToSubtraction: ClearCarryFlag                      ; in 6502 the borrow flag is inverted carry, z80 just uses carry so we need to clear it
135+  870C B7          >                        or a
136+  870D 9A                                   sbc     a,d                         ; a = a - q
137+  870E                                      ClearCarryFlag                      ; set carry so it gets shifted into bit 0 of b. we do this as we have to flip carry due to jr c from earlier cp d
137+  870E B7          >                        or a
138+  870F 3F           .SkipSubtraction:       ccf                                 ; we need to do this as 6502 does opposite on carry, i.e. if we jumped direct here then carry would be set in z80
139+  8710 CB 14                                rl      h                           ; roll d left bringing in carry if there was an sbc performed
140+  8712 10 F1                                djnz    .DivideLoop                 ; 8 cycles
141+  8714 BA           .CalculateRemainder:    cp      d                           ; calulate 256 * a / d if q >= q then answer will not fit in one byte d is still set, a holds remainder to be subtracted
142+  8715 30 19                                jr      nc, .RemainderTooBig
143+  8717                                      ClearCarryFlag                      ; remove carry as the previous cp will have set it and mess up the sla in the remainder loop
143+  8717 B7          >                        or a
144+  8718 06 FE        .InitRemainderLoop:     ld      b,%11111110                 ; loop for bits 1 to 7
145+  871A 68                                   ld      l,b                         ; and set l to capture result bits (R)
146+  871B CB 27        .RemainderLoop:         sla     a                           ; shift a left
147+  871D 38 0A                                jr      c, .RemainderSubtraction    ; if there was a carry go to subtraction
148+  871F BA                                   cp      d                           ; if a < d then skip subtraction
149+  8720 38 01                                jr      c,.RemainderSkipSubtract    ; .
150+  8722 9A                                   sbc     d                           ; a > q so a = a - q, carry will be clear here
151+  8723 3F           .RemainderSkipSubtract: ccf                                 ; as the jr used z80 we need to flip the carry to behave like 6502
152+  8724 CB 15                                rl      l                           ; rotate counter to the left
153+  8726 38 F3                                jr      c, .RemainderLoop           ; if there was a bit pushed to carry then loop
154+  8728 C9                                   ret
155+  8729 9A           .RemainderSubtraction:  sbc     d                           ; as the carry came from an sla we want to retain it
156+  872A                                      SetCarryFlag                        ; roll in a carry bit to result
156+  872A 37          >                        scf
157+  872B CB 15                                rl      l                           ;
158+  872D 38 EC                                jr      c, .RemainderLoop           ; and loop if there was a carry bit that came out
159+  872F C9                                   ret
160+  8730 2E FF        .RemainderTooBig:       ld      l,$FF                       ; now hl = result
161+  8732 C9                                   ret
162+  8733
163+  8733 BA           AEquAmul256DivD:        cp      d
164+  8734 28 1D                                jr      z,.BothSame
165+  8736 30 1E                                jr      nc,.DgtA
166+  8738 1E FE                                ld      e,%11111110                 ; Set R to have bits 1-7 set, so we can rotate through 7
167+  873A CB 27        .DivideLoop:            sla     a
168+  873C 38 0D                                jr      c,.LL29
169+  873E                                      JumpIfALTNusng  d, .SkipSub         ; will jump if carry set, so we need to reset on the rol
169+  873E BA          >                        cp      d
169+  873F DA 44 87    >                        jp		c, .SkipSub
170+  8742 92                                   sub     d
171+  8743                                      ClearCarryFlag                      ; reset clarry as it will be complimented for rotate as 6502 does carry flags inverted
171+  8743 B7          >                        or a
172+  8744              .SkipSub:               FlipCarryFlag                       ; if we did the subtract the carry will be clear so we need to invert to roll in.
172+  8744 3F          >                        ccf
173+  8745 CB 13                                rl      e
174+  8747 38 F1                                jr      c,.DivideLoop
175+  8749 7B                                   ld      a,e
176+  874A C9                                   ret
177+  874B 92           .LL29:                  sub     d                           ; A >= Q, so set A = A - Q
178+  874C                                      SetCarryFlag                        ; Set the C flag to rotate into the result in R
178+  874C 37          >                        scf
179+  874D CB 13                                rl      e                           ; rotate counter e left
180+  874F 38 E9                                jr      c,.DivideLoop               ; if a bit was spat off teh end then loop
181+  8751 7B                                   ld      a,e                         ; stick result in a
182+  8752 C9                                   ret
183+  8753 3E 01        .BothSame:              ld  a,1
184+  8755 C9                                   ret
185+  8756 3E FF        .DgtA:                  ld  a,255                           ; Fail with FF as result
186+  8758 C9                                   ret
187+  8759
188+  8759
189+  8759              ; Divide 8-bit values
190+  8759              ; In: Divide E by divider C
191+  8759              ; Out: A = result, B = rest
192+  8759              ;
193+  8759              ;;;Div8:
194+  8759              ;;;    xor a
195+  8759              ;;;    ld b,8
196+  8759              ;;;Div8_Loop:
197+  8759              ;;;    rl e
198+  8759              ;;;    rla
199+  8759              ;;;    sub c
200+  8759              ;;;    jr nc,Div8_NoAdd
201+  8759              ;;;    add a,c
202+  8759              ;;;Div8_NoAdd:
203+  8759              ;;;    djnz Div8_Loop
204+  8759              ;;;    ld b,a0
205+  8759              ;;;    ld a,e
206+  8759              ;;;    rla
207+  8759              ;;;    cpl
208+  8759              ;;;    ret
209+  8759
210+  8759              ;;Inputs: DE is the numerator, BC is the divisor
211+  8759              ;;Outputs: DE is the result
212+  8759              ;;         A is a copy of E
213+  8759              ;;         HL is the remainder
214+  8759              ;;         BC is not changed
215+  8759              ;; so DE = DE /BC
216+  8759              ;140 bytes
217+  8759              ;145cc
218+  8759
219+  8759              MacroDEDivBC:       MACRO
220+  8759 ~                                rla
221+  8759 ~                                adc     hl,hl
222+  8759 ~                                sbc     hl,bc
223+  8759 ~                                jr      nc,$+3
224+  8759 ~                                add     hl,bc
225+  8759                                  ENDM
226+  8759
227+  8759              DEequDEDivBC:
228+  8759 AF               xor a
229+  875A ED 62            sbc hl,hl
230+  875C 7A               ld a,d
231+  875D                  MacroDEDivBC
231+  875D 17          >                    rla
231+  875E ED 6A       >                    adc     hl,hl
231+  8760 ED 42       >                    sbc     hl,bc
231+  8762 30 01       >                    jr      nc,$+3
231+  8764 09          >                    add     hl,bc
232+  8765                  MacroDEDivBC
232+  8765 17          >                    rla
232+  8766 ED 6A       >                    adc     hl,hl
232+  8768 ED 42       >                    sbc     hl,bc
232+  876A 30 01       >                    jr      nc,$+3
232+  876C 09          >                    add     hl,bc
233+  876D                  MacroDEDivBC
233+  876D 17          >                    rla
233+  876E ED 6A       >                    adc     hl,hl
233+  8770 ED 42       >                    sbc     hl,bc
233+  8772 30 01       >                    jr      nc,$+3
233+  8774 09          >                    add     hl,bc
234+  8775                  MacroDEDivBC
234+  8775 17          >                    rla
234+  8776 ED 6A       >                    adc     hl,hl
234+  8778 ED 42       >                    sbc     hl,bc
234+  877A 30 01       >                    jr      nc,$+3
234+  877C 09          >                    add     hl,bc
235+  877D                  MacroDEDivBC
235+  877D 17          >                    rla
235+  877E ED 6A       >                    adc     hl,hl
235+  8780 ED 42       >                    sbc     hl,bc
235+  8782 30 01       >                    jr      nc,$+3
235+  8784 09          >                    add     hl,bc
236+  8785                  MacroDEDivBC
236+  8785 17          >                    rla
236+  8786 ED 6A       >                    adc     hl,hl
236+  8788 ED 42       >                    sbc     hl,bc
236+  878A 30 01       >                    jr      nc,$+3
236+  878C 09          >                    add     hl,bc
237+  878D                  MacroDEDivBC
237+  878D 17          >                    rla
237+  878E ED 6A       >                    adc     hl,hl
237+  8790 ED 42       >                    sbc     hl,bc
237+  8792 30 01       >                    jr      nc,$+3
237+  8794 09          >                    add     hl,bc
238+  8795                  MacroDEDivBC
238+  8795 17          >                    rla
238+  8796 ED 6A       >                    adc     hl,hl
238+  8798 ED 42       >                    sbc     hl,bc
238+  879A 30 01       >                    jr      nc,$+3
238+  879C 09          >                    add     hl,bc
239+  879D 17               rla
240+  879E 2F               cpl
241+  879F 57               ld d,a
242+  87A0
243+  87A0 7B               ld a,e
244+  87A1                  MacroDEDivBC
244+  87A1 17          >                    rla
244+  87A2 ED 6A       >                    adc     hl,hl
244+  87A4 ED 42       >                    sbc     hl,bc
244+  87A6 30 01       >                    jr      nc,$+3
244+  87A8 09          >                    add     hl,bc
245+  87A9                  MacroDEDivBC
245+  87A9 17          >                    rla
245+  87AA ED 6A       >                    adc     hl,hl
245+  87AC ED 42       >                    sbc     hl,bc
245+  87AE 30 01       >                    jr      nc,$+3
245+  87B0 09          >                    add     hl,bc
246+  87B1                  MacroDEDivBC
246+  87B1 17          >                    rla
246+  87B2 ED 6A       >                    adc     hl,hl
246+  87B4 ED 42       >                    sbc     hl,bc
246+  87B6 30 01       >                    jr      nc,$+3
246+  87B8 09          >                    add     hl,bc
247+  87B9                  MacroDEDivBC
247+  87B9 17          >                    rla
247+  87BA ED 6A       >                    adc     hl,hl
247+  87BC ED 42       >                    sbc     hl,bc
247+  87BE 30 01       >                    jr      nc,$+3
247+  87C0 09          >                    add     hl,bc
248+  87C1                  MacroDEDivBC
248+  87C1 17          >                    rla
248+  87C2 ED 6A       >                    adc     hl,hl
248+  87C4 ED 42       >                    sbc     hl,bc
248+  87C6 30 01       >                    jr      nc,$+3
248+  87C8 09          >                    add     hl,bc
249+  87C9                  MacroDEDivBC
249+  87C9 17          >                    rla
249+  87CA ED 6A       >                    adc     hl,hl
249+  87CC ED 42       >                    sbc     hl,bc
249+  87CE 30 01       >                    jr      nc,$+3
249+  87D0 09          >                    add     hl,bc
250+  87D1                  MacroDEDivBC
250+  87D1 17          >                    rla
250+  87D2 ED 6A       >                    adc     hl,hl
250+  87D4 ED 42       >                    sbc     hl,bc
250+  87D6 30 01       >                    jr      nc,$+3
250+  87D8 09          >                    add     hl,bc
251+  87D9                  MacroDEDivBC
251+  87D9 17          >                    rla
251+  87DA ED 6A       >                    adc     hl,hl
251+  87DC ED 42       >                    sbc     hl,bc
251+  87DE 30 01       >                    jr      nc,$+3
251+  87E0 09          >                    add     hl,bc
252+  87E1 17               rla
253+  87E2 2F               cpl
254+  87E3 5F               ld e,a
255+  87E4 C9               ret
256+  87E5
257+  87E5
258+  87E5
259+  87E5              ;divdide by 16 using undocumented instrunctions
260+  87E5              ;Input: BC = Dividend, DE = Divisor, HL = 0
261+  87E5              ;Output: BC = Quotient, HL = Remainder
262+  87E5              ; Our use
263+  87E5              ; BC = A0
264+  87E5              ; DE = 0C
265+  87E5              ; so BC = a * 256 / C
266+  87E5              DIV16Amul256dCUNDOC:    JumpIfAGTENusng	  c,DEV16ATooLarge                                          ; first off if a > c ten return 255
266+  87E5 B9          >                        cp     c
266+  87E6 D2 11 88    >                        jp		nc,DEV16ATooLarge
267+  87E9 47                                   ld      b,a
268+  87EA 59                                   ld      e,c
269+  87EB 0E 00                                ld      c,0
270+  87ED 16 00                                ld      d,0
271+  87EF C3 FC 87                             jp      DIV16UNDOC
272+  87F2 47           DIV16Amul256dQUNDOC:    ld      b,a
273+  87F3 0E 00                                ld      c,0
274+  87F5 21 A2 80                             ld      hl,varQ
275+  87F8 7E                                   ld      a,(hl)
276+  87F9 16 00                                ld      d,0
277+  87FB 5F                                   ld      e,a
278+  87FC              DIV16BCDivDEUNDOC:
279+  87FC 21 00 00     DIV16UNDOC:             ld      hl,0
280+  87FF 78                                   ld      a,b
281+  8800 06 10                                ld      b,16
282+  8802 CB 31        DIV16UNDOCLOOP:         sll	c		; unroll 16 times
283+  8804 17                                   rla			; ...
284+  8805 ED 6A                                adc	hl,hl		; ...
285+  8807 ED 52                                sbc	hl,de		; ...
286+  8809 30 02                                jr	nc,DIV16UNDOCSKIP		; ...
287+  880B 19                                   add	hl,de		; ...
288+  880C 0D                                   dec	c		; ...
289+  880D 10 F3        DIV16UNDOCSKIP:         djnz DIV16UNDOCLOOP
290+  880F 47                                   ld   b,a
291+  8810 C9                                   ret
292+  8811 01 FF 00     DEV16ATooLarge:         ld     bc,$00FF
293+  8814 C9                                   ret
294+  8815              ; switch to logarithm version
295+  8815              ; "> asm_div8 C_Div_D - C is the numerator, D is the denominator, A is the remainder, B is 0, C is the result of C/D,D,E,H,L are not changed"
296+  8815 06 08        asm_div8:               ld b,8
297+  8817 AF                                   xor a
298+  8818 CB 21        .div8_loop:	            sla c
299+  881A 17                                   rla
300+  881B BA                                   cp d
301+  881C 38 02                                jr c,.div8_skip
301+  881E
302+  881E 0C                                   inc c
303+  881F 92                                   sub d
304+  8820 10 F6        .div8_skip:	            djnz .div8_loop
305+  8822 C9                                   ret
306+  8823              ; ">asm_div16: HL_Div_C: HL is the numerator,  C is the denominator, output A is the remainder, B is 0, C,DE is not changedHL is the quotient"
307+  8823 06 10        asm_div16:              ld b,16
308+  8825 AF                                   xor a
309+  8826 CB 25        div16_loop:	            sla l
310+  8828 CB 14                                rl	h
311+  882A              ;    add hl,hl
312+  882A 17                                   rla
313+  882B B9                                   cp c
314+  882C 38 02                                jr c,div16_skip
315+  882E 2C                                   inc l
316+  882F 91                                   sub c
317+  8830 10 F4        div16_skip:		        djnz div16_loop
318+  8832 C9                                   ret
319+  8833              ;
320+  8833              ; Divide 16-bit values (with 16-bit result)
321+  8833              ; In: Divide BC by divider DE
322+  8833              ; Out: BC = result, HL = rest
323+  8833              ;
324+  8833              HLDivC_Iteration: 	MACRO
325+  8833 ~            					add	hl,hl		; unroll 16 times
326+  8833 ~            					rla				; ...
327+  8833 ~            					cp	c			; ...
328+  8833 ~            					jr	1F
329+  8833 ~            					sub	c			; ...
330+  8833 ~            1:
331+  8833 ~            					inc	l			; ...
332+  8833              					ENDM
333+  8833
334+  8833
335+  8833              ; 06 06 2022 Not used
336+  8833              ; ">div1616: BC = BC / DE. HL = remainder"
337+  8833 21 00 00     Div1616:            ld hl,0
338+  8836 78                               ld a,b
339+  8837 06 08                            ld b,8
340+  8839 17           .Div16_Loop1:       rla
341+  883A ED 6A                            adc hl,hl
342+  883C ED 52                            sbc hl,de
343+  883E 30 01                            jr nc,.Div16_NoAdd1
344+  8840 19                               add hl,de
345+  8841 10 F6        .Div16_NoAdd1:      djnz .Div16_Loop1
346+  8843 17                               rla
347+  8844 2F                               cpl
348+  8845 47                               ld b,a
349+  8846 79                               ld a,c
350+  8847 48                               ld c,b
351+  8848 06 08                            ld b,8
352+  884A 17           .Div16_Loop2:       rla
353+  884B ED 6A                            adc hl,hl
354+  884D ED 52                            sbc hl,de
355+  884F 30 01                            jr nc,.Div16_NoAdd2
356+  8851 19                               add hl,de
357+  8852 10 F6        .Div16_NoAdd2:      djnz .Div16_Loop2
358+  8854 17                               rla
359+  8855 2F                               cpl
360+  8856 41                               ld b,c
361+  8857 4F                               ld c,a
362+  8858 C9                               ret
363+  8859
364+  8859
365+  8859              EDivC_Iteration:        MACRO
366+  8859 ~                                    rl  e
367+  8859 ~                                    rla
368+  8859 ~                                    sub c
369+  8859 ~                                    jr  nc,.Div8_NoAdd
370+  8859 ~                                    add a,c
371+  8859 ~            .Div8_NoAdd:
372+  8859                                      ENDM
373+  8859
374+  8859              ; Switch to a logarithm version
375+  8859              ; Divide E by divider C Out: A = result, B = rest
376+  8859              E_Div_C:                ZeroA
376+  8859 AF          >                        xor a
377+  885A                                      EDivC_Iteration
377+  885A CB 13       >                        rl  e
377+  885C 17          >                        rla
377+  885D 91          >                        sub c
377+  885E 30 01       >                        jr  nc,.Div8_NoAdd
377+  8860 81          >                        add a,c
377+  8861             >.Div8_NoAdd:
378+  8861                                      EDivC_Iteration
378+  8861 CB 13       >                        rl  e
378+  8863 17          >                        rla
378+  8864 91          >                        sub c
378+  8865 30 01       >                        jr  nc,.Div8_NoAdd
378+  8867 81          >                        add a,c
378+  8868             >.Div8_NoAdd:
379+  8868                                      EDivC_Iteration
379+  8868 CB 13       >                        rl  e
379+  886A 17          >                        rla
379+  886B 91          >                        sub c
379+  886C 30 01       >                        jr  nc,.Div8_NoAdd
379+  886E 81          >                        add a,c
379+  886F             >.Div8_NoAdd:
380+  886F                                      EDivC_Iteration
380+  886F CB 13       >                        rl  e
380+  8871 17          >                        rla
380+  8872 91          >                        sub c
380+  8873 30 01       >                        jr  nc,.Div8_NoAdd
380+  8875 81          >                        add a,c
380+  8876             >.Div8_NoAdd:
381+  8876                                      EDivC_Iteration
381+  8876 CB 13       >                        rl  e
381+  8878 17          >                        rla
381+  8879 91          >                        sub c
381+  887A 30 01       >                        jr  nc,.Div8_NoAdd
381+  887C 81          >                        add a,c
381+  887D             >.Div8_NoAdd:
382+  887D                                      EDivC_Iteration
382+  887D CB 13       >                        rl  e
382+  887F 17          >                        rla
382+  8880 91          >                        sub c
382+  8881 30 01       >                        jr  nc,.Div8_NoAdd
382+  8883 81          >                        add a,c
382+  8884             >.Div8_NoAdd:
383+  8884                                      EDivC_Iteration
383+  8884 CB 13       >                        rl  e
383+  8886 17          >                        rla
383+  8887 91          >                        sub c
383+  8888 30 01       >                        jr  nc,.Div8_NoAdd
383+  888A 81          >                        add a,c
383+  888B             >.Div8_NoAdd:
384+  888B                                      EDivC_Iteration
384+  888B CB 13       >                        rl  e
384+  888D 17          >                        rla
384+  888E 91          >                        sub c
384+  888F 30 01       >                        jr  nc,.Div8_NoAdd
384+  8891 81          >                        add a,c
384+  8892             >.Div8_NoAdd:
385+  8892 47                                   ld      b,a
386+  8893 7B                                   ld      a,e
387+  8894 17                                   rla
388+  8895 2F                                   cpl
389+  8896 C9                                   ret
390+  8897
391+  8897
392+  8897              BCDIVDE_Iteration:      MACRO
393+  8897 ~                                    rla
394+  8897 ~                                    adc	    hl,hl
395+  8897 ~                                    add	    hl,de
396+  8897 ~                                    jr	    c,1F
397+  8897 ~                                    sbc	    hl,de
398+  8897 ~            1:
399+  8897                                      ENDM
400+  8897
401+  8897
402+  8897              ; ">BC_Div_DE: BC = BC / DE. HL = remainder fast divide with unrolled loop"
403+  8897              ;BC/DE ==> BC, remainder in HL
404+  8897              ;NOTE: BC/0 returns 0 as the quotient.
405+  8897              ;min: 738cc
406+  8897              ;max: 898cc
407+  8897              ;avg: 818cc
408+  8897              ;144 bytes
409+  8897 AF           BC_Div_DE:              xor a
410+  8898 67                                   ld h,a
411+  8899 6F                                   ld l,a
412+  889A 93                                   sub e
413+  889B 5F                                   ld e,a
414+  889C 9F                                   sbc a,a
415+  889D 92                                   sub d
416+  889E 57                                   ld d,a
417+  889F 78                                   ld a,b
418+  88A0                                      BCDIVDE_Iteration
418+  88A0 17          >                        rla
418+  88A1 ED 6A       >                        adc	    hl,hl
418+  88A3 19          >                        add	    hl,de
418+  88A4 38 02       >                        jr	    c,1F
418+  88A6 ED 52       >                        sbc	    hl,de
418+  88A8             >1:
419+  88A8                                      BCDIVDE_Iteration
419+  88A8 17          >                        rla
419+  88A9 ED 6A       >                        adc	    hl,hl
419+  88AB 19          >                        add	    hl,de
419+  88AC 38 02       >                        jr	    c,1F
419+  88AE ED 52       >                        sbc	    hl,de
419+  88B0             >1:
420+  88B0                                      BCDIVDE_Iteration
420+  88B0 17          >                        rla
420+  88B1 ED 6A       >                        adc	    hl,hl
420+  88B3 19          >                        add	    hl,de
420+  88B4 38 02       >                        jr	    c,1F
420+  88B6 ED 52       >                        sbc	    hl,de
420+  88B8             >1:
421+  88B8                                      BCDIVDE_Iteration
421+  88B8 17          >                        rla
421+  88B9 ED 6A       >                        adc	    hl,hl
421+  88BB 19          >                        add	    hl,de
421+  88BC 38 02       >                        jr	    c,1F
421+  88BE ED 52       >                        sbc	    hl,de
421+  88C0             >1:
422+  88C0                                      BCDIVDE_Iteration
422+  88C0 17          >                        rla
422+  88C1 ED 6A       >                        adc	    hl,hl
422+  88C3 19          >                        add	    hl,de
422+  88C4 38 02       >                        jr	    c,1F
422+  88C6 ED 52       >                        sbc	    hl,de
422+  88C8             >1:
423+  88C8                                      BCDIVDE_Iteration
423+  88C8 17          >                        rla
423+  88C9 ED 6A       >                        adc	    hl,hl
423+  88CB 19          >                        add	    hl,de
423+  88CC 38 02       >                        jr	    c,1F
423+  88CE ED 52       >                        sbc	    hl,de
423+  88D0             >1:
424+  88D0                                      BCDIVDE_Iteration
424+  88D0 17          >                        rla
424+  88D1 ED 6A       >                        adc	    hl,hl
424+  88D3 19          >                        add	    hl,de
424+  88D4 38 02       >                        jr	    c,1F
424+  88D6 ED 52       >                        sbc	    hl,de
424+  88D8             >1:
425+  88D8                                      BCDIVDE_Iteration
425+  88D8 17          >                        rla
425+  88D9 ED 6A       >                        adc	    hl,hl
425+  88DB 19          >                        add	    hl,de
425+  88DC 38 02       >                        jr	    c,1F
425+  88DE ED 52       >                        sbc	    hl,de
425+  88E0             >1:
426+  88E0 17                                   rla
427+  88E1 47                                   ld b,a
428+  88E2
429+  88E2 79                                   ld a,c
430+  88E3                                      BCDIVDE_Iteration
430+  88E3 17          >                        rla
430+  88E4 ED 6A       >                        adc	    hl,hl
430+  88E6 19          >                        add	    hl,de
430+  88E7 38 02       >                        jr	    c,1F
430+  88E9 ED 52       >                        sbc	    hl,de
430+  88EB             >1:
431+  88EB                                      BCDIVDE_Iteration
431+  88EB 17          >                        rla
431+  88EC ED 6A       >                        adc	    hl,hl
431+  88EE 19          >                        add	    hl,de
431+  88EF 38 02       >                        jr	    c,1F
431+  88F1 ED 52       >                        sbc	    hl,de
431+  88F3             >1:
432+  88F3                                      BCDIVDE_Iteration
432+  88F3 17          >                        rla
432+  88F4 ED 6A       >                        adc	    hl,hl
432+  88F6 19          >                        add	    hl,de
432+  88F7 38 02       >                        jr	    c,1F
432+  88F9 ED 52       >                        sbc	    hl,de
432+  88FB             >1:
433+  88FB                                      BCDIVDE_Iteration
433+  88FB 17          >                        rla
433+  88FC ED 6A       >                        adc	    hl,hl
433+  88FE 19          >                        add	    hl,de
433+  88FF 38 02       >                        jr	    c,1F
433+  8901 ED 52       >                        sbc	    hl,de
433+  8903             >1:
434+  8903                                      BCDIVDE_Iteration
434+  8903 17          >                        rla
434+  8904 ED 6A       >                        adc	    hl,hl
434+  8906 19          >                        add	    hl,de
434+  8907 38 02       >                        jr	    c,1F
434+  8909 ED 52       >                        sbc	    hl,de
434+  890B             >1:
435+  890B                                      BCDIVDE_Iteration
435+  890B 17          >                        rla
435+  890C ED 6A       >                        adc	    hl,hl
435+  890E 19          >                        add	    hl,de
435+  890F 38 02       >                        jr	    c,1F
435+  8911 ED 52       >                        sbc	    hl,de
435+  8913             >1:
436+  8913                                      BCDIVDE_Iteration
436+  8913 17          >                        rla
436+  8914 ED 6A       >                        adc	    hl,hl
436+  8916 19          >                        add	    hl,de
436+  8917 38 02       >                        jr	    c,1F
436+  8919 ED 52       >                        sbc	    hl,de
436+  891B             >1:
437+  891B                                      BCDIVDE_Iteration
437+  891B 17          >                        rla
437+  891C ED 6A       >                        adc	    hl,hl
437+  891E 19          >                        add	    hl,de
437+  891F 38 02       >                        jr	    c,1F
437+  8921 ED 52       >                        sbc	    hl,de
437+  8923             >1:
438+  8923 17                                   rla
439+  8924 4F                                   ld c,a
440+  8925 C9                                   ret
441+  8926
442+  8926              ; 06 06 2022 not used
443+  8926              ;Inputs:
444+  8926              ;     DE,BC are 8.8 Fixed Point numbers
445+  8926              ;Outputs:
446+  8926              ;     DE is the 8.8 Fixed Point result (rounded to the least significant bit)
447+  8926              ;if DE is 0 : 122cc or 136cc if BC is negative
448+  8926              ;if |BC|>=128*|DE| : 152cc or 166cc if BC is negative
449+  8926              ;Otherwise:
450+  8926              ;min: 1107cc
451+  8926              ;max: 1319cc
452+  8926              ;avg: 1201cc
453+  8926 78           BC_Div_DE_88:           ld a,b  ; First, find out if the output is positive or negative
454+  8927 AA                                   xor d
455+  8928 F5                                   push af   ;sign bit is the result sign bit
456+  8929              ; Now make sure the inputs are positive
457+  8929 A8                                   xor b     ;A now has the value of B, since I XORed it with D twice (cancelling)
458+  892A F2 33 89                             jp p,BC_Div_DE_88_lbl1   ;if Positive, don't negate
459+  892D AF                                   xor a
460+  892E 91                                   sub c
461+  892F 4F                                   ld c,a
462+  8930 9F                                   sbc a,a
463+  8931 90                                   sub b
464+  8932 47                                   ld b,a
465+  8933 7A           BC_Div_DE_88_lbl1:      ld a,d  ;now make DE negative to optimize the remainder comparison
466+  8934 B2                                   or d
467+  8935 FA 3E 89                             jp m,BC_Div_DE_88_lbl2
468+  8938 AF                                   xor a
469+  8939 93                                   sub e
470+  893A 5F                                   ld e,a
471+  893B 9F                                   sbc a,a
472+  893C 92                                   sub d
473+  893D 57                                   ld d,a
474+  893E B3           BC_Div_DE_88_lbl2:      or e      ;if DE is 0, we can call it an overflow ;A is the current value of D
475+  893F 28 1D                                jr z,div_fixed88_overflow
476+  8941 26 00                                ld h,0          ;The accumulator gets set to B if no overflow.;We can use H=0 to save a few cc in the meantime
477+  8943 78                                   ld a,b;if B+DE>=0, then we'll have overflow
478+  8944 83                                   add a,e
479+  8945 7A                                   ld a,d
480+  8946 8C                                   adc a,h
481+  8947 38 15                                jr c,div_fixed88_overflow
482+  8949 68                                   ld l,b  ;Now we can load the accumulator/remainder with B;H is already 0
483+  894A 79                                   ld a,c
484+  894B CD 66 89                             call div_fixed88_sub
485+  894E 4F                                   ld c,a
486+  894F 78                                   ld a,b      ;A is now 0
487+  8950 CD 66 89                             call div_fixed88_sub
488+  8953 51                                   ld d,c
489+  8954 5F                                   ld e,a
490+  8955 F1                                   pop af
491+  8956 F0                                   ret p
492+  8957 AF                                   xor a
493+  8958 93                                   sub e
494+  8959 5F                                   ld e,a
495+  895A 9F                                   sbc a,a
496+  895B 92                                   sub d
497+  895C 57                                   ld d,a
498+  895D C9                                   ret
499+  895E
500+  895E 11 FF 7F     div_fixed88_overflow:   ld de,$7FFF
501+  8961 F1                                   pop af
502+  8962 F0                                   ret p
503+  8963 13                                   inc de
504+  8964 1C                                   inc e
505+  8965 C9                                   ret
506+  8966
507+  8966              ;min: 456cc
508+  8966              ;max: 536cc
509+  8966              ;avg: 496cc
510+  8966 06 08        div_fixed88_sub:        ld b,8
511+  8968 17           BC_Div_DE_88_lbl3:      rla
512+  8969 ED 6A                                adc hl,hl
513+  896B 19                                   add hl,de
514+  896C 38 02                                jr c,$+4
515+  896E ED 52                                sbc hl,de
516+  8970 10 F6                                djnz BC_Div_DE_88_lbl3
517+  8972 8F                                   adc a,a
518+  8973 C9                                   ret
519+  8974
# file closed: ../Maths/asm_divide.asm
 97   8974                  include "../Maths/multiply.asm"
# file opened: ../Maths/multiply.asm
  1+  8974              HLequSRmulQdiv256:      ;X.Y=x1lo.S*M/256  	\ where M/256 is gradient
  2+  8974 2A A3 80                             ld  hl,(varRS)
  3+  8977 3A A2 80                             ld  a,(varQ)
  4+  897A C5 D5        HLeqyHLmulAdiv256:      push    bc,,de
  5+  897C 11 00 00                             ld  de,0        ; de = XY
  6+  897F 47                                   ld  b,a         ; b = Q
  7+  8980                                      ShiftHLRight1
  7+  8980 CB 3C       >			   srl h
  7+  8982 CB 1D       >			   rr  l
  8+  8984 CB 20                                sla b
  9+  8986 30 03                                jr  nc,.LL126
 10+  8988 EB           .LL125:                 ex de,hl
 11+  8989 19                                   add hl,de
 12+  898A EB                                   ex  de,hl       ; de = de + rs
 13+  898B              .LL126:                 ShiftHLRight1
 13+  898B CB 3C       >			   srl h
 13+  898D CB 1D       >			   rr  l
 14+  898F CB 20                                sla b
 15+  8991 38 F5                                jr      c,.LL125
 16+  8993 20 F6                                jr      nz,.LL126
 17+  8995 EB                                   ex      de,hl   ; hl = result
 18+  8996 D1 C1                                pop     bc,,de
 19+  8998 C9                                   ret
 20+  8999
 21+  8999
 22+  8999              MacroDEEquQmulASigned:  MACRO
 23+  8999 ~                                    ld      d,a                         ; save a into d
 24+  8999 ~                                    ld      a,(varQ)
 25+  8999 ~                                    ld      e,a
 26+  8999 ~                                    xor     d                           ; a = a xor var Q
 27+  8999 ~                                    and     SignOnly8Bit
 28+  8999 ~                                    ld      b,a                         ; b = sign of a xor q
 29+  8999 ~                                    ld      a,d                         ; d = abs d (or a reg)
 30+  8999 ~                                    and     SignMask8Bit
 31+  8999 ~                                    ld      d,a
 32+  8999 ~                                    ld      a,e                         ; e = abs e (or varQ)
 33+  8999 ~                                    and     SignMask8Bit
 34+  8999 ~                                    ld      e,a
 35+  8999 ~                                    mul                                 ; de = a * Q
 36+  8999 ~                                    ld      a,d
 37+  8999 ~                                    or      b                           ; de = a * Q leading sign bit
 38+  8999 ~                                    ld      d,a
 39+  8999                                      ENDM
 40+  8999
 41+  8999
 42+  8999
 43+  8999                                 ; .MAD	\ -> &22AD  \ Multiply and Add  (DE also) X.A(Lo.Hi) = Q*A + R.S (Lo.Hi)
 44+  8999              madXAequQmulAaddRS:     MacroDEEquQmulASigned
 44+  8999 57          >                        ld      d,a                         ; save a into d
 44+  899A 3A A2 80    >                        ld      a,(varQ)
 44+  899D 5F          >                        ld      e,a
 44+  899E AA          >                        xor     d                           ; a = a xor var Q
 44+  899F E6 80       >                        and     SignOnly8Bit
 44+  89A1 47          >                        ld      b,a                         ; b = sign of a xor q
 44+  89A2 7A          >                        ld      a,d                         ; d = abs d (or a reg)
 44+  89A3 E6 7F       >                        and     SignMask8Bit
 44+  89A5 57          >                        ld      d,a
 44+  89A6 7B          >                        ld      a,e                         ; e = abs e (or varQ)
 44+  89A7 E6 7F       >                        and     SignMask8Bit
 44+  89A9 5F          >                        ld      e,a
 44+  89AA ED 30       >                        mul                                 ; de = a * Q
 44+  89AC 7A          >                        ld      a,d
 44+  89AD B0          >                        or      b                           ; de = a * Q leading sign bit
 44+  89AE 57          >                        ld      d,a
 45+  89AF 2A A3 80                             ld		hl,(varR)
 46+  89B2 CD DA 89                             call	madXAAddHLDESigned
 47+  89B5 EB                                   ex      de,hl                       ; de = R.S + DE
 48+  89B6                                      ClearCarryFlag
 48+  89B6 B7          >                        or a
 49+  89B7 DD 6B                                ld      ixl,e
 50+  89B9 7A                                   ld      a,d
 51+  89BA C9                                   ret
 52+  89BB
 53+  89BB              madDEequQmulAaddRS:     MacroDEEquQmulASigned
 53+  89BB 57          >                        ld      d,a                         ; save a into d
 53+  89BC 3A A2 80    >                        ld      a,(varQ)
 53+  89BF 5F          >                        ld      e,a
 53+  89C0 AA          >                        xor     d                           ; a = a xor var Q
 53+  89C1 E6 80       >                        and     SignOnly8Bit
 53+  89C3 47          >                        ld      b,a                         ; b = sign of a xor q
 53+  89C4 7A          >                        ld      a,d                         ; d = abs d (or a reg)
 53+  89C5 E6 7F       >                        and     SignMask8Bit
 53+  89C7 57          >                        ld      d,a
 53+  89C8 7B          >                        ld      a,e                         ; e = abs e (or varQ)
 53+  89C9 E6 7F       >                        and     SignMask8Bit
 53+  89CB 5F          >                        ld      e,a
 53+  89CC ED 30       >                        mul                                 ; de = a * Q
 53+  89CE 7A          >                        ld      a,d
 53+  89CF B0          >                        or      b                           ; de = a * Q leading sign bit
 53+  89D0 57          >                        ld      d,a
 54+  89D1 2A A3 80                             ld		hl,(varR)
 55+  89D4 CD DA 89                             call	madXAAddHLDESigned
 56+  89D7 EB                                   ex      de,hl                       ; de = R.S + DE
 57+  89D8                                      ClearCarryFlag
 57+  89D8 B7          >                        or a
 58+  89D9 C9                                   ret
 59+  89DA
 60+  89DA 7C           madXAAddHLDESigned:     ld      a,h
 61+  89DB E6 80                                and     SignOnly8Bit
 62+  89DD 47                                   ld      b,a                         ;save sign bit in b
 63+  89DE AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
 64+  89DF                                      JumpIfNegative .ADDHLDEOppSGN        ;Signs are opposite there fore we can subtract to get difference
 64+  89DF FA F7 89    >                        jp		m, .ADDHLDEOppSGN
 65+  89E2 78           .ADDHLDESameSigns:       ld      a,b
 66+  89E3 B2                                   or      d
 67+  89E4                                      JumpIfNegative .ADDHLDESameNeg       ; optimisation so we can just do simple add if both positive
 67+  89E4 FA E9 89    >                        jp		m, .ADDHLDESameNeg
 68+  89E7 19                                   add     hl,de
 69+  89E8 C9                                   ret
 70+  89E9 7C           .ADDHLDESameNeg:         ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 71+  89EA E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 72+  89EC 67                                   ld      h,a
 73+  89ED 7A                                   ld      a,d
 74+  89EE E6 7F                                and     SignMask8Bit
 75+  89F0 57                                   ld      d,a
 76+  89F1 19                                   add     hl,de
 77+  89F2 3E 80                                ld      a,SignOnly8Bit
 78+  89F4 B4                                   or      h                           ; now set bit for negative value, we won't bother with overflow for now TODO
 79+  89F5 67                                   ld      h,a
 80+  89F6 C9                                   ret
 81+  89F7 7C           .ADDHLDEOppSGN:          ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit                     ; here HL and DE are opposite
 82+  89F8 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 83+  89FA 67                                   ld      h,a
 84+  89FB 7A                                   ld      a,d
 85+  89FC E6 7F                                and     SignMask8Bit
 86+  89FE 57                                   ld      d,a
 87+  89FF B7                                   or      a
 88+  8A00 ED 52                                sbc     hl,de
 89+  8A02 38 04                                jr      c,.ADDHLDEOppInvert
 90+  8A04 78           .ADDHLDEOppSGNNoCarry:   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
 91+  8A05 B4                                   or      h
 92+  8A06 67                                   ld      h,a                         ; set the previou sign value
 93+  8A07 C9                                   ret
 94+  8A08              .ADDHLDEOppInvert:       NegHL                                                   ; we need to flip the sign and 2'c the Hl result
 94+  8A08 AF          >                    xor a
 94+  8A09 95          >                    sub l
 94+  8A0A 6F          >                    ld l,a
 94+  8A0B 9F          >                    sbc a,a
 94+  8A0C 94          >                    sub h
 94+  8A0D 67          >                    ld h,a
 95+  8A0E 78                                   ld      a,b
 96+  8A0F EE 80                                xor     SignOnly8Bit                ; flip sign bit
 97+  8A11 B4                                   or      h
 98+  8A12 67                                   ld      h,a                         ; recover sign
 99+  8A13 C9                                   ret
100+  8A14
101+  8A14
102+  8A14                  ; multiplication of 16-bit number and 8-bit number into a 24-bit product
103+  8A14                  ;
104+  8A14                  ; enter : hl = 16-bit multiplier   = x
105+  8A14                  ;          e =  8-bit multiplicand = y
106+  8A14                  ;
107+  8A14                  ; exit  : ahl = 24-bit product
108+  8A14                  ;         carry reset
109+  8A14                  ;
110+  8A14                  ; uses  : af, de, hl
111+  8A14 54           AHLequHLmulE:           ld d,h                      ; xh
112+  8A15 63                                   ld h,e                      ; yl
113+  8A16 ED 30                                mul de                      ; xh*yl
114+  8A18 EB                                   ex de,hl
115+  8A19 ED 30                                mul de                      ; yl*xl, hl = xh*yl
116+  8A1B
117+  8A1B 7A                                   ld  a,d                     ; sum products
118+  8A1C 85                                   add a,l
119+  8A1D 57                                   ld  d,a
120+  8A1E EB                                   ex de,hl
121+  8A1F
122+  8A1F 7A                                   ld  a,d
123+  8A20 CE 00                                adc a,0
124+  8A22 C9                                   ret
125+  8A23
126+  8A23 54           HLE0quH0mulE:           ld      d,h                 ; .
127+  8A24 63                                   ld      h,e                 ; .
128+  8A25 ED 30                                mul     de                  ; de = xh * yl
129+  8A27 EB                                   ex      de,hl
130+  8A28 C9                                   ret
131+  8A29
132+  8A29                 ; multiplication of two 16-bit numbers into a 32-bit product
133+  8A29                 ;
134+  8A29                 ; enter : de = 16-bit multiplicand = y
135+  8A29                 ;         hl = 16-bit multiplicand = x
136+  8A29                 ;
137+  8A29                 ; exit  : dehl = 32-bit product
138+  8A29                 ;         carry reset
139+  8A29                 ;
140+  8A29                 ; uses  : af, bc, de, hl
141+  8A29
142+  8A29
143+  8A29
144+  8A29 45           DEHLequDEmulHL:         ld b,l                      ; x0
145+  8A2A 4B                                   ld c,e                      ; y0
146+  8A2B 5D                                   ld e,l                      ; x0
147+  8A2C 6A                                   ld l,d
148+  8A2D E5                                   push hl                     ; x1 y1
149+  8A2E 69                                   ld l,c                      ; y0
150+  8A2F              ; bc = x0 y0, de = y1 x0,  hl = x1 y0,  stack = x1 y1
151+  8A2F ED 30                                mul de                      ; y1*x0
152+  8A31 EB                                   ex de,hl
153+  8A32 ED 30                                mul de                      ; x1*y0
154+  8A34
155+  8A34 AF                                   xor a                       ; zero A
156+  8A35 19                                   add hl,de                   ; sum cross products p2 p1
157+  8A36 8F                                   adc a,a                     ; capture carry p3
158+  8A37
159+  8A37 59                                   ld e,c                      ; x0
160+  8A38 50                                   ld d,b                      ; y0
161+  8A39 ED 30                                mul de                      ; y0*x0
162+  8A3B
163+  8A3B 47                                   ld b,a                      ; carry from cross products
164+  8A3C 4C                                   ld c,h                      ; LSB of MSW from cross products
165+  8A3D
166+  8A3D 7A                                   ld a,d
167+  8A3E 85                                   add a,l
168+  8A3F 67                                   ld h,a
169+  8A40 6B                                   ld l,e                      ; LSW in HL p1 p0
170+  8A41
171+  8A41 D1                                   pop de
172+  8A42 ED 30                                mul de                      ; x1*y1
173+  8A44
174+  8A44 EB                                   ex de,hl
175+  8A45 ED 4A                                adc hl,bc
176+  8A47 EB                                   ex de,hl                    ; de = final MSW
177+  8A48
178+  8A48 C9                                   ret
179+  8A49
180+  8A49              ; multiplication of two 16-bit numbers into a 16-bit product
181+  8A49              ; enter : de = 16-bit multiplicand
182+  8A49              ;         hl = 16-bit multiplicand
183+  8A49              ; exit  : hl = 16-bit product
184+  8A49              ;         carry reset
185+  8A49              ; maths is
186+  8A49              ;        hl = y , de= x
187+  8A49              ;        hl = xhi,ylo + (yhigh * xlow)
188+  8A49              ;        hl = yhih & xlo + x
189+  8A49              ;
190+  8A49              ;
191+  8A49              ; uses  : af, bc, de, hl
192+  8A49 C5           mulDEbyHL:              push    bc
193+  8A4A 7A                                   ld a,d                      ; a = xh
194+  8A4B 54                                   ld d,h                      ; d = yh
195+  8A4C 67                                   ld h,a                      ; h = xh
196+  8A4D 4B                                   ld c,e                      ; c = xl
197+  8A4E 45                                   ld b,l                      ; b = yl
198+  8A4F ED 30                                mul                         ; yh * yl
199+  8A51 EB                                   ex de,hl
200+  8A52 ED 30                                mul                         ; xh * yl
201+  8A54 19                                   add hl,de                   ; add cross products
202+  8A55 59                                   ld e,c
203+  8A56 50                                   ld d,b
204+  8A57 ED 30                                mul                         ; yl * xl
205+  8A59 7D                                   ld a,l                      ; cross products lsb
206+  8A5A 82                                   add a,d                     ; add to msb final
207+  8A5B 67                                   ld h,a
208+  8A5C 6B                                   ld l,e                      ; hl = final
209+  8A5D                                      ; 83 cycles, 19 bytes
210+  8A5D AF                                   xor a                       ; reset carry
211+  8A5E C1                                   pop     bc
212+  8A5F C9                                   ret
213+  8A60
214+  8A60
215+  8A60              ; CHL = multiplicand D = multiplier
216+  8A60              ; DCHL = CHL * D
217+  8A60 7A           mulCHLbyDSigned:        ld      a,d                 ; get sign from d
218+  8A61 AC                                   xor     h                   ; xor with h to get resultant sign
219+  8A62 E6 80                                and     SignOnly8Bit        ; .
220+  8A64 FD 67                                ld      iyh,a               ; iyh = copy of sign
221+  8A66 79                                   ld      a,c                 ; now CHL = ABS (CHL)
222+  8A67 E6 7F                                and     SignMask8Bit        ; .
223+  8A69 4F                                   ld      c,a                 ; .
224+  8A6A 7A                                   ld      a,d                 ; d = ABS D
225+  8A6B E6 7F                                and     SignMask8Bit        ; .
226+  8A6D              ; At this point CHL = ABS (HLE), A = ABS(D)
227+  8A6D 57           .mul1:                  ld      d,a                 ; first do D * L
228+  8A6E 5D                                   ld      e,l                 ; .
229+  8A6F ED 30                                mul     de                  ; DE = L * D
230+  8A71 08                                   ex      af,af'              ; save multiplier
231+  8A72 6B                                   ld      l,e                 ; L = p0
232+  8A73 7A                                   ld      a,d                 ; carry byte
233+  8A74 08                                   ex      af,af'              ; retrieve muliplier and save carry byte along with flags
234+  8A75 5C           .mul2:                  ld      e,h                 ; byte 2 of multiplicand
235+  8A76 57                                   ld      d,a                 ; and multiplier
236+  8A77 ED 30                                mul     de                  ; now its D & L
237+  8A79 08                                   ex      af,af'              ; get back carry byte with flags
238+  8A7A 83           .carrybyte1:            add     a,e                 ; add low byte carry to result and retain carry too through next instructions
239+  8A7B 67                                   ld      h,a                 ; h = P1
240+  8A7C 7A                                   ld      a,d                 ; a = carry byte
241+  8A7D 08                                   ex      af,af'              ; save carry byte and get back multiplier with flags
242+  8A7E 59           .mul3:                  ld      e,c                 ; byte 3 of multiplicand
243+  8A7F 57                                   ld      d,a                 ;
244+  8A80 ED 30                                mul     de                  ;
245+  8A82 08                                   ex      af,af'              ; get back carry byte and carry prior to first add
246+  8A83 8B                                   adc     a,e                 ;
247+  8A84 FD B4                                or      iyh                 ; recover saved resultant sign
248+  8A86 4F                                   ld      c,a                 ; c byte 3. Note the value range allowed can never cause a byte 3 carry
249+  8A87 C9                                   ret
250+  8A88
251+  8A88              ;  CHL = 53456 D = 1E
252+  8A88              ;  56 * 1E = A14 L = 14 carry = 0A
253+  8A88              ;  34 * 1E = 618 H = 18 +A = 22 carry = 6
254+  8A88              ;  5  * 1E = 096 C = 96 + 6 = 9C
255+  8A88              ;  CHL = 9C2214
256+  8A88              ;mult3
257+  8A88              ; DELC = HLE * D, uses HL, DE, C , A , IYH
258+  8A88              ; HLE = multiplicand D = multiplier
259+  8A88              ; tested by mathstestsun.asm all passed
260+  8A88              ; Algorithm
261+  8A88              ; AC =  E * D   (save carry)         H    L    E
262+  8A88              ; DE =  L * D                                  D
263+  8A88              ;  L =  A + E + carry                         E*D (lo)
264+  8A88              ; DE =  H * D                             L*D+ ^ (hi)
265+  8A88              ;  E =  A + E + carry                H*D (lo) + carry
266+  8A88              ;
267+  8A88              ;
268+  8A88 7A           mulHLEbyDSigned:        ld      a,d                 ; get sign from d
269+  8A89 AC                                   xor     h                   ; xor with h to get resultant sign
270+  8A8A E6 80                                and     SignOnly8Bit        ; .
271+  8A8C FD 67                                ld      iyh,a               ; iyh = copy of sign
272+  8A8E 7C                                   ld      a,h                 ; now HLE = ABS (HLE)
273+  8A8F E6 7F                                and     SignMask8Bit        ; .
274+  8A91 67                                   ld      h,a                 ; .
275+  8A92 7A                                   ld      a,d                 ; d = ABS D
276+  8A93 E6 7F                                and     SignMask8Bit        ; .
277+  8A95 57                                   ld      d,a                 ; .
278+  8A96 B7           .testEitherSideZero:    or      a
279+  8A97 28 24                                jr      z,.ResultZero
280+  8A99 7C                                   ld      a,h
281+  8A9A B5                                   or      l
282+  8A9B B3                                   or      e
283+  8A9C 28 1F                                jr      z,.ResultZero
284+  8A9E              ; At this point HLE = ABS (HLE), A = ABS(D)
285+  8A9E 42                                   ld      b,d                 ; save Quotient
286+  8A9F ED 30        .mul1:                  mul     de                  ; C = E * D
287+  8AA1 4B                                   ld      c,e                 ; C = p0
288+  8AA2 FD 6A                                ld      iyl,d               ; save carry (p1)
289+  8AA4 5D           .mul2:                  ld      e,l                 ; L = L * D
290+  8AA5 50                                   ld      d,b                 ; .
291+  8AA6 ED 30                                mul     de                  ; .
292+  8AA8 FD 7D                                ld      a,iyl               ; get back p1
293+  8AAA 83           .carrybyte1:            add     a,e                 ; L = L + E
294+  8AAB 6F                                   ld      l,a                 ; .
295+  8AAC FD 6A                                ld      iyl,d               ; save new carry byte
296+  8AAE 5C           .mul3:                  ld      e,h                 ; E = H * D
297+  8AAF 50                                   ld      d,b                 ; .
298+  8AB0 ED 30                                mul     de                  ; .
299+  8AB2 FD 7D                                ld      a,iyl
300+  8AB4 8B                                   adc     a,e                 ; .
301+  8AB5 5F                                   ld      e,a                 ; .
302+  8AB6 7A           .ItsNotZero:            ld      a,d                 ;
303+  8AB7 CE 00                                adc     a,0                 ; final carry bit
304+  8AB9 FD B4                                or      iyh                 ; bring back sign
305+  8ABB 57                                   ld      d,a                 ; s = sign
306+  8ABC C9                                   ret
307+  8ABD 11 00 00     .ResultZero:            ld      de,0
308+  8AC0                                      ZeroA
308+  8AC0 AF          >                        xor a
309+  8AC1 4F                                   ld      c,a
310+  8AC2 6F                                   ld      l,a
311+  8AC3 C9                                   ret
312+  8AC4
313+  8AC4              ;;;
314+  8AC4              ;;;
315+  8AC4              ;;;mulHLEbyDSigned:        ld      a,d                 ; get sign from d
316+  8AC4              ;;;                        xor     h                   ; xor with h to get resultant sign
317+  8AC4              ;;;                        and     SignOnly8Bit        ; .
318+  8AC4              ;;;                        ld      iyh,a               ; iyh = copy of sign
319+  8AC4              ;;;                        ld      a,h                 ; now HLE = ABS (HLE)
320+  8AC4              ;;;                        and     SignMask8Bit        ; .
321+  8AC4              ;;;                        ld      h,a                 ; .
322+  8AC4              ;;;                        ld      a,d                 ; d = ABS D
323+  8AC4              ;;;                        and     SignMask8Bit        ; .
324+  8AC4              ;;;                        ld      d,a                 ; .
325+  8AC4              ;;;.testEitherSideZero:    or      a
326+  8AC4              ;;;                        jr      z,.ResultZero
327+  8AC4              ;;;                        ld      a,h
328+  8AC4              ;;;                        or      l
329+  8AC4              ;;;                        or      e
330+  8AC4              ;;;                        jr      z,.ResultZero
331+  8AC4              ;;;; At this point HLE = ABS (HLE), A = ABS(D)
332+  8AC4              ;;;.mul1:                  mul     de                  ; C = E * D
333+  8AC4              ;;;                        ex      af,af'              ; save mulitplier
334+  8AC4              ;;;                        ld      c,e                 ; C = p0
335+  8AC4              ;;;                        ld      a,d                 ; save carry (p1)
336+  8AC4              ;;;                        ex      af,af'              ; .
337+  8AC4              ;;;.mul2:                  ld      e,l                 ; L = L * D
338+  8AC4              ;;;                        ld      d,a                 ; .
339+  8AC4              ;;;                        mul     de                  ; .
340+  8AC4              ;;;                        ex      af,af'              ; .
341+  8AC4              ;;;.carrybyte1:            add     a,e                 ; L = L + E
342+  8AC4              ;;;                        ld      l,a                 ; .
343+  8AC4              ;;;                        ld      a,d
344+  8AC4              ;;;                        ex      af,af'              ; save new carry byte
345+  8AC4              ;;;.mul3:                  ld      e,h                 ; E = H * D
346+  8AC4              ;;;                        ld      d,a                 ; .
347+  8AC4              ;;;                        mul     de                  ; .
348+  8AC4              ;;;                        ex      af,af'              ; .
349+  8AC4              ;;;                        adc     a,e                 ; .
350+  8AC4              ;;;                        ld      e,a                 ; .
351+  8AC4              ;;;.ItsNotZero:            ld      a,d                 ;
352+  8AC4              ;;;                        adc     a,0                 ; final carry bit
353+  8AC4              ;;;                        or      iyh                 ; bring back sign
354+  8AC4              ;;;                        ld      d,a                 ; s = sign
355+  8AC4              ;;;                        ret
356+  8AC4              ;;;.ResultZero:            ld      de,0
357+  8AC4              ;;;                        ZeroA
358+  8AC4              ;;;                        ld      c,a
359+  8AC4              ;;;                        ld      l,a
360+  8AC4              ;;;                        ret
361+  8AC4
362+  8AC4              ; multiplication of two S156-bit numbers into a 16-bit 2'd compliment product
363+  8AC4              ; enter : de = 16-bit multiplicand
364+  8AC4              ;         hl = 16-bit multiplicand
365+  8AC4              ; exit  : hl = 16-bit product
366+  8AC4              ;         carry reset
367+  8AC4              ;
368+  8AC4              ; uses  : af, bc, de, hl
369+  8AC4 00           mulDEbyHLSignByte       DB      0
370+  8AC5 AF           mulDEbyHLSgnTo2c:       xor     a
371+  8AC6 32 C4 8A                             ld      (mulDEbyHLSignByte),a
372+  8AC9 7A           .SignDE:                ld      a,d
373+  8ACA ED 27 80                             test    $80
374+  8ACD 28 08                                jr      z,.SignHL
375+  8ACF E6 7F        .NegativeDE:            and     $7F
376+  8AD1 57                                   ld      d,a
377+  8AD2 3E 80                                ld      a,$80
378+  8AD4 32 C4 8A                             ld      (mulDEbyHLSignByte),a
379+  8AD7 7C           .SignHL:                ld      a,h
380+  8AD8 ED 27 80                             test    $80
381+  8ADB 28 0B                                jr      z,.AbsoluteMultiply
382+  8ADD E6 7F        .NegativeHL:            and     $7F
383+  8ADF 67                                   ld      h,a
384+  8AE0 3A C4 8A                             ld      a,(mulDEbyHLSignByte)
385+  8AE3 EE 80                                xor     $80
386+  8AE5 32 C4 8A                             ld      (mulDEbyHLSignByte),a
387+  8AE8 CD 49 8A     .AbsoluteMultiply:      call    mulDEbyHL
388+  8AEB 3A C4 8A     .RecoverSign:           ld      a,(mulDEbyHLSignByte)
389+  8AEE ED 27 80                             test    $80
390+  8AF1 C8                                   ret     z
391+  8AF2 AF           .Negateghl: 			xor 	a
392+  8AF3 95                                   sub 	l
393+  8AF4 6F                                   ld 		l,a
394+  8AF5 9F                                   sbc 	a,a
395+  8AF6 94                                   sub 	h
396+  8AF7 67                                   ld 		h,a
397+  8AF8 C9                                   ret
398+  8AF9
399+  8AF9 AF           mulDESgnbyHLUnsgnTo2c:  xor     a
400+  8AFA 32 C4 8A                             ld      (mulDEbyHLSignByte),a
401+  8AFD 7A           .SignDE:                ld      a,d
402+  8AFE ED 27 80                             test    $80
403+  8B01 28 08                                jr      z,.AbsoluteMultiply
404+  8B03 E6 7F        .NegativeDE:            and     $7F
405+  8B05 57                                   ld      d,a
406+  8B06 3E 80                                ld      a,$80
407+  8B08 32 C4 8A                             ld      (mulDEbyHLSignByte),a
408+  8B0B CD 49 8A     .AbsoluteMultiply:      call    mulDEbyHL
409+  8B0E 3A C4 8A     .RecoverSign:           ld      a,(mulDEbyHLSignByte)
410+  8B11 ED 27 80                             test    $80
411+  8B14 C8                                   ret     z
412+  8B15 AF           .Negateghl:             xor 	a
413+  8B16 95                                   sub 	l
414+  8B17 6F                                   ld 		l,a
415+  8B18 9F                                   sbc 	a,a
416+  8B19 94                                   sub 	h
417+  8B1A 67                                   ld 		h,a
418+  8B1B C9                                   ret
419+  8B1C
420+  8B1C
# file closed: ../Maths/multiply.asm
 98   8B1C
 99   8B1C                  SAVENEX OPEN "maths_test.nex", $8000 , $7F00
100   8B1C                  SAVENEX CFG  0,0,0,1
101   8B1C                  SAVENEX AUTO
102   8B1C                  SAVENEX CLOSE
103   8B1C
104   8B1C
105   8B1C              ;call    EAeqyDEdivC
106   8B1C              ;   break
107   8B1C              ;   ld      d,01
108   8B1C              ;   ld      e,56
109   8B1C              ;   ld      c,6
110   8B1C              ;    call    EAeqyDEdivC
111   8B1C              ;   break
112   8B1C              ;   ld      d,0
113   8B1C              ;   ld      e,0
114   8B1C              ;   ld      c,8
115   8B1C              ;    call    EAeqyDEdivC
116   8B1C              ;   break
117   8B1C              ;   ld      d,16
118   8B1C              ;   ld      e,16
119   8B1C              ;   ld      c,0
120   8B1C              ;    call    EAeqyDEdivC
121   8B1C              ;   break
122   8B1C              ;test1:
123   8B1C              ;	ld hl, 50
124   8B1C              ;	ld (varDustY),hl
125   8B1C              ;	ld hl,5
126   8B1C              ;	ld (varQ),hl
127   8B1C              ;	ld a,0
128   8B1C              ;	ld (varY),a
129   8B1C              ;	call asm_mlu1
130   8B1C              ;	ld a,0
131   8B1C              ;	call writeResult
132   8B1C              ;test2:
133   8B1C              ;    ld a,100
134   8B1C              ;	ld hl,varQ
135   8B1C              ;	ld (hl),a
136   8B1C              ;	ld a,3
137   8B1C              ;	call asm_mlu2
138   8B1C              ;	ld a,1
139   8B1C              ;	call writeResult
140   8B1C              ;test3:
141   8B1C              ;	ld a,9
142   8B1C              ;	call asm_squa
143   8B1C              ;	ld a,2
144   8B1C              ;	call writeResult ;; 8`
145   8B1C              ;test4:
146   8B1C              ;	ld de,$1EF1
147   8B1C              ;	call asm_sqrt
148   8B1C              ;	ex de,hl
149   8B1C              ;	ld a,3
150   8B1C              ;	call writeResult	;; 3
151   8B1C              ;test5:
152   8B1C              ;	ld hl, varQ
153   8B1C              ;	ld (hl),43
154   8B1C              ;	ld a, 43
155   8B1C              ;	call asm_tis2
156   8B1C              ;	ex de,hl
157   8B1C              ;	ld a,4
158   8B1C              ;	call writeResult ;; 96
159   8B1C              ;test6:
160   8B1C              ;	ld hl, varQ
161   8B1C              ;	ld (hl),22
162   8B1C              ;	ld a, 56
163   8B1C              ;	call asm_tis2 ;; hl = result
164   8B1C              ;	ex de,hl
165   8B1C              ;	ld a,5
166   8B1C              ;	call writeResult ;; 96
167   8B1C              ;test7:
168   8B1C              ;	ld hl, varQ
169   8B1C              ;	ld (hl),56
170   8B1C              ;	ld a, 22
171   8B1C              ;startLoop:
172   8B1C              ;	jp startLoop
173   8B1C              ;	call asm_tis2
174   8B1C              ;	ex de,hl
175   8B1C              ;	ld a,6
176   8B1C              ;	call writeResult;; 38
177   8B1C              ;test8:
178   8B1C              ;	ld hl, varQ
179   8B1C              ;	ld (hl),22
180   8B1C              ;	ld a, 11
181   8B1C              ;	call asm_tis2
182   8B1C              ;	ex de,hl
183   8B1C              ;	ld a,7
184   8B1C              ;	call writeResult	 ;; 48
185   8B1C              ;
# file closed: maths_test.asm
