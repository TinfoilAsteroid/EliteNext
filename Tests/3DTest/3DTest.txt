# file opened: 3DTest.asm
   1  0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
   2  0000                              DISPLAY "3D Test Code"
   3  0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
   4  0000
   5  0000                  DEVICE ZXSPECTRUMNEXT
   6  0000                  SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
   7  0000
   8  0000
   9  0000                  DEFINE  SHIP_DRAW_FULL_SCREEN 1
  10  0000               CSPECTMAP 3DTest.map
  11  0000               OPT --zxnext=cspect --syntax=a --reversepop
  12  0000              ;-- Key Definitions
  13  0000              ;   Q/A pitch       O/P roll        W/A Thrust
  14  0000              ;   T/G ship pitch, F/H ship roll   U/J Ship Thrust
  15  0000              ;   P   Cycle through ships
  16  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  17  0000              ; Game Defines
  18  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  19  0000              ; Colour Defines
  20  0000                                      INCLUDE "../../Hardware/L2ColourDefines.asm"
# file opened: ../../Hardware/L2ColourDefines.asm
   1+ 0000              L2ColourBLACK           EQU   0
   2+ 0000              L2ColourRED_1           EQU 224                 ; RGB 255,  0,  0
   3+ 0000              L2ColourRED_2           EQU 192                 ; RGB 218,  0,  0
   4+ 0000              L2ColourRED_3           EQU 160                 ; RGB 182,  0,  0
   5+ 0000              L2ColourRED_4           EQU 128                 ; RGB 145,  0,  0
   6+ 0000              L2ColourRED_5           EQU  96                 ; RGB 109,  0,  0
   7+ 0000              L2ColourRED_6           EQU  64                 ; RGB  72,  0,  0
   8+ 0000              L2ColourRED_7           EQU  32                 ; RGB  36,  0,  0
   9+ 0000              L2ColourYELLOW_1        EQU 252                 ; RGB 255,255,  0
  10+ 0000              L2ColourYELLOW_2        EQU 216                 ; RGB 218,218,  0
  11+ 0000              L2ColourYELLOW_3        EQU 180                 ; RGB 182,182,  0
  12+ 0000              L2ColourYELLOW_4        EQU 144                 ; RGB 145,145,  0
  13+ 0000              L2ColourYELLOW_5        EQU 108                 ; RGB 109.109,  0
  14+ 0000              L2ColourYELLOW_6        EQU  72                 ; RGB  72, 72,  0
  15+ 0000              L2ColourYELLOW_7        EQU  36                 ; RGB  36, 36,  0
  16+ 0000              L2ColourGREEN_1		    EQU  28                 ; RGB   0,255,  0
  17+ 0000              L2ColourGREEN_2		    EQU  24                 ; RGB   0,218,  0
  18+ 0000              L2ColourGREEN_3		    EQU  16                 ; RGB   0,145,  0
  19+ 0000              L2ColourGREEN_4         EQU  12                 ; RGB   0,109,  0
  20+ 0000              L2ColourGREEN_5         EQU   8                 ; RGB   0, 72,  0
  21+ 0000              L2ColourGREEN_6         EQU   4                 ; RGB   0, 36,  0
  22+ 0000              L2ColourBLUE_1          EQU   3                 ; RGB 0,0,255
  23+ 0000              L2ColourBLUE_2          EQU   2                 ; RGB 0,0,170
  24+ 0000              L2ColourBLUE_3          EQU   1                 ; RGB 0,0,85
  25+ 0000
  26+ 0000
  27+ 0000              L2ColourWHITE_1         EQU 255                 ; RGB 255,255,255
  28+ 0000              L2ColourWHITE_2         EQU 146
  29+ 0000              L2ColourGREY_1		    EQU L2ColourWHITE_2
  30+ 0000              L2ColourGREY_2		    EQU 109
  31+ 0000              L2ColourGREY_3		    EQU  73
  32+ 0000              L2ColourGREY_4		    EQU  37
  33+ 0000
  34+ 0000              L2ColourGREEN_MB        EQU  29                 ;RGB 0,255,85
  35+ 0000              L2ColourGREEN_MR        EQU 124                 ;RGB 109.255,0
  36+ 0000              L2ColourCREAM_1         EQU 218                 ; RGB 218,218,170
  37+ 0000              L2ColourCREAM_2         EQU 182                 ; RGB 182,182,170
  38+ 0000              L2ColourCREAM_3         EQU 146                 ; RGB 145,145,170
  39+ 0000
  40+ 0000              L2ColourTRANSPARENT     EQU 227                 ; RGB 255,  0,255
  41+ 0000              L2ColourMAGENTA_1       EQU 162                 ; RGB 182,  0,170
  42+ 0000              L2ColourMAGENTA_2       EQU 130                 ; RGB 145,  0,170
  43+ 0000              L2ColourMAGENTA_3       EQU  97                 ; RGB 109,  0, 85
  44+ 0000              L2ColourMAGENTA_4       EQU  65                 ; RGB  72,  0, 85
  45+ 0000              L2ColourORANGE_1        EQU 236                 ; RGB
  46+ 0000              L2ColourORANGE_2        EQU 168                 ; RGB
  47+ 0000              L2ColourORANGE_3        EQU  68                 ; RGB
  48+ 0000              L2ColourCYAN_1          EQU  31                 ; RGB   0,255, 255
  49+ 0000              L2ColourCYAN_2          EQU  18                 ; RGB
  50+ 0000              L2ColourCYAN_3          EQU   9                 ; RGB
  51+ 0000              L2ColourPURPLE_1        EQU 109                 ; RGB
  52+ 0000              L2ColourPURPLE_2        EQU  66                 ; RGB
  53+ 0000              L2ColourPURPLE_3        EQU  33                 ; RGB
  54+ 0000              L2ColourPINK_1		    EQU 231                 ; RGB
  55+ 0000              L2ColourPINK_2		    EQU 226                 ; RGB
  56+ 0000              L2ColourPINK_3		    EQU 225                 ; RGB
  57+ 0000              L2ColourPINK_4		    EQU 224                 ; RGB
  58+ 0000
# file closed: ../../Hardware/L2ColourDefines.asm
  21  0000                                      INCLUDE "../../Hardware/L1ColourDefines.asm"
# file opened: ../../Hardware/L1ColourDefines.asm
   1+ 0000
   2+ 0000              L1ColourInkBlack        EQU %00000000
   3+ 0000              L1ColourInkBlue         EQU %00000001
   4+ 0000              L1ColourInkRed          EQU %00000010
   5+ 0000              L1ColourInkMagenta      EQU %00000011
   6+ 0000              L1ColourInkGreen        EQU %00000100
   7+ 0000              L1ColourInkCyan         EQU %00000101
   8+ 0000              L1ColourInkYellow       EQU %00000110
   9+ 0000              L1ColourInkWhite        EQU %00000111
  10+ 0000              L1ColourPaperBlack      EQU %00000000
  11+ 0000              L1ColourPaperBlue       EQU %00001000
  12+ 0000              L1ColourPaperRed        EQU %00010000
  13+ 0000              L1ColourPaperMagenta    EQU %00011000
  14+ 0000              L1ColourPaperGreen      EQU %00100000
  15+ 0000              L1ColourPaperCyan       EQU %00101000
  16+ 0000              L1ColourPaperYellow     EQU %00110000
  17+ 0000              L1ColourPaperWhite      EQU %00111000
  18+ 0000              L1ColourFlash           EQU %10000000
  19+ 0000              L1ColourBright          EQU %01000000
  20+ 0000              ;----------------------------------------------------------------------------------------------------------------------------------
  21+ 0000              ; Screen Specific Colour Defines
  22+ 0000              L1InvHighlight          EQU L1ColourBright | L1ColourPaperRed   | L1ColourInkYellow
  23+ 0000              L1InvLowlight           EQU                  L1ColourPaperBlack | L1ColourInkWhite
# file closed: ../../Hardware/L1ColourDefines.asm
  22  0000                                      INCLUDE "../../Hardware/register_defines.asm"
# file opened: ../../Hardware/register_defines.asm
   1+ 0000              ; Peripheral 2
   2+ 0000              ENABLE_CPU_SPEED_MODE                   EQU %10000000
   3+ 0000              DIVERT_BEEP_ONLY                        EQU %01000000
   4+ 0000              ENABLE_50_60_SWITCH                     EQU %00100000
   5+ 0000              ENABLE_MMCAUTO_SWITCH                   EQU %00010000
   6+ 0000              ENABLE_MULTIFACE_M1                     EQU %00001000
   7+ 0000              PS2MODE_KEYBOARD                        EQU %00000000
   8+ 0000              PS2MODE_MOUSE                           EQU %00000100
   9+ 0000              AUDIO_CHIPMODE_YM                       EQU %00000000
  10+ 0000              AUDIO_CHIPMODE_AY                       EQU %00000001
  11+ 0000              AUDIO_CHIPMODE_DISABLED                 EQU %00000010
  12+ 0000              INTERNAL_SPEAKER_ENABLE                 EQU %00010000
  13+ 0000              ; Peripheral 3
  14+ 0000              UNLOCK_PORT_7FFD_PAGING                 EQU %10000000
  15+ 0000              DISABLE_RAM_IO_CONTENTION               EQU %01000000
  16+ 0000              AY_STEREO_MODE_ACB                      EQU %00100000
  17+ 0000              INTERNAL_SPEAKER                        EQU %00010000
  18+ 0000              ENABLE_DACS                             EQU %00001000
  19+ 0000              ENABLE_TIMEX_VIDEO_MODE                 EQU %00000100
  20+ 0000              ENABLE_TURBO_SOUND                      EQU %00000010
  21+ 0000              ENABLE_ISSUE2_KEYBOARD                  EQU %00000001
  22+ 0000              ; Peripheral 4
  23+ 0000              ENABLE_AY2_MONO                         EQU %10000000
  24+ 0000              ENABLE_AY1_MONO                         EQU %01000000
  25+ 0000              ENABLE_AY0_MONO                         EQU %00100000
  26+ 0000              SPRITE_ID_LOCKSTEP                      EQU %00010000
  27+ 0000              RESET_DIVMMC_MAPRAM                     EQU %00001000
  28+ 0000              SILENCE_HDMI_AUDIO                      EQU %00000100
  29+ 0000              SCALLINES_50PCT                         EQU %00000001
  30+ 0000              SCANLINES_25PCT                         EQU %00000010
  31+ 0000              SCANLINES_125PCT                        EQU %00000011
  32+ 0000              ; Audio Registers
  33+ 0000              CHANNEL_A_FINE                          EQU 0
  34+ 0000              CHANNEL_A_COARSE                        EQU 1
  35+ 0000              CHANNEL_B_FINE                          EQU 2
  36+ 0000              CHANNEL_B_COARSE                        EQU 3
  37+ 0000              CHANNEL_C_FINE                          EQU 4
  38+ 0000              CHANNEL_C_COARSE                        EQU 5
  39+ 0000              NOISE_PERIOD                            EQU 6
  40+ 0000              TONE_ENABLE                             EQU 7
  41+ 0000              CHANNEL_A_AMPLITUDE                     EQU 8
  42+ 0000              CHANNEL_B_AMPLITUDE                     EQU 9
  43+ 0000              CHANNEL_C_AMPLITUDE                     EQU 10
  44+ 0000              ENVELOPE_PERIOD_FINE                    EQU 11
  45+ 0000              ENVELOPE_PERIOD_COARSE                  EQU 12
  46+ 0000              ENVELOPE_SHAPE                          EQU 13
  47+ 0000
  48+ 0000              ENVELOPE_HOLD_ON                        EQU 1
  49+ 0000              ENVELOPE_ALTERNATE_ON                   EQU 2
  50+ 0000              ENVELOPE_ATTACK_ON                      EQU 4
  51+ 0000              ENVELOPE_CONTINUE_ON                    EQU 8
  52+ 0000
  53+ 0000              ENVELOPE_SHAPE_SINGLE_DECAY             EQU 0                                                                                    ; \____________
  54+ 0000              ENVELOPE_SHAPE_SINGLE_ATTACK            EQU                        ENVELOPE_ATTACK_ON                                            ; /|___________
  55+ 0000              ENVELOPE_SHAPE_REPEAT_DECAY             EQU ENVELOPE_CONTINUE_ON                                                                 ; \|\|\|\|\|\|\
  56+ 0000              ENVELOPE_SHAPE_REPEAT_DECAY_ATTACK      EQU ENVELOPE_CONTINUE_ON |                      ENVELOPE_ALTERNATE_ON                    ; \/\/\/\/\/\/\
  57+ 0000              ENVELOPE_SHAPE_SINGLE_DECAY_HOLD        EQU ENVELOPE_CONTINUE_ON |                      ENVELOPE_ALTERNATE_ON | ENVELOPE_HOLD_ON ; \|-----------
  58+ 0000              ENVELOPE_SHAPE_REPEAT_ATTACK            EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON                                            ; /|/|/|/|/|/|/|
  59+ 0000              ENVELOPE_SHAPE_SINGLE_ATTACK_HOLD       EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON |                         ENVELOPE_HOLD_ON ; /------------
  60+ 0000              ENVELOPE_SHAPE_REPEAT_ATTACK_DECAY      EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON | ENVELOPE_ALTERNATE_ON                    ; /\/\/\/\/\/\/
  61+ 0000
  62+ 0000              ENVELOPE_HOLD                           EQU %00000001
  63+ 0000              ENVELOPE_ALTERNATE                      EQU %00000010
  64+ 0000              ENVELOPE_ATTACK                         EQU %00000010
  65+ 0000              ENVELOPE_CONTINUE                       EQU %00000010
  66+ 0000              ; Sound Control
  67+ 0000              TONE_CHANNEL_A                          EQU %00000001
  68+ 0000              TONE_CHANNEL_B                          EQU %00000010
  69+ 0000              TONE_CHANNEL_C                          EQU %00000100
  70+ 0000              NOISE_CHANNEL_A                         EQU %00001000
  71+ 0000              NOISE_CHANNEL_B                         EQU %00010000
  72+ 0000              NOISE_CHANNEL_C                         EQU %00100000
  73+ 0000              ; Version for AND to enabled (its inverted)
  74+ 0000              TONE_CHANNEL_A_ON                       EQU %11111110
  75+ 0000              TONE_CHANNEL_B_ON                       EQU %11111101
  76+ 0000              TONE_CHANNEL_C_ON                       EQU %11111011
  77+ 0000              NOISE_CHANNEL_A_ON                      EQU %11110111
  78+ 0000              NOISE_CHANNEL_B_ON                      EQU %11101111
  79+ 0000              NOISE_CHANNEL_C_ON                      EQU %11011111
  80+ 0000
  81+ 0000              ; Turbo Sound Control
  82+ 0000              TURBO_MANDATORY                         EQU %10011100
  83+ 0000              TURBO_LEFT                              EQU %01000000
  84+ 0000              TURBO_RIGHT                             EQU %00100000
  85+ 0000              TURBO_CHIP_AY3                          EQU %00000011
  86+ 0000              TURBO_CHIP_AY2                          EQU %00000010
  87+ 0000              TURBO_CHIP_AY1                          EQU %00000001
  88+ 0000
  89+ 0000              IO_LAYER2_PORT                          EQU $123B
  90+ 0000              IO_EXT_BANK_PORT 			            EQU $DFFD ; 57341
  91+ 0000              IO_BANK_PORT                            EQU $7FFD ; 32765
  92+ 0000              REGISTER_NUMBER_PORT					EQU $243B
  93+ 0000              REGISTER_VALUE_PORT						EQU $253B
  94+ 0000              SPRITE_SLOT_PORT						EQU $303B ; port for sprite and pattern index
  95+ 0000              SPRITE_INFO_PORT                        EQU $0057
  96+ 0000              SPRITE_PATTERN_UPLOAD_PORT				EQU $005B
  97+ 0000              TURBO_SOUND_NEXT_CONTROL                EQU $FFFD
  98+ 0000              SOUND_CHIP_REGISTER_WRITE               EQU $BFFD
  99+ 0000              IO_KEYBOARD_PORT                        EQU $FE
 100+ 0000              IO_DATAGEAR_DMA_PORT 		            EQU $6B
 101+ 0000              UART_TX_PORT_PORT                       EQU $133B
 102+ 0000              UART_RX_PORT_PORT                       EQU $143B
 103+ 0000              UART_CONTROL_PORT                       EQU $153B
 104+ 0000              UART_FRAME_PORT                         EQU $163B
 105+ 0000              CTC_CHANNEL1_PORT                       EQU $183B
 106+ 0000              CTC_CHANNEL2_PORT                       EQU $193B
 107+ 0000              CTC_CHANNEL3_PORT                       EQU $1A3B
 108+ 0000              CTC_CHANNEL4_PORT                       EQU $1B3B
 109+ 0000              PLUS_3_MEMORY_PAGING_CONTROL_PORT       EQU $1FFD
 110+ 0000              MB02_DMA_PORT                           EQU $0B
 111+ 0000              SPECDRUM_DAC_OUTPUT                     EQU $DF
 112+ 0000
 113+ 0000              Speed_3_5MHZ                            EQU 0
 114+ 0000              Speed_7MHZ                              EQU 1
 115+ 0000              Speed_14MHZ                             EQU 2
 116+ 0000              Speed_28MHZ                             EQU 3
 117+ 0000
 118+ 0000
 119+ 0000              MACHINE_ID_REGISTER						EQU $00
 120+ 0000              VERSION_REGISTER						EQU $01
 121+ 0000              RESET_REGISTER		    				EQU $02
 122+ 0000              MACHINE_TYPE_REGISTER					EQU $03
 123+ 0000              PAGE_RAM_REGISTER						EQU $04
 124+ 0000              PERIPHERAL_1_REGISTER					EQU $05   ; Sets joystick mode, video frequency and Scandoubler
 125+ 0000              PERIPHERAL_2_REGISTER					EQU $06   ; Enables CPU Speed key, DivMMC, Multiface, Mouse and AY audio.
 126+ 0000              TURBO_MODE_REGISTER						EQU $07
 127+ 0000              PERIPHERAL_3_REGISTER					EQU $08   ; ABC/ACB Stereo, Internal Speaker, SpecDrum, Timex Video Modes, Turbo Sound Next, RAM contention and [un]lock 128k paging
 128+ 0000              PERIPHERAL_4_REGISTER                   EQU $09   ; Sets scanlines, AY mono output, Sprite-id lockstep, reset DivMMC mapram and disable HDMI audio
 129+ 0000              PERIPHERAL_5_REGISTER                   EQU $0A  ; Mouse
 130+ 0000              CORE_VERSION_REGISTER                   EQU $0E
 131+ 0000              ANTI_BRICK_SYSTEM_REGISTER				EQU $10
 132+ 0000              VIDEO_TIMING_REGISTER                   EQU $11
 133+ 0000              LAYER2_RAM_PAGE_REGISTER				EQU $12
 134+ 0000              LAYER2_RAM_SHADOW_REGISTER      		EQU $13
 135+ 0000              TRANSPARENCY_COLOUR_REGISTER			EQU $14
 136+ 0000              SPRITE_LAYERS_SYSTEM_REGISTER			EQU $15
 137+ 0000              LAYER2_OFFSET_X_REGISTER				EQU $16
 138+ 0000              LAYER2_OFFSET_Y_REGISTER				EQU $17
 139+ 0000              CLIP_WINDOW_LAYER2_REGISTER				EQU $18
 140+ 0000              CLIP_WINDOW_SPRITES_REGISTER			EQU $19
 141+ 0000              CLIP_WINDOW_ULA_REGISTER				EQU $1A
 142+ 0000              CLIP_WINDOW_TILEMAP_REGISTER            EQU $1B
 143+ 0000              CLIP_WINDOW_CONTROL_REGISTER			EQU $1C
 144+ 0000              ;29 not used
 145+ 0000              ACTIVE_VIDEO_LINE_MSB_REGISTER			EQU $1E
 146+ 0000              ACTIVE_VIDEO_LINE_LSB_REGISTER			EQU $1F
 147+ 0000              ; 32 to 34 not used
 148+ 0000              LINE_INTERRUPT_CONTROL_REGISTER			EQU $22
 149+ 0000              LINE_INTERRUPT_VALUE_LSB_REGISTER		EQU $23
 150+ 0000              ULA_X_OFFSET_REGISTER                   EQU $26
 151+ 0000              ULA_Y_OFFSET_REGSITER                   EQU $27
 152+ 0000              KEYMAP_HIGH_ADDRESS_REGISTER			EQU $28
 153+ 0000              KEYMAP_LOW_ADDRESS_REGISTER				EQU $29
 154+ 0000              KEYMAP_HIGH_DATA_REGISTER				EQU $2A
 155+ 0000              KEYMAP_LOW_DATA_REGISTER				EQU $2B
 156+ 0000              DAC_B_MIRROR_REGISTER                   EQU $2C
 157+ 0000              DAC_AB_MIRROR_REGISTER                  EQU $2D
 158+ 0000              DAC_C_MORROR_REGISTER                   EQU $2E
 159+ 0000              TILEMAP_OFFSET_XMSB_REGISTER            EQU $2F
 160+ 0000              TILEMAP_OFFSET_XLSB_REGISTER            EQU $30
 161+ 0000              TILEMAP_OFFSET_YMSB_REGISTER            EQU $31
 162+ 0000              LORES_OFFSET_X_REGISTER					EQU $32
 163+ 0000              LORES_OFFSET_Y_REGISTER					EQU $33
 164+ 0000              SPRITE_PORT_INDEX_REGISTER              EQU $34
 165+ 0000              SPRITE_PORT_ATTR0_REGISTER              EQU $35
 166+ 0000              SPRITE_PORT_ATTR1_REGISTER              EQU $36
 167+ 0000              SPRITE_PORT_ATTR2_REGISTER              EQU $37
 168+ 0000              SPRITE_PORT_ATTR3_REGISTER              EQU $38
 169+ 0000              SPRITE_PORT_ATTR4_REGISTER              EQU $39
 170+ 0000              PALETTE_INDEX_REGISTER					EQU $40
 171+ 0000              PALETTE_VALUE_8BIT_REGISTER				EQU $41
 172+ 0000              PALETTE_FORMAT_REGISTER					EQU $42
 173+ 0000              PALETTE_CONTROL_REGISTER				EQU $43
 174+ 0000              PALETTE_VALUE_9BIT_REGISTER				EQU $44
 175+ 0000              TRANSPARENCY_COLOUR_FALLBACK_REGISTER   EQU $4A
 176+ 0000              SPRITES_TRANSPARENCY_INDEX_REGISTER     EQU $4B
 177+ 0000              TILEMAP_TRANSPARENCY_INDEX_REGISTER     EQU $4C
 178+ 0000              ; 72 to 79 unused
 179+ 0000              MMU_SLOT_0_REGISTER						EQU $50
 180+ 0000              MMU_SLOT_1_REGISTER						EQU $51
 181+ 0000              MMU_SLOT_2_REGISTER						EQU $52
 182+ 0000              MMU_SLOT_3_REGISTER						EQU $53
 183+ 0000              MMU_SLOT_4_REGISTER						EQU $54
 184+ 0000              MMU_SLOT_5_REGISTER						EQU $55
 185+ 0000              MMU_SLOT_6_REGISTER						EQU $56
 186+ 0000              MMU_SLOT_7_REGISTER						EQU $57
 187+ 0000              ; 88 to 95 unused
 188+ 0000              COPPER_DATA_REGISTER					EQU $60
 189+ 0000              COPPER_CONTROL_LOW_REGISTER				EQU $61
 190+ 0000              COPPER_CONTROL_HIGH_REGISTER			EQU $62
 191+ 0000              COPPER_DATA_16BIT_WRITE_REGISTER        EQU $63
 192+ 0000              VERTICAL_VIDEO_LINE_OFFSET_REGISTER     EQU $64
 193+ 0000              ULA_CONTROL_REGISTER                    EQU $68
 194+ 0000              DISPLAY_CONTROL_1_REGISTER              EQU $69
 195+ 0000              LORES_CONTROL_REGISTER                  EQU $6A
 196+ 0000              TILEMAP_CONTROL_REGISTER                EQU $6B
 197+ 0000              DEFAULT_TILEMAP_ATTRIBUTE_REGISTER      EQU $6C
 198+ 0000              ; 109 unused
 199+ 0000              TILEMAP_BASE_ADDRESS_REGISTER           EQU $6E
 200+ 0000              TILE_DEFINITIONS_BASE_ADDRESS_REGISTER  EQU $6F
 201+ 0000              LAYER_2_CONTROL_REGISTER                EQU $70
 202+ 0000              LAYER_2_X_OFFSET_MSB_REGISTER           EQU $71
 203+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_0_WITH_INC EQU $75
 204+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_1_WITH_INC EQU $76
 205+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_2_WITH_INC EQU $77
 206+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_3_WITH_INC EQU $78
 207+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_4_WITH_INC EQU $79
 208+ 0000              USER_STORAGE_0_REGISTER                 EQU $7F ; general purpose variable, e.g. for copper
 209+ 0000              EXPANSION_BUS_ENABLE_REGISTER           EQU $80
 210+ 0000              EXPANSION_BUS_CONTROL_REGISTER          EQU $81
 211+ 0000              INTERNAL_PORT_DECODING_B0_7_REGISTER    EQU $82
 212+ 0000              INTERNAL_PORT_DECODING_B8_15_REGISTER   EQU $83
 213+ 0000              INTERNAL_PORT_DECODING_B16_23_REGISTER  EQU $84
 214+ 0000              INTERNAL_PORT_DECODING_B24_31_REGISTER  EQU $85
 215+ 0000              EXPANSION_BUS_DECODING_B0_7_REGISTER    EQU $86
 216+ 0000              EXPANSION_BUS_DECODING_B8_15_REGISTER   EQU $87
 217+ 0000              EXPANSION_BUS_DECODING_B16_23_REGISTER  EQU $88
 218+ 0000              EXPANSION_BUS_DECODING_B24_31_REGISTER  EQU $89
 219+ 0000              EXPANSION_BUS_IO_PROPAGE_REGISTER       EQU $8A
 220+ 0000              ALTERNATE_ROM_REGISTER                  EQU $8C
 221+ 0000              MEMORY_MAPPING_REGISTER                 EQU $8E
 222+ 0000              PI_GPI_OUTPUT_ENABLE_0_REIGISTER        EQU $98
 223+ 0000              PI_GPI_OUTPUT_ENABLE_1_REIGISTER        EQU $99
 224+ 0000              PI_GPI_OUTPUT_ENABLE_2_REIGISTER        EQU $9A
 225+ 0000              PI_GPI_OUTPUT_ENABLE_3_REIGISTER        EQU $9B
 226+ 0000              PI_PERPIPHERAL_ENABLE_REGISTER          EQU $A0
 227+ 0000              PI_I2S_AUDIO_CONTROL_REGISTER           EQU $A2
 228+ 0000              PI_I2S_CLOCK_DIVIDE_REGISTER            EQU $A3
 229+ 0000              ESP_WIFI_GPIO_OUTPUT_REGISTER           EQU $A8
 230+ 0000              ESP_WIFI_GPIO_REGISTER                  EQU $A9
 231+ 0000              EXTENDED_KEYS_0_REGISTER                EQU $B0
 232+ 0000              EXTENDED_KEYS_1_REGISTER                EQU $B1
 233+ 0000              DIVMMC_TRAP_ENABLE_1                    EQU $B2
 234+ 0000              DIVMMC_TRAP_ENABLE_2                    EQU $B4
 235+ 0000              DEBUG_LED_CONTROL_REGISTER              EQU $FF
 236+ 0000
 237+ 0000              INTERUPT_CONTROL                        EQU $0C ; Interrupt control
 238+ 0000              NMI_RETURN_LSB				            EQU	$0C2	; NMI Return Address LSB
 239+ 0000              NMI_RETURN_MSB				            EQU	$0C3	; NMI Return Address MSB
 240+ 0000              INTERRUPT_EN0				            EQU	$0C4	; INT EN 0
 241+ 0000              INTERRUPT_EN1				            EQU	$0C5	; INT EN 1
 242+ 0000              INTERRUPT_EN2				            EQU	$0C6	; INT EN 2
 243+ 0000              INTERRUPT_ST0				            EQU	$0C8	; INT status 0
 244+ 0000              INTERRUPT_ST1				            EQU	$0C9	; INT status 1
 245+ 0000              INTERRUPT_ST2				            EQU	$0CA	; INT status 2
 246+ 0000              INTERRUPT_DM0				            EQU	$0CC	; INT DMA EN 0
 247+ 0000              INTERRUPT_DM1				            EQU	$0CD	; INT DMA EN 1
 248+ 0000              INTERRUPT_DM2				            EQU	$0CE	; INT DMA EN 2
 249+ 0000              CTC_CHANNEL_0				            EQU	$183B	; CTC channel 0 port
 250+ 0000              CTC_CHANNEL_1				            EQU	$193B	; CTC channel 1 port
 251+ 0000              CTC_CHANNEL_2				            EQU	$1A3B	; CTC channel 2 port
 252+ 0000              CTC_CHANNEL_3				            EQU	$1B3B	; CTC channel 3 port
 253+ 0000              CTC_CHANNEL_4				            EQU	$1C3B	; CTC channel 4 port
 254+ 0000              CTC_CHANNEL_5				            EQU	$1D3B	; CTC channel 5 port
 255+ 0000              CTC_CHANNEL_6				            EQU	$1E3B	; CTC channel 6 port
 256+ 0000              CTC_CHANNEL_7				            EQU	$1F3B	; CTC channel 7 port
 257+ 0000              CTCBASE                                 EQU $c0		; MSB Base address of buffer
 258+ 0000              CTCSIZE                                 EQU $04 	; MSB buffer length
 259+ 0000              CTCEND                                  EQU CTCBASE+(CTCSIZE*2)
 260+ 0000
 261+ 0000
 262+ 0000              DEBUG_LEDS_REGISTER						EQU 255
 263+ 0000
 264+ 0000
 265+ 0000              GetNextRegSaveBC:	MACRO register
 266+ 0000 ~                                push bc
 267+ 0000 ~                                ld bc,$243B
 268+ 0000 ~                                ld a,register
 269+ 0000 ~                                out (c),a
 270+ 0000 ~                                inc b
 271+ 0000 ~                                in a,(c)
 272+ 0000 ~                                pop bc
 273+ 0000                                  ENDM
 274+ 0000
 275+ 0000              GetNextReg:	MACRO register
 276+ 0000 ~                        ld bc,$243B
 277+ 0000 ~                        ld a,register
 278+ 0000 ~                        out (c),a
 279+ 0000 ~                        inc b
 280+ 0000 ~                        in a,(c)
 281+ 0000                          ENDM
 282+ 0000
# file closed: ../../Hardware/register_defines.asm
  23  0000                                      INCLUDE "../../Layer2Graphics/layer2_defines.asm"
# file opened: ../../Layer2Graphics/layer2_defines.asm
   1+ 0000
   2+ 0000
   3+ 0000              LAYER2_SHIFTED_SCREEN_TOP  	 equ 0
   4+ 0000              LAYER2_SHIFTED_SCREEN_MIDDLE equ $40
   5+ 0000              LAYER2_SHIFTED_SCREEN_BOTTOM equ $80
   6+ 0000
   7+ 0000              ; note hi byte is not decoded on DMA port so can out OUTIR
   8+ 0000
   9+ 0000              IO_SPRITE_SLOT_PORT 		 equ 12347
  10+ 0000              IO_SPRITE_PATTERN_PORT       equ 91
  11+ 0000              IO_SPRITE_ATTRIBUTES_PORT    equ 87
  12+ 0000
  13+ 0000              LAYER2_VISIBLE_MASK 		equ $02
  14+ 0000              ; DEBUG 0 for always write to primary 08 for double buffering
  15+ 0000                  IFDEF DOUBLEBUFFER
  16+ 0000 ~            LAYER2_SHADOW_SCREEN_MASK 	equ $08
  17+ 0000                  ELSE
  18+ 0000              LAYER2_SHADOW_SCREEN_MASK 	equ $00
  19+ 0000                  ENDIF
  20+ 0000              LAYER2_READ_ENABLE_MASK 	equ %00000100
  21+ 0000              LAYER2_WRITE_ENABLE_MASK 	equ %00000001
  22+ 0000              LAYER2_READ_WRITE_MASK      equ %00000101
  23+ 0000              LAYER2_SCREEN_SECTION_MASK 	equ $03
  24+ 0000              LAYER2_SCREEN_SECTION_SHIFT equ 6
  25+ 0000
  26+ 0000              LAYER2_DISABLE_MEM_WRITE    equ %11111110
  27+ 0000              LAYER2_DISABLE_MEM_READ     equ %11111011
  28+ 0000              LAYER2_DISABLE_MEM_ACCESS   equ %11111010
  29+ 0000
  30+ 0000              LAYER2_SCREEN_BANK1          equ 8
  31+ 0000              LAYER2_SCREEN_BANK2          equ 9
  32+ 0000              LAYER2_SCREEN_BANK3          equ 10
  33+ 0000              LAYER2_SCREEN_BANK4          equ 11     ; used by 320 and 640 mode
  34+ 0000              LAYER2_SCREEN_BANK5          equ 12     ; used by 320 and 640 mode
  35+ 0000              LAYER2_SHADOW_BANK1          equ 13
  36+ 0000              LAYER2_SHADOW_BANK2          equ 14
  37+ 0000              LAYER2_SHADOW_BANK3          equ 15
  38+ 0000              LAYER2_SHADOW_BANK4          equ 16     ; used by 320 and 640 mode
  39+ 0000              LAYER2_SHADOW_BANK5          equ 17     ; used by 320 and 640 mode
  40+ 0000
  41+ 0000              SCREEN_HEIGHT 				 equ 192
  42+ 0000              SCREEN_RAM_BASE				 equ $0000
  43+ 0000              SCREEN_HOZ_MIN_PIX		     equ 10
  44+ 0000
  45+ 0000              SPRITES_VISIBLE_MASK         equ $01
  46+ 0000              SPRITES_ON_BORDER_MASK       equ $02
  47+ 0000              LAYER_PRIORITIES_MASK        equ $07
  48+ 0000              LORES_MODE_MASK              equ $80
  49+ 0000              LAYER_PRIORITIES_SHIFT       equ 2
  50+ 0000
  51+ 0000              LAYER_PRIORITIES_S_L_U 		equ 0
  52+ 0000              LAYER_PRIORITIES_L_S_U 		equ 1
  53+ 0000              LAYER_PRIORITIES_S_U_L  	equ 2
  54+ 0000              LAYER_PRIORITIES_L_U_S 		equ 3
  55+ 0000              LAYER_PRIORITIES_U_S_L 		equ 4
  56+ 0000              LAYER_PRIORITIES_U_L_S 		equ 5
  57+ 0000
  58+ 0000              DMA_WRO_BLOCK_PORTA_A2B_XFR  equ $7D
  59+ 0000              DMA_WRO_BLOCK_PORTA_B2A_XFR  equ $79
  60+ 0000              DMA_WR1_P1FIXED_MEMORY       equ $24
  61+ 0000              DMA_WR1_P1DEC_MEMORY         equ $04
  62+ 0000              DMA_WR1_P1INC_MEMORY         equ $14
  63+ 0000              DMA_WR2_P2FIXED_MEMORY       equ $20
  64+ 0000              DMA_WR2_P2DEC_MEMORY         equ $00
  65+ 0000              DMA_WR2_P2INC_MEMORY         equ $10
  66+ 0000              DMA_WR4_CONT_MODE            equ $AD
  67+ 0000              DMA_WR4_BURST_MODE           equ $CD
  68+ 0000              DMA_RESET                    equ $c3
  69+ 0000              DMA_RESET_PORT_A_TIMING      equ $c7
  70+ 0000              DMA_RESET_PORT_B_TIMING      equ $cb
  71+ 0000              DMA_LOAD                     equ $cf
  72+ 0000              DMA_CONTINUE                 equ $d3
  73+ 0000              DMA_DISABLE_INTERUPTS        equ $af
  74+ 0000              DMA_ENABLE_INTERUPTS         equ $ab
  75+ 0000              DMA_RESET_DISABLE_INTERUPTS  equ $a3
  76+ 0000              DMA_ENABLE_AFTER_RETI        equ $b7
  77+ 0000              DMA_READ_STATUS_BYTE         equ $bf
  78+ 0000              DMA_REINIT_STATUS_BYTE       equ $8b
  79+ 0000              DMA_START_READ_SEQUENCE      equ $a7
  80+ 0000              DMA_FORCE_READY              equ $b3
  81+ 0000              DMA_STOP_AT_END			     equ $82
  82+ 0000              DMA_DISABLE                  equ $83
  83+ 0000              DMA_ENABLE                   equ $87
  84+ 0000              DMA_WRITE_REGISTER_COMMAND   equ $bb
  85+ 0000              DMA_BURST                    equ $cd
  86+ 0000              DMA_CONTINUOUS               equ $ad
  87+ 0000              ZXN_DMA_PORT                 equ $6b
  88+ 0000
  89+ 0000
  90+ 0000              COLOUR_TRANSPARENT			 equ $E3
  91+ 0000
  92+ 0000
  93+ 0000
  94+ 0000
# file closed: ../../Layer2Graphics/layer2_defines.asm
  24  0000                                      INCLUDE	"../../Hardware/memory_bank_defines.asm"
# file opened: ../../Hardware/memory_bank_defines.asm
   1+ 0000
   2+ 0000              membanksize			    equ	$1FFF
   3+ 0000
   4+ 0000              StartOfBank     	    equ $0000
   5+ 0000
   6+ 0000              membank0 			    equ $0000
   7+ 0000              dmaCopySrcAddr		    equ	$0000
   8+ 0000              MathsTablesAddr         equ $0000
   9+ 0000              membank1 			    equ $2000
  10+ 0000              membank2 			    equ $4000
  11+ 0000              membank3 			    equ $6000
  12+ 0000              membank4 			    equ $8000
  13+ 0000              membank5 			    equ $a000
  14+ 0000              membank6 			    equ $c000
  15+ 0000              ScreenBank              equ $c000
  16+ 0000              MenuGalChtAddr          equ $c000
  17+ 0000              MenuEquipSAddr          equ $c000
  18+ 0000              MenuInventAddr          equ $c000
  19+ 0000              MenuMarketAddr          equ $c000
  20+ 0000              DispMarketAddr          equ $c000
  21+ 0000              MenuShrChtAddr          equ $c000
  22+ 0000              MenuStatusAddr          equ $c000
  23+ 0000              MenuSystemAddr          equ $c000
  24+ 0000              ViewFrontAddr           equ $c000
  25+ 0000              SunBankAddr             equ $c000
  26+ 0000              PlanetBankAddr          equ $c000
  27+ 0000              SpaceStationBankAddr    equ $c000
  28+ 0000              UniverseBankAddr	    equ $c000
  29+ 0000              LaunchShipAddr          equ $c000
  30+ 0000              membank7 			    equ $e000
  31+ 0000              L1membankAddr   	    equ $e000
  32+ 0000              L2membankAddr   	    equ $e000
  33+ 0000              ShipModelsAddr	        equ $e000
  34+ 0000              SpritemembankAddr       equ $e000
  35+ 0000              ResetUniverseAddr       equ $e000
  36+ 0000              StockTableAddr	        equ $e000
  37+ 0000              CommanderAddr           equ $e000
  38+ 0000              LAYER2Addr              equ $e000
  39+ 0000              LAYER1Addr              equ $e000
  40+ 0000              SPRITEAddr              equ $e000
  41+ 0000              ConsoleImageAddr        equ $e000
  42+ 0000              GalaxyDataAddr          equ $e000
  43+ 0000              SoundAddr               equ $e000
  44+ 0000              KeyboardAddr            equ $e000
  45+ 0000              MathsBankedFnsAddr      equ $0000
  46+ 0000
  47+ 0000              EXSDOSMMU0              equ MMU_SLOT_0_REGISTER
  48+ 0000              MathsTablesMMU          equ MMU_SLOT_0_REGISTER
  49+ 0000              MathsBankedFnsMMU       equ MMU_SLOT_0_REGISTER
  50+ 0000              ShipReadMMU             equ MMU_SLOT_0_REGISTER
  51+ 0000              DMACpySourceMMU		    equ	MMU_SLOT_0_REGISTER
  52+ 0000              EXSDOSMMU1              equ MMU_SLOT_1_REGISTER
  53+ 0000              SunMMU 		            equ MMU_SLOT_6_REGISTER
  54+ 0000              PlanetMMU 		        equ MMU_SLOT_6_REGISTER
  55+ 0000              UniverseMMU 		    equ MMU_SLOT_6_REGISTER
  56+ 0000              SpaceStationMMU         equ MMU_SLOT_6_REGISTER
  57+ 0000              ScreenBankMMU           equ MMU_SLOT_6_REGISTER
  58+ 0000              MenuEquipSMMU           equ MMU_SLOT_6_REGISTER
  59+ 0000              MenuShrChtMMU           equ MMU_SLOT_6_REGISTER
  60+ 0000              MenuGalChtMMU           equ MMU_SLOT_6_REGISTER
  61+ 0000              MenuInventMMU           equ MMU_SLOT_6_REGISTER
  62+ 0000              MenuSystemMMU           equ MMU_SLOT_6_REGISTER
  63+ 0000              MenuMarketMMU           equ MMU_SLOT_6_REGISTER
  64+ 0000              DispMarketMMU           equ MMU_SLOT_6_REGISTER
  65+ 0000              MenuStatusMMU           equ MMU_SLOT_6_REGISTER
  66+ 0000              LaunchShipMMU           equ MMU_SLOT_6_REGISTER
  67+ 0000              L1memMMU       		    equ MMU_SLOT_7_REGISTER
  68+ 0000              L2memMMU       		    equ MMU_SLOT_7_REGISTER
  69+ 0000              SpritememMMU   		    equ MMU_SLOT_7_REGISTER
  70+ 0000              ShipModelMMU  		    equ MMU_SLOT_7_REGISTER
  71+ 0000              ResetUniverseMMU	    equ MMU_SLOT_7_REGISTER
  72+ 0000              CommanderMMU	        equ MMU_SLOT_7_REGISTER
  73+ 0000              StockTableMMU		    equ MMU_SLOT_7_REGISTER
  74+ 0000              ConsoleImageDataMMU	    equ MMU_SLOT_7_REGISTER
  75+ 0000              GalaxyDataMMU	        equ MMU_SLOT_7_REGISTER
  76+ 0000              SoundMMU                equ MMU_SLOT_7_REGISTER
  77+ 0000              KeyboardMMU             equ MMU_SLOT_7_REGISTER
  78+ 0000
  79+ 0000              ; banks 8 to 17 are reserved for layer 2 memory
  80+ 0000              BankResetUniv           equ 49
  81+ 0000              BankMenuShrCht          equ 50
  82+ 0000              BankMenuGalCht          equ 51
  83+ 0000              BankMenuInvent          equ 52
  84+ 0000              BankMenuSystem          equ 53
  85+ 0000              BankMenuMarket          equ 54
  86+ 0000              BankStockTable          equ 55
  87+ 0000              BankCommander           equ 56
  88+ 0000              BankLAYER2              equ 57
  89+ 0000              BankLAYER1              equ 58
  90+ 0000              BankShipModels1         equ 59
  91+ 0000              BankSPRITE              equ 60
  92+ 0000              BankConsole             equ 61
  93+ 0000              BankFrontView           equ 62
  94+ 0000              BankMenuStatus          equ 63
  95+ 0000              BankMenuEquipS          equ 64
  96+ 0000              BankLaunchShip          equ 65
  97+ 0000              BankDispMarket          equ 66
  98+ 0000              BankShipModels2         equ 67
  99+ 0000              BankShipModels3         equ 68
 100+ 0000              BankShipModels4         equ 69
 101+ 0000
 102+ 0000              BankUNIVDATA0           equ 70
 103+ 0000              BankSpaceStationData    equ 70
 104+ 0000              BankUNIVDATA1           equ 71
 105+ 0000              BankUNIVDATA2           equ 72
 106+ 0000              BankUNIVDATA3           equ 73
 107+ 0000              BankUNIVDATA4           equ 74
 108+ 0000              BankUNIVDATA5           equ 75
 109+ 0000              BankUNIVDATA6           equ 76
 110+ 0000              BankUNIVDATA7           equ 77
 111+ 0000              BankUNIVDATA8           equ 78
 112+ 0000              BankUNIVDATA9           equ 79
 113+ 0000              BankUNIVDATA10          equ 80
 114+ 0000              BankUNIVDATA11          equ 81
 115+ 0000              BankUNIVDATA12          equ 82
 116+ 0000              BankSunData             equ 83
 117+ 0000              BankPlanetData          equ 84
 118+ 0000
 119+ 0000              BankGalaxyData0         equ 91
 120+ 0000              BankGalaxyData1         equ 92
 121+ 0000              BankGalaxyData2         equ 93
 122+ 0000              BankGalaxyData3         equ 94
 123+ 0000              BankGalaxyData4         equ 95
 124+ 0000              BankGalaxyData5         equ 96
 125+ 0000              BankGalaxyData6         equ 97
 126+ 0000              BankGalaxyData7         equ 98
 127+ 0000
 128+ 0000              BankMathsTables         equ 99
 129+ 0000              BankSound               equ 100
 130+ 0000              BankKeyboard            equ 101
 131+ 0000              BankMathsBankedFns      equ 102
 132+ 0000
 133+ 0000              BankROM                 equ 255
 134+ 0000
 135+ 0000
# file closed: ../../Hardware/memory_bank_defines.asm
  25  0000                                      INCLUDE "../../Hardware/screen_equates.asm"
# file opened: ../../Hardware/screen_equates.asm
   1+ 0000              ScreenHeight 		equ 192
   2+ 0000              ScreenLastRow       equ ScreenHeight -1
   3+ 0000              ScreenWidth  		equ 256
   4+ 0000              ScreenLastCol       equ ScreenWidth -1
   5+ 0000              ScreenHeightHalf	equ 96
   6+ 0000              ScreenWidthHalf  	equ 128
   7+ 0000              ScreenCenterY		equ 96
   8+ 0000              ScreenCenterX       equ 128
   9+ 0000              ViewHeight          equ 128
  10+ 0000              ViewHeightPlus1     equ 128+1
  11+ 0000              ViewLastRow       	equ ViewHeight -1
  12+ 0000              ViewWidth  			equ 256
  13+ 0000              ViewLastCol         equ ViewWidth -1
  14+ 0000              ViewHeightHalf      equ 63
  15+ 0000              ViewWidthHalf       equ 127
  16+ 0000              ViewCenterY         equ 64
  17+ 0000              ViewCenterX         equ 128
  18+ 0000                                      DISPLAY "TODO: place odler for debugging"
  19+ 0000              ShipColour			equ $FF		; place holder for debugging TODO
  20+ 0000              ScreenL1Bottom      equ $5000
  21+ 0000              ScreenL1BottomLen   equ 32 * 8 * 8
  22+ 0000              ScreenL1AttrBtm     equ $5A00
  23+ 0000              ScreenL1AttrBtmLen  equ 32 * 8
  24+ 0000
# file closed: ../../Hardware/screen_equates.asm
  26  0000                                      INCLUDE "../../Data/ShipModelEquates.asm"
# file opened: ../../Data/ShipModelEquates.asm
   1+ 0000              ScoopDebrisOffset	        equ	0                               ; hull byte#0 high nibble is scoop info, lower nibble is debris spin info
   2+ 0000              MissileLockLoOffset	        equ 1
   3+ 0000              MissileLockHiOffset	        equ 2
   4+ 0000              EdgeAddyOffset		        equ 3
   5+ 0000              LineX4Offset		        equ 5
   6+ 0000              GunVertexOffset		        equ 6
   7+ 0000              ExplosionCtOffset	        equ 7
   8+ 0000              VertexCountOffset           equ 8
   9+ 0000              VertexCtX6Offset	        equ 9
  10+ 0000              EdgeCountOffset		        equ 10
  11+ 0000              BountyLoOffset		        equ 11
  12+ 0000              BountyHiOffset		        equ 12
  13+ 0000              FaceCtX4Offset		        equ 13
  14+ 0000              DotOffset			        equ 14
  15+ 0000              EnergyOffset		        equ 15
  16+ 0000              SpeedOffset			        equ 16
  17+ 0000              FaceAddyOffset		        equ 17
  18+ 0000              QOffset				        equ 19
  19+ 0000              LaserOffset			        equ 20
  20+ 0000              VerticiesAddyOffset         equ 21
  21+ 0000              ShipTypeOffset              equ 23
  22+ 0000              ShipNewBitsOffset           equ 24
  23+ 0000              ShipAIFlagsOffset           equ 25
  24+ 0000              ShipECMFittedChanceOffset   equ 26
  25+ 0000              ShipSolidFlagOffset         equ 27 ; Intially for non cargo these will be garbage
  26+ 0000              ShipSolidFillOffset         equ 28
  27+ 0000              ShipSolidLenOffset          equ 29
  28+ 0000              ShipDataLength              equ ShipECMFittedChanceOffset+1
  29+ 0000
  30+ 0000              CobraTablePointer           equ 43
  31+ 0000              ;29 faulty
  32+ 0000              BankThreshold               equ 16
  33+ 0000
  34+ 0000              ShipTableALast              equ 23
  35+ 0000              ShipTableBLast              equ 39
  36+ 0000              ShipTableCLast              equ 55
  37+ 0000
# file closed: ../../Data/ShipModelEquates.asm
  27  0000                                      INCLUDE "../../Macros/graphicsMacros.asm"
# file opened: ../../Macros/graphicsMacros.asm
   1+ 0000              ; General Graphics macros
   2+ 0000              DoubleBufferIfPossible: MACRO
   3+ 0000 ~                                    IFDEF DOUBLEBUFFER
   4+ 0000 ~                                        MMUSelectLayer2
   5+ 0000 ~                                        call  l2_cls
   6+ 0000 ~                                        call  l2_flip_buffers
   7+ 0000 ~                                    ENDIF
   8+ 0000                                      ENDM
   9+ 0000
  10+ 0000              DoubleBuffer320IfPossible: MACRO
  11+ 0000 ~                                    IFDEF DOUBLEBUFFER
  12+ 0000 ~                                        MMUSelectLayer2
  13+ 0000 ~                                        call  l2_320_cls
  14+ 0000 ~                                        call  l2_flip_buffers
  15+ 0000 ~                                    ENDIF
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              DoubleBuffer640IfPossible: MACRO
  19+ 0000 ~                                    IFDEF DOUBLEBUFFER
  20+ 0000 ~                                        MMUSelectLayer2
  21+ 0000 ~                                        call  l2_640_cls
  22+ 0000 ~                                        call  l2_flip_buffers
  23+ 0000 ~                                    ENDIF
  24+ 0000                                      ENDM
  25+ 0000
  26+ 0000
  27+ 0000
  28+ 0000              ErrorEquStepMinusDelta: MACRO   delta_step, delta_value
  29+ 0000 ~                                    ld      hl,(delta_step)
  30+ 0000 ~                                    ld      de,(delta_value)
  31+ 0000 ~                                    ClearCarryFlag
  32+ 0000 ~                                    sbc     hl,de
  33+ 0000 ~                                    ld      (error),hl
  34+ 0000                                      ENDM
  35+ 0000
  36+ 0000              ; we could hold steps and deltas in alternate registers later
  37+ 0000              ErrorPlusStep:          MACRO   delta_step
  38+ 0000 ~                                    ld      hl,(error)
  39+ 0000 ~                                    ld      de,(delta_step)
  40+ 0000 ~                                    add     hl,de
  41+ 0000 ~                                    ld      (error),hl
  42+ 0000                                      ENDM
  43+ 0000
  44+ 0000              ErrorMinusStep:         MACRO   delta_step
  45+ 0000 ~                                    ld      hl,(error)
  46+ 0000 ~                                    ld      de,(delta_step)
  47+ 0000 ~                                    ClearCarryFlag
  48+ 0000 ~                                    sbc     hl,de
  49+ 0000 ~                                    ld      (error),hl
  50+ 0000                                      ENDM
  51+ 0000
  52+ 0000              SetExitFalse:           MACRO
  53+ 0000 ~                                    xor     a
  54+ 0000 ~                                    ld      (set_exit),a
  55+ 0000                                      ENDM
  56+ 0000
  57+ 0000              ; pulls axis high byte to a, returns nz if negative, z if positive
  58+ 0000              IsAxisLT0:              MACRO   axis
  59+ 0000 ~                                    ld      a,(axis+1)
  60+ 0000 ~                                    and     $80
  61+ 0000                                      ENDM
  62+ 0000
  63+ 0000              ; modifies HL, loaded with register, returns z if >=0, nz if negative
  64+ 0000              IsMemld16GTE0           MACRO   mem
  65+ 0000 ~                                    ld      hl, (mem)
  66+ 0000 ~                                    bit     7,h
  67+ 0000                                      ENDM
  68+ 0000
  69+ 0000              IsMemNegative8JumpFalse:MACRO   mem, target
  70+ 0000 ~                                    ld      a,(mem)
  71+ 0000 ~                                    and     $80
  72+ 0000 ~                                    jp      z, target
  73+ 0000                                      ENDM
  74+ 0000
  75+ 0000              IsMem16GT0JumpFalse:    MACRO   mem, target
  76+ 0000 ~                                    ld      hl, (mem)
  77+ 0000 ~                                    bit     7,h
  78+ 0000 ~                                    jp      nz, target
  79+ 0000 ~                                    ld      a,h
  80+ 0000 ~                                    or      l
  81+ 0000 ~                                    jp      z,  target
  82+ 0000                                      ENDM
  83+ 0000
  84+ 0000              FloorHLdivDETarget:     MACRO   target
  85+ 0000 ~                                    call    l_div                   ;       .  (so we swap and call l_div) HL = DE / HL, DE = DE % HL
  86+ 0000 ~                                    ld      a,d                     ;       .  get bit 7 into carry (set if negative)
  87+ 0000 ~                                    sla     a                       ;
  88+ 0000 ~                                    jr      nc,.FloorIsOK           ;
  89+ 0000 ~            .FloorAdjust:           dec     hl                      ;       .  if remainder >= adjust by 1 for negative
  90+ 0000 ~            .FloorIsOK:             ld      (target),hl             ;       .  now save the msd value
  91+ 0000                                      ENDM
  92+ 0000
# file closed: ../../Macros/graphicsMacros.asm
  28  0000                                      INCLUDE "../../Macros/callMacros.asm"
# file opened: ../../Macros/callMacros.asm
   1+ 0000
   2+ 0000              CallIfAEqNusng:         MACRO   reg,target
   3+ 0000 ~                                    cp      reg
   4+ 0000 ~                                    call	z,target
   5+ 0000                                      ENDM
   6+ 0000
   7+ 0000              CallIfAGTENusng:        MACRO   reg,target
   8+ 0000 ~                                    cp      reg
   9+ 0000 ~                                    call	nc,target
  10+ 0000                                      ENDM
  11+ 0000
  12+ 0000              CallIfAGTEMemusng:      MACRO   reg,target
  13+ 0000 ~                                    ld      hl,reg
  14+ 0000 ~                                    cp      (hl)
  15+ 0000 ~                                    call	nc,target
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              CallIfALTMemusng:       MACRO   reg,target
  19+ 0000 ~                                    ld      hl,reg
  20+ 0000 ~                                    cp      (hl)
  21+ 0000 ~                                    call	c,target
  22+ 0000                                      ENDM
  23+ 0000
  24+ 0000              CallIfALTNusng:         MACRO   reg,target
  25+ 0000 ~                                    cp      reg
  26+ 0000 ~                                    call	c,target
  27+ 0000                                      ENDM
  28+ 0000
  29+ 0000              CallIfMemEqMemusng:     MACRO mem, address, target
  30+ 0000 ~                                    ld      a,(mem)
  31+ 0000 ~                                    ld      hl,address
  32+ 0000 ~                                    cp      (hl)
  33+ 0000 ~                                    call    z,target
  34+ 0000                                      ENDM
  35+ 0000
  36+ 0000              CallIfMemEqNusng:       MACRO mem, value, target
  37+ 0000 ~                                    ld      a,(mem)
  38+ 0000 ~                                    cp      value
  39+ 0000 ~                                    call    z,target
  40+ 0000                                      ENDM
  41+ 0000
  42+ 0000
  43+ 0000              CallIfMemGTENusng:      MACRO mem, value, target
  44+ 0000 ~                                    ld      a,(mem)
  45+ 0000 ~                                    cp      value
  46+ 0000 ~                                    call    nc,target
  47+ 0000                                      ENDM
  48+ 0000
  49+ 0000              CallIfMemTrue:          MACRO mem, target
  50+ 0000 ~                                    ld      a,(mem)
  51+ 0000 ~                                    and     a
  52+ 0000 ~                                    call    z, target
  53+ 0000                                      ENDM
  54+ 0000
  55+ 0000              CallIfMemFalse:         MACRO mem, target
  56+ 0000 ~                                    ld      a,(mem)
  57+ 0000 ~                                    and     a
  58+ 0000 ~                                    call    nz, target
  59+ 0000                                      ENDM
  60+ 0000
  61+ 0000              CallIfMemZero:          MACRO mem, target
  62+ 0000 ~                                    ld      a,(mem)
  63+ 0000 ~                                    and     a
  64+ 0000 ~                                    call    z, target
  65+ 0000                                      ENDM
  66+ 0000
  67+ 0000              CallIfMemNotZero:       MACRO mem, target
  68+ 0000 ~                                    ld      a,(mem)
  69+ 0000 ~                                    and     a
  70+ 0000 ~                                    call    nz, target
  71+ 0000                                      ENDM
  72+ 0000              CallIfATrue:            MACRO target
  73+ 0000 ~                                    and     a
  74+ 0000 ~                                    call    z, target
  75+ 0000                                      ENDM
  76+ 0000
  77+ 0000              CallIfAFalse:           MACRO target
  78+ 0000 ~                                    and     a
  79+ 0000 ~                                    call    nz, target
  80+ 0000                                      ENDM
  81+ 0000
  82+ 0000              CallIfAZero:            MACRO target
  83+ 0000 ~                                    and     a
  84+ 0000 ~                                    call    z, target
  85+ 0000                                      ENDM
  86+ 0000
  87+ 0000              CallIfANotZero:         MACRO target
  88+ 0000 ~                                    and     a
  89+ 0000 ~                                    call    nz, target
  90+ 0000                                      ENDM
# file closed: ../../Macros/callMacros.asm
  29  0000                                      INCLUDE "../../Macros/carryFlagMacros.asm"
# file opened: ../../Macros/carryFlagMacros.asm
   1+ 0000
   2+ 0000              SetCarryFlag:           MACRO
   3+ 0000 ~                                    scf
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              ClearCarryFlag:	        MACRO
   7+ 0000 ~                                    or a
   8+ 0000                                      ENDM
   9+ 0000
  10+ 0000              FlipCarryFlag:          MACRO
  11+ 0000 ~                                    ccf
  12+ 0000                                      ENDM
  13+ 0000
# file closed: ../../Macros/carryFlagMacros.asm
  30  0000                                      INCLUDE "../../Macros/CopyByteMacros.asm"
# file opened: ../../Macros/CopyByteMacros.asm
   1+ 0000              CopyByteAtHLixToA:		MACRO memloc
   2+ 0000 ~            						ex          de,hl                               ; save hl
   3+ 0000 ~            						ld          hl,memloc
   4+ 0000 ~            						add         hl,a
   5+ 0000 ~            						ld          a,(hl)                              ; get XX2[x]
   6+ 0000 ~            						ex          de,hl                               ; get hl back as we need it in loop
   7+ 0000              						ENDM
   8+ 0000
   9+ 0000              ; Increments IYL
  10+ 0000              ; Increments IHL
  11+ 0000              ; Gets value at hl and loads into Parameter 1 address
  12+ 0000
  13+ 0000              CopyByteAtNextHLiyl: 	MACRO memloc
  14+ 0000 ~            						inc         iyl                                 ;
  15+ 0000 ~            						inc         hl                                  ; vertex byte#1
  16+ 0000 ~            						ld          a,(hl)                              ;
  17+ 0000 ~            						ld          (memloc),a                     ; XX15+2 = (V),Y
  18+ 0000              						ENDM
  19+ 0000
  20+ 0000              ;------------------------------------------------------------------------------------------------------------------------------
  21+ 0000              CopyByteAtNextHL:   MACRO targetaddr
  22+ 0000 ~                                inc         hl                                  ; vertex byte#1
  23+ 0000 ~                                ld          a,(hl)                              ;
  24+ 0000 ~                                ld          (targetaddr),a                     ; SunXX15+2 = (V),Y
  25+ 0000                                  ENDM
# file closed: ../../Macros/CopyByteMacros.asm
  31  0000                                      INCLUDE "../../Macros/ldCopyMacros.asm"
# file opened: ../../Macros/ldCopyMacros.asm
   1+ 0000              ZeroA:		            MACRO
   2+ 0000 ~                                    xor a
   3+ 0000                                      ENDM
   4+ 0000
   5+ 0000              SetATrue:               MACRO
   6+ 0000 ~                                    xor     a
   7+ 0000                                      ENDM
   8+ 0000
   9+ 0000              SetAFalse:              MACRO
  10+ 0000 ~                                    ld      a,$FF
  11+ 0000                                      ENDM
  12+ 0000
  13+ 0000              SetMemFalse             MACRO   mem
  14+ 0000 ~                                    ld      a,$FF
  15+ 0000 ~                                    ld      (mem),a
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              SetMemTrue              MACRO   mem
  19+ 0000 ~                                    xor     a
  20+ 0000 ~                                    ld      (mem),a
  21+ 0000                                      ENDM
  22+ 0000
  23+ 0000              SetMemZero:             MACRO   mem
  24+ 0000 ~                                    xor     a
  25+ 0000 ~                                    ld      (mem),a
  26+ 0000                                      ENDM
  27+ 0000
  28+ 0000              SetMemToN:              MACRO   mem,value
  29+ 0000 ~                                    ld      a,value
  30+ 0000 ~                                    ld      (mem),a
  31+ 0000                                      ENDM
  32+ 0000
  33+ 0000              ldCopyStringLen:        MACRO   source, target, strlen
  34+ 0000 ~                                    ld      hl,source
  35+ 0000 ~                                    ld      de, target
  36+ 0000 ~                                    ld      bc, strlen
  37+ 0000 ~                                    ldir
  38+ 0000                                      ENDM
  39+ 0000
  40+ 0000              ldCopyTextAtHLtoDE:     MACRO
  41+ 0000 ~            .CopyLoop:              ld      a,(hl)
  42+ 0000 ~                                    ld      (de),a
  43+ 0000 ~                                    cp      0
  44+ 0000 ~                                    jp      z,.DoneCopy
  45+ 0000 ~                                    inc     hl
  46+ 0000 ~                                    inc     de
  47+ 0000 ~                                    jr      .CopyLoop
  48+ 0000 ~            .DoneCopy:
  49+ 0000                                      ENDM
  50+ 0000
  51+ 0000              ldClearTextLoop:        MACRO   TextSize
  52+ 0000 ~                                    ld      b,a
  53+ 0000 ~                                    ld      a,TextSize
  54+ 0000 ~            .ClearLoop:             ld      (hl),a
  55+ 0000 ~                                    inc     hl
  56+ 0000 ~                                    djnz    .ClearLoop
  57+ 0000                                      ENDM
  58+ 0000
  59+ 0000              ldCopyByte:             MACRO memfrom, memto
  60+ 0000 ~                                    ld       a,(memfrom)
  61+ 0000 ~                                    ld       (memto),a
  62+ 0000                                      ENDM
  63+ 0000
  64+ 0000
  65+ 0000              ldCopyByteABS:          MACRO memfrom, memto
  66+ 0000 ~                                    ld       a,(memfrom)
  67+ 0000 ~                                    and		$7F
  68+ 0000 ~                                    ld       (memto),a
  69+ 0000                                      ENDM
  70+ 0000
  71+ 0000              ldAtHLtoMem:            MACRO   memto
  72+ 0000 ~                                    ld      a,(hl)
  73+ 0000 ~                                    ld      (memto),a
  74+ 0000                                      ENDM
  75+ 0000
  76+ 0000              ldCopyWord:             MACRO memfrom, memto
  77+ 0000 ~                                    ldCopy2Byte memfrom, memto
  78+ 0000                                      ENDM
  79+ 0000
  80+ 0000              ldCopy2Byte:            MACRO  memfrom, memto
  81+ 0000 ~                                    ld       hl,(memfrom)
  82+ 0000 ~                                    ld       (memto),hl
  83+ 0000                                      ENDM
  84+ 0000
  85+ 0000              ldWriteConst            MACRO  memfrom, memto
  86+ 0000 ~                                    ld       a,memfrom
  87+ 0000 ~                                    ld       (memto),a
  88+ 0000                                      ENDM
  89+ 0000
  90+ 0000              ldWriteZero             MACRO  memto
  91+ 0000 ~                                    xor      a
  92+ 0000 ~                                    ld       (memto),a
  93+ 0000                                      ENDM
  94+ 0000
  95+ 0000              ldIXLaFromN:	        MACRO memfrom
  96+ 0000 ~                                    ld		a,(memfrom)
  97+ 0000 ~                                    ld		ixl,a
  98+ 0000                                      ENDM
  99+ 0000
 100+ 0000              ldIXHaFromN:	        MACRO memfrom
 101+ 0000 ~                                    ld		a,(memfrom)
 102+ 0000 ~                                    ld		ixh,a
 103+ 0000                                      ENDM
 104+ 0000
 105+ 0000              ldIYLaFromN:	        MACRO memfrom
 106+ 0000 ~                                    ld		a,(memfrom)
 107+ 0000 ~                                    ld		iyl,a
 108+ 0000                                      ENDM
 109+ 0000
 110+ 0000              ldIYHaFromN:	        MACRO memfrom
 111+ 0000 ~                                    ld		a,(memfrom)
 112+ 0000 ~                                    ld		iyh,a
 113+ 0000                                      ENDM
 114+ 0000
 115+ 0000              ; Read a 32 bit value from address HL into BCDE
 116+ 0000              ldBCDEatHL:             MACRO
 117+ 0000 ~                                    ld      e,(hl)
 118+ 0000 ~                                    inc     hl
 119+ 0000 ~                                    ld      d,(hl)
 120+ 0000 ~                                    inc     hl
 121+ 0000 ~                                    ld      c,(hl)
 122+ 0000 ~                                    inc     hl
 123+ 0000 ~                                    ld      b,(hl)
 124+ 0000 ~                                    inc     hl
 125+ 0000                                      ENDM
 126+ 0000
 127+ 0000              ldBCatHL:               MACRO
 128+ 0000 ~                                    ld      c,(hl)
 129+ 0000 ~                                    inc     hl
 130+ 0000 ~                                    ld      b,(hl)
 131+ 0000 ~                                    inc     hl
 132+ 0000                                      ENDM
 133+ 0000
 134+ 0000              ldhlde:			        MACRO
 135+ 0000 ~                                    ld		h,d
 136+ 0000 ~                                    ld		l,e
 137+ 0000                                      ENDM
 138+ 0000
 139+ 0000              ldhlbc:			        MACRO
 140+ 0000 ~                                    ld		h,b
 141+ 0000 ~                                    ld		l,c
 142+ 0000                                      ENDM
 143+ 0000
 144+ 0000              ldbcde:			        MACRO
 145+ 0000 ~                                    ld		b,d
 146+ 0000 ~                                    ld		c,e
 147+ 0000                                      ENDM
 148+ 0000
 149+ 0000              lddebc:			        MACRO
 150+ 0000 ~                                    ld		d,b
 151+ 0000 ~                                    ld		e,c
 152+ 0000                                      ENDM
 153+ 0000
 154+ 0000              ldbchl:			        MACRO
 155+ 0000 ~                                    ld		b,h
 156+ 0000 ~                                    ld		c,l
 157+ 0000                                      ENDM
 158+ 0000
 159+ 0000              lddeiy:			        MACRO
 160+ 0000 ~                                    ld		d,iyh
 161+ 0000 ~                                    ld		e,iyl
 162+ 0000                                      ENDM
 163+ 0000
 164+ 0000              ldiyde:			        MACRO
 165+ 0000 ~                                    ld		iyh,d
 166+ 0000 ~                                    ld		iyl,e
 167+ 0000                                      ENDM
 168+ 0000
 169+ 0000
 170+ 0000              FourLDIInstrunctions:   MACRO
 171+ 0000 ~                                    ldi
 172+ 0000 ~                                    ldi
 173+ 0000 ~                                    ldi
 174+ 0000 ~                                    ldi
 175+ 0000                                      ENDM
 176+ 0000
 177+ 0000              FiveLDIInstrunctions:   MACRO
 178+ 0000 ~                                    ldi
 179+ 0000 ~                                    ldi
 180+ 0000 ~                                    ldi
 181+ 0000 ~                                    ldi
 182+ 0000 ~                                    ldi
 183+ 0000                                      ENDM
 184+ 0000
 185+ 0000              SixLDIInstrunctions:    MACRO
 186+ 0000 ~                                    ldi
 187+ 0000 ~                                    ldi
 188+ 0000 ~                                    ldi
 189+ 0000 ~                                    ldi
 190+ 0000 ~                                    ldi
 191+ 0000 ~                                    ldi
 192+ 0000                                      ENDM
 193+ 0000
 194+ 0000              EightLDIInstrunctions:  MACRO
 195+ 0000 ~            		                ldi
 196+ 0000 ~            		                ldi
 197+ 0000 ~            		                ldi
 198+ 0000 ~            		                ldi
 199+ 0000 ~            		                ldi
 200+ 0000 ~            		                ldi
 201+ 0000 ~            		                ldi
 202+ 0000 ~            		                ldi
 203+ 0000                                      ENDM
 204+ 0000
 205+ 0000              NineLDIInstrunctions:  MACRO
 206+ 0000 ~            		                ldi
 207+ 0000 ~            		                ldi
 208+ 0000 ~            		                ldi
 209+ 0000 ~            		                ldi
 210+ 0000 ~            		                ldi
 211+ 0000 ~            		                ldi
 212+ 0000 ~            		                ldi
 213+ 0000 ~            		                ldi
 214+ 0000 ~            		                ldi
 215+ 0000                                      ENDM
# file closed: ../../Macros/ldCopyMacros.asm
  32  0000                                      INCLUDE "../../Macros/ldIndexedMacros.asm"
# file opened: ../../Macros/ldIndexedMacros.asm
   1+ 0000              GetByteAInTable:    MACRO table
   2+ 0000 ~                                ld          hl,table
   3+ 0000 ~                                add         hl,a
   4+ 0000 ~                                ld          a,(hl)
   5+ 0000                                  ENDM
   6+ 0000
   7+ 0000              HLWordAInTable:     MACRO table
   8+ 0000 ~                                ld          hl,table
   9+ 0000 ~                                sla         a
  10+ 0000 ~                                add         hl,a
  11+ 0000 ~                                ld          a,(hl)
  12+ 0000 ~                                inc         hl
  13+ 0000 ~                                ld          h,(hl)
  14+ 0000 ~                                ld          l,a
  15+ 0000                                  ENDM
  16+ 0000
  17+ 0000
  18+ 0000              ldAToHLixl:			MACRO value
  19+ 0000 ~            					ld          hl,value
  20+ 0000 ~            					ex          af,af'
  21+ 0000 ~            					ld          a,ixl
  22+ 0000 ~            					add         hl,a
  23+ 0000 ~            					ex          af,af'
  24+ 0000 ~            					ld          (hl),a
  25+ 0000              					ENDM
  26+ 0000
  27+ 0000              ldAToHLiyl:			MACRO value
  28+ 0000 ~            					ld          hl,value
  29+ 0000 ~            					ex          af,af'
  30+ 0000 ~            					ld          a,iyl
  31+ 0000 ~            					add         hl,a
  32+ 0000 ~            					ex          af,af'
  33+ 0000 ~            					ld          (hl),a
  34+ 0000              					ENDM
  35+ 0000
  36+ 0000
  37+ 0000              ldHLixlToA:         MACRO value
  38+ 0000 ~                                ld          hl,value
  39+ 0000 ~                                ex          af,af'
  40+ 0000 ~                                ld          a,ixl
  41+ 0000 ~                                add         hl,a
  42+ 0000 ~                                ld          a,(hl)
  43+ 0000                                  ENDM
  44+ 0000
  45+ 0000              ldHLiylToA:         MACRO value
  46+ 0000 ~                                ld          hl,value
  47+ 0000 ~                                ex          af,af'
  48+ 0000 ~                                ld          a,iyl
  49+ 0000 ~                                add         hl,a
  50+ 0000 ~                                ld          a,(hl)
  51+ 0000                                  ENDM
  52+ 0000
  53+ 0000              ldHLIdxAToA:        MACRO value
  54+ 0000 ~                                ld          hl,value
  55+ 0000 ~                                add         hl,a
  56+ 0000 ~                                ld          a,(hl)
  57+ 0000                                  ENDM
  58+ 0000
  59+ 0000              HLEquAddrAtHLPlusA: MACRO
  60+ 0000 ~                                sla         a
  61+ 0000 ~                                add         hl,a
  62+ 0000 ~                                ld          a,(hl)
  63+ 0000 ~                                inc         hl
  64+ 0000 ~                                ld          h,(hl)
  65+ 0000 ~                                ld          l,a
  66+ 0000                                  ENDM
  67+ 0000
  68+ 0000              ;-- Performs HL = |HL| - 1
  69+ 0000              DecHLABS:           MACRO
  70+ 0000 ~                                bit         7,h
  71+ 0000 ~                                jp          nz,.NegativeDec
  72+ 0000 ~            .IsHLZero:          ld          a,h                 ; if its zero it becomes negative
  73+ 0000 ~                                or          l
  74+ 0000 ~                                jp          z,.HLZero
  75+ 0000 ~            .PositiveDec:       dec         hl
  76+ 0000 ~                                jp          .Done
  77+ 0000 ~            .NegativeDec:       ld          a,h
  78+ 0000 ~                                and         $7F
  79+ 0000 ~                                ld          h,a
  80+ 0000 ~                                dec         hl
  81+ 0000 ~                                set         7,h
  82+ 0000 ~                                jp          .Done
  83+ 0000 ~            .HLZero:            ld          hl,$8001
  84+ 0000 ~            .Done:
  85+ 0000                                  ENDM
  86+ 0000
  87+ 0000              ;-- Performs HL = HL - 1
  88+ 0000              DecHLSigned:        MACRO
  89+ 0000 ~                                bit         7,h
  90+ 0000 ~                                jp          nz,.NegativeDec
  91+ 0000 ~            .IsHLZero:          ld          a,h                 ; if its zero it becomes negative
  92+ 0000 ~                                or          l
  93+ 0000 ~                                jp          z,.HLZero
  94+ 0000 ~            .PositiveDec:       dec         hl
  95+ 0000 ~                                jp          .Done
  96+ 0000 ~            .NegativeDec:       ld          a,h
  97+ 0000 ~                                and         $7F
  98+ 0000 ~                                ld          h,a
  99+ 0000 ~                                inc         hl                  ; if its already negative then add 1 to make it further
 100+ 0000 ~                                set         7,h
 101+ 0000 ~                                jp          .Done
 102+ 0000 ~            .HLZero:            ld          hl,$8001
 103+ 0000 ~            .Done:
 104+ 0000                                  ENDM
 105+ 0000
# file closed: ../../Macros/ldIndexedMacros.asm
  33  0000                                      INCLUDE "../../Macros/jumpMacros.asm"
# file opened: ../../Macros/jumpMacros.asm
   1+ 0000              JumpIfHLNegative:       MACRO target
   2+ 0000 ~                                    bit     7,h
   3+ 0000 ~                                    jp      nz,target
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              JumpIfPositive:	        MACRO target
   7+ 0000 ~                                    jp		p, target
   8+ 0000                                      ENDM
   9+ 0000
  10+ 0000              JumpIfNegative:	        MACRO target
  11+ 0000 ~                                    jp		m, target
  12+ 0000                                      ENDM
  13+ 0000
  14+ 0000
  15+ 0000              JumpIfUnderflow:	    MACRO target
  16+ 0000 ~                                    jp		po, target
  17+ 0000                                      ENDM
  18+ 0000
  19+ 0000              JumpIfOverflow:	        MACRO target
  20+ 0000 ~                                    jp		po, target
  21+ 0000                                      ENDM
  22+ 0000
  23+ 0000
  24+ 0000              JumpIfNotZero:	        MACRO target
  25+ 0000 ~                                    jp	nz,target
  26+ 0000                                      ENDM
  27+ 0000
  28+ 0000              JumpIfZero:	            MACRO target
  29+ 0000 ~                                    jp	z,target
  30+ 0000                                      ENDM
  31+ 0000
  32+ 0000              ;.. Bit routines
  33+ 0000              JumpOnLeadSignSet:      MACRO   reg, target
  34+ 0000 ~                                    ld      a,reg
  35+ 0000 ~                                    and     SignOnly8Bit
  36+ 0000 ~                                    jp      nz,target
  37+ 0000                                      ENDM
  38+ 0000
  39+ 0000              JumpOnLeadSignClear:    MACRO   reg, target
  40+ 0000 ~                                    ld      a,reg
  41+ 0000 ~                                    and     SignOnly8Bit
  42+ 0000 ~                                    jp      z,target
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              JumpOnLeadSignSetA:     MACRO   target
  46+ 0000 ~                                    and     SignOnly8Bit
  47+ 0000 ~                                    jp      nz,target
  48+ 0000                                      ENDM
  49+ 0000
  50+ 0000              JumpOnLeadSignClearA:   MACRO   target
  51+ 0000 ~                                    and     SignOnly8Bit
  52+ 0000 ~                                    jp      z,target
  53+ 0000                                      ENDM
  54+ 0000
  55+ 0000              JumpOnMemBitSet:        MACRO mem, bitnbr, target
  56+ 0000 ~                                    ld      a,(mem)
  57+ 0000 ~                                    bit 	bitnbr,a
  58+ 0000 ~                                    jp      nz,target
  59+ 0000                                      ENDM
  60+ 0000
  61+ 0000              JumpOnMemBitClear:      MACRO mem, bitnbr, target
  62+ 0000 ~                                    ld      a,(mem)
  63+ 0000 ~                                    bit 	bitnbr,a
  64+ 0000 ~                                    jp      z,target
  65+ 0000                                      ENDM
  66+ 0000
  67+ 0000
  68+ 0000              JumpOnABitSet:          MACRO   bitnbr, target
  69+ 0000 ~                                    bit 	bitnbr, a
  70+ 0000 ~                                    jp      nz,target
  71+ 0000                                      ENDM
  72+ 0000
  73+ 0000              JumpOnABitClear:        MACRO   bitnbr, target
  74+ 0000 ~                                    bit 	bitnbr, a
  75+ 0000 ~                                    jp      z,target
  76+ 0000                                      ENDM
  77+ 0000
  78+ 0000              JumpOnABit5Set:         MACRO   target
  79+ 0000 ~                                    and     Bit5Only
  80+ 0000 ~                                    jp      nz,target
  81+ 0000                                      ENDM
  82+ 0000
  83+ 0000              JumpOnABit5Clear:       MACRO   target
  84+ 0000 ~                                    and     Bit5Only
  85+ 0000 ~                                    jp      z,target
  86+ 0000                                      ENDM
  87+ 0000
  88+ 0000              JumpOnBitMaskSet:       MACRO   bitmask, target
  89+ 0000 ~                                    and     bitmask
  90+ 0000 ~                                    jp      nz,target
  91+ 0000                                      ENDM
  92+ 0000
  93+ 0000              JumpOnBitMaskClear:     MACRO   bitmask, target
  94+ 0000 ~                                    and     bitmask
  95+ 0000 ~                                    jp      z,target
  96+ 0000                                      ENDM
  97+ 0000
  98+ 0000              JumpOnMemBitMaskSet:    MACRO   mem, bitmask, target
  99+ 0000 ~                                    ld      a,(mem)
 100+ 0000 ~                                    and     bitmask
 101+ 0000 ~                                    jp      nz,target
 102+ 0000                                      ENDM
 103+ 0000
 104+ 0000              JumpOnMemBitMaskClear:  MACRO   mem, bitmask, target
 105+ 0000 ~                                    ld      a,(mem)
 106+ 0000 ~                                    and     bitmask
 107+ 0000 ~                                    jp      z,target
 108+ 0000                                      ENDM
 109+ 0000
 110+ 0000              JumpOnBitSet:           MACRO  reg, bitnbr, target
 111+ 0000 ~                                    bit 	bitnbr,reg
 112+ 0000 ~                                    jp      nz,target
 113+ 0000                                      ENDM
 114+ 0000
 115+ 0000              JumpOnBitClear:         MACRO  reg, bitnbr, target
 116+ 0000 ~                                    bit 	bitnbr,reg
 117+ 0000 ~                                    jp      z,target
 118+ 0000                                      ENDM
 119+ 0000
 120+ 0000              ; Comparison Routines
 121+ 0000              JumpIfAGTEusng:         MACRO
 122+ 0000 ~                                    jp		nc,target
 123+ 0000                                      ENDM
 124+ 0000
 125+ 0000              JumpIfAGTENusng:        MACRO reg,target
 126+ 0000 ~                                    cp     reg
 127+ 0000 ~                                    jp		nc,target
 128+ 0000                                      ENDM
 129+ 0000
 130+ 0000              JumpIfAGTEMemusng:      MACRO mem,target
 131+ 0000 ~                                    ld      hl,mem
 132+ 0000 ~                                    cp      (hl)
 133+ 0000 ~                                    jp		nc,target
 134+ 0000                                      ENDM
 135+ 0000              JumpIfMemGTENusng:      MACRO mem, value, target
 136+ 0000 ~                                    ld     a,(mem)
 137+ 0000 ~                                    cp     value
 138+ 0000 ~                                    jp	  nc,target
 139+ 0000                                      ENDM
 140+ 0000
 141+ 0000              JumpIfMemGTEMemusng:    MACRO mem, address, target
 142+ 0000 ~                                    ld   a,(mem)
 143+ 0000 ~                                    ld   hl,address
 144+ 0000 ~                                    cp   (hl)
 145+ 0000 ~                                    jp	  nc,target
 146+ 0000                                      ENDM
 147+ 0000
 148+ 0000              JumpIfMemEqMemusng:     MACRO mem, address, target
 149+ 0000 ~                                    ld   a,(mem)
 150+ 0000 ~                                    ld   hl,address
 151+ 0000 ~                                    cp   (hl)
 152+ 0000 ~                                    jp	  z,target
 153+ 0000                                      ENDM
 154+ 0000
 155+ 0000              JumpIfMemNeMemusng:     MACRO mem, address, target
 156+ 0000 ~                                    ld   a,(mem)
 157+ 0000 ~                                    ld   hl,address
 158+ 0000 ~                                    cp   (hl)
 159+ 0000 ~                                    jp	  nz,target
 160+ 0000                                      ENDM
 161+ 0000
 162+ 0000              JumpIfMemTrue:          MACRO mem, target
 163+ 0000 ~                                    ld      a,(mem)
 164+ 0000 ~                                    and     a
 165+ 0000 ~                                    jp      z, target
 166+ 0000                                      ENDM
 167+ 0000
 168+ 0000              JumpIfMemFalse:         MACRO mem, target
 169+ 0000 ~                                    ld      a,(mem)
 170+ 0000 ~                                    and     a
 171+ 0000 ~                                    jp      nz, target
 172+ 0000                                      ENDM
 173+ 0000
 174+ 0000              JumpIfATrue:            MACRO target
 175+ 0000 ~                                    and     a
 176+ 0000 ~                                    jp      z, target
 177+ 0000                                      ENDM
 178+ 0000
 179+ 0000              JumpIfAFalse:           MACRO target
 180+ 0000 ~                                    and     a
 181+ 0000 ~                                    jp      nz, target
 182+ 0000                                      ENDM
 183+ 0000
 184+ 0000              JumpIfANotFalse:        MACRO target
 185+ 0000 ~                                    cp      $FF
 186+ 0000 ~                                    jp      nz, target
 187+ 0000                                      ENDM
 188+ 0000
 189+ 0000              ;-- Less than Macros -------------------------------------------
 190+ 0000              JumpIfALTMemHLusng:     MACRO target
 191+ 0000 ~                                    cp    (hl)
 192+ 0000 ~                                    jp	  c,target
 193+ 0000                                      ENDM
 194+ 0000
 195+ 0000              JumpIfRegLTE:           MACRO   reg, value, target
 196+ 0000 ~                                    ld      a,reg
 197+ 0000 ~                                    cp      value
 198+ 0000 ~                                    jp	    z,target
 199+ 0000 ~                                    jp		c, target
 200+ 0000                                      ENDM
 201+ 0000
 202+ 0000              JumpIfALTMemusng:       MACRO mem,target
 203+ 0000 ~                                    ld      hl,mem
 204+ 0000 ~                                    cp      (hl)
 205+ 0000 ~                                    jp		c,target
 206+ 0000                                      ENDM
 207+ 0000
 208+ 0000
 209+ 0000              JumpIfALTusng:          MACRO target
 210+ 0000 ~                                    jp		c,target
 211+ 0000                                      ENDM
 212+ 0000
 213+ 0000              JumpIfALTNusng:         MACRO value, target
 214+ 0000 ~                                    cp      value
 215+ 0000 ~                                    jp		c, target
 216+ 0000                                      ENDM
 217+ 0000
 218+ 0000              JumpIfALTNsigned:       MACRO   value, target
 219+ 0000 ~                                    cp      value
 220+ 0000 ~                                    jp      m,.SignSet
 221+ 0000 ~            .SignClear:             jp      pe,target       ; Sign (0), P/V (1)
 222+ 0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (0)
 223+ 0000 ~            .SignSet:               jp      po,target
 224+ 0000 ~            .CheckComplete:
 225+ 0000                                      ENDM
 226+ 0000
 227+ 0000              JumpIfMemLTNusng:       MACRO mem, value, target
 228+ 0000 ~                                    ld      a,(mem)
 229+ 0000 ~                                    cp      value
 230+ 0000 ~                                    jp	  c,target
 231+ 0000                                      ENDM
 232+ 0000
 233+ 0000              JumpIfMemLTMemusng:     MACRO mem, value, target
 234+ 0000 ~                                    ld    a,(mem)
 235+ 0000 ~                                    ld    hl,value
 236+ 0000 ~                                    cp    (hl)
 237+ 0000 ~                                    jp	  c,target
 238+ 0000                                      ENDM
 239+ 0000              ;-- ------------------------------------------------------------
 240+ 0000              JumpIfAGTENsigned       MACRO   value, target
 241+ 0000 ~                                    cp      value
 242+ 0000 ~                                    jp      m,.SignSet
 243+ 0000 ~            .SignClear:             jp      po,target       ; Sign (0), P/V (0)
 244+ 0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (1)
 245+ 0000 ~            .SignSet:               jp      pe,target
 246+ 0000 ~            .CheckComplete:
 247+ 0000                                      ENDM
 248+ 0000
 249+ 0000              JumpIfMemEqNusng:       MACRO mem,value,target
 250+ 0000 ~                                    ld  a,(mem)
 251+ 0000 ~                                    cp  value
 252+ 0000 ~                                    jp  z,target
 253+ 0000                                      ENDM
 254+ 0000
 255+ 0000              JumpIfMemNeNusng:       MACRO mem,value,target
 256+ 0000 ~                                    ld  a,(mem)
 257+ 0000 ~                                    cp  value
 258+ 0000 ~                                    jp  nz,target
 259+ 0000                                      ENDM
 260+ 0000
 261+ 0000              JumpIfMemZero:          MACRO mem,target
 262+ 0000 ~                                    ld  a,(mem)
 263+ 0000 ~                                    and a
 264+ 0000 ~                                    jp  z,target
 265+ 0000                                      ENDM
 266+ 0000
 267+ 0000              JumpIfMemNotZero:       MACRO mem,target
 268+ 0000 ~                                    ld  a,(mem)
 269+ 0000 ~                                    and a
 270+ 0000 ~                                    jp  nz,target
 271+ 0000                                      ENDM
 272+ 0000
 273+ 0000              JumpIfANENusng:         MACRO value, target
 274+ 0000 ~                                    cp     value
 275+ 0000 ~                                    jp      nz,target
 276+ 0000                                      ENDM
 277+ 0000
 278+ 0000              JumpIfANEquNusng:       MACRO value, target
 279+ 0000 ~                                    cp     value
 280+ 0000 ~                                    jp     z,target
 281+ 0000                                      ENDM
 282+ 0000
 283+ 0000              JumpIfANEMemusng:       MACRO  value, target
 284+ 0000 ~                                    ld    hl,value
 285+ 0000 ~                                    cp    (hl)
 286+ 0000 ~                                    jp      nz,target
 287+ 0000                                      ENDM
 288+ 0000
 289+ 0000              JumpIfAEqNusng:         MACRO value, target
 290+ 0000 ~                                    cp     value
 291+ 0000 ~                                    jp      z,target
 292+ 0000                                      ENDM
 293+ 0000
 294+ 0000              JumpIfAIsZero:	        MACRO target
 295+ 0000 ~                                    and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 296+ 0000 ~                                    jp	    z, target
 297+ 0000                                      ENDM
 298+ 0000
 299+ 0000              JumpIfRegIsNotZero:     MACRO   reg, target
 300+ 0000 ~                                    ld      a,reg
 301+ 0000 ~                                    and     a
 302+ 0000 ~                                    jp	    nz,target
 303+ 0000                                      ENDM
 304+ 0000
 305+ 0000
 306+ 0000              JumpIfAIsNotZero:       MACRO target
 307+ 0000 ~                                    and     a
 308+ 0000 ~                                    jp	    nz,target
 309+ 0000                                      ENDM
 310+ 0000
 311+ 0000              JumpIfMemIsNotZero:     MACRO value, target
 312+ 0000 ~                                    ld      a,(value)
 313+ 0000 ~                                    and     a
 314+ 0000 ~                                    jp	    nz,target
 315+ 0000                                      ENDM
 316+ 0000              IfResultZeroGoto:	    MACRO target
 317+ 0000 ~                                    jp	z,target
 318+ 0000                                      ENDM
 319+ 0000
 320+ 0000              IfResultNotZeroGoto:    MACRO target
 321+ 0000 ~                                    jp	nz,target
 322+ 0000                                      ENDM
 323+ 0000
# file closed: ../../Macros/jumpMacros.asm
  34  0000                                      INCLUDE "../../Macros/MathsMacros.asm"
# file opened: ../../Macros/MathsMacros.asm
   1+ 0000              ; sets z flag is HL less than 255 else sets it to nz (note opposite of GT127)
   2+ 0000              IsHLGT255:              MACRO
   3+ 0000 ~                                    bit     7,h
   4+ 0000 ~                                    ret     z
   5+ 0000 ~                                    ld      a,h
   6+ 0000 ~                                    and     a
   7+ 0000                                      ENDM
   8+ 0000
   9+ 0000              ; Sets z flat if HL = 255 else sets it to nz
  10+ 0000              IsHLEqu255:             MACRO
  11+ 0000 ~                                    ld      a,h
  12+ 0000 ~                                    and     a               ; if its non zero then it can't be 255
  13+ 0000 ~                                    ret     nz
  14+ 0000 ~                                    ld      a,l
  15+ 0000 ~                                    inc     a               ; if it was 255 the inc will set it to zero
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              ; Sets Z flag if GT 127 else nz
  19+ 0000              IsHLGT127:              MACRO
  20+ 0000 ~                                    bit     7,h             ; -ve?
  21+ 0000 ~                                    jr      nz,.DoneCheck
  22+ 0000 ~                                    ld      a,h             ; +ve > 256?
  23+ 0000 ~                                    and     a
  24+ 0000 ~                                    jr      nz,.DoneCheck
  25+ 0000 ~                                    ld      a,l
  26+ 0000 ~                                    and     $80             ; this will set z to false if bit 7 set and clear lower bits
  27+ 0000 ~                                    cp      $80             ; this will set z to true if bit 7 set
  28+ 0000 ~            .DoneCheck:
  29+ 0000                                      ENDM
  30+ 0000
  31+ 0000              ReturnIfHLGT127:        MACRO
  32+ 0000 ~                                    bit     7,h             ; -ve?
  33+ 0000 ~                                    jr      nz,.DoneCheck   ; forces check complete
  34+ 0000 ~                                    ld      a,h             ; +ve > 256?
  35+ 0000 ~                                    and     a               ;
  36+ 0000 ~                                    ret     nz              ; forces a return
  37+ 0000 ~                                    bit     7,l             ; bit 7 of lower set?
  38+ 0000 ~                                    ret     nz              ; forces a return
  39+ 0000 ~            .DoneCheck:
  40+ 0000                                      ENDM
  41+ 0000
  42+ 0000              IsDEGT127:              MACRO
  43+ 0000 ~                                    bit     7,d
  44+ 0000 ~                                    jr      nz,.DoneCheck
  45+ 0000 ~                                    ld      a,d
  46+ 0000 ~                                    jr      nz,.DoneCheck
  47+ 0000 ~                                    ld      a,e
  48+ 0000 ~                                    and     $80
  49+ 0000 ~            .DoneCheck:
  50+ 0000                                      ENDM
  51+ 0000
  52+ 0000              ABSa2c:                 MACRO
  53+ 0000 ~                                    bit     7,a
  54+ 0000 ~                                    jp      z,.DoneABSa
  55+ 0000 ~                                    neg
  56+ 0000 ~            .DoneABSa:
  57+ 0000                                      ENDM
  58+ 0000
  59+ 0000              DEEquSquareA:           MACRO
  60+ 0000 ~                                    ld  d,a
  61+ 0000 ~                                    ld  e,a
  62+ 0000 ~                                    mul de
  63+ 0000                                      ENDM
  64+ 0000
  65+ 0000              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
  66+ 0000 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
  67+ 0000 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
  68+ 0000 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
  69+ 0000 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
  70+ 0000 ~                                    xor $80                             ;
  71+ 0000 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
  72+ 0000 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
  73+ 0000 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
  74+ 0000 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
  75+ 0000 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
  76+ 0000 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
  77+ 0000                                      ENDM
  78+ 0000
  79+ 0000              SignedHLTo2C:           MACRO
  80+ 0000 ~                                    bit     7,h
  81+ 0000 ~                                    jr      z,.Done2c
  82+ 0000 ~                                    ld      a,h
  83+ 0000 ~                                    and     SignMask8Bit
  84+ 0000 ~                                    ld      h,a
  85+ 0000 ~                                    NegHL
  86+ 0000 ~            .Done2c:
  87+ 0000                                      ENDM
  88+ 0000
  89+ 0000              MemSignedTo2C:          MACRO   memfrom
  90+ 0000 ~                                    ld      hl,(memfrom)
  91+ 0000 ~                                    bit     7,h
  92+ 0000 ~                                    jr      z,.Done2c
  93+ 0000 ~                                    ld      a,h
  94+ 0000 ~                                    and     SignMask8Bit
  95+ 0000 ~                                    ld      h,a
  96+ 0000 ~            .Done2c:                ld      (memfrom),hl
  97+ 0000                                      ENDM
  98+ 0000
  99+ 0000
 100+ 0000                  ;returns result in H
 101+ 0000              EDiv10Inline:           MACRO
 102+ 0000 ~                                    ld      d,0
 103+ 0000 ~                                    ld      hl,de
 104+ 0000 ~                                    add     hl,hl
 105+ 0000 ~                                    add     hl,de
 106+ 0000 ~                                    add     hl,hl
 107+ 0000 ~                                    add     hl,hl
 108+ 0000 ~                                    add     hl,de
 109+ 0000 ~                                    add     hl,hl
 110+ 0000                                      ENDM
 111+ 0000
 112+ 0000              cpHLDE:                 MACRO
 113+ 0000 ~                                    push    hl
 114+ 0000 ~                                    and     a
 115+ 0000 ~                                    sbc     hl,de
 116+ 0000 ~                                    pop     hl
 117+ 0000                                      ENDM
 118+ 0000
 119+ 0000              cpABSDEHL:              MACRO
 120+ 0000 ~                                    push     hl,,de
 121+ 0000 ~                                    ld      a,h
 122+ 0000 ~                                    and     $7F
 123+ 0000 ~                                    ld      h,a
 124+ 0000 ~                                    ld      a,d
 125+ 0000 ~                                    and     $7F
 126+ 0000 ~                                    ld      d,a
 127+ 0000 ~                                    ex      de,hl
 128+ 0000 ~                                    sbc     hl,de
 129+ 0000 ~                                    pop     hl,,de
 130+ 0000                                      ENDM
 131+ 0000
 132+ 0000              ; Simple are they both the same setting z if they are
 133+ 0000              ; tehcicall this works but it measn the final ret z is alwys done
 134+ 0000              ; so jp needs to be to a target
 135+ 0000              cpHLEquDE:              MACRO   passedCheck
 136+ 0000 ~                                    ld      a,h
 137+ 0000 ~                                    cp      d
 138+ 0000 ~                                    jp      nz, passedCheck
 139+ 0000 ~                                    ld      a,l
 140+ 0000 ~                                    cp      e
 141+ 0000 ~            .NoTheSame:
 142+ 0000                                      ENDM
 143+ 0000
 144+ 0000              cpHLEquBC:              MACRO   passedCheck
 145+ 0000 ~                                    ld      a,h
 146+ 0000 ~                                    cp      b
 147+ 0000 ~                                    jp      nz, passedCheck
 148+ 0000 ~                                    ld      a,l
 149+ 0000 ~                                    cp      c
 150+ 0000 ~            .NoTheSame:
 151+ 0000                                      ENDM
 152+ 0000
 153+ 0000              cpDEEquBC:              MACRO   passedCheck
 154+ 0000 ~                                    ld      a,d
 155+ 0000 ~                                    cp      b
 156+ 0000 ~                                    jp      nz, passedCheck
 157+ 0000 ~                                    ld      a,e
 158+ 0000 ~                                    cp      c
 159+ 0000 ~            .NoTheSame:
 160+ 0000                                      ENDM
 161+ 0000              ; Simple version just sets carry if HL < DE reset, does an initial compare for z
 162+ 0000              cpHLDELeadSign:         MACRO
 163+ 0000 ~                                    ld      a,h
 164+ 0000 ~                                    cp      d
 165+ 0000 ~                                    jr      nz,.FullCompare
 166+ 0000 ~                                    ld      a,l
 167+ 0000 ~                                    cp      e
 168+ 0000 ~                                    ret     z
 169+ 0000 ~            .FullCompare:           ld      a,h
 170+ 0000 ~                                    xor     d
 171+ 0000 ~                                    and     $80
 172+ 0000 ~                                    jr      nz,.OppositeSigns   ; If opposite signs is a simple sign test
 173+ 0000 ~                                    ld      a,h                 ; same signs so a little simpler
 174+ 0000 ~                                    and     $80
 175+ 0000 ~                                    jp      z,cpHLDE            ; if h is positive then both are positive by here so just cpHLDE
 176+ 0000 ~                                    jp      cpABSDEHL           ; else we have to do ABScpDEHL
 177+ 0000 ~            .OppositeSigns:         ld      a,h
 178+ 0000 ~                                    and     $80
 179+ 0000 ~                                    and     $80
 180+ 0000 ~                                    jp      z,.HLGTDE
 181+ 0000 ~            .HLLTDE:                SetCarryFlag
 182+ 0000 ~                                    ret
 183+ 0000 ~            .HLGTDE:                ClearCarryFlag
 184+ 0000 ~                                    ret
 185+ 0000                                      ENDM
 186+ 0000
 187+ 0000              ;Unsigned
 188+ 0000              ;If HL == DE, then Z flag is set.
 189+ 0000              ;If HL != DE, then Z flag is reset.
 190+ 0000              ;If HL <  DE, then C flag is set.
 191+ 0000              ;If HL >= DE, then C flag is reset.
 192+ 0000              ;
 193+ 0000              ;Signed
 194+ 0000              ;If HL == DE, then Z flag is set.
 195+ 0000              ;If HL != DE, then Z flag is reset.
 196+ 0000              ;If HL <  DE, then S and P/V are different.
 197+ 0000              ;If HL >= DE, then S and P/V are the same.
 198+ 0000
 199+ 0000
 200+ 0000              N0equN1byN2div256:      MACRO param1,param2,param3
 201+ 0000 ~                                    ld      a,param3                        ;
 202+ 0000 ~                                    ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 203+ 0000 ~                                    ld      a,param2                        ; A = XX16 element
 204+ 0000 ~                                    ld      d,a
 205+ 0000 ~                                    mul
 206+ 0000 ~                                    ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 207+ 0000 ~                                    ld      (param1),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 208+ 0000                                      ENDM
 209+ 0000
 210+ 0000              AequN1xorN2:            MACRO  param1,param2
 211+ 0000 ~                                    ld      a,(param1)
 212+ 0000 ~                                    xor     param2
 213+ 0000                                      ENDM
 214+ 0000
 215+ 0000              SpeedMulAxis:           MACRO   speedreg, axis
 216+ 0000 ~                                    ld      e,speedreg
 217+ 0000 ~                                    ld      hl,(axis)
 218+ 0000 ~                                    ld      a,h
 219+ 0000 ~                                    ClearSignBitA
 220+ 0000 ~                                    ld      d,a
 221+ 0000 ~                                    mul     de
 222+ 0000 ~                                    ld      a,h
 223+ 0000 ~                                    SignBitOnlyA
 224+ 0000 ~                                    ld      b,a;ld      c,a
 225+ 0000 ~                                    ld      h,d;ld      e,d
 226+ 0000 ~                                    ld      c,0;ld      d,0
 227+ 0000                                      ENDM
 228+ 0000
 229+ 0000              ; Adds speed (8 bit) to vertex (24 bit signed)
 230+ 0000              AddSpeedToVert:         MACRO   vertex
 231+ 0000 ~                                    ld      de,(vertex+1)
 232+ 0000 ~                                    ld      a,(vertex)
 233+ 0000 ~                                    ld      l,a
 234+ 0000 ~                                    call    AddBCHtoDELsigned               ; DEL = DEL + BCH
 235+ 0000 ~                                    ld      a,l
 236+ 0000 ~                                    ld      (vertex),a
 237+ 0000 ~                                    ld      (vertex+1),de
 238+ 0000                                      ENDM
# file closed: ../../Macros/MathsMacros.asm
  35  0000                                      INCLUDE "../../Macros/MMUMacros.asm"
# file opened: ../../Macros/MMUMacros.asm
   1+ 0000              MMUSelectROM0:       MACRO
   2+ 0000 ~                                 nextreg EXSDOSMMU0,        BankROM
   3+ 0000                                   ENDM
   4+ 0000
   5+ 0000              MMUSelectROMS:       MACRO
   6+ 0000 ~                                 nextreg EXSDOSMMU0,        BankROM
   7+ 0000 ~                                 nextreg EXSDOSMMU1,        BankROM
   8+ 0000                                   ENDM
   9+ 0000
  10+ 0000              MMUSelectMathsTables:MACRO
  11+ 0000 ~                                 nextreg MathsTablesMMU,    BankMathsTables
  12+ 0000                                   ENDM
  13+ 0000
  14+ 0000              MMUSelectKeyboard:   MACRO
  15+ 0000 ~                                 nextreg KeyboardMMU,       BankKeyboard
  16+ 0000                                   ENDM
  17+ 0000
  18+ 0000              MMUSelectSpriteBank: MACRO
  19+ 0000 ~            					 nextreg SpritememMMU,	    BankSPRITE
  20+ 0000              					 ENDM
  21+ 0000
  22+ 0000              MMUSelectConsoleBank: MACRO
  23+ 0000 ~            					 nextreg ConsoleImageDataMMU,  BankConsole
  24+ 0000              					 ENDM
  25+ 0000
  26+ 0000              MMUSelectLayer1: 	 MACRO
  27+ 0000 ~            					 nextreg L1memMMU,		    BankLAYER1
  28+ 0000              					 ENDM
  29+ 0000
  30+ 0000              MMUSelectLayer2: 	 MACRO
  31+ 0000 ~            					 nextreg L2memMMU,		    BankLAYER2
  32+ 0000              					 ENDM
  33+ 0000
  34+ 0000              MMUSelectResetUniv:  MACRO
  35+ 0000 ~                                 nextreg ResetUniverseMMU, BankResetUniv
  36+ 0000                                   ENDM
  37+ 0000
  38+ 0000              MMUSelectShipARead:  MACRO
  39+ 0000 ~                                 add    a,BankUNIVDATA0
  40+ 0000 ~                                 nextreg ShipReadMMU,       a
  41+ 0000                                   ENDM
  42+ 0000
  43+ 0000              MMUSelectShipBank1:  MACRO
  44+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels1
  45+ 0000              					 ENDM
  46+ 0000              MMUSelectShipBank2:  MACRO
  47+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels2
  48+ 0000              					 ENDM
  49+ 0000              MMUSelectShipBank3:  MACRO
  50+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels3
  51+ 0000              					 ENDM
  52+ 0000              MMUSelectShipBank4:  MACRO
  53+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels4
  54+ 0000              					 ENDM
  55+ 0000
  56+ 0000              MMUSelectShipBankA   MACRO
  57+ 0000 ~            					 nextreg ShipModelMMU,	    a
  58+ 0000              					 ENDM
  59+ 0000
  60+ 0000              MMUSelectShipBankN:  MACRO value
  61+ 0000 ~            					 nextreg ShipModelMMU,	    value
  62+ 0000              					 ENDM
  63+ 0000
  64+ 0000              MMUSelectCommander:	 MACRO
  65+ 0000 ~                                 nextreg CommanderMMU,       BankCommander
  66+ 0000              					 ENDM
  67+ 0000
  68+ 0000              MMUSelectStockTable: MACRO
  69+ 0000 ~                                 nextreg StockTableMMU,     BankStockTable
  70+ 0000              					 ENDM
  71+ 0000
  72+ 0000              MMUSelectCpySrcA:    MACRO
  73+ 0000 ~                                 nextreg DMACpySourceMMU,	a
  74+ 0000              					 ENDM
  75+ 0000
  76+ 0000              MMUSelectCpySrcN:    MACRO value
  77+ 0000 ~                                 nextreg DMACpySourceMMU,	value
  78+ 0000              					 ENDM
  79+ 0000
  80+ 0000              MMUSelectSun:        MACRO
  81+ 0000 ~                                 nextreg SunMMU,            BankSunData
  82+ 0000                                   ENDM
  83+ 0000
  84+ 0000              MMUSelectPlanet:     MACRO
  85+ 0000 ~                                 nextreg PlanetMMU,         BankPlanetData
  86+ 0000                                   ENDM
  87+ 0000
  88+ 0000              MMUSelectUniverseA:  MACRO
  89+ 0000 ~                                 add    a,BankUNIVDATA0
  90+ 0000 ~                                 nextreg UniverseMMU,       a
  91+ 0000                                   ENDM
  92+ 0000              ;Version that assumes a pre calulated A, used whn optimising many switches
  93+ 0000              MMUSelectUnivBankA:  MACRO
  94+ 0000 ~                                 nextreg UniverseMMU,       a
  95+ 0000                                   ENDM
  96+ 0000
  97+ 0000              MMUSelectUniverseN:  MACRO value
  98+ 0000 ~                                 nextreg UniverseMMU,       BankUNIVDATA0+value
  99+ 0000                                   ENDM
 100+ 0000
 101+ 0000              MMUSelectSpaceStation: MACRO
 102+ 0000 ~                                 nextreg SpaceStationMMU,         BankSpaceStationData
 103+ 0000                                   ENDM
 104+ 0000
 105+ 0000              MMUSelectMathsBankedFns   MACRO
 106+ 0000 ~                                 nextreg MathsBankedFnsMMU, BankMathsBankedFns
 107+ 0000                                   ENDM
 108+ 0000
 109+ 0000              MMUSelectGalaxyA:    MACRO
 110+ 0000 ~                                 nextreg GalaxyDataMMU,     a
 111+ 0000                                   ENDM
 112+ 0000
 113+ 0000              MMUSelectGalaxyN:    MACRO value
 114+ 0000 ~                                 nextreg GalaxyDataMMU,     BankGalaxyData0+value
 115+ 0000                                   ENDM
 116+ 0000              MMUSelectGalaxyACopy:MACRO
 117+ 0000 ~                                 nextreg UniverseMMU,       a
 118+ 0000                                   ENDM
 119+ 0000
 120+ 0000              MMUSelectUniverseAbs:MACRO value
 121+ 0000 ~                                 nextreg UniverseMMU,       value
 122+ 0000                                   ENDM
 123+ 0000
 124+ 0000              MMUSelectMenuGalCht: MACRO
 125+ 0000 ~                                 nextreg MenuGalChtMMU,		BankMenuGalCht
 126+ 0000              					 ENDM
 127+ 0000
 128+ 0000              MMUSelectMenuShrCht: MACRO
 129+ 0000 ~            					 nextreg MenuShrChtMMU,		BankMenuShrCht
 130+ 0000              					 ENDM
 131+ 0000
 132+ 0000              MMUSelectMenuInvent: MACRO
 133+ 0000 ~                                 nextreg MenuInventMMU,		BankMenuInvent
 134+ 0000              					 ENDM
 135+ 0000
 136+ 0000              MMUSelectMenuSystem: MACRO
 137+ 0000 ~                                 nextreg MenuSystemMMU,		BankMenuSystem
 138+ 0000              					 ENDM
 139+ 0000
 140+ 0000              MMUSelectMenuMarket: MACRO
 141+ 0000 ~                                 nextreg MenuMarketMMU,		BankMenuMarket
 142+ 0000              					 ENDM
 143+ 0000
 144+ 0000              MMUSelectMenuStatus: MACRO
 145+ 0000 ~                                 nextreg MenuStatusMMU,		BankMenuStatus
 146+ 0000              					 ENDM
 147+ 0000
 148+ 0000              MMUSelectViewFront:  MACRO
 149+ 0000 ~                                 nextreg ScreenBankMMU,		BankFrontView
 150+ 0000              					 ENDM
 151+ 0000
 152+ 0000              MMUSelectScreenA:    MACRO
 153+ 0000 ~                                 nextreg ScreenBankMMU,		a
 154+ 0000              					 ENDM
 155+ 0000
 156+ 0000              MMUSelectSound:      MACRO
 157+ 0000 ~                                 nextreg SoundMMU,		    BankSound
 158+ 0000              					 ENDM
# file closed: ../../Macros/MMUMacros.asm
  36  0000                                      INCLUDE "../../Macros/NegateMacros.asm"
# file opened: ../../Macros/NegateMacros.asm
   1+ 0000
   2+ 0000              macronegate16hl:	MACRO
   3+ 0000 ~            					xor 	a
   4+ 0000 ~            					sub 	l
   5+ 0000 ~            					ld 		l,a
   6+ 0000 ~            					sbc 	a,a
   7+ 0000 ~            					sub 	h
   8+ 0000 ~            					ld 		h,a
   9+ 0000              					ENDM
  10+ 0000
  11+ 0000
  12+ 0000              macroAbsHL:         MACRO
  13+ 0000 ~                                bit     7,h
  14+ 0000 ~                                jp      z,.alreadyABS
  15+ 0000 ~            					xor 	a
  16+ 0000 ~            					sub 	l
  17+ 0000 ~            					ld 		l,a
  18+ 0000 ~            					sbc 	a,a
  19+ 0000 ~            					sub 	h
  20+ 0000 ~            					ld 		h,a
  21+ 0000 ~            .alreadyABS:
  22+ 0000                                  ENDM
  23+ 0000
  24+ 0000              macronegate16de:	MACRO
  25+ 0000 ~            					xor 	a
  26+ 0000 ~                                sub 	e
  27+ 0000 ~                                ld 		e,a
  28+ 0000 ~                                sbc 	a,a
  29+ 0000 ~                                sub 	d
  30+ 0000 ~                                ld 		d,a
  31+ 0000              					ENDM
  32+ 0000
  33+ 0000              macronegate16bc:	MACRO
  34+ 0000 ~            					xor 	a
  35+ 0000 ~                                sub 	c
  36+ 0000 ~                                ld 		c,a
  37+ 0000 ~                                sbc 	a,a
  38+ 0000 ~                                sub 	b
  39+ 0000 ~                                ld 		b,a
  40+ 0000              					ENDM
  41+ 0000
  42+ 0000              macronegate16ix:	MACRO
  43+ 0000 ~            					xor 	a
  44+ 0000 ~                                sub 	ixl
  45+ 0000 ~                                ld 		ixl,a
  46+ 0000 ~                                sbc 	a,a
  47+ 0000 ~                                sub 	ixh
  48+ 0000 ~                                ld 		ixh,a
  49+ 0000              					ENDM
  50+ 0000
  51+ 0000
  52+ 0000              NegIY:			    MACRO
  53+ 0000 ~                                xor a
  54+ 0000 ~                                sub iyl
  55+ 0000 ~                                ld iyl,a
  56+ 0000 ~                                sbc a,a
  57+ 0000 ~                                sub iyh
  58+ 0000 ~                                ld iyh,a
  59+ 0000                                  ENDM
  60+ 0000
  61+ 0000              NegHL:			    MACRO
  62+ 0000 ~                                xor a
  63+ 0000 ~                                sub l
  64+ 0000 ~                                ld l,a
  65+ 0000 ~                                sbc a,a
  66+ 0000 ~                                sub h
  67+ 0000 ~                                ld h,a
  68+ 0000                                  ENDM
  69+ 0000
  70+ 0000              NegDE:			    MACRO
  71+ 0000 ~                                xor a
  72+ 0000 ~                                sub e
  73+ 0000 ~                                ld e,a
  74+ 0000 ~                                sbc a,a
  75+ 0000 ~                                sub d
  76+ 0000 ~                                ld d,a
  77+ 0000                                  ENDM
  78+ 0000
  79+ 0000              NegBC:			    MACRO
  80+ 0000 ~                                xor a
  81+ 0000 ~                                sub c
  82+ 0000 ~                                ld c,a
  83+ 0000 ~                                sbc a,a
  84+ 0000 ~                                sub  b
  85+ 0000 ~                                ld b,a
  86+ 0000                                  ENDM
  87+ 0000
  88+ 0000              NegH                MACRO
  89+ 0000 ~                                ld      a,h
  90+ 0000 ~                                neg
  91+ 0000 ~                                ld      h,a
  92+ 0000                                  ENDM
  93+ 0000
  94+ 0000              NegD                MACRO
  95+ 0000 ~                                ld      a,d
  96+ 0000 ~                                neg
  97+ 0000 ~                                ld      d,a
  98+ 0000                                  ENDM
  99+ 0000
 100+ 0000              NegB                MACRO
 101+ 0000 ~                                ld      a,b
 102+ 0000 ~                                neg
 103+ 0000 ~                                ld      b,a
 104+ 0000                                  ENDM
 105+ 0000
# file closed: ../../Macros/NegateMacros.asm
  37  0000                                      INCLUDE "../../Macros/returnMacros.asm"
# file opened: ../../Macros/returnMacros.asm
   1+ 0000              ReturnIfHLNegative:     MACRO   target
   2+ 0000 ~                                    bit     7,h
   3+ 0000 ~                                    ret     nz
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              ReturnIfDENegative:     MACRO   target
   7+ 0000 ~                                    bit     7,d
   8+ 0000 ~                                    ret     nz
   9+ 0000                                      ENDM
  10+ 0000
  11+ 0000              ReturnOnBitSet:         MACRO  reg, bitnbr
  12+ 0000 ~                                    bit 	bitnbr,reg
  13+ 0000 ~                                    ret     nz
  14+ 0000                                      ENDM
  15+ 0000
  16+ 0000              ReturnOnMemBitSet:      MACRO mem, bitnbr
  17+ 0000 ~                                    ld   a,(mem)
  18+ 0000 ~                                    bit 	bitnbr,a
  19+ 0000 ~                                    ret     nz
  20+ 0000                                      ENDM
  21+ 0000
  22+ 0000              ReturnOnBitClear:       MACRO reg, bitnbr
  23+ 0000 ~                                    bit 	bitnbr,reg
  24+ 0000 ~                                    ret		z
  25+ 0000                                      ENDM
  26+ 0000
  27+ 0000              ReturnOnMemBitClear:    MACRO mem, bitnbr
  28+ 0000 ~                                    ld     a,(mem)
  29+ 0000 ~                                    bit 	bitnbr,a
  30+ 0000 ~                                    ret		z
  31+ 0000                                      ENDM
  32+ 0000
  33+ 0000              ReturnIfMemFalse:       MACRO   mem
  34+ 0000 ~                                    ld      a,(mem)
  35+ 0000 ~                                    and     a
  36+ 0000 ~                                    ret     nz
  37+ 0000                                      ENDM
  38+ 0000
  39+ 0000              ReturnIfMemTrue:        MACRO   mem
  40+ 0000 ~                                    ld      a,(mem)
  41+ 0000 ~                                    and     a
  42+ 0000 ~                                    ret     z
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              ReturnIfAIsZero:        MACRO
  46+ 0000 ~                                    and     a
  47+ 0000 ~                                    ret     z
  48+ 0000                                      ENDM
  49+ 0000
  50+ 0000              ReturnIfMemisZero:      MACRO mem
  51+ 0000 ~                                    ld   a,(mem)
  52+ 0000 ~                                    and a
  53+ 0000 ~                                    ret    z
  54+ 0000                                      ENDM
  55+ 0000
  56+ 0000              ReturnIfMemIsNegative:  MACRO mem
  57+ 0000 ~                                    ld      a,(mem)
  58+ 0000 ~                                    and     $80
  59+ 0000 ~                                    ret     nz
  60+ 0000                                      ENDM
  61+ 0000
  62+ 0000              ReturnIfBitMaskClear    MACRO   bitmask
  63+ 0000 ~                                    and     bitmask
  64+ 0000 ~                                    ret     z
  65+ 0000                                      ENDM
  66+ 0000
  67+ 0000              ReturnIfBitMaskSet      MACRO   bitmask
  68+ 0000 ~                                    and     bitmask
  69+ 0000 ~                                    ret     nz
  70+ 0000                                      ENDM
  71+ 0000
  72+ 0000              ReturnIfMemEquN:        MACRO mem, value
  73+ 0000 ~                                    ld     a,(mem)
  74+ 0000 ~                                    cp     value
  75+ 0000 ~                                    ret    nz
  76+ 0000                                      ENDM
  77+ 0000
  78+ 0000              ReturnIfMemNeNusng:     MACRO mem, value
  79+ 0000 ~                                    ld   a,(mem)
  80+ 0000 ~                                    cp     value
  81+ 0000 ~                                    ret    z
  82+ 0000                                      ENDM
  83+ 0000
  84+ 0000              ReturnIfRegNotZero:     MACRO reg
  85+ 0000 ~                                    ld      a, reg
  86+ 0000 ~                                    and     a
  87+ 0000 ~                                    ret     nz
  88+ 0000                                      ENDM
  89+ 0000
  90+ 0000              ReturnIfANotZero:       MACRO
  91+ 0000 ~                                    and     a
  92+ 0000 ~                                    ret     nz
  93+ 0000                                      ENDM
  94+ 0000
  95+ 0000              ReturnIfNotZero:        MACRO
  96+ 0000 ~                                    ret     nz
  97+ 0000                                      ENDM
  98+ 0000
  99+ 0000              ReturnIfZero:           MACRO
 100+ 0000 ~                                    ret     z
 101+ 0000                                      ENDM
 102+ 0000
 103+ 0000              ReturnIfNegative:       MACRO
 104+ 0000 ~                                    ret     m
 105+ 0000                                      ENDM
 106+ 0000
 107+ 0000
 108+ 0000              ReturnIfMemNotZero:     MACRO mem
 109+ 0000 ~                                    ld     a,(mem)
 110+ 0000 ~                                    and     a
 111+ 0000 ~                                    ret    nz
 112+ 0000                                      ENDM
 113+ 0000
 114+ 0000              ReturnIfAGTEusng:       MACRO value
 115+ 0000 ~                                    cp    value
 116+ 0000 ~                                    ret	 nc
 117+ 0000                                      ENDM
 118+ 0000
 119+ 0000              ReturnIfRegLTNusng:     MACRO reg, value
 120+ 0000 ~                                    ld      a,reg
 121+ 0000 ~                                    cp      value
 122+ 0000 ~                                    ret	    c
 123+ 0000                                      ENDM
 124+ 0000
 125+ 0000              ReturnIfALTNusng:       MACRO value
 126+ 0000 ~                                    cp    value
 127+ 0000 ~                                    ret	 c
 128+ 0000                                      ENDM
 129+ 0000
 130+ 0000              ReturnIfAGTENusng:      MACRO value
 131+ 0000 ~                                    cp    value
 132+ 0000 ~                                    ret	 nc
 133+ 0000                                      ENDM
 134+ 0000
 135+ 0000              ReturnIfAGTEMemusng:    MACRO value
 136+ 0000 ~                                    ld      hl,value
 137+ 0000 ~                                    cp      (hl)
 138+ 0000 ~                                    ret	    nc
 139+ 0000                                      ENDM
 140+ 0000
 141+ 0000              ReturnIfANENusng:       MACRO value
 142+ 0000 ~                                    cp      value
 143+ 0000 ~                                    ret     nz
 144+ 0000                                      ENDM
 145+ 0000
 146+ 0000              ReturnIfAEqNusng:       MACRO value
 147+ 0000 ~                                    cp      value
 148+ 0000 ~                                    ret     z
 149+ 0000                                      ENDM
 150+ 0000
# file closed: ../../Macros/returnMacros.asm
  38  0000                                      INCLUDE "../../Macros/ShiftMacros.asm"
# file opened: ../../Macros/ShiftMacros.asm
   1+ 0000              ShiftIYRight1: MACRO
   2+ 0000 ~            			   ld 	a,iyh
   3+ 0000 ~            			   srl 	a
   4+ 0000 ~            			   ld	iyh,a
   5+ 0000 ~            			   ld 	a,iyl
   6+ 0000 ~            			   rra
   7+ 0000 ~            			   ld	iyl,a
   8+ 0000              			   ENDM
   9+ 0000
  10+ 0000              ShiftIXRight1: MACRO
  11+ 0000 ~            			   ld 	a,ixh
  12+ 0000 ~            			   srl 	a
  13+ 0000 ~            			   ld	ixh,a
  14+ 0000 ~            			   ld 	a,ixl
  15+ 0000 ~            			   rra
  16+ 0000 ~            			   ld	ixl,a
  17+ 0000              			   ENDM
  18+ 0000
  19+ 0000              ShiftHLRight1: MACRO
  20+ 0000 ~            			   srl h
  21+ 0000 ~            			   rr  l
  22+ 0000              			   ENDM
  23+ 0000
  24+ 0000              ShiftDERight1: MACRO
  25+ 0000 ~            			   srl d
  26+ 0000 ~            			   rr  e
  27+ 0000              			   ENDM
  28+ 0000
  29+ 0000              ShiftBCRight1: MACRO
  30+ 0000 ~            			   srl b
  31+ 0000 ~            			   rr  c
  32+ 0000              			   ENDM
  33+ 0000
  34+ 0000
  35+ 0000
  36+ 0000              ShiftHLDiv8:   MACRO
  37+ 0000 ~            			   srl h
  38+ 0000 ~            			   rr  l
  39+ 0000 ~            			   srl h
  40+ 0000 ~            			   rr  l
  41+ 0000 ~            			   srl h
  42+ 0000 ~            			   rr  l
  43+ 0000              			   ENDM
  44+ 0000
  45+ 0000              ShiftHLLeft1:  MACRO    ; 16 T states
  46+ 0000 ~            			   sla l
  47+ 0000 ~            			   rl  h
  48+ 0000              			   ENDM
  49+ 0000
  50+ 0000              ShiftDELeft1:  MACRO    ; 16 T states
  51+ 0000 ~            			   sla e
  52+ 0000 ~            			   rl  d
  53+ 0000              			   ENDM
  54+ 0000
  55+ 0000              BarrelHLLeft3: MACRO
  56+ 0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
  57+ 0000 ~                           push     bc      ; 10
  58+ 0000 ~                           ld       b,3     ; 7
  59+ 0000 ~                           bsrl     de,b    ; 8
  60+ 0000 ~                           pop      bc      ; 10
  61+ 0000 ~                           ex       de,hl   ; 4
  62+ 0000                             ENDM
  63+ 0000
  64+ 0000              BarrelHLRight3: MACRO
  65+ 0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
  66+ 0000 ~                           push     bc      ; 10
  67+ 0000 ~                           ld       b,3     ; 7
  68+ 0000 ~                           bsrl     de,b    ; 8
  69+ 0000 ~                           pop      bc      ; 10
  70+ 0000 ~                           ex       de,hl   ; 4
  71+ 0000                             ENDM
  72+ 0000
  73+ 0000              RollBCLeft1:   MACRO	; 16 T states
  74+ 0000 ~                           rl  c
  75+ 0000 ~                           rl  b
  76+ 0000                             ENDM
  77+ 0000
  78+ 0000              RollDELeft1:   MACRO	; 16 T states
  79+ 0000 ~                           rl  e
  80+ 0000 ~                           rl  d
  81+ 0000                             ENDM
  82+ 0000
  83+ 0000              ShiftBCLeft1:  MACRO    ; 16 T states
  84+ 0000 ~            			   sla c
  85+ 0000 ~            			   rl  b
  86+ 0000              			   ENDM
  87+ 0000
  88+ 0000              ShiftLeftMem:       MACRO   reg
  89+ 0000 ~                                ld      hl,reg
  90+ 0000 ~                                sla     (hl)
  91+ 0000                                  ENDM
  92+ 0000
  93+ 0000
  94+ 0000
  95+ 0000              ShiftMem16Right1:   MACRO memaddr
  96+ 0000 ~                                ld    hl,(memaddr)
  97+ 0000 ~                                srl   h
  98+ 0000 ~                                rr    l
  99+ 0000 ~                                ld    (memaddr),hl
 100+ 0000                                  ENDM
 101+ 0000
 102+ 0000              ShiftMem8Right1:    MACRO memaddr
 103+ 0000 ~                                ld      a,(memaddr)
 104+ 0000 ~                                srl     a
 105+ 0000 ~                                ld      (memaddr),a
 106+ 0000                                  ENDM
 107+ 0000
 108+ 0000
 109+ 0000              ShiftMem8Left1A:    MACRO memaddr
 110+ 0000 ~                                ld      a,(memaddr)
 111+ 0000 ~                                sla     a
 112+ 0000 ~                                ld      (memaddr),a
 113+ 0000                                  ENDM
 114+ 0000
# file closed: ../../Macros/ShiftMacros.asm
  39  0000                                      INCLUDE "../../Macros/signBitMacros.asm"
# file opened: ../../Macros/signBitMacros.asm
   1+ 0000              SetMemBitN              MACRO mem,bitnbr
   2+ 0000 ~                                    ld      hl,mem
   3+ 0000 ~                                    set     bitnbr,(hl)
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              ClearMemBitN            MACRO mem,bitnbr
   7+ 0000 ~                                    ld      hl,mem
   8+ 0000 ~                                    res     bitnbr,(hl)
   9+ 0000                                      ENDM
  10+ 0000
  11+ 0000
  12+ 0000              ClearSignBitMem:        MACRO mem
  13+ 0000 ~                                    ld      a,(mem)
  14+ 0000 ~                                    and     SignMask8Bit
  15+ 0000 ~                                    ld      (mem),a
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              SetSignBitMem:          MACRO   mem
  19+ 0000 ~                                    ld      a,(mem)
  20+ 0000 ~                                    or      SignOnly8Bit
  21+ 0000 ~                                    ld      (mem),a
  22+ 0000                                      ENDM
  23+ 0000
  24+ 0000              FlipSignMem:            MACRO mem
  25+ 0000 ~                                    ld  a,(mem)
  26+ 0000 ~                                    xor SignOnly8Bit
  27+ 0000 ~                                    ld  (mem),a
  28+ 0000                                      ENDM
  29+ 0000
  30+ 0000              SignBitOnlyMem:         MACRO mem
  31+ 0000 ~                                    ld      a, (mem)
  32+ 0000 ~                                    and     SignOnly8Bit
  33+ 0000 ~                                    ld      (mem),a
  34+ 0000                                      ENDM
  35+ 0000
  36+ 0000              ClearSignBit:           MACRO reg
  37+ 0000 ~                                    ld      a,reg
  38+ 0000 ~                                    and     SignMask8Bit
  39+ 0000 ~                                    ld      reg,a
  40+ 0000                                      ENDM
  41+ 0000
  42+ 0000              SetSignBit:             MACRO   reg
  43+ 0000 ~                                    ld      a,reg
  44+ 0000 ~                                    or      SignOnly8Bit
  45+ 0000 ~                                    ld      reg,a
  46+ 0000                                      ENDM
  47+ 0000
  48+ 0000              FlipSignBit:            MACRO   reg
  49+ 0000 ~                                    ld      a, reg
  50+ 0000 ~                                    xor     SignOnly8Bit
  51+ 0000 ~                                    ld      reg,a
  52+ 0000                                      ENDM
  53+ 0000
  54+ 0000              SignBitOnly:            MACRO   reg
  55+ 0000 ~                                    ld      a, reg
  56+ 0000 ~                                    and     SignOnly8Bit
  57+ 0000 ~                                    ld      reg,a
  58+ 0000                                      ENDM
  59+ 0000
  60+ 0000              ClearSignBitA:          MACRO
  61+ 0000 ~                                    and     SignMask8Bit
  62+ 0000                                      ENDM
  63+ 0000
  64+ 0000              SetSignBitA:            MACRO
  65+ 0000 ~                                    or      SignOnly8Bit
  66+ 0000                                      ENDM
  67+ 0000
  68+ 0000              FlipSignBitA:           MACRO
  69+ 0000 ~                                    xor     SignOnly8Bit
  70+ 0000                                      ENDM
  71+ 0000
  72+ 0000              SignBitOnlyA:           MACRO
  73+ 0000 ~                                    and     SignOnly8Bit
  74+ 0000                                      ENDM
# file closed: ../../Macros/signBitMacros.asm
  40  0000                                      INCLUDE "../../Macros/KeyboardMacros.asm"
# file opened: ../../Macros/KeyboardMacros.asm
   1+ 0000              MacroIsKeyPressed:      MACRO C_Pressed_keycode
   2+ 0000 ~                                    ld      a,C_Pressed_keycode
   3+ 0000 ~                                    MMUSelectKeyboard
   4+ 0000 ~                                    call    is_key_pressed
   5+ 0000                                      ENDM
   6+ 0000
   7+ 0000              MacroInitkeyboard:      MACRO
   8+ 0000 ~                                    MMUSelectKeyboard
   9+ 0000 ~                                    call    init_keyboard
  10+ 0000                                      ENDM
  11+ 0000
# file closed: ../../Macros/KeyboardMacros.asm
  41  0000                                      INCLUDE "../../Universe/UniverseMacros/asm_linedraw.asm"
# file opened: ../../Universe/UniverseMacros/asm_linedraw.asm
   1+ 0000              ClippingVarsMacro:   MACRO   prefix1?
   2+ 0000 ~            ;-- Clipping code for universe objects -------------------------------------------
   3+ 0000 ~            prefix1?_XX13        DB 0
   4+ 0000 ~
   5+ 0000 ~
   6+ 0000 ~            prefix1?_varK3		 DS	4				; D2
   7+ 0000 ~            prefix1?_centreX     equ prefix1?_varK3
   8+ 0000 ~            prefix1?_varK3p2	 DB	0				; 42
   9+ 0000 ~            prefix1?_varK3p3	 DB	0				; 43
  10+ 0000 ~            prefix1?_varK3p1	 equ prefix1?_varK3+1			; D3
  11+ 0000 ~            prefix1?_varK4		 DS	4				; E0
  12+ 0000 ~            prefix1?_centreY     equ prefix1?_varK4
  13+ 0000 ~            prefix1?_varK4p1	 equ prefix1?_varK4+1			; D3
  14+ 0000 ~            prefix1?_varK5       DS  6
  15+ 0000 ~            prefix1?_varK5p2     equ prefix1?_varK5+2
  16+ 0000 ~            prefix1?_varK6       DS  6
  17+ 0000 ~            prefix1?_varK6p2     equ prefix1?_varK6+2
  18+ 0000 ~
  19+ 0000 ~            prefix1?_XX12p2      DB 0    ; The line's gradient * 256 (so 1.0 = 256)
  20+ 0000 ~            prefix1?_XX12p3      DB 0    ; The direction of slope ; + LT to BR; - TR to BL
  21+ 0000 ~            prefix1?_XX12p4      DB 0
  22+ 0000 ~            prefix1?_XX12p5      DB 0
  23+ 0000 ~            prefix1?_Delta_x     EQU prefix1?_XX12p2
  24+ 0000 ~            prefix1?_Delta_y     EQU prefix1?_XX12p4
  25+ 0000 ~            prefix1?_Tvar        DB 0    ; The gradient of slope ; 0 if it's a shallow slope (DX > DY) ; &FF if it's a steep slope (DY > DX) Returns:  XX15        m         x1 as an 8-bit coordinate XX15+2               y1 as an 8-bit coordinate
  26+ 0000 ~            prefix1?_Qvar        DB 0
  27+ 0000 ~            prefix1?_Rvar        DB 0    ; general purpose for calcs  Paired with S must be done this way round for SUBHeightFromY1 etc to work
  28+ 0000 ~            prefix1?_Svar        DB 0    ; sign variable
  29+ 0000 ~            prefix1?_SRvarPair   EQU prefix1?_Rvar
  30+ 0000 ~            prefix1?_Xreg        DB 0
  31+ 0000 ~            prefix1?_Yreg        DB 0
  32+ 0000 ~            prefix1?_YXregPair   EQU prefix1?_Xreg
  33+ 0000                                   ENDM
  34+ 0000
  35+ 0000              ;-- Name: LL28 Calculate R = 256 * A / Q
  36+ 0000              ;-- LL28+4              Skips the A >= Q check and always returns with C flag cleared, so this can be called if we know the division will work
  37+ 0000              ;-- LL31                Skips the A >= Q check and does not set the R counter, so this can be used for jumping straight into the division loop if R is already set to 254 and we know the division will work
  38+ 0000              ;   Reg mapping 6502  Z80
  39+ 0000              ;               a     a
  40+ 0000              ;               b     x
  41+ 0000              ;               c     q
  42+ 0000              ;               d     r
  43+ 0000              ;
  44+ 0000              ClippingCodeLL28Macro:      MACRO   prefix1?
  45+ 0000 ~            prefix1?_LL28_6502:         ld      hl,Qvar                 ; CMP Q                  \ If A >= Q, then the answer will not fit in one byte,
  46+ 0000 ~                                        ld      c,(hl)                  ; using c as Q var
  47+ 0000 ~                                        cp      c
  48+ 0000 ~                                        FlipCarryFlag
  49+ 0000 ~                                        jp      c, prefix1?_LL2_6502    ; BCS LL2                \ so jump to LL2 to return 255
  50+ 0000 ~                                        ld      b,$FE                   ; LDX #%11111110         \ Set R to have bits 1-7 set, so we can rotate through 7 loop iterations, getting a 1 each time, and then we use b as Rvar
  51+ 0000 ~            prefix1?_LL31_6502:          sla     a                       ; ASL A                  \ Shift A to the left
  52+ 0000 ~                                        jp      c, prefix1?_LL29_6502             ; BCS LL29               \ If bit 7 of A was set, then jump straight to the subtraction
  53+ 0000 ~                                        FlipCarryFlag                   ;                          If A < N, then C flag is set.
  54+ 0000 ~                                        JumpIfALTNusng c, prefix1?_LL31_SKIPSUB_6502 ; CMP Q              \ If A < Q, skip the following subtraction
  55+ 0000 ~                                                                            ; BCC P%+4
  56+ 0000 ~                                        sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  57+ 0000 ~                                        ClearCarryFlag
  58+ 0000 ~            prefix1?_LL31_SKIPSUB_6502:  FlipCarryFlag
  59+ 0000 ~                                        rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  60+ 0000 ~                                        jp      c, prefix1?_LL31_6502            ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  61+ 0000 ~                                        ld      a,b
  62+ 0000 ~                                        ld      (Rvar),a
  63+ 0000 ~                                        ret                             ; RTS                    \ R left with remainder of division
  64+ 0000 ~            prefix1?_LL29_6502:          sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  65+ 0000 ~                                        SetCarryFlag                    ; SEC                    \ Set the C flag to rotate into the result in R
  66+ 0000 ~                                        rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  67+ 0000 ~                                        jp      c, prefix1?_LL31_6502            ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  68+ 0000 ~                                        ld      a,b                     ; RTS                    \ Return from the subroutine with R containing the
  69+ 0000 ~                                        ld      (Rvar),a                ; .
  70+ 0000 ~                                        ret                             ; .                      \ remainder of the division
  71+ 0000 ~            prefix1?_LL2_6502:          ld      a,$FF                   ; LDA #255               \ The division is very close to 1, so return the closest
  72+ 0000 ~                                        ld      (Rvar),a                ; STA R                  \ possible answer to 256, i.e. R = 255
  73+ 0000 ~                                        SetCarryFlag                    ; we failed so need carry flag set
  74+ 0000 ~                                        ret                             ; RTS                    \ Return from the subroutine
  75+ 0000 ~
  76+ 0000 ~            prefix1?_ADDXRegtoY1:       ld      a,(Xreg)                ; Set y1 = y1 + (Y X)
  77+ 0000 ~                                        ld      c,a
  78+ 0000 ~                                        ld      b,0
  79+ 0000 ~                                        ld      hl,(prefix1?_XX1532)
  80+ 0000 ~                                        ClearCarryFlag
  81+ 0000 ~                                        adc     hl,bc
  82+ 0000 ~                                        ld      (prefix1?_XX1532),hl
  83+ 0000 ~                                        ret
  84+ 0000 ~
  85+ 0000 ~            prefix1?_ADDYXRegtoY1:      ld      bc,(YXregPair)          ; Set y1 = y1 + (Y X)
  86+ 0000 ~                                        ld      hl,(prefix1?_XX1532)
  87+ 0000 ~                                        ClearCarryFlag
  88+ 0000 ~                                        adc     hl,bc
  89+ 0000 ~                                        ld      (prefix1?_XX1532),hl
  90+ 0000 ~                                        ret
  91+ 0000 ~
  92+ 0000 ~            prefix1?_ADDYXRegtoX1:      ld      bc,(YXregPair)          ; Set x1 = x1 + (Y X)
  93+ 0000 ~                                        ld      hl,(prefix1?_XX1510)
  94+ 0000 ~                                        ClearCarryFlag
  95+ 0000 ~                                        adc     hl,bc
  96+ 0000 ~                                        ld      (prefix1?_XX1510),hl
  97+ 0000 ~                                        ret
  98+ 0000 ~
  99+ 0000 ~            prefix1?_SUBBCFromY1:       ld      hl,(prefix1?_XX1532)             ; Set (S R) = (y1_hi y1_lo) - BC where BC can be say screen height
 100+ 0000 ~                                        ClearCarryFlag
 101+ 0000 ~                                        sbc     hl,bc
 102+ 0000 ~                                        ld      (SRvarPair),hl
 103+ 0000 ~                                        ret
 104+ 0000 ~
 105+ 0000 ~            prefix1?_AddSRToYX:         ld      hl,(YXregPair)
 106+ 0000 ~                                        ld      de,(SRvarPair)
 107+ 0000 ~                                        ClearCarryFlag
 108+ 0000 ~                                        adc     hl,de
 109+ 0000 ~                                        ld      (YXregPair),hl
 110+ 0000 ~                                        ret
 111+ 0000 ~
 112+ 0000 ~            prefix1?_ClampX:            ld      a,h
 113+ 0000 ~                                        and     a
 114+ 0000 ~                                        ld      a,l
 115+ 0000 ~                                        ret     z
 116+ 0000 ~                                        jp      p,.Max255
 117+ 0000 ~            .ClampXMin0:                ZeroA
 118+ 0000 ~                                        ret
 119+ 0000 ~            .Max255:                    ld      a,$FF
 120+ 0000 ~                                        ret
 121+ 0000 ~
 122+ 0000 ~            prefix1?_ClampY:            ld      a,h
 123+ 0000 ~                                        and     a
 124+ 0000 ~                                        jp      z,.ClampYlo
 125+ 0000 ~                                        jp      p,.Max127
 126+ 0000 ~            .ClampYMin0:                ZeroA
 127+ 0000 ~                                        ret
 128+ 0000 ~            .Max127:                    ld      a,127
 129+ 0000 ~                                        ret
 130+ 0000 ~            .ClampYlo:                  ld      a,l
 131+ 0000 ~                                        and     a
 132+ 0000 ~                                        ret     p
 133+ 0000 ~                                        ld      a,127
 134+ 0000 ~                                        ret
 135+ 0000                                          ENDM
 136+ 0000              ;-- Rountes to code:
 137+ 0000              ;-- LL118
 138+ 0000              ;-- LL120   Done
 139+ 0000              ;-- LL129   Done
 140+ 0000              ;-- LL123   Done
 141+ 0000                             ; NOTE DOES ABS ONLY
 142+ 0000
 143+ 0000
 144+ 0000                              ;--- LL118 Move along a point until on screen
 145+ 0000              ; In XX1510 x1 as a 16-bit coordinate (x1_hi x1_lo)
 146+ 0000              ;    XX1532 y1 as a 16-bit coordinate (y1_hi y1_lo)
 147+ 0000              ;    XX12p2 The line's gradient * 256 (so 1.0 = 256)
 148+ 0000              ;    XX12p3 The direction of slope: * Positive = top left to bottom right * Negative (bit 7 set) = top right to bottom left
 149+ 0000              ;    T      The gradient of slope:* 0 if it's a shallow slope * &FF if it's a steep slope
 150+ 0000              ;  Out  XX150               x1 as an 8-bit coordinate
 151+ 0000              ;       XX152               y1 as an 8-bit coordinate
 152+ 0000              ;----------------------------------------------------------------------------------------------------------------
 153+ 0000
 154+ 0000
 155+ 0000              ;---------------------------------------------------------------------------------------------------------------------
 156+ 0000              ;--  Calculate the following:
 157+ 0000              ;--   * If T = 0, this is a shallow slope, so calculate (Y X) = (S x1_lo) * XX12+2
 158+ 0000              ;--   * If T <> 0, this is a steep slope, so calculate (Y X) = (S x1_lo) / XX12+2
 159+ 0000              ;-- giving (Y X) the opposite sign to the slope direction in XX12+3.
 160+ 0000              ;---------------------------------------------------------------------------------------------------------------------
 161+ 0000              ClippingCodeLL120Macro:     MACRO   prefix1?
 162+ 0000 ~            prefix1?_LL120_6502:        ld      a,(prefix1?_XX1510)              ;LDA XX15               \ Set R = x1_lo
 163+ 0000 ~                                        ld      (Rvar),a                ;STA R
 164+ 0000 ~                                        call    prefix1?_LL129_6502              ;JSR LL129              \ Call LL129 to do the following:  Q = XX12+2 = line gradient, A = S EOR XX12+3 = S EOR slope direction  (S R) = |S R|
 165+ 0000 ~                                        push    af                      ;PHA                    \ Store A on the stack so we can use it later
 166+ 0000 ~            ; DONT NEED PLUS MESSES UP FLAGS                    push    af                      ;LDX T                  \ If T is non-zero, then it's a steep slope, so jump
 167+ 0000 ~                                        ld      a,(Tvar)                ; .
 168+ 0000 ~                                        ld      (Xreg),a                ;. REDUNDANT REMOVE IN OPTIMISATION
 169+ 0000 ~                                        and     a                       ;BNE LL121              \ down to LL121 to calculate this instead (Y X) = (S R) / Q
 170+ 0000 ~            ; DONT NEED PLUS MESSES UP FLAGS                    pop     af                      ;.                      (recover teh saved A before the cp)
 171+ 0000 ~                                        jr      nz,prefix1?_LL121_6502           ;.
 172+ 0000 ~            ;..   (Y X) = (S R) * Q - must be ABS, sign determined by opposite of the sign of the value on top of stack
 173+ 0000 ~            prefix1?_LL122_6502:         ZeroA                           ;LDA #0                 \ Set A = 0
 174+ 0000 ~
 175+ 0000 ~                                        IFDEF DEBUG_LL122_DIRECT"
 176+ 0000 ~                                              DISPLAY "DIRECT CALL TO LL122 so dummy push a to stack with 0"
 177+ 0000 ~                                              push    af
 178+ 0000 ~                                        ENDIF
 179+ 0000 ~                                        ld      (Xreg),a                ;TAX                    \ Set (Y X) = 0 so we can start building the answer here
 180+ 0000 ~                                        ld      (Yreg),a                ;TAY
 181+ 0000 ~                                        ld      hl,Svar
 182+ 0000 ~                                        ld      bc,(SRvarPair)          ;LSR S                  \ Shift (S R) to the right, so we extract bit 0 of (S R)
 183+ 0000 ~                                        ShiftBCRight1                   ;ROR R                  \ into the C flag
 184+ 0000 ~                                        ld      (SRvarPair),bc
 185+ 0000 ~                                        ld      hl, Qvar                ;ASL Q                  \ Shift Q to the left, catching bit 7 in the C flag
 186+ 0000 ~                                        sla     (hl)                    ;.
 187+ 0000 ~                                        jr      nc, prefix1?_LL126_6502          ;BCC LL126              \ If C (i.e. the next bit from Q) is clear, do not do
 188+ 0000 ~            ; the addition for this bit of Q, and instead skip to LL126 to just do the shifts
 189+ 0000 ~            prefix1?_LL125_6502:        call    AddSRToYX               ;TXA                    \ Set (Y X) = (Y X) + (S R)  starting with the low bytes And then doing the high bytes
 190+ 0000 ~            prefix1?_LL126_6502:        ld      bc,(SRvarPair)          ;LSR S                  \ Shift (S R) to the right
 191+ 0000 ~                                        ShiftBCRight1                   ;ROR R
 192+ 0000 ~                                        ld      (SRvarPair),bc          ;.
 193+ 0000 ~                                        ld      hl, Qvar                ;ASL Q                  \ Shift Q to the left, catching bit 7 in the C flag
 194+ 0000 ~                                        sla     (hl)                    ;.
 195+ 0000 ~                                        jr      c,prefix1?_LL125_6502            ;BCS LL125              \ If C (i.e. the next bit from Q) is set, loop back to LL125 to do the addition for this bit of Q
 196+ 0000 ~                                        jr      nz,prefix1?_LL126_6502           ;BNE LL126              \ If Q has not yet run out of set bits, loop back to LL126 to do the \"shift\" part of shift-and-add until we have done additions for all the set bits in Q, to give us our multiplication result
 197+ 0000 ~                                        pop     af                      ;PLA                    \ Restore A, which we calculated above, from the stack
 198+ 0000 ~                                        and     a                       ;BPL LL133              \ If A is positive jump to LL133 to negate (Y X) and
 199+ 0000 ~                                        jp      p,prefix1?_LL133_6502            ;.
 200+ 0000 ~                                        ;.. return from the subroutine using a tail call
 201+ 0000 ~                                        ret                             ;RTS                    \ Return from the subroutine
 202+ 0000                                  ENDM
 203+ 0000              ;----------------------------------------------------------------------------------------------------------------------------
 204+ 0000              ;-- Calculate the following:
 205+ 0000              ;--         * If T = 0, this is a shallow slope, so calculate (Y X) = (S R) / XX12+2 (does not use X1lo but directly SR)
 206+ 0000              ;--         * If T <> 0, this is a steep slope, so calculate (Y X) = (S R) * XX12+2  (does not use X1lo but directly SR)
 207+ 0000              ;--             giving (Y X) the opposite sign to the slope direction in XX12+3.
 208+ 0000              ClippingCodeLL122Macro:      MACRO   prefix1?
 209+ 0000 ~            prefix1?_LL123_6502:         call    prefix1?_LL129_6502              ;JSR LL129              \ Call LL129 to do the following   Q = XX12+2   = line gradient
 210+ 0000 ~                                         push    af                      ;PHA                    \ Store A on the stack so we can use it later
 211+ 0000 ~            ; DONT NEED PLUS MESSES UP FLAGS                    push    af                      ;LDX T                  \ If T is non-zero, then it's a steep slope, so jump up
 212+ 0000 ~                                         ld      a,(Tvar)                ; .
 213+ 0000 ~                                         ld      (Xreg),a                ;BNE LL122              \ to LL122 to calculate this instead:
 214+ 0000 ~                                         and     a                       ;.
 215+ 0000 ~            ;  DONT NEED PLUS MESSES UP FLAGS                    pop     af                      ;.
 216+ 0000 ~                                         jr      nz,prefix1?_LL122_6502           ;.
 217+ 0000 ~            ;--  The following calculates: (Y X) = (S R) / Q using the same shift-and-subtract algorithm that's documented in TIS2
 218+ 0000 ~            prefix1?_LL121_6502:         ld      a,$FF                   ;LDA #%11111111         \ Set Y = %11111111
 219+ 0000 ~                                         ld      (Yreg),a                ;TAY
 220+ 0000 ~                                         sla     a                       ;ASL A                  \ Set X = %11111110
 221+ 0000 ~                                         ld      (Xreg),a                ;TAX
 222+ 0000 ~            ;--  This sets (Y X) = %1111111111111110, so we can rotate through 15 loop iterations, getting a 1 each time, and then getting a 0 on the 16th iteration... and we can also use it to catch our result bits into bit 0 each time
 223+ 0000 ~            prefix1?_LL130_6502:         ld      bc,(SRvarPair)          ;ASL R                  \ Shift (S R) to the left
 224+ 0000 ~                                        ShiftBCLeft1                    ;.
 225+ 0000 ~                                        ld      (SRvarPair),bc          ;ROL S
 226+ 0000 ~                                        ld      a,(Svar)                ;LDA S                  \ Set A = S
 227+ 0000 ~                                        jr      c, prefix1?_LL131_6502           ;BCS LL131              \ If bit 7 of S was set, then jump straight to the subtraction
 228+ 0000 ~                                        ld      hl,Qvar                 ;CMP Q                  \ If A < Q (i.e. S < Q), skip the following subtractions
 229+ 0000 ~                                        cp      (hl)
 230+ 0000 ~                                        FlipCarryFlag                   ; note flip carry flag here to simulate 6502 operation
 231+ 0000 ~                                        jr      nc,prefix1?_LL132A_6502          ;BCC LL132  (NOTE Carry flag reversed in Z80 for CP)
 232+ 0000 ~            prefix1?_LL131_6502:         FlipCarryFlag                   ;flip carry to make it act like a 6502 borrow
 233+ 0000 ~                                        sbc     (hl)                    ;SBC Q                  \ A >= Q (i.e. S >= Q) so set:
 234+ 0000 ~                                        ld      (Svar),a                ;STA S
 235+ 0000 ~                                        ld      a,(Rvar)                ;LDA R                  \ And then doing the high bytes
 236+ 0000 ~                                        ClearCarryFlag                  ;\   S = (A R) - Q  = (S R) - Q starting with the low bytes (we know the C flag is set so the subtraction will be correct)
 237+ 0000 ~                                        sbc     0                       ;SBC #0
 238+ 0000 ~                                        ld      (Rvar),a                ;STA R
 239+ 0000 ~                                        SetCarryFlag                    ;SEC                    \ Set the C flag to rotate into the result in (Y X)
 240+ 0000 ~                                        jp      prefix1?_LL132_6502              ;added so that we can do a 6502 style carry above
 241+ 0000 ~            prefix1?_LL132A_6502:        nop; FlipCarryFlag
 242+ 0000 ~            prefix1?_LL132_6502:         ld      bc,(YXregPair)          ; Rotate the counter in (Y X) to the left, and catch the
 243+ 0000 ~                                        RollBCLeft1                     ; ROL A                  \ result bit into bit 0 (which will be a 0 if we didn't
 244+ 0000 ~                                        ld      (YXregPair),bc          ; TAX                    \ do the subtraction, or 1 if we did)
 245+ 0000 ~                                        jr      c, prefix1?_LL130_6502           ; BCS LL130              \ If we still have set bits in (Y X), loop back to LL130 to do the next iteration of 15, until we have done the whole division
 246+ 0000 ~                    IFDEF DEBUG_LL121_DIRECT
 247+ 0000 ~                          DISPLAY "DIRECT CALL TO LL121 so dummy push"
 248+ 0000 ~                                        push    af
 249+ 0000 ~                    ENDIF
 250+ 0000 ~                                        pop     af                      ; PLA                    \ Restore A, which we calculated above, from the stack
 251+ 0000 ~                                        and     a                       ; BMI LL128              \ If A is negative jump to LL128 to return from the
 252+ 0000 ~                                        jp      m, prefix1?_LL128_6502           ; .                      \ subroutine with (Y X) as is
 253+ 0000 ~            prefix1?_LL133_6502:          ld      bc,(YXregPair)          ; TXA                    \ Otherwise negate (Y X) using two's complement by first
 254+ 0000 ~                                        macronegate16bc                 ; EOR #%11111111         \ setting the low byte to ~X + 1
 255+ 0000 ~                                        ld      (YXregPair),bc          ; ADC #1                 \ The addition works as we know the C flag is clear from\ when we passed through the BCS above
 256+ 0000 ~            prefix1?_LL128_6502:          ret                             ; RTS                    \ Return from the subroutine
 257+ 0000 ~            ;-------------------------------------------------------------------------------------------------------
 258+ 0000 ~            ;..  Do the following, in this order: Q = XX12+2 A = S EOR XX12+3 (S R) = |S R|
 259+ 0000 ~            ;..  This sets up the variables required above to calculate (S R) / XX12+2 and give the result the opposite sign to XX13+3.
 260+ 0000 ~            prefix1?_LL129_6502:        push    af                      ;LDX XX12+2             \ Set Q = XX12+2
 261+ 0000 ~                                        ld      a,(prefix1?_XX12p2)              ;.
 262+ 0000 ~                                        ld      (Xreg),a                ;.
 263+ 0000 ~                                        ld      (Qvar),a                ;STX Q
 264+ 0000 ~                                        pop     af                      ;.
 265+ 0000 ~                                        ld      a,(Svar)                ;LDA S                  \ If S is positive, jump to LL127
 266+ 0000 ~                                        and     a                       ;BPL LL127
 267+ 0000 ~                                        jp      p,prefix1?_LL127_6502            ;.
 268+ 0000 ~                                        ZeroA                           ;.LDA #0                \ Otherwise set R = -R
 269+ 0000 ~                                        ClearCarryFlag                  ;SEC
 270+ 0000 ~                                        ld      hl, Rvar                ;SBC R
 271+ 0000 ~                                        sbc     (hl)                    ;.
 272+ 0000 ~                                        ld      (Rvar),a                ;STA R
 273+ 0000 ~                                        ld      a,(Svar)                ;LDA S                  \ Push S onto the stack
 274+ 0000 ~                                        push    af                      ;PHA
 275+ 0000 ~                                        xor     $FF                     ;EOR #%11111111         \ Set S = ~S + 1 + C  ?? is this all just doing |Svar|?
 276+ 0000 ~                                        adc     0                       ;ADC #0
 277+ 0000 ~                                        ld      (Svar),a                ;STA S
 278+ 0000 ~                                        pop     af                      ;PLA                    \ Pull the original, negative S from the stack into A
 279+ 0000 ~            prefix1?_LL127_6502:        ld      hl,prefix1?_XX12p3               ;EOR XX12+3             \ Set A = original argument S EOR'd with XX12+3
 280+ 0000 ~                                        xor     (hl)                    ;.
 281+ 0000 ~                                        ret                             ;RTS                    \ Return from the subroutine
 282+ 0000 ~            ;----------------------------------------------------------------------------------------------------------------
 283+ 0000 ~            ;--- LL118 Move along a point until on screen
 284+ 0000 ~            ; In XX1510 x1 as a 16-bit coordinate (x1_hi x1_lo)
 285+ 0000 ~            ;    XX1532 y1 as a 16-bit coordinate (y1_hi y1_lo)
 286+ 0000 ~            ;    XX12p2 The line's gradient * 256 (so 1.0 = 256)
 287+ 0000 ~            ;    XX12p3 The direction of slope: * Positive = top left to bottom right * Negative (bit 7 set) = top right to bottom left
 288+ 0000 ~            ;    T      The gradient of slope:* 0 if it's a shallow slope * &FF if it's a steep slope
 289+ 0000 ~            ;  Out  XX150               x1 as an 8-bit coordinate
 290+ 0000 ~            ;       XX152               y1 as an 8-bit coordinate
 291+ 0000 ~            ;----------------------------------------------------------------------------------------------------------------
 292+ 0000 ~
 293+ 0000 ~            prefix1?_LL118_6502:         ld      a,(prefix1?_XX1510+1)            ; LDA XX15+1             \ If x1_hi is positive, jump down to LL119 to skip the
 294+ 0000 ~                                        and     a                       ; BPL LL119              \ .
 295+ 0000 ~                                        jp      p, prefix1?_LL119_6502           ;                        \ following
 296+ 0000 ~            .X1Negative:                ld      (Svar),a                ; STA S                  \ Otherwise x1_hi is negative, i.e. off the left of the screen, so set S = x1_hi
 297+ 0000 ~                                        call    prefix1?_LL120_6502              ; Call LL120 to calculate:  (Y X) = (S x1_lo) * XX12+2      if T = 0   = x1 * gradient
 298+ 0000 ~                                                                ;                            (Y X) = (S x1_lo) / XX12+2      if T <> 0  = x1 / gradient
 299+ 0000 ~                                                                ; with the sign of (Y X) set to the opposite of the line's direction of slope
 300+ 0000 ~                                        call    ADDYXRegtoY1             ; Set y1 = y1 + (Y X)
 301+ 0000 ~                                        ld      (prefix1?_XX1532),hl             ; .
 302+ 0000 ~                                        ld      hl,0                    ; Set x1 = 0
 303+ 0000 ~                                        ld      (prefix1?_XX1510),hl             ; .
 304+ 0000 ~                                        ld      a,0                     ; set 0 up for replacemetn of the TAX and BEQ bit
 305+ 0000 ~                                        ld      (Xreg),a                ; TAX                    \ Set X = 0 so the next BEQ becomes a jmp but we will do it anyway in next line
 306+ 0000 ~                                        jp      prefix1?_LL134_6502              ; just do the jump to LL134 rather than setting to equal flag and then jumping
 307+ 0000 ~            ;-- Entering LL119 a will always be the value of X1 Hi byte
 308+ 0000 ~            prefix1?_LL119_6502:         jp      z,prefix1?_LL134_6502            ; BEQ LL134              \ x1_hi = 0 then jump down to LL134 to skip the following, as the x-coordinate is already on-screen
 309+ 0000 ~                                                                        ;                        \ (as 0 <= (x_hi x_lo) <= 255)
 310+ 0000 ~                                        ld      (Svar),a                ; STA S                  \ Otherwise x1_hi is positive, i.e. x1 >= 256 and off
 311+ 0000 ~                                        dec     a                       ; DEC S                  \ the right side of the screen, so set S = x1_hi - 1
 312+ 0000 ~                                        ld      (Svar),a                ;
 313+ 0000 ~                                        call    prefix1?_LL120_6502              ; JSR LL120              \ Call LL120 to calculate:  (Y X) = (S x1_lo) * XX12+2      if T = 0   = (x1 - 256) * gradient
 314+ 0000 ~                                                                        ;                        \                           (Y X) = (S x1_lo) / XX12+2      if T <> 0 = (x1 - 256) / gradient
 315+ 0000 ~                                                                        ;                        \ with the sign of (Y X) set to the opposite of the line's direction of slope
 316+ 0000 ~                                        call    ADDYXRegtoY1             ; TXA                    \ Set y1 = y1 + (Y X)
 317+ 0000 ~                                        ld      hl,255                  ; LDX #255               \ Set x1 = 255
 318+ 0000 ~                                        ld      ( prefix1?_XX1510 ),hl             ; STX XX15 ;INX; STX XX15+1
 319+ 0000 ~            ;--  We have moved the point so the x-coordinate is on  screen (i.e. in the range 0-255), so now for the  y-coordinate
 320+ 0000 ~            prefix1?_LL134_6502:        ld      a,(prefix1?_XX1532+1)            ; LDA XX15+3             \ If y1_hi is positive, jump down to LL119 to skip
 321+ 0000 ~                                        and     a                       ; BPL LL135              \ the following
 322+ 0000 ~                                        jp      p, prefix1?_LL135_6502           ; .
 323+ 0000 ~                                        ld      (Svar),a                ; STA S                  \ Otherwise y1_hi is negative, i.e. off the top of the screen, so set S = y1_hi
 324+ 0000 ~                                        ld      a, ( prefix1?_XX1532)             ; LDA XX15+2             \ Set R = y1_lo
 325+ 0000 ~                                        ld      (Rvar),a                ; STA R
 326+ 0000 ~                                        call    prefix1?_LL123_6502              ; JSR LL123              \ Call LL123 to calculate:  (Y X) = (S R) / XX12+2      if T = 0 = y1 / gradient
 327+ 0000 ~                                                                        ;                        \                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
 328+ 0000 ~                                                                        ;                         with the sign of (Y X) set to the opposite of the line's direction of slope
 329+ 0000 ~                                        call    ADDYXRegtoX1            ; TXA                    \ Set x1 = x1 + (Y X)
 330+ 0000 ~                                        ld      hl,0                    ; LDA #0                 \ Set y1 = 0
 331+ 0000 ~                                        ld      ( prefix1?_XX1532),hl             ; STA XX15+2, XX15+3
 332+ 0000 ~            prefix1?_LL135_6502:         ld      bc,128                  ; LDA XX15+2             \ Set (S R) = (y1_hi y1_lo) - screen height
 333+ 0000 ~                                        call    SUBBCFromY1             ; .                      \ .
 334+ 0000 ~                                        jr      c, prefix1?_LL136_6502           ; BCC LL136              \ If the subtraction underflowed, i.e. if y1 < screen height, then y1 is already on-screen, so jump to LL136
 335+ 0000 ~                                                                ;                        \ to return from the subroutine, as we are done
 336+ 0000 ~            ;;-   If we get here then y1 >= screen height, i.e. off the bottom of the screen
 337+ 0000 ~            prefix1?_LL139_6502:         call    prefix1?_LL123_6502              ; JSR LL123              \ Call LL123 to calculate:   (Y X) = (S R) / XX12+2      if T = 0  = (y1 - screen height) / gradient
 338+ 0000 ~            ;                        \                            (Y X) = (S R) * XX12+2      if T <> 0 = (y1 - screen height) * gradient
 339+ 0000 ~            ;                          with the sign of (Y X) set to the opposite of the line's direction of slope
 340+ 0000 ~                                        call    ADDYXRegtoX1            ; TXA                    \ Set x1 = x1 + (Y X)
 341+ 0000 ~                                        ld      hl, 127                 ; LDA #Y*2-1             \ Set y1 = 2 * #Y - 1. The constant #Y is 96, the y-coordinate of the mid-point of the space view (or in our case 127)
 342+ 0000 ~                                        ld      (prefix1?_XX1532),hl             ; STA XX15+3             \ pixel row of the space view
 343+ 0000 ~            prefix1?_LL136_6502:         ret                             ; RTS                    \ Return from the subroutine
 344+ 0000 ~            ;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 345+ 0000 ~            ;-- LL145 LINE CLIP
 346+ 0000 ~            ;-- OPTISIATIONS - VERTICAL HORZONTAL POINT |DX| = |DY| (and all the veriants for +/-)
 347+ 0000 ~            ;-- This routine clips the line from (x1, y1) to (x2, y2) so it fits on-screen, or returns an error if it can't be clipped to fit. The arguments are 16-bit coordinates, and the clipped line is returned using 8-bit screen coordinates.
 348+ 0000 ~            ;-- This part sets XX13 to reflect which of the two points are on-screen and off-screen.
 349+ 0000 ~            ;-- IN  : XX15(1 0) x1 XX15(3 2) y1 XX15(5 4) x2 XX12(1 0) y2
 350+ 0000 ~            ;-- OUT : (X1, Y1), (X2, Y2) Screen coordinate C flag  Clear if the clipped line fits on-screen, set if itdoesn't
 351+ 0000 ~            ;         XX13 The state of the original coordinates on-screen:* 0   = (x2, y2) on-screen* 95(64)  = (x1, y1) on-screen,  (x2, y2) off-screen* 191(128) = (x1, y1) off-screen, (x2, y2) off-screen
 352+ 0000 ~            ;              So XX13 is non-zero if the end of the line was clipped,meaning the next line sent to BLINE can't join onto the end but has to start a new segment
 353+ 0000 ~            ;         SWAP The swap status of the returned coordinates:* &FF if we swapped the values of (x1, y1) and(x2, y2) as part of the clipping process* 0 if the coordinates are still in the same order
 354+ 0000 ~            ; TODO treat horizonal/vert and single pixel as special cases
 355+ 0000                                  ENDM
 356+ 0000
 357+ 0000              ClippingCodeLL145Macro:     MACRO   prefix1?
 358+ 0000 ~            prefix1?_LL145_6502:        ZeroA                           ; LDA #0                 \ Set SWAP = 0
 359+ 0000 ~                                        ld      (SWAP),a                ; STA SWAP
 360+ 0000 ~                                        ld      a,(prefix1?_XX15X2hi)            ; LDA XX15+5             \ Set A = x2_hi (use b as a substibute for a)
 361+ 0000 ~                                        ld      b,a                     ; .
 362+ 0000 ~            ; Note that as we are interested in the sign of XX113 then this needs to be >= 128 or < 128 or 0, we will use 191 as per bbc for now
 363+ 0000 ~            ; for the screen coord we will use 127 though, we use c as a temporay X register
 364+ 0000 ~            prefix1?_LL147_6502:        ld      a,191                   ; LDX #Y*2-1             \ Set X = #Y * 2 - 1. The constant #Y is 96, the y-coordinate of the mid-point of the space view, so this sets Y2 to 191, the y-coordinate of the bottom pixel row of the space view
 365+ 0000 ~                                        ld      (Xreg),a                ; .
 366+ 0000 ~            ;                    ld      a,127
 367+ 0000 ~            ;                    ld      c,a
 368+ 0000 ~            .CheckX2Y2High:             ld      a,b                     ; ORA XX12+1             \ If one or both of x2_hi and y2_hi are non-zero, jump
 369+ 0000 ~                                        ld      hl,prefix1?_XX15Y2hi    ; .
 370+ 0000 ~                                        or      (hl)                    ; .
 371+ 0000 ~                                        jp      nz,prefix1?_LL107_6502  ; BNE LL107              \ to LL107 to skip the following, leaving X at 191
 372+ 0000 ~            .CheckY2Lo:                 ld      a,127 ;,c               ; get back the temporary x reg from c
 373+ 0000 ~                                        ld      hl,prefix1?_XX15Y2lo    ; CPX XX12               \ If y2_lo > the y-coordinate of the bottom of screen (a is being used as X at this point still)
 374+ 0000 ~                                        cp      (hl)                    ; .
 375+ 0000 ~                                        jp      c,prefix1?_LL107_6502   ; BCC LL107              \ then (x2, y2) is off the bottom of the screen, so skip the following instruction, leaving X at 127
 376+ 0000 ~                                        ZeroA                           ; LDX #0                 \ Set X = 0
 377+ 0000 ~                                        ld      (Xreg),a
 378+ 0000 ~            prefix1?_LL107_6502:        ld      a,(Xreg)                ; STX XX13               \ Set XX13 = X, so we have * XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen* XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lois off the bottom of the screen
 379+ 0000 ~                                        ld      ( prefix1?_XX13),a      ; now c is released as a temporary x reg
 380+ 0000 ~                                        ld      a,(prefix1?_XX15X1hi)   ; LDA XX15+1             \ If one or both of x1_hi and y1_hi are non-zero, jump
 381+ 0000 ~                                        ld      hl,prefix1?_XX15Y1hi    ; ORA XX15+3             \ to LL83
 382+ 0000 ~                                        or      (hl)                    ; .
 383+ 0000 ~                                        jp      nz,prefix1?_LL83_6502            ; BNE LL83
 384+ 0000 ~            ; DEBUG SIMPLIFIED CODE, now we just compare y1 lo > 127
 385+ 0000 ~                                        ld      a,(XX1532)              ; If y1_lo > the y-coordinate of the bottom of screen (If A >= N, then C flag is reset.) ;ld      a,127                   ; LDA #Y*2-1             \ If y1_lo > the y-coordinate of the bottom of screen (If A >= N, then C flag is reset.)
 386+ 0000 ~                                        ld      h,127                   ; then (x1, y1) is off the bottom of the screen, so jump                                 ;ld      hl,XX1532               ; CMP XX15+2             \ then (x1, y1) is off the bottom of the screen, so jump
 387+ 0000 ~                                        cp      h                       ; to LL83                                                                                ;cp      (hl)                    ; .                      \ to LL83
 388+ 0000 ~                                        jp      nc, prefix1?_LL83_6502         ; BCC LL83               \ . (y1 > 127 jump, i.e. 127 <= y1 )
 389+ 0000 ~                                        ld      a,( prefix1?_XX13)                ; LDA XX13               \ If we get here, (x1, y1) is on-screen. If XX13 is non-zero, i.e. (x2, y2) is off-screen, jump
 390+ 0000 ~                                        and     a                       ; BNE LL108              \ to LL108 to halve it before continuing at LL83
 391+ 0000 ~                                        jp      nz,prefix1?_LL108_6502
 392+ 0000 ~            ; If we get here, the high bytes are all zero, which means the x-coordinates are < 256 and therefore fit on screen, and neither coordinate is off the bottom of the screen. That means both coordinates are already on
 393+ 0000 ~            ; screen, so we don't need to do any clipping, all weneed to do is move the low bytes into (X1, Y1) and X2, Y2) and return
 394+ 0000 ~            ; X1 = XX15 (10)  Y1 = XX15+1 X2 = XX15+2 Y2 = XX15+3
 395+ 0000 ~            prefix1?_LL146_6502:        ld      hl,(prefix1?_XX15X1lo)           ;  Save X1 to XX1510
 396+ 0000 ~                                        call    prefix1?_ClampX
 397+ 0000 ~                                        ld      (prefix1?_XX15X1lo),a
 398+ 0000 ~                                        ld      hl,(prefix1?_XX15Y1lo)           ;  hl = y1
 399+ 0000 ~                                        call    prefix1?_ClampY
 400+ 0000 ~                                        ld      (prefix1?_XX1510+1),a            ;  XX1510... = [X1][Y1]
 401+ 0000 ~
 402+ 0000 ~                                        ld      hl,(prefix1?_XX15X2lo)           ;  de = x2
 403+ 0000 ~                                        call    prefix1?_ClampX
 404+ 0000 ~                                        ld      (prefix1?_XX1510+2),a            ;  XX1510... = [X1][Y1][X2]
 405+ 0000 ~
 406+ 0000 ~                                        ld      hl,(prefix1?_XX15Y2lo)           ;  bc = y2
 407+ 0000 ~                                        call    prefix1?_ClampY
 408+ 0000 ~                                        ld      (prefix1?_XX1510+3),a            ;  XX1510... = [X1][Y1][X2][Y2]
 409+ 0000 ~                                        ClearCarryFlag                  ; CLC                    \ Clear the C flag as the clipped line fits on-screen
 410+ 0000 ~                                        ret                             ; RTS                    \ Return from the subroutine
 411+ 0000 ~            prefix1?_LL109_6502:        SetCarryFlag                    ; SEC                    \ Set the C flag to indicate the clipped line does not fit on-screen
 412+ 0000 ~                                        ret                             ; RTS                    \ Return from the subroutine
 413+ 0000 ~            prefix1?_LL108_6502:        ld      hl, prefix1?_XX13                 ; LSR XX13               \ If we get here then (x2, y2) is off-screen and XX13 is
 414+ 0000 ~                                        srl     (hl)                    ;                        \ 191, (128)  so shift XX13 right to halve it to 95 (64)
 415+ 0000 ~            ;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 416+ 0000 ~            ;-- LL145 (Part 2 of 4)
 417+ 0000 ~            prefix1?_LL83_6502:         ld      a,( prefix1?_XX13)               ; LDA XX13               \ If XX13 < 128 then only one of the points is on-screen
 418+ 0000 ~                                        and     a                                ; BPL LL115              \ so jump down to LL115 to skip the checks of whether
 419+ 0000 ~                                        jp      p,prefix1?_LL115_6502            ;                        \ both points are in the strips to the right or bottom of the screen
 420+ 0000 ~            ;-- If we get here, both points are off-screen
 421+ 0000 ~                                        ld      a,(prefix1?_XX15X1hi)            ; LDA XX15+1             \ If both x1_hi and x2_hi have bit 7 set, jump to LL109
 422+ 0000 ~                                        ld      hl,prefix1?_XX15X2hi             ; AND XX15+5             \ to return from the subroutine with the C flag set, as
 423+ 0000 ~                                        and     (hl)
 424+ 0000 ~                                        jp      m, prefix1?_LL109_6502           ; BMI LL109              \ the entire line is above the top of the screen
 425+ 0000 ~                                        ld      a,(prefix1?_XX15Y1hi)            ; LDA XX15+3             \ If both y1_hi and y2_hi have bit 7 set, jump to LL109
 426+ 0000 ~                                        ld      hl,prefix1?_XX15Y2hi             ; AND XX12+1             \ to return from the subroutine with the C flag set, as
 427+ 0000 ~                                        and     (hl)                             ; BMI LL109              \ the entire line is to the left of the screen
 428+ 0000 ~                                        jp      m,prefix1?_LL109_6502            ; .
 429+ 0000 ~                                        ld      a,(prefix1?_XX15X1hi)            ; LDX XX15+1             \ Set A = X = x1_hi - 1
 430+ 0000 ~                                        dec     a                                ; DEX
 431+ 0000 ~                                        ld      (Xreg),a                         ; TXA
 432+ 0000 ~                                        push    af                               ; LDX XX15+5     SP+1    \ Set XX12+2 = x2_hi - 1, we need to save a register first
 433+ 0000 ~                                        ld      a,(prefix1?_XX15X2hi)            ; .
 434+ 0000 ~                                        dec     a                                ; DEX
 435+ 0000 ~                                        ld      (Xreg),a                         ; STX XX12+2
 436+ 0000 ~                                        pop     af                               ; .              SP+0    restore a register
 437+ 0000 ~                                        ld      hl,prefix1?_XX15Y2hi             ; ORA XX12+2             \ If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set,
 438+ 0000 ~                                        or      (hl)                             ; .
 439+ 0000 ~                                        jp      p, prefix1?_LL109_6502           ; BPL LL109              \ jump to LL109 to return from the subroutine with the C flag set, as the line doesn't fit on-screen
 440+ 0000 ~            ; for this bit, while z80 uses carry the opposite way to 6502, 6502 uses borrow, in effect inverting the flip
 441+ 0000 ~            ;NOTEFOUND A PATH WHERE IT DOES NOT DO THIS CHECK e.g. 90 B2 8D A2
 442+ 0000 ~            prefix1?_LL83_DEBUG:          ld      a,(prefix1?_XX1532)              ; LDA XX15+2             \ If y1_lo < y-coordinate of screen bottom, clear the C
 443+ 0000 ~                                        cp      128                     ; CMP #Y*2               \ flag, otherwise set it (NOTE FLIPPED IN z80)
 444+ 0000 ~                                        ld      a,(prefix1?_XX1532+1)            ; LDA XX15+3             \ Set XX12+2 = y1_hi - (1 - C), so:
 445+ 0000 ~                                        sbc     0                       ; SBC #0                 \ .
 446+ 0000 ~                                        ld      (prefix1?_XX12p2),a              ; STA XX12+2             \  * Set XX12+2 = y1_hi - 1 if y1_lo is on-screen * Set XX12+2 = y1_hi  otherwise We do this subtraction because we are only interested
 447+ 0000 ~                                        ld      a,(prefix1?_XX1576)              ; LDA XX12               \ If y2_lo < y-coordinate of screen bottom, clear the C
 448+ 0000 ~                                        cp      128                     ; CMP #Y*2               \ flag, otherwise set it
 449+ 0000 ~                                        ld      a,(prefix1?_XX1576+1)            ; LDA XX12+1             \ Set XX12+2 = y2_hi - (1 - C), so:
 450+ 0000 ~                                        sbc     0                       ; SBC #0                   * Set XX12+1 = y2_hi - 1 if y2_lo is on-screen  * Set XX12+1 = y2_hi     otherwise
 451+ 0000 ~                                        ld      hl,prefix1?_XX12p2               ; ORA XX12+2             \ If neither XX12+1 or XX12+2 have bit 7 set, jump to
 452+ 0000 ~                                        or      (hl)                    ; .
 453+ 0000 ~                                        jp      p,prefix1?_LL109_6502            ; BPL LL109              \ LL109 to return from the subroutine with the C flag set, as the line doesn't fit on-screen
 454+ 0000 ~            ;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 455+ 0000 ~            ;-- LL145 (Part 3 of 4) Summary: Clip line: Calculate the line's gradient
 456+ 0000 ~            prefix1?_LL115_6502:        ld      a,(Yreg)                ; TYA                    \ Store Y on the stack so we can preserve it through the call to this routine
 457+ 0000 ~                                        push    af                      ; PHA            SP+1    \ call to this subroutine
 458+ 0000 ~                                        ld      hl,(prefix1?_XX15X2lo)             ; LDA XX15+4             \ Set XX12+2 = x2_lo - x1_lo
 459+ 0000 ~                                        ld      de,(prefix1?_XX15X1lo)             ; LDA XX15+5             \ Set XX12+3 = x2_hi - x1_hi
 460+ 0000 ~                                        ClearCarryFlag                  ; SBC XX15+1
 461+ 0000 ~                                        sbc     hl,de                   ; .
 462+ 0000 ~                                        ld      (delta_x),hl            ; .
 463+ 0000 ~                                        ld      hl,(prefix1?_XX15Y2lo)             ; LDA XX12               \ Set XX12+4 = y2_lo - y1_lo
 464+ 0000 ~                                        ld      de,(prefix1?_XX15Y1lo)             ;
 465+ 0000 ~                                        ClearCarryFlag                  ; SBC XX15+2
 466+ 0000 ~                                        sbc     hl,de                   ; .
 467+ 0000 ~                                        ld      (delta_y),hl            ; .
 468+ 0000 ~            ; So we now have:  delta_x in XX12(3 2)  delta_y in XX12(5 4) where the delta is (x1, y1) - (x2, y2))
 469+ 0000 ~                                        ld      a,(delta_y+1)           ; EOR XX12+3             \ Set S = the sign of delta_x * the sign of delta_y, so
 470+ 0000 ~                                        ld      hl,delta_x+1
 471+ 0000 ~                                        xor     (hl)
 472+ 0000 ~                                        ld      (Svar),a                ; STA S                  \ if bit 7 of S is set, the deltas have different signs (perhaps we should do bit 7 mask ?????????
 473+ 0000 ~                                        ld      hl,(delta_y)            ; LDA XX12+5             \ If delta_y_hi is positive, jump down to LL110 to skip
 474+ 0000 ~                                        ld      a,h
 475+ 0000 ~                                        and     a
 476+ 0000 ~                                        jp      p, prefix1?_LL110_6502  ; BPL LL110              \ the following
 477+ 0000 ~                                        NegHL                           ; LDA #0                 \ Otherwise flip the sign of delta_y to make it
 478+ 0000 ~                                        ld      (delta_y),hl            ; positive, starting with the low bytes
 479+ 0000 ~            prefix1?_LL110_6502:        ld      hl,(delta_x)            ; LDA XX12+3             \ If delta_x_hi is positive, jump down to LL111 to skip
 480+ 0000 ~                                        ld      a,h                     ; BPL LL111              \ the following
 481+ 0000 ~                                        and     a                       ; .
 482+ 0000 ~                                        jp      p,prefix1?_LL111_6502            ; .
 483+ 0000 ~                                        NegHL                           ; SEC                    \ Otherwise flip the sign of delta_x to make it
 484+ 0000 ~                                        ld      (delta_x),hl            ; LDA #0                 \ positive, starting with the low bytes
 485+ 0000 ~            ;--  We now keep halving |delta_x| and |delta_y| until both of them have zero in their high bytes
 486+ 0000 ~            prefix1?_LL111_6502:        ld      hl,(delta_x)
 487+ 0000 ~                                        ld      de,(delta_y)
 488+ 0000 ~                                        ld      a,h                     ; TAX                    \ If |delta_x_hi| is non-zero, skip the following
 489+ 0000 ~                                        or      d                       ; BNE LL112
 490+ 0000 ~                                        jp      z,prefix1?_LL113_6502            ; LDX XX12+5             \ If |delta_y_hi| = 0, jump down to LL113 (as both |delta_x_hi| and |delta_y_hi| are 0)
 491+ 0000 ~            prefix1?_LL112_6502:        ShiftHLRight1                   ; LSR A                  \ Halve the value of delta_x in (A XX12+2)
 492+ 0000 ~                                        ShiftDERight1                   ; LSR XX12+5             \ Halve the value of delta_y XX12(5 4)
 493+ 0000 ~                                        ld      (delta_x),hl
 494+ 0000 ~                                        ld      (delta_y),de            ; write them back so we don't end up in an infinite loop
 495+ 0000 ~                                        jp       prefix1?_LL111_6502                  ; JMP LL111              \ Loop back to LL111
 496+ 0000 ~            ;-- By now, the high bytes of both |delta_x| and |delta_y| are zero
 497+ 0000 ~            prefix1?_LL113_6502:        ZeroA                           ; STX T                  \ We know that X = 0 as that's what we tested with a BEQ  above, so this sets T = 0
 498+ 0000 ~                                        ld      (Tvar),a
 499+ 0000 ~                                        ld      a,(delta_x)             ; LDA XX12+2             \ If delta_x_lo < delta_y_lo, so our line is more
 500+ 0000 ~                                        ld      hl,delta_y              ; CMP XX12+4             \ vertical than horizontal, jump to LL114
 501+ 0000 ~                                        cp      (hl)
 502+ 0000 ~                                        jp      c, prefix1?_LL114_6502  ; BCC LL114              ; if delta y > delta x then its a steep slope so we do 256*dy/dx
 503+ 0000 ~            ;-- If we get here then our line is more horizontal than vertical, so it is a shallow slope
 504+ 0000 ~                                        ld      a,(delta_x)             ; STA Q                  \ Set Q = delta_x_lo
 505+ 0000 ~                                        ld      (Qvar),a                ; .
 506+ 0000 ~                                        ld      a,(delta_y)             ; LDA XX12+4             \ Set A = delta_y_lo
 507+ 0000 ~                                        call    prefix1?_LL28_6502      ; JSR LL28               \ Call LL28 to calculate: R = 256 * A / Q = 256 * delta_y_lo / delta_x_lo
 508+ 0000 ~                                        jp      prefix1?_LL116_6502     ; JMP LL116              \ Jump to LL116, as we now have the line's gradient in R
 509+ 0000 ~            ;-- If we get here then our line is more vertical than horizontal, so it is a steep slope
 510+ 0000 ~            prefix1?_LL114_6502:        ld      a,(delta_y)             ; LDA XX12+4             \ Set Q = delta_y_lo
 511+ 0000 ~                                        ld      (Qvar),a                ; STA Q
 512+ 0000 ~                                        ld      a,(delta_x)             ; LDA XX12+2             \ Set A = delta_x_lo
 513+ 0000 ~                                        call    prefix1?_LL28_6502               ; JSR LL28               \ Call LL28 to calculate: R = 256 * A / Q = 256 * delta_x_lo / delta_y_lo
 514+ 0000 ~                                        ld      a,$FF                   ; DEC T                  \ T was set to 0 above, so this sets T = &FF when our
 515+ 0000 ~                                        ld      (Tvar),a                ;                        \ line is steep
 516+ 0000 ~            ;----------------------------------------------------------------------------------------------------------------
 517+ 0000 ~            ;--- LL116 This part sets things up to call the routine in LL188, which does the actual clipping.
 518+ 0000 ~            ;--  If we get here, then R has been set to the gradient of the line (x1, y1) to(x2, y2), with T indicating the gradient of slope: * 0   = shallow slope (more horizontal than vertical)
 519+ 0000 ~            ;--                                                                                                                                * &FF = steep slope (more vertical than horizontal)
 520+ 0000 ~            ;-- XX13 has been set as follows: * 0   = (x1, y1) off-screen, (x2, y2) on-screen * 95(64)  = (x1, y1) on-screen,  (x2, y2) off-screen * 191(128) = (x1, y1) off-screen, (x2, y2) off-screen
 521+ 0000 ~            prefix1?_LL116_6502:        ld      a,(Rvar)                ; LDA R                  \ Store the gradient in XX12+2
 522+ 0000 ~                                        ld      (prefix1?_XX12p2),a     ; STA XX12+2
 523+ 0000 ~                                        ld      a,(Svar)                ; LDA S                  \ Store the type of slope in XX12+3, bit 7 clear means
 524+ 0000 ~                                        ld      (prefix1?_XX12p3),a              ; STA XX12+3             \ top left to bottom right, bit 7 set means top right to bottom left
 525+ 0000 ~                                        ld      a,( prefix1?_XX13)                ; LDA XX13               \ If XX13 = 0, skip the following instruction
 526+ 0000 ~                                        cp      0                       ; BEQ LL138
 527+ 0000 ~                                        jp      z,prefix1?_LL138_6502            ; .
 528+ 0000 ~                                        jp      p, prefix1?_LLX117_6502          ; If XX13 is positive, it must be 95 (64) as 128 would be negative). This means (x1, y1) is on-screen but (x2, y2) isn't, so we jump
 529+ 0000 ~            ;-- If we get here, XX13 = 0 or 191, so (x1, y1) is off-screen and needs clipping
 530+ 0000 ~            prefix1?_LL138_6502:          call    prefix1?_LL118_6502              ; JSR LL118              \ Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 531+ 0000 ~                                        ld      a,( prefix1?_XX13)                ; LDA XX13               \ If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to
 532+ 0000 ~                                        and     a
 533+ 0000 ~                                        jp      p,prefix1?_LL124_6502            ; BPL LL124              \ LL124 to return with a successfully clipped line
 534+ 0000 ~            ;-- If we get here, XX13 = 191 (128) (both coordinates areoff-screen)
 535+ 0000 ~            prefix1?_LL117_6502:          ld      a,(prefix1?_XX1510+1)            ; LDA XX15+1             \ If either of x1_hi or y1_hi are non-zero, jump to
 536+ 0000 ~                                        ld      hl,prefix1?_XX1532+1             ; ORA XX15+3             \ LL137 to return from the subroutine with the C flag
 537+ 0000 ~                                        or      (hl)
 538+ 0000 ~                                        jp      nz, prefix1?_LL137_6502          ; BNE LL137              \ set, as the line doesn't fit on-screen
 539+ 0000 ~                                        ld      a,(prefix1?_XX1532)              ; LDA XX15+2             \ If y1_lo > y-coordinate of the bottom of the screen
 540+ 0000 ~                                        cp      128                     ; CMP #Y*2               \ jump to LL137 to return from the subroutine with the
 541+ 0000 ~                                        jp      nc, prefix1?_LL137_6502          ; BCS LL137              \ C flag set, as the line doesn't fit on-screen
 542+ 0000 ~            ;-- If we get here, XX13 = 95 or 191, and in both cases (x2, y2) is off-screen, so we now need to swap the (x1, y1) and (x2, y2) coordinates around before doing the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
 543+ 0000 ~            prefix1?_LLX117_6502:         ld      hl,( prefix1?_XX1510)             ; LDX XX15               \ Swap x1_lo = x2_lo
 544+ 0000 ~                                        ld      de,( prefix1?_XX1554)
 545+ 0000 ~                                        ld      ( prefix1?_XX1510),de
 546+ 0000 ~                                        ld      ( prefix1?_XX1554),hl
 547+ 0000 ~                                        ld      hl,( prefix1?_XX1532)             ; LDX XX15+2             \ Swap y1_lo = y2_lo
 548+ 0000 ~                                        ld      de,( prefix1?_XX1576)
 549+ 0000 ~                                        ld      ( prefix1?_XX1532),de
 550+ 0000 ~                                        ld      ( prefix1?_XX1576),hl
 551+ 0000 ~                                        call    prefix1?_LL118_6502              ; JSR LL118              \ Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 552+ 0000 ~                                        ld      hl,SWAP
 553+ 0000 ~                                        dec     (hl)                    ; DEC SWAP               \ Set SWAP = &FF to indicate that we just clipped the line at the (x2, y2) end by swapping the coordinates (the DEC does this as we set SWAP to 0 at the start of this subroutine)
 554+ 0000 ~            prefix1?_LL124_6502:          pop     af                      ; PLA            SP+0    \ Restore Y from the stack so it gets preserved through
 555+ 0000 ~                                        ld      (Yreg),a                ; TAY                    \ the call to this subroutine
 556+ 0000 ~                                        call    prefix1?_LL146_6502              ; JMP LL146              \ Jump up to LL146 to move the low bytes of (x1, y1) and (x2, y2) into (X1, Y1) and (X2, Y2), and return from the subroutine with a successfully clipped line
 557+ 0000 ~                                        ret                             ; then exit so we don't pop it twice
 558+ 0000 ~            prefix1?_LL137_6502:          pop     af                      ; PLA            SP+0    \ Restore Y from the stack so it gets preserved through
 559+ 0000 ~                                        ld      (Yreg),a                ; TAY                    \ the call to this subroutine
 560+ 0000 ~                                        SetCarryFlag                    ; SEC                    \ Set the C flag to indicate the clipped line does not fit on-screen
 561+ 0000 ~                                        ret                             ; RTS                    \ Return from the subroutine
 562+ 0000 ~
 563+ 0000 ~
 564+ 0000 ~            prefix1?_l2_draw_6502_line:   ld      hl,x1                           ; copy from currnet position to 6502 variables
 565+ 0000 ~                                        ld      de, prefix1?_XX1510
 566+ 0000 ~                                        ld      bc,4*2
 567+ 0000 ~                                        ldir
 568+ 0000 ~                                        call    prefix1?_LL145_6502                      ; perform 6502 version
 569+ 0000 ~                                        ret     c                               ; returns if carry is set as its a no draw
 570+ 0000 ~            .CopyBackResults:           ld      hl,0
 571+ 0000 ~                                        ld      (x1),hl
 572+ 0000 ~                                        ld      (y1),hl
 573+ 0000 ~                                        ld      (x2),hl
 574+ 0000 ~                                        ld      (y2),hl
 575+ 0000 ~                                        ld      a,( prefix1?_XX1510)
 576+ 0000 ~                                        ld      (x1),a
 577+ 0000 ~                                        ld      c,a
 578+ 0000 ~                                        ld      a,( prefix1?_XX1510+1)
 579+ 0000 ~                                        ld      (y1),a
 580+ 0000 ~                                        ld      b,a
 581+ 0000 ~                                        ld      a,( prefix1?_XX1510+2)
 582+ 0000 ~                                        ld      (x2),a
 583+ 0000 ~                                        ld      e,a
 584+ 0000 ~                                        ld      a,( prefix1?_XX1510+3)
 585+ 0000 ~                                        ld      (y2),a
 586+ 0000 ~                                        ld      d,a
 587+ 0000 ~                                        ld      a,$FF
 588+ 0000 ~                                        ClearCarryFlag
 589+ 0000 ~                                        ret
 590+ 0000                      ENDM
# file closed: ../../Universe/UniverseMacros/asm_linedraw.asm
  42  0000                                      INCLUDE "../../Universe/UniverseMacros/UniverseVarsDefineMacro.asm"
# file opened: ../../Universe/UniverseMacros/UniverseVarsDefineMacro.asm
   1+ 0000              ; -- AI Core data
   2+ 0000              UnivCoreAIVarsMacro:        MACRO  prefix1?
   3+ 0000 ~            prefix1?_BnKRotXCounter             DB  0                       ; INWK +29
   4+ 0000 ~            prefix1?_BnKRotZCounter             DB  0                       ; INWK +30
   5+ 0000 ~            prefix1?_BnkCam0yLo                 DB  0                       ; INWK +33 ????
   6+ 0000 ~            prefix1?_BnkCam0yHi                 DB  0                       ; INWK +34?????
   7+ 0000 ~            prefix1?_BnKShipType                DB  0
   8+ 0000 ~
   9+ 0000 ~            ; Used to make 16 bit reads a little cleaner in source code
  10+ 0000 ~            prefix1?_BnKzPoint                  DS  3
  11+ 0000 ~            prefix1?_BnKzPointLo                equ prefix1?_BnKzPoint
  12+ 0000 ~            prefix1?_BnKzPointHi                equ prefix1?_BnKzPoint+1
  13+ 0000 ~            prefix1?_BnKzPointSign              equ prefix1?_BnKzPoint+2
  14+ 0000 ~
  15+ 0000 ~            ; Used for medridan drawing routines
  16+ 0000 ~            prefix1?_BnKCx                      DW  0
  17+ 0000 ~            prefix1?_BnKCxSign                  EQU prefix1?_BnKCx+1
  18+ 0000 ~            prefix1?_BnKCy                      DW  0
  19+ 0000 ~            prefix1?_BnKCySign                  EQU prefix1?_BnKCy+1
  20+ 0000 ~            prefix1?_BnKUx                      DW  0
  21+ 0000 ~            prefix1?_BnKUxSign                  EQU prefix1?_BnKUx+1
  22+ 0000 ~            prefix1?_BnKUy                      DW  0
  23+ 0000 ~            prefix1?_BnKUySign                  EQU prefix1?_BnKUy+1
  24+ 0000 ~            prefix1?_BnKVx                      DW  0
  25+ 0000 ~            prefix1?_BnKVxSign                  EQU prefix1?_BnKVx+1
  26+ 0000 ~            prefix1?_BnKVy                      DW  0
  27+ 0000 ~            prefix1?_BnKVySign                  EQU prefix1?_BnKVy+1
  28+ 0000 ~            prefix1?_BnKSinCNT2                 DB  0
  29+ 0000 ~            prefix1?_BnKSinCNT2Sign             DB  0
  30+ 0000 ~            prefix1?_BnKCosCNT2                 DB  0
  31+ 0000 ~            prefix1?_BnKCosCNT2Sign             DB  0
  32+ 0000 ~            prefix1?_BnKUxCos                   DB  0
  33+ 0000 ~            prefix1?_BnKUxCosSign               DB  0
  34+ 0000 ~            prefix1?_BnKUyCos                   DB  0
  35+ 0000 ~            prefix1?_BnKUyCosSign               DB  0
  36+ 0000 ~            prefix1?_BnKVxSin                   DB  0
  37+ 0000 ~            prefix1?_BnKVxSinSign               DB  0
  38+ 0000 ~            prefix1?_BnKVySin                   DB  0
  39+ 0000 ~            prefix1?_BnKVySinSign               DB  0
  40+ 0000 ~            prefix1?_BnKVxVySinSign             DB  0
  41+ 0000 ~            prefix1?_BnKUxUyCosSign             DB  0
  42+ 0000 ~            prefix1?_BnKUxCosAddVxSin           DW  0
  43+ 0000 ~            prefix1?_BnKUyCosSubVySin           DW  0
  44+ 0000 ~            prefix1?_BnKAngle                   DB  0
  45+ 0000 ~            s
  46+ 0000 ~
  47+ 0000 ~            ; General local variables used in universe object
  48+ 0000 ~            prefix1?_BnKTGT                     DB  0
  49+ 0000 ~            prefix1?_BnKSTP                     DB  0
  50+ 0000 ~            prefix1?_BnKLSP                     DS  50              ; move to planet or L2 code ?
  51+ 0000 ~            prefix1?_BnKCNT                     DB  0               ; 93
  52+ 0000 ~            prefix1?_BnKCNT2                    DB  0               ; 93
  53+ 0000 ~            ; Replaced LSX2 and LSY2 with plot heaps of 64 x 2 bytes each + 1 pair for initial point
  54+ 0000 ~                IFDEF MERIDANLINEDEBUG
  55+ 0000 ~            prefix1?_BnKPlotXHeap               DS  $82			   ; &0EC0	    \ LSX2 bline buffer size?
  56+ 0000 ~            prefix1?_BnKPlotYHeap               DS  $82            ; &0F0E	    \ LSY2
  57+ 0000 ~                ENDIF
  58+ 0000 ~            prefix1?_BnKPlotIndex               DB  0
  59+ 0000 ~                DISPLAY "TODO can we remove this and just use BnkCNT = 0 as the same thing?"
  60+ 0000 ~            prefix1?_BnKFlag					DB  0
  61+ 0000 ~
  62+ 0000 ~            ; Post clipping the results are now 8 bit
  63+ 0000 ~            prefix1?_BnKVisibility              DB  0               ; replaces general purpose xx4 in renderingW
  64+ 0000 ~            prefix1?_BnKProjectedY              DB  0
  65+ 0000 ~            prefix1?_BnKProjectedX              DB  0
  66+ 0000 ~            prefix1?_BnKProjected               equ prefix1?_BnKProjectedY  ; resultant projected position
  67+ 0000 ~            prefix1?_XX15Save                   DS  8
  68+ 0000 ~            prefix1?_XX15Save2                  DS  8
  69+ 0000 ~            prefix1?_Radius                     DB  0
  70+ 0000 ~            ; Used when drawing curves for the end value from previous calls to BLINE
  71+ 0000 ~            ; held as 16 bit values pre clipping
  72+ 0000 ~            prefix1?_PrevXPos                   DW 0
  73+ 0000 ~            prefix1?_PrevYPos                   DW 0
  74+ 0000 ~            prefix1?_NewXPos                    DW 0
  75+ 0000 ~            prefix1?_NewYPos                    DW 0
  76+ 0000 ~
  77+ 0000 ~            ; Colouration
  78+ 0000 ~            ; For planets, Colour 1 is main colour, Colour 2 is outer rim
  79+ 0000 ~            ; if we are going to do outer rim then may have colour thickeness as number of pixels to simulat atmosphere
  80+ 0000 ~            prefix1?_Colour1                    DB 0
  81+ 0000 ~            prefix1?_Colour2                    DB 0
  82+ 0000 ~            prefix1?_Colour2Thickness           DB 0
  83+ 0000 ~
  84+ 0000 ~            ;        -- _pl(prf .. "Radius                     DW  0
  85+ 0000 ~            ;        -- _pl(prf .. "RadiusHigh                 equ prefix1?_Radius+1
  86+ 0000                                           ENDM
  87+ 0000
  88+ 0000              UnivPosVarsMacro:            MACRO  prefix1?
  89+ 0000 ~            prefix1?_BnKxlo                     DB  0                       ; INWK+0
  90+ 0000 ~            prefix1?_BnKxhi                     DB  0                       ; there are hi medium low as some times these are 24 bit
  91+ 0000 ~            prefix1?_BnKxsgn                    DB  0                       ; INWK+2
  92+ 0000 ~            prefix1?_BnKylo                     DB  0                       ; INWK+3 \ ylo
  93+ 0000 ~            prefix1?_BnKyhi                     DB  0                       ; INWK+4 \ yHi
  94+ 0000 ~            prefix1?_BnKysgn                    DB  0                       ; INWK +5
  95+ 0000 ~            prefix1?_BnKzlo                     DB  0                       ; INWK +6
  96+ 0000 ~            prefix1?_BnKzhi                     DB  0                       ; INWK +7
  97+ 0000 ~            prefix1?_BnKzsgn                    DB  0                       ; INWK +8
  98+ 0000 ~            prefix1?_CompassX                   DW  0
  99+ 0000 ~            prefix1?_CompassY                   DW  0
 100+ 0000 ~            prefix1?_BnKElipseCenterX           DW  0
 101+ 0000 ~            prefix1?_BnKElipseCenterY           DW  0
 102+ 0000 ~            prefix1?_BnKElipseRadiusU           DW  0
 103+ 0000 ~            prefix1?_BnKElipseRadiusV           DW  0
 104+ 0000                                          ENDM
 105+ 0000
 106+ 0000              ; Rotation data is stored as lohi, but only 15 bits with 16th bit being  a sign bit. Note this is NOT 2'c compliment
 107+ 0000              ;-Rotation Matrix of Universe Object-----------------------------------------------------------------------------------------------
 108+ 0000              UnivRotationVarsMacro:      MACRO prefix1?
 109+ 0000 ~            prefix1?_BnKrotmatSidevX            DW  0                       ; INWK +21
 110+ 0000 ~            prefix1?_BnKrotmatSidev             equ prefix1?_BnKrotmatSidevX
 111+ 0000 ~            prefix1?_BnKrotmatSidevY            DW  0                       ; INWK +23
 112+ 0000 ~            prefix1?_BnKrotmatSidevZ            DW  0                       ; INWK +25
 113+ 0000 ~            prefix1?_BnKrotmatRoofvX            DW  0                       ; INWK +15
 114+ 0000 ~            prefix1?_BnKrotmatRoofv             equ prefix1?_BnKrotmatRoofvX
 115+ 0000 ~            prefix1?_BnKrotmatRoofvY            DW  0                       ; INWK +17
 116+ 0000 ~            prefix1?_BnKrotmatRoofvZ            DW  0                       ; INWK +19
 117+ 0000 ~            prefix1?_BnKrotmatNosevX            DW  0                       ; INWK +9
 118+ 0000 ~            prefix1?_BnKrotmatNosev             EQU prefix1?_BnKrotmatNosevX
 119+ 0000 ~            prefix1?_BnKrotmatNosevY            DW  0                       ; INWK +11
 120+ 0000 ~            prefix1?_BnKrotmatNosevZ            DW  0                       ; INWK +13
 121+ 0000                                          ENDM
 122+ 0000
 123+ 0000
 124+ 0000              XX15DefineMacro: MACRO   prefix1?
 125+ 0000 ~
 126+ 0000 ~            prefix1?_BnKXScaled                  DB  0               ; XX15+0Xscaled
 127+ 0000 ~            prefix1?_BnKXScaledSign              DB  0               ; XX15+1xsign
 128+ 0000 ~            prefix1?_BnKYScaled                  DB  0               ; XX15+2yscaled
 129+ 0000 ~            prefix1?_BnKYScaledSign              DB  0               ; XX15+3ysign
 130+ 0000 ~            prefix1?_BnKZScaled                  DB  0               ; XX15+4zscaled
 131+ 0000 ~            prefix1?_BnKZScaledSign              DB  0               ; XX15+5zsign
 132+ 0000 ~            prefix1?_XX1576                      DW  0    ; y2
 133+ 0000 ~
 134+ 0000 ~            prefix1?_XX15:                       equ prefix1?_BnKXScaled
 135+ 0000 ~            prefix1?_XX15VecX:                   equ prefix1?_XX15
 136+ 0000 ~            prefix1?_XX15VecY:                   equ prefix1?_XX15+1
 137+ 0000 ~            prefix1?_XX15VecZ:                   equ prefix1?_XX15+2
 138+ 0000 ~            prefix1?_BnKXPoint:                  equ prefix1?_XX15
 139+ 0000 ~            prefix1?_BnKXPointLo:                equ prefix1?_XX15+0
 140+ 0000 ~            prefix1?_BnKXPointHi:                equ prefix1?_XX15+1
 141+ 0000 ~            prefix1?_BnKXPointSign:              equ prefix1?_XX15+2
 142+ 0000 ~            prefix1?_BnKYPoint:                  equ prefix1?_XX15+3
 143+ 0000 ~            prefix1?_BnKYPointLo:                equ prefix1?_XX15+3
 144+ 0000 ~            prefix1?_BnKYPointHi:                equ prefix1?_XX15+4
 145+ 0000 ~            prefix1?_BnKYPointSign:              equ prefix1?_XX15+5
 146+ 0000 ~
 147+ 0000 ~            prefix1?_XX1510                      EQU prefix1?_BnKXScaled    ; x1 as a 16-bit coordinate (x1_hi x1_lo)
 148+ 0000 ~            prefix1?_XX1532                      EQU prefix1?_BnKYScaled   ; y1 as a 16-bit coordinate (y1_hi y1_lo)
 149+ 0000 ~            prefix1?_XX1554                      EQU prefix1?_BnKZScaled   ; x2
 150+ 0000 ~            prefix1?_XX1554p1                    EQU prefix1?_XX1554+1
 151+ 0000 ~            prefix1?_XX15X1lo                    EQU prefix1?_XX1510
 152+ 0000 ~            prefix1?_XX15X1hi                    EQU prefix1?_XX1510+1
 153+ 0000 ~            prefix1?_XX15Y1lo                    EQU prefix1?_XX1532
 154+ 0000 ~            prefix1?_XX15Y1hi                    EQU prefix1?_XX1532+1
 155+ 0000 ~            prefix1?_XX15X2lo                    EQU prefix1?_XX1554
 156+ 0000 ~            prefix1?_XX15X2hi                    EQU prefix1?_XX1554+1
 157+ 0000 ~            prefix1?_XX15Y2lo                    EQU prefix1?_XX1210
 158+ 0000 ~            prefix1?_XX15Y2hi                    EQU prefix1?_XX1210+1
 159+ 0000 ~            prefix1?_XX15PlotX1                  EQU prefix1?_XX15
 160+ 0000 ~            prefix1?_XX15PlotY1                  EQU prefix1?_XX15+1
 161+ 0000 ~            prefix1?_XX15PlotX2                  EQU prefix1?_XX15+2
 162+ 0000 ~            prefix1?_XX15PlotY2                  EQU prefix1?_XX15+3
 163+ 0000                          ENDM
 164+ 0000
 165+ 0000              XX12DefineMacro: MACRO   prefix1?
 166+ 0000 ~            ;-- transmat0 --------------------------------------------------------------------------------------------------------------------------
 167+ 0000 ~            ; Note XX12 comes after as some logic in normal processing uses XX15 and XX12 combines
 168+ 0000 ~
 169+ 0000 ~            prefix1?_XX1210                     EQU prefix1?_XX1576
 170+ 0000 ~            prefix1?_XX12p1                     EQU prefix1?_XX1210+1
 171+ 0000 ~            prefix1?_XX12                       EQU prefix1?_XX1210
 172+ 0000 ~
 173+ 0000 ~
 174+ 0000 ~            prefix1?_BnKXX12xLo                 EQU prefix1?_XX12               ; XX12+0
 175+ 0000 ~            prefix1?_BnKXX12xSign               EQU prefix1?_XX12+1   ; XX12+1
 176+ 0000 ~            prefix1?_BnKXX12yLo                 EQU prefix1?_XX12+2   ; XX12+2
 177+ 0000 ~            prefix1?_BnKXX12ySign               EQU prefix1?_XX12+3   ; XX12+3
 178+ 0000 ~            prefix1?_BnKXX12zLo                 EQU prefix1?_XX12+4   ; XX12+4
 179+ 0000 ~            prefix1?_BnKXX12zSign               EQU prefix1?_XX12+5   ; XX12+5
 180+ 0000 ~            prefix1?_XX12Save                   DS  6
 181+ 0000 ~            prefix1?_XX12Save2                  DS  6
 182+ 0000 ~
 183+ 0000 ~            prefix1?_varXX12                    EQU prefix1?_XX12
 184+ 0000 ~            ; Repurposed XX12 when plotting lines
 185+ 0000 ~            prefix1?_BnkY2                      equ prefix1?_XX12+0
 186+ 0000 ~            prefix1?_BnKy2Lo                    equ prefix1?_XX12+0
 187+ 0000 ~            prefix1?_BnkY2Hi                    equ prefix1?_XX12+1
 188+ 0000 ~            prefix1?_BnkDeltaXLo                equ prefix1?_XX12+2
 189+ 0000 ~            prefix1?_BnkDeltaXHi                equ prefix1?_XX12+3
 190+ 0000 ~            prefix1?_BnkDeltaYLo                equ prefix1?_XX12+4
 191+ 0000 ~            prefix1?_BnkDeltaYHi                equ prefix1?_XX12+5
 192+ 0000 ~            prefix1?_BnkGradient                equ prefix1?_XX12+2
 193+ 0000 ~            prefix1?_BnkTemp1                   equ prefix1?_XX12+2
 194+ 0000 ~            prefix1?_BnkTemp1Lo                 equ prefix1?_XX12+2
 195+ 0000 ~            prefix1?_BnkTemp1Hi                 equ prefix1?_XX12+3
 196+ 0000 ~            prefix1?_BnkTemp2                   equ prefix1?_XX12+3
 197+ 0000 ~            prefix1?_BnkTemp2Lo                 equ prefix1?_XX12+3
 198+ 0000 ~            prefix1?_BnkTemp2Hi                 equ prefix1?_XX12+4
 199+ 0000                                          ENDM
 200+ 0000
 201+ 0000              XX16DefineMacro: MACRO   prefix1?
 202+ 0000 ~            ;-- XX16 --------------------------------------------------------------------------------------------------------------------------
 203+ 0000 ~            prefix1?_BnkTransmatSidevX          DW  0               ; XX16+0
 204+ 0000 ~            prefix1?_BnkTransmatSidev           EQU prefix1?_BnkTransmatSidevX
 205+ 0000 ~            prefix1?_BnkTransmatSidevY          DW 0                ; XX16+2
 206+ 0000 ~            prefix1?_BnkTransmatSidevZ          DW 0                ; XX16+2
 207+ 0000 ~            prefix1?_BnkTransmatRoofvX          DW 0
 208+ 0000 ~            prefix1?_BnkTransmatRoofv           EQU prefix1?_BnkTransmatRoofvX
 209+ 0000 ~            prefix1?_BnkTransmatRoofvY          DW 0                ; XX16+2
 210+ 0000 ~            prefix1?_BnkTransmatRoofvZ          DW 0                ; XX16+2
 211+ 0000 ~            prefix1?_BnkTransmatNosevX          DW 0
 212+ 0000 ~            prefix1?_BnkTransmatNosev           EQU prefix1?_BnkTransmatNosevX
 213+ 0000 ~            prefix1?_BnkTransmatNosevY          DW 0                ; XX16+2
 214+ 0000 ~            prefix1?_BnkTransmatNosevZ          DW 0                ; XX16+2
 215+ 0000 ~            prefix1?_BnkTransmatTransX          DW 0
 216+ 0000 ~            prefix1?_BnkTransmatTransY          DW 0
 217+ 0000 ~            prefix1?_BnkTransmatTransZ          DW 0
 218+ 0000 ~            prefix1?_XX16                       equ prefix1?_BnkTransmatSidev
 219+ 0000 ~            ;-- XX16Inv --------------------------------------------------------------------------------------------------------------------------
 220+ 0000 ~            prefix1?_BnkTransInvRow0x0          DW 0
 221+ 0000 ~            prefix1?_BnkTransInvRow0x1          DW 0
 222+ 0000 ~            prefix1?_BnkTransInvRow0x2          DW 0
 223+ 0000 ~            prefix1?_BnkTransInvRow0x3          DW 0
 224+ 0000 ~            prefix1?_BnkTransInvRow1y0          DW 0
 225+ 0000 ~            prefix1?_BnkTransInvRow1y1          DW 0
 226+ 0000 ~            prefix1?_BnkTransInvRow1y2          DW 0
 227+ 0000 ~            prefix1?_BnkTransInvRow1y3          DW 0
 228+ 0000 ~            prefix1?_BnkTransInvRow2z0          DW 0
 229+ 0000 ~            prefix1?_BnkTransInvRow2z1          DW 0
 230+ 0000 ~            prefix1?_BnkTransInvRow2z2          DW 0
 231+ 0000 ~            prefix1?_BnkTransInvRow2z3          DW 0
 232+ 0000 ~
 233+ 0000 ~            prefix1?_XX16Inv                    equ prefix1?_BnkTransInvRow0x0
 234+ 0000                                          ENDM
 235+ 0000
 236+ 0000              XX18DefineMacro: MACRO   prefix1?
 237+ 0000 ~            ;-- XX18 --------------------------------------------------------------------------------------------------------------------------
 238+ 0000 ~            prefix1?_BnkDrawCam0xLo             DB  0               ; XX18+0
 239+ 0000 ~            prefix1?_BnkDrawCam0xHi             DB  0               ; XX18+1
 240+ 0000 ~            prefix1?_BnkDrawCam0xSgn            DB  0               ; XX18+2
 241+ 0000 ~            prefix1?_BnkDrawCam0x               equ prefix1?_BnkDrawCam0xLo
 242+ 0000 ~            prefix1?_BnkDrawCam0yLo             DB  0               ; XX18+3
 243+ 0000 ~            prefix1?_BnkDrawCam0yHi             DB  0               ; XX18+4
 244+ 0000 ~            prefix1?_BnkDrawCam0ySgn            DB  0               ; XX18+5
 245+ 0000 ~            prefix1?_BnkDrawCam0y               equ prefix1?_BnkDrawCam0yLo
 246+ 0000 ~            prefix1?_BnkDrawCam0zLo             DB  0               ; XX18+6
 247+ 0000 ~            prefix1?_BnkDrawCam0zHi             DB  0               ; XX18+7
 248+ 0000 ~            prefix1?_BnkDrawCam0zSgn            DB  0               ; XX18+8
 249+ 0000 ~            prefix1?_BnkDrawCam0z               equ prefix1?_BnkDrawCam0zLo
 250+ 0000 ~            prefix1?_XX18                       equ prefix1?_BnkDrawCam0xLo
 251+ 0000                                          ENDM
 252+ 0000
 253+ 0000              XX25DefineMacro: MACRO   prefix1?
 254+ 0000 ~            ;-- XX25 --------------------------------------------------------------------------------------------------------------------------
 255+ 0000 ~            prefix1?_BnKProjxLo                 DB  0
 256+ 0000 ~            prefix1?_BnKProjxHi                 DB  0
 257+ 0000 ~            prefix1?_BnKProjxSgn                DB  0
 258+ 0000 ~            prefix1?_BnKProjx                   EQU prefix1?_BnKProjxLo
 259+ 0000 ~            prefix1?_BnKProjyLo                 DB  0
 260+ 0000 ~            prefix1?_BnKProjyHi                 DB  0
 261+ 0000 ~            prefix1?_BnKProjySgn                DB  0
 262+ 0000 ~            prefix1?_BnKProjy                   EQU prefix1?_BnKProjyLo
 263+ 0000 ~            prefix1?_BnKProjzLo                 DB  0
 264+ 0000 ~            prefix1?_BnKProjzHi                 DB  0
 265+ 0000 ~            prefix1?_BnKProjzSgn                DB  0
 266+ 0000 ~            prefix1?_BnKProjz                   EQU prefix1?_BnKProjzLo
 267+ 0000 ~            prefix1?_XX25                       EQU prefix1?_BnKProjxLo
 268+ 0000                                          ENDM
 269+ 0000
 270+ 0000              CopyPosToXX15Macro: MACRO   prefix1?
 271+ 0000 ~
 272+ 0000 ~            prefix1?_CopyPosToXX15:    ld hl,prefix1?_Bnkxhi
 273+ 0000 ~                                       ld de,prefix1?_BnkXScaled
 274+ 0000 ~                                       ldi
 275+ 0000 ~                                       ldi
 276+ 0000 ~                                       inc hl ; skip to y high
 277+ 0000 ~                                       ldi
 278+ 0000 ~                                       ldi
 279+ 0000 ~                                       inc hl ; skip to z hig
 280+ 0000 ~                                       ldi
 281+ 0000 ~                                       ldi
 282+ 0000 ~                                       ret
 283+ 0000                                  ENDM
 284+ 0000
 285+ 0000              CopyXX12ScaledToXX18Macro:  MACRO    prefix1?
 286+ 0000 ~            prefix1?_CopyXX12ScaledToXX18:
 287+ 0000 ~            prefix1?_CopyResultToDrawCam:    ld      hl, prefix1?_XX12
 288+ 0000 ~                                             ld      de, prefix1?_XX18
 289+ 0000 ~                                             ldi    ; X12+0 => XX18+0  Set XX18(2 0) = dot_sidev
 290+ 0000 ~                                             inc de ; skip to XX18+2 as it will be on XX18+1
 291+ 0000 ~                                             ldi    ; XX12+1 => XX18+2
 292+ 0000 ~                                             ldi    ; XX12+2 => XX18+3 Set XX12+1 => XX18+2
 293+ 0000 ~                                             inc de ; skip to XX18+5 as it will be on XX18+4
 294+ 0000 ~                                             ldi    ; XX12+3 => XX18+5
 295+ 0000 ~                                             ldi    ; XX12+4 => XX18+6 Set XX18(8 6) = dot_nosev
 296+ 0000 ~                                             inc de ; skip to XX18+8 as it will be on XX18+7
 297+ 0000 ~                                             ldi    ; XX12+5 => XX18+8
 298+ 0000 ~                                             ret
 299+ 0000                                          ENDM
 300+ 0000
 301+ 0000              CopyXX12toXX15Macro:        MACRO    prefix1?
 302+ 0000 ~            prefix1?_CopyXX12toXX15:         ld      hl, prefix1?_BnkXX12xLo
 303+ 0000 ~                                             ld      de, prefix1?_XX18
 304+ 0000 ~                                             ldi      ; xlo
 305+ 0000 ~                                             ldi      ; xsg
 306+ 0000 ~                                             ldi      ; xlo
 307+ 0000 ~                                             ldi      ; xsg
 308+ 0000 ~                                             ldi      ; xlo
 309+ 0000 ~                                             ldi      ; xsg
 310+ 0000 ~                                             ret
 311+ 0000                                          ENDM
 312+ 0000
 313+ 0000              InitialiseUniverseObjMacro: MACRO   prefix1?
 314+ 0000 ~            prefix1?_InitRotMat:    ld      hl, 0
 315+ 0000 ~                                    ld      (prefix1?_BnKrotmatSidevY),hl       ; set the zeroes
 316+ 0000 ~                                    ld      (prefix1?_BnKrotmatSidevZ),hl       ; set the zeroes
 317+ 0000 ~                                    ld      (prefix1?_BnKrotmatRoofvX),hl       ; set the zeroes
 318+ 0000 ~                                    ld      (prefix1?_BnKrotmatRoofvZ),hl       ; set the zeroes
 319+ 0000 ~                                    ld      (prefix1?_BnKrotmatNosevX),hl       ; set the zeroes
 320+ 0000 ~                                    ld      (prefix1?_BnKrotmatNosevY),hl       ; set the zeroes
 321+ 0000 ~            ; Optimised as already have 0 in l
 322+ 0000 ~                                    ld      h, $60	             				; 96 in hi byte
 323+ 0000 ~                                    ;ld      hl,1
 324+ 0000 ~                                    ld      (prefix1?_BnKrotmatSidevX),hl
 325+ 0000 ~                                    ld      (prefix1?_BnKrotmatRoofvY),hl
 326+ 0000 ~            ; Optimised as already have 0 in l
 327+ 0000 ~                                    ld      h, $E0					            ; -96 in hi byte which is +96 with hl bit 7 set
 328+ 0000 ~                                    ld      (prefix1?_BnKrotmatNosevZ),hl
 329+ 0000 ~                                    ret
 330+ 0000                                          ENDM
 331+ 0000
# file closed: ../../Universe/UniverseMacros/UniverseVarsDefineMacro.asm
  43  0000                                      INCLUDE "../../Variables/general_variables_macros.asm"
# file opened: ../../Variables/general_variables_macros.asm
   1+ 0000              ; limited to 255 character length
   2+ 0000              CountLengthHL:          MACRO   Limiter
   3+ 0000 ~                                    ld      de,hl
   4+ 0000 ~                                    ld      bc,Limiter
   5+ 0000 ~                                    xor     a
   6+ 0000 ~                                    cpir
   7+ 0000 ~                                    ClearCarryFlag
   8+ 0000 ~                                    sbc     hl,de
   9+ 0000 ~                                    ld      a,l
  10+ 0000 ~                                    ret
  11+ 0000                                      ENDM
  12+ 0000
  13+ 0000              IncMemMaxN:             MACRO   mem, maxvalue
  14+ 0000 ~                                    ld      a,(mem)
  15+ 0000 ~                                    cp      maxvalue
  16+ 0000 ~                                    jr      c,.IncMaxed
  17+ 0000 ~                                    inc     a
  18+ 0000 ~                                    ld      (mem),a
  19+ 0000 ~            .IncMaxed:
  20+ 0000                                      ENDM
  21+ 0000
  22+ 0000              IncMemMaxNCycle:        MACRO   mem, cyclevalue
  23+ 0000 ~                                    ld      a,(mem)
  24+ 0000 ~                                    inc     a
  25+ 0000 ~                                    cp      cyclevalue
  26+ 0000 ~                                    jr      c,.IncMaxed
  27+ 0000 ~                                    xor     a
  28+ 0000 ~            .IncMaxed:              ld      (mem),a
  29+ 0000                                      ENDM
  30+ 0000
  31+ 0000
  32+ 0000              HalfLengthHL:           MACRO
  33+ 0000 ~                                    ld      b,0
  34+ 0000 ~            .CountLenLoop:          ld      a,(hl)
  35+ 0000 ~                                    cp      0
  36+ 0000 ~                                    jr      z,.DoneCount
  37+ 0000 ~                                    inc     b
  38+ 0000 ~                                    inc     hl
  39+ 0000 ~                                    jr      .CountLenLoop
  40+ 0000 ~            .DoneCount:             ld      a,32
  41+ 0000 ~                                    sub     b
  42+ 0000 ~                                    sra     a
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              MakeInnocentMacro:		MACRO
  46+ 0000 ~            						xor		a
  47+ 0000 ~            						ld		(FugitiveInnocentStatus),a
  48+ 0000              						ENDM
  49+ 0000
  50+ 0000              NoEscapePodMacro:		MACRO
  51+ 0000 ~            						xor		a
  52+ 0000 ~            						ld		(EscapePod),a
  53+ 0000              						ENDM
  54+ 0000
  55+ 0000              MaxFuelLevel            EQU     70              ; 7.0 light years max
  56+ 0000              MaxFuelMacro:			MACRO
  57+ 0000 ~            						ld		a,MaxFuelLevel
  58+ 0000 ~            						ld		(Fuel),a
  59+ 0000              						ENDM
  60+ 0000
  61+ 0000              MaxThrottle:            MACRO
  62+ 0000 ~                                    ld      a,(SHIPMAXSPEED)
  63+ 0000 ~                                    ld      (DELTA),a
  64+ 0000 ~                                    ld      d,a
  65+ 0000 ~                                    ld      e,4
  66+ 0000 ~                                    mul
  67+ 0000 ~                                    ld      (DELT4Lo),de
  68+ 0000                                      ENDM
  69+ 0000
  70+ 0000              ZeroThrottle:           MACRO
  71+ 0000 ~                                    xor     a
  72+ 0000 ~                                    ld      (DELTA),a
  73+ 0000 ~                                    ld      (DELT4Lo),a
  74+ 0000 ~                                    ld      (DELT4Lo+1),a
  75+ 0000                                      ENDM
  76+ 0000
  77+ 0000              ZeroPitch:              MACRO
  78+ 0000 ~                                    xor     a
  79+ 0000 ~                                    ld      (BET2),a
  80+ 0000 ~                                    ld      (BET2FLIP),a
  81+ 0000 ~                                    ld      (JSTY),a
  82+ 0000 ~                                    ld      (BETA),a
  83+ 0000                                      ENDM
  84+ 0000
  85+ 0000              ZeroRoll:               MACRO
  86+ 0000 ~                                    xor     a                              ; zero roll and climb
  87+ 0000 ~                                    ld      (ALP2),a
  88+ 0000 ~                                    ld      (ALP2FLIP),a
  89+ 0000 ~                                    ld      (JSTX),a
  90+ 0000 ~                                    ld      (ALPHA),a
  91+ 0000                                      ENDM
  92+ 0000
  93+ 0000              CorrectPostJumpFuel:    MACRO
  94+ 0000 ~                                    ld      a,(Fuel)
  95+ 0000 ~                                    ld      hl,Distance
  96+ 0000 ~                                    sub     a,(hl)
  97+ 0000 ~                                    ld      (Fuel),a
  98+ 0000                                      ENDM
  99+ 0000
 100+ 0000              AnyMissilesLeft:        MACRO
 101+ 0000 ~                                    ld      a,(NbrMissiles)
 102+ 0000 ~                                    and     a
 103+ 0000                                      ENDM
 104+ 0000
 105+ 0000              SetMissileTargetA:      MACRO
 106+ 0000 ~                                    ld      (MissileTargettingFlag),a   ; Set to slot number clearing bit 7
 107+ 0000                                      ENDM
 108+ 0000
 109+ 0000              IsMissileLaunchFlagged: MACRO
 110+ 0000 ~                                    ld      a,(MissileTargettingFlag)
 111+ 0000 ~                                    and     $80
 112+ 0000                                      ENDM
 113+ 0000
 114+ 0000              SetMissileTargetting:   MACRO
 115+ 0000 ~                                    ld      a,StageMissileTargeting
 116+ 0000 ~                                    ld      (MissileTargettingFlag),a
 117+ 0000                                      ENDM
 118+ 0000
 119+ 0000              ClearMissileTargetting: MACRO
 120+ 0000 ~                                    ld      a,StageMissileNotTargeting
 121+ 0000 ~                                    ld      (MissileTargettingFlag),a
 122+ 0000                                      ENDM
 123+ 0000
 124+ 0000
 125+ 0000              ; Clear targetting bits which signals launch if lower nibble has selected target
 126+ 0000              SetMissileLaunch:       MACRO
 127+ 0000 ~                                    ld      a,(MissileTargettingFlag)
 128+ 0000 ~                                    and     $0F
 129+ 0000 ~                                    ld      (MissileTargettingFlag),a
 130+ 0000                                      ENDM
 131+ 0000
 132+ 0000              LockMissileToA:         MACRO
 133+ 0000 ~                                    or      $80
 134+ 0000 ~                                    ld      (MissileTargettingFlag),a
 135+ 0000                                      ENDM
 136+ 0000
 137+ 0000              ClearECM:               MACRO
 138+ 0000 ~                                    xor     a
 139+ 0000 ~                                    ld      (ECMCountDown),a
 140+ 0000                                      ENDM
 141+ 0000
 142+ 0000
 143+ 0000              ; Will check to see if bit 2 is set, if it is clear, then friendly hence z is set
 144+ 0000              ;                                    if hit is set then hostile hence z is not set
 145+ 0000              IsShipHostile:          MACRO
 146+ 0000 ~                                    ld      a,(ShipNewBitsAddr)
 147+ 0000 ~                                    and     ShipIsHostile
 148+ 0000                                      ENDM
 149+ 0000
 150+ 0000              ; Will check to see if bit 2 is set, if it is clear, then friendly hence z is set
 151+ 0000              ;                                    if hit is set then hostile hence z is not set
 152+ 0000              IsShipFriendly:         MACRO
 153+ 0000 ~                                    ld      a,(ShipNewBitsAddr)
 154+ 0000 ~                                    and     ShipNotHostile                  ; mask so we only have hostile bit
 155+ 0000                                      ENDM
 156+ 0000
 157+ 0000              ; Will check to see if bit 5 is set, if clear, then not exploding z clear
 158+ 0000              ;                                    if set    then exploding     z set
 159+ 0000              IsShipExploding:        MACRO
 160+ 0000 ~                                    ld      a,(UBnkaiatkecm)
 161+ 0000 ~                                    and     ShipExploding
 162+ 0000                                      ENDM
 163+ 0000
 164+ 0000              UpdateLaserOnCounter:   MACRO
 165+ 0000 ~                                    ld      a,(CurrLaserPulseOnCount)
 166+ 0000 ~                                    and     a
 167+ 0000 ~                                    jr      z,.LaserOnIsDone
 168+ 0000 ~                                    dec     a
 169+ 0000 ~                                    ld      (CurrLaserPulseOnCount),a
 170+ 0000 ~                                    jr      z,.LaserOnIsDone
 171+ 0000 ~                                    ldCopyByte CurrLaserPulseOffTime, CurrLaserPulseOffCount
 172+ 0000 ~            .LaserOnIsDone:
 173+ 0000                                      ENDM
 174+ 0000
 175+ 0000              UpdateLaserOffCounter:  MACRO
 176+ 0000 ~                                    ld      a,(CurrLaserPulseOffTime)
 177+ 0000 ~                                    and     a
 178+ 0000 ~                                    jr      z,.LaserOffIsDone
 179+ 0000 ~                                    dec     a
 180+ 0000 ~                                    ld      (CurrLaserPulseOffTime),a
 181+ 0000 ~                                    jr      z,.LaserOffIsDone
 182+ 0000 ~                                    ldCopyByte CurrLaserPulseRest, CurrLaserPulseRestCount
 183+ 0000 ~            .LaserOffIsDone:
 184+ 0000                                      ENDM
 185+ 0000
 186+ 0000              UpdateLaserRestCounter: MACRO
 187+ 0000 ~                                    ld      a,(CurrLaserPulseRestCount)
 188+ 0000 ~                                    and     a
 189+ 0000 ~                                    jr      z,.LaserRestIsDone
 190+ 0000 ~                                    dec     a
 191+ 0000 ~                                    ld      (CurrLaserPulseRestCount),a
 192+ 0000 ~                                    jr      z,.LaserRestIsDone
 193+ 0000 ~                                    ZeroA                                                                           ;    then pulse rate count = 0
 194+ 0000 ~                                    ld      (CurrLaserPulseRateCount),a                                             ;    .
 195+ 0000 ~            .LaserRestIsDone
 196+ 0000                                      ENDM
 197+ 0000
 198+ 0000              ChargeEnergyAndShields: MACRO
 199+ 0000 ~                                    ld      a,$FF
 200+ 0000 ~                                    ld      (PlayerEnergy),a
 201+ 0000 ~                                    ld      (ForeShield),a
 202+ 0000 ~                                    ld      (AftShield),a
 203+ 0000                                      ENDM
 204+ 0000
 205+ 0000              CopyPresentSystemToTarget: MACRO
 206+ 0000 ~                                    ld      hl,(PresentSystemX)
 207+ 0000 ~                                    ld      (TargetSystemX),hl
 208+ 0000                                      ENDM
 209+ 0000
 210+ 0000              CopyTargetSystemToPresent: MACRO
 211+ 0000 ~                                    ld      hl,(TargetSystemX)
 212+ 0000 ~                                    ld      (PresentSystemX),hl
 213+ 0000                                      ENDM
 214+ 0000
 215+ 0000              HalveFugitiveStatus:    MACRO
 216+ 0000 ~                                    ld      hl,FugitiveInnocentStatus
 217+ 0000 ~                                    srl     (hl)
 218+ 0000                                      ENDM
 219+ 0000
 220+ 0000              ClearForceTransition    MACRO
 221+ 0000 ~                                    ld      a,$FF
 222+ 0000 ~                                    ld      (ScreenTransitionForced),a
 223+ 0000                                      ENDM
 224+ 0000
 225+ 0000              ForceTransition:        MACRO newScreen
 226+ 0000 ~                                    ld      a,newScreen
 227+ 0000 ~                                    ld      (ScreenTransitionForced), a
 228+ 0000                                      ENDM
 229+ 0000
 230+ 0000              IsSpaceStationPresent:  MACRO
 231+ 0000 ~                                    ld      a,(SpaceStationSafeZone)
 232+ 0000 ~                                    and     a
 233+ 0000                                      ENDM
 234+ 0000
 235+ 0000              SetSafeZone:            MACRO
 236+ 0000 ~                                    xor     a
 237+ 0000 ~                                    ld      (SpaceStationSafeZone),a
 238+ 0000                                      ENDM
 239+ 0000
 240+ 0000              ClearSafeZone:          MACRO
 241+ 0000 ~                                    ld      a,$FF
 242+ 0000 ~                                    ld      (SpaceStationSafeZone),a
 243+ 0000                                      ENDM
 244+ 0000
 245+ 0000              ClearTemperatures:      MACRO
 246+ 0000 ~                                    xor     a
 247+ 0000 ~                                    ld      (CabinTemperature),a
 248+ 0000 ~                                    ld      (GunTemperature),a
 249+ 0000                                      ENDM
 250+ 0000
 251+ 0000              ClearWarpPressed:       MACRO
 252+ 0000 ~                                    SetMemFalse WarpPressed
 253+ 0000                                      ENDM
 254+ 0000
 255+ 0000              CoolCabin:              MACRO
 256+ 0000 ~                                    ld      a,(CabinTemperature)
 257+ 0000 ~                                    and     a
 258+ 0000 ~                                    jr      z,.AlreadyCool
 259+ 0000 ~                                    dec     a
 260+ 0000 ~                                    ld      (CabinTemperature),a
 261+ 0000 ~            .AlreadyCool:
 262+ 0000                                      ENDM
 263+ 0000
 264+ 0000              CoolLasers:             MACRO
 265+ 0000 ~                                    ld      a,(GunTemperature)
 266+ 0000 ~                                    and     a
 267+ 0000 ~                                    jr      z,.AlreadyCool
 268+ 0000 ~                                    dec     a
 269+ 0000 ~                                    ld      (GunTemperature),a
 270+ 0000 ~            .AlreadyCool:
 271+ 0000                                      ENDM
 272+ 0000
 273+ 0000              ; type 255 is "not fitted"
 274+ 0000
 275+ 0000
 276+ 0000              InitEventCounter:       MACRO
 277+ 0000 ~                                    xor     a
 278+ 0000 ~                                    ld      (EventCounter),a
 279+ 0000                                      ENDM
 280+ 0000
 281+ 0000              ClearMissJump:          MACRO
 282+ 0000 ~                                    ld      a,$FF
 283+ 0000 ~                                    ld      (MissJumpFlag),a
 284+ 0000                                      ENDM
 285+ 0000
 286+ 0000
 287+ 0000              DrainSystem:            MACRO   SystemMem, DrainMem
 288+ 0000 ~                                    ld      a,(DrainMem)
 289+ 0000 ~                                    ld      b,a
 290+ 0000 ~                                    ld      a,(SystemMem)
 291+ 0000 ~                                    sub     a,b
 292+ 0000 ~                                    ld      (SystemMem),a
 293+ 0000 ~                                    jr      c,.ZeroSystem
 294+ 0000 ~                                    jp      .ExitPoint
 295+ 0000 ~            .ZeroSystem:            ZeroA
 296+ 0000 ~                                    ld      (SystemMem),a
 297+ 0000 ~            .ExitPoint
 298+ 0000                                      ENDM
 299+ 0000
 300+ 0000              BoostSystem:            MACRO   SystemMem, BoostMem
 301+ 0000 ~                                    ld      a,(BoostMem)
 302+ 0000 ~                                    ld      b,a
 303+ 0000 ~                                    ld      a,(SystemMem)
 304+ 0000 ~                                    add     b
 305+ 0000 ~                                    ld      (SystemMem),a
 306+ 0000 ~                                    jr      c, .MaxSystem
 307+ 0000 ~                                    jp      .ExitPoint
 308+ 0000 ~            .MaxSystem:             ld      a,255
 309+ 0000 ~                                    ld      (SystemMem),a
 310+ 0000 ~            .ExitPoint
 311+ 0000                                      ENDM
 312+ 0000
 313+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER HasEngineSoundChanged:  MACRO
 314+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ld      a,(EngineSoundChanged)
 315+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         and     a
 316+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ENDM
 317+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER
 318+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER ClearEngineSoundChanged:MACRO
 319+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         xor      a
 320+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ld      (EngineSoundChanged),a
 321+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ENDM
 322+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER
 323+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER SetEngineSoundChanged:  MACRO
 324+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ld      a,$FF
 325+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ld      (EngineSoundChanged),a
 326+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ENDM
 327+ 0000
# file closed: ../../Variables/general_variables_macros.asm
  44  0000                                      INCLUDE "../../Variables/UniverseSlot_macros.asm"
# file opened: ../../Variables/UniverseSlot_macros.asm
   1+ 0000
   2+ 0000              AddJunkCount:           MACRO
   3+ 0000 ~                                    ld      hl,JunkCount
   4+ 0000 ~                                    inc     (hl)
   5+ 0000                                      ENDM
   6+ 0000
   7+ 0000              SubJunkCount:           MACRO
   8+ 0000 ~                                    ld      hl,JunkCount
   9+ 0000 ~                                    dec     (hl)
  10+ 0000                                      ENDM
  11+ 0000
  12+ 0000              ClearJunkCount:         MACRO
  13+ 0000 ~                                    ZeroA
  14+ 0000 ~                                    ld      (JunkCount),a
  15+ 0000                                      ENDM
  16+ 0000
  17+ 0000              AddCop:                 MACRO
  18+ 0000 ~                                    ld      hl,CopCount
  19+ 0000 ~                                    inc     (hl)
  20+ 0000                                      ENDM
  21+ 0000
  22+ 0000              SubCop:                 MACRO
  23+ 0000 ~                                    ld      hl,CopCount
  24+ 0000 ~                                    dec     (hl)
  25+ 0000                                      ENDM
  26+ 0000
  27+ 0000              AddPirateCount:         MACRO
  28+ 0000 ~                                    ld      hl,PirateCount
  29+ 0000 ~                                    inc     (hl)
  30+ 0000                                      ENDM
  31+ 0000
  32+ 0000              SubPirateCount:         MACRO
  33+ 0000 ~                                    ld      hl,PirateCount
  34+ 0000 ~                                    inc     (hl)
  35+ 0000                                      ENDM
  36+ 0000
  37+ 0000              AreCopsPresent:         MACRO
  38+ 0000 ~                                    ld      a,(CopCount)
  39+ 0000 ~                                    and     a
  40+ 0000                                      ENDM
  41+ 0000
  42+ 0000              ; Class == shiptype
  43+ 0000              SetSlotAToUnivClass:    MACRO
  44+ 0000 ~                                    ex      af,af'
  45+ 0000 ~                                    ld      a,(ShipTypeAddr)
  46+ 0000 ~                                    ld      b,a
  47+ 0000 ~                                    ex      af,af'
  48+ 0000 ~                                    call    SetSlotAToClassB
  49+ 0000                                      ENDM
  50+ 0000
  51+ 0000              TestRoomForJunk:        MACRO   Target
  52+ 0000 ~                                    ld      a,3
  53+ 0000 ~                                    JumpIfMemTrue  SpaceStationSafeZone, .DoTest
  54+ 0000 ~                                    add     a,2
  55+ 0000 ~            .DoTest                 JumpIfALTMemusng    JunkCount, Target
  56+ 0000                                      ENDM
  57+ 0000
  58+ 0000              JumpIfSpaceStation:     MACRO   Target
  59+ 0000 ~                                    ld      hl,UniverseSlotType
  60+ 0000 ~                                    ld      a,(hl)
  61+ 0000 ~                                    cp      ShipTypeStation
  62+ 0000                                      ENDM
  63+ 0000
  64+ 0000              ClearSlotMem:           MACRO   mem
  65+ 0000 ~                                    ld      a,(mem)
  66+ 0000 ~                                    call    ClearSlotA
  67+ 0000                                      ENDM
  68+ 0000
  69+ 0000              IsSlotEmpty:            MACRO
  70+ 0000 ~                                    ld      hl,UniverseSlotList
  71+ 0000 ~                                    add     hl,a
  72+ 0000 ~                                    ld      a,(hl)
  73+ 0000 ~                                    cp      0
  74+ 0000                                      ENDM
  75+ 0000
  76+ 0000              IsSlotMissile:          MACRO
  77+ 0000 ~                                    ld      hl,UniverseSlotType
  78+ 0000 ~                                    add     hl,a
  79+ 0000 ~                                    ld      a,(hl)
  80+ 0000 ~                                    cp      ShipTypeMissile
  81+ 0000                                      ENDM
  82+ 0000
  83+ 0000
  84+ 0000              ; Checks if slot is empty else A = ship type
  85+ 0000              ReturnIfSlotAEmpty:     MACRO
  86+ 0000 ~                                    ld      hl,UniverseSlotList
  87+ 0000 ~                                    add     hl,a
  88+ 0000 ~                                    ld      a,(hl)
  89+ 0000 ~                                    inc     a
  90+ 0000 ~                                    ret     z           ; if slot was ff inc would make it 0
  91+ 0000 ~                                    dec     a           ; get original value back for later
  92+ 0000                                      ENDM
  93+ 0000
  94+ 0000              JumpIfSlotAEmpty:       MACRO   Target
  95+ 0000 ~                                    ld      hl,UniverseSlotList
  96+ 0000 ~                                    add     hl,a
  97+ 0000 ~                                    ld      a,(hl)
  98+ 0000 ~                                    inc     a
  99+ 0000 ~                                    jp      z,Target    ; if slot was ff inc would make it 0
 100+ 0000 ~                                    dec     a           ; get original value back for later
 101+ 0000                                      ENDM
 102+ 0000
 103+ 0000              JumpIfSlotHLEmpty:      MACRO   Target
 104+ 0000 ~                                    ld      a,(hl)
 105+ 0000 ~                                    and     a
 106+ 0000 ~                                    jr      nz,Target
 107+ 0000                                      ENDM
# file closed: ../../Variables/UniverseSlot_macros.asm
  45  0000                                      INCLUDE "../../Data/ShipIdEquates.asm"
# file opened: ../../Data/ShipIdEquates.asm
   1+ 0000
   2+ 0000
   3+ 0000
   4+ 0000              ShipID_Adder            EQU 00
   5+ 0000              ShipID_Anaconda         EQU 01
   6+ 0000              ShipID_Asp_Mk_2         EQU 02
   7+ 0000              ShipID_Boa              EQU 03
   8+ 0000              ShipID_CargoType5       EQU 04
   9+ 0000              ShipID_Boulder          EQU 05
  10+ 0000              ShipID_Asteroid         EQU 06
  11+ 0000              ShipID_Bushmaster       EQU 07
  12+ 0000              ShipID_Chameleon        EQU 08
  13+ 0000              ShipID_CobraMk3         EQU 09
  14+ 0000              ShipID_Cobra_Mk_1       EQU 10
  15+ 0000              ShipID_Cobra_Mk_3_P     EQU 11
  16+ 0000              ShipID_Constrictor      EQU 12
  17+ 0000              ShipID_Coriolis         EQU 13
  18+ 0000              ShipID_Cougar           EQU 14
  19+ 0000              ShipID_Dodo             EQU 15
  20+ 0000              ShipID_Dragon           EQU 16
  21+ 0000              ShipID_Escape_Pod       EQU 17
  22+ 0000              ShipID_Fer_De_Lance     EQU 18
  23+ 0000              ShipID_Gecko            EQU 19
  24+ 0000              ShipID_Ghavial          EQU 20
  25+ 0000              ShipID_Iguana           EQU 21
  26+ 0000              ShipID_Krait            EQU 22
  27+ 0000              ShipID_Logo             EQU 23
  28+ 0000              ShipID_Mamba            EQU 24
  29+ 0000              ShipID_Missile          EQU 25
  30+ 0000              ShipID_Monitor          EQU 26
  31+ 0000              ShipID_Moray            EQU 27
  32+ 0000              ShipID_Ophidian         EQU 28
  33+ 0000              ShipID_Plate            EQU 29
  34+ 0000              ShipID_Python           EQU 30
  35+ 0000              ShipID_Python_P         EQU 31
  36+ 0000              ShipID_Rock_Hermit      EQU 32
  37+ 0000              ShipID_ShuttleType9     EQU 33
  38+ 0000              ShipID_Shuttle_Mk_2     EQU 34
  39+ 0000              ShipID_Sidewinder       EQU 35
  40+ 0000              ShipID_Splinter         EQU 36
  41+ 0000              ShipID_TestVector       EQU 37
  42+ 0000              ShipID_Thargoid         EQU 38
  43+ 0000              ShipID_Thargon          EQU 39
  44+ 0000              ShipID_TransportType10  EQU 40
  45+ 0000              ShipID_Viper            EQU 41
  46+ 0000              ShipID_Worm             EQU 42
  47+ 0000              ShipID_Rattler          EQU 43
  48+ 0000
# file closed: ../../Data/ShipIdEquates.asm
  46  0000
  47  0000              MessageAt:              MACRO   x,y,message
  48  0000 ~                                    MMUSelectLayer1
  49  0000 ~                                    ld      d,y
  50  0000 ~                                    ld      e,x
  51  0000 ~                                    ld      hl,message
  52  0000 ~                                    call    l1_print_at_wrap
  53  0000                                      ENDM
  54  0000
  55  0000              SetBorder:              MACRO   value
  56  0000 ~                                    MMUSelectLayer1
  57  0000 ~                                    ld          a,value
  58  0000 ~                                    call        l1_set_border
  59  0000                                      ENDM
  60  0000
  61  0000              charactersetaddr		equ 15360
  62  0000              STEPDEBUG               equ 1
  63  0000
  64  0000              TopOfStack              equ $5CCB ;$6100
  65  0000
  66  0000                                      ORG $5DCB;      $6200
  67  5DCB F3           EliteNextStartup:       di
  68  5DCC ED 91 07 03  .InitialiseClockSpeed:  nextreg     TURBO_MODE_REGISTER,Speed_28MHZ
  69  5DD0              .InitialiseLayerOrder:
  70  5DD0                                      DISPLAY "Starting Assembly At ", EliteNextStartup
  71  5DD0                                      ; "STARTUP"
  72  5DD0                                      ; Make sure  rom is in page 0 during load
  73  5DD0                                      MMUSelectLayer2
  73  5DD0 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
  74  5DD4 CD 0F E0                             call        asm_disable_l2_readwrite
  75  5DD7                                      MMUSelectROMS
  75  5DD7 ED 91 50 FF >                     nextreg EXSDOSMMU0,        BankROM
  75  5DDB ED 91 51 FF >                     nextreg EXSDOSMMU1,        BankROM
  76  5DDF                                      MMUSelectLayer1
  76  5DDF ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
  77  5DE3 CD 8F E0                             call		l1_cls
  78  5DE6 3E 07                                ld			a,7
  79  5DE8 CD AA E0                             call		l1_attr_cls_to_a
  80  5DEB                                      SetBorder   $FF
  80  5DEB             >                        MMUSelectLayer1
  80  5DEB ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
  80  5DEF 3E FF       >                        ld          a,$FF
  80  5DF1 CD B4 E0    >                        call        l1_set_border
  81  5DF4              .InitialiseL2:          MMUSelectLayer2
  81  5DF4 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
  82  5DF8 CD 45 E2                             call 		l2_initialise
  83  5DFB CD 04 E0                             call        asm_l2_double_buffer_on
  84  5DFE CD 0E E2                             call        l2_cls
  85  5E01 CD 6F E2                             call        l2_flip_buffers
  86  5E04 CD 0E E2                             call        l2_cls
  87  5E07              .InitialisingMessage:   MMUSelectUniverseN  0
  87  5E07 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
  88  5E0B CD 6A 6C     InitialiseMainLoop:     call        ClearUnivSlotList
  89  5E0E CD 36 63                             call        SelectShip
  90  5E11                                      MMUSelectKeyboard
  90  5E11 ED 91 57 65 >                     nextreg KeyboardMMU,       BankKeyboard
  91  5E15 CD F7 E0                             call        init_keyboard
  92  5E18                                      ZeroA
  92  5E18 AF          >                        xor a
  93  5E19 32 76 68                             ld          (JSTX),a
  94  5E1C 32 6C 68                             ld          (JSTY),a
  95  5E1F C3 8C 5F                             jp          MainLoop
  96  5E22              TestNormalise:          MMUSelectMathsBankedFns
  96  5E22 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
  97  5E26 DD 21 55 5E                          ld          ix,TestVec1
  98  5E2A CD A0 76                             call        NormaliseIXVector
  99  5E2D DD 21 65 5E                          ld          ix,TestVec2
 100  5E31 CD A0 76                             call        NormaliseIXVector
 101  5E34 DD 21 75 5E                          ld          ix,TestVec3
 102  5E38 CD A0 76                             call        NormaliseIXVector
 103  5E3B DD 21 85 5E                          ld          ix,TestVec4
 104  5E3F CD A0 76                             call        NormaliseIXVector
 105  5E42 DD 21 95 5E                          ld          ix,TestVec5
 106  5E46 CD A0 76                             call        NormaliseIXVector
 107  5E49 DD 21 A5 5E                          ld          ix,TestVec6
 108  5E4D CD A0 76                             call        NormaliseIXVector
 109  5E50 DD 01        .SpinKeyboard:          break
 110  5E52 C3 B5 5E                             jp          TestTidy
 111  5E55 00 60 00 00  TestVec1:               DW  $6000, $0000, $0000, $0, $0, $0, $0, $0
 111  5E59 00 00 00 00
 111  5E5D 00 00 00 00
 111  5E61 00 00 00 00
 112  5E65 00 30 00 20  TestVec2:               DW  $3000, $2000, $0000, $0, $0, $0, $0, $0
 112  5E69 00 00 00 00
 112  5E6D 00 00 00 00
 112  5E71 00 00 00 00
 113  5E75 00 00 00 00  TestVec3:               DW  $0000, $0000, $E000, $0, $0, $0, $0, $0
 113  5E79 00 E0 00 00
 113  5E7D 00 00 00 00
 113  5E81 00 00 00 00
 114  5E85 00 60 00 60  TestVec4:               DW  $6000, $6000, $0000, $0, $0, $0, $0, $0
 114  5E89 00 00 00 00
 114  5E8D 00 00 00 00
 114  5E91 00 00 00 00
 115  5E95 00 00 00 00  TestVec5:               DW  $0000, $0000, $1000, $0, $0, $0, $0, $0
 115  5E99 00 10 00 00
 115  5E9D 00 00 00 00
 115  5EA1 00 00 00 00
 116  5EA5 50 34 50 24  TestVec6:               DW  $3450, $2450, $3E00, $0, $0, $0, $0, $0
 116  5EA9 00 3E 00 00
 116  5EAD 00 00 00 00
 116  5EB1 00 00 00 00
 117  5EB5              TestTidy:               MMUSelectMathsBankedFns
 117  5EB5 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 118  5EB9                                      MMUSelectUniverseN 0
 118  5EB9 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 119  5EBD 21 20 5F                             ld          hl,TestMatrix1
 119  5EC0 11 29 C0       ld de, UBnkrotmatSidevX
 119  5EC3 01 12 00       ld bc, 2 * 9
 119  5EC6 ED B0          ldir
 120  5EC8 CD F9 7A                             call        TidyVectorsIX
 121  5ECB DD 01                                break
 122  5ECD 21 32 5F                             ld          hl,TestMatrix2
 122  5ED0 11 29 C0       ld de, UBnkrotmatSidevX
 122  5ED3 01 12 00       ld bc, 2 * 9
 122  5ED6 ED B0          ldir
 123  5ED8 CD F9 7A                             call        TidyVectorsIX
 124  5EDB DD 01                                break
 125  5EDD 21 44 5F                             ld          hl,TestMatrix3
 125  5EE0 11 29 C0       ld de, UBnkrotmatSidevX
 125  5EE3 01 12 00       ld bc, 2 * 9
 125  5EE6 ED B0          ldir
 126  5EE8 CD F9 7A                             call        TidyVectorsIX
 127  5EEB DD 01                                break
 128  5EED 21 56 5F                             ld          hl,TestMatrix4
 128  5EF0 11 29 C0       ld de, UBnkrotmatSidevX
 128  5EF3 01 12 00       ld bc, 2 * 9
 128  5EF6 ED B0          ldir
 129  5EF8 CD F9 7A                             call        TidyVectorsIX
 130  5EFB DD 01                                break
 131  5EFD 21 68 5F                             ld          hl,TestMatrix5
 131  5F00 11 29 C0       ld de, UBnkrotmatSidevX
 131  5F03 01 12 00       ld bc, 2 * 9
 131  5F06 ED B0          ldir
 132  5F08 CD F9 7A                             call        TidyVectorsIX
 133  5F0B DD 01                                break
 134  5F0D 21 7A 5F                             ld          hl,TestMatrix6
 134  5F10 11 29 C0       ld de, UBnkrotmatSidevX
 134  5F13 01 12 00       ld bc, 2 * 9
 134  5F16 ED B0          ldir
 135  5F18 CD F9 7A                             call        TidyVectorsIX
 136  5F1B DD 01                                break
 137  5F1D C3 8C 5F                             jp          MainLoop
 138  5F20                                      ;   SIDEV                ROOFV                NOSEV
 139  5F20 00 00 00 00  TestMatrix1:            DW  $0000, $0000, $E000, $0000, $6000, $0000, $6000, $0000, $0000
 139  5F24 00 E0 00 00
 139  5F28 00 60 00 00
 139  5F2C 00 60 00 00
 139  5F30 00 00
 140  5F32 00 00 00 00  TestMatrix2:            DW  $0000, $0000, $E000, $0000, $5EEC, $0000, $6000, $0000, $0000
 140  5F36 00 E0 00 00
 140  5F3A EC 5E 00 00
 140  5F3E 00 60 00 00
 140  5F42 00 00
 141  5F44 00 00 00 00  TestMatrix3:            DW  $0000, $0000, $E000, $0000, $5EEC, $0000, $3000, $3000, $3000
 141  5F48 00 E0 00 00
 141  5F4C EC 5E 00 00
 141  5F50 00 30 00 30
 141  5F54 00 30
 142  5F56 00 00 00 00  TestMatrix4:            DW  $0000, $0000, $E000, $0000, $6000, $0000, $5000, $0000, $0000
 142  5F5A 00 E0 00 00
 142  5F5E 00 60 00 00
 142  5F62 00 50 00 00
 142  5F66 00 00
 143  5F68 00 00 00 00  TestMatrix5:            DW  $0000, $0000, $E000, $0000, $5500, $0000, $6000, $0000, $0000
 143  5F6C 00 E0 00 00
 143  5F70 00 55 00 00
 143  5F74 00 60 00 00
 143  5F78 00 00
 144  5F7A 00 00 00 00  TestMatrix6:            DW  $0000, $0000, $E100, $0000, $6000, $0000, $6000, $0000, $0000
 144  5F7E 00 E1 00 00
 144  5F82 00 60 00 00
 144  5F86 00 60 00 00
 144  5F8A 00 00
 145  5F8C              ;...................................................................................................................................
 146  5F8C              MainLoop:	            MMUSelectMathsBankedFns                                         ; make sure we are in maths routines in case a save paged out
 146  5F8C ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 147  5F90 CD 36 6D                             call    doRandom                                                ; redo the seeds every frame
 148  5F93              ;.. Check if keyboard scanning is allowed by screen. If this is set then skip all keyboard and AI..................................
 149  5F93              InputBlockerCheck:      MMUSelectKeyboard
 149  5F93 ED 91 57 65 >                     nextreg KeyboardMMU,       BankKeyboard
 150  5F97 CD 03 E1                             call    scan_keyboard
 151  5F9A              ;-- Key Definitions
 152  5F9A              ; Player Pitcn and Roll
 153  5F9A              ;   Q/A pitch       O/P roll        W/A Thrust
 154  5F9A 3E 0A                                ld      a,VK_Q
 155  5F9C CD 84 E1                             call    is_vkey_held
 156  5F9F C4 E0 60                             call    nz, PressedPitchPlus
 157  5FA2
 158  5FA2 3E 05                                ld      a,VK_A
 159  5FA4 CD 84 E1                             call    is_vkey_held
 160  5FA7 C4 ED 60                             call    nz, PressedPitchMinus
 161  5FAA
 162  5FAA 3E 1A                                ld      a,VK_O
 163  5FAC CD 84 E1                             call    is_vkey_held
 164  5FAF C4 FA 60                             call    nz, PressedRollPlus
 165  5FB2
 166  5FB2 3E 19                                ld      a,VK_P
 167  5FB4 CD 84 E1                             call    is_vkey_held
 168  5FB7 C4 07 61                             call    nz, PressedRollMinus
 169  5FBA
 170  5FBA              ;   N   Cycle through ships
 171  5FBA 3E 26                                ld      a,VK_N
 172  5FBC CD 8D E1                             call    is_vkey_pressed
 173  5FBF CC 36 63                             call    z, SelectShip
 174  5FC2              ; Tidy and Normalise Vector
 175  5FC2 3E 04                                ld      a,VK_V
 176  5FC4 CD 8D E1                             call    is_vkey_pressed
 177  5FC7 CC F9 7A                             call    z, TidyVectorsIX
 178  5FCA              ; Ship Pitch and Roll T/G ship pitch, F/H ship roll   U/J Ship Thrust
 179  5FCA                                      MMUSelectKeyboard
 179  5FCA ED 91 57 65 >                     nextreg KeyboardMMU,       BankKeyboard
 180  5FCE 3E 0E                                ld      a,VK_T
 181  5FD0 CD 84 E1                             call    is_vkey_held
 182  5FD3 C4 B8 60                             call    nz, PressedSPitchPlus
 183  5FD6
 184  5FD6 3E 09                                ld      a,VK_G
 185  5FD8 CD 84 E1                             call    is_vkey_held
 186  5FDB C4 C2 60                             call    nz, PressedSPitchMinus
 187  5FDE
 188  5FDE 3E 08                                ld      a,VK_F
 189  5FE0 CD 84 E1                             call    is_vkey_held
 190  5FE3 C4 CC 60                             call    nz, PressedSRollPlus
 191  5FE6
 192  5FE6 3E 22                                ld      a,VK_H
 193  5FE8 CD 84 E1                             call    is_vkey_held
 194  5FEB C4 D6 60                             call    nz, PressedSRollMinus
 195  5FEE
 196  5FEE              ; PanKeys 1 + y  2 -y  3 +x 4 -x 5 +z 6 -z
 197  5FEE 3E 13                                ld      a,VK_5
 198  5FF0 CD 84 E1                             call    is_vkey_held
 199  5FF3 C4 40 60                             call    nz, PressedZPlus
 200  5FF6
 201  5FF6 3E 18                                ld      a,VK_6
 202  5FF8 CD 84 E1                             call    is_vkey_held
 203  5FFB C4 54 60                             call    nz, PressedZMinus
 204  5FFE
 205  5FFE 3E 11                                ld      a,VK_3
 206  6000 CD 84 E1                             call    is_vkey_held
 207  6003 C4 68 60                             call    nz, PressedXPlus
 208  6006
 209  6006 3E 12                                ld      a,VK_4
 210  6008 CD 84 E1                             call    is_vkey_held
 211  600B C4 7C 60                             call    nz, PressedXMinus
 212  600E
 213  600E 3E 0F                                ld      a,VK_1
 214  6010 CD 84 E1                             call    is_vkey_held
 215  6013 C4 90 60                             call    nz, PressedYPlus
 216  6016
 217  6016 3E 10                                ld      a,VK_2
 218  6018 CD 84 E1                             call    is_vkey_held
 219  601B C4 A4 60                             call    nz, PressedYMinus
 220  601E              ;.. Update values based on movekey keys, may likley need damping as this coudl be very fast
 221  601E CD 65 61     UpdateShipsControl:     call    UpdateUniverseObjects
 222  6021              .JustViewPortCLS:       MMUSelectLayer2
 222  6021 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 223  6025 CD 0E E2                             call    l2_cls
 224  6028              ;.. Render Ship ...................................................................................................................
 225  6028              DrawForwardsShips:
 226  6028 AF           DrawShip:               xor     a
 227  6029 32 64 61     .DrawShipLoop:          ld      (CurrentShipUniv),a
 228  602C CD 0F 6D                             call    GetTypeAtSlotA
 229  602F              .SelectShipToDraw:      MMUSelectUniverseN 0
 229  602F ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 230  6033 CD 14 D9     .ProcessUnivShip:       call    ProcessShip          ; The whole explosion logic is now encapsulated in process ship ;TODO TUNE THIS   ;; call    ProcessUnivShip
 231  6036              ;.. Flip Buffer ...................................................................................................................
 232  6036              DoubleBufferCheck:      MMUSelectLayer2
 232  6036 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 233  603A CD 6F E2                             call    l2_flip_buffers
 234  603D C3 8C 5F                             jp MainLoop
 235  6040              ;.. Keyboard Routines .............................................................................................................
 236  6040              PressedZPlus:           MMUSelectUniverseN 0
 236  6040 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 237  6044 DD 21 26 C0                          ld      ix,UBnKzlo
 238  6048 FD 21 CA 62                          ld      iy,Plus20
 239  604C                                      MMUSelectMathsBankedFns
 239  604C ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 239  6050 CD 90 00       call    AddAtIXtoAtIY24Signed
 240  6053 C9                                   ret
 241  6054
 242  6054              PressedZMinus:          MMUSelectUniverseN 0
 242  6054 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 243  6058 DD 21 26 C0                          ld      ix,UBnKzlo
 244  605C FD 21 CD 62                          ld      iy,Minus20
 245  6060                                      MMUSelectMathsBankedFns
 245  6060 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 245  6064 CD 90 00       call    AddAtIXtoAtIY24Signed
 246  6067 C9                                   ret
 247  6068
 248  6068              PressedXPlus:           MMUSelectUniverseN 0
 248  6068 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 249  606C DD 21 20 C0                          ld      ix,UBnKxlo
 250  6070 FD 21 CA 62                          ld      iy,Plus20
 251  6074                                      MMUSelectMathsBankedFns
 251  6074 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 251  6078 CD 90 00       call    AddAtIXtoAtIY24Signed
 252  607B C9                                   ret
 253  607C
 254  607C              PressedXMinus:          MMUSelectUniverseN 0
 254  607C ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 255  6080 DD 21 20 C0                          ld      ix,UBnKxlo
 256  6084 FD 21 CD 62                          ld      iy,Minus20
 257  6088                                      MMUSelectMathsBankedFns
 257  6088 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 257  608C CD 90 00       call    AddAtIXtoAtIY24Signed
 258  608F C9                                   ret
 259  6090
 260  6090              PressedYPlus:           MMUSelectUniverseN 0
 260  6090 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 261  6094 DD 21 23 C0                          ld      ix,UBnKylo
 262  6098 FD 21 CA 62                          ld      iy,Plus20
 263  609C                                      MMUSelectMathsBankedFns
 263  609C ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 263  60A0 CD 90 00       call    AddAtIXtoAtIY24Signed
 264  60A3 C9                                   ret
 265  60A4
 266  60A4              PressedYMinus:          MMUSelectUniverseN 0
 266  60A4 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 267  60A8 DD 21 23 C0                          ld      ix,UBnKylo
 268  60AC FD 21 CD 62                          ld      iy,Minus20
 269  60B0                                      MMUSelectMathsBankedFns
 269  60B0 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 269  60B4 CD 90 00       call    AddAtIXtoAtIY24Signed
 270  60B7 C9                                   ret
 271  60B8
 272  60B8              PressedSPitchPlus:      MMUSelectUniverseN 0
 272  60B8 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 273  60BC 3E 0A                                ld      a,10
 274  60BE 32 49 C0                             ld      (UBnKRotZCounter),a
 275  60C1 C9                                   ret
 276  60C2
 277  60C2              PressedSPitchMinus:     MMUSelectUniverseN 0
 277  60C2 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 278  60C6 3E 8A                                ld      a,$80+10
 279  60C8 32 49 C0                             ld      (UBnKRotZCounter),a
 280  60CB C9                                   ret
 281  60CC
 282  60CC              PressedSRollPlus:       MMUSelectUniverseN 0
 282  60CC ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 283  60D0 3E 0A                                ld      a,10
 284  60D2 32 48 C0                             ld      (UBnKRotXCounter),a
 285  60D5 C9                                   ret
 286  60D6
 287  60D6              PressedSRollMinus:      MMUSelectUniverseN 0
 287  60D6 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 288  60DA 3E 8A                                ld      a,$80+10
 289  60DC 32 48 C0                             ld      (UBnKRotXCounter),a
 290  60DF C9                                   ret
 291  60E0
 292  60E0              PressedPitchPlus:       MMUSelectUniverseN 0
 292  60E0 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 293  60E4 3E 14                                ld      a,20
 294  60E6 32 6C 68                             ld      (JSTY),a
 295  60E9 CD 3C 61                             call    draw_front_calc_beta
 296  60EC C9                                   ret
 297  60ED
 298  60ED              PressedPitchMinus:      MMUSelectUniverseN 0
 298  60ED ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 299  60F1 3E EC                                ld      a,-20
 300  60F3 32 6C 68                             ld      (JSTY),a
 301  60F6 CD 3C 61                             call    draw_front_calc_beta
 302  60F9 C9                                   ret
 303  60FA
 304  60FA              PressedRollPlus:        MMUSelectUniverseN 0
 304  60FA ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 305  60FE 3E 3C                                ld      a,60
 306  6100 32 76 68                             ld      (JSTX),a
 307  6103 CD 14 61                             call    draw_front_calc_alpha
 308  6106 C9                                   ret
 309  6107
 310  6107              PressedRollMinus:       MMUSelectUniverseN 0
 310  6107 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 311  610B 3E C4                                ld      a,-60
 312  610D 32 76 68                             ld      (JSTX),a
 313  6110 CD 14 61                             call    draw_front_calc_alpha
 314  6113 C9                                   ret
 315  6114
 316  6114 47           draw_front_calc_alpha:  ld      b,a
 317  6115 E6 80                                and     $80
 318  6117 32 7A 68                             ld      (ALP2),a                            ; set sign
 319  611A 4F                                   ld      c,a                                 ; save sign
 320  611B EE 80                                xor     $80
 321  611D 32 7B 68                             ld      (ALP2FLIP),a                        ; and oppsite sign
 322  6120 3A 76 68                             ld      a,(JSTX)
 323  6123 ED 27 80                             test    $80
 324  6126 28 02                                jr      z,  .PositiveRoll
 325  6128 ED 44        .NegativeRoll:          neg
 326  612A CB 3F        .PositiveRoll           srl     a                                   ; divide sign by 4
 327  612C CB 3F                                srl     a
 328  612E FE 08                                cp      8
 329  6130 38 02                                jr      c,.NotIncreasedDamp                 ; if a < 8 divide by 2 again
 330  6132 CB 3F        .IncreasedDamp          srl     a
 331  6134 32 79 68     .NotIncreasedDamp:      ld      (ALP1),a
 332  6137 B1                                   or      c
 333  6138 32 78 68                             ld      (ALPHA),a                           ; a = signed bit alph1
 334  613B C9                                   ret
 335  613C
 336  613C              ; Do the same for pitch
 337  613C 47           draw_front_calc_beta:   ld      b,a
 338  613D E6 80                                and     $80
 339  613F 32 6E 68                             ld      (BET2),a                            ; set sign
 340  6142 4F                                   ld      c,a                                 ; save sign
 341  6143 EE 80                                xor     $80
 342  6145 32 6F 68                             ld      (BET2FLIP),a                        ; and oppsite sign
 343  6148 3A 6C 68                             ld      a,(JSTY)
 344  614B ED 27 80                             test    $80
 345  614E 28 02                                jr      z,  .PositivePitch
 346  6150 ED 44        .NegativePitch:         neg
 347  6152 CB 3F        .PositivePitch:         srl     a                                   ; divide sign by 4
 348  6154 CB 3F                                srl     a
 349  6156 FE 08                                cp      8
 350  6158 38 02                                jr      c,.NotIncreasedDamp                 ; if a < 8 divide by 2 again
 351  615A CB 3F        .IncreasedDamp          srl     a
 352  615C 32 6D 68     .NotIncreasedDamp:      ld      (BET1),a
 353  615F B1                                   or      c
 354  6160 32 6B 68                             ld      (BETA),a                            ; a = signed bit bet1
 355  6163 C9                                   ret
 356  6164
 357  6164              ;..Update Universe Objects.........................................................................................................
 358  6164              ;..................................................................................................................................
 359  6164              ;                           DEFINE ROTATIONDEBUG 1
 360  6164              ;                           DEFINE CLIPDEBUG 1
 361  6164 00           CurrentShipUniv:        DB      0
 362  6165              ;..................................................................................................................................
 363  6165              ; if ship is destroyed or exploding then z flag is clear, else z flag is set
 364  6165              ;..................................................................................................................................
 365  6165              ; Replacement for MVEIT routine
 366  6165 AF           UpdateUniverseObjects:  xor     a
 367  6166 32 24 6B                             ld      (SelectedUniverseSlot),a
 368  6169 CD 0F 6D                             call    GetTypeAtSlotA
 369  616C AF                                   xor     a
 370  616D                                      MMUSelectUniverseA                                      ; and we apply roll and pitch
 370  616D C6 46       >                     add    a,BankUNIVDATA0
 370  616F ED 92 56    >                     nextreg UniverseMMU,       a
 371  6172 CD 98 61     .ProperUpdate:          call    ApplyMyRollAndPitchTest
 372  6175              ;call    ApplyMyRollAndPitch24Bit                             ; todo , make all 4 of these 1 call
 373  6175 3A 49 C0                             ld      a,(UBnKRotZCounter)
 374  6178 FE 00                                cp      0
 375  617A CD EE D5                             call    ApplyShipRollAndPitch
 376  617D CD 34 D7                             call    ApplyShipSpeed
 377  6180 CD 78 C6                             call    UpdateSpeedAndPitch                             ; update based on rates of speed roll and pitch accelleration/decelleration
 378  6183 3E 00        .TotalDampen:           ld      a,0
 379  6185 32 49 C0                             ld      (UBnKRotZCounter),a             ; no pitch
 380  6188 32 48 C0                             ld      (UBnKRotXCounter),a
 381  618B 32 76 68                             ld      (JSTX),a
 382  618E 32 6C 68                             ld      (JSTY),a
 383  6191 CD 14 61                             call    draw_front_calc_alpha
 384  6194 CD 3C 61                             call    draw_front_calc_beta
 385  6197 C9                                   ret
 386  6198              ;..................................................................................................................................
 387  6198 3A 78 68     ApplyMyRollAndPitchTest:ld      a,(ALPHA)                   ; no roll or pitch, no calc needed
 388  619B A7           .CheckForRoll:          and		a
 389  619C C4 F8 61     						call	nz,Test_Roll
 390  619F 3A 6B 68     .CheckForPitch:			ld		a,(BETA)
 391  61A2 A7           						and		a
 392  61A3 C4 5E 62     						call	nz,Test_Pitch
 393  61A6 3A 59 69     .ApplySpeed:            ld      a,(DELTA)                   ; BCH = - Delta
 394  61A9              						ReturnIfAIsZero
 394  61A9 A7          >                        and     a
 394  61AA C8          >                        ret     z
 395  61AB 0E 00        						ld      c,0                         ;
 396  61AD 67           						ld      h,a                         ;
 397  61AE 06 80        						ld      b,$80                       ;
 398  61B0 ED 5B 27 C0  						ld      de,(UBnKzhi)                ; DEL = z position
 399  61B4 3A 26 C0     						ld      a,(UBnKzlo)                 ; .
 400  61B7 6F           						ld      l,a                         ; .
 401  61B8 CD 14 01     						call    AddBCHtoDELsigned           ; update speed
 402  61BB ED 53 27 C0  						ld      (UBnKzhi),DE                ; write back to zpos
 403  61BF 7D           						ld      a,l
 404  61C0 32 26 C0     						ld      (UBnKzlo),a                ;
 405  61C3 3A 78 68                             ld      a,(ALPHA)
 406  61C6 21 6B 68                             ld      hl,BETA
 407  61C9 B6                                   or      (hl)
 408  61CA C8                                   ret     z
 409  61CB DD 21 29 C0                          ld      ix,UBnkrotmatSidevX
 410  61CF CD BA 02                             call    ApplyRollAndPitchToIX
 411  61D2 DD 21 2F C0                          ld      ix,UBnkrotmatRoofvX
 412  61D6 CD BA 02                             call    ApplyRollAndPitchToIX
 413  61D9 DD 21 35 C0                          ld      ix,UBnkrotmatNosevX
 414  61DD CD BA 02                             call    ApplyRollAndPitchToIX
 415  61E0 C9                                   ret
 416  61E1
 417  61E1              ;----------------------------------------------------------------------------------------------------------------------------------
 418  61E1              ; Planet version of pitch and roll is a 24 bit calculation 1 bit sign + 23 bit value
 419  61E1              ; Need to write a test routine for roll and pitchs
 420  61E1 00 00 00 00  TestAlphaMulX            DB $00,$00, $00, $00
 421  61E5 00 00 00 00  TestAlphaMulY            DB $00,$00, $00, $00
 422  61E9 00 00 00 00  TestAlphaMulZ            DB $00,$00, $00, $00
 423  61ED 00 00 00 00  TestBetaMulZ             DB $00,$00, $00, $00
 424  61F1 00 00 00 00  TestBetaMulY             DB $00,$00, $00, $00
 425  61F5 00 00 00     TestK2                   DS 3
 426  61F8
 427  61F8 3A 78 68     Test_Roll:				ld      a,(ALPHA)                   ; get roll value
 428  61FB E6 7F        						and 	$7F
 429  61FD 57           						ld      d,a                         ; .
 430  61FE 3A 23 C0     						ld      a,(UBnKylo)                ; HLE = x sgn, hi, lo
 431  6201 5F           						ld      e,a                         ; .
 432  6202 2A 24 C0     						ld      hl,(UBnKyhi)               ; .
 433  6205 CD 0A 6F     						call    mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * -alpha / 256
 434  6208 7D           						ld		a,l
 435  6209 32 E5 61     						ld		(TestAlphaMulY),a			; save result
 436  620C ED 53 E6 61  						ld		(TestAlphaMulY+1),de		; save result
 437  6210 3A 78 68     						ld      a,(ALPHA)                   ; get roll value
 438  6213 E6 7F        						and 	$7F
 439  6215 57           						ld      d,a                         ; .
 440  6216 3A 20 C0     						ld      a,(UBnKxlo)                ; HLE = x sgn, hi, lo
 441  6219 5F           						ld      e,a                         ; .
 442  621A 2A 21 C0     						ld      hl,(UBnKxhi)               ; .
 443  621D CD 0A 6F     						call    mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * -alpha / 256
 444  6220 7D           						ld		a,l
 445  6221 32 E1 61     						ld		(TestAlphaMulX),a			; save result
 446  6224 ED 53 E2 61  						ld		(TestAlphaMulX+1),de		; save result
 447  6228 3A 78 68     						ld		a,(ALPHA)
 448  622B E6 80        						and		$80
 449  622D CA 47 62     						jp		z,.RollingRight
 450  6230 DD 21 20 C0  .RollingLeft:			ld		ix,UBnKxlo
 451  6234 FD 21 E5 61  						ld		iy,TestAlphaMulY
 452  6238 CD 90 00     						call	AddAtIXtoAtIY24Signed
 453  623B DD 21 23 C0  						ld		ix,UBnKylo
 454  623F FD 21 E1 61  						ld		iy,TestAlphaMulX
 455  6243 CD CD 00     						call	SubAtIXtoAtIY24Signed
 456  6246 C9           						ret
 457  6247 DD 21 20 C0  .RollingRight:			ld		ix,UBnKxlo
 458  624B FD 21 E5 61  						ld		iy,TestAlphaMulY
 459  624F CD CD 00     						call	SubAtIXtoAtIY24Signed
 460  6252 DD 21 23 C0  						ld		ix,UBnKylo
 461  6256 FD 21 E1 61  						ld		iy,TestAlphaMulX
 462  625A CD 90 00     						call	AddAtIXtoAtIY24Signed
 463  625D C9           						ret
 464  625E
 465  625E 3A 6B 68     Test_Pitch:				ld      a,(BETA)                   ; get roll value
 466  6261 E6 7F        						and 	$7F
 467  6263 57           						ld      d,a                         ; .
 468  6264 3A 23 C0     						ld      a,(UBnKylo)                ; HLE = x sgn, hi, lo
 469  6267 5F           						ld      e,a                         ; .
 470  6268 2A 24 C0     						ld      hl,(UBnKyhi)               ; .
 471  626B CD 0A 6F     						call    mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * -alpha / 256
 472  626E 7D           						ld		a,l
 473  626F 32 F1 61     						ld		(TestBetaMulY),a			; save result
 474  6272 ED 53 F2 61  						ld		(TestBetaMulY+1),de		; save result
 475  6276 3A 6B 68     						ld      a,(BETA)                   ; get roll value
 476  6279 E6 7F        						and 	$7F
 477  627B 57           						ld      d,a                         ; .
 478  627C 3A 26 C0     						ld      a,(UBnKzlo)                ; HLE = x sgn, hi, lo
 479  627F 5F           						ld      e,a                         ; .
 480  6280 2A 27 C0     						ld      hl,(UBnKzhi)               ; .
 481  6283 CD 0A 6F     						call    mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * -alpha / 256
 482  6286 7D           						ld		a,l
 483  6287 32 ED 61     						ld		(TestBetaMulZ),a			; save result
 484  628A ED 53 EE 61  						ld		(TestBetaMulZ+1),de		; save result
 485  628E 3A 6B 68     						ld		a,(BETA)
 486  6291 E6 80        						and		$80
 487  6293 CA AD 62     						jp		z,.Climbing
 488  6296 DD 21 23 C0  .Diving:				ld		ix,UBnKylo
 489  629A FD 21 ED 61  						ld		iy,TestBetaMulZ
 490  629E CD 90 00     						call	AddAtIXtoAtIY24Signed
 491  62A1 DD 21 26 C0  						ld		ix,UBnKzlo
 492  62A5 FD 21 F1 61  						ld		iy,TestBetaMulY
 493  62A9 CD CD 00     						call	SubAtIXtoAtIY24Signed
 494  62AC C9           						ret
 495  62AD DD 21 23 C0  .Climbing:		     	ld		ix,UBnKylo
 496  62B1 FD 21 ED 61  						ld		iy,TestBetaMulZ
 497  62B5 CD CD 00     						call	SubAtIXtoAtIY24Signed
 498  62B8 DD 21 26 C0  						ld		ix,UBnKzlo
 499  62BC FD 21 F1 61  						ld		iy,TestBetaMulY
 500  62C0 CD 90 00     						call	AddAtIXtoAtIY24Signed
 501  62C3 C9           						ret
 502  62C4              ;..................................................................................................................................
 503  62C4
 504  62C4 0A 00 00     Plus10:                 DB 10,0,0
 505  62C7 0A 00 80     Minus10:                DB 10,0,$80
 506  62CA
 507  62CA 14 00 00     Plus20:                 DB 20,0,0
 508  62CD 14 00 80     Minus20:                DB 20,0,$80
 509  62D0
 510  62D0 00 00 00...  SaveUBNK:               DS 3*3
 511  62D9
 512  62D9 E5 D5 C5 F5  SavePosition:           push    hl,,de,,bc,,af
 513  62DD 3A 64 61                             ld      a,(CurrentShipUniv)
 514  62E0 FE 02                                cp      2
 515  62E2 20 31                                jr      nz,.DoneSave
 516  62E4                                      ;break
 517  62E4 21 20 C0                             ld      hl, UBnKxlo
 518  62E7 11 D0 62                             ld      de, SaveUBNK
 519  62EA 01 09 00                             ld      bc, 3*3
 520  62ED ED B0                                ldir
 521  62EF 3E 00                                ld      a,0
 522  62F1 32 24 C0                             ld      (UBnKyhi)  ,a
 523  62F4 32 21 C0                             ld      (UBnKxhi)  ,a
 524  62F7 32 27 C0                             ld      (UBnKzhi)  ,a
 525  62FA 32 22 C0                             ld      (UBnKxsgn) ,a
 526  62FD 32 25 C0                             ld      (UBnKysgn) ,a
 527  6300 32 27 C0                             ld      (UBnKzhi)  ,a
 528  6303 32 28 C0                             ld      (UBnKzsgn) ,a
 529  6306 3E 05                                ld      a, $5
 530  6308 32 23 C0                             ld      (UBnKylo)  ,a
 531  630B 3E 05                                ld      a, $5
 532  630D 32 20 C0                             ld      (UBnKxlo)  ,a
 533  6310 3E 6E                                ld      a, $6E
 534  6312 32 26 C0                             ld      (UBnKzlo)  ,a
 535  6315 F1 C1 D1 E1  .DoneSave:              pop     hl,,de,,bc,,af
 536  6319 C9                                   ret
 537  631A
 538  631A E5 D5 C5 F5  RestorePosition:        push    hl,,de,,bc,,af
 539  631E 3A 64 61                             ld      a,(CurrentShipUniv)
 540  6321 FE 02                                cp      2
 541  6323 20 0B                                jr      nz,.DoneSave
 542  6325                                      ;break
 543  6325 21 D0 62                             ld      hl, SaveUBNK
 544  6328 11 20 C0                             ld      de, UBnKxlo
 545  632B 01 09 00                             ld      bc, 3*3
 546  632E ED B0                                ldir
 547  6330 F1 C1 D1 E1  .DoneSave:              pop     hl,,de,,bc,,af
 548  6334 C9                                   ret
 549  6335
 550  6335 00           currentDemoShip:        DB      0;$12 ; 13 - corirollis
 551  6336
 552  6336
 553  6336              SelectShip:             MMUSelectUniverseN  0
 553  6336 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 554  633A 06 00                                ld      b,0
 555  633C                                      MMUSelectShipBank1
 555  633C ED 91 57 3B >					 nextreg ShipModelMMU,	    BankShipModels1
 556  6340 FD 26 01                             ld      iyh, 1
 557  6343 3A 35 63     .SelectRandom:          ld      a,(currentDemoShip)
 558  6346 FD 6F                                ld      iyl,a
 559  6348 CD 0F E0                             call    GetShipBankId                       ; find actual memory location of data
 560  634B                                      MMUSelectShipBankA
 560  634B ED 92 57    >					 nextreg ShipModelMMU,	    a
 561  634E 78                                   ld      a,b
 562  634F CD 6A E0                             call    CopyShipToUniverse
 563  6352 3A 0D C4                             ld      a,(ShipTypeAddr)
 564  6355 3E 01                                ld      a,1                                 ; slot 1, iyh and iyl already set
 565  6357 CD 28 C7                             call    UnivInitRuntime
 566  635A CD 9B C6                             call    UnivSetDemoPostion
 567  635D 3A 35 63                             ld      a,(currentDemoShip)
 568  6360 3C                                   inc     a
 569  6361                                      JumpIfALTNusng  16, .OKInc
 569  6361 FE 10       >                        cp      16
 569  6363 DA 67 63    >                        jp		c, .OKInc
 570  6366              .ResetInc:              ZeroA
 570  6366 AF          >                        xor a
 571  6367 32 35 63     .OKInc:                 ld      (currentDemoShip),a
 572  636A C9                                   ret
 573  636B
 574  636B
 575  636B              ;----------------------------------------------------------------------------------------------------------------------------------
 576  636B              ; Set initial ship position as X,Y,Z 000,000,03B4
 577  636B 21 00 00     SetInitialShipPosition: ld      hl,$0000
 578  636E 22 20 C0                             ld      (UBnKxlo),hl
 579  6371 21 00 00                             ld      hl,$0000
 580  6374 22 23 C0                             ld      (UBnKylo),hl
 581  6377 21 B4 03                             ld      hl,$03B4
 582  637A 22 26 C0                             ld      (UBnKzlo),hl
 583  637D AF                                   xor     a
 584  637E 32 22 C0                             ld      (UBnKxsgn),a
 585  6381 32 25 C0                             ld      (UBnKysgn),a
 586  6384 32 28 C0                             ld      (UBnKzsgn),a
 587  6387 CD 34 C7                             call	InitialiseOrientation            ;#00;
 588  638A 3E 01                                ld      a,1
 589  638C 32 59 69                             ld      (DELTA),a
 590  638F 21 04 00                             ld      hl,4
 591  6392 22 5A 69                             ld      (DELTA4),hl
 592  6395 C9                                   ret
 593  6396
 594  6396                          include "../../Maths/Utilities/XX12EquNodeDotOrientation.asm"
# file opened: ../../Maths/Utilities/XX12EquNodeDotOrientation.asm
   1+ 6396              ; We enter here with hl pointing at XX16 and bc = XX15 value
   2+ 6396              ; so xx12 = XX15 * XX16 row
   3+ 6396              XX12ProcessOneRow:
   4+ 6396              XX12CalcXCell:
   5+ 6396 ED 4B A6 C0          ld		bc,(UBnkXScaled)
   6+ 639A 5E           		ld		e,(hl)								    ; get orientation ZX
   7+ 639B 23           		inc		hl
   8+ 639C 56           		ld		d,(hl)                                  ; so now e = xx16 value d = xx16 sign
   9+ 639D 7A           		ld		a,d
  10+ 639E A8                   xor     b
  11+ 639F E6 80        		and		SignOnly8Bit                            ; a = XX 16 sign
  12+ 63A1 DD 67        		ld		ixh,a								    ; orientation sign to ixh
  13+ 63A3 78           		ld		a,b                                     ; now make bc abs bc
  14+ 63A4 E6 7F        		and		SignMask8Bit
  15+ 63A6 47           		ld		b,a                                     ; bc = abs(bc) now
  16+ 63A7 E5           		push	hl
  17+ 63A8 16 00                ld      d,0                                     ; d = value
  18+ 63AA 60           		ld		h,b
  19+ 63AB 69           		ld		l,c
  20+ 63AC CD 70 6E     		call	mulDEbyHL							    ; hl = |orientation| * |x pos)
  21+ 63AF 22 31 68     		ld		(XX12PVarResult1),hl				    ; T = 16 bit result, we only want to use high byte later
  22+ 63B2 DD 7C        		ld		a,ixh
  23+ 63B4 32 38 68     		ld		(XX12PVarSign1),a					    ; S = sign  not sign 1 and 2 are reversed in memory so that fetchign back will put 1 in high byte 2 in low byte
  24+ 63B7 E1           		pop		hl
  25+ 63B8              XX12CalcYCell:
  26+ 63B8 ED 4B A8 C0          ld		bc,(UBnkYScaled)
  27+ 63BC 23           		inc		hl
  28+ 63BD 5E           		ld		e,(hl)							    	; get orientation ZX
  29+ 63BE 23           		inc		hl
  30+ 63BF 56           		ld		d,(hl)
  31+ 63C0 7A           		ld		a,d
  32+ 63C1 A8                   xor     b
  33+ 63C2 E6 80        		and		SignOnly8Bit
  34+ 63C4 DD 67        		ld		ixh,a								    ; XX16 orientation sign to ixh
  35+ 63C6 78           		ld		a,b                                     ; now make bc abs bc
  36+ 63C7 E6 7F        		and		SignMask8Bit
  37+ 63C9 47           		ld		b,a                                     ; bc = abs(bc) now
  38+ 63CA E5           		push	hl
  39+ 63CB 16 00                ld      d,0                                     ; d = value
  40+ 63CD 60           		ld		h,b
  41+ 63CE 69           		ld		l,c
  42+ 63CF CD 70 6E     		call	mulDEbyHL							    ; hl = |orientation| * |x pos)
  43+ 63D2 22 33 68     		ld		(XX12PVarResult2),hl				    ; T = 16 bit result
  44+ 63D5 DD 7C        		ld		a,ixh
  45+ 63D7 32 37 68     		ld		(XX12PVarSign2),a					    ; S = sign
  46+ 63DA E1           		pop		hl
  47+ 63DB              XX12CalcZCell:
  48+ 63DB ED 4B AA C0          ld		bc,(UBnkZScaled)
  49+ 63DF 23           		inc		hl
  50+ 63E0 5E           		ld		e,(hl)								    ; get orientation ZX
  51+ 63E1 23           		inc		hl
  52+ 63E2 56           		ld		d,(hl)
  53+ 63E3 7A           		ld		a,d
  54+ 63E4 A8                   xor     b
  55+ 63E5 E6 80        		and		SignOnly8Bit
  56+ 63E7 DD 67        		ld		ixh,a								    ; orientation sign to ixh
  57+ 63E9 78           		ld		a,b                                     ; now make bc abs bc
  58+ 63EA E6 7F        		and		SignMask8Bit
  59+ 63EC 47           		ld		b,a                                     ; bc = abs(bc) now
  60+ 63ED 16 00                ld      d,0                                     ; d = value
  61+ 63EF 60           		ld		h,b
  62+ 63F0 69           		ld		l,c
  63+ 63F1 CD 70 6E     		call	mulDEbyHL							    ; hl = |orientation| * |x pos)
  64+ 63F4 22 35 68     		ld		(XX12PVarResult3),hl				    ; T = 16 bit result
  65+ 63F7 DD 7C        		ld		a,ixh
  66+ 63F9 32 39 68     		ld		(XX12PVarSign3),a					    ; S = sign
  67+ 63FC              XX12CalcCellResult:
  68+ 63FC 2A 31 68     		ld		hl,(XX12PVarResult1)				    ; X Cell Result
  69+ 63FF ED 5B 33 68  		ld		de,(XX12PVarResult2)				    ; Y Cell Result
  70+ 6403 ED 4B 37 68  		ld		bc,(XX12PVarSign2)					    ; b = var 1 result sign c = var 2 result signs
  71+ 6407              XX12MSBOnly:
  72+ 6407 6C           		ld		l,h									    ; now move results into lower byte so / 256
  73+ 6408 5A           		ld		e,d									    ; for both results
  74+ 6409 AF           		xor		a									    ;
  75+ 640A 67           		ld		h,a									    ;
  76+ 640B 57           		ld		d,a									    ; so set high byte to 0
  77+ 640C CD 33 00     		call	ADDHLDESignBC                           ;  XX12ProcessCalcHLPlusDESignBC		; returns with HL = result1 + result 2 signed in a
  78+ 640F 47           		ld		b,a									    ; move sign into b ready for next calc
  79+ 6410 3A 39 68     		ld		a,(XX12PVarSign3)					    ; result of the calcZ cell
  80+ 6413 4F           		ld		c,a									    ; goes into c to align with DE
  81+ 6414 ED 5B 35 68  		ld		de,(XX12PVarResult3)				    ; now add result to Result 3
  82+ 6418 5A           		ld		e,d                                     ; d = result /256
  83+ 6419 16 00        		ld		d,0									    ; and only us high byte
  84+ 641B CD 33 00     		call	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC		; returns with HL = result and a = sign
  85+ 641E C9           		ret											    ; hl = result, a = sign
  86+ 641F              								    ; hl = result, a = sign
  87+ 641F
  88+ 641F              XX12EquNodeDotTransMat:							    ; .LL51	\ -> &4832 \ XX12=XX15.XX16  each vector is 16-bit x,y,z **** ACTUALLY XX16 is value in low sign bit in high
  89+ 641F              ;...X cell
  90+ 641F 21 79 C0     		ld		hl,UbnkTransInvRow0x0     			; process orientation matrix row 0
  91+ 6422 CD 96 63             call    XX12ProcessOneRow                   ; hl = result, a = sign
  92+ 6425 47           		ld		b,a                                 ; b = sign
  93+ 6426 7C           		ld		a,h                                 ; a = high byte
  94+ 6427 B0           		or		b
  95+ 6428 32 AD C0     		ld		(UBnkXX12xSign),a					; a = result with sign in bit 7
  96+ 642B 7D           		ld		a,l                                 ; the result will be in the lower byte now
  97+ 642C 32 AC C0             ld      (UBnkXX12xLo),a						; that is result done for
  98+ 642F              ;...Y cell
  99+ 642F 21 81 C0     		ld		hl,UbnkTransInvRow1y0     			; process orientation matrix row 1
 100+ 6432 CD 96 63             call    XX12ProcessOneRow
 101+ 6435 47           		ld		b,a
 102+ 6436 7C           		ld		a,h
 103+ 6437              ;		ld		a,l
 104+ 6437 B0           		or		b
 105+ 6438 32 AF C0     		ld		(UBnkXX12ySign),a					; a = result with sign in bit 7
 106+ 643B 7D           		ld		a,l                                 ; the result will be in the lower byte now
 107+ 643C 32 AE C0             ld      (UBnkXX12yLo),a						; that is result done for
 108+ 643F              ;...Z cell
 109+ 643F 21 89 C0     		ld		hl,UbnkTransInvRow2z0     			; process orientation matrix row 1
 110+ 6442 CD 96 63             call    XX12ProcessOneRow
 111+ 6445 47           		ld		b,a
 112+ 6446 7C                   ld		a,h
 113+ 6447              ;		ld		a,l
 114+ 6447 B0           		or		b
 115+ 6448 32 B1 C0     		ld		(UBnkXX12zSign),a					; a = result with sign in bit 7
 116+ 644B 7D           		ld		a,l                                 ; the result will be in the lower byte now
 117+ 644C 32 B0 C0             ld      (UBnkXX12zLo),a						; that is result done for
 118+ 644F C9                   ret
 119+ 6450
 120+ 6450              XX12EquNodeDotOrientation:							; .LL51	\ -> &4832 \ XX12=XX15.XX16  each vector is 16-bit x,y,z **** ACTUALLY XX16 is value in low sign bit in high
 121+ 6450              ;...X cell
 122+ 6450 21 79 C0     		ld		hl,UbnkTransInvRow0x0     			; process orientation matrix row 0
 123+ 6453 CD 96 63             call    XX12ProcessOneRow                   ; hl = result, a = sign
 124+ 6456 47           		ld		b,a                                 ; b = sign
 125+ 6457 7C           		ld		a,h                                 ; a = high byte
 126+ 6458 B0           		or		b
 127+ 6459 32 AD C0     		ld		(UBnkXX12xSign),a					; a = result with sign in bit 7
 128+ 645C 7D           		ld		a,l                                 ; the result will be in the lower byte now
 129+ 645D 32 AC C0             ld      (UBnkXX12xLo),a						; that is result done for
 130+ 6460              ;...Y cell
 131+ 6460 21 81 C0     		ld		hl,UbnkTransInvRow1y0     			; process orientation matrix row 1
 132+ 6463 CD 96 63             call    XX12ProcessOneRow
 133+ 6466 47           		ld		b,a
 134+ 6467 7C           		ld		a,h
 135+ 6468              ;		ld		a,l
 136+ 6468 B0           		or		b
 137+ 6469 32 AF C0     		ld		(UBnkXX12ySign),a					; a = result with sign in bit 7
 138+ 646C 7D           		ld		a,l                                 ; the result will be in the lower byte now
 139+ 646D 32 AE C0             ld      (UBnkXX12yLo),a						; that is result done for
 140+ 6470              ;...Z cell
 141+ 6470 21 89 C0     		ld		hl,UbnkTransInvRow2z0     			; process orientation matrix row 1
 142+ 6473 CD 96 63             call    XX12ProcessOneRow
 143+ 6476 47           		ld		b,a
 144+ 6477 7C                   ld		a,h
 145+ 6478              ;		ld		a,l
 146+ 6478 B0           		or		b
 147+ 6479 32 B1 C0     		ld		(UBnkXX12zSign),a					; a = result with sign in bit 7
 148+ 647C 7D           		ld		a,l                                 ; the result will be in the lower byte now
 149+ 647D 32 B0 C0             ld      (UBnkXX12zLo),a						; that is result done for
 150+ 6480 C9                   ret
 151+ 6481
 152+ 6481              XX12EquNodeDotXX16:					         		; .LL51	\ -> &4832 \ XX12=XX15.XX16  each vector is 16-bit x,y,z **** ACTUALLY XX16 is value in low sign bit in high
 153+ 6481              ;...X cell
 154+ 6481 21 61 C0     		ld		hl,UBnkTransmatSidevX     			; process orientation matrix row 0
 155+ 6484 CD 96 63             call    XX12ProcessOneRow                   ; hl = result, a = sign
 156+ 6487 47           		ld		b,a                                 ; b = sign
 157+ 6488 7C           		ld		a,h                                 ; a = high byte
 158+ 6489 B0           		or		b
 159+ 648A 32 AD C0     		ld		(UBnkXX12xSign),a					; a = result with sign in bit 7
 160+ 648D 7D           		ld		a,l                                 ; the result will be in the lower byte now
 161+ 648E 32 AC C0             ld      (UBnkXX12xLo),a						; that is result done for
 162+ 6491              ;...Y cell
 163+ 6491 21 67 C0     		ld		hl,UBnkTransmatRoofvX     			; process orientation matrix row 1
 164+ 6494 CD 96 63             call    XX12ProcessOneRow
 165+ 6497 47           		ld		b,a
 166+ 6498 7C           		ld		a,h
 167+ 6499              ;		ld		a,l
 168+ 6499 B0           		or		b
 169+ 649A 32 AF C0     		ld		(UBnkXX12ySign),a					; a = result with sign in bit 7
 170+ 649D 7D           		ld		a,l                                 ; the result will be in the lower byte now
 171+ 649E 32 AE C0             ld      (UBnkXX12yLo),a						; that is result done for
 172+ 64A1              ;...Z cell
 173+ 64A1 21 6D C0     		ld		hl,UBnkTransmatNosevX     			; process orientation matrix row 1
 174+ 64A4 CD 96 63             call    XX12ProcessOneRow
 175+ 64A7 47           		ld		b,a
 176+ 64A8 7C                   ld		a,h
 177+ 64A9              ;		ld		a,l
 178+ 64A9 B0           		or		b
 179+ 64AA 32 B1 C0     		ld		(UBnkXX12zSign),a					; a = result with sign in bit 7
 180+ 64AD 7D           		ld		a,l                                 ; the result will be in the lower byte now
 181+ 64AE 32 B0 C0             ld      (UBnkXX12zLo),a						; that is result done for
 182+ 64B1 C9                   ret
# file closed: ../../Maths/Utilities/XX12EquNodeDotOrientation.asm
 595  64B2                          include "../../ModelRender/CopyXX12ToXX15.asm"
# file opened: ../../ModelRender/CopyXX12ToXX15.asm
   1+ 64B2 21 AC C0     CopyXX12ToXX15:         ld      hl,XX12
   2+ 64B5 11 A6 C0                             ld      de,XX15
   3+ 64B8 01 06 00                             ld      bc,6
   4+ 64BB ED B0                                ldir
   5+ 64BD C9                                   ret
   6+ 64BE
   7+ 64BE 21 AC C0     CopyXX12ToXX12Save:     ld      hl,XX12
   8+ 64C1 11 B2 C0                             ld      de,XX12Save
   9+ 64C4 01 06 00                             ld      bc,6
  10+ 64C7 ED B0                                ldir
  11+ 64C9 C9                                   ret
  12+ 64CA
  13+ 64CA 21 B2 C0     CopyXX12SaveToXX12:     ld      hl,XX12Save
  14+ 64CD 11 AC C0                             ld      de,XX12
  15+ 64D0 01 06 00                             ld      bc,6
  16+ 64D3 ED B0                                ldir
  17+ 64D5 C9                                   ret
  18+ 64D6
  19+ 64D6 21 AC C0     CopyXX12ToXX12Save2:    ld      hl,XX12
  20+ 64D9 11 B8 C0                             ld      de,XX12Save2
  21+ 64DC 01 06 00                             ld      bc,6
  22+ 64DF ED B0                                ldir
  23+ 64E1 C9                                   ret
  24+ 64E2
  25+ 64E2 21 B8 C0     CopyXX12Save2ToXX12:    ld      hl,XX12Save2
  26+ 64E5 11 AC C0                             ld      de,XX12
  27+ 64E8 01 06 00                             ld      bc,6
  28+ 64EB ED B0                                ldir
  29+ 64ED C9                                   ret
  30+ 64EE
# file closed: ../../ModelRender/CopyXX12ToXX15.asm
 596  64EE                          include "../../Maths/Utilities/ScaleXX16Matrix197.asm"
# file opened: ../../Maths/Utilities/ScaleXX16Matrix197.asm
   1+ 64EE              ScaleXX16Matrix197:
   2+ 64EE                      IFDEF LOGMATHS
   3+ 64EE ~                                    ld		b,9                 ; Interate though all 9 matrix elements
   4+ 64EE ~                                    ld		hl,UBnkTransmatSidev ; within XX16 (transmat)
   5+ 64EE ~                                    MMUSelectMathsTables
   6+ 64EE ~            .ScaleXX16Loop:         ld		e,(hl)              ; set DE = matrix value              ;
   7+ 64EE ~                                    inc		hl                  ;
   8+ 64EE ~                                    ld		a,(hl)              ;
   9+ 64EE ~                                    ld		d,a                 ;
  10+ 64EE ~                                    and     SignOnly8Bit        ; A holds high still to we can strip out sign bit
  11+ 64EE ~                                    ld		ixl,a				; retain for sign bit
  12+ 64EE ~                                    ShiftDELeft1				; carry now holds sign bit and DE = De * 2, this will in effect strip off the sign bit automatically
  13+ 64EE ~                                    ld      a,d                 ; a = high byte after x 2
  14+ 64EE ~                                    push	bc                  ; save BC  counter and constant 197
  15+ 64EE ~                                    push	hl                  ; save HL
  16+ 64EE ~                                    call    AEquAmul256Div197Log;
  17+ 64EE ~                                    pop		hl
  18+ 64EE ~                                    dec     hl                  ; move back to low byte
  19+ 64EE ~                                    ld      (hl),a              ; save result in low byte as we want to preserve high byte sign
  20+ 64EE ~                                    inc     hl                  ; move back to high byte
  21+ 64EE ~                                    ld      a,ixl
  22+ 64EE ~                                    ld      (hl),a              ; write back just sign bit
  23+ 64EE ~                                    pop		bc                  ; retrieve both counter and constant 197
  24+ 64EE ~                                    inc     hl                  ; no to next vertex value
  25+ 64EE ~                                    djnz	.ScaleXX16Loop
  26+ 64EE ~                                    MMUSelectROM0
  27+ 64EE ~                                    ret
  28+ 64EE                      ELSE
  29+ 64EE 06 09                                ld		b,9                 ; Interate though all 9 matrix elements
  30+ 64F0 0E C5                                ld		c,ConstNorm         ; c = 197
  31+ 64F2 21 61 C0                             ld		hl,UBnkTransmatSidev ; within XX16 (transmat)
  32+ 64F5 7E           .ScaleXX16Loop:         ld		a,(hl)              ; set DE = matrix value
  33+ 64F6 5F                                   ld		e,a                 ;
  34+ 64F7 23                                   inc		hl                  ;
  35+ 64F8 7E                                   ld		a,(hl)              ;
  36+ 64F9 57                                   ld		d,a                 ;
  37+ 64FA E6 80                                and     SignOnly8Bit        ; A holds high still to we can strip out sign bit
  38+ 64FC DD 6F                                ld		ixl,a				; retain for sign bit
  39+ 64FE                                      ShiftDELeft1				; carry now holds sign bit and DE = De * 2, this will in effect strip off the sign bit automatically
  39+ 64FE CB 23       >			   sla e
  39+ 6500 CB 12       >			   rl  d
  40+ 6502 7A                                   ld      a,d                 ; a = high byte after x 2
  41+ 6503 C5                                   push	bc                  ; save BC  counter and constant 197
  42+ 6504 E5                                   push	hl                  ; save HL
  43+ 6505 CD F0 72                             call	DIV16Amul256dCUNDOC; AEquAmul256DivD; DIV16Amul256dCUNDOC	; result in BC = A*256 / 197 or D *512 / 197 = 2.6 * vector element, effectivley the result will always be in c
  44+ 6508 E1                                   pop		hl
  45+ 6509 2B                                   dec     hl                  ; move back to low byte
  46+ 650A 71                                   ld      (hl),c              ; save result in low byte as we want to preserve high byte sign
  47+ 650B 23                                   inc     hl                  ; move back to high byte
  48+ 650C                                  ;    ld      a,(hl)
  49+ 650C                                  ;    and     $80
  50+ 650C DD 7D                                ld      a,ixl
  51+ 650E 77                                   ld      (hl),a              ; write back just sign bit
  52+ 650F C1                                   pop		bc                  ; retrieve both counter and constant 197
  53+ 6510 23                                   inc     hl                  ; no to next vertex value
  54+ 6511 10 E2                                djnz	.ScaleXX16Loop
  55+ 6513 C9                                   ret
  56+ 6514                      ENDIF
# file closed: ../../Maths/Utilities/ScaleXX16Matrix197.asm
 597  6514
 598  6514                          include "../../Universe/StarDust/StarRoutines.asm"
# file opened: ../../Universe/StarDust/StarRoutines.asm
   1+ 6514              ;note: DIV16Amul256dCUNDOC as per
   2+ 6514              ;                                   BC = A0
   3+ 6514              ;                                   DE = 0C
   4+ 6514              ;                                   so BC = a * 256 / C
   5+ 6514
   6+ 6514              ; We can cheat here, Speed is always 0 or positive
   7+ 6514              ; z postion will always be positive if we can see it
   8+ 6514
   9+ 6514 EB           InitStarAtHL:           ex      de,hl               ; preserving hl
  10+ 6515 CD 36 6D                             call    doRND               ; a = random OR bit 5
  11+ 6518 EB                                   ex      de,hl               ; .
  12+ 6519 F6 08                                or      8                   ; .
  13+ 651B 77                                   ld      (hl),a              ; save to x pos
  14+ 651C E6 7F                                and     $7F                 ; a = abs a
  15+ 651E 23                                   inc     hl                  ;
  16+ 651F 77                                   ld      (hl),a              ;
  17+ 6520 EB                                   ex      de,hl               ; preserving hl
  18+ 6521 CD 36 6D                             call    doRND               ; a = -ve (random / 2)
  19+ 6524 EB                                   ex      de,hl               ; .
  20+ 6525 0F                                   rrca                        ; .
  21+ 6526 E6 80                                and     $80                 ; .
  22+ 6528 B6                                   or      (hl)                ; or with
  23+ 6529 77                                   ld      (hl),a
  24+ 652A 23                                   inc     hl
  25+ 652B EB                                   ex      de,hl
  26+ 652C CD 36 6D                             call    doRND
  27+ 652F EB                                   ex      de,hl
  28+ 6530 F6 04                                or      4
  29+ 6532 77                                   ld      (hl),a
  30+ 6533 23                                   inc     hl
  31+ 6534 E6 7F                                and     $7F
  32+ 6536 77                                   ld      (hl),a
  33+ 6537 EB                                   ex      de,hl
  34+ 6538 CD 36 6D                             call    doRND
  35+ 653B EB                                   ex      de,hl
  36+ 653C 0F                                   rrca
  37+ 653D E6 80                                and     $80
  38+ 653F B6                                   or      (hl)
  39+ 6540 77                                   ld      (hl),a
  40+ 6541 23                                   inc     hl
  41+ 6542 EB                                   ex      de,hl
  42+ 6543 CD 36 6D                             call    doRND
  43+ 6546 EB                                   ex      de,hl
  44+ 6547 F6 90                                or      144
  45+ 6549 77                                   ld      (hl),a
  46+ 654A 23                                   inc     hl
  47+ 654B F6 70                                or      %01110000
  48+ 654D E6 7F                                and     $7f     ; bodge
  49+ 654F 77                                   ld      (hl),a
  50+ 6550 23                                   inc     hl
  51+ 6551 C9                                   ret
  52+ 6552
  53+ 6552 EB           InitHyperStarAtHL:      ex      de,hl
  54+ 6553 CD 36 6D                             call    doRND
  55+ 6556 CB 27                                sla     a
  56+ 6558 CB 27                                sla     a                ; so its * 4 as we have a blank spot
  57+ 655A EB                                   ex      de,hl
  58+ 655B E6 F8                                and     %11111000
  59+ 655D 77                                   ld      (hl),a
  60+ 655E E6 7F                                and     $7F
  61+ 6560 23                                   inc     hl
  62+ 6561 77                                   ld      (hl),a
  63+ 6562 EB                                   ex      de,hl
  64+ 6563 CD 36 6D                             call    doRND
  65+ 6566 EB                                   ex      de,hl
  66+ 6567 0F                                   rrca
  67+ 6568 E6 80                                and     $80
  68+ 656A B6                                   or      (hl)
  69+ 656B 77                                   ld      (hl),a
  70+ 656C 23                                   inc     hl
  71+ 656D EB                                   ex      de,hl
  72+ 656E CD 36 6D                             call    doRND
  73+ 6571 CB 27                                sla     a
  74+ 6573 CB 27                                sla     a               ; so its * 4 as we have a blank spot
  75+ 6575 EB                                   ex      de,hl
  76+ 6576 E6 F8                                and     %11111000
  77+ 6578 77                                   ld      (hl),a
  78+ 6579 23                                   inc     hl
  79+ 657A E6 7F                                and     $7F
  80+ 657C 77                                   ld      (hl),a
  81+ 657D EB                                   ex      de,hl
  82+ 657E CD 36 6D                             call    doRND
  83+ 6581 EB                                   ex      de,hl
  84+ 6582 0F                                   rrca
  85+ 6583 E6 80                                and     $80
  86+ 6585 B6                                   or      (hl)
  87+ 6586 77                                   ld      (hl),a
  88+ 6587 23                                   inc     hl
  89+ 6588 EB                                   ex      de,hl
  90+ 6589 CD 36 6D                             call    doRND
  91+ 658C EB                                   ex      de,hl
  92+ 658D F6 5F                                or      95
  93+ 658F 77                                   ld      (hl),a
  94+ 6590 23                                   inc     hl
  95+ 6591 F6 70                                or      %01110000
  96+ 6593 E6 7F                                and     $7f     ; bodge
  97+ 6595 77                                   ld      (hl),a
  98+ 6596 23                                   inc     hl
  99+ 6597 C9                                   ret
 100+ 6598
 101+ 6598              ;----------------------------------------------------------------------------------------------------------------------------------
 102+ 6598 06 0B        InitialiseStars:        ld      b,MaxNumberOfStars
 103+ 659A 21 85 6A                             ld      hl,varDust
 104+ 659D CD 14 65     .InitStarsLoop:         call    InitStarAtHL
 105+ 65A0 10 FB                                djnz    .InitStarsLoop
 106+ 65A2 C9                                   ret
 107+ 65A3              ;----------------------------------------------------------------------------------------------------------------------------------
 108+ 65A3 06 0B        InitialiseHyperStars:   ld      b,MaxNumberOfStars
 109+ 65A5 21 85 6A                             ld      hl,varDust
 110+ 65A8 CD 52 65     .InitStarsLoop:         call    InitHyperStarAtHL
 111+ 65AB 10 FB                                djnz    .InitStarsLoop
 112+ 65AD C9                                   ret
 113+ 65AE              ;----------------------------------------------------------------------------------------------------------------------------------
 114+ 65AE FD 21 85 6A  SaveCurrentDust:        ld          iy,varDust
 115+ 65B2 DD 21 6F 6A                          ld          ix,varDustWarpRender
 116+ 65B6 06 0B                                ld          b, MaxNumberOfStars
 117+ 65B8 FD 7E 01     .SaveLoop               ld          a,(iy+1)
 118+ 65BB 6F                                   ld          l,a
 119+ 65BC E6 7F                                and         $7F
 120+ 65BE                                      JumpOnBitSet l,7,.StarNegXPt
 120+ 65BE CB 7D       >                        bit 	7,l
 120+ 65C0 C2 C9 65    >                        jp      nz,.StarNegXPt
 121+ 65C3 C6 80                                add         a,$80
 122+ 65C5 5F                                   ld          e,a
 123+ 65C6 C3 CE 65                             jp          .StarDoneX
 124+ 65C9 57           .StarNegXPt:            ld          d,a
 125+ 65CA 3E 80                                ld          a,$80
 126+ 65CC 92                                   sub         d
 127+ 65CD 5F                                   ld          e,a
 128+ 65CE FD 7E 03     .StarDoneX:             ld          a,(iy+3)
 129+ 65D1 6F                                   ld          l,a
 130+ 65D2 E6 7F                                and         $7F
 131+ 65D4                                      JumpOnBitSet l,7,.StarNegYPt
 131+ 65D4 CB 7D       >                        bit 	7,l
 131+ 65D6 C2 DF 65    >                        jp      nz,.StarNegYPt
 132+ 65D9 C6 60                                add         a,$60
 133+ 65DB 57                                   ld          d,a
 134+ 65DC C3 E4 65                             jp          .StarDoneY
 135+ 65DF 57           .StarNegYPt:            ld          d,a
 136+ 65E0 3E 60                                ld          a,$60
 137+ 65E2 92                                   sub         d
 138+ 65E3 57                                   ld          d,a
 139+ 65E4 DD 73 00     .StarDoneY:             ld          (ix+0),e
 140+ 65E7 DD 72 01                             ld          (ix+1),d
 141+ 65EA DD 23                                inc         ix
 142+ 65EC DD 23                                inc         ix
 143+ 65EE FD E5 E1                             ld          hl,iy
 144+ 65F1 3E 06                                ld          a,6
 145+ 65F3 ED 31                                add         hl,a
 146+ 65F5 E5 FD E1                             ld          iy,hl
 147+ 65F8 10 BE                                djnz        .SaveLoop
 148+ 65FA C9                                   ret
 149+ 65FB
 150+ 65FB              ;----------------------------------------------------------------------------------------------------------------------------------
 151+ 65FB 06 0B        DustForward:            ld      b,MaxNumberOfStars                  ; get the number of stars to process
 152+ 65FD FD 21 85 6A                          ld      iy,varDust                          ; hl is now a pointer to the dust array
 153+ 6601 C5           StarProcessLoop:        push    bc                                  ; save counter +1
 154+ 6602 FD 7E 05     .Qequ64XSpeedDivZHi:    ld      a,(iy+5)                            ; e  = z high
 155+ 6605 5F                                   ld      e,a                                 ; d = 0
 156+ 6606 16 00                                ld      d,0                                 ; de = zhi/256
 157+ 6608 3A 59 69                             ld      a,(DELTA)                           ; a = speed
 158+ 660B                                      JumpIfAIsNotZero .NormalSpeed               ; if we are stationary set speed
 158+ 660B A7          >                        and     a
 158+ 660C C2 10 66    >                        jp	    nz,.NormalSpeed
 159+ 660F 3C                                   inc     a                                   ; so it is at least some dust movement
 160+ 6610 47           .NormalSpeed:           ld      b,a                                 ;
 161+ 6611 0E 00                                ld      c,0                                 ; bc = delta * 256
 162+ 6613 CD 7C 73                             call    BC_Div_DE                           ; BC = Speed/Z , HL = remainder
 163+ 6616                                      ShiftHLRight1
 163+ 6616 CB 3C       >			   srl h
 163+ 6618 CB 1D       >			   rr  l
 164+ 661A                                      ShiftHLRight1                               ; hl = remainder/2 so now 64 * speed / zhi
 164+ 661A CB 3C       >			   srl h
 164+ 661C CB 1D       >			   rr  l
 165+ 661E 7D                                   ld      a,l                                 ;
 166+ 661F F6 01                                or      1                                   ; so ensure A is at least 1 for ambient movement
 167+ 6621 DD 6F                                ld      ixl,a                               ; preserve A which is also VarQ = 64 * speed / zhi
 168+ 6623 FD 6E 04 FD  .ZequZMinusSpeedX64:    ld      hl,(iy+4)                           ; hl = z
 168+ 6627 66 05
 169+ 6629 ED 5B 5A 69                          ld      de, (DELTA4)                         ; de = delta4 i.e. speed * 64 pre computed
 170+ 662D CD 75 01                             call    subHLDES15
 171+ 6630                                      JumpOnBitSet h,7,ResetStar                  ; if z ended up negative then reset the star
 171+ 6630 CB 7C       >                        bit 	7,h
 171+ 6632 C2 87 67    >                        jp      nz,ResetStar
 172+ 6635 FD 75 04 FD                          ld      (iy+4),hl                           ; save new z pos
 172+ 6639 74 05
 173+ 663B FD 6E 00 FD  .XEquXPlusXhiMulQ       ld      hl,(iy+0)                           ; hl  = x
 173+ 663F 66 01
 174+ 6641 7C                                   ld      a,h                                 ;
 175+ 6642 E6 7F                                and     $7F                                 ;
 176+ 6644 57                                   ld      d,a                                 ; d = abs(x hi)
 177+ 6645 DD 5D                                ld      e,ixl                               ; e = Q = 64 * speed / zhi
 178+ 6647 ED 30                                mul                                         ; de =  abs(x hi) * Q
 179+ 6649 7C                                   ld      a,h                                 ;
 180+ 664A E6 80                                and     $80                                 ;
 181+ 664C B2                                   or      d                                   ; set sign bit in d
 182+ 664D 57                                   ld      d,a                                 ;
 183+ 664E CD 56 00                             call    ADDHLDESignedV4                  ; x = x + (x hi/256 * Q)
 184+ 6651 7C                                   ld      a,h
 185+ 6652 E6 7F                                and     $7F
 186+ 6654                                      JumpIfAGTENusng $70, ResetStar
 186+ 6654 FE 70       >                        cp     $70
 186+ 6656 D2 87 67    >                        jp		nc,ResetStar
 187+ 6659 FD 75 00 FD                          ld      (iy+0),hl                           ;
 187+ 665D 74 01
 188+ 665F FD 6E 02 FD  .YEquYPlusYhiMulQ       ld      hl,(iy+2)                           ; hl  = y
 188+ 6663 66 03
 189+ 6665 7C                                   ld      a,h                                 ;
 190+ 6666 E6 7F                                and     $7F                                 ;
 191+ 6668 57                                   ld      d,a                                 ; d = abs(y hi)
 192+ 6669 DD 5D                                ld      e,ixl                               ; e = Q = 64 * speed / zhi
 193+ 666B ED 30                                mul                                         ; de =  abs(y hi) * Q
 194+ 666D 7C                                   ld      a,h                                 ;
 195+ 666E E6 80                                and     $80                                 ;
 196+ 6670 B2                                   or      d                                   ; set sign bit in d
 197+ 6671 57                                   ld      d,a                                 ;
 198+ 6672 CD 56 00                             call    ADDHLDESignedV4                  ; y = y + (x hi/256 * Q)
 199+ 6675 7C                                   ld      a,h
 200+ 6676 E6 7F                                and     $7F
 201+ 6678                                      JumpIfAGTENusng $60, ResetStar
 201+ 6678 FE 60       >                        cp     $60
 201+ 667A D2 87 67    >                        jp		nc,ResetStar
 202+ 667D 7C                                   ld      a,h
 203+ 667E E6 80                                and     $80
 204+ 6680 20 06                                jr      nz,.NoSecondCheck
 205+ 6682 7C                                   ld      a,h
 206+ 6683                                      JumpIfAGTENusng $20, ResetStar
 206+ 6683 FE 20       >                        cp     $20
 206+ 6685 D2 87 67    >                        jp		nc,ResetStar
 207+ 6688 FD 75 02 FD  .NoSecondCheck:         ld      (iy+2),hl                           ;
 207+ 668C 74 03
 208+ 668E              ; Now roll
 209+ 668E              ;  6. x = x - alpha * y / 256
 210+ 668E 3A 79 68     .XRoll:                 ld      a,(ALP1)                           ; h = sign, l = magnitude
 211+ 6691 FE 00                                cp      0
 212+ 6693 28 4D                                jr      z,.NoRoll                           ; don;t roll if magnitude is 0
 213+ 6695                                   ;   break
 214+ 6695 6F                                   ld      l,a                                 ; roll magnitude
 215+ 6696 3A 7B 68                             ld      a,(ALP2FLIP)                        ; inverted roll sign
 216+ 6699 E6 80                                and     SignOnly8Bit                        ; sanitise sign bit
 217+ 669B 67                                   ld      h,a                                 ; h = roll sign
 218+ 669C E5                                   push    hl                                  ; save on the stack
 219+ 669D 4F           .rxSaveAlphaSign:       ld      c,a                                 ; save alpha sign in c
 220+ 669E 55           .rxDEquABSAlpha:        ld      d,l                                 ; d= abs (alpha)
 221+ 669F FD 7E 03                             ld      a,(iy+3)                            ; get high byte from x coord
 222+ 66A2 5F                                   ld      e,a                                 ; save signed byte
 223+ 66A3 E6 80                                and     SignOnly8Bit                        ; a = sign only
 224+ 66A5 47           .rxBEquSignXHi:         ld      b,a                                 ; save sign of x in b
 225+ 66A6 7B           .rxEEquABSignX:         ld      a,e                                 ; e = abs byte
 226+ 66A7 E6 7F                                and     SignMask8Bit
 227+ 66A9 5F                                   ld      e,a                                 ; save abs x hi in e
 228+ 66AA ED 30                                mul                                         ; abs(alpha) * abs(y high) (so /256)
 229+ 66AC 79                                   ld      a,c                                 ; get back sign from roll
 230+ 66AD A8                                   xor     b                                   ; handle muliple sign bits
 231+ 66AE B2                                   or      d
 232+ 66AF 57                                   ld      d,a                                 ; de = signed alpha & y high / 256
 233+ 66B0 FD 6E 00 FD                          ld      hl,(iy+0)                           ; h = iy+1, l = iy+0
 233+ 66B4 66 01
 234+ 66B6 CD 75 01                             call    subHLDES15                       ; we are usign add, so may need to fip sign?
 235+ 66B9 FD 75 00 FD                          ld      (iy+0),hl
 235+ 66BD 74 01
 236+ 66BF              ;  5. y = y + alpha * x / 256
 237+ 66BF              .YRoll:                 ;break
 238+ 66BF E1                                   pop     hl                                  ; h = sign, l = magnitude
 239+ 66C0 4C           .rySaveAlphaSign:       ld      c,h                                 ; save alpha sign in c
 240+ 66C1 55           .ryDEquABSAlpha:        ld      d,l                                 ; d= abs (alpha)
 241+ 66C2 FD 7E 01                             ld      a,(iy+1)                            ; get high byte from x coord
 242+ 66C5 5F                                   ld      e,a
 243+ 66C6 E6 80                                and     SignOnly8Bit
 244+ 66C8 47           .ryBEquSignXHi:         ld      b,a                                 ; save sign of x in b
 245+ 66C9 7B           .ryEEquABSignX:         ld      a,e
 246+ 66CA E6 7F                                and     SignMask8Bit
 247+ 66CC 5F                                   ld      e,a                                 ; save abs x hi in e
 248+ 66CD ED 30                                mul                                         ; abs(alpha) * abs(y high) (so /256)
 249+ 66CF 79                                   ld      a,c
 250+ 66D0 A8                                   xor     b                                   ; handle muliple sign bits
 251+ 66D1 B2                                   or      d
 252+ 66D2 57                                   ld      d,a                                 ; de = signed alpha & y high / 256
 253+ 66D3 FD 6E 02 FD                          ld      hl,(iy+2)                           ; h = iy+1, l = iy+0
 253+ 66D7 66 03
 254+ 66D9 CD 56 00                             call    ADDHLDESignedV4                  ; we are usign add, so may need to fip sign?
 255+ 66DC FD 75 02 FD                          ld      (iy+2),hl
 255+ 66E0 74 03
 256+ 66E2 3A 6D 68     .NoRoll:                ld      a,(BET1)
 257+ 66E5 FE 00                                cp      0
 258+ 66E7 28 22                                jr      z,.NoPitch
 259+ 66E9              ;  8. y = y - beta * 256
 260+ 66E9 57           .YPitch:                ld      d,a                                 ; d = BET1
 261+ 66EA FD 7E 02                             ld      a,(iy+2)
 262+ 66ED 5F                                   ld      e,a                                 ; e = Y HI
 263+ 66EE ED 30                                mul                                         ; de = BET1 * YHi so now D = BETA & YHI / 256
 264+ 66F0 5F                                   ld      e,a
 265+ 66F1 ED 30                                mul                                         ; so now de = (BETA & Yhi) ^ 2
 266+ 66F3                                      ShiftDELeft1                                ; de = 2 * ((BETA & Yhi) ^ 2)
 266+ 66F3 CB 23       >			   sla e
 266+ 66F5 CB 12       >			   rl  d
 267+ 66F7 3A 6E 68                             ld      a,(BET2)                            ; get inverted Sign
 268+ 66FA B2                                   or      d
 269+ 66FB 57                                   ld      d,a                                 ; de = - (2 * ((BETA & Yhi) ^ 2))
 270+ 66FC FD 6E 02 FD                          ld      hl,(iy+2)
 270+ 6700 66 03
 271+ 6702 CD 56 00                             call    ADDHLDESignedV4
 272+ 6705 FD 75 02 FD                          ld      (iy+2),hl
 272+ 6709 74 03
 273+ 670B              ; now work out screen pos
 274+ 670B              ; Note two optimistations, write to layer 2 - we get a free removal via double buffer cls
 275+ 670B              ; read z dept than determine hw many pixesl to plot, e.g. 1,2,3,4
 276+ 670B              ;        pop     de
 277+ 670B               ;       call    ProjectStarXToScreen
 278+ 670B                                      ;pop     de
 279+ 670B              .NoPitch:
 280+ 670B FD 7E 01     .ProjectStar:           ld      a,(iy+1)
 281+ 670E 6F                                   ld      l,a
 282+ 670F E6 7F                                and     $7F
 283+ 6711                                      JumpOnBitSet l,7,StarNegXPt
 283+ 6711 CB 7D       >                        bit 	7,l
 283+ 6713 C2 1C 67    >                        jp      nz,StarNegXPt
 284+ 6716 C6 80                                add     a,$80
 285+ 6718 4F                                   ld      c,a
 286+ 6719 C3 21 67                             jp      StarDoneX
 287+ 671C 47           StarNegXPt:             ld      b,a
 288+ 671D 3E 80                                ld      a,$80
 289+ 671F 90                                   sub     b
 290+ 6720 4F                                   ld      c,a
 291+ 6721 FD 7E 03     StarDoneX:              ld      a,(iy+3)
 292+ 6724 6F                                   ld      l,a
 293+ 6725 E6 7F                                and     $7F
 294+ 6727                                      JumpOnBitSet l,7,StarNegYPt
 294+ 6727 CB 7D       >                        bit 	7,l
 294+ 6729 C2 32 67    >                        jp      nz,StarNegYPt
 295+ 672C C6 60                                add     a,$60
 296+ 672E 47                                   ld      b,a
 297+ 672F C3 37 67                             jp      StarDoneY
 298+ 6732 47           StarNegYPt:             ld      b,a
 299+ 6733 3E 60                                ld      a,$60
 300+ 6735 90                                   sub     b
 301+ 6736 47                                   ld      b,a
 302+ 6737 3E 92        StarDoneY:              ld      a,L2DustColour
 303+ 6739 C5                                   push    bc
 304+ 673A              .DrawStar:              MMUSelectLayer2
 304+ 673A ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 305+ 673E CD 8E E2                             call    l2_plot_pixel
 306+ 6741 FD 7E 05                             ld      a,(iy+5)
 307+ 6744 C1                                   pop    bc
 308+ 6745                                      JumpIfAGTENusng $60,EndofStarsLoop
 308+ 6745 FE 60       >                        cp     $60
 308+ 6747 D2 77 67    >                        jp		nc,EndofStarsLoop
 309+ 674A 3E 92                                ld      a,L2DustColour
 310+ 674C 0C                                   inc     c
 311+ 674D C5                                   push    bc
 312+ 674E                                      MMUSelectLayer2
 312+ 674E ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 313+ 6752 CD 8E E2                             call    l2_plot_pixel
 314+ 6755 FD 7E 05                             ld      a,(iy+5)
 315+ 6758 C1                                   pop    bc
 316+ 6759                                      JumpIfAGTENusng $37,EndofStarsLoop
 316+ 6759 FE 37       >                        cp     $37
 316+ 675B D2 77 67    >                        jp		nc,EndofStarsLoop
 317+ 675E 3E 92                                ld      a,L2DustColour
 318+ 6760 04                                   inc     b
 319+ 6761 C5                                   push    bc
 320+ 6762                                      MMUSelectLayer2
 320+ 6762 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 321+ 6766 CD 8E E2                             call    l2_plot_pixel
 322+ 6769 FD 7E 05                             ld      a,(iy+5)
 323+ 676C C1                                   pop    bc
 324+ 676D 3E 92                                ld      a,L2DustColour
 325+ 676F 0D                                   dec     c
 326+ 6770                                      MMUSelectLayer2
 326+ 6770 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 327+ 6774 CD 8E E2                             call    l2_plot_pixel
 328+ 6777 C1           EndofStarsLoop:         pop     bc                                      ;  0
 329+ 6778 FD E5        NextStarLoop3:          push    iy                                      ; +1
 330+ 677A E1                                   pop     hl                                      ;  0
 331+ 677B ED 34 06 00                          add     hl,6
 332+ 677F E5           NextStarLoop2:          push    hl                                      ; +1
 333+ 6780 FD E1                                pop     iy                                      ;  0
 334+ 6782 05                                   dec     b
 335+ 6783 C2 01 66                             jp      nz,StarProcessLoop
 336+ 6786 C9                                   ret
 337+ 6787 C1           ResetStar:              pop     bc                                      ; 0
 338+ 6788 FD E5                                push    iy                                      ; +1 (current star)
 339+ 678A E1                                   pop     hl                                      ; 0
 340+ 678B CD 14 65                             call    InitStarAtHL
 341+ 678E C3 78 67                             jp      NextStarLoop3
 342+ 6791              ;----------------------------------------------------------------------------------------------------------------------------------
 343+ 6791 FD 4E 00     ProjectStarXToScreen:   ld      c,(iy+0)
 344+ 6794 FD 7E 01                             ld      a,(iy+1)
 345+ 6797 6F                                   ld      l,a
 346+ 6798 E6 7F                                and     $7F
 347+ 679A 47                                   ld      b,a
 348+ 679B CD 07 73                             call    DIV16BCDivDEUNDOC
 349+ 679E 7D                                   ld      a,l
 350+ 679F                                      JumpOnBitSet a,7,StarXNegativePoint             ; LL62 up, -ve Xdist, RU screen onto XX3 heap
 350+ 679F CB 7F       >                        bit 	7,a
 350+ 67A1 C2 AC 67    >                        jp      nz,StarXNegativePoint
 351+ 67A4              ;StarXPositivePoint:									; x was positive result
 352+ 67A4 2E 80                                ld          l,ScreenCenterX						;
 353+ 67A6 26 00                                ld          h,0
 354+ 67A8 09                                   add         hl,bc								; hl = Screen Centre + X
 355+ 67A9 C3 B3 67                             jp          StarStoreXPoint
 356+ 67AC              StarXNegativePoint:                                 ; x < 0 so need to subtract from the screen centre position
 357+ 67AC 2E 80                                ld          l,ScreenCenterX
 358+ 67AE 26 00                                ld          h,0
 359+ 67B0                                      ClearCarryFlag
 359+ 67B0 B7          >                        or a
 360+ 67B1 ED 42                                sbc         hl,bc                               ; hl = Screen Centre - X
 361+ 67B3              StarStoreXPoint:                                    ; also from LL62, XX3 node heap has xscreen node so far.
 362+ 67B3 7D                                   ld          a,l
 363+ 67B4 32 DD 6A                             ld          (varStarX),a
 364+ 67B7 C9                                   ret
 365+ 67B8
 366+ 67B8 FD 46 02     ProjectStarYToScreen:   ld          b,(iy+2)
 367+ 67BB FD 7E 03                             ld          a,(iy+3)
 368+ 67BE 6F                                   ld          l,a
 369+ 67BF E6 7F                                and         $7F
 370+ 67C1 47                                   ld          b,a
 371+ 67C2 CD 07 73                             call        DIV16BCDivDEUNDOC
 372+ 67C5 7D                                   ld          a,l                                 ; XX15+2 \ sign of X dist
 373+ 67C6                                      JumpOnBitSet a,7,StarNegativeYPoint             ; LL62 up, -ve Xdist, RU screen onto XX3 heap top of screen is Y = 0
 373+ 67C6 CB 7F       >                        bit 	7,a
 373+ 67C8 C2 D3 67    >                        jp      nz,StarNegativeYPoint
 374+ 67CB                                  ;StarPositiveYPoint:									; Y is positive so above the centre line
 375+ 67CB 2E 60                               ld          l,ScreenCenterY
 376+ 67CD                                      ClearCarryFlag
 376+ 67CD B7          >                        or a
 377+ 67CE ED 42                                sbc         hl,bc  							 	; hl = ScreenCentreY - Y coord (as screen is 0 at top)
 378+ 67D0 C3 D8 67                             jp          StarStoreYPoint
 379+ 67D3              StarNegativeYPoint:									; this bit is only 8 bit aware TODO FIX
 380+ 67D3 2E 60                                ld          l,ScreenCenterY
 381+ 67D5 26 00                                ld          h,0
 382+ 67D7 09                                   add         hl,bc								; hl = ScreenCenterY + Y as negative is below the center of screen
 383+ 67D8              StarStoreYPoint:                                    ; also from LL62, XX3 node heap has xscreen node so far.
 384+ 67D8 7D                                   ld          a,l
 385+ 67D9 32 DE 6A                             ld          (varStarY),a
 386+ 67DC C9                                   ret
 387+ 67DD
 388+ 67DD
# file closed: ../../Universe/StarDust/StarRoutines.asm
 599  67DD
 600  67DD                          INCLUDE	"../../Hardware/memfill_dma.asm"
# file opened: ../../Hardware/memfill_dma.asm
   1+ 67DD
   2+ 67DD 00           memfillvalue		DB 0
   3+ 67DE 83 C3 C7 CB  memfill        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   3+ 67E2 7D
   4+ 67E3 DD 67        memfill_astrt  		DW memfillvalue
   5+ 67E5 00 40        memfill_length 		DB $00,$40
   6+ 67E7 24 10 AD     					DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
   7+ 67EA 00 00        memfill_bstrt  		DB $00,$00
   8+ 67EC 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
   9+ 67F0              memfill_cmd_len	  	EQU $ - memfill
  10+ 67F0
  11+ 67F0              memfill_dma:
  12+ 67F0              ; "memfill_dma, hl = address to fill, a = value, de = length"
  13+ 67F0              .set_fill_value:
  14+ 67F0 32 DD 67     	ld 		(memfillvalue),a
  15+ 67F3              .set_target:
  16+ 67F3 22 EA 67     	ld		(memfill_bstrt),hl
  17+ 67F6              .set_length:
  18+ 67F6 ED 53 E5 67  	ld		(memfill_length),de
  19+ 67FA              .write_dma:
  20+ 67FA 21 DE 67     	ld 		hl, memfill
  21+ 67FD 06 12        	ld 		b, memfill_cmd_len
  22+ 67FF 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
  23+ 6801 ED B3        	otir
  24+ 6803 C9           	ret
  25+ 6804
# file closed: ../../Hardware/memfill_dma.asm
 601  6804                          INCLUDE	"../../Hardware/memcopy_dma.asm"
# file opened: ../../Hardware/memcopy_dma.asm
   1+ 6804
   2+ 6804 83 C3 C7 CB  memcopy        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   2+ 6808 7D
   3+ 6809 00 00        memcopy_astrt  		DB $00,$00
   4+ 680B 00 40        memcopy_length 		DB $00,$40
   5+ 680D 14 10 CD     					DB DMA_WR1_P1INC_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_BURST_MODE;DMA_WR4_CONT_MODE
   6+ 6810 00 00        memcopy_bstrt  		DB $00,$00
   7+ 6812 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
   8+ 6816              memcopy_cmd_len	  	equ $ - memcopy
   9+ 6816
  10+ 6816              memcopy_dma:
  11+ 6816              ; "memcopy_dma, hl = target address de = source address to copy, bc = length"
  12+ 6816              .set_target:
  13+ 6816 22 10 68     	ld		(memcopy_bstrt),hl
  14+ 6819              .set_source:
  15+ 6819 ED 53 09 68  	ld		(memcopy_astrt),de
  16+ 681D              .set_length:
  17+ 681D ED 43 0B 68  	ld		(memcopy_length),bc
  18+ 6821              .write_dma:
  19+ 6821 21 04 68     	ld 		hl, memcopy
  20+ 6824 06 12        	ld 		b, memcopy_cmd_len
  21+ 6826 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
  22+ 6828 ED B3        	otir
  23+ 682A C9           	ret
  24+ 682B
# file closed: ../../Hardware/memcopy_dma.asm
 602  682B 00 00        XX12PVarQ			DW 0
 603  682D 00 00        XX12PVarR			DW 0
 604  682F 00 00        XX12PVarS			DW 0
 605  6831 00 00        XX12PVarResult1		DW 0
 606  6833 00 00        XX12PVarResult2		DW 0
 607  6835 00 00        XX12PVarResult3		DW 0
 608  6837 00           XX12PVarSign2		DB 0
 609  6838 00           XX12PVarSign1		DB 0								; Note reversed so BC can do a little endian fetch
 610  6839 00           XX12PVarSign3		DB 0
 611  683A                  INCLUDE "../../Variables/constant_equates.asm"
# file opened: ../../Variables/constant_equates.asm
   1+ 683A              ;Contants
   2+ 683A
   3+ 683A              SignMask8Bit		equ %01111111
   4+ 683A              SignMask16Bit		equ %0111111111111111
   5+ 683A              SignOnly8Bit		equ $80
   6+ 683A              SignOnly16Bit		equ $8000
   7+ 683A
   8+ 683A              Bit7Only            equ %10000000
   9+ 683A              Bit6Only            equ %01000000
  10+ 683A              Bit5Only            equ %00100000
  11+ 683A              Bit4Only            equ %00010000
  12+ 683A              Bit3Only            equ %00001000
  13+ 683A              Bit2Only            equ %00000100
  14+ 683A              Bit1Only            equ %00000010
  15+ 683A              Bit0Only            equ %00000001
  16+ 683A              Bit7Clear           equ %01111111
  17+ 683A              Bit6Clear           equ %10111111
  18+ 683A              Bit5Clear           equ %11011111
  19+ 683A              Bit4Clear           equ %11101111
  20+ 683A              Bit3Clear           equ %11110111
  21+ 683A              Bit2Clear           equ %11111011
  22+ 683A              Bit1Clear           equ %11111101
  23+ 683A              Bit0Clear           equ %11111110
  24+ 683A              ConstPi				equ $80
  25+ 683A              ConstNorm           equ 197
  26+ 683A              ;OpCodes
  27+ 683A              OpCodeSCF           equ $37
  28+ 683A              OpCodeCCF           equ $3F
  29+ 683A              OpCodeAndA          equ $A7
  30+ 683A              OpCodeClearCarryFlag equ OpCodeAndA
  31+ 683A
  32+ 683A              ;Text Tokens
  33+ 683A              EliteToken			equ $1E			; Token ID for text messsage ---- E L I T E ----
  34+ 683A              BrabenBellToken 	equ $0D
  35+ 683A              AcorToken			equ $0C
  36+ 683A              ; Cursor Bits
  37+ 683A              CursorClimb         equ %10000000
  38+ 683A              CursorDive          equ %01000000
  39+ 683A              CursorLeft          equ %00100000
  40+ 683A              CursorRight         equ %00010000
  41+ 683A              CursorHome          equ %00001000
  42+ 683A              CursorRecenter      equ %00000100
  43+ 683A
  44+ 683A              ; Intro Screen
  45+ 683A              TitleShip			equ	$8C
  46+ 683A              RotationUnity		equ $60
  47+ 683A              DBCheckCode			equ $DB
  48+ 683A              MaxVisibility		equ $1F
  49+ 683A              FarInFront			equ $C0
  50+ 683A              ; Equipment Flags
  51+ 683A              EquipmentItemFitted     equ $FF
  52+ 683A              EquipmentItemNotFitted  equ 0
  53+ 683A              ; Universe Managment
  54+ 683A              PlanetTypeMeridian      equ 128
  55+ 683A              PlanetMinRadius         equ 6
  56+ 683A
  57+ 683A              ShipTotalModelCount     equ 44
  58+ 683A              ShipTypeScoopable       equ 4         ; a sub set of junk
  59+ 683A              ShipTypeJunk            equ 3
  60+ 683A              ShipTypeStation         equ 2
  61+ 683A              ShipTypeMissile         equ 1
  62+ 683A              ShipTypeNormal          equ 0
  63+ 683A              ShipTypeText            equ 253
  64+ 683A              ShipTypeDebug           equ 254
  65+ 683A              ShipTypeEmpty           equ 255
  66+ 683A
  67+ 683A              SpawnTypeStation        EQU 0
  68+ 683A              SpawnTypeAsteroid       EQU SpawnTypeStation        + 1
  69+ 683A              SpawnTypeJunk           EQU SpawnTypeAsteroid       + 1
  70+ 683A              SpawnTypeCop            EQU SpawnTypeJunk           + 1
  71+ 683A              SpawnTypeTrader         EQU SpawnTypeCop            + 1
  72+ 683A              SpawnTypeNonTrader      EQU SpawnTypeTrader         + 1
  73+ 683A              SpawnTypePirate         EQU SpawnTypeNonTrader      + 1
  74+ 683A              SpawnTypeHunter         EQU SpawnTypePirate         + 1
  75+ 683A              SpawnTypeThargoid       EQU SpawnTypeHunter         + 1
  76+ 683A              SpawnTypeMission        EQU SpawnTypeThargoid       + 1
  77+ 683A              SpawnTypeStationDebris  EQU SpawnTypeMission        + 1
  78+ 683A              SpawnTypeMissionEvent   EQU SpawnTypeStationDebris  + 1
  79+ 683A              SpawnTypeDoNotSpawn     EQU SpawnTypeMissionEvent   + 1
  80+ 683A
  81+ 683A
  82+ 683A              ; Laser and Missile Settings
  83+ 683A              ; Laser and Missile
  84+ 683A              ShipLaserPower          equ %11110000
  85+ 683A              ShipMissileCount        equ %00001111
  86+ 683A              ShipMissiles1           equ %00000001
  87+ 683A              ShipMissiles2           equ %00000010
  88+ 683A              ShipMissiles3           equ %00000011
  89+ 683A              ShipMissiles4           equ %00000100
  90+ 683A              ShipMissiles5           equ %00000101
  91+ 683A              ShipMissiles6           equ %00000110
  92+ 683A              ShipMissiles7           equ %00000111
  93+ 683A              ShipMissiles8           equ %00001000
  94+ 683A              ShipMissiles9           equ %00001001
  95+ 683A              ShipMissiles10          equ %00001010
  96+ 683A              ShipMissiles11          equ %00001011
  97+ 683A              ShipMissiles12          equ %00001100
  98+ 683A              ShipMissiles13          equ %00001101
  99+ 683A              ShipMissiles14          equ %00001110
 100+ 683A              ShipMissiles15          equ %00001111
 101+ 683A              ; AI Flags  UniverseAIControl
 102+ 683A              ShipCanAnger            equ %10000000   ; Yes or no
 103+ 683A              ShipFighterBaySize      equ %01110000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 104+ 683A              ShipFighterBaySize1     equ %00010000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 105+ 683A              ShipFighterBaySize2     equ %00100000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 106+ 683A              ShipFighterBaySize3     equ %00110000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 107+ 683A              ShipFighterBaySize4     equ %01000000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 108+ 683A              ShipFighterBaySize5     equ %01010000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 109+ 683A              ShipFighterBaySizeInf   equ %01110000   ; Infinite fighters (well 255 as thats enough)
 110+ 683A              ShipFighterType         equ %00001100   ; 4 types 0 = Worm, 1 = Sidewinder, 2 = Viper, 3 = Thargon
 111+ 683A              ShipFighterWorm         equ %00000000
 112+ 683A              ShipFighterSidewinder   equ %00000100
 113+ 683A              ShipFighterViper        equ %00001000
 114+ 683A              ShipFighterThargon      equ %00001100
 115+ 683A              ShipUltraHostile        equ %00000010   ; If ultra hostile, will never back down so behaves like a missile
 116+ 683A              ShipFree                equ $00000011   ; Unused bits at present for later
 117+ 683A              ; NewBTactics
 118+ 683A              ShipIsTrader            equ Bit0Only   ; Trader flag  80% are peaceful 20% also have Bounty Hunter flag
 119+ 683A              ShipIsBountyHunter      equ Bit1Only   ;
 120+ 683A              ShipIsHostile           equ Bit2Only   ; Also used as Angry flag now
 121+ 683A              ShipIsPirate            equ Bit3Only   ;
 122+ 683A              ShipIsDocking           equ Bit4Only   ;
 123+ 683A              ShipIsBystander         equ Bit5Only   ;
 124+ 683A              ShipIsCop               equ Bit6Only   ;
 125+ 683A              ShipHasEscapePod        equ Bit7Only   ;
 126+ 683A              ShipHostileNewBitNbr    equ 2
 127+ 683A
 128+ 683A              ; UBnkaiatkecm
 129+ 683A              ;Unused                 equ Bit0Only
 130+ 683A              ;Unused                 equ Bit1Only
 131+ 683A              ;Unused                 equ Bit2Only
 132+ 683A              ShipIsDot               equ Bit3Only
 133+ 683A              ShipKilled              equ Bit4Only    ; Ship has just been marked as killed so initiate cloud of debris
 134+ 683A              ShipExploding           equ Bit5Only
 135+ 683A              ShipIsVisible           equ Bit6Only
 136+ 683A              ShipAIEnabled           equ Bit7Only   ;
 137+ 683A
 138+ 683A
 139+ 683A              ; UBnkaiakecm 2
 140+ 683A              ;ShipAngryNewBitNbr      equ 4
 141+ 683A              ShipExplosionDuration   equ 75         ; amount of frames an explosion lasts for
 142+ 683A              ShipNotHostile          equ Bit2Clear   ;
 143+ 683A              ShipIsNotDot            equ Bit3Clear
 144+ 683A              ShipIsDotBitNbr         equ 3
 145+ 683A              ShipKilledBitNbr        equ 4
 146+ 683A              ShipIsVisibleBitNbr     equ 6
 147+ 683A              ShipIsScoopDockEsc      equ Bit7Only   ;
 148+ 683A              ShipAIDisabled          equ Bit7Clear
 149+ 683A              ShipAIEnabledBitNbr     equ 7
 150+ 683A              ShipExplodingBitNbr     equ 5
 151+ 683A              ; Equipment Defaults
 152+ 683A              ECMCounterMax           equ $80
 153+ 683A              ; Main Loop State
 154+ 683A              StatePlayerDocked       equ $FF
 155+ 683A              StateCompletedLaunch    equ $FD
 156+ 683A              StateInTransition       equ $FE
 157+ 683A              StateHJumping           equ $FC
 158+ 683A              StateHEntering          equ $FB
 159+ 683A              StateCompletedHJump     equ $FA
 160+ 683A              StateNormal             equ 0
 161+ 683A              ; Missile Stage flags , $8x = locked to ship id x, $0x = fire at ship id x requested
 162+ 683A              StageMissileNotTargeting equ $FF
 163+ 683A              StageMissileTargeting   equ $FE
 164+ 683A
 165+ 683A
 166+ 683A              ShipMaxDistance     equ 192
 167+ 683A              HyperSpaceTimers    equ $0B0B
 168+ 683A
 169+ 683A              ; -- game limts
 170+ 683A              MaxNumberOfStars	equ 11
 171+ 683A              ConsoleRefreshInterval  equ 5
 172+ 683A              MaxJunkStation      equ 3
 173+ 683A              MaxJunkFreeSpace    equ 5
 174+ 683A              WarpCoolDownPeriod  equ 90
 175+ 683A
 176+ 683A              ShipTypeSize		equ	32 			;??????? just a guess for now
 177+ 683A              ShipSST				equ 4			; its a space station
 178+ 683A              UniverseBasePage 	equ 70			; Base memory bank for universe Item #0
 179+ 683A              ShipDataBasePage	equ	90			; Needs 2mb upgrade but what the heck
 180+ 683A              ShipCountMax		equ	2			; For now just 2 ships to debug
 181+ 683A              LineLimitPerShip	equ 70			; Max lines per ship
 182+ 683A              FaceLimitPerShip	equ	70			; Same as line limit to simplify some logic
 183+ 683A              ; "NEED TO DEFINE SHIPTYPESIZE TODO"
 184+ 683A
 185+ 683A              ; Memory page managment	(Refers to a memory slot as a place to access data)
 186+ 683A              ShipDataSlot		equ	6			; this may move into rom swap out space later
 187+ 683A              UniverseObjectSlot	equ	7
 188+ 683A
 189+ 683A              KeyForwardsView		equ	$20
 190+ 683A              ; Game specific equates
 191+ 683A              MissileDropHeight   equ 5           ; how far the missile is ejected on launch in y axis
 192+ 683A              WarpSequenceCount   equ 50
 193+ 683A
 194+ 683A              ;...Game Colour Mapping
 195+ 683A              L2DustColour        equ L2ColourGREY_1
 196+ 683A              L2SunScannerBright  equ 252
 197+ 683A              L2SunScanner        equ 180
 198+ 683A              L2DebrisColour      equ L2ColourYELLOW_1
 199+ 683A
 200+ 683A
 201+ 683A              ; Ship Data
 202+ 683A              ;;;;	.XX21	\ -> &5600 \ Table of pointers to ships' data given to XX0
 203+ 683A              ;;;;00 7F			 EQUW &7F00 \ type  1 is #MSL  Missile data on page off bottom of screen
 204+ 683A              ;;;;00 00			 EQUW 0     \ type  2 is #SST  Space Station, Coriolis or Dodo.
 205+ 683A              ;;;;00 00			 EQUW 0     \ type  3 is #ESC  Escape capsule
 206+ 683A              ;;;;00 00			 EQUW 0     \ type  4 is #PLT  Plate, alloys
 207+ 683A              ;;;;00 00			 EQUW 0     \ type  5 is #OIL  Cargo cannister
 208+ 683A              ;;;;00 00			 EQUW 0     \ type  6 is       Boulder
 209+ 683A              ;;;;00 00			 EQUW 0     \ type  7 is #AST  Asteroid
 210+ 683A              ;;;;00 00			 EQUW 0     \ type  8 is #SPL  Splinter, rock.
 211+ 683A              ;;;;00 00			 EQUW 0     \ type  9 is #SHU  Shuttle
 212+ 683A              ;;;;00 00			 EQUW 0     \ type 10 is       Transporter
 213+ 683A              ;;;;00 00			 EQUW 0     \ type 11 is #CYL  Cobra Mk III,  Boa
 214+ 683A              ;;;;00 00			 EQUW 0     \ type 12 is       Python
 215+ 683A              ;;;;00 00			 EQUW 0     \ type 13 is       Last of three traders
 216+ 683A              ;;;;00 00			 EQUW 0     \ type 14 is #ANA  Anaconda
 217+ 683A              ;;;;00 00			 EQUW 0     \ type 15 is #WRM  Worm with Anaconda
 218+ 683A              ;;;;00 00			 EQUW 0     \ type 16 is #COP  Viper
 219+ 683A              ;;;;00 00			 EQUW 0     \ type 17 is       First pirate
 220+ 683A              ;;;;00 00			 EQUW 0     \ type 18 is
 221+ 683A              ;;;;00 00			 EQUW 0     \ type 19 is #KRA  Krait small pirate
 222+ 683A              ;;;;00 00			 EQUW 0     \ type 20 is #ADA  Adder
 223+ 683A              ;;;;00 00			 EQUW 0     \ type 21 is
 224+ 683A              ;;;;00 00			 EQUW 0     \ type 22 is
 225+ 683A              ;;;;00 00			 EQUW 0     \ type 23 is
 226+ 683A              ;;;;00 00			 EQUW 0     \ type 24 is #CYL2 Last strong pirate
 227+ 683A              ;;;;00 00			 EQUW 0     \ type 25 is #ASP  Asp Mk II
 228+ 683A              ;;;;00 00			 EQUW 0     \ type 26 is #FER  Fer de Lance
 229+ 683A              ;;;;00 00			 EQUW 0     \ type 27 is
 230+ 683A              ;;;;00 00			 EQUW 0     \ type 28 is	Last of three bounty hunters
 231+ 683A              ;;;;00 00			 EQUW 0     \ type 29 is #THG  Thargoid
 232+ 683A              ;;;;00 00			 EQUW 0     \ type 30 is #TGL  Thargon
 233+ 683A              ;;;;00 00			 EQUW 0     \ type 31 is #CON  Constrictor
 234+ 683A              ;;;;	.E%	\ -> &563E \ Hull NEWB bits are escpod, cop, inno, ?, pirate, angry, hunter, trader.
 235+ 683A              ;;;;			\ NEWB examples
 236+ 683A              ;;;;\ 21			EQUB &21    \ 0010 0001    9 Shuttle has no escape pod, inno, trader.
 237+ 683A              ;;;;\ 61			EQUB &61    \ 0110 0001   10 Tansporter no escape pod, Cop, inno, trader.
 238+ 683A              ;;;;\ A0			EQUB &A0    \ 1010 0000   11 Cobra has Escape pod, inno, not a trader.
 239+ 683A              ;;;;\ C2			EQUB &C2    \ 1100 0010   16 Viper has Escape pod, Cop, hunter.
 240+ 683A              ;;;;\ 8C			EQUB &8C    \ 1000 1100   19 Krait pirate has escape pod, is pirate and angry.
 241+ 683A
# file closed: ../../Variables/constant_equates.asm
 612  683A                  INCLUDE "../../Variables/general_variables.asm"
# file opened: ../../Variables/general_variables.asm
   1+ 683A                  IFNDEF LASER_V2
   2+ 683A                  DEFINE  LASER_V2    1
   3+ 683A                  ENDIF
   4+ 683A              ; Debugging data
   5+ 683A 00 00 00...  failureDiag DS  10              ; 10 bytes to log data before a failure
   6+ 6844
   7+ 6844              LogFailure:     MACRO messageAddress
   8+ 6844 ~                            ld      hl,messageAddress
   9+ 6844 ~                            ld      de,failureDiag
  10+ 6844 ~                            ld      bc,10
  11+ 6844 ~                            ldir
  12+ 6844                              ENDM
  13+ 6844
  14+ 6844
  15+ 6844 00 00        varAxis1	DW 	0				; address of first axis in a rotation action
  16+ 6846 00 00        varAxis2	DW	0				; address of 2nd axis in a roation action
  17+ 6848              ; Variables to simulate 6502 registers until code fixed
  18+ 6848              ; These must be here in this order as reading Y and X can then be a 16 bit read
  19+ 6848 00           regX		DB	0               ; using 16 bit read into BC this would go into C
  20+ 6849 00           regY		DB	0               ; using 16 bit read into BC this would go into B
  21+ 684A 00           regA		DB	0
  22+ 684B
  23+ 684B
  24+ 684B 00           varGPLoopA	DB	0				; General Purpose innermost loop variable
  25+ 684C 00 00        INF			DW	0				; page 0 &20 Used to get address from UNIV array
  26+ 684E 00 00        INF28		DW	0				; page 0 &20 Used to get address from UNIV array
  27+ 6850
  28+ 6850
  29+ 6850
  30+ 6850              ;XX16		DS	16				; 16 byte Matrix
  31+ 6850
  32+ 6850              P0INWK							; page 0 & 46
  33+ 6850              p0INWK31						; page 0 & 65
  34+ 6850              P0INWK36						; PAGE 0 &6A
  35+ 6850
  36+ 6850 00           XX4			DB	0				; XX4 page 0 &96 last Normal Found to be visible
  37+ 6851              LastNormalVisible	equ	XX4
  38+ 6851              varXX4              equ XX4
  39+ 6851
  40+ 6851
  41+ 6851
  42+ 6851 00           PATG		DB	0				; 6502 &03C9
  43+ 6852 00 00        SLSP 		DW	0				; &03B0 \ SLSP \ ship lines pointer
  44+ 6854
  45+ 6854
  46+ 6854              ;UNIV		DS FreeListSize*2	; Array of Universe Pointers
  47+ 6854              ;HULLINDEX	DS ShipTypeSize*2	; hull index for table at XX21= &F XX21-1,Y
  48+ 6854
  49+ 6854              ; Present System Variables
  50+ 6854
  51+ 6854 2B           RandomSeed				DB	43			    ; 00 DEBUG JUST SOME START VALUES
  52+ 6855 20           RandomSeed1				DB	32	            ; 01
  53+ 6856 0C           RandomSeed2				DB	12			    ; 02
  54+ 6857 42           RandomSeed3				DB	66			    ; 03
  55+ 6858 00 00 00 00  RandomSeedSave          DS  4               ; used in explosion routine to save randoms
  56+ 685C 00           varT1					DB	0				; 06
  57+ 685D 00           SClo					DB 0				; 07
  58+ 685E 00           SChi					DB 0				; 08
  59+ 685F 00           varP					DB 0 				; 10	XX16+7
  60+ 6860 00           varPhi					DB 0 				; 11	XX16+8
  61+ 6861 00           varPhi2					DB 0 				; 12	XX16+9
  62+ 6862 00           varPhiSign              DB 0
  63+ 6863              varPp1                  equ varPhi
  64+ 6863              varPp2                  equ varPhi2
  65+ 6863              varPp3                  equ varPhiSign
  66+ 6863 00           UnivPointerLo			DB	0				; 20		INF                 XX0+2
  67+ 6864 00           UnivPointerHi			DB	0				; 21      INF+1               XX0+3
  68+ 6865              UnivPointer				equ	UnivPointerLo
  69+ 6865 00           varV					DB 0				; 22                          XX0+4
  70+ 6866 00           varVHi					DB 0				; 23                          XX0+5
  71+ 6867 00           varXXlo                 DB 0                ; 24
  72+ 6868 00           varXXHi                 DB 0                ; 25
  73+ 6869              varXX					equ	varXXlo
  74+ 6869 00           YYlo                    DB 0                ; 26
  75+ 686A 00           YYHi                    DB 0                ; 27
  76+ 686B              varYY					equ	YYlo
  77+ 686B              											;	28
  78+ 686B              											;	29
  79+ 686B              ;PlayerShipPositionData - Must be contiguous for setup
  80+ 686B 00           BETA 					DB	0               ; 2A        (pitch done)
  81+ 686C 00           JSTY                    DB  0               ; Joystick analog
  82+ 686D 00           BET1 					DB	0               ; 2B        lower7 magnitude
  83+ 686E 00           BET2                    DB  0               ;            climb sign
  84+ 686F 00           BET2FLIP				DB	0				; 7C		BET 2 pitch Sign negated
  85+ 6870 1F           BET1MAXC                DB  31              ; max climb
  86+ 6871 E1           BET1MAXD                DB  -31             ; max dive
  87+ 6872 00           XC						DB	0               ; 2C
  88+ 6873 00           YC						DB 	0               ; 2D
  89+ 6874              ;... ECM logic. If another ship adds ECM then we just set the loop A and B to starting values so they overlap
  90+ 6874 00           ECMCountDown            DB  0
  91+ 6875 00           ECMLoopB                DB  0
  92+ 6876 00 00        JSTX                    DW  0               ;           Joystick analog value
  93+ 6878 00           ALPHA					DB	0				; 8D        Alpha with bit 7 sign
  94+ 6879 00           ALP1					DB 	0				; 31		ALP1	ABS Alpha
  95+ 687A 00           ALP2					DB  0				; 32		ALP2	Roll Sign
  96+ 687B 00           ALP2FLIP				DB  0				; 33		ALP2	negated roll sign
  97+ 687C 1F           ALP1MAXR                DB  31               ;   Maximum roll, added becuase we may allow different ship types
  98+ 687D E1           ALP1MAXL                DB  -31             ;   Maximum roll, added becuase we may allow different ship types
  99+ 687E
 100+ 687E
 101+ 687E              ;-- Message handler -----------------------------------------------------------------------------------------------------------------
 102+ 687E              MAXMESSAGES             EQU 5
 103+ 687E              MESSAGETIMELIMIT        EQU 20
 104+ 687E              MESSAGESIZE             EQU 33
 105+ 687E              MESSAGELINE             EQU $0001
 106+ 687E
 107+ 687E 00           MessageCount            DB  0                ; used for enquing messages later
 108+ 687F 00           MessageCurrent          DB  0
 109+ 6880 05 00        MessageIndex            DW  MAXMESSAGES
 110+ 6882 00 00 00...  MessageQueue            DS  MAXMESSAGES * MESSAGESIZE
 111+ 6927 05           MessageTimeout          DB  MAXMESSAGES
 112+ 6928 00 00 00...  IndexedWork				DS	37				; General purpose work space when doing temp arrays
 113+ 694D
 114+ 694D              ; MOVED TO Universe XX19					DB	0				; page 0 &67
 115+ 694D              ; MOVED TO Universe XX20					DB	0				; page 0 &67 also used as XX19+1 for XX19 being a word
 116+ 694D              ;DEFUNCT EQUATE NormalCountCopyBy4		equ	XX20			; Also used for normal * 4 holding variable
 117+ 694D 00           XX21					DB  0				; this may be part of XX20/xx21 accordign to spawn new shipXX21		DW	0				; Ah XX21 is hull pointer  hull pointer lo as it can;t hold HULLINDX as 16bit array
 118+ 694E              ;XX21 is the pointer table to the pages for ship types. this will be repalaced by paging so just need an equate for first page
 119+ 694E
 120+ 694E
 121+ 694E 00           QQ17					DB	0				;   72
 122+ 694F 00           XX18xlo                 DB  0               ;	72		XX18   xlo
 123+ 6950 00           XX18xhi                 DB  0               ;	73		XX18+1 xhi
 124+ 6951 00           XX18xsg                 DB  0               ;	74		XX18+2 xsgn
 125+ 6952 00           XX18ylo                 DB  0               ;	75		XX18   ylo
 126+ 6953 00           XX18yhi                 DB  0               ;	76		XX18+1 yhi
 127+ 6954 00           XX18ysg                 DB  0               ;	77		XX18+2 ysgn
 128+ 6955 00           XX18zlo                 DB  0               ;	78		XX18   zlo
 129+ 6956 00           XX18zhi                 DB  0               ;	79		XX18+1 zhi
 130+ 6957 00           XX18zsg                 DB  0               ;	7A		XX18+2 zsgn
 131+ 6958
 132+ 6958 28           SHIPMAXSPEED            DB  40              ; variable to facilitate ship editing later
 133+ 6959 00           DELTA					DB 	0				; 7D 		DELTA  \ bpl -2 inserted here to stall from title code if byte check fails
 134+ 695A 00           DELT4Lo					DB 	0				; 7E
 135+ 695B 00           DELT4Hi					DB 	0				; 7F
 136+ 695C              DELTA4                  equ                 DELT4Lo
 137+ 695C
 138+ 695C              ; SoundFX Variables -------------------------------------------------------------------------------------------
 139+ 695C              ;DEFUNCT, uses DELTA/ LAST_DELTAEngineSoundChanged:     DB  0
 140+ 695C FF           SoundFxToEnqueue        DB  $FF             ; $FF No sound to enque,if it is $FF then next sound will not get enqued
 141+ 695D 00           InterruptCounter        DB 0                ; simple marker updated once per IM2 event
 142+ 695E
 143+ 695E
 144+ 695E              ; Not thise must be in this order else 16 bit fetches will fail
 145+ 695E 00           varU                    DB  0               ;   80
 146+ 695F 00           varQ					DB  0 				;	81
 147+ 6960 00           varR					DB  0 				;	82
 148+ 6961 00           varS					DB  0 				;	83
 149+ 6962              varRS                   equ varR
 150+ 6962
 151+ 6962 00 00        varU16                  DW  0               ; 16 bit variant on varU as I can't use above for this
 152+ 6964
 153+ 6964 00           XSAV					DB	0				; 84	   XSAV usef for nearby ship count outer
 154+ 6965 00           YSAV                    DB  0               ; 85
 155+ 6966 00           XX17					DB	0				; 86
 156+ 6967              RequiredScale			equ  XX17			; use to hold calculated scale in drawing ship
 157+ 6967              varXX17                 equ  XX17
 158+ 6967 00           ScreenChanged           DB  0
 159+ 6968 00           ScreenIndex             DB  0
 160+ 6969 00 00        ScreenIndexTablePointer DW  0
 161+ 696B 00           InvertedYAxis           DB  0
 162+ 696C 00           MenuIdMax				DB	0				;	87		MenuIdMax		QQ11
 163+ 696D              											; Bit 7 Set  ShortRangeChart    $80
 164+ 696D              											; Bit 6 Set  Galactic Chart     $40
 165+ 696D              											; Bit 5 Set  Market Place       $20
 166+ 696D              											; Bit 4 Set  Status Screen      $10
 167+ 696D              											; Bit 3 Set  Display Inventory  $08
 168+ 696D                                                          ; Bit 2 Set  Planet Data        $04
 169+ 696D                                                          ; View bit combinations if the ones above not matched
 170+ 696D                                                          ; bits 1 0
 171+ 696D                                                          ;      1 1  Front view , i.e. $03
 172+ 696D                                                          ;      1 0  Aft View          $02
 173+ 696D                                                          ;      0 1  Left View         $01
 174+ 696D                                                          ;      0 0  Right view        $00
 175+ 696D              											; Bit 0 Set  Data On System
 176+ 696D              											; 0  Space View (Not a menu)
 177+ 696D 00           ZZDust					DB	0				;	88		ZZDust (Poss 16 bit need to check)
 178+ 696E 00           XX13                    DB  0               ;   89
 179+ 696F 00           TYPE					DB	0				; 8C used for ship type in drawing
 180+ 6970              ;Docked flag = 00 = in free space
 181+ 6970              ;              FF = Docked
 182+ 6970              ;              FE = transition
 183+ 6970              ;              FD = Setup open space and transition to not docked
 184+ 6970              ;              FC = Hyperspace manimation
 185+ 6970              ;              FB = Hyperspace complete
 186+ 6970 00           varSWAP                 DB  0               ; 90 , general purpose swap variable
 187+ 6971 00           varCNT                  DB  0               ; 93
 188+ 6972
 189+ 6972 00           varK					DB	0				; 40
 190+ 6973 00           varKp1					DB	0				; 41
 191+ 6974 00           varKp2					DB	0				; 42
 192+ 6975 00           varKp3					DB	0				; 43
 193+ 6976
 194+ 6976 00           varK2                   DB  0               ; 9B
 195+ 6977 00           varK2p1                 DB  0               ; 9C K2 plus 1
 196+ 6978 00           varK2p2                 DB  0               ; 9D K2 plus 2
 197+ 6979 00           varK2p3                 DB  0               ; 9E K2 plus 3
 198+ 697A
 199+ 697A 00           Point                   DB  0               ; 9F      POINT
 200+ 697B
 201+ 697B 00           varT					DB	0				; D1
 202+ 697C 00           varTSign                DB  0               ; for teh odd need for a 16 bit varT
 203+ 697D
 204+ 697D 00 00 00...  varVector9ByteWork      DS  9
 205+ 6986
 206+ 6986 00 00 00 00  varK3					DS	4				; D2
 207+ 698A 00           varK3p2					DB	0				; 42
 208+ 698B 00           varK3p3					DB	0				; 43
 209+ 698C              varK3p1					equ varK3+1			; D3
 210+ 698C 00 00 00 00  varK4					DS	4				; E0
 211+ 6990              varK4p1					equ varK4+1			; D3
 212+ 6990 00 00 00...  varK5                   DS  6
 213+ 6996              varK5p2                 equ varK5+2
 214+ 6996 00 00 00...  varK6                   DS  6
 215+ 699C              varK6p2                 equ varK6+2
 216+ 699C              ;Heap
 217+ 699C
 218+ 699C 00 00        HeapStart				DS	2				; &0100 XX3 50 bytes for now
 219+ 699E 00 00 00...  HeapData				DS	50
 220+ 69D0              ; Contains 				X 16 bit, Y ;MissileArmedStatus		DB	0				; 0344 MSAR   using MissileTarget, if missile is not armed tehn target is FF
 221+ 69D0              ; TODO will need an read for a list of missiles, who they are targeting an the target current vector for AI persuit
 222+ 69D0              ; i.e. a list of programmed missiles in universe slot list code
 223+ 69D0 00 00 00...  DampingKeys				DS  7				; 0387 - 038D
 224+ 69D7              ;  #&6 Does K toggle keyboard/joystick control -  03CD certainly makes keyboard not work anymore.
 225+ 69D7              ;  #&5 Does J reverse both joystick channels
 226+ 69D7              ;  #&4 Does Y reverse joystick Y channel			03CB
 227+ 69D7              ;  #&2 Does X toggle startup message display ? PATG?	03C9
 228+ 69D7              ;  #&3 Does F toggle flashing information			03CA
 229+ 69D7              ;  #&1 Does A toggle keyboard auto-recentering ?
 230+ 69D7              ;  #&0 Caps-lock toggles keyboard flight damping
 231+ 69D7
 232+ 69D7              ;-- Galaxy and Universe Variables ----------------------------------------------------------------------------------------------------
 233+ 69D7 00 00 00...  SystemSeed				DS  5				;	6C		QQ15	Current Galaxy Seed
 234+ 69DC 00 00 00...  StockAvaliabiliy		DS 	16				; 038D - 039C Stock inventory in station
 235+ 69EC 00           AlienItemsAvaliability  DB	0				; 039D
 236+ 69ED 00           RandomMarketSeed		DB	0				; 039E   \ QQ26	\ random byte for each system vist (for market)
 237+ 69EE 00           Galaxy      			DB	0				; 0367 Galaxy (incremented with galactiv drive
 238+ 69EF 00 00 00...  WorkingSeeds			DS	6
 239+ 69F5 00 00 00...  PresentSystemSeeds		DS	6				; 03B2 - 03B7
 240+ 69FB 00 00 00...  GalaxySeeds				DS	6				; 035B - 0360 QQ21
 241+ 6A01 00           PresentSystemX			DB	0				; System we are currently in
 242+ 6A02 00           PresentSystemY			DB  0				; System we are currently in
 243+ 6A03 00           TargetSystemX			DB	0				; System we are targeting for jump
 244+ 6A04 00           TargetSystemY			DB	0				; System we are targeting for jump
 245+ 6A05              ; --- Current System Data ------------------------------------------------------------------------------------------------------------
 246+ 6A05 00           GovPresentSystem		DB	0				; 03AE Govenment
 247+ 6A06 00           TekPresentSystem		DB	0				; 03AF Technology
 248+ 6A07 00           SpaceStationSafeZone    DB  0               ; Flag to determine if we are in safe zone
 249+ 6A08 00           ExtraVesselsCounter     DB  0
 250+ 6A09 00           JunkCount				DB  0				; $033E
 251+ 6A0A 00           AsteroidCount           DB  0               ; Not used as yet
 252+ 6A0B 00           TransporterCount        DB  0
 253+ 6A0C 00           CopCount                DB  0
 254+ 6A0D 00           PirateCount             DB  0
 255+ 6A0E              ;- commander and ship state variables ------------------------------------------------------------------------------------------------
 256+ 6A0E 00           NbrMissiles				DB	0				; 038B	Does this clash with Dampingkeys?
 257+ 6A0F 00           PlayerECMActiveCount    DB  0               ; Countdown for player ECM
 258+ 6A10 00           FugitiveInnocentStatus	DB	0				; 038C	FIST
 259+ 6A11 00 00        KillTally  				DW	0				; 039F - 03A0 \ TALLY   \ kills lo hi
 260+ 6A13 00           CurrentRank             DB  0   			;
 261+ 6A14 00           MarketPrice				DB	0				; 03AA QQ24
 262+ 6A15 00           MaxStockAvaliable		DB  0				; 03AB   \ QQ25     \ max available
 263+ 6A16 00           SystemEconomy			DB  0				; 03AC \ QQ28   \ the economy byte of present system (0 is Rich Ind.)
 264+ 6A17 00           CargoItem				DB	0				; 03AD (I think its item type just scooped) QQ29
 265+ 6A18 00 00        ShipLineStackPointer	DW	0				; 03B0 & 03B1 ship Lines pointer reset to top LS% = &0CFF (make DW for z80 and direct hl pointer)
 266+ 6A1A              											; this is ship lines stack pointer so may be redundant with paging
 267+ 6A1A              											; LS = line stack so we will have one for now to remove later
 268+ 6A1A              ; - no longer used, holding here intil its safe to delte
 269+ 6A1A 00           MCH						DB	0				; 03A4  \ MCH  \ old message to erase
 270+ 6A1B 00           COMP     				DB	0				; 03A1 2nd competion byte used for save integrity checks?
 271+ 6A1C              ; not needed as we don't do security on file COK						DB	0				; 0366 Competition Byte what ? Does some file check and accelleration check
 272+ 6A1C              ; - no longer used, holding here intil its safe to delte
 273+ 6A1C
 274+ 6A1C 00           DisplayEcononmy			DB	0				; 03B8
 275+ 6A1D 00           DisplayGovernment		DB  0				; 03B9 Is it target? 03B9 \ QQ4	 \ Government, 0 is Anarchy.
 276+ 6A1E 00           DisplayTekLevel			DB	0				; 03BA   \ QQ5	\ Tech
 277+ 6A1F 00 00        DisplayPopulation		DW	0				; 03BB \ QQ6  \ population*10
 278+ 6A21 00 00        DisplayProductivity		DW	0				; 03BD \ QQ7   \ productivity*10
 279+ 6A23 00 00        Distance          		DW	0				; 03BE \ QQ8 distince in 0.1LY units
 280+ 6A25 00 00        DisplayRadius			DW	0
 281+ 6A27 00 00 00     ParentPlanetX           DS  3               ; used when spawining space station to determine origin
 282+ 6A2A 00 00 00     ParentPlanetY           DS  3               ;
 283+ 6A2D 00 00 00     ParentPlanetZ           DS  3               ;
 284+ 6A30              ; --- Used in creation of sun and planet ------------------------------------------------------------------------------------------------
 285+ 6A30 00           PlanetXPos              DS  1
 286+ 6A31 00           PlanetYPos              DS  1
 287+ 6A32 00           PlanetZPos              DS  1
 288+ 6A33 00           PlanetType              DS  1
 289+ 6A34 00           SunXPos                 DS  1
 290+ 6A35 00           SunYPos                 DS  1
 291+ 6A36 00           SunZPos                 DS  1
 292+ 6A37              ; -- Current Missile Runbtime data ------------------------------------------------------------------------------------------------
 293+ 6A37 00           CurrentMissileBank:     DB      0                                   ; used by missile logic as local copy of missile bank number
 294+ 6A38 00 00        MissileXPos             DW      0
 295+ 6A3A 00           MissileXSgn             DB      0
 296+ 6A3B 00 00        MissileYPos             DW      0
 297+ 6A3D 00           MissileYSgn             DB      0
 298+ 6A3E 00 00        MissileZPos             DW      0
 299+ 6A40 00           MissileZSgn             DB      0
 300+ 6A41 00 00        CurrentTargetXpos       DS      2
 301+ 6A43 00 00        CurrentTargetXsgn       DS      2
 302+ 6A45 00 00        CurrentTargetYpos       DS      2
 303+ 6A47 00 00        CurrentTargetYsgn       DS      2
 304+ 6A49 00 00        CurrentTargetZpos       DS      2
 305+ 6A4B 00 00        CurrentTargetZsgn       DS      2
 306+ 6A4D 00 00        TargetVectorXpos        DS      2
 307+ 6A4F 00 00        TargetVectorXsgn        DS      2
 308+ 6A51 00 00        TargetVectorYpos        DS      2
 309+ 6A53 00 00        TargetVectorYsgn        DS      2
 310+ 6A55 00 00        TargetVectorZpos        DS      2
 311+ 6A57 00 00        TargetVectorZsgn        DS      2
 312+ 6A59 00           CurrentMissileBlastRange:      DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 313+ 6A5A 00           CurrentMissileBlastDamage:     DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 314+ 6A5B 00           CurrentMissileDetonateRange:   DB  0                       ; TODO Initi for runtime copied in when setting up a missile, allows for proximity missiles
 315+ 6A5C 00           CurrentMissileDetonateDamage:  DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 316+ 6A5D              ; --- Spawn Probability Table ---------------------------------------------------------------------------------------------------
 317+ 6A5D 00 00 00...  SpawnLowVssalue         DS 6                                ; Maxium of 6 entries in table
 318+ 6A63 00 00 00...  SpawnHighvalue          DS 6                                ; Maxium of 6 entries in table
 319+ 6A69 00 00 00...  ShipClassId             DS 6
 320+ 6A6F              ; --- Space dust ----------------------------------------------------------------------------------------------------------------
 321+ 6A6F 00 00 00...  varDustWarpRender       DS MaxNumberOfStars * 2 ; Copy of base positions for warp
 322+ 6A85 00 00 00...  varDust                 DS MaxNumberOfStars * 6
 323+ 6AC7 00 00 00...  varDustSceen            DS MaxNumberOfStars * 2 ; To optimise star list to wipe from screen
 324+ 6ADD 00           varStarX                DB 0
 325+ 6ADE 00           varStarY                DB 0
 326+ 6ADF 00 00 00...  varDustX                DS MaxNumberOfStars *2
 327+ 6AF5 00 00 00...  varDustY                DS MaxNumberOfStars *2
 328+ 6B0B 00 00 00...  varDustZ                DS MaxNumberOfStars *2
 329+ 6B21              ; --- Main Loop Data -------------------------------------------------------------------------------------------------------------
 330+ 6B21 00           DockedFlag				DB	0				; 8E -
 331+ 6B22 00           GamePaused              DB  0
 332+ 6B23 00           CurrentUniverseAI       DB  0               ; current ship unviverse slot due an AI update
 333+ 6B24 00           SelectedUniverseSlot    DB  0
 334+ 6B25 00           SetStationHostileFlag   DB  0               ; used to semaphore angry space station
 335+ 6B26 00           ShipBlastCheckCounter   DB  0
 336+ 6B27 00           InnerHyperCount			DB 	0				; 2F QQ22+1 (will move to a CTC timer later)
 337+ 6B28 00           OuterHyperCount			DB 	0				; 2E QQ22
 338+ 6B29 00           WarpCooldown            DB  0
 339+ 6B2A 00           EventCounter            DB  0
 340+ 6B2B 00           HyperCircle             DB  0
 341+ 6B2C 00           MissJumpFlag            DB  0
 342+ 6B2D 00           PlayerMisJump			DB	0				; $0341 witchspace misjump
 343+ 6B2E 00           HyperSpaceFX			DB	0				; 0348 HFX (probabyl BBC specific
 344+ 6B2F 00           ExtraVessels			DB	0				; 0349 EV Use d by cops, extra vessels still to spawn?
 345+ 6B30 00           Delay					DB	0				; 034A Delay general purpose eg. spawing EV or when printign messages
 346+ 6B31 00           CurrentMissileCheck:    DB  0               ; if > Universe Slot list then free for next missile
 347+ 6B32 00           MessageForDestroyed		DB	0				; 034B Message flag for item + destroyed
 348+ 6B33              UniverseSlotListSize    equ	12
 349+ 6B33 00 00 00...  UniverseSlotList        DS  UniverseSlotListSize
 350+ 6B3F 00 00 00...  UniverseSlotType        DS  UniverseSlotListSize ; base type, e.g. missile, cargo etc,
 351+ 6B4B              ; Probably not needed UniverseTypeCount       DS  UniverseSlotListSize
 352+ 6B4B 05           ConsoleRefreshCounter   DB  ConsoleRefreshInterval ; Every 4 interations the console will update twice (once for primary and once for seconday buffer)
 353+ 6B4C 00           ConsoleRedrawFlag       DB  0
 354+ 6B4D 00           TextInputMode           DB  0
 355+ 6B4E 00           CursorKeysPressed       DB  0               ; mapping of the current key presses
 356+ 6B4F                                                          ; 7    6    5    4     3    2        1    0
 357+ 6B4F                                                          ; Up   Down Left Right Home Recentre
 358+ 6B4F 00           FireLaserPressed        DB  0
 359+ 6B50 00           WarpPressed             DB  0
 360+ 6B51 00           CompassColor			DB	0				; 03C5
 361+ 6B52 00           SoundToggle				DB	0				; 03C6
 362+ 6B53 00           KeyboardRecenterToggle	DB	0				; 03C8
 363+ 6B54 00           PATGMask				DB	0				; &03C9    \ PATG	\ Mask to scan keyboard X-key, for misjump
 364+ 6B55 00           FlashToggle				DB  0				; 03CA \ FLH \ flash toggle
 365+ 6B56 00           ReverseJoystick			DB	0				; 03CB \ JSTGY \ Y reverse joystick Y channel
 366+ 6B57 00           JoystickToggle			DB	0				; 03CD  \ JSTK    \ K toggle keyboard/joystick
 367+ 6B58 00           DigitalJoystick			DB	0				; 03CE \ JDB   \ . = toggle between keyboard and bitpaddle
 368+ 6B59 00           DiskReadFailFlag		DB	0				; 03CF \ CATF \ Disk catalog fail flag
 369+ 6B5A
 370+ 6B5A              ; Working Data
 371+ 6B5A
 372+ 6B5A              ;UniverseTable			DS	26				; 1741  \ address pointers for 13 ships INF on pages &9. 37 bytes each.
 373+ 6B5A              ; $0900 =	EQUW page9+37* 0 \ copied to inner worskpace INWK on zero-page when needed
 374+ 6B5A              ; $0925 =	EQUW page9+37* 1
 375+ 6B5A              ; $094A =	EQUW page9+37* 2
 376+ 6B5A              ; $096F =	EQUW page9+37* 3
 377+ 6B5A              ; $0994 =	EQUW page9+37* 4
 378+ 6B5A              ; $09B9 =	EQUW page9+37* 5
 379+ 6B5A              ; $09DE =	EQUW page9+37* 6
 380+ 6B5A              ; $0A03 =	EQUW page9+37* 7
 381+ 6B5A              ; $0A28 =	EQUW page9+37* 8
 382+ 6B5A              ; $0A4D =	EQUW page9+37* 9
 383+ 6B5A              ; $0A72 =	EQUW page9+37*10
 384+ 6B5A              ; $0A97 =	EQUW page9+37*11
 385+ 6B5A              ; $0ABC =	EQUW page9+37*12 \ allwk up to &0ABC while heap for edges working down from &CFF.
 386+ 6B5A
 387+ 6B5A
 388+ 6B5A
 389+ 6B5A              ; 0b00 is start address of data to save
 390+ 6B5A              ; Now MissionData VarTP					DB	0				; 0358 TP? The Plan  \ mission uses lower 4 bits
 391+ 6B5A              											; Bit mask XXXX10XX - Thargoid plan mission
 392+ 6B5A
 393+ 6B5A 00           MissionData				DB	0				; &0B00	  \ look at data, first byte is TP mission bits
 394+ 6B5B
 395+ 6B5B 00 00        FileNameStringPointer	DW	0				;0C00	   \ pointer to filename string
 396+ 6B5D 00 00        CommanderLoadAddress	DW	0				;0C03
 397+ 6B5F 00 00        LengthOfFile			DW	0				;0C0B
 398+ 6B61 00 00        SaveDataEndAddress		DW	0				;&0C0F	      \ &0C00 is end address of data to save
 399+ 6B63
 400+ 6B63 00 00 00...  EdgesBuffer				DS 50
 401+ 6B95              EdgesBufferSP			equ	$				; Was $0CFF			; Heap pointer for edges buffer
 402+ 6B95              ShipLinesBufferSP		equ EdgesBufferSP	; was $0CFF
 403+ 6B95
 404+ 6B95 00 00 00...  ShipLineStack			DS  70			; For now but will be in the page later
 405+ 6BDB              ShipLineStackTop		equ $ - ShipLineStack
 406+ 6BDB
 407+ 6BDB              ; No longer needed
 408+ 6BDB              ;LSO						DS 	$C0				;0E00 Line Buffer Solar of 192 lines (may be 191 in reality)
 409+ 6BDB              ; LSX vector overlaps with LSO
 410+ 6BDB              ;LSX2					DS	$C0				; &0EC0	    \ LSX2 bline buffer size?
 411+ 6BDB              ;LSY2					DS  $C)	           	; &0F0E	    \ LSY2
 412+ 6BDB
 413+ 6BDB              ; -- Player Runtime Data
 414+ 6BDB 00           GunTemperature          DB  0
 415+ 6BDC 00           CabinTemperature        DB  0
 416+ 6BDD 00           PlayerForwardSheild0	DB	0 ; ?????
 417+ 6BDE 00           PlayerForwardSheild1    DB	0
 418+ 6BDF 00           PlayerForwardSheild2    DB	0
 419+ 6BE0 00           ForeShield				DB	0				; These three must be contiguous
 420+ 6BE1 00           AftShield				DB	0				; .
 421+ 6BE2 00           PlayerEnergy			DB	0				; and in this order
 422+ 6BE3 00           CompassX				DB	0				; 03A8
 423+ 6BE4 00           CompassY				DB	0				; 03A9
 424+ 6BE5              ; Simplification of missile targetting
 425+ 6BE5              ; $FF no missile targettting enabled
 426+ 6BE5              ; $FE missile targetting, no target selected
 427+ 6BE5              ; bit 7 set then tagetting and lower nibble holds missile target and launching
 428+ 6BE5              ; bit 7 clear launch at selected target in lower nibble
 429+ 6BE5 00           MissileTargettingFlag   DB  0
 430+ 6BE6              ;;MissileTarget			DB  0				; 45
 431+ 6BE6              ;;MissileLaunchFlag       DB  0
 432+ 6BE6 00 00 00...  CommanderName           DS  15
 433+ 6BF5 00           CommanderName0			DB	0				; Sneaky little 0 to allow use of print name directly
 434+ 6BF6 00           BadnessStatus           DB  0
 435+ 6BF7              ;note rapidly changing views could reset these so need to consider it in an array
 436+ 6BF7              ; LaserType
 437+ 6BF7              ; LaserPulseRate                          ; how many pulses can be fired before long pause
 438+ 6BF7              ; LaserPulsePause                         ; time before next pulse - 0 = beam
 439+ 6BF7              ; LaserPulseRest                          ; time before pulse count resets to 0
 440+ 6BF7              ; LaserDamageOutput                       ; amount of damage for a laser hit
 441+ 6BF7              ; LaserEnergyDrain                        ; amount of energy drained by cycle
 442+ 6BF7              ; LaserHeat                               ; amount of heat generated
 443+ 6BF7              ; LaserDurability                         ; probabability out of 255 that a hit on unshielded will add random amount of damage
 444+ 6BF7              ; LaserDurabilityAmount                   ; max amount of damagage can be sustained in one damage hit
 445+ 6BF7              ; LaserInMarkets                          ; can this laser be purchased 0 = yes 1 = no
 446+ 6BF7              ; LaserTechLevel                          ; minimum tech level system to buy from
 447+ 6BF7              ; need to add copy table routines
 448+ 6BF7 00           CurrLaserType           DB  0               ; current view laser type, copied in from LaserType array
 449+ 6BF8 00           CurrLaserDamage         DB  0               ; copied in from LaserDamagedFlag array
 450+ 6BF9 00           CurrLaserPulseRate      DB  0               ; current view laser amount of pulses
 451+ 6BFA 00           CurrLaserPulseOnTime    DB  0               ; how many cycles the laser is on
 452+ 6BFB 00           CurrLaserPulseOffTime   DB  0               ; how many cycles the laser is on
 453+ 6BFC 00           CurrLaserPulseRest      DB  0               ; current view laser delay setup between pulses
 454+ 6BFD
 455+ 6BFD                  IFDEF LASER_V2
 456+ 6BFD 00           LaserBeamOn             DB  0
 457+ 6BFE 00           CurrLaserDuration       DB  0   ; == CurrLaserPulseOnTime
 458+ 6BFF 00           CurrentBurstPause       DB  0   ; == CurrLaserPulseOffTime
 459+ 6C00 00           CurrentCooldown         DB  0   ; == CurrLaserPulseRest
 460+ 6C01                  ENDIF
 461+ 6C01 00           CurrLaserBurstRate      DB  0
 462+ 6C02 00           CurrLaserBurstCount     DB  0   ; == LaserPulseRate
 463+ 6C03 00           CurrLaserDamageOutput   DB  0
 464+ 6C04 00           CurrLaserEnergyDrain    DB  0
 465+ 6C05 00           CurrLaserHeat           DB  0
 466+ 6C06 00           CurrLaserDurability     DB  0
 467+ 6C07 00           CurrLaserDurabilityAmount DB  0
 468+ 6C08
 469+ 6C08              ; Count down timers must be aligned like this to work
 470+ 6C08 00           CurrLaserPulseOnCount   DB  0               ; how many cycles the laser is on timer
 471+ 6C09 00           CurrLaserPulseOffCount  DB  0               ; how many cycles the laser is on timer
 472+ 6C0A 00           CurrLaserPulseRestCount DB  0               ; countdown after shooting for next shot
 473+ 6C0B 00           CurrLaserPulseRateCount DB  0               ; current view laser current pulses fired
 474+ 6C0C
 475+ 6C0C              ; -- Input variables
 476+ 6C0C 00           JoystickX				DB	0				; 034C JSTX
 477+ 6C0D 00           JoystickY				DB	0				; 034D JSTY
 478+ 6C0E 00           XSAV2 					DB	0				; 034E used to temporary save 6502 X reg
 479+ 6C0F 00           YSAV2 					DB	0				; 034F used to temporary save 6502 Y reg
 480+ 6C10
 481+ 6C10              ; -- Console drawing data
 482+ 6C10              FShieldStart            equ $8410
 483+ 6C10              AShieldStart            equ $8D10
 484+ 6C10              FuelStart               equ $9410
 485+ 6C10
 486+ 6C10              EnergyBar4Start         equ $A5D5
 487+ 6C10              EnergyBar3Start         equ $ADD5
 488+ 6C10              EnergyBar2Start         equ $B5D5
 489+ 6C10              EnergyBar1Start         equ $BDD5
 490+ 6C10              ; 70 /2 = 35 values
 491+ 6C10              ;                            0                             1                             2                             3
 492+ 6C10              ;                            0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6
 493+ 6C10 01 02 02 03  FuelMapping             DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,19,20,21,21,22,23,24,25,26,27,28,30,31,31
 493+ 6C14 04 04 05 06
 493+ 6C18 06 07 08 09
 493+ 6C1C 0A 0A 0B 0C
 493+ 6C20 0D 0E 0E 0F
 493+ 6C24 10 10 11 13
 493+ 6C28 14 15 15 16
 493+ 6C2C 17 18 19 1A
 493+ 6C30 1B 1C 1E 1F
 493+ 6C34 1F
 494+ 6C35              SpeedoStart             equ $84D1
 495+ 6C35              ;                            0                             1                             2                             3                             4
 496+ 6C35              ;                            0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0
 497+ 6C35 01 02 02 03  SpeedoMapping           DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,18,19,20,20,21,22,23,24,24,25,26,26,27,28,28,29,30,31
 497+ 6C39 04 04 05 06
 497+ 6C3D 06 07 08 09
 497+ 6C41 0A 0A 0B 0C
 497+ 6C45 0D 0E 0E 0F
 497+ 6C49 10 10 11 12
 497+ 6C4D 13 14 14 15
 497+ 6C51 16 17 18 18
 497+ 6C55 19 1A 1A 1B
 497+ 6C59 1C 1C 1D 1E
 497+ 6C5D 1F
 498+ 6C5E
 499+ 6C5E              DialMiddleXPos          equ $E1
 500+ 6C5E              RollMiddle              equ $8CE0
 501+ 6C5E              PitchMiddle             equ $94E0
 502+ 6C5E
 503+ 6C5E
 504+ 6C5E
 505+ 6C5E
 506+ 6C5E
# file closed: ../../Variables/general_variables.asm
 613  6C5E                  ;NCLUDE "../../Variables/general_variablesRoutines.asm"
 614  6C5E                  INCLUDE "../../Variables/UniverseSlotRoutines.asm"
# file opened: ../../Variables/UniverseSlotRoutines.asm
   1+ 6C5E              ; Note this code is core code and can not be in a memory bank unless do explosion code is changed too
   2+ 6C5E AF           ClearSlotCount:         xor     a
   3+ 6C5F 21 33 6B                             ld      hl,UniverseSlotList
   4+ 6C62 06 0C                                ld      b, UniverseSlotListSize ; prbably not needed + UniverseSlotTypeSize
   5+ 6C64 77           .fillLoop:              ld      (hl),a
   6+ 6C65 23                                   inc     hl
   7+ 6C66 10 FC                                djnz    .fillLoop
   8+ 6C68 C9                                   ret
   9+ 6C69
  10+ 6C69              ; Initialises all types to a count of 1 where there is an occupied universe slot
  11+ 6C69              ; this needs expanding to cater for a missing type, find type and increment count (use cpir?)
  12+ 6C69              ; DOE NOT WORK CorrectSlotCount:       call    ClearSlotCount
  13+ 6C69              ; DOE NOT WORK                         ld      hl,UniverseSlotCount
  14+ 6C69              ; DOE NOT WORK                         ld      de,UniverseSlotList
  15+ 6C69              ; DOE NOT WORK                         ld      b,UniverseSlotListSize
  16+ 6C69              ; DOE NOT WORK .fillLoop:              ld      a,(de)
  17+ 6C69              ; DOE NOT WORK                         cp      $FF
  18+ 6C69              ; DOE NOT WORK                         jr      z,.SkipSlot
  19+ 6C69              ; DOE NOT WORK .CorrectSlot:           ld      (hl),a
  20+ 6C69              ; DOE NOT WORK                         inc     hl
  21+ 6C69              ; DOE NOT WORK                         ld      (hl),1
  22+ 6C69              ; DOE NOT WORK                         inc     hl
  23+ 6C69              ; DOE NOT WORK                         inc     hl
  24+ 6C69              ; DOE NOT WORK .SkipSlot               inc     de
  25+ 6C69              ; DOE NOT WORK                         djnz    .fillLoop
  26+ 6C69 C9                                   ret
  27+ 6C6A              ; Wipe all items
  28+ 6C6A 3E FF        ClearUnivSlotList:      ld      a,$FF
  29+ 6C6C 21 33 6B                             ld      hl,UniverseSlotList
  30+ 6C6F 06 18                                ld      b, UniverseSlotListSize * 2
  31+ 6C71 77           .fillLoop:              ld      (hl),a
  32+ 6C72 23                                   inc     hl
  33+ 6C73 10 FC                                djnz    .fillLoop
  34+ 6C75 C9                                   ret
  35+ 6C76
  36+ 6C76 21 33 6B     SetSlot0ToSpaceStation: ld      hl,UniverseSlotList
  37+ 6C79 36 02                                ld      (hl),ShipTypeStation
  38+ 6C7B 21 3F 6B                             ld      hl,UniverseSlotType
  39+ 6C7E 36 02                                ld      (hl),ShipTypeStation
  40+ 6C80 C9                                   ret
  41+ 6C81
  42+ 6C81 21 33 6B     SetSlotAToTypeB:        ld      hl,UniverseSlotList
  43+ 6C84 ED 31                                add     hl,a
  44+ 6C86 70                                   ld      (hl),b
  45+ 6C87 C9                                   ret
  46+ 6C88
  47+ 6C88 21 3F 6B     SetSlotAToClassB:       ld      hl,UniverseSlotType
  48+ 6C8B ED 31                                add     hl,a
  49+ 6C8D 70                                   ld      (hl),b
  50+ 6C8E C9                                   ret
  51+ 6C8F
  52+ 6C8F              ; Clears all except slot A, used when say restarting a space station post launch
  53+ 6C8F 57           ClearFreeSlotListSaveA: ld      d,a
  54+ 6C90 0E 00                                ld      c,0
  55+ 6C92 21 33 6B                             ld      hl,UniverseSlotList
  56+ 6C95 06 18                                ld      b, UniverseSlotListSize * 2
  57+ 6C97 79           .fillLoop:              ld      a,c
  58+ 6C98 BA                                   cp      d
  59+ 6C99 28 03                                jr      z,.SkipSlot
  60+ 6C9B 3E FF                                ld      a,$FF
  61+ 6C9D 77                                   ld      (hl),a
  62+ 6C9E 23           .SkipSlot:              inc     hl
  63+ 6C9F 23                                   inc     hl
  64+ 6CA0 10 F5                                djnz    .fillLoop
  65+ 6CA2 C9                                   ret
  66+ 6CA3
  67+ 6CA3 21 33 6B     ClearSlotA:             ld      hl,UniverseSlotList
  68+ 6CA6 ED 31                                add     hl,a
  69+ 6CA8 36 FF                                ld      (hl),$FF
  70+ 6CAA 3E 0C                                ld      a,UniverseSlotListSize  ; move to types
  71+ 6CAC ED 31                                add     hl,a
  72+ 6CAE 36 FF                                ld      (hl),$FF
  73+ 6CB0 C9                                   ret
  74+ 6CB1
  75+ 6CB1              ; Space Station will always be slot 0
  76+ 6CB1 21 40 6B     ClearJunk:              ld      hl,UniverseSlotType+1
  77+ 6CB4 0E 01                                ld      c,1
  78+ 6CB6 06 0B                                ld      b,UniverseSlotListSize -1      ; ignore space station
  79+ 6CB8 7E           .NextShip:              ld      a,(hl)
  80+ 6CB9 FE 03                                cp      ShipTypeJunk
  81+ 6CBB CA CC 6C                             jp      z,.ProcessJunk
  82+ 6CBE FE 04                                cp      ShipTypeScoopable
  83+ 6CC0 CA CC 6C                             jp      z,.ProcessJunk
  84+ 6CC3 23           .DoneIteration:         inc     hl
  85+ 6CC4 0C                                   inc     c
  86+ 6CC5 10 F1                                djnz    .NextShip
  87+ 6CC7                                      ClearJunkCount
  87+ 6CC7             >                        ZeroA
  87+ 6CC7 AF          >                        xor a
  87+ 6CC8 32 09 6A    >                        ld      (JunkCount),a
  88+ 6CCB C9                                   ret
  89+ 6CCC 79           .ProcessJunk:           ld      a,c
  90+ 6CCD CD A3 6C                             call    ClearSlotA
  91+ 6CD0 C3 C3 6C                             jp      .DoneIteration
  92+ 6CD3
  93+ 6CD3
  94+ 6CD3 21 40 6B     WarpJunk:               ld      hl,UniverseSlotType+1
  95+ 6CD6 0E 01                                ld      c,1
  96+ 6CD8 06 0B                                ld      b,UniverseSlotListSize -1      ; ignore space station
  97+ 6CDA 7E           .NextShip:              ld      a,(hl)
  98+ 6CDB FE 03                                cp      ShipTypeJunk
  99+ 6CDD CA EA 6C                             jp      z,.ProcessJunk
 100+ 6CE0 FE 04                                cp      ShipTypeScoopable
 101+ 6CE2 CA EA 6C                             jp      z,.ProcessJunk
 102+ 6CE5 23           .DoneIteration:         inc     hl
 103+ 6CE6 0C                                   inc     c
 104+ 6CE7 10 F1                                djnz    .NextShip
 105+ 6CE9 C9                                   ret
 106+ 6CEA 79           .ProcessJunk:           ld      a,c
 107+ 6CEB                                      MMUSelectUniverseA
 107+ 6CEB C6 46       >                     add    a,BankUNIVDATA0
 107+ 6CED ED 92 56    >                     nextreg UniverseMMU,       a
 108+ 6CF0 CD 42 C6                             call    WarpOffset
 109+ 6CF3 C3 E5 6C                             jp      .DoneIteration
 110+ 6CF6
 111+ 6CF6 21 40 6B     AreShipsPresent:        ld      hl,UniverseSlotType+1
 112+ 6CF9 06 0B                                ld      b,UniverseSlotListSize -1      ; ignore space station
 113+ 6CFB 7E           .NextShip:              ld      a,(hl)
 114+ 6CFC FE 00                                cp      ShipTypeNormal
 115+ 6CFE                                      ClearCarryFlag
 115+ 6CFE B7          >                        or a
 116+ 6CFF C8                                   ret     z
 117+ 6D00 23                                   inc     hl
 118+ 6D01 10 F8                                djnz    .NextShip
 119+ 6D03                                      SetCarryFlag
 119+ 6D03 37          >                        scf
 120+ 6D04 C9                                   ret
 121+ 6D05
 122+ 6D05 21 33 6B     IsSpaceStationPresent:  ld      hl,UniverseSlotList
 123+ 6D08                                      ClearCarryFlag
 123+ 6D08 B7          >                        or a
 124+ 6D09 7E           .SearchLoop:            ld      a,(hl)
 125+ 6D0A                                      ReturnIfAEqNusng ShipTypeStation
 125+ 6D0A FE 02       >                        cp      ShipTypeStation
 125+ 6D0C C8          >                        ret     z
 126+ 6D0D                                      SetCarryFlag
 126+ 6D0D 37          >                        scf
 127+ 6D0E C9                                   ret
 128+ 6D0F
 129+ 6D0F 21 33 6B     GetTypeAtSlotA:         ld      hl,UniverseSlotList
 130+ 6D12 ED 31                                add     hl,a
 131+ 6D14 7E                                   ld      a,(hl)
 132+ 6D15 C9                                   ret
 133+ 6D16
 134+ 6D16 21 34 6B     IsPlanetOrSpaceStation: ld      hl,UniverseSlotList+1
 135+ 6D19 7E                                   ld      a,(hl)
 136+ 6D1A C9                                   ret
 137+ 6D1B
 138+ 6D1B 21 33 6B     FindNextFreeSlotInC:    ld      hl,UniverseSlotList
 139+ 6D1E 06 0C                                ld      b, UniverseSlotListSize
 140+ 6D20 0E 00                                ld      c, 0
 141+ 6D22 7E           .SearchLoop:            ld      a,(hl)
 142+ 6D23                                      JumpIfAEqNusng $FF, .FoundSlot
 142+ 6D23 FE FF       >                        cp     $FF
 142+ 6D25 CA 2E 6D    >                        jp      z,.FoundSlot
 143+ 6D28 0C                                   inc     c
 144+ 6D29 23                                   inc     hl
 145+ 6D2A 10 F6                                djnz    .SearchLoop
 146+ 6D2C                                      SetCarryFlag
 146+ 6D2C 37          >                        scf
 147+ 6D2D C9                                   ret
 148+ 6D2E              .FoundSlot:             ClearCarryFlag
 148+ 6D2E B7          >                        or a
 149+ 6D2F C9                                   ret
 150+ 6D30
 151+ 6D30
 152+ 6D30 CD 1B 6D     FindNextFreeSlotInA:    call    FindNextFreeSlotInC
 153+ 6D33 79                                   ld      a,c
 154+ 6D34 C9                                   ret
 155+ 6D35
# file closed: ../../Variables/UniverseSlotRoutines.asm
 615  6D35                  ;NCLUDE "../../Variables/EquipmentVariables.asm"
 616  6D35                  INCLUDE "../../Variables/random_number.asm"
# file opened: ../../Variables/random_number.asm
   1+ 6D35              doRandom2:									; .DORND2	\ -> &3F85 \ Restricted for explosion dust.
   2+ 6D35              doRND2:
   3+ 6D35 A7           	and		a								; fast clear carry  leave bit0 of RAND+2 at 0.
   4+ 6D36              doRandom:									;.DORND	\ -> &3F86 \ do random, new A, X.
   5+ 6D36              ; "doRandom, Random Seed update, new value in A & C)"
   6+ 6D36              ; uses a c h l registers
   7+ 6D36              doRND:                  ;exx                                     ; protect bc,de,hl
   8+ 6D36 3A 54 68                             ld		a,(RandomSeed)					; Get Seed 0
   9+ 6D39 CB 17                                rl		a								; Rotate L including carry
  10+ 6D3B 4F                                   ld		c,a								; c =  double lo
  11+ 6D3C 21 56 68     .AddSeed2:              ld		hl,RandomSeed2
  12+ 6D3F 8E                                   adc		a,(hl)							; RAND+2
  13+ 6D40 32 54 68     .SaveAtoSeed:           ld		(RandomSeed),a					; and save RAND
  14+ 6D43 08           .SaveBtoSeed2:          ex		af,af'
  15+ 6D44 79                                   ld		a,c
  16+ 6D45 32 56 68                             ld		(RandomSeed2),a
  17+ 6D48 08                                   ex		af,af'
  18+ 6D49 3A 55 68                             ld		a,(RandomSeed1)
  19+ 6D4C 4F                                   ld		c,a								; C = Seed1
  20+ 6D4D 21 57 68     .AddSeed3:              ld		hl,RandomSeed3
  21+ 6D50 8E                                   adc		a,(hl)
  22+ 6D51 32 55 68                             ld		(RandomSeed1),a
  23+ 6D54 08                                   ex		af,af'
  24+ 6D55 79                                   ld		a,c
  25+ 6D56 32 57 68                             ld		(RandomSeed3),a
  26+ 6D59 08                                   ex		af,af'
  27+ 6D5A                                      ;exx                                     ; get bc,de,hl back
  28+ 6D5A C9                                   ret
  29+ 6D5B
  30+ 6D5B 21 54 68     saveRandomSeeds:        ld      hl,RandomSeed
  31+ 6D5E 11 58 68                             ld      de,RandomSeedSave
  32+ 6D61 01 04 00                             ld      bc,4
  33+ 6D64 ED A0                                ldi
  34+ 6D66 ED A0                                ldi
  35+ 6D68 ED A0                                ldi
  36+ 6D6A ED A0                                ldi
  37+ 6D6C C9                                   ret
  38+ 6D6D
  39+ 6D6D 21 58 68     restoreRandomSeeds:     ld      hl,RandomSeedSave
  40+ 6D70 11 54 68                             ld      de,RandomSeed
  41+ 6D73 01 04 00                             ld      bc,4
  42+ 6D76 ED A0                                ldi
  43+ 6D78 ED A0                                ldi
  44+ 6D7A ED A0                                ldi
  45+ 6D7C ED A0                                ldi
  46+ 6D7E C9                                   ret
# file closed: ../../Variables/random_number.asm
 617  6D7F              ;INCLUDE "Tables/inwk_table.asm" This is no longer needed as we will write to univer object bank
 618  6D7F              ; Include all maths libraries to test assembly
 619  6D7F                  ;INCLUDE "../../Maths/asm_add.asm"
 620  6D7F                  ;INCLUDE "../../Maths/asm_subtract.asm"
 621  6D7F                  ;NCLUDE "../../Maths/DIVD3B2.asm"
 622  6D7F                  INCLUDE "../../Maths/multiply.asm"
# file opened: ../../Maths/multiply.asm
   1+ 6D7F              HLequSRmulQdiv256:      ;X.Y=x1lo.S*M/256  	\ where M/256 is gradient
   2+ 6D7F 2A 60 69                             ld  hl,(varRS)
   3+ 6D82 3A 5F 69                             ld  a,(varQ)
   4+ 6D85 C5 D5        HLeqyHLmulAdiv256:      push    bc,,de
   5+ 6D87 11 00 00                             ld  de,0        ; de = XY
   6+ 6D8A 47                                   ld  b,a         ; b = Q
   7+ 6D8B                                      ShiftHLRight1
   7+ 6D8B CB 3C       >			   srl h
   7+ 6D8D CB 1D       >			   rr  l
   8+ 6D8F CB 20                                sla b
   9+ 6D91 30 03                                jr  nc,.LL126
  10+ 6D93 EB           .LL125:                 ex de,hl
  11+ 6D94 19                                   add hl,de
  12+ 6D95 EB                                   ex  de,hl       ; de = de + rs
  13+ 6D96              .LL126:                 ShiftHLRight1
  13+ 6D96 CB 3C       >			   srl h
  13+ 6D98 CB 1D       >			   rr  l
  14+ 6D9A CB 20                                sla b
  15+ 6D9C 38 F5                                jr      c,.LL125
  16+ 6D9E 20 F6                                jr      nz,.LL126
  17+ 6DA0 EB                                   ex      de,hl   ; hl = result
  18+ 6DA1 D1 C1                                pop     bc,,de
  19+ 6DA3 C9                                   ret
  20+ 6DA4
  21+ 6DA4              ; FMLTU - A = A * Q / 256
  22+ 6DA4 57           AequAmulQdiv256usgn:    ld      d,a
  23+ 6DA5 3A 5F 69                             ld      a,(varQ)
  24+ 6DA8 5F                                   ld      e,a
  25+ 6DA9              asm_defmutl:
  26+ 6DA9              ; "ASM_FMUTKL .FMLTU	\ -> &2847  \ A=D*E/256unsg  Fast multiply"
  27+ 6DA9 ED 30        AequDmulEdiv256usgn:    mul     de
  28+ 6DAB 7A                                   ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
  29+ 6DAC C9                                   ret
  30+ 6DAD
  31+ 6DAD
  32+ 6DAD              ; muliptiply S7d ny S7e signed
  33+ 6DAD              ; used A and B registers
  34+ 6DAD              ; result in DE
  35+ 6DAD 7A           mulDbyESigned:          ld      a,d
  36+ 6DAE AB                                   xor     e
  37+ 6DAF E6 80                                and     SignOnly8Bit
  38+ 6DB1 47                                   ld      b,a
  39+ 6DB2 7A                                   ld      a,d
  40+ 6DB3 E6 7F                                and     SignMask8Bit
  41+ 6DB5 57                                   ld      d,a
  42+ 6DB6 7B                                   ld      a,e
  43+ 6DB7 E6 7F                                and     SignMask8Bit
  44+ 6DB9 5F                                   ld      e,a
  45+ 6DBA ED 30                                mul     de
  46+ 6DBC 7A                                   ld      a,d
  47+ 6DBD B0                                   or      b
  48+ 6DBE 57                                   ld      d,a
  49+ 6DBF C9                                   ret
  50+ 6DC0
  51+ 6DC0
  52+ 6DC0
  53+ 6DC0              MacroDEEquQmulASigned:  MACRO
  54+ 6DC0 ~                                    ld      d,a                         ; save a into d
  55+ 6DC0 ~                                    ld      a,(varQ)
  56+ 6DC0 ~                                    ld      e,a
  57+ 6DC0 ~                                    xor     d                           ; a = a xor var Q
  58+ 6DC0 ~                                    and     SignOnly8Bit
  59+ 6DC0 ~                                    ld      b,a                         ; b = sign of a xor q
  60+ 6DC0 ~                                    ld      a,d                         ; d = abs d (or a reg)
  61+ 6DC0 ~                                    and     SignMask8Bit
  62+ 6DC0 ~                                    ld      d,a
  63+ 6DC0 ~                                    ld      a,e                         ; e = abs e (or varQ)
  64+ 6DC0 ~                                    and     SignMask8Bit
  65+ 6DC0 ~                                    ld      e,a
  66+ 6DC0 ~                                    mul                                 ; de = a * Q
  67+ 6DC0 ~                                    ld      a,d
  68+ 6DC0 ~                                    or      b                           ; de = a * Q leading sign bit
  69+ 6DC0 ~                                    ld      d,a
  70+ 6DC0                                      ENDM
  71+ 6DC0
  72+ 6DC0
  73+ 6DC0
  74+ 6DC0                                 ; .MAD	\ -> &22AD  \ Multiply and Add  (DE also) X.A(Lo.Hi) = Q*A + R.S (Lo.Hi)
  75+ 6DC0              madXAequQmulAaddRS:     MacroDEEquQmulASigned
  75+ 6DC0 57          >                        ld      d,a                         ; save a into d
  75+ 6DC1 3A 5F 69    >                        ld      a,(varQ)
  75+ 6DC4 5F          >                        ld      e,a
  75+ 6DC5 AA          >                        xor     d                           ; a = a xor var Q
  75+ 6DC6 E6 80       >                        and     SignOnly8Bit
  75+ 6DC8 47          >                        ld      b,a                         ; b = sign of a xor q
  75+ 6DC9 7A          >                        ld      a,d                         ; d = abs d (or a reg)
  75+ 6DCA E6 7F       >                        and     SignMask8Bit
  75+ 6DCC 57          >                        ld      d,a
  75+ 6DCD 7B          >                        ld      a,e                         ; e = abs e (or varQ)
  75+ 6DCE E6 7F       >                        and     SignMask8Bit
  75+ 6DD0 5F          >                        ld      e,a
  75+ 6DD1 ED 30       >                        mul                                 ; de = a * Q
  75+ 6DD3 7A          >                        ld      a,d
  75+ 6DD4 B0          >                        or      b                           ; de = a * Q leading sign bit
  75+ 6DD5 57          >                        ld      d,a
  76+ 6DD6 2A 60 69                             ld		hl,(varR)
  77+ 6DD9 CD 01 6E                             call	madXAAddHLDESigned
  78+ 6DDC EB                                   ex      de,hl                       ; de = R.S + DE
  79+ 6DDD                                      ClearCarryFlag
  79+ 6DDD B7          >                        or a
  80+ 6DDE DD 6B                                ld      ixl,e
  81+ 6DE0 7A                                   ld      a,d
  82+ 6DE1 C9                                   ret
  83+ 6DE2
  84+ 6DE2              madDEequQmulAaddRS:     MacroDEEquQmulASigned
  84+ 6DE2 57          >                        ld      d,a                         ; save a into d
  84+ 6DE3 3A 5F 69    >                        ld      a,(varQ)
  84+ 6DE6 5F          >                        ld      e,a
  84+ 6DE7 AA          >                        xor     d                           ; a = a xor var Q
  84+ 6DE8 E6 80       >                        and     SignOnly8Bit
  84+ 6DEA 47          >                        ld      b,a                         ; b = sign of a xor q
  84+ 6DEB 7A          >                        ld      a,d                         ; d = abs d (or a reg)
  84+ 6DEC E6 7F       >                        and     SignMask8Bit
  84+ 6DEE 57          >                        ld      d,a
  84+ 6DEF 7B          >                        ld      a,e                         ; e = abs e (or varQ)
  84+ 6DF0 E6 7F       >                        and     SignMask8Bit
  84+ 6DF2 5F          >                        ld      e,a
  84+ 6DF3 ED 30       >                        mul                                 ; de = a * Q
  84+ 6DF5 7A          >                        ld      a,d
  84+ 6DF6 B0          >                        or      b                           ; de = a * Q leading sign bit
  84+ 6DF7 57          >                        ld      d,a
  85+ 6DF8 2A 60 69                             ld		hl,(varR)
  86+ 6DFB CD 01 6E                             call	madXAAddHLDESigned
  87+ 6DFE EB                                   ex      de,hl                       ; de = R.S + DE
  88+ 6DFF                                      ClearCarryFlag
  88+ 6DFF B7          >                        or a
  89+ 6E00 C9                                   ret
  90+ 6E01
  91+ 6E01 7C           madXAAddHLDESigned:     ld      a,h
  92+ 6E02 E6 80                                and     SignOnly8Bit
  93+ 6E04 47                                   ld      b,a                         ;save sign bit in b
  94+ 6E05 AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
  95+ 6E06                                      JumpIfNegative .ADDHLDEOppSGN        ;Signs are opposite there fore we can subtract to get difference
  95+ 6E06 FA 1E 6E    >                        jp		m, .ADDHLDEOppSGN
  96+ 6E09 78           .ADDHLDESameSigns:       ld      a,b
  97+ 6E0A B2                                   or      d
  98+ 6E0B                                      JumpIfNegative .ADDHLDESameNeg       ; optimisation so we can just do simple add if both positive
  98+ 6E0B FA 10 6E    >                        jp		m, .ADDHLDESameNeg
  99+ 6E0E 19                                   add     hl,de
 100+ 6E0F C9                                   ret
 101+ 6E10 7C           .ADDHLDESameNeg:         ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 102+ 6E11 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 103+ 6E13 67                                   ld      h,a
 104+ 6E14 7A                                   ld      a,d
 105+ 6E15 E6 7F                                and     SignMask8Bit
 106+ 6E17 57                                   ld      d,a
 107+ 6E18 19                                   add     hl,de
 108+ 6E19 3E 80                                ld      a,SignOnly8Bit
 109+ 6E1B B4                                   or      h                           ; now set bit for negative value, we won't bother with overflow for now TODO
 110+ 6E1C 67                                   ld      h,a
 111+ 6E1D C9                                   ret
 112+ 6E1E 7C           .ADDHLDEOppSGN:          ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit                     ; here HL and DE are opposite
 113+ 6E1F E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 114+ 6E21 67                                   ld      h,a
 115+ 6E22 7A                                   ld      a,d
 116+ 6E23 E6 7F                                and     SignMask8Bit
 117+ 6E25 57                                   ld      d,a
 118+ 6E26 B7                                   or      a
 119+ 6E27 ED 52                                sbc     hl,de
 120+ 6E29 38 04                                jr      c,.ADDHLDEOppInvert
 121+ 6E2B 78           .ADDHLDEOppSGNNoCarry:   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
 122+ 6E2C B4                                   or      h
 123+ 6E2D 67                                   ld      h,a                         ; set the previou sign value
 124+ 6E2E C9                                   ret
 125+ 6E2F              .ADDHLDEOppInvert:       NegHL                                                   ; we need to flip the sign and 2'c the Hl result
 125+ 6E2F AF          >                    xor a
 125+ 6E30 95          >                    sub l
 125+ 6E31 6F          >                    ld l,a
 125+ 6E32 9F          >                    sbc a,a
 125+ 6E33 94          >                    sub h
 125+ 6E34 67          >                    ld h,a
 126+ 6E35 78                                   ld      a,b
 127+ 6E36 EE 80                                xor     SignOnly8Bit                ; flip sign bit
 128+ 6E38 B4                                   or      h
 129+ 6E39 67                                   ld      h,a                         ; recover sign
 130+ 6E3A C9                                   ret
 131+ 6E3B
 132+ 6E3B
 133+ 6E3B                  ; multiplication of 16-bit number and 8-bit number into a 24-bit product
 134+ 6E3B                  ;
 135+ 6E3B                  ; enter : hl = 16-bit multiplier   = x
 136+ 6E3B                  ;          e =  8-bit multiplicand = y
 137+ 6E3B                  ;
 138+ 6E3B                  ; exit  : ahl = 24-bit product
 139+ 6E3B                  ;         carry reset
 140+ 6E3B                  ;
 141+ 6E3B                  ; uses  : af, de, hl
 142+ 6E3B 54           AHLequHLmulE:           ld d,h                      ; xh
 143+ 6E3C 63                                   ld h,e                      ; yl
 144+ 6E3D ED 30                                mul de                      ; xh*yl
 145+ 6E3F EB                                   ex de,hl
 146+ 6E40 ED 30                                mul de                      ; yl*xl, hl = xh*yl
 147+ 6E42
 148+ 6E42 7A                                   ld  a,d                     ; sum products
 149+ 6E43 85                                   add a,l
 150+ 6E44 57                                   ld  d,a
 151+ 6E45 EB                                   ex de,hl
 152+ 6E46
 153+ 6E46 7A                                   ld  a,d
 154+ 6E47 CE 00                                adc a,0
 155+ 6E49 C9                                   ret
 156+ 6E4A
 157+ 6E4A 54           HLE0quH0mulE:           ld      d,h                 ; .
 158+ 6E4B 63                                   ld      h,e                 ; .
 159+ 6E4C ED 30                                mul     de                  ; de = xh * yl
 160+ 6E4E EB                                   ex      de,hl
 161+ 6E4F C9                                   ret
 162+ 6E50
 163+ 6E50                 ; multiplication of two 16-bit numbers into a 32-bit product
 164+ 6E50                 ;
 165+ 6E50                 ; enter : de = 16-bit multiplicand = y
 166+ 6E50                 ;         hl = 16-bit multiplicand = x
 167+ 6E50                 ;
 168+ 6E50                 ; exit  : dehl = 32-bit product
 169+ 6E50                 ;         carry reset
 170+ 6E50                 ;
 171+ 6E50                 ; uses  : af, bc, de, hl
 172+ 6E50
 173+ 6E50
 174+ 6E50
 175+ 6E50 45           DEHLequDEmulHL:         ld b,l                      ; x0
 176+ 6E51 4B                                   ld c,e                      ; y0
 177+ 6E52 5D                                   ld e,l                      ; x0
 178+ 6E53 6A                                   ld l,d
 179+ 6E54 E5                                   push hl                     ; x1 y1
 180+ 6E55 69                                   ld l,c                      ; y0
 181+ 6E56              ; bc = x0 y0, de = y1 x0,  hl = x1 y0,  stack = x1 y1
 182+ 6E56 ED 30                                mul de                      ; y1*x0
 183+ 6E58 EB                                   ex de,hl
 184+ 6E59 ED 30                                mul de                      ; x1*y0
 185+ 6E5B
 186+ 6E5B AF                                   xor a                       ; zero A
 187+ 6E5C 19                                   add hl,de                   ; sum cross products p2 p1
 188+ 6E5D 8F                                   adc a,a                     ; capture carry p3
 189+ 6E5E
 190+ 6E5E 59                                   ld e,c                      ; x0
 191+ 6E5F 50                                   ld d,b                      ; y0
 192+ 6E60 ED 30                                mul de                      ; y0*x0
 193+ 6E62
 194+ 6E62 47                                   ld b,a                      ; carry from cross products
 195+ 6E63 4C                                   ld c,h                      ; LSB of MSW from cross products
 196+ 6E64
 197+ 6E64 7A                                   ld a,d
 198+ 6E65 85                                   add a,l
 199+ 6E66 67                                   ld h,a
 200+ 6E67 6B                                   ld l,e                      ; LSW in HL p1 p0
 201+ 6E68
 202+ 6E68 D1                                   pop de
 203+ 6E69 ED 30                                mul de                      ; x1*y1
 204+ 6E6B
 205+ 6E6B EB                                   ex de,hl
 206+ 6E6C ED 4A                                adc hl,bc
 207+ 6E6E EB                                   ex de,hl                    ; de = final MSW
 208+ 6E6F
 209+ 6E6F C9                                   ret
 210+ 6E70
 211+ 6E70              ; multiplication of two 16-bit numbers into a 16-bit product
 212+ 6E70              ; enter : de = 16-bit multiplicand
 213+ 6E70              ;         hl = 16-bit multiplicand
 214+ 6E70              ; exit  : hl = 16-bit product
 215+ 6E70              ;         carry reset
 216+ 6E70              ; maths is
 217+ 6E70              ;        hl = y , de= x
 218+ 6E70              ;        hl = xhi,ylo + (yhigh * xlow)
 219+ 6E70              ;        hl = yhih & xlo + x
 220+ 6E70              ;
 221+ 6E70              ;
 222+ 6E70              ; uses  : af, bc, de, hl
 223+ 6E70 C5           mulDEbyHL:              push    bc
 224+ 6E71 7A                                   ld a,d                      ; a = xh
 225+ 6E72 54                                   ld d,h                      ; d = yh
 226+ 6E73 67                                   ld h,a                      ; h = xh
 227+ 6E74 4B                                   ld c,e                      ; c = xl
 228+ 6E75 45                                   ld b,l                      ; b = yl
 229+ 6E76 ED 30                                mul                         ; yh * yl
 230+ 6E78 EB                                   ex de,hl
 231+ 6E79 ED 30                                mul                         ; xh * yl
 232+ 6E7B 19                                   add hl,de                   ; add cross products
 233+ 6E7C 59                                   ld e,c
 234+ 6E7D 50                                   ld d,b
 235+ 6E7E ED 30                                mul                         ; yl * xl
 236+ 6E80 7D                                   ld a,l                      ; cross products lsb
 237+ 6E81 82                                   add a,d                     ; add to msb final
 238+ 6E82 67                                   ld h,a
 239+ 6E83 6B                                   ld l,e                      ; hl = final
 240+ 6E84                                      ; 83 cycles, 19 bytes
 241+ 6E84 AF                                   xor a                       ; reset carry
 242+ 6E85 C1                                   pop     bc
 243+ 6E86 C9                                   ret
 244+ 6E87
 245+ 6E87              ; multiplication of 16-bit numbers by 8-bit product
 246+ 6E87              ; enter : de = 16-bit multiplicand
 247+ 6E87              ;          l = 8-bit multiplicand
 248+ 6E87              ; exit  : hl = 16-bit product
 249+ 6E87              ;         carry reset
 250+ 6E87              ; maths is
 251+ 6E87              ;        hl = y , de= x
 252+ 6E87              ;        hl = xhi,ylo + (yhigh * xlow)
 253+ 6E87              ;        hl = yhih & xlo + x
 254+ 6E87              ;
 255+ 6E87              ;
 256+ 6E87              ; uses  : af, bc, de, hl
 257+ 6E87 C5 E5 D5     mulDEbyLSigned:         push    bc,,hl,,de
 258+ 6E8A 7A                                   ld a,d                      ; a = xh
 259+ 6E8B 16 00                                ld d,0                      ; d = yh = 0
 260+ 6E8D 67                                   ld h,a                      ; h = xh
 261+ 6E8E 4B                                   ld c,e                      ; c = xl
 262+ 6E8F 45                                   ld b,l                      ; b = yl
 263+ 6E90              ;                        mul                         ; yh * xl which will always be 0
 264+ 6E90 EB                                   ex de,hl                    ; de = xh yl
 265+ 6E91 ED 30                                mul                         ; xh * yl
 266+ 6E93 EB                                   ex de,hl                    ; hl = xh * yl
 267+ 6E94              ;                        add hl,de                   ; add cross products
 268+ 6E94 59                                   ld e,c                      ; de = yl xl
 269+ 6E95 50                                   ld d,b                      ; .
 270+ 6E96 ED 30                                mul                         ; yl * xl
 271+ 6E98 7D                                   ld a,l                      ; cross products lsb
 272+ 6E99 82                                   add a,d                     ; add to msb final
 273+ 6E9A 67                                   ld h,a
 274+ 6E9B 6B                                   ld l,e                      ; hl = final
 275+ 6E9C AF                                   xor a                       ; reset carry
 276+ 6E9D C1                                   pop     bc                  ; get de for sign
 277+ 6E9E 78                                   ld      a,b
 278+ 6E9F C1                                   pop     bc                  ; get hl for sign
 279+ 6EA0 A8                                   xor     b
 280+ 6EA1 E6 80                                and     $80                 ; so we now have the sign bit
 281+ 6EA3 B4                                   or      h                   ; so set the sign
 282+ 6EA4 67                                   ld      h,a                 ; .
 283+ 6EA5 C1                                   pop     bc                  ; clear up stack
 284+ 6EA6 C9                                   ret
 285+ 6EA7
 286+ 6EA7                  DISPLAY "TODO: TEST"
 287+ 6EA7 7A           mulDEbyHLSigned:        ld  a,d                     ; de = abs de
 288+ 6EA8 47                                   ld  b,a                     ;
 289+ 6EA9 E6 7F                                and     $7F                 ; .
 290+ 6EAB 57                                   ld  d,a                     ; .
 291+ 6EAC 7C                                   ld  a,h                     ; hl = abs hl
 292+ 6EAD 4F                                   ld  c,a                     ; .
 293+ 6EAE E6 7F                                and     $7F                 ; .
 294+ 6EB0 67                                   ld      h,a                 ; .
 295+ 6EB1 79                                   ld      a,c                 ; ixl = target sign of de * hl
 296+ 6EB2 AA                                   xor     d                   ;
 297+ 6EB3 E6 80                                and     $80                 ;
 298+ 6EB5 DD 6F                                ld      ixl,a               ;
 299+ 6EB7 CD 70 6E                             call    mulDEbyHL           ; calculate ABS(DE) * ABS(HL)
 300+ 6EBA 7C                                   ld      a,h                 ; recover sign bit
 301+ 6EBB DD B5                                or      ixl
 302+ 6EBD 67                                   ld      h,a
 303+ 6EBE C9                                   ret
 304+ 6EBF
 305+ 6EBF              ; CHL = multiplicand D = multiplier
 306+ 6EBF              ; DCHL = CHL * D
 307+ 6EBF 7A           mulCHLbyDSigned:        ld      a,d                 ; get sign from d
 308+ 6EC0 AC                                   xor     h                   ; xor with h to get resultant sign
 309+ 6EC1 E6 80                                and     SignOnly8Bit        ; .
 310+ 6EC3 FD 67                                ld      iyh,a               ; iyh = copy of sign
 311+ 6EC5 79                                   ld      a,c                 ; now CHL = ABS (CHL)
 312+ 6EC6 E6 7F                                and     SignMask8Bit        ; .
 313+ 6EC8 4F                                   ld      c,a                 ; .
 314+ 6EC9 7A                                   ld      a,d                 ; d = ABS D
 315+ 6ECA E6 7F                                and     SignMask8Bit        ; .
 316+ 6ECC              ; At this point CHL = ABS (HLE), A = ABS(D)
 317+ 6ECC 57           .mul1:                  ld      d,a                 ; first do D * L
 318+ 6ECD 5D                                   ld      e,l                 ; .
 319+ 6ECE ED 30                                mul     de                  ; DE = L * D
 320+ 6ED0 08                                   ex      af,af'              ; save multiplier
 321+ 6ED1 6B                                   ld      l,e                 ; L = p0
 322+ 6ED2 7A                                   ld      a,d                 ; carry byte
 323+ 6ED3 08                                   ex      af,af'              ; retrieve muliplier and save carry byte along with flags
 324+ 6ED4 5C           .mul2:                  ld      e,h                 ; byte 2 of multiplicand
 325+ 6ED5 57                                   ld      d,a                 ; and multiplier
 326+ 6ED6 ED 30                                mul     de                  ; now its D & L
 327+ 6ED8 08                                   ex      af,af'              ; get back carry byte with flags
 328+ 6ED9 83           .carrybyte1:            add     a,e                 ; add low byte carry to result and retain carry too through next instructions
 329+ 6EDA 67                                   ld      h,a                 ; h = P1
 330+ 6EDB 7A                                   ld      a,d                 ; a = carry byte
 331+ 6EDC 08                                   ex      af,af'              ; save carry byte and get back multiplier with flags
 332+ 6EDD 59           .mul3:                  ld      e,c                 ; byte 3 of multiplicand
 333+ 6EDE 57                                   ld      d,a                 ;
 334+ 6EDF ED 30                                mul     de                  ;
 335+ 6EE1 08                                   ex      af,af'              ; get back carry byte and carry prior to first add
 336+ 6EE2 8B                                   adc     a,e                 ;
 337+ 6EE3 FD B4                                or      iyh                 ; recover saved resultant sign
 338+ 6EE5 4F                                   ld      c,a                 ; c byte 3. Note the value range allowed can never cause a byte 3 carry
 339+ 6EE6 C9                                   ret
 340+ 6EE7
 341+ 6EE7              ;  CHL = 53456 D = 1E
 342+ 6EE7              ;  56 * 1E = A14 L = 14 carry = 0A
 343+ 6EE7              ;  34 * 1E = 618 H = 18 +A = 22 carry = 6
 344+ 6EE7              ;  5  * 1E = 096 C = 96 + 6 = 9C
 345+ 6EE7              ;  CHL = 9C2214
 346+ 6EE7              ;mult3
 347+ 6EE7              ; DELC = HLE * D, uses HL, DE, C , A , IYH
 348+ 6EE7              ; HLE = multiplicand D = multiplier
 349+ 6EE7              ; tested by mathstestsun.asm all passed
 350+ 6EE7              ; Algorithm
 351+ 6EE7              ; AC =  E * D   (save carry)         H    L    E
 352+ 6EE7              ; DE =  L * D                                  D
 353+ 6EE7              ;  L =  A + E + carry                         E*D (lo)
 354+ 6EE7              ; DE =  H * D                             L*D+ ^ (hi)
 355+ 6EE7              ;  E =  A + E + carry                H*D (lo) + carry
 356+ 6EE7              ;
 357+ 6EE7              ;
 358+ 6EE7 7A           mulHLbyDE2sc:           ld      a,d
 359+ 6EE8 AC                                   xor     h
 360+ 6EE9 E6 80                                and     SignOnly8Bit
 361+ 6EEB FD 67                                ld      iyh,a               ; save sign bit for result
 362+ 6EED 7C                                   ld      a,h
 363+ 6EEE E6 80                                and     SignOnly8Bit
 364+ 6EF0 28 06                                jr      z,.HLPositive
 365+ 6EF2              .HLNegative:            NegHL
 365+ 6EF2 AF          >                    xor a
 365+ 6EF3 95          >                    sub l
 365+ 6EF4 6F          >                    ld l,a
 365+ 6EF5 9F          >                    sbc a,a
 365+ 6EF6 94          >                    sub h
 365+ 6EF7 67          >                    ld h,a
 366+ 6EF8 7A           .HLPositive:            ld      a,d
 367+ 6EF9 E6 80                                and     SignOnly8Bit
 368+ 6EFB 28 06                                jr      z,.DEPositive
 369+ 6EFD              .DENegative:            NegDE
 369+ 6EFD AF          >                    xor a
 369+ 6EFE 93          >                    sub e
 369+ 6EFF 5F          >                    ld e,a
 369+ 6F00 9F          >                    sbc a,a
 369+ 6F01 92          >                    sub d
 369+ 6F02 57          >                    ld d,a
 370+ 6F03 CD 70 6E     .DEPositive:            call    mulDEbyHL           ; now do calc
 371+ 6F06 FD 7C                                ld      a,iyh
 372+ 6F08 A7                                   and     a                   ; if its 0 then we are good
 373+ 6F09 C8                                   ret     z
 374+ 6F0A
 375+ 6F0A
 376+ 6F0A              ; Mulitply HLE by D leading Sign
 377+ 6F0A              ; used IY A BC
 378+ 6F0A              ; result it loaded to DELC
 379+ 6F0A 7A           mulHLEbyDSigned:        ld      a,d                 ; get sign from d
 380+ 6F0B AC                                   xor     h                   ; xor with h to get resultant sign
 381+ 6F0C E6 80                                and     SignOnly8Bit        ; .
 382+ 6F0E FD 67                                ld      iyh,a               ; iyh = copy of sign
 383+ 6F10 7C                                   ld      a,h                 ; now HLE = ABS (HLE)
 384+ 6F11 E6 7F                                and     SignMask8Bit        ; .
 385+ 6F13 67                                   ld      h,a                 ; .
 386+ 6F14 7A                                   ld      a,d                 ; d = ABS D
 387+ 6F15 E6 7F                                and     SignMask8Bit        ; .
 388+ 6F17 57                                   ld      d,a                 ; .
 389+ 6F18 B7           .testEitherSideZero:    or      a
 390+ 6F19 28 24                                jr      z,.ResultZero
 391+ 6F1B 7C                                   ld      a,h
 392+ 6F1C B5                                   or      l
 393+ 6F1D B3                                   or      e
 394+ 6F1E 28 1F                                jr      z,.ResultZero
 395+ 6F20              ; At this point HLE = ABS (HLE), A = ABS(D)
 396+ 6F20 42                                   ld      b,d                 ; save Quotient
 397+ 6F21 ED 30        .mul1:                  mul     de                  ; C = E * D
 398+ 6F23 4B                                   ld      c,e                 ; C = p0
 399+ 6F24 FD 6A                                ld      iyl,d               ; save carry (p1)
 400+ 6F26 5D           .mul2:                  ld      e,l                 ; L = L * D
 401+ 6F27 50                                   ld      d,b                 ; .
 402+ 6F28 ED 30                                mul     de                  ; .
 403+ 6F2A FD 7D                                ld      a,iyl               ; get back p1
 404+ 6F2C 83           .carrybyte1:            add     a,e                 ; L = L + E
 405+ 6F2D 6F                                   ld      l,a                 ; .
 406+ 6F2E FD 6A                                ld      iyl,d               ; save new carry byte
 407+ 6F30 5C           .mul3:                  ld      e,h                 ; E = H * D
 408+ 6F31 50                                   ld      d,b                 ; .
 409+ 6F32 ED 30                                mul     de                  ; .
 410+ 6F34 FD 7D                                ld      a,iyl
 411+ 6F36 8B                                   adc     a,e                 ; .
 412+ 6F37 5F                                   ld      e,a                 ; .
 413+ 6F38 7A           .ItsNotZero:            ld      a,d                 ;
 414+ 6F39 CE 00                                adc     a,0                 ; final carry bit
 415+ 6F3B FD B4                                or      iyh                 ; bring back sign
 416+ 6F3D 57                                   ld      d,a                 ; s = sign
 417+ 6F3E C9                                   ret
 418+ 6F3F 11 00 00     .ResultZero:            ld      de,0
 419+ 6F42                                      ZeroA
 419+ 6F42 AF          >                        xor a
 420+ 6F43 4F                                   ld      c,a
 421+ 6F44 6F                                   ld      l,a
 422+ 6F45 C9                                   ret
 423+ 6F46
 424+ 6F46              ;;;
 425+ 6F46              ;;;
 426+ 6F46              ;;;mulHLEbyDSigned:        ld      a,d                 ; get sign from d
 427+ 6F46              ;;;                        xor     h                   ; xor with h to get resultant sign
 428+ 6F46              ;;;                        and     SignOnly8Bit        ; .
 429+ 6F46              ;;;                        ld      iyh,a               ; iyh = copy of sign
 430+ 6F46              ;;;                        ld      a,h                 ; now HLE = ABS (HLE)
 431+ 6F46              ;;;                        and     SignMask8Bit        ; .
 432+ 6F46              ;;;                        ld      h,a                 ; .
 433+ 6F46              ;;;                        ld      a,d                 ; d = ABS D
 434+ 6F46              ;;;                        and     SignMask8Bit        ; .
 435+ 6F46              ;;;                        ld      d,a                 ; .
 436+ 6F46              ;;;.testEitherSideZero:    or      a
 437+ 6F46              ;;;                        jr      z,.ResultZero
 438+ 6F46              ;;;                        ld      a,h
 439+ 6F46              ;;;                        or      l
 440+ 6F46              ;;;                        or      e
 441+ 6F46              ;;;                        jr      z,.ResultZero
 442+ 6F46              ;;;; At this point HLE = ABS (HLE), A = ABS(D)
 443+ 6F46              ;;;.mul1:                  mul     de                  ; C = E * D
 444+ 6F46              ;;;                        ex      af,af'              ; save mulitplier
 445+ 6F46              ;;;                        ld      c,e                 ; C = p0
 446+ 6F46              ;;;                        ld      a,d                 ; save carry (p1)
 447+ 6F46              ;;;                        ex      af,af'              ; .
 448+ 6F46              ;;;.mul2:                  ld      e,l                 ; L = L * D
 449+ 6F46              ;;;                        ld      d,a                 ; .
 450+ 6F46              ;;;                        mul     de                  ; .
 451+ 6F46              ;;;                        ex      af,af'              ; .
 452+ 6F46              ;;;.carrybyte1:            add     a,e                 ; L = L + E
 453+ 6F46              ;;;                        ld      l,a                 ; .
 454+ 6F46              ;;;                        ld      a,d
 455+ 6F46              ;;;                        ex      af,af'              ; save new carry byte
 456+ 6F46              ;;;.mul3:                  ld      e,h                 ; E = H * D
 457+ 6F46              ;;;                        ld      d,a                 ; .
 458+ 6F46              ;;;                        mul     de                  ; .
 459+ 6F46              ;;;                        ex      af,af'              ; .
 460+ 6F46              ;;;                        adc     a,e                 ; .
 461+ 6F46              ;;;                        ld      e,a                 ; .
 462+ 6F46              ;;;.ItsNotZero:            ld      a,d                 ;
 463+ 6F46              ;;;                        adc     a,0                 ; final carry bit
 464+ 6F46              ;;;                        or      iyh                 ; bring back sign
 465+ 6F46              ;;;                        ld      d,a                 ; s = sign
 466+ 6F46              ;;;                        ret
 467+ 6F46              ;;;.ResultZero:            ld      de,0
 468+ 6F46              ;;;                        ZeroA
 469+ 6F46              ;;;                        ld      c,a
 470+ 6F46              ;;;                        ld      l,a
 471+ 6F46              ;;;                        ret
 472+ 6F46
 473+ 6F46              ; multiplication of two S156-bit numbers into a 16-bit 2'd compliment product
 474+ 6F46              ; enter : de = 16-bit multiplicand
 475+ 6F46              ;         hl = 16-bit multiplicand
 476+ 6F46              ; exit  : hl = 16-bit product
 477+ 6F46              ;         carry reset
 478+ 6F46              ;
 479+ 6F46              ; uses  : af, bc, de, hl
 480+ 6F46 00           mulDEbyHLSignByte       DB      0
 481+ 6F47 AF           mulDEbyHLSgnTo2c:       xor     a
 482+ 6F48 32 46 6F                             ld      (mulDEbyHLSignByte),a
 483+ 6F4B 7A           .SignDE:                ld      a,d
 484+ 6F4C ED 27 80                             test    $80
 485+ 6F4F 28 08                                jr      z,.SignHL
 486+ 6F51 E6 7F        .NegativeDE:            and     $7F
 487+ 6F53 57                                   ld      d,a
 488+ 6F54 3E 80                                ld      a,$80
 489+ 6F56 32 46 6F                             ld      (mulDEbyHLSignByte),a
 490+ 6F59 7C           .SignHL:                ld      a,h
 491+ 6F5A ED 27 80                             test    $80
 492+ 6F5D 28 0B                                jr      z,.AbsoluteMultiply
 493+ 6F5F E6 7F        .NegativeHL:            and     $7F
 494+ 6F61 67                                   ld      h,a
 495+ 6F62 3A 46 6F                             ld      a,(mulDEbyHLSignByte)
 496+ 6F65 EE 80                                xor     $80
 497+ 6F67 32 46 6F                             ld      (mulDEbyHLSignByte),a
 498+ 6F6A CD 70 6E     .AbsoluteMultiply:      call    mulDEbyHL
 499+ 6F6D 3A 46 6F     .RecoverSign:           ld      a,(mulDEbyHLSignByte)
 500+ 6F70 ED 27 80                             test    $80
 501+ 6F73 C8                                   ret     z
 502+ 6F74 AF           .Negateghl: 			xor 	a
 503+ 6F75 95                                   sub 	l
 504+ 6F76 6F                                   ld 		l,a
 505+ 6F77 9F                                   sbc 	a,a
 506+ 6F78 94                                   sub 	h
 507+ 6F79 67                                   ld 		h,a
 508+ 6F7A C9                                   ret
 509+ 6F7B
 510+ 6F7B AF           mulDESgnbyHLUnsgnTo2c:  xor     a
 511+ 6F7C 32 46 6F                             ld      (mulDEbyHLSignByte),a
 512+ 6F7F 7A           .SignDE:                ld      a,d
 513+ 6F80 ED 27 80                             test    $80
 514+ 6F83 28 08                                jr      z,.AbsoluteMultiply
 515+ 6F85 E6 7F        .NegativeDE:            and     $7F
 516+ 6F87 57                                   ld      d,a
 517+ 6F88 3E 80                                ld      a,$80
 518+ 6F8A 32 46 6F                             ld      (mulDEbyHLSignByte),a
 519+ 6F8D CD 70 6E     .AbsoluteMultiply:      call    mulDEbyHL
 520+ 6F90 3A 46 6F     .RecoverSign:           ld      a,(mulDEbyHLSignByte)
 521+ 6F93 ED 27 80                             test    $80
 522+ 6F96 C8                                   ret     z
 523+ 6F97 AF           .Negateghl:             xor 	a
 524+ 6F98 95                                   sub 	l
 525+ 6F99 6F                                   ld 		l,a
 526+ 6F9A 9F                                   sbc 	a,a
 527+ 6F9B 94                                   sub 	h
 528+ 6F9C 67                                   ld 		h,a
 529+ 6F9D C9                                   ret
 530+ 6F9E
 531+ 6F9E
# file closed: ../../Maths/multiply.asm
 623  6F9E                  INCLUDE "../../Maths/asm_square.asm"
# file opened: ../../Maths/asm_square.asm
   1+ 6F9E              ; "ASM_SQUA : TESTGOOD"
   2+ 6F9E              ; "AP = A^2 A = low,P = hi"
   3+ 6F9E
   4+ 6F9E              inline_squde: MACRO
   5+ 6F9E ~            			ld	e,a
   6+ 6F9E ~            			ld  d,a
   7+ 6F9E ~            			mul
   8+ 6F9E              			ENDM
   9+ 6F9E
  10+ 6F9E              inline_squa: MACRO
  11+ 6F9E ~            			ld	e,a
  12+ 6F9E ~            			ld  d,a
  13+ 6F9E ~            			mul
  14+ 6F9E ~            			ld	a,e
  15+ 6F9E              			ENDM
  16+ 6F9E
# file closed: ../../Maths/asm_square.asm
 624  6F9E                  INCLUDE "../../Maths/asm_sine.asm"
# file opened: ../../Maths/asm_sine.asm
   1+ 6F9E              ;- MACROS
   2+ 6F9E              LookupSineAMacro:       MACRO
   3+ 6F9E ~                                    ld      hl,SNE                      ; Set Q = sin(X)  = sin(CNT2 mod 32) = |sin(CNT2)|
   4+ 6F9E ~                                    add     hl, a
   5+ 6F9E ~                                    ld      a,(hl)
   6+ 6F9E                                      ENDM
   7+ 6F9E
   8+ 6F9E              ; Gets the sine of A from the lookup table into A
   9+ 6F9E              LookupSineA:            LookupSineAMacro
   9+ 6F9E 21 47 70    >                        ld      hl,SNE                      ; Set Q = sin(X)  = sin(CNT2 mod 32) = |sin(CNT2)|
   9+ 6FA1 ED 31       >                        add     hl, a
   9+ 6FA3 7E          >                        ld      a,(hl)
  10+ 6FA4 C9                                   ret
  11+ 6FA5
# file closed: ../../Maths/asm_sine.asm
 625  6FA5                  INCLUDE "../../Maths/asm_sqrt.asm"
# file opened: ../../Maths/asm_sqrt.asm
   1+ 6FA5              ; "ASM SQRT : TESTGOOD"
   2+ 6FA5              ; "16-bit integer square root"
   3+ 6FA5              ; "call with de = number to square root"
   4+ 6FA5              ; "returns   hl = square root"
   5+ 6FA5              ; "corrupts  bc, de"
   6+ 6FA5              asm_sqrt:
   7+ 6FA5 01 00 80     	ld bc,$8000
   8+ 6FA8 61           	ld h,c
   9+ 6FA9 69           	ld l,c
  10+ 6FAA              .sqrloop:
  11+ 6FAA CB 38        	srl b
  12+ 6FAC CB 19        	rr c
  13+ 6FAE 09           	add hl,bc
  14+ 6FAF EB           	ex de,hl
  15+ 6FB0 ED 52        	sbc hl,de
  16+ 6FB2 38 04        	jr c,.sqrbit
  17+ 6FB4 EB           	ex de,hl
  18+ 6FB5 09           	add hl,bc
  19+ 6FB6 18 05        	jr .sqrfi
  20+ 6FB8              .sqrbit:
  21+ 6FB8 19           	add hl,de
  22+ 6FB9 EB           	ex de,hl
  23+ 6FBA B7           	or a
  24+ 6FBB ED 42        	sbc hl,bc
  25+ 6FBD              .sqrfi:
  26+ 6FBD CB 3C        	srl h
  27+ 6FBF CB 1D        	rr l
  28+ 6FC1 CB 38        	srl b
  29+ 6FC3 CB 19        	rr c
  30+ 6FC5 30 E3        	jr nc,.sqrloop
  31+ 6FC7 C9           	ret
  32+ 6FC8
  33+ 6FC8
  34+ 6FC8              sqrtQR:					; Q = SQR(Qlo.Rhi) Q <~127
  35+ 6FC8 3A 5F 69     	ld		a,(varQ)
  36+ 6FCB 5F           	ld		e,a
  37+ 6FCC 3A 60 69     	ld		a,(varR)
  38+ 6FCF 57           	ld		d,a
  39+ 6FD0 CD A5 6F     	call	asm_sqrt
  40+ 6FD3 7D               ld      a,l
  41+ 6FD4 32 5F 69     	ld		(varQ),a
  42+ 6FD7 C9           	ret
  43+ 6FD8
# file closed: ../../Maths/asm_sqrt.asm
 626  6FD8                  INCLUDE "../../Maths/asm_arctan.asm"
# file opened: ../../Maths/asm_arctan.asm
   1+ 6FD8              ;Calculate A = arctan(P / Q)
   2+ 6FD8              ; This finds the angle in the right-angled triangle where the opposite side to angle A is length P and the adjacent side to angle A has
   3+ 6FD8              ; length Q, so:  tan(A) = P / Q
   4+ 6FD8              ;
   5+ 6FD8              ; The result in A is an integer representing the angle in radians. The routine returns values in the range 0 to 128,  (or 0 to PI radians).
   6+ 6FD8 3A 5F 68     ARCTAN:                 ld      a,(varP)                    ; LDA P                  \ Set T1 = P EOR Q, which will have the sign of P * Q
   7+ 6FDB 21 5F 69                             ld      hl,varQ                     ; EOR Q
   8+ 6FDE AE                                   xor     (hl)                        ; .
   9+ 6FDF 32 5C 68                             ld      (varT1),a                   ; STA T1
  10+ 6FE2 3A 5F 69                             ld      a,(varQ)                    ; LDA Q                  \ If Q = 0, jump to AR2 to return a right angle
  11+ 6FE5 A7                                   and     a                           ; BEQ AR2
  12+ 6FE6 CA 28 70                             jp      z, .AR2                     ; .
  13+ 6FE9 CB 27                                sla     a                           ; ASL A                  \ Set Q = |Q| * 2 (this is a quick way of clearing the
  14+ 6FEB 32 5F 69                             ld      (varQ),a                    ; STA Q                  \ sign bit, and we don't need to shift right again as we only ever use this value in the division with |P| * 2, which we set next)
  15+ 6FEE 3A 5F 68                             ld      a,(varP)                    ; LDA P                  \ Set A = |P| * 2
  16+ 6FF1 CB 27                                sla     a                           ; ASL A
  17+ 6FF3 32 5F 68                             ld      (varP),a
  18+ 6FF6 21 5F 69                             ld      hl,varQ
  19+ 6FF9 BE                                   cp      (hl)                        ; CMP Q                  \ If A >= Q, i.e. |P| > |Q|, jump to AR1 to swap P
  20+ 6FFA D2 0C 70                             jp      nc, .AR1                    ; BCS AR1                \ and Q around, so we can still use the lookup table
  21+ 6FFD CD 34 70                             call    ARS1                        ; JSR ARS1               \ Call ARS1 to set the following from the lookup table:  A = arctan(A / Q)  = arctan(|P / Q|)
  22+ 7000                                      ClearCarryFlag                      ; SEC                    \ Set the C flag so the SBC instruction in AR3 will be correct, should we jump there
  22+ 7000 B7          >                        or a
  23+ 7001 4F           .AR4:                   ld      c,a                         ; as we have to use a we use c as a temp, we can't push af as we would loose flags on pop
  24+ 7002 3A 5C 68                             ld      a,(varT1)                   ; LDX T1                 \ If T1 is negative, i.e. P and Q have different signs,
  25+ 7005 47                                   ld      b,a                         ; .
  26+ 7006 A7                                   and     a                           ; BMI AR3                \ jump down to AR3 to return arctan(-|P / Q|)
  27+ 7007 79                                   ld      a,c                         ; .                      \ we need to get a back before jump
  28+ 7008 FA 2B 70                             jp      m, .AR3                     ; .
  29+ 700B C9                                   ret                                 ; RTS                    \ Otherwise P and Q have the same sign, so our result is correct and we can return from the subroutine
  30+ 700C              ; We want to calculate arctan(t) where |t| > 1, so we can use the calculation described in the documentation for the ACT table, i.e. 64 - arctan(1 / t)
  31+ 700C              ; In the 6502 verion it works with A already being P but we will fetch it
  32+ 700C 3A 5F 69     .AR1:                   ld      a,(varQ)                    ; LDX Q                  \ Swap the values in Q and P, using the fact that we
  33+ 700F 47                                   ld      b,a                         ; .
  34+ 7010 3A 5F 68                             ld      a,(varP)                    ; STA Q                  \ called AR1 with A = P
  35+ 7013 32 5F 69                             ld      (varQ),a                    ; .
  36+ 7016 78                                   ld      a,b                         ; TXA                    \ This also sets A = P (which now contains the original argument |Q|)
  37+ 7017 32 5F 68                             ld      (varP),a                    ; STX P                  \
  38+ 701A CD 34 70                             call    ARS1                        ; JSR ARS1               \ Call ARS1 to set the following from the lookup table: A = arctan(A / Q) = arctan(|Q / P|) = arctan(1 / |P / Q|)
  39+ 701D 32 7B 69                             ld      (varT),a                    ; STA T                  \ Set T = 64 - T, we use B as T (its not really that)
  40+ 7020 47                                   ld      b,a                         ; its actually t = a, a = 64-a
  41+ 7021 3E 40                                ld      a,64                        ; LDA #64 What is going on here is t = result
  42+ 7023                                      ClearCarryFlag                      ; SBC T                            a = 64- result
  42+ 7023 B7          >                        or a
  43+ 7024 98                                   sbc     a,b                         ; .
  44+ 7025 C3 01 70                             jp      .AR4                        ; BCS AR4                \ Jump to AR4 to continue the calculation (this BCS is effectively a JMP as the subtraction will never underflow, as ARS1 returns values in the range 0-31)
  45+ 7028              ; If we get here then Q = 0, so tan(A) = infinity and A is a right angle, or 0.25 of a circle. We allocate 255 to a full circle, so we should return 63 for a right angle
  46+ 7028 3E 3F        .AR2:                   ld      a,63                        ; LDA #63                \ Set A to 63, to represent a right angle
  47+ 702A C9                                   ret                                 ; RTS                    \ Return from the subroutine
  48+ 702B              ; A contains arctan(|P / Q|) but P and Q have different signs, so we need to return arctan(-|P / Q|), using the calculation described in the documentation for the ACT table, i.e. 128 - A
  49+ 702B 32 7B 69     .AR3:                   ld      (varT),a
  50+ 702E 47                                   ld      b,a                         ; STA T                  \ Set A = 128 - A, we use b as T
  51+ 702F 3E 80                                ld      a,128                       ; LDA #128               \
  52+ 7031                                      ClearCarryFlag                      ; SBC T                  \ The subtraction will work because we did a SEC before calling AR3
  52+ 7031 B7          >                        or a
  53+ 7032 98                                   sbc     a,b
  54+ 7033 C9                                   ret                                 ; RTS                    \ Return from the subroutine
  55+ 7034              ; This routine fetches arctan(A / Q) from the ACT table, so A will be set to an integer in the range 0 to 31 that represents an angle from 0 to 45 degrees (or 0 to \ PI / 4 radians)
  56+ 7034 CD 85 7F     ARS1:                   call    LL28Amul256DivQ_6502        ; JSR LL28               \ Call LL28 to calculate: R = 256 * A / Q
  57+ 7037 3A 60 69                             ld      a,(varR)                    ; LDA R                  \ Set X = R / 8
  58+ 703A CB 3F                                srl     a                           ; LSR A                  \       = 32 * A / Q
  59+ 703C CB 3F                                srl     a                           ; LSR A                  \
  60+ 703E CB 3F                                srl     a                           ; LSR A                  \ so X has the value t * 32 where t = A / Q, which is
  61+ 7040 21 67 70                             ld      hl,ACT                      ; TAX                    \ what we need to look up values in the ACT table
  62+ 7043 ED 31                                add     hl,a                        ; LDA ACT,X              \ Fetch ACT+X from the ACT table into A, so now:
  63+ 7045 7E                                   ld      a,(hl)                      ;                        \   A = value in ACT + X = value in ACT + (32 * A / Q)= arctan(A / Q)
  64+ 7046 C9                                   ret                                 ; RTS                    \ Return from the subroutine
  65+ 7047
  66+ 7047              ;;;arctan:										; .ARCTAN	\ -> &2A3C  \ A=TAN-1(P/Q) \ A=arctan (P/Q)  called from block E
  67+ 7047              ;;;		ld		a,(varP)					; a = var P
  68+ 7047              ;;;		ld		hl,varQ
  69+ 7047              ;;;		xor		(hl)						; a = var p XOR varQ
  70+ 7047              ;;;		ld		a,(varT1)					; \ T1	 \ quadrant info
  71+ 7047              ;;;		ld		c,a							; c = copy of T1
  72+ 7047              ;;;		ld		a,(hl)						; Q
  73+ 7047              ;;;		cp		0
  74+ 7047              ;;;		jr		z,.AR2						;  Q=0 so set angle to 63, pi/2
  75+ 7047              ;;;		ld		(varQ),a					; Q move to reg B?
  76+ 7047              ;;;		ld		d,a							; copy to reg d
  77+ 7047              ;;;		sla		a							; drop sign
  78+ 7047              ;;;		ld		a,(varP)					; P
  79+ 7047              ;;;		ld		e,a							; copy to reg e
  80+ 7047              ;;;		sla		a							; drop sign
  81+ 7047              ;;;		cp		d							; compare with b (unsigned varQ * 2)
  82+ 7047              ;;;		jr		nc, .ars1					; if q >  p then adjust  swop A and Q as A >= Q
  83+ 7047              ;;;		call	ars1						; \ ARS1 \ get Angle for A*32/Q from table.
  84+ 7047              ;;;		scf									; set carry flag
  85+ 7047              ;;;.ar4:										; sub o.k
  86+ 7047              ;;;		bit 	7,c							; is T1 (also in c) negative?
  87+ 7047              ;;;		jr		nz,.ar3						;  -ve quadrant
  88+ 7047              ;;;		ret
  89+ 7047              ;;;.ar1:										; swop A and Q entering here d = q and e = P
  90+ 7047              ;;;		ld		a,d							; a = varQ
  91+ 7047              ;;;		ld		d,e							; varQ = varP
  92+ 7047              ;;;		ld		e,a							; swap D and E around
  93+ 7047              ;;;		ld		(varP),a					; write to actual variables
  94+ 7047              ;;;		ld		a,d
  95+ 7047              ;;;		ld		(varQ),a					; write to actual variables
  96+ 7047              ;;;		call	.ars1
  97+ 7047              ;;;		ld		(varT),b
  98+ 7047              ;;;		ld		b,a							; B = T = angle
  99+ 7047              ;;;		ld		a,64						; next range of angle, pi/4 to pi/2
 100+ 7047              ;;;		sub		a,b							; a = 64 - T (or b)
 101+ 7047              ;;;		jr		nc,.ar4						;  sub o.k
 102+ 7047              ;;;.ar2:										; .AR2	\ set angle to 90 degrees
 103+ 7047              ;;;		ld 		a,&3F						;  #63
 104+ 7047              ;;;		ret
 105+ 7047              ;;;.ar3:										;.AR3	\ -ve quadrant
 106+ 7047              ;;;		ld		b,a							; b = T	= \ angle
 107+ 7047              ;;;		ld		a,ConstPi					; a = Pi
 108+ 7047              ;;;		sub		b,a							; A = 128-T, so now covering range pi/2 to pi correctly
 109+ 7047              ;;;		ret
 110+ 7047              ;;;.ars1:										; .ARS1	\ -> &2A75  \ get Angle for A*32/Q from table.
 111+ 7047              ;;;		call	RequAmul256divQ				;  LL28 \ BFRDIV R=A*256/Q
 112+ 7047              ;;;		ld		a,(regA)
 113+ 7047              ;;;		srl		a
 114+ 7047              ;;;		srl		a
 115+ 7047              ;;;		srl		a							;  31 max.
 116+ 7047              ;;;		ld		hl, ArcTanTable				; root of index into table at end of words data
 117+ 7047              ;;;		add		hl,a						; now at real data
 118+ 7047              ;;;		ld		a,(hl)						; a =  ACT[a]
 119+ 7047              ;;;.arsr:										; rts used by laser lines below (will not in later code)
 120+ 7047              ;;;		ret
 121+ 7047
 122+ 7047
 123+ 7047
# file closed: ../../Maths/asm_arctan.asm
 627  7047                  INCLUDE "../../Maths/SineTable.asm"
# file opened: ../../Maths/SineTable.asm
   1+ 7047              ;; PRINT "SIN TABLE"
   2+ 7047              ;; FOR I% =  0 TO  31
   3+ 7047              ;; N = ABS(SIN((I%/64)*2*PI))
   4+ 7047              ;; IF N >= 1 THEN B% = 255  ELSE B% = INT(256 * N + 0.5)
   5+ 7047              ;; PRINT B%
   6+ 7047              ;; NEXT I%
   7+ 7047
   8+ 7047
   9+ 7047 00 19 32 4A  SNE:            DB 000, 025, 050, 074, 098, 121, 142, 162
   9+ 704B 62 79 8E A2
  10+ 704F B5 C6 D5 E2                  DB 181, 198, 213, 226, 237, 245, 251, 255
  10+ 7053 ED F5 FB FF
  11+ 7057 FF FF FB F5                  DB 255, 255, 251, 245, 237, 226, 213, 198
  11+ 705B ED E2 D5 C6
  12+ 705F B5 A2 8E 79                  DB 181, 162, 142, 121, 098, 074, 050, 025
  12+ 7063 62 4A 32 19
# file closed: ../../Maths/SineTable.asm
 628  7067                  INCLUDE "../../Maths/ArcTanTable.asm"
# file opened: ../../Maths/ArcTanTable.asm
   1+ 7067              ;PRINT "ARCTAN TABLE"
   2+ 7067              ;FOR I% = 0 TO 31
   3+ 7067              ;    PRINT INT((128/PI) * ATN(I%/32)+0.5)
   4+ 7067              ;NEXT I%
   5+ 7067
   6+ 7067 00 01 03 04  ACT:            DB 000, 001, 003, 004, 005, 006, 008, 009
   6+ 706B 05 06 08 09
   7+ 706F 0A 0B 0C 0D                  DB 010, 011, 012, 013, 015, 016, 017, 018
   7+ 7073 0F 10 11 12
   8+ 7077 13 14 15 16                  DB 019, 020, 021, 022, 023, 024, 025, 025
   8+ 707B 17 18 19 19
   9+ 707F 1A 1B 1C 1D                  DB 026, 027, 028, 029, 030, 031, 031, 031
   9+ 7083 1E 1F 1F 1F
  10+ 7087
# file closed: ../../Maths/ArcTanTable.asm
 629  7087                  INCLUDE "../../Maths/negate16.asm"
# file opened: ../../Maths/negate16.asm
   1+ 7087              ;;----------------------------------------------------------------------------------------------------------------------
   2+ 7087              ;; 16-bit negate
   3+ 7087                      ; Input:
   4+ 7087                      ;       HL = value
   5+ 7087                      ; Output:
   6+ 7087                      ;       HL = -value
   7+ 7087                      ; Destroys:
   8+ 7087                      ;       AF
   9+ 7087                      ;
  10+ 7087              negate16:
  11+ 7087 AF           negate16hl:         xor 	a
  12+ 7088 95                               sub 	l
  13+ 7089 6F                               ld 		l,a
  14+ 708A 9F                               sbc 	a,a
  15+ 708B 94                               sub 	h
  16+ 708C 67                               ld 		h,a
  17+ 708D C9                               ret
  18+ 708E
  19+ 708E AF           negate16de:         xor 	a
  20+ 708F 93                               sub 	e
  21+ 7090 5F                               ld 		e,a
  22+ 7091 9F                               sbc 	a,a
  23+ 7092 92                               sub 	d
  24+ 7093 57                               ld 		d,a
  25+ 7094 C9                               ret
  26+ 7095
  27+ 7095 AF           negate16bc:         xor 	a
  28+ 7096 91                               sub 	c
  29+ 7097 4F                               ld 		c,a
  30+ 7098 9F                               sbc 	a,a
  31+ 7099 90                               sub 	b
  32+ 709A 47                               ld 		b,a
  33+ 709B C9                               ret
  34+ 709C
# file closed: ../../Maths/negate16.asm
 630  709C                  INCLUDE "../../Maths/asm_divide.asm"
# file opened: ../../Maths/asm_divide.asm
   1+ 709C              ;   K(3 2 1 0)           The result of the division
   2+ 709C              ;   X                    X is preserved
   3+ 709C
   4+ 709C              ; Calculate K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo) where zsign hi lo is in DE with zsign leading hi
   5+ 709C 00 00 00 00  varQRS                 DS      4
   6+ 70A0 00 00 00     varAPP                  DS     3
   7+ 70A3
   8+ 70A3                                  DISPLAY "TODO:  neds rewrite of whoel DIDV3B2"
   9+ 70A3              ;; NEEDS REWRITE TODO OF WHOLE DIVD3B2
  10+ 70A3              ;; NEEDS REWRITE TODO
  11+ 70A3
  12+ 70A3              ; b = varR, c= varQ
  13+ 70A3              Requ256mulAdivQ_6502:
  14+ 70A3 CB 27        .LL31_6502:             sla     a                       ; ASL A                   \ Shift A to the left
  15+ 70A5 DA BA 70                             jp      c,.LL29_6502             ; BCS LL29               \ If bit 7 of A was set, then jump straight to the subtraction
  16+ 70A8                                      FlipCarryFlag                   ;                          If A < N, then C flag is set.
  16+ 70A8 3F          >                        ccf
  17+ 70A9                                      JumpIfALTNusng c, .LL31_SKIPSUB_6502 ; CMP Q              \ If A < Q, skip the following subtraction
  17+ 70A9 B9          >                        cp      c
  17+ 70AA DA AF 70    >                        jp		c, .LL31_SKIPSUB_6502
  18+ 70AD                                                                      ; BCC P%+4
  19+ 70AD 91                                   sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  20+ 70AE                                      ClearCarryFlag
  20+ 70AE B7          >                        or a
  21+ 70AF              .LL31_SKIPSUB_6502:     FlipCarryFlag
  21+ 70AF 3F          >                        ccf
  22+ 70B0 CB 10                                rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  23+ 70B2 DA A3 70                             jp      c, .LL31_6502            ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  24+ 70B5 78                                   ld      a,b
  25+ 70B6 32 86 EF                             ld      (Rvar),a
  26+ 70B9 C9                                   ret                             ; RTS                    \ R left with remainder of division
  27+ 70BA 91           .LL29_6502:             sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  28+ 70BB                                      SetCarryFlag                    ; SEC                    \ Set the C flag to rotate into the result in R
  28+ 70BB 37          >                        scf
  29+ 70BC CB 10                                rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  30+ 70BE DA A3 70                             jp      c, .LL31_6502            ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  31+ 70C1 78                                   ld      a,b                     ; RTS                    \ Return from the subroutine with R containing the
  32+ 70C2 32 86 EF                             ld      (Rvar),a                ; .
  33+ 70C5 C9                                   ret                             ; .                      \ remainder of the division
  34+ 70C6 3E FF        .LL2_6502:              ld      a,$FF                   ; LDA #255               \ The division is very close to 1, so return the closest
  35+ 70C8 32 60 69                             ld      (varR),a                ; STA R                  \ possible answer to 256, i.e. R = 255
  36+ 70CB 47                                   ld      b,a                     ; as we are using b as varR
  37+ 70CC                                      SetCarryFlag                    ; we failed so need carry flag set
  37+ 70CC 37          >                        scf
  38+ 70CD C9                                   ret                             ; RTS                    \ Return from the subroutine
  39+ 70CE
  40+ 70CE
  41+ 70CE 00           DIVD3B_SHIFT_REG:       DB      0
  42+ 70CF
  43+ 70CF 7B           DIV3B2DE:               ld      a,e                         ; load QRS with Z sign hi lo
  44+ 70D0 32 9E 70                             ld      (varQRS+2),a
  45+ 70D3 7A                                   ld      a,d
  46+ 70D4 E6 7F                                and     $7F
  47+ 70D6 32 9D 70                             ld      (varQRS+1),a
  48+ 70D9 7A                                   ld      a,d
  49+ 70DA E6 80                                and     $80
  50+ 70DC 32 9C 70                             ld      (varQRS),a
  51+ 70DF C3 E5 70                             jp      DVID3B
  52+ 70E2              ; Calculate K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo) = A P[1 0 ] / (SRQ)
  53+ 70E2              ; We don't use zlo and assume its already loaded into SRQ
  54+ 70E2 32 61 68     DVID3B2:                ld      (varP+2),a                  ;STA P+2                \ Set P+2 = A
  55+ 70E5                                                                          ; LDA INWK+6             \ Set Q = z_lo
  56+ 70E5                                                                          ; STA Q
  57+ 70E5                                                                          ; LDA INWK+7             \ Set R = z_hi
  58+ 70E5                                                                          ; STA R
  59+ 70E5                                                                          ; LDA INWK+8             \ Set S = z_sign
  60+ 70E5                                                                          ; STA S
  61+ 70E5              ;  Given the above assignments, we now want to calculate K(3 2 1 0) = P(2 1 0) / (S R Q)
  62+ 70E5 3A 5F 68     DVID3B:                 ld      a,(varP)                    ; LDA P                 \ Make sure P(2 1 0) is at least 1
  63+ 70E8 F6 01                                or      1                           ; ORA #1
  64+ 70EA 32 5F 68                             ld      (varP),a                    ; STA P
  65+ 70ED              ;--- t = sign of P2 xor S (i.e. sign of result) ------------;
  66+ 70ED 3A 61 68                             ld      a,(varP+2)                  ; LDA P+2                \ Set T to the sign of P+2 * S (i.e. the sign of the
  67+ 70F0 21 61 69                             ld      hl, varS                    ; EOR S                  \ result) and store it in T
  68+ 70F3 AE                                   xor     (hl)
  69+ 70F4 E6 80                                and     $80                         ; AND #%10000000
  70+ 70F6 32 7B 69                             ld      (varT),a                    ; STA T
  71+ 70F9              ;--- New bit added to aviod a divde by 0 -------------------;
  72+ 70F9 3A 5F 69     .CheckQRSAtLeast1:      ld      a,(varQ)                    ;
  73+ 70FC 21 60 69                             ld      hl,varR                     ;
  74+ 70FF B6                                   or      (hl)                        ;
  75+ 7100 C2 08 71                             jp      nz,.DVL9Prep                ;
  76+ 7103 3E 01                                ld      a,1                         ;
  77+ 7105 32 5F 69                             ld      (varQ),a                    ;
  78+ 7108              ; A P(1) P(0) = ABS P(2 1 0)
  79+ 7108 06 00        .DVL9Prep:              ld      b,0                         ; LDY #0                 \ Set Y = 0 to store the scale factor (use b as Y)
  80+ 710A 3A 61 68                             ld      a,(varP+2)                  ; LDA P+2                \ Clear the sign bit of P+2, so the division can be done
  81+ 710D E6 7F                                and     $7F                         ; AND #%01111111         \ with positive numbers and we'll set the correct sign below, once all the maths is done
  82+ 710F              ; We now shift (A P+1 P) left until A >= 64, counting the number of shifts in Y. This makes the top part of the division as large as possible, thus retaining as
  83+ 710F              ; much accuracy as we can.  When we come to return the final result, we shift the result by the number of places in Y, and in the correct direction
  84+ 710F                                      DISPLAY "TODO DVL9 and DVL6 move P and QRS into registers for faster shift"
  85+ 710F              ;-- while A < 64 shift A P(1) P(0) -------------------------;
  86+ 710F FE 40        .DVL9:                  cp      64                          ; CMP #64                \ If A >= 64, jump down to DV14
  87+ 7111 D2 22 71                             jp      nc, .DV14                   ; BCS DV14
  88+ 7114 21 5F 68                             ld      hl,varP                     ; ASL P                  \ Shift (A P+1 P) to the left
  89+ 7117 CB 26                                sla     (hl)
  90+ 7119 23                                   inc     hl                          ; ROL P+1
  91+ 711A CB 16                                rl      (hl)
  92+ 711C CB 17                                rl      a                           ; ROL A
  93+ 711E 04                                   inc     b                           ; INY                    \ Increment the scale factor in Y
  94+ 711F C3 0F 71                             jp      .DVL9                       ; BNE DVL9               \ Loop up to DVL9 (this BNE is effectively a JMP, as Y will never be zero)
  95+ 7122              ; If we get here, A >= 64 and contains the highest byte of the numerator, scaled up by the number of left shifts in Y (b in our code)
  96+ 7122 32 61 68     .DV14:                  ld      (varP+2),a                  ; Store A in P+2, so we now have the scaled value of the numerator in P(2 1 0)
  97+ 7125 3A 61 69                             ld      a,(varS)                    ; LDA S                  \ Set A = |S|
  98+ 7128 E6 7F                                and     $7F                         ; AND #%01111111
  99+ 712A                                      ;nop                                ;  BMI DV9               \ If bit 7 of A is set, jump down to DV9 (which can never happen)
 100+ 712A              ; We now shift (S R Q) left until bit 7 of S is set, reducing Y by the number of shifts. This makes the bottom part of the division as large as possible, thus
 101+ 712A              ; retaining as much accuracy as we can. When we come to return the final result, we shift the result by the total number of places in Y, and in the correct
 102+ 712A              ; direction, to give us the correct result
 103+ 712A              ; We set A to |S| above, so the following actually shifts (A R Q)
 104+ 712A 05           .DVL6:                  dec     b                           ; DEY                    \ Decrement the scale factor in Y (b)
 105+ 712B 21 5F 69                             ld      hl,varQ                     ; ASL Q                  \ Shift (A R Q) to the left
 106+ 712E CB 26                                sla     (hl)                        ; .
 107+ 7130 21 60 69                             ld      hl,varR                     ; ROL R
 108+ 7133 CB 16                                rl      (hl)                        ; .
 109+ 7135 CB 17                                rl      a                           ; ROL A
 110+ 7137 F2 2A 71                             jp      p,.DVL6                     ; BPL DVL6               \ Loop up to DVL6 to do another shift, until bit 7 of A is set and we can't shift left any further
 111+ 713A              ; We have now shifted both the numerator and denominator left as far as they will go, keeping a tally of the overall scale factor of the various shifts in Y. We
 112+ 713A              ; can now divide just the two highest bytes to get our result
 113+ 713A 32 5F 69     .DV9:                   ld      (varQ),a                    ; STA Q                  \ Set Q = A, the highest byte of the denominator
 114+ 713D 4F                                   ld      c,a                         ; for Requ256mulAdivQ_6502 as it uses c as Q
 115+ 713E 78                                   ld      a,b                         ; preserve shift register in DEVD3B_SHIFT_REG
 116+ 713F 32 CE 70                             ld      (DIVD3B_SHIFT_REG),a
 117+ 7142              ; Note in Requ256mulAdivQ_6502 we use B as R Var for shift register
 118+ 7142 06 FE                                ld      b,254                       ; LDA #254               \ Set R to have bits 1-7 set, so we can pass this to
 119+ 7144 32 60 69                             ld      (varR),a                    ; STA R                  \ LL31 to act as the bit counter in the division
 120+ 7147 3A 61 68                             ld      a,(varP+2)                  ; LDA P+2                \ Set A to the highest byte of the numerator
 121+ 714A CD A3 70                             call    Requ256mulAdivQ_6502        ; JSR LL31               \ Call LL31 to calculate: R = 256 * A / Q which means result is in b
 122+ 714D              ; The result of our division is now in R, so we just need to shift it back by the scale factor in Y
 123+ 714D                                      ZeroA                               ; LDA #0                \ Set K(3 2 1) = 0 to hold the result (we populate K)
 123+ 714D AF          >                        xor a
 124+ 714E 32 73 69                             ld      (varK+1),a                  ; STA K+1               \ next)
 125+ 7151 32 74 69                             ld      (varK+2),a                  ; STA K+2
 126+ 7154 32 75 69                             ld      (varK+3),a                  ; STA K+3
 127+ 7157 3A CE 70                             ld      a,(DIVD3B_SHIFT_REG)        ; TYA                   \ If Y (shift counter in b) is positive, jump to DV12
 128+ 715A B7                                   or      a                           ; .                      we want to check the sign or if its zero
 129+ 715B CA 86 71                             jp      z,.DV13                     ; Optimisation to save a second jump from DV12 to DV13
 130+ 715E F2 91 71                             jp      p,.DV12                     ; BPL DV12
 131+ 7161              ; If we get here then Y is negative, so we need to shift the result R to the left by Y places, and then set the correct sign for the result
 132+ 7161                                      DISPLAY "TODO check oprimisation here for var r  in b"
 133+ 7161 48                                   ld      c,b
 134+ 7162 3A CE 70                             ld      a,(DIVD3B_SHIFT_REG)
 135+ 7165 47                                   ld      b,a
 136+ 7166 79                                   ld      a,c
 137+ 7167                                      ; OPTIM ld      a,(varR)                    ; LDA R                  \ Set A = R
 138+ 7167 CB 27        .DVL8:                  sla     a                           ; ASL A                  \ Shift (K+3 K+2 K+1 A) left
 139+ 7169 21 73 69                             ld      hl,varK+1                   ; ROL K+1
 140+ 716C CB 16                                rl      (hl)                        ; .
 141+ 716E 23                                   inc     hl                          ; ROL K+2
 142+ 716F CB 16                                rl      (hl)                        ; .
 143+ 7171 23                                   inc     hl                          ; ROL K+3
 144+ 7172 CB 16                                rl      (hl)                        ; .
 145+ 7174 04                                   inc     b                           ; INY                    \ Increment the scale factor in Y
 146+ 7175 C2 67 71                             jp      nz,.DVL8                    ; BNE DVL8               \ Loop back to DVL8 until we have shifted left by Y places
 147+ 7178 32 72 69                             ld      (varK),a                    ; STA K                  \ Store A in K so the result is now in K(3 2 1 0)
 148+ 717B 3A 75 69                             ld      a,(varK+3)                  ; LDA K+3                \ Set K+3 to the sign in T, which we set above to the
 149+ 717E 21 7B 69                             ld      hl,varT                     ; ORA T                  \ correct sign for the result
 150+ 7181 B6                                   or      (hl)                        ; .
 151+ 7182 32 75 69                             ld      (varK+3),a                  ; STA K+3
 152+ 7185 C9                                   ret                                 ; RTS                    \ Return from the subroutine
 153+ 7186              ; If we get here then Y is zero, so we don't need to shift the result R, we just need to set the correct sign for the result
 154+ 7186 78           .DV13:                  ld      a,b; varR)                  ; LDA R                  \ Store R in K so the result is now in K(3 2 1 0)
 155+ 7187 32 72 69                             ld      (varK),a                    ; STA K
 156+ 718A 3A 7B 69                             ld      a,(varT)                    ; LDA T                  \ Set K+3 to the sign in T, which we set above to the
 157+ 718D 32 75 69                             ld      (varK+3),a                  ; STA K+3                \ correct sign for the result
 158+ 7190 C9                                   ret                                 ; RTS                    \ Return from the subroutine
 159+ 7191              ; if we get here U is positive but still could be zero, now this is handled in DV9
 160+ 7191              .DV12:                  ; nop                               ; BEQ DV13               \ We jumped here having set A to the scale factor in Y, so this jumps up to DV13 if Y = 0
 161+ 7191              ; If we get here then Y is positive and non-zero, so we need to shift the result R to the right by Y places and then set the correct sign for the result. We also
 162+ 7191              ; know that K(3 2 1) will stay 0, as we are shifting the lowest byte to the right, so no set bits will make their way into the top three bytes
 163+ 7191                                      ;ld      a,(varR)                    ; LDA R                  \ Set A = R
 164+ 7191 48                                   ld      c,b
 165+ 7192 3A CE 70                             ld      a,(DIVD3B_SHIFT_REG)
 166+ 7195 47                                   ld      b,a
 167+ 7196 79                                   ld      a,c
 168+ 7197 CB 3F        .DVL10:                 srl     a                           ; LSR A                  \ Shift A right
 169+ 7199 05                                   dec     b                           ; DEY                    \ Decrement the scale factor in Y
 170+ 719A C2 97 71                             jp      nz,.DVL10                   ; BNE DVL10              \ Loop back to DVL10 until we have shifted right by Y places
 171+ 719D 32 72 69                             ld      (varK),a                    ; STA K                  \ Store the shifted A in K so the result is now in K(3 2 1 0)
 172+ 71A0 3A 7B 69                             ld      a,(varT)                    ; LDA T                  \ Set K+3 to the sign in T, which we set above to the
 173+ 71A3 32 75 69                             ld      (varK+3),a                  ; STA K+3                \ correct sign for the result
 174+ 71A6 C9                                   ret                                 ; RTS                    \ Return from the subroutine
 175+ 71A7              ;
 176+ 71A7              ;   Set flags E to 11111110
 177+ 71A7              ;   Loop:   A << 2
 178+ 71A7              ;           if carry was 0
 179+ 71A7              ;               if a >= D
 180+ 71A7              ;                   A = A - D
 181+ 71A7              ;                   clear carry (probably irrelevant really)
 182+ 71A7              ;           else
 183+ 71A7
 184+ 71A7              ;               sla flags << bringing in carry of 1
 185+ 71A7              ;               if bit 7 of flag was set then loop
 186+ 71A7              ;                                        elase a = e and exit
 187+ 71A7              ;
 188+ 71A7              ; ">BC_Div_DE: BC = BC / DE. HL = remainder fast divide with unrolled loop BC/DE ==> BC, remainder in HL
 189+ 71A7              ;
 190+ 71A7              ;INPUTS: hl = dividend dbc = divisor
 191+ 71A7              ;OUTPUTS: hl/de -> AHL = quotient CDE = remainder, Carryflag set if divide by 0
 192+ 71A7
 193+ 71A7 57           DVIDT:                  ld      d,a                     ; D = var P+1
 194+ 71A8 3A 5F 69                             ld      a,(varQ)
 195+ 71AB 4F                                   ld      c,a                     ; C = var Q
 196+ 71AC 3A 5F 68                             ld      a,(varP)
 197+ 71AF 5F                                   ld      e,a                     ; E = var P
 198+ 71B0                                      ; Need fast exists on ABS values
 199+ 71B0 7A           BAequDEdivC:            ld      a,d                     ; Fast exit is value is 0
 200+ 71B1 B3                                   or      e                       ; .
 201+ 71B2 28 2A                                jr      z,.ResultIsZero         ; .
 202+ 71B4 79                                   ld      a,c                     ; Fast exit is divide by 0
 203+ 71B5 A7                                   and     a                       ;
 204+ 71B6 28 29                                jr      z,.ResultIsFFFF         ;
 205+ 71B8 7A           .SavSign:               ld      a,d                     ; preserve sign of result in var T
 206+ 71B9 A9                                   xor     c                       ;
 207+ 71BA E6 80                                and     $80
 208+ 71BC 6F                                   ld      l,a                     ; l = var T
 209+ 71BD 3E 00                                ld      a,0
 210+ 71BF 06 10                                ld      b,16
 211+ 71C1                                      ShiftDELeft1
 211+ 71C1 CB 23       >			   sla e
 211+ 71C3 CB 12       >			   rl  d
 212+ 71C5 CB 21                                sla     c                       ; c = abs c
 213+ 71C7 CB 39                                srl     c
 214+ 71C9 CB 17        .DivideLoop:            rl      a
 215+ 71CB                                      JumpIfALTNusng c, .SkipSubtract
 215+ 71CB B9          >                        cp      c
 215+ 71CC DA D2 71    >                        jp		c, .SkipSubtract
 216+ 71CF                                      ClearCarryFlag
 216+ 71CF B7          >                        or a
 217+ 71D0 99                                   sbc     c
 218+ 71D1                                      ClearCarryFlag
 218+ 71D1 B7          >                        or a
 219+ 71D2 3F           .SkipSubtract:          ccf
 220+ 71D3 CB 13                                rl      e
 221+ 71D5 CB 12                                rl      d
 222+ 71D7 05                                   dec     b
 223+ 71D8 20 EF                                jr      nz,.DivideLoop
 224+ 71DA 7B                                   ld      a,e
 225+ 71DB B5                                   or      l
 226+ 71DC 42                                   ld      b,d
 227+ 71DD C9                                   ret
 228+ 71DE              .ResultIsZero:          ZeroA
 228+ 71DE AF          >                        xor a
 229+ 71DF 47                                   ld      b,a
 230+ 71E0 C9                                   ret
 231+ 71E1 3E FF        .ResultIsFFFF:          ld      a,$FF
 232+ 71E3 47                                   ld      b,a
 233+ 71E4 C9                                   ret
 234+ 71E5
 235+ 71E5 57           DIV96:                  ld      d,a                     ; D = var P+1
 236+ 71E6 3A 5F 69                             ld      a,(varQ)
 237+ 71E9 0E 60                                ld      c,96                    ; C = var Q
 238+ 71EB 3A 5F 68                             ld      a,(varP)
 239+ 71EE 5F                                   ld      e,a                     ; E = var P
 240+ 71EF                                      ; Need fast exists on ABS values
 241+ 71EF 7A           BAequDEdiv96            ld      a,d                     ; Fast exit is value is 0
 242+ 71F0 B3                                   or      e                       ; .
 243+ 71F1 28 26                                jr      z,.ResultIsZero         ; .
 244+ 71F3 7A           .SavSign:               ld      a,d                     ; preserve sign of result in var T
 245+ 71F4 A9                                   xor     c                       ;
 246+ 71F5 E6 80                                and     $80
 247+ 71F7 6F                                   ld      l,a                     ; l = var T
 248+ 71F8 3E 00                                ld      a,0
 249+ 71FA 06 10                                ld      b,16
 250+ 71FC                                      ShiftDELeft1
 250+ 71FC CB 23       >			   sla e
 250+ 71FE CB 12       >			   rl  d
 251+ 7200 CB 21                                sla     c                       ; c = abs c
 252+ 7202 CB 39                                srl     c
 253+ 7204 CB 17        .DivideLoop:            rl      a
 254+ 7206                                      JumpIfALTNusng c, .SkipSubtract
 254+ 7206 B9          >                        cp      c
 254+ 7207 DA 0D 72    >                        jp		c, .SkipSubtract
 255+ 720A                                      ClearCarryFlag
 255+ 720A B7          >                        or a
 256+ 720B 99                                   sbc     c
 257+ 720C                                      ClearCarryFlag
 257+ 720C B7          >                        or a
 258+ 720D 3F           .SkipSubtract:          ccf
 259+ 720E CB 13                                rl      e
 260+ 7210 CB 12                                rl      d
 261+ 7212 05                                   dec     b
 262+ 7213 20 EF                                jr      nz,.DivideLoop
 263+ 7215 7B                                   ld      a,e
 264+ 7216 B5                                   or      l
 265+ 7217 42                                   ld      b,d
 266+ 7218 C9                                   ret
 267+ 7219              .ResultIsZero:          ZeroA
 267+ 7219 AF          >                        xor a
 268+ 721A 47                                   ld      b,a
 269+ 721B C9                                   ret
 270+ 721C
 271+ 721C 14           Div16by24usgn:          inc     d                           ; can we fast retu
 272+ 721D 15                                   dec     d
 273+ 721E 20 13                                jr      nz,.ResultZero
 274+ 7220 50 59                                ld      de,bc                       ; so prep for bc/de
 275+ 7222 44 4D                                ld      bc,hl
 276+ 7224 7A           .div16by16usng:         ld      a,d
 277+ 7225 B3                                   or      e
 278+ 7226 28 10                                jr      z,.DivideByZero
 279+ 7228 14                                   inc     d
 280+ 7229 15                                   dec     d
 281+ 722A CD 7C 73                             call    BC_Div_DE
 282+ 722D                                      ZeroA
 282+ 722D AF          >                        xor a
 283+ 722E EB                                   ex      de,hl                       ; de = remainder (need to fix c after hl = nothing of worth)
 284+ 722F 60 69                                ld      hl,bc                       ; hl = result (a is zero from above)
 285+ 7231 4F                                   ld      c,a                         ; now fix c
 286+ 7232 C9                                   ret
 287+ 7233 AF           .ResultZero:            xor     a                           ; set AHL to 0 as d was 0 so h is zero
 288+ 7234 4F                                   ld      c,a                         ; c = 0
 289+ 7235 67                                   ld      h,a
 290+ 7236 6F                                   ld      l,a
 291+ 7237 C9                                   ret
 292+ 7238 3E FF        .DivideByZero:          ld      a,$FF
 293+ 723A 67                                   ld      h,a
 294+ 723B 6F                                   ld      l,a
 295+ 723C                                      SetCarryFlag
 295+ 723C 37          >                        scf
 296+ 723D C9                                   ret
 297+ 723E
 298+ 723E              ;DIVD4 P-R=A/Qunsg  \P.R = A/Q unsigned called by Hall
 299+ 723E                          IFDEF HLEquAmul256DivD_Used
 300+ 723E ~            HLEquAmul256DivD:       ld		b,8							; counter
 301+ 723E ~                                    sla		a							;
 302+ 723E ~                                    ld		h,a							; r a * 2 we will build result in hl
 303+ 723E ~            .DivideLoop:            rl		a							; a = a * 2
 304+ 723E ~                                    jr      c,.StraightToSubtraction    ; jump on carry to subtraction
 305+ 723E ~                                    cp      d                           ; what was var Q
 306+ 723E ~                                    jr		c,.SkipSubtraction	        ; if a < d skip subtraction, note this will come to skip subtraction with carry the wrong way round
 307+ 723E ~            .StraightToSubtraction: ClearCarryFlag                      ; in 6502 the borrow flag is inverted carry, z80 just uses carry so we need to clear it
 308+ 723E ~                                    sbc     a,d                         ; a = a - q
 309+ 723E ~                                    ClearCarryFlag                      ; set carry so it gets shifted into bit 0 of b. we do this as we have to flip carry due to jr c from earlier cp d
 310+ 723E ~            .SkipSubtraction:       ccf                                 ; we need to do this as 6502 does opposite on carry, i.e. if we jumped direct here then carry would be set in z80
 311+ 723E ~                                    rl      h                           ; roll d left bringing in carry if there was an sbc performed
 312+ 723E ~                                    djnz    .DivideLoop                 ; 8 cycles
 313+ 723E ~            .CalculateRemainder:    cp      d                           ; calulate 256 * a / d if q >= q then answer will not fit in one byte d is still set, a holds remainder to be subtracted
 314+ 723E ~                                    jr      nc, .RemainderTooBig
 315+ 723E ~                                    ClearCarryFlag                      ; remove carry as the previous cp will have set it and mess up the sla in the remainder loop
 316+ 723E ~            .InitRemainderLoop:     ld      b,%11111110                 ; loop for bits 1 to 7
 317+ 723E ~                                    ld      l,b                         ; and set l to capture result bits (R)
 318+ 723E ~            .RemainderLoop:         sla     a                           ; shift a left
 319+ 723E ~                                    jr      c, .RemainderSubtraction    ; if there was a carry go to subtraction
 320+ 723E ~                                    cp      d                           ; if a < d then skip subtraction
 321+ 723E ~                                    jr      c,.RemainderSkipSubtract    ; .
 322+ 723E ~                                    sbc     d                           ; a > q so a = a - q, carry will be clear here
 323+ 723E ~            .RemainderSkipSubtract: ccf                                 ; as the jr used z80 we need to flip the carry to behave like 6502
 324+ 723E ~                                    rl      l                           ; rotate counter to the left
 325+ 723E ~                                    jr      c, .RemainderLoop           ; if there was a bit pushed to carry then loop
 326+ 723E ~                                    ret
 327+ 723E ~            .RemainderSubtraction:  sbc     d                           ; as the carry came from an sla we want to retain it
 328+ 723E ~                                    SetCarryFlag                        ; roll in a carry bit to result
 329+ 723E ~                                    rl      l                           ;
 330+ 723E ~                                    jr      c, .RemainderLoop           ; and loop if there was a carry bit that came out
 331+ 723E ~                                    ret
 332+ 723E ~            .RemainderTooBig:       ld      l,$FF                       ; now hl = result
 333+ 723E ~                                    ret
 334+ 723E                          ENDIF
 335+ 723E
 336+ 723E BA           AEquAmul256DivD:        cp      d
 337+ 723F 28 1D                                jr      z,.BothSame
 338+ 7241 30 1E                                jr      nc,.DgtA
 339+ 7243 1E FE                                ld      e,%11111110                 ; Set R to have bits 1-7 set, so we can rotate through 7
 340+ 7245 CB 27        .DivideLoop:            sla     a
 341+ 7247 38 0D                                jr      c,.LL29
 342+ 7249                                      JumpIfALTNusng  d, .SkipSub         ; will jump if carry set, so we need to reset on the rol
 342+ 7249 BA          >                        cp      d
 342+ 724A DA 4F 72    >                        jp		c, .SkipSub
 343+ 724D 92                                   sub     d
 344+ 724E                                      ClearCarryFlag                      ; reset clarry as it will be complimented for rotate as 6502 does carry flags inverted
 344+ 724E B7          >                        or a
 345+ 724F              .SkipSub:               FlipCarryFlag                       ; if we did the subtract the carry will be clear so we need to invert to roll in.
 345+ 724F 3F          >                        ccf
 346+ 7250 CB 13                                rl      e
 347+ 7252 38 F1                                jr      c,.DivideLoop
 348+ 7254 7B                                   ld      a,e
 349+ 7255 C9                                   ret
 350+ 7256 92           .LL29:                  sub     d                           ; A >= Q, so set A = A - Q
 351+ 7257                                      SetCarryFlag                        ; Set the C flag to rotate into the result in R
 351+ 7257 37          >                        scf
 352+ 7258 CB 13                                rl      e                           ; rotate counter e left
 353+ 725A 38 E9                                jr      c,.DivideLoop               ; if a bit was spat off teh end then loop
 354+ 725C 7B                                   ld      a,e                         ; stick result in a
 355+ 725D C9                                   ret
 356+ 725E 3E 01        .BothSame:              ld  a,1
 357+ 7260 C9                                   ret
 358+ 7261 3E FF        .DgtA:                  ld  a,255                           ; Fail with FF as result
 359+ 7263 C9                                   ret
 360+ 7264
 361+ 7264              ; Divide 8-bit values
 362+ 7264              ; In: Divide E by divider C
 363+ 7264              ; Out: A = result, B = rest
 364+ 7264              ;
 365+ 7264              ;;;Div8:
 366+ 7264              ;;;    xor a
 367+ 7264              ;;;    ld b,8
 368+ 7264              ;;;Div8_Loop:
 369+ 7264              ;;;    rl e
 370+ 7264              ;;;    rla
 371+ 7264              ;;;    sub c
 372+ 7264              ;;;    jr nc,Div8_NoAdd
 373+ 7264              ;;;    add a,c
 374+ 7264              ;;;Div8_NoAdd:
 375+ 7264              ;;;    djnz Div8_Loop
 376+ 7264              ;;;    ld b,a0
 377+ 7264              ;;;    ld a,e
 378+ 7264              ;;;    rla
 379+ 7264              ;;;    cpl
 380+ 7264              ;;;    ret
 381+ 7264
 382+ 7264              ;;Inputs: DE is the numerator, BC is the divisor
 383+ 7264              ;;Outputs: DE is the result
 384+ 7264              ;;         A is a copy of E
 385+ 7264              ;;         HL is the remainder
 386+ 7264              ;;         BC is not changed
 387+ 7264              ;; so DE = DE /BC
 388+ 7264              ;140 bytes
 389+ 7264              ;145cc
 390+ 7264
 391+ 7264              MacroDEDivBC:       MACRO
 392+ 7264 ~                                rla
 393+ 7264 ~                                adc     hl,hl
 394+ 7264 ~                                sbc     hl,bc
 395+ 7264 ~                                jr      nc,$+3
 396+ 7264 ~                                add     hl,bc
 397+ 7264                                  ENDM
 398+ 7264
 399+ 7264 AF           DEequDEDivBC:       xor a
 400+ 7265 ED 62                            sbc hl,hl
 401+ 7267 7A                               ld a,d
 402+ 7268                                  MacroDEDivBC
 402+ 7268 17          >                    rla
 402+ 7269 ED 6A       >                    adc     hl,hl
 402+ 726B ED 42       >                    sbc     hl,bc
 402+ 726D 30 01       >                    jr      nc,$+3
 402+ 726F 09          >                    add     hl,bc
 403+ 7270                                  MacroDEDivBC
 403+ 7270 17          >                    rla
 403+ 7271 ED 6A       >                    adc     hl,hl
 403+ 7273 ED 42       >                    sbc     hl,bc
 403+ 7275 30 01       >                    jr      nc,$+3
 403+ 7277 09          >                    add     hl,bc
 404+ 7278                                  MacroDEDivBC
 404+ 7278 17          >                    rla
 404+ 7279 ED 6A       >                    adc     hl,hl
 404+ 727B ED 42       >                    sbc     hl,bc
 404+ 727D 30 01       >                    jr      nc,$+3
 404+ 727F 09          >                    add     hl,bc
 405+ 7280                                  MacroDEDivBC
 405+ 7280 17          >                    rla
 405+ 7281 ED 6A       >                    adc     hl,hl
 405+ 7283 ED 42       >                    sbc     hl,bc
 405+ 7285 30 01       >                    jr      nc,$+3
 405+ 7287 09          >                    add     hl,bc
 406+ 7288                                  MacroDEDivBC
 406+ 7288 17          >                    rla
 406+ 7289 ED 6A       >                    adc     hl,hl
 406+ 728B ED 42       >                    sbc     hl,bc
 406+ 728D 30 01       >                    jr      nc,$+3
 406+ 728F 09          >                    add     hl,bc
 407+ 7290                                  MacroDEDivBC
 407+ 7290 17          >                    rla
 407+ 7291 ED 6A       >                    adc     hl,hl
 407+ 7293 ED 42       >                    sbc     hl,bc
 407+ 7295 30 01       >                    jr      nc,$+3
 407+ 7297 09          >                    add     hl,bc
 408+ 7298                                  MacroDEDivBC
 408+ 7298 17          >                    rla
 408+ 7299 ED 6A       >                    adc     hl,hl
 408+ 729B ED 42       >                    sbc     hl,bc
 408+ 729D 30 01       >                    jr      nc,$+3
 408+ 729F 09          >                    add     hl,bc
 409+ 72A0                                  MacroDEDivBC
 409+ 72A0 17          >                    rla
 409+ 72A1 ED 6A       >                    adc     hl,hl
 409+ 72A3 ED 42       >                    sbc     hl,bc
 409+ 72A5 30 01       >                    jr      nc,$+3
 409+ 72A7 09          >                    add     hl,bc
 410+ 72A8 17                               rla
 411+ 72A9 2F                               cpl
 412+ 72AA 57                               ld d,a
 413+ 72AB
 414+ 72AB 7B                               ld a,e
 415+ 72AC                                  MacroDEDivBC
 415+ 72AC 17          >                    rla
 415+ 72AD ED 6A       >                    adc     hl,hl
 415+ 72AF ED 42       >                    sbc     hl,bc
 415+ 72B1 30 01       >                    jr      nc,$+3
 415+ 72B3 09          >                    add     hl,bc
 416+ 72B4                                  MacroDEDivBC
 416+ 72B4 17          >                    rla
 416+ 72B5 ED 6A       >                    adc     hl,hl
 416+ 72B7 ED 42       >                    sbc     hl,bc
 416+ 72B9 30 01       >                    jr      nc,$+3
 416+ 72BB 09          >                    add     hl,bc
 417+ 72BC                                  MacroDEDivBC
 417+ 72BC 17          >                    rla
 417+ 72BD ED 6A       >                    adc     hl,hl
 417+ 72BF ED 42       >                    sbc     hl,bc
 417+ 72C1 30 01       >                    jr      nc,$+3
 417+ 72C3 09          >                    add     hl,bc
 418+ 72C4                                  MacroDEDivBC
 418+ 72C4 17          >                    rla
 418+ 72C5 ED 6A       >                    adc     hl,hl
 418+ 72C7 ED 42       >                    sbc     hl,bc
 418+ 72C9 30 01       >                    jr      nc,$+3
 418+ 72CB 09          >                    add     hl,bc
 419+ 72CC                                  MacroDEDivBC
 419+ 72CC 17          >                    rla
 419+ 72CD ED 6A       >                    adc     hl,hl
 419+ 72CF ED 42       >                    sbc     hl,bc
 419+ 72D1 30 01       >                    jr      nc,$+3
 419+ 72D3 09          >                    add     hl,bc
 420+ 72D4                                  MacroDEDivBC
 420+ 72D4 17          >                    rla
 420+ 72D5 ED 6A       >                    adc     hl,hl
 420+ 72D7 ED 42       >                    sbc     hl,bc
 420+ 72D9 30 01       >                    jr      nc,$+3
 420+ 72DB 09          >                    add     hl,bc
 421+ 72DC                                  MacroDEDivBC
 421+ 72DC 17          >                    rla
 421+ 72DD ED 6A       >                    adc     hl,hl
 421+ 72DF ED 42       >                    sbc     hl,bc
 421+ 72E1 30 01       >                    jr      nc,$+3
 421+ 72E3 09          >                    add     hl,bc
 422+ 72E4                                  MacroDEDivBC
 422+ 72E4 17          >                    rla
 422+ 72E5 ED 6A       >                    adc     hl,hl
 422+ 72E7 ED 42       >                    sbc     hl,bc
 422+ 72E9 30 01       >                    jr      nc,$+3
 422+ 72EB 09          >                    add     hl,bc
 423+ 72EC 17                               rla
 424+ 72ED 2F                               cpl
 425+ 72EE 5F                               ld e,a
 426+ 72EF C9                               ret
 427+ 72F0              ;divdide by 16 using undocumented instrunctions
 428+ 72F0              ;Input: BC = Dividend, DE = Divisor, HL = 0
 429+ 72F0              ;Output: BC = Quotient, HL = Remainder
 430+ 72F0              ; Our use
 431+ 72F0              ; BC = A0
 432+ 72F0              ; DE = 0C
 433+ 72F0              ; so BC = a * 256 / C
 434+ 72F0              DIV16Amul256dCUNDOC:    JumpIfAGTENusng	  c,DEV16ATooLarge                                          ; first off if a > c ten return 255
 434+ 72F0 B9          >                        cp     c
 434+ 72F1 D2 1C 73    >                        jp		nc,DEV16ATooLarge
 435+ 72F4 47                                   ld      b,a
 436+ 72F5 59                                   ld      e,c
 437+ 72F6 0E 00                                ld      c,0
 438+ 72F8 16 00                                ld      d,0
 439+ 72FA C3 07 73                             jp      DIV16UNDOC
 440+ 72FD 47           DIV16Amul256dQUNDOC:    ld      b,a
 441+ 72FE 0E 00                                ld      c,0
 442+ 7300 21 5F 69                             ld      hl,varQ
 443+ 7303 7E                                   ld      a,(hl)
 444+ 7304 16 00                                ld      d,0
 445+ 7306 5F                                   ld      e,a
 446+ 7307              DIV16BCDivDEUNDOC:
 447+ 7307 21 00 00     DIV16UNDOC:             ld      hl,0
 448+ 730A 78                                   ld      a,b
 449+ 730B 06 10                                ld      b,16
 450+ 730D CB 31        DIV16UNDOCLOOP:         sll	c		; unroll 16 times
 451+ 730F 17                                   rla			; ...
 452+ 7310 ED 6A                                adc	hl,hl		; ...
 453+ 7312 ED 52                                sbc	hl,de		; ...
 454+ 7314 30 02                                jr	nc,DIV16UNDOCSKIP		; ...
 455+ 7316 19                                   add	hl,de		; ...
 456+ 7317 0D                                   dec	c		; ...
 457+ 7318 10 F3        DIV16UNDOCSKIP:         djnz DIV16UNDOCLOOP
 458+ 731A 47                                   ld   b,a
 459+ 731B C9                                   ret
 460+ 731C 01 FF 00     DEV16ATooLarge:         ld     bc,$00FF
 461+ 731F C9                                   ret
 462+ 7320              ; switch to logarithm version
 463+ 7320              ; "> asm_div8 C_Div_D - C is the numerator, D is the denominator, A is the remainder, B is 0, C is the result of C/D,D,E,H,L are not changed"
 464+ 7320 06 08        asm_div8:               ld b,8
 465+ 7322 AF                                   xor a
 466+ 7323 CB 21        .div8_loop:	            sla c
 467+ 7325 17                                   rla
 468+ 7326 BA                                   cp d
 469+ 7327 38 02                                jr c,.div8_skip
 469+ 7329
 470+ 7329 0C                                   inc c
 471+ 732A 92                                   sub d
 472+ 732B 10 F6        .div8_skip:	            djnz .div8_loop
 473+ 732D C9                                   ret
 474+ 732E              ; ">asm_div16: HL_Div_C: HL is the numerator,  C is the denominator, output A is the remainder, B is 0, C,DE is not changedHL is the quotient"
 475+ 732E 06 10        asm_div16:              ld b,16
 476+ 7330 AF                                   xor a
 477+ 7331 CB 25        div16_loop:	            sla l
 478+ 7333 CB 14                                rl	h
 479+ 7335              ;    add hl,hl
 480+ 7335 17                                   rla
 481+ 7336 B9                                   cp c
 482+ 7337 38 02                                jr c,div16_skip
 483+ 7339 2C                                   inc l
 484+ 733A 91                                   sub c
 485+ 733B 10 F4        div16_skip:		        djnz div16_loop
 486+ 733D C9                                   ret
 487+ 733E              ;
 488+ 733E              ; Divide 16-bit values (with 16-bit result)
 489+ 733E              ; In: Divide BC by divider DE
 490+ 733E              ; Out: BC = result, HL = rest
 491+ 733E              ;
 492+ 733E              HLDivC_Iteration: 	    MACRO
 493+ 733E ~                                    add	hl,hl		; unroll 16 times
 494+ 733E ~                                    rla				; ...
 495+ 733E ~                                    cp	c			; ...
 496+ 733E ~                                    jr	1F
 497+ 733E ~                                    sub	c			; ...
 498+ 733E ~            1:
 499+ 733E ~                                    inc	l			; ...
 500+ 733E                                      ENDM
 501+ 733E
 502+ 733E              EDivC_Iteration:        MACRO
 503+ 733E ~                                    rl  e
 504+ 733E ~                                    rla
 505+ 733E ~                                    sub c
 506+ 733E ~                                    jr  nc,.Div8_NoAdd
 507+ 733E ~                                    add a,c
 508+ 733E ~            .Div8_NoAdd:
 509+ 733E                                      ENDM
 510+ 733E
 511+ 733E              ; Switch to a logarithm version
 512+ 733E              ; Divide E by divider C Out: A = result, B = rest
 513+ 733E              E_Div_C:                ZeroA
 513+ 733E AF          >                        xor a
 514+ 733F                                      EDivC_Iteration
 514+ 733F CB 13       >                        rl  e
 514+ 7341 17          >                        rla
 514+ 7342 91          >                        sub c
 514+ 7343 30 01       >                        jr  nc,.Div8_NoAdd
 514+ 7345 81          >                        add a,c
 514+ 7346             >.Div8_NoAdd:
 515+ 7346                                      EDivC_Iteration
 515+ 7346 CB 13       >                        rl  e
 515+ 7348 17          >                        rla
 515+ 7349 91          >                        sub c
 515+ 734A 30 01       >                        jr  nc,.Div8_NoAdd
 515+ 734C 81          >                        add a,c
 515+ 734D             >.Div8_NoAdd:
 516+ 734D                                      EDivC_Iteration
 516+ 734D CB 13       >                        rl  e
 516+ 734F 17          >                        rla
 516+ 7350 91          >                        sub c
 516+ 7351 30 01       >                        jr  nc,.Div8_NoAdd
 516+ 7353 81          >                        add a,c
 516+ 7354             >.Div8_NoAdd:
 517+ 7354                                      EDivC_Iteration
 517+ 7354 CB 13       >                        rl  e
 517+ 7356 17          >                        rla
 517+ 7357 91          >                        sub c
 517+ 7358 30 01       >                        jr  nc,.Div8_NoAdd
 517+ 735A 81          >                        add a,c
 517+ 735B             >.Div8_NoAdd:
 518+ 735B                                      EDivC_Iteration
 518+ 735B CB 13       >                        rl  e
 518+ 735D 17          >                        rla
 518+ 735E 91          >                        sub c
 518+ 735F 30 01       >                        jr  nc,.Div8_NoAdd
 518+ 7361 81          >                        add a,c
 518+ 7362             >.Div8_NoAdd:
 519+ 7362                                      EDivC_Iteration
 519+ 7362 CB 13       >                        rl  e
 519+ 7364 17          >                        rla
 519+ 7365 91          >                        sub c
 519+ 7366 30 01       >                        jr  nc,.Div8_NoAdd
 519+ 7368 81          >                        add a,c
 519+ 7369             >.Div8_NoAdd:
 520+ 7369                                      EDivC_Iteration
 520+ 7369 CB 13       >                        rl  e
 520+ 736B 17          >                        rla
 520+ 736C 91          >                        sub c
 520+ 736D 30 01       >                        jr  nc,.Div8_NoAdd
 520+ 736F 81          >                        add a,c
 520+ 7370             >.Div8_NoAdd:
 521+ 7370                                      EDivC_Iteration
 521+ 7370 CB 13       >                        rl  e
 521+ 7372 17          >                        rla
 521+ 7373 91          >                        sub c
 521+ 7374 30 01       >                        jr  nc,.Div8_NoAdd
 521+ 7376 81          >                        add a,c
 521+ 7377             >.Div8_NoAdd:
 522+ 7377 47                                   ld      b,a
 523+ 7378 7B                                   ld      a,e
 524+ 7379 17                                   rla
 525+ 737A 2F                                   cpl
 526+ 737B C9                                   ret
 527+ 737C
 528+ 737C
 529+ 737C              BCDIVDE_Iteration:      MACRO
 530+ 737C ~                                    rla
 531+ 737C ~                                    adc	    hl,hl
 532+ 737C ~                                    add	    hl,de
 533+ 737C ~                                    jr	    c,1F
 534+ 737C ~                                    sbc	    hl,de
 535+ 737C ~            1:
 536+ 737C                                      ENDM
 537+ 737C
 538+ 737C
 539+ 737C              ; ">BC_Div_DE: BC = BC / DE. HL = remainder fast divide with unrolled loop"
 540+ 737C              ;BC/DE ==> BC, remainder in HL
 541+ 737C              ;NOTE: BC/0 returns 0 as the quotient.
 542+ 737C              ;min: 738cc
 543+ 737C              ;max: 898cc
 544+ 737C              ;avg: 818cc
 545+ 737C              ;144 bytes
 546+ 737C AF           BC_Div_DE:              xor a
 547+ 737D 67                                   ld h,a
 548+ 737E 6F                                   ld l,a
 549+ 737F 93                                   sub e
 550+ 7380 5F                                   ld e,a
 551+ 7381 9F                                   sbc a,a
 552+ 7382 92                                   sub d
 553+ 7383 57                                   ld d,a
 554+ 7384 78                                   ld a,b
 555+ 7385                                      BCDIVDE_Iteration
 555+ 7385 17          >                        rla
 555+ 7386 ED 6A       >                        adc	    hl,hl
 555+ 7388 19          >                        add	    hl,de
 555+ 7389 38 02       >                        jr	    c,1F
 555+ 738B ED 52       >                        sbc	    hl,de
 555+ 738D             >1:
 556+ 738D                                      BCDIVDE_Iteration
 556+ 738D 17          >                        rla
 556+ 738E ED 6A       >                        adc	    hl,hl
 556+ 7390 19          >                        add	    hl,de
 556+ 7391 38 02       >                        jr	    c,1F
 556+ 7393 ED 52       >                        sbc	    hl,de
 556+ 7395             >1:
 557+ 7395                                      BCDIVDE_Iteration
 557+ 7395 17          >                        rla
 557+ 7396 ED 6A       >                        adc	    hl,hl
 557+ 7398 19          >                        add	    hl,de
 557+ 7399 38 02       >                        jr	    c,1F
 557+ 739B ED 52       >                        sbc	    hl,de
 557+ 739D             >1:
 558+ 739D                                      BCDIVDE_Iteration
 558+ 739D 17          >                        rla
 558+ 739E ED 6A       >                        adc	    hl,hl
 558+ 73A0 19          >                        add	    hl,de
 558+ 73A1 38 02       >                        jr	    c,1F
 558+ 73A3 ED 52       >                        sbc	    hl,de
 558+ 73A5             >1:
 559+ 73A5                                      BCDIVDE_Iteration
 559+ 73A5 17          >                        rla
 559+ 73A6 ED 6A       >                        adc	    hl,hl
 559+ 73A8 19          >                        add	    hl,de
 559+ 73A9 38 02       >                        jr	    c,1F
 559+ 73AB ED 52       >                        sbc	    hl,de
 559+ 73AD             >1:
 560+ 73AD                                      BCDIVDE_Iteration
 560+ 73AD 17          >                        rla
 560+ 73AE ED 6A       >                        adc	    hl,hl
 560+ 73B0 19          >                        add	    hl,de
 560+ 73B1 38 02       >                        jr	    c,1F
 560+ 73B3 ED 52       >                        sbc	    hl,de
 560+ 73B5             >1:
 561+ 73B5                                      BCDIVDE_Iteration
 561+ 73B5 17          >                        rla
 561+ 73B6 ED 6A       >                        adc	    hl,hl
 561+ 73B8 19          >                        add	    hl,de
 561+ 73B9 38 02       >                        jr	    c,1F
 561+ 73BB ED 52       >                        sbc	    hl,de
 561+ 73BD             >1:
 562+ 73BD                                      BCDIVDE_Iteration
 562+ 73BD 17          >                        rla
 562+ 73BE ED 6A       >                        adc	    hl,hl
 562+ 73C0 19          >                        add	    hl,de
 562+ 73C1 38 02       >                        jr	    c,1F
 562+ 73C3 ED 52       >                        sbc	    hl,de
 562+ 73C5             >1:
 563+ 73C5 17                                   rla
 564+ 73C6 47                                   ld b,a
 565+ 73C7 79                                   ld a,c
 566+ 73C8                                      BCDIVDE_Iteration
 566+ 73C8 17          >                        rla
 566+ 73C9 ED 6A       >                        adc	    hl,hl
 566+ 73CB 19          >                        add	    hl,de
 566+ 73CC 38 02       >                        jr	    c,1F
 566+ 73CE ED 52       >                        sbc	    hl,de
 566+ 73D0             >1:
 567+ 73D0                                      BCDIVDE_Iteration
 567+ 73D0 17          >                        rla
 567+ 73D1 ED 6A       >                        adc	    hl,hl
 567+ 73D3 19          >                        add	    hl,de
 567+ 73D4 38 02       >                        jr	    c,1F
 567+ 73D6 ED 52       >                        sbc	    hl,de
 567+ 73D8             >1:
 568+ 73D8                                      BCDIVDE_Iteration
 568+ 73D8 17          >                        rla
 568+ 73D9 ED 6A       >                        adc	    hl,hl
 568+ 73DB 19          >                        add	    hl,de
 568+ 73DC 38 02       >                        jr	    c,1F
 568+ 73DE ED 52       >                        sbc	    hl,de
 568+ 73E0             >1:
 569+ 73E0                                      BCDIVDE_Iteration
 569+ 73E0 17          >                        rla
 569+ 73E1 ED 6A       >                        adc	    hl,hl
 569+ 73E3 19          >                        add	    hl,de
 569+ 73E4 38 02       >                        jr	    c,1F
 569+ 73E6 ED 52       >                        sbc	    hl,de
 569+ 73E8             >1:
 570+ 73E8                                      BCDIVDE_Iteration
 570+ 73E8 17          >                        rla
 570+ 73E9 ED 6A       >                        adc	    hl,hl
 570+ 73EB 19          >                        add	    hl,de
 570+ 73EC 38 02       >                        jr	    c,1F
 570+ 73EE ED 52       >                        sbc	    hl,de
 570+ 73F0             >1:
 571+ 73F0                                      BCDIVDE_Iteration
 571+ 73F0 17          >                        rla
 571+ 73F1 ED 6A       >                        adc	    hl,hl
 571+ 73F3 19          >                        add	    hl,de
 571+ 73F4 38 02       >                        jr	    c,1F
 571+ 73F6 ED 52       >                        sbc	    hl,de
 571+ 73F8             >1:
 572+ 73F8                                      BCDIVDE_Iteration
 572+ 73F8 17          >                        rla
 572+ 73F9 ED 6A       >                        adc	    hl,hl
 572+ 73FB 19          >                        add	    hl,de
 572+ 73FC 38 02       >                        jr	    c,1F
 572+ 73FE ED 52       >                        sbc	    hl,de
 572+ 7400             >1:
 573+ 7400                                      BCDIVDE_Iteration
 573+ 7400 17          >                        rla
 573+ 7401 ED 6A       >                        adc	    hl,hl
 573+ 7403 19          >                        add	    hl,de
 573+ 7404 38 02       >                        jr	    c,1F
 573+ 7406 ED 52       >                        sbc	    hl,de
 573+ 7408             >1:
 574+ 7408 17                                   rla
 575+ 7409 4F                                   ld c,a
 576+ 740A C9                                   ret
 577+ 740B 78           Floor_DivQSigned:       ld      a,b             ; save resultant sign
 578+ 740C AA                                   xor     d               ;
 579+ 740D E6 80                                and     $80             ;
 580+ 740F DD 67                                ld      ixh,a           ;
 581+ 7411 78                                   ld      a,b
 582+ 7412 E6 7F                                and     $7F
 583+ 7414 47                                   ld      b,a
 584+ 7415 7A                                   ld      a,d
 585+ 7416 E6 7F                                and     $7F
 586+ 7418 57                                   ld      d,a
 587+ 7419 CD 21 74                             call    Floor_DivQ
 588+ 741C 78                                   ld      a,b
 589+ 741D DD B4                                or      ixh
 590+ 741F 47                                   ld      b,a
 591+ 7420 C9                                   ret
 592+ 7421
 593+ 7421
 594+ 7421
 595+ 7421              ; BC = BC / DE
 596+ 7421              ; HL = BC % DE
 597+ 7421              ; if HL > 0 BC -= 1
 598+ 7421 78           Floor_DivQ:             ld      a,b
 599+ 7422 B1                                   or      c
 600+ 7423 28 26                                jr      z, .divide0By   ; if bc is zero just return as result will be zero
 601+ 7425 7A                                   ld      a,d
 602+ 7426 B3                                   or      e
 603+ 7427 28 26                                jr      z, .divideBy0
 604+ 7429 D5                                   push    de
 605+ 742A CD 7C 73     .DoDivide:              call    BC_Div_DE       ; bc(q0) = bc / de , hl(r0) = bc %de
 606+ 742D D1                                   pop     de              ; get divisor back to test
 607+ 742E CB 7A                                bit     7,d             ; if divisor <0 or = 0 goto else branch
 608+ 7430 C2 40 74                             jp      nz,.deLTE0
 609+ 7433 7A                                   ld      a,d
 610+ 7434 B3                                   or      e
 611+ 7435 CA 40 74                             jp      z,.deLTE0
 612+ 7438 CB 7C        .deGT0:                 bit     7,h             ; if remainder >=0 return with no adjustment
 613+ 743A C8                                   ret     z               ; if remainder was not negative then all done
 614+ 743B 0B                                   dec     bc              ; else q --
 615+ 743C                                      ClearCarryFlag          ;      r += b
 615+ 743C B7          >                        or a
 616+ 743D ED 5A                                adc     hl,de           ;      .
 617+ 743F C9                                   ret
 618+ 7440 CB 7C        .deLTE0:                bit     7,h             ; if remainder <= 0 retun with no adjustment
 619+ 7442 C8                                   ret     z               ; (return if negative)
 620+ 7443 7C                                   ld      a,h
 621+ 7444 B5                                   or      l               ; (return if zero)
 622+ 7445 C8                                   ret     z
 623+ 7446 0B                                   dec     bc              ; else q --
 624+ 7447                                      ClearCarryFlag          ;      r += b
 624+ 7447 B7          >                        or a
 625+ 7448 ED 5A                                adc     hl,de           ;      .
 626+ 744A C9                                   ret
 627+ 744B 21 00 00     .divide0By:             ld      hl,0            ; hl = 0, bc is already 0
 628+ 744E C9                                   ret
 629+ 744F 21 00 00     .divideBy0:             ld      hl,0
 630+ 7452 01 01 00                             ld      bc,1
 631+ 7455 C9                                   ret
 632+ 7456
 633+ 7456
 634+ 7456              L_DIV_0_ITERATION:      MACRO
 635+ 7456 ~                                    rl      de              ;left shift dividend + quotient carry
 636+ 7456 ~                                    ex      de,hl
 637+ 7456 ~                                    rl      de              ;left shift remainder + dividend carry
 638+ 7456 ~                                    ex      de,hl
 639+ 7456 ~                                    sub     hl,bc           ;substract divisor from remainder
 640+ 7456 ~                                    jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 641+ 7456 ~                                    add     hl,bc           ;revert subtraction of divisor
 642+ 7456 ~            .skip_revert0:          ccf                     ;complement carry
 643+ 7456 ~                                    rl      de              ;left shift dividend + quotient carry
 644+ 7456 ~                                    ex      de,hl
 645+ 7456 ~                                    rl      de              ;left shift remainder + dividend carry
 646+ 7456 ~                                    ex      de,hl
 647+ 7456 ~                                    sub     hl,bc           ;substract divisor from remainder
 648+ 7456 ~                                    jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 649+ 7456 ~                                    add     hl,bc           ;revert subtraction of divisor
 650+ 7456 ~            .skip_revert1:          ccf                     ;complement carry
 651+ 7456                                      ENDM
 652+ 7456
 653+ 7456              ; HL = DE / BC, DE = DE % BC
 654+ 7456 21 00 00     l_div_0:                ld      hl,0            ;clear remainder
 655+ 7459                                      L_DIV_0_ITERATION
 655+ 7459 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 655+ 745D EB          >                        ex      de,hl
 655+ 745E CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 655+ 7462 EB          >                        ex      de,hl
 655+ 7463 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 655+ 7466 D2 6A 74    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 655+ 7469 09          >                        add     hl,bc           ;revert subtraction of divisor
 655+ 746A 3F          >.skip_revert0:          ccf                     ;complement carry
 655+ 746B CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 655+ 746F EB          >                        ex      de,hl
 655+ 7470 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 655+ 7474 EB          >                        ex      de,hl
 655+ 7475 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 655+ 7478 D2 7C 74    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 655+ 747B 09          >                        add     hl,bc           ;revert subtraction of divisor
 655+ 747C 3F          >.skip_revert1:          ccf                     ;complement carry
 656+ 747D                                      L_DIV_0_ITERATION
 656+ 747D CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 656+ 7481 EB          >                        ex      de,hl
 656+ 7482 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 656+ 7486 EB          >                        ex      de,hl
 656+ 7487 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 656+ 748A D2 8E 74    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 656+ 748D 09          >                        add     hl,bc           ;revert subtraction of divisor
 656+ 748E 3F          >.skip_revert0:          ccf                     ;complement carry
 656+ 748F CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 656+ 7493 EB          >                        ex      de,hl
 656+ 7494 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 656+ 7498 EB          >                        ex      de,hl
 656+ 7499 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 656+ 749C D2 A0 74    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 656+ 749F 09          >                        add     hl,bc           ;revert subtraction of divisor
 656+ 74A0 3F          >.skip_revert1:          ccf                     ;complement carry
 657+ 74A1                                      L_DIV_0_ITERATION
 657+ 74A1 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 657+ 74A5 EB          >                        ex      de,hl
 657+ 74A6 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 657+ 74AA EB          >                        ex      de,hl
 657+ 74AB B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 657+ 74AE D2 B2 74    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 657+ 74B1 09          >                        add     hl,bc           ;revert subtraction of divisor
 657+ 74B2 3F          >.skip_revert0:          ccf                     ;complement carry
 657+ 74B3 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 657+ 74B7 EB          >                        ex      de,hl
 657+ 74B8 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 657+ 74BC EB          >                        ex      de,hl
 657+ 74BD B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 657+ 74C0 D2 C4 74    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 657+ 74C3 09          >                        add     hl,bc           ;revert subtraction of divisor
 657+ 74C4 3F          >.skip_revert1:          ccf                     ;complement carry
 658+ 74C5                                      L_DIV_0_ITERATION
 658+ 74C5 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 658+ 74C9 EB          >                        ex      de,hl
 658+ 74CA CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 658+ 74CE EB          >                        ex      de,hl
 658+ 74CF B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 658+ 74D2 D2 D6 74    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 658+ 74D5 09          >                        add     hl,bc           ;revert subtraction of divisor
 658+ 74D6 3F          >.skip_revert0:          ccf                     ;complement carry
 658+ 74D7 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 658+ 74DB EB          >                        ex      de,hl
 658+ 74DC CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 658+ 74E0 EB          >                        ex      de,hl
 658+ 74E1 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 658+ 74E4 D2 E8 74    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 658+ 74E7 09          >                        add     hl,bc           ;revert subtraction of divisor
 658+ 74E8 3F          >.skip_revert1:          ccf                     ;complement carry
 659+ 74E9                                      L_DIV_0_ITERATION
 659+ 74E9 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 659+ 74ED EB          >                        ex      de,hl
 659+ 74EE CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 659+ 74F2 EB          >                        ex      de,hl
 659+ 74F3 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 659+ 74F6 D2 FA 74    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 659+ 74F9 09          >                        add     hl,bc           ;revert subtraction of divisor
 659+ 74FA 3F          >.skip_revert0:          ccf                     ;complement carry
 659+ 74FB CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 659+ 74FF EB          >                        ex      de,hl
 659+ 7500 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 659+ 7504 EB          >                        ex      de,hl
 659+ 7505 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 659+ 7508 D2 0C 75    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 659+ 750B 09          >                        add     hl,bc           ;revert subtraction of divisor
 659+ 750C 3F          >.skip_revert1:          ccf                     ;complement carry
 660+ 750D                                      L_DIV_0_ITERATION
 660+ 750D CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 660+ 7511 EB          >                        ex      de,hl
 660+ 7512 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 660+ 7516 EB          >                        ex      de,hl
 660+ 7517 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 660+ 751A D2 1E 75    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 660+ 751D 09          >                        add     hl,bc           ;revert subtraction of divisor
 660+ 751E 3F          >.skip_revert0:          ccf                     ;complement carry
 660+ 751F CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 660+ 7523 EB          >                        ex      de,hl
 660+ 7524 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 660+ 7528 EB          >                        ex      de,hl
 660+ 7529 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 660+ 752C D2 30 75    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 660+ 752F 09          >                        add     hl,bc           ;revert subtraction of divisor
 660+ 7530 3F          >.skip_revert1:          ccf                     ;complement carry
 661+ 7531                                      L_DIV_0_ITERATION
 661+ 7531 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 661+ 7535 EB          >                        ex      de,hl
 661+ 7536 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 661+ 753A EB          >                        ex      de,hl
 661+ 753B B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 661+ 753E D2 42 75    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 661+ 7541 09          >                        add     hl,bc           ;revert subtraction of divisor
 661+ 7542 3F          >.skip_revert0:          ccf                     ;complement carry
 661+ 7543 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 661+ 7547 EB          >                        ex      de,hl
 661+ 7548 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 661+ 754C EB          >                        ex      de,hl
 661+ 754D B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 661+ 7550 D2 54 75    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 661+ 7553 09          >                        add     hl,bc           ;revert subtraction of divisor
 661+ 7554 3F          >.skip_revert1:          ccf                     ;complement carry
 662+ 7555                                      L_DIV_0_ITERATION
 662+ 7555 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 662+ 7559 EB          >                        ex      de,hl
 662+ 755A CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 662+ 755E EB          >                        ex      de,hl
 662+ 755F B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 662+ 7562 D2 66 75    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 662+ 7565 09          >                        add     hl,bc           ;revert subtraction of divisor
 662+ 7566 3F          >.skip_revert0:          ccf                     ;complement carry
 662+ 7567 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 662+ 756B EB          >                        ex      de,hl
 662+ 756C CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 662+ 7570 EB          >                        ex      de,hl
 662+ 7571 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 662+ 7574 D2 78 75    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 662+ 7577 09          >                        add     hl,bc           ;revert subtraction of divisor
 662+ 7578 3F          >.skip_revert1:          ccf                     ;complement carry
 663+ 7579 CB 13 CB 12                          rl      de              ;left shift dividend + quotient carry
 664+ 757D EB                                   ex      de,hl           ;dividend<>remainder
 665+ 757E C9                                   ret
 666+ 757F
 667+ 757F
 668+ 757F
 669+ 757F
 670+ 757F 11 FE FF     LLHLdivC:               ld      de,$FFFE                    ; set XY to &FFFE at start, de holds XY
 671+ 7582              .LL130:                 ShiftHLLeft1                        ; RS *= 2
 671+ 7582 CB 25       >			   sla l
 671+ 7584 CB 14       >			   rl  h
 672+ 7586 7C                                   ld      a,h
 673+ 7587 38 04                                jr      c,.LL131                    ; if S overflowed skip Q test and do subtractions
 674+ 7589                                      JumpIfALTNusng c, .LL132            ; if S <  Q = 256/gradient skip subtractions
 674+ 7589 B9          >                        cp      c
 674+ 758A DA 95 75    >                        jp		c, .LL132
 675+ 758D 3F           .LL131:                 ccf                                 ; compliment carry
 676+ 758E 99                                   sbc     a,c                         ; q
 677+ 758F 67                                   ld      h,a                         ; h (s)
 678+ 7590 7D                                   ld      a,l                         ; r
 679+ 7591 DE 00                                sbc     a,0                         ; 0 - so in effect SR - Q*256
 680+ 7593 37                                   scf                                 ; set carry for next rolls
 681+ 7594 3F                                   ccf
 682+ 7595              .LL132:                 RollDELeft1                         ; Rotate de bits left
 682+ 7595 CB 13       >               rl  e
 682+ 7597 CB 12       >               rl  d
 683+ 7599 38 E7                                jr      c,.LL130                    ;
 684+ 759B EB                                   ex      de,hl                       ; hl = result
 685+ 759C C9                                   ret
 686+ 759D
 687+ 759D
 688+ 759D AF           div_hl_c:               xor	a
 689+ 759E 06 10                                ld	b, 16
 690+ 75A0 29           .loop:                  add	hl, hl
 691+ 75A1 17                                   rla
 692+ 75A2 38 03                                jr	c, $+5
 693+ 75A4 B9                                   cp	c
 694+ 75A5 38 02                                jr	c, $+4
 695+ 75A7 91                                   sub	c
 696+ 75A8 2C                                   inc	l
 697+ 75A9 10 F5                                djnz	.loop
 698+ 75AB C9                                   ret
 699+ 75AC              ;l_div, signed division
 700+ 75AC              ; comes in with DE and HL
 701+ 75AC              ; HL = DE / HL, DE = DE % HL
 702+ 75AC 4A           l_div:                  ld      c,d             ;sign of dividend
 703+ 75AD 44                                   ld      b,h             ;sign of divisor
 704+ 75AE C5                                   push    bc              ;save signs
 705+ 75AF 4D                                   ld      c,l             ;divisor to bc
 706+ 75B0 7A                                   ld      a,d
 707+ 75B1 B7                                   or      a
 708+ 75B2 F2 BB 75                             jp      p,.NotDENeg
 709+ 75B5              .DeNegate:              macronegate16de
 709+ 75B5 AF          >					xor 	a
 709+ 75B6 93          >                    sub 	e
 709+ 75B7 5F          >                    ld 		e,a
 709+ 75B8 9F          >                    sbc 	a,a
 709+ 75B9 92          >                    sub 	d
 709+ 75BA 57          >                    ld 		d,a
 710+ 75BB 78           .NotDENeg:              ld      a,b
 711+ 75BC B7                                   or      a
 712+ 75BD F2 C6 75                             jp      p,.NotBCNeg     ; if signs are opposite them flip
 713+ 75C0                                      macronegate16bc
 713+ 75C0 AF          >					xor 	a
 713+ 75C1 91          >                    sub 	c
 713+ 75C2 4F          >                    ld 		c,a
 713+ 75C3 9F          >                    sbc 	a,a
 713+ 75C4 90          >                    sub 	b
 713+ 75C5 47          >                    ld 		b,a
 714+ 75C6 CD 56 74     .NotBCNeg:              call    l_div_0         ;unsigned HL = DE / BC, DE = DE % BC
 715+ 75C9                                      ; C standard requires that the result of division satisfy a = (a/b)*b + a%b emainder takes sign of the dividend
 716+ 75C9 C1                                   pop     bc              ;restore sign info
 717+ 75CA 78                                   ld      a,b
 718+ 75CB A9                                   xor     c               ;quotient, sign of dividend^divisor
 719+ 75CC F2 D5 75                             jp      p,.NotHLNeg
 720+ 75CF                                      macronegate16hl
 720+ 75CF AF          >					xor 	a
 720+ 75D0 95          >					sub 	l
 720+ 75D1 6F          >					ld 		l,a
 720+ 75D2 9F          >					sbc 	a,a
 720+ 75D3 94          >					sub 	h
 720+ 75D4 67          >					ld 		h,a
 721+ 75D5 79           .NotHLNeg:              ld      a,c
 722+ 75D6 B7                                   or      a,a             ;remainder, sign of dividend
 723+ 75D7 F0                                   ret     p
 724+ 75D8                                      macronegate16de
 724+ 75D8 AF          >					xor 	a
 724+ 75D9 93          >                    sub 	e
 724+ 75DA 5F          >                    ld 		e,a
 724+ 75DB 9F          >                    sbc 	a,a
 724+ 75DC 92          >                    sub 	d
 724+ 75DD 57          >                    ld 		d,a
 725+ 75DE C9                                   ret
 726+ 75DF
# file closed: ../../Maths/asm_divide.asm
 631  75DF                  INCLUDE "../../Maths/asm_unitvector.asm"
# file opened: ../../Maths/asm_unitvector.asm
   1+ 75DF              asm_tis2:
   2+ 75DF              ; ">TIS2 A = (A / Q * 96) so A = -96 ---- 96  range "
   3+ 75DF              ; ">DOES NOT DO SIGNED YET"
   4+ 75DF F5           	push af
   5+ 75E0 E6 7F            and SignMask8Bit
   6+ 75E2 57           	ld d,a				;; d = A
   7+ 75E3 3A 5F 69     	ld a,(varQ)
   8+ 75E6 5F           	ld e,a
   9+ 75E7 7A           	ld a,d
  10+ 75E8 BB           	cp e
  11+ 75E9 30 11        	jr nc, .tis2_set96	;; jump if a >= Q
  12+ 75EB 1E 60        	ld e, 96
  13+ 75ED ED 30        	mul				; de = d * 96 (also a * 96 )
  14+ 75EF EB           	ex de,hl
  15+ 75F0 3A 5F 69     	ld a,(varQ)
  16+ 75F3 4F           	ld c,a
  17+ 75F4 CD 2E 73     	call asm_div16
  18+ 75F7 F1           	pop af
  19+ 75F8 E6 80        	and $80
  20+ 75FA B5           	or l
  21+ 75FB C9           	ret
  22+ 75FC              .tis2_set96:
  23+ 75FC F1           	pop af
  24+ 75FD E6 80        	and $80
  25+ 75FF F6 96        	or $96
  26+ 7601 C9           	ret
  27+ 7602
  28+ 7602
  29+ 7602              asm_unit_vector:
  30+ 7602              squareregfx:
  31+ 7602 3A A6 C0     	ld a,(UBnkXScaled)
  32+ 7605 57           	ld d,a
  33+ 7606 5F           	ld e,a
  34+ 7607 ED 30        	mul
  35+ 7609 EB           	ex de,hl
  36+ 760A              squareregfy:
  37+ 760A 3A A8 C0     	ld a, (UBnkYScaled)
  38+ 760D 57           	ld d,a
  39+ 760E 5F           	ld e,a
  40+ 760F ED 30        	mul
  41+ 7611 19           	add hl,de
  42+ 7612              squareregfz:
  43+ 7612 3A AA C0     	ld a, (UBnkZScaled)
  44+ 7615 57           	ld d,a
  45+ 7616 5F           	ld e,a
  46+ 7617 ED 30        	mul
  47+ 7619 19           	add hl,de
  48+ 761A EB           	ex de,hl			; de de to number to root
  49+ 761B              hlequsquareroot:
  50+ 761B CD A5 6F     	call asm_sqrt		; hl = sqrt (fx^2 + fy^2 + fx^2)
  51+ 761E E5           	push hl				; save it for work 3 copies
  52+ 761F E5           	push hl				; save it for work
  53+ 7620 E5           	push hl				; save it for work
  54+ 7621              normfx:
  55+ 7621 3A A6 C0     	ld a,(UBnkXScaled)
  56+ 7624 E1           	pop hl				; get copy #1
  57+ 7625 7D           	ld a,l				; we assume only l had worthwhile data but could spill into h
  58+ 7626 4F           	ld c,a
  59+ 7627 CD DF 75     	call asm_tis2
  60+ 762A 32 A6 C0     	ld (UBnkXScaled),a
  61+ 762D              normfy:
  62+ 762D 3A A8 C0     	ld a,(UBnkYScaled)
  63+ 7630 E1           	pop hl				; get copy #2
  64+ 7631 7D           	ld a,l
  65+ 7632 4F           	ld c,a
  66+ 7633 CD DF 75     	call asm_tis2
  67+ 7636 32 A8 C0     	ld (UBnkYScaled),a
  68+ 7639              normfz:
  69+ 7639 3A AA C0     	ld a,(UBnkZScaled)
  70+ 763C E1           	pop hl				; get copy #2
  71+ 763D 7D           	ld a,l
  72+ 763E 4F           	ld c,a
  73+ 763F CD DF 75     	call asm_tis2
  74+ 7642 32 AA C0     	ld (UBnkZScaled),a
  75+ 7645              asm_unit_vector_end:
  76+ 7645 C9           	ret
  77+ 7646
# file closed: ../../Maths/asm_unitvector.asm
 632  7646                  INCLUDE "../../Maths/compare16.asm"
# file opened: ../../Maths/compare16.asm
   1+ 7646              ; Input:
   2+ 7646              ;       HL = 1st value
   3+ 7646              ;       DE = 2nd value
   4+ 7646              ; Output:
   5+ 7646              ;       CF, ZF = results of comparison:
   6+ 7646              ;
   7+ 7646              ;               CF      ZF      Result
   8+ 7646              ;               -----------------------------------
   9+ 7646              ;               0       0       HL > DE
  10+ 7646              ;               0       1       HL == DE
  11+ 7646              ;               1       0       HL < DE
  12+ 7646              ;               1       1       Impossible
  13+ 7646              ;
  14+ 7646
  15+ 7646
  16+ 7646 E5           CompareBCDESigned:  push    hl
  17+ 7647 A7                               and     a
  18+ 7648 60 69                            ld      hl,bc
  19+ 764A ED 52                            sbc     hl,de
  20+ 764C E1                               pop     hl
  21+ 764D C9                               ret
  22+ 764E
  23+ 764E E5           CompareDEBCSigned:  push    hl
  24+ 764F A7                               and     a
  25+ 7650 62 6B                            ld      hl,de
  26+ 7652 ED 42                            sbc     hl,bc
  27+ 7654 E1                               pop     hl
  28+ 7655 C9                               ret
  29+ 7656
  30+ 7656
  31+ 7656              ;### CMPGTE -> test if A>=B
  32+ 7656              ;### Input      HL=A, DE=B if hl=> de no carry else de > hl and set carry
  33+ 7656 7C           CompareHLDESgn:     ld a,h
  34+ 7657 AA                               xor d
  35+ 7658 FA 62 76                         jp m, .cmpgte2
  36+ 765B ED 52                            sbc hl,de
  37+ 765D 30 09                            jr nc, .cmpgte3
  38+ 765F 19           .cmpgte1            add hl,de
  39+ 7660                                  SetCarryFlag
  39+ 7660 37          >                        scf
  40+ 7661 C9                               ret
  41+ 7662 CB 7A        .cmpgte2            bit 7,d
  42+ 7664 28 05                            jr z,.cmpgte4
  43+ 7666              .cmpgte5:           ClearCarryFlag
  43+ 7666 B7          >                        or a
  44+ 7667 C9                               ret
  45+ 7668 19           .cmpgte3            add hl,de
  46+ 7669                                  ClearCarryFlag
  46+ 7669 B7          >                        or a
  47+ 766A C9                               ret
  48+ 766B              .cmpgte4:           SetCarryFlag
  48+ 766B 37          >                        scf
  49+ 766C C9                               ret
  50+ 766D
  51+ 766D              ; Compares HL and DE sets z flag if same, else nz
  52+ 766D 7C           CompareHLDESame:    ld  a,h
  53+ 766E BA                               cp  d
  54+ 766F C0                               ret nz
  55+ 7670 7D                               ld  a,l
  56+ 7671 BB                               cp  e
  57+ 7672 C9                               ret
  58+ 7673
  59+ 7673
  60+ 7673
  61+ 7673 7C           CompareHLBCSgn:     ld a,h
  62+ 7674 A8                               xor b
  63+ 7675 FA 7E 76                         jp m, .cmpgte2
  64+ 7678 ED 42                            sbc hl,bc
  65+ 767A 30 06                            jr nc, .cmpgte3
  66+ 767C              .cmpgte1            SetCarryFlag
  66+ 767C 37          >                        scf
  67+ 767D C9                               ret
  68+ 767E CB 78        .cmpgte2            bit 7,b
  69+ 7680 28 FA                            jr z,.cmpgte1
  70+ 7682              .cmpgte3            ClearCarryFlag
  70+ 7682 B7          >                        or a
  71+ 7683 C9                               ret
  72+ 7684
  73+ 7684              CompareHLDESigned:
  74+ 7684 E5           compare16HLDE:      push    hl
  75+ 7685 A7                               and     a
  76+ 7686 ED 52                            sbc     hl,de
  77+ 7688 E1                               pop     hl
  78+ 7689 C9                               ret
  79+ 768A              CompareHLBCSigned:
  80+ 768A E5           CompareHLBC:        push    hl
  81+ 768B A7                               and     a
  82+ 768C ED 42                            sbc     hl,bc
  83+ 768E E1                               pop     hl
  84+ 768F C9                               ret
  85+ 7690
  86+ 7690              ; With compare signed we do ABS comparison
  87+ 7690              ; this is used for view ports as we just want to know if its +/- out side of 90 degrees
  88+ 7690
  89+ 7690 E5 D5        compare16HLDEABS:   push    hl,,de
  90+ 7692 7C                               ld      a,h                                     ; Quick pass see of both the same sign
  91+ 7693 E6 7F                            and     SignMask8Bit
  92+ 7695 67                               ld      h,a
  93+ 7696 7A                               ld      a,d                                     ; Quick pass see of both the same sign
  94+ 7697 E6 7F                            and     SignMask8Bit
  95+ 7699 57                               ld      d,a
  96+ 769A A7                               and     a
  97+ 769B ED 52                            sbc     hl,de
  98+ 769D D1 E1                            pop     hl,,de
  99+ 769F C9                               ret
 100+ 76A0
 101+ 76A0
# file closed: ../../Maths/compare16.asm
 633  76A0                  INCLUDE "../../Maths/normalise96.asm"
# file opened: ../../Maths/normalise96.asm
   1+ 76A0              ; a equal a / d * 96
   2+ 76A0              ; Tested and works with signed numbers
   3+ 76A0 DD 7E 01     NormaliseIXVector:      ld		a,(ix+1)			; Vector X high
   4+ 76A3 E6 7F                                and		SignMask8Bit        ; a = abs X high
   5+ 76A5 57                                   ld      d,a                 ; hl = abs X ^ 2
   6+ 76A6 5F                                   ld      e,a                 ; .
   7+ 76A7 ED 30                                mul     de                  ; .
   8+ 76A9 EB                                   ex      de,hl               ; .
   9+ 76AA DD 7E 03                             ld		a,(ix+3)			; vector = Y high
  10+ 76AD E6 7F                                and		SignMask8Bit        ; unsigned
  11+ 76AF 57                                   ld      d,a                 ; de = abs Y ^ 2
  12+ 76B0 5F                                   ld      e,a                 ; .
  13+ 76B1 ED 30                                mul     de                  ; .
  14+ 76B3 19                                   add     hl,de               ; hl = x^2 + y ^2
  15+ 76B4 DD 7E 05                             ld		a,(ix+5)			; vector = Z high
  16+ 76B7 E6 7F                                and		SignMask8Bit        ; unsigned
  17+ 76B9 57                                   ld      d,a                 ; de = abs Z ^ 2
  18+ 76BA 5F                                   ld      e,a                 ; .
  19+ 76BB ED 30                                mul     de                  ; .
  20+ 76BD 19                                   add     hl,de               ; de = x^2 + y ^2 + z ^ 2
  21+ 76BE EB                                   ex      de,hl               ; .
  22+ 76BF CD A5 6F     .n96SQRT:               call	asm_sqrt			; hl = sqrt de
  23+ 76C2 DD 7E 01     .n96NORMX:              ld		a,(ix+1)
  24+ 76C5 55                                   ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  25+ 76C6 CD 00 79                             call	AequAdivDmul96Q8    ; does not use HL so we can retain it
  26+ 76C9 47                                   ld		b,a				    ; Sort out restoring sign bit
  27+ 76CA 0E 00                                ld      c,0                 ; .
  28+ 76CC DD 71 00 DD                          ld		(ix+0),bc           ; .
  28+ 76D0 70 01
  29+ 76D2 DD 7E 03     .n96NORMY:              ld		a,(ix+3)
  30+ 76D5 55                                   ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  31+ 76D6 CD 00 79                             call	AequAdivDmul96Q8	; does not use HL so we can retain it
  32+ 76D9 47                                   ld		b,a				    ; Sort out restoring sign bit
  33+ 76DA 0E 00                                ld      c,0                 ; .
  34+ 76DC DD 71 02 DD                          ld		(ix+2),bc           ; .
  34+ 76E0 70 03
  35+ 76E2 DD 7E 05     .n96NORMZ:              ld		a,(ix+5)
  36+ 76E5 55                                   ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  37+ 76E6 CD 00 79                             call	AequAdivDmul96Q8 	; does not use HL so we can retain it
  38+ 76E9 47                                   ld		b,a				    ; Sort out restoring sign bit
  39+ 76EA 0E 00                                ld      c,0                 ; .
  40+ 76EC DD 71 04 DD                          ld		(ix+4),bc           ; .
  40+ 76F0 70 05
  41+ 76F2 C9                                   ret
  42+ 76F3
  43+ 76F3              ; .NORM	\ -> &3BD6 \ Normalize 3-vector length of XX15
  44+ 76F3 3A A6 C0     normaliseXX1596S7:      ld		a,(XX15VecX)	    ; XX15+0
  45+ 76F6 DD 67                                ld		ixh,a               ; ixh = signed x component
  46+ 76F8 E6 7F                                and		SignMask8Bit        ; a = unsigned version
  47+ 76FA              .n96SQX:	            inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
  47+ 76FA 5F          >			ld	e,a
  47+ 76FB 57          >			ld  d,a
  47+ 76FC ED 30       >			mul
  48+ 76FE 62                                   ld		h,d					; h == varR d = varO e= varA
  49+ 76FF 6B                                   ld		l,e					; l == varQ  															:: so HL = XX15[x]^2
  50+ 7700 3A A7 C0     .n96SQY:                ld		a,(XX15VecY)
  51+ 7703 DD 6F                                ld		ixl,a               ; ixl = signed y componet
  52+ 7705 E6 7F                                and		SignMask8Bit                 ; = abs
  53+ 7707                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2		:: so DE = XX15[y]^2
  53+ 7707 5F          >			ld	e,a
  53+ 7708 57          >			ld  d,a
  53+ 7709 ED 30       >			mul
  54+ 770B 19                                   add		hl,de				; hl = XX15[x]^2 + XX15[y]^2
  55+ 770C 3A A8 C0     .n96SQZ:                ld		a,(XX15VecZ)			; Note comments say \ ZZ15+2  should be \ XX15+2 as per code
  56+ 770F FD 67                                ld		iyh,a               ; iyh = signed
  57+ 7711 E6 7F                                and		SignMask8Bit                 ; unsigned
  58+ 7713                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2		:: so DE = XX15[z]^2
  58+ 7713 5F          >			ld	e,a
  58+ 7714 57          >			ld  d,a
  58+ 7715 ED 30       >			mul
  59+ 7717 19           .n96SQADD:              add		hl,de				; hl = XX15[x]^2 + XX15[y]^2 + XX15[z]^2
  60+ 7718 EB                                   ex		de,hl				; hl => de ready for square root
  61+ 7719 CD A5 6F     .n96SQRT:               call	asm_sqrt			; hl = de = sqrt(XX15[x]^2 + XX15[y]^2 + XX15[z]^2), we just are interested in l which is the new Q
  62+ 771C 3A A6 C0     .n96NORMX:              ld		a,(XX15VecX)
  63+ 771F E6 7F                                and		SignMask8Bit
  64+ 7721 4F                                   ld		c,a
  65+ 7722 55                                   ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  66+ 7723 CD B6 78                             call	AequAdivDmul967Bit	; does not use HL so we can retain it
  67+ 7726 47                                   ld		b,a				    ;++SGN
  68+ 7727 DD 7C                                ld		a,ixh			    ;++SGN
  69+ 7729 E6 80                                and		$80				    ;++SGN
  70+ 772B B0                                   or		b				    ;++SGN
  71+ 772C 32 A6 C0                             ld		(XX15VecX),a
  72+ 772F 3A A7 C0     .n96NORMY:              ld		a,(XX15VecY)
  73+ 7732 E6 7F                                and		SignMask8Bit
  74+ 7734 4F                                   ld		c,a
  75+ 7735 55                                   ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  76+ 7736 CD B6 78                             call	AequAdivDmul967Bit     	; does not use HL so we can retain it
  77+ 7739 47                                   ld		b,a				    ;++SGN
  78+ 773A DD 7D                                ld		a,ixl			    ;++SGN
  79+ 773C E6 80                                and		$80				    ;++SGN
  80+ 773E B0                                   or		b				    ;++SGN
  81+ 773F 32 A7 C0                             ld		(XX15VecY),a
  82+ 7742 3A A8 C0     .n96NORMZ:              ld		a,(XX15VecZ)
  83+ 7745 E6 7F                                and		SignMask8Bit
  84+ 7747 4F                                   ld		c,a
  85+ 7748 55                                   ld		d,l				; Q(i.e. l) => D, later we can just pop into de
  86+ 7749 CD B6 78                             call	AequAdivDmul967Bit;AequAdivDmul96	; does not use HL so we can retain it
  87+ 774C 47                                   ld		b,a				    ;++SGN
  88+ 774D FD 7C                                ld		a,iyh			    ;++SGN
  89+ 774F E6 80                                and		$80				    ;++SGN
  90+ 7751 B0                                   or		b				    ;++SGN
  91+ 7752 32 A8 C0                             ld		(XX15VecZ),a
  92+ 7755 C9                                   ret
  93+ 7756
  94+ 7756              ; Normalise vector
  95+ 7756              ; scale Q = Sqrt (X^2 + Y^2 + Z^2)
  96+ 7756              ; X = X / Q with 96 = 1 , i.e X = X / Q * 3/8
  97+ 7756              ; Y = Y / Q with 96 = 1 , i.e Y = Y / Q * 3/8
  98+ 7756              ; Z = Z / Q with 96 = 1 , i.e Z = Z / Q * 3/8
  99+ 7756
# file closed: ../../Maths/normalise96.asm
 634  7756                  INCLUDE "../../Maths/binary_to_decimal.asm"
# file opened: ../../Maths/binary_to_decimal.asm
   1+ 7756              ;Number in hl to decimal ASCII
   2+ 7756              ;Thanks to z80 Bits
   3+ 7756              ;inputs:	hl = number to ASCII
   4+ 7756              ;example: hl=300 outputs '00300'
   5+ 7756              ;destroys: af, bc, hl, de used
   6+ 7756              DispHLtoDE:
   7+ 7756              ; "DispHL, writes HL to DE address"
   8+ 7756 01 F0 D8     	ld	bc,-10000
   9+ 7759 CD 6F 77     	call	Num1
  10+ 775C 01 18 FC     	ld	bc,-1000
  11+ 775F CD 6F 77     	call	Num1
  12+ 7762 01 9C FF     	ld	bc,-100
  13+ 7765 CD 6F 77     	call	Num1
  14+ 7768 0E F6        	ld	c,-10
  15+ 776A CD 6F 77     	call	Num1
  16+ 776D 0E FF        	ld	c,-1
  17+ 776F              Num1:
  18+ 776F 3E 2F        	ld	a,'0'-1
  19+ 7771              .Num2:
  20+ 7771 3C           	inc	a
  21+ 7772 09           	add	hl,bc
  22+ 7773 38 FC        	jr	c,.Num2
  23+ 7775 ED 42        	sbc	hl,bc
  24+ 7777 12           	ld	(de),a
  25+ 7778 13           	inc	de
  26+ 7779 C9           	ret
  27+ 777A
  28+ 777A              DispAtoDE:
  29+ 777A 26 00        	ld h,0
  30+ 777C 6F           	ld l,a
  31+ 777D C3 56 77     	jp DispHLtoDE
  32+ 7780
  33+ 7780              DispPriceAtoDE:
  34+ 7780 26 00        	ld h,0
  35+ 7782 6F           	ld l,a
  36+ 7783 01 9C FF     	ld	bc,-100
  37+ 7786 CD 96 77     	call	.NumLeadBlank1
  38+ 7789 0E F6        	ld	c,-10
  39+ 778B CD 6F 77     	call	Num1
  40+ 778E 3E 2E        	ld		a,'.'					; we could assume preformat but
  41+ 7790                                  DISPLAY "TODO:  optimise "
  42+ 7790 12           	ld		(de),a					; we can optimse that later TODO
  43+ 7791 13           	inc		de						; with just an inc De
  44+ 7792 0E FF        	ld	c,-1
  45+ 7794 18 D9        	jr		Num1
  46+ 7796              .NumLeadBlank1:
  47+ 7796 3E 2F        	ld	a,'0'-1
  48+ 7798              .NumLeadBlank2:
  49+ 7798 3C           	inc	a
  50+ 7799 09           	add	hl,bc
  51+ 779A 38 FC        	jr	c,.NumLeadBlank2
  52+ 779C FE 30        	cp	'0'
  53+ 779E 20 02        	jr	nz,.DontBlank
  54+ 77A0              .Blank:
  55+ 77A0 3E 20        	ld	a,' '
  56+ 77A2              .DontBlank:
  57+ 77A2 ED 42        	sbc	hl,bc
  58+ 77A4 12           	ld	(de),a
  59+ 77A5 13           	inc	de
  60+ 77A6 C9           	ret
  61+ 77A7
  62+ 77A7              DispQtyAtoDE:
  63+ 77A7 FE 00        	cp	0
  64+ 77A9 28 23        	jr	z,.NoStock
  65+ 77AB 26 00        	ld h,0
  66+ 77AD 6F           	ld l,a
  67+ 77AE 01 9C FF     	ld	bc,-100
  68+ 77B1 CD BD 77     	call	.NumLeadBlank1
  69+ 77B4 0E F6        	ld	c,-10
  70+ 77B6 CD BD 77     	call	.NumLeadBlank1
  71+ 77B9 0E FF        	ld	c,-1
  72+ 77BB 18 B2        	jr		Num1
  73+ 77BD              .NumLeadBlank1:
  74+ 77BD 3E 2F        	ld	a,'0'-1
  75+ 77BF              .NumLeadBlank2:
  76+ 77BF 3C           	inc	a
  77+ 77C0 09           	add	hl,bc
  78+ 77C1 38 FC        	jr	c,.NumLeadBlank2
  79+ 77C3 FE 30        	cp	'0'
  80+ 77C5 20 02        	jr	nz,.DontBlank
  81+ 77C7              .Blank:
  82+ 77C7 3E 20        	ld	a,' '
  83+ 77C9              .DontBlank:
  84+ 77C9 ED 42        	sbc	hl,bc
  85+ 77CB 12           	ld	(de),a
  86+ 77CC 13           	inc	de
  87+ 77CD C9           	ret
  88+ 77CE              .NoStock:
  89+ 77CE 3E 20        	ld	a,' '
  90+ 77D0 12           	ld	(de),a
  91+ 77D1 13           	inc	de
  92+ 77D2 12           	ld	(de),a
  93+ 77D3 13           	inc	de
  94+ 77D4 3E 2D        	ld	a,'-'
  95+ 77D6 12           	ld	(de),a
  96+ 77D7 13           	inc de
  97+ 77D8 C9           	ret
  98+ 77D9
  99+ 77D9
 100+ 77D9              ;### CLCN32 -> Converts 32Bit-Value in ASCII-String (terminated by 0)
 101+ 77D9              ;### Input      DE,IX=32bit value, IY=destination address
 102+ 77D9              ;### Output     IY=last char in destination string
 103+ 77D9              ;### Destroyed AF,BC,DE,HL,IX
 104+ 77D9 01 00 00 00  clcn32t dw 1,0,     10,0,     100,0,     1000,0,       10000,0
 104+ 77DD 0A 00 00 00
 104+ 77E1 64 00 00 00
 104+ 77E5 E8 03 00 00
 104+ 77E9 10 27 00 00
 105+ 77ED A0 86 01 00          dw $86a0,1, $4240,$0f, $9680,$98, $e100,$05f5, $ca00,$3b9a
 105+ 77F1 40 42 0F 00
 105+ 77F5 80 96 98 00
 105+ 77F9 00 E1 F5 05
 105+ 77FD 00 CA 9A 3B
 106+ 7801 00 00 00 00  clcn32z ds 4
 107+ 7805
 108+ 7805              ; As per display but shifts final digit by 1 and puts in "." for 1 decimal place
 109+ 7805 CD 14 78     DispDEIXtoIY1DP:        call    DispDEIXtoIY
 110+ 7808 FD 7E 00                             ld      a,(IY+0)
 111+ 780B FD 77 01                             ld      (IY+1),a
 112+ 780E 3E 2E                                ld      a,"."
 113+ 7810 FD 77 00                             ld      (IY+0),a
 114+ 7813 C9                                   ret
 115+ 7814
 116+ 7814 DD 22 01 78  DispDEIXtoIY:           ld (clcn32z),ix
 117+ 7818 ED 53 03 78                          ld (clcn32z+2),de
 118+ 781C DD 21 FD 77                          ld ix,clcn32t+36
 119+ 7820 06 09                                ld b,9
 120+ 7822 0E 00                                ld c,0
 121+ 7824 3E 30        .clcn321:               ld a,'0'
 122+ 7826 B7                                   or a
 123+ 7827 DD 5E 00     .clcn322:               ld e,(ix+0)
 124+ 782A DD 56 01                             ld d,(ix+1)
 125+ 782D 2A 01 78                             ld hl,(clcn32z)
 126+ 7830 ED 52                                sbc hl,de
 127+ 7832 22 01 78                             ld (clcn32z),hl
 128+ 7835 DD 5E 02                             ld e,(ix+2)
 129+ 7838 DD 56 03                             ld d,(ix+3)
 130+ 783B 2A 03 78                             ld hl,(clcn32z+2)
 131+ 783E ED 52                                sbc hl,de
 132+ 7840 22 03 78                             ld (clcn32z+2),hl
 133+ 7843 38 04                                jr c,.clcn325
 134+ 7845 0C                                   inc c
 135+ 7846 3C                                   inc a
 136+ 7847 18 DE                                jr .clcn322
 137+ 7849 DD 5E 00     .clcn325:               ld e,(ix+0)
 138+ 784C DD 56 01                             ld d,(ix+1)
 139+ 784F 2A 01 78                             ld hl,(clcn32z)
 140+ 7852 19                                   add hl,de
 141+ 7853 22 01 78                             ld (clcn32z),hl
 142+ 7856 DD 5E 02                             ld e,(ix+2)
 143+ 7859 DD 56 03                             ld d,(ix+3)
 144+ 785C 2A 03 78                             ld hl,(clcn32z+2)
 145+ 785F ED 5A                                adc hl,de
 146+ 7861 22 03 78                             ld (clcn32z+2),hl
 147+ 7864 11 FC FF                             ld de,-4
 148+ 7867 DD 19                                add ix,de
 149+ 7869 0C                                   inc c
 150+ 786A 0D                                   dec c
 151+ 786B 28 05                                jr z,.clcn323
 152+ 786D FD 77 00                             ld (iy+0),a
 153+ 7870 FD 23                                inc iy
 154+ 7872 10 B0        .clcn323:               djnz .clcn321
 155+ 7874 3A 01 78                             ld a,(clcn32z)
 156+ 7877 C6 30                                add A,'0'
 157+ 7879 FD 77 00                             ld (iy+0),a
 158+ 787C FD 36 01 00                          ld (iy+1),0
 159+ 7880 C9                                   ret
 160+ 7881
# file closed: ../../Maths/binary_to_decimal.asm
 635  7881                  INCLUDE "../../Maths/Utilities/AequAdivQmul96-TIS2.asm" ; AequAdivDmul96
# file opened: ../../Maths/Utilities/AequAdivQmul96-TIS2.asm
   1+ 7881              AequAdivQmul96ABS:      JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
   1+ 7881 BA          >                        cp     d
   1+ 7882 D2 9D 78    >                        jp		nc,.TIS2AccGTEQ
   2+ 7885 06 FE                                ld			b,$FE						; division roll (replaced varT)
   3+ 7887 CB 27        .TIS2RollTLoop:			sla			a
   4+ 7889                                      JumpIfALTNusng d,.TIS2SkipSub           ; a < d so don;t subtract
   4+ 7889 BA          >                        cp      d
   4+ 788A DA A0 78    >                        jp		c, .TIS2SkipSub
   5+ 788D 9A                                   sbc			a,d							; do subtraction with carry
   6+ 788E 37                                   scf
   7+ 788F CB 10                                rl			b							; T rolled left to push bit out the end
   8+ 7891 38 F4                                jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
   9+ 7893 78           .TIS2SKIPCont:	        ld			a,b							; T
  10+ 7894 CB 3F                                srl			a							; result / 2
  11+ 7896 CB 3F                                srl			a							; result / 4
  12+ 7898 47                                   ld			b,a							; t = t /4
  13+ 7899 CB 3F                                srl			a							; result / 8
  14+ 789B 80                                   add			a,b							; result /8 + result /4
  15+ 789C C9                                   ret
  16+ 789D 3E 60        .TIS2AccGTEQ:           ld			a,$60							; unity
  17+ 789F C9                                   ret
  18+ 78A0 B7           .TIS2SkipSub:           or			a
  19+ 78A1 CB 10                                rl			b							; T rolled left to push bit out the end
  20+ 78A3 38 E2                                jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
  21+ 78A5 C3 93 78                             jp			.TIS2SKIPCont
  22+ 78A8
  23+ 78A8
  24+ 78A8              ; USES 			A DE BC
  25+ 78A8              ; DOES NOT USE 	HL
  26+ 78A8              TIS2962C:		; two's compliment entry point, exits not 2's compliment
  27+ 78A8 CB 7F        	bit			        7,a
  28+ 78AA 28 04        	jr			        z,AequAdivQmul96
  29+ 78AC ED 44        	neg			        							; revers 2s'c and just set neg bit
  30+ 78AE CB FF        	set			        7,a
  31+ 78B0              ; Note negative numbers are bit 7 set not 2's compliment
  32+ 78B0              AequAdivQmul96:								; TIS296:			; .tis2 A = A /Q *96 (or A = A * 3/8 * Q) Reduce Acc in NORM routine i.e. *96/Q clamps at +- 96
  33+ 78B0              TIS2:
  34+ 78B0 4F                                   ld			c,a							; copy of Acc
  35+ 78B1 3A 5F 69                             ld			a,(varQ)
  36+ 78B4 57                                   ld			d,a							; d = varQ
  37+ 78B5 79                                   ld			a,c							; recover a
  38+ 78B6 4F           AequAdivDmul967Bit:     ld          c,a
  39+ 78B7 7A                                   ld          a,d
  40+ 78B8 CB 27                                sla         a       ; wipe sign bit
  41+ 78BA C8                                   ret         z       ; quick exit if dividing 0 as a will have the result of 0
  42+ 78BB 30 10                                jr          nc, .OKToDivide
  43+ 78BD B7           .ScaleDown:             or          a       ; clear carry bit
  44+ 78BE CB 3A                                srl         d       ; d >> 1 to get back to 7 bit value
  45+ 78C0 79                                   ld          a,c
  46+ 78C1 E6 7F                                and         SignMask8Bit
  47+ 78C3 CB 3F                                srl         a
  48+ 78C5 47                                   ld          b,a
  49+ 78C6 79                                   ld          a,c
  50+ 78C7 E6 80                                and         $80
  51+ 78C9 B0                                   or          b
  52+ 78CA C3 CE 78                             jp          AequAdivDmul96
  53+ 78CD 79           .OKToDivide:            ld          a,c
  54+ 78CE 4F           AequAdivDmul96:         ld			c,a							; copy of Acc as we need the sign, alternate entry point assuming D preloaded, wastes an "ld c,a" but simplifies code
  55+ 78CF E6 7F                                and			SignMask8Bit				; ignore sign
  56+ 78D1                                      JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
  56+ 78D1 BA          >                        cp     d
  56+ 78D2 D2 F2 78    >                        jp		nc,.TIS2AccGTEQ
  57+ 78D5 06 FE                                ld			b,$FE						; division roll (replaced varT)
  58+ 78D7              .TIS2RollTLoop:									; .TIL2	; roll T
  59+ 78D7 CB 27                                sla			a
  60+ 78D9                                      JumpIfALTNusng d,.TIS2SkipSub           ; a < d so don;t subtract
  60+ 78D9 BA          >                        cp      d
  60+ 78DA DA F8 78    >                        jp		c, .TIS2SkipSub
  61+ 78DD 9A                                   sbc			a,d							; do subtraction with carry
  62+ 78DE 37                                   scf                                     ; set carrry to roll into b
  63+ 78DF CB 10                                rl			b							; T rolled left to push bit out the end
  64+ 78E1 38 F4                                jr			c,.TIS2RollTLoop			; if we still have not hit the empty marker continue
  65+ 78E3 78           .TIS2SKIPCont:	        ld			a,b							; A = T = 4 / 4
  66+ 78E4 CB 3F                                srl			a							; .
  67+ 78E6 CB 3F                                srl			a							; .
  68+ 78E8 47                                   ld			b,a							; .
  69+ 78E9 CB 3F                                srl			a							; A = A / 2 (i.e. T /8)
  70+ 78EB 80                                   add			a,b							; A = T/8 + T/4 (3T/8)
  71+ 78EC 47                                   ld			b,a							; b = 3/8*Acc (max = 96)
  72+ 78ED 79                                   ld			a,c							; copy of Acc to look at sign bit
  73+ 78EE E6 80                                and			$80							; recover sign only
  74+ 78F0 B0                                   or			b							; now put b back in so we have a leading sign bit (note not 2's compliment)
  75+ 78F1 C9                                   ret
  76+ 78F2              ;TI4:										;\ clean to +/- unity
  77+ 78F2 79           .TIS2AccGTEQ:           ld			a,c
  78+ 78F3 E6 80                                and			$80							; copy of Acc
  79+ 78F5 F6 60                                or			$60							; unity
  80+ 78F7 C9                                   ret
  81+ 78F8              .TIS2SkipSub:           ClearCarryFlag                          ; Clear carry as it needs to be empty to roll in 0
  81+ 78F8 B7          >                        or a
  82+ 78F9 CB 10                                rl			b							; T rolled left to push bit out the end
  83+ 78FB 38 DA                                jr			c,.TIS2RollTLoop			; if we still have not hit the empty marker continue
  84+ 78FD C3 E3 78                             jp			.TIS2SKIPCont
  85+ 7900
  86+ 7900
  87+ 7900
  88+ 7900              ; as per AequAdivDmul967Bit but Q is an 8 bit unsigned
  89+ 7900              ; a = a(S7)/Q(8u)*96
  90+ 7900 4F           AequAdivDmul96Q8:       ld          c,a                         ; c = a
  91+ 7901 7A           .CheckDivide0:          ld          a,d                         ; check if its a / 0
  92+ 7902 A7                                   and         a                           ; .
  93+ 7903 CA 2A 79                             jp          z,.TIS2AccGTEQ              ; .
  94+ 7906 79           .NotDivide0:            ld          a,c                         ; get back value of A
  95+ 7907 E6 7F                                and         SignMask8Bit                ; and make it abs, so a = abs(a) c = original a
  96+ 7909                                      JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
  96+ 7909 BA          >                        cp     d
  96+ 790A D2 2A 79    >                        jp		nc,.TIS2AccGTEQ
  97+ 790D 06 FE                                ld			b,$FE						; division roll (replaced varT)
  98+ 790F              .TIS2RollTLoop:									; .TIL2	; roll T
  99+ 790F CB 27                                sla			a
 100+ 7911                                      JumpIfALTNusng d,.TIS2SkipSub           ; a < d so don;t subtract
 100+ 7911 BA          >                        cp      d
 100+ 7912 DA 30 79    >                        jp		c, .TIS2SkipSub
 101+ 7915 9A                                   sbc			a,d							; do subtraction with carry
 102+ 7916 37                                   scf                                     ; set carrry to roll into b
 103+ 7917 CB 10                                rl			b							; T rolled left to push bit out the end
 104+ 7919 38 F4                                jr			c,.TIS2RollTLoop			; if we still have not hit the empty marker continue
 105+ 791B 78           .TIS2SKIPCont:	        ld			a,b							; A = T = 4 / 4
 106+ 791C CB 3F                                srl			a							; .
 107+ 791E CB 3F                                srl			a							; .
 108+ 7920 47                                   ld			b,a							; .
 109+ 7921 CB 3F                                srl			a							; A = A / 2 (i.e. T /8)
 110+ 7923 80                                   add			a,b							; A = T/8 + T/4 (3T/8)
 111+ 7924 47                                   ld			b,a							; b = 3/8*Acc (max = 96)
 112+ 7925 79                                   ld			a,c							; copy of Acc to look at sign bit
 113+ 7926 E6 80                                and			SignOnly8Bit    			; recover sign only
 114+ 7928 B0                                   or			b							; now put b back in so we have a leading sign bit (note not 2's compliment)
 115+ 7929 C9                                   ret
 116+ 792A              ;TI4:										;\ clean to +/- unity
 117+ 792A 79           .TIS2AccGTEQ:           ld			a,c
 118+ 792B E6 80                                and			$80							; copy of Acc
 119+ 792D F6 60                                or			$60							; unity
 120+ 792F C9                                   ret
 121+ 7930              .TIS2SkipSub:           ClearCarryFlag                          ; Clear carry as it needs to be empty to roll in 0
 121+ 7930 B7          >                        or a
 122+ 7931 CB 10                                rl			b							; T rolled left to push bit out the end
 123+ 7933 38 DA                                jr			c,.TIS2RollTLoop			; if we still have not hit the empty marker continue
 124+ 7935 C3 1B 79                             jp			.TIS2SKIPCont
 125+ 7938
 126+ 7938
# file closed: ../../Maths/Utilities/AequAdivQmul96-TIS2.asm
 636  7938                  INCLUDE "../../Maths/Utilities/AequAmulQdiv256-FMLTU.asm"
# file opened: ../../Maths/Utilities/AequAmulQdiv256-FMLTU.asm
   1+ 7938              ; "ASM_FMUTKL .FMLTU	\ -> &2847  \ A=A*Q/256unsg  Fast multiply"
   2+ 7938              fmltu:
   3+ 7938 57           AequAmulQdiv256:        ld	d,a
   4+ 7939 3A 5F 69                             ld	a,(varQ)
   5+ 793C 5F                                   ld	e,a
   6+ 793D ED 30                                mul
   7+ 793F 7A                                   ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
   8+ 7940 C9                                   ret
   9+ 7941
  10+ 7941 5F           AequAmulDdiv256:        ld  e,a
  11+ 7942 ED 30                                mul
  12+ 7944 7A                                   ld  a,d
  13+ 7945 C9                                   ret
  14+ 7946
# file closed: ../../Maths/Utilities/AequAmulQdiv256-FMLTU.asm
 637  7946                  ;INCLUDE "../../Maths/Utilities/PRequSpeedDivZZdiv8-DV42-DV42IYH.asm"
 638  7946                  INCLUDE "../../Maths/Utilities/APequQmulA-MULT1.asm"
# file opened: ../../Maths/Utilities/APequQmulA-MULT1.asm
   1+ 7946              APequQmulA:
   2+ 7946              asm_mult1:
   3+ 7946              ; "ASM_MULT1 (DE) A(hi).P(lo) = Q * A first part of MAD, multiply and add. Visited Quite often. A=hi P = lo also returns result in DE"
   4+ 7946 FE 00        	cp	0
   5+ 7948 28 1F        	jr	z,.mul0			; quick exit if its Q * 0
   6+ 794A 5F           	ld	e,a
   7+ 794B 3A 5F 69     	ld	a,(varQ)
   8+ 794E 57           	ld	d,a
   9+ 794F FE 00        	cp	0				; compare a
  10+ 7951 28 16        	jr	z,.mul0			; quick exit if its 0 * a
  11+ 7953 AB           	xor	e				; -- = + +- = - -+ = - ++ = +
  12+ 7954 E6 80        	and $80				; get the resultant sign and save into b
  13+ 7956 47           	ld	b,a
  14+ 7957 7A           	ld	a,d
  15+ 7958 E6 7F        	and	SignMask8Bit	; now strip off sign bits
  16+ 795A 57           	ld	d,a
  17+ 795B 7B           	ld	a,e
  18+ 795C E6 7F        	and SignMask8Bit
  19+ 795E 5F           	ld	e,a
  20+ 795F ED 30        	mul					; zxn de = d * e
  21+ 7961 7B           	ld	a,e
  22+ 7962 32 5F 68     	ld	(varP),a		; p = lo
  23+ 7965 7A           	ld	a,d				; a = hi
  24+ 7966 B0           	or	b				; de goes to a and varP also re-do sign bit
  25+ 7967 57           	ld	d,a				; we will work with de having result as we may bin vars later
  26+ 7968 C9           	ret
  27+ 7969              .mul0:
  28+ 7969 AF           	xor	a
  29+ 796A 32 5F 68     	ld	(varP),a
  30+ 796D 57           	ld	d,a
  31+ 796E 5F           	ld  e,a
  32+ 796F C9           	ret
  33+ 7970
# file closed: ../../Maths/Utilities/APequQmulA-MULT1.asm
 639  7970                  INCLUDE "../../Maths/Utilities/badd_ll38.asm"
# file opened: ../../Maths/Utilities/badd_ll38.asm
   1+ 7970              baddll38:				;.LL38	\ -> &4812 \ BADD(S)A=R+Q(SA) \ byte add (subtract)   (Sign S)A = R + Q*(Sign from A^S)
   2+ 7970              SAEquSRPlusAQ:
   3+ 7970              ; Calculate the following between sign-magnitude numbers:
   4+ 7970              ;   (S A) = (S R) + (A Q)
   5+ 7970              ; where the sign bytes only contain the sign bits, not magnitudes.
   6+ 7970              ; note goes wrong at <-127 >128 so need 16 bit version
   7+ 7970              ; so need to fix the issue with carry flag not returning a fault correctly
   8+ 7970              LL38:
   9+ 7970              ;	ld		d,a
  10+ 7970              ;	ld		a,(varQ)
  11+ 7970              ;	ld		e,a
  12+ 7970              ;	ld		a,(varS)
  13+ 7970              ;	ld		h,a
  14+ 7970              ;	ld		a,(varR)
  15+ 7970              ;	ld		l,a
  16+ 7970              ;	call	ADDHLDESignedv3
  17+ 7970              ;	ld		a,h
  18+ 7970              ;	ld		(varS),a
  19+ 7970              ;	ld		a,l
  20+ 7970              ;	ret
  21+ 7970              ; calculation table
  22+ 7970              ;   R     Q    Op            Sign calc
  23+ 7970              ;	10    5    Add           +    sign same add R sign
  24+ 7970              ;   -10   5    ABS Sub       -    sign diff ABS R > S sub R sign
  25+ 7970              ;   10   -5    ABS sub       +    sign diff ABS R > S sub R sign
  26+ 7970              ;	-10  -5    ABS Add       -    sign same add R sign
  27+ 7970              ;   5    10    Add           +    sign same add R sign
  28+ 7970              ;   -5   10    Swap ABS SUB  +    sign diff ABS Q > R swap SUB Q sign
  29+ 7970              ;   5    -10   swap ABS Sub  -    sign diff ABS Q > R swap SUB R sign
  30+ 7970              ;   -5   -10   ABS  add      -    sign same add R sign
  31+ 7970
  32+ 7970              ;   -10   5    ABS Sub       -    sign diff ABS R > S sub R sign
  33+ 7970              ;   10   -5    ABS sub       +    sign diff ABS R > S sub R sign
  34+ 7970              ;   -5   10    Swap ABS SUB  +    sign diff ABS Q > R swap SUB Q sign
  35+ 7970              ;   5    -10   swap ABS Sub  -    sign diff ABS Q > R swap SUB R sign
  36+ 7970
  37+ 7970
  38+ 7970              ; Calculate sign for Q from A and varS
  39+ 7970 21 61 69     	ld		hl,varS							;
  40+ 7973 AE           	xor		(hl)							;  EOR &83		\ S	\ sign of operator is A xor S
  41+ 7974 FA 7F 79     	jp		m,.LL39Subtraction  			; if signs are different then we have subtraction
  42+ 7977 3A 5F 69     	ld		a,(varQ)						; Q	\ else addition, S already correct
  43+ 797A 21 60 69     	ld		hl,varR
  44+ 797D 86           	add		a,(hl)							; a = Q + R
  45+ 797E C9           	ret										; Done carry set if overflow
  46+ 797F              .LL39Subtraction:							; 1 byte subtraction (S)A = R-Q
  47+ 797F 3A 60 69     	ld		a,(varR)						; a = R
  48+ 7982 21 5F 69     	ld		hl,varQ                         ; Q
  49+ 7985              ;--	JumpIfALTMemHLusng LL39SwapSubtraction	; if a < (hl) then do LL39SwapSubtraction
  50+ 7985              	ClearCarryFlag                          ; we need to not use carry (6502 is different that it uses the compliement)
  50+ 7985 B7          >                        or a
  51+ 7986 9E           	sbc		a,(hl)							; A = R - Q which as R >= Q will always be a positive result
  52+ 7987 38 01            jr      c,.LL39SignCorrection
  53+ 7989              ;--    jr      a,.LL39ResultZero
  54+ 7989              ;--   JumpIfNegative LL39SignCorrection		; if there was underflow we have to correct sign
  55+ 7989              ;--	or		a								; Clear carry flag to say result is correct
  56+ 7989 C9           	ret
  57+ 798A              .LL39SignCorrection:
  58+ 798A FE 00            cp      0                               ; if its 0 then neg will affect flag so we just zero result to save compute
  59+ 798C 28 0E            jr      z,.LL39ResultZero
  60+ 798E ED 44            neg                                     ; flip A 2'c value to positive
  61+ 7990 08           	ex		af,af'							; save A temporarily
  62+ 7991 3A 61 69     	ld		a,(varS)						; Flip Sign bit in varS
  63+ 7994 EE 80        	xor		$80							    ;
  64+ 7996 32 61 69     	ld		(varS),a                        ; flip sign bit of a
  65+ 7999 08           	ex		af,af'                          ; get back a which is the result
  66+ 799A                  ClearCarryFlag                          ; clear carry as NEG instrunction sets it for non zero
  66+ 799A B7          >                        or a
  67+ 799B C9           	ret
  68+ 799C              .LL39ResultZero:
  69+ 799C 32 61 69         ld      (varS),a                        ; a is zero at this stage so set sign as well
  70+ 799F                  ClearCarryFlag                          ; clear carry
  70+ 799F B7          >                        or a
  71+ 79A0 C9               ret
  72+ 79A1              ;--LL39SwapSubtraction:
  73+ 79A1              ;--	push	bc
  74+ 79A1              ;--	ld		b,a
  75+ 79A1              ;--	ld		a,(hl)
  76+ 79A1              ;--	sub		b
  77+ 79A1              ;--	pop		bc
  78+ 79A1              ;--	ex		af,af'							; do we flip here or negate. i think its flip as its overflowed unsigned
  79+ 79A1              ;--	ld		a,(varS)
  80+ 79A1              ;--	xor		$80
  81+ 79A1              ;--	ld		(varS),a
  82+ 79A1              ;--	ex		af,af'
  83+ 79A1              ;--	ret
  84+ 79A1
  85+ 79A1              ;;;;	baddll38:				;.LL38	\ -> &4812 \ BADD(S)A=R+Q(SA) \ byte add (subtract)   (Sign S)A = R + Q*(Sign from A^S)
  86+ 79A1              ;;;;; Calculate the following between sign-magnitude numbers:
  87+ 79A1              ;;;;;   (S A) = (S R) + (A Q)
  88+ 79A1              ;;;;; where the sign bytes only contain the sign bits, not magnitudes.
  89+ 79A1              ;;;;; note goes wrong at <-127 >128 so need 16 bit version
  90+ 79A1              ;;;;LL38:
  91+ 79A1              ;;;;; Calculate sign for Q from A and varS
  92+ 79A1              ;;;;	ld		hl,varS							;
  93+ 79A1              ;;;;	xor		(hl)							;  EOR &83		\ S	\ sign of operator is A xor S
  94+ 79A1              ;;;;	jp		m,.LL39Subtraction  			; if signs are different then we have subtraction
  95+ 79A1              ;;;;	ld		a,(varQ)						; Q	\ else addition, S already correct
  96+ 79A1              ;;;;	ld		hl,varR
  97+ 79A1              ;;;;	add		a,(hl)							; a = Q + R
  98+ 79A1              ;;;;	ret										; Done
  99+ 79A1              ;;;;.LL39Subtraction:							; 1 byte subtraction (S)A = R-Q
 100+ 79A1              ;;;;	ld		hl,varQ                         ;
 101+ 79A1              ;;;;	ld		a,(hl)
 102+ 79A1              ;;;;	JumpIfAGTENusng 128,LL39Sub16bit		; does this need to be 16 bit
 103+ 79A1              ;;;;	ld		a,(varR)						;
 104+ 79A1              ;;;;	ClearCarryFlag                          ; we need to not use carry (6502 is different that it uses the compliement)
 105+ 79A1              ;;;;	sbc		a,(hl)							; A = R - Q
 106+ 79A1              ;;;;	jr		c,.SignCorrection				; if there was underflow we have to correct sign
 107+ 79A1              ;;;;	or		a								; Clear carry flag to say result is correct
 108+ 79A1              ;;;;	ret
 109+ 79A1              ;;;;.SignCorrection:
 110+ 79A1              ;;;;    neg                                     ; flip A 2'c value to positive
 111+ 79A1              ;;;;	ex		af,af'							; save A temporarily
 112+ 79A1              ;;;;	ld		a,(varS)						; Flip Sign bit in varS
 113+ 79A1              ;;;;	xor		$80							    ;
 114+ 79A1              ;;;;	ld		(varS),a                        ; flip sign bit of a
 115+ 79A1              ;;;;	ex		af,af'                          ; get back a which is the result
 116+ 79A1              ;;;;	ret
 117+ 79A1              ;;;;LL39Sub16Bit:
 118+ 79A1              ;;;;	ld		e,a
 119+ 79A1              ;;;;	ld		d,0
 120+ 79A1              ;;;;	ld		a,(varR)
 121+ 79A1              ;;;;	ld		l,a
 122+ 79A1              ;;;;	ld		h,0
 123+ 79A1              ;;;;	ClearCarryFlag
 124+ 79A1              ;;;;	sbc		hl,de
 125+ 79A1              ;;;;	jr		c,.SignCorrection16bit
 126+ 79A1              ;;;;	bit		7,h
 127+ 79A1              ;;;;	jr		z,.GoodToReturn
 128+ 79A1              ;;;;.Needtonegate:
 129+ 79A1              ;;;;	macronegate16hl
 130+ 79A1              ;;;;.GoodToReturn
 131+ 79A1              ;;;;	ld		a,l
 132+ 79A1              ;;;;	or		a
 133+ 79A1              ;;;;	ret
 134+ 79A1              ;;;;.SignCorrection16bit:
 135+ 79A1              ;;;;	macronegate16hl
 136+ 79A1              ;;;;	ld		a,(varS)						; Flip Sign bit in varS
 137+ 79A1              ;;;;	xor		$80							    ;
 138+ 79A1              ;;;;	ld		(varS),a                        ; flip sign bit of a
 139+ 79A1              ;;;;	ld		a,l
 140+ 79A1              ;;;;	ret
 141+ 79A1
 142+ 79A1
# file closed: ../../Maths/Utilities/badd_ll38.asm
 640  79A1                  INCLUDE "../../Maths/Utilities/RequAmul256divQ-BFRDIV.asm"
# file opened: ../../Maths/Utilities/RequAmul256divQ-BFRDIV.asm
   1+ 79A1              ;;;LL28:
   2+ 79A1              ;;;    ld      c,a                         ;
   3+ 79A1              ;;;    ld      a,(varQ)                    ;
   4+ 79A1              ;;;    ld      b,a                         ;
   5+ 79A1              ;;;    ld      a,c                         ; Get varQ into b and retain c
   6+ 79A1              ;;;RequAmul256divB:                        ;
   7+ 79A1              ;;;LL28Breg:
   8+ 79A1              ;;;; "BFRDIV R = (A * 256 / Q)  byte from remainder of division, not signed a = a, b = q, c = r"
   9+ 79A1              ;;;	cp		b							; Check A >= Q
  10+ 79A1              ;;;	jr		nc, .AnswerTooBig			; A >= Q? yes too big
  11+ 79A1              ;;;.CalcRemainder:
  12+ 79A1              ;;;	ld		c, 	$FE						; set R to $FE
  13+ 79A1              ;;;.RollRemainder:
  14+ 79A1              ;;;	sla		a
  15+ 79A1              ;;;	jr		c,.Reduce					; if a >> generates carry reduce
  16+ 79A1              ;;;	cp		b							; a < q?
  17+ 79A1              ;;;	jr		nc,.DontSBC
  18+ 79A1              ;;;.DoSBC:									; a is < q
  19+ 79A1              ;;;	sbc		a,b							; 	a -= q
  20+ 79A1              ;;;.DontSBC:
  21+ 79A1              ;;;	rl		c							; r << 1
  22+ 79A1              ;;;	jr		c, .RollRemainder			; if rol generated a carry, continue
  23+ 79A1              ;;;    ld      a,c
  24+ 79A1              ;;;    ld      (varR),a
  25+ 79A1              ;;;	ret									; R (c) left with remainder
  26+ 79A1              ;;;.Reduce:								; a geneated a carry
  27+ 79A1              ;;;	sbc		a,b							; a = a - (q +1)
  28+ 79A1              ;;;	scf									; set carry flag for rl
  29+ 79A1              ;;;	rl		c							; r << 1 briging in carry
  30+ 79A1              ;;;	jr		c,	.RollRemainder			; if a carry fell off bit 7 then repeat
  31+ 79A1              ;;;    ld      a,c
  32+ 79A1              ;;;    ld      (varR),a
  33+ 79A1              ;;;	ret
  34+ 79A1              ;;;.AnswerTooBig:
  35+ 79A1              ;;;	ld	    c,$FF							; arse its too big
  36+ 79A1              ;;;    ld      a,c
  37+ 79A1              ;;;    ld      (varR),a
  38+ 79A1              ;;;	ret
  39+ 79A1
  40+ 79A1              BCequAmul256DivC:
  41+ 79A1 59             ld    e,c
  42+ 79A2 67             ld    h,a
  43+ 79A3 2E 00          ld    l,0
  44+ 79A5              AdivEDivide:                             ; this routine performs the operation BC=HL/E
  45+ 79A5 7B             ld a,e                                 ; checking the divisor; returning if it is zero
  46+ 79A6 B7             or a                                   ; from this time on the carry is cleared
  47+ 79A7 C8             ret z
  48+ 79A8 01 FF FF       ld bc,-1                               ; BC is used to accumulate the result
  49+ 79AB 16 00          ld d,0                                 ; clearing D, so DE holds the divisor
  50+ 79AD              AdivEDivLoop:                            ; subtracting DE from HL until the first overflow
  51+ 79AD ED 52          sbc hl,de                              ; since the carry is zero, SBC works as if it was a SUB
  52+ 79AF 03             inc bc                                 ;  note that this instruction does not alter the flags
  53+ 79B0 30 FB          jr nc,AdivEDivLoop                     ; no carry means that there was no overflow
  54+ 79B2 C9             ret
  55+ 79B3
  56+ 79B3              HL_Div_C:
  57+ 79B3              ; Integer divides HL by C
  58+ 79B3              ; Result in HL, remainder in A
  59+ 79B3              ; Clobbers F, B
  60+ 79B3 06 10                ld b,16
  61+ 79B5 AF                   xor a
  62+ 79B6              HL_Div_C_Loop:
  63+ 79B6 29                   add hl,hl
  64+ 79B7 17                   rla
  65+ 79B8 B9                   cp c
  66+ 79B9 38 02                jr c,HL_DivC_Skip
  67+ 79BB 91                   sub c
  68+ 79BC 2C                   inc l
  69+ 79BD              HL_DivC_Skip:
  70+ 79BD 10 F7                djnz HL_Div_C_Loop
  71+ 79BF 7D                   ld   a,l
  72+ 79C0 32 60 69             ld  (varR),a
  73+ 79C3 C9                   ret
  74+ 79C4
  75+ 79C4
  76+ 79C4
  77+ 79C4              ; Entry point if varQ is populated with demoninator
  78+ 79C4              RequAmul256divQ:
  79+ 79C4              BFRDIV:
  80+ 79C4 F5           		push	af
  81+ 79C5 3A 5F 69     		ld		a,(varQ)
  82+ 79C8 4F           		ld		c,a
  83+ 79C9 F1           		pop		af
  84+ 79CA FE 00        		cp		0
  85+ 79CC CA E3 79     		jp		z, HLDIVC_0_BY	; fast exit if numerator is 0
  86+ 79CF              RequAmul256divC:
  87+ 79CF 2E 00        		ld		l,0
  88+ 79D1 67           		ld		h,a
  89+ 79D2              HL_Div_Cold:						; fast entry point if C and HL are already set
  90+ 79D2 06 10        		ld b,16
  91+ 79D4 AF           		xor a
  92+ 79D5              LOOPPOINT:
  93+ 79D5 29           		add hl,hl
  94+ 79D6 17           		rla
  95+ 79D7 B9           		cp c
  96+ 79D8 38 02        		jr c,SKIPINCSUB
  97+ 79DA 2C           		inc l
  98+ 79DB 91           		sub c
  99+ 79DC              SKIPINCSUB:
 100+ 79DC 10 F7        		djnz LOOPPOINT
 101+ 79DE 7D           		ld		a,l
 102+ 79DF 32 60 69     		ld 		(varR),a
 103+ 79E2 C9           		ret
 104+ 79E3              HLDIVC_0_BY:
 105+ 79E3 32 60 69     		ld		(varR),a
 106+ 79E6 C9           		ret
 107+ 79E7              ;	push	af
 108+ 79E7              ;	ld		a,b
 109+ 79E7              ;	ld		(varQ),a
 110+ 79E7              ;	pop		af
 111+ 79E7              ;RequAmul256divQ:
 112+ 79E7              ;BFRDIV:									;BFRDIV R=A*256/Q   byte from remainder of division
 113+ 79E7              ;	ld		hl,varQ
 114+ 79E7              ;	JumpIfAGTENusng	(hl),LL2			;  is A >=  Q ?, if yes, answer too big for 1 byte, R=#&FF
 115+ 79E7              ;	ld		b,$FE						; b = X
 116+ 79E7              ;	ld		c,a							; c = R	div roll counter
 117+ 79E7              ;LL31:									; roll R
 118+ 79E7              ;	sla		a
 119+ 79E7              ;	jr		c,LL29						; hop to Reduce
 120+ 79E7              ;	JumpIfALTNusng (hl)					; Q skip sbc if a < Q
 121+ 79E7              ;	sbc		a,(hl)						; a = a - Q
 122+ 79E7              ;	rl		c							; rotate R left
 123+ 79E7              ;	jr		c,LL31						; loop if R poped out a carry bit
 124+ 79E7              ;	jr		LL2Good
 125+ 79E7              ;LL29:									; Reduce
 126+ 79E7              ;	sbc		a,(hl)
 127+ 79E7              ;	scf
 128+ 79E7              ;	rl		c							; roll a carry flag into R
 129+ 79E7              ;	jr		c,LL31						;  loop R
 130+ 79E7              ;	jr		LL2Good
 131+ 79E7              ;LL2:
 132+ 79E7              ;	ld		c,$FF
 133+ 79E7              ;LL2Good:
 134+ 79E7              ;	ld		a,c
 135+ 79E7              ;	ld		(varR),a
 136+ 79E7              ;	ret
 137+ 79E7
# file closed: ../../Maths/Utilities/RequAmul256divQ-BFRDIV.asm
 641  79E7                  INCLUDE "../../Maths/Utilities/RequAdivQ-LL61.asm"
# file opened: ../../Maths/Utilities/RequAdivQ-LL61.asm
   1+ 79E7              RequAdivQ:
   2+ 79E7              	; R = A/Q, U = remainder, code looked a little odd as if R is reminader and U = result
   3+ 79E7              LL61:										; Handling division R=A/Q for case further down
   4+ 79E7 4F           	ld		c,a								; c = A
   5+ 79E8 3A 5F 69     	ld		a,(varQ)						; test for divide by 0
   6+ 79EB FE 00        	cp		0
   7+ 79ED 28 16        	jr		z,LL84							; divide by zero error
   8+ 79EF 57           	ld		d,a								; now we can do C/D
   9+ 79F0 06 08            ld b,8
  10+ 79F2 AF               xor a
  11+ 79F3              LL63:										; roll divide loop
  12+ 79F3 CB 21            sla c
  13+ 79F5 17               rla
  14+ 79F6 BA               cp d
  15+ 79F7 38 02            jr c,LL64
  16+ 79F9 0C               inc c
  17+ 79FA 92               sub d
  18+ 79FB              LL64:
  19+ 79FB 10 F6            djnz LL63
  20+ 79FD 32 5E 69     	ld	(varU),a							; store remainder in U
  21+ 7A00 79           	ld	a,c
  22+ 7A01 32 60 69     	ld	(varR),a							; store remainder in R
  23+ 7A04 C9               ret
  24+ 7A05              LL84:										; div error  R=U=#5
  25+ 7A05 3E 32        	ld		a,50
  26+ 7A07 32 60 69     	ld		(varR),a
  27+ 7A0A 32 5E 69     	ld		(varU),a
  28+ 7A0D C9           	ret
  29+ 7A0E
# file closed: ../../Maths/Utilities/RequAdivQ-LL61.asm
 642  7A0E                  INCLUDE "../../Maths/Utilities/RSequQmulA-MULT12.asm"
# file opened: ../../Maths/Utilities/RSequQmulA-MULT12.asm
   1+ 7A0E              asm_mult12:
   2+ 7A0E              RSequQmulA:
   3+ 7A0E              ; "asm_ult12  R.S = Q * A \ visited quite often S = hi, R = lo, odd that its opposite to mult1"
   4+ 7A0E CD 46 79     	call APequQmulA
   5+ 7A11 08           	ex 	af,af'
   6+ 7A12 7A           	ld	a,d
   7+ 7A13 32 61 69     	ld	(varS),a
   8+ 7A16 7B           	ld	a,e
   9+ 7A17 32 60 69     	ld	(varR),a
  10+ 7A1A 08           	ex 	af,af'
  11+ 7A1B C9           	ret
  12+ 7A1C
# file closed: ../../Maths/Utilities/RSequQmulA-MULT12.asm
 643  7A1C                  include "../../Universe/Ships/CopyRotMattoXX15.asm"
# file opened: ../../Universe/Ships/CopyRotMattoXX15.asm
   1+ 7A1C              CopyRotMatNoseVtoXX15:
   2+ 7A1C                      ldCopyByte  UBnkrotmatNosevX+1 ,XX15VecX
   2+ 7A1C 3A 36 C0    >                        ld       a,(UBnkrotmatNosevX+1)
   2+ 7A1F 32 A6 C0    >                        ld       (XX15VecX),a
   3+ 7A22                      ldCopyByte  UBnkrotmatNosevY+1, XX15VecY
   3+ 7A22 3A 38 C0    >                        ld       a,(UBnkrotmatNosevY+1)
   3+ 7A25 32 A7 C0    >                        ld       (XX15VecY),a
   4+ 7A28                      ldCopyByte  UBnkrotmatNosevZ+1 ,XX15VecZ
   4+ 7A28 3A 3A C0    >                        ld       a,(UBnkrotmatNosevZ+1)
   4+ 7A2B 32 A8 C0    >                        ld       (XX15VecZ),a
   5+ 7A2E C9                   ret
   6+ 7A2F
   7+ 7A2F              CopyRotMatRoofVtoXX15:
   8+ 7A2F                      ldCopyByte  UBnkrotmatRoofvX+1 ,XX15VecX
   8+ 7A2F 3A 30 C0    >                        ld       a,(UBnkrotmatRoofvX+1)
   8+ 7A32 32 A6 C0    >                        ld       (XX15VecX),a
   9+ 7A35                      ldCopyByte  UBnkrotmatRoofvY+1, XX15VecY
   9+ 7A35 3A 32 C0    >                        ld       a,(UBnkrotmatRoofvY+1)
   9+ 7A38 32 A7 C0    >                        ld       (XX15VecY),a
  10+ 7A3B                      ldCopyByte  UBnkrotmatRoofvZ+1 ,XX15VecZ
  10+ 7A3B 3A 34 C0    >                        ld       a,(UBnkrotmatRoofvZ+1)
  10+ 7A3E 32 A8 C0    >                        ld       (XX15VecZ),a
  11+ 7A41 C9                   ret
  12+ 7A42
  13+ 7A42              CopyRotMatSideVtoXX15:
  14+ 7A42                      ldCopyByte  UBnkrotmatSidevX+1 ,XX15VecX
  14+ 7A42 3A 2A C0    >                        ld       a,(UBnkrotmatSidevX+1)
  14+ 7A45 32 A6 C0    >                        ld       (XX15VecX),a
  15+ 7A48                      ldCopyByte  UBnkrotmatSidevY+1, XX15VecY
  15+ 7A48 3A 2C C0    >                        ld       a,(UBnkrotmatSidevY+1)
  15+ 7A4B 32 A7 C0    >                        ld       (XX15VecY),a
  16+ 7A4E                      ldCopyByte  UBnkrotmatSidevZ+1 ,XX15VecZ
  16+ 7A4E 3A 2E C0    >                        ld       a,(UBnkrotmatSidevZ+1)
  16+ 7A51 32 A8 C0    >                        ld       (XX15VecZ),a
  17+ 7A54 C9                   ret
  18+ 7A55
# file closed: ../../Universe/Ships/CopyRotMattoXX15.asm
 644  7A55                  include "../../Universe/Ships/CopyXX15toRotMat.asm"
# file opened: ../../Universe/Ships/CopyXX15toRotMat.asm
   1+ 7A55              CopyXX15toRotMatNoseV:
   2+ 7A55                      ldCopyByte  XX15VecX, UBnkrotmatNosevX+1
   2+ 7A55 3A A6 C0    >                        ld       a,(XX15VecX)
   2+ 7A58 32 36 C0    >                        ld       (UBnkrotmatNosevX+1),a
   3+ 7A5B                      ldCopyByte  XX15VecY, UBnkrotmatNosevY+1
   3+ 7A5B 3A A7 C0    >                        ld       a,(XX15VecY)
   3+ 7A5E 32 38 C0    >                        ld       (UBnkrotmatNosevY+1),a
   4+ 7A61                      ldCopyByte  XX15VecZ, UBnkrotmatNosevZ+1
   4+ 7A61 3A A8 C0    >                        ld       a,(XX15VecZ)
   4+ 7A64 32 3A C0    >                        ld       (UBnkrotmatNosevZ+1),a
   5+ 7A67                      ZeroA
   5+ 7A67 AF          >                        xor a
   6+ 7A68 32 35 C0             ld  (UBnkrotmatNosevX),a
   7+ 7A6B 32 37 C0             ld  (UBnkrotmatNosevY),a
   8+ 7A6E 32 39 C0             ld  (UBnkrotmatNosevZ),a
   9+ 7A71 C9                   ret
  10+ 7A72
  11+ 7A72              CopyXX15toRotMatRoofV:
  12+ 7A72                      ldCopyByte  XX15VecX, UBnkrotmatRoofvX+1
  12+ 7A72 3A A6 C0    >                        ld       a,(XX15VecX)
  12+ 7A75 32 30 C0    >                        ld       (UBnkrotmatRoofvX+1),a
  13+ 7A78                      ldCopyByte  XX15VecY, UBnkrotmatRoofvY+1
  13+ 7A78 3A A7 C0    >                        ld       a,(XX15VecY)
  13+ 7A7B 32 32 C0    >                        ld       (UBnkrotmatRoofvY+1),a
  14+ 7A7E                      ldCopyByte  XX15VecZ, UBnkrotmatRoofvZ+1
  14+ 7A7E 3A A8 C0    >                        ld       a,(XX15VecZ)
  14+ 7A81 32 34 C0    >                        ld       (UBnkrotmatRoofvZ+1),a
  15+ 7A84                      ZeroA
  15+ 7A84 AF          >                        xor a
  16+ 7A85 32 2F C0             ld  (UBnkrotmatRoofvX),a
  17+ 7A88 32 31 C0             ld  (UBnkrotmatRoofvY),a
  18+ 7A8B 32 33 C0             ld  (UBnkrotmatRoofvZ),a
  19+ 7A8E C9                   ret
  20+ 7A8F
  21+ 7A8F              CopyXX15toRotMatSideV:
  22+ 7A8F                      ldCopyByte  XX15VecX, UBnkrotmatSidevX+1
  22+ 7A8F 3A A6 C0    >                        ld       a,(XX15VecX)
  22+ 7A92 32 2A C0    >                        ld       (UBnkrotmatSidevX+1),a
  23+ 7A95                      ldCopyByte  XX15VecY, UBnkrotmatSidevY+1
  23+ 7A95 3A A7 C0    >                        ld       a,(XX15VecY)
  23+ 7A98 32 2C C0    >                        ld       (UBnkrotmatSidevY+1),a
  24+ 7A9B                      ldCopyByte  XX15VecZ, UBnkrotmatSidevZ+1
  24+ 7A9B 3A A8 C0    >                        ld       a,(XX15VecZ)
  24+ 7A9E 32 2E C0    >                        ld       (UBnkrotmatSidevZ+1),a
  25+ 7AA1                      ZeroA
  25+ 7AA1 AF          >                        xor a
  26+ 7AA2 32 29 C0             ld  (UBnkrotmatSidevX),a
  27+ 7AA5 32 2B C0             ld  (UBnkrotmatSidevY),a
  28+ 7AA8 32 2D C0             ld  (UBnkrotmatSidevZ),a
  29+ 7AAB C9                   ret
  30+ 7AAC
# file closed: ../../Universe/Ships/CopyXX15toRotMat.asm
 645  7AAC                  INCLUDE "../../Maths/Utilities/tidy.asm"
# file opened: ../../Maths/Utilities/tidy.asm
   1+ 7AAC              ;rotmap0xLo: DB	0				; INWK +9
   2+ 7AAC              ;rotmap0xHi: DB	0				; INWK +10
   3+ 7AAC              ;rotmat0yLo: DB	0				; INWK +11
   4+ 7AAC              ;rotmat0yHi: DB	0				; INWK +12
   5+ 7AAC              ;rotmat0zLo:	DB 	0				; INWK +13
   6+ 7AAC              ;rotmat0zHi:	DB 	0				; INWK +14
   7+ 7AAC              ;rotmap1xLo: DB	0				; INWK +15
   8+ 7AAC              ;rotmap1xHi:	DB	0				; INWK +16
   9+ 7AAC              ;rotmat1yLo:	DB	0				; INWK +17
  10+ 7AAC              ;rotmat1yHi:	DB	0				; INWK +18
  11+ 7AAC              ;rotmat1zLo:	DB	0				; INWK +19
  12+ 7AAC              ;rotmat1zHi:	DB	0				; INWK +20
  13+ 7AAC              ;rotmat2xLo: DB	0				; INWK +21
  14+ 7AAC              ;rotmat2xHi:	DB	0				; INWK +22
  15+ 7AAC              ;rotmat2yLo:	DB	0				; INWK +23
  16+ 7AAC              ;rotmat2yHi:	DB	0				; INWK +24
  17+ 7AAC              ;rotmat2zLo:	DB	0				; INWK +25
  18+ 7AAC              ;rotmat2zHi:	DB	0				; INWK +26
  19+ 7AAC              ;
  20+ 7AAC              ;rotmatFx	equ	rotmat0xHi
  21+ 7AAC              ;rotmatFy	equ	rotmat0yHi
  22+ 7AAC              ;rotmatFz	equ	rotmat0zHi
  23+ 7AAC              ;rotmatUx	equ	rotmat1xHi
  24+ 7AAC              ;rotmatUy	equ	rotmat1yHi
  25+ 7AAC              ;rotmatUz	equ	rotmat1zHi
  26+ 7AAC              ;
  27+ 7AAC              ;inwkarray			equ		INWK+10
  28+ 7AAC
  29+ 7AAC
  30+ 7AAC              ; d = vector 1 e = vector 2 h = vector3 l = vector 4 b = vector 5
  31+ 7AAC              ; performs (d*e + h*l) / b and puts the result in de where e is 0
  32+ 7AAC C5           TidyCalc:       push    bc
  33+ 7AAD CD AD 6D                     call    mulDbyESigned           ; de = vector 1 * vector 2
  34+ 7AB0 EB                           ex      hl,de                   ; get hl into de and save result of de
  35+ 7AB1 CD AD 6D                     call    mulDbyESigned           ; de = vector 2 * vector 3
  36+ 7AB4 CD 04 00                     call    AddDEtoHLSigned         ; BC = HL = HL + DE
  37+ 7AB7 D1                           pop     de                      ; DE = BC saved from earlier
  38+ 7AB8 7C                           ld      a,h                     ; check for result 0
  39+ 7AB9 B5                           or      l                       ; .
  40+ 7ABA CA DB 7A                     jp      z,.ZeroResult           ; .
  41+ 7ABD 44 4D                        ld      bc,hl                   ; .
  42+ 7ABF 7A                           ld      a,d                     ; check for divide by zero
  43+ 7AC0 A7                           and     a                       ; .
  44+ 7AC1 CA D2 7A                     jp      z,.MaxedResult          ; .
  45+ 7AC4 5A                           ld      e,d                     ; now de = 0b (i.e. b register not hex value)
  46+ 7AC5 16 00                        ld      d,0                     ;
  47+ 7AC7 CD 0B 74                     call    Floor_DivQSigned        ; TO BE TESTED should do BC = BC / DE
  48+ 7ACA 78                           ld      a,b                     ; sign bit from b
  49+ 7ACB E6 80                        and     $80                     ; .
  50+ 7ACD B1                           or      c                       ; bring in the value
  51+ 7ACE 57                           ld      d,a                     ; de = c0 (i.e. c register not hex value)
  52+ 7ACF 1E 00                        ld      e,0                     ; .
  53+ 7AD1 C9                           ret
  54+ 7AD2 78           .MaxedResult:   ld      a,b                     ; make result signed unity (i.e. 1 or 96 in our case)
  55+ 7AD3 EE 80                        xor     $80
  56+ 7AD5 F6 60                        or      $60
  57+ 7AD7 57                           ld      d,a
  58+ 7AD8 1E 00                        ld      e,0
  59+ 7ADA C9                           ret
  60+ 7ADB 11 00 00     .ZeroResult:    ld      de,0
  61+ 7ADE C9                           ret
  62+ 7ADF              ; as per tidy calc except
  63+ 7ADF              ; d = vector 1 e = vector 2 h = vector3 l = vector 4
  64+ 7ADF              ; performs (d*e - h*l) / 96 and puts the result in de where e is 0
  65+ 7ADF
  66+ 7ADF CD AD 6D     TidySide:       call    mulDbyESigned           ; de = vector 1 * vector 2
  67+ 7AE2 EB                           ex      de,hl                   ; get hl = vector 1 * vector 2
  68+ 7AE3 CD AD 6D                     call    mulDbyESigned           ; de = vector 2 * vector 3
  69+ 7AE6 CD 00 00                     call    SubDEfromHLSigned       ; BC = HL = HL - DE
  70+ 7AE9 44 4D                        ld      bc,hl                   ; .
  71+ 7AEB 11 60 00                     ld      de,$60                  ; now de = 96
  72+ 7AEE CD 0B 74                     call    Floor_DivQSigned        ; TO BE TESTED should do BC = BC / DE
  73+ 7AF1 78                           ld      a,b                     ; sign bit from b
  74+ 7AF2 E6 80                        and     $80                     ; .
  75+ 7AF4 B1                           or      c                       ; bring in the value
  76+ 7AF5 57                           ld      d,a                     ; de = c0 (i.e. c register not hex value)
  77+ 7AF6 1E 00                        ld      e,0                     ; .
  78+ 7AF8 C9                           ret
  79+ 7AF9
  80+ 7AF9              ;; orthonormalise vector for UBnK ship vector uses IX IT
  81+ 7AF9 DD 21 35 C0  TidyVectorsIX:  ld      ix,UBnkrotmatNosevX
  82+ 7AFD CD A0 76                     call    NormaliseIXVector       ; initially we normalise the nose vector
  83+ 7B00 3A 36 C0     .CheckNoseXSize:ld      a,(UBnkrotmatNosevX+1)  ; a = nose x
  84+ 7B03 E6 30                        and     %00110000                ; if bits 7 and 6 are clear the work with nosey
  85+ 7B05 CA 39 7B                     jp      z, .NoseXSmall
  86+ 7B08              ;-- When nosex is large ------------------------  roofv_x =-(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
  87+ 7B08 3A 38 C0     .NoseXLarge:    ld      a,(UBnkrotmatNosevY+1)  ; a = nose x
  88+ 7B0B 57                           ld      d,a
  89+ 7B0C 3A 32 C0                     ld      a,(UBnkrotmatRoofvY+1)  ; hl = nosev_y * roofv_y
  90+ 7B0F 5F                           ld      e,a                     ; we already have d so only need roofY
  91+ 7B10 3A 3A C0                     ld      a,(UBnkrotmatNosevZ+1)  ; de = nosev_z * roofv_z
  92+ 7B13 67                           ld      h,a                     ; .
  93+ 7B14 3A 34 C0                     ld      a,(UBnkrotmatRoofvZ+1)  ; .
  94+ 7B17 6F                           ld      l,a                     ; .
  95+ 7B18 3A 36 C0                     ld      a,(UBnkrotmatNosevX+1)
  96+ 7B1B 47                           ld      b,a
  97+ 7B1C CD AC 7A                     call    TidyCalc
  98+ 7B1F 7A                           ld      a,d
  99+ 7B20 B3                           or      e
 100+ 7B21 CA 28 7B                     jp      z,.NoRoofXFlip
 101+ 7B24 3E 80                        ld      a,$80                   ; flip sign bit if not zero
 102+ 7B26 AA                           xor     d
 103+ 7B27 57                           ld      d,a
 104+ 7B28 ED 53 2F C0  .NoRoofXFlip:   ld      (UBnkrotmatRoofvX),de   ; write roofvx
 105+ 7B2C C3 94 7B                     jp      .NormaliseRoofv
 106+ 7B2F 11 00 E0     .MaxedRoofX:    ld      de,$E000                ; TEST if sign is correct for all of these if was divide by zero make it -1
 107+ 7B32 ED 53 2F C0                  ld      (UBnkrotmatRoofvX),de   ; write roofvx
 108+ 7B36 C3 94 7B                     jp      .NormaliseRoofv
 109+ 7B39              ;-- When noseX is small ------------------------ determine if we are doign roofz or roof y
 110+ 7B39 3A 37 C0     .NoseXSmall:    ld      a,(UBnkrotmatNosevY)
 111+ 7B3C E6 60                        and     %01100000
 112+ 7B3E CA 6C 7B                     jp      z,.NoseYSmall
 113+ 7B41              ;-- When noseY is large ------------------------ roofv_z = -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
 114+ 7B41 3A 36 C0     .NoseYLarge:    ld      a,(UBnkrotmatNosevX+1)
 115+ 7B44 57                           ld      d,a
 116+ 7B45 3A 30 C0                     ld      a,(UBnkrotmatRoofvX+1)
 117+ 7B48 5F                           ld      e,a
 118+ 7B49 3A 38 C0                     ld      a,(UBnkrotmatNosevY+1)
 119+ 7B4C 67                           ld      h,a
 120+ 7B4D 3A 32 C0                     ld      a,(UBnkrotmatRoofvY+1)
 121+ 7B50 6F                           ld      l,a
 122+ 7B51 3A 3A C0                     ld      a,(UBnkrotmatNosevZ+1)
 123+ 7B54 47                           ld      b,a
 124+ 7B55 CD AC 7A                     call    TidyCalc
 125+ 7B58 7A                           ld      a,d
 126+ 7B59 B3                           or      e
 127+ 7B5A CA 65 7B                     jp      z,.NoRoofZFlip
 128+ 7B5D 3E 80                        ld      a,$80                   ; flip sign bit if not zero
 129+ 7B5F AA                           xor     d
 130+ 7B60 57                           ld      d,a
 131+ 7B61 3E 80                        ld      a,$80                   ; flip sign bit
 132+ 7B63 AA                           xor     d
 133+ 7B64 57                           ld      d,a
 134+ 7B65 ED 53 33 C0  .NoRoofZFlip:   ld      (UBnkrotmatRoofvZ),de   ; write roofvz
 135+ 7B69 C3 94 7B                     jp      .NormaliseRoofv
 136+ 7B6C              ;-- When noseY is large ------------------------ roofv_y = -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
 137+ 7B6C 3A 36 C0     .NoseYSmall:    ld      a,(UBnkrotmatNosevX+1)
 138+ 7B6F 57                           ld      d,a
 139+ 7B70 3A 30 C0                     ld      a,(UBnkrotmatRoofvX+1)
 140+ 7B73 5F                           ld      e,a
 141+ 7B74 3A 3A C0                     ld      a,(UBnkrotmatNosevZ+1)
 142+ 7B77 67                           ld      h,a
 143+ 7B78 3A 34 C0                     ld      a,(UBnkrotmatRoofvZ+1)
 144+ 7B7B 6F                           ld      l,a
 145+ 7B7C 3A 38 C0                     ld      a,(UBnkrotmatNosevY+1)
 146+ 7B7F 47                           ld      b,a
 147+ 7B80 CD AC 7A                     call    TidyCalc
 148+ 7B83 7A                           ld      a,d
 149+ 7B84 B3                           or      e
 150+ 7B85 CA 90 7B                     jp      z,.NoRoofYFlip
 151+ 7B88 3E 80                        ld      a,$80                   ; flip sign bit if not zero
 152+ 7B8A AA                           xor     d
 153+ 7B8B 57                           ld      d,a
 154+ 7B8C 3E 80                        ld      a,$80                   ; flip sign bit
 155+ 7B8E AA                           xor     d
 156+ 7B8F 57                           ld      d,a
 157+ 7B90 ED 53 31 C0  .NoRoofYFlip:   ld      (UBnkrotmatRoofvY),de   ; write roofvy
 158+ 7B94 DD 21 2F C0  .NormaliseRoofv:ld      ix,UBnkrotmatRoofvX     ; now normalise roofv
 159+ 7B98 CD A0 76                     call    NormaliseIXVector
 160+ 7B9B              ; -- sidev_x = (nosev_z * roofv_y - nosev_y * roofv_z) / 96
 161+ 7B9B 3A 3A C0     .CalcSidevX:    ld      a,(UBnkrotmatNosevZ+1)
 162+ 7B9E 57                           ld      d,a
 163+ 7B9F 3A 32 C0                     ld      a,(UBnkrotmatRoofvY+1)
 164+ 7BA2 5F                           ld      e,a
 165+ 7BA3 3A 38 C0                     ld      a,(UBnkrotmatNosevY+1)
 166+ 7BA6 67                           ld      h,a
 167+ 7BA7 3A 34 C0                     ld      a,(UBnkrotmatRoofvZ+1)
 168+ 7BAA 6F                           ld      l,a
 169+ 7BAB CD DF 7A                     call    TidySide
 170+ 7BAE ED 53 29 C0                  ld      (UBnkrotmatSidevX),de   ; write sidevX
 171+ 7BB2              ; -- sidev_y = (nosev_x * roofv_z - nosev_z * roofv_x) / 96
 172+ 7BB2 3A 36 C0     .CalcSidevY:    ld      a,(UBnkrotmatNosevX+1)
 173+ 7BB5 57                           ld      d,a
 174+ 7BB6 3A 34 C0                     ld      a,(UBnkrotmatRoofvZ+1)
 175+ 7BB9 5F                           ld      e,a
 176+ 7BBA 3A 3A C0                     ld      a,(UBnkrotmatNosevZ+1)
 177+ 7BBD 67                           ld      h,a
 178+ 7BBE 3A 30 C0                     ld      a,(UBnkrotmatRoofvX+1)
 179+ 7BC1 6F                           ld      l,a
 180+ 7BC2 CD DF 7A                     call    TidySide
 181+ 7BC5 ED 53 2B C0                  ld      (UBnkrotmatSidevY),de   ; write sidevX
 182+ 7BC9              ; -- sidev_z = (nosev_y * roofv_x - nosev_x * roofv_y) / 96
 183+ 7BC9 3A 38 C0     .CalcSidevZ:    ld      a,(UBnkrotmatNosevY+1)
 184+ 7BCC 57                           ld      d,a
 185+ 7BCD 3A 30 C0                     ld      a,(UBnkrotmatRoofvX+1)
 186+ 7BD0 5F                           ld      e,a
 187+ 7BD1 3A 36 C0                     ld      a,(UBnkrotmatNosevX+1)
 188+ 7BD4 67                           ld      h,a
 189+ 7BD5 3A 32 C0                     ld      a,(UBnkrotmatRoofvY+1)
 190+ 7BD8 6F                           ld      l,a
 191+ 7BD9 CD DF 7A                     call    TidySide
 192+ 7BDC ED 53 2D C0                  ld      (UBnkrotmatSidevZ),de   ; write sidevX
 193+ 7BE0 C9                           ret
 194+ 7BE1              ;
 195+ 7BE1              ; Divide that sets value to FFFF if divide by 0 unless main value is 0, then 0
 196+ 7BE1
 197+ 7BE1              ; (P+1 A) = (A P) / Q
 198+ 7BE1              ;  B A    = (A P) / Q
 199+ 7BE1              ; TESTED OK
 200+ 7BE1
 201+ 7BE1
 202+ 7BE1 2A A6 C0     NormalizeXX15:          ld      hl, (XX15VecX)              ; h= VecX, l = VecY
 203+ 7BE4 3A A8 C0                             ld      a,  (XX15VecZ)              ; a = VecZ, d we don't care
 204+ 7BE7 E6 7F        .ABSZ:                  and     SignMask8Bit
 205+ 7BE9 FD 67                                ld      iyh,a                       ; iyh = abs z
 206+ 7BEB 57           .ZSquared:              ld      d,a
 207+ 7BEC 5F                                   ld      e,a
 208+ 7BED ED 30                                mul     de
 209+ 7BEF 42 4B                                ld      bc,de                       ; bc = z squared
 210+ 7BF1 7D           .ABSX:                  ld      a,l
 211+ 7BF2 E6 7F        .XSquared:              and     SignMask8Bit
 212+ 7BF4 DD 67                                ld      ixh,a                       ; ixh = abs x
 213+ 7BF6 57                                   ld      d,a
 214+ 7BF7 5F                                   ld      e,a
 215+ 7BF8 ED 30                                mul     de
 216+ 7BFA EB                                   ex      de,hl                       ; hl = x squared
 217+ 7BFB 7A           .ABSY:                  ld      a,d                         ; as h was swapped into d
 218+ 7BFC E6 7F                                and     SignMask8Bit
 219+ 7BFE DD 6F                                ld      ixl,a                       ; ixl = abs y
 220+ 7C00 5F           .YSquared:              ld      e,a
 221+ 7C01 57                                   ld      d,a
 222+ 7C02 ED 30                                mul     de                          ; de = y squared
 223+ 7C04 19                                   add     hl,de                       ; hl = hl + de + bc
 224+ 7C05 09                                   add     hl,bc                       ;
 225+ 7C06 EB                                   ex      de,hl
 226+ 7C07 CD A5 6F                             call    asm_sqrt                    ; d = iyl =hl = sqrt (de) = sqrt (x ^ 2 + y ^ 2 + z ^ 2)
 227+ 7C0A 55                                   ld      d,l
 228+ 7C0B FD 6A                                ld      iyl,d
 229+ 7C0D DD 7C        .NormaliseX:            ld      a,ixh                       ; normalise x
 230+ 7C0F CD 00 79                             call    AequAdivDmul96Q8
 231+ 7C12                                      DISPLAY "TODO: ERROR if D is > 127 then it thinkgs its -ve number and falls appart"
 232+ 7C12                                     ;TODO : Need a divison routine where D is unsigned as its sqare rooted so will always be positive
 233+ 7C12 57                                   ld      d,a
 234+ 7C13 3A A6 C0                             ld      a,(XX15VecX)
 235+ 7C16 E6 80                                and     SignOnly8Bit
 236+ 7C18 B2                                   or      d
 237+ 7C19 32 A6 C0                             ld      (XX15VecX),a
 238+ 7C1C DD 7D        .NormaliseY:            ld      a,ixl                       ; normalise y
 239+ 7C1E 55                                   ld      d,l
 240+ 7C1F CD 00 79                             call    AequAdivDmul96Q8
 241+ 7C22 57                                   ld      d,a
 242+ 7C23 3A A7 C0                             ld      a,(XX15VecY)
 243+ 7C26 E6 80                                and     SignOnly8Bit
 244+ 7C28 B2                                   or      d
 245+ 7C29 32 A7 C0                             ld      (XX15VecY),a
 246+ 7C2C FD 7C        .NormaliseZ:            ld      a,iyh                       ; normalise z
 247+ 7C2E 55                                   ld      d,l
 248+ 7C2F CD 00 79                             call    AequAdivDmul96Q8
 249+ 7C32 57                                   ld      d,a
 250+ 7C33 3A A8 C0                             ld      a,(XX15VecZ)
 251+ 7C36 E6 80                                and     SignOnly8Bit
 252+ 7C38 B2                                   or      d
 253+ 7C39 32 A8 C0                             ld      (XX15VecZ),a
 254+ 7C3C C9                                   ret
 255+ 7C3D
 256+ 7C3D              TidyNormaliseNoseV:     MACRO
 257+ 7C3D ~                                    call	CopyRotMatNoseVtoXX15	    ; copy over matrix row 3 (Nosev)
 258+ 7C3D ~                                    call	NormalizeXX15			    ; normalise z hi, its really TIS3 and write back to matrix
 259+ 7C3D ~                                    call	CopyXX15toRotMatNoseV       ; .
 260+ 7C3D                                      ENDM
 261+ 7C3D              TidyNormaliseRoofV:     MACRO
 262+ 7C3D ~                                    call	CopyRotMatRoofVtoXX15
 263+ 7C3D ~                                    call	NormalizeXX15			; normalise z hi, its really TIS3
 264+ 7C3D ~                                    call	CopyXX15toRotMatRoofV
 265+ 7C3D                                      ENDM
 266+ 7C3D
 267+ 7C3D
 268+ 7C3D              TidyUbnK:               ;break
 269+ 7C3D                                      TidyNormaliseNoseV
 269+ 7C3D CD 1C 7A    >                        call	CopyRotMatNoseVtoXX15	    ; copy over matrix row 3 (Nosev)
 269+ 7C40 CD E1 7B    >                        call	NormalizeXX15			    ; normalise z hi, its really TIS3 and write back to matrix
 269+ 7C43 CD 55 7A    >                        call	CopyXX15toRotMatNoseV       ; .
 270+ 7C46 3A 36 C0                             ld      a,(UBnkrotmatNosevX+1)      ; Now check and see which vector elemetn we are going to
 271+ 7C49 E6 60                                and     %01100000                   ; if X is not small then we go straigth to roofx
 272+ 7C4B C2 E3 7C                             jp      nz,.ProcessRoofX            ; .
 273+ 7C4E 3A 38 C0     .TidyXIsSmall:          ld      a,(UBnkrotmatNosevY+1)      ; Else we test Y on to using
 274+ 7C51 E6 60                                and     %01100000                   ; if Y is not small we process roofz
 275+ 7C53 20 47                                jr      nz,.ProcessRoofZ            ; .
 276+ 7C55              ;...roofv_y´ = -(nosev_x´ * roofv_x + nosev_z´ * roofv_z) / nosev_y´
 277+ 7C55 3A 36 C0     .ProcessRoofY:          ld		a,(UBnkrotmatNosevX+1)
 278+ 7C58 32 5F 69                             ld		(varQ),a					; q = nosev_y
 279+ 7C5B 3A 30 C0                             ld		a,(UBnkrotmatRoofvX+1)	    ;roov z
 280+ 7C5E CD 0E 7A                             call	RSequQmulA
 281+ 7C61 3A 3A C0                             ld		a,(UBnkrotmatNosevZ+1)		; nosev z
 282+ 7C64 32 5F 69                             ld		(varQ),a					; b = regX for now
 283+ 7C67 3A 34 C0                             ld		a,(UBnkrotmatRoofvZ+1)	    ; roofv y
 284+ 7C6A CD E2 6D                             call	madDEequQmulAaddRS
 285+ 7C6D 7A                                   ld      a,d                         ; flip sign bit
 286+ 7C6E EE 80                                xor     SignOnly8Bit
 287+ 7C70 57                                   ld      d,a
 288+ 7C71 3A 38 C0                             ld      a,(UBnkrotmatNosevY+1)
 289+ 7C74 32 5F 69                             ld      (varQ),a
 290+ 7C77 7A           .YTest0Div:             ld      a,d
 291+ 7C78 E6 7F                                and     $7F
 292+ 7C7A B3                                   or      e
 293+ 7C7B FE 00                                cp      0
 294+ 7C7D 20 0E                                jr      nz,.SkipYZeroTest
 295+ 7C7F                                      ZeroA
 295+ 7C7F AF          >                        xor a
 296+ 7C80 C3 DD 7C                             jp      .SetRoofZ
 297+ 7C83 FE 00        .YTestDiv0:             cp      0
 298+ 7C85 20 06                                jr      nz,.SkipYZeroTest
 299+ 7C87 3E 60        .YDivideByZero:         ld      a,96
 300+ 7C89 B2                                   or      d
 301+ 7C8A C3 DD 7C                             jp      .SetRoofZ
 302+ 7C8D 7B           .SkipYZeroTest:         ld      a,e
 303+ 7C8E 32 5F 68                             ld      (varP),a
 304+ 7C91 7A                                   ld      a,d
 305+ 7C92 CD A7 71                             call    DVIDT
 306+ 7C95 78                                   ld      a,b
 307+ 7C96 32 32 C0     .SetRoofY:              ld      (UBnkrotmatRoofvY+1),a
 308+ 7C99 C3 27 7D                             jp      .DoneRoof
 309+ 7C9C              ;...roofv_z´ = -(nosev_x´ * roofv_x + nosev_y´ * roofv_y) / nosev_z´
 310+ 7C9C 3A 36 C0     .ProcessRoofZ:          ld		a,(UBnkrotmatNosevX+1)      ; Failing that we default to Z
 311+ 7C9F 32 5F 69                             ld		(varQ),a				    ; q = nosev_y
 312+ 7CA2 3A 30 C0                             ld		a,(UBnkrotmatRoofvX+1)	    ;roov z
 313+ 7CA5 CD 0E 7A                             call	RSequQmulA
 314+ 7CA8 3A 38 C0                             ld		a,(UBnkrotmatNosevY+1)	    ; nosev z
 315+ 7CAB 32 5F 69                             ld		(varQ),a				    ; b = regX for now
 316+ 7CAE 3A 32 C0                             ld		a,(UBnkrotmatRoofvY+1)	    ; roofv y
 317+ 7CB1 CD E2 6D                             call	madDEequQmulAaddRS
 318+ 7CB4 7A                                   ld      a,d                         ; flip sign bit
 319+ 7CB5 EE 80                                xor     SignOnly8Bit
 320+ 7CB7 57                                   ld      d,a
 321+ 7CB8 3A 3A C0                             ld      a,(UBnkrotmatNosevZ+1)
 322+ 7CBB 32 5F 69                             ld      (varQ),a
 323+ 7CBE 7A           .ZTest0Div:             ld      a,d
 324+ 7CBF E6 7F                                and     $7F
 325+ 7CC1 B3                                   or      e
 326+ 7CC2 FE 00                                cp      0
 327+ 7CC4 20 0E                                jr      nz,.SkipZZeroTest
 328+ 7CC6                                      ZeroA
 328+ 7CC6 AF          >                        xor a
 329+ 7CC7 C3 DD 7C                             jp      .SetRoofZ
 330+ 7CCA FE 00        .ZTestDiv0:             cp      0
 331+ 7CCC 20 06                                jr      nz,.SkipZZeroTest
 332+ 7CCE 3E 60        .ZDivideByZero:         ld      a,96
 333+ 7CD0 B2                                   or      d
 334+ 7CD1 C3 DD 7C                             jp      .SetRoofZ
 335+ 7CD4 7B           .SkipZZeroTest:         ld      a,e
 336+ 7CD5 32 5F 68                             ld      (varP),a
 337+ 7CD8 7A                                   ld      a,d
 338+ 7CD9 CD A7 71                             call    DVIDT
 339+ 7CDC 78                                   ld      a,b
 340+ 7CDD 32 34 C0     .SetRoofZ:              ld      (UBnkrotmatRoofvZ+1),a
 341+ 7CE0 C3 27 7D                             jp      .DoneRoof
 342+ 7CE3              ;...roofv_x´ = -(nosev_y´ * roofv_y + nosev_z´ * roofv_z) / nosev_x´
 343+ 7CE3 3A 38 C0     .ProcessRoofX:          ld		a,(UBnkrotmatNosevY+1)      ; so we set Q to Nose Y
 344+ 7CE6 32 5F 69                             ld		(varQ),a					; q = nosev_y
 345+ 7CE9 3A 32 C0                             ld		a,(UBnkrotmatRoofvY+1)	    ; A = roofv Y
 346+ 7CEC CD 0E 7A                             call	RSequQmulA                  ; RS = NoseY & RoofY
 347+ 7CEF 3A 3A C0                             ld		a,(UBnkrotmatNosevZ+1)		; nosev z
 348+ 7CF2 32 5F 69                             ld		(varQ),a					; b = regX for now
 349+ 7CF5 3A 34 C0                             ld		a,(UBnkrotmatRoofvZ+1)	    ; roofv y
 350+ 7CF8 CD E2 6D                             call	madDEequQmulAaddRS
 351+ 7CFB 7A                                   ld      a,d                         ; flip sign bit
 352+ 7CFC EE 80                                xor     SignOnly8Bit
 353+ 7CFE 57                                   ld      d,a
 354+ 7CFF 3A 36 C0                             ld      a,(UBnkrotmatNosevX+1)
 355+ 7D02 32 5F 69                             ld      (varQ),a
 356+ 7D05 7A           .XTest0Div:             ld      a,d
 357+ 7D06 E6 7F                                and     $7F
 358+ 7D08 B3                                   or      e
 359+ 7D09 FE 00                                cp      0
 360+ 7D0B 20 0E                                jr      nz,.SkipXZeroTest
 361+ 7D0D                                      ZeroA
 361+ 7D0D AF          >                        xor a
 362+ 7D0E C3 DD 7C                             jp      .SetRoofZ
 363+ 7D11 FE 00        .XTestDiv0:             cp      0
 364+ 7D13 20 06                                jr      nz,.SkipXZeroTest
 365+ 7D15 3E 60        .XDivideByZero:         ld      a,96
 366+ 7D17 B2                                   or      d
 367+ 7D18 C3 24 7D                             jp      .SetRoofX
 368+ 7D1B 7B           .SkipXZeroTest:         ld      a,e
 369+ 7D1C 32 5F 68                             ld      (varP),a
 370+ 7D1F 7A                                   ld      a,d
 371+ 7D20 CD A7 71                             call    DVIDT
 372+ 7D23 78                                   ld      a,b
 373+ 7D24 32 30 C0     .SetRoofX:              ld      (UBnkrotmatRoofvX+1),a
 374+ 7D27              .DoneRoof:              TidyNormaliseRoofV
 374+ 7D27 CD 2F 7A    >                        call	CopyRotMatRoofVtoXX15
 374+ 7D2A CD E1 7B    >                        call	NormalizeXX15			; normalise z hi, its really TIS3
 374+ 7D2D CD 72 7A    >                        call	CopyXX15toRotMatRoofV
 375+ 7D30              ;...sidex = ((nosez * roofy) - nosey * roofz) / 96
 376+ 7D30 3A 3A C0     .DoSidevX:              ld		a,(UBnkrotmatNosevZ+1)      ;  -(-nosev_z * roofv_y + nosev_y * roofv_z) / 96
 377+ 7D33 EE 80                                xor     SignOnly8Bit
 378+ 7D35 32 5F 69                             ld		(varQ),a					; q = nosev_y
 379+ 7D38 3A 32 C0                             ld		a,(UBnkrotmatRoofvY+1)	     ;roov z
 380+ 7D3B CD 0E 7A                             call	RSequQmulA
 381+ 7D3E 3A 38 C0                             ld		a,(UBnkrotmatNosevY+1)		; nosev z
 382+ 7D41 32 5F 69                             ld		(varQ),a							; b = regX for now
 383+ 7D44 3A 34 C0                             ld		a,(UBnkrotmatRoofvZ+1)	    ; roofv y
 384+ 7D47 CD E2 6D                             call	madDEequQmulAaddRS
 385+ 7D4A CD EF 71                             call    BAequDEdiv96
 386+ 7D4D 78                                   ld      a,b
 387+ 7D4E 32 2A C0                             ld      (UBnkrotmatSidevX+1),a
 388+ 7D51              ;...sidey = ((nosex * roofz) - nosez * roofx) / 96
 389+ 7D51 3A 36 C0     .DoSidevY:              ld		a,(UBnkrotmatNosevX+1)      ; -(-nosev_x * roofv_z - nosev_z * roofv_x) / 96
 390+ 7D54 EE 80                                xor     SignOnly8Bit
 391+ 7D56 32 5F 69                             ld		(varQ),a					; q = nosev_y
 392+ 7D59 3A 34 C0                             ld		a,(UBnkrotmatRoofvZ+1)	    ; roov z
 393+ 7D5C CD 0E 7A                             call	RSequQmulA                  ; rs = nosex * roofz
 394+ 7D5F 3A 3A C0                             ld		a,(UBnkrotmatNosevZ+1)		; nosev z
 395+ 7D62 32 5F 69                             ld		(varQ),a					; b = regX for now
 396+ 7D65 3A 34 C0                             ld		a,(UBnkrotmatRoofvZ+1)	    ; roofv y
 397+ 7D68 CD E2 6D                             call	madDEequQmulAaddRS          ; DE = noseyz* roofz +
 398+ 7D6B CD EF 71                             call    BAequDEdiv96
 399+ 7D6E 78                                   ld      a,b
 400+ 7D6F 32 2C C0                             ld      (UBnkrotmatSidevY+1),a         ;-(-nosev_y * roofv_x + nosev_x * roofv_y) / 96
 401+ 7D72              ;...sidez = ((nosey * roofx) - nosex * roofy) / 96
 402+ 7D72 3A 38 C0     .DoSidevZ:              ld		a,(UBnkrotmatNosevY+1)      ;
 403+ 7D75 EE 80                                xor     SignOnly8Bit
 404+ 7D77 32 5F 69                             ld		(varQ),a					; q = nosev_y
 405+ 7D7A 3A 34 C0                             ld		a,(UBnkrotmatRoofvZ+1)	     ;roov z
 406+ 7D7D CD 0E 7A                             call	RSequQmulA
 407+ 7D80 3A 36 C0                             ld		a,(UBnkrotmatNosevX+1)		; nosev z
 408+ 7D83 32 5F 69                             ld		(varQ),a							; b = regX for now
 409+ 7D86 3A 32 C0                             ld		a,(UBnkrotmatRoofvY+1)	    ; roofv y
 410+ 7D89 CD E2 6D                             call	madDEequQmulAaddRS
 411+ 7D8C CD EF 71                             call    BAequDEdiv96
 412+ 7D8F 78                                   ld      a,b
 413+ 7D90 32 2E C0                             ld      (UBnkrotmatSidevZ+1),a
 414+ 7D93                                      ZeroA
 414+ 7D93 AF          >                        xor a
 415+ 7D94 32 29 C0                             ld      (UBnkrotmatSidevX),a
 416+ 7D97 32 2B C0                             ld      (UBnkrotmatSidevY),a
 417+ 7D9A 32 2D C0                             ld      (UBnkrotmatSidevZ),a
 418+ 7D9D C9                                   ret
 419+ 7D9E
 420+ 7D9E
 421+ 7D9E              TidySub1:									;.TIS1	\ -> &293B  \ Tidy subroutine 1  X.A =  (-X*A  + (R.S))/96
 422+ 7D9E              		; b = regX on entry
 423+ 7D9E              TIS1Prep:									;.TIS1	\ -> &293B  \ Tidy subroutine 1 using B register = X
 424+ 7D9E 08           		ex		af,af'
 425+ 7D9F 78           		ld		a,b
 426+ 7DA0 32 5F 69     		ld		(varQ),a
 427+ 7DA3 08           		ex		af,af'
 428+ 7DA4 EE 80        		xor		$80							;	 flip sign of Acc
 429+ 7DA6 CD C0 6D     		call	madXAequQmulAaddRS			; \ MAD \ multiply and add (X,A) =  -X*A  + (R,S)
 430+ 7DA9              ; USES 				A BC E
 431+ 7DA9              ; DOES NOT USE		D HL
 432+ 7DA9              Tis1Div96:							   		; .DVID96	\ Their comment A=A/96: answer is A*255/96
 433+ 7DA9 4F           		ld		c,a							; Store sign bit in  ct (we use e reg for that)
 434+ 7DAA E6 80        		and		SignOnly8Bit						; ..
 435+ 7DAC 5F           		ld		e,a							; ..
 436+ 7DAD 79           		ld		a,c							; a = high byte again with sign bit cleared
 437+ 7DAE E6 7F        		and		SignMask8Bit							; ..
 438+ 7DB0 06 FE        		ld		b,$FE						; slide counter T1
 439+ 7DB2              TIS1RollTLoop								; roll T1  clamp Acc to #96 for rotation matrix unity
 440+ 7DB2 CB 27        		sla		a
 441+ 7DB4              		JumpIfALTNusng $60, TIS1SkipSub
 441+ 7DB4 FE 60       >                        cp      $60
 441+ 7DB6 DA C3 7D    >                        jp		c, TIS1SkipSub
 442+ 7DB9 DE 60        		sbc		a,$60							; subtract 96
 443+ 7DBB 37           		scf
 444+ 7DBC CB 10        		rl		b							;  T1
 445+ 7DBE 38 F2        		jr		c,TIS1RollTLoop
 446+ 7DC0              TIS1KIPCont:
 447+ 7DC0 78           		ld		a,b							;   T1
 448+ 7DC1 B3           		or		e							;   restore T sign
 449+ 7DC2 C9           		ret
 450+ 7DC3              TIS1SkipSub:
 451+ 7DC3 B7           	or			a
 452+ 7DC4 CB 10        	rl			b							; T rolled left to push bit out the end
 453+ 7DC6 38 EA        	jr			c,TIS1RollTLoop				; if we still have not hit the empty marker continue
 454+ 7DC8 C3 C0 7D     	jp			TIS1KIPCont
 455+ 7DCB
 456+ 7DCB              ;.TIDY	\ -> &4679 \ Orthogonalize rotation matrix that uses 0x60 as unity returns INWK(16,18,20) = INWK(12*18+14*20, 10*16+14*20, 10*16+12*18) / INWK(10,12,14)
 457+ 7DCB              ; Ux,Uy,Uz = -(FyUy+FzUz, FxUx+FzUz, FxUx+FyUy)/ Fx,Fy,Fz
 458+ 7DCB
 459+ 7DCB
 460+ 7DCB
 461+ 7DCB
 462+ 7DCB                          DISPLAY "TODO: look at note on TODO"
 463+ 7DCB              TidyRotYSmall:
 464+ 7DCB CD F4 7E     		call	CalcRoofvZ
 465+ 7DCE 32 34 C0     		ld		(UBnkrotmatRoofvZ+1),a			; set roofvy hi?? Says roofz TODO
 466+ 7DD1 C3 05 7E     		jp		NormaliseRoofV
 467+ 7DD4
 468+ 7DD4              TidyRotXSmall:
 469+ 7DD4 AF           		xor		a
 470+ 7DD5 47           		ld		b,a
 471+ 7DD6 3A 38 C0     		ld		a,(UBnkrotmatNosevY+1)			; nosev_y
 472+ 7DD9 E6 60        		and		%01100000
 473+ 7DDB CA CB 7D     		jp		z,TidyRotYSmall
 474+ 7DDE 3A 3A C0     		ld		a,(UBnkrotmatNosevZ+1)			; nosev z
 475+ 7DE1 47           		ld		b,a							; b = regX for now
 476+ 7DE2 3A 32 C0     		ld		a,(UBnkrotmatRoofvY+1)			; roofv y
 477+ 7DE5 CD BA 7E     		call	CalcRoofvY					; Set (roofvy= (nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y, Q -= nosev_z
 478+ 7DE8 32 32 C0     		ld		(UBnkrotmatRoofvY+1),a			; set roofvy hi
 479+ 7DEB C3 05 7E     		jp		NormaliseRoofV
 480+ 7DEE              ; TIDY is broken
 481+ 7DEE
 482+ 7DEE
 483+ 7DEE              TIDY:
 484+ 7DEE
 485+ 7DEE              ORTHOGALISE:
 486+ 7DEE              ;-- NormaliseNosev
 487+ 7DEE CD 1C 7A     		call	CopyRotMatNoseVtoXX15
 488+ 7DF1 CD F3 76     		call	normaliseXX1596S7			; normalise z hi, its really TIS3
 489+ 7DF4 CD 55 7A     		call	CopyXX15toRotMatNoseV
 490+ 7DF7              .CheckNXSmall:
 491+ 7DF7 3A 36 C0     		ld		a,(UBnkrotmatNosevX+1)
 492+ 7DFA E6 60        		and		%01100000					; check top two magnitude bits
 493+ 7DFC CA D4 7D     		jp		z,TidyRotXSmall
 494+ 7DFF              .RotXIsBig:
 495+ 7DFF CD 80 7E             call	CalcRoofvX
 496+ 7E02 32 30 C0     		ld		(UBnkrotmatRoofvX+1),a    	; set roofvx hi
 497+ 7E05              NormaliseRoofV:
 498+ 7E05 CD 2F 7A     		call	CopyRotMatRoofVtoXX15		; xx15 = roofv
 499+ 7E08 CD F3 76     		call	normaliseXX1596S7			; normalise roof
 500+ 7E0B              ;calc sidev x
 501+ 7E0B CD 72 7A     		call	CopyXX15toRotMatRoofV		; get back normalised version
 502+ 7E0E 3A 36 C0     		ld		a,(UBnkrotmatNosevX+1)
 503+ 7E11 32 5F 69     		ld		(varQ),a					; q = nosev_y
 504+ 7E14 3A 34 C0     		ld		a,(UBnkrotmatRoofvZ+1)	     ;roov z
 505+ 7E17 CD 0E 7A     		call	RSequQmulA
 506+ 7E1A 3A 3A C0     		ld		a,(UBnkrotmatNosevZ+1)		; nosev z
 507+ 7E1D 47           		ld		b,a							; b = regX for now
 508+ 7E1E 3A 32 C0     		ld		a,(UBnkrotmatRoofvY+1)	    ; roofv y
 509+ 7E21 CD 9E 7D     		call	TidySub1					; Set (A ?)= (-nosev_z * roofv_y + nosev_y * roofv_z) / 96, Q -= nosev_z
 510+ 7E24                      JumpIfAIsZero NormSideXNoNeg
 510+ 7E24 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 510+ 7E25 CA 2A 7E    >                        jp	    z, NormSideXNoNeg
 511+ 7E28 EE 80        		xor		$80							; flip a to get -sidev_x
 512+ 7E2A              NormSideXNoNeg:
 513+ 7E2A 32 2A C0     		ld		(UBnkrotmatSidevX+1),a
 514+ 7E2D              ;calc sidev y
 515+ 7E2D 3A 3A C0     		ld		a,(UBnkrotmatNosevZ+1)			; nosev z
 516+ 7E30 32 5F 69     		ld		(varQ),a
 517+ 7E33 3A 30 C0     		ld		a,(UBnkrotmatRoofvX+1)			; roofv x
 518+ 7E36 CD 0E 7A     		call	RSequQmulA
 519+ 7E39 3A 36 C0     		ld		a,(UBnkrotmatNosevX+1)			        ; nosev x
 520+ 7E3C 47           		ld		b,a							; b = regX for now
 521+ 7E3D 3A 34 C0     		ld		a,(UBnkrotmatRoofvZ+1)			; roofv z
 522+ 7E40 CD 9E 7D     		call	TidySub1					; Set (A ?)= (-nosev_z * roofv_y + nosev_y * roofv_z) / 96, Q -= nosev_z
 523+ 7E43                      JumpIfAIsZero NormSideYNoNeg
 523+ 7E43 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 523+ 7E44 CA 49 7E    >                        jp	    z, NormSideYNoNeg
 524+ 7E47 EE 80        		xor		$80							; flip a to get -sidev_y
 525+ 7E49              NormSideYNoNeg:
 526+ 7E49 32 38 C0     		ld		(UBnkrotmatNosevY+1),a
 527+ 7E4C              ;calc sidev z
 528+ 7E4C 3A 36 C0     		ld		a,(UBnkrotmatNosevX+1)			; nosev x
 529+ 7E4F 32 5F 69     		ld		(varQ),a
 530+ 7E52 3A 32 C0     		ld		a,(UBnkrotmatRoofvY+1)			; roofv y
 531+ 7E55 CD 0E 7A     		call	RSequQmulA
 532+ 7E58 3A 38 C0     		ld		a,(UBnkrotmatNosevY+1)			; nosev y
 533+ 7E5B 47           		ld		b,a							; b = regX for now
 534+ 7E5C 3A 30 C0     		ld		a,(UBnkrotmatRoofvX+1)			; roofv x
 535+ 7E5F CD 9E 7D     		call	TidySub1					; Set (A ?)= (-nosev_z * roofv_y + nosev_y * roofv_z) / 96, Q -= nosev_z
 536+ 7E62                      JumpIfAIsZero NormSideZNoNeg
 536+ 7E62 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 536+ 7E63 CA 68 7E    >                        jp	    z, NormSideZNoNeg
 537+ 7E66 EE 80        		xor		$80							; flip a to get -sidev_y
 538+ 7E68              NormSideZNoNeg:
 539+ 7E68 32 2C C0     		ld		(UBnkrotmatSidevY+1),a ;TODO SHoudl this be Y??
 540+ 7E6B              .ClearLoBytes:
 541+ 7E6B 21 35 C0     		ld		hl,UBnkrotmatNosevX
 542+ 7E6E 06 09        		ld		b,9
 543+ 7E70 AF                   xor     a
 544+ 7E71              .ClearLoLoop:
 545+ 7E71 77           		ld		(hl),a						; zero out lo bytes
 546+ 7E72 23           		inc		hl
 547+ 7E73 23           		inc		hl
 548+ 7E74 10 FB        		djnz	.ClearLoLoop
 549+ 7E76 CD 42 7A     		call	CopyRotMatSideVtoXX15		; xx15 = roofv
 550+ 7E79 CD F3 76     		call	normaliseXX1596S7			; normalise roof
 551+ 7E7C              ;calc sidev x
 552+ 7E7C CD 8F 7A     		call	CopyXX15toRotMatSideV		; get back normalised version
 553+ 7E7F
 554+ 7E7F C9           		ret
 555+ 7E80
 556+ 7E80
 557+ 7E80              CalcRoofvX:
 558+ 7E80              Tidy1RX:										; roofv_x´ = -(nosev_y´ * roofv_y + nosev_z´ * roofv_z) / nosev_x´
 559+ 7E80              		ldCopyByte UBnkrotmatNosevZ+1,varQ
 559+ 7E80 3A 3A C0    >                        ld       a,(UBnkrotmatNosevZ+1)
 559+ 7E83 32 5F 69    >                        ld       (varQ),a
 560+ 7E86 3A 34 C0     		ld		a,(UBnkrotmatRoofvZ+1)
 561+ 7E89 CD 0E 7A     		call	RSequQmulA						; rs = nosez hi * roofz hi
 562+ 7E8C              		ldCopyByte UBnkrotmatNosevY+1,varQ
 562+ 7E8C 3A 38 C0    >                        ld       a,(UBnkrotmatNosevY+1)
 562+ 7E8F 32 5F 69    >                        ld       (varQ),a
 563+ 7E92 3A 32 C0     		ld		a,(UBnkrotmatRoofvY+1)
 564+ 7E95 CD C0 6D     		call	madXAequQmulAaddRS				; DE = nosey hi * roofy hi + rs
 565+ 7E98 7A           		ld		a,d
 566+ 7E99 E6 80        		and 	$80
 567+ 7E9B FD 67        		ld		iyh,a
 568+ 7E9D              ;DEBUG		ld		c,a
 569+ 7E9D 3A 36 C0     		ld		a,(UBnkrotmatNosevX+1)					; get nosev x sign
 570+ 7EA0 4F           		ld		c,a								; temp save
 571+ 7EA1 E6 80        		and		$80
 572+ 7EA3 FD AC        		xor		iyh								; flip from saved multiply sign result
 573+ 7EA5 FD 67        		ld		iyh,a							; save nosesev sign to iyh
 574+ 7EA7 79           		ld		a,c								; recover a
 575+ 7EA8 E6 7F        		and		$7F								; a is unsigned nosev x
 576+ 7EAA 42           		ld		b,d
 577+ 7EAB 4B           		ld		c,e								; bc = nosev_y´ * roofv_y + nosev_z´ * roofv_z
 578+ 7EAC 57           		ld		d,a								; de = nosev x hi
 579+ 7EAD 1E 00        		ld		e,0
 580+ 7EAF CD 7C 73     		call	BC_Div_DE
 581+ 7EB2 FD 7C        		ld		a,iyh							; get back sign from nosevx
 582+ 7EB4 EE 80        		xor		$80								; flip sign
 583+ 7EB6 E6 80        		and		$80								; keep sign bit only
 584+ 7EB8 B0           		or		b
 585+ 7EB9 C9           		ret
 586+ 7EBA
 587+ 7EBA
 588+ 7EBA              CalcRoofvY:
 589+ 7EBA              Tidy1RY:										; roofv_y´ = -(nosev_x´ * roofv_x + nosev_z´ * roofv_z) / nosev_y´
 590+ 7EBA              		ldCopyByte UBnkrotmatNosevZ+1,varQ				;                  A        Q              RS
 590+ 7EBA 3A 3A C0    >                        ld       a,(UBnkrotmatNosevZ+1)
 590+ 7EBD 32 5F 69    >                        ld       (varQ),a
 591+ 7EC0 3A 34 C0     		ld		a,(UBnkrotmatRoofvZ+1)
 592+ 7EC3 CD 0E 7A     		call	RSequQmulA
 593+ 7EC6              		ldCopyByte UBnkrotmatNosevX+1,varQ
 593+ 7EC6 3A 36 C0    >                        ld       a,(UBnkrotmatNosevX+1)
 593+ 7EC9 32 5F 69    >                        ld       (varQ),a
 594+ 7ECC 3A 30 C0     		ld		a,(UBnkrotmatRoofvX+1)
 595+ 7ECF CD C0 6D     		call	madXAequQmulAaddRS
 596+ 7ED2 7A           		ld		a,d
 597+ 7ED3 E6 80        		and 	$80
 598+ 7ED5 FD 67        		ld		iyh,a
 599+ 7ED7 3A 38 C0     		ld		a,(UBnkrotmatNosevY+1)					; get nosev x sign
 600+ 7EDA 4F           		ld		c,a								; temp save
 601+ 7EDB E6 80        		and		$80
 602+ 7EDD FD AC        		xor		iyh								; flip from saved multiply sign result
 603+ 7EDF FD 67        		ld		iyh,a							; save nosesev sign to iyh
 604+ 7EE1 79           		ld		a,c								; recover a
 605+ 7EE2 E6 7F        		and		$7F								; a is unsigned nosev x
 606+ 7EE4 42           		ld		b,d
 607+ 7EE5 4B           		ld		c,e								; bc = nosev_y´ * roofv_y + nosev_z´ * roofv_z
 608+ 7EE6 57           		ld		d,a								; de = nosev x hi
 609+ 7EE7 1E 00        		ld		e,0
 610+ 7EE9 CD 7C 73     		call	BC_Div_DE
 611+ 7EEC FD 7C        		ld		a,iyh
 612+ 7EEE EE 80        		xor		$80
 613+ 7EF0 E6 80        		and		$80
 614+ 7EF2 B0           		or		b
 615+ 7EF3 C9           		ret
 616+ 7EF4
 617+ 7EF4              CalcRoofvZ:
 618+ 7EF4              Tidy1RZ:										; roofv_z´ = -(nosev_x´ * roofv_x + nosev_y´ * roofv_y) / nosev_z´
 619+ 7EF4              		ldCopyByte UBnkrotmatNosevY+1,varQ
 619+ 7EF4 3A 38 C0    >                        ld       a,(UBnkrotmatNosevY+1)
 619+ 7EF7 32 5F 69    >                        ld       (varQ),a
 620+ 7EFA 3A 32 C0     		ld		a,(UBnkrotmatRoofvY+1)
 621+ 7EFD CD 0E 7A     		call	RSequQmulA						; rs = NOSEy * ROOFy
 622+ 7F00              		ldCopyByte UBnkrotmatNosevX+1,varQ
 622+ 7F00 3A 36 C0    >                        ld       a,(UBnkrotmatNosevX+1)
 622+ 7F03 32 5F 69    >                        ld       (varQ),a
 623+ 7F06 3A 30 C0     		ld		a,(UBnkrotmatRoofvX+1)
 624+ 7F09 CD C0 6D     		call	madXAequQmulAaddRS				; de (A,ixl) = NOSEx * ROOFx + RS
 625+ 7F0C 7A           		ld		a,d
 626+ 7F0D E6 80        		and 	$80
 627+ 7F0F FD 67        		ld		iyh,a
 628+ 7F11 3A 3A C0     		ld		a,(UBnkrotmatNosevZ+1)					; get nosev x sign
 629+ 7F14 4F           		ld		c,a								; temp save
 630+ 7F15 E6 80        		and		$80
 631+ 7F17 FD AC        		xor		iyh								; flip from saved multiply sign result
 632+ 7F19 FD 67        		ld		iyh,a							; save nosesev sign to iyh
 633+ 7F1B 79           		ld		a,c								; recover a
 634+ 7F1C E6 7F        		and		$7F								; a is unsigned nosev x
 635+ 7F1E 42           		ld		b,d
 636+ 7F1F 4B           		ld		c,e								; bc = nosev_y´ * roofv_y + nosev_z´ * roofv_z
 637+ 7F20 57           		ld		d,a								; de = nosev x hi
 638+ 7F21 1E 00        		ld		e,0
 639+ 7F23 CD 7C 73     		call	BC_Div_DE
 640+ 7F26 FD 7C        		ld		a,iyh
 641+ 7F28 EE 80        		xor		$80
 642+ 7F2A E6 80        		and		$80
 643+ 7F2C B0           		or		b
 644+ 7F2D C9           		ret
 645+ 7F2E
# file closed: ../../Maths/Utilities/tidy.asm
 646  7F2E                  INCLUDE "../../Maths/Utilities/LL28AequAmul256DivD.asm"
# file opened: ../../Maths/Utilities/LL28AequAmul256DivD.asm
   1+ 7F2E
   2+ 7F2E              LL28Amul256DivD:        JumpIfAGTENusng  d, .Ll28Exit255
   2+ 7F2E BA          >                        cp     d
   2+ 7F2F D2 4D 7F    >                        jp		nc,.Ll28Exit255
   3+ 7F32 1E FE                                ld      e,%11111110                 ; Set R to have bits 1-7 set, so we can rotate through 7
   4+ 7F34 CB 27        .LL31:                  sla     a
   5+ 7F36 38 0D                                jr      c,.LL29
   6+ 7F38                                      JumpIfALTNusng  d, .SkipSub         ; will jump if carry set, so we need to reset on the rol
   6+ 7F38 BA          >                        cp      d
   6+ 7F39 DA 3E 7F    >                        jp		c, .SkipSub
   7+ 7F3C 92                                   sub     d
   8+ 7F3D                                      ClearCarryFlag                      ; reset clarry as it will be complimented for rotate as 6502 does carry flags inverted
   8+ 7F3D B7          >                        or a
   9+ 7F3E 3F           .SkipSub:               ccf                                 ; if we did the subtract the carry will be clear so we need to invert to roll in.
  10+ 7F3F CB 13                                rl      e
  11+ 7F41 38 F1                                jr      c,.LL31
  12+ 7F43 7B                                   ld      a,e
  13+ 7F44 C9                                   ret
  14+ 7F45 92           .LL29:                  sub     d                           ; A >= Q, so set A = A - Q
  15+ 7F46 37                                   scf                                 ; Set the C flag to rotate into the result in R
  16+ 7F47 CB 13                                rl      e                           ; rotate counter e left
  17+ 7F49 38 E9                                jr      c,.LL31                     ; if a bit was spat off teh end then loop
  18+ 7F4B 7B                                   ld      a,e                         ; stick result in a
  19+ 7F4C C9                                   ret
  20+ 7F4D 3E FF        .Ll28Exit255:           ld  a,255                           ; Fail with FF as result
  21+ 7F4F C9                                   ret
  22+ 7F50
  23+ 7F50              ;-- Name: LL28 Calculate R = 256 * A / Q
  24+ 7F50              ;-- LL28+4              Skips the A >= Q check and always returns with C flag cleared, so this can be called if we know the division will work
  25+ 7F50              ;-- LL31                Skips the A >= Q check and does not set the R counter, so this can be used for jumping straight into the division loop if R is already set to 254 and we know the division will work
  26+ 7F50              ;   Reg mapping 6502  Z80
  27+ 7F50              ;               a     a
  28+ 7F50              ;               b     x
  29+ 7F50              ;               c     q
  30+ 7F50              ;               d     r
  31+ 7F50              ;
  32+ 7F50 21 85 EF     LL28Amul256DivD_6502:   ld      hl,Qvar                 ; CMP Q                  \ If A >= Q, then the answer will not fit in one byte,
  33+ 7F53 4E                                   ld      c,(hl)                  ; using c as Q var
  34+ 7F54 B9                                   cp      c
  35+ 7F55                                      FlipCarryFlag
  35+ 7F55 3F          >                        ccf
  36+ 7F56 DA 7E 7F                             jp      c, .LL2_6502            ; BCS LL2                \ so jump to LL2 to return 255
  37+ 7F59 06 FE                                ld      b,$FE                   ; LDX #%11111110         \ Set R to have bits 1-7 set, so we can rotate through 7 loop iterations, getting a 1 each time, and then we use b as Rvar
  38+ 7F5B CB 27        .LL31_6502:             sla     a                       ; ASL A                  \ Shift A to the left
  39+ 7F5D DA 72 7F                             jp      c,.LL29_6502            ; BCS LL29               \ If bit 7 of A was set, then jump straight to the subtraction
  40+ 7F60                                      FlipCarryFlag                   ;                          If A < N, then C flag is set.
  40+ 7F60 3F          >                        ccf
  41+ 7F61                                      JumpIfALTNusng c, .LL31_SKIPSUB_6502 ; CMP Q              \ If A < Q, skip the following subtraction
  41+ 7F61 B9          >                        cp      c
  41+ 7F62 DA 67 7F    >                        jp		c, .LL31_SKIPSUB_6502
  42+ 7F65                                                                      ; BCC P%+4
  43+ 7F65 91                                   sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  44+ 7F66                                      ClearCarryFlag
  44+ 7F66 B7          >                        or a
  45+ 7F67              .LL31_SKIPSUB_6502:     FlipCarryFlag
  45+ 7F67 3F          >                        ccf
  46+ 7F68 CB 10                                rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  47+ 7F6A DA 5B 7F                             jp      c, .LL31_6502           ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  48+ 7F6D 78                                   ld      a,b
  49+ 7F6E 32 86 EF                             ld      (Rvar),a
  50+ 7F71 C9                                   ret                             ; RTS                    \ R left with remainder of division
  51+ 7F72 91           .LL29_6502:             sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  52+ 7F73                                      SetCarryFlag                    ; SEC                    \ Set the C flag to rotate into the result in R
  52+ 7F73 37          >                        scf
  53+ 7F74 CB 10                                rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  54+ 7F76 DA 5B 7F                             jp      c, .LL31_6502           ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  55+ 7F79 78                                   ld      a,b                     ; RTS                    \ Return from the subroutine with R containing the
  56+ 7F7A 32 86 EF                             ld      (Rvar),a                ; .
  57+ 7F7D C9                                   ret                             ; .                      \ remainder of the division
  58+ 7F7E 3E FF        .LL2_6502:              ld      a,$FF                   ; LDA #255               \ The division is very close to 1, so return the closest
  59+ 7F80 32 86 EF                             ld      (Rvar),a                ; STA R                  \ possible answer to 256, i.e. R = 255
  60+ 7F83                                      SetCarryFlag                    ; we failed so need carry flag set
  60+ 7F83 37          >                        scf
  61+ 7F84 C9                                   ret                             ; RTS                    \ Return from the subroutine
  62+ 7F85
  63+ 7F85
  64+ 7F85 21 5F 69     LL28Amul256DivQ_6502:   ld      hl,varQ                 ; CMP Q                  \ If A >= Q, then the answer will not fit in one byte,
  65+ 7F88 4E                                   ld      c,(hl)                  ; using c as Q var
  66+ 7F89 B9                                   cp      c
  67+ 7F8A                                      FlipCarryFlag
  67+ 7F8A 3F          >                        ccf
  68+ 7F8B DA B3 7F                             jp      c, .LL2_6502            ; BCS LL2                \ so jump to LL2 to return 255
  69+ 7F8E 06 FE                                ld      b,$FE                   ; LDX #%11111110         \ Set R to have bits 1-7 set, so we can rotate through 7 loop iterations, getting a 1 each time, and then we use b as Rvar
  70+ 7F90 CB 27        .LL31_6502:             sla     a                       ; ASL A                  \ Shift A to the left
  71+ 7F92 DA A7 7F                             jp      c,.LL29_6502            ; BCS LL29               \ If bit 7 of A was set, then jump straight to the subtraction
  72+ 7F95                                      FlipCarryFlag                   ;                          If A < N, then C flag is set.
  72+ 7F95 3F          >                        ccf
  73+ 7F96                                      JumpIfALTNusng c, .LL31_SKIPSUB_6502 ; CMP Q              \ If A < Q, skip the following subtraction
  73+ 7F96 B9          >                        cp      c
  73+ 7F97 DA 9C 7F    >                        jp		c, .LL31_SKIPSUB_6502
  74+ 7F9A                                                                      ; BCC P%+4
  75+ 7F9A 91                                   sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  76+ 7F9B                                      ClearCarryFlag
  76+ 7F9B B7          >                        or a
  77+ 7F9C              .LL31_SKIPSUB_6502:     FlipCarryFlag
  77+ 7F9C 3F          >                        ccf
  78+ 7F9D CB 10                                rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  79+ 7F9F DA 90 7F                             jp      c, .LL31_6502           ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  80+ 7FA2 78                                   ld      a,b
  81+ 7FA3 32 60 69                             ld      (varR),a
  82+ 7FA6 C9                                   ret                             ; RTS                    \ R left with remainder of division
  83+ 7FA7 91           .LL29_6502:             sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  84+ 7FA8                                      SetCarryFlag                    ; SEC                    \ Set the C flag to rotate into the result in R
  84+ 7FA8 37          >                        scf
  85+ 7FA9 CB 10                                rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  86+ 7FAB DA 90 7F                             jp      c, .LL31_6502           ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  87+ 7FAE 78                                   ld      a,b                     ; RTS                    \ Return from the subroutine with R containing the
  88+ 7FAF 32 60 69                             ld      (varR),a                ; .
  89+ 7FB2 C9                                   ret                             ; .                      \ remainder of the division
  90+ 7FB3 3E FF        .LL2_6502:              ld      a,$FF                   ; LDA #255               \ The division is very close to 1, so return the closest
  91+ 7FB5 32 60 69                             ld      (varR),a                ; STA R                  \ possible answer to 256, i.e. R = 255
  92+ 7FB8                                      SetCarryFlag                    ; we failed so need carry flag set
  92+ 7FB8 37          >                        scf
  93+ 7FB9 C9                                   ret                             ; RTS                    \ Return from the subroutine
  94+ 7FBA
# file closed: ../../Maths/Utilities/LL28AequAmul256DivD.asm
 647  7FBA                  INCLUDE "../../Maths/Utilities/XAequMinusXAPplusRSdiv96-TIS1.asm"
# file opened: ../../Maths/Utilities/XAequMinusXAPplusRSdiv96-TIS1.asm
   1+ 7FBA              XAequMinusXAplusRSdiv96:					;.TIS1	\ -> &293B  \ Tidy subroutine 1  X.A =  (-X*A  + (R.S))/96
   2+ 7FBA              TIS1:
   3+ 7FBA 08           		ex		af,af'
   4+ 7FBB 3A 48 68     		ld		a,(regX)
   5+ 7FBE 47           		ld		b,a
   6+ 7FBF 08           		ex		af,af'
   7+ 7FC0              BAequMinusBAplusRSdiv96:					;.TIS1	\ -> &293B  \ Tidy subroutine 1 using B register = X
   8+ 7FC0 08           		ex		af,af'
   9+ 7FC1 78           		ld		a,b
  10+ 7FC2 32 5F 69     		ld		(varQ),a
  11+ 7FC5 08           		ex		af,af'
  12+ 7FC6 EE 80        		xor		$80							;	 flip sign of Acc
  13+ 7FC8 CD C0 6D     		call	madXAequQmulAaddRS			; \ MAD \ multiply and add (X,A) =  -X*A  + (R,S)
  14+ 7FCB              ; USES 				A BC E
  15+ 7FCB              ; DOES NOT USE		D HL
  16+ 7FCB              Div96:										; .DVID96	\ Their comment A=A/96: answer is A*255/96
  17+ 7FCB 47           		ld		b,a
  18+ 7FCC E6 80        		and		$80							;	hi sign
  19+ 7FCE 5F           		ld		e,a							;   e = varT
  20+ 7FCF 78           		ld		a,b
  21+ 7FD0 E6 7F        		and		$7F							;	hi A7
  22+ 7FD2 06 FE        		ld		b,$FE						;   slide counter
  23+ 7FD4 48           		ld		c,b							;   c == T1 ::  T1
  24+ 7FD5              .DVL3:										;   roll T1  clamp Acc to #96 for rotation matrix unity
  25+ 7FD5 CB 27        		sla		a
  26+ 7FD7 FE 60        		cp		$60							; max 96
  27+ 7FD9 30 02        		jr		nc,.DV4
  28+ 7FDB DE 60        		sbc		a,$60							;  SBC #&60
  29+ 7FDD              .DV4:										; skip subtraction
  30+ 7FDD CB 11        		rl		c							;  T1
  31+ 7FDF 38 F4        		jr		c,.DVL3
  32+ 7FE1 79           		ld		a,c							;   T1
  33+ 7FE2 B3           		or		e							;   restore T sign
  34+ 7FE3 C9           		ret
  35+ 7FE4
# file closed: ../../Maths/Utilities/XAequMinusXAPplusRSdiv96-TIS1.asm
 648  7FE4                  INCLUDE "../../Menus/common_menu.asm"
# file opened: ../../Menus/common_menu.asm
   1+ 7FE4 43 4F 4D 4D  txt_commander 			DB "COMMANDER",0
   1+ 7FE8 41 4E 44 45
   1+ 7FEC 52 00
   2+ 7FEE 49 4E 56 45  txt_inventory 			DB "INVENTORY",0
   2+ 7FF2 4E 54 4F 52
   2+ 7FF6 59 00
   3+ 7FF8 50 72 65 73  txt_present_system		DB "Present System   :",0
   3+ 7FFC 65 6E 74 20
   3+ 8000 53 79 73 74
   3+ 8004 65 6D 20 20
   3+ 8008 20 3A 00
   4+ 800B 48 79 70 65  txt_hyperspace_system	DB "Hyperspace System:",0
   4+ 800F 72 73 70 61
   4+ 8013 63 65 20 53
   4+ 8017 79 73 74 65
   4+ 801B 6D 3A 00
   5+ 801E 43 6F 6E 64  txt_condition			DB "Condition   :",0
   5+ 8022 69 74 69 6F
   5+ 8026 6E 20 20 20
   5+ 802A 3A 00
   6+ 802C 46 75 65 6C  txt_fuel				DB "Fuel        :",0
   6+ 8030 20 20 20 20
   6+ 8034 20 20 20 20
   6+ 8038 3A 00
   7+ 803A 43 61 73 68  txt_cash				DB "Cash        :",0
   7+ 803E 20 20 20 20
   7+ 8042 20 20 20 20
   7+ 8046 3A 00
   8+ 8048 4C 65 67 61  txt_legal_status		DB "Legal Status:",0
   8+ 804C 6C 20 53 74
   8+ 8050 61 74 75 73
   8+ 8054 3A 00
   9+ 8056 52 61 74 69  txt_rating				DB "Rating      :",0
   9+ 805A 6E 67 20 20
   9+ 805E 20 20 20 20
   9+ 8062 3A 00
  10+ 8064 45 51 55 49  txt_equipment			DB "EQUIPMENT:",0
  10+ 8068 50 4D 45 4E
  10+ 806C 54 3A 00
  11+ 806F
  12+ 806F 30 30 2E 30  txt_fuel_level			DB "00.0 Light Years",0
  12+ 8073 20 4C 69 67
  12+ 8077 68 74 20 59
  12+ 807B 65 61 72 73
  12+ 807F 00
  13+ 8080 58 58 58 58  txt_cash_amount			DB "XXXXXXXXXX",0
  13+ 8084 58 58 58 58
  13+ 8088 58 58 00
  14+ 808B 2E           txt_cash_decimal        DB "."
  15+ 808C 58 20 43 72  txt_cash_fraction       DB "X Cr",0
  15+ 8090 00
  16+ 8091
  17+ 8091              txt_status_colour		equ $FF
  18+ 8091
  19+ 8091              ;;DEFUNCTprint_boiler_text_l2:
  20+ 8091              ;;DEFUNCT; ">print_boilder_text hl = text structure, b = message count"
  21+ 8091              ;;DEFUNCTBoilerTextLoop:
  22+ 8091              ;;DEFUNCT	push		bc			; Save Message Count loop value
  23+ 8091              ;;DEFUNCT	ld			c,(hl)		; Get Row into b
  24+ 8091              ;;DEFUNCT	inc			hl
  25+ 8091              ;;DEFUNCT	ld			b,(hl)		; Get Col into b
  26+ 8091              ;;DEFUNCT	inc			hl
  27+ 8091              ;;DEFUNCT	ld			e,(hl)		; Get text address Lo into E
  28+ 8091              ;;DEFUNCT	inc			hl
  29+ 8091              ;;DEFUNCT	ld			d,(hl)		; Get text address Hi into E
  30+ 8091              ;;DEFUNCT	inc			hl
  31+ 8091              ;;DEFUNCT	push		hl			; Save present HL to stack as this is the address for the next message
  32+ 8091              ;;DEFUNCT	ex			de,hl		; now hl = address of text data
  33+ 8091              ;;DEFUNCT	ld			e,txt_status_colour
  34+ 8091              ;;DEFUNCT    MMUSelectLayer2
  35+ 8091              ;;DEFUNCT	call		l1_print_at
  36+ 8091              ;;DEFUNCT	pop			hl
  37+ 8091              ;;DEFUNCT	pop			bc
  38+ 8091              ;;DEFUNCT	djnz		BoilerTextLoop
  39+ 8091              ;;DEFUNCT	ret
  40+ 8091
  41+ 8091
  42+ 8091              ;:DEFUNCT print_boiler_text:
  43+ 8091              ;:DEFUNCT ; ">print_boilder_text hl = text structure, b = message count"
  44+ 8091              ;:DEFUNCT .BoilerTextLoop:
  45+ 8091              ;:DEFUNCT 	push		bc			; Save Message Count loop value
  46+ 8091              ;:DEFUNCT 	ld			c,(hl)		; Get Row into b
  47+ 8091              ;:DEFUNCT 	inc			hl
  48+ 8091              ;:DEFUNCT 	ld			b,(hl)		; Get Col into b
  49+ 8091              ;:DEFUNCT 	inc			hl
  50+ 8091              ;:DEFUNCT 	ld			e,(hl)		; Get text address Lo into E
  51+ 8091              ;:DEFUNCT 	inc			hl
  52+ 8091              ;:DEFUNCT 	ld			d,(hl)		; Get text address Hi into E
  53+ 8091              ;:DEFUNCT 	inc			hl
  54+ 8091              ;:DEFUNCT 	push		hl			; Save present HL to stack as this is the address for the next message
  55+ 8091              ;:DEFUNCT 	ex			de,hl		; now hl = address of text data
  56+ 8091              ;:DEFUNCT 	ld			e,txt_status_colour
  57+ 8091              ;:DEFUNCT 	push		bc
  58+ 8091              ;:DEFUNCT 	pop			de
  59+ 8091              ;:DEFUNCT 	call		l1_print_at
  60+ 8091              ;:DEFUNCT 	pop			hl
  61+ 8091              ;:DEFUNCT 	pop			bc
  62+ 8091              ;:DEFUNCT 	djnz		.BoilerTextLoop
  63+ 8091              ;:DEFUNCT 	ret
  64+ 8091
  65+ 8091              ;;DEFUNCTGetFuelLevel:           INCLUDE "Menus/get_fuel_level_inlineinclude.asm"
  66+ 8091
  67+ 8091              ;;DEFUNCTGetCash:                ld      hl,(Cash)
  68+ 8091              ;;DEFUNCT                        ex      de,hl
  69+ 8091              ;;DEFUNCT                        ld      ix,(Cash+2)
  70+ 8091              ;;DEFUNCT                        ld		iy,txt_cash_amount
  71+ 8091              ;;DEFUNCT                        call 	DispDEIXtoIY	; This will write out with 0 termination after last digit
  72+ 8091              ;;DEFUNCT.ShiftDecimalDigit:     ld		a,(IY+0)				;Push last digit to post decimal
  73+ 8091              ;;DEFUNCT                        ld		(txt_cash_fraction),a
  74+ 8091              ;;DEFUNCT.UpdateInteger:         ld		hl,txt_cash_amount+1	; Now was there only 1 digit
  75+ 8091              ;;DEFUNCT                        ld		a,(hl)					; if so we leave it alone so its "0.0"
  76+ 8091              ;;DEFUNCT                        cp		0
  77+ 8091              ;;DEFUNCT                        ret		z
  78+ 8091              ;;DEFUNCT                        ld		(IY),0					; Else we erase last digit as it went to fraction
  79+ 8091              ;;DEFUNCT                        ret
  80+ 8091
# file closed: ../../Menus/common_menu.asm
 649  8091              MainNonBankedCodeEnd:
 650  8091                  DISPLAY "Main Non Banked Code Ends at ",$
 651  8091
 652  8091              ; Bank 57  ------------------------------------------------------------------------------------------------------------------------
 653  8091                  SLOT    LAYER2Addr
 654  8091                  PAGE    BankLAYER2
 655  8091                  ORG     LAYER2Addr
 656  E000
 657  E000                  INCLUDE "../../Layer2Graphics/layer2_bank_select.asm"
# file opened: ../../Layer2Graphics/layer2_bank_select.asm
   1+ E000
   2+ E000 00           varL2_BANK_SELECTED			 DB	0
   3+ E001 00           varL2_CURRENT_BANK           DB	0
   4+ E002 00           varL2_BUFFER_MODE            DB 0
   5+ E003 00           varL2_ACCESS_MODE            DB 0
   6+ E004
   7+ E004 3E 08        asm_l2_double_buffer_on:    ld      a,8
   8+ E006 32 02 E0                                 ld      (varL2_BUFFER_MODE),a
   9+ E009 C9                                       ret
  10+ E00A
  11+ E00A AF           asm_l2_double_buffer_off:   xor     a
  12+ E00B 32 02 E0                                 ld      (varL2_BUFFER_MODE),a
  13+ E00E C9                                       ret
  14+ E00F
  15+ E00F 01 3B 12     asm_disable_l2_readwrite:   ld      bc, IO_LAYER2_PORT
  16+ E012 ED 70                                    in      (c)
  17+ E014 32 03 E0                                 ld      (varL2_ACCESS_MODE),a
  18+ E017 E6 FA                                    and     LAYER2_DISABLE_MEM_ACCESS
  19+ E019 ED 79                                    out     (c),a
  20+ E01B C9                                       ret
  21+ E01C
  22+ E01C 3A 03 E0     asm_restore_l2_readwrite:   ld      a,(varL2_ACCESS_MODE)
  23+ E01F E6 05                                    and     LAYER2_READ_WRITE_MASK
  24+ E021 57                                       ld      d,a
  25+ E022 01 3B 12                                 ld      bc, IO_LAYER2_PORT
  26+ E025 ED 70                                    in      (c)
  27+ E027 32 03 E0                                 ld      (varL2_ACCESS_MODE),a
  28+ E02A A2                                       and     d
  29+ E02B ED 79                                    out     (c),a
  30+ E02D C9                                       ret
  31+ E02E
  32+ E02E 01 3B 12     asm_enable_l2_readwrite:    ld      bc, IO_LAYER2_PORT
  33+ E031 ED 70                                    in      (c)
  34+ E033 F6 05                                    or      LAYER2_READ_WRITE_MASK
  35+ E035 ED 79                                    out     (c),a
  36+ E037 C9                                       ret
  37+ E038
  38+ E038              ; "asm_l2_bank_select"
  39+ E038              ; " a = sepecific bank mask value to select, does not set varL2_BANK_SELECTED"
  40+ E038 57           asm_l2_bank_select:         ld      d,a
  41+ E039 FE 00                                    cp      0
  42+ E03B 28 08                                    jr      z,.NotBreakDebug
  43+ E03D FE 40                                    cp      $40
  44+ E03F 28 04                                    jr      z,.NotBreakDebug
  45+ E041 FE 80                                    cp      $80
  46+ E043 28 00                                    jr      z,.NotBreakDebug
  47+ E045              .NotBreakDebug:
  48+ E045 3A 02 E0                                 ld      a,(varL2_BUFFER_MODE)
  49+ E048 F6 03                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK
  50+ E04A B2                                       or      d; | LAYER2_SHADOW_SCREEN_MASK
  51+ E04B 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
  52+ E04E ED 79                                    out 	(c),a
  53+ E050 C9                                       ret
  54+ E051              ;  "asm_l2_bank_select a = sepecific bank number to select, dsets varL2_BANK_SELECTED"
  55+ E051 32 00 E0     asm_l2_bank_n_select:       ld		(varL2_BANK_SELECTED),a
  56+ E054 FE 00                                    cp		0
  57+ E056 20 04                                    jr 		nz,.nottopbank
  58+ E058 3E 00        .topbank:                   ld		a,LAYER2_SHIFTED_SCREEN_TOP
  59+ E05A 18 DC                                    jr		asm_l2_bank_select
  60+ E05C FE 01        .nottopbank:                cp		1
  61+ E05E 20 04                                    jr 		nz,.notmiddlebank
  62+ E060 3E 40        .middlebank:                ld		a,LAYER2_SHIFTED_SCREEN_MIDDLE
  63+ E062 18 D4                                    jr		asm_l2_bank_select
  64+ E064 3E 80        .notmiddlebank:             ld		a,LAYER2_SHIFTED_SCREEN_BOTTOM ; default to bottom
  65+ E066 18 D0                                    jr		asm_l2_bank_select
  66+ E068              		; Note no ret as its handled by above routines
  67+ E068
  68+ E068              asm_l2_bank_0_macro:        MACRO
  69+ E068 ~                                        ld      a,(varL2_BUFFER_MODE)
  70+ E068 ~                                        or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
  71+ E068 ~                                        ld 		bc, IO_LAYER2_PORT
  72+ E068 ~                                        out 	(c),a
  73+ E068 ~                                      ;  ld      a,%0001000              ; Bank offset of + 1
  74+ E068 ~                                      ;  out     (c),a
  75+ E068 ~                                        ZeroA						; set a to 0
  76+ E068 ~                                        ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  77+ E068                                          ENDM
  78+ E068
  79+ E068              asm_l2_bank_1_macro:        MACRO
  80+ E068 ~                                        ld      a,(varL2_BUFFER_MODE)
  81+ E068 ~                                        or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
  82+ E068 ~                                        ld 		bc, IO_LAYER2_PORT
  83+ E068 ~                                        out 	(c),a
  84+ E068 ~                                       ; ld      a,%0001000              ; Bank offset of + 1
  85+ E068 ~                                      ;  out     (c),a
  86+ E068 ~                                        ld      a,1						; set a to 0
  87+ E068 ~                                        ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  88+ E068                                          ENDM
  89+ E068
  90+ E068              asm_l2_bank_2_macro:        MACRO
  91+ E068 ~                                        ld      a,(varL2_BUFFER_MODE)
  92+ E068 ~                                        or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
  93+ E068 ~                                        ld 		bc, IO_LAYER2_PORT
  94+ E068 ~                                        out 	(c),a
  95+ E068 ~                                      ;  ld      a,%0001000              ; Bank offset of + 1
  96+ E068 ~                                       ; out     (c),a
  97+ E068 ~                                        ld      a,2						; set a to 0
  98+ E068 ~                                        ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  99+ E068                                          ENDM
 100+ E068
 101+ E068              asm_l2_bank_3_macro:        MACRO
 102+ E068 ~                                        ld      a,(varL2_BUFFER_MODE)
 103+ E068 ~                                        or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
 104+ E068 ~                                        or      %0001011
 105+ E068 ~                                        ld 		bc, IO_LAYER2_PORT
 106+ E068 ~                                        out 	(c),a
 107+ E068 ~                                        ld      a,3						; set a to 0
 108+ E068 ~                                        ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 109+ E068                                          ENDM
 110+ E068
 111+ E068              asm_l2_bank_4_macro:        MACRO
 112+ E068 ~                                        ld      a,(varL2_BUFFER_MODE)
 113+ E068 ~                                        or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
 114+ E068 ~                                        ld 		bc, IO_LAYER2_PORT
 115+ E068 ~                                        out 	(c),a
 116+ E068 ~                                        ld      a,4						; set a to 0
 117+ E068 ~                                        ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 118+ E068                                          ENDM
 119+ E068
 120+ E068              ; "asm_l2_row_bank_select"
 121+ E068              ; "A (unsinged) = y row of pixel line from top, sets the bank to top middle or bottom and adjusts a reg to row memory address"
 122+ E068              ; "Could optimise by holding the previous bank but given its only an out statement it may not save T states at all"
 123+ E068              ; "destroys BC call de is safe a = adjusted poke pixel row"
 124+ E068              asm_l2_row_bank_select:     JumpIfAGTENusng 128, .BottomBank
 124+ E068 FE 80       >                        cp     128
 124+ E06A D2 A6 E0    >                        jp		nc,.BottomBank
 125+ E06D                                          JumpIfAGTENusng 64, .MiddleBank
 125+ E06D FE 40       >                        cp     64
 125+ E06F D2 8A E0    >                        jp		nc,.MiddleBank
 126+ E072 08                                       ex      af,af'
 127+ E073                                          JumpIfMemZero varL2_BANK_SELECTED, .NoTopChange
 127+ E073 3A 00 E0    >                        ld  a,(varL2_BANK_SELECTED)
 127+ E076 A7          >                        and a
 127+ E077 CA 88 E0    >                        jp  z,.NoTopChange
 128+ E07A                                          asm_l2_bank_0_macro
 128+ E07A 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 128+ E07D F6 03       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
 128+ E07F 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 128+ E082 ED 79       >                            out 	(c),a
 128+ E084             >                          ;  ld      a,%0001000              ; Bank offset of + 1
 128+ E084             >                          ;  out     (c),a
 128+ E084             >                            ZeroA						; set a to 0
 128+ E084 AF          >                        xor a
 128+ E085 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 129+ E088 08           .NoTopChange:               ex      af,af'
 130+ E089 C9                                       ret
 131+ E08A 08           .MiddleBank:                ex      af,af'
 132+ E08B                                          JumpIfMemEqNusng varL2_BANK_SELECTED, 1, .NoMiddleChange
 132+ E08B 3A 00 E0    >                        ld  a,(varL2_BANK_SELECTED)
 132+ E08E FE 01       >                        cp  1
 132+ E090 CA A2 E0    >                        jp  z,.NoMiddleChange
 133+ E093                                          asm_l2_bank_1_macro
 133+ E093 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 133+ E096 F6 43       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
 133+ E098 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 133+ E09B ED 79       >                            out 	(c),a
 133+ E09D             >                           ; ld      a,%0001000              ; Bank offset of + 1
 133+ E09D             >                          ;  out     (c),a
 133+ E09D 3E 01       >                            ld      a,1						; set a to 0
 133+ E09F 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 134+ E0A2 08           .NoMiddleChange:            ex      af,af'
 135+ E0A3 D6 40                                    sub     64
 136+ E0A5 C9                                       ret
 137+ E0A6 08           .BottomBank:                ex      af,af'
 138+ E0A7                                          JumpIfMemEqNusng varL2_BANK_SELECTED, 2, .NoBottomChange
 138+ E0A7 3A 00 E0    >                        ld  a,(varL2_BANK_SELECTED)
 138+ E0AA FE 02       >                        cp  2
 138+ E0AC CA BE E0    >                        jp  z,.NoBottomChange
 139+ E0AF                                          asm_l2_bank_2_macro
 139+ E0AF 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 139+ E0B2 F6 83       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 139+ E0B4 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 139+ E0B7 ED 79       >                            out 	(c),a
 139+ E0B9             >                          ;  ld      a,%0001000              ; Bank offset of + 1
 139+ E0B9             >                           ; out     (c),a
 139+ E0B9 3E 02       >                            ld      a,2						; set a to 0
 139+ E0BB 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 140+ E0BE 08           .NoBottomChange:            ex      af,af'
 141+ E0BF D6 80                                    sub     128
 142+ E0C1 C9                                       ret
 143+ E0C2
 144+ E0C2
 145+ E0C2              ; "asm_l2_row_bank_select"
 146+ E0C2              ; "HL (unsinged) = x column of pixel line from left
 147+ E0C2              ; 0-  63
 148+ E0C2              ; 64- 127
 149+ E0C2              ; 128 - 191
 150+ E0C2              ; 192 - 255
 151+ E0C2              ; 256 - 321
 152+ E0C2              ; outputs l with the correct column number
 153+ E0C2 7A           asm_l2_320_col_bank_select: ld      a,d
 154+ E0C3                                          JumpIfAIsNotZero .Bank5             ; 256 - 321
 154+ E0C3 A7          >                        and     a
 154+ E0C4 C2 27 E1    >                        jp	    nz,.Bank5
 155+ E0C7 7B                                       ld      a,e
 156+ E0C8                                          JumpIfAGTENusng 192, .Bank4
 156+ E0C8 FE C0       >                        cp     192
 156+ E0CA D2 10 E1    >                        jp		nc,.Bank4
 157+ E0CD                                          JumpIfAGTENusng 128, .Bank3
 157+ E0CD FE 80       >                        cp     128
 157+ E0CF D2 FB E0    >                        jp		nc,.Bank3
 158+ E0D2                                          JumpIfAGTENusng 64 , .Bank2
 158+ E0D2 FE 40       >                        cp     64
 158+ E0D4 D2 E6 E0    >                        jp		nc,.Bank2
 159+ E0D7              .Bank1:                     asm_l2_bank_0_macro
 159+ E0D7 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 159+ E0DA F6 03       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
 159+ E0DC 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 159+ E0DF ED 79       >                            out 	(c),a
 159+ E0E1             >                          ;  ld      a,%0001000              ; Bank offset of + 1
 159+ E0E1             >                          ;  out     (c),a
 159+ E0E1             >                            ZeroA						; set a to 0
 159+ E0E1 AF          >                        xor a
 159+ E0E2 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 160+ E0E5 C9                                       ret
 161+ E0E6              .Bank2:                     asm_l2_bank_1_macro
 161+ E0E6 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 161+ E0E9 F6 43       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
 161+ E0EB 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 161+ E0EE ED 79       >                            out 	(c),a
 161+ E0F0             >                           ; ld      a,%0001000              ; Bank offset of + 1
 161+ E0F0             >                          ;  out     (c),a
 161+ E0F0 3E 01       >                            ld      a,1						; set a to 0
 161+ E0F2 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 162+ E0F5                                          ClearCarryFlag
 162+ E0F5 B7          >                        or a
 163+ E0F6 7D                                       ld      a,l
 164+ E0F7 E6 BF                                    and     %10111111       ; fast subtract 64, just clear bit
 165+ E0F9 67                                       ld      h,a
 166+ E0FA C9                                       ret
 167+ E0FB              .Bank3:                     asm_l2_bank_2_macro
 167+ E0FB 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 167+ E0FE F6 83       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 167+ E100 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 167+ E103 ED 79       >                            out 	(c),a
 167+ E105             >                          ;  ld      a,%0001000              ; Bank offset of + 1
 167+ E105             >                           ; out     (c),a
 167+ E105 3E 02       >                            ld      a,2						; set a to 0
 167+ E107 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 168+ E10A                                          ClearCarryFlag
 168+ E10A B7          >                        or a
 169+ E10B 7D                                       ld      a,l
 170+ E10C E6 7F                                    and     %01111111       ; fast subtract 128, just clear bit
 171+ E10E 67                                       ld      h,a
 172+ E10F C9                                       ret
 173+ E110              .Bank4:                     asm_l2_bank_3_macro
 173+ E110 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 173+ E113 F6 03       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
 173+ E115 F6 0B       >                            or      %0001011
 173+ E117 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 173+ E11A ED 79       >                            out 	(c),a
 173+ E11C 3E 03       >                            ld      a,3						; set a to 0
 173+ E11E 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 174+ E121                                          ClearCarryFlag
 174+ E121 B7          >                        or a
 175+ E122 7B                                       ld      a,e
 176+ E123 E6 3F                                    and     %00111111       ; fast subtract 192, just clear bit
 177+ E125 67                                       ld      h,a
 178+ E126 C9                                       ret
 179+ E127              .Bank5:                     asm_l2_bank_4_macro
 179+ E127 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 179+ E12A F6 43       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
 179+ E12C 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 179+ E12F ED 79       >                            out 	(c),a
 179+ E131 3E 04       >                            ld      a,4						; set a to 0
 179+ E133 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 180+ E136 65                                       ld      h,l             ; fast subtract 256, just clear bit
 181+ E137 C9                                       ret
 182+ E138
 183+ E138              ;;;
 184+ E138              ;;;
 185+ E138              ;;;                            cp 		64			; row < 64?
 186+ E138              ;;;                            jr 		nc, .l2rowGTE64
 187+ E138              ;;;.l2rowLT64:                 ex		af,af'
 188+ E138              ;;;                            ;ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP | LAYER2_SHADOW_SCREEN_MASK
 189+ E138              ;;;                            ld      a,(varL2_BUFFER_MODE)
 190+ E138              ;;;                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
 191+ E138              ;;;                            ld 		bc, IO_LAYER2_PORT
 192+ E138              ;;;                            out 	(c),a
 193+ E138              ;;;                            xor		a						; set a to 0
 194+ E138              ;;;                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 195+ E138              ;;;                            ex		af,af'					; return pixel poke unharmed
 196+ E138              ;;;                            ret
 197+ E138              ;;;.l2rowGTE64:                cp 		128
 198+ E138              ;;;                            jr 		nc, .l2rowGTE128
 199+ E138              ;;;.l2row64to127:              ex		af,af'
 200+ E138              ;;;                    ;		ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE | LAYER2_SHADOW_SCREEN_MASK
 201+ E138              ;;;                            ld      a,(varL2_BUFFER_MODE)
 202+ E138              ;;;                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
 203+ E138              ;;;                            ld 		bc, IO_LAYER2_PORT
 204+ E138              ;;;                            out 	(c),a
 205+ E138              ;;;                            ld		a,1						; set a to 1
 206+ E138              ;;;                            ld		(varL2_BANK_SELECTED),a	; save selected bank
 207+ E138              ;;;                            ex		af,af'
 208+ E138              ;;;                            sub		64
 209+ E138              ;;;                            ret
 210+ E138              ;;;.l2rowGTE128:               ex		af,af'
 211+ E138              ;;;                    ;		ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM | LAYER2_SHADOW_SCREEN_MASK
 212+ E138              ;;;                            ld      a,(varL2_BUFFER_MODE)
 213+ E138              ;;;                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 214+ E138              ;;;
 215+ E138              ;;;                            ld 		bc, IO_LAYER2_PORT
 216+ E138              ;;;                            out 	(c),a
 217+ E138              ;;;                            ld		a,1						; set a to 2
 218+ E138              ;;;                            ld		(varL2_BANK_SELECTED),a	; save selected bank
 219+ E138              ;;;                            ex		af,af'
 220+ E138              ;;;                            sub		128
 221+ E138              ;;;                            ret
 222+ E138
 223+ E138
# file closed: ../../Layer2Graphics/layer2_bank_select.asm
 658  E138                  INCLUDE "../../Layer2Graphics/layer2_cls.asm"
# file opened: ../../Layer2Graphics/layer2_cls.asm
   1+ E138
   2+ E138 00           l2_cls_byte	            DB 0
   3+ E139              ; ">DMA Command BLOCK"
   4+ E139
   5+ E139 83 C3 C7 CB  l2_fill                 DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   5+ E13D 7D
   6+ E13E 38 E1        l2_fill_astrt           DW l2_cls_byte
   7+ E140 00 40        l2_fill_length          DB $00,$40
   8+ E142 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
   9+ E145 00 00        l2_fill_bstrt           DB $00,$00
  10+ E147 82 CF B3 87                          DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
  11+ E14B              l2_fill_cmd_len	        EQU $ - l2_fill
  12+ E14B
  13+ E14B 83 C3 C7 CB  l2_fill_burst           DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
  13+ E14F 7D
  14+ E150 38 E1        .l2_fill_astrt          DW l2_cls_byte
  15+ E152 00 40        .l2_fill_length         DB $00,$40
  16+ E154 24 10 CD                             DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_BURST_MODE
  17+ E157 00 00        .l2_fill_bstrt          DB $00,$00
  18+ E159 82 CF B3 87                          DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
  19+ E15D              l2_fill_burst_cmd_len   EQU $ - l2_fill_burst
  20+ E15D
  21+ E15D              ; ">l2_cls_dma_bank sets a bank to"
  22+ E15D              l2_cls_dma_bank:
  23+ E15D 32 38 E1     .set_colour:            ld (l2_cls_byte),a
  24+ E160 21 39 E1     .write_dma:             ld hl, l2_fill
  25+ E163 06 12                                ld b, l2_fill_cmd_len
  26+ E165 0E 6B                                ld	c,IO_DATAGEAR_DMA_PORT
  27+ E167 ED B3                                otir
  28+ E169 C9                                   ret
  29+ E16A
  30+ E16A              ; ">l2_cls_dma_bank sets a bank to"
  31+ E16A              l2_cls_dma_bank_burst:
  32+ E16A 32 38 E1     .set_colour:            ld (l2_cls_byte),a
  33+ E16D 21 4B E1     .write_dma:             ld hl, l2_fill_burst
  34+ E170 06 12                                ld b, l2_fill_burst_cmd_len
  35+ E172 0E 6B                                ld	c,IO_DATAGEAR_DMA_PORT
  36+ E174 ED B3                                otir
  37+ E176 C9                                   ret
  38+ E177
  39+ E177 3E 00        l2_set_color_upper2:    ld      a,0
  40+ E179 CD 68 E0                             call asm_l2_row_bank_select
  41+ E17C 3A 38 E1                             ld      a,(l2_cls_byte)
  42+ E17F CD 5D E1                             call l2_cls_dma_bank
  43+ E182 3E 40                                ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
  44+ E184 CD 68 E0                             call asm_l2_row_bank_select
  45+ E187 3A 38 E1                             ld      a,(l2_cls_byte)
  46+ E18A CD 5D E1                             call l2_cls_dma_bank
  47+ E18D C9                                   ret
  48+ E18E
  49+ E18E
  50+ E18E              l2_cls_upper_two_thirds:;ld a,0								; pretend we are plotting pixel on row 0 to force top selection
  51+ E18E                                      asm_l2_bank_0_macro ; call asm_l2_row_bank_select
  51+ E18E 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  51+ E191 F6 03       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
  51+ E193 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  51+ E196 ED 79       >                            out 	(c),a
  51+ E198             >                          ;  ld      a,%0001000              ; Bank offset of + 1
  51+ E198             >                          ;  out     (c),a
  51+ E198             >                            ZeroA						; set a to 0
  51+ E198 AF          >                        xor a
  51+ E199 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  52+ E19C 3E E3                                ld 	a,COLOUR_TRANSPARENT
  53+ E19E CD 5D E1                             call l2_cls_dma_bank
  54+ E1A1                                      ;ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
  55+ E1A1                                      asm_l2_bank_1_macro ;call asm_l2_row_bank_select
  55+ E1A1 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  55+ E1A4 F6 43       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
  55+ E1A6 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  55+ E1A9 ED 79       >                            out 	(c),a
  55+ E1AB             >                           ; ld      a,%0001000              ; Bank offset of + 1
  55+ E1AB             >                          ;  out     (c),a
  55+ E1AB 3E 01       >                            ld      a,1						; set a to 0
  55+ E1AD 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  56+ E1B0 3E E3                                ld 	a,COLOUR_TRANSPARENT
  57+ E1B2 CD 5D E1                             call l2_cls_dma_bank
  58+ E1B5 C9                                   ret
  59+ E1B6
  60+ E1B6              l2_cls_upper_two_thirds_burst:;ld a,0								; pretend we are plotting pixel on row 0 to force top selection
  61+ E1B6                                      asm_l2_bank_0_macro ; call asm_l2_row_bank_select
  61+ E1B6 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  61+ E1B9 F6 03       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
  61+ E1BB 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  61+ E1BE ED 79       >                            out 	(c),a
  61+ E1C0             >                          ;  ld      a,%0001000              ; Bank offset of + 1
  61+ E1C0             >                          ;  out     (c),a
  61+ E1C0             >                            ZeroA						; set a to 0
  61+ E1C0 AF          >                        xor a
  61+ E1C1 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  62+ E1C4 3E E3                                ld 	a,COLOUR_TRANSPARENT
  63+ E1C6 CD 6A E1                             call l2_cls_dma_bank_burst
  64+ E1C9                                      ;ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
  65+ E1C9                                      asm_l2_bank_1_macro ;call asm_l2_row_bank_select
  65+ E1C9 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  65+ E1CC F6 43       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
  65+ E1CE 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  65+ E1D1 ED 79       >                            out 	(c),a
  65+ E1D3             >                           ; ld      a,%0001000              ; Bank offset of + 1
  65+ E1D3             >                          ;  out     (c),a
  65+ E1D3 3E 01       >                            ld      a,1						; set a to 0
  65+ E1D5 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  66+ E1D8 3E E3                                ld 	a,COLOUR_TRANSPARENT
  67+ E1DA CD 6A E1                             call l2_cls_dma_bank_burst
  68+ E1DD C9                                   ret
  69+ E1DE
  70+ E1DE              l2_cls_lower_third:     ;ld a,128							; pretend we are plotting pixel on row 64 to force mid selection
  71+ E1DE                                      asm_l2_bank_2_macro; call asm_l2_row_bank_select
  71+ E1DE 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  71+ E1E1 F6 83       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
  71+ E1E3 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  71+ E1E6 ED 79       >                            out 	(c),a
  71+ E1E8             >                          ;  ld      a,%0001000              ; Bank offset of + 1
  71+ E1E8             >                           ; out     (c),a
  71+ E1E8 3E 02       >                            ld      a,2						; set a to 0
  71+ E1EA 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  72+ E1ED 3E E3                                ld 	a,COLOUR_TRANSPARENT
  73+ E1EF CD 5D E1                             call l2_cls_dma_bank
  74+ E1F2 C9                                   ret
  75+ E1F3
  76+ E1F3              l2_cls_lower_third_burst:asm_l2_bank_2_macro; call asm_l2_row_bank_select
  76+ E1F3 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  76+ E1F6 F6 83       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
  76+ E1F8 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  76+ E1FB ED 79       >                            out 	(c),a
  76+ E1FD             >                          ;  ld      a,%0001000              ; Bank offset of + 1
  76+ E1FD             >                           ; out     (c),a
  76+ E1FD 3E 02       >                            ld      a,2						; set a to 0
  76+ E1FF 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  77+ E202 3E E3                                ld 	a,COLOUR_TRANSPARENT
  78+ E204 CD 6A E1                             call l2_cls_dma_bank_burst
  79+ E207 C9                                   ret
  80+ E208
  81+ E208
  82+ E208 CD B6 E1     l2_cls_burst:           call l2_cls_upper_two_thirds_burst
  83+ E20B C3 F3 E1                             jp   l2_cls_lower_third_burst
  84+ E20E
  85+ E20E
  86+ E20E CD 8E E1     l2_cls:                 call l2_cls_upper_two_thirds
  87+ E211 C3 DE E1                             jp   l2_cls_lower_third
  88+ E214
  89+ E214              l2_320_cls:
  90+ E214 CD 8E E1     l2_640_cls:             call l2_cls_upper_two_thirds
  91+ E217 CD DE E1                             call   l2_cls_lower_third
  92+ E21A                                      ; need to clear banks 4 and 5 via normal paging, say into C000 with interrupts disabled
  93+ E21A                                      asm_l2_bank_3_macro
  93+ E21A 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  93+ E21D F6 03       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
  93+ E21F F6 0B       >                            or      %0001011
  93+ E221 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  93+ E224 ED 79       >                            out 	(c),a
  93+ E226 3E 03       >                            ld      a,3						; set a to 0
  93+ E228 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  94+ E22B 3E E3                                ld 	a,COLOUR_TRANSPARENT
  95+ E22D CD 5D E1                             call l2_cls_dma_bank
  96+ E230                                      asm_l2_bank_4_macro
  96+ E230 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  96+ E233 F6 43       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
  96+ E235 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  96+ E238 ED 79       >                            out 	(c),a
  96+ E23A 3E 04       >                            ld      a,4						; set a to 0
  96+ E23C 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  97+ E23F 3E E3                                ld 	a,COLOUR_TRANSPARENT
  98+ E241 CD 5D E1                             call l2_cls_dma_bank
  99+ E244
 100+ E244 C9                                   ret
 101+ E245
# file closed: ../../Layer2Graphics/layer2_cls.asm
 659  E245                  INCLUDE "../../Layer2Graphics/layer2_initialise.asm"
# file opened: ../../Layer2Graphics/layer2_initialise.asm
   1+ E245
   2+ E245 ED 91 70 00  l2_initialise:          nextreg     LAYER_2_CONTROL_REGISTER,           %00000000               ; 256x192x8bpp
   3+ E249 ED 91 12 08                          nextreg		LAYER2_RAM_PAGE_REGISTER,          	LAYER2_SCREEN_BANK1
   4+ E24D ED 91 13 0D                          nextreg		LAYER2_RAM_SHADOW_REGISTER,     	LAYER2_SHADOW_BANK1
   5+ E251 ED 91 14 E3                          nextreg		TRANSPARENCY_COLOUR_REGISTER, 		COLOUR_TRANSPARENT
   6+ E255                                      ZeroA
   6+ E255 AF          >                        xor a
   7+ E256                                      DoubleBufferIfPossible
   7+ E256             >                        IFDEF DOUBLEBUFFER
   7+ E256 ~           >                            MMUSelectLayer2
   7+ E256 ~           >                            call  l2_cls
   7+ E256 ~           >                            call  l2_flip_buffers
   7+ E256             >                        ENDIF
   8+ E256                                      DoubleBufferIfPossible
   8+ E256             >                        IFDEF DOUBLEBUFFER
   8+ E256 ~           >                            MMUSelectLayer2
   8+ E256 ~           >                            call  l2_cls
   8+ E256 ~           >                            call  l2_flip_buffers
   8+ E256             >                        ENDIF
   9+ E256 CD 68 E0                             call        asm_l2_row_bank_select
  10+ E259 C9                                   ret
  11+ E25A
  12+ E25A ED 91 70 10  l2_320_initialise:      nextreg     LAYER_2_CONTROL_REGISTER,           %00010000               ; 320x256x8bpp
  13+ E25E ED 91 12 08                          nextreg		LAYER2_RAM_PAGE_REGISTER,          	LAYER2_SCREEN_BANK1
  14+ E262 ED 91 13 0D                          nextreg		LAYER2_RAM_SHADOW_REGISTER,     	LAYER2_SHADOW_BANK1
  15+ E266 ED 91 14 E3                          nextreg		TRANSPARENCY_COLOUR_REGISTER, 		COLOUR_TRANSPARENT
  16+ E26A                                      ZeroA
  16+ E26A AF          >                        xor a
  17+ E26B                                      DoubleBuffer320IfPossible
  17+ E26B             >                        IFDEF DOUBLEBUFFER
  17+ E26B ~           >                            MMUSelectLayer2
  17+ E26B ~           >                            call  l2_320_cls
  17+ E26B ~           >                            call  l2_flip_buffers
  17+ E26B             >                        ENDIF
  18+ E26B                                      DoubleBuffer320IfPossible
  18+ E26B             >                        IFDEF DOUBLEBUFFER
  18+ E26B ~           >                            MMUSelectLayer2
  18+ E26B ~           >                            call  l2_320_cls
  18+ E26B ~           >                            call  l2_flip_buffers
  18+ E26B             >                        ENDIF
  19+ E26B CD C2 E0                             call        asm_l2_320_col_bank_select
  20+ E26E C9                                   ret
  21+ E26F
  22+ E26F              ;l2_640_initialise:      nextreg     LAYER_2_CONTROL_REGISTER,           %00100000               ; 320x256x8bpp
  23+ E26F              ;                        nextreg		LAYER2_RAM_PAGE_REGISTER,          	LAYER2_SCREEN_BANK1
  24+ E26F              ;                        nextreg		LAYER2_RAM_SHADOW_REGISTER,     	LAYER2_SHADOW_BANK1
  25+ E26F              ;                        nextreg		TRANSPARENCY_COLOUR_REGISTER, 		COLOUR_TRANSPARENT
  26+ E26F              ;                        ZeroA
  27+ E26F              ;                        DoubleBuffer640IfPossible
  28+ E26F              ;                        DoubleBuffer640IfPossible
  29+ E26F              ;                        call        asm_l2_640_col_bank_select
  30+ E26F              ;                        ret
  31+ E26F
# file closed: ../../Layer2Graphics/layer2_initialise.asm
 660  E26F                  INCLUDE "../../Layer2Graphics/l2_flip_buffers.asm"
# file opened: ../../Layer2Graphics/l2_flip_buffers.asm
   1+ E26F              l2_flip_buffers:        GetNextReg LAYER2_RAM_PAGE_REGISTER
   1+ E26F 01 3B 24    >            ld bc,$243B
   1+ E272 3E 12       >            ld a,LAYER2_RAM_PAGE_REGISTER
   1+ E274 ED 79       >            out (c),a
   1+ E276 04          >            inc b
   1+ E277 ED 78       >            in a,(c)
   2+ E279 57                                   ld      d,a
   3+ E27A                                      GetNextReg LAYER2_RAM_SHADOW_REGISTER
   3+ E27A 01 3B 24    >            ld bc,$243B
   3+ E27D 3E 13       >            ld a,LAYER2_RAM_SHADOW_REGISTER
   3+ E27F ED 79       >            out (c),a
   3+ E281 04          >            inc b
   3+ E282 ED 78       >            in a,(c)
   4+ E284 5F                                   ld      e,a
   5+ E285 ED 92 12                             nextreg LAYER2_RAM_PAGE_REGISTER, a
   6+ E288 7A                                   ld      a,d
   7+ E289 ED 92 13                             nextreg LAYER2_RAM_SHADOW_REGISTER, a
   8+ E28C C9                                   ret
   9+ E28D
# file closed: ../../Layer2Graphics/l2_flip_buffers.asm
 661  E28D                  INCLUDE "../../Layer2Graphics/layer2_plot_pixel.asm"
# file opened: ../../Layer2Graphics/layer2_plot_pixel.asm
   1+ E28D
   2+ E28D DF           line_gfx_colour db $DF
   3+ E28E
   4+ E28E              l2_plot_macro:          MACRO
   5+ E28E ~                                    ld      a,b
   6+ E28E ~                                    JumpIfAGTENusng 192 ,.NoPlot
   7+ E28E ~                                    ld      l,c
   8+ E28E ~                                    call    asm_l2_row_bank_select
   9+ E28E ~                                    ld      h,a
  10+ E28E ~                                    ld      a,(line_gfx_colour)
  11+ E28E ~                                    ld      (hl),a
  12+ E28E ~            .NoPlot:
  13+ E28E                                      ENDM
  14+ E28E
  15+ E28E
  16+ E28E              ; ">l2_plot_pixel b= row number, c = column number, a = pixel col"
  17+ E28E F5           l2_plot_pixel:          push    af
  18+ E28F 78                                   ld      a,b
  19+ E290              l2_pp_row_valid:        JumpIfAGTENusng ScreenHeight,l2_pp_dont_plot
  19+ E290 FE C0       >                        cp     ScreenHeight
  19+ E292 D2 A0 E2    >                        jp		nc,l2_pp_dont_plot
  20+ E295 C5                                   push    bc								; bank select destroys bc so need to save it
  21+ E296                                  ;	ld      a,b
  22+ E296 CD 68 E0                             call    asm_l2_row_bank_select
  23+ E299 C1                                   pop     bc
  24+ E29A 47                                   ld      b,a
  25+ E29B 60                                   ld      h,b								; hl now holds ram address after bank select
  26+ E29C 69                                   ld      l,c
  27+ E29D F1                                   pop     af								; a = colour to plott
  28+ E29E 77                                   ld      (hl),a
  29+ E29F C9                                   ret
  30+ E2A0 F1           l2_pp_dont_plot:        pop     af
  31+ E2A1 C9                                   ret
  32+ E2A2
  33+ E2A2              ; ">l2_plot_pixel d= row number, hl = column number, e = pixel col"
  34+ E2A2 7C           l2_plot_pixel_320:      ld      a,h
  35+ E2A3 FE 01                                cp      1                               ; if < 256, definite OK
  36+ E2A5 20 05                                jr      nz,.DoneCheck
  37+ E2A7 7D                                   ld      a,l
  38+ E2A8 E6 C0                                and     %11000000                       ; if its 7 or 6 set then > 319
  39+ E2AA 20 06                                jr      nz,.DontPlot
  40+ E2AC CD C2 E0     .DoneCheck:             call    asm_l2_320_col_bank_select      ; adjust hl for column > h
  41+ E2AF 6A                                   ld      l,d                             ; as they are horizontal now
  42+ E2B0 7B                                   ld      a,e
  43+ E2B1 77                                   ld      (hl),a
  44+ E2B2 C9           .DontPlot:              ret
  45+ E2B3
  46+ E2B3 CD C2 E0     l2_plot_pixel_320_no_check:   call    asm_l2_320_col_bank_select      ; adjust hl for column > h
  47+ E2B6 6A                                   ld      l,d                             ; as they are horizontal now
  48+ E2B7 7B                                   ld      a,e
  49+ E2B8 77                                   ld      (hl),a
  50+ E2B9 C9                                   ret
  51+ E2BA
  52+ E2BA              ; y aixs bounds check must have been done before calling this
  53+ E2BA F5           l2_plot_pixel_no_check: push    af
  54+ E2BB C5                                   push    bc								; bank select destroys bc so need to save it
  55+ E2BC 78                                   ld      a,b                             ; determine target bank
  56+ E2BD CD 68 E0                             call    asm_l2_row_bank_select
  57+ E2C0 C1                                   pop     bc
  58+ E2C1 47                                   ld      b,a                             ; b now adjusted for bank, c = column
  59+ E2C2 60 69                                ld      hl,bc                           ; hl now holds ram address after bank select
  60+ E2C4 F1                                   pop     af								; a = colour to plott
  61+ E2C5 77                                   ld      (hl),a                          ; poke to ram
  62+ E2C6 C9                                   ret
  63+ E2C7
  64+ E2C7              ; ">l2_plot_pixel_no_bank b= row number, c = column number, a = pixel col"
  65+ E2C7              ; This version assues pixel is in the same bank as previously plotted ones. optimised for horizontal lines
  66+ E2C7 E5           l2_plot_pixel_no_bank:  push 	hl
  67+ E2C8 60                                   ld 		h,b								; hl now holds ram address after bank select
  68+ E2C9 69                                   ld 		l,c
  69+ E2CA 77                                   ld 		(hl),a
  70+ E2CB E1                                   pop		hl
  71+ E2CC C9                                   ret
  72+ E2CD
  73+ E2CD              ; ">l2_plot_pixel_no_bank d= row number, h = column number, a = pixel col"
  74+ E2CD              ; This version assues pixel is in the same bank as previously plotted ones. optimised for horizontal lines
  75+ E2CD              l2_plot_pixel_320_no_bank:
  76+ E2CD 6A                                   ld 		l,d
  77+ E2CE 77                                   ld 		(hl),a
  78+ E2CF C9                                   ret
  79+ E2D0              ; The more simpler h col l row is just ld (hl),a so no need for a function
  80+ E2D0
  81+ E2D0
  82+ E2D0 F5           ShipPixel:              push    af
  83+ E2D1 78                                   ld      a,b
  84+ E2D2 FE 7F                                cp      127
  85+ E2D4 D0                                   ret     nc
  86+ E2D5 F1                                   pop     af
  87+ E2D6 18 E2                                jr      l2_plot_pixel_no_check
  88+ E2D8                                      ;***Implicit ret due to jr
  89+ E2D8
  90+ E2D8              ; in bc = yx iyl = colour
  91+ E2D8 78           DebrisPixel:            ld      a,b
  92+ E2D9 FE 7F                                cp      127
  93+ E2DB D0                                   ret     nc
  94+ E2DC FD 7D                                ld      a, iyl
  95+ E2DE 18 DA                                jr      l2_plot_pixel_no_check
  96+ E2E0                                      ;***Implicit ret due to jr
  97+ E2E0
  98+ E2E0 F5           l2_plot_pixel_y_test:   push	af
  99+ E2E1 78                                   ld		a,b
 100+ E2E2 FE C0                                cp		192
 101+ E2E4 30 03                                jr		nc,.clearup
 102+ E2E6 F1                                   pop		af
 103+ E2E7 18 A5                                jr		l2_plot_pixel
 104+ E2E9 F1           .clearup:               pop		af
 105+ E2EA C9                                   ret
 106+ E2EB
 107+ E2EB              l2_point_pixel_y_safe:	MACRO
 108+ E2EB ~            						push	hl
 109+ E2EB ~            						push	bc
 110+ E2EB ~            						call	l2_plot_pixel
 111+ E2EB ~            						pop		bc
 112+ E2EB ~            						pop		hl
 113+ E2EB              						ENDM
 114+ E2EB
# file closed: ../../Layer2Graphics/layer2_plot_pixel.asm
 662  E2EB                  INCLUDE "../../Layer2Graphics/layer2_print_character.asm"
# file opened: ../../Layer2Graphics/layer2_print_character.asm
   1+ E2EB
   2+ E2EB              l2_print_chr_at:
   3+ E2EB              ; "l2_print_chr_at, bc = col,row, d= character, e = colour"
   4+ E2EB              ; "Need a version that also prints absence of character"
   5+ E2EB 7A           	ld		a,d
   6+ E2EC FE 20        	cp		32
   7+ E2EE 38 3F        	jr		c,.InvalidCharacter		; Must be between 32 and 127
   8+ E2F0 FE 7F        	cp		127
   9+ E2F2 30 3B        	jr		nc,.InvalidCharacter
  10+ E2F4              .ValidCharater:
  11+ E2F4 26 00        	ld		h,0
  12+ E2F6 6A           	ld		l,d
  13+ E2F7 29           	add		hl,hl						; * 2
  14+ E2F8 29           	add		hl,hl						; * 4
  15+ E2F9 29           	add		hl,hl						; * 8 to get byte address
  16+ E2FA ED 34 00 3C  	add		hl,charactersetaddr			; hl = address of rom char
  17+ E2FE 04           	inc		b							; start + 1 pixel x and y as we only print 7x7
  18+ E2FF 23           	inc		hl							; skip first byte
  19+ E300 16 07        	ld		d,7
  20+ E302              .PrintCharLoop:
  21+ E302 D5           	push	de
  22+ E303 7E           	ld		a,(hl)
  23+ E304 FE 00        	cp		0
  24+ E306 28 21        	jr		z,.NextRowNoBCPop
  25+ E308              .PrintARow:
  26+ E308 C5           	push	bc							; save row col
  27+ E309 16 07        	ld		d,7							; d is loop row number now
  28+ E30B              .PrintPixelLoop:
  29+ E30B 0C           	inc		c							; we start at col 1 not 0 so can move inc here
  30+ E30C              .PrintTheRow:
  31+ E30C CB 27        	sla		a							; scroll char 1 pixel as we read from bit 7
  32+ E30E F5           	push	af							; save character byte
  33+ E30F CB 7F        	bit		7,a							; If left most pixel set then plot
  34+ E311 20 04        	jr		nz,.PixelToPrint
  35+ E313              .NoPixelToPrint:
  36+ E313 3E E3        	ld		a,$E3
  37+ E315 18 01        	jr		.HaveSetPixelColour
  38+ E317              .PixelToPrint:
  39+ E317 7B           	ld		a,e							; Get Colour
  40+ E318              .HaveSetPixelColour
  41+ E318 E5           	push	hl
  42+ E319              ;	push	bc							; at the moment we don't do paging on first plot so need to preserve BC
  43+ E319              .BankOnFirstOnly:
  44+ E319 F5           	push	af
  45+ E31A 7A           	ld		a,d
  46+ E31B FE 07        	cp		7
  47+ E31D 28 11        	jr		z,.PlotWithBank
  48+ E31F              .PlotNoBank:
  49+ E31F F1           	pop		af
  50+ E320 60           	ld 		h,b								; hl now holds ram address after bank select
  51+ E321 69           	ld 		l,c
  52+ E322 77           	ld 		(hl),a
  53+ E323              .IterateLoop:
  54+ E323              ;	pop		bc
  55+ E323 E1           	pop		hl
  56+ E324 F1           	pop		af							; a= current byte shifted
  57+ E325 15           	dec		d						 	; do dec after inc as we amy
  58+ E326 20 E3        	jr		nz,.PrintPixelLoop
  59+ E328              .NextRow:
  60+ E328 C1           	pop		bc							; Current Col Row
  61+ E329              .NextRowNoBCPop:
  62+ E329 D1           	pop		de							; d= row loop
  63+ E32A 04           	inc		b							; Down 1 row
  64+ E32B 23           	inc		hl							; Next character byte
  65+ E32C 15           	dec		d							; 1 done now
  66+ E32D 20 D3        	jr		nz,.PrintCharLoop
  67+ E32F              .InvalidCharacter:
  68+ E32F C9           	ret
  69+ E330              .PlotWithBank:
  70+ E330 F1           	pop		af
  71+ E331 CD 8E E2     	call	l2_plot_pixel				; This will shift bc to poke row
  72+ E334 18 ED        	jr		.IterateLoop
  73+ E336
  74+ E336              l2_print_at:
  75+ E336              ; "l2_print_at bc= colrow, hl = addr of message, e = colour"
  76+ E336              ; "No error trapping, if there is no null is will just cycle on the line"
  77+ E336 7E           	ld	a,(hl)							; Return if empty string
  78+ E337 FE 00        	cp	0
  79+ E339 C8           	ret	z
  80+ E33A E5           	push	hl
  81+ E33B D5           	push	de
  82+ E33C C5           	push	bc
  83+ E33D 57           	ld		d,a							; bc = pos, de = char and colour
  84+ E33E CD EB E2     	call 	l2_print_chr_at
  85+ E341 C1           	pop		bc
  86+ E342 D1           	pop		de
  87+ E343 E1           	pop		hl
  88+ E344              .Move8Pixlestoright:
  89+ E344 08           	ex		af,af'
  90+ E345 79           	ld		a,c
  91+ E346 C6 08        	add		8
  92+ E348 4F           	ld		c,a
  93+ E349 08           	ex		af,af'
  94+ E34A 23           	inc		hl
  95+ E34B 18 E9        	jr		l2_print_at					; Just loop until 0 found
  96+ E34D
  97+ E34D
  98+ E34D              ; "l2_print_chr_at, bc = col,row, d= character, e = colour"
  99+ E34D              ; "Need a version that also prints absence of character"
 100+ E34D              ; removed blank line optimisation as we need spaces printed
 101+ E34D 7A           l2_print_7chr_at:       ld		a,d
 102+ E34E FE 1F                                cp		31
 103+ E350 38 3D                                jr		c,.InvalidCharacter		; Must be between 32 and 127
 104+ E352 FE 7F                                cp		127
 105+ E354 30 39                                jr		nc,.InvalidCharacter
 106+ E356 26 00        .ValidCharater:         ld		h,0
 107+ E358 6A                                   ld		l,d
 108+ E359 29                                   add		hl,hl						; * 2
 109+ E35A 29                                   add		hl,hl						; * 4
 110+ E35B 29                                   add		hl,hl						; * 8 to get byte address
 111+ E35C ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
 112+ E360 04                                   inc		b							; start + 1 pixel x and y as we only print 7x7
 113+ E361 23                                   inc		hl							; skip first byte
 114+ E362 16 07                                ld		d,7
 115+ E364 D5           .PrintCharLoop:         push	de
 116+ E365 7E                                   ld		a,(hl)
 117+ E366                                      ;cp		0
 118+ E366                                      ;jr		z,.NextRowNoBCPop
 119+ E366 C5           .PrintARow:             push	bc							; save row col
 120+ E367 16 06                                ld		d,6							; d is loop row number now
 121+ E369 0C           .PrintPixelLoop:        inc		c							; we start at col 1 not 0 so can move inc here
 122+ E36A 28 1C                                jr		z,.NextRow
 123+ E36C CB 27                                sla		a							; scroll char 1 pixel as we read from bit 7
 124+ E36E F5                                   push	af							; save character byte
 125+ E36F CB 7F                                bit		7,a							; If left most pixel set then plot
 126+ E371 20 04                                jr		nz,.PixelToPrint
 127+ E373 3E E3        .NoPixelToPrint:        ld		a,$E3
 128+ E375 18 01                                jr		.HaveSetPixelColour
 129+ E377 7B           .PixelToPrint:          ld		a,e							; Get Colour
 130+ E378 E5           .HaveSetPixelColour		push	hl
 131+ E379                                      ;	push	bc							; at the moment we don't do paging on first plot so need to preserve BC
 132+ E379 F5           .BankOnFirstOnly:       push	af
 133+ E37A 7A                                   ld		a,d
 134+ E37B FE 06                                cp		6
 135+ E37D 28 11                                jr		z,.PlotWithBank
 136+ E37F F1           .PlotNoBank:            pop		af
 137+ E380 60                                   ld 		h,b								; hl now holds ram address after bank select
 138+ E381 69                                   ld 		l,c
 139+ E382 77                                   ld 		(hl),a
 140+ E383              .IterateLoop:	        ;	pop		bc
 141+ E383 E1                                   pop		hl
 142+ E384 F1                                   pop		af							; a= current byte shifted
 143+ E385 15                                   dec		d						 	; do dec after inc as we amy
 144+ E386 20 E1                                jr		nz,.PrintPixelLoop
 145+ E388 C1           .NextRow:               pop		bc							; Current Col Row
 146+ E389 D1           .NextRowNoBCPop:	    pop		de							; d= row loop
 147+ E38A 04                                   inc		b							; Down 1 row
 148+ E38B 23                                   inc		hl							; Next character byte
 149+ E38C 15                                   dec		d							; 1 done now
 150+ E38D 20 D5                                jr		nz,.PrintCharLoop
 151+ E38F C9           .InvalidCharacter:      ret
 152+ E390 F1           .PlotWithBank:          pop		af
 153+ E391 CD 8E E2                             call	l2_plot_pixel				; This will shift bc to poke row
 154+ E394 18 ED                                jr		.IterateLoop
 155+ E396
 156+ E396              ; "l2_print_7at bc= colrow, hl = addr of message, e = colour"
 157+ E396              ; "No error trapping, if there is no null is will just cycle on the line"
 158+ E396 7E           l2_print_7at:           ld	a,(hl)							; Return if empty string
 159+ E397 FE 00                                cp	0
 160+ E399 C8                                   ret	z
 161+ E39A E5                                   push	hl
 162+ E39B D5                                   push	de
 163+ E39C C5                                   push	bc
 164+ E39D 57                                   ld		d,a							; bc = pos, de = char and colour
 165+ E39E CD 4D E3                             call 	l2_print_7chr_at
 166+ E3A1 C1                                   pop		bc
 167+ E3A2 D1                                   pop		de
 168+ E3A3 E1                                   pop		hl
 169+ E3A4 08           .Move7Pixlestoright:	ex		af,af'
 170+ E3A5 79                                   ld		a,c
 171+ E3A6 C6 07                                add		7
 172+ E3A8 4F                                   ld		c,a
 173+ E3A9 08                                   ex		af,af'
 174+ E3AA 23                                   inc		hl
 175+ E3AB 18 E9                                jr		l2_print_7at					; Just loop until 0 found
 176+ E3AD
 177+ E3AD
 178+ E3AD              ; "l2_print_7at b= row, hl = col de = addr of message, c = colour"
 179+ E3AD              ; "No error trapping, if there is no null is will just cycle on the line"
 180+ E3AD
 181+ E3AD 1A           l2_print_7at_320:       ld	a,(de)							; Return if empty string
 182+ E3AE FE 00                                cp	0
 183+ E3B0 C8                                   ret	z
 184+ E3B1 E5 D5 C5                             push	hl,,de,,bc
 185+ E3B4 57                                   ld		d,a							; bc = pos, de = char and colour
 186+ E3B5                                      ;TODOcallcall 	l2_print_7chr_at_320
 187+ E3B5 C1 D1 E1                             pop		hl,,de,,bc
 188+ E3B8 08           .Move7Pixlestoright:	ex		af,af'
 189+ E3B9 79                                   ld		a,c
 190+ E3BA C6 07                                add		7
 191+ E3BC 4F                                   ld		c,a
 192+ E3BD 08                                   ex		af,af'
 193+ E3BE 23                                   inc		hl
 194+ E3BF 18 EC                                jr		l2_print_7at_320		    ; Just loop until 0 found
 195+ E3C1
 196+ E3C1
# file closed: ../../Layer2Graphics/layer2_print_character.asm
 663  E3C1                  INCLUDE "../../Layer2Graphics/layer2_draw_box.asm"
# file opened: ../../Layer2Graphics/layer2_draw_box.asm
   1+ E3C1              ; "l2_draw_thick_box bc=rowcol, de=heightwidth h=color"
   2+ E3C1              ; TODO DMA Optimise
   3+ E3C1                              DISPLAY "TODO: dma optimise"
   4+ E3C1 C5 D5 E5     l2_draw_fill_box:       push    bc,,de,,hl
   5+ E3C4 53                                   ld      d,e
   6+ E3C5 5C                                   ld      e,h
   7+ E3C6 CD 5C E4                             call    l2_draw_horz_line           ; "bc = left side row,col, d = length, e = color"
   8+ E3C9 E1 D1 C1                             pop     bc,,de,,hl
   9+ E3CC 04                                   inc     b
  10+ E3CD 15                                   dec     d
  11+ E3CE C8                                   ret     z
  12+ E3CF 18 F0                                jr      l2_draw_fill_box
  13+ E3D1
  14+ E3D1              ; "l2_draw_box bc=rowcol, de=heightwidth a=color"
  15+ E3D1 C5 D5 F5     l2_draw_box:            push	bc,,de,,af
  16+ E3D4 53                                   ld		d,e
  17+ E3D5 5F                                   ld		e,a
  18+ E3D6 14                                   inc		d
  19+ E3D7 CD 5C E4                             call	l2_draw_horz_line
  20+ E3DA F1 D1 C1                             pop		bc,,de,,af
  21+ E3DD C5 D5 F5     .bottomhorzline:	    push	bc,,de,,af
  22+ E3E0 67                                   ld		h,a							;save color whilst b = row + height
  23+ E3E1 78                                   ld		a,b
  24+ E3E2 82                                   add		a,d
  25+ E3E3 47                                   ld		b,a
  26+ E3E4 53                                   ld		d,e							; d = width
  27+ E3E5 14                                   inc		d							; Extra pixel for width
  28+ E3E6 5C                                   ld		e,h							; e = colour
  29+ E3E7 CD 5C E4                             call	l2_draw_horz_line
  30+ E3EA F1 D1 C1                             pop		bc,,de,,af
  31+ E3ED C5 D5 F5     .leftvertline:          push	bc,,de,,af
  32+ E3F0 04                                   inc		b							; save 2 pixles
  33+ E3F1 15                                   dec		d
  34+ E3F2 5F                                   ld		e,a							; e = color
  35+ E3F3 CD C7 E4                             call	l2_draw_vert_line
  36+ E3F6 F1 D1 C1                             pop		bc,,de,,af
  37+ E3F9 04           .rightvertline:         inc		b							; save 2 pixles
  38+ E3FA 15                                   dec		d
  39+ E3FB 67                                   ld		h,a							;save color whilst c = col + width
  40+ E3FC 79                                   ld		a,c
  41+ E3FD 83                                   add		a,e
  42+ E3FE 4F                                   ld		c,a
  43+ E3FF 5C                                   ld		e,h							; e = color
  44+ E400 CD C7 E4                             call	l2_draw_vert_line
  45+ E403 C9                                   ret
  46+ E404
  47+ E404              ; "b = row, hl = col, c = height, de = width, a = colour"
  48+ E404 C5 D5 E5 F5  l2_draw_box_320:        push    bc,,de,,hl,,af
  49+ E408                                      ;TODOcall    l2_draw_horz_line_320       ; b = row, hl = col, e = width a = colour
  50+ E408 F1 E1 D1 C1                          pop     bc,,de,,hl,,af
  51+ E40C C5 D5 E5 F5                          push    bc,,de,,hl,,af
  52+ E410 08                                   ex      af,af'
  53+ E411 78                                   ld      a,b
  54+ E412 3D                                   dec     a
  55+ E413 81                                   add     a,c
  56+ E414 41                                   ld      b,c
  57+ E415 08                                   ex      af,af'
  58+ E416                                      ;TODOcall    l2_draw_horz_line_320       ; b = row, hl = col, e = width a = colour
  59+ E416 F1 E1 D1 C1  .leftVertLine:          pop     bc,,de,,hl,,af
  60+ E41A C5 D5 E5 F5                          push    bc,,de,,hl,,af
  61+ E41E                                      ;TODOcall    l2_draw_vert_line_320
  62+ E41E F1 E1 D1 C1                          pop     bc,,de,,hl,,af
  63+ E422 19                                   add     hl,de
  64+ E423 2B                                   dec     hl
  65+ E424                                      ;TODOcall    l2_draw_vert_line_320
  66+ E424 C9                                   ret
  67+ E425
# file closed: ../../Layer2Graphics/layer2_draw_box.asm
 664  E425                  INCLUDE "../../Layer2Graphics/asm_l2_plot_horizontal.asm"
# file opened: ../../Layer2Graphics/asm_l2_plot_horizontal.asm
   1+ E425
   2+ E425              ;; NOTE DMA is little endian
   3+ E425 00           l2_horz_pixel           DB 0
   4+ E426
   5+ E426 83 C3 C7 CB  l2_horz_line            DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   5+ E42A 7D
   6+ E42B 25 E4        l2_horz_colr            DW l2_horz_pixel
   7+ E42D 00           l2_horz_lenlo           DB 0
   8+ E42E 00           l2_horz_lenhi           DB 0
   9+ E42F 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY, DMA_WR2_P2INC_MEMORY, DMA_WR4_CONT_MODE
  10+ E432 00 00        l2_horz_target          DB $00, $00
  11+ E434 CF 87                                DB DMA_LOAD, DMA_ENABLE
  12+ E436              l2_horz_cmd_len	        EQU $ - l2_horz_line
  13+ E436
  14+ E436
  15+ E436              ; "l2_draw_horz_dma"
  16+ E436              ; "plot at bc for length d colour e using dma, assumes bank already selected"
  17+ E436 7B           l2_draw_horz_dma:       ld		a,e                                               ; T=4      ;
  18+ E437 32 25 E4                             ld		(l2_horz_pixel),a                                 ; T=13     ;
  19+ E43A 5A                                   ld      e,d ; saved 3 t states ld		a,d                                               ; T=4      ; e=d   4
  20+ E43B 16 00                                ld      d,0; saved 3 t states ld 		(l2_horz_lenlo),a                                 ; T=13     ; d = 0  7
  21+ E43D ED 53 2D E4                          ld      (l2_horz_lenlo),de; saved 3 t states xor 	a                                                 ; T=4      ; t 20  31
  22+ E441                                      ; saved 3 t states ld ld 		(l2_horz_lenhi),a                                 ; T=13     ;
  23+ E441                                    ; saved 4 t states  ld		h,b                           ;          ;
  24+ E441                                    ; saved 4 t states  ld		l,c                           ;          ;
  25+ E441 ED 43 32 E4                          ld      (l2_horz_target),bc ; saved 4 t states  was , hl  ; T=20     ;
  26+ E445 21 26 E4     .write_dma:             ld 		hl, l2_horz_line                                  ;          ;
  27+ E448 06 10                                ld 		b, l2_horz_cmd_len                                ;
  28+ E44A 0E 6B                                ld		c,IO_DATAGEAR_DMA_PORT                            ;
  29+ E44C ED B3                                otir                                                      ;
  30+ E44E C9                                   ret
  31+ E44F
  32+ E44F              ; "bc = left side row,col, d = length, e = color"
  33+ E44F D5           l2_draw_horz_dma_bank:  push 	de							; save length and colour
  34+ E450 C5                                   push 	bc							; save row col
  35+ E451 78                                   ld   	a,b
  36+ E452 CD 68 E0                             call 	asm_l2_row_bank_select		; now we have the correct bank, its a horizontal line so bank will not shift
  37+ E455 C1                                   pop  	bc
  38+ E456 47                                   ld	 	b,a	       					; fixed row by the call we can go straight into HL with row col
  39+ E457 D1                                   pop  	de							; get length back
  40+ E458 CD 36 E4                             call    l2_draw_horz_dma
  41+ E45B C9                                   ret
  42+ E45C
  43+ E45C              ; "l2_draw_horz_line"
  44+ E45C              ; "bc = left side row,col, d = length, e = color"
  45+ E45C              ; "optimisation if above min pix is will use dma call SCREEN_HOZ_MIN_PIX not implemented yet"
  46+ E45C 7A           l2_draw_horz_line:      ld		a,d
  47+ E45D FE 00                                cp 		0							; if its zero length then just return
  48+ E45F C8           .zerolengthexit:        ret		z
  49+ E460 FE 01        .isitlen1:              cp 		1
  50+ E462 CA 84 E4                             jp 		z,.l2_draw_horz_line_1
  51+ E465 FE 0A        .longenoughtfordma:     cp  10
  52+ E467 C3 4F E4                             jp  l2_draw_horz_dma_bank
  53+ E46A D5 C5        .plottableline:         push 	de,,bc  					; save length and colour an d row col
  54+ E46C 78                                   ld   	a,b
  55+ E46D CD 68 E0                             call 	asm_l2_row_bank_select		; now we have the correct bank, its a horizontal line so bank will not shift
  56+ E470 C1                                   pop  	bc
  57+ E471 67                                   ld	 	h,a	       					; fixed row by the call we can go straight into HL with row col
  58+ E472 69                                   ld   	l,c
  59+ E473 D1                                   pop  	de							; get length back
  60+ E474 79           .cliptest:              ld	 	a,c							; get column + length
  61+ E475 42                                   ld  	b,d  						; speculate that we don't clip by pre-loading b with length
  62+ E476 82                                   add  	a,d
  63+ E477 30 06                                jr   	nc, .l2_draw_horz_plot_loop	; if carry is set c+d > 255
  64+ E479 3E FF        .clipat255:             ld   	a,$FF
  65+ E47B 91                                   sub  	c							; a holds clipped length
  66+ E47C 47                                   ld 		b, a 						; so now hl holds poke address  b = clipped length e = colour
  67+ E47D 18 00                                jr		.l2_draw_horz_plot_loop
  68+ E47F 73           .l2_draw_horz_plot_loop:ld (hl),e							; loop poking hl with e for b pixels
  69+ E480 23                                   inc hl
  70+ E481 10 FC                                djnz .l2_draw_horz_plot_loop
  71+ E483 C9                                   ret
  72+ E484 7B           .l2_draw_horz_line_1:   ld		a,e
  73+ E485                                      l2_plot_macro; jp		l2_plot_pixel				; hijack return
  73+ E485 78          >                        ld      a,b
  73+ E486             >                        JumpIfAGTENusng 192 ,.NoPlot
  73+ E486 FE C0       >                        cp     192
  73+ E488 D2 94 E4    >                        jp		nc,.NoPlot
  73+ E48B 69          >                        ld      l,c
  73+ E48C CD 68 E0    >                        call    asm_l2_row_bank_select
  73+ E48F 67          >                        ld      h,a
  73+ E490 3A 8D E2    >                        ld      a,(line_gfx_colour)
  73+ E493 77          >                        ld      (hl),a
  73+ E494             >.NoPlot:
  74+ E494 C9                                   ret
  75+ E495
  76+ E495
  77+ E495              ; "l2_draw_horz_line_to"
  78+ E495              ; "bc = left side row,col, d right pixel, e = color"
  79+ E495 7A           l2_draw_horz_line_to:   ld 		a,d
  80+ E496 B9                                   cp 		c
  81+ E497 30 04                                jr		nc, .noswap
  82+ E499 28 07                                jr      z, .singlepixel
  83+ E49B 51           .swap:                  ld		d,c
  84+ E49C 4F                                   ld		c,a
  85+ E49D 7A           .noswap:                ld		a,d
  86+ E49E 91                                   sub		c
  87+ E49F              ;                        dec		a							; so now its length not offset
  88+ E49F 57                                   ld		d,a
  89+ E4A0 18 BA                                jr 		l2_draw_horz_line			; hijack routine and return statements
  90+ E4A2 7B           .singlepixel:           ld		a,e
  91+ E4A3                                      l2_plot_macro; jp		l2_plot_pixel				; hijack return
  91+ E4A3 78          >                        ld      a,b
  91+ E4A4             >                        JumpIfAGTENusng 192 ,.NoPlot
  91+ E4A4 FE C0       >                        cp     192
  91+ E4A6 D2 B2 E4    >                        jp		nc,.NoPlot
  91+ E4A9 69          >                        ld      l,c
  91+ E4AA CD 68 E0    >                        call    asm_l2_row_bank_select
  91+ E4AD 67          >                        ld      h,a
  91+ E4AE 3A 8D E2    >                        ld      a,(line_gfx_colour)
  91+ E4B1 77          >                        ld      (hl),a
  91+ E4B2             >.NoPlot:
  92+ E4B2 C9                                   ret
  93+ E4B3
# file closed: ../../Layer2Graphics/asm_l2_plot_horizontal.asm
 665  E4B3                  INCLUDE "../../Layer2Graphics/asm_l2_plot_vertical.asm"
# file opened: ../../Layer2Graphics/asm_l2_plot_vertical.asm
   1+ E4B3              ; ">l2_draw_vert_segment"
   2+ E4B3              ; ">hl = bank adjusted pixel poke address d = length, e = color"
   3+ E4B3              ; ">will always clip once h = 64 even if length > 64 destroys a and hl, d = resudual length not plotted"
   4+ E4B3 7A           l2_draw_vert_segment:   ld		a,d
   5+ E4B4 FE 00        .emptylinecheck:	    cp 		0
   6+ E4B6 C8                                   ret		z
   7+ E4B7 FE 01        .justonepixel	        cp		1
   8+ E4B9 20 02                                jr		nz, .multiplepixelsLoop
   9+ E4BB 73                                   ld		(hl),e
  10+ E4BC C9                                   ret
  11+ E4BD              .multiplepixelsLoop:
  12+ E4BD 7C           .endofbankcheck:        ld   	a,h
  13+ E4BE FE 40                                cp   	64
  14+ E4C0 D0                                   ret		nc							; check before we poke data if we have hit a boundary
  15+ E4C1 73           .canplotapixel:         ld   	(hl),e						; set colour
  16+ E4C2 24                                   inc 	h							; we don't check here else we would need a dec d on ret could do for optimisation of loop though
  17+ E4C3 15                                   dec		d
  18+ E4C4 C8                                   ret		z
  19+ E4C5 18 F6                                jr		.multiplepixelsLoop
  20+ E4C7
  21+ E4C7              ; ">l2_draw_vert_line"
  22+ E4C7              ; ">bc = row col d = length, e = color"
  23+ E4C7 78           l2_draw_vert_line:      ld 		a,b
  24+ E4C8 FE C0        .offscreencheck:        cp 		SCREEN_HEIGHT
  25+ E4CA D0                                   ret 	nc							; can't start off the screen
  26+ E4CB 7A           .emptylinecheck:        ld		a,d
  27+ E4CC FE 00                                cp		0
  28+ E4CE C8                                   ret		z
  29+ E4CF FE 01                                cp		1
  30+ E4D1 20 10                                jr		nz,.multiplepixels
  31+ E4D3              .itsonepixel:           l2_plot_macro; call	l2_plot_pixel
  31+ E4D3 78          >                        ld      a,b
  31+ E4D4             >                        JumpIfAGTENusng 192 ,.NoPlot
  31+ E4D4 FE C0       >                        cp     192
  31+ E4D6 D2 E2 E4    >                        jp		nc,.NoPlot
  31+ E4D9 69          >                        ld      l,c
  31+ E4DA CD 68 E0    >                        call    asm_l2_row_bank_select
  31+ E4DD 67          >                        ld      h,a
  31+ E4DE 3A 8D E2    >                        ld      a,(line_gfx_colour)
  31+ E4E1 77          >                        ld      (hl),a
  31+ E4E2             >.NoPlot:
  32+ E4E2 C9                                   ret
  33+ E4E3              .multiplepixels:						; so now we have at least 2 pixels to plot
  34+ E4E3 7A           .clipto192:             ld		a,d							; get length
  35+ E4E4 80                                   add		a,b							; a= row + length
  36+ E4E5 38 04                                jr		c,.needtoclip				; if it was > 255 then there is a definite need
  37+ E4E7 FE C0                                cp		SCREEN_HEIGHT
  38+ E4E9 38 08                                jr		c, .noclipneeded
  39+ E4EB 78           .needtoclip             ld		a,b
  40+ E4EC 82                                   add		a,d
  41+ E4ED D6 C0                                sub		SCREEN_HEIGHT
  42+ E4EF 67                                   ld		h,a							; use h as a temp holding for (row + length) - 192
  43+ E4F0 7A                                   ld		a,d
  44+ E4F1 94                                   sub		h
  45+ E4F2 57                                   ld		d,a							; d = length - ((row + length) - 192)
  46+ E4F3              ; so now BC = row col, d = length clipped, e = color
  47+ E4F3 78           .noclipneeded:          ld		a,b
  48+ E4F4 C5 D5                                push	bc,,de
  49+ E4F6 CD 68 E0                             call 	asm_l2_row_bank_select
  49+ E4F9               	 	; we now have poke address and a variable holding current bank number
  50+ E4F9 D1 C1                                pop		bc,,de
  51+ E4FB 67                                   ld		h,a							; b now tolds target pixel for first plot
  52+ E4FC 69                                   ld		l,c  						; and c holds pixel column for plotting
  53+ E4FD CD B3 E4                             call 	l2_draw_vert_segment		; draw seg, d = pixels remaining
  54+ E500 7A                                   ld		a,d							; a and d = nbr pixels remaining
  55+ E501 FE 00                                cp		0
  56+ E503 28 27                                jr		z, .doneplotting
  57+ E505 3A 00 E0     .anotherbank:           ld		a, (varL2_BANK_SELECTED)
  58+ E508 3C                                   inc		a
  59+ E509 06 00                                ld		b,0
  60+ E50B C5 D5                                push	bc,,de
  61+ E50D CD 51 E0                             call 	asm_l2_bank_n_select
  62+ E510 D1 C1                                pop     bc,,de
  63+ E512 60                                   ld		h,b							; b now tolds target pixel for first plot
  64+ E513 69                                   ld		l,c  						; and c holds pixel column for plotting
  65+ E514 CD B3 E4                             call	l2_draw_vert_segment
  66+ E517 7A                                   ld		a,d
  67+ E518 FE 00                                cp		0
  68+ E51A 28 10                                jr		z,.doneplotting
  69+ E51C 3A 00 E0     .yetanotherbank:        ld		a, (varL2_BANK_SELECTED)
  70+ E51F 3C                                   inc		a
  71+ E520 06 00                                ld		b,0
  72+ E522 C5 D5                                push	bc,,de
  73+ E524 CD 51 E0                             call 	asm_l2_bank_n_select
  74+ E527 D1                                   pop		de
  75+ E528 E1                                   pop		hl							; hl = bc
  76+ E529 CD B3 E4                             call	l2_draw_vert_segment		; we have now hit 192 pixels so done
  77+ E52C C9           .doneplotting:	        ret
  78+ E52D
  79+ E52D              ; ">l2_draw_vert_line_to"
  80+ E52D              ; ">bc = row col d = to position, e = color"
  81+ E52D 78           l2_draw_vert_line_to:   ld		a,b
  82+ E52E BA                                   cp		d
  83+ E52F 38 02                                jr		c, .noyswap
  84+ E531 42           .yswap:                 ld		b,d			; Swap round row numbers so we are always incrementing
  85+ E532 57                                   ld		d,a			; now we have a top to bottom to we we can calc length from bc
  86+ E533 7A           .noyswap:               ld		a,d 		; we still may have d in a but only if it was bottom to top
  87+ E534 90                                   sub		b
  88+ E535 3C                                   inc		a			; so now its length not offset
  89+ E536 57                                   ld		d,a
  90+ E537 18 8E                                jr		l2_draw_vert_line	; we can hijack its clipping, 0 check and return logic
  91+ E539                                      ; no return needed
  92+ E539
# file closed: ../../Layer2Graphics/asm_l2_plot_vertical.asm
 666  E539                  INCLUDE "../../Layer2Graphics/layer2_plot_diagonal.asm"
# file opened: ../../Layer2Graphics/layer2_plot_diagonal.asm
   1+ E539
   2+ E539              l2_draw_box_to:
   3+ E539              ; ">l2_draw_box_to bc=rowcol, de=torowcol a=color"
   4+ E539              ; ">NOT IMPLEMENTED YET"
   5+ E539 C9           	ret
   6+ E53A
   7+ E53A              ;; Note l2stepx is done via self modifying code rather than an if for speed
   8+ E53A              ;; l2stepx1 and l2stepx2 are the addresses to stick the inc or dec in
   9+ E53A              l2incbcstep EQU $03
  10+ E53A              l2incbstep	EQU	$04
  11+ E53A              l2decbstep	EQU $05
  12+ E53A              l2decbcstep EQU $0B
  13+ E53A              l2deccstep	EQU $0D
  14+ E53A              l2inccstep	EQU	$0C
  15+ E53A              l2incdestep EQU $13
  16+ E53A              l2decdestep EQU $1B
  17+ E53A              l2inchlstep EQU $23
  18+ E53A              l2dechlstep EQU $2B
  19+ E53A              		; l2 deltas are signed
  20+ E53A 00 00        l2deltaY	DW	0
  21+ E53C 00 00        l2deltaX	DW	0
  22+ E53E 00           l2deltaYsq	db	0
  23+ E53F 00           l2deltaXsq	db	0
  24+ E540 00           l2deltaYn	db	0
  25+ E541 00           l2deltaXn	db	0
  26+ E542 00           l2deltaYsqn	db	0
  27+ E543 00           l2deltaXsqn	db	0
  28+ E544 00           l2linecolor	db	0
  29+ E545 00 00        l2fraction	dw	0
  30+ E547 00 00        l2e2		dw	0
  31+ E549 00           l2way		db	0
  32+ E54A 00 00        l2targetPtr	dw	0
  33+ E54C              ;; These arrays should be 192 but if we use 256 then getting array2 value is just inc h rather than indexing again.
  34+ E54C 00 00 00...  l2targetArray1 ds	256
  35+ E64C 00 00 00...  l2targetArray2 ds	256
  36+ E74C              ;; Using Bresenham Algorithm draw a diagonal line top to bottom. First we must sort of course
  37+ E74C              ;;plotLine(int x0, int y0, int x1, int y1)
  38+ E74C              ;;    dx =  abs(x1-x0);
  39+ E74C              ;;    sx = x0<x1 ? 1 : -1;
  40+ E74C              ;;    dy = -abs(y1-y0);
  41+ E74C              ;;    sy = y0<y1 ? 1 : -1;
  42+ E74C              ;;    err = dx+dy;  /* error value e_xy */
  43+ E74C              ;;    while (true)   /* loop */
  44+ E74C              ;;        plot(x0, y0);
  45+ E74C              ;;        if (x0==x1 && y0==y1) break;
  46+ E74C              ;;        e2 = 2*err;
  47+ E74C              ;;        if (e2 >= dy) /* e_xy+e_x > 0 */
  48+ E74C              ;;            err += dy;
  49+ E74C              ;;            x0 += sx;
  50+ E74C              ;;        end if
  51+ E74C              ;;        if (e2 <= dx) /* e_xy+e_y < 0 */
  52+ E74C              ;;            err += dx;
  53+ E74C              ;;            y0 += sy;
  54+ E74C              ;;        end if
  55+ E74C              ;;    end while
  56+ E74C              ; ">l2_draw_diagonal_save, bc = y0,x0 de=y1,x1,a=array nbr ESOURCE LL30 or LION"
  57+ E74C              ; ">hl will be either l2targetArray1 or 2"
  58+ E74C              ; For S15 version we can still use the current table as this will hold final fill data
  59+ E74C              ; but we have to come in with X1Y1 X2Y2 being 16 bit
  60+ E74C              ; if the Y1Y2 are both off same side of screen or X1X2 both off same side them line array is set as empty
  61+ E74C              ; so
  62+ E74C              ;       for each line from Y1 to Y2
  63+ E74C              ;           if calculate as normal
  64+ E74C              ;                if off screen we don't write
  65+ E74C              ;                if on screen we clip to 0,255  which is easy as a horizontal line
  66+ E74C              ;           we will need a special case were a line is not rendered    we have x1=255 and X1 = 0, i.e. they are flipped
  67+ E74C              ;              we could also cheat and say view port as 1 pixel edge border so we can count x1 = 0 as no line
  68+ E74C
  69+ E74C              ; This must be called with  Y1 < Y2 as we won;t do a pre check
  70+ E74C              ; Caulates the temp x. IY [01] = X1 [23]=Y1 [45]=X2 [67]=Y2 [89]=midY3
  71+ E74C              ; Draw a line from BC to DE, with target Y position in a, all values must be 2's C at this points
  72+ E74C              ; calculate deltaX, deltaY for line.
  73+ E74C              ; calculate offsetY = TargetY - Y1
  74+ E74C              ; calculate XTarget = X1 + (deltaX/deltaY) *  offsetY
  75+ E74C              ;;;l2DiagDeltaX    DW 0
  76+ E74C              ;;;l2_diagonal_getx:       ld		hl,0                            ;
  77+ E74C              ;;;                        ld      ixh,0                           ; flag byte clear
  78+ E74C              ;;;                        ld      (target_y),a                    ; save target
  79+ E74C              ;;;.calculateDeltaX:       ld      hl,(IY+4)
  80+ E74C              ;;;                        ld      de,(IY+0)
  81+ E74C              ;;;                        ClearCarryFlag
  82+ E74C              ;;;                        sbc     hl,de
  83+ E74C              ;;;                        ld      (l2DiagDeltaX),hl
  84+ E74C              ;;;.calculateDeltaY:       ld      hl,(IY+6)
  85+ E74C              ;;;                        ld      de,(IY+2)
  86+ E74C              ;;;                        ClearCarryFlag
  87+ E74C              ;;;                        sbc     hl,de
  88+ E74C              ;;;                        ld      (l2DiagDeltaY),hl
  89+ E74C              ;;;.ABSDx:                 ld      hl,(l2DiagDeltaX)
  90+ E74C              ;;;                        ld      a,h
  91+ E74C              ;;;                        and     $80
  92+ E74C              ;;;                        jr      nz,.DxPositive
  93+ E74C              ;;;.DxNegative:            macronegate16hl
  94+ E74C              ;;;.DxPositive:            ex      de,hl                               ; de = deltaX
  95+ E74C              ;;;                        ld      hl,(l2DiagDeltaY)
  96+ E74C              ;;;                        ld      a,h
  97+ E74C              ;;;                        and     $80
  98+ E74C              ;;;                        jr      nz,.DyPositive
  99+ E74C              ;;;.DyNegative:            macronegate16hl
 100+ E74C              ;;;.DyPositive:
 101+ E74C              ;;;.ScaleLoop:             ld      a,h                                 ; At this point DX and DY are ABS values
 102+ E74C              ;;;                        or      d                                   ; .
 103+ E74C              ;;;                        jr      z,.ScaleDone                        ; .
 104+ E74C              ;;;                        ShiftDERight1                               ; .
 105+ E74C              ;;;                        ShiftHLRight1                               ; .
 106+ E74C              ;;;                        jr      .ScaleLoop                          ; scaled down Dx and Dy to 8 bit, Dy may have been;;                                                                                               negative
 107+ E74C              ;;;.ScaleDone:             ; hl = ABS DY, DE = ABS DX,  bc = Y1, ix = Y2,   note H and D will be zero
 108+ E74C              ;;;.CalculateDelta:        ld      a,e                                 ; if DX < DY goto DX/DY
 109+ E74C              ;;;                        JumpIfALTNusng l,.DXdivDY                   ; else do DY/DX
 110+ E74C              ;;;.DYdivDX:               ld      a,l                                 ;    A = DY
 111+ E74C              ;;;                        ld      d,e                                 ;    D = DX
 112+ E74C              ;;;                        call    AEquAmul256DivD                     ;    A = R = 256 * DY / DX
 113+ E74C              ;;;.SaveGradientDYDX:      ld      (Gradient),a
 114+ E74C              ;;;                        ld      a,ixh
 115+ E74C              ;;;                        or      16
 116+ E74C              ;;;                        ld      ixh,a                               ;
 117+ E74C              ;;;                        jp      .ClipP1                             ;
 118+ E74C              ;;;.DXdivDY:               ld      a,e                                 ;    A = DX
 119+ E74C              ;;;                        ld      d,l                                 ;    D = DY
 120+ E74C              ;;;                        call    AEquAmul256DivD                     ;    A = R = 256 * DX / DY
 121+ E74C              ;;;.SaveGradientDXDY:      ld      (Gradient),a
 122+ E74C              ;;;
 123+ E74C              ;;;have X1 -> X
 124+ E74C              ;;;need deltaMidY = MidY - Y0
 125+ E74C              ;;;                        X0 + (DeltaMY * Gradient) but if the graident is flipped then its X0+(deltaMY / Gradient)
 126+ E74C              ;;;
 127+ E74C              ;;;
 128+ E74C              ;;;.calculateDeltaY:
 129+ E74C              ;;;.calcualteDxDyOrDyDx
 130+ E74C              ;;;.calculate
 131+ E74C              ;;;
 132+ E74C              ; Total unoptimised version
 133+ E74C              ; use hl, de, bc, af,
 134+ E74C              ; no used yet ix iy
 135+ E74C              ; can we do an ex for hl' and de' holding x and hl, de holding y?
 136+ E74C              ;;;l2_X0                   DW 0
 137+ E74C              ;;;l2_Y0                   DW 0
 138+ E74C              ;;;l2_X1                   DW 0
 139+ E74C              ;;;l2_Y1                   DW 0
 140+ E74C              ;;;l2_DX                   DW 0
 141+ E74C              ;;;l2_DY                   DW 0
 142+ E74C              ;;;l2_SX                   DW 0
 143+ E74C              ;;;l2_SY                   DW 0
 144+ E74C              ;;;l2_Error                DW 0
 145+ E74C              ;;;l2_E2                   DW 0
 146+ E74C              ;;;int_bren_save_Array1:   ld      hl,(l2_X1)          ; if X0 < X1
 147+ E74C              ;;;                        ld      de,(l2_X0)          ; calculate SX DX
 148+ E74C              ;;;                        ClearCarryFlag              ;
 149+ E74C              ;;;                        sbc     hl,de               ;
 150+ E74C              ;;;                        bit     7,h                 ;
 151+ E74C              ;;;                        jr      z,.DXPositive       ;
 152+ E74C              ;;;.DXNegative:            NegHL                       ;
 153+ E74C              ;;;                        ld      bc,-1               ;
 154+ E74C              ;;;                        jp      .DoneCalcDx         ;
 155+ E74C              ;;;.DXPositive:            ld      bc,1                ;
 156+ E74C              ;;;.DoneCalcDx:            ld      (l2_SX),bc          ;
 157+ E74C              ;;;                        ld      (l2_DX),hl          ;
 158+ E74C              ;;;.CalcDY:                ld      hl,(l2_Y1)          ; If Y1 < Y1
 159+ E74C              ;;;                        ld      de,(l2_Y0)          ; calculate SY DY
 160+ E74C              ;;;                        ClearCarryFlag              ;
 161+ E74C              ;;;                        sbc     hl,de               ;
 162+ E74C              ;;;                        bit     7,h                 ;
 163+ E74C              ;;;                        jr      z,.DYPositive       ;
 164+ E74C              ;;;.DYNegative:            ld      bc,-1               ;
 165+ E74C              ;;;                        jp      .DoneCalcDx         ;
 166+ E74C              ;;;.DYPositive:            NegHL                       ;
 167+ E74C              ;;;                        ld      bc,1                ;
 168+ E74C              ;;;.DoneCalcDy:            ld      (l2_SY),bc          ;
 169+ E74C              ;;;                        ld      (l2_DY),hl
 170+ E74C              ;;;.CalcError:             ld      hl,(l2_DX)
 171+ E74C              ;;;                        ld      de,(l2_DY)
 172+ E74C              ;;;                        add     hl,de
 173+ E74C              ;;;                        ld      (l2_Error),hl
 174+ E74C              ;;;.CalcLoop:              break
 175+ E74C              ;;;                        ld      hl,(l2_X0)          ; get X0 and Y0
 176+ E74C              ;;;.CheckYRange:           ld      de,(l2_Y0)
 177+ E74C              ;;;                        ld      a,d                 ; if Y > 127
 178+ E74C              ;;;                        and     a                   ; or Y is negative
 179+ E74C              ;;;                        jr      nz,.YOutOfRange     ; then we can skip the plot
 180+ E74C              ;;;                        ld      a,e                 ;
 181+ E74C              ;;;                        and     $80                 ;
 182+ E74C              ;;;                        jr      nz,.YOutOfRange     ;
 183+ E74C              ;;;.CheckXRange:           ld      a,h                 ; if X0 is negative
 184+ E74C              ;;;                        and     a
 185+ E74C              ;;;                        jr      z,.XOKToPlot
 186+ E74C              ;;;                        and     $80
 187+ E74C              ;;;                        jr      z,.NotXNegative
 188+ E74C              ;;;.XNegative:             ld      a,0
 189+ E74C              ;;;                        jp      .ClipXDone
 190+ E74C              ;;;.NotXNegative:          ld      a,255
 191+ E74C              ;;;                        jp      .ClipXDone
 192+ E74C              ;;;.XOKToPlot:             ld      a,l                 ; no clip therefore we can just use l
 193+ E74C              ;;;.ClipXDone:             push    hl
 194+ E74C              ;;;                        push    af                  ; using the Y coordinate
 195+ E74C              ;;;                        ld      hl,l2targetArray1   ; plot the X value for this row
 196+ E74C              ;;;                        ld      a,e
 197+ E74C              ;;;                        add     hl,a
 198+ E74C              ;;;                        pop     af
 199+ E74C              ;;;                        ld      (hl),a
 200+ E74C              ;;;                        pop     hl
 201+ E74C              ;;;.YOutOfRange: ; At this point we have either plotted or its outside array range
 202+ E74C              ;;;                        ld      bc,(l2_X1)
 203+ E74C              ;;;.CheckEndXY:            cpHLEquBC .CheckEndXYOK     ; hl will equal X0 still by here
 204+ E74C              ;;;                        jp      nz,.x0x1Differ
 205+ E74C              ;;;.CheckEndXYOK:          ld      bc,(l2_Y1)
 206+ E74C              ;;;                        cpDEEquBC  .x0x1Differ      ; de will equal Y0 still by here
 207+ E74C              ;;;                        ret     z                   ; if they are both the same we are done
 208+ E74C              ;;;.x0x1Differ:
 209+ E74C              ;;;.SetError2:             ld      hl,(l2_Error)       ; e2 = 2 * error
 210+ E74C              ;;;                        add     hl,hl               ; .
 211+ E74C              ;;;                        ld      (l2_E2),hl          ; .
 212+ E74C              ;;;.CheckE2gteDY:          ld      de,(l2_DY)          ; if e2 >= dy
 213+ E74C              ;;;                        call    compare16HLDE       ; .
 214+ E74C              ;;;                        jp      pe, .E2DyParitySet
 215+ E74C              ;;;                        jp      m,  .E2ltDY         ; to get here overflow clear, so if m is set then HL<DE
 216+ E74C              ;;;                        jp      .E2gteDY
 217+ E74C              ;;;.E2DyParitySet:         jp      p,  .E2ltDY         ; if pe is set, then if sign is clear HL<DE
 218+ E74C              ;;;.E2gteDY:               ld      hl,(l2_X0)          ;      if x0 == x1 break
 219+ E74C              ;;;                        ld      de,(l2_X1)          ;      .
 220+ E74C              ;;;                        cpHLEquDE .ErrorUpdateDY    ;      .
 221+ E74C              ;;;                        ret     z                   ;      .
 222+ E74C              ;;;.ErrorUpdateDY:         ld      hl,(l2_Error)       ;      error = error + dy
 223+ E74C              ;;;                        ld      de,(l2_DY)          ;      .
 224+ E74C              ;;;                        add     hl,de               ;      .
 225+ E74C              ;;;                        ld      (l2_Error),hl       ;      .
 226+ E74C              ;;;.UpdateX0:              ld      hl,(l2_X0)          ;      x0 = x0 + sx
 227+ E74C              ;;;                        ld      bc,(l2_SX)          ;      .
 228+ E74C              ;;;                        add     hl,bc               ;      .
 229+ E74C              ;;;                        ld      (l2_X0),hl          ;      .
 230+ E74C              ;;;.E2ltDY:
 231+ E74C              ;;;.CheckE2lteDX:          ld      hl,(l2_E2)          ; if e2 <= dx
 232+ E74C              ;;;                        ld      de,(l2_DX)          ; as we can't do skip on e2>dx
 233+ E74C              ;;;                        call    compare16HLDE       ; we will jump based on e2 <= dx
 234+ E74C              ;;;                        jp      z, .E2lteDX
 235+ E74C              ;;;                        jp      pe, .E2DxParitySet
 236+ E74C              ;;;                        jp      m,  .E2lteDX         ; to get here overflow clear, so if m is set then HL<DE
 237+ E74C              ;;;                        jp      .E2gteDx
 238+ E74C              ;;;.E2DxParitySet:         jp      p,  .E2lteDX
 239+ E74C              ;;;                        jp      .E2gteDx
 240+ E74C              ;;;.E2lteDX:               ld      hl,(l2_Y0)          ;      .
 241+ E74C              ;;;                        ld      de,(l2_Y1)          ;      .
 242+ E74C              ;;;                        cpHLEquDE .ErrorUdpateDX    ;      .
 243+ E74C              ;;;                        ret     z                   ;      .
 244+ E74C              ;;;.ErrorUdpateDX:         ld      hl,(l2_Error)       ;      error = error + dx
 245+ E74C              ;;;                        ld      de,(l2_DX)          ;      .
 246+ E74C              ;;;                        add     hl,de               ;      .
 247+ E74C              ;;;                        ld      (l2_Error),hl       ;      .
 248+ E74C              ;;;.UpdateY0:              ld      hl,(l2_Y0)          ;      x0 = x0 + sx
 249+ E74C              ;;;                        ld      bc,(l2_SY)          ;      .
 250+ E74C              ;;;                        add     hl,bc              ;      .
 251+ E74C              ;;;                        ld      (l2_Y0),hl         ;      .
 252+ E74C              ;;;.E2gteDx:               jp      .CalcLoop           ; repeat until we have a return
 253+ E74C
 254+ E74C
 255+ E74C              ;;;;;;;; for this it myst always be sorted Y0 -> Y2
 256+ E74C              ;;;;;;;;; note we ca't use this to do x? as it will clip inherently
 257+ E74C              ;;;;;;;l2_save_diagnonal_signed_1:
 258+ E74C              ;;;;;;;                        ld		hl,0                            ;
 259+ E74C              ;;;;;;;                        ld		(l2deltaX),hl                   ;
 260+ E74C              ;;;;;;;                        ld		(l2deltaY),hl
 261+ E74C              ;;;;;;;.CheckYOnScreen:        ld      de,(l2_commonTopY)
 262+ E74C              ;;;;;;;                        ld      hl,(l2_bottomY)
 263+ E74C              ;;;;;;;                        ld      a,d
 264+ E74C              ;;;;;;;                        and     h
 265+ E74C              ;;;;;;;                        and     $80
 266+ E74C              ;;;;;;;                        jr      nz,.OffScreen
 267+ E74C              ;;;;;;;;...dy = y1 - y0
 268+ E74C              ;;;;;;;.CalcDeltaY:            ClearCarryFlag
 269+ E74C              ;;;;;;;                        sbc     hl,de                           ; now delta is signed, if its negative then something bad as gone wrong
 270+ E74C              ;;;;;;;                        ld      a,h
 271+ E74C              ;;;;;;;                        and     $80
 272+ E74C              ;;;;;;;                        jr      nz,.OffScreen
 273+ E74C              ;;;;;;;                        ld      (l2deltaY),hl                   ; Delta signed
 274+ E74C              ;;;;;;;CheckXOnScreen:         ld      de,(l2_leftX)
 275+ E74C              ;;;;;;;                        ld      hl,(l2_rightX)
 276+ E74C              ;;;;;;;                        ld      a,d
 277+ E74C              ;;;;;;;                        and     h
 278+ E74C              ;;;;;;;                        and     $80
 279+ E74C              ;;;;;;;                        jr      nz,.OffScreen
 280+ E74C              ;;;;;;;                        ClearCarryFlag
 281+ E74C              ;;;;;;;;...dx = x1 - x0
 282+ E74C              ;;;;;;;.CalcDeltaX:            sbc     hl,de                           ; now delta is signed, could be negative
 283+ E74C              ;;;;;;;                        ld      (l2deltaX),hl                   ; Delta signed
 284+ E74C              ;;;;;;;                        ld      a,h
 285+ E74C              ;;;;;;;                        and     $80
 286+ E74C              ;;;;;;;                        jr      nz,.LeftToRight
 287+ E74C              ;;;;;;;.RightToLeft:           set up instrnctin
 288+ E74C              ;;;;;;;.LeftToRight:           set up instrnctin
 289+ E74C              ;;;;;;;.setErr:									                    ;  LD H  := (D'-E')/2    round up if +ve or down if -ve
 290+ E74C              ;;;;;;;,FracDYltDX:            ld		hl,(l2deltaY)					; Fraction = dY - dX
 291+ E74C              ;;;;;;;                        ld		de,(l2deltaX)
 292+ E74C              ;;;;;;;                        ClearCarryFlag
 293+ E74C              ;;;;;;;                        sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
 294+ E74C              ;;;;;;;                        ex		de,hl
 295+ E74C              ;;;;;;;                        ld		iyh,d							; we will use IY reg for fractions
 296+ E74C              ;;;;;;;                        ld		iyl,e
 297+ E74C              ;;;;;;;                        jp		p,.fracIsPositive
 298+ E74C              ;;;;;;;
 299+ E74C              ;;;;;;;plotLine(x0, y0, x1, y1)
 300+ E74C              ;;;;;;;    dx = x1 - x0
 301+ E74C              ;;;;;;;    dy = y1 - y0
 302+ E74C              ;;;;;;;    D = 2*dy - dx
 303+ E74C              ;;;;;;;    y = y0
 304+ E74C              ;;;;;;;
 305+ E74C              ;;;;;;;    for x from x0 to x1
 306+ E74C              ;;;;;;;        plot(x,y)
 307+ E74C              ;;;;;;;        if D > 0
 308+ E74C              ;;;;;;;            y = y + 1
 309+ E74C              ;;;;;;;            D = D - 2*dx
 310+ E74C              ;;;;;;;        end if
 311+ E74C              ;;;;;;;        D = D + 2*dy
 312+ E74C              ;;;;;;;
 313+ E74C
 314+ E74C
 315+ E74C
 316+ E74C              ;;;;;.fracIsNegative:        NegIY
 317+ E74C              ;;;;;                        ShiftIYRight1
 318+ E74C              ;;;;;                        NegIY
 319+ E74C              ;;;;;                        jp		.SkipCalcInc					; so we have a negative frac
 320+ E74C              ;;;;;.fracIsPositive:        ShiftIYRight1
 321+ E74C              ;;;;;.SkipCalcInc:		                        			    	; As we loop, bc = to plot current XY
 322+ E74C              ;;;;;.preTargetArray:	    ld		hl,l2targetArray1               ; Assuming row 0
 323+ E74C              ;;;;;l2S_setTarget:	        ld		(l2targetPtr),hl
 324+ E74C              ;;;;;                                                                ; set DE to current row
 325+ E74C              ;;;;;.S_Loop:			    ld		hl,(l2targetPtr)				; Insert into respective array
 326+ E74C              ;;;;;                                                                ; calculate current row
 327+ E74C              ;;;;;                                                                ; if current row >= 0
 328+ E74C              ;;;;;                                                                ; write current X value in DE to (hl)
 329+ E74C              ;;;;;                        ld		a,b
 330+ E74C              ;;;;;                        add		hl,a
 331+ E74C              ;;;;;                        ld		(hl),c
 332+ E74C              ;;;;;l2S_CheckIfEnd:	        ld		a,ixh
 333+ E74C              ;;;;;                        JumpIfAGTENusng	  b,l2S_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
 334+ E74C              ;;;;;                        jp		l2S_Continue
 335+ E74C              ;;;;;l2S_CheckXPos:          ld      a,(l2S_adjustCol)
 336+ E74C              ;;;;;                        cp      l2inccstep; if we self modified to inc the we can do a cp e else its cp c
 337+ E74C              ;;;;;                        jr      z,.IncCP
 338+ E74C              ;;;;;.DecCP:                 ld      a,c
 339+ E74C              ;;;;;                        ReturnIfALTNusng ixl
 340+ E74C              ;;;;;                        ReturnIfAEqNusng ixl
 341+ E74C              ;;;;;                        jp      l2S_Continue
 342+ E74C              ;;;;;.IncCP:                 ld		a,c
 343+ E74C              ;;;;;                        ReturnIfAGTENusng ixl					; if X1 has reached or exceeded X2 then we are done
 344+ E74C              ;;;;;l2S_Continue:
 345+ E74C              ;;;;;l2S_HNegative:			ld		a,iyh
 346+ E74C              ;;;;;                        bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
 347+ E74C              ;;;;;                        jr		z,l2S_ErrNotNegative			;
 348+ E74C              ;;;;;l2S_ErrNegative:		ld		a,(l2deltaY)					; if its a negative error update X
 349+ E74C              ;;;;;                        ld		d,0
 350+ E74C              ;;;;;                        ld		e,a
 351+ E74C              ;;;;;                        add		iy,de							; add deltaY(unsinged) to l2fraction
 352+ E74C              ;;;;;l2S_adjustCol:          nop										; this is our inc/dec of X
 353+ E74C              ;;;;;                        jr		l2S_Loop							; repeat loop
 354+ E74C              ;;;;;l2S_ErrNotNegative:     ld		a,iyh
 355+ E74C              ;;;;;                        or		iyl
 356+ E74C              ;;;;;                        JumpIfAIsZero l2S_ErrZero					; if there is no error then goto zeroerror
 357+ E74C              ;;;;;l2S_ErrPositive:        ld      de,iy;  lddeiy								; if its a positive error then we update Y
 358+ E74C              ;;;;;                        ex		de,hl
 359+ E74C              ;;;;;                        ld		d,0
 360+ E74C              ;;;;;                        ld		a,(l2deltaX)
 361+ E74C              ;;;;;                        ld		e,a
 362+ E74C              ;;;;;                        ClearCarryFlag
 363+ E74C              ;;;;;                        sbc		hl,de
 364+ E74C              ;;;;;                        ex		de,hl
 365+ E74C              ;;;;;                        ld      iy,de;ldiyde
 366+ E74C              ;;;;;l2S_adjustRow:          inc		b								; move Y down by one
 367+ E74C              ;;;;;                        jr		l2S_Loop
 368+ E74C              ;;;;;l2S_ErrZero:            ld		hl,(l2deltaX)
 369+ E74C              ;;;;;                        ex		de,hl
 370+ E74C              ;;;;;                        ld		hl,(l2deltaY)
 371+ E74C              ;;;;;                        ClearCarryFlag
 372+ E74C              ;;;;;                        sbc		hl,de
 373+ E74C              ;;;;;                        ex		de,hl
 374+ E74C              ;;;;;                        ld      iy,de; ldiyde
 375+ E74C              ;;;;;l2S_adjustCol2:         nop										; update X and Y
 376+ E74C              ;;;;;                        inc		b
 377+ E74C              ;;;;;                        jr		l2S_Loop
 378+ E74C              ;;;;;
 379+ E74C              ;;;;;.OffScreen:             SetCarryFlag
 380+ E74C              ;;;;;                        ret
 381+ E74C              ;;;;;
 382+ E74C              ;;;;;
 383+ E74C
 384+ E74C                      IFDEF L2_DIAGONAL_SAVE
 385+ E74C ~            l2_draw_diagonal_save:  cp		1
 386+ E74C ~                                    jr		z,l2S_ItsArray1
 387+ E74C ~                                    ld		hl,l2targetArray2
 388+ E74C ~                                    jp		l2S_setTarget
 389+ E74C ~            l2S_ItsArray1:	        ld		hl,l2targetArray1
 390+ E74C ~            l2S_setTarget:	        ld		(l2targetPtr),hl
 391+ E74C ~            ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
 392+ E74C ~                                    ld		(l2linecolor),a					;save colour for later
 393+ E74C ~                                    ld		hl,0                            ;
 394+ E74C ~                                    ld		(l2deltaX),hl                   ;
 395+ E74C ~                                    ld		(l2deltaY),hl                   ; initlaise deltas as we will only be loading 8 bit in there but workign in 16 bit later
 396+ E74C ~            l2S_preSort:            ld		a,b								;
 397+ E74C ~                                    JumpIfALTNusng	d,l2S_noYSort			; we must have Y1 < Y2 (if eqyal then verical line picked up earlier
 398+ E74C ~            l2S_SortBasedOnY:	    ldhlbc									;
 399+ E74C ~                                    ex		de,hl                           ;
 400+ E74C ~                                    ldbchl									; swap over bc and de using hl as an intermediate
 401+ E74C ~            l2S_noYSort:		    ld		ixh,d							; ixh now holds target Y coord post sorting
 402+ E74C ~                                    ld		ixl,e							; ixl now holds target X coord post sorting
 403+ E74C ~            l2S_setXLen:            ld		a,c                             ;
 404+ E74C ~                                    JumpIfALTNusng e,l2S_PosXLen			; if x1 < x2 then we have a positive increment
 405+ E74C ~            l2S_NegXLen:            ld		a,c                             ;
 406+ E74C ~                                    sub     e                               ;
 407+ E74C ~                                    ld		(l2deltaX),a					; As x1 > x2 we do deltaX = X1 - X2
 408+ E74C ~                                    ld		a,l2deccstep					; and set the value for inc dec self modifying to Dec
 409+ E74C ~                                    jr		l2S_XINCDEC
 410+ E74C ~            ; we set comparison
 411+ E74C ~            l2S_PosXLen:	        ld		a,e                             ;
 412+ E74C ~                                    sub		c                               ;
 413+ E74C ~                                    ld 		(l2deltaX),a                    ; As x1 < x2 we do deltaX = X2 - X1
 414+ E74C ~                                    ld		a,l2inccstep                    ; and set the value for inc dec self modifying to Inc
 415+ E74C ~            ; also need to fix the comparison, if its +x then compare with
 416+ E74C ~            l2S_XINCDEC:	        ld		(l2S_adjustCol),a				;
 417+ E74C ~                                    ld		(l2S_adjustCol2),a				; update self modifying code for X update with inc or dec from above
 418+ E74C ~            l2S_setYLen:            ld		a,d							 	; presorted on Y so it is now always positive
 419+ E74C ~                                    sub		b
 420+ E74C ~                                    ld 		(l2deltaY),a					; DeltaY = Y2 - Y1
 421+ E74C ~            l2S_setErr:									;  LD H  := (D'-E')/2    round up if +ve or down if -ve
 422+ E74C ~            ldS_FracDYltDX:         ld		hl,(l2deltaY)					; Fraction = dY - dX
 423+ E74C ~                                    ld		de,(l2deltaX)
 424+ E74C ~                                    ClearCarryFlag
 425+ E74C ~                                    sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
 426+ E74C ~                                    ex		de,hl
 427+ E74C ~                                    ld		iyh,d							; we will use IY reg for fractions
 428+ E74C ~                                    ld		iyl,e
 429+ E74C ~                                    jp		p,l2S_fracIsPositive
 430+ E74C ~            l2S_fracIsNegative:     NegIY
 431+ E74C ~                                    ShiftIYRight1
 432+ E74C ~                                    NegIY
 433+ E74C ~                                    jp		l2S_SkipCalcInc					; so we have a negative frac
 434+ E74C ~            l2S_fracIsPositive:     ShiftIYRight1
 435+ E74C ~            l2S_SkipCalcInc:		                        				; As we loop, bc = to plot current XY
 436+ E74C ~            l2S_Loop:			    ld		hl,(l2targetPtr)				; Insert into respective array
 437+ E74C ~                                    ld		a,b
 438+ E74C ~                                    add		hl,a
 439+ E74C ~                                    ld		(hl),c
 440+ E74C ~            l2S_CheckIfEnd:	        ld		a,ixh
 441+ E74C ~                                    JumpIfAGTENusng	  b,l2S_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
 442+ E74C ~                                    jp		l2S_Continue
 443+ E74C ~            l2S_CheckXPos:          ld      a,(l2S_adjustCol)
 444+ E74C ~                                    cp      l2inccstep; if we self modified to inc the we can do a cp e else its cp c
 445+ E74C ~                                    jr      z,.IncCP
 446+ E74C ~            .DecCP:                 ld      a,c
 447+ E74C ~                                    ReturnIfALTNusng ixl
 448+ E74C ~                                    ReturnIfAEqNusng ixl
 449+ E74C ~                                    jp      l2S_Continue
 450+ E74C ~            .IncCP:                 ld		a,c
 451+ E74C ~                                    ReturnIfAGTENusng ixl					; if X1 has reached or exceeded X2 then we are done
 452+ E74C ~            l2S_Continue:
 453+ E74C ~            l2S_HNegative:			ld		a,iyh
 454+ E74C ~                                    bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
 455+ E74C ~                                    jr		z,l2S_ErrNotNegative			;
 456+ E74C ~            l2S_ErrNegative:		ld		a,(l2deltaY)					; if its a negative error update X
 457+ E74C ~                                    ld		d,0
 458+ E74C ~                                    ld		e,a
 459+ E74C ~                                    add		iy,de							; add deltaY(unsinged) to l2fraction
 460+ E74C ~            l2S_adjustCol:          nop										; this is our inc/dec of X
 461+ E74C ~                                    jr		l2S_Loop							; repeat loop
 462+ E74C ~            l2S_ErrNotNegative:     ld		a,iyh
 463+ E74C ~                                    or		iyl
 464+ E74C ~                                    JumpIfAIsZero l2S_ErrZero					; if there is no error then goto zeroerror
 465+ E74C ~            l2S_ErrPositive:        ld      de,iy;  lddeiy								; if its a positive error then we update Y
 466+ E74C ~                                    ex		de,hl
 467+ E74C ~                                    ld		d,0
 468+ E74C ~                                    ld		a,(l2deltaX)
 469+ E74C ~                                    ld		e,a
 470+ E74C ~                                    ClearCarryFlag
 471+ E74C ~                                    sbc		hl,de
 472+ E74C ~                                    ex		de,hl
 473+ E74C ~                                    ld      iy,de;ldiyde
 474+ E74C ~            l2S_adjustRow:          inc		b								; move Y down by one
 475+ E74C ~                                    jr		l2S_Loop
 476+ E74C ~            l2S_ErrZero:            ld		hl,(l2deltaX)
 477+ E74C ~                                    ex		de,hl
 478+ E74C ~                                    ld		hl,(l2deltaY)
 479+ E74C ~                                    ClearCarryFlag
 480+ E74C ~                                    sbc		hl,de
 481+ E74C ~                                    ex		de,hl
 482+ E74C ~                                    ld      iy,de; ldiyde
 483+ E74C ~            l2S_adjustCol2:         nop										; update X and Y
 484+ E74C ~                                    inc		b
 485+ E74C ~                                    jr		l2S_Loop
 486+ E74C                      ENDIF
 487+ E74C                      DEFINE  L2_DRAW_DIAGONAL 1
 488+ E74C                      IFDEF L2_DRAW_DIAGONAL
 489+ E74C              ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
 490+ E74C 32 44 E5     l2_draw_diagonal:       ld		(l2linecolor),a					;save colour for later
 491+ E74F 21 00 00                             ld		hl,0                            ;
 492+ E752 22 3C E5                             ld		(l2deltaX),hl                   ;
 493+ E755 22 3A E5                             ld		(l2deltaY),hl                   ; initlaise deltas as we will only be loading 8 bit in there but workign in 16 bit later
 494+ E758 78           l2D_preSort:            ld		a,b								;
 495+ E759                                      JumpIfALTNusng	d,l2D_noYSort			; we must have Y1 < Y2 (if equal then verical line picked up earlier
 495+ E759 BA          >                        cp      d
 495+ E75A DA 62 E7    >                        jp		c, l2D_noYSort
 496+ E75D              l2D_SortBasedOnY:	    ldhlbc									;
 496+ E75D 60          >                        ld		h,b
 496+ E75E 69          >                        ld		l,c
 497+ E75F EB                                   ex		de,hl                           ;
 498+ E760                                      ldbchl									; swap over bc and de using hl as an intermediate
 498+ E760 44          >                        ld		b,h
 498+ E761 4D          >                        ld		c,l
 499+ E762 DD 62        l2D_noYSort:		    ld		ixh,d							; ixh now holds target Y coord post sorting
 500+ E764 DD 6B                                ld		ixl,e							; ixl now holds target X coord post sorting
 501+ E766 79           l2D_setXLen:            ld		a,c                             ;
 502+ E767                                      JumpIfALTNusng e,l2D_PosXLen			; if x1 < x2 then we have a positive increment
 502+ E767 BB          >                        cp      e
 502+ E768 DA 74 E7    >                        jp		c, l2D_PosXLen
 503+ E76B 79           l2D_NegXLen:            ld		a,c                             ;
 504+ E76C 93                                   sub     e                               ;
 505+ E76D 32 3C E5                             ld		(l2deltaX),a					; As x1 > x2 we do deltaX = X1 - X2
 506+ E770 3E 0D                                ld		a,l2deccstep					; and set the value for inc dec self modifying to Dec
 507+ E772 18 07                                jr		l2D_XINCDEC
 508+ E774 7B           l2D_PosXLen:	        ld		a,e                             ;
 509+ E775 91                                   sub		c                               ;
 510+ E776 32 3C E5                             ld 		(l2deltaX),a                    ; As x1 < x2 we do deltaX = X2 - X1
 511+ E779 3E 0C                                ld		a,l2inccstep                    ; and set the value for inc dec self modifying to Inc
 512+ E77B 32 F6 E7     l2D_XINCDEC:	        ld		(l2D_adjustCol),a				;
 513+ E77E 32 26 E8                             ld		(l2D_adjustCol2),a				; update self modifying code for X update with inc or dec from above
 514+ E781 7A           l2D_setYLen				ld		a,d							 	; presorted on Y so it is now always positive
 515+ E782 90                                   sub		b
 516+ E783 32 3A E5                             ld 		(l2deltaY),a					; DeltaY = Y2 - Y1
 517+ E786              l2D_setErr:									;  LD H  := (D'-E')/2    round up if +ve or down if -ve
 518+ E786 2A 3A E5     ldD_FracDYltDX:			ld		hl,(l2deltaY)					; Fraction = dY - dX
 519+ E789 ED 5B 3C E5                          ld		de,(l2deltaX)
 520+ E78D                                      ClearCarryFlag
 520+ E78D B7          >                        or a
 521+ E78E ED 52                                sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
 522+ E790 EB                                   ex		de,hl
 523+ E791 FD 62                                ld		iyh,d							; we will use IY reg for fractions
 524+ E793 FD 6B                                ld		iyl,e
 525+ E795 F2 BA E7                             jp		p,l2D_fracIsPositive
 526+ E798              l2D_fracIsNegative:     NegIY
 526+ E798 AF          >                    xor a
 526+ E799 FD 95       >                    sub iyl
 526+ E79B FD 6F       >                    ld iyl,a
 526+ E79D 9F          >                    sbc a,a
 526+ E79E FD 94       >                    sub iyh
 526+ E7A0 FD 67       >                    ld iyh,a
 527+ E7A2                                      ShiftIYRight1
 527+ E7A2 FD 7C       >			   ld 	a,iyh
 527+ E7A4 CB 3F       >			   srl 	a
 527+ E7A6 FD 67       >			   ld	iyh,a
 527+ E7A8 FD 7D       >			   ld 	a,iyl
 527+ E7AA 1F          >			   rra
 527+ E7AB FD 6F       >			   ld	iyl,a
 528+ E7AD                                      NegIY
 528+ E7AD AF          >                    xor a
 528+ E7AE FD 95       >                    sub iyl
 528+ E7B0 FD 6F       >                    ld iyl,a
 528+ E7B2 9F          >                    sbc a,a
 528+ E7B3 FD 94       >                    sub iyh
 528+ E7B5 FD 67       >                    ld iyh,a
 529+ E7B7 C3 C5 E7                             jp		l2D_SkipCalcInc					; so we have a negative frac
 530+ E7BA              l2D_fracIsPositive:     ShiftIYRight1
 530+ E7BA FD 7C       >			   ld 	a,iyh
 530+ E7BC CB 3F       >			   srl 	a
 530+ E7BE FD 67       >			   ld	iyh,a
 530+ E7C0 FD 7D       >			   ld 	a,iyl
 530+ E7C2 1F          >			   rra
 530+ E7C3 FD 6F       >			   ld	iyl,a
 531+ E7C5              l2D_SkipCalcInc:
 532+ E7C5 C5 D5        l2D_Loop:				push	bc,,de                 			; l2DeltaY and l2DeltaX are set
 533+ E7C7 3A 44 E5                             ld		a,(l2linecolor)     			;
 534+ E7CA                                      l2_plot_macro;call	l2_plot_pixel       			; Plot Pixel
 534+ E7CA 78          >                        ld      a,b
 534+ E7CB             >                        JumpIfAGTENusng 192 ,.NoPlot
 534+ E7CB FE C0       >                        cp     192
 534+ E7CD D2 D9 E7    >                        jp		nc,.NoPlot
 534+ E7D0 69          >                        ld      l,c
 534+ E7D1 CD 68 E0    >                        call    asm_l2_row_bank_select
 534+ E7D4 67          >                        ld      h,a
 534+ E7D5 3A 8D E2    >                        ld      a,(line_gfx_colour)
 534+ E7D8 77          >                        ld      (hl),a
 534+ E7D9             >.NoPlot:
 535+ E7D9 D1 C1                                pop     bc,,de
 536+ E7DB DD 7C        l2D_CheckIfEnd:	        ld		a,ixh
 537+ E7DD                                      JumpIfAGTENusng	  b,l2D_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
 537+ E7DD B8          >                        cp     b
 537+ E7DE D2 E4 E7    >                        jp		nc,l2D_CheckXPos
 538+ E7E1 C3 E8 E7                             jp		l2D_Continue
 539+ E7E4 79           l2D_CheckXPos:          ld		a,c
 540+ E7E5                                      ReturnIfAEqNusng ixl					; if X1 has reached or exceeded X2 then we are done
 540+ E7E5 DD BD       >                        cp      ixl
 540+ E7E7 C8          >                        ret     z
 541+ E7E8              l2D_Continue:
 542+ E7E8 FD 7C        l2D_HNegative:			ld		a,iyh
 543+ E7EA CB 7F                                bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
 544+ E7EC 28 0B                                jr		z,l2D_ErrNotNegative			;
 545+ E7EE 3A 3A E5     l2D_ErrNegative:		ld		a,(l2deltaY)
 546+ E7F1 16 00                                ld		d,0
 547+ E7F3 5F                                   ld		e,a
 548+ E7F4 FD 19                                add		iy,de							; add deltaY(unsinged) to l2fraction
 549+ E7F6 00           l2D_adjustCol:          nop										; this is our inc/dec of X
 550+ E7F7 18 CC                                jr		l2D_Loop							; repeat loop
 551+ E7F9 FD 7C        l2D_ErrNotNegative:     ld		a,iyh
 552+ E7FB FD B5                                or		iyl
 553+ E7FD                                      JumpIfAIsZero l2D_ErrZero					; if there is no error then goto zeroerror
 553+ E7FD A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 553+ E7FE CA 17 E8    >                        jp	    z, l2D_ErrZero
 554+ E801 FD 54 FD 5D  l2D_ErrPositive:		ld      de,iy;lddeiy
 555+ E805 EB                                   ex		de,hl
 556+ E806 16 00                                ld		d,0
 557+ E808 3A 3C E5                             ld		a,(l2deltaX)
 558+ E80B 5F                                   ld		e,a
 559+ E80C                                      ClearCarryFlag
 559+ E80C B7          >                        or a
 560+ E80D ED 52                                sbc		hl,de
 561+ E80F EB                                   ex		de,hl
 562+ E810 FD 62 FD 6B                          ld      iy,de;ldiyde
 563+ E814 04           l2D_adjustRow:			inc		b
 564+ E815 18 AE                                jr		l2D_Loop
 565+ E817 2A 3C E5     l2D_ErrZero:            ld		hl,(l2deltaX)
 566+ E81A EB                                   ex		de,hl
 567+ E81B 2A 3A E5                             ld		hl,(l2deltaY)
 568+ E81E                                      ClearCarryFlag
 568+ E81E B7          >                        or a
 569+ E81F ED 52                                sbc		hl,de
 570+ E821 EB                                   ex		de,hl
 571+ E822 FD 62 FD 6B                          ld      iy,de;ldiyde
 572+ E826 00           l2D_adjustCol2:         nop										; update X and Y
 573+ E827 04                                   inc		b
 574+ E828 18 9B                                jr		l2D_Loop
 575+ E82A              ;----------------------------------------------------------------------------------------------------------------------------------
 576+ E82A                      ENDIF
 577+ E82A
 578+ E82A
 579+ E82A
 580+ E82A              ;Loin:				; BBC version of line draw
 581+ E82A              ;; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color)"
 582+ E82A              ;	ld		(l2linecolor),a					; save colour as a reg gets used alot, coudl move this into interrupt flag and disable interrups
 583+ E82A              ;	ld		ixh,0							; ixh = s
 584+ E82A              ;	ld		iyh,0							; iyh = swap
 585+ E82A              ;	ld		l,0								; l will hold delta sign flags
 586+ E82A              ;LoinCalcDeltaX:
 587+ E82A              ;	ld		a,e
 588+ E82A              ;	sub		c								; a = deltaX
 589+ E82A              ;	JumpIfPositive LoinPosDx
 590+ E82A              ;LoinNegDx:
 591+ E82A              ;	neg										; carry flag will indicate deltaX was negative
 592+ E82A              ;	ld		l,$80							; set bit 7 of l for negative
 593+ E82A              ;LoinPosDx:
 594+ E82A              ;	ld		ixl,a							; ixl = varP = deltaX
 595+ E82A              ;LoinCalcDeltaY:
 596+ E82A              ;	ld		a,d
 597+ E82A              ;	sub		b								; a= deltaY
 598+ E82A              ;	JumpIfPositive LoinPosDy
 599+ E82A              ;LoinNegDy:
 600+ E82A              ;	neg
 601+ E82A              ;	set		6,l								; set bit 6 of l for negative deltaY
 602+ E82A              ;LoinPosDy:
 603+ E82A              ;	ld		iyl,a							; iyl = varQ = deltaY
 604+ E82A              ;	JumpIfAGTENusng ixl, LoinSTPy			; if deltaY >= DeltaX then step along Y
 605+ E82A              ;LoinSTPx:									; step along X
 606+ E82A              ;	JumpOnBitClear l,7						; if l flags were clear then X2 < X2
 607+ E82A              ;LoinSTPxSwapCoords:
 608+ E82A              ;	dec		iyh								; swap flag now becomes FF
 609+ E82A              ;	ld		a,l								; save l flags
 610+ E82A              ;	ex		de,hl							; save de to hl
 611+ E82A              ;	lddebc									; Point2 = point1
 612+ E82A              ;	ldbchl									; Point1 = point2 that was saved
 613+ E82A              ;	ld		l,a								; get back l flags
 614+ E82A              ;LoinSTPxCorrectOrder:
 615+ E82A              ;	l2_point_pixel_y_safe					; call plot pixel preseving bc hl
 616+ E82A              ;	ld		a,iyl							; get delta Y back
 617+ E82A              ;	ld		iy1,$FE							; roll counter
 618+ E82A              ;LionSTPxRollQ:
 619+ E82A              ;	sla		a								; highest bit of delta-Y
 620+ E82A              ;	jp		c,LoinSTPxSteep
 621+ E82A              ;	cp		ixl								; compare with DeltaX
 622+ E82A              ;	jp		cs,LoinSTPxShallow
 623+ E82A              ;LoinSTPxSteep:								;; LI4
 624+ E82A              ;	sbc		a,ixl							; deltaYwork -= (deltaX+1)
 625+ E82A              ;	scf										; force carry flag set
 626+ E82A              ;LoinSTPxShallow:							;; LI5
 627+ E82A              ;	rl		iyl								; rotate iyl which started as FE
 628+ E82A              ;	jp		c,LionSTPxRollQ					; so we are doing a 6 bit loop
 629+ E82A              ;	inc		ihl								; DeltaX += 1
 630+ E82A              ;LoinSTPxYDirection:							; change this to self modifying code
 631+ E82A              ;	ld		a,d
 632+ E82A              ;	JumpIfAGTEn	b,LionDOWN:
 633+ E82A              ;	ld		a,iyh							; swap flag
 634+ E82A              ;	JumpIfANotZero	X1Inc  					; if swap flag was not set then no need to update R
 635+ E82A              ;LoinSTPxX1Dec:
 636+ E82A              ;	dec		c								; move left 1 pixel as we sawped
 637+ E82A              ;LoinSTPxXCounter:							;; LIL2
 638+ E82A              ;	sub		b
 639+ E82A              ;	if
 640+ E82A              ;
 641+ E82A              ;85 82                   STA &82	   \ R	\ mask byte
 642+ E82A              ;A5 81                   LDA &81	   \ Q	\ delta-Y
 643+ E82A              ;A2 FE                   LDX #&FE	\ roll counter
 644+ E82A              ;86 81                   STX &81		\ Q
 645+ E82A              ;.LIL1	\ roll Q
 646+ E82A              ;0A                      ASL A		\ highest bit of delta-Y
 647+ E82A              ;B0 04                   BCS LI4		\ steep
 648+ E82A              ;C5 1B                   CMP &1B	   \ P	\ delta-X
 649+ E82A              ;90 03                   BCC LI5		\ shallow
 650+ E82A              ;.LI4	\ steep
 651+ E82A              ;E5 1B                   SBC &1B		\ P
 652+ E82A              ;38                      SEC
 653+ E82A              ;.LI5	\ shallow
 654+ E82A              ;26 81                   ROL &81	   \ Q	\ #&FE
 655+ E82A              ;B0 F2                   BCS LIL1 	\ loop Q, end with some low bits in Q
 656+ E82A              ;A6 1B                   LDX &1B		\ P
 657+ E82A              ;E8                      INX 		\ Xreg is width
 658+ E82A              ;A5 37                   LDA &37		\ Y2
 659+ E82A              ;E5 35                   SBC &35		\ Y1
 660+ E82A              ;B0 2C                   BCS DOWN	\ draw line to the right and down
 661+ E82A              ;A5 90                   LDA &90		\ SWAP
 662+ E82A              ;D0 07                   BNE LI6		\ else Xreg was correct after all, no need to update R
 663+ E82A              ;CA                      DEX
 664+ E82A              ;.LIL2	\ counter X width
 665+ E82A              ;A5 82                   LDA &82	   \ R	\ mask byte
 666+ E82A              ;51 07                   EOR (&07),Y	\ (SC),Y
 667+ E82A              ;91 07                   STA (&07),Y	\ (SC),Y
 668+ E82A              ;.LI6	\ Xreg correct
 669+ E82A              ;46 82                   LSR &82	   \ R	\ mask byte
 670+ E82A              ;90 08                   BCC LI7   	\ else moving to next column to right. Bring carry in back
 671+ E82A              ;66 82                   ROR &82		\ R
 672+ E82A              ;A5 07                   LDA &07		\ SC
 673+ E82A              ;69 08                   ADC #8		\ next column
 674+ E82A              ;85 07                   STA &07		\ SC
 675+ E82A              ;.LI7	\ S += Q. this is like an overflow monitor to update Y
 676+ E82A              ;A5 83                   LDA &83		\ S
 677+ E82A              ;65 81                   ADC &81	   \ Q	\ some low bits
 678+ E82A              ;85 83                   STA &83		\ S
 679+ E82A              ;90 07                   BCC LIC2	\ skip Y adjustment
 680+ E82A              ;88                      DEY
 681+ E82A              ;10 04                   BPL LIC2	\ skip Y adjustment
 682+ E82A              ;C6 08                   DEC &08		\ SC+1
 683+ E82A              ;A0 07                   LDY #7
 684+ E82A              ;.LIC2	\ skip Y adjustment
 685+ E82A              ;CA                      DEX
 686+ E82A              ;D0 DC                   BNE LIL2	\ loop X width
 687+ E82A              ;A4 85                   LDY &85	 \ YSAV \ restore Yreg
 688+ E82A              ;60                      RTS
 689+ E82A              ;
 690+ E82A              ;.DOWN	\ Line is going to the right and down
 691+ E82A              ;A5 90                   LDA &90		\ SWAP
 692+ E82A              ;F0 07                   BEQ LI9		\ no swap
 693+ E82A              ;CA                      DEX
 694+ E82A              ;.LIL3	\ counter X width
 695+ E82A              ;A5 82                   LDA &82	    \ R \ mask byte
 696+ E82A              ;51 07                   EOR (&07),Y	\ (SC),Y
 697+ E82A              ;91 07                   STA (&07),Y	\ (SC),Y
 698+ E82A              ;.LI9	\ no swap
 699+ E82A              ;46 82                   LSR &82		\ R
 700+ E82A              ;90 08                   BCC LI10	\ still in correct column, hop
 701+ E82A              ;66 82                   ROR &82		\ R
 702+ E82A              ;A5 07                   LDA &07		\ SC
 703+ E82A              ;69 08                   ADC #8		\ next column
 704+ E82A              ;85 07                   STA &07		\ SC
 705+ E82A              ;.LI10	\ this is like an overflow monitor to update Y
 706+ E82A              ;A5 83                   LDA &83		\ S
 707+ E82A              ;65 81                   ADC &81		\ Q
 708+ E82A              ;85 83                   STA &83		\ S
 709+ E82A              ;90 09                   BCC LIC3	\ skip Y adjustment
 710+ E82A              ;C8                      INY
 711+ E82A              ;C0 08                   CPY #8
 712+ E82A              ;D0 04                   BNE LIC3	\ have not reached bottom byte of char, hop
 713+ E82A              ;E6 08                   INC &08		\ SC+1
 714+ E82A              ;A0 00                   LDY #0
 715+ E82A              ;.LIC3	\ skipped Y adjustment
 716+ E82A              ;CA                      DEX
 717+ E82A              ;D0 DA                   BNE LIL3	\ loop X width
 718+ E82A              ;A4 85                   LDY &85	 \ YSAV \ restore Yreg
 719+ E82A              ;60                      RTS
 720+ E82A              ;
 721+ E82A              ;.STPY	\ -> &1797 \ Step along y for line, goes down and to right
 722+ E82A              ;A4 35                   LDY &35		\ Y1
 723+ E82A              ;98                      TYA
 724+ E82A              ;A6 34                   LDX &34		\ X1
 725+ E82A              ;C4 37                   CPY &37		\ Y2
 726+ E82A              ;B0 10                   BCS LI15	\ skip swap if Y1 >= Y2
 727+ E82A              ;C6 90                   DEC &90		\ SWAP
 728+ E82A              ;A5 36                   LDA &36		\ X2
 729+ E82A              ;85 34                   STA &34		\ X1
 730+ E82A              ;86 36                   STX &36		\ X2
 731+ E82A              ;AA                      TAX
 732+ E82A              ;A5 37                   LDA &37		\ Y2
 733+ E82A              ;85 35                   STA &35		\ Y1
 734+ E82A              ;84 37                   STY &37		\ Y2
 735+ E82A              ;A8                      TAY
 736+ E82A              ;.LI15	\ Y1 Y2 order is now correct
 737+ E82A              ;4A                      LSR A
 738+ E82A              ;4A                      LSR A
 739+ E82A              ;4A                      LSR A
 740+ E82A              ;09 60                   ORA #&60
 741+ E82A              ;85 08                   STA &08	 \ SC+1	\ screen hi
 742+ E82A              ;8A                      TXA 		\ X1
 743+ E82A              ;29 F8                   AND #&F8
 744+ E82A              ;85 07                   STA &07	  \ SC	\ screen lo
 745+ E82A              ;8A                      TXA
 746+ E82A              ;29 07                   AND #7		\ mask index
 747+ E82A              ;AA                      TAX
 748+ E82A              ;BD AF 16                LDA &16AF,X \ TWOS,X \ Mode4 single pixel
 749+ E82A              ;85 82                   STA &82	    \ R	\ mask
 750+ E82A              ;A5 35                   LDA &35		\ Y1
 751+ E82A              ;29 07                   AND #7
 752+ E82A              ;A8                      TAY
 753+ E82A              ;A5 1B                   LDA &1B	    \ P	\ delta-X
 754+ E82A              ;A2 01                   LDX #1		\ roll counter
 755+ E82A              ;86 1B                   STX &1B	    	\ P
 756+ E82A              ;.LIL4	\ roll P
 757+ E82A              ;0A                      ASL A
 758+ E82A              ;B0 04                   BCS LI13	\ do subtraction
 759+ E82A              ;C5 81                   CMP &81	    \ Q	\ delta-Y
 760+ E82A              ;90 03                   BCC LI14	\ less than Q
 761+ E82A              ;.LI13	\ do subtraction
 762+ E82A              ;E5 81                   SBC &81		\ Q
 763+ E82A              ;38                      SEC
 764+ E82A              ;.LI14	\ less than Q
 765+ E82A              ;26 1B                   ROL &1B		\ P
 766+ E82A              ;90 F2                   BCC LIL4	\ loop P, end with some low bits in P
 767+ E82A              ;A6 81                   LDX &81		\ Q
 768+ E82A              ;E8                      INX 		\ adjust height
 769+ E82A              ;A5 36                   LDA &36		\ X2
 770+ E82A              ;E5 34                   SBC &34		\ X1
 771+ E82A              ;90 2D                   BCC LFT		\ if C cleared then line moving to the left - hop down
 772+ E82A              ;18                      CLC
 773+ E82A              ;A5 90                   LDA &90		\ SWAP
 774+ E82A              ;F0 07                   BEQ LI17 	\ skip first point
 775+ E82A              ;CA                      DEX
 776+ E82A              ;.LIL5	\ skipped first point, counter X
 777+ E82A              ;A5 82                   LDA &82	    \ R \ mask byte
 778+ E82A              ;51 07                   EOR (&07),Y	\ (SC),Y
 779+ E82A              ;91 07                   STA (&07),Y	\ (SC),Y
 780+ E82A              ;.LI17	\ skipped first point
 781+ E82A              ;88                      DEY
 782+ E82A              ;10 04                   BPL LI16	\ skip hi adjust
 783+ E82A              ;C6 08                   DEC &08		\ SC+1
 784+ E82A              ;A0 07                   LDY #7		\ new char
 785+ E82A              ;	.LI16	\ skipped hi adjust
 786+ E82A              ;A5 83                   LDA &83		\ S
 787+ E82A              ;65 1B                   ADC &1B		\ P
 788+ E82A              ;85 83                   STA &83		\ S
 789+ E82A              ;90 0C                   BCC LIC5	\ skip, still in same column
 790+ E82A              ;46 82                   LSR &82	  \ R	\ mask
 791+ E82A              ;90 08                   BCC LIC5  	\ no mask bit hop
 792+ E82A              ;66 82                   ROR &82   \ R	\ else moved over to next column, reset mask
 793+ E82A              ;A5 07                   LDA &07	  \ SC  \ screen lo
 794+ E82A              ;69 08                   ADC #8		\ next char below
 795+ E82A              ;85 07                   STA &07		\ SC
 796+ E82A              ;.LIC5	\ same column
 797+ E82A              ;CA                      DEX
 798+ E82A              ;D0 DC                   BNE LIL5	\ loop X height
 799+ E82A              ;A4 85                   LDY &85	 \ YSAV	\ restore Yreg
 800+ E82A              ;60                      RTS
 801+ E82A              ;
 802+ E82A              ;.LFT	\ going left
 803+ E82A              ;A5 90                   LDA &90		\ SWAP
 804+ E82A              ;F0 07                   BEQ LI18	\ skip first point
 805+ E82A              ;CA                      DEX 		\ reduce height
 806+ E82A              ;.LIL6	\ counter X height
 807+ E82A              ;A5 82                   LDA &82	   \ R	\ mask byte
 808+ E82A              ;51 07                   EOR (&07),Y	\ (SC),Y
 809+ E82A              ;91 07                   STA (&07),Y	\ (SC),Y
 810+ E82A              ;.LI18
 811+ E82A              ;88                      DEY
 812+ E82A              ;10 04                   BPL LI19	\ skip hi adjust
 813+ E82A              ;C6 08                   DEC &08		\ SC+1
 814+ E82A              ;A0 07                   LDY #7		\ rest char row
 815+ E82A              ;.LI19	\ skipped hi adjust
 816+ E82A              ;A5 83                   LDA &83		\ S
 817+ E82A              ;65 1B                   ADC &1B	    \ P \ some low bits
 818+ E82A              ;85 83                   STA &83		\ S
 819+ E82A              ;90 0D                   BCC LIC6	\ no overflow
 820+ E82A              ;06 82                   ASL &82	    \ R \ else move byte mask to the left
 821+ E82A              ;90 09                   BCC LIC6	\ no overflow
 822+ E82A              ;26 82                   ROL &82		\ R
 823+ E82A              ;A5 07                   LDA &07		\ SC
 824+ E82A              ;E9 07                   SBC #7		\ down 1 char
 825+ E82A              ;85 07                   STA &07		\ SC
 826+ E82A              ;18                      CLC
 827+ E82A              ;.LIC6	\ no overflow
 828+ E82A              ;CA                      DEX 		\ height
 829+ E82A              ;D0 DB                   BNE LIL6	\ loop X
 830+ E82A              ;A4 85                   LDY &85	 \ YSAV	\ restore Yreg
 831+ E82A              ;.HL6
 832+ E82A              ;60                      RTS 		\ end Line drawing
 833+ E82A
 834+ E82A
 835+ E82A              ;;l2_draw_diagonalopt:
 836+ E82A                              DISPLAY "TODO: optimisation"
 837+ E82A              	; ">TODO l2_draw_diagonalopt fast horz vert optmisation"
 838+ E82A              ;;	push	af
 839+ E82A              ;;	ld		a,b
 840+ E82A              ;;	cp		d
 841+ E82A              ;;	jr		z,.RegularDiagnonal
 842+ E82A              ;;.CheckHorz:
 843+ E82A              ;;	ld		a,c
 844+ E82A              ;;	cp		e
 845+ E82A              ;;	jr		z,.horizontalLine
 846+ E82A              ;;.RegularDiagnonal:
 847+ E82A              ;;	pop		af
 848+ E82A              ;;	call diag
 849+ E82A
 850+ E82A
 851+ E82A              ;;l2_signed_mul2a:
 852+ E82A              ;;; ">l2_signed_mul2a - Signed a = a * 2 using shift)"
 853+ E82A              ;;	TEST	$80
 854+ E82A              ;;	jr		nz, .negativecalc
 855+ E82A              ;;.positivecalc:
 856+ E82A              ;;	ccf
 857+ E82A              ;;	rla
 858+ E82A              ;;	ret
 859+ E82A              ;;.negativecalc:
 860+ E82A              ;;	neg
 861+ E82A              ;;	ccf
 862+ E82A              ;;	rla
 863+ E82A              ;;	neg
 864+ E82A              ;;	ret
 865+ E82A              ;;
 866+ E82A              ;;l2_signed_mul2atohl:
 867+ E82A              ;;; ">l2_signed_mul2ahl - Signed hl = a * 2 using shift)"
 868+ E82A              ;;	TEST	$80
 869+ E82A              ;;	jr		nz, .negativecalc
 870+ E82A              ;;.positivecalc:
 871+ E82A              ;;	ld		hl,0
 872+ E82A              ;;	ld		l,a
 873+ E82A              ;;	add		hl,a
 874+ E82A              ;;	ret
 875+ E82A              ;;.negativecalc:
 876+ E82A              ;;	neg
 877+ E82A              ;;	ld		hl,0
 878+ E82A              ;;	ld		l,a
 879+ E82A              ;;	neghl
 880+ E82A              ;;	ret
 881+ E82A              ;;
 882+ E82A              ;;l2_e2fractionby2:
 883+ E82A              ;;	ld 		hl,(l2fraction)
 884+ E82A              ;;	push	de
 885+ E82A              ;;	ld		d,h
 886+ E82A              ;;	ld		e,l
 887+ E82A              ;;	add		hl,de
 888+ E82A              ;;	pop		de
 889+ E82A              ;;	ld		(l2e2),hl
 890+ E82A              ;;	ret
 891+ E82A
 892+ E82A
 893+ E82A
 894+ E82A
 895+ E82A
 896+ E82A              ;;//	ld		(l2linecolor),a   			; could do an ex but it will be needed multiple times between many uses of a reg
 897+ E82A              ;;//.catchLoop:
 898+ E82A              ;;//	jp .catchLoop
 899+ E82A              ;;//.continue:
 900+ E82A              ;;//    ld      A,D
 901+ E82A              ;;//    sub     H
 902+ E82A              ;;//    jr      NC,.DXpositive    ;delta_x > 0
 903+ E82A              ;;//.DXNegative:
 904+ E82A              ;;//    neg
 905+ E82A              ;;//.DXPositive:
 906+ E82A              ;;//    ld      B,A              ;B <- |delta_x|
 907+ E82A              ;;//    ld      A,E
 908+ E82A              ;;//    sub     L
 909+ E82A              ;;//    jr      NC,.DYpositive    ;delta_y > 0
 910+ E82A              ;;//.DYNegative:
 911+ E82A              ;;//    neg
 912+ E82A              ;;//.DYPositive:
 913+ E82A              ;;//    sub     B               ;|delta_y|
 914+ E82A              ;;//	push	af
 915+ E82A              ;;//	jr		c,.DeltaX
 916+ E82A              ;;//.DeltaY
 917+ E82A              ;;//	ld      A,H             			;if |delta_x| < |delta_y| then
 918+ E82A              ;;//    ld      H,L             			;then values x and y are swapped
 919+ E82A              ;;//    ld      L,A             			;so the loop will always be performed on the
 920+ E82A              ;;//    ld      A,D             			;x value. A flag must be set to
 921+ E82A              ;;//    ld      D,E             			;remind that data must be drawn (y,x)
 922+ E82A              ;;//    ld      E,A             			;instead of (x,y)
 923+ E82A              ;;//.DeltaX:
 924+ E82A              ;;//	ld		a,d
 925+ E82A              ;;//	sub		h
 926+ E82A              ;;//	jr		nc,.TestDY					; x1 < x2
 927+ E82A              ;;//.TestDX:
 928+ E82A              ;;//	ex		de,hl
 929+ E82A              ;;//.TestDY:
 930+ E82A              ;;//	ld		a,e
 931+ E82A              ;;//	sub		l
 932+ E82A              ;;//    ld      A,$01
 933+ E82A              ;;//    jr      NC,.StoreA
 934+ E82A              ;;//    neg                     ;y1 > y2 : in case2 the 'y' variable
 935+ E82A              ;;//.StoreA:
 936+ E82A              ;;//        ld      (l2way),A
 937+ E82A              ;;//.InitLine:
 938+ E82A              ;;//        ld      B,H
 939+ E82A              ;;//        ld      C,L
 940+ E82A              ;;//        ld      A,E
 941+ E82A              ;;//        sub     L
 942+ E82A              ;;//        jr      NC,.EndInit
 943+ E82A              ;;//        ld      A,L
 944+ E82A              ;;//        ld      L,E
 945+ E82A              ;;//        ld      E,A
 946+ E82A              ;;//.EndInit:
 947+ E82A              ;;//        ld      A,E
 948+ E82A              ;;//        sub     L
 949+ E82A              ;;//        rla
 950+ E82A              ;;//        ld      L,A             ;value to add in case1 (d < 0)
 951+ E82A              ;;//        add     A,H
 952+ E82A              ;;//        sub     D
 953+ E82A              ;;//        ld      E,A             ;'d' variable is initialised
 954+ E82A              ;;//        add     A,H
 955+ E82A              ;;//        sub     D
 956+ E82A              ;;//        ld      H,A             ;value to add in case2 (d >= 0)
 957+ E82A              ;;//.Loop:
 958+ E82A              ;;//        ld      A,B
 959+ E82A              ;;//        sub     D
 960+ E82A              ;;//        jr      NC,.EndLine       ;the line is completely drawn.
 961+ E82A              ;;//        pop     AF
 962+ E82A              ;;//        bit     7,A
 963+ E82A              ;;//        push    AF
 964+ E82A              ;;//        push    AF
 965+ E82A              ;;//        push    BC
 966+ E82A              ;;//        jr      Z,.DrawPoint
 967+ E82A              ;;//        ld      A,B
 968+ E82A              ;;//        ld      B,C
 969+ E82A              ;;//        ld      C,A
 970+ E82A              ;;//.DrawPoint:
 971+ E82A              ;;//		push	hl
 972+ E82A              ;;//		pushbcdeaf
 973+ E82A              ;;//		ld		b,e
 974+ E82A              ;;//		ld		c,d
 975+ E82A              ;;//	ld 		a,(l2linecolor)
 976+ E82A              ;;//	call	l2_plot_pixel
 977+ E82A              ;;//		popafdebc
 978+ E82A              ;;//		pop		hl
 979+ E82A              ;;//        pop     BC
 980+ E82A              ;;//        pop     AF
 981+ E82A              ;;//.TestD:
 982+ E82A              ;;//        bit     7,E
 983+ E82A              ;;//        jr      NZ,.Case1
 984+ E82A              ;;//.Case2:                          ;d >= 0
 985+ E82A              ;;//        ld      A,E
 986+ E82A              ;;//        add     A,H
 987+ E82A              ;;//        ld      E,A
 988+ E82A              ;;//        ld      A,(l2way)
 989+ E82A              ;;//        add     A,C
 990+ E82A              ;;//        ld      C,A
 991+ E82A              ;;//        jr      .EndLoop
 992+ E82A              ;;//.Case1:                          ;d < 0
 993+ E82A              ;;//        ld      A,E
 994+ E82A              ;;//        add     A,L
 995+ E82A              ;;//        ld      E,A
 996+ E82A              ;;//.EndLoop:
 997+ E82A              ;;//        inc     B
 998+ E82A              ;;//        jr      .Loop
 999+ E82A              ;;//.EndLine:
1000+ E82A              ;;//        pop     AF              ;MUST NOT BE REMOVED
1001+ E82A              ;;//        pop     HL              ;can be removed
1002+ E82A              ;;//        pop     DE              ;can be removed
1003+ E82A              ;;//        ret
1004+ E82A
1005+ E82A              ;;	ld		(.l2yadjust),a
1006+ E82A              ;;	call	calcdeltax:
1007+ E82A              ;;	ld		(.l2xadjust),a
1008+ E82A              ;;.calcfraction:							; err(or fraction) = dx+dy;
1009+ E82A              ;;	push	hl
1010+ E82A              ;;	push	de
1011+ E82A              ;;	ld		hl,(l2deltaX)
1012+ E82A              ;;	ld		de,(l2deltaY)
1013+ E82A              ;;	add		hl,de
1014+ E82A              ;;	ld		(l2fraction),hl
1015+ E82A              ;;	pop		de
1016+ E82A              ;;	pop		hl
1017+ E82A              ;;.mainloop:
1018+ E82A              ;;	push	bc
1019+ E82A              ;;	push	de
1020+ E82A              ;;	ld 		a,(l2linecolor)
1021+ E82A              ;;	call	l2_plot_pixel
1022+ E82A              ;;	pop		de
1023+ E82A              ;;	pop		bc
1024+ E82A              ;;.arewefinishedtest
1025+ E82A              ;;	ld		a,b
1026+ E82A              ;;	cp		d
1027+ E82A              ;;	jr		nz,.notthereyet
1028+ E82A              ;;	ld		a,c
1029+ E82A              ;;	cp		e
1030+ E82A              ;;	ret		z
1031+ E82A              ;;.notthereyet:
1032+ E82A              ;;	push	de
1033+ E82A              ;;	call	l2_e2fractionby2			; e2 = 2*err;
1034+ E82A              ;;	pop		de
1035+ E82A              ;;.e2dytest:								; if (e2 >= dy) /* e_xy+e_x > 0 */  then S and P/V are the same
1036+ E82A              ;;	push	de							; so if m & pe  or p & po calc (m = sign set p = 0)
1037+ E82A              ;;	ld		de,(l2deltaY)				;    if m & po  or p & pe skip  (pe = pv set po = pv 0)
1038+ E82A              ;;	or		a							;
1039+ E82A              ;;	sbc		hl,de						;
1040+ E82A              ;;	pop		de
1041+ E82A              ;;	jr		z,  .dodycalc				; if equal then calc
1042+ E82A              ;;	jp		p,	.dodycalc				; sign clear to H>D even with negtives
1043+ E82A              ;;	jr		.skipdycalc         		; sign = 0     so  skip as pe
1044+ E82A              ;;.dodycalc:
1045+ E82A              ;;	ld		hl,(l2fraction)
1046+ E82A              ;;	push	de
1047+ E82A              ;;	ld		de,(l2deltaY)
1048+ E82A              ;;	add		hl,de
1049+ E82A              ;;	ld		(l2fraction),de
1050+ E82A              ;;	pop		de
1051+ E82A              ;;.l2yadjust:
1052+ E82A              ;;	nop
1053+ E82A              ;;.skipdycalc:
1054+ E82A              ;;.e2dxtest:								;  if (e2 <= dx) /* e_xy+e_y < 0 */ then S and P/V are different.
1055+ E82A              ;;	ld		hl,(l2e2)
1056+ E82A              ;;	push	de							;
1057+ E82A              ;;	ld		de,(l2deltaX)				;
1058+ E82A              ;;	or		a							; clear carry flag
1059+ E82A              ;;	sbc		hl,de						; hl = hl - de is if de > hl will get pv and signed different?
1060+ E82A              ;;	pop		de
1061+ E82A              ;;	jr		z,.dodxcalc					; e2 == dx so do calc
1062+ E82A              ;;	jp		m,.dodxcalc					; was sign bit set
1063+ E82A              ;;	jr		.skipdxcalc         	    ; diff so skip ; pvclear = po        pvset = pe
1064+ E82A              ;;.dodxcalc:
1065+ E82A              ;;	ld		hl,(l2fraction)
1066+ E82A              ;;	push	de
1067+ E82A              ;;	ld		de,(l2deltaX)
1068+ E82A              ;;	add		hl,de
1069+ E82A              ;;	ld		(l2fraction),de
1070+ E82A              ;;	pop		de
1071+ E82A              ;;.l2xadjust:
1072+ E82A              ;;	nop
1073+ E82A              ;;.skipdxcalc:
1074+ E82A              ;;	jr 		.mainloop
1075+ E82A
1076+ E82A
1077+ E82A              ;;/l2_draw_diagonalold:
1078+ E82A              ;;/MESSAGE ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color)"
1079+ E82A              ;;/	ld		(l2linecolor),a   			; could do an ex but it will be needed multiple times between many uses of a reg
1080+ E82A              ;;/.sortycoords:
1081+ E82A              ;;/	ld		a,b							; Sort to Y0 is always > y1 so we don't have to deal with step y and only step x
1082+ E82A              ;;/	cp		d
1083+ E82A              ;;/	jr		nc, .nocoordswap
1084+ E82A              ;;/.swapcoords:
1085+ E82A              ;;/	ex		de,hl						; save de to hl ! effective code line 98 after macros
1086+ E82A              ;;/	lddebc
1087+ E82A              ;;/	ldbchl
1088+ E82A              ;;/.nocoordswap:
1089+ E82A              ;;/	ld		a,d							; l2_dy = -ABS(l2_vy1 - l2_vy0)
1090+ E82A              ;;/	sub		b							; we have already sorted  so y1 > y0
1091+ E82A              ;;/	ld		(l2deltaY),a
1092+ E82A              ;;/	neg									; DEBUG
1093+ E82A              ;;/	ld		(l2deltaYn),a				; DEBUG
1094+ E82A              ;;/	neg									; DEBUG
1095+ E82A              ;;/.deltaxequABSx0Minusx1:						; we need to set l2dx to abs x1-x0 and set
1096+ E82A              ;;/    ld		a,c
1097+ E82A              ;;/	cp		e
1098+ E82A              ;;/	jr		c, .x1GTx0
1099+ E82A              ;;/.x1LTx0
1100+ E82A              ;;/	ld		a,c
1101+ E82A              ;;/	sub		e
1102+ E82A              ;;/	ld		(l2deltaX),a				; just 8 bit for now should it be 16?
1103+ E82A              ;;/	neg									; DEBUG
1104+ E82A              ;;/	ld		(l2deltaXn),a				; DEBUG
1105+ E82A              ;;/	neg									; DEBUG
1106+ E82A              ;;/	ld		a,l2incbstep
1107+ E82A              ;;/	jr		.setlayershift0
1108+ E82A              ;;/.x1GTx0:
1109+ E82A              ;;/	ld		a,e
1110+ E82A              ;;/	sub		c
1111+ E82A              ;;/	ld		(l2deltaX),a					; just 8 bit for now should it be 16?
1112+ E82A              ;;/	neg									; DEBUG
1113+ E82A              ;;/	ld		(l2deltaXn),a				; DEBUG
1114+ E82A              ;;/	neg									; DEBUG
1115+ E82A              ;;/	ld		a,l2decbstep
1116+ E82A              ;;/.setlayershift0:
1117+ E82A              ;;/	ld		a,0
1118+ E82A              ;;/	pushbcde
1119+ E82A              ;;/	call	asm_l2_bank_n_select		; l2_layer_shift = 0 and bank 0 selected
1120+ E82A              ;;/	popdebc
1121+ E82A              ;;/; so now we have set inc or dec instruction, l2dy, l2dx and on bank 0,
1122+ E82A              ;;/.dymuliplyby2:
1123+ E82A              ;;/	ld		a, (l2deltaY)				; dy *= 2
1124+ E82A              ;;/	call	l2_signed_mul2a
1125+ E82A              ;;/	ld		(l2deltaYsq),a
1126+ E82A              ;;/	neg									; DEBUG
1127+ E82A              ;;/	ld		(l2deltaYsqn),a				; DEBUG
1128+ E82A              ;;/	neg									; DEBUG
1129+ E82A              ;;/.dxmuliplyby2:
1130+ E82A              ;;/	ld		a, (l2deltaX)				; dx *= 2
1131+ E82A              ;;/	call	l2_signed_mul2a
1132+ E82A              ;;/	ld		(l2deltaXsq),a
1133+ E82A              ;;/	neg									; DEBUG
1134+ E82A              ;;/	ld		(l2deltaXsqn),a				; DEBUG
1135+ E82A              ;;/	neg									; DEBUG
1136+ E82A              ;;/.plotfirstpixel:
1137+ E82A              ;;/	pushbcde
1138+ E82A              ;;/	ld a,(l2linecolor)
1139+ E82A              ;;/	call	l2_plot_pixel
1140+ E82A              ;;/	popdebc
1141+ E82A              ;;/.mainloop:								; if (l2_dx > l2_dy) signed
1142+ E82A              ;;/	ld		a,(l2deltaX)				;If A < N, then S and P/V are different.
1143+ E82A              ;;/	ld		hl,l2deltaY					;A >= N, then S and P/V are the same
1144+ E82A              ;;/	cp		(hl)
1145+ E82A              ;;/	jp		m,	.signset
1146+ E82A              ;;/.signclear:
1147+ E82A              ;;/	jp		pe,	.dxLTEdybranch
1148+ E82A              ;;/	jr		.dxGTdybranch
1149+ E82A              ;;/.signset:
1150+ E82A              ;;/	jp		po,	.dxLTEdybranch
1151+ E82A              ;;/.dxGTdybranch:
1152+ E82A              ;;/	ld		a,(l2deltaYsq)
1153+ E82A              ;;/	ld		hl,l2deltaX
1154+ E82A              ;;/	sub		(hl)
1155+ E82A              ;;/	ld		(l2fraction),a				; faction = dy - 1/2 dx
1156+ E82A              ;;/.BranchAwhile							; while (l2_vx0 != l2_vx1)
1157+ E82A              ;;/	ld		a,c
1158+ E82A              ;;/	cp		e
1159+ E82A              ;;/	ret		z							; if x0 = x1 then done
1160+ E82A              ;;/.BranchAtestfraction:					; if (l2_fraction >= 0)
1161+ E82A              ;;/	ld		a,(l2fraction)
1162+ E82A              ;;/	TEST	$80
1163+ E82A              ;;/	jr		nz,.BranchAskipYstep
1164+ E82A              ;;/	inc		b							; 		++l2_vy0;
1165+ E82A              ;;/	ld		hl,l2deltaXsq
1166+ E82A              ;;/	sub		(hl)						; 		l2_fraction -= l2_dx;
1167+ E82A              ;;/	ld		(l2fraction),a
1168+ E82A              ;;/.BranchAskipYstep:
1169+ E82A              ;;/.l2stepx1:
1170+ E82A              ;;/	inc		b							; this is self modifying code point 1 l2_vx0 += l2_stepx
1171+ E82A              ;;/	ld		a,(l2fraction)				; l2_fraction += l2_dy can optimise later as a already has this?
1172+ E82A              ;;/	ld		hl,l2deltaYsq
1173+ E82A              ;;/	add		a,(hl)
1174+ E82A              ;;/	ld		(l2fraction),a
1175+ E82A              ;;/.BranchAplotBCColA:						; l2_plot_pixel(l2_vx0,l2_vy0,color);
1176+ E82A              ;;/	pushbcde
1177+ E82A              ;;/	ld a,(l2linecolor)
1178+ E82A              ;;/	call	l2_plot_pixel
1179+ E82A              ;;/	popdebc
1180+ E82A              ;;/.BranchAloop:
1181+ E82A              ;;/	jr		.BranchAwhile
1182+ E82A              ;;/.dxLTEdybranch:
1183+ E82A              ;;/	ld		a,(l2deltaXsq)				; l2_fraction = l2_dx - (l2_dy >> 1);
1184+ E82A              ;;/	ld		hl, l2deltaY
1185+ E82A              ;;/	sub		(hl)
1186+ E82A              ;;/	ld		(l2fraction),a				; faction = dy - 1/2 d
1187+ E82A              ;;/.BranchBwhile:							; while (l2_vy0 != l2_vy1)
1188+ E82A              ;;/	ld		a,b
1189+ E82A              ;;/	cp		d
1190+ E82A              ;;/	ret		z							; if x0 = x1 then done
1191+ E82A              ;;/.BranchBtestfraction:					; if (l2_fraction >= 0)
1192+ E82A              ;;/	ld		a,(l2fraction)
1193+ E82A              ;;/	TEST	$80
1194+ E82A              ;;/	jr		nz,.BranchBskipYstep
1195+ E82A              ;;/.l2stepx2
1196+ E82A              ;;/	inc		b							; l2_vx0 += l2_stepx; this is self modifying code point 2
1197+ E82A              ;;/	ld		a,(l2fraction)				; l2_fraction -= l2_dy
1198+ E82A              ;;/	ld		hl,l2deltaYsq
1199+ E82A              ;;/	sub		(hl)
1200+ E82A              ;;/	ld		(l2fraction),a
1201+ E82A              ;;/.BranchBskipYstep:
1202+ E82A              ;;/	ld		hl, l2deltaYsq
1203+ E82A              ;;/	add		a,(hl)
1204+ E82A              ;;/	ld		(l2fraction),a
1205+ E82A              ;;/	inc		b							; ++l2_vy0;
1206+ E82A              ;;/.BranchBplotBCColA:
1207+ E82A              ;;/	pushbcde
1208+ E82A              ;;/	ld a,(l2linecolor)
1209+ E82A              ;;/	call	l2_plot_pixel
1210+ E82A              ;;/	popdebc
1211+ E82A              ;;/.BranchBloop:
1212+ E82A              ;;/	jr		.BranchBwhile
1213+ E82A
# file closed: ../../Layer2Graphics/layer2_plot_diagonal.asm
 667  E82A                  INCLUDE "../../Layer2Graphics/int_bren_save.asm"
# file opened: ../../Layer2Graphics/int_bren_save.asm
   1+ E82A              OPCODE_IncHL            EQU $23
   2+ E82A              OPCODE_DecHL            EQU $2B
   3+ E82A              OPCODE_IncHLIndirect    EQU $34
   4+ E82A              OPCODE_DecHLIndirect    EQU $35
   5+ E82A              OPCODE_IncDE            EQU $13
   6+ E82A              OPCODE_DecDE            EQU $1B
   7+ E82A              OPCODE_JpNCnn           EQU $D2
   8+ E82A              OPCODE_JpCnn            EQU $DA
   9+ E82A              LOWEST_SAVE             EQU 0
  10+ E82A              HIGHEST_SAVE            EQU 1
  11+ E82A
  12+ E82A              SetIncrement:           MACRO   Location
  13+ E82A ~                                    ld      a,OPCODE_IncDE
  14+ E82A ~                                    ld      (Location),a
  15+ E82A                                      ENDM
  16+ E82A              SetDecrement:           MACRO   Location
  17+ E82A ~                                    ld      a,OPCODE_DecDE
  18+ E82A ~                                    ld      (Location),a
  19+ E82A                                      ENDM
  20+ E82A
  21+ E82A              ; So next optimisation
  22+ E82A              ; we know that we start from row y0 to row Y0
  23+ E82A              ; so we can just reference that row range and zero it out rather than the whole
  24+ E82A              ; data set
  25+ E82A 00           l2_fillValue            DB 0
  26+ E82B
  27+ E82B 83 C3 C7 CB  l2_fill_line            DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
  27+ E82F 7D
  28+ E830 2A E8        l2_fill_colr            DW l2_fillValue
  29+ E832 FF           l2_fill_lenlo           DB 255
  30+ E833 00           l2_fill_lenhi           DB 0
  31+ E834 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY, DMA_WR2_P2INC_MEMORY, DMA_WR4_CONT_MODE
  32+ E837 00 00        l2_fill_target          DB $00, $00
  33+ E839 CF 87                                DB DMA_LOAD, DMA_ENABLE
  34+ E83B              l2_bren_cmd_len	        EQU $ - l2_fill_line
  35+ E83B
  36+ E83B 32 2A E8     l2_fill_dma:            ld		(l2_fillValue),a                                 ; T=13     ;
  37+ E83E 22 37 E8                             ld      (l2_fill_target),hl
  38+ E841 21 2B E8     .write_dma:             ld 		hl, l2_fill_line                                  ;          ;
  39+ E844 06 10                                ld 		b, l2_bren_cmd_len                                ;
  40+ E846 0E 6B                                ld		c,IO_DATAGEAR_DMA_PORT                            ;
  41+ E848 ED B3                                otir                                                      ;
  42+ E84A C9                                   ret
  43+ E84B
  44+ E84B              ; to find a point Y1 along a line X0Y0 to X2Y2
  45+ E84B              ; DX = X2-X0, DY = Y2-Y0, D = DX/DY, X1 = X0+ ((Y1-Y0)*DX)
  46+ E84B              ; will need 16.8 24 bit maths for DX DY unless we scale down and do a muliplier up
  47+ E84B              ; so we could do DX = X2-X0, scale to 8.8  ... Note this will fail for extrmem near vertical or horizontal angles
  48+ E84B              ;                DY = Y2-Y0, scale to 8.8  ... could we use an octlet lookup table?
  49+ E84B              ;                D  = DX/DY which would give us an 8.2 proportion
  50+ E84B              ; a look up table would not work for calc of DX DY but we could use a log table and anti log to simplify to add/subtract
  51+ E84B              ; need a version of this that counts down to a trigger Y axis + 1, ideallign using DX DY if possible
  52+ E84B              ; We may be able to use the flat top/flat botttom and pick up a calculated value 0nce it hits Y2?
  53+ E84B              ; Yes logirithm table will work, need to build as a decimal set optimised
  54+ E84B              ; logically if the ship is too close it will always be too close to render so we can exclude
  55+ E84B              ; excessivley large values for X and Y as they will either be too far off side or span the whole screen
  56+ E84B              ; and just flood fill
  57+ E84B              ; Thsi means we can do log maths for jsut 0 to 1024
  58+ E84B              ; 9/11 we assume that large values will either flood fill or be straight lines
  59+ E84B              ; so we allow a range of -256 to + 512 ,i.e. off screen by a whole additional screen
  60+ E84B              ; then divide becomes 16 bit div 16 bit to yeild an 8.8 result. This can then be used to work out the new position
  61+ E84B              ; so                    DE = DX (Ignoring signs for now)
  62+ E84B              ;                       HL = DY
  63+ E84B              ; we need L2_DX, L2_DY output is HL
  64+ E84B              ; After workign out in excel Formulas are:
  65+ E84B              ; incomming X0, Y0, Y1, DX , DY
  66+ E84B              ; dY2 = Y1-Y0
  67+ E84B              ; dXHi = DX/DY*256
  68+ E84B              ; dxRemainder = DX-dXHi
  69+ E84B              ; dXRemainder = TRUNC((dxRemainder)/DY)*256
  70+ E84B              ; Integer component = dY2 * dXHi /256
  71+ E84B              ; Adj     component = DY2 * dXRemainder /256
  72+ E84B              ; total = Integer + Adj + X0
  73+ E84B
  74+ E84B 00 00        l2_X0                   DW 0
  75+ E84D 00 00        l2_Y0                   DW 0
  76+ E84F 00 00        l2_X1                   DW 0
  77+ E851 00 00        l2_Y1                   DW 0
  78+ E853 00 00        ld_YMid                 DW 0
  79+ E855 00 00        l2_DX                   DW 0
  80+ E857 00 00        l2_DY                   DW 0
  81+ E859 00 00        l2_Error                DW 0
  82+ E85B 00 00        l2_E2                   DW 0
  83+ E85D 00 00        l2_dY2                  DW 0
  84+ E85F 00 00        ld_dxHi                 DW 0
  85+ E861 00 00        l2_dxRemainder          DW 0
  86+ E863 00 00        l2_dxRemainder2         DW 0
  87+ E865 00 00        l2_dXRemainderAdj       DW 0
  88+ E867 00 00        l2_integer              DW 0
  89+ E869 00 00        l2_integer2             DW 0
  90+ E86B
  91+ E86B 2A 55 E8     ScaleDXDY:              ld      hl,(l2_DX)
  92+ E86E ED 5B 57 E8                          ld      de,(l2_DY)
  93+ E872 7C           .ScaleLoop:             ld      a,h
  94+ E873 B2                                   or      d
  95+ E874 28 0B                                jr      z,.ScaleDone
  96+ E876                                      ShiftHLRight1
  96+ E876 CB 3C       >			   srl h
  96+ E878 CB 1D       >			   rr  l
  97+ E87A                                      ShiftDERight1
  97+ E87A CB 3A       >			   srl d
  97+ E87C CB 1B       >			   rr  e
  98+ E87E C3 72 E8                             jp      .ScaleLoop
  99+ E881 22 55 E8     .ScaleDone:             ld      (l2_DX),hl
 100+ E884 ED 53 57 E8                          ld      (l2_DY),de
 101+ E888 C9                                   ret
 102+ E889
 103+ E889 2A 4F E8     HLEquMidX:              ld      hl,(l2_X1)
 104+ E88C ED 5B 4B E8                          ld      de,(l2_X0)
 105+ E890                                      ClearCarryFlag
 105+ E890 B7          >                        or a
 106+ E891 ED 52                                sbc     hl,de
 107+ E893 22 55 E8                             ld      (l2_DX),hl
 108+ E896 2A 51 E8                             ld      hl,(l2_Y1)
 109+ E899 ED 5B 4D E8                          ld      de,(l2_Y0)
 110+ E89D                                      ClearCarryFlag
 110+ E89D B7          >                        or a
 111+ E89E ED 52                                sbc     hl,de
 112+ E8A0 22 57 E8                             ld      (l2_DY),hl
 113+ E8A3                                      ;break
 114+ E8A3 CD 6B E8                             call    ScaleDXDY
 115+ E8A6 2A 53 E8                             ld      hl,(ld_YMid)
 116+ E8A9                                      ClearCarryFlag
 116+ E8A9 B7          >                        or a
 117+ E8AA ED 52                                sbc     hl,de
 118+ E8AC 22 5D E8                             ld      (l2_dY2),hl
 119+ E8AF ED 4B 55 E8                          ld      bc,(l2_DX)          ; dXHi(DE)= DX/DY*256
 120+ E8B3 ED 5B 57 E8                          ld      de,(l2_DY)          ; .
 121+ E8B7 DD 62 DD 6B                          ld      ix,de               ; .
 122+ E8BB E5 FD E1                             ld      iy,hl               ; .
 123+ E8BE              ;                       BC = DX/DY as 8.8           ; .
 124+ E8BE CD 7C 73                             call    BC_Div_DE; DEequDEDivBC; DE is the result HL is the remainder
 125+ E8C1 78                                   ld      a,b                 ; if DE is 8 bit only
 126+ E8C2 A7                                   and     a                   ; .
 127+ E8C3 28 06                                jr      z,.LT255            ; goto LT255
 128+ E8C5 01 FF FF                             ld      bc,$FFFF            ; else set BC to $FFFF
 129+ E8C8 C3 02 E9                             jp      .DoneCalc           ; .
 130+ E8CB ED 43 5F E8  .LT255:                 ld      (ld_dxHi),bc        ;
 131+ E8CF 22 61 E8                             ld      (l2_dxRemainder),hl ; dxRemainder = DX-dXHi
 132+ E8D2              .CalcIntegerComponent:  ;break
 133+ E8D2 2A 5D E8                             ld      hl,(l2_dY2)         ; Integer component = dY2 * dXHi /256
 134+ E8D5 ED 5B 5F E8                          ld      de,(ld_dxHi)        ; .
 135+ E8D9 CD 50 6E                             call    DEHLequDEmulHL      ; .
 136+ E8DC ED 53 67 E8                          ld      (l2_integer),de     ; .
 137+ E8E0 22 69 E8                             ld      (l2_integer2),hl    ; .
 138+ E8E3 ED 4B 61 E8  .CalcRemainderFraction: ld      bc,(l2_dxRemainder) ; dXRemainder = TRUNC((dxRemainder)/DY)*256
 139+ E8E7 ED 5B 57 E8                          ld      de,(l2_DY)          ; .
 140+ E8EB CD 7C 73                             call    BC_Div_DE           ; BC, remainder in HL
 141+ E8EE ED 43 65 E8                          ld      (l2_dXRemainderAdj),bc
 142+ E8F2 22 63 E8                             ld      (l2_dxRemainder2),hl
 143+ E8F5 2A 5D E8     .CalcAdjustment:        ld      hl,(l2_dY2)         ; Adj component = DY2 * dXRemainder /256
 144+ E8F8 50 59                                ld      de,bc               ;
 145+ E8FA CD 50 6E                             call    DEHLequDEmulHL      ;
 146+ E8FD 2A 67 E8                             ld      hl,(l2_integer)
 147+ E900 19                                   add     hl,de
 148+ E901 C9                                   ret
 149+ E902
 150+ E902
 151+ E902              ;                       HL = (DE * B) /256
 152+ E902 C5           .DoneCalc:              push    bc
 153+ E903 58                                   ld      e,b
 154+ E904 DD E5 E1                             ld      hl,ix
 155+ E907 CD 3B 6E                             call AHLequHLmulE
 156+ E90A 6C                                   ld l,h
 157+ E90B 67                                   ld h,a
 158+ E90C E5 DD E1                             ld      ix,hl
 159+ E90F              ;                       DE = (DE * C) /256          ld e,c call AHLequHLmulE,ld l,h, ld h,a
 160+ E90F C1                                   pop     bc
 161+ E910 59                                   ld      e,c
 162+ E911 FD E5 E1                             ld      hl,iy
 163+ E914 CD 3B 6E                             call AHLequHLmulE
 164+ E917 6C                                   ld l,h
 165+ E918 67                                   ld h,a
 166+ E919              ;                       HL + = DE
 167+ E919 DD 54 DD 5D                          ld      de,ix
 168+ E91D 19                                   add     hl,de
 169+ E91E              ;                       HL + + X0
 170+ E91E ED 5B 4B E8                          ld      de,(l2_X0)
 171+ E922 19                                   add     hl,de
 172+ E923 C9                                   ret
 173+ E924
 174+ E924
 175+ E924
 176+ E924
 177+ E924              ;; Need optimisation for vertical line and horizonal
 178+ E924              int_bren_save_Array1Low:
 179+ E924 3E FF                                ld      a,$FF
 180+ E926 21 4C E5                             ld      hl,l2targetArray1   ; L2targetArray2 Population
 181+ E929 CD 3B E8                             call    l2_fill_dma
 182+ E92C 3E DA                                ld      a,OPCODE_JpCnn
 183+ E92E 21 4C E5                             ld      hl,l2targetArray1   ; L2targetArray2 Population
 184+ E931 C3 5F E9                             jp      int_bren_save_Array ;
 185+ E934              int_bren_save_Array1High:
 186+ E934                                      ZeroA
 186+ E934 AF          >                        xor a
 187+ E935 21 4C E5                             ld      hl,l2targetArray1   ; L2targetArray2 Population
 188+ E938 CD 3B E8                             call    l2_fill_dma
 189+ E93B 3E D2                                ld      a,OPCODE_JpNCnn
 190+ E93D 21 4C E5                             ld      hl,l2targetArray1   ; L2targetArray2 Population
 191+ E940 C3 5F E9                             jp      int_bren_save_Array ;
 192+ E943              int_bren_save_Array2Low:
 193+ E943 3E FF                                ld      a,$FF
 194+ E945 21 4C E6                             ld      hl,l2targetArray2   ; L2targetArray2 Population
 195+ E948 CD 3B E8                             call    l2_fill_dma
 196+ E94B 3E DA                                ld      a,OPCODE_JpCnn
 197+ E94D 21 4C E6                             ld      hl,l2targetArray2   ; L2targetArray2 Population
 198+ E950 C3 5F E9                             jp      int_bren_save_Array ;
 199+ E953              int_bren_save_Array2High:
 200+ E953                                      ZeroA
 200+ E953 AF          >                        xor a
 201+ E954 21 4C E6                             ld      hl,l2targetArray2   ; L2targetArray2 Population
 202+ E957 CD 3B E8                             call    l2_fill_dma
 203+ E95A 21 4C E6                             ld      hl,l2targetArray2   ; L2targetArray2 Population
 204+ E95D 3E D2                                ld      a,OPCODE_JpNCnn
 205+ E95F              ; Uses HL DE
 206+ E95F              ; Note this works out the last position for each point, not any intermediate
 207+ E95F              ; so we need a version that plots lowest for left line & highest for right line
 208+ E95F 22 EB E9     int_bren_save_Array:    ld      (.TargetArrayAddr+2),hl
 209+ E962 32 FC E9                             ld      (.TargetJump),a
 210+ E965 2A 4F E8                             ld      hl,(l2_X1)          ; if X0 < X1
 211+ E968 ED 5B 4B E8                          ld      de,(l2_X0)          ; calculate SX DX
 212+ E96C              ; --- dx = abs(x1 - x0) & set up SX
 213+ E96C                                      ClearCarryFlag              ;
 213+ E96C B7          >                        or a
 214+ E96D ED 52                                sbc     hl,de               ;
 215+ E96F CB 7C                                bit     7,h                 ;
 216+ E971 28 0E                                jr      z,.DXPositive       ;
 217+ E973              .DXNegative:            NegHL                       ;
 217+ E973 AF          >                    xor a
 217+ E974 95          >                    sub l
 217+ E975 6F          >                    ld l,a
 217+ E976 9F          >                    sbc a,a
 217+ E977 94          >                    sub h
 217+ E978 67          >                    ld h,a
 218+ E979                                      SetDecrement .UpdateX0Operation
 218+ E979 3E 1B       >                        ld      a,OPCODE_DecDE
 218+ E97B 32 4C EA    >                        ld      (.UpdateX0Operation),a
 219+ E97E C3 86 E9                             jp      .DoneCalcDx         ;
 220+ E981              .DXPositive:            SetIncrement .UpdateX0Operation
 220+ E981 3E 13       >                        ld      a,OPCODE_IncDE
 220+ E983 32 4C EA    >                        ld      (.UpdateX0Operation),a
 221+ E986 22 55 E8     .DoneCalcDx:            ld      (l2_DX),hl          ;
 222+ E989 ED 5B 4B E8                          ld      de,(l2_X0)          ; fetch in X0 so we can exx
 223+ E98D ED 4B 4F E8                          ld      bc,(l2_X1)          ; and also X1
 224+ E991 D9                                   exx                         ; ++now hl' = DX, DE'=X0, BC' = X1
 225+ E992              ; --- dy = -abs(y1 - y0) & set up SY
 226+ E992 2A 51 E8     .CalcDY:                ld      hl,(l2_Y1)          ; If Y1 < Y1
 227+ E995 ED 5B 4D E8                          ld      de,(l2_Y0)          ; calculate SY DY
 228+ E999                                      ClearCarryFlag              ;
 228+ E999 B7          >                        or a
 229+ E99A ED 52                                sbc     hl,de               ;
 230+ E99C CB 7C                                bit     7,h                 ;
 231+ E99E 28 08                                jr      z,.DYPositive       ;
 232+ E9A0              .DYNegative:            SetDecrement .UpdateY0Operation
 232+ E9A0 3E 1B       >                        ld      a,OPCODE_DecDE
 232+ E9A2 32 83 EA    >                        ld      (.UpdateY0Operation),a
 233+ E9A5 C3 86 E9                             jp      .DoneCalcDx         ;
 234+ E9A8              .DYPositive:            NegHL                       ;
 234+ E9A8 AF          >                    xor a
 234+ E9A9 95          >                    sub l
 234+ E9AA 6F          >                    ld l,a
 234+ E9AB 9F          >                    sbc a,a
 234+ E9AC 94          >                    sub h
 234+ E9AD 67          >                    ld h,a
 235+ E9AE                                      SetIncrement .UpdateY0Operation
 235+ E9AE 3E 13       >                        ld      a,OPCODE_IncDE
 235+ E9B0 32 83 EA    >                        ld      (.UpdateY0Operation),a
 236+ E9B3 22 57 E8     .DoneCalcDy:            ld      (l2_DY),hl
 237+ E9B6 ED 5B 4D E8                          ld      de,(l2_Y0)          ; fetch in X0
 238+ E9BA ED 4B 51 E8                          ld      bc,(l2_Y1)          ; now hl = DY, DE=Y0, BC = Y1
 239+ E9BE              ; ---   error = dx + dy >> at this point hl' = DX, DE'=X0, BC' = X1 and hl = DY, DE=Y0, BC = Y1
 240+ E9BE E5 FD E1     .CalcError:             ld      iy,hl               ; fetch DY into IY
 241+ E9C1 D9                                   exx                         ; ++now looking at DX data set and DY in alternate
 242+ E9C2 EB                                   ex      de,hl               ; quickly flip over de and to support add instruction
 243+ E9C3 FD 19                                add     iy,de               ; we have set up IY as L2_Error
 244+ E9C5 EB                                   ex      de,hl
 245+ E9C6 FD 22 59 E8                          ld      (l2_Error),iy
 246+ E9CA              ; --- While True        >> at this point we are looing at DX and need to consider state at iteration loop
 247+ E9CA D9           .CalcLoop:              exx                         ; ++now looking at DY data set and DX in alternate
 248+ E9CB                                      ;ld      hl,(l2_X0)         ; get X0 and Y0
 249+ E9CB              ; --- PLOT X0, Y0       >> now looking at DY data set and DX in alternate
 250+ E9CB              .CheckYRange:           ;ld      de,(l2_Y0)
 251+ E9CB 7A                                   ld      a,d                 ; if Y0 > 127
 252+ E9CC A7                                   and     a                   ; or Y0 is negative
 253+ E9CD 20 35                                jr      nz,.YOutOfRange     ; then we can skip the plot
 254+ E9CF 7B                                   ld      a,e                 ;
 255+ E9D0 E6 80                                and     $80                 ;
 256+ E9D2 20 30                                jr      nz,.YOutOfRange     ;
 257+ E9D4 D9           .CheckXRange:           exx                         ; ++now looking at DX data set and DY in alternate
 258+ E9D5 7A                                   ld      a,d                 ; if X0 is negative
 259+ E9D6 A7                                   and     a
 260+ E9D7 28 0E                                jr      z,.XOKToPlot
 261+ E9D9 E6 80                                and     $80
 262+ E9DB 28 05                                jr      z,.NotXNegative
 263+ E9DD 3E 00        .XNegative:             ld      a,0                 ; if X0 <0 > 255 then clamp it
 264+ E9DF C3 E8 E9                             jp      .ClipXDone          ;
 265+ E9E2 3E FF        .NotXNegative:          ld      a,255               ;
 266+ E9E4 C3 E8 E9                             jp      .ClipXDone          ;
 267+ E9E7 7B           .XOKToPlot:             ld      a,e                 ; no clip therefore we can just use X0 as is
 268+ E9E8 D9           .ClipXDone:             exx                         ; ++now looking at DY data set and DX in alternate
 269+ E9E9 DD 21 4C E5  .TargetArrayAddr:       ld      ix,l2targetArray1   ; later this will be self modifying
 270+ E9ED 08                                   ex      af,af'
 271+ E9EE 7B                                   ld      a,e
 272+ E9EF 32 FA E9                             ld      (.TargetRead+2),a   ; Write Y0 offset to IX offset
 273+ E9F2 32 02 EA                             ld      (.TargetWrite+2),a  ; Write Y0 offset to IX offset
 274+ E9F5 08                                   ex      af,af'
 275+ E9F6 C5                                   push    bc
 276+ E9F7 47                                   ld      b,a
 277+ E9F8 DD 7E 00     .TargetRead:            ld      a,(IX+0)
 278+ E9FB B8                                   cp      b
 279+ E9FC DA 03 EA     .TargetJump:            jp      c,.SkipWrite
 280+ E9FF 78                                   ld      a,b
 281+ EA00 DD 77 00     .TargetWrite:           ld      (IX+0),a            ; directly updates l2targetArray1
 282+ EA03 C1           .SkipWrite:             pop     bc
 283+ EA04              ; --- if x0 == x1 && y0 == y1 break
 284+ EA04              .YOutOfRange: ; At this point we have either plotted or its outside array range
 285+ EA04 D9                                   exx                         ; ++now looking at DX data set and DY in alternate
 286+ EA05              ;                        ld      bc,(l2_X1)
 287+ EA05              .CheckEndXY:            cpDEEquBC .CheckEndXYOK     ; de will equal X0 still by here
 287+ EA05 7A          >                        ld      a,d
 287+ EA06 B8          >                        cp      b
 287+ EA07 C2 0F EA    >                        jp      nz, .CheckEndXYOK
 287+ EA0A 7B          >                        ld      a,e
 287+ EA0B B9          >                        cp      c
 287+ EA0C             >.NoTheSame:
 288+ EA0C C2 19 EA                             jp      nz,.x0x1Differ
 289+ EA0F D9           .CheckEndXYOK:          exx                         ; ++ in this branch in this branchnow looking at DY data set and DX in alternate
 290+ EA10              ;                        ld      bc,(l2_Y1)
 291+ EA10                                      cpDEEquBC  .x0x1Differ      ; de will equal Y0 still by here
 291+ EA10 7A          >                        ld      a,d
 291+ EA11 B8          >                        cp      b
 291+ EA12 C2 19 EA    >                        jp      nz, .x0x1Differ
 291+ EA15 7B          >                        ld      a,e
 291+ EA16 B9          >                        cp      c
 291+ EA17             >.NoTheSame:
 292+ EA17 D9                                   exx                         ; ++ in this branch now looking at DX data set and DY in alternate
 293+ EA18 C8                                   ret     z                   ; if they are both the same we are done
 294+ EA19              .x0x1Differ:                                        ; by this point we could be looking at DX on all branches
 295+ EA19              ; --- e2 = 2 * error
 296+ EA19 D9           .SetError2:             exx                         ; ++now looking at DY data set and DX in alternate
 297+ EA1A E5 D5                                push    hl,,de              ; save HL
 298+ EA1C EB                                   ex      de,hl               ; de = DY; could futher optimise to check DY>E2 and reduce instruction count
 299+ EA1D FD E5 E1                             ld      hl,iy;(l2_Error)       ; e2 = 2 * error
 300+ EA20 29                                   add     hl,hl               ; .
 301+ EA21 22 5B E8                             ld      (l2_E2),hl          ; .
 302+ EA24                                      ; before here we are looking at DY
 303+ EA24              ; --- if e2 >= dy
 304+ EA24 CD 84 76     .CheckE2gteDY:          call    compare16HLDE       ; .
 305+ EA27 D1 E1                                pop     hl,,de              ; before jumps get HL back
 306+ EA29 EA 32 EA                             jp      pe, .E2DyParitySet  ; Jump looking at DY
 307+ EA2C FA 4E EA                             jp      m,  .E2ltDY         ; Jump looking at DY to get here overflow clear, so if m is set then HL<DE
 308+ EA2F C3 35 EA                             jp      .E2gteDY            ; Jump looking at DY
 309+ EA32              .E2DyParitySet:         ; entering here looking at DY
 310+ EA32 F2 4E EA                             jp      p,  .E2ltDY         ; Jump looking at DY if pe is set, then if sign is clear HL<DE
 311+ EA35              ; --- if x0 == x1 break
 312+ EA35 D9           .E2gteDY:               exx                         ; ++ in this branch now looking at DX data set and DY in alternate
 313+ EA36                                      cpDEEquBC .ErrorUpdateDY    ;      if x0 == x1 break
 313+ EA36 7A          >                        ld      a,d
 313+ EA37 B8          >                        cp      b
 313+ EA38 C2 3E EA    >                        jp      nz, .ErrorUpdateDY
 313+ EA3B 7B          >                        ld      a,e
 313+ EA3C B9          >                        cp      c
 313+ EA3D             >.NoTheSame:
 314+ EA3D C8                                   ret     z                   ;      .
 315+ EA3E              ; --- error = error + dy
 316+ EA3E D9           .ErrorUpdateDY:         exx                         ; if we get here we are looking at DY data set and DX in alternate
 317+ EA3F E5 D5                                push    hl,,de              ; save HL
 318+ EA41 EB                                   ex      de,hl               ; de = DY
 319+ EA42 FD E5 E1                             ld      hl,iy;(l2_Error)       ;      error = error + dy
 320+ EA45 19                                   add     hl,de               ;      .
 321+ EA46 E5 FD E1                             ld      iy,hl;(l2_Error),hl       ;      .
 322+ EA49 D1 E1                                pop     hl,,de
 323+ EA4B              ; --- x0 = x0 + sx
 324+ EA4B D9           .UpdateX0:              exx                         ; now back looking at DX data set and DY in alternate
 325+ EA4C 00           .UpdateX0Operation:     nop                         ;      x0 = x0 +/- sx
 326+ EA4D D9                                   exx                         ; correction on this brach so we are looking at DY
 327+ EA4E              .E2ltDY:                ; entering here, looking at DY in all branches
 328+ EA4E              ; --- if e2 <= dx
 329+ EA4E D9           .CheckE2lteDX:          exx                         ; we want to look at DX
 330+ EA4F E5 D5                                push    hl,,de
 331+ EA51 EB                                   ex      de,hl               ; de = l2_DX
 332+ EA52 2A 5B E8                             ld      hl,(l2_E2)          ; if e2 <= dx
 333+ EA55              ;                        ld      de,(l2_DX)          ; as we can't do skip on e2>dx
 334+ EA55 CD 84 76                             call    compare16HLDE       ; we will jump based on e2 <= dx
 335+ EA58 D1 E1                                pop     hl,,de              ; recover saved HL DE
 336+ EA5A CA 6C EA                             jp      z, .E2lteDX         ; Jump looking at DX
 337+ EA5D EA 66 EA                             jp      pe, .E2DxParitySet  ; Jump looking at DX
 338+ EA60 FA 6C EA                             jp      m,  .E2lteDX        ; Jump looking at DX : to get here overflow clear, so if m is set then HL<DE
 339+ EA63 C3 85 EA                             jp      .E2gteDx            ; Jump looking at DX
 340+ EA66 F2 6C EA     .E2DxParitySet:         jp      p,  .E2lteDX        ; Jump looking at DX
 341+ EA69 C3 85 EA                             jp      .E2gteDx            ; Jump looking at DX
 342+ EA6C              ; ---  if y0 == y1 break
 343+ EA6C              .E2lteDX:               ; Entry looking at DX
 344+ EA6C D9                                   exx                         ;      in branch looking at DY
 345+ EA6D                                      cpDEEquBC .ErrorUpdateDX    ;      .
 345+ EA6D 7A          >                        ld      a,d
 345+ EA6E B8          >                        cp      b
 345+ EA6F C2 76 EA    >                        jp      nz, .ErrorUpdateDX
 345+ EA72 7B          >                        ld      a,e
 345+ EA73 B9          >                        cp      c
 345+ EA74             >.NoTheSame:
 346+ EA74 D9                                   exx                         ;      in branch looking at DX
 347+ EA75 C8                                   ret     z                   ;      .
 348+ EA76              ; --- error = error + dx
 349+ EA76              .ErrorUpdateDX:         ; at this point will be looking at DX
 350+ EA76 E5 D5                                push    hl,,de
 351+ EA78 EB                                   ex      de,hl               ;      de = DY
 352+ EA79 FD E5 E1                             ld      hl,iy;(l2_Error)       ;      error = error + dx
 353+ EA7C 19                                   add     hl,de               ;      .
 354+ EA7D E5 FD E1                             ld      iy,hl;(l2_Error),hl       ;      .
 355+ EA80 D1 E1                                pop     hl,,de
 356+ EA82              ; --- y0 = y0 + sy
 357+ EA82 D9           .UpdateY0:              exx                         ;      in this branch we are looking at DY
 358+ EA83 00           .UpdateY0Operation:     nop                         ;      y0 = y0 + sy
 359+ EA84 D9                                   exx                         ;      in this branch we are looking at
 360+ EA85              ; --- Loop
 361+ EA85              .E2gteDx:               ; at this point will be looking at DX again
 362+ EA85 C3 CA E9                             jp      .CalcLoop           ; repeat until we have a return
 363+ EA88
# file closed: ../../Layer2Graphics/int_bren_save.asm
 668  EA88                  INCLUDE "../../Layer2Graphics/layer2_plot_circle.asm"
# file opened: ../../Layer2Graphics/layer2_plot_circle.asm
   1+ EA88
   2+ EA88 00 00        l2_circle_pos		DW 0
   3+ EA8A 00           l2_circle_colour	DB 0
   4+ EA8B 00           l2_circle_radius	DB 0
   5+ EA8C 00           l2_circle_x			DB 0
   6+ EA8D 00           l2_circle_y			DB 0
   7+ EA8E 00           l2_circle_d			DB 0
   8+ EA8F
   9+ EA8F 00 00 00...  l2_circle_xHeap 	DS 2*66
  10+ EB13 00 00 00...  l2_circle_yHeap     DS 2*66
  11+ EB97 00           l2_circle_heap_size DB 0
  12+ EB98 00 00        l2_circle_clip_y    DW 0
  13+ EB9A 00 00        l2_circle_clip_x    DW 0
  14+ EB9C 00           l2_circle_flag      DB 0
  15+ EB9D 00           l2_circle_counter   DB 0
  16+ EB9E              ;Sine table
  17+ EB9E              ;FOR I%, 0, 31
  18+ EB9E              ;
  19+ EB9E              ; N = ABS(SIN((I% / 64) * 2 * PI))
  20+ EB9E              ;
  21+ EB9E              ; IF N >= 1
  22+ EB9E              ;  EQUB 255
  23+ EB9E              ; ELSE
  24+ EB9E              ;  EQUB INT(256 * N + 0.5)
  25+ EB9E              ; ENDIF
  26+ EB9E              ;
  27+ EB9E              ;NEXT
  28+ EB9E              ;---------------------------------------------------------------------------------------------------------------------------------
  29+ EB9E              ; in HL = xPixelPos, DE = yPixelPos, A = Radius
  30+ EB9E              ;IFDEF   CIRCLE2
  31+ EB9E              ;;;;+l2_circle_clipped:	ld		(l2_circle_radius),a
  32+ EB9E              ;;;;+					ld		(l2_circle_clip_y),de
  33+ EB9E              ;;;;+					ld		(l2_circle_clip_x),hl
  34+ EB9E              ;;;;+					ZeroA
  35+ EB9E              ;;;;+					ld		(l2_circle_heap_size),a
  36+ EB9E              ;;;;+					ld		(l2_circle_counter),a
  37+ EB9E              ;;;;+					dec		a
  38+ EB9E              ;;;;+					ld		(l2_circle_flag),a
  39+ EB9E              ;;;;+.CircleLoop:		call	SinCounter						; a = sin (counter) * 256
  40+ EB9E              ;;;;+					ld		d,a
  41+ EB9E              ;;;;+					ld		a,(l2_circle_radius)
  42+ EB9E              ;;;;+					ld		e,a
  43+ EB9E              ;;;;+					mul										; de = k * sin (counter) so d = k * sin (counter) / 256
  44+ EB9E              ;;;;+					ld		e,d								; using de as TA
  45+ EB9E              ;;;;+					ld		d,0
  46+ EB9E              ;;;;+					ld		a,(l2_circle_counter)
  47+ EB9E              ;;;;+					JumpIfALTNusng 33,.RightHalf
  48+ EB9E              ;;;;+.LeftHalf:			NegateDE								; if >= 33 then DE = de * -1 (2's c)
  49+ EB9E              ;;;;+					K6 = de + l2_circle_clip_x
  50+ EB9E              ;;;;+					call	CosCounter
  51+ EB9E              ;;;;+					ld		d,a
  52+ EB9E              ;;;;+					ld		a,(l2_circla_radius)
  53+ EB9E              ;;;;+					mul		de
  54+ EB9E              ;;;;+					ld		e,d
  55+ EB9E              ;;;;+					ld		d,0
  56+ EB9E              ;;;;+					a 		= l2_counter + 15 mod 64
  57+ EB9E              ;;;;+					JumpIfALTNusng	33, .BottomHalf
  58+ EB9E              ;;;;+.TopHalf:			NegateDE
  59+ EB9E              ;;;;+					K62 = de + l2_circle_clip_y
  60+ EB9E              ;;;;+					ld		a,(l2_circle_flag)
  61+ EB9E              ;;;;+					JumpIfAIsZZero		.SkipFlagUpdate
  62+ EB9E              ;;;;+					inc		a
  63+ EB9E              ;;;;+					ld		(l2_circle_flag),a
  64+ EB9E              ;;;;+.SkipFlagUpdate:
  65+ EB9E              ;;;;+
  66+ EB9E              ;;;;+                X = K * SIN (CNT + 16) (i.e X = K * COS (CNT)
  67+ EB9E              ;;;;+                A = (CNT + 15) mod 64
  68+ EB9E              ;;;;+                if  A >= 33     ; top half of circle
  69+ EB9E              ;;;;+                    X = neg X
  70+ EB9E              ;;;;+                    T = negative
  71+ EB9E              ;;;;+                call    Bline (draw segment)
  72+ EB9E              ;;;;+                        K6(32) = TX + K4(10) = y corrc of center + new point
  73+ EB9E              ;;;;+                        if flag <> 0
  74+ EB9E              ;;;;+                            flag ++ (as flag initially will be $FF so go to 0)
  75+ EB9E              ;;;;+                        BL5:
  76+ EB9E              ;;;;+                        if LSY2[LSP-1] <> $FF and LSY2 [LSP1] <> $FF    (BL5)
  77+ EB9E              ;;;;+                            X15 [0 1] = K5(10)                      (BL1)
  78+ EB9E              ;;;;+                            X15 [2 3] = K5(32)
  79+ EB9E              ;;;;+                            X15 [4 5] = K6(10)
  80+ EB9E              ;;;;+                            X15 [6 7] = K6(32)
  81+ EB9E              ;;;;+                            call clip X1Y1 to X2Y2
  82+ EB9E              ;;;;+                            if Line off scren goto BL5
  83+ EB9E              ;;;;+                            IF swap <> 0
  84+ EB9E              ;;;;+                                swap X1Y1 with X2Y2
  85+ EB9E              ;;;;+                            Y = LAP                                 (BL9)
  86+ EB9E              ;;;;+                            A = LSY2-1 [Y]
  87+ EB9E              ;;;;+                            if A = $FF
  88+ EB9E              ;;;;+                                LSX2[Y] = X1
  89+ EB9E              ;;;;+                                LSY2[Y] = Y1
  90+ EB9E              ;;;;+                                Y++
  91+ EB9E              ;;;;+
  92+ EB9E              ;;;;+                            Store X2 in LSX2(Y)                     (BL8)
  93+ EB9E              ;;;;+                            Store Y2 in lSY2(y)
  94+ EB9E              ;;;;+                            call    DrawLine from (X1 Y1 to X2 Y2)
  95+ EB9E              ;;;;+                            if  XX13 <> 0 goto BL5
  96+ EB9E              ;;;;+                                                                (BL7)
  97+ EB9E              ;;;;+                        Copy data for K6(3210) into K5(3210) for next call (K5(10) = x  K5(32) = y)
  98+ EB9E              ;;;;+                        CNT = CNT + STP
  99+ EB9E              ;;;;+            while CNT < 65
 100+ EB9E              ;ENDIF
 101+ EB9E
 102+ EB9E              ; ix = x Position, iy = y position, d = radius in Leading sign magnitude
 103+ EB9E
 104+ EB9E              ;EliteCheckOnSM:     ld
 105+ EB9E              ;; ix = x Position, iy = y position, d = radius in 2's compliment
 106+ EB9E              ;;EliteCheckOn2c:
 107+ EB9E              ;;.CheckXOffLeft:     ld      hl,ix               ; if x position + radius is < 0 then its off screen
 108+ EB9E              ;;                    ld      c,d                 ; use c as a temporary holding
 109+ EB9E              ;;                    ld      d,0                 ;
 110+ EB9E              ;;                    ld      e,c                 ;
 111+ EB9E              ;;                    ClearCarryFlag              ;
 112+ EB9E              ;;                    adc     hl,de               ;
 113+ EB9E              ;;                    jp      m, .NotOnScreen     ;
 114+ EB9E              ;;.CheckXOffRight:    ld      hl,ix               ; if x position - radius > 255 then its off screen
 115+ EB9E              ;;                    ClearCarryFlag              ;
 116+ EB9E              ;;                    sbc     hl,de               ;
 117+ EB9E              ;;                    ld      a,h                 ;
 118+ EB9E              ;;                    and     a
 119+ EB9E              ;;                    jp      nz,.NotOnScreen
 120+ EB9E              ;;.CheckXOffLeft:     ld      hl,iy               ; if y position + radius is < 0 then its off screen
 121+ EB9E              ;;                    ld      c,d                 ; use c as a temporary holding
 122+ EB9E              ;;                    ld      d,0                 ;
 123+ EB9E              ;;                    ld      e,c                 ;
 124+ EB9E              ;;                    ClearCarryFlag              ;
 125+ EB9E              ;;                    adc     hl,de               ;
 126+ EB9E              ;;                    jp      m, .NotOnScreen     ;
 127+ EB9E              ;;.CheckXOffRight:    ld      hl,iy               ; if y position - radius > 255 then its off screen
 128+ EB9E              ;;                    ClearCarryFlag              ; if y position - radius > 127 then also off screen
 129+ EB9E              ;;                    sbc     hl,de               ;
 130+ EB9E              ;;                    ld      a,h                 ;
 131+ EB9E              ;;                    and     a                   ;
 132+ EB9E              ;;                    jp      nz,.NotOnScreen     ;
 133+ EB9E              ;;                    ld      a,l                 ;
 134+ EB9E              ;;                    and     $80                 ;
 135+ EB9E              ;;                    jp      nz,.NotOnScreen     ;
 136+ EB9E              ;;.OnScreen:          ClearCarryFlag
 137+ EB9E              ;;                    ret
 138+ EB9E              ;;.NotOnScreen:       SetCarryFlag
 139+ EB9E              ;;                    ret
 140+ EB9E
 141+ EB9E
 142+ EB9E              ;;CircleRadius        DB      0
 143+ EB9E              ;;CircleStep          DB      0
 144+ EB9E              ;;CircleFlag          DB      0
 145+ EB9E              ;;CircleCounter       DB      0
 146+ EB9E              ;;; EliteCircle, uses lines as per original elite
 147+ EB9E              ;;; ix = x Position, iy = y position, d = radius, e = colour x and y are 2's compliment not leading sign
 148+ EB9E              ;;EliteCircle:        push    de                      ; save radius
 149+ EB9E              ;;                    call    EliteCheckOn2c          ; if its off screen carry will be set to
 150+ EB9E              ;;                    ret     c                       ;
 151+ EB9E              ;;                    pop     de                      ; set X (or in our case circle radius) to radius
 152+ EB9E              ;;                    ld      a,d                     ;
 153+ EB9E              ;;                    ld      (CircleRadius),a        ;
 154+ EB9E              ;;                    ld      d,8
 155+ EB9E              ;;                    JumpIfALTNusng  d,.DoneRadius   ; If the radius < 8, skip to PL89
 156+ EB9E              ;;                    srl     d                       ; Halve d so d = 4
 157+ EB9E              ;;                    JumpifALTNusng  60,.DoneRadius  ; If the radius < 60, skip to PL89
 158+ EB9E              ;;                    srl     d                       ; Halve d so d = 2
 159+ EB9E              ;;.DoneRadius:        ld      a,d                     ; Now store value in d into step
 160+ EB9E              ;;                    ld      (CircleStep),a
 161+ EB9E              ;;; ix = x Position, iy = y position, CircleRadius = radius, CircleStep = step value based on radius, must be on screen
 162+ EB9E              ;;EliteCircle2:       ld      a,$FF                   ; set flag for first plot
 163+ EB9E              ;;                    ld      (CircleFlag),a
 164+ EB9E              ;;                    inc     a                       ; set counter to 0 (goes to 64)
 165+ EB9E              ;;                    ld      (CircleCounter),a
 166+ EB9E              ;;.CircleLoop:        ld      a,(CircleCounter)       ; Set A = CNT
 167+ EB9E              ;;
 168+ EB9E              ;; JSR FMLTU2             \ Call FMLTU2 to calculate:
 169+ EB9E              ;;                        \
 170+ EB9E              ;;                        \   A = K * sin(A)
 171+ EB9E              ;;                        \     = K * sin(CNT)
 172+ EB9E              ;;
 173+ EB9E              ;; LDX #0                 \ Set T = 0, so we have the following:
 174+ EB9E              ;; STX T                  \
 175+ EB9E              ;;                        \   (T A) = K * sin(CNT)
 176+ EB9E              ;;                        \
 177+ EB9E              ;;                        \ which is the x-coordinate of the circle for this count
 178+ EB9E              ;;
 179+ EB9E              ;; LDX CNT                \ If CNT < 33 then jump to PL37, as this is the right
 180+ EB9E              ;; CPX #33                \ half of the circle and the sign of the x-coordinate is
 181+ EB9E              ;; BCC PL37               \ correct
 182+ EB9E              ;;
 183+ EB9E              ;; EOR #%11111111         \ This is the left half of the circle, so we want to
 184+ EB9E              ;; ADC #0                 \ flip the sign of the x-coordinate in (T A) using two's
 185+ EB9E              ;; TAX                    \ complement, so we start with the low byte and store it
 186+ EB9E              ;;                        \ in X (the ADC adds 1 as we know the C flag is set)
 187+ EB9E              ;;
 188+ EB9E              ;; LDA #&FF               \ And then we flip the high byte in T
 189+ EB9E              ;; ADC #0
 190+ EB9E              ;; STA T
 191+ EB9E              ;;
 192+ EB9E              ;; TXA                    \ Finally, we restore the low byte from X, so we have
 193+ EB9E              ;;                        \ now negated the x-coordinate in (T A)
 194+ EB9E              ;;
 195+ EB9E              ;; CLC                    \ Clear the C flag so we can do some more addition below
 196+ EB9E              ;;
 197+ EB9E              ;;.PL37
 198+ EB9E              ;;
 199+ EB9E              ;; ADC K3                 \ We now calculate the following:
 200+ EB9E              ;; STA K6                 \
 201+ EB9E              ;;                        \   K6(1 0) = (T A) + K3(1 0)
 202+ EB9E              ;;                        \
 203+ EB9E              ;;                        \ to add the coordinates of the centre to our circle
 204+ EB9E              ;;                        \ point, starting with the low bytes
 205+ EB9E              ;;
 206+ EB9E              ;; LDA K3+1               \ And then doing the high bytes, so we now have:
 207+ EB9E              ;; ADC T                  \
 208+ EB9E              ;; STA K6+1               \   K6(1 0) = K * sin(CNT) + K3(1 0)
 209+ EB9E              ;;                        \
 210+ EB9E              ;;                        \ which is the result we want for the x-coordinate
 211+ EB9E              ;;
 212+ EB9E              ;; LDA CNT                \ Set A = CNT + 16
 213+ EB9E              ;; CLC
 214+ EB9E              ;; ADC #16
 215+ EB9E              ;;
 216+ EB9E              ;; JSR FMLTU2             \ Call FMLTU2 to calculate:
 217+ EB9E              ;;                        \
 218+ EB9E              ;;                        \   A = K * sin(A)
 219+ EB9E              ;;                        \     = K * sin(CNT + 16)
 220+ EB9E              ;;                        \     = K * cos(CNT)
 221+ EB9E              ;;
 222+ EB9E              ;; TAX                    \ Set X = A
 223+ EB9E              ;;                        \       = K * cos(CNT)
 224+ EB9E              ;;
 225+ EB9E              ;; LDA #0                 \ Set T = 0, so we have the following:
 226+ EB9E              ;; STA T                  \
 227+ EB9E              ;;                        \   (T X) = K * cos(CNT)
 228+ EB9E              ;;                        \
 229+ EB9E              ;;                        \ which is the y-coordinate of the circle for this count
 230+ EB9E              ;;
 231+ EB9E              ;; LDA CNT                \ Set A = (CNT + 15) mod 64
 232+ EB9E              ;; ADC #15
 233+ EB9E              ;; AND #63
 234+ EB9E              ;;
 235+ EB9E              ;; CMP #33                \ If A < 33 (i.e. CNT is 0-16 or 48-64) then jump to
 236+ EB9E              ;; BCC PL38               \ PL38, as this is the bottom half of the circle and the
 237+ EB9E              ;;                        \ sign of the y-coordinate is correct
 238+ EB9E              ;;
 239+ EB9E              ;; TXA                    \ This is the top half of the circle, so we want to
 240+ EB9E              ;; EOR #%11111111         \ flip the sign of the y-coordinate in (T X) using two's
 241+ EB9E              ;; ADC #0                 \ complement, so we start with the low byte in X (the
 242+ EB9E              ;; TAX                    \ ADC adds 1 as we know the C flag is set)
 243+ EB9E              ;;
 244+ EB9E              ;; LDA #&FF               \ And then we flip the high byte in T, so we have
 245+ EB9E              ;; ADC #0                 \ now negated the y-coordinate in (T X)
 246+ EB9E              ;; STA T
 247+ EB9E              ;;
 248+ EB9E              ;; CLC                    \ Clear the C flag so we can do some more addition below
 249+ EB9E              ;;
 250+ EB9E              ;;.PL38
 251+ EB9E              ;;
 252+ EB9E              ;; JSR BLINE              \ Call BLINE to draw this segment, which also increases
 253+ EB9E              ;;                        \ CNT by STP, the step size
 254+ EB9E              ;;
 255+ EB9E              ;; CMP #65                \ If CNT >= 65 then skip the next instruction
 256+ EB9E              ;; BCS P%+5
 257+ EB9E              ;;
 258+ EB9E              ;; JMP PLL3               \ Jump back for the next segment
 259+ EB9E              ;;
 260+ EB9E              ;; CLC                    \ Clear the C flag to indicate success
 261+ EB9E              ;;
 262+ EB9E              ;; RTS                    \ Return from the subroutine
 263+ EB9E              ;;; ">L2_draw_circle16 bit" ix = x Position, iy = y position, d = radius, e = colour
 264+ EB9E              ;;; draw using minium squared algorithm
 265+ EB9E              ;;;
 266+ EB9E              ;;CircleCurrentX      DB      0
 267+ EB9E              ;;CircleCurrentY      DB      0
 268+ EB9E              ;;CircleCurrentError  DW      0
 269+ EB9E              ;;l2_draw_circle16bit:ld
 270+ EB9E              ;;.ConvertIXto2sC
 271+ EB9E              ;;.ConvertIYto2sC
 272+ EB9E              ;;.ZeroCurrentError
 273+ EB9E              ;;.SetCurrentXRadius:
 274+ EB9E              ;;.ZeroCurrentY
 275+ EB9E              ;;.DrawPixels:
 276+ EB9E              ;;
 277+ EB9E              ;;                    MMUSelectLayer2
 278+ EB9E              ;;.PlotLoop:
 279+ EB9E              ;;.Plot1:
 280+ EB9E              ;;
 281+ EB9E              ;;.Plot2:
 282+ EB9E              ;;
 283+ EB9E              ;;.Plot3:
 284+ EB9E              ;;
 285+ EB9E              ;;.Plot3:
 286+ EB9E              ;;
 287+ EB9E              ;;.Plot5:
 288+ EB9E              ;;
 289+ EB9E              ;;.Plot6:
 290+ EB9E              ;;
 291+ EB9E              ;;.Plot7:
 292+ EB9E              ;;
 293+ EB9E              ;;.Plot8:
 294+ EB9E              ;;
 295+ EB9E              ;;
 296+ EB9E              ;;
 297+ EB9E              ;;
 298+ EB9E              ;;
 299+ EB9E              ;;
 300+ EB9E              ;;
 301+ EB9E              ;;
 302+ EB9E              ;;
 303+ EB9E              ;;                    ld      a,(CurrentX)    ; if x <= y then break loop
 304+ EB9E              ;;                    ld      hl,CurrentY     ; .
 305+ EB9E              ;;                    cp      (hl)            ; .
 306+ EB9E              ;;                    ret     z               ; . X = Y
 307+ EB9E              ;;                    ret     c               ; . X < Y
 308+ EB9E              ;;.UpdateError:       ld      a,(CurrentY)    ; e += 2*y + 1
 309+ EB9E              ;;                    ld      e,a
 310+ EB9E              ;;                    ld      d,0
 311+ EB9E              ;;                    ShiftDELeft1
 312+ EB9E              ;;                    inc     de
 313+ EB9E              ;;                    ld      hl,(CircleCurrentError)
 314+ EB9E              ;;                    ClearCarryFlag
 315+ EB9E              ;;                    adc     hl,de
 316+ EB9E              ;;                    ld      (CircleCurrentError),hl
 317+ EB9E              ;;.NextCurrentY:      ld      hl,CircleCurrentY
 318+ EB9E              ;;                    inc     (hl)
 319+ EB9E              ;;.CheckEgtX:         ld      hl,(CircleCurrentError)
 320+ EB9E              ;;                    ld      a,(CircleCurrentX)
 321+ EB9E              ;;                    ld      d,0
 322+ EB9E              ;;                    ld      e,0
 323+ EB9E              ;;                    cpHLDE
 324+ EB9E              ;;                    jp      z,.AdjustError
 325+ EB9E              ;;                    jp      nc,.PlotLoop
 326+ EB9E              ;;.AdjustError:       ld      a,(CircleCurrentX)
 327+ EB9E              ;;                    ld      d,0
 328+ EB9E              ;;                    ld      e,a
 329+ EB9E              ;;                    ShiftDELeft1
 330+ EB9E              ;;                    ld      hl,(CircleCurrentError)
 331+ EB9E              ;;                    inc     hl
 332+ EB9E              ;;                    ClearCarryFlag
 333+ EB9E              ;;                    sbc     hl,de
 334+ EB9E              ;;                    ld      a,e
 335+ EB9E              ;;                    dec     a
 336+ EB9E              ;;                    ld      (CircleCurrentX),a
 337+ EB9E              ;;                    jp      .PlotLoop
 338+ EB9E              ;;;plot pixel at x = de y = bc
 339+ EB9E              ;;.PlotPixelBCDE:     ld		a,0                     ; This was originally indirect, where as it neeed to be value
 340+ EB9E              ;;                    push	de,,bc,,hl
 341+ EB9E              ;;                    ld      a,d                     ; if d is not zero then it must be -ve or > 255 to skip
 342+ EB9E              ;;                    and     a                       ;
 343+ EB9E              ;;                    ret     nz                      ;
 344+ EB9E              ;;                    ld      a,b                     ; if b is not zero then it must be -ve or > 255 to skip
 345+ EB9E              ;;                    and     a
 346+ EB9E              ;;                    ret     nz
 347+ EB9E              ;;                    ld      a,c                     ; but also check if y > 127 and if so skip
 348+ EB9E              ;;                    and     $80
 349+ EB9E              ;;                    ret     nz
 350+ EB9E              ;;                    ld      a,c                     ; so we can now plot
 351+ EB9E              ;;                    call    asm_l2_row_bank_select
 352+ EB9E              ;;                    ld      h,a
 353+ EB9E              ;;                    ld      l,e
 354+ EB9E              ;;                    ld      a,(line_gfx_colour)
 355+ EB9E              ;;                    ld      (hl),a
 356+ EB9E              ;;                    pop		de,,bc,,hl
 357+ EB9E              ;;                    ret
 358+ EB9E              ;;
 359+ EB9E
 360+ EB9E              ;---------------------------------------------------------------------------------------------------------------------------------
 361+ EB9E              ; ">l2_draw_circle BC = center row col, d = radius, e = colour"
 362+ EB9E 7B           l2_draw_circle:     ld		a,e
 363+ EB9F 32 45 EC                         ld		(.PlotPixel+1),a
 364+ EBA2 7A                               ld		a,d								; get radius
 365+ EBA3 A7                               and		a
 366+ EBA4 C8                               ret		z
 367+ EBA5 FE 01                            cp		1
 368+ EBA7 CA 5C EC                         jp		z,CircleSinglepixel
 369+ EBAA ED 43 D4 EB                      ld		(.Plot1+1),bc	        ; save origin into cXcY reg in code
 370+ EBAE DD 67                            ld		ixh,a			        ; ixh =  x = raidus
 371+ EBB0 DD 2E 00                         ld		ixl,0			        ; iyh =  y = 0
 372+ EBB3 26 00        .calcd:	            ld		h,0
 373+ EBB5 6F                               ld		l,a
 374+ EBB6 29                               add		hl,hl			        ; hl = r * 2
 375+ EBB7 EB                               ex		de,hl			        ; de = r * 2
 376+ EBB8 21 03 00                         ld		hl,3
 377+ EBBB A7                               and		a
 378+ EBBC ED 52                            sbc		hl,de			        ; hl = 3 - (r * 2)
 379+ EBBE 44                               ld		b,h
 380+ EBBF 4D                               ld		c,l				        ; bc = 3 - (r * 2)
 381+ EBC0 21 01 00     .calcdelta:         ld		hl,1
 382+ EBC3 16 00                            ld		d,0
 383+ EBC5 DD 5D                            ld		e,ixl
 384+ EBC7 A7                               and		a
 385+ EBC8 ED 52                            sbc		hl,de
 386+ EBCA 11 01 00     .Setde1:            ld		de,1
 387+ EBCD DD 7C        .CircleLoop:        ld		a,ixh
 388+ EBCF DD BD                            cp		ixl
 389+ EBD1 D8                               ret		c
 390+ EBD2 D9           .ProcessLoop:	    exx
 391+ EBD3 11 00 00     .Plot1:             ld		de,0                    ; de = cXcY
 392+ EBD6 7B                               ld		a,e                     ; c = cY + error
 393+ EBD7 DD 85                            add		a,ixl                   ;
 394+ EBD9 4F                               ld		c,a                     ;
 395+ EBDA 7A                               ld		a,d                     ; b = xY+radius
 396+ EBDB DD 84                            add		a,ixh                   ;
 397+ EBDD 47                               ld		b,a                     ;
 398+ EBDE CD 44 EC                         call	.PlotPixel			    ;CX+X,CY+Y
 399+ EBE1 7B           .Plot2:             ld 		a,e
 400+ EBE2 DD 95                            sub 	ixl
 401+ EBE4 4F                               ld 		c,a
 402+ EBE5 7A                               ld 		a,d
 403+ EBE6 DD 84                            add 	a,ixh
 404+ EBE8 47                               ld		b,a
 405+ EBE9 CD 44 EC                         call	.PlotPixel			    ;CX-X,CY+Y
 406+ EBEC 7B           .Plot3:             ld 		a,e
 407+ EBED DD 85                            add		a,ixl
 408+ EBEF 4F                               ld 		c,a
 409+ EBF0 7A                               ld 		a,d
 410+ EBF1 DD 94                            sub 	ixh
 411+ EBF3 47                               ld 		b,a
 412+ EBF4 CD 44 EC                         call	.PlotPixel			    ;CX+X,CY-Y
 413+ EBF7 7B           .Plot4:             ld 		a,e
 414+ EBF8 DD 95                            sub 	ixl
 415+ EBFA 4F                               ld 		c,a
 416+ EBFB 7A                               ld 		a,d
 417+ EBFC DD 94                            sub 	ixh
 418+ EBFE 47                               ld 		b,a
 419+ EBFF CD 44 EC                         call	.PlotPixel			    ;CX-X,CY-Y
 420+ EC02 7A           .Plot5:	            ld 		a,d
 421+ EC03 DD 85                            add 	a,ixl
 422+ EC05 47                               ld 		b,a
 423+ EC06 7B                               ld 		a,e
 424+ EC07 DD 84                            add 	a,ixh
 425+ EC09 4F                               ld 		c,a
 426+ EC0A CD 44 EC                         call	.PlotPixel			    ;CY+X,CX+Y
 427+ EC0D 7A           .Plot6:	            ld 		a,d
 428+ EC0E DD 95                            sub 	ixl
 429+ EC10 47                               ld 		b,a
 430+ EC11 7B                               ld 		a,e
 431+ EC12 DD 84                            add 	a,ixh
 432+ EC14 4F                               ld 		c,a
 433+ EC15 CD 44 EC                         call	.PlotPixel			    ;CY-X,CX+Y
 434+ EC18 7A           .Plot7:	            ld 		a,d
 435+ EC19 DD 85                            add 	a,ixl
 436+ EC1B 47                               ld 		b,a
 437+ EC1C 7B                               ld 		a,e
 438+ EC1D DD 94                            sub 	ixh
 439+ EC1F 4F                               ld 		c,a
 440+ EC20 CD 44 EC                         call	.PlotPixel			    ;CY+X,CX-Y
 441+ EC23 7A           .Plot8:	            ld 		a,d
 442+ EC24 DD 95                            sub 	ixl
 443+ EC26 47                               ld		b,a
 444+ EC27 7B                               ld 		a,e
 445+ EC28 DD 94                            sub 	ixh
 446+ EC2A 4F                               ld 		c,a
 447+ EC2B CD 44 EC                         call	.PlotPixel			    ;CY-X,CX-Y
 448+ EC2E D9                               exx
 449+ EC2F CB 7C        .IncrementCircle:	bit     7,h				        ; Check for Hl<=0
 450+ EC31 28 03                            jr z,   .draw_circle_1
 451+ EC33 19                               add hl,de			            ; Delta=Delta+D1
 452+ EC34 18 05                            jr      .draw_circle_2		;
 453+ EC36 09           .draw_circle_1:		add     hl,bc			        ; Delta=Delta+D2
 454+ EC37 03                               inc     bc
 455+ EC38 03                               inc     bc				        ; D2=D2+2
 456+ EC39 DD 25                            dec     ixh				        ; Y=Y-1
 457+ EC3B 03           .draw_circle_2:		inc bc				            ; D2=D2+2
 458+ EC3C 03                               inc bc
 459+ EC3D 13                               inc de				            ; D1=D1+2
 460+ EC3E 13                               inc de
 461+ EC3F DD 2C                            inc ixl				            ; X=X+1
 462+ EC41 C3 CD EB                         jp      .CircleLoop
 463+ EC44 3E 00        .PlotPixel:         ld		a,0                     ; This was originally indirect, where as it neeed to be value
 464+ EC46 D5 C5 E5                         push	de,,bc,,hl
 465+ EC49                                  l2_plot_macro; call 	l2_plot_pixel_y_test
 465+ EC49 78          >                        ld      a,b
 465+ EC4A             >                        JumpIfAGTENusng 192 ,.NoPlot
 465+ EC4A FE C0       >                        cp     192
 465+ EC4C D2 58 EC    >                        jp		nc,.NoPlot
 465+ EC4F 69          >                        ld      l,c
 465+ EC50 CD 68 E0    >                        call    asm_l2_row_bank_select
 465+ EC53 67          >                        ld      h,a
 465+ EC54 3A 8D E2    >                        ld      a,(line_gfx_colour)
 465+ EC57 77          >                        ld      (hl),a
 465+ EC58             >.NoPlot:
 466+ EC58 E1 C1 D1                         pop		de,,bc,,hl
 467+ EC5B C9                               ret
 468+ EC5C 7B           CircleSinglepixel:  ld		a,e
 469+ EC5D                                  l2_plot_macro; call	l2_plot_pixel_y_test
 469+ EC5D 78          >                        ld      a,b
 469+ EC5E             >                        JumpIfAGTENusng 192 ,.NoPlot
 469+ EC5E FE C0       >                        cp     192
 469+ EC60 D2 6C EC    >                        jp		nc,.NoPlot
 469+ EC63 69          >                        ld      l,c
 469+ EC64 CD 68 E0    >                        call    asm_l2_row_bank_select
 469+ EC67 67          >                        ld      h,a
 469+ EC68 3A 8D E2    >                        ld      a,(line_gfx_colour)
 469+ EC6B 77          >                        ld      (hl),a
 469+ EC6C             >.NoPlot:
 470+ EC6C C9                               ret
 471+ EC6D
 472+ EC6D              CalcNewPointMacro:  MACRO reg1, oper, reg2
 473+ EC6D ~                                ClearCarryFlag
 474+ EC6D ~                                ld      b,0
 475+ EC6D ~                                ld      c,reg2
 476+ EC6D ~                                oper    hl,bc
 477+ EC6D                                  ENDM
 478+ EC6D
 479+ EC6D              ; ">l2_draw_clipped_circle HL = Center X 2's c, DE = Center Y 2's , c = radius, b = colour"
 480+ EC6D              l2_draw_clipped_circle:
 481+ EC6D 78                               ld      a,b                     ; save Colour
 482+ EC6E 32 9F ED                         ld		(.PlotColour+1),a
 483+ EC71 79                               ld		a,c								; get radius
 484+ EC72                                  ReturnIfAIsZero
 484+ EC72 A7          >                        and     a
 484+ EC73 C8          >                        ret     z
 485+ EC74                                  JumpIfAEqNusng  1, .circleSinglepixel
 485+ EC74 FE 01       >                        cp     1
 485+ EC76 CA B9 ED    >                        jp      z,.circleSinglepixel
 486+ EC79 ED 53 A6 EC                      ld		(.Plot1Y+1),de					; save origin into DE and HL
 487+ EC7D 22 A9 EC                         ld      (.Plot1X+1),hl                  ; .
 488+ EC80                                  DISPLAY "TODO : IXH and IXL need to be 16 bit and in IX and IY"
 489+ EC80 DD 67                            ld		ixh,a							; ixh = x = raidus
 490+ EC82 DD 2E 00                         ld		ixl,0						    ; ixl = y = error
 491+ EC85 26 00        .calcd:	            ld		h,0                             ; hl = radius
 492+ EC87 6F                               ld		l,a                             ; raidius is still in a at this point
 493+ EC88 29                               add		hl,hl							; hl = r * 2
 494+ EC89 EB                               ex		de,hl							; de = r * 2
 495+ EC8A 21 03 00                         ld		hl,3                            ; hl = 3 - (r * 2)
 496+ EC8D                                  ClearCarryFlag                          ; .
 496+ EC8D B7          >                        or a
 497+ EC8E ED 52                            sbc		hl,de							; .
 498+ EC90 44 4D                            ld      bc,hl                           ; bc = 3 - (r * 2)
 499+ EC92 21 01 00     .calcdelta:         ld		hl,1                            ; hl = 1
 500+ EC95 16 00                            ld		d,0                             ; de = ixl (error)
 501+ EC97 DD 5D                            ld		e,ixl                           ;
 502+ EC99                                  ClearCarryFlag                          ;
 502+ EC99 B7          >                        or a
 503+ EC9A ED 52                            sbc		hl,de                           ; hl = 1 - error
 504+ EC9C 11 01 00     .Setde1:            ld		de,1                            ; de = 1
 505+ EC9F              .CircleLoop:        ReturnIfRegLTNusng ixh, ixl             ; if radius > ixl counter
 505+ EC9F DD 7C       >                        ld      a,ixh
 505+ ECA1 DD BD       >                        cp      ixl
 505+ ECA3 D8          >                        ret	    c
 506+ ECA4 D9           .ProcessLoop:	    exx                                     ; save all bc,de,hl registers
 507+ ECA5              ;--- CX+X,CY+Y ---------------------------------------------;
 508+ ECA5 11 00 00     .Plot1Y:            ld		de,0                            ; this is Y coord
 509+ ECA8 21 00 00     .Plot1X:            ld      hl,0                            ; this is x coord
 510+ ECAB E5 D5                            push    hl,,de
 511+ ECAD                                  CalcNewPointMacro hl, adc, ixh          ;
 511+ ECAD             >                    ClearCarryFlag
 511+ ECAD B7          >                        or a
 511+ ECAE 06 00       >                    ld      b,0
 511+ ECB0 DD 4C       >                    ld      c,ixh
 511+ ECB2 ED 4A       >                    adc    hl,bc
 512+ ECB4 EB                               ex      de,hl                           ; de = x coord calculated, hl =y center Y
 513+ ECB5                                  CalcNewPointMacro hl, adc, ixl          ;
 513+ ECB5             >                    ClearCarryFlag
 513+ ECB5 B7          >                        or a
 513+ ECB6 06 00       >                    ld      b,0
 513+ ECB8 DD 4D       >                    ld      c,ixl
 513+ ECBA ED 4A       >                    adc    hl,bc
 514+ ECBC CD 94 ED                         call	.PlotPixel	            		; CX+X,CY+Y using DE = x and hl = y *** Note if we order plot 1 to 8 we can selectivley jump past many on elimiation check
 515+ ECBF D1 E1        .Plot1Done:         pop     hl,,de                          ; get de (y) and hl (x) back but reversed as the next plot expected the to be reversed from the ex de,hl above  + 0
 516+ ECC1              ;--- CX+X,CY-Y ---------------------------------------------;
 517+ ECC1 E5 D5        .Plot2:             push    hl,,de                          ; e.g  do all CX + X first, so plot1, plot3 and just one check for cx + x off screen
 518+ ECC3                                  CalcNewPointMacro hl, adc, ixh          ;
 518+ ECC3             >                    ClearCarryFlag
 518+ ECC3 B7          >                        or a
 518+ ECC4 06 00       >                    ld      b,0
 518+ ECC6 DD 4C       >                    ld      c,ixh
 518+ ECC8 ED 4A       >                    adc    hl,bc
 519+ ECCA                                  JumpIfRegIsNotZero  h,.Plot2Done        ;
 519+ ECCA 7C          >                        ld      a,h
 519+ ECCB A7          >                        and     a
 519+ ECCC C2 DA EC    >                        jp	    nz,.Plot2Done
 520+ ECCF EB                               ex      de,hl                           ; de = calculated x
 521+ ECD0                                  CalcNewPointMacro hl, sbc, ixl          ;
 521+ ECD0             >                    ClearCarryFlag
 521+ ECD0 B7          >                        or a
 521+ ECD1 06 00       >                    ld      b,0
 521+ ECD3 DD 4D       >                    ld      c,ixl
 521+ ECD5 ED 42       >                    sbc    hl,bc
 522+ ECD7 CD 94 ED                         call	.PlotPixel	                    ; CX-X,CY+Y
 523+ ECDA D1 E1        .Plot2Done:         pop     hl,,de
 524+ ECDC              ;--- CX-X,CY-Y ---------------------------------------------; bollocksC
 525+ ECDC E5 D5        .Plot3:             push    hl,,de
 526+ ECDE                                  CalcNewPointMacro hl, sbc, ixh          ;
 526+ ECDE             >                    ClearCarryFlag
 526+ ECDE B7          >                        or a
 526+ ECDF 06 00       >                    ld      b,0
 526+ ECE1 DD 4C       >                    ld      c,ixh
 526+ ECE3 ED 42       >                    sbc    hl,bc
 527+ ECE5                                  JumpIfRegIsNotZero  h,.Plot3Done        ;
 527+ ECE5 7C          >                        ld      a,h
 527+ ECE6 A7          >                        and     a
 527+ ECE7 C2 F5 EC    >                        jp	    nz,.Plot3Done
 528+ ECEA EB                               ex      de,hl                           ; de = calculated x
 529+ ECEB                                  CalcNewPointMacro hl, sbc, ixl          ;
 529+ ECEB             >                    ClearCarryFlag
 529+ ECEB B7          >                        or a
 529+ ECEC 06 00       >                    ld      b,0
 529+ ECEE DD 4D       >                    ld      c,ixl
 529+ ECF0 ED 42       >                    sbc    hl,bc
 530+ ECF2 CD 94 ED                         call	.PlotPixel	                    ; CX+X,CY-Y
 531+ ECF5 D1 E1        .Plot3Done:         pop     hl,,de
 532+ ECF7              ;--- CX-X,CY+Y ---------------------------------------------; bollocks
 533+ ECF7 E5 D5        .Plot4:             push    hl,,de
 534+ ECF9                                  CalcNewPointMacro hl, sbc, ixh          ;
 534+ ECF9             >                    ClearCarryFlag
 534+ ECF9 B7          >                        or a
 534+ ECFA 06 00       >                    ld      b,0
 534+ ECFC DD 4C       >                    ld      c,ixh
 534+ ECFE ED 42       >                    sbc    hl,bc
 535+ ED00                                  JumpIfRegIsNotZero  h,.Plot4Done
 535+ ED00 7C          >                        ld      a,h
 535+ ED01 A7          >                        and     a
 535+ ED02 C2 10 ED    >                        jp	    nz,.Plot4Done
 536+ ED05 EB                               ex      de,hl
 537+ ED06                                  CalcNewPointMacro hl, adc, ixl          ;
 537+ ED06             >                    ClearCarryFlag
 537+ ED06 B7          >                        or a
 537+ ED07 06 00       >                    ld      b,0
 537+ ED09 DD 4D       >                    ld      c,ixl
 537+ ED0B ED 4A       >                    adc    hl,bc
 538+ ED0D CD 94 ED                         call	.PlotPixel	                    ; CX-X,CY-Y
 539+ ED10 D1 E1        .Plot4Done:         pop     hl,,de
 540+ ED12              ;--- CX+Y,CY+X ---------------------------------------------; bollocks
 541+ ED12 E5 D5        .Plot5:             push    hl,,de
 542+ ED14                                  CalcNewPointMacro hl, adc, ixl          ;
 542+ ED14             >                    ClearCarryFlag
 542+ ED14 B7          >                        or a
 542+ ED15 06 00       >                    ld      b,0
 542+ ED17 DD 4D       >                    ld      c,ixl
 542+ ED19 ED 4A       >                    adc    hl,bc
 543+ ED1B                                  JumpIfRegIsNotZero  h,.Plot5Done
 543+ ED1B 7C          >                        ld      a,h
 543+ ED1C A7          >                        and     a
 543+ ED1D C2 2B ED    >                        jp	    nz,.Plot5Done
 544+ ED20 EB                               ex      de,hl
 545+ ED21                                  CalcNewPointMacro hl, adc, ixh          ;
 545+ ED21             >                    ClearCarryFlag
 545+ ED21 B7          >                        or a
 545+ ED22 06 00       >                    ld      b,0
 545+ ED24 DD 4C       >                    ld      c,ixh
 545+ ED26 ED 4A       >                    adc    hl,bc
 546+ ED28 CD 94 ED                         call	.PlotPixel	                    ;CY+X,CX+Y
 547+ ED2B D1 E1        .Plot5Done:         pop     hl,,de
 548+ ED2D              ;--- CX+Y,CX-X ---------------------------------------------;bollocks
 549+ ED2D E5 D5        .Plot6:             push    hl,,de
 550+ ED2F                                  CalcNewPointMacro hl, adc, ixl          ;
 550+ ED2F             >                    ClearCarryFlag
 550+ ED2F B7          >                        or a
 550+ ED30 06 00       >                    ld      b,0
 550+ ED32 DD 4D       >                    ld      c,ixl
 550+ ED34 ED 4A       >                    adc    hl,bc
 551+ ED36                                  JumpIfRegIsNotZero  h,.Plot6Done
 551+ ED36 7C          >                        ld      a,h
 551+ ED37 A7          >                        and     a
 551+ ED38 C2 46 ED    >                        jp	    nz,.Plot6Done
 552+ ED3B EB                               ex      de,hl
 553+ ED3C                                  CalcNewPointMacro hl, sbc, ixh          ;
 553+ ED3C             >                    ClearCarryFlag
 553+ ED3C B7          >                        or a
 553+ ED3D 06 00       >                    ld      b,0
 553+ ED3F DD 4C       >                    ld      c,ixh
 553+ ED41 ED 42       >                    sbc    hl,bc
 554+ ED43 CD 94 ED                         call	.PlotPixel	                    ; CY-X,CX+Y
 555+ ED46 D1 E1        .Plot6Done:         pop     hl,,de
 556+ ED48              ;--- CX-Y,CY-X ---------------------------------------------;bollocksC
 557+ ED48 E5 D5        .Plot7:             push    hl,,de
 558+ ED4A                                  CalcNewPointMacro hl, sbc, ixl          ;
 558+ ED4A             >                    ClearCarryFlag
 558+ ED4A B7          >                        or a
 558+ ED4B 06 00       >                    ld      b,0
 558+ ED4D DD 4D       >                    ld      c,ixl
 558+ ED4F ED 42       >                    sbc    hl,bc
 559+ ED51                                  JumpIfRegIsNotZero  h,.Plot7Done
 559+ ED51 7C          >                        ld      a,h
 559+ ED52 A7          >                        and     a
 559+ ED53 C2 61 ED    >                        jp	    nz,.Plot7Done
 560+ ED56 EB                               ex      de,hl
 561+ ED57                                  CalcNewPointMacro hl, sbc, ixh          ;
 561+ ED57             >                    ClearCarryFlag
 561+ ED57 B7          >                        or a
 561+ ED58 06 00       >                    ld      b,0
 561+ ED5A DD 4C       >                    ld      c,ixh
 561+ ED5C ED 42       >                    sbc    hl,bc
 562+ ED5E CD 94 ED                         call	.PlotPixel	                    ; CY+X,CX-Y
 563+ ED61 D1 E1        .Plot7Done:         pop     hl,,de
 564+ ED63              ;--- CX-Y,CY+X ---------------------------------------------; bollocks
 565+ ED63 E5 D5        .Plot8:             push    hl,,de
 566+ ED65                                  CalcNewPointMacro hl, sbc, ixl          ;
 566+ ED65             >                    ClearCarryFlag
 566+ ED65 B7          >                        or a
 566+ ED66 06 00       >                    ld      b,0
 566+ ED68 DD 4D       >                    ld      c,ixl
 566+ ED6A ED 42       >                    sbc    hl,bc
 567+ ED6C                                  JumpIfRegIsNotZero  h,.Plot8Done
 567+ ED6C 7C          >                        ld      a,h
 567+ ED6D A7          >                        and     a
 567+ ED6E C2 7C ED    >                        jp	    nz,.Plot8Done
 568+ ED71 EB                               ex      de,hl
 569+ ED72                                  CalcNewPointMacro hl, adc, ixh          ;
 569+ ED72             >                    ClearCarryFlag
 569+ ED72 B7          >                        or a
 569+ ED73 06 00       >                    ld      b,0
 569+ ED75 DD 4C       >                    ld      c,ixh
 569+ ED77 ED 4A       >                    adc    hl,bc
 570+ ED79 CD 94 ED                         call	.PlotPixel	                    ; CY-X,CX-Y
 571+ ED7C D1 E1        .Plot8Done:         pop     hl,,de
 572+ ED7E D9           .PlotDone:          exx
 573+ ED7F CB 7C        .IncrementCircle:	bit     7,h				; Check for Hl<=0
 574+ ED81 28 03                            jr z,   .draw_circle_1
 575+ ED83 19                               add hl,de			; Delta=Delta+D1
 576+ ED84 18 05                            jr      .draw_circle_2		;
 577+ ED86 09           .draw_circle_1:		add     hl,bc			; Delta=Delta+D2
 578+ ED87 03                               inc     bc
 579+ ED88 03                               inc     bc				; D2=D2+2
 580+ ED89 DD 25                            dec     ixh				; Y=Y-1
 581+ ED8B 03           .draw_circle_2:		inc     bc				; D2=D2+2
 582+ ED8C 03                               inc     bc
 583+ ED8D 13                               inc     de				; D1=D1+2
 584+ ED8E 13                               inc     de
 585+ ED8F DD 2C                            inc     ixl				; X=X+1
 586+ ED91 C3 9F EC                         jp      .CircleLoop
 587+ ED94 7A           .PlotPixel:         ld      a,d             ; filter x> 256 or negative
 588+ ED95 A7                               and     a
 589+ ED96 C0                               ret     nz
 590+ ED97 7C                               ld      a,h             ; filter y > 256 or negative
 591+ ED98 A7                               and     a
 592+ ED99 C0                               ret     nz
 593+ ED9A 7D                               ld      a,l             ; filter y > 127
 594+ ED9B E6 80                            and     $80
 595+ ED9D C0                               ret     nz
 596+ ED9E 3E 00        .PlotColour:        ld		a,0             ; This was originally indirect, where as it neeed to be value
 597+ EDA0 D5 C5 E5                         push	de,,bc,,hl
 598+ EDA3 45                               ld      b,l             ; At this point de = x and hl = y
 599+ EDA4 4B                               ld      c,e
 600+ EDA5                                  l2_plot_macro; call 	l2_plot_pixel_y_test
 600+ EDA5 78          >                        ld      a,b
 600+ EDA6             >                        JumpIfAGTENusng 192 ,.NoPlot
 600+ EDA6 FE C0       >                        cp     192
 600+ EDA8 D2 B4 ED    >                        jp		nc,.NoPlot
 600+ EDAB 69          >                        ld      l,c
 600+ EDAC CD 68 E0    >                        call    asm_l2_row_bank_select
 600+ EDAF 67          >                        ld      h,a
 600+ EDB0 3A 8D E2    >                        ld      a,(line_gfx_colour)
 600+ EDB3 77          >                        ld      (hl),a
 600+ EDB4             >.NoPlot:
 601+ EDB4 E1 C1 D1                         pop		de,,bc,,hl
 602+ EDB7                                  ClearCarryFlag
 602+ EDB7 B7          >                        or a
 603+ EDB8 C9                               ret
 604+ EDB9 7C           .circleSinglepixel: ld      a,h             ; as its 1 pixel if h or d are non zero then its off screen
 605+ EDBA B2                               or      d
 606+ EDBB C0                               ret     nz
 607+ EDBC CB 7B                            bit     7,e             ; and if Y is > 127 then off screen , bit is 8 states like ld a,e and a
 608+ EDBE C0                               ret     nz
 609+ EDBF 78                               ld      a,b             ; a = colour
 610+ EDC0 43                               ld      b,e             ; b = y
 611+ EDC1 4D                               ld      c,l             ; c = x
 612+ EDC2 CD 8E E2                         call    l2_plot_pixel
 613+ EDC5 C9                               ret
# file closed: ../../Layer2Graphics/layer2_plot_circle.asm
 669  EDC6                  INCLUDE "../../Layer2Graphics/layer2_plot_circle_fill.asm"
# file opened: ../../Layer2Graphics/layer2_plot_circle_fill.asm
   1+ EDC6
   2+ EDC6 00           l2_circle_dblx		DB 0
   3+ EDC7 00           l2_circle_dbly		DB 0
   4+ EDC8
   5+ EDC8              ; ">l2_draw_circle_fill BC = center row col, d = radius, e = colour"
   6+ EDC8              ; Note this code currently does not process BC
   7+ EDC8 7B           l2_draw_circle_fill:    ld		a,e
   8+ EDC9 32 5F EE                             ld		(.LineColour+1),a
   9+ EDCC 7A                                   ld		a,d								; get radius
  10+ EDCD A7                                   and		a
  11+ EDCE C8                                   ret		z
  12+ EDCF FE 01                                cp		1
  13+ EDD1 CA 5C EC                             jp		z,CircleSinglepixel
  14+ EDD4 ED 43 FE ED                          ld		(.Line1+1),bc					; save origin into DE reg in code
  15+ EDD8 DD 67                                ld		ixh,a							; ixh = raidus (x)
  16+ EDDA DD 2E 00                             ld		ixl,0							; ihy = y
  17+ EDDD 26 00        .calcd:	                ld		h,0
  18+ EDDF 6F                                   ld		l,a
  19+ EDE0 29                                   add		hl,hl							; hl = r * 2
  20+ EDE1 EB                                   ex		de,hl							; de = r * 2
  21+ EDE2 21 03 00                             ld		hl,3
  22+ EDE5 A7                                   and		a
  23+ EDE6 ED 52                                sbc		hl,de							; hl = 3 - (r * 2)
  24+ EDE8 44                                   ld		b,h
  25+ EDE9 4D                                   ld		c,l								; bc = 3 - (r * 2)
  26+ EDEA 21 01 00     .calcdelta              ld		hl,1
  27+ EDED 16 00                                ld		d,0
  28+ EDEF DD 5D                                ld		e,ixl
  29+ EDF1 A7                                   and		a
  30+ EDF2 ED 52                                sbc		hl,de
  31+ EDF4 11 01 00     .Setde1	                ld		de,1
  32+ EDF7 DD 7C        .CircleLoop:            ld		a,ixh
  33+ EDF9 DD BD                                cp		ixl
  34+ EDFB D8                                   ret		c
  35+ EDFC D9           .ProcessLoop:	        exx
  36+ EDFD 11 00 00     .Line1:                 ld		de,0
  37+ EE00 7B                                   ld 		a,e
  38+ EE01 DD 95                                sub 	ixl
  39+ EE03 4F                                   ld 		c,a
  40+ EE04 7A                                   ld 		a,d
  41+ EE05 DD 84                                add 	a,ixh
  42+ EE07 47                                   ld		b,a
  43+ EE08                                                  DISPLAY "TODO: add double x calc"
  44+ EE08                                      ;; TODO ADD DOUBLE X CALC
  45+ EE08 D5                                   push	de
  46+ EE09 DD 55                                ld		d,ixl
  47+ EE0B CB 22                                sla		d
  48+ EE0D CD 5A EE                             call	.PlotLine			;CX-X,CY+Y
  49+ EE10 D1                                   pop		de
  50+ EE11 7B           .Line2:                 ld 		a,e
  51+ EE12 DD 95                                sub		ixl
  52+ EE14 4F                                   ld 		c,a
  53+ EE15 7A                                   ld 		a,d
  54+ EE16 DD 94                                sub 	ixh
  55+ EE18 47                                   ld 		b,a
  56+ EE19                                      ;; TODO ADD DOUBLE X CALC
  57+ EE19 D5                                   push	de
  58+ EE1A DD 55                                ld		d,ixl
  59+ EE1C CB 22                                sla		d
  60+ EE1E CD 5A EE                             call	.PlotLine			;CX-X,CY-Y
  61+ EE21 D1                                   pop		de
  62+ EE22 7B           .Line3:	                ld 		a,e
  63+ EE23 DD 94                                sub		ixh
  64+ EE25 4F                                   ld 		c,a
  65+ EE26 7A                                   ld 		a,d
  66+ EE27 DD 85                                add 	a,ixl
  67+ EE29 47                                   ld 		b,a
  68+ EE2A                                      ;; TODO ADD DOUBLE Y CALC
  69+ EE2A D5                                   push	de
  70+ EE2B DD 54                                ld		d,ixh
  71+ EE2D CB 22                                sla		d
  72+ EE2F CD 5A EE                             call	.PlotLine			;CX-Y,CY+x
  73+ EE32 D1                                   pop		de
  74+ EE33 7B           .Line4:	                ld 		a,e
  75+ EE34 DD 94                                sub		ixh
  76+ EE36 4F                                   ld 		c,a
  77+ EE37 7A                                   ld 		a,d
  78+ EE38 DD 95                                sub 	ixl
  79+ EE3A 47                                   ld 		b,a
  80+ EE3B                                      ;; TODO ADD DOUBLE Y CALC
  81+ EE3B D5                                   push	de
  82+ EE3C DD 54                                ld		d,ixh
  83+ EE3E CB 22                                sla		d
  84+ EE40 CD 5A EE                             call	.PlotLine			;CX-Y,CY+x
  85+ EE43 D1                                   pop		de
  86+ EE44 D9                                   exx
  87+ EE45 CB 7C        .IncrementCircle:	    bit 7,h				; Check for Hl<=0
  88+ EE47 28 03                                jr z,.draw_circle_1
  89+ EE49 19                                   add hl,de			; Delta=Delta+D1
  90+ EE4A 18 05                                jr .draw_circle_2		;
  91+ EE4C 09           .draw_circle_1:		    add hl,bc			; Delta=Delta+D2
  92+ EE4D 03                                   inc bc
  93+ EE4E 03                                   inc bc				; D2=D2+2
  94+ EE4F DD 25                                dec ixh				; Y=Y-1
  95+ EE51 03           .draw_circle_2:		    inc bc				; D2=D2+2
  96+ EE52 03                                   inc bc
  97+ EE53 13                                   inc de				; D1=D1+2
  98+ EE54 13                                   inc de
  99+ EE55 DD 2C                                inc ixl				; X=X+1
 100+ EE57 C3 F7 ED                             jp .CircleLoop
 101+ EE5A D5 C5 E5 F5  .PlotLine:              push	de,,bc,,hl,,af
 102+ EE5E 3E 00        .LineColour:	        ld		a,0         ; circle colur
 103+ EE60 5F                                   ld      e,a
 104+ EE61 CD 5C E4                             call 	l2_draw_horz_line
 105+ EE64 F1 E1 C1 D1                          pop     de,,bc,,hl,,af
 106+ EE68 C9                                   ret
 107+ EE69
 108+ EE69              ; ">l2_draw_clipped_circle HL = Center X 2's c, DE = Center Y 2's , c = radius, b = colour"
 109+ EE69              l2_draw_clipped_circle_filled:
 110+ EE69 78                               ld      a,b                             ; save Colour
 111+ EE6A 32 64 EF                         ld		(.PlotColour+1),a
 112+ EE6D 79                               ld		a,c								; get radius
 113+ EE6E                                  ReturnIfAIsZero
 113+ EE6E A7          >                        and     a
 113+ EE6F C8          >                        ret     z
 114+ EE70                                  JumpIfAEqNusng  1, .circleSinglepixel
 114+ EE70 FE 01       >                        cp     1
 114+ EE72 CA 6A EF    >                        jp      z,.circleSinglepixel
 115+ EE75 ED 53 A2 EE                      ld		(.Plot1Y+1),de					; save origin into DE and HL
 116+ EE79 22 A5 EE                         ld      (.Plot1X+1),hl                  ; .
 117+ EE7C                                  DISPLAY "TODO : IXH and IXL need to be 16 bit and in IX and IY"
 118+ EE7C DD 67                            ld		ixh,a							; ixh = x = raidus
 119+ EE7E DD 2E 00                         ld		ixl,0						    ; ixl = y = error
 120+ EE81 26 00        .calcd:	            ld		h,0                             ; hl = radius
 121+ EE83 6F                               ld		l,a                             ; raidius is still in a at this point
 122+ EE84 29                               add		hl,hl							; hl = r * 2
 123+ EE85 EB                               ex		de,hl							; de = r * 2
 124+ EE86 21 03 00                         ld		hl,3                            ; hl = 3 - (r * 2)
 125+ EE89                                  ClearCarryFlag                          ; .
 125+ EE89 B7          >                        or a
 126+ EE8A ED 52                            sbc		hl,de							; .
 127+ EE8C 44 4D                            ld      bc,hl                           ; bc = 3 - (r * 2)
 128+ EE8E 21 01 00     .calcdelta:         ld		hl,1                            ; hl = 1
 129+ EE91 16 00                            ld		d,0                             ; de = ixl (error)
 130+ EE93 DD 5D                            ld		e,ixl                           ;
 131+ EE95                                  ClearCarryFlag                          ;
 131+ EE95 B7          >                        or a
 132+ EE96 ED 52                            sbc		hl,de                           ; hl = 1 - error
 133+ EE98 11 01 00     .Setde1:            ld		de,1                            ; de = 1
 134+ EE9B              .CircleLoop:        ReturnIfRegLTNusng ixh, ixl             ; if radius > ixl counter
 134+ EE9B DD 7C       >                        ld      a,ixh
 134+ EE9D DD BD       >                        cp      ixl
 134+ EE9F D8          >                        ret	    c
 135+ EEA0 D9           .ProcessLoop:	    exx                                     ; save all bc,de,hl registers
 136+ EEA1              ; For line drawing we can go from left to right in a single call
 137+ EEA1              ;--- from CX-X to CX+X, CY+Y -------------------------------;
 138+ EEA1 11 00 00     .Plot1Y:            ld		de,0                            ; this is Y coord
 139+ EEA4 21 00 00     .Plot1X:            ld      hl,0                            ; this is x coord
 140+ EEA7 E5 D5        .Plot1:             push    hl,,de                          ; push X then Y  on top Stack+2
 141+ EEA9                                  CalcNewPointMacro hl, sbc, ixh          ; hl = CX - X
 141+ EEA9             >                    ClearCarryFlag
 141+ EEA9 B7          >                        or a
 141+ EEAA 06 00       >                    ld      b,0
 141+ EEAC DD 4C       >                    ld      c,ixh
 141+ EEAE ED 42       >                    sbc    hl,bc
 142+ EEB0 EB                               ex      de,hl                           ; de = CX - X
 143+ EEB1 ED 53 D5 EE                      ld      (.LoadDEXStart1+1),de           ; save it for Plot 2 as well
 144+ EEB5                                  CalcNewPointMacro hl, adc, ixl          ; hl = CY + Y
 144+ EEB5             >                    ClearCarryFlag
 144+ EEB5 B7          >                        or a
 144+ EEB6 06 00       >                    ld      b,0
 144+ EEB8 DD 4D       >                    ld      c,ixl
 144+ EEBA ED 4A       >                    adc    hl,bc
 145+ EEBC 06 00                            ld      b,0                             ; Now we have calculated D is bc
 146+ EEBE DD 4C                            ld      c,ixh                           ;
 147+ EEC0                                  ShiftBCLeft1                            ;
 147+ EEC0 CB 21       >			   sla c
 147+ EEC2 CB 10       >			   rl  b
 148+ EEC4 ED 43 D8 EE                      ld      (.LoadBCLength1+1),bc            ; self modifying to optimise laod on line 2
 149+ EEC8 CD 29 EF                         call	.PlotLine               		; de = start X, hl= Y line, bc = length
 150+ EECB E1           .Plot1Done:         pop     hl                              ; Stack+1 get cy from stack into hl to save an ex as we have pre calculated x positions
 151+ EECC              ;--- from CX-X to CX+X, CY-Y -------------------------------;
 152+ EECC E5           .Plot2:             push    hl                              ; Stack+2 put cy back on stack so it holds cy stack already holds cx
 153+ EECD                                  CalcNewPointMacro hl, sbc, ixl          ; now we have CY-Y in hl
 153+ EECD             >                    ClearCarryFlag
 153+ EECD B7          >                        or a
 153+ EECE 06 00       >                    ld      b,0
 153+ EED0 DD 4D       >                    ld      c,ixl
 153+ EED2 ED 42       >                    sbc    hl,bc
 154+ EED4 11 00 00     .LoadDEXStart1:     ld      de,0                            ; de is loaded from above via self modiying code with start X
 155+ EED7 01 00 00     .LoadBCLength1:     ld      bc,0                            ; bc is loaded from above via self modifying code with length
 156+ EEDA CD 29 EF                         call	.PlotLine                       ;
 157+ EEDD D1 E1        .Plot2Done:         pop     hl,,de                          ; Stack+0 now hl = cx, de = cy
 158+ EEDF              ;--- from CX-Y to CX+Y, CY+X -------------------------------;
 159+ EEDF D5           .Plot3:             push    de                              ; Stack + 1 we need cy for final plot calculation
 160+ EEE0                                  CalcNewPointMacro hl, sbc, ixl          ; hl = CX - Y
 160+ EEE0             >                    ClearCarryFlag
 160+ EEE0 B7          >                        or a
 160+ EEE1 06 00       >                    ld      b,0
 160+ EEE3 DD 4D       >                    ld      c,ixl
 160+ EEE5 ED 42       >                    sbc    hl,bc
 161+ EEE7 EB                               ex      de,hl                           ; de = CX - Y
 162+ EEE8 ED 53 0B EF                      ld      (.LoadDEXStart2+1),de             ; save it for Plot 2 as well
 163+ EEEC                                  CalcNewPointMacro hl, adc, ixh          ; hl = CY + X
 163+ EEEC             >                    ClearCarryFlag
 163+ EEEC B7          >                        or a
 163+ EEED 06 00       >                    ld      b,0
 163+ EEEF DD 4C       >                    ld      c,ixh
 163+ EEF1 ED 4A       >                    adc    hl,bc
 164+ EEF3 06 00                            ld      b,0                             ; Now we have calculated D is bc
 165+ EEF5 DD 4D                            ld      c,ixl                           ;
 166+ EEF7                                  ShiftBCLeft1                            ;
 166+ EEF7 CB 21       >			   sla c
 166+ EEF9 CB 10       >			   rl  b
 167+ EEFB ED 43 0E EF                      ld      (.LoadBCLength2+1),bc            ; self modifying to optimise laod on line 2
 168+ EEFF CD 29 EF                         call	.PlotLine               		; de = start X, hl= Y line, bc = length
 169+ EF02 E1           .Plot3Done:         pop     hl                              ; Stack + 0 get cy from stack into hl to save an ex as we have pre calculated x positions
 170+ EF03              ;--- from CX-X to CX+X, CY-Y -------------------------------;
 171+ EF03              .Plot4a:            CalcNewPointMacro hl, sbc, ixh          ; now we have CY-X in hl
 171+ EF03             >                    ClearCarryFlag
 171+ EF03 B7          >                        or a
 171+ EF04 06 00       >                    ld      b,0
 171+ EF06 DD 4C       >                    ld      c,ixh
 171+ EF08 ED 42       >                    sbc    hl,bc
 172+ EF0A 11 00 00     .LoadDEXStart2:     ld      de,0                            ; de is loaded from above via self modiying code with start X
 173+ EF0D 01 00 00     .LoadBCLength2:     ld      bc,0                            ; bc is loaded from above via self modifying code with length
 174+ EF10 CD 29 EF                         call	.PlotLine                       ;
 175+ EF13 D9           .PlotDone:          exx                                     ; get back data from alternate registers
 176+ EF14 CB 7C        .IncrementCircle:	bit     7,h			                  	; Check for Hl<=0
 177+ EF16 28 03                            jr z,   .draw_circle_1
 178+ EF18 19                               add hl,de			                    ; Delta=Delta+D1
 179+ EF19 18 05                            jr      .draw_circle_2		            ;
 180+ EF1B 09           .draw_circle_1:		add     hl,bc		                    ; Delta=Delta+D2
 181+ EF1C 03                               inc     bc
 182+ EF1D 03                               inc     bc			                    ; D2=D2+2
 183+ EF1E DD 25                            dec     ixh			                    ; Y=Y-1
 184+ EF20 03           .draw_circle_2:		inc     bc			                    ; D2=D2+2
 185+ EF21 03                               inc     bc
 186+ EF22 13                               inc     de			                    ; D1=D1+2
 187+ EF23 13                               inc     de
 188+ EF24 DD 2C                            inc     ixl			                    ; X=X+1
 189+ EF26 C3 9B EE                         jp      .CircleLoop
 190+ EF29              ;-- PERFORM THE LINE DRAW ----------------------------------;
 191+ EF29              ; comes in with de = left x , hl = y, bc = length
 192+ EF29              ; Note bc must be +ve < 32768
 193+ EF29              .PlotLine:
 194+ EF29 7C           .IsYOnScreen:       ld      a,h                             ; if y > 255 or < 0 then no line to draw
 195+ EF2A A7                               and     a                               ;
 196+ EF2B C0                               ret     nz                              ;
 197+ EF2C 7D                               ld      a,l                             ;
 198+ EF2D A7                               and     a                               ;
 199+ EF2E F8                               ret     m                               ; if m set then y must be > 127
 200+ EF2F              ;-- now check X coordinate, if X < 256 then skip x position clip
 201+ EF2F 7A           .IsXOffRight:       ld      a,d                             ; if x >255
 202+ EF30 A7                               and     a
 203+ EF31 28 19                            jr      z,.NoLeftClip                   ; if high is not set then no X clip
 204+ EF33              ;-- if X > 255 then off screen so just skip line
 205+ EF33 F0           .LeftClip:          ret     p                               ; if its > 255 then no line
 206+ EF34              ;-- if its off the left then add distance, if this is < 0 then off screen skip
 207+ EF34 E5           .IsTotallyOffLeft:  push    hl                              ; if X pos + length <0 then no line
 208+ EF35 62 6B                            ld      hl,de                           ; .
 209+ EF37                                  ClearCarryFlag                          ; .
 209+ EF37 B7          >                        or a
 210+ EF38              ;    but also this calculation gives us the line length if x is clipped to 90
 211+ EF38 ED 4A                            adc     hl,bc                           ; .
 212+ EF3A 44 4D                            ld      bc,hl                           ; save the result in HL as this is also line length from hl = 0
 213+ EF3C E1                               pop     hl                              ; .
 214+ EF3D F8                               ret     m                               ; if x + distance < 0 then off screen skip
 215+ EF3E              ;-- now as its on screen but clipped x < 0 we can just draw a line from 0 to x+d, maxed at x+d = 255
 216+ EF3E 11 00 00     .ClippedSpanX:      ld      de,0                            ; if off left X = 0, bc already calcualted above in ADC
 217+ EF41 78                               ld      a,b                             ; if bc < 255 then good
 218+ EF42 A7                               and     a
 219+ EF43 CA 60 EF                         jp      z,.NoPopPlotColour              ;
 220+ EF46 01 FF 00                         ld      bc,255                          ; max length
 221+ EF49 C3 60 EF                         jp      .NoPopPlotColour                ; we can now just draw
 222+ EF4C              ;-- No left side clipping needed so we just need to work out if x + d > 255
 223+ EF4C E5           .NoLeftClip:        push    hl                              ; STACK+1 if corrected x + length < 256 then
 224+ EF4D 62 6B                            ld      hl,de                           ; just plot
 225+ EF4F 09                               add     hl,bc
 226+ EF50 7C                               ld      a,h
 227+ EF51 B7                               or      a
 228+ EF52 E1                               pop     hl
 229+ EF53 CA 60 EF                         jp      z,.NoPopPlotColour
 230+ EF56              ;-- x + d > 255 so we plot from x to distance 255 - x
 231+ EF56 E5           .LengthClip:        push    hl
 232+ EF57 21 FF 00                         ld      hl,255
 233+ EF5A                                  ClearCarryFlag
 233+ EF5A B7          >                        or a
 234+ EF5B ED 52                            sbc     hl,de                           ; now hl = corrected length
 235+ EF5D 44 4D                            ld      bc,hl
 236+ EF5F              ;-- This entry point is if there is hl on the stack
 237+ EF5F E1           .PopHLPlotColour:   pop     hl
 238+ EF60 51           .NoPopPlotColour:   ld      d,c             ; d = length
 239+ EF61 4B                               ld      c,e             ; c = start X
 240+ EF62 45                               ld      b,l             ; b = row Y
 241+ EF63 1E 00        .PlotColour:        ld		e,0             ; This was originally indirect, where as it neeed to be value
 242+ EF65 CD 4F E4                         call    l2_draw_horz_dma_bank
 243+ EF68                                  ClearCarryFlag
 243+ EF68 B7          >                        or a
 244+ EF69 C9                               ret
 245+ EF6A 7C           .circleSinglepixel: ld      a,h             ; as its 1 pixel if h or d are non zero then its off screen
 246+ EF6B B2                               or      d
 247+ EF6C C0                               ret     nz
 248+ EF6D CB 7B                            bit     7,e             ; and if Y is > 127 then off screen , bit is 8 states like ld a,e and a
 249+ EF6F C0                               ret     nz
 250+ EF70 78                               ld      a,b             ; a = colour
 251+ EF71 43                               ld      b,e             ; b = y
 252+ EF72 4D                               ld      c,l             ; c = x
 253+ EF73 CD 8E E2                         call    l2_plot_pixel
 254+ EF76 C9                               ret
# file closed: ../../Layer2Graphics/layer2_plot_circle_fill.asm
 670  EF77                  INCLUDE "../../Layer2Graphics/BBCEliteDirectMappingLL118.asm"
# file opened: ../../Layer2Graphics/BBCEliteDirectMappingLL118.asm
   1+ EF77                              IFDEF DEBUG_LL122_DIRECT
   2+ EF77 ~                                    ; (Y X) = (S R) * Q
   3+ EF77 ~                                    ; yxregpair = (20 * 140)/256 = 16d 10h
   4+ EF77 ~            Debug_LL122_6502:       ld      hl, 20
   4+ EF77 ~             ld      (SRvarPair),hl
   5+ EF77 ~                                    ld      a,  140
   5+ EF77 ~             ld      (Qvar),a
   6+ EF77 ~                                    call    LL122_6502  ; -10                               >> PASS
   7+ EF77 ~                                    ;break
   8+ EF77 ~                                    ; yxregpair = 20 * 140 = 17d 11h
   9+ EF77 ~                                    ld      hl, 20
   9+ EF77 ~             ld      (SRvarPair),hl
  10+ EF77 ~                                    ld      a,  230
  10+ EF77 ~             ld      (Qvar),a
  11+ EF77 ~                                    call    LL122_6502  ; -17                               >> PASS
  12+ EF77 ~                                    ret
  13+ EF77                              ENDIF
  14+ EF77
  15+ EF77              ;--  The following calculates: (Y X) = (S R) / Q using the same shift-and-subtract algorithm that's documented in TIS2
  16+ EF77
  17+ EF77                              IFDEF DEBUG_LL121_DIRECT
  18+ EF77 ~                                    ; (Y X) = (S R) / Q
  19+ EF77 ~                                    ; yxregpair = 20 / 140 = 20*256 / 140 = 36d, 24h
  20+ EF77 ~            Debug_LL121_6502:       ld      hl, 20
  20+ EF77 ~             ld      (SRvarPair),hl
  21+ EF77 ~                                    ld      a,  140
  21+ EF77 ~             ld      (Qvar),a
  22+ EF77 ~                                    call    LL121_6502  ; -36                               >> PASS
  23+ EF77 ~                                    ;break
  24+ EF77 ~                                    ; yxregpair =  20 / 140 = 20*256 / 230 = 22d, 11h
  25+ EF77 ~                                    ld      hl, 20
  25+ EF77 ~             ld      (SRvarPair),hl
  26+ EF77 ~                                    ld      a,  230
  26+ EF77 ~             ld      (Qvar),a
  27+ EF77 ~                                    call    LL121_6502  ; -22                               >> PASS
  28+ EF77 ~                                    ;break
  29+ EF77 ~                                    ret
  30+ EF77                              ENDIF
  31+ EF77
  32+ EF77                              IFDEF DEBUG_LL129_DIRECT
  33+ EF77 ~            Debug_LL129_6502:       ld      hl,-20
  33+ EF77 ~             ld     (SRvarPair),hl
  34+ EF77 ~                                    ld      a, 0
  34+ EF77 ~             ld     (XX12p3),a
  35+ EF77 ~                                    ld      a, 10
  35+ EF77 ~             ld     (XX12p2),a
  36+ EF77 ~                                    call    LL129_6502  ; expect q = 10, a = $FF SR = 20    >> PASS
  37+ EF77 ~                                    ;break
  38+ EF77 ~                                    ld      hl,20
  38+ EF77 ~             ld     (SRvarPair),hl
  39+ EF77 ~                                    ld      a, 0
  39+ EF77 ~             ld     (XX12p3),a
  40+ EF77 ~                                    ld      a, 40
  40+ EF77 ~             ld     (XX12p2),a
  41+ EF77 ~                                    call    LL129_6502  ; expect q = 40, a = 00 SR = 20     >> PASS
  42+ EF77 ~                                    ;break
  43+ EF77 ~                                    ld      hl,40
  43+ EF77 ~             ld     (SRvarPair),hl
  44+ EF77 ~                                    ld      a, $FF
  44+ EF77 ~             ld     (XX12p3),a
  45+ EF77 ~                                    ld      a, 40
  45+ EF77 ~             ld     (XX12p2),a
  46+ EF77 ~                                    call    LL129_6502  ; expect q = 40, a = $FF SR = 40    >> PASS
  47+ EF77 ~                                    ;break
  48+ EF77 ~                                    ld      hl,-40
  48+ EF77 ~             ld     (SRvarPair),hl
  49+ EF77 ~                                    ld      a, $FF
  49+ EF77 ~             ld     (XX12p3),a
  50+ EF77 ~                                    ld      a, 40
  50+ EF77 ~             ld     (XX12p2),a
  51+ EF77 ~                                    call    LL129_6502  ; expect q = 40, a = 00 SR = 40     >> PASS
  52+ EF77 ~                                    ;break
  53+ EF77 ~                                    ret
  54+ EF77                              ENDIF
  55+ EF77
  56+ EF77                              IFDEF DEBUG_LL120_DIRECT
  57+ EF77 ~            Debug_LL120_6502:       ld      a,0
  57+ EF77 ~             ld      (Tvar),a                  ; SLOPE 0 so calcualte YX = S X1lo * XX12+2
  58+ EF77 ~                                    ld      hl,20
  58+ EF77 ~             ld a,h
  58+ EF77 ~              ld (Svar),a
  58+ EF77 ~              ld a,l
  58+ EF77 ~              ld (XX1510),a  ; S x1lo = 20
  59+ EF77 ~                                    ld      a,140
  59+ EF77 ~             ld      (XX12p2),a                ; XX12+2  140, gradient 0.546875
  60+ EF77 ~                                    ld      a,0
  60+ EF77 ~             ld      (XX12p3),a                ; SLOPE DIRECTION so -ve result
  61+ EF77 ~                                    ; post LL129 Q = 140 a = 00  SR YX = (20 * 140) /256 * -1 = -10
  62+ EF77 ~                                    call    LL120_6502  ; Expect mulitply so (Y X) -10      >> PASS
  63+ EF77 ~                                    ;break
  64+ EF77 ~                                    ld      a,0
  64+ EF77 ~             ld      (Tvar),a                  ; SLOPE 0 so calcualte YX = S X1lo * XX12+2
  65+ EF77 ~                                    ld      hl,20
  65+ EF77 ~             ld a,h
  65+ EF77 ~              ld (Svar),a
  65+ EF77 ~              ld a,l
  65+ EF77 ~              ld (XX1510),a  ; S x1lo = 20
  66+ EF77 ~                                    ld      a,140
  66+ EF77 ~             ld      (XX12p2),a                ; XX12+2 140, gradient 0.546875
  67+ EF77 ~                                    ld      a,$FF
  67+ EF77 ~             ld      (XX12p3),a                ; sLOPE DIRECTION so +ve result
  68+ EF77 ~                                    ; post LL129 Q = 140 a = FF  SR = 20  YX = (20 * 140) /256 = 10
  69+ EF77 ~                                    call    LL120_6502  ; Expect / so (Y X)10                   >> PASS
  70+ EF77 ~                                    ;break
  71+ EF77 ~                                    ld      a,$FF
  71+ EF77 ~             ld      (Tvar),a                  ; SLOPE <> 0 so calcualte YX = S X1lo / XX12+2
  72+ EF77 ~                                    ld      hl,20
  72+ EF77 ~             ld a,h
  72+ EF77 ~              ld (Svar),a
  72+ EF77 ~              ld a,l
  72+ EF77 ~              ld (XX1510),a  ; S x1lo = 20
  73+ EF77 ~                                    ld      a,140
  73+ EF77 ~             ld      (XX12p2),a                ; XX12+2 140, gradient 0.546875
  74+ EF77 ~                                    ld      a,$00
  74+ EF77 ~             ld      (XX12p3),a                ; sLOPE DIRECTION  so -ve result
  75+ EF77 ~                                    ; post LL129 Q = 140 a = 00  SR = 20  YX = (20 *256 / 140) = -36
  76+ EF77 ~                                    call    LL120_6502  ; Expect / so (Y X)-36
  77+ EF77 ~                                    ld      a,$FF
  77+ EF77 ~             ld      (Tvar),a                  ; SLOPE <> 0 so calcualte YX = S X1lo / XX12+2
  78+ EF77 ~                                    ld      hl,20
  78+ EF77 ~             ld a,h
  78+ EF77 ~              ld (Svar),a
  78+ EF77 ~              ld a,l
  78+ EF77 ~              ld (XX1510),a  ; S x1lo = 20
  79+ EF77 ~                                    ld      a,140
  79+ EF77 ~             ld      (XX12p2),a                ; XX12+2 140, gradient 0.546875
  80+ EF77 ~                                    ld      a,$FF
  80+ EF77 ~             ld      (XX12p3),a                ; sLOPE DIRECTION  so +ve result
  81+ EF77 ~                                    ; post LL129 Q = 140 a = 00 SR = 20 YX = (20 *256 / 140) = 36
  82+ EF77 ~                                    call    LL120_6502  ; Expect / so (Y X)  36                   >> PASS
  83+ EF77 ~                                    ret
  84+ EF77                              ENDIF
  85+ EF77              ;----------------------------------------------------------------------------------------------------------------------------
  86+ EF77              ;-- Calculate the following:
  87+ EF77              ;--         * If T = 0, this is a shallow slope, so calculate (Y X) = (S R) / XX12+2
  88+ EF77              ;--         * If T <> 0, this is a steep slope, so calculate (Y X) = (S R) * XX12+2
  89+ EF77              ;--             giving (Y X) the opposite sign to the slope direction in XX12+3.
  90+ EF77                              IFDEF DEBUG_LL123_DIRECT
  91+ EF77 ~            Debug_LL123_6502:       ld      a,$00
  91+ EF77 ~             ld      (Tvar),a                  ; SLOPE 0 (Y X) = (S R) / XX12+2
  92+ EF77 ~                                    ld      hl,20
  92+ EF77 ~             ld      (SRvarPair),hl
  93+ EF77 ~                                    ld      a,140
  93+ EF77 ~             ld      (XX12p2),a                ; XX12+2 gradient 0.546875
  94+ EF77 ~                                    ld      a,0
  94+ EF77 ~             ld      (XX12p3),a                ; sLOPE DIRECTION
  95+ EF77 ~                                    call    LL123_6502  ; Expect * so (Y X)-36 = (20 / 140 ) * 256 * -1 PASS
  96+ EF77 ~                                    ;break
  97+ EF77 ~                                    ld      a,$00
  97+ EF77 ~             ld      (Tvar),a                  ; SLOPE 0 (Y X) = (S R) / XX12+2
  98+ EF77 ~                                    ld      hl,20
  98+ EF77 ~             ld      (SRvarPair),hl
  99+ EF77 ~                                    ld      a,140
  99+ EF77 ~             ld      (XX12p2),a                ; XX12+2 gradient 0.546875
 100+ EF77 ~                                    ld      a,$FF
 100+ EF77 ~             ld      (XX12p3),a                ; sLOPE DIRECTION
 101+ EF77 ~                                    call    LL123_6502  ; Expect * so (Y X)36 = (20 / 140 ) * 256  PASS
 102+ EF77 ~                                    ;break
 103+ EF77 ~                                    ld      a,$FF
 103+ EF77 ~             ld      (Tvar),a                  ; SLOPE <> 0 (Y X) = (S R) * XX12+2
 104+ EF77 ~                                    ld      hl,20
 104+ EF77 ~             ld      (SRvarPair),hl
 105+ EF77 ~                                    ld      a,140
 105+ EF77 ~             ld      (XX12p2),a                ; XX12+2 gradient 0.546875
 106+ EF77 ~                                    ld      a,$00
 106+ EF77 ~             ld      (XX12p3),a                ; sLOPE DIRECTION
 107+ EF77 ~                                    call    LL123_6502  ; Expect / so (Y X)-10 (20 * 140 ) / 256 * -1 PASS
 108+ EF77 ~                                    ld      a,$FF
 108+ EF77 ~             ld      (Tvar),a                  ; SLOPE <> 0 (Y X) = (S R) * XX12+2
 109+ EF77 ~                                    ld      hl,20
 109+ EF77 ~             ld      (SRvarPair),hl
 110+ EF77 ~                                    ld      a,140
 110+ EF77 ~             ld      (XX12p2),a                ; XX12+2 gradient 0.546875
 111+ EF77 ~                                    ld      a,$FF
 111+ EF77 ~             ld      (XX12p3),a                ; sLOPE DIRECTION
 112+ EF77 ~                                    call    LL123_6502  ; Expect / so (Y X) 10 (20 * 140 ) / 256  PASS
 113+ EF77 ~                                    ret
 114+ EF77                              ENDIF
 115+ EF77
 116+ EF77                              IFDEF DEBUG_LL118_DIRECT
 117+ EF77 ~            Debug_LL118_6502:       ld      a,$FF
 117+ EF77 ~             ld      (Tvar),a                  ; SLOPE FF so steep
 118+ EF77 ~                                    ld      hl,-20
 118+ EF77 ~             ld      (XX1510),hl               ; x1 = -20
 119+ EF77 ~                                    ld      hl,-20
 119+ EF77 ~             ld      (XX1532),hl               ; y1 = -20
 120+ EF77 ~                                    ld      a,120
 120+ EF77 ~             ld      (XX12p2),a                ; XX12+2 = 120 (120/256) = 0.46875
 121+ EF77 ~                                    ld      a,0
 121+ EF77 ~             ld      (XX12p3),a                ; Slope Direction so TL to BR
 122+ EF77 ~                                    ; -20, -20 steep TL>BR, gradient 120/256: Dir -1 so
 123+ EF77 ~                                    call    LL118_6502  ; Expect * so x = 0 y =  -20 + (-20/(120/256)) = 22, x1 = 0 so stop there PASS
 124+ EF77 ~                                    ;break
 125+ EF77 ~
 126+ EF77 ~                                    ld      a,$FF
 126+ EF77 ~             ld      (Tvar),a                  ; SLOPE FF so steep
 127+ EF77 ~                                    ld      hl,-30
 127+ EF77 ~             ld      (XX1510),hl               ; x1 = -20
 128+ EF77 ~                                    ld      hl,-20
 128+ EF77 ~             ld      (XX1532),hl               ; y1 = -20
 129+ EF77 ~                                    ld      a,60
 129+ EF77 ~             ld      (XX12p2),a                ; XX12+2 = 120 (120/256) = 0.46875
 130+ EF77 ~                                    ld      a,0
 130+ EF77 ~             ld      (XX12p3),a                ; Slope Direction so TL to BR
 131+ EF77 ~                                    ; -20, -20 steep TL>BR, gradient 120/256: Dir -1 so
 132+ EF77 ~                                    call    LL118_6502  ; Expect * so 108,0  PASS (fixed carry flag issue in LL121 and re-tested LL121)
 133+ EF77 ~                                    ;break
 134+ EF77 ~
 135+ EF77 ~                                    ld      a,$0
 135+ EF77 ~             ld      (Tvar),a                  ; SLOPE FF so steep
 136+ EF77 ~                                    ld      hl,-20
 136+ EF77 ~             ld      (XX1510),hl               ; x1 = -20
 137+ EF77 ~                                    ld      hl,-20
 137+ EF77 ~             ld      (XX1532),hl               ; y1 = -20
 138+ EF77 ~                                    ld      a,60
 138+ EF77 ~             ld      (XX12p2),a                ; XX12+2 = 120 (120/256) = 0.46875
 139+ EF77 ~                                    ld      a,0
 139+ EF77 ~             ld      (XX12p3),a                ; Slope Direction so TL to BR
 140+ EF77 ~                                    ; -20, -20 steep TL>BR, gradient 120/256: Dir -1 so
 141+ EF77 ~                                    call    LL118_6502  ; Expect * so 108,0  PASS (fixed carry flag issue in LL121 and re-tested LL121)
 142+ EF77 ~                                    ;break
 143+ EF77 ~                                    ret
 144+ EF77 ~
 145+ EF77                              ENDIF
 146+ EF77
 147+ EF77                              IFDEF DEBUG_LL28_6502
 148+ EF77 ~            Debug_LL28_6502:        ld      a,27
 148+ EF77 ~             ld     (Qvar),a
 149+ EF77 ~                                    ld      a,76
 150+ EF77 ~                                    call    LL28_6502   ; Expect $FF carry
 151+ EF77 ~                                    ;break
 152+ EF77 ~                                    ld      a,76
 152+ EF77 ~             ld     (Qvar),a
 153+ EF77 ~                                    ld      a,27        ; Expect 2
 154+ EF77 ~                                    call    LL28_6502
 155+ EF77 ~                                    ;break
 156+ EF77 ~                                    ld      a,200
 156+ EF77 ~             ld     (Qvar),a
 157+ EF77 ~                                    ld      a,50
 158+ EF77 ~                                    call    LL28_6502   ; Expect 4
 159+ EF77 ~                                    ;break
 160+ EF77 ~                                    ld      a,97
 160+ EF77 ~             ld     (Qvar),a
 161+ EF77 ~                                    ld      a,76
 162+ EF77 ~                                    call    LL28_6502   ; Expect 1
 163+ EF77 ~                                    ;break
 164+ EF77 ~                                    ld      a,$20
 164+ EF77 ~             ld     (Qvar),a
 165+ EF77 ~                                    ld      a,$10
 166+ EF77 ~                                    call    LL28_6502   ; Expect 1
 167+ EF77 ~                                    ;break
 168+ EF77 ~                                    ld      d,27
 169+ EF77 ~                                    ld      a,76
 170+ EF77 ~                                    call    AEquAmul256DivD
 171+ EF77 ~                                    ;break
 172+ EF77 ~                                    ld      d,76
 173+ EF77 ~                                    ld      a,27
 174+ EF77 ~                                    call    AEquAmul256DivD
 175+ EF77 ~                                    ;break
 176+ EF77 ~                                    ld      d,200
 177+ EF77 ~                                    ld      a,50
 178+ EF77 ~                                    call    AEquAmul256DivD
 179+ EF77 ~                                    ;break
 180+ EF77 ~                                    ld      d,$20
 181+ EF77 ~                                    ld      a,$10
 182+ EF77 ~                                    call    AEquAmul256DivD
 183+ EF77 ~                                    ;break
 184+ EF77 ~                                    ret
 185+ EF77                              ENDIF
 186+ EF77
 187+ EF77
 188+ EF77                              IFDEF DEBUG_LL145_6502
 189+ EF77 ~            Debug_LL145_6502:       ; ld  a,1      : ld  (UbnkLineArrayLen),a
 190+ EF77 ~                                    ; ld  hl,$0116 : ld  (UbnkLineArray),hl
 191+ EF77 ~                                    ; ld  hl,$004B : ld  (UbnkLineArray+2),hl
 192+ EF77 ~                                    ; ld  hl,$00F8 : ld  (UbnkLineArray+4),hl
 193+ EF77 ~                                    ; ld  hl,$002F : ld  (UbnkLineArray+6),hl
 194+ EF77 ~                                    ; call    DrawLinesLateClipping : ;break
 195+ EF77 ~                                    ; ld  a,1      : ld  (UbnkLineArrayLen),a
 196+ EF77 ~                                    ; ld  hl,$0033 : ld  (UbnkLineArray),hl
 197+ EF77 ~                                    ; ld  hl,$0016 : ld  (UbnkLineArray+2),hl
 198+ EF77 ~                                    ; ld  hl,$001D : ld  (UbnkLineArray+4),hl
 199+ EF77 ~                                    ; ld  hl,$FFBE : ld  (UbnkLineArray+6),hl
 200+ EF77 ~                                    ; call    DrawLinesLateClipping : ;break
 201+ EF77 ~                                    ; ld  a,1      : ld  (UbnkLineArrayLen),a
 202+ EF77 ~                                    ; ld  hl,$0055 : ld  (UbnkLineArray),hl
 203+ EF77 ~                                    ; ld  hl,$FF83 : ld  (UbnkLineArray+2),hl
 204+ EF77 ~                                    ; ld  hl,$0033 : ld  (UbnkLineArray+4),hl
 205+ EF77 ~                                    ; ld  hl,$0016 : ld  (UbnkLineArray+6),hl
 206+ EF77 ~                                    ; call    DrawLinesLateClipping :  ;break
 207+ EF77 ~
 208+ EF77 ~                                    ;ld  a,1      : ld  (UbnkLineArrayLen),a
 209+ EF77 ~                                    ;ld  hl,$00B3 : ld  (UbnkLineArray),hl
 210+ EF77 ~                                    ;ld  hl,$0054 : ld  (UbnkLineArray+2),hl
 211+ EF77 ~                                    ;ld  hl,$005d : ld  (UbnkLineArray+4),hl
 212+ EF77 ~                                    ;ld  hl,$ffd5 : ld  (UbnkLineArray+6),hl
 213+ EF77 ~                                    ;call    DrawLinesLateClipping :  ;break
 214+ EF77 ~                                    ;
 215+ EF77 ~                                    ;ld  a,1      : ld  (UbnkLineArrayLen),a
 216+ EF77 ~                                    ;ld  hl,$005d : ld  (UbnkLineArray),hl
 217+ EF77 ~                                    ;ld  hl,$ffd5 : ld  (UbnkLineArray+2),hl
 218+ EF77 ~                                    ;ld  hl,$00b9 : ld  (UbnkLineArray+4),hl
 219+ EF77 ~                                    ;ld  hl,$0028 : ld  (UbnkLineArray+6),hl
 220+ EF77 ~                                    ;call    DrawLinesLateClipping :  ;break
 221+ EF77 ~
 222+ EF77 ~                                    ld  a,1
 222+ EF77 ~              ld  (UbnkLineArrayLen),a
 223+ EF77 ~                                    ld  hl,$ffc7
 223+ EF77 ~              ld  (UbnkLineArray),hl
 224+ EF77 ~                                    ld  hl,$001a
 224+ EF77 ~              ld  (UbnkLineArray+2),hl
 225+ EF77 ~                                    ld  hl,$005d
 225+ EF77 ~              ld  (UbnkLineArray+4),hl
 226+ EF77 ~                                    ld  hl,$ffd5
 226+ EF77 ~              ld  (UbnkLineArray+6),hl
 227+ EF77 ~                                    call    DrawLinesLateClipping
 227+ EF77 ~               ;break
 228+ EF77 ~
 229+ EF77 ~                                    ;ld  a,1      : ld  (UbnkLineArrayLen),a
 230+ EF77 ~                                    ;ld  hl,$0089 : ld  (UbnkLineArray),hl
 231+ EF77 ~                                    ;ld  hl,$00e2 : ld  (UbnkLineArray+2),hl
 232+ EF77 ~                                    ;ld  hl,$fff3 : ld  (UbnkLineArray+4),hl
 233+ EF77 ~                                    ;ld  hl,$00b9 : ld  (UbnkLineArray+6),hl
 234+ EF77 ~                                    ;call    DrawLinesLateClipping :  ;break
 235+ EF77 ~
 236+ EF77 ~                                    ret
 237+ EF77                              ENDIF
 238+ EF77                      DEFINE DEBUG_6502_LINE_CLIPPING
 239+ EF77                      IFDEF DEBUG_6502_LINE_CLIPPING
 240+ EF77
 241+ EF77 00           xX13        DB 0
 242+ EF78 00 00        XX1510      DW 0    ; x1 as a 16-bit coordinate (x1_hi x1_lo)
 243+ EF7A 00 00        XX1532      DW 0    ; y1 as a 16-bit coordinate (y1_hi y1_lo)
 244+ EF7C 00 00        XX1554      DW 0    ; x2
 245+ EF7E              XX1554p1    EQU XX1554+1
 246+ EF7E 00 00        XX1576      DW 0    ; y2
 247+ EF80              XX1210      EQU XX1576
 248+ EF80              XX12p1      EQU XX1210+1
 249+ EF80              XX15X1lo    EQU XX1510
 250+ EF80              XX15X1hi    EQU XX1510+1
 251+ EF80              XX15Y1lo    EQU XX1532
 252+ EF80              XX15Y1hi    EQU XX1532+1
 253+ EF80              XX15X2lo    EQU XX1554
 254+ EF80              XX15X2hi    EQU XX1554+1
 255+ EF80              XX15Y2lo    EQU XX1210
 256+ EF80              XX15Y2hi    EQU XX1210+1
 257+ EF80
 258+ EF80 00           XX12p2      DB 0    ; The line's gradient * 256 (so 1.0 = 256)
 259+ EF81 00           XX12p3      DB 0    ; The direction of slope ; + LT to BR; - TR to BL
 260+ EF82 00           XX12p4      DB 0
 261+ EF83 00           XX12p5      DB 0
 262+ EF84              Delta_x     EQU XX12p2
 263+ EF84              Delta_y     EQU XX12p4
 264+ EF84 00           Tvar        DB 0    ; The gradient of slope ; 0 if it's a shallow slope (DX > DY) ; &FF if it's a steep slope (DY > DX)
 265+ EF85                                  ; Returns:  XX15        m         x1 as an 8-bit coordinate XX15+2               y1 as an 8-bit coordinate
 266+ EF85 00           Qvar        DB 0
 267+ EF86 00           Rvar        DB 0    ; general purpose for calcs  Paired with S must be done this way round for SUBHeightFromY1 etc to work
 268+ EF87 00           Svar        DB 0    ; sign variable
 269+ EF88              SRvarPair   EQU Rvar
 270+ EF88 00           Xreg        DB 0
 271+ EF89 00           Yreg        DB 0
 272+ EF8A              YXregPair   EQU Xreg
 273+ EF8A
 274+ EF8A              ;-- Name: LL28 Calculate R = 256 * A / Q
 275+ EF8A              ;-- LL28+4              Skips the A >= Q check and always returns with C flag cleared, so this can be called if we know the division will work
 276+ EF8A              ;-- LL31                Skips the A >= Q check and does not set the R counter, so this can be used for jumping straight into the division loop if R is already set to 254 and we know the division will work
 277+ EF8A              ;   Reg mapping 6502  Z80
 278+ EF8A              ;               a     a
 279+ EF8A              ;               b     x
 280+ EF8A              ;               c     q
 281+ EF8A              ;               d     r
 282+ EF8A              ;
 283+ EF8A 21 85 EF     LL28_6502:          ld      hl,Qvar                 ; CMP Q                  \ If A >= Q, then the answer will not fit in one byte,
 284+ EF8D 4E                               ld      c,(hl)                  ; using c as Q var
 285+ EF8E B9                               cp      c
 286+ EF8F                                  FlipCarryFlag
 286+ EF8F 3F          >                        ccf
 287+ EF90 DA B8 EF                         jp      c, LL2_6502             ; BCS LL2                \ so jump to LL2 to return 255
 288+ EF93 06 FE                            ld      b,$FE                   ; LDX #%11111110         \ Set R to have bits 1-7 set, so we can rotate through 7 loop iterations, getting a 1 each time, and then we use b as Rvar
 289+ EF95 CB 27        LL31_6502:          sla     a                       ; ASL A                  \ Shift A to the left
 290+ EF97 DA AC EF                         jp      c,LL29_6502             ; BCS LL29               \ If bit 7 of A was set, then jump straight to the subtraction
 291+ EF9A                                  FlipCarryFlag                   ;                          If A < N, then C flag is set.
 291+ EF9A 3F          >                        ccf
 292+ EF9B                                  JumpIfALTNusng c, LL31_SKIPSUB_6502 ; CMP Q              \ If A < Q, skip the following subtraction
 292+ EF9B B9          >                        cp      c
 292+ EF9C DA A1 EF    >                        jp		c, LL31_SKIPSUB_6502
 293+ EF9F                                                                  ; BCC P%+4
 294+ EF9F 91                               sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
 295+ EFA0                                  ClearCarryFlag
 295+ EFA0 B7          >                        or a
 296+ EFA1              LL31_SKIPSUB_6502:  FlipCarryFlag
 296+ EFA1 3F          >                        ccf
 297+ EFA2 CB 10                            rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
 298+ EFA4 DA 95 EF                         jp      c, LL31_6502            ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
 299+ EFA7 78                               ld      a,b
 300+ EFA8 32 86 EF                         ld      (Rvar),a
 301+ EFAB C9                               ret                             ; RTS                    \ R left with remainder of division
 302+ EFAC 91           LL29_6502:          sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
 303+ EFAD                                  SetCarryFlag                    ; SEC                    \ Set the C flag to rotate into the result in R
 303+ EFAD 37          >                        scf
 304+ EFAE CB 10                            rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
 305+ EFB0 DA 95 EF                         jp      c, LL31_6502            ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
 306+ EFB3 78                               ld      a,b                     ; RTS                    \ Return from the subroutine with R containing the
 307+ EFB4 32 86 EF                         ld      (Rvar),a                ; .
 308+ EFB7 C9                               ret                             ; .                      \ remainder of the division
 309+ EFB8 3E FF        LL2_6502:           ld      a,$FF                   ; LDA #255               \ The division is very close to 1, so return the closest
 310+ EFBA 32 86 EF                         ld      (Rvar),a                ; STA R                  \ possible answer to 256, i.e. R = 255
 311+ EFBD                                  SetCarryFlag                    ; we failed so need carry flag set
 311+ EFBD 37          >                        scf
 312+ EFBE C9                               ret                             ; RTS                    \ Return from the subroutine
 313+ EFBF
 314+ EFBF 3A 88 EF     ADDXRegtoY1:        ld      a,(Xreg)                ; Set y1 = y1 + (Y X)
 315+ EFC2 4F                               ld      c,a
 316+ EFC3 06 00                            ld      b,0
 317+ EFC5 2A 7A EF                         ld      hl,(XX1532)
 318+ EFC8                                  ClearCarryFlag
 318+ EFC8 B7          >                        or a
 319+ EFC9 ED 4A                            adc     hl,bc
 320+ EFCB 22 7A EF                         ld      (XX1532),hl
 321+ EFCE C9                               ret
 322+ EFCF
 323+ EFCF ED 4B 88 EF  ADDYXRegtoY1:       ld      bc,(YXregPair)          ; Set y1 = y1 + (Y X)
 324+ EFD3 2A 7A EF                         ld      hl,(XX1532)
 325+ EFD6                                  ClearCarryFlag
 325+ EFD6 B7          >                        or a
 326+ EFD7 ED 4A                            adc     hl,bc
 327+ EFD9 22 7A EF                         ld      (XX1532),hl
 328+ EFDC C9                               ret
 329+ EFDD
 330+ EFDD ED 4B 88 EF  ADDYXRegtoX1:       ld      bc,(YXregPair)          ; Set x1 = x1 + (Y X)
 331+ EFE1 2A 78 EF                         ld      hl,(XX1510)
 332+ EFE4                                  ClearCarryFlag
 332+ EFE4 B7          >                        or a
 333+ EFE5 ED 4A                            adc     hl,bc
 334+ EFE7 22 78 EF                         ld      (XX1510),hl
 335+ EFEA C9                               ret
 336+ EFEB
 337+ EFEB 2A 7A EF     SUBBCFromY1:        ld      hl,(XX1532)             ; Set (S R) = (y1_hi y1_lo) - BC where BC can be say screen height
 338+ EFEE                                  ClearCarryFlag
 338+ EFEE B7          >                        or a
 339+ EFEF ED 42                            sbc     hl,bc
 340+ EFF1 22 86 EF                         ld      (SRvarPair),hl
 341+ EFF4 C9                               ret
 342+ EFF5
 343+ EFF5 2A 88 EF     AddSRToYX:          ld      hl,(YXregPair)
 344+ EFF8 ED 5B 86 EF                      ld      de,(SRvarPair)
 345+ EFFC                                  ClearCarryFlag
 345+ EFFC B7          >                        or a
 346+ EFFD ED 5A                            adc     hl,de
 347+ EFFF 22 88 EF                         ld      (YXregPair),hl
 348+ F002 C9                               ret
 349+ F003
 350+ F003
 351+ F003
 352+ F003 7C           ClampX:             ld      a,h
 353+ F004 A7                               and     a
 354+ F005 7D                               ld      a,l
 355+ F006 C8                               ret     z
 356+ F007 F2 0C F0                         jp      p,.Max255
 357+ F00A              .Min0:              ZeroA
 357+ F00A AF          >                        xor a
 358+ F00B C9                               ret
 359+ F00C 3E FF        .Max255:            ld      a,$FF
 360+ F00E C9                               ret
 361+ F00F
 362+ F00F 7C           ClampY:             ld      a,h
 363+ F010 A7                               and     a
 364+ F011 CA 1C F0                         jp      z,.ClampYlo
 365+ F014 F2 19 F0                         jp      p,.Max127
 366+ F017              .Min0:              ZeroA
 366+ F017 AF          >                        xor a
 367+ F018 C9                               ret
 368+ F019 3E 7F        .Max127:            ld      a,127
 369+ F01B C9                               ret
 370+ F01C 7D           .ClampYlo:          ld      a,l
 371+ F01D A7                               and     a
 372+ F01E F0                               ret     p
 373+ F01F 3E 7F                            ld      a,127
 374+ F021 C9                               ret
 375+ F022
 376+ F022              ;-- Rountes to code:
 377+ F022              ;-- LL118
 378+ F022              ;-- LL120   Done
 379+ F022              ;-- LL129   Done
 380+ F022              ;-- LL123   Done
 381+ F022                              ; NOTE DOES ABS ONLY
 382+ F022
 383+ F022
 384+ F022                              ;--- LL118 Move along a point until on screen
 385+ F022              ; In XX1510 x1 as a 16-bit coordinate (x1_hi x1_lo)
 386+ F022              ;    XX1532 y1 as a 16-bit coordinate (y1_hi y1_lo)
 387+ F022              ;    XX12p2 The line's gradient * 256 (so 1.0 = 256)
 388+ F022              ;    XX12p3 The direction of slope: * Positive = top left to bottom right * Negative (bit 7 set) = top right to bottom left
 389+ F022              ;    T      The gradient of slope:* 0 if it's a shallow slope * &FF if it's a steep slope
 390+ F022              ;  Out  XX150               x1 as an 8-bit coordinate
 391+ F022              ;       XX152               y1 as an 8-bit coordinate
 392+ F022              ;----------------------------------------------------------------------------------------------------------------
 393+ F022
 394+ F022
 395+ F022              ;---------------------------------------------------------------------------------------------------------------------
 396+ F022              ;--  Calculate the following:
 397+ F022              ;--   * If T = 0, this is a shallow slope, so calculate (Y X) = (S x1_lo) * XX12+2
 398+ F022              ;--   * If T <> 0, this is a steep slope, so calculate (Y X) = (S x1_lo) / XX12+2
 399+ F022              ;-- giving (Y X) the opposite sign to the slope direction in XX12+3.
 400+ F022              ;---------------------------------------------------------------------------------------------------------------------
 401+ F022 3A 78 EF     LL120_6502:         ld      a,(XX1510)              ;LDA XX15               \ Set R = x1_lo
 402+ F025 32 86 EF                         ld      (Rvar),a                ;STA R
 403+ F028 CD D4 F0                         call    LL129_6502              ;JSR LL129              \ Call LL129 to do the following:  Q = XX12+2 = line gradient, A = S EOR XX12+3 = S EOR slope direction  (S R) = |S R|
 404+ F02B F5                               push    af                      ;PHA                    \ Store A on the stack so we can use it later
 405+ F02C              ; DONT NEED PLUS MESSES UP FLAGS                    push    af                      ;LDX T                  \ If T is non-zero, then it's a steep slope, so jump
 406+ F02C 3A 84 EF                         ld      a,(Tvar)                ; .
 407+ F02F 32 88 EF                         ld      (Xreg),a                ;. REDUNDANT REMOVE IN OPTIMISATION
 408+ F032 A7                               and     a                       ;BNE LL121              \ down to LL121 to calculate this instead (Y X) = (S R) / Q
 409+ F033              ; DONT NEED PLUS MESSES UP FLAGS                    pop     af                      ;.                      (recover teh saved A before the cp)
 410+ F033 20 48                            jr      nz,LL121_6502           ;.
 411+ F035              ;..   (Y X) = (S R) * Q - must be ABS, sign determined by opposite of the sign of the value on top of stack
 412+ F035              LL122_6502:         ZeroA                           ;LDA #0                 \ Set A = 0
 412+ F035 AF          >                        xor a
 413+ F036                          IFDEF DEBUG_LL122_DIRECT
 414+ F036 ~                                DISPLAY "DIRECT CALL TO LL122 so dummy push a to stack with 0"
 415+ F036 ~                                push    af
 416+ F036                          ENDIF
 417+ F036 32 88 EF                         ld      (Xreg),a                ;TAX                    \ Set (Y X) = 0 so we can start building the answer here
 418+ F039 32 89 EF                         ld      (Yreg),a                ;TAY
 419+ F03C 21 87 EF                         ld      hl,Svar
 420+ F03F ED 4B 86 EF                      ld      bc,(SRvarPair)          ;LSR S                  \ Shift (S R) to the right, so we extract bit 0 of (S R)
 421+ F043                                  ShiftBCRight1                   ;ROR R                  \ into the C flag
 421+ F043 CB 38       >			   srl b
 421+ F045 CB 19       >			   rr  c
 422+ F047 ED 43 86 EF                      ld      (SRvarPair),bc
 423+ F04B 21 85 EF                         ld      hl, Qvar                ;ASL Q                  \ Shift Q to the left, catching bit 7 in the C flag
 424+ F04E CB 26                            sla     (hl)                    ;.
 425+ F050 30 03                            jr      nc, LL126_6502          ;BCC LL126              \ If C (i.e. the next bit from Q) is clear, do not do
 426+ F052                                                                  ;                         the addition for this bit of Q, and instead skip to LL126 to just do the shifts
 427+ F052 CD F5 EF     LL125_6502:         call    AddSRToYX               ;TXA                    \ Set (Y X) = (Y X) + (S R)  starting with the low bytes And then doing the high bytes
 428+ F055 ED 4B 86 EF  LL126_6502:         ld      bc,(SRvarPair)          ;LSR S                  \ Shift (S R) to the right
 429+ F059                                  ShiftBCRight1                   ;ROR R
 429+ F059 CB 38       >			   srl b
 429+ F05B CB 19       >			   rr  c
 430+ F05D ED 43 86 EF                      ld      (SRvarPair),bc          ;.
 431+ F061 21 85 EF                         ld      hl, Qvar                ;ASL Q                  \ Shift Q to the left, catching bit 7 in the C flag
 432+ F064 CB 26                            sla     (hl)                    ;.
 433+ F066 38 EA                            jr      c,LL125_6502            ;BCS LL125              \ If C (i.e. the next bit from Q) is set, loop back to LL125 to do the addition for this bit of Q
 434+ F068 20 EB                            jr      nz,LL126_6502           ;BNE LL126              \ If Q has not yet run out of set bits, loop back to LL126 to do the "shift" part of shift-and-add until we have done additions for all the set bits in Q, to give us our multiplication result
 435+ F06A F1                               pop     af                      ;PLA                    \ Restore A, which we calculated above, from the stack
 436+ F06B A7                               and     a                       ;BPL LL133              \ If A is positive jump to LL133 to negate (Y X) and
 437+ F06C F2 C5 F0                         jp      p,LL133_6502            ;.
 438+ F06F              ;.. return from the subroutine using a tail call
 439+ F06F C9                               ret                             ;RTS                    \ Return from the subroutine
 440+ F070
 441+ F070              ;----------------------------------------------------------------------------------------------------------------------------
 442+ F070              ;-- Calculate the following:
 443+ F070              ;--         * If T = 0, this is a shallow slope, so calculate (Y X) = (S R) / XX12+2 (does not use X1lo but directly SR)
 444+ F070              ;--         * If T <> 0, this is a steep slope, so calculate (Y X) = (S R) * XX12+2  (does not use X1lo but directly SR)
 445+ F070              ;--             giving (Y X) the opposite sign to the slope direction in XX12+3.
 446+ F070 CD D4 F0     LL123_6502:         call    LL129_6502              ;JSR LL129              \ Call LL129 to do the following   Q = XX12+2   = line gradient
 447+ F073 F5                               push    af                      ;PHA                    \ Store A on the stack so we can use it later
 448+ F074              ; DONT NEED PLUS MESSES UP FLAGS                    push    af                      ;LDX T                  \ If T is non-zero, then it's a steep slope, so jump up
 449+ F074 3A 84 EF                         ld      a,(Tvar)                ; .
 450+ F077 32 88 EF                         ld      (Xreg),a                ;BNE LL122              \ to LL122 to calculate this instead:
 451+ F07A A7                               and     a                       ;.
 452+ F07B              ;  DONT NEED PLUS MESSES UP FLAGS                    pop     af                      ;.
 453+ F07B 20 B8                            jr      nz,LL122_6502           ;.
 454+ F07D              ;--  The following calculates: (Y X) = (S R) / Q using the same shift-and-subtract algorithm that's documented in TIS2
 455+ F07D 3E FF        LL121_6502:         ld      a,$FF                   ;LDA #%11111111         \ Set Y = %11111111
 456+ F07F 32 89 EF                         ld      (Yreg),a                ;TAY
 457+ F082 CB 27                            sla     a                       ;ASL A                  \ Set X = %11111110
 458+ F084 32 88 EF                         ld      (Xreg),a                ;TAX
 459+ F087              ;--  This sets (Y X) = %1111111111111110, so we can rotate through 15 loop iterations, getting a 1 each time, and then getting a 0 on the 16th iteration... and we can also use it to catch our result bits into bit 0 each time
 460+ F087 ED 4B 86 EF  LL130_6502:         ld      bc,(SRvarPair)          ;ASL R                  \ Shift (S R) to the left
 461+ F08B                                  ShiftBCLeft1                    ;.
 461+ F08B CB 21       >			   sla c
 461+ F08D CB 10       >			   rl  b
 462+ F08F ED 43 86 EF                      ld      (SRvarPair),bc          ;ROL S
 463+ F093 3A 87 EF                         ld      a,(Svar)                ;LDA S                  \ Set A = S
 464+ F096 38 07                            jr      c, LL131_6502           ;BCS LL131              \ If bit 7 of S was set, then jump straight to the subtraction
 465+ F098 21 85 EF                         ld      hl,Qvar                 ;CMP Q                  \ If A < Q (i.e. S < Q), skip the following subtractions
 466+ F09B BE                               cp      (hl)
 467+ F09C                                  FlipCarryFlag                   ; note flip carry flag here to simulate 6502 operation
 467+ F09C 3F          >                        ccf
 468+ F09D 30 12                            jr      nc,LL132A_6502          ;BCC LL132  (NOTE Carry flag reversed in Z80 for CP)
 469+ F09F              LL131_6502:         FlipCarryFlag                   ;flip carry to make it act like a 6502 borrow
 469+ F09F 3F          >                        ccf
 470+ F0A0 9E                               sbc     (hl)                    ;SBC Q                  \ A >= Q (i.e. S >= Q) so set:
 471+ F0A1 32 87 EF                         ld      (Svar),a                ;STA S
 472+ F0A4 3A 86 EF                         ld      a,(Rvar)                ;LDA R                  \ And then doing the high bytes
 473+ F0A7                                  ClearCarryFlag                  ;\   S = (A R) - Q  = (S R) - Q starting with the low bytes (we know the C flag is set so the subtraction will be correct)
 473+ F0A7 B7          >                        or a
 474+ F0A8 DE 00                            sbc     0                       ;SBC #0
 475+ F0AA 32 86 EF                         ld      (Rvar),a                ;STA R
 476+ F0AD                                  SetCarryFlag                    ;SEC                    \ Set the C flag to rotate into the result in (Y X)
 476+ F0AD 37          >                        scf
 477+ F0AE C3 B2 F0                         jp      LL132_6502              ;added so that we can do a 6502 style carry above
 478+ F0B1 00           LL132A_6502:        nop; FlipCarryFlag
 479+ F0B2 ED 4B 88 EF  LL132_6502:         ld      bc,(YXregPair)          ; Rotate the counter in (Y X) to the left, and catch the
 480+ F0B6                                  RollBCLeft1                     ; ROL A                  \ result bit into bit 0 (which will be a 0 if we didn't
 480+ F0B6 CB 11       >               rl  c
 480+ F0B8 CB 10       >               rl  b
 481+ F0BA ED 43 88 EF                      ld      (YXregPair),bc          ; TAX                    \ do the subtraction, or 1 if we did)
 482+ F0BE 38 C7                            jr      c, LL130_6502           ; BCS LL130              \ If we still have set bits in (Y X), loop back to LL130 to do the next iteration of 15, until we have done the whole division
 483+ F0C0                          IFDEF DEBUG_LL121_DIRECT
 484+ F0C0 ~                                DISPLAY "DIRECT CALL TO LL121 so dummy push"
 485+ F0C0 ~                                push    af
 486+ F0C0                          ENDIF
 487+ F0C0 F1                               pop     af                      ; PLA                    \ Restore A, which we calculated above, from the stack
 488+ F0C1 A7                               and     a                       ; BMI LL128              \ If A is negative jump to LL128 to return from the
 489+ F0C2 FA D3 F0                         jp      m, LL128_6502           ; .                      \ subroutine with (Y X) as is
 490+ F0C5 ED 4B 88 EF  LL133_6502:         ld      bc,(YXregPair)          ; TXA                    \ Otherwise negate (Y X) using two's complement by first
 491+ F0C9                                  macronegate16bc                 ; EOR #%11111111         \ setting the low byte to ~X + 1
 491+ F0C9 AF          >					xor 	a
 491+ F0CA 91          >                    sub 	c
 491+ F0CB 4F          >                    ld 		c,a
 491+ F0CC 9F          >                    sbc 	a,a
 491+ F0CD 90          >                    sub 	b
 491+ F0CE 47          >                    ld 		b,a
 492+ F0CF ED 43 88 EF                      ld      (YXregPair),bc          ; ADC #1                 \ The addition works as we know the C flag is clear from\ when we passed through the BCS above
 493+ F0D3 C9           LL128_6502:         ret                             ; RTS                    \ Return from the subroutine
 494+ F0D4              ;-------------------------------------------------------------------------------------------------------
 495+ F0D4              ;..  Do the following, in this order: Q = XX12+2 A = S EOR XX12+3 (S R) = |S R|
 496+ F0D4              ;..  This sets up the variables required above to calculate (S R) / XX12+2 and give the result the opposite sign to XX13+3.
 497+ F0D4 F5           LL129_6502:         push    af                      ;LDX XX12+2             \ Set Q = XX12+2
 498+ F0D5 3A 80 EF                         ld      a,(XX12p2)              ;.
 499+ F0D8 32 88 EF                         ld      (Xreg),a                ;.
 500+ F0DB 32 85 EF                         ld      (Qvar),a                ;STX Q
 501+ F0DE F1                               pop     af                      ;.
 502+ F0DF 3A 87 EF                         ld      a,(Svar)                ;LDA S                  \ If S is positive, jump to LL127
 503+ F0E2 A7                               and     a                       ;BPL LL127
 504+ F0E3 F2 FB F0                         jp      p,LL127_6502            ;.
 505+ F0E6                                  ZeroA                           ;.LDA #0                \ Otherwise set R = -R
 505+ F0E6 AF          >                        xor a
 506+ F0E7                                  ClearCarryFlag                  ;SEC
 506+ F0E7 B7          >                        or a
 507+ F0E8 21 86 EF                         ld      hl, Rvar                ;SBC R
 508+ F0EB 9E                               sbc     (hl)                    ;.
 509+ F0EC 32 86 EF                         ld      (Rvar),a                ;STA R
 510+ F0EF 3A 87 EF                         ld      a,(Svar)                ;LDA S                  \ Push S onto the stack
 511+ F0F2 F5                               push    af                      ;PHA
 512+ F0F3 EE FF                            xor     $FF                     ;EOR #%11111111         \ Set S = ~S + 1 + C  ?? is this all just doing |Svar|?
 513+ F0F5 CE 00                            adc     0                       ;ADC #0
 514+ F0F7 32 87 EF                         ld      (Svar),a                ;STA S
 515+ F0FA F1                               pop     af                      ;PLA                    \ Pull the original, negative S from the stack into A
 516+ F0FB 21 81 EF     LL127_6502:         ld      hl,XX12p3               ;EOR XX12+3             \ Set A = original argument S EOR'd with XX12+3
 517+ F0FE AE                               xor     (hl)                    ;.
 518+ F0FF C9                               ret                             ;RTS                    \ Return from the subroutine
 519+ F100              ;----------------------------------------------------------------------------------------------------------------
 520+ F100              ;--- LL118 Move along a point until on screen
 521+ F100              ; In XX1510 x1 as a 16-bit coordinate (x1_hi x1_lo)
 522+ F100              ;    XX1532 y1 as a 16-bit coordinate (y1_hi y1_lo)
 523+ F100              ;    XX12p2 The line's gradient * 256 (so 1.0 = 256)
 524+ F100              ;    XX12p3 The direction of slope: * Positive = top left to bottom right * Negative (bit 7 set) = top right to bottom left
 525+ F100              ;    T      The gradient of slope:* 0 if it's a shallow slope * &FF if it's a steep slope
 526+ F100              ;  Out  XX150               x1 as an 8-bit coordinate
 527+ F100              ;       XX152               y1 as an 8-bit coordinate
 528+ F100              ;----------------------------------------------------------------------------------------------------------------
 529+ F100
 530+ F100 3A 79 EF     LL118_6502:         ld      a,(XX1510+1)            ; LDA XX15+1             \ If x1_hi is positive, jump down to LL119 to skip the
 531+ F103 A7                               and     a                       ; BPL LL119              \ .
 532+ F104 F2 21 F1                         jp      p, LL119_6502           ;                        \ following
 533+ F107 32 87 EF     .X1Negative:        ld      (Svar),a                ; STA S                  \ Otherwise x1_hi is negative, i.e. off the left of the screen, so set S = x1_hi
 534+ F10A CD 22 F0                         call    LL120_6502              ; Call LL120 to calculate:  (Y X) = (S x1_lo) * XX12+2      if T = 0   = x1 * gradient
 535+ F10D                                                                  ;                            (Y X) = (S x1_lo) / XX12+2      if T <> 0  = x1 / gradient
 536+ F10D                                                                  ; with the sign of (Y X) set to the opposite of the line's direction of slope
 537+ F10D CD CF EF                         call    ADDYXRegtoY1             ; Set y1 = y1 + (Y X)
 538+ F110 22 7A EF                         ld      (XX1532),hl             ; .
 539+ F113 21 00 00                         ld      hl,0                    ; Set x1 = 0
 540+ F116 22 78 EF                         ld      (XX1510),hl             ; .
 541+ F119 3E 00                            ld      a,0                     ; set 0 up for replacemetn of the TAX and BEQ bit
 542+ F11B 32 88 EF                         ld      (Xreg),a                ; TAX                    \ Set X = 0 so the next BEQ becomes a jmp but we will do it anyway in next line
 543+ F11E C3 37 F1                         jp      LL134_6502              ; just do the jump to LL134 rather than setting to equal flag and then jumping
 544+ F121              ;-- Entering LL119 a will always be the value of X1 Hi byte
 545+ F121 CA 37 F1     LL119_6502:         jp      z,LL134_6502            ; BEQ LL134              \ x1_hi = 0 then jump down to LL134 to skip the following, as the x-coordinate is already on-screen
 546+ F124                                                                  ;                        \ (as 0 <= (x_hi x_lo) <= 255)
 547+ F124 32 87 EF                         ld      (Svar),a                ; STA S                  \ Otherwise x1_hi is positive, i.e. x1 >= 256 and off
 548+ F127 3D                               dec     a                       ; DEC S                  \ the right side of the screen, so set S = x1_hi - 1
 549+ F128 32 87 EF                         ld      (Svar),a                ;
 550+ F12B CD 22 F0                         call    LL120_6502              ; JSR LL120              \ Call LL120 to calculate:  (Y X) = (S x1_lo) * XX12+2      if T = 0   = (x1 - 256) * gradient
 551+ F12E                                                                  ;                        \                           (Y X) = (S x1_lo) / XX12+2      if T <> 0 = (x1 - 256) / gradient
 552+ F12E                                                                  ;                        \ with the sign of (Y X) set to the opposite of the line's direction of slope
 553+ F12E CD CF EF                         call    ADDYXRegtoY1             ; TXA                    \ Set y1 = y1 + (Y X)
 554+ F131 21 FF 00                         ld      hl,255                  ; LDX #255               \ Set x1 = 255
 555+ F134 22 78 EF                         ld      (XX1510),hl             ; STX XX15 ;INX; STX XX15+1
 556+ F137              ;--  We have moved the point so the x-coordinate is on  screen (i.e. in the range 0-255), so now for the  y-coordinate
 557+ F137 3A 7B EF     LL134_6502:         ld      a,(XX1532+1)            ; LDA XX15+3             \ If y1_hi is positive, jump down to LL119 to skip
 558+ F13A A7                               and     a                       ; BPL LL135              \ the following
 559+ F13B F2 53 F1                         jp      p, LL135_6502           ; .
 560+ F13E 32 87 EF                         ld      (Svar),a                ; STA S                  \ Otherwise y1_hi is negative, i.e. off the top of the screen, so set S = y1_hi
 561+ F141 3A 7A EF                         ld      a, (XX1532)             ; LDA XX15+2             \ Set R = y1_lo
 562+ F144 32 86 EF                         ld      (Rvar),a                ; STA R
 563+ F147 CD 70 F0                         call    LL123_6502              ; JSR LL123              \ Call LL123 to calculate:  (Y X) = (S R) / XX12+2      if T = 0 = y1 / gradient
 564+ F14A                                                                  ;                        \                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
 565+ F14A                                                                  ;                         with the sign of (Y X) set to the opposite of the line's direction of slope
 566+ F14A CD DD EF                         call    ADDYXRegtoX1            ; TXA                    \ Set x1 = x1 + (Y X)
 567+ F14D 21 00 00                         ld      hl,0                    ; LDA #0                 \ Set y1 = 0
 568+ F150 22 7A EF                         ld      (XX1532),hl             ; STA XX15+2, XX15+3
 569+ F153 01 80 00     LL135_6502:         ld      bc,128                  ; LDA XX15+2             \ Set (S R) = (y1_hi y1_lo) - screen height
 570+ F156 CD EB EF                         call    SUBBCFromY1             ; .                      \ .
 571+ F159 38 0C                            jr      c, LL136_6502           ; BCC LL136              \ If the subtraction underflowed, i.e. if y1 < screen height, then y1 is already on-screen, so jump to LL136
 572+ F15B                                                                  ;                        \ to return from the subroutine, as we are done
 573+ F15B              ;;-   If we get here then y1 >= screen height, i.e. off the bottom of the screen
 574+ F15B CD 70 F0     LL139_6502:         call    LL123_6502              ; JSR LL123              \ Call LL123 to calculate:   (Y X) = (S R) / XX12+2      if T = 0  = (y1 - screen height) / gradient
 575+ F15E                                                                  ;                        \                            (Y X) = (S R) * XX12+2      if T <> 0 = (y1 - screen height) * gradient
 576+ F15E                                                                  ;                          with the sign of (Y X) set to the opposite of the line's direction of slope
 577+ F15E CD DD EF                         call    ADDYXRegtoX1            ; TXA                    \ Set x1 = x1 + (Y X)
 578+ F161 21 7F 00                         ld      hl, 127                 ; LDA #Y*2-1             \ Set y1 = 2 * #Y - 1. The constant #Y is 96, the y-coordinate of the mid-point of the space view (or in our case 127)
 579+ F164 22 7A EF                         ld      (XX1532),hl             ; STA XX15+3             \ pixel row of the space view
 580+ F167 C9           LL136_6502:         ret                             ; RTS                    \ Return from the subroutine
 581+ F168              ;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 582+ F168              ;-- LL145 LINE CLIP
 583+ F168              ;-- OPTISIATIONS - VERTICAL HORZONTAL POINT |DX| = |DY| (and all the veriants for +/-)
 584+ F168              ;-- This routine clips the line from (x1, y1) to (x2, y2) so it fits on-screen, or returns an error if it can't be clipped to fit. The arguments are 16-bit coordinates, and the clipped line is returned using 8-bit screen coordinates.
 585+ F168              ;-- This part sets XX13 to reflect which of the two points are on-screen and off-screen.
 586+ F168              ;-- IN  : XX15(1 0) x1 XX15(3 2) y1 XX15(5 4) x2 XX12(1 0) y2
 587+ F168              ;-- OUT : (X1, Y1), (X2, Y2) Screen coordinate C flag  Clear if the clipped line fits on-screen, set if itdoesn't
 588+ F168              ;         XX13 The state of the original coordinates on-screen:* 0   = (x2, y2) on-screen* 95(64)  = (x1, y1) on-screen,  (x2, y2) off-screen* 191(128) = (x1, y1) off-screen, (x2, y2) off-screen
 589+ F168              ;              So XX13 is non-zero if the end of the line was clipped,meaning the next line sent to BLINE can't join onto the end but has to start a new segment
 590+ F168              ;         SWAP The swap status of the returned coordinates:* &FF if we swapped the values of (x1, y1) and(x2, y2) as part of the clipping process* 0 if the coordinates are still in the same order
 591+ F168                                  DISPLAY "TODO: treat horz vert and sigle pixel as special cases"
 592+ F168              ; TODO treat horizonal/vert and single pixel as special cases
 593+ F168              LL145_6502:         ZeroA                           ; LDA #0                 \ Set SWAP = 0
 593+ F168 AF          >                        xor a
 594+ F169 32 86 C7                         ld      (SWAP),a                ; STA SWAP
 595+ F16C 3A 7D EF                         ld      a,(XX1554+1)            ; LDA XX15+5             \ Set A = x2_hi (use b as a substibute for a)
 596+ F16F 47                               ld      b,a                     ; .
 597+ F170              ; Note that as we are interested in the sign of XX113 then this needs to be >= 128 or < 128 or 0, we will use 191 as per bbc for now
 598+ F170              ; for the screen coord we will use 127 though, we use c as a temporay X register
 599+ F170 3E BF        LL147_6502:         ld      a,191                   ; LDX #Y*2-1             \ Set X = #Y * 2 - 1. The constant #Y is 96, the y-coordinate of the mid-point of the space view, so this sets Y2 to 191, the y-coordinate of the bottom pixel row of the space view
 600+ F172 32 88 EF                         ld      (Xreg),a                ; .
 601+ F175              ;                    ld      a,127
 602+ F175              ;                    ld      c,a
 603+ F175 78           .CheckX2Y2High:     ld      a,b                     ; ORA XX12+1             \ If one or both of x2_hi and y2_hi are non-zero, jump
 604+ F176 21 7F EF                         ld      hl,XX12p1               ; .
 605+ F179 B6                               or      (hl)                    ; .
 606+ F17A C2 8A F1                         jp      nz,LL107_6502           ; BNE LL107              \ to LL107 to skip the following, leaving X at 191
 607+ F17D 3E 7F        .CheckY2Lo:         ld      a,127 ;,c               ; get back the temporary x reg from c
 608+ F17F 21 7E EF                         ld      hl,XX1210               ; CPX XX12               \ If y2_lo > the y-coordinate of the bottom of screen (a is being used as X at this point still)
 609+ F182 BE                               cp      (hl)                    ; .
 610+ F183 DA 8A F1                         jp      c,LL107_6502            ; BCC LL107              \ then (x2, y2) is off the bottom of the screen, so skip the following instruction, leaving X at 127
 611+ F186                                  ZeroA                           ; LDX #0                 \ Set X = 0
 611+ F186 AF          >                        xor a
 612+ F187 32 88 EF                         ld      (Xreg),a
 613+ F18A 3A 88 EF     LL107_6502:         ld      a,(Xreg)                ; STX XX13               \ Set XX13 = X, so we have * XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen* XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lois off the bottom of the screen
 614+ F18D 32 6E 69                         ld      (XX13),a                ; now c is released as a temporary x reg
 615+ F190 3A 79 EF                         ld      a,(XX1510+1)            ; LDA XX15+1             \ If one or both of x1_hi and y1_hi are non-zero, jump
 616+ F193 21 7B EF                         ld      hl,XX1532+1             ; ORA XX15+3             \ to LL83
 617+ F196 B6                               or      (hl)                    ; .
 618+ F197 C2 D7 F1                         jp      nz,LL83_6502            ; BNE LL83
 619+ F19A              ; DEBUG SIMPLIFIED CODE, now we just compare y1 lo > 127
 620+ F19A 3A 7A EF                         ld      a,(XX1532)              ; If y1_lo > the y-coordinate of the bottom of screen (If A >= N, then C flag is reset.) ;ld      a,127                   ; LDA #Y*2-1             \ If y1_lo > the y-coordinate of the bottom of screen (If A >= N, then C flag is reset.)
 621+ F19D 26 7F                            ld      h,127                   ; then (x1, y1) is off the bottom of the screen, so jump                                 ;ld      hl,XX1532               ; CMP XX15+2             \ then (x1, y1) is off the bottom of the screen, so jump
 622+ F19F BC                               cp      h                       ; to LL83                                                                                ;cp      (hl)                    ; .                      \ to LL83
 623+ F1A0 D2 D7 F1                         jp      nc, LL83_6502         ; BCC LL83               \ . (y1 > 127 jump, i.e. 127 <= y1 )
 624+ F1A3 3A 6E 69                         ld      a,(XX13)                ; LDA XX13               \ If we get here, (x1, y1) is on-screen. If XX13 is non-zero, i.e. (x2, y2) is off-screen, jump
 625+ F1A6 A7                               and     a                       ; BNE LL108              \ to LL108 to halve it before continuing at LL83
 626+ F1A7 C2 D2 F1                         jp      nz,LL108_6502
 627+ F1AA              ; If we get here, the high bytes are all zero, which means the x-coordinates are < 256 and therefore fit on screen, and neither coordinate is off the bottom of the screen. That means both coordinates are already on
 628+ F1AA              ; screen, so we don't need to do any clipping, all weneed to do is move the low bytes into (X1, Y1) and X2, Y2) and return
 629+ F1AA              ; X1 = XX15 (10)  Y1 = XX15+1 X2 = XX15+2 Y2 = XX15+3
 630+ F1AA                  DEFINE CLAMPINGEXTREMES
 631+ F1AA              LL146_6502: IFDEF CLAMPINGEXTREMES
 632+ F1AA 2A 78 EF                         ld      hl,(XX1510)             ;  Save X1 to XX1510
 633+ F1AD CD 03 F0                         call    ClampX
 634+ F1B0 32 78 EF                         ld      (XX1510),a
 635+ F1B3                          ENDIF
 636+ F1B3 2A 7A EF                         ld      hl,(XX1532)             ;  hl = y1
 637+ F1B6 CD 0F F0                         call    ClampY
 638+ F1B9 32 79 EF                         ld      (XX1510+1),a            ;  XX1510... = [X1][Y1]
 639+ F1BC
 640+ F1BC 2A 7C EF                         ld      hl,(XX1554)             ;  de = x2
 641+ F1BF CD 03 F0                         call    ClampX
 642+ F1C2 32 7A EF                         ld      (XX1510+2),a            ;  XX1510... = [X1][Y1][X2]
 643+ F1C5
 644+ F1C5 2A 7E EF                         ld      hl,(XX1576)             ;  bc = y2
 645+ F1C8 CD 0F F0                         call    ClampY
 646+ F1CB 32 7B EF                         ld      (XX1510+3),a            ;  XX1510... = [X1][Y1][X2][Y2]
 647+ F1CE
 648+ F1CE                                  ClearCarryFlag                  ; CLC                    \ Clear the C flag as the clipped line fits on-screen
 648+ F1CE B7          >                        or a
 649+ F1CF C9                               ret                             ; RTS                    \ Return from the subroutine
 650+ F1D0              LL109_6502:         SetCarryFlag                    ; SEC                    \ Set the C flag to indicate the clipped line does not fit on-screen
 650+ F1D0 37          >                        scf
 651+ F1D1 C9                               ret                             ; RTS                    \ Return from the subroutine
 652+ F1D2 21 6E 69     LL108_6502:         ld      hl,XX13                 ; LSR XX13               \ If we get here then (x2, y2) is off-screen and XX13 is
 653+ F1D5 CB 3E                            srl     (hl)                    ;                        \ 191, (128)  so shift XX13 right to halve it to 95 (64)
 654+ F1D7              ;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 655+ F1D7              ;-- LL145 (Part 2 of 4)
 656+ F1D7 3A 6E 69     LL83_6502:          ld      a,(XX13)                ; LDA XX13               \ If XX13 < 128 then only one of the points is on-screen
 657+ F1DA A7                               and     a                       ; BPL LL115              \ so jump down to LL115 to skip the checks of whether
 658+ F1DB F2 27 F2                         jp      p,LL115_6502            ;                        \ both points are in the strips to the right or bottom of the screen
 659+ F1DE              ;-- If we get here, both points are off-screen
 660+ F1DE 3A 79 EF                         ld      a,(XX1510+1)            ; LDA XX15+1             \ If both x1_hi and x2_hi have bit 7 set, jump to LL109
 661+ F1E1 21 7D EF                         ld      hl,XX1554+1             ; AND XX15+5             \ to return from the subroutine with the C flag set, as
 662+ F1E4 A6                               and     (hl)
 663+ F1E5 FA D0 F1                         jp      m, LL109_6502           ; BMI LL109              \ the entire line is above the top of the screen
 664+ F1E8 3A 7B EF                         ld      a,(XX1532+1)            ; LDA XX15+3             \ If both y1_hi and y2_hi have bit 7 set, jump to LL109
 665+ F1EB 21 7F EF                         ld      hl,XX1576+1             ; AND XX12+1             \ to return from the subroutine with the C flag set, as
 666+ F1EE A6                               and     (hl)                    ; BMI LL109              \ the entire line is to the left of the screen
 667+ F1EF FA D0 F1                         jp      m,LL109_6502            ; .
 668+ F1F2 3A 79 EF                         ld      a,(XX1510+1)            ; LDX XX15+1             \ Set A = X = x1_hi - 1
 669+ F1F5 3D                               dec     a                       ; DEX
 670+ F1F6 32 88 EF                         ld      (Xreg),a                ; TXA
 671+ F1F9 F5                               push    af                      ; LDX XX15+5     SP+1    \ Set XX12+2 = x2_hi - 1, we need to save a register first
 672+ F1FA 3A 7D EF                         ld      a,(XX1554+1)            ; .
 673+ F1FD 3D                               dec     a                       ; DEX
 674+ F1FE 32 88 EF                         ld      (Xreg),a                ; STX XX12+2
 675+ F201 F1                               pop     af                      ; .              SP+0    restore a register
 676+ F202 21 7F EF                         ld      hl,XX1576+1             ; ORA XX12+2             \ If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set,
 677+ F205 B6                               or      (hl)                    ; .
 678+ F206 F2 D0 F1                         jp      p, LL109_6502           ; BPL LL109              \ jump to LL109 to return from the subroutine with the C flag set, as the line doesn't fit on-screen
 679+ F209              ; for this bit, while z80 uses carry the opposite way to 6502, 6502 uses borrow, in effect inverting the flip
 680+ F209              ;NOTEFOUND A PATH WHERE IT DOES NOT DO THIS CHECK e.g. 90 B2 8D A2
 681+ F209 3A 7A EF     LL83_DEBUG:         ld      a,(XX1532)              ; LDA XX15+2             \ If y1_lo < y-coordinate of screen bottom, clear the C
 682+ F20C FE 80                            cp      128                     ; CMP #Y*2               \ flag, otherwise set it (NOTE FLIPPED IN z80)
 683+ F20E 3A 7B EF                         ld      a,(XX1532+1)            ; LDA XX15+3             \ Set XX12+2 = y1_hi - (1 - C), so:
 684+ F211              ;                    FlipCarryFlag                   ; as 6502 uses borrow in subtracts we flip for SBC as z80 CP does opposite too, if A < N carry set so flip
 685+ F211 DE 00                            sbc     0                       ; SBC #0                 \ .
 686+ F213 32 80 EF                         ld      (XX12p2),a              ; STA XX12+2             \  * Set XX12+2 = y1_hi - 1 if y1_lo is on-screen * Set XX12+2 = y1_hi  otherwise We do this subtraction because we are only interested
 687+ F216 3A 7E EF                         ld      a,(XX1576)              ; LDA XX12               \ If y2_lo < y-coordinate of screen bottom, clear the C
 688+ F219 FE 80                            cp      128                     ; CMP #Y*2               \ flag, otherwise set it
 689+ F21B 3A 7F EF                         ld      a,(XX1576+1)            ; LDA XX12+1             \ Set XX12+2 = y2_hi - (1 - C), so:
 690+ F21E              ;                    FlipCarryFlag
 691+ F21E DE 00                            sbc     0                       ; SBC #0                   * Set XX12+1 = y2_hi - 1 if y2_lo is on-screen  * Set XX12+1 = y2_hi     otherwise
 692+ F220 21 80 EF                         ld      hl,XX12p2               ; ORA XX12+2             \ If neither XX12+1 or XX12+2 have bit 7 set, jump to
 693+ F223 B6                               or      (hl)                    ; .
 694+ F224 F2 D0 F1                         jp      p,LL109_6502            ; BPL LL109              \ LL109 to return from the subroutine with the C flag set, as the line doesn't fit on-screen
 695+ F227              ;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 696+ F227              ;-- LL145 (Part 3 of 4) Summary: Clip line: Calculate the line's gradient
 697+ F227 3A 89 EF     LL115_6502:         ld      a,(Yreg)                ; TYA                    \ Store Y on the stack so we can preserve it through the call to this routine
 698+ F22A F5                               push    af                      ; PHA            SP+1    \ call to this subroutine
 699+ F22B 2A 7C EF                         ld      hl,(XX1554)             ; LDA XX15+4             \ Set XX12+2 = x2_lo - x1_lo
 700+ F22E ED 5B 78 EF                      ld      de,(XX1510)             ; LDA XX15+5             \ Set XX12+3 = x2_hi - x1_hi
 701+ F232                                  ClearCarryFlag                  ; SBC XX15+1
 701+ F232 B7          >                        or a
 702+ F233 ED 52                            sbc     hl,de                   ; .
 703+ F235 22 D6 F5                         ld      (delta_x),hl            ; .
 704+ F238 2A 7E EF                         ld      hl,(XX1576)             ; LDA XX12               \ Set XX12+4 = y2_lo - y1_lo
 705+ F23B ED 5B 7A EF                      ld      de,(XX1532)             ;
 706+ F23F                                  ClearCarryFlag                  ; SBC XX15+2
 706+ F23F B7          >                        or a
 707+ F240 ED 52                            sbc     hl,de                   ; .
 708+ F242 22 D8 F5                         ld      (delta_y),hl            ; .
 709+ F245              ; So we now have:  delta_x in XX12(3 2)  delta_y in XX12(5 4) where the delta is (x1, y1) - (x2, y2))
 710+ F245 3A D9 F5                         ld      a,(delta_y+1)           ; EOR XX12+3             \ Set S = the sign of delta_x * the sign of delta_y, so
 711+ F248 21 D7 F5                         ld      hl,delta_x+1
 712+ F24B AE                               xor     (hl)
 713+ F24C 32 87 EF                         ld      (Svar),a                ; STA S                  \ if bit 7 of S is set, the deltas have different signs (perhaps we should do bit 7 mask ?????????
 714+ F24F 2A D8 F5                         ld      hl,(delta_y)            ; LDA XX12+5             \ If delta_y_hi is positive, jump down to LL110 to skip
 715+ F252 7C                               ld      a,h
 716+ F253 A7                               and     a
 717+ F254 F2 60 F2                         jp      p, LL110_6502           ; BPL LL110              \ the following
 718+ F257                                  NegHL                           ; LDA #0                 \ Otherwise flip the sign of delta_y to make it
 718+ F257 AF          >                    xor a
 718+ F258 95          >                    sub l
 718+ F259 6F          >                    ld l,a
 718+ F25A 9F          >                    sbc a,a
 718+ F25B 94          >                    sub h
 718+ F25C 67          >                    ld h,a
 719+ F25D 22 D8 F5                         ld      (delta_y),hl            ; positive, starting with the low bytes
 720+ F260 2A D6 F5     LL110_6502:         ld      hl,(delta_x)            ; LDA XX12+3             \ If delta_x_hi is positive, jump down to LL111 to skip
 721+ F263 7C                               ld      a,h                     ; BPL LL111              \ the following
 722+ F264 A7                               and     a                       ; .
 723+ F265 F2 71 F2                         jp      p,LL111_6502            ; .
 724+ F268                                  NegHL                           ; SEC                    \ Otherwise flip the sign of delta_x to make it
 724+ F268 AF          >                    xor a
 724+ F269 95          >                    sub l
 724+ F26A 6F          >                    ld l,a
 724+ F26B 9F          >                    sbc a,a
 724+ F26C 94          >                    sub h
 724+ F26D 67          >                    ld h,a
 725+ F26E 22 D6 F5                         ld      (delta_x),hl            ; LDA #0                 \ positive, starting with the low bytes
 726+ F271              ;--  We now keep halving |delta_x| and |delta_y| until both of them have zero in their high bytes
 727+ F271 2A D6 F5     LL111_6502:         ld      hl,(delta_x)
 728+ F274 ED 5B D8 F5                      ld      de,(delta_y)
 729+ F278 7C                               ld      a,h                     ; TAX                    \ If |delta_x_hi| is non-zero, skip the following
 730+ F279 B2                               or      d                       ; BNE LL112
 731+ F27A CA 8F F2                         jp      z,LL113_6502            ; LDX XX12+5             \ If |delta_y_hi| = 0, jump down to LL113 (as both |delta_x_hi| and |delta_y_hi| are 0)
 732+ F27D              LL112_6502:         ShiftHLRight1                   ; LSR A                  \ Halve the value of delta_x in (A XX12+2)
 732+ F27D CB 3C       >			   srl h
 732+ F27F CB 1D       >			   rr  l
 733+ F281                                  ShiftDERight1                   ; LSR XX12+5             \ Halve the value of delta_y XX12(5 4)
 733+ F281 CB 3A       >			   srl d
 733+ F283 CB 1B       >			   rr  e
 734+ F285 22 D6 F5                         ld      (delta_x),hl
 735+ F288 ED 53 D8 F5                      ld      (delta_y),de            ; write them back so we don't end up in an infinite loop
 736+ F28C C3 71 F2                         jp  LL111_6502                  ; JMP LL111              \ Loop back to LL111
 737+ F28F              ;-- By now, the high bytes of both |delta_x| and |delta_y| are zero
 738+ F28F              LL113_6502:         ZeroA                           ; STX T                  \ We know that X = 0 as that's what we tested with a BEQ  above, so this sets T = 0
 738+ F28F AF          >                        xor a
 739+ F290 32 84 EF                         ld  (Tvar),a
 740+ F293 3A D6 F5                         ld      a,(delta_x)             ; LDA XX12+2             \ If delta_x_lo < delta_y_lo, so our line is more
 741+ F296 21 D8 F5                         ld      hl,delta_y              ; CMP XX12+4             \ vertical than horizontal, jump to LL114
 742+ F299 BE                               cp      (hl)
 743+ F29A DA AC F2                         jp      c, LL114_6502           ; BCC LL114              ; if delta y > delta x then its a steep slope so we do 256*dy/dx
 744+ F29D              ;-- If we get here then our line is more horizontal than vertical, so it is a shallow slope
 745+ F29D 3A D6 F5                         ld      a,(delta_x)             ; STA Q                  \ Set Q = delta_x_lo
 746+ F2A0 32 85 EF                         ld      (Qvar),a                ; .
 747+ F2A3 3A D8 F5                         ld      a,(delta_y)             ; LDA XX12+4             \ Set A = delta_y_lo
 748+ F2A6 CD 8A EF                         call    LL28_6502               ; JSR LL28               \ Call LL28 to calculate: R = 256 * A / Q = 256 * delta_y_lo / delta_x_lo
 749+ F2A9 C3 BD F2                         jp      LL116_6502              ; JMP LL116              \ Jump to LL116, as we now have the line's gradient in R
 750+ F2AC              ;-- If we get here then our line is more vertical than horizontal, so it is a steep slope
 751+ F2AC 3A D8 F5     LL114_6502:         ld      a,(delta_y)             ; LDA XX12+4             \ Set Q = delta_y_lo
 752+ F2AF 32 85 EF                         ld      (Qvar),a                ; STA Q
 753+ F2B2 3A D6 F5                         ld      a,(delta_x)             ; LDA XX12+2             \ Set A = delta_x_lo
 754+ F2B5 CD 8A EF                         call    LL28_6502               ; JSR LL28               \ Call LL28 to calculate: R = 256 * A / Q = 256 * delta_x_lo / delta_y_lo
 755+ F2B8 3E FF                            ld      a,$FF                   ; DEC T                  \ T was set to 0 above, so this sets T = &FF when our
 756+ F2BA 32 84 EF                         ld      (Tvar),a                ;                        \ line is steep
 757+ F2BD              ;----------------------------------------------------------------------------------------------------------------
 758+ F2BD              ;--- LL116 This part sets things up to call the routine in LL188, which does the actual clipping.
 759+ F2BD              ;--  If we get here, then R has been set to the gradient of the line (x1, y1) to(x2, y2), with T indicating the gradient of slope: * 0   = shallow slope (more horizontal than vertical)
 760+ F2BD              ;--                                                                                                                                * &FF = steep slope (more vertical than horizontal)
 761+ F2BD              ;-- XX13 has been set as follows: * 0   = (x1, y1) off-screen, (x2, y2) on-screen * 95(64)  = (x1, y1) on-screen,  (x2, y2) off-screen * 191(128) = (x1, y1) off-screen, (x2, y2) off-screen
 762+ F2BD 3A 86 EF     LL116_6502:         ld      a,(Rvar)                ; LDA R                  \ Store the gradient in XX12+2
 763+ F2C0 32 80 EF                         ld      (XX12p2),a              ; STA XX12+2
 764+ F2C3 3A 87 EF                         ld      a,(Svar)                ; LDA S                  \ Store the type of slope in XX12+3, bit 7 clear means
 765+ F2C6 32 81 EF                         ld      (XX12p3),a              ; STA XX12+3             \ top left to bottom right, bit 7 set means top right to bottom left
 766+ F2C9 3A 6E 69                         ld      a,(XX13)                ; LDA XX13               \ If XX13 = 0, skip the following instruction
 767+ F2CC FE 00                            cp      0                       ; BEQ LL138
 768+ F2CE CA D4 F2                         jp      z,LL138_6502            ; .
 769+ F2D1 F2 F0 F2                         jp      p, LLX117_6502          ; If XX13 is positive, it must be 95 (64) as 128 would be negative). This means (x1, y1) is on-screen but (x2, y2) isn't, so we jump
 770+ F2D4              ;-- If we get here, XX13 = 0 or 191, so (x1, y1) is off-screen and needs clipping
 771+ F2D4 CD 00 F1     LL138_6502:         call    LL118_6502              ; JSR LL118              \ Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 772+ F2D7 3A 6E 69                         ld      a,(XX13)                ; LDA XX13               \ If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to
 773+ F2DA A7                               and     a
 774+ F2DB F2 13 F3                         jp      p,LL124_6502            ; BPL LL124              \ LL124 to return with a successfully clipped line
 775+ F2DE              ;-- If we get here, XX13 = 191 (128) (both coordinates areoff-screen)
 776+ F2DE 3A 79 EF     LL117_6502:         ld      a,(XX1510+1)            ; LDA XX15+1             \ If either of x1_hi or y1_hi are non-zero, jump to
 777+ F2E1 21 7B EF                         ld      hl,XX1532+1             ; ORA XX15+3             \ LL137 to return from the subroutine with the C flag
 778+ F2E4 B6                               or      (hl)
 779+ F2E5 C2 1B F3                         jp      nz, LL137_6502          ; BNE LL137              \ set, as the line doesn't fit on-screen
 780+ F2E8 3A 7A EF                         ld      a,(XX1532)              ; LDA XX15+2             \ If y1_lo > y-coordinate of the bottom of the screen
 781+ F2EB FE 80                            cp      128                     ; CMP #Y*2               \ jump to LL137 to return from the subroutine with the
 782+ F2ED D2 1B F3                         jp      nc, LL137_6502          ; BCS LL137              \ C flag set, as the line doesn't fit on-screen
 783+ F2F0              ;-- If we get here, XX13 = 95 or 191, and in both cases (x2, y2) is off-screen, so we now need to swap the (x1, y1) and (x2, y2) coordinates around before doing the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
 784+ F2F0 2A 78 EF     LLX117_6502:        ld      hl,(XX1510)             ; LDX XX15               \ Swap x1_lo = x2_lo
 785+ F2F3 ED 5B 7C EF                      ld      de,(XX1554)
 786+ F2F7 ED 53 78 EF                      ld      (XX1510),de
 787+ F2FB 22 7C EF                         ld      (XX1554),hl
 788+ F2FE 2A 7A EF                         ld      hl,(XX1532)             ; LDX XX15+2             \ Swap y1_lo = y2_lo
 789+ F301 ED 5B 7E EF                      ld      de,(XX1576)
 790+ F305 ED 53 7A EF                      ld      (XX1532),de
 791+ F309 22 7E EF                         ld      (XX1576),hl
 792+ F30C CD 00 F1                         call    LL118_6502              ; JSR LL118              \ Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 793+ F30F 21 86 C7                         ld      hl,SWAP
 794+ F312 35                               dec     (hl)                    ; DEC SWAP               \ Set SWAP = &FF to indicate that we just clipped the line at the (x2, y2) end by swapping the coordinates (the DEC does this as we set SWAP to 0 at the start of this subroutine)
 795+ F313 F1           LL124_6502:         pop     af                      ; PLA            SP+0    \ Restore Y from the stack so it gets preserved through
 796+ F314 32 89 EF                         ld      (Yreg),a                ; TAY                    \ the call to this subroutine
 797+ F317 CD AA F1                         call    LL146_6502              ; JMP LL146              \ Jump up to LL146 to move the low bytes of (x1, y1) and (x2, y2) into (X1, Y1) and (X2, Y2), and return from the subroutine with a successfully clipped line
 798+ F31A C9                               ret                             ; then exit so we don't pop it twice
 799+ F31B F1           LL137_6502:         pop     af                      ; PLA            SP+0    \ Restore Y from the stack so it gets preserved through
 800+ F31C 32 89 EF                         ld      (Yreg),a                ; TAY                    \ the call to this subroutine
 801+ F31F                                  SetCarryFlag                    ; SEC                    \ Set the C flag to indicate the clipped line does not fit on-screen
 801+ F31F 37          >                        scf
 802+ F320 C9                               ret                             ; RTS                    \ Return from the subroutine
 803+ F321                      ENDIF
# file closed: ../../Layer2Graphics/BBCEliteDirectMappingLL118.asm
 671  F321                  INCLUDE "../../Layer2Graphics/l2_draw_any_line.asm"
# file opened: ../../Layer2Graphics/l2_draw_any_line.asm
   1+ F321
   2+ F321 FF FF        starty                  DW     $FFFF
   3+ F323 FF FF        endy                    DW     $FFFF
   4+ F325 CF           traingleColor           DB     $CF
   5+ F326 00 00 00...  SaveArrayS1             DS     128*2
   6+ F426 00 00 00...  SaveArrayS2             DS     128*2
   7+ F526
   8+ F526                      IFDEF Add_l2_drawHorzClipY
   9+ F526 ~            l2_drawHorzClipY:
  10+ F526 ~            .ClipY:                 ex      de,hl                       ; get X1 into de
  11+ F526 ~            .ClipDE:                bit     7,d
  12+ F526 ~                                    jr      z,.DEPositive
  13+ F526 ~            .DENegative:            ld      de,0
  14+ F526 ~                                    jp      .ClipDEDone
  15+ F526 ~            .DEPositive:            ld      a,d
  16+ F526 ~                                    and     a
  17+ F526 ~                                    jp      z,.ClipDE127
  18+ F526 ~            .ClipDE256:             ld      de,127
  19+ F526 ~                                    jp      .ClipDEDone
  20+ F526 ~            .ClipDE127:             bit     7,e
  21+ F526 ~                                    jp      z,.ClipDEDone
  22+ F526 ~                                    ld      de,127
  23+ F526 ~            .ClipDEDone:
  24+ F526 ~            .AdjustStartY:          ld      hl,(starty)
  25+ F526 ~                                    call    CompareHLDESgn           ; if de < HL
  26+ F526 ~                                    jr      z,.AdjustEndY               ;
  27+ F526 ~                                    jr      c,.AdjustEndY               ;
  28+ F526 ~            .ClipStartY:            ld      (starty),de                 ; .
  29+ F526 ~            .AdjustEndY:            ld      hl,(endy)                   ; is endy still uninitialised
  30+ F526 ~            .InitEndY:              ld      a,h                         ;
  31+ F526 ~                                    and     l                           ;
  32+ F526 ~                                    cp      $FF                         ;
  33+ F526 ~                                    jr      z,.ForceEndYSet
  34+ F526 ~            .CheckEndY:             call    CompareHLDESgn           ; if de < HL
  35+ F526 ~                                    ret     z
  36+ F526 ~                                    ret     nc
  37+ F526 ~            .ForceEndYSet:          ld      (endy),de
  38+ F526 ~                                    ret
  39+ F526                      ENDIF
  40+ F526
  41+ F526
  42+ F526 2A AE F5     l2_drawVertClip:        ld      hl,(y1)
  43+ F529 ED 5B B2 F5                          ld      de,(y2)
  44+ F52D CD 56 76                             call    CompareHLDESgn
  45+ F530 30 01                                jr      nc,.y1ltey2
  46+ F532 EB                                   ex      de,hl
  47+ F533 CB 7C        .y1ltey2:               bit     7,h
  48+ F535 CA 3B F5                             jp      z,.y1Positive
  49+ F538 21 00 00                             ld      hl,0
  50+ F53B 7A           .y1Positive             ld      a,d
  51+ F53C A7                                   and     a
  52+ F53D CA 45 F5                             jp      z,.y2lt255
  53+ F540 1E 7F                                ld      e,127
  54+ F542 C3 4C F5                             jp      .y2Clipped
  55+ F545 CB 7B        .y2lt255:               bit     7,e
  56+ F547 CA 4C F5                             jp      z,.y2Clipped
  57+ F54A 1E 7F                                ld      e,127
  58+ F54C ED 4B AC F5  .y2Clipped:             ld      bc,(x1)
  59+ F550 45                                   ld      b,l
  60+ F551 53                                   ld      d,e
  61+ F552 1E BF                                ld      e,$BF
  62+ F554 C3 2D E5                             jp      l2_draw_vert_line_to                ; ">bc = row col d = to position, e = color"
  63+ F557
  64+ F557
  65+ F557 2A AC F5     l2_drawHorzClip:        ld      hl,(x1)
  66+ F55A ED 5B B0 F5                          ld      de,(x2)
  67+ F55E CD 56 76                             call    CompareHLDESgn
  68+ F561 30 01                                jr      nc,.x1ltex2
  69+ F563 EB                                   ex      de,hl
  70+ F564 CB 7C        .x1ltex2:               bit     7,h
  71+ F566 CA 6C F5                             jp      z,.x1Positive
  72+ F569 21 00 00                             ld      hl,0
  73+ F56C 7A           .x1Positive             ld      a,d
  74+ F56D A7                                   and     a
  75+ F56E CA 73 F5                             jp      z,.x2Clipped
  76+ F571 1E FF                                ld      e,255
  77+ F573 ED 4B AE F5  .x2Clipped:             ld      bc,(y1)
  78+ F577 41                                   ld      b,c
  79+ F578 4D                                   ld      c,l
  80+ F579 53                                   ld      d,e
  81+ F57A 1E BF                                ld      e,$BF
  82+ F57C C3 95 E4                             jp      l2_draw_horz_line_to                ; "bc = left side row,col, d right pixel, e = color"
  83+ F57F
  84+ F57F                      IFDEF Add_l2_drawVertClipY
  85+ F57F ~            l2_drawVertClipY:       bit     7,d                     ; i = (py1<0?0:py1);
  86+ F57F ~                                    jr      z,.PYIsOK
  87+ F57F ~            .SetPYTo0:              ld      de,0
  88+ F57F ~            .PYIsOK:                ld      hl,(starty)
  89+ F57F ~                                    IsHLEqu255
  90+ F57F ~                                    jp      z,.UpdateStartY
  91+ F57F ~                                    call    CompareHLDESgn       ; or starty > py
  92+ F57F ~                                    jr      nc,.UpdateStartY        ;
  93+ F57F ~                                    jp      .PrepareUpdateArray
  94+ F57F ~            .UpdateStartY:          ld      (starty),de
  95+ F57F ~            .PrepareUpdateArray:    JumpIfRegLTE c, 127, .UpdateCounters ; we loop from
  96+ F57F ~                                    ld      c,127
  97+ F57F ~            .UpdateEndY:            ld      (endy),bc               ; save BC to endy y as its now clamped, thsi frees up BC regsiters
  98+ F57F ~            .UpdateCounters:        ld      hl,ix                   ; get target array index and set it to
  99+ F57F ~                                    add     hl,de                   ; targetArray[de]
 100+ F57F ~                                    add     hl,de                   ; .
 101+ F57F ~                                    ld      a,c                     ; now set up B as an iterator
 102+ F57F ~                                    sub     b                       ; for py2 - py1 + 1 entries
 103+ F57F ~                                    inc     a                       ; .
 104+ F57F ~                                    ld      b,a                     ; .
 105+ F57F ~                                    ld      de,ix                   ; we don't need de anymore to move ix for faster instructions
 106+ F57F ~            .UpdateArray:           ld      (hl),de                 ; use sjasm fake as it does (hl)=e,inc hl, (hl)=d,inc hl
 107+ F57F ~                                    inc     a                       ; use a as a counter for the end when we update EndY
 108+ F57F ~                                    djnz    .UpdateArray            ; .
 109+ F57F ~                                    ret                             ; we are now done
 110+ F57F                      ENDIF
 111+ F57F
 112+ F57F
 113+ F57F              ; ">l2_draw_any_line, bc = y0,x0 de=y1,x1,a=color: determines if its horizontal, vertical or diagonal then hands off the work"
 114+ F57F              ; b - y0 c - x0, d - y1 e - x1 a - colour
 115+ F57F 08           l2_draw_any_line:       ex		af,af'              ; save colour into a'
 116+ F580 79                                   ld		a,c                 ; if x and e are the same its horizontal
 117+ F581 BB                                   cp		e
 118+ F582 28 08                                jr		z,.HorizontalLineCheck
 119+ F584 78                                   ld		a,b                 ; if b and d are the same its vertica;
 120+ F585 BA                                   cp		d
 121+ F586 28 0E                                jr		z,.VerticalLine
 122+ F588              ; use jp and get a free ret instruction optimisation
 123+ F588 08           .DiagonalLine:		    ex		af,af'			     ; get colour back into a
 124+ F589 C3 4C E7                             jp		l2_draw_diagonal
 125+ F58C
 126+ F58C 78           .HorizontalLineCheck:   ld      a,b
 127+ F58D BA                                   cp      d
 128+ F58E 28 0B                                jr      z, .SinglePixel
 129+ F590 08           .HorizontalLine:        ex		af,af'              ; get colour back into a
 130+ F591 53                                   ld		d,e				    ; set d as target right pixel
 131+ F592 5F                                   ld		e,a				    ; e holds colour on this call
 132+ F593 C3 95 E4                             jp		l2_draw_horz_line_to
 133+ F596 08           .VerticalLine:          ex		af,af'
 134+ F597 5F                                   ld		e,a				    ; e holds colour on this call
 135+ F598 C3 2D E5                             jp		l2_draw_vert_line_to
 136+ F59B 08           .SinglePixel:           ex		af,af'              ; get colour back into a
 137+ F59C                                      l2_plot_macro; jp      l2_plot_pixel
 137+ F59C 78          >                        ld      a,b
 137+ F59D             >                        JumpIfAGTENusng 192 ,.NoPlot
 137+ F59D FE C0       >                        cp     192
 137+ F59F D2 AB F5    >                        jp		nc,.NoPlot
 137+ F5A2 69          >                        ld      l,c
 137+ F5A3 CD 68 E0    >                        call    asm_l2_row_bank_select
 137+ F5A6 67          >                        ld      h,a
 137+ F5A7 3A 8D E2    >                        ld      a,(line_gfx_colour)
 137+ F5AA 77          >                        ld      (hl),a
 137+ F5AB             >.NoPlot:
 138+ F5AB C9                                   ret
 139+ F5AC              ;-*-*-;......................................................
 140+ F5AC              ;-*-*-; hl'hl = x1y1 de'de = x3y3 , does not save, just plots points
 141+ F5AC              ;-*-*-Layer2_draw_ClipY_Line:
 142+ F5AC              ;-*-*-;                       Eliminte totally off screen first
 143+ F5AC              ;-*-*-.Y1HighTest:            IsHLGT127                       ; if y1 and y2 > 127
 144+ F5AC              ;-*-*-                        jr      nz,.Y1HighLTE127        ; .
 145+ F5AC              ;-*-*-.Y2HighTest:            IsDEGT127                       ; .
 146+ F5AC              ;-*-*-                        ret     nz                       ;   return
 147+ F5AC              ;-*-*-.Y1HighLTE127:
 148+ F5AC              ;-*-*-.Y1LowTest:             bit     7,h                     ; if y1 and y2 < 0
 149+ F5AC              ;-*-*-                        jr      z,.YTestPass            ; .
 150+ F5AC              ;-*-*-                        bit     7,d                     ; .
 151+ F5AC              ;-*-*-                        ret     nz                      ;   return
 152+ F5AC              ;-*-*-.YTestPass:             exx                             ; hl hl' = x1y1 de de' = x2y2
 153+ F5AC              ;-*-*-                        ld      a,h                     ; if x1 and x2 < 0 or > 255
 154+ F5AC              ;-*-*-                        and     a                       ; then in either scenario high
 155+ F5AC              ;-*-*-                        jr      z,.XTestPass            ; byte will not be zero
 156+ F5AC              ;-*-*-                        ld      a,d                     ; .
 157+ F5AC              ;-*-*-                        and     a                       ; .
 158+ F5AC              ;-*-*-                        ret     nz                      ;   return
 159+ F5AC              ;-*-*-.XTestPass:                                             ;
 160+ F5AC              ;-*-*-;                       Check for horizontal and vertical exceptions
 161+ F5AC              ;-*-*-.CheckForVertical:      call    CompareHLDESigned       ; if x1 = x2 then vertical line
 162+ F5AC              ;-*-*-                        jp      z, l2_drawVertClipY     ;    goto vertical and use its ret as a free exit
 163+ F5AC              ;-*-*-.CheckForHorizontal:    exx                             ; hl'hl = x1y1 de'de = x2y2
 164+ F5AC              ;-*-*-                        call    CompareHLDESigned       ; if y1 = y2 then horizonal line
 165+ F5AC              ;-*-*-                        jp      z, l2_drawHorzClipY     ; goto  horizontal and use its ret as a free exit
 166+ F5AC              ;-*-*-                        exx                             ; hl hl' = x1y1 de de' = x2y2
 167+ F5AC              ;-*-*-;                       Now we can draw diagnoal, note we are pre-sorting Y so no need to do sort logic
 168+ F5AC              ;-*-*-;                       Check if X1 > X2 and set sign, X1 x2 and clip accordingly
 169+ F5AC              ;-*-*-.SetupMinMaxX:          call    CompareHLDESigned       ; If x1 > x2
 170+ F5AC              ;-*-*-                        jr      c, .x1LTx2              ; . (else jump to x1 < x2 as we have already handled x1 = x2)
 171+ F5AC              ;-*-*-.x1GTEx2:               ld      a,$FF                   ;   sign_x = -1 (also iyh)
 172+ F5AC              ;-*-*-                        ld      (sign_x),a              ;   .
 173+ F5AC              ;-*-*-                        ld      iyh,a
 174+ F5AC              ;-*-*-                        NegHL                           ;   x1 = - x1
 175+ F5AC              ;-*-*-                        NegDE                           ;   x2 = - x2
 176+ F5AC              ;-*-*-                        xor     a                       ;   xmax = 0
 177+ F5AC              ;-*-*-                        ld      (clip_xmax),a           ;   .
 178+ F5AC              ;-*-*-                        ld      (clip_xmax+1),a         ;   .
 179+ F5AC              ;-*-*-                        inc     a                       ;   xmin = -255 ($FF01)
 180+ F5AC              ;-*-*-                        ld      (clip_xmin),a           ;   .
 181+ F5AC              ;-*-*-                        ld      a,$FF
 182+ F5AC              ;-*-*-                        ld      (clip_xmin+1),a         ;   .
 183+ F5AC              ;-*-*-                        jp      .DoneSignSetup          ; else
 184+ F5AC              ;-*-*-;                       if X1<X2 then set up sign as 1, clip, we don't need to change X1 and X2
 185+ F5AC              ;-*-*-.x1LTx2:                ld      a,1                     ;   sign_x = 1 (also iyh)
 186+ F5AC              ;-*-*-                        ld      (sign_x),a              ;   .
 187+ F5AC              ;-*-*-                        ld      iyh,a                   ;   .
 188+ F5AC              ;-*-*-                        ZeroA                           ;   clip_xmin = 0
 189+ F5AC              ;-*-*-                        ld      (clip_xmin),a           ;   .
 190+ F5AC              ;-*-*-                        ld      (clip_xmin+1),a         ;   .
 191+ F5AC              ;-*-*-                        ld      (clip_xmax+1),a         ;   clip_xmax = 255
 192+ F5AC              ;-*-*-                        dec     a                       ;   .
 193+ F5AC              ;-*-*-                        ld      (clip_xmax),a           ;   .
 194+ F5AC              ;-*-*-.DoneSignSetup:
 195+ F5AC              ;-*-*-;                       Set up Delta x = x2 - x1
 196+ F5AC              ;-*-*-.CalcDeltas:            ex      de,hl                   ; de = x1 hl = x2
 197+ F5AC              ;-*-*-                        push    hl                      ; save x2                       Stack+1
 198+ F5AC              ;-*-*-                        ClearCarryFlag                  ; delta_x = x2 - x1
 199+ F5AC              ;-*-*-                        sbc     hl,de                   ; .
 200+ F5AC              ;-*-*-                        ld      (delta_x),hl            ; .
 201+ F5AC              ;-*-*-;                       Set up Delta X step
 202+ F5AC              ;-*-*-                        ClearCarryFlag                  ; multiply by 2
 203+ F5AC              ;-*-*-                        adc     hl,hl                   ; .
 204+ F5AC              ;-*-*-                        ld      (delta_x_step),hl       ; delta_x_step = delta x * 2
 205+ F5AC              ;-*-*-                        pop     hl                      ; Restore X2                     Stack+0
 206+ F5AC              ;-*-*-                        ; now hl = x2 and de = x1
 207+ F5AC              ;-*-*-;                       Set up Delta y = y2 - y1
 208+ F5AC              ;-*-*-.CalcDeltaY:            exx                             ; hl = y1 de = y2, we don't save hl,de as we will load later
 209+ F5AC              ;-*-*-                        ld      (y1Work),hl             ; y1Work = y1
 210+ F5AC              ;-*-*-                        push    hl                      ; save y1 so that it can be loaded to HL later
 211+ F5AC              ;-*-*-                        ld      (y2Work),de             ; y2Work = y2
 212+ F5AC              ;-*-*-                        ex      de,hl                   ; set de to y2Work and hl to y1Work
 213+ F5AC              ;-*-*-                        ClearCarryFlag                  ; delta_y = y2 - y1
 214+ F5AC              ;-*-*-                        sbc     hl,de                   ; .
 215+ F5AC              ;-*-*-                        ld      (delta_y),hl            ; .
 216+ F5AC              ;-*-*-;                       Set up Delta Y step
 217+ F5AC              ;-*-*-                        ClearCarryFlag                  ; multiply by 2
 218+ F5AC              ;-*-*-                        adc     hl,hl                   ; .
 219+ F5AC              ;-*-*-                        ld      (delta_y_step),hl       ; delta_y_step = delta y * 2
 220+ F5AC              ;-*-*-                        ; now hl = y1 de = y2
 221+ F5AC              ;-*-*-;                       x_pos = x1, y_pos = y1
 222+ F5AC              ;-*-*-.SavePositions:         exx                             ; de = x1 hl = x2
 223+ F5AC              ;-*-*-                        ld      (x1Work),de             ; x1Work = x1
 224+ F5AC              ;-*-*-                        ld      (x2Work),hl             ; x2Work = x2
 225+ F5AC              ;-*-*-                        ;ex      de,hl                   ; hl = x1 de = x2
 226+ F5AC              ;-*-*-                        pop     hl                      ; y_pos = hl = y1   = y_pos     Stack+0
 227+ F5AC              ;-*-*-                        ld      (x_pos),de              ; .
 228+ F5AC              ;-*-*-                        ld      (y_pos),hl              ; .
 229+ F5AC              ;-*-*-;                       Check for Delta X >= Delta Y and do respective code version
 230+ F5AC              ;-*-*-.CheckDeltaXGTEDeltaY:  ld      hl,(delta_x)            ; hl = delta x
 231+ F5AC              ;-*-*-                        ld      de,(delta_y)            ; de = delta y
 232+ F5AC              ;-*-*-                        call    CompareHLDESigned       ; if data x < deltay
 233+ F5AC              ;-*-*-                        jp      c, DeltaXltDeltaY
 234+ F5AC              ;-*-*-;..................................................................................................................................
 235+ F5AC              ;-*-*-;                       this is where dx >= dy
 236+ F5AC              ;-*-*-;--- Delta X >= DeltaY ---------------------------------;    error = delta y_step - delta x
 237+ F5AC              ;-*-*-;                       Error = delta Y Step - Delta X and set Exit false
 238+ F5AC              ;-*-*-L2DeltaXgteDeltaY:      ErrorEquStepMinusDelta delta_y_step, delta_x ; this also sets de to delta x
 239+ F5AC              ;-*-*-                        SetExitFalse                    ;    set exit = false
 240+ F5AC              ;-*-*-;---                    if y < 0 then set y = 0 & save X pos to targetArray[0]..;
 241+ F5AC              ;-*-*-.IsY1TL0:               IsAxisLT0 (y1Work)              ;    if y1 < 0
 242+ F5AC              ;-*-*-                        jp     z,.Y1IsNotLT0           ;    .
 243+ F5AC              ;-*-*-;                       ... temp = 2 * (-y1) -1 * delta X
 244+ F5AC              ;-*-*-.Y1IsLT0:               ex      de,hl                   ;       de = delta x
 245+ F5AC              ;-*-*-                        ld      hl,(y1Work)             ;       temp = (2 * (0 - y1) - 1) * delta_x; Note from entering de = delta_x
 246+ F5AC              ;-*-*-                        NegHL                        ;       .      (0-y1 also equals negate y1)
 247+ F5AC              ;-*-*-                        ClearCarryFlag                  ;       .
 248+ F5AC              ;-*-*-                        adc     hl,hl                   ;       .      (y1 = y1 * 2)
 249+ F5AC              ;-*-*-                        dec     hl                      ;       .      (y1 = y1 -1)
 250+ F5AC              ;-*-*-                        call    mulHLbyDE2sc            ;       .      (multiply by de which is delta x)
 251+ F5AC              ;-*-*-                        ld      (linetemp),hl           ;       .      (and save to linetemp)
 252+ F5AC              ;-*-*-                        ld      de,(delta_y_step)       ;       .  (set BC to divq floor bc/de)
 253+ F5AC              ;-*-*-                        ex      de,hl                   ;       msd = floor_divq (temp, delta_y_step)
 254+ F5AC              ;-*-*-;                       ... msd = floor (temp , delta y step)
 255+ F5AC              ;-*-*-                        FloorHLdivDETarget msd          ;       .
 256+ F5AC              ;-*-*-;                       ... xpos += msd
 257+ F5AC              ;-*-*-                        ex      hl,de                   ;       x pos += msd (move msd to de)
 258+ F5AC              ;-*-*-                        ld      hl,(x_pos)              ;       .            (pull in x1temp and add de)
 259+ F5AC              ;-*-*-                        add     hl,de                   ;       .
 260+ F5AC              ;-*-*-                        ld      (x_pos),hl              ;       .            (store result in x_pos)
 261+ F5AC              ;-*-*-;                       ... if x_pos > clip_xmax then return
 262+ F5AC              ;-*-*-.IsXposGTClipXMax:      ld      de,(clip_xmax)          ;       if x_pos > clip_xmax then return
 263+ F5AC              ;-*-*-                        call    CompareHLDESigned               ;       .
 264+ F5AC              ;-*-*-                        jr      z,.XPosLTEXMax         ;       .
 265+ F5AC              ;-*-*-                        ret     nc                      ;       .
 266+ F5AC              ;-*-*-.XPosLTEXMax:
 267+ F5AC              ;-*-*-;                       ... if x_pos > clip_xmin
 268+ F5AC              ;-*-*-.IsXposGTEClipXmin:     ld      de,(clip_xmin)          ;       if x_pos >= clip_xmin
 269+ F5AC              ;-*-*-                        call    CompareHLDESigned               ;       .
 270+ F5AC              ;-*-*-                        jr      z,.XposLTClipXmin       ;       .
 271+ F5AC              ;-*-*-                        jr      c,.XposLTClipXmin       ;
 272+ F5AC              ;-*-*-;                       ... ... then rem = temp - msd * delta y step
 273+ F5AC              ;-*-*-.XposGTEClipXMin:       ld      hl,(msd)                ;          rem = temp - msd * delta_y_step
 274+ F5AC              ;-*-*-                        ld      de,(delta_y_step)       ;          .     (de =  delta_y_step)
 275+ F5AC              ;-*-*-                        call    mulHLbyDE2sc            ;          .     (hl = msd * delta y step)
 276+ F5AC              ;-*-*-                        ex      de,hl                   ;          .     (de = hl)
 277+ F5AC              ;-*-*-                        ld      hl,(linetemp)           ;          .     (hl = linetemp)
 278+ F5AC              ;-*-*-                        ClearCarryFlag                  ;          .
 279+ F5AC              ;-*-*-                        sbc     hl,de                   ;          .     (hl = hl = de)
 280+ F5AC              ;-*-*-                        ld      (rem),hl                ;          .     (rem = result)
 281+ F5AC              ;-*-*-;                       ... ... y pos = 0
 282+ F5AC              ;-*-*-                        xor     a                       ;          y_pos = 0
 283+ F5AC              ;-*-*-                        ld      (y_pos),a               ;          .
 284+ F5AC              ;-*-*-                        ld      (y_pos+1),a             ;          .
 285+ F5AC              ;-*-*-;                       ... ... error = error - (rem + delta x)
 286+ F5AC              ;-*-*-                        ld      de,(delta_x)            ;          error -= rem + delta_x
 287+ F5AC              ;-*-*-                        add     hl,de                   ;          .      (hl = (rem still) (de = delta x) )
 288+ F5AC              ;-*-*-                        ex      de,hl                   ;          .      (move result into de)
 289+ F5AC              ;-*-*-                        ld      hl,(error)              ;          .      (get error into hl)
 290+ F5AC              ;-*-*-                        ClearCarryFlag                  ;          .      (error - de)
 291+ F5AC              ;-*-*-                        sbc     hl,de                   ;          .
 292+ F5AC              ;-*-*-                        ld      (error),hl              ;          .      (save in hl)
 293+ F5AC              ;-*-*-;                       ... ... if rem > 0
 294+ F5AC              ;-*-*-                        IsMem16GT0JumpFalse rem, .remNotGT0 ;      if (rem > 0)
 295+ F5AC              ;-*-*-;                       ... ... ... xpos ++
 296+ F5AC              ;-*-*-.remGT0:                ld      hl,x_pos                ;              x_pos += 1
 297+ F5AC              ;-*-*-                        inc     (hl)                    ;              .
 298+ F5AC              ;-*-*-;                       ... ... ... error += delta y step
 299+ F5AC              ;-*-*-                        ErrorPlusStep delta_y_step      ;              error += delta_y_step
 300+ F5AC              ;-*-*-;                       ... ... set exit true
 301+ F5AC              ;-*-*-.remNotGT0:             ld      a,$FF                   ;          set_exit = true
 302+ F5AC              ;-*-*-                        ld      (set_exit),a            ;          .
 303+ F5AC              ;-*-*-;                       ... ...  set target array [0] to xpos
 304+ F5AC              ;-*-*-                        ld      hl,(x_pos)              ;          targetArray[0] = x_pos
 305+ F5AC              ;-*-*-                        ld      (ix+0),l                ;          .  (targetArray is pointed to by ix)
 306+ F5AC              ;-*-*-                        ld      (ix+1),h                ;          .
 307+ F5AC              ;-*-*-.Y1IsNotLT0:
 308+ F5AC              ;-*-*-;                       x pos end = x2
 309+ F5AC              ;-*-*-.XposLTClipXmin:        ld      hl,(x2Work)             ;    x_pos_end = x2
 310+ F5AC              ;-*-*-                        ld      (x_pos_end),hl          ;    .
 311+ F5AC              ;-*-*-;                       if y2 > 127
 312+ F5AC              ;-*-*-.IsY2GT127:             ld      hl,(y2Work)             ;    if (y2 > 127)
 313+ F5AC              ;-*-*-                        IsHLGT127                       ;    .
 314+ F5AC              ;-*-*-                        jr      nz,.Y2LTE127            ;    .
 315+ F5AC              ;-*-*-;                       ... temp = delta x step * (127 - y1) + delta x
 316+ F5AC              ;-*-*-.Y2GT127:               ld      de,(y1Work)             ;       temp = delta_x_step * (127 - y1) + delta_x
 317+ F5AC              ;-*-*-                        ld      hl,127                  ;       .      (de = y1work)
 318+ F5AC              ;-*-*-                        ClearCarryFlag                  ;       .      (hl = 127 )
 319+ F5AC              ;-*-*-                        sbc     hl,de                   ;       .      (hl - de)
 320+ F5AC              ;-*-*-                        ld      de,(delta_x_step)       ;       .      (de = delta x step)
 321+ F5AC              ;-*-*-                        call    mulHLbyDE2sc                    ;       .      (hl = hl * de)
 322+ F5AC              ;-*-*-                        ld      de,(delta_x)            ;       .      (de = delta x)
 323+ F5AC              ;-*-*-                        add     hl,de                   ;       .      (hl + de)
 324+ F5AC              ;-*-*-                        ld      (linetemp),hl           ;       .      (and save to line temp)
 325+ F5AC              ;-*-*-                        ld      de,(delta_y_step)       ;       de = delta y step
 326+ F5AC              ;-*-*-                        ex      de,hl                   ;       de = linetemp hl = delta y step
 327+ F5AC              ;-*-*-;                       ... msd = floor_divq (temp, delta y step)
 328+ F5AC              ;-*-*-                        FloorHLdivDETarget msd          ;       msd = floor_divq(temp,delta_y_step); (hl=de/hl)
 329+ F5AC              ;-*-*-                        ld      bc,hl                   ;       save off msd as we will need it again
 330+ F5AC              ;-*-*-                        ld      de,(x1Work)             ;
 331+ F5AC              ;-*-*-;                       ... xpos_end = x1 + msd
 332+ F5AC              ;-*-*-                        add     hl,de                   ;       x_pos_end = x1 + msd;
 333+ F5AC              ;-*-*-                        ld      (x_pos_end),hl          ;
 334+ F5AC              ;-*-*-;                       ... if (temp - msd * delta y step)) == 0
 335+ F5AC              ;-*-*-                        ld      hl,bc                   ;       if ((temp - msd * delta_y_step) == 0) --x_pos_end;
 336+ F5AC              ;-*-*-                        ld      de,(delta_y_step)       ;       .    (hl = msd * delta_y_step)
 337+ F5AC              ;-*-*-                        call    mulHLbyDE2sc            ;       .
 338+ F5AC              ;-*-*-                        ex      hl,de                   ;       .    (hl = linetemp - hl
 339+ F5AC              ;-*-*-                        ld      hl,(linetemp)           ;       .
 340+ F5AC              ;-*-*-                        ClearCarryFlag                  ;       .
 341+ F5AC              ;-*-*-                        sbc     hl,de                   ;       .
 342+ F5AC              ;-*-*-                        jr      nz,.Calc1NotZero        ;       .
 343+ F5AC              ;-*-*-;                       ... ... x pos end minus 1
 344+ F5AC              ;-*-*-                        ld      hl,x_pos_end            ;           then -- x_pos_end
 345+ F5AC              ;-*-*-                        dec     (hl)                    ;           .
 346+ F5AC              ;-*-*-.Calc1NotZero:
 347+ F5AC              ;-*-*-;                       if sign_x == -1
 348+ F5AC              ;-*-*-.Y2LTE127:              break
 349+ F5AC              ;-*-*-                        IsMemNegative8JumpFalse sign_x, .SignXNotNegative ; just check if its negative
 350+ F5AC              ;-*-*-;                       ... xpos = - xpos
 351+ F5AC              ;-*-*-.SignXNegative:         ld      hl,(x_pos)              ;       x_pos = -x_pos
 352+ F5AC              ;-*-*-                        NegHL                           ;       .
 353+ F5AC              ;-*-*-                        ld      (x_pos),hl              ;       .
 354+ F5AC              ;-*-*-;                       ... xpos end = - xpos end
 355+ F5AC              ;-*-*-                        ld      hl,(x_pos_end)          ;       x_pos_end = -x_pos_end
 356+ F5AC              ;-*-*-                        NegHL                           ;       .
 357+ F5AC              ;-*-*-                        ld      (x_pos_end),hl          ;       .
 358+ F5AC              ;-*-*-                        dec     (hl)                    ;       .
 359+ F5AC              ;-*-*-;                       delta x step = delta x step - delta y step
 360+ F5AC              ;-*-*-.SignXNotNegative:      ld      hl,(delta_x_step)       ;    delta_x_step -= delta_y_step
 361+ F5AC              ;-*-*-                        ld      de,(delta_y_step)       ;    .
 362+ F5AC              ;-*-*-                        ClearCarryFlag                  ;    .
 363+ F5AC              ;-*-*-                        sbc     hl,de                   ;    .
 364+ F5AC              ;-*-*-                        ld      (delta_x_step),hl       ;    .
 365+ F5AC              ;-*-*-;..................................................................................................................................
 366+ F5AC              ;-*-*-;--- DxFTEDyNotLongest while loop ----------------------;
 367+ F5AC              ;-*-*-L2DxGTEDy:                ld      bc,(x_pos)              ;    while (x_pos != x_pos_end) loading bc with xppos an de as x_pos_end
 368+ F5AC              ;-*-*-                        ld      de,(x_pos_end)          ;    .
 369+ F5AC              ;-*-*-                        ld      hl,ix                   ;    load hl as target array
 370+ F5AC              ;-*-*-                        ld      a,(y_pos)               ;    by this point y pos must be 8 bit
 371+ F5AC              ;-*-*-                        add     hl,a                    ;    So we are setting up hl as targetArray pointer
 372+ F5AC              ;-*-*-                        add     hl,a                    ;    .
 373+ F5AC              ;-*-*-;..................................................................................................................................
 374+ F5AC              ;-*-*-;--- Version where longest is not saved ----------------;
 375+ F5AC              ;-*-*-                        exx                             ;      switch to alternate registers
 376+ F5AC              ;-*-*-                        ld      hl,(error)              ;      load up stepping into alternate registers
 377+ F5AC              ;-*-*-                        ld      de,(delta_x_step)       ;      .
 378+ F5AC              ;-*-*-                        ld      bc,(delta_y_step)       ;      .
 379+ F5AC              ;-*-*-                        exx                             ;      .
 380+ F5AC              ;-*-*-                        ld      a,(sign_x)              ;      Self modify inc of y_pos
 381+ F5AC              ;-*-*-                        and     $80                     ;
 382+ F5AC              ;-*-*-                        jr      z,.SetWhileInc          ;
 383+ F5AC              ;-*-*-.SetWhileDec:           ld      a,InstrDECBC
 384+ F5AC              ;-*-*-                        ld      (.WhileIncInstuction), a
 385+ F5AC              ;-*-*-                        jp      .WhileLoop
 386+ F5AC              ;-*-*-.SetWhileInc:           ld      a,InstrINCBC
 387+ F5AC              ;-*-*-                        ld      (.WhileIncInstuction), a
 388+ F5AC              ;-*-*-;--- Update Loop ---------------------------------------;
 389+ F5AC              ;-*-*-; In loop hl  = target array pointer bc = x_pos,       de = x_pos_end, (we don't need to reatin Y_pos)
 390+ F5AC              ;-*-*-;         hl' = error                bc'= delta_y_step de'=delta_x_step
 391+ F5AC              ;-*-*-.WhileLoop:             call    CompareBCDESigned       ;      while x_pos != x_pos_end
 392+ F5AC              ;-*-*-                        ret     z                       ;      .
 393+ F5AC              ;-*-*-                        call    L2_plotAtRowLColC       ;        targetArray[y_pos] = x_pos
 394+ F5AC              ;-*-*-                        exx                             ;        if error >= 0
 395+ F5AC              ;-*-*-                        bit     7,h                     ;        .
 396+ F5AC              ;-*-*-                        jr      nz,.ErrorNegative       ;        .
 397+ F5AC              ;-*-*-.ErrorPositive:         ClearCarryFlag                  ;             error -= delta_x_step
 398+ F5AC              ;-*-*-                        sbc     hl,de                   ;             .
 399+ F5AC              ;-*-*-                        exx                             ;             back to main regsters
 400+ F5AC              ;-*-*-                        inc     hl                      ;             y pos for target Array index +2
 401+ F5AC              ;-*-*-                        inc     hl                      ;             as its 16 bit
 402+ F5AC              ;-*-*-                        jp      .WhileIncInstuction     ;             .
 403+ F5AC              ;-*-*-.ErrorNegative:         add     hl,bc                   ;        else error += delta y step
 404+ F5AC              ;-*-*-                        exx                             ;             back to main regsters
 405+ F5AC              ;-*-*-.WhileIncInstuction:    inc     bc                      ;       x_pos += sign_x (doneas self modifying to inc or dec)
 406+ F5AC              ;-*-*-                        jp      .WhileLoop
 407+ F5AC              ;-*-*-;..................................................................................................................................;--- Delta X < DeltaY ----------------------------------;
 408+ F5AC              ;-*-*-;--- ELSE ----------------------------------------------;
 409+ F5AC              ;-*-*-;--- DX < DY -------------------------------------------;
 410+ F5AC              ;-*-*-;..................................................................................................................................;--- Delta X < DeltaY ----------------------------------;
 411+ F5AC              ;-*-*-;                       error = delta x_step - delta y
 412+ F5AC              ;-*-*-L2DeltaXltDeltaY:       ErrorEquStepMinusDelta delta_x_step, delta_y
 413+ F5AC              ;-*-*-;                       set exit false
 414+ F5AC              ;-*-*-                        SetExitFalse                    ; set exit = false
 415+ F5AC              ;-*-*-;                       if x1 < xmin && y pos > 127 then exit early
 416+ F5AC              ;-*-*-.IsY1TL0:               ld      hl,(x1Work)             ; if x1 < clip xmin
 417+ F5AC              ;-*-*-                        ld      de,(clip_xmin)          ; .
 418+ F5AC              ;-*-*-                        call    CompareHLDESigned               ; .
 419+ F5AC              ;-*-*-                        jp      z, .X1gteClipMin        ; .
 420+ F5AC              ;-*-*-                        jp      c, .X1ltClipMin         ; and y_pos > 127
 421+ F5AC              ;-*-*-                        ld      hl,(y1Work)             ;
 422+ F5AC              ;-*-*-.X1gteClipMin:          ReturnIfHLGT127                 ;    then return
 423+ F5AC              ;-*-*-;                       if y1 work < 0
 424+ F5AC              ;-*-*-.X1ltClipMin:           IsAxisLT0 (y1Work)              ; if y1 < 0             ;
 425+ F5AC              ;-*-*-                        jr      z,.Y1IsNotLT0           ; .
 426+ F5AC              ;-*-*-;                       ... temp = delta x step * (-y1)
 427+ F5AC              ;-*-*-.Y1IsLT0:               ld      hl,(y1Work)             ;    temp = (0 - y1) * delta_x_step;
 428+ F5AC              ;-*-*-                        NegHL                        ;    . (0 - y1 also equals negate HL)
 429+ F5AC              ;-*-*-                        ClearCarryFlag                  ;    .
 430+ F5AC              ;-*-*-                        ld      de,(delta_x_step)       ;    .
 431+ F5AC              ;-*-*-                        call    mulHLbyDE2sc            ;    .
 432+ F5AC              ;-*-*-                        ld      (linetemp),hl           ;    .
 433+ F5AC              ;-*-*-;                       ... msd = floor_divq (temp, delta y step)
 434+ F5AC              ;-*-*-                        ld      de,(delta_y_step)       ;    msd = floor_divq (temp, delta_y_step);
 435+ F5AC              ;-*-*-;                       ... rem calculation now done in floor macro above into de
 436+ F5AC              ;-*-*-                        FloorHLdivDETarget msd          ;    .
 437+ F5AC              ;-*-*-                        ld      (rem),de                ;    As DE = reminder we can do rem = temp % delta_y_step; for free
 438+ F5AC              ;-*-*-;                       ... xpos = xpos + msd
 439+ F5AC              ;-*-*-                        ex      hl,de                   ;    x pos += msd (move msd to de)
 440+ F5AC              ;-*-*-                        ld      hl,(x_pos)              ;    .            (pull in x1temp and add de)
 441+ F5AC              ;-*-*-                        add     hl,de                   ;    .
 442+ F5AC              ;-*-*-                        ld      (x_pos),hl              ;    .            (store result in x_pos)
 443+ F5AC              ;-*-*-;                       ... if xpos > xmax
 444+ F5AC              ;-*-*-.IsXposGTClipXMax:      ld      de,(clip_xmax)          ;    if x_pos > clip_xmax then return
 445+ F5AC              ;-*-*-                        call      CompareHLDESigned               ;    .
 446+ F5AC              ;-*-*-;                       ...    or (pos = xmax && rem >= delta y) then return
 447+ F5AC              ;-*-*-                        jr      z,.XPosLTEXMax          ;    .
 448+ F5AC              ;-*-*-                        ret     nc                      ;    .
 449+ F5AC              ;-*-*-.XPosLTEXMax:           ld      de,(clip_xmin)          ;    if x_pos == clip_xmin
 450+ F5AC              ;-*-*-                        call      CompareHLDESigned               ;    .
 451+ F5AC              ;-*-*-                        jr      nz,.XneClipMax          ;    and rem >= deltay
 452+ F5AC              ;-*-*-                        ld      hl,(rem)                ;    .
 453+ F5AC              ;-*-*-                        ld      de,(delta_y)            ;    .
 454+ F5AC              ;-*-*-                        call      CompareHLDESigned               ;    .
 455+ F5AC              ;-*-*-                        ret     c                       ;    then return
 456+ F5AC              ;-*-*-;                       ... save rem and set y pos to 0
 457+ F5AC              ;-*-*-                        ex      de,hl                   ;    save rem
 458+ F5AC              ;-*-*-                        ld      hl,0                    ;    y_pos = 0
 459+ F5AC              ;-*-*-;                       ... error = error + rem
 460+ F5AC              ;-*-*-                        ld      (y_pos),hl              ;    error += rem
 461+ F5AC              ;-*-*-                        ld      hl,(error)              ;    .
 462+ F5AC              ;-*-*-                        add     hl,de                   ;    .
 463+ F5AC              ;-*-*-                        ld      (error),hl              ;    .
 464+ F5AC              ;-*-*-;                       ... if rem >= delta y
 465+ F5AC              ;-*-*-                        ex      de,hl                   ;    if (rem >= delta_y)
 466+ F5AC              ;-*-*-                        ld      de,(delta_y)            ;    .
 467+ F5AC              ;-*-*-                        call      CompareHLDESigned               ;    .
 468+ F5AC              ;-*-*-                        jr      z,.RemGTEDeltaY         ;    .
 469+ F5AC              ;-*-*-                        jr      nc,.RemGTEDeltaY        ;    .
 470+ F5AC              ;-*-*-;                       ... ... x pos = x pos + 1
 471+ F5AC              ;-*-*-                        ld      hl,x_pos                ;       ++x_pos
 472+ F5AC              ;-*-*-                        inc     (hl)                    ;       .
 473+ F5AC              ;-*-*-                        ld      hl,(error)              ;       error += delta_y_step
 474+ F5AC              ;-*-*-                        ld      de,(delta_y_step)       ;       .
 475+ F5AC              ;-*-*-                        add     hl,de                   ;       .
 476+ F5AC              ;-*-*-                        ld      (error),hl              ;       .
 477+ F5AC              ;-*-*-.RemGTEDeltaY:
 478+ F5AC              ;-*-*-.Y1IsNotLT0:
 479+ F5AC              ;-*-*-.XneClipMax:            ld      hl,(y2Work)             ;  y_pos_end = y2
 480+ F5AC              ;-*-*-                        ld      (y_pos_end),hl          ;  .
 481+ F5AC              ;-*-*-                        ld      de,127                  ;  y_pos_end = (y_pos_end < 127)?y_pos_end+1:128
 482+ F5AC              ;-*-*-                        call      CompareHLDESigned               ;  .
 483+ F5AC              ;-*-*-                        jr      nc,.YPosEndlt127        ;  .
 484+ F5AC              ;-*-*-                        ld      hl,128                  ;  .
 485+ F5AC              ;-*-*-                        jp      .DoneXneClipMax         ;  .
 486+ F5AC              ;-*-*-.YPosEndlt127:          inc     hl                      ;  .
 487+ F5AC              ;-*-*-.DoneXneClipMax:        ld      (y_pos_end),hl          ;  .
 488+ F5AC              ;-*-*-                                                        ; if sign_x == -1
 489+ F5AC              ;-*-*-.Y2LTE127:              IsMemNegative8JumpFalse sign_x, .SignXNotNegative
 490+ F5AC              ;-*-*-.SignXNegative:         ld      hl,(x_pos)              ;    x_pos = -x_pos
 491+ F5AC              ;-*-*-                        NegHL                        ;    .
 492+ F5AC              ;-*-*-                        ld      (x_pos),hl              ;    .
 493+ F5AC              ;-*-*-                        ld      hl,(y2Work)             ;    x_pos_end = -x_pos_end
 494+ F5AC              ;-*-*-.SignXNotNegative:      ld      hl,(delta_y_step)       ; delta_y_step -= delta_x_step
 495+ F5AC              ;-*-*-                        ld      de,(delta_x_step)       ; .
 496+ F5AC              ;-*-*-                        ClearCarryFlag                  ; .
 497+ F5AC              ;-*-*-                        sbc     hl,de                   ; .
 498+ F5AC              ;-*-*-                        ld      hl,(delta_x_step)       ; .
 499+ F5AC              ;-*-*-;..................................................................................................................................
 500+ F5AC              ;-*-*-;--- Dx < Dy Longest while loop ------------------------;
 501+ F5AC              ;-*-*-L2DxLTDy:               ld      hl,(y_pos)              ;       starty=y_pos
 502+ F5AC              ;-*-*-                        ld      (starty),hl             ;       .
 503+ F5AC              ;-*-*-;--- Version where longest issaved ---------------------;
 504+ F5AC              ;-*-*-.LoadAlternateRegs:     ld      bc,(y_pos)              ;       we already have IY so just need xpos and end
 505+ F5AC              ;-*-*-                        ld      de,(y_pos_end)
 506+ F5AC              ;-*-*-                        ld      iy,(x_pos)
 507+ F5AC              ;-*-*-                        ld      hl,ix                   ;    load hl as target array
 508+ F5AC              ;-*-*-                        ld      a,c                     ;    by this point y pos must be 8 bit
 509+ F5AC              ;-*-*-                        add     hl,a                    ;    So we are setting up hl as targetArray pointer
 510+ F5AC              ;-*-*-                        add     hl,a
 511+ F5AC              ;-*-*-                        exx                             ;       switch to alternate registers
 512+ F5AC              ;-*-*-                        ld      hl,(error)              ;       load up stepping into alternate registers
 513+ F5AC              ;-*-*-                        ld      de,(delta_x_step)       ;       and error
 514+ F5AC              ;-*-*-                        ld      bc,(delta_y_step)       ;
 515+ F5AC              ;-*-*-                        exx                             ;       and then switch back to main registers
 516+ F5AC              ;-*-*-                        ld      a,(sign_x)              ;       if Sign x is -1
 517+ F5AC              ;-*-*-                        and     $80                     ;       .
 518+ F5AC              ;-*-*-                        jr      z,.SetWhileInc          ;       .
 519+ F5AC              ;-*-*-.SetWhileDec:           ld      a,InstrDECIY
 520+ F5AC              ;-*-*-                        ld      (.WhileIncInstuction+1),a; set self modifying to dec and 2 byte instruction
 521+ F5AC              ;-*-*-                        jp      .WhileLoop:             ;       .
 522+ F5AC              ;-*-*-.SetWhileInc:           ld      a,InstrINCIY
 523+ F5AC              ;-*-*-                        ld      (.WhileIncInstuction+1),a; else set to inc
 524+ F5AC              ;-*-*-;--- Update Loop ---------------------------------------;
 525+ F5AC              ;-*-*-; In loop hl  = target array pointer bc = x_pos,       de = x_pos_end, (we don't need to reatin Y_pos)
 526+ F5AC              ;-*-*-;         hl' = error                bc'= delta_y_step de'=delta_x_step
 527+ F5AC              ;-*-*-;- we coudl optimise by setting bc to y_pos_end - y_pos +1 and just doing djnz
 528+ F5AC              ;-*-*-.WhileLoop:             call    CompareBCDESigned       ;      while y_pos != y_pos_end
 529+ F5AC              ;-*-*-                        ret     z                       ;      .
 530+ F5AC              ;-*-*-                        ld      a,iyl
 531+ F5AC              ;-*-*-                        call    L2_plotAtRowLColA       ; targetArray[y_pos] = x_pos
 532+ F5AC              ;-*-*-                        inc     hl
 533+ F5AC              ;-*-*-                        ld      a,iyh
 534+ F5AC              ;-*-*-                        ld      (hl),a
 535+ F5AC              ;-*-*-                        inc     hl
 536+ F5AC              ;-*-*-                        exx                             ;        if error >= 0
 537+ F5AC              ;-*-*-                        bit     7,h                     ;        .
 538+ F5AC              ;-*-*-                        jr      nz,.ErrorNegative       ;        .
 539+ F5AC              ;-*-*-.WhileIncInstuction:    inc     iy                      ;             x_pos += sign_x (doneas self modifying to inc or dec)
 540+ F5AC              ;-*-*-.ErrorPositive:         ClearCarryFlag                  ;             error -= delta_y_step
 541+ F5AC              ;-*-*-                        sbc     hl,bc                   ;             .
 542+ F5AC              ;-*-*-                        jp      .LoopEnd                ;             .
 543+ F5AC              ;-*-*-.ErrorNegative:         add     hl,de                   ;        else error += delta x step
 544+ F5AC              ;-*-*-.LoopEnd:               exx                             ;             back to main regsters
 545+ F5AC              ;-*-*-                        inc     bc                      ;        ++y_pos
 546+ F5AC              ;-*-*-                        jp      .WhileLoop
 547+ F5AC              ;-*-*-
 548+ F5AC              ;-*-*-
 549+ F5AC              ;-*-*-;---------------------------------
 550+ F5AC              ;-*-*-L2_plotAtRowLColC:      ld      a,c
 551+ F5AC              ;-*-*-L2_plotAtRowLColA:      push    bc,,de,,hl,,af
 552+ F5AC              ;-*-*-                        ex      af,af'
 553+ F5AC              ;-*-*-                        push    af
 554+ F5AC              ;-*-*-                        ex      af,af'
 555+ F5AC              ;-*-*-                        ld      b,l
 556+ F5AC              ;-*-*-                        ld      c,a
 557+ F5AC              ;-*-*-                        ld      a,$FF                   ; white for now
 558+ F5AC              ;-*-*-                        call    l2_plot_pixel
 559+ F5AC              ;-*-*-                        pop     af
 560+ F5AC              ;-*-*-                        ex      af,af'
 561+ F5AC              ;-*-*-                        pop     bc,,de,,hl,,af
 562+ F5AC              ;-*-*-                        ret
 563+ F5AC              ;-*-*-
 564+ F5AC
 565+ F5AC 00 00        x1                      dw 0
 566+ F5AE 00 00        y1                      dw 0
 567+ F5B0 00 00        x2                      dw 0
 568+ F5B2 00 00        y2                      dw 0
 569+ F5B4 00 00        savex1                  dw 0
 570+ F5B6 00 00        savey1                  dw 0
 571+ F5B8 00 00        savex2                  dw 0
 572+ F5BA 00 00        savey2                  dw 0
 573+ F5BC 00 00        temp                    dw 0
 574+ F5BE 00           longest:                DB 0
 575+ F5BF 00 00        x1Work:                 DW 0
 576+ F5C1 00 00        y1Work:                 DW 0
 577+ F5C3 00 00        x2Work:                 DW 0
 578+ F5C5 00 00        y2Work:                 DW 0
 579+ F5C7 00 00        x_pos:                  DW 0
 580+ F5C9 00 00        y_pos:                  DW 0
 581+ F5CB 00 00        x_pos_end:              DW 0
 582+ F5CD 00 00        y_pos_end:              DW 0
 583+ F5CF 00 00        clip_xmax:              DW 0
 584+ F5D1 00 00        clip_xmin:              DW 0
 585+ F5D3 00 00        sign_x                  DW 0
 586+ F5D5 00           sign_y                  DB 0
 587+ F5D6 00 00        delta_x                 DW 0
 588+ F5D8 00 00        delta_y                 DW 0
 589+ F5DA 00 00        delta_y_x               DW 0 ; holds the compressed version for elite line draw
 590+ F5DC 00 00        delta_x_step            DW 0
 591+ F5DE 00 00        delta_y_step            DW 0
 592+ F5E0 00 00        linetemp                DW 0
 593+ F5E2 00 00        gradient                DW 0
 594+ F5E4 00 00        tSlope                  DW 0
 595+ F5E6 00 00        msd                     DW 0
 596+ F5E8 00 00        error                   DW 0
 597+ F5EA 00           set_exit                DB 0
 598+ F5EB 00 00        rem                     DW 0
 599+ F5ED              InstrDECBC              equ $0B
 600+ F5ED              InstrINCBC              equ $03
 601+ F5ED              InstrDECIY              equ $2B
 602+ F5ED              InstrINCIY              equ $23
 603+ F5ED
 604+ F5ED              MACROAequBMinusC16:     MACRO   pA, pB, pC
 605+ F5ED ~                                    ld      hl,(pB)                         ;       error = delta_y_step - delta_x;
 606+ F5ED ~                                    ld      de,(pC)                         ; .
 607+ F5ED ~                                    ClearCarryFlag                          ; .
 608+ F5ED ~                                    sbc     hl,de                           ; .
 609+ F5ED ~                                    ld      (pA),hl
 610+ F5ED                                      ENDM
 611+ F5ED              ;--- Swaps point 1 and point 2 around (i.e x1 y1 <--> x2 y2)
 612+ F5ED 2A AE F5     SwapCoords:             ld      hl,(y1)                         ;       then swap point 1 and point 2
 613+ F5F0 ED 5B B2 F5                          ld      de,(y2)                         ;       .
 614+ F5F4 ED 53 AE F5                          ld      (y1),de                         ;       .
 615+ F5F8 22 B2 F5                             ld      (y2),hl                         ;       .
 616+ F5FB 2A AC F5                             ld      hl,(x1)                         ;       .
 617+ F5FE ED 5B B0 F5                          ld      de,(x2)                         ;       .
 618+ F602 ED 53 AC F5                          ld      (x1),de                         ;       .
 619+ F606 22 B0 F5                             ld      (x2),hl                         ;       .
 620+ F609 C9                                   ret
 621+ F60A
 622+ F60A                      ; DEFINE SPLITLINE 1
 623+ F60A
 624+ F60A                      DEFINE CLIPPED_LINEX 1
 625+ F60A                      DEFINE SPLITORLINEX  1
 626+ F60A                      IFDEF SPLITLINE
 626+ F60A ~
 627+ F60A ~            l2_draw_clipped_line:
 628+ F60A                      ENDIF
 629+ F60A                      IFDEF CLIPPED_LINEX
 629+ F60A
 630+ F60A              l2_draw_clipped_lineX:
 631+ F60A                      ENDIF
 632+ F60A                      IFDEF SPLITORLINEX
 633+ F60A 2A AE F5                             ld      hl,(y1)                         ; if (y1 > y2)
 634+ F60D ED 5B B2 F5                          ld      de,(y2)                         ; .
 635+ F611 CD 56 76                             call    CompareHLDESgn                  ; .
 636+ F614 DA 1A F6                             jp      c,.NoSwapCoords
 637+ F617 CD ED F5     .SwapCoords:            call    SwapCoords
 638+ F61A              .NoSwapCoords:
 639+ F61A ED 5B AE F5  .CalcDX:                ld      de,(y1)                         ; Calculate |dy|
 640+ F61E 2A B2 F5                             ld      hl,(y2)                         ; .
 641+ F621                                      ClearCarryFlag                          ; .
 641+ F621 B7          >                        or a
 642+ F622 ED 52                                sbc     hl,de                           ; .
 643+ F624 E5 FD E1                             ld      iy,hl                           ; iy = |dy|
 644+ F627 ED 5B AC F5  .CalcDy:                ld      de,(x1)                         ; Calculate |dx|
 645+ F62B 2A B0 F5                             ld      hl,(x2)                         ; .
 646+ F62E 06 00                                ld      b,0                             ; assume x1 < x2 and assume no negate needed
 647+ F630 CD 56 76                             call    CompareHLDESgn                  ;
 648+ F633 D2 38 F6                             jp      nc,.DxNoSwap                     ;
 649+ F636 EB           .DxSwap:                ex      de,hl                           ; swap just x over
 650+ F637 04                                   inc     b                               ; and flag that we had to do it
 651+ F638              .DxNoSwap:              ClearCarryFlag                          ;
 651+ F638 B7          >                        or a
 652+ F639 ED 52                                sbc     hl,de                           ;
 653+ F63B E5 DD E1                             ld      ix,hl                           ; ix = |dx|
 654+ F63E DD 7C        .CheckForHuge:          ld      a,ixh                           ; if either dx or dy > 255 then split line
 655+ F640 FD B4                                or      iyh                             ; .
 656+ F642 C2 56 F6                             jp      nz, .BreakNeeded                ; .
 657+ F645 DD 7D        .ChecktGT180:           ld      a,ixl
 658+ F647 FE B4                                cp      180
 659+ F649 D2 56 F6                             jp      nc,.BreakNeeded
 660+ F64C FD 7D                                ld      a,iyl
 661+ F64E FE B4                                cp      180
 662+ F650 D2 56 F6                             jp      nc,.BreakNeeded
 663+ F653 C3 BA F6                             jp      .noBreakNeeded
 664+ F656              .BreakNeeded:           ldCopy2Byte y1, savey1                  ;       savey1 = y1                     create savey1 (y1) to savey2 (y break)
 664+ F656 2A AE F5    >                        ld       hl,(y1)
 664+ F659 22 B6 F5    >                        ld       (savey1),hl
 665+ F65C                                      ShiftIYRight1                           ;       savey2 = y1 + (work_dy/2)
 665+ F65C FD 7C       >			   ld 	a,iyh
 665+ F65E CB 3F       >			   srl 	a
 665+ F660 FD 67       >			   ld	iyh,a
 665+ F662 FD 7D       >			   ld 	a,iyl
 665+ F664 1F          >			   rra
 665+ F665 FD 6F       >			   ld	iyl,a
 666+ F667 2A AE F5                             ld      hl,(y1)                         ;       .
 667+ F66A                                      ClearCarryFlag                          ;       .
 667+ F66A B7          >                        or a
 668+ F66B FD 54 FD 5D                          ld      de,iy
 669+ F66F ED 5A                                adc     hl,de                           ;       .
 670+ F671 22 BA F5                             ld      (savey2),hl                     ;       .
 671+ F674 22 AE F5                             ld      (y1),hl                         ;       y1     = savey2, y2 untouched   create y1 (break) to y2
 672+ F677 05                                   dec     b                               ;       if b was 1 then decb would set z flag so we know that x1 > x2
 673+ F678 C2 7E F6                             jp      nz,.X1gtX2
 674+ F67B CD ED F5     .X1lteX2:               call    SwapCoords
 675+ F67E              .X1gtX2:                ldCopy2Byte x1, savex1                  ;       savex1 = x1                     create savex1 (x1) to savex2 (x break)
 675+ F67E 2A AC F5    >                        ld       hl,(x1)
 675+ F681 22 B4 F5    >                        ld       (savex1),hl
 676+ F684                                      ShiftIXRight1                           ;       savex2 = x1 + (work_dx/2)
 676+ F684 DD 7C       >			   ld 	a,ixh
 676+ F686 CB 3F       >			   srl 	a
 676+ F688 DD 67       >			   ld	ixh,a
 676+ F68A DD 7D       >			   ld 	a,ixl
 676+ F68C 1F          >			   rra
 676+ F68D DD 6F       >			   ld	ixl,a
 677+ F68F 2A AC F5                             ld      hl,(x1)                         ;       .
 678+ F692                                      ClearCarryFlag                          ;       .
 678+ F692 B7          >                        or a
 679+ F693 DD 54 DD 5D                          ld      de,ix
 680+ F697 ED 5A                                adc     hl,de                           ;       .
 681+ F699 22 B8 F5                             ld      (savex2),hl                     ;       .
 682+ F69C 22 AC F5                             ld      (x1),hl                         ;       x1     = savex1, x2 untouched  create x1 (break to x2)
 683+ F69F                      ENDIF
 684+ F69F                      IFDEF SPLITLINE
 685+ F69F ~                                    call    l2_draw_short_line              ;       drawshortLine
 686+ F69F                      ENDIF
 687+ F69F                      IFDEF CLIPPED_LINEX
 688+ F69F CD BA F6                             call    l2_draw_clipped_line
 689+ F6A2                      ENDIF
 690+ F6A2                      IFDEF SPLITORLINEX
 691+ F6A2                                      ldCopyWord savex1,x1
 691+ F6A2             >                        ldCopy2Byte savex1, x1
 691+ F6A2 2A B4 F5    >                        ld       hl,(savex1)
 691+ F6A5 22 AC F5    >                        ld       (x1),hl
 692+ F6A8                                      ldCopyWord savey1,y1
 692+ F6A8             >                        ldCopy2Byte savey1, y1
 692+ F6A8 2A B6 F5    >                        ld       hl,(savey1)
 692+ F6AB 22 AE F5    >                        ld       (y1),hl
 693+ F6AE                                      ldCopyWord savex2,x2
 693+ F6AE             >                        ldCopy2Byte savex2, x2
 693+ F6AE 2A B8 F5    >                        ld       hl,(savex2)
 693+ F6B1 22 B0 F5    >                        ld       (x2),hl
 694+ F6B4                                      ldCopyWord savey2,y2
 694+ F6B4             >                        ldCopy2Byte savey2, y2
 694+ F6B4 2A BA F5    >                        ld       hl,(savey2)
 694+ F6B7 22 B2 F5    >                        ld       (y2),hl
 695+ F6BA              .noBreakNeeded:         // Falls straight into l2_draw_short_line
 696+ F6BA                      ENDIF
 697+ F6BA                      IFDEF SPLITLINE
 697+ F6BA ~
 698+ F6BA ~            l2_draw_short_line:     ; check out of bounds
 699+ F6BA                      ENDIF
 700+ F6BA                      IFDEF CLIPPED_LINEX
 701+ F6BA              l2_draw_clipped_line:
 702+ F6BA                      ENDIF
 703+ F6BA                      IFDEF SPLITORLINEX
 704+ F6BA 2A AC F5     CheckForOnScreen:       ld      hl,(x1)
 705+ F6BD ED 5B B0 F5                          ld      de,(x2)
 706+ F6C1 CB 7C        .X1X2NegativeCheck:     bit     7,h                             ; if they are both negative then bail out
 707+ F6C3 28 03                                jr      z,.X1X2NotNegative
 708+ F6C5 CB 7A                                bit     7,d
 709+ F6C7 C0           .X1X2IsNegative:        ret     nz
 710+ F6C8 7C           .X1X2NotNegative:       ld      a,h                             ; if they are both not negative then if one is negative that is good
 711+ F6C9 AA                                   xor     d
 712+ F6CA FA D5 F6                             jp      m,.X1X2SpanScreen
 713+ F6CD 7C           .X1X2BothPositive:      ld      a,h                             ; if x1 or x2 high is zero then at least one pixel is on screen
 714+ F6CE A7                                   and     a
 715+ F6CF CA D5 F6                             jp      z,.X1X2SpanScreen
 716+ F6D2 7A                                   ld      a,d                             ; if x1 was > 255 then if x2 > 255 bail out
 717+ F6D3 A7                                   and     a
 718+ F6D4 C0                                   ret     nz
 719+ F6D5 2A AE F5     .X1X2SpanScreen:        ld      hl,(y1)
 720+ F6D8 ED 5B B2 F5                          ld      de,(y2)
 721+ F6DC CB 7C        .Y1Y2NegativeCheck:     bit     7,h                             ; if they are both negative then bail out
 722+ F6DE 28 03                                jr      z,.Y1Y2NotNegative
 723+ F6E0 CB 7A                                bit     7,d
 724+ F6E2 C0           .Y1Y2IsNegative:        ret     nz
 725+ F6E3 7C           .Y1Y2NotNegative:       ld      a,h                             ; if they are both not negative then if one is negative that is good
 726+ F6E4 AA                                   xor     d
 727+ F6E5 FA F7 F6                             jp      m,.Y1Y2SpanScreen
 728+ F6E8 01 80 00     .Y1Y2BothPositive:      ld      bc,128                          ; if they are both positive and at least one is < 128 then carry on
 729+ F6EB CD 8A 76                             call    CompareHLBC
 730+ F6EE 38 07                                jr      c,.Y1Y2SpanScreen
 731+ F6F0 EB                                   ex      de,hl                           ; save y1 into de
 732+ F6F1 CD 8A 76                             call    CompareHLBC
 733+ F6F4 38 01                                jr      c,.Y1Y2SpanScreen
 734+ F6F6 C9                                   ret
 735+ F6F7              .Y1Y2SpanScreen:
 736+ F6F7 CD 6D 76     CheckForHorizontal:     call    CompareHLDESame                 ; de = saved y1 , hl = y2
 737+ F6FA CA 26 F5                             jp      z, l2_drawVertClip
 738+ F6FD 2A AC F5     CheckForVertical:       ld      hl,(x1)
 739+ F700 ED 5B B0 F5                          ld      de,(x2)
 740+ F704 CD 6D 76                             call    CompareHLDESame
 741+ F707 CA 57 F5                             jp      z, l2_drawHorzClip
 742+ F70A                                      ; Need horizontal and vertical optimisation code in at thispoint
 743+ F70A 2A AE F5     CheckForSwap:           ld      hl,(y1)                         ; if (y1 > y2)
 744+ F70D ED 5B B2 F5                          ld      de,(y2)                         ; .
 745+ F711 CD 56 76                             call    CompareHLDESgn                  ; .
 746+ F714 DA 1A F7                             jp      c,.NoSwapCoords
 747+ F717 CD ED F5     .SwapCoords:            call    SwapCoords
 748+ F71A                                      ; Default in sign and clip ranges, sign 16 bit for now
 749+ F71A 21 00 00     .NoSwapCoords:          ld      hl,0                            ; clip_xmin = 0;
 750+ F71D 22 D1 F5                             ld      (clip_xmin),hl                  ; .
 751+ F720 2E FF                                ld      l,255                           ; clip xmax = 255;
 752+ F722 22 CF F5                             ld      (clip_xmax),hl                  ; .
 753+ F725 21 01 00                             ld      hl,1                            ; sign_x = 1
 754+ F728 22 D3 F5                             ld      (sign_x),hl                     ; .
 755+ F72B                                      ; if moving right to left then swap signs and clip
 756+ F72B 2A AC F5                             ld      hl,(x1)                         ; if x1 > x2
 757+ F72E ED 5B B0 F5                          ld      de,(x2)                         ; .
 758+ F732 CD 56 76                             call    CompareHLDESgn                  ; .
 759+ F735 38 2C                                jr      c,.X1tlX2                       ; .
 760+ F737 21 FF FF     .X1gteX2:               ld      hl, -1                          ;        sign_x = 01
 761+ F73A 22 D3 F5                             ld      (sign_x),hl                     ;        .
 762+ F73D 2A AC F5                             ld      hl,(x1)                         ;        x1 = -x1;
 763+ F740                                      macronegate16hl                         ;        .
 763+ F740 AF          >					xor 	a
 763+ F741 95          >					sub 	l
 763+ F742 6F          >					ld 		l,a
 763+ F743 9F          >					sbc 	a,a
 763+ F744 94          >					sub 	h
 763+ F745 67          >					ld 		h,a
 764+ F746 22 AC F5                             ld      (x1),hl                         ;        .
 765+ F749 ED 5B B0 F5                          ld      de,(x2)                         ;        x2 = -x2;
 766+ F74D                                      macronegate16de                         ;        .
 766+ F74D AF          >					xor 	a
 766+ F74E 93          >                    sub 	e
 766+ F74F 5F          >                    ld 		e,a
 766+ F750 9F          >                    sbc 	a,a
 766+ F751 92          >                    sub 	d
 766+ F752 57          >                    ld 		d,a
 767+ F753 ED 53 B0 F5                          ld      (x2),de                         ;        .
 768+ F757 21 01 FF                             ld      hl,-255                         ;        clip_xmin =-255;
 769+ F75A 22 D1 F5                             ld      (clip_xmin),hl                  ;        .
 770+ F75D 21 00 00                             ld      hl,0                            ;        clip_xmax = 0;
 771+ F760 22 CF F5                             ld      (clip_xmax),hl                  ;        .
 772+ F763              .X1tlX2:                                                        ;
 773+ F763                                      ; calculate deltas
 774+ F763 2A B0 F5     .DxEquX2MinusX1:        ld      hl,(x2)                         ; delta_x = x2 - x1;
 775+ F766 ED 5B AC F5                          ld      de,(x1)                         ; .
 776+ F76A                                      ClearCarryFlag                          ; .
 776+ F76A B7          >                        or a
 777+ F76B ED 52                                sbc     hl,de                           ; .
 778+ F76D 22 D6 F5                             ld      (delta_x),hl                    ; .
 779+ F770 2A B2 F5     .DyEquY2MinusY1:        ld      hl,(y2)                         ; delta_y = y2 - y1;
 780+ F773 ED 5B AE F5                          ld      de,(y1)                         ; .
 781+ F777                                      ClearCarryFlag                          ; .
 781+ F777 B7          >                        or a
 782+ F778 ED 52                                sbc     hl,de                           ; .
 783+ F77A 22 D8 F5                             ld      (delta_y),hl                    ; .
 784+ F77D ED 5B D6 F5  .ScaleDeltaXY:          ld      de,(delta_x)                    ; we already have delta y but x could be negative
 785+ F781 06 00                                ld      b,0
 786+ F783 CB 7A                                bit     7,d
 787+ F785 CA 8F F7                             jp      z,.DeltaYABSDone                ; de = | de |, b = 1 to denote negative needs resetting
 788+ F788 04                                   inc     b
 789+ F789                                      macronegate16de
 789+ F789 AF          >					xor 	a
 789+ F78A 93          >                    sub 	e
 789+ F78B 5F          >                    ld 		e,a
 789+ F78C 9F          >                    sbc 	a,a
 789+ F78D 92          >                    sub 	d
 789+ F78E 57          >                    ld 		d,a
 790+ F78F              .DeltaYABSDone:
 791+ F78F ~            /*.ScaleHighLoop:         ld      a,d
 792+ F78F ~                                    or      h
 793+ F78F ~                                    jr      z,.HighScaleDone
 794+ F78F ~                                    ShiftDERight1
 795+ F78F ~                                    ShiftHLRight1
 796+ F78F ~                                    jp      .ScaleHighLoop
 797+ F78F ~            .HighScaleDone:
 798+ F78F ~            .LowScaleLoop:          ld      a,e
 799+ F78F ~                                    or      l
 800+ F78F ~                                    and     $80
 801+ F78F ~                                    jr      z,.LowScaleDone
 802+ F78F ~                                    ShiftDERight1
 803+ F78F ~                                    ShiftHLRight1
 804+ F78F ~                                    jp      .LowScaleLoop
 805+ F78F ~            .LowScaleDone:          bit     0,b
 806+ F78F ~                                    jr      z,.DeltaDone
 807+ F78F ~            .SortDXSign:            macronegate16de
 808+ F78F ~            .DeltaDone:             ld      (delta_x),de
 809+ F78F ~                                    ld      (delta_y),hl*/
 810+ F78F 2A D6 F5     .DeltaXStepCalc:        ld     hl, (delta_x)
 811+ F792                                      ClearCarryFlag                          ; delta_x_step = 2 * delta_x;
 811+ F792 B7          >                        or a
 812+ F793 ED 6A                                adc     hl,hl                           ; .
 813+ F795 22 DC F5                             ld      (delta_x_step),hl               ; .
 814+ F798 2A D8 F5     .DeltaYStepCalc:        ld     hl, (delta_y)
 815+ F79B                                      ClearCarryFlag                          ; delta_y_step = 2 * delta_y;
 815+ F79B B7          >                        or a
 816+ F79C ED 6A                                adc     hl,hl                           ; .
 817+ F79E 22 DE F5                             ld      (delta_y_step),hl               ; .
 818+ F7A1 2A AC F5                             ld      hl,(x1)                         ; x_pos = x1;
 819+ F7A4 22 C7 F5                             ld      (x_pos),hl                      ; .
 820+ F7A7 ED 5B AE F5                          ld      de,(y1)                         ; y_pos = y1;
 821+ F7AB ED 53 C9 F5                          ld      (y_pos),de                      ; .
 822+ F7AF                                      ; check if we are workign on dx or dy
 823+ F7AF 2A D6 F5     .CompareDxDy:           ld      hl,(delta_x)                    ; if (delta_x >= delta_y)
 824+ F7B2 ED 5B D8 F5                          ld      de,(delta_y)
 825+ F7B6 CD 56 76                             call    CompareHLDESgn
 826+ F7B9 DA 00 FA                             jp      c, LineDrawDxLTDy
 827+ F7BC              ;.......................DxGteDy branch.............................................................................................
 828+ F7BC 2A DE F5     LineDrawDxGteDy:        ld      hl,(delta_y_step)               ;       error = delta_y_step - delta_x;
 829+ F7BF ED 5B D6 F5                          ld      de,(delta_x)                    ;       .
 830+ F7C3                                      ClearCarryFlag                          ;       .
 830+ F7C3 B7          >                        or a
 831+ F7C4 ED 52                                sbc     hl,de                           ;       .
 832+ F7C6 22 E8 F5                             ld      (error),hl                      ;       .
 833+ F7C9                                      ZeroA                                   ;       set exit false (0 == false)
 833+ F7C9 AF          >                        xor a
 834+ F7CA 32 EA F5                             ld      (set_exit),a                    ;       .
 835+ F7CD                                      ; clipping of negative y1
 836+ F7CD 2A AE F5                             ld      hl,(y1)                         ;       if (y1 < 0)
 837+ F7D0 CB 7C                                bit     7,h                             ;       .
 838+ F7D2 CA 6A F8                             jp      z,.y1GTE0                       ;       .
 839+ F7D5 2A AE F5     .y1LT0:                 ld      hl,(y1)                         ;           temp = (2 * (0 - y1) - 1) * delta_x;
 840+ F7D8                                      macronegate16hl                         ;               hl = |y1|
 840+ F7D8 AF          >					xor 	a
 840+ F7D9 95          >					sub 	l
 840+ F7DA 6F          >					ld 		l,a
 840+ F7DB 9F          >					sbc 	a,a
 840+ F7DC 94          >					sub 	h
 840+ F7DD 67          >					ld 		h,a
 841+ F7DE                                      ClearCarryFlag
 841+ F7DE B7          >                        or a
 842+ F7DF ED 6A                                adc     hl,hl                           ;               hl = (2 * |y1|)
 843+ F7E1 2B                                   dec     hl                              ;               hl = (2 * |y1| - 1)
 844+ F7E2 ED 5B D6 F5                          ld      de,(delta_x)                    ;               hl = hl * delta_x
 845+ F7E6 CD E7 6E                             call    mulHLbyDE2sc                    ;               .
 846+ F7E9 22 BC F5                             ld      (temp),hl                       ;               save to temp
 847+ F7EC 44 4D                                ld      bc,hl                           ;            msd = temp / delta_y_step
 848+ F7EE ED 5B DE F5                          ld      de,(delta_y_step)               ;               BC = BC / DE, HL = BC % DE
 849+ F7F2 CD 21 74                             call    Floor_DivQ                      ;               .
 850+ F7F5 ED 43 E6 F5                          ld      (msd),bc                        ;               .
 851+ F7F9 2A C7 F5                             ld      hl,(x_pos)                      ;            x_pos += msd
 852+ F7FC                                      ClearCarryFlag
 852+ F7FC B7          >                        or a
 853+ F7FD ED 4A                                adc     hl,bc                           ;            .
 854+ F7FF 22 C7 F5                             ld      (x_pos),hl                      ;            .
 855+ F802 ED 5B CF F5                          ld      de,(clip_xmax)                  ;            if (x_pos >= clip_xmax)
 856+ F806 CD 6D 76                             call    CompareHLDESame                 ;            .
 857+ F809 CA 10 F8                             jp      z,.xposLTEClipxmax              ;            .
 858+ F80C CD 56 76                             call    CompareHLDESgn                  ;            .
 859+ F80F D0                                   ret     nc                              ;               return
 860+ F810 2A C7 F5     .xposLTEClipxmax:       ld      hl,(x_pos)                      ;            if (x_pos >= clip_xmin)
 861+ F813 ED 5B D1 F5                          ld      de,(clip_xmin)                  ;            .
 862+ F817 CD 56 76                             call    CompareHLDESgn                  ;            .
 863+ F81A DA 6A F8                             jp      c,.xposLTxmin                   ;            .
 864+ F81D 2A E6 F5     .xposGTExmin:           ld      hl,(msd)                        ;               rem = temp - (msd * delta_y_step) (its really IY from floor_divq)
 865+ F820 ED 5B DE F5                          ld      de,(delta_y_step)               ;                   de = msd * delta_y_step
 866+ F824 CD E7 6E                             call    mulHLbyDE2sc                    ;                   .
 867+ F827 EB                                   ex      de,hl                           ;                   .
 868+ F828 2A BC F5                             ld      hl,(temp)                       ;                   hl = temp - de
 869+ F82B                                      ClearCarryFlag                          ;                   .
 869+ F82B B7          >                        or a
 870+ F82C ED 52                                sbc     hl,de                           ;                   .
 871+ F82E 22 EB F5                             ld      (rem),hl                        ;                   .
 872+ F831 11 00 00                             ld      de,0                            ;               y_pos = 0
 873+ F834 ED 53 C9 F5                          ld      (y_pos),de                      ;               .
 874+ F838 ED 5B EB F5                          ld      de,(rem)                        ;               error -= rem + delta_x
 875+ F83C                                      ClearCarryFlag
 875+ F83C B7          >                        or a
 876+ F83D ED 5A                                adc     hl,de                           ;                   de = rem+delta_x
 877+ F83F EB                                   ex      de,hl                           ;                   .
 878+ F840 2A E8 F5                             ld      hl,(error)                      ;                   hl = error - de
 879+ F843                                      ClearCarryFlag                          ;                   .
 879+ F843 B7          >                        or a
 880+ F844 ED 52                                sbc     hl,de                           ;                   .
 881+ F846 22 E8 F5                             ld      (error),hl                      ;                   write to error
 882+ F849 2A EB F5                             ld      hl,(rem)                        ;               if (rem > 0)
 883+ F84C 7C                                   ld      a,h                             ;               .
 884+ F84D B5                                   or      l                               ;               .
 885+ F84E CA 65 F8                             jp      z,.remLte0                      ;               .
 886+ F851 2A C7 F5     .remGT0:                ld      hl,(x_pos)                      ;                   x_pos += 1;
 887+ F854 23                                   inc     hl                              ;                   .
 888+ F855 22 C7 F5                             ld      (x_pos),hl                      ;                   .
 889+ F858 2A E8 F5                             ld      hl,(error)                      ;                   error += delta_y_step;
 890+ F85B ED 5B DE F5                          ld      de,(delta_y_step)               ;                   .
 891+ F85F                                      ClearCarryFlag                          ;                   .
 891+ F85F B7          >                        or a
 892+ F860 ED 5A                                adc     hl,de                           ;                   .
 893+ F862 22 E8 F5                             ld      (error),hl                      ;                   .
 894+ F865 3E 01        .remLte0:               ld      a,1                             ;               set exit = true
 895+ F867 32 EA F5                             ld      (set_exit),a                    ;               .
 896+ F86A              .xposLTxmin:
 897+ F86A 3A EA F5     .y1GTE0:                ld      a,(set_exit)                    ;           if (!set_exit && x1 < clip_xmin)
 898+ F86D A7                                   and     a                               ;           .
 899+ F86E C2 FE F8                             jp      nz,.exit_false                  ;           .   Exit if set_exit is true
 900+ F871 2A AC F5                             ld      hl,(x1)                         ;           .
 901+ F874 ED 5B D1 F5                          ld      de,(clip_xmin)                  ;           .   Exit if x1 > xmin
 902+ F878 CD 56 76                             call    CompareHLDESgn                  ;           .
 903+ F87B D2 FE F8                             jp      nc,.exit_false                  ;           .
 904+ F87E EB                                   ex      de,hl                           ;               temp = delta_y_step * (clip_xmin - x1)
 905+ F87F ED 5B AC F5                          ld      de,(x1)                         ;                   (clip_xmin - x1) (already have clip_xmin in de)
 906+ F883                                      ClearCarryFlag                          ;                   .
 906+ F883 B7          >                        or a
 907+ F884 ED 52                                sbc     hl,de                           ;                   .
 908+ F886 ED 5B DE F5                          ld      de,(delta_y_step)               ;                   hl = delta_y_step * (clip_xmin - x1)
 909+ F88A CD E7 6E                             call    mulHLbyDE2sc                    ;                   .
 910+ F88D 22 BC F5                             ld      (temp),hl                       ;                   .
 911+ F890 44 4D        .msdEQtempDIVdxstep:    ld      bc,hl                           ;               msd = temp / delta_x_step
 912+ F892 ED 5B DC F5                          ld      de,(delta_x_step)               ;                  BC = BC / DE, HL = BC % DE
 913+ F896 CD 21 74                             call    Floor_DivQ                      ;                  .
 914+ F899 ED 43 E6 F5                          ld      (msd),bc                        ;                  .
 915+ F89D E5 FD E1                             ld      iy,hl                           ;                  save BC%DE into HL (temp % delta x step0
 916+ F8A0 2A C9 F5     .yposPlusmsd:           ld      hl,(y_pos)                      ;               y_pos += msd
 917+ F8A3                                      ClearCarryFlag                          ;                   bc already is msd
 917+ F8A3 B7          >                        or a
 918+ F8A4 ED 4A                                adc     hl,bc                           ;                   hl += bc
 919+ F8A6 22 C9 F5                             ld      (y_pos),hl                      ;                   .
 920+ F8A9 FD E5 E1                             ld      hl,iy                           ;               rem = temp % delta_x_step (which is in IY)
 921+ F8AC 22 EB F5                             ld      (rem),hl                        ;               .
 922+ F8AF 2A C9 F5                             ld      hl,(y_pos)                      ;           if ((y_pos > 127) || (y_pos == 127 && rem >= delta_x))
 923+ F8B2 11 7F 00                             ld      de,127                          ;           .
 924+ F8B5 CD 6D 76                             call    CompareHLDESame                 ;           .    if y_pos != clipxmax skip the abort test
 925+ F8B8 20 0B                                jr      nz,.YPosNotClipymax             ;           .
 926+ F8BA 2A EB F5                             ld      hl,(rem)                        ;           .    if rem < delta_y  skip the abort test
 927+ F8BD ED 5B D6 F5                          ld      de,(delta_x)                    ;           .
 928+ F8C1 CD 56 76                             call    CompareHLDESgn                  ;           .
 929+ F8C4 D8                                   ret     c                               ;           .
 930+ F8C5 EB           .YPosNotClipymax:       ex      de,hl                           ;           .    swap over xpos and max to compare xpos > xmax
 931+ F8C6 CD 56 76                             call    CompareHLDESgn                  ;           .    if xpos > clipxmax then return (i.e clipxmax - xpos had a carry)
 932+ F8C9 D8                                   ret     c
 933+ F8CA 2A D1 F5     .yposLT127:             ld      hl,(clip_xmin)                  ;               x_pos = clip_xmin;
 934+ F8CD 22 C7 F5                             ld      (x_pos),hl                      ;               .
 935+ F8D0 2A E8 F5                             ld      hl,(error)                      ;               error += rem
 936+ F8D3 ED 5B EB F5                          ld      de,(rem)                        ;               .
 937+ F8D7                                      ClearCarryFlag                          ;               .
 937+ F8D7 B7          >                        or a
 938+ F8D8 ED 5A                                adc     hl,de                           ;               .
 939+ F8DA 22 E8 F5                             ld      (error),hl                      ;               .
 940+ F8DD 2A EB F5                             ld      hl,(rem)                        ;               if (rem >= delta_x)
 941+ F8E0 ED 5B D6 F5                          ld      de,(delta_x)                    ;               .
 942+ F8E4 CD 56 76                             call    CompareHLDESgn                  ;               .
 943+ F8E7 DA FE F8                             jp      c,.remLTDeltaX                  ;               .
 944+ F8EA 2A C9 F5     .remGTEDeltaX:          ld      hl,(y_pos)                      ;                   y_pos++
 945+ F8ED 23                                   inc     hl
 946+ F8EE 22 C9 F5                             ld      (y_pos),hl
 947+ F8F1 2A E8 F5                             ld      hl,(error)                      ;                    error -= delta_x_step;
 948+ F8F4 ED 5B DC F5                          ld      de,(delta_x_step)               ;                    .
 949+ F8F8                                      ClearCarryFlag                          ;                    .
 949+ F8F8 B7          >                        or a
 950+ F8F9 ED 52                                sbc     hl,de                           ;                    .
 951+ F8FB 22 E8 F5                             ld      (error),hl                      ;                    .
 952+ F8FE              .remLTDeltaX:
 953+ F8FE 2A B0 F5     .exit_false:            ld      hl,(x2)                         ;           x_pos_end = x2;
 954+ F901 22 CB F5                             ld      (x_pos_end),hl                  ;           .
 955+ F904 2A B2 F5                             ld      hl,(y2)                         ;           if (y2 > 127)
 956+ F907 11 7F 00                             ld      de,127                          ;           .
 957+ F90A CD 6D 76                             call    CompareHLDESame                 ;           .   if y2 is zero fails check
 958+ F90D CA 64 F9                             jp      z,.y2LTE127                     ;           .
 959+ F910 CD 56 76                             call    CompareHLDESgn                  ;           .   if y2 < 127 then there is carry so fails check
 960+ F913 DA 64 F9                             jp      c,.y2LTE127                      ;           .
 961+ F916 21 7F 00     .y2GT127:               ld      hl,127                          ;               temp = delta_x_step * (127 - y1) + delta_x;
 962+ F919 ED 5B AE F5                          ld      de,(y1)                         ;                   hl = 127-y1
 963+ F91D                                      ClearCarryFlag                          ;
 963+ F91D B7          >                        or a
 964+ F91E ED 52                                sbc     hl,de
 965+ F920 ED 5B DC F5                          ld      de,(delta_x_step)               ;                   hl = delta_x_step * (127-y1)
 966+ F924 CD E7 6E                             call    mulHLbyDE2sc                    ;                   .
 967+ F927 ED 5B D6 F5                          ld      de,(delta_x)                    ;                   hl += delta_x
 968+ F92B                                      ClearCarryFlag                          ;                   .
 968+ F92B B7          >                        or a
 969+ F92C ED 5A                                adc     hl,de                           ;                   .
 970+ F92E 22 BC F5                             ld      (temp),hl
 971+ F931 44 4D                                ld      bc,hl
 972+ F933 ED 5B DE F5                          ld      de,(delta_y_step)               ;               msd = temp / delta y step
 973+ F937 CD 21 74                             call    Floor_DivQ                      ;               .
 974+ F93A ED 43 E6 F5                          ld      (msd),bc                        ;               .
 975+ F93E 2A AC F5                             ld      hl,(x1)                         ;               x_pos_end = x1 + msd;
 976+ F941                                      ClearCarryFlag                          ;               .
 976+ F941 B7          >                        or a
 977+ F942 ED 4A                                adc     hl,bc                           ;               .
 978+ F944 22 CB F5                             ld      (x_pos_end),hl                  ;               .
 979+ F947 2A E6 F5                             ld      hl,(msd)                        ;               if ((temp - msd * delta_y_step) == 0) --x_pos_end
 980+ F94A ED 5B DE F5                          ld      de,(delta_y_step)               ;               .
 981+ F94E CD E7 6E                             call    mulHLbyDE2sc                    ;               .
 982+ F951 EB                                   ex      de,hl                           ;               .
 983+ F952 2A BC F5                             ld      hl,(temp)                       ;               .
 984+ F955                                      ClearCarryFlag                          ;               .
 984+ F955 B7          >                        or a
 985+ F956 ED 52                                sbc     hl,de                           ;               .
 986+ F958 7C                                   ld      a,h                             ;               .
 987+ F959 B5                                   or      l                               ;               .
 988+ F95A C2 64 F9                             jp      nz,.NotTheSame                  ;               .
 989+ F95D 2A CB F5     .IsTheSame:             ld      hl,(x_pos_end)                  ;                   --x_pos_end
 990+ F960 2B                                   dec     hl                              ;                   .
 991+ F961 22 CB F5                             ld      (x_pos_end),hl                  ;                   .
 992+ F964              .NotTheSame:
 993+ F964 2A CB F5     .y2LTE127:              ld      hl,(x_pos_end)                  ;           x_pos_end = min (x_pos_end,clip_xmax) + 1
 994+ F967 ED 5B CF F5                          ld      de,(clip_xmax)                  ;           .
 995+ F96B CD 56 76                             call    CompareHLDESgn                  ;           .
 996+ F96E D2 7B F9                             jp      nc,.xposgtexmax                 ;           .
 997+ F971 2A CB F5     .xposltxmax:            ld      hl,(x_pos_end)                  ;           .
 998+ F974 23                                   inc     hl                              ;               x_pos_end+1
 999+ F975 22 CB F5                             ld      (x_pos_end),hl                  ;               .
1000+ F978 C3 80 F9                             jp      .DoneXposAdjust                 ;               .
1001+ F97B 13           .xposgtexmax:           inc     de                              ;               else
1002+ F97C ED 53 CB F5                          ld      (x_pos_end),de                  ;               clip_xmax+1
1003+ F980 3A D3 F5     .DoneXposAdjust:        ld      a,(sign_x)                      ;           if (sign_x == -1)
1004+ F983 3C                                   inc     a
1005+ F984 C2 9F F9                             jp      nz,.SignNotMinus1
1006+ F987 2A C7 F5     .SignEquMinus1:         ld      hl,(x_pos)                      ;               x_pos = -x_pos;
1007+ F98A                                      macronegate16hl
1007+ F98A AF          >					xor 	a
1007+ F98B 95          >					sub 	l
1007+ F98C 6F          >					ld 		l,a
1007+ F98D 9F          >					sbc 	a,a
1007+ F98E 94          >					sub 	h
1007+ F98F 67          >					ld 		h,a
1008+ F990 22 C7 F5                             ld      (x_pos),hl
1009+ F993 2A CB F5                             ld      hl,(x_pos_end)                  ;               x_pos_end = -x_pos_end;
1010+ F996                                      macronegate16hl
1010+ F996 AF          >					xor 	a
1010+ F997 95          >					sub 	l
1010+ F998 6F          >					ld 		l,a
1010+ F999 9F          >					sbc 	a,a
1010+ F99A 94          >					sub 	h
1010+ F99B 67          >					ld 		h,a
1011+ F99C 22 CB F5                             ld      (x_pos_end),hl
1012+ F99F              .y2LTE27:
1013+ F99F              .SignNotMinus1:
1014+ F99F ED 5B DE F5                          ld      de,(delta_y_step)               ;        delta_x_step -= delta_y_step;
1015+ F9A3 2A DC F5                             ld      hl,(delta_x_step)               ;        .
1016+ F9A6                                      ClearCarryFlag                          ;        .
1016+ F9A6 B7          >                        or a
1017+ F9A7 ED 52                                sbc     hl,de                           ;        .
1018+ F9A9 22 DC F5                             ld      (delta_x_step),hl               ;        .
1019+ F9AC 2A C7 F5     .PlottingLoop:          ld      hl,(x_pos)                      ;        while (x_pos != x_pos_end)
1020+ F9AF ED 5B CB F5                          ld      de,(x_pos_end)                  ;        .
1021+ F9B3 CD 6D 76                             call    CompareHLDESame                 ;        .
1022+ F9B6 C8                                   ret     z                               ;        .
1023+ F9B7 2A C7 F5                             ld      hl,(x_pos)                      ;               drawpixel at xpos, ypos, Colour
1024+ F9BA 4D                                   ld      c,l                             ;               .
1025+ F9BB 2A C9 F5                             ld      hl,(y_pos)                      ;               .
1026+ F9BE 45                                   ld      b,l                             ;               .
1027+ F9BF 3E BF                                ld      a,$BF                           ;               .
1028+ F9C1 CD 8E E2     .PlotPixel:             call    l2_plot_pixel                   ;               .
1029+ F9C4 2A E8 F5                             ld      hl,(error)                      ;               if (error >= 0)
1030+ F9C7 CB 7C                                bit     7,h                             ;               .
1031+ F9C9 C2 E3 F9                             jp      nz,.errorLT0                    ;               .
1032+ F9CC 2A C9 F5     .errorGTE0:             ld	    hl,(y_pos)                      ;                   ++y_pos;
1033+ F9CF 23                                   inc	    hl                              ;                   .
1034+ F9D0 22 C9 F5                             ld	    (y_pos),hl                      ;                   .
1035+ F9D3 2A E8 F5                             ld	    hl,(error)                      ;                   error -= delta_x_step;
1036+ F9D6 ED 5B DC F5                          ld	    de,(delta_x_step)               ;                   .
1037+ F9DA                                      ClearCarryFlag                          ;                   .
1037+ F9DA B7          >                        or a
1038+ F9DB ED 52                                sbc	    hl,de                           ;                   .
1039+ F9DD 22 E8 F5                             ld	    (error),hl                      ;                   .
1040+ F9E0 C3 F0 F9                             jp      .DoneErrorAdjust                ;                   .
1041+ F9E3 2A E8 F5     .errorLT0:              ld	    hl,(error)                      ;                   error += delta_y_step;
1042+ F9E6 ED 5B DE F5                          ld	    de,(delta_y_step)
1043+ F9EA                                      ClearCarryFlag
1043+ F9EA B7          >                        or a
1044+ F9EB ED 5A                                adc	    hl,de
1045+ F9ED 22 E8 F5                             ld	    (error),hl
1046+ F9F0 ED 5B D3 F5  .DoneErrorAdjust:       ld      de,(sign_x)
1047+ F9F4 2A C7 F5                             ld      hl,(x_pos)
1048+ F9F7                                      ClearCarryFlag
1048+ F9F7 B7          >                        or a
1049+ F9F8 ED 5A                                adc     hl,de
1050+ F9FA 22 C7 F5                             ld      (x_pos),hl
1051+ F9FD C3 AC F9                             jp      .PlottingLoop
1052+ FA00              ;.......................DxGltDy branch.............................................................................................
1053+ FA00              LineDrawDxLTDy:         ;ret
1054+ FA00 2A DC F5                             ld      hl,(delta_x_step)               ;       error = delta_x_step - delta_y;
1055+ FA03 ED 5B D8 F5                          ld      de,(delta_y)
1056+ FA07                                      ClearCarryFlag
1056+ FA07 B7          >                        or a
1057+ FA08 ED 52                                sbc     hl,de
1058+ FA0A 22 E8 F5                             ld      (error),hl
1059+ FA0D                                      ZeroA                                   ;        set exit false (0 == false)
1059+ FA0D AF          >                        xor a
1060+ FA0E 32 EA F5                             ld      (set_exit),a
1061+ FA11 2A AC F5                             ld      hl,(x1)                         ;        if (x1 < clip_xmin)
1062+ FA14 ED 5B D1 F5                          ld      de,(clip_xmin)                  ;        .
1063+ FA18 CD 56 76                             call    CompareHLDESgn                  ;        .
1064+ FA1B D2 AF FA                             jp      nc,.x1GTEClipXmin               ;        .
1065+ FA1E ED 5B AC F5  .x1LTClipXmin:          ld      de,(x1)                         ;           temp = (2 * (cllp_xmin - x1) - 1) * delta_y;
1066+ FA22 2A D1 F5                             ld      hl,(clip_xmin)                  ;               hl = clip_xmin - x1
1067+ FA25                                      ClearCarryFlag                          ;               .
1067+ FA25 B7          >                        or a
1068+ FA26 ED 52                                sbc     hl,de                           ;               .
1069+ FA28                                      ClearCarryFlag
1069+ FA28 B7          >                        or a
1070+ FA29 ED 6A                                adc     hl,hl                           ;               hl = (2* hl)
1071+ FA2B 2B                                   dec     hl                              ;               hl = (2 *  hl - 1)
1072+ FA2C ED 5B D8 F5                          ld      de,(delta_y)                    ;               hl = hl  * delta_y
1073+ FA30 CD E7 6E                             call    mulHLbyDE2sc                    ;               .
1074+ FA33 22 BC F5                             ld      (temp),hl                       ;               .
1075+ FA36 44 4D                                ld      bc,hl                           ;            msd = temp / delta_x_step
1076+ FA38 ED 5B DC F5                          ld      de,(delta_x_step)               ;               BC = BC / DE, HL = BC % DE
1077+ FA3C CD 21 74                             call    Floor_DivQ                      ;               .
1078+ FA3F ED 43 E6 F5                          ld      (msd),bc                        ;               .
1079+ FA43 2A C9 F5                             ld      hl,(y_pos)                      ;            y_pos += msd
1080+ FA46                                      ClearCarryFlag
1080+ FA46 B7          >                        or a
1081+ FA47 ED 4A                                adc     hl,bc                           ;            .
1082+ FA49 22 C9 F5                             ld      (y_pos),hl                      ;            .
1083+ FA4C 11 7F 00                             ld      de,127                          ;            if (y_pos >= 127)
1084+ FA4F CD 6D 76                             call    CompareHLDESame                 ;            .
1085+ FA52 CA 59 FA                             jp      z,.yposGT127                    ;            .
1086+ FA55 CD 56 76                             call    CompareHLDESgn                  ;            .
1087+ FA58 D0                                   ret     nc                              ;               return
1088+ FA59 2A C9 F5     .yposGT127:             ld      hl,(y_pos)                      ;            if (y_pos >= 0)
1089+ FA5C CB 7C                                bit     7,h
1090+ FA5E C2 AF FA                             jp      nz,.yposLT0
1091+ FA61 2A E6 F5     .yposGT0:               ld      hl,(msd)                        ;               rem = temp - (msd * delta_x_step)
1092+ FA64 ED 5B DC F5                          ld      de,(delta_x_step)               ;                   de = msd * delta_x_step
1093+ FA68 CD E7 6E                             call    mulHLbyDE2sc                    ;                   .
1094+ FA6B EB                                   ex      de,hl                           ;                   .
1095+ FA6C 2A BC F5                             ld      hl,(temp)                       ;                   hl = temp - de
1096+ FA6F                                      ClearCarryFlag                          ;                   .
1096+ FA6F B7          >                        or a
1097+ FA70 ED 52                                sbc     hl,de                           ;                   .
1098+ FA72 22 EB F5                             ld      (rem),hl                        ;                   .
1099+ FA75 ED 5B D1 F5                          ld      de,(clip_xmin)                  ;               x_pos = clip_xmin
1100+ FA79 ED 53 C7 F5                          ld      (x_pos),de                      ;               .
1101+ FA7D ED 5B EB F5                          ld      de,(rem)                        ;               error -= rem + delta_y
1102+ FA81                                      ClearCarryFlag                          ;               .
1102+ FA81 B7          >                        or a
1103+ FA82 ED 5A                                adc     hl,de                           ;                   de = rem+delta_x
1104+ FA84 EB                                   ex      de,hl                           ;                   .
1105+ FA85 2A E8 F5                             ld      hl,(error)                      ;                   hl = error - de
1106+ FA88                                      ClearCarryFlag                          ;                   .
1106+ FA88 B7          >                        or a
1107+ FA89 ED 52                                sbc     hl,de                           ;                   .
1108+ FA8B 22 E8 F5                             ld      (error),hl                      ;                   .
1109+ FA8E 2A EB F5                             ld      hl,(rem)                        ;               if (rem > 0)
1110+ FA91 7C                                   ld      a,h                             ;               .
1111+ FA92 B5                                   or      l                               ;               .
1112+ FA93 CA AA FA                             jp      z,.remLte0                      ;               .
1113+ FA96 2A C9 F5     .remGT0:                ld      hl,(y_pos)                      ;                   y_pos += 1;
1114+ FA99 23                                   inc     hl
1115+ FA9A 22 C9 F5                             ld      (y_pos),hl
1116+ FA9D 2A E8 F5                             ld      hl,(error)                      ;                   error += delta_x_step;
1117+ FAA0 ED 5B DC F5                          ld      de,(delta_x_step)
1118+ FAA4                                      ClearCarryFlag
1118+ FAA4 B7          >                        or a
1119+ FAA5 ED 5A                                adc     hl,de
1120+ FAA7 22 E8 F5                             ld      (error),hl
1121+ FAAA 3E 01        .remLte0:               ld      a,1                             ;               set exit = true
1122+ FAAC 32 EA F5                             ld      (set_exit),a                    ;               .
1123+ FAAF
1124+ FAAF              .yposLT0:
1125+ FAAF 3A EA F5     .x1GTEClipXmin:         ld      a,(set_exit)                    ;        if (!set_exit && y1 < 0)
1126+ FAB2 A7                                   and     a                               ;        .
1127+ FAB3 C2 3D FB                             jp      nz,.exit_false                  ;        .  if exit is 1 then its true so exit branch
1128+ FAB6 2A AE F5                             ld      hl,(y1)                         ;        .  if y1 is positive (including 0) then exit branch
1129+ FAB9 CB 7C                                bit     7,h                             ;        .
1130+ FABB CA 3D FB                             jp      z,.exit_false                   ;        .
1131+ FABE 2A AE F5                             ld      hl,(y1)                         ;           temp = delta_x_step * (0 - y1)
1132+ FAC1                                      macronegate16hl                         ;           .
1132+ FAC1 AF          >					xor 	a
1132+ FAC2 95          >					sub 	l
1132+ FAC3 6F          >					ld 		l,a
1132+ FAC4 9F          >					sbc 	a,a
1132+ FAC5 94          >					sub 	h
1132+ FAC6 67          >					ld 		h,a
1133+ FAC7 ED 5B DC F5                          ld      de,(delta_x_step)               ;           .       hl = delta_x_step * (- y1)
1134+ FACB CD E7 6E                             call    mulHLbyDE2sc                    ;           .
1135+ FACE 22 BC F5                             ld      (temp),hl                       ;           .
1136+ FAD1 44 4D        .msdEQtempDIVdxstep:    ld      bc,hl                           ;           msd = temp / delta_y_step
1137+ FAD3 ED 5B DE F5                          ld      de,(delta_y_step)               ;               BC = BC / DE, HL = BC % DE
1138+ FAD7 CD 21 74                             call    Floor_DivQ                      ;               .
1139+ FADA ED 43 E6 F5                          ld      (msd),bc                        ;               .
1140+ FADE E5 FD E1                             ld      iy,hl                           ;               same remainders (which is also mod result)
1141+ FAE1 22 EB F5                             ld      (rem),hl                        ;           rem = temp % delta_y_step (swapped from being after x_pos += msd)
1142+ FAE4 2A C7 F5     .yposPlusmsd:           ld      hl,(x_pos)                      ;           x_pos += msd
1143+ FAE7                                      ClearCarryFlag                          ;           .   bc already is msd
1143+ FAE7 B7          >                        or a
1144+ FAE8 ED 4A                                adc     hl,bc                           ;           .   hl += bc
1145+ FAEA 22 C7 F5                             ld      (x_pos),hl                      ;           .
1146+ FAED 2A C7 F5                             ld      hl,(x_pos)                      ;           if ((x_pos > clip_xmax) || (x_pos == clip_xmax && rem >= delta_y))
1147+ FAF0 ED 5B CF F5                          ld      de,(clip_xmax)                  ;           .
1148+ FAF4 CD 6D 76                             call    CompareHLDESame                 ;           .    if xpos != clipxmax skip the abort test
1149+ FAF7 20 0B                                jr      nz,.XPosNotClipxmax             ;           .
1150+ FAF9 2A EB F5                             ld      hl,(rem)                        ;           .    if rem < delta_y  skip the abort test
1151+ FAFC ED 5B D8 F5                          ld      de,(delta_y)                    ;           .
1152+ FB00 CD 56 76                             call    CompareHLDESgn                  ;           .
1153+ FB03 D8                                   ret     c                               ;           .
1154+ FB04 EB           .XPosNotClipxmax:       ex      de,hl                           ;           .    swap over xpos and max to compare xpos > xmax
1155+ FB05 CD 56 76                             call    CompareHLDESgn                  ;           .    if xpos > clipxmax then return (i.e clipxmax - xpos had a carry)
1156+ FB08 D8                                   ret     c
1157+ FB09 21 00 00     .xposLT127:             ld      hl,0                            ;           y_pos = 0;
1158+ FB0C 22 C9 F5                             ld      (y_pos),hl                      ;           .
1159+ FB0F 2A E8 F5                             ld      hl,(error)                      ;           error += rem
1160+ FB12 ED 5B EB F5                          ld      de,(rem)                        ;           .
1161+ FB16                                      ClearCarryFlag                          ;           .
1161+ FB16 B7          >                        or a
1162+ FB17 ED 5A                                adc     hl,de                           ;           .
1163+ FB19 22 E8 F5                             ld      (error),hl                      ;           .
1164+ FB1C 2A EB F5                             ld      hl,(rem)                        ;           if (rem >= delta_y)
1165+ FB1F ED 5B D8 F5                          ld      de,(delta_y)                    ;           .
1166+ FB23 CD 56 76                             call    CompareHLDESgn                  ;           .
1167+ FB26 DA 3D FB                             jp      c,.remLTDeltaY                  ;           .
1168+ FB29 2A C7 F5     .remGTEDeltaY:          ld      hl,(x_pos)                      ;                x_pos++
1169+ FB2C 23                                   inc     hl
1170+ FB2D 22 C7 F5                             ld      (x_pos),hl
1171+ FB30 2A E8 F5                             ld      hl,(error)                      ;                error -= delta_y_step;
1172+ FB33 ED 5B DE F5                          ld      de,(delta_y_step)               ;                .
1173+ FB37                                      ClearCarryFlag                          ;                .
1173+ FB37 B7          >                        or a
1174+ FB38 ED 52                                sbc     hl,de                           ;                .
1175+ FB3A 22 E8 F5                             ld      (error),hl                      ;                .
1176+ FB3D              .remLTDeltaY:
1177+ FB3D 2A B2 F5     .exit_false:            ld      hl,(y2)                         ;           y_pos_end = y2;
1178+ FB40 22 CD F5                             ld      (y_pos_end),hl                  ;           .
1179+ FB43 2A B0 F5                             ld      hl,(x2)                         ;           if (x2 > clip_xmax)
1180+ FB46 ED 5B CF F5                          ld      de,(clip_xmax)                  ;           .
1181+ FB4A CD 6D 76                             call    CompareHLDESame                 ;           .
1182+ FB4D CA A4 FB                             jp      z,.x2LTEclipxmax                ;           .
1183+ FB50 CD 56 76                             call    CompareHLDESgn                  ;           .
1184+ FB53 DA A4 FB                             jp      c,.x2LTEclipxmax                ;           .
1185+ FB56 2A CF F5     .x2GTclipxmax:          ld      hl,(clip_xmax)                  ;               temp = delta_y_step * (clip_xmax - x1) + delta_y;
1186+ FB59 ED 5B AC F5                          ld      de,(x1)                         ;                   hl = 127-y1
1187+ FB5D                                      ClearCarryFlag                          ;
1187+ FB5D B7          >                        or a
1188+ FB5E ED 52                                sbc     hl,de
1189+ FB60 ED 5B DE F5                          ld      de,(delta_y_step)               ;                   hl = delta_x_step * (clip_xmax - x1)
1190+ FB64 CD E7 6E                             call    mulHLbyDE2sc                    ;                   .
1191+ FB67 ED 5B D8 F5                          ld      de,(delta_y)                    ;                   hl += delta_y
1192+ FB6B                                      ClearCarryFlag                          ;                   .
1192+ FB6B B7          >                        or a
1193+ FB6C ED 5A                                adc     hl,de                           ;                   .
1194+ FB6E 22 BC F5                             ld      (temp),hl
1195+ FB71 44 4D                                ld      bc,hl
1196+ FB73 ED 5B DC F5                          ld      de,(delta_x_step)               ;               msd = temp / delta x step
1197+ FB77 CD 21 74                             call    Floor_DivQ                      ;               .
1198+ FB7A ED 43 E6 F5                          ld      (msd),bc                        ;               .
1199+ FB7E 2A AE F5                             ld      hl,(y1)                         ;               y_pos_end = y1 + msd;
1200+ FB81                                      ClearCarryFlag                          ;               .
1200+ FB81 B7          >                        or a
1201+ FB82 ED 4A                                adc     hl,bc                           ;               .
1202+ FB84 22 CD F5                             ld      (y_pos_end),hl                  ;               .
1203+ FB87 2A E6 F5                             ld      hl,(msd)                        ;               if ((temp - msd * delta_x_step) == 0) --y_pos_end
1204+ FB8A ED 5B DC F5                          ld      de,(delta_x_step)               ;               .
1205+ FB8E CD E7 6E                             call    mulHLbyDE2sc                    ;               .
1206+ FB91 EB                                   ex      de,hl                           ;               .
1207+ FB92 2A BC F5                             ld      hl,(temp)                       ;               .
1208+ FB95                                      ClearCarryFlag                          ;               .
1208+ FB95 B7          >                        or a
1209+ FB96 ED 52                                sbc     hl,de                           ;               .
1210+ FB98 7C                                   ld      a,h                             ;               .
1211+ FB99 B5                                   or      l                               ;               .
1212+ FB9A C2 A4 FB                             jp      nz,.NotTheSame                  ;               .
1213+ FB9D 2A CD F5     .IsTheSame:             ld      hl,(y_pos_end)                  ;                   --x_pos_end
1214+ FBA0 2B                                   dec     hl                              ;                   .
1215+ FBA1 22 CD F5                             ld      (y_pos_end),hl                  ;                   .
1216+ FBA4              .NotTheSame:
1217+ FBA4 2A CD F5     .x2LTEclipxmax:         ld      hl,(y_pos_end)                  ;           y_pos_end = min(y_pos_end, clip_ymax) + 1
1218+ FBA7 11 7F 00                             ld      de,127                          ;           .
1219+ FBAA CD 56 76                             call    CompareHLDESgn                  ;           .
1220+ FBAD D2 BA FB                             jp      nc,.yposgteymax                 ;           .
1221+ FBB0 2A CD F5     .yposltymax:            ld      hl,(y_pos_end)                  ;           .
1222+ FBB3 23                                   inc     hl                              ;           .
1223+ FBB4 22 CD F5                             ld      (y_pos_end),hl                  ;           .
1224+ FBB7 C3 BF FB                             jp      .DoneYposAdjust                 ;           .
1225+ FBBA 13           .yposgteymax:           inc     de                              ;           .
1226+ FBBB ED 53 CD F5                          ld      (y_pos_end),de                  ;           .
1227+ FBBF 3A D3 F5     .DoneYposAdjust:        ld      a,(sign_x)                      ;           if (sign_x == -1)
1228+ FBC2 3C                                   inc     a
1229+ FBC3 C2 DE FB                             jp      nz,.SignNotMinus1
1230+ FBC6 2A C7 F5     .SignEquMinus1:         ld      hl,(x_pos)                      ;               x_pos = -x_pos;
1231+ FBC9                                      macronegate16hl
1231+ FBC9 AF          >					xor 	a
1231+ FBCA 95          >					sub 	l
1231+ FBCB 6F          >					ld 		l,a
1231+ FBCC 9F          >					sbc 	a,a
1231+ FBCD 94          >					sub 	h
1231+ FBCE 67          >					ld 		h,a
1232+ FBCF 22 C7 F5                             ld      (x_pos),hl
1233+ FBD2 2A CB F5                             ld      hl,(x_pos_end)                  ;               x_pos_end = -x_pos_end;
1234+ FBD5                                      macronegate16hl
1234+ FBD5 AF          >					xor 	a
1234+ FBD6 95          >					sub 	l
1234+ FBD7 6F          >					ld 		l,a
1234+ FBD8 9F          >					sbc 	a,a
1234+ FBD9 94          >					sub 	h
1234+ FBDA 67          >					ld 		h,a
1235+ FBDB 22 CB F5                             ld      (x_pos_end),hl
1236+ FBDE ED 5B DC F5  .SignNotMinus1:         ld      de,(delta_x_step)               ;        delta_y_step -= delta_x_step;
1237+ FBE2 2A DE F5                             ld      hl,(delta_y_step)               ;        .
1238+ FBE5                                      ClearCarryFlag                          ;        .
1238+ FBE5 B7          >                        or a
1239+ FBE6 ED 52                                sbc     hl,de                           ;        .
1240+ FBE8 22 DE F5                             ld      (delta_y_step),hl               ;        .
1241+ FBEB 2A C9 F5     .PlottingLoop:          ld      hl,(y_pos)                      ;        while (y_pos != y_pos_end)
1242+ FBEE ED 5B CD F5                          ld      de,(y_pos_end)
1243+ FBF2 CD 6D 76                             call    CompareHLDESame
1244+ FBF5 C8                                   ret     z
1245+ FBF6 2A C7 F5     .PlotPixel:             ld      hl,(x_pos)
1246+ FBF9 4D                                   ld      c,l
1247+ FBFA 2A C9 F5                             ld      hl,(y_pos)
1248+ FBFD 45                                   ld      b,l
1249+ FBFE 3E BF                                ld      a,$BF
1250+ FC00 CD 8E E2                             call    l2_plot_pixel                   ;               drawpixel at xpos, ypos, Colour
1251+ FC03 2A E8 F5                             ld      hl,(error)                      ;               if (error >= 0)
1252+ FC06 CB 7C                                bit     7,h
1253+ FC08 C2 28 FC                             jp      nz,.errorLT0
1254+ FC0B 2A C7 F5     .errorGTE0:             ld	    hl,(x_pos)                      ;                   ++x_pos
1255+ FC0E ED 5B D3 F5                          ld      de,(sign_x)
1256+ FC12                                      ClearCarryFlag
1256+ FC12 B7          >                        or a
1257+ FC13 ED 5A                                adc     hl,de
1258+ FC15 22 C7 F5                             ld	    (x_pos),hl
1259+ FC18 2A E8 F5                             ld	    hl,(error)                      ;                   error -= delta_y_step;
1260+ FC1B ED 5B DE F5                          ld	    de,(delta_y_step)
1261+ FC1F                                      ClearCarryFlag
1261+ FC1F B7          >                        or a
1262+ FC20 ED 52                                sbc	    hl,de
1263+ FC22 22 E8 F5                             ld	    (error),hl
1264+ FC25 C3 35 FC                             jp      .DoneErrorAdjust
1265+ FC28 2A E8 F5     .errorLT0:              ld	    hl,(error)                      ;                   error += delta_x_step;
1266+ FC2B ED 5B DC F5                          ld	    de,(delta_x_step)
1267+ FC2F                                      ClearCarryFlag
1267+ FC2F B7          >                        or a
1268+ FC30 ED 5A                                adc	    hl,de
1269+ FC32 22 E8 F5                             ld	    (error),hl
1270+ FC35 2A C9 F5     .DoneErrorAdjust:       ld      hl,(y_pos)
1271+ FC38 23                                   inc     hl
1272+ FC39 22 C9 F5                             ld      (y_pos),hl
1273+ FC3C C3 EB FB                             jp      .PlottingLoop
1274+ FC3F                      ENDIF
1275+ FC3F
1276+ FC3F
1277+ FC3F 21 AC F5     l2_draw_6502_line:      ld      hl,x1                           ; copy from currnet position to 6502 variables
1278+ FC42 11 78 EF                             ld      de,XX1510
1279+ FC45 01 08 00                             ld      bc,4*2
1280+ FC48 ED B0                                ldir
1281+ FC4A CD 68 F1                             call    LL145_6502                      ; perform 6502 version
1282+ FC4D D8                                   ret     c                               ; returns if carry is set as its a no draw
1283+ FC4E 21 00 00     .CopyBackResults:       ld      hl,0
1284+ FC51 22 AC F5                             ld      (x1),hl
1285+ FC54 22 AE F5                             ld      (y1),hl
1286+ FC57 22 B0 F5                             ld      (x2),hl
1287+ FC5A 22 B2 F5                             ld      (y2),hl
1288+ FC5D 3A 78 EF                             ld      a,(XX1510)
1289+ FC60 32 AC F5                             ld      (x1),a
1290+ FC63 4F                                   ld      c,a
1291+ FC64 3A 79 EF                             ld      a,(XX1510+1)
1292+ FC67 32 AE F5                             ld      (y1),a
1293+ FC6A 47                                   ld      b,a
1294+ FC6B 3A 7A EF                             ld      a,(XX1510+2)
1295+ FC6E 32 B0 F5                             ld      (x2),a
1296+ FC71 5F                                   ld      e,a
1297+ FC72 3A 7B EF                             ld      a,(XX1510+3)
1298+ FC75 32 B2 F5                             ld      (y2),a
1299+ FC78 57                                   ld      d,a
1300+ FC79 3E FF                                ld      a,$FF
1301+ FC7B                                      ClearCarryFlag
1301+ FC7B B7          >                        or a
1302+ FC7C C9                                   ret
1303+ FC7D                                 ;     call    l2_draw_clipped_line
1304+ FC7D              ;                        call    l2_draw_diagonal                ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
1305+ FC7D              ;................................................................
1306+ FC7D 00 00        result                  dw      0
1307+ FC7F              ;    swap = 0;
1308+ FC7F              ;    if (y1 > y2)
1309+ FC7F 2A AE F5     l2_draw_elite_line:     ld      hl,(y1)                         ; if (y1 > y2)
1310+ FC82 ED 5B B2 F5                          ld      de,(y2)                         ; .
1311+ FC86 CD 56 76                             call    CompareHLDESgn                  ; .
1312+ FC89 DA 8F FC                             jp      c,.NoSwapCoords                 ;
1313+ FC8C              ;        swapp1p2();
1314+ FC8C CD ED F5     .SwapCoords:            call    SwapCoords                      ;       swap them so y1 <= y2
1315+ FC8F 2A AC F5     .NoSwapCoords:          ld      hl,(x1)                         ; hl = x1
1316+ FC92 ED 5B B0 F5                          ld      de,(x2)                         ; de = x2
1317+ FC96 ED 4B AE F5                          ld      bc,(y1)                         ; bc = y1
1318+ FC9A DD 2A B2 F5                          ld      ix,(y2)                         ; ix = y2
1319+ FC9E              .CheckForVertical:
1320+ FC9E              .CheckForHorizontal:
1321+ FC9E FD 26 80                             ld      iyh,128                         ; iyh = xx13 = 128
1322+ FCA1              ;    xx13 = 128;
1323+ FCA1              ;    if (x2 >= 0 && x2 <= 255 && y2 >= 0 && y2 <= 127)
1324+ FCA1 7A                                   ld      a,d                             ; if (x2 >= 0 && x2 <= 255 && y2 >= 0 && y2 <= 127)
1325+ FCA2 DD B4                                or      ixh                             ; .  [if x2 and y2 > 255 goto point2clip]
1326+ FCA4 20 09                                jr      nz,.Point2Clip                  ; .  .
1327+ FCA6 DD 7D                                ld      a,ixl                           ; .  [if y2 low > 127 goto point2clip]
1328+ FCA8 CB 7F                                bit     7,a                             ; .  .
1329+ FCAA 20 03                                jr      nz,.Point2Clip                  ; .  .
1330+ FCAC              ;        xx13 = 0;
1331+ FCAC FD 26 00     .Point2NoClip:          ld      iyh,0                           ;       iyh = xx13 = 0
1332+ FCAF              ;    if (x1 >= 0 && x1 <= 255 && y1 >= 0 && y1 <= 127)
1333+ FCAF 7C           .Point2Clip:            ld      a,h                             ; if (x1 >= 0 && x1 <= 255 && y1 >= 0 && y1 <= 127)
1334+ FCB0 B0                                   or      b                               ; . [ if x1 or y1 > 255 goto clip needed]
1335+ FCB1 C2 C2 FC                             jp      nz,.ClipNeeded                  ; .
1336+ FCB4 CB 79                                bit     7,c                             ; . [ if y1 low > 127 goto clip needed]
1337+ FCB6 C2 C2 FC                             jp      nz,.ClipNeeded                  ; .
1338+ FCB9              ;        if (xx13 != 0)
1339+ FCB9 FD 7C        .ClipPoint1:            ld      a,iyh                           ;       if (xx13 = 0)
1340+ FCBB A7                                   and     a                               ;       .
1341+ FCBC CA B9 FD                             jp      z,.ClipComplete                 ;               clipping not needed so treat as done an ddraw the line
1342+ FCBF FD 26 40                             ld      iyh,64                          ;       else xx13 = 64 (xx13 /2 but if xx13 is 0 it never hits here so can just set to 64)
1343+ FCC2              ;.......................LL138
1344+ FCC2 FD 7C        .ClipNeeded:            ld      a,iyh                           ; if (xx13 == 128)
1345+ FCC4 CB 7F                                bit     7,a                             ; . [ jump if bit 7 is not set so <> 128]
1346+ FCC6 CA FF FC                             jp      z,.xx13Not128                   ; .
1347+ FCC9 7C           .xx13Is128:             ld      a,h                             ;       if (x1 < 0 && x2 < 0)
1348+ FCCA A2                                   and     d                               ;       . [ x1 and x2 high bits 7 are both set then its off to the left]
1349+ FCCB F8                                   ret     m                               ;               return
1350+ FCCC 78                                   ld      a,b                             ;       if (y1 < 0 && y2 < 0)
1351+ FCCD DD A4                                and     ixh                             ;       . [ y1 and y2 high bits 7 are both set then its off the top]
1352+ FCCF F8                                   ret     m                               ;               return
1353+ FCD0 7C                                   ld      a,h                             ;       if (x1 > 255  && x2 > 255)
1354+ FCD1 CB 7F                                bit     7,a                             ;       . [test if x1 is negative and if so skip]
1355+ FCD3 C2 E2 FC                             jp      nz,.x1x2LessThan256             ;       .
1356+ FCD6 A7                                   and     a                               ;       . [ if x1 is not negative then if high has any value its > 256]
1357+ FCD7 CA E2 FC                             jp      z,.x1x2LessThan256              ;       .
1358+ FCDA 7A                                   ld      a,d                             ;       . [test if x2 is negative]
1359+ FCDB CB 7F                                bit     7,a                             ;       .
1360+ FCDD C2 E2 FC                             jp      nz,.x1x2LessThan256             ;       . < can simplify with with an xor test to detect if opposite signs first >
1361+ FCE0 A7                                   and     a                               ;       . [ if x2 is not negative then if high has any value its > 256]
1362+ FCE1 C0                                   ret     nz                              ;               return
1363+ FCE2 78           .x1x2LessThan256:       ld      a,b                             ;       if (y1 > 127  && y2 > 127)
1364+ FCE3 CB 7F                                bit     7,a                             ;       . [test if y1 is negative]
1365+ FCE5 C2 FF FC                             jp      nz,.y1y2LessThan128             ;       .
1366+ FCE8 A7                                   and     a                               ;       . [ if y1 is not negative then if high has any value its > 256]
1367+ FCE9 CA FF FC                             jp      z,.y1y2LessThan128              ;       .
1368+ FCEC CB 79                                bit     7,c                             ;       . [ if y1 low bit 7 is set then its > 127]
1369+ FCEE CA FF FC                             jp      z,.y1y2LessThan128              ;       .
1370+ FCF1 DD 7C                                ld      a,ixh                           ;       . [test if y2 is negative]
1371+ FCF3 A7                                   and     a                               ;       .
1372+ FCF4 FA FF FC                             jp      m,.y1y2LessThan128              ;       .
1373+ FCF7 A7                                   and     a                               ;       . [ if y2 is not negative then if high has any value its > 256]
1374+ FCF8 CA FF FC                             jp      z,.y1y2LessThan128              ;       .
1375+ FCFB DD 7D                                ld      a,ixl                           ;       .
1376+ FCFD A7                                   and     a                               ;       . [ if y2 low bit 7 is set then its > 127]
1377+ FCFE F8                                   ret     m                               ;               return
1378+ FCFF              ;.......................LL115
1379+ FCFF              .xx13Not128:                        // check right point
1380+ FCFF EB           .y1y2LessThan128:       ex      de,hl                           ; delta_x = x2 - x1;
1381+ FD00                                      ClearCarryFlag                          ; .
1381+ FD00 B7          >                        or a
1382+ FD01 ED 52                                sbc     hl,de                           ; .
1383+ FD03 22 D6 F5                             ld      (delta_x),hl                    ; redundant as its in DE TODO OPTIMISE
1384+ FD06 EB                                   ex      de,hl                           ; de = delta_x for next bit
1385+ FD07 DD E5 E1     .DyEquY2MinusY1:        ld      hl,ix                           ; delta_y = y2 - y1;
1386+ FD0A                                      ClearCarryFlag                          ; .
1386+ FD0A B7          >                        or a
1387+ FD0B ED 42                                sbc     hl,bc                           ; .
1388+ FD0D 22 D8 F5                             ld      (delta_y),hl                    ; . [ so now de = dx and hl = dy]
1389+ FD10 FD 2E 80                             ld      iyl,128                         ; assuming sign is iyl is positive dx dy
1390+ FD13 CB 7A        .SignDeltaXY:           bit     7,d                             ; if delta x is negative (delta y will always be positive)
1391+ FD15 CA 21 FD                             jp      z,.DeltaXPositive               ; .
1392+ FD18 FD 2E 00     .DeltaXNegative:        ld      iyl,0                           ;       so we set sign to 0
1393+ FD1B                                      macronegate16de                         ;       and set delta x to |delta x|
1393+ FD1B AF          >					xor 	a
1393+ FD1C 93          >                    sub 	e
1393+ FD1D 5F          >                    ld 		e,a
1393+ FD1E 9F          >                    sbc 	a,a
1393+ FD1F 92          >                    sub 	d
1393+ FD20 57          >                    ld 		d,a
1394+ FD21 ED 53 D6 F5  .DeltaXPositive:        ld      (delta_x),de                    ;       .
1395+ FD25              ;.......................Scale down DY and DY to 7 bit
1396+ FD25 7C           .ScaleDXDY:             ld      a,h                             ; scale down so that dx and dx are < 256
1397+ FD26 B2                                   or      d                               ; .
1398+ FD27 CA 35 FD                             jp      z,.ScaleDXDYHighDone            ; .
1399+ FD2A                                      ShiftDERight1                           ; .
1399+ FD2A CB 3A       >			   srl d
1399+ FD2C CB 1B       >			   rr  e
1400+ FD2E                                      ShiftHLRight1                           ; .
1400+ FD2E CB 3C       >			   srl h
1400+ FD30 CB 1D       >			   rr  l
1401+ FD32 C3 25 FD                             jp      .ScaleDXDY                      ; .
1402+ FD35 7B           .ScaleDXDYHighDone:     ld      a,e                             ; because of signed maths we will scale down to 7 bits to be safe
1403+ FD36 B5                                   or      l                               ; .
1404+ FD37 F2 42 FD                             jp      p,.LowScaleDone                 ; .
1405+ FD3A                                      ShiftDERight1                           ; .
1405+ FD3A CB 3A       >			   srl d
1405+ FD3C CB 1B       >			   rr  e
1406+ FD3E                                      ShiftHLRight1                           ; .
1406+ FD3E CB 3C       >			   srl h
1406+ FD40 CB 1D       >			   rr  l
1407+ FD42              ;.......................Work out slope and gradient - later on we will work with deltax beign abs
1408+ FD42 ED 53 D6 F5  .LowScaleDone:          ld      (delta_x),de                    ; save adjusted dx and dy back
1409+ FD46 22 D8 F5                             ld      (delta_y),hl                    ; .
1410+ FD49 55                                   ld      d,l                             ; now d = dy e = dx
1411+ FD4A ED 53 DA F5                          ld      (delta_y_x),de                  ; save for diagnostics
1412+ FD4E              .SetUpTSlope:           ZeroA                                   ; Initialise tSlope to 0
1412+ FD4E AF          >                        xor a
1413+ FD4F 32 E4 F5                             ld      (tSlope),a                      ; .
1414+ FD52 7B                                   ld      a,e                             ; a = dx
1415+ FD53                                      JumpIfAGTENusng d, .deltaxGTEdeltaY     ; if dx < dy
1415+ FD53 BA          >                        cp     d
1415+ FD54 D2 67 FD    >                        jp		nc,.deltaxGTEdeltaY
1416+ FD57 43           .deltaXLTdeltaY:        ld      b,e                             ;       bc = dx $00
1417+ FD58 0E 00                                ld      c,0                             ;       .
1418+ FD5A 5A                                   ld      e,d                             ;       de = $00 dy
1419+ FD5B 16 00                                ld      d,0                             ;       .
1420+ FD5D CD 21 74                             call    Floor_DivQ                      ;       bc = bc / de  (dx * 256 / dy)
1421+ FD60 ED 43 E2 F5                          ld      (gradient),bc                   ;       in reality this is 8 bit little endian
1422+ FD64 C3 78 FD                             jp      .donedxdycheck                  ;       .
1423+ FD67                                                                              ; else
1424+ FD67 42           .deltaxGTEdeltaY:       ld      b,d                             ;       bc = dy << 0
1425+ FD68 0E 00                                ld      c,0                             ;       .
1426+ FD6A 16 00                                ld      d,0                             ;       de = 0dx
1427+ FD6C CD 21 74                             call    Floor_DivQ                      ;       bc = bc / de (dy * 256 / dx)
1428+ FD6F ED 43 E2 F5                          ld      (gradient),bc                   ;       in reality this is 8 bit little endian
1429+ FD73 3E FF                                ld      a,255                           ;       set tslope to -1
1430+ FD75 32 E4 F5                             ld      (tSlope),a                      ;       .
1431+ FD78              .donedxdycheck:                 // CHECK CORRECT POINT
1432+ FD78              ;.......................Clipping point 1
1433+ FD78                                      ;break
1434+ FD78 FD 7C                                ld      a,iyh                           ; if xx13 = 0 or xx13 = 128 (values can be 0, 128, 64 later we can optimise to see if its <> 64)
1435+ FD7A A7                                   and     a                               ; . [xx13 = 0  enter the block]
1436+ FD7B CA 81 FD                             jp      z,.xx13is0or128                 ; .
1437+ FD7E F2 A2 FD                             jp      p,.xx13not0or128                ; . [xx13 <> 128 then skip block]
1438+ FD81 CD BF FD     .xx13is0or128:          call    ClipLL118Elite                  ;       clip point 1
1439+ FD84 FD 7C                                ld      a,iyh                           ;       if xx13 <> 0
1440+ FD86 A7                                   and     a                               ;       .
1441+ FD87 CA 9E FD                             jp      z,.ImmediateDraw                ;       .
1442+ FD8A 3A AD F5                             ld      a,(x1+1)                        ;               if (if (x1 <0 || x1 > 255 || y1 <0 || y1 > 127)) return
1443+ FD8D A7                                   and     a                               ;               .
1444+ FD8E F8                                   ret     m                               ;               . [x1 high is negative then return]
1445+ FD8F C0                                   ret     nz                              ;               . [if x1 high is not zero, x1 > 255 return (above will have sorted negative test on bit 7)]
1446+ FD90 3A AF F5                             ld      a,(y1+1)                        ;               . [a = x1 high]
1447+ FD93 A7                                   and     a                               ;               .
1448+ FD94 F8                                   ret     m                               ;               . [if y1 negative return]
1449+ FD95 C0                                   ret     nz                              ;               . [if y1 > 255 return (above will have sorted negative test on bit 7)]
1450+ FD96 3A AE F5                             ld      a,(y1)                          ;               . [a = y1 low]
1451+ FD99 A7                                   and     a                               ;               .
1452+ FD9A F8                                   ret     m                               ;               . [if y1 > 127 then low byte would appear as negative in bit 7]
1453+ FD9B C3 A2 FD                             jp      .SkipCheckP1OnScreen            ;               else goto SkipCheckP1OnScreen
1454+ FD9E              .ImmediateDraw:         IFDEF SPLITORLINEX
1455+ FD9E CD BA F6                             call    l2_draw_clipped_line            ;        else if we get here we only needed to clip one point so draw the line
1456+ FDA1                                      ENDIF
1457+ FDA1 C9                                   ret                                     ;             and we are done
1458+ FDA2              .xx13not0or128:
1459+ FDA2 CD ED F5     .SkipCheckP1OnScreen:   call    SwapCoords                      ; swap point 1 and point 2 so we can now process P2
1460+ FDA5 CD BF FD                             call    ClipLL118Elite                  ; clip P2
1461+ FDA8 3A AD F5                             ld      a,(x1+1)                        ; if (x1 <0 || x1 > 255 || y1 <0 || y1 > 127) return
1462+ FDAB A7                                   and     a                               ; .
1463+ FDAC F8                                   ret     m                               ; . [if x1 negative return]
1464+ FDAD C0                                   ret     nz                              ; . [if x1 > 255 return (above will have sorted negative test on bit 7)]
1465+ FDAE 3A AF F5                             ld      a,(y1+1)                        ; . [a = y1 high]
1466+ FDB1 A7                                   and     a                               ;
1467+ FDB2 F8                                   ret     m                               ; . [if y1 negative return]
1468+ FDB3 C0                                   ret     nz                              ; . [if y1 > 255 return (above will have sorted negative test on bit 7)]
1469+ FDB4 3A AE F5                             ld      a,(y1)                          ; . [a = y1 low]
1470+ FDB7 A7                                   and     a                               ; .
1471+ FDB8 F8                                   ret     m                               ; . [if y1 low > 127 then low byte would appear as negative in bit 7]
1472+ FDB9              .ClipComplete:
1473+ FDB9              .xx13is0or128Draw:      IFDEF SPLITORLINEX
1474+ FDB9 CD BA F6                             call    l2_draw_clipped_line            ; if we get here we only needed to clip one point/have done all slipping needed
1475+ FDBC                                      ENDIF
1476+ FDBC C9                                   ret
1477+ FDBD              ;................................................................
1478+ FDBD 00 00        ClipSign                dw      0
1479+ FDBF              ClipLL118Elite:        ;break
1480+ FDBF 2A AC F5     .checkX1IsNegative      ld      hl,(x1)                         ; if x1 is negative
1481+ FDC2 CB 7C                                bit     7,h                             ; .
1482+ FDC4 CA E3 FD                             jp      z,.x1GTE0                       ; .
1483+ FDC7 3E FF        .x1LT0:                 ld      a,255                           ;       clip sign = -1
1484+ FDC9 32 BD FD                             ld      (ClipSign),a                    ;       .
1485+ FDCC CD 4B FE                             call    CalcLL120                       ;       calc ll120
1486+ FDCF 21 00 00                             ld      hl,0                            ;       x1 = 0
1487+ FDD2 22 AC F5                             ld      (x1),hl                         ;       .
1488+ FDD5 2A AE F5                             ld      hl,(y1)                         ;       y1 = y1 + result
1489+ FDD8 ED 5B 7D FC                          ld      de,(result)                     ;       . [and save in hl for optimisation processing y1]
1490+ FDDC 19                                   add     hl,de                           ;       .
1491+ FDDD 22 AE F5                             ld      (y1),hl                         ;       .
1492+ FDE0 C3 00 FE                             jp      .checkY1IsNegative              ;       .
1493+ FDE3 7C           .x1GTE0:                ld      a,h                             ; else
1494+ FDE4 A7                                   and     a                               ;       if x1 > 255
1495+ FDE5 CA 00 FE                             jp      z,.checkY1IsNegative            ;       .
1496+ FDE8                                      ZeroA                                   ;               sign must be 0 for postive adjustment
1496+ FDE8 AF          >                        xor a
1497+ FDE9 32 BD FD                             ld      (ClipSign),a                    ;               .
1498+ FDEC CD 4B FE                             call    CalcLL120                       ;               Calc LL120
1499+ FDEF 21 FF 00                             ld      hl,255                          ;               x1 = 255
1500+ FDF2 22 AC F5                             ld      (x1),hl                         ;               .
1501+ FDF5 2A AE F5                             ld      hl,(y1)                         ;               y1 = y1 + result
1502+ FDF8 ED 5B 7D FC                          ld      de,(result)                     ;               . [and save in hl for optimisation processing y1]
1503+ FDFC 19                                   add     hl,de                           ;               .
1504+ FDFD 22 AE F5                             ld      (y1),hl                         ;               .
1505+ FE00                                                                              ; end if
1506+ FE00 2A AE F5     .checkY1IsNegative:     ld      hl,(y1)                         ; if (y1 <0) [if we don;t need to clip x1 then we need to load hl with y1 as it never got loaded]
1507+ FE03 CB 7C                                bit     7,h                             ; .
1508+ FE05 CA 21 FE                             jp      z,.checkY1LT128                 ; .
1509+ FE08 3E FF                                ld      a,255                           ;       set sign to -1 for calc
1510+ FE0A 32 BD FD                             ld      (ClipSign),a                    ;       .
1511+ FE0D CD 98 FE                             call    CalcLL123                       ;       calc LL123
1512+ FE10 2A AC F5                             ld      hl,(x1)                         ;       x1 = x1 + result
1513+ FE13 ED 5B 7D FC                          ld      de,(result)                     ;       .
1514+ FE17 19                                   add     hl,de                           ;       .
1515+ FE18 22 AC F5                             ld      (x1),hl                         ;       .
1516+ FE1B 21 00 00                             ld      hl,0                            ;       y1 = 0
1517+ FE1E 22 AE F5                             ld      (y1),hl                         ;       .
1518+ FE21 7C           .checkY1LT128:          ld      a,h                             ; finished if y < 128
1519+ FE22 A7                                   and     a                               ; .
1520+ FE23 C2 29 FE                             jp      nz,.mopUpY1                     ; . [jump to mop up if y1 high <> 0, wehave already dealt with negatvies so don't need to consider that]
1521+ FE26 7D                                   ld      a,l                             ; . [now check y1 low and return if y1 low > 127]
1522+ FE27 A7                                   and     a                               ; .
1523+ FE28 F0                                   ret     p                               ; . [ if y1 low was positive then we are done as it means y1 < 128]
1524+ FE29 11 80 00     .mopUpY1:               ld      de,128                          ; y1 = y1 - 128
1525+ FE2C                                      ClearCarryFlag                          ; .
1525+ FE2C B7          >                        or a
1526+ FE2D ED 52                                sbc     hl,de                           ; .
1527+ FE2F 22 AE F5                             ld      (y1),hl                         ; .
1528+ FE32                                      ZeroA                                   ; set clip sign to 0
1528+ FE32 AF          >                        xor a
1529+ FE33 32 BD FD                             ld      (ClipSign),a                    ; to get to here if y1 < 0, y is set to 0, if its < 128 then it never reaches here, so y1 must be > 128 to get here
1530+ FE36 CD 98 FE                             call    CalcLL123                       ; calc LL123
1531+ FE39 2A AC F5                             ld      hl,(x1)                         ; x1 = x1 + result
1532+ FE3C ED 5B 7D FC                          ld      de,(result)                     ; .
1533+ FE40 19                                   add     hl,de                           ; .
1534+ FE41 22 AC F5                             ld      (x1),hl                         ; .
1535+ FE44 21 7F 00                             ld      hl,127                          ; y1 = 127
1536+ FE47 22 AE F5                             ld      (y1),hl                         ; .
1537+ FE4A C9                                   ret
1538+ FE4B
1539+ FE4B 2A AC F5     CalcLL120:              ld      hl,(x1)                         ; x1= |x1|
1540+ FE4E                                      macroAbsHL                              ; .
1540+ FE4E CB 7C       >                    bit     7,h
1540+ FE50 CA 59 FE    >                    jp      z,.alreadyABS
1540+ FE53 AF          >					xor 	a
1540+ FE54 95          >					sub 	l
1540+ FE55 6F          >					ld 		l,a
1540+ FE56 9F          >					sbc 	a,a
1540+ FE57 94          >					sub 	h
1540+ FE58 67          >					ld 		h,a
1540+ FE59             >.alreadyABS:
1541+ FE59 3A E4 F5                             ld      a,(tSlope)                      ; if (tslope == 0)
1542+ FE5C A7                                   and     a                               ; .
1543+ FE5D C2 7C FE                             jp      nz,.tSlopeNonZero               ; .
1544+ FE60 55           .tSlopeZero:            ld      d,l                             ;       d = x1 & 255
1545+ FE61 3A E2 F5                             ld      a,(gradient)                    ;       e = gradient
1546+ FE64 5F                                   ld      e,a                             ;
1547+ FE65 ED 30                                mul     de                              ;       de = x1 & 255 * gradient
1548+ FE67 5A                                   ld      e,d                             ;       de = x1 * gradient /256
1549+ FE68 16 00                                ld      d,0                             ;       .
1550+ FE6A 3A BD FD                             ld      a,(ClipSign)                    ;       if clipsign != 0
1551+ FE6D A7                                   and     a                               ;       .
1552+ FE6E CA 77 FE                             jp      z,.tSlopeZeroDone               ;       .
1553+ FE71              .tSlopeZeroNegate:      macronegate16de                         ;               result = - result
1553+ FE71 AF          >					xor 	a
1553+ FE72 93          >                    sub 	e
1553+ FE73 5F          >                    ld 		e,a
1553+ FE74 9F          >                    sbc 	a,a
1553+ FE75 92          >                    sub 	d
1553+ FE76 57          >                    ld 		d,a
1554+ FE77 ED 53 7D FC  .tSlopeZeroDone:        ld      (result),de                     ;
1555+ FE7B C9                                   ret                                     ;
1556+ FE7C              .tSlopeNonZero:         ;ld      a,(gradient)                    ; else  c = gradient
1557+ FE7C                                      ;ld      c,a                             ;       .
1558+ FE7C                                      ;ld      a,l                             ;       a = x1 & 255
1559+ FE7C                                      ;call    DIV16Amul256dCUNDOC             ;       bc = a * 256/c
1560+ FE7C
1561+ FE7C ED 5B E2 F5                          ld      de,(gradient)                   ; BC = BC / DE
1562+ FE80 45                                   ld      b,l
1563+ FE81 0E 00                                ld      c,0
1564+ FE83                                      ;; CORRECTED TO LADO INTO B ld      bc,hl                           ; HL = BC % DE
1565+ FE83 CD 21 74                             call    Floor_DivQ
1566+ FE86
1567+ FE86 3A BD FD                             ld      a,(ClipSign)                    ;       if clipsign != 0
1568+ FE89 A7                                   and     a                               ;       .
1569+ FE8A CA 93 FE                             jp      z,.tSlopeNonZeroDone            ;       .
1570+ FE8D              .tSlopeNonZeroNegate:   macronegate16bc                         ;               result = - result
1570+ FE8D AF          >					xor 	a
1570+ FE8E 91          >                    sub 	c
1570+ FE8F 4F          >                    ld 		c,a
1570+ FE90 9F          >                    sbc 	a,a
1570+ FE91 90          >                    sub 	b
1570+ FE92 47          >                    ld 		b,a
1571+ FE93 ED 43 7D FC  .tSlopeNonZeroDone:     ld      (result),bc
1572+ FE97 C9                                   ret
1573+ FE98              ;.......................LL123
1574+ FE98              CalcLL123:              ;break
1575+ FE98 2A AE F5                             ld      hl,(y1)                         ; hl = |y1|
1576+ FE9B                                      macroAbsHL                              ; .
1576+ FE9B CB 7C       >                    bit     7,h
1576+ FE9D CA A6 FE    >                    jp      z,.alreadyABS
1576+ FEA0 AF          >					xor 	a
1576+ FEA1 95          >					sub 	l
1576+ FEA2 6F          >					ld 		l,a
1576+ FEA3 9F          >					sbc 	a,a
1576+ FEA4 94          >					sub 	h
1576+ FEA5 67          >					ld 		h,a
1576+ FEA6             >.alreadyABS:
1577+ FEA6 3A E4 F5                             ld      a,(tSlope)                      ; if tSlope = 0
1578+ FEA9 A7                                   and     a                               ; .
1579+ FEAA C2 C8 FE                             jp      nz,.tSlopeNonZero               ; .
1580+ FEAD              .tSlopeZero:           ; ld      a,(gradient)                    ;       c = gradient
1581+ FEAD              ;                        ld      c,a                             ;       .
1582+ FEAD              ;                        ld      a,l                             ;       hl = y1 (which is now abs and < 256)
1583+ FEAD              ;                        call    DIV16Amul256dCUNDOC             ;       bc = A * 256 / c
1584+ FEAD ED 5B E2 F5                          ld      de,(gradient)                   ; BC = BC / DE
1585+ FEB1 44 4D                                ld      bc,hl                           ; HL = BC % DE
1586+ FEB3 CD 21 74                             call    Floor_DivQ
1587+ FEB6 3A BD FD                             ld      a,(ClipSign)                    ;       if clipsign != 0
1588+ FEB9 A7                                   and     a                               ;       .
1589+ FEBA CA C3 FE                             jp      z, .tSlopeZeroDone              ;       .
1590+ FEBD              .tSlopeZeroNegate:      macronegate16bc                         ;               result = -result
1590+ FEBD AF          >					xor 	a
1590+ FEBE 91          >                    sub 	c
1590+ FEBF 4F          >                    ld 		c,a
1590+ FEC0 9F          >                    sbc 	a,a
1590+ FEC1 90          >                    sub 	b
1590+ FEC2 47          >                    ld 		b,a
1591+ FEC3 ED 43 7D FC  .tSlopeZeroDone:        ld      (result),bc                     ;       . save result in either case
1592+ FEC7 C9                                   ret                                     ;       .
1593+ FEC8 55           .tSlopeNonZero:         ld      d,l                             ; else  d = |y1| low
1594+ FEC9 3A E2 F5                             ld      a,(gradient)                    ;       e = gradient
1595+ FECC 5F                                   ld      e,a                             ;       .
1596+ FECD ED 30                                mul     de                              ;       de = l * gradient
1597+ FECF 5A                                   ld      e,d                             ;       de = l * gradient /256
1598+ FED0 16 00                                ld      d,0                             ;       .
1599+ FED2 3A BD FD                             ld      a,(ClipSign)                    ;       if clipsign != 0
1600+ FED5 A7                                   and     a                               ;
1601+ FED6 CA DF FE                             jp      z,.tSlopeNonZeroDone            ;
1602+ FED9              .tSlopeNonZeroNegate:   macronegate16de                         ;               result = -result
1602+ FED9 AF          >					xor 	a
1602+ FEDA 93          >                    sub 	e
1602+ FEDB 5F          >                    ld 		e,a
1602+ FEDC 9F          >                    sbc 	a,a
1602+ FEDD 92          >                    sub 	d
1602+ FEDE 57          >                    ld 		d,a
1603+ FEDF ED 53 7D FC  .tSlopeNonZeroDone:     ld      (result),de                     ;       . save result in either case
1604+ FEE3 C9                                   ret                                     ;       .
1605+ FEE4
# file closed: ../../Layer2Graphics/l2_draw_any_line.asm
 672  FEE4                  INCLUDE "../../Layer2Graphics/l2_draw_line_v2.asm"
# file opened: ../../Layer2Graphics/l2_draw_line_v2.asm
   1+ FEE4              ; ******************************************************************************
   2+ FEE4              ;
   3+ FEE4              ;	Draw a pixel line from (x0,y0) defined in (COORDS) - the current plot
   4+ FEE4              ;	coordinate, to the relative distance points (x0+x,y0+y).
   5+ FEE4              ;
   6+ FEE4              ;	Design & programming by Gunther Strube,	Copyright (C) InterLogic 1995
   7+ FEE4              ;
   8+ FEE4              ;	The (COORDS+0)	pointer contains the current y coordinate, (COORDS+1) the
   9+ FEE4              ;	current x coordinate. The main program should reset the (COORDS) variables
  10+ FEE4              ;	before using line drawing.
  11+ FEE4              ;
  12+ FEE4              ;	The routine checks the range of specified coordinates which is the
  13+ FEE4              ;	boundaries of the graphics area (256x64	pixels).
  14+ FEE4              ;	If a boundary error occurs the routine exits automatically.	This may be
  15+ FEE4              ;	useful if you are trying to draw a line longer than allowed. Only the
  16+ FEE4              ;	visible part will be drawn.
  17+ FEE4              ;
  18+ FEE4              ;	The hardware graphics memory is organized as (0,0) in the top left corner.
  19+ FEE4              ;
  20+ FEE4              ;	The plot routine is	defined by an address pointer	in IX.
  21+ FEE4              ;
  22+ FEE4              ;	IN:	HL =	move	relative x horisontal points (maximum +/- 255).
  23+ FEE4              ;		DE =	move	relative y vertical	points (maximum +/-	255).
  24+ FEE4              ;		IX =	pointer to plot routine that uses HL = (x,y)	of plot coordinate.
  25+ FEE4              ;
  26+ FEE4              ;	OUT:	None.
  27+ FEE4              ;
  28+ FEE4              ;	Registers	used	by routine:
  29+ FEE4              ;		   N	:	B, loop counter
  30+ FEE4              ;		   i	:	line	balance variable
  31+ FEE4              ;		   x	:	H/L,	horisontal, vertical distance	variables
  32+ FEE4              ;		   y	:	H/L,	horisontal, vertical distance	variables
  33+ FEE4              ;	  (x0,y0)	:	(h,l)
  34+ FEE4              ;	  direc_x	:	d, horisontal step increment
  35+ FEE4              ;	  direc_y	:	e, vertical step increment
  36+ FEE4              ;		 ddx	:	b, horisontal step increment
  37+ FEE4              ;		 ddy	:	c, vertical step increment
  38+ FEE4              ;
  39+ FEE4              ;		DE, A work registers.
  40+ FEE4              ;
  41+ FEE4              ; The algorithm in pseudo-code:
  42+ FEE4              ;
  43+ FEE4              ;	direc_x =	SGN x: direc_y	= SGN y
  44+ FEE4              ;	x = ABS x: y =	ABS y
  45+ FEE4              ;
  46+ FEE4              ;	if x	>= y
  47+ FEE4              ;		if x+y=0 then return
  48+ FEE4              ;		H = x
  49+ FEE4              ;		L = y
  50+ FEE4              ;		ddx = direc_x
  51+ FEE4              ;		ddy = 0
  52+ FEE4              ;	else
  53+ FEE4              ;		H = y
  54+ FEE4              ;		L = x
  55+ FEE4              ;		ddx = 0
  56+ FEE4              ;		ddy = direc_y
  57+ FEE4              ;	endif
  58+ FEE4              ;
  59+ FEE4              ;	B = H
  60+ FEE4              ;	i = INT(B/2)
  61+ FEE4              ;	FOR N=B TO 1 STEP -1
  62+ FEE4              ;		i = i + L
  63+ FEE4              ;		if i	< H
  64+ FEE4              ;			ix =	ddx
  65+ FEE4              ;			iy =	ddy
  66+ FEE4              ;		else
  67+ FEE4              ;			i = i - H
  68+ FEE4              ;			ix =	direc_x
  69+ FEE4              ;			iy =	direc_y
  70+ FEE4              ;		endif
  71+ FEE4              ;		x0 =	x0 +	ix
  72+ FEE4              ;		y0 =	y0 +	iy
  73+ FEE4              ;		plot	(x0,y0)
  74+ FEE4              ;	NEXT	N
  75+ FEE4              ;
  76+ FEE4              ;
  77+ FEE4              ;	Registers	changed after return:
  78+ FEE4              ;		..BCDEHL/IXIY/af......	same
  79+ FEE4              ;		AF....../..../..bcdehl	different
  80+ FEE4              ;
  81+ FEE4 00 00        line_gfx_coords         dw  0
  82+ FEE6
  83+ FEE6              LineHLtoDE:
  84+ FEE6 7C           TestMaxY:               ld	a,h ; were h = y or l = y?
  85+ FEE7 FE C0                                cp	192
  86+ FEE9 30 26                                jr	nc, exit_line		; y0	coordinate out	of range
  87+ FEEB 7A                                   ld	a,d
  88+ FEEC FE C0                                cp	192
  89+ FEEE 30 21                                jr	nc, exit_line		; y1	coordinate out	of range
  90+ FEF0 22 E4 FE                             ld	(line_gfx_coords),hl		; the starting	point is now default
  91+ FEF3 E5                                   push	hl
  92+ FEF4 D5                                   push	de
  93+ FEF5 6C                                   ld	l,h				; L = x0
  94+ FEF6 62                                   ld	h,d				; H = x1
  95+ FEF7 7C           distanceX:		        ld	a,h
  96+ FEF8 95                                   sub	l
  97+ FEF9 6F                                   ld	l,a
  98+ FEFA 26 00                                ld	h,0
  99+ FEFC 30 02                                jr	nc, distanceXDone
 100+ FEFE 26 FF                                ld	h,-1
 101+ FF00 D1           distanceXDone:          pop	de
 102+ FF01 E3                                   ex	(sp),hl			; L = y0
 103+ FF02 63                                   ld	h,e				; H = y1
 104+ FF03 7C           distanceY:		        ld	a,h
 105+ FF04 95                                   sub	l
 106+ FF05 6F                                   ld	l,a
 107+ FF06 26 00                                ld	h,0
 108+ FF08 30 02                                jr	nc, distanceYDone
 109+ FF0A 26 FF                                ld	h,-1
 110+ FF0C D1           distanceYDone:          pop	de
 111+ FF0D EB                                   ex	de,hl			; h.dist.	= HL, v.dist. = DE
 112+ FF0E CD 12 FF                             call	DrawLineRelative			; draw line...
 113+ FF11 C9           exit_line:              ret
 114+ FF12
 115+ FF12              ; ***************************************************************************
 116+ FF12              ;
 117+ FF12              ;	IN:	HL =	move	relative x horisontal points (maximum +/- 255).
 118+ FF12              ;		DE =	move	relative y vertical	points (maximum +/-	255).
 119+ FF12              ;
 120+ FF12              ; OUT: h - l distance in	HL
 121+ FF12              ;
 122+ FF12
 123+ FF12 D5           DrawLineRelative:       push	de
 124+ FF13 E5                                   push	hl
 125+ FF14 D9                                   exx
 126+ FF15 E1                                   pop	hl					; get relative	horisontal movement
 127+ FF16 CD 8D FF                             call	sgn
 128+ FF19 57                                   ld	d,a					; direc_x	= SGN(x) installed d = +/-1 for horizontal update
 129+ FF1A CD 9A FF                             call	absValue
 130+ FF1D 45                                   ld	b,l					; x = ABS(x)
 131+ FF1E E1           DrawLineGetVertRelative:pop	hl					; get relative	vertical movement
 132+ FF1F CD 8D FF                             call	sgn
 133+ FF22 5F                                   ld	e,a					; direc_y	= SGN(y) installed  = +/-1 for vertical update
 134+ FF23 CD 9A FF                             call	absValue
 135+ FF26 4D                                   ld	c,l					; y = ABS(y) so now bc = dxdy
 136+ FF27              ; so by here BC = dx dy HL in increment/decrement x y
 137+ FF27 C5                                   push	bc
 138+ FF28 D9                                   exx
 139+ FF29 E1                                   pop	hl					; H = absolute	x dist., L = absolute y distance
 140+ FF2A 7C                                   ld	a,h
 141+ FF2B BD                                   cp	l
 142+ FF2C 38 0A                                jr	c, x_smaller_y		; if	x >=	y
 143+ FF2E B4           areXandYZero:           or	h					;	if x+y = 0
 144+ FF2F 28 5B                                jr	z, exit_draw		;		return
 145+ FF31 D9           y_lessorequal_x:        exx						;	else
 146+ FF32 42                                   ld	b,d					;		ddx = direc_x
 147+ FF33 0E 00                                ld	c,0					;		ddy = 0
 148+ FF35 D9                                   exx
 149+ FF36 18 08                                jr	init_drawloop		; else
 150+ FF38 7C           x_smaller_y:	        ld	a,h
 151+ FF39 65                                   ld	h,l					;	H = y
 152+ FF3A 6F                                   ld	l,a					;	L = x
 153+ FF3B D9                                   exx
 154+ FF3C 06 00                                ld	b,0					;	ddx = 0
 155+ FF3E 4B                                   ld	c,e					;	ddy = direc_y
 156+ FF3F D9                                   exx
 157+ FF40 44           init_drawloop:	        ld	b,h
 158+ FF41 4C                                   ld	c,h					; B = H
 159+ FF42 CB 39                                srl	c					; i = INT(B/2)
 160+ FF44              										; FOR N=B	TO 1	STEP	-1
 161+ FF44 79           drawloop:		        ld	a,c
 162+ FF45 85                                   add	a,l
 163+ FF46 38 09                                jr	c, i_greater		;	i + L > 255  (i > H)
 164+ FF48 BC                                   cp	h
 165+ FF49 30 06                                jr	nc, i_greater		;	if i	< H
 166+ FF4B 4F                                   ld	c,a					;		i = i + L
 167+ FF4C D9                                   exx
 168+ FF4D C5                                   push	bc				;		ix =	ddx:	iy =	ddy
 169+ FF4E D9                                   exx
 170+ FF4F 18 05                                jr	check_plot			;	else
 171+ FF51 94           i_greater:		        sub	h					;		i = i - H
 172+ FF52 4F                                   ld	c,a
 173+ FF53 D9                                   exx
 174+ FF54 D5                                   push	de				;		ix =	direc_x: iy = direc_y
 175+ FF55 D9                                   exx						;	endif
 176+ FF56 E3           check_plot:		        ex	(sp),hl				;	preserve H,L distances on stack
 177+ FF57 EB                                   ex	de,hl				;	D,E = ix,	iy
 178+ FF58 2A E4 FE                             ld	hl,(line_gfx_coords)
 179+ FF5B 7D                                   ld	a,l
 180+ FF5C 83                                   add	a,e					;
 181+ FF5D 6F                                   ld	l,a					;	y0 =	y0 +	iy (y0 is	checked by plot)
 182+ FF5E 7A                                   ld	a,d
 183+ FF5F 3C                                   inc	a
 184+ FF60 84                                   add	a,h
 185+ FF61 38 04                                jr	c, check_range		;	check out	of range
 186+ FF63 28 26                                jr	z, range_error		;	Fz=1	& Fc=0 denotes	x0 <	0
 187+ FF65 18 02                                jr	plot_point
 188+ FF67 20 22        check_range:            jr	nz, range_error	;	Fz=0	& Fc=1 denotes	x0 >	255
 189+ FF69
 190+ FF69 3D           plot_point:             dec	a
 191+ FF6A C5                                   push	bc
 192+ FF6B F5                                   push	af
 193+ FF6C 47                                   ld	    b,a					;	x0 =	x0 +	ix
 194+ FF6D 4D                                   ld		c,l
 195+ FF6E 3A 8D E2                             ld		a,(line_gfx_colour)
 196+ FF71 ED 43 E4 FE                          ld      (line_gfx_coords),bc
 197+ FF75                                      l2_plot_macro; call	l2_plot_pixel:
 197+ FF75 78          >                        ld      a,b
 197+ FF76             >                        JumpIfAGTENusng 192 ,.NoPlot
 197+ FF76 FE C0       >                        cp     192
 197+ FF78 D2 84 FF    >                        jp		nc,.NoPlot
 197+ FF7B 69          >                        ld      l,c
 197+ FF7C CD 68 E0    >                        call    asm_l2_row_bank_select
 197+ FF7F 67          >                        ld      h,a
 197+ FF80 3A 8D E2    >                        ld      a,(line_gfx_colour)
 197+ FF83 77          >                        ld      (hl),a
 197+ FF84             >.NoPlot:
 198+ FF84 F1                                   pop		af
 199+ FF85 C1                                   pop		bc
 200+ FF86 E1           plot_RET:		        pop	hl					;	restore H,L distances...
 201+ FF87 10 BB                                djnz	drawloop		; NEXT N
 202+ FF89 18 01                                jr	exit_draw
 203+ FF8B
 204+ FF8B E1           range_error:	        pop	hl					; remove H,L distances...
 205+ FF8C C9           exit_draw:		        ret
 206+ FF8D
 207+ FF8D
 208+ FF8D              ; ******************************************************************************
 209+ FF8D              ;
 210+ FF8D              ;	SGN (Signum value) of 16	bit signed integer.
 211+ FF8D              ;
 212+ FF8D              ;	IN:		HL =	integer
 213+ FF8D              ;	OUT:		A = result: 0,1,-1 (if zero, positive, negative)
 214+ FF8D              ;
 215+ FF8D              ;	Registers	changed after return:
 216+ FF8D              ;	..BCDEHL/IXIY	same
 217+ FF8D              ;	AF....../....	different
 218+ FF8D              ;
 219+ FF8D 7C           sgn:				    ld	a,h
 220+ FF8E B5                                   or	l
 221+ FF8F C8                                   ret	z				; integer	is zero, return 0...
 222+ FF90 CB 7C                                bit	7,h
 223+ FF92 20 03                                jr	nz, negative_int
 224+ FF94 3E 01                                ld	a,1
 225+ FF96 C9                                   ret
 226+ FF97 3E FF        negative_int:		    ld	a,-1
 227+ FF99 C9                                   ret
 228+ FF9A
 229+ FF9A
 230+ FF9A              ; ******************************************************************************
 231+ FF9A              ;
 232+ FF9A              ;	ABS (Absolute value) of 16 bit signed integer.
 233+ FF9A              ;
 234+ FF9A              ;	IN:		HL =	integer
 235+ FF9A              ;	OUT:		HL =	converted	integer
 236+ FF9A              ;
 237+ FF9A              ;	Registers	changed after return:
 238+ FF9A              ;	A.BCDE../IXIY	same
 239+ FF9A              ;	.F....HL/....	different
 240+ FF9A              ;
 241+ FF9A CB 7C        absValue:			    bit	7,h
 242+ FF9C C8                                   ret	z				; integer	is positive...
 243+ FF9D D5                                   push	de
 244+ FF9E EB                                   ex	de,hl
 245+ FF9F 21 00 00                             ld	hl,0
 246+ FFA2 BF                                   cp	a				; Fc	= 0,	may not be used...
 247+ FFA3 ED 52                                sbc	hl,de			; convert	negative integer
 248+ FFA5 D1                                   pop	de
 249+ FFA6 C9                                   ret
 250+ FFA7
# file closed: ../../Layer2Graphics/l2_draw_line_v2.asm
 673  FFA7                  DISPLAY "Bank ",BankLAYER2," - Bytes free ",/D, $2000 - ($-LAYER2Addr), " - BankLAYER2"
 674  FFA7              ; Bank 58  ------------------------------------------------------------------------------------------------------------------------
 675  FFA7                  SLOT    LAYER1Addr
 676  FFA7                  PAGE    BankLAYER1
 677  FFA7                  ORG     LAYER1Addr, BankLAYER1
 678  E000 42 61 6E 6B  Layer1Header:  DB "Bank L1 Utils--"
 678  E004 20 4C 31 20
 678  E008 55 74 69 6C
 678  E00C 73 2D 2D
 679  E00F
 680  E00F                  INCLUDE "../../Layer1Graphics/layer1_attr_utils.asm"
# file opened: ../../Layer1Graphics/layer1_attr_utils.asm
   1+ E00F
   2+ E00F 00 58        L1AttrRow00:            DW $5800                    ;Row 1    */
   3+ E011 20 58        L1AttrRow01:            DW $5820                    ;Row 2    */
   4+ E013 40 58        L1AttrRow02:            DW $5840                    ;Row 3    */
   5+ E015 60 58        L1AttrRow03:            DW $5860                    ;Row 4    */
   6+ E017 80 58        L1AttrRow04:            DW $5880                    ;Row 5    */
   7+ E019 A0 58        L1AttrRow05:            DW $58A0                    ;Row 6    */
   8+ E01B C0 58        L1AttrRow06:            DW $58C0                    ;Row 7    */
   9+ E01D E0 58        L1AttrRow07:            DW $58E0                    ;Row 8    */
  10+ E01F 00 59        L1AttrRow08:            DW $5900                    ;Row 9    */
  11+ E021 20 59        L1AttrRow09:            DW $5920                    ;Row 10   */
  12+ E023 40 59        L1AttrRow10:            DW $5940                    ;Row 11   */
  13+ E025 60 59        L1AttrRow11:            DW $5960                    ;Row 12   */
  14+ E027 80 59        L1AttrRow12:            DW $5980                    ;Row 13   */
  15+ E029 A0 59        L1AttrRow13:            DW $59A0                    ;Row 14   */
  16+ E02B C0 59        L1AttrRow14:            DW $59C0                    ;Row 15   */
  17+ E02D E0 59        L1AttrRow15:            DW $59E0                    ;Row 16   */
  18+ E02F 00 5A        L1AttrRow16:            DW $5A00                    ;Row 17   */
  19+ E031 20 5A        L1AttrRow17:            DW $5A20                    ;Row 18   */
  20+ E033 40 5A        L1AttrRow18:            DW $5A40                    ;Row 19   */
  21+ E035 60 5A        L1AttrRow19:            DW $5A60                    ;Row 20   */
  22+ E037 80 5A        L1AttrRow20:            DW $5A80                    ;Row 21   */
  23+ E039 A0 5A        L1AttrRow21:            DW $5AA0                    ;Row 22   */
  24+ E03B C0 5A        L1AttrRow22:            DW $5AC0                    ;Row 23   */
  25+ E03D E0 5A        L1AttrRow23:            DW $5AE0                    ;Row 23   */
  26+ E03F
  27+ E03F              ; "l2_hilight_row, d = row, e = colour"
  28+ E03F 21 0F E0     l1_hilight_row:         ld      hl, L1AttrRow00
  29+ E042 4B                                   ld      c,e
  30+ E043 7A                                   ld      a,d
  31+ E044 CB 27                                sla     a
  32+ E046 ED 31                                add     hl,a
  33+ E048 7E                                   ld      a,(hl)
  34+ E049 5F                                   ld      e,a
  35+ E04A 23                                   inc     hl
  36+ E04B 7E                                   ld      a,(hl)
  37+ E04C 57                                   ld      d,a
  38+ E04D EB                                   ex      hl,de
  39+ E04E 79                                   ld		a,c
  40+ E04F 11 20 00                             ld		de, 32
  41+ E052 CD F0 67                             call	memfill_dma
  42+ E055 C9                                   ret
  43+ E056
# file closed: ../../Layer1Graphics/layer1_attr_utils.asm
 681  E056                  INCLUDE "../../Layer1Graphics/layer1_cls.asm"
# file opened: ../../Layer1Graphics/layer1_cls.asm
   1+ E056 AF           l1_cls_top:             xor     a
   2+ E057 21 00 40                             ld      hl, $4000
   3+ E05A 11 00 08                             ld      de, $0800
   4+ E05D CD F0 67                             call    memfill_dma
   5+ E060 C9                                   ret
   6+ E061
   7+ E061 AF           l1_cls_mid:             xor     a
   8+ E062 21 00 48                             ld      hl, $4800
   9+ E065 11 00 08                             ld      de, $0800
  10+ E068 CD F0 67                             call    memfill_dma
  11+ E06B C9                                   ret
  12+ E06C
  13+ E06C AF           l1_cls_bottom:          xor     a
  14+ E06D 21 00 50                             ld      hl, $5000
  15+ E070 11 00 08                             ld      de, $0800
  16+ E073 CD F0 67                             call    memfill_dma
  17+ E076 C9                                   ret
  18+ E077
  19+ E077              ; Designed specifically to clear a whole character aligned line
  20+ E077 1E 00        l1_cls_line_d:          ld      e,0
  21+ E079 ED 94                                pixelad
  22+ E07B 11 00 01                             ld      de,32 * 8
  23+ E07E AF                                   xor     a
  24+ E07F CD F0 67                             call    memfill_dma
  25+ E082 C9                                   ret
  26+ E083
  27+ E083              ; Designed specifically to clear a whole character aligned 2 lines line, used for say clearing hyperspace message
  28+ E083 1E 00        l1_cls_2_lines_d:       ld      e,0
  29+ E085 ED 94                                pixelad
  30+ E087 11 00 02                             ld      de,32 * 16
  31+ E08A AF                                   xor     a
  32+ E08B CD F0 67                             call    memfill_dma
  33+ E08E C9                                   ret
  34+ E08F
  35+ E08F AF           l1_cls:                 xor		a
  36+ E090 21 00 40     l1_cls_to_a:            ld		hl,	$4000
  37+ E093 11 00 18                             ld		de, $1800
  38+ E096 CD F0 67                             call	memfill_dma
  39+ E099 C9                                   ret
  40+ E09A
  41+ E09A 21 00 58     l1_attr_cls_2DlinesA:   ld		hl,	$5800
  42+ E09D 1E 20                                ld      e,32
  43+ E09F ED 30                                mul
  44+ E0A1 19                                   add     hl,de
  45+ E0A2 11 40 00                             ld		de, 32 * 2
  46+ E0A5 CD F0 67                             call	memfill_dma
  47+ E0A8 C9                                   ret
  48+ E0A9
  49+ E0A9
  50+ E0A9 AF           l1_attr_cls:            xor		a
  51+ E0AA 21 00 58     l1_attr_cls_to_a:       ld		hl,	$5800
  52+ E0AD 11 00 03                             ld		de, $0300
  53+ E0B0 CD F0 67                             call	memfill_dma
  54+ E0B3 C9                                   ret
  55+ E0B4
  56+ E0B4 01 FE FE     l1_set_border:          ld	    bc, 0xFEFE
  57+ E0B7 ED 79                                out		(c),a
  58+ E0B9 C9                                   ret
# file closed: ../../Layer1Graphics/layer1_cls.asm
 682  E0BA                  INCLUDE "../../Layer1Graphics/layer1_print_at.asm"
# file opened: ../../Layer1Graphics/layer1_print_at.asm
   1+ E0BA              ; "l1 print char a = character, de = Ypixel Xchar of print"
   2+ E0BA D5 E5        l1_print_char:          push	de,,hl
   3+ E0BC ED 94                                pixelad								; hl = address of de
   4+ E0BE E5                                   push	hl							; save hl for loop
   5+ E0BF 26 00                                ld		h,0
   6+ E0C1 6F                                   ld		l,a
   7+ E0C2 29                                   add		hl,hl						; * 2
   8+ E0C3 29                                   add		hl,hl						; * 4
   9+ E0C4 29                                   add		hl,hl						; * 8 to get byte address
  10+ E0C5 ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
  11+ E0C9 EB                                   ex		de,hl						; save address into de
  12+ E0CA E1                                   pop		hl							; get back hl for loop
  13+ E0CB 06 08                                ld		b,8							; do 8 rows
  14+ E0CD 1A           .PrintCharLoop:         ld		a,(de)						; row byte
  15+ E0CE 13                                   inc		de							; next byte
  16+ E0CF 77                                   ld		(hl),a						; poke to screen
  17+ E0D0 ED 93                                pixeldn								; Down 1 row
  18+ E0D2 10 F9                                djnz	.PrintCharLoop				; loop for 8 bytes
  19+ E0D4 E1 D1                                pop		de,,hl					    ; restore hl
  20+ E0D6 C9                                   ret
  21+ E0D7
  22+ E0D7              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
  23+ E0D7              ; now skips ascii code < 32 but moves on cursor by 1 char
  24+ E0D7              l1_print_at:
  25+ E0D7 7E           .PrintLoop:             ld		a,(hl)
  26+ E0D8 FE 00                                cp		0
  27+ E0DA C8                                   ret		z
  28+ E0DB                                      CallIfAGTENusng " ", l1_print_char
  28+ E0DB FE 20       >                        cp      " "
  28+ E0DD D4 BA E0    >                        call	nc,l1_print_char
  29+ E0E0 23                                   inc		hl							; move 1 message character right
  30+ E0E1 7B                                   ld		a,e
  31+ E0E2 C6 08                                add		a,8
  32+ E0E4 5F                                   ld		e,a							; move 1 screen character right
  33+ E0E5 18 F0                                jr		.PrintLoop
  34+ E0E7                                                      DISPLAY "TODO: looks liek rogue popde"
  35+ E0E7              .Clearstackandfinish:   ;pop		de                      ; TODO LOOOKS TO BE A ROGUE POPDE
  36+ E0E7 C9                                   ret
  37+ E0E8
  38+ E0E8              ;l1_print_at_wrap:
  39+ E0E8              ;; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
  40+ E0E8              ;	ld      iyh,e
  41+ E0E8              ;.PrintLoop:
  42+ E0E8              ;	ld		a,(hl)
  43+ E0E8              ;	cp		0
  44+ E0E8              ;	ret		z
  45+ E0E8              ;.CountWordCharLen
  46+ E0E8              ;; Need to change to word wrap, so it will loop through string as before
  47+ E0E8              ;; but read up until a null or space, take the character count * 8 for pixels
  48+ E0E8              ;; if that is > 238 then force a premature line wrap
  49+ E0E8              ;
  50+ E0E8              ;
  51+ E0E8              ;    push    iy
  52+ E0E8              ;    call	l1_print_char
  53+ E0E8              ;    pop     iy
  54+ E0E8              ;	inc		hl							; move 1 message character right
  55+ E0E8              ;	ld		a,e
  56+ E0E8              ;    cp      238
  57+ E0E8              ;    jr      nc,.NextLine
  58+ E0E8              ;	add		a,8
  59+ E0E8              ;	ld		e,a							; move 1 screen character right
  60+ E0E8              ;	jr		.PrintLoop
  61+ E0E8              ;.Clearstackandfinish:
  62+ E0E8              ;	pop		de
  63+ E0E8              ;	ret
  64+ E0E8              ;.NextLine:
  65+ E0E8              ;    ld      a,(hl)
  66+ E0E8              ;    cp      " "
  67+ E0E8              ;    ld      e,iyh
  68+ E0E8              ;    ld      a,d
  69+ E0E8              ;    add     a,8
  70+ E0E8              ;    ld      d,a
  71+ E0E8              ;    jr		.PrintLoop
  72+ E0E8
  73+ E0E8              ; Counts next word at hl, uses e and forces a wrap if it would over flow puts value in c
  74+ E0E8 E5           L1LenWordAtHL:          push    hl
  75+ E0E9 D5                                   push    de
  76+ E0EA 7E           .CountLoop:             ld      a,(hl)
  77+ E0EB FE 00                                cp      0
  78+ E0ED 28 0F                                jr      z,.CountDone
  79+ E0EF FE 20                                cp      32
  80+ E0F1 28 0B                                jr      z,.CountDone
  81+ E0F3 7B                                   ld      a,e
  82+ E0F4 C6 08                                add     a,8
  83+ E0F6 5F                                   ld      e,a
  84+ E0F7 FE EE                                cp      238
  85+ E0F9 30 07                                jr      nc,.TooLong
  86+ E0FB 23                                   inc     hl
  87+ E0FC 18 EC                                jr      .CountLoop
  88+ E0FE D1           .CountDone:             pop     de
  89+ E0FF E1                                   pop     hl
  90+ E100 AF                                   xor     a
  91+ E101 C9                                   ret
  92+ E102 D1           .TooLong                pop     de
  93+ E103 E1                                   pop     hl
  94+ E104 3E FF                                ld      a,$FF
  95+ E106 C9                                   ret
  96+ E107
  97+ E107 7E           L1PrintWordAtHL:        ld      a,(hl)
  98+ E108 FE 00                                cp      0
  99+ E10A C8                                   ret     z
 100+ E10B FE 20                                cp      32
 101+ E10D 28 0F                                jr      z,.ItsASpace
 102+ E10F FD E5                                push    iy
 103+ E111 CD BA E0                             call	l1_print_char
 104+ E114 FD E1                                pop     iy
 105+ E116 7B                                   ld      a,e
 106+ E117 C6 08                                add     a,8
 107+ E119 5F                                   ld      e,a
 108+ E11A 23                                   inc     hl
 109+ E11B C3 07 E1                             jp      L1PrintWordAtHL
 110+ E11E 23           .ItsASpace:             inc     hl      ;  Just a bodge for now
 111+ E11F 7B                                   ld      a,e
 112+ E120 C6 08                                add     a,8
 113+ E122 5F                                   ld      e,a
 114+ E123 C9                                   ret
 115+ E124
 116+ E124
 117+ E124              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
 118+ E124              ; Now has full word level wrapping
 119+ E124 FD 63        l1_print_at_wrap:       ld      iyh,e
 120+ E126 7E           .PrintLoop:             ld		a,(hl)
 121+ E127 FE 00                                cp		0
 122+ E129 C8                                   ret		z
 123+ E12A CD E8 E0     .CountWordCharLen:      call    L1LenWordAtHL
 124+ E12D FE FF                                cp      $FF
 125+ E12F 28 06                                jr      z,.WrapNextLine
 126+ E131 CD 07 E1     .NotTooLong:            call    L1PrintWordAtHL
 127+ E134              ; Need to change to word wrap, so it will loop through string as before
 128+ E134              ; but read up until a null or space, take the character count * 8 for pixels
 129+ E134              ; if that is > 238 then force a premature line wrap
 130+ E134 18 F0                                jr		.PrintLoop
 131+ E136              .Clearstackandfinish:   ;op		de
 132+ E136 C9                                   ret
 133+ E137              .WrapNextLine:
 134+ E137 FD 5C        .NextLine:              ld      e,iyh
 135+ E139 7A                                   ld      a,d
 136+ E13A C6 08                                add     a,8
 137+ E13C 57                                   ld      d,a
 138+ E13D 18 E7                                jr		.PrintLoop
 139+ E13F
 140+ E13F
# file closed: ../../Layer1Graphics/layer1_print_at.asm
 683  E13F                  DISPLAY "Bank ",BankLAYER1," - Bytes free ",/D, $2000 - ($-LAYER1Addr), " - BankLAYER1"
 684  E13F              ; Bank 59  ------------------------------------------------------------------------------------------------------------------------
 685  E13F              ; In the first copy of the banks the "Non number" labels exist. They will map directly in other banks
 686  E13F              ; as the is aligned and data tables are after that
 687  E13F              ; need to make the ship index tables same size in each to simplify further
 688  E13F                  SLOT    ShipModelsAddr
 689  E13F                  PAGE    BankShipModels1
 690  E13F              	ORG     ShipModelsAddr, BankShipModels1
 691  E000
 692  E000              MShipBankTable          MACRO
 693  E000 ~                                    DW      BankShipModels1
 694  E000 ~                                    DW      BankShipModels2
 695  E000 ~                                    DW      BankShipModels3
 696  E000 ~                                    DW      BankShipModels4
 697  E000                                      ENDM
 698  E000              ; For ship number A fetch
 699  E000              ;           the adjusted ship number in B , C = original number
 700  E000              ;           bank number in A for the respective ship based on the ship table
 701  E000              MGetShipBankId:         MACRO   banktable
 702  E000 ~                                    ld      b,0
 703  E000 ~                                    ld      c,a                                 ; c= original ship id
 704  E000 ~            .ShiftLoop:             srl     a
 705  E000 ~                                    srl     a
 706  E000 ~                                    srl     a
 707  E000 ~                                    srl     a                                   ; divide by 16
 708  E000 ~                                    ld      b,a                                 ; b = bank nbr
 709  E000 ~                                    ld      a,c
 710  E000 ~                                    ld      d,b
 711  E000 ~                                    ld      e,16
 712  E000 ~                                    mul                                         ; de = 16 * bank number (max is about 15 banks)
 713  E000 ~                                    sub     e                                   ; a= actual model id now
 714  E000 ~            .SelectedBank:          ld      d,b                                 ; save current bank number
 715  E000 ~                                    ld      b,a                                 ; b = adjusted ship nbr
 716  E000 ~                                    ld      a,d                                 ; a = bank number
 717  E000 ~            ;.. Now b = bank and a = adjusted ship nbr
 718  E000 ~                                    ld      hl,banktable                        ; a= bank index
 719  E000 ~                                    add     hl,a
 720  E000 ~                                    add     hl,a
 721  E000 ~                                    ld      a,(hl)                              ; a = actual bank now
 722  E000 ~                                    ClearCarryFlag
 723  E000 ~                                    ret
 724  E000                                      ENDM
 725  E000
 726  E000              McopyVertsToUniverse:   MACRO
 727  E000 ~                                    ld          hl,(VerticesAddyAddr)       ; now the pointers are in Ubnk its easy to read
 728  E000 ~                                    ld          de,UBnkHullVerticies
 729  E000 ~                                    ld          b,0
 730  E000 ~                                    ld			a,(VertexCtX6Addr)
 731  E000 ~                                    ld          c,a
 732  E000 ~                                    ex          de,hl                       ; dma transfer goes de -> hl i.e. opposite of ldir
 733  E000 ~                                    call        memcopy_dma
 734  E000 ~                                    ret
 735  E000                                      ENDM
 736  E000
 737  E000              McopyEdgesToUniverse:   MACRO
 738  E000 ~                                    ld          hl,(EdgeAddyAddr)          ; now the pointers are in Ubnk its easy to read
 739  E000 ~                                    ld          de,UBnkHullEdges
 740  E000 ~                                    ld          b,0
 741  E000 ~                                    ld			a,(LineX4Addr)
 742  E000 ~                                    ld          c,a
 743  E000 ~                                    ex          de,hl                       ; dma transfer goes de -> hl i.e. opposite of ldir
 744  E000 ~                                    call        memcopy_dma
 745  E000 ~                                    ret
 746  E000                                      ENDM
 747  E000
 748  E000              McopyNormsToUniverse:   MACRO
 749  E000 ~                                    ld          hl,(FaceAddyAddr)          ; now the pointers are in Ubnk its easy to read
 750  E000 ~                                    ld          de,UBnkHullNormals
 751  E000 ~                                    ld          b,0
 752  E000 ~                                    ld          a,(FaceCtX4Addr)
 753  E000 ~                                    ld          c,a
 754  E000 ~                                    ex          de,hl                       ; dma transfer goes de -> hl i.e. opposite of ldir
 755  E000 ~                                    call        memcopy_dma
 756  E000 ~                                    ret
 757  E000                                      ENDM
 758  E000
 759  E000              ; Passes in ship nbr in A and bank is part of MACRO
 760  E000              MCopyShipToUniverse:    MACRO       banklabel
 761  E000 ~                                    ld          hl,UBnkShipModelBank
 762  E000 ~                                    ld          (hl),banklabel
 763  E000 ~                                    push        af
 764  E000 ~                                    ld          a,iyl
 765  E000 ~                                    ld          (UBnKShipModelId),a
 766  E000 ~                                    pop         af
 767  E000 ~                                    ld          (UBnKShipModelNbr),a
 768  E000 ~            .GetHullDataLength:     ld          hl,ShipModelSizeTable
 769  E000 ~                                    add         hl,a
 770  E000 ~                                    add         hl,a                        ; we won't multiply by 2 as GetInfo is a general purpose routines so would end up x 4
 771  E000 ~                                    ld          c,(hl)
 772  E000 ~                                    inc         hl
 773  E000 ~                                    ld          b,(hl)                      ; bc now equals length of data set
 774  E000 ~            .GetHullDataAddress:    ld          hl,ShipModelTable
 775  E000 ~                                    add         hl,a
 776  E000 ~                                    add         hl,a                        ; now hl = address of ship data value
 777  E000 ~                                    ld          a,(hl)
 778  E000 ~                                    inc         hl
 779  E000 ~                                    ld          h,(hl)
 780  E000 ~                                    ld          l,a                         ; now hl = address of ship hull data
 781  E000 ~                                    ld          de,UBnkHullCopy             ; Universe bank
 782  E000 ~                                    ld          bc,ShipDataLength
 783  E000 ~                                    ldir
 784  E000 ~                                    call        CopyVertsToUniv
 785  E000 ~                                    call        CopyEdgesToUniv
 786  E000 ~                                    call        CopyNormsToUniv
 787  E000 ~            .ClearName:             ld          hl,StartOfUnivName
 788  E000 ~                                    ld          a," "
 789  E000 ~                                    ld          b,16
 790  E000 ~            .fillLoop:              ld          (hl),a
 791  E000 ~                                    inc         hl
 792  E000 ~                                    djnz        .fillLoop
 793  E000 ~                                    ret
 794  E000                                      ENDM
 795  E000
 796  E000              MCopyBodyToUniverse:    MACRO       copyRoutine
 797  E000 ~                                    ld          a,13
 798  E000 ~                                    call        copyRoutine
 799  E000 ~                                    ret
 800  E000                                      ENDM
 801  E000
 802  E000
 803  E000              MCopyShipIdToUniverse:  MACRO
 804  E000 ~                                    call        GetShipModelId
 805  E000 ~                                    MMUSelectShipBankA
 806  E000 ~                                    ld          a,b
 807  E000 ~                                    jp          CopyShipToUniverse
 808  E000                                      ENDM
 809  E000
 810  E000
 811  E000
 812  E000
 813  E000                  INCLUDE "../../Data/ShipBank1Label.asm"
# file opened: ../../Data/ShipBank1Label.asm
   1+ E000 53 68 69 70  ShipBank1Label:         DB  "ShipBank1      "
   1+ E004 42 61 6E 6B
   1+ E008 31 20 20 20
   1+ E00C 20 20 20
   2+ E00F
# file closed: ../../Data/ShipBank1Label.asm
 814  E00F              GetShipBankId:
 815  E00F              GetShipBank1Id:         MGetShipBankId ShipBankTable
 815  E00F 06 00       >                        ld      b,0
 815  E011 4F          >                        ld      c,a                                 ; c= original ship id
 815  E012 CB 3F       >.ShiftLoop:             srl     a
 815  E014 CB 3F       >                        srl     a
 815  E016 CB 3F       >                        srl     a
 815  E018 CB 3F       >                        srl     a                                   ; divide by 16
 815  E01A 47          >                        ld      b,a                                 ; b = bank nbr
 815  E01B 79          >                        ld      a,c
 815  E01C 50          >                        ld      d,b
 815  E01D 1E 10       >                        ld      e,16
 815  E01F ED 30       >                        mul                                         ; de = 16 * bank number (max is about 15 banks)
 815  E021 93          >                        sub     e                                   ; a= actual model id now
 815  E022 50          >.SelectedBank:          ld      d,b                                 ; save current bank number
 815  E023 47          >                        ld      b,a                                 ; b = adjusted ship nbr
 815  E024 7A          >                        ld      a,d                                 ; a = bank number
 815  E025             >;.. Now b = bank and a = adjusted ship nbr
 815  E025 21 62 E0    >                        ld      hl,ShipBankTable                        ; a= bank index
 815  E028 ED 31       >                        add     hl,a
 815  E02A ED 31       >                        add     hl,a
 815  E02C 7E          >                        ld      a,(hl)                              ; a = actual bank now
 815  E02D             >                        ClearCarryFlag
 815  E02D B7          >                        or a
 815  E02E C9          >                        ret
 816  E02F              CopyVertsToUniv:
 817  E02F              CopyVertsToUniv1:       McopyVertsToUniverse
 817  E02F 2A 0B C4    >                        ld          hl,(VerticesAddyAddr)       ; now the pointers are in Ubnk its easy to read
 817  E032 11 11 C4    >                        ld          de,UBnkHullVerticies
 817  E035 06 00       >                        ld          b,0
 817  E037 3A FF C3    >                        ld			a,(VertexCtX6Addr)
 817  E03A 4F          >                        ld          c,a
 817  E03B EB          >                        ex          de,hl                       ; dma transfer goes de -> hl i.e. opposite of ldir
 817  E03C CD 16 68    >                        call        memcopy_dma
 817  E03F C9          >                        ret
 818  E040              CopyEdgesToUniv:
 819  E040              CopyEdgesToUniv1:       McopyEdgesToUniverse
 819  E040 2A F9 C3    >                        ld          hl,(EdgeAddyAddr)          ; now the pointers are in Ubnk its easy to read
 819  E043 11 01 C5    >                        ld          de,UBnkHullEdges
 819  E046 06 00       >                        ld          b,0
 819  E048 3A FB C3    >                        ld			a,(LineX4Addr)
 819  E04B 4F          >                        ld          c,a
 819  E04C EB          >                        ex          de,hl                       ; dma transfer goes de -> hl i.e. opposite of ldir
 819  E04D CD 16 68    >                        call        memcopy_dma
 819  E050 C9          >                        ret
 820  E051              CopyNormsToUniv:
 821  E051              CopyNormsToUniv1:       McopyNormsToUniverse
 821  E051 2A 07 C4    >                        ld          hl,(FaceAddyAddr)          ; now the pointers are in Ubnk its easy to read
 821  E054 11 C9 C5    >                        ld          de,UBnkHullNormals
 821  E057 06 00       >                        ld          b,0
 821  E059 3A 03 C4    >                        ld          a,(FaceCtX4Addr)
 821  E05C 4F          >                        ld          c,a
 821  E05D EB          >                        ex          de,hl                       ; dma transfer goes de -> hl i.e. opposite of ldir
 821  E05E CD 16 68    >                        call        memcopy_dma
 821  E061 C9          >                        ret
 822  E062              ShipBankTable:
 823  E062              ShipBankTable1:         MShipBankTable
 823  E062 3B 00       >                        DW      BankShipModels1
 823  E064 43 00       >                        DW      BankShipModels2
 823  E066 44 00       >                        DW      BankShipModels3
 823  E068 45 00       >                        DW      BankShipModels4
 824  E06A              CopyShipToUniverse:
 825  E06A              CopyShipToUniverse1     MCopyShipToUniverse     BankShipModels1
 825  E06A 21 41 C0    >                        ld          hl,UBnkShipModelBank
 825  E06D 36 3B       >                        ld          (hl),BankShipModels1
 825  E06F F5          >                        push        af
 825  E070 FD 7D       >                        ld          a,iyl
 825  E072 32 43 C0    >                        ld          (UBnKShipModelId),a
 825  E075 F1          >                        pop         af
 825  E076 32 42 C0    >                        ld          (UBnKShipModelNbr),a
 825  E079 21 31 E1    >.GetHullDataLength:     ld          hl,ShipModelSizeTable
 825  E07C ED 31       >                        add         hl,a
 825  E07E ED 31       >                        add         hl,a                        ; we won't multiply by 2 as GetInfo is a general purpose routines so would end up x 4
 825  E080 4E          >                        ld          c,(hl)
 825  E081 23          >                        inc         hl
 825  E082 46          >                        ld          b,(hl)                      ; bc now equals length of data set
 825  E083 21 B1 E0    >.GetHullDataAddress:    ld          hl,ShipModelTable
 825  E086 ED 31       >                        add         hl,a
 825  E088 ED 31       >                        add         hl,a                        ; now hl = address of ship data value
 825  E08A 7E          >                        ld          a,(hl)
 825  E08B 23          >                        inc         hl
 825  E08C 66          >                        ld          h,(hl)
 825  E08D 6F          >                        ld          l,a                         ; now hl = address of ship hull data
 825  E08E 11 F6 C3    >                        ld          de,UBnkHullCopy             ; Universe bank
 825  E091 01 1B 00    >                        ld          bc,ShipDataLength
 825  E094 ED B0       >                        ldir
 825  E096 CD 2F E0    >                        call        CopyVertsToUniv
 825  E099 CD 40 E0    >                        call        CopyEdgesToUniv
 825  E09C CD 51 E0    >                        call        CopyNormsToUniv
 825  E09F 21 10 C0    >.ClearName:             ld          hl,StartOfUnivName
 825  E0A2 3E 20       >                        ld          a," "
 825  E0A4 06 10       >                        ld          b,16
 825  E0A6 77          >.fillLoop:              ld          (hl),a
 825  E0A7 23          >                        inc         hl
 825  E0A8 10 FC       >                        djnz        .fillLoop
 825  E0AA C9          >                        ret
 826  E0AB              CopyBodyToUniverse:
 827  E0AB              CopyBodyToUniverse1:    MCopyBodyToUniverse     CopyShipToUniverse1
 827  E0AB 3E 0D       >                        ld          a,13
 827  E0AD CD 6A E0    >                        call        CopyShipToUniverse1
 827  E0B0 C9          >                        ret
 828  E0B1              ShipModelTable:
 829  E0B1 51 E1        ShipModelTable1:         DW Adder                                   ;00 $00
 830  E0B3 8C E2                                 DW Anaconda                                ;01 $01
 831  E0B5 99 E3                                 DW Asp_Mk_2                                ;02 $02
 832  E0B7 CA E4                                 DW Boa                                     ;03 $03
 833  E0B9 C7 E5                                 DW CargoType5                              ;04 $04
 834  E0BB 9B E6                                 DW Boulder                                 ;05 $05
 835  E0BD 48 E7                                 DW Asteroid                                ;06 $06
 836  E0BF 29 E8                                 DW Bushmaster                              ;07 $07
 837  E0C1 00 E9                                 DW Chameleon                               ;08 $08
 838  E0C3 32 EA                                 DW CobraMk3                                ;09 $09
 839  E0C5 C5 EB                                 DW Cobra_Mk_1                              ;10 $0A
 840  E0C7 96 EC                                 DW Cobra_Mk_3_P                            ;11 $0B
 841  E0C9 29 EE                                 DW Constrictor                             ;12 $0C
 842  E0CB 36 EF                                 DW Coriolis                                ;13 $0D
 843  E0CD 5D F0                                 DW Cougar                                  ;14 $0E
 844  E0CF 6A F1                                 DW Dodo                                    ;15 $0F
 845  E0D1              ShipVertexTable:
 846  E0D1 70 E1        ShipVertexTable1:        DW AdderVertices                           ;00 $00
 847  E0D3 AB E2                                 DW AnacondaVertices                        ;01 $01
 848  E0D5 B8 E3                                 DW Asp_Mk_2Vertices                        ;02 $02
 849  E0D7 E9 E4                                 DW BoaVertices                             ;03 $03
 850  E0D9 E6 E5                                 DW CargoType5Vertices                      ;04 $04
 851  E0DB BA E6                                 DW BoulderVertices                         ;05 $05
 852  E0DD 67 E7                                 DW AsteroidVertices                        ;06 $06
 853  E0DF 48 E8                                 DW BushmasterVertices                      ;07 $07
 854  E0E1 1E E9                                 DW ChameleonVertices                       ;08 $08
 855  E0E3 51 EA                                 DW CobraMk3Vertices                        ;09 $09
 856  E0E5 E4 EB                                 DW Cobra_Mk_1Vertices                      ;10 $0A
 857  E0E7 B5 EC                                 DW Cobra_Mk_3_PVertices                    ;11 $0B
 858  E0E9 48 EE                                 DW ConstrictorVertices                     ;12 $0C
 859  E0EB 55 EF                                 DW CoriolisVertices                        ;13 $0D
 860  E0ED 7C F0                                 DW CougarVertices                          ;14 $0E
 861  E0EF 89 F1                                 DW DodoVertices                            ;15 $0F
 862  E0F1              ShipEdgeTable:
 863  E0F1 DC E1        ShipEdgeTable1:          DW AdderEdges                              ;00 $00
 864  E0F3 05 E3                                 DW AnacondaEdges                           ;01 $01
 865  E0F5 2A E4                                 DW Asp_Mk_2Edges                           ;02 $02
 866  E0F7 37 E5                                 DW BoaEdges                                ;03 $03
 867  E0F9 22 E6                                 DW CargoType5Edges                         ;04 $04
 868  E0FB E4 E6                                 DW BoulderEdges                            ;05 $05
 869  E0FD 9D E7                                 DW AsteroidEdges                           ;06 $06
 870  E0FF 90 E8                                 DW BushmasterEdges                         ;07 $07
 871  E101 8A E9                                 DW ChameleonEdges                          ;08 $08
 872  E103 F9 EA                                 DW CobraMk3Edges                           ;09 $09
 873  E105 26 EC                                 DW Cobra_Mk_1Edges                         ;10 $0A
 874  E107 5D ED                                 DW Cobra_Mk_3_PEdges                       ;11 $0B
 875  E109 AE EE                                 DW ConstrictorEdges                        ;12 $0C
 876  E10B B5 EF                                 DW CoriolisEdges                           ;13 $0D
 877  E10D EE F0                                 DW CougarEdges                             ;14 $0E
 878  E10F 19 F2                                 DW DodoEdges                               ;15 $0F
 879  E111              ShipNormalTable:
 880  E111 50 E2        ShipNormalTable1:        DW AdderNormals                            ;00 $00
 881  E113 69 E3                                 DW AnacondaNormals                         ;01 $01
 882  E115 9A E4                                 DW Asp_Mk_2Normals                         ;02 $02
 883  E117 97 E5                                 DW BoaNormals                              ;03 $03
 884  E119 5E E6                                 DW CargoType5Normals                       ;04 $04
 885  E11B 20 E7                                 DW BoulderNormals                          ;05 $05
 886  E11D F1 E7                                 DW AsteroidNormals                         ;06 $06
 887  E11F DC E8                                 DW BushmasterNormals                       ;07 $07
 888  E121 FE E9                                 DW ChameleonNormals                        ;08 $08
 889  E123 91 EB                                 DW CobraMk3Normals                         ;09 $09
 890  E125 6E EC                                 DW Cobra_Mk_1Normals                       ;10 $0A
 891  E127 F5 ED                                 DW Cobra_Mk_3_PNormals                     ;11 $0B
 892  E129 0E EF                                 DW ConstrictorNormals                      ;12 $0C
 893  E12B 25 F0                                 DW CoriolisNormals                         ;13 $0D
 894  E12D 52 F1                                 DW CougarNormals                           ;14 $0E
 895  E12F A1 F2                                 DW DodoNormals                             ;15 $0F
 896  E131              ShipModelSizeTable:
 897  E131 3B 01        ShipModelSizeTable1:     DW AdderLen                                ;00 $00
 898  E133 0D 01                                 DW AnacondaLen                             ;01 $01
 899  E135 31 01                                 DW Asp_Mk_2Len                             ;02 $02
 900  E137 FD 00                                 DW BoaLen                                  ;03 $03
 901  E139 B3 00                                 DW CargoType5Len                           ;04 $04
 902  E13B AD 00                                 DW BoulderLen                              ;05 $05
 903  E13D E1 00                                 DW AsteroidLen                             ;06 $06
 904  E13F D7 00                                 DW BushmasterLen                           ;07 $07
 905  E141 32 01                                 DW ChameleonLen                            ;08 $08
 906  E143 93 01                                 DW CobraMk3Len                             ;09 $09
 907  E145 D1 00                                 DW Cobra_Mk_1Len                           ;10 $0A
 908  E147 93 01                                 DW Cobra_Mk_3_PLen                         ;11 $0B
 909  E149 0D 01                                 DW ConstrictorLen                          ;12 $0C
 910  E14B 27 01                                 DW CoriolisLen                             ;13 $0D
 911  E14D 0D 01                                 DW CougarLen                               ;14 $0E
 912  E14F 67 01                                 DW DodoLen                                 ;15 $0F
 913  E151
 914  E151                                      include "../../Data/ships/Adder.asm"
# file opened: ../../Data/ships/Adder.asm
   1+ E151 00           Adder:	                DB $00                              ; Number of cargo canisters released when destroyed
   2+ E152 C4 09                                DW 50 * 50                          ; Ship's targetable area LoHi
   3+ E154 DC E1                                DW AdderEdges                       ; Edge Data
   4+ E156 74                                   DB AdderEdgesSize                   ; Size of Edge Data
   5+ E157 00                                   DB $00                              ; Gun Vertex Byte offset
   6+ E158 16                                   DB $16                              ; Explosion Count
   7+ E159 12                                   DB AdderVertSize / 6                ; Vertex Count /6
   8+ E15A 6C                                   DB AdderVertSize                    ; Vertex Count
   9+ E15B 1D                                   DB AdderEdgesCnt                    ; Edges Count
  10+ E15C 28 00                                DW $0028                            ; Bounty LoHi
  11+ E15E 3C                                   DB AdderNormalsSize                 ; Face (Normal) Count
  12+ E15F 17                                   DB $17                              ; Range when it turns to a dot
  13+ E160 48                                   DB $48                              ; Energy Max
  14+ E161 18                                   DB $18                              ; Speed Max
  15+ E162 50 E2                                DW AdderNormals                     ; Normals
  16+ E164 12                                   DB $12                              ; Q scaling
  17+ E165 21                                   DB $21                              ; Laser power and Nbr Missiles
  18+ E166 70 E1                                DW AdderVertices                    ; Verticles Address
  19+ E168 00                                   DB ShipTypeNormal                   ; Ship Type
  20+ E169 00                                   DB 0                                ; NewB Tactics
  21+ E16A 80                                   DB ShipCanAnger                     ; AI Flags
  22+ E16B 80                                   DB $80                              ; chance of ECM module
  23+ E16C FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ E16D 00 00                                DW $0000                            ; no solid data
  25+ E16F 00                                   DB $00                              ; no solid data
  26+ E170
  27+ E170                                                     ; chance of ECM module
  28+ E170 12 00 28 9F  AdderVertices:	        DB $12, $00, $28, $9F, $01, $BC     ;01
  28+ E174 01 BC
  29+ E176 12 00 28 1F                          DB $12, $00, $28, $1F, $01, $23     ;02
  29+ E17A 01 23
  30+ E17C 1E 00 18 3F                          DB $1E, $00, $18, $3F, $23, $45     ;03
  30+ E180 23 45
  31+ E182 1E 00 28 3F                          DB $1E, $00, $28, $3F, $45, $66     ;04
  31+ E186 45 66
  32+ E188 12 07 28 7F                          DB $12, $07, $28, $7F, $56, $7E     ;05
  32+ E18C 56 7E
  33+ E18E 12 07 28 FF                          DB $12, $07, $28, $FF, $78, $AE     ;06
  33+ E192 78 AE
  34+ E194 1E 00 28 BF                          DB $1E, $00, $28, $BF, $89, $AA     ;07
  34+ E198 89 AA
  35+ E19A 1E 00 18 BF                          DB $1E, $00, $18, $BF, $9A, $BC     ;08
  35+ E19E 9A BC
  36+ E1A0 12 07 28 BF                          DB $12, $07, $28, $BF, $78, $9D     ;09
  36+ E1A4 78 9D
  37+ E1A6 12 07 28 3F                          DB $12, $07, $28, $3F, $46, $7D     ;10
  37+ E1AA 46 7D
  38+ E1AC 12 07 0D 9F                          DB $12, $07, $0D, $9F, $09, $BD     ;11
  38+ E1B0 09 BD
  39+ E1B2 12 07 0D 1F                          DB $12, $07, $0D, $1F, $02, $4D     ;12
  39+ E1B6 02 4D
  40+ E1B8 12 07 0D DF                          DB $12, $07, $0D, $DF, $1A, $CE     ;13
  40+ E1BC 1A CE
  41+ E1BE 12 07 0D 5F                          DB $12, $07, $0D, $5F, $13, $5E     ;14
  41+ E1C2 13 5E
  42+ E1C4 0B 03 1D 85                          DB $0B, $03, $1D, $85, $00, $00     ;15
  42+ E1C8 00 00
  43+ E1CA 0B 03 1D 05                          DB $0B, $03, $1D, $05, $00, $00     ;16
  43+ E1CE 00 00
  44+ E1D0 0B 04 18 04                          DB $0B, $04, $18, $04, $00, $00     ;17
  44+ E1D4 00 00
  45+ E1D6 0B 04 18 84                          DB $0B, $04, $18, $84, $00, $00     ;18
  45+ E1DA 00 00
  46+ E1DC              AdderVertSize:          equ $ - AdderVertices
  47+ E1DC 1F 01 00 04  AdderEdges:	            DB $1F, $01, $00, $04               ;01
  48+ E1E0 07 23 04 08                          DB $07, $23, $04, $08               ;02
  49+ E1E4 1F 45 08 0C                          DB $1F, $45, $08, $0C               ;03
  50+ E1E8 1F 56 0C 10                          DB $1F, $56, $0C, $10               ;04
  51+ E1EC 1F 7E 10 14                          DB $1F, $7E, $10, $14               ;05
  52+ E1F0 1F 8A 14 18                          DB $1F, $8A, $14, $18               ;06
  53+ E1F4 1F 9A 18 1C                          DB $1F, $9A, $18, $1C               ;07
  54+ E1F8 07 BC 1C 00                          DB $07, $BC, $1C, $00               ;08
  55+ E1FC 1F 46 0C 24                          DB $1F, $46, $0C, $24               ;09
  56+ E200 1F 7D 24 20                          DB $1F, $7D, $24, $20               ;10
  57+ E204 1F 89 20 18                          DB $1F, $89, $20, $18               ;11
  58+ E208 1F 0B 00 28                          DB $1F, $0B, $00, $28               ;12
  59+ E20C 1F 9B 1C 28                          DB $1F, $9B, $1C, $28               ;13
  60+ E210 1F 02 04 2C                          DB $1F, $02, $04, $2C               ;14
  61+ E214 1F 24 08 2C                          DB $1F, $24, $08, $2C               ;15
  62+ E218 1F 1C 00 30                          DB $1F, $1C, $00, $30               ;16
  63+ E21C 1F AC 1C 30                          DB $1F, $AC, $1C, $30               ;17
  64+ E220 1F 13 04 34                          DB $1F, $13, $04, $34               ;18
  65+ E224 1F 35 08 34                          DB $1F, $35, $08, $34               ;19
  66+ E228 1F 0D 28 2C                          DB $1F, $0D, $28, $2C               ;20
  67+ E22C 1F 1E 30 34                          DB $1F, $1E, $30, $34               ;21
  68+ E230 1F 9D 20 28                          DB $1F, $9D, $20, $28               ;22
  69+ E234 1F 4D 24 2C                          DB $1F, $4D, $24, $2C               ;23
  70+ E238 1F AE 14 30                          DB $1F, $AE, $14, $30               ;24
  71+ E23C 1F 5E 10 34                          DB $1F, $5E, $10, $34               ;25
  72+ E240 05 00 38 3C                          DB $05, $00, $38, $3C               ;26
  73+ E244 03 00 3C 40                          DB $03, $00, $3C, $40               ;27
  74+ E248 04 00 40 44                          DB $04, $00, $40, $44               ;28
  75+ E24C 03 00 44 38                          DB $03, $00, $44, $38               ;29
  76+ E250              AdderEdgesSize:         equ $ - AdderEdges
  77+ E250              AdderEdgesCnt:          equ AdderEdgesSize/4
  78+ E250 1F 00 27 0A  AdderNormals:	        DB $1F, $00, $27, $0A               ;01
  79+ E254 5F 00 27 0A                          DB $5F, $00, $27, $0A               ;02
  80+ E258 1F 45 32 0D                          DB $1F, $45, $32, $0D               ;03
  81+ E25C 5F 45 32 0D                          DB $5F, $45, $32, $0D               ;04
  82+ E260 1F 1E 34 00                          DB $1F, $1E, $34, $00               ;05
  83+ E264 5F 1E 34 00                          DB $5F, $1E, $34, $00               ;06
  84+ E268 3F 00 00 A0                          DB $3F, $00, $00, $A0               ;07
  85+ E26C 3F 00 00 A0                          DB $3F, $00, $00, $A0               ;08
  86+ E270 3F 00 00 A0                          DB $3F, $00, $00, $A0               ;09
  87+ E274 9F 1E 34 00                          DB $9F, $1E, $34, $00               ;10
  88+ E278 DF 1E 34 00                          DB $DF, $1E, $34, $00               ;11
  89+ E27C 9F 45 32 0D                          DB $9F, $45, $32, $0D               ;12
  90+ E280 DF 45 32 0D                          DB $DF, $45, $32, $0D               ;13
  91+ E284 1F 00 1C 00                          DB $1F, $00, $1C, $00               ;14
  92+ E288 5F 00 1C 00                          DB $5F, $00, $1C, $00               ;15
  93+ E28C
  94+ E28C              AdderNormalsSize:       equ $ - AdderNormals
  95+ E28C              AdderLen:                equ $ - Adder
  96+ E28C
  97+ E28C
  98+ E28C
  99+ E28C
 100+ E28C
 101+ E28C
 102+ E28C
 103+ E28C
 104+ E28C
 105+ E28C
 106+ E28C
# file closed: ../../Data/ships/Adder.asm
 915  E28C                                      include "../../Data/ships/Anaconda.asm"
# file opened: ../../Data/ships/Anaconda.asm
   1+ E28C 07           Anaconda:	            DB $07                                                        ; Number of cargo canisters released when destroyed
   2+ E28D 10 27                                DW 100 * 100                                                  ; Ship's targetable area LoHi
   3+ E28F 05 E3                                DW AnacondaEdges                                              ; Edge Data
   4+ E291 64                                   DB AnacondaEdgesSize                                          ; Size of Edge Data
   5+ E292 30                                   DB $30                                                        ; Gun Vertex Byte offset
   6+ E293 2E                                   DB $2E                                                        ; Explosion Count
   7+ E294 0F                                   DB AnacondaVertSize / 6                                       ; Vertex Count /6
   8+ E295 5A                                   DB AnacondaVertSize                                           ; Vertex Count
   9+ E296 19                                   DB AnacondaEdgesCnt                                           ; Edges Count
  10+ E297 00 00                                DW $0000                                                      ; Bounty LoHi
  11+ E299 30                                   DB AnacondaNormalsSize                                        ; Face (Normal) Count
  12+ E29A 24                                   DB $24                                                        ; Range when it turns to a dot
  13+ E29B FC                                   DB $FC                                                        ; Energy Max
  14+ E29C 0E                                   DB $0E                                                        ; Speed Max
  15+ E29D 69 E3                                DW AnacondaNormals                                            ; Normals
  16+ E29F 11                                   DB $11                                                        ; Q scaling
  17+ E2A0 3F                                   DB $3F                                                        ; Laser power and Nbr Missiles
  18+ E2A1 AB E2                                DW AnacondaVertices                                           ; Verticles Address
  19+ E2A3 00                                   DB ShipTypeNormal                                             ; Ship Type
  20+ E2A4 00                                   DB 0                                                          ; NewB Tactics
  21+ E2A5 A4                                   DB ShipCanAnger | ShipFighterBaySize2 | ShipFighterSidewinder ; AI Flags
  22+ E2A6 D0                                   DB $D0                                                        ; chance of ECM module
  23+ E2A7 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ E2A8 00 00                                DW $0000                            ; no solid data
  25+ E2AA 00                                   DB $00                              ; no solid data
  26+ E2AB
  27+ E2AB 00 07 3A 3E  AnacondaVertices:	    DB $00, $07, $3A, $3E, $01, $55 ;01
  27+ E2AF 01 55
  28+ E2B1 2B 0D 25 FE                          DB $2B, $0D, $25, $FE, $01, $22 ;02
  28+ E2B5 01 22
  29+ E2B7 1A 2F 03 FE                          DB $1A, $2F, $03, $FE, $02, $33 ;03
  29+ E2BB 02 33
  30+ E2BD 1A 2F 03 7E                          DB $1A, $2F, $03, $7E, $03, $44 ;04
  30+ E2C1 03 44
  31+ E2C3 2B 0D 25 7E                          DB $2B, $0D, $25, $7E, $04, $55 ;05
  31+ E2C7 04 55
  32+ E2C9 00 30 31 3E                          DB $00, $30, $31, $3E, $15, $66 ;06
  32+ E2CD 15 66
  33+ E2CF 45 0F 0F BE                          DB $45, $0F, $0F, $BE, $12, $77 ;07
  33+ E2D3 12 77
  34+ E2D5 2B 27 28 DF                          DB $2B, $27, $28, $DF, $23, $88 ;08
  34+ E2D9 23 88
  35+ E2DB 2B 27 28 5F                          DB $2B, $27, $28, $5F, $34, $99 ;09
  35+ E2DF 34 99
  36+ E2E1 45 0F 0F 3E                          DB $45, $0F, $0F, $3E, $45, $AA ;10
  36+ E2E5 45 AA
  37+ E2E7 2B 35 17 BF                          DB $2B, $35, $17, $BF, $FF, $FF ;11
  37+ E2EB FF FF
  38+ E2ED 45 01 20 DF                          DB $45, $01, $20, $DF, $27, $88 ;12
  38+ E2F1 27 88
  39+ E2F3 00 00 FE 1F                          DB $00, $00, $FE, $1F, $FF, $FF ;13
  39+ E2F7 FF FF
  40+ E2F9 45 01 20 5F                          DB $45, $01, $20, $5F, $49, $AA ;14
  40+ E2FD 49 AA
  41+ E2FF 2B 35 17 3F                          DB $2B, $35, $17, $3F, $FF, $FF ;15
  41+ E303 FF FF
  42+ E305              AnacondaVertSize:       equ $ - AnacondaVertices
  43+ E305 1E 01 00 04  AnacondaEdges:	        DB $1E, $01, $00, $04           ;01
  44+ E309 1E 02 04 08                          DB $1E, $02, $04, $08           ;02
  45+ E30D 1E 03 08 0C                          DB $1E, $03, $08, $0C           ;03
  46+ E311 1E 04 0C 10                          DB $1E, $04, $0C, $10           ;04
  47+ E315 1E 05 00 10                          DB $1E, $05, $00, $10           ;05
  48+ E319 1D 15 00 14                          DB $1D, $15, $00, $14           ;06
  49+ E31D 1D 12 04 18                          DB $1D, $12, $04, $18           ;07
  50+ E321 1D 23 08 1C                          DB $1D, $23, $08, $1C           ;08
  51+ E325 1D 34 0C 20                          DB $1D, $34, $0C, $20           ;09
  52+ E329 1D 45 10 24                          DB $1D, $45, $10, $24           ;10
  53+ E32D 1E 16 14 28                          DB $1E, $16, $14, $28           ;11
  54+ E331 1E 17 18 28                          DB $1E, $17, $18, $28           ;12
  55+ E335 1E 27 18 2C                          DB $1E, $27, $18, $2C           ;13
  56+ E339 1E 28 1C 2C                          DB $1E, $28, $1C, $2C           ;14
  57+ E33D 1F 38 1C 30                          DB $1F, $38, $1C, $30           ;15
  58+ E341 1F 39 20 30                          DB $1F, $39, $20, $30           ;16
  59+ E345 1E 49 20 34                          DB $1E, $49, $20, $34           ;17
  60+ E349 1E 4A 24 34                          DB $1E, $4A, $24, $34           ;18
  61+ E34D 1E 5A 24 38                          DB $1E, $5A, $24, $38
  62+ E351 1E 56 14 38                          DB $1E, $56, $14, $38
  63+ E355 1E 6B 28 38                          DB $1E, $6B, $28, $38
  64+ E359 1F 7B 28 30                          DB $1F, $7B, $28, $30
  65+ E35D 1F 78 2C 30                          DB $1F, $78, $2C, $30
  66+ E361 1F 9A 30 34                          DB $1F, $9A, $30, $34
  67+ E365 1F AB 30 38                          DB $1F, $AB, $30, $38
  68+ E369              AnacondaEdgesSize:      equ $ - AnacondaEdges
  69+ E369              AnacondaEdgesCnt:       equ AnacondaEdgesSize/4
  70+ E369 7E 00 33 31  AnacondaNormals:	    DB $7E, $00, $33, $31           ;01
  71+ E36D BE 33 12 57                          DB $BE, $33, $12, $57           ;02
  72+ E371 FE 4D 39 13                          DB $FE, $4D, $39, $13           ;03
  73+ E375 5F 00 5A 10                          DB $5F, $00, $5A, $10           ;04
  74+ E379 7E 4D 39 13                          DB $7E, $4D, $39, $13           ;05
  75+ E37D 3E 33 12 57                          DB $3E, $33, $12, $57           ;06
  76+ E381 3E 00 6F 14                          DB $3E, $00, $6F, $14           ;07
  77+ E385 9F 61 48 18                          DB $9F, $61, $48, $18           ;08
  78+ E389 DF 6C 44 22                          DB $DF, $6C, $44, $22           ;09
  79+ E38D 5F 6C 44 22                          DB $5F, $6C, $44, $22           ;10
  80+ E391 1F 61 48 18                          DB $1F, $61, $48, $18           ;11
  81+ E395 1F 00 5E 12                          DB $1F, $00, $5E, $12           ;12
  82+ E399              AnacondaNormalsSize:    equ $ - AnacondaNormals
  83+ E399              AnacondaLen:            equ $ - Anaconda
  84+ E399
  85+ E399
  86+ E399
  87+ E399
# file closed: ../../Data/ships/Anaconda.asm
 916  E399                                      include "../../Data/ships/Asp_Mk_2.asm"
# file opened: ../../Data/ships/Asp_Mk_2.asm
   1+ E399 00           Asp_Mk_2:	            DB $00                          ; Number of cargo canisters released when destroyed
   2+ E39A 10 0E                                DW 60 * 60                      ; Ship's targetable area LoHi
   3+ E39C 2A E4                                DW Asp_Mk_2Edges                ; Edge Data
   4+ E39E 70                                   DB Asp_Mk_2EdgesSize            ; Size of Edge Data
   5+ E39F 20                                   DB $20                          ; Gun Vertex Byte offset
   6+ E3A0 1A                                   DB $1A                          ; Explosion Count
   7+ E3A1 13                                   DB Asp_Mk_2VertSize /6          ; Vertex Count /6
   8+ E3A2 72                                   DB Asp_Mk_2VertSize             ; Vertex Count
   9+ E3A3 1C                                   DB Asp_Mk_2EdgesCnt             ; Edges Count
  10+ E3A4 C8 00                                DW $00C8                        ; Bounty LoHi
  11+ E3A6 30                                   DB Asp_Mk_2NormalsSize          ; Face (Normal) Count
  12+ E3A7 28                                   DB $28                          ; Range when it turns to a dot
  13+ E3A8 96                                   DB $96                          ; Energy Max
  14+ E3A9 28                                   DB $28                          ; Speed Max
  15+ E3AA 9A E4                                DW Asp_Mk_2Normals              ; Normals
  16+ E3AC 01                                   DB $01                          ; Q scaling
  17+ E3AD 29                                   DB $29                          ; Laser power and Nbr Missiles
  18+ E3AE B8 E3                                DW Asp_Mk_2Vertices             ; Verticles Address
  19+ E3B0 00                                   DB ShipTypeNormal               ; Ship Type
  20+ E3B1 00                                   DB 0                            ; NewB Tactics
  21+ E3B2 80                                   DB ShipCanAnger                 ; AI Flags
  22+ E3B3 80                                   DB $80                          ; chance of ECM module
  23+ E3B4 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ E3B5 00 00                                DW $0000                            ; no solid data
  25+ E3B7 00                                   DB $00                              ; no solid data
  26+ E3B8
  27+ E3B8 00 12 00 56  Asp_Mk_2Vertices:	    DB $00, $12, $00, $56, $01, $22 ;01
  27+ E3BC 01 22
  28+ E3BE 00 09 2D 7F                          DB $00, $09, $2D, $7F, $12, $BB ;02
  28+ E3C2 12 BB
  29+ E3C4 2B 00 2D 3F                          DB $2B, $00, $2D, $3F, $16, $BB ;03
  29+ E3C8 16 BB
  30+ E3CA 45 03 00 5F                          DB $45, $03, $00, $5F, $16, $79 ;04
  30+ E3CE 16 79
  31+ E3D0 2B 0E 1C 5F                          DB $2B, $0E, $1C, $5F, $01, $77 ;05
  31+ E3D4 01 77
  32+ E3D6 2B 00 2D BF                          DB $2B, $00, $2D, $BF, $25, $BB ;06
  32+ E3DA 25 BB
  33+ E3DC 45 03 00 DF                          DB $45, $03, $00, $DF, $25, $8A ;07
  33+ E3E0 25 8A
  34+ E3E2 2B 0E 1C DF                          DB $2B, $0E, $1C, $DF, $02, $88 ;08
  34+ E3E6 02 88
  35+ E3E8 1A 07 49 5F                          DB $1A, $07, $49, $5F, $04, $79 ;09
  35+ E3EC 04 79
  36+ E3EE 1A 07 49 DF                          DB $1A, $07, $49, $DF, $04, $8A ;10
  36+ E3F2 04 8A
  37+ E3F4 2B 0E 1C 1F                          DB $2B, $0E, $1C, $1F, $34, $69 ;11
  37+ E3F8 34 69
  38+ E3FA 2B 0E 1C 9F                          DB $2B, $0E, $1C, $9F, $34, $5A ;12
  38+ E3FE 34 5A
  39+ E400 00 09 2D 3F                          DB $00, $09, $2D, $3F, $35, $6B ;13
  39+ E404 35 6B
  40+ E406 11 00 2D AA                          DB $11, $00, $2D, $AA, $BB, $BB ;14
  40+ E40A BB BB
  41+ E40C 11 00 2D 29                          DB $11, $00, $2D, $29, $BB, $BB ;15
  41+ E410 BB BB
  42+ E412 00 04 2D 6A                          DB $00, $04, $2D, $6A, $BB, $BB ;16
  42+ E416 BB BB
  43+ E418 00 04 2D 28                          DB $00, $04, $2D, $28, $BB, $BB ;17
  43+ E41C BB BB
  44+ E41E 00 07 49 4A                          DB $00, $07, $49, $4A, $04, $04 ;18
  44+ E422 04 04
  45+ E424 00 07 53 4A                          DB $00, $07, $53, $4A, $04, $04 ;19
  45+ E428 04 04
  46+ E42A              Asp_Mk_2VertSize:       equ $ - Asp_Mk_2Vertices
  47+ E42A 16 12 00 04  Asp_Mk_2Edges:	        DB $16, $12, $00, $04           ;01
  48+ E42E 16 01 00 10                          DB $16, $01, $00, $10           ;02
  49+ E432 16 02 00 1C                          DB $16, $02, $00, $1C           ;03
  50+ E436 1F 1B 04 08                          DB $1F, $1B, $04, $08           ;04
  51+ E43A 1F 16 08 0C                          DB $1F, $16, $08, $0C           ;05
  52+ E43E 10 79 0C 20                          DB $10, $79, $0C, $20           ;06
  53+ E442 1F 04 20 24                          DB $1F, $04, $20, $24           ;07
  54+ E446 10 8A 18 24                          DB $10, $8A, $18, $24           ;08
  55+ E44A 1F 25 14 18                          DB $1F, $25, $14, $18           ;09
  56+ E44E 1F 2B 04 14                          DB $1F, $2B, $04, $14           ;10
  57+ E452 1F 17 0C 10                          DB $1F, $17, $0C, $10           ;11
  58+ E456 1F 07 10 20                          DB $1F, $07, $10, $20           ;12
  59+ E45A 1F 28 18 1C                          DB $1F, $28, $18, $1C           ;13
  60+ E45E 1F 08 1C 24                          DB $1F, $08, $1C, $24           ;14
  61+ E462 1F 6B 08 30                          DB $1F, $6B, $08, $30           ;15
  62+ E466 1F 5B 14 30                          DB $1F, $5B, $14, $30           ;16
  63+ E46A 16 36 28 30                          DB $16, $36, $28, $30           ;17
  64+ E46E 16 35 2C 30                          DB $16, $35, $2C, $30           ;18
  65+ E472 16 34 28 2C                          DB $16, $34, $28, $2C
  66+ E476 1F 5A 18 2C                          DB $1F, $5A, $18, $2C
  67+ E47A 1F 4A 24 2C                          DB $1F, $4A, $24, $2C
  68+ E47E 1F 69 0C 28                          DB $1F, $69, $0C, $28
  69+ E482 1F 49 20 28                          DB $1F, $49, $20, $28
  70+ E486 0A BB 34 3C                          DB $0A, $BB, $34, $3C
  71+ E48A 09 BB 3C 38                          DB $09, $BB, $3C, $38
  72+ E48E 08 BB 38 40                          DB $08, $BB, $38, $40
  73+ E492 08 BB 40 34                          DB $08, $BB, $40, $34
  74+ E496 0A 04 48 44                          DB $0A, $04, $48, $44
  75+ E49A              Asp_Mk_2EdgesSize:      equ $ - Asp_Mk_2Edges
  76+ E49A              Asp_Mk_2EdgesCnt:       equ Asp_Mk_2EdgesSize/4
  77+ E49A 5F 00 23 05  Asp_Mk_2Normals:	    DB $5F, $00, $23, $05           ;01
  78+ E49E 7F 08 26 07                          DB $7F, $08, $26, $07           ;02
  79+ E4A2 FF 08 26 07                          DB $FF, $08, $26, $07           ;03
  80+ E4A6 36 00 18 01                          DB $36, $00, $18, $01           ;04
  81+ E4AA 1F 00 2B 13                          DB $1F, $00, $2B, $13           ;05
  82+ E4AE BF 06 1C 02                          DB $BF, $06, $1C, $02           ;06
  83+ E4B2 3F 06 1C 02                          DB $3F, $06, $1C, $02           ;07
  84+ E4B6 5F 3B 40 1F                          DB $5F, $3B, $40, $1F           ;08
  85+ E4BA DF 3B 40 1F                          DB $DF, $3B, $40, $1F           ;09
  86+ E4BE 1F 50 2E 32                          DB $1F, $50, $2E, $32           ;10
  87+ E4C2 9F 50 2E 32                          DB $9F, $50, $2E, $32           ;11
  88+ E4C6 3F 00 00 5A                          DB $3F, $00, $00, $5A           ;12
  89+ E4CA              Asp_Mk_2NormalsSize:    equ $ - Asp_Mk_2Normals
  90+ E4CA              Asp_Mk_2Len:            equ $ - Asp_Mk_2
  91+ E4CA
  92+ E4CA
  93+ E4CA
  94+ E4CA
# file closed: ../../Data/ships/Asp_Mk_2.asm
 917  E4CA                                      include "../../Data/ships/Boa.asm"
# file opened: ../../Data/ships/Boa.asm
   1+ E4CA 05           Boa:	                DB $05                          ; Number of cargo canisters released when destroyed
   2+ E4CB 24 13                                DW 70 * 70                      ; Ship's targetable area LoHi
   3+ E4CD 37 E5                                DW BoaEdges                     ; Edge Data
   4+ E4CF 60                                   DB BoaEdgesSize                 ; Size of Edge Data
   5+ E4D0 00                                   DB $00                          ; Gun Vertex Byte offset
   6+ E4D1 26                                   DB $26                          ; Explosion Count
   7+ E4D2 0D                                   DB BoaVertSize /6               ; Vertex Count /6
   8+ E4D3 4E                                   DB BoaVertSize                  ; Vertex Count
   9+ E4D4 18                                   DB BoaEdgesCnt                  ; Edges Count
  10+ E4D5 00 00                                DW $0000                        ; Bounty LoHi
  11+ E4D7 30                                   DB BoaNormalsSize               ; Face (Normal) Count
  12+ E4D8 28                                   DB $28                          ; Range when it turns to a dot
  13+ E4D9 FA                                   DB $FA                          ; Energy Max
  14+ E4DA 18                                   DB $18                          ; Speed Max
  15+ E4DB 97 E5                                DW BoaNormals                   ; Normals
  16+ E4DD 00                                   DB $00                          ; Q scaling
  17+ E4DE 1C                                   DB $1C                          ; Laser power and Nbr Missiles
  18+ E4DF E9 E4                                DW BoaVertices                  ; Verticles Address
  19+ E4E1 00                                   DB ShipTypeNormal               ; Ship Type
  20+ E4E2 00                                   DB 0                            ; NewB Tactics
  21+ E4E3 80                                   DB ShipCanAnger                 ; AI Flags
  22+ E4E4 A0                                   DB $A0                          ; chance of ECM module
  23+ E4E5 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ E4E6 00 00                                DW $0000                            ; no solid data
  25+ E4E8 00                                   DB $00                              ; no solid data
  26+ E4E9
  27+ E4E9 00 00 5D 1F  BoaVertices:	        DB $00, $00, $5D, $1F, $FF, $FF ; 01
  27+ E4ED FF FF
  28+ E4EF 00 28 57 38                          DB $00, $28, $57, $38, $02, $33 ; 02
  28+ E4F3 02 33
  29+ E4F5 26 19 63 78                          DB $26, $19, $63, $78, $01, $44 ; 03
  29+ E4F9 01 44
  30+ E4FB 26 19 63 F8                          DB $26, $19, $63, $F8, $12, $55 ; 04
  30+ E4FF 12 55
  31+ E501 26 28 3B BF                          DB $26, $28, $3B, $BF, $23, $69 ; 05
  31+ E505 23 69
  32+ E507 26 28 3B 3F                          DB $26, $28, $3B, $3F, $03, $6B ; 06
  32+ E50B 03 6B
  33+ E50D 3E 00 43 3F                          DB $3E, $00, $43, $3F, $04, $8B ; 07
  33+ E511 04 8B
  34+ E513 18 41 4F 7F                          DB $18, $41, $4F, $7F, $14, $8A ; 08
  34+ E517 14 8A
  35+ E519 18 41 4F FF                          DB $18, $41, $4F, $FF, $15, $7A ; 09
  35+ E51D 15 7A
  36+ E51F 3E 00 43 BF                          DB $3E, $00, $43, $BF, $25, $79 ; 10
  36+ E523 25 79
  37+ E525 00 07 6B 36                          DB $00, $07, $6B, $36, $02, $AA ; 11
  37+ E529 02 AA
  38+ E52B 0D 09 6B 76                          DB $0D, $09, $6B, $76, $01, $AA ; 12
  38+ E52F 01 AA
  39+ E531 0D 09 6B F6                          DB $0D, $09, $6B, $F6, $12, $CC ; 13
  39+ E535 12 CC
  40+ E537              BoaVertSize:            equ $ - BoaVertices
  41+ E537 1F 6B 00 14  BoaEdges:	            DB $1F, $6B, $00, $14
  42+ E53B 1F 8A 00 1C                          DB $1F, $8A, $00, $1C
  43+ E53F 1F 79 00 24                          DB $1F, $79, $00, $24
  44+ E543 1D 69 00 10                          DB $1D, $69, $00, $10
  45+ E547 1D 8B 00 18                          DB $1D, $8B, $00, $18
  46+ E54B 1D 7A 00 20                          DB $1D, $7A, $00, $20
  47+ E54F 1F 36 10 14                          DB $1F, $36, $10, $14
  48+ E553 1F 0B 14 18                          DB $1F, $0B, $14, $18
  49+ E557 1F 48 18 1C                          DB $1F, $48, $18, $1C
  50+ E55B 1F 1A 1C 20                          DB $1F, $1A, $1C, $20
  51+ E55F 1F 57 20 24                          DB $1F, $57, $20, $24
  52+ E563 1F 29 10 24                          DB $1F, $29, $10, $24
  53+ E567 18 23 04 10                          DB $18, $23, $04, $10
  54+ E56B 18 03 04 14                          DB $18, $03, $04, $14
  55+ E56F 18 25 0C 24                          DB $18, $25, $0C, $24
  56+ E573 18 15 0C 20                          DB $18, $15, $0C, $20
  57+ E577 18 04 08 18                          DB $18, $04, $08, $18
  58+ E57B 18 14 08 1C                          DB $18, $14, $08, $1C
  59+ E57F 16 02 04 28                          DB $16, $02, $04, $28
  60+ E583 16 01 08 2C                          DB $16, $01, $08, $2C
  61+ E587 16 12 0C 30                          DB $16, $12, $0C, $30
  62+ E58B 0E 0C 28 2C                          DB $0E, $0C, $28, $2C
  63+ E58F 0E 1C 2C 30                          DB $0E, $1C, $2C, $30
  64+ E593 0E 2C 30 28                          DB $0E, $2C, $30, $28
  65+ E597              BoaEdgesSize:           equ $ - BoaEdges
  66+ E597              BoaEdgesCnt:            equ BoaEdgesSize/4
  67+ E597 3F 2B 25 3C  BoaNormals:	            DB $3F, $2B, $25, $3C
  68+ E59B 7F 00 2D 59                          DB $7F, $00, $2D, $59
  69+ E59F BF 2B 25 3C                          DB $BF, $2B, $25, $3C
  70+ E5A3 1F 00 28 00                          DB $1F, $00, $28, $00
  71+ E5A7 7F 3E 20 14                          DB $7F, $3E, $20, $14
  72+ E5AB FF 3E 20 14                          DB $FF, $3E, $20, $14
  73+ E5AF 1F 00 17 06                          DB $1F, $00, $17, $06
  74+ E5B3 DF 17 0F 09                          DB $DF, $17, $0F, $09
  75+ E5B7 5F 17 0F 09                          DB $5F, $17, $0F, $09
  76+ E5BB 9F 1A 0D 0A                          DB $9F, $1A, $0D, $0A
  77+ E5BF 5F 00 1F 0C                          DB $5F, $00, $1F, $0C
  78+ E5C3 1F 1A 0D 0A                          DB $1F, $1A, $0D, $0A
  79+ E5C7              BoaNormalsSize:         equ $ - BoaNormals
  80+ E5C7              BoaLen:                 equ $ - Boa
  81+ E5C7
# file closed: ../../Data/ships/Boa.asm
 918  E5C7                                      include "../../Data/ships/CargoType5.asm"
# file opened: ../../Data/ships/CargoType5.asm
   1+ E5C7 00           CargoType5              DB $00                                     ; Number of cargo canisters released when destroyed
   2+ E5C8 90 01                                DW 20 * 20                                 ; Ship's targetable area LoHi
   3+ E5CA 22 E6                                DW CargoType5Edges                         ; Edge Data
   4+ E5CC 3C                                   DB CargoType5EdgesSize                     ; Size of Edge Data
   5+ E5CD 00                                   DB $00                                     ; Gun Vertex Byte offset
   6+ E5CE 12                                   DB $12                                     ; Explosion Count
   7+ E5CF 0A                                   DB CargoType5VertSize /6                   ; Vertex Count /6
   8+ E5D0 3C                                   DB CargoType5VertSize                      ; Vertex Count
   9+ E5D1 0F                                   DB CargoType5EdgesCnt                      ; Edges Count
  10+ E5D2 00 00                                DW $0000                                   ; Bounty LoHi
  11+ E5D4 1C                                   DB CargoType5NormalsSize                   ; Face (Normal) Count
  12+ E5D5 0C                                   DB $0C                                     ; Range when it turns to a dot
  13+ E5D6 11                                   DB $11                                     ; Energy Max
  14+ E5D7 0F                                   DB $0F                                     ; Speed Max
  15+ E5D8 5E E6                                DW CargoType5Normals                       ; Normals
  16+ E5DA 02                                   DB $02                                     ; Q scaling
  17+ E5DB 00                                   DB $00                                     ; Laser power and Nbr Missiles
  18+ E5DC E6 E5                                DW CargoType5Vertices                      ; Verticles Address
  19+ E5DE 04                                   DB ShipTypeScoopable                       ; Ship Type
  20+ E5DF 00                                   DB 0                                       ; NewB Tactics
  21+ E5E0 00                                   DB 0                                       ; AI Flags
  22+ E5E1 00                                   DB $0                                      ; chance of ECM module
  23+ E5E2 00                                   DB $00                                     ; Supports Solid Fill
  24+ E5E3 7A E6                                DW CargoType5Traingles                  ;
  25+ E5E5 21                                   DB CargoType5TrainglesSize
  26+ E5E6              ; So cargo is               Edge offset $0050  Face Offset $008C, Verices will alwys be +20, LineMax 31 -> 4  EdgeCnt 15  VertexCnt 60 -> 10     FaceCn 28 -> 7
  27+ E5E6              ;                                       Faces
  28+ E5E6              ;                            X  Y    Z  12 34  Vis
  29+ E5E6 18 10 00 1F  CargoType5Vertices		DB $18,$10,$00,$1F,$10,$55 	               ;00  Top Right
  29+ E5EA 10 55
  30+ E5EC 18 05 0F 1F                          DB $18,$05,$0F,$1F,$10,$22                 ;01  Mid Right Near
  30+ E5F0 10 22
  31+ E5F2 18 0D 09 5F                          DB $18,$0D,$09,$5F,$20,$33                 ;02  Bottom right Near
  31+ E5F6 20 33
  32+ E5F8 18 0D 09 7F                          DB $18,$0D,$09,$7F,$30,$44                 ;03  Bottom Right Rear
  32+ E5FC 30 44
  33+ E5FE 18 05 0F 3F                          DB $18,$05,$0F,$3F,$40,$55                 ;04  Mid Right Rear
  33+ E602 40 55
  34+ E604 18 10 00 9F                          DB $18,$10,$00,$9F,$51,$66                 ;05  Left versions
  34+ E608 51 66
  35+ E60A 18 05 0F 9F                          DB $18,$05,$0F,$9F,$21,$66                 ;06
  35+ E60E 21 66
  36+ E610 18 0D 09 DF                          DB $18,$0D,$09,$DF,$32,$66                 ;07
  36+ E614 32 66
  37+ E616 18 0D 09 FF                          DB $18,$0D,$09,$FF,$43,$66                 ;08
  37+ E61A 43 66
  38+ E61C 18 05 0F BF                          DB $18,$05,$0F,$BF,$54,$66                 ;09
  38+ E620 54 66
  39+ E622              CargoType5VertSize      equ $  - CargoType5Vertices
  40+ E622              ;                          Vis  FacVert Offset (4 bytexVertnbr)
  41+ E622              ;                               12  01 02
  42+ E622 1F 10 00 04  CargoType5Edges			DB $1F,$10,$00,$04 	       ;00 Face  0,1
  43+ E626 1F 20 04 08                          DB $1F,$20,$04,$08         ;01
  44+ E62A 1F 30 08 0C                          DB $1F,$30,$08,$0C         ;02
  45+ E62E 1F 40 0C 10                          DB $1F,$40,$0C,$10         ;03
  46+ E632 1F 50 00 10                          DB $1F,$50,$00,$10         ;04
  47+ E636 1F 51 00 14                          DB $1F,$51,$00,$14         ;05
  48+ E63A 1F 21 04 18                          DB $1F,$21,$04,$18         ;06
  49+ E63E 1F 32 08 1C                          DB $1F,$32,$08,$1C         ;07
  50+ E642 1F 43 0C 20                          DB $1F,$43,$0C,$20         ;08
  51+ E646 1F 54 10 24                          DB $1F,$54,$10,$24         ;19
  52+ E64A 1F 61 14 18                          DB $1F,$61,$14,$18         ;10
  53+ E64E 1F 62 18 1C                          DB $1F,$62,$18,$1C         ;11
  54+ E652 1F 63 1C 20                          DB $1F,$63,$1C,$20         ;12
  55+ E656 1F 64 20 24                          DB $1F,$64,$20,$24         ;13
  56+ E65A 1F 65 24 14                          DB $1F,$65,$24,$14         ;14
  57+ E65E              CargoType5EdgesSize     equ $  - CargoType5Edges
  58+ E65E              CargoType5EdgesCnt      equ CargoType5EdgesSize / 4
  59+ E65E              ;                           x  y    z   vis
  60+ E65E 1F 60 00 00  CargoType5Normals    	DB $1F,$60,$00,$00 			               ;00 Right side
  61+ E662 1F 00 29 1E                          DB $1F,$00,$29,$1E                         ;01
  62+ E666 5F 00 12 30                          DB $5F,$00,$12,$30                         ;02
  63+ E66A 5F 00 33 00                          DB $5F,$00,$33,$00                         ;03
  64+ E66E 7F 00 12 30                          DB $7F,$00,$12,$30                         ;04
  65+ E672 3F 00 29 1E                          DB $3F,$00,$29,$1E                         ;05 Left
  66+ E676 9F 60 00 00                          DB $9F,$60,$00,$00   ; end Cargo cannister ;06 right side
  67+ E67A              CargoType5NormalsSize   equ $  - CargoType5Normals
  68+ E67A              CargoType5Len           equ $  - CargoType5
  69+ E67A                                      ; Triangles is made of a list of edges
  70+ E67A              ; Ideal is pointers have a DW at the end to the list of triangles and count
  71+ E67A              ; for testing we will do a simple search
  72+ E67A              ;                          Nrm NodeOffset X 1
  73+ E67A              ;                                0    1    2
  74+ E67A 00 00 04 10  CargoType5Traingles     DB $00,$00*4, $01*4, $04*4
  75+ E67E 00 04 08 10                          DB $00,$01*4, $02*4, $04*4
  76+ E682 00 08 0C 10                          DB $00,$02*4, $03*4, $04*4
  77+ E686 01 00 10 14                          DB $01,$00*4, $04*4, $05*4
  78+ E68A 01 10 14 18                          DB $01,$04*4, $05*4, $06*4
  79+ E68E                                  ;   DB $02,
  80+ E68E                                  ;   DB $03,
  81+ E68E                                  ;   DB $03,
  82+ E68E                                  ;   DB $04,
  83+ E68E                                  ;   DB $04,
  84+ E68E                                  ;   DB $01,
  85+ E68E                                  ;   DB $01,
  86+ E68E                                  ;   DB $01,
  87+ E68E                                  ;   DB $01,
  88+ E68E 06 14 18 24                          DB $06,$05*4, $06*4, $09*4 ; its we store UBNkNodeArray + this offset it will save one memroy ready
  89+ E692 06 18 1C 24                          DB $06,$06*4, $07*4, $09*4
  90+ E696 06 1C 20 24                          DB $06,$07*4, $08*4, $09*4
  91+ E69A FF                                   DB $FF ; Very important end of traingle list marker
  92+ E69B              CargoType5TrainglesSize:equ $  -  CargoType5Traingles
  93+ E69B
  94+ E69B
  95+ E69B
# file closed: ../../Data/ships/CargoType5.asm
 919  E69B                                      include "../../Data/ships/Boulder.asm"
# file opened: ../../Data/ships/Boulder.asm
   1+ E69B 00           Boulder:	            DB $00                               ; Number of cargo canisters released when destroyed
   2+ E69C 84 03                                DW 30 * 30                           ; Ship's targetable area LoHi
   3+ E69E E4 E6                                DW BoulderEdges                      ; Edge Data
   4+ E6A0 3C                                   DB BoulderEdgesSize                  ; Size of Edge Data
   5+ E6A1 00                                   DB $00                               ; Gun Vertex Byte offset
   6+ E6A2 0E                                   DB $0E                               ; Explosion Count
   7+ E6A3 07                                   DB BoulderVertSize /6                ; Vertex Count /6
   8+ E6A4 2A                                   DB BoulderVertSize                   ; Vertex Count
   9+ E6A5 0F                                   DB BoulderEdgesCnt                   ; Edges Count
  10+ E6A6 01 00                                DW $0001                             ; Bounty LoHi
  11+ E6A8 28                                   DB BoulderNormalsSize                ; Face (Normal) Count
  12+ E6A9 14                                   DB $14                               ; Range when it turns to a dot
  13+ E6AA 14                                   DB $14                               ; Energy Max
  14+ E6AB 1E                                   DB $1E                               ; Speed Max
  15+ E6AC 20 E7                                DW BoulderNormals                    ; Normals
  16+ E6AE 02                                   DB $02                               ; Q scaling
  17+ E6AF 00                                   DB $00                               ; Laser power and Nbr Missiles
  18+ E6B0 BA E6                                DW BoulderVertices                   ; Verticles Address
  19+ E6B2 03                                   DB ShipTypeJunk                      ; Ship Type
  20+ E6B3 00                                   DB 0                                 ; NewB Tactics
  21+ E6B4 00                                   DB 0                                 ; AI Flags
  22+ E6B5 A0                                   DB $A0                               ; chance of ECM module
  23+ E6B6 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ E6B7 00 00                                DW $0000                            ; no solid data
  25+ E6B9 00                                   DB $00                              ; no solid data
  26+ E6BA
  27+ E6BA 12 25 0B BF  BoulderVertices:	    DB $12, $25, $0B, $BF, $01, $59
  27+ E6BE 01 59
  28+ E6C0 1E 07 0C 1F                          DB $1E, $07, $0C, $1F, $12, $56
  28+ E6C4 12 56
  29+ E6C6 1C 07 0C 7F                          DB $1C, $07, $0C, $7F, $23, $67
  29+ E6CA 23 67
  30+ E6CC 02 00 27 3F                          DB $02, $00, $27, $3F, $34, $78
  30+ E6D0 34 78
  31+ E6D2 1C 22 1E BF                          DB $1C, $22, $1E, $BF, $04, $89
  31+ E6D6 04 89
  32+ E6D8 05 0A 0D 5F                          DB $05, $0A, $0D, $5F, $FF, $FF
  32+ E6DC FF FF
  33+ E6DE 14 11 1E 3F                          DB $14, $11, $1E, $3F, $FF, $FF
  33+ E6E2 FF FF
  34+ E6E4              BoulderVertSize:        equ $ - BoulderVertices
  35+ E6E4 1F 15 00 04  BoulderEdges:	        DB $1F, $15, $00, $04
  36+ E6E8 1F 26 04 08                          DB $1F, $26, $04, $08
  37+ E6EC 1F 37 08 0C                          DB $1F, $37, $08, $0C
  38+ E6F0 1F 48 0C 10                          DB $1F, $48, $0C, $10
  39+ E6F4 1F 09 10 00                          DB $1F, $09, $10, $00
  40+ E6F8 1F 01 00 14                          DB $1F, $01, $00, $14
  41+ E6FC 1F 12 04 14                          DB $1F, $12, $04, $14
  42+ E700 1F 23 08 14                          DB $1F, $23, $08, $14
  43+ E704 1F 34 0C 14                          DB $1F, $34, $0C, $14
  44+ E708 1F 04 10 14                          DB $1F, $04, $10, $14
  45+ E70C 1F 59 00 18                          DB $1F, $59, $00, $18
  46+ E710 1F 56 04 18                          DB $1F, $56, $04, $18
  47+ E714 1F 67 08 18                          DB $1F, $67, $08, $18
  48+ E718 1F 78 0C 18                          DB $1F, $78, $0C, $18
  49+ E71C 1F 89 10 18                          DB $1F, $89, $10, $18
  50+ E720              BoulderEdgesSize:       equ $ - BoulderEdges
  51+ E720              BoulderEdgesCnt:        equ BoulderEdgesSize/4
  52+ E720 DF 0F 03 08  BoulderNormals:	        DB $DF, $0F, $03, $08
  53+ E724 9F 07 0C 1E                          DB $9F, $07, $0C, $1E
  54+ E728 5F 20 2F 18                          DB $5F, $20, $2F, $18
  55+ E72C FF 03 27 07                          DB $FF, $03, $27, $07
  56+ E730 FF 05 04 01                          DB $FF, $05, $04, $01
  57+ E734 1F 31 54 08                          DB $1F, $31, $54, $08
  58+ E738 3F 70 15 15                          DB $3F, $70, $15, $15
  59+ E73C 7F 4C 23 52                          DB $7F, $4C, $23, $52
  60+ E740 3F 16 38 89                          DB $3F, $16, $38, $89
  61+ E744 3F 28 6E 26                          DB $3F, $28, $6E, $26
  62+ E748              BoulderNormalsSize:     equ $ - BoulderNormals
  63+ E748              BoulderLen:             equ $ - Boulder
  64+ E748
# file closed: ../../Data/ships/Boulder.asm
 920  E748                                      include "../../Data/ships/Asteroid.asm"
# file opened: ../../Data/ships/Asteroid.asm
   1+ E748 00           Asteroid:	            DB $00                          ; Number of cargo canisters released when destroyed
   2+ E749 00 19                                DW 80 * 80                      ; Ship's targetable area LoHi
   3+ E74B 9D E7                                DW AsteroidEdges                ; Edge Data
   4+ E74D 54                                   DB AsteroidEdgesSize            ; Size of Edge Data
   5+ E74E 00                                   DB $00                          ; Gun Vertex Byte offset
   6+ E74F 22                                   DB $22                          ; Explosion Count
   7+ E750 09                                   DB AsteroidVertSize /6          ; Vertex Count /6
   8+ E751 36                                   DB AsteroidVertSize             ; Vertex Count
   9+ E752 15                                   DB AsteroidEdgesCnt             ; Edges Count
  10+ E753 05 00                                DW $0005                        ; Bounty LoHi
  11+ E755 38                                   DB AsteroidNormalsSize          ; Face (Normal) Count
  12+ E756 32                                   DB $32                          ; Range when it turns to a dot
  13+ E757 3C                                   DB $3C                          ; Energy Max
  14+ E758 1E                                   DB $1E                          ; Speed Max
  15+ E759 F1 E7                                DW AsteroidNormals              ; Normals
  16+ E75B 01                                   DB $01                          ; Q scaling
  17+ E75C 00                                   DB $00                          ; Laser power and Nbr Missiles
  18+ E75D 67 E7                                DW AsteroidVertices             ; Verticles Address
  19+ E75F 03                                   DB ShipTypeJunk                 ; Ship Type
  20+ E760 00                                   DB 0                            ; NewB Tactics
  21+ E761 00                                   DB 0                            ; AI Flags
  22+ E762 00                                   DB $00                          ; chance of ECM module
  23+ E763 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ E764 00 00                                DW $0000                            ; no solid data
  25+ E766 00                                   DB $00                              ; no solid data
  26+ E767
  27+ E767 00 50 00 1F  AsteroidVertices:	    DB $00, $50, $00, $1F, $FF, $FF ;01
  27+ E76B FF FF
  28+ E76D 50 0A 00 DF                          DB $50, $0A, $00, $DF, $FF, $FF ;02
  28+ E771 FF FF
  29+ E773 00 50 00 5F                          DB $00, $50, $00, $5F, $FF, $FF ;03
  29+ E777 FF FF
  30+ E779 46 28 00 5F                          DB $46, $28, $00, $5F, $FF, $FF ;04
  30+ E77D FF FF
  31+ E77F 3C 32 00 1F                          DB $3C, $32, $00, $1F, $65, $DC ;05
  31+ E783 65 DC
  32+ E785 32 00 3C 1F                          DB $32, $00, $3C, $1F, $FF, $FF ;06
  32+ E789 FF FF
  33+ E78B 28 00 46 9F                          DB $28, $00, $46, $9F, $10, $32 ;07
  33+ E78F 10 32
  34+ E791 00 1E 4B 3F                          DB $00, $1E, $4B, $3F, $FF, $FF ;08
  34+ E795 FF FF
  35+ E797 00 32 3C 7F                          DB $00, $32, $3C, $7F, $98, $BA ;09
  35+ E79B 98 BA
  36+ E79D              AsteroidVertSize:       equ $ - AsteroidVertices
  37+ E79D 1F 72 00 04  AsteroidEdges:	        DB $1F, $72, $00, $04           ;01
  38+ E7A1 1F D6 00 10                          DB $1F, $D6, $00, $10           ;02
  39+ E7A5 1F C5 0C 10                          DB $1F, $C5, $0C, $10           ;03
  40+ E7A9 1F B4 08 0C                          DB $1F, $B4, $08, $0C           ;04
  41+ E7AD 1F A3 04 08                          DB $1F, $A3, $04, $08           ;05
  42+ E7B1 1F 32 04 18                          DB $1F, $32, $04, $18           ;06
  43+ E7B5 1F 31 08 18                          DB $1F, $31, $08, $18           ;07
  44+ E7B9 1F 41 08 14                          DB $1F, $41, $08, $14           ;08
  45+ E7BD 1F 10 14 18                          DB $1F, $10, $14, $18           ;09
  46+ E7C1 1F 60 00 14                          DB $1F, $60, $00, $14           ;10
  47+ E7C5 1F 54 0C 14                          DB $1F, $54, $0C, $14           ;11
  48+ E7C9 1F 20 00 18                          DB $1F, $20, $00, $18           ;12
  49+ E7CD 1F 65 10 14                          DB $1F, $65, $10, $14           ;13
  50+ E7D1 1F A8 04 20                          DB $1F, $A8, $04, $20           ;14
  51+ E7D5 1F 87 04 1C                          DB $1F, $87, $04, $1C           ;15
  52+ E7D9 1F D7 00 1C                          DB $1F, $D7, $00, $1C           ;16
  53+ E7DD 1F DC 10 1C                          DB $1F, $DC, $10, $1C           ;17
  54+ E7E1 1F C9 0C 1C                          DB $1F, $C9, $0C, $1C           ;18
  55+ E7E5 1F B9 0C 20                          DB $1F, $B9, $0C, $20
  56+ E7E9 1F BA 08 20                          DB $1F, $BA, $08, $20
  57+ E7ED 1F 98 1C 20                          DB $1F, $98, $1C, $20
  58+ E7F1
  59+ E7F1              AsteroidEdgesSize:      equ $ - AsteroidEdges
  60+ E7F1              AsteroidEdgesCnt:       equ AsteroidEdgesSize/4
  61+ E7F1 1F 09 42 51  AsteroidNormals:	    DB $1F, $09, $42, $51           ;01
  62+ E7F5 5F 09 42 51                          DB $5F, $09, $42, $51           ;02
  63+ E7F9 9F 48 40 1F                          DB $9F, $48, $40, $1F           ;03
  64+ E7FD DF 40 49 2F                          DB $DF, $40, $49, $2F           ;04
  65+ E801 5F 2D 4F 41                          DB $5F, $2D, $4F, $41           ;05
  66+ E805 1F 87 0F 23                          DB $1F, $87, $0F, $23           ;06
  67+ E809 1F 26 4C 46                          DB $1F, $26, $4C, $46           ;07
  68+ E80D BF 42 3B 27                          DB $BF, $42, $3B, $27           ;08
  69+ E811 FF 43 0F 50                          DB $FF, $43, $0F, $50           ;09
  70+ E815 7F 42 0E 4B                          DB $7F, $42, $0E, $4B           ;10
  71+ E819 FF 46 50 28                          DB $FF, $46, $50, $28           ;11
  72+ E81D 7F 3A 66 33                          DB $7F, $3A, $66, $33           ;12
  73+ E821 3F 51 09 43                          DB $3F, $51, $09, $43           ;13
  74+ E825 3F 2F 5E 3F                          DB $3F, $2F, $5E, $3F           ;14
  75+ E829              AsteroidNormalsSize:    equ $ - AsteroidNormals
  76+ E829              AsteroidLen:            equ $ - Asteroid
  77+ E829
  78+ E829
# file closed: ../../Data/ships/Asteroid.asm
 921  E829                                      include "../../Data/ships/Bushmaster.asm"
# file opened: ../../Data/ships/Bushmaster.asm
   1+ E829 00           Bushmaster:	            DB $00                           ; Number of cargo canisters released when destroyed
   2+ E82A 9A 10                                DW $109A                         ; Ship's targetable area LoHi
   3+ E82C 90 E8                                DW BushmasterEdges               ; Edge Data
   4+ E82E 4C                                   DB BushmasterEdgesSize           ; Size of Edge Data
   5+ E82F 00                                   DB $00                           ; Gun Vertex Byte offset
   6+ E830 1E                                   DB $1E                           ; Explosion Count
   7+ E831 0C                                   DB BushmasterVertSize /6         ; Vertex Count /6
   8+ E832 48                                   DB BushmasterVertSize            ; Vertex Count
   9+ E833 13                                   DB BushmasterEdgesCnt            ; Edges Count
  10+ E834 96 00                                DW $0096                         ; Bounty LoHi
  11+ E836 24                                   DB BushmasterNormalsSize         ; Face (Normal) Count
  12+ E837 14                                   DB $14                           ; Range when it turns to a dot
  13+ E838 4A                                   DB $4A                           ; Energy Max
  14+ E839 23                                   DB $23                           ; Speed Max
  15+ E83A DC E8                                DW BushmasterNormals             ; Normals
  16+ E83C 02                                   DB $02                           ; Q scaling
  17+ E83D 21                                   DB $20 | ShipMissiles1           ; Laser power and Nbr Missiles
  18+ E83E 48 E8                                DW BushmasterVertices            ; Verticles Address
  19+ E840 00                                   DB ShipTypeNormal                ; Ship Type
  20+ E841 00                                   DB 0                             ; NewB Tactics
  21+ E842 80                                   DB ShipCanAnger                  ; AI Flags
  22+ E843 70                                   DB $70                           ; chance of ECM module
  23+ E844 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ E845 00 00                                DW $0000                            ; no solid data
  25+ E847 00                                   DB $00                              ; no solid data
  26+ E848
  27+ E848 00 00 3C 1F  BushmasterVertices:	    DB $00, $00, $3C, $1F, $23, $01  ; 01
  27+ E84C 23 01
  28+ E84E 32 00 14 1F                          DB $32, $00, $14, $1F, $57, $13  ; 02
  28+ E852 57 13
  29+ E854 32 00 14 9F                          DB $32, $00, $14, $9F, $46, $02  ; 03
  29+ E858 46 02
  30+ E85A 00 14 00 1F                          DB $00, $14, $00, $1F, $45, $01  ; 04
  30+ E85E 45 01
  31+ E860 00 14 28 7F                          DB $00, $14, $28, $7F, $FF, $FF  ; 05
  31+ E864 FF FF
  32+ E866 00 0E 28 3F                          DB $00, $0E, $28, $3F, $88, $45  ; 06
  32+ E86A 88 45
  33+ E86C 28 00 28 3F                          DB $28, $00, $28, $3F, $88, $57  ; 07
  33+ E870 88 57
  34+ E872 28 00 28 BF                          DB $28, $00, $28, $BF, $88, $46  ; 08
  34+ E876 88 46
  35+ E878 00 04 28 2A                          DB $00, $04, $28, $2A, $88, $88  ; 09
  35+ E87C 88 88
  36+ E87E 0A 00 28 2A                          DB $0A, $00, $28, $2A, $88, $88  ; 10
  36+ E882 88 88
  37+ E884 00 04 28 6A                          DB $00, $04, $28, $6A, $88, $88  ; 11
  37+ E888 88 88
  38+ E88A 0A 00 28 AA                          DB $0A, $00, $28, $AA, $88, $88  ; 12           ; 12 * 6 = 72
  38+ E88E 88 88
  39+ E890              BushmasterVertSize:     equ $ - BushmasterVertices
  40+ E890 1F 13 00 04  BushmasterEdges:	    DB $1F, $13, $00, $04            ; 01
  41+ E894 1F 02 00 08                          DB $1F, $02, $00, $08            ; 02
  42+ E898 1F 01 00 0C                          DB $1F, $01, $00, $0C            ; 03
  43+ E89C 1F 23 00 10                          DB $1F, $23, $00, $10            ; 04
  44+ E8A0 1F 45 0C 14                          DB $1F, $45, $0C, $14            ; 05
  45+ E8A4 1F 04 08 0C                          DB $1F, $04, $08, $0C            ; 06
  46+ E8A8 1F 15 04 0C                          DB $1F, $15, $04, $0C            ; 07
  47+ E8AC 1F 46 08 1C                          DB $1F, $46, $08, $1C            ; 08
  48+ E8B0 1F 57 04 18                          DB $1F, $57, $04, $18            ; 09
  49+ E8B4 1F 26 08 10                          DB $1F, $26, $08, $10            ; 10
  50+ E8B8 1F 37 04 10                          DB $1F, $37, $04, $10            ; 11
  51+ E8BC 1F 48 14 1C                          DB $1F, $48, $14, $1C            ; 12
  52+ E8C0 1F 58 14 18                          DB $1F, $58, $14, $18            ; 13
  53+ E8C4 1F 68 10 1C                          DB $1F, $68, $10, $1C            ; 14
  54+ E8C8 1F 78 10 18                          DB $1F, $78, $10, $18            ; 15
  55+ E8CC 0A 88 20 24                          DB $0A, $88, $20, $24            ; 16
  56+ E8D0 0A 88 24 28                          DB $0A, $88, $24, $28            ; 17
  57+ E8D4 0A 88 28 2C                          DB $0A, $88, $28, $2C            ; 18
  58+ E8D8 0A 88 2C 20                          DB $0A, $88, $2C, $20            ; 19           ; 19 * 4 = 76
  59+ E8DC              BushmasterEdgesSize:    equ $ - BushmasterEdges
  60+ E8DC              BushmasterEdgesCnt:     equ BushmasterEdgesSize/4        ;
  61+ E8DC 9F 17 58 1D  BushmasterNormals:	    DB $9F, $17, $58, $1D            ; 01
  62+ E8E0 1F 17 58 1D                          DB $1F, $17, $58, $1D            ; 02
  63+ E8E4 DF 0E 5D 12                          DB $DF, $0E, $5D, $12            ; 03
  64+ E8E8 5F 0E 5D 12                          DB $5F, $0E, $5D, $12            ; 04
  65+ E8EC BF 1F 59 0D                          DB $BF, $1F, $59, $0D            ; 05
  66+ E8F0 3F 1F 59 0D                          DB $3F, $1F, $59, $0D            ; 06
  67+ E8F4 FF 2A 55 07                          DB $FF, $2A, $55, $07            ; 07
  68+ E8F8 7F 2A 55 07                          DB $7F, $2A, $55, $07            ; 08
  69+ E8FC 3F 00 00 60                          DB $3F, $00, $00, $60            ; 09           ; 9 * 4 = 36
  70+ E900              BushmasterNormalsSize:  equ $ - BushmasterNormals
  71+ E900              BushmasterLen:          equ $ - Bushmaster
  72+ E900
# file closed: ../../Data/ships/Bushmaster.asm
 922  E900                                      include "../../Data/ships/Chameleon.asm"
# file opened: ../../Data/ships/Chameleon.asm
   1+ E900 03           Chameleon:	            DB $03                          ; Number of cargo canisters released when destroyed
   2+ E901 A0 0F                                DW $0FA0                        ; Ship's targetable area LoHi
   3+ E903 8A E9                                DW ChameleonEdges               ; Edge Data
   4+ E905 74                                   DB ChameleonEdgesSize           ; Size of Edge Data
   5+ E906 00                                   DB $00                          ; Gun Vertex Byte offset
   6+ E907 1A                                   DB $1A                          ; Explosion Count
   7+ E908 12                                   DB ChameleonVertSize /6         ; Vertex Count /6
   8+ E909 6C                                   DB ChameleonVertSize            ; Vertex Count
   9+ E90A 1D                                   DB ChameleonEdgesCnt            ; Edges Count
  10+ E90B C8                                   DB $00C8                        ; Bounty LoHi
  11+ E90C 34                                   DB ChameleonNormalsSize         ; Face (Normal) Count
  12+ E90D 0A                                   DB $0A                          ; Range when it turns to a dot
  13+ E90E 64                                   DB $64                          ; Energy Max
  14+ E90F 1D                                   DB $1D                          ; Speed Max
  15+ E910 FE E9                                DW ChameleonNormals             ; Normals
  16+ E912 01                                   DB $01                          ; Q scaling
  17+ E913 23                                   DB $23                          ; Laser power and Nbr Missiles
  18+ E914 1E E9                                DW ChameleonVertices            ; Verticles Address
  19+ E916 00                                   DB ShipTypeNormal               ; Ship Type
  20+ E917 00                                   DB 0                            ; NewB Tactics
  21+ E918 80                                   DB ShipCanAnger                 ; AI Flags
  22+ E919 40                                   DB $40                          ; chance of ECM module
  23+ E91A FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ E91B 00 00                                DW $0000                            ; no solid data
  25+ E91D 00                                   DB $00                              ; no solid data
  26+ E91E
  27+ E91E 12 00 6E 9F  ChameleonVertices:	    DB $12, $00, $6E, $9F, $25, $01
  27+ E922 25 01
  28+ E924 12 00 6E 1F                          DB $12, $00, $6E, $1F, $34, $01
  28+ E928 34 01
  29+ E92A 28 00 00 9F                          DB $28, $00, $00, $9F, $8B, $25
  29+ E92E 8B 25
  30+ E930 08 18 00 9F                          DB $08, $18, $00, $9F, $68, $22
  30+ E934 68 22
  31+ E936 08 18 00 1F                          DB $08, $18, $00, $1F, $69, $33
  31+ E93A 69 33
  32+ E93C 28 00 00 1F                          DB $28, $00, $00, $1F, $9A, $34
  32+ E940 9A 34
  33+ E942 08 18 00 5F                          DB $08, $18, $00, $5F, $7A, $44
  33+ E946 7A 44
  34+ E948 08 18 00 DF                          DB $08, $18, $00, $DF, $7B, $55
  34+ E94C 7B 55
  35+ E94E 00 18 28 1F                          DB $00, $18, $28, $1F, $36, $02
  35+ E952 36 02
  36+ E954 00 18 28 5F                          DB $00, $18, $28, $5F, $57, $14
  36+ E958 57 14
  37+ E95A 20 00 28 BF                          DB $20, $00, $28, $BF, $BC, $88
  37+ E95E BC 88
  38+ E960 00 18 28 3F                          DB $00, $18, $28, $3F, $9C, $68
  38+ E964 9C 68
  39+ E966 20 00 28 3F                          DB $20, $00, $28, $3F, $AC, $99
  39+ E96A AC 99
  40+ E96C 00 18 28 7F                          DB $00, $18, $28, $7F, $BC, $7A
  40+ E970 BC 7A
  41+ E972 08 00 28 AA                          DB $08, $00, $28, $AA, $CC, $CC
  41+ E976 CC CC
  42+ E978 00 08 28 2A                          DB $00, $08, $28, $2A, $CC, $CC
  42+ E97C CC CC
  43+ E97E 08 00 28 2A                          DB $08, $00, $28, $2A, $CC, $CC
  43+ E982 CC CC
  44+ E984 00 08 28 6A                          DB $00, $08, $28, $6A, $CC, $CC
  44+ E988 CC CC
  45+ E98A              ChameleonVertSize:      equ $ - ChameleonVertices
  46+ E98A 1F 01 00 04  ChameleonEdges:	        DB $1F, $01, $00, $04
  47+ E98E 1F 02 00 20                          DB $1F, $02, $00, $20
  48+ E992 1F 15 00 24                          DB $1F, $15, $00, $24
  49+ E996 1F 03 04 20                          DB $1F, $03, $04, $20
  50+ E99A 1F 14 04 24                          DB $1F, $14, $04, $24
  51+ E99E 1F 34 04 14                          DB $1F, $34, $04, $14
  52+ E9A2 1F 25 00 08                          DB $1F, $25, $00, $08
  53+ E9A6 1F 26 0C 20                          DB $1F, $26, $0C, $20
  54+ E9AA 1F 36 10 20                          DB $1F, $36, $10, $20
  55+ E9AE 1F 75 1C 24                          DB $1F, $75, $1C, $24
  56+ E9B2 1F 74 18 24                          DB $1F, $74, $18, $24
  57+ E9B6 1F 39 10 14                          DB $1F, $39, $10, $14
  58+ E9BA 1F 4A 14 18                          DB $1F, $4A, $14, $18
  59+ E9BE 1F 28 08 0C                          DB $1F, $28, $08, $0C
  60+ E9C2 1F 5B 08 1C                          DB $1F, $5B, $08, $1C
  61+ E9C6 1F 8B 08 28                          DB $1F, $8B, $08, $28
  62+ E9CA 1F 9A 14 30                          DB $1F, $9A, $14, $30
  63+ E9CE 1F 68 0C 2C                          DB $1F, $68, $0C, $2C
  64+ E9D2 1F 7B 1C 34                          DB $1F, $7B, $1C, $34
  65+ E9D6 1F 69 10 2C                          DB $1F, $69, $10, $2C
  66+ E9DA 1F 7A 18 34                          DB $1F, $7A, $18, $34
  67+ E9DE 1F 8C 28 2C                          DB $1F, $8C, $28, $2C
  68+ E9E2 1F BC 28 34                          DB $1F, $BC, $28, $34
  69+ E9E6 1F 9C 2C 30                          DB $1F, $9C, $2C, $30
  70+ E9EA 1F AC 30 34                          DB $1F, $AC, $30, $34
  71+ E9EE 0A CC 38 3C                          DB $0A, $CC, $38, $3C
  72+ E9F2 0A CC 3C 40                          DB $0A, $CC, $3C, $40
  73+ E9F6 0A CC 40 44                          DB $0A, $CC, $40, $44
  74+ E9FA 0A CC 44 38                          DB $0A, $CC, $44, $38
  75+ E9FE              ChameleonEdgesSize:     equ $ - ChameleonEdges
  76+ E9FE              ChameleonEdgesCnt:      equ ChameleonEdgesSize/4
  77+ E9FE 1F 00 5A 1F  ChameleonNormals:	    DB $1F, $00, $5A, $1F
  78+ EA02 5F 00 5A 1F                          DB $5F, $00, $5A, $1F
  79+ EA06 9F 39 4C 0B                          DB $9F, $39, $4C, $0B
  80+ EA0A 1F 39 4C 0B                          DB $1F, $39, $4C, $0B
  81+ EA0E 5F 39 4C 0B                          DB $5F, $39, $4C, $0B
  82+ EA12 DF 39 4C 0B                          DB $DF, $39, $4C, $0B
  83+ EA16 1F 00 60 00                          DB $1F, $00, $60, $00
  84+ EA1A 5F 00 60 00                          DB $5F, $00, $60, $00
  85+ EA1E BF 39 4C 0B                          DB $BF, $39, $4C, $0B
  86+ EA22 3F 39 4C 0B                          DB $3F, $39, $4C, $0B
  87+ EA26 7F 39 4C 0B                          DB $7F, $39, $4C, $0B
  88+ EA2A FF 39 4C 0B                          DB $FF, $39, $4C, $0B
  89+ EA2E 3F 00 00 60                          DB $3F, $00, $00, $60
  90+ EA32              ChameleonNormalsSize:   equ $ - ChameleonNormals
  91+ EA32              ChameleonLen:           equ $ - Chameleon
  92+ EA32
# file closed: ../../Data/ships/Chameleon.asm
 923  EA32                                      include "../../Data/ships/CobraMk3.asm"
# file opened: ../../Data/ships/CobraMk3.asm
   1+ EA32              ; Corrected pointers
   2+ EA32              ;                      0    1    2  3  4  5   6   7   8   9   10  11  12   13  14  15   16 17 18 19    20    21
   3+ EA32              ;					   Scp  Missile Edge  Lin Gun Exp Vtx Edg Bounty  Face              Face           Vertices
   4+ EA32              ;                      Deb  Lock    Lo Hi x4  Vtx Cnt x6  X1  lo  hi  x4   Dot Erg Spd  Lo Hi Q  Laser Lo    hi
   5+ EA32 03           CobraMk3    		    DB $03                            ; Number of cargo canisters released when destroyed
   6+ EA33 41 23                                DW $2341                          ; Ship's targetable area LoHi
   7+ EA35 F9 EA                                DW CobraMk3Edges                  ; Edge Data
   8+ EA37 98                                   DB CobraMkEdgesSize               ; Size of Edge Data
   9+ EA38 54                                   DB $54                            ; Gun Vertex Byte offset
  10+ EA39 2A                                   DB $2A                            ; Explosion Count
  11+ EA3A 1C                                   DB CobraMkVertSize /6             ; Vertex Count /6
  12+ EA3B A8                                   DB CobraMkVertSize                ; Vertex Count
  13+ EA3C 26                                   DB CobraMkEdgesCnt                ; Edges Count
  14+ EA3D 00 00                                DW $0000                          ; Bounty LoHi
  15+ EA3F 34                                   DB CobraMk3NormalsSize            ; Face (Normal) Count
  16+ EA40 32                                   DB $32                            ; Range when it turns to a dot
  17+ EA41 96                                   DB $96                            ; Energy Max
  18+ EA42 1C                                   DB $1C                            ; Speed Max
  19+ EA43 91 EB                                DW CobraMk3Normals                ; Normals
  20+ EA45 01                                   DB $01                            ; Q scaling
  21+ EA46 34                                   DB $30 | ShipMissiles4            ; Laser power and Nbr Missiles
  22+ EA47 51 EA                                DW CobraMk3Vertices               ; Verticles Address
  23+ EA49 00                                   DB ShipTypeNormal                 ; Ship Type
  24+ EA4A 00                                   DB 0                              ; NewB Tactics
  25+ EA4B 80                                   DB ShipCanAnger                   ; AI Flags
  26+ EA4C 70                                   DB $70                            ; chance of ECM module
  27+ EA4D FF                                   DB $FF                              ; Supports Solid Fill = false
  28+ EA4E 00 00                                DW $0000                            ; no solid data
  29+ EA50 00                                   DB $00                              ; no solid data
  30+ EA51
  31+ EA51 20 00 4C 1F  CobraMk3Vertices	    DB $20,$00,$4C,$1F,$FF,$FF
  31+ EA55 FF FF
  32+ EA57 20 00 4C 9F                          DB $20,$00,$4C,$9F,$FF,$FF
  32+ EA5B FF FF
  33+ EA5D 00 1A 18 1F                          DB $00,$1A,$18,$1F,$FF,$FF
  33+ EA61 FF FF
  34+ EA63 78 03 08 FF                          DB $78,$03,$08,$FF,$73,$AA
  34+ EA67 73 AA
  35+ EA69 78 03 08 7F                          DB $78,$03,$08,$7F,$84,$CC
  35+ EA6D 84 CC
  36+ EA6F 58 10 28 BF                          DB $58,$10,$28,$BF,$FF,$FF
  36+ EA73 FF FF
  37+ EA75 58 10 28 3F                          DB $58,$10,$28,$3F,$FF,$FF
  37+ EA79 FF FF
  38+ EA7B 80 08 28 7F                          DB $80,$08,$28,$7F,$98,$CC
  38+ EA7F 98 CC
  39+ EA81 80 08 28 FF                          DB $80,$08,$28,$FF,$97,$AA
  39+ EA85 97 AA
  40+ EA87 00 1A 28 3F                          DB $00,$1A,$28,$3F,$65,$99
  40+ EA8B 65 99
  41+ EA8D 20 18 28 FF                          DB $20,$18,$28,$FF,$A9,$BB
  41+ EA91 A9 BB
  42+ EA93 20 18 28 7F                          DB $20,$18,$28,$7F,$B9,$CC
  42+ EA97 B9 CC
  43+ EA99 24 08 28 B4                          DB $24,$08,$28,$B4,$99,$99
  43+ EA9D 99 99
  44+ EA9F 08 0C 28 B4                          DB $08,$0C,$28,$B4,$99,$99
  44+ EAA3 99 99
  45+ EAA5 08 0C 28 34                          DB $08,$0C,$28,$34,$99,$99
  45+ EAA9 99 99
  46+ EAAB 24 08 28 34                          DB $24,$08,$28,$34,$99,$99
  46+ EAAF 99 99
  47+ EAB1 24 0C 28 74                          DB $24,$0C,$28,$74,$99,$99
  47+ EAB5 99 99
  48+ EAB7 08 10 28 74                          DB $08,$10,$28,$74,$99,$99
  48+ EABB 99 99
  49+ EABD 08 10 28 F4                          DB $08,$10,$28,$F4,$99,$99
  49+ EAC1 99 99
  50+ EAC3 24 0C 28 F4                          DB $24,$0C,$28,$F4,$99,$99
  50+ EAC7 99 99
  51+ EAC9 00 00 4C 06                          DB $00,$00,$4C,$06,$B0,$BB
  51+ EACD B0 BB
  52+ EACF 00 00 5A 1F                          DB $00,$00,$5A,$1F,$B0,$BB
  52+ EAD3 B0 BB
  53+ EAD5 50 06 28 E8                          DB $50,$06,$28,$E8,$99,$99
  53+ EAD9 99 99
  54+ EADB 50 06 28 A8                          DB $50,$06,$28,$A8,$99,$99
  54+ EADF 99 99
  55+ EAE1 58 00 28 A6                          DB $58,$00,$28,$A6,$99,$99
  55+ EAE5 99 99
  56+ EAE7 50 06 28 28                          DB $50,$06,$28,$28,$99,$99
  56+ EAEB 99 99
  57+ EAED 58 00 28 26                          DB $58,$00,$28,$26,$99,$99
  57+ EAF1 99 99
  58+ EAF3 50 06 28 68                          DB $50,$06,$28,$68,$99,$99
  58+ EAF7 99 99
  59+ EAF9              CobraMkVertSize         equ $  - CobraMk3Vertices
  60+ EAF9 1F B0 00 04  CobraMk3Edges		    DB $1F,$B0,$00,$04
  61+ EAFD 1F C4 00 10                          DB $1F,$C4,$00,$10
  62+ EB01 1F A3 04 0C                          DB $1F,$A3,$04,$0C
  63+ EB05 1F A7 0C 20                          DB $1F,$A7,$0C,$20
  64+ EB09 1F C8 10 1C                          DB $1F,$C8,$10,$1C
  65+ EB0D 1F 98 18 1C                          DB $1F,$98,$18,$1C
  66+ EB11 1F 96 18 24                          DB $1F,$96,$18,$24
  67+ EB15 1F 95 14 24                          DB $1F,$95,$14,$24
  68+ EB19 1F 97 14 20                          DB $1F,$97,$14,$20
  69+ EB1D 1F 51 08 14                          DB $1F,$51,$08,$14
  70+ EB21 1F 62 08 18                          DB $1F,$62,$08,$18
  71+ EB25 1F 73 0C 14                          DB $1F,$73,$0C,$14
  72+ EB29 1F 84 10 18                          DB $1F,$84,$10,$18
  73+ EB2D 1F 10 04 08                          DB $1F,$10,$04,$08
  74+ EB31 1F 20 00 08                          DB $1F,$20,$00,$08
  75+ EB35 1F A9 20 28                          DB $1F,$A9,$20,$28
  76+ EB39 1F B9 28 2C                          DB $1F,$B9,$28,$2C
  77+ EB3D 1F C9 1C 2C                          DB $1F,$C9,$1C,$2C
  78+ EB41 1F BA 04 28                          DB $1F,$BA,$04,$28
  79+ EB45 1F CB 00 2C                          DB $1F,$CB,$00,$2C
  80+ EB49 1D 31 04 14                          DB $1D,$31,$04,$14
  81+ EB4D 1D 42 00 18                          DB $1D,$42,$00,$18
  82+ EB51 06 B0 50 54                          DB $06,$B0,$50,$54
  83+ EB55 14 99 30 34                          DB $14,$99,$30,$34
  84+ EB59 14 99 48 4C                          DB $14,$99,$48,$4C
  85+ EB5D 14 99 38 3C                          DB $14,$99,$38,$3C
  86+ EB61 14 99 40 44                          DB $14,$99,$40,$44
  87+ EB65 13 99 3C 40                          DB $13,$99,$3C,$40
  88+ EB69 11 99 38 44                          DB $11,$99,$38,$44
  89+ EB6D 13 99 34 48                          DB $13,$99,$34,$48
  90+ EB71 13 99 30 4C                          DB $13,$99,$30,$4C
  91+ EB75 1E 65 08 24                          DB $1E,$65,$08,$24
  92+ EB79 06 99 58 60                          DB $06,$99,$58,$60
  93+ EB7D 06 99 5C 60                          DB $06,$99,$5C,$60
  94+ EB81 08 99 58 5C                          DB $08,$99,$58,$5C
  95+ EB85 06 99 64 68                          DB $06,$99,$64,$68
  96+ EB89 06 99 68 6C                          DB $06,$99,$68,$6C
  97+ EB8D 08 99 64 6C                          DB $08,$99,$64,$6C
  98+ EB91              CobraMkEdgesSize        equ $  - CobraMk3Edges
  99+ EB91              CobraMkEdgesCnt         equ CobraMkEdgesSize/4
 100+ EB91              ; start normals #0 = top f,$on,$ p,$at,$ o,$ C,$br,$ Mk III
 101+ EB91 1F 00 3E 1F  CobraMk3Normals		    DB $1F,$00,$3E,$1F
 102+ EB95 9F 12 37 10                          DB $9F,$12,$37,$10
 103+ EB99 1F 12 37 10                          DB $1F,$12,$37,$10
 104+ EB9D 9F 10 34 0E                          DB $9F,$10,$34,$0E
 105+ EBA1 1F 10 34 0E                          DB $1F,$10,$34,$0E
 106+ EBA5 9F 0E 2F 00                          DB $9F,$0E,$2F,$00
 107+ EBA9 1F 0E 2F 00                          DB $1F,$0E,$2F,$00
 108+ EBAD 9F 3D 66 00                          DB $9F,$3D,$66,$00
 109+ EBB1 1F 3D 66 00                          DB $1F,$3D,$66,$00
 110+ EBB5 3F 00 00 50                          DB $3F,$00,$00,$50
 111+ EBB9 DF 07 2A 09                          DB $DF,$07,$2A,$09
 112+ EBBD 5F 00 1E 06                          DB $5F,$00,$1E,$06
 113+ EBC1 5F 07 2A 09                          DB $5F,$07,$2A,$09 		;end of Cobra Mk III
 114+ EBC5              CobraMk3NormalsSize     equ $  - CobraMk3Normals
 115+ EBC5              CobraMk3Len             equ $  - CobraMk3
 116+ EBC5
# file closed: ../../Data/ships/CobraMk3.asm
 924  EBC5                                      include "../../Data/ships/Cobra_Mk_1.asm"
# file opened: ../../Data/ships/Cobra_Mk_1.asm
   1+ EBC5 03           Cobra_Mk_1:	            DB $03                              ; Number of cargo canisters released when destroyed
   2+ EBC6 49 26                                DW $2649                            ; Ship's targetable area LoHi
   3+ EBC8 26 EC                                DW Cobra_Mk_1Edges                  ; Edge Data
   4+ EBCA 48                                   DB Cobra_Mk_1EdgesSize              ; Size of Edge Data
   5+ EBCB 28                                   DB $28                              ; Gun Vertex Byte offset
   6+ EBCC 1A                                   DB $1A                              ; Explosion Count
   7+ EBCD 0B                                   DB Cobra_Mk_1VertSize /6            ; Vertex Count /6
   8+ EBCE 42                                   DB Cobra_Mk_1VertSize               ; Vertex Count
   9+ EBCF 12                                   DB Cobra_Mk_1EdgesCnt               ; Edges Count
  10+ EBD0 00 4B                                DW $4B00                            ; Bounty LoHi
  11+ EBD2 28                                   DB Cobra_Mk_1NormalsSize            ; Face (Normal) Count
  12+ EBD3 13                                   DB $13                              ; Range when it turns to a dot
  13+ EBD4 51                                   DB $51                              ; Energy Max
  14+ EBD5 1A                                   DB $1A                              ; Speed Max
  15+ EBD6 6E EC                                DW Cobra_Mk_1Normals                ; Normals
  16+ EBD8 02                                   DB $02                              ; Q scaling
  17+ EBD9 23                                   DB $20 | ShipMissiles3              ; Laser power and Nbr Missiles
  18+ EBDA E4 EB                                DW Cobra_Mk_1Vertices               ; Verticles Address
  19+ EBDC 00                                   DB ShipTypeNormal                   ; Ship Type
  20+ EBDD 00                                   DB 0                                ; NewB Tactics
  21+ EBDE 80                                   DB ShipCanAnger                     ; AI Flags
  22+ EBDF 30                                   DB $30                              ; chance of ECM module
  23+ EBE0 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ EBE1 00 00                                DW $0000                            ; no solid data
  25+ EBE3 00                                   DB $00                              ; no solid data
  26+ EBE4
  27+ EBE4 12 01 32 DF  Cobra_Mk_1Vertices:	    DB $12, $01, $32, $DF, $01, $23
  27+ EBE8 01 23
  28+ EBEA 12 01 32 5F                          DB $12, $01, $32, $5F, $01, $45
  28+ EBEE 01 45
  29+ EBF0 42 00 07 9F                          DB $42, $00, $07, $9F, $23, $88
  29+ EBF4 23 88
  30+ EBF6 42 00 07 1F                          DB $42, $00, $07, $1F, $45, $99
  30+ EBFA 45 99
  31+ EBFC 20 0C 26 BF                          DB $20, $0C, $26, $BF, $26, $78
  31+ EC00 26 78
  32+ EC02 20 0C 26 3F                          DB $20, $0C, $26, $3F, $46, $79
  32+ EC06 46 79
  33+ EC08 36 0C 26 FF                          DB $36, $0C, $26, $FF, $13, $78
  33+ EC0C 13 78
  34+ EC0E 36 0C 26 7F                          DB $36, $0C, $26, $7F, $15, $79
  34+ EC12 15 79
  35+ EC14 00 0C 06 34                          DB $00, $0C, $06, $34, $02, $46
  35+ EC18 02 46
  36+ EC1A 00 01 32 42                          DB $00, $01, $32, $42, $01, $11
  36+ EC1E 01 11
  37+ EC20 00 01 3C 5F                          DB $00, $01, $3C, $5F, $01, $11
  37+ EC24 01 11
  38+ EC26              Cobra_Mk_1VertSize:     equ $ - Cobra_Mk_1Vertices
  39+ EC26 1F 01 04 00  Cobra_Mk_1Edges:	    DB $1F, $01, $04, $00
  40+ EC2A 1F 23 00 08                          DB $1F, $23, $00, $08
  41+ EC2E 1F 38 08 18                          DB $1F, $38, $08, $18
  42+ EC32 1F 17 18 1C                          DB $1F, $17, $18, $1C
  43+ EC36 1F 59 1C 0C                          DB $1F, $59, $1C, $0C
  44+ EC3A 1F 45 0C 04                          DB $1F, $45, $0C, $04
  45+ EC3E 1F 28 08 10                          DB $1F, $28, $08, $10
  46+ EC42 1F 67 10 14                          DB $1F, $67, $10, $14
  47+ EC46 1F 49 14 0C                          DB $1F, $49, $14, $0C
  48+ EC4A 14 02 00 20                          DB $14, $02, $00, $20
  49+ EC4E 14 04 20 04                          DB $14, $04, $20, $04
  50+ EC52 10 26 10 20                          DB $10, $26, $10, $20
  51+ EC56 10 46 20 14                          DB $10, $46, $20, $14
  52+ EC5A 1F 78 10 18                          DB $1F, $78, $10, $18
  53+ EC5E 1F 79 14 1C                          DB $1F, $79, $14, $1C
  54+ EC62 14 13 00 18                          DB $14, $13, $00, $18
  55+ EC66 14 15 04 1C                          DB $14, $15, $04, $1C
  56+ EC6A 02 01 28 24                          DB $02, $01, $28, $24
  57+ EC6E              Cobra_Mk_1EdgesSize:    equ $ - Cobra_Mk_1Edges
  58+ EC6E              Cobra_Mk_1EdgesCnt:     equ Cobra_Mk_1EdgesSize/4
  59+ EC6E 1F 00 29 0A  Cobra_Mk_1Normals:	    DB $1F, $00, $29, $0A
  60+ EC72 5F 00 1B 03                          DB $5F, $00, $1B, $03
  61+ EC76 9F 08 2E 08                          DB $9F, $08, $2E, $08
  62+ EC7A DF 0C 39 0C                          DB $DF, $0C, $39, $0C
  63+ EC7E 1F 08 2E 08                          DB $1F, $08, $2E, $08
  64+ EC82 5F 0C 39 0C                          DB $5F, $0C, $39, $0C
  65+ EC86 1F 00 31 00                          DB $1F, $00, $31, $00
  66+ EC8A 3F 00 00 9A                          DB $3F, $00, $00, $9A
  67+ EC8E BF 79 6F 3E                          DB $BF, $79, $6F, $3E
  68+ EC92 3F 79 6F 3E                          DB $3F, $79, $6F, $3E
  69+ EC96              Cobra_Mk_1NormalsSize:  equ $ - Cobra_Mk_1Normals
  70+ EC96              Cobra_Mk_1Len:          equ $ - Cobra_Mk_1
  71+ EC96
# file closed: ../../Data/ships/Cobra_Mk_1.asm
 925  EC96                                      include "../../Data/ships/Cobra_Mk_3_P.asm"
# file opened: ../../Data/ships/Cobra_Mk_3_P.asm
   1+ EC96 01           Cobra_Mk_3_P:	        DB $01                              ; Number of cargo canisters released when destroyed
   2+ EC97 41 23                                DW $2341                            ; Ship's targetable area LoHi
   3+ EC99 5D ED                                DW Cobra_Mk_3_PEdges                ; Edge Data
   4+ EC9B 98                                   DB Cobra_Mk_3_PEdgesSize            ; Size of Edge Data
   5+ EC9C 54                                   DB $54                              ; Gun Vertex Byte offset
   6+ EC9D 2A                                   DB $2A                              ; Explosion Count
   7+ EC9E 1C                                   DB Cobra_Mk_3_PVertSize /6          ; Vertex Count /6
   8+ EC9F A8                                   DB Cobra_Mk_3_PVertSize             ; Vertex Count
   9+ ECA0 26                                   DB Cobra_Mk_3_PEdgesCnt             ; Edges Count
  10+ ECA1 00 AF                                DW $AF00                            ; Bounty LoHi
  11+ ECA3 34                                   DB Cobra_Mk_3_PNormalsSize          ; Face (Normal) Count
  12+ ECA4                                      ; Add in a new byte for range for LoD, if this is zero then no LoD Data
  13+ ECA4 32                                   DB $32                              ; Range when it turns to a dot
  14+ ECA5 96                                   DB $96                              ; Energy Max
  15+ ECA6 1C                                   DB $1C                              ; Speed Max
  16+ ECA7 F5 ED                                DW Cobra_Mk_3_PNormals              ; Normals
  17+ ECA9 01                                   DB $01                              ; Q scaling
  18+ ECAA 14                                   DB $10 | ShipMissiles4              ; Laser power and Nbr Missiles
  19+ ECAB B5 EC                                DW Cobra_Mk_3_PVertices             ; Verticles Address
  20+ ECAD 00                                   DB ShipTypeNormal                   ; Ship Type
  21+ ECAE 00                                   DB 0                                ; NewB Tactics
  22+ ECAF 80                                   DB ShipCanAnger                     ; AI Flags
  23+ ECB0 90                                   DB $90                              ; chance of ECM module
  24+ ECB1 FF                                   DB $FF                              ; Supports Solid Fill = false
  25+ ECB2 00 00                                DW $0000                            ; no solid data
  26+ ECB4 00                                   DB $00                              ; no solid data
  27+ ECB5
  28+ ECB5 20 00 4C 1F  Cobra_Mk_3_PVertices:	DB $20, $00, $4C, $1F, $FF, $FF
  28+ ECB9 FF FF
  29+ ECBB 20 00 4C 9F                          DB $20, $00, $4C, $9F, $FF, $FF
  29+ ECBF FF FF
  30+ ECC1 00 1A 18 1F                          DB $00, $1A, $18, $1F, $FF, $FF
  30+ ECC5 FF FF
  31+ ECC7 78 03 08 FF                          DB $78, $03, $08, $FF, $73, $AA
  31+ ECCB 73 AA
  32+ ECCD 78 03 08 7F                          DB $78, $03, $08, $7F, $84, $CC
  32+ ECD1 84 CC
  33+ ECD3 58 10 28 BF                          DB $58, $10, $28, $BF, $FF, $FF
  33+ ECD7 FF FF
  34+ ECD9 58 10 28 3F                          DB $58, $10, $28, $3F, $FF, $FF
  34+ ECDD FF FF
  35+ ECDF 80 08 28 7F                          DB $80, $08, $28, $7F, $98, $CC
  35+ ECE3 98 CC
  36+ ECE5 80 08 28 FF                          DB $80, $08, $28, $FF, $97, $AA
  36+ ECE9 97 AA
  37+ ECEB 00 1A 28 3F                          DB $00, $1A, $28, $3F, $65, $99
  37+ ECEF 65 99
  38+ ECF1 20 18 28 FF                          DB $20, $18, $28, $FF, $A9, $BB
  38+ ECF5 A9 BB
  39+ ECF7 20 18 28 7F                          DB $20, $18, $28, $7F, $B9, $CC
  39+ ECFB B9 CC
  40+ ECFD 24 08 28 B4                          DB $24, $08, $28, $B4, $99, $99
  40+ ED01 99 99
  41+ ED03 08 0C 28 B4                          DB $08, $0C, $28, $B4, $99, $99
  41+ ED07 99 99
  42+ ED09 08 0C 28 34                          DB $08, $0C, $28, $34, $99, $99
  42+ ED0D 99 99
  43+ ED0F 24 08 28 34                          DB $24, $08, $28, $34, $99, $99
  43+ ED13 99 99
  44+ ED15 24 0C 28 74                          DB $24, $0C, $28, $74, $99, $99
  44+ ED19 99 99
  45+ ED1B 08 10 28 74                          DB $08, $10, $28, $74, $99, $99
  45+ ED1F 99 99
  46+ ED21 08 10 28 F4                          DB $08, $10, $28, $F4, $99, $99
  46+ ED25 99 99
  47+ ED27 24 0C 28 F4                          DB $24, $0C, $28, $F4, $99, $99
  47+ ED2B 99 99
  48+ ED2D 00 00 4C 06                          DB $00, $00, $4C, $06, $B0, $BB
  48+ ED31 B0 BB
  49+ ED33 00 00 5A 1F                          DB $00, $00, $5A, $1F, $B0, $BB
  49+ ED37 B0 BB
  50+ ED39 50 06 28 E8                          DB $50, $06, $28, $E8, $99, $99
  50+ ED3D 99 99
  51+ ED3F 50 06 28 A8                          DB $50, $06, $28, $A8, $99, $99
  51+ ED43 99 99
  52+ ED45 58 00 28 A6                          DB $58, $00, $28, $A6, $99, $99
  52+ ED49 99 99
  53+ ED4B 50 06 28 28                          DB $50, $06, $28, $28, $99, $99
  53+ ED4F 99 99
  54+ ED51 58 00 28 26                          DB $58, $00, $28, $26, $99, $99
  54+ ED55 99 99
  55+ ED57 50 06 28 68                          DB $50, $06, $28, $68, $99, $99
  55+ ED5B 99 99
  56+ ED5D              Cobra_Mk_3_PVertSize:   equ $ - Cobra_Mk_3_PVertices
  57+ ED5D 1F B0 00 04  Cobra_Mk_3_PEdges:	    DB $1F, $B0, $00, $04
  58+ ED61 1F C4 00 10                          DB $1F, $C4, $00, $10
  59+ ED65 1F A3 04 0C                          DB $1F, $A3, $04, $0C
  60+ ED69 1F A7 0C 20                          DB $1F, $A7, $0C, $20
  61+ ED6D 1F C8 10 1C                          DB $1F, $C8, $10, $1C
  62+ ED71 1F 98 18 1C                          DB $1F, $98, $18, $1C
  63+ ED75 1F 96 18 24                          DB $1F, $96, $18, $24
  64+ ED79 1F 95 14 24                          DB $1F, $95, $14, $24
  65+ ED7D 1F 97 14 20                          DB $1F, $97, $14, $20
  66+ ED81 1F 51 08 14                          DB $1F, $51, $08, $14
  67+ ED85 1F 62 08 18                          DB $1F, $62, $08, $18
  68+ ED89 1F 73 0C 14                          DB $1F, $73, $0C, $14
  69+ ED8D 1F 84 10 18                          DB $1F, $84, $10, $18
  70+ ED91 1F 10 04 08                          DB $1F, $10, $04, $08
  71+ ED95 1F 20 00 08                          DB $1F, $20, $00, $08
  72+ ED99 1F A9 20 28                          DB $1F, $A9, $20, $28
  73+ ED9D 1F B9 28 2C                          DB $1F, $B9, $28, $2C
  74+ EDA1 1F C9 1C 2C                          DB $1F, $C9, $1C, $2C
  75+ EDA5 1F BA 04 28                          DB $1F, $BA, $04, $28
  76+ EDA9 1F CB 00 2C                          DB $1F, $CB, $00, $2C
  77+ EDAD 1D 31 04 14                          DB $1D, $31, $04, $14
  78+ EDB1 1D 42 00 18                          DB $1D, $42, $00, $18
  79+ EDB5 06 B0 50 54                          DB $06, $B0, $50, $54
  80+ EDB9 14 99 30 34                          DB $14, $99, $30, $34
  81+ EDBD 14 99 48 4C                          DB $14, $99, $48, $4C
  82+ EDC1 14 99 38 3C                          DB $14, $99, $38, $3C
  83+ EDC5 14 99 40 44                          DB $14, $99, $40, $44
  84+ EDC9 13 99 3C 40                          DB $13, $99, $3C, $40
  85+ EDCD 11 99 38 44                          DB $11, $99, $38, $44
  86+ EDD1 13 99 34 48                          DB $13, $99, $34, $48
  87+ EDD5 13 99 30 4C                          DB $13, $99, $30, $4C
  88+ EDD9 1E 65 08 24                          DB $1E, $65, $08, $24
  89+ EDDD 06 99 58 60                          DB $06, $99, $58, $60
  90+ EDE1 06 99 5C 60                          DB $06, $99, $5C, $60
  91+ EDE5 08 99 58 5C                          DB $08, $99, $58, $5C
  92+ EDE9 06 99 64 68                          DB $06, $99, $64, $68
  93+ EDED 06 99 68 6C                          DB $06, $99, $68, $6C
  94+ EDF1 08 99 64 6C                          DB $08, $99, $64, $6C
  95+ EDF5              Cobra_Mk_3_PEdgesSize:  equ $ - Cobra_Mk_3_PEdges
  96+ EDF5              Cobra_Mk_3_PEdgesCnt:   equ Cobra_Mk_3_PEdgesSize/4
  97+ EDF5 1F 00 3E 1F  Cobra_Mk_3_PNormals:	DB $1F, $00, $3E, $1F
  98+ EDF9 9F 12 37 10                          DB $9F, $12, $37, $10
  99+ EDFD 1F 12 37 10                          DB $1F, $12, $37, $10
 100+ EE01 9F 10 34 0E                          DB $9F, $10, $34, $0E
 101+ EE05 1F 10 34 0E                          DB $1F, $10, $34, $0E
 102+ EE09 9F 0E 2F 00                          DB $9F, $0E, $2F, $00
 103+ EE0D 1F 0E 2F 00                          DB $1F, $0E, $2F, $00
 104+ EE11 9F 3D 66 00                          DB $9F, $3D, $66, $00
 105+ EE15 1F 3D 66 00                          DB $1F, $3D, $66, $00
 106+ EE19 3F 00 00 50                          DB $3F, $00, $00, $50
 107+ EE1D DF 07 2A 09                          DB $DF, $07, $2A, $09
 108+ EE21 5F 00 1E 06                          DB $5F, $00, $1E, $06
 109+ EE25 5F 07 2A 09                          DB $5F, $07, $2A, $09
 110+ EE29              Cobra_Mk_3_PNormalsSize:equ $ - Cobra_Mk_3_PNormals
 111+ EE29              Cobra_Mk_3_PLen:        equ $ - Cobra_Mk_3_P
 112+ EE29
# file closed: ../../Data/ships/Cobra_Mk_3_P.asm
 926  EE29                                      include "../../Data/ships/Constrictor.asm"
# file opened: ../../Data/ships/Constrictor.asm
   1+ EE29 F3           Constrictor:    	    DB $F3                         ; Number of cargo canisters released when destroyed
   2+ EE2A 49 26                                DW $2649                       ; Ship's targetable area LoHi
   3+ EE2C AE EE                                DW ConstrictorEdges            ; Edge Data
   4+ EE2E 60                                   DB ConstrictorEdgesSize        ; Size of Edge Data
   5+ EE2F 00                                   DB $00                         ; Gun Vertex Byte offset
   6+ EE30 2E                                   DB $2E                         ; Explosion Count
   7+ EE31 11                                   DB ConstrictorVertSize /6      ; Vertex Count /6
   8+ EE32 66                                   DB ConstrictorVertSize         ; Vertex Count
   9+ EE33 18                                   DB ConstrictorEdgesCnt         ; Edges Count
  10+ EE34 18 00                                DW $0018                       ; Bounty LoHi
  11+ EE36 28                                   DB ConstrictorNormalsSize      ; Face (Normal) Count
  12+ EE37 2D                                   DB $2D                         ; Range when it turns to a dot
  13+ EE38 C8                                   DB $C8                         ; Energy Max
  14+ EE39 37                                   DB $37                         ; Speed Max
  15+ EE3A 0E EF                                DW ConstrictorNormals          ; Normals
  16+ EE3C 02                                   DB $02                         ; Q scaling
  17+ EE3D 2F                                   DB $20 | ShipMissiles15        ; Laser power and Nbr Missiles
  18+ EE3E 48 EE                                DW ConstrictorVertices         ; Verticles Address
  19+ EE40 00                                   DB ShipTypeNormal              ; Ship Type
  20+ EE41 00                                   DB 0                           ; NewB Tactics
  21+ EE42 80                                   DB ShipCanAnger                ; AI Flags
  22+ EE43 FF                                   DB $FF                         ; chance of ECM module
  23+ EE44 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ EE45 00 00                                DW $0000                            ; no solid data
  25+ EE47 00                                   DB $00                              ; no solid data
  26+ EE48
  27+ EE48 14 07 50 5F  ConstrictorVertices     DB $14, $07, $50, $5F, $02, $99
  27+ EE4C 02 99
  28+ EE4E 14 07 50 DF                          DB $14, $07, $50, $DF, $01, $99
  28+ EE52 01 99
  29+ EE54 36 07 28 DF                          DB $36, $07, $28, $DF, $14, $99
  29+ EE58 14 99
  30+ EE5A 36 07 28 FF                          DB $36, $07, $28, $FF, $45, $89
  30+ EE5E 45 89
  31+ EE60 14 0D 28 BF                          DB $14, $0D, $28, $BF, $56, $88
  31+ EE64 56 88
  32+ EE66 14 0D 28 3F                          DB $14, $0D, $28, $3F, $67, $88
  32+ EE6A 67 88
  33+ EE6C 36 07 28 7F                          DB $36, $07, $28, $7F, $37, $89
  33+ EE70 37 89
  34+ EE72 36 07 28 5F                          DB $36, $07, $28, $5F, $23, $99
  34+ EE76 23 99
  35+ EE78 14 0D 05 1F                          DB $14, $0D, $05, $1F, $FF, $FF
  35+ EE7C FF FF
  36+ EE7E 14 0D 05 9F                          DB $14, $0D, $05, $9F, $FF, $FF
  36+ EE82 FF FF
  37+ EE84 14 07 3E 52                          DB $14, $07, $3E, $52, $99, $99
  37+ EE88 99 99
  38+ EE8A 14 07 3E D2                          DB $14, $07, $3E, $D2, $99, $99
  38+ EE8E 99 99
  39+ EE90 19 07 19 72                          DB $19, $07, $19, $72, $99, $99
  39+ EE94 99 99
  40+ EE96 19 07 19 F2                          DB $19, $07, $19, $F2, $99, $99
  40+ EE9A 99 99
  41+ EE9C 0F 07 0F 6A                          DB $0F, $07, $0F, $6A, $99, $99
  41+ EEA0 99 99
  42+ EEA2 0F 07 0F EA                          DB $0F, $07, $0F, $EA, $99, $99
  42+ EEA6 99 99
  43+ EEA8 00 07 00 40                          DB $00, $07, $00, $40, $9F, $01
  43+ EEAC 9F 01
  44+ EEAE              ConstrictorVertSize     equ $  - ConstrictorVertices
  45+ EEAE 1F 09 00 04  ConstrictorEdges        DB $1F, $09, $00, $04
  46+ EEB2 1F 19 04 08                          DB $1F, $19, $04, $08
  47+ EEB6 1F 01 04 24                          DB $1F, $01, $04, $24
  48+ EEBA 1F 02 00 20                          DB $1F, $02, $00, $20
  49+ EEBE 1F 29 00 1C                          DB $1F, $29, $00, $1C
  50+ EEC2 1F 23 1C 20                          DB $1F, $23, $1C, $20
  51+ EEC6 1F 14 08 24                          DB $1F, $14, $08, $24
  52+ EECA 1F 49 08 0C                          DB $1F, $49, $08, $0C
  53+ EECE 1F 39 18 1C                          DB $1F, $39, $18, $1C
  54+ EED2 1F 37 18 20                          DB $1F, $37, $18, $20
  55+ EED6 1F 67 14 20                          DB $1F, $67, $14, $20
  56+ EEDA 1F 56 10 24                          DB $1F, $56, $10, $24
  57+ EEDE 1F 45 0C 24                          DB $1F, $45, $0C, $24
  58+ EEE2 1F 58 0C 10                          DB $1F, $58, $0C, $10
  59+ EEE6 1F 68 10 14                          DB $1F, $68, $10, $14
  60+ EEEA 1F 78 14 18                          DB $1F, $78, $14, $18
  61+ EEEE 1F 89 0C 18                          DB $1F, $89, $0C, $18
  62+ EEF2 1F 06 20 24                          DB $1F, $06, $20, $24
  63+ EEF6 12 99 28 30                          DB $12, $99, $28, $30
  64+ EEFA 05 99 30 38                          DB $05, $99, $30, $38
  65+ EEFE 0A 99 38 28                          DB $0A, $99, $38, $28
  66+ EF02 0A 99 2C 3C                          DB $0A, $99, $2C, $3C
  67+ EF06 05 99 34 3C                          DB $05, $99, $34, $3C
  68+ EF0A 12 99 2C 34                          DB $12, $99, $2C, $34
  69+ EF0E              ConstrictorEdgesSize    equ $  - ConstrictorEdges
  70+ EF0E              ConstrictorEdgesCnt     equ ConstrictorEdgesSize/4
  71+ EF0E 1F 00 37 0F  ConstrictorNormals      DB $1F, $00, $37, $0F, $9F, $18, $4B, $14
  71+ EF12 9F 18 4B 14
  72+ EF16 1F 18 4B 14                          DB $1F, $18, $4B, $14, $1F, $2C, $4B, $00
  72+ EF1A 1F 2C 4B 00
  73+ EF1E 9F 2C 4B 00                          DB $9F, $2C, $4B, $00, $9F, $2C, $4B, $00
  73+ EF22 9F 2C 4B 00
  74+ EF26 1F 00 35 00                          DB $1F, $00, $35, $00, $1F, $2C, $4B, $00
  74+ EF2A 1F 2C 4B 00
  75+ EF2E 3F 00 00 A0                          DB $3F, $00, $00, $A0, $5F, $00, $1B, $00
  75+ EF32 5F 00 1B 00
  76+ EF36              ConstrictorNormalsSize  equ $  - ConstrictorNormals
  77+ EF36              ConstrictorLen          equ $  - Constrictor
  78+ EF36
# file closed: ../../Data/ships/Constrictor.asm
 927  EF36                                      include "../../Data/ships/Coriolis.asm"
# file opened: ../../Data/ships/Coriolis.asm
   1+ EF36 00           Coriolis:	            DB $00                                      ; Number of cargo canisters released when destroyed
   2+ EF37 00 64                                DW $6400                                    ; Ship's targetable area LoHi
   3+ EF39 B5 EF                                DW CoriolisEdges                            ; Edge Data
   4+ EF3B 70                                   DB CoriolisEdgesSize                        ; Size of Edge Data
   5+ EF3C 00                                   DB $00                                      ; Gun Vertex Byte offset
   6+ EF3D 36                                   DB $36                                      ; Explosion Count
   7+ EF3E 10                                   DB CoriolisVertSize /6                      ; Vertex Count /6
   8+ EF3F 60                                   DB CoriolisVertSize                         ; Vertex Count
   9+ EF40 1C                                   DB CoriolisEdgesCnt                         ; Edges Count
  10+ EF41 00 00                                DW $0000                                    ; Bounty LoHi
  11+ EF43 38                                   DB CoriolisNormalsSize                      ; Face (Normal) Count
  12+ EF44 78                                   DB $78                                      ; Range when it turns to a dot
  13+ EF45 F0                                   DB $F0                                      ; Energy Max
  14+ EF46 00                                   DB $00                                      ; Speed Max
  15+ EF47 25 F0                                DW CoriolisNormals                          ; Normals
  16+ EF49 00                                   DB $00                                      ; Q scaling
  17+ EF4A 06                                   DB $06                                      ; Laser power and Nbr Missiles
  18+ EF4B 55 EF                                DW CoriolisVertices                         ; Verticles Address
  19+ EF4D 02                                   DB ShipTypeStation                          ; Ship Type
  20+ EF4E 00                                   DB 0                                        ; NewB Tactics
  21+ EF4F 78                                   DB ShipFighterBaySize | ShipFighterViper    ; AI Flags
  22+ EF50 FF                                   DB $FF                                      ; chance of ECM module
  23+ EF51 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ EF52 00 00                                DW $0000                            ; no solid data
  25+ EF54 00                                   DB $00                              ; no solid data
  26+ EF55              ;Need to do a debug cube and test that, even better a debug square only
  27+ EF55              ; a debug cube would be -160, 160, 160  to -160,160,-160    top left forward     to top left rear         TLF   $A0, $A0, $A0, $9F, $14, $50
  28+ EF55              ;                       -160, 160, 160  to -160,-160,160    top left forward     to bottom left forward   TLR   $A0, $A0, $A0, $BF, $45, $60
  29+ EF55              ;                       -160, 160,-160  to  160,160,-160    top left rear        to top right rear        BLF   $A0, $A0, $A0, $DF, $12, $40
  30+ EF55              ;                       -160, 160,-160  to -160,-160,-160   top left rear        to bottom left rear      TRR   $A0, $A0, $A0, $3F, $35, $60
  31+ EF55              ;                       -160,-160,-160  to -160,-160,-160   bottom left forward  to bottom left rear      BLR   $A0, $A0, $A0, $FF, $24, $60
  32+ EF55              ;                       -160, 160, 160  to  160, 160, 160   top left forward     to top right forward     TRF   $A0, $A0, $A0, $1F, $13, $60
  33+ EF55              ;                       -160,-160, 160  to  160,-160, 160   bottom left forward  to bottom right forward  BRF   $A0, $A0, $A0, $5F, $12, $30
  34+ EF55              ;                       -160,-160,-160  to  160,-160,-160   bottom left rear     to bottom right rear     BRR   $A0, $A0, $A0, $7F, $23, $50
  35+ EF55              ;                        160, 160, 160  to  160, 160,-160   top right forward    to top right rear
  36+ EF55              ;                        160,-160, 160  to  160,-160,-160   bottom right forward to bottom right rear
  37+ EF55              ;                        160, 160, 160  to  160,-160, 160   top right forward    to bottom right forward
  38+ EF55              ;                        160, 160,-160  to  160,-160,-160   top right rear       to bottom right rear
  39+ EF55              CoriolisVertices:	    ; DB $A0, $A0, $A0, $9F, $14, $50    ; TLF 1
  40+ EF55                                      ; DB $A0, $A0, $A0, $BF, $45, $60    ; TLR 2
  41+ EF55                                      ; DB $A0, $A0, $A0, $DF, $12, $40    ; BLF 3
  42+ EF55                                      ; DB $A0, $A0, $A0, $3F, $35, $60    ; TRR 4
  43+ EF55                                      ; DB $A0, $A0, $A0, $FF, $24, $60    ; BLR 5
  44+ EF55                                      ; DB $A0, $A0, $A0, $1F, $13, $60    ; TRF 6
  45+ EF55                                      ; DB $A0, $A0, $A0, $5F, $12, $30    ; BRF 7
  46+ EF55                                      ; DB $A0, $A0, $A0, $7F, $23, $50    ; BRR 8
  47+ EF55 A0 00 A0 1F                           DB $A0, $00, $A0, $1F, $10, $62     ; 160,   0 , 160
  47+ EF59 10 62
  48+ EF5B 00 A0 A0 1F                           DB $00, $A0, $A0, $1F, $20, $83     ;   0, 160 , 160
  48+ EF5F 20 83
  49+ EF61 A0 00 A0 9F                           DB $A0, $00, $A0, $9F, $30, $74     ;-160,   0 , 160
  49+ EF65 30 74
  50+ EF67 00 A0 A0 5F                           DB $00, $A0, $A0, $5F, $10, $54     ;   0,-160 , 160
  50+ EF6B 10 54
  51+ EF6D A0 A0 00 5F                           DB $A0, $A0, $00, $5F, $51, $A6     ; 160,-160 ,   0
  51+ EF71 51 A6
  52+ EF73 A0 A0 00 1F                           DB $A0, $A0, $00, $1F, $62, $B8     ; 160, 160 ,   0
  52+ EF77 62 B8
  53+ EF79 A0 A0 00 9F                           DB $A0, $A0, $00, $9F, $73, $C8     ;-160, 160 ,   0
  53+ EF7D 73 C8
  54+ EF7F A0 A0 00 DF                           DB $A0, $A0, $00, $DF, $54, $97     ;-160,-160 ,   0
  54+ EF83 54 97
  55+ EF85 A0 00 A0 3F                           DB $A0, $00, $A0, $3F, $A6, $DB     ; 160,   0 ,-160
  55+ EF89 A6 DB
  56+ EF8B 00 A0 A0 3F                           DB $00, $A0, $A0, $3F, $B8, $DC     ;   0, 160 ,-160
  56+ EF8F B8 DC
  57+ EF91 A0 00 A0 BF                           DB $A0, $00, $A0, $BF, $97, $DC     ;-160,   0 ,-160
  57+ EF95 97 DC
  58+ EF97 00 A0 A0 7F                           DB $00, $A0, $A0, $7F, $95, $DA     ;   0,-160 ,-160
  58+ EF9B 95 DA
  59+ EF9D 0A 1E A0 5E                           DB $0A, $1E, $A0, $5E, $00, $00     ; 160, -30 , 160
  59+ EFA1 00 00
  60+ EFA3 0A 1E A0 1E                           DB $0A, $1E, $A0, $1E, $00, $00     ; 160,  30 , 160
  60+ EFA7 00 00
  61+ EFA9 0A 1E A0 9E                           DB $0A, $1E, $A0, $9E, $00, $00     ;-160,  30 , 160
  61+ EFAD 00 00
  62+ EFAF 0A 1E A0 DE                          DB $0A, $1E, $A0, $DE, $00, $00     ;-160, -30 , 160
  62+ EFB3 00 00
  63+ EFB5              CoriolisVertSize:       equ $ - CoriolisVertices
  64+ EFB5              CoriolisEdges:	        ; DB $1F, $46, $01, $02
  65+ EFB5                                      ; DB $1F, $56, $02, $04
  66+ EFB5                                      ; DB $1F, $36, $06, $04
  67+ EFB5                                      ; DB $1F, $16, $01, $06
  68+ EFB5                                      ; DB $1F, $14, $01, $03
  69+ EFB5                                      ; DB $1F, $46, $02, $05
  70+ EFB5                                      ; DB $1F, $35, $04, $08
  71+ EFB5                                      ; DB $1F, $23, $06, $07
  72+ EFB5                                      ; DB $1F, $24, $03, $05
  73+ EFB5                                      ; DB $1F, $25, $05, $08
  74+ EFB5                                      ; DB $1F, $23, $07, $08
  75+ EFB5                                      ; DB $1F, $12, $03, $07
  76+ EFB5
  77+ EFB5 1F 10 00 0C                          DB $1F, $10, $00, $0C
  78+ EFB9 1F 20 00 04                          DB $1F, $20, $00, $04
  79+ EFBD 1F 30 04 08                          DB $1F, $30, $04, $08
  80+ EFC1 1F 40 08 0C                          DB $1F, $40, $08, $0C
  81+ EFC5 1F 51 0C 10                          DB $1F, $51, $0C, $10
  82+ EFC9 1F 61 00 10                          DB $1F, $61, $00, $10
  83+ EFCD 1F 62 00 14                          DB $1F, $62, $00, $14
  84+ EFD1 1F 82 14 04                          DB $1F, $82, $14, $04
  85+ EFD5 1F 83 04 18                          DB $1F, $83, $04, $18
  86+ EFD9 1F 73 08 18                          DB $1F, $73, $08, $18
  87+ EFDD 1F 74 08 1C                          DB $1F, $74, $08, $1C
  88+ EFE1 1F 54 0C 1C                          DB $1F, $54, $0C, $1C
  89+ EFE5 1F DA 20 2C                          DB $1F, $DA, $20, $2C
  90+ EFE9 1F DB 20 24                          DB $1F, $DB, $20, $24
  91+ EFED 1F DC 24 28                          DB $1F, $DC, $24, $28
  92+ EFF1 1F D9 28 2C                          DB $1F, $D9, $28, $2C
  93+ EFF5 1F A5 10 2C                          DB $1F, $A5, $10, $2C
  94+ EFF9 1F A6 10 20                          DB $1F, $A6, $10, $20
  95+ EFFD 1F B6 14 20                          DB $1F, $B6, $14, $20
  96+ F001 1F B8 14 24                          DB $1F, $B8, $14, $24
  97+ F005 1F C8 18 24                          DB $1F, $C8, $18, $24
  98+ F009 1F C7 18 28                          DB $1F, $C7, $18, $28
  99+ F00D 1F 97 1C 28                          DB $1F, $97, $1C, $28
 100+ F011 1F 95 1C 2C                          DB $1F, $95, $1C, $2C
 101+ F015 1E 00 30 34                          DB $1E, $00, $30, $34
 102+ F019 1E 00 34 38                          DB $1E, $00, $34, $38
 103+ F01D 1E 00 38 3C                          DB $1E, $00, $38, $3C
 104+ F021 1E 00 3C 30                          DB $1E, $00, $3C, $30
 105+ F025              CoriolisEdgesSize:      equ $ - CoriolisEdges
 106+ F025              CoriolisEdgesCnt:       equ CoriolisEdgesSize/4
 107+ F025              CoriolisNormals:	    ; DB $1F, $6B, $00, $00
 108+ F025                                      ; DB $5F, $00, $6B, $00
 109+ F025                                      ; DB $1F, $6B, $00, $00
 110+ F025                                      ; DB $9F, $6B, $00, $00
 111+ F025                                      ; DB $3F, $00, $00, $6B
 112+ F025                                      ; DB $1F, $00, $6B, $00
 113+ F025
 114+ F025 1F 00 00 A0                          DB $1F, $00, $00, $A0
 115+ F029 5F 6B 6B 6B                          DB $5F, $6B, $6B, $6B
 116+ F02D 1F 6B 6B 6B                          DB $1F, $6B, $6B, $6B
 117+ F031 9F 6B 6B 6B                          DB $9F, $6B, $6B, $6B
 118+ F035 DF 6B 6B 6B                          DB $DF, $6B, $6B, $6B
 119+ F039 5F 00 A0 00                          DB $5F, $00, $A0, $00
 120+ F03D 1F A0 00 00                          DB $1F, $A0, $00, $00
 121+ F041 9F A0 00 00                          DB $9F, $A0, $00, $00
 122+ F045 1F 00 A0 00                          DB $1F, $00, $A0, $00
 123+ F049 FF 6B 6B 6B                          DB $FF, $6B, $6B, $6B
 124+ F04D 7F 6B 6B 6B                          DB $7F, $6B, $6B, $6B
 125+ F051 3F 6B 6B 6B                          DB $3F, $6B, $6B, $6B
 126+ F055 BF 6B 6B 6B                          DB $BF, $6B, $6B, $6B
 127+ F059 3F 00 00 A0                          DB $3F, $00, $00, $A0
 128+ F05D              CoriolisNormalsSize:    equ $ - CoriolisNormals
 129+ F05D              CoriolisLen:            equ $ - Coriolis
 130+ F05D
# file closed: ../../Data/ships/Coriolis.asm
 928  F05D                                      include "../../Data/ships/Cougar.asm"
# file opened: ../../Data/ships/Cougar.asm
   1+ F05D 03           Cougar:	                DB $03                         ; Number of cargo canisters released when destroyed
   2+ F05E 24 13                                DW $1324                       ; Ship's targetable area LoHi
   3+ F060 EE F0                                DW CougarEdges                 ; Edge Data
   4+ F062 64                                   DB CougarEdgesSize             ; Size of Edge Data
   5+ F063 00                                   DB $00                         ; Gun Vertex Byte offset
   6+ F064 2A                                   DB $2A                         ; Explosion Count
   7+ F065 13                                   DB CougarVertSize /6           ; Vertex Count /6
   8+ F066 72                                   DB CougarVertSize              ; Vertex Count
   9+ F067 19                                   DB CougarEdgesCnt              ; Edges Count
  10+ F068 00 00                                DW $0000                       ; Bounty LoHi
  11+ F06A 18                                   DB CougarNormalsSize           ; Face (Normal) Count
  12+ F06B 22                                   DB $22                         ; Range when it turns to a dot
  13+ F06C FC                                   DB $FC                         ; Energy Max
  14+ F06D 28                                   DB $28                         ; Speed Max
  15+ F06E 52 F1                                DW CougarNormals               ; Normals
  16+ F070 02                                   DB $02                         ; Q scaling
  17+ F071 34                                   DB $30 | ShipMissiles4         ; Laser power and Nbr Missiles
  18+ F072 7C F0                                DW CougarVertices              ; Verticles Address
  19+ F074 00                                   DB ShipTypeNormal              ; Ship Type
  20+ F075 00                                   DB 0                           ; NewB Tactics
  21+ F076 80                                   DB ShipCanAnger                ; AI Flags
  22+ F077 B0                                   DB $B0                         ; chance of ECM module
  23+ F078 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ F079 00 00                                DW $0000                            ; no solid data
  25+ F07B 00                                   DB $00                              ; no solid data
  26+ F07C
  27+ F07C 00 05 43 1F  CougarVertices:	        DB $00, $05, $43, $1F, $02, $44
  27+ F080 02 44
  28+ F082 14 00 28 9F                          DB $14, $00, $28, $9F, $01, $22
  28+ F086 01 22
  29+ F088 28 00 28 BF                          DB $28, $00, $28, $BF, $01, $55
  29+ F08C 01 55
  30+ F08E 00 0E 28 3E                          DB $00, $0E, $28, $3E, $04, $55
  30+ F092 04 55
  31+ F094 00 0E 28 7E                          DB $00, $0E, $28, $7E, $12, $35
  31+ F098 12 35
  32+ F09A 14 00 28 1F                          DB $14, $00, $28, $1F, $23, $44
  32+ F09E 23 44
  33+ F0A0 28 00 28 3F                          DB $28, $00, $28, $3F, $34, $55
  33+ F0A4 34 55
  34+ F0A6 24 00 38 9F                          DB $24, $00, $38, $9F, $01, $11
  34+ F0AA 01 11
  35+ F0AC 3C 00 14 BF                          DB $3C, $00, $14, $BF, $01, $11
  35+ F0B0 01 11
  36+ F0B2 24 00 38 1F                          DB $24, $00, $38, $1F, $34, $44
  36+ F0B6 34 44
  37+ F0B8 3C 00 14 3F                          DB $3C, $00, $14, $3F, $34, $44
  37+ F0BC 34 44
  38+ F0BE 00 07 23 12                          DB $00, $07, $23, $12, $00, $44
  38+ F0C2 00 44
  39+ F0C4 00 08 19 14                          DB $00, $08, $19, $14, $00, $44
  39+ F0C8 00 44
  40+ F0CA 0C 02 2D 94                          DB $0C, $02, $2D, $94, $00, $00
  40+ F0CE 00 00
  41+ F0D0 0C 02 2D 14                          DB $0C, $02, $2D, $14, $44, $44
  41+ F0D4 44 44
  42+ F0D6 0A 06 28 B4                          DB $0A, $06, $28, $B4, $55, $55
  42+ F0DA 55 55
  43+ F0DC 0A 06 28 F4                          DB $0A, $06, $28, $F4, $55, $55
  43+ F0E0 55 55
  44+ F0E2 0A 06 28 74                          DB $0A, $06, $28, $74, $55, $55
  44+ F0E6 55 55
  45+ F0E8 0A 06 28 34                          DB $0A, $06, $28, $34, $55, $55
  45+ F0EC 55 55
  46+ F0EE              CougarVertSize:         equ $ - CougarVertices
  47+ F0EE 1F 02 00 04  CougarEdges:	        DB $1F, $02, $00, $04
  48+ F0F2 1F 01 04 1C                          DB $1F, $01, $04, $1C
  49+ F0F6 1F 01 1C 20                          DB $1F, $01, $1C, $20
  50+ F0FA 1F 01 20 08                          DB $1F, $01, $20, $08
  51+ F0FE 1E 05 08 0C                          DB $1E, $05, $08, $0C
  52+ F102 1E 45 0C 18                          DB $1E, $45, $0C, $18
  53+ F106 1E 15 08 10                          DB $1E, $15, $08, $10
  54+ F10A 1E 35 10 18                          DB $1E, $35, $10, $18
  55+ F10E 1F 34 18 28                          DB $1F, $34, $18, $28
  56+ F112 1F 34 28 24                          DB $1F, $34, $28, $24
  57+ F116 1F 34 24 14                          DB $1F, $34, $24, $14
  58+ F11A 1F 24 14 00                          DB $1F, $24, $14, $00
  59+ F11E 1B 04 00 0C                          DB $1B, $04, $00, $0C
  60+ F122 1B 12 04 10                          DB $1B, $12, $04, $10
  61+ F126 1B 23 14 10                          DB $1B, $23, $14, $10
  62+ F12A 1A 01 04 08                          DB $1A, $01, $04, $08
  63+ F12E 1A 34 14 18                          DB $1A, $34, $14, $18
  64+ F132 14 00 30 34                          DB $14, $00, $30, $34
  65+ F136 12 00 34 2C                          DB $12, $00, $34, $2C
  66+ F13A 12 44 2C 38                          DB $12, $44, $2C, $38
  67+ F13E 14 44 38 30                          DB $14, $44, $38, $30
  68+ F142 12 55 3C 40                          DB $12, $55, $3C, $40
  69+ F146 14 55 40 48                          DB $14, $55, $40, $48
  70+ F14A 12 55 48 44                          DB $12, $55, $48, $44
  71+ F14E 14 55 44 3C                          DB $14, $55, $44, $3C
  72+ F152              CougarEdgesSize:        equ $ - CougarEdges
  73+ F152              CougarEdgesCnt:         equ CougarEdgesSize/4
  74+ F152 9F 10 2E 04  CougarNormals:	        DB $9F, $10, $2E, $04
  75+ F156 DF 10 2E 04                          DB $DF, $10, $2E, $04
  76+ F15A 5F 00 1B 05                          DB $5F, $00, $1B, $05
  77+ F15E 5F 10 2E 04                          DB $5F, $10, $2E, $04
  78+ F162 1F 10 2E 04                          DB $1F, $10, $2E, $04
  79+ F166 3E 00 00 A0                          DB $3E, $00, $00, $A0
  80+ F16A              CougarNormalsSize:      equ $ - CougarNormals
  81+ F16A              CougarLen:              equ $ - Cougar
  82+ F16A
# file closed: ../../Data/ships/Cougar.asm
 929  F16A                                      include "../../Data/ships/Dodo.asm"
# file opened: ../../Data/ships/Dodo.asm
   1+ F16A 00           Dodo:	                DB $00                        ; Number of cargo canisters released when destroyed
   2+ F16B 90 7E                                DW $7E90                      ; Ship's targetable area LoHi
   3+ F16D 19 F2                                DW DodoEdges                  ; Edge Data
   4+ F16F 88                                   DB DodoEdgesSize              ; Size of Edge Data
   5+ F170 00                                   DB $00                        ; Gun Vertex Byte offset
   6+ F171 36                                   DB $36                        ; Explosion Count
   7+ F172 18                                   DB DodoVertSize /6            ; Vertex Count /6
   8+ F173 90                                   DB DodoVertSize               ; Vertex Count
   9+ F174 22                                   DB DodoEdgesCnt               ; Edges Count
  10+ F175 00 00                                DW $0000                      ; Bounty LoHi
  11+ F177 30                                   DB DodoNormalsSize            ; Face (Normal) Count
  12+ F178 7D                                   DB $7D                        ; Range when it turns to a dot
  13+ F179 F0                                   DB $F0                        ; Energy Max
  14+ F17A 00                                   DB $00                        ; Speed Max
  15+ F17B A1 F2                                DW DodoNormals                ; Normals
  16+ F17D 00                                   DB $00                        ; Q scaling
  17+ F17E 00                                   DB $00                        ; Laser power and Nbr Missiles
  18+ F17F 89 F1                                DW DodoVertices               ; Verticles Address
  19+ F181 02                                   DB ShipTypeStation            ; Ship Type
  20+ F182 00                                   DB 0                          ; NewB Tactics
  21+ F183 00                                   DB 0                          ; AI Flags
  22+ F184 FF                                   DB $FF                        ; chance of ECM module
  23+ F185 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ F186 00 00                                DW $0000                            ; no solid data
  25+ F188 00                                   DB $00                              ; no solid data
  26+ F189
  27+ F189 00 96 C4 1F  DodoVertices:	        DB $00, $96, $C4, $1F, $01, $55
  27+ F18D 01 55
  28+ F18F 8F 2E C4 1F                          DB $8F, $2E, $C4, $1F, $01, $22
  28+ F193 01 22
  29+ F195 58 79 C4 5F                          DB $58, $79, $C4, $5F, $02, $33
  29+ F199 02 33
  30+ F19B 58 79 C4 DF                          DB $58, $79, $C4, $DF, $03, $44
  30+ F19F 03 44
  31+ F1A1 8F 2E C4 9F                          DB $8F, $2E, $C4, $9F, $04, $55
  31+ F1A5 04 55
  32+ F1A7 00 F3 2E 1F                          DB $00, $F3, $2E, $1F, $15, $66
  32+ F1AB 15 66
  33+ F1AD E7 4B 2E 1F                          DB $E7, $4B, $2E, $1F, $12, $77
  33+ F1B1 12 77
  34+ F1B3 8F C4 2E 5F                          DB $8F, $C4, $2E, $5F, $23, $88
  34+ F1B7 23 88
  35+ F1B9 8F C4 2E DF                          DB $8F, $C4, $2E, $DF, $34, $99
  35+ F1BD 34 99
  36+ F1BF E7 4B 2E 9F                          DB $E7, $4B, $2E, $9F, $45, $AA
  36+ F1C3 45 AA
  37+ F1C5 8F C4 2E 3F                          DB $8F, $C4, $2E, $3F, $16, $77
  37+ F1C9 16 77
  38+ F1CB E7 4B 2E 7F                          DB $E7, $4B, $2E, $7F, $27, $88
  38+ F1CF 27 88
  39+ F1D1 00 F3 2E 7F                          DB $00, $F3, $2E, $7F, $38, $99
  39+ F1D5 38 99
  40+ F1D7 E7 4B 2E FF                          DB $E7, $4B, $2E, $FF, $49, $AA
  40+ F1DB 49 AA
  41+ F1DD 8F C4 2E BF                          DB $8F, $C4, $2E, $BF, $56, $AA
  41+ F1E1 56 AA
  42+ F1E3 58 79 C4 3F                          DB $58, $79, $C4, $3F, $67, $BB
  42+ F1E7 67 BB
  43+ F1E9 8F 2E C4 7F                          DB $8F, $2E, $C4, $7F, $78, $BB
  43+ F1ED 78 BB
  44+ F1EF 00 96 C4 7F                          DB $00, $96, $C4, $7F, $89, $BB
  44+ F1F3 89 BB
  45+ F1F5 8F 2E C4 FF                          DB $8F, $2E, $C4, $FF, $9A, $BB
  45+ F1F9 9A BB
  46+ F1FB 58 79 C4 BF                          DB $58, $79, $C4, $BF, $6A, $BB
  46+ F1FF 6A BB
  47+ F201 10 20 C4 9E                          DB $10, $20, $C4, $9E, $00, $00
  47+ F205 00 00
  48+ F207 10 20 C4 DE                          DB $10, $20, $C4, $DE, $00, $00
  48+ F20B 00 00
  49+ F20D 10 20 C4 17                          DB $10, $20, $C4, $17, $00, $00
  49+ F211 00 00
  50+ F213 10 20 C4 57                          DB $10, $20, $C4, $57, $00, $00
  50+ F217 00 00
  51+ F219              DodoVertSize:           equ $ - DodoVertices
  52+ F219 1F 01 00 04  DodoEdges:	            DB $1F, $01, $00, $04
  53+ F21D 1F 02 04 08                          DB $1F, $02, $04, $08
  54+ F221 1F 03 08 0C                          DB $1F, $03, $08, $0C
  55+ F225 1F 04 0C 10                          DB $1F, $04, $0C, $10
  56+ F229 1F 05 10 00                          DB $1F, $05, $10, $00
  57+ F22D 1F 16 14 28                          DB $1F, $16, $14, $28
  58+ F231 1F 17 28 18                          DB $1F, $17, $28, $18
  59+ F235 1F 27 18 2C                          DB $1F, $27, $18, $2C
  60+ F239 1F 28 2C 1C                          DB $1F, $28, $2C, $1C
  61+ F23D 1F 38 1C 30                          DB $1F, $38, $1C, $30
  62+ F241 1F 39 30 20                          DB $1F, $39, $30, $20
  63+ F245 1F 49 20 34                          DB $1F, $49, $20, $34
  64+ F249 1F 4A 34 24                          DB $1F, $4A, $34, $24
  65+ F24D 1F 5A 24 38                          DB $1F, $5A, $24, $38
  66+ F251 1F 56 38 14                          DB $1F, $56, $38, $14
  67+ F255 1F 7B 3C 40                          DB $1F, $7B, $3C, $40
  68+ F259 1F 8B 40 44                          DB $1F, $8B, $40, $44
  69+ F25D 1F 9B 44 48                          DB $1F, $9B, $44, $48
  70+ F261 1F AB 48 4C                          DB $1F, $AB, $48, $4C
  71+ F265 1F 6B 4C 3C                          DB $1F, $6B, $4C, $3C
  72+ F269 1F 15 00 14                          DB $1F, $15, $00, $14
  73+ F26D 1F 12 04 18                          DB $1F, $12, $04, $18
  74+ F271 1F 23 08 1C                          DB $1F, $23, $08, $1C
  75+ F275 1F 34 0C 20                          DB $1F, $34, $0C, $20
  76+ F279 1F 45 10 24                          DB $1F, $45, $10, $24
  77+ F27D 1F 67 28 3C                          DB $1F, $67, $28, $3C
  78+ F281 1F 78 2C 40                          DB $1F, $78, $2C, $40
  79+ F285 1F 89 30 44                          DB $1F, $89, $30, $44
  80+ F289 1F 9A 34 48                          DB $1F, $9A, $34, $48
  81+ F28D 1F 6A 38 4C                          DB $1F, $6A, $38, $4C
  82+ F291 1E 00 50 54                          DB $1E, $00, $50, $54
  83+ F295 14 00 54 5C                          DB $14, $00, $54, $5C
  84+ F299 17 00 5C 58                          DB $17, $00, $5C, $58
  85+ F29D 14 00 58 50                          DB $14, $00, $58, $50
  86+ F2A1              DodoEdgesSize:          equ $ - DodoEdges
  87+ F2A1              DodoEdgesCnt:           equ DodoEdgesSize/4
  88+ F2A1 1F 00 00 C4  DodoNormals:	        DB $1F, $00, $00, $C4
  89+ F2A5 1F 67 8E 58                          DB $1F, $67, $8E, $58
  90+ F2A9 5F A9 37 59                          DB $5F, $A9, $37, $59
  91+ F2AD 5F 00 B0 58                          DB $5F, $00, $B0, $58
  92+ F2B1 DF A9 37 59                          DB $DF, $A9, $37, $59
  93+ F2B5 9F 67 8E 58                          DB $9F, $67, $8E, $58
  94+ F2B9 3F 00 B0 58                          DB $3F, $00, $B0, $58
  95+ F2BD 3F A9 37 59                          DB $3F, $A9, $37, $59
  96+ F2C1 7F 67 8E 58                          DB $7F, $67, $8E, $58
  97+ F2C5 FF 67 8E 58                          DB $FF, $67, $8E, $58
  98+ F2C9 BF A9 37 59                          DB $BF, $A9, $37, $59
  99+ F2CD 3F 00 00 C4                          DB $3F, $00, $00, $C4
 100+ F2D1              DodoNormalsSize:        equ $ - DodoNormals
 101+ F2D1              DodoLen:                equ $ - Dodo
 102+ F2D1
# file closed: ../../Data/ships/Dodo.asm
 930  F2D1
 931  F2D1
 932  F2D1                  DISPLAY "Bank ",BankShipModels1," - Bytes free ",/D, $2000 - ($-ShipModelsAddr), " - BankShipModels1"
 933  F2D1              ; Bank 70  ------------------------------------------------------------------------------------------------------------------------
 934  F2D1                                  SLOT    UniverseBankAddr
 935  F2D1                                  PAGE    BankUNIVDATA0
 936  F2D1                                  ORG	    UniverseBankAddr,BankUNIVDATA0
 937  C000                                  INCLUDE "../../Tests/3DTest/univ_ship_data.asm"
# file opened: ../../Tests/3DTest/univ_ship_data.asm
   1+ C000              ;    DEFINE DEBUGMISSILELAUNCH 1
   2+ C000              ;    DEFINE PLOTPOINTSONLY 1
   3+ C000              ;   DEFINE OVERLAYNODES 1
   4+ C000              ; In  flight ship data tables
   5+ C000              ; In  flight ship data tables
   6+ C000              ; There can be upto &12 objects in flight.
   7+ C000              ; To avoid hassle of memory heap managment, the free list
   8+ C000              ; will correspond to a memory bank offset so data will be held in
   9+ C000              ; 1 bank per universe object. Its a waste of a lot of memory but really
  10+ C000              ; 1 bank per universe object. Its a waste of a lot of memory but really
  11+ C000              ; simple that way. Each bank will be 8K and swapped on 8K slot 7 $E000 to $FFFF
  12+ C000              ; This means each gets its own line list, inwork etc
  13+ C000
  14+ C000              ; "Runtime Ship Data paged into in Bank 7"
  15+ C000              ;                       1234567890123456
  16+ C000 55 6E 69 76  StartOfUniv:        DB "Universe PG"
  16+ C004 65 72 73 65
  16+ C008 20 50 47
  17+ C00B 58           StartOfUnivN:       DB "X"
  18+ C00C 00 00        StartOfUnivPad:     DS 2
  19+ C00E 00           StartOfUnivM:       DB 0
  20+ C00F 00           StartOfUnivT        DB 0
  21+ C010 00 00 00...  StartOfUnivName     DS 16
  22+ C020              ;-Camera Position of Ship----------------------------------------------------------------------------------------------------------
  23+ C020                                     INCLUDE "../../Universe/Ships/AIRuntimeData.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/AIRuntimeData.asm
   1++C020              ;-Camera Position of Ship----------------------------------------------------------------------------------------------------------
   2++C020              ;--NOTE POSTITION AND MATRIX are loaded by a single LDIR in cases so must be contiguous
   3++C020              StartOfShipRuntimeData      EQU $
   4++C020 00           UBnKxlo                     DB  0                       ; INWK+0
   5++C021 00           UBnKxhi                     DB  0                       ; there are hi medium low as some times these are 24 bit
   6++C022 00           UBnKxsgn                    DB  0                       ; INWK+2
   7++C023 00           UBnKylo                     DB  0                       ; INWK+3 \ ylo
   8++C024 00           UBnKyhi                     DB  0                       ; INWK+4 \ yHi
   9++C025 00           UBnKysgn                    DB  0                       ; INWK +5
  10++C026 00           UBnKzlo                     DB  0                       ; INWK +6
  11++C027 00           UBnKzhi                     DB  0                       ; INWK +7
  12++C028 00           UBnKzsgn                    DB  0                       ; INWK +8
  13++C029              ;-Rotation Matrix of Ship----------------------------------------------------------------------------------------------------------
  14++C029              ; Rotation data is stored as lohi, but only 15 bits with 16th bit being  a sign bit. Note this is NOT 2'c compliment
  15++C029              ; Note they seem to have to be after camera position not quite found why yet, can only assume it does an iy or ix indexed copy? Bu oddly does not affect space station.
  16++C029 00 00        UBnkrotmatSidevX            DW  0                       ; INWK +21
  17++C02B              UBnkrotmatSidev             equ UBnkrotmatSidevX
  18++C02B 00 00        UBnkrotmatSidevY            DW  0                       ; INWK +23
  19++C02D 00 00        UBnkrotmatSidevZ            DW  0                       ; INWK +25
  20++C02F 00 00        UBnkrotmatRoofvX            DW  0                       ; INWK +15
  21++C031              UBnkrotmatRoofv             equ UBnkrotmatRoofvX
  22++C031 00 00        UBnkrotmatRoofvY            DW  0                       ; INWK +17
  23++C033 00 00        UBnkrotmatRoofvZ            DW  0                       ; INWK +19
  24++C035 00 00        UBnkrotmatNosevX            DW  0                       ; INWK +9
  25++C037              UBnkrotmatNosev             EQU UBnkrotmatNosevX
  26++C037 00 00        UBnkrotmatNosevY            DW  0                       ; INWK +11
  27++C039 00 00        UBnkrotmatNosevZ            DW  0                       ; INWK +13
  28++C03B              ; -- Note these must be here for initialise blast as it does a 12 byte ldir
  29++C03B              ; . Note missile explosion will have to have logic to cause linger if a blast is to be enqued
  30++C03B 00           UBnKMissileBlastRange:      DB  0                       ; copied in when setting up a missile
  31++C03C 00           UBnKMissileBlastDamage:     DB  0                       ; copied in when setting up a missile
  32++C03D 00           UBnKMissileDetonateRange:   DB  0                       ; copied in when setting up a missile, allows for proximity missiles
  33++C03E 00           UBnKMissileDetonateDamage:  DB  0                       ; copied in when setting up a missile
  34++C03F              ; -- Metadata for ship to help with bank managment
  35++C03F              UBnKStartOfRuntimeData:
  36++C03F 00           UBnKSlotNumber              DB  0
  37++C040 00           UbnKShipUnivBankNbr         DB  0                       ; Present ship universe bank number
  38++C041 00           UBnkShipModelBank           DB  0                       ; Bank nbr ship was from
  39++C042 00           UBnKShipModelNbr            DB  0                       ; Ship Id with in the bank
  40++C043 00           UBnKShipModelId             DB  0                       ; Absolute ship id
  41++C044              ; -- Ship AI data
  42++C044 00           UBnKMissleHitToProcess      DB  0                       ; This is used for enquing missle blasts as we can only do one missile at a time, could make it multi but neeed to smooth CPU usage
  43++C045 00           UBnKMissileTarget           DB  0                       ; This is the ship slot number for the target from 0 to n if the missile is not hostile to us, if the target is $FF then its us
  44++C046 00           UBnKSpeed                   DB  0                       ; INWK +27
  45++C047 00           UBnKAccel                   DB  0                       ; INWK +28
  46++C048 00           UBnKRotXCounter             DB  0                       ; INWK +29
  47++C049 00           UBnKRotZCounter             DB  0                       ; INWK +30
  48++C04A 00           UBnKRAT                     DB  0                       ; temporary for rotation magnitude or roll counter, for debugging state
  49++C04B 00           UBnKRAT2                    DB  0                       ; temporary for rotation threshold
  50++C04C 00           UBnKCNT                     DB  0                       ; temp for calculating roll and pitch
  51++C04D 00           UBnKCNT2                    DB  0                       ; roll threshold, max angle boynd ship will slow down
  52++C04E 00           univRAT                     DB  0               ; 99
  53++C04F 00           univRAT2                    DB  0               ; 9A
  54++C050 00           univRAT2Val                 DB  0               ; 9A
  55++C051 00           UBnKexplDsp                 DB  0                       ; INWK +31 clear exploding/display state|missiles
  56++C052 00           UBnkDrawAllFaces            DB  0
  57++C053 00           UBnKShipAggression          DB  0                       ; calculated agression factor
  58++C054 00           UBnkaiatkecm                DB  0                       ; INWK +32 ai_attack_univ_ecm i.e. AI type
  59++C055 00           UBnKSpawnObject             DB  0
  60++C056 00           UBnkCam0yLo                 DB  0                       ; INWK +33 ????
  61++C057 00           UBnkCam0yHi                 DB  0                       ; INWK +34?????
  62++C058 00           UBnKEnergy                  DB  0                       ; INWK +35
  63++C059 00           UBnKECMCountDown            DB  0                       ; counts down ECM usage if activated reducing energy too in update loop
  64++C05A 00           UBnKECMFitted               DB  0                       ; Does ship have ECM, true false
  65++C05B 00           UBnKLaserPower              DB  0                       ; Type of laser fitted
  66++C05C 00           UBnKMissilesLeft            DB  0
  67++C05D 00           UBnKFighterShipId           DB  0                       ; computed ship Id for any carriers
  68++C05E 00           UBnKFightersLeft            DB  0                       ; the number of ships left in hanger, 255 = infinite
  69++C05F 00           UBnKCloudCounter            DB  0                       ; cloud pixels
  70++C060 00           UBnKCloudRadius             DB  0                       ; cloud pixels
  71++C061              UBnKRuntimeSize             EQU $-UBnKStartOfRuntimeData
  72++C061              ; Flags work as follows:
  73++C061              ; UBnKSpawnObject - signals on death to spawn cargo items
  74++C061              ; 0 -                   Spawn Cargo 1
  75++C061              ; 1 -                   Spawn Cargo 2
  76++C061              ; 2 -                   Spawn Cargo 3
  77++C061              ; 3 -                   Spawn Cargo 4
  78++C061              ; 4 -                   Spawn Alloy 1
  79++C061              ; 5 -                   Spawn Alloy 2
  80++C061              ; 6 -                   Spawn Alloy 3
  81++C061              ; 7 -                   Spawn Alloy 4
  82++C061
  83++C061              ; UBnkaiatkecm
  84++C061              ; Bit	                Description
  85++C061              ; 7 -                   AI Enabled Flag
  86++C061              ; 6 -                   Ship Visible = ShipOnScreen/NotCloaked (cleared or set by check visible or cloaking override)
  87++C061              ; 5 -                   Ship is exploding if set, note if its a missile and one already equeued this will have to linger
  88++C061              ;                       linger can be done by not erasing ship unit missile equeue handled
  89++C061              ; 4 -                   Ship marked as exploded, cleared once aknowledged then bit 5 takes over and UBnKCloudCounter
  90++C061              ; 3 -                   Display state - Plot as a Dot
  91++C061              ; 2 -                   Nbr of Missiles bit 2
  92++C061              ; 1 -                   Nbr of Missiles bit 1
  93++C061              ; 0 -                   ECM present flag
  94++C061              ; ShipNewBitsAddr (in blueprint)
  95++C061              ;Bit	                Description
  96++C061              ;#0	Trader flag         * 0 = not a trader  * 1 = trader
  97++C061              ;                       80% of traders are peaceful and mind their own business plying their trade between the planet and space station, but 20% of them moonlight as bounty hunters (see bit #1)
  98++C061              ;                       Ships that are traders: Escape pod, Shuttle, Transporter, Anaconda, Rock hermit, Worm
  99++C061              ;#1 Bounty hunter flag  * 0 = not a bounty hunter* 1 = bounty hunter
 100++C061              ;                       If we are a fugitive or a serious offender and we bump into a bounty hunter, they will become hostile and attack us (see bit #2)
 101++C061              ;                       Ships that are bounty hunters: Viper, Fer-de-lance
 102++C061              ;#2	Hostile flag        * 0 = not hostile  * 1 = hostile
 103++C061              ;                       Hostile ships will attack us on sight; there are quite a few of them
 104++C061              ;                       Ships that are hostile: Sidewinder, Mamba, Krait, Adder, Gecko, Cobra Mk I, Worm, Cobra Mk III, Asp Mk II, Python (pirate), Moray, Thargoid, Thargon, Constrictor
 105++C061              ;#3	Pirate flag         * 0 = not a pirate * 1 = pirate
 106++C061              ;                       Hostile pirates will attack us on sight, but once we get inside the space station safe zone, they will stop
 107++C061              ;                       Ships that are pirates: Sidewinder, Mamba, Krait, Adder, Gecko, Cobra Mk I, Cobra Mk III, Asp Mk II, Python (pirate), Moray, Thargoid
 108++C061              ;#4	Docking flag        * 0 = not docking * 1 = docking
 109++C061              ;                       Traders with their docking flag set fly towards the space station to try to dock, otherwise they aim for the planet
 110++C061              ;                       This flag is randomly set for traders when they are spawned
 111++C061              ;                       Ships that can be docking: Escape pod, Shuttle, Transporter, Anaconda, Rock hermit, Worm
 112++C061              ;#5	Innocent bystander  * 0 = normal * 1 = innocent bystander
 113++C061              ;                       If we attack an innocent ship within the space station safe zone, then the station will get angry with us and start spawning cops
 114++C061              ;                       Ships that are innocent bystanders: Shuttle, Transporter, Cobra Mk III, Python, Boa, Anaconda, Rock hermit, Cougar
 115++C061              ;#6	Cop flag            * 0 = not a cop * 1 = cop
 116++C061              ;                       If we destroy a cop, then we instantly become a fugitive (the Transporter isn't actually a cop, but it's clearly under police protection)
 117++C061              ;                       Ships that are cops: Viper, Transporter
 118++C061              ;#7	Scooped, docked, escape pod flag
 119++C061              ;                       For spawned ships, this flag indicates that the ship been scooped or has docked (bit 7 is always clear on spawning)
 120++C061              ;                       For blueprints, this flag indicates whether the ship type has an escape pod fitted, so it can launch it when in dire straits
 121++C061              ;                       Ships that have escape pods: Cobra Mk III, Python, Boa, Anaconda, Rock hermit, Viper, Mamba, Krait, Adder, Cobra Mk I, Cobra Mk III (pirate), Asp Mk II, Python (pirate), Fer-de-lance
 122++C061
# file closed: ../../Tests/3DTest/../../Universe/Ships/AIRuntimeData.asm
  24+ C061                                      INCLUDE "../../Universe/Ships/XX16Vars.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/XX16Vars.asm
   1++C061              ;-- XX16 --------------------------------------------------------------------------------------------------------------------------
   2++C061 00 00        UBnkTransmatSidevX          DW  0               ; XX16+0
   3++C063              UBnkTransmatSidev           EQU UBnkTransmatSidevX
   4++C063 00 00        UBnkTransmatSidevY          DW 0                ; XX16+2
   5++C065 00 00        UBnkTransmatSidevZ          DW 0                ; XX16+2
   6++C067 00 00        UBnkTransmatRoofvX          DW 0
   7++C069              UBnkTransmatRoofv           EQU UBnkTransmatRoofvX
   8++C069 00 00        UBnkTransmatRoofvY          DW 0                ; XX16+2
   9++C06B 00 00        UBnkTransmatRoofvZ          DW 0                ; XX16+2
  10++C06D 00 00        UBnkTransmatNosevX          DW 0
  11++C06F              UBnkTransmatNosev           EQU UBnkTransmatNosevX
  12++C06F 00 00        UBnkTransmatNosevY          DW 0                ; XX16+2
  13++C071 00 00        UBnkTransmatNosevZ          DW 0                ; XX16+2
  14++C073 00 00        UbnkTransmatTransX          DW 0
  15++C075 00 00        UbnkTransmatTransY          DW 0
  16++C077 00 00        UbnkTransmatTransZ          DW 0
  17++C079              XX16                        equ UBnkTransmatSidev
  18++C079              ;-- XX16Inv --------------------------------------------------------------------------------------------------------------------------
  19++C079 00 00        UbnkTransInvRow0x0          DW 0
  20++C07B 00 00        UbnkTransInvRow0x1          DW 0
  21++C07D 00 00        UbnkTransInvRow0x2          DW 0
  22++C07F 00 00        UbnkTransInvRow0x3          DW 0
  23++C081 00 00        UbnkTransInvRow1y0          DW 0
  24++C083 00 00        UbnkTransInvRow1y1          DW 0
  25++C085 00 00        UbnkTransInvRow1y2          DW 0
  26++C087 00 00        UbnkTransInvRow1y3          DW 0
  27++C089 00 00        UbnkTransInvRow2z0          DW 0
  28++C08B 00 00        UbnkTransInvRow2z1          DW 0
  29++C08D 00 00        UbnkTransInvRow2z2          DW 0
  30++C08F 00 00        UbnkTransInvRow2z3          DW 0
  31++C091
  32++C091              XX16Inv             equ UbnkTransInvRow0x0
  33++C091
# file closed: ../../Tests/3DTest/../../Universe/Ships/XX16Vars.asm
  25+ C091                                      INCLUDE "../../Universe/Ships/XX25Vars.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/XX25Vars.asm
   1++C091              ;-- XX25 --------------------------------------------------------------------------------------------------------------------------
   2++C091 00           UbnkProjxLo                 DB  0
   3++C092 00           UbnkProjxHi                 DB  0
   4++C093 00           UbnkProjxSgn                DB  0
   5++C094              UbnkProjx                   EQU UbnkProjxLo
   6++C094 00           UbnkProjyLo                 DB  0
   7++C095 00           UbnkProjyHi                 DB  0
   8++C096 00           UbnkProjySgn                DB  0
   9++C097              UbnkProjy                   EQU UbnkProjyLo
  10++C097 00           UbnkProjzLo                 DB  0
  11++C098 00           UbnkProjzHi                 DB  0
  12++C099 00           UbnkProjzSgn                DB  0
  13++C09A              UbnkProjz                   EQU UbnkProjzLo
  14++C09A              XX25                        EQU UbnkProjxLo
  15++C09A
# file closed: ../../Tests/3DTest/../../Universe/Ships/XX25Vars.asm
  26+ C09A                                      INCLUDE "../../Universe/Ships/XX18Vars.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/XX18Vars.asm
   1++C09A              ;-- XX18 --------------------------------------------------------------------------------------------------------------------------
   2++C09A 00           UBnkDrawCam0xLo             DB  0               ; XX18+0
   3++C09B 00           UBnkDrawCam0xHi             DB  0               ; XX18+1
   4++C09C 00           UBnkDrawCam0xSgn            DB  0               ; XX18+2
   5++C09D              UBnkDrawCam0x               equ UBnkDrawCam0xLo
   6++C09D 00           UBnkDrawCam0yLo             DB  0               ; XX18+3
   7++C09E 00           UBnkDrawCam0yHi             DB  0               ; XX18+4
   8++C09F 00           UBnkDrawCam0ySgn            DB  0               ; XX18+5
   9++C0A0              UBnkDrawCam0y               equ UBnkDrawCam0yLo
  10++C0A0 00           UBnkDrawCam0zLo             DB  0               ; XX18+6
  11++C0A1 00           UBnkDrawCam0zHi             DB  0               ; XX18+7
  12++C0A2 00           UBnkDrawCam0zSgn            DB  0               ; XX18+8
  13++C0A3              UBnkDrawCam0z               equ UBnkDrawCam0zLo
  14++C0A3              XX18                        equ UBnkDrawCam0xLo
  15++C0A3
# file closed: ../../Tests/3DTest/../../Universe/Ships/XX18Vars.asm
  27+ C0A3
  28+ C0A3              ; Used to make 16 bit reads a little cleaner in source code
  29+ C0A3 00 00 00     UbnkZPoint                  DS  3
  30+ C0A6              UbnkZPointLo                equ UbnkZPoint
  31+ C0A6              UbnkZPointHi                equ UbnkZPoint+1
  32+ C0A6              UbnkZPointSign              equ UbnkZPoint+2
  33+ C0A6                                      INCLUDE "../../Universe/Ships/XX15Vars.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/XX15Vars.asm
   1++C0A6              ;-- XX15 --------------------------------------------------------------------------------------------------------------------------
   2++C0A6 00           UBnkXScaled                 DB  0               ; XX15+0Xscaled
   3++C0A7 00           UBnkXScaledSign             DB  0               ; XX15+1xsign
   4++C0A8 00           UBnkYScaled                 DB  0               ; XX15+2yscaled
   5++C0A9 00           UBnkYScaledSign             DB  0               ; XX15+3ysign
   6++C0AA 00           UBnkZScaled                 DB  0               ; XX15+4zscaled
   7++C0AB 00           UBnkZScaledSign             DB  0               ; XX15+5zsign
   8++C0AC
   9++C0AC              XX15                        equ UBnkXScaled
  10++C0AC              XX15VecX                    equ XX15
  11++C0AC              XX15VecY                    equ XX15+1
  12++C0AC              XX15VecZ                    equ XX15+2
  13++C0AC              UbnkXPoint                  equ XX15
  14++C0AC              UbnkXPointLo                equ XX15+0
  15++C0AC              UbnkXPointHi                equ XX15+1
  16++C0AC              UbnkXPointSign              equ XX15+2
  17++C0AC              UbnkYPoint                  equ XX15+3
  18++C0AC              UbnkYPointLo                equ XX15+3
  19++C0AC              UbnkYPointHi                equ XX15+4
  20++C0AC              UbnkYPointSign              equ XX15+5
  21++C0AC              ; Repurposed XX15 pre clip plines
  22++C0AC              UbnkPreClipX1               equ XX15+0
  23++C0AC              UbnkPreClipY1               equ XX15+2
  24++C0AC              UbnkPreClipX2               equ XX15+4
  25++C0AC              UbnkPreClipY2               equ XX15+6
  26++C0AC              ; Repurposed XX15 post clip lines
  27++C0AC              UBnkNewX1                   equ XX15+0
  28++C0AC              UBnkNewY1                   equ XX15+1
  29++C0AC              UBnkNewX2                   equ XX15+2
  30++C0AC              UBnkNewY2                   equ XX15+3
  31++C0AC              ; Repurposed XX15
  32++C0AC              regXX15fx                   equ UBnkXScaled
  33++C0AC              regXX15fxSgn                equ UBnkXScaledSign
  34++C0AC              regXX15fy                   equ UBnkYScaled
  35++C0AC              regXX15fySgn                equ UBnkYScaledSign
  36++C0AC              regXX15fz                   equ UBnkZScaled
  37++C0AC              regXX15fzSgn                equ UBnkZScaledSign
  38++C0AC              ; Repurposed XX15
  39++C0AC              varX1                       equ UBnkXScaled       ; Reused, verify correct position
  40++C0AC              varY1                       equ UBnkXScaledSign   ; Reused, verify correct position
  41++C0AC              varZ1                       equ UBnkYScaled       ; Reused, verify correct position
  42++C0AC              ; After clipping the coords are two 8 bit pairs
  43++C0AC              UBnkPoint1Clipped           equ UBnkXScaled
  44++C0AC              UBnkPoint2Clipped           equ UBnkYScaled
  45++C0AC              ; Repurposed XX15 when plotting lines
  46++C0AC              ; Repurposed XX15 before calling clip routine
  47++C0AC              UBnkX1                      equ XX15
  48++C0AC              UBnKx1Lo                    equ XX15
  49++C0AC              UBnKx1Hi                    equ XX15+1
  50++C0AC              UBnkY1                      equ XX15+2
  51++C0AC              UbnKy1Lo                    equ XX15+2
  52++C0AC              UBnkY1Hi                    equ XX15+3
  53++C0AC              UBnkX2                      equ XX15+4
  54++C0AC              UBnkX2Lo                    equ XX15+4
  55++C0AC              UBnkX2Hi                    equ XX15+5
  56++C0AC
# file closed: ../../Tests/3DTest/../../Universe/Ships/XX15Vars.asm
  34+ C0AC                                      INCLUDE "../../Universe/Ships/XX12Vars.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/XX12Vars.asm
   1++C0AC              ;-- transmat0 --------------------------------------------------------------------------------------------------------------------------
   2++C0AC              ; Note XX12 comes after as some logic in normal processing uses XX15 and XX12 combines
   3++C0AC 00           UBnkXX12xLo                 DB  0               ; XX12+0
   4++C0AD 00           UBnkXX12xSign               DB  0               ; XX12+1
   5++C0AE 00           UBnkXX12yLo                 DB  0               ; XX12+2
   6++C0AF 00           UBnkXX12ySign               DB  0               ; XX12+3
   7++C0B0 00           UBnkXX12zLo                 DB  0               ; XX12+4
   8++C0B1 00           UBnkXX12zSign               DB  0               ; XX12+5
   9++C0B2 00 00 00...  XX12Save                    DS  6
  10++C0B8 00 00 00...  XX12Save2                   DS  6
  11++C0BE              XX12                        equ UBnkXX12xLo
  12++C0BE              varXX12                     equ UBnkXX12xLo
  13++C0BE              ; Repurposed XX12 when plotting lines
  14++C0BE              UBnkY2                      equ XX12+0
  15++C0BE              UbnKy2Lo                    equ XX12+0
  16++C0BE              UBnkY2Hi                    equ XX12+1
  17++C0BE              UBnkDeltaXLo                equ XX12+2
  18++C0BE              UBnkDeltaXHi                equ XX12+3
  19++C0BE              UBnkDeltaYLo                equ XX12+4
  20++C0BE              UBnkDeltaYHi                equ XX12+5
  21++C0BE              UbnkGradient                equ XX12+2
  22++C0BE              UBnkTemp1                   equ XX12+2
  23++C0BE              UBnkTemp1Lo                 equ XX12+2
  24++C0BE              UBnkTemp1Hi                 equ XX12+3
  25++C0BE              UBnkTemp2                   equ XX12+3
  26++C0BE              UBnkTemp2Lo                 equ XX12+3
  27++C0BE              UBnkTemp2Hi                 equ XX12+4
  28++C0BE
# file closed: ../../Tests/3DTest/../../Universe/Ships/XX12Vars.asm
  35+ C0BE
  36+ C0BE
  37+ C0BE              ; Post clipping the results are now 8 bit
  38+ C0BE 00           UBnkVisibility              DB  0               ; replaces general purpose xx4 in rendering
  39+ C0BF 00           UBnkProjectedY              DB  0
  40+ C0C0 00           UBnkProjectedX              DB  0
  41+ C0C1              UBnkProjected               equ UBnkProjectedY  ; resultant projected position
  42+ C0C1 00 00 00...  XX15Save                    DS  8
  43+ C0C9 00 00 00...  XX15Save2                   DS  8
  44+ C0D1 00           VarBackface                 DB 0
  45+ C0D2              ; Heap (or array) information for lines and normals
  46+ C0D2              ; Coords are stored XY,XY,XY,XY
  47+ C0D2              ; Normals
  48+ C0D2              ; This needs re-oprganising now.
  49+ C0D2              ; Runtime Calculation Store
  50+ C0D2
  51+ C0D2              FaceArraySize               equ 30
  52+ C0D2              EdgeHeapSize                equ 40
  53+ C0D2              NodeArraySize               equ 40
  54+ C0D2              LineArraySize               equ 50; incerased for max of 28 lines, of 4 points of 16 bits each
  55+ C0D2              ; ONLY IF TESTING SOLID FILL TraingleArraySize           equ 25
  56+ C0D2              ; Storage arrays for data
  57+ C0D2              ; Structure of arrays
  58+ C0D2              ; Visibility array  - 1 Byte per face/normal on ship model Bit 7 (or FF) visible, 0 Invisible
  59+ C0D2              ; Node array corresponds to a processed vertex from the ship model transformed into world coordinates and tracks the node list from model
  60+ C0D2              ; NodeArray         -  4 bytes per element      0           1            2          3
  61+ C0D2              ;                                               X Coord Lo  Y Coord Lo   Z CoordLo  Sign Bits 7 6 5 for X Y Z Signs (set = negative)
  62+ C0D2              ; Line Array        -  4 bytes per eleement     0           1            2          3
  63+ C0D2              ;                                               X1          Y1           X2         Y2
  64+ C0D2 00 00 00...  UbnkFaceVisArray            DS FaceArraySize            ; XX2 Up to 16 faces this may be normal list, each entry is controlled by bit 7, 1 visible, 0 hidden
  65+ C0F0              ; Node array holds the projected to screen position regardless of if its clipped or not
  66+ C0F0              ; When we use traingles we can cheat a bit on clipping as all lines will be horizontal so clipping is much simplified
  67+ C0F0 00 00 00...  UBnkNodeArray               DS NodeArraySize * 4        ; XX3 Holds the points as an array, its an array not a heap
  68+ C190 00 00 00...  UBnkNodeArray2              DS NodeArraySize * 4        ; XX3 Holds the points as an array, its an array not a heap
  69+ C230 00 00 00...  UbnkLineArray               DS LineArraySize * 8        ; XX19 Holds the clipped line details
  70+ C3C0              ; ONLY IF TESTING SOLID FILL UBnkTriangleOverspill       DS TraingleArraySize * 4    ; jsut a padding for testing
  71+ C3C0              UBnkLinesHeapMax            EQU $ - UbnkLineArray
  72+ C3C0              UBnkTraingleArray           EQU UbnkLineArray           ; We can use the line array as we draw lines or traingles
  73+ C3C0 00 00 00...  UbnkEdgeProcessedList DS EdgeHeapSize
  74+ C3E8              ; Array current Lengths
  75+ C3E8 00           UbnkFaceVisArrayLen         DS 1
  76+ C3E9 00           UBnkNodeArrayLen            DS 1
  77+ C3EA 00           UbnkLineArrayLen            DS 1                        ; total number of lines loaded to array
  78+ C3EB 00           UbnkLineArrayBytes          DS 1                        ; total number of bytes loaded to array  = array len * 4
  79+ C3EC              XX20                        equ UbnkLineArrayLen
  80+ C3EC              varXX20                     equ UbnkLineArrayLen
  81+ C3EC
  82+ C3EC 00           UbnkEdgeHeapSize            DS 1
  83+ C3ED 00           UbnkEdgeHeapBytes           DS 1
  84+ C3EE 00           UBnkLinesHeapLen            DS 1
  85+ C3EF 00           UbnKEdgeHeapCounter         DS 1
  86+ C3F0 00           UbnKEdgeRadius              DS 1
  87+ C3F1 00           UbnKEdgeShipType            DS 1
  88+ C3F2 00           UbnKEdgeExplosionType       DS 1
  89+ C3F3
  90+ C3F3              ; Node heap is used to write out transformed Vertexs
  91+ C3F3
  92+ C3F3              ; Lines
  93+ C3F3 00 00 00     UBnkXX19                    DS  3
  94+ C3F6
  95+ C3F6 00 00 00...  UBnkHullCopy                DS  ShipDataLength
  96+ C411              ScoopDebrisAddr             equ UBnkHullCopy + ScoopDebrisOffset
  97+ C411              MissileLockLoAddr           equ UBnkHullCopy + MissileLockLoOffset
  98+ C411              MissileLockHiAddr           equ UBnkHullCopy + MissileLockHiOffset
  99+ C411              EdgeAddyAddr                equ UBnkHullCopy + EdgeAddyOffset
 100+ C411              LineX4Addr                  equ UBnkHullCopy + LineX4Offset
 101+ C411              GunVertexAddr               equ UBnkHullCopy + GunVertexOffset
 102+ C411              ExplosionCtAddr             equ UBnkHullCopy + ExplosionCtOffset
 103+ C411              VertexCountAddr             equ UBnkHullCopy + VertexCountOffset
 104+ C411              VertexCtX6Addr              equ UBnkHullCopy + VertexCtX6Offset
 105+ C411              EdgeCountAddr               equ UBnkHullCopy + EdgeCountOffset
 106+ C411              BountyLoAddr                equ UBnkHullCopy + BountyLoOffset
 107+ C411              BountyHiAddr                equ UBnkHullCopy + BountyHiOffset
 108+ C411              FaceCtX4Addr                equ UBnkHullCopy + FaceCtX4Offset
 109+ C411              DotAddr                     equ UBnkHullCopy + DotOffset
 110+ C411              EnergyAddr                  equ UBnkHullCopy + EnergyOffset
 111+ C411              SpeedAddr                   equ UBnkHullCopy + SpeedOffset
 112+ C411              FaceAddyAddr                equ UBnkHullCopy + FaceAddyOffset
 113+ C411              QAddr                       equ UBnkHullCopy + QOffset
 114+ C411              LaserAddr                   equ UBnkHullCopy + LaserOffset
 115+ C411              VerticesAddyAddr            equ UBnkHullCopy + VerticiesAddyOffset
 116+ C411              ShipTypeAddr                equ UBnkHullCopy + ShipTypeOffset
 117+ C411              ShipNewBitsAddr             equ UBnkHullCopy + ShipNewBitsOffset
 118+ C411              ShipAIFlagsAddr             equ UBnkHullCopy + ShipAIFlagsOffset
 119+ C411              ShipECMFittedChanceAddr     equ UBnkHullCopy + ShipECMFittedChanceOffset
 120+ C411              ShipSolidFlagAddr           equ UBnkHullCopy + ShipSolidFlagOffset
 121+ C411              ShipSolidFillAddr           equ UBnkHullCopy + ShipSolidFillOffset
 122+ C411              ShipSolidLenAddr            equ UBnkHullCopy + ShipSolidLenOffset
 123+ C411              ; Static Ship Data. This is copied in when creating the universe object
 124+ C411              XX0                         equ UBnkHullCopy        ; general hull index pointer TODO find biggest ship design
 125+ C411
 126+ C411 00 00 00...  UBnkHullVerticies           DS  40 * 6              ; largetst is trasnport type 10 at 37 vericies so alows for 40 * 6 Bytes  =
 127+ C501 00 00 00...  UBnkHullEdges               DS  50 * 4              ; ype 10 is 46 edges so allow 50
 128+ C5C9 00 00 00...  UBnkHullNormals             DS  20 * 4              ; type 10 is 14 edges so 20 to be safe
 129+ C619                  IFDEF SOLIDHULLTEST
 130+ C619 ~            UBnkHullSolid               DS  100 * 4             ; Up to 100 triangles (May optimise so only loads non hidden faces later
 131+ C619                  ENDIF
 132+ C619 0C           OrthagCountdown             DB  12
 133+ C61A
 134+ C61A              UBnkShipCopy                equ UBnkHullVerticies               ; Buffer for copy of ship data, for speed will copy to a local memory block, Cobra is around 400 bytes on creation of a new ship so should be plenty
 135+ C61A              UBnk_Data_len               EQU $ - StartOfUniv
 136+ C61A
 137+ C61A
 138+ C61A              ZeroUnivPitch:          MACRO
 139+ C61A ~                                    xor     a
 140+ C61A ~                                    ld      (UBnKRotZCounter),a
 141+ C61A                                      ENDM
 142+ C61A
 143+ C61A              ZeroUnivRoll:           MACRO
 144+ C61A ~                                    xor     a
 145+ C61A ~                                    ld      (UBnKRotXCounter),a
 146+ C61A                                      ENDM
 147+ C61A
 148+ C61A              ZeroUnivPitchAndRoll:   MACRO
 149+ C61A ~                                    xor     a
 150+ C61A ~                                    ld      (UBnKRotXCounter),a
 151+ C61A ~                                    ld      (UBnKRotZCounter),a
 152+ C61A                                      ENDM
 153+ C61A
 154+ C61A
 155+ C61A              MaxUnivPitchAndRoll:    MACRO
 156+ C61A ~                                    ld      a,127
 157+ C61A ~                                    ld      (UBnKRotXCounter),a
 158+ C61A ~                                    ld      (UBnKRotZCounter),a
 159+ C61A                                      ENDM
 160+ C61A
 161+ C61A              InfinitePitch:          MACRO
 162+ C61A ~                                    ld      a,$FF
 163+ C61A ~                                    ld      (UBnKRotZCounter),a
 164+ C61A                                      ENDM
 165+ C61A
 166+ C61A              InfiniteRoll:           MACRO
 167+ C61A ~                                    ld      a,$FF
 168+ C61A ~                                    ld      (UBnKRotXCounter),a
 169+ C61A                                      ENDM
 170+ C61A
 171+ C61A              InfinitePitchAndRoll:    MACRO
 172+ C61A ~                                    ld      a,$FF
 173+ C61A ~                                    ld      (UBnKRotXCounter),a
 174+ C61A ~                                    ld      (UBnKRotZCounter),a
 175+ C61A                                      ENDM
 176+ C61A
 177+ C61A              RandomUnivPitchAndRoll: MACRO
 178+ C61A ~                                    call    doRandom
 179+ C61A ~                                    or      %01101111
 180+ C61A ~                                    ld      (UBnKRotXCounter),a
 181+ C61A ~                                    call    doRandom
 182+ C61A ~                                    or      %01101111
 183+ C61A ~                                    ld      (UBnKRotZCounter),a
 184+ C61A                                      ENDM
 185+ C61A
 186+ C61A              RandomUnivSpeed:        MACRO
 187+ C61A ~                                    call    doRandom
 188+ C61A ~                                    and     31
 189+ C61A ~                                    ld      (UBnKSpeed),a
 190+ C61A                                      ENDM
 191+ C61A
 192+ C61A              MaxUnivSpeed:           MACRO
 193+ C61A ~                                    ld      a,31
 194+ C61A ~                                    ld      (UBnKSpeed),a
 195+ C61A                                      ENDM
 196+ C61A
 197+ C61A              ZeroUnivAccelleration:  MACRO
 198+ C61A ~                                    xor     a
 199+ C61A ~                                    ld      (UBnKAccel),a
 200+ C61A                                      ENDM
 201+ C61A
 202+ C61A 3A 0E C4     SetShipHostile:         ld      a,(ShipNewBitsAddr)
 203+ C61D F6 04                                or      ShipIsHostile
 204+ C61F 32 0E C4                             ld      (ShipNewBitsAddr),a
 205+ C622 C9                                   ret
 206+ C623
 207+ C623 3A 0E C4     ClearShipHostile:       ld      a,(ShipNewBitsAddr)
 208+ C626 E6 FB                                and     ShipNotHostile
 209+ C628 32 0E C4                             ld      (ShipNewBitsAddr),a
 210+ C62B C9                                   ret
 211+ C62C
 212+ C62C
 213+ C62C              ; --------------------------------------------------------------
 214+ C62C 21 00 C0     ResetUBnkData:          ld      hl,StartOfUniv
 215+ C62F 11 1A 06                             ld      de,UBnk_Data_len
 216+ C632 AF                                   xor     a
 217+ C633 CD F0 67                             call    memfill_dma
 218+ C636 C9                                   ret
 219+ C637              ; --------------------------------------------------------------
 220+ C637 21 20 C0     ResetUbnkPosition:      ld      hl,UBnKxlo
 221+ C63A 06 09                                ld      b, 3*3
 222+ C63C AF                                   xor     a
 223+ C63D 77           .zeroLoop:              ld      (hl),a
 224+ C63E 23                                   inc     hl
 225+ C63F 10 FC                                djnz    .zeroLoop
 226+ C641 C9                                   ret
 227+ C642
 228+ C642              ;-- This takes an Axis and subtracts 1, handles leading sign and boundary of 0 going negative
 229+ C642              JumpOffSet:             MACRO   Axis
 230+ C642 ~                                    ld      hl,(Axis)
 231+ C642 ~                                    ld      a,h
 232+ C642 ~                                    and     SignOnly8Bit
 233+ C642 ~                                    jr      nz,.NegativeAxis
 234+ C642 ~            .PositiveAxis:          dec     l
 235+ C642 ~                                    jp      m,.MovingNegative
 236+ C642 ~                                    jp      .Done
 237+ C642 ~            .NegativeAxis:          inc     l                               ; negative means increment the z
 238+ C642 ~                                    jp      .Done
 239+ C642 ~            .MovingNegative:        ld      hl,$8001                        ; -1
 240+ C642 ~            .Done                   ld      (Axis),hl
 241+ C642                                      ENDM
 242+ C642
 243+ C642
 244+ C642              WarpOffset:             JumpOffSet  UBnKzhi                     ; we will simplify on just moving Z
 244+ C642 2A 27 C0    >                        ld      hl,(UBnKzhi)
 244+ C645 7C          >                        ld      a,h
 244+ C646 E6 80       >                        and     SignOnly8Bit
 244+ C648 20 07       >                        jr      nz,.NegativeAxis
 244+ C64A 2D          >.PositiveAxis:          dec     l
 244+ C64B FA 55 C6    >                        jp      m,.MovingNegative
 244+ C64E C3 58 C6    >                        jp      .Done
 244+ C651 2C          >.NegativeAxis:          inc     l                               ; negative means increment the z
 244+ C652 C3 58 C6    >                        jp      .Done
 244+ C655 21 01 80    >.MovingNegative:        ld      hl,$8001                        ; -1
 244+ C658 22 27 C0    >.Done                   ld      (UBnKzhi),hl
 245+ C65B C9                                   ret
 246+ C65C
 247+ C65C 44           WarpUnivByHL:           ld      b,h
 248+ C65D 4D                                   ld      c,l
 249+ C65E 26 00                                ld      h,0
 250+ C660 ED 5B 27 C0                          ld      de,(UBnKzhi)
 251+ C664 3A 26 C0                             ld      a,(UBnKzlo)
 252+ C667 6F                                   ld      l,a
 253+ C668                                      MMUSelectMathsBankedFns
 253+ C668 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 253+ C66C CD 10 01       call  SubBCHfromDELsigned
 254+ C66F ED 53 27 C0                          ld      (UBnKzhi),de
 255+ C673 7D                                   ld      a,l
 256+ C674 32 26 C0                             ld      (UBnKzlo),a
 257+ C677 C9                                   ret
 258+ C678
 259+ C678              ; --------------------------------------------------------------
 260+ C678              ; update ship speed and pitch based on adjustments from AI Tactics
 261+ C678 3A 47 C0     UpdateSpeedAndPitch:    ld      a,(UBnKAccel)                   ; only apply non zero accelleration
 262+ C67B                                      JumpIfAIsZero .SkipAccelleration
 262+ C67B A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 262+ C67C CA 9A C6    >                        jp	    z, .SkipAccelleration
 263+ C67F 47                                   ld      b,a                             ; b = accelleration in 2's c
 264+ C680 3A 46 C0                             ld      a,(UBnKSpeed)                   ; a = speed + accelleration
 265+ C683                                      ClearCarryFlag
 265+ C683 B7          >                        or a
 266+ C684 88                                   adc     a,b
 267+ C685                                      JumpIfPositive  .DoneAccelleration      ; if speed < 0
 267+ C685 F2 89 C6    >                        jp		p, .DoneAccelleration
 268+ C688              .SpeedNegative:         ZeroA                                   ;    then speed = 0
 268+ C688 AF          >                        xor a
 269+ C689 47           .DoneAccelleration:     ld      b,a                             ; if speed > speed limit
 270+ C68A 3A 06 C4                             ld      a,(SpeedAddr)                   ;    speed = limit
 271+ C68D                                      JumpIfAGTENusng b, .SpeedInLimits       ; .
 271+ C68D B8          >                        cp     b
 271+ C68E D2 92 C6    >                        jp		nc,.SpeedInLimits
 272+ C691 47                                   ld      b,a                             ; .
 273+ C692 78           .SpeedInLimits:         ld      a,b                             ; .
 274+ C693 32 46 C0                             ld      (UBnKSpeed),a                   ; .
 275+ C696                                      ZeroA                                   ; acclleration = 0
 275+ C696 AF          >                        xor a
 276+ C697 32 47 C0                             ld      (UBnKAccel),a                   ; for next AI update
 277+ C69A              .SkipAccelleration:     ; handle roll and pitch rates
 278+ C69A C9                                   ret
 279+ C69B
 280+ C69B
 281+ C69B CD D4 C6     UnivSetDemoPostion:     call    UnivSetSpawnPosition
 282+ C69E 3E 81                                ld      a,%10000001                     ; AI Enabled has 1 missile
 283+ C6A0 32 54 C0                             ld      (UBnkaiatkecm),a                ; set hostinle, no AI, has ECM
 284+ C6A3 32 0E C4                             ld      (ShipNewBitsAddr),a             ; initialise new bits logic
 285+ C6A6 3E 00                                ld      a,0
 286+ C6A8 32 49 C0                             ld      (UBnKRotZCounter),a             ; no pitch
 287+ C6AB 32 48 C0                             ld      (UBnKRotXCounter),a             ; set roll to maxi on station
 288+ C6AE                                      ZeroA
 288+ C6AE AF          >                        xor a
 289+ C6AF 32 22 C0                             ld      (UBnKxsgn),a
 290+ C6B2 32 25 C0                             ld      (UBnKysgn),a
 291+ C6B5 32 28 C0                             ld      (UBnKzsgn),a
 292+ C6B8 21 00 00                             ld      hl,0
 293+ C6BB 22 20 C0                             ld      (UBnKxlo),hl
 294+ C6BE 22 23 C0                             ld      (UBnKylo),hl
 295+ C6C1 3A 0D C4                             ld      a,(ShipTypeAddr)
 296+ C6C4 21 B0 05                             ld      hl,$05B0                            ; so its a negative distance behind
 297+ C6C7                                      JumpIfANENusng ShipTypeStation, .SkipFurther
 297+ C6C7 FE 02       >                        cp     ShipTypeStation
 297+ C6C9 C2 D0 C6    >                        jp      nz,.SkipFurther
 298+ C6CC 3E 05                                ld      a,5
 299+ C6CE 84                                   add     h
 300+ C6CF 67                                   ld      h,a
 301+ C6D0 22 26 C0     .SkipFurther            ld      (UBnKzlo),hl
 302+ C6D3 C9                                   ret
 303+ C6D4                  DISPLAY "Tracing 1", $
 304+ C6D4              ; --------------------------------------------------------------
 305+ C6D4              ; This sets the position of the current ship randomly, called after spawing
 306+ C6D4              ; Spawns in withink 16 bit range so 24 bit friendly
 307+ C6D4 CD 34 C7     UnivSetSpawnPosition:   call    InitialiseOrientation
 308+ C6D7                                      RandomUnivPitchAndRoll
 308+ C6D7 CD 36 6D    >                        call    doRandom
 308+ C6DA F6 6F       >                        or      %01101111
 308+ C6DC 32 48 C0    >                        ld      (UBnKRotXCounter),a
 308+ C6DF CD 36 6D    >                        call    doRandom
 308+ C6E2 F6 6F       >                        or      %01101111
 308+ C6E4 32 49 C0    >                        ld      (UBnKRotZCounter),a
 309+ C6E7 CD 36 6D                             call    doRandom                        ; set x lo and y lo to random
 310+ C6EA 32 20 C0     .setXlo:                ld      (UBnKxlo),a
 311+ C6ED 32 23 C0     .setYlo:                ld      (UBnKylo),a
 312+ C6F0 0F           .setXsign:              rrca                                    ; rotate by 1 bit right
 313+ C6F1 47                                   ld      b,a
 314+ C6F2 E6 80                                and     SignOnly8Bit
 315+ C6F4 32 22 C0                             ld      (UBnKxsgn),a
 316+ C6F7 78           .setYSign:              ld      a,b                             ; get random back again
 317+ C6F8 0F                                   rrca                                    ; rotate by 1 bit right
 318+ C6F9 47                                   ld      b,a
 319+ C6FA E6 80                                and     SignOnly8Bit                    ; and set y sign
 320+ C6FC 32 25 C0                             ld      (UBnKysgn),a
 321+ C6FF CB 08        .setYHigh:              rrc     b                               ; as value is in b rotate again
 322+ C701 78                                   ld      a,b                             ;
 323+ C702 E6 1F                                and     31                              ; set y hi to random 0 to 31
 324+ C704 32 24 C0                             ld      (UBnKyhi),a                     ;
 325+ C707 CB 08        .setXHigh:              rrc     b                               ; as value is in b rotate again
 326+ C709 78                                   ld      a,b
 327+ C70A E6 1F                                and     31                              ; set x hi to random 0 to 31
 328+ C70C 4F                                   ld      c,a                             ; save shifted into c as well
 329+ C70D 32 21 C0                             ld      (UBnKxhi),a
 330+ C710 3E 50        .setZHigh:              ld      a,80                            ; set z hi to 80 - xhi - yhi - carry
 331+ C712 98                                   sbc     b
 332+ C713 99                                   sbc     c
 333+ C714 32 27 C0                             ld      (UBnKzhi),a
 334+ C717 3A 0D C4     .CheckIfBodyOrJunk:     ld      a,(ShipTypeAddr)
 335+ C71A                                      ReturnIfAEqNusng ShipTypeJunk
 335+ C71A FE 03       >                        cp      ShipTypeJunk
 335+ C71C C8          >                        ret     z
 336+ C71D                                      ReturnIfAEqNusng ShipTypeScoopable
 336+ C71D FE 04       >                        cp      ShipTypeScoopable
 336+ C71F C8          >                        ret     z
 337+ C720 78                                   ld      a,b                             ; its not junk to set z sign
 338+ C721 0F                                   rrca                                    ; as it can jump in
 339+ C722 E6 80                                and     SignOnly8Bit
 340+ C724 32 28 C0                             ld      (UBnKzsgn),a
 341+ C727 C9                                   ret
 342+ C728                  ;Input: BC = Dividend, DE = Divisor, HL = 0
 343+ C728              ;Output: BC = Quotient, HL = Remainder
 344+ C728
 345+ C728              ; Initialiase data, iyh must equal slot number
 346+ C728              ;                   iyl must be ship type
 347+ C728              ;                   a  = current bank number
 348+ C728 01 22 00     UnivInitRuntime:        ld      bc,UBnKRuntimeSize
 349+ C72B 21 3F C0                             ld      hl,UBnKStartOfRuntimeData
 350+ C72E                                      ZeroA
 350+ C72E AF          >                        xor a
 351+ C72F 77           .InitLoop:              ld      (hl),a
 352+ C730 23                                   inc     hl
 353+ C731 10 FC                                djnz    .InitLoop
 354+ C733 C9                                   ret
 355+ C734                  DISPLAY "Tracing 2", $
 356+ C734
 357+ C734                                      include "../../Universe/Ships/InitialiseOrientation.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/InitialiseOrientation.asm
   1++C734              ;  sidev = (1,  0,  0)  sidev = (&6000, 0, 0)
   2++C734              ;  roofv = (0,  1,  0)  roofv = (0, &6000, 0)
   3++C734              ;  nosev = (0,  0, -1)  nosev = (0, 0, &E000)   E000 = SignBit[96]
   4++C734              InitialiseOrientation:
   5++C734 21 00 00     ZI1:                    ld      hl, 0
   6++C737 22 2B C0                             ld      (UBnkrotmatSidevY),hl                ; set the zeroes
   7++C73A 22 2D C0                             ld      (UBnkrotmatSidevZ),hl                ; set the zeroes
   8++C73D 22 2F C0                             ld      (UBnkrotmatRoofvX),hl                ; set the zeroes
   9++C740 22 33 C0                             ld      (UBnkrotmatRoofvZ),hl                ; set the zeroes
  10++C743 22 35 C0                             ld      (UBnkrotmatNosevX),hl                ; set the zeroes
  11++C746 22 37 C0                             ld      (UBnkrotmatNosevY),hl                ; set the zeroes
  12++C749              ; Optimised as already have 0 in l
  13++C749 26 60                                ld      h, $60	             				; 96 in hi byte
  14++C74B                                      ;ld      hl,1
  15++C74B 22 29 C0                             ld      (UBnkrotmatSidevX),hl
  16++C74E 22 31 C0                             ld      (UBnkrotmatRoofvY),hl
  17++C751              ; Optimised as already have 0 in l
  18++C751 26 E0                                ld      h, $E0					            ; -96 in hi byte which is +96 with hl bit 7 set
  19++C753 22 39 C0                             ld      (UBnkrotmatNosevZ),hl
  20++C756 C9                                   ret
  21++C757
  22++C757              InitialisePlayerMissileOrientation:
  23++C757 CD 34 C7                             call    InitialiseOrientation
  24++C75A 21 00 60                             ld      hl,$6000
  25++C75D 22 39 C0                             ld      (UBnkrotmatNosevZ),hl           ; mius
  26++C760 C9                                   ret
  27++C761
  28++C761
  29++C761              ;  sidev = (1,  0,  0)  sidev = (&6000, 0, 0)
  30++C761              ;  roofv = (0,  1,  0)  roofv = (0, &6000, 0)
  31++C761              ;  nosev = (-0,  -0, 1) nosev = (0, 0, &6000)
  32++C761 CD 34 C7     LaunchedOrientation:    call    InitialiseOrientation
  33++C764                                      FlipSignMem UBnkrotmatNosevX+1;  as its 0 flipping will make no difference
  33++C764 3A 36 C0    >                        ld  a,(UBnkrotmatNosevX+1)
  33++C767 EE 80       >                        xor SignOnly8Bit
  33++C769 32 36 C0    >                        ld  (UBnkrotmatNosevX+1),a
  34++C76C                                      FlipSignMem UBnkrotmatNosevY+1;  as its 0 flipping will make no difference
  34++C76C 3A 38 C0    >                        ld  a,(UBnkrotmatNosevY+1)
  34++C76F EE 80       >                        xor SignOnly8Bit
  34++C771 32 38 C0    >                        ld  (UBnkrotmatNosevY+1),a
  35++C774                                      FlipSignMem UBnkrotmatNosevZ+1
  35++C774 3A 3A C0    >                        ld  a,(UBnkrotmatNosevZ+1)
  35++C777 EE 80       >                        xor SignOnly8Bit
  35++C779 32 3A C0    >                        ld  (UBnkrotmatNosevZ+1),a
  36++C77C C9                                   ret
  37++C77D
# file closed: ../../Tests/3DTest/../../Universe/Ships/InitialiseOrientation.asm
 358+ C77D
 359+ C77D              ;--------------------------------------------------------------------------------------------------------
 360+ C77D                                      INCLUDE "../../ModelRender/CLIP-LL145.asm"
# file opened: ../../Tests/3DTest/../../ModelRender/CLIP-LL145.asm
   1++C77D              ;--------------------------------------------------------------------------------------------------------------------
   2++C77D
   3++C77D 00           clipDx                  DB      0           ; also XX12+2
   4++C77E 00           clipDxHigh              DB      0           ; also XX12+3
   5++C77F 00           clipDxHighNonABS        DB      0           ; also XX12+3
   6++C780 00           clipDy                  DB      0           ; also XX12+4
   7++C781 00           clipDyHigh              DB      0           ; also XX12+5
   8++C782 00           clipGradient            DB      0
   9++C783 00           clipDxySign             DB      0
  10++C784              varX12p3                equ     clipDxySign
  11++C784 00           clipXGTY                DB      0
  12++C785 00           clipFlags               DB      0
  13++C786 00           SWAP                    DB      0
  14++C787 00 00        varYX                   DW      0
  15++C789              ;varRegX                 DB      0
  16++C789              ;varXX12p2               DB      0
  17++C789 00           clipXX13                 DB      0
  18++C78A 00           Gradient                DB      0
  19++C78B              ; for start and end y. bit7 of lower determines its not been setup yet
  20++C78B
  21++C78B              ;--------------------------------------------------------------------------------------
  22++C78B                      IFNDEF       CLIPVersion3
  23++C78B ED 4B A8 C0  ClipLine:               ld      bc,(UbnkPreClipY1)          ; bc - XX15(2,3) Y1
  24++C78F DD 2A AC C0                          ld      ix,(UbnkPreClipY2)          ; ix - XX12(0,1) Y2
  25++C793 2A A6 C0                             ld      hl,(UbnkPreClipX1)          ; hl - XX15(0,1) X1
  26++C796 ED 5B AA C0                          ld      de,(UbnkPreClipX2)          ; de - XX15(4,5) X2
  27++C79A AF                                   xor     a
  28++C79B 32 86 C7                             ld      (SWAP),a                    ; SWAP = 0
  29++C79E 7A                                   ld      a,d                         ; A = X2Hi
  30++C79F FD 26 BF     .LL147:                 ld      iyh,$BF                     ; we need to be 191 as its 128 + another bit set from 0 to 6, we are using iyh as regX (128 will actually do)
  31++C7A2 DD B4                                or      ixh                         ; if (X2Hi L-OR Y2 Hi <> 0) goto LL107             -- X2Y2 off screen
  32++C7A4 20 0A                                jr      nz, .LL107
  33++C7A6 DD 7D                                ld      a,ixl
  34++C7A8 ED 27 80                             test    $80                         ; if screen hight < y2 lo, i.e y2 lo >127 goto LL107,
  35++C7AB 20 03                                jr      nz,.LL107
  36++C7AD FD 26 00                             ld      iyh, 0                      ; else iyh = regX = 0                                                                        -- X2Y2 on screen
  37++C7B0              ; XX13 = regX (i.e. iyh)      ( if XX13 = XX13 is 191 if (x2, y2) is off-screen else 0) we bin XX13 as not needed
  38++C7B0              ; so XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen,  XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lo is off the bottom of the screen
  39++C7B0 FD 7C        .LL107                  ld      a,iyh
  40++C7B2 32 89 C7                             ld      (clipXX13),a                ; debug copy iyh to xx13
  41++C7B5 7C                                   ld      a,h                         ; If (X1 hi L-OR Y1) hi  goto LL83                   -- X1Y1 off screen and maybe X2Y2
  42++C7B6 B0                                   or      b                           ;
  43++C7B7 20 27                                jr      nz,.LL83                    ;
  44++C7B9 79                                   ld      a,c                         ; or (y1 lo > bottom of screen)
  45++C7BA ED 27 80                             test    $80                         ; i.e  screen height < y1)
  46++C7BD 20 21                                jr      nz,.LL83
  47++C7BF              ; If we get here, (x1, y1) is on-screen
  48++C7BF FD 7C                                ld      a,iyh                       ; iyh = xx13 at this point if  XX13 <> 0 goto LL108                                                        -- X1Y1 on screen, if we flagged X2Y2 off screen goto LL108
  49++C7C1 FE 00                                cp      0
  50++C7C3 20 15                                jr      nz, .LL108
  51++C7C5              ; Finished clipping exit point ----------------------------------------------------------------------------------------
  52++C7C5 79           .ClipDone:              ld      a,c                         ; LL146 (Clip Done)               Y1 = y1 lo, x2 = x2 lo, x1 = x1 lo y1 = y1 lo                                   -- Nothing off screen
  53++C7C6 32 A7 C0                             ld      (UBnkNewY1),a
  54++C7C9 DD 7D                                ld      a,ixl
  55++C7CB 32 A9 C0                             ld      (UBnkNewY2),a
  56++C7CE 7D                                   ld      a,l
  57++C7CF 32 A6 C0                             ld      (UBnkNewX1),a
  58++C7D2 7B                                   ld      a,e
  59++C7D3 32 A8 C0                             ld      (UBnkNewX2),a
  60++C7D6                                      ClearCarryFlag                      ; carry is clear so valid to plot is in XX15(0to3)
  60++C7D6 B7          >                        or a
  61++C7D7 C9                                   ret                                 ; 2nd pro different, it swops based on swop flag around here.
  62++C7D8              ; Finished out of bounds exit point -----------------------------------------------------------------------------------
  63++C7D8              .PointsOutofBounds:     SetCarryFlag                        ; LL109 (ClipFailed) carry flag set as not visible
  63++C7D8 37          >                        scf
  64++C7D9 C9                                   ret
  65++C7DA FD 7C        .LL108:                 ld      a,iyh
  66++C7DC B7                                   or      a
  67++C7DD 1F                                   rra
  68++C7DE FD 67                                ld      iyh,a                       ; (X2Y2 Off Screen)         XX13 = 95 (i.e. divide it by 2)                                                 -- X1Y1 on screen X2Y2 off screen
  69++C7E0 FD 7C        .LL83:                  ld      a,iyh                       ; (Line On screen Test)      if XX13 < 128 then only 1 point is on screen so goto LL115                      -- We only need to deal with X2Y2
  70++C7E2 ED 27 80                             test    $80                         ;
  71++C7E5 28 28                                jr      z, .LL115                   ;
  72++C7E7              ;                       Check for X1 and X2 negative
  73++C7E7 7C                                   ld      a,h                         ; If both x1_hi and x2_hi have bit 7 set, jump to LL109  to return from the subroutine with the C flag set, as the entire line is above the top of the screen
  74++C7E8 A2                                   and     d
  75++C7E9                                      JumpIfNegative  .PointsOutofBounds
  75++C7E9 FA D8 C7    >                        jp		m, .PointsOutofBounds
  76++C7EC              ;                       Check for Y1 and Y2 negative
  77++C7EC 78                                   ld      a,b                         ; If both y1_hi and y2_hi have bit 7 set, jump to LL109  to return from the subroutine with the C flag set, as the entire line is above the top of the screen
  78++C7ED DD A4                                and     ixh
  79++C7EF                                      JumpIfNegative  .PointsOutofBounds
  79++C7EF FA D8 C7    >                        jp		m, .PointsOutofBounds
  80++C7F2              ;                       Check for X1 and X2 both > 255
  81++C7F2 7C                                   ld      a,h                         ; If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set, jump to LL109 to return from the subroutine with the C  flag set, as the line doesn't fit on-screen
  82++C7F3 3D                                   dec     a
  83++C7F4 FD 6F                                ld      iyl,a                       ; using iyl as XX12+2 var
  84++C7F6 7A                                   ld      a,d                         ; a = x2 hi
  85++C7F7 3D                                   dec     a
  86++C7F8 FD B5                                or      iyl                         ; (x2 hi -1 ) or (x1 hi -1)
  87++C7FA                                      JumpIfPositive .PointsOutofBounds   ; if both x1 and x2hi were > 0 then subtracting 1 would result in 0..254 so either being negative means it was 0 before
  87++C7FA F2 D8 C7    >                        jp		p, .PointsOutofBounds
  88++C7FD              ; by here we have eliminated -ve Y1 bounds so can just test for positive high and bit 7 of lo
  89++C7FD DD 7C                                ld      a,ixh
  90++C7FF 3D                                   dec     a
  91++C800 FD 6F                                ld      iyl,a
  92++C802 78                                   ld      a,b
  93++C803 3D                                   dec     a
  94++C804 FD B5                                or      iyl
  95++C806                                      JumpIfPositive .PointsOutofBounds   ; if both x1 and x2hi were > 0 then subtracting 1 would result in 0..254 so either being negative means it was 0 before
  95++C806 F2 D8 C7    >                        jp		p, .PointsOutofBounds
  96++C809 79                                   ld      a,c
  97++C80A DD A5                                and     ixl
  98++C80C                                      JumpIfNegative .PointsOutofBounds   ; really if both are > 127
  98++C80C FA D8 C7    >                        jp		m, .PointsOutofBounds
  99++C80F              ; Clip line: calulate the line's gradient
 100++C80F              ; here as an optimisation we make sure X1 is always < X2  later on
 101++C80F              .LL115:                 ClearCarryFlag
 101++C80F B7          >                        or a
 102++C810 E5 D5        .CalcDX:                push    hl,,de
 103++C812 EB                                   ex      hl,de                       ; so hl is x2 and de = x1
 104++C813 ED 52                                sbc     hl,de
 105++C815 22 7D C7                             ld      (clipDx),hl
 106++C818 7C                                   ld      a,h
 107++C819 32 7F C7                             ld      (clipDxHighNonABS),a
 108++C81C              .CalcDy:                ClearCarryFlag
 108++C81C B7          >                        or a
 109++C81D DD E5 E1                             ld      hl,ix
 110++C820 ED 42                                sbc     hl,bc
 111++C822 54 5D                                ld      de,hl           ;;OPTIMISATION 6/11/21
 112++C824 22 80 C7                             ld      (clipDy),hl     ;OPTIMISATION 6/11/21 commented out
 113++C827 7C           .CalcQuadrant:          ld      a,h
 114++C828 32 81 C7                             ld      (clipDyHigh),a              ; so A = sign of deltay in effect
 115++C82B              ; So we now have delta_x in XX12(3 2), delta_y in XX12(5 4)  where the delta is (x1, y1) - (x2, y2))
 116++C82B 21 7E C7                             ld      hl,clipDxHigh
 117++C82E AE                                   xor     (hl)                        ; now a = sign dx xor sign dy
 118++C82F 32 61 69                             ld      (varS),a                    ; DEBGU putting it in var S too for now
 119++C832 32 83 C7                             ld      (clipDxySign),a
 120++C835 3A 81 C7     .AbsDy:                 ld      a,(clipDyHigh)
 121++C838 ED 27 80                             test    $80
 122++C83B 28 0E                                jr      z,.LL110                    ; If delta_y_hi is positive, jump down to LL110 to skip the following
 123++C83D ED 5B 80 C7                          ld      de,(clipDy)                 ;OPTIMISATION 6/11/21 commented out
 124++C841                                      macronegate16de                     ; Otherwise flip the sign of delta_y to make it  positive, starting with the low bytes
 124++C841 AF          >					xor 	a
 124++C842 93          >                    sub 	e
 124++C843 5F          >                    ld 		e,a
 124++C844 9F          >                    sbc 	a,a
 124++C845 92          >                    sub 	d
 124++C846 57          >                    ld 		d,a
 125++C847 ED 53 80 C7                          ld      (clipDy),de                 ;OPTIMISATION 6/11/21 commented out
 126++C84B 2A 7D C7     .LL110:                 ld      hl,(clipDx)
 127++C84E 3A 7E C7                             ld      a,(clipDxHigh)
 128++C851 ED 27 80                             test    $80                         ; is it a negative X
 129++C854 28 06                                jr      z,.LL111                    ; If delta_x_hi is positive, jump down to LL110 to skip the following
 130++C856                                      ;ld      hl,(clipDx)                 ;OPTIMISATION 6/11/21 commented out
 131++C856                                      macronegate16hl                     ; Otherwise flip the sign of delta_y to make it  positive, starting with the low bytes
 131++C856 AF          >					xor 	a
 131++C857 95          >					sub 	l
 131++C858 6F          >					ld 		l,a
 131++C859 9F          >					sbc 	a,a
 131++C85A 94          >					sub 	h
 131++C85B 67          >					ld 		h,a
 132++C85C              .LL111:
 133++C85C 7C           .ScaleLoop:             ld      a,h                         ; At this point DX and DY are ABS values
 134++C85D B2                                   or      d
 135++C85E 28 0A                                jr      z,.CalculateDelta
 136++C860                                      ShiftDERight1
 136++C860 CB 3A       >			   srl d
 136++C862 CB 1B       >			   rr  e
 137++C864                                      ShiftHLRight1
 137++C864 CB 3C       >			   srl h
 137++C866 CB 1D       >			   rr  l
 138++C868 18 F2                                jr      .ScaleLoop                  ; scaled down Dx and Dy to 8 bit, Dy may have been negative
 139++C86A              .CalculateDelta:
 140++C86A              ; By now, the high bytes of both |delta_x| and |delta_y| are zero We know that h and d are both = 0 as that's what we tested with a BEQ
 141++C86A AF           .LL113:                 xor     a
 142++C86B 32 7B 69                             ld      (varT),a                    ; t = 0
 143++C86E 7D                                   ld      a,l                         ; If delta_x_lo < delta_y_lo, so our line is more vertical than horizontal, jump to LL114
 144++C86F                                      JumpIfALTNusng  e, .LL114           ;
 144++C86F BB          >                        cp      e
 144++C870 DA 80 C8    >                        jp		c, .LL114
 145++C873              ; Here Dx >= Dy sp calculate Delta Y / delta X
 146++C873 32 5F 69     .DxGTEDy:               ld      (varQ),a                    ; Set Q = delta_x_lo
 147++C876 57                                   ld      d,a                         ; d = also Q for calc
 148++C877 7B                                   ld      a,e                         ; Set A = delta_y_lo
 149++C878 CD 3E 72                             call    AEquAmul256DivD; LL28Amul256DivD             ; Call LL28 to calculate:  R (actually a reg) = 256 * A / Q   = 256 * delta_y_lo / delta_x_lo
 150++C87B 32 60 69                             ld      (varR),a                    ;
 151++C87E 18 10                                jr      .LL116                      ; Jump to LL116, as we now have the line's gradient in R
 152++C880              ; Here Delta Y > Delta X so calulate delta X / delta Y
 153++C880 7B           .LL114:                 ld      a,e                         ; Set Q = delta_y_lo
 154++C881 57                                   ld      d,a
 155++C882 32 5F 69                             ld      (varQ),a
 156++C885 7D                                   ld      a,l                         ; Set A = delta_x_lo
 157++C886 CD 3E 72                             call    AEquAmul256DivD; LL28Amul256DivD             ; Call LL28 to calculate: R = 256 * A / Q  = 256 * delta_x_lo / delta_y_lo
 158++C889 32 60 69                             ld      (varR),a                    ;
 159++C88C 21 7B 69                             ld      hl,varT                     ; T was set to 0 above, so this sets T = &FF
 160++C88F 35                                   dec     (hl)
 161++C890 D1           .LL116:                 pop     de                          ; get back X2
 162++C891 E1                                   pop     hl                          ; get back X1 into hl,
 163++C892 3A 60 69                             ld      a,(varR)                    ; Store the gradient in XX12+2 this can be optimised later
 164++C895 32 82 C7                             ld      (clipGradient),a
 165++C898 FD 6F                                ld      iyl,a
 166++C89A 3A 61 69                             ld      a,(varS)
 167++C89D 32 83 C7                             ld      (clipDxySign),a             ;  Store the type of slope in XX12+3, bit 7 clear means ?Not needed as clipDxySign is used for varS earlier?
 168++C8A0                                                                          ; top left to bottom right, bit 7 set means top right to bottom left **CODE IS WRONG HERE A TEST IS BL to TR
 169++C8A0 FD 7C                                ld      a,iyh                       ; iyh was XX13 from earlier
 170++C8A2 FE 00                                cp      0                           ; If XX13 = 0, skip the following instruction
 171++C8A4 28 05                                jr      z,.LL138                    ;
 172++C8A6 ED 27 80                             test    $80                         ; If XX13 is positive, it must be 95. This means (x1, y1) is on-screen but (x2, y2) isn't, so we jump to LLX117 to swap the (x1, y1) and (x2, y2)
 173++C8A9 28 13                                jr      z,.LLX117                   ; coordinates around before doing the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
 174++C8AB              ; If we get here, XX13 = 0 or 191, so (x1, y1) is off-screen and needs clipping
 175++C8AB CD D2 C8     .LL138                  call    ClipPointHLBC               ; Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 176++C8AE FD 7C                                ld      a,iyh                       ; If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to LL124 to return with a successfully clipped line
 177++C8B0 ED 27 80                             test    $80
 178++C8B3 28 1A                                jr      z,.LL124
 179++C8B5              ; If we get here, XX13 = 191 (both coordinates are off-screen)
 180++C8B5 7C           .LL117:                 ld      a,h                         ; If either of x1_hi or y1_hi are non-zero, jump to
 181++C8B6 B0                                   or      b                           ; LL137 to return from the subroutine with the C flag
 182++C8B7 C2 D8 C7                             jp      nz, .PointsOutofBounds      ; set, as the line doesn't fit on-screen
 183++C8BA B1                                   or      c                           ; if x1 and y1 hi are both zero test bit 8 or Y1 to see if its > 128
 184++C8BB FA D8 C7                             jp      m, .PointsOutofBounds       ; set, as the line doesn't fit on-screen
 185++C8BE              ; If we get here, XX13 = 95 or 191, and in both cases (x2, y2) is off-screen, so we now need to swap the (x1, y1) and (x2, y2) coordinates around before doing
 186++C8BE              ; the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
 187++C8BE EB           .LLX117:                ex      de,hl                       ;  swap X1 and X2
 188++C8BF DD E5                                push    ix                          ;  swap Y1 and Y2
 189++C8C1 C5                                   push    bc
 190++C8C2 DD E1                                pop     ix
 191++C8C4 C1                                   pop     bc
 192++C8C5 CD D2 C8                             call    ClipPointHLBC               ;  Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 193++C8C8 3A 86 C7                             ld      a,(SWAP)
 194++C8CB 3D                                   dec     a
 195++C8CC 32 86 C7                             ld      (SWAP),a                    ; Set SWAP = &FF to indicate that we just clipped the line at the (x2, y2) end by swapping the coordinates (the DEC does this as we set SWAP to 0 at the start of this subroutine)
 196++C8CF C3 C5 C7     .LL124:                 jp      .ClipDone                    ; now put points in place
 197++C8D2              ; Move a point along a line until it is on-screen point is held in HL(X) BC(Y) LL118
 198++C8D2              ; iyh still holds XX13 iyl still holds gradient
 199++C8D2 7C           ClipPointHLBC:          ld      a,h                         ; If x1_hi is positive, jump down to LL119 to skip the following
 200++C8D3 ED 27 80                             test    $80
 201++C8D6 28 17                                jr      z,.LL119
 202++C8D8 32 61 69     .X1isNegative:          ld      (varS),a                    ;  Otherwise x1_hi is negative, i.e. off the left of the screen, so set S = x1_hi
 203++C8DB E5 D5 C5                             push    hl,,de,,bc
 204++C8DE CD 54 C9                             call    LL120                       ;  Call LL120 to calculate:   (Y X) = (S x1_lo) * XX12+2      if T = 0   = x1 * gradient
 205++C8E1                                                                          ;                             (Y X) = (S x1_lo) / XX12+2      if T <> 0  = x1 / gradient
 206++C8E1                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
 207++C8E1 C1 D1 E1                             pop    hl,,de,,bc                   ;  get coordinates back
 208++C8E4 2A 87 C7                             ld      hl,(varYX)
 209++C8E7 09                                   add     hl,bc                       ; y1 = y1 + varYX
 210++C8E8 44 4D                                ld      bc,hl
 211++C8EA 21 00 00                             ld      hl,0                        ; Set x1 = 0
 212++C8ED 18 1A                                jr      .LL134                      ; in BBC is set x to 0 to force jump, we will just jump
 213++C8EF FE 00        .LL119:                 cp      0
 214++C8F1 28 16                                jr      z,.LL134                    ;  If x1_hi = 0 then jump down to LL134 to skip the following, as the x-coordinate is already on-screen (as 0 <= (x_hi x_lo) <= 255)
 215++C8F3 3D                                   dec     a
 216++C8F4 32 61 69                             ld      (varS),a                    ;  Otherwise x1_hi is positive, i.e. x1 >= 256 and off the right side of the screen, so set S = x1_hi - 1
 217++C8F7 E5 D5 C5                             push    hl,,de,,bc
 218++C8FA CD 54 C9                             call    LL120                      ;  Call LL120 to calculate: (Y X) = (S x1_lo) * XX12+2      if T = 0  = (x1 - 256) * gradient
 219++C8FD                                                                          ;                           (Y X) = (S x1_lo) / XX12+2      if T <> 0 = (x1 - 256) / gradient
 220++C8FD                                                                          ;  with the sign of (Y X) set to the opposite of theline's direction of slope
 221++C8FD C1 D1 E1                             pop     hl,,de,,bc
 222++C900 2A 87 C7                             ld      hl,(varYX)
 223++C903 09                                   add     hl,bc                        ;OPTIMISATION 6/11/21 simplfied post debug
 224++C904 44 4D                                ld      bc,hl                        ;OPTIMISATION 6/11/21 simplfied post debug
 225++C906 21 FF 00                             ld      hl,255                      ; Set x1 = 255
 226++C909              ; We have moved the point so the x-coordinate is on screen (i.e. in the range 0-255), so now for they-coordinate
 227++C909 78           .LL134:                 ld      a,b                         ; If y1_hi is positive, jump down to LL135  to skip the following
 228++C90A ED 27 80                             test    $80                         ;
 229++C90D 28 1A                                jr      z,.LL135                    ;
 230++C90F 32 61 69                             ld      (varS),a                    ; Otherwise y1_hi is negative, i.e. off the top of the screen, so set S = y1_hi
 231++C912 79                                   ld      a,c                         ; Set R = y1_lo
 232++C913 32 60 69                             ld      (varR),a                    ;
 233++C916 E5 D5 C5                             push    hl,,de,,bc
 234++C919 CD B5 C9                             call    LL123                       ;  Call LL123 to calculate: (Y X) = (S R) / XX12+2      if T = 0  = y1 / gradient
 235++C91C                                                                          ;                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
 236++C91C                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
 237++C91C C1 D1 E1                             pop     hl,,de,,bc
 238++C91F D5                                   push    de
 239++C920 EB                                   ex      hl,de                       ; de = x1
 240++C921 2A 87 C7                             ld      hl,(varYX)                  ; hl = varYX
 241++C924 19                                   add     hl,de                       ; we don't need to swap back as its an add, Set x1 = x1 + (Y X)
 242++C925 D1                                   pop     de                          ; de = x2 again
 243++C926 01 00 00                             ld      bc,0                        ; Set y1 = 0
 244++C929 79           .LL135:                 ld      a,c                         ; if bc < 128 then no work to do
 245++C92A E6 80                                and     $80
 246++C92C B0                                   or      b                           ; here we see if c bit 8 is set or anything in b as we know if its 0 this would mean there is no need to clip
 247++C92D C8                                   ret     z
 248++C92E E5                                   push    hl
 249++C92F 60 69                                ld      hl,bc
 250++C931 01 80 00                             ld      bc,128
 251++C934 B7                                   or      a
 252++C935 ED 42                                sbc     hl,bc                       ; hl =  (S R) = (y1_hi y1_lo) - 128
 253++C937 22 60 69                             ld      (varRS), hl                 ; and now RS (or SR)
 254++C93A 7C                                   ld      a,h
 255++C93B E1                                   pop     hl
 256++C93C ED 27 80                             test    $80                         ; If the subtraction underflowed, i.e. if y1 < 192, then y1 is already on-screen, so jump to LL136 to return from the subroutine, as we are done
 257++C93F C0                                   ret     nz
 258++C940              ; If we get here then y1 >= 192, i.e. off the bottom of the screen
 259++C940 E5 D5 C5     .LL139:                 push    hl,,de,,bc
 260++C943 CD B5 C9                             call    LL123                       ;  Call LL123 to calculate: (Y X) = (S R) / XX12+2      if T = 0  = y1 / gradient
 261++C946                                                                          ;                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
 262++C946                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
 263++C946 C1 D1 E1                             pop     hl,,de,,bc
 264++C949 D5                                   push    de
 265++C94A EB                                   ex      hl,de
 266++C94B 2A 87 C7                             ld      hl,(varYX)
 267++C94E 19                                   add     hl,de                       ; we don't need to swap back as its an add, Set x1 = x1 + (Y X)
 268++C94F 01 7F 00                             ld      bc,127                      ; set bc to 127 bottom of screen
 269++C952 D1                                   pop     de
 270++C953 C9           .LL136:                 ret                                 ;  Return from the subroutine
 271++C954                      ENDIF
 272++C954
 273++C954              ; Calculate the following:   * If T = 0  (more vertical than horizontal), (Y X) = (S x1_lo) * XX12+2
 274++C954              ;                            * If T <> 0 (more horizontal than vertical), (Y X) = (S x1_lo) / XX12+2
 275++C954              ;                              giving (Y X) the opposite sign to the slope direction in XX12+3.
 276++C954              ; Other entry points        LL122                Calculate (Y X) = (S R) * Q and set the sign to the opposite of the top byte on the stack
 277++C954 7D           LL120:                  ld      a,l                          ; Set R = x1_lo
 278++C955 32 60 69                             ld      (varR),a
 279++C958 CD 12 CA                             call    LL129                        ;  Call LL129 to do the following:  Q = XX12+2   = line gradient  A = S EOR XX12+3 = S EOR slope direction (S R) = |S R| So A contains the sign of S * slope direction
 280++C95B F5                                   push    af                           ;  Store A on the stack so we can use it later
 281++C95C C5                                   push    bc
 282++C95D 47                                   ld      b,a
 283++C95E 3A 7B 69                             ld      a,(varT)                     ; instead : (Y X) = (S R ) / Q
 284++C961 FE 00                                cp      0
 285++C963 78                                   ld      a,b
 286++C964 C1                                   pop     bc                           ; we can't use af as that would disrupt the flags
 287++C965 C2 7C C9                             jp      nz, .LL121
 288++C968              ; The following calculates:  (Y X) = (S R) * Q using the same shift-and-add algorithm that's documented in MULT1
 289++C968 3A 82 C7     .LL122:                  ld      a,(clipGradient)
 290++C96B 32 5F 69                             ld      (varQ),a; optimise
 291++C96E CD 7F 6D                             call    HLequSRmulQdiv256
 292++C971 22 87 C7                             ld      (varYX),hl
 293++C974 F1                                   pop     af
 294++C975 ED 27 80                             test    $80
 295++C978 CA A8 C9                             jp      z,.LL133
 296++C97B C9                                   ret
 297++C97C 11 FE FF     .LL121:                  ld      de,$FFFE                    ; set XY to &FFFE at start, de holds XY
 298++C97F 2A 60 69                             ld      hl,(varRS)                  ; hl = RS
 299++C982 3A 5F 69                             ld      a,(varQ)
 300++C985 47                                   ld      b,a                         ; b = q
 301++C986              .LL130:                 ShiftHLLeft1                        ; RS *= 2
 301++C986 CB 25       >			   sla l
 301++C988 CB 14       >			   rl  h
 302++C98A 7C                                   ld      a,h
 303++C98B 38 04                                jr      c,.LL131                    ; if S overflowed skip Q test and do subtractions
 304++C98D                                      JumpIfALTNusng b, .LL132            ; if S <  Q = 256/gradient skip subtractions
 304++C98D B8          >                        cp      b
 304++C98E DA 99 C9    >                        jp		c, .LL132
 305++C991 3F           .LL131:                 ccf                                 ; compliment carry
 306++C992 98                                   sbc     a,b                         ; q
 307++C993 67                                   ld      h,a                         ; h (s)
 308++C994 7D                                   ld      a,l                         ; r
 309++C995 DE 00                                sbc     a,0                         ; 0 - so in effect SR - Q*256
 310++C997 37                                   scf                                 ; set carry for next rolls
 311++C998 3F                                   ccf
 312++C999              .LL132:                 RollDELeft1                         ; Rotate de bits left
 312++C999 CB 13       >               rl  e
 312++C99B CB 12       >               rl  d
 313++C99D 38 E7                                jr      c,.LL130                    ;
 314++C99F ED 53 87 C7                          ld      (varYX),de
 315++C9A3 F1                                   pop     af              ; get back sign
 316++C9A4 ED 27 80                             test    $80
 317++C9A7 C8                                   ret     z               ; if negative then return with value as is reversed sign
 318++C9A8 2A 87 C7     .LL133:                 ld      hl,(varYX)      ; may not actually need this?
 319++C9AB                                      NegHL
 319++C9AB AF          >                    xor a
 319++C9AC 95          >                    sub l
 319++C9AD 6F          >                    ld l,a
 319++C9AE 9F          >                    sbc a,a
 319++C9AF 94          >                    sub h
 319++C9B0 67          >                    ld h,a
 320++C9B1 22 87 C7                             ld      (varYX),hl
 321++C9B4 C9           .LL128:                 ret
 322++C9B5
 323++C9B5
 324++C9B5
 325++C9B5
 326++C9B5              ; Calculate the following: * If T = 0,  calculate (Y X) = (S R) / XX12+2 (actually SR & XX12+2 /256)
 327++C9B5              ;                          * If T <> 0, calculate (Y X) = (S R) * XX12+2
 328++C9B5              ;                          giving (Y X) the opposite sign to the slope direction in XX12+3.
 329++C9B5              ;
 330++C9B5              ; Other entry points:      LL121                Calculate (Y X) = (S R) / Q and set the sign to the opposite of the top byte on the stack
 331++C9B5              ;                          LL133                Negate (Y X) and return from the subroutine
 332++C9B5              ;                          LL128                Contains an RTS
 333++C9B5 CD 12 CA     LL123:                  call    LL129                       ; Call LL129 to do the following: Q = XX12+2   = line gradient  A = S EOR XX12+3 = S EOR slope direction (S R) = |S R| So A contains the sign of S * slope direction
 334++C9B8 F5                                   push    af                          ; Store A on the stack so we can use it later
 335++C9B9 C5                                   push    bc                          ; If T is non-zero, so it's more horizontal than vertical, jump down to LL121 to calculate this
 336++C9BA 47                                   ld      b,a
 337++C9BB 3A 7B 69                             ld      a,(varT)                    ; instead : (Y X) = (S R) * Q *** this looks to be the wrong way roudn for Y!!!!
 338++C9BE FE 00                                cp      0
 339++C9C0 78                                   ld      a,b
 340++C9C1 C1                                   pop     bc
 341++C9C2 C2 FE C9                             jp      nz, .LL122
 342++C9C5              ; The following calculates: (Y X) = (S R) / Q using the same shift-and-subtract algorithm that's documented in TIS2, its actually X.Y=R.S*256/Q
 343++C9C5 11 FE FF     .LL121:                 ld      de,$FFFE                    ; set XY to &FFFE at start, de holds XY
 344++C9C8 2A 60 69                             ld      hl,(varRS)                  ; hl = RS
 345++C9CB 3A 5F 69                             ld      a,(varQ)
 346++C9CE 47                                   ld      b,a                         ; b = q
 347++C9CF              .LL130:                 ShiftHLLeft1                        ; RS *= 2
 347++C9CF CB 25       >			   sla l
 347++C9D1 CB 14       >			   rl  h
 348++C9D3 7C                                   ld      a,h
 349++C9D4 38 04                                jr      c,.LL131                    ; if S overflowed skip Q test and do subtractions
 350++C9D6                                      JumpIfALTNusng b, .LL132            ; if S <  Q = 256/gradient skip subtractions
 350++C9D6 B8          >                        cp      b
 350++C9D7 DA E2 C9    >                        jp		c, .LL132
 351++C9DA 3F           .LL131:                 ccf                                 ; compliment carry
 352++C9DB 98                                   sbc     a,b                         ; q
 353++C9DC 67                                   ld      h,a                         ; h (s)
 354++C9DD 7D                                   ld      a,l                         ; r
 355++C9DE DE 00                                sbc     a,0                         ; 0 - so in effect SR - Q*256
 356++C9E0 37                                   scf                                 ; set carry for next rolls
 357++C9E1 3F                                   ccf
 358++C9E2              .LL132:                 RollDELeft1                         ; Rotate de bits left
 358++C9E2 CB 13       >               rl  e
 358++C9E4 CB 12       >               rl  d
 359++C9E6 38 E7                                jr      c,.LL130                    ;
 360++C9E8 ED 53 87 C7                          ld      (varYX),de
 361++C9EC F1                                   pop     af              ; get back sign
 362++C9ED ED 27 80                             test    $80
 363++C9F0 C8                                   ret     z               ; if negative then return with value as is reversed sign
 364++C9F1 2A 87 C7     .LL133:                 ld      hl,(varYX)      ; may not actually need this?
 365++C9F4                                      NegHL
 365++C9F4 AF          >                    xor a
 365++C9F5 95          >                    sub l
 365++C9F6 6F          >                    ld l,a
 365++C9F7 9F          >                    sbc a,a
 365++C9F8 94          >                    sub h
 365++C9F9 67          >                    ld h,a
 366++C9FA 22 87 C7                             ld      (varYX),hl
 367++C9FD C9           .LL128:                 ret
 368++C9FE              ; The following calculates:  (Y X) = (S R) * Q using the same shift-and-add algorithm that's documented in MULT1
 369++C9FE 3A 82 C7     .LL122:                 ld      a,(clipGradient)
 370++CA01 32 5F 69                             ld      (varQ),a; optimise
 371++CA04 CD 7F 6D                             call    HLequSRmulQdiv256
 372++CA07 22 87 C7                             ld      (varYX),hl
 373++CA0A F1                                   pop     af
 374++CA0B ED 27 80                             test    $80
 375++CA0E CA F1 C9                             jp      z,.LL133
 376++CA11 C9                                   ret
 377++CA12
 378++CA12              ; Do the following, in this order:  Q = XX12+2
 379++CA12              ;                                   A = S EOR XX12+3
 380++CA12              ;                                   (S R) = |S R|
 381++CA12              ; This sets up the variables required above to calculate (S R) / XX12+2 and give the result the opposite sign to XX13+3.
 382++CA12 3A 82 C7     LL129:                  ld      a,(clipGradient)
 383++CA15 32 5F 69                             ld      (varQ),a                    ; Set Q = XX12+2
 384++CA18 3A 61 69                             ld      a,(varS)                    ; If S is positive, jump to LL127
 385++CA1B E5 F5                                push    hl,,af                      ; else
 386++CA1D ED 27 80                             test    $80                         ;   if bit 7 is clear
 387++CA20 28 0C                                jr      z,.LL127                    ;      RS = ABS RS
 388++CA22 2A 60 69                             ld      hl,(varRS)                  ;      .
 389++CA25                                      NegHL                               ;      .
 389++CA25 AF          >                    xor a
 389++CA26 95          >                    sub l
 389++CA27 6F          >                    ld l,a
 389++CA28 9F          >                    sbc a,a
 389++CA29 94          >                    sub h
 389++CA2A 67          >                    ld h,a
 390++CA2B 22 60 69                             ld      (varRS),hl                  ;      .
 391++CA2E 21 83 C7     .LL127:                 ld      hl,clipDxySign              ;   hl = dxy sign
 392++CA31 F1                                   pop     af                          ;
 393++CA32 AE                                   xor     (hl)                        ; a = S XOR clipDxySign
 394++CA33 E1                                   pop     hl
 395++CA34 C9                                   ret
 396++CA35
 397++CA35              ;--------------------------------------------------------------------------------------
 398++CA35              ; Thow away out of bounds by more than 250
 399++CA35              ClipLineV3:             ;break
 400++CA35                      IFDEF       CLIPVersion3
 401++CA35 ~            ;My logic version
 402++CA35 ~            .CheckYorder:
 403++CA35 ~                                    ld      hl,(UbnkPreClipY1)
 404++CA35 ~                                    ld      de,(UbnkPreClipY2)
 405++CA35 ~                                    call    CompareHLDESgn
 406++CA35 ~                                    jr      c,.LineP1toP2                          ; if Y1 < Y2 then we can use the points as is else we have to swap
 407++CA35 ~            .LineP2toP1:            ld      bc,(UbnkPreClipY2)                      ; fetch and write out in reverse
 408++CA35 ~                                    ld      ix,(UbnkPreClipY1)
 409++CA35 ~                                    ld      de,(UbnkPreClipX1)
 410++CA35 ~                                    ld      hl,(UbnkPreClipX2)
 411++CA35 ~                                    ld      (UbnkPreClipY1),bc                      ; bc - XX15(2,3) Y1
 412++CA35 ~                                    ld      (UbnkPreClipY2),ix                      ; ix - XX12(0,1) Y2
 413++CA35 ~                                    ld      (UbnkPreClipX1),hl                      ; hl - XX15(0,1) X1
 414++CA35 ~                                    ld      (UbnkPreClipX2),de                      ;  de - XX15(4,5) X2
 415++CA35 ~                                    jp      .CheckNoClip
 416++CA35 ~            .LineP1toP2             ld      bc,(UbnkPreClipY1)                      ; bc - XX15(2,3) Y1
 417++CA35 ~                                    ld      ix,(UbnkPreClipY2)                      ; ix - XX12(0,1) Y2
 418++CA35 ~                                    ld      hl,(UbnkPreClipX1)                      ; hl - XX15(0,1) X1
 419++CA35 ~                                    ld      de,(UbnkPreClipX2)                      ; de - XX15(4,5) X2
 420++CA35 ~            .CheckNoClip:           ld      a,b
 421++CA35 ~                                    or      d
 422++CA35 ~                                    or      h
 423++CA35 ~                                    or      ixh
 424++CA35 ~                                    jp      nz,.CheckXOffScreen                 ; if both Y1 and y2 have bit 7 set
 425++CA35 ~                                    ld      a,c                                 ; then we clip
 426++CA35 ~                                    and     ixl
 427++CA35 ~                                    test    $80
 428++CA35 ~                                    jp      z, .ClipComplete
 429++CA35 ~            ;if either x1hi x2hi are 0 then we clip. if both <> 0and both same sign exit
 430++CA35 ~            .CheckXOffScreen:       ld      a,h
 431++CA35 ~                                    xor     d
 432++CA35 ~                                    test    $80                                 ; non descructive test of bit 7 is set
 433++CA35 ~                                    jp      nz,.X1X2OppositeSign                ; if bit 7 was set then x1 and x2 must be opposite signs so its on screen
 434++CA35 ~            .X1X2SameSigns:         ld      a,h                                 ; so to get there h and d must be the same sign
 435++CA35 ~                                    test    $80                                 ; if they are the same sign and at x1 is negative then x2 must be negative so off screen
 436++CA35 ~                                    JumpIfAIsZero .X1X2CheckIfBothRight
 437++CA35 ~            .X1X2BothNegative:      SetCarryFlag                                ; to get to here x1 and x2 must be high and off the same sign so its not to draw
 438++CA35 ~                                    ret
 439++CA35 ~            .X1X2CheckIfBothRight:  and     a                                   ; we have h in a already
 440++CA35 ~                                    jr      z,.X1OnScreen
 441++CA35 ~                                    ld      a,d
 442++CA35 ~                                    and     a
 443++CA35 ~                                    jr      z,.X2OnScreen
 444++CA35 ~            .X1X2OffRightSide:      SetCarryFlag                                ; to get to here x1 and x2 must be high and off the same sign so its not to draw
 445++CA35 ~                                    ret
 446++CA35 ~            ;                       to get to here x1 and x2 either span -ve to +ve or from on screen to off screen
 447++CA35 ~            .X1OnScreen:
 448++CA35 ~            .X2OnScreen:
 449++CA35 ~            .X1X2OppositeSign:
 450++CA35 ~            ;                       Now check to see if Y is off screen
 451++CA35 ~            .CheckYOffScreen:       ld      a,b                                     ; Check if y1 and y2 are opposite signs, fi so it spans screen so we are good
 452++CA35 ~            .CheckBothYNegative:    xor     ixh
 453++CA35 ~                                    test    $80                                     ; if bit 7 is set then opposite signs
 454++CA35 ~                                    jp      nz,.Y1Y2OppositeSign                    ; if y1 and y2 are opposite signs its on screen and spans at least one side
 455++CA35 ~            .Y1Y2SameSign:          ld      a,b                                     ; if they are the same sign then if one is negative, so is the other so off screen
 456++CA35 ~                                    test    $80
 457++CA35 ~                                    jp      z,.Y1Y2Positive
 458++CA35 ~            .Y1Y2Negative:          SetCarryFlag
 459++CA35 ~                                    ret
 460++CA35 ~            .Y1Y2Positive:          ld      a,c                                     ; if its the same sign y1 or y2 could be 0 and if they are
 461++CA35 ~                                    and     $80                                     ; this will test to see if b >0 or c > 127
 462++CA35 ~                                    or      b                                       ;
 463++CA35 ~                                    jp      z,.Y1OnScreen
 464++CA35 ~                                    ld      a,ixl
 465++CA35 ~                                    and     $80
 466++CA35 ~                                    or      ixh
 467++CA35 ~                                    jp      z,.Y2OnScreen
 468++CA35 ~            .Y1Y2OffBottomSide:     SetCarryFlag
 469++CA35 ~                                    ret
 470++CA35 ~            .Y1OnScreen:
 471++CA35 ~            .Y2OnScreen:
 472++CA35 ~            .Y1Y2OppositeSign:
 473++CA35 ~            .StartProcessing:       ld      hl,(UbnkPreClipX1)                      ; Now we can test and Clip
 474++CA35 ~                                    ld      de,(UbnkPreClipX2)                      ; de - XX15(4,5)
 475++CA35 ~                                    ld      iyh,0                                   ; set iyh flags to 0
 476++CA35 ~            ; if x1hi or y1 high <> 0 or y1 > 127 then set bit 1 of clipcoord       ; we can optimise this later
 477++CA35 ~                                    ld      a,h
 478++CA35 ~                                    or      b
 479++CA35 ~                                    jr      z,.CheckP1Ylo
 480++CA35 ~            ;                       iyh     bit 0 - P1 Needs Clipping
 481++CA35 ~            ;                               bit 1 - P2 Needs Clipping
 482++CA35 ~            ;                               bit 2 - x1 >= x2 (left to right)
 483++CA35 ~            ;                               bit 3 - y1 >= y2 (top to bottom)
 484++CA35 ~            ;                               bit 4 -  DY/DX (steep)
 485++CA35 ~            .P1OffScreen:           ld      iyh,1                                   ; if either p1 x or y was off screen set bit 0 to 1
 486++CA35 ~                                    jp      .CheckP2OffScreen                       ; .
 487++CA35 ~            .CheckP1Ylo:            ld      a,c                                     ; .
 488++CA35 ~                                    and     $80                                     ; .
 489++CA35 ~                                    jr      z,.CheckP2OffScreen                     ; .
 490++CA35 ~                                    ld      iyh,1                                   ; .
 491++CA35 ~            .CheckP2OffScreen:      ld      a,d                                     ; if x2hi or y2 off screen then set bit 2 of clipcoord to 1
 492++CA35 ~                                    or      ixh                                     ; .
 493++CA35 ~                                    jr      z,.CheckP2Ylo                           ; .
 494++CA35 ~            .P2OffScreen:           ld      a,iyh                                   ; .
 495++CA35 ~                                    or      2                                       ; .
 496++CA35 ~                                    ld      iyh,a                                   ; .
 497++CA35 ~                                    jp      .CheckXDirection                        ; .
 498++CA35 ~            .CheckP2Ylo:            ld      a,ixl                                   ; .
 499++CA35 ~                                    and     $80                                     ; .
 500++CA35 ~                                    jr      z,.CheckXDirection                      ; .
 501++CA35 ~                                    ld      a,iyh                                   ; .
 502++CA35 ~                                    or      2                                       ; .
 503++CA35 ~                                    ld      iyh,a                                   ; .
 504++CA35 ~            .CheckXDirection:       push    de,,hl
 505++CA35 ~                                    call    CompareHLDESgn                          ; IF HL equals DE, Z=1,C=0, IF HL is less than DE, Z=0,C=1, IF HL is more than DE, Z=0,C=0
 506++CA35 ~                                    pop     de,,hl
 507++CA35 ~                                    jp      c,.CalculateDx                          ;
 508++CA35 ~            .X1gteX2:               ld      a,iyh                                   ; if x1 >= x2 then set bit 3 to denote -ve x direction, note we will eliminate horziontal / vertical early as an optimisation
 509++CA35 ~                                    or      4                                       ; .
 510++CA35 ~                                    ld      iyh,a                                   ; .
 511++CA35 ~                                    ; Y Direction is now always top to bottom
 512++CA35 ~            .CalculateDx:           ClearCarryFlag                                  ;                       calculate DX
 513++CA35 ~                                    sbc     hl,de                                   ; .
 514++CA35 ~            .ABSDX:                 ld      a,h                                     ; HL = | HL - DE |
 515++CA35 ~                                    test    $80                                     ; .
 516++CA35 ~                                    jr      z,.DXPositive                           ; .
 517++CA35 ~                                    macronegate16hl                                 ; .
 518++CA35 ~            .DXPositive:            ex      de,hl                                   ; de = abs delta x
 519++CA35 ~            .CalculateDy:           ClearCarryFlag                                  ; hl = Y2 -Y1 as its pre sorted its always positive if on screen
 520++CA35 ~                                    ld      hl,ix                                   ; iy = hl = Y2 - Y1
 521++CA35 ~                                    sbc     hl,bc                                   ; .
 522++CA35 ~            .DYPositive:            ; Scale DX and DY to 8 bit, by here hl = abs dy, de = abs dx
 523++CA35 ~            ;calculate DY
 524++CA35 ~            .ScaleLoop:             ld      a,h                                     ; At this point DX and DY are ABS values
 525++CA35 ~                                    or      d                                       ; .
 526++CA35 ~                                    jr      z,.ScaleDone                            ; .
 527++CA35 ~                                    ShiftDERight1                                   ; .
 528++CA35 ~                                    ShiftHLRight1                                   ; .
 529++CA35 ~                                    jr      .ScaleLoop                              ; scaled down Dx and Dy to 8 bit, Dy may have been;;                                                                                               negative
 530++CA35 ~            .ScaleDone:             ; hl = ABS DY, DE = ABS DX,  bc = Y1, ix = Y2,   note H and D will be zero
 531++CA35 ~            ; if Dx = 0 then horizontal line and clip X1 & X2 only then exit
 532++CA35 ~            ; if Dy = 0 then vertical line and clip Y1 & Y2 only then exit
 533++CA35 ~
 534++CA35 ~            ; if DX < DY  gradient = 256 * delta_x_lo / delta_y_lo
 535++CA35 ~            ;        else gradient = 256 * delta_y_lo / delta_x_lo, set bit 5 of clipcord
 536++CA35 ~            .CalculateDelta:        ld      a,e                                     ; if DX < DY goto DX/DY
 537++CA35 ~                                    JumpIfALTNusng l,.DXdivDY                       ; else do DY/DX
 538++CA35 ~            .DYdivDX:               ld      a,l                                     ;    A = DY
 539++CA35 ~                                    ld      d,e                                     ;    D = DX
 540++CA35 ~                                    call    AEquAmul256DivD                         ;    A = R = 256 * DY / DX
 541++CA35 ~            .SaveGradientDYDX:      ld      (Gradient),a
 542++CA35 ~                                    ld      a,iyh                                   ;    bit 5 of iyh denotes that its a DX/DY (steep), if its clear its DY/DX (shallow)
 543++CA35 ~                                    or      16                                      ;    .
 544++CA35 ~                                    ld      iyh,a                                   ;    .
 545++CA35 ~                                    jp      .ClipP1                                 ;    .
 546++CA35 ~            .DXdivDY:               ld      a,e                                     ;    A = DX
 547++CA35 ~                                    ld      d,l                                     ;    D = DY
 548++CA35 ~                                    call    AEquAmul256DivD                         ;    A = R = 256 * DX / DY
 549++CA35 ~            .SaveGradientDXDY:      ld      (Gradient),a
 550++CA35 ~            ; if bit 1 of clipccord is set call    LL118
 551++CA35 ~            .ClipP1:                ld      a,iyh                                   ; if bit 1 is clear to say no need to clip pont 1 we just jump to point 2
 552++CA35 ~                                    test    1                                       ; .
 553++CA35 ~                                    jp      z,.ClipP2                               ; .
 554++CA35 ~                                    call    LL118v3                                 ; else clip P1 first
 555++CA35 ~                                    ld      a,b                                     ;      and if b or h have a value its failed to totally clip  as it may be only in bounds on just x or y
 556++CA35 ~                                    or      h                                       ;      .
 557++CA35 ~                                    jr      z, .P1Ygt127Check                       ;      .
 558++CA35 ~            .P1HighOutofBounds:     SetCarryFlag                                    ;      .
 559++CA35 ~                                    ret                                             ;      .
 560++CA35 ~            .P1Ygt127Check:         ld      a,c                                     ;      or if y > 127 its failed to totally clip
 561++CA35 ~                                    test    $80                                     ;      .
 562++CA35 ~                                    SetCarryFlag                                    ;      .
 563++CA35 ~                                    ret     nz                                      ;      .
 564++CA35 ~                                    ld      (UbnkPreClipY1), bc                     ;      else its valid and clipped point 1 so save ti back
 565++CA35 ~                                    ld      (UbnkPreClipX1), hl
 566++CA35 ~            ; if bit 2 of clipcoord is set
 567++CA35 ~            ;        swap x1y1 with x2y2
 568++CA35 ~            ;        call    LL118
 569++CA35 ~            .ClipP2:                ld      a,iyh                                   ; so now repeat all that for point 2
 570++CA35 ~                                    and     2
 571++CA35 ~                                    jp      z,.ClipComplete
 572++CA35 ~                                    call    LL118v3PreSwap                          ; now clip p2
 573++CA35 ~                                    ld      a,b                                     ; if either high is set then it failed to properly clip
 574++CA35 ~                                    or      h                                       ; .
 575++CA35 ~                                    jr      z, .P2Ygt127Check                       ; .
 576++CA35 ~            .P2HighOutofBounds:     SetCarryFlag                                    ; .
 577++CA35 ~                                    ret                                             ; .
 578++CA35 ~            .P2Ygt127Check:         ld      a,c                                     ; if c > 127 then it also failed to clip
 579++CA35 ~                                    test    $80                                     ; .
 580++CA35 ~                                    SetCarryFlag                                    ; .
 581++CA35 ~                                    ret     nz                                      ; .
 582++CA35 ~                                    ld      (UbnkPreClipY2), bc                     ; bc - XX15(2,3);;
 583++CA35 ~                                    ld      (UbnkPreClipX2), hl
 584++CA35 ~            ;clip compelte exit
 585++CA35 ~            .ClipComplete:          ld      bc,(UbnkPreClipY1)                      ; bc - XX15(2,3);;
 586++CA35 ~                                    ld      hl,(UbnkPreClipX1)
 587++CA35 ~                                    ld      ix,(UbnkPreClipY2)                      ; bc - XX15(2,3);;
 588++CA35 ~                                    ld      de,(UbnkPreClipX2)
 589++CA35 ~            .SaveClippedLine:       ld      a,c                                     ; Y1 = y1 lo, x2 = x2 lo, x1 = x1 lo y1 = y1 lo                                   -- Nothing off screen
 590++CA35 ~                                    ld      (UBnkNewY1),a
 591++CA35 ~                                    ld      a,ixl
 592++CA35 ~                                    ld      (UBnkNewY2),a
 593++CA35 ~                                    ld      a,l
 594++CA35 ~                                    ld      (UBnkNewX1),a
 595++CA35 ~                                    ld      a,e
 596++CA35 ~                                    ld      (UBnkNewX2),a
 597++CA35 ~                                    ClearCarryFlag                              ; we have a success so not carry
 598++CA35 ~                                    ret
 599++CA35 ~            ;-----------------------------------------------------------------------------------------------------------------------------------
 600++CA35 ~            LL118v3PreSwap:         ld      bc,(UbnkPreClipY2)                  ; bc - XX15(2,3);;
 601++CA35 ~                                    ld      hl,(UbnkPreClipX2)
 602++CA35 ~                                    jp      LL118v3Fetched
 603++CA35 ~            ;-----------------------------------------------------------------------------------------------------------------------------------
 604++CA35 ~            LL118v3:                ld      bc,(UbnkPreClipY1)                  ; bc - XX15(2,3);;
 605++CA35 ~                                    ld      hl,(UbnkPreClipX1)
 606++CA35 ~            ;-----------------------------------------------------------------------------------------------------------------------------------
 607++CA35 ~            LL118v3Fetched:
 608++CA35 ~            ;                       At this point bc = y position, hl = x position both 16 bit
 609++CA35 ~            ;                       if x < 0 then x = 0
 610++CA35 ~            ;                                     adjust = -x */ gradient depending on if its steep or shallow
 611++CA35 ~            ;                                     y = y +- adjust depending on if we are going +ve direction or negative direction  (or simplify it, that it will always be + for x1y1 and - for x2y2 as we pre-sort)
 612++CA35 ~            ;                       if x > 255 then x = 255
 613++CA35 ~            ;                                     adjust = x-255 */ gradient
 614++CA35 ~            ;                                     y = y +- adjust depending on if we are going +ve direction or negative direction  (or simplify it, that it will always be + for x1y1 and - for x2y2 as we pre-sort)
 615++CA35 ~            ;                       if y < 0 then y = 0
 616++CA35 ~            ;                                     adjust = -y */ gradient
 617++CA35 ~            ;                                     x = x +- adjust depending on if we are going left to right or visa versa
 618++CA35 ~            ;                       if y >127 then y = 127
 619++CA35 ~            ;                                     adjust = y-127 */ gradient
 620++CA35 ~            ;                                     x = x +- adjust depending on if we are going left to right or visa versa
 621++CA35 ~            ;
 622++CA35 ~            ;                       iyh     bit 0 - P1 Needs Clipping
 623++CA35 ~            ;                               bit 1 - P2 Needs Clipping
 624++CA35 ~            ;                               bit 2 - x1 >= x2 (left to right)
 625++CA35 ~            ;                               bit 3 - y1 >= y2 (top to bottom)
 626++CA35 ~            ;                               bit 4 -  DY/DX (steep)
 627++CA35 ~            ; if X1 hi <> 0
 628++CA35 ~            LL118:                  ;break
 629++CA35 ~                                    ld      a,h                                     ; if x1 high is 0 then we don't need to clip x at all
 630++CA35 ~                                    and     a
 631++CA35 ~                                    jp      z,.X1NoClipNeeded
 632++CA35 ~            ;                       if x1 hi bit 7 is set (so negative)
 633++CA35 ~            .CalcBlockX:            test    $80                                     ; if h is postiive then jump to the XPositive Calc block
 634++CA35 ~                                    jr      z,.CalcBlockXPositive
 635++CA35 ~            ;                       if clipccord bit 5 is set Adjust = abs(X1) / Gradient (may need to swap bit check?)
 636++CA35 ~            .CalcBlockXNegative:    ld      a,iyh                                   ;
 637++CA35 ~                                    test    16                                      ; bit 5 of iyh denotes that its a DY/DX, if its clear its DX/DY
 638++CA35 ~                                    jr      nz,.CalcBlockXNegMulGrad
 639++CA35 ~            .CaclBlockXNegDivGrad:  macronegate16hl
 640++CA35 ~                                    ld      a,(Gradient)
 641++CA35 ~                                    push    bc                                      ; abs(X1) / Gradient
 642++CA35 ~                                    ld      h,c                     ; move offset into high byte of h
 643++CA35 ~                                    ld      l,0
 644++CA35 ~                                    ld      c,a
 645++CA35 ~                                    call    div_hl_c
 646++CA35 ~                                    pop     bc
 647++CA35 ~                                    jp      .DoneXNegCalc
 648++CA35 ~            ;                       else set Adjust = abs(X1) * Gradient
 649++CA35 ~            .CalcBlockXNegMulGrad:  push    bc                                      ; abs(X1) * Gradient
 650++CA35 ~                                    macronegate16hl
 651++CA35 ~                                    ld      a,(Gradient)
 652++CA35 ~                                    call    HLeqyHLmulAdiv256
 653++CA35 ~                                    pop     bc
 654++CA35 ~            ;                       y1 += adjust * (-1 if bit 4 of clipcoord is set)
 655++CA35 ~            ;                       x1 = 0 then call into DonrX1Calc
 656++CA35 ~            ;                       we can skip the test for negative Y direection
 657++CA35 ~            .DoneXNegCalc:          macronegate16hl
 658++CA35 ~            .XNegSkipNegate:        ld      de,bc
 659++CA35 ~                                    ex      hl,de
 660++CA35 ~                                    add     hl,de
 661++CA35 ~                                    ld      bc,hl
 662++CA35 ~                                    ld      hl,0
 663++CA35 ~                                    jp      .DoneXCalc
 664++CA35 ~            ;                       else x1 hi is positive
 665++CA35 ~            ;                       if clipccord bit 5 is set Adjust = X1 lo / Gradient (may need to swap bit check?)
 666++CA35 ~            .CalcBlockXPositive:    ld      a,iyh
 667++CA35 ~                                    test    16
 668++CA35 ~                                    jr      nz,.CalcBlockXPosMulGrad
 669++CA35 ~            .CalcBlockXPosDivGrad:  ld      a,(Gradient)            ;Q = gradient
 670++CA35 ~                                    push    bc
 671++CA35 ~                                    ld      c,a
 672++CA35 ~                                    ld      de,255
 673++CA35 ~                                    sub     hl,de
 674++CA35 ~                                    ld      h,l
 675++CA35 ~                                    ld      l,0
 676++CA35 ~                                    call    div_hl_c
 677++CA35 ~                                    pop     bc
 678++CA35 ~                                    jp      .DoneX2Calc
 679++CA35 ~            ;                                 else set Adjust = X1 lo * Gradient
 680++CA35 ~            .CalcBlockXPosMulGrad:  push    bc
 681++CA35 ~                                    ld      a,(Gradient)            ;Q = gradient
 682++CA35 ~                                    ld      de,255
 683++CA35 ~                                    sub     hl,de
 684++CA35 ~                                    call    HLeqyHLmulAdiv256       ; hl = YX = SR / Q
 685++CA35 ~                                    pop     bc
 686++CA35 ~            ;                       y1 += adjust * (-1 if bit 4 of clipcoord is set)
 687++CA35 ~            ;                       x1 = 255
 688++CA35 ~            ;                       we can skip the test for negative Y direection
 689++CA35 ~            .DoneX2Calc:            macronegate16hl
 690++CA35 ~            .X2SkipNegate:          ex      de,hl
 691++CA35 ~                                    ld      hl,bc
 692++CA35 ~                                    add     hl,de
 693++CA35 ~                                    ld      bc,hl
 694++CA35 ~                                    ld      hl,255
 695++CA35 ~            ;                       if Y1 hi <> 0 or Y1 low >= 128 then y coordinate is good
 696++CA35 ~            .DoneXCalc:             ld      a,b
 697++CA35 ~                                    and     a
 698++CA35 ~                                    jr      nz,.CalcBlockY1Test
 699++CA35 ~                                    ld      a,c
 700++CA35 ~                                    and     $80
 701++CA35 ~                                    ClearCarryFlag                  ; speculative clear of carry in case its good
 702++CA35 ~                                    ret     z
 703++CA35 ~            ;                       if Y1 hi bit 7 is set
 704++CA35 ~            .X1NoClipNeeded:
 705++CA35 ~            .CalcBlockY1Test:       ld      a,b
 706++CA35 ~                                    test    $80
 707++CA35 ~                                    jr      z,.CalcBlockYPos       ; if Y is positive jump forward
 708++CA35 ~            ;                       if clipccord bit 5 is set Adjust = abs(Y1) / Gradient (may need to swap bit check?)
 709++CA35 ~                                    break
 710++CA35 ~            .CalcBlockY1:           ld      a,iyh
 711++CA35 ~                                    test    16
 712++CA35 ~                                    jr      nz,.CalcBlockYNegMulGrad
 713++CA35 ~            .CalcBlockYNegDivGrad:  macronegate16bc
 714++CA35 ~                                    ld      a,(Gradient)            ;Q = gradient
 715++CA35 ~                                    push    hl
 716++CA35 ~                                    ld      h,c                     ; move offset into high byte of h
 717++CA35 ~                                    ld      l,0
 718++CA35 ~                                    ld      c,a
 719++CA35 ~                                    call    div_hl_c;LLHLdivC;div_hl_c
 720++CA35 ~                                    pop     de
 721++CA35 ~                                    ex      de,hl
 722++CA35 ~                                    jp      .DoneBlockY1
 723++CA35 ~            ;                                 else set Adjust = abs(Y1) * Gradient
 724++CA35 ~            .CalcBlockYNegMulGrad:  macronegate16bc
 725++CA35 ~                                    push    hl
 726++CA35 ~                                    ld      hl,bc
 727++CA35 ~                                    ld      a,(Gradient)            ;Q = gradient
 728++CA35 ~                                    call    HLeqyHLmulAdiv256       ; hl = YX = SR / Q
 729++CA35 ~                                    pop     de
 730++CA35 ~                                    ex      de,hl
 731++CA35 ~            ;                       x1 += adjust * (-1 if bit 3 of clipcoord is set)
 732++CA35 ~            ;                       y1 = 0
 733++CA35 ~            ;                       ret
 734++CA35 ~            ;                       now we have done the adjustment, if y or x are off screen then the line spans screen in only 1 dimension so doesn't get drawn
 735++CA35 ~            .DoneBlockY1:           ld      a,iyh
 736++CA35 ~                                    test    4
 737++CA35 ~                                    jr      z,.Y1SkipNegate
 738++CA35 ~                                    macronegate16de
 739++CA35 ~            .Y1SkipNegate:          add     hl,de
 740++CA35 ~                                    ld      bc,0
 741++CA35 ~                                    ret
 742++CA35 ~            ;                       if clipccord bit 5 is set Adjust = Y1 lo / Gradient (may need to swap bit check?)
 743++CA35 ~            .CalcBlockYPos:         ld      a,iyh
 744++CA35 ~                                    test    16
 745++CA35 ~                                    jr      z,.CalcBlockYPosMulGrad
 746++CA35 ~            .CalcBlockYPosDivGrad:  ld      a,(Gradient)            ;Q = gradient
 747++CA35 ~                                    push    hl
 748++CA35 ~                                    ld      hl,bc
 749++CA35 ~                                    ld      de,127
 750++CA35 ~                                    sub     hl,de
 751++CA35 ~                                    ld      h,l
 752++CA35 ~                                    ld      l,0
 753++CA35 ~                                    ld      c,a
 754++CA35 ~                                    call    div_hl_c;LLHLdivC
 755++CA35 ~                                    pop     de
 756++CA35 ~                                    ex      de,hl
 757++CA35 ~                                    jp      .DoneBlockY2
 758++CA35 ~            ;                                 else set Adjust = Y1 lo * Gradient
 759++CA35 ~            .CalcBlockYPosMulGrad:  push    hl
 760++CA35 ~                                    ld      hl,bc
 761++CA35 ~                                    ld      de,127
 762++CA35 ~                                    sub     hl,de
 763++CA35 ~                                    ld      a,(Gradient)
 764++CA35 ~                                    call    HLeqyHLmulAdiv256       ; hl = YX = SR / Q
 765++CA35 ~                                    pop     de
 766++CA35 ~                                    ex      de,hl
 767++CA35 ~            ;                x1 += adjust * (-1 if bit 3 of clipcoord is set)
 768++CA35 ~            ;                y1 = 127
 769++CA35 ~            .DoneBlockY2:           ld      a,iyh
 770++CA35 ~                                    test    4
 771++CA35 ~                                    jr      nz,.Y2SkipNegate
 772++CA35 ~                                    macronegate16de
 773++CA35 ~            .Y2SkipNegate:          add     hl,de
 774++CA35 ~                                    ld      bc,127
 775++CA35 ~                                    ret
 776++CA35                      ELSE
 777++CA35 C9                       ret
 778++CA36                      ENDIF
 779++CA36              ; old code for on screen test
 780++CA36              ;;;;;;; if y1 > 127 and y2 > 127 then same sing and exit
 781++CA36              ;;;;;;
 782++CA36              ;;;;;;;if y1hi y2hi are <> 0 and both same sign exit
 783++CA36              ;;;;;;.CheckYOffScreen:       ld      a,b                                 ; y1 and y2 high tests
 784++CA36              ;;;;;;                        and     ixh
 785++CA36              ;;;;;;                        jp      .CheckYLow
 786++CA36              ;;;;;;                        ld
 787++CA36              ;;;;;;                        and     a                                   ; if either is zero then we can check for > 127
 788++CA36              ;;;;;;                        jr      z,.YHighNegativeCheck               ;
 789++CA36              ;;;;;;                        ld      a,ixh                               ;
 790++CA36              ;;;;;;                        and     a                                   ;
 791++CA36              ;;;;;;                        ret     nz                                  ;
 792++CA36              ;;;;;;;if y1h bit 7 and y2h bit 7 set then exit as both -ve
 793++CA36              ;;;;;;                        ld      a,b                                 ;
 794++CA36              ;;;;;;                        and     ixh                                 ;
 795++CA36              ;;;;;;                        and     $80                                 ;
 796++CA36              ;;;;;;                        ret     z                                   ;
 797++CA36              ;;;;;;;if y1h > 0 and y2h > 0 then exit as both are +ve high
 798++CA36              ;;;;;;                        ld      a,b                                 ;
 799++CA36              ;;;;;;                        and     ixh                                 ;
 800++CA36              ;;;;;;                        ret     nz                                  ;
 801++CA36              ;;;;;;;if y1h or y2h is not 0 then proceed to clip
 802++CA36              ;;;;;;                        ld      a,b
 803++CA36              ;;;;;;                        or      ixh
 804++CA36              ;;;;;;                        jr      nz,.StartProcessing
 805++CA36              ;;;;;;;if (y1l bit 7 is set and y1h is clear ) or (y2l bit 7 is set and y2h is clear) the proceed to clip
 806++CA36              ;;;;;;                        ld      a,c
 807++CA36              ;;;;;;                        or      ixl
 808++CA36              ;;;;;;                        and     $80
 809++CA36              ;;;;;;                        jr      z,.StartProcessing
 810++CA36              ;;;;;;
 811++CA36              ;;;;;;.CheckYOffScreen:       ld      a,b                                 ;
 812++CA36              ;;;;;;                        cp      0                                   ;
 813++CA36              ;;;;;;                        jr      z,.Y1HighIsZero                     ;
 814++CA36              ;;;;;;                        ld      a,ixh                               ; if we get here Y1 high <> 0
 815++CA36              ;;;;;;                        cp      0                                   ;
 816++CA36              ;;;;;;                        jr      z,.Y2HighIsZero                     ; if they are both non zero we can do a sign check
 817++CA36              ;;;;;;.CheckYSameSign:        ld      a,b                                 ; if we get here Y1 high and Y2 high are not zero
 818++CA36              ;;;;;;                        xor     ixh                                 ; so same sign then bail out if they are
 819++CA36              ;;;;;;                        and     $80                                 ;
 820++CA36              ;;;;;;                        ret     z                                   ;
 821++CA36              ;;;;;;;if we get here either y1hi or y2 hi are 0, now check and y1 low > 127 & y2 low > 127, exit
 822++CA36              ;;;;;;.Y1HighIsZero:          ld      a,ixh                               ; as y1h is zero, if y2h is zero we do y1 y2 test
 823++CA36              ;;;;;;                        cp      0                                   ;
 824++CA36              ;;;;;;                        jr      nz,.Startprocessing                 ;
 825++CA36              ;;;;;;                        ld      a,c                                 ; so by here y1h and y2h must be zero
 826++CA36              ;;;;;;                        and     ixl
 827++CA36              ;;;;;;
 828++CA36              ;;;;;;                        .CheckY2Lo                        ;
 829++CA36              ;;;;;;.CheckY1Lo:             ld      a,c
 830++CA36              ;;;;;;                        and     $80
 831++CA36              ;;;;;;                        jr      z,.StartProcessing
 832++CA36              ;;;;;;.CheckY2Lo:             ld      a,ixl
 833++CA36              ;;;;;;                        and     $80
 834++CA36              ;;;;;;                        ret     nz
 835++CA36              ;;;;;;;clip = 0
# file closed: ../../Tests/3DTest/../../ModelRender/CLIP-LL145.asm
 361+ CA36              ;--------------------------------------------------------------------------------------------------------
 362+ CA36                                      INCLUDE "../../Universe/Ships/CopyRotmatToTransMat.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/CopyRotmatToTransMat.asm
   1++CA36              ; Set TransMatTo
   2++CA36              ; XX16(1 0)   (3 2)   (5 4)   = sidev_x sidev_y sidev_z XX16(13,12) (15 14) (17 16)
   3++CA36              ; XX16(7 6)   (9 8)   (11 10) = roofv_x roofv_y roofv_z XX16(7 6)   (9 8)   (11 10)
   4++CA36              ; XX16(13 12) (15 14) (17 16) = nosev_x nosev_y nosev_z XX16(1 0)   (3 2)   (5 4)
   5++CA36              ; This moves Side XYZ to position 0, Roof XYZ to position 1 annd nose XYZ to position 2 as a copy of each batch of 6 bytes
   6++CA36              ; 18 byte fast copy
   7++CA36
   8++CA36              ; Fast copy using the stack                                                         ; T states
   9++CA36 DD 21 00 00  CopyRotmatToTransMat:   ld      ix,0                                                ; 14
  10++CA3A DD 39                                add     ix,sp                                               ; 15
  11++CA3C 31 29 C0                             ld      sp,UBnkrotmatSidevX ; Source                        ; 10
  12++CA3F E1                                   pop     hl                  ; UBnkrotmatSidevX              ; 10
  13++CA40 D1                                   pop     de                  ; UBnkrotmatSidevY              ; 10
  14++CA41 C1                                   pop     bc                  ; UBnkrotmatSidevZ              ; 10
  15++CA42 D9                                   exx                                                         ; 4
  16++CA43 E1                                   pop     hl                  ; UBnkrotmatRoofvX              ; 10
  17++CA44 D1                                   pop     de                  ; UBnkrotmatRoofvY              ; 10
  18++CA45 C1                                   pop     bc                  ; UBnkrotmatRoofvZ              ; 10
  19++CA46 31 6D C0                             ld      sp,UBnkTransmatRoofvZ+2 ; Target + 2 reversed       ; 10
  20++CA49 C5                                   push    bc                                                  ; 10
  21++CA4A D5                                   push    de                                                  ; 10
  22++CA4B E5                                   push    hl                                                  ; 10
  23++CA4C D9                                   exx                                                         ; 4
  24++CA4D C5                                   push    bc                                                  ; 10
  25++CA4E D5                                   push    de                                                  ; 10
  26++CA4F E5                                   push    hl                                                  ; 10
  27++CA50 31 35 C0                             ld      sp,UBnkrotmatNosevX ; Source                        ; 10
  28++CA53 E1                                   pop     hl                  ; UBnkrotmatSidevX              ; 10
  29++CA54 D1                                   pop     de                  ; UBnkrotmatSidevY              ; 10
  30++CA55 C1                                   pop     bc                  ; UBnkrotmatSidevZ              ; 10
  31++CA56 31 73 C0                             ld      sp,UBnkTransmatNosevZ+2                             ; 10
  32++CA59 C5                                   push    bc                                                  ; 10
  33++CA5A D5                                   push    de                                                  ; 10
  34++CA5B E5                                   push    hl                                                  ; 10
  35++CA5C DD F9                                ld      sp,ix               ; restore stack                 ; 10
  36++CA5E C9                                   ret                                                         ; 10 Total 267 (LDI version is 318)
  37++CA5F
  38++CA5F
  39++CA5F
  40++CA5F              ;CopyRotmatToTransMat:
  41++CA5F              ;                        ld      hl,UBnkrotmatSidevX
  42++CA5F              ;                        ld      de,UBnkTransmatSidevX
  43++CA5F              ;                        SixLDIInstrunctions
  44++CA5F              ;                        ld      hl,UBnkrotmatRoofvX
  45++CA5F              ;                        ld      de, UBnkTransmatRoofvX
  46++CA5F              ;                        SixLDIInstrunctions
  47++CA5F              ;                        ld      hl,UBnkrotmatNosevX
  48++CA5F              ;                        ld      de, UBnkTransmatNosevX
  49++CA5F              ;                        SixLDIInstrunctions
  50++CA5F              ;                        ret
  51++CA5F
  52++CA5F              CopyRotToTransMacro:    MACRO
  53++CA5F ~                                    ld      hl,UBnkrotmatSidevX
  54++CA5F ~                                    ld      de,UBnkTransmatSidevX
  55++CA5F ~                                    SixLDIInstrunctions
  56++CA5F ~                                    SixLDIInstrunctions
  57++CA5F ~                                    SixLDIInstrunctions
  58++CA5F                                      ENDM
  59++CA5F
# file closed: ../../Tests/3DTest/../../Universe/Ships/CopyRotmatToTransMat.asm
 363+ CA5F                                      INCLUDE "../../Universe/Ships/TransposeXX12ByShipToXX15.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/TransposeXX12ByShipToXX15.asm
   1++CA5F              TransposeXX12ByShipToXX15:
   2++CA5F 2A AC C0             ld		hl,(UBnkXX12xLo)					; get X into HL
   3++CA62 7C           		ld		a,h			                        ; get XX12 Sign
   4++CA63 E6 80        		and		$80									; check sign bit on high byte
   5++CA65 47           		ld		b,a									; and put it in of 12xlo in b
   6++CA66                      ;110921 debugld      h,0
   7++CA66 7C                   ld      a,h
   8++CA67 E6 7F                and     $7F
   9++CA69 67                   ld      h,a
  10++CA6A                      ;110921 debugld      h,0
  11++CA6A ED 5B 20 C0  		ld		de,(UBnKxlo)						;
  12++CA6E 3A 22 C0     		ld		a,(UBnKxsgn)						; get Ship Pos (low,high,sign)
  13++CA71 E6 80        		and		$80									; make sure we only have bit 7
  14++CA73 4F           		ld		c,a									; and put sign of unkxsgn c
  15++CA74 CD 33 00     		call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC		; this will result in HL = result and A = sign
  16++CA77 B4           		or		h									; combine sign in A with H to give 15 bit signed (*NOT* 2's c)
  17++CA78 67           		ld		h,a
  18++CA79 22 A6 C0     		ld		(UBnkXScaled),hl					; now write it out to XX15 X pos
  19++CA7C              ; ..................................
  20++CA7C 2A AE C0     		ld		hl,(UBnkXX12yLo)					; Repeat above for Y coordinate
  21++CA7F 7C           		ld		a,h
  22++CA80 E6 80        		and		$80
  23++CA82 47           		ld		b,a
  24++CA83                      ;110921 debugld      h,0
  25++CA83 7C                   ld      a,h
  26++CA84 E6 7F                and     $7F
  27++CA86 67                   ld      h,a
  28++CA87                      ;110921 debugld      h,0
  29++CA87 ED 5B 23 C0  		ld		de,(UBnKylo)
  30++CA8B 3A 25 C0     		ld		a,(UBnKysgn)
  31++CA8E E6 80        		and		$80									; make sure we only have bit 7
  32++CA90 4F           		ld		c,a
  33++CA91 CD 33 00     		call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC
  34++CA94 B4           		or		h									; combine sign in A with H
  35++CA95 67           		ld		h,a
  36++CA96 22 A8 C0     		ld		(UBnkYScaled),hl
  37++CA99              ; ..................................
  38++CA99 2A B0 C0     		ld		hl,(UBnkXX12zLo)					; and now repeat for Z cooord
  39++CA9C 7C           		ld		a,h
  40++CA9D E6 80        		and		$80
  41++CA9F 47           		ld		b,a
  42++CAA0                      ;110921 debugld      h,0
  43++CAA0 7C                   ld      a,h
  44++CAA1 E6 7F                and     $7F
  45++CAA3 67                   ld      h,a
  46++CAA4                      ;110921 debugld      h,0
  47++CAA4 ED 5B 26 C0  		ld		de,(UBnKzlo)
  48++CAA8 3A 28 C0     		ld		a,(UBnKzsgn)
  49++CAAB E6 80        		and		$80									; make sure we only have bit 7
  50++CAAD 4F           		ld		c,a
  51++CAAE CD 33 00     		call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC
  52++CAB1 B4           		or		h									; combine sign in A with H
  53++CAB2 67           		ld		h,a
  54++CAB3 CB 7C        		bit		7,h                                 ; if sign if positive then we don't need to do the clamp so we ony jump
  55++CAB5 20 16        		jr		nz,ClampZto4                        ; result was negative so we need to clamp to 4
  56++CAB7 E6 7F                and     $7F                                 ; a = value unsigned
  57++CAB9 20 06                jr      nz,NoClampZto4                      ; if high byte was 0 then we could need to clamp still by this stage its +v but and will set z flag if high byte is zero
  58++CABB 7D                   ld      a,l                                 ; get low byte now
  59++CABC              		JumpIfALTNusng 4,ClampZto4					; if its < 4 then fix at 4
  59++CABC FE 04       >                        cp      4
  59++CABE DA CD CA    >                        jp		c, ClampZto4
  60++CAC1              NoClampZto4:
  61++CAC1 22 AA C0     		ld		(UBnkZScaled),hl					; hl = signed calculation and > 4
  62++CAC4 7D           		ld		a,l									; in addition write out the z cooord to UT for now for backwards compat (DEBUG TODO remove later)
  63++CAC5 32 7B 69             ld      (varT),a
  64++CAC8 7C           		ld		a,h
  65++CAC9 32 5E 69             ld      (varU),a
  66++CACC C9           		ret
  67++CACD              ClampZto4:											; This is where we limit 4 to a minimum of 4
  68++CACD 21 04 00     		ld		hl,4
  69++CAD0 22 AA C0     		ld		(UBnkZScaled),hl; BODGE FOR NOW
  70++CAD3 7D           		ld		a,l
  71++CAD4 32 7B 69             ld      (varT),a                            ;                                                                           ;;;
  72++CAD7 7C           		ld		a,h
  73++CAD8 32 5E 69             ld      (varU),a 						; compatibility for now
  74++CADB C9           		ret
  75++CADC
# file closed: ../../Tests/3DTest/../../Universe/Ships/TransposeXX12ByShipToXX15.asm
 364+ CADC                                      INCLUDE "../../Maths/Utilities/ScaleNodeTo8Bit.asm"
# file opened: ../../Tests/3DTest/../../Maths/Utilities/ScaleNodeTo8Bit.asm
   1++CADC              ScaleNodeTo8Bit:								; TODO make signed
   2++CADC ED 4B AA C0  	ld			bc,(UBnkZScaled)
   3++CAE0 2A A6 C0     	ld			hl,(UBnkXScaled)
   4++CAE3 ED 5B A8 C0  	ld			de,(UBnkYScaled)
   5++CAE7              SetABSbc:
   6++CAE7 78           	ld			a,b
   7++CAE8 DD 67        	ld			ixh,a
   8++CAEA E6 7F        	and			SignMask8Bit
   9++CAEC 47           	ld			b,a									; bc = ABS bc
  10++CAED              SetABShl:
  11++CAED 7C           	ld			a,h
  12++CAEE DD 6F        	ld			ixl,a
  13++CAF0 E6 7F        	and			SignMask8Bit
  14++CAF2 67           	ld			h,a									; hl = ABS hl
  15++CAF3              SetABSde:
  16++CAF3 7A           	ld			a,d
  17++CAF4 FD 67        	ld			iyh,a
  18++CAF6 E6 7F        	and			SignMask8Bit
  19++CAF8 57           	ld			d,a									; de = ABS de
  20++CAF9              ScaleNodeTo8BitLoop:
  21++CAF9 78               ld          a,b		                            ; U	\ z hi
  22++CAFA B4           	or			h                                   ; XX15+1	\ x hi
  23++CAFB B2           	or			d                                   ; XX15+4	\ y hi
  24++CAFC 28 0F            jr          z,ScaleNodeDone                   ; if X, Y, Z = 0  exit loop down once hi U rolled to 0
  25++CAFE                  ShiftHLRight1
  25++CAFE CB 3C       >			   srl h
  25++CB00 CB 1D       >			   rr  l
  26++CB02                  ShiftDERight1
  26++CB02 CB 3A       >			   srl d
  26++CB04 CB 1B       >			   rr  e
  27++CB06              	ShiftBCRight1
  27++CB06 CB 38       >			   srl b
  27++CB08 CB 19       >			   rr  c
  28++CB0A C3 F9 CA         jp          ScaleNodeTo8BitLoop
  29++CB0D              ScaleNodeDone:										; now we have scaled values we have to deal with sign
  30++CB0D DD 7C        	ld			a,ixh								; get sign bit and or with b
  31++CB0F E6 80        	and			SignOnly8Bit
  32++CB11 B0           	or			b
  33++CB12 47           	ld			b,a
  34++CB13              SignforHL:
  35++CB13 DD 7D        	ld			a,ixl								; get sign bit and or with b
  36++CB15 E6 80        	and			SignOnly8Bit
  37++CB17 B4           	or			h
  38++CB18 67           	ld			h,a
  39++CB19              SignforDE:
  40++CB19 FD 7C        	ld			a,iyh								; get sign bit and or with b
  41++CB1B E6 80        	and			SignOnly8Bit
  42++CB1D B2           	or			d
  43++CB1E 57           	ld			d,a
  44++CB1F              SignsDoneSaveResult:
  45++CB1F ED 43 AA C0  	ld			(UBnkZScaled),bc
  46++CB23 22 A6 C0     	ld			(UBnkXScaled),hl
  47++CB26 ED 53 A8 C0  	ld			(UBnkYScaled),de
  48++CB2A 78           	ld			a,b
  49++CB2B 32 5E 69     	ld			(varU),a
  50++CB2E 79           	ld			a,c
  51++CB2F 32 7B 69     	ld			(varT),a
  52++CB32 C9           	ret
  53++CB33
# file closed: ../../Tests/3DTest/../../Maths/Utilities/ScaleNodeTo8Bit.asm
 365+ CB33
 366+ CB33              ;--------------------------------------------------------------------------------------------------------
 367+ CB33 21 D2 C0     SetFaceAVisible:        ld      hl,UbnkFaceVisArray
 368+ CB36 ED 31                                add     hl,a
 369+ CB38 3E FF                                ld      a,$FF
 370+ CB3A 77                                   ld      (hl),a
 371+ CB3B C9                                   ret
 372+ CB3C              ;--------------------------------------------------------------------------------------------------------
 373+ CB3C 21 D2 C0     SetFaceAHidden:         ld      hl,UbnkFaceVisArray
 374+ CB3F ED 31                                add     hl,a
 375+ CB41 AF                                   xor     a
 376+ CB42 77                                   ld      (hl),a
 377+ CB43 C9                                   ret
 378+ CB44              ;--------------------------------------------------------------------------------------------------------
 379+ CB44 3A 03 C4     SetAllFacesVisible:     ld      a,(FaceCtX4Addr)            ; (XX0),Y which is XX0[0C] or UBnkHullCopy+FaceCtX4Addr                                 ;;; Faces count (previously loaded into b up front but no need to shave bytes for clarity
 380+ CB47 CB 3F                                srl     a                           ; else do explosion needs all vertices                                                  ;;;
 381+ CB49 CB 3F                                srl     a                           ;  /=4  TODO add this into blueprint data for speed                                                           ;;; For loop = 15 to 0
 382+ CB4B 47                                   ld      b,a                         ; b = Xreg = number of normals, faces
 383+ CB4C 21 D2 C0                             ld      hl,UbnkFaceVisArray
 384+ CB4F 3E FF                                ld      a,$FF
 385+ CB51              SetAllFacesVisibleLoop:
 386+ CB51 77           EE30:                   ld      (hl),a
 387+ CB52 23                                   inc     hl
 388+ CB53 10 FC                                djnz    SetAllFacesVisibleLoop
 389+ CB55 C9                                   ret
 390+ CB56              ;--------------------------------------------------------------------------------------------------------
 391+ CB56 3A 03 C4     SetAllFacesHidden:      ld      a,(FaceCtX4Addr)            ; (XX0),Y which is XX0[0C] or UBnkHullCopy+ShipHullFacesCount                           ;;; Faces count (previously loaded into b up front but no need to shave bytes for clarity
 392+ CB59 CB 3F                                srl     a                           ; else do explosion needs all vertices                                                  ;;;
 393+ CB5B CB 3F                                srl     a                           ;  /=4                                                                                  ;;; For loop = 15 to 0
 394+ CB5D 47                                   ld      b,a                         ; b = Xreg = number of normals, faces
 395+ CB5E 06 10                                ld      b,16
 396+ CB60 21 D2 C0                             ld      hl,UbnkFaceVisArray
 397+ CB63 3E 00                                ld      a,$00
 398+ CB65 77           SetAllFacesHiddenLoop:  ld      (hl),a
 399+ CB66 23                                   inc     hl
 400+ CB67 10 FC                                djnz    SetAllFacesHiddenLoop
 401+ CB69 C9                                   ret
 402+ CB6A              ;--------------------------------------------------------------------------------------------------------
 403+ CB6A                                      include "../../Universe/Ships/NormaliseTransMat.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/NormaliseTransMat.asm
   1++CB6A              ;divdide by 16 using undocumented instrunctions
   2++CB6A 47           Norm256mulAdivQ:        ld      b,a
   3++CB6B 0E 00                                ld      c,0
   4++CB6D 16 00                                ld      d,0
   5++CB6F 3A 5F 69                             ld      a,(varQ)
   6++CB72 5F                                   ld      e,a
   7++CB73              ;Input: BC = Dividend, DE = Divisor, HL = 0
   8++CB73              ;Output: BC = Quotient, HL = Remainder
   9++CB73 21 00 00     NormDIV16UNDOC:         ld      hl,0
  10++CB76 78                                   ld      a,b
  11++CB77 06 10                                ld      b,16
  12++CB79 CB 31        NormDIV16UNDOCLOOP:     sll	    c		; unroll 16 times
  13++CB7B 17                                   rla	    		; ...
  14++CB7C ED 6A                                adc	    hl,hl		; ...
  15++CB7E ED 52                                sbc	    hl,de		; ...
  16++CB80 30 02                                jr	    nc,NormDIV16UNDOCSKIP		; ...
  17++CB82 19                                   add	    hl,de		; ...
  18++CB83 0D                                   dec	    c		; ...
  19++CB84 10 F3        NormDIV16UNDOCSKIP:     djnz    NormDIV16UNDOCLOOP
  20++CB86 79                                   ld      a,c
  21++CB87 32 60 69                             ld      (varR),a
  22++CB8A C9                                   ret
  23++CB8B
  24++CB8B FD 67        Norm256mulAdivQSignA:   ld      iyh,a
  25++CB8D                                      ClearSignBitA
  25++CB8D E6 7F       >                        and     SignMask8Bit
  26++CB8F CD 6A CB                             call    Norm256mulAdivQ              ; do 15 bit unsigned
  27++CB92 FD 7C                                ld      a,iyh                       ; now correct R reg
  28++CB94                                      SignBitOnlyA
  28++CB94 E6 80       >                        and     SignOnly8Bit
  29++CB96 B1                                   or      c
  30++CB97 32 60 69                             ld      (varR),a
  31++CB9A C9                                   ret
  32++CB9B
  33++CB9B              ; Tested OK
  34++CB9B              ;LL21
  35++CB9B              NormaliseTransMat:
  36++CB9B                      IFDEF LOGMATHS
  37++CB9B ~                            ld      hl,UBnkTransmatNosevZ+1     ; initialise loop
  38++CB9B ~                            ld      b,9                         ; total of 9 elements to transform
  39++CB9B ~                            MMUSelectMathsTables
  40++CB9B ~            .LL21Loop:      ld      d,(hl)
  41++CB9B ~                            dec     hl
  42++CB9B ~                            ld      e,(hl)                      ; de = hilo now   hl now = pointer to low byte
  43++CB9B ~                            ShiftDELeft1                        ; De = DE * 2
  44++CB9B ~                            ld      a,d                         ; a = hi byte after shifting
  45++CB9B ~                            push	hl
  46++CB9B ~                            push	bc
  47++CB9B ~                            call    AEquAmul256Div197Log        ; R = (2(hi).0)/ConstNorm - LL28 Optimised BFRDIV R=A*256/Q = delta_y / delta_x Use Y/X grad. as not steep
  48++CB9B ~                            ;ld      a,c                         ; BFRDIV returns R also in l reg
  49++CB9B ~                            pop		bc
  50++CB9B ~                            pop		hl							; bc gets wrecked by BFRDIV
  51++CB9B ~                            ld      (hl),a                      ; write low result to low byte so zlo = (zhl *2)/197, we keep hi byte in tact as we need the sign bit
  52++CB9B ~                            dec     hl                          ; now hl = hi byte of pre val e.g z->y->x
  53++CB9B ~                            djnz    .LL21Loop                   ; loop from 2zLo through to 0xLo
  54++CB9B ~                            MMUSelectROM0
  55++CB9B ~                            ret
  56++CB9B                      ELSE
  57++CB9B 21 72 C0                     ld      hl,UBnkTransmatNosevZ+1         ; initialise loop
  58++CB9E 0E C5                        ld      c,ConstNorm                 ; c = Q = norm = 197
  59++CBA0 79                           ld      a,c
  60++CBA1 32 5F 69                     ld      (varQ),a                    ; set up varQ
  61++CBA4 06 09                        ld      b,9                         ; total of 9 elements to transform
  62++CBA6 56           LL21Loop:       ld      d,(hl)
  63++CBA7 2B                           dec     hl
  64++CBA8 5E                           ld      e,(hl)                      ; de = hilo now   hl now = pointer to low byte
  65++CBA9                              ShiftDELeft1                        ; De = DE * 2
  65++CBA9 CB 23       >			   sla e
  65++CBAB CB 12       >			   rl  d
  66++CBAD 7A                           ld      a,d                         ; a = hi byte after shifting
  67++CBAE E5                           push	hl
  68++CBAF C5                           push	bc
  69++CBB0 CD 6A CB                     call    Norm256mulAdivQ
  70++CBB3                              ;===call    RequAmul256divC				; R = (2(hi).0)/ConstNorm - LL28 Optimised BFRDIV R=A*256/Q = delta_y / delta_x Use Y/X grad. as not steep
  71++CBB3 79                           ld      a,c                         ; BFRDIV returns R also in l reg
  72++CBB4 C1                           pop		bc
  73++CBB5 E1                           pop		hl							; bc gets wrecked by BFRDIV
  74++CBB6 77                           ld      (hl),a                      ; write low result to low byte so zlo = (zhl *2)/197, we keep hi byte in tact as we need the sign bit
  75++CBB7 2B                           dec     hl                          ; now hl = hi byte of pre val e.g z->y->x
  76++CBB8 10 EC                        djnz    LL21Loop                    ; loop from 2zLo through to 0xLo
  77++CBBA C9                           ret
  78++CBBB                      ENDIF
# file closed: ../../Tests/3DTest/../../Universe/Ships/NormaliseTransMat.asm
 404+ CBBB              ;--------------------------------------------------------------------------------------------------------
 405+ CBBB                                      include "../../Universe/Ships/InverseXX16.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/InverseXX16.asm
   1++CBBB              ; TESTEDOK
   2++CBBB
   3++CBBB              ;ScaleOrientationXX16:                       ; DEBUG TODO will combine with inverse later
   4++CBBB              ;        ld      a,(XX17)
   5++CBBB              ;        ld      ixl,a
   6++CBBB              ;        ld      ixh,9
   7++CBBB              ;        ld      hl,UBnkTransInv0x
   8++CBBB              ;        ld      a,(hl)
   9++CBBB              ;ScaleNode:
  10++CBBB              ;        ld      b,ixl
  11++CBBB              ;ScaleNodeLoop:
  12++CBBB              ;        sla      a
  13++CBBB              ;        djnz    ScaleNodeLoop
  14++CBBB              ;        ld      (hl),a
  15++CBBB              ;        inc     hl
  16++CBBB              ;        inc     hl
  17++CBBB              ;        dec     ixh
  18++CBBB              ;        jr      nz,ScaleNode
  19++CBBB              ;        ret
  20++CBBB
  21++CBBB
  22++CBBB              InverseXX16:								; lead routine into .LL42	\ ->  &4B04 \ DO nodeX-Ycoords their comment  \  TrnspMat
  23++CBBB              ; we coudl combine this with move to transmat later as an optimisation
  24++CBBB              ; INPUT - All Scaled
  25++CBBB              ;  They transmat has already been put into side, roof nose order
  26++CBBB              ;  XX16   = |sidev_x| |sidev_y| |sidev_z|  1  0  3  2  5  4 note each bytepair is Scaled value in low and high byte just for sign
  27++CBBB              ;  XX16   = |roofv_x| |roofv_y| |roofv_z|  7  6  8  9 11 10
  28++CBBB              ;  XX16   = |nosev_x| |nosev_y| |nosev_z| 13 12 15 14 17 16
  29++CBBB              ; OUTPUT
  30++CBBB              ;  XX16(1 0)   ( 3 2) ( 5 4 ) =  sidev_x roofv_x nosev_x
  31++CBBB              ;  XX16(7 6)   ( 8 9) (11 10) =  sidev_y roofv_y nosev_y
  32++CBBB              ;  XX16(13 12) (15 14)(17 16) =  sidev_z roofv_z nosev_z
  33++CBBB              ; First all side values become compoment 0 of each vector
  34++CBBB 2A 61 C0             ld      hl,(UBnkTransmatSidevX)     ;
  35++CBBE ED 5B 67 C0          ld      de,(UBnkTransmatRoofvX)     ;
  36++CBC2 ED 4B 6D C0          ld      bc,(UBnkTransmatNosevX)     ;
  37++CBC6 22 79 C0             ld      (UbnkTransInvRow0x0),hl     ;
  38++CBC9 ED 53 7B C0          ld      (UbnkTransInvRow0x1),de     ;
  39++CBCD ED 43 7D C0          ld      (UbnkTransInvRow0x2),bc     ;
  40++CBD1 2A 63 C0             ld      hl,(UBnkTransmatSidevY)     ;
  41++CBD4 ED 5B 69 C0          ld      de,(UBnkTransmatRoofvY)     ;
  42++CBD8 ED 4B 6F C0          ld      bc,(UBnkTransmatNosevY)     ;
  43++CBDC 22 81 C0             ld      (UbnkTransInvRow1y0),hl     ;
  44++CBDF ED 53 83 C0          ld      (UbnkTransInvRow1y1),de     ;
  45++CBE3 ED 43 85 C0          ld      (UbnkTransInvRow1y2),bc     ;
  46++CBE7 2A 65 C0             ld      hl,(UBnkTransmatSidevZ)     ;
  47++CBEA ED 5B 6B C0          ld      de,(UBnkTransmatRoofvZ)     ;
  48++CBEE ED 4B 71 C0          ld      bc,(UBnkTransmatNosevZ)     ;
  49++CBF2 22 89 C0             ld      (UbnkTransInvRow2z0),hl     ;
  50++CBF5 ED 53 8B C0          ld      (UbnkTransInvRow2z1),de     ;
  51++CBF9 ED 43 8D C0          ld      (UbnkTransInvRow2z2),bc     ;
  52++CBFD C9                   ret
  53++CBFE
  54++CBFE
# file closed: ../../Tests/3DTest/../../Universe/Ships/InverseXX16.asm
 406+ CBFE              ;--------------------------------------------------------------------------------------------------------
 407+ CBFE              XX12DotOneRow:
 408+ CBFE              XX12CalcX:              N0equN1byN2div256 varT, (hl), (UBnkXScaled)       ; T = (hl) * regXX15fx /256
 408+ CBFE 3A A6 C0    >                        ld      a,(UBnkXScaled)                        ;
 408+ CC01 5F          >                        ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 408+ CC02 7E          >                        ld      a,(hl)                        ; A = XX16 element
 408+ CC03 57          >                        ld      d,a
 408+ CC04 ED 30       >                        mul
 408+ CC06 7A          >                        ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 408+ CC07 32 7B 69    >                        ld      (varT),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 409+ CC0A 23                                   inc     hl                                  ; move to sign byte
 410+ CC0B              XX12CalcXSign:          AequN1xorN2 UBnkXScaledSign,(hl)             ;
 410+ CC0B 3A A7 C0    >                        ld      a,(UBnkXScaledSign)
 410+ CC0E AE          >                        xor     (hl)
 411+ CC0F 32 61 69                             ld      (varS),a                            ; Set S to the sign of x_sign * sidev_x
 412+ CC12 23                                   inc     hl
 413+ CC13              XX12CalcY:              N0equN1byN2div256 varQ, (hl),(UBnkYScaled)       ; Q = XX16 * XX15 /256 using varQ to hold regXX15fx
 413+ CC13 3A A8 C0    >                        ld      a,(UBnkYScaled)                        ;
 413+ CC16 5F          >                        ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 413+ CC17 7E          >                        ld      a,(hl)                        ; A = XX16 element
 413+ CC18 57          >                        ld      d,a
 413+ CC19 ED 30       >                        mul
 413+ CC1B 7A          >                        ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 413+ CC1C 32 5F 69    >                        ld      (varQ),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 414+ CC1F                                      ldCopyByte varT,varR                        ; R = T =  |sidev_x| * x_lo / 256
 414+ CC1F 3A 7B 69    >                        ld       a,(varT)
 414+ CC22 32 60 69    >                        ld       (varR),a
 415+ CC25 23                                   inc     hl
 416+ CC26                                      AequN1xorN2 UBnkYScaledSign,(hl)             ; Set A to the sign of y_sign * sidev_y
 416+ CC26 3A A9 C0    >                        ld      a,(UBnkYScaledSign)
 416+ CC29 AE          >                        xor     (hl)
 417+ CC2A              ; (S)A = |sidev_x| * x_lo / 256  = |sidev_x| * x_lo + |sidev_y| * y_lo
 418+ CC2A E5           STequSRplusAQ           push    hl
 419+ CC2B CD 70 79                             call    baddll38                            ; JSR &4812 \ LL38   \ BADD(S)A=R+Q(SA) \ 1byte add (subtract)
 420+ CC2E E1                                   pop     hl
 421+ CC2F 32 7B 69                             ld      (varT),a                            ; T = |sidev_x| * x_lo + |sidev_y| * y_lo
 422+ CC32 23                                   inc     hl
 423+ CC33              XX12CalcZ:              N0equN1byN2div256 varQ,(hl),(UBnkZScaled)       ; Q = |sidev_z| * z_lo / 256
 423+ CC33 3A AA C0    >                        ld      a,(UBnkZScaled)                        ;
 423+ CC36 5F          >                        ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 423+ CC37 7E          >                        ld      a,(hl)                        ; A = XX16 element
 423+ CC38 57          >                        ld      d,a
 423+ CC39 ED 30       >                        mul
 423+ CC3B 7A          >                        ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 423+ CC3C 32 5F 69    >                        ld      (varQ),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 424+ CC3F                                      ldCopyByte varT,varR                        ; R = |sidev_x| * x_lo + |sidev_y| * y_lo
 424+ CC3F 3A 7B 69    >                        ld       a,(varT)
 424+ CC42 32 60 69    >                        ld       (varR),a
 425+ CC45 23                                   inc     hl
 426+ CC46                                      AequN1xorN2 UBnkZScaledSign,(hl)             ; A = sign of z_sign * sidev_z
 426+ CC46 3A AB C0    >                        ld      a,(UBnkZScaledSign)
 426+ CC49 AE          >                        xor     (hl)
 427+ CC4A              ; (S)A= |sidev_x| * x_lo + |sidev_y| * y_lo + |sidev_z| * z_lo
 428+ CC4A CD 70 79                             call    baddll38                            ; JSR &4812 \ LL38   \ BADD(S)A=R+Q(SA)   \ 1byte add (subtract)
 429+ CC4D              ; Now we exit with A = result S = Sign
 430+ CC4D C9                                   ret
 431+ CC4E
 432+ CC4E
 433+ CC4E                  DISPLAY "Tracing 4", $
 434+ CC4E
 435+ CC4E              ;-- LL51---------------------------------------------------------------------------------------------------------------------------
 436+ CC4E              ;TESTED OK
 437+ CC4E              ;XX12EquScaleDotOrientation:                         ; .LL51 \ -> &4832 \ XX12=XX15.XX16  each vector is 16-bit x,y,z
 438+ CC4E              XX12EquXX15DotProductXX16:
 439+ CC4E 01 00 00                             ld      bc,0                                ; LDX, LDY 0
 440+ CC51 21 61 C0                             ld      hl,UBnkTransmatSidevX
 441+ CC54 CD FE CB                             call    XX12DotOneRow
 442+ CC57 32 AC C0                             ld      (UBnkXX12xLo),a
 443+ CC5A 3A 61 69                             ld      a,(varS)
 444+ CC5D 32 AD C0                             ld      (UBnkXX12xSign),a
 445+ CC60 21 67 C0                             ld      hl,UBnkTransmatRoofvX
 446+ CC63 CD FE CB                             call    XX12DotOneRow
 447+ CC66 32 AE C0                             ld      (UBnkXX12yLo),a
 448+ CC69 3A 61 69                             ld      a,(varS)
 449+ CC6C 32 AF C0                             ld      (UBnkXX12ySign),a
 450+ CC6F 21 6D C0                             ld      hl,UBnkTransmatNosevX
 451+ CC72 CD FE CB                             call    XX12DotOneRow
 452+ CC75 32 B0 C0                             ld      (UBnkXX12zLo),a
 453+ CC78 3A 61 69                             ld      a,(varS)
 454+ CC7B 32 B1 C0                             ld      (UBnkXX12zSign),a
 455+ CC7E C9                                   ret
 456+ CC7F              ;--------------------------------------------------------------------------------------------------------
 457+ CC7F                                      INCLUDE "../../Universe/Ships/CopyXX12ScaledToXX18.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/CopyXX12ScaledToXX18.asm
   1++CC7F              CopyXX12ScaledToXX18:
   2++CC7F              CopyResultToDrawCam:
   3++CC7F                      ldCopyByte XX12         ,XX18             ; XX12+0 => XX18+0  Set XX18(2 0) = dot_sidev
   3++CC7F 3A AC C0    >                        ld       a,(XX12)
   3++CC82 32 9A C0    >                        ld       (XX18),a
   4++CC85                      ldCopyByte XX12+1       ,XX18+2           ; XX12+1 => XX18+2
   4++CC85 3A AD C0    >                        ld       a,(XX12+1)
   4++CC88 32 9C C0    >                        ld       (XX18+2),a
   5++CC8B                      ldCopyByte XX12+2       ,XX18+3           ; XX12+2 => XX18+3  Set XX12+1 => XX18+2
   5++CC8B 3A AE C0    >                        ld       a,(XX12+2)
   5++CC8E 32 9D C0    >                        ld       (XX18+3),a
   6++CC91                      ldCopyByte XX12+3       ,XX18+5           ; XX12+3 => XX18+5
   6++CC91 3A AF C0    >                        ld       a,(XX12+3)
   6++CC94 32 9F C0    >                        ld       (XX18+5),a
   7++CC97                      ldCopyByte XX12+4       ,XX18+6           ; XX12+4 => XX18+6  Set XX18(8 6) = dot_nosev
   7++CC97 3A B0 C0    >                        ld       a,(XX12+4)
   7++CC9A 32 A0 C0    >                        ld       (XX18+6),a
   8++CC9D                      ldCopyByte XX12+5       ,XX18+8           ; XX12+5 => XX18+8
   8++CC9D 3A B1 C0    >                        ld       a,(XX12+5)
   8++CCA0 32 A2 C0    >                        ld       (XX18+8),a
   9++CCA3 C9                   ret
  10++CCA4
# file closed: ../../Tests/3DTest/../../Universe/Ships/CopyXX12ScaledToXX18.asm
 458+ CCA4                                      INCLUDE "../../Universe/Ships/CopyXX12toXX15.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/CopyXX12toXX15.asm
   1++CCA4              CopyXX12toXX15:         ldCopyByte  UBnkXX12xLo     ,UBnkXScaled        ; xlo
   1++CCA4 3A AC C0    >                        ld       a,(UBnkXX12xLo)
   1++CCA7 32 A6 C0    >                        ld       (UBnkXScaled),a
   2++CCAA                                      ldCopyByte  UBnkXX12xSign   ,UBnkXScaledSign    ; xsg
   2++CCAA 3A AD C0    >                        ld       a,(UBnkXX12xSign)
   2++CCAD 32 A7 C0    >                        ld       (UBnkXScaledSign),a
   3++CCB0                                      ldCopyByte  UBnkXX12yLo     ,UBnkYScaled        ; xlo
   3++CCB0 3A AE C0    >                        ld       a,(UBnkXX12yLo)
   3++CCB3 32 A8 C0    >                        ld       (UBnkYScaled),a
   4++CCB6                                      ldCopyByte  UBnkXX12ySign   ,UBnkYScaledSign    ; xsg
   4++CCB6 3A AF C0    >                        ld       a,(UBnkXX12ySign)
   4++CCB9 32 A9 C0    >                        ld       (UBnkYScaledSign),a
   5++CCBC                                      ldCopyByte  UBnkXX12zLo     ,UBnkZScaled        ; xlo
   5++CCBC 3A B0 C0    >                        ld       a,(UBnkXX12zLo)
   5++CCBF 32 AA C0    >                        ld       (UBnkZScaled),a
   6++CCC2                                      ldCopyByte  UBnkXX12zSign   ,UBnkZScaledSign    ; xsg
   6++CCC2 3A B1 C0    >                        ld       a,(UBnkXX12zSign)
   6++CCC5 32 AB C0    >                        ld       (UBnkZScaledSign),a
   7++CCC8 C9                                   ret
   8++CCC9
# file closed: ../../Tests/3DTest/../../Universe/Ships/CopyXX12toXX15.asm
 459+ CCC9                                      INCLUDE "../../Universe/Ships/CopyXX18toXX15.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/CopyXX18toXX15.asm
   1++CCC9              CopyXX18toXX15:
   2++CCC9              CopyDrawCamToScaled:
   3++CCC9                      ldCopyByte  UBnkDrawCam0xLo ,UBnkXScaled        ; xlo
   3++CCC9 3A 9A C0    >                        ld       a,(UBnkDrawCam0xLo)
   3++CCCC 32 A6 C0    >                        ld       (UBnkXScaled),a
   4++CCCF                      ldCopyByte  UBnkDrawCam0xSgn,UBnkXScaledSign    ; xsg
   4++CCCF 3A 9C C0    >                        ld       a,(UBnkDrawCam0xSgn)
   4++CCD2 32 A7 C0    >                        ld       (UBnkXScaledSign),a
   5++CCD5                      ldCopyByte  UBnkDrawCam0yLo ,UBnkYScaled        ; xlo
   5++CCD5 3A 9D C0    >                        ld       a,(UBnkDrawCam0yLo)
   5++CCD8 32 A8 C0    >                        ld       (UBnkYScaled),a
   6++CCDB                      ldCopyByte  UBnkDrawCam0ySgn,UBnkYScaledSign    ; xsg
   6++CCDB 3A 9F C0    >                        ld       a,(UBnkDrawCam0ySgn)
   6++CCDE 32 A9 C0    >                        ld       (UBnkYScaledSign),a
   7++CCE1                      ldCopyByte  UBnkDrawCam0zLo ,UBnkZScaled        ; xlo
   7++CCE1 3A A0 C0    >                        ld       a,(UBnkDrawCam0zLo)
   7++CCE4 32 AA C0    >                        ld       (UBnkZScaled),a
   8++CCE7                      ldCopyByte  UBnkDrawCam0zSgn,UBnkZScaledSign    ; xsg
   8++CCE7 3A A2 C0    >                        ld       a,(UBnkDrawCam0zSgn)
   8++CCEA 32 AB C0    >                        ld       (UBnkZScaledSign),a
   9++CCED C9                   ret
  10++CCEE
# file closed: ../../Tests/3DTest/../../Universe/Ships/CopyXX18toXX15.asm
 460+ CCEE                                      INCLUDE "../../Universe/Ships/CopyXX18ScaledToXX15.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/CopyXX18ScaledToXX15.asm
   1++CCEE 2A 20 C0     LoadCraftToCamera:      ld      hl,(UBnKxlo)            ; UBnKxlo, UBnKxhi
   2++CCF1 ED 5B 22 C0                          ld      de,(UBnKxsgn)           ; UBnKxsgn, UBnKylo
   3++CCF5 ED 4B 24 C0                          ld      bc,(UBnKyhi)            ; UBnKyhi, UBnKysgn
   4++CCF9 22 9A C0                             ld      (UBnkDrawCam0xLo),hl    ; UBnkDrawCam0xLo, UBnkDrawCam0xHi
   5++CCFC ED 53 9C C0                          ld      (UBnkDrawCam0xSgn),de   ; UBnkDrawCam0xSgn,UBnkDrawCam0yLo
   6++CD00 ED 43 9E C0                          ld      (UBnkDrawCam0yHi),bc    ; UBnkDrawCam0yHi, UBnkDrawCam0ySgn
   7++CD04
   8++CD04 2A 26 C0                             ld      hl,(UBnKzlo)            ; UBnKzlo, UBnKzhi
   9++CD07 3A 28 C0                             ld      a,(UBnKzsgn)             ; UBnKzlo
  10++CD0A 22 A0 C0                             ld      (UBnkDrawCam0zLo),hl    ; UBnkDrawCam0zLo, UBnkDrawCam0zHi
  11++CD0D 32 A2 C0                             ld      (UBnkDrawCam0zSgn),a    ; UBnkDrawCam0zSgn
  12++CD10 C9                                   ret
  13++CD11              ;                       ld      hl,UBnKxlo
  14++CD11              ;                       ld      de,UBnkDrawCam0xLo
  15++CD11              ;                       NineLDIInstrunctions                ; transfer 9 bytes
  16++CD11 C9                                   ret
  17++CD12
  18++CD12 2A 9A C0     CopyCameraToXX15Signed: ld  hl,(UBnkDrawCam0xLo)
  19++CD15 3A 9C C0                             ld  a,(UBnkDrawCam0xSgn)
  20++CD18 B4                                   or  h
  21++CD19 67                                   ld  h,a
  22++CD1A 22 A6 C0                             ld  (UBnkXScaled),hl
  23++CD1D 2A 9D C0                             ld  hl,(UBnkDrawCam0yLo)
  24++CD20 3A 9F C0                             ld  a,(UBnkDrawCam0ySgn)
  25++CD23 B4                                   or  h
  26++CD24 67                                   ld  h,a
  27++CD25 22 A8 C0                             ld  (UBnkYScaled),hl
  28++CD28 2A A0 C0                             ld  hl,(UBnkDrawCam0zLo)
  29++CD2B 3A A2 C0                             ld  a,(UBnkDrawCam0zSgn)
  30++CD2E B4                                   or  h
  31++CD2F 67                                   ld  h,a
  32++CD30 22 AA C0                             ld  (UBnkZScaled),hl
  33++CD33 C9                                   ret
  34++CD34
  35++CD34              ;;;CopyXX18ScaledToXX15:
  36++CD34              ;;;CopyDrawCamToScaledMatrix:
  37++CD34              ;;;        ldCopyByte  UBnkDrawCam0zSgn, UBnkZScaledSign   ; XX18+8 => XX15+5
  38++CD34              ;;;        ldCopyByte  UBnkDrawCam0xLo,  UBnkXScaled       ; XX18+0 => XX15+0
  39++CD34              ;;;        ldCopyByte  UBnkDrawCam0xSgn, UBnkXScaledSign   ; XX18+2 => XX15+1
  40++CD34              ;;;        ldCopyByte  UBnkDrawCam0yLo,  UBnkYScaled       ; XX18+3 => XX15+2
  41++CD34              ;;;        ldCopyByte  UBnkDrawCam0ySgn, UBnkYScaledSign   ; XX18+5 => XX15+3
  42++CD34              ;;;        ldCopyByte  UBnkDrawCam0zLo,  UBnkZScaled       ; XX18+6 => XX15+4
  43++CD34              ;;;        ret
  44++CD34
  45++CD34              ;;;CopyXX15ToXX18Scaled:
  46++CD34              ;;;CopyScaledMatrixToDrawCam:
  47++CD34              ;;;        ldCopyByte UBnkZScaledSign,   UBnkDrawCam0zSgn  ; XX15+5 => XX18+8
  48++CD34              ;;;        ldCopyByte UBnkXScaled,       UBnkDrawCam0xLo   ; XX15+0 => XX18+0
  49++CD34              ;;;        ldCopyByte UBnkXScaledSign,   UBnkDrawCam0xSgn  ; XX15+1 => XX18+2
  50++CD34              ;;;        ldCopyByte UBnkYScaled,       UBnkDrawCam0yLo   ; XX15+2 => XX18+3
  51++CD34              ;;;        ldCopyByte UBnkYScaledSign,   UBnkDrawCam0ySgn  ; XX15+3 => XX18+5
  52++CD34              ;;;        ldCopyByte UBnkZScaled,       UBnkDrawCam0zLo   ; XX15+4 => XX18+6
  53++CD34              ;;;        ret
  54++CD34
  55++CD34
  56++CD34              XX15EquXX15AddXX18:
  57++CD34              LL94Z:
  58++CD34 26 00                ld      h,0                                                     ;           AddZ = FaceData (XX12)z +  ShipPos (XX18)z
  59++CD36 16 00                ld      d,0                                                     ;
  60++CD38 3A AA C0             ld      a,(UBnkZScaled)                                         ;
  61++CD3B 6F                   ld      l,a                                                     ;
  62++CD3C 3A AB C0             ld      a,(UBnkZScaledSign)                                     ;
  63++CD3F 47                   ld      b,a                                                     ;
  64++CD40 3A A0 C0             ld      a,(UBnkDrawCam0zLo)                                     ;
  65++CD43 5F                   ld      e,a                                                     ;
  66++CD44 3A A2 C0             ld      a,(UBnkDrawCam0zSgn)                                    ;
  67++CD47 4F                   ld      c,a                                                     ;
  68++CD48 CD 33 00             call    ADDHLDESignBC                                           ;
  69++CD4B 47                   ld      b,a                                                     ;
  70++CD4C 7C                   ld      a,h                                                     ;
  71++CD4D 78                   ld      a,b                                                     ;           else  Scaled (XX15) Z = AddZ
  72++CD4E 32 AB C0             ld      (UBnkZScaledSign),a                                     ;
  73++CD51 7D                   ld      a,l                                                     ;
  74++CD52 32 AA C0             ld      (UBnkZScaled),a                                         ;           endif
  75++CD55              LL94X:
  76++CD55 26 00                ld      h,0                                                     ;           AddZ = FaceData (XX12)z +  ShipPos (XX18)z
  77++CD57 16 00                ld      d,0                                                     ;
  78++CD59 3A A6 C0             ld      a,(UBnkXScaled)                                         ;
  79++CD5C 6F                   ld      l,a                                                     ;
  80++CD5D 3A A7 C0             ld      a,(UBnkXScaledSign)                                     ;
  81++CD60 47                   ld      b,a                                                     ;
  82++CD61 3A 9A C0             ld      a,(UBnkDrawCam0xLo)                                     ;
  83++CD64 5F                   ld      e,a                                                     ;
  84++CD65 3A 9C C0             ld      a,(UBnkDrawCam0xSgn)                                    ;
  85++CD68 4F                   ld      c,a                                                     ;
  86++CD69 CD 33 00             call    ADDHLDESignBC                                           ;
  87++CD6C 47                   ld      b,a                                                     ;
  88++CD6D 7C                   ld      a,h                                                     ;
  89++CD6E 78                   ld      a,b                                                     ;           else  Scaled (XX15) Z = AddZ
  90++CD6F 32 A7 C0             ld      (UBnkXScaledSign),a                                     ;
  91++CD72 7D                   ld      a,l                                                     ;
  92++CD73 32 A6 C0             ld      (UBnkXScaled),a                                         ;           endif
  93++CD76              LL94Y:
  94++CD76 26 00                ld      h,0                                                     ;           AddZ = FaceData (XX12)z +  ShipPos (XX18)z
  95++CD78 16 00                ld      d,0                                                     ;
  96++CD7A 3A A8 C0             ld      a,(UBnkYScaled)                                         ;
  97++CD7D 6F                   ld      l,a                                                     ;
  98++CD7E 3A A9 C0             ld      a,(UBnkYScaledSign)                                     ;
  99++CD81 47                   ld      b,a                                                     ;
 100++CD82 3A 9D C0             ld      a,(UBnkDrawCam0yLo)                                     ;
 101++CD85 5F                   ld      e,a                                                     ;
 102++CD86 3A 9F C0             ld      a,(UBnkDrawCam0ySgn)                                    ;
 103++CD89 4F                   ld      c,a                                                     ;
 104++CD8A CD 33 00             call    ADDHLDESignBC                                           ;
 105++CD8D 47                   ld      b,a                                                     ;
 106++CD8E 7C                   ld      a,h                                                     ;
 107++CD8F 78                   ld      a,b                                                     ;           else  Scaled (XX15) Z = AddZ
 108++CD90 32 A9 C0             ld      (UBnkYScaledSign),a                                     ;
 109++CD93 7D                   ld      a,l                                                     ;
 110++CD94 32 A8 C0             ld      (UBnkYScaled),a                                         ;
 111++CD97 C9                   ret
 112++CD98
# file closed: ../../Tests/3DTest/../../Universe/Ships/CopyXX18ScaledToXX15.asm
 461+ CD98                                      INCLUDE "../../Universe/Ships/CopyXX12ToScaled.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/CopyXX12ToScaled.asm
   1++CD98              CopyXX12ToScaled:
   2++CD98              CopyResultToScaled:
   3++CD98                      ldCopyByte  XX12+0,UBnkXScaled      ; xnormal lo
   3++CD98 3A AC C0    >                        ld       a,(XX12+0)
   3++CD9B 32 A6 C0    >                        ld       (UBnkXScaled),a
   4++CD9E                      ldCopyByte  XX12+2,UBnkYScaled      ; ynormal lo
   4++CD9E 3A AE C0    >                        ld       a,(XX12+2)
   4++CDA1 32 A8 C0    >                        ld       (UBnkYScaled),a
   5++CDA4                      ldCopyByte  XX12+4,UBnkZScaled      ; znormal lo and leaves a holding zscaled normal
   5++CDA4 3A B0 C0    >                        ld       a,(XX12+4)
   5++CDA7 32 AA C0    >                        ld       (UBnkZScaled),a
   6++CDAA C9                   ret
   7++CDAB
# file closed: ../../Tests/3DTest/../../Universe/Ships/CopyXX12ToScaled.asm
 462+ CDAB              ;--------------------------------------------------------------------------------------------------------
 463+ CDAB                                      INCLUDE "../../Maths/Utilities/DotProductXX12XX15.asm"
# file opened: ../../Tests/3DTest/../../Maths/Utilities/DotProductXX12XX15.asm
   1++CDAB              ;;; Q = XX12 xLo ,A = XX15 xLo
   2++CDAB              ;;; T = A * Q/256 Usgined  (FMLTU)
   3++CDAB              ;;; S = XX12 XSign Xor XX15 XSign
   4++CDAB              ;;; Q = XX12 Ynormal Lo, A = XX15+2 (y lo)
   5++CDAB              ;;; Q = A * Q/256 Usigned (FMLTI)
   6++CDAB              ;;; R = T
   7++CDAB              ;;; A = XX12+3 (ySign) Xor XX15+3 (ySign)
   8++CDAB              ;;; T = BADD s(A) = R + Q(SA) (xdot + ydot)
   9++CDAB              ;;; Q = XX12+4 (znormal lo) A = XX15+4 z lo
  10++CDAB              ;;; Q = A * Q /256 usigned (zdot)
  11++CDAB              ;;; R = T
  12++CDAB              ;;; A - XX15+ 5 Zsign Xor XX12+5 Z Sign
  13++CDAB
  14++CDAB
  15++CDAB
  16++CDAB
  17++CDAB
  18++CDAB              MacroAequDxEdiv256usgn:	MACRO
  19++CDAB ~            						mul
  20++CDAB ~            						ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
  21++CDAB              						ENDM
  22++CDAB              DotProductXX12XX15:
  23++CDAB 3A AC C0             ld          a,(UBnkXX12xLo)         ; Use e as var Q for xnormal lo
  24++CDAE                      JumpIfAIsZero dotxskipzero
  24++CDAE A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  24++CDAF CA CC CD    >                        jp	    z, dotxskipzero
  25++CDB2 5F                   ld          e,a
  26++CDB3 3A A6 C0             ld          a,(UBnkXScaled)         ; use d as XX12 world xform x, e = norm x
  27++CDB6 57                   ld          d,a                     ; de = xx12 x signed
  28++CDB7                      JumpIfAIsZero dotxskipzero
  28++CDB7 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  28++CDB8 CA CC CD    >                        jp	    z, dotxskipzero
  29++CDBB ED 30        		mul
  30++CDBD 42                   ld          b,d                     ; b = result
  31++CDBE 3A AD C0             ld          a,(UBnkXX12xSign)
  32++CDC1 21 A7 C0             ld          hl,UBnkXScaledSign
  33++CDC4 AE                   xor         (hl)
  34++CDC5 E6 80                and         $80                     ; so sign bit only
  35++CDC7 FD 67                ld          iyh ,a                   ; we actually need to preserve sign in iyh here
  36++CDC9 C3 D0 CD             jp          dotmuly
  37++CDCC              dotxskipzero:
  38++CDCC AF                   xor         a
  39++CDCD 47                   ld          b,a
  40++CDCE FD 67                ld          iyh,a
  41++CDD0              dotmuly:
  42++CDD0              ; now we have b = XX12 x &d  norm x signed
  43++CDD0 3A AE C0             ld          a,(UBnkXX12yLo)
  44++CDD3                      JumpIfAIsZero dotyskipzero
  44++CDD3 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  44++CDD4 CA F3 CD    >                        jp	    z, dotyskipzero
  45++CDD7 5F                   ld          e,a
  46++CDD8 3A A8 C0             ld          a,(UBnkYScaled)         ; XX15+2
  47++CDDB                      JumpIfAIsZero dotyskipzero
  47++CDDB A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  47++CDDC CA F3 CD    >                        jp	    z, dotyskipzero
  48++CDDF 57                   ld          d,a                     ; de = xx12 x signed
  49++CDE0 ED 30                mul
  50++CDE2 4A                   ld          c,d                     ; c = result
  51++CDE3 DD 69                ld          ixl,c
  52++CDE5 3A AF C0             ld          a,(UBnkXX12ySign)       ; A = ysg
  53++CDE8 21 A9 C0             ld          hl, UBnkYScaledSign     ; a= y sign XOR Y scaled sign
  54++CDEB AE                   xor         (hl)                    ; XX15+3
  55++CDEC E6 80                and         $80                     ; do b = x mul c = y mul, iyh = sign for b and a = sign for c
  56++CDEE DD 67                ld          ixh,a
  57++CDF0 C3 F7 CD             jp          dotaddxy
  58++CDF3              dotyskipzero:
  59++CDF3 AF                   xor         a
  60++CDF4 4F                   ld          c,a
  61++CDF5 DD 67                ld          ixh,a
  62++CDF7              dotaddxy:
  63++CDF7              ; Optimise later as this is 16 bit
  64++CDF7 26 00                ld          h,0                     ;
  65++CDF9 68                   ld          l,b                     ; hl = xlo + x scaled
  66++CDFA 16 00                ld          d,0                     ;
  67++CDFC 59                   ld          e,c                     ; de = ylo + yscaled
  68++CDFD FD 44                ld          b,iyh                   ; b = sign of xlo + xscaled
  69++CDFF 4F                   ld          c,a                     ; c = sign of ylo + yscaled
  70++CE00 CD 33 00             call ADDHLDESignBC                  ; so now hl = result so will push sign to h
  71++CE03 47                   ld          b,a                     ; b = resultant sign , hl = add so far
  72++CE04 3A B0 C0             ld          a,(UBnkXX12zLo)         ;
  73++CE07                      JumpIfAIsZero dotzskipzero
  73++CE07 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  73++CE08 CA 2D CE    >                        jp	    z, dotzskipzero
  74++CE0B 5F                   ld          e,a                     ;
  75++CE0C 3A AA C0             ld          a,(UBnkZScaled)         ;
  76++CE0F                      JumpIfAIsZero dotzskipzero
  76++CE0F A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  76++CE10 CA 2D CE    >                        jp	    z, dotzskipzero
  77++CE13 57                   ld          d,a
  78++CE14 ED 30                mul
  79++CE16 E5                   push        hl                      ; save prev result
  80++CE17 3A AB C0             ld          a,(UBnkZScaledSign)
  81++CE1A 21 B1 C0             ld          hl, UBnkXX12zSign       ; XX15+5
  82++CE1D AE                   xor         (hl)                    ; hi sign
  83++CE1E E6 80                and         $80                     ; a = sign of multiply
  84++CE20 4F                   ld          c,a                     ; c = sign of z lo & z scaled
  85++CE21 E1                   pop         hl
  86++CE22 5A                   ld          e,d
  87++CE23 16 00                ld          d,0
  88++CE25 CD 33 00             call ADDHLDESignBC
  89++CE28 32 61 69             ld          (varS),a
  90++CE2B 7D                   ld          a,l
  91++CE2C C9                   ret                                 ; returns with A = value, varS = sign
  92++CE2D              dotzskipzero:                               ; if we got here then z was zero so no component so just tidy up from last add
  93++CE2D 78                   ld          a,b
  94++CE2E 32 61 69             ld          (varS),a
  95++CE31 7D                   ld          a,l
  96++CE32 C9                   ret
  97++CE33              ;;;;       DotProductXX12XX15:
  98++CE33              ;;;;       ld          a,(UBnkXX12xLo)         ; Use e as var Q for xnormal lo
  99++CE33              ;;;;       ld          e,a
 100++CE33              ;;;;       ld          a,(UBnkXScaled)         ; use d as XX12 world xform x, e = norm x
 101++CE33              ;;;;       ld          d,a                     ; de = xx12 x signed
 102++CE33              ;;;;		; FMLTU	\ A=A*Q/256unsg using D as A and E as Q
 103++CE33              ;;;;		mul
 104++CE33              ;;;;       ld          b,d                     ; b as var T
 105++CE33              ;;;;       ld          a,(UBnkXX12xSign)
 106++CE33              ;;;;       ld          hl,UBnkXScaledSign
 107++CE33              ;;;;       xor         (hl)
 108++CE33              ;;;;       and         $80                     ; so sign bit only
 109++CE33              ;;;;       ld          (varS),a                ; we did use c as S \ S	\ x-sign, but we actually need it in varS for BADD
 110++CE33              ;;;; now we have b = XX12 x & norm x signed
 111++CE33              ;;;; by here B = xlo & xscaled C = result sign
 112++CE33              ;;;;       ld          a,(UBnkXX12yLo)
 113++CE33              ;;;;       ld          e,a
 114++CE33              ;;;;       ld          a,(UBnkYScaled)         ; XX15+2
 115++CE33              ;;;;		ld          d,a						; MISSED THIS EARLIER BUG FIX
 116++CE33              ;;;;       mul
 117++CE33              ;;;;       ld          a,d
 118++CE33              ;;;;       ld          (varQ),a                ; Q = Y y-dot
 119++CE33              ;;;;       ld          a,b                     ; get back T from above held in b
 120++CE33              ;;;;       ld          (varR),a                ; R= b \ T	\ x-dot
 121++CE33              ;;;;       ld          a,(UBnkXX12ySign)       ; A = ysg
 122++CE33              ;;;;       ld          hl, UBnkYScaledSign     ; a= y sign XOR Y scaled sign
 123++CE33              ;;;;       xor         (hl)                    ; XX15+3
 124++CE33              ;;;;       and         $80
 125++CE33              ;;;;       call        baddll38                ; LL38	\ BADD(S)A=R+Q(SA)   \ 1byte add (subtract)
 126++CE33              ;;;;       ld          (varT),a                ; var T	\ xdot+ydot
 127++CE33              ;;;;       ld          a,(UBnkXX12zLo)         ; use d as  varQ        ; XX12+4	\ znormal lo to varQ
 128++CE33              ;;;;       ld          e,a                     ; use e as var Q
 129++CE33              ;;;;       ld          a,(UBnkZScaled)         ;
 130++CE33              ;;;;       ld          d,a
 131++CE33              ;;;;       mul
 132++CE33              ;;;;       ld          a,d
 133++CE33              ;;;;       ld          (varQ),a                ; Q	\ zdot
 134++CE33              ;;;;       ldCopyByte  varT,varR               ; copy T to R so R = resutl of previous calc
 135++CE33              ;;;;       ld          a,(UBnkZScaledSign)
 136++CE33              ;;;;       ld          hl, UBnkXX12zSign       ; XX15+5
 137++CE33              ;;;;       xor         (hl)                    ; hi sign
 138++CE33              ;;;;       and         $80
 139++CE33              ;;;;       call        baddll38                ; LL38	\ BADD(S)A=R+Q(SA)   \ 1byte add (subtract)
 140++CE33              ;;;;       ret                                 ; returns with A = value, varS = sign
 141++CE33
# file closed: ../../Tests/3DTest/../../Maths/Utilities/DotProductXX12XX15.asm
 464+ CE33              ;--------------------------------------------------------------------------------------------------------
 465+ CE33              ; scale Normal. IXL is xReg and A is loaded with XX17 holds the scale factor to apply
 466+ CE33              ; Not Used in code      include "Universe/Ships/ScaleNormal.asm"
 467+ CE33              ;--------------------------------------------------------------------------------------------------------
 468+ CE33                                      INCLUDE "../../Universe/Ships/ScaleObjectDistance.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/ScaleObjectDistance.asm
   1++CE33              ScaleObjectDistance:
   2++CE33              ; ">ScaleObjectDistance, scales camera location and returns c = scaling factor (equiv of X reg)"
   3++CE33 3A 09 C4             ld      a,(QAddr)                   ; Hull byte #18 normals scaled by 2^Q% DtProd^XX2  their comment   Dot product gives  normals' visibility in XX2
   4++CE36 4F                   ld      c,a                         ; c = Q factor for scaling of normals
   5++CE37              LL90:                                       ; scaling object distance
   6++CE37 3A A1 C0             ld      a,(UBnkDrawCam0zHi)         ; z_hi
   7++CE3A 47                   ld      b,a                         ; z_hi (yReg)
   8++CE3B                      ReturnIfAIsZero                     ; if zHi 0 test ifis object close/small, i.e. zhi already zero then we are done
   8++CE3B A7          >                        and     a
   8++CE3C C8          >                        ret     z
   9++CE3D              LL90Loop:
  10++CE3D              ; Loop dividing camera by 2 until zhi is 0 and updating scale factor
  11++CE3D 0C                   inc     c                           ; LL90+3 \ repeat INWK z brought closer, take Qscale X up
  12++CE3E                      ShiftMem16Right1 UBnkDrawCam0yLo    ; cam Y /= 2
  12++CE3E 2A 9D C0    >                    ld    hl,(UBnkDrawCam0yLo)
  12++CE41 CB 3C       >                    srl   h
  12++CE43 CB 1D       >                    rr    l
  12++CE45 22 9D C0    >                    ld    (UBnkDrawCam0yLo),hl
  13++CE48                      ShiftMem16Right1 UBnkDrawCam0xLo    ; cam X /= 2
  13++CE48 2A 9A C0    >                    ld    hl,(UBnkDrawCam0xLo)
  13++CE4B CB 3C       >                    srl   h
  13++CE4D CB 1D       >                    rr    l
  13++CE4F 22 9A C0    >                    ld    (UBnkDrawCam0xLo),hl
  14++CE52                      ShiftMem16Right1 UBnkDrawCam0zLo    ; cam Z /= 2
  14++CE52 2A A0 C0    >                    ld    hl,(UBnkDrawCam0zLo)
  14++CE55 CB 3C       >                    srl   h
  14++CE57 CB 1D       >                    rr    l
  14++CE59 22 A0 C0    >                    ld    (UBnkDrawCam0zLo),hl
  15++CE5C 7C                   ld      a,h                         ; last shift will result in zhi adjusted into h reg.
  16++CE5D                      JumpIfAIsNotZero LL90Loop           ; loop until z hi = 0 this gives scalinging in c
  16++CE5D A7          >                        and     a
  16++CE5E C2 3D CE    >                        jp	    nz,LL90Loop
  17++CE61 C9                   ret
  18++CE62
# file closed: ../../Tests/3DTest/../../Universe/Ships/ScaleObjectDistance.asm
 469+ CE62              ;--------------------------------------------------------------------------------------------------------
 470+ CE62
 471+ CE62              ; Backface cull
 472+ CE62              ; is the angle between the ship -> camera vector and the normal of the face as long as both are unit vectors soo we can check that normal z > 0
 473+ CE62              ; normal vector = cross product of ship ccordinates
 474+ CE62              ;
 475+ CE62                                      INCLUDE "../../Universe/Ships/CopyFaceToXX15.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/CopyFaceToXX15.asm
   1++CE62 7E           CopyFaceToXX15:         ld      a,(hl)                      ; get Normal byte 0                                                                    ;;;     if visibility (bits 4 to 0 of byte 0) > XX4
   2++CE63 47                                   ld      b,a                                                    ;;;
   3++CE64 E6 80                                and     SignOnly8Bit
   4++CE66 32 A7 C0                             ld      (UBnkXScaledSign),a           ; write Sign bits to x sign                                                            ;;;
   5++CE69 78                                   ld      a,b
   6++CE6A CB 27                                sla     a                           ; move y sign to bit 7                                                                 ;;;   copy sign bits to XX12
   7++CE6C 47                                   ld      b,a
   8++CE6D E6 80                                and     SignOnly8Bit
   9++CE6F 32 A9 C0                             ld      (UBnkYScaledSign),a           ;                                                                                      ;;;
  10++CE72 78                                   ld      a,b
  11++CE73 CB 27                                sla     a                           ; move y sign to bit 7                                                                 ;;;   copy sign bits to XX12
  12++CE75 E6 80                                and     SignOnly8Bit
  13++CE77 32 AB C0                             ld      (UBnkZScaledSign),a           ;                                                                                      ;;;
  14++CE7A 23                                   inc     hl                          ; move to X ccord
  15++CE7B 7E                                   ld      a,(hl)                      ;                                                                                      ;;;   XX12 x,y,z lo = Normal[loop].x,y,z
  16++CE7C 32 A6 C0                             ld      (UBnkXScaled),a                                                                                                    ;;;
  17++CE7F 23                                   inc     hl                                                                                                                 ;;;
  18++CE80 7E                                   ld      a,(hl)                      ;                                                                                      ;;;
  19++CE81 32 A8 C0                             ld      (UBnkYScaled),a                                                                                                    ;;;
  20++CE84 23                                   inc     hl                                                                                                                 ;;;
  21++CE85 7E                                   ld      a,(hl)                      ;                                                                                      ;;;
  22++CE86 32 AA C0                             ld      (UBnkZScaled),a
  23++CE89 C9                                   ret
  24++CE8A
# file closed: ../../Tests/3DTest/../../Universe/Ships/CopyFaceToXX15.asm
 476+ CE8A                                      INCLUDE "../../Universe/Ships/CopyFaceToXX12.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/CopyFaceToXX12.asm
   1++CE8A 7E           CopyFaceToXX12:         ld      a,(hl)                      ; get Normal byte 0                                                                    ;;;     if visibility (bits 4 to 0 of byte 0) > XX4
   2++CE8B 47                                   ld      b,a                         ; save sign bits to b
   3++CE8C E6 80                                and     SignOnly8Bit
   4++CE8E 32 AD C0                             ld      (UBnkXX12xSign),a           ; write Sign bits to x sign                                                            ;;;
   5++CE91 78                                   ld      a,b
   6++CE92 CB 27                                sla     a                           ; move y sign to bit 7                                                                 ;;;   copy sign bits to XX12
   7++CE94 47                                   ld      b,a
   8++CE95 E6 80                                and     SignOnly8Bit
   9++CE97 32 AF C0                             ld      (UBnkXX12ySign),a           ;                                                                                      ;;;
  10++CE9A 78                                   ld      a,b
  11++CE9B CB 27                                sla     a                           ; move y sign to bit 7                                                                 ;;;   copy sign bits to XX12
  12++CE9D E6 80                                and     SignOnly8Bit
  13++CE9F 32 B1 C0                             ld      (UBnkXX12zSign),a           ;                                                                                      ;;;
  14++CEA2 23                                   inc     hl                          ; move to X ccord
  15++CEA3 7E                                   ld      a,(hl)                      ;                                                                                      ;;;   XX12 x,y,z lo = Normal[loop].x,y,z
  16++CEA4 32 AC C0                             ld      (UBnkXX12xLo),a                                                                                                    ;;;
  17++CEA7 23                                   inc     hl                                                                                                                 ;;;
  18++CEA8 7E                                   ld      a,(hl)                      ;                                                                                      ;;;
  19++CEA9 32 AE C0                             ld      (UBnkXX12yLo),a                                                                                                    ;;;
  20++CEAC 23                                   inc     hl                                                                                                                 ;;;
  21++CEAD 7E                                   ld      a,(hl)                      ;                                                                                      ;;;
  22++CEAE 32 B0 C0                             ld      (UBnkXX12zLo),a
  23++CEB1 C9                                   ret
  24++CEB2
# file closed: ../../Tests/3DTest/../../Universe/Ships/CopyFaceToXX12.asm
 477+ CEB2              ;--------------------------------------------------------------
 478+ CEB2              ;--------------------------------------------------------------
 479+ CEB2                                      INCLUDE "../../ModelRender/BackfaceCull.asm"
# file opened: ../../Tests/3DTest/../../ModelRender/BackfaceCull.asm
   1++CEB2              ;    DEFINE DEBUGDRAWDISTANCE 1
   2++CEB2                  DEFINE CHECKDOTSHIPDATA  1
   3++CEB2               ;   DEFINE DEBUGFORCEFACEDRAW 1
   4++CEB2 00           CurrentNormIdx  DB 0
   5++CEB3              ; SomeFacesVisible:
   6++CEB3              ; EE29:
   7++CEB3
   8++CEB3              ;   Backface cull logic  line of sight vector . face normal vector
   9++CEB3              ;       line of sight vector . face normal vector
  10++CEB3              ;       => line of sight vector = [x y z] + face normal vector
  11++CEB3              ;       Where [x y z] =
  12++CEB3              ;                                               [ [x y z] . sidev ]
  13++CEB3              ;                    projected [x y z] vector = [ [x y z] . roofv ]
  14++CEB3              ;                                               [ [x y z] . nosev ]
  15++CEB3              ;
  16++CEB3              ;   so project the [x y z] vector into the face's normal space
  17++CEB3              ;  line of sight vector = projected [x y z] vector + face normal vector
  18++CEB3              ;                         [ [x y z] . sidev ]   [ normal_x ]
  19++CEB3              ;                       = [ [x y z] . roofv ] + [ normal_y ]
  20++CEB3              ;                         [ [x y z] . nosev ]   [ normal_z ]
  21++CEB3              ;
  22++CEB3              ;                         [ [x y z] . sidev + normal_x ]
  23++CEB3              ;                       = [ [x y z] . roofv + normal_y ]
  24++CEB3              ;                         [ [x y z] . nosev + normal_z ]
  25++CEB3              ;
  26++CEB3              ; so
  27++CEB3              ;              visibility = [ [x y z] . sidev + normal_x ]   [ normal_x ]
  28++CEB3              ;                            [ [x y z] . roofv + normal_y ] . [ normal_y ]
  29++CEB3              ;                           [ [x y z] . nosev + normal_z ]   [ normal_z ]
  30++CEB3              ;
  31++CEB3              ; where face is visible if visibility < 0
  32++CEB3              ;
  33++CEB3              ;   so we set XX15 to [x y z] . sidev
  34++CEB3              ;                     [x y z] . roofv
  35++CEB3              ;                     [x y z] . nosev
  36++CEB3              ;
  37++CEB3
  38++CEB3
  39++CEB3
  40++CEB3 3A A1 C0     ScaleDrawcam:           ld      a,(UBnkDrawCam0zHi)         ; if z hi is 0 then we have scaled XX18
  41++CEB6                                      JumpIfAIsZero .ScaleDone            ;
  41++CEB6 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  41++CEB7 CA E3 CE    >                        jp	    z, .ScaleDone
  42++CEBA 2A 9A C0                             ld      hl,(UBnkDrawCam0xLo)        ; pull postition into registers
  43++CEBD ED 5B 9D C0                          ld      de,(UBnkDrawCam0yLo)        ; we only pull in if needed to save fetches
  44++CEC1 ED 4B A0 C0                          ld      bc,(UBnkDrawCam0zLo)        ;
  45++CEC5 FD 2C        .ScaleNormalLoop:       inc     iyl                         ; Q goes up by one
  46++CEC7                                      ShiftHLRight1                       ; divide cam position by 2
  46++CEC7 CB 3C       >			   srl h
  46++CEC9 CB 1D       >			   rr  l
  47++CECB                                      ShiftDERight1                       ;
  47++CECB CB 3A       >			   srl d
  47++CECD CB 1B       >			   rr  e
  48++CECF                                      ShiftBCRight1                       ;
  48++CECF CB 38       >			   srl b
  48++CED1 CB 19       >			   rr  c
  49++CED3 78                                   ld      a,b                         ; loop if not scaled down
  50++CED4                                      JumpIfAIsNotZero .ScaleNormalLoop     ;
  50++CED4 A7          >                        and     a
  50++CED5 C2 C5 CE    >                        jp	    nz,.ScaleNormalLoop
  51++CED8 22 9A C0                             ld      (UBnkDrawCam0xLo),hl        ; save position back to XX18
  52++CEDB ED 53 9D C0                          ld      (UBnkDrawCam0yLo),de        ;
  53++CEDF ED 43 A0 C0                          ld      (UBnkDrawCam0zLo),bc        ;
  54++CEE3 FD 7D        .ScaleDone:             ld      a,iyl
  55++CEE5 32 66 69                             ld      (varXX17),a                  ; XX17 = normal scale factor for current ship adjusted for camera
  56++CEE8 C9                                   ret
  57++CEE9
  58++CEE9 3A 28 C0     CheckVisible:           ld      a,(UBnKzsgn)                 ; Is the ship behind us
  59++CEEC E6 80        .CheckBehind:           and     SignOnly8Bit                 ; which means z sign is negative
  60++CEEE 20 31                                jr      nz,.ShipNoDraw               ; .
  61++CEF0 2A 26 C0     .CheckViewPort:         ld      hl,(UBnKzlo)                 ; now check to see if its within 90 degree arc
  62++CEF3 7C                                   ld      a,h
  63++CEF4                                      JumpIfAGTENusng ShipMaxDistance, .ShipNoDraw
  63++CEF4 FE C0       >                        cp     ShipMaxDistance
  63++CEF6 D2 21 CF    >                        jp		nc,.ShipNoDraw
  64++CEF9 ED 5B 20 C0  .CheckXAxis:            ld      de,(UBnKxlo)                 ; if abs x > abx z then its out side of view port
  65++CEFD CD 84 76                             call    compare16HLDE
  66++CF00 38 1F                                jr      c,.ShipNoDraw               ; ship is too far out on the X Axis
  67++CF02 ED 5B 23 C0  .CheckYAxis:            ld      de,(UBnKylo)                ; if abs y > abx z then its out side of view port
  68++CF06 CD 84 76                             call    compare16HLDE
  69++CF09 38 16                                jr      c,.ShipNoDraw               ; ship is too far out on the X Axis
  70++CF0B                                      IFDEF   CHECKDOTSHIPDATA
  71++CF0B 3A 04 C4     .CheckDotV2:                ld      a,(DotAddr)
  72++CF0E                                          JumpIfAGTENusng h, .DrawFull
  72++CF0E BC          >                        cp     h
  72++CF0F D2 15 CF    >                        jp		nc,.DrawFull
  73++CF12 C3 27 CF                                 jp      .ShipIsADot
  74++CF15 3A 54 C0     .DrawFull:                  ld      a,(UBnkaiatkecm)            ; its visible but a dot
  75++CF18 F6 40                                    or      ShipIsVisible               ; Visible and not a dot
  76++CF1A E6 F7                                    and     ShipIsNotDot                ;
  77++CF1C 32 54 C0                                 ld      (UBnkaiatkecm),a            ;
  78++CF1F                                          ClearCarryFlag
  78++CF1F B7          >                        or a
  79++CF20 C9                                       ret
  80++CF21                                      ELSE
  81++CF21 ~            .CalculateXX4:              ShiftHLRight1                       ; hl = z pos / 8
  82++CF21 ~                                        ShiftHLRight1                       ; .
  83++CF21 ~                                        ShiftHLRight1                       ; .
  84++CF21 ~                                        ld      a,h
  85++CF21 ~                                        srl     a                           ; if a / 16 <> 0 then ship is a dot
  86++CF21 ~            .DrawAsDotCheck:            JumpIfNotZero   .ShipIsADot
  87++CF21 ~                                        ; Check visbility distance
  88++CF21 ~            .SetXX4Dist:                ;break
  89++CF21 ~                                        ld      a,l
  90++CF21 ~                                        rra                                 ; l may have had bit 0 of h carried in
  91++CF21 ~                                        srl     a                           ; so move it to bit 4 giving A as distance $000xxxxx
  92++CF21 ~                                        srl     a
  93++CF21 ~                                        srl     a
  94++CF21 ~                                        ld      (UBnkDrawAllFaces),a        ; XX4 = "all faces" distance
  95++CF21 ~                                        ld      a,(UBnkaiatkecm)            ; its visible but a dot
  96++CF21 ~                                        or      ShipIsVisible               ; Visible and not a dot
  97++CF21 ~                                        and     ShipIsNotDot                ;
  98++CF21 ~                                        ld      (UBnkaiatkecm),a            ;
  99++CF21 ~                                        ClearCarryFlag
 100++CF21 ~                                        ret
 101++CF21                                      ENDIF
 102++CF21              .ShipNoDraw:            ClearMemBitN  UBnkaiatkecm  , ShipIsVisibleBitNbr ; Assume its hidden
 102++CF21 21 54 C0    >                        ld      hl,UBnkaiatkecm
 102++CF24 CB B6       >                        res     ShipIsVisibleBitNbr,(hl)
 103++CF26 C9                                   ret
 104++CF27 3A 54 C0     .ShipIsADot:            ld      a,(UBnkaiatkecm)            ; its visible but a dot
 105++CF2A                                      IFDEF DEBUGDRAWDISTANCE
 106++CF2A ~                                        or      ShipIsVisible   ;
 107++CF2A                                      ELSE
 108++CF2A F6 48                                    or      ShipIsVisible | ShipIsDot   ;
 109++CF2C                                      ENDIF
 110++CF2C 32 54 C0                             ld      (UBnkaiatkecm),a            ;
 111++CF2F C9                                   ret
 112++CF30
 113++CF30                                                  DISPLAY "TODO:remove all teh processing of rotmat to load craft to camera as its already been done"
 114++CF30              CullV2:                 ReturnIfMemisZero FaceCtX4Addr      ;
 114++CF30 3A 03 C4    >                        ld   a,(FaceCtX4Addr)
 114++CF33 A7          >                        and a
 114++CF34 C8          >                        ret    z
 115++CF35                                      ;break
 116++CF35 CD 36 CA                             call    CopyRotmatToTransMat        ; XX16 = UBNKRotMat
 117++CF38 CD EE 64                             call    ScaleXX16Matrix197          ; scale rotation matrix in XX16
 118++CF3B CD EE CC                             call    LoadCraftToCamera           ; XX18 = camera
 119++CF3E                                      ;call    CopyCameraToXX15Signed      ; Copy the camera to XX15 as signed 15 bit
 120++CF3E 3A 09 C4     .BackfaceLoop:          ld      a,(QAddr)                   ;
 121++CF41 FD 6F                                ld      iyl,a                       ; iyl = scale factor
 122++CF43              ; By this point XX18 = scaled draw cam and iyl = scale factor
 123++CF43 CD B3 CE                             call    ScaleDrawcam                ; XX18 = scaled camera XX17 = scale
 124++CF46 CD 12 CD                             call    CopyCameraToXX15Signed      ; Xx18 -> xx15 sign + 15 bit
 125++CF49 CD 81 64     .LL91:                  call    XX12EquNodeDotXX16          ; xx12 = Scaled Camera . Rotation matrix (Note Xx16 no Xx16 inv)
 126++CF4C CD 7F CC                             call    CopyXX12ScaledToXX18        ; now xx18 = XX12 = xx15.xx16
 127++CF4F 21 C9 C5     .PrepNormals:           ld      hl,UBnkHullNormals                                                                                                 ;;; V = address of Normal start
 128++CF52 22 65 68                             ld      (varV),hl
 129++CF55 3A 03 C4                             ld      a,(FaceCtX4Addr)                                        ; For each face
 130++CF58 CB 3F                                srl     a                                              ;
 131++CF5A CB 3F                                srl     a                                              ;
 132++CF5C 47                                   ld      b,a                                            ;
 133++CF5D AF                                   xor     a
 134++CF5E 32 B2 CE                             ld      (CurrentNormIdx),a                                          ; used to increment up face incdex as b decrements
 135++CF61 E5           .ProcessNormalsLoop:    push    hl
 136++CF62 C5                                   push    bc
 137++CF63 7E           .LL86:                  ld      a,(hl)                                         ; Get Face sign and visibility distance byte
 138++CF64 E6 1F                                and     $1F                                            ; if normal visibility range  < XX4
 139++CF66 E5                                   push    hl
 140++CF67 21 52 C0                             ld      hl,UBnkDrawAllFaces
 141++CF6A BE                                   cp      (hl)
 142++CF6B E1                                   pop     hl
 143++CF6C                                      IFDEF DEBUGFORCEFACEDRAW
 144++CF6C ~                                        jp      .FaceVisible
 145++CF6C                                      ELSE
 146++CF6C DA B1 D0                                 jp      c,.FaceVisible              ; then we always draw
 147++CF6F                                      ENDIF
 148++CF6F              ; This bit needs to be added to force face visible
 149++CF6F CD 8A CE     .LL87:                  call    CopyFaceToXX12              ; XX12 = normal (repolaced scale version) as a working copy
 150++CF72 3A 66 69                             ld      a,(XX17)                    ; a = q scale XX17 cauclated by the call to ScaleDrawcam
 151++CF75 47                                   ld      b,a
 152++CF76                                      JumpIfALTNusng 4,.ScaleNormByXX17   ; if q >= 4 then is so big we don;t factor in + normal for dot product
 152++CF76 FE 04       >                        cp      4
 152++CF78 DA B3 CF    >                        jp		c, .ScaleNormByXX17
 153++CF7B CD C9 CC     .LL143:                 call    CopyXX18toXX15              ; and we just set XX15 = scaled Camera dot rotation matrix
 154++CF7E C3 42 D0                             jp      .DoneScalingIntoXX15        ; Now Process XX12 normal
 155++CF81 3A 9A C0     .Ovflw:                 ld      a,(UBnkDrawCam0xLo)         ; divide camera by 2 if overflow
 156++CF84 CB 3F                                srl     a                           ; which is held in XX18
 157++CF86 32 9A C0                             ld      (UBnkDrawCam0xLo),a         ; .
 158++CF89 3A A0 C0                             ld      a,(UBnkDrawCam0zLo)         ; .
 159++CF8C CB 3F                                srl     a                           ; .
 160++CF8E 32 A0 C0                             ld      (UBnkDrawCam0zLo),a         ; .
 161++CF91 3A 9D C0                             ld      a,(UBnkDrawCam0yLo)         ; .
 162++CF94 CB 3F                                srl     a                           ; .
 163++CF96 32 9D C0                             ld      (UBnkDrawCam0yLo),a        ; .
 164++CF99 06 01        .ScaleXScaledAgain:     ld      b,1                         ; set scale to 1 so we divide original normal by 2 into face and try again and hope we didn't scaled down XX12 earlier so if we did then we must be in the do doo as the object was obscenely large and very close
 165++CF9B                                      ShiftMem8Right1 UBnkXScaled         ; Divide XX15 by 2^B
 165++CF9B 3A A6 C0    >                    ld      a,(UBnkXScaled)
 165++CF9E CB 3F       >                    srl     a
 165++CFA0 32 A6 C0    >                    ld      (UBnkXScaled),a
 166++CFA3                                      ShiftMem8Right1 UBnkYScaled         ;
 166++CFA3 3A A8 C0    >                    ld      a,(UBnkYScaled)
 166++CFA6 CB 3F       >                    srl     a
 166++CFA8 32 A8 C0    >                    ld      (UBnkYScaled),a
 167++CFAB                                      ShiftMem8Right1 UBnkZScaled         ;
 167++CFAB 3A AA C0    >                    ld      a,(UBnkZScaled)
 167++CFAE CB 3F       >                    srl     a
 167++CFB0 32 AA C0    >                    ld      (UBnkZScaled),a
 168++CFB3              ; if we jumped to here scale factor < 4 so we copy in normal to XX15 (scaled) LL92
 169++CFB3              .ScaleNormByXX17:       ;ld      b,a
 170++CFB3 CD A4 CC                             call    CopyXX12toXX15
 171++CFB6 05           .LL93                   dec     b
 172++CFB7 FA D6 CF                             jp      m, .ScaledNorm
 173++CFBA              .LL93Loop:              ShiftMem8Right1 UBnkXScaled        ; Divide XX15 by 2^B, I think this should be really XX12 and is a bug in the original code
 173++CFBA 3A A6 C0    >                    ld      a,(UBnkXScaled)
 173++CFBD CB 3F       >                    srl     a
 173++CFBF 32 A6 C0    >                    ld      (UBnkXScaled),a
 174++CFC2                                      ShiftMem8Right1 UBnkYScaled        ;
 174++CFC2 3A A8 C0    >                    ld      a,(UBnkYScaled)
 174++CFC5 CB 3F       >                    srl     a
 174++CFC7 32 A8 C0    >                    ld      (UBnkYScaled),a
 175++CFCA                                      ShiftMem8Right1 UBnkZScaled        ;
 175++CFCA 3A AA C0    >                    ld      a,(UBnkZScaled)
 175++CFCD CB 3F       >                    srl     a
 175++CFCF 32 AA C0    >                    ld      (UBnkZScaled),a
 176++CFD2 05                                   dec     b                          ;
 177++CFD3 F2 BA CF                             jp      p,.LL93Loop                ; Now we have XX15 as scaled Normal, XX15 as camera, don;t really knwo why as cals work on XX12 and XX18
 178++CFD6              .ScaledNorm:            ;ORIG CODE DOES NOT HAVE THIS call    CopyXX15ToXX12 ; DEBUG as XX15 shoudl be a sacled nromal
 179++CFD6              ; Add normal to XX15
 180++CFD6              ; if we jumped here direct from LL143 then XX15 = drawcam scaled by Q, XX12 = face normal unscaled, XX18 = drawcam scaled also
 181++CFD6              ; if we jumped here via scaling       then XX15 = normal scaled by Q,  XX12 = face normal unscaled, XX16 = drawcam scaled
 182++CFD6              ; if we hit an overflow               then XX15 = drawcam scaled by Q  XX12 = face normal unscaled, XX18 = (drawcam scaled / 2 ) / 2^ nbr overflows (if we cam in vai scaling then its a mess?
 183++CFD6              ; So LL94 is wrong as it shoud be operating on XX12 not XX15
 184++CFD6              .LL94:                  ldCopyByte UBnkZScaled, varR        ; ldCopyByte  UBnkZScaled,     varR  ; if we jumped direct XX15 = drawcam scaled, Xx12 = normal xx18 = drawcam
 184++CFD6 3A AA C0    >                        ld       a,(UBnkZScaled)
 184++CFD9 32 60 69    >                        ld       (varR),a
 185++CFDC                                      ldCopyByte UBnkXX12zSign, varS      ; ldCopyByte  UBnkYScaled,     varS  ; if we did scaling then xx15 = norm scaled XX18 = drawcam
 185++CFDC 3A B1 C0    >                        ld       a,(UBnkXX12zSign)
 185++CFDF 32 61 69    >                        ld       (varS),a
 186++CFE2                                      ldCopyByte  UBnkDrawCam0zLo, varQ   ; AQ = drawcam Z signed
 186++CFE2 3A A0 C0    >                        ld       a,(UBnkDrawCam0zLo)
 186++CFE5 32 5F 69    >                        ld       (varQ),a
 187++CFE8 3A A2 C0                             ld      a,(UBnkDrawCam0zSgn)        ; .
 188++CFEB CD 70 79                             call    SAEquSRPlusAQ               ; SA = drawcam Z dot + z
 189++CFEE DA 81 CF                             jp      c,.Ovflw
 190++CFF1 32 AA C0                             ld      (UBnkZScaled),a             ; XX15Z = SA
 191++CFF4                                      ldCopyByte  varS, UBnkZScaledSign   ;
 191++CFF4 3A 61 69    >                        ld       a,(varS)
 191++CFF7 32 AB C0    >                        ld       (UBnkZScaledSign),a
 192++CFFA                                      ldCopyByte  UBnkXScaled,     varR   ; SR = normal X
 192++CFFA 3A A6 C0    >                        ld       a,(UBnkXScaled)
 192++CFFD 32 60 69    >                        ld       (varR),a
 193++D000                                      ldCopyByte  UBnkXX12xSign,   varS   ; .
 193++D000 3A AD C0    >                        ld       a,(UBnkXX12xSign)
 193++D003 32 61 69    >                        ld       (varS),a
 194++D006                                      ldCopyByte  UBnkDrawCam0xLo, varQ   ; AQ = drawcam x dot
 194++D006 3A 9A C0    >                        ld       a,(UBnkDrawCam0xLo)
 194++D009 32 5F 69    >                        ld       (varQ),a
 195++D00C 3A 9C C0                             ld      a,(UBnkDrawCam0xSgn)        ; .
 196++D00F CD 70 79                             call    SAEquSRPlusAQ               ; SA = normal x + drawcam x dot
 197++D012 DA 81 CF                             jp      c,.Ovflw
 198++D015 32 A6 C0                             ld      (UBnkXScaled),a             ; XX15Z = SA
 199++D018                                      ldCopyByte  varS, UBnkXScaledSign   ; .
 199++D018 3A 61 69    >                        ld       a,(varS)
 199++D01B 32 A7 C0    >                        ld       (UBnkXScaledSign),a
 200++D01E                                      ldCopyByte  UBnkYScaled, varR       ; SR = normal Y
 200++D01E 3A A8 C0    >                        ld       a,(UBnkYScaled)
 200++D021 32 60 69    >                        ld       (varR),a
 201++D024                                      ldCopyByte  UBnkXX12ySign, varS     ; .
 201++D024 3A AF C0    >                        ld       a,(UBnkXX12ySign)
 201++D027 32 61 69    >                        ld       (varS),a
 202++D02A                                      ldCopyByte  UBnkDrawCam0yLo, varQ   ; AQ = drawcam y dot
 202++D02A 3A 9D C0    >                        ld       a,(UBnkDrawCam0yLo)
 202++D02D 32 5F 69    >                        ld       (varQ),a
 203++D030 3A 9F C0                             ld      a,(UBnkDrawCam0ySgn)        ; .
 204++D033 CD 70 79                             call    SAEquSRPlusAQ               ; SA = normal y + drawcam y dot
 205++D036 DA 81 CF                             jp      c,.Ovflw                    ; .
 206++D039 32 A8 C0                             ld      (UBnkYScaled),a             ; XX15 Y = SA
 207++D03C                                      ldCopyByte   varS, UBnkYScaledSign  ; .
 207++D03C 3A 61 69    >                        ld       a,(varS)
 207++D03F 32 A9 C0    >                        ld       (UBnkYScaledSign),a
 208++D042              ; calculate dot product LL89
 209++D042              .DoneScalingIntoXX15:   ldCopyByte  UBnkXX12xLo, varQ       ; Q = norm X XX12
 209++D042 3A AC C0    >                        ld       a,(UBnkXX12xLo)
 209++D045 32 5F 69    >                        ld       (varQ),a
 210++D048 3A A6 C0                             ld      a,(UBnkXScaled)             ; A = XX15 X
 211++D04B CD 38 79                             call    AequAmulQdiv256             ; A = XX15 X * XX 12 X
 212++D04E 32 7B 69                             ld      (varT),a                    ; T = XX15 X * XX 12 X
 213++D051 3A AD C0                             ld      a,(UBnkXX12xSign)           ; S = sign of XX15 X * XX12 X
 214++D054 21 A7 C0                             ld      hl,UBnkXScaledSign          ; .
 215++D057 AE                                   xor     (hl)                        ; .
 216++D058 32 61 69                             ld      (varS),a                    ; .
 217++D05B                                      ldCopyByte  UBnkXX12yLo, varQ       ; Q = norm Y XX12
 217++D05B 3A AE C0    >                        ld       a,(UBnkXX12yLo)
 217++D05E 32 5F 69    >                        ld       (varQ),a
 218++D061 3A A8 C0                             ld      a,(UBnkYScaled)             ; A = XX15 Y
 219++D064 CD 38 79                             call    AequAmulQdiv256             ; A = XX15 Y * XX 12 Y
 220++D067 32 5F 69                             ld      (varQ),a                    ; Q = XX15 Y * XX 12 Y
 221++D06A                                      ldCopyByte  varT,varR               ; R = XX15 X * XX 12 X
 221++D06A 3A 7B 69    >                        ld       a,(varT)
 221++D06D 32 60 69    >                        ld       (varR),a
 222++D070 3A AF C0                             ld      a,  (UBnkXX12ySign)         ; A = sign of XX15 Y * XX 12 Y
 223++D073 21 A9 C0                             ld      hl, UBnkYScaledSign         ; .
 224++D076 AE                                   xor     (hl)                        ; .
 225++D077 CD 70 79                             call    SAEquSRPlusAQ               ; SA = SR+AQ = (X calc) + (Y calc)
 226++D07A 32 7B 69                             ld      (varT),a                    ; T = usigned (X calc) + (Y calc)
 227++D07D                                      ldCopyByte  UBnkXX12zLo, varQ       ; Q = XX12 Z
 227++D07D 3A B0 C0    >                        ld       a,(UBnkXX12zLo)
 227++D080 32 5F 69    >                        ld       (varQ),a
 228++D083 3A AA C0                             ld      a,  (UBnkZScaled)           ; A = XX15 Z
 229++D086 CD 38 79                             call    AequAmulQdiv256             ; A = XX12 Z * XX15 Z
 230++D089 32 5F 69                             ld      (varQ),a                    ; Q = XX12 Z * XX15 Z
 231++D08C                                      ldCopyByte  varT, varR              ; R = usigned (X calc) + (Y calc)
 231++D08C 3A 7B 69    >                        ld       a,(varT)
 231++D08F 32 60 69    >                        ld       (varR),a
 232++D092 3A AB C0                             ld      a,  (UBnkZScaledSign)       ; A = sign of XX12 Z * XX15 Z
 233++D095 21 B1 C0                             ld      hl, UBnkXX12zSign           ; .
 234++D098 AE                                   xor     (hl)                        ; .
 235++D099 CD 70 79                             call    SAEquSRPlusAQ               ; SA = ((X+Y signed)) (Z signed)
 236++D09C FE 00                                cp      0                           ; was the result 0, if so then there are scenarios where SAEquSRPlusAQ can return -ve 0
 237++D09E 28 08                                jr      z,.FaceNotVisible           ; in which case face is not visible
 238++D0A0 3A 61 69                             ld      a,(varS)                    ; if the cacl was a negative number then its visible
 239++D0A3 ED 27 80                             test    $80                         ; this should test S not A
 240++D0A6 20 09                                jr      nz,.FaceVisible                                      ;        if dot product < 0 set face visible
 241++D0A8 3A B2 CE     .FaceNotVisible:         ld          a,(CurrentNormIdx)
 242++D0AB CD 3C CB                             call        SetFaceAHidden                                      ;           set face invisible
 243++D0AE C3 B7 D0                             jp          .ProcessNormalLoopEnd                                ;        end if
 244++D0B1 3A B2 CE     .FaceVisible:            ld          a,(CurrentNormIdx)
 245++D0B4 CD 33 CB                             call        SetFaceAVisible
 246++D0B7 21 B2 CE     .ProcessNormalLoopEnd:  ld          hl, CurrentNormIdx
 247++D0BA 34                                   inc         (hl)                    ; move index pointer up by one
 248++D0BB C1                                   pop         bc
 249++D0BC E1                                   pop         hl                      ; get normal data pointer back
 250++D0BD 3E 04                                ld          a,4
 251++D0BF ED 31                                add         hl,a                    ; move to next normal entry
 252++D0C1 22 65 68                             ld          (varV),hl               ; save as we need it again
 253++D0C4 05                                   dec         b
 254++D0C5 C2 61 CF                             jp          nz,.ProcessNormalsLoop
 255++D0C8 C9                                   ret
 256++D0C9
# file closed: ../../Tests/3DTest/../../ModelRender/BackfaceCull.asm
 480+ D0C9              ;--LL52 to LL55-----------------------------------------------------------------------------------------------------------------
 481+ D0C9
 482+ D0C9              TransposeXX12NodeToXX15:
 483+ D0C9                      ldCopyByte  UBnKxsgn,UbnkXPointSign           ; UBnkXSgn => XX15+2 x sign
 483+ D0C9 3A 22 C0    >                        ld       a,(UBnKxsgn)
 483+ D0CC 32 A8 C0    >                        ld       (UbnkXPointSign),a
 484+ D0CF ED 4B AC C0          ld          bc,(UBnkXX12xLo)                   ; c = lo, b = sign   XX12XLoSign
 485+ D0D3 A8                   xor         b                                   ; a = UBnkKxsgn (or XX15+2) here and b = XX12xsign,  XX12+1 \ rotated xnode h                                                                             ;;;           a = a XOR XX12+1                              XCALC
 486+ D0D4 FA EA D0             jp          m,NodeNegativeX                                                                                                                                                            ;;;           if sign is +ve                        ::LL52   XCALC
 487+ D0D7              ; XX15 [0,1] = INWK[0]+ XX12[0] + 256*INWK[1]                                                                                       ;;;          while any of x,y & z hi <> 0
 488+ D0D7              NodeXPositiveX:
 489+ D0D7 79                   ld          a,c                                 ; We picked up XX12+0 above in bc Xlo
 490+ D0D8 06 00                ld          b,0                                 ; but only want to work on xlo                                                           ;;;              XX15xHiLo = XX12HiLo + xpos lo             XCALC
 491+ D0DA 2A 20 C0             ld          hl,(UBnKxlo)                       ; hl = XX1 UBNKxLo
 492+ D0DD 26 00                ld          h,0                                 ; but we don;t want the sign
 493+ D0DF 09                   add         hl,bc                               ; its a 16 bit add
 494+ D0E0 22 A6 C0             ld          (UbnkXPoint),hl                    ; And written to XX15 0,1
 495+ D0E3 AF                   xor         a                                   ; we want to write 0 as sign bit (not in original code)
 496+ D0E4 32 A8 C0             ld          (UbnkXPointSign),a
 497+ D0E7 C3 06 D1             jp          FinishedThisNodeX
 498+ D0EA              ; If we get here then _sign and vertv_ have different signs so do subtract
 499+ D0EA              NodeNegativeX:
 500+ D0EA              LL52X:                                                 ;
 501+ D0EA 2A 20 C0             ld          hl,(UBnKxlo)                       ; Coord
 502+ D0ED ED 4B AC C0          ld          bc,(UBnkXX12xLo)                   ; XX12
 503+ D0F1 06 00                ld          b,0                                 ; XX12 lo byte only
 504+ D0F3 ED 42                sbc         hl,bc                               ; hl = UBnKx - UBnkXX12xLo
 505+ D0F5 F2 03 D1             jp          p,SetAndMopX                       ; if result is positive skip to write back
 506+ D0F8              NodeXNegSignChangeX:
 507+ D0F8              ; If we get here the result is 2'c compliment so we reverse it and flip sign
 508+ D0F8 CD 87 70             call        negate16hl                          ; Convert back to positive and flip sign
 509+ D0FB 3A A8 C0             ld          a,(UbnkXPointSign)                 ; XX15+2
 510+ D0FE EE 80                xor         $80                                 ; Flip bit 7
 511+ D100 32 A8 C0             ld          (UbnkXPointSign),a                 ; XX15+2
 512+ D103              SetAndMopX:
 513+ D103 22 20 C0             ld          (UBnKxlo),hl                       ; XX15+0
 514+ D106              FinishedThisNodeX:
 515+ D106
 516+ D106              LL53:
 517+ D106
 518+ D106                      ldCopyByte  UBnKysgn,UbnkYPointSign           ; UBnkXSgn => XX15+2 x sign
 518+ D106 3A 25 C0    >                        ld       a,(UBnKysgn)
 518+ D109 32 AB C0    >                        ld       (UbnkYPointSign),a
 519+ D10C ED 4B AE C0          ld          bc,(UBnkXX12yLo)                   ; c = lo, b = sign   XX12XLoSign
 520+ D110 A8                   xor         b                                   ; a = UBnkKxsgn (or XX15+2) here and b = XX12xsign,  XX12+1 \ rotated xnode h                                                                             ;;;           a = a XOR XX12+1                              XCALC
 521+ D111 FA 27 D1             jp          m,NodeNegativeY                                                                                                                                                            ;;;           if sign is +ve                        ::LL52   XCALC
 522+ D114              ; XX15 [0,1] = INWK[0]+ XX12[0] + 256*INWK[1]                                                                                       ;;;          while any of x,y & z hi <> 0
 523+ D114              NodeXPositiveY:
 524+ D114 79                   ld          a,c                                 ; We picked up XX12+0 above in bc Xlo
 525+ D115 06 00                ld          b,0                                 ; but only want to work on xlo                                                           ;;;              XX15xHiLo = XX12HiLo + xpos lo             XCALC
 526+ D117 2A 23 C0             ld          hl,(UBnKylo)                       ; hl = XX1 UBNKxLo
 527+ D11A 26 00                ld          h,0                                 ; but we don;t want the sign
 528+ D11C 09                   add         hl,bc                               ; its a 16 bit add
 529+ D11D 22 A9 C0             ld          (UbnkYPoint),hl                    ; And written to XX15 0,1
 530+ D120 AF                   xor         a                                   ; we want to write 0 as sign bit (not in original code)
 531+ D121 32 A8 C0             ld          (UbnkXPointSign),a
 532+ D124 C3 43 D1             jp          FinishedThisNodeY
 533+ D127              ; If we get here then _sign and vertv_ have different signs so do subtract
 534+ D127              NodeNegativeY:
 535+ D127              LL52Y:                                                 ;
 536+ D127 2A 23 C0             ld          hl,(UBnKylo)                       ; Coord
 537+ D12A ED 4B AE C0          ld          bc,(UBnkXX12yLo)                   ; XX12
 538+ D12E 06 00                ld          b,0                                 ; XX12 lo byte only
 539+ D130 ED 42                sbc         hl,bc                               ; hl = UBnKx - UBnkXX12xLo
 540+ D132 F2 40 D1             jp          p,SetAndMopY                       ; if result is positive skip to write back
 541+ D135              NodeXNegSignChangeY:
 542+ D135              ; If we get here the result is 2'c compliment so we reverse it and flip sign
 543+ D135 CD 87 70             call        negate16hl                          ; Convert back to positive and flip sign
 544+ D138 3A AB C0             ld          a,(UbnkYPointSign)                 ; XX15+2
 545+ D13B EE 80                xor         $80                                 ; Flip bit 7
 546+ D13D 32 AB C0             ld          (UbnkYPointSign),a                 ; XX15+2
 547+ D140              SetAndMopY:
 548+ D140 22 23 C0             ld          (UBnKylo),hl                       ; XX15+0
 549+ D143              FinishedThisNodeY:
 550+ D143
 551+ D143                  DISPLAY "Tracing 5", $
 552+ D143
 553+ D143              TransposeZ:
 554+ D143              LL55:                                                   ; Both y signs arrive here, Onto z                                          ;;;
 555+ D143 3A B1 C0             ld          a,(UBnkXX12zSign)                   ; XX12+5    \ rotated znode hi                                              ;;;
 556+ D146                      JumpOnBitSet a,7,NegativeNodeZ                    ; LL56 -ve Z node                                                           ;;;
 556+ D146 CB 7F       >                        bit 	7,a
 556+ D148 C2 5C D1    >                        jp      nz,NegativeNodeZ
 557+ D14B 3A B0 C0             ld          a,(UBnkXX12zLo)                     ; XX12+4 \ rotated znode lo                                                 ;;;
 558+ D14E 2A 26 C0             ld          hl,(UBnKzlo)                        ; INWK+6    \ zorg lo                                                       ;;;
 559+ D151 ED 31                add         hl,a                                ; hl = INWKZ + XX12z                                                        ;;;
 560+ D153 7D                   ld          a,l
 561+ D154 32 7B 69             ld          (varT),a                            ;                                                                           ;;;
 562+ D157 7C                   ld          a,h
 563+ D158 32 5E 69             ld          (varU),a                            ; now z = hl or U(hi).T(lo)                                                 ;;;
 564+ D15B C9                   ret                                             ; LL57  \ Node additions done, z = U.T                                      ;;;
 565+ D15C              ; Doing additions and scalings for each visible node around here                                                                    ;;;
 566+ D15C              NegativeNodeZ:
 567+ D15C              LL56:                                                   ; Enter XX12+5 -ve Z node case  from above                                  ;;;
 568+ D15C 2A 26 C0             ld          hl,(UBnKzlo)                        ; INWK+6 \ z org lo                                                         ;;;
 569+ D15F ED 4B B0 C0          ld          bc,(UBnkXX12zLo)                    ; XX12+4    \ rotated z node lo                                                 ......................................................
 570+ D163 06 00                ld          b,0                                 ; upper byte will be garbage
 571+ D165                      ClearCarryFlag
 571+ D165 B7          >                        or a
 572+ D166 ED 42                sbc         hl,bc                               ; 6502 used carry flag compliment
 573+ D168 7D                   ld          a,l
 574+ D169 32 7B 69             ld          (varT),a                            ; t = result low
 575+ D16C 7C                   ld          a,h
 576+ D16D 32 5E 69             ld          (varU),a                            ; u = result high
 577+ D170 E2 7D D1             jp          po,MakeNodeClose                    ; no overflow to parity would be clear
 578+ D173              LL56Overflow:
 579+ D173 FE 00                cp          0                                   ; is varU 0?
 580+ D175 20 16                jr          nz,NodeAdditionsDone                ; Enter Node additions done, UT=z
 581+ D177 3A 7B 69             ld          a,(varT)                            ; T \ restore z lo
 582+ D17A                      ReturnIfAGTENusng 4                              ; >= 4 ? zlo big enough, Enter Node additions done.
 582+ D17A FE 04       >                        cp    4
 582+ D17C D0          >                        ret	 nc
 583+ D17D              MakeNodeClose:
 584+ D17D              LL140:                                                  ; else make node close
 585+ D17D AF                   xor         a                                   ; hi This needs tuning to use a 16 bit variable
 586+ D17E 32 5E 69             ld          (varU),a                            ; U
 587+ D181 3E 04                ld          a,4                                 ; lo
 588+ D183 32 7B 69             ld          (varT),a                            ; T
 589+ D186 C9                   ret
 590+ D187              ;--LL49-------------------------------------------------------------------------------------------------------------------------
 591+ D187              ProcessVisibleNode:
 592+ D187              RotateNode:                                                                                                                         ;;;
 593+ D187 CD 4E CC             call        XX12EquXX15DotProductXX16                                                                                       ;;;           call      XX12=XX15.XX16
 594+ D18A              LL52LL53LL54LL55
 595+ D18A              TransposeNode:
 596+ D18A CD C9 D0             call        TransposeXX12NodeToXX15
 597+ D18D
 598+ D18D              ; ......................................................                                                         ;;;
 599+ D18D              NodeAdditionsDone:
 600+ D18D              Scale16BitTo8Bit:
 601+ D18D              LL57:                                                   ; Enter Node additions done, z=T.U set up from LL55
 602+ D18D 3A 5E 69             ld          a,(varU)                            ; U \ z hi
 603+ D190 21 A7 C0             ld          hl,UbnkXPointHi
 604+ D193 B6                   or          (hl)                                ; XX15+1    \ x hi
 605+ D194 21 AA C0             ld          hl,UbnkYPointHi
 606+ D197 B6                   or          (hl)                                ; XX15+4    \ y hi
 607+ D198              AreXYZHiAllZero:
 608+ D198 28 2B                jr          z,NodeScalingDone                   ; if X, Y, Z = 0  exit loop down once hi U rolled to 0
 609+ D19A              DivideXYZBy2:
 610+ D19A                      ShiftMem16Right1    UbnkXPoint                  ; XX15[0,1]
 610+ D19A 2A A6 C0    >                    ld    hl,(UbnkXPoint)
 610+ D19D CB 3C       >                    srl   h
 610+ D19F CB 1D       >                    rr    l
 610+ D1A1 22 A6 C0    >                    ld    (UbnkXPoint),hl
 611+ D1A4                      ShiftMem16Right1    UbnkYPoint                  ; XX15[3,4]
 611+ D1A4 2A A9 C0    >                    ld    hl,(UbnkYPoint)
 611+ D1A7 CB 3C       >                    srl   h
 611+ D1A9 CB 1D       >                    rr    l
 611+ D1AB 22 A9 C0    >                    ld    (UbnkYPoint),hl
 612+ D1AE 3A 5E 69             ld          a,(varU)                            ; U \ z hi
 613+ D1B1 67                   ld          h,a
 614+ D1B2 3A 7B 69             ld          a,(varT)                            ; T \ z lo
 615+ D1B5 6F                   ld          l,a
 616+ D1B6                      ShiftHLRight1
 616+ D1B6 CB 3C       >			   srl h
 616+ D1B8 CB 1D       >			   rr  l
 617+ D1BA 7C                   ld          a,h
 618+ D1BB 32 5E 69             ld          (varU),a
 619+ D1BE 7D                   ld          a,l
 620+ D1BF 32 7B 69             ld          (varT),a                            ; T \ z lo
 621+ D1C2 C3 8D D1             jp          Scale16BitTo8Bit                    ; loop U
 622+ D1C5              NodeScalingDone:
 623+ D1C5              LL60:                                                   ; hi U rolled to 0, exited loop above.
 624+ D1C5              ProjectNodeToScreen:
 625+ D1C5                      ldCopyByte  varT,varQ                           ; T =>  Q   \ zdist lo
 625+ D1C5 3A 7B 69    >                        ld       a,(varT)
 625+ D1C8 32 5F 69    >                        ld       (varQ),a
 626+ D1CB 3A A6 C0             ld          a,(UbnkXPointLo)                    ; XX15  \ rolled x lo
 627+ D1CE 21 5F 69             ld          hl,varQ
 628+ D1D1 BE                   cp          (hl)                                ; Q
 629+ D1D2                      JumpIfALTusng DoSmallAngle                      ; LL69 if xdist < zdist hop over jmp to small x angle
 629+ D1D2 DA DB D1    >                        jp		c,DoSmallAngle
 630+ D1D5 CD E7 79             call        RequAdivQ                           ; LL61  \ visit up  R = A/Q = x/z
 631+ D1D8 C3 E3 D1             jp          SkipSmallAngle                      ; LL65  \ hop over small xangle
 632+ D1DB              DoSmallAngle:                                           ; small x angle
 633+ D1DB              LL69:
 634+ D1DB              ; TODO check if we need to retain BC as this trashes it
 635+ D1DB              ;Input: BC = Dividend, DE = Divisor, HL = 0
 636+ D1DB              ;Output: BC = Quotient, HL = Remainder
 637+ D1DB 47                   ld      b,a
 638+ D1DC CD 07 73             call    DIV16UNDOC
 639+ D1DF 79                   ld      a,c
 640+ D1E0 32 60 69             ld      (varR),a
 641+ D1E3               ;;;       call        RequAmul256divQ                     ; LL28  \ BFRDIV R=A*256/Q byte for remainder of division
 642+ D1E3              SkipSmallAngle:
 643+ D1E3              ScaleX:
 644+ D1E3              LL65:                                                   ; both continue for scaling based on z
 645+ D1E3 3A A8 C0             ld          a,(UbnkXPointSign)                  ; XX15+2 \ sign of X dist
 646+ D1E6                      JumpOnBitSet a,7,NegativeXPoint                 ; LL62 up, -ve Xdist, RU screen onto XX3 heap
 646+ D1E6 CB 7F       >                        bit 	7,a
 646+ D1E8 C2 FB D1    >                        jp      nz,NegativeXPoint
 647+ D1EB              ; ......................................................
 648+ D1EB              PositiveXPoint:
 649+ D1EB 3A 60 69             ld          a,(varR)
 650+ D1EE 6F                   ld          l,a
 651+ D1EF 3A 5E 69             ld          a,(varU)
 652+ D1F2 67                   ld          h,a
 653+ D1F3 3E 80                ld          a,ScreenCenterX
 654+ D1F5 ED 31                add         hl,a
 655+ D1F7 EB                   ex          de,hl
 656+ D1F8 C3 0B D2             jp          StoreXPoint
 657+ D1FB              NegativeXPoint:
 658+ D1FB              LL62:                                                   ; Arrive from LL65 just below, screen for -ve RU onto XX3 heap, index X=CNT ;;;
 659+ D1FB 3A 60 69             ld          a,(varR)
 660+ D1FE 6F                   ld          l,a
 661+ D1FF 3A 5E 69             ld          a,(varU)
 662+ D202 67                   ld          h,a
 663+ D203 0E 80                ld          c,ScreenCenterX
 664+ D205 06 00                ld          b,0
 665+ D207                      ClearCarryFlag
 665+ D207 B7          >                        or a
 666+ D208 ED 42                sbc         hl,bc                               ; hl = RU-ScreenCenterX
 667+ D20A EB                   ex          de,hl
 668+ D20B              StoreXPoint:                                            ; also from LL62, XX3 node heap has xscreen node so far.
 669+ D20B FD 73 00             ld          (iy+0),e                            ; Update X Point
 670+ D20E FD 72 01             ld          (iy+1),d                            ; Update X Point
 671+ D211 FD 23                inc         iy
 672+ D213 FD 23                inc         iy
 673+ D215              ; ......................................................
 674+ D215              LL66:
 675+ D215              ProcessYPoint:
 676+ D215 AF                   xor         a                                   ; y hi = 0
 677+ D216 32 5E 69             ld          (varU),a                            ; U
 678+ D219                      ldCopyByte  varT,varQ                           ; Q \ zdist lo
 678+ D219 3A 7B 69    >                        ld       a,(varT)
 678+ D21C 32 5F 69    >                        ld       (varQ),a
 679+ D21F 3A A9 C0             ld          a,(UbnkYPointLo)                    ; XX15+3 \ rolled y low
 680+ D222 21 5F 69             ld          hl,varQ
 681+ D225 BE                   cp          (hl)                                ; Q
 682+ D226                      JumpIfALTusng SmallYHop                         ; if ydist < zdist hop to small yangle
 682+ D226 DA 2F D2    >                        jp		c,SmallYHop
 683+ D229              SmallYPoint:
 684+ D229 CD E7 79             call        RequAdivQ                           ; LL61  \ else visit up R = A/Q = y/z
 685+ D22C C3 32 D2             jp          SkipYScale                          ; LL68 hop over small y yangle
 686+ D22F              SmallYHop:
 687+ D22F              LL67:                                                   ; Arrive from LL66 above if XX15+3 < Q \ small yangle
 688+ D22F CD C4 79             call        RequAmul256divQ                     ; LL28  \ BFRDIV R=A*256/Q byte for remainder of division
 689+ D232              SkipYScale:
 690+ D232              LL68:                                                   ; both carry on, also arrive from LL66, yscaled based on z
 691+ D232 3A AB C0             ld          a,(UbnkYPointSign)                  ; XX15+5 \ sign of X dist
 692+ D235 CB 7F                bit         7,a
 693+ D237 C2 4A D2             jp          nz,NegativeYPoint                   ; LL62 up, -ve Xdist, RU screen onto XX3 heap
 694+ D23A              PositiveYPoint:
 695+ D23A 3A 60 69             ld          a,(varR)
 696+ D23D 6F                   ld          l,a
 697+ D23E 3A 5E 69             ld          a,(varU)
 698+ D241 67                   ld          h,a
 699+ D242 3E 60                ld          a,ScreenHeightHalf
 700+ D244 ED 31                add         hl,a
 701+ D246 EB                   ex          de,hl
 702+ D247 C3 5A D2             jp          LL50
 703+ D24A              NegativeYPoint:
 704+ D24A              LL70:                                                   ; Arrive from LL65 just below, screen for -ve RU onto XX3 heap, index X=CNT ;;;
 705+ D24A 3A 60 69             ld          a,(varR)
 706+ D24D 6F                   ld          l,a
 707+ D24E 3A 5E 69             ld          a,(varU)
 708+ D251 67                   ld          h,a
 709+ D252 0E 60                ld          c,ScreenHeightHalf
 710+ D254 06 00                ld          b,0
 711+ D256                      ClearCarryFlag
 711+ D256 B7          >                        or a
 712+ D257 ED 42                sbc         hl,bc                               ; hl = RU-ScreenCenterX
 713+ D259 EB                   ex          de,hl
 714+ D25A              LL50:                                                   ; also from LL62, XX3 node heap has xscreen node so far.
 715+ D25A FD 73 00             ld          (iy+0),e                            ; Update X Point
 716+ D25D FD 72 01             ld          (iy+1),d                            ; Update X Point
 717+ D260 FD 23                inc         iy
 718+ D262 FD 23                inc         iy
 719+ D264 C9                   ret
 720+ D265              ;--------------------------------------------------------------------------------------------------------
 721+ D265              ;;;     Byte 0 = X magnitide with origin at middle of ship
 722+ D265              ;;;     Byte 1 = Y magnitide with origin at middle of ship
 723+ D265              ;;;     Byte 2 = Z magnitide with origin at middle of ship
 724+ D265              ;;;     Byte 3 = Sign Bits of Vertex 7=X 6=Y 5 = Z 4 - 0 = visibility beyond which vertix is not shown
 725+ D265              CopyNodeToXX15:
 726+ D265                      ldCopyByte  hl, UBnkXScaled                     ; Load into XX15                                                                     Byte 0;;;     XX15 xlo   = byte 0
 726+ D265 7E          >                        ld       a,(hl)
 726+ D266 32 A6 C0    >                        ld       (UBnkXScaled),a
 727+ D269 23                   inc         hl
 728+ D26A                      ldCopyByte  hl, UBnkYScaled                     ; Load into XX15                                                                     Byte 0;;;     XX15 xlo   = byte 0
 728+ D26A 7E          >                        ld       a,(hl)
 728+ D26B 32 A8 C0    >                        ld       (UBnkYScaled),a
 729+ D26E 23                   inc         hl
 730+ D26F                      ldCopyByte  hl, UBnkZScaled                     ; Load into XX15                                                                     Byte 0;;;     XX15 xlo   = byte 0
 730+ D26F 7E          >                        ld       a,(hl)
 730+ D270 32 AA C0    >                        ld       (UBnkZScaled),a
 731+ D273 23                   inc         hl
 732+ D274              PopulateXX15SignBits:
 733+ D274              ; Simplfied for debugging, needs optimising back to original DEBUG TODO
 734+ D274 7E                   ld          a,(hl)
 735+ D275 4F                   ld          c,a                                 ; copy sign and visibility to c
 736+ D276 47                   ld          b,a
 737+ D277 E6 80                and         $80                                 ; keep high 3 bits
 738+ D279 32 A7 C0             ld          (UBnkXScaledSign),a                 ; Copy Sign Bits                                                            ;;;
 739+ D27C 78                   ld          a,b
 740+ D27D E6 40                and         $40
 741+ D27F CB 27                sla         a                                   ; Copy Sign Bits                                                            ;;;
 742+ D281 32 A9 C0             ld          (UBnkYScaledSign),a                 ; Copy Sign Bits                                                            ;;;
 743+ D284 78                   ld          a,b
 744+ D285 E6 20                and         $20
 745+ D287 CB 27                sla         a                                   ; Copy Sign Bits                                                            ;;;
 746+ D289 CB 27                sla         a                                   ; Copy Sign Bits                                                            ;;;
 747+ D28B 32 AB C0             ld          (UBnkZScaledSign),a                 ; Copy Sign Bits                                                            ;;;
 748+ D28E 79                   ld          a,c                                 ; returns a with visibility sign byte
 749+ D28F E6 1F                and         $1F                                 ; visibility is held in bits 0 to 4                                                              ;;;     A = XX15 Signs AND &1F (to get lower 5 visibility)
 750+ D291 32 7B 69             ld          (varT),a                            ; and store in varT as its needed later
 751+ D294 C9                   ret
 752+ D295
 753+ D295              ;;;     Byte 4 = High 4 bits Face 2 Index Low 4 bits = Face 1 Index
 754+ D295              ;;;     Byte 5 = High 4 bits Face 4 Index Low 4 bits = Face 3 Index
 755+ D295              ;..............................................................................................................................
 756+ D295              ProcessANode:                                           ; Start loop on Nodes for visibility, each node has 4 faces associated with ;;; For each node (point) in model                  ::LL48
 757+ D295              LL48GetScale:
 758+ D295 3A 50 68             ld          a,(LastNormalVisible)               ; get Normal visible range into e before we copy node
 759+ D298 5F                   ld          e,a
 760+ D299 CD 65 D2             call        CopyNodeToXX15
 761+ D29C              LL48GetVertices:
 762+ D29C              LL48GetVertSignAndVisDist:
 763+ D29C                      JumpIfALTNusng e,NodeIsNotVisible               ; if XX4 > Visibility distance then vertext too far away , next vertex.                                             ;;;        goto LL50 (end of loop)
 763+ D29C BB          >                        cp      e
 763+ D29D DA DA D2    >                        jp		c, NodeIsNotVisible
 764+ D2A0              CheckFace1:                                                                                                                         ;;;     if all FaceVisile[point face any of idx1,2,3 or 4] = 0
 765+ D2A0                      CopyByteAtNextHL varP                           ; vertex byte#4, first 2 faces two 4-bit indices 0:15 into XX2 for 2 of the ;;;     get point face idx from byte 4 & 5 of normal
 765+ D2A0 23          >                    inc         hl                                  ; vertex byte#1
 765+ D2A1 7E          >                    ld          a,(hl)                              ;
 765+ D2A2 32 5F 68    >                    ld          (varP),a                     ; SunXX15+2 = (V),Y
 766+ D2A5 57                   ld          d,a                                 ; use d to hold a as a temp                                                 ;;;
 767+ D2A6 E6 0F                and         $0F                                 ; face 1                                                                    ;;;
 768+ D2A8 E5                   push        hl                                  ; we need to save HL                                                        ;;;
 769+ D2A9                      ldHLIdxAToA UbnkFaceVisArray                    ; visibility at face 1                                                Byte 4;;;
 769+ D2A9 21 D2 C0    >                    ld          hl,UbnkFaceVisArray
 769+ D2AC ED 31       >                    add         hl,a
 769+ D2AE 7E          >                    ld          a,(hl)
 770+ D2AF E1                   pop         hl                                  ;                                                                           ;;;
 771+ D2B0                      JumpIfAIsNotZero NodeIsVisible                  ; is face 1 visible                                                         ;;;
 771+ D2B0 A7          >                        and     a
 771+ D2B1 C2 E0 D2    >                        jp	    nz,NodeIsVisible
 772+ D2B4              CheckFace2:                                                                                                                         ;;;
 773+ D2B4 7A                   ld          a,d                                                                                                             ;;;
 774+ D2B5 ED 23                swapnib                                                                                                                     ;;;
 775+ D2B7 E6 0F                and         $0F                                 ; this is face 2                                                            ;;;
 776+ D2B9                      JumpIfAIsNotZero NodeIsVisible                  ; is face 1 visible                                                         ;;;
 776+ D2B9 A7          >                        and     a
 776+ D2BA C2 E0 D2    >                        jp	    nz,NodeIsVisible
 777+ D2BD              CheckFace3:                                                                                                                         ;;;
 778+ D2BD                      CopyByteAtNextHL varP                           ; vertex byte#4, first 2 faces two 4-bit indices 0:15 into XX2 for 2 of the ;;;
 778+ D2BD 23          >                    inc         hl                                  ; vertex byte#1
 778+ D2BE 7E          >                    ld          a,(hl)                              ;
 778+ D2BF 32 5F 68    >                    ld          (varP),a                     ; SunXX15+2 = (V),Y
 779+ D2C2 57                   ld          d,a                                 ; use d to hold a as a temp                                                 ;;;
 780+ D2C3 E6 0F                and         $0F                                 ; face 1                                                                    ;;;
 781+ D2C5 E5                   push        hl                                  ; we need to save HL                                                        ;;;
 782+ D2C6                      ldHLIdxAToA UbnkFaceVisArray                  ; visibility at face 1                                                Byte 5;;;
 782+ D2C6 21 D2 C0    >                    ld          hl,UbnkFaceVisArray
 782+ D2C9 ED 31       >                    add         hl,a
 782+ D2CB 7E          >                    ld          a,(hl)
 783+ D2CC E1                   pop         hl                                  ;                                                                           ;;;
 784+ D2CD                      JumpIfAIsNotZero NodeIsVisible                  ; is face 1 visible                                                         ;;;
 784+ D2CD A7          >                        and     a
 784+ D2CE C2 E0 D2    >                        jp	    nz,NodeIsVisible
 785+ D2D1              CheckFace4:                                                                                                                         ;;;
 786+ D2D1 7A                   ld          a,d                                                                                                             ;;;
 787+ D2D2 ED 23                swapnib                                                                                                                     ;;;
 788+ D2D4 E6 0F                and         $0F                                 ; this is face 2                                                            ;;;
 789+ D2D6                      JumpIfAIsNotZero NodeIsVisible                  ; is face 1 visible                                                         ;;;
 789+ D2D6 A7          >                        and     a
 789+ D2D7 C2 E0 D2    >                        jp	    nz,NodeIsVisible
 790+ D2DA              NodeIsNotVisible:                                                                                                                   ;;;
 791+ D2DA 01 04 00             ld          bc,4
 792+ D2DD FD 09                add         iy,bc                               ; if not visible then move to next element in array anyway                  ;;;
 793+ D2DF                      ;;; Should we be loading FFFFFFFF into 4 bytes or just ignore?
 794+ D2DF C9                   ret                                                                                                      ;;;        goto LL50 (end of loop)
 795+ D2E0              NodeIsVisible:
 796+ D2E0              LL49:
 797+ D2E0 CD 87 D1             call        ProcessVisibleNode                  ; Process node to determine if it goes on heap
 798+ D2E3 C9                   ret
 799+ D2E4
 800+ D2E4                  DISPLAY "Tracing 6", $
 801+ D2E4
 802+ D2E4              ProjectNodeToEye:
 803+ D2E4 ED 4B AA C0      ld          bc,(UBnkZScaled)                    ; BC = Z Cordinate. By here it MUST be positive as its clamped to 4 min
 804+ D2E8 79               ld          a,c                                 ;  so no need for a negative check
 805+ D2E9 32 5F 69         ld          (varQ),a                            ; VarQ = z
 806+ D2EC 3A A6 C0         ld          a,(UBnkXScaled)                     ; XX15  \ rolled x lo which is signed
 807+ D2EF CD F0 72         call        DIV16Amul256dCUNDOC                 ; result in BC which is 16 bit TODO Move to 16 bit below not just C reg
 808+ D2F2 3A A7 C0         ld          a,(UBnkXScaledSign)                 ; XX15+2 \ sign of X dist
 809+ D2F5                  JumpOnBitSet a,7,EyeNegativeXPoint             ; LL62 up, -ve Xdist, RU screen onto XX3 heap
 809+ D2F5 CB 7F       >                        bit 	7,a
 809+ D2F7 C2 02 D3    >                        jp      nz,EyeNegativeXPoint
 810+ D2FA              EyePositiveXPoint:                                  ; x was positive result
 811+ D2FA 2E 80            ld          l,ScreenCenterX                     ;
 812+ D2FC 26 00            ld          h,0
 813+ D2FE 09               add         hl,bc                               ; hl = Screen Centre + X
 814+ D2FF C3 09 D3         jp          EyeStoreXPoint
 815+ D302              EyeNegativeXPoint:                                 ; x < 0 so need to subtract from the screen centre position
 816+ D302 2E 80            ld          l,ScreenCenterX
 817+ D304 26 00            ld          h,0
 818+ D306                  ClearCarryFlag
 818+ D306 B7          >                        or a
 819+ D307 ED 42            sbc         hl,bc                               ; hl = Screen Centre - X
 820+ D309              EyeStoreXPoint:                                    ; also from LL62, XX3 node heap has xscreen node so far.
 821+ D309 EB               ex          de,hl
 822+ D30A FD 73 00         ld          (iy+0),e                            ; Update X Point TODO this bit is 16 bit aware just need to fix above bit
 823+ D30D FD 72 01         ld          (iy+1),d                            ; Update X Point
 824+ D310              EyeProcessYPoint:
 825+ D310 ED 4B AA C0      ld          bc,(UBnkZScaled)                    ; Now process Y co-ordinate
 826+ D314 79               ld          a,c
 827+ D315 32 5F 69         ld          (varQ),a
 828+ D318 3A A8 C0         ld          a,(UBnkYScaled)                     ; XX15  \ rolled x lo
 829+ D31B CD F0 72         call        DIV16Amul256dCUNDOC                 ; a = Y scaled * 256 / zscaled
 830+ D31E 3A A9 C0         ld          a,(UBnkYScaledSign)                 ; XX15+2 \ sign of X dist
 831+ D321                  JumpOnBitSet a,7,EyeNegativeYPoint             ; LL62 up, -ve Xdist, RU screen onto XX3 heap top of screen is Y = 0
 831+ D321 CB 7F       >                        bit 	7,a
 831+ D323 C2 2E D3    >                        jp      nz,EyeNegativeYPoint
 832+ D326              EyePositiveYPoint:                                  ; Y is positive so above the centre line
 833+ D326 2E 60            ld          l,ScreenCenterY
 834+ D328                  ClearCarryFlag
 834+ D328 B7          >                        or a
 835+ D329 ED 42            sbc         hl,bc                               ; hl = ScreenCentreY - Y coord (as screen is 0 at top)
 836+ D32B C3 33 D3         jp          EyeStoreYPoint
 837+ D32E              EyeNegativeYPoint:                                  ; this bit is only 8 bit aware TODO FIX
 838+ D32E 2E 60            ld          l,ScreenCenterY
 839+ D330 26 00            ld          h,0
 840+ D332 09               add         hl,bc                               ; hl = ScreenCenterY + Y as negative is below the center of screen
 841+ D333              EyeStoreYPoint:                                    ; also from LL62, XX3 node heap has xscreen node so far.
 842+ D333 EB               ex          de,hl
 843+ D334 FD 73 02         ld          (iy+2),e                            ; Update Y Point
 844+ D337 FD 72 03         ld          (iy+3),d                            ; Update Y Point
 845+ D33A C9               ret
 846+ D33B              ; ---------------------------------------------------------------------------------------------------------------------------------
 847+ D33B                          INCLUDE "../../Universe/Ships/ApplyMyRollAndPitch.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/ApplyMyRollAndPitch.asm
   1++D33B
   2++D33B              ; Full version
   3++D33B              ; 1. K2 = y - alpha * x
   4++D33B              ; 2. z = z + beta * K2
   5++D33B              ; 3. y = K2 - beta * z
   6++D33B              ; 4. x = x + alpha * y
   7++D33B
   8++D33B
   9++D33B              APPequPosPlusAPP:       MACRO    Position, PositionSign
  10++D33B ~                                    push    bc
  11++D33B ~                                    ld      c,a                         ; save original value of a into c
  12++D33B ~                                    ld      a,(PositionSign)
  13++D33B ~                                    ld      b,a
  14++D33B ~                                    ld      a,c
  15++D33B ~                                    xor     b                           ; a = a xor x postition sign
  16++D33B ~                                    jp      m,.MV50                     ; if the sign is negative then A and X are both opposite signs
  17++D33B ~            ; Signs are the same to we just add and take which ever sign
  18++D33B ~                                    ld      de,(varPp1)                  ; Note we take p+2,p+1 we we did a previous 24 bit mulitple
  19++D33B ~                                    ld      hl,(Position)
  20++D33B ~                                    add     hl,de
  21++D33B ~                                    ld      (varPp1),hl                  ; now we have P1 and p2 with lo hi and
  22++D33B ~                                    ld      a,c                         ; and a = original sign as they were both the same
  23++D33B ~                                    pop     bc
  24++D33B ~                                    ret
  25++D33B ~            ; Signs are opposite so we subtract
  26++D33B ~            .MV50:                  ld      de,(varPp1)
  27++D33B ~                                    ld      hl,(Position)
  28++D33B ~                                    or      a
  29++D33B ~                                    sbc     hl,de
  30++D33B ~                                    jr      c,.MV51                     ; if the result was negative then negate result
  31++D33B ~                                    ld      a,c                         ; get back the original sign
  32++D33B ~                                    ld      (varPp1),hl                 ; and save result to P[2][1]
  33++D33B ~                                    xor     SignOnly8Bit                ; flip sign and exit A = flip of a
  34++D33B ~                                    pop     bc
  35++D33B ~                                    ret
  36++D33B ~            .MV51:                  NegHL
  37++D33B ~                                    ld      (varPp1),hl
  38++D33B ~                                    ld      a,c                         ; the original sign will still be good
  39++D33B ~                                    pop     bc
  40++D33B ~                                    ret
  41++D33B                                      ENDM
  42++D33B
  43++D33B
  44++D33B              APPequXPosPlusAPP:     APPequPosPlusAPP UBnKxlo, UBnKxsgn
  44++D33B C5          >                        push    bc
  44++D33C 4F          >                        ld      c,a                         ; save original value of a into c
  44++D33D 3A 22 C0    >                        ld      a,(UBnKxsgn)
  44++D340 47          >                        ld      b,a
  44++D341 79          >                        ld      a,c
  44++D342 A8          >                        xor     b                           ; a = a xor x postition sign
  44++D343 FA 54 D3    >                        jp      m,.MV50                     ; if the sign is negative then A and X are both opposite signs
  44++D346             >; Signs are the same to we just add and take which ever sign
  44++D346 ED 5B 60 68 >                        ld      de,(varPp1)                  ; Note we take p+2,p+1 we we did a previous 24 bit mulitple
  44++D34A 2A 20 C0    >                        ld      hl,(UBnKxlo)
  44++D34D 19          >                        add     hl,de
  44++D34E 22 60 68    >                        ld      (varPp1),hl                  ; now we have P1 and p2 with lo hi and
  44++D351 79          >                        ld      a,c                         ; and a = original sign as they were both the same
  44++D352 C1          >                        pop     bc
  44++D353 C9          >                        ret
  44++D354             >; Signs are opposite so we subtract
  44++D354 ED 5B 60 68 >.MV50:                  ld      de,(varPp1)
  44++D358 2A 20 C0    >                        ld      hl,(UBnKxlo)
  44++D35B B7          >                        or      a
  44++D35C ED 52       >                        sbc     hl,de
  44++D35E 38 08       >                        jr      c,.MV51                     ; if the result was negative then negate result
  44++D360 79          >                        ld      a,c                         ; get back the original sign
  44++D361 22 60 68    >                        ld      (varPp1),hl                 ; and save result to P[2][1]
  44++D364 EE 80       >                        xor     SignOnly8Bit                ; flip sign and exit A = flip of a
  44++D366 C1          >                        pop     bc
  44++D367 C9          >                        ret
  44++D368             >.MV51:                  NegHL
  44++D368 AF          >                    xor a
  44++D369 95          >                    sub l
  44++D36A 6F          >                    ld l,a
  44++D36B 9F          >                    sbc a,a
  44++D36C 94          >                    sub h
  44++D36D 67          >                    ld h,a
  44++D36E 22 60 68    >                        ld      (varPp1),hl
  44++D371 79          >                        ld      a,c                         ; the original sign will still be good
  44++D372 C1          >                        pop     bc
  44++D373 C9          >                        ret
  45++D374
  46++D374              APPequYPosPlusAPP:     APPequPosPlusAPP UBnKylo, UBnKysgn
  46++D374 C5          >                        push    bc
  46++D375 4F          >                        ld      c,a                         ; save original value of a into c
  46++D376 3A 25 C0    >                        ld      a,(UBnKysgn)
  46++D379 47          >                        ld      b,a
  46++D37A 79          >                        ld      a,c
  46++D37B A8          >                        xor     b                           ; a = a xor x postition sign
  46++D37C FA 8D D3    >                        jp      m,.MV50                     ; if the sign is negative then A and X are both opposite signs
  46++D37F             >; Signs are the same to we just add and take which ever sign
  46++D37F ED 5B 60 68 >                        ld      de,(varPp1)                  ; Note we take p+2,p+1 we we did a previous 24 bit mulitple
  46++D383 2A 23 C0    >                        ld      hl,(UBnKylo)
  46++D386 19          >                        add     hl,de
  46++D387 22 60 68    >                        ld      (varPp1),hl                  ; now we have P1 and p2 with lo hi and
  46++D38A 79          >                        ld      a,c                         ; and a = original sign as they were both the same
  46++D38B C1          >                        pop     bc
  46++D38C C9          >                        ret
  46++D38D             >; Signs are opposite so we subtract
  46++D38D ED 5B 60 68 >.MV50:                  ld      de,(varPp1)
  46++D391 2A 23 C0    >                        ld      hl,(UBnKylo)
  46++D394 B7          >                        or      a
  46++D395 ED 52       >                        sbc     hl,de
  46++D397 38 08       >                        jr      c,.MV51                     ; if the result was negative then negate result
  46++D399 79          >                        ld      a,c                         ; get back the original sign
  46++D39A 22 60 68    >                        ld      (varPp1),hl                 ; and save result to P[2][1]
  46++D39D EE 80       >                        xor     SignOnly8Bit                ; flip sign and exit A = flip of a
  46++D39F C1          >                        pop     bc
  46++D3A0 C9          >                        ret
  46++D3A1             >.MV51:                  NegHL
  46++D3A1 AF          >                    xor a
  46++D3A2 95          >                    sub l
  46++D3A3 6F          >                    ld l,a
  46++D3A4 9F          >                    sbc a,a
  46++D3A5 94          >                    sub h
  46++D3A6 67          >                    ld h,a
  46++D3A7 22 60 68    >                        ld      (varPp1),hl
  46++D3AA 79          >                        ld      a,c                         ; the original sign will still be good
  46++D3AB C1          >                        pop     bc
  46++D3AC C9          >                        ret
  47++D3AD
  48++D3AD              APPequZPosPlusAPP:     APPequPosPlusAPP UBnKzlo, UBnKzsgn
  48++D3AD C5          >                        push    bc
  48++D3AE 4F          >                        ld      c,a                         ; save original value of a into c
  48++D3AF 3A 28 C0    >                        ld      a,(UBnKzsgn)
  48++D3B2 47          >                        ld      b,a
  48++D3B3 79          >                        ld      a,c
  48++D3B4 A8          >                        xor     b                           ; a = a xor x postition sign
  48++D3B5 FA C6 D3    >                        jp      m,.MV50                     ; if the sign is negative then A and X are both opposite signs
  48++D3B8             >; Signs are the same to we just add and take which ever sign
  48++D3B8 ED 5B 60 68 >                        ld      de,(varPp1)                  ; Note we take p+2,p+1 we we did a previous 24 bit mulitple
  48++D3BC 2A 26 C0    >                        ld      hl,(UBnKzlo)
  48++D3BF 19          >                        add     hl,de
  48++D3C0 22 60 68    >                        ld      (varPp1),hl                  ; now we have P1 and p2 with lo hi and
  48++D3C3 79          >                        ld      a,c                         ; and a = original sign as they were both the same
  48++D3C4 C1          >                        pop     bc
  48++D3C5 C9          >                        ret
  48++D3C6             >; Signs are opposite so we subtract
  48++D3C6 ED 5B 60 68 >.MV50:                  ld      de,(varPp1)
  48++D3CA 2A 26 C0    >                        ld      hl,(UBnKzlo)
  48++D3CD B7          >                        or      a
  48++D3CE ED 52       >                        sbc     hl,de
  48++D3D0 38 08       >                        jr      c,.MV51                     ; if the result was negative then negate result
  48++D3D2 79          >                        ld      a,c                         ; get back the original sign
  48++D3D3 22 60 68    >                        ld      (varPp1),hl                 ; and save result to P[2][1]
  48++D3D6 EE 80       >                        xor     SignOnly8Bit                ; flip sign and exit A = flip of a
  48++D3D8 C1          >                        pop     bc
  48++D3D9 C9          >                        ret
  48++D3DA             >.MV51:                  NegHL
  48++D3DA AF          >                    xor a
  48++D3DB 95          >                    sub l
  48++D3DC 6F          >                    ld l,a
  48++D3DD 9F          >                    sbc a,a
  48++D3DE 94          >                    sub h
  48++D3DF 67          >                    ld h,a
  48++D3E0 22 60 68    >                        ld      (varPp1),hl
  48++D3E3 79          >                        ld      a,c                         ; the original sign will still be good
  48++D3E4 C1          >                        pop     bc
  48++D3E5 C9          >                        ret
  49++D3E6
  50++D3E6              ; rollWork holds Alpha intermidate results
  51++D3E6 00 00 00     rollWork      DS 3
  52++D3E9              rollWorkp1    equ rollWork
  53++D3E9              rollWorkp2    equ rollWork+1
  54++D3E9              rollWorkp3    equ rollWork+2
  55++D3E9
  56++D3E9              ;----------------------------------------------------------------------------------------------------------------------------------
  57++D3E9              ; based on MVEIT part 4 of 9
  58++D3E9 3A 79 68     ApplyMyRollAndPitch:    ld      a,(ALP1)                    ; get roll magnitude
  59++D3EC 21 6D 68                             ld      hl,BET1                     ; and pitch
  60++D3EF B6                                   or      (hl)
  61++D3F0 CA AE D4                             jp      z,.NoRotation               ; if both zero then don't compute
  62++D3F3              ; If the xsgn,ysng or zsng are not 0 or $80 then we use 24 bit routines
  63++D3F3              ; else we can just continue to use 16 bit
  64++D3F3                                     ;jp      ApplyMyRollAndPitch24Bit
  65++D3F3
  66++D3F3 3A 22 C0     .CheckFor24Bit:         ld      a,(UBnKxsgn)
  67++D3F6 21 25 C0                             ld      hl,UBnKysgn
  68++D3F9 B6                                   or      (hl)
  69++D3FA 21 28 C0                             ld      hl,UBnKzsgn
  70++D3FD B6                                   or      (hl)
  71++D3FE E6 7F                                and     $7F
  72++D400 C2 38 D5                             jp      nz,ApplyMyRollAndPitch24Bit
  73++D403                                      ;break
  74++D403              ; P[210] = x * alph (we use P[2]P[1] later as result/256
  75++D403 5F           .Not24BitCalcs:         ld      e,a                         ; e = roll magnitude
  76++D404 2A 20 C0                             ld      hl,(UBnKxlo)                ; hl = ship x pos
  77++D407 CD 3B 6E                             call    AHLequHLmulE                ; MULTU2-2 AHL = UbnkXlo * Alp1 both unsigned
  78++D40A 32 61 68                             ld      (varPhi2),a                 ; set P[2] to high byte to help with ./256
  79++D40D 22 5F 68                             ld      (varP),hl                   ; P (2 1 0) = UbnkXlo * Alph1
  80++D410              ; A = Flip sign
  81++D410 3A 7A 68                             ld      a,(ALP2)                ; flip the current roll angle alpha and xor with x sign
  82++D413 21 22 C0                             ld      hl,UBnKxsgn                 ; and xor with x pos sign
  83++D416 AE                                   xor     (hl)                        ; so now  (A P+2 P+1) = - (x_sign x_hi x_lo) * alpha / 256
  84++D417              ; AP[2]P[1] =Y + AP[2]P[1] (i.e. Previous APP/256)
  85++D417 CD 74 D3                             call    APPequYPosPlusAPP           ; MVT6 calculate APP = y - (x * alpha / 256)
  86++D41A              ; K2 = AP[2][1] K2(3 2 1) = (A P+2 P+1) = y - x * alpha / 256
  87++D41A 32 E8 D3                             ld      (rollWorkp3),a               ; k2+3 = sign of result
  88++D41D 22 E6 D3                             ld      (rollWorkp1),hl             ; k2+1,2 = result
  89++D420              ; P[210] = K2[2 1] * Beta  = (A ~P) * X
  90++D420 3A 6D 68                             ld      a,(BET1)                    ; a = magnitude of pitch
  91++D423 5F                                   ld      e,a
  92++D424 CD 3B 6E                             call    AHLequHLmulE                ; MLTU2-2 AHL = (P+2 P+1) * BET1 or by now ((UbnkXlo * Alph1)/256 * Bet1)
  93++D427 32 61 68                             ld      (varPp2),a                   ; save highest byte in P2
  94++D42A 22 5F 68                             ld      (varP),hl
  95++D42D              ; Fetch sign of previosu cal and xor with BETA inverted
  96++D42D 3A E8 D3                             ld      a,(rollWorkp3)
  97++D430 5F                                   ld      e,a
  98++D431 3A 6E 68                             ld      a,(BET2)
  99++D434 AB                                   xor     e                           ; so we get the sign of K3 and xor with pitch sign
 100++D435              ; Z = P[210] =Z + APP
 101++D435 CD AD D3                             call    APPequZPosPlusAPP           ; MVT6
 102++D438 32 28 C0                             ld      (UBnKzsgn),a                ; save result back into z
 103++D43B 22 26 C0                             ld      (UBnKzlo),hl
 104++D43E              ; A[P1]P[0] = z * Beta
 105++D43E 3A 6D 68                             ld      a,(BET1)                    ; get pitch back again for mulitply in original it was kept in Q so no fetch needed
 106++D441 5F                                   ld      e,a
 107++D442 CD 3B 6E                             call    AHLequHLmulE                ; MULTU2 P2 P1 was already in hl (A P+1 P) = (z_hi z_lo) * beta
 108++D445 32 61 68                             ld      (varPp2),a                  ; P2 = high byte of result
 109++D448 22 5F 68                             ld      (varP),hl                   ; P (2 1 0) = UbnkXlo & Alph1
 110++D44B              ; A xor BET2,Zsign
 111++D44B 3A E8 D3                             ld      a,(rollWorkp3)               ; get K3 (sign of y) and store it in y pos
 112++D44E 32 25 C0                             ld      (UBnKysgn),a                ; save result back into y
 113++D451 5F                                   ld      e,a                         ; a = y sign Xor pitch rate sign
 114++D452 3A 6E 68                             ld      a,(BET2)                    ;
 115++D455 AB                                   xor     e                           ;
 116++D456 5F                                   ld      e,a                         ; now xor it with z sign too
 117++D457 3A 28 C0                             ld      a,(UBnKzsgn)                ;
 118++D45A AB                                   xor     e                           ; so now a = sign of y * beta * sign y * sign z
 119++D45B F2 6A D4                             jp      p,.MV43                     ; if result is pve beta * z and y have differetn signs
 120++D45E 2A 60 68                             ld      hl,(varPp1)
 121++D461 ED 5B E6 D3                          ld      de,(rollWorkp1)
 122++D465 B7                                   or      a
 123++D466 19                                   add     hl,de
 124++D467 C3 84 D4                             jp      .MV44
 125++D46A 2A E6 D3     .MV43:                  ld      hl,(rollWorkp1)
 126++D46D ED 5B 60 68                          ld      de,(varPp1)
 127++D471 B7                                   or      a
 128++D472 ED 52                                sbc     hl,de                       ; (y_hi y_lo) = K2(2 1) - P(2 1)
 129++D474 30 0E                                jr      nc,.MV44                    ; if there was no over flow carry on
 130++D476                                      NegHL
 130++D476 AF          >                    xor a
 130++D477 95          >                    sub l
 130++D478 6F          >                    ld l,a
 130++D479 9F          >                    sbc a,a
 130++D47A 94          >                    sub h
 130++D47B 67          >                    ld h,a
 131++D47C 3A 25 C0                             ld      a,(UBnKysgn)                ; flip sign bit TODO, we may have to remove xor as planets and Univs are sign + 23 bit xpos
 132++D47F EE 80                                xor     SignOnly8Bit
 133++D481 32 25 C0                             ld      (UBnKysgn),a
 134++D484              ; by here we have (y_sign y_hi y_lo) = K2(2 1) - P(2 1) = K2 - beta * z
 135++D484 22 23 C0     .MV44:                  ld      (UBnKylo),hl                ; we do save here to avoid two writes if MV43 ended up with a 2s'c conversion
 136++D487 3A 79 68                             ld      a,(ALP1)                    ; get roll magnitude
 137++D48A 5F                                   ld      e,a
 138++D48B 2A 23 C0                             ld      hl,(UBnKylo)
 139++D48E CD 3B 6E                             call    AHLequHLmulE                ; MLTU2-2 AHL = (y_hi y_lo) * alpha
 140++D491 32 61 68                             ld      (varPp2),a                  ; store high byte P(2 1 0) = (y_hi y_lo) * alpha
 141++D494 22 5F 68                             ld      (varP),hl
 142++D497 3A 7B 68                             ld      a,(ALP2FLIP)
 143++D49A 5F                                   ld      e,a
 144++D49B 3A 25 C0                             ld      a,(UBnKysgn)
 145++D49E AB                                   xor     e                           ; a = sign of roll xor y so now we have (A P+2 P+1) = (y_sign y_hi y_lo) * alpha / 256
 146++D49F CD 3B D3                             call    APPequXPosPlusAPP           ; MVT6 Set (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1) = x + y * alpha / 256
 147++D4A2 32 22 C0                             ld      (UBnKxsgn),a                ; save resutl stright into X pos
 148++D4A5 22 20 C0                             ld      (UBnKxlo),hl
 149++D4A8                                      ;break
 150++D4A8 CD C7 D4                             call    ApplyMyRollToOrientation
 151++D4AB CD F6 D4                             call    ApplyMyPitchToOrientation
 152++D4AE                                      ; if its not a Univ then apply to local orientation
 153++D4AE 3A 59 69     .NoRotation:            ld      a,(DELTA)                   ; get speed
 154++D4B1 16 00                                ld      d,0
 155++D4B3 5F                                   ld      e,a                         ; de = speed in low byte
 156++D4B4 2A 26 C0                             ld      hl,(UBnKzlo)                ; hl = z position
 157++D4B7 3A 28 C0                             ld      a,(UBnKzsgn)                ; b = z sign
 158++D4BA 47                                   ld      b,a                         ;
 159++D4BB 0E 80                                ld      c,$80                       ; c = -ve as we are always moving forwards
 160++D4BD CD 33 00                             call    ADDHLDESignBC               ; update speed
 161++D4C0 22 26 C0                             ld      (UBnKzlo),hl                ; write back to zpos
 162++D4C3 32 28 C0                             ld      (UBnKzsgn),a                ;
 163++D4C6 C9                                   ret
 164++D4C7
 165++D4C7                             DISPLAY "TODO: Looks like pitch is always being applied as positive"
 166++D4C7              ApplyMyRollToOrientation:MMUSelectMathsBankedFns
 166++D4C7 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 167++D4CB 3A 78 68                             ld      a,(ALPHA)
 167++D4CE DD 21 35 C0    ld ix,UBnkrotmatNosevX
 167++D4D2 FD 21 37 C0    ld iy,UBnkrotmatNosevY
 167++D4D6 CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyRollToNosev:
 168++D4D9 3A 78 68                             ld      a,(ALPHA)
 168++D4DC DD 21 29 C0    ld ix,UBnkrotmatSidevX
 168++D4E0 FD 21 2B C0    ld iy,UBnkrotmatSidevY
 168++D4E4 CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyRollToSidev:
 169++D4E7 3A 78 68                             ld      a,(ALPHA)
 169++D4EA DD 21 2F C0    ld ix,UBnkrotmatRoofvX
 169++D4EE FD 21 31 C0    ld iy,UBnkrotmatRoofvY
 169++D4F2 CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyRollToRoofv:
 170++D4F5 C9                                   ret
 171++D4F6
 172++D4F6              ApplyMyPitchToOrientation:
 173++D4F6 3A 6B 68                             ld      a,(BETA)
 173++D4F9 DD 21 39 C0    ld ix,UBnkrotmatNosevZ
 173++D4FD FD 21 37 C0    ld iy,UBnkrotmatNosevY
 173++D501 CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyPitchToNosev:
 174++D504 3A 6B 68                             ld      a,(BETA)
 174++D507 DD 21 2D C0    ld ix,UBnkrotmatSidevZ
 174++D50B FD 21 2B C0    ld iy,UBnkrotmatSidevY
 174++D50F CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyPitchToSidev:
 175++D512 3A 6B 68                             ld      a,(BETA)
 175++D515 DD 21 33 C0    ld ix,UBnkrotmatRoofvZ
 175++D519 FD 21 31 C0    ld iy,UBnkrotmatRoofvY
 175++D51D CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyPitchToRoofv:
 176++D520 C9                                   ret
 177++D521              ;----------------------------------------------------------------------------------------------------------------------------------
 178++D521              ; 24 bit version of pitch and roll is a 24 bit calculation 1 bit sign + 23 bit value
 179++D521              ; Need to write a test routine for roll and pitchs
 180++D521              ; Minsky Roll       Minsky Pitch
 181++D521              ;  y -= alpha * x    y -= beta * z
 182++D521              ;  x += alpha * y    z += beta * y
 183++D521              ; or once combined
 184++D521              ;   1. K2 = y - alpha * x
 185++D521              ;   2. z = z + beta * K2
 186++D521              ;   3. y = K2 - beta * z
 187++D521              ;   4. x = x + alpha * y
 188++D521              ;----------------------------------------------------------------------------------------------------------------------------------
 189++D521              ; Based on non optimised version of Planet pitch and roll is a 24 bit calculation 1 bit sign + 23 bit value
 190++D521              ; Now at least rolls the correct direction
 191++D521 00 00 00 00  UnivAlphaMulX               DB $00,$00, $00, $00
 192++D525 00 00 00 00  UnivAlphaMulY               DB $00,$00, $00, $00
 193++D529 00 00 00 00  UnivAlphaMulZ               DB $00,$00, $00, $00
 194++D52D 00 00 00 00  UnivBetaMulZ                DB $00,$00, $00, $00
 195++D531 00 00 00 00  UnivBetaMulY                DB $00,$00, $00, $00
 196++D535 00 00 00     UnivK2                      DS 3
 197++D538
 198++D538 3A 78 68     ApplyMyRollAndPitch24Bit: 	 ld     a,(ALPHA)                   ; no roll or pitch, no calc needed
 199++D53B 21 6B 68                                  ld     hl,BETA
 200++D53E B6                                        or     (hl)
 201++D53F C4 63 D5                                  call   nz, Univ_Roll_And_Pitch
 202++D542              ;.CheckForRoll:              and		a
 203++D542              ;							call	nz,Univ_Roll
 204++D542              ;.CheckForPitch:				ld		a,(BETA)
 205++D542              ;							and		a
 206++D542              ;							call	nz,Univ_Pitch
 207++D542 3A 59 69     .ApplySpeed:            	ld      a,(DELTA)                   ; BCH = - Delta
 208++D545              							ReturnIfAIsZero
 208++D545 A7          >                        and     a
 208++D546 C8          >                        ret     z
 209++D547 0E 00        							ld      c,0                         ;
 210++D549 67           							ld      h,a                         ;
 211++D54A 06 80        							ld      b,$80                       ;
 212++D54C ED 5B 27 C0  							ld      de,(UBnKzhi)                ; DEL = z position
 213++D550 3A 26 C0     							ld      a,(UBnKzlo)                 ; .
 214++D553 6F           							ld      l,a                         ; .
 215++D554 CD 14 01     							call    AddBCHtoDELsigned           ; update speed
 216++D557 ED 53 27 C0  							ld      (UBnKzhi),DE                ; write back to zpos
 217++D55B 7D           							ld      a,l
 218++D55C 32 26 C0     							ld      (UBnKzlo),a                ;
 219++D55F C9           							ret
 220++D560              ; Performs minsky rotation
 221++D560              ; Joystick left          Joystick right
 222++D560              ; ---------------------  ---------------------
 223++D560              ; x :=  x      + y / 64  x :=  x -  y / 64  so rather than /64  is z * alpha / 256
 224++D560              ; y :=  y      - x /64   y :=  y +  x / 64
 225++D560              ;
 226++D560              ; Joystick down          Joystick up
 227++D560              ; ---------------------  ---------------------
 228++D560              ; y :=  y      + z / 64  y :=  y - z / 64
 229++D560              ; z :=  z      - y / 64  z :=  z + y / 64
 230++D560              ;
 231++D560              ; get z, multiply by alpha, pick top 3 bytes with sign
 232++D560              ; get x, multiply by alpha, pick top 3 bytes with sign
 233++D560              ; if alpha +ve subtract x = x - z adj, z =z + x adj , else x += z adj z -= z adj
 234++D560              ; so we can assume 24 bit maths and just do 16 bit multiply of say HL = nosev x [sgn][hi] and de = [0][alpha] by calling AHLequHLmulE
 235++D560              ; for roll
 236++D560              ; nosev_y = nosev_y - alpha * nosev_x_hi
 237++D560              ; nosev_x = nosev_x + alpha * nosev_y_hi
 238++D560              ; and for pitch
 239++D560              ; nosev_y = nosev_y - beta * nosev_z_hi
 240++D560              ; nosev_z = nosev_z + beta * nosev_y_hi
 241++D560              ;  1. K2 = y - alpha * x
 242++D560              ;   2. z = z + beta * K2
 243++D560              ;   3. y = K2 - beta * z
 244++D560              ;   4. x = x + alpha * y
 245++D560              ;
 246++D560              ;   1a. K [3 2 1 0] = -alpha * (x sign hi lo)
 247++D560              ;   1b. K [3 2 1]   = y sign hi lo + K [321] (in effect y minus (alpha * x / 256)
 248++D560              ;   1c. K2 [3 2 1]  = k [3 2 1 ]
 249++D560              ;   2a. K[3 2 1 0]  = k2 [3 2 1] * beta
 250++D560              ;   2b. z sign hi lo += K[3 2 1] ( in effect z += (beta * K2)/256
 251++D560              ;   3a. K [3 2 1 0] = z sign hi lo * -beta
 252++D560              ;   3b. y sign hi lo = K2 [3 2 1] - K [3 2 1] ( in effect K2 - (beta * z) /256
 253++D560              ;
 254++D560              ;   4. x = x + alpha * y
 255++D560
 256++D560
 257++D560
 258++D560              ;-- Q = - ALPHA
 259++D560              ;-- A P[1 0] = xsign xhi xlo
 260++D560              ;-- call K[3 2 1 0] = A P[1 0] * Q which means  K(3 2 1) = (A P+1 P) * Q / 256 = x * -alpha / 256 = - alpha * x / 256
 261++D560              ;-- call K[3 2 1] = ysign hi lo + K[3 2 1] (= y - alpha * x / 256)
 262++D560              ;-- K2 [3 2 1 ] = K [ 3 2 1 ]
 263++D560              ;-- A P [1 0]   = K [3 2 1]
 264++D560              ;-- Q = BETA
 265++D560              ;-- K[3 2 1 0] = A P[1 0] * Q
 266++D560              ;-- K3[3 2 1] = z sign hi lo + K[3 2 1]
 267++D560              ;-- A P [1 0] = -K [3 2 1]
 268++D560              ;-- z sign hi lo = K[3 2 1]
 269++D560              ;-- K[3 2 1 0] = A P[1 0] * Q
 270++D560              ;-- T = K[3] sign bit
 271++D560              ;-- A = K[3] sign bit xor K2[3]
 272++D560              ;-- if positive A yhi lo - = K [3 2 1 0] + K2[3 2 1 0] so A yhi ylo = K + K2 /256 as we abandon low byte
 273++D560              ;-- if negative A yhi lo = (K - k2 )/256
 274++D560              ;-- A = A xor T
 275++D560              ;-- y sign = A
 276++D560              ;-- Q = alpha
 277++D560              ;-- A P(1 0) = y sign hi lo
 278++D560              ;-- K[3 2 1 0 ] A P[1 0] * Q
 279++D560              ;-- x sign hi lo = K[3 2 1] = xsign hi lo * K[3 2 1]
 280++D560
 281++D560 00 00 00     K2      DS  3
 282++D563
 283++D563 3A 78 68     Univ_Roll_And_Pitch:	    ld      a,(ALPHA)                   ; get roll value
 284++D566              ;** 1. K2 = y - alpha * x **************************************
 285++D566              ;-- DEL = alpha * (x sign hi lo) /256
 286++D566 57           							ld      d,a                         ; d = alpha
 287++D567 3A 20 C0     							ld      a,(UBnKxlo)                 ; HLE = x sgn, hi, lo
 288++D56A 5F           							ld      e,a                         ; .
 289++D56B 2A 21 C0     							ld      hl,(UBnKxhi)                ; hl = UBnKchi sgn
 290++D56E CD 0A 6F     							call    mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * alpha / 256
 291++D571              ;-- DEL = K2 = y - alpha * x
 292++D571 42 4B                                    ld      bc,de                       ; transfer to BCH for now
 293++D573 65                                       ld      h,l
 294++D574 ED 5B 24 C0                              ld      de,(UBnKyhi)
 295++D578 3A 23 C0                                 ld      a,(UBnKylo)
 296++D57B 6F                                       ld      l,a
 297++D57C CD 10 01                                 call    SubBCHfromDELsigned
 298++D57F ED 53 61 D5                              ld      (K2+1),de
 299++D583 7D                                       ld      a,l
 300++D584 32 60 D5                                 ld      (K2),a
 301++D587              ;** 2. z = z + beta * K2 ***************************************
 302++D587              ;-- HLE = DEL ..................................................
 303++D587 EB                                       ex      de,hl                       ; will set hl to de and e to l in one go
 304++D588              ;-- DELC = beta * HLE, i.e. beta * K2
 305++D588 3A 6B 68                                 ld      a,(BETA)
 306++D58B 57                                       ld      d,a
 307++D58C CD 0A 6F                                 call    mulHLEbyDSigned             ; DELC = beta * K2
 308++D58F              ;-- DEL = z + DEL, i.e. z + Beta * K2 /256
 309++D58F ED 4B 27 C0                              ld      bc,(UBnKzhi)                ; BCH = z
 310++D593 3A 26 C0                                 ld      a,(UBnKzlo)                 ; .
 311++D596 67                                       ld      h,a                         ; .
 312++D597 CD 14 01                                 call    AddBCHtoDELsigned           ; DEL =z + (beta * K2)/256
 313++D59A ED 53 27 C0                              ld      (UBnKzhi),de                ; and save to Z
 314++D59E 7D                                       ld      a,l                         ; .
 315++D59F 32 26 C0                                 ld      (UBnKzlo),a                 ; .
 316++D5A2              ;** 3. y = K2 - beta * z ***************************************
 317++D5A2              ;-- DEL = beta * z / 256
 318++D5A2 3A 6B 68                                 ld      a,(BETA)                    ; get pitch value
 319++D5A5 57           							ld      d,a                         ; d = pitch
 320++D5A6 3A 26 C0     							ld      a,(UBnKzlo)                 ; HLE = z sgn, hi, lo
 321++D5A9 5F           							ld      e,a                         ; .
 322++D5AA 2A 27 C0     							ld      hl,(UBnKzhi)                ; hl = UBnKchi sgn
 323++D5AD CD 0A 6F     							call    mulHLEbyDSigned             ; DELC = z * beta, so DEL = z * beta / 256
 324++D5B0              ;-- BCH = DEL ..................................................
 325++D5B0 42 4B                                    ld      bc,de                       ; transfer to BCH for now
 326++D5B2 65                                       ld      h,l
 327++D5B3              ;-- y = DEL = K2 - beta * z = DEL - BCH
 328++D5B3 ED 5B 61 D5                              ld      de,(K2+1)                   ; del = K2
 329++D5B7 3A 60 D5                                 ld      a,(K2)                      ; .
 330++D5BA 6F                                       ld      l,a                         ; .
 331++D5BB CD 10 01                                 call    SubBCHfromDELsigned         ; .
 332++D5BE ED 53 24 C0                              ld      (UBnKyhi),de                ; and save to y
 333++D5C2 7D                                       ld      a,l                         ; .
 334++D5C3 32 23 C0                                 ld      (UBnKylo),a                 ; .
 335++D5C6              ;** 4. x = x + alpha * y ***************************************
 336++D5C6              ;-- DEL = alpha * y
 337++D5C6 3A 78 68                                 ld      a,(ALPHA)                   ; get roll value
 338++D5C9              ;-- DEL = alpha * (y sign hi lo) /256
 339++D5C9 57           							ld      d,a                         ; d = alpha
 340++D5CA 3A 23 C0     							ld      a,(UBnKylo)                 ; HLE = y sgn, hi, lo
 341++D5CD 5F           							ld      e,a                         ; .
 342++D5CE 2A 24 C0     							ld      hl,(UBnKyhi)                ; hl = UBnKyhi sgn
 343++D5D1 CD 0A 6F     							call    mulHLEbyDSigned             ; DELC = y * alpha, so DEL = Y * alpha / 256
 344++D5D4              ;-- DEL = x + alpha * y
 345++D5D4 42 4B                                    ld      bc,de                       ; transfer to BCH for now
 346++D5D6 65                                       ld      h,l                         ; .
 347++D5D7 ED 5B 21 C0                              ld      de,(UBnKxhi)                ; del = x
 348++D5DB 3A 20 C0                                 ld      a,(UBnKxlo)                 ; .
 349++D5DE 6F                                       ld      l,a                         ; .
 350++D5DF CD 14 01                                 call    AddBCHtoDELsigned           ; del = del + bch = x + alpha * y
 351++D5E2 ED 53 21 C0                              ld      (UBnKxhi),de                ; and save to x
 352++D5E6 7D                                       ld      a,l                         ; .
 353++D5E7 32 20 C0                                 ld      (UBnKxlo),a                 ; .
 354++D5EA              .ApplyRollToRight:          ;call    ApplyMyRollToOrientation
 355++D5EA CD F6 D4     .ApplyPitchToClimb:         call    ApplyMyPitchToOrientation
 356++D5ED                                        ;  call    TidyVectorsIX ; doesn't work
 357++D5ED C9           							ret
# file closed: ../../Tests/3DTest/../../Universe/Ships/ApplyMyRollAndPitch.asm
 848+ D5EE                          INCLUDE "../../Universe/Ships/ApplyShipRollAndPitch.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/ApplyShipRollAndPitch.asm
   1++D5EE
   2++D5EE              ; A = value for rotation
   3++D5EE              ; HL = address of value for rotation
   4++D5EE              ; TODO logic for permanent spin, I thik this it -127??
   5++D5EE              SplitAndDampenZ:        MACRO
   6++D5EE ~                                    ld      b,a
   7++D5EE ~                                    and     SignMask8Bit            ; if abs (Rotz) is 0 then skip
   8++D5EE ~                                    jp      z,.ProcessRoll
   9++D5EE ~                                    ld      a,b                     ; b = rotate counter S7
  10++D5EE ~                                    and     SignOnly8Bit            ; a = sign rat2 = c = sign
  11++D5EE ~                                    ld      c,a                     ; .
  12++D5EE ~                                    ld      (univRAT2),a            ; .
  13++D5EE ~                                    ld      a,b                     ; a = abs b
  14++D5EE ~                                    and     SignMask8Bit            ; .
  15++D5EE ~                                    dec     a                       ; dampen
  16++D5EE ~                                    ld      (univRAT2Val),a
  17++D5EE ~                                    or      c                       ; make S7 again after dampening
  18++D5EE ~                                    ld      (UBnKRotZCounter),a
  19++D5EE                                      ENDM
  20++D5EE
  21++D5EE              SplitAndDampenX:        MACRO
  22++D5EE ~                                    ld      b,a
  23++D5EE ~                                    and     SignMask8Bit            ; exit early is ABS = 0
  24++D5EE ~                                    and     a                       ; .
  25++D5EE ~                                    ret     z                       ; .
  26++D5EE ~                                    ld      a,b                     ; a = rotate counter S7
  27++D5EE ~                                    and     SignOnly8Bit            ; rat2 = c = sign
  28++D5EE ~                                    ld      c,a                     ; .
  29++D5EE ~                                    ld      (univRAT2),a            ; .
  30++D5EE ~                                    ld      a,b                     ; a = abs b
  31++D5EE ~                                    and     SignMask8Bit            ; .
  32++D5EE ~                                    dec     a                       ; dampen
  33++D5EE ~                                    ld      (univRAT2Val),a
  34++D5EE ~                                    or      c                       ; make S7 again after dampening
  35++D5EE ~                                    ld      (UBnKRotXCounter),a
  36++D5EE                                      ENDM
  37++D5EE
  38++D5EE
  39++D5EE              ;----------------------------------------------------------------------------------------------------------------------------------
  40++D5EE              ; based on MVEIT part 4 of 9
  41++D5EE              ; x and z counters are proper 2's c values
  42++D5EE 3A 49 C0     ApplyShipRollAndPitch:  ld      a,(UBnKRotZCounter)
  43++D5F1 FE FF                                cp      $FF
  44++D5F3 28 18                                jr      z,.PitchSAxes
  45++D5F5                                      SplitAndDampenZ
  45++D5F5 47          >                        ld      b,a
  45++D5F6 E6 7F       >                        and     SignMask8Bit            ; if abs (Rotz) is 0 then skip
  45++D5F8 CA 3A D6    >                        jp      z,.ProcessRoll
  45++D5FB 78          >                        ld      a,b                     ; b = rotate counter S7
  45++D5FC E6 80       >                        and     SignOnly8Bit            ; a = sign rat2 = c = sign
  45++D5FE 4F          >                        ld      c,a                     ; .
  45++D5FF 32 4F C0    >                        ld      (univRAT2),a            ; .
  45++D602 78          >                        ld      a,b                     ; a = abs b
  45++D603 E6 7F       >                        and     SignMask8Bit            ; .
  45++D605 3D          >                        dec     a                       ; dampen
  45++D606 32 50 C0    >                        ld      (univRAT2Val),a
  45++D609 B1          >                        or      c                       ; make S7 again after dampening
  45++D60A 32 49 C0    >                        ld      (UBnKRotZCounter),a
  46++D60D                                      ;ld      a,(UBnKRotZCounter)
  47++D60D 21 2F C0     .PitchSAxes:            ld	    hl,UBnkrotmatRoofvX; UBnkrotmatSidevY
  48++D610 22 44 68                             ld	    (varAxis1),hl
  49++D613 21 35 C0                             ld	    hl,UBnkrotmatNosevX; UBnkrotmatSidevZ
  50++D616 22 46 68                             ld	    (varAxis2),hl
  51++D619 CD 86 D6                             call    MVS5RotateAxis
  52++D61C 21 31 C0     .PitchRAxes:            ld	    hl,UBnkrotmatRoofvY
  53++D61F 22 44 68                             ld	    (varAxis1),hl
  54++D622 21 37 C0                             ld	    hl,UBnkrotmatNosevY;UBnkrotmatRoofvZ
  55++D625 22 46 68                             ld	    (varAxis2),hl
  56++D628 CD 86 D6                             call    MVS5RotateAxis
  57++D62B 21 33 C0     .PitchNAxes:            ld	    hl,UBnkrotmatRoofvZ; UBnkrotmatNosevY
  58++D62E 22 44 68                             ld	    (varAxis1),hl
  59++D631 21 39 C0                             ld	    hl,UBnkrotmatNosevZ
  60++D634 22 46 68                             ld	    (varAxis2),hl
  61++D637 CD 86 D6                             call    MVS5RotateAxis
  62++D63A 3A 48 C0     .ProcessRoll:           ld      a,(UBnKRotXCounter)
  63++D63D FE FF                                cp      $FF
  64++D63F 28 17                                jr      z,.RollSAxis
  65++D641                                      SplitAndDampenX
  65++D641 47          >                        ld      b,a
  65++D642 E6 7F       >                        and     SignMask8Bit            ; exit early is ABS = 0
  65++D644 A7          >                        and     a                       ; .
  65++D645 C8          >                        ret     z                       ; .
  65++D646 78          >                        ld      a,b                     ; a = rotate counter S7
  65++D647 E6 80       >                        and     SignOnly8Bit            ; rat2 = c = sign
  65++D649 4F          >                        ld      c,a                     ; .
  65++D64A 32 4F C0    >                        ld      (univRAT2),a            ; .
  65++D64D 78          >                        ld      a,b                     ; a = abs b
  65++D64E E6 7F       >                        and     SignMask8Bit            ; .
  65++D650 3D          >                        dec     a                       ; dampen
  65++D651 32 50 C0    >                        ld      (univRAT2Val),a
  65++D654 B1          >                        or      c                       ; make S7 again after dampening
  65++D655 32 48 C0    >                        ld      (UBnKRotXCounter),a
  66++D658 21 2F C0     .RollSAxis:           	ld	    hl,UBnkrotmatRoofvX; UBnkrotmatSidevX
  67++D65B 22 44 68                             ld	    (varAxis1),hl
  68++D65E 21 29 C0                             ld	    hl,UBnkrotmatSidevX; UBnkrotmatSidevY
  69++D661 22 46 68                             ld	    (varAxis2),hl
  70++D664 CD 86 D6                             call    MVS5RotateAxis
  71++D667 21 31 C0     .RollRAxis:             ld	    hl,UBnkrotmatRoofvY; UBnkrotmatRoofvX
  72++D66A 22 44 68                             ld	    (varAxis1),hl
  73++D66D 21 2B C0                             ld	    hl,UBnkrotmatSidevY; UBnkrotmatRoofvY
  74++D670 22 46 68                             ld	    (varAxis2),hl
  75++D673 CD 86 D6                             call    MVS5RotateAxis
  76++D676 21 33 C0     .RollNAxis:             ld	    hl,UBnkrotmatRoofvZ; UBnkrotmatNosevX
  77++D679 22 44 68                             ld	    (varAxis1),hl
  78++D67C 21 2D C0                             ld	    hl,UBnkrotmatSidevZ; UBnkrotmatNosevY
  79++D67F 22 46 68                             ld	    (varAxis2),hl
  80++D682 CD 86 D6                             call    MVS5RotateAxis
  81++D685 C9                                   ret
  82++D686
  83++D686
  84++D686
  85++D686              ; Roate around axis
  86++D686              ; varAxis1 and varAxis2 point to the address of the axis to rotate
  87++D686              ; so the axis x1 points to roofv  x , y or z
  88++D686              ;             x2           nosev or sidev  x, y or z
  89++D686              ;   Axis1 = Axis1 * (1 - 1/512)  + Axis2 / 16
  90++D686              ;   Axis2 = Axis2 * (1 - 1/512)  - Axis1 / 16
  91++D686              ; var RAT2 gives direction
  92++D686              ; for pitch x we come in with Axis1 = roofv_x and Axis2 = nosev_x
  93++D686              ;-Set up S R -----------------------------------------
  94++D686              ; optimised we don't deal with sign here just the value of roof axis / 512
  95++D686 2A 44 68     MVS5RotateAxis:         ld      hl,(varAxis1)   ; work on roofv axis to get (1- 1/152) * roofv axis
  96++D689 5E                                   ld      e,(hl)
  97++D68A 23                                   inc     hl
  98++D68B 56                                   ld      d,(hl)          ; de = Axis1 (roofv x for pitch x)
  99++D68C EB                                   ex      de,hl           ; hl = Axis1 (roofv x for pitch x)
 100++D68D 7C                                   ld      a,h
 101++D68E E6 80                                and     SignOnly8Bit
 102++D690 FD 67                                ld      iyh,a           ; iyh = sign Axis1
 103++D692 7C                                   ld      a,h
 104++D693 E6 7F                                and     SignMask8Bit    ; a = Axis1 (roof hi axis  unsigned)
 105++D695 CB 3F                                srl     a               ; a = Axis1/2
 106++D697 5F                                   ld      e,a             ;
 107++D698 FD 7C                                ld      a,iyh           ; A = Axis 1 sign
 108++D69A 57                                   ld      d,a             ; de = signed Axis1 / 512
 109++D69B B7                                   or      a               ; clear carry
 110++D69C CD 75 01                             call    subHLDES15      ; hl = roof axis - (roof axis /512) which in effect is roof * (1-1/512)
 111++D69F              ;-Push to stack roof axis - (roofaxis/152)  ----------------------------------------------------------------------------------
 112++D69F E5                                   push    hl              ; save hl on stack PUSH ID 1 (roof axis - roofv aixs /512)
 113++D6A0 7D                                   ld      a,l
 114++D6A1 32 60 69                             ld      (varR),a
 115++D6A4 7C                                   ld      a,h
 116++D6A5 32 61 69                             ld      (varS),a        ;  RS now equals (1- 1/152) * roofv axis or (roof axis - roofv aixs /512)
 117++D6A8              ;-calculate roofv latter half of calc
 118++D6A8 2A 46 68                             ld      hl,(varAxis2)   ; now work on nosev axis to get nosev axis / 16
 119++D6AB 5E                                   ld      e,(hl)
 120++D6AC 23                                   inc     hl
 121++D6AD 56                                   ld      d,(hl)          ; de = value of roof axis
 122++D6AE 7A                                   ld      a,d
 123++D6AF E6 80                                and     SignOnly8Bit
 124++D6B1 FD 67                                ld      iyh,a           ; save sign
 125++D6B3 7A                                   ld      a,d
 126++D6B4 E6 7F                                and     SignMask8Bit    ; a = nosev hi axis  unsigned
 127++D6B6 57                                   ld      d,a             ; de = abs (nosev)
 128++D6B7                                      ShiftDERight1
 128++D6B7 CB 3A       >			   srl d
 128++D6B9 CB 1B       >			   rr  e
 129++D6BB                                      ShiftDERight1
 129++D6BB CB 3A       >			   srl d
 129++D6BD CB 1B       >			   rr  e
 130++D6BF                                      ShiftDERight1
 130++D6BF CB 3A       >			   srl d
 130++D6C1 CB 1B       >			   rr  e
 131++D6C3                                      ShiftDERight1           ; de = nosev /16 unsigned
 131++D6C3 CB 3A       >			   srl d
 131++D6C5 CB 1B       >			   rr  e
 132++D6C7 3A 4F C0                             ld      a,(univRAT2)     ; need to consider direction, so by defautl we use rat2, but flip via sign bit
 133++D6CA FD AC                                xor     iyh             ; get the sign back we saveded from DE in so de = nosev axis / 16 signed
 134++D6CC E6 80                                and     SignOnly8Bit
 135++D6CE B2                                   or      d
 136++D6CF 57                                   ld      d,a             ; de = nosev /16 signed and ready as if we were doing a + or - based on RAT2
 137++D6D0              ;;; ld      a,e
 138++D6D0              ;;;     or      iyh
 139++D6D0              ;;; ld      (varP),a        ; PA now equals nosev axis / 16 signed
 140++D6D0              ;-now AP = nosev /16  --------------------------------------------------------------------------------------------------------
 141++D6D0 E1                                   pop     hl              ; get back RS POP ID 1
 142++D6D1                  ;ex     de,hl           ; swapping around so hl = AP and de = SR , shoud not matter though as its an add
 143++D6D1              ;-now DE = (roofaxis/512) hl - abs(nosevaxis) --------------------------------------------------------------------------------
 144++D6D1 CD 56 00                             call    ADDHLDESignedV4 ; do add using hl and de
 145++D6D4 E5                                   push    hl              ; we use stack to represent var K here now varK = Nosev axis /16 + (1 - 1/512) * roofv axis PUSH ID 2
 146++D6D5              ;-push to stack nosev axis + roofvaxis /512  which is what roofv axis will be ------------------------------------------------
 147++D6D5              ;-- Set up SR = 1 - 1/512 * nosev-----------------------
 148++D6D5 2A 46 68                             ld      hl,(varAxis2)   ; work on nosev again to get nosev - novesv / 512
 149++D6D8 5E                                   ld      e,(hl)
 150++D6D9 23                                   inc     hl
 151++D6DA 56                                   ld      d,(hl)
 152++D6DB EB                                   ex      de,hl
 153++D6DC 7C                                   ld      a,h
 154++D6DD E6 80                                and     $80
 155++D6DF FD 67                                ld      iyh,a
 156++D6E1 7C                                   ld      a,h
 157++D6E2 E6 7F                                and     SignMask8Bit    ; a = roof hi axis  unsigned
 158++D6E4 CB 3F                                srl     a               ; now A = unsigned 15 bit nosev axis hi / 2 (or in effect nosev / 512
 159++D6E6 5F                                   ld      e,a
 160++D6E7 FD 7C                                ld      a,iyh
 161++D6E9 57                                   ld      d,a
 162++D6EA B7                                   or      a               ; clear carry
 163++D6EB CD 75 01                             call    subHLDES15
 164++D6EE              ;   sbc     hl,de           ; hl = nosev - novesv / 512
 165++D6EE E5                                   push    hl              ; save hl on stack  PUSH ID 3
 166++D6EF 7D                                   ld      a,l
 167++D6F0 32 5F 68                             ld      (varP),a        ; p = low of resuilt
 168++D6F3 7C                                   ld      a,h
 169++D6F4 E6 7F                                and     SignMask8Bit    ; a = roof hi axis  unsigned
 170++D6F6 32 7B 69                             ld      (varT),a        ; t = high of result
 171++D6F9              ;-- Set up TQ
 172++D6F9 2A 44 68                             ld      hl,(varAxis1)   ; now work on roofv axis / 16
 173++D6FC              ;   ld      hl,(varAxis2)   ; work on nosev again
 174++D6FC 5E                                   ld      e,(hl)
 175++D6FD 23                                   inc     hl
 176++D6FE 56                                   ld      d,(hl)
 177++D6FF 7A                                   ld      a,d
 178++D700 E6 80                                and     $80
 179++D702 FD 67                                ld      iyh,a           ; save sign
 180++D704 7A                                   ld      a,d
 181++D705 E6 7F                                and     SignMask8Bit    ; a = nosev hi axis  unsigned
 182++D707 57                                   ld      d,a             ; de = abs (nosev)
 183++D708                                      ShiftDERight1
 183++D708 CB 3A       >			   srl d
 183++D70A CB 1B       >			   rr  e
 184++D70C                                      ShiftDERight1
 184++D70C CB 3A       >			   srl d
 184++D70E CB 1B       >			   rr  e
 185++D710                                      ShiftDERight1
 185++D710 CB 3A       >			   srl d
 185++D712 CB 1B       >			   rr  e
 186++D714                                      ShiftDERight1           ; de = nosev /16 unsigned
 186++D714 CB 3A       >			   srl d
 186++D716 CB 1B       >			   rr  e
 187++D718 3A 4F C0                             ld      a,(univRAT2)
 188++D71B FD AC                                xor     iyh             ; get the sign back in so de = nosev axis / 16 signed
 189++D71D E6 80                                and     $80
 190++D71F B2                                   or      d
 191++D720 57                                   ld      d,a
 192++D721              ;;; ld      a,e
 193++D721              ;;;     or      iyh
 194++D721              ;;; ld      (varP),a        ; PA now equals nosev axis / 16 signed
 195++D721 E1                                   pop     hl              ; get back RS   POP ID 3
 196++D722              ;   ex      de,hl           ; swapping around so hl = AP and de = SR , shoud not matter though as its an add
 197++D722 CD 75 01                             call    subHLDES15 ; do add using hl and de
 198++D725              ;-- Update nosev ---------------------------------------
 199++D725 EB                                   ex      de,hl           ; save hl to de
 200++D726 2A 46 68                             ld      hl,(varAxis2)
 201++D729 73                                   ld      (hl),e
 202++D72A 23                                   inc     hl
 203++D72B 72                                   ld      (hl),d          ; copy result into nosev
 204++D72C              ;-- Update roofv ---------------------------------------
 205++D72C D1                                   pop     de              ; get calc saved on stack POP ID 2
 206++D72D 2A 44 68                             ld      hl,(varAxis1)
 207++D730 73                                   ld      (hl),e
 208++D731 23                                   inc     hl
 209++D732 72                                   ld      (hl),d          ; copy result into nosev
 210++D733 C9                                   ret
 211++D734
 212++D734
# file closed: ../../Tests/3DTest/../../Universe/Ships/ApplyShipRollAndPitch.asm
 849+ D734                          INCLUDE "../../Universe/Ships/ApplyShipSpeed.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/ApplyShipSpeed.asm
   1++D734
   2++D734
   3++D734              ;AddSpeedToVert:         MACRO   vertex
   4++D734              ;                        ld      hl,(vertex)
   5++D734              ;                        ld      a,(vertex+2)
   6++D734              ;                        ld      b,a
   7++D734              ;                        call    AHLEquBHLaddCDE
   8++D734              ;                        ld      (vertex),hl
   9++D734              ;                        ld      (vertex+2),a
  10++D734              ;                        ENDM
  11++D734
  12++D734
  13++D734              ; ---------------------------------------------------------------------------------------------------------------------------------
  14++D734 3A 46 C0     ApplyShipSpeed:         ld      a,(UBnKSpeed)                   ; get speed * 4
  15++D737 FE 00                                cp      0
  16++D739 C8                                   ret     z
  17++D73A CB 27                                sla     a
  18++D73C CB 27                                sla     a
  19++D73E FD 6F                                ld      iyl,a                           ; save pre calculated speed
  20++D740              .ApplyToX:              SpeedMulAxis    a, UBnkrotmatNosevX     ; e =  ABS (nosev x hi) c = sign
  20++D740 5F          >                        ld      e,a
  20++D741 2A 35 C0    >                        ld      hl,(UBnkrotmatNosevX)
  20++D744 7C          >                        ld      a,h
  20++D745             >                        ClearSignBitA
  20++D745 E6 7F       >                        and     SignMask8Bit
  20++D747 57          >                        ld      d,a
  20++D748 ED 30       >                        mul     de
  20++D74A 7C          >                        ld      a,h
  20++D74B             >                        SignBitOnlyA
  20++D74B E6 80       >                        and     SignOnly8Bit
  20++D74D 47          >                        ld      b,a;ld      c,a
  20++D74E 62          >                        ld      h,d;ld      e,d
  20++D74F 0E 00       >                        ld      c,0;ld      d,0
  21++D751              .AddSpeedToX:           AddSpeedToVert UBnKxlo
  21++D751 ED 5B 21 C0 >                        ld      de,(UBnKxlo+1)
  21++D755 3A 20 C0    >                        ld      a,(UBnKxlo)
  21++D758 6F          >                        ld      l,a
  21++D759 CD 14 01    >                        call    AddBCHtoDELsigned               ; DEL = DEL + BCH
  21++D75C 7D          >                        ld      a,l
  21++D75D 32 20 C0    >                        ld      (UBnKxlo),a
  21++D760 ED 53 21 C0 >                        ld      (UBnKxlo+1),de
  22++D764              .ApplyToY:              SpeedMulAxis    iyl, UBnkrotmatNosevY
  22++D764 FD 5D       >                        ld      e,iyl
  22++D766 2A 37 C0    >                        ld      hl,(UBnkrotmatNosevY)
  22++D769 7C          >                        ld      a,h
  22++D76A             >                        ClearSignBitA
  22++D76A E6 7F       >                        and     SignMask8Bit
  22++D76C 57          >                        ld      d,a
  22++D76D ED 30       >                        mul     de
  22++D76F 7C          >                        ld      a,h
  22++D770             >                        SignBitOnlyA
  22++D770 E6 80       >                        and     SignOnly8Bit
  22++D772 47          >                        ld      b,a;ld      c,a
  22++D773 62          >                        ld      h,d;ld      e,d
  22++D774 0E 00       >                        ld      c,0;ld      d,0
  23++D776              .AddSpeedToY:           AddSpeedToVert UBnKylo
  23++D776 ED 5B 24 C0 >                        ld      de,(UBnKylo+1)
  23++D77A 3A 23 C0    >                        ld      a,(UBnKylo)
  23++D77D 6F          >                        ld      l,a
  23++D77E CD 14 01    >                        call    AddBCHtoDELsigned               ; DEL = DEL + BCH
  23++D781 7D          >                        ld      a,l
  23++D782 32 23 C0    >                        ld      (UBnKylo),a
  23++D785 ED 53 24 C0 >                        ld      (UBnKylo+1),de
  24++D789              .ApplyToZ:              SpeedMulAxis    iyl, UBnkrotmatNosevZ
  24++D789 FD 5D       >                        ld      e,iyl
  24++D78B 2A 39 C0    >                        ld      hl,(UBnkrotmatNosevZ)
  24++D78E 7C          >                        ld      a,h
  24++D78F             >                        ClearSignBitA
  24++D78F E6 7F       >                        and     SignMask8Bit
  24++D791 57          >                        ld      d,a
  24++D792 ED 30       >                        mul     de
  24++D794 7C          >                        ld      a,h
  24++D795             >                        SignBitOnlyA
  24++D795 E6 80       >                        and     SignOnly8Bit
  24++D797 47          >                        ld      b,a;ld      c,a
  24++D798 62          >                        ld      h,d;ld      e,d
  24++D799 0E 00       >                        ld      c,0;ld      d,0
  25++D79B              .AddSpeedToZ:           AddSpeedToVert UBnKzlo
  25++D79B ED 5B 27 C0 >                        ld      de,(UBnKzlo+1)
  25++D79F 3A 26 C0    >                        ld      a,(UBnKzlo)
  25++D7A2 6F          >                        ld      l,a
  25++D7A3 CD 14 01    >                        call    AddBCHtoDELsigned               ; DEL = DEL + BCH
  25++D7A6 7D          >                        ld      a,l
  25++D7A7 32 26 C0    >                        ld      (UBnKzlo),a
  25++D7AA ED 53 27 C0 >                        ld      (UBnKzlo+1),de
  26++D7AE C9                                   ret
  27++D7AF
# file closed: ../../Tests/3DTest/../../Universe/Ships/ApplyShipSpeed.asm
 850+ D7AF                          INCLUDE "../../ModelRender/DrawLines.asm"
# file opened: ../../Tests/3DTest/../../ModelRender/DrawLines.asm
   1++D7AF
   2++D7AF
   3++D7AF              ; ---------------------------------------------------------------------------------------------------------------------------------
   4++D7AF 00           DrawLinesCounter		db	0
   5++D7B0              ; Initial tests look OK
   6++D7B0              LL155:;
   7++D7B0              ClearLine:                                  ; CLEAR LINEstr visited by EE31 when XX3 heap ready to draw/erase lines in XX19 heap.
   8++D7B0                    ;break                                                                             ; ObjectInFront:
   9++D7B0 3E 65        DrawLines:              ld	a,$65 ; DEBUG
  10++D7B2 FD 6F                                ld    iyl,a							; set ixl to colour (assuming we come in here with a = colour to draw)
  11++D7B4 3A EA C3                             ld	a,(UbnkLineArrayLen)			; get number of lines
  12++D7B7                                      ReturnIfAIsZero   						; No lines then bail out.
  12++D7B7 A7          >                        and     a
  12++D7B8 C8          >                        ret     z
  13++D7B9 FD 67                                ld	iyh,a			                ; number of lines still to draw
  14++D7BB 21 30 C2                             ld	hl,UbnkLineArray
  15++D7BE 4E           .DrawLinesLoop:         ld    c,(hl)                          ; (XX19),Y c = varX1
  16++D7BF 23                                   inc   hl
  17++D7C0 46                                   ld    b,(hl)                          ; bc = point1 Y,X
  18++D7C1 23                                   inc   hl
  19++D7C2 5E                                   ld    e,(hl)                          ; c = varX1
  20++D7C3 23                                   inc   hl
  21++D7C4 56                                   ld    d,(hl)                          ; de = point2 Y,X
  22++D7C5 23                                   inc   hl
  23++D7C6 E5 FD E5                             push  hl,,iy
  24++D7C9 60                                   ld    h,b
  25++D7CA 69                                   ld    l,c
  26++D7CB                ;  call    l2_draw_any_line                ; call version of LOIN that used BCDE
  27++D7CB FD 7D                                ld	a,iyl							; get colour back before calling line draw
  28++D7CD                                      MMUSelectLayer2
  28++D7CD ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
  29++D7D1 CD E6 FE                             call  LineHLtoDE
  30++D7D4 FD E1 E1                             pop   hl,,iy
  31++D7D7 FD 25                                dec   iyh
  32++D7D9 20 E3                                jr	nz, .DrawLinesLoop
  33++D7DB C9                                   ret                                     ; --- Wireframe end  \ LL118-1
  34++D7DC
  35++D7DC
  36++D7DC 3E 65        DrawLinesLateClipping:  ld	a,$65 ; DEBUG
  37++D7DE FD 6F                                ld    iyl,a					      ; set ixl to colour (assuming we come in here with a = colour to draw)
  38++D7E0 3A EA C3                             ld	a,(UbnkLineArrayLen)			; get number of lines
  39++D7E3                                      ReturnIfAIsZero   				; No lines then bail out.
  39++D7E3 A7          >                        and     a
  39++D7E4 C8          >                        ret     z
  40++D7E5 FD 67                                ld	iyh,a			                  ; number of lines still to draw
  41++D7E7 21 30 C2                             ld	hl,UbnkLineArray
  42++D7EA                                      MMUSelectLayer2
  42++D7EA ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
  43++D7EE 3E BF                                ld    a,$BF
  44++D7F0 32 8D E2                             ld    (line_gfx_colour),a
  45++D7F3 11 AC F5     LateDrawLinesLoop:      ld    de,x1
  46++D7F6                                      FourLDIInstrunctions
  46++D7F6 ED A0       >                        ldi
  46++D7F8 ED A0       >                        ldi
  46++D7FA ED A0       >                        ldi
  46++D7FC ED A0       >                        ldi
  47++D7FE                                      FourLDIInstrunctions
  47++D7FE ED A0       >                        ldi
  47++D800 ED A0       >                        ldi
  47++D802 ED A0       >                        ldi
  47++D804 ED A0       >                        ldi
  48++D806 E5 FD E5                             push  hl,,iy
  49++D809                                      //call  l2_draw_clipped_line
  50++D809                                      //call  l2_draw_elite_line
  51++D809 CD 3F FC                             call    l2_draw_6502_line
  52++D80C DA 48 D8                             jp      c,LateNoLineToDraw
  53++D80F
  54++D80F E5 C5 D5 FD  PreLate:                push    hl,,bc,,de,,iy
  54++D813 E5
  55++D814 3A AC F5                             ld      a,(x1)
  56++D817 4F                                   ld      c,a
  57++D818 3A AE F5                             ld      a,(y1)
  58++D81B 47                                   ld      b,a
  59++D81C 3A B0 F5                             ld      a,(x2)
  60++D81F 5F                                   ld      e,a
  61++D820 3A B2 F5                             ld      a,(y2)
  62++D823 57                                   ld      d,a
  63++D824                                      ; bc = y0,x0 de=y1,x1,a=color)
  64++D824 3E D5                                ld	    a, $D5 ; colour
  65++D826              ReadyToDraw:            MMUSelectLayer2
  65++D826 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
  66++D82A 78           CheckHorz:              ld      a,b
  67++D82B BA                                   cp      d
  68++D82C C2 35 D8                             jp      nz,.ItsNotHorizontal
  69++D82F CD 57 F5     .ItsHorizontal:         call    l2_drawHorzClip
  70++D832 C3 43 D8                             jp      DrawnLine
  71++D835 79           .ItsNotHorizontal:      ld      a,c
  72++D836 B3                                   or      e
  73++D837 C2 40 D8                             jp      nz,LateLine
  74++D83A CD 26 F5     .ItsVertical:           call    l2_drawVertClip
  75++D83D C3 43 D8                             jp      DrawnLine
  76++D840 CD 7F FC     LateLine:               call    l2_draw_elite_line; l2_draw_diagonal ** NOTE DOESNT DO HORZ OR VERT
  77++D843 FD E1 D1 C1  DrawnLine:              pop     hl,,bc,,de,,iy
  77++D847 E1
  78++D848 FD E1 E1     LateNoLineToDraw:       pop   hl,,iy
  79++D84B FD 25                                dec   iyh
  80++D84D 20 A4                                jr	nz, LateDrawLinesLoop
  81++D84F C9                                   ret                                     ; --- Wireframe end  \ LL118-1
# file closed: ../../Tests/3DTest/../../ModelRender/DrawLines.asm
 851+ D850              ; ---------------------------------------------------------------------------------------------------------------------------------
 852+ D850
 853+ D850              ; DIot seem to lawyas have Y = 0???
 854+ D850              ProcessDot:            ; break
 855+ D850 CD 36 CA                             call    CopyRotmatToTransMat             ;#01; Load to Rotation Matrix to XX16, 16th bit is sign bit
 856+ D853 CD EE 64                             call    ScaleXX16Matrix197               ;#02; Normalise XX16
 857+ D856 CD EE CC                             call    LoadCraftToCamera                ;#04; Load Ship Coords to XX18
 858+ D859 CD BB CB                             call    InverseXX16                      ;#11; Invert rotation matrix
 859+ D85C 21 00 00                             ld      hl,0
 860+ D85F 22 A6 C0                             ld      (UBnkXScaled),hl
 861+ D862 22 A8 C0                             ld      (UBnkYScaled),hl
 862+ D865 22 AA C0                             ld      (UBnkZScaled),hl
 863+ D868 AF                                   xor     a
 864+ D869 CD 50 64                             call    XX12EquNodeDotOrientation
 865+ D86C CD 5F CA                             call    TransposeXX12ByShipToXX15
 866+ D86F CD DC CA                             call    ScaleNodeTo8Bit                     ; scale to 8 bit values, why don't we hold the magnitude here?x
 867+ D872 FD 21 F0 C0                          ld      iy,UBnkNodeArray
 868+ D876 CD E4 D2                             call    ProjectNodeToEye
 869+ D879 C9                                   ret
 870+ D87A
 871+ D87A              ; .....................................................
 872+ D87A              ; Plot Node points as part of debugging
 873+ D87A 3A FF C3     PlotAllNodes:           ld      a,(VertexCtX6Addr)               ; get Hull byte#9 = number of vertices *6                                   ;;;
 874+ D87D 4F           .GetActualVertexCount:  ld      c,a                              ; XX20 also c = number of vertices * 6 (or XX20)
 875+ D87E 4F                                   ld      c,a                              ; XX20 also c = number of vertices * 6 (or XX20)
 876+ D87F 16 06                                ld      d,6
 877+ D881 CD 20 73                             call    asm_div8                         ; asm_div8 C_Div_D - C is the numerator, D is the denominator, A is the remainder, B is 0, C is the result of C/D,D,E,H,L are not changed"
 878+ D884 41                                   ld      b,c                              ; c = number of vertices
 879+ D885 FD 21 F0 C0                          ld      iy,UBnkNodeArray
 880+ D889 FD 5E 00     .PlotLoop:              ld      e,(iy)
 881+ D88C FD 56 01                             ld      d,(iy+1)
 882+ D88F FD 6E 02                             ld      l,(iy+2)
 883+ D892 FD 66 03                             ld      h,(iy+3)
 884+ D895 C5 FD E5                             push    bc,,iy
 885+ D898 CD A9 D8                             call    PlotAtDEHL
 886+ D89B FD E1 C1                             pop     bc,,iy
 887+ D89E FD 23                                inc     iy
 888+ D8A0 FD 23                                inc     iy
 889+ D8A2 FD 23                                inc     iy
 890+ D8A4 FD 23                                inc     iy
 891+ D8A6 10 E1                                djnz    .PlotLoop
 892+ D8A8 C9                                   ret
 893+ D8A9
 894+ D8A9 7A           PlotAtDEHL:             ld      a,d
 895+ D8AA A7                                   and     a
 896+ D8AB C0                                   ret     nz
 897+ D8AC 7C                                   ld      a,h
 898+ D8AD A7                                   and     a
 899+ D8AE C0                                   ret     nz
 900+ D8AF 7D                                   ld      a,l
 901+ D8B0 E6 80                                and     $80
 902+ D8B2 C0                                   ret     nz
 903+ D8B3                                      MMUSelectLayer2
 903+ D8B3 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 904+ D8B7 45                                   ld      b,l
 905+ D8B8 4B                                   ld      c,e
 906+ D8B9 3E 88                                ld      a,$88
 907+ D8BB CD 8E E2                             call    l2_plot_pixel
 908+ D8BE C9                                   ret
 909+ D8BF
 910+ D8BF
 911+ D8BF              ; .....................................................
 912+ D8BF              ; Process Nodes does the following:
 913+ D8BF              ; for each node:
 914+ D8BF              ;     see if node >
 915+ D8BF 00           PNXX20DIV6          DB      0
 916+ D8C0 00 00        PNVERTEXPTR         DW      0   ; DEBUG WILL USE LATER
 917+ D8C2 00 00        PNNODEPRT           DW      0   ; DEBUG WILL USE LATER
 918+ D8C4 00           PNLASTNORM          DB      0
 919+ D8C5              ProcessNodes:           ZeroA
 919+ D8C5 AF          >                        xor a
 920+ D8C6 32 EA C3                             ld      (UbnkLineArrayLen),a
 921+ D8C9 CD 36 CA                             call    CopyRotmatToTransMat ; CopyRotToTransMacro                      ;#01; Load to Rotation Matrix to XX16, 16th bit is sign bit
 922+ D8CC CD EE 64                             call    ScaleXX16Matrix197               ;#02; Normalise XX16
 923+ D8CF CD EE CC                             call    LoadCraftToCamera                ;#04; Load Ship Coords to XX18
 924+ D8D2 CD BB CB                             call    InverseXX16                      ;#11; Invert rotation matrix
 925+ D8D5 21 11 C4                             ld      hl,UBnkHullVerticies
 926+ D8D8 3A FF C3                             ld      a,(VertexCtX6Addr)               ; get Hull byte#9 = number of vertices *6                                   ;;;
 927+ D8DB 4F           GetActualVertexCount:   ld      c,a                              ; XX20 also c = number of vertices * 6 (or XX20)
 928+ D8DC 4F                                   ld      c,a                              ; XX20 also c = number of vertices * 6 (or XX20)
 929+ D8DD 16 06                                ld      d,6
 930+ D8DF CD 20 73                             call    asm_div8                         ; asm_div8 C_Div_D - C is the numerator, D is the denominator, A is the remainder, B is 0, C is the result of C/D,D,E,H,L are not changed"
 931+ D8E2 41                                   ld      b,c                              ; c = number of vertices
 932+ D8E3 FD 21 F0 C0                          ld      iy,UBnkNodeArray
 933+ D8E7              LL48:
 934+ D8E7 C5           PointLoop:              push    bc                                  ; save counters
 935+ D8E8 E5                                   push    hl                                  ; save verticies list pointer
 936+ D8E9 FD E5                                push    iy                                  ; save Screen plot array pointer
 937+ D8EB 78                                   ld      a,b
 938+ D8EC                                      ;break
 939+ D8EC CD 65 D2                             call    CopyNodeToXX15                      ; copy verices at hl to xx15
 940+ D8EF 3A A7 C0                             ld      a,(UBnkXScaledSign)
 941+ D8F2 CD 50 64                             call    XX12EquNodeDotOrientation
 942+ D8F5 CD 5F CA                             call    TransposeXX12ByShipToXX15
 943+ D8F8 CD DC CA                             call    ScaleNodeTo8Bit                     ; scale to 8 bit values, why don't we hold the magnitude here?x
 944+ D8FB FD E1                                pop     iy                                  ; get back screen plot array pointer
 945+ D8FD CD E4 D2                             call    ProjectNodeToEye                     ; set up screen plot list entry
 946+ D900                 ; ld      hl,UbnkLineArrayLen
 947+ D900                ;  inc     (hl)                                ; another node done
 948+ D900 FD E5        ReadyForNextPoint:      push    iy                                  ; copy screen plot pointer to hl
 949+ D902 E1                                   pop     hl
 950+ D903 3E 04                                ld      a,4
 951+ D905 ED 31                                add     hl,a
 952+ D907 E5                                   push    hl                                  ; write it back at iy + 4
 953+ D908 FD E1                                pop     iy                                  ; and put it in iy again
 954+ D90A E1                                   pop     hl                                  ; get hl back as vertex list
 955+ D90B 3E 06                                ld      a,6
 956+ D90D ED 31                                add     hl,a                                ; and move to next vertex
 957+ D90F C1                                   pop     bc                                  ; get counter back
 958+ D910 10 D5                                djnz    PointLoop
 959+ D912              ; ......................................................
 960+ D912                                      ClearCarryFlag
 960+ D912 B7          >                        or a
 961+ D913 C9                                   ret
 962+ D914              ; ...........................................................
 963+ D914 CD E9 CE     ProcessShip:            call    CheckVisible                ; checks for z -ve and outside view frustrum, sets up flags for next bit
 964+ D917              ;............................................................
 965+ D917              .DetermineDrawType:     ReturnOnBitClear    a, ShipIsVisibleBitNbr          ; if its not visible exit early
 965+ D917 CB 77       >                        bit 	ShipIsVisibleBitNbr,a
 965+ D919 C8          >                        ret		z
 966+ D91A              ;............................................................
 967+ D91A CD C5 D8     .CarryOnWithDraw:       call    ProcessNodes                ; process notes is the poor performer or check distnace is not culling
 968+ D91D                                     ; break
 969+ D91D 3E E3                                ld      a,$E3
 970+ D91F 32 8D E2                             ld      (line_gfx_colour),a
 971+ D922 CD 30 CF                             call    CullV2
 972+ D925 CD 3C D9                             call    PrepLines                       ; With late clipping this just moves the data to the line array which is now x2 size
 973+ D928 CD DC D7                             call    DrawLinesLateClipping
 974+ D92B C9                                   ret
 975+ D92C
 976+ D92C                  ;INCLUDE "../../Universe/Ships/PrepLines.asm"
 977+ D92C              ;--------------------------------------------------------------------------------------------------------
 978+ D92C                      DISPLAY "Tracing 8", $
 979+ D92C
 980+ D92C                  INCLUDE "../../ModelRender/getVertexNodeAtAToX1Y1.asm"
# file opened: ../../Tests/3DTest/../../ModelRender/getVertexNodeAtAToX1Y1.asm
   1++D92C              ;--------------------------------------------------------------------------------------------------------
   2++D92C              ; a = byteoffset to node array as its pre computed to x4 bytes
   3++D92C 21 F0 C0     getVertexNodeAtAToDE:   ld          hl,UBnkNodeArray                    ; hl = edgelist  current pointer
   4++D92F ED 31                                add         hl,a                                ; hl = address of Node
   5++D931 7E                                   ld          a,(hl)                              ; get edge list nbr 1 edge
   6++D932 ED A0                                ldi                                             ; x1 lo
   7++D934 ED A0                                ldi                                             ; x1 hi
   8++D936 ED A0                                ldi                                             ; y1 lo
   9++D938 ED A0                                ldi                                             ; y1 hi
  10++D93A C9                                   ret
  11++D93B
  12++D93B              ;getVertexNodeAtAToX1Y1: ld          hl,UBnkNodeArray                    ; hl = edgelist  current pointer
  13++D93B              ;                        add         hl,a                                ; hl = address of Node
  14++D93B              ;                        ld          a,(hl)                              ; get edge list nbr 1 edge
  15++D93B              ;                        ld          de,UBnkX1
  16++D93B              ;                        ldi                                             ; x1 lo
  17++D93B              ;                        ldi                                             ; x1 hi
  18++D93B              ;                        ldi                                             ; y1 lo
  19++D93B              ;                        ldi                                             ; y1 hi
  20++D93B              ;                        ret
  21++D93B
# file closed: ../../Tests/3DTest/../../ModelRender/getVertexNodeAtAToX1Y1.asm
 981+ D93B
 982+ D93B                      DISPLAY "Tracing 9", $
 983+ D93B
 984+ D93B                  INCLUDE "../../ModelRender/getVertexNodeAtAToX2Y2.asm"
# file opened: ../../Tests/3DTest/../../ModelRender/getVertexNodeAtAToX2Y2.asm
   1++D93B              ;--------------------------------------------------------------------------------------------------------
   2++D93B              ; a = byteoffset to node array as its pre computed to x4 bytes
   3++D93B              ;getVertexNodeAtAToX2Y2: ld          hl,UBnkNodeArray                    ; hl = edgelist  current pointer
   4++D93B              ;                        add         hl,a                                ; hl = address of Node
   5++D93B              ;                        ld          a,(hl)                              ; get edge list nbr 1 edge
   6++D93B              ;                        ld          de,UBnkX2
   7++D93B              ;                        ldi                                             ; x1 lo
   8++D93B              ;                        ldi                                             ; x1 hi
   9++D93B              ;                        ldi                                             ; y1 lo
  10++D93B              ;                        ldi                                             ; y1 hi
  11++D93B              ;                        ret
# file closed: ../../Tests/3DTest/../../ModelRender/getVertexNodeAtAToX2Y2.asm
 985+ D93B                      DISPLAY "Tracing 10", $
 986+ D93B
 987+ D93B                  INCLUDE "../../ModelRender/GetFaceAtA.asm"
# file opened: ../../Tests/3DTest/../../ModelRender/GetFaceAtA.asm
   1++D93B              ;--------------------------------------------------------------------------------------------------------
   2++D93B              GetFaceAtA:         MACRO
   3++D93B ~                                ld          hl,UbnkFaceVisArray
   4++D93B ~                                add         hl,a
   5++D93B ~                                ld          a,(hl)                              ; get face visibility
   6++D93B                                  ENDM
   7++D93B
# file closed: ../../Tests/3DTest/../../ModelRender/GetFaceAtA.asm
 988+ D93B                      DISPLAY "Tracing 11", $
 989+ D93B
 990+ D93B              ;--------------------------------------------------------------------------------------------------------
 991+ D93B              ; LL72 Goes through each edge in to determine if they are on a visible face, if so load start and end to line array as clipped lines
 992+ D93B               ;   DEFINE NOBACKFACECULL 1
 993+ D93B 00           PLEDGECTR           DB          0
 994+ D93C
 995+ D93C              PrepLines:
 996+ D93C              InitialiseLineRead:
 997+ D93C                      ;break
 998+ D93C                      ldWriteZero UbnkLineArrayLen                    ; current line array index = 0
 998+ D93C AF          >                        xor      a
 998+ D93D 32 EA C3    >                        ld       (UbnkLineArrayLen),a
 999+ D940 32 EB C3             ld          (UbnkLineArrayBytes),a              ; UbnkLineArrayBytes= nbr of bytes of lines laoded = array len * 4
1000+ D943 32 3B D9             ld          (PLEDGECTR),a
1001+ D946 3A 00 C4             ld          a,(EdgeCountAddr)
1002+ D949 DD 67                ld          ixh,a                               ; ixh = XX17 = Total number of edges to traverse
1003+ D94B FD 2E 00             ld          iyl,0                               ; ixl = current edge index
1004+ D94E 21 30 C2             ld          hl,UbnkLineArray                    ; head of array
1005+ D951 22 62 69             ld          (varU16),hl                         ; store current line array pointer un varU16
1006+ D954                      ldCopyByte  EdgeCountAddr, XX17                 ; XX17  = total number of edges to traverse edge counter
1006+ D954 3A 00 C4    >                        ld       a,(EdgeCountAddr)
1006+ D957 32 66 69    >                        ld       (XX17),a
1007+ D95A 3A 51 C0             ld          a,(UBnKexplDsp)                     ; get explosion status
1008+ D95D                      JumpOnBitClear a,6,CalculateNewLines            ; LL170 bit6 of display state clear (laser not firing) \ Calculate new lines
1008+ D95D CB 77       >                        bit 	6,a
1008+ D95F CA 67 D9    >                        jp      z,CalculateNewLines
1009+ D962 E6 BF                and         $BF                                 ; else laser is firing, clear bit6.
1010+ D964 32 51 C0             ld          (UBnKexplDsp),a                     ; INWK+31
1011+ D967              ;   TODO commentedout as teh subroutine is a mess   call        AddLaserBeamLine                    ; add laser beam line to draw list
1012+ D967              ; NOw we can calculate hull after including laser line
1013+ D967              CalculateNewLines:
1014+ D967              LL170:                                                  ;(laser not firing) \ Calculate new lines   \ their comment
1015+ D967              CheckEdgesForVisibility:
1016+ D967 21 01 C5             ld          hl,UBnkHullEdges
1017+ D96A                      ; TODO change heap to 3 separate arrays and break them down during copy of ship hull data
1018+ D96A 22 65 68             ld          (varV),hl                           ; V \ is pointer to where edges data start
1019+ D96D 3A FB C3             ld          a,(LineX4Addr)
1020+ D970 47                   ld          b,a                                 ; nbr of bytes of edge data
1021+ D971              LL75Loop:                                               ; count Visible edges
1022+ D971              IsEdgeInVisibilityRange:
1023+ D971 2A 65 68             ld          hl,(varV)
1024+ D974 E5                   push        hl
1025+ D975 FD E1                pop         iy
1026+ D977 3A 50 68             ld          a,(LastNormalVisible)               ; XX4 is visibility range
1027+ D97A 57                   ld          d,a                                 ; d holds copy of XX4
1028+ D97B              ; Get Edge Byte 0
1029+ D97B FD 7E 00             ld          a,(IY+0)                            ; edge data byte#0 is visibility distance
1030+ D97E                      JumpIfALTNusng d,LL78EdgeNotVisible             ; XX4   \ visibility LLx78 edge not visible
1030+ D97E BA          >                        cp      d
1030+ D97F DA DA D9    >                        jp		c, LL78EdgeNotVisible
1031+ D982              EdgeMayBeVisibile:
1032+ D982              ; Get Edge Byte 1
1033+ D982              IsFace1Visibile:                                        ; edges have 2 faces to test
1034+ D982 FD 7E 01             ld          a,(IY+1)                            ; (V),Y \ edge data byte#1 bits 0 to 3 face 1 4 to 7 face 2
1035+ D985 4F                   ld          c,a                                 ;  c = a copy of byte 1
1036+ D986 E6 0F                and         $0F                                 ;
1037+ D988                      GetFaceAtA
1037+ D988 21 D2 C0    >                    ld          hl,UbnkFaceVisArray
1037+ D98B ED 31       >                    add         hl,a
1037+ D98D 7E          >                    ld          a,(hl)                              ; get face visibility
1038+ D98E              ;       jp  VisibileEdge; DEBUG BODGE TEST TODO
1039+ D98E                      JumpIfAIsNotZero VisibileEdge                     ; LL70 visible edge
1039+ D98E A7          >                        and     a
1039+ D98F C2 A3 D9    >                        jp	    nz,VisibileEdge
1040+ D992              IsFace2Visibile:
1041+ D992 79                   ld          a,c                                 ; restore byte 1 from c register
1042+ D993 ED 23                swapnib                                         ;
1043+ D995 E6 0F                and         $0F                                 ; swap high byte into low byte
1044+ D997 E5                   push        hl
1045+ D998                      GetFaceAtA
1045+ D998 21 D2 C0    >                    ld          hl,UbnkFaceVisArray
1045+ D99B ED 31       >                    add         hl,a
1045+ D99D 7E          >                    ld          a,(hl)                              ; get face visibility
1046+ D99E E1                   pop         hl
1047+ D99F                      JumpIfAIsZero LL78EdgeNotVisible                ; edge not visible
1047+ D99F A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
1047+ D9A0 CA DA D9    >                        jp	    z, LL78EdgeNotVisible
1048+ D9A3              VisibileEdge:                                           ; Now we need to node id from bytes 2 - start and 3 - end
1049+ D9A3              ;LL79--Visible edge--------------------------------------
1050+ D9A3              ; Get Edge Byte 2
1051+ D9A3 FD 7E 02             ld          a,(IY+2)                            ; get Node id
1052+ D9A6 11 A6 C0             ld          de,UBnkX1
1053+ D9A9 CD 2C D9             call        getVertexNodeAtAToDE; getVertexNodeAtAToX1Y1              ; get the points X1Y1 from node
1054+ D9AC FD 7E 03             ld          a,(IY+3)
1055+ D9AF 11 AA C0             ld          de,UBnkX2
1056+ D9B2 CD 2C D9             call        getVertexNodeAtAToDE; getVertexNodeAtAToX2Y2              ; get the points X2Y2 from node
1057+ D9B5              LL80:                                                   ; ll80 \ Shove visible edge onto XX19 ship lines heap counter U
1058+ D9B5 ED 5B 62 69          ld          de,(varU16)                         ; clipped edges heap address
1059+ D9B9 21 A6 C0             ld          hl,UbnkPreClipX1
1060+ D9BC                      FourLDIInstrunctions
1060+ D9BC ED A0       >                        ldi
1060+ D9BE ED A0       >                        ldi
1060+ D9C0 ED A0       >                        ldi
1060+ D9C2 ED A0       >                        ldi
1061+ D9C4                      FourLDIInstrunctions
1061+ D9C4 ED A0       >                        ldi
1061+ D9C6 ED A0       >                        ldi
1061+ D9C8 ED A0       >                        ldi
1061+ D9CA ED A0       >                        ldi
1062+ D9CC ED 53 62 69          ld          (varU16),de                         ; update U16 with current address
1063+ D9D0 21 EA C3             ld          hl,UbnkLineArrayLen                 ; we have loaded one line
1064+ D9D3 34                   inc         (hl)
1065+ D9D4 7E                   ld          a,(hl)
1066+ D9D5                      JumpIfAGTENusng LineArraySize,CompletedLineGeneration   ; have we hit max lines for a model hop over jmp to Exit edge data loop
1066+ D9D5 FE 32       >                        cp     LineArraySize
1066+ D9D7 D2 F0 D9    >                        jp		nc,CompletedLineGeneration
1067+ D9DA              ; If we hit here we skip the write of line arryay u16
1068+ D9DA              LL78EdgeNotVisible:                                     ; also arrive here if Edge not visible, loop next data edge.
1069+ D9DA              LL78:
1070+ D9DA 2A 65 68             ld          hl,(varV)                           ; varV is current edge address
1071+ D9DD 3E 04                ld          a,4
1072+ D9DF ED 31                add         hl,a
1073+ D9E1 22 65 68             ld          (varV),hl
1074+ D9E4 21 3B D9             ld          hl,PLEDGECTR                        ;
1075+ D9E7 34                   inc         (hl)                                ;
1076+ D9E8 7E                   ld          a,(hl)                              ; current edge index ++
1077+ D9E9                      JumpIfANEMemusng XX17,LL75Loop                  ; compare with total number of edges
1077+ D9E9 21 66 69    >                        ld    hl,XX17
1077+ D9EC BE          >                        cp    (hl)
1077+ D9ED C2 71 D9    >                        jp      nz,LL75Loop
1078+ D9F0              CompletedLineGeneration:
1079+ D9F0              LL81:
1080+ D9F0              LL81SHPPT:                                              ; SHPPT ship is a point arrives here with Acc=2, bottom entry in heap
1081+ D9F0 3A EA C3             ld          a,(UbnkLineArrayLen)                ; UbnkLineArrayLen = nbr of lines loaded
1082+ D9F3 CB 27                sla         a
1083+ D9F5 CB 27                sla         a                                   ; multiple by 4 to equal number of bytes
1084+ D9F7 CB 27                sla         a                           ; multiple by 8 to equal number of bytes
1085+ D9F9 32 EB C3             ld          (UbnkLineArrayBytes),a              ; UbnkLineArrayBytes= nbr of bytes of lines laoded = array len * 4
1086+ D9FC              ExitEdgeDataLoop:
1087+ D9FC C9                   ret
1088+ D9FD
1089+ D9FD
1090+ D9FD                  DISPLAY "Tracing XX", $
1091+ D9FD
1092+ D9FD              UnivBankSize  EQU $ - StartOfUniv
1093+ D9FD
# file closed: ../../Tests/3DTest/univ_ship_data.asm
 938  D9FD                                  DISPLAY "Sizing Bank ",BankUNIVDATA0," - Start ",UniverseBankAddr," End - ",$, "- Universe Data A"
 939  D9FD                                  DISPLAY "Bank ",BankUNIVDATA0," - Bytes free ",/D, $2000 - ($-UniverseBankAddr), "- Universe Data A"
 940  D9FD                                  ASSERT $-UniverseBankAddr <8912, Bank code leaks over 8K boundary
 941  D9FD              ; Bank 99  ------------------------------------------------------------------------------------------------------------------------
 942  D9FD                                  SLOT    MathsTablesAddr
 943  D9FD                                  PAGE    BankMathsTables
 944  D9FD                                  ORG     MathsTablesAddr,BankMathsTables
 945  0000                                  INCLUDE "../../Maths/logmaths.asm"
# file opened: ../../Maths/logmaths.asm
   1+ 0000 4C 6F 67 4D  logmaths_page_marker    DB "LogMaths   PG99"
   1+ 0004 61 74 68 73
   1+ 0008 20 20 20 50
   1+ 000C 47 39 39
   2+ 000F
   3+ 000F EB           AntiLogHL:              ex      de,hl
   4+ 0010 21 83 05                             ld      hl,LogReverseHighByte
   5+ 0013 01 14 02                             ld      bc,LogReverseTableLen
   6+ 0016 7A                                   ld      a,d
   7+ 0017 ED A1        .SearchLoop:            cpi                                     ; first pass index into high byte
   8+ 0019 28 03                                jr      z,.FoundHighByte
   9+ 001B 23                                   inc     hl
  10+ 001C 18 F9                                jr      .SearchLoop
  11+ 001E 23           .FoundHighByte:         inc     hl                              ; now we have high double it for table of words
  12+ 001F 7E                                   ld      a,(hl)                          ; .
  13+ 0020 21 83 03                             ld      hl,LogTable                     ; .
  14+ 0023 ED 31                                add     hl,a                            ; .
  15+ 0025 ED 31                                add     hl,a                            ; .
  16+ 0027 7A           .LookForLowByteLoop:    ld      a,d                             ; search for low byte or change in high byte
  17+ 0028 BE                                   cp      (hl)
  18+ 0029 20 09                                jr      nz,.SkippedPastHigh
  19+ 002B 23                                   inc     hl
  20+ 002C 7B                                   ld      a,e
  21+ 002D                                      JumpIfAGTENusng (hl), .SkippedPastLow
  21+ 002D BE          >                        cp     (hl)
  21+ 002E D2 35 00    >                        jp		nc,.SkippedPastLow
  22+ 0031 C3 27 00                             jp      .LookForLowByteLoop
  23+ 0034
  24+ 0034 2B           .SkippedPastHigh:       dec     hl                              ; for high we are on next word
  25+ 0035 2B           .SkippedPastLow:        dec     hl                              ; for low we are no next byte
  26+ 0036 EB                                   ex      de,hl                           ; move address to de for subtract
  27+ 0037 21 83 03                             ld      hl,LogTable                     ; subtract from log table address
  28+ 003A                                      ClearCarryFlag
  28+ 003A B7          >                        or a
  29+ 003B ED 52                                sbc     hl,de                           ; so nwo we have nbr of words, i.e anito log * 2
  30+ 003D                                      ShiftHLRight1                           ; now must be >= 255
  30+ 003D CB 3C       >			   srl h
  30+ 003F CB 1D       >			   rr  l
  31+ 0041 7D                                   ld      a,l
  32+ 0042 C9                                   ret
  33+ 0043
  34+ 0043              ; calculates R = 256 * A / Q
  35+ 0043              Requ256mulAdivQ_Log:    JumpIfAGTEMemusng varQ, LL2             ; If A >= Q, then the answer will not fit in one byte, return 255
  35+ 0043 21 5F 69    >                        ld      hl,varQ
  35+ 0046 BE          >                        cp      (hl)
  35+ 0047 D2 BB 00    >                        jp		nc,LL2
  36+ 004A FD 6F                                ld      iyl,a                           ; STA widget             \ Store A in widget, so now widget = argument A
  37+ 004C DD 67                                ld      ixh,a                           ; TAX                    \ Transfer A into X, so now X = argument A
  38+ 004E                                      JumpIfAIsZero LLfix                     ; If A = 0, jump to LLfix to return a result of 0
  38+ 004E A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  38+ 004F CA B7 00    >                        jp	    z, LLfix
  39+ 0052              ; calculate log(A) - log(Q), first adding the low bytes (from the logL table), and then the high bytes (from the log table)
  40+ 0052              ; this determins if we branch to antilog or antilogodd for negative value
  41+ 0052 21 83 03     .GetLogA:               ld      hl,LogTable                     ; LDA logL,X             \ e = low byte of log(X)
  42+ 0055 ED 31                                add     hl,a                            ; have to add twice as ist 8 bit so cant shift
  43+ 0057 ED 31                                add     hl,a                            ;
  44+ 0059 5E                                   ld      e,(hl)                          ;
  45+ 005A 23                                   inc     hl                              ;
  46+ 005B 56                                   ld      d,(hl)                          ; de = logH[X] logL[X]
  47+ 005C 21 83 03                             ld      hl,LogTable                     ;
  48+ 005F 3A 5F 69                             ld      a,(varQ)                        ;
  49+ 0062 ED 31                                add     hl,a                            ;
  50+ 0064 ED 31                                add     hl,a                            ;
  51+ 0066 4E                                   ld      c,(hl)                          ;
  52+ 0067 23                                   inc     hl                              ;
  53+ 0068 46                                   ld      b,(hl)                          ; bc = logH[X] logL[X]
  54+ 0069 7B                                   ld      a,e                             ; SBC logL,X             \       = low byte of log(A) - low byte of log(Q)
  55+ 006A                                      ClearCarryFlag                          ; .
  55+ 006A B7          >                        or a
  56+ 006B 99                                   sbc     a,c                             ; .
  57+ 006C D2 93 00                             jp      nc,NoCarryBranch
  58+ 006F FA 83 00     CarryBranch:            jp      m,.noddlog                     ; BMI noddlog            \ If the subtraction is negative, jump to noddlog
  59+ 0072 5F                                   ld      e,a                             ; save logL[A] - logL[Q] in e, probabyl dont need this
  60+ 0073 7A                                   ld      a,d                             ; a = logH(a)
  61+ 0074              .CarryFlagPoint1:       SetCarryFlag
  61+ 0074 37          >                        scf
  62+ 0075 98                                   sbc     a,b                             ; a = high byte of logH[A] - logH[Q] note carry is not affected from prev sbc
  63+ 0076 D2 BB 00                             jp      nc,LL2                          ; If the subtraction fitted into one byte and didn't underflow, then log(A) - log(Q) < 256, so we jump to LL2 return a result of 255
  64+ 0079 21 83 01                             ld      hl,AntiLogTable                 ; TAX                    \ Otherwise we return the A-th entry from the antilog
  65+ 007C ED 31                                add     hl,a                            ; LDA antilog,X          \ table
  66+ 007E 7E                                   ld      a,(hl)
  67+ 007F 32 60 69                             ld      (varR),a                        ; STA R                  \ Set the result in R to the value of A
  68+ 0082 C9                                   ret                                     ; RTS                    \ Return from the subroutine
  69+ 0083 7A           .noddlog:               ld      a,d                             ; LDX widget             \ Set d = high byte of log(A) - high byte of log(Q)
  70+ 0084              .CarryFlagPoint2:       SetCarryFlag
  70+ 0084 37          >                        scf
  71+ 0085 98                                   sbc     a,b
  72+ 0086 D2 BB 00                             jp      nc,LL2                          ; BCS LL2                \ If the subtraction fitted into one byte and didn't underflow, then log(A) - log(Q) < 256, so we jump to LL2 to return a result of 255
  73+ 0089 21 83 02                             ld      hl, AnitLogODDTable             ; TAX                    \ Otherwise we return the A-th entry from the antilogODD
  74+ 008C ED 31                                add     hl,a                            ; LDA antilogODD,X       \ table
  75+ 008E 7E                                   ld      a,(hl)
  76+ 008F 32 60 69                             ld      (varR),a                        ; STA R                  \ Set the result in R to the value of A
  77+ 0092 C9                                   ret                                     ; RTS                    \ Return from the subroutine
  78+ 0093 FA A7 00     NoCarryBranch:          jp      m,.noddlog                     ; BMI noddlog            \ If the subtraction is negative, jump to noddlog
  79+ 0096 5F                                   ld      e,a                             ; save logL[A] - logL[Q] in e, probabyl dont need this
  80+ 0097 7A                                   ld      a,d                             ; a = logH(a)
  81+ 0098              .CarryFlagPoint1:       ClearCarryFlag
  81+ 0098 B7          >                        or a
  82+ 0099 98                                   sbc     a,b                             ; a = high byte of logH[A] - logH[Q] note carry is not affected from prev sbc
  83+ 009A D2 BB 00                             jp      nc,LL2                          ; If the subtraction fitted into one byte and didn't underflow, then log(A) - log(Q) < 256, so we jump to LL2 return a result of 255
  84+ 009D 21 83 01                             ld      hl,AntiLogTable                 ; TAX                    \ Otherwise we return the A-th entry from the antilog
  85+ 00A0 ED 31                                add     hl,a                            ; LDA antilog,X          \ table
  86+ 00A2 7E                                   ld      a,(hl)
  87+ 00A3 32 60 69                             ld      (varR),a                        ; STA R                  \ Set the result in R to the value of A
  88+ 00A6 C9                                   ret                                     ; RTS                    \ Return from the subroutine
  89+ 00A7 7A           .noddlog:               ld      a,d                             ; LDX widget             \ Set d = high byte of log(A) - high byte of log(Q)
  90+ 00A8              .CarryFlagPoint2:       ClearCarryFlag
  90+ 00A8 B7          >                        or a
  91+ 00A9 98                                   sbc     a,b
  92+ 00AA D2 BB 00                             jp      nc,LL2                          ; BCS LL2                \ If the subtraction fitted into one byte and didn't underflow, then log(A) - log(Q) < 256, so we jump to LL2 to return a result of 255
  93+ 00AD 21 83 02                             ld      hl, AnitLogODDTable             ; TAX                    \ Otherwise we return the A-th entry from the antilogODD
  94+ 00B0 ED 31                                add     hl,a                            ; LDA antilogODD,X       \ table
  95+ 00B2 7E                                   ld      a,(hl)
  96+ 00B3 32 60 69                             ld      (varR),a                        ; STA R                  \ Set the result in R to the value of A
  97+ 00B6 C9                                   ret                                     ; RTS                    \ Return from the subroutine
  98+ 00B7 32 60 69     LLfix:                  ld      (varR),a                        ; Set the result in R to the value of A
  99+ 00BA C9                                   ret                                     ; RTS                    \ Return from the subroutine
 100+ 00BB 3E FF        LL2:                    ld      a,$FF
 101+ 00BD 32 60 69                             ld      (varR),a
 102+ 00C0 C9                                   ret
 103+ 00C1
 104+ 00C1
 105+ 00C1              AEquAmul256DivBLogLT:   JumpIfAIsZero   .ResultIsZero
 105+ 00C1 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 105+ 00C2 CA EA 00    >                        jp	    z, .ResultIsZero
 106+ 00C5 21 83 03                             ld      hl,LogTable                     ; de = log a
 107+ 00C8 ED 31                                add     hl,a                            ; .
 108+ 00CA ED 31                                add     hl,a                            ; .
 109+ 00CC 5E                                   ld      e,(hl)                          ; .
 110+ 00CD 23                                   inc     hl                              ; .
 111+ 00CE 56                                   ld      d,(hl)                          ; .
 112+ 00CF 21 83 03                             ld      hl,LogTable                     ; hl = log b
 113+ 00D2 78                                   ld      a,b                             ; .
 114+ 00D3 ED 31                                add     hl,a                            ; .
 115+ 00D5 ED 31                                add     hl,a                            ; .
 116+ 00D7 7E                                   ld      a,(hl)                          ; .
 117+ 00D8 23                                   inc     hl                              ; .
 118+ 00D9 66                                   ld      h,(hl)                          ; .
 119+ 00DA 6F                                   ld      l,a                             ; .
 120+ 00DB                                      ClearCarryFlag                          ;
 120+ 00DB B7          >                        or a
 121+ 00DC EB                                   ex      de,hl                           ; now hl = log a and de = log b
 122+ 00DD ED 52                                sbc     hl,de                           ; hl = log a - log b
 123+ 00DF 7C                                   ld      a,h                             ; .
 124+ 00E0 21 83 02                             ld      hl,AnitLogODDTable               ; hl = anti log (log a - log b)
 125+ 00E3 ED 31                                add     hl,a                            ; which is also a / b
 126+ 00E5 ED 31                                add     hl,a                            ; .
 127+ 00E7 7E                                   ld      a,(hl)                          ; .
 128+ 00E8                                      ClearCarryFlag                          ;
 128+ 00E8 B7          >                        or a
 129+ 00E9 C9                                   ret
 130+ 00EA              .ResultIsZero:          ClearCarryFlag
 130+ 00EA B7          >                        or a
 131+ 00EB                                      ZeroA
 131+ 00EB AF          >                        xor a
 132+ 00EC C9                                   ret
 133+ 00ED
 134+ 00ED              AEquAmul256DivBLog:     JumpIfAIsZero   .ResultIsZero
 134+ 00ED A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 134+ 00EE CA 24 01    >                        jp	    z, .ResultIsZero
 135+ 00F1                                      JumpIfAGTENusng d, AEquAmul256DivBLogLT
 135+ 00F1 BA          >                        cp     d
 135+ 00F2 D2 C1 00    >                        jp		nc,AEquAmul256DivBLogLT
 136+ 00F5 21 83 03                             ld      hl,LogTable                     ; de = log a
 137+ 00F8 ED 31                                add     hl,a                            ; .
 138+ 00FA ED 31                                add     hl,a                            ; .
 139+ 00FC 5E                                   ld      e,(hl)                          ; .
 140+ 00FD 23                                   inc     hl                              ; .
 141+ 00FE 56                                   ld      d,(hl)                          ; .
 142+ 00FF 21 83 03                             ld      hl,LogTable                     ; hl = log b
 143+ 0102 78                                   ld      a,b                             ; .
 144+ 0103 ED 31                                add     hl,a                            ; .
 145+ 0105 ED 31                                add     hl,a                            ; .
 146+ 0107 7E                                   ld      a,(hl)                          ; .
 147+ 0108 23                                   inc     hl                              ; .
 148+ 0109 66                                   ld      h,(hl)                          ; .
 149+ 010A 6F                                   ld      l,a                             ; .
 150+ 010B                                      ClearCarryFlag                          ;
 150+ 010B B7          >                        or a
 151+ 010C EB                                   ex      de,hl                           ; now hl = log a and de = log b
 152+ 010D ED 52                                sbc     hl,de                           ; hl = log a - log b
 153+ 010F 38 0B                                jr      c,.ResultIsOne                  ; .
 154+ 0111 7C                                   ld      a,h                             ; .
 155+ 0112 21 83 01                             ld      hl,AntiLogTable                 ; hl = anti log (log a - log b)
 156+ 0115 ED 31                                add     hl,a                            ; which is also a / b
 157+ 0117 ED 31                                add     hl,a                            ; .
 158+ 0119 7E                                   ld      a,(hl)                          ; .
 159+ 011A                                      ClearCarryFlag                          ;
 159+ 011A B7          >                        or a
 160+ 011B C9                                   ret
 161+ 011C              .ResultIsOne:           ClearCarryFlag
 161+ 011C B7          >                        or a
 162+ 011D 3E FF                                ld      a,$FF
 163+ 011F C9                                   ret
 164+ 0120              .ResultIsInfinte:       SetCarryFlag
 164+ 0120 37          >                        scf
 165+ 0121 3E FF                                ld      a,$FF
 166+ 0123 C9                                   ret
 167+ 0124              .ResultIsZero:          ClearCarryFlag
 167+ 0124 B7          >                        or a
 168+ 0125 C9                                   ret
 169+ 0126
 170+ 0126              AEquAmul256Div197LogLT: JumpIfAIsZero   .ResultIsZero
 170+ 0126 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 170+ 0127 CA 46 01    >                        jp	    z, .ResultIsZero
 171+ 012A 21 83 03                             ld      hl,LogTable                     ; point to log a in LogTable
 172+ 012D ED 31                                add     hl,a                            ; Note we can't sla in case a > 127
 173+ 012F ED 31                                add     hl,a
 174+ 0131 5E                                   ld      e,(hl)                          ; de = log a
 175+ 0132 23                                   inc     hl                              ; .
 176+ 0133 56                                   ld      d,(hl)                          ; .
 177+ 0134 21 A9 F3                             ld      hl,$F3A9                        ; hl = $F3A9 = log 197
 178+ 0137                                      ClearCarryFlag
 178+ 0137 B7          >                        or a
 179+ 0138 EB                                   ex      hl,de                           ; hl = log a, de = log 197
 180+ 0139 ED 52                                sbc     hl,de
 181+ 013B 7C                                   ld      a,h
 182+ 013C 21 83 02                             ld      hl,AnitLogODDTable
 183+ 013F ED 31                                add     hl,a
 184+ 0141 ED 31                                add     hl,a
 185+ 0143 7E                                   ld      a,(hl)
 186+ 0144                                      ClearCarryFlag
 186+ 0144 B7          >                        or a
 187+ 0145 C9                                   ret
 188+ 0146              .ResultIsZero:          ClearCarryFlag
 188+ 0146 B7          >                        or a
 189+ 0147                                      ZeroA
 189+ 0147 AF          >                        xor a
 190+ 0148 C9                                   ret
 191+ 0149
 192+ 0149
 193+ 0149              AEquAmul256Div197Log:   JumpIfAIsZero   .ResultIsZero
 193+ 0149 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 193+ 014A CA 73 01    >                        jp	    z, .ResultIsZero
 194+ 014D                                      JumpIfAGTENusng d, AEquAmul256Div197LogLT
 194+ 014D BA          >                        cp     d
 194+ 014E D2 26 01    >                        jp		nc,AEquAmul256Div197LogLT
 195+ 0151 21 83 03                             ld      hl,LogTable                     ; point to log a in LogTable
 196+ 0154 ED 31                                add     hl,a                            ; Note we can't sla in case a > 127
 197+ 0156 ED 31                                add     hl,a
 198+ 0158 5E                                   ld      e,(hl)                          ; de = log a
 199+ 0159 23                                   inc     hl                              ; .
 200+ 015A 56                                   ld      d,(hl)                          ; .
 201+ 015B 21 A9 F3                             ld      hl,$F3A9                        ; hl = $F3A9 = log 197
 202+ 015E                                      ClearCarryFlag
 202+ 015E B7          >                        or a
 203+ 015F EB                                   ex      hl,de                           ; hl = log a, de = log 197
 204+ 0160 ED 52                                sbc     hl,de
 205+ 0162 38 0B                                jr      c,.ResultIsOne
 206+ 0164 7C                                   ld      a,h
 207+ 0165 21 83 01                             ld      hl,AntiLogTable
 208+ 0168 ED 31                                add     hl,a
 209+ 016A ED 31                                add     hl,a
 210+ 016C 7E                                   ld      a,(hl)
 211+ 016D                                      ClearCarryFlag
 211+ 016D B7          >                        or a
 212+ 016E C9                                   ret
 213+ 016F              .ResultIsOne:           ClearCarryFlag
 213+ 016F B7          >                        or a
 214+ 0170 3E FF                                ld      a,$FF
 215+ 0172 C9                                   ret
 216+ 0173              .ResultIsZero:          ClearCarryFlag
 216+ 0173 B7          >                        or a
 217+ 0174 C9                                   ret
 218+ 0175
 219+ 0175              AEquAmul256Div197LogSignA:
 220+ 0175 FD 67                                ld      iyh,a
 221+ 0177                                      ClearSignBitA
 221+ 0177 E6 7F       >                        and     SignMask8Bit
 222+ 0179 CD 49 01                             call    AEquAmul256Div197Log
 223+ 017C 47                                   ld      b,a
 224+ 017D FD 7C                                ld      a,iyh
 225+ 017F                                      SignBitOnlyA
 225+ 017F E6 80       >                        and     SignOnly8Bit
 226+ 0181 B0                                   or      b
 227+ 0182 C9                                   ret
# file closed: ../../Maths/logmaths.asm
 946  0183                                  INCLUDE "../../Tables/antilogtable.asm"
# file opened: ../../Tables/antilogtable.asm
   1+ 0183 01 01 01 01  AntiLogTable:           DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 0 to 9
   1+ 0187 01 01 01 01
   1+ 018B 01 01
   2+ 018D 01 01 01 01                          DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 10 to 19
   2+ 0191 01 01 01 01
   2+ 0195 01 01
   3+ 0197 01 01 01 01                          DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 20 to 29
   3+ 019B 01 01 01 01
   3+ 019F 01 01
   4+ 01A1 01 01 02 02                          DB $01, $01, $02, $02, $02, $02, $02, $02, $02, $02 ; 30 to 39
   4+ 01A5 02 02 02 02
   4+ 01A9 02 02
   5+ 01AB 02 02 02 02                          DB $02, $02, $02, $02, $02, $02, $02, $02, $02, $02 ; 40 to 49
   5+ 01AF 02 02 02 02
   5+ 01B3 02 02
   6+ 01B5 02 03 03 03                          DB $02, $03, $03, $03, $03, $03, $03, $03, $03, $03 ; 50 to 59
   6+ 01B9 03 03 03 03
   6+ 01BD 03 03
   7+ 01BF 03 03 03 03                          DB $03, $03, $03, $03, $04, $04, $04, $04, $04, $04 ; 60 to 69
   7+ 01C3 04 04 04 04
   7+ 01C7 04 04
   8+ 01C9 04 04 04 04                          DB $04, $04, $04, $04, $04, $05, $05, $05, $05, $05 ; 70 to 79
   8+ 01CD 04 05 05 05
   8+ 01D1 05 05
   9+ 01D3 05 05 05 06                          DB $05, $05, $05, $06, $06, $06, $06, $06, $06, $06 ; 80 to 89
   9+ 01D7 06 06 06 06
   9+ 01DB 06 06
  10+ 01DD 07 07 07 07                          DB $07, $07, $07, $07, $07, $07, $08, $08, $08, $08 ; 90 to 99
  10+ 01E1 07 07 08 08
  10+ 01E5 08 08
  11+ 01E7 08 08 09 09                          DB $08, $08, $09, $09, $09, $09, $09, $0A, $0A, $0A ; 100 to 109
  11+ 01EB 09 09 09 0A
  11+ 01EF 0A 0A
  12+ 01F1 0A 0B 0B 0B                          DB $0A, $0B, $0B, $0B, $0B, $0C, $0C, $0C, $0C, $0D ; 110 to 119
  12+ 01F5 0B 0C 0C 0C
  12+ 01F9 0C 0D
  13+ 01FB 0D 0D 0E 0E                          DB $0D, $0D, $0E, $0E, $0E, $0E, $0F, $0F, $10, $10 ; 120 to 129
  13+ 01FF 0E 0E 0F 0F
  13+ 0203 10 10
  14+ 0205 10 11 11 11                          DB $10, $11, $11, $11, $12, $12, $13, $13, $13, $14 ; 130 to 139
  14+ 0209 12 12 13 13
  14+ 020D 13 14
  15+ 020F 14 15 15 16                          DB $14, $15, $15, $16, $16, $17, $17, $18, $18, $19 ; 140 to 149
  15+ 0213 16 17 17 18
  15+ 0217 18 19
  16+ 0219 19 1A 1A 1B                          DB $19, $1A, $1A, $1B, $1C, $1C, $1D, $1D, $1E, $1F ; 150 to 159
  16+ 021D 1C 1C 1D 1D
  16+ 0221 1E 1F
  17+ 0223 20 20 21 22                          DB $20, $20, $21, $22, $22, $23, $24, $25, $26, $26 ; 160 to 169
  17+ 0227 22 23 24 25
  17+ 022B 26 26
  18+ 022D 27 28 29 2A                          DB $27, $28, $29, $2A, $2B, $2C, $2D, $2E, $2F, $30 ; 170 to 179
  18+ 0231 2B 2C 2D 2E
  18+ 0235 2F 30
  19+ 0237 31 32 33 34                          DB $31, $32, $33, $34, $35, $36, $38, $39, $3A, $3B ; 180 to 189
  19+ 023B 35 36 38 39
  19+ 023F 3A 3B
  20+ 0241 3D 3E 40 41                          DB $3D, $3E, $40, $41, $42, $44, $45, $47, $48, $4A ; 190 to 199
  20+ 0245 42 44 45 47
  20+ 0249 48 4A
  21+ 024B 4C 4D 4F 51                          DB $4C, $4D, $4F, $51, $52, $54, $56, $58, $5A, $5C ; 200 to 219
  21+ 024F 52 54 56 58
  21+ 0253 5A 5C
  22+ 0255 5E 60 62 64                          DB $5E, $60, $62, $64, $67, $69, $6B, $6D, $70, $72 ; 210 to 229
  22+ 0259 67 69 6B 6D
  22+ 025D 70 72
  23+ 025F 75 77 7A 7D                          DB $75, $77, $7A, $7D, $80, $82, $85, $88, $8B, $8E ; 220 to 239
  23+ 0263 80 82 85 88
  23+ 0267 8B 8E
  24+ 0269 91 94 98 9B                          DB $91, $94, $98, $9B, $9E, $A2, $A5, $A9, $AD, $B1 ; 230 to 239
  24+ 026D 9E A2 A5 A9
  24+ 0271 AD B1
  25+ 0273 B5 B8 BD C1                          DB $B5, $B8, $BD, $C1, $C5, $C9, $CE, $D2, $D7, $DB ; 240 to 249
  25+ 0277 C5 C9 CE D2
  25+ 027B D7 DB
  26+ 027D E0 E5 EA EF                          DB $E0, $E5, $EA, $EF, $F5, $FA                     ; 250 to 255
  26+ 0281 F5 FA
  27+ 0283
  28+ 0283 01 01 01 01  AnitLogODDTable:        DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 0 to 9
  28+ 0287 01 01 01 01
  28+ 028B 01 01
  29+ 028D 01 01 01 01                          DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 10 to 19
  29+ 0291 01 01 01 01
  29+ 0295 01 01
  30+ 0297 01 01 01 01                          DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 20 to 29
  30+ 029B 01 01 01 01
  30+ 029F 01 01
  31+ 02A1 01 01 02 02                          DB $01, $01, $02, $02, $02, $02, $02, $02, $02, $02 ; 30 to 39
  31+ 02A5 02 02 02 02
  31+ 02A9 02 02
  32+ 02AB 02 02 02 02                          DB $02, $02, $02, $02, $02, $02, $02, $02, $02, $02 ; 40 to 49
  32+ 02AF 02 02 02 02
  32+ 02B3 02 02
  33+ 02B5 02 03 03 03                          DB $02, $03, $03, $03, $03, $03, $03, $03, $03, $03 ; 50 to 59
  33+ 02B9 03 03 03 03
  33+ 02BD 03 03
  34+ 02BF 03 03 03 03                          DB $03, $03, $03, $03, $04, $04, $04, $04, $04, $04 ; 60 to 69
  34+ 02C3 04 04 04 04
  34+ 02C7 04 04
  35+ 02C9 04 04 04 04                          DB $04, $04, $04, $04, $05, $05, $05, $05, $05, $05 ; 70 to 79
  35+ 02CD 05 05 05 05
  35+ 02D1 05 05
  36+ 02D3 05 05 05 06                          DB $05, $05, $05, $06, $06, $06, $06, $06, $06, $06 ; 80 to 89
  36+ 02D7 06 06 06 06
  36+ 02DB 06 06
  37+ 02DD 07 07 07 07                          DB $07, $07, $07, $07, $07, $07, $08, $08, $08, $08 ; 90 to 99
  37+ 02E1 07 07 08 08
  37+ 02E5 08 08
  38+ 02E7 08 09 09 09                          DB $08, $09, $09, $09, $09, $09, $0A, $0A, $0A, $0A ; 100 to 109
  38+ 02EB 09 09 0A 0A
  38+ 02EF 0A 0A
  39+ 02F1 0A 0B 0B 0B                          DB $0A, $0B, $0B, $0B, $0B, $0C, $0C, $0C, $0D, $0D ; 110 to 119
  39+ 02F5 0B 0C 0C 0C
  39+ 02F9 0D 0D
  40+ 02FB 0D 0D 0E 0E                          DB $0D, $0D, $0E, $0E, $0E, $0F, $0F, $0F, $10, $10 ; 120 to 129
  40+ 02FF 0E 0F 0F 0F
  40+ 0303 10 10
  41+ 0305 10 11 11 12                          DB $10, $11, $11, $12, $12, $12, $13, $13, $14, $14 ; 130 to 139
  41+ 0309 12 12 13 13
  41+ 030D 14 14
  42+ 030F 14 15 15 16                          DB $14, $15, $15, $16, $16, $17, $17, $18, $18, $19 ; 140 to 149
  42+ 0313 16 17 17 18
  42+ 0317 18 19
  43+ 0319 1A 1A 1B 1B                          DB $1A, $1A, $1B, $1B, $1C, $1D, $1D, $1E, $1E, $1F ; 150 to 159
  43+ 031D 1C 1D 1D 1E
  43+ 0321 1E 1F
  44+ 0323 20 21 21 22                          DB $20, $21, $21, $22, $23, $24, $24, $25, $26, $27 ; 160 to 169
  44+ 0327 23 24 24 25
  44+ 032B 26 27
  45+ 032D 28 29 29 2A                          DB $28, $29, $29, $2A, $2B, $2C, $2D, $2E, $2F, $30 ; 170 to 179
  45+ 0331 2B 2C 2D 2E
  45+ 0335 2F 30
  46+ 0337 31 32 34 35                          DB $31, $32, $34, $35, $36, $37, $38, $3A, $3B, $3C ; 180 to 189
  46+ 033B 36 37 38 3A
  46+ 033F 3B 3C
  47+ 0341 3D 3F 40 42                          DB $3D, $3F, $40, $42, $43, $45, $46, $48, $49, $4B ; 190 to 199
  47+ 0345 43 45 46 48
  47+ 0349 49 4B
  48+ 034B 4C 4E 50 52                          DB $4C, $4E, $50, $52, $53, $55, $57, $59, $5B, $5D ; 200 to 219
  48+ 034F 53 55 57 59
  48+ 0353 5B 5D
  49+ 0355 5F 61 63 65                          DB $5F, $61, $63, $65, $68, $6A, $6C, $6F, $71, $74 ; 210 to 229
  49+ 0359 68 6A 6C 6F
  49+ 035D 71 74
  50+ 035F 76 79 7B 7E                          DB $76, $79, $7B, $7E, $81, $84, $87, $8A, $8D, $90 ; 220 to 239
  50+ 0363 81 84 87 8A
  50+ 0367 8D 90
  51+ 0369 93 96 99 9D                          DB $93, $96, $99, $9D, $A0, $A4, $A7, $AB, $AF, $B3 ; 230 to 239
  51+ 036D A0 A4 A7 AB
  51+ 0371 AF B3
  52+ 0373 B6 BA BF C3                          DB $B6, $BA, $BF, $C3, $C7, $CB, $D0, $D4, $D9, $DE ; 240 to 249
  52+ 0377 C7 CB D0 D4
  52+ 037B D9 DE
  53+ 037D E3 E8 ED F2                          DB $E3, $E8, $ED, $F2, $F7, $FD                     ; 250 to 255
  53+ 0381 F7 FD
  54+ 0383
# file closed: ../../Tables/antilogtable.asm
 947  0383                                  INCLUDE "../../Tables/logtable.asm"
# file opened: ../../Tables/logtable.asm
   1+ 0383 00 00        LogTable:               DW $0000                                                                   ; 0
   2+ 0385 00 00 00 20                          DW $0000, $2000, $32B8, $4000, $4A4D, $52B8, $59D6, $6000, $6570, $6A4D    ;   1 TO  10
   2+ 0389 B8 32 00 40
   2+ 038D 4D 4A B8 52
   2+ 0391 D6 59 00 60
   2+ 0395 70 65 4D 6A
   3+ 0399 B4 6E B8 72                          DW $6EB4, $72B8, $766A, $79D6, $7D05, $8000, $82CC, $8570, $87EF, $8A4D    ;  11 TO  20
   3+ 039D 6A 76 D6 79
   3+ 03A1 05 7D 00 80
   3+ 03A5 CC 82 70 85
   3+ 03A9 EF 87 4D 8A
   4+ 03AD 8E 8C B4 8E                          DW $8C8E, $8EB4, $90C1, $92B8, $949A, $966A, $9828, $99D6, $9B75, $9D05    ;  21 TO  30
   4+ 03B1 C1 90 B8 92
   4+ 03B5 9A 94 6A 96
   4+ 03B9 28 98 D6 99
   4+ 03BD 75 9B 05 9D
   5+ 03C1 89 9E 00 A0                          DW $9E89, $A000, $A16C, $A2CC, $A423, $A570, $A6B4, $A7EF, $A922, $AA4D    ;  31 TO  40
   5+ 03C5 6C A1 CC A2
   5+ 03C9 23 A4 70 A5
   5+ 03CD B4 A6 EF A7
   5+ 03D1 22 A9 4D AA
   6+ 03D5 71 AB 8E AC                          DW $AB71, $AC8E, $ADA4, $AEB4, $AFBD, $B0C1, $B1BF, $B2B8, $B3AC, $B49A    ;  41 TO  50
   6+ 03D9 A4 AD B4 AE
   6+ 03DD BD AF C1 B0
   6+ 03E1 BF B1 B8 B2
   6+ 03E5 AC B3 9A B4
   7+ 03E9 85 B5 6A B6                          DW $B585, $B66A, $B74B, $B828, $B901, $B9D6, $BAA7, $BB75, $BC3F, $BD05    ;  51 TO  60
   7+ 03ED 4B B7 28 B8
   7+ 03F1 01 B9 D6 B9
   7+ 03F5 A7 BA 75 BB
   7+ 03F9 3F BC 05 BD
   8+ 03FD C9 BD 89 BE                          DW $BDC9, $BE89, $BF46, $C000, $C0B7, $C16C, $C21D, $C2CC, $C379, $C423    ;  61 TO  70
   8+ 0401 46 BF 00 C0
   8+ 0405 B7 C0 6C C1
   8+ 0409 1D C2 CC C2
   8+ 040D 79 C3 23 C4
   9+ 0411 CB C4 70 C5                          DW $C4CB, $C570, $C613, $C6B4, $C752, $C7EF, $C88A, $C922, $C9B9, $CA4D    ;  71 TO  80
   9+ 0415 13 C6 B4 C6
   9+ 0419 52 C7 EF C7
   9+ 041D 8A C8 22 C9
   9+ 0421 B9 C9 4D CA
  10+ 0425 E0 CA 71 CB                          DW $CAE0, $CB71, $CC00, $CC8E, $CD1A, $CDA4, $CE2D, $CEB4, $CF39, $CFBD    ;  81 TO  90
  10+ 0429 00 CC 8E CC
  10+ 042D 1A CD A4 CD
  10+ 0431 2D CE B4 CE
  10+ 0435 39 CF BD CF
  11+ 0439 40 D0 C1 D0                          DW $D040, $D0C1, $D141, $D1BF, $D23C, $D2B8, $D332, $D3AC, $D424, $D49A    ;  91 TO 100
  11+ 043D 41 D1 BF D1
  11+ 0441 3C D2 B8 D2
  11+ 0445 32 D3 AC D3
  11+ 0449 24 D4 9A D4
  12+ 044D 10 D5 85 D5                          DW $D510, $D585, $D5F8, $D66A, $D6DB, $D74B, $D7BA, $D828, $D895, $D901    ; 101 TO 110
  12+ 0451 F8 D5 6A D6
  12+ 0455 DB D6 4B D7
  12+ 0459 BA D7 28 D8
  12+ 045D 95 D8 01 D9
  13+ 0461 6C D9 D6 D9                          DW $D96C, $D9D6, $DA3F, $DAA7, $DB0E, $DB75, $DBDA, $DC3F, $DCA2, $DD05    ; 111 TO 120
  13+ 0465 3F DA A7 DA
  13+ 0469 0E DB 75 DB
  13+ 046D DA DB 3F DC
  13+ 0471 A2 DC 05 DD
  14+ 0475 67 DD C9 DD                          DW $DD67, $DDC9, $DE29, $DE89, $DEE8, $DF46, $DFA3, $E000, $E05C, $E0B7    ; 121 TO 130
  14+ 0479 29 DE 89 DE
  14+ 047D E8 DE 46 DF
  14+ 0481 A3 DF 00 E0
  14+ 0485 5C E0 B7 E0
  15+ 0489 12 E1 6C E1                          DW $E112, $E16C, $E1C5, $E21D, $E275, $E2CC, $E323, $E379, $E3CE, $E423    ; 131 TO 140
  15+ 048D C5 E1 1D E2
  15+ 0491 75 E2 CC E2
  15+ 0495 23 E3 79 E3
  15+ 0499 CE E3 23 E4
  16+ 049D 77 E4 CB E4                          DW $E477, $E4CB, $E51E, $E570, $E5C2, $E613, $E664, $E6B4, $E703, $E752    ; 141 TO 150
  16+ 04A1 1E E5 70 E5
  16+ 04A5 C2 E5 13 E6
  16+ 04A9 64 E6 B4 E6
  16+ 04AD 03 E7 52 E7
  17+ 04B1 A1 E7 EF E7                          DW $E7A1, $E7EF, $E83D, $E88A, $E8D6, $E922, $E96E, $E9B9, $EA03, $EA4D    ; 151 TO 160
  17+ 04B5 3D E8 8A E8
  17+ 04B9 D6 E8 22 E9
  17+ 04BD 6E E9 B9 E9
  17+ 04C1 03 EA 4D EA
  18+ 04C5 97 EA E0 EA                          DW $EA97, $EAE0, $EB29, $EB71, $EBB9, $EC00, $EC47, $EC8E, $ECD4, $ED1A    ; 161 TO 170
  18+ 04C9 29 EB 71 EB
  18+ 04CD B9 EB 00 EC
  18+ 04D1 47 EC 8E EC
  18+ 04D5 D4 EC 1A ED
  19+ 04D9 5F ED A4 ED                          DW $ED5F, $EDA4, $EDE8, $EE2D, $EE70, $EEB4, $EEF7, $EF39, $EF7B, $EFBD    ; 171 TO 180
  19+ 04DD E8 ED 2D EE
  19+ 04E1 70 EE B4 EE
  19+ 04E5 F7 EE 39 EF
  19+ 04E9 7B EF BD EF
  20+ 04ED FF EF 40 F0                          DW $EFFF, $F040, $F081, $F0C1, $F101, $F141, $F180, $F1BF, $F1FE, $F23C    ; 181 TO 190
  20+ 04F1 81 F0 C1 F0
  20+ 04F5 01 F1 41 F1
  20+ 04F9 80 F1 BF F1
  20+ 04FD FE F1 3C F2
  21+ 0501 7A F2 B8 F2                          DW $F27A, $F2B8, $F2F5, $F332, $F36F, $F3AC, $F3E8, $F424, $F45F, $F49A    ; 191 TO 290
  21+ 0505 F5 F2 32 F3
  21+ 0509 6F F3 AC F3
  21+ 050D E8 F3 24 F4
  21+ 0511 5F F4 9A F4
  22+ 0515 D5 F4 10 F5                          DW $F4D5, $F510, $F54A, $F585, $F5BE, $F5F8, $F631, $F66A, $F6A3, $F6DB    ; 201 TO 210
  22+ 0519 4A F5 85 F5
  22+ 051D BE F5 F8 F5
  22+ 0521 31 F6 6A F6
  22+ 0525 A3 F6 DB F6
  23+ 0529 13 F7 4B F7                          DW $F713, $F74B, $F783, $F7BA, $F7F1, $F828, $F85F, $F895, $F8CB, $F901    ; 211 TO 220
  23+ 052D 83 F7 BA F7
  23+ 0531 F1 F7 28 F8
  23+ 0535 5F F8 95 F8
  23+ 0539 CB F8 01 F9
  24+ 053D 36 F9 6C F9                          DW $F936, $F96C, $F9A1, $F9D6, $FA0A, $FA3F, $FA73, $FAA7, $FADB, $FB0E    ; 221 TO 230
  24+ 0541 A1 F9 D6 F9
  24+ 0545 0A FA 3F FA
  24+ 0549 73 FA A7 FA
  24+ 054D DB FA 0E FB
  25+ 0551 42 FB 75 FB                          DW $FB42, $FB75, $FBA7, $FBDA, $FC0C, $FC3F, $FC71, $FCA2, $FCD4, $FD05    ; 231 TO 240
  25+ 0555 A7 FB DA FB
  25+ 0559 0C FC 3F FC
  25+ 055D 71 FC A2 FC
  25+ 0561 D4 FC 05 FD
  26+ 0565 36 FD 67 FD                          DW $FD36, $FD67, $FD98, $FDC9, $FDF9, $FE29, $FE59, $FE89, $FEB8, $FEE8    ; 241 TO 250
  26+ 0569 98 FD C9 FD
  26+ 056D F9 FD 29 FE
  26+ 0571 59 FE 89 FE
  26+ 0575 B8 FE E8 FE
  27+ 0579 17 FF 46 FF                          DW $FF17, $FF46, $FF75, $FFA3, $FFA3                                       ; 251 TO 255
  27+ 057D 75 FF A3 FF
  27+ 0581 A3 FF
  28+ 0583
  29+ 0583
  30+ 0583
  31+ 0583 00 00 00 00  LogReverseHighByte:     DW $00, 000, $20, 002, $32, 003, $40, 004, $4A, 005, $52, 006
  31+ 0587 20 00 02 00
  31+ 058B 32 00 03 00
  31+ 058F 40 00 04 00
  31+ 0593 4A 00 05 00
  31+ 0597 52 00 06 00
  32+ 059B 59 00 07 00                          DW $59, 007, $60, 008, $65, 009, $6A, 010, $6E, 011, $72, 012
  32+ 059F 60 00 08 00
  32+ 05A3 65 00 09 00
  32+ 05A7 6A 00 0A 00
  32+ 05AB 6E 00 0B 00
  32+ 05AF 72 00 0C 00
  33+ 05B3 76 00 0D 00                          DW $76, 013, $79, 014, $7D, 015, $80, 016, $82, 017, $85, 018
  33+ 05B7 79 00 0E 00
  33+ 05BB 7D 00 0F 00
  33+ 05BF 80 00 10 00
  33+ 05C3 82 00 11 00
  33+ 05C7 85 00 12 00
  34+ 05CB 87 00 13 00                          DW $87, 019, $8A, 020, $8C, 021, $8E, 022, $90, 023, $92, 024
  34+ 05CF 8A 00 14 00
  34+ 05D3 8C 00 15 00
  34+ 05D7 8E 00 16 00
  34+ 05DB 90 00 17 00
  34+ 05DF 92 00 18 00
  35+ 05E3 94 00 19 00                          DW $94, 025, $96, 026, $98, 027, $99, 028, $9B, 029, $9D, 030
  35+ 05E7 96 00 1A 00
  35+ 05EB 98 00 1B 00
  35+ 05EF 99 00 1C 00
  35+ 05F3 9B 00 1D 00
  35+ 05F7 9D 00 1E 00
  36+ 05FB 9E 00 1F 00                          DW $9E, 031, $A0, 032, $A1, 033, $A2, 034, $A4, 035, $A5, 036
  36+ 05FF A0 00 20 00
  36+ 0603 A1 00 21 00
  36+ 0607 A2 00 22 00
  36+ 060B A4 00 23 00
  36+ 060F A5 00 24 00
  37+ 0613 A6 00 25 00                          DW $A6, 037, $A7, 038, $A9, 039, $AA, 040, $AB, 041, $AC, 042
  37+ 0617 A7 00 26 00
  37+ 061B A9 00 27 00
  37+ 061F AA 00 28 00
  37+ 0623 AB 00 29 00
  37+ 0627 AC 00 2A 00
  38+ 062B AD 00 2B 00                          DW $AD, 043, $AE, 044, $AF, 045, $B0, 046, $B1, 047, $B2, 048
  38+ 062F AE 00 2C 00
  38+ 0633 AF 00 2D 00
  38+ 0637 B0 00 2E 00
  38+ 063B B1 00 2F 00
  38+ 063F B2 00 30 00
  39+ 0643 B3 00 31 00                          DW $B3, 049, $B4, 050, $B5, 051, $B6, 052, $B7, 053, $B8, 054
  39+ 0647 B4 00 32 00
  39+ 064B B5 00 33 00
  39+ 064F B6 00 34 00
  39+ 0653 B7 00 35 00
  39+ 0657 B8 00 36 00
  40+ 065B B9 00 38 00                          DW $B9, 056, $B9, 056, $BA, 057, $BB, 058, $BC, 059, $BD, 060
  40+ 065F B9 00 38 00
  40+ 0663 BA 00 39 00
  40+ 0667 BB 00 3A 00
  40+ 066B BC 00 3B 00
  40+ 066F BD 00 3C 00
  41+ 0673 BE 00 3E 00                          DW $BE, 062, $BF, 063, $C0, 064, $C1, 066, $C2, 067, $C3, 069
  41+ 0677 BF 00 3F 00
  41+ 067B C0 00 40 00
  41+ 067F C1 00 42 00
  41+ 0683 C2 00 43 00
  41+ 0687 C3 00 45 00
  42+ 068B C4 00 46 00                          DW $C4, 070, $C5, 072, $C6, 072, $C7, 074, $C8, 076, $C9, 077
  42+ 068F C5 00 48 00
  42+ 0693 C6 00 48 00
  42+ 0697 C7 00 4A 00
  42+ 069B C8 00 4C 00
  42+ 069F C9 00 4D 00
  43+ 06A3 CA 00 50 00                          DW $CA, 080, $CB, 082, $CC, 083, $CD, 085, $CE, 087, $CF, 088
  43+ 06A7 CB 00 52 00
  43+ 06AB CC 00 53 00
  43+ 06AF CD 00 55 00
  43+ 06B3 CE 00 57 00
  43+ 06B7 CF 00 58 00
  44+ 06BB D0 00 5A 00                          DW $D0, 090, $D1, 092, $D2, 094, $D3, 097, $D4, 100, $D5, 102
  44+ 06BF D1 00 5C 00
  44+ 06C3 D2 00 5E 00
  44+ 06C7 D3 00 61 00
  44+ 06CB D4 00 64 00
  44+ 06CF D5 00 66 00
  45+ 06D3 D6 00 68 00                          DW $D6, 104, $D6, 105, $D7, 106, $D7, 107, $D8, 108, $D8, 109
  45+ 06D7 D6 00 69 00
  45+ 06DB D7 00 6A 00
  45+ 06DF D7 00 6B 00
  45+ 06E3 D8 00 6C 00
  45+ 06E7 D8 00 6D 00
  46+ 06EB D9 00 6E 00                          DW $D9, 110, $D9, 111, $D9, 112, $DA, 113, $DB, 114, $DC, 117
  46+ 06EF D9 00 6F 00
  46+ 06F3 D9 00 70 00
  46+ 06F7 DA 00 71 00
  46+ 06FB DB 00 72 00
  46+ 06FF DC 00 75 00
  47+ 0703 DD 00 78 00                          DW $DD, 120, $DE, 123, $DF, 126, $E0, 128, $E1, 131, $E2, 134
  47+ 0707 DE 00 7B 00
  47+ 070B DF 00 7E 00
  47+ 070F E0 00 80 00
  47+ 0713 E1 00 83 00
  47+ 0717 E2 00 86 00
  48+ 071B E3 00 89 00                          DW $E3, 137, $E4, 140, $E5, 143, $E6, 146, $E7, 149, $E8, 153
  48+ 071F E4 00 8C 00
  48+ 0723 E5 00 8F 00
  48+ 0727 E6 00 92 00
  48+ 072B E7 00 95 00
  48+ 072F E8 00 99 00
  49+ 0733 E9 00 9C 00                          DW $E9, 156, $EA, 159, $EB, 163, $EC, 166, $ED, 170, $EE, 174
  49+ 0737 EA 00 9F 00
  49+ 073B EB 00 A3 00
  49+ 073F EC 00 A6 00
  49+ 0743 ED 00 AA 00
  49+ 0747 EE 00 AE 00
  50+ 074B EF 00 B2 00                          DW $EF, 178, $F0, 182, $F1, 185, $F2, 190, $F3, 194, $F4, 198
  50+ 074F F0 00 B6 00
  50+ 0753 F1 00 B9 00
  50+ 0757 F2 00 BE 00
  50+ 075B F3 00 C2 00
  50+ 075F F4 00 C6 00
  51+ 0763 F5 00 CA 00                          DW $F5, 202, $F6, 207, $F7, 211, $F8, 216, $F8, 217, $F9, 220
  51+ 0767 F6 00 CF 00
  51+ 076B F7 00 D3 00
  51+ 076F F8 00 D8 00
  51+ 0773 F8 00 D9 00
  51+ 0777 F9 00 DC 00
  52+ 077B FA 00 E1 00                          DW $FA, 225, $FB, 230, $FB, 233, $FC, 235, $FD, 240, $FE, 246
  52+ 077F FB 00 E6 00
  52+ 0783 FB 00 E9 00
  52+ 0787 FC 00 EB 00
  52+ 078B FD 00 F0 00
  52+ 078F FE 00 F6 00
  53+ 0793 FF 00 FB 00                          DW $FF, 251
  54+ 0797              LogReverseTableLen:     EQU $ - LogReverseHighByte
# file closed: ../../Tables/logtable.asm
 948  0797                                  DISPLAY "Bank ",BankMathsTables," - Bytes free ",/D, $2000 - ($-MathsTablesAddr), " - BankMathsTables"
 949  0797                                  ASSERT $-MathsTablesAddr <8912, Bank code leaks over 8K boundary
 950  0797              ; Bank 100  -----------------------------------------------------------------------------------------------------------------------
 951  0797                                  SLOT    KeyboardAddr
 952  0797                                  PAGE    BankKeyboard
 953  0797                                  ORG SoundAddr, BankKeyboard
 954  E000                                  INCLUDE "../../Hardware/keyboard.asm"
# file opened: ../../Hardware/keyboard.asm
   1+ E000              ;
   2+ E000              ; $FEFE;65278 V, C, X, Z, Caps Shifts       4  3  2  1  0
   3+ E000              ; $FDFE;65022 G, F, D, S, A                 9  8  7  6  5
   4+ E000              ; $FBFE;64510 T, R, E, W, Q                14 13 12 11 10
   5+ E000              ; $F7FE;63486 5, 4, 3, 2, 1                19 18 17 16 15
   6+ E000              ; $EFFE;61438 6, 7, 8, 9, 0                24 23 22 23 20
   7+ E000              ; $DFFE;57342 Y, U, I, O, P                29 28 27 26 25
   8+ E000              ; $BFFE;49150 H, J, K, L, Enter            34 33 32 31 30
   9+ E000              ; $7FFE;32766 B, N, M, Symbol Shift, Space 39 38 37 36 35
  10+ E000              ;
  11+ E000              ; Keyboard
  12+ E000              ;
  13+ E000              ;   0      1       2       3       4       5        6       7       8       9
  14+ E000              ;  VK_CAPS, VK_Z,  VK_X,   VK_C,   VK_V,   VK_A,    VK_S,   VK_D,   VK_F,   VK_G
  15+ E000              ;   10     11      12      13      14      15       16      17      18      19
  16+ E000              ;  VK_Q,   VK_W,   VK_E,   VK_R,   VK_T,   VK_1,    VK_2,   VK_3,   VK_4,   VK_5
  17+ E000              ;   20     21      22      23      24      25       26      27      28      29
  18+ E000              ;  VK_0    VK_9,   VK_8,   VK_7,   VK_6,   VK_P ,    VK_O,  VK_I,   VK_U,   VK_Y
  19+ E000              ;   30     31      32      33      34      35       36      37      38      39
  20+ E000              ; VK_ENTER VK_L,   VK_K,   VK_J,   VK_H,   VK_SPACE VK_SYM, VK_M,   VK_N,   VK_B
  21+ E000              ;
  22+ E000              ; ZX Spectrum Next Compound keys
  23+ E000              ;   40     41       42       43      44      45       46       47
  24+ E000              ;  VK_SEMI VK_QUOTE VK_COMMA VK_STOP VK_UP   VK_DOWN  VK_LEFT  VK _RIGHT        $Register B0 bits 7 to 0    (Set to set ULA Register ($68) bit to to prevent default keystrokes
  25+ E000              ;   48       49      50       51         52          53       54      55
  26+ E000              ;  VK_DELETE VK_EDIT VK_BREAK VK_INV_VID VK_TRUE_VID VK_GRAPH VK_CAPS VK_EXTEND $Register B1 bits 7 to 0
  27+ E000              ; Default map
  28+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  29+ E000              ;   0          1           2             3              4           5           6           7           8           9
  30+ E000              ;   VK_CAPS    VK_Z        VK_X,         VK_C,          VK_V,       VK_A        VK_S,       VK_D,       VK_F,       VK_G
  31+ E000              ;              GameSkip                  Equip          SelLCargo   Climb       Decelerate  Recentre    FireM       HomeCursor
  32+ E000              ;                                                                                                       Find System
  33+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  34+ E000              ;   10         11          12            13             14          15          16          17          18          19
  35+ E000              ;   VK_Q       VK_W,       VK_E,         VK_R,          VK_T,       VK_1        VK_2        VK_3        VK_4        VK_5
  36+ E000              ;   Dive       Accelerate  ECM           UnarmMissile   TargetM     FrontV      AftV        LeftV       RightV      GalacticChart
  37+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  38+ E000              ;   20         Accel       22            23             24          25          26          27          28          29
  39+ E000              ;   VK_0       VK_9,       VK_8,         VK_7,          VK_6,       VK_P ,      VK_O,       VK_I,       VK_U,       VK_Y
  40+ E000              ;   EscapePod  Inventory   Status        MarketPrices   LocalChart  RollRight   RolLLeft                EnergyBomb  Quit
  41+ E000              ;   PlanetData                                                      PauseGame   SaveGame
  42+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  43+ E000              ;   30         31          32            33             34          Right       36          37          EnergyBomb  39
  44+ E000              ;   VK_ENTER   VK_L,       VK_K,         VK_J,          VK_H,       VK_SPACE    VK_SYM,     VK_M,       VK_N,       VK_B
  45+ E000              ;              Launch                    Distance       Hyperspace  Laser                               DockComp    BuyCargo
  46+ E000              ;              ResumeGame                WarpJump
  47+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  48+ E000              ;   40         41          42            43             44          45          46          47          48          49
  49+ E000              ;   VK_SEMI    VK_QUOTE    VK_COMMA      VK_STOP        VK_UP       VK_DOWN     VK_LEFT     VK _RIGHT   VK_DELETE   VK_EDIT
  50+ E000              ;   Market     EquipShip   PlanetData    NearestObject  Map Cursor no auto repeat....................   Delete      Find System
  51+ E000              ;
  52+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  53+ E000              ;   50         51          52            53             54          55
  54+ E000              ;   VK_BREAK   VK_INV_VID  VK_TRUE_VID   VK_GRAPH       VK_EXTCAPS  VK_EXTEND
  55+ E000              ;   EscapePod  Inventory   Status        GalacticChart  LocalChart  SystemJump
  56+ E000              ;
  57+ E000
  58+ E000              ; You can read address to check keystate by address KeyboardMap + c_Pressed corresponding key. There is also an addr_ helper too
  59+ E000
  60+ E000              c_Pressed_Front         equ 0  * 2
  61+ E000              c_Pressed_Aft           equ 1  * 2
  62+ E000              c_Pressed_Left          equ 2  * 2
  63+ E000              c_Pressed_Right         equ 3  * 2
  64+ E000              c_Pressed_RollLeft      equ 4  * 2
  65+ E000              c_Pressed_RollRight     equ 5  * 2
  66+ E000              c_Pressed_Dive          equ 6  * 2
  67+ E000              c_Pressed_Climb         equ 7  * 2
  68+ E000              c_Pressed_Accellerate   equ 8  * 2
  69+ E000              c_Pressed_Decellerate   equ 9  * 2
  70+ E000              c_Pressed_FireLaser     equ 10 * 2
  71+ E000              c_Pressed_TargetMissle  equ 11 * 2
  72+ E000              c_Pressed_FireMissile   equ 12 * 2
  73+ E000              c_Pressed_UnarmMissile  equ 13 * 2
  74+ E000              c_Pressed_ECM           equ 14 * 2
  75+ E000              c_Pressed_EnergyBomb    equ 15 * 2
  76+ E000              c_Pressed_EscapePod     equ 16 * 2
  77+ E000              c_Pressed_DockingComp   equ 17 * 2
  78+ E000              c_Pressed_Hyperspace    equ 18 * 2
  79+ E000              c_Pressed_Distance      equ 19 * 2
  80+ E000              c_Pressed_HomeCursor    equ 20 * 2
  81+ E000              c_Pressed_Launch        equ 21 * 2
  82+ E000              c_Pressed_BuyCargo      equ 22 * 2
  83+ E000              c_Pressed_SellCargo     equ 23 * 2
  84+ E000              c_Pressed_Equip         equ 24 * 2
  85+ E000              c_Pressed_GalacticChrt  equ 25 * 2
  86+ E000              c_Pressed_LocalChart    equ 26 * 2
  87+ E000              c_Pressed_MarketPrices  equ 27 * 2
  88+ E000              c_Pressed_Status        equ 28 * 2
  89+ E000              c_Pressed_Inventory     equ 29 * 2
  90+ E000              c_Pressed_GameSkip      equ 30 * 2
  91+ E000              c_Pressed_Save          equ 31 * 2
  92+ E000              c_Pressed_Freeze        equ 32 * 2
  93+ E000              c_Pressed_Resume        equ 33 * 2
  94+ E000              c_Pressed_Recentre      equ 34 * 2
  95+ E000              c_Pressed_Quit          equ 35 * 2
  96+ E000              c_Pressed_PlanetData    equ 36 * 2
  97+ E000              c_Pressed_CursorUp      equ 37 * 2
  98+ E000              c_Pressed_CursorDown    equ 38 * 2
  99+ E000              c_Pressed_Find          equ 39 * 2
 100+ E000              c_Pressed_Yes           equ 40 * 2
 101+ E000              c_Pressed_No            equ 41 * 2
 102+ E000              c_Pressed_Warp          equ 42 * 2
 103+ E000              c_Pressed_ExtMarket     equ 43 * 2
 104+ E000              c_Pressed_ExtEquip      equ 44 * 2
 105+ E000              c_Pressed_ExtPlanet     equ 45 * 2
 106+ E000              c_Pressed_ExtNearest    equ 46 * 2
 107+ E000              c_Pressed_ExtCurUp      equ 47 * 2
 108+ E000              c_Pressed_ExtCurDown    equ 48 * 2
 109+ E000              c_Pressed_ExtCurLeft    equ 49 * 2
 110+ E000              c_Pressed_ExtCurRight   equ 50 * 2
 111+ E000              c_Pressed_ExtDelete     equ 51 * 2
 112+ E000              c_Pressed_ExtFindSystem equ 52 * 2
 113+ E000              c_Pressed_ExtEscapePod  equ 53 * 2
 114+ E000              c_Pressed_ExtInventory  equ 54 * 2
 115+ E000              c_Pressed_ExtStatus     equ 55 * 2
 116+ E000              c_Pressed_ExtGlactic    equ 56 * 2
 117+ E000              c_Pressed_ExtLocal      equ 57 * 2
 118+ E000              c_Pressed_ExtSystemJump equ 58 * 2
 119+ E000
 120+ E000              ; half row 1
 121+ E000              VK_CAPS  				equ 0
 122+ E000              VK_Z  					equ 1
 123+ E000              VK_X  					equ 2
 124+ E000              VK_C  					equ 3
 125+ E000              VK_V  					equ 4
 126+ E000              ; half row 2
 127+ E000              VK_A  					equ 5
 128+ E000              VK_S  					equ 6
 129+ E000              VK_D  					equ 7
 130+ E000              VK_F					equ 8
 131+ E000              VK_G  					equ 9
 132+ E000              ; half row 3
 133+ E000              VK_Q  					equ 10
 134+ E000              VK_W  					equ 11
 135+ E000              VK_E  					equ 12
 136+ E000              VK_R  					equ 13
 137+ E000              VK_T  					equ 14
 138+ E000              ; half row 4
 139+ E000              VK_1  					equ 15
 140+ E000              VK_2  					equ 16
 141+ E000              VK_3  					equ 17
 142+ E000              VK_4  					equ 18
 143+ E000              VK_5  					equ 19
 144+ E000              ; half row 5
 145+ E000              VK_0 					equ 20
 146+ E000              VK_9 					equ 21
 147+ E000              VK_8 					equ 22
 148+ E000              VK_7 					equ 23
 149+ E000              VK_6 					equ 24
 150+ E000              ; half row 6
 151+ E000              VK_P  					equ 25
 152+ E000              VK_O  					equ 26
 153+ E000              VK_I  					equ 27
 154+ E000              VK_U  					equ 28
 155+ E000              VK_Y  					equ 29
 156+ E000              ; half row 7
 157+ E000              VK_ENTER 				equ 30
 158+ E000              VK_L  					equ 31
 159+ E000              VK_K  					equ 32
 160+ E000              VK_J  					equ 33
 161+ E000              VK_H  					equ 34
 162+ E000              ; half row 8
 163+ E000              VK_SPACE 				equ 35
 164+ E000              VK_SYM  				equ 36
 165+ E000              VK_M  					equ 37
 166+ E000              VK_N  					equ 38
 167+ E000              VK_B  					equ 39
 168+ E000              ; Extended Group B0
 169+ E000              VK_SEMI                 equ 40
 170+ E000              VK_QUOTE                equ 41
 171+ E000              VK_COMMA                equ 42
 172+ E000              VK_STOP                 equ 43
 173+ E000              VK_UP                   equ 44
 174+ E000              VK_DOWN                 equ 45
 175+ E000              VK_LEFT                 equ 46
 176+ E000              VK_RIGHT                equ 47
 177+ E000              ; Extended Group B1
 178+ E000              VK_DELETE               equ 48
 179+ E000              VK_EDIT                 equ 49
 180+ E000              VK_BREAK                equ 50
 181+ E000              VK_INV_VID              equ 51
 182+ E000              VK_TRUE_VID             equ 52
 183+ E000              VK_GRAPH                equ 53
 184+ E000              VK_EXTCAPS              equ 54
 185+ E000              VK_EXTEND               equ 55
 186+ E000              ;KeyboardMapping
 187+ E000              KeyCode_Front        	equ VK_1
 188+ E000              KeyCode_Aft          	equ VK_2
 189+ E000              KeyCode_Left         	equ VK_3
 190+ E000              KeyCode_Right        	equ VK_4
 191+ E000              KeyCode_RollLeft     	equ VK_O
 192+ E000              KeyCode_RollRight    	equ VK_P
 193+ E000              KeyCode_Dive         	equ VK_Q
 194+ E000              KeyCode_Climb        	equ VK_A
 195+ E000              KeyCode_Accellerate  	equ VK_W
 196+ E000              KeyCode_Decellerate  	equ VK_S
 197+ E000              KeyCode_FireLaser    	equ VK_SPACE
 198+ E000              KeyCode_TargetMissle 	equ VK_T
 199+ E000              KeyCode_FireMissile  	equ VK_STOP
 200+ E000              KeyCode_Find        	equ VK_F
 201+ E000              KeyCode_UnarmMissile 	equ VK_R
 202+ E000              KeyCode_ECM          	equ VK_E
 203+ E000              KeyCode_EnergyBomb   	equ VK_U
 204+ E000              KeyCode_EscapePod    	equ VK_CAPS
 205+ E000              KeyCode_DockingComp  	equ VK_N
 206+ E000              KeyCode_Hyperspace   	equ VK_H
 207+ E000              KeyCode_Distance     	equ VK_J
 208+ E000              KeyCode_HomeCursor   	equ VK_G
 209+ E000              KeyCode_Launch       	equ VK_L
 210+ E000              KeyCode_BuyCargo     	equ VK_B
 211+ E000              KeyCode_SellCargo    	equ VK_V
 212+ E000              KeyCode_Equip        	equ VK_C
 213+ E000              KeyCode_GalacticChrt 	equ VK_5
 214+ E000              KeyCode_LocalChart   	equ VK_6
 215+ E000              KeyCode_MarketPrices 	equ VK_7
 216+ E000              KeyCode_Status       	equ VK_8
 217+ E000              KeyCode_Inventory    	equ VK_9
 218+ E000              KeyCode_GameSkip     	equ VK_Z
 219+ E000              KeyCode_Save         	equ VK_O
 220+ E000              KeyCode_Freeze       	equ VK_B
 221+ E000              KeyCode_Resume       	equ VK_L
 222+ E000              KeyCode_Recentre     	equ VK_STOP
 223+ E000              KeyCode_Quit         	equ VK_Y
 224+ E000              KeyCode_PlanetData   	equ VK_0
 225+ E000              KeyCode_CursorUp        equ VK_Q
 226+ E000              KeyCode_CursorDown      equ VK_A
 227+ E000              KeyCode_PressedYes      equ VK_Y
 228+ E000              KeyCode_PressedNo       equ VK_N
 229+ E000              KeyCode_Warp            equ VK_J
 230+ E000              KeyCode_ExtMarket       equ VK_SEMI
 231+ E000              KeyCode_ExtEquip        equ VK_QUOTE
 232+ E000              KeyCode_ExtPlanet       equ VK_COMMA
 233+ E000              KeyCode_ExtNearest      equ VK_STOP
 234+ E000              KeyCode_ExtCurUp        equ VK_UP
 235+ E000              KeyCode_ExtCurDown      equ VK_DOWN
 236+ E000              KeyCode_ExtCurLeft      equ VK_LEFT
 237+ E000              KeyCode_ExtCurRight     equ VK_RIGHT
 238+ E000              KeyCode_ExtDelete       equ VK_DELETE
 239+ E000              KeyCode_ExtFindSystem   equ VK_EDIT
 240+ E000              KeyCode_ExtEscapePod    equ VK_BREAK
 241+ E000              KeyCode_ExtInventory    equ VK_INV_VID
 242+ E000              KeyCode_ExtStatus       equ VK_TRUE_VID
 243+ E000              KeyCode_ExtGlactic      equ VK_GRAPH
 244+ E000              KeyCode_ExtLocal        equ VK_EXTCAPS
 245+ E000              KeyCode_ExtSystemJump   equ VK_EXTEND
 246+ E000
 247+ E000 00 00 00...  Keys					DS	55          ; This is the list of key states for all the VK keys presssed i.e. VK_CAPS through to VK_B
 248+ E037              c_KeyBoardLen 			equ $ - Keys
 249+ E037 00 00 00...  RawKeys					DS	10          ; increased for extended keys
 250+ E041 FE FD FB F7  KeyAddrTab				DB	$FE, $FD, $FB, $F7, $EF, $DF, $BF, $7F
 250+ E045 EF DF BF 7F
 251+ E049              ; Now keyboard map lists each game key and the corresponding address in the Keys table to get the value. This way redefining keys is just a case
 252+ E049              ; of updating this table with the respective location to look up
 253+ E049              ; key list sequence is in table above
 254+ E049 0F E0 10 E0  KeyboardMap             DW  Keys+KeyCode_Front        ,Keys+KeyCode_Aft          ,Keys+KeyCode_Left         ,Keys+KeyCode_Right        ,Keys+KeyCode_RollLeft
 254+ E04D 11 E0 12 E0
 254+ E051 1A E0
 255+ E053 19 E0 0A E0                          DW  Keys+KeyCode_RollRight    ,Keys+KeyCode_Dive         ,Keys+KeyCode_Climb        ,Keys+KeyCode_Accellerate  ,Keys+KeyCode_Decellerate
 255+ E057 05 E0 0B E0
 255+ E05B 06 E0
 256+ E05D 23 E0 0E E0                          DW  Keys+KeyCode_FireLaser    ,Keys+KeyCode_TargetMissle ,Keys+KeyCode_FireMissile  ,Keys+KeyCode_UnarmMissile ,Keys+KeyCode_ECM
 256+ E061 2B E0 0D E0
 256+ E065 0C E0
 257+ E067 1C E0 00 E0                          DW  Keys+KeyCode_EnergyBomb   ,Keys+KeyCode_EscapePod    ,Keys+KeyCode_DockingComp  ,Keys+KeyCode_Hyperspace   ,Keys+KeyCode_Distance
 257+ E06B 26 E0 22 E0
 257+ E06F 21 E0
 258+ E071 09 E0 1F E0                          DW  Keys+KeyCode_HomeCursor   ,Keys+KeyCode_Launch       ,Keys+KeyCode_BuyCargo     ,Keys+KeyCode_SellCargo    ,Keys+KeyCode_Equip
 258+ E075 27 E0 04 E0
 258+ E079 03 E0
 259+ E07B 13 E0 18 E0                          DW  Keys+KeyCode_GalacticChrt ,Keys+KeyCode_LocalChart   ,Keys+KeyCode_MarketPrices ,Keys+KeyCode_Status       ,Keys+KeyCode_Inventory
 259+ E07F 17 E0 16 E0
 259+ E083 15 E0
 260+ E085 01 E0 1A E0                          DW  Keys+KeyCode_GameSkip     ,Keys+KeyCode_Save         ,Keys+KeyCode_Freeze       ,Keys+KeyCode_Resume       ,Keys+KeyCode_Recentre
 260+ E089 27 E0 1F E0
 260+ E08D 2B E0
 261+ E08F 1D E0 14 E0                          DW  Keys+KeyCode_Quit         ,Keys+KeyCode_PlanetData   ,Keys+KeyCode_CursorUp     ,Keys+KeyCode_CursorDown   ,Keys+KeyCode_Find
 261+ E093 0A E0 05 E0
 261+ E097 08 E0
 262+ E099 1D E0 26 E0                          DW  Keys+KeyCode_PressedYes   ,Keys+KeyCode_PressedNo    ,Keys+KeyCode_Warp         ,Keys+KeyCode_ExtMarket    ,Keys+KeyCode_ExtEquip
 262+ E09D 21 E0 28 E0
 262+ E0A1 29 E0
 263+ E0A3 2A E0 2B E0                          DW  Keys+KeyCode_ExtPlanet    ,Keys+KeyCode_ExtNearest   ,Keys+KeyCode_ExtCurUp     ,Keys+KeyCode_ExtCurDown   ,Keys+KeyCode_ExtCurLeft
 263+ E0A7 2C E0 2D E0
 263+ E0AB 2E E0
 264+ E0AD 2F E0 30 E0                          DW  Keys+KeyCode_ExtCurRight  ,Keys+KeyCode_ExtDelete    ,Keys+KeyCode_ExtFindSystem,Keys+KeyCode_ExtEscapePod ,Keys+KeyCode_ExtInventory
 264+ E0B1 31 E0 32 E0
 264+ E0B5 33 E0
 265+ E0B7 34 E0 35 E0                          DW  Keys+KeyCode_ExtStatus    ,Keys+KeyCode_ExtGlactic   ,Keys+KeyCode_ExtLocal     ,Keys+KeyCode_ExtSystemJump
 265+ E0BB 36 E0 37 E0
 266+ E0BF
 267+ E0BF
 268+ E0BF 3F 5A 58 43  ASCII_Map:              DB "?","Z","X","C","V"
 268+ E0C3 56
 269+ E0C4 41 53 44 46                          DB "A","S","D","F","G"
 269+ E0C8 47
 270+ E0C9 51 57 45 52                          DB "Q","W","E","R","T"
 270+ E0CD 54
 271+ E0CE 31 32 33 34                          DB "1","2","3","4","5"
 271+ E0D2 35
 272+ E0D3 30 39 38 37                          DB "0","9","8","7","6"
 272+ E0D7 36
 273+ E0D8 50 4F 49 55                          DB "P","O","I","U","Y"
 273+ E0DC 59
 274+ E0DD 3E 4C 4B 4A                          DB ">","L","K","J","H"
 274+ E0E1 48
 275+ E0E2 20 5E 4D 4E                          DB " ","^","M","N","B"
 275+ E0E6 42
 276+ E0E7 3B 22 2C 2E                          DB ";",'"',",",".","^","v","[","]"  ; Extended keys register 0 semicolon, quote, comman, fullstop, up, down, left, right
 276+ E0EB 5E 76 5B 5D
 277+ E0EF 23 65 62 69                          DB "#","e","b","i","t","g","c","x"  ; Extended keys register 1 delete, edit, break, inv video, true video graph, caps, extend
 277+ E0F3 74 67 63 78
 278+ E0F7              ; mapping of a code to the lookup table Keyboard map. So if you are using an addr_Pressed you can then fetch from KeyboardMap the address in Keys
 279+ E0F7              ; for the raw key press status
 280+ E0F7              addr_Pressed_Front         equ KeyboardMap+c_Pressed_Front
 281+ E0F7              addr_Pressed_Aft           equ KeyboardMap+c_Pressed_Aft
 282+ E0F7              addr_Pressed_Left          equ KeyboardMap+c_Pressed_Left
 283+ E0F7              addr_Pressed_Right         equ KeyboardMap+c_Pressed_Right
 284+ E0F7              addr_Pressed_RollLeft      equ KeyboardMap+c_Pressed_RollLeft
 285+ E0F7              addr_Pressed_RollRight     equ KeyboardMap+c_Pressed_RollRight
 286+ E0F7              addr_Pressed_Dive          equ KeyboardMap+c_Pressed_Dive
 287+ E0F7              addr_Pressed_Climb         equ KeyboardMap+c_Pressed_Climb
 288+ E0F7              addr_Pressed_Accellerate   equ KeyboardMap+c_Pressed_Accellerate
 289+ E0F7              addr_Pressed_Decellerate   equ KeyboardMap+c_Pressed_Decellerate
 290+ E0F7              addr_Pressed_FireLaser     equ KeyboardMap+c_Pressed_FireLaser
 291+ E0F7              addr_Pressed_TargetMissle  equ KeyboardMap+c_Pressed_TargetMissle
 292+ E0F7              addr_Pressed_FireMissile   equ KeyboardMap+c_Pressed_FireMissile
 293+ E0F7              addr_Pressed_UnarmMissile  equ KeyboardMap+c_Pressed_UnarmMissile
 294+ E0F7              addr_Pressed_ECM           equ KeyboardMap+c_Pressed_ECM
 295+ E0F7              addr_Pressed_EnergyBomb    equ KeyboardMap+c_Pressed_EnergyBomb
 296+ E0F7              addr_Pressed_EscapePod     equ KeyboardMap+c_Pressed_EscapePod
 297+ E0F7              addr_Pressed_DockingComp   equ KeyboardMap+c_Pressed_DockingComp
 298+ E0F7              addr_Pressed_Hyperspace    equ KeyboardMap+c_Pressed_Hyperspace
 299+ E0F7              addr_Pressed_Distance      equ KeyboardMap+c_Pressed_Distance
 300+ E0F7              addr_Pressed_HomeCursor    equ KeyboardMap+c_Pressed_HomeCursor
 301+ E0F7              addr_Pressed_Launch        equ KeyboardMap+c_Pressed_Launch
 302+ E0F7              addr_Pressed_BuyCargo      equ KeyboardMap+c_Pressed_BuyCargo
 303+ E0F7              addr_Pressed_SellCargo     equ KeyboardMap+c_Pressed_SellCargo
 304+ E0F7              addr_Pressed_Equip         equ KeyboardMap+c_Pressed_Equip
 305+ E0F7              addr_Pressed_GalacticChrt  equ KeyboardMap+c_Pressed_GalacticChrt
 306+ E0F7              addr_Pressed_LocalChart    equ KeyboardMap+c_Pressed_LocalChart
 307+ E0F7              addr_Pressed_MarketPrices  equ KeyboardMap+c_Pressed_MarketPrices
 308+ E0F7              addr_Pressed_Status        equ KeyboardMap+c_Pressed_Status
 309+ E0F7              addr_Pressed_Inventory     equ KeyboardMap+c_Pressed_Inventory
 310+ E0F7              addr_Pressed_GameSkip      equ KeyboardMap+c_Pressed_GameSkip
 311+ E0F7              addr_Pressed_Save          equ KeyboardMap+c_Pressed_Save
 312+ E0F7              addr_Pressed_Freeze        equ KeyboardMap+c_Pressed_Freeze
 313+ E0F7              addr_Pressed_Resume        equ KeyboardMap+c_Pressed_Resume
 314+ E0F7              addr_Pressed_Recentre      equ KeyboardMap+c_Pressed_Recentre
 315+ E0F7              addr_Pressed_Quit          equ KeyboardMap+c_Pressed_Quit
 316+ E0F7              addr_Pressed_PlanetData    equ KeyboardMap+c_Pressed_PlanetData
 317+ E0F7              addr_Pressed_CursorUp      equ KeyboardMap+c_Pressed_CursorUp
 318+ E0F7              addr_Pressed_CursorDown    equ KeyboardMap+c_Pressed_CursorDown
 319+ E0F7              addr_Pressed_Find          equ KeyboardMap+c_Pressed_Find
 320+ E0F7              addr_Pressed_Warp          equ KeyboardMap+c_Pressed_Warp
 321+ E0F7
 322+ E0F7
 323+ E0F7              MIsKeyPressed:          MACRO   keyaddress, misstarget
 324+ E0F7 ~                                    MMUSelectKeyboard
 325+ E0F7 ~                                    ld      hl,(keyaddress)
 326+ E0F7 ~                                    ld      a,(hl)
 327+ E0F7 ~                                    JumpIfAIsZero   misstarget
 328+ E0F7                                      ENDM
 329+ E0F7
 330+ E0F7
 331+ E0F7 21 00 E0     init_keyboard:          ld		hl,Keys                         ; no key s are pressed by default
 332+ E0FA 11 37 00                             ld		de, c_KeyBoardLen               ;
 333+ E0FD 3E 00                                ld		a,0                             ;
 334+ E0FF CD F0 67                             call	memfill_dma                     ;
 335+ E102 C9                                   ret                                     ;
 336+ E103
 337+ E103
 338+ E103
 339+ E103 DD 21 37 E0  scan_keyboard:          ld		ix,RawKeys                      ; hl = table of raw IO port readings
 340+ E107 21 41 E0                             ld		hl,KeyAddrTab                   ; de = table of IO ports to read
 341+ E10A 0E 08                                ld		c,8                             ; 8 ports to ready
 342+ E10C 11 00 E0                             ld      de,Keys                         ; ix = table of key states from raw read
 343+ E10F 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
 344+ E110 DB FE                                in		a,($FE)							; read port to a
 345+ E112 DD 77 00                             ld      (ix+0),a                        ; save raw scan
 346+ E115 DD 23                                inc     ix
 347+ E117 23                                   inc		hl                              ; and ready for next read
 348+ E118 06 05        .ProcessInputBits:      ld		b,5								; loop all bits (there are only 5 keys to a group)
 349+ E11A 1F           .ProcessBitsLoop:       rra                                     ; shit bit 0 into carry
 350+ E11B 30 08                                jr      nc,.SetKeyPressed               ; low bit means it was pressed
 351+ E11D FD 6F                                ld      iyl,a
 352+ E11F                                      ZeroA
 352+ E11F AF          >                        xor a
 353+ E120 C3 2D E1                             jp      .SetKey
 354+ E123 20 0B                                jr		nz,.SkipKeySet
 355+ E125 FD 6F        .SetKeyPressed:	        ld      iyl,a                           ; save current input byte
 356+ E127 1A                                   ld      a,(de)                          ; get current keystate
 357+ E128 FE 02                                cp      2
 358+ E12A 28 02                                jr      z,.AlreadyHeld
 359+ E12C 3C                                   inc     a                               ; and increment by 1 as its moved from previous state
 360+ E12D 12           .SetKey:                ld		(de),a				  	        ; save key Pressed state
 361+ E12E FD 7D        .AlreadyHeld:           ld      a,iyl                           ; and retrieve the current input byte
 362+ E130 13           .SkipKeySet:	        inc		de								; move to next key
 363+ E131 10 E7                                djnz	.ProcessBitsLoop				; Process all key group bits
 364+ E133 0D                                   dec     c                               ; thats one row of bits all processed
 365+ E134 20 D9                                jr      nz,.PortReadLoop				; Read next input port
 366+ E136              .ReadExtend0:           GetNextReg EXTENDED_KEYS_0_REGISTER
 366+ E136 01 3B 24    >            ld bc,$243B
 366+ E139 3E B0       >            ld a,EXTENDED_KEYS_0_REGISTER
 366+ E13B ED 79       >            out (c),a
 366+ E13D 04          >            inc b
 366+ E13E ED 78       >            in a,(c)
 367+ E140 32 3F E0                             ld      (RawKeys+8),a                   ; save to extended slot
 368+ E143 06 08                                ld      b,8
 369+ E145 21 28 E0                             ld      hl,Keys + VK_SEMI
 370+ E148 17           .ProcessExtend0:        rla                                     ; shift bits left into carry for extended keys
 371+ E149 30 04                                jr      nc,.SetExtend0KeyPressed
 372+ E14B              .Extend0NotPressed:     ZeroA
 372+ E14B AF          >                        xor a
 373+ E14C C3 55 E1                             jp      .SetExtend0Key
 374+ E14F 7E           .SetExtend0KeyPressed:  ld      a,(hl)
 375+ E150 FE 02                                cp      2
 376+ E152 28 02                                jr      z,.Extend0AlreadyHeld
 377+ E154 3C                                   inc     a
 378+ E155 77           .SetExtend0Key:         ld      (hl),a
 379+ E156 23           .Extend0AlreadyHeld:    inc     hl
 380+ E157 10 EF                                djnz    .ProcessExtend0
 381+ E159              .ReadExtend1:           GetNextReg EXTENDED_KEYS_1_REGISTER
 381+ E159 01 3B 24    >            ld bc,$243B
 381+ E15C 3E B1       >            ld a,EXTENDED_KEYS_1_REGISTER
 381+ E15E ED 79       >            out (c),a
 381+ E160 04          >            inc b
 381+ E161 ED 78       >            in a,(c)
 382+ E163 32 40 E0                             ld      (RawKeys+9),a                      ; save to extended slot
 383+ E166 06 08                                ld      b,8
 384+ E168 21 30 E0                             ld      hl,Keys + VK_DELETE
 385+ E16B 17           .ProcessExtend1:        rla                                     ; shift bits left into carry for extended keys
 386+ E16C 30 04                                jr      nc,.SetExtend1KeyPressed
 387+ E16E              .Extend1NotPressed:     ZeroA
 387+ E16E AF          >                        xor a
 388+ E16F C3 78 E1                             jp      .SetExtend1Key
 389+ E172 7E           .SetExtend1KeyPressed:  ld      a,(hl)
 390+ E173 FE 02                                cp      2
 391+ E175 28 02                                jr      z,.Extend1AlreadyHeld
 392+ E177 3C                                   inc     a
 393+ E178 77           .SetExtend1Key:         ld      (hl),a
 394+ E179 23           .Extend1AlreadyHeld:    inc     hl
 395+ E17A 10 EF                                djnz    .ProcessExtend1
 396+ E17C C9                                   ret
 397+ E17D
 398+ E17D
 399+ E17D
 400+ E17D              GetKeyStateAddressDE:   MACRO
 401+ E17D ~                                    ld      hl,KeyboardMap                  ; work our address to read from
 402+ E17D ~                                    add     hl,a
 403+ E17D ~                                    ld      e,(hl)
 404+ E17D ~                                    inc     hl
 405+ E17D ~                                    ld      d,(hl)                          ; now de = address in keypress list
 406+ E17D                                      ENDM
 407+ E17D
 408+ E17D              GetKeyStateAddressHL:   MACRO
 409+ E17D ~                                    ld      hl,KeyboardMap                  ; work our address to read from
 410+ E17D ~                                    add     hl,a
 411+ E17D ~                                    ld      a,(hl)
 412+ E17D ~                                    inc     hl
 413+ E17D ~                                    ld      h,(hl)                          ; now hl = address in keypress list
 414+ E17D ~                                    ld      l,a
 415+ E17D                                      ENDM
 416+ E17D
 417+ E17D
 418+ E17D              ;;old debug codeCurrentX            DB 0
 419+ E17D              ;;old debug codeCurrentY            DB 0
 420+ E17D              ;;old debug code
 421+ E17D              ;;old debug codedisplayKeyStatus:       xor         a
 422+ E17D              ;;old debug code                        ld          (CurrentX),a
 423+ E17D              ;;old debug code                        ld          hl,RawKeys
 424+ E17D              ;;old debug code                        ld          a,(hl)
 425+ E17D              ;;old debug code                        and         %00011111
 426+ E17D              ;;old debug code                        ld          b,5
 427+ E17D              ;;old debug code.displayLoop:           push        bc,,hl
 428+ E17D              ;;old debug code                        rra
 429+ E17D              ;;old debug code                        jr          c,.displayNoPress
 430+ E17D              ;;old debug code.displayPress:          push        af
 431+ E17D              ;;old debug code                        ld          a,(CurrentX)
 432+ E17D              ;;old debug code                        ld          e,a
 433+ E17D              ;;old debug code                        ld          a,(CurrentY)
 434+ E17D              ;;old debug code                        ld          d,a
 435+ E17D              ;;old debug code                        ld          a,'*'
 436+ E17D              ;;old debug code                        MMUSelectLayer1
 437+ E17D              ;;old debug code                        call        l1_print_char
 438+ E17D              ;;old debug code                        ld          a,(CurrentX)
 439+ E17D              ;;old debug code                        add         a,8
 440+ E17D              ;;old debug code                        ld          (CurrentX),a
 441+ E17D              ;;old debug code                        pop         af
 442+ E17D              ;;old debug code                        pop         bc,,hl
 443+ E17D              ;;old debug code                        djnz        .displayLoop
 444+ E17D              ;;old debug code                        ret
 445+ E17D              ;;old debug code.displayNoPress:        push        af
 446+ E17D              ;;old debug code                        ld          a,(CurrentX)
 447+ E17D              ;;old debug code                        ld          e,a
 448+ E17D              ;;old debug code                        ld          a,(CurrentY)
 449+ E17D              ;;old debug code                        ld          d,a
 450+ E17D              ;;old debug code                        ld          a,'O'
 451+ E17D              ;;old debug code                        MMUSelectLayer1
 452+ E17D              ;;old debug code                        call        l1_print_char
 453+ E17D              ;;old debug code                        ld          a,(CurrentX)
 454+ E17D              ;;old debug code                        add         a,8
 455+ E17D              ;;old debug code                        ld          (CurrentX),a
 456+ E17D              ;;old debug code                        pop         af
 457+ E17D              ;;old debug code                        pop         bc,,hl
 458+ E17D              ;;old debug code                        djnz        .displayLoop
 459+ E17D              ;;old debug code                        ret
 460+ E17D              ;;old debug code
 461+ E17D              ;;old debug codedisplayDownStatus:      ld  a,(Keys+      KeyCode_CursorUp)
 462+ E17D              ;;old debug code                        cp  0
 463+ E17D              ;;old debug code                        jr      z,.displayNoUp
 464+ E17D              ;;old debug code                        cp  1
 465+ E17D              ;;old debug code                        jr      z,.displayUp
 466+ E17D              ;;old debug code.displayHeld:           ld      de,8*15
 467+ E17D              ;;old debug code                        ld      a,"*"
 468+ E17D              ;;old debug code                        MMUSelectLayer1
 469+ E17D              ;;old debug code                        call        l1_print_char
 470+ E17D              ;;old debug code                        ret
 471+ E17D              ;;old debug code.displayUp:             ld      de,8*15
 472+ E17D              ;;old debug code                        ld      a,"+"
 473+ E17D              ;;old debug code                        MMUSelectLayer1
 474+ E17D              ;;old debug code                        call        l1_print_char
 475+ E17D              ;;old debug code                        ret
 476+ E17D              ;;old debug code.displayNoUp:             ld      de,8*15
 477+ E17D              ;;old debug code                        ld      a,"O"
 478+ E17D              ;;old debug code                        MMUSelectLayer1
 479+ E17D              ;;old debug code                        call        l1_print_char
 480+ E17D              ;;old debug code                        ret
 481+ E17D              ;;old debug code
 482+ E17D
 483+ E17D
 484+ E17D              ; call with a = c_Pressed key, will then read mapping does this with keyboard scan, waits until key gets to state 1, if it was already held then#
 485+ E17D              ; it will have to be let go to reset of 0 and scan again
 486+ E17D              ; Deprecated as not used as yet
 487+ E17D              ;;;;;;wait_for_key_a_press:   GetKeyStateAddressHL
 488+ E17D              ;;;;;;                        push    hl
 489+ E17D              ;;;;;;.wait_loop:             call    scan_keyboard
 490+ E17D              ;;;;;;                        pop     hl                              ; get key address into hl
 491+ E17D              ;;;;;;                        push    hl
 492+ E17D              ;;;;;;                        ld      a,(hl)
 493+ E17D              ;;;;;;                        JumpIfANENusng  1,.wait_loop             ; will also loop if held down when entering this routine
 494+ E17D              ;;;;;;                        pop     hl                              ; tidy up rogue push, less t states than detecting if we want to push or not
 495+ E17D              ;;;;;;                        ret
 496+ E17D              ;;;;;;; call with a = c_Pressed key, will then read mapping does this with keyboard scan waits until key gets to state 2
 497+ E17D              ;;;;;;wait_for_key_a_held:    GetKeyStateAddressDE
 498+ E17D              ;;;;;;                        push    hl
 499+ E17D              ;;;;;;.wait_loop:             call    scan_keyboard
 500+ E17D              ;;;;;;                        pop     hl
 501+ E17D              ;;;;;;                        push    hl
 502+ E17D              ;;;;;;                        ld      a,(hl)
 503+ E17D              ;;;;;;                        JumpIfALTNusng  2, .wait_loop
 504+ E17D              ;;;;;;                        pop     hl
 505+ E17D              ;;;;;;                        ret
 506+ E17D
 507+ E17D              ; Gets the current keystate of the c_Pressed Key in a register
 508+ E17D 21 00 E0     get_vkey_a_state:       ld      hl,Keys
 509+ E180 ED 31                                add     hl,a
 510+ E182 7E                                   ld      a,(hl)
 511+ E183 C9                                   ret
 512+ E184
 513+ E184 21 00 E0     is_vkey_held:           ld      hl,Keys
 514+ E187 ED 31                                add     hl,a
 515+ E189 7E                                   ld      a,(hl)
 516+ E18A E6 02                                and     Bit1Only
 517+ E18C C9                                   ret
 518+ E18D
 519+ E18D 21 00 E0     is_vkey_pressed:        ld      hl,Keys
 520+ E190 ED 31                                add     hl,a
 521+ E192 7E                                   ld      a,(hl)
 522+ E193 FE 01                                cp      1
 523+ E195 C9                                   ret
 524+ E196
 525+ E196              get_key_a_state:        GetKeyStateAddressHL                    ; reads a mapped key and sets a to key staus, e.g. 0 1 or >=2 DOES NOT SCAN KEYBOARD
 525+ E196 21 49 E0    >                        ld      hl,KeyboardMap                  ; work our address to read from
 525+ E199 ED 31       >                        add     hl,a
 525+ E19B 7E          >                        ld      a,(hl)
 525+ E19C 23          >                        inc     hl
 525+ E19D 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 525+ E19E 6F          >                        ld      l,a
 526+ E19F 7E                                   ld      a,(hl)                          ; a = keystate
 527+ E1A0 C9                                   ret
 528+ E1A1
 529+ E1A1              ; sets they keystate of c pressed key in a register to 1 (pressed)
 530+ E1A1              ; This will be used by auto dock
 531+ E1A1              force_key_press:        GetKeyStateAddressHL                    ; read key locations
 531+ E1A1 21 49 E0    >                        ld      hl,KeyboardMap                  ; work our address to read from
 531+ E1A4 ED 31       >                        add     hl,a
 531+ E1A6 7E          >                        ld      a,(hl)
 531+ E1A7 23          >                        inc     hl
 531+ E1A8 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 531+ E1A9 6F          >                        ld      l,a
 532+ E1AA 3E 01                                ld      a,1
 533+ E1AC 77                                   ld      (hl),a
 534+ E1AD C9                                   ret
 535+ E1AE
 536+ E1AE              is_key_up_state:        GetKeyStateAddressHL
 536+ E1AE 21 49 E0    >                        ld      hl,KeyboardMap                  ; work our address to read from
 536+ E1B1 ED 31       >                        add     hl,a
 536+ E1B3 7E          >                        ld      a,(hl)
 536+ E1B4 23          >                        inc     hl
 536+ E1B5 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 536+ E1B6 6F          >                        ld      l,a
 537+ E1B7 7E                                   ld      a,(hl)
 538+ E1B8 FE 00                                cp      0
 539+ E1BA C9                                   ret
 540+ E1BB
 541+ E1BB              ; returns z is set if c_ key is pressed
 542+ E1BB              is_key_pressed:         GetKeyStateAddressHL
 542+ E1BB 21 49 E0    >                        ld      hl,KeyboardMap                  ; work our address to read from
 542+ E1BE ED 31       >                        add     hl,a
 542+ E1C0 7E          >                        ld      a,(hl)
 542+ E1C1 23          >                        inc     hl
 542+ E1C2 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 542+ E1C3 6F          >                        ld      l,a
 543+ E1C4 7E                                   ld      a,(hl)                          ; a = keystate
 544+ E1C5 FE 01                                cp      1                               ; we cant just test bit 0 as this may have been held long
 545+ E1C7 C9                                   ret
 546+ E1C8
 547+ E1C8              ; returns nz is set if c_ key is held, if key was held then keystate would be 2 or 3, i.e. bit 1 set
 548+ E1C8              is_key_held:            GetKeyStateAddressHL
 548+ E1C8 21 49 E0    >                        ld      hl,KeyboardMap                  ; work our address to read from
 548+ E1CB ED 31       >                        add     hl,a
 548+ E1CD 7E          >                        ld      a,(hl)
 548+ E1CE 23          >                        inc     hl
 548+ E1CF 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 548+ E1D0 6F          >                        ld      l,a
 549+ E1D1 7E                                   ld      a,(hl)                          ; a = keystate
 550+ E1D2 E6 02                                and     Bit1Only                        ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
 551+ E1D4 C9                                   ret
 552+ E1D5
 553+ E1D5              ; checks to see if any key is pressed in the key table
 554+ E1D5 21 00 E0     is_any_key_pressed:     ld      hl,Keys
 555+ E1D8 01 28 00                             ld      bc,40
 556+ E1DB 3E 01                                ld      a,1
 557+ E1DD ED B1                                cpir                                    ; search for the value 1
 558+ E1DF 28 03                                jr      z,.KeyPressed                   ; if a key was pressed then handle press
 559+ E1E1                                      SetAFalse
 559+ E1E1 3E FF       >                        ld      a,$FF
 560+ E1E3 C9                                   ret
 561+ E1E4 3E 27        .KeyPressed:            ld      a,39                            ; so c will be how many keys still to scan
 562+ E1E6 91                                   sub     c                               ; so a = 40 - c to get to result
 563+ E1E7 C9                                   ret
 564+ E1E8
 565+ E1E8 21 00 E0     is_any_key_held:        ld      hl,Keys
 566+ E1EB 06 28                                ld      b,40
 567+ E1ED 0E 00                                ld      c,0
 568+ E1EF 7E           .KeyReadLoop:           ld      a,(hl)
 569+ E1F0 E6 02                                and     Bit1Only                        ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
 570+ E1F2 C2 FC E1                             jp      nz,.KeyPressed
 571+ E1F5 23                                   inc     hl
 572+ E1F6 0C                                   inc     c
 573+ E1F7 10 F6                                djnz    .KeyReadLoop
 574+ E1F9                                      SetAFalse
 574+ E1F9 3E FF       >                        ld      a,$FF
 575+ E1FB C9                                   ret
 576+ E1FC 79           .KeyPressed:            ld      a,c
 577+ E1FD C9                                   ret
 578+ E1FE
 579+ E1FE
 580+ E1FE 21 41 E0     WaitForNoKey:           ld      hl,KeyAddrTab                   ; de = table of IO ports to read
 581+ E201 06 08                                ld		b,8                             ; 8 ports to ready
 582+ E203 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
 583+ E204 DB FE                                in		a,($FE)							; read port to a
 584+ E206 E6 1F                                and     %00011111
 585+ E208 FE 1F                                cp      %00011111
 586+ E20A 20 F2                                jr      nz ,WaitForNoKey
 587+ E20C 23                                   inc		hl                              ; and ready for next read
 588+ E20D 10 F4                                djnz    .PortReadLoop
 589+ E20F C9                                   ret
 590+ E210
 591+ E210 F5 D5 C5 E5  WaitForAnyKey:          push    af,,de,,bc,,hl
 592+ E214 CD FE E1                             call    WaitForNoKey
 593+ E217 21 41 E0     .waitKeyLoop:           ld		hl,KeyAddrTab                   ; de = table of IO ports to read
 594+ E21A 06 08                                ld		b,8                             ; 8 ports to ready
 595+ E21C 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
 596+ E21D DB FE                                in		a,($FE)							; read port to a
 597+ E21F E6 1F                                and     %00011111
 598+ E221 FE 1F                                cp      %00011111
 599+ E223 C2 2D E2                             jp      nz,.WaitComplete
 600+ E226 C0                                   ret     nz
 601+ E227 23                                   inc		hl                              ; and ready for next read
 602+ E228 10 F2                                djnz    .PortReadLoop
 603+ E22A C3 17 E2                             jp      .waitKeyLoop
 604+ E22D E1 C1 D1 F1  .WaitComplete:          pop     af,,de,,bc,,hl
 605+ E231 C9                                   ret
 606+ E232
 607+ E232
 608+ E232 00 00 00...  InputString             DS  30              ; used for a 30 character input buffer
 609+ E250 00                                   DB  0               ; end of string marker as a safety
 610+ E251 00           InputLength             DB  0               ; Current String length
 611+ E252 00           InputCursor             DB  0               ; Current Cursor Position
 612+ E253 00           EnterPressed            DB  0               ; zero notpressed FF pressed
 613+ E254 00           InputChanged            DB  0
 614+ E255 00           InsertMode              DB  0
 615+ E256              InputLimit              EQU 20
 616+ E256
 617+ E256 21 32 E2     keyboard_copy_input_to_de:  ld      hl,InputString
 618+ E259 3A 52 E2                                 ld      a,(InputCursor)
 619+ E25C FE 00                                    cp      0
 620+ E25E 28 05                                    jr      z,.NoString
 621+ E260 4F                                       ld      c,a
 622+ E261 06 00                                    ld      b,0
 623+ E263 ED B0                                    ldir
 624+ E265 3E 00        .NoString                   ld      a,0
 625+ E267 12                                       ld      (de),a
 626+ E268 C9                                       ret
 627+ E269
 628+ E269               ;Input routine logic
 629+ E269               ;Intialise input state
 630+ E269
 631+ E269              ; Scans the key pressed to determine if its an alpha, returns ascii code or 0 if not alpha
 632+ E269              ; Input a = key pressed, returns with carry set if no alpha else carry is clear
 633+ E269              isKeyAlpha:             JumpIfALTNusng  "A",   .NotAlpha
 633+ E269 FE 41       >                        cp      "A"
 633+ E26B DA 75 E2    >                        jp		c, .NotAlpha
 634+ E26E                                      JumpIfAGTENusng "Z"+1, .NotAlpha
 634+ E26E FE 5B       >                        cp     "Z"+1
 634+ E270 D2 75 E2    >                        jp		nc,.NotAlpha
 635+ E273                                      ClearCarryFlag
 635+ E273 B7          >                        or a
 636+ E274 C9                                   ret
 637+ E275              .NotAlpha               SetCarryFlag
 637+ E275 37          >                        scf
 638+ E276 C9                                   ret
 639+ E277
 640+ E277 3A 52 E2     InsertKeystroke:        ld      a,(InputCursor)                         ; Current Cursor position
 641+ E27A FE 1E                                cp      30                                      ; protect from buffer overflow
 642+ E27C C8                                   ret     z                                       ; .
 643+ E27D 21 32 E2                             ld      hl,InputString                          ; position hl to position in input string
 644+ E280 ED 31                                add     hl,a                                    ; .
 645+ E282 E5                                   push    hl                                      ; save current cursor position
 646+ E283 47                                   ld      b,a                                     ; as a quick optimisation
 647+ E284                                      JumpIfMemFalse InsertMode, .NoCopyNeeded        ; if we are in overtype mode skip copy
 647+ E284 3A 55 E2    >                        ld      a,(InsertMode)
 647+ E287 A7          >                        and     a
 647+ E288 C2 A8 E2    >                        jp      nz, .NoCopyNeeded
 648+ E28B 3A 51 E2                             ld      a,(InputLength)                         ; no need to shuffle string
 649+ E28E B8                                   cp      b                                       ; if we are at the end already
 650+ E28F 78                                   ld      a,b                                     ; .
 651+ E290 CA A8 E2                             jp      z,.NoCopyNeeded                         ; so we can behave like overtype mode
 652+ E293 11 4F E2                             ld      de,InputString+29                       ; now from the end of the string
 653+ E296 21 4E E2                             ld      hl,InputString+28                       ; .
 654+ E299 06 1D                                ld      b,29                                    ; for up to 29 characters
 655+ E29B 4F                                   ld      c,a                                     ; back to the current cursor position
 656+ E29C C5           .CopyLoop:              push    bc                                      ; save current position
 657+ E29D 7E                                   ld      a,(hl)                                  ; now suffle from left char to right char
 658+ E29E 12                                   ld      (de),a                                  ; .
 659+ E29F 2B                                   dec     hl                                      ; moving back one byte at a time
 660+ E2A0 1B                                   dec     de                                      ;
 661+ E2A1 05                                   dec     b                                       ; and reducing the current copy position
 662+ E2A2 79                                   ld      a,c                                     ; have we reached the input cursor pos
 663+ E2A3 B8                                   cp      b                                       ;
 664+ E2A4 C1                                   pop     bc
 665+ E2A5 C2 9C E2                             jp      nz,.CopyLoop
 666+ E2A8 E1           .NoCopyNeeded:          pop     hl
 667+ E2A9 3A B4 E2                             ld      a,(LastKeyPressed)
 668+ E2AC 77                                   ld      (hl),a
 669+ E2AD 21 51 E2                             ld      hl,InputLength
 670+ E2B0 34                                   inc     (hl)
 671+ E2B1 23                                   inc     hl                                      ;  to input cursor as a short cut to logic
 672+ E2B2 34                                   inc     (hl)
 673+ E2B3 C9                                   ret
 674+ E2B4
 675+ E2B4
 676+ E2B4              ; We won't have any auto repeat on input
 677+ E2B4 00           LastKeyPressed:         db 0
 678+ E2B5
 679+ E2B5              initInputText:          ZeroA
 679+ E2B5 AF          >                        xor a
 680+ E2B6 32 52 E2                             ld      (InputCursor),a
 681+ E2B9 32 B4 E2                             ld      (LastKeyPressed),a
 682+ E2BC 32 51 E2                             ld      (InputLength),a
 683+ E2BF                                      SetMemTrue  InsertMode
 683+ E2BF AF          >                        xor     a
 683+ E2C0 32 55 E2    >                        ld      (InsertMode),a
 684+ E2C3                                      SetMemFalse EnterPressed
 684+ E2C3 3E FF       >                        ld      a,$FF
 684+ E2C5 32 53 E2    >                        ld      (EnterPressed),a
 685+ E2C8                                      SetMemFalse InputChanged
 685+ E2C8 3E FF       >                        ld      a,$FF
 685+ E2CA 32 54 E2    >                        ld      (InputChanged),a
 686+ E2CD 21 32 E2                             ld      hl,InputString
 687+ E2D0 06 1E                                ld      b,30
 688+ E2D2 77           .wipeloop:              ld      (hl),a
 689+ E2D3 23                                   inc     hl
 690+ E2D4 10 FC                                djnz    .wipeloop
 691+ E2D6 C9                                   ret
 692+ E2D7
 693+ E2D7              ;;;InputNameV2:            call    is_any_key_pressed              ; scan for key states
 694+ E2D7              ;;;                        cp      $FF                             ; no key means we reset auto repeat
 695+ E2D7              ;;;                        jp      z,.NoKeyPressed                 ;
 696+ E2D7              ;;;.IsItLastKeyHeld:       ld      hl,LastKeyPressed               ; is it the same key as before
 697+ E2D7              ;;;                        cp      (hl)                            ;
 698+ E2D7              ;;;                        ret     z                               ; if so just ignore it to avoid auto repeat
 699+ E2D7              ;;;.SetNewAntiRepeat:      ld      (LastKeyPressed),a
 700+ E2D7              ;;;.CheckKeyPressed:       call    isKeyAlpha
 701+ E2D7              ;;;                        jp      nc,.AlphaKeyPressed
 702+ E2D7              ;;;.CheckSpaceKeyPressed:  cp      " "
 703+ E2D7              ;;;                        jp      z,.SpacePressed
 704+ E2D7              ;;;.CheckEnterPressed:     cp      ">"
 705+ E2D7              ;;;                        jp      z,.EnterPressed
 706+ E2D7              ;;;.CheckLeftPressed:      cp      "["
 707+ E2D7              ;;;                        jp      z,.LeftPressed
 708+ E2D7              ;;;.CheckRightPressed:     cp      "]"
 709+ E2D7              ;;;                        jp      z,.RightPressed
 710+ E2D7              ;;;.CheckDeletePressed:    cp      "#"
 711+ E2D7              ;;;                        jp      z,.DeletePressed
 712+ E2D7              ;;;.AnyOtherKeyIsIgnored:  ret
 713+ E2D7              ;;;.AlphaKeyPressed:       ld      a,(InputLength)
 714+ E2D7              ;;;                        JumpIfAGTENusng 30,.MaxInputReached
 715+ E2D7              ;;;.InsertKey:             call    InsertKeystroke
 716+ E2D7              ;;;                        ret
 717+ E2D7              ;;;.SpacePressed:          call    InsertKeystroke
 718+ E2D7              ;;;                        ret
 719+ E2D7              ;;;.EnterPressed:
 720+ E2D7              ;;;
 721+ E2D7              ;;;.LeftPressed:           ld      a,(InputCusor)
 722+ E2D7              ;;;                        JumpIfAIsZero, .MaxInputReached
 723+ E2D7              ;;;                        dec     a
 724+ E2D7              ;;;                        ld      (InputCursor),a
 725+ E2D7              ;;;                        ret
 726+ E2D7              ;;;.RightPressed:          ld      a,(InputLength)
 727+ E2D7              ;;;                        inc     a
 728+ E2D7              ;;;                        ld      b,a
 729+ E2D7              ;;;                        ld      a,(InputCursor)
 730+ E2D7              ;;;                        JumpIfMemGTENusng b, .MaxInputReached
 731+ E2D7              ;;;                        inc     a
 732+ E2D7              ;;;                        ld      (InputCursor),a
 733+ E2D7              ;;;                        ret
 734+ E2D7              ;;;.DeletaPressed:         ld      a,(InputCusor)
 735+ E2D7              ;;;                        ld      c,a
 736+ E2D7              ;;;                        JumpIfAisZero, .MaxInputReached
 737+ E2D7              ;;;                        ld      a,(InputLength)
 738+ E2D7              ;;;                        JumpIfAisZero, .MaxInputReached
 739+ E2D7              ;;;                        ld      de,InputString
 740+ E2D7              ;;;                        ld      hl,de
 741+ E2D7              ;;;                        inc     hl
 742+ E2D7              ;;;                        ld      a,(InputLength)                 ; copy backwards
 743+ E2D7              ;;;                        dec     c                               ; for string length - curretn cursor
 744+ E2D7              ;;;                        ld      c,a
 745+ E2D7              ;;;                        ld      b,0
 746+ E2D7              ;;;                        ldir
 747+ E2D7              ;;;                        ret
 748+ E2D7              ;;;GOTTOHERE
 749+ E2D7
 750+ E2D7
 751+ E2D7
 752+ E2D7 C9           .MaxInputReached:       ret ; will add a beep later
 753+ E2D8
 754+ E2D8
 755+ E2D8
 756+ E2D8
 757+ E2D8              .NoKeyPressed:          ZeroA
 757+ E2D8 AF          >                        xor a
 758+ E2D9 32 B4 E2                             ld      (LastKeyPressed),a              ; Clear last key pressed
 759+ E2DC
 760+ E2DC
 761+ E2DC              InputName:              SetMemFalse InputChanged
 761+ E2DC 3E FF       >                        ld      a,$FF
 761+ E2DE 32 54 E2    >                        ld      (InputChanged),a
 762+ E2E1 CD D5 E1                             call    is_any_key_pressed
 763+ E2E4 FE FF                                cp      $FF
 764+ E2E6 C8                                   ret     z
 765+ E2E7 4F           .KeyPressed:            ld      c,a
 766+ E2E8 3A 52 E2                             ld      a,(InputCursor)                 ; No key so we can now look at if we are at the end of the buffer
 767+ E2EB FE 14                                cp      InputLimit                      ; move to variable later and then cp (hl)
 768+ E2ED 28 0B                                jr      z,.DeleteOrEnterOnly            ;
 769+ E2EF 21 BF E0                             ld      hl,ASCII_Map
 770+ E2F2 79                                   ld      a,c
 771+ E2F3 ED 31                                add     hl,a
 772+ E2F5 7E                                   ld      a,(hl)
 773+ E2F6 FE 41                                cp      "A"
 774+ E2F8 30 09                                jr      nc,.AlphaPressed
 775+ E2FA              ; CAPS and Symbol act as delete for now
 776+ E2FA FE 23        .DeleteOrEnterOnly      cp      "#"                             ; if space was  pressed (mapped to Hash in ASCII table))
 777+ E2FC 28 31                                jr      z,.SpacePressed                 ; for now we will ignore the shift and just assume delete
 778+ E2FE FE 3E                                cp      ">"         ; ENTER
 779+ E300 28 17                                jr      z,.EnterPressed
 780+ E302 C9                                   ret
 781+ E303 47           .AlphaPressed:          ld      b,a
 782+ E304 3A 52 E2                             ld      a,(InputCursor)
 783+ E307 4F                                   ld      c,a
 784+ E308 21 32 E2                             ld      hl,InputString
 785+ E30B ED 31                                add     hl,a
 786+ E30D 78                                   ld      a,b
 787+ E30E 70                                   ld      (hl),b
 788+ E30F 79                                   ld      a,c
 789+ E310 21 52 E2                             ld      hl,InputCursor
 790+ E313 34                                   inc     (hl)
 791+ E314                                      SetMemTrue InputChanged
 791+ E314 AF          >                        xor     a
 791+ E315 32 54 E2    >                        ld      (InputChanged),a
 792+ E318 C9                                   ret
 793+ E319 3A 52 E2     .EnterPressed:          ld      a,(InputCursor)
 794+ E31C 21 32 E2                             ld      hl,InputString
 795+ E31F ED 31                                add     hl,a
 796+ E321                                      ZeroA
 796+ E321 AF          >                        xor a
 797+ E322 77                                   ld      (hl),a
 798+ E323                                      SetMemTrue EnterPressed
 798+ E323 AF          >                        xor     a
 798+ E324 32 53 E2    >                        ld      (EnterPressed),a
 799+ E327                                      SetMemTrue InputChanged
 799+ E327 AF          >                        xor     a
 799+ E328 32 54 E2    >                        ld      (InputChanged),a
 800+ E32B CD F7 E0                             call    init_keyboard           ; Flush keyboard status so futher inputs don't auto read the enter key as a second press
 801+ E32E C9                                   ret
 802+ E32F 3A 52 E2     .SpacePressed:          ld      a,(InputCursor)         ; Space = delete
 803+ E332 FE 00                                cp      0                       ; if input is zero length then can not delete
 804+ E334 C8                                   ret     z
 805+ E335 3D                                   dec     a                       ; move back one and update cursor pos
 806+ E336 32 52 E2                             ld      (InputCursor),a         ;
 807+ E339 21 32 E2                             ld      hl,InputString          ; now update end of line to null
 808+ E33C ED 31                                add     hl,a                    ; .
 809+ E33E                                      ZeroA                           ; .
 809+ E33E AF          >                        xor a
 810+ E33F 77                                   ld      (hl),a                  ; .
 811+ E340                                      SetMemTrue InputChanged
 811+ E340 AF          >                        xor     a
 811+ E341 32 54 E2    >                        ld      (InputChanged),a
 812+ E344 C9                                   ret
 813+ E345
 814+ E345              TargetMissileTest:      AnyMissilesLeft
 814+ E345 3A 0E 6A    >                        ld      a,(NbrMissiles)
 814+ E348 A7          >                        and     a
 815+ E349                                      JumpIfZero      .ClearTargetting
 815+ E349 CA 60 E3    >                        jp	z,.ClearTargetting
 816+ E34C                                      IsMissileLaunchFlagged                      ; if we are comitted to launch
 816+ E34C 3A E5 6B    >                        ld      a,(MissileTargettingFlag)
 816+ E34F E6 80       >                        and     $80
 817+ E351 C8                                   ret             z                           ; then don't scan as it will be cleared on launch
 818+ E352 3E 16        .ScanForKey:            ld              a,c_Pressed_TargetMissle    ; if not pressed we are done
 819+ E354 CD BB E1                             call            is_key_pressed              ; .
 820+ E357 C0                                   ret             nz                          ; .
 821+ E358 3A E5 6B     .TargetPressed:         ld              a,(MissileTargettingFlag)   ; get flag back
 822+ E35B                                      JumpIfAEqNusng  StageMissileNotTargeting, .SetTargetting
 822+ E35B FE FF       >                        cp     StageMissileNotTargeting
 822+ E35D CA 66 E3    >                        jp      z,.SetTargetting
 823+ E360              .ClearTargetting:       ClearMissileTargetting
 823+ E360 3E FF       >                        ld      a,StageMissileNotTargeting
 823+ E362 32 E5 6B    >                        ld      (MissileTargettingFlag),a
 824+ E365 C9                                   ret
 825+ E366              .SetTargetting:         SetMissileTargetting
 825+ E366 3E FE       >                        ld      a,StageMissileTargeting
 825+ E368 32 E5 6B    >                        ld      (MissileTargettingFlag),a
 826+ E36B C9                                   ret
 827+ E36C
 828+ E36C AF           MovementKeyTest:        xor     a
 829+ E36D 32 4E 6B                             ld      (CursorKeysPressed),a
 830+ E370 3A 6C 69                             ld      a,(MenuIdMax)
 831+ E373 E6 FC                                and     $FC
 832+ E375 20 26                                jr      nz,CursorKeys
 833+ E377 2A 57 E0     ClimbDiveKeys:          ld      hl,(addr_Pressed_Climb)                 ; Check for Climb
 834+ E37A 7E                                   ld      a,(hl)
 835+ E37B                                      JumpIfAIsZero ScanDiveKey
 835+ E37B A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 835+ E37C CA 8A E3    >                        jp	    z, ScanDiveKey
 836+ E37F 3A 4E 6B                             ld      a,(CursorKeysPressed)
 837+ E382 F6 80                                or      CursorClimb
 838+ E384 32 4E 6B                             ld      (CursorKeysPressed),a
 839+ E387 C3 C0 E3                             jp      ScanLeftKey
 840+ E38A 2A 55 E0     ScanDiveKey:            ld      hl,(addr_Pressed_Dive)                  ; Check for Dive
 841+ E38D 7E                                   ld      a,(hl)
 842+ E38E                                      JumpIfAIsZero ScanLeftKey
 842+ E38E A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 842+ E38F CA C0 E3    >                        jp	    z, ScanLeftKey
 843+ E392 3A 4E 6B                             ld      a,(CursorKeysPressed)
 844+ E395 F6 40                                or      CursorDive
 845+ E397 32 4E 6B                             ld      (CursorKeysPressed),a
 846+ E39A C3 C0 E3                             jp      ScanLeftKey
 847+ E39D 2A 93 E0     CursorKeys:             ld      hl,(addr_Pressed_CursorUp)              ; Check cursor keys
 848+ E3A0 7E                                   ld      a,(hl)
 849+ E3A1                                      JumpIfAIsZero ScanCursorDownKey
 849+ E3A1 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 849+ E3A2 CA B0 E3    >                        jp	    z, ScanCursorDownKey
 850+ E3A5 3A 4E 6B                             ld      a,(CursorKeysPressed)
 851+ E3A8 F6 80                                or      CursorClimb
 852+ E3AA 32 4E 6B                             ld      (CursorKeysPressed),a
 853+ E3AD C3 C0 E3                             jp      ScanLeftKey
 854+ E3B0 2A 95 E0     ScanCursorDownKey:      ld      hl,(addr_Pressed_CursorDown)
 855+ E3B3 7E                                   ld      a,(hl)
 856+ E3B4                                      JumpIfAIsZero ScanLeftKey
 856+ E3B4 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 856+ E3B5 CA C0 E3    >                        jp	    z, ScanLeftKey
 857+ E3B8 3A 4E 6B                             ld      a,(CursorKeysPressed)
 858+ E3BB F6 40                                or      CursorDive
 859+ E3BD 32 4E 6B                             ld      (CursorKeysPressed),a
 860+ E3C0 2A 51 E0     ScanLeftKey:            ld      hl,(addr_Pressed_RollLeft)
 861+ E3C3 7E                                   ld      a,(hl)
 862+ E3C4                                      JumpIfAIsZero ScanRightKey
 862+ E3C4 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 862+ E3C5 CA D1 E3    >                        jp	    z, ScanRightKey
 863+ E3C8 3A 4E 6B                             ld      a,(CursorKeysPressed)
 864+ E3CB F6 20                                or      CursorLeft
 865+ E3CD 32 4E 6B                             ld      (CursorKeysPressed),a
 866+ E3D0 C9                                   ret
 867+ E3D1 2A 53 E0     ScanRightKey:           ld      hl,(addr_Pressed_RollRight)
 868+ E3D4 7E                                   ld      a,(hl)
 869+ E3D5                                      JumpIfAIsZero ScanHomeKey
 869+ E3D5 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 869+ E3D6 CA E2 E3    >                        jp	    z, ScanHomeKey
 870+ E3D9 3A 4E 6B                             ld      a,(CursorKeysPressed)
 871+ E3DC F6 10                                or      CursorRight
 872+ E3DE 32 4E 6B                             ld      (CursorKeysPressed),a
 873+ E3E1 C9                                   ret
 874+ E3E2 2A 71 E0     ScanHomeKey:            ld      hl,(addr_Pressed_HomeCursor)
 875+ E3E5 7E                                   ld      a,(hl)
 876+ E3E6                                      JumpIfAIsZero ScanRecentreKey
 876+ E3E6 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 876+ E3E7 CA F3 E3    >                        jp	    z, ScanRecentreKey
 877+ E3EA 3A 4E 6B                             ld      a,(CursorKeysPressed)
 878+ E3ED F6 08                                or      CursorHome
 879+ E3EF 32 4E 6B                             ld      (CursorKeysPressed),a
 880+ E3F2 C9                                   ret
 881+ E3F3 2A 8D E0     ScanRecentreKey:        ld      hl,(addr_Pressed_Recentre)
 882+ E3F6 7E                                   ld      a,(hl)
 883+ E3F7                                      ReturnIfAIsZero
 883+ E3F7 A7          >                        and     a
 883+ E3F8 C8          >                        ret     z
 884+ E3F9 3A 4E 6B                             ld      a,(CursorKeysPressed)
 885+ E3FC F6 04                                or      CursorRecenter
 886+ E3FE 32 4E 6B                             ld      (CursorKeysPressed),a
 887+ E401 C9                                   ret
 888+ E402
 889+ E402
# file closed: ../../Hardware/keyboard.asm
 955  E402                                  DISPLAY "Keyboard ",BankKeyboard," - Bytes free ",/D, $2000 - ($-KeyboardAddr), " - BankKeyboard"
 956  E402                                  ASSERT $-KeyboardAddr <8912, Bank code leaks over 8K boundary
 957  E402               ; Bank 102  -----------------------------------------------------------------------------------------------------------------------
 958  E402                                  SLOT    MathsBankedFnsAddr
 959  E402                                  PAGE    BankMathsBankedFns
 960  E402                                  ORG     MathsBankedFnsAddr,BankMathsBankedFns
 961  0000                                  INCLUDE "../../Maths/MathsBankedFns.asm"
# file opened: ../../Maths/MathsBankedFns.asm
   1+ 0000
   2+ 0000 7A           SubDEfromHLSigned:      ld      a,d
   3+ 0001 EE 80                                xor     $80
   4+ 0003 57                                   ld      d,a
   5+ 0004              ; Adds DE to HL, in form S15 result will also be S15 rather than 2's C
   6+ 0004 7C           AddDEtoHLSigned:        ld      a,h                         ; extract h sign to b
   7+ 0005 E6 80                                and     $80                         ; hl = abs (hl)
   8+ 0007 47                                   ld      b,a
   9+ 0008 7C                                   ld      a,h
  10+ 0009 E6 7F                                and     $7F
  11+ 000B 67                                   ld      h,a
  12+ 000C 7A                                   ld      a,d                         ; extract d sign to c
  13+ 000D E6 80                                and     $80                         ; de = abs (de)
  14+ 000F 4F                                   ld      c,a
  15+ 0010 7A                                   ld      a,d
  16+ 0011 E6 7F                                and     $7F
  17+ 0013 57                                   ld      d,a
  18+ 0014 78                                   ld      a,b
  19+ 0015 A9                                   xor     c
  20+ 0016 C2 1E 00                             jp      nz,.OppositeSigns
  21+ 0019 19           .SameSigns              add     hl,de                       ; same signs so just add
  22+ 001A 78                                   ld      a,b                         ; and bring in the sign from b
  23+ 001B B4                                   or      h                           ; note this has to be 15 bit result
  24+ 001C 67                                   ld      h,a                         ; but we can assume that
  25+ 001D C9                                   ret
  26+ 001E              .OppositeSigns:         ClearCarryFlag
  26+ 001E B7          >                        or a
  27+ 001F ED 52                                sbc     hl,de
  28+ 0021 38 04                                jr      c,.OppsiteSignInvert
  29+ 0023 78           .OppositeSignNoInvert:  ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
  30+ 0024 B4                                   or      h
  31+ 0025 67                                   ld      h,a                         ; set the previou sign value
  32+ 0026 C9                                   ret
  33+ 0027              .OppsiteSignInvert:     NegHL                              ; we need to flip the sign and 2'c the Hl result
  33+ 0027 AF          >                    xor a
  33+ 0028 95          >                    sub l
  33+ 0029 6F          >                    ld l,a
  33+ 002A 9F          >                    sbc a,a
  33+ 002B 94          >                    sub h
  33+ 002C 67          >                    ld h,a
  34+ 002D 78                                   ld      a,b
  35+ 002E EE 80                                xor     SignOnly8Bit               ; flip sign bit
  36+ 0030 B4                                   or      h
  37+ 0031 67                                   ld      h,a                         ; recover sign
  38+ 0032 C9                                   ret
  39+ 0033
  40+ 0033 78           ADDHLDESignBC:          ld      a,b
  41+ 0034 E6 80                                and     SignOnly8Bit
  42+ 0036 A9                                   xor     c                           ;if b sign and c sign were different then bit 7 of a will be 1 which means
  43+ 0037                                      JumpIfNegative .ADDHLDEsBCOppSGN     ;Signs are opposite there fore we can subtract to get difference
  43+ 0037 FA 45 00    >                        jp		m, .ADDHLDEsBCOppSGN
  44+ 003A 78           .ADDHLDEsBCSameSigns:   ld      a,b
  45+ 003B B1                                   or      c
  46+ 003C                                      JumpIfNegative .ADDHLDEsBCSameNeg    ; optimisation so we can just do simple add if both positive
  46+ 003C FA 41 00    >                        jp		m, .ADDHLDEsBCSameNeg
  47+ 003F 19                                   add     hl,de                       ; both positive so a will already be zero
  48+ 0040 C9                                   ret
  49+ 0041 19           .ADDHLDEsBCSameNeg:      add     hl,de
  50+ 0042 78                                   ld      a,b
  51+ 0043                                      DISPLAY "TODO: don't bother with overflow for now"
  52+ 0043 B1                                   or      c                           ; now set bit for negative value, we won't bother with overflow for now TODO
  53+ 0044 C9                                   ret
  54+ 0045              .ADDHLDEsBCOppSGN:       ClearCarryFlag
  54+ 0045 B7          >                        or a
  55+ 0046 ED 52                                sbc     hl,de
  56+ 0048 38 02                                jr      c,.ADDHLDEsBCOppInvert
  57+ 004A 78           .ADDHLDEsBCOppSGNNoCarry:ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
  58+ 004B C9                                   ret
  59+ 004C              .ADDHLDEsBCOppInvert:   NegHL                               ; if result was zero then set sign to zero (which doing h or l will give us for free)
  59+ 004C AF          >                    xor a
  59+ 004D 95          >                    sub l
  59+ 004E 6F          >                    ld l,a
  59+ 004F 9F          >                    sbc a,a
  59+ 0050 94          >                    sub h
  59+ 0051 67          >                    ld h,a
  60+ 0052 78                                   ld      a,b
  61+ 0053 EE 80                                xor     SignOnly8Bit                ; flip sign bit
  62+ 0055 C9                                   ret
  63+ 0056
  64+ 0056 7C           ADDHLDESignedV4:        ld      a,h
  65+ 0057 E6 80                                and     SignOnly8Bit
  66+ 0059 47                                   ld      b,a                         ;save sign bit in b
  67+ 005A AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
  68+ 005B                                      JumpIfNegative .ADDHLDEOppSGN       ;Signs are opposite there fore we can subtract to get difference
  68+ 005B FA 73 00    >                        jp		m, .ADDHLDEOppSGN
  69+ 005E 78           .ADDHLDESameSigns:      ld      a,b
  70+ 005F B2                                   or      d
  71+ 0060                                      JumpIfNegative .ADDHLDESameNeg      ; optimisation so we can just do simple add if both positive
  71+ 0060 FA 65 00    >                        jp		m, .ADDHLDESameNeg
  72+ 0063 19                                   add     hl,de
  73+ 0064 C9                                   ret
  74+ 0065 7C           .ADDHLDESameNeg:        ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
  75+ 0066 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
  76+ 0068 67                                   ld      h,a
  77+ 0069 7A                                   ld      a,d
  78+ 006A E6 7F                                and     SignMask8Bit
  79+ 006C 57                                   ld      d,a
  80+ 006D 19                                   add     hl,de
  81+ 006E 3E 80                                ld      a,SignOnly8Bit
  82+ 0070                                      DISPLAY "TODO:  dont bother with overflow for now"
  83+ 0070 B4                                   or      h                           ; now set bit for negative value, we won't bother with overflow for now TODO
  84+ 0071 67                                   ld      h,a
  85+ 0072 C9                                   ret
  86+ 0073 7C           .ADDHLDEOppSGN:         ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit                     ; here HL and DE are opposite
  87+ 0074 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
  88+ 0076 67                                   ld      h,a
  89+ 0077 7A                                   ld      a,d
  90+ 0078 E6 7F                                and     SignMask8Bit
  91+ 007A 57                                   ld      d,a
  92+ 007B                                      ClearCarryFlag
  92+ 007B B7          >                        or a
  93+ 007C ED 52                                sbc     hl,de
  94+ 007E 38 04                                jr      c,.ADDHLDEOppInvert
  95+ 0080 78           .ADDHLDEOppSGNNoCarry:  ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
  96+ 0081 B4                                   or      h
  97+ 0082 67                                   ld      h,a                         ; set the previou sign value
  98+ 0083 C9                                   ret
  99+ 0084              .ADDHLDEOppInvert:      NegHL                                                   ; we need to flip the sign and 2'c the Hl result
  99+ 0084 AF          >                    xor a
  99+ 0085 95          >                    sub l
  99+ 0086 6F          >                    ld l,a
  99+ 0087 9F          >                    sbc a,a
  99+ 0088 94          >                    sub h
  99+ 0089 67          >                    ld h,a
 100+ 008A 78                                   ld      a,b
 101+ 008B EE 80                                xor     SignOnly8Bit                ; flip sign bit
 102+ 008D B4                                   or      h
 103+ 008E 67                                   ld      h,a                         ; recover sign
 104+ 008F C9                                   ret
 105+ 0090
 106+ 0090              ; extension to AddBCHtoDELsigned
 107+ 0090              ; takes ix as the address of the values to load into DEL
 108+ 0090              ;       iy as the address of the values to load into BCH
 109+ 0090 DD 6E 00     AddAtIXtoAtIY24Signed:  ld      l,(ix+0)            ; del = ix (sign hi lo)
 110+ 0093 DD 5E 01                             ld      e,(ix+1)            ; .
 111+ 0096 DD 56 02                             ld      d,(ix+2)            ; .
 112+ 0099 FD 66 00                             ld      h,(iy+0)            ; bch = iy (sign, hi, lo)
 113+ 009C FD 4E 01                             ld      c,(iy+1)            ; .
 114+ 009F FD 46 02                             ld      b,(iy+2)            ; .
 115+ 00A2 FD E5                                push    iy                  ; save iy as add function changes is
 116+ 00A4 CD 14 01                             call    AddBCHtoDELsigned   ; Perform del += bch
 117+ 00A7 FD E1                                pop     iy                  ; get iy back
 118+ 00A9 DD 75 00                             ld      (ix+0),l            ; put result into (ix)
 119+ 00AC DD 73 01                             ld      (ix+1),e            ; .
 120+ 00AF DD 72 02                             ld      (ix+2),d            ; .
 121+ 00B2 C9                                   ret
 122+ 00B3
 123+ 00B3              AddDELequAtIXPlusIY24Signed:
 124+ 00B3 DD 6E 00                             ld      l,(ix+0)            ; del = ix (sign hi lo)
 125+ 00B6 DD 5E 01                             ld      e,(ix+1)            ; .
 126+ 00B9 DD 56 02                             ld      d,(ix+2)            ; .
 127+ 00BC FD 66 00                             ld      h,(iy+0)            ; bch = iy (sign, hi, lo)
 128+ 00BF FD 4E 01                             ld      c,(iy+1)            ; .
 129+ 00C2 FD 46 02                             ld      b,(iy+2)            ; .
 130+ 00C5 FD E5                                push    iy                  ; save iy as add function changes is
 131+ 00C7 CD 14 01                             call    AddBCHtoDELsigned   ; Perform del += bch
 132+ 00CA FD E1                                pop     iy                  ; get iy back
 133+ 00CC C9                                   ret
 134+ 00CD              ; extension to AddBCHtoDELsigned
 135+ 00CD              ; takes ix as the address of the values to load into DEL
 136+ 00CD              ;       iy as the address of the values to load into BCH
 137+ 00CD              ; subtracts iy from ix putting result in ix
 138+ 00CD DD 6E 00     SubAtIXtoAtIY24Signed:  ld      l,(ix+0)            ; del = ix (sign hi lo)
 139+ 00D0 DD 5E 01                             ld      e,(ix+1)            ; .
 140+ 00D3 DD 56 02                             ld      d,(ix+2)            ; .
 141+ 00D6 FD 66 00                             ld      h,(iy+0)            ; bch = -iy (sign, hi, lo)
 142+ 00D9 FD 4E 01                             ld      c,(iy+1)            ; .
 143+ 00DC FD 7E 02                             ld      a,(iy+2)            ; .
 144+ 00DF EE 80                                xor     SignOnly8Bit        ; . this is where we flip sign to make add subtract
 145+ 00E1 47                                   ld      b,a                 ; .
 146+ 00E2 FD E5                                push    iy                  ; save iy as add function changes is
 147+ 00E4 CD 14 01                             call    AddBCHtoDELsigned   ; perform del += bch which as we flipped bch sign means (ix [210] -= iy [210])
 148+ 00E7 FD E1                                pop     iy                  ; get iy back
 149+ 00E9 DD 75 00                             ld      (ix+0),l            ; put result into (ix)
 150+ 00EC DD 73 01                             ld      (ix+1),e            ; .
 151+ 00EF DD 72 02                             ld      (ix+2),d            ; .
 152+ 00F2 C9                                   ret
 153+ 00F3
 154+ 00F3              ; extension to AddBCHtoDELsigned
 155+ 00F3              ; takes ix as the address of the values to load into DEL
 156+ 00F3              ;       iy as the address of the values to load into BCH
 157+ 00F3              ; subtracts iy from ix leaving result in del
 158+ 00F3              SubDELequAtIXMinusAtIY24Signed:
 159+ 00F3 DD 6E 00                             ld      l,(ix+0)            ; del = ix (sign hi lo)
 160+ 00F6 DD 5E 01                             ld      e,(ix+1)            ; .
 161+ 00F9 DD 56 02                             ld      d,(ix+2)            ; .
 162+ 00FC FD 66 00                             ld      h,(iy+0)            ; bch = -iy (sign, hi, lo)
 163+ 00FF FD 4E 01                             ld      c,(iy+1)            ; .
 164+ 0102 FD 7E 02                             ld      a,(iy+2)            ; .
 165+ 0105 EE 80                                xor     SignOnly8Bit        ; . this is where we flip sign to make add subtract
 166+ 0107 47                                   ld      b,a                 ; .
 167+ 0108 FD E5                                push    iy                  ; save iy as add function changes is
 168+ 010A CD 14 01                             call    AddBCHtoDELsigned   ; perform del += bch which as we flipped bch sign means (ix [210] -= iy [210])
 169+ 010D FD E1                                pop     iy                  ; get iy back
 170+ 010F C9                                   ret
 171+ 0110
 172+ 0110
 173+ 0110              ;tested mathstestsun2
 174+ 0110              ; DEL = DEL - BCH signed, uses BC, DE, HL, IY, A
 175+ 0110              ; Just flips sign on b then performs add
 176+ 0110 78           SubBCHfromDELsigned:    ld      a,b
 177+ 0111 EE 80                                xor     SignOnly8Bit
 178+ 0113 47                                   ld      b,a
 179+ 0114              ; DEL = DEL + BCH signed, uses BC, DE, HL, IY, A
 180+ 0114 78           AddBCHtoDELsigned:      ld      a,b                 ; Are the values both the same sign?
 181+ 0115 AA                                   xor     d                   ; .
 182+ 0116 E6 80                                and     SignOnly8Bit        ; .
 183+ 0118 20 19                                jr      nz,.SignDifferent   ; .
 184+ 011A 78           .SignSame:              ld      a,b                 ; if they are then we only need 1 signe
 185+ 011B E6 80                                and     SignOnly8Bit        ; so store it in iyh
 186+ 011D FD 67                                ld      iyh,a               ;
 187+ 011F 78                                   ld      a,b                 ; bch = abs bch
 188+ 0120 E6 7F                                and     SignMask8Bit        ; .
 189+ 0122 47                                   ld      b,a                 ; .
 190+ 0123 7A                                   ld      a,d                 ; del = abs del
 191+ 0124 E6 7F                                and     SignMask8Bit        ; .
 192+ 0126 57                                   ld      d,a                 ; .
 193+ 0127 7C                                   ld      a,h                 ; l = h + l
 194+ 0128 85                                   add     l                   ; .
 195+ 0129 6F                                   ld      l,a                 ; .
 196+ 012A 79                                   ld      a,c                 ; e = e + c + carry
 197+ 012B 8B                                   adc     e                   ; .
 198+ 012C 5F                                   ld      e,a                 ; .
 199+ 012D 78                                   ld      a,b                 ; d = b + d + carry (signed)
 200+ 012E 8A                                   adc     d                   ;
 201+ 012F FD B4                                or      iyh                 ; d = or back in sign bit
 202+ 0131 57                                   ld      d,a                 ;
 203+ 0132 C9                                   ret                         ; done
 204+ 0133 78           .SignDifferent:         ld      a,b                 ; bch = abs bch
 205+ 0134 FD 67                                ld      iyh,a               ; iyh = b sign
 206+ 0136 E6 7F                                and     SignMask8Bit        ; .
 207+ 0138 47                                   ld      b,a                 ; .
 208+ 0139 7A                                   ld      a,d                 ; del = abs del
 209+ 013A FD 6F                                ld      iyl,a               ; iyl = d sign
 210+ 013C E6 7F                                and     SignMask8Bit        ; .
 211+ 013E 57                                   ld      d,a                 ; .
 212+ 013F E5                                   push    hl                  ; save hl
 213+ 0140 60 69                                ld      hl,bc               ; hl = bc - de, if bc < de then there is a carry
 214+ 0142 ED 52                                sbc     hl,de               ;
 215+ 0144 E1                                   pop     hl                  ;
 216+ 0145 38 0E                                jr      c,.BCHltDEL
 217+ 0147 20 1C                                jr      nz,.DELltBCH        ; if the result was not zero then DEL > BCH
 218+ 0149 7C           .BCeqDE:                ld      a,h                 ; if the result was zero then check lowest bits
 219+ 014A                                      JumpIfALTNusng l,.BCHltDEL
 219+ 014A BD          >                        cp      l
 219+ 014B DA 55 01    >                        jp		c, .BCHltDEL
 220+ 014E 20 15                                jr      nz,.DELltBCH
 221+ 0150              ; The same so its just zero
 222+ 0150 AF           .BCHeqDEL:              xor     a                  ; its just zero
 223+ 0151 57                                   ld      d,a                ; .
 224+ 0152 5F                                   ld      e,a                ; .
 225+ 0153 6F                                   ld      l,a                ; .
 226+ 0154 C9                                   ret                        ; .
 227+ 0155              ;BCH is less than DEL so its DEL - BCH the sort out sign
 228+ 0155 7D           .BCHltDEL:              ld      a,l                ; l = l - h                      ; ex
 229+ 0156 94                                   sub     h                  ; .                              ;   01D70F DEL
 230+ 0157 6F                                   ld      l,a                ; .                              ;  -000028 BCH
 231+ 0158 7B                                   ld      a,e                ; e = e - c - carry              ;1.
 232+ 0159 99                                   sbc     c                  ; .                              ;
 233+ 015A 5F                                   ld      e,a                ; .                              ;
 234+ 015B 7A                                   ld      a,d                ; d = d - b - carry              ;
 235+ 015C 98                                   sbc     b                  ; .                              ;
 236+ 015D 57                                   ld      d,a                ; .                              ;
 237+ 015E FD 7D                                ld      a,iyl              ; as d was larger, take d sign
 238+ 0160 E6 80                                and     SignOnly8Bit       ;
 239+ 0162 B2                                   or      d                  ;
 240+ 0163 57                                   ld      d,a                ;
 241+ 0164 C9                                   ret
 242+ 0165 7C           .DELltBCH:              ld      a,h                ; l = h - l
 243+ 0166 95                                   sub     l                  ;
 244+ 0167 6F                                   ld      l,a                ;
 245+ 0168 79                                   ld      a,c                ; e = c - e - carry
 246+ 0169 9B                                   sbc     e                  ;
 247+ 016A 5F                                   ld      e,a                ;
 248+ 016B 78                                   ld      a,b                ; d = b - d - carry
 249+ 016C 9A                                   sbc     d                  ;
 250+ 016D 57                                   ld      d,a                ;
 251+ 016E FD 7C                                ld      a,iyh              ; as b was larger, take b sign into d
 252+ 0170 E6 80                                and     SignOnly8Bit       ;
 253+ 0172 B2                                   or      d                  ;
 254+ 0173 57                                   ld      d,a                ;
 255+ 0174 C9                                   ret
 256+ 0175              ;-----------------------------------------------------------------------------------------------------------
 257+ 0175              ; Subtract Functions
 258+ 0175              ;...subtract routines
 259+ 0175              ; we could cheat, flip the sign of DE and just add but its not very optimised
 260+ 0175 7C           subHLDES15:             ld      a,h
 261+ 0176 E6 80                                and     SignOnly8Bit
 262+ 0178 47                                   ld      b,a                         ;save sign bit in b
 263+ 0179 AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
 264+ 017A                                      JumpIfNegative .SUBHLDEOppSGN        ;Signs are opposite therefore we can add
 264+ 017A FA A8 01    >                        jp		m, .SUBHLDEOppSGN
 265+ 017D 78           .SUBHLDESameSigns:      ld      a,b
 266+ 017E B2                                   or      d
 267+ 017F                                      JumpIfNegative .SUBHLDESameNeg       ; optimisation so we can just do simple add if both positive
 267+ 017F FA 89 01    >                        jp		m, .SUBHLDESameNeg
 268+ 0182                                      ClearCarryFlag
 268+ 0182 B7          >                        or a
 269+ 0183 ED 52                                sbc     hl,de
 270+ 0185                                      JumpIfNegative .SUBHLDESameOvrFlw
 270+ 0185 FA 9C 01    >                        jp		m, .SUBHLDESameOvrFlw
 271+ 0188 C9                                   ret
 272+ 0189 7C           .SUBHLDESameNeg:        ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 273+ 018A E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 274+ 018C 67                                   ld      h,a
 275+ 018D 7A                                   ld      a,d
 276+ 018E E6 7F                                and     SignMask8Bit
 277+ 0190 57                                   ld      d,a
 278+ 0191                                      ClearCarryFlag
 278+ 0191 B7          >                        or a
 279+ 0192 ED 52                                sbc     hl,de
 280+ 0194                                      JumpIfNegative .SUBHLDESameOvrFlw
 280+ 0194 FA 9C 01    >                        jp		m, .SUBHLDESameOvrFlw
 281+ 0197                                                          DISPLAY "TODO:  don't bother with overflow for now"
 282+ 0197 7C                                   ld      a,h                         ; now set bit for negative value, we won't bother with overflow for now TODO
 283+ 0198 F6 80                                or      SignOnly8Bit
 284+ 019A 67                                   ld      h,a
 285+ 019B C9                                   ret
 286+ 019C              .SUBHLDESameOvrFlw:     NegHL
 286+ 019C AF          >                    xor a
 286+ 019D 95          >                    sub l
 286+ 019E 6F          >                    ld l,a
 286+ 019F 9F          >                    sbc a,a
 286+ 01A0 94          >                    sub h
 286+ 01A1 67          >                    ld h,a
 287+ 01A2 78                                   ld      a,b
 288+ 01A3 EE 80                                xor     SignOnly8Bit                ; flip sign bit
 289+ 01A5 B4                                   or      h
 290+ 01A6 67                                   ld      h,a                         ; recover sign
 291+ 01A7 C9                                   ret
 292+ 01A8 B7           .SUBHLDEOppSGN:         or      a
 293+ 01A9 7C                                   ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 294+ 01AA E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 295+ 01AC 67                                   ld      h,a
 296+ 01AD 7A                                   ld      a,d
 297+ 01AE E6 7F                                and     SignMask8Bit
 298+ 01B0 57                                   ld      d,a
 299+ 01B1 19                                   add     hl,de
 300+ 01B2 78                                   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
 301+ 01B3 B4                                   or      h
 302+ 01B4 67                                   ld      h,a                         ; set the previou sign value
 303+ 01B5 C9                                   ret
 304+ 01B6              ;------------------------------------------------------------------------------------------------
 305+ 01B6              ;-- checks to see if a postition is in range of another, e.g. missile hit
 306+ 01B6              ;-- ix = ship position    - pointer to xyz vector as 3 bytes per element
 307+ 01B6              ;-- oy = misisle position - pointer to xyz vector as 3 bytes per element
 308+ 01B6              ;-- sets carry if in blast range, else not carry
 309+ 01B6              ;-- blast range will always be an 8 bit value
 310+ 01B6              CheckInCollisionRange:
 311+ 01B6 CD F3 00     .CheckXDistance:        call    SubDELequAtIXMinusAtIY24Signed ; get distance between x coordinates
 312+ 01B9 7A                                   ld      a,d                 ; check abs distance
 313+ 01BA E6 7F                                and     SignMask8Bit        ; if high bytes are set
 314+ 01BC B3                                   or      e                   ; then no hit
 315+ 01BD C2 FC 01                             jp      nz,.NoCollision     ; if high bytes are set no collision
 316+ 01C0 7D                                   ld      a,l
 317+ 01C1                                      JumpIfAGTEMemusng  CurrentMissileBlastRange ,.NoCollision
 317+ 01C1 21 59 6A    >                        ld      hl,CurrentMissileBlastRange
 317+ 01C4 BE          >                        cp      (hl)
 317+ 01C5 D2 FC 01    >                        jp		nc,.NoCollision
 318+ 01C8 01 03 00     .CheckYDistance:        ld      bc,3                ; move ix and iy
 319+ 01CB DD 09                                add     ix,bc               ; on 3 bytes
 320+ 01CD FD 09                                add     iy,bc               ;
 321+ 01CF CD F3 00                             call    SubDELequAtIXMinusAtIY24Signed ; get distance between x coordinates
 322+ 01D2 7A                                   ld      a,d                 ; check abs distance
 323+ 01D3 E6 7F                                and     SignMask8Bit        ; if high bytes are set
 324+ 01D5 B3                                   or      e                   ; then no hit
 325+ 01D6 C2 FC 01                             jp      nz,.NoCollision     ; if high bytes are set no collision
 326+ 01D9 7D                                   ld      a,l
 327+ 01DA                                      JumpIfAGTEMemusng  CurrentMissileBlastRange ,.NoCollision
 327+ 01DA 21 59 6A    >                        ld      hl,CurrentMissileBlastRange
 327+ 01DD BE          >                        cp      (hl)
 327+ 01DE D2 FC 01    >                        jp		nc,.NoCollision
 328+ 01E1 01 03 00     .CheckZDistance:        ld      bc,3                ; move ix and iy
 329+ 01E4 DD 09                                add     ix,bc               ; on 3 bytes
 330+ 01E6 FD 09                                add     iy,bc               ;
 331+ 01E8 CD F3 00                             call    SubDELequAtIXMinusAtIY24Signed ; get distance between x coordinates
 332+ 01EB 7A                                   ld      a,d                 ; check abs distance
 333+ 01EC E6 7F                                and     SignMask8Bit        ; if high bytes are set
 334+ 01EE B3                                   or      e                   ; then no hit
 335+ 01EF C2 FC 01                             jp      nz,.NoCollision     ; if high bytes are set no collision
 336+ 01F2 7D                                   ld      a,l
 337+ 01F3                                      JumpIfAGTEMemusng  CurrentMissileBlastRange ,.NoCollision
 337+ 01F3 21 59 6A    >                        ld      hl,CurrentMissileBlastRange
 337+ 01F6 BE          >                        cp      (hl)
 337+ 01F7 D2 FC 01    >                        jp		nc,.NoCollision
 338+ 01FA              .CollisionDetected:     SetCarryFlag                ; collision in blast range
 338+ 01FA 37          >                        scf
 339+ 01FB C9                                   ret
 340+ 01FC              .NoCollision:           ClearCarryFlag              ; no collision in blast range
 340+ 01FC B7          >                        or a
 341+ 01FD C9                                   ret
 342+ 01FE
 343+ 01FE              ;------------------------------------------------------------------------------------------------
 344+ 01FE              ; -- Checks if 24 bit value at ix > iy and returns ix pointing to the correct value
 345+ 01FE              ; -- Sets carryflag if a swap occured as part of the Jump If A LessThan check
 346+ 01FE FD 7E 02     CompareAtIXtoIYABS:     ld      a,(iy+2)
 347+ 0201 E6 7F        .CheckSignByte:         and     SignMask8Bit
 348+ 0203 47                                   ld      b,a
 349+ 0204 DD 7E 02                             ld      a,(ix+2)
 350+ 0207 E6 7F                                and     SignMask8Bit
 351+ 0209                                      JumpIfALTNusng b,.SwapIXIY
 351+ 0209 B8          >                        cp      b
 351+ 020A DA 22 02    >                        jp		c, .SwapIXIY
 352+ 020D DD 7E 01     .CheckHighByte:         ld      a,(ix+1)
 353+ 0210 FD BE 01                             cp      (iy+1)
 354+ 0213                                      JumpIfALTNusng b,.SwapIXIY
 354+ 0213 B8          >                        cp      b
 354+ 0214 DA 22 02    >                        jp		c, .SwapIXIY
 355+ 0217 DD 7E 00     .CheckLowByte:          ld      a,(ix+0)
 356+ 021A FD BE 00                             cp      (iy+0)
 357+ 021D                                      JumpIfALTNusng b,.SwapIXIY
 357+ 021D B8          >                        cp      b
 357+ 021E DA 22 02    >                        jp		c, .SwapIXIY
 358+ 0221 C9                                   ret
 359+ 0222 DD E5        .SwapIXIY               push    ix                  ; swap over ix and iy
 360+ 0224 FD E5                                push    iy                  ; this means that ix is always larger of two or ix if they are the same value
 361+ 0226 DD E1                                pop     ix                  ; iy is a smaller of the two values, or untouched in the same value
 362+ 0228 FD E1                                pop     iy                  ; Thsi means we can do a compare and pick which one we preferr after, carry says if swap occured if we need that
 363+ 022A C9                                   ret
 364+ 022B
 365+ 022B              ;------------------------------------------------------------------------------------------------
 366+ 022B              ; -- Manhattan distance
 367+ 022B              ; -- very quick distance calculation based on a cube
 368+ 022B              ; -- ix = pointer to vector of 3x3, iy = distance to check
 369+ 022B              ; simploy done by ABS (ix)
 370+ 022B              ; returns z if outside box, nz if inside box
 371+ 022B DD 6E 00     ManhattanDistanceIXIY:  ld      l,(ix+0)            ; del = abs ix (sign hi lo)
 372+ 022E DD 5E 01     .checkX:                ld      e,(ix+1)            ; .
 373+ 0231 DD 7E 02                             ld      a,(ix+2)            ; .
 374+ 0234 E6 7F                                and     SignMask8Bit        ;
 375+ 0236 57                                   ld      d,a                 ;
 376+ 0237 FD 66 00                             ld      h,(iy+0)            ; bch = distiance to check
 377+ 023A FD 4E 01                             ld      c,(iy+1)            ; .
 378+ 023D FD 7E 02                             ld      a,(iy+2)            ; .
 379+ 0240 EE 80                                xor     SignOnly8Bit        ; . this is where we flip sign to make add subtract
 380+ 0242 47                                   ld      b,a                 ; .
 381+ 0243 C5 E5                                push    bc,,hl              ; save this for 2nd and 3rd test
 382+ 0245 FD E5                                push    iy                  ; save iy as add function changes is
 383+ 0247 CD 14 01                             call    AddBCHtoDELsigned   ; perform del += bch which as we flipped bch sign means (ix [210] -= iy [210])
 384+ 024A FD E1                                pop     iy                  ; get iy back
 385+ 024C 7A                                   ld      a,d
 386+ 024D E6 80                                and     SignOnly8Bit
 387+ 024F CA 88 02                             jp      z,.ClearUp          ; so if its positive then outside boundary
 388+ 0252 E1 C1        .checkY:                pop     bc,,hl
 389+ 0254 C5 E5                                push    bc,,hl
 390+ 0256 DD 6E 03                             ld      l,(ix+3)            ; del = abs ix (sign hi lo)
 391+ 0259 DD 5E 04                             ld      e,(ix+4)            ; .
 392+ 025C DD 7E 05                             ld      a,(ix+5)            ; .
 393+ 025F E6 7F                                and     SignMask8Bit        ;
 394+ 0261 57                                   ld      d,a                 ;
 395+ 0262 FD E5                                push    iy                  ; save iy as add function changes is
 396+ 0264 CD 14 01                             call    AddBCHtoDELsigned   ; perform del += bch which as we flipped bch sign means (ix [210] -= iy [210])
 397+ 0267 FD E1                                pop     iy                  ; get iy back
 398+ 0269 7A                                   ld      a,d
 399+ 026A E6 80                                and     SignOnly8Bit
 400+ 026C CA 88 02                             jp      z,.ClearUp          ; so if its positive then outside boundary
 401+ 026F E1 C1        .checkZ:                pop     bc,,hl
 402+ 0271 DD 6E 06                             ld      l,(ix+6)            ; del = abs ix (sign hi lo)
 403+ 0274 DD 5E 07                             ld      e,(ix+7)            ; .
 404+ 0277 DD 7E 08                             ld      a,(ix+8)            ; .
 405+ 027A E6 7F                                and     SignMask8Bit        ;
 406+ 027C 57                                   ld      d,a                 ;
 407+ 027D FD E5                                push    iy                  ; save iy as add function changes is
 408+ 027F CD 14 01                             call    AddBCHtoDELsigned   ; perform del += bch which as we flipped bch sign means (ix [210] -= iy [210])
 409+ 0282 FD E1                                pop     iy                  ; get iy back
 410+ 0284 7A                                   ld      a,d
 411+ 0285 E6 80                                and     SignOnly8Bit
 412+ 0287 C9                                   ret
 413+ 0288 E1 C1        .ClearUp:               pop     bc,,hl
 414+ 028A C9                                   ret
 415+ 028B
 416+ 028B
 417+ 028B              ; Note vectors are 2 byte lead sign, angle is 8 bit lead sign
 418+ 028B              ApplyMyAngleAToIXIY:    ;break
 419+ 028B F5                                   push    af                          ; save angle
 420+ 028C              ; Calculate Angle * vector /256, i.e take angle and mutiple by high byte of vector
 421+ 028C 5F           .processVector1:        ld      e,a                         ; e = angle
 422+ 028D DD 56 01                             ld      d,(ix+1)                    ; d = vector 1 / 256
 423+ 0290 CD AD 6D                             call    mulDbyESigned               ; calcualte DE = Vector * angle /256
 424+ 0293 FD 6E 00 FD                          ld      hl,(iy+0)                   ; hl = vector 2
 424+ 0297 66 01
 425+ 0299 CD 00 00                             call    SubDEfromHLSigned           ; hl = vector 2 - (vector 1 * angle / 256)
 426+ 029C FD 75 00 FD                          ld      (iy+0),hl                   ; .
 426+ 02A0 74 01
 427+ 02A2 F1           .processVector2:        pop     af
 428+ 02A3 5F                                   ld      e,a                         ; e = angle
 429+ 02A4 FD 56 01                             ld      d,(iy+1)                    ; d = vector 2 / 256
 430+ 02A7 CD AD 6D                             call    mulDbyESigned               ; de = vector 2 * angle /256
 431+ 02AA DD 6E 00 DD                          ld      hl,(ix+0)                   ; hl = vector 1
 431+ 02AE 66 01
 432+ 02B0 CD 04 00                             call    AddDEtoHLSigned             ; hl = hl + de
 433+ 02B3 DD 75 00 DD                          ld      (ix+0),hl                   ; .
 433+ 02B7 74 01
 434+ 02B9 C9                                   ret
 435+ 02BA
 436+ 02BA              ; Applies Roll Alpha and Pitch Beta to vector at IX
 437+ 02BA              ApplyRollAndPitchToIX:
 438+ 02BA              ;-- y Vector = y - alpha * nosev_x_hi
 439+ 02BA DD 5E 01                             ld      e,(ix+1)                    ; e = X component hi
 440+ 02BD 3A 78 68                             ld      a,(ALPHA)                   ; alpha S7
 441+ 02C0 57                                   ld      d,a
 442+ 02C1 CD AD 6D                             call    mulDbyESigned               ; d = X Vector * alpha / 256
 443+ 02C4 DD 6E 02                             ld      l,(ix+2)                    ; hl = Y Vector component
 444+ 02C7 DD 66 03                             ld      h,(ix+3)                    ;
 445+ 02CA CD 00 00                             call    SubDEfromHLSigned           ; hl = Y - (alpha * nosev x hi)
 446+ 02CD DD 75 02                             ld      (ix+2),l
 447+ 02D0 DD 74 03                             ld      (ix+3),h
 448+ 02D3              ;-- x Vector = x Vector + alpha * y_hi
 449+ 02D3 DD 5E 03                             ld      e,(ix+3)                    ; e = y component hi
 450+ 02D6 3A 78 68                             ld      a,(ALPHA)                   ; alpha S7
 451+ 02D9 57                                   ld      d,a
 452+ 02DA CD AD 6D                             call    mulDbyESigned               ; d = y Vector * alpha / 256
 453+ 02DD DD 6E 02                             ld      l,(ix+2)                    ; hl = x Vector component
 454+ 02E0 DD 66 03                             ld      h,(ix+3)                    ;
 455+ 02E3 CD 04 00                             call    AddDEtoHLSigned             ; hl = x + (alpha * nosev x hi)
 456+ 02E6 DD 75 00                             ld      (ix+0),l
 457+ 02E9 DD 74 01                             ld      (ix+1),h
 458+ 02EC              ;-- nosev_y = nosev_y - beta * nosev_z_hi
 459+ 02EC DD 5E 05                             ld      e,(ix+5)                    ; e = z component hi
 460+ 02EF 3A 6B 68                             ld      a,(BETA)                    ; beta S7
 461+ 02F2 57                                   ld      d,a
 462+ 02F3 CD AD 6D                             call    mulDbyESigned               ; d = Z Vector * beta / 256
 463+ 02F6 DD 6E 02                             ld      l,(ix+2)                    ; hl = y Vector component
 464+ 02F9 DD 66 03                             ld      h,(ix+3)                    ;
 465+ 02FC CD 00 00                             call    SubDEfromHLSigned           ; hl = Y - (beta * nosev z hi)
 466+ 02FF DD 75 02                             ld      (ix+2),l
 467+ 0302 DD 74 03                             ld      (ix+3),h
 468+ 0305              ;-- nosev_z = nosev_z + beta * nosev_y_hi
 469+ 0305 DD 5E 03                             ld      e,(ix+3)                    ; e = y component hi
 470+ 0308 3A 6B 68                             ld      a,(BETA)                    ; beta S7
 471+ 030B 57                                   ld      d,a
 472+ 030C CD AD 6D                             call    mulDbyESigned               ; d = y Vector * beta / 256
 473+ 030F DD 6E 04                             ld      l,(ix+4)                    ; hl = z Vector component
 474+ 0312 DD 66 05                             ld      h,(ix+5)                    ;
 475+ 0315 CD 04 00                             call    AddDEtoHLSigned             ; hl = z + (beta * nosev z hi)
 476+ 0318 DD 75 04                             ld      (ix+4),l
 477+ 031B DD 74 05                             ld      (ix+5),h
 478+ 031E C9                                   ret
 479+ 031F
 480+ 031F
# file closed: ../../Maths/MathsBankedFns.asm
 962  031F                                  DISPLAY "Bank ",MathsBankedFnsAddr," - Bytes free ",/D, $2000 - ($-MathsBankedFnsAddr), " - BankMathsBankedAdd"
 963  031F                                  ASSERT $-MathsBankedFnsAddr <8912, Bank code leaks over 8K boundary
 964  031F
 965  031F                  SAVENEX OPEN "3DTest.nex", EliteNextStartup , TopOfStack
 966  031F                  SAVENEX CFG  0,0,0,1
 967  031F                  SAVENEX AUTO
 968  031F                  SAVENEX CLOSE
 969  031F                  DISPLAY "Main Non Banked Code End ", MainNonBankedCodeEnd , " Bytes free ", 0B000H - MainNonBankedCodeEnd
 970  031F                  ASSERT MainNonBankedCodeEnd < 0B000H, Program code leaks intot interrup vector table
 971  031F
# file closed: 3DTest.asm
