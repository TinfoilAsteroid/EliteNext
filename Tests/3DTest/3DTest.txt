# file opened: 3DTest.asm
   1  0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
   2  0000                              DISPLAY "3D Test Code"
   3  0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
   4  0000                              DISPLAY "TODO: Odd Single pixel bug "
   5  0000                  DEVICE ZXSPECTRUMNEXT
   6  0000                  SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
   7  0000
   8  0000
   9  0000                  DEFINE  SHIP_DRAW_FULL_SCREEN 1
  10  0000                  DEFINE  USE_NORMALISE_IX  1
  11  0000                  DEFINE  INTERRUPS_DISABLE 1
  12  0000                  DEFINE  DEBUG_NO_TACTICS_CODE 1
  13  0000               CSPECTMAP 3DTest.map
  14  0000               OPT --zxnext=cspect --syntax=a --reversepop
  15  0000              ;-- Key Definitions
  16  0000              ;   Q/A pitch       O/P roll        W/A Thrust
  17  0000              ;   T/G ship pitch, F/H ship roll   U/J Ship Thrust
  18  0000              ;   P   Cycle through ships
  19  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  20  0000              ; Game Defines
  21  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  22  0000              ; Colour Defines
  23  0000                                      INCLUDE "../../Hardware/L2ColourDefines.asm"
# file opened: ../../Hardware/L2ColourDefines.asm
   1+ 0000              L2ColourBLACK           EQU   0
   2+ 0000              L2ColourRED_1           EQU 224                 ; RGB 255,  0,  0
   3+ 0000              L2ColourRED_2           EQU 192                 ; RGB 218,  0,  0
   4+ 0000              L2ColourRED_3           EQU 160                 ; RGB 182,  0,  0
   5+ 0000              L2ColourRED_4           EQU 128                 ; RGB 145,  0,  0
   6+ 0000              L2ColourRED_5           EQU  96                 ; RGB 109,  0,  0
   7+ 0000              L2ColourRED_6           EQU  64                 ; RGB  72,  0,  0
   8+ 0000              L2ColourRED_7           EQU  32                 ; RGB  36,  0,  0
   9+ 0000              L2ColourYELLOW_1        EQU 252                 ; RGB 255,255,  0
  10+ 0000              L2ColourYELLOW_2        EQU 216                 ; RGB 218,218,  0
  11+ 0000              L2ColourYELLOW_3        EQU 180                 ; RGB 182,182,  0
  12+ 0000              L2ColourYELLOW_4        EQU 144                 ; RGB 145,145,  0
  13+ 0000              L2ColourYELLOW_5        EQU 108                 ; RGB 109.109,  0
  14+ 0000              L2ColourYELLOW_6        EQU  72                 ; RGB  72, 72,  0
  15+ 0000              L2ColourYELLOW_7        EQU  36                 ; RGB  36, 36,  0
  16+ 0000              L2ColourGREEN_1		    EQU  28                 ; RGB   0,255,  0
  17+ 0000              L2ColourGREEN_2		    EQU  24                 ; RGB   0,218,  0
  18+ 0000              L2ColourGREEN_3		    EQU  16                 ; RGB   0,145,  0
  19+ 0000              L2ColourGREEN_4         EQU  12                 ; RGB   0,109,  0
  20+ 0000              L2ColourGREEN_5         EQU   8                 ; RGB   0, 72,  0
  21+ 0000              L2ColourGREEN_6         EQU   4                 ; RGB   0, 36,  0
  22+ 0000              L2ColourBLUE_1          EQU   3                 ; RGB 0,0,255
  23+ 0000              L2ColourBLUE_2          EQU   2                 ; RGB 0,0,170
  24+ 0000              L2ColourBLUE_3          EQU   1                 ; RGB 0,0,85
  25+ 0000
  26+ 0000
  27+ 0000              L2ColourWHITE_1         EQU 255                 ; RGB 255,255,255
  28+ 0000              L2ColourWHITE_2         EQU 146
  29+ 0000              L2ColourGREY_1		    EQU L2ColourWHITE_2
  30+ 0000              L2ColourGREY_2		    EQU 109
  31+ 0000              L2ColourGREY_3		    EQU  73
  32+ 0000              L2ColourGREY_4		    EQU  37
  33+ 0000
  34+ 0000              L2ColourGREEN_MB        EQU  29                 ;RGB 0,255,85
  35+ 0000              L2ColourGREEN_MR        EQU 124                 ;RGB 109.255,0
  36+ 0000              L2ColourCREAM_1         EQU 218                 ; RGB 218,218,170
  37+ 0000              L2ColourCREAM_2         EQU 182                 ; RGB 182,182,170
  38+ 0000              L2ColourCREAM_3         EQU 146                 ; RGB 145,145,170
  39+ 0000
  40+ 0000              L2ColourTRANSPARENT     EQU 227                 ; RGB 255,  0,255
  41+ 0000              L2ColourMAGENTA_1       EQU 162                 ; RGB 182,  0,170
  42+ 0000              L2ColourMAGENTA_2       EQU 130                 ; RGB 145,  0,170
  43+ 0000              L2ColourMAGENTA_3       EQU  97                 ; RGB 109,  0, 85
  44+ 0000              L2ColourMAGENTA_4       EQU  65                 ; RGB  72,  0, 85
  45+ 0000              L2ColourORANGE_1        EQU 236                 ; RGB
  46+ 0000              L2ColourORANGE_2        EQU 168                 ; RGB
  47+ 0000              L2ColourORANGE_3        EQU  68                 ; RGB
  48+ 0000              L2ColourCYAN_1          EQU  31                 ; RGB   0,255, 255
  49+ 0000              L2ColourCYAN_2          EQU  18                 ; RGB
  50+ 0000              L2ColourCYAN_3          EQU   9                 ; RGB
  51+ 0000              L2ColourPURPLE_1        EQU 109                 ; RGB
  52+ 0000              L2ColourPURPLE_2        EQU  66                 ; RGB
  53+ 0000              L2ColourPURPLE_3        EQU  33                 ; RGB
  54+ 0000              L2ColourPINK_1		    EQU 231                 ; RGB
  55+ 0000              L2ColourPINK_2		    EQU 226                 ; RGB
  56+ 0000              L2ColourPINK_3		    EQU 225                 ; RGB
  57+ 0000              L2ColourPINK_4		    EQU 224                 ; RGB
  58+ 0000
# file closed: ../../Hardware/L2ColourDefines.asm
  24  0000                                      INCLUDE "../../Hardware/L1ColourDefines.asm"
# file opened: ../../Hardware/L1ColourDefines.asm
   1+ 0000
   2+ 0000              L1ColourInkBlack        EQU %00000000
   3+ 0000              L1ColourInkBlue         EQU %00000001
   4+ 0000              L1ColourInkRed          EQU %00000010
   5+ 0000              L1ColourInkMagenta      EQU %00000011
   6+ 0000              L1ColourInkGreen        EQU %00000100
   7+ 0000              L1ColourInkCyan         EQU %00000101
   8+ 0000              L1ColourInkYellow       EQU %00000110
   9+ 0000              L1ColourInkWhite        EQU %00000111
  10+ 0000              L1ColourPaperBlack      EQU %00000000
  11+ 0000              L1ColourPaperBlue       EQU %00001000
  12+ 0000              L1ColourPaperRed        EQU %00010000
  13+ 0000              L1ColourPaperMagenta    EQU %00011000
  14+ 0000              L1ColourPaperGreen      EQU %00100000
  15+ 0000              L1ColourPaperCyan       EQU %00101000
  16+ 0000              L1ColourPaperYellow     EQU %00110000
  17+ 0000              L1ColourPaperWhite      EQU %00111000
  18+ 0000              L1ColourFlash           EQU %10000000
  19+ 0000              L1ColourBright          EQU %01000000
  20+ 0000              ;----------------------------------------------------------------------------------------------------------------------------------
  21+ 0000              ; Screen Specific Colour Defines
  22+ 0000              L1InvHighlight          EQU L1ColourBright | L1ColourPaperRed   | L1ColourInkYellow
  23+ 0000              L1InvLowlight           EQU                  L1ColourPaperBlack | L1ColourInkWhite
# file closed: ../../Hardware/L1ColourDefines.asm
  25  0000                                      INCLUDE "../../Hardware/register_defines.asm"
# file opened: ../../Hardware/register_defines.asm
   1+ 0000              ; Peripheral 2
   2+ 0000              ENABLE_CPU_SPEED_MODE                   EQU %10000000
   3+ 0000              DIVERT_BEEP_ONLY                        EQU %01000000
   4+ 0000              ENABLE_50_60_SWITCH                     EQU %00100000
   5+ 0000              ENABLE_MMCAUTO_SWITCH                   EQU %00010000
   6+ 0000              ENABLE_MULTIFACE_M1                     EQU %00001000
   7+ 0000              PS2MODE_KEYBOARD                        EQU %00000000
   8+ 0000              PS2MODE_MOUSE                           EQU %00000100
   9+ 0000              AUDIO_CHIPMODE_YM                       EQU %00000000
  10+ 0000              AUDIO_CHIPMODE_AY                       EQU %00000001
  11+ 0000              AUDIO_CHIPMODE_DISABLED                 EQU %00000010
  12+ 0000              INTERNAL_SPEAKER_ENABLE                 EQU %00010000
  13+ 0000              ; Peripheral 3
  14+ 0000              UNLOCK_PORT_7FFD_PAGING                 EQU %10000000
  15+ 0000              DISABLE_RAM_IO_CONTENTION               EQU %01000000
  16+ 0000              AY_STEREO_MODE_ACB                      EQU %00100000
  17+ 0000              INTERNAL_SPEAKER                        EQU %00010000
  18+ 0000              ENABLE_DACS                             EQU %00001000
  19+ 0000              ENABLE_TIMEX_VIDEO_MODE                 EQU %00000100
  20+ 0000              ENABLE_TURBO_SOUND                      EQU %00000010
  21+ 0000              ENABLE_ISSUE2_KEYBOARD                  EQU %00000001
  22+ 0000              ; Peripheral 4
  23+ 0000              ENABLE_AY2_MONO                         EQU %10000000
  24+ 0000              ENABLE_AY1_MONO                         EQU %01000000
  25+ 0000              ENABLE_AY0_MONO                         EQU %00100000
  26+ 0000              SPRITE_ID_LOCKSTEP                      EQU %00010000
  27+ 0000              RESET_DIVMMC_MAPRAM                     EQU %00001000
  28+ 0000              SILENCE_HDMI_AUDIO                      EQU %00000100
  29+ 0000              SCALLINES_50PCT                         EQU %00000001
  30+ 0000              SCANLINES_25PCT                         EQU %00000010
  31+ 0000              SCANLINES_125PCT                        EQU %00000011
  32+ 0000              ; Audio Registers
  33+ 0000              CHANNEL_A_FINE                          EQU 0
  34+ 0000              CHANNEL_A_COARSE                        EQU 1
  35+ 0000              CHANNEL_B_FINE                          EQU 2
  36+ 0000              CHANNEL_B_COARSE                        EQU 3
  37+ 0000              CHANNEL_C_FINE                          EQU 4
  38+ 0000              CHANNEL_C_COARSE                        EQU 5
  39+ 0000              NOISE_PERIOD                            EQU 6
  40+ 0000              TONE_ENABLE                             EQU 7
  41+ 0000              CHANNEL_A_AMPLITUDE                     EQU 8
  42+ 0000              CHANNEL_B_AMPLITUDE                     EQU 9
  43+ 0000              CHANNEL_C_AMPLITUDE                     EQU 10
  44+ 0000              ENVELOPE_PERIOD_FINE                    EQU 11
  45+ 0000              ENVELOPE_PERIOD_COARSE                  EQU 12
  46+ 0000              ENVELOPE_SHAPE                          EQU 13
  47+ 0000
  48+ 0000              ENVELOPE_HOLD_ON                        EQU 1
  49+ 0000              ENVELOPE_ALTERNATE_ON                   EQU 2
  50+ 0000              ENVELOPE_ATTACK_ON                      EQU 4
  51+ 0000              ENVELOPE_CONTINUE_ON                    EQU 8
  52+ 0000
  53+ 0000              ENVELOPE_SHAPE_SINGLE_DECAY             EQU 0                                                                                    ; \____________
  54+ 0000              ENVELOPE_SHAPE_SINGLE_ATTACK            EQU                        ENVELOPE_ATTACK_ON                                            ; /|___________
  55+ 0000              ENVELOPE_SHAPE_REPEAT_DECAY             EQU ENVELOPE_CONTINUE_ON                                                                 ; \|\|\|\|\|\|\
  56+ 0000              ENVELOPE_SHAPE_REPEAT_DECAY_ATTACK      EQU ENVELOPE_CONTINUE_ON |                      ENVELOPE_ALTERNATE_ON                    ; \/\/\/\/\/\/\
  57+ 0000              ENVELOPE_SHAPE_SINGLE_DECAY_HOLD        EQU ENVELOPE_CONTINUE_ON |                      ENVELOPE_ALTERNATE_ON | ENVELOPE_HOLD_ON ; \|-----------
  58+ 0000              ENVELOPE_SHAPE_REPEAT_ATTACK            EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON                                            ; /|/|/|/|/|/|/|
  59+ 0000              ENVELOPE_SHAPE_SINGLE_ATTACK_HOLD       EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON |                         ENVELOPE_HOLD_ON ; /------------
  60+ 0000              ENVELOPE_SHAPE_REPEAT_ATTACK_DECAY      EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON | ENVELOPE_ALTERNATE_ON                    ; /\/\/\/\/\/\/
  61+ 0000
  62+ 0000              ENVELOPE_HOLD                           EQU %00000001
  63+ 0000              ENVELOPE_ALTERNATE                      EQU %00000010
  64+ 0000              ENVELOPE_ATTACK                         EQU %00000010
  65+ 0000              ENVELOPE_CONTINUE                       EQU %00000010
  66+ 0000              ; Sound Control
  67+ 0000              TONE_CHANNEL_A                          EQU %00000001
  68+ 0000              TONE_CHANNEL_B                          EQU %00000010
  69+ 0000              TONE_CHANNEL_C                          EQU %00000100
  70+ 0000              NOISE_CHANNEL_A                         EQU %00001000
  71+ 0000              NOISE_CHANNEL_B                         EQU %00010000
  72+ 0000              NOISE_CHANNEL_C                         EQU %00100000
  73+ 0000              ; Version for AND to enabled (its inverted)
  74+ 0000              TONE_CHANNEL_A_ON                       EQU %11111110
  75+ 0000              TONE_CHANNEL_B_ON                       EQU %11111101
  76+ 0000              TONE_CHANNEL_C_ON                       EQU %11111011
  77+ 0000              NOISE_CHANNEL_A_ON                      EQU %11110111
  78+ 0000              NOISE_CHANNEL_B_ON                      EQU %11101111
  79+ 0000              NOISE_CHANNEL_C_ON                      EQU %11011111
  80+ 0000
  81+ 0000              ; Turbo Sound Control
  82+ 0000              TURBO_MANDATORY                         EQU %10011100
  83+ 0000              TURBO_LEFT                              EQU %01000000
  84+ 0000              TURBO_RIGHT                             EQU %00100000
  85+ 0000              TURBO_CHIP_AY3                          EQU %00000011
  86+ 0000              TURBO_CHIP_AY2                          EQU %00000010
  87+ 0000              TURBO_CHIP_AY1                          EQU %00000001
  88+ 0000
  89+ 0000              IO_LAYER2_PORT                          EQU $123B
  90+ 0000              IO_EXT_BANK_PORT 			            EQU $DFFD ; 57341
  91+ 0000              IO_BANK_PORT                            EQU $7FFD ; 32765
  92+ 0000              REGISTER_NUMBER_PORT					EQU $243B
  93+ 0000              REGISTER_VALUE_PORT						EQU $253B
  94+ 0000              SPRITE_SLOT_PORT						EQU $303B ; port for sprite and pattern index
  95+ 0000              SPRITE_INFO_PORT                        EQU $0057
  96+ 0000              SPRITE_PATTERN_UPLOAD_PORT				EQU $005B
  97+ 0000              TURBO_SOUND_NEXT_CONTROL                EQU $FFFD
  98+ 0000              SOUND_CHIP_REGISTER_WRITE               EQU $BFFD
  99+ 0000              IO_KEYBOARD_PORT                        EQU $FE
 100+ 0000              IO_DATAGEAR_DMA_PORT 		            EQU $6B
 101+ 0000              UART_TX_PORT_PORT                       EQU $133B
 102+ 0000              UART_RX_PORT_PORT                       EQU $143B
 103+ 0000              UART_CONTROL_PORT                       EQU $153B
 104+ 0000              UART_FRAME_PORT                         EQU $163B
 105+ 0000              CTC_CHANNEL1_PORT                       EQU $183B
 106+ 0000              CTC_CHANNEL2_PORT                       EQU $193B
 107+ 0000              CTC_CHANNEL3_PORT                       EQU $1A3B
 108+ 0000              CTC_CHANNEL4_PORT                       EQU $1B3B
 109+ 0000              PLUS_3_MEMORY_PAGING_CONTROL_PORT       EQU $1FFD
 110+ 0000              MB02_DMA_PORT                           EQU $0B
 111+ 0000              SPECDRUM_DAC_OUTPUT                     EQU $DF
 112+ 0000
 113+ 0000              Speed_3_5MHZ                            EQU 0
 114+ 0000              Speed_7MHZ                              EQU 1
 115+ 0000              Speed_14MHZ                             EQU 2
 116+ 0000              Speed_28MHZ                             EQU 3
 117+ 0000
 118+ 0000
 119+ 0000              MACHINE_ID_REGISTER						EQU $00
 120+ 0000              VERSION_REGISTER						EQU $01
 121+ 0000              RESET_REGISTER		    				EQU $02
 122+ 0000              MACHINE_TYPE_REGISTER					EQU $03
 123+ 0000              PAGE_RAM_REGISTER						EQU $04
 124+ 0000              PERIPHERAL_1_REGISTER					EQU $05   ; Sets joystick mode, video frequency and Scandoubler
 125+ 0000              PERIPHERAL_2_REGISTER					EQU $06   ; Enables CPU Speed key, DivMMC, Multiface, Mouse and AY audio.
 126+ 0000              TURBO_MODE_REGISTER						EQU $07
 127+ 0000              PERIPHERAL_3_REGISTER					EQU $08   ; ABC/ACB Stereo, Internal Speaker, SpecDrum, Timex Video Modes, Turbo Sound Next, RAM contention and [un]lock 128k paging
 128+ 0000              PERIPHERAL_4_REGISTER                   EQU $09   ; Sets scanlines, AY mono output, Sprite-id lockstep, reset DivMMC mapram and disable HDMI audio
 129+ 0000              PERIPHERAL_5_REGISTER                   EQU $0A  ; Mouse
 130+ 0000              CORE_VERSION_REGISTER                   EQU $0E
 131+ 0000              ANTI_BRICK_SYSTEM_REGISTER				EQU $10
 132+ 0000              VIDEO_TIMING_REGISTER                   EQU $11
 133+ 0000              LAYER2_RAM_PAGE_REGISTER				EQU $12
 134+ 0000              LAYER2_RAM_SHADOW_REGISTER      		EQU $13
 135+ 0000              TRANSPARENCY_COLOUR_REGISTER			EQU $14
 136+ 0000              SPRITE_LAYERS_SYSTEM_REGISTER			EQU $15
 137+ 0000              LAYER2_OFFSET_X_REGISTER				EQU $16
 138+ 0000              LAYER2_OFFSET_Y_REGISTER				EQU $17
 139+ 0000              CLIP_WINDOW_LAYER2_REGISTER				EQU $18
 140+ 0000              CLIP_WINDOW_SPRITES_REGISTER			EQU $19
 141+ 0000              CLIP_WINDOW_ULA_REGISTER				EQU $1A
 142+ 0000              CLIP_WINDOW_TILEMAP_REGISTER            EQU $1B
 143+ 0000              CLIP_WINDOW_CONTROL_REGISTER			EQU $1C
 144+ 0000              ;29 not used
 145+ 0000              ACTIVE_VIDEO_LINE_MSB_REGISTER			EQU $1E
 146+ 0000              ACTIVE_VIDEO_LINE_LSB_REGISTER			EQU $1F
 147+ 0000              ; 32 to 34 not used
 148+ 0000              LINE_INTERRUPT_CONTROL_REGISTER			EQU $22
 149+ 0000              LINE_INTERRUPT_VALUE_LSB_REGISTER		EQU $23
 150+ 0000              ULA_X_OFFSET_REGISTER                   EQU $26
 151+ 0000              ULA_Y_OFFSET_REGSITER                   EQU $27
 152+ 0000              KEYMAP_HIGH_ADDRESS_REGISTER			EQU $28
 153+ 0000              KEYMAP_LOW_ADDRESS_REGISTER				EQU $29
 154+ 0000              KEYMAP_HIGH_DATA_REGISTER				EQU $2A
 155+ 0000              KEYMAP_LOW_DATA_REGISTER				EQU $2B
 156+ 0000              DAC_B_MIRROR_REGISTER                   EQU $2C
 157+ 0000              DAC_AB_MIRROR_REGISTER                  EQU $2D
 158+ 0000              DAC_C_MORROR_REGISTER                   EQU $2E
 159+ 0000              TILEMAP_OFFSET_XMSB_REGISTER            EQU $2F
 160+ 0000              TILEMAP_OFFSET_XLSB_REGISTER            EQU $30
 161+ 0000              TILEMAP_OFFSET_YMSB_REGISTER            EQU $31
 162+ 0000              LORES_OFFSET_X_REGISTER					EQU $32
 163+ 0000              LORES_OFFSET_Y_REGISTER					EQU $33
 164+ 0000              SPRITE_PORT_INDEX_REGISTER              EQU $34
 165+ 0000              SPRITE_PORT_ATTR0_REGISTER              EQU $35
 166+ 0000              SPRITE_PORT_ATTR1_REGISTER              EQU $36
 167+ 0000              SPRITE_PORT_ATTR2_REGISTER              EQU $37
 168+ 0000              SPRITE_PORT_ATTR3_REGISTER              EQU $38
 169+ 0000              SPRITE_PORT_ATTR4_REGISTER              EQU $39
 170+ 0000              PALETTE_INDEX_REGISTER					EQU $40
 171+ 0000              PALETTE_VALUE_8BIT_REGISTER				EQU $41
 172+ 0000              PALETTE_FORMAT_REGISTER					EQU $42
 173+ 0000              PALETTE_CONTROL_REGISTER				EQU $43
 174+ 0000              PALETTE_VALUE_9BIT_REGISTER				EQU $44
 175+ 0000              TRANSPARENCY_COLOUR_FALLBACK_REGISTER   EQU $4A
 176+ 0000              SPRITES_TRANSPARENCY_INDEX_REGISTER     EQU $4B
 177+ 0000              TILEMAP_TRANSPARENCY_INDEX_REGISTER     EQU $4C
 178+ 0000              ; 72 to 79 unused
 179+ 0000              MMU_SLOT_0_REGISTER						EQU $50
 180+ 0000              MMU_SLOT_1_REGISTER						EQU $51
 181+ 0000              MMU_SLOT_2_REGISTER						EQU $52
 182+ 0000              MMU_SLOT_3_REGISTER						EQU $53
 183+ 0000              MMU_SLOT_4_REGISTER						EQU $54
 184+ 0000              MMU_SLOT_5_REGISTER						EQU $55
 185+ 0000              MMU_SLOT_6_REGISTER						EQU $56
 186+ 0000              MMU_SLOT_7_REGISTER						EQU $57
 187+ 0000              ; 88 to 95 unused
 188+ 0000              COPPER_DATA_REGISTER					EQU $60
 189+ 0000              COPPER_CONTROL_LOW_REGISTER				EQU $61
 190+ 0000              COPPER_CONTROL_HIGH_REGISTER			EQU $62
 191+ 0000              COPPER_DATA_16BIT_WRITE_REGISTER        EQU $63
 192+ 0000              VERTICAL_VIDEO_LINE_OFFSET_REGISTER     EQU $64
 193+ 0000              ULA_CONTROL_REGISTER                    EQU $68
 194+ 0000              DISPLAY_CONTROL_1_REGISTER              EQU $69
 195+ 0000              LORES_CONTROL_REGISTER                  EQU $6A
 196+ 0000              TILEMAP_CONTROL_REGISTER                EQU $6B
 197+ 0000              DEFAULT_TILEMAP_ATTRIBUTE_REGISTER      EQU $6C
 198+ 0000              ; 109 unused
 199+ 0000              TILEMAP_BASE_ADDRESS_REGISTER           EQU $6E
 200+ 0000              TILE_DEFINITIONS_BASE_ADDRESS_REGISTER  EQU $6F
 201+ 0000              LAYER_2_CONTROL_REGISTER                EQU $70
 202+ 0000              LAYER_2_X_OFFSET_MSB_REGISTER           EQU $71
 203+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_0_WITH_INC EQU $75
 204+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_1_WITH_INC EQU $76
 205+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_2_WITH_INC EQU $77
 206+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_3_WITH_INC EQU $78
 207+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_4_WITH_INC EQU $79
 208+ 0000              USER_STORAGE_0_REGISTER                 EQU $7F ; general purpose variable, e.g. for copper
 209+ 0000              EXPANSION_BUS_ENABLE_REGISTER           EQU $80
 210+ 0000              EXPANSION_BUS_CONTROL_REGISTER          EQU $81
 211+ 0000              INTERNAL_PORT_DECODING_B0_7_REGISTER    EQU $82
 212+ 0000              INTERNAL_PORT_DECODING_B8_15_REGISTER   EQU $83
 213+ 0000              INTERNAL_PORT_DECODING_B16_23_REGISTER  EQU $84
 214+ 0000              INTERNAL_PORT_DECODING_B24_31_REGISTER  EQU $85
 215+ 0000              EXPANSION_BUS_DECODING_B0_7_REGISTER    EQU $86
 216+ 0000              EXPANSION_BUS_DECODING_B8_15_REGISTER   EQU $87
 217+ 0000              EXPANSION_BUS_DECODING_B16_23_REGISTER  EQU $88
 218+ 0000              EXPANSION_BUS_DECODING_B24_31_REGISTER  EQU $89
 219+ 0000              EXPANSION_BUS_IO_PROPAGE_REGISTER       EQU $8A
 220+ 0000              ALTERNATE_ROM_REGISTER                  EQU $8C
 221+ 0000              MEMORY_MAPPING_REGISTER                 EQU $8E
 222+ 0000              PI_GPI_OUTPUT_ENABLE_0_REIGISTER        EQU $98
 223+ 0000              PI_GPI_OUTPUT_ENABLE_1_REIGISTER        EQU $99
 224+ 0000              PI_GPI_OUTPUT_ENABLE_2_REIGISTER        EQU $9A
 225+ 0000              PI_GPI_OUTPUT_ENABLE_3_REIGISTER        EQU $9B
 226+ 0000              PI_PERPIPHERAL_ENABLE_REGISTER          EQU $A0
 227+ 0000              PI_I2S_AUDIO_CONTROL_REGISTER           EQU $A2
 228+ 0000              PI_I2S_CLOCK_DIVIDE_REGISTER            EQU $A3
 229+ 0000              ESP_WIFI_GPIO_OUTPUT_REGISTER           EQU $A8
 230+ 0000              ESP_WIFI_GPIO_REGISTER                  EQU $A9
 231+ 0000              EXTENDED_KEYS_0_REGISTER                EQU $B0
 232+ 0000              EXTENDED_KEYS_1_REGISTER                EQU $B1
 233+ 0000              DIVMMC_TRAP_ENABLE_1                    EQU $B2
 234+ 0000              DIVMMC_TRAP_ENABLE_2                    EQU $B4
 235+ 0000              DEBUG_LED_CONTROL_REGISTER              EQU $FF
 236+ 0000
 237+ 0000              INTERUPT_CONTROL                        EQU $0C ; Interrupt control
 238+ 0000              NMI_RETURN_LSB				            EQU	$0C2	; NMI Return Address LSB
 239+ 0000              NMI_RETURN_MSB				            EQU	$0C3	; NMI Return Address MSB
 240+ 0000              INTERRUPT_EN0				            EQU	$0C4	; INT EN 0
 241+ 0000              INTERRUPT_EN1				            EQU	$0C5	; INT EN 1
 242+ 0000              INTERRUPT_EN2				            EQU	$0C6	; INT EN 2
 243+ 0000              INTERRUPT_ST0				            EQU	$0C8	; INT status 0
 244+ 0000              INTERRUPT_ST1				            EQU	$0C9	; INT status 1
 245+ 0000              INTERRUPT_ST2				            EQU	$0CA	; INT status 2
 246+ 0000              INTERRUPT_DM0				            EQU	$0CC	; INT DMA EN 0
 247+ 0000              INTERRUPT_DM1				            EQU	$0CD	; INT DMA EN 1
 248+ 0000              INTERRUPT_DM2				            EQU	$0CE	; INT DMA EN 2
 249+ 0000              CTC_CHANNEL_0				            EQU	$183B	; CTC channel 0 port
 250+ 0000              CTC_CHANNEL_1				            EQU	$193B	; CTC channel 1 port
 251+ 0000              CTC_CHANNEL_2				            EQU	$1A3B	; CTC channel 2 port
 252+ 0000              CTC_CHANNEL_3				            EQU	$1B3B	; CTC channel 3 port
 253+ 0000              CTC_CHANNEL_4				            EQU	$1C3B	; CTC channel 4 port
 254+ 0000              CTC_CHANNEL_5				            EQU	$1D3B	; CTC channel 5 port
 255+ 0000              CTC_CHANNEL_6				            EQU	$1E3B	; CTC channel 6 port
 256+ 0000              CTC_CHANNEL_7				            EQU	$1F3B	; CTC channel 7 port
 257+ 0000              CTCBASE                                 EQU $c0		; MSB Base address of buffer
 258+ 0000              CTCSIZE                                 EQU $04 	; MSB buffer length
 259+ 0000              CTCEND                                  EQU CTCBASE+(CTCSIZE*2)
 260+ 0000
 261+ 0000
 262+ 0000              DEBUG_LEDS_REGISTER						EQU 255
 263+ 0000
 264+ 0000
 265+ 0000              GetNextRegSaveBC:	MACRO register
 266+ 0000 ~                                push bc
 267+ 0000 ~                                ld bc,$243B
 268+ 0000 ~                                ld a,register
 269+ 0000 ~                                out (c),a
 270+ 0000 ~                                inc b
 271+ 0000 ~                                in a,(c)
 272+ 0000 ~                                pop bc
 273+ 0000                                  ENDM
 274+ 0000
 275+ 0000              GetNextReg:	MACRO register
 276+ 0000 ~                        ld bc,$243B
 277+ 0000 ~                        ld a,register
 278+ 0000 ~                        out (c),a
 279+ 0000 ~                        inc b
 280+ 0000 ~                        in a,(c)
 281+ 0000                          ENDM
 282+ 0000
# file closed: ../../Hardware/register_defines.asm
  26  0000                                      INCLUDE "../../Layer2Graphics/layer2_defines.asm"
# file opened: ../../Layer2Graphics/layer2_defines.asm
   1+ 0000
   2+ 0000
   3+ 0000              LAYER2_SHIFTED_SCREEN_TOP  	 equ 0
   4+ 0000              LAYER2_SHIFTED_SCREEN_MIDDLE equ $40
   5+ 0000              LAYER2_SHIFTED_SCREEN_BOTTOM equ $80
   6+ 0000
   7+ 0000
   8+ 0000              ; note hi byte is not decoded on DMA port so can out OUTIR
   9+ 0000
  10+ 0000              IO_SPRITE_SLOT_PORT 		 equ 12347
  11+ 0000              IO_SPRITE_PATTERN_PORT       equ 91
  12+ 0000              IO_SPRITE_ATTRIBUTES_PORT    equ 87
  13+ 0000
  14+ 0000              LAYER2_VISIBLE_MASK 		equ $02
  15+ 0000              ; DEBUG 0 for always write to primary 08 for double buffering
  16+ 0000                  IFDEF DOUBLEBUFFER
  17+ 0000 ~            LAYER2_SHADOW_SCREEN_MASK 	equ $08
  18+ 0000                  ELSE
  19+ 0000              LAYER2_SHADOW_SCREEN_MASK 	equ $00
  20+ 0000                  ENDIF
  21+ 0000              LAYER2_READ_ENABLE_MASK 	equ %00000100
  22+ 0000              LAYER2_WRITE_ENABLE_MASK 	equ %00000001
  23+ 0000              LAYER2_READ_WRITE_MASK      equ %00000101
  24+ 0000              LAYER2_SCREEN_SECTION_MASK 	equ $03
  25+ 0000              LAYER2_SCREEN_SECTION_SHIFT equ 6
  26+ 0000
  27+ 0000              LAYER2_DISABLE_MEM_WRITE    equ %11111110
  28+ 0000              LAYER2_DISABLE_MEM_READ     equ %11111011
  29+ 0000              LAYER2_DISABLE_MEM_ACCESS   equ %11111010
  30+ 0000
  31+ 0000              LAYER2_SCREEN_BANK1          equ 8
  32+ 0000              LAYER2_SCREEN_BANK2          equ 9
  33+ 0000              LAYER2_SCREEN_BANK3          equ 10
  34+ 0000              LAYER2_SCREEN_BANK4          equ 11     ; used by 320 and 640 mode
  35+ 0000              LAYER2_SCREEN_BANK5          equ 12     ; used by 320 and 640 mode
  36+ 0000              LAYER2_SHADOW_BANK1          equ 13
  37+ 0000              LAYER2_SHADOW_BANK2          equ 14
  38+ 0000              LAYER2_SHADOW_BANK3          equ 15
  39+ 0000              LAYER2_SHADOW_BANK4          equ 16     ; used by 320 and 640 mode
  40+ 0000              LAYER2_SHADOW_BANK5          equ 17     ; used by 320 and 640 mode
  41+ 0000
  42+ 0000              SCREEN_HEIGHT 				 equ 192
  43+ 0000              SCREEN_RAM_BASE				 equ $0000
  44+ 0000              SCREEN_HOZ_MIN_PIX		     equ 10
  45+ 0000
  46+ 0000              SPRITES_VISIBLE_MASK         equ $01
  47+ 0000              SPRITES_ON_BORDER_MASK       equ $02
  48+ 0000              LAYER_PRIORITIES_MASK        equ $07
  49+ 0000              LORES_MODE_MASK              equ $80
  50+ 0000              LAYER_PRIORITIES_SHIFT       equ 2
  51+ 0000
  52+ 0000              LAYER_PRIORITIES_S_L_U 		equ 0
  53+ 0000              LAYER_PRIORITIES_L_S_U 		equ 1
  54+ 0000              LAYER_PRIORITIES_S_U_L  	equ 2
  55+ 0000              LAYER_PRIORITIES_L_U_S 		equ 3
  56+ 0000              LAYER_PRIORITIES_U_S_L 		equ 4
  57+ 0000              LAYER_PRIORITIES_U_L_S 		equ 5
  58+ 0000
  59+ 0000              DMA_WRO_BLOCK_PORTA_A2B_XFR  equ $7D
  60+ 0000              DMA_WRO_BLOCK_PORTA_B2A_XFR  equ $79
  61+ 0000              DMA_WR1_P1FIXED_MEMORY       equ $24
  62+ 0000              DMA_WR1_P1DEC_MEMORY         equ $04
  63+ 0000              DMA_WR1_P1INC_MEMORY         equ $14
  64+ 0000              DMA_WR2_P2FIXED_MEMORY       equ $20
  65+ 0000              DMA_WR2_P2DEC_MEMORY         equ $00
  66+ 0000              DMA_WR2_P2INC_MEMORY         equ $10
  67+ 0000              DMA_WR4_CONT_MODE            equ $AD
  68+ 0000              DMA_WR4_BURST_MODE           equ $CD
  69+ 0000              DMA_RESET                    equ $c3
  70+ 0000              DMA_RESET_PORT_A_TIMING      equ $c7
  71+ 0000              DMA_RESET_PORT_B_TIMING      equ $cb
  72+ 0000              DMA_LOAD                     equ $cf
  73+ 0000              DMA_CONTINUE                 equ $d3
  74+ 0000              DMA_DISABLE_INTERUPTS        equ $af
  75+ 0000              DMA_ENABLE_INTERUPTS         equ $ab
  76+ 0000              DMA_RESET_DISABLE_INTERUPTS  equ $a3
  77+ 0000              DMA_ENABLE_AFTER_RETI        equ $b7
  78+ 0000              DMA_READ_STATUS_BYTE         equ $bf
  79+ 0000              DMA_REINIT_STATUS_BYTE       equ $8b
  80+ 0000              DMA_START_READ_SEQUENCE      equ $a7
  81+ 0000              DMA_FORCE_READY              equ $b3
  82+ 0000              DMA_STOP_AT_END			     equ $82
  83+ 0000              DMA_DISABLE                  equ $83
  84+ 0000              DMA_ENABLE                   equ $87
  85+ 0000              DMA_WRITE_REGISTER_COMMAND   equ $bb
  86+ 0000              DMA_BURST                    equ $cd
  87+ 0000              DMA_CONTINUOUS               equ $ad
  88+ 0000              ZXN_DMA_PORT                 equ $6b
  89+ 0000
  90+ 0000
  91+ 0000              COLOUR_TRANSPARENT			 equ $E3
  92+ 0000
  93+ 0000
  94+ 0000
  95+ 0000
# file closed: ../../Layer2Graphics/layer2_defines.asm
  27  0000                                      INCLUDE	"../../Hardware/memory_bank_defines.asm"
# file opened: ../../Hardware/memory_bank_defines.asm
   1+ 0000
   2+ 0000              membanksize			    equ	$1FFF
   3+ 0000
   4+ 0000              StartOfBank     	    equ $0000
   5+ 0000
   6+ 0000              membank0 			    equ $0000
   7+ 0000              dmaCopySrcAddr		    equ	$0000
   8+ 0000              MathsTablesAddr         equ $0000
   9+ 0000              membank1 			    equ $2000
  10+ 0000              membank2 			    equ $4000
  11+ 0000              membank3 			    equ $6000
  12+ 0000              membank4 			    equ $8000
  13+ 0000              membank5 			    equ $a000
  14+ 0000              membank6 			    equ $c000
  15+ 0000              ScreenBank              equ $c000
  16+ 0000              MenuGalChtAddr          equ $c000
  17+ 0000              MenuEquipSAddr          equ $c000
  18+ 0000              MenuInventAddr          equ $c000
  19+ 0000              MenuMarketAddr          equ $c000
  20+ 0000              MenuShrChtAddr          equ $c000
  21+ 0000              MenuStatusAddr          equ $c000
  22+ 0000              MenuSystemAddr          equ $c000
  23+ 0000              ViewFrontAddr           equ $c000
  24+ 0000              SunBankAddr             equ $c000
  25+ 0000              PlanetBankAddr          equ $c000
  26+ 0000              SpaceStationBankAddr    equ $c000
  27+ 0000              UniverseBankAddr	    equ $c000
  28+ 0000              LaunchShipAddr          equ $c000
  29+ 0000              membank7 			    equ $e000
  30+ 0000              L1membankAddr   	    equ $e000
  31+ 0000              L2membankAddr   	    equ $e000
  32+ 0000              ShipModelsAddr	        equ $e000
  33+ 0000              SpritemembankAddr       equ $e000
  34+ 0000              ResetUniverseAddr       equ $e000
  35+ 0000              StockTableAddr	        equ $e000
  36+ 0000              CommanderAddr           equ $e000
  37+ 0000              LAYER2Addr              equ $e000
  38+ 0000              LAYER1Addr              equ $e000
  39+ 0000              SPRITEAddr              equ $e000
  40+ 0000              ConsoleImageAddr        equ $e000
  41+ 0000              GalaxyDataAddr          equ $e000
  42+ 0000              SoundAddr               equ $e000
  43+ 0000              KeyboardAddr            equ $e000
  44+ 0000              MathsBankedFnsAddr      equ $0000
  45+ 0000              PIFnsAddr               equ $e000
  46+ 0000              EquipmentTablesAddr     equ $e000
  47+ 0000
  48+ 0000              EXSDOSMMU0              equ MMU_SLOT_0_REGISTER
  49+ 0000              MathsTablesMMU          equ MMU_SLOT_0_REGISTER
  50+ 0000              MathsBankedFnsMMU       equ MMU_SLOT_0_REGISTER
  51+ 0000              ShipReadMMU             equ MMU_SLOT_0_REGISTER
  52+ 0000              DMACpySourceMMU		    equ	MMU_SLOT_0_REGISTER
  53+ 0000              EXSDOSMMU1              equ MMU_SLOT_1_REGISTER
  54+ 0000              SunMMU 		            equ MMU_SLOT_6_REGISTER
  55+ 0000              PlanetMMU 		        equ MMU_SLOT_6_REGISTER
  56+ 0000              UniverseMMU 		    equ MMU_SLOT_6_REGISTER
  57+ 0000              SpaceStationMMU         equ MMU_SLOT_6_REGISTER
  58+ 0000              ScreenBankMMU           equ MMU_SLOT_6_REGISTER
  59+ 0000              MenuEquipSMMU           equ MMU_SLOT_6_REGISTER
  60+ 0000              MenuShrChtMMU           equ MMU_SLOT_6_REGISTER
  61+ 0000              MenuGalChtMMU           equ MMU_SLOT_6_REGISTER
  62+ 0000              MenuInventMMU           equ MMU_SLOT_6_REGISTER
  63+ 0000              MenuSystemMMU           equ MMU_SLOT_6_REGISTER
  64+ 0000              MenuMarketMMU           equ MMU_SLOT_6_REGISTER
  65+ 0000              MenuStatusMMU           equ MMU_SLOT_6_REGISTER
  66+ 0000              LaunchShipMMU           equ MMU_SLOT_6_REGISTER
  67+ 0000              L1memMMU       		    equ MMU_SLOT_7_REGISTER
  68+ 0000              L2memMMU       		    equ MMU_SLOT_7_REGISTER
  69+ 0000              SpritememMMU   		    equ MMU_SLOT_7_REGISTER
  70+ 0000              ShipModelMMU  		    equ MMU_SLOT_7_REGISTER
  71+ 0000              ResetUniverseMMU	    equ MMU_SLOT_7_REGISTER
  72+ 0000              CommanderMMU	        equ MMU_SLOT_7_REGISTER
  73+ 0000              StockTableMMU		    equ MMU_SLOT_7_REGISTER
  74+ 0000              ConsoleImageDataMMU	    equ MMU_SLOT_7_REGISTER
  75+ 0000              GalaxyDataMMU	        equ MMU_SLOT_7_REGISTER
  76+ 0000              SoundMMU                equ MMU_SLOT_7_REGISTER
  77+ 0000              KeyboardMMU             equ MMU_SLOT_7_REGISTER
  78+ 0000              PIFnsMMU                equ	MMU_SLOT_7_REGISTER
  79+ 0000              EquipmentTablesMMU      equ MMU_SLOT_7_REGISTER
  80+ 0000
  81+ 0000              ; banks 8 to 17 are reserved for layer 2 memory
  82+ 0000              BankResetUniv           equ 49
  83+ 0000              BankMenuShrCht          equ 50
  84+ 0000              BankMenuGalCht          equ 51
  85+ 0000              BankMenuInvent          equ 52
  86+ 0000              BankMenuSystem          equ 53
  87+ 0000              BankMenuMarket          equ 54
  88+ 0000              BankStockTable          equ 55
  89+ 0000              BankCommander           equ 56
  90+ 0000              BankLAYER2              equ 57
  91+ 0000              BankLAYER1              equ 58
  92+ 0000              BankShipModels1         equ 59
  93+ 0000              BankSPRITE              equ 60
  94+ 0000              BankConsole             equ 61
  95+ 0000              BankFrontView           equ 62
  96+ 0000              BankMenuStatus          equ 63
  97+ 0000              BankMenuEquipS          equ 64
  98+ 0000              BankLaunchShip          equ 65
  99+ 0000              BankEquipmentTables     equ 66
 100+ 0000              BankShipModels2         equ 67
 101+ 0000              BankShipModels3         equ 68
 102+ 0000              BankShipModels4         equ 69
 103+ 0000
 104+ 0000              BankUNIVDATA0           equ 70
 105+ 0000              BankSpaceStationData    equ 70
 106+ 0000              BankUNIVDATA1           equ 71
 107+ 0000              BankUNIVDATA2           equ 72
 108+ 0000              BankUNIVDATA3           equ 73
 109+ 0000              BankUNIVDATA4           equ 74
 110+ 0000              BankUNIVDATA5           equ 75
 111+ 0000              BankUNIVDATA6           equ 76
 112+ 0000              BankUNIVDATA7           equ 77
 113+ 0000              BankUNIVDATA8           equ 78
 114+ 0000              BankUNIVDATA9           equ 79
 115+ 0000              BankUNIVDATA10          equ 80
 116+ 0000              BankUNIVDATA11          equ 81
 117+ 0000              BankUNIVDATA12          equ 82
 118+ 0000              BankSunData             equ 83
 119+ 0000              BankPlanetData          equ 84
 120+ 0000
 121+ 0000              BankGalaxyData0         equ 91
 122+ 0000              BankGalaxyData1         equ 92
 123+ 0000              BankGalaxyData2         equ 93
 124+ 0000              BankGalaxyData3         equ 94
 125+ 0000              BankGalaxyData4         equ 95
 126+ 0000              BankGalaxyData5         equ 96
 127+ 0000              BankGalaxyData6         equ 97
 128+ 0000              BankGalaxyData7         equ 98
 129+ 0000
 130+ 0000              BankMathsTables         equ 99
 131+ 0000              BankSound               equ 100
 132+ 0000              BankKeyboard            equ 101
 133+ 0000              BankMathsBankedFns      equ 102
 134+ 0000              BankPIFns               equ 103
 135+ 0000
 136+ 0000              BankROM                 equ 255
 137+ 0000
 138+ 0000
# file closed: ../../Hardware/memory_bank_defines.asm
  28  0000                                      INCLUDE "../../Hardware/screen_equates.asm"
# file opened: ../../Hardware/screen_equates.asm
   1+ 0000              ScreenHeight 		equ 192
   2+ 0000              ScreenLastRow       equ ScreenHeight -1
   3+ 0000              ScreenWidth  		equ 256
   4+ 0000              ScreenLastCol       equ ScreenWidth -1
   5+ 0000              ScreenHeightHalf	equ 96
   6+ 0000              ScreenWidthHalf  	equ 128
   7+ 0000              ScreenCenterY		equ 96
   8+ 0000              ScreenCenterX       equ 128
   9+ 0000              ViewHeight          equ 128
  10+ 0000              ViewHeightPlus1     equ 128+1
  11+ 0000              ViewLastRow       	equ ViewHeight -1
  12+ 0000              ViewWidth  			equ 256
  13+ 0000              ViewLastCol         equ ViewWidth -1
  14+ 0000              ViewHeightHalf      equ 63
  15+ 0000              ViewWidthHalf       equ 127
  16+ 0000              ViewCenterY         equ 64
  17+ 0000              ViewCenterX         equ 128
  18+ 0000                                      DISPLAY "TODO: place odler for debugging"
  19+ 0000              ShipColour			equ $FF		; place holder for debugging TODO
  20+ 0000              ScreenL1Bottom      equ $5000
  21+ 0000              ScreenL1BottomLen   equ 32 * 8 * 8
  22+ 0000              ScreenL1AttrBtm     equ $5A00
  23+ 0000              ScreenL1AttrBtmLen  equ 32 * 8
  24+ 0000
# file closed: ../../Hardware/screen_equates.asm
  29  0000                                      INCLUDE "../../Data/ShipModelEquates.asm"
# file opened: ../../Data/ShipModelEquates.asm
   1+ 0000              ScoopDebrisOffset	        equ	0                               ; hull byte#0 high nibble is scoop info, lower nibble is debris spin info
   2+ 0000              MissileLockLoOffset	        equ 1
   3+ 0000              MissileLockHiOffset	        equ 2
   4+ 0000              EdgeAddyOffset		        equ 3
   5+ 0000              LineX4Offset		        equ 5
   6+ 0000              GunVertexOffset		        equ 6
   7+ 0000              ExplosionCtOffset	        equ 7
   8+ 0000              VertexCountOffset           equ 8
   9+ 0000              VertexCtX6Offset	        equ 9
  10+ 0000              EdgeCountOffset		        equ 10
  11+ 0000              BountyLoOffset		        equ 11
  12+ 0000              BountyHiOffset		        equ 12
  13+ 0000              FaceCtX4Offset		        equ 13
  14+ 0000              DotOffset			        equ 14
  15+ 0000              EnergyOffset		        equ 15
  16+ 0000              SpeedOffset			        equ 16
  17+ 0000              FaceAddyOffset		        equ 17
  18+ 0000              QOffset				        equ 19
  19+ 0000              LaserOffset			        equ 20
  20+ 0000              VerticiesAddyOffset         equ 21
  21+ 0000              ShipTypeOffset              equ 23
  22+ 0000              ShipNewBitsOffset           equ 24
  23+ 0000              ShipAIFlagsOffset           equ 25
  24+ 0000              ShipECMFittedChanceOffset   equ 26
  25+ 0000              ShipSolidFlagOffset         equ 27 ; Intially for non cargo these will be garbage
  26+ 0000              ShipSolidFillOffset         equ 28
  27+ 0000              ShipSolidLenOffset          equ 29
  28+ 0000              ShipDataLength              equ ShipECMFittedChanceOffset+1
  29+ 0000
  30+ 0000              CobraTablePointer           equ 43
  31+ 0000              ;29 faulty
  32+ 0000              BankThreshold               equ 16
  33+ 0000
  34+ 0000              ShipTableALast              equ 23
  35+ 0000              ShipTableBLast              equ 39
  36+ 0000              ShipTableCLast              equ 55
  37+ 0000
# file closed: ../../Data/ShipModelEquates.asm
  30  0000                                      INCLUDE "../../Macros/graphicsMacros.asm"
# file opened: ../../Macros/graphicsMacros.asm
   1+ 0000              ; General Graphics macros
   2+ 0000              DoubleBufferIfPossible: MACRO
   3+ 0000 ~                                    IFDEF DOUBLEBUFFER
   4+ 0000 ~                                        MMUSelectLayer2
   5+ 0000 ~                                        call  l2_cls
   6+ 0000 ~                                        call  l2_flip_buffers
   7+ 0000 ~                                    ENDIF
   8+ 0000                                      ENDM
   9+ 0000
  10+ 0000              DoubleBuffer320IfPossible: MACRO
  11+ 0000 ~                                    IFDEF DOUBLEBUFFER
  12+ 0000 ~                                        MMUSelectLayer2
  13+ 0000 ~                                        call  l2_320_cls
  14+ 0000 ~                                        call  l2_flip_buffers
  15+ 0000 ~                                    ENDIF
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000                  IFDEF L2_640_SUPPORT
  19+ 0000 ~            DoubleBuffer640IfPossible: MACRO
  20+ 0000 ~                                    IFDEF DOUBLEBUFFER
  21+ 0000 ~                                        MMUSelectLayer2
  22+ 0000 ~                                        call  l2_640_cls
  23+ 0000 ~                                        call  l2_flip_buffers
  24+ 0000 ~                                    ENDIF
  25+ 0000 ~                                    ENDM
  26+ 0000                  ENDIF
  27+ 0000
  28+ 0000
  29+ 0000              ErrorEquStepMinusDelta: MACRO   delta_step, delta_value
  30+ 0000 ~                                    ld      hl,(delta_step)
  31+ 0000 ~                                    ld      de,(delta_value)
  32+ 0000 ~                                    ClearCarryFlag
  33+ 0000 ~                                    sbc     hl,de
  34+ 0000 ~                                    ld      (error),hl
  35+ 0000                                      ENDM
  36+ 0000
  37+ 0000              ; we could hold steps and deltas in alternate registers later
  38+ 0000              ErrorPlusStep:          MACRO   delta_step
  39+ 0000 ~                                    ld      hl,(error)
  40+ 0000 ~                                    ld      de,(delta_step)
  41+ 0000 ~                                    add     hl,de
  42+ 0000 ~                                    ld      (error),hl
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              ErrorMinusStep:         MACRO   delta_step
  46+ 0000 ~                                    ld      hl,(error)
  47+ 0000 ~                                    ld      de,(delta_step)
  48+ 0000 ~                                    ClearCarryFlag
  49+ 0000 ~                                    sbc     hl,de
  50+ 0000 ~                                    ld      (error),hl
  51+ 0000                                      ENDM
  52+ 0000
  53+ 0000              SetExitFalse:           MACRO
  54+ 0000 ~                                    xor     a
  55+ 0000 ~                                    ld      (set_exit),a
  56+ 0000                                      ENDM
  57+ 0000
  58+ 0000              ; pulls axis high byte to a, returns nz if negative, z if positive
  59+ 0000              IsAxisLT0:              MACRO   axis
  60+ 0000 ~                                    ld      a,(axis+1)
  61+ 0000 ~                                    and     $80
  62+ 0000                                      ENDM
  63+ 0000
  64+ 0000              ; modifies HL, loaded with register, returns z if >=0, nz if negative
  65+ 0000              IsMemld16GTE0           MACRO   mem
  66+ 0000 ~                                    ld      hl, (mem)
  67+ 0000 ~                                    bit     7,h
  68+ 0000                                      ENDM
  69+ 0000
  70+ 0000              IsMemNegative8JumpFalse:MACRO   mem, target
  71+ 0000 ~                                    ld      a,(mem)
  72+ 0000 ~                                    and     $80
  73+ 0000 ~                                    jp      z, target
  74+ 0000                                      ENDM
  75+ 0000
  76+ 0000              IsMem16GT0JumpFalse:    MACRO   mem, target
  77+ 0000 ~                                    ld      hl, (mem)
  78+ 0000 ~                                    bit     7,h
  79+ 0000 ~                                    jp      nz, target
  80+ 0000 ~                                    ld      a,h
  81+ 0000 ~                                    or      l
  82+ 0000 ~                                    jp      z,  target
  83+ 0000                                      ENDM
  84+ 0000
  85+ 0000              FloorHLdivDETarget:     MACRO   target
  86+ 0000 ~                                    call    l_div                   ;       .  (so we swap and call l_div) HL = DE / HL, DE = DE % HL
  87+ 0000 ~                                    ld      a,d                     ;       .  get bit 7 into carry (set if negative)
  88+ 0000 ~                                    sla     a                       ;
  89+ 0000 ~                                    jr      nc,.FloorIsOK           ;
  90+ 0000 ~            .FloorAdjust:           dec     hl                      ;       .  if remainder >= adjust by 1 for negative
  91+ 0000 ~            .FloorIsOK:             ld      (target),hl             ;       .  now save the msd value
  92+ 0000                                      ENDM
  93+ 0000
# file closed: ../../Macros/graphicsMacros.asm
  31  0000                                      INCLUDE "../../Macros/callMacros.asm"
# file opened: ../../Macros/callMacros.asm
   1+ 0000
   2+ 0000              CallIfAEqNusng:         MACRO   reg,target
   3+ 0000 ~                                    cp      reg
   4+ 0000 ~                                    call	z,target
   5+ 0000                                      ENDM
   6+ 0000
   7+ 0000              CallIfAGTENusng:        MACRO   reg,target
   8+ 0000 ~                                    cp      reg
   9+ 0000 ~                                    call	nc,target
  10+ 0000                                      ENDM
  11+ 0000
  12+ 0000              CallIfAGTEMemusng:      MACRO   reg,target
  13+ 0000 ~                                    ld      hl,reg
  14+ 0000 ~                                    cp      (hl)
  15+ 0000 ~                                    call	nc,target
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              CallIfALTMemusng:       MACRO   reg,target
  19+ 0000 ~                                    ld      hl,reg
  20+ 0000 ~                                    cp      (hl)
  21+ 0000 ~                                    call	c,target
  22+ 0000                                      ENDM
  23+ 0000
  24+ 0000              CallIfALTNusng:         MACRO   reg,target
  25+ 0000 ~                                    cp      reg
  26+ 0000 ~                                    call	c,target
  27+ 0000                                      ENDM
  28+ 0000
  29+ 0000              CallIfMemEqMemusng:     MACRO mem, address, target
  30+ 0000 ~                                    ld      a,(mem)
  31+ 0000 ~                                    ld      hl,address
  32+ 0000 ~                                    cp      (hl)
  33+ 0000 ~                                    call    z,target
  34+ 0000                                      ENDM
  35+ 0000
  36+ 0000              CallIfMemEqNusng:       MACRO mem, value, target
  37+ 0000 ~                                    ld      a,(mem)
  38+ 0000 ~                                    cp      value
  39+ 0000 ~                                    call    z,target
  40+ 0000                                      ENDM
  41+ 0000
  42+ 0000
  43+ 0000              CallIfMemGTENusng:      MACRO mem, value, target
  44+ 0000 ~                                    ld      a,(mem)
  45+ 0000 ~                                    cp      value
  46+ 0000 ~                                    call    nc,target
  47+ 0000                                      ENDM
  48+ 0000
  49+ 0000              CallIfMemTrue:          MACRO mem, target
  50+ 0000 ~                                    ld      a,(mem)
  51+ 0000 ~                                    and     a
  52+ 0000 ~                                    call    z, target
  53+ 0000                                      ENDM
  54+ 0000
  55+ 0000              CallIfMemFalse:         MACRO mem, target
  56+ 0000 ~                                    ld      a,(mem)
  57+ 0000 ~                                    and     a
  58+ 0000 ~                                    call    nz, target
  59+ 0000                                      ENDM
  60+ 0000
  61+ 0000              CallIfMemZero:          MACRO mem, target
  62+ 0000 ~                                    ld      a,(mem)
  63+ 0000 ~                                    and     a
  64+ 0000 ~                                    call    z, target
  65+ 0000                                      ENDM
  66+ 0000
  67+ 0000              CallIfMemNotZero:       MACRO mem, target
  68+ 0000 ~                                    ld      a,(mem)
  69+ 0000 ~                                    and     a
  70+ 0000 ~                                    call    nz, target
  71+ 0000                                      ENDM
  72+ 0000              CallIfATrue:            MACRO target
  73+ 0000 ~                                    and     a
  74+ 0000 ~                                    call    z, target
  75+ 0000                                      ENDM
  76+ 0000
  77+ 0000              CallIfAFalse:           MACRO target
  78+ 0000 ~                                    and     a
  79+ 0000 ~                                    call    nz, target
  80+ 0000                                      ENDM
  81+ 0000
  82+ 0000              CallIfAZero:            MACRO target
  83+ 0000 ~                                    and     a
  84+ 0000 ~                                    call    z, target
  85+ 0000                                      ENDM
  86+ 0000
  87+ 0000              CallIfANotZero:         MACRO target
  88+ 0000 ~                                    and     a
  89+ 0000 ~                                    call    nz, target
  90+ 0000                                      ENDM
# file closed: ../../Macros/callMacros.asm
  32  0000                                      INCLUDE "../../Macros/carryFlagMacros.asm"
# file opened: ../../Macros/carryFlagMacros.asm
   1+ 0000
   2+ 0000              SetCarryFlag:           MACRO
   3+ 0000 ~                                    scf
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              ClearCarryFlag:	        MACRO
   7+ 0000 ~                                    or a
   8+ 0000                                      ENDM
   9+ 0000
  10+ 0000              FlipCarryFlag:          MACRO
  11+ 0000 ~                                    ccf
  12+ 0000                                      ENDM
  13+ 0000
# file closed: ../../Macros/carryFlagMacros.asm
  33  0000                                      INCLUDE "../../Macros/CopyByteMacros.asm"
# file opened: ../../Macros/CopyByteMacros.asm
   1+ 0000              CopyByteAtHLixToA:		MACRO memloc
   2+ 0000 ~            						ex          de,hl                               ; save hl
   3+ 0000 ~            						ld          hl,memloc
   4+ 0000 ~            						add         hl,a
   5+ 0000 ~            						ld          a,(hl)                              ; get XX2[x]
   6+ 0000 ~            						ex          de,hl                               ; get hl back as we need it in loop
   7+ 0000              						ENDM
   8+ 0000
   9+ 0000              ; Increments IYL
  10+ 0000              ; Increments IHL
  11+ 0000              ; Gets value at hl and loads into Parameter 1 address
  12+ 0000
  13+ 0000              CopyByteAtNextHLiyl: 	MACRO memloc
  14+ 0000 ~            						inc         iyl                                 ;
  15+ 0000 ~            						inc         hl                                  ; vertex byte#1
  16+ 0000 ~            						ld          a,(hl)                              ;
  17+ 0000 ~            						ld          (memloc),a                     ; XX15+2 = (V),Y
  18+ 0000              						ENDM
  19+ 0000
  20+ 0000              ;------------------------------------------------------------------------------------------------------------------------------
  21+ 0000              CopyByteAtNextHL:   MACRO targetaddr
  22+ 0000 ~                                inc         hl                                  ; vertex byte#1
  23+ 0000 ~                                ld          a,(hl)                              ;
  24+ 0000 ~                                ld          (targetaddr),a                     ; SunXX15+2 = (V),Y
  25+ 0000                                  ENDM
# file closed: ../../Macros/CopyByteMacros.asm
  34  0000                                      INCLUDE "../../Macros/ldCopyMacros.asm"
# file opened: ../../Macros/ldCopyMacros.asm
   1+ 0000
   2+ 0000
   3+ 0000              SetATrue:               MACRO
   4+ 0000 ~                                    xor     a
   5+ 0000                                      ENDM
   6+ 0000
   7+ 0000              SetAFalse:              MACRO
   8+ 0000 ~                                    ld      a,$FF
   9+ 0000                                      ENDM
  10+ 0000
  11+ 0000              SetMemFalse             MACRO   mem
  12+ 0000 ~                                    ld      a,$FF
  13+ 0000 ~                                    ld      (mem),a
  14+ 0000                                      ENDM
  15+ 0000
  16+ 0000              SetMemTrue              MACRO   mem
  17+ 0000 ~                                    xor     a
  18+ 0000 ~                                    ld      (mem),a
  19+ 0000                                      ENDM
  20+ 0000
  21+ 0000              SetMemZero:             MACRO   mem
  22+ 0000 ~                                    xor     a
  23+ 0000 ~                                    ld      (mem),a
  24+ 0000                                      ENDM
  25+ 0000
  26+ 0000              SetMemToN:              MACRO   mem,value
  27+ 0000 ~                                    ld      a,value
  28+ 0000 ~                                    ld      (mem),a
  29+ 0000                                      ENDM
  30+ 0000
  31+ 0000              ldCopyStringLen:        MACRO   source, target, strlen
  32+ 0000 ~                                    ld      hl,source
  33+ 0000 ~                                    ld      de, target
  34+ 0000 ~                                    ld      bc, strlen
  35+ 0000 ~                                    ldir
  36+ 0000                                      ENDM
  37+ 0000
  38+ 0000              ldCopyTextAtHLtoDE:     MACRO
  39+ 0000 ~            .CopyLoop:              ld      a,(hl)
  40+ 0000 ~                                    ld      (de),a
  41+ 0000 ~                                    cp      0
  42+ 0000 ~                                    jp      z,.DoneCopy
  43+ 0000 ~                                    inc     hl
  44+ 0000 ~                                    inc     de
  45+ 0000 ~                                    jr      .CopyLoop
  46+ 0000 ~            .DoneCopy:
  47+ 0000                                      ENDM
  48+ 0000
  49+ 0000              ldClearTextLoop:        MACRO   TextSize
  50+ 0000 ~                                    ld      b,a
  51+ 0000 ~                                    ld      a,TextSize
  52+ 0000 ~            .ClearLoop:             ld      (hl),a
  53+ 0000 ~                                    inc     hl
  54+ 0000 ~                                    djnz    .ClearLoop
  55+ 0000                                      ENDM
  56+ 0000
  57+ 0000              ldCopyByte:             MACRO memfrom, memto
  58+ 0000 ~                                    ld       a,(memfrom)
  59+ 0000 ~                                    ld       (memto),a
  60+ 0000                                      ENDM
  61+ 0000
  62+ 0000
  63+ 0000              ldCopyByteABS:          MACRO memfrom, memto
  64+ 0000 ~                                    ld       a,(memfrom)
  65+ 0000 ~                                    and		$7F
  66+ 0000 ~                                    ld       (memto),a
  67+ 0000                                      ENDM
  68+ 0000
  69+ 0000              ldAtHLtoMem:            MACRO   memto
  70+ 0000 ~                                    ld      a,(hl)
  71+ 0000 ~                                    ld      (memto),a
  72+ 0000                                      ENDM
  73+ 0000
  74+ 0000              ldCopyWord:             MACRO memfrom, memto
  75+ 0000 ~                                    ldCopy2Byte memfrom, memto
  76+ 0000                                      ENDM
  77+ 0000
  78+ 0000              ldCopy2Byte:            MACRO  memfrom, memto
  79+ 0000 ~                                    ld       hl,(memfrom)
  80+ 0000 ~                                    ld       (memto),hl
  81+ 0000                                      ENDM
  82+ 0000
  83+ 0000              ldWriteConst            MACRO  memfrom, memto
  84+ 0000 ~                                    ld       a,memfrom
  85+ 0000 ~                                    ld       (memto),a
  86+ 0000                                      ENDM
  87+ 0000
  88+ 0000              ldWriteZero             MACRO  memto
  89+ 0000 ~                                    xor      a
  90+ 0000 ~                                    ld       (memto),a
  91+ 0000                                      ENDM
  92+ 0000
  93+ 0000              ldIXLaFromN:	        MACRO memfrom
  94+ 0000 ~                                    ld		a,(memfrom)
  95+ 0000 ~                                    ld		ixl,a
  96+ 0000                                      ENDM
  97+ 0000
  98+ 0000              ldIXHaFromN:	        MACRO memfrom
  99+ 0000 ~                                    ld		a,(memfrom)
 100+ 0000 ~                                    ld		ixh,a
 101+ 0000                                      ENDM
 102+ 0000
 103+ 0000              ldIYLaFromN:	        MACRO memfrom
 104+ 0000 ~                                    ld		a,(memfrom)
 105+ 0000 ~                                    ld		iyl,a
 106+ 0000                                      ENDM
 107+ 0000
 108+ 0000              ldIYHaFromN:	        MACRO memfrom
 109+ 0000 ~                                    ld		a,(memfrom)
 110+ 0000 ~                                    ld		iyh,a
 111+ 0000                                      ENDM
 112+ 0000
 113+ 0000              ; Read a 32 bit value from address HL into BCDE
 114+ 0000              ldBCDEatHL:             MACRO
 115+ 0000 ~                                    ld      e,(hl)
 116+ 0000 ~                                    inc     hl
 117+ 0000 ~                                    ld      d,(hl)
 118+ 0000 ~                                    inc     hl
 119+ 0000 ~                                    ld      c,(hl)
 120+ 0000 ~                                    inc     hl
 121+ 0000 ~                                    ld      b,(hl)
 122+ 0000 ~                                    inc     hl
 123+ 0000                                      ENDM
 124+ 0000
 125+ 0000              ldBCatHL:               MACRO
 126+ 0000 ~                                    ld      c,(hl)
 127+ 0000 ~                                    inc     hl
 128+ 0000 ~                                    ld      b,(hl)
 129+ 0000 ~                                    inc     hl
 130+ 0000                                      ENDM
 131+ 0000
 132+ 0000              ldhlde:			        MACRO
 133+ 0000 ~                                    ld		h,d
 134+ 0000 ~                                    ld		l,e
 135+ 0000                                      ENDM
 136+ 0000
 137+ 0000              ldhlbc:			        MACRO
 138+ 0000 ~                                    ld		h,b
 139+ 0000 ~                                    ld		l,c
 140+ 0000                                      ENDM
 141+ 0000
 142+ 0000              ldbcde:			        MACRO
 143+ 0000 ~                                    ld		b,d
 144+ 0000 ~                                    ld		c,e
 145+ 0000                                      ENDM
 146+ 0000
 147+ 0000              lddebc:			        MACRO
 148+ 0000 ~                                    ld		d,b
 149+ 0000 ~                                    ld		e,c
 150+ 0000                                      ENDM
 151+ 0000
 152+ 0000              ldbchl:			        MACRO
 153+ 0000 ~                                    ld		b,h
 154+ 0000 ~                                    ld		c,l
 155+ 0000                                      ENDM
 156+ 0000
 157+ 0000              lddeiy:			        MACRO
 158+ 0000 ~                                    ld		d,iyh
 159+ 0000 ~                                    ld		e,iyl
 160+ 0000                                      ENDM
 161+ 0000
 162+ 0000              ldiyde:			        MACRO
 163+ 0000 ~                                    ld		iyh,d
 164+ 0000 ~                                    ld		iyl,e
 165+ 0000                                      ENDM
 166+ 0000
 167+ 0000
 168+ 0000              FourLDIInstrunctions:   MACRO
 169+ 0000 ~                                    ldi
 170+ 0000 ~                                    ldi
 171+ 0000 ~                                    ldi
 172+ 0000 ~                                    ldi
 173+ 0000                                      ENDM
 174+ 0000
 175+ 0000              FiveLDIInstrunctions:   MACRO
 176+ 0000 ~                                    ldi
 177+ 0000 ~                                    ldi
 178+ 0000 ~                                    ldi
 179+ 0000 ~                                    ldi
 180+ 0000 ~                                    ldi
 181+ 0000                                      ENDM
 182+ 0000
 183+ 0000              SixLDIInstrunctions:    MACRO
 184+ 0000 ~                                    ldi
 185+ 0000 ~                                    ldi
 186+ 0000 ~                                    ldi
 187+ 0000 ~                                    ldi
 188+ 0000 ~                                    ldi
 189+ 0000 ~                                    ldi
 190+ 0000                                      ENDM
 191+ 0000
 192+ 0000              EightLDIInstrunctions:  MACRO
 193+ 0000 ~            		                ldi
 194+ 0000 ~            		                ldi
 195+ 0000 ~            		                ldi
 196+ 0000 ~            		                ldi
 197+ 0000 ~            		                ldi
 198+ 0000 ~            		                ldi
 199+ 0000 ~            		                ldi
 200+ 0000 ~            		                ldi
 201+ 0000                                      ENDM
 202+ 0000
 203+ 0000              NineLDIInstrunctions:  MACRO
 204+ 0000 ~            		                ldi
 205+ 0000 ~            		                ldi
 206+ 0000 ~            		                ldi
 207+ 0000 ~            		                ldi
 208+ 0000 ~            		                ldi
 209+ 0000 ~            		                ldi
 210+ 0000 ~            		                ldi
 211+ 0000 ~            		                ldi
 212+ 0000 ~            		                ldi
 213+ 0000                                      ENDM
# file closed: ../../Macros/ldCopyMacros.asm
  35  0000                                      INCLUDE "../../Macros/ldIndexedMacros.asm"
# file opened: ../../Macros/ldIndexedMacros.asm
   1+ 0000              GetByteAInTable:    MACRO table
   2+ 0000 ~                                ld          hl,table
   3+ 0000 ~                                add         hl,a
   4+ 0000 ~                                ld          a,(hl)
   5+ 0000                                  ENDM
   6+ 0000
   7+ 0000              HLWordAInTable:     MACRO table
   8+ 0000 ~                                ld          hl,table
   9+ 0000 ~                                sla         a
  10+ 0000 ~                                add         hl,a
  11+ 0000 ~                                ld          a,(hl)
  12+ 0000 ~                                inc         hl
  13+ 0000 ~                                ld          h,(hl)
  14+ 0000 ~                                ld          l,a
  15+ 0000                                  ENDM
  16+ 0000
  17+ 0000
  18+ 0000              ldAToHLixl:			MACRO value
  19+ 0000 ~            					ld          hl,value
  20+ 0000 ~            					ex          af,af'
  21+ 0000 ~            					ld          a,ixl
  22+ 0000 ~            					add         hl,a
  23+ 0000 ~            					ex          af,af'
  24+ 0000 ~            					ld          (hl),a
  25+ 0000              					ENDM
  26+ 0000
  27+ 0000              ldAToHLiyl:			MACRO value
  28+ 0000 ~            					ld          hl,value
  29+ 0000 ~            					ex          af,af'
  30+ 0000 ~            					ld          a,iyl
  31+ 0000 ~            					add         hl,a
  32+ 0000 ~            					ex          af,af'
  33+ 0000 ~            					ld          (hl),a
  34+ 0000              					ENDM
  35+ 0000
  36+ 0000
  37+ 0000              ldHLixlToA:         MACRO value
  38+ 0000 ~                                ld          hl,value
  39+ 0000 ~                                ex          af,af'
  40+ 0000 ~                                ld          a,ixl
  41+ 0000 ~                                add         hl,a
  42+ 0000 ~                                ld          a,(hl)
  43+ 0000                                  ENDM
  44+ 0000
  45+ 0000              ldHLiylToA:         MACRO value
  46+ 0000 ~                                ld          hl,value
  47+ 0000 ~                                ex          af,af'
  48+ 0000 ~                                ld          a,iyl
  49+ 0000 ~                                add         hl,a
  50+ 0000 ~                                ld          a,(hl)
  51+ 0000                                  ENDM
  52+ 0000
  53+ 0000              ldHLIdxAToA:        MACRO value
  54+ 0000 ~                                ld          hl,value
  55+ 0000 ~                                add         hl,a
  56+ 0000 ~                                ld          a,(hl)
  57+ 0000                                  ENDM
  58+ 0000
  59+ 0000              HLEquAddrAtHLPlusA: MACRO
  60+ 0000 ~                                sla         a
  61+ 0000 ~                                add         hl,a
  62+ 0000 ~                                ld          a,(hl)
  63+ 0000 ~                                inc         hl
  64+ 0000 ~                                ld          h,(hl)
  65+ 0000 ~                                ld          l,a
  66+ 0000                                  ENDM
  67+ 0000
  68+ 0000              ;-- Performs HL = |HL| - 1
  69+ 0000              DecHLABS:           MACRO
  70+ 0000 ~                                bit         7,h
  71+ 0000 ~                                jp          nz,.NegativeDec
  72+ 0000 ~            .IsHLZero:          ld          a,h                 ; if its zero it becomes negative
  73+ 0000 ~                                or          l
  74+ 0000 ~                                jp          z,.HLZero
  75+ 0000 ~            .PositiveDec:       dec         hl
  76+ 0000 ~                                jp          .Done
  77+ 0000 ~            .NegativeDec:       ld          a,h
  78+ 0000 ~                                and         $7F
  79+ 0000 ~                                ld          h,a
  80+ 0000 ~                                dec         hl
  81+ 0000 ~                                set         7,h
  82+ 0000 ~                                jp          .Done
  83+ 0000 ~            .HLZero:            ld          hl,$8001
  84+ 0000 ~            .Done:
  85+ 0000                                  ENDM
  86+ 0000
  87+ 0000              ;-- Performs HL = HL - 1
  88+ 0000              DecHLSigned:        MACRO
  89+ 0000 ~                                bit         7,h
  90+ 0000 ~                                jp          nz,.NegativeDec
  91+ 0000 ~            .IsHLZero:          ld          a,h                 ; if its zero it becomes negative
  92+ 0000 ~                                or          l
  93+ 0000 ~                                jp          z,.HLZero
  94+ 0000 ~            .PositiveDec:       dec         hl
  95+ 0000 ~                                jp          .Done
  96+ 0000 ~            .NegativeDec:       ld          a,h
  97+ 0000 ~                                and         $7F
  98+ 0000 ~                                ld          h,a
  99+ 0000 ~                                inc         hl                  ; if its already negative then add 1 to make it further
 100+ 0000 ~                                set         7,h
 101+ 0000 ~                                jp          .Done
 102+ 0000 ~            .HLZero:            ld          hl,$8001
 103+ 0000 ~            .Done:
 104+ 0000                                  ENDM
 105+ 0000
# file closed: ../../Macros/ldIndexedMacros.asm
  36  0000                                      INCLUDE "../../Macros/jumpMacros.asm"
# file opened: ../../Macros/jumpMacros.asm
   1+ 0000              JumpIfHLNegative:       MACRO target
   2+ 0000 ~                                    bit     7,h
   3+ 0000 ~                                    jp      nz,target
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              JumpIfPositive:	        MACRO target
   7+ 0000 ~                                    jp		p, target
   8+ 0000                                      ENDM
   9+ 0000
  10+ 0000              JumpIfNegative:	        MACRO target
  11+ 0000 ~                                    jp		m, target
  12+ 0000                                      ENDM
  13+ 0000
  14+ 0000
  15+ 0000              JumpIfUnderflow:	    MACRO target
  16+ 0000 ~                                    jp		po, target
  17+ 0000                                      ENDM
  18+ 0000
  19+ 0000              JumpIfOverflow:	        MACRO target
  20+ 0000 ~                                    jp		po, target
  21+ 0000                                      ENDM
  22+ 0000
  23+ 0000
  24+ 0000              JumpIfNotZero:	        MACRO target
  25+ 0000 ~                                    jp	nz,target
  26+ 0000                                      ENDM
  27+ 0000
  28+ 0000              JumpIfZero:	            MACRO target
  29+ 0000 ~                                    jp	z,target
  30+ 0000                                      ENDM
  31+ 0000
  32+ 0000              ;.. Bit routines
  33+ 0000              JumpOnLeadSignSet:      MACRO   reg, target
  34+ 0000 ~                                    ld      a,reg
  35+ 0000 ~                                    and     SignOnly8Bit
  36+ 0000 ~                                    jp      nz,target
  37+ 0000                                      ENDM
  38+ 0000
  39+ 0000              JumpOnLeadSignClear:    MACRO   reg, target
  40+ 0000 ~                                    ld      a,reg
  41+ 0000 ~                                    and     SignOnly8Bit
  42+ 0000 ~                                    jp      z,target
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              JumpOnLeadSignSetA:     MACRO   target
  46+ 0000 ~                                    and     SignOnly8Bit
  47+ 0000 ~                                    jp      nz,target
  48+ 0000                                      ENDM
  49+ 0000
  50+ 0000              JumpOnLeadSignClearA:   MACRO   target
  51+ 0000 ~                                    and     SignOnly8Bit
  52+ 0000 ~                                    jp      z,target
  53+ 0000                                      ENDM
  54+ 0000
  55+ 0000              JumpOnMemBitSet:        MACRO mem, bitnbr, target
  56+ 0000 ~                                    ld      a,(mem)
  57+ 0000 ~                                    bit 	bitnbr,a
  58+ 0000 ~                                    jp      nz,target
  59+ 0000                                      ENDM
  60+ 0000
  61+ 0000              JumpOnMemBitClear:      MACRO mem, bitnbr, target
  62+ 0000 ~                                    ld      a,(mem)
  63+ 0000 ~                                    bit 	bitnbr,a
  64+ 0000 ~                                    jp      z,target
  65+ 0000                                      ENDM
  66+ 0000
  67+ 0000
  68+ 0000              JumpOnABitSet:          MACRO   bitnbr, target
  69+ 0000 ~                                    bit 	bitnbr, a
  70+ 0000 ~                                    jp      nz,target
  71+ 0000                                      ENDM
  72+ 0000
  73+ 0000              JumpOnABitClear:        MACRO   bitnbr, target
  74+ 0000 ~                                    bit 	bitnbr, a
  75+ 0000 ~                                    jp      z,target
  76+ 0000                                      ENDM
  77+ 0000
  78+ 0000              JumpOnABit5Set:         MACRO   target
  79+ 0000 ~                                    and     Bit5Only
  80+ 0000 ~                                    jp      nz,target
  81+ 0000                                      ENDM
  82+ 0000
  83+ 0000              JumpOnABit5Clear:       MACRO   target
  84+ 0000 ~                                    and     Bit5Only
  85+ 0000 ~                                    jp      z,target
  86+ 0000                                      ENDM
  87+ 0000
  88+ 0000              JumpOnBitMaskSet:       MACRO   bitmask, target
  89+ 0000 ~                                    and     bitmask
  90+ 0000 ~                                    jp      nz,target
  91+ 0000                                      ENDM
  92+ 0000
  93+ 0000              JumpOnBitMaskClear:     MACRO   bitmask, target
  94+ 0000 ~                                    and     bitmask
  95+ 0000 ~                                    jp      z,target
  96+ 0000                                      ENDM
  97+ 0000
  98+ 0000              JumpOnMemBitMaskSet:    MACRO   mem, bitmask, target
  99+ 0000 ~                                    ld      a,(mem)
 100+ 0000 ~                                    and     bitmask
 101+ 0000 ~                                    jp      nz,target
 102+ 0000                                      ENDM
 103+ 0000
 104+ 0000              JumpOnMemBitMaskClear:  MACRO   mem, bitmask, target
 105+ 0000 ~                                    ld      a,(mem)
 106+ 0000 ~                                    and     bitmask
 107+ 0000 ~                                    jp      z,target
 108+ 0000                                      ENDM
 109+ 0000
 110+ 0000              JumpOnBitSet:           MACRO  reg, bitnbr, target
 111+ 0000 ~                                    bit 	bitnbr,reg
 112+ 0000 ~                                    jp      nz,target
 113+ 0000                                      ENDM
 114+ 0000
 115+ 0000              JumpOnBitClear:         MACRO  reg, bitnbr, target
 116+ 0000 ~                                    bit 	bitnbr,reg
 117+ 0000 ~                                    jp      z,target
 118+ 0000                                      ENDM
 119+ 0000
 120+ 0000              ; Comparison Routines
 121+ 0000              JumpIfAGTEusng:         MACRO
 122+ 0000 ~                                    jp		nc,target
 123+ 0000                                      ENDM
 124+ 0000
 125+ 0000              JumpIfAGTENusng:        MACRO reg,target
 126+ 0000 ~                                    cp     reg
 127+ 0000 ~                                    jp		nc,target
 128+ 0000                                      ENDM
 129+ 0000
 130+ 0000              JumpIfAGTEMemusng:      MACRO mem,target
 131+ 0000 ~                                    ld      hl,mem
 132+ 0000 ~                                    cp      (hl)
 133+ 0000 ~                                    jp		nc,target
 134+ 0000                                      ENDM
 135+ 0000              JumpIfMemGTENusng:      MACRO mem, value, target
 136+ 0000 ~                                    ld     a,(mem)
 137+ 0000 ~                                    cp     value
 138+ 0000 ~                                    jp	  nc,target
 139+ 0000                                      ENDM
 140+ 0000
 141+ 0000              JumpIfMemGTEMemusng:    MACRO mem, address, target
 142+ 0000 ~                                    ld   a,(mem)
 143+ 0000 ~                                    ld   hl,address
 144+ 0000 ~                                    cp   (hl)
 145+ 0000 ~                                    jp	  nc,target
 146+ 0000                                      ENDM
 147+ 0000
 148+ 0000              JumpIfMemEqMemusng:     MACRO mem, address, target
 149+ 0000 ~                                    ld   a,(mem)
 150+ 0000 ~                                    ld   hl,address
 151+ 0000 ~                                    cp   (hl)
 152+ 0000 ~                                    jp	  z,target
 153+ 0000                                      ENDM
 154+ 0000
 155+ 0000              JumpIfMemNeMemusng:     MACRO mem, address, target
 156+ 0000 ~                                    ld   a,(mem)
 157+ 0000 ~                                    ld   hl,address
 158+ 0000 ~                                    cp   (hl)
 159+ 0000 ~                                    jp	  nz,target
 160+ 0000                                      ENDM
 161+ 0000
 162+ 0000              JumpIfMemTrue:          MACRO mem, target
 163+ 0000 ~                                    ld      a,(mem)
 164+ 0000 ~                                    and     a
 165+ 0000 ~                                    jp      z, target
 166+ 0000                                      ENDM
 167+ 0000
 168+ 0000              JumpIfMemFalse:         MACRO mem, target
 169+ 0000 ~                                    ld      a,(mem)
 170+ 0000 ~                                    and     a
 171+ 0000 ~                                    jp      nz, target
 172+ 0000                                      ENDM
 173+ 0000
 174+ 0000              JumpIfATrue:            MACRO target
 175+ 0000 ~                                    and     a
 176+ 0000 ~                                    jp      z, target
 177+ 0000                                      ENDM
 178+ 0000
 179+ 0000              JumpIfAFalse:           MACRO target
 180+ 0000 ~                                    and     a
 181+ 0000 ~                                    jp      nz, target
 182+ 0000                                      ENDM
 183+ 0000
 184+ 0000              JumpIfANotFalse:        MACRO target
 185+ 0000 ~                                    cp      $FF
 186+ 0000 ~                                    jp      nz, target
 187+ 0000                                      ENDM
 188+ 0000
 189+ 0000              ;-- Less than Macros -------------------------------------------
 190+ 0000              JumpIfALTMemHLusng:     MACRO target
 191+ 0000 ~                                    cp    (hl)
 192+ 0000 ~                                    jp	  c,target
 193+ 0000                                      ENDM
 194+ 0000
 195+ 0000              JumpIfRegLTE:           MACRO   reg, value, target
 196+ 0000 ~                                    ld      a,reg
 197+ 0000 ~                                    cp      value
 198+ 0000 ~                                    jp	    z,target
 199+ 0000 ~                                    jp		c, target
 200+ 0000                                      ENDM
 201+ 0000
 202+ 0000              JumpIfALTMemusng:       MACRO mem,target
 203+ 0000 ~                                    ld      hl,mem
 204+ 0000 ~                                    cp      (hl)
 205+ 0000 ~                                    jp		c,target
 206+ 0000                                      ENDM
 207+ 0000
 208+ 0000
 209+ 0000              JumpIfALTusng:          MACRO target
 210+ 0000 ~                                    jp		c,target
 211+ 0000                                      ENDM
 212+ 0000
 213+ 0000              JumpIfALTNusng:         MACRO value, target
 214+ 0000 ~                                    cp      value
 215+ 0000 ~                                    jp		c, target
 216+ 0000                                      ENDM
 217+ 0000
 218+ 0000              JumpIfALTNsigned:       MACRO   value, target
 219+ 0000 ~                                    cp      value
 220+ 0000 ~                                    jp      m,.SignSet
 221+ 0000 ~            .SignClear:             jp      pe,target       ; Sign (0), P/V (1)
 222+ 0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (0)
 223+ 0000 ~            .SignSet:               jp      po,target
 224+ 0000 ~            .CheckComplete:
 225+ 0000                                      ENDM
 226+ 0000
 227+ 0000              JumpIfMemLTNusng:       MACRO mem, value, target
 228+ 0000 ~                                    ld      a,(mem)
 229+ 0000 ~                                    cp      value
 230+ 0000 ~                                    jp	  c,target
 231+ 0000                                      ENDM
 232+ 0000
 233+ 0000              JumpIfMemLTMemusng:     MACRO mem, value, target
 234+ 0000 ~                                    ld    a,(mem)
 235+ 0000 ~                                    ld    hl,value
 236+ 0000 ~                                    cp    (hl)
 237+ 0000 ~                                    jp	  c,target
 238+ 0000                                      ENDM
 239+ 0000              ;-- ------------------------------------------------------------
 240+ 0000              JumpIfAGTENsigned       MACRO   value, target
 241+ 0000 ~                                    cp      value
 242+ 0000 ~                                    jp      m,.SignSet
 243+ 0000 ~            .SignClear:             jp      po,target       ; Sign (0), P/V (0)
 244+ 0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (1)
 245+ 0000 ~            .SignSet:               jp      pe,target
 246+ 0000 ~            .CheckComplete:
 247+ 0000                                      ENDM
 248+ 0000
 249+ 0000              JumpIfMemEqNusng:       MACRO mem,value,target
 250+ 0000 ~                                    ld  a,(mem)
 251+ 0000 ~                                    cp  value
 252+ 0000 ~                                    jp  z,target
 253+ 0000                                      ENDM
 254+ 0000
 255+ 0000              JumpIfMemNeNusng:       MACRO mem,value,target
 256+ 0000 ~                                    ld  a,(mem)
 257+ 0000 ~                                    cp  value
 258+ 0000 ~                                    jp  nz,target
 259+ 0000                                      ENDM
 260+ 0000
 261+ 0000              JumpIfMemZero:          MACRO mem,target
 262+ 0000 ~                                    ld  a,(mem)
 263+ 0000 ~                                    and a
 264+ 0000 ~                                    jp  z,target
 265+ 0000                                      ENDM
 266+ 0000
 267+ 0000              JumpIfMemNotZero:       MACRO mem,target
 268+ 0000 ~                                    ld  a,(mem)
 269+ 0000 ~                                    and a
 270+ 0000 ~                                    jp  nz,target
 271+ 0000                                      ENDM
 272+ 0000
 273+ 0000              JumpIfANENusng:         MACRO value, target
 274+ 0000 ~                                    cp     value
 275+ 0000 ~                                    jp      nz,target
 276+ 0000                                      ENDM
 277+ 0000
 278+ 0000              JumpIfANEquNusng:       MACRO value, target
 279+ 0000 ~                                    cp     value
 280+ 0000 ~                                    jp     z,target
 281+ 0000                                      ENDM
 282+ 0000
 283+ 0000              JumpIfANEMemusng:       MACRO  value, target
 284+ 0000 ~                                    ld    hl,value
 285+ 0000 ~                                    cp    (hl)
 286+ 0000 ~                                    jp      nz,target
 287+ 0000                                      ENDM
 288+ 0000
 289+ 0000              JumpIfAEqNusng:         MACRO value, target
 290+ 0000 ~                                    cp     value
 291+ 0000 ~                                    jp      z,target
 292+ 0000                                      ENDM
 293+ 0000
 294+ 0000              JumpIfAIsZero:	        MACRO target
 295+ 0000 ~                                    and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 296+ 0000 ~                                    jp	    z, target
 297+ 0000                                      ENDM
 298+ 0000
 299+ 0000              JumpIfRegIsNotZero:     MACRO   reg, target
 300+ 0000 ~                                    ld      a,reg
 301+ 0000 ~                                    and     a
 302+ 0000 ~                                    jp	    nz,target
 303+ 0000                                      ENDM
 304+ 0000
 305+ 0000
 306+ 0000              JumpIfAIsNotZero:       MACRO target
 307+ 0000 ~                                    and     a
 308+ 0000 ~                                    jp	    nz,target
 309+ 0000                                      ENDM
 310+ 0000
 311+ 0000              JumpIfMemIsNotZero:     MACRO value, target
 312+ 0000 ~                                    ld      a,(value)
 313+ 0000 ~                                    and     a
 314+ 0000 ~                                    jp	    nz,target
 315+ 0000                                      ENDM
 316+ 0000              IfResultZeroGoto:	    MACRO target
 317+ 0000 ~                                    jp	z,target
 318+ 0000                                      ENDM
 319+ 0000
 320+ 0000              IfResultNotZeroGoto:    MACRO target
 321+ 0000 ~                                    jp	nz,target
 322+ 0000                                      ENDM
 323+ 0000
# file closed: ../../Macros/jumpMacros.asm
  37  0000                                      INCLUDE "../../Macros/MathsMacros.asm"
# file opened: ../../Macros/MathsMacros.asm
   1+ 0000              ZeroA:		            MACRO
   2+ 0000 ~                                    xor a
   3+ 0000                                      ENDM
   4+ 0000              ; sets z flag is HL less than 255 else sets it to nz (note opposite of GT127)
   5+ 0000              IsHLGT255:              MACRO
   6+ 0000 ~                                    bit     7,h
   7+ 0000 ~                                    ret     z
   8+ 0000 ~                                    ld      a,h
   9+ 0000 ~                                    and     a
  10+ 0000                                      ENDM
  11+ 0000
  12+ 0000              ; Sets z flat if HL = 255 else sets it to nz
  13+ 0000              IsHLEqu255:             MACRO
  14+ 0000 ~                                    ld      a,h
  15+ 0000 ~                                    and     a               ; if its non zero then it can't be 255
  16+ 0000 ~                                    ret     nz
  17+ 0000 ~                                    ld      a,l
  18+ 0000 ~                                    inc     a               ; if it was 255 the inc will set it to zero
  19+ 0000                                      ENDM
  20+ 0000
  21+ 0000              ; Sets Z flag if GT 127 else nz
  22+ 0000              IsHLGT127:              MACRO
  23+ 0000 ~                                    bit     7,h             ; -ve?
  24+ 0000 ~                                    jr      nz,.DoneCheck
  25+ 0000 ~                                    ld      a,h             ; +ve > 256?
  26+ 0000 ~                                    and     a
  27+ 0000 ~                                    jr      nz,.DoneCheck
  28+ 0000 ~                                    ld      a,l
  29+ 0000 ~                                    and     $80             ; this will set z to false if bit 7 set and clear lower bits
  30+ 0000 ~                                    cp      $80             ; this will set z to true if bit 7 set
  31+ 0000 ~            .DoneCheck:
  32+ 0000                                      ENDM
  33+ 0000
  34+ 0000              ReturnIfHLGT127:        MACRO
  35+ 0000 ~                                    bit     7,h             ; -ve?
  36+ 0000 ~                                    jr      nz,.DoneCheck   ; forces check complete
  37+ 0000 ~                                    ld      a,h             ; +ve > 256?
  38+ 0000 ~                                    and     a               ;
  39+ 0000 ~                                    ret     nz              ; forces a return
  40+ 0000 ~                                    bit     7,l             ; bit 7 of lower set?
  41+ 0000 ~                                    ret     nz              ; forces a return
  42+ 0000 ~            .DoneCheck:
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              IsDEGT127:              MACRO
  46+ 0000 ~                                    bit     7,d
  47+ 0000 ~                                    jr      nz,.DoneCheck
  48+ 0000 ~                                    ld      a,d
  49+ 0000 ~                                    jr      nz,.DoneCheck
  50+ 0000 ~                                    ld      a,e
  51+ 0000 ~                                    and     $80
  52+ 0000 ~            .DoneCheck:
  53+ 0000                                      ENDM
  54+ 0000
  55+ 0000              ABSa2c:                 MACRO
  56+ 0000 ~                                    bit     7,a
  57+ 0000 ~                                    jp      z,.DoneABSa
  58+ 0000 ~                                    neg
  59+ 0000 ~            .DoneABSa:
  60+ 0000                                      ENDM
  61+ 0000
  62+ 0000              DEEquSquareA:           MACRO
  63+ 0000 ~                                    ld  d,a
  64+ 0000 ~                                    ld  e,a
  65+ 0000 ~                                    mul de
  66+ 0000                                      ENDM
  67+ 0000
  68+ 0000              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
  69+ 0000 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
  70+ 0000 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
  71+ 0000 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
  72+ 0000 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
  73+ 0000 ~                                    xor $80                             ;
  74+ 0000 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
  75+ 0000 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
  76+ 0000 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
  77+ 0000 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
  78+ 0000 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
  79+ 0000 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
  80+ 0000                                      ENDM
  81+ 0000
  82+ 0000              SignedHLTo2C:           MACRO
  83+ 0000 ~                                    bit     7,h
  84+ 0000 ~                                    jr      z,.Done2c
  85+ 0000 ~                                    ld      a,h
  86+ 0000 ~                                    and     SignMask8Bit
  87+ 0000 ~                                    ld      h,a
  88+ 0000 ~                                    NegHL
  89+ 0000 ~            .Done2c:
  90+ 0000                                      ENDM
  91+ 0000
  92+ 0000              MemSignedTo2C:          MACRO   memfrom
  93+ 0000 ~                                    ld      hl,(memfrom)
  94+ 0000 ~                                    bit     7,h
  95+ 0000 ~                                    jr      z,.Done2c
  96+ 0000 ~                                    ld      a,h
  97+ 0000 ~                                    and     SignMask8Bit
  98+ 0000 ~                                    ld      h,a
  99+ 0000 ~            .Done2c:                ld      (memfrom),hl
 100+ 0000                                      ENDM
 101+ 0000
 102+ 0000
 103+ 0000                  ;returns result in H
 104+ 0000              EDiv10Inline:           MACRO
 105+ 0000 ~                                    ld      d,0
 106+ 0000 ~                                    ld      hl,de
 107+ 0000 ~                                    add     hl,hl
 108+ 0000 ~                                    add     hl,de
 109+ 0000 ~                                    add     hl,hl
 110+ 0000 ~                                    add     hl,hl
 111+ 0000 ~                                    add     hl,de
 112+ 0000 ~                                    add     hl,hl
 113+ 0000                                      ENDM
 114+ 0000
 115+ 0000              cpHLDE:                 MACRO
 116+ 0000 ~                                    push    hl
 117+ 0000 ~                                    and     a
 118+ 0000 ~                                    sbc     hl,de
 119+ 0000 ~                                    pop     hl
 120+ 0000                                      ENDM
 121+ 0000
 122+ 0000              cpABSDEHL:              MACRO
 123+ 0000 ~                                    push     hl,,de
 124+ 0000 ~                                    ld      a,h
 125+ 0000 ~                                    and     $7F
 126+ 0000 ~                                    ld      h,a
 127+ 0000 ~                                    ld      a,d
 128+ 0000 ~                                    and     $7F
 129+ 0000 ~                                    ld      d,a
 130+ 0000 ~                                    ex      de,hl
 131+ 0000 ~                                    sbc     hl,de
 132+ 0000 ~                                    pop     hl,,de
 133+ 0000                                      ENDM
 134+ 0000
 135+ 0000              ; Simple are they both the same setting z if they are
 136+ 0000              ; tehcicall this works but it measn the final ret z is alwys done
 137+ 0000              ; so jp needs to be to a target
 138+ 0000              cpHLEquDE:              MACRO   passedCheck
 139+ 0000 ~                                    ld      a,h
 140+ 0000 ~                                    cp      d
 141+ 0000 ~                                    jp      nz, passedCheck
 142+ 0000 ~                                    ld      a,l
 143+ 0000 ~                                    cp      e
 144+ 0000 ~            .NoTheSame:
 145+ 0000                                      ENDM
 146+ 0000
 147+ 0000              cpHLEquBC:              MACRO   passedCheck
 148+ 0000 ~                                    ld      a,h
 149+ 0000 ~                                    cp      b
 150+ 0000 ~                                    jp      nz, passedCheck
 151+ 0000 ~                                    ld      a,l
 152+ 0000 ~                                    cp      c
 153+ 0000 ~            .NoTheSame:
 154+ 0000                                      ENDM
 155+ 0000
 156+ 0000              cpDEEquBC:              MACRO   passedCheck
 157+ 0000 ~                                    ld      a,d
 158+ 0000 ~                                    cp      b
 159+ 0000 ~                                    jp      nz, passedCheck
 160+ 0000 ~                                    ld      a,e
 161+ 0000 ~                                    cp      c
 162+ 0000 ~            .NoTheSame:
 163+ 0000                                      ENDM
 164+ 0000              ; Simple version just sets carry if HL < DE reset, does an initial compare for z
 165+ 0000              cpHLDELeadSign:         MACRO
 166+ 0000 ~                                    ld      a,h
 167+ 0000 ~                                    cp      d
 168+ 0000 ~                                    jr      nz,.FullCompare
 169+ 0000 ~                                    ld      a,l
 170+ 0000 ~                                    cp      e
 171+ 0000 ~                                    ret     z
 172+ 0000 ~            .FullCompare:           ld      a,h
 173+ 0000 ~                                    xor     d
 174+ 0000 ~                                    and     $80
 175+ 0000 ~                                    jr      nz,.OppositeSigns   ; If opposite signs is a simple sign test
 176+ 0000 ~                                    ld      a,h                 ; same signs so a little simpler
 177+ 0000 ~                                    and     $80
 178+ 0000 ~                                    jp      z,cpHLDE            ; if h is positive then both are positive by here so just cpHLDE
 179+ 0000 ~                                    jp      cpABSDEHL           ; else we have to do ABScpDEHL
 180+ 0000 ~            .OppositeSigns:         ld      a,h
 181+ 0000 ~                                    and     $80
 182+ 0000 ~                                    and     $80
 183+ 0000 ~                                    jp      z,.HLGTDE
 184+ 0000 ~            .HLLTDE:                SetCarryFlag
 185+ 0000 ~                                    ret
 186+ 0000 ~            .HLGTDE:                ClearCarryFlag
 187+ 0000 ~                                    ret
 188+ 0000                                      ENDM
 189+ 0000
 190+ 0000              ;Unsigned
 191+ 0000              ;If HL == DE, then Z flag is set.
 192+ 0000              ;If HL != DE, then Z flag is reset.
 193+ 0000              ;If HL <  DE, then C flag is set.
 194+ 0000              ;If HL >= DE, then C flag is reset.
 195+ 0000              ;
 196+ 0000              ;Signed
 197+ 0000              ;If HL == DE, then Z flag is set.
 198+ 0000              ;If HL != DE, then Z flag is reset.
 199+ 0000              ;If HL <  DE, then S and P/V are different.
 200+ 0000              ;If HL >= DE, then S and P/V are the same.
 201+ 0000
 202+ 0000
 203+ 0000              N0equN1byN2div256:      MACRO param1,param2,param3
 204+ 0000 ~                                    ld      a,param3                        ;
 205+ 0000 ~                                    ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 206+ 0000 ~                                    ld      a,param2                        ; A = XX16 element
 207+ 0000 ~                                    ld      d,a
 208+ 0000 ~                                    mul
 209+ 0000 ~                                    ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 210+ 0000 ~                                    ld      (param1),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 211+ 0000                                      ENDM
 212+ 0000
 213+ 0000              AequN1xorN2:            MACRO  param1,param2
 214+ 0000 ~                                    ld      a,(param1)
 215+ 0000 ~                                    xor     param2
 216+ 0000                                      ENDM
 217+ 0000
 218+ 0000              SpeedMulAxis:           MACRO   speedreg, axis
 219+ 0000 ~                                    ld      e,speedreg
 220+ 0000 ~                                    ld      hl,(axis)
 221+ 0000 ~                                    ld      a,h
 222+ 0000 ~                                    ClearSignBitA
 223+ 0000 ~                                    ld      d,a
 224+ 0000 ~                                    mul     de
 225+ 0000 ~                                    ld      a,h
 226+ 0000 ~                                    SignBitOnlyA
 227+ 0000 ~                                    ld      b,a;ld      c,a
 228+ 0000 ~                                    ld      h,d;ld      e,d
 229+ 0000 ~                                    ld      c,0;ld      d,0
 230+ 0000                                      ENDM
 231+ 0000
 232+ 0000              ; Adds speed (8 bit) to vertex (24 bit signed)
 233+ 0000              AddSpeedToVert:         MACRO   vertex
 234+ 0000 ~                                    ld      de,(vertex+1)
 235+ 0000 ~                                    ld      a,(vertex)
 236+ 0000 ~                                    ld      l,a
 237+ 0000 ~                                    call    AddBCHtoDELsigned               ; DEL = DEL + BCH
 238+ 0000 ~                                    ld      a,l
 239+ 0000 ~                                    ld      (vertex),a
 240+ 0000 ~                                    ld      (vertex+1),de
 241+ 0000                                      ENDM
# file closed: ../../Macros/MathsMacros.asm
  38  0000                                      INCLUDE "../../Macros/MMUMacros.asm"
# file opened: ../../Macros/MMUMacros.asm
   1+ 0000              MMUSelectROM0:       MACRO
   2+ 0000 ~                                 nextreg EXSDOSMMU0,        BankROM
   3+ 0000                                   ENDM
   4+ 0000
   5+ 0000              MMUSelectROMS:       MACRO
   6+ 0000 ~                                 nextreg EXSDOSMMU0,        BankROM
   7+ 0000 ~                                 nextreg EXSDOSMMU1,        BankROM
   8+ 0000                                   ENDM
   9+ 0000
  10+ 0000              MMUSelectMathsTables:MACRO
  11+ 0000 ~                                 nextreg MathsTablesMMU,    BankMathsTables
  12+ 0000                                   ENDM
  13+ 0000
  14+ 0000              MMUSelectKeyboard:   MACRO
  15+ 0000 ~                                 nextreg KeyboardMMU,       BankKeyboard
  16+ 0000                                   ENDM
  17+ 0000
  18+ 0000              MMUSelectSpriteBank: MACRO
  19+ 0000 ~            					 nextreg SpritememMMU,	    BankSPRITE
  20+ 0000              					 ENDM
  21+ 0000
  22+ 0000              MMUSelectConsoleBank: MACRO
  23+ 0000 ~            					 nextreg ConsoleImageDataMMU,  BankConsole
  24+ 0000              					 ENDM
  25+ 0000
  26+ 0000              MMUSelectLayer1: 	 MACRO
  27+ 0000 ~            					 nextreg L1memMMU,		    BankLAYER1
  28+ 0000              					 ENDM
  29+ 0000
  30+ 0000              MMUSelectLayer2: 	 MACRO
  31+ 0000 ~            					 nextreg L2memMMU,		    BankLAYER2
  32+ 0000              					 ENDM
  33+ 0000
  34+ 0000              MMUSelectResetUniv:  MACRO
  35+ 0000 ~                                 nextreg ResetUniverseMMU, BankResetUniv
  36+ 0000                                   ENDM
  37+ 0000
  38+ 0000              MMUSelectShipARead:  MACRO
  39+ 0000 ~                                 add    a,BankUNIVDATA0
  40+ 0000 ~                                 nextreg ShipReadMMU,       a
  41+ 0000                                   ENDM
  42+ 0000
  43+ 0000              MMUSelectShipBank1:  MACRO
  44+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels1
  45+ 0000              					 ENDM
  46+ 0000              MMUSelectShipBank2:  MACRO
  47+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels2
  48+ 0000              					 ENDM
  49+ 0000              MMUSelectShipBank3:  MACRO
  50+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels3
  51+ 0000              					 ENDM
  52+ 0000              MMUSelectShipBank4:  MACRO
  53+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels4
  54+ 0000              					 ENDM
  55+ 0000
  56+ 0000              MMUSelectShipBankA   MACRO
  57+ 0000 ~            					 nextreg ShipModelMMU,	    a
  58+ 0000              					 ENDM
  59+ 0000
  60+ 0000              MMUSelectShipBankN:  MACRO value
  61+ 0000 ~            					 nextreg ShipModelMMU,	    value
  62+ 0000              					 ENDM
  63+ 0000
  64+ 0000              MMUSelectCommander:	 MACRO
  65+ 0000 ~                                 nextreg CommanderMMU,       BankCommander
  66+ 0000              					 ENDM
  67+ 0000
  68+ 0000              MMUSelectStockTable: MACRO
  69+ 0000 ~                                 nextreg StockTableMMU,     BankStockTable
  70+ 0000              					 ENDM
  71+ 0000
  72+ 0000              MMUSelectCpySrcA:    MACRO
  73+ 0000 ~                                 nextreg DMACpySourceMMU,	a
  74+ 0000              					 ENDM
  75+ 0000
  76+ 0000              MMUSelectCpySrcN:    MACRO value
  77+ 0000 ~                                 nextreg DMACpySourceMMU,	value
  78+ 0000              					 ENDM
  79+ 0000
  80+ 0000              MMUSelectSun:        MACRO
  81+ 0000 ~                                 nextreg SunMMU,            BankSunData
  82+ 0000                                   ENDM
  83+ 0000
  84+ 0000              MMUSelectPlanet:     MACRO
  85+ 0000 ~                                 nextreg PlanetMMU,         BankPlanetData
  86+ 0000                                   ENDM
  87+ 0000
  88+ 0000              MMUSelectUniverseA:  MACRO
  89+ 0000 ~                                 add    a,BankUNIVDATA0
  90+ 0000 ~                                 nextreg UniverseMMU,       a
  91+ 0000                                   ENDM
  92+ 0000              ;Version that assumes a pre calulated A, used whn optimising many switches
  93+ 0000              MMUSelectUnivBankA:  MACRO
  94+ 0000 ~                                 nextreg UniverseMMU,       a
  95+ 0000                                   ENDM
  96+ 0000
  97+ 0000              MMUSelectUniverseN:  MACRO value
  98+ 0000 ~                                 nextreg UniverseMMU,       BankUNIVDATA0+value
  99+ 0000                                   ENDM
 100+ 0000
 101+ 0000              MMUSelectSpaceStation: MACRO
 102+ 0000 ~                                 nextreg SpaceStationMMU,   BankSpaceStationData
 103+ 0000                                   ENDM
 104+ 0000
 105+ 0000              MMUSelectMathsBankedFns   MACRO
 106+ 0000 ~                                 nextreg MathsBankedFnsMMU, BankMathsBankedFns
 107+ 0000                                   ENDM
 108+ 0000
 109+ 0000              MMUSelectGalaxyA:    MACRO
 110+ 0000 ~                                 nextreg GalaxyDataMMU,     a
 111+ 0000                                   ENDM
 112+ 0000
 113+ 0000              MMUSelectGalaxyN:    MACRO value
 114+ 0000 ~                                 nextreg GalaxyDataMMU,     BankGalaxyData0+value
 115+ 0000                                   ENDM
 116+ 0000              MMUSelectGalaxyACopy:MACRO
 117+ 0000 ~                                 nextreg UniverseMMU,       a
 118+ 0000                                   ENDM
 119+ 0000
 120+ 0000              MMUSelectUniverseAbs:MACRO value
 121+ 0000 ~                                 nextreg UniverseMMU,       value
 122+ 0000                                   ENDM
 123+ 0000
 124+ 0000              MMUSelectMenuGalCht: MACRO
 125+ 0000 ~                                 nextreg MenuGalChtMMU,		BankMenuGalCht
 126+ 0000              					 ENDM
 127+ 0000
 128+ 0000              MMUSelectMenuShrCht: MACRO
 129+ 0000 ~            					 nextreg MenuShrChtMMU,		BankMenuShrCht
 130+ 0000              					 ENDM
 131+ 0000
 132+ 0000              MMUSelectMenuInvent: MACRO
 133+ 0000 ~                                 nextreg MenuInventMMU,		BankMenuInvent
 134+ 0000              					 ENDM
 135+ 0000
 136+ 0000              MMUSelectMenuSystem: MACRO
 137+ 0000 ~                                 nextreg MenuSystemMMU,		BankMenuSystem
 138+ 0000              					 ENDM
 139+ 0000
 140+ 0000              MMUSelectMenuMarket: MACRO
 141+ 0000 ~                                 nextreg MenuMarketMMU,		BankMenuMarket
 142+ 0000              					 ENDM
 143+ 0000
 144+ 0000              MMUSelectEquipmentTables: MACRO
 145+ 0000 ~                                nextreg EquipmentTablesMMU,		BankEquipmentTables
 146+ 0000              					 ENDM
 147+ 0000
 148+ 0000              MMUSelectMenuStatus: MACRO
 149+ 0000 ~                                 nextreg MenuStatusMMU,		BankMenuStatus
 150+ 0000              					 ENDM
 151+ 0000
 152+ 0000              MMUSelectViewFront:  MACRO
 153+ 0000 ~                                 nextreg ScreenBankMMU,		BankFrontView
 154+ 0000              					 ENDM
 155+ 0000
 156+ 0000              MMUSelectScreenA:    MACRO
 157+ 0000 ~                                 nextreg ScreenBankMMU,		a
 158+ 0000              					 ENDM
 159+ 0000
 160+ 0000              MMUSelectSound:      MACRO
 161+ 0000 ~                                 nextreg SoundMMU,		    BankSound
 162+ 0000              					 ENDM
 163+ 0000
 164+ 0000              MMUSelectPIFns:      MACRO
 165+ 0000 ~                                 nextreg PIFnsMMU,          BankPIFns
 166+ 0000              					 ENDM
 167+ 0000
 168+ 0000
 169+ 0000              SaveMMU6:           MACRO
 170+ 0000 ~                                GetNextReg  MMU_SLOT_6_REGISTER
 171+ 0000 ~                                ld      (SavedMMU6),a
 172+ 0000                                  ENDM
 173+ 0000
 174+ 0000              RestoreMMU6:        MACRO
 175+ 0000 ~                                ld      a,(SavedMMU6)               ; now restore up post interrupt
 176+ 0000 ~                                nextreg MMU_SLOT_6_REGISTER,a       ; Restore MMU7
 177+ 0000                                  ENDM
 178+ 0000
 179+ 0000              SaveMMU7:           MACRO
 180+ 0000 ~                                GetNextReg  MMU_SLOT_7_REGISTER
 181+ 0000 ~                                ld      (SavedMMU7),a
 182+ 0000                                  ENDM
 183+ 0000
 184+ 0000              RestoreMMU7:        MACRO
 185+ 0000 ~                                ld      a,(SavedMMU7)               ; now restore up post interrupt
 186+ 0000 ~                                nextreg MMU_SLOT_7_REGISTER,a       ; Restore MMU7
 187+ 0000                                  ENDM
# file closed: ../../Macros/MMUMacros.asm
  39  0000                                      INCLUDE "../../Macros/NegateMacros.asm"
# file opened: ../../Macros/NegateMacros.asm
   1+ 0000
   2+ 0000              macronegate16hl:	MACRO
   3+ 0000 ~            					xor 	a
   4+ 0000 ~            					sub 	l
   5+ 0000 ~            					ld 		l,a
   6+ 0000 ~            					sbc 	a,a
   7+ 0000 ~            					sub 	h
   8+ 0000 ~            					ld 		h,a
   9+ 0000              					ENDM
  10+ 0000
  11+ 0000
  12+ 0000              macroAbsHL:         MACRO
  13+ 0000 ~                                bit     7,h
  14+ 0000 ~                                jp      z,.alreadyABS
  15+ 0000 ~            					xor 	a
  16+ 0000 ~            					sub 	l
  17+ 0000 ~            					ld 		l,a
  18+ 0000 ~            					sbc 	a,a
  19+ 0000 ~            					sub 	h
  20+ 0000 ~            					ld 		h,a
  21+ 0000 ~            .alreadyABS:
  22+ 0000                                  ENDM
  23+ 0000
  24+ 0000              macronegate16de:	MACRO
  25+ 0000 ~            					xor 	a
  26+ 0000 ~                                sub 	e
  27+ 0000 ~                                ld 		e,a
  28+ 0000 ~                                sbc 	a,a
  29+ 0000 ~                                sub 	d
  30+ 0000 ~                                ld 		d,a
  31+ 0000              					ENDM
  32+ 0000
  33+ 0000              macronegate16bc:	MACRO
  34+ 0000 ~            					xor 	a
  35+ 0000 ~                                sub 	c
  36+ 0000 ~                                ld 		c,a
  37+ 0000 ~                                sbc 	a,a
  38+ 0000 ~                                sub 	b
  39+ 0000 ~                                ld 		b,a
  40+ 0000              					ENDM
  41+ 0000
  42+ 0000              macronegate16ix:	MACRO
  43+ 0000 ~            					xor 	a
  44+ 0000 ~                                sub 	ixl
  45+ 0000 ~                                ld 		ixl,a
  46+ 0000 ~                                sbc 	a,a
  47+ 0000 ~                                sub 	ixh
  48+ 0000 ~                                ld 		ixh,a
  49+ 0000              					ENDM
  50+ 0000
  51+ 0000
  52+ 0000              NegIY:			    MACRO
  53+ 0000 ~                                xor a
  54+ 0000 ~                                sub iyl
  55+ 0000 ~                                ld iyl,a
  56+ 0000 ~                                sbc a,a
  57+ 0000 ~                                sub iyh
  58+ 0000 ~                                ld iyh,a
  59+ 0000                                  ENDM
  60+ 0000
  61+ 0000              NegHL:			    MACRO
  62+ 0000 ~                                xor a
  63+ 0000 ~                                sub l
  64+ 0000 ~                                ld l,a
  65+ 0000 ~                                sbc a,a
  66+ 0000 ~                                sub h
  67+ 0000 ~                                ld h,a
  68+ 0000                                  ENDM
  69+ 0000
  70+ 0000              NegDE:			    MACRO
  71+ 0000 ~                                xor a
  72+ 0000 ~                                sub e
  73+ 0000 ~                                ld e,a
  74+ 0000 ~                                sbc a,a
  75+ 0000 ~                                sub d
  76+ 0000 ~                                ld d,a
  77+ 0000                                  ENDM
  78+ 0000
  79+ 0000              NegBC:			    MACRO
  80+ 0000 ~                                xor a
  81+ 0000 ~                                sub c
  82+ 0000 ~                                ld c,a
  83+ 0000 ~                                sbc a,a
  84+ 0000 ~                                sub  b
  85+ 0000 ~                                ld b,a
  86+ 0000                                  ENDM
  87+ 0000
  88+ 0000              NegH                MACRO
  89+ 0000 ~                                ld      a,h
  90+ 0000 ~                                neg
  91+ 0000 ~                                ld      h,a
  92+ 0000                                  ENDM
  93+ 0000
  94+ 0000              NegD                MACRO
  95+ 0000 ~                                ld      a,d
  96+ 0000 ~                                neg
  97+ 0000 ~                                ld      d,a
  98+ 0000                                  ENDM
  99+ 0000
 100+ 0000              NegB                MACRO
 101+ 0000 ~                                ld      a,b
 102+ 0000 ~                                neg
 103+ 0000 ~                                ld      b,a
 104+ 0000                                  ENDM
 105+ 0000
# file closed: ../../Macros/NegateMacros.asm
  40  0000                                      INCLUDE "../../Macros/returnMacros.asm"
# file opened: ../../Macros/returnMacros.asm
   1+ 0000              ReturnIfHLNegative:     MACRO   target
   2+ 0000 ~                                    bit     7,h
   3+ 0000 ~                                    ret     nz
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              ReturnIfDENegative:     MACRO   target
   7+ 0000 ~                                    bit     7,d
   8+ 0000 ~                                    ret     nz
   9+ 0000                                      ENDM
  10+ 0000
  11+ 0000              ReturnOnBitSet:         MACRO  reg, bitnbr
  12+ 0000 ~                                    bit 	bitnbr,reg
  13+ 0000 ~                                    ret     nz
  14+ 0000                                      ENDM
  15+ 0000
  16+ 0000              ReturnOnMemBitSet:      MACRO mem, bitnbr
  17+ 0000 ~                                    ld   a,(mem)
  18+ 0000 ~                                    bit 	bitnbr,a
  19+ 0000 ~                                    ret     nz
  20+ 0000                                      ENDM
  21+ 0000
  22+ 0000              ReturnOnBitClear:       MACRO reg, bitnbr
  23+ 0000 ~                                    bit 	bitnbr,reg
  24+ 0000 ~                                    ret		z
  25+ 0000                                      ENDM
  26+ 0000
  27+ 0000              ReturnOnMemBitClear:    MACRO mem, bitnbr
  28+ 0000 ~                                    ld     a,(mem)
  29+ 0000 ~                                    bit 	bitnbr,a
  30+ 0000 ~                                    ret		z
  31+ 0000                                      ENDM
  32+ 0000
  33+ 0000              ReturnIfMemFalse:       MACRO   mem
  34+ 0000 ~                                    ld      a,(mem)
  35+ 0000 ~                                    and     a
  36+ 0000 ~                                    ret     nz
  37+ 0000                                      ENDM
  38+ 0000
  39+ 0000              ReturnIfMemTrue:        MACRO   mem
  40+ 0000 ~                                    ld      a,(mem)
  41+ 0000 ~                                    and     a
  42+ 0000 ~                                    ret     z
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              ReturnIfAIsZero:        MACRO
  46+ 0000 ~                                    and     a
  47+ 0000 ~                                    ret     z
  48+ 0000                                      ENDM
  49+ 0000
  50+ 0000              ReturnIfMemisZero:      MACRO mem
  51+ 0000 ~                                    ld   a,(mem)
  52+ 0000 ~                                    and a
  53+ 0000 ~                                    ret    z
  54+ 0000                                      ENDM
  55+ 0000
  56+ 0000              ReturnIfMemIsNegative:  MACRO mem
  57+ 0000 ~                                    ld      a,(mem)
  58+ 0000 ~                                    and     $80
  59+ 0000 ~                                    ret     nz
  60+ 0000                                      ENDM
  61+ 0000
  62+ 0000              ReturnIfBitMaskClear    MACRO   bitmask
  63+ 0000 ~                                    and     bitmask
  64+ 0000 ~                                    ret     z
  65+ 0000                                      ENDM
  66+ 0000
  67+ 0000              ReturnIfBitMaskSet      MACRO   bitmask
  68+ 0000 ~                                    and     bitmask
  69+ 0000 ~                                    ret     nz
  70+ 0000                                      ENDM
  71+ 0000
  72+ 0000              ReturnIfMemEquN:        MACRO mem, value
  73+ 0000 ~                                    ld     a,(mem)
  74+ 0000 ~                                    cp     value
  75+ 0000 ~                                    ret    nz
  76+ 0000                                      ENDM
  77+ 0000
  78+ 0000              ReturnIfMemNeNusng:     MACRO mem, value
  79+ 0000 ~                                    ld   a,(mem)
  80+ 0000 ~                                    cp     value
  81+ 0000 ~                                    ret    z
  82+ 0000                                      ENDM
  83+ 0000
  84+ 0000              ReturnIfRegNotZero:     MACRO reg
  85+ 0000 ~                                    ld      a, reg
  86+ 0000 ~                                    and     a
  87+ 0000 ~                                    ret     nz
  88+ 0000                                      ENDM
  89+ 0000
  90+ 0000              ReturnIfANotZero:       MACRO
  91+ 0000 ~                                    and     a
  92+ 0000 ~                                    ret     nz
  93+ 0000                                      ENDM
  94+ 0000
  95+ 0000              ReturnIfNotZero:        MACRO
  96+ 0000 ~                                    ret     nz
  97+ 0000                                      ENDM
  98+ 0000
  99+ 0000              ReturnIfZero:           MACRO
 100+ 0000 ~                                    ret     z
 101+ 0000                                      ENDM
 102+ 0000
 103+ 0000              ReturnIfNegative:       MACRO
 104+ 0000 ~                                    ret     m
 105+ 0000                                      ENDM
 106+ 0000
 107+ 0000
 108+ 0000              ReturnIfMemNotZero:     MACRO mem
 109+ 0000 ~                                    ld     a,(mem)
 110+ 0000 ~                                    and     a
 111+ 0000 ~                                    ret    nz
 112+ 0000                                      ENDM
 113+ 0000
 114+ 0000              ReturnIfAGTEusng:       MACRO value
 115+ 0000 ~                                    cp    value
 116+ 0000 ~                                    ret	 nc
 117+ 0000                                      ENDM
 118+ 0000
 119+ 0000              ReturnIfRegLTNusng:     MACRO reg, value
 120+ 0000 ~                                    ld      a,reg
 121+ 0000 ~                                    cp      value
 122+ 0000 ~                                    ret	    c
 123+ 0000                                      ENDM
 124+ 0000
 125+ 0000              ReturnIfALTNusng:       MACRO value
 126+ 0000 ~                                    cp    value
 127+ 0000 ~                                    ret	 c
 128+ 0000                                      ENDM
 129+ 0000
 130+ 0000              ReturnIfAGTENusng:      MACRO value
 131+ 0000 ~                                    cp    value
 132+ 0000 ~                                    ret	 nc
 133+ 0000                                      ENDM
 134+ 0000
 135+ 0000              ReturnIfAGTEMemusng:    MACRO value
 136+ 0000 ~                                    ld      hl,value
 137+ 0000 ~                                    cp      (hl)
 138+ 0000 ~                                    ret	    nc
 139+ 0000                                      ENDM
 140+ 0000
 141+ 0000              ReturnIfANENusng:       MACRO value
 142+ 0000 ~                                    cp      value
 143+ 0000 ~                                    ret     nz
 144+ 0000                                      ENDM
 145+ 0000
 146+ 0000              ReturnIfAEqNusng:       MACRO value
 147+ 0000 ~                                    cp      value
 148+ 0000 ~                                    ret     z
 149+ 0000                                      ENDM
 150+ 0000
# file closed: ../../Macros/returnMacros.asm
  41  0000                                      INCLUDE "../../Macros/ShiftMacros.asm"
# file opened: ../../Macros/ShiftMacros.asm
   1+ 0000              ShiftIYRight1: MACRO
   2+ 0000 ~                           ld   a,iyh
   3+ 0000 ~                           srl  a
   4+ 0000 ~                           ld   iyh,a
   5+ 0000 ~                           ld   a,iyl
   6+ 0000 ~                           rra
   7+ 0000 ~                           ld   iyl,a
   8+ 0000                             ENDM
   9+ 0000
  10+ 0000              ShiftIXRight1: MACRO
  11+ 0000 ~                           ld   a,ixh
  12+ 0000 ~                           srl  a
  13+ 0000 ~                           ld   ixh,a
  14+ 0000 ~                           ld   a,ixl
  15+ 0000 ~                           rra
  16+ 0000 ~                           ld   ixl,a
  17+ 0000                             ENDM
  18+ 0000
  19+ 0000              ShiftIXhHLRight1: MACRO
  20+ 0000 ~                           ld  a,ixh
  21+ 0000 ~                           srl a
  22+ 0000 ~                           ld  ixh,a
  23+ 0000 ~                           rr  h
  24+ 0000 ~                           rr  l
  25+ 0000                             ENDM
  26+ 0000
  27+ 0000              ShiftIYhDERight1: MACRO
  28+ 0000 ~                           ld  a,iyh
  29+ 0000 ~                           srl a
  30+ 0000 ~                           ld  iyh,a
  31+ 0000 ~                           rr  d
  32+ 0000 ~                           rr  e
  33+ 0000                             ENDM
  34+ 0000
  35+ 0000              ShiftIYlBCRight1: MACRO
  36+ 0000 ~                           ld  a,iyl
  37+ 0000 ~                           srl a
  38+ 0000 ~                           ld  iyl,a
  39+ 0000 ~                           rr  b
  40+ 0000 ~                           rr  c
  41+ 0000                             ENDM
  42+ 0000
  43+ 0000              ShiftIXlBCRight1: MACRO
  44+ 0000 ~                           ld  a,ixl
  45+ 0000 ~                           srl a
  46+ 0000 ~                           ld  ixl,a
  47+ 0000 ~                           rr  b
  48+ 0000 ~                           rr  c
  49+ 0000                             ENDM
  50+ 0000
  51+ 0000              ShiftHLRight1: MACRO
  52+ 0000 ~                           srl h
  53+ 0000 ~                           rr  l
  54+ 0000                             ENDM
  55+ 0000
  56+ 0000              ShiftBHLRight1:MACRO
  57+ 0000 ~                           srl b
  58+ 0000 ~                           rr h
  59+ 0000 ~                           rr  l
  60+ 0000                             ENDM
  61+ 0000
  62+ 0000              ShiftCDERight1:MACRO
  63+ 0000 ~                           srl c
  64+ 0000 ~                           rr  d
  65+ 0000 ~                           rr  e
  66+ 0000                             ENDM
  67+ 0000
  68+ 0000
  69+ 0000              SRAHLRight1: MACRO
  70+ 0000 ~                           sra h
  71+ 0000 ~                           rr  l
  72+ 0000                             ENDM
  73+ 0000
  74+ 0000              ShiftDERight1: MACRO
  75+ 0000 ~                           srl d
  76+ 0000 ~                           rr  e
  77+ 0000                             ENDM
  78+ 0000
  79+ 0000              ShiftBCRight1: MACRO
  80+ 0000 ~                           srl b
  81+ 0000 ~                           rr  c
  82+ 0000                             ENDM
  83+ 0000
  84+ 0000
  85+ 0000              ShiftHLDiv8:   MACRO
  86+ 0000 ~                           srl h
  87+ 0000 ~                           rr  l
  88+ 0000 ~                           srl h
  89+ 0000 ~                           rr  l
  90+ 0000 ~                           srl h
  91+ 0000 ~                           rr  l
  92+ 0000                             ENDM
  93+ 0000
  94+ 0000              ShiftBHLLeft1:  MACRO
  95+ 0000 ~                            sla l
  96+ 0000 ~                            rl  h
  97+ 0000 ~                            rl  b
  98+ 0000                              ENDM
  99+ 0000
 100+ 0000              ShiftCDELeft1:  MACRO
 101+ 0000 ~                            sla e
 102+ 0000 ~                            rl  d
 103+ 0000 ~                            rl  c
 104+ 0000                              ENDM
 105+ 0000
 106+ 0000              ShiftHLLeft1:  MACRO    ; 16 T states
 107+ 0000 ~                           sla l
 108+ 0000 ~                           rl  h
 109+ 0000                             ENDM
 110+ 0000
 111+ 0000              ShiftDELeft1:  MACRO    ; 16 T states
 112+ 0000 ~                           sla e
 113+ 0000 ~                           rl  d
 114+ 0000                             ENDM
 115+ 0000
 116+ 0000              BarrelHLLeft3: MACRO
 117+ 0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
 118+ 0000 ~                           push     bc      ; 10
 119+ 0000 ~                           ld       b,3     ; 7
 120+ 0000 ~                           bsrl     de,b    ; 8
 121+ 0000 ~                           pop      bc      ; 10
 122+ 0000 ~                           ex       de,hl   ; 4
 123+ 0000                             ENDM
 124+ 0000
 125+ 0000              BarrelHLRight3: MACRO
 126+ 0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
 127+ 0000 ~                           push     bc      ; 10
 128+ 0000 ~                           ld       b,3     ; 7
 129+ 0000 ~                           bsrl     de,b    ; 8
 130+ 0000 ~                           pop      bc      ; 10
 131+ 0000 ~                           ex       de,hl   ; 4
 132+ 0000                             ENDM
 133+ 0000
 134+ 0000              RollBCLeft1:   MACRO    ; 16 T states
 135+ 0000 ~                           rl  c
 136+ 0000 ~                           rl  b
 137+ 0000                             ENDM
 138+ 0000
 139+ 0000              RollDELeft1:   MACRO    ; 16 T states
 140+ 0000 ~                           rl  e
 141+ 0000 ~                           rl  d
 142+ 0000                             ENDM
 143+ 0000
 144+ 0000              ShiftBCLeft1:  MACRO    ; 16 T states
 145+ 0000 ~                           sla c
 146+ 0000 ~                           rl  b
 147+ 0000                             ENDM
 148+ 0000
 149+ 0000              ShiftLeftMem:       MACRO   reg
 150+ 0000 ~                                ld      hl,reg
 151+ 0000 ~                                sla     (hl)
 152+ 0000                                  ENDM
 153+ 0000
 154+ 0000
 155+ 0000
 156+ 0000              ShiftMem16Right1:   MACRO memaddr
 157+ 0000 ~                                ld    hl,(memaddr)
 158+ 0000 ~                                srl   h
 159+ 0000 ~                                rr    l
 160+ 0000 ~                                ld    (memaddr),hl
 161+ 0000                                  ENDM
 162+ 0000
 163+ 0000              ShiftMem8Right1:    MACRO memaddr
 164+ 0000 ~                                ld      a,(memaddr)
 165+ 0000 ~                                srl     a
 166+ 0000 ~                                ld      (memaddr),a
 167+ 0000                                  ENDM
 168+ 0000
 169+ 0000
 170+ 0000              ShiftMem8Left1A:    MACRO memaddr
 171+ 0000 ~                                ld      a,(memaddr)
 172+ 0000 ~                                sla     a
 173+ 0000 ~                                ld      (memaddr),a
 174+ 0000                                  ENDM
 175+ 0000
# file closed: ../../Macros/ShiftMacros.asm
  42  0000                                      INCLUDE "../../Macros/signBitMacros.asm"
# file opened: ../../Macros/signBitMacros.asm
   1+ 0000              SetMemBitN              MACRO mem,bitnbr
   2+ 0000 ~                                    ld      hl,mem
   3+ 0000 ~                                    set     bitnbr,(hl)
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              ClearMemBitN            MACRO mem,bitnbr
   7+ 0000 ~                                    ld      hl,mem
   8+ 0000 ~                                    res     bitnbr,(hl)
   9+ 0000                                      ENDM
  10+ 0000
  11+ 0000
  12+ 0000              ClearSignBitMem:        MACRO mem
  13+ 0000 ~                                    ld      a,(mem)
  14+ 0000 ~                                    and     SignMask8Bit
  15+ 0000 ~                                    ld      (mem),a
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              SetSignBitMem:          MACRO   mem
  19+ 0000 ~                                    ld      a,(mem)
  20+ 0000 ~                                    or      SignOnly8Bit
  21+ 0000 ~                                    ld      (mem),a
  22+ 0000                                      ENDM
  23+ 0000
  24+ 0000              FlipSignMem:            MACRO mem
  25+ 0000 ~                                    ld  a,(mem)
  26+ 0000 ~                                    xor SignOnly8Bit
  27+ 0000 ~                                    ld  (mem),a
  28+ 0000                                      ENDM
  29+ 0000
  30+ 0000              SignBitOnlyMem:         MACRO mem
  31+ 0000 ~                                    ld      a, (mem)
  32+ 0000 ~                                    and     SignOnly8Bit
  33+ 0000 ~                                    ld      (mem),a
  34+ 0000                                      ENDM
  35+ 0000
  36+ 0000              ClearSignBit:           MACRO reg
  37+ 0000 ~                                    ld      a,reg
  38+ 0000 ~                                    and     SignMask8Bit
  39+ 0000 ~                                    ld      reg,a
  40+ 0000                                      ENDM
  41+ 0000
  42+ 0000              SetSignBit:             MACRO   reg
  43+ 0000 ~                                    ld      a,reg
  44+ 0000 ~                                    or      SignOnly8Bit
  45+ 0000 ~                                    ld      reg,a
  46+ 0000                                      ENDM
  47+ 0000
  48+ 0000              FlipSignBit:            MACRO   reg
  49+ 0000 ~                                    ld      a, reg
  50+ 0000 ~                                    xor     SignOnly8Bit
  51+ 0000 ~                                    ld      reg,a
  52+ 0000                                      ENDM
  53+ 0000
  54+ 0000              SignBitOnly:            MACRO   reg
  55+ 0000 ~                                    ld      a, reg
  56+ 0000 ~                                    and     SignOnly8Bit
  57+ 0000 ~                                    ld      reg,a
  58+ 0000                                      ENDM
  59+ 0000
  60+ 0000              ClearSignBitA:          MACRO
  61+ 0000 ~                                    and     SignMask8Bit
  62+ 0000                                      ENDM
  63+ 0000
  64+ 0000              SetSignBitA:            MACRO
  65+ 0000 ~                                    or      SignOnly8Bit
  66+ 0000                                      ENDM
  67+ 0000
  68+ 0000              FlipSignBitA:           MACRO
  69+ 0000 ~                                    xor     SignOnly8Bit
  70+ 0000                                      ENDM
  71+ 0000
  72+ 0000              SignBitOnlyA:           MACRO
  73+ 0000 ~                                    and     SignOnly8Bit
  74+ 0000                                      ENDM
# file closed: ../../Macros/signBitMacros.asm
  43  0000                                      INCLUDE "../../Macros/KeyboardMacros.asm"
# file opened: ../../Macros/KeyboardMacros.asm
   1+ 0000              MacroIsKeyPressed:      MACRO C_Pressed_keycode
   2+ 0000 ~                                    ld      a,C_Pressed_keycode
   3+ 0000 ~                                    MMUSelectKeyboard
   4+ 0000 ~                                    call    is_key_pressed
   5+ 0000                                      ENDM
   6+ 0000
   7+ 0000              MacroInitkeyboard:      MACRO
   8+ 0000 ~                                    MMUSelectKeyboard
   9+ 0000 ~                                    call    init_keyboard
  10+ 0000                                      ENDM
  11+ 0000
# file closed: ../../Macros/KeyboardMacros.asm
  44  0000                                      INCLUDE "../../Universe/UniverseMacros/asm_linedraw.asm"
# file opened: ../../Universe/UniverseMacros/asm_linedraw.asm
   1+ 0000              ClippingVarsMacro:   MACRO   prefix1?
   2+ 0000 ~            ;-- Clipping code for universe objects -------------------------------------------
   3+ 0000 ~            prefix1?_XX13        DB 0
   4+ 0000 ~
   5+ 0000 ~
   6+ 0000 ~            prefix1?_varK3		 DS	4				; D2
   7+ 0000 ~            prefix1?_centreX     equ prefix1?_varK3
   8+ 0000 ~            prefix1?_varK3p2	 DB	0				; 42
   9+ 0000 ~            prefix1?_varK3p3	 DB	0				; 43
  10+ 0000 ~            prefix1?_varK3p1	 equ prefix1?_varK3+1			; D3
  11+ 0000 ~            prefix1?_varK4		 DS	4				; E0
  12+ 0000 ~            prefix1?_centreY     equ prefix1?_varK4
  13+ 0000 ~            prefix1?_varK4p1	 equ prefix1?_varK4+1			; D3
  14+ 0000 ~            prefix1?_varK5       DS  6
  15+ 0000 ~            prefix1?_varK5p2     equ prefix1?_varK5+2
  16+ 0000 ~            prefix1?_varK6       DS  6
  17+ 0000 ~            prefix1?_varK6p2     equ prefix1?_varK6+2
  18+ 0000 ~
  19+ 0000 ~            prefix1?_XX12p2      DB 0    ; The line's gradient * 256 (so 1.0 = 256)
  20+ 0000 ~            prefix1?_XX12p3      DB 0    ; The direction of slope ; + LT to BR; - TR to BL
  21+ 0000 ~            prefix1?_XX12p4      DB 0
  22+ 0000 ~            prefix1?_XX12p5      DB 0
  23+ 0000 ~            prefix1?_Delta_x     EQU prefix1?_XX12p2
  24+ 0000 ~            prefix1?_Delta_y     EQU prefix1?_XX12p4
  25+ 0000 ~            prefix1?_Tvar        DB 0    ; The gradient of slope ; 0 if it's a shallow slope (DX > DY) ; &FF if it's a steep slope (DY > DX) Returns:  XX15        m         x1 as an 8-bit coordinate XX15+2               y1 as an 8-bit coordinate
  26+ 0000 ~            prefix1?_Qvar        DB 0
  27+ 0000 ~            prefix1?_Rvar        DB 0    ; general purpose for calcs  Paired with S must be done this way round for SUBHeightFromY1 etc to work
  28+ 0000 ~            prefix1?_Svar        DB 0    ; sign variable
  29+ 0000 ~            prefix1?_SRvarPair   EQU prefix1?_Rvar
  30+ 0000 ~            prefix1?_Xreg        DB 0
  31+ 0000 ~            prefix1?_Yreg        DB 0
  32+ 0000 ~            prefix1?_YXregPair   EQU prefix1?_Xreg
  33+ 0000                                   ENDM
  34+ 0000
  35+ 0000              ;-- Name: LL28 Calculate R = 256 * A / Q
  36+ 0000              ;-- LL28+4              Skips the A >= Q check and always returns with C flag cleared, so this can be called if we know the division will work
  37+ 0000              ;-- LL31                Skips the A >= Q check and does not set the R counter, so this can be used for jumping straight into the division loop if R is already set to 254 and we know the division will work
  38+ 0000              ;   Reg mapping 6502  Z80
  39+ 0000              ;               a     a
  40+ 0000              ;               b     x
  41+ 0000              ;               c     q
  42+ 0000              ;               d     r
  43+ 0000              ;
  44+ 0000              ClippingCodeLL28Macro:      MACRO   prefix1?
  45+ 0000 ~            prefix1?_LL28_6502:         ld      hl,Qvar                 ; CMP Q                  \ If A >= Q, then the answer will not fit in one byte,
  46+ 0000 ~                                        ld      c,(hl)                  ; using c as Q var
  47+ 0000 ~                                        cp      c
  48+ 0000 ~                                        FlipCarryFlag
  49+ 0000 ~                                        jp      c, prefix1?_LL2_6502    ; BCS LL2                \ so jump to LL2 to return 255
  50+ 0000 ~                                        ld      b,$FE                   ; LDX #%11111110         \ Set R to have bits 1-7 set, so we can rotate through 7 loop iterations, getting a 1 each time, and then we use b as Rvar
  51+ 0000 ~            prefix1?_LL31_6502:          sla     a                       ; ASL A                  \ Shift A to the left
  52+ 0000 ~                                        jp      c, prefix1?_LL29_6502             ; BCS LL29               \ If bit 7 of A was set, then jump straight to the subtraction
  53+ 0000 ~                                        FlipCarryFlag                   ;                          If A < N, then C flag is set.
  54+ 0000 ~                                        JumpIfALTNusng c, prefix1?_LL31_SKIPSUB_6502 ; CMP Q              \ If A < Q, skip the following subtraction
  55+ 0000 ~                                                                            ; BCC P%+4
  56+ 0000 ~                                        sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  57+ 0000 ~                                        ClearCarryFlag
  58+ 0000 ~            prefix1?_LL31_SKIPSUB_6502:  FlipCarryFlag
  59+ 0000 ~                                        rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  60+ 0000 ~                                        jp      c, prefix1?_LL31_6502            ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  61+ 0000 ~                                        ld      a,b
  62+ 0000 ~                                        ld      (Rvar),a
  63+ 0000 ~                                        ret                             ; RTS                    \ R left with remainder of division
  64+ 0000 ~            prefix1?_LL29_6502:          sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  65+ 0000 ~                                        SetCarryFlag                    ; SEC                    \ Set the C flag to rotate into the result in R
  66+ 0000 ~                                        rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  67+ 0000 ~                                        jp      c, prefix1?_LL31_6502            ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  68+ 0000 ~                                        ld      a,b                     ; RTS                    \ Return from the subroutine with R containing the
  69+ 0000 ~                                        ld      (Rvar),a                ; .
  70+ 0000 ~                                        ret                             ; .                      \ remainder of the division
  71+ 0000 ~            prefix1?_LL2_6502:          ld      a,$FF                   ; LDA #255               \ The division is very close to 1, so return the closest
  72+ 0000 ~                                        ld      (Rvar),a                ; STA R                  \ possible answer to 256, i.e. R = 255
  73+ 0000 ~                                        SetCarryFlag                    ; we failed so need carry flag set
  74+ 0000 ~                                        ret                             ; RTS                    \ Return from the subroutine
  75+ 0000 ~
  76+ 0000 ~            prefix1?_ADDXRegtoY1:       ld      a,(Xreg)                ; Set y1 = y1 + (Y X)
  77+ 0000 ~                                        ld      c,a
  78+ 0000 ~                                        ld      b,0
  79+ 0000 ~                                        ld      hl,(prefix1?_XX1532)
  80+ 0000 ~                                        ClearCarryFlag
  81+ 0000 ~                                        adc     hl,bc
  82+ 0000 ~                                        ld      (prefix1?_XX1532),hl
  83+ 0000 ~                                        ret
  84+ 0000 ~
  85+ 0000 ~            prefix1?_ADDYXRegtoY1:      ld      bc,(YXregPair)          ; Set y1 = y1 + (Y X)
  86+ 0000 ~                                        ld      hl,(prefix1?_XX1532)
  87+ 0000 ~                                        ClearCarryFlag
  88+ 0000 ~                                        adc     hl,bc
  89+ 0000 ~                                        ld      (prefix1?_XX1532),hl
  90+ 0000 ~                                        ret
  91+ 0000 ~
  92+ 0000 ~            prefix1?_ADDYXRegtoX1:      ld      bc,(YXregPair)          ; Set x1 = x1 + (Y X)
  93+ 0000 ~                                        ld      hl,(prefix1?_XX1510)
  94+ 0000 ~                                        ClearCarryFlag
  95+ 0000 ~                                        adc     hl,bc
  96+ 0000 ~                                        ld      (prefix1?_XX1510),hl
  97+ 0000 ~                                        ret
  98+ 0000 ~
  99+ 0000 ~            prefix1?_SUBBCFromY1:       ld      hl,(prefix1?_XX1532)             ; Set (S R) = (y1_hi y1_lo) - BC where BC can be say screen height
 100+ 0000 ~                                        ClearCarryFlag
 101+ 0000 ~                                        sbc     hl,bc
 102+ 0000 ~                                        ld      (SRvarPair),hl
 103+ 0000 ~                                        ret
 104+ 0000 ~
 105+ 0000 ~            prefix1?_AddSRToYX:         ld      hl,(YXregPair)
 106+ 0000 ~                                        ld      de,(SRvarPair)
 107+ 0000 ~                                        ClearCarryFlag
 108+ 0000 ~                                        adc     hl,de
 109+ 0000 ~                                        ld      (YXregPair),hl
 110+ 0000 ~                                        ret
 111+ 0000 ~
 112+ 0000 ~            prefix1?_ClampX:            ld      a,h
 113+ 0000 ~                                        and     a
 114+ 0000 ~                                        ld      a,l
 115+ 0000 ~                                        ret     z
 116+ 0000 ~                                        jp      p,.Max255
 117+ 0000 ~            .ClampXMin0:                ZeroA
 118+ 0000 ~                                        ret
 119+ 0000 ~            .Max255:                    ld      a,$FF
 120+ 0000 ~                                        ret
 121+ 0000 ~
 122+ 0000 ~            prefix1?_ClampY:            ld      a,h
 123+ 0000 ~                                        and     a
 124+ 0000 ~                                        jp      z,.ClampYlo
 125+ 0000 ~                                        jp      p,.Max127
 126+ 0000 ~            .ClampYMin0:                ZeroA
 127+ 0000 ~                                        ret
 128+ 0000 ~            .Max127:                    ld      a,127
 129+ 0000 ~                                        ret
 130+ 0000 ~            .ClampYlo:                  ld      a,l
 131+ 0000 ~                                        and     a
 132+ 0000 ~                                        ret     p
 133+ 0000 ~                                        ld      a,127
 134+ 0000 ~                                        ret
 135+ 0000                                          ENDM
 136+ 0000              ;-- Rountes to code:
 137+ 0000              ;-- LL118
 138+ 0000              ;-- LL120   Done
 139+ 0000              ;-- LL129   Done
 140+ 0000              ;-- LL123   Done
 141+ 0000                             ; NOTE DOES ABS ONLY
 142+ 0000
 143+ 0000
 144+ 0000                              ;--- LL118 Move along a point until on screen
 145+ 0000              ; In XX1510 x1 as a 16-bit coordinate (x1_hi x1_lo)
 146+ 0000              ;    XX1532 y1 as a 16-bit coordinate (y1_hi y1_lo)
 147+ 0000              ;    XX12p2 The line's gradient * 256 (so 1.0 = 256)
 148+ 0000              ;    XX12p3 The direction of slope: * Positive = top left to bottom right * Negative (bit 7 set) = top right to bottom left
 149+ 0000              ;    T      The gradient of slope:* 0 if it's a shallow slope * &FF if it's a steep slope
 150+ 0000              ;  Out  XX150               x1 as an 8-bit coordinate
 151+ 0000              ;       XX152               y1 as an 8-bit coordinate
 152+ 0000              ;----------------------------------------------------------------------------------------------------------------
 153+ 0000
 154+ 0000
 155+ 0000              ;---------------------------------------------------------------------------------------------------------------------
 156+ 0000              ;--  Calculate the following:
 157+ 0000              ;--   * If T = 0, this is a shallow slope, so calculate (Y X) = (S x1_lo) * XX12+2
 158+ 0000              ;--   * If T <> 0, this is a steep slope, so calculate (Y X) = (S x1_lo) / XX12+2
 159+ 0000              ;-- giving (Y X) the opposite sign to the slope direction in XX12+3.
 160+ 0000              ;---------------------------------------------------------------------------------------------------------------------
 161+ 0000              ClippingCodeLL120Macro:     MACRO   prefix1?
 162+ 0000 ~            prefix1?_LL120_6502:        ld      a,(prefix1?_XX1510)              ;LDA XX15               \ Set R = x1_lo
 163+ 0000 ~                                        ld      (Rvar),a                ;STA R
 164+ 0000 ~                                        call    prefix1?_LL129_6502              ;JSR LL129              \ Call LL129 to do the following:  Q = XX12+2 = line gradient, A = S EOR XX12+3 = S EOR slope direction  (S R) = |S R|
 165+ 0000 ~                                        push    af                      ;PHA                    \ Store A on the stack so we can use it later
 166+ 0000 ~            ; DONT NEED PLUS MESSES UP FLAGS                    push    af                      ;LDX T                  \ If T is non-zero, then it's a steep slope, so jump
 167+ 0000 ~                                        ld      a,(Tvar)                ; .
 168+ 0000 ~                                        ld      (Xreg),a                ;. REDUNDANT REMOVE IN OPTIMISATION
 169+ 0000 ~                                        and     a                       ;BNE LL121              \ down to LL121 to calculate this instead (Y X) = (S R) / Q
 170+ 0000 ~            ; DONT NEED PLUS MESSES UP FLAGS                    pop     af                      ;.                      (recover teh saved A before the cp)
 171+ 0000 ~                                        jr      nz,prefix1?_LL121_6502           ;.
 172+ 0000 ~            ;..   (Y X) = (S R) * Q - must be ABS, sign determined by opposite of the sign of the value on top of stack
 173+ 0000 ~            prefix1?_LL122_6502:         ZeroA                           ;LDA #0                 \ Set A = 0
 174+ 0000 ~
 175+ 0000 ~                                        IFDEF DEBUG_LL122_DIRECT"
 176+ 0000 ~                                              DISPLAY "DIRECT CALL TO LL122 so dummy push a to stack with 0"
 177+ 0000 ~                                              push    af
 178+ 0000 ~                                        ENDIF
 179+ 0000 ~                                        ld      (Xreg),a                ;TAX                    \ Set (Y X) = 0 so we can start building the answer here
 180+ 0000 ~                                        ld      (Yreg),a                ;TAY
 181+ 0000 ~                                        ld      hl,Svar
 182+ 0000 ~                                        ld      bc,(SRvarPair)          ;LSR S                  \ Shift (S R) to the right, so we extract bit 0 of (S R)
 183+ 0000 ~                                        ShiftBCRight1                   ;ROR R                  \ into the C flag
 184+ 0000 ~                                        ld      (SRvarPair),bc
 185+ 0000 ~                                        ld      hl, Qvar                ;ASL Q                  \ Shift Q to the left, catching bit 7 in the C flag
 186+ 0000 ~                                        sla     (hl)                    ;.
 187+ 0000 ~                                        jr      nc, prefix1?_LL126_6502          ;BCC LL126              \ If C (i.e. the next bit from Q) is clear, do not do
 188+ 0000 ~            ; the addition for this bit of Q, and instead skip to LL126 to just do the shifts
 189+ 0000 ~            prefix1?_LL125_6502:        call    AddSRToYX               ;TXA                    \ Set (Y X) = (Y X) + (S R)  starting with the low bytes And then doing the high bytes
 190+ 0000 ~            prefix1?_LL126_6502:        ld      bc,(SRvarPair)          ;LSR S                  \ Shift (S R) to the right
 191+ 0000 ~                                        ShiftBCRight1                   ;ROR R
 192+ 0000 ~                                        ld      (SRvarPair),bc          ;.
 193+ 0000 ~                                        ld      hl, Qvar                ;ASL Q                  \ Shift Q to the left, catching bit 7 in the C flag
 194+ 0000 ~                                        sla     (hl)                    ;.
 195+ 0000 ~                                        jr      c,prefix1?_LL125_6502            ;BCS LL125              \ If C (i.e. the next bit from Q) is set, loop back to LL125 to do the addition for this bit of Q
 196+ 0000 ~                                        jr      nz,prefix1?_LL126_6502           ;BNE LL126              \ If Q has not yet run out of set bits, loop back to LL126 to do the \"shift\" part of shift-and-add until we have done additions for all the set bits in Q, to give us our multiplication result
 197+ 0000 ~                                        pop     af                      ;PLA                    \ Restore A, which we calculated above, from the stack
 198+ 0000 ~                                        and     a                       ;BPL LL133              \ If A is positive jump to LL133 to negate (Y X) and
 199+ 0000 ~                                        jp      p,prefix1?_LL133_6502            ;.
 200+ 0000 ~                                        ;.. return from the subroutine using a tail call
 201+ 0000 ~                                        ret                             ;RTS                    \ Return from the subroutine
 202+ 0000                                  ENDM
 203+ 0000              ;----------------------------------------------------------------------------------------------------------------------------
 204+ 0000              ;-- Calculate the following:
 205+ 0000              ;--         * If T = 0, this is a shallow slope, so calculate (Y X) = (S R) / XX12+2 (does not use X1lo but directly SR)
 206+ 0000              ;--         * If T <> 0, this is a steep slope, so calculate (Y X) = (S R) * XX12+2  (does not use X1lo but directly SR)
 207+ 0000              ;--             giving (Y X) the opposite sign to the slope direction in XX12+3.
 208+ 0000              ClippingCodeLL122Macro:      MACRO   prefix1?
 209+ 0000 ~            prefix1?_LL123_6502:         call    prefix1?_LL129_6502              ;JSR LL129              \ Call LL129 to do the following   Q = XX12+2   = line gradient
 210+ 0000 ~                                         push    af                      ;PHA                    \ Store A on the stack so we can use it later
 211+ 0000 ~            ; DONT NEED PLUS MESSES UP FLAGS                    push    af                      ;LDX T                  \ If T is non-zero, then it's a steep slope, so jump up
 212+ 0000 ~                                         ld      a,(Tvar)                ; .
 213+ 0000 ~                                         ld      (Xreg),a                ;BNE LL122              \ to LL122 to calculate this instead:
 214+ 0000 ~                                         and     a                       ;.
 215+ 0000 ~            ;  DONT NEED PLUS MESSES UP FLAGS                    pop     af                      ;.
 216+ 0000 ~                                         jr      nz,prefix1?_LL122_6502           ;.
 217+ 0000 ~            ;--  The following calculates: (Y X) = (S R) / Q using the same shift-and-subtract algorithm that's documented in TIS2
 218+ 0000 ~            prefix1?_LL121_6502:         ld      a,$FF                   ;LDA #%11111111         \ Set Y = %11111111
 219+ 0000 ~                                         ld      (Yreg),a                ;TAY
 220+ 0000 ~                                         sla     a                       ;ASL A                  \ Set X = %11111110
 221+ 0000 ~                                         ld      (Xreg),a                ;TAX
 222+ 0000 ~            ;--  This sets (Y X) = %1111111111111110, so we can rotate through 15 loop iterations, getting a 1 each time, and then getting a 0 on the 16th iteration... and we can also use it to catch our result bits into bit 0 each time
 223+ 0000 ~            prefix1?_LL130_6502:         ld      bc,(SRvarPair)          ;ASL R                  \ Shift (S R) to the left
 224+ 0000 ~                                        ShiftBCLeft1                    ;.
 225+ 0000 ~                                        ld      (SRvarPair),bc          ;ROL S
 226+ 0000 ~                                        ld      a,(Svar)                ;LDA S                  \ Set A = S
 227+ 0000 ~                                        jr      c, prefix1?_LL131_6502           ;BCS LL131              \ If bit 7 of S was set, then jump straight to the subtraction
 228+ 0000 ~                                        ld      hl,Qvar                 ;CMP Q                  \ If A < Q (i.e. S < Q), skip the following subtractions
 229+ 0000 ~                                        cp      (hl)
 230+ 0000 ~                                        FlipCarryFlag                   ; note flip carry flag here to simulate 6502 operation
 231+ 0000 ~                                        jr      nc,prefix1?_LL132A_6502          ;BCC LL132  (NOTE Carry flag reversed in Z80 for CP)
 232+ 0000 ~            prefix1?_LL131_6502:         FlipCarryFlag                   ;flip carry to make it act like a 6502 borrow
 233+ 0000 ~                                        sbc     (hl)                    ;SBC Q                  \ A >= Q (i.e. S >= Q) so set:
 234+ 0000 ~                                        ld      (Svar),a                ;STA S
 235+ 0000 ~                                        ld      a,(Rvar)                ;LDA R                  \ And then doing the high bytes
 236+ 0000 ~                                        ClearCarryFlag                  ;\   S = (A R) - Q  = (S R) - Q starting with the low bytes (we know the C flag is set so the subtraction will be correct)
 237+ 0000 ~                                        sbc     0                       ;SBC #0
 238+ 0000 ~                                        ld      (Rvar),a                ;STA R
 239+ 0000 ~                                        SetCarryFlag                    ;SEC                    \ Set the C flag to rotate into the result in (Y X)
 240+ 0000 ~                                        jp      prefix1?_LL132_6502              ;added so that we can do a 6502 style carry above
 241+ 0000 ~            prefix1?_LL132A_6502:        nop; FlipCarryFlag
 242+ 0000 ~            prefix1?_LL132_6502:         ld      bc,(YXregPair)          ; Rotate the counter in (Y X) to the left, and catch the
 243+ 0000 ~                                        RollBCLeft1                     ; ROL A                  \ result bit into bit 0 (which will be a 0 if we didn't
 244+ 0000 ~                                        ld      (YXregPair),bc          ; TAX                    \ do the subtraction, or 1 if we did)
 245+ 0000 ~                                        jr      c, prefix1?_LL130_6502           ; BCS LL130              \ If we still have set bits in (Y X), loop back to LL130 to do the next iteration of 15, until we have done the whole division
 246+ 0000 ~                    IFDEF DEBUG_LL121_DIRECT
 247+ 0000 ~                          DISPLAY "DIRECT CALL TO LL121 so dummy push"
 248+ 0000 ~                                        push    af
 249+ 0000 ~                    ENDIF
 250+ 0000 ~                                        pop     af                      ; PLA                    \ Restore A, which we calculated above, from the stack
 251+ 0000 ~                                        and     a                       ; BMI LL128              \ If A is negative jump to LL128 to return from the
 252+ 0000 ~                                        jp      m, prefix1?_LL128_6502           ; .                      \ subroutine with (Y X) as is
 253+ 0000 ~            prefix1?_LL133_6502:          ld      bc,(YXregPair)          ; TXA                    \ Otherwise negate (Y X) using two's complement by first
 254+ 0000 ~                                        macronegate16bc                 ; EOR #%11111111         \ setting the low byte to ~X + 1
 255+ 0000 ~                                        ld      (YXregPair),bc          ; ADC #1                 \ The addition works as we know the C flag is clear from\ when we passed through the BCS above
 256+ 0000 ~            prefix1?_LL128_6502:          ret                             ; RTS                    \ Return from the subroutine
 257+ 0000 ~            ;-------------------------------------------------------------------------------------------------------
 258+ 0000 ~            ;..  Do the following, in this order: Q = XX12+2 A = S EOR XX12+3 (S R) = |S R|
 259+ 0000 ~            ;..  This sets up the variables required above to calculate (S R) / XX12+2 and give the result the opposite sign to XX13+3.
 260+ 0000 ~            prefix1?_LL129_6502:        push    af                      ;LDX XX12+2             \ Set Q = XX12+2
 261+ 0000 ~                                        ld      a,(prefix1?_XX12p2)              ;.
 262+ 0000 ~                                        ld      (Xreg),a                ;.
 263+ 0000 ~                                        ld      (Qvar),a                ;STX Q
 264+ 0000 ~                                        pop     af                      ;.
 265+ 0000 ~                                        ld      a,(Svar)                ;LDA S                  \ If S is positive, jump to LL127
 266+ 0000 ~                                        and     a                       ;BPL LL127
 267+ 0000 ~                                        jp      p,prefix1?_LL127_6502            ;.
 268+ 0000 ~                                        ZeroA                           ;.LDA #0                \ Otherwise set R = -R
 269+ 0000 ~                                        ClearCarryFlag                  ;SEC
 270+ 0000 ~                                        ld      hl, Rvar                ;SBC R
 271+ 0000 ~                                        sbc     (hl)                    ;.
 272+ 0000 ~                                        ld      (Rvar),a                ;STA R
 273+ 0000 ~                                        ld      a,(Svar)                ;LDA S                  \ Push S onto the stack
 274+ 0000 ~                                        push    af                      ;PHA
 275+ 0000 ~                                        xor     $FF                     ;EOR #%11111111         \ Set S = ~S + 1 + C  ?? is this all just doing |Svar|?
 276+ 0000 ~                                        adc     0                       ;ADC #0
 277+ 0000 ~                                        ld      (Svar),a                ;STA S
 278+ 0000 ~                                        pop     af                      ;PLA                    \ Pull the original, negative S from the stack into A
 279+ 0000 ~            prefix1?_LL127_6502:        ld      hl,prefix1?_XX12p3               ;EOR XX12+3             \ Set A = original argument S EOR'd with XX12+3
 280+ 0000 ~                                        xor     (hl)                    ;.
 281+ 0000 ~                                        ret                             ;RTS                    \ Return from the subroutine
 282+ 0000 ~            ;----------------------------------------------------------------------------------------------------------------
 283+ 0000 ~            ;--- LL118 Move along a point until on screen
 284+ 0000 ~            ; In XX1510 x1 as a 16-bit coordinate (x1_hi x1_lo)
 285+ 0000 ~            ;    XX1532 y1 as a 16-bit coordinate (y1_hi y1_lo)
 286+ 0000 ~            ;    XX12p2 The line's gradient * 256 (so 1.0 = 256)
 287+ 0000 ~            ;    XX12p3 The direction of slope: * Positive = top left to bottom right * Negative (bit 7 set) = top right to bottom left
 288+ 0000 ~            ;    T      The gradient of slope:* 0 if it's a shallow slope * &FF if it's a steep slope
 289+ 0000 ~            ;  Out  XX150               x1 as an 8-bit coordinate
 290+ 0000 ~            ;       XX152               y1 as an 8-bit coordinate
 291+ 0000 ~            ;----------------------------------------------------------------------------------------------------------------
 292+ 0000 ~
 293+ 0000 ~            prefix1?_LL118_6502:         ld      a,(prefix1?_XX1510+1)            ; LDA XX15+1             \ If x1_hi is positive, jump down to LL119 to skip the
 294+ 0000 ~                                        and     a                       ; BPL LL119              \ .
 295+ 0000 ~                                        jp      p, prefix1?_LL119_6502           ;                        \ following
 296+ 0000 ~            .X1Negative:                ld      (Svar),a                ; STA S                  \ Otherwise x1_hi is negative, i.e. off the left of the screen, so set S = x1_hi
 297+ 0000 ~                                        call    prefix1?_LL120_6502              ; Call LL120 to calculate:  (Y X) = (S x1_lo) * XX12+2      if T = 0   = x1 * gradient
 298+ 0000 ~                                                                ;                            (Y X) = (S x1_lo) / XX12+2      if T <> 0  = x1 / gradient
 299+ 0000 ~                                                                ; with the sign of (Y X) set to the opposite of the line's direction of slope
 300+ 0000 ~                                        call    ADDYXRegtoY1             ; Set y1 = y1 + (Y X)
 301+ 0000 ~                                        ld      (prefix1?_XX1532),hl             ; .
 302+ 0000 ~                                        ld      hl,0                    ; Set x1 = 0
 303+ 0000 ~                                        ld      (prefix1?_XX1510),hl             ; .
 304+ 0000 ~                                        ld      a,0                     ; set 0 up for replacemetn of the TAX and BEQ bit
 305+ 0000 ~                                        ld      (Xreg),a                ; TAX                    \ Set X = 0 so the next BEQ becomes a jmp but we will do it anyway in next line
 306+ 0000 ~                                        jp      prefix1?_LL134_6502              ; just do the jump to LL134 rather than setting to equal flag and then jumping
 307+ 0000 ~            ;-- Entering LL119 a will always be the value of X1 Hi byte
 308+ 0000 ~            prefix1?_LL119_6502:         jp      z,prefix1?_LL134_6502            ; BEQ LL134              \ x1_hi = 0 then jump down to LL134 to skip the following, as the x-coordinate is already on-screen
 309+ 0000 ~                                                                        ;                        \ (as 0 <= (x_hi x_lo) <= 255)
 310+ 0000 ~                                        ld      (Svar),a                ; STA S                  \ Otherwise x1_hi is positive, i.e. x1 >= 256 and off
 311+ 0000 ~                                        dec     a                       ; DEC S                  \ the right side of the screen, so set S = x1_hi - 1
 312+ 0000 ~                                        ld      (Svar),a                ;
 313+ 0000 ~                                        call    prefix1?_LL120_6502              ; JSR LL120              \ Call LL120 to calculate:  (Y X) = (S x1_lo) * XX12+2      if T = 0   = (x1 - 256) * gradient
 314+ 0000 ~                                                                        ;                        \                           (Y X) = (S x1_lo) / XX12+2      if T <> 0 = (x1 - 256) / gradient
 315+ 0000 ~                                                                        ;                        \ with the sign of (Y X) set to the opposite of the line's direction of slope
 316+ 0000 ~                                        call    ADDYXRegtoY1             ; TXA                    \ Set y1 = y1 + (Y X)
 317+ 0000 ~                                        ld      hl,255                  ; LDX #255               \ Set x1 = 255
 318+ 0000 ~                                        ld      ( prefix1?_XX1510 ),hl             ; STX XX15 ;INX; STX XX15+1
 319+ 0000 ~            ;--  We have moved the point so the x-coordinate is on  screen (i.e. in the range 0-255), so now for the  y-coordinate
 320+ 0000 ~            prefix1?_LL134_6502:        ld      a,(prefix1?_XX1532+1)            ; LDA XX15+3             \ If y1_hi is positive, jump down to LL119 to skip
 321+ 0000 ~                                        and     a                       ; BPL LL135              \ the following
 322+ 0000 ~                                        jp      p, prefix1?_LL135_6502           ; .
 323+ 0000 ~                                        ld      (Svar),a                ; STA S                  \ Otherwise y1_hi is negative, i.e. off the top of the screen, so set S = y1_hi
 324+ 0000 ~                                        ld      a, ( prefix1?_XX1532)             ; LDA XX15+2             \ Set R = y1_lo
 325+ 0000 ~                                        ld      (Rvar),a                ; STA R
 326+ 0000 ~                                        call    prefix1?_LL123_6502              ; JSR LL123              \ Call LL123 to calculate:  (Y X) = (S R) / XX12+2      if T = 0 = y1 / gradient
 327+ 0000 ~                                                                        ;                        \                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
 328+ 0000 ~                                                                        ;                         with the sign of (Y X) set to the opposite of the line's direction of slope
 329+ 0000 ~                                        call    ADDYXRegtoX1            ; TXA                    \ Set x1 = x1 + (Y X)
 330+ 0000 ~                                        ld      hl,0                    ; LDA #0                 \ Set y1 = 0
 331+ 0000 ~                                        ld      ( prefix1?_XX1532),hl             ; STA XX15+2, XX15+3
 332+ 0000 ~            prefix1?_LL135_6502:         ld      bc,128                  ; LDA XX15+2             \ Set (S R) = (y1_hi y1_lo) - screen height
 333+ 0000 ~                                        call    SUBBCFromY1             ; .                      \ .
 334+ 0000 ~                                        jr      c, prefix1?_LL136_6502           ; BCC LL136              \ If the subtraction underflowed, i.e. if y1 < screen height, then y1 is already on-screen, so jump to LL136
 335+ 0000 ~                                                                ;                        \ to return from the subroutine, as we are done
 336+ 0000 ~            ;;-   If we get here then y1 >= screen height, i.e. off the bottom of the screen
 337+ 0000 ~            prefix1?_LL139_6502:         call    prefix1?_LL123_6502              ; JSR LL123              \ Call LL123 to calculate:   (Y X) = (S R) / XX12+2      if T = 0  = (y1 - screen height) / gradient
 338+ 0000 ~            ;                        \                            (Y X) = (S R) * XX12+2      if T <> 0 = (y1 - screen height) * gradient
 339+ 0000 ~            ;                          with the sign of (Y X) set to the opposite of the line's direction of slope
 340+ 0000 ~                                        call    ADDYXRegtoX1            ; TXA                    \ Set x1 = x1 + (Y X)
 341+ 0000 ~                                        ld      hl, 127                 ; LDA #Y*2-1             \ Set y1 = 2 * #Y - 1. The constant #Y is 96, the y-coordinate of the mid-point of the space view (or in our case 127)
 342+ 0000 ~                                        ld      (prefix1?_XX1532),hl             ; STA XX15+3             \ pixel row of the space view
 343+ 0000 ~            prefix1?_LL136_6502:         ret                             ; RTS                    \ Return from the subroutine
 344+ 0000 ~            ;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 345+ 0000 ~            ;-- LL145 LINE CLIP
 346+ 0000 ~            ;-- OPTISIATIONS - VERTICAL HORZONTAL POINT |DX| = |DY| (and all the veriants for +/-)
 347+ 0000 ~            ;-- This routine clips the line from (x1, y1) to (x2, y2) so it fits on-screen, or returns an error if it can't be clipped to fit. The arguments are 16-bit coordinates, and the clipped line is returned using 8-bit screen coordinates.
 348+ 0000 ~            ;-- This part sets XX13 to reflect which of the two points are on-screen and off-screen.
 349+ 0000 ~            ;-- IN  : XX15(1 0) x1 XX15(3 2) y1 XX15(5 4) x2 XX12(1 0) y2
 350+ 0000 ~            ;-- OUT : (X1, Y1), (X2, Y2) Screen coordinate C flag  Clear if the clipped line fits on-screen, set if itdoesn't
 351+ 0000 ~            ;         XX13 The state of the original coordinates on-screen:* 0   = (x2, y2) on-screen* 95(64)  = (x1, y1) on-screen,  (x2, y2) off-screen* 191(128) = (x1, y1) off-screen, (x2, y2) off-screen
 352+ 0000 ~            ;              So XX13 is non-zero if the end of the line was clipped,meaning the next line sent to BLINE can't join onto the end but has to start a new segment
 353+ 0000 ~            ;         SWAP The swap status of the returned coordinates:* &FF if we swapped the values of (x1, y1) and(x2, y2) as part of the clipping process* 0 if the coordinates are still in the same order
 354+ 0000 ~            ; TODO treat horizonal/vert and single pixel as special cases
 355+ 0000                                  ENDM
 356+ 0000
 357+ 0000              ClippingCodeLL145Macro:     MACRO   prefix1?
 358+ 0000 ~            prefix1?_LL145_6502:        ZeroA                           ; LDA #0                 \ Set SWAP = 0
 359+ 0000 ~                                        ld      (SWAP),a                ; STA SWAP
 360+ 0000 ~                                        ld      a,(prefix1?_XX15X2hi)            ; LDA XX15+5             \ Set A = x2_hi (use b as a substibute for a)
 361+ 0000 ~                                        ld      b,a                     ; .
 362+ 0000 ~            ; Note that as we are interested in the sign of XX113 then this needs to be >= 128 or < 128 or 0, we will use 191 as per bbc for now
 363+ 0000 ~            ; for the screen coord we will use 127 though, we use c as a temporay X register
 364+ 0000 ~            prefix1?_LL147_6502:        ld      a,191                   ; LDX #Y*2-1             \ Set X = #Y * 2 - 1. The constant #Y is 96, the y-coordinate of the mid-point of the space view, so this sets Y2 to 191, the y-coordinate of the bottom pixel row of the space view
 365+ 0000 ~                                        ld      (Xreg),a                ; .
 366+ 0000 ~            ;                    ld      a,127
 367+ 0000 ~            ;                    ld      c,a
 368+ 0000 ~            .CheckX2Y2High:             ld      a,b                     ; ORA XX12+1             \ If one or both of x2_hi and y2_hi are non-zero, jump
 369+ 0000 ~                                        ld      hl,prefix1?_XX15Y2hi    ; .
 370+ 0000 ~                                        or      (hl)                    ; .
 371+ 0000 ~                                        jp      nz,prefix1?_LL107_6502  ; BNE LL107              \ to LL107 to skip the following, leaving X at 191
 372+ 0000 ~            .CheckY2Lo:                 ld      a,127 ;,c               ; get back the temporary x reg from c
 373+ 0000 ~                                        ld      hl,prefix1?_XX15Y2lo    ; CPX XX12               \ If y2_lo > the y-coordinate of the bottom of screen (a is being used as X at this point still)
 374+ 0000 ~                                        cp      (hl)                    ; .
 375+ 0000 ~                                        jp      c,prefix1?_LL107_6502   ; BCC LL107              \ then (x2, y2) is off the bottom of the screen, so skip the following instruction, leaving X at 127
 376+ 0000 ~                                        ZeroA                           ; LDX #0                 \ Set X = 0
 377+ 0000 ~                                        ld      (Xreg),a
 378+ 0000 ~            prefix1?_LL107_6502:        ld      a,(Xreg)                ; STX XX13               \ Set XX13 = X, so we have * XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen* XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lois off the bottom of the screen
 379+ 0000 ~                                        ld      ( prefix1?_XX13),a      ; now c is released as a temporary x reg
 380+ 0000 ~                                        ld      a,(prefix1?_XX15X1hi)   ; LDA XX15+1             \ If one or both of x1_hi and y1_hi are non-zero, jump
 381+ 0000 ~                                        ld      hl,prefix1?_XX15Y1hi    ; ORA XX15+3             \ to LL83
 382+ 0000 ~                                        or      (hl)                    ; .
 383+ 0000 ~                                        jp      nz,prefix1?_LL83_6502            ; BNE LL83
 384+ 0000 ~            ; DEBUG SIMPLIFIED CODE, now we just compare y1 lo > 127
 385+ 0000 ~                                        ld      a,(XX1532)              ; If y1_lo > the y-coordinate of the bottom of screen (If A >= N, then C flag is reset.) ;ld      a,127                   ; LDA #Y*2-1             \ If y1_lo > the y-coordinate of the bottom of screen (If A >= N, then C flag is reset.)
 386+ 0000 ~                                        ld      h,127                   ; then (x1, y1) is off the bottom of the screen, so jump                                 ;ld      hl,XX1532               ; CMP XX15+2             \ then (x1, y1) is off the bottom of the screen, so jump
 387+ 0000 ~                                        cp      h                       ; to LL83                                                                                ;cp      (hl)                    ; .                      \ to LL83
 388+ 0000 ~                                        jp      nc, prefix1?_LL83_6502         ; BCC LL83               \ . (y1 > 127 jump, i.e. 127 <= y1 )
 389+ 0000 ~                                        ld      a,( prefix1?_XX13)                ; LDA XX13               \ If we get here, (x1, y1) is on-screen. If XX13 is non-zero, i.e. (x2, y2) is off-screen, jump
 390+ 0000 ~                                        and     a                       ; BNE LL108              \ to LL108 to halve it before continuing at LL83
 391+ 0000 ~                                        jp      nz,prefix1?_LL108_6502
 392+ 0000 ~            ; If we get here, the high bytes are all zero, which means the x-coordinates are < 256 and therefore fit on screen, and neither coordinate is off the bottom of the screen. That means both coordinates are already on
 393+ 0000 ~            ; screen, so we don't need to do any clipping, all weneed to do is move the low bytes into (X1, Y1) and X2, Y2) and return
 394+ 0000 ~            ; X1 = XX15 (10)  Y1 = XX15+1 X2 = XX15+2 Y2 = XX15+3
 395+ 0000 ~            prefix1?_LL146_6502:        ld      hl,(prefix1?_XX15X1lo)           ;  Save X1 to XX1510
 396+ 0000 ~                                        call    prefix1?_ClampX
 397+ 0000 ~                                        ld      (prefix1?_XX15X1lo),a
 398+ 0000 ~                                        ld      hl,(prefix1?_XX15Y1lo)           ;  hl = y1
 399+ 0000 ~                                        call    prefix1?_ClampY
 400+ 0000 ~                                        ld      (prefix1?_XX1510+1),a            ;  XX1510... = [X1][Y1]
 401+ 0000 ~
 402+ 0000 ~                                        ld      hl,(prefix1?_XX15X2lo)           ;  de = x2
 403+ 0000 ~                                        call    prefix1?_ClampX
 404+ 0000 ~                                        ld      (prefix1?_XX1510+2),a            ;  XX1510... = [X1][Y1][X2]
 405+ 0000 ~
 406+ 0000 ~                                        ld      hl,(prefix1?_XX15Y2lo)           ;  bc = y2
 407+ 0000 ~                                        call    prefix1?_ClampY
 408+ 0000 ~                                        ld      (prefix1?_XX1510+3),a            ;  XX1510... = [X1][Y1][X2][Y2]
 409+ 0000 ~                                        ClearCarryFlag                  ; CLC                    \ Clear the C flag as the clipped line fits on-screen
 410+ 0000 ~                                        ret                             ; RTS                    \ Return from the subroutine
 411+ 0000 ~            prefix1?_LL109_6502:        SetCarryFlag                    ; SEC                    \ Set the C flag to indicate the clipped line does not fit on-screen
 412+ 0000 ~                                        ret                             ; RTS                    \ Return from the subroutine
 413+ 0000 ~            prefix1?_LL108_6502:        ld      hl, prefix1?_XX13                 ; LSR XX13               \ If we get here then (x2, y2) is off-screen and XX13 is
 414+ 0000 ~                                        srl     (hl)                    ;                        \ 191, (128)  so shift XX13 right to halve it to 95 (64)
 415+ 0000 ~            ;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 416+ 0000 ~            ;-- LL145 (Part 2 of 4)
 417+ 0000 ~            prefix1?_LL83_6502:         ld      a,( prefix1?_XX13)               ; LDA XX13               \ If XX13 < 128 then only one of the points is on-screen
 418+ 0000 ~                                        and     a                                ; BPL LL115              \ so jump down to LL115 to skip the checks of whether
 419+ 0000 ~                                        jp      p,prefix1?_LL115_6502            ;                        \ both points are in the strips to the right or bottom of the screen
 420+ 0000 ~            ;-- If we get here, both points are off-screen
 421+ 0000 ~                                        ld      a,(prefix1?_XX15X1hi)            ; LDA XX15+1             \ If both x1_hi and x2_hi have bit 7 set, jump to LL109
 422+ 0000 ~                                        ld      hl,prefix1?_XX15X2hi             ; AND XX15+5             \ to return from the subroutine with the C flag set, as
 423+ 0000 ~                                        and     (hl)
 424+ 0000 ~                                        jp      m, prefix1?_LL109_6502           ; BMI LL109              \ the entire line is above the top of the screen
 425+ 0000 ~                                        ld      a,(prefix1?_XX15Y1hi)            ; LDA XX15+3             \ If both y1_hi and y2_hi have bit 7 set, jump to LL109
 426+ 0000 ~                                        ld      hl,prefix1?_XX15Y2hi             ; AND XX12+1             \ to return from the subroutine with the C flag set, as
 427+ 0000 ~                                        and     (hl)                             ; BMI LL109              \ the entire line is to the left of the screen
 428+ 0000 ~                                        jp      m,prefix1?_LL109_6502            ; .
 429+ 0000 ~                                        ld      a,(prefix1?_XX15X1hi)            ; LDX XX15+1             \ Set A = X = x1_hi - 1
 430+ 0000 ~                                        dec     a                                ; DEX
 431+ 0000 ~                                        ld      (Xreg),a                         ; TXA
 432+ 0000 ~                                        push    af                               ; LDX XX15+5     SP+1    \ Set XX12+2 = x2_hi - 1, we need to save a register first
 433+ 0000 ~                                        ld      a,(prefix1?_XX15X2hi)            ; .
 434+ 0000 ~                                        dec     a                                ; DEX
 435+ 0000 ~                                        ld      (Xreg),a                         ; STX XX12+2
 436+ 0000 ~                                        pop     af                               ; .              SP+0    restore a register
 437+ 0000 ~                                        ld      hl,prefix1?_XX15Y2hi             ; ORA XX12+2             \ If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set,
 438+ 0000 ~                                        or      (hl)                             ; .
 439+ 0000 ~                                        jp      p, prefix1?_LL109_6502           ; BPL LL109              \ jump to LL109 to return from the subroutine with the C flag set, as the line doesn't fit on-screen
 440+ 0000 ~            ; for this bit, while z80 uses carry the opposite way to 6502, 6502 uses borrow, in effect inverting the flip
 441+ 0000 ~            ;NOTEFOUND A PATH WHERE IT DOES NOT DO THIS CHECK e.g. 90 B2 8D A2
 442+ 0000 ~            prefix1?_LL83_DEBUG:          ld      a,(prefix1?_XX1532)              ; LDA XX15+2             \ If y1_lo < y-coordinate of screen bottom, clear the C
 443+ 0000 ~                                        cp      128                     ; CMP #Y*2               \ flag, otherwise set it (NOTE FLIPPED IN z80)
 444+ 0000 ~                                        ld      a,(prefix1?_XX1532+1)            ; LDA XX15+3             \ Set XX12+2 = y1_hi - (1 - C), so:
 445+ 0000 ~                                        sbc     0                       ; SBC #0                 \ .
 446+ 0000 ~                                        ld      (prefix1?_XX12p2),a              ; STA XX12+2             \  * Set XX12+2 = y1_hi - 1 if y1_lo is on-screen * Set XX12+2 = y1_hi  otherwise We do this subtraction because we are only interested
 447+ 0000 ~                                        ld      a,(prefix1?_XX1576)              ; LDA XX12               \ If y2_lo < y-coordinate of screen bottom, clear the C
 448+ 0000 ~                                        cp      128                     ; CMP #Y*2               \ flag, otherwise set it
 449+ 0000 ~                                        ld      a,(prefix1?_XX1576+1)            ; LDA XX12+1             \ Set XX12+2 = y2_hi - (1 - C), so:
 450+ 0000 ~                                        sbc     0                       ; SBC #0                   * Set XX12+1 = y2_hi - 1 if y2_lo is on-screen  * Set XX12+1 = y2_hi     otherwise
 451+ 0000 ~                                        ld      hl,prefix1?_XX12p2               ; ORA XX12+2             \ If neither XX12+1 or XX12+2 have bit 7 set, jump to
 452+ 0000 ~                                        or      (hl)                    ; .
 453+ 0000 ~                                        jp      p,prefix1?_LL109_6502            ; BPL LL109              \ LL109 to return from the subroutine with the C flag set, as the line doesn't fit on-screen
 454+ 0000 ~            ;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 455+ 0000 ~            ;-- LL145 (Part 3 of 4) Summary: Clip line: Calculate the line's gradient
 456+ 0000 ~            prefix1?_LL115_6502:        ld      a,(Yreg)                ; TYA                    \ Store Y on the stack so we can preserve it through the call to this routine
 457+ 0000 ~                                        push    af                      ; PHA            SP+1    \ call to this subroutine
 458+ 0000 ~                                        ld      hl,(prefix1?_XX15X2lo)             ; LDA XX15+4             \ Set XX12+2 = x2_lo - x1_lo
 459+ 0000 ~                                        ld      de,(prefix1?_XX15X1lo)             ; LDA XX15+5             \ Set XX12+3 = x2_hi - x1_hi
 460+ 0000 ~                                        ClearCarryFlag                  ; SBC XX15+1
 461+ 0000 ~                                        sbc     hl,de                   ; .
 462+ 0000 ~                                        ld      (delta_x),hl            ; .
 463+ 0000 ~                                        ld      hl,(prefix1?_XX15Y2lo)             ; LDA XX12               \ Set XX12+4 = y2_lo - y1_lo
 464+ 0000 ~                                        ld      de,(prefix1?_XX15Y1lo)             ;
 465+ 0000 ~                                        ClearCarryFlag                  ; SBC XX15+2
 466+ 0000 ~                                        sbc     hl,de                   ; .
 467+ 0000 ~                                        ld      (delta_y),hl            ; .
 468+ 0000 ~            ; So we now have:  delta_x in XX12(3 2)  delta_y in XX12(5 4) where the delta is (x1, y1) - (x2, y2))
 469+ 0000 ~                                        ld      a,(delta_y+1)           ; EOR XX12+3             \ Set S = the sign of delta_x * the sign of delta_y, so
 470+ 0000 ~                                        ld      hl,delta_x+1
 471+ 0000 ~                                        xor     (hl)
 472+ 0000 ~                                        ld      (Svar),a                ; STA S                  \ if bit 7 of S is set, the deltas have different signs (perhaps we should do bit 7 mask ?????????
 473+ 0000 ~                                        ld      hl,(delta_y)            ; LDA XX12+5             \ If delta_y_hi is positive, jump down to LL110 to skip
 474+ 0000 ~                                        ld      a,h
 475+ 0000 ~                                        and     a
 476+ 0000 ~                                        jp      p, prefix1?_LL110_6502  ; BPL LL110              \ the following
 477+ 0000 ~                                        NegHL                           ; LDA #0                 \ Otherwise flip the sign of delta_y to make it
 478+ 0000 ~                                        ld      (delta_y),hl            ; positive, starting with the low bytes
 479+ 0000 ~            prefix1?_LL110_6502:        ld      hl,(delta_x)            ; LDA XX12+3             \ If delta_x_hi is positive, jump down to LL111 to skip
 480+ 0000 ~                                        ld      a,h                     ; BPL LL111              \ the following
 481+ 0000 ~                                        and     a                       ; .
 482+ 0000 ~                                        jp      p,prefix1?_LL111_6502            ; .
 483+ 0000 ~                                        NegHL                           ; SEC                    \ Otherwise flip the sign of delta_x to make it
 484+ 0000 ~                                        ld      (delta_x),hl            ; LDA #0                 \ positive, starting with the low bytes
 485+ 0000 ~            ;--  We now keep halving |delta_x| and |delta_y| until both of them have zero in their high bytes
 486+ 0000 ~            prefix1?_LL111_6502:        ld      hl,(delta_x)
 487+ 0000 ~                                        ld      de,(delta_y)
 488+ 0000 ~                                        ld      a,h                     ; TAX                    \ If |delta_x_hi| is non-zero, skip the following
 489+ 0000 ~                                        or      d                       ; BNE LL112
 490+ 0000 ~                                        jp      z,prefix1?_LL113_6502            ; LDX XX12+5             \ If |delta_y_hi| = 0, jump down to LL113 (as both |delta_x_hi| and |delta_y_hi| are 0)
 491+ 0000 ~            prefix1?_LL112_6502:        ShiftHLRight1                   ; LSR A                  \ Halve the value of delta_x in (A XX12+2)
 492+ 0000 ~                                        ShiftDERight1                   ; LSR XX12+5             \ Halve the value of delta_y XX12(5 4)
 493+ 0000 ~                                        ld      (delta_x),hl
 494+ 0000 ~                                        ld      (delta_y),de            ; write them back so we don't end up in an infinite loop
 495+ 0000 ~                                        jp       prefix1?_LL111_6502                  ; JMP LL111              \ Loop back to LL111
 496+ 0000 ~            ;-- By now, the high bytes of both |delta_x| and |delta_y| are zero
 497+ 0000 ~            prefix1?_LL113_6502:        ZeroA                           ; STX T                  \ We know that X = 0 as that's what we tested with a BEQ  above, so this sets T = 0
 498+ 0000 ~                                        ld      (Tvar),a
 499+ 0000 ~                                        ld      a,(delta_x)             ; LDA XX12+2             \ If delta_x_lo < delta_y_lo, so our line is more
 500+ 0000 ~                                        ld      hl,delta_y              ; CMP XX12+4             \ vertical than horizontal, jump to LL114
 501+ 0000 ~                                        cp      (hl)
 502+ 0000 ~                                        jp      c, prefix1?_LL114_6502  ; BCC LL114              ; if delta y > delta x then its a steep slope so we do 256*dy/dx
 503+ 0000 ~            ;-- If we get here then our line is more horizontal than vertical, so it is a shallow slope
 504+ 0000 ~                                        ld      a,(delta_x)             ; STA Q                  \ Set Q = delta_x_lo
 505+ 0000 ~                                        ld      (Qvar),a                ; .
 506+ 0000 ~                                        ld      a,(delta_y)             ; LDA XX12+4             \ Set A = delta_y_lo
 507+ 0000 ~                                        call    prefix1?_LL28_6502      ; JSR LL28               \ Call LL28 to calculate: R = 256 * A / Q = 256 * delta_y_lo / delta_x_lo
 508+ 0000 ~                                        jp      prefix1?_LL116_6502     ; JMP LL116              \ Jump to LL116, as we now have the line's gradient in R
 509+ 0000 ~            ;-- If we get here then our line is more vertical than horizontal, so it is a steep slope
 510+ 0000 ~            prefix1?_LL114_6502:        ld      a,(delta_y)             ; LDA XX12+4             \ Set Q = delta_y_lo
 511+ 0000 ~                                        ld      (Qvar),a                ; STA Q
 512+ 0000 ~                                        ld      a,(delta_x)             ; LDA XX12+2             \ Set A = delta_x_lo
 513+ 0000 ~                                        call    prefix1?_LL28_6502               ; JSR LL28               \ Call LL28 to calculate: R = 256 * A / Q = 256 * delta_x_lo / delta_y_lo
 514+ 0000 ~                                        ld      a,$FF                   ; DEC T                  \ T was set to 0 above, so this sets T = &FF when our
 515+ 0000 ~                                        ld      (Tvar),a                ;                        \ line is steep
 516+ 0000 ~            ;----------------------------------------------------------------------------------------------------------------
 517+ 0000 ~            ;--- LL116 This part sets things up to call the routine in LL188, which does the actual clipping.
 518+ 0000 ~            ;--  If we get here, then R has been set to the gradient of the line (x1, y1) to(x2, y2), with T indicating the gradient of slope: * 0   = shallow slope (more horizontal than vertical)
 519+ 0000 ~            ;--                                                                                                                                * &FF = steep slope (more vertical than horizontal)
 520+ 0000 ~            ;-- XX13 has been set as follows: * 0   = (x1, y1) off-screen, (x2, y2) on-screen * 95(64)  = (x1, y1) on-screen,  (x2, y2) off-screen * 191(128) = (x1, y1) off-screen, (x2, y2) off-screen
 521+ 0000 ~            prefix1?_LL116_6502:        ld      a,(Rvar)                ; LDA R                  \ Store the gradient in XX12+2
 522+ 0000 ~                                        ld      (prefix1?_XX12p2),a     ; STA XX12+2
 523+ 0000 ~                                        ld      a,(Svar)                ; LDA S                  \ Store the type of slope in XX12+3, bit 7 clear means
 524+ 0000 ~                                        ld      (prefix1?_XX12p3),a              ; STA XX12+3             \ top left to bottom right, bit 7 set means top right to bottom left
 525+ 0000 ~                                        ld      a,( prefix1?_XX13)                ; LDA XX13               \ If XX13 = 0, skip the following instruction
 526+ 0000 ~                                        cp      0                       ; BEQ LL138
 527+ 0000 ~                                        jp      z,prefix1?_LL138_6502            ; .
 528+ 0000 ~                                        jp      p, prefix1?_LLX117_6502          ; If XX13 is positive, it must be 95 (64) as 128 would be negative). This means (x1, y1) is on-screen but (x2, y2) isn't, so we jump
 529+ 0000 ~            ;-- If we get here, XX13 = 0 or 191, so (x1, y1) is off-screen and needs clipping
 530+ 0000 ~            prefix1?_LL138_6502:          call    prefix1?_LL118_6502              ; JSR LL118              \ Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 531+ 0000 ~                                        ld      a,( prefix1?_XX13)                ; LDA XX13               \ If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to
 532+ 0000 ~                                        and     a
 533+ 0000 ~                                        jp      p,prefix1?_LL124_6502            ; BPL LL124              \ LL124 to return with a successfully clipped line
 534+ 0000 ~            ;-- If we get here, XX13 = 191 (128) (both coordinates areoff-screen)
 535+ 0000 ~            prefix1?_LL117_6502:          ld      a,(prefix1?_XX1510+1)            ; LDA XX15+1             \ If either of x1_hi or y1_hi are non-zero, jump to
 536+ 0000 ~                                        ld      hl,prefix1?_XX1532+1             ; ORA XX15+3             \ LL137 to return from the subroutine with the C flag
 537+ 0000 ~                                        or      (hl)
 538+ 0000 ~                                        jp      nz, prefix1?_LL137_6502          ; BNE LL137              \ set, as the line doesn't fit on-screen
 539+ 0000 ~                                        ld      a,(prefix1?_XX1532)              ; LDA XX15+2             \ If y1_lo > y-coordinate of the bottom of the screen
 540+ 0000 ~                                        cp      128                     ; CMP #Y*2               \ jump to LL137 to return from the subroutine with the
 541+ 0000 ~                                        jp      nc, prefix1?_LL137_6502          ; BCS LL137              \ C flag set, as the line doesn't fit on-screen
 542+ 0000 ~            ;-- If we get here, XX13 = 95 or 191, and in both cases (x2, y2) is off-screen, so we now need to swap the (x1, y1) and (x2, y2) coordinates around before doing the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
 543+ 0000 ~            prefix1?_LLX117_6502:         ld      hl,( prefix1?_XX1510)             ; LDX XX15               \ Swap x1_lo = x2_lo
 544+ 0000 ~                                        ld      de,( prefix1?_XX1554)
 545+ 0000 ~                                        ld      ( prefix1?_XX1510),de
 546+ 0000 ~                                        ld      ( prefix1?_XX1554),hl
 547+ 0000 ~                                        ld      hl,( prefix1?_XX1532)             ; LDX XX15+2             \ Swap y1_lo = y2_lo
 548+ 0000 ~                                        ld      de,( prefix1?_XX1576)
 549+ 0000 ~                                        ld      ( prefix1?_XX1532),de
 550+ 0000 ~                                        ld      ( prefix1?_XX1576),hl
 551+ 0000 ~                                        call    prefix1?_LL118_6502              ; JSR LL118              \ Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 552+ 0000 ~                                        ld      hl,SWAP
 553+ 0000 ~                                        dec     (hl)                    ; DEC SWAP               \ Set SWAP = &FF to indicate that we just clipped the line at the (x2, y2) end by swapping the coordinates (the DEC does this as we set SWAP to 0 at the start of this subroutine)
 554+ 0000 ~            prefix1?_LL124_6502:          pop     af                      ; PLA            SP+0    \ Restore Y from the stack so it gets preserved through
 555+ 0000 ~                                        ld      (Yreg),a                ; TAY                    \ the call to this subroutine
 556+ 0000 ~                                        call    prefix1?_LL146_6502              ; JMP LL146              \ Jump up to LL146 to move the low bytes of (x1, y1) and (x2, y2) into (X1, Y1) and (X2, Y2), and return from the subroutine with a successfully clipped line
 557+ 0000 ~                                        ret                             ; then exit so we don't pop it twice
 558+ 0000 ~            prefix1?_LL137_6502:          pop     af                      ; PLA            SP+0    \ Restore Y from the stack so it gets preserved through
 559+ 0000 ~                                        ld      (Yreg),a                ; TAY                    \ the call to this subroutine
 560+ 0000 ~                                        SetCarryFlag                    ; SEC                    \ Set the C flag to indicate the clipped line does not fit on-screen
 561+ 0000 ~                                        ret                             ; RTS                    \ Return from the subroutine
 562+ 0000 ~
 563+ 0000 ~
 564+ 0000 ~            prefix1?_l2_draw_6502_line:   ld      hl,x1                           ; copy from currnet position to 6502 variables
 565+ 0000 ~                                        ld      de, prefix1?_XX1510
 566+ 0000 ~                                        ld      bc,4*2
 567+ 0000 ~                                        ldir
 568+ 0000 ~                                        call    prefix1?_LL145_6502                      ; perform 6502 version
 569+ 0000 ~                                        ret     c                               ; returns if carry is set as its a no draw
 570+ 0000 ~            .CopyBackResults:           ld      hl,0
 571+ 0000 ~                                        ld      (x1),hl
 572+ 0000 ~                                        ld      (y1),hl
 573+ 0000 ~                                        ld      (x2),hl
 574+ 0000 ~                                        ld      (y2),hl
 575+ 0000 ~                                        ld      a,( prefix1?_XX1510)
 576+ 0000 ~                                        ld      (x1),a
 577+ 0000 ~                                        ld      c,a
 578+ 0000 ~                                        ld      a,( prefix1?_XX1510+1)
 579+ 0000 ~                                        ld      (y1),a
 580+ 0000 ~                                        ld      b,a
 581+ 0000 ~                                        ld      a,( prefix1?_XX1510+2)
 582+ 0000 ~                                        ld      (x2),a
 583+ 0000 ~                                        ld      e,a
 584+ 0000 ~                                        ld      a,( prefix1?_XX1510+3)
 585+ 0000 ~                                        ld      (y2),a
 586+ 0000 ~                                        ld      d,a
 587+ 0000 ~                                        ld      a,$FF
 588+ 0000 ~                                        ClearCarryFlag
 589+ 0000 ~                                        ret
 590+ 0000                      ENDM
# file closed: ../../Universe/UniverseMacros/asm_linedraw.asm
  45  0000                                      INCLUDE "../../Universe/UniverseMacros/UniverseVarsDefineMacro.asm"
# file opened: ../../Universe/UniverseMacros/UniverseVarsDefineMacro.asm
   1+ 0000              ; -- AI Core data
   2+ 0000              UnivCoreAIVarsMacro:        MACRO  prefix1?
   3+ 0000 ~            prefix1?_BnKRotXCounter             DB  0                       ; INWK +29
   4+ 0000 ~            prefix1?_BnKRotZCounter             DB  0                       ; INWK +30
   5+ 0000 ~            prefix1?_BnkCam0yLo                 DB  0                       ; INWK +33 ????
   6+ 0000 ~            prefix1?_BnkCam0yHi                 DB  0                       ; INWK +34?????
   7+ 0000 ~            prefix1?_BnKShipType                DB  0
   8+ 0000 ~
   9+ 0000 ~            ; Used to make 16 bit reads a little cleaner in source code
  10+ 0000 ~            prefix1?_BnKzPoint                  DS  3
  11+ 0000 ~            prefix1?_BnKzPointLo                equ prefix1?_BnKzPoint
  12+ 0000 ~            prefix1?_BnKzPointHi                equ prefix1?_BnKzPoint+1
  13+ 0000 ~            prefix1?_BnKzPointSign              equ prefix1?_BnKzPoint+2
  14+ 0000 ~
  15+ 0000 ~            ; Used for medridan drawing routines
  16+ 0000 ~            prefix1?_BnKCx                      DW  0
  17+ 0000 ~            prefix1?_BnKCxSign                  EQU prefix1?_BnKCx+1
  18+ 0000 ~            prefix1?_BnKCy                      DW  0
  19+ 0000 ~            prefix1?_BnKCySign                  EQU prefix1?_BnKCy+1
  20+ 0000 ~            prefix1?_BnKUx                      DW  0
  21+ 0000 ~            prefix1?_BnKUxSign                  EQU prefix1?_BnKUx+1
  22+ 0000 ~            prefix1?_BnKUy                      DW  0
  23+ 0000 ~            prefix1?_BnKUySign                  EQU prefix1?_BnKUy+1
  24+ 0000 ~            prefix1?_BnKVx                      DW  0
  25+ 0000 ~            prefix1?_BnKVxSign                  EQU prefix1?_BnKVx+1
  26+ 0000 ~            prefix1?_BnKVy                      DW  0
  27+ 0000 ~            prefix1?_BnKVySign                  EQU prefix1?_BnKVy+1
  28+ 0000 ~            prefix1?_BnKSinCNT2                 DB  0
  29+ 0000 ~            prefix1?_BnKSinCNT2Sign             DB  0
  30+ 0000 ~            prefix1?_BnKCosCNT2                 DB  0
  31+ 0000 ~            prefix1?_BnKCosCNT2Sign             DB  0
  32+ 0000 ~            prefix1?_BnKUxCos                   DB  0
  33+ 0000 ~            prefix1?_BnKUxCosSign               DB  0
  34+ 0000 ~            prefix1?_BnKUyCos                   DB  0
  35+ 0000 ~            prefix1?_BnKUyCosSign               DB  0
  36+ 0000 ~            prefix1?_BnKVxSin                   DB  0
  37+ 0000 ~            prefix1?_BnKVxSinSign               DB  0
  38+ 0000 ~            prefix1?_BnKVySin                   DB  0
  39+ 0000 ~            prefix1?_BnKVySinSign               DB  0
  40+ 0000 ~            prefix1?_BnKVxVySinSign             DB  0
  41+ 0000 ~            prefix1?_BnKUxUyCosSign             DB  0
  42+ 0000 ~            prefix1?_BnKUxCosAddVxSin           DW  0
  43+ 0000 ~            prefix1?_BnKUyCosSubVySin           DW  0
  44+ 0000 ~            prefix1?_BnKAngle                   DB  0
  45+ 0000 ~            s
  46+ 0000 ~
  47+ 0000 ~            ; General local variables used in universe object
  48+ 0000 ~            prefix1?_BnKTGT                     DB  0
  49+ 0000 ~            prefix1?_BnKSTP                     DB  0
  50+ 0000 ~            prefix1?_BnKLSP                     DS  50              ; move to planet or L2 code ?
  51+ 0000 ~            prefix1?_BnKCNT                     DB  0               ; 93
  52+ 0000 ~            prefix1?_BnKCNT2                    DB  0               ; 93
  53+ 0000 ~            ; Replaced LSX2 and LSY2 with plot heaps of 64 x 2 bytes each + 1 pair for initial point
  54+ 0000 ~                IFDEF MERIDANLINEDEBUG
  55+ 0000 ~            prefix1?_BnKPlotXHeap               DS  $82			   ; &0EC0	    \ LSX2 bline buffer size?
  56+ 0000 ~            prefix1?_BnKPlotYHeap               DS  $82            ; &0F0E	    \ LSY2
  57+ 0000 ~                ENDIF
  58+ 0000 ~            prefix1?_BnKPlotIndex               DB  0
  59+ 0000 ~                DISPLAY "TODO can we remove this and just use BnkCNT = 0 as the same thing?"
  60+ 0000 ~            prefix1?_BnKFlag					DB  0
  61+ 0000 ~
  62+ 0000 ~            ; Post clipping the results are now 8 bit
  63+ 0000 ~            prefix1?_BnKVisibility              DB  0               ; replaces general purpose xx4 in renderingW
  64+ 0000 ~            prefix1?_BnKProjectedY              DB  0
  65+ 0000 ~            prefix1?_BnKProjectedX              DB  0
  66+ 0000 ~            prefix1?_BnKProjected               equ prefix1?_BnKProjectedY  ; resultant projected position
  67+ 0000 ~            prefix1?_XX15Save                   DS  8
  68+ 0000 ~            prefix1?_XX15Save2                  DS  8
  69+ 0000 ~            prefix1?_Radius                     DB  0
  70+ 0000 ~            ; Used when drawing curves for the end value from previous calls to BLINE
  71+ 0000 ~            ; held as 16 bit values pre clipping
  72+ 0000 ~            prefix1?_PrevXPos                   DW 0
  73+ 0000 ~            prefix1?_PrevYPos                   DW 0
  74+ 0000 ~            prefix1?_NewXPos                    DW 0
  75+ 0000 ~            prefix1?_NewYPos                    DW 0
  76+ 0000 ~
  77+ 0000 ~            ; Colouration
  78+ 0000 ~            ; For planets, Colour 1 is main colour, Colour 2 is outer rim
  79+ 0000 ~            ; if we are going to do outer rim then may have colour thickeness as number of pixels to simulat atmosphere
  80+ 0000 ~            prefix1?_Colour1                    DB 0
  81+ 0000 ~            prefix1?_Colour2                    DB 0
  82+ 0000 ~            prefix1?_Colour2Thickness           DB 0
  83+ 0000 ~
  84+ 0000 ~            ;        -- _pl(prf .. "Radius                     DW  0
  85+ 0000 ~            ;        -- _pl(prf .. "RadiusHigh                 equ prefix1?_Radius+1
  86+ 0000                                           ENDM
  87+ 0000
  88+ 0000              UnivPosVarsMacro:            MACRO  prefix1?
  89+ 0000 ~            prefix1?_BnKxlo                     DB  0                       ; INWK+0
  90+ 0000 ~            prefix1?_BnKxhi                     DB  0                       ; there are hi medium low as some times these are 24 bit
  91+ 0000 ~            prefix1?_BnKxsgn                    DB  0                       ; INWK+2
  92+ 0000 ~            prefix1?_BnKylo                     DB  0                       ; INWK+3 \ ylo
  93+ 0000 ~            prefix1?_BnKyhi                     DB  0                       ; INWK+4 \ yHi
  94+ 0000 ~            prefix1?_BnKysgn                    DB  0                       ; INWK +5
  95+ 0000 ~            prefix1?_BnKzlo                     DB  0                       ; INWK +6
  96+ 0000 ~            prefix1?_BnKzhi                     DB  0                       ; INWK +7
  97+ 0000 ~            prefix1?_BnKzsgn                    DB  0                       ; INWK +8
  98+ 0000 ~            prefix1?_CompassX                   DW  0
  99+ 0000 ~            prefix1?_CompassY                   DW  0
 100+ 0000 ~            prefix1?_BnKElipseCenterX           DW  0
 101+ 0000 ~            prefix1?_BnKElipseCenterY           DW  0
 102+ 0000 ~            prefix1?_BnKElipseRadiusU           DW  0
 103+ 0000 ~            prefix1?_BnKElipseRadiusV           DW  0
 104+ 0000                                          ENDM
 105+ 0000
 106+ 0000              ; Rotation data is stored as lohi, but only 15 bits with 16th bit being  a sign bit. Note this is NOT 2'c compliment
 107+ 0000              ;-Rotation Matrix of Universe Object-----------------------------------------------------------------------------------------------
 108+ 0000              UnivRotationVarsMacro:      MACRO prefix1?
 109+ 0000 ~            prefix1?_BnKrotmatSidevX            DW  0                       ; INWK +21
 110+ 0000 ~            prefix1?_BnKrotmatSidev             equ prefix1?_BnKrotmatSidevX
 111+ 0000 ~            prefix1?_BnKrotmatSidevY            DW  0                       ; INWK +23
 112+ 0000 ~            prefix1?_BnKrotmatSidevZ            DW  0                       ; INWK +25
 113+ 0000 ~            prefix1?_BnKrotmatRoofvX            DW  0                       ; INWK +15
 114+ 0000 ~            prefix1?_BnKrotmatRoofv             equ prefix1?_BnKrotmatRoofvX
 115+ 0000 ~            prefix1?_BnKrotmatRoofvY            DW  0                       ; INWK +17
 116+ 0000 ~            prefix1?_BnKrotmatRoofvZ            DW  0                       ; INWK +19
 117+ 0000 ~            prefix1?_BnKrotmatNosevX            DW  0                       ; INWK +9
 118+ 0000 ~            prefix1?_BnKrotmatNosev             EQU prefix1?_BnKrotmatNosevX
 119+ 0000 ~            prefix1?_BnKrotmatNosevY            DW  0                       ; INWK +11
 120+ 0000 ~            prefix1?_BnKrotmatNosevZ            DW  0                       ; INWK +13
 121+ 0000                                          ENDM
 122+ 0000
 123+ 0000
 124+ 0000              XX15DefineMacro: MACRO   prefix1?
 125+ 0000 ~
 126+ 0000 ~            prefix1?_BnKXScaled                  DB  0               ; XX15+0Xscaled
 127+ 0000 ~            prefix1?_BnKXScaledSign              DB  0               ; XX15+1xsign
 128+ 0000 ~            prefix1?_BnKYScaled                  DB  0               ; XX15+2yscaled
 129+ 0000 ~            prefix1?_BnKYScaledSign              DB  0               ; XX15+3ysign
 130+ 0000 ~            prefix1?_BnKZScaled                  DB  0               ; XX15+4zscaled
 131+ 0000 ~            prefix1?_BnKZScaledSign              DB  0               ; XX15+5zsign
 132+ 0000 ~            prefix1?_XX1576                      DW  0    ; y2
 133+ 0000 ~
 134+ 0000 ~            prefix1?_XX15:                       equ prefix1?_BnKXScaled
 135+ 0000 ~            prefix1?_XX15VecX:                   equ prefix1?_XX15
 136+ 0000 ~            prefix1?_XX15VecY:                   equ prefix1?_XX15+1
 137+ 0000 ~            prefix1?_XX15VecZ:                   equ prefix1?_XX15+2
 138+ 0000 ~            prefix1?_BnKXPoint:                  equ prefix1?_XX15
 139+ 0000 ~            prefix1?_BnKXPointLo:                equ prefix1?_XX15+0
 140+ 0000 ~            prefix1?_BnKXPointHi:                equ prefix1?_XX15+1
 141+ 0000 ~            prefix1?_BnKXPointSign:              equ prefix1?_XX15+2
 142+ 0000 ~            prefix1?_BnKYPoint:                  equ prefix1?_XX15+3
 143+ 0000 ~            prefix1?_BnKYPointLo:                equ prefix1?_XX15+3
 144+ 0000 ~            prefix1?_BnKYPointHi:                equ prefix1?_XX15+4
 145+ 0000 ~            prefix1?_BnKYPointSign:              equ prefix1?_XX15+5
 146+ 0000 ~
 147+ 0000 ~            prefix1?_XX1510                      EQU prefix1?_BnKXScaled    ; x1 as a 16-bit coordinate (x1_hi x1_lo)
 148+ 0000 ~            prefix1?_XX1532                      EQU prefix1?_BnKYScaled   ; y1 as a 16-bit coordinate (y1_hi y1_lo)
 149+ 0000 ~            prefix1?_XX1554                      EQU prefix1?_BnKZScaled   ; x2
 150+ 0000 ~            prefix1?_XX1554p1                    EQU prefix1?_XX1554+1
 151+ 0000 ~            prefix1?_XX15X1lo                    EQU prefix1?_XX1510
 152+ 0000 ~            prefix1?_XX15X1hi                    EQU prefix1?_XX1510+1
 153+ 0000 ~            prefix1?_XX15Y1lo                    EQU prefix1?_XX1532
 154+ 0000 ~            prefix1?_XX15Y1hi                    EQU prefix1?_XX1532+1
 155+ 0000 ~            prefix1?_XX15X2lo                    EQU prefix1?_XX1554
 156+ 0000 ~            prefix1?_XX15X2hi                    EQU prefix1?_XX1554+1
 157+ 0000 ~            prefix1?_XX15Y2lo                    EQU prefix1?_XX1210
 158+ 0000 ~            prefix1?_XX15Y2hi                    EQU prefix1?_XX1210+1
 159+ 0000 ~            prefix1?_XX15PlotX1                  EQU prefix1?_XX15
 160+ 0000 ~            prefix1?_XX15PlotY1                  EQU prefix1?_XX15+1
 161+ 0000 ~            prefix1?_XX15PlotX2                  EQU prefix1?_XX15+2
 162+ 0000 ~            prefix1?_XX15PlotY2                  EQU prefix1?_XX15+3
 163+ 0000                          ENDM
 164+ 0000
 165+ 0000              XX12DefineMacro: MACRO   prefix1?
 166+ 0000 ~            ;-- transmat0 --------------------------------------------------------------------------------------------------------------------------
 167+ 0000 ~            ; Note XX12 comes after as some logic in normal processing uses XX15 and XX12 combines
 168+ 0000 ~
 169+ 0000 ~            prefix1?_XX1210                     EQU prefix1?_XX1576
 170+ 0000 ~            prefix1?_XX12p1                     EQU prefix1?_XX1210+1
 171+ 0000 ~            prefix1?_XX12                       EQU prefix1?_XX1210
 172+ 0000 ~
 173+ 0000 ~
 174+ 0000 ~            prefix1?_BnKXX12xLo                 EQU prefix1?_XX12               ; XX12+0
 175+ 0000 ~            prefix1?_BnKXX12xSign               EQU prefix1?_XX12+1   ; XX12+1
 176+ 0000 ~            prefix1?_BnKXX12yLo                 EQU prefix1?_XX12+2   ; XX12+2
 177+ 0000 ~            prefix1?_BnKXX12ySign               EQU prefix1?_XX12+3   ; XX12+3
 178+ 0000 ~            prefix1?_BnKXX12zLo                 EQU prefix1?_XX12+4   ; XX12+4
 179+ 0000 ~            prefix1?_BnKXX12zSign               EQU prefix1?_XX12+5   ; XX12+5
 180+ 0000 ~            prefix1?_XX12Save                   DS  6
 181+ 0000 ~            prefix1?_XX12Save2                  DS  6
 182+ 0000 ~
 183+ 0000 ~            prefix1?_varXX12                    EQU prefix1?_XX12
 184+ 0000 ~            ; Repurposed XX12 when plotting lines
 185+ 0000 ~            prefix1?_BnkY2                      equ prefix1?_XX12+0
 186+ 0000 ~            prefix1?_BnKy2Lo                    equ prefix1?_XX12+0
 187+ 0000 ~            prefix1?_BnkY2Hi                    equ prefix1?_XX12+1
 188+ 0000 ~            prefix1?_BnkDeltaXLo                equ prefix1?_XX12+2
 189+ 0000 ~            prefix1?_BnkDeltaXHi                equ prefix1?_XX12+3
 190+ 0000 ~            prefix1?_BnkDeltaYLo                equ prefix1?_XX12+4
 191+ 0000 ~            prefix1?_BnkDeltaYHi                equ prefix1?_XX12+5
 192+ 0000 ~            prefix1?_BnkGradient                equ prefix1?_XX12+2
 193+ 0000 ~            prefix1?_BnkTemp1                   equ prefix1?_XX12+2
 194+ 0000 ~            prefix1?_BnkTemp1Lo                 equ prefix1?_XX12+2
 195+ 0000 ~            prefix1?_BnkTemp1Hi                 equ prefix1?_XX12+3
 196+ 0000 ~            prefix1?_BnkTemp2                   equ prefix1?_XX12+3
 197+ 0000 ~            prefix1?_BnkTemp2Lo                 equ prefix1?_XX12+3
 198+ 0000 ~            prefix1?_BnkTemp2Hi                 equ prefix1?_XX12+4
 199+ 0000                                          ENDM
 200+ 0000
 201+ 0000              XX16DefineMacro: MACRO   prefix1?
 202+ 0000 ~            ;-- XX16 --------------------------------------------------------------------------------------------------------------------------
 203+ 0000 ~            prefix1?_BnkTransmatSidevX          DW  0               ; XX16+0
 204+ 0000 ~            prefix1?_BnkTransmatSidev           EQU prefix1?_BnkTransmatSidevX
 205+ 0000 ~            prefix1?_BnkTransmatSidevY          DW 0                ; XX16+2
 206+ 0000 ~            prefix1?_BnkTransmatSidevZ          DW 0                ; XX16+2
 207+ 0000 ~            prefix1?_BnkTransmatRoofvX          DW 0
 208+ 0000 ~            prefix1?_BnkTransmatRoofv           EQU prefix1?_BnkTransmatRoofvX
 209+ 0000 ~            prefix1?_BnkTransmatRoofvY          DW 0                ; XX16+2
 210+ 0000 ~            prefix1?_BnkTransmatRoofvZ          DW 0                ; XX16+2
 211+ 0000 ~            prefix1?_BnkTransmatNosevX          DW 0
 212+ 0000 ~            prefix1?_BnkTransmatNosev           EQU prefix1?_BnkTransmatNosevX
 213+ 0000 ~            prefix1?_BnkTransmatNosevY          DW 0                ; XX16+2
 214+ 0000 ~            prefix1?_BnkTransmatNosevZ          DW 0                ; XX16+2
 215+ 0000 ~            prefix1?_BnkTransmatTransX          DW 0
 216+ 0000 ~            prefix1?_BnkTransmatTransY          DW 0
 217+ 0000 ~            prefix1?_BnkTransmatTransZ          DW 0
 218+ 0000 ~            prefix1?_XX16                       equ prefix1?_BnkTransmatSidev
 219+ 0000 ~            ;-- XX16Inv --------------------------------------------------------------------------------------------------------------------------
 220+ 0000 ~            prefix1?_BnkTransInvRow0x0          DW 0
 221+ 0000 ~            prefix1?_BnkTransInvRow0x1          DW 0
 222+ 0000 ~            prefix1?_BnkTransInvRow0x2          DW 0
 223+ 0000 ~            prefix1?_BnkTransInvRow0x3          DW 0
 224+ 0000 ~            prefix1?_BnkTransInvRow1y0          DW 0
 225+ 0000 ~            prefix1?_BnkTransInvRow1y1          DW 0
 226+ 0000 ~            prefix1?_BnkTransInvRow1y2          DW 0
 227+ 0000 ~            prefix1?_BnkTransInvRow1y3          DW 0
 228+ 0000 ~            prefix1?_BnkTransInvRow2z0          DW 0
 229+ 0000 ~            prefix1?_BnkTransInvRow2z1          DW 0
 230+ 0000 ~            prefix1?_BnkTransInvRow2z2          DW 0
 231+ 0000 ~            prefix1?_BnkTransInvRow2z3          DW 0
 232+ 0000 ~
 233+ 0000 ~            prefix1?_XX16Inv                    equ prefix1?_BnkTransInvRow0x0
 234+ 0000                                          ENDM
 235+ 0000
 236+ 0000              XX18DefineMacro: MACRO   prefix1?
 237+ 0000 ~            ;-- XX18 --------------------------------------------------------------------------------------------------------------------------
 238+ 0000 ~            prefix1?_BnkDrawCam0xLo             DB  0               ; XX18+0
 239+ 0000 ~            prefix1?_BnkDrawCam0xHi             DB  0               ; XX18+1
 240+ 0000 ~            prefix1?_BnkDrawCam0xSgn            DB  0               ; XX18+2
 241+ 0000 ~            prefix1?_BnkDrawCam0x               equ prefix1?_BnkDrawCam0xLo
 242+ 0000 ~            prefix1?_BnkDrawCam0yLo             DB  0               ; XX18+3
 243+ 0000 ~            prefix1?_BnkDrawCam0yHi             DB  0               ; XX18+4
 244+ 0000 ~            prefix1?_BnkDrawCam0ySgn            DB  0               ; XX18+5
 245+ 0000 ~            prefix1?_BnkDrawCam0y               equ prefix1?_BnkDrawCam0yLo
 246+ 0000 ~            prefix1?_BnkDrawCam0zLo             DB  0               ; XX18+6
 247+ 0000 ~            prefix1?_BnkDrawCam0zHi             DB  0               ; XX18+7
 248+ 0000 ~            prefix1?_BnkDrawCam0zSgn            DB  0               ; XX18+8
 249+ 0000 ~            prefix1?_BnkDrawCam0z               equ prefix1?_BnkDrawCam0zLo
 250+ 0000 ~            prefix1?_XX18                       equ prefix1?_BnkDrawCam0xLo
 251+ 0000                                          ENDM
 252+ 0000
 253+ 0000              XX25DefineMacro: MACRO   prefix1?
 254+ 0000 ~            ;-- XX25 --------------------------------------------------------------------------------------------------------------------------
 255+ 0000 ~            prefix1?_BnKProjxLo                 DB  0
 256+ 0000 ~            prefix1?_BnKProjxHi                 DB  0
 257+ 0000 ~            prefix1?_BnKProjxSgn                DB  0
 258+ 0000 ~            prefix1?_BnKProjx                   EQU prefix1?_BnKProjxLo
 259+ 0000 ~            prefix1?_BnKProjyLo                 DB  0
 260+ 0000 ~            prefix1?_BnKProjyHi                 DB  0
 261+ 0000 ~            prefix1?_BnKProjySgn                DB  0
 262+ 0000 ~            prefix1?_BnKProjy                   EQU prefix1?_BnKProjyLo
 263+ 0000 ~            prefix1?_BnKProjzLo                 DB  0
 264+ 0000 ~            prefix1?_BnKProjzHi                 DB  0
 265+ 0000 ~            prefix1?_BnKProjzSgn                DB  0
 266+ 0000 ~            prefix1?_BnKProjz                   EQU prefix1?_BnKProjzLo
 267+ 0000 ~            prefix1?_XX25                       EQU prefix1?_BnKProjxLo
 268+ 0000                                          ENDM
 269+ 0000
 270+ 0000              CopyPosToXX15Macro: MACRO   prefix1?
 271+ 0000 ~
 272+ 0000 ~            prefix1?_CopyPosToXX15:    ld hl,prefix1?_Bnkxhi
 273+ 0000 ~                                       ld de,prefix1?_BnkXScaled
 274+ 0000 ~                                       ldi
 275+ 0000 ~                                       ldi
 276+ 0000 ~                                       inc hl ; skip to y high
 277+ 0000 ~                                       ldi
 278+ 0000 ~                                       ldi
 279+ 0000 ~                                       inc hl ; skip to z hig
 280+ 0000 ~                                       ldi
 281+ 0000 ~                                       ldi
 282+ 0000 ~                                       ret
 283+ 0000                                  ENDM
 284+ 0000
 285+ 0000              CopyXX12ScaledToXX18Macro:  MACRO    prefix1?
 286+ 0000 ~            prefix1?_CopyXX12ScaledToXX18:
 287+ 0000 ~            prefix1?_CopyResultToDrawCam:    ld      hl, prefix1?_XX12
 288+ 0000 ~                                             ld      de, prefix1?_XX18
 289+ 0000 ~                                             ldi    ; X12+0 => XX18+0  Set XX18(2 0) = dot_sidev
 290+ 0000 ~                                             inc de ; skip to XX18+2 as it will be on XX18+1
 291+ 0000 ~                                             ldi    ; XX12+1 => XX18+2
 292+ 0000 ~                                             ldi    ; XX12+2 => XX18+3 Set XX12+1 => XX18+2
 293+ 0000 ~                                             inc de ; skip to XX18+5 as it will be on XX18+4
 294+ 0000 ~                                             ldi    ; XX12+3 => XX18+5
 295+ 0000 ~                                             ldi    ; XX12+4 => XX18+6 Set XX18(8 6) = dot_nosev
 296+ 0000 ~                                             inc de ; skip to XX18+8 as it will be on XX18+7
 297+ 0000 ~                                             ldi    ; XX12+5 => XX18+8
 298+ 0000 ~                                             ret
 299+ 0000                                          ENDM
 300+ 0000
 301+ 0000              CopyXX12toXX15Macro:        MACRO    prefix1?
 302+ 0000 ~            prefix1?_CopyXX12toXX15:         ld      hl, prefix1?_BnkXX12xLo
 303+ 0000 ~                                             ld      de, prefix1?_XX18
 304+ 0000 ~                                             ldi      ; xlo
 305+ 0000 ~                                             ldi      ; xsg
 306+ 0000 ~                                             ldi      ; xlo
 307+ 0000 ~                                             ldi      ; xsg
 308+ 0000 ~                                             ldi      ; xlo
 309+ 0000 ~                                             ldi      ; xsg
 310+ 0000 ~                                             ret
 311+ 0000                                          ENDM
 312+ 0000
 313+ 0000              InitialiseUniverseObjMacro: MACRO   prefix1?
 314+ 0000 ~            prefix1?_InitRotMat:    ld      hl, 0
 315+ 0000 ~                                    ld      (prefix1?_BnKrotmatSidevY),hl       ; set the zeroes
 316+ 0000 ~                                    ld      (prefix1?_BnKrotmatSidevZ),hl       ; set the zeroes
 317+ 0000 ~                                    ld      (prefix1?_BnKrotmatRoofvX),hl       ; set the zeroes
 318+ 0000 ~                                    ld      (prefix1?_BnKrotmatRoofvZ),hl       ; set the zeroes
 319+ 0000 ~                                    ld      (prefix1?_BnKrotmatNosevX),hl       ; set the zeroes
 320+ 0000 ~                                    ld      (prefix1?_BnKrotmatNosevY),hl       ; set the zeroes
 321+ 0000 ~            ; Optimised as already have 0 in l
 322+ 0000 ~                                    ld      h, $60	             				; 96 in hi byte
 323+ 0000 ~                                    ;ld      hl,1
 324+ 0000 ~                                    ld      (prefix1?_BnKrotmatSidevX),hl
 325+ 0000 ~                                    ld      (prefix1?_BnKrotmatRoofvY),hl
 326+ 0000 ~            ; Optimised as already have 0 in l
 327+ 0000 ~                                    ld      h, $E0					            ; -96 in hi byte which is +96 with hl bit 7 set
 328+ 0000 ~                                    ld      (prefix1?_BnKrotmatNosevZ),hl
 329+ 0000 ~                                    ret
 330+ 0000                                          ENDM
 331+ 0000
# file closed: ../../Universe/UniverseMacros/UniverseVarsDefineMacro.asm
  46  0000                                      INCLUDE "../../Variables/general_variables_macros.asm"
# file opened: ../../Variables/general_variables_macros.asm
   1+ 0000              ; limited to 255 character length
   2+ 0000              CountLengthHL:          MACRO   Limiter
   3+ 0000 ~                                    ld      de,hl
   4+ 0000 ~                                    ld      bc,Limiter
   5+ 0000 ~                                    xor     a
   6+ 0000 ~                                    cpir
   7+ 0000 ~                                    ClearCarryFlag
   8+ 0000 ~                                    sbc     hl,de
   9+ 0000 ~                                    ld      a,l
  10+ 0000 ~                                    ret
  11+ 0000                                      ENDM
  12+ 0000
  13+ 0000              IncMemMaxN:             MACRO   mem, maxvalue
  14+ 0000 ~                                    ld      a,(mem)
  15+ 0000 ~                                    cp      maxvalue
  16+ 0000 ~                                    jr      c,.IncMaxed
  17+ 0000 ~                                    inc     a
  18+ 0000 ~                                    ld      (mem),a
  19+ 0000 ~            .IncMaxed:
  20+ 0000                                      ENDM
  21+ 0000
  22+ 0000              IncMemMaxNCycle:        MACRO   mem, cyclevalue
  23+ 0000 ~                                    ld      a,(mem)
  24+ 0000 ~                                    inc     a
  25+ 0000 ~                                    cp      cyclevalue
  26+ 0000 ~                                    jr      c,.IncMaxed
  27+ 0000 ~                                    xor     a
  28+ 0000 ~            .IncMaxed:              ld      (mem),a
  29+ 0000                                      ENDM
  30+ 0000
  31+ 0000
  32+ 0000              HalfLengthHL:           MACRO
  33+ 0000 ~                                    ld      b,0
  34+ 0000 ~            .CountLenLoop:          ld      a,(hl)
  35+ 0000 ~                                    cp      0
  36+ 0000 ~                                    jr      z,.DoneCount
  37+ 0000 ~                                    inc     b
  38+ 0000 ~                                    inc     hl
  39+ 0000 ~                                    jr      .CountLenLoop
  40+ 0000 ~            .DoneCount:             ld      a,32
  41+ 0000 ~                                    sub     b
  42+ 0000 ~                                    sra     a
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              MakeInnocentMacro:		MACRO
  46+ 0000 ~            						xor		a
  47+ 0000 ~            						ld		(FugitiveInnocentStatus),a
  48+ 0000              						ENDM
  49+ 0000
  50+ 0000              NoEscapePodMacro:		MACRO
  51+ 0000 ~            						xor		a
  52+ 0000 ~            						ld		(EscapePod),a
  53+ 0000              						ENDM
  54+ 0000
  55+ 0000              MaxFuelLevel            EQU     70              ; 7.0 light years max
  56+ 0000              MaxFuelMacro:			MACRO
  57+ 0000 ~            						ld		a,MaxFuelLevel
  58+ 0000 ~            						ld		(Fuel),a
  59+ 0000              						ENDM
  60+ 0000
  61+ 0000              MaxThrottle:            MACRO
  62+ 0000 ~                                    ld      a,(SHIPMAXSPEED)
  63+ 0000 ~                                    ld      (DELTA),a
  64+ 0000 ~                                    ld      d,a
  65+ 0000 ~                                    ld      e,4
  66+ 0000 ~                                    mul
  67+ 0000 ~                                    ld      (DELT4Lo),de
  68+ 0000                                      ENDM
  69+ 0000
  70+ 0000              ZeroThrottle:           MACRO
  71+ 0000 ~                                    xor     a
  72+ 0000 ~                                    ld      (DELTA),a
  73+ 0000 ~                                    ld      (DELT4Lo),a
  74+ 0000 ~                                    ld      (DELT4Lo+1),a
  75+ 0000                                      ENDM
  76+ 0000
  77+ 0000              ZeroPitch:              MACRO
  78+ 0000 ~                                    xor     a
  79+ 0000 ~                                    ld      (BET2),a
  80+ 0000 ~                                    ld      (BET2FLIP),a
  81+ 0000 ~                                    ld      (JSTY),a
  82+ 0000 ~                                    ld      (BETA),a
  83+ 0000                                      ENDM
  84+ 0000
  85+ 0000              ZeroRoll:               MACRO
  86+ 0000 ~                                    xor     a                              ; zero roll and climb
  87+ 0000 ~                                    ld      (ALP2),a
  88+ 0000 ~                                    ld      (ALP2FLIP),a
  89+ 0000 ~                                    ld      (JSTX),a
  90+ 0000 ~                                    ld      (ALPHA),a
  91+ 0000                                      ENDM
  92+ 0000
  93+ 0000              CorrectPostJumpFuel:    MACRO
  94+ 0000 ~                                    ld      a,(Fuel)
  95+ 0000 ~                                    ld      hl,Distance
  96+ 0000 ~                                    sub     a,(hl)
  97+ 0000 ~                                    ld      (Fuel),a
  98+ 0000                                      ENDM
  99+ 0000
 100+ 0000              AnyMissilesLeft:        MACRO
 101+ 0000 ~                                    ld      a,(NbrMissiles)
 102+ 0000 ~                                    and     a
 103+ 0000                                      ENDM
 104+ 0000
 105+ 0000              SetMissileTargetA:      MACRO
 106+ 0000 ~                                    ld      (MissileTargettingFlag),a   ; Set to slot number clearing bit 7
 107+ 0000                                      ENDM
 108+ 0000
 109+ 0000              IsMissileLaunchFlagged: MACRO
 110+ 0000 ~                                    ld      a,(MissileTargettingFlag)
 111+ 0000 ~                                    and     $80
 112+ 0000                                      ENDM
 113+ 0000
 114+ 0000              SetMissileTargetting:   MACRO
 115+ 0000 ~                                    ld      a,StageMissileTargeting
 116+ 0000 ~                                    ld      (MissileTargettingFlag),a
 117+ 0000                                      ENDM
 118+ 0000
 119+ 0000              ClearMissileTargetting: MACRO
 120+ 0000 ~                                    ld      a,StageMissileNotTargeting
 121+ 0000 ~                                    ld      (MissileTargettingFlag),a
 122+ 0000                                      ENDM
 123+ 0000
 124+ 0000
 125+ 0000              ; Clear targetting bits which signals launch if lower nibble has selected target
 126+ 0000              SetMissileLaunch:       MACRO
 127+ 0000 ~                                    ld      a,(MissileTargettingFlag)
 128+ 0000 ~                                    and     $0F
 129+ 0000 ~                                    ld      (MissileTargettingFlag),a
 130+ 0000                                      ENDM
 131+ 0000
 132+ 0000              LockMissileToA:         MACRO
 133+ 0000 ~                                    or      $80
 134+ 0000 ~                                    ld      (MissileTargettingFlag),a
 135+ 0000                                      ENDM
 136+ 0000
 137+ 0000              ClearECM:               MACRO
 138+ 0000 ~                                    xor     a
 139+ 0000 ~                                    ld      (ECMCountDown),a
 140+ 0000                                      ENDM
 141+ 0000
 142+ 0000
 143+ 0000              ; Will check to see if bit 2 is set, if it is clear, then friendly hence z is set
 144+ 0000              ;                                    if it is set    then hostile hence z is not set
 145+ 0000              IsShipHostile:          MACRO
 146+ 0000 ~                                    ld      a,(ShipNewBitsAddr)
 147+ 0000 ~                                    and     ShipIsHostile
 148+ 0000                                      ENDM
 149+ 0000              ; Will check to see if docking is set, if docking     z flag is clear
 150+ 0000              ;                                      if not docking z flag is set
 151+ 0000              IsShipDocking:          MACRO
 152+ 0000 ~                                    ld      a,(ShipNewBitsAddr)
 153+ 0000 ~                                    and     ShipIsDocking
 154+ 0000                                      ENDM
 155+ 0000
 156+ 0000              ; Will check to see if bit 2 is set, if it is clear, then friendly hence z is set
 157+ 0000              ;                                    if hit is set then hostile hence z is not set
 158+ 0000              IsShipFriendly:         MACRO
 159+ 0000 ~                                    ld      a,(ShipNewBitsAddr)
 160+ 0000 ~                                    and     ShipNotHostile                  ; mask so we only have hostile bit
 161+ 0000                                      ENDM
 162+ 0000
 163+ 0000              ; Will check to see if bit 5 is set, if clear, then not exploding z clear
 164+ 0000              ;                                    if set    then exploding     z set
 165+ 0000              IsShipExploding:        MACRO
 166+ 0000 ~                                    ld      a,(UBnkaiatkecm)
 167+ 0000 ~                                    and     ShipExploding
 168+ 0000                                      ENDM
 169+ 0000
 170+ 0000              ; Checks if ship is a trader, if ship is a trader then z flag is clear
 171+ 0000              ;                             if ship isn't a trader then z flag is set
 172+ 0000              IsShipTrader:           MACRO
 173+ 0000 ~                                    ld      a,(ShipNewBitsAddr)
 174+ 0000 ~                                    and     ShipIsTrader
 175+ 0000                                      ENDM
 176+ 0000              ; Will check if the AI bit is set, if set then z is clear, if clear then z is set
 177+ 0000              IsAIEnabled:            MACRO
 178+ 0000 ~                                    ld      hl, UBnkaiatkecm
 179+ 0000 ~                                    bit 	ShipAIEnabledBitNbr,(hl)
 180+ 0000                                      ENDM
 181+ 0000
 182+ 0000              UpdateLaserOnCounter:   MACRO
 183+ 0000 ~                                    ld      a,(CurrLaserPulseOnCount)
 184+ 0000 ~                                    and     a
 185+ 0000 ~                                    jr      z,.LaserOnIsDone
 186+ 0000 ~                                    dec     a
 187+ 0000 ~                                    ld      (CurrLaserPulseOnCount),a
 188+ 0000 ~                                    jr      z,.LaserOnIsDone
 189+ 0000 ~                                    ldCopyByte CurrLaserPulseOffTime, CurrLaserPulseOffCount
 190+ 0000 ~            .LaserOnIsDone:
 191+ 0000                                      ENDM
 192+ 0000
 193+ 0000              UpdateLaserOffCounter:  MACRO
 194+ 0000 ~                                    ld      a,(CurrLaserPulseOffTime)
 195+ 0000 ~                                    and     a
 196+ 0000 ~                                    jr      z,.LaserOffIsDone
 197+ 0000 ~                                    dec     a
 198+ 0000 ~                                    ld      (CurrLaserPulseOffTime),a
 199+ 0000 ~                                    jr      z,.LaserOffIsDone
 200+ 0000 ~                                    ldCopyByte CurrLaserPulseRest, CurrLaserPulseRestCount
 201+ 0000 ~            .LaserOffIsDone:
 202+ 0000                                      ENDM
 203+ 0000
 204+ 0000              UpdateLaserRestCounter: MACRO
 205+ 0000 ~                                    ld      a,(CurrLaserPulseRestCount)
 206+ 0000 ~                                    and     a
 207+ 0000 ~                                    jr      z,.LaserRestIsDone
 208+ 0000 ~                                    dec     a
 209+ 0000 ~                                    ld      (CurrLaserPulseRestCount),a
 210+ 0000 ~                                    jr      z,.LaserRestIsDone
 211+ 0000 ~                                    ZeroA                                                                           ;    then pulse rate count = 0
 212+ 0000 ~                                    ld      (CurrLaserPulseRateCount),a                                             ;    .
 213+ 0000 ~            .LaserRestIsDone
 214+ 0000                                      ENDM
 215+ 0000
 216+ 0000              ChargeEnergyAndShields: MACRO
 217+ 0000 ~                                    ld      a,$FF
 218+ 0000 ~                                    ld      (PlayerEnergy),a
 219+ 0000 ~                                    ld      (ForeShield),a
 220+ 0000 ~                                    ld      (AftShield),a
 221+ 0000                                      ENDM
 222+ 0000
 223+ 0000              CopyPresentSystemToTarget: MACRO
 224+ 0000 ~                                    ld      hl,(PresentSystemX)
 225+ 0000 ~                                    ld      (TargetSystemX),hl
 226+ 0000                                      ENDM
 227+ 0000
 228+ 0000              CopyTargetSystemToPresent: MACRO
 229+ 0000 ~                                    ld      hl,(TargetSystemX)
 230+ 0000 ~                                    ld      (PresentSystemX),hl
 231+ 0000                                      ENDM
 232+ 0000
 233+ 0000              HalveFugitiveStatus:    MACRO
 234+ 0000 ~                                    ld      hl,FugitiveInnocentStatus
 235+ 0000 ~                                    srl     (hl)
 236+ 0000                                      ENDM
 237+ 0000
 238+ 0000              ClearForceTransition    MACRO
 239+ 0000 ~                                    ld      a,$FF
 240+ 0000 ~                                    ld      (ScreenTransitionForced),a
 241+ 0000                                      ENDM
 242+ 0000
 243+ 0000              ForceTransition:        MACRO newScreen
 244+ 0000 ~                                    ld      a,newScreen
 245+ 0000 ~                                    ld      (ScreenTransitionForced), a
 246+ 0000                                      ENDM
 247+ 0000
 248+ 0000              IsSpaceStationPresent:  MACRO
 249+ 0000 ~                                    ld      a,(SpaceStationSafeZone)
 250+ 0000 ~                                    and     a
 251+ 0000                                      ENDM
 252+ 0000
 253+ 0000              SetSafeZone:            MACRO
 254+ 0000 ~                                    xor     a
 255+ 0000 ~                                    ld      (SpaceStationSafeZone),a
 256+ 0000                                      ENDM
 257+ 0000
 258+ 0000              ClearSafeZone:          MACRO
 259+ 0000 ~                                    ld      a,$FF
 260+ 0000 ~                                    ld      (SpaceStationSafeZone),a
 261+ 0000                                      ENDM
 262+ 0000
 263+ 0000              ClearTemperatures:      MACRO
 264+ 0000 ~                                    xor     a
 265+ 0000 ~                                    ld      (CabinTemperature),a
 266+ 0000 ~                                    ld      (GunTemperature),a
 267+ 0000                                      ENDM
 268+ 0000
 269+ 0000              ClearWarpPressed:       MACRO
 270+ 0000 ~                                    SetMemFalse WarpPressed
 271+ 0000                                      ENDM
 272+ 0000
 273+ 0000              CoolCabin:              MACRO
 274+ 0000 ~                                    ld      a,(CabinTemperature)
 275+ 0000 ~                                    and     a
 276+ 0000 ~                                    jr      z,.AlreadyCool
 277+ 0000 ~                                    dec     a
 278+ 0000 ~                                    ld      (CabinTemperature),a
 279+ 0000 ~            .AlreadyCool:
 280+ 0000                                      ENDM
 281+ 0000
 282+ 0000              CoolLasers:             MACRO
 283+ 0000 ~                                    ld      a,(GunTemperature)
 284+ 0000 ~                                    and     a
 285+ 0000 ~                                    jr      z,.AlreadyCool
 286+ 0000 ~                                    dec     a
 287+ 0000 ~                                    ld      (GunTemperature),a
 288+ 0000 ~            .AlreadyCool:
 289+ 0000                                      ENDM
 290+ 0000
 291+ 0000              ; type 255 is "not fitted"
 292+ 0000
 293+ 0000
 294+ 0000              InitEventCounter:       MACRO
 295+ 0000 ~                                    xor     a
 296+ 0000 ~                                    ld      (EventCounter),a
 297+ 0000                                      ENDM
 298+ 0000
 299+ 0000              ClearMissJump:          MACRO
 300+ 0000 ~                                    ld      a,$FF
 301+ 0000 ~                                    ld      (MissJumpFlag),a
 302+ 0000                                      ENDM
 303+ 0000
 304+ 0000
 305+ 0000              DrainSystem:            MACRO   SystemMem, DrainMem
 306+ 0000 ~                                    ld      a,(DrainMem)
 307+ 0000 ~                                    ld      b,a
 308+ 0000 ~                                    ld      a,(SystemMem)
 309+ 0000 ~                                    sub     a,b
 310+ 0000 ~                                    ld      (SystemMem),a
 311+ 0000 ~                                    jr      c,.ZeroSystem
 312+ 0000 ~                                    jp      .ExitPoint
 313+ 0000 ~            .ZeroSystem:            ZeroA
 314+ 0000 ~                                    ld      (SystemMem),a
 315+ 0000 ~            .ExitPoint
 316+ 0000                                      ENDM
 317+ 0000
 318+ 0000              BoostSystem:            MACRO   SystemMem, BoostMem
 319+ 0000 ~                                    ld      a,(BoostMem)
 320+ 0000 ~                                    ld      b,a
 321+ 0000 ~                                    ld      a,(SystemMem)
 322+ 0000 ~                                    add     b
 323+ 0000 ~                                    ld      (SystemMem),a
 324+ 0000 ~                                    jr      c, .MaxSystem
 325+ 0000 ~                                    jp      .ExitPoint
 326+ 0000 ~            .MaxSystem:             ld      a,255
 327+ 0000 ~                                    ld      (SystemMem),a
 328+ 0000 ~            .ExitPoint
 329+ 0000                                      ENDM
 330+ 0000
 331+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER HasEngineSoundChanged:  MACRO
 332+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ld      a,(EngineSoundChanged)
 333+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         and     a
 334+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ENDM
 335+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER
 336+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER ClearEngineSoundChanged:MACRO
 337+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         xor      a
 338+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ld      (EngineSoundChanged),a
 339+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ENDM
 340+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER
 341+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER SetEngineSoundChanged:  MACRO
 342+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ld      a,$FF
 343+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ld      (EngineSoundChanged),a
 344+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ENDM
 345+ 0000
# file closed: ../../Variables/general_variables_macros.asm
  47  0000                                      INCLUDE "../../Variables/UniverseSlot_macros.asm"
# file opened: ../../Variables/UniverseSlot_macros.asm
   1+ 0000
   2+ 0000              AddJunkCount:           MACRO
   3+ 0000 ~                                    ld      hl,JunkCount
   4+ 0000 ~                                    inc     (hl)
   5+ 0000                                      ENDM
   6+ 0000
   7+ 0000              SubJunkCount:           MACRO
   8+ 0000 ~                                    ld      hl,JunkCount
   9+ 0000 ~                                    dec     (hl)
  10+ 0000                                      ENDM
  11+ 0000
  12+ 0000              ClearJunkCount:         MACRO
  13+ 0000 ~                                    ZeroA
  14+ 0000 ~                                    ld      (JunkCount),a
  15+ 0000                                      ENDM
  16+ 0000
  17+ 0000              AddCop:                 MACRO
  18+ 0000 ~                                    ld      hl,CopCount
  19+ 0000 ~                                    inc     (hl)
  20+ 0000                                      ENDM
  21+ 0000
  22+ 0000              SubCop:                 MACRO
  23+ 0000 ~                                    ld      hl,CopCount
  24+ 0000 ~                                    dec     (hl)
  25+ 0000                                      ENDM
  26+ 0000
  27+ 0000              AddPirateCount:         MACRO
  28+ 0000 ~                                    ld      hl,PirateCount
  29+ 0000 ~                                    inc     (hl)
  30+ 0000                                      ENDM
  31+ 0000
  32+ 0000              SubPirateCount:         MACRO
  33+ 0000 ~                                    ld      hl,PirateCount
  34+ 0000 ~                                    inc     (hl)
  35+ 0000                                      ENDM
  36+ 0000
  37+ 0000              AreCopsPresent:         MACRO
  38+ 0000 ~                                    ld      a,(CopCount)
  39+ 0000 ~                                    and     a
  40+ 0000                                      ENDM
  41+ 0000
  42+ 0000              ; Class == shiptype
  43+ 0000              SetSlotAToUnivClass:    MACRO
  44+ 0000 ~                                    ex      af,af'
  45+ 0000 ~                                    ld      a,(ShipTypeAddr)
  46+ 0000 ~                                    ld      b,a
  47+ 0000 ~                                    ex      af,af'
  48+ 0000 ~                                    call    SetSlotAToClassB
  49+ 0000                                      ENDM
  50+ 0000
  51+ 0000              TestRoomForJunk:        MACRO   Target
  52+ 0000 ~                                    ld      a,3
  53+ 0000 ~                                    JumpIfMemTrue  SpaceStationSafeZone, .DoTest
  54+ 0000 ~                                    add     a,2
  55+ 0000 ~            .DoTest                 JumpIfALTMemusng    JunkCount, Target
  56+ 0000                                      ENDM
  57+ 0000
  58+ 0000              JumpIfSpaceStation:     MACRO   Target
  59+ 0000 ~                                    ld      hl,UniverseSlotType
  60+ 0000 ~                                    ld      a,(hl)
  61+ 0000 ~                                    cp      ShipTypeStation
  62+ 0000                                      ENDM
  63+ 0000
  64+ 0000              ClearSlotMem:           MACRO   mem
  65+ 0000 ~                                    ld      a,(mem)
  66+ 0000 ~                                    call    ClearSlotA
  67+ 0000                                      ENDM
  68+ 0000
  69+ 0000              IsSlotEmpty:            MACRO
  70+ 0000 ~                                    ld      hl,UniverseSlotList
  71+ 0000 ~                                    add     hl,a
  72+ 0000 ~                                    ld      a,(hl)
  73+ 0000 ~                                    cp      0
  74+ 0000                                      ENDM
  75+ 0000
  76+ 0000              IsSlotMissile:          MACRO
  77+ 0000 ~                                    ld      hl,UniverseSlotType
  78+ 0000 ~                                    add     hl,a
  79+ 0000 ~                                    ld      a,(hl)
  80+ 0000 ~                                    cp      ShipTypeMissile
  81+ 0000                                      ENDM
  82+ 0000
  83+ 0000
  84+ 0000              ; Checks if slot is empty else A = ship type
  85+ 0000              ReturnIfSlotAEmpty:     MACRO
  86+ 0000 ~                                    ld      hl,UniverseSlotList
  87+ 0000 ~                                    add     hl,a
  88+ 0000 ~                                    ld      a,(hl)
  89+ 0000 ~                                    inc     a
  90+ 0000 ~                                    ret     z           ; if slot was ff inc would make it 0
  91+ 0000 ~                                    dec     a           ; get original value back for later
  92+ 0000                                      ENDM
  93+ 0000
  94+ 0000              JumpIfSlotAEmpty:       MACRO   Target
  95+ 0000 ~                                    ld      hl,UniverseSlotList
  96+ 0000 ~                                    add     hl,a
  97+ 0000 ~                                    ld      a,(hl)
  98+ 0000 ~                                    inc     a
  99+ 0000 ~                                    jp      z,Target    ; if slot was ff inc would make it 0
 100+ 0000 ~                                    dec     a           ; get original value back for later
 101+ 0000                                      ENDM
 102+ 0000
 103+ 0000              JumpIfSlotHLEmpty:      MACRO   Target
 104+ 0000 ~                                    ld      a,(hl)
 105+ 0000 ~                                    and     a
 106+ 0000 ~                                    jr      nz,Target
 107+ 0000                                      ENDM
# file closed: ../../Variables/UniverseSlot_macros.asm
  48  0000                                      INCLUDE "../../Data/ShipIdEquates.asm"
# file opened: ../../Data/ShipIdEquates.asm
   1+ 0000
   2+ 0000
   3+ 0000
   4+ 0000              ShipID_Adder            EQU 00
   5+ 0000              ShipID_Anaconda         EQU 01
   6+ 0000              ShipID_Asp_Mk_2         EQU 02
   7+ 0000              ShipID_Boa              EQU 03
   8+ 0000              ShipID_CargoType5       EQU 04
   9+ 0000              ShipID_Boulder          EQU 05
  10+ 0000              ShipID_Asteroid         EQU 06
  11+ 0000              ShipID_Bushmaster       EQU 07
  12+ 0000              ShipID_Chameleon        EQU 08
  13+ 0000              ShipID_CobraMk3         EQU 09
  14+ 0000              ShipID_Cobra_Mk_1       EQU 10
  15+ 0000              ShipID_Cobra_Mk_3_P     EQU 11
  16+ 0000              ShipID_Constrictor      EQU 12
  17+ 0000              ShipID_Coriolis         EQU 13
  18+ 0000              ShipID_Cougar           EQU 14
  19+ 0000              ShipID_Dodo             EQU 15
  20+ 0000              ShipID_Dragon           EQU 16
  21+ 0000              ShipID_Escape_Pod       EQU 17
  22+ 0000              ShipID_Fer_De_Lance     EQU 18
  23+ 0000              ShipID_Gecko            EQU 19
  24+ 0000              ShipID_Ghavial          EQU 20
  25+ 0000              ShipID_Iguana           EQU 21
  26+ 0000              ShipID_Krait            EQU 22
  27+ 0000              ShipID_Logo             EQU 23
  28+ 0000              ShipID_Mamba            EQU 24
  29+ 0000              ShipID_Missile          EQU 25
  30+ 0000              ShipID_Monitor          EQU 26
  31+ 0000              ShipID_Moray            EQU 27
  32+ 0000              ShipID_Ophidian         EQU 28
  33+ 0000              ShipID_Plate            EQU 29
  34+ 0000              ShipID_Python           EQU 30
  35+ 0000              ShipID_Python_P         EQU 31
  36+ 0000              ShipID_Rock_Hermit      EQU 32
  37+ 0000              ShipID_ShuttleType9     EQU 33
  38+ 0000              ShipID_Shuttle_Mk_2     EQU 34
  39+ 0000              ShipID_Sidewinder       EQU 35
  40+ 0000              ShipID_Splinter         EQU 36
  41+ 0000              ShipID_TestVector       EQU 37
  42+ 0000              ShipID_Thargoid         EQU 38
  43+ 0000              ShipID_Thargon          EQU 39
  44+ 0000              ShipID_TransportType10  EQU 40
  45+ 0000              ShipID_Viper            EQU 41
  46+ 0000              ShipID_Worm             EQU 42
  47+ 0000              ShipID_Rattler          EQU 43
  48+ 0000
# file closed: ../../Data/ShipIdEquates.asm
  49  0000
  50  0000              MessageAt:              MACRO   x,y,message
  51  0000 ~                                    MMUSelectLayer1
  52  0000 ~                                    ld      d,y
  53  0000 ~                                    ld      e,x
  54  0000 ~                                    ld      hl,message
  55  0000 ~                                    call    l1_print_at_wrap
  56  0000                                      ENDM
  57  0000
  58  0000              SetBorder:              MACRO   value
  59  0000 ~                                    MMUSelectLayer1
  60  0000 ~                                    ld          a,value
  61  0000 ~                                    call        l1_set_border
  62  0000                                      ENDM
  63  0000
  64  0000              charactersetaddr		equ 15360
  65  0000              STEPDEBUG               equ 1
  66  0000
  67  0000              TopOfStack              equ $5CCB ;$6100
  68  0000
  69  0000                                      ORG $5DCB;      $6200
  70  5DCB F3           EliteNextStartup:       di
  71  5DCC ED 91 07 03  .InitialiseClockSpeed:  nextreg     TURBO_MODE_REGISTER,Speed_28MHZ
  72  5DD0              .InitialiseLayerOrder:
  73  5DD0                                      DISPLAY "Starting Assembly At ", EliteNextStartup
  74  5DD0                                      ; "STARTUP"
  75  5DD0                                      ; Make sure  rom is in page 0 during load
  76  5DD0                                      MMUSelectLayer2
  76  5DD0 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
  77  5DD4 CD 11 E0                             call        asm_disable_l2_readwrite
  78  5DD7                                      MMUSelectROMS
  78  5DD7 ED 91 50 FF >                     nextreg EXSDOSMMU0,        BankROM
  78  5DDB ED 91 51 FF >                     nextreg EXSDOSMMU1,        BankROM
  79  5DDF                                      MMUSelectLayer1
  79  5DDF ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
  80  5DE3 CD 8F E0                             call		l1_cls
  81  5DE6 3E 07                                ld			a,7
  82  5DE8 CD AA E0                             call		l1_attr_cls_to_a
  83  5DEB                                      SetBorder   $FF
  83  5DEB             >                        MMUSelectLayer1
  83  5DEB ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
  83  5DEF 3E FF       >                        ld          a,$FF
  83  5DF1 CD B4 E0    >                        call        l1_set_border
  84  5DF4              .InitialiseL2:          MMUSelectLayer2
  84  5DF4 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
  85  5DF8 CD 85 E3                             call 		l2_initialise
  86  5DFB CD 06 E0                             call        asm_l2_double_buffer_on
  87  5DFE CD 3A E3                             call        l2_cls
  88  5E01 CD DC E3                             call        l2_flip_buffers
  89  5E04 CD 3A E3                             call        l2_cls
  90  5E07              .InitialisingMessage:   MMUSelectUniverseN  0
  90  5E07 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
  91  5E0B CD 2C 6A     InitialiseMainLoop:     call        ClearUnivSlotList
  92  5E0E CD 90 63                             call        SelectShip
  93  5E11                                      MMUSelectKeyboard
  93  5E11 ED 91 57 65 >                     nextreg KeyboardMMU,       BankKeyboard
  94  5E15 CD F7 E0                             call        init_keyboard
  95  5E18                                      ZeroA
  95  5E18 AF          >                        xor a
  96  5E19 32 1C 66                             ld          (JSTX),a
  97  5E1C 32 12 66                             ld          (JSTY),a
  98  5E1F C3 8C 5F                             jp          TestOrientRandP
  99  5E22              TestNormalise:          MMUSelectMathsBankedFns
  99  5E22 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 100  5E26 DD 21 55 5E                          ld          ix,TestVec1
 101  5E2A CD 06 74                             call        NormaliseIXVector
 102  5E2D DD 21 65 5E                          ld          ix,TestVec2
 103  5E31 CD 06 74                             call        NormaliseIXVector
 104  5E34 DD 21 75 5E                          ld          ix,TestVec3
 105  5E38 CD 06 74                             call        NormaliseIXVector
 106  5E3B DD 21 85 5E                          ld          ix,TestVec4
 107  5E3F CD 06 74                             call        NormaliseIXVector
 108  5E42 DD 21 95 5E                          ld          ix,TestVec5
 109  5E46 CD 06 74                             call        NormaliseIXVector
 110  5E49 DD 21 A5 5E                          ld          ix,TestVec6
 111  5E4D CD 06 74                             call        NormaliseIXVector
 112  5E50 DD 01        .SpinKeyboard:          break
 113  5E52 C3 B5 5E                             jp          TestTidy
 114  5E55 00 60 00 00  TestVec1:               DW  $6000, $0000, $0000, $0, $0, $0, $0, $0
 114  5E59 00 00 00 00
 114  5E5D 00 00 00 00
 114  5E61 00 00 00 00
 115  5E65 00 30 00 20  TestVec2:               DW  $3000, $2000, $0000, $0, $0, $0, $0, $0
 115  5E69 00 00 00 00
 115  5E6D 00 00 00 00
 115  5E71 00 00 00 00
 116  5E75 00 00 00 00  TestVec3:               DW  $0000, $0000, $E000, $0, $0, $0, $0, $0
 116  5E79 00 E0 00 00
 116  5E7D 00 00 00 00
 116  5E81 00 00 00 00
 117  5E85 00 60 00 60  TestVec4:               DW  $6000, $6000, $0000, $0, $0, $0, $0, $0
 117  5E89 00 00 00 00
 117  5E8D 00 00 00 00
 117  5E91 00 00 00 00
 118  5E95 00 00 00 00  TestVec5:               DW  $0000, $0000, $1000, $0, $0, $0, $0, $0
 118  5E99 00 10 00 00
 118  5E9D 00 00 00 00
 118  5EA1 00 00 00 00
 119  5EA5 50 34 50 24  TestVec6:               DW  $3450, $2450, $3E00, $0, $0, $0, $0, $0
 119  5EA9 00 3E 00 00
 119  5EAD 00 00 00 00
 119  5EB1 00 00 00 00
 120  5EB5              TestTidy:               MMUSelectMathsBankedFns
 120  5EB5 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 121  5EB9                                      MMUSelectUniverseN 0
 121  5EB9 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 122  5EBD 21 20 5F                             ld          hl,TestMatrix1
 122  5EC0 11 2A C0       ld de, UBnkrotmatSidevX
 122  5EC3 01 12 00       ld bc, 2 * 9
 122  5EC6 ED B0          ldir
 123  5EC8 CD DC 77                             call        TidyVectorsIX
 124  5ECB DD 01                                break
 125  5ECD 21 32 5F                             ld          hl,TestMatrix2
 125  5ED0 11 2A C0       ld de, UBnkrotmatSidevX
 125  5ED3 01 12 00       ld bc, 2 * 9
 125  5ED6 ED B0          ldir
 126  5ED8 CD DC 77                             call        TidyVectorsIX
 127  5EDB DD 01                                break
 128  5EDD 21 44 5F                             ld          hl,TestMatrix3
 128  5EE0 11 2A C0       ld de, UBnkrotmatSidevX
 128  5EE3 01 12 00       ld bc, 2 * 9
 128  5EE6 ED B0          ldir
 129  5EE8 CD DC 77                             call        TidyVectorsIX
 130  5EEB DD 01                                break
 131  5EED 21 56 5F                             ld          hl,TestMatrix4
 131  5EF0 11 2A C0       ld de, UBnkrotmatSidevX
 131  5EF3 01 12 00       ld bc, 2 * 9
 131  5EF6 ED B0          ldir
 132  5EF8 CD DC 77                             call        TidyVectorsIX
 133  5EFB DD 01                                break
 134  5EFD 21 68 5F                             ld          hl,TestMatrix5
 134  5F00 11 2A C0       ld de, UBnkrotmatSidevX
 134  5F03 01 12 00       ld bc, 2 * 9
 134  5F06 ED B0          ldir
 135  5F08 CD DC 77                             call        TidyVectorsIX
 136  5F0B DD 01                                break
 137  5F0D 21 7A 5F                             ld          hl,TestMatrix6
 137  5F10 11 2A C0       ld de, UBnkrotmatSidevX
 137  5F13 01 12 00       ld bc, 2 * 9
 137  5F16 ED B0          ldir
 138  5F18 CD DC 77                             call        TidyVectorsIX
 139  5F1B DD 01                                break
 140  5F1D C3 E3 5F                             jp          MainLoop
 141  5F20                                      ;   SIDEV                ROOFV                NOSEV
 142  5F20 00 00 00 00  TestMatrix1:            DW  $0000, $0000, $E000, $0000, $6000, $0000, $6000, $0000, $0000
 142  5F24 00 E0 00 00
 142  5F28 00 60 00 00
 142  5F2C 00 60 00 00
 142  5F30 00 00
 143  5F32 00 00 00 00  TestMatrix2:            DW  $0000, $0000, $E000, $0000, $5EEC, $0000, $6000, $0000, $0000
 143  5F36 00 E0 00 00
 143  5F3A EC 5E 00 00
 143  5F3E 00 60 00 00
 143  5F42 00 00
 144  5F44 00 00 00 00  TestMatrix3:            DW  $0000, $0000, $E000, $0000, $5EEC, $0000, $3000, $3000, $3000
 144  5F48 00 E0 00 00
 144  5F4C EC 5E 00 00
 144  5F50 00 30 00 30
 144  5F54 00 30
 145  5F56 00 00 00 00  TestMatrix4:            DW  $0000, $0000, $E000, $0000, $6000, $0000, $5000, $0000, $0000
 145  5F5A 00 E0 00 00
 145  5F5E 00 60 00 00
 145  5F62 00 50 00 00
 145  5F66 00 00
 146  5F68 00 00 00 00  TestMatrix5:            DW  $0000, $0000, $E000, $0000, $5500, $0000, $6000, $0000, $0000
 146  5F6C 00 E0 00 00
 146  5F70 00 55 00 00
 146  5F74 00 60 00 00
 146  5F78 00 00
 147  5F7A 00 00 00 00  TestMatrix6:            DW  $0000, $0000, $E100, $0000, $6000, $0000, $6000, $0000, $0000
 147  5F7E 00 E1 00 00
 147  5F82 00 60 00 00
 147  5F86 00 60 00 00
 147  5F8A 00 00
 148  5F8C 3E 60        TestOrientRandP:        ld      a,$60
 149  5F8E 32 1E 66                             ld      (ALPHA),a
 150  5F91 32 11 66                             ld      (BETA),a
 151  5F94 DD 21 B8 5F                          ld      ix,TestVector1
 152  5F98 06 06                                ld      b,6
 153  5F9A DD E5 C5     .TestLoop:              push    ix,,bc
 154  5F9D DD 01                                break
 155  5F9F                                      MMUSelectMathsBankedFns
 155  5F9F ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 156  5FA3 CD BA 02                             call    ApplyRollAndPitchToIX
 157  5FA6 C1 DD E1                             pop     ix,,bc
 158  5FA9 DD E5 E1                             ld      hl,ix
 159  5FAC 3E 06                                ld      a,6
 160  5FAE ED 31                                add     hl,a
 161  5FB0 E5 DD E1                             ld      ix,hl
 162  5FB3 10 E5                                djnz    .TestLoop
 163  5FB5 C3 DC 5F                             jp      InitMainLoop
 164  5FB8              ; y Vector = y - alpha * x_hi
 165  5FB8              ; x Vector = x + alpha * y_hi
 166  5FB8              ; y Vector = y - beta * z_hi
 167  5FB8              ; z Vector = z + beta * y_hi
 168  5FB8 00 00 00 00  TestVector1:            DW  $0000, $0000, $E000
 168  5FBC 00 E0
 169  5FBE 00 00 00 00  TestVector2:            DW  $0000, $0000, $0000
 169  5FC2 00 00
 170  5FC4 00 60 00 00  TestVector3:            DW  $6000, $0000, $0000
 170  5FC8 00 00
 171  5FCA 00 00 00 E0  TestVector4:            DW  $0000, $E000, $0000
 171  5FCE 00 00
 172  5FD0 00 00 EC 5E  TestVector5:            DW  $0000, $5EEC, $0000
 172  5FD4 00 00
 173  5FD6 00 60 00 00  TestVector6:            DW  $6000, $0000, $0000
 173  5FDA 00 00
 174  5FDC
 175  5FDC              ;...................................................................................................................................
 176  5FDC              InitMainLoop:           ZeroA
 176  5FDC AF          >                        xor a
 177  5FDD 32 1E 66                             ld      (ALPHA),a
 178  5FE0 32 11 66                             ld      (BETA),a
 179  5FE3              MainLoop:	            MMUSelectMathsBankedFns                                         ; make sure we are in maths routines in case a save paged out
 179  5FE3 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 180  5FE7 CD 08 6B                             call    doRandom                                                ; redo the seeds every frame
 181  5FEA              ;.. Check if keyboard scanning is allowed by screen. If this is set then skip all keyboard and AI..................................
 182  5FEA              InputBlockerCheck:      MMUSelectKeyboard
 182  5FEA ED 91 57 65 >                     nextreg KeyboardMMU,       BankKeyboard
 183  5FEE CD 03 E1                             call    scan_keyboard
 184  5FF1              ;-- Key Definitions
 185  5FF1              ; Player Pitcn and Roll
 186  5FF1              ;   Q/A pitch       O/P roll        W/A Thrust
 187  5FF1 3E 0A                                ld      a,VK_Q
 188  5FF3 CD 88 E1                             call    is_vkey_held
 189  5FF6 C4 37 61                             call    nz, PressedPitchPlus
 190  5FF9
 191  5FF9 3E 05                                ld      a,VK_A
 192  5FFB CD 88 E1                             call    is_vkey_held
 193  5FFE C4 44 61                             call    nz, PressedPitchMinus
 194  6001
 195  6001 3E 1A                                ld      a,VK_O
 196  6003 CD 88 E1                             call    is_vkey_held
 197  6006 C4 51 61                             call    nz, PressedRollPlus
 198  6009
 199  6009 3E 19                                ld      a,VK_P
 200  600B CD 88 E1                             call    is_vkey_held
 201  600E C4 5E 61                             call    nz, PressedRollMinus
 202  6011
 203  6011              ;   N   Cycle through ships
 204  6011 3E 26                                ld      a,VK_N
 205  6013 CD 91 E1                             call    is_vkey_pressed
 206  6016 CC 90 63                             call    z, SelectShip
 207  6019              ; Tidy and Normalise Vector
 208  6019 3E 04                                ld      a,VK_V
 209  601B CD 91 E1                             call    is_vkey_pressed
 210  601E CC DC 77                             call    z, TidyVectorsIX
 211  6021              ; Ship Pitch and Roll T/G ship pitch, F/H ship roll   U/J Ship Thrust
 212  6021                                      MMUSelectKeyboard
 212  6021 ED 91 57 65 >                     nextreg KeyboardMMU,       BankKeyboard
 213  6025 3E 0E                                ld      a,VK_T
 214  6027 CD 88 E1                             call    is_vkey_held
 215  602A C4 0F 61                             call    nz, PressedSPitchPlus
 216  602D
 217  602D 3E 09                                ld      a,VK_G
 218  602F CD 88 E1                             call    is_vkey_held
 219  6032 C4 19 61                             call    nz, PressedSPitchMinus
 220  6035
 221  6035 3E 08                                ld      a,VK_F
 222  6037 CD 88 E1                             call    is_vkey_held
 223  603A C4 23 61                             call    nz, PressedSRollPlus
 224  603D
 225  603D 3E 22                                ld      a,VK_H
 226  603F CD 88 E1                             call    is_vkey_held
 227  6042 C4 2D 61                             call    nz, PressedSRollMinus
 228  6045
 229  6045              ; PanKeys 1 + y  2 -y  3 +x 4 -x 5 +z 6 -z
 230  6045 3E 13                                ld      a,VK_5
 231  6047 CD 88 E1                             call    is_vkey_held
 232  604A C4 97 60                             call    nz, PressedZPlus
 233  604D
 234  604D 3E 18                                ld      a,VK_6
 235  604F CD 88 E1                             call    is_vkey_held
 236  6052 C4 AB 60                             call    nz, PressedZMinus
 237  6055
 238  6055 3E 11                                ld      a,VK_3
 239  6057 CD 88 E1                             call    is_vkey_held
 240  605A C4 BF 60                             call    nz, PressedXPlus
 241  605D
 242  605D 3E 12                                ld      a,VK_4
 243  605F CD 88 E1                             call    is_vkey_held
 244  6062 C4 D3 60                             call    nz, PressedXMinus
 245  6065
 246  6065 3E 0F                                ld      a,VK_1
 247  6067 CD 88 E1                             call    is_vkey_held
 248  606A C4 E7 60                             call    nz, PressedYPlus
 249  606D
 250  606D 3E 10                                ld      a,VK_2
 251  606F CD 88 E1                             call    is_vkey_held
 252  6072 C4 FB 60                             call    nz, PressedYMinus
 253  6075              ;.. Update values based on movekey keys, may likley need damping as this coudl be very fast
 254  6075 CD BC 61     UpdateShipsControl:     call    UpdateUniverseObjects
 255  6078              .JustViewPortCLS:       MMUSelectLayer2
 255  6078 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 256  607C CD 3A E3                             call    l2_cls
 257  607F
 258  607F              ;.. Render Ship ...................................................................................................................
 259  607F              DrawForwardsShips:
 260  607F AF           DrawShip:               xor     a
 261  6080 32 BB 61     .DrawShipLoop:          ld      (CurrentShipUniv),a
 262  6083 CD D1 6A                             call    GetTypeAtSlotA
 263  6086              .SelectShipToDraw:      MMUSelectUniverseN 0
 263  6086 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 264  608A CD 62 D9     .ProcessUnivShip:       call    ProcessShip          ; The whole explosion logic is now encapsulated in process ship ;TODO TUNE THIS   ;; call    ProcessUnivShip
 265  608D              ;.. Flip Buffer ...................................................................................................................
 266  608D              DoubleBufferCheck:      MMUSelectLayer2
 266  608D ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 267  6091 CD DC E3                             call    l2_flip_buffers
 268  6094 C3 E3 5F                             jp MainLoop
 269  6097              ;.. Keyboard Routines .............................................................................................................
 270  6097              PressedZPlus:           MMUSelectUniverseN 0
 270  6097 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 271  609B DD 21 26 C0                          ld      ix,UBnKzlo
 272  609F FD 21 24 63                          ld      iy,Plus20
 273  60A3                                      MMUSelectMathsBankedFns
 273  60A3 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 273  60A7 CD 90 00       call    AddAtIXtoAtIY24Signed
 274  60AA C9                                   ret
 275  60AB
 276  60AB              PressedZMinus:          MMUSelectUniverseN 0
 276  60AB ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 277  60AF DD 21 26 C0                          ld      ix,UBnKzlo
 278  60B3 FD 21 27 63                          ld      iy,Minus20
 279  60B7                                      MMUSelectMathsBankedFns
 279  60B7 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 279  60BB CD 90 00       call    AddAtIXtoAtIY24Signed
 280  60BE C9                                   ret
 281  60BF
 282  60BF              PressedXPlus:           MMUSelectUniverseN 0
 282  60BF ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 283  60C3 DD 21 20 C0                          ld      ix,UBnKxlo
 284  60C7 FD 21 24 63                          ld      iy,Plus20
 285  60CB                                      MMUSelectMathsBankedFns
 285  60CB ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 285  60CF CD 90 00       call    AddAtIXtoAtIY24Signed
 286  60D2 C9                                   ret
 287  60D3
 288  60D3              PressedXMinus:          MMUSelectUniverseN 0
 288  60D3 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 289  60D7 DD 21 20 C0                          ld      ix,UBnKxlo
 290  60DB FD 21 27 63                          ld      iy,Minus20
 291  60DF                                      MMUSelectMathsBankedFns
 291  60DF ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 291  60E3 CD 90 00       call    AddAtIXtoAtIY24Signed
 292  60E6 C9                                   ret
 293  60E7
 294  60E7              PressedYPlus:           MMUSelectUniverseN 0
 294  60E7 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 295  60EB DD 21 23 C0                          ld      ix,UBnKylo
 296  60EF FD 21 24 63                          ld      iy,Plus20
 297  60F3                                      MMUSelectMathsBankedFns
 297  60F3 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 297  60F7 CD 90 00       call    AddAtIXtoAtIY24Signed
 298  60FA C9                                   ret
 299  60FB
 300  60FB              PressedYMinus:          MMUSelectUniverseN 0
 300  60FB ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 301  60FF DD 21 23 C0                          ld      ix,UBnKylo
 302  6103 FD 21 27 63                          ld      iy,Minus20
 303  6107                                      MMUSelectMathsBankedFns
 303  6107 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 303  610B CD 90 00       call    AddAtIXtoAtIY24Signed
 304  610E C9                                   ret
 305  610F
 306  610F              PressedSPitchPlus:      MMUSelectUniverseN 0
 306  610F ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 307  6113 3E 0A                                ld      a,10
 308  6115 32 89 C0                             ld      (UBnKRotZCounter),a
 309  6118 C9                                   ret
 310  6119
 311  6119              PressedSPitchMinus:     MMUSelectUniverseN 0
 311  6119 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 312  611D 3E 8A                                ld      a,$80+10
 313  611F 32 89 C0                             ld      (UBnKRotZCounter),a
 314  6122 C9                                   ret
 315  6123
 316  6123              PressedSRollPlus:       MMUSelectUniverseN 0
 316  6123 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 317  6127 3E 0A                                ld      a,10
 318  6129 32 88 C0                             ld      (UBnKRotXCounter),a
 319  612C C9                                   ret
 320  612D
 321  612D              PressedSRollMinus:      MMUSelectUniverseN 0
 321  612D ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 322  6131 3E 8A                                ld      a,$80+10
 323  6133 32 88 C0                             ld      (UBnKRotXCounter),a
 324  6136 C9                                   ret
 325  6137
 326  6137              PressedPitchPlus:       MMUSelectUniverseN 0
 326  6137 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 327  613B 3E 14                                ld      a,20
 328  613D 32 12 66                             ld      (JSTY),a
 329  6140 CD 93 61                             call    draw_front_calc_beta
 330  6143 C9                                   ret
 331  6144
 332  6144              PressedPitchMinus:      MMUSelectUniverseN 0
 332  6144 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 333  6148 3E EC                                ld      a,-20
 334  614A 32 12 66                             ld      (JSTY),a
 335  614D CD 93 61                             call    draw_front_calc_beta
 336  6150 C9                                   ret
 337  6151
 338  6151              PressedRollPlus:        MMUSelectUniverseN 0
 338  6151 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 339  6155 3E 3C                                ld      a,60
 340  6157 32 1C 66                             ld      (JSTX),a
 341  615A CD 6B 61                             call    draw_front_calc_alpha
 342  615D C9                                   ret
 343  615E
 344  615E              PressedRollMinus:       MMUSelectUniverseN 0
 344  615E ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 345  6162 3E C4                                ld      a,-60
 346  6164 32 1C 66                             ld      (JSTX),a
 347  6167 CD 6B 61                             call    draw_front_calc_alpha
 348  616A C9                                   ret
 349  616B
 350  616B 47           draw_front_calc_alpha:  ld      b,a
 351  616C E6 80                                and     $80
 352  616E 32 20 66                             ld      (ALP2),a                            ; set sign
 353  6171 4F                                   ld      c,a                                 ; save sign
 354  6172 EE 80                                xor     $80
 355  6174 32 21 66                             ld      (ALP2FLIP),a                        ; and oppsite sign
 356  6177 3A 1C 66                             ld      a,(JSTX)
 357  617A ED 27 80                             test    $80
 358  617D 28 02                                jr      z,  .PositiveRoll
 359  617F ED 44        .NegativeRoll:          neg
 360  6181 CB 3F        .PositiveRoll           srl     a                                   ; divide sign by 4
 361  6183 CB 3F                                srl     a
 362  6185 FE 08                                cp      8
 363  6187 38 02                                jr      c,.NotIncreasedDamp                 ; if a < 8 divide by 2 again
 364  6189 CB 3F        .IncreasedDamp          srl     a
 365  618B 32 1F 66     .NotIncreasedDamp:      ld      (ALP1),a
 366  618E B1                                   or      c
 367  618F 32 1E 66                             ld      (ALPHA),a                           ; a = signed bit alph1
 368  6192 C9                                   ret
 369  6193
 370  6193              ; Do the same for pitch
 371  6193 47           draw_front_calc_beta:   ld      b,a
 372  6194 E6 80                                and     $80
 373  6196 32 14 66                             ld      (BET2),a                            ; set sign
 374  6199 4F                                   ld      c,a                                 ; save sign
 375  619A EE 80                                xor     $80
 376  619C 32 15 66                             ld      (BET2FLIP),a                        ; and oppsite sign
 377  619F 3A 12 66                             ld      a,(JSTY)
 378  61A2 ED 27 80                             test    $80
 379  61A5 28 02                                jr      z,  .PositivePitch
 380  61A7 ED 44        .NegativePitch:         neg
 381  61A9 CB 3F        .PositivePitch:         srl     a                                   ; divide sign by 4
 382  61AB CB 3F                                srl     a
 383  61AD FE 08                                cp      8
 384  61AF 38 02                                jr      c,.NotIncreasedDamp                 ; if a < 8 divide by 2 again
 385  61B1 CB 3F        .IncreasedDamp          srl     a
 386  61B3 32 13 66     .NotIncreasedDamp:      ld      (BET1),a
 387  61B6 B1                                   or      c
 388  61B7 32 11 66                             ld      (BETA),a                            ; a = signed bit bet1
 389  61BA C9                                   ret
 390  61BB
 391  61BB              ;..Update Universe Objects.........................................................................................................
 392  61BB              ;..................................................................................................................................
 393  61BB              ;                           DEFINE ROTATIONDEBUG 1
 394  61BB              ;                           DEFINE CLIPDEBUG 1
 395  61BB 00           CurrentShipUniv:        DB      0
 396  61BC              ;..................................................................................................................................
 397  61BC              ; if ship is destroyed or exploding then z flag is clear, else z flag is set
 398  61BC              ;..................................................................................................................................
 399  61BC              ; Replacement for MVEIT routine
 400  61BC AF           UpdateUniverseObjects:  xor     a
 401  61BD 32 E6 68                             ld      (SelectedUniverseSlot),a
 402  61C0 CD D1 6A                             call    GetTypeAtSlotA
 403  61C3 AF                                   xor     a
 404  61C4                                      MMUSelectUniverseA                                      ; and we apply roll and pitch
 404  61C4 C6 46       >                     add    a,BankUNIVDATA0
 404  61C6 ED 92 56    >                     nextreg UniverseMMU,       a
 405  61C9 CD EF 61     .ProperUpdate:          call    ApplyMyRollAndPitchTest
 406  61CC              ;call    ApplyMyRollAndPitch24Bit                             ; todo , make all 4 of these 1 call
 407  61CC 3A 89 C0                             ld      a,(UBnKRotZCounter)
 408  61CF FE 00                                cp      0
 409  61D1 CD 3C D6                             call    ApplyShipRollAndPitch
 410  61D4 CD 82 D7                             call    ApplyShipSpeed
 411  61D7 CD D3 C6                             call    UpdateSpeedAndPitch                             ; update based on rates of speed roll and pitch accelleration/decelleration
 412  61DA 3E 00        .TotalDampen:           ld      a,0
 413  61DC 32 89 C0                             ld      (UBnKRotZCounter),a             ; no pitch
 414  61DF 32 88 C0                             ld      (UBnKRotXCounter),a
 415  61E2 32 1C 66                             ld      (JSTX),a
 416  61E5 32 12 66                             ld      (JSTY),a
 417  61E8 CD 6B 61                             call    draw_front_calc_alpha
 418  61EB CD 93 61                             call    draw_front_calc_beta
 419  61EE C9                                   ret
 420  61EF              ;..................................................................................................................................
 421  61EF              ApplyMyRollAndPitchTest:;break
 422  61EF 3A 1E 66                             ld      a,(ALPHA)                   ; no roll or pitch, no calc needed
 423  61F2 A7           .CheckForRoll:          and		a
 424  61F3 C4 52 62     						call	nz,Test_Roll
 425  61F6 3A 11 66     .CheckForPitch:			ld		a,(BETA)
 426  61F9 A7           						and		a
 427  61FA C4 B8 62     						call	nz,Test_Pitch
 428  61FD C9                                   ret
 429  61FE 3A FF 66     .ApplySpeed:            ld      a,(DELTA)                   ; BCH = - Delta
 430  6201 A7                                   and     a
 431  6202 CA 1D 62                             jp      z,.ApplyOrientation
 432  6205              						;ReturnIfAIsZero
 433  6205 0E 00                                ld      c,0                         ;
 434  6207 67           						ld      h,a                         ;
 435  6208 06 80        						ld      b,$80                       ;
 436  620A ED 5B 27 C0  						ld      de,(UBnKzhi)                ; DEL = z position
 437  620E 3A 26 C0     						ld      a,(UBnKzlo)                 ; .
 438  6211 6F           						ld      l,a                         ; .
 439  6212 CD 14 01     						call    AddBCHtoDELsigned           ; update speed
 440  6215 ED 53 27 C0  						ld      (UBnKzhi),DE                ; write back to zpos
 441  6219 7D           						ld      a,l
 442  621A 32 26 C0     						ld      (UBnKzlo),a                ;
 443  621D 3A 1E 66     .ApplyOrientation:      ld      a,(ALPHA)
 444  6220 21 11 66                             ld      hl,BETA
 445  6223 B6                                   or      (hl)
 446  6224 C8                                   ret     z
 447  6225 DD 21 2A C0                          ld      ix,UBnkrotmatSidevX
 448  6229 CD BA 02                             call    ApplyRollAndPitchToIX
 449  622C DD 21 30 C0                          ld      ix,UBnkrotmatRoofvX
 450  6230 CD BA 02                             call    ApplyRollAndPitchToIX
 451  6233 DD 21 36 C0                          ld      ix,UBnkrotmatNosevX
 452  6237 CD BA 02                             call    ApplyRollAndPitchToIX
 453  623A C9                                   ret
 454  623B
 455  623B              ;----------------------------------------------------------------------------------------------------------------------------------
 456  623B              ; Planet version of pitch and roll is a 24 bit calculation 1 bit sign + 23 bit value
 457  623B              ; Need to write a test routine for roll and pitchs
 458  623B 00 00 00 00  TestAlphaMulX            DB $00,$00, $00, $00
 459  623F 00 00 00 00  TestAlphaMulY            DB $00,$00, $00, $00
 460  6243 00 00 00 00  TestAlphaMulZ            DB $00,$00, $00, $00
 461  6247 00 00 00 00  TestBetaMulZ             DB $00,$00, $00, $00
 462  624B 00 00 00 00  TestBetaMulY             DB $00,$00, $00, $00
 463  624F 00 00 00     TestK2                   DS 3
 464  6252
 465  6252 3A 1E 66     Test_Roll:				ld      a,(ALPHA)                   ; get roll value
 466  6255 E6 7F        						and 	$7F
 467  6257 57           						ld      d,a                         ; .
 468  6258 3A 23 C0     						ld      a,(UBnKylo)                ; HLE = x sgn, hi, lo
 469  625B 5F           						ld      e,a                         ; .
 470  625C 2A 24 C0     						ld      hl,(UBnKyhi)               ; .
 471  625F CD A0 6B     						call    DELCequHLEmulDs; replaces mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * -alpha / 256
 472  6262 7D           						ld		a,l
 473  6263 32 3F 62     						ld		(TestAlphaMulY),a			; save result
 474  6266 ED 53 40 62  						ld		(TestAlphaMulY+1),de		; save result
 475  626A 3A 1E 66     						ld      a,(ALPHA)                   ; get roll value
 476  626D E6 7F        						and 	$7F
 477  626F 57           						ld      d,a                         ; .
 478  6270 3A 20 C0     						ld      a,(UBnKxlo)                ; HLE = x sgn, hi, lo
 479  6273 5F           						ld      e,a                         ; .
 480  6274 2A 21 C0     						ld      hl,(UBnKxhi)               ; .
 481  6277 CD A0 6B     						call    DELCequHLEmulDs; replaces mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * -alpha / 256
 482  627A 7D           						ld		a,l
 483  627B 32 3B 62     						ld		(TestAlphaMulX),a			; save result
 484  627E ED 53 3C 62  						ld		(TestAlphaMulX+1),de		; save result
 485  6282 3A 1E 66     						ld		a,(ALPHA)
 486  6285 E6 80        						and		$80
 487  6287 CA A1 62     						jp		z,.RollingRight
 488  628A DD 21 20 C0  .RollingLeft:			ld		ix,UBnKxlo
 489  628E FD 21 3F 62  						ld		iy,TestAlphaMulY
 490  6292 CD 90 00     						call	AddAtIXtoAtIY24Signed
 491  6295 DD 21 23 C0  						ld		ix,UBnKylo
 492  6299 FD 21 3B 62  						ld		iy,TestAlphaMulX
 493  629D CD CD 00     						call	SubAtIXtoAtIY24Signed
 494  62A0 C9           						ret
 495  62A1 DD 21 20 C0  .RollingRight:			ld		ix,UBnKxlo
 496  62A5 FD 21 3F 62  						ld		iy,TestAlphaMulY
 497  62A9 CD CD 00     						call	SubAtIXtoAtIY24Signed
 498  62AC DD 21 23 C0  						ld		ix,UBnKylo
 499  62B0 FD 21 3B 62  						ld		iy,TestAlphaMulX
 500  62B4 CD 90 00     						call	AddAtIXtoAtIY24Signed
 501  62B7 C9           						ret
 502  62B8
 503  62B8 3A 11 66     Test_Pitch:				ld      a,(BETA)                   ; get roll value
 504  62BB E6 7F        						and 	$7F
 505  62BD 57           						ld      d,a                         ; .
 506  62BE 3A 23 C0     						ld      a,(UBnKylo)                ; HLE = x sgn, hi, lo
 507  62C1 5F           						ld      e,a                         ; .
 508  62C2 2A 24 C0     						ld      hl,(UBnKyhi)               ; .
 509  62C5 CD A0 6B     						call    DELCequHLEmulDs; replaces mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * -alpha / 256
 510  62C8 7D           						ld		a,l
 511  62C9 32 4B 62     						ld		(TestBetaMulY),a			; save result
 512  62CC ED 53 4C 62  						ld		(TestBetaMulY+1),de		; save result
 513  62D0 3A 11 66     						ld      a,(BETA)                   ; get roll value
 514  62D3 E6 7F        						and 	$7F
 515  62D5 57           						ld      d,a                         ; .
 516  62D6 3A 26 C0     						ld      a,(UBnKzlo)                ; HLE = x sgn, hi, lo
 517  62D9 5F           						ld      e,a                         ; .
 518  62DA 2A 27 C0     						ld      hl,(UBnKzhi)               ; .
 519  62DD CD A0 6B     						call    DELCequHLEmulDs; replaces mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * -alpha / 256
 520  62E0 7D           						ld		a,l
 521  62E1 32 47 62     						ld		(TestBetaMulZ),a			; save result
 522  62E4 ED 53 48 62  						ld		(TestBetaMulZ+1),de		; save result
 523  62E8 3A 11 66     						ld		a,(BETA)
 524  62EB E6 80        						and		$80
 525  62ED CA 07 63     						jp		z,.Climbing
 526  62F0 DD 21 23 C0  .Diving:				ld		ix,UBnKylo
 527  62F4 FD 21 47 62  						ld		iy,TestBetaMulZ
 528  62F8 CD 90 00     						call	AddAtIXtoAtIY24Signed
 529  62FB DD 21 26 C0  						ld		ix,UBnKzlo
 530  62FF FD 21 4B 62  						ld		iy,TestBetaMulY
 531  6303 CD CD 00     						call	SubAtIXtoAtIY24Signed
 532  6306 C9           						ret
 533  6307 DD 21 23 C0  .Climbing:		     	ld		ix,UBnKylo
 534  630B FD 21 47 62  						ld		iy,TestBetaMulZ
 535  630F CD CD 00     						call	SubAtIXtoAtIY24Signed
 536  6312 DD 21 26 C0  						ld		ix,UBnKzlo
 537  6316 FD 21 4B 62  						ld		iy,TestBetaMulY
 538  631A CD 90 00     						call	AddAtIXtoAtIY24Signed
 539  631D C9           						ret
 540  631E              ;..................................................................................................................................
 541  631E
 542  631E 0A 00 00     Plus10:                 DB 10,0,0
 543  6321 0A 00 80     Minus10:                DB 10,0,$80
 544  6324
 545  6324 14 00 00     Plus20:                 DB 20,0,0
 546  6327 14 00 80     Minus20:                DB 20,0,$80
 547  632A
 548  632A 00 00 00...  SaveUBNK:               DS 3*3
 549  6333
 550  6333 E5 D5 C5 F5  SavePosition:           push    hl,,de,,bc,,af
 551  6337 3A BB 61                             ld      a,(CurrentShipUniv)
 552  633A FE 02                                cp      2
 553  633C 20 31                                jr      nz,.DoneSave
 554  633E                                      ;break
 555  633E 21 20 C0                             ld      hl, UBnKxlo
 556  6341 11 2A 63                             ld      de, SaveUBNK
 557  6344 01 09 00                             ld      bc, 3*3
 558  6347 ED B0                                ldir
 559  6349 3E 00                                ld      a,0
 560  634B 32 24 C0                             ld      (UBnKyhi)  ,a
 561  634E 32 21 C0                             ld      (UBnKxhi)  ,a
 562  6351 32 27 C0                             ld      (UBnKzhi)  ,a
 563  6354 32 22 C0                             ld      (UBnKxsgn) ,a
 564  6357 32 25 C0                             ld      (UBnKysgn) ,a
 565  635A 32 27 C0                             ld      (UBnKzhi)  ,a
 566  635D 32 28 C0                             ld      (UBnKzsgn) ,a
 567  6360 3E 05                                ld      a, $5
 568  6362 32 23 C0                             ld      (UBnKylo)  ,a
 569  6365 3E 05                                ld      a, $5
 570  6367 32 20 C0                             ld      (UBnKxlo)  ,a
 571  636A 3E 6E                                ld      a, $6E
 572  636C 32 26 C0                             ld      (UBnKzlo)  ,a
 573  636F F1 C1 D1 E1  .DoneSave:              pop     hl,,de,,bc,,af
 574  6373 C9                                   ret
 575  6374
 576  6374 E5 D5 C5 F5  RestorePosition:        push    hl,,de,,bc,,af
 577  6378 3A BB 61                             ld      a,(CurrentShipUniv)
 578  637B FE 02                                cp      2
 579  637D 20 0B                                jr      nz,.DoneSave
 580  637F                                      ;break
 581  637F 21 2A 63                             ld      hl, SaveUBNK
 582  6382 11 20 C0                             ld      de, UBnKxlo
 583  6385 01 09 00                             ld      bc, 3*3
 584  6388 ED B0                                ldir
 585  638A F1 C1 D1 E1  .DoneSave:              pop     hl,,de,,bc,,af
 586  638E C9                                   ret
 587  638F
 588  638F 00           currentDemoShip:        DB      0;$12 ; 13 - corirollis
 589  6390
 590  6390
 591  6390              SelectShip:             MMUSelectUniverseN  0
 591  6390 ED 91 56 46 >                     nextreg UniverseMMU,       BankUNIVDATA0+0
 592  6394 06 00                                ld      b,0
 593  6396                                      MMUSelectShipBank1
 593  6396 ED 91 57 3B >					 nextreg ShipModelMMU,	    BankShipModels1
 594  639A FD 26 01                             ld      iyh, 1
 595  639D 3A 8F 63     .SelectRandom:          ld      a,(currentDemoShip)
 596  63A0 FD 6F                                ld      iyl,a
 597  63A2 CD 0F E0                             call    GetShipBankId                       ; find actual memory location of data
 598  63A5                                      MMUSelectShipBankA
 598  63A5 ED 92 57    >					 nextreg ShipModelMMU,	    a
 599  63A8 78                                   ld      a,b
 600  63A9 CD 6A E0                             call    CopyShipToUniverse
 601  63AC 3A 4E C4                             ld      a,(ShipTypeAddr)
 602  63AF 3E 01                                ld      a,1                                 ; slot 1, iyh and iyl already set
 603  63B1 CD 83 C7                             call    UnivInitRuntime
 604  63B4 CD F6 C6                             call    UnivSetDemoPostion
 605  63B7 3A 8F 63                             ld      a,(currentDemoShip)
 606  63BA 3C                                   inc     a
 607  63BB                                      JumpIfALTNusng  16, .OKInc
 607  63BB FE 10       >                        cp      16
 607  63BD DA C1 63    >                        jp		c, .OKInc
 608  63C0              .ResetInc:              ZeroA
 608  63C0 AF          >                        xor a
 609  63C1 32 8F 63     .OKInc:                 ld      (currentDemoShip),a
 610  63C4 C9                                   ret
 611  63C5
 612  63C5
 613  63C5              ;----------------------------------------------------------------------------------------------------------------------------------
 614  63C5              ; Set initial ship position as X,Y,Z 000,000,03B4
 615  63C5 21 00 00     SetInitialShipPosition: ld      hl,$0000
 616  63C8 22 20 C0                             ld      (UBnKxlo),hl
 617  63CB 21 00 00                             ld      hl,$0000
 618  63CE 22 23 C0                             ld      (UBnKylo),hl
 619  63D1 21 B4 03                             ld      hl,$03B4
 620  63D4 22 26 C0                             ld      (UBnKzlo),hl
 621  63D7 AF                                   xor     a
 622  63D8 32 22 C0                             ld      (UBnKxsgn),a
 623  63DB 32 25 C0                             ld      (UBnKysgn),a
 624  63DE 32 28 C0                             ld      (UBnKzsgn),a
 625  63E1 CD 8F C7                             call	InitialiseOrientation            ;#00;
 626  63E4 3E 01                                ld      a,1
 627  63E6 32 FF 66                             ld      (DELTA),a
 628  63E9 21 04 00                             ld      hl,4
 629  63EC 22 00 67                             ld      (DELTA4),hl
 630  63EF C9                                   ret
 631  63F0
 632  63F0                          DISPLAY "../../Maths/Utilities/XX12EquNodeDotOrientation.asm"
 633  63F0                          include "../../Maths/Utilities/XX12EquNodeDotOrientation.asm"
# file opened: ../../Maths/Utilities/XX12EquNodeDotOrientation.asm
   1+ 63F0              ; We enter here with hl pointing at XX16 and bc = XX15 value
   2+ 63F0              ; so xx12 = XX15 * XX16 row
   3+ 63F0              XX12ProcessOneRow:
   4+ 63F0              XX12CalcXCell:
   5+ 63F0 ED 4B E7 C0          ld		bc,(UBnkXScaled)
   6+ 63F4 5E           		ld		e,(hl)								    ; get orientation ZX
   7+ 63F5 23           		inc		hl
   8+ 63F6 56           		ld		d,(hl)                                  ; so now e = xx16 value d = xx16 sign
   9+ 63F7 7A           		ld		a,d
  10+ 63F8 A8                   xor     b
  11+ 63F9 E6 80        		and		SignOnly8Bit                            ; a = XX 16 sign
  12+ 63FB DD 67        		ld		ixh,a								    ; orientation sign to ixh
  13+ 63FD 78           		ld		a,b                                     ; now make bc abs bc
  14+ 63FE E6 7F        		and		SignMask8Bit
  15+ 6400 47           		ld		b,a                                     ; bc = abs(bc) now
  16+ 6401 E5           		push	hl
  17+ 6402 16 00                ld      d,0                                     ; d = value
  18+ 6404 60           		ld		h,b
  19+ 6405 69           		ld		l,c
  20+ 6406 CD 52 6C     		call	HLequHLmulDEu; replaces mulDEbyHL							    ; hl = |orientation| * |x pos)
  21+ 6409 22 C2 65     		ld		(XX12PVarResult1),hl				    ; T = 16 bit result, we only want to use high byte later
  22+ 640C DD 7C        		ld		a,ixh
  23+ 640E 32 C9 65     		ld		(XX12PVarSign1),a					    ; S = sign  not sign 1 and 2 are reversed in memory so that fetchign back will put 1 in high byte 2 in low byte
  24+ 6411 E1           		pop		hl
  25+ 6412              XX12CalcYCell:
  26+ 6412 ED 4B E9 C0          ld		bc,(UBnkYScaled)
  27+ 6416 23           		inc		hl
  28+ 6417 5E           		ld		e,(hl)							    	; get orientation ZX
  29+ 6418 23           		inc		hl
  30+ 6419 56           		ld		d,(hl)
  31+ 641A 7A           		ld		a,d
  32+ 641B A8                   xor     b
  33+ 641C E6 80        		and		SignOnly8Bit
  34+ 641E DD 67        		ld		ixh,a								    ; XX16 orientation sign to ixh
  35+ 6420 78           		ld		a,b                                     ; now make bc abs bc
  36+ 6421 E6 7F        		and		SignMask8Bit
  37+ 6423 47           		ld		b,a                                     ; bc = abs(bc) now
  38+ 6424 E5           		push	hl
  39+ 6425 16 00                ld      d,0                                     ; d = value
  40+ 6427 60           		ld		h,b
  41+ 6428 69           		ld		l,c
  42+ 6429 CD 52 6C     		call	HLequHLmulDEu; replaces mulDEbyHL							    ; hl = |orientation| * |x pos)
  43+ 642C 22 C4 65     		ld		(XX12PVarResult2),hl				    ; T = 16 bit result
  44+ 642F DD 7C        		ld		a,ixh
  45+ 6431 32 C8 65     		ld		(XX12PVarSign2),a					    ; S = sign
  46+ 6434 E1           		pop		hl
  47+ 6435              XX12CalcZCell:
  48+ 6435 ED 4B EB C0          ld		bc,(UBnkZScaled)
  49+ 6439 23           		inc		hl
  50+ 643A 5E           		ld		e,(hl)								    ; get orientation ZX
  51+ 643B 23           		inc		hl
  52+ 643C 56           		ld		d,(hl)
  53+ 643D 7A           		ld		a,d
  54+ 643E A8                   xor     b
  55+ 643F E6 80        		and		SignOnly8Bit
  56+ 6441 DD 67        		ld		ixh,a								    ; orientation sign to ixh
  57+ 6443 78           		ld		a,b                                     ; now make bc abs bc
  58+ 6444 E6 7F        		and		SignMask8Bit
  59+ 6446 47           		ld		b,a                                     ; bc = abs(bc) now
  60+ 6447 16 00                ld      d,0                                     ; d = value
  61+ 6449 60           		ld		h,b
  62+ 644A 69           		ld		l,c
  63+ 644B CD 52 6C     		call	HLequHLmulDEu; replaces mulDEbyHL							    ; hl = |orientation| * |x pos)
  64+ 644E 22 C6 65     		ld		(XX12PVarResult3),hl				    ; T = 16 bit result
  65+ 6451 DD 7C        		ld		a,ixh
  66+ 6453 32 CA 65     		ld		(XX12PVarSign3),a					    ; S = sign
  67+ 6456              XX12CalcCellResult:
  68+ 6456 2A C2 65     		ld		hl,(XX12PVarResult1)				    ; X Cell Result
  69+ 6459 ED 5B C4 65  		ld		de,(XX12PVarResult2)				    ; Y Cell Result
  70+ 645D ED 4B C8 65  		ld		bc,(XX12PVarSign2)					    ; b = var 1 result sign c = var 2 result signs
  71+ 6461              XX12MSBOnly:
  72+ 6461 6C           		ld		l,h									    ; now move results into lower byte so / 256
  73+ 6462 5A           		ld		e,d									    ; for both results
  74+ 6463 AF           		xor		a									    ;
  75+ 6464 67           		ld		h,a									    ;
  76+ 6465 57           		ld		d,a									    ; so set high byte to 0
  77+ 6466 CD 33 00     		call	ADDHLDESignBC                           ;  XX12ProcessCalcHLPlusDESignBC		; returns with HL = result1 + result 2 signed in a
  78+ 6469 47           		ld		b,a									    ; move sign into b ready for next calc
  79+ 646A 3A CA 65     		ld		a,(XX12PVarSign3)					    ; result of the calcZ cell
  80+ 646D 4F           		ld		c,a									    ; goes into c to align with DE
  81+ 646E ED 5B C6 65  		ld		de,(XX12PVarResult3)				    ; now add result to Result 3
  82+ 6472 5A           		ld		e,d                                     ; d = result /256
  83+ 6473 16 00        		ld		d,0									    ; and only us high byte
  84+ 6475 CD 33 00     		call	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC		; returns with HL = result and a = sign
  85+ 6478 C9           		ret											    ; hl = result, a = sign
  86+ 6479              								    ; hl = result, a = sign
  87+ 6479
  88+ 6479              XX12EquNodeDotTransMat:							    ; .LL51	\ -> &4832 \ XX12=XX15.XX16  each vector is 16-bit x,y,z **** ACTUALLY XX16 is value in low sign bit in high
  89+ 6479              ;...X cell
  90+ 6479 21 BA C0     		ld		hl,UbnkTransInvRow0x0     			; process orientation matrix row 0
  91+ 647C CD F0 63             call    XX12ProcessOneRow                   ; hl = result, a = sign
  92+ 647F 47           		ld		b,a                                 ; b = sign
  93+ 6480 7C           		ld		a,h                                 ; a = high byte
  94+ 6481 B0           		or		b
  95+ 6482 32 EE C0     		ld		(UBnkXX12xSign),a					; a = result with sign in bit 7
  96+ 6485 7D           		ld		a,l                                 ; the result will be in the lower byte now
  97+ 6486 32 ED C0             ld      (UBnkXX12xLo),a						; that is result done for
  98+ 6489              ;...Y cell
  99+ 6489 21 C2 C0     		ld		hl,UbnkTransInvRow1y0     			; process orientation matrix row 1
 100+ 648C CD F0 63             call    XX12ProcessOneRow
 101+ 648F 47           		ld		b,a
 102+ 6490 7C           		ld		a,h
 103+ 6491              ;		ld		a,l
 104+ 6491 B0           		or		b
 105+ 6492 32 F0 C0     		ld		(UBnkXX12ySign),a					; a = result with sign in bit 7
 106+ 6495 7D           		ld		a,l                                 ; the result will be in the lower byte now
 107+ 6496 32 EF C0             ld      (UBnkXX12yLo),a						; that is result done for
 108+ 6499              ;...Z cell
 109+ 6499 21 CA C0     		ld		hl,UbnkTransInvRow2z0     			; process orientation matrix row 1
 110+ 649C CD F0 63             call    XX12ProcessOneRow
 111+ 649F 47           		ld		b,a
 112+ 64A0 7C                   ld		a,h
 113+ 64A1              ;		ld		a,l
 114+ 64A1 B0           		or		b
 115+ 64A2 32 F2 C0     		ld		(UBnkXX12zSign),a					; a = result with sign in bit 7
 116+ 64A5 7D           		ld		a,l                                 ; the result will be in the lower byte now
 117+ 64A6 32 F1 C0             ld      (UBnkXX12zLo),a						; that is result done for
 118+ 64A9 C9                   ret
 119+ 64AA
 120+ 64AA              XX12EquNodeDotOrientation:							; .LL51	\ -> &4832 \ XX12=XX15.XX16  each vector is 16-bit x,y,z **** ACTUALLY XX16 is value in low sign bit in high
 121+ 64AA              ;...X cell
 122+ 64AA 21 BA C0     		ld		hl,UbnkTransInvRow0x0     			; process orientation matrix row 0
 123+ 64AD CD F0 63             call    XX12ProcessOneRow                   ; hl = result, a = sign
 124+ 64B0 47           		ld		b,a                                 ; b = sign
 125+ 64B1 7C           		ld		a,h                                 ; a = high byte
 126+ 64B2 B0           		or		b
 127+ 64B3 32 EE C0     		ld		(UBnkXX12xSign),a					; a = result with sign in bit 7
 128+ 64B6 7D           		ld		a,l                                 ; the result will be in the lower byte now
 129+ 64B7 32 ED C0             ld      (UBnkXX12xLo),a						; that is result done for
 130+ 64BA              ;...Y cell
 131+ 64BA 21 C2 C0     		ld		hl,UbnkTransInvRow1y0     			; process orientation matrix row 1
 132+ 64BD CD F0 63             call    XX12ProcessOneRow
 133+ 64C0 47           		ld		b,a
 134+ 64C1 7C           		ld		a,h
 135+ 64C2              ;		ld		a,l
 136+ 64C2 B0           		or		b
 137+ 64C3 32 F0 C0     		ld		(UBnkXX12ySign),a					; a = result with sign in bit 7
 138+ 64C6 7D           		ld		a,l                                 ; the result will be in the lower byte now
 139+ 64C7 32 EF C0             ld      (UBnkXX12yLo),a						; that is result done for
 140+ 64CA              ;...Z cell
 141+ 64CA 21 CA C0     		ld		hl,UbnkTransInvRow2z0     			; process orientation matrix row 1
 142+ 64CD CD F0 63             call    XX12ProcessOneRow
 143+ 64D0 47           		ld		b,a
 144+ 64D1 7C                   ld		a,h
 145+ 64D2              ;		ld		a,l
 146+ 64D2 B0           		or		b
 147+ 64D3 32 F2 C0     		ld		(UBnkXX12zSign),a					; a = result with sign in bit 7
 148+ 64D6 7D           		ld		a,l                                 ; the result will be in the lower byte now
 149+ 64D7 32 F1 C0             ld      (UBnkXX12zLo),a						; that is result done for
 150+ 64DA C9                   ret
 151+ 64DB
 152+ 64DB              XX12EquNodeDotXX16:					         		; .LL51	\ -> &4832 \ XX12=XX15.XX16  each vector is 16-bit x,y,z **** ACTUALLY XX16 is value in low sign bit in high
 153+ 64DB              ;...X cell
 154+ 64DB 21 A2 C0     		ld		hl,UBnkTransmatSidevX     			; process orientation matrix row 0
 155+ 64DE CD F0 63             call    XX12ProcessOneRow                   ; hl = result, a = sign
 156+ 64E1 47           		ld		b,a                                 ; b = sign
 157+ 64E2 7C           		ld		a,h                                 ; a = high byte
 158+ 64E3 B0           		or		b
 159+ 64E4 32 EE C0     		ld		(UBnkXX12xSign),a					; a = result with sign in bit 7
 160+ 64E7 7D           		ld		a,l                                 ; the result will be in the lower byte now
 161+ 64E8 32 ED C0             ld      (UBnkXX12xLo),a						; that is result done for
 162+ 64EB              ;...Y cell
 163+ 64EB 21 A8 C0     		ld		hl,UBnkTransmatRoofvX     			; process orientation matrix row 1
 164+ 64EE CD F0 63             call    XX12ProcessOneRow
 165+ 64F1 47           		ld		b,a
 166+ 64F2 7C           		ld		a,h
 167+ 64F3              ;		ld		a,l
 168+ 64F3 B0           		or		b
 169+ 64F4 32 F0 C0     		ld		(UBnkXX12ySign),a					; a = result with sign in bit 7
 170+ 64F7 7D           		ld		a,l                                 ; the result will be in the lower byte now
 171+ 64F8 32 EF C0             ld      (UBnkXX12yLo),a						; that is result done for
 172+ 64FB              ;...Z cell
 173+ 64FB 21 AE C0     		ld		hl,UBnkTransmatNosevX     			; process orientation matrix row 1
 174+ 64FE CD F0 63             call    XX12ProcessOneRow
 175+ 6501 47           		ld		b,a
 176+ 6502 7C                   ld		a,h
 177+ 6503              ;		ld		a,l
 178+ 6503 B0           		or		b
 179+ 6504 32 F2 C0     		ld		(UBnkXX12zSign),a					; a = result with sign in bit 7
 180+ 6507 7D           		ld		a,l                                 ; the result will be in the lower byte now
 181+ 6508 32 F1 C0             ld      (UBnkXX12zLo),a						; that is result done for
 182+ 650B C9                   ret
# file closed: ../../Maths/Utilities/XX12EquNodeDotOrientation.asm
 634  650C                          DISPLAY "../../ModelRender/CopyXX12ToXX15.asm"
 635  650C                          include "../../ModelRender/CopyXX12ToXX15.asm"
# file opened: ../../ModelRender/CopyXX12ToXX15.asm
   1+ 650C 21 ED C0     CopyXX12ToXX15:         ld      hl,XX12
   2+ 650F 11 E7 C0                             ld      de,XX15
   3+ 6512 01 06 00                             ld      bc,6
   4+ 6515 ED B0                                ldir
   5+ 6517 C9                                   ret
   6+ 6518
   7+ 6518 21 ED C0     CopyXX12ToXX12Save:     ld      hl,XX12
   8+ 651B 11 F3 C0                             ld      de,XX12Save
   9+ 651E 01 06 00                             ld      bc,6
  10+ 6521 ED B0                                ldir
  11+ 6523 C9                                   ret
  12+ 6524
  13+ 6524 21 F3 C0     CopyXX12SaveToXX12:     ld      hl,XX12Save
  14+ 6527 11 ED C0                             ld      de,XX12
  15+ 652A 01 06 00                             ld      bc,6
  16+ 652D ED B0                                ldir
  17+ 652F C9                                   ret
  18+ 6530
  19+ 6530 21 ED C0     CopyXX12ToXX12Save2:    ld      hl,XX12
  20+ 6533 11 F9 C0                             ld      de,XX12Save2
  21+ 6536 01 06 00                             ld      bc,6
  22+ 6539 ED B0                                ldir
  23+ 653B C9                                   ret
  24+ 653C
  25+ 653C 21 F9 C0     CopyXX12Save2ToXX12:    ld      hl,XX12Save2
  26+ 653F 11 ED C0                             ld      de,XX12
  27+ 6542 01 06 00                             ld      bc,6
  28+ 6545 ED B0                                ldir
  29+ 6547 C9                                   ret
  30+ 6548
# file closed: ../../ModelRender/CopyXX12ToXX15.asm
 636  6548                          DISPLAY "../../Maths/Utilities/ScaleXX16Matrix197.asm"
 637  6548                          include "../../Maths/Utilities/ScaleXX16Matrix197.asm"
# file opened: ../../Maths/Utilities/ScaleXX16Matrix197.asm
   1+ 6548              ScaleXX16Matrix197:
   2+ 6548                      IFDEF LOGMATHS
   3+ 6548 ~                                    ld		b,9                 ; Interate though all 9 matrix elements
   4+ 6548 ~                                    ld		hl,UBnkTransmatSidev ; within XX16 (transmat)
   5+ 6548 ~                                    MMUSelectMathsTables
   6+ 6548 ~            .ScaleXX16Loop:         ld		e,(hl)              ; set DE = matrix value              ;
   7+ 6548 ~                                    inc		hl                  ;
   8+ 6548 ~                                    ld		a,(hl)              ;
   9+ 6548 ~                                    ld		d,a                 ;
  10+ 6548 ~                                    and     SignOnly8Bit        ; A holds high still to we can strip out sign bit
  11+ 6548 ~                                    ld		ixl,a				; retain for sign bit
  12+ 6548 ~                                    ShiftDELeft1				; carry now holds sign bit and DE = De * 2, this will in effect strip off the sign bit automatically
  13+ 6548 ~                                    ld      a,d                 ; a = high byte after x 2
  14+ 6548 ~                                    push	bc                  ; save BC  counter and constant 197
  15+ 6548 ~                                    push	hl                  ; save HL
  16+ 6548 ~                                    call    AEquAmul256Div197Log;
  17+ 6548 ~                                    pop		hl
  18+ 6548 ~                                    dec     hl                  ; move back to low byte
  19+ 6548 ~                                    ld      (hl),a              ; save result in low byte as we want to preserve high byte sign
  20+ 6548 ~                                    inc     hl                  ; move back to high byte
  21+ 6548 ~                                    ld      a,ixl
  22+ 6548 ~                                    ld      (hl),a              ; write back just sign bit
  23+ 6548 ~                                    pop		bc                  ; retrieve both counter and constant 197
  24+ 6548 ~                                    inc     hl                  ; no to next vertex value
  25+ 6548 ~                                    djnz	.ScaleXX16Loop
  26+ 6548 ~                                    MMUSelectROM0
  27+ 6548 ~                                    ret
  28+ 6548                      ELSE
  29+ 6548 06 09                                ld		b,9                 ; Interate though all 9 matrix elements
  30+ 654A 0E C5                                ld		c,ConstNorm         ; c = 197
  31+ 654C 21 A2 C0                             ld		hl,UBnkTransmatSidev ; within XX16 (transmat)
  32+ 654F 7E           .ScaleXX16Loop:         ld		a,(hl)              ; set DE = matrix value
  33+ 6550 5F                                   ld		e,a                 ;
  34+ 6551 23                                   inc		hl                  ;
  35+ 6552 7E                                   ld		a,(hl)              ;
  36+ 6553 57                                   ld		d,a                 ;
  37+ 6554 E6 80                                and     SignOnly8Bit        ; A holds high still to we can strip out sign bit
  38+ 6556 DD 6F                                ld		ixl,a				; retain for sign bit
  39+ 6558                                      ShiftDELeft1				; carry now holds sign bit and DE = De * 2, this will in effect strip off the sign bit automatically
  39+ 6558 CB 23       >               sla e
  39+ 655A CB 12       >               rl  d
  40+ 655C 7A                                   ld      a,d                 ; a = high byte after x 2
  41+ 655D C5                                   push	bc                  ; save BC  counter and constant 197
  42+ 655E E5                                   push	hl                  ; save HL
  43+ 655F CD 48 70                             call	DIV16Amul256dCUNDOC; AEquAmul256DivD; DIV16Amul256dCUNDOC	; result in BC = A*256 / 197 or D *512 / 197 = 2.6 * vector element, effectivley the result will always be in c
  44+ 6562 E1                                   pop		hl
  45+ 6563 2B                                   dec     hl                  ; move back to low byte
  46+ 6564 71                                   ld      (hl),c              ; save result in low byte as we want to preserve high byte sign
  47+ 6565 23                                   inc     hl                  ; move back to high byte
  48+ 6566                                  ;    ld      a,(hl)
  49+ 6566                                  ;    and     $80
  50+ 6566 DD 7D                                ld      a,ixl
  51+ 6568 77                                   ld      (hl),a              ; write back just sign bit
  52+ 6569 C1                                   pop		bc                  ; retrieve both counter and constant 197
  53+ 656A 23                                   inc     hl                  ; no to next vertex value
  54+ 656B 10 E2                                djnz	.ScaleXX16Loop
  55+ 656D C9                                   ret
  56+ 656E                      ENDIF
# file closed: ../../Maths/Utilities/ScaleXX16Matrix197.asm
 638  656E
 639  656E                          ;nclude "../../Universe/StarDust/StarRoutines.asm"
 640  656E
 641  656E                          INCLUDE	"../../Hardware/memfill_dma.asm"
# file opened: ../../Hardware/memfill_dma.asm
   1+ 656E
   2+ 656E 00           memfillvalue		DB 0
   3+ 656F 83 C3 C7 CB  memfill        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   3+ 6573 7D
   4+ 6574 6E 65        memfill_astrt  		DW memfillvalue
   5+ 6576 00 40        memfill_length 		DB $00,$40
   6+ 6578 24 10 AD     					DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
   7+ 657B 00 00        memfill_bstrt  		DB $00,$00
   8+ 657D 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
   9+ 6581              memfill_cmd_len	  	EQU $ - memfill
  10+ 6581
  11+ 6581              memfill_dma:
  12+ 6581              ; "memfill_dma, hl = address to fill, a = value, de = length"
  13+ 6581              .set_fill_value:
  14+ 6581 32 6E 65     	ld 		(memfillvalue),a
  15+ 6584              .set_target:
  16+ 6584 22 7B 65     	ld		(memfill_bstrt),hl
  17+ 6587              .set_length:
  18+ 6587 ED 53 76 65  	ld		(memfill_length),de
  19+ 658B              .write_dma:
  20+ 658B 21 6F 65     	ld 		hl, memfill
  21+ 658E 06 12        	ld 		b, memfill_cmd_len
  22+ 6590 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
  23+ 6592 ED B3        	otir
  24+ 6594 C9           	ret
  25+ 6595
# file closed: ../../Hardware/memfill_dma.asm
 642  6595                          INCLUDE	"../../Hardware/memcopy_dma.asm"
# file opened: ../../Hardware/memcopy_dma.asm
   1+ 6595
   2+ 6595 83 C3 C7 CB  memcopy        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   2+ 6599 7D
   3+ 659A 00 00        memcopy_astrt  		DB $00,$00
   4+ 659C 00 40        memcopy_length 		DB $00,$40
   5+ 659E 14 10 CD     					DB DMA_WR1_P1INC_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_BURST_MODE;DMA_WR4_CONT_MODE
   6+ 65A1 00 00        memcopy_bstrt  		DB $00,$00
   7+ 65A3 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
   8+ 65A7              memcopy_cmd_len	  	equ $ - memcopy
   9+ 65A7
  10+ 65A7              memcopy_dma:
  11+ 65A7              ; "memcopy_dma, hl = target address de = source address to copy, bc = length"
  12+ 65A7              .set_target:
  13+ 65A7 22 A1 65     	ld		(memcopy_bstrt),hl
  14+ 65AA              .set_source:
  15+ 65AA ED 53 9A 65  	ld		(memcopy_astrt),de
  16+ 65AE              .set_length:
  17+ 65AE ED 43 9C 65  	ld		(memcopy_length),bc
  18+ 65B2              .write_dma:
  19+ 65B2 21 95 65     	ld 		hl, memcopy
  20+ 65B5 06 12        	ld 		b, memcopy_cmd_len
  21+ 65B7 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
  22+ 65B9 ED B3        	otir
  23+ 65BB C9           	ret
  24+ 65BC
# file closed: ../../Hardware/memcopy_dma.asm
 643  65BC 00 00        XX12PVarQ			DW 0
 644  65BE 00 00        XX12PVarR			DW 0
 645  65C0 00 00        XX12PVarS			DW 0
 646  65C2 00 00        XX12PVarResult1		DW 0
 647  65C4 00 00        XX12PVarResult2		DW 0
 648  65C6 00 00        XX12PVarResult3		DW 0
 649  65C8 00           XX12PVarSign2		DB 0
 650  65C9 00           XX12PVarSign1		DB 0								; Note reversed so BC can do a little endian fetch
 651  65CA 00           XX12PVarSign3		DB 0
 652  65CB                  INCLUDE "../../Variables/constant_equates.asm"
# file opened: ../../Variables/constant_equates.asm
   1+ 65CB              ;Contants
   2+ 65CB
   3+ 65CB              SignMask8Bit		equ %01111111
   4+ 65CB              SignMask16Bit		equ %0111111111111111
   5+ 65CB              SignOnly8Bit		equ $80
   6+ 65CB              SignOnly16Bit		equ $8000
   7+ 65CB
   8+ 65CB              Bit7Only            equ %10000000
   9+ 65CB              Bit6Only            equ %01000000
  10+ 65CB              Bit5Only            equ %00100000
  11+ 65CB              Bit4Only            equ %00010000
  12+ 65CB              Bit3Only            equ %00001000
  13+ 65CB              Bit2Only            equ %00000100
  14+ 65CB              Bit1Only            equ %00000010
  15+ 65CB              Bit0Only            equ %00000001
  16+ 65CB              Bit7Clear           equ %01111111
  17+ 65CB              Bit6Clear           equ %10111111
  18+ 65CB              Bit5Clear           equ %11011111
  19+ 65CB              Bit4Clear           equ %11101111
  20+ 65CB              Bit3Clear           equ %11110111
  21+ 65CB              Bit2Clear           equ %11111011
  22+ 65CB              Bit1Clear           equ %11111101
  23+ 65CB              Bit0Clear           equ %11111110
  24+ 65CB              ConstPi				equ $80
  25+ 65CB              ConstNorm           equ 197
  26+ 65CB              ;OpCodes
  27+ 65CB              OpCodeSCF           equ $37
  28+ 65CB              OpCodeCCF           equ $3F
  29+ 65CB              OpCodeAndA          equ $A7
  30+ 65CB              OpCodeClearCarryFlag equ OpCodeAndA
  31+ 65CB
  32+ 65CB              TidyInterval        equ 16
  33+ 65CB
  34+ 65CB              ;Text Tokens
  35+ 65CB              EliteToken			equ $1E			; Token ID for text messsage ---- E L I T E ----
  36+ 65CB              BrabenBellToken 	equ $0D
  37+ 65CB              AcorToken			equ $0C
  38+ 65CB              ; Cursor Bits
  39+ 65CB              CursorClimb         equ %10000000
  40+ 65CB              CursorDive          equ %01000000
  41+ 65CB              CursorLeft          equ %00100000
  42+ 65CB              CursorRight         equ %00010000
  43+ 65CB              CursorHome          equ %00001000
  44+ 65CB              CursorRecenter      equ %00000100
  45+ 65CB
  46+ 65CB              ; Intro Screen
  47+ 65CB              TitleShip			equ	$8C
  48+ 65CB              RotationUnity		equ $60
  49+ 65CB              DBCheckCode			equ $DB
  50+ 65CB              MaxVisibility		equ $1F
  51+ 65CB              FarInFront			equ $C0
  52+ 65CB              ; Equipment Flags
  53+ 65CB              EquipmentItemFitted     equ $FF
  54+ 65CB              EquipmentItemNotFitted  equ 0
  55+ 65CB              ; Universe Managment
  56+ 65CB              PlanetTypeMeridian      equ 128
  57+ 65CB              PlanetMinRadius         equ 6
  58+ 65CB
  59+ 65CB              ShipTotalModelCount     equ 44
  60+ 65CB              ShipTypeNormal          equ 0
  61+ 65CB              ShipTypeMissile         equ 1
  62+ 65CB              ShipTypeStation         equ 2
  63+ 65CB              ShipTypeJunk            equ 3
  64+ 65CB              ShipTypeScoopable       equ 4         ; a sub set of junk
  65+ 65CB              ShipTypeTargoid         equ 5
  66+ 65CB              ShipTypeUndefined1      equ 6
  67+ 65CB              ShipTypeUndefined2      equ 7
  68+ 65CB              ShipTypeUndefined3      equ 8
  69+ 65CB              ShipTypeUndefined4      equ 9
  70+ 65CB              ShipTypeUndefined5      equ 10
  71+ 65CB              ShipTypeUndefined6      equ 11
  72+ 65CB              ShipTypeUndefined7      equ 12
  73+ 65CB              ShipTypeUndefined8      equ 13
  74+ 65CB              ShipTypeUndefined9      equ 14
  75+ 65CB              ShipTypeUndefined10      equ 15
  76+ 65CB              ShipTypeNoAI            equ 16
  77+ 65CB
  78+ 65CB              ShipTypeText            equ 253
  79+ 65CB              ShipTypeDebug           equ 254
  80+ 65CB              ShipTypeEmpty           equ 255
  81+ 65CB
  82+ 65CB              SpawnTypeStation        EQU 0
  83+ 65CB              SpawnTypeBodies         EQU SpawnTypeStation        + 1
  84+ 65CB              SpawnTypeJunk           EQU SpawnTypeBodies         + 1
  85+ 65CB              SpawnTypeCop            EQU SpawnTypeJunk           + 1
  86+ 65CB              SpawnTypeTrader         EQU SpawnTypeCop            + 1
  87+ 65CB              SpawnTypeNonTrader      EQU SpawnTypeTrader         + 1
  88+ 65CB              SpawnTypePirate         EQU SpawnTypeNonTrader      + 1
  89+ 65CB              SpawnTypeHunter         EQU SpawnTypePirate         + 1
  90+ 65CB              SpawnTypeThargoid       EQU SpawnTypeHunter         + 1
  91+ 65CB              SpawnTypeMission        EQU SpawnTypeThargoid       + 1
  92+ 65CB              SpawnTypeStationDebris  EQU SpawnTypeMission        + 1
  93+ 65CB              SpawnTypeMissionEvent   EQU SpawnTypeStationDebris  + 1
  94+ 65CB              SpawnTypeDoNotSpawn     EQU SpawnTypeMissionEvent   + 1
  95+ 65CB
  96+ 65CB              ; Inventory Equates
  97+ 65CB              StockTypeCount          EQU 17
  98+ 65CB              StockTypeMax            EQU StockTypeCount - 1
  99+ 65CB              StockTypePenultimate    EQU StockTypeCount - 2
 100+ 65CB              ; Laser and Missile Settings
 101+ 65CB              ; Laser and Missile
 102+ 65CB              ShipLaserPower          equ %11110000
 103+ 65CB              ShipMissileCount        equ %00001111
 104+ 65CB              ShipMissiles1           equ %00000001
 105+ 65CB              ShipMissiles2           equ %00000010
 106+ 65CB              ShipMissiles3           equ %00000011
 107+ 65CB              ShipMissiles4           equ %00000100
 108+ 65CB              ShipMissiles5           equ %00000101
 109+ 65CB              ShipMissiles6           equ %00000110
 110+ 65CB              ShipMissiles7           equ %00000111
 111+ 65CB              ShipMissiles8           equ %00001000
 112+ 65CB              ShipMissiles9           equ %00001001
 113+ 65CB              ShipMissiles10          equ %00001010
 114+ 65CB              ShipMissiles11          equ %00001011
 115+ 65CB              ShipMissiles12          equ %00001100
 116+ 65CB              ShipMissiles13          equ %00001101
 117+ 65CB              ShipMissiles14          equ %00001110
 118+ 65CB              ShipMissiles15          equ %00001111
 119+ 65CB              ; AI Flags  UniverseAIControl
 120+ 65CB              ShipCanAnger            equ %10000000   ; Yes or no
 121+ 65CB              ShipFighterBaySize      equ %01110000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 122+ 65CB              ShipFighterBaySize1     equ %00010000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 123+ 65CB              ShipFighterBaySize2     equ %00100000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 124+ 65CB              ShipFighterBaySize3     equ %00110000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 125+ 65CB              ShipFighterBaySize4     equ %01000000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 126+ 65CB              ShipFighterBaySize5     equ %01010000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 127+ 65CB              ShipFighterBaySizeInf   equ %01110000   ; Infinite fighters (well 255 as thats enough)
 128+ 65CB              ShipFighterType         equ %00001100   ; 4 types 0 = Worm, 1 = Sidewinder, 2 = Viper, 3 = Thargon
 129+ 65CB              ShipFighterWorm         equ %00000000
 130+ 65CB              ShipFighterSidewinder   equ %00000100
 131+ 65CB              ShipFighterViper        equ %00001000
 132+ 65CB              ShipFighterThargon      equ %00001100
 133+ 65CB              ShipUltraHostile        equ %00000010   ; If ultra hostile, will never back down so behaves like a missile
 134+ 65CB              ShipFree                equ $00000011   ; Unused bits at present for later
 135+ 65CB              ; NewBTactics
 136+ 65CB              ShipIsTrader            equ Bit0Only   ; Trader flag  80% are peaceful 20% also have Bounty Hunter flag
 137+ 65CB              ShipIsBountyHunter      equ Bit1Only   ;
 138+ 65CB              ShipIsHostile           equ Bit2Only   ; Also used as Angry flag now
 139+ 65CB              ShipIsPirate            equ Bit3Only   ;
 140+ 65CB              ShipIsDocking           equ Bit4Only   ;
 141+ 65CB              ShipIsBystander         equ Bit5Only   ;
 142+ 65CB              ShipIsCop               equ Bit6Only   ;
 143+ 65CB              ShipHasEscapePod        equ Bit7Only   ;
 144+ 65CB              ShipHostileNewBitNbr    equ 2
 145+ 65CB                      DISPLAY "TODO: Add bravery based on rank, new bits and type of ship"
 146+ 65CB
 147+ 65CB              ; UBnkaiatkecm
 148+ 65CB              ;Unused                 equ Bit0Only
 149+ 65CB              ;Unused                 equ Bit1Only
 150+ 65CB              ;Unused                 equ Bit2Only
 151+ 65CB              ShipIsDot               equ Bit3Only
 152+ 65CB              ShipKilled              equ Bit4Only    ; Ship has just been marked as killed so initiate cloud of debris
 153+ 65CB              ShipExploding           equ Bit5Only
 154+ 65CB              ShipIsVisible           equ Bit6Only
 155+ 65CB              ShipAIEnabled           equ Bit7Only   ;
 156+ 65CB
 157+ 65CB
 158+ 65CB              ; UBnkaiakecm 2
 159+ 65CB              ;ShipAngryNewBitNbr      equ 4
 160+ 65CB              ShipExplosionDuration   equ 75         ; amount of frames an explosion lasts for
 161+ 65CB              ShipNotHostile          equ Bit2Clear   ;
 162+ 65CB              ShipIsNotDot            equ Bit3Clear
 163+ 65CB              ShipIsDotBitNbr         equ 3
 164+ 65CB              ShipKilledBitNbr        equ 4
 165+ 65CB              ShipIsVisibleBitNbr     equ 6
 166+ 65CB              ShipIsScoopDockEsc      equ Bit7Only   ;
 167+ 65CB              ShipAIDisabled          equ Bit7Clear
 168+ 65CB              ShipAIEnabledBitNbr     equ 7
 169+ 65CB              ShipExplodingBitNbr     equ 5
 170+ 65CB              ; Equipment Defaults
 171+ 65CB              ECMCounterMax           equ $80
 172+ 65CB              ; Main Loop State
 173+ 65CB              StatePlayerDocked       equ $FF
 174+ 65CB              StateCompletedLaunch    equ $FD
 175+ 65CB              StateInTransition       equ $FE
 176+ 65CB              StateHJumping           equ $FC
 177+ 65CB              StateHEntering          equ $FB
 178+ 65CB              StateCompletedHJump     equ $FA
 179+ 65CB              StateNormal             equ 0
 180+ 65CB              ; Missile Stage flags , $8x = locked to ship id x, $0x = fire at ship id x requested
 181+ 65CB              StageMissileNotTargeting equ $FF
 182+ 65CB              StageMissileTargeting   equ $FE
 183+ 65CB
 184+ 65CB
 185+ 65CB              ShipMaxDistance     equ 192
 186+ 65CB              HyperSpaceTimers    equ $0B0B
 187+ 65CB
 188+ 65CB              ; -- game limts
 189+ 65CB              MaxNumberOfStars	equ 11
 190+ 65CB              ConsoleRefreshInterval  equ 5
 191+ 65CB              MaxJunkStation      equ 3
 192+ 65CB              MaxJunkFreeSpace    equ 5
 193+ 65CB              WarpCoolDownPeriod  equ 90
 194+ 65CB
 195+ 65CB              ShipTypeSize		equ	32 			;??????? just a guess for now
 196+ 65CB              ShipSST				equ 4			; its a space station
 197+ 65CB              UniverseBasePage 	equ 70			; Base memory bank for universe Item #0
 198+ 65CB              ShipDataBasePage	equ	90			; Needs 2mb upgrade but what the heck
 199+ 65CB              ShipCountMax		equ	2			; For now just 2 ships to debug
 200+ 65CB              LineLimitPerShip	equ 70			; Max lines per ship
 201+ 65CB              FaceLimitPerShip	equ	70			; Same as line limit to simplify some logic
 202+ 65CB              ; "NEED TO DEFINE SHIPTYPESIZE TODO"
 203+ 65CB
 204+ 65CB              ; Memory page managment	(Refers to a memory slot as a place to access data)
 205+ 65CB              ShipDataSlot		equ	6			; this may move into rom swap out space later
 206+ 65CB              UniverseObjectSlot	equ	7
 207+ 65CB
 208+ 65CB              KeyForwardsView		equ	$20
 209+ 65CB              ; Game specific equates
 210+ 65CB              MissileDropHeight   equ 5           ; how far the missile is ejected on launch in y axis
 211+ 65CB              WarpSequenceCount   equ 50
 212+ 65CB
 213+ 65CB              ;...Game Colour Mapping
 214+ 65CB              L2DustColour        equ L2ColourGREY_1
 215+ 65CB              L2SunScannerBright  equ 252
 216+ 65CB              L2SunScanner        equ 180
 217+ 65CB              L2DebrisColour      equ L2ColourYELLOW_1
 218+ 65CB
 219+ 65CB
 220+ 65CB              ; Ship Data
 221+ 65CB              ;;;;	.XX21	\ -> &5600 \ Table of pointers to ships' data given to XX0
 222+ 65CB              ;;;;00 7F			 EQUW &7F00 \ type  1 is #MSL  Missile data on page off bottom of screen
 223+ 65CB              ;;;;00 00			 EQUW 0     \ type  2 is #SST  Space Station, Coriolis or Dodo.
 224+ 65CB              ;;;;00 00			 EQUW 0     \ type  3 is #ESC  Escape capsule
 225+ 65CB              ;;;;00 00			 EQUW 0     \ type  4 is #PLT  Plate, alloys
 226+ 65CB              ;;;;00 00			 EQUW 0     \ type  5 is #OIL  Cargo cannister
 227+ 65CB              ;;;;00 00			 EQUW 0     \ type  6 is       Boulder
 228+ 65CB              ;;;;00 00			 EQUW 0     \ type  7 is #AST  Asteroid
 229+ 65CB              ;;;;00 00			 EQUW 0     \ type  8 is #SPL  Splinter, rock.
 230+ 65CB              ;;;;00 00			 EQUW 0     \ type  9 is #SHU  Shuttle
 231+ 65CB              ;;;;00 00			 EQUW 0     \ type 10 is       Transporter
 232+ 65CB              ;;;;00 00			 EQUW 0     \ type 11 is #CYL  Cobra Mk III,  Boa
 233+ 65CB              ;;;;00 00			 EQUW 0     \ type 12 is       Python
 234+ 65CB              ;;;;00 00			 EQUW 0     \ type 13 is       Last of three traders
 235+ 65CB              ;;;;00 00			 EQUW 0     \ type 14 is #ANA  Anaconda
 236+ 65CB              ;;;;00 00			 EQUW 0     \ type 15 is #WRM  Worm with Anaconda
 237+ 65CB              ;;;;00 00			 EQUW 0     \ type 16 is #COP  Viper
 238+ 65CB              ;;;;00 00			 EQUW 0     \ type 17 is       First pirate
 239+ 65CB              ;;;;00 00			 EQUW 0     \ type 18 is
 240+ 65CB              ;;;;00 00			 EQUW 0     \ type 19 is #KRA  Krait small pirate
 241+ 65CB              ;;;;00 00			 EQUW 0     \ type 20 is #ADA  Adder
 242+ 65CB              ;;;;00 00			 EQUW 0     \ type 21 is
 243+ 65CB              ;;;;00 00			 EQUW 0     \ type 22 is
 244+ 65CB              ;;;;00 00			 EQUW 0     \ type 23 is
 245+ 65CB              ;;;;00 00			 EQUW 0     \ type 24 is #CYL2 Last strong pirate
 246+ 65CB              ;;;;00 00			 EQUW 0     \ type 25 is #ASP  Asp Mk II
 247+ 65CB              ;;;;00 00			 EQUW 0     \ type 26 is #FER  Fer de Lance
 248+ 65CB              ;;;;00 00			 EQUW 0     \ type 27 is
 249+ 65CB              ;;;;00 00			 EQUW 0     \ type 28 is	Last of three bounty hunters
 250+ 65CB              ;;;;00 00			 EQUW 0     \ type 29 is #THG  Thargoid
 251+ 65CB              ;;;;00 00			 EQUW 0     \ type 30 is #TGL  Thargon
 252+ 65CB              ;;;;00 00			 EQUW 0     \ type 31 is #CON  Constrictor
 253+ 65CB              ;;;;	.E%	\ -> &563E \ Hull NEWB bits are escpod, cop, inno, ?, pirate, angry, hunter, trader.
 254+ 65CB              ;;;;			\ NEWB examples
 255+ 65CB              ;;;;\ 21			EQUB &21    \ 0010 0001    9 Shuttle has no escape pod, inno, trader.
 256+ 65CB              ;;;;\ 61			EQUB &61    \ 0110 0001   10 Tansporter no escape pod, Cop, inno, trader.
 257+ 65CB              ;;;;\ A0			EQUB &A0    \ 1010 0000   11 Cobra has Escape pod, inno, not a trader.
 258+ 65CB              ;;;;\ C2			EQUB &C2    \ 1100 0010   16 Viper has Escape pod, Cop, hunter.
 259+ 65CB              ;;;;\ 8C			EQUB &8C    \ 1000 1100   19 Krait pirate has escape pod, is pirate and angry.
 260+ 65CB
# file closed: ../../Variables/constant_equates.asm
 653  65CB                  INCLUDE "../../Variables/general_variables.asm"
# file opened: ../../Variables/general_variables.asm
   1+ 65CB                  IFNDEF LASER_V2
   2+ 65CB                  DEFINE  LASER_V2    1
   3+ 65CB                  ENDIF
   4+ 65CB              ; Debugging data
   5+ 65CB 00 00 00...  failureDiag DS  10              ; 10 bytes to log data before a failure
   6+ 65D5
   7+ 65D5              LogFailure:     MACRO messageAddress
   8+ 65D5 ~                            ld      hl,messageAddress
   9+ 65D5 ~                            ld      de,failureDiag
  10+ 65D5 ~                            ld      bc,10
  11+ 65D5 ~                            ldir
  12+ 65D5                              ENDM
  13+ 65D5              ;-- Memory management variables
  14+ 65D5 00 00 00...  SaveMMU0Queue:          DS      5                   ; Allows up to 5 levels of depth for queue stacking
  15+ 65DA 00 00 00...  SaveMMU6Queue:          DS      5                   ; Allows up to 5 levels of depth for queue stacking
  16+ 65DF 00 00 00...  SaveMMU7Queue:          DS      5                   ; Allows up to 5 levels of depth for queue stacking
  17+ 65E4              ;-- Note these are not counters but initialised to memory locations to simplify code
  18+ 65E4              ;-- Point to the next free memory location to write to
  19+ 65E4 D5 65        SaveMMU0QueueHead:      DW      SaveMMU0Queue       ; Current last saved MMU Entry
  20+ 65E6 DA 65        SaveMMU6QueueHead:      DW      SaveMMU6Queue       ; Current last saved MMU Entry
  21+ 65E8 DF 65        SaveMMU7QueueHead:      DW      SaveMMU7Queue       ; Current last saved MMU Entry
  22+ 65EA
  23+ 65EA 00 00        varAxis1	DW 	0				; address of first axis in a rotation action
  24+ 65EC 00 00        varAxis2	DW	0				; address of 2nd axis in a roation action
  25+ 65EE              ; Variables to simulate 6502 registers until code fixed
  26+ 65EE              ; These must be here in this order as reading Y and X can then be a 16 bit read
  27+ 65EE 00           regX		DB	0               ; using 16 bit read into BC this would go into C
  28+ 65EF 00           regY		DB	0               ; using 16 bit read into BC this would go into B
  29+ 65F0 00           regA		DB	0
  30+ 65F1
  31+ 65F1
  32+ 65F1 00           varGPLoopA	DB	0				; General Purpose innermost loop variable
  33+ 65F2 00 00        INF			DW	0				; page 0 &20 Used to get address from UNIV array
  34+ 65F4 00 00        INF28		DW	0				; page 0 &20 Used to get address from UNIV array
  35+ 65F6
  36+ 65F6
  37+ 65F6
  38+ 65F6              ;XX16		DS	16				; 16 byte Matrix
  39+ 65F6
  40+ 65F6              P0INWK							; page 0 & 46
  41+ 65F6              p0INWK31						; page 0 & 65
  42+ 65F6              P0INWK36						; PAGE 0 &6A
  43+ 65F6
  44+ 65F6 00           XX4			DB	0				; XX4 page 0 &96 last Normal Found to be visible
  45+ 65F7              LastNormalVisible	equ	XX4
  46+ 65F7              varXX4              equ XX4
  47+ 65F7
  48+ 65F7
  49+ 65F7
  50+ 65F7 00           PATG		DB	0				; 6502 &03C9
  51+ 65F8 00 00        SLSP 		DW	0				; &03B0 \ SLSP \ ship lines pointer
  52+ 65FA
  53+ 65FA
  54+ 65FA              ;UNIV		DS FreeListSize*2	; Array of Universe Pointers
  55+ 65FA              ;HULLINDEX	DS ShipTypeSize*2	; hull index for table at XX21= &F XX21-1,Y
  56+ 65FA
  57+ 65FA              ; Present System Variables
  58+ 65FA
  59+ 65FA 2B           RandomSeed				DB	43			    ; 00 DEBUG JUST SOME START VALUES
  60+ 65FB 20           RandomSeed1				DB	32	            ; 01
  61+ 65FC 0C           RandomSeed2				DB	12			    ; 02
  62+ 65FD 42           RandomSeed3				DB	66			    ; 03
  63+ 65FE 00 00 00 00  RandomSeedSave          DS  4               ; used in explosion routine to save randoms
  64+ 6602 00           varT1					DB	0				; 06
  65+ 6603 00           SClo					DB 0				; 07
  66+ 6604 00           SChi					DB 0				; 08
  67+ 6605 00           varP					DB 0 				; 10	XX16+7
  68+ 6606 00           varPhi					DB 0 				; 11	XX16+8
  69+ 6607 00           varPhi2					DB 0 				; 12	XX16+9
  70+ 6608 00           varPhiSign              DB 0
  71+ 6609              varPp1                  equ varPhi
  72+ 6609              varPp2                  equ varPhi2
  73+ 6609              varPp3                  equ varPhiSign
  74+ 6609 00           UnivPointerLo			DB	0				; 20		INF                 XX0+2
  75+ 660A 00           UnivPointerHi			DB	0				; 21      INF+1               XX0+3
  76+ 660B              UnivPointer				equ	UnivPointerLo
  77+ 660B 00           varV					DB 0				; 22                          XX0+4
  78+ 660C 00           varVHi					DB 0				; 23                          XX0+5
  79+ 660D 00           varXXlo                 DB 0                ; 24
  80+ 660E 00           varXXHi                 DB 0                ; 25
  81+ 660F              varXX					equ	varXXlo
  82+ 660F 00           YYlo                    DB 0                ; 26
  83+ 6610 00           YYHi                    DB 0                ; 27
  84+ 6611              varYY					equ	YYlo
  85+ 6611              											;	28
  86+ 6611              											;	29
  87+ 6611              ;PlayerShipPositionData - Must be contiguous for setup
  88+ 6611 00           BETA 					DB	0               ; 2A        (pitch done)
  89+ 6612 00           JSTY                    DB  0               ; Joystick analog
  90+ 6613 00           BET1 					DB	0               ; 2B        lower7 magnitude
  91+ 6614 00           BET2                    DB  0               ;            climb sign
  92+ 6615 00           BET2FLIP				DB	0				; 7C		BET 2 pitch Sign negated
  93+ 6616 1F           BET1MAXC                DB  31              ; max climb
  94+ 6617 E1           BET1MAXD                DB  -31             ; max dive
  95+ 6618 00           XC						DB	0               ; 2C
  96+ 6619 00           YC						DB 	0               ; 2D
  97+ 661A              ;... ECM logic. If another ship adds ECM then we just set the loop A and B to starting values so they overlap
  98+ 661A 00           ECMCountDown            DB  0
  99+ 661B 00           ECMLoopB                DB  0
 100+ 661C 00 00        JSTX                    DW  0               ;           Joystick analog value
 101+ 661E 00           ALPHA					DB	0				; 8D        Alpha with bit 7 sign
 102+ 661F 00           ALP1					DB 	0				; 31		ALP1	ABS Alpha
 103+ 6620 00           ALP2					DB  0				; 32		ALP2	Roll Sign
 104+ 6621 00           ALP2FLIP				DB  0				; 33		ALP2	negated roll sign
 105+ 6622 1F           ALP1MAXR                DB  31               ;   Maximum roll, added becuase we may allow different ship types
 106+ 6623 E1           ALP1MAXL                DB  -31             ;   Maximum roll, added becuase we may allow different ship types
 107+ 6624
 108+ 6624
 109+ 6624              ;-- Message handler -----------------------------------------------------------------------------------------------------------------
 110+ 6624              MAXMESSAGES             EQU 5
 111+ 6624              MESSAGETIMELIMIT        EQU 20
 112+ 6624              MESSAGESIZE             EQU 33
 113+ 6624              MESSAGELINE             EQU $0001
 114+ 6624
 115+ 6624 00           MessageCount            DB  0                ; used for enquing messages later
 116+ 6625 00           MessageCurrent          DB  0
 117+ 6626 05 00        MessageIndex            DW  MAXMESSAGES
 118+ 6628 00 00 00...  MessageQueue            DS  MAXMESSAGES * MESSAGESIZE
 119+ 66CD 05           MessageTimeout          DB  MAXMESSAGES
 120+ 66CE 00 00 00...  IndexedWork				DS	37				; General purpose work space when doing temp arrays
 121+ 66F3
 122+ 66F3              ; MOVED TO Universe XX19					DB	0				; page 0 &67
 123+ 66F3              ; MOVED TO Universe XX20					DB	0				; page 0 &67 also used as XX19+1 for XX19 being a word
 124+ 66F3              ;DEFUNCT EQUATE NormalCountCopyBy4		equ	XX20			; Also used for normal * 4 holding variable
 125+ 66F3 00           XX21					DB  0				; this may be part of XX20/xx21 accordign to spawn new shipXX21		DW	0				; Ah XX21 is hull pointer  hull pointer lo as it can;t hold HULLINDX as 16bit array
 126+ 66F4              ;XX21 is the pointer table to the pages for ship types. this will be repalaced by paging so just need an equate for first page
 127+ 66F4
 128+ 66F4
 129+ 66F4 00           QQ17					DB	0				;   72
 130+ 66F5 00           XX18xlo                 DB  0               ;	72		XX18   xlo
 131+ 66F6 00           XX18xhi                 DB  0               ;	73		XX18+1 xhi
 132+ 66F7 00           XX18xsg                 DB  0               ;	74		XX18+2 xsgn
 133+ 66F8 00           XX18ylo                 DB  0               ;	75		XX18   ylo
 134+ 66F9 00           XX18yhi                 DB  0               ;	76		XX18+1 yhi
 135+ 66FA 00           XX18ysg                 DB  0               ;	77		XX18+2 ysgn
 136+ 66FB 00           XX18zlo                 DB  0               ;	78		XX18   zlo
 137+ 66FC 00           XX18zhi                 DB  0               ;	79		XX18+1 zhi
 138+ 66FD 00           XX18zsg                 DB  0               ;	7A		XX18+2 zsgn
 139+ 66FE
 140+ 66FE 28           SHIPMAXSPEED            DB  40              ; variable to facilitate ship editing later
 141+ 66FF 00           DELTA					DB 	0				; 7D 		DELTA  \ bpl -2 inserted here to stall from title code if byte check fails
 142+ 6700 00           DELT4Lo					DB 	0				; 7E
 143+ 6701 00           DELT4Hi					DB 	0				; 7F
 144+ 6702              DELTA4                  equ                 DELT4Lo
 145+ 6702
 146+ 6702              ; SoundFX Variables -------------------------------------------------------------------------------------------
 147+ 6702              ;DEFUNCT, uses DELTA/ LAST_DELTAEngineSoundChanged:     DB  0
 148+ 6702 FF           SoundFxToEnqueue        DB  $FF             ; $FF No sound to enque,if it is $FF then next sound will not get enqued
 149+ 6703 00           InterruptCounter        DB 0                ; simple marker updated once per IM2 event
 150+ 6704
 151+ 6704
 152+ 6704              ; Not thise must be in this order else 16 bit fetches will fail
 153+ 6704 00           varU                    DB  0               ;   80
 154+ 6705 00           varQ					DB  0 				;	81
 155+ 6706 00           varR					DB  0 				;	82
 156+ 6707 00           varS					DB  0 				;	83
 157+ 6708              varRS                   equ varR
 158+ 6708
 159+ 6708 00 00        varU16                  DW  0               ; 16 bit variant on varU as I can't use above for this
 160+ 670A
 161+ 670A 00           XSAV					DB	0				; 84	   XSAV usef for nearby ship count outer
 162+ 670B 00           YSAV                    DB  0               ; 85
 163+ 670C 00           XX17					DB	0				; 86
 164+ 670D              RequiredScale			equ  XX17			; use to hold calculated scale in drawing ship
 165+ 670D              varXX17                 equ  XX17
 166+ 670D 00           ScreenChanged           DB  0
 167+ 670E 00           ScreenIndex             DB  0
 168+ 670F 00 00        ScreenIndexTablePointer DW  0
 169+ 6711 00           InvertedYAxis           DB  0
 170+ 6712 00           MenuIdMax				DB	0				;	87		MenuIdMax		QQ11
 171+ 6713              											; Bit 7 Set  ShortRangeChart    $80
 172+ 6713              											; Bit 6 Set  Galactic Chart     $40
 173+ 6713              											; Bit 5 Set  Market Place       $20
 174+ 6713              											; Bit 4 Set  Status Screen      $10
 175+ 6713              											; Bit 3 Set  Display Inventory  $08
 176+ 6713                                                          ; Bit 2 Set  Planet Data        $04
 177+ 6713                                                          ; View bit combinations if the ones above not matched
 178+ 6713                                                          ; bits 1 0
 179+ 6713                                                          ;      1 1  Front view , i.e. $03
 180+ 6713                                                          ;      1 0  Aft View          $02
 181+ 6713                                                          ;      0 1  Left View         $01
 182+ 6713                                                          ;      0 0  Right view        $00
 183+ 6713              											; Bit 0 Set  Data On System
 184+ 6713              											; 0  Space View (Not a menu)
 185+ 6713 00           ZZDust					DB	0				;	88		ZZDust (Poss 16 bit need to check)
 186+ 6714 00           XX13                    DB  0               ;   89
 187+ 6715 00           TYPE					DB	0				; 8C used for ship type in drawing
 188+ 6716              ;Docked flag = 00 = in free space
 189+ 6716              ;              FF = Docked
 190+ 6716              ;              FE = transition
 191+ 6716              ;              FD = Setup open space and transition to not docked
 192+ 6716              ;              FC = Hyperspace manimation
 193+ 6716              ;              FB = Hyperspace complete
 194+ 6716 00           varSWAP                 DB  0               ; 90 , general purpose swap variable
 195+ 6717 00           varCNT                  DB  0               ; 93
 196+ 6718
 197+ 6718 00           varK					DB	0				; 40
 198+ 6719 00           varKp1					DB	0				; 41
 199+ 671A 00           varKp2					DB	0				; 42
 200+ 671B 00           varKp3					DB	0				; 43
 201+ 671C
 202+ 671C 00           varK2                   DB  0               ; 9B
 203+ 671D 00           varK2p1                 DB  0               ; 9C K2 plus 1
 204+ 671E 00           varK2p2                 DB  0               ; 9D K2 plus 2
 205+ 671F 00           varK2p3                 DB  0               ; 9E K2 plus 3
 206+ 6720
 207+ 6720 00           Point                   DB  0               ; 9F      POINT
 208+ 6721
 209+ 6721 00           varT					DB	0				; D1
 210+ 6722 00           varTSign                DB  0               ; for teh odd need for a 16 bit varT
 211+ 6723
 212+ 6723 00 00 00...  varVector9ByteWork      DS  9
 213+ 672C
 214+ 672C 00 00 00 00  varK3					DS	4				; D2
 215+ 6730 00           varK3p2					DB	0				; 42
 216+ 6731 00           varK3p3					DB	0				; 43
 217+ 6732              varK3p1					equ varK3+1			; D3
 218+ 6732 00 00 00 00  varK4					DS	4				; E0
 219+ 6736              varK4p1					equ varK4+1			; D3
 220+ 6736 00 00 00...  varK5                   DS  6
 221+ 673C              varK5p2                 equ varK5+2
 222+ 673C 00 00 00...  varK6                   DS  6
 223+ 6742              varK6p2                 equ varK6+2
 224+ 6742              ;Heap
 225+ 6742
 226+ 6742 00 00        HeapStart				DS	2				; &0100 XX3 50 bytes for now
 227+ 6744 00 00 00...  HeapData				DS	50
 228+ 6776              ; Contains 				X 16 bit, Y ;MissileArmedStatus		DB	0				; 0344 MSAR   using MissileTarget, if missile is not armed tehn target is FF
 229+ 6776              ; TODO will need an read for a list of missiles, who they are targeting an the target current vector for AI persuit
 230+ 6776              ; i.e. a list of programmed missiles in universe slot list code
 231+ 6776 00 00 00...  DampingKeys				DS  7				; 0387 - 038D
 232+ 677D              ;  #&6 Does K toggle keyboard/joystick control -  03CD certainly makes keyboard not work anymore.
 233+ 677D              ;  #&5 Does J reverse both joystick channels
 234+ 677D              ;  #&4 Does Y reverse joystick Y channel			03CB
 235+ 677D              ;  #&2 Does X toggle startup message display ? PATG?	03C9
 236+ 677D              ;  #&3 Does F toggle flashing information			03CA
 237+ 677D              ;  #&1 Does A toggle keyboard auto-recentering ?
 238+ 677D              ;  #&0 Caps-lock toggles keyboard flight damping
 239+ 677D
 240+ 677D              ;-- Galaxy and Universe Variables ----------------------------------------------------------------------------------------------------
 241+ 677D 00 00 00...  SystemSeed				DS  5				;	6C		QQ15	Current Galaxy Seed
 242+ 6782 00 00 00...  StockAvaliabiliy		DS 	16				; 038D - 039C Stock inventory in station
 243+ 6792 00           AlienItemsAvaliability  DB	0				; 039D
 244+ 6793 00           RandomMarketSeed		DB	0				; 039E   \ QQ26	\ random byte for each system vist (for market)
 245+ 6794 00           Galaxy      			DB	0				; 0367 Galaxy (incremented with galactiv drive
 246+ 6795 00 00 00...  WorkingSeeds			DS	6
 247+ 679B 00 00 00...  PresentSystemSeeds		DS	6				; 03B2 - 03B7
 248+ 67A1 00 00 00...  GalaxySeeds				DS	6				; 035B - 0360 QQ21
 249+ 67A7 00           PresentSystemX			DB	0				; System we are currently in
 250+ 67A8 00           PresentSystemY			DB  0				; System we are currently in
 251+ 67A9 00           TargetSystemX			DB	0				; System we are targeting for jump
 252+ 67AA 00           TargetSystemY			DB	0				; System we are targeting for jump
 253+ 67AB              ; --- Current System Data ------------------------------------------------------------------------------------------------------------
 254+ 67AB 00           GovPresentSystem		DB	0				; 03AE Govenment
 255+ 67AC 00           TekPresentSystem		DB	0				; 03AF Technology
 256+ 67AD 00           SpaceStationSafeZone    DB  0               ; Flag to determine if we are in safe zone
 257+ 67AE 00           ExtraVesselsCounter     DB  0
 258+ 67AF 00           JunkCount				DB  0				; $033E
 259+ 67B0 00           AsteroidCount           DB  0               ; Not used as yet
 260+ 67B1 00           TransporterCount        DB  0
 261+ 67B2 00           CopCount                DB  0
 262+ 67B3 00           PirateCount             DB  0
 263+ 67B4              ;- commander and ship state variables ------------------------------------------------------------------------------------------------
 264+ 67B4 00           NbrMissiles				DB	0				; 038B	Does this clash with Dampingkeys?
 265+ 67B5 00           PlayerECMActiveCount    DB  0               ; Countdown for player ECM
 266+ 67B6 00           FugitiveInnocentStatus	DB	0				; 038C	FIST
 267+ 67B7 00 00        KillTally  				DW	0				; 039F - 03A0 \ TALLY   \ kills lo hi
 268+ 67B9 00           CurrentRank             DB  0   			;
 269+ 67BA 00           MarketPrice				DB	0				; 03AA QQ24
 270+ 67BB 00           MaxStockAvaliable		DB  0				; 03AB   \ QQ25     \ max available
 271+ 67BC 00           SystemEconomy			DB  0				; 03AC \ QQ28   \ the economy byte of present system (0 is Rich Ind.)
 272+ 67BD 00           CargoItem				DB	0				; 03AD (I think its item type just scooped) QQ29
 273+ 67BE 00 00        ShipLineStackPointer	DW	0				; 03B0 & 03B1 ship Lines pointer reset to top LS% = &0CFF (make DW for z80 and direct hl pointer)
 274+ 67C0              											; this is ship lines stack pointer so may be redundant with paging
 275+ 67C0              											; LS = line stack so we will have one for now to remove later
 276+ 67C0              ; - no longer used, holding here intil its safe to delte
 277+ 67C0 00           MCH						DB	0				; 03A4  \ MCH  \ old message to erase
 278+ 67C1 00           COMP     				DB	0				; 03A1 2nd competion byte used for save integrity checks?
 279+ 67C2              ; not needed as we don't do security on file COK						DB	0				; 0366 Competition Byte what ? Does some file check and accelleration check
 280+ 67C2              ; - no longer used, holding here intil its safe to delte
 281+ 67C2
 282+ 67C2 00           DisplayEcononmy			DB	0				; 03B8
 283+ 67C3 00           DisplayGovernment		DB  0				; 03B9 Is it target? 03B9 \ QQ4	 \ Government, 0 is Anarchy.
 284+ 67C4 00           DisplayTekLevel			DB	0				; 03BA   \ QQ5	\ Tech
 285+ 67C5 00 00        DisplayPopulation		DW	0				; 03BB \ QQ6  \ population*10
 286+ 67C7 00 00        DisplayProductivity		DW	0				; 03BD \ QQ7   \ productivity*10
 287+ 67C9 00 00        Distance          		DW	0				; 03BE \ QQ8 distince in 0.1LY units
 288+ 67CB 00 00        DisplayRadius			DW	0
 289+ 67CD              ; --- Used in creation of sun and planet and working out ship AI for travel direction ---------------------------------------------------
 290+ 67CD 00 00 00     ParentPlanetX           DS  3               ; used when spawining space station to determine origin
 291+ 67D0 00 00 00     ParentPlanetY           DS  3               ; provisioned for 24 bit values
 292+ 67D3 00 00 00     ParentPlanetZ           DS  3               ; probably later on make station position an equate to planet
 293+ 67D6 00 00 00     PlanetXPos              DS  3               ; .
 294+ 67D9 00 00 00     PlanetYPos              DS  3               ; .
 295+ 67DC 00 00 00     PlanetZPos              DS  3               ; .
 296+ 67DF 00 00 00     PlanetType              DS  3               ; .
 297+ 67E2 00 00 00     SunXPos                 DS  3               ; .
 298+ 67E5 00 00 00     SunYPos                 DS  3               ; .
 299+ 67E8 00 00 00     SunZPos                 DS  3               ; .
 300+ 67EB 00 00 00     StationXPos             DS  3               ; .
 301+ 67EE 00 00 00     StationYPos             DS  3               ; .
 302+ 67F1 00 00 00     StationZPos             DS  3               ; .
 303+ 67F4 00 00        DirectionVectorX        DS  2               ; Direction vector from one point to another
 304+ 67F6 00 00        DirectionVectorY        DS  2               ; .
 305+ 67F8 00 00        DirectionVectorZ        DS  2               ; .
 306+ 67FA              ; -- Current Missile Runbtime data ------------------------------------------------------------------------------------------------
 307+ 67FA 00           CurrentMissileBank:     DB      0                                   ; used by missile logic as local copy of missile bank number
 308+ 67FB 00 00        MissileXPos             DW      0
 309+ 67FD 00           MissileXSgn             DB      0
 310+ 67FE 00 00        MissileYPos             DW      0
 311+ 6800 00           MissileYSgn             DB      0
 312+ 6801 00 00        MissileZPos             DW      0
 313+ 6803 00           MissileZSgn             DB      0
 314+ 6804 00 00        CurrentTargetXpos       DS      2
 315+ 6806 00 00        CurrentTargetXsgn       DS      2
 316+ 6808 00 00        CurrentTargetYpos       DS      2
 317+ 680A 00 00        CurrentTargetYsgn       DS      2
 318+ 680C 00 00        CurrentTargetZpos       DS      2
 319+ 680E 00 00        CurrentTargetZsgn       DS      2
 320+ 6810 00 00        TargetVectorXpos        DS      2
 321+ 6812 00           TargetVectorXsgn        DS      1
 322+ 6813 00 00        TargetVectorYpos        DS      2
 323+ 6815 00 00        TargetVectorYsgn        DS      2
 324+ 6817 00 00        TargetVectorZpos        DS      2
 325+ 6819 00 00        TargetVectorZsgn        DS      2
 326+ 681B 00           CurrentMissileBlastRange:      DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 327+ 681C 00           CurrentMissileBlastDamage:     DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 328+ 681D 00           CurrentMissileDetonateRange:   DB  0                       ; TODO Initi for runtime copied in when setting up a missile, allows for proximity missiles
 329+ 681E 00           CurrentMissileDetonateDamage:  DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 330+ 681F              ; --- Spawn Probability Table ---------------------------------------------------------------------------------------------------
 331+ 681F 00 00 00...  SpawnLowVssalue         DS 6                                ; Maxium of 6 entries in table
 332+ 6825 00 00 00...  SpawnHighvalue          DS 6                                ; Maxium of 6 entries in table
 333+ 682B 00 00 00...  ShipClassId             DS 6
 334+ 6831              ; --- Space dust ----------------------------------------------------------------------------------------------------------------
 335+ 6831 00 00 00...  varDustWarpRender       DS MaxNumberOfStars * 2 ; Copy of base positions for warp
 336+ 6847 00 00 00...  varDust                 DS MaxNumberOfStars * 6
 337+ 6889 00 00 00...  varDustSceen            DS MaxNumberOfStars * 2 ; To optimise star list to wipe from screen
 338+ 689F 00           varStarX                DB 0
 339+ 68A0 00           varStarY                DB 0
 340+ 68A1 00 00 00...  varDustX                DS MaxNumberOfStars *2
 341+ 68B7 00 00 00...  varDustY                DS MaxNumberOfStars *2
 342+ 68CD 00 00 00...  varDustZ                DS MaxNumberOfStars *2
 343+ 68E3              ; --- Main Loop Data -------------------------------------------------------------------------------------------------------------
 344+ 68E3 00           DockedFlag				DB	0				; 8E -
 345+ 68E4 00           GamePaused              DB  0
 346+ 68E5 00           CurrentUniverseAI       DB  0               ; current ship unviverse slot due an AI update
 347+ 68E6 00           SelectedUniverseSlot    DB  0
 348+ 68E7 00           SetStationHostileFlag   DB  0               ; used to semaphore angry space station
 349+ 68E8 00           ShipBlastCheckCounter   DB  0
 350+ 68E9 00           InnerHyperCount			DB 	0				; 2F QQ22+1 (will move to a CTC timer later)
 351+ 68EA 00           OuterHyperCount			DB 	0				; 2E QQ22
 352+ 68EB 00           WarpCooldown            DB  0
 353+ 68EC 00           EventCounter            DB  0
 354+ 68ED 00           HyperCircle             DB  0
 355+ 68EE 00           MissJumpFlag            DB  0
 356+ 68EF 00           PlayerMisJump			DB	0				; $0341 witchspace misjump
 357+ 68F0 00           HyperSpaceFX			DB	0				; 0348 HFX (probabyl BBC specific
 358+ 68F1 00           ExtraVessels			DB	0				; 0349 EV Use d by cops, extra vessels still to spawn?
 359+ 68F2 00           Delay					DB	0				; 034A Delay general purpose eg. spawing EV or when printign messages
 360+ 68F3 00           CurrentMissileCheck:    DB  0               ; if > Universe Slot list then free for next missile
 361+ 68F4 00           MessageForDestroyed		DB	0				; 034B Message flag for item + destroyed
 362+ 68F5              UniverseSlotListSize    equ	12
 363+ 68F5 00 00 00...  UniverseSlotList        DS  UniverseSlotListSize
 364+ 6901 00 00 00...  UniverseSlotType        DS  UniverseSlotListSize ; base type, e.g. missile, cargo etc,
 365+ 690D              ; Probably not needed UniverseTypeCount       DS  UniverseSlotListSize
 366+ 690D 05           ConsoleRefreshCounter   DB  ConsoleRefreshInterval ; Every 4 interations the console will update twice (once for primary and once for seconday buffer)
 367+ 690E 00           ConsoleRedrawFlag       DB  0
 368+ 690F 00           TextInputMode           DB  0
 369+ 6910 00           CursorKeysPressed       DB  0               ; mapping of the current key presses
 370+ 6911                                                          ; 7    6    5    4     3    2        1    0
 371+ 6911                                                          ; Up   Down Left Right Home Recentre
 372+ 6911 00           FireLaserPressed        DB  0
 373+ 6912 00           WarpPressed             DB  0
 374+ 6913 00           CompassColor			DB	0				; 03C5
 375+ 6914 00           SoundToggle				DB	0				; 03C6
 376+ 6915 00           KeyboardRecenterToggle	DB	0				; 03C8
 377+ 6916 00           PATGMask				DB	0				; &03C9    \ PATG	\ Mask to scan keyboard X-key, for misjump
 378+ 6917 00           FlashToggle				DB  0				; 03CA \ FLH \ flash toggle
 379+ 6918 00           ReverseJoystick			DB	0				; 03CB \ JSTGY \ Y reverse joystick Y channel
 380+ 6919 00           JoystickToggle			DB	0				; 03CD  \ JSTK    \ K toggle keyboard/joystick
 381+ 691A 00           DigitalJoystick			DB	0				; 03CE \ JDB   \ . = toggle between keyboard and bitpaddle
 382+ 691B 00           DiskReadFailFlag		DB	0				; 03CF \ CATF \ Disk catalog fail flag
 383+ 691C
 384+ 691C              ; Working Data
 385+ 691C
 386+ 691C              ;UniverseTable			DS	26				; 1741  \ address pointers for 13 ships INF on pages &9. 37 bytes each.
 387+ 691C              ; $0900 =	EQUW page9+37* 0 \ copied to inner worskpace INWK on zero-page when needed
 388+ 691C              ; $0925 =	EQUW page9+37* 1
 389+ 691C              ; $094A =	EQUW page9+37* 2
 390+ 691C              ; $096F =	EQUW page9+37* 3
 391+ 691C              ; $0994 =	EQUW page9+37* 4
 392+ 691C              ; $09B9 =	EQUW page9+37* 5
 393+ 691C              ; $09DE =	EQUW page9+37* 6
 394+ 691C              ; $0A03 =	EQUW page9+37* 7
 395+ 691C              ; $0A28 =	EQUW page9+37* 8
 396+ 691C              ; $0A4D =	EQUW page9+37* 9
 397+ 691C              ; $0A72 =	EQUW page9+37*10
 398+ 691C              ; $0A97 =	EQUW page9+37*11
 399+ 691C              ; $0ABC =	EQUW page9+37*12 \ allwk up to &0ABC while heap for edges working down from &CFF.
 400+ 691C
 401+ 691C
 402+ 691C
 403+ 691C              ; 0b00 is start address of data to save
 404+ 691C              ; Now MissionData VarTP					DB	0				; 0358 TP? The Plan  \ mission uses lower 4 bits
 405+ 691C              											; Bit mask XXXX10XX - Thargoid plan mission
 406+ 691C
 407+ 691C 00           MissionData				DB	0				; &0B00	  \ look at data, first byte is TP mission bits
 408+ 691D
 409+ 691D 00 00        FileNameStringPointer	DW	0				;0C00	   \ pointer to filename string
 410+ 691F 00 00        CommanderLoadAddress	DW	0				;0C03
 411+ 6921 00 00        LengthOfFile			DW	0				;0C0B
 412+ 6923 00 00        SaveDataEndAddress		DW	0				;&0C0F	      \ &0C00 is end address of data to save
 413+ 6925              LineBuffer:                                ; needs to be 5 * 255 ideally
 414+ 6925 00 00 00...  EdgesBuffer				DS 50
 415+ 6957              EdgesBufferSP			equ	$				; Was $0CFF			; Heap pointer for edges buffer
 416+ 6957              ShipLinesBufferSP		equ EdgesBufferSP	; was $0CFF
 417+ 6957
 418+ 6957 00 00 00...  ShipLineStack			DS  70			; For now but will be in the page later
 419+ 699D              ShipLineStackTop		equ $ - ShipLineStack
 420+ 699D
 421+ 699D              ; No longer needed
 422+ 699D              ;LSO						DS 	$C0				;0E00 Line Buffer Solar of 192 lines (may be 191 in reality)
 423+ 699D              ; LSX vector overlaps with LSO
 424+ 699D              ;LSX2					DS	$C0				; &0EC0	    \ LSX2 bline buffer size?
 425+ 699D              ;LSY2					DS  $C)	           	; &0F0E	    \ LSY2
 426+ 699D
 427+ 699D              ; -- Player Runtime Data
 428+ 699D 00           GunTemperature          DB  0
 429+ 699E 00           CabinTemperature        DB  0
 430+ 699F 00           PlayerForwardSheild0	DB	0 ; ?????
 431+ 69A0 00           PlayerForwardSheild1    DB	0
 432+ 69A1 00           PlayerForwardSheild2    DB	0
 433+ 69A2 00           ForeShield				DB	0				; These three must be contiguous
 434+ 69A3 00           AftShield				DB	0				; .
 435+ 69A4 00           PlayerEnergy			DB	0				; and in this order
 436+ 69A5 00           CompassX				DB	0				; 03A8
 437+ 69A6 00           CompassY				DB	0				; 03A9
 438+ 69A7              ; Simplification of missile targetting
 439+ 69A7              ; $FF no missile targettting enabled
 440+ 69A7              ; $FE missile targetting, no target selected
 441+ 69A7              ; bit 7 set then tagetting and lower nibble holds missile target and launching
 442+ 69A7              ; bit 7 clear launch at selected target in lower nibble
 443+ 69A7 00           MissileTargettingFlag   DB  0
 444+ 69A8              ;;MissileTarget			DB  0				; 45
 445+ 69A8              ;;MissileLaunchFlag       DB  0
 446+ 69A8 00 00 00...  CommanderName           DS  15
 447+ 69B7 00           CommanderName0			DB	0				; Sneaky little 0 to allow use of print name directly
 448+ 69B8 00           BadnessStatus           DB  0
 449+ 69B9              ;note rapidly changing views could reset these so need to consider it in an array
 450+ 69B9              ; LaserType
 451+ 69B9              ; LaserPulseRate                          ; how many pulses can be fired before long pause
 452+ 69B9              ; LaserPulsePause                         ; time before next pulse - 0 = beam
 453+ 69B9              ; LaserPulseRest                          ; time before pulse count resets to 0
 454+ 69B9              ; LaserDamageOutput                       ; amount of damage for a laser hit
 455+ 69B9              ; LaserEnergyDrain                        ; amount of energy drained by cycle
 456+ 69B9              ; LaserHeat                               ; amount of heat generated
 457+ 69B9              ; LaserDurability                         ; probabability out of 255 that a hit on unshielded will add random amount of damage
 458+ 69B9              ; LaserDurabilityAmount                   ; max amount of damagage can be sustained in one damage hit
 459+ 69B9              ; LaserInMarkets                          ; can this laser be purchased 0 = yes 1 = no
 460+ 69B9              ; LaserTechLevel                          ; minimum tech level system to buy from
 461+ 69B9              ; need to add copy table routines
 462+ 69B9 00           CurrLaserType           DB  0               ; current view laser type, copied in from LaserType array
 463+ 69BA 00           CurrLaserDamage         DB  0               ; copied in from LaserDamagedFlag array
 464+ 69BB 00           CurrLaserPulseRate      DB  0               ; current view laser amount of pulses
 465+ 69BC 00           CurrLaserPulseOnTime    DB  0               ; how many cycles the laser is on
 466+ 69BD 00           CurrLaserPulseOffTime   DB  0               ; how many cycles the laser is on
 467+ 69BE 00           CurrLaserPulseRest      DB  0               ; current view laser delay setup between pulses
 468+ 69BF
 469+ 69BF                  IFDEF LASER_V2
 470+ 69BF 00           LaserBeamOn             DB  0
 471+ 69C0 00           CurrLaserDuration       DB  0   ; == CurrLaserPulseOnTime
 472+ 69C1 00           CurrentBurstPause       DB  0   ; == CurrLaserPulseOffTime
 473+ 69C2 00           CurrentCooldown         DB  0   ; == CurrLaserPulseRest
 474+ 69C3                  ENDIF
 475+ 69C3 00           CurrLaserBurstRate      DB  0
 476+ 69C4 00           CurrLaserBurstCount     DB  0   ; == LaserPulseRate
 477+ 69C5 00           CurrLaserDamageOutput   DB  0
 478+ 69C6 00           CurrLaserEnergyDrain    DB  0
 479+ 69C7 00           CurrLaserHeat           DB  0
 480+ 69C8 00           CurrLaserDurability     DB  0
 481+ 69C9 00           CurrLaserDurabilityAmount DB  0
 482+ 69CA
 483+ 69CA              ; Count down timers must be aligned like this to work
 484+ 69CA 00           CurrLaserPulseOnCount   DB  0               ; how many cycles the laser is on timer
 485+ 69CB 00           CurrLaserPulseOffCount  DB  0               ; how many cycles the laser is on timer
 486+ 69CC 00           CurrLaserPulseRestCount DB  0               ; countdown after shooting for next shot
 487+ 69CD 00           CurrLaserPulseRateCount DB  0               ; current view laser current pulses fired
 488+ 69CE
 489+ 69CE              ; -- Input variables
 490+ 69CE 00           JoystickX				DB	0				; 034C JSTX
 491+ 69CF 00           JoystickY				DB	0				; 034D JSTY
 492+ 69D0 00           XSAV2 					DB	0				; 034E used to temporary save 6502 X reg
 493+ 69D1 00           YSAV2 					DB	0				; 034F used to temporary save 6502 Y reg
 494+ 69D2
 495+ 69D2              ; -- Console drawing data
 496+ 69D2              FShieldStart            equ $8410
 497+ 69D2              AShieldStart            equ $8D10
 498+ 69D2              FuelStart               equ $9410
 499+ 69D2
 500+ 69D2              EnergyBar4Start         equ $A5D5
 501+ 69D2              EnergyBar3Start         equ $ADD5
 502+ 69D2              EnergyBar2Start         equ $B5D5
 503+ 69D2              EnergyBar1Start         equ $BDD5
 504+ 69D2              ; 70 /2 = 35 values
 505+ 69D2              ;                            0                             1                             2                             3
 506+ 69D2              ;                            0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6
 507+ 69D2 01 02 02 03  FuelMapping             DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,19,20,21,21,22,23,24,25,26,27,28,30,31,31
 507+ 69D6 04 04 05 06
 507+ 69DA 06 07 08 09
 507+ 69DE 0A 0A 0B 0C
 507+ 69E2 0D 0E 0E 0F
 507+ 69E6 10 10 11 13
 507+ 69EA 14 15 15 16
 507+ 69EE 17 18 19 1A
 507+ 69F2 1B 1C 1E 1F
 507+ 69F6 1F
 508+ 69F7              SpeedoStart             equ $84D1
 509+ 69F7              ;                            0                             1                             2                             3                             4
 510+ 69F7              ;                            0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0
 511+ 69F7 01 02 02 03  SpeedoMapping           DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,18,19,20,20,21,22,23,24,24,25,26,26,27,28,28,29,30,31
 511+ 69FB 04 04 05 06
 511+ 69FF 06 07 08 09
 511+ 6A03 0A 0A 0B 0C
 511+ 6A07 0D 0E 0E 0F
 511+ 6A0B 10 10 11 12
 511+ 6A0F 13 14 14 15
 511+ 6A13 16 17 18 18
 511+ 6A17 19 1A 1A 1B
 511+ 6A1B 1C 1C 1D 1E
 511+ 6A1F 1F
 512+ 6A20
 513+ 6A20              DialMiddleXPos          equ $E1
 514+ 6A20              RollMiddle              equ $8CE0
 515+ 6A20              PitchMiddle             equ $94E0
 516+ 6A20
 517+ 6A20
 518+ 6A20
 519+ 6A20
 520+ 6A20
# file closed: ../../Variables/general_variables.asm
 654  6A20                  ;NCLUDE "../../Variables/general_variablesRoutines.asm"
 655  6A20                  INCLUDE "../../Variables/UniverseSlotRoutines.asm"
# file opened: ../../Variables/UniverseSlotRoutines.asm
   1+ 6A20              ; Note this code is core code and can not be in a memory bank unless do explosion code is changed too
   2+ 6A20 AF           ClearSlotCount:         xor     a
   3+ 6A21 21 F5 68                             ld      hl,UniverseSlotList
   4+ 6A24 06 0C                                ld      b, UniverseSlotListSize ; prbably not needed + UniverseSlotTypeSize
   5+ 6A26 77           .fillLoop:              ld      (hl),a
   6+ 6A27 23                                   inc     hl
   7+ 6A28 10 FC                                djnz    .fillLoop
   8+ 6A2A C9                                   ret
   9+ 6A2B
  10+ 6A2B              ; Initialises all types to a count of 1 where there is an occupied universe slot
  11+ 6A2B              ; this needs expanding to cater for a missing type, find type and increment count (use cpir?)
  12+ 6A2B              ; DOE NOT WORK CorrectSlotCount:       call    ClearSlotCount
  13+ 6A2B              ; DOE NOT WORK                         ld      hl,UniverseSlotCount
  14+ 6A2B              ; DOE NOT WORK                         ld      de,UniverseSlotList
  15+ 6A2B              ; DOE NOT WORK                         ld      b,UniverseSlotListSize
  16+ 6A2B              ; DOE NOT WORK .fillLoop:              ld      a,(de)
  17+ 6A2B              ; DOE NOT WORK                         cp      $FF
  18+ 6A2B              ; DOE NOT WORK                         jr      z,.SkipSlot
  19+ 6A2B              ; DOE NOT WORK .CorrectSlot:           ld      (hl),a
  20+ 6A2B              ; DOE NOT WORK                         inc     hl
  21+ 6A2B              ; DOE NOT WORK                         ld      (hl),1
  22+ 6A2B              ; DOE NOT WORK                         inc     hl
  23+ 6A2B              ; DOE NOT WORK                         inc     hl
  24+ 6A2B              ; DOE NOT WORK .SkipSlot               inc     de
  25+ 6A2B              ; DOE NOT WORK                         djnz    .fillLoop
  26+ 6A2B C9                                   ret
  27+ 6A2C              ; Wipe all items
  28+ 6A2C 3E FF        ClearUnivSlotList:      ld      a,$FF
  29+ 6A2E 21 F5 68                             ld      hl,UniverseSlotList
  30+ 6A31 06 18                                ld      b, UniverseSlotListSize * 2
  31+ 6A33 77           .fillLoop:              ld      (hl),a
  32+ 6A34 23                                   inc     hl
  33+ 6A35 10 FC                                djnz    .fillLoop
  34+ 6A37 C9                                   ret
  35+ 6A38
  36+ 6A38 21 F5 68     SetSlot0ToSpaceStation: ld      hl,UniverseSlotList
  37+ 6A3B 36 02                                ld      (hl),ShipTypeStation
  38+ 6A3D 21 01 69                             ld      hl,UniverseSlotType
  39+ 6A40 36 02                                ld      (hl),ShipTypeStation
  40+ 6A42 C9                                   ret
  41+ 6A43
  42+ 6A43 21 F5 68     SetSlotAToTypeB:        ld      hl,UniverseSlotList
  43+ 6A46 ED 31                                add     hl,a
  44+ 6A48 70                                   ld      (hl),b
  45+ 6A49 C9                                   ret
  46+ 6A4A
  47+ 6A4A 21 01 69     SetSlotAToClassB:       ld      hl,UniverseSlotType
  48+ 6A4D ED 31                                add     hl,a
  49+ 6A4F 70                                   ld      (hl),b
  50+ 6A50 C9                                   ret
  51+ 6A51
  52+ 6A51              ; Clears all except slot A, used when say restarting a space station post launch
  53+ 6A51 57           ClearFreeSlotListSaveA: ld      d,a
  54+ 6A52 0E 00                                ld      c,0
  55+ 6A54 21 F5 68                             ld      hl,UniverseSlotList
  56+ 6A57 06 18                                ld      b, UniverseSlotListSize * 2
  57+ 6A59 79           .fillLoop:              ld      a,c
  58+ 6A5A BA                                   cp      d
  59+ 6A5B 28 03                                jr      z,.SkipSlot
  60+ 6A5D 3E FF                                ld      a,$FF
  61+ 6A5F 77                                   ld      (hl),a
  62+ 6A60 23           .SkipSlot:              inc     hl
  63+ 6A61 23                                   inc     hl
  64+ 6A62 10 F5                                djnz    .fillLoop
  65+ 6A64 C9                                   ret
  66+ 6A65
  67+ 6A65 21 F5 68     ClearSlotA:             ld      hl,UniverseSlotList
  68+ 6A68 ED 31                                add     hl,a
  69+ 6A6A 36 FF                                ld      (hl),$FF
  70+ 6A6C 3E 0C                                ld      a,UniverseSlotListSize  ; move to types
  71+ 6A6E ED 31                                add     hl,a
  72+ 6A70 36 FF                                ld      (hl),$FF
  73+ 6A72 C9                                   ret
  74+ 6A73
  75+ 6A73              ; Space Station will always be slot 0
  76+ 6A73 21 02 69     ClearJunk:              ld      hl,UniverseSlotType+1
  77+ 6A76 0E 01                                ld      c,1
  78+ 6A78 06 0B                                ld      b,UniverseSlotListSize -1      ; ignore space station
  79+ 6A7A 7E           .NextShip:              ld      a,(hl)
  80+ 6A7B FE 03                                cp      ShipTypeJunk
  81+ 6A7D CA 8E 6A                             jp      z,.ProcessJunk
  82+ 6A80 FE 04                                cp      ShipTypeScoopable
  83+ 6A82 CA 8E 6A                             jp      z,.ProcessJunk
  84+ 6A85 23           .DoneIteration:         inc     hl
  85+ 6A86 0C                                   inc     c
  86+ 6A87 10 F1                                djnz    .NextShip
  87+ 6A89                                      ClearJunkCount
  87+ 6A89             >                        ZeroA
  87+ 6A89 AF          >                        xor a
  87+ 6A8A 32 AF 67    >                        ld      (JunkCount),a
  88+ 6A8D C9                                   ret
  89+ 6A8E 79           .ProcessJunk:           ld      a,c
  90+ 6A8F CD 65 6A                             call    ClearSlotA
  91+ 6A92 C3 85 6A                             jp      .DoneIteration
  92+ 6A95
  93+ 6A95
  94+ 6A95 21 02 69     WarpJunk:               ld      hl,UniverseSlotType+1
  95+ 6A98 0E 01                                ld      c,1
  96+ 6A9A 06 0B                                ld      b,UniverseSlotListSize -1      ; ignore space station
  97+ 6A9C 7E           .NextShip:              ld      a,(hl)
  98+ 6A9D FE 03                                cp      ShipTypeJunk
  99+ 6A9F CA AC 6A                             jp      z,.ProcessJunk
 100+ 6AA2 FE 04                                cp      ShipTypeScoopable
 101+ 6AA4 CA AC 6A                             jp      z,.ProcessJunk
 102+ 6AA7 23           .DoneIteration:         inc     hl
 103+ 6AA8 0C                                   inc     c
 104+ 6AA9 10 F1                                djnz    .NextShip
 105+ 6AAB C9                                   ret
 106+ 6AAC 79           .ProcessJunk:           ld      a,c
 107+ 6AAD                                      MMUSelectUniverseA
 107+ 6AAD C6 46       >                     add    a,BankUNIVDATA0
 107+ 6AAF ED 92 56    >                     nextreg UniverseMMU,       a
 108+ 6AB2 CD 9D C6                             call    WarpOffset
 109+ 6AB5 C3 A7 6A                             jp      .DoneIteration
 110+ 6AB8
 111+ 6AB8 21 02 69     AreShipsPresent:        ld      hl,UniverseSlotType+1
 112+ 6ABB 06 0B                                ld      b,UniverseSlotListSize -1      ; ignore space station
 113+ 6ABD 7E           .NextShip:              ld      a,(hl)
 114+ 6ABE FE 00                                cp      ShipTypeNormal
 115+ 6AC0                                      ClearCarryFlag
 115+ 6AC0 B7          >                        or a
 116+ 6AC1 C8                                   ret     z
 117+ 6AC2 23                                   inc     hl
 118+ 6AC3 10 F8                                djnz    .NextShip
 119+ 6AC5                                      SetCarryFlag
 119+ 6AC5 37          >                        scf
 120+ 6AC6 C9                                   ret
 121+ 6AC7
 122+ 6AC7 21 F5 68     IsSpaceStationPresent:  ld      hl,UniverseSlotList
 123+ 6ACA                                      ClearCarryFlag
 123+ 6ACA B7          >                        or a
 124+ 6ACB 7E           .SearchLoop:            ld      a,(hl)
 125+ 6ACC                                      ReturnIfAEqNusng ShipTypeStation
 125+ 6ACC FE 02       >                        cp      ShipTypeStation
 125+ 6ACE C8          >                        ret     z
 126+ 6ACF                                      SetCarryFlag
 126+ 6ACF 37          >                        scf
 127+ 6AD0 C9                                   ret
 128+ 6AD1
 129+ 6AD1 21 F5 68     GetTypeAtSlotA:         ld      hl,UniverseSlotList
 130+ 6AD4 ED 31                                add     hl,a
 131+ 6AD6 7E                                   ld      a,(hl)
 132+ 6AD7 C9                                   ret
 133+ 6AD8
 134+ 6AD8 21 F6 68     IsPlanetOrSpaceStation: ld      hl,UniverseSlotList+1
 135+ 6ADB 7E                                   ld      a,(hl)
 136+ 6ADC C9                                   ret
 137+ 6ADD              ;-----------------------------------------------------------------------------
 138+ 6ADD              ;-- Search the slot list for a free slot and return the result in c register.
 139+ 6ADD              ;-- Carry is clear if successful, else carry is set if all slots full
 140+ 6ADD              ;-- uses hl, bc, a
 141+ 6ADD 21 F5 68     FindNextFreeSlotInC:    ld      hl,UniverseSlotList
 142+ 6AE0 06 0C                                ld      b, UniverseSlotListSize
 143+ 6AE2 0E 00                                ld      c, 0
 144+ 6AE4 7E           .SearchLoop:            ld      a,(hl)
 145+ 6AE5                                      JumpIfAEqNusng $FF, .FoundSlot
 145+ 6AE5 FE FF       >                        cp     $FF
 145+ 6AE7 CA F0 6A    >                        jp      z,.FoundSlot
 146+ 6AEA 0C                                   inc     c
 147+ 6AEB 23                                   inc     hl
 148+ 6AEC 10 F6                                djnz    .SearchLoop
 149+ 6AEE                                      SetCarryFlag
 149+ 6AEE 37          >                        scf
 150+ 6AEF C9                                   ret
 151+ 6AF0              .FoundSlot:             ClearCarryFlag
 151+ 6AF0 B7          >                        or a
 152+ 6AF1 C9                                   ret
 153+ 6AF2
 154+ 6AF2              ;-----------------------------------------------------------------------------
 155+ 6AF2              ;-- calls FindNextFreeSlotInC and returns the result in a and c registers.
 156+ 6AF2              ;-- Carry is clear if successful, else carry is set if all slots full
 157+ 6AF2              ;-- uses hl, bc, a
 158+ 6AF2 CD DD 6A     FindNextFreeSlotInA:    call    FindNextFreeSlotInC
 159+ 6AF5 79                                   ld      a,c
 160+ 6AF6 C9                                   ret
 161+ 6AF7
# file closed: ../../Variables/UniverseSlotRoutines.asm
 656  6AF7                  ;NCLUDE "../../Variables/EquipmentVariables.asm"
 657  6AF7                  INCLUDE "../../Variables/random_number.asm"
# file opened: ../../Variables/random_number.asm
   1+ 6AF7              ; dea = random number
   2+ 6AF7 CD 08 6B     doRandomS24:            call    doRandom
   3+ 6AFA 57                                   ld      d,a
   4+ 6AFB E5                                   push    hl
   5+ 6AFC CD 08 6B                             call    doRandom
   6+ 6AFF E1                                   pop     hl
   7+ 6B00 5F                                   ld      e,a
   8+ 6B01 E5                                   push    hl
   9+ 6B02 CD 08 6B                             call    doRandom
  10+ 6B05 E1                                   pop     hl
  11+ 6B06 C9                                   ret
  12+ 6B07
  13+ 6B07              doRandom2:									; .DORND2	\ -> &3F85 \ Restricted for explosion dust.
  14+ 6B07              doRND2:
  15+ 6B07 A7           	and		a								; fast clear carry  leave bit0 of RAND+2 at 0.
  16+ 6B08              doRandom:									;.DORND	\ -> &3F86 \ do random, new A, X.
  17+ 6B08              ; "doRandom, Random Seed update, new value in A & C)"
  18+ 6B08              ; uses a 'a c h l registers, de not affected
  19+ 6B08              doRND:                  ;exx                                     ; protect bc,de,hl
  20+ 6B08 3A FA 65                             ld		a,(RandomSeed)					; Get Seed 0
  21+ 6B0B CB 17                                rl		a								; Rotate L including carry
  22+ 6B0D 4F                                   ld		c,a								; c =  double lo
  23+ 6B0E 21 FC 65     .AddSeed2:              ld		hl,RandomSeed2
  24+ 6B11 8E                                   adc		a,(hl)							; RAND+2
  25+ 6B12 32 FA 65     .SaveAtoSeed:           ld		(RandomSeed),a					; and save RAND
  26+ 6B15 08           .SaveBtoSeed2:          ex		af,af'
  27+ 6B16 79                                   ld		a,c
  28+ 6B17 32 FC 65                             ld		(RandomSeed2),a
  29+ 6B1A 08                                   ex		af,af'
  30+ 6B1B 3A FB 65                             ld		a,(RandomSeed1)
  31+ 6B1E 4F                                   ld		c,a								; C = Seed1
  32+ 6B1F 21 FD 65     .AddSeed3:              ld		hl,RandomSeed3
  33+ 6B22 8E                                   adc		a,(hl)
  34+ 6B23 32 FB 65                             ld		(RandomSeed1),a
  35+ 6B26 08                                   ex		af,af'
  36+ 6B27 79                                   ld		a,c
  37+ 6B28 32 FD 65                             ld		(RandomSeed3),a
  38+ 6B2B 08                                   ex		af,af'
  39+ 6B2C                                      ;exx                                     ; get bc,de,hl back
  40+ 6B2C C9                                   ret
  41+ 6B2D
  42+ 6B2D 21 FA 65     saveRandomSeeds:        ld      hl,RandomSeed
  43+ 6B30 11 FE 65                             ld      de,RandomSeedSave
  44+ 6B33 01 04 00                             ld      bc,4
  45+ 6B36 ED A0                                ldi
  46+ 6B38 ED A0                                ldi
  47+ 6B3A ED A0                                ldi
  48+ 6B3C ED A0                                ldi
  49+ 6B3E C9                                   ret
  50+ 6B3F
  51+ 6B3F 21 FE 65     restoreRandomSeeds:     ld      hl,RandomSeedSave
  52+ 6B42 11 FA 65                             ld      de,RandomSeed
  53+ 6B45 01 04 00                             ld      bc,4
  54+ 6B48 ED A0                                ldi
  55+ 6B4A ED A0                                ldi
  56+ 6B4C ED A0                                ldi
  57+ 6B4E ED A0                                ldi
  58+ 6B50 C9                                   ret
# file closed: ../../Variables/random_number.asm
 658  6B51              ;INCLUDE "Tables/inwk_table.asm" This is no longer needed as we will write to univer object bank
 659  6B51              ; Include all maths libraries to test assembly
 660  6B51                  ;INCLUDE "../../Maths/asm_add.asm"
 661  6B51                  ;INCLUDE "../../Maths/asm_subtract.asm"
 662  6B51                  ;NCLUDE "../../Maths/DIVD3B2.asm"
 663  6B51
 664  6B51                  ;INCLUDE "./Maths/asm_multiply.asm"
 665  6B51                  DISPLAY ">Loading S78 Maths routines"
 666  6B51                  INCLUDE "../../MathsFPS78/asm_multiply_S78.asm"
# file opened: ../../MathsFPS78/asm_multiply_S78.asm
   1+ 6B51              ; asm_mulitply_S78
   2+ 6B51              ; Multiplcation routines for Lead sign 7.8 format, adapted based on Q88 format but only respresents negatives by sign bit
   3+ 6B51
   4+ 6B51              ; replaces all maths multplication
   5+ 6B51
   6+ 6B51              ; DE = D (S7) * E (S7)
   7+ 6B51              ; Optimised mulitploy routines S7 by S7 signed
   8+ 6B51              ; muliptiply S7.0 bu ny S7e signed
   9+ 6B51              ; used A and B registers
  10+ 6B51              ; result in DE
  11+ 6B51              ; This replaces DEequDmulEs
  12+ 6B51              ; 16 bit HL * DE
  13+ 6B51              ; start with lower and help with add sequence           ; all with carry flag (as lower case target reg)
  14+ 6B51              ;        L *     E   X0mulY0 1>> 1>>  shift >> 16       ;     HL = L * E
  15+ 6B51              ;        L *   D     Y1mulX0 0   1>>  shift >> 8        ;   DEHL = 00HL  + 0[L*D]0
  16+ 6B51              ;      H   *     E   X1mulY0 0   1>>  shift >> 8        ;   DEHL = DEHL  + 0[H*E]0 = DEH + 0[H*E]
  17+ 6B51              ;      H   *   D     X1mulY1 0   0    shift 0           ;  CDE   = CDE   + 0[H*D]
  18+ 6B51              ; 16 bit HL *  E
  19+ 6B51              ; start with lower and help with add sequence           ; all with carry flag (as lower case target reg)
  20+ 6B51              ;        L *     E   X0mulY0 1>> 1>>  shift >> 16       ;     HL = L * E
  21+ 6B51              ;        L *   D     Y1mulX0 0   1>>  shift >> 8        ;   DEHL = 00HL  + 0[L*D]0
  22+ 6B51              ;      H   *     E   X1mulY0 0   1>>  shift >> 8        ;   DEHL = DEHL  + 0[H*E]0 = DEH + 0[H*E]
  23+ 6B51              ;      H   *   D     X1mulY1 0   0    shift 0           ;  CDE   = CDE   + 0[H*D]
  24+ 6B51
  25+ 6B51
  26+ 6B51
  27+ 6B51 7A           DEequDmulEs:        ld      a,d                     ; work out resultant sign and load into b
  28+ 6B52 AB                               xor     e                       ; .
  29+ 6B53 E6 80                            and     SignOnly8Bit            ; .
  30+ 6B55 47                               ld      b,a                     ; .
  31+ 6B56 7A                               ld      a,d                     ; now clear d sign bit
  32+ 6B57 E6 7F                            and     SignMask8Bit            ; .
  33+ 6B59 57                               ld      d,a                     ; .
  34+ 6B5A 7B                               ld      a,e                     ; now clear e sign bit
  35+ 6B5B E6 7F                            and     SignMask8Bit            ; .
  36+ 6B5D 5F                               ld      e,a                     ; .
  37+ 6B5E ED 30                            mul     de                      ; do mulitply
  38+ 6B60 7A                               ld      a,d                     ; get sign bit from b and re0introduce it
  39+ 6B61 B0                               or      b                       ; .
  40+ 6B62 57                               ld      d,a                     ; .
  41+ 6B63 C9                               ret
  42+ 6B64
  43+ 6B64              fixedS158_muls:
  44+ 6B64              ;HL.0 = BH.L * CD.E, does this by scaling down to BH * CD then scaled result up by a word
  45+ 6B64 6C                               ld      l,h
  46+ 6B65 60                               ld      h,b
  47+ 6B66 5A                               ld      e,d
  48+ 6B67 51                               ld      d,c
  49+ 6B68 C3 58 6C                         jp      fixedS78_muls
  50+ 6B6B
  51+ 6B6B 57           AequAmulEdiv256u:   ld      d,a
  52+ 6B6C ED 30                            mul     de
  53+ 6B6E 7A                               ld      a,d
  54+ 6B6F C9                               ret
  55+ 6B70
  56+ 6B70 57           AequAmulQdiv256u:   ld      d,a
  57+ 6B71 3A 05 67                         ld      a,(varQ)
  58+ 6B74 5F                               ld      e,a
  59+ 6B75 ED 30                            mul     de
  60+ 6B77 7A                               ld      a,d
  61+ 6B78 C9                               ret
  62+ 6B79
  63+ 6B79              ;HL = HL * DE in 2's compliment
  64+ 6B79 7A           HLequHLmulDE2sc:        ld      a,d
  65+ 6B7A AC                                   xor     h
  66+ 6B7B E6 80                                and     SignOnly8Bit
  67+ 6B7D FD 67                                ld      iyh,a               ; save sign bit for result
  68+ 6B7F 7C                                   ld      a,h
  69+ 6B80 E6 80                                and     SignOnly8Bit
  70+ 6B82 28 06                                jr      z,.HLPositive
  71+ 6B84              .HLNegative:            NegHL
  71+ 6B84 AF          >                    xor a
  71+ 6B85 95          >                    sub l
  71+ 6B86 6F          >                    ld l,a
  71+ 6B87 9F          >                    sbc a,a
  71+ 6B88 94          >                    sub h
  71+ 6B89 67          >                    ld h,a
  72+ 6B8A 7A           .HLPositive:            ld      a,d
  73+ 6B8B E6 80                                and     SignOnly8Bit
  74+ 6B8D 28 06                                jr      z,.DEPositive
  75+ 6B8F              .DENegative:            NegDE
  75+ 6B8F AF          >                    xor a
  75+ 6B90 93          >                    sub e
  75+ 6B91 5F          >                    ld e,a
  75+ 6B92 9F          >                    sbc a,a
  75+ 6B93 92          >                    sub d
  75+ 6B94 57          >                    ld d,a
  76+ 6B95 CD 52 6C     .DEPositive:            call    HLequHLmulDEu         ; now do calc
  77+ 6B98 FD 7C                                ld      a,iyh
  78+ 6B9A A7                                   and     a                   ; if its 0 then we are good
  79+ 6B9B C8                                   ret     z
  80+ 6B9C
  81+ 6B9C              ; "ASM_FMUTKL .FMLTU	\ -> &2847  \ A=D*E/256unsg  Fast multiply"
  82+ 6B9C ED 30        AequDmulEdiv256u:   mul     de
  83+ 6B9E 7A                               ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
  84+ 6B9F C9                               ret
  85+ 6BA0              ; DELC = HL.E by .D leading Sign (replaces mulHLEbyDSigned)
  86+ 6BA0 7A           DELCequHLEmulDs:    ld      a,d                 ; get sign from d
  87+ 6BA1 AC                               xor     h                   ; xor with h to get resultant sign
  88+ 6BA2 E6 80                            and     SignOnly8Bit        ; .
  89+ 6BA4 FD 67                            ld      iyh,a               ; iyh = copy of sign
  90+ 6BA6 CB BC                            res     7,h                 ; clear sign bit to get ABS values
  91+ 6BA8 CB BA                            res     7,d                 ;
  92+ 6BAA 7A           .ChecForZero:       ld      a,d                 ; quick test for d
  93+ 6BAB A7                               and     a
  94+ 6BAC 28 12                            jr      z,.ResultZero       ; now test HLE
  95+ 6BAE 7C                               ld      a,h                 ;
  96+ 6BAF B5                               or      l                   ;
  97+ 6BB0 B3                               or      e                   ;
  98+ 6BB1 28 0D                            jr      z,.ResultZero       ;
  99+ 6BB3 7A           .LoadForDEHLmulAu:  ld      a,d                 ; we now have divisor set
 100+ 6BB4 53                               ld      d,e
 101+ 6BB5 5C                               ld      e,h
 102+ 6BB6 65                               ld      h,l
 103+ 6BB7 6A                               ld      l,d
 104+ 6BB8
 105+ 6BB8 CD C6 6B                         call    DEHLequEHLmulAu
 106+ 6BBB 7A                               ld      a,d
 107+ 6BBC FD B4                            or      iyh                 ;
 108+ 6BBE 57                               ld      d,a
 109+ 6BBF C9                               ret
 110+ 6BC0              .ResultZero:        ZeroA
 110+ 6BC0 AF          >                        xor a
 111+ 6BC1 57                               ld      d,a
 112+ 6BC2 5F                               ld      e,a
 113+ 6BC3 6F                               ld      l,a
 114+ 6BC4 4F                               ld      c,a
 115+ 6BC5 C9                               ret
 116+ 6BC6
 117+ 6BC6              ; adehl = ehl * a , we will simplify this down to ehl * a (or d?)
 118+ 6BC6 06 00        DEHLequEHLmulAu:    ld      b,0 ; N/A ld      b,d                       ; relocate DE
 119+ 6BC8 4B                               ld      c,e                 ; x2
 120+ 6BC9 5D                               ld      e,l                 ; x0
 121+ 6BCA 57                               ld      d,a                 ; y0
 122+ 6BCB ED 30                            mul     de                  ; de = y0*x0
 123+ 6BCD 08                               ex      af,af               ; save y0 'accumulator
 124+ 6BCE 6B                               ld      l,e                 ;'p0
 125+ 6BCF 7A                               ld      a,d                 ;'p1 carry
 126+ 6BD0 08                               ex      af,af               ; get back y0
 127+ 6BD1 5C                               ld      e,h                 ; x1
 128+ 6BD2 57                               ld      d,a                 ; y0
 129+ 6BD3 ED 30                            mul     de                  ; y0*x1
 130+ 6BD5 08                               ex      af,af               ; get back carry
 131+ 6BD6 83                               add     a,e                 ; h = carry + LSW of y0 & x1
 132+ 6BD7 67                               ld      h,a                 ; .
 133+ 6BD8 7A                               ld      a,d                 ;'p2 carry
 134+ 6BD9 08                               ex      af,af               ; get back y0
 135+ 6BDA 59                               ld      e,c
 136+ 6BDB 57                               ld      d,a
 137+ 6BDC ED 30                            mul     de                  ; y0*x2
 138+ 6BDE 08                               ex      af,af               ; get back p2 carry
 139+ 6BDF 8B                               adc     a,e                 ; and add LWS of y0*x2
 140+ 6BE0 5F                               ld      e,a                 ; now we have
 141+ 6BE1 CE 00                            adc     a,0                 ; finally get carry and sign into iyh
 142+ 6BE3 57                               ld      d,a
 143+ 6BE4 C9                               ret
 144+ 6BE5              ; ahl = hl * e simplified 16x8 muliplication
 145+ 6BE5 54           AHLequHLmulE:       ld      d,h                 ; x1
 146+ 6BE6 63                               ld      h,e                 ; y0
 147+ 6BE7 ED 30                            mul     de                  ; x1*y0
 148+ 6BE9 EB                               ex      de,hl
 149+ 6BEA ED 30                            mul     de                  ; y0*xl, hl = x1*y0l
 150+ 6BEC 7A                               ld      a,d                 ; sum products
 151+ 6BED 85                               add     a,l
 152+ 6BEE 57                               ld      d,a
 153+ 6BEF EB                               ex      de,hl
 154+ 6BF0 7A                               ld      a,d
 155+ 6BF1 CE 00                            adc     a,0
 156+ 6BF3 C9                               ret
 157+ 6BF4
 158+ 6BF4
 159+ 6BF4                                  DISPLAY "TO DO TEST IF this gets D correct"
 160+ 6BF4                                  ;ld      c,a                 ; c = p2
 161+ 6BF4                                  ;ld      a,d                 ; a = p3 carry
 162+ 6BF4                                  ;ex      af,af
 163+ 6BF4                                  ;ld e,b                     we don;t have x3
 164+ 6BF4                                  ;ld d,a
 165+ 6BF4                                  ;mul de                       ; y*x3
 166+ 6BF4                                  ;ex af,af
 167+ 6BF4                                  ;adc a,e
 168+ 6BF4                                  ;ld b,a                       ;'p3
 169+ 6BF4                                  ;ld a,d                       ;'p4 carry
 170+ 6BF4                                  ;adc a,0                      ;'final carry
 171+ 6BF4
 172+ 6BF4                                  ;ld d,b                       ; return DE
 173+ 6BF4                                  ;ld e,c
 174+ 6BF4
 175+ 6BF4              ; kept for now but think its good to delete
 176+ 6BF4              ;
 177+ 6BF4              ;                    ld      b,d                 ; save Quotient y0
 178+ 6BF4              ;.mul1:              mul     de                  ; [IYL]C = E * D    (p1) (p0) x0 * y0
 179+ 6BF4              ;                    ld      c,e                 ; .
 180+ 6BF4              ;                    ld      iyl,d               ; .
 181+ 6BF4              ;.mul2:              ld      e,l                 ; de = x1 * y0
 182+ 6BF4              ;                    ld      d,b                 ; .
 183+ 6BF4              ;                    mul     de                  ; .
 184+ 6BF4              ;                    ld      a,iyl               ; get back p1 (carry)
 185+ 6BF4              ;.carrybyte1:        add     a,e                 ; l = p1 = p1 + LSW of x1 * y0 and we are doen with carry
 186+ 6BF4              ;                    ld      l,a                 ; .
 187+ 6BF4              ;                    ld      iyl,d               ; save new carry byte MSW of x1 * y0
 188+ 6BF4              ;.mul3:              ld      e,h                 ; E = H * D
 189+ 6BF4              ;                    ld      d,b                 ; .
 190+ 6BF4              ;                    mul     de                  ; .
 191+ 6BF4              ;                    ld      a,iyl
 192+ 6BF4              ;                    adc     a,e                 ; .
 193+ 6BF4              ;                    ld      e,a                 ; .
 194+ 6BF4              ;.ItsNotZero:        ld      a,d                 ;
 195+ 6BF4              ;                    adc     a,0                 ; final carry bit
 196+ 6BF4              ;                    or      iyh                 ; bring back sign
 197+ 6BF4              ;                    ld      d,a                 ; s = sign
 198+ 6BF4              ;                    ret
 199+ 6BF4              ;.ResultZero:        ld      de,0
 200+ 6BF4              ;                    ZeroA
 201+ 6BF4              ;                    ld      c,a
 202+ 6BF4              ;                    ld      l,a
 203+ 6BF4              ;                    ret
 204+ 6BF4                  DISPLAY "TODO replace this with non memory access version"
 205+ 6BF4              HLequSRmulQdiv256:  ;X.Y=x1 lo.S*M/256  	\ where M/256 is gradient replaces HLequSRmulQdiv256
 206+ 6BF4 2A 06 67                         ld      hl,(varRS)
 207+ 6BF7 3A 05 67                         ld      a,(varQ)
 208+ 6BFA C5 D5        HLeqyHLmulAdiv256:  push    bc,,de
 209+ 6BFC 11 00 00                         ld      de,0        ; de = XY
 210+ 6BFF 47                               ld      b,a         ; b = Q
 211+ 6C00                                  ShiftHLRight1
 211+ 6C00 CB 3C       >               srl h
 211+ 6C02 CB 1D       >               rr  l
 212+ 6C04 CB 20                            sla     b
 213+ 6C06 30 03                            jr      nc,.LL126
 214+ 6C08 EB           .LL125:             ex      de,hl
 215+ 6C09 19                               add     hl,de
 216+ 6C0A EB                               ex      de,hl       ; de = de + rs
 217+ 6C0B              .LL126:             ShiftHLRight1
 217+ 6C0B CB 3C       >               srl h
 217+ 6C0D CB 1D       >               rr  l
 218+ 6C0F CB 20                            sla b
 219+ 6C11 38 F5                            jr      c,.LL125
 220+ 6C13 20 F6                            jr      nz,.LL126
 221+ 6C15 EB                               ex      de,hl   ; hl = result
 222+ 6C16 D1 C1                            pop     bc,,de
 223+ 6C18 C9                               ret
 224+ 6C19
 225+ 6C19              ; AHL = HL * E unsigned, in effect X1 X0 * Y0
 226+ 6C19 AB           AHLequHLmulEu:      xor     e                       ; .
 227+ 6C1A E6 80                            and     SignOnly8Bit            ; .
 228+ 6C1C 47                               ld      b,a                     ; .
 229+ 6C1D 7A                               ld      a,d                     ; now clear d sign bit
 230+ 6C1E E6 7F                            and     SignMask8Bit            ; .
 231+ 6C20 57                               ld      d,a                     ; .
 232+ 6C21 7B                               ld      a,e                     ; now clear e sign bit
 233+ 6C22 E6 7F                            and     SignMask8Bit            ; .
 234+ 6C24 5F                               ld      e,a                     ; .
 235+ 6C25 ED 30                            mul     de                      ; do mulitply
 236+ 6C27 7A                               ld      a,d                     ; get sign bit from b and re0introduce it
 237+ 6C28 B0                               or      b                       ; .
 238+ 6C29 57                               ld      d,a                     ; .
 239+ 6C2A C9                               ret
 240+ 6C2B 54           .performMultiplyU:  ld      d,h                     ; de = x1 y0
 241+ 6C2C 63                               ld      h,e                     ; save y0 into h
 242+ 6C2D ED 30                            mul     de                      ; de = x1 * y0
 243+ 6C2F EB                               ex      de,hl                   ; de = y0 x0, hl = x1 * y0 (p2 p1)
 244+ 6C30 ED 30                            mul     de                      ; de = y0 * x0
 245+ 6C32 7A                               ld      a,d                     ; sum products y0 * x0 upper byte + x1 * y0 lower byte
 246+ 6C33 85                               add     a,l                     ; .
 247+ 6C34 57                               ld      d,a                     ; d = result (p1)
 248+ 6C35 EB                               ex      de,hl                   ; hl = p1 p0
 249+ 6C36 7A                               ld      a,d                     ; a = p2 + carry from add above
 250+ 6C37 CE 00                            adc     a,0                     ;
 251+ 6C39 EB                               ex      de,hl                   ; now result is in ADE
 252+ 6C3A C9                               ret
 253+ 6C3B              ; hl = de * hl where de & hl are small enough to always ne 16 bit result, replaces mulDEbyHL
 254+ 6C3B C5           HLequDEmulHL:       push    bc
 255+ 6C3C 7A                               ld      a,d                     ; a = x1
 256+ 6C3D 54                               ld      d,h                     ; d = y1
 257+ 6C3E 67                               ld      h,a                     ; h = x1
 258+ 6C3F 4B                               ld      c,e                     ; c = x0
 259+ 6C40 45                               ld      b,l                     ; b = y0
 260+ 6C41 ED 30                            mul     de                      ; y1 * y0
 261+ 6C43 EB                               ex      de,hl
 262+ 6C44 ED 30                            mul     de                      ; x1 * y0
 263+ 6C46 19                               add     hl,de                   ; add cross products
 264+ 6C47 59                               ld      e,c
 265+ 6C48 50                               ld      d,b
 266+ 6C49 ED 30                            mul     de                      ; y0 * x0
 267+ 6C4B 7D                               ld      a,l                     ; cross products lsb
 268+ 6C4C 82                               add     a,d                     ; add to msb final
 269+ 6C4D 67                               ld      h,a
 270+ 6C4E 6B                               ld      l,e                     ; hl = final
 271+ 6C4F                                  ; 83 cycles, 19 bytes
 272+ 6C4F AF                               xor     a                       ; reset carry
 273+ 6C50 C1                               pop     bc
 274+ 6C51 C9                               ret
 275+ 6C52              HLequHLmulDEu:
 276+ 6C52              ;H.L = H.L * D.E unsigned S7.8 format, just skips signed bit check
 277+ 6C52 CD 6C 6C                         call    fixedS78_mulu
 278+ 6C55 6C                               ld      l,h
 279+ 6C56 67                               ld      h,a
 280+ 6C57 C9                               ret
 281+ 6C58              fixedS78_muls:
 282+ 6C58              ;H.L = D.E * H.L as S7.8 Fixed Point maths, when doing 24 bit maths scale down to 8.8 as its accurate enough
 283+ 6C58              HL_Mul_DE_88:
 284+ 6C58 7A           .checkSigns:        ld      a,d
 285+ 6C59 AC                               xor     h
 286+ 6C5A E6 80                            and     $80
 287+ 6C5C FD 6F                            ld      iyl,a               ; sign bit is the result sign bit held in iy as we want to optimise
 288+ 6C5E CB BA        .forcePositiveOnly: res     7,d                 ; de = abs de
 289+ 6C60 CB BC                            res     7,h                 ; hl = abs hl
 290+ 6C62 CD 6C 6C                         call    fixedS78_mulu       ; DEHL = DE * HL,
 291+ 6C65 6C           .getS88Result:      ld      l,h                 ; we want to lose D and L as part of return so put EH into HL
 292+ 6C66 63                               ld      h,e                 ; .
 293+ 6C67 7C                               ld      a,h                 ; now return result with sign bit, if the result over flowed into S88 then it will be out
 294+ 6C68 FD B5                            or      iyl                 ;
 295+ 6C6A 67                               ld      h,a                 ;
 296+ 6C6B C9                               ret                         ;
 297+ 6C6C              ;DE.HL = D.E * H.L as  7.8 Fixed Point unsigned maths, when doing 24 bit maths scale down to 8.8 as its accurate enough
 298+ 6C6C              fixedS78_mulu:      ;
 299+ 6C6C 7A           .checkZeroMul:      ld      a,d
 300+ 6C6D B3                               or      e
 301+ 6C6E CA 96 6C                         jp      z,.resultIsZero
 302+ 6C71 7C                               ld      a,h
 303+ 6C72 B5                               or      l
 304+ 6C73 CA 96 6C                         jp      z, .resultIsZero
 305+ 6C76 45           .performMultiplyU:  ld      b,l                 ; b = x0
 306+ 6C77 4B                               ld      c,e                 ; c =  y0
 307+ 6C78 5D                               ld      e,l                 ; e = x0
 308+ 6C79 6A                               ld      l,d                 ; l = y1 d is already y1
 309+ 6C7A E5                               push    hl                  ; save x1 y1 to stack
 310+ 6C7B 69                               ld      l,c                 ; l = y0
 311+ 6C7C ED 30                            mul     de                  ; hl  = y1 * x0
 312+ 6C7E EB                               ex      de,hl               ; . also setting de to x1 y0 as we prepped them in advance
 313+ 6C7F ED 30                            mul     de                  ; x1*y0
 314+ 6C81                                  ZeroA
 314+ 6C81 AF          >                        xor a
 315+ 6C82 19                               add     hl,de               ; sum cross products of y1*x0, x1 * y0 as they require no shifting
 316+ 6C83 8F                               adc     a,a                 ; and capture carry bit ready for p3
 317+ 6C84 59                               ld      e,c                 ; de = x0 * y0
 318+ 6C85 50                               ld      d,b                 ; .
 319+ 6C86 ED 30                            mul     de                  ; .
 320+ 6C88 47                               ld      b,a                 ; carry from cross products setting bc to <c>h  (where <c> is carry flag)
 321+ 6C89 4C                               ld      c,h                 ; .
 322+ 6C8A 7A                               ld      a,d                 ; h = high byte of x0 * y 0 _ lower byte of cross product of y1 * x0
 323+ 6C8B 85                               add     a,l                 ; .
 324+ 6C8C 67                               ld      h,a                 ; .)
 325+ 6C8D 6B                               ld      l,e                 ; so now we have lower btwo bytes of result in HL (p1 p0)
 326+ 6C8E D1                               pop de                      ; get x1 and y1 back from stack into de ready for multiply
 327+ 6C8F ED 30                            mul de                      ; hl = x1*y1 and de = p1 p0
 328+ 6C91 EB                               ex de,hl                    ; .
 329+ 6C92 ED 4A                            adc hl,bc                   ; hl = (x1 * y1) + <c>h (where h is upper byte of cross product from above)
 330+ 6C94 EB                               ex de,hl                    ; swap over de and hl for final result
 331+ 6C95 C9                               ret
 332+ 6C96 11 00 00     .resultIsZero:      ld      de,0
 333+ 6C99 21 00 00                         ld      hl,0
 334+ 6C9C C9                               ret
 335+ 6C9D
# file closed: ../../MathsFPS78/asm_multiply_S78.asm
 667  6C9D                  INCLUDE "../../Maths/asm_square.asm"
# file opened: ../../Maths/asm_square.asm
   1+ 6C9D              ; "ASM_SQUA : TESTGOOD"
   2+ 6C9D              ; "AP = A^2 A = low,P = hi"
   3+ 6C9D
   4+ 6C9D              inline_squde: MACRO
   5+ 6C9D ~            			ld	e,a
   6+ 6C9D ~            			ld  d,a
   7+ 6C9D ~            			mul
   8+ 6C9D              			ENDM
   9+ 6C9D
  10+ 6C9D              inline_squa: MACRO
  11+ 6C9D ~            			ld	e,a
  12+ 6C9D ~            			ld  d,a
  13+ 6C9D ~            			mul
  14+ 6C9D ~            			ld	a,e
  15+ 6C9D              			ENDM
  16+ 6C9D
# file closed: ../../Maths/asm_square.asm
 668  6C9D                  INCLUDE "../../Maths/asm_sine.asm"
# file opened: ../../Maths/asm_sine.asm
   1+ 6C9D              ;- MACROS
   2+ 6C9D              LookupSineAMacro:       MACRO
   3+ 6C9D ~                                    ld      hl,SNE                      ; Set Q = sin(X)  = sin(CNT2 mod 32) = |sin(CNT2)|
   4+ 6C9D ~                                    add     hl, a
   5+ 6C9D ~                                    ld      a,(hl)
   6+ 6C9D                                      ENDM
   7+ 6C9D
   8+ 6C9D              ; Gets the sine of A from the lookup table into A
   9+ 6C9D              LookupSineA:            LookupSineAMacro
   9+ 6C9D 21 46 6D    >                        ld      hl,SNE                      ; Set Q = sin(X)  = sin(CNT2 mod 32) = |sin(CNT2)|
   9+ 6CA0 ED 31       >                        add     hl, a
   9+ 6CA2 7E          >                        ld      a,(hl)
  10+ 6CA3 C9                                   ret
  11+ 6CA4
# file closed: ../../Maths/asm_sine.asm
 669  6CA4                  INCLUDE "../../Maths/asm_sqrt.asm"
# file opened: ../../Maths/asm_sqrt.asm
   1+ 6CA4              ; "ASM SQRT : TESTGOOD"
   2+ 6CA4              ; "16-bit integer square root"
   3+ 6CA4              ; "call with de = number to square root"
   4+ 6CA4              ; "returns   hl = square root"
   5+ 6CA4              ; "corrupts  bc, de"
   6+ 6CA4              asm_sqrt:
   7+ 6CA4 01 00 80     	ld bc,$8000
   8+ 6CA7 61           	ld h,c
   9+ 6CA8 69           	ld l,c
  10+ 6CA9              .sqrloop:
  11+ 6CA9 CB 38        	srl b
  12+ 6CAB CB 19        	rr c
  13+ 6CAD 09           	add hl,bc
  14+ 6CAE EB           	ex de,hl
  15+ 6CAF ED 52        	sbc hl,de
  16+ 6CB1 38 04        	jr c,.sqrbit
  17+ 6CB3 EB           	ex de,hl
  18+ 6CB4 09           	add hl,bc
  19+ 6CB5 18 05        	jr .sqrfi
  20+ 6CB7              .sqrbit:
  21+ 6CB7 19           	add hl,de
  22+ 6CB8 EB           	ex de,hl
  23+ 6CB9 B7           	or a
  24+ 6CBA ED 42        	sbc hl,bc
  25+ 6CBC              .sqrfi:
  26+ 6CBC CB 3C        	srl h
  27+ 6CBE CB 1D        	rr l
  28+ 6CC0 CB 38        	srl b
  29+ 6CC2 CB 19        	rr c
  30+ 6CC4 30 E3        	jr nc,.sqrloop
  31+ 6CC6 C9           	ret
  32+ 6CC7
  33+ 6CC7
  34+ 6CC7              sqrtQR:					; Q = SQR(Qlo.Rhi) Q <~127
  35+ 6CC7 3A 05 67     	ld		a,(varQ)
  36+ 6CCA 5F           	ld		e,a
  37+ 6CCB 3A 06 67     	ld		a,(varR)
  38+ 6CCE 57           	ld		d,a
  39+ 6CCF CD A4 6C     	call	asm_sqrt
  40+ 6CD2 7D               ld      a,l
  41+ 6CD3 32 05 67     	ld		(varQ),a
  42+ 6CD6 C9           	ret
  43+ 6CD7
# file closed: ../../Maths/asm_sqrt.asm
 670  6CD7                  INCLUDE "../../Maths/asm_arctan.asm"
# file opened: ../../Maths/asm_arctan.asm
   1+ 6CD7              ;Calculate A = arctan(P / Q)
   2+ 6CD7              ; This finds the angle in the right-angled triangle where the opposite side to angle A is length P and the adjacent side to angle A has
   3+ 6CD7              ; length Q, so:  tan(A) = P / Q
   4+ 6CD7              ;
   5+ 6CD7              ; The result in A is an integer representing the angle in radians. The routine returns values in the range 0 to 128,  (or 0 to PI radians).
   6+ 6CD7 3A 05 66     ARCTAN:                 ld      a,(varP)                    ; LDA P                  \ Set T1 = P EOR Q, which will have the sign of P * Q
   7+ 6CDA 21 05 67                             ld      hl,varQ                     ; EOR Q
   8+ 6CDD AE                                   xor     (hl)                        ; .
   9+ 6CDE 32 02 66                             ld      (varT1),a                   ; STA T1
  10+ 6CE1 3A 05 67                             ld      a,(varQ)                    ; LDA Q                  \ If Q = 0, jump to AR2 to return a right angle
  11+ 6CE4 A7                                   and     a                           ; BEQ AR2
  12+ 6CE5 CA 27 6D                             jp      z, .AR2                     ; .
  13+ 6CE8 CB 27                                sla     a                           ; ASL A                  \ Set Q = |Q| * 2 (this is a quick way of clearing the
  14+ 6CEA 32 05 67                             ld      (varQ),a                    ; STA Q                  \ sign bit, and we don't need to shift right again as we only ever use this value in the division with |P| * 2, which we set next)
  15+ 6CED 3A 05 66                             ld      a,(varP)                    ; LDA P                  \ Set A = |P| * 2
  16+ 6CF0 CB 27                                sla     a                           ; ASL A
  17+ 6CF2 32 05 66                             ld      (varP),a
  18+ 6CF5 21 05 67                             ld      hl,varQ
  19+ 6CF8 BE                                   cp      (hl)                        ; CMP Q                  \ If A >= Q, i.e. |P| > |Q|, jump to AR1 to swap P
  20+ 6CF9 D2 0B 6D                             jp      nc, .AR1                    ; BCS AR1                \ and Q around, so we can still use the lookup table
  21+ 6CFC CD 33 6D                             call    ARS1                        ; JSR ARS1               \ Call ARS1 to set the following from the lookup table:  A = arctan(A / Q)  = arctan(|P / Q|)
  22+ 6CFF                                      ClearCarryFlag                      ; SEC                    \ Set the C flag so the SBC instruction in AR3 will be correct, should we jump there
  22+ 6CFF B7          >                        or a
  23+ 6D00 4F           .AR4:                   ld      c,a                         ; as we have to use a we use c as a temp, we can't push af as we would loose flags on pop
  24+ 6D01 3A 02 66                             ld      a,(varT1)                   ; LDX T1                 \ If T1 is negative, i.e. P and Q have different signs,
  25+ 6D04 47                                   ld      b,a                         ; .
  26+ 6D05 A7                                   and     a                           ; BMI AR3                \ jump down to AR3 to return arctan(-|P / Q|)
  27+ 6D06 79                                   ld      a,c                         ; .                      \ we need to get a back before jump
  28+ 6D07 FA 2A 6D                             jp      m, .AR3                     ; .
  29+ 6D0A C9                                   ret                                 ; RTS                    \ Otherwise P and Q have the same sign, so our result is correct and we can return from the subroutine
  30+ 6D0B              ; We want to calculate arctan(t) where |t| > 1, so we can use the calculation described in the documentation for the ACT table, i.e. 64 - arctan(1 / t)
  31+ 6D0B              ; In the 6502 verion it works with A already being P but we will fetch it
  32+ 6D0B 3A 05 67     .AR1:                   ld      a,(varQ)                    ; LDX Q                  \ Swap the values in Q and P, using the fact that we
  33+ 6D0E 47                                   ld      b,a                         ; .
  34+ 6D0F 3A 05 66                             ld      a,(varP)                    ; STA Q                  \ called AR1 with A = P
  35+ 6D12 32 05 67                             ld      (varQ),a                    ; .
  36+ 6D15 78                                   ld      a,b                         ; TXA                    \ This also sets A = P (which now contains the original argument |Q|)
  37+ 6D16 32 05 66                             ld      (varP),a                    ; STX P                  \
  38+ 6D19 CD 33 6D                             call    ARS1                        ; JSR ARS1               \ Call ARS1 to set the following from the lookup table: A = arctan(A / Q) = arctan(|Q / P|) = arctan(1 / |P / Q|)
  39+ 6D1C 32 21 67                             ld      (varT),a                    ; STA T                  \ Set T = 64 - T, we use B as T (its not really that)
  40+ 6D1F 47                                   ld      b,a                         ; its actually t = a, a = 64-a
  41+ 6D20 3E 40                                ld      a,64                        ; LDA #64 What is going on here is t = result
  42+ 6D22                                      ClearCarryFlag                      ; SBC T                            a = 64- result
  42+ 6D22 B7          >                        or a
  43+ 6D23 98                                   sbc     a,b                         ; .
  44+ 6D24 C3 00 6D                             jp      .AR4                        ; BCS AR4                \ Jump to AR4 to continue the calculation (this BCS is effectively a JMP as the subtraction will never underflow, as ARS1 returns values in the range 0-31)
  45+ 6D27              ; If we get here then Q = 0, so tan(A) = infinity and A is a right angle, or 0.25 of a circle. We allocate 255 to a full circle, so we should return 63 for a right angle
  46+ 6D27 3E 3F        .AR2:                   ld      a,63                        ; LDA #63                \ Set A to 63, to represent a right angle
  47+ 6D29 C9                                   ret                                 ; RTS                    \ Return from the subroutine
  48+ 6D2A              ; A contains arctan(|P / Q|) but P and Q have different signs, so we need to return arctan(-|P / Q|), using the calculation described in the documentation for the ACT table, i.e. 128 - A
  49+ 6D2A 32 21 67     .AR3:                   ld      (varT),a
  50+ 6D2D 47                                   ld      b,a                         ; STA T                  \ Set A = 128 - A, we use b as T
  51+ 6D2E 3E 80                                ld      a,128                       ; LDA #128               \
  52+ 6D30                                      ClearCarryFlag                      ; SBC T                  \ The subtraction will work because we did a SEC before calling AR3
  52+ 6D30 B7          >                        or a
  53+ 6D31 98                                   sbc     a,b
  54+ 6D32 C9                                   ret                                 ; RTS                    \ Return from the subroutine
  55+ 6D33              ; This routine fetches arctan(A / Q) from the ACT table, so A will be set to an integer in the range 0 to 31 that represents an angle from 0 to 45 degrees (or 0 to \ PI / 4 radians)
  56+ 6D33 CD F1 6D     ARS1:                   call    Amul256DivQ                 ; JSR LL28               \ Call LL28 to calculate: R = 256 * A / Q
  57+ 6D36 3A 06 67                             ld      a,(varR)                    ; LDA R                  \ Set X = R / 8
  58+ 6D39 CB 3F                                srl     a                           ; LSR A                  \       = 32 * A / Q
  59+ 6D3B CB 3F                                srl     a                           ; LSR A                  \
  60+ 6D3D CB 3F                                srl     a                           ; LSR A                  \ so X has the value t * 32 where t = A / Q, which is
  61+ 6D3F 21 66 6D                             ld      hl,ACT                      ; TAX                    \ what we need to look up values in the ACT table
  62+ 6D42 ED 31                                add     hl,a                        ; LDA ACT,X              \ Fetch ACT+X from the ACT table into A, so now:
  63+ 6D44 7E                                   ld      a,(hl)                      ;                        \   A = value in ACT + X = value in ACT + (32 * A / Q)= arctan(A / Q)
  64+ 6D45 C9                                   ret                                 ; RTS                    \ Return from the subroutine
  65+ 6D46
  66+ 6D46              ;;;arctan:										; .ARCTAN	\ -> &2A3C  \ A=TAN-1(P/Q) \ A=arctan (P/Q)  called from block E
  67+ 6D46              ;;;		ld		a,(varP)					; a = var P
  68+ 6D46              ;;;		ld		hl,varQ
  69+ 6D46              ;;;		xor		(hl)						; a = var p XOR varQ
  70+ 6D46              ;;;		ld		a,(varT1)					; \ T1	 \ quadrant info
  71+ 6D46              ;;;		ld		c,a							; c = copy of T1
  72+ 6D46              ;;;		ld		a,(hl)						; Q
  73+ 6D46              ;;;		cp		0
  74+ 6D46              ;;;		jr		z,.AR2						;  Q=0 so set angle to 63, pi/2
  75+ 6D46              ;;;		ld		(varQ),a					; Q move to reg B?
  76+ 6D46              ;;;		ld		d,a							; copy to reg d
  77+ 6D46              ;;;		sla		a							; drop sign
  78+ 6D46              ;;;		ld		a,(varP)					; P
  79+ 6D46              ;;;		ld		e,a							; copy to reg e
  80+ 6D46              ;;;		sla		a							; drop sign
  81+ 6D46              ;;;		cp		d							; compare with b (unsigned varQ * 2)
  82+ 6D46              ;;;		jr		nc, .ars1					; if q >  p then adjust  swop A and Q as A >= Q
  83+ 6D46              ;;;		call	ars1						; \ ARS1 \ get Angle for A*32/Q from table.
  84+ 6D46              ;;;		scf									; set carry flag
  85+ 6D46              ;;;.ar4:										; sub o.k
  86+ 6D46              ;;;		bit 	7,c							; is T1 (also in c) negative?
  87+ 6D46              ;;;		jr		nz,.ar3						;  -ve quadrant
  88+ 6D46              ;;;		ret
  89+ 6D46              ;;;.ar1:										; swop A and Q entering here d = q and e = P
  90+ 6D46              ;;;		ld		a,d							; a = varQ
  91+ 6D46              ;;;		ld		d,e							; varQ = varP
  92+ 6D46              ;;;		ld		e,a							; swap D and E around
  93+ 6D46              ;;;		ld		(varP),a					; write to actual variables
  94+ 6D46              ;;;		ld		a,d
  95+ 6D46              ;;;		ld		(varQ),a					; write to actual variables
  96+ 6D46              ;;;		call	.ars1
  97+ 6D46              ;;;		ld		(varT),b
  98+ 6D46              ;;;		ld		b,a							; B = T = angle
  99+ 6D46              ;;;		ld		a,64						; next range of angle, pi/4 to pi/2
 100+ 6D46              ;;;		sub		a,b							; a = 64 - T (or b)
 101+ 6D46              ;;;		jr		nc,.ar4						;  sub o.k
 102+ 6D46              ;;;.ar2:										; .AR2	\ set angle to 90 degrees
 103+ 6D46              ;;;		ld 		a,&3F						;  #63
 104+ 6D46              ;;;		ret
 105+ 6D46              ;;;.ar3:										;.AR3	\ -ve quadrant
 106+ 6D46              ;;;		ld		b,a							; b = T	= \ angle
 107+ 6D46              ;;;		ld		a,ConstPi					; a = Pi
 108+ 6D46              ;;;		sub		b,a							; A = 128-T, so now covering range pi/2 to pi correctly
 109+ 6D46              ;;;		ret
 110+ 6D46              ;;;.ars1:										; .ARS1	\ -> &2A75  \ get Angle for A*32/Q from table.
 111+ 6D46              ;;;		call	RequAmul256divQ				;  LL28 \ BFRDIV R=A*256/Q
 112+ 6D46              ;;;		ld		a,(regA)
 113+ 6D46              ;;;		srl		a
 114+ 6D46              ;;;		srl		a
 115+ 6D46              ;;;		srl		a							;  31 max.
 116+ 6D46              ;;;		ld		hl, ArcTanTable				; root of index into table at end of words data
 117+ 6D46              ;;;		add		hl,a						; now at real data
 118+ 6D46              ;;;		ld		a,(hl)						; a =  ACT[a]
 119+ 6D46              ;;;.arsr:										; rts used by laser lines below (will not in later code)
 120+ 6D46              ;;;		ret
 121+ 6D46
 122+ 6D46
 123+ 6D46
# file closed: ../../Maths/asm_arctan.asm
 671  6D46                  INCLUDE "../../Maths/SineTable.asm"
# file opened: ../../Maths/SineTable.asm
   1+ 6D46              ;; PRINT "SIN TABLE"
   2+ 6D46              ;; FOR I% =  0 TO  31
   3+ 6D46              ;; N = ABS(SIN((I%/64)*2*PI))
   4+ 6D46              ;; IF N >= 1 THEN B% = 255  ELSE B% = INT(256 * N + 0.5)
   5+ 6D46              ;; PRINT B%
   6+ 6D46              ;; NEXT I%
   7+ 6D46
   8+ 6D46
   9+ 6D46 00 19 32 4A  SNE:            DB 000, 025, 050, 074, 098, 121, 142, 162
   9+ 6D4A 62 79 8E A2
  10+ 6D4E B5 C6 D5 E2                  DB 181, 198, 213, 226, 237, 245, 251, 255
  10+ 6D52 ED F5 FB FF
  11+ 6D56 FF FF FB F5                  DB 255, 255, 251, 245, 237, 226, 213, 198
  11+ 6D5A ED E2 D5 C6
  12+ 6D5E B5 A2 8E 79                  DB 181, 162, 142, 121, 098, 074, 050, 025
  12+ 6D62 62 4A 32 19
# file closed: ../../Maths/SineTable.asm
 672  6D66                  INCLUDE "../../Maths/ArcTanTable.asm"
# file opened: ../../Maths/ArcTanTable.asm
   1+ 6D66              ;PRINT "ARCTAN TABLE"
   2+ 6D66              ;FOR I% = 0 TO 31
   3+ 6D66              ;    PRINT INT((128/PI) * ATN(I%/32)+0.5)
   4+ 6D66              ;NEXT I%
   5+ 6D66
   6+ 6D66 00 01 03 04  ACT:            DB 000, 001, 003, 004, 005, 006, 008, 009
   6+ 6D6A 05 06 08 09
   7+ 6D6E 0A 0B 0C 0D                  DB 010, 011, 012, 013, 015, 016, 017, 018
   7+ 6D72 0F 10 11 12
   8+ 6D76 13 14 15 16                  DB 019, 020, 021, 022, 023, 024, 025, 025
   8+ 6D7A 17 18 19 19
   9+ 6D7E 1A 1B 1C 1D                  DB 026, 027, 028, 029, 030, 031, 031, 031
   9+ 6D82 1E 1F 1F 1F
  10+ 6D86
# file closed: ../../Maths/ArcTanTable.asm
 673  6D86                  INCLUDE "../../Maths/negate16.asm"
# file opened: ../../Maths/negate16.asm
   1+ 6D86              ;;----------------------------------------------------------------------------------------------------------------------
   2+ 6D86              ;; 16-bit negate
   3+ 6D86                      ; Input:
   4+ 6D86                      ;       HL = value
   5+ 6D86                      ; Output:
   6+ 6D86                      ;       HL = -value
   7+ 6D86                      ; Destroys:
   8+ 6D86                      ;       AF
   9+ 6D86                      ;
  10+ 6D86              negate16:
  11+ 6D86 AF           negate16hl:         xor 	a
  12+ 6D87 95                               sub 	l
  13+ 6D88 6F                               ld 		l,a
  14+ 6D89 9F                               sbc 	a,a
  15+ 6D8A 94                               sub 	h
  16+ 6D8B 67                               ld 		h,a
  17+ 6D8C C9                               ret
  18+ 6D8D
  19+ 6D8D AF           negate16de:         xor 	a
  20+ 6D8E 93                               sub 	e
  21+ 6D8F 5F                               ld 		e,a
  22+ 6D90 9F                               sbc 	a,a
  23+ 6D91 92                               sub 	d
  24+ 6D92 57                               ld 		d,a
  25+ 6D93 C9                               ret
  26+ 6D94
  27+ 6D94 AF           negate16bc:         xor 	a
  28+ 6D95 91                               sub 	c
  29+ 6D96 4F                               ld 		c,a
  30+ 6D97 9F                               sbc 	a,a
  31+ 6D98 90                               sub 	b
  32+ 6D99 47                               ld 		b,a
  33+ 6D9A C9                               ret
  34+ 6D9B
# file closed: ../../Maths/negate16.asm
 674  6D9B                  INCLUDE "../../Maths/asm_divide.asm"
# file opened: ../../Maths/asm_divide.asm
   1+ 6D9B              ;   K(3 2 1 0)           The result of the division
   2+ 6D9B              ;   X                    X is preserved
   3+ 6D9B
   4+ 6D9B              ; Calculate K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo) where zsign hi lo is in DE with zsign leading hi
   5+ 6D9B 00 00 00 00  varQRS                 DS      4
   6+ 6D9F 00 00 00     varAPP                 DS     3
   7+ 6DA2 00           RvarDiv                DS     1
   8+ 6DA3
   9+ 6DA3                                  DISPLAY "TODO:  neds rewrite of whoel DIDV3B2"
  10+ 6DA3              ;; NEEDS REWRITE TODO OF WHOLE DIVD3B2
  11+ 6DA3              ;; NEEDS REWRITE TODO
  12+ 6DA3
  13+ 6DA3              ; b = varR, c= varQ
  14+ 6DA3              Requ256mulAdivQ_6502:
  15+ 6DA3 CB 27        .LL31_6502:             sla     a                       ; ASL A                   \ Shift A to the left
  16+ 6DA5 DA BA 6D                             jp      c,.LL29_6502            ; BCS LL29               \ If bit 7 of A was set, then jump straight to the subtraction
  17+ 6DA8                                      FlipCarryFlag                   ;                          If A < N, then C flag is set.
  17+ 6DA8 3F          >                        ccf
  18+ 6DA9                                      JumpIfALTNusng c, .LL31_SKIPSUB_6502 ; CMP Q              \ If A < Q, skip the following subtraction
  18+ 6DA9 B9          >                        cp      c
  18+ 6DAA DA AF 6D    >                        jp		c, .LL31_SKIPSUB_6502
  19+ 6DAD                                                                      ; BCC P%+4
  20+ 6DAD 91                                   sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  21+ 6DAE                                      ClearCarryFlag
  21+ 6DAE B7          >                        or a
  22+ 6DAF              .LL31_SKIPSUB_6502:     FlipCarryFlag
  22+ 6DAF 3F          >                        ccf
  23+ 6DB0 CB 10                                rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  24+ 6DB2 DA A3 6D                             jp      c, .LL31_6502            ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  25+ 6DB5 78                                   ld      a,b
  26+ 6DB6 32 A2 6D                             ld      (RvarDiv),a
  27+ 6DB9 C9                                   ret                             ; RTS                    \ R left with remainder of division
  28+ 6DBA 91           .LL29_6502:             sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  29+ 6DBB                                      SetCarryFlag                    ; SEC                    \ Set the C flag to rotate into the result in R
  29+ 6DBB 37          >                        scf
  30+ 6DBC CB 10                                rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  31+ 6DBE DA A3 6D                             jp      c, .LL31_6502            ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  32+ 6DC1 78                                   ld      a,b                     ; RTS                    \ Return from the subroutine with R containing the
  33+ 6DC2 32 A2 6D                             ld      (RvarDiv),a                ; .
  34+ 6DC5 C9                                   ret                             ; .                      \ remainder of the division
  35+ 6DC6 3E FF        .LL2_6502:              ld      a,$FF                   ; LDA #255               \ The division is very close to 1, so return the closest
  36+ 6DC8 32 06 67                             ld      (varR),a                ; STA R                  \ possible answer to 256, i.e. R = 255
  37+ 6DCB 47                                   ld      b,a                     ; as we are using b as varR
  38+ 6DCC                                      SetCarryFlag                    ; we failed so need carry flag set
  38+ 6DCC 37          >                        scf
  39+ 6DCD C9                                   ret                             ; RTS                    \ Return from the subroutine
  40+ 6DCE                             DISPLAY "TODO : Merge Requ256mulAdivQ_6502  RequAmul256divQ"
  41+ 6DCE              ; Entry point if varQ is populated with demoninator
  42+ 6DCE              RequAmul256divQ:
  43+ 6DCE F5           BFRDIV:                 push	af
  44+ 6DCF 3A 05 67                             ld		a,(varQ)
  45+ 6DD2 4F                                   ld		c,a
  46+ 6DD3 F1                                   pop		af
  47+ 6DD4 FE 00                                cp		0
  48+ 6DD6 CA ED 6D                             jp		z, HLDIVC_0_BY	; fast exit if numerator is 0
  49+ 6DD9 2E 00        RequAmul256divC:        ld		l,0
  50+ 6DDB 67                                   ld		h,a
  51+ 6DDC 06 10        HL_Div_Cold:			ld b,16			; fast entry point if C and HL are already set
  52+ 6DDE AF                                   xor a
  53+ 6DDF 29           LOOPPOINT:	            add hl,hl
  54+ 6DE0 17                                   rla
  55+ 6DE1 B9                                   cp c
  56+ 6DE2 38 02                                jr c,SKIPINCSUB
  57+ 6DE4 2C                                   inc l
  58+ 6DE5 91                                   sub c
  59+ 6DE6 10 F7        SKIPINCSUB:             djnz LOOPPOINT
  60+ 6DE8 7D                                   ld		a,l
  61+ 6DE9 32 06 67                             ld 		(varR),a
  62+ 6DEC C9                                   ret
  63+ 6DED 32 06 67     HLDIVC_0_BY:            ld		(varR),a
  64+ 6DF0 C9                                   ret
  65+ 6DF1
  66+ 6DF1
  67+ 6DF1 21 05 67     Amul256DivQ:            ld      hl,varQ                 ; CMP Q                  \ If A >= Q, then the answer will not fit in one byte,
  68+ 6DF4 4E                                   ld      c,(hl)                  ; using c as Q var
  69+ 6DF5 B9                                   cp      c
  70+ 6DF6                                      FlipCarryFlag
  70+ 6DF6 3F          >                        ccf
  71+ 6DF7 DA 1F 6E                             jp      c, .LL2_6502            ; BCS LL2                \ so jump to LL2 to return 255
  72+ 6DFA 06 FE                                ld      b,$FE                   ; LDX #%11111110         \ Set R to have bits 1-7 set, so we can rotate through 7 loop iterations, getting a 1 each time, and then we use b as Rvar
  73+ 6DFC CB 27        .LL31_6502:             sla     a                       ; ASL A                  \ Shift A to the left
  74+ 6DFE DA 13 6E                             jp      c,.LL29_6502            ; BCS LL29               \ If bit 7 of A was set, then jump straight to the subtraction
  75+ 6E01                                      FlipCarryFlag                   ;                          If A < N, then C flag is set.
  75+ 6E01 3F          >                        ccf
  76+ 6E02                                      JumpIfALTNusng c, .LL31_SKIPSUB_6502 ; CMP Q              \ If A < Q, skip the following subtraction
  76+ 6E02 B9          >                        cp      c
  76+ 6E03 DA 08 6E    >                        jp		c, .LL31_SKIPSUB_6502
  77+ 6E06                                                                      ; BCC P%+4
  78+ 6E06 91                                   sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  79+ 6E07                                      ClearCarryFlag
  79+ 6E07 B7          >                        or a
  80+ 6E08              .LL31_SKIPSUB_6502:     FlipCarryFlag
  80+ 6E08 3F          >                        ccf
  81+ 6E09 CB 10                                rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  82+ 6E0B DA FC 6D                             jp      c, .LL31_6502           ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  83+ 6E0E 78                                   ld      a,b
  84+ 6E0F 32 06 67                             ld      (varR),a
  85+ 6E12 C9                                   ret                             ; RTS                    \ R left with remainder of division
  86+ 6E13 91           .LL29_6502:             sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
  87+ 6E14                                      SetCarryFlag                    ; SEC                    \ Set the C flag to rotate into the result in R
  87+ 6E14 37          >                        scf
  88+ 6E15 CB 10                                rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
  89+ 6E17 DA FC 6D                             jp      c, .LL31_6502           ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
  90+ 6E1A 78                                   ld      a,b                     ; RTS                    \ Return from the subroutine with R containing the
  91+ 6E1B 32 06 67                             ld      (varR),a                ; .
  92+ 6E1E C9                                   ret                             ; .                      \ remainder of the division
  93+ 6E1F 3E FF        .LL2_6502:              ld      a,$FF                   ; LDA #255               \ The division is very close to 1, so return the closest
  94+ 6E21 32 06 67                             ld      (varR),a                ; STA R                  \ possible answer to 256, i.e. R = 255
  95+ 6E24                                      SetCarryFlag                    ; we failed so need carry flag set
  95+ 6E24 37          >                        scf
  96+ 6E25 C9                                   ret                             ; RTS                    \ Return from the subroutine
  97+ 6E26
  98+ 6E26
  99+ 6E26 00           DIVD3B_SHIFT_REG:       DB      0
 100+ 6E27
 101+ 6E27 7B           DIV3B2DE:               ld      a,e                         ; load QRS with Z sign hi lo
 102+ 6E28 32 9D 6D                             ld      (varQRS+2),a
 103+ 6E2B 7A                                   ld      a,d
 104+ 6E2C E6 7F                                and     $7F
 105+ 6E2E 32 9C 6D                             ld      (varQRS+1),a
 106+ 6E31 7A                                   ld      a,d
 107+ 6E32 E6 80                                and     $80
 108+ 6E34 32 9B 6D                             ld      (varQRS),a
 109+ 6E37 C3 3D 6E                             jp      DVID3B
 110+ 6E3A              ; Calculate K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo) = A P[1 0 ] / (SRQ)
 111+ 6E3A              ; We don't use zlo and assume its already loaded into SRQ
 112+ 6E3A 32 07 66     DVID3B2:                ld      (varP+2),a                  ;STA P+2                \ Set P+2 = A
 113+ 6E3D                                                                          ; LDA INWK+6             \ Set Q = z_lo
 114+ 6E3D                                                                          ; STA Q
 115+ 6E3D                                                                          ; LDA INWK+7             \ Set R = z_hi
 116+ 6E3D                                                                          ; STA R
 117+ 6E3D                                                                          ; LDA INWK+8             \ Set S = z_sign
 118+ 6E3D                                                                          ; STA S
 119+ 6E3D              ;  Given the above assignments, we now want to calculate K(3 2 1 0) = P(2 1 0) / (S R Q)
 120+ 6E3D 3A 05 66     DVID3B:                 ld      a,(varP)                    ; LDA P                 \ Make sure P(2 1 0) is at least 1
 121+ 6E40 F6 01                                or      1                           ; ORA #1
 122+ 6E42 32 05 66                             ld      (varP),a                    ; STA P
 123+ 6E45              ;--- t = sign of P2 xor S (i.e. sign of result) ------------;
 124+ 6E45 3A 07 66                             ld      a,(varP+2)                  ; LDA P+2                \ Set T to the sign of P+2 * S (i.e. the sign of the
 125+ 6E48 21 07 67                             ld      hl, varS                    ; EOR S                  \ result) and store it in T
 126+ 6E4B AE                                   xor     (hl)
 127+ 6E4C E6 80                                and     $80                         ; AND #%10000000
 128+ 6E4E 32 21 67                             ld      (varT),a                    ; STA T
 129+ 6E51              ;--- New bit added to aviod a divde by 0 -------------------;
 130+ 6E51 3A 05 67     .CheckQRSAtLeast1:      ld      a,(varQ)                    ;
 131+ 6E54 21 06 67                             ld      hl,varR                     ;
 132+ 6E57 B6                                   or      (hl)                        ;
 133+ 6E58 C2 60 6E                             jp      nz,.DVL9Prep                ;
 134+ 6E5B 3E 01                                ld      a,1                         ;
 135+ 6E5D 32 05 67                             ld      (varQ),a                    ;
 136+ 6E60              ; A P(1) P(0) = ABS P(2 1 0)
 137+ 6E60 06 00        .DVL9Prep:              ld      b,0                         ; LDY #0                 \ Set Y = 0 to store the scale factor (use b as Y)
 138+ 6E62 3A 07 66                             ld      a,(varP+2)                  ; LDA P+2                \ Clear the sign bit of P+2, so the division can be done
 139+ 6E65 E6 7F                                and     $7F                         ; AND #%01111111         \ with positive numbers and we'll set the correct sign below, once all the maths is done
 140+ 6E67              ; We now shift (A P+1 P) left until A >= 64, counting the number of shifts in Y. This makes the top part of the division as large as possible, thus retaining as
 141+ 6E67              ; much accuracy as we can.  When we come to return the final result, we shift the result by the number of places in Y, and in the correct direction
 142+ 6E67                                      DISPLAY "TODO DVL9 and DVL6 move P and QRS into registers for faster shift"
 143+ 6E67              ;-- while A < 64 shift A P(1) P(0) -------------------------;
 144+ 6E67 FE 40        .DVL9:                  cp      64                          ; CMP #64                \ If A >= 64, jump down to DV14
 145+ 6E69 D2 7A 6E                             jp      nc, .DV14                   ; BCS DV14
 146+ 6E6C 21 05 66                             ld      hl,varP                     ; ASL P                  \ Shift (A P+1 P) to the left
 147+ 6E6F CB 26                                sla     (hl)
 148+ 6E71 23                                   inc     hl                          ; ROL P+1
 149+ 6E72 CB 16                                rl      (hl)
 150+ 6E74 CB 17                                rl      a                           ; ROL A
 151+ 6E76 04                                   inc     b                           ; INY                    \ Increment the scale factor in Y
 152+ 6E77 C3 67 6E                             jp      .DVL9                       ; BNE DVL9               \ Loop up to DVL9 (this BNE is effectively a JMP, as Y will never be zero)
 153+ 6E7A              ; If we get here, A >= 64 and contains the highest byte of the numerator, scaled up by the number of left shifts in Y (b in our code)
 154+ 6E7A 32 07 66     .DV14:                  ld      (varP+2),a                  ; Store A in P+2, so we now have the scaled value of the numerator in P(2 1 0)
 155+ 6E7D 3A 07 67                             ld      a,(varS)                    ; LDA S                  \ Set A = |S|
 156+ 6E80 E6 7F                                and     $7F                         ; AND #%01111111
 157+ 6E82                                      ;nop                                ;  BMI DV9               \ If bit 7 of A is set, jump down to DV9 (which can never happen)
 158+ 6E82              ; We now shift (S R Q) left until bit 7 of S is set, reducing Y by the number of shifts. This makes the bottom part of the division as large as possible, thus
 159+ 6E82              ; retaining as much accuracy as we can. When we come to return the final result, we shift the result by the total number of places in Y, and in the correct
 160+ 6E82              ; direction, to give us the correct result
 161+ 6E82              ; We set A to |S| above, so the following actually shifts (A R Q)
 162+ 6E82 05           .DVL6:                  dec     b                           ; DEY                    \ Decrement the scale factor in Y (b)
 163+ 6E83 21 05 67                             ld      hl,varQ                     ; ASL Q                  \ Shift (A R Q) to the left
 164+ 6E86 CB 26                                sla     (hl)                        ; .
 165+ 6E88 21 06 67                             ld      hl,varR                     ; ROL R
 166+ 6E8B CB 16                                rl      (hl)                        ; .
 167+ 6E8D CB 17                                rl      a                           ; ROL A
 168+ 6E8F F2 82 6E                             jp      p,.DVL6                     ; BPL DVL6               \ Loop up to DVL6 to do another shift, until bit 7 of A is set and we can't shift left any further
 169+ 6E92              ; We have now shifted both the numerator and denominator left as far as they will go, keeping a tally of the overall scale factor of the various shifts in Y. We
 170+ 6E92              ; can now divide just the two highest bytes to get our result
 171+ 6E92 32 05 67     .DV9:                   ld      (varQ),a                    ; STA Q                  \ Set Q = A, the highest byte of the denominator
 172+ 6E95 4F                                   ld      c,a                         ; for Requ256mulAdivQ_6502 as it uses c as Q
 173+ 6E96 78                                   ld      a,b                         ; preserve shift register in DEVD3B_SHIFT_REG
 174+ 6E97 32 26 6E                             ld      (DIVD3B_SHIFT_REG),a
 175+ 6E9A              ; Note in Requ256mulAdivQ_6502 we use B as R Var for shift register
 176+ 6E9A 06 FE                                ld      b,254                       ; LDA #254               \ Set R to have bits 1-7 set, so we can pass this to
 177+ 6E9C 32 06 67                             ld      (varR),a                    ; STA R                  \ LL31 to act as the bit counter in the division
 178+ 6E9F 3A 07 66                             ld      a,(varP+2)                  ; LDA P+2                \ Set A to the highest byte of the numerator
 179+ 6EA2 CD A3 6D                             call    Requ256mulAdivQ_6502        ; JSR LL31               \ Call LL31 to calculate: R = 256 * A / Q which means result is in b
 180+ 6EA5              ; The result of our division is now in R, so we just need to shift it back by the scale factor in Y
 181+ 6EA5                                      ZeroA                               ; LDA #0                \ Set K(3 2 1) = 0 to hold the result (we populate K)
 181+ 6EA5 AF          >                        xor a
 182+ 6EA6 32 19 67                             ld      (varK+1),a                  ; STA K+1               \ next)
 183+ 6EA9 32 1A 67                             ld      (varK+2),a                  ; STA K+2
 184+ 6EAC 32 1B 67                             ld      (varK+3),a                  ; STA K+3
 185+ 6EAF 3A 26 6E                             ld      a,(DIVD3B_SHIFT_REG)        ; TYA                   \ If Y (shift counter in b) is positive, jump to DV12
 186+ 6EB2 B7                                   or      a                           ; .                      we want to check the sign or if its zero
 187+ 6EB3 CA DE 6E                             jp      z,.DV13                     ; Optimisation to save a second jump from DV12 to DV13
 188+ 6EB6 F2 E9 6E                             jp      p,.DV12                     ; BPL DV12
 189+ 6EB9              ; If we get here then Y is negative, so we need to shift the result R to the left by Y places, and then set the correct sign for the result
 190+ 6EB9                                      DISPLAY "TODO check oprimisation here for var r  in b"
 191+ 6EB9 48                                   ld      c,b
 192+ 6EBA 3A 26 6E                             ld      a,(DIVD3B_SHIFT_REG)
 193+ 6EBD 47                                   ld      b,a
 194+ 6EBE 79                                   ld      a,c
 195+ 6EBF                                      ; OPTIM ld      a,(varR)                    ; LDA R                  \ Set A = R
 196+ 6EBF CB 27        .DVL8:                  sla     a                           ; ASL A                  \ Shift (K+3 K+2 K+1 A) left
 197+ 6EC1 21 19 67                             ld      hl,varK+1                   ; ROL K+1
 198+ 6EC4 CB 16                                rl      (hl)                        ; .
 199+ 6EC6 23                                   inc     hl                          ; ROL K+2
 200+ 6EC7 CB 16                                rl      (hl)                        ; .
 201+ 6EC9 23                                   inc     hl                          ; ROL K+3
 202+ 6ECA CB 16                                rl      (hl)                        ; .
 203+ 6ECC 04                                   inc     b                           ; INY                    \ Increment the scale factor in Y
 204+ 6ECD C2 BF 6E                             jp      nz,.DVL8                    ; BNE DVL8               \ Loop back to DVL8 until we have shifted left by Y places
 205+ 6ED0 32 18 67                             ld      (varK),a                    ; STA K                  \ Store A in K so the result is now in K(3 2 1 0)
 206+ 6ED3 3A 1B 67                             ld      a,(varK+3)                  ; LDA K+3                \ Set K+3 to the sign in T, which we set above to the
 207+ 6ED6 21 21 67                             ld      hl,varT                     ; ORA T                  \ correct sign for the result
 208+ 6ED9 B6                                   or      (hl)                        ; .
 209+ 6EDA 32 1B 67                             ld      (varK+3),a                  ; STA K+3
 210+ 6EDD C9                                   ret                                 ; RTS                    \ Return from the subroutine
 211+ 6EDE              ; If we get here then Y is zero, so we don't need to shift the result R, we just need to set the correct sign for the result
 212+ 6EDE 78           .DV13:                  ld      a,b; varR)                  ; LDA R                  \ Store R in K so the result is now in K(3 2 1 0)
 213+ 6EDF 32 18 67                             ld      (varK),a                    ; STA K
 214+ 6EE2 3A 21 67                             ld      a,(varT)                    ; LDA T                  \ Set K+3 to the sign in T, which we set above to the
 215+ 6EE5 32 1B 67                             ld      (varK+3),a                  ; STA K+3                \ correct sign for the result
 216+ 6EE8 C9                                   ret                                 ; RTS                    \ Return from the subroutine
 217+ 6EE9              ; if we get here U is positive but still could be zero, now this is handled in DV9
 218+ 6EE9              .DV12:                  ; nop                               ; BEQ DV13               \ We jumped here having set A to the scale factor in Y, so this jumps up to DV13 if Y = 0
 219+ 6EE9              ; If we get here then Y is positive and non-zero, so we need to shift the result R to the right by Y places and then set the correct sign for the result. We also
 220+ 6EE9              ; know that K(3 2 1) will stay 0, as we are shifting the lowest byte to the right, so no set bits will make their way into the top three bytes
 221+ 6EE9                                      ;ld      a,(varR)                    ; LDA R                  \ Set A = R
 222+ 6EE9 48                                   ld      c,b
 223+ 6EEA 3A 26 6E                             ld      a,(DIVD3B_SHIFT_REG)
 224+ 6EED 47                                   ld      b,a
 225+ 6EEE 79                                   ld      a,c
 226+ 6EEF CB 3F        .DVL10:                 srl     a                           ; LSR A                  \ Shift A right
 227+ 6EF1 05                                   dec     b                           ; DEY                    \ Decrement the scale factor in Y
 228+ 6EF2 C2 EF 6E                             jp      nz,.DVL10                   ; BNE DVL10              \ Loop back to DVL10 until we have shifted right by Y places
 229+ 6EF5 32 18 67                             ld      (varK),a                    ; STA K                  \ Store the shifted A in K so the result is now in K(3 2 1 0)
 230+ 6EF8 3A 21 67                             ld      a,(varT)                    ; LDA T                  \ Set K+3 to the sign in T, which we set above to the
 231+ 6EFB 32 1B 67                             ld      (varK+3),a                  ; STA K+3                \ correct sign for the result
 232+ 6EFE C9                                   ret                                 ; RTS                    \ Return from the subroutine
 233+ 6EFF              ;
 234+ 6EFF              ;   Set flags E to 11111110
 235+ 6EFF              ;   Loop:   A << 2
 236+ 6EFF              ;           if carry was 0
 237+ 6EFF              ;               if a >= D
 238+ 6EFF              ;                   A = A - D
 239+ 6EFF              ;                   clear carry (probably irrelevant really)
 240+ 6EFF              ;           else
 241+ 6EFF
 242+ 6EFF              ;               sla flags << bringing in carry of 1
 243+ 6EFF              ;               if bit 7 of flag was set then loop
 244+ 6EFF              ;                                        elase a = e and exit
 245+ 6EFF              ;
 246+ 6EFF              ; ">BC_Div_DE: BC = BC / DE. HL = remainder fast divide with unrolled loop BC/DE ==> BC, remainder in HL
 247+ 6EFF              ;
 248+ 6EFF              ;INPUTS: hl = dividend dbc = divisor
 249+ 6EFF              ;OUTPUTS: hl/de -> AHL = quotient CDE = remainder, Carryflag set if divide by 0
 250+ 6EFF
 251+ 6EFF 57           DVIDT:                  ld      d,a                     ; D = var P+1
 252+ 6F00 3A 05 67                             ld      a,(varQ)
 253+ 6F03 4F                                   ld      c,a                     ; C = var Q
 254+ 6F04 3A 05 66                             ld      a,(varP)
 255+ 6F07 5F                                   ld      e,a                     ; E = var P
 256+ 6F08                                      ; Need fast exists on ABS values
 257+ 6F08 7A           BAequDEdivC:            ld      a,d                     ; Fast exit is value is 0
 258+ 6F09 B3                                   or      e                       ; .
 259+ 6F0A 28 2A                                jr      z,.ResultIsZero         ; .
 260+ 6F0C 79                                   ld      a,c                     ; Fast exit is divide by 0
 261+ 6F0D A7                                   and     a                       ;
 262+ 6F0E 28 29                                jr      z,.ResultIsFFFF         ;
 263+ 6F10 7A           .SavSign:               ld      a,d                     ; preserve sign of result in var T
 264+ 6F11 A9                                   xor     c                       ;
 265+ 6F12 E6 80                                and     $80
 266+ 6F14 6F                                   ld      l,a                     ; l = var T
 267+ 6F15 3E 00                                ld      a,0
 268+ 6F17 06 10                                ld      b,16
 269+ 6F19                                      ShiftDELeft1
 269+ 6F19 CB 23       >               sla e
 269+ 6F1B CB 12       >               rl  d
 270+ 6F1D CB 21                                sla     c                       ; c = abs c
 271+ 6F1F CB 39                                srl     c
 272+ 6F21 CB 17        .DivideLoop:            rl      a
 273+ 6F23                                      JumpIfALTNusng c, .SkipSubtract
 273+ 6F23 B9          >                        cp      c
 273+ 6F24 DA 2A 6F    >                        jp		c, .SkipSubtract
 274+ 6F27                                      ClearCarryFlag
 274+ 6F27 B7          >                        or a
 275+ 6F28 99                                   sbc     c
 276+ 6F29                                      ClearCarryFlag
 276+ 6F29 B7          >                        or a
 277+ 6F2A 3F           .SkipSubtract:          ccf
 278+ 6F2B CB 13                                rl      e
 279+ 6F2D CB 12                                rl      d
 280+ 6F2F 05                                   dec     b
 281+ 6F30 20 EF                                jr      nz,.DivideLoop
 282+ 6F32 7B                                   ld      a,e
 283+ 6F33 B5                                   or      l
 284+ 6F34 42                                   ld      b,d
 285+ 6F35 C9                                   ret
 286+ 6F36              .ResultIsZero:          ZeroA
 286+ 6F36 AF          >                        xor a
 287+ 6F37 47                                   ld      b,a
 288+ 6F38 C9                                   ret
 289+ 6F39 3E FF        .ResultIsFFFF:          ld      a,$FF
 290+ 6F3B 47                                   ld      b,a
 291+ 6F3C C9                                   ret
 292+ 6F3D
 293+ 6F3D 57           DIV96:                  ld      d,a                     ; D = var P+1
 294+ 6F3E 3A 05 67                             ld      a,(varQ)
 295+ 6F41 0E 60                                ld      c,96                    ; C = var Q
 296+ 6F43 3A 05 66                             ld      a,(varP)
 297+ 6F46 5F                                   ld      e,a                     ; E = var P
 298+ 6F47                                      ; Need fast exists on ABS values
 299+ 6F47 7A           BAequDEdiv96            ld      a,d                     ; Fast exit is value is 0
 300+ 6F48 B3                                   or      e                       ; .
 301+ 6F49 28 26                                jr      z,.ResultIsZero         ; .
 302+ 6F4B 7A           .SavSign:               ld      a,d                     ; preserve sign of result in var T
 303+ 6F4C A9                                   xor     c                       ;
 304+ 6F4D E6 80                                and     $80
 305+ 6F4F 6F                                   ld      l,a                     ; l = var T
 306+ 6F50 3E 00                                ld      a,0
 307+ 6F52 06 10                                ld      b,16
 308+ 6F54                                      ShiftDELeft1
 308+ 6F54 CB 23       >               sla e
 308+ 6F56 CB 12       >               rl  d
 309+ 6F58 CB 21                                sla     c                       ; c = abs c
 310+ 6F5A CB 39                                srl     c
 311+ 6F5C CB 17        .DivideLoop:            rl      a
 312+ 6F5E                                      JumpIfALTNusng c, .SkipSubtract
 312+ 6F5E B9          >                        cp      c
 312+ 6F5F DA 65 6F    >                        jp		c, .SkipSubtract
 313+ 6F62                                      ClearCarryFlag
 313+ 6F62 B7          >                        or a
 314+ 6F63 99                                   sbc     c
 315+ 6F64                                      ClearCarryFlag
 315+ 6F64 B7          >                        or a
 316+ 6F65 3F           .SkipSubtract:          ccf
 317+ 6F66 CB 13                                rl      e
 318+ 6F68 CB 12                                rl      d
 319+ 6F6A 05                                   dec     b
 320+ 6F6B 20 EF                                jr      nz,.DivideLoop
 321+ 6F6D 7B                                   ld      a,e
 322+ 6F6E B5                                   or      l
 323+ 6F6F 42                                   ld      b,d
 324+ 6F70 C9                                   ret
 325+ 6F71              .ResultIsZero:          ZeroA
 325+ 6F71 AF          >                        xor a
 326+ 6F72 47                                   ld      b,a
 327+ 6F73 C9                                   ret
 328+ 6F74
 329+ 6F74 14           Div16by24usgn:          inc     d                           ; can we fast retu
 330+ 6F75 15                                   dec     d
 331+ 6F76 20 13                                jr      nz,.ResultZero
 332+ 6F78 50 59                                ld      de,bc                       ; so prep for bc/de
 333+ 6F7A 44 4D                                ld      bc,hl
 334+ 6F7C 7A           .div16by16usng:         ld      a,d
 335+ 6F7D B3                                   or      e
 336+ 6F7E 28 10                                jr      z,.DivideByZero
 337+ 6F80 14                                   inc     d
 338+ 6F81 15                                   dec     d
 339+ 6F82 CD D4 70                             call    BC_Div_DE
 340+ 6F85                                      ZeroA
 340+ 6F85 AF          >                        xor a
 341+ 6F86 EB                                   ex      de,hl                       ; de = remainder (need to fix c after hl = nothing of worth)
 342+ 6F87 60 69                                ld      hl,bc                       ; hl = result (a is zero from above)
 343+ 6F89 4F                                   ld      c,a                         ; now fix c
 344+ 6F8A C9                                   ret
 345+ 6F8B AF           .ResultZero:            xor     a                           ; set AHL to 0 as d was 0 so h is zero
 346+ 6F8C 4F                                   ld      c,a                         ; c = 0
 347+ 6F8D 67                                   ld      h,a
 348+ 6F8E 6F                                   ld      l,a
 349+ 6F8F C9                                   ret
 350+ 6F90 3E FF        .DivideByZero:          ld      a,$FF
 351+ 6F92 67                                   ld      h,a
 352+ 6F93 6F                                   ld      l,a
 353+ 6F94                                      SetCarryFlag
 353+ 6F94 37          >                        scf
 354+ 6F95 C9                                   ret
 355+ 6F96
 356+ 6F96              ;DIVD4 P-R=A/Qunsg  \P.R = A/Q unsigned called by Hall
 357+ 6F96                          IFDEF HLEquAmul256DivD_Used
 358+ 6F96 ~            HLEquAmul256DivD:       ld		b,8							; counter
 359+ 6F96 ~                                    sla		a							;
 360+ 6F96 ~                                    ld		h,a							; r a * 2 we will build result in hl
 361+ 6F96 ~            .DivideLoop:            rl		a							; a = a * 2
 362+ 6F96 ~                                    jr      c,.StraightToSubtraction    ; jump on carry to subtraction
 363+ 6F96 ~                                    cp      d                           ; what was var Q
 364+ 6F96 ~                                    jr		c,.SkipSubtraction	        ; if a < d skip subtraction, note this will come to skip subtraction with carry the wrong way round
 365+ 6F96 ~            .StraightToSubtraction: ClearCarryFlag                      ; in 6502 the borrow flag is inverted carry, z80 just uses carry so we need to clear it
 366+ 6F96 ~                                    sbc     a,d                         ; a = a - q
 367+ 6F96 ~                                    ClearCarryFlag                      ; set carry so it gets shifted into bit 0 of b. we do this as we have to flip carry due to jr c from earlier cp d
 368+ 6F96 ~            .SkipSubtraction:       ccf                                 ; we need to do this as 6502 does opposite on carry, i.e. if we jumped direct here then carry would be set in z80
 369+ 6F96 ~                                    rl      h                           ; roll d left bringing in carry if there was an sbc performed
 370+ 6F96 ~                                    djnz    .DivideLoop                 ; 8 cycles
 371+ 6F96 ~            .CalculateRemainder:    cp      d                           ; calulate 256 * a / d if q >= q then answer will not fit in one byte d is still set, a holds remainder to be subtracted
 372+ 6F96 ~                                    jr      nc, .RemainderTooBig
 373+ 6F96 ~                                    ClearCarryFlag                      ; remove carry as the previous cp will have set it and mess up the sla in the remainder loop
 374+ 6F96 ~            .InitRemainderLoop:     ld      b,%11111110                 ; loop for bits 1 to 7
 375+ 6F96 ~                                    ld      l,b                         ; and set l to capture result bits (R)
 376+ 6F96 ~            .RemainderLoop:         sla     a                           ; shift a left
 377+ 6F96 ~                                    jr      c, .RemainderSubtraction    ; if there was a carry go to subtraction
 378+ 6F96 ~                                    cp      d                           ; if a < d then skip subtraction
 379+ 6F96 ~                                    jr      c,.RemainderSkipSubtract    ; .
 380+ 6F96 ~                                    sbc     d                           ; a > q so a = a - q, carry will be clear here
 381+ 6F96 ~            .RemainderSkipSubtract: ccf                                 ; as the jr used z80 we need to flip the carry to behave like 6502
 382+ 6F96 ~                                    rl      l                           ; rotate counter to the left
 383+ 6F96 ~                                    jr      c, .RemainderLoop           ; if there was a bit pushed to carry then loop
 384+ 6F96 ~                                    ret
 385+ 6F96 ~            .RemainderSubtraction:  sbc     d                           ; as the carry came from an sla we want to retain it
 386+ 6F96 ~                                    SetCarryFlag                        ; roll in a carry bit to result
 387+ 6F96 ~                                    rl      l                           ;
 388+ 6F96 ~                                    jr      c, .RemainderLoop           ; and loop if there was a carry bit that came out
 389+ 6F96 ~                                    ret
 390+ 6F96 ~            .RemainderTooBig:       ld      l,$FF                       ; now hl = result
 391+ 6F96 ~                                    ret
 392+ 6F96                          ENDIF
 393+ 6F96
 394+ 6F96 BA           AEquAmul256DivD:        cp      d
 395+ 6F97 28 1D                                jr      z,.BothSame
 396+ 6F99 30 1E                                jr      nc,.DgtA
 397+ 6F9B 1E FE                                ld      e,%11111110                 ; Set R to have bits 1-7 set, so we can rotate through 7
 398+ 6F9D CB 27        .DivideLoop:            sla     a
 399+ 6F9F 38 0D                                jr      c,.LL29
 400+ 6FA1                                      JumpIfALTNusng  d, .SkipSub         ; will jump if carry set, so we need to reset on the rol
 400+ 6FA1 BA          >                        cp      d
 400+ 6FA2 DA A7 6F    >                        jp		c, .SkipSub
 401+ 6FA5 92                                   sub     d
 402+ 6FA6                                      ClearCarryFlag                      ; reset clarry as it will be complimented for rotate as 6502 does carry flags inverted
 402+ 6FA6 B7          >                        or a
 403+ 6FA7              .SkipSub:               FlipCarryFlag                       ; if we did the subtract the carry will be clear so we need to invert to roll in.
 403+ 6FA7 3F          >                        ccf
 404+ 6FA8 CB 13                                rl      e
 405+ 6FAA 38 F1                                jr      c,.DivideLoop
 406+ 6FAC 7B                                   ld      a,e
 407+ 6FAD C9                                   ret
 408+ 6FAE 92           .LL29:                  sub     d                           ; A >= Q, so set A = A - Q
 409+ 6FAF                                      SetCarryFlag                        ; Set the C flag to rotate into the result in R
 409+ 6FAF 37          >                        scf
 410+ 6FB0 CB 13                                rl      e                           ; rotate counter e left
 411+ 6FB2 38 E9                                jr      c,.DivideLoop               ; if a bit was spat off teh end then loop
 412+ 6FB4 7B                                   ld      a,e                         ; stick result in a
 413+ 6FB5 C9                                   ret
 414+ 6FB6 3E 01        .BothSame:              ld  a,1
 415+ 6FB8 C9                                   ret
 416+ 6FB9 3E FF        .DgtA:                  ld  a,255                           ; Fail with FF as result
 417+ 6FBB C9                                   ret
 418+ 6FBC
 419+ 6FBC              ; Divide 8-bit values
 420+ 6FBC              ; In: Divide E by divider C
 421+ 6FBC              ; Out: A = result, B = rest
 422+ 6FBC              ;
 423+ 6FBC              ;;;Div8:
 424+ 6FBC              ;;;    xor a
 425+ 6FBC              ;;;    ld b,8
 426+ 6FBC              ;;;Div8_Loop:
 427+ 6FBC              ;;;    rl e
 428+ 6FBC              ;;;    rla
 429+ 6FBC              ;;;    sub c
 430+ 6FBC              ;;;    jr nc,Div8_NoAdd
 431+ 6FBC              ;;;    add a,c
 432+ 6FBC              ;;;Div8_NoAdd:
 433+ 6FBC              ;;;    djnz Div8_Loop
 434+ 6FBC              ;;;    ld b,a0
 435+ 6FBC              ;;;    ld a,e
 436+ 6FBC              ;;;    rla
 437+ 6FBC              ;;;    cpl
 438+ 6FBC              ;;;    ret
 439+ 6FBC
 440+ 6FBC              ;;Inputs: DE is the numerator, BC is the divisor
 441+ 6FBC              ;;Outputs: DE is the result
 442+ 6FBC              ;;         A is a copy of E
 443+ 6FBC              ;;         HL is the remainder
 444+ 6FBC              ;;         BC is not changed
 445+ 6FBC              ;; so DE = DE /BC
 446+ 6FBC              ;140 bytes
 447+ 6FBC              ;145cc
 448+ 6FBC
 449+ 6FBC              MacroDEDivBC:       MACRO
 450+ 6FBC ~                                rla
 451+ 6FBC ~                                adc     hl,hl
 452+ 6FBC ~                                sbc     hl,bc
 453+ 6FBC ~                                jr      nc,$+3
 454+ 6FBC ~                                add     hl,bc
 455+ 6FBC                                  ENDM
 456+ 6FBC
 457+ 6FBC AF           DEequDEDivBC:       xor a
 458+ 6FBD ED 62                            sbc hl,hl
 459+ 6FBF 7A                               ld a,d
 460+ 6FC0                                  MacroDEDivBC
 460+ 6FC0 17          >                    rla
 460+ 6FC1 ED 6A       >                    adc     hl,hl
 460+ 6FC3 ED 42       >                    sbc     hl,bc
 460+ 6FC5 30 01       >                    jr      nc,$+3
 460+ 6FC7 09          >                    add     hl,bc
 461+ 6FC8                                  MacroDEDivBC
 461+ 6FC8 17          >                    rla
 461+ 6FC9 ED 6A       >                    adc     hl,hl
 461+ 6FCB ED 42       >                    sbc     hl,bc
 461+ 6FCD 30 01       >                    jr      nc,$+3
 461+ 6FCF 09          >                    add     hl,bc
 462+ 6FD0                                  MacroDEDivBC
 462+ 6FD0 17          >                    rla
 462+ 6FD1 ED 6A       >                    adc     hl,hl
 462+ 6FD3 ED 42       >                    sbc     hl,bc
 462+ 6FD5 30 01       >                    jr      nc,$+3
 462+ 6FD7 09          >                    add     hl,bc
 463+ 6FD8                                  MacroDEDivBC
 463+ 6FD8 17          >                    rla
 463+ 6FD9 ED 6A       >                    adc     hl,hl
 463+ 6FDB ED 42       >                    sbc     hl,bc
 463+ 6FDD 30 01       >                    jr      nc,$+3
 463+ 6FDF 09          >                    add     hl,bc
 464+ 6FE0                                  MacroDEDivBC
 464+ 6FE0 17          >                    rla
 464+ 6FE1 ED 6A       >                    adc     hl,hl
 464+ 6FE3 ED 42       >                    sbc     hl,bc
 464+ 6FE5 30 01       >                    jr      nc,$+3
 464+ 6FE7 09          >                    add     hl,bc
 465+ 6FE8                                  MacroDEDivBC
 465+ 6FE8 17          >                    rla
 465+ 6FE9 ED 6A       >                    adc     hl,hl
 465+ 6FEB ED 42       >                    sbc     hl,bc
 465+ 6FED 30 01       >                    jr      nc,$+3
 465+ 6FEF 09          >                    add     hl,bc
 466+ 6FF0                                  MacroDEDivBC
 466+ 6FF0 17          >                    rla
 466+ 6FF1 ED 6A       >                    adc     hl,hl
 466+ 6FF3 ED 42       >                    sbc     hl,bc
 466+ 6FF5 30 01       >                    jr      nc,$+3
 466+ 6FF7 09          >                    add     hl,bc
 467+ 6FF8                                  MacroDEDivBC
 467+ 6FF8 17          >                    rla
 467+ 6FF9 ED 6A       >                    adc     hl,hl
 467+ 6FFB ED 42       >                    sbc     hl,bc
 467+ 6FFD 30 01       >                    jr      nc,$+3
 467+ 6FFF 09          >                    add     hl,bc
 468+ 7000 17                               rla
 469+ 7001 2F                               cpl
 470+ 7002 57                               ld d,a
 471+ 7003
 472+ 7003 7B                               ld a,e
 473+ 7004                                  MacroDEDivBC
 473+ 7004 17          >                    rla
 473+ 7005 ED 6A       >                    adc     hl,hl
 473+ 7007 ED 42       >                    sbc     hl,bc
 473+ 7009 30 01       >                    jr      nc,$+3
 473+ 700B 09          >                    add     hl,bc
 474+ 700C                                  MacroDEDivBC
 474+ 700C 17          >                    rla
 474+ 700D ED 6A       >                    adc     hl,hl
 474+ 700F ED 42       >                    sbc     hl,bc
 474+ 7011 30 01       >                    jr      nc,$+3
 474+ 7013 09          >                    add     hl,bc
 475+ 7014                                  MacroDEDivBC
 475+ 7014 17          >                    rla
 475+ 7015 ED 6A       >                    adc     hl,hl
 475+ 7017 ED 42       >                    sbc     hl,bc
 475+ 7019 30 01       >                    jr      nc,$+3
 475+ 701B 09          >                    add     hl,bc
 476+ 701C                                  MacroDEDivBC
 476+ 701C 17          >                    rla
 476+ 701D ED 6A       >                    adc     hl,hl
 476+ 701F ED 42       >                    sbc     hl,bc
 476+ 7021 30 01       >                    jr      nc,$+3
 476+ 7023 09          >                    add     hl,bc
 477+ 7024                                  MacroDEDivBC
 477+ 7024 17          >                    rla
 477+ 7025 ED 6A       >                    adc     hl,hl
 477+ 7027 ED 42       >                    sbc     hl,bc
 477+ 7029 30 01       >                    jr      nc,$+3
 477+ 702B 09          >                    add     hl,bc
 478+ 702C                                  MacroDEDivBC
 478+ 702C 17          >                    rla
 478+ 702D ED 6A       >                    adc     hl,hl
 478+ 702F ED 42       >                    sbc     hl,bc
 478+ 7031 30 01       >                    jr      nc,$+3
 478+ 7033 09          >                    add     hl,bc
 479+ 7034                                  MacroDEDivBC
 479+ 7034 17          >                    rla
 479+ 7035 ED 6A       >                    adc     hl,hl
 479+ 7037 ED 42       >                    sbc     hl,bc
 479+ 7039 30 01       >                    jr      nc,$+3
 479+ 703B 09          >                    add     hl,bc
 480+ 703C                                  MacroDEDivBC
 480+ 703C 17          >                    rla
 480+ 703D ED 6A       >                    adc     hl,hl
 480+ 703F ED 42       >                    sbc     hl,bc
 480+ 7041 30 01       >                    jr      nc,$+3
 480+ 7043 09          >                    add     hl,bc
 481+ 7044 17                               rla
 482+ 7045 2F                               cpl
 483+ 7046 5F                               ld e,a
 484+ 7047 C9                               ret
 485+ 7048              ;divdide by 16 using undocumented instrunctions
 486+ 7048              ;Input: BC = Dividend, DE = Divisor, HL = 0
 487+ 7048              ;Output: BC = Quotient, HL = Remainder
 488+ 7048              ; Our use
 489+ 7048              ; BC = A0
 490+ 7048              ; DE = 0C
 491+ 7048              ; so BC = a * 256 / C
 492+ 7048              DIV16Amul256dCUNDOC:    JumpIfAGTENusng	  c,DEV16ATooLarge                                          ; first off if a > c ten return 255
 492+ 7048 B9          >                        cp     c
 492+ 7049 D2 74 70    >                        jp		nc,DEV16ATooLarge
 493+ 704C 47                                   ld      b,a
 494+ 704D 59                                   ld      e,c
 495+ 704E 0E 00                                ld      c,0
 496+ 7050 16 00                                ld      d,0
 497+ 7052 C3 5F 70                             jp      DIV16UNDOC
 498+ 7055 47           DIV16Amul256dQUNDOC:    ld      b,a
 499+ 7056 0E 00                                ld      c,0
 500+ 7058 21 05 67                             ld      hl,varQ
 501+ 705B 7E                                   ld      a,(hl)
 502+ 705C 16 00                                ld      d,0
 503+ 705E 5F                                   ld      e,a
 504+ 705F              DIV16BCDivDEUNDOC:
 505+ 705F 21 00 00     DIV16UNDOC:             ld      hl,0
 506+ 7062 78                                   ld      a,b
 507+ 7063 06 10                                ld      b,16
 508+ 7065 CB 31        DIV16UNDOCLOOP:         sll	c		; unroll 16 times
 509+ 7067 17                                   rla			; ...
 510+ 7068 ED 6A                                adc	hl,hl		; ...
 511+ 706A ED 52                                sbc	hl,de		; ...
 512+ 706C 30 02                                jr	nc,DIV16UNDOCSKIP		; ...
 513+ 706E 19                                   add	hl,de		; ...
 514+ 706F 0D                                   dec	c		; ...
 515+ 7070 10 F3        DIV16UNDOCSKIP:         djnz DIV16UNDOCLOOP
 516+ 7072 47                                   ld   b,a
 517+ 7073 C9                                   ret
 518+ 7074 01 FF 00     DEV16ATooLarge:         ld     bc,$00FF
 519+ 7077 C9                                   ret
 520+ 7078              ; switch to logarithm version
 521+ 7078              ; "> asm_div8 C_Div_D - C is the numerator, D is the denominator, A is the remainder, B is 0, C is the result of C/D,D,E,H,L are not changed"
 522+ 7078 06 08        asm_div8:               ld b,8
 523+ 707A AF                                   xor a
 524+ 707B CB 21        .div8_loop:	            sla c
 525+ 707D 17                                   rla
 526+ 707E BA                                   cp d
 527+ 707F 38 02                                jr c,.div8_skip
 527+ 7081
 528+ 7081 0C                                   inc c
 529+ 7082 92                                   sub d
 530+ 7083 10 F6        .div8_skip:	            djnz .div8_loop
 531+ 7085 C9                                   ret
 532+ 7086              ; ">asm_div16: HL_Div_C: HL is the numerator,  C is the denominator, output A is the remainder, B is 0, C,DE is not changedHL is the quotient"
 533+ 7086 06 10        asm_div16:              ld b,16
 534+ 7088 AF                                   xor a
 535+ 7089 CB 25        div16_loop:	            sla l
 536+ 708B CB 14                                rl	h
 537+ 708D              ;    add hl,hl
 538+ 708D 17                                   rla
 539+ 708E B9                                   cp c
 540+ 708F 38 02                                jr c,div16_skip
 541+ 7091 2C                                   inc l
 542+ 7092 91                                   sub c
 543+ 7093 10 F4        div16_skip:		        djnz div16_loop
 544+ 7095 C9                                   ret
 545+ 7096              ;
 546+ 7096              ; Divide 16-bit values (with 16-bit result)
 547+ 7096              ; In: Divide BC by divider DE
 548+ 7096              ; Out: BC = result, HL = rest
 549+ 7096              ;
 550+ 7096              HLDivC_MACRO: 	        MACRO
 551+ 7096 ~                                    add	    hl,hl		; unroll 16 times
 552+ 7096 ~                                    rla				; ...
 553+ 7096 ~                                    jr      c,      .DoSubInc
 554+ 7096 ~                                    cp	    c			; ...
 555+ 7096 ~                                    jr      c,      .NoSubInc
 556+ 7096 ~            .DoSubInc:              sub	c			; ...
 557+ 7096 ~                                    inc	l			; ...
 558+ 7096 ~            .NoSubInc:
 559+ 7096                                      ENDM
 560+ 7096
 561+ 7096              EDivC_Iteration:        MACRO
 562+ 7096 ~                                    rl  e
 563+ 7096 ~                                    rla
 564+ 7096 ~                                    sub c
 565+ 7096 ~                                    jr  nc,.Div8_NoAdd
 566+ 7096 ~                                    add a,c
 567+ 7096 ~            .Div8_NoAdd:
 568+ 7096                                      ENDM
 569+ 7096
 570+ 7096              ; Switch to a logarithm version
 571+ 7096              ; Divide E by divider C Out: A = result, B = rest
 572+ 7096              E_Div_C:                ZeroA
 572+ 7096 AF          >                        xor a
 573+ 7097                                      EDivC_Iteration
 573+ 7097 CB 13       >                        rl  e
 573+ 7099 17          >                        rla
 573+ 709A 91          >                        sub c
 573+ 709B 30 01       >                        jr  nc,.Div8_NoAdd
 573+ 709D 81          >                        add a,c
 573+ 709E             >.Div8_NoAdd:
 574+ 709E                                      EDivC_Iteration
 574+ 709E CB 13       >                        rl  e
 574+ 70A0 17          >                        rla
 574+ 70A1 91          >                        sub c
 574+ 70A2 30 01       >                        jr  nc,.Div8_NoAdd
 574+ 70A4 81          >                        add a,c
 574+ 70A5             >.Div8_NoAdd:
 575+ 70A5                                      EDivC_Iteration
 575+ 70A5 CB 13       >                        rl  e
 575+ 70A7 17          >                        rla
 575+ 70A8 91          >                        sub c
 575+ 70A9 30 01       >                        jr  nc,.Div8_NoAdd
 575+ 70AB 81          >                        add a,c
 575+ 70AC             >.Div8_NoAdd:
 576+ 70AC                                      EDivC_Iteration
 576+ 70AC CB 13       >                        rl  e
 576+ 70AE 17          >                        rla
 576+ 70AF 91          >                        sub c
 576+ 70B0 30 01       >                        jr  nc,.Div8_NoAdd
 576+ 70B2 81          >                        add a,c
 576+ 70B3             >.Div8_NoAdd:
 577+ 70B3                                      EDivC_Iteration
 577+ 70B3 CB 13       >                        rl  e
 577+ 70B5 17          >                        rla
 577+ 70B6 91          >                        sub c
 577+ 70B7 30 01       >                        jr  nc,.Div8_NoAdd
 577+ 70B9 81          >                        add a,c
 577+ 70BA             >.Div8_NoAdd:
 578+ 70BA                                      EDivC_Iteration
 578+ 70BA CB 13       >                        rl  e
 578+ 70BC 17          >                        rla
 578+ 70BD 91          >                        sub c
 578+ 70BE 30 01       >                        jr  nc,.Div8_NoAdd
 578+ 70C0 81          >                        add a,c
 578+ 70C1             >.Div8_NoAdd:
 579+ 70C1                                      EDivC_Iteration
 579+ 70C1 CB 13       >                        rl  e
 579+ 70C3 17          >                        rla
 579+ 70C4 91          >                        sub c
 579+ 70C5 30 01       >                        jr  nc,.Div8_NoAdd
 579+ 70C7 81          >                        add a,c
 579+ 70C8             >.Div8_NoAdd:
 580+ 70C8                                      EDivC_Iteration
 580+ 70C8 CB 13       >                        rl  e
 580+ 70CA 17          >                        rla
 580+ 70CB 91          >                        sub c
 580+ 70CC 30 01       >                        jr  nc,.Div8_NoAdd
 580+ 70CE 81          >                        add a,c
 580+ 70CF             >.Div8_NoAdd:
 581+ 70CF 47                                   ld      b,a
 582+ 70D0 7B                                   ld      a,e
 583+ 70D1 17                                   rla
 584+ 70D2 2F                                   cpl
 585+ 70D3 C9                                   ret
 586+ 70D4
 587+ 70D4
 588+ 70D4              BCDIVDE_Iteration:      MACRO
 589+ 70D4 ~                                    rla
 590+ 70D4 ~                                    adc	    hl,hl
 591+ 70D4 ~                                    add	    hl,de
 592+ 70D4 ~                                    jr	    c,1F
 593+ 70D4 ~                                    sbc	    hl,de
 594+ 70D4 ~            1:
 595+ 70D4                                      ENDM
 596+ 70D4
 597+ 70D4
 598+ 70D4              ; ">BC_Div_DE: BC = BC / DE. HL = remainder fast divide with unrolled loop"
 599+ 70D4              ;BC/DE ==> BC, remainder in HL
 600+ 70D4              ;NOTE: BC/0 returns 0 as the quotient.
 601+ 70D4              ;min: 738cc
 602+ 70D4              ;max: 898cc
 603+ 70D4              ;avg: 818cc
 604+ 70D4              ;144 bytes
 605+ 70D4 AF           BC_Div_DE:              xor a
 606+ 70D5 67                                   ld h,a
 607+ 70D6 6F                                   ld l,a
 608+ 70D7 93                                   sub e
 609+ 70D8 5F                                   ld e,a
 610+ 70D9 9F                                   sbc a,a
 611+ 70DA 92                                   sub d
 612+ 70DB 57                                   ld d,a
 613+ 70DC 78                                   ld a,b
 614+ 70DD                                      BCDIVDE_Iteration
 614+ 70DD 17          >                        rla
 614+ 70DE ED 6A       >                        adc	    hl,hl
 614+ 70E0 19          >                        add	    hl,de
 614+ 70E1 38 02       >                        jr	    c,1F
 614+ 70E3 ED 52       >                        sbc	    hl,de
 614+ 70E5             >1:
 615+ 70E5                                      BCDIVDE_Iteration
 615+ 70E5 17          >                        rla
 615+ 70E6 ED 6A       >                        adc	    hl,hl
 615+ 70E8 19          >                        add	    hl,de
 615+ 70E9 38 02       >                        jr	    c,1F
 615+ 70EB ED 52       >                        sbc	    hl,de
 615+ 70ED             >1:
 616+ 70ED                                      BCDIVDE_Iteration
 616+ 70ED 17          >                        rla
 616+ 70EE ED 6A       >                        adc	    hl,hl
 616+ 70F0 19          >                        add	    hl,de
 616+ 70F1 38 02       >                        jr	    c,1F
 616+ 70F3 ED 52       >                        sbc	    hl,de
 616+ 70F5             >1:
 617+ 70F5                                      BCDIVDE_Iteration
 617+ 70F5 17          >                        rla
 617+ 70F6 ED 6A       >                        adc	    hl,hl
 617+ 70F8 19          >                        add	    hl,de
 617+ 70F9 38 02       >                        jr	    c,1F
 617+ 70FB ED 52       >                        sbc	    hl,de
 617+ 70FD             >1:
 618+ 70FD                                      BCDIVDE_Iteration
 618+ 70FD 17          >                        rla
 618+ 70FE ED 6A       >                        adc	    hl,hl
 618+ 7100 19          >                        add	    hl,de
 618+ 7101 38 02       >                        jr	    c,1F
 618+ 7103 ED 52       >                        sbc	    hl,de
 618+ 7105             >1:
 619+ 7105                                      BCDIVDE_Iteration
 619+ 7105 17          >                        rla
 619+ 7106 ED 6A       >                        adc	    hl,hl
 619+ 7108 19          >                        add	    hl,de
 619+ 7109 38 02       >                        jr	    c,1F
 619+ 710B ED 52       >                        sbc	    hl,de
 619+ 710D             >1:
 620+ 710D                                      BCDIVDE_Iteration
 620+ 710D 17          >                        rla
 620+ 710E ED 6A       >                        adc	    hl,hl
 620+ 7110 19          >                        add	    hl,de
 620+ 7111 38 02       >                        jr	    c,1F
 620+ 7113 ED 52       >                        sbc	    hl,de
 620+ 7115             >1:
 621+ 7115                                      BCDIVDE_Iteration
 621+ 7115 17          >                        rla
 621+ 7116 ED 6A       >                        adc	    hl,hl
 621+ 7118 19          >                        add	    hl,de
 621+ 7119 38 02       >                        jr	    c,1F
 621+ 711B ED 52       >                        sbc	    hl,de
 621+ 711D             >1:
 622+ 711D 17                                   rla
 623+ 711E 47                                   ld b,a
 624+ 711F 79                                   ld a,c
 625+ 7120                                      BCDIVDE_Iteration
 625+ 7120 17          >                        rla
 625+ 7121 ED 6A       >                        adc	    hl,hl
 625+ 7123 19          >                        add	    hl,de
 625+ 7124 38 02       >                        jr	    c,1F
 625+ 7126 ED 52       >                        sbc	    hl,de
 625+ 7128             >1:
 626+ 7128                                      BCDIVDE_Iteration
 626+ 7128 17          >                        rla
 626+ 7129 ED 6A       >                        adc	    hl,hl
 626+ 712B 19          >                        add	    hl,de
 626+ 712C 38 02       >                        jr	    c,1F
 626+ 712E ED 52       >                        sbc	    hl,de
 626+ 7130             >1:
 627+ 7130                                      BCDIVDE_Iteration
 627+ 7130 17          >                        rla
 627+ 7131 ED 6A       >                        adc	    hl,hl
 627+ 7133 19          >                        add	    hl,de
 627+ 7134 38 02       >                        jr	    c,1F
 627+ 7136 ED 52       >                        sbc	    hl,de
 627+ 7138             >1:
 628+ 7138                                      BCDIVDE_Iteration
 628+ 7138 17          >                        rla
 628+ 7139 ED 6A       >                        adc	    hl,hl
 628+ 713B 19          >                        add	    hl,de
 628+ 713C 38 02       >                        jr	    c,1F
 628+ 713E ED 52       >                        sbc	    hl,de
 628+ 7140             >1:
 629+ 7140                                      BCDIVDE_Iteration
 629+ 7140 17          >                        rla
 629+ 7141 ED 6A       >                        adc	    hl,hl
 629+ 7143 19          >                        add	    hl,de
 629+ 7144 38 02       >                        jr	    c,1F
 629+ 7146 ED 52       >                        sbc	    hl,de
 629+ 7148             >1:
 630+ 7148                                      BCDIVDE_Iteration
 630+ 7148 17          >                        rla
 630+ 7149 ED 6A       >                        adc	    hl,hl
 630+ 714B 19          >                        add	    hl,de
 630+ 714C 38 02       >                        jr	    c,1F
 630+ 714E ED 52       >                        sbc	    hl,de
 630+ 7150             >1:
 631+ 7150                                      BCDIVDE_Iteration
 631+ 7150 17          >                        rla
 631+ 7151 ED 6A       >                        adc	    hl,hl
 631+ 7153 19          >                        add	    hl,de
 631+ 7154 38 02       >                        jr	    c,1F
 631+ 7156 ED 52       >                        sbc	    hl,de
 631+ 7158             >1:
 632+ 7158                                      BCDIVDE_Iteration
 632+ 7158 17          >                        rla
 632+ 7159 ED 6A       >                        adc	    hl,hl
 632+ 715B 19          >                        add	    hl,de
 632+ 715C 38 02       >                        jr	    c,1F
 632+ 715E ED 52       >                        sbc	    hl,de
 632+ 7160             >1:
 633+ 7160 17                                   rla
 634+ 7161 4F                                   ld c,a
 635+ 7162 C9                                   ret
 636+ 7163 78           Floor_DivQSigned:       ld      a,b             ; save resultant sign
 637+ 7164 AA                                   xor     d               ;
 638+ 7165 E6 80                                and     $80             ;
 639+ 7167 DD 67                                ld      ixh,a           ;
 640+ 7169 78                                   ld      a,b
 641+ 716A E6 7F                                and     $7F
 642+ 716C 47                                   ld      b,a
 643+ 716D 7A                                   ld      a,d
 644+ 716E E6 7F                                and     $7F
 645+ 7170 57                                   ld      d,a
 646+ 7171 CD 79 71                             call    Floor_DivQ
 647+ 7174 78                                   ld      a,b
 648+ 7175 DD B4                                or      ixh
 649+ 7177 47                                   ld      b,a
 650+ 7178 C9                                   ret
 651+ 7179
 652+ 7179
 653+ 7179
 654+ 7179              ; BC = BC / DE
 655+ 7179              ; HL = BC % DE
 656+ 7179              ; if HL > 0 BC -= 1
 657+ 7179 78           Floor_DivQ:             ld      a,b
 658+ 717A B1                                   or      c
 659+ 717B 28 26                                jr      z, .divide0By   ; if bc is zero just return as result will be zero
 660+ 717D 7A                                   ld      a,d
 661+ 717E B3                                   or      e
 662+ 717F 28 26                                jr      z, .divideBy0
 663+ 7181 D5                                   push    de
 664+ 7182 CD D4 70     .DoDivide:              call    BC_Div_DE       ; bc(q0) = bc / de , hl(r0) = bc %de
 665+ 7185 D1                                   pop     de              ; get divisor back to test
 666+ 7186 CB 7A                                bit     7,d             ; if divisor <0 or = 0 goto else branch
 667+ 7188 C2 98 71                             jp      nz,.deLTE0
 668+ 718B 7A                                   ld      a,d
 669+ 718C B3                                   or      e
 670+ 718D CA 98 71                             jp      z,.deLTE0
 671+ 7190 CB 7C        .deGT0:                 bit     7,h             ; if remainder >=0 return with no adjustment
 672+ 7192 C8                                   ret     z               ; if remainder was not negative then all done
 673+ 7193 0B                                   dec     bc              ; else q --
 674+ 7194                                      ClearCarryFlag          ;      r += b
 674+ 7194 B7          >                        or a
 675+ 7195 ED 5A                                adc     hl,de           ;      .
 676+ 7197 C9                                   ret
 677+ 7198 CB 7C        .deLTE0:                bit     7,h             ; if remainder <= 0 retun with no adjustment
 678+ 719A C8                                   ret     z               ; (return if negative)
 679+ 719B 7C                                   ld      a,h
 680+ 719C B5                                   or      l               ; (return if zero)
 681+ 719D C8                                   ret     z
 682+ 719E 0B                                   dec     bc              ; else q --
 683+ 719F                                      ClearCarryFlag          ;      r += b
 683+ 719F B7          >                        or a
 684+ 71A0 ED 5A                                adc     hl,de           ;      .
 685+ 71A2 C9                                   ret
 686+ 71A3 21 00 00     .divide0By:             ld      hl,0            ; hl = 0, bc is already 0
 687+ 71A6 C9                                   ret
 688+ 71A7 21 00 00     .divideBy0:             ld      hl,0
 689+ 71AA 01 01 00                             ld      bc,1
 690+ 71AD C9                                   ret
 691+ 71AE
 692+ 71AE
 693+ 71AE              L_DIV_0_ITERATION:      MACRO
 694+ 71AE ~                                    rl      de              ;left shift dividend + quotient carry
 695+ 71AE ~                                    ex      de,hl
 696+ 71AE ~                                    rl      de              ;left shift remainder + dividend carry
 697+ 71AE ~                                    ex      de,hl
 698+ 71AE ~                                    sub     hl,bc           ;substract divisor from remainder
 699+ 71AE ~                                    jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 700+ 71AE ~                                    add     hl,bc           ;revert subtraction of divisor
 701+ 71AE ~            .skip_revert0:          ccf                     ;complement carry
 702+ 71AE ~                                    rl      de              ;left shift dividend + quotient carry
 703+ 71AE ~                                    ex      de,hl
 704+ 71AE ~                                    rl      de              ;left shift remainder + dividend carry
 705+ 71AE ~                                    ex      de,hl
 706+ 71AE ~                                    sub     hl,bc           ;substract divisor from remainder
 707+ 71AE ~                                    jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 708+ 71AE ~                                    add     hl,bc           ;revert subtraction of divisor
 709+ 71AE ~            .skip_revert1:          ccf                     ;complement carry
 710+ 71AE                                      ENDM
 711+ 71AE
 712+ 71AE              ; HL = DE / BC, DE = DE % BC
 713+ 71AE 21 00 00     l_div_0:                ld      hl,0            ;clear remainder
 714+ 71B1                                      L_DIV_0_ITERATION
 714+ 71B1 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 714+ 71B5 EB          >                        ex      de,hl
 714+ 71B6 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 714+ 71BA EB          >                        ex      de,hl
 714+ 71BB B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 714+ 71BE D2 C2 71    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 714+ 71C1 09          >                        add     hl,bc           ;revert subtraction of divisor
 714+ 71C2 3F          >.skip_revert0:          ccf                     ;complement carry
 714+ 71C3 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 714+ 71C7 EB          >                        ex      de,hl
 714+ 71C8 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 714+ 71CC EB          >                        ex      de,hl
 714+ 71CD B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 714+ 71D0 D2 D4 71    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 714+ 71D3 09          >                        add     hl,bc           ;revert subtraction of divisor
 714+ 71D4 3F          >.skip_revert1:          ccf                     ;complement carry
 715+ 71D5                                      L_DIV_0_ITERATION
 715+ 71D5 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 715+ 71D9 EB          >                        ex      de,hl
 715+ 71DA CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 715+ 71DE EB          >                        ex      de,hl
 715+ 71DF B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 715+ 71E2 D2 E6 71    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 715+ 71E5 09          >                        add     hl,bc           ;revert subtraction of divisor
 715+ 71E6 3F          >.skip_revert0:          ccf                     ;complement carry
 715+ 71E7 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 715+ 71EB EB          >                        ex      de,hl
 715+ 71EC CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 715+ 71F0 EB          >                        ex      de,hl
 715+ 71F1 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 715+ 71F4 D2 F8 71    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 715+ 71F7 09          >                        add     hl,bc           ;revert subtraction of divisor
 715+ 71F8 3F          >.skip_revert1:          ccf                     ;complement carry
 716+ 71F9                                      L_DIV_0_ITERATION
 716+ 71F9 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 716+ 71FD EB          >                        ex      de,hl
 716+ 71FE CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 716+ 7202 EB          >                        ex      de,hl
 716+ 7203 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 716+ 7206 D2 0A 72    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 716+ 7209 09          >                        add     hl,bc           ;revert subtraction of divisor
 716+ 720A 3F          >.skip_revert0:          ccf                     ;complement carry
 716+ 720B CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 716+ 720F EB          >                        ex      de,hl
 716+ 7210 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 716+ 7214 EB          >                        ex      de,hl
 716+ 7215 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 716+ 7218 D2 1C 72    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 716+ 721B 09          >                        add     hl,bc           ;revert subtraction of divisor
 716+ 721C 3F          >.skip_revert1:          ccf                     ;complement carry
 717+ 721D                                      L_DIV_0_ITERATION
 717+ 721D CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 717+ 7221 EB          >                        ex      de,hl
 717+ 7222 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 717+ 7226 EB          >                        ex      de,hl
 717+ 7227 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 717+ 722A D2 2E 72    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 717+ 722D 09          >                        add     hl,bc           ;revert subtraction of divisor
 717+ 722E 3F          >.skip_revert0:          ccf                     ;complement carry
 717+ 722F CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 717+ 7233 EB          >                        ex      de,hl
 717+ 7234 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 717+ 7238 EB          >                        ex      de,hl
 717+ 7239 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 717+ 723C D2 40 72    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 717+ 723F 09          >                        add     hl,bc           ;revert subtraction of divisor
 717+ 7240 3F          >.skip_revert1:          ccf                     ;complement carry
 718+ 7241                                      L_DIV_0_ITERATION
 718+ 7241 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 718+ 7245 EB          >                        ex      de,hl
 718+ 7246 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 718+ 724A EB          >                        ex      de,hl
 718+ 724B B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 718+ 724E D2 52 72    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 718+ 7251 09          >                        add     hl,bc           ;revert subtraction of divisor
 718+ 7252 3F          >.skip_revert0:          ccf                     ;complement carry
 718+ 7253 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 718+ 7257 EB          >                        ex      de,hl
 718+ 7258 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 718+ 725C EB          >                        ex      de,hl
 718+ 725D B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 718+ 7260 D2 64 72    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 718+ 7263 09          >                        add     hl,bc           ;revert subtraction of divisor
 718+ 7264 3F          >.skip_revert1:          ccf                     ;complement carry
 719+ 7265                                      L_DIV_0_ITERATION
 719+ 7265 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 719+ 7269 EB          >                        ex      de,hl
 719+ 726A CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 719+ 726E EB          >                        ex      de,hl
 719+ 726F B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 719+ 7272 D2 76 72    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 719+ 7275 09          >                        add     hl,bc           ;revert subtraction of divisor
 719+ 7276 3F          >.skip_revert0:          ccf                     ;complement carry
 719+ 7277 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 719+ 727B EB          >                        ex      de,hl
 719+ 727C CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 719+ 7280 EB          >                        ex      de,hl
 719+ 7281 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 719+ 7284 D2 88 72    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 719+ 7287 09          >                        add     hl,bc           ;revert subtraction of divisor
 719+ 7288 3F          >.skip_revert1:          ccf                     ;complement carry
 720+ 7289                                      L_DIV_0_ITERATION
 720+ 7289 CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 720+ 728D EB          >                        ex      de,hl
 720+ 728E CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 720+ 7292 EB          >                        ex      de,hl
 720+ 7293 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 720+ 7296 D2 9A 72    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 720+ 7299 09          >                        add     hl,bc           ;revert subtraction of divisor
 720+ 729A 3F          >.skip_revert0:          ccf                     ;complement carry
 720+ 729B CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 720+ 729F EB          >                        ex      de,hl
 720+ 72A0 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 720+ 72A4 EB          >                        ex      de,hl
 720+ 72A5 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 720+ 72A8 D2 AC 72    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 720+ 72AB 09          >                        add     hl,bc           ;revert subtraction of divisor
 720+ 72AC 3F          >.skip_revert1:          ccf                     ;complement carry
 721+ 72AD                                      L_DIV_0_ITERATION
 721+ 72AD CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 721+ 72B1 EB          >                        ex      de,hl
 721+ 72B2 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 721+ 72B6 EB          >                        ex      de,hl
 721+ 72B7 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 721+ 72BA D2 BE 72    >                        jp      nc,.skip_revert0 ;if remainder < divisor, add back divisor
 721+ 72BD 09          >                        add     hl,bc           ;revert subtraction of divisor
 721+ 72BE 3F          >.skip_revert0:          ccf                     ;complement carry
 721+ 72BF CB 13 CB 12 >                        rl      de              ;left shift dividend + quotient carry
 721+ 72C3 EB          >                        ex      de,hl
 721+ 72C4 CB 13 CB 12 >                        rl      de              ;left shift remainder + dividend carry
 721+ 72C8 EB          >                        ex      de,hl
 721+ 72C9 B7 ED 42    >                        sub     hl,bc           ;substract divisor from remainder
 721+ 72CC D2 D0 72    >                        jp      NC,.skip_revert1 ;if remainder < divisor, add back divisor
 721+ 72CF 09          >                        add     hl,bc           ;revert subtraction of divisor
 721+ 72D0 3F          >.skip_revert1:          ccf                     ;complement carry
 722+ 72D1 CB 13 CB 12                          rl      de              ;left shift dividend + quotient carry
 723+ 72D5 EB                                   ex      de,hl           ;dividend<>remainder
 724+ 72D6 C9                                   ret
 725+ 72D7
 726+ 72D7
 727+ 72D7
 728+ 72D7
 729+ 72D7 11 FE FF     LLHLdivC:               ld      de,$FFFE                    ; set XY to &FFFE at start, de holds XY
 730+ 72DA              .LL130:                 ShiftHLLeft1                        ; RS *= 2
 730+ 72DA CB 25       >               sla l
 730+ 72DC CB 14       >               rl  h
 731+ 72DE 7C                                   ld      a,h
 732+ 72DF 38 04                                jr      c,.LL131                    ; if S overflowed skip Q test and do subtractions
 733+ 72E1                                      JumpIfALTNusng c, .LL132            ; if S <  Q = 256/gradient skip subtractions
 733+ 72E1 B9          >                        cp      c
 733+ 72E2 DA ED 72    >                        jp		c, .LL132
 734+ 72E5 3F           .LL131:                 ccf                                 ; compliment carry
 735+ 72E6 99                                   sbc     a,c                         ; q
 736+ 72E7 67                                   ld      h,a                         ; h (s)
 737+ 72E8 7D                                   ld      a,l                         ; r
 738+ 72E9 DE 00                                sbc     a,0                         ; 0 - so in effect SR - Q*256
 739+ 72EB 37                                   scf                                 ; set carry for next rolls
 740+ 72EC 3F                                   ccf
 741+ 72ED              .LL132:                 RollDELeft1                         ; Rotate de bits left
 741+ 72ED CB 13       >               rl  e
 741+ 72EF CB 12       >               rl  d
 742+ 72F1 38 E7                                jr      c,.LL130                    ;
 743+ 72F3 EB                                   ex      de,hl                       ; hl = result
 744+ 72F4 C9                                   ret
 745+ 72F5
 746+ 72F5
 747+ 72F5 AF           div_hl_c:               xor	a
 748+ 72F6 06 10                                ld	b, 16
 749+ 72F8 29           .loop:                  add	hl, hl
 750+ 72F9 17                                   rla
 751+ 72FA 38 03                                jr	c, $+5
 752+ 72FC B9                                   cp	c
 753+ 72FD 38 02                                jr	c, $+4
 754+ 72FF 91                                   sub	c
 755+ 7300 2C                                   inc	l
 756+ 7301 10 F5                                djnz	.loop
 757+ 7303 C9                                   ret
 758+ 7304              ;l_div, signed division
 759+ 7304              ; comes in with DE and HL
 760+ 7304              ; HL = DE / HL, DE = DE % HL
 761+ 7304 4A           l_div:                  ld      c,d             ;sign of dividend
 762+ 7305 44                                   ld      b,h             ;sign of divisor
 763+ 7306 C5                                   push    bc              ;save signs
 764+ 7307 4D                                   ld      c,l             ;divisor to bc
 765+ 7308 7A                                   ld      a,d
 766+ 7309 B7                                   or      a
 767+ 730A F2 13 73                             jp      p,.NotDENeg
 768+ 730D              .DeNegate:              macronegate16de
 768+ 730D AF          >					xor 	a
 768+ 730E 93          >                    sub 	e
 768+ 730F 5F          >                    ld 		e,a
 768+ 7310 9F          >                    sbc 	a,a
 768+ 7311 92          >                    sub 	d
 768+ 7312 57          >                    ld 		d,a
 769+ 7313 78           .NotDENeg:              ld      a,b
 770+ 7314 B7                                   or      a
 771+ 7315 F2 1E 73                             jp      p,.NotBCNeg     ; if signs are opposite them flip
 772+ 7318                                      macronegate16bc
 772+ 7318 AF          >					xor 	a
 772+ 7319 91          >                    sub 	c
 772+ 731A 4F          >                    ld 		c,a
 772+ 731B 9F          >                    sbc 	a,a
 772+ 731C 90          >                    sub 	b
 772+ 731D 47          >                    ld 		b,a
 773+ 731E CD AE 71     .NotBCNeg:              call    l_div_0         ;unsigned HL = DE / BC, DE = DE % BC
 774+ 7321                                      ; C standard requires that the result of division satisfy a = (a/b)*b + a%b emainder takes sign of the dividend
 775+ 7321 C1                                   pop     bc              ;restore sign info
 776+ 7322 78                                   ld      a,b
 777+ 7323 A9                                   xor     c               ;quotient, sign of dividend^divisor
 778+ 7324 F2 2D 73                             jp      p,.NotHLNeg
 779+ 7327                                      macronegate16hl
 779+ 7327 AF          >					xor 	a
 779+ 7328 95          >					sub 	l
 779+ 7329 6F          >					ld 		l,a
 779+ 732A 9F          >					sbc 	a,a
 779+ 732B 94          >					sub 	h
 779+ 732C 67          >					ld 		h,a
 780+ 732D 79           .NotHLNeg:              ld      a,c
 781+ 732E B7                                   or      a,a             ;remainder, sign of dividend
 782+ 732F F0                                   ret     p
 783+ 7330                                      macronegate16de
 783+ 7330 AF          >					xor 	a
 783+ 7331 93          >                    sub 	e
 783+ 7332 5F          >                    ld 		e,a
 783+ 7333 9F          >                    sbc 	a,a
 783+ 7334 92          >                    sub 	d
 783+ 7335 57          >                    ld 		d,a
 784+ 7336 C9                                   ret
 785+ 7337
# file closed: ../../Maths/asm_divide.asm
 675  7337                  INCLUDE "../../Maths/asm_unitvector.asm"
# file opened: ../../Maths/asm_unitvector.asm
   1+ 7337              asm_tis2:
   2+ 7337              ; ">TIS2 A = (A / Q * 96) so A = -96 ---- 96  range "
   3+ 7337              ; ">DOES NOT DO SIGNED YET"
   4+ 7337 F5           	push af
   5+ 7338 E6 7F            and SignMask8Bit
   6+ 733A 57           	ld d,a				;; d = A
   7+ 733B 3A 05 67     	ld a,(varQ)
   8+ 733E 5F           	ld e,a
   9+ 733F 7A           	ld a,d
  10+ 7340 BB           	cp e
  11+ 7341 30 11        	jr nc, .tis2_set96	;; jump if a >= Q
  12+ 7343 1E 60        	ld e, 96
  13+ 7345 ED 30        	mul				; de = d * 96 (also a * 96 )
  14+ 7347 EB           	ex de,hl
  15+ 7348 3A 05 67     	ld a,(varQ)
  16+ 734B 4F           	ld c,a
  17+ 734C CD 86 70     	call asm_div16
  18+ 734F F1           	pop af
  19+ 7350 E6 80        	and $80
  20+ 7352 B5           	or l
  21+ 7353 C9           	ret
  22+ 7354              .tis2_set96:
  23+ 7354 F1           	pop af
  24+ 7355 E6 80        	and $80
  25+ 7357 F6 96        	or $96
  26+ 7359 C9           	ret
  27+ 735A
  28+ 735A
  29+ 735A              asm_unit_vector:
  30+ 735A              squareregfx:
  31+ 735A 3A E7 C0     	ld a,(UBnkXScaled)
  32+ 735D 57           	ld d,a
  33+ 735E 5F           	ld e,a
  34+ 735F ED 30        	mul
  35+ 7361 EB           	ex de,hl
  36+ 7362              squareregfy:
  37+ 7362 3A E9 C0     	ld a, (UBnkYScaled)
  38+ 7365 57           	ld d,a
  39+ 7366 5F           	ld e,a
  40+ 7367 ED 30        	mul
  41+ 7369 19           	add hl,de
  42+ 736A              squareregfz:
  43+ 736A 3A EB C0     	ld a, (UBnkZScaled)
  44+ 736D 57           	ld d,a
  45+ 736E 5F           	ld e,a
  46+ 736F ED 30        	mul
  47+ 7371 19           	add hl,de
  48+ 7372 EB           	ex de,hl			; de de to number to root
  49+ 7373              hlequsquareroot:
  50+ 7373 CD A4 6C     	call asm_sqrt		; hl = sqrt (fx^2 + fy^2 + fx^2)
  51+ 7376 E5           	push hl				; save it for work 3 copies
  52+ 7377 E5           	push hl				; save it for work
  53+ 7378 E5           	push hl				; save it for work
  54+ 7379              normfx:
  55+ 7379 3A E7 C0     	ld a,(UBnkXScaled)
  56+ 737C E1           	pop hl				; get copy #1
  57+ 737D 7D           	ld a,l				; we assume only l had worthwhile data but could spill into h
  58+ 737E 4F           	ld c,a
  59+ 737F CD 37 73     	call asm_tis2
  60+ 7382 32 E7 C0     	ld (UBnkXScaled),a
  61+ 7385              normfy:
  62+ 7385 3A E9 C0     	ld a,(UBnkYScaled)
  63+ 7388 E1           	pop hl				; get copy #2
  64+ 7389 7D           	ld a,l
  65+ 738A 4F           	ld c,a
  66+ 738B CD 37 73     	call asm_tis2
  67+ 738E 32 E9 C0     	ld (UBnkYScaled),a
  68+ 7391              normfz:
  69+ 7391 3A EB C0     	ld a,(UBnkZScaled)
  70+ 7394 E1           	pop hl				; get copy #2
  71+ 7395 7D           	ld a,l
  72+ 7396 4F           	ld c,a
  73+ 7397 CD 37 73     	call asm_tis2
  74+ 739A 32 EB C0     	ld (UBnkZScaled),a
  75+ 739D              asm_unit_vector_end:
  76+ 739D C9           	ret
  77+ 739E
# file closed: ../../Maths/asm_unitvector.asm
 676  739E                  INCLUDE "../../Maths/compare16.asm"
# file opened: ../../Maths/compare16.asm
   1+ 739E              ; Input:
   2+ 739E              ;       HL = 1st value
   3+ 739E              ;       DE = 2nd value
   4+ 739E              ; Output:
   5+ 739E              ;       CF, ZF = results of comparison:
   6+ 739E              ;
   7+ 739E              ;               CF      ZF      Result
   8+ 739E              ;               -----------------------------------
   9+ 739E              ;               0       0       HL > DE
  10+ 739E              ;               0       1       HL == DE
  11+ 739E              ;               1       0       HL < DE
  12+ 739E              ;               1       1       Impossible
  13+ 739E              ;
  14+ 739E EB           CompareDEHLunsigned:ex      de,hl
  15+ 739F E5                               push    hl
  16+ 73A0 A7                               and     a
  17+ 73A1 ED 52                            sbc     hl,de
  18+ 73A3 E1                               pop     hl
  19+ 73A4 EB                               ex      de,hl
  20+ 73A5 C9                               ret
  21+ 73A6 E5           CompareHLDEunsigned:push    hl
  22+ 73A7 A7                               and     a
  23+ 73A8 ED 52                            sbc     hl,de
  24+ 73AA E1                               pop     hl
  25+ 73AB C9                               ret
  26+ 73AC
  27+ 73AC E5           CompareBCDESigned:  push    hl
  28+ 73AD A7                               and     a
  29+ 73AE 60 69                            ld      hl,bc
  30+ 73B0 ED 52                            sbc     hl,de
  31+ 73B2 E1                               pop     hl
  32+ 73B3 C9                               ret
  33+ 73B4
  34+ 73B4 E5           CompareDEBCSigned:  push    hl
  35+ 73B5 A7                               and     a
  36+ 73B6 62 6B                            ld      hl,de
  37+ 73B8 ED 42                            sbc     hl,bc
  38+ 73BA E1                               pop     hl
  39+ 73BB C9                               ret
  40+ 73BC
  41+ 73BC
  42+ 73BC              ;### CMPGTE -> test if A>=B
  43+ 73BC              ;### Input      HL=A, DE=B if hl=> de no carry else de > hl and set carry
  44+ 73BC 7C           CompareHLDESgn:     ld a,h
  45+ 73BD AA                               xor d
  46+ 73BE FA C8 73                         jp m, .cmpgte2
  47+ 73C1 ED 52                            sbc hl,de
  48+ 73C3 30 09                            jr nc, .cmpgte3
  49+ 73C5 19           .cmpgte1            add hl,de
  50+ 73C6                                  SetCarryFlag
  50+ 73C6 37          >                        scf
  51+ 73C7 C9                               ret
  52+ 73C8 CB 7A        .cmpgte2            bit 7,d
  53+ 73CA 28 05                            jr z,.cmpgte4
  54+ 73CC              .cmpgte5:           ClearCarryFlag
  54+ 73CC B7          >                        or a
  55+ 73CD C9                               ret
  56+ 73CE 19           .cmpgte3            add hl,de
  57+ 73CF                                  ClearCarryFlag
  57+ 73CF B7          >                        or a
  58+ 73D0 C9                               ret
  59+ 73D1              .cmpgte4:           SetCarryFlag
  59+ 73D1 37          >                        scf
  60+ 73D2 C9                               ret
  61+ 73D3
  62+ 73D3              ; Compares HL and DE sets z flag if same, else nz
  63+ 73D3 7C           CompareHLDESame:    ld  a,h
  64+ 73D4 BA                               cp  d
  65+ 73D5 C0                               ret nz
  66+ 73D6 7D                               ld  a,l
  67+ 73D7 BB                               cp  e
  68+ 73D8 C9                               ret
  69+ 73D9
  70+ 73D9
  71+ 73D9
  72+ 73D9 7C           CompareHLBCSgn:     ld a,h
  73+ 73DA A8                               xor b
  74+ 73DB FA E4 73                         jp m, .cmpgte2
  75+ 73DE ED 42                            sbc hl,bc
  76+ 73E0 30 06                            jr nc, .cmpgte3
  77+ 73E2              .cmpgte1            SetCarryFlag
  77+ 73E2 37          >                        scf
  78+ 73E3 C9                               ret
  79+ 73E4 CB 78        .cmpgte2            bit 7,b
  80+ 73E6 28 FA                            jr z,.cmpgte1
  81+ 73E8              .cmpgte3            ClearCarryFlag
  81+ 73E8 B7          >                        or a
  82+ 73E9 C9                               ret
  83+ 73EA
  84+ 73EA              CompareHLDESigned:
  85+ 73EA E5           compare16HLDE:      push    hl
  86+ 73EB A7                               and     a
  87+ 73EC ED 52                            sbc     hl,de
  88+ 73EE E1                               pop     hl
  89+ 73EF C9                               ret
  90+ 73F0              CompareHLBCSigned:
  91+ 73F0 E5           CompareHLBC:        push    hl
  92+ 73F1 A7                               and     a
  93+ 73F2 ED 42                            sbc     hl,bc
  94+ 73F4 E1                               pop     hl
  95+ 73F5 C9                               ret
  96+ 73F6
  97+ 73F6              ; With compare signed we do ABS comparison
  98+ 73F6              ; this is used for view ports as we just want to know if its +/- out side of 90 degrees
  99+ 73F6
 100+ 73F6 E5 D5        compare16HLDEABS:   push    hl,,de
 101+ 73F8 7C                               ld      a,h                                     ; Quick pass see of both the same sign
 102+ 73F9 E6 7F                            and     SignMask8Bit
 103+ 73FB 67                               ld      h,a
 104+ 73FC 7A                               ld      a,d                                     ; Quick pass see of both the same sign
 105+ 73FD E6 7F                            and     SignMask8Bit
 106+ 73FF 57                               ld      d,a
 107+ 7400 A7                               and     a
 108+ 7401 ED 52                            sbc     hl,de
 109+ 7403 D1 E1                            pop     hl,,de
 110+ 7405 C9                               ret
 111+ 7406
 112+ 7406
# file closed: ../../Maths/compare16.asm
 677  7406                  INCLUDE "../../Maths/normalise96.asm"
# file opened: ../../Maths/normalise96.asm
   1+ 7406              ; a equal a / d * 96
   2+ 7406              ; Tested and works with signed numbers
   3+ 7406 DD 7E 01     NormaliseIXVector:      ld		a,(ix+1)			; Vector X high
   4+ 7409 E6 7F                                and		SignMask8Bit        ; a = abs X high
   5+ 740B 57                                   ld      d,a                 ; hl = abs X ^ 2
   6+ 740C 5F                                   ld      e,a                 ; .
   7+ 740D ED 30                                mul     de                  ; .
   8+ 740F EB                                   ex      de,hl               ; .
   9+ 7410 DD 7E 03                             ld		a,(ix+3)			; vector = Y high
  10+ 7413 E6 7F                                and		SignMask8Bit        ; unsigned
  11+ 7415 57                                   ld      d,a                 ; de = abs Y ^ 2
  12+ 7416 5F                                   ld      e,a                 ; .
  13+ 7417 ED 30                                mul     de                  ; .
  14+ 7419 19                                   add     hl,de               ; hl = x^2 + y ^2
  15+ 741A DD 7E 05                             ld		a,(ix+5)			; vector = Z high
  16+ 741D E6 7F                                and		SignMask8Bit        ; unsigned
  17+ 741F 57                                   ld      d,a                 ; de = abs Z ^ 2
  18+ 7420 5F                                   ld      e,a                 ; .
  19+ 7421 ED 30                                mul     de                  ; .
  20+ 7423 19                                   add     hl,de               ; de = x^2 + y ^2 + z ^ 2
  21+ 7424 EB                                   ex      de,hl               ; .
  22+ 7425 CD A4 6C     .n96SQRT:               call	asm_sqrt			; hl = sqrt de
  23+ 7428 DD 7E 01     .n96NORMX:              ld		a,(ix+1)
  24+ 742B 55                                   ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  25+ 742C CD 5E 76                             call	AequAdivDmul96Q8    ; does not use HL so we can retain it
  26+ 742F 47                                   ld		b,a				    ; Sort out restoring sign bit
  27+ 7430 0E 00                                ld      c,0                 ; .
  28+ 7432 DD 71 00 DD                          ld		(ix+0),bc           ; .
  28+ 7436 70 01
  29+ 7438 DD 7E 03     .n96NORMY:              ld		a,(ix+3)
  30+ 743B 55                                   ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  31+ 743C CD 5E 76                             call	AequAdivDmul96Q8	; does not use HL so we can retain it
  32+ 743F 47                                   ld		b,a				    ; Sort out restoring sign bit
  33+ 7440 0E 00                                ld      c,0                 ; .
  34+ 7442 DD 71 02 DD                          ld		(ix+2),bc           ; .
  34+ 7446 70 03
  35+ 7448 DD 7E 05     .n96NORMZ:              ld		a,(ix+5)
  36+ 744B 55                                   ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  37+ 744C CD 5E 76                             call	AequAdivDmul96Q8 	; does not use HL so we can retain it
  38+ 744F 47                                   ld		b,a				    ; Sort out restoring sign bit
  39+ 7450 0E 00                                ld      c,0                 ; .
  40+ 7452 DD 71 04 DD                          ld		(ix+4),bc           ; .
  40+ 7456 70 05
  41+ 7458 C9                                   ret
  42+ 7459
  43+ 7459              ; .NORM	\ -> &3BD6 \ Normalize 3-vector length of XX15
  44+ 7459 3A E7 C0     normaliseXX1596S7:      ld		a,(XX15VecX)	    ; XX15+0
  45+ 745C DD 67                                ld		ixh,a               ; ixh = signed x component
  46+ 745E E6 7F                                and		SignMask8Bit        ; a = unsigned version
  47+ 7460              .n96SQX:	            inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
  47+ 7460 5F          >			ld	e,a
  47+ 7461 57          >			ld  d,a
  47+ 7462 ED 30       >			mul
  48+ 7464 62                                   ld		h,d					; h == varR d = varO e= varA
  49+ 7465 6B                                   ld		l,e					; l == varQ  															:: so HL = XX15[x]^2
  50+ 7466 3A E8 C0     .n96SQY:                ld		a,(XX15VecY)
  51+ 7469 DD 6F                                ld		ixl,a               ; ixl = signed y componet
  52+ 746B E6 7F                                and		SignMask8Bit                 ; = abs
  53+ 746D                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2		:: so DE = XX15[y]^2
  53+ 746D 5F          >			ld	e,a
  53+ 746E 57          >			ld  d,a
  53+ 746F ED 30       >			mul
  54+ 7471 19                                   add		hl,de				; hl = XX15[x]^2 + XX15[y]^2
  55+ 7472 3A E9 C0     .n96SQZ:                ld		a,(XX15VecZ)			; Note comments say \ ZZ15+2  should be \ XX15+2 as per code
  56+ 7475 FD 67                                ld		iyh,a               ; iyh = signed
  57+ 7477 E6 7F                                and		SignMask8Bit                 ; unsigned
  58+ 7479                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2		:: so DE = XX15[z]^2
  58+ 7479 5F          >			ld	e,a
  58+ 747A 57          >			ld  d,a
  58+ 747B ED 30       >			mul
  59+ 747D 19           .n96SQADD:              add		hl,de				; hl = XX15[x]^2 + XX15[y]^2 + XX15[z]^2
  60+ 747E EB                                   ex		de,hl				; hl => de ready for square root
  61+ 747F CD A4 6C     .n96SQRT:               call	asm_sqrt			; hl = de = sqrt(XX15[x]^2 + XX15[y]^2 + XX15[z]^2), we just are interested in l which is the new Q
  62+ 7482 3A E7 C0     .n96NORMX:              ld		a,(XX15VecX)
  63+ 7485 E6 7F                                and		SignMask8Bit
  64+ 7487 4F                                   ld		c,a
  65+ 7488 55                                   ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  66+ 7489 CD 14 76                             call	AequAdivDmul967Bit	; does not use HL so we can retain it
  67+ 748C 47                                   ld		b,a				    ;++SGN
  68+ 748D DD 7C                                ld		a,ixh			    ;++SGN
  69+ 748F E6 80                                and		$80				    ;++SGN
  70+ 7491 B0                                   or		b				    ;++SGN
  71+ 7492 32 E7 C0                             ld		(XX15VecX),a
  72+ 7495 3A E8 C0     .n96NORMY:              ld		a,(XX15VecY)
  73+ 7498 E6 7F                                and		SignMask8Bit
  74+ 749A 4F                                   ld		c,a
  75+ 749B 55                                   ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  76+ 749C CD 14 76                             call	AequAdivDmul967Bit     	; does not use HL so we can retain it
  77+ 749F 47                                   ld		b,a				    ;++SGN
  78+ 74A0 DD 7D                                ld		a,ixl			    ;++SGN
  79+ 74A2 E6 80                                and		$80				    ;++SGN
  80+ 74A4 B0                                   or		b				    ;++SGN
  81+ 74A5 32 E8 C0                             ld		(XX15VecY),a
  82+ 74A8 3A E9 C0     .n96NORMZ:              ld		a,(XX15VecZ)
  83+ 74AB E6 7F                                and		SignMask8Bit
  84+ 74AD 4F                                   ld		c,a
  85+ 74AE 55                                   ld		d,l				; Q(i.e. l) => D, later we can just pop into de
  86+ 74AF CD 14 76                             call	AequAdivDmul967Bit;AequAdivDmul96	; does not use HL so we can retain it
  87+ 74B2 47                                   ld		b,a				    ;++SGN
  88+ 74B3 FD 7C                                ld		a,iyh			    ;++SGN
  89+ 74B5 E6 80                                and		$80				    ;++SGN
  90+ 74B7 B0                                   or		b				    ;++SGN
  91+ 74B8 32 E9 C0                             ld		(XX15VecZ),a
  92+ 74BB C9                                   ret
  93+ 74BC
  94+ 74BC              ; Normalise vector
  95+ 74BC              ; scale Q = Sqrt (X^2 + Y^2 + Z^2)
  96+ 74BC              ; X = X / Q with 96 = 1 , i.e X = X / Q * 3/8
  97+ 74BC              ; Y = Y / Q with 96 = 1 , i.e Y = Y / Q * 3/8
  98+ 74BC              ; Z = Z / Q with 96 = 1 , i.e Z = Z / Q * 3/8
  99+ 74BC
 100+ 74BC                      IFNDEF DEBUG_NO_TACTICS_CODE
 101+ 74BC ~            ;------------------------------------------------------------
 102+ 74BC ~            ; To normalise the 24 bit version, bring out sign into TargetVectorxsgn
 103+ 74BC ~            ; and make UBnKTargetXpos = abs (UBnKTargetXPos)
 104+ 74BC ~            ; set up UBnKTarget[XYZ]Pos with 7 bit version of vector normalised
 105+ 74BC ~            ; set up UBnKTargetpXYZ]Sgn with the sign bit
 106+ 74BC ~            NormalseUnivTarget:     ld      a,(UBnKTargetXPos+2)
 107+ 74BC ~                                    ld      b,a
 108+ 74BC ~                                    and     $80
 109+ 74BC ~                                    ld      (UBnKTargetXPosSgn),a        ; Split out the sign into byte 3
 110+ 74BC ~                                    ld      a,b
 111+ 74BC ~                                    and     $7F
 112+ 74BC ~                                    ld      (UBnKTargetXPos+2),a
 113+ 74BC ~            .ABSYComponenet:        ld      a,(UBnKTargetYPos+2)
 114+ 74BC ~                                    ld      b,a
 115+ 74BC ~                                    and     $80
 116+ 74BC ~                                    ld      (UBnKTargetYPosSgn),a        ; Split out the sign into byte 3
 117+ 74BC ~                                    ld      a,b
 118+ 74BC ~                                    and     $7F
 119+ 74BC ~                                    ld      (UBnKTargetYPos+2),a
 120+ 74BC ~            .ABSXZomponenet:        ld      a,(UBnKTargetZPos+2)
 121+ 74BC ~                                    ld      b,a
 122+ 74BC ~                                    and     $80
 123+ 74BC ~                                    ld      (UBnKTargetZPosSgn),a        ; Split out the sign into byte 3
 124+ 74BC ~                                    ld      a,b
 125+ 74BC ~                                    and     $7F
 126+ 74BC ~                                    ld      (UBnKTargetZPos+2),a
 127+ 74BC ~            ;.. When we hit here the UBnKTargetX,Y and Z are 24 bit abs values to simplify scaling
 128+ 74BC ~            .Scale:                 ld      hl, (TacticsVectorX)        ; pull 24 bit into registers
 129+ 74BC ~                                    ld      a,(TacticsVectorX+2)        ; h l ixH = X
 130+ 74BC ~                                    ld      ixh,a                       ;
 131+ 74BC ~                                    ld      de, (TacticsVectorY)        ; d e iyH = Y
 132+ 74BC ~                                    ld      a,(TacticsVectorY+2)        ;
 133+ 74BC ~                                    ld      iyh,a                       ;
 134+ 74BC ~                                    ld      bc, (TacticsVectorZ)        ; b c iyL = Y
 135+ 74BC ~                                    ld      a,(TacticsVectorZ+2)        ;
 136+ 74BC ~                                    ld      iyl,a                       ;
 137+ 74BC ~            .ScaleLoop1:            ld      a,ixh                       ; first pass get to 16 bit
 138+ 74BC ~                                    or      iyh
 139+ 74BC ~                                    or      iyl
 140+ 74BC ~                                    or      iyh
 141+ 74BC ~                                    jp      z,.DoneScaling1
 142+ 74BC ~                                    ShiftIXhHLRight1
 143+ 74BC ~                                    ShiftIYhDERight1
 144+ 74BC ~                                    ShiftIYlBCRight1
 145+ 74BC ~            .DoneScaling1:          ;-- Now we have got here hl = X, de = Y, bc = Z
 146+ 74BC ~                                    ;-- we cal just jump into the Normalize Tactics code
 147+ 74BC ~            .ScaleLoop2:            ld      a,h
 148+ 74BC ~                                    or      d
 149+ 74BC ~                                    or      b
 150+ 74BC ~                                    jr      z,.DoneScaling2
 151+ 74BC ~                                    ShiftHLRight1
 152+ 74BC ~                                    ShiftDERight1
 153+ 74BC ~                                    ShiftBCRight1
 154+ 74BC ~                                    jp      .ScaleLoop2
 155+ 74BC ~            ;-- Now we are down to 8 bit values, so we need to scale again to get S7
 156+ 74BC ~            .DoneScaling2:          ShiftHLRight1
 157+ 74BC ~                                    ShiftDERight1
 158+ 74BC ~                                    ShiftBCRight1
 159+ 74BC ~            .CalculateLength:       push    hl,,de,,bc                  ; save vecrtor x y and z nwo they are scaled to 1 byte
 160+ 74BC ~                                    ld      d,e                         ; hl = y ^ 2
 161+ 74BC ~                                    mul     de                          ; .
 162+ 74BC ~                                    ex      de,hl                       ; .
 163+ 74BC ~                                    ld      d,e                         ; de = x ^ 2
 164+ 74BC ~                                    mul     de                          ; .
 165+ 74BC ~                                    add     hl,de                       ; hl = y^ 2 + x ^ 2
 166+ 74BC ~                                    ld      d,c
 167+ 74BC ~                                    ld      e,c
 168+ 74BC ~                                    mul     de
 169+ 74BC ~                                    add     hl,de                       ; hl =  y^ 2 + x ^ 2 + z ^ 2
 170+ 74BC ~                                    ex      de,hl                       ; fix as hl was holding square
 171+ 74BC ~                                    call    asm_sqrt                    ; hl = sqrt (de) = sqrt (x ^ 2 + y ^ 2 + z ^ 2)
 172+ 74BC ~                                    ; add in logic if h is low then use lower bytes for all
 173+ 74BC ~            .NormaliseZ:            ld      a,l                         ; save length into iyh
 174+ 74BC ~                                    ld      iyh,a                       ; .
 175+ 74BC ~                                    ld      d,a                         ;
 176+ 74BC ~                                    pop     bc                          ; retrive z scaled
 177+ 74BC ~                                    ld      a,c                         ; a = scaled byte
 178+ 74BC ~                                    call    AequAdivDmul967Bit
 179+ 74BC ~                                    ld      (TacticsVectorZ),a          ; now Tactics Vector Z byte 1 is value
 180+ 74BC ~            .NormaliseY:            pop     de
 181+ 74BC ~                                    ld      a,e
 182+ 74BC ~                                    ld      d,iyh
 183+ 74BC ~                                    call    AequAdivDmul967Bit
 184+ 74BC ~                                    ld      (TacticsVectorY),a
 185+ 74BC ~            .NormaliseX:            pop     hl
 186+ 74BC ~                                    ld      a,l
 187+ 74BC ~                                    ld      d,iyh
 188+ 74BC ~                                    call    AequAdivDmul967Bit
 189+ 74BC ~                                    ld      (TacticsVectorX),a          ;
 190+ 74BC ~                                    ret
 191+ 74BC ~
 192+ 74BC ~                        DISPLAY "TODO: Missle AI only works on S15 spread over 24 bits, i.e. ignores Sign byte 7 bits"
 193+ 74BC ~            ;-- This norallises the Tactics vector in memory as much as possible, uses 16 bits
 194+ 74BC ~            NormalizeTactics:       ld      hl, (TacticsVectorX)        ; pull XX15 into registers
 195+ 74BC ~                                    ld      de, (TacticsVectorY)        ; .
 196+ 74BC ~                                    ld      bc, (TacticsVectorZ)        ; .
 197+ 74BC ~            .ScaleLoop:             ld      a,h
 198+ 74BC ~                                    or      d
 199+ 74BC ~                                    or      b
 200+ 74BC ~                                    jr      z,.DoneScaling
 201+ 74BC ~                                    ShiftHLRight1
 202+ 74BC ~                                    ShiftDERight1
 203+ 74BC ~                                    ShiftBCRight1
 204+ 74BC ~                                    jp      .ScaleLoop
 205+ 74BC ~            .DoneScaling:           ShiftHLRight1                       ; as the values now need to be sign magnitued
 206+ 74BC ~                                    ShiftDERight1                       ; e.g. S + 7 bit we need an extra shift
 207+ 74BC ~                                    ShiftBCRight1                       ; now values are in L E C
 208+ 74BC ~                                    push    hl,,de,,bc                  ; save vecrtor x y and z nwo they are scaled to 1 byte
 209+ 74BC ~                                    ld      d,e                         ; hl = y ^ 2
 210+ 74BC ~                                    mul     de                          ; .
 211+ 74BC ~                                    ex      de,hl                       ; .
 212+ 74BC ~                                    ld      d,e                         ; de = x ^ 2
 213+ 74BC ~                                    mul     de                          ; .
 214+ 74BC ~                                    add     hl,de                       ; hl = y^ 2 + x ^ 2
 215+ 74BC ~                                    ld      d,c
 216+ 74BC ~                                    ld      e,c
 217+ 74BC ~                                    mul     de
 218+ 74BC ~                                    add     hl,de                       ; hl =  y^ 2 + x ^ 2 + z ^ 2
 219+ 74BC ~                                    ex      de,hl                       ; fix as hl was holding square
 220+ 74BC ~                                    call    asm_sqrt                    ; hl = sqrt (de) = sqrt (x ^ 2 + y ^ 2 + z ^ 2)
 221+ 74BC ~                                    ; add in logic if h is low then use lower bytes for all
 222+ 74BC ~                                    ld      a,l
 223+ 74BC ~                                    ld      iyh,a
 224+ 74BC ~                                    ld      d,a
 225+ 74BC ~                                    pop     bc                          ; retrive tacticsvectorz scaled
 226+ 74BC ~                                    ld      a,c                         ; a = scaled byte
 227+ 74BC ~                                    call    AequAdivDmul967Bit;AequAdivDmul96Unsg          ; This rountine I think is wrong and retuins bad values
 228+ 74BC ~                                    ld      (TacticsVectorZ),a
 229+ 74BC ~                                    pop     de
 230+ 74BC ~                                    ld      a,e
 231+ 74BC ~                                    ld      d,iyh
 232+ 74BC ~                                    call    AequAdivDmul967Bit;AequAdivDmul96Unsg
 233+ 74BC ~                                    ld      (TacticsVectorY),a
 234+ 74BC ~                                    pop     hl
 235+ 74BC ~                                    ld      a,l
 236+ 74BC ~                                    ld      d,iyh
 237+ 74BC ~                                    call    AequAdivDmul967Bit;AequAdivDmul96Unsg
 238+ 74BC ~                                    ld      (TacticsVectorX),a
 239+ 74BC ~                                    ; BODGE FOR NOW
 240+ 74BC ~                                    ZeroA                              ;; added to help debugging
 241+ 74BC ~                                    ld      (TacticsVectorX+1),a       ;; added to help debugging
 242+ 74BC ~                                    ld      (TacticsVectorY+1),a       ;; added to help debugging
 243+ 74BC ~                                    ld      (TacticsVectorZ+1),a       ;; added to help debugging
 244+ 74BC ~                                    SignBitOnlyMem TacticsVectorX+2     ; now upper byte is sign only
 245+ 74BC ~                                    SignBitOnlyMem TacticsVectorY+2     ; (could move it to lower perhaps later if
 246+ 74BC ~                                    SignBitOnlyMem TacticsVectorZ+2     ;  its worth it)
 247+ 74BC ~                                  ;; oly using byte 2 for sign  ldCopyByte TacticsVectorX+2, TacticsVectorX+1
 248+ 74BC ~                                  ;; oly using byte 2 for sign  ldCopyByte TacticsVectorY+2, TacticsVectorY+1
 249+ 74BC ~                                  ;; oly using byte 2 for sign  ldCopyByte TacticsVectorZ+2, TacticsVectorZ+1
 250+ 74BC ~                                  ;; oly using byte 2 for sign  SignBitOnlyMem TacticsVectorX+1     ; now upper byte is sign only
 251+ 74BC ~                                  ;; oly using byte 2 for sign  SignBitOnlyMem TacticsVectorY+1     ; (could move it to lower perhaps later if
 252+ 74BC ~                                  ;; oly using byte 2 for sign  SignBitOnlyMem TacticsVectorZ+1     ;  its worth it)
 253+ 74BC ~                                    ret
 254+ 74BC                      ENDIF
 255+ 74BC
# file closed: ../../Maths/normalise96.asm
 678  74BC                  INCLUDE "../../Maths/binary_to_decimal.asm"
# file opened: ../../Maths/binary_to_decimal.asm
   1+ 74BC              ;Number in hl to decimal ASCII
   2+ 74BC              ;Thanks to z80 Bits
   3+ 74BC              ;inputs:	hl = number to ASCII
   4+ 74BC              ;example: hl=300 outputs '00300'
   5+ 74BC              ;destroys: af, bc, hl, de used
   6+ 74BC              DispHLtoDE:
   7+ 74BC              ; "DispHL, writes HL to DE address"
   8+ 74BC 01 F0 D8     	ld	bc,-10000
   9+ 74BF CD D5 74     	call	Num1
  10+ 74C2 01 18 FC     	ld	bc,-1000
  11+ 74C5 CD D5 74     	call	Num1
  12+ 74C8 01 9C FF     	ld	bc,-100
  13+ 74CB CD D5 74     	call	Num1
  14+ 74CE 0E F6        	ld	c,-10
  15+ 74D0 CD D5 74     	call	Num1
  16+ 74D3 0E FF        	ld	c,-1
  17+ 74D5              Num1:
  18+ 74D5 3E 2F        	ld	a,'0'-1
  19+ 74D7              .Num2:
  20+ 74D7 3C           	inc	a
  21+ 74D8 09           	add	hl,bc
  22+ 74D9 38 FC        	jr	c,.Num2
  23+ 74DB ED 42        	sbc	hl,bc
  24+ 74DD 12           	ld	(de),a
  25+ 74DE 13           	inc	de
  26+ 74DF C9           	ret
  27+ 74E0
  28+ 74E0              DispAtoDE:
  29+ 74E0 26 00        	ld h,0
  30+ 74E2 6F           	ld l,a
  31+ 74E3 C3 BC 74     	jp DispHLtoDE
  32+ 74E6
  33+ 74E6              DispPriceAtoDE:
  34+ 74E6 26 00        	ld h,0
  35+ 74E8 6F           	ld l,a
  36+ 74E9 01 9C FF     	ld	bc,-100
  37+ 74EC CD FC 74     	call	.NumLeadBlank1
  38+ 74EF 0E F6        	ld	c,-10
  39+ 74F1 CD D5 74     	call	Num1
  40+ 74F4 3E 2E        	ld		a,'.'					; we could assume preformat but
  41+ 74F6                                  DISPLAY "TODO:  optimise "
  42+ 74F6 12           	ld		(de),a					; we can optimse that later TODO
  43+ 74F7 13           	inc		de						; with just an inc De
  44+ 74F8 0E FF        	ld	c,-1
  45+ 74FA 18 D9        	jr		Num1
  46+ 74FC              .NumLeadBlank1:
  47+ 74FC 3E 2F        	ld	a,'0'-1
  48+ 74FE              .NumLeadBlank2:
  49+ 74FE 3C           	inc	a
  50+ 74FF 09           	add	hl,bc
  51+ 7500 38 FC        	jr	c,.NumLeadBlank2
  52+ 7502 FE 30        	cp	'0'
  53+ 7504 20 02        	jr	nz,.DontBlank
  54+ 7506              .Blank:
  55+ 7506 3E 20        	ld	a,' '
  56+ 7508              .DontBlank:
  57+ 7508 ED 42        	sbc	hl,bc
  58+ 750A 12           	ld	(de),a
  59+ 750B 13           	inc	de
  60+ 750C C9           	ret
  61+ 750D
  62+ 750D              DispQtyAtoDE:
  63+ 750D FE 00        	cp	0
  64+ 750F 28 23        	jr	z,.NoStock
  65+ 7511 26 00        	ld h,0
  66+ 7513 6F           	ld l,a
  67+ 7514 01 9C FF     	ld	bc,-100
  68+ 7517 CD 23 75     	call	.NumLeadBlank1
  69+ 751A 0E F6        	ld	c,-10
  70+ 751C CD 23 75     	call	.NumLeadBlank1
  71+ 751F 0E FF        	ld	c,-1
  72+ 7521 18 B2        	jr		Num1
  73+ 7523              .NumLeadBlank1:
  74+ 7523 3E 2F        	ld	a,'0'-1
  75+ 7525              .NumLeadBlank2:
  76+ 7525 3C           	inc	a
  77+ 7526 09           	add	hl,bc
  78+ 7527 38 FC        	jr	c,.NumLeadBlank2
  79+ 7529 FE 30        	cp	'0'
  80+ 752B 20 02        	jr	nz,.DontBlank
  81+ 752D              .Blank:
  82+ 752D 3E 20        	ld	a,' '
  83+ 752F              .DontBlank:
  84+ 752F ED 42        	sbc	hl,bc
  85+ 7531 12           	ld	(de),a
  86+ 7532 13           	inc	de
  87+ 7533 C9           	ret
  88+ 7534              .NoStock:
  89+ 7534 3E 20        	ld	a,' '
  90+ 7536 12           	ld	(de),a
  91+ 7537 13           	inc	de
  92+ 7538 12           	ld	(de),a
  93+ 7539 13           	inc	de
  94+ 753A 3E 2D        	ld	a,'-'
  95+ 753C 12           	ld	(de),a
  96+ 753D 13           	inc de
  97+ 753E C9           	ret
  98+ 753F
  99+ 753F
 100+ 753F              ;### CLCN32 -> Converts 32Bit-Value in ASCII-String (terminated by 0)
 101+ 753F              ;### Input      DE,IX=32bit value, IY=destination address
 102+ 753F              ;### Output     IY=last char in destination string
 103+ 753F              ;### Destroyed AF,BC,DE,HL,IX
 104+ 753F 01 00 00 00  clcn32t dw 1,0,     10,0,     100,0,     1000,0,       10000,0
 104+ 7543 0A 00 00 00
 104+ 7547 64 00 00 00
 104+ 754B E8 03 00 00
 104+ 754F 10 27 00 00
 105+ 7553 A0 86 01 00          dw $86a0,1, $4240,$0f, $9680,$98, $e100,$05f5, $ca00,$3b9a
 105+ 7557 40 42 0F 00
 105+ 755B 80 96 98 00
 105+ 755F 00 E1 F5 05
 105+ 7563 00 CA 9A 3B
 106+ 7567 00 00 00 00  clcn32z ds 4
 107+ 756B
 108+ 756B              ; As per display but shifts final digit by 1 and puts in "." for 1 decimal place
 109+ 756B CD 7A 75     DispDEIXtoIY1DP:        call    DispDEIXtoIY
 110+ 756E FD 7E 00                             ld      a,(IY+0)
 111+ 7571 FD 77 01                             ld      (IY+1),a
 112+ 7574 3E 2E                                ld      a,"."
 113+ 7576 FD 77 00                             ld      (IY+0),a
 114+ 7579 C9                                   ret
 115+ 757A
 116+ 757A DD 22 67 75  DispDEIXtoIY:           ld (clcn32z),ix
 117+ 757E ED 53 69 75                          ld (clcn32z+2),de
 118+ 7582 DD 21 63 75                          ld ix,clcn32t+36
 119+ 7586 06 09                                ld b,9
 120+ 7588 0E 00                                ld c,0
 121+ 758A 3E 30        .clcn321:               ld a,'0'
 122+ 758C B7                                   or a
 123+ 758D DD 5E 00     .clcn322:               ld e,(ix+0)
 124+ 7590 DD 56 01                             ld d,(ix+1)
 125+ 7593 2A 67 75                             ld hl,(clcn32z)
 126+ 7596 ED 52                                sbc hl,de
 127+ 7598 22 67 75                             ld (clcn32z),hl
 128+ 759B DD 5E 02                             ld e,(ix+2)
 129+ 759E DD 56 03                             ld d,(ix+3)
 130+ 75A1 2A 69 75                             ld hl,(clcn32z+2)
 131+ 75A4 ED 52                                sbc hl,de
 132+ 75A6 22 69 75                             ld (clcn32z+2),hl
 133+ 75A9 38 04                                jr c,.clcn325
 134+ 75AB 0C                                   inc c
 135+ 75AC 3C                                   inc a
 136+ 75AD 18 DE                                jr .clcn322
 137+ 75AF DD 5E 00     .clcn325:               ld e,(ix+0)
 138+ 75B2 DD 56 01                             ld d,(ix+1)
 139+ 75B5 2A 67 75                             ld hl,(clcn32z)
 140+ 75B8 19                                   add hl,de
 141+ 75B9 22 67 75                             ld (clcn32z),hl
 142+ 75BC DD 5E 02                             ld e,(ix+2)
 143+ 75BF DD 56 03                             ld d,(ix+3)
 144+ 75C2 2A 69 75                             ld hl,(clcn32z+2)
 145+ 75C5 ED 5A                                adc hl,de
 146+ 75C7 22 69 75                             ld (clcn32z+2),hl
 147+ 75CA 11 FC FF                             ld de,-4
 148+ 75CD DD 19                                add ix,de
 149+ 75CF 0C                                   inc c
 150+ 75D0 0D                                   dec c
 151+ 75D1 28 05                                jr z,.clcn323
 152+ 75D3 FD 77 00                             ld (iy+0),a
 153+ 75D6 FD 23                                inc iy
 154+ 75D8 10 B0        .clcn323:               djnz .clcn321
 155+ 75DA 3A 67 75                             ld a,(clcn32z)
 156+ 75DD C6 30                                add A,'0'
 157+ 75DF FD 77 00                             ld (iy+0),a
 158+ 75E2 FD 36 01 00                          ld (iy+1),0
 159+ 75E6 C9                                   ret
 160+ 75E7
# file closed: ../../Maths/binary_to_decimal.asm
 679  75E7                  INCLUDE "../../Maths/asm_AequAdivQmul96.asm" ; AequAdivDmul96
# file opened: ../../Maths/asm_AequAdivQmul96.asm
   1+ 75E7              AequAdivQmul96ABS:      JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
   1+ 75E7 BA          >                        cp     d
   1+ 75E8 D2 03 76    >                        jp		nc,.TIS2AccGTEQ
   2+ 75EB 06 FE                                ld			b,$FE						; division roll (replaced varT)
   3+ 75ED CB 27        .TIS2RollTLoop:			sla			a
   4+ 75EF                                      JumpIfALTNusng d,.TIS2SkipSub           ; a < d so don;t subtract
   4+ 75EF BA          >                        cp      d
   4+ 75F0 DA 06 76    >                        jp		c, .TIS2SkipSub
   5+ 75F3 9A                                   sbc			a,d							; do subtraction with carry
   6+ 75F4 37                                   scf
   7+ 75F5 CB 10                                rl			b							; T rolled left to push bit out the end
   8+ 75F7 38 F4                                jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
   9+ 75F9 78           .TIS2SKIPCont:	        ld			a,b							; T
  10+ 75FA CB 3F                                srl			a							; result / 2
  11+ 75FC CB 3F                                srl			a							; result / 4
  12+ 75FE 47                                   ld			b,a							; t = t /4
  13+ 75FF CB 3F                                srl			a							; result / 8
  14+ 7601 80                                   add			a,b							; result /8 + result /4
  15+ 7602 C9                                   ret
  16+ 7603 3E 60        .TIS2AccGTEQ:           ld			a,$60							; unity
  17+ 7605 C9                                   ret
  18+ 7606 B7           .TIS2SkipSub:           or			a
  19+ 7607 CB 10                                rl			b							; T rolled left to push bit out the end
  20+ 7609 38 E2                                jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
  21+ 760B C3 F9 75                             jp			.TIS2SKIPCont
  22+ 760E
  23+ 760E
  24+ 760E              ;; USES 			A DE BC
  25+ 760E              ;; DOES NOT USE 	HL
  26+ 760E              ;TIS2962C:		; two's compliment entry point, exits not 2's compliment
  27+ 760E              ;	bit			        7,a
  28+ 760E              ;	jr			        z,AequAdivQmul96
  29+ 760E              ;	neg			        							; revers 2s'c and just set neg bit
  30+ 760E              ;	set			        7,a
  31+ 760E              ;; Note negative numbers are bit 7 set not 2's compliment
  32+ 760E              AequAdivQmul96:								; TIS296:			; .tis2 A = A /Q *96 (or A = A * 3/8 * Q) Reduce Acc in NORM routine i.e. *96/Q clamps at +- 96
  33+ 760E              TIS2:
  34+ 760E 4F                                   ld			c,a							; copy of Acc
  35+ 760F 3A 05 67                             ld			a,(varQ)
  36+ 7612 57                                   ld			d,a							; d = varQ
  37+ 7613 79                                   ld			a,c							; recover a
  38+ 7614 4F           AequAdivDmul967Bit:     ld          c,a
  39+ 7615 7A                                   ld          a,d
  40+ 7616 CB 27                                sla         a       ; wipe sign bit
  41+ 7618 C8                                   ret         z       ; quick exit if dividing 0 as a will have the result of 0
  42+ 7619 30 10                                jr          nc, .OKToDivide
  43+ 761B B7           .ScaleDown:             or          a       ; clear carry bit
  44+ 761C CB 3A                                srl         d       ; d >> 1 to get back to 7 bit value
  45+ 761E 79                                   ld          a,c
  46+ 761F E6 7F                                and         SignMask8Bit
  47+ 7621 CB 3F                                srl         a
  48+ 7623 47                                   ld          b,a
  49+ 7624 79                                   ld          a,c
  50+ 7625 E6 80                                and         $80
  51+ 7627 B0                                   or          b
  52+ 7628 C3 2C 76                             jp          AequAdivDmul96
  53+ 762B 79           .OKToDivide:            ld          a,c
  54+ 762C 4F           AequAdivDmul96:         ld			c,a							; copy of Acc as we need the sign, alternate entry point assuming D preloaded, wastes an "ld c,a" but simplifies code
  55+ 762D E6 7F                                and			SignMask8Bit				; ignore sign
  56+ 762F                                      JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
  56+ 762F BA          >                        cp     d
  56+ 7630 D2 50 76    >                        jp		nc,.TIS2AccGTEQ
  57+ 7633 06 FE                                ld			b,$FE						; division roll (replaced varT)
  58+ 7635              .TIS2RollTLoop:									; .TIL2	; roll T
  59+ 7635 CB 27                                sla			a
  60+ 7637                                      JumpIfALTNusng d,.TIS2SkipSub           ; a < d so don;t subtract
  60+ 7637 BA          >                        cp      d
  60+ 7638 DA 56 76    >                        jp		c, .TIS2SkipSub
  61+ 763B 9A                                   sbc			a,d							; do subtraction with carry
  62+ 763C 37                                   scf                                     ; set carrry to roll into b
  63+ 763D CB 10                                rl			b							; T rolled left to push bit out the end
  64+ 763F 38 F4                                jr			c,.TIS2RollTLoop			; if we still have not hit the empty marker continue
  65+ 7641 78           .TIS2SKIPCont:	        ld			a,b							; A = T = 4 / 4
  66+ 7642 CB 3F                                srl			a							; .
  67+ 7644 CB 3F                                srl			a							; .
  68+ 7646 47                                   ld			b,a							; .
  69+ 7647 CB 3F                                srl			a							; A = A / 2 (i.e. T /8)
  70+ 7649 80                                   add			a,b							; A = T/8 + T/4 (3T/8)
  71+ 764A 47                                   ld			b,a							; b = 3/8*Acc (max = 96)
  72+ 764B 79                                   ld			a,c							; copy of Acc to look at sign bit
  73+ 764C E6 80                                and			$80							; recover sign only
  74+ 764E B0                                   or			b							; now put b back in so we have a leading sign bit (note not 2's compliment)
  75+ 764F C9                                   ret
  76+ 7650              ;TI4:										;\ clean to +/- unity
  77+ 7650 79           .TIS2AccGTEQ:           ld			a,c
  78+ 7651 E6 80                                and			$80							; copy of Acc
  79+ 7653 F6 60                                or			$60							; unity
  80+ 7655 C9                                   ret
  81+ 7656              .TIS2SkipSub:           ClearCarryFlag                          ; Clear carry as it needs to be empty to roll in 0
  81+ 7656 B7          >                        or a
  82+ 7657 CB 10                                rl			b							; T rolled left to push bit out the end
  83+ 7659 38 DA                                jr			c,.TIS2RollTLoop			; if we still have not hit the empty marker continue
  84+ 765B C3 41 76                             jp			.TIS2SKIPCont
  85+ 765E
  86+ 765E
  87+ 765E
  88+ 765E              ; as per AequAdivDmul967Bit but Q is an 8 bit unsigned
  89+ 765E              ; a = a(S7)/Q(8u)*96
  90+ 765E 4F           AequAdivDmul96Q8:       ld          c,a                         ; c = a
  91+ 765F 7A           .CheckDivide0:          ld          a,d                         ; check if its a / 0
  92+ 7660 A7                                   and         a                           ; .
  93+ 7661 CA 88 76                             jp          z,.TIS2AccGTEQ              ; .
  94+ 7664 79           .NotDivide0:            ld          a,c                         ; get back value of A
  95+ 7665 E6 7F                                and         SignMask8Bit                ; and make it abs, so a = abs(a) c = original a
  96+ 7667                                      JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
  96+ 7667 BA          >                        cp     d
  96+ 7668 D2 88 76    >                        jp		nc,.TIS2AccGTEQ
  97+ 766B 06 FE                                ld			b,$FE						; division roll (replaced varT)
  98+ 766D              .TIS2RollTLoop:									; .TIL2	; roll T
  99+ 766D CB 27                                sla			a
 100+ 766F                                      JumpIfALTNusng d,.TIS2SkipSub           ; a < d so don;t subtract
 100+ 766F BA          >                        cp      d
 100+ 7670 DA 8E 76    >                        jp		c, .TIS2SkipSub
 101+ 7673 9A                                   sbc			a,d							; do subtraction with carry
 102+ 7674 37                                   scf                                     ; set carrry to roll into b
 103+ 7675 CB 10                                rl			b							; T rolled left to push bit out the end
 104+ 7677 38 F4                                jr			c,.TIS2RollTLoop			; if we still have not hit the empty marker continue
 105+ 7679 78           .TIS2SKIPCont:	        ld			a,b							; A = T = 4 / 4
 106+ 767A CB 3F                                srl			a							; .
 107+ 767C CB 3F                                srl			a							; .
 108+ 767E 47                                   ld			b,a							; .
 109+ 767F CB 3F                                srl			a							; A = A / 2 (i.e. T /8)
 110+ 7681 80                                   add			a,b							; A = T/8 + T/4 (3T/8)
 111+ 7682 47                                   ld			b,a							; b = 3/8*Acc (max = 96)
 112+ 7683 79                                   ld			a,c							; copy of Acc to look at sign bit
 113+ 7684 E6 80                                and			SignOnly8Bit    			; recover sign only
 114+ 7686 B0                                   or			b							; now put b back in so we have a leading sign bit (note not 2's compliment)
 115+ 7687 C9                                   ret
 116+ 7688              ;TI4:										;\ clean to +/- unity
 117+ 7688 79           .TIS2AccGTEQ:           ld			a,c
 118+ 7689 E6 80                                and			$80							; copy of Acc
 119+ 768B F6 60                                or			$60							; unity
 120+ 768D C9                                   ret
 121+ 768E              .TIS2SkipSub:           ClearCarryFlag                          ; Clear carry as it needs to be empty to roll in 0
 121+ 768E B7          >                        or a
 122+ 768F CB 10                                rl			b							; T rolled left to push bit out the end
 123+ 7691 38 DA                                jr			c,.TIS2RollTLoop			; if we still have not hit the empty marker continue
 124+ 7693 C3 79 76                             jp			.TIS2SKIPCont
 125+ 7696
 126+ 7696
# file closed: ../../Maths/asm_AequAdivQmul96.asm
 680  7696                  INCLUDE "../../Maths/Utilities/AequAmulQdiv256-FMLTU.asm"
# file opened: ../../Maths/Utilities/AequAmulQdiv256-FMLTU.asm
   1+ 7696              ; "ASM_FMUTKL .FMLTU	\ -> &2847  \ A=A*Q/256unsg  Fast multiply"
   2+ 7696              fmltu:
   3+ 7696 57           AequAmulQdiv256:        ld	d,a
   4+ 7697 3A 05 67                             ld	a,(varQ)
   5+ 769A 5F                                   ld	e,a
   6+ 769B ED 30                                mul
   7+ 769D 7A                                   ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
   8+ 769E C9                                   ret
   9+ 769F
  10+ 769F 5F           AequAmulDdiv256:        ld  e,a
  11+ 76A0 ED 30                                mul
  12+ 76A2 7A                                   ld  a,d
  13+ 76A3 C9                                   ret
  14+ 76A4
# file closed: ../../Maths/Utilities/AequAmulQdiv256-FMLTU.asm
 681  76A4                  ;INCLUDE "../../Maths/Utilities/PRequSpeedDivZZdiv8-DV42-DV42IYH.asm"
 682  76A4                  INCLUDE "../../Maths/Utilities/APequQmulA-MULT1.asm"
# file opened: ../../Maths/Utilities/APequQmulA-MULT1.asm
   1+ 76A4              APequQmulA:
   2+ 76A4              asm_mult1:
   3+ 76A4              ; "ASM_MULT1 (DE) A(hi).P(lo) = Q * A first part of MAD, multiply and add. Visited Quite often. A=hi P = lo also returns result in DE"
   4+ 76A4 FE 00        	cp	0
   5+ 76A6 28 1F        	jr	z,.mul0			; quick exit if its Q * 0
   6+ 76A8 5F           	ld	e,a
   7+ 76A9 3A 05 67     	ld	a,(varQ)
   8+ 76AC 57           	ld	d,a
   9+ 76AD FE 00        	cp	0				; compare a
  10+ 76AF 28 16        	jr	z,.mul0			; quick exit if its 0 * a
  11+ 76B1 AB           	xor	e				; -- = + +- = - -+ = - ++ = +
  12+ 76B2 E6 80        	and $80				; get the resultant sign and save into b
  13+ 76B4 47           	ld	b,a
  14+ 76B5 7A           	ld	a,d
  15+ 76B6 E6 7F        	and	SignMask8Bit	; now strip off sign bits
  16+ 76B8 57           	ld	d,a
  17+ 76B9 7B           	ld	a,e
  18+ 76BA E6 7F        	and SignMask8Bit
  19+ 76BC 5F           	ld	e,a
  20+ 76BD ED 30        	mul					; zxn de = d * e
  21+ 76BF 7B           	ld	a,e
  22+ 76C0 32 05 66     	ld	(varP),a		; p = lo
  23+ 76C3 7A           	ld	a,d				; a = hi
  24+ 76C4 B0           	or	b				; de goes to a and varP also re-do sign bit
  25+ 76C5 57           	ld	d,a				; we will work with de having result as we may bin vars later
  26+ 76C6 C9           	ret
  27+ 76C7              .mul0:
  28+ 76C7 AF           	xor	a
  29+ 76C8 32 05 66     	ld	(varP),a
  30+ 76CB 57           	ld	d,a
  31+ 76CC 5F           	ld  e,a
  32+ 76CD C9           	ret
  33+ 76CE
# file closed: ../../Maths/Utilities/APequQmulA-MULT1.asm
 683  76CE                  INCLUDE "../../Maths/Utilities/badd_ll38.asm"
# file opened: ../../Maths/Utilities/badd_ll38.asm
   1+ 76CE              baddll38:				;.LL38	\ -> &4812 \ BADD(S)A=R+Q(SA) \ byte add (subtract)   (Sign S)A = R + Q*(Sign from A^S)
   2+ 76CE              SAEquSRPlusAQ:
   3+ 76CE              ; Calculate the following between sign-magnitude numbers:
   4+ 76CE              ;   (S A) = (S R) + (A Q)
   5+ 76CE              ; where the sign bytes only contain the sign bits, not magnitudes.
   6+ 76CE              ; note goes wrong at <-127 >128 so need 16 bit version
   7+ 76CE              ; so need to fix the issue with carry flag not returning a fault correctly
   8+ 76CE              LL38:
   9+ 76CE              ;	ld		d,a
  10+ 76CE              ;	ld		a,(varQ)
  11+ 76CE              ;	ld		e,a
  12+ 76CE              ;	ld		a,(varS)
  13+ 76CE              ;	ld		h,a
  14+ 76CE              ;	ld		a,(varR)
  15+ 76CE              ;	ld		l,a
  16+ 76CE              ;	call	ADDHLDESignedv3
  17+ 76CE              ;	ld		a,h
  18+ 76CE              ;	ld		(varS),a
  19+ 76CE              ;	ld		a,l
  20+ 76CE              ;	ret
  21+ 76CE              ; calculation table
  22+ 76CE              ;   R     Q    Op            Sign calc
  23+ 76CE              ;	10    5    Add           +    sign same add R sign
  24+ 76CE              ;   -10   5    ABS Sub       -    sign diff ABS R > S sub R sign
  25+ 76CE              ;   10   -5    ABS sub       +    sign diff ABS R > S sub R sign
  26+ 76CE              ;	-10  -5    ABS Add       -    sign same add R sign
  27+ 76CE              ;   5    10    Add           +    sign same add R sign
  28+ 76CE              ;   -5   10    Swap ABS SUB  +    sign diff ABS Q > R swap SUB Q sign
  29+ 76CE              ;   5    -10   swap ABS Sub  -    sign diff ABS Q > R swap SUB R sign
  30+ 76CE              ;   -5   -10   ABS  add      -    sign same add R sign
  31+ 76CE
  32+ 76CE              ;   -10   5    ABS Sub       -    sign diff ABS R > S sub R sign
  33+ 76CE              ;   10   -5    ABS sub       +    sign diff ABS R > S sub R sign
  34+ 76CE              ;   -5   10    Swap ABS SUB  +    sign diff ABS Q > R swap SUB Q sign
  35+ 76CE              ;   5    -10   swap ABS Sub  -    sign diff ABS Q > R swap SUB R sign
  36+ 76CE
  37+ 76CE
  38+ 76CE              ; Calculate sign for Q from A and varS
  39+ 76CE 21 07 67     	ld		hl,varS							;
  40+ 76D1 AE           	xor		(hl)							;  EOR &83		\ S	\ sign of operator is A xor S
  41+ 76D2 FA DD 76     	jp		m,.LL39Subtraction  			; if signs are different then we have subtraction
  42+ 76D5 3A 05 67     	ld		a,(varQ)						; Q	\ else addition, S already correct
  43+ 76D8 21 06 67     	ld		hl,varR
  44+ 76DB 86           	add		a,(hl)							; a = Q + R
  45+ 76DC C9           	ret										; Done carry set if overflow
  46+ 76DD              .LL39Subtraction:							; 1 byte subtraction (S)A = R-Q
  47+ 76DD 3A 06 67     	ld		a,(varR)						; a = R
  48+ 76E0 21 05 67     	ld		hl,varQ                         ; Q
  49+ 76E3              ;--	JumpIfALTMemHLusng LL39SwapSubtraction	; if a < (hl) then do LL39SwapSubtraction
  50+ 76E3              	ClearCarryFlag                          ; we need to not use carry (6502 is different that it uses the compliement)
  50+ 76E3 B7          >                        or a
  51+ 76E4 9E           	sbc		a,(hl)							; A = R - Q which as R >= Q will always be a positive result
  52+ 76E5 38 01            jr      c,.LL39SignCorrection
  53+ 76E7              ;--    jr      a,.LL39ResultZero
  54+ 76E7              ;--   JumpIfNegative LL39SignCorrection		; if there was underflow we have to correct sign
  55+ 76E7              ;--	or		a								; Clear carry flag to say result is correct
  56+ 76E7 C9           	ret
  57+ 76E8              .LL39SignCorrection:
  58+ 76E8 FE 00            cp      0                               ; if its 0 then neg will affect flag so we just zero result to save compute
  59+ 76EA 28 0E            jr      z,.LL39ResultZero
  60+ 76EC ED 44            neg                                     ; flip A 2'c value to positive
  61+ 76EE 08           	ex		af,af'							; save A temporarily
  62+ 76EF 3A 07 67     	ld		a,(varS)						; Flip Sign bit in varS
  63+ 76F2 EE 80        	xor		$80							    ;
  64+ 76F4 32 07 67     	ld		(varS),a                        ; flip sign bit of a
  65+ 76F7 08           	ex		af,af'                          ; get back a which is the result
  66+ 76F8                  ClearCarryFlag                          ; clear carry as NEG instrunction sets it for non zero
  66+ 76F8 B7          >                        or a
  67+ 76F9 C9           	ret
  68+ 76FA              .LL39ResultZero:
  69+ 76FA 32 07 67         ld      (varS),a                        ; a is zero at this stage so set sign as well
  70+ 76FD                  ClearCarryFlag                          ; clear carry
  70+ 76FD B7          >                        or a
  71+ 76FE C9               ret
  72+ 76FF              ;--LL39SwapSubtraction:
  73+ 76FF              ;--	push	bc
  74+ 76FF              ;--	ld		b,a
  75+ 76FF              ;--	ld		a,(hl)
  76+ 76FF              ;--	sub		b
  77+ 76FF              ;--	pop		bc
  78+ 76FF              ;--	ex		af,af'							; do we flip here or negate. i think its flip as its overflowed unsigned
  79+ 76FF              ;--	ld		a,(varS)
  80+ 76FF              ;--	xor		$80
  81+ 76FF              ;--	ld		(varS),a
  82+ 76FF              ;--	ex		af,af'
  83+ 76FF              ;--	ret
  84+ 76FF
  85+ 76FF              ;;;;	baddll38:				;.LL38	\ -> &4812 \ BADD(S)A=R+Q(SA) \ byte add (subtract)   (Sign S)A = R + Q*(Sign from A^S)
  86+ 76FF              ;;;;; Calculate the following between sign-magnitude numbers:
  87+ 76FF              ;;;;;   (S A) = (S R) + (A Q)
  88+ 76FF              ;;;;; where the sign bytes only contain the sign bits, not magnitudes.
  89+ 76FF              ;;;;; note goes wrong at <-127 >128 so need 16 bit version
  90+ 76FF              ;;;;LL38:
  91+ 76FF              ;;;;; Calculate sign for Q from A and varS
  92+ 76FF              ;;;;	ld		hl,varS							;
  93+ 76FF              ;;;;	xor		(hl)							;  EOR &83		\ S	\ sign of operator is A xor S
  94+ 76FF              ;;;;	jp		m,.LL39Subtraction  			; if signs are different then we have subtraction
  95+ 76FF              ;;;;	ld		a,(varQ)						; Q	\ else addition, S already correct
  96+ 76FF              ;;;;	ld		hl,varR
  97+ 76FF              ;;;;	add		a,(hl)							; a = Q + R
  98+ 76FF              ;;;;	ret										; Done
  99+ 76FF              ;;;;.LL39Subtraction:							; 1 byte subtraction (S)A = R-Q
 100+ 76FF              ;;;;	ld		hl,varQ                         ;
 101+ 76FF              ;;;;	ld		a,(hl)
 102+ 76FF              ;;;;	JumpIfAGTENusng 128,LL39Sub16bit		; does this need to be 16 bit
 103+ 76FF              ;;;;	ld		a,(varR)						;
 104+ 76FF              ;;;;	ClearCarryFlag                          ; we need to not use carry (6502 is different that it uses the compliement)
 105+ 76FF              ;;;;	sbc		a,(hl)							; A = R - Q
 106+ 76FF              ;;;;	jr		c,.SignCorrection				; if there was underflow we have to correct sign
 107+ 76FF              ;;;;	or		a								; Clear carry flag to say result is correct
 108+ 76FF              ;;;;	ret
 109+ 76FF              ;;;;.SignCorrection:
 110+ 76FF              ;;;;    neg                                     ; flip A 2'c value to positive
 111+ 76FF              ;;;;	ex		af,af'							; save A temporarily
 112+ 76FF              ;;;;	ld		a,(varS)						; Flip Sign bit in varS
 113+ 76FF              ;;;;	xor		$80							    ;
 114+ 76FF              ;;;;	ld		(varS),a                        ; flip sign bit of a
 115+ 76FF              ;;;;	ex		af,af'                          ; get back a which is the result
 116+ 76FF              ;;;;	ret
 117+ 76FF              ;;;;LL39Sub16Bit:
 118+ 76FF              ;;;;	ld		e,a
 119+ 76FF              ;;;;	ld		d,0
 120+ 76FF              ;;;;	ld		a,(varR)
 121+ 76FF              ;;;;	ld		l,a
 122+ 76FF              ;;;;	ld		h,0
 123+ 76FF              ;;;;	ClearCarryFlag
 124+ 76FF              ;;;;	sbc		hl,de
 125+ 76FF              ;;;;	jr		c,.SignCorrection16bit
 126+ 76FF              ;;;;	bit		7,h
 127+ 76FF              ;;;;	jr		z,.GoodToReturn
 128+ 76FF              ;;;;.Needtonegate:
 129+ 76FF              ;;;;	macronegate16hl
 130+ 76FF              ;;;;.GoodToReturn
 131+ 76FF              ;;;;	ld		a,l
 132+ 76FF              ;;;;	or		a
 133+ 76FF              ;;;;	ret
 134+ 76FF              ;;;;.SignCorrection16bit:
 135+ 76FF              ;;;;	macronegate16hl
 136+ 76FF              ;;;;	ld		a,(varS)						; Flip Sign bit in varS
 137+ 76FF              ;;;;	xor		$80							    ;
 138+ 76FF              ;;;;	ld		(varS),a                        ; flip sign bit of a
 139+ 76FF              ;;;;	ld		a,l
 140+ 76FF              ;;;;	ret
 141+ 76FF
 142+ 76FF
# file closed: ../../Maths/Utilities/badd_ll38.asm
 684  76FF               ;   INCLUDE "../../Maths/Utilities/RequAmul256divQ-BFRDIV.asm"
 685  76FF               ;   INCLUDE "../../Maths/Utilities/RequAdivQ-LL61.asm"
 686  76FF               ;   INCLUDE "../../Maths/Utilities/RSequQmulA-MULT12.asm"
 687  76FF                  include "../../Universe/Ships/CopyRotMattoXX15.asm"
# file opened: ../../Universe/Ships/CopyRotMattoXX15.asm
   1+ 76FF              CopyRotMatNoseVtoXX15:
   2+ 76FF                      ldCopyByte  UBnkrotmatNosevX+1 ,XX15VecX
   2+ 76FF 3A 37 C0    >                        ld       a,(UBnkrotmatNosevX+1)
   2+ 7702 32 E7 C0    >                        ld       (XX15VecX),a
   3+ 7705                      ldCopyByte  UBnkrotmatNosevY+1, XX15VecY
   3+ 7705 3A 39 C0    >                        ld       a,(UBnkrotmatNosevY+1)
   3+ 7708 32 E8 C0    >                        ld       (XX15VecY),a
   4+ 770B                      ldCopyByte  UBnkrotmatNosevZ+1 ,XX15VecZ
   4+ 770B 3A 3B C0    >                        ld       a,(UBnkrotmatNosevZ+1)
   4+ 770E 32 E9 C0    >                        ld       (XX15VecZ),a
   5+ 7711 C9                   ret
   6+ 7712
   7+ 7712              CopyRotMatRoofVtoXX15:
   8+ 7712                      ldCopyByte  UBnkrotmatRoofvX+1 ,XX15VecX
   8+ 7712 3A 31 C0    >                        ld       a,(UBnkrotmatRoofvX+1)
   8+ 7715 32 E7 C0    >                        ld       (XX15VecX),a
   9+ 7718                      ldCopyByte  UBnkrotmatRoofvY+1, XX15VecY
   9+ 7718 3A 33 C0    >                        ld       a,(UBnkrotmatRoofvY+1)
   9+ 771B 32 E8 C0    >                        ld       (XX15VecY),a
  10+ 771E                      ldCopyByte  UBnkrotmatRoofvZ+1 ,XX15VecZ
  10+ 771E 3A 35 C0    >                        ld       a,(UBnkrotmatRoofvZ+1)
  10+ 7721 32 E9 C0    >                        ld       (XX15VecZ),a
  11+ 7724 C9                   ret
  12+ 7725
  13+ 7725              CopyRotMatSideVtoXX15:
  14+ 7725                      ldCopyByte  UBnkrotmatSidevX+1 ,XX15VecX
  14+ 7725 3A 2B C0    >                        ld       a,(UBnkrotmatSidevX+1)
  14+ 7728 32 E7 C0    >                        ld       (XX15VecX),a
  15+ 772B                      ldCopyByte  UBnkrotmatSidevY+1, XX15VecY
  15+ 772B 3A 2D C0    >                        ld       a,(UBnkrotmatSidevY+1)
  15+ 772E 32 E8 C0    >                        ld       (XX15VecY),a
  16+ 7731                      ldCopyByte  UBnkrotmatSidevZ+1 ,XX15VecZ
  16+ 7731 3A 2F C0    >                        ld       a,(UBnkrotmatSidevZ+1)
  16+ 7734 32 E9 C0    >                        ld       (XX15VecZ),a
  17+ 7737 C9                   ret
  18+ 7738
# file closed: ../../Universe/Ships/CopyRotMattoXX15.asm
 688  7738                  include "../../Universe/Ships/CopyXX15toRotMat.asm"
# file opened: ../../Universe/Ships/CopyXX15toRotMat.asm
   1+ 7738              CopyXX15toRotMatNoseV:
   2+ 7738                      ldCopyByte  XX15VecX, UBnkrotmatNosevX+1
   2+ 7738 3A E7 C0    >                        ld       a,(XX15VecX)
   2+ 773B 32 37 C0    >                        ld       (UBnkrotmatNosevX+1),a
   3+ 773E                      ldCopyByte  XX15VecY, UBnkrotmatNosevY+1
   3+ 773E 3A E8 C0    >                        ld       a,(XX15VecY)
   3+ 7741 32 39 C0    >                        ld       (UBnkrotmatNosevY+1),a
   4+ 7744                      ldCopyByte  XX15VecZ, UBnkrotmatNosevZ+1
   4+ 7744 3A E9 C0    >                        ld       a,(XX15VecZ)
   4+ 7747 32 3B C0    >                        ld       (UBnkrotmatNosevZ+1),a
   5+ 774A                      ZeroA
   5+ 774A AF          >                        xor a
   6+ 774B 32 36 C0             ld  (UBnkrotmatNosevX),a
   7+ 774E 32 38 C0             ld  (UBnkrotmatNosevY),a
   8+ 7751 32 3A C0             ld  (UBnkrotmatNosevZ),a
   9+ 7754 C9                   ret
  10+ 7755
  11+ 7755              CopyXX15toRotMatRoofV:
  12+ 7755                      ldCopyByte  XX15VecX, UBnkrotmatRoofvX+1
  12+ 7755 3A E7 C0    >                        ld       a,(XX15VecX)
  12+ 7758 32 31 C0    >                        ld       (UBnkrotmatRoofvX+1),a
  13+ 775B                      ldCopyByte  XX15VecY, UBnkrotmatRoofvY+1
  13+ 775B 3A E8 C0    >                        ld       a,(XX15VecY)
  13+ 775E 32 33 C0    >                        ld       (UBnkrotmatRoofvY+1),a
  14+ 7761                      ldCopyByte  XX15VecZ, UBnkrotmatRoofvZ+1
  14+ 7761 3A E9 C0    >                        ld       a,(XX15VecZ)
  14+ 7764 32 35 C0    >                        ld       (UBnkrotmatRoofvZ+1),a
  15+ 7767                      ZeroA
  15+ 7767 AF          >                        xor a
  16+ 7768 32 30 C0             ld  (UBnkrotmatRoofvX),a
  17+ 776B 32 32 C0             ld  (UBnkrotmatRoofvY),a
  18+ 776E 32 34 C0             ld  (UBnkrotmatRoofvZ),a
  19+ 7771 C9                   ret
  20+ 7772
  21+ 7772              CopyXX15toRotMatSideV:
  22+ 7772                      ldCopyByte  XX15VecX, UBnkrotmatSidevX+1
  22+ 7772 3A E7 C0    >                        ld       a,(XX15VecX)
  22+ 7775 32 2B C0    >                        ld       (UBnkrotmatSidevX+1),a
  23+ 7778                      ldCopyByte  XX15VecY, UBnkrotmatSidevY+1
  23+ 7778 3A E8 C0    >                        ld       a,(XX15VecY)
  23+ 777B 32 2D C0    >                        ld       (UBnkrotmatSidevY+1),a
  24+ 777E                      ldCopyByte  XX15VecZ, UBnkrotmatSidevZ+1
  24+ 777E 3A E9 C0    >                        ld       a,(XX15VecZ)
  24+ 7781 32 2F C0    >                        ld       (UBnkrotmatSidevZ+1),a
  25+ 7784                      ZeroA
  25+ 7784 AF          >                        xor a
  26+ 7785 32 2A C0             ld  (UBnkrotmatSidevX),a
  27+ 7788 32 2C C0             ld  (UBnkrotmatSidevY),a
  28+ 778B 32 2E C0             ld  (UBnkrotmatSidevZ),a
  29+ 778E C9                   ret
  30+ 778F
# file closed: ../../Universe/Ships/CopyXX15toRotMat.asm
 689  778F                  INCLUDE "../../Maths/asm_tidy.asm"
# file opened: ../../Maths/asm_tidy.asm
   1+ 778F              ; d = vector 1 e = vector 2 h = vector3 l = vector 4 b = vector 5
   2+ 778F              ; performs (d*e + h*l) / b and puts the result in de where e is 0
   3+ 778F C5           TidyCalc:       push    bc
   4+ 7790 CD 51 6B                     call    DEequDmulEs           ; de = vector 1 * vector 2
   5+ 7793 EB                           ex      hl,de                   ; get hl into de and save result of de
   6+ 7794 CD 51 6B                     call    DEequDmulEs           ; de = vector 2 * vector 3
   7+ 7797 CD 04 00                     call    AddDEtoHLSigned         ; BC = HL = HL + DE
   8+ 779A D1                           pop     de                      ; DE = BC saved from earlier
   9+ 779B 7C                           ld      a,h                     ; check for result 0
  10+ 779C B5                           or      l                       ; .
  11+ 779D CA BE 77                     jp      z,.ZeroResult           ; .
  12+ 77A0 44 4D                        ld      bc,hl                   ; .
  13+ 77A2 7A                           ld      a,d                     ; check for divide by zero
  14+ 77A3 A7                           and     a                       ; .
  15+ 77A4 CA B5 77                     jp      z,.MaxedResult          ; .
  16+ 77A7 5A                           ld      e,d                     ; now de = 0b (i.e. b register not hex value)
  17+ 77A8 16 00                        ld      d,0                     ;
  18+ 77AA CD 63 71                     call    Floor_DivQSigned        ; TO BE TESTED should do BC = BC / DE
  19+ 77AD 78                           ld      a,b                     ; sign bit from b
  20+ 77AE E6 80                        and     $80                     ; .
  21+ 77B0 B1                           or      c                       ; bring in the value
  22+ 77B1 57                           ld      d,a                     ; de = c0 (i.e. c register not hex value)
  23+ 77B2 1E 00                        ld      e,0                     ; .
  24+ 77B4 C9                           ret
  25+ 77B5 78           .MaxedResult:   ld      a,b                     ; make result signed unity (i.e. 1 or 96 in our case)
  26+ 77B6 EE 80                        xor     $80
  27+ 77B8 F6 60                        or      $60
  28+ 77BA 57                           ld      d,a
  29+ 77BB 1E 00                        ld      e,0
  30+ 77BD C9                           ret
  31+ 77BE 11 00 00     .ZeroResult:    ld      de,0
  32+ 77C1 C9                           ret
  33+ 77C2              ; as per tidy calc except
  34+ 77C2              ; d = vector 1 e = vector 2 h = vector3 l = vector 4
  35+ 77C2              ; performs (d*e - h*l) / 96 and puts the result in de where e is 0
  36+ 77C2
  37+ 77C2 CD 51 6B     TidySide:       call    DEequDmulEs           ; de = vector 1 * vector 2
  38+ 77C5 EB                           ex      de,hl                   ; get hl = vector 1 * vector 2
  39+ 77C6 CD 51 6B                     call    DEequDmulEs           ; de = vector 2 * vector 3
  40+ 77C9 CD 00 00                     call    SubDEfromHLSigned       ; BC = HL = HL - DE
  41+ 77CC 44 4D                        ld      bc,hl                   ; .
  42+ 77CE 11 60 00                     ld      de,$60                  ; now de = 96
  43+ 77D1 CD 63 71                     call    Floor_DivQSigned        ; TO BE TESTED should do BC = BC / DE
  44+ 77D4 78                           ld      a,b                     ; sign bit from b
  45+ 77D5 E6 80                        and     $80                     ; .
  46+ 77D7 B1                           or      c                       ; bring in the value
  47+ 77D8 57                           ld      d,a                     ; de = c0 (i.e. c register not hex value)
  48+ 77D9 1E 00                        ld      e,0                     ; .
  49+ 77DB C9                           ret
  50+ 77DC
  51+ 77DC              ;; orthonormalise vector for UBnK ship vector uses IX IT
  52+ 77DC                  DISPLAY "TidyVectorsIX"
  53+ 77DC DD 21 36 C0  TidyVectorsIX:  ld      ix,UBnkrotmatNosevX
  54+ 77E0 CD 06 74                     call    NormaliseIXVector       ; initially we normalise the nose vector
  55+ 77E3 3A 37 C0     .CheckNoseXSize:ld      a,(UBnkrotmatNosevX+1)  ; a = nose x
  56+ 77E6 E6 30                        and     %00110000                ; if bits 7 and 6 are clear the work with nosey
  57+ 77E8 CA 1C 78                     jp      z, .NoseXSmall
  58+ 77EB              ;-- When nosex is large ------------------------  roofv_x =-(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
  59+ 77EB 3A 39 C0     .NoseXLarge:    ld      a,(UBnkrotmatNosevY+1)  ; a = nose x
  60+ 77EE 57                           ld      d,a
  61+ 77EF 3A 33 C0                     ld      a,(UBnkrotmatRoofvY+1)  ; hl = nosev_y * roofv_y
  62+ 77F2 5F                           ld      e,a                     ; we already have d so only need roofY
  63+ 77F3 3A 3B C0                     ld      a,(UBnkrotmatNosevZ+1)  ; de = nosev_z * roofv_z
  64+ 77F6 67                           ld      h,a                     ; .
  65+ 77F7 3A 35 C0                     ld      a,(UBnkrotmatRoofvZ+1)  ; .
  66+ 77FA 6F                           ld      l,a                     ; .
  67+ 77FB 3A 37 C0                     ld      a,(UBnkrotmatNosevX+1)
  68+ 77FE 47                           ld      b,a
  69+ 77FF CD 8F 77                     call    TidyCalc
  70+ 7802 7A                           ld      a,d
  71+ 7803 B3                           or      e
  72+ 7804 CA 0B 78                     jp      z,.NoRoofXFlip
  73+ 7807 3E 80                        ld      a,$80                   ; flip sign bit if not zero
  74+ 7809 AA                           xor     d
  75+ 780A 57                           ld      d,a
  76+ 780B ED 53 30 C0  .NoRoofXFlip:   ld      (UBnkrotmatRoofvX),de   ; write roofvx
  77+ 780F C3 77 78                     jp      .NormaliseRoofv
  78+ 7812 11 00 E0     .MaxedRoofX:    ld      de,$E000                ; TEST if sign is correct for all of these if was divide by zero make it -1
  79+ 7815 ED 53 30 C0                  ld      (UBnkrotmatRoofvX),de   ; write roofvx
  80+ 7819 C3 77 78                     jp      .NormaliseRoofv
  81+ 781C              ;-- When noseX is small ------------------------ determine if we are doign roofz or roof y
  82+ 781C 3A 38 C0     .NoseXSmall:    ld      a,(UBnkrotmatNosevY)
  83+ 781F E6 60                        and     %01100000
  84+ 7821 CA 4F 78                     jp      z,.NoseYSmall
  85+ 7824              ;-- When noseY is large ------------------------ roofv_z = -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
  86+ 7824 3A 37 C0     .NoseYLarge:    ld      a,(UBnkrotmatNosevX+1)
  87+ 7827 57                           ld      d,a
  88+ 7828 3A 31 C0                     ld      a,(UBnkrotmatRoofvX+1)
  89+ 782B 5F                           ld      e,a
  90+ 782C 3A 39 C0                     ld      a,(UBnkrotmatNosevY+1)
  91+ 782F 67                           ld      h,a
  92+ 7830 3A 33 C0                     ld      a,(UBnkrotmatRoofvY+1)
  93+ 7833 6F                           ld      l,a
  94+ 7834 3A 3B C0                     ld      a,(UBnkrotmatNosevZ+1)
  95+ 7837 47                           ld      b,a
  96+ 7838 CD 8F 77                     call    TidyCalc
  97+ 783B 7A                           ld      a,d
  98+ 783C B3                           or      e
  99+ 783D CA 48 78                     jp      z,.NoRoofZFlip
 100+ 7840 3E 80                        ld      a,$80                   ; flip sign bit if not zero
 101+ 7842 AA                           xor     d
 102+ 7843 57                           ld      d,a
 103+ 7844 3E 80                        ld      a,$80                   ; flip sign bit
 104+ 7846 AA                           xor     d
 105+ 7847 57                           ld      d,a
 106+ 7848 ED 53 34 C0  .NoRoofZFlip:   ld      (UBnkrotmatRoofvZ),de   ; write roofvz
 107+ 784C C3 77 78                     jp      .NormaliseRoofv
 108+ 784F              ;-- When noseY is large ------------------------ roofv_y = -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
 109+ 784F 3A 37 C0     .NoseYSmall:    ld      a,(UBnkrotmatNosevX+1)
 110+ 7852 57                           ld      d,a
 111+ 7853 3A 31 C0                     ld      a,(UBnkrotmatRoofvX+1)
 112+ 7856 5F                           ld      e,a
 113+ 7857 3A 3B C0                     ld      a,(UBnkrotmatNosevZ+1)
 114+ 785A 67                           ld      h,a
 115+ 785B 3A 35 C0                     ld      a,(UBnkrotmatRoofvZ+1)
 116+ 785E 6F                           ld      l,a
 117+ 785F 3A 39 C0                     ld      a,(UBnkrotmatNosevY+1)
 118+ 7862 47                           ld      b,a
 119+ 7863 CD 8F 77                     call    TidyCalc
 120+ 7866 7A                           ld      a,d
 121+ 7867 B3                           or      e
 122+ 7868 CA 73 78                     jp      z,.NoRoofYFlip
 123+ 786B 3E 80                        ld      a,$80                   ; flip sign bit if not zero
 124+ 786D AA                           xor     d
 125+ 786E 57                           ld      d,a
 126+ 786F 3E 80                        ld      a,$80                   ; flip sign bit
 127+ 7871 AA                           xor     d
 128+ 7872 57                           ld      d,a
 129+ 7873 ED 53 32 C0  .NoRoofYFlip:   ld      (UBnkrotmatRoofvY),de   ; write roofvy
 130+ 7877 DD 21 30 C0  .NormaliseRoofv:ld      ix,UBnkrotmatRoofvX     ; now normalise roofv
 131+ 787B CD 06 74                     call    NormaliseIXVector
 132+ 787E              ; -- sidev_x = (nosev_z * roofv_y - nosev_y * roofv_z) / 96
 133+ 787E 3A 3B C0     .CalcSidevX:    ld      a,(UBnkrotmatNosevZ+1)
 134+ 7881 57                           ld      d,a
 135+ 7882 3A 33 C0                     ld      a,(UBnkrotmatRoofvY+1)
 136+ 7885 5F                           ld      e,a
 137+ 7886 3A 39 C0                     ld      a,(UBnkrotmatNosevY+1)
 138+ 7889 67                           ld      h,a
 139+ 788A 3A 35 C0                     ld      a,(UBnkrotmatRoofvZ+1)
 140+ 788D 6F                           ld      l,a
 141+ 788E CD C2 77                     call    TidySide
 142+ 7891 ED 53 2A C0                  ld      (UBnkrotmatSidevX),de   ; write sidevX
 143+ 7895              ; -- sidev_y = (nosev_x * roofv_z - nosev_z * roofv_x) / 96
 144+ 7895 3A 37 C0     .CalcSidevY:    ld      a,(UBnkrotmatNosevX+1)
 145+ 7898 57                           ld      d,a
 146+ 7899 3A 35 C0                     ld      a,(UBnkrotmatRoofvZ+1)
 147+ 789C 5F                           ld      e,a
 148+ 789D 3A 3B C0                     ld      a,(UBnkrotmatNosevZ+1)
 149+ 78A0 67                           ld      h,a
 150+ 78A1 3A 31 C0                     ld      a,(UBnkrotmatRoofvX+1)
 151+ 78A4 6F                           ld      l,a
 152+ 78A5 CD C2 77                     call    TidySide
 153+ 78A8 ED 53 2C C0                  ld      (UBnkrotmatSidevY),de   ; write sidevX
 154+ 78AC              ; -- sidev_z = (nosev_y * roofv_x - nosev_x * roofv_y) / 96
 155+ 78AC 3A 39 C0     .CalcSidevZ:    ld      a,(UBnkrotmatNosevY+1)
 156+ 78AF 57                           ld      d,a
 157+ 78B0 3A 31 C0                     ld      a,(UBnkrotmatRoofvX+1)
 158+ 78B3 5F                           ld      e,a
 159+ 78B4 3A 37 C0                     ld      a,(UBnkrotmatNosevX+1)
 160+ 78B7 67                           ld      h,a
 161+ 78B8 3A 33 C0                     ld      a,(UBnkrotmatRoofvY+1)
 162+ 78BB 6F                           ld      l,a
 163+ 78BC CD C2 77                     call    TidySide
 164+ 78BF ED 53 2E C0                  ld      (UBnkrotmatSidevZ),de   ; write sidevX
 165+ 78C3                          IFDEF ROUND_ROLL_AND_PITCH
 166+ 78C3 ~            .ClearLowBytes: ld      hl,UBnkrotmatSidevX
 167+ 78C3 ~                            ZeroA
 168+ 78C3 ~                            ld      b,9
 169+ 78C3 ~            .WriteLoop:     ld      (hl),a
 170+ 78C3 ~                            inc     hl
 171+ 78C3 ~                            inc     hl
 172+ 78C3 ~                            djnz    .WriteLoop
 173+ 78C3                          ENDIF
 174+ 78C3 C9                           ret
 175+ 78C4
# file closed: ../../Maths/asm_tidy.asm
 690  78C4               ;   INCLUDE "../../Maths/Utilities/LL28AequAmul256DivD.asm"
 691  78C4               ;   INCLUDE "../../Maths/Utilities/XAequMinusXAPplusRSdiv96-TIS1.asm"
 692  78C4                  INCLUDE "../../Menus/common_menu.asm"
# file opened: ../../Menus/common_menu.asm
   1+ 78C4 43 4F 4D 4D  txt_commander 			DB "COMMANDER",0
   1+ 78C8 41 4E 44 45
   1+ 78CC 52 00
   2+ 78CE 49 4E 56 45  txt_inventory 			DB "INVENTORY",0
   2+ 78D2 4E 54 4F 52
   2+ 78D6 59 00
   3+ 78D8 50 72 65 73  txt_present_system		DB "Present System   :",0
   3+ 78DC 65 6E 74 20
   3+ 78E0 53 79 73 74
   3+ 78E4 65 6D 20 20
   3+ 78E8 20 3A 00
   4+ 78EB 48 79 70 65  txt_hyperspace_system	DB "Hyperspace System:",0
   4+ 78EF 72 73 70 61
   4+ 78F3 63 65 20 53
   4+ 78F7 79 73 74 65
   4+ 78FB 6D 3A 00
   5+ 78FE 43 6F 6E 64  txt_condition			DB "Condition   :",0
   5+ 7902 69 74 69 6F
   5+ 7906 6E 20 20 20
   5+ 790A 3A 00
   6+ 790C 46 75 65 6C  txt_fuel				DB "Fuel        :",0
   6+ 7910 20 20 20 20
   6+ 7914 20 20 20 20
   6+ 7918 3A 00
   7+ 791A 43 61 73 68  txt_cash				DB "Cash        :",0
   7+ 791E 20 20 20 20
   7+ 7922 20 20 20 20
   7+ 7926 3A 00
   8+ 7928 4C 65 67 61  txt_legal_status		DB "Legal Status:",0
   8+ 792C 6C 20 53 74
   8+ 7930 61 74 75 73
   8+ 7934 3A 00
   9+ 7936 52 61 74 69  txt_rating				DB "Rating      :",0
   9+ 793A 6E 67 20 20
   9+ 793E 20 20 20 20
   9+ 7942 3A 00
  10+ 7944 45 51 55 49  txt_equipment			DB "EQUIPMENT:",0
  10+ 7948 50 4D 45 4E
  10+ 794C 54 3A 00
  11+ 794F
  12+ 794F 30 30 2E 30  txt_fuel_level			DB "00.0 Light Years",0
  12+ 7953 20 4C 69 67
  12+ 7957 68 74 20 59
  12+ 795B 65 61 72 73
  12+ 795F 00
  13+ 7960 58 58 58 58  txt_cash_amount			DB "XXXXXXXXXX",0
  13+ 7964 58 58 58 58
  13+ 7968 58 58 00
  14+ 796B 2E           txt_cash_decimal        DB "."
  15+ 796C 58 20 43 72  txt_cash_fraction       DB "X Cr",0
  15+ 7970 00
  16+ 7971
  17+ 7971              txt_status_colour		equ $FF
  18+ 7971              txt_highlight_colour    equ $D0
  19+ 7971
# file closed: ../../Menus/common_menu.asm
 693  7971              MainNonBankedCodeEnd:
 694  7971                  DISPLAY "Main Non Banked Code Ends at ",$
 695  7971
 696  7971              ; Bank 57  ------------------------------------------------------------------------------------------------------------------------
 697  7971                  SLOT    LAYER2Addr
 698  7971                  PAGE    BankLAYER2
 699  7971                  ORG     LAYER2Addr
 700  E000
 701  E000                  INCLUDE "../../Layer2Graphics/layer2_bank_select.asm"
# file opened: ../../Layer2Graphics/layer2_bank_select.asm
   1+ E000
   2+ E000 00           varL2_BANK_SELECTED			 DB	0
   3+ E001 00           varL2_CURRENT_BANK           DB	0
   4+ E002 00           varL2_BUFFER_MODE            DB 0
   5+ E003 00           varL2_ACCESS_MODE            DB 0
   6+ E004 00           varL2_SAVED_SELECT           DB 0
   7+ E005 00           varL2_SAVED_OFFSET           DB 0
   8+ E006
   9+ E006 3E 08        asm_l2_double_buffer_on:    ld      a,8
  10+ E008 32 02 E0                                 ld      (varL2_BUFFER_MODE),a
  11+ E00B C9                                       ret
  12+ E00C
  13+ E00C AF           asm_l2_double_buffer_off:   xor     a
  14+ E00D 32 02 E0                                 ld      (varL2_BUFFER_MODE),a
  15+ E010 C9                                       ret
  16+ E011
  17+ E011 01 3B 12     asm_disable_l2_readwrite:   ld      bc, IO_LAYER2_PORT
  18+ E014 ED 70                                    in      (c)
  19+ E016 32 03 E0                                 ld      (varL2_ACCESS_MODE),a
  20+ E019 E6 FA                                    and     LAYER2_DISABLE_MEM_ACCESS
  21+ E01B ED 79                                    out     (c),a
  22+ E01D C9                                       ret
  23+ E01E
  24+ E01E 3A 03 E0     asm_restore_l2_readwrite:   ld      a,(varL2_ACCESS_MODE)
  25+ E021 E6 05                                    and     LAYER2_READ_WRITE_MASK
  26+ E023 57                                       ld      d,a
  27+ E024 01 3B 12                                 ld      bc, IO_LAYER2_PORT
  28+ E027 ED 70                                    in      (c)
  29+ E029 32 03 E0                                 ld      (varL2_ACCESS_MODE),a
  30+ E02C A2                                       and     d
  31+ E02D ED 79                                    out     (c),a
  32+ E02F C9                                       ret
  33+ E030
  34+ E030 01 3B 12     asm_enable_l2_readwrite:    ld      bc, IO_LAYER2_PORT
  35+ E033 ED 70                                    in      (c)
  36+ E035 F6 05                                    or      LAYER2_READ_WRITE_MASK
  37+ E037 ED 79                                    out     (c),a
  38+ E039 C9                                       ret
  39+ E03A
  40+ E03A              ; "asm_l2_bank_select"
  41+ E03A              ; " a = sepecific bank mask value to select, does not set varL2_BANK_SELECTED"
  42+ E03A 57           asm_l2_bank_select:         ld      d,a
  43+ E03B FE 00                                    cp      0
  44+ E03D 28 08                                    jr      z,.NotBreakDebug
  45+ E03F FE 40                                    cp      $40
  46+ E041 28 04                                    jr      z,.NotBreakDebug
  47+ E043 FE 80                                    cp      $80
  48+ E045 28 00                                    jr      z,.NotBreakDebug
  49+ E047              .NotBreakDebug:
  50+ E047 3A 02 E0                                 ld      a,(varL2_BUFFER_MODE)
  51+ E04A F6 03                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK
  52+ E04C B2                                       or      d; | LAYER2_SHADOW_SCREEN_MASK
  53+ E04D 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
  54+ E050 ED 79                                    out 	(c),a
  55+ E052 C9                                       ret
  56+ E053              ;  "asm_l2_bank_select a = sepecific bank number to select, dsets varL2_BANK_SELECTED"
  57+ E053 32 00 E0     asm_l2_bank_n_select:       ld		(varL2_BANK_SELECTED),a
  58+ E056 FE 00                                    cp		0
  59+ E058 20 04                                    jr 		nz,.nottopbank
  60+ E05A 3E 00        .topbank:                   ld		a,LAYER2_SHIFTED_SCREEN_TOP
  61+ E05C 18 DC                                    jr		asm_l2_bank_select
  62+ E05E FE 01        .nottopbank:                cp		1
  63+ E060 20 04                                    jr 		nz,.notmiddlebank
  64+ E062 3E 40        .middlebank:                ld		a,LAYER2_SHIFTED_SCREEN_MIDDLE
  65+ E064 18 D4                                    jr		asm_l2_bank_select
  66+ E066 3E 80        .notmiddlebank:             ld		a,LAYER2_SHIFTED_SCREEN_BOTTOM ; default to bottom
  67+ E068 18 D0                                    jr		asm_l2_bank_select
  68+ E06A              		; Note no ret as its handled by above routines
  69+ E06A
  70+ E06A 3A 04 E0     asm_l2_reselect_saved_bank: ld      a,(varL2_SAVED_SELECT)  ; recover selected option
  71+ E06D 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
  72+ E070 ED 79                                    out 	(c),a
  73+ E072 3A 05 E0                                 ld      a,(varL2_SAVED_OFFSET)
  74+ E075 ED 79                                    out 	(c),a
  75+ E077 C9                                       ret
  76+ E078
  77+ E078
  78+ E078              asm_l2_bank_0_macro:        MACRO
  79+ E078 ~                                        ld      a,(varL2_BUFFER_MODE)
  80+ E078 ~                                        or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
  81+ E078 ~                                        ld      (varL2_SAVED_SELECT),a  ; save selected option
  82+ E078 ~                                        ld 		bc, IO_LAYER2_PORT
  83+ E078 ~                                        out 	(c),a
  84+ E078 ~                                        ld      a,%00010000             ; write bit 4 set so we can force a bank offset of 0 from top bank
  85+ E078 ~                                        ld      (varL2_SAVED_OFFSET),a
  86+ E078 ~                                        out 	(c),a
  87+ E078 ~                                        ZeroA						; set a to 0
  88+ E078 ~                                        ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  89+ E078                                          ENDM
  90+ E078
  91+ E078              asm_l2_bank_1_macro:        MACRO
  92+ E078 ~                                        ld      a,(varL2_BUFFER_MODE)
  93+ E078 ~                                        or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
  94+ E078 ~                                        ld      (varL2_SAVED_SELECT),a  ; save selected option
  95+ E078 ~                                        ld 		bc, IO_LAYER2_PORT
  96+ E078 ~                                        out 	(c),a
  97+ E078 ~                                        ld      a,%00010000             ; write bit 4 set so we can force a bank offset of 0 from middle bank
  98+ E078 ~                                        ld      (varL2_SAVED_OFFSET),a
  99+ E078 ~                                        out 	(c),a
 100+ E078 ~                                        ld      a,1						; set a to 0
 101+ E078 ~                                        ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 102+ E078                                          ENDM
 103+ E078
 104+ E078              asm_l2_bank_2_macro:        MACRO
 105+ E078 ~                                        ld      a,(varL2_BUFFER_MODE)
 106+ E078 ~                                        or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 107+ E078 ~                                        ld      (varL2_SAVED_SELECT),a  ; save selected option
 108+ E078 ~                                        ld 		bc, IO_LAYER2_PORT
 109+ E078 ~                                        out 	(c),a
 110+ E078 ~                                        ld      a,%00010000             ; write bit 4 set so we can force a bank offset of 0 from bottom bank
 111+ E078 ~                                        ld      (varL2_SAVED_OFFSET),a
 112+ E078 ~                                        out 	(c),a
 113+ E078 ~                                        ld      a,2						; set a to 0
 114+ E078 ~                                        ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 115+ E078                                          ENDM
 116+ E078
 117+ E078              asm_l2_bank_3_macro:        MACRO
 118+ E078 ~                                        ld      a,(varL2_BUFFER_MODE)
 119+ E078 ~                                        or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 120+ E078 ~                                        ld      (varL2_SAVED_SELECT),a  ; save selected option
 121+ E078 ~                                        ld 		bc, IO_LAYER2_PORT
 122+ E078 ~                                        out 	(c),a
 123+ E078 ~                                        ld      a,%00010001             ; write bit 4 set so we can force a bank offset of 1 from bottom bank
 124+ E078 ~                                        ld      (varL2_SAVED_OFFSET),a
 125+ E078 ~                                        out 	(c),a
 126+ E078 ~                                        ld      a,3						; set a to 0
 127+ E078 ~                                        ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 128+ E078                                          ENDM
 129+ E078
 130+ E078              asm_l2_bank_4_macro:        MACRO
 131+ E078 ~                                        ld      a,(varL2_BUFFER_MODE)
 132+ E078 ~                                        or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 133+ E078 ~                                        ld 		bc, IO_LAYER2_PORT
 134+ E078 ~                                        ld      (varL2_SAVED_SELECT),a  ; save selected option
 135+ E078 ~                                        out 	(c),a
 136+ E078 ~                                        ld      a,%00010010             ; write bit 4 set so we can force a bank offset of 2 from bottom bank
 137+ E078 ~                                        ld      (varL2_SAVED_OFFSET),a
 138+ E078 ~                                        out 	(c),a
 139+ E078 ~                                        ld      a,4						; set a to 0
 140+ E078 ~                                        ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 141+ E078                                          ENDM
 142+ E078
 143+ E078              ; "asm_l2_row_bank_select"
 144+ E078              ; "A (unsinged) = y row of pixel line from top, sets the bank to top middle or bottom and adjusts a reg to row memory address"
 145+ E078              ; "Could optimise by holding the previous bank but given its only an out statement it may not save T states at all"
 146+ E078              ; "destroys BC call de is safe a = adjusted poke pixel row"
 147+ E078              asm_l2_row_bank_select:     JumpIfAGTENusng 128, .BottomBank
 147+ E078 FE 80       >                        cp     128
 147+ E07A D2 CA E0    >                        jp		nc,.BottomBank
 148+ E07D                                          JumpIfAGTENusng 64, .MiddleBank
 148+ E07D FE 40       >                        cp     64
 148+ E07F D2 A4 E0    >                        jp		nc,.MiddleBank
 149+ E082 08                                       ex      af,af'
 150+ E083                                          JumpIfMemZero varL2_BANK_SELECTED, .NoTopChange
 150+ E083 3A 00 E0    >                        ld  a,(varL2_BANK_SELECTED)
 150+ E086 A7          >                        and a
 150+ E087 CA A2 E0    >                        jp  z,.NoTopChange
 151+ E08A                                          asm_l2_bank_0_macro
 151+ E08A 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 151+ E08D F6 03       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
 151+ E08F 32 04 E0    >                            ld      (varL2_SAVED_SELECT),a  ; save selected option
 151+ E092 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 151+ E095 ED 79       >                            out 	(c),a
 151+ E097 3E 10       >                            ld      a,%00010000             ; write bit 4 set so we can force a bank offset of 0 from top bank
 151+ E099 32 05 E0    >                            ld      (varL2_SAVED_OFFSET),a
 151+ E09C ED 79       >                            out 	(c),a
 151+ E09E             >                            ZeroA						; set a to 0
 151+ E09E AF          >                        xor a
 151+ E09F 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 152+ E0A2 08           .NoTopChange:               ex      af,af'
 153+ E0A3 C9                                       ret
 154+ E0A4 08           .MiddleBank:                ex      af,af'
 155+ E0A5                                          JumpIfMemEqNusng varL2_BANK_SELECTED, 1, .NoMiddleChange
 155+ E0A5 3A 00 E0    >                        ld  a,(varL2_BANK_SELECTED)
 155+ E0A8 FE 01       >                        cp  1
 155+ E0AA CA C6 E0    >                        jp  z,.NoMiddleChange
 156+ E0AD                                          asm_l2_bank_1_macro
 156+ E0AD 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 156+ E0B0 F6 43       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
 156+ E0B2 32 04 E0    >                            ld      (varL2_SAVED_SELECT),a  ; save selected option
 156+ E0B5 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 156+ E0B8 ED 79       >                            out 	(c),a
 156+ E0BA 3E 10       >                            ld      a,%00010000             ; write bit 4 set so we can force a bank offset of 0 from middle bank
 156+ E0BC 32 05 E0    >                            ld      (varL2_SAVED_OFFSET),a
 156+ E0BF ED 79       >                            out 	(c),a
 156+ E0C1 3E 01       >                            ld      a,1						; set a to 0
 156+ E0C3 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 157+ E0C6 08           .NoMiddleChange:            ex      af,af'
 158+ E0C7 D6 40                                    sub     64
 159+ E0C9 C9                                       ret
 160+ E0CA 08           .BottomBank:                ex      af,af'
 161+ E0CB                                          JumpIfMemEqNusng varL2_BANK_SELECTED, 2, .NoBottomChange
 161+ E0CB 3A 00 E0    >                        ld  a,(varL2_BANK_SELECTED)
 161+ E0CE FE 02       >                        cp  2
 161+ E0D0 CA EC E0    >                        jp  z,.NoBottomChange
 162+ E0D3                                          asm_l2_bank_2_macro
 162+ E0D3 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 162+ E0D6 F6 83       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 162+ E0D8 32 04 E0    >                            ld      (varL2_SAVED_SELECT),a  ; save selected option
 162+ E0DB 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 162+ E0DE ED 79       >                            out 	(c),a
 162+ E0E0 3E 10       >                            ld      a,%00010000             ; write bit 4 set so we can force a bank offset of 0 from bottom bank
 162+ E0E2 32 05 E0    >                            ld      (varL2_SAVED_OFFSET),a
 162+ E0E5 ED 79       >                            out 	(c),a
 162+ E0E7 3E 02       >                            ld      a,2						; set a to 0
 162+ E0E9 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 163+ E0EC 08           .NoBottomChange:            ex      af,af'
 164+ E0ED D6 80                                    sub     128
 165+ E0EF C9                                       ret
 166+ E0F0
 167+ E0F0
 168+ E0F0              ; "asm_l2_320_row_bank_select"
 169+ E0F0              ; HL (unsinged) = x column of pixel line from left, uses this to define bank
 170+ E0F0              ; 0-  63                    Bank 1
 171+ E0F0              ; 64- 127                   Bank 2
 172+ E0F0              ; 128 - 191                 Bank 3
 173+ E0F0              ; 192 - 255                 Bank 4
 174+ E0F0              ; 256 - 321                 Bank 5
 175+ E0F0              ; outputs h with the correct column number adjusted for bank selection
 176+ E0F0 7C           asm_l2_320_col_bank_select: ld      a,h
 177+ E0F1 A7                                       and     a
 178+ E0F2 C2 84 E1                                 jp      nz,.Bank5                       ; if high bit is set must be bank 5
 179+ E0F5 7D                                       ld      a,l
 180+ E0F6 E6 C0                                    and     %11000000                       ; if upper 2 bits are set then must be bank 4
 181+ E0F8 CA 00 E1                                 jp      z,.NotBank4
 182+ E0FB FE C0                                    cp      %11000000
 183+ E0FD CA 65 E1                                 jp      z,.Bank4
 184+ E100 7D           .NotBank4:                  ld      a,l                             ; try again with original number
 185+ E101 ED 27 80                                 test    %10000000                       ; if 128 or greater then must be bank 3
 186+ E104 C2 46 E1                                 jp      nz,.Bank3
 187+ E107 ED 27 40                                 test    %01000000                       ; if 64 to 127 then bank 2
 188+ E10A C2 27 E1                                 jp      nz,.Bank2
 189+ E10D              .Bank1:                     asm_l2_bank_0_macro
 189+ E10D 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 189+ E110 F6 03       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
 189+ E112 32 04 E0    >                            ld      (varL2_SAVED_SELECT),a  ; save selected option
 189+ E115 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 189+ E118 ED 79       >                            out 	(c),a
 189+ E11A 3E 10       >                            ld      a,%00010000             ; write bit 4 set so we can force a bank offset of 0 from top bank
 189+ E11C 32 05 E0    >                            ld      (varL2_SAVED_OFFSET),a
 189+ E11F ED 79       >                            out 	(c),a
 189+ E121             >                            ZeroA						; set a to 0
 189+ E121 AF          >                        xor a
 189+ E122 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 190+ E125 65                                       ld      h,l
 191+ E126 C9                                       ret
 192+ E127              .Bank2:                     asm_l2_bank_1_macro
 192+ E127 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 192+ E12A F6 43       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
 192+ E12C 32 04 E0    >                            ld      (varL2_SAVED_SELECT),a  ; save selected option
 192+ E12F 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 192+ E132 ED 79       >                            out 	(c),a
 192+ E134 3E 10       >                            ld      a,%00010000             ; write bit 4 set so we can force a bank offset of 0 from middle bank
 192+ E136 32 05 E0    >                            ld      (varL2_SAVED_OFFSET),a
 192+ E139 ED 79       >                            out 	(c),a
 192+ E13B 3E 01       >                            ld      a,1						; set a to 0
 192+ E13D 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 193+ E140                                          ClearCarryFlag
 193+ E140 B7          >                        or a
 194+ E141 7D                                       ld      a,l
 195+ E142 E6 BF                                    and     %10111111                       ; fast subtract 64, just clear bit
 196+ E144 67                                       ld      h,a
 197+ E145 C9                                       ret
 198+ E146              .Bank3:                     asm_l2_bank_2_macro
 198+ E146 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 198+ E149 F6 83       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 198+ E14B 32 04 E0    >                            ld      (varL2_SAVED_SELECT),a  ; save selected option
 198+ E14E 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 198+ E151 ED 79       >                            out 	(c),a
 198+ E153 3E 10       >                            ld      a,%00010000             ; write bit 4 set so we can force a bank offset of 0 from bottom bank
 198+ E155 32 05 E0    >                            ld      (varL2_SAVED_OFFSET),a
 198+ E158 ED 79       >                            out 	(c),a
 198+ E15A 3E 02       >                            ld      a,2						; set a to 0
 198+ E15C 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 199+ E15F                                          ClearCarryFlag
 199+ E15F B7          >                        or a
 200+ E160 7D                                       ld      a,l
 201+ E161 E6 7F                                    and     %01111111                       ; fast subtract 128, just clear bit
 202+ E163 67                                       ld      h,a
 203+ E164 C9                                       ret
 204+ E165              .Bank4:                     asm_l2_bank_3_macro
 204+ E165 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 204+ E168 F6 83       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 204+ E16A 32 04 E0    >                            ld      (varL2_SAVED_SELECT),a  ; save selected option
 204+ E16D 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 204+ E170 ED 79       >                            out 	(c),a
 204+ E172 3E 11       >                            ld      a,%00010001             ; write bit 4 set so we can force a bank offset of 1 from bottom bank
 204+ E174 32 05 E0    >                            ld      (varL2_SAVED_OFFSET),a
 204+ E177 ED 79       >                            out 	(c),a
 204+ E179 3E 03       >                            ld      a,3						; set a to 0
 204+ E17B 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 205+ E17E                                          ClearCarryFlag
 205+ E17E B7          >                        or a
 206+ E17F 7D                                       ld      a,l
 207+ E180 E6 3F                                    and     %00111111                       ; fast subtract 192, just clear bit
 208+ E182 67                                       ld      h,a
 209+ E183 C9                                       ret
 210+ E184              .Bank5:                     asm_l2_bank_4_macro
 210+ E184 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 210+ E187 F6 83       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 210+ E189 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 210+ E18C 32 04 E0    >                            ld      (varL2_SAVED_SELECT),a  ; save selected option
 210+ E18F ED 79       >                            out 	(c),a
 210+ E191 3E 12       >                            ld      a,%00010010             ; write bit 4 set so we can force a bank offset of 2 from bottom bank
 210+ E193 32 05 E0    >                            ld      (varL2_SAVED_OFFSET),a
 210+ E196 ED 79       >                            out 	(c),a
 210+ E198 3E 04       >                            ld      a,4						; set a to 0
 210+ E19A 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 211+ E19D 65                                       ld      h,l                             ; fast subtract 256, just clear bit
 212+ E19E C9                                       ret
 213+ E19F
 214+ E19F              ; takes current bank saved in varL2_BANK_SELECTED, increments it cycling around and selects
 215+ E19F              ; returns h with 0 for adjusted column number
 216+ E19F              ; note this is for a temp bank switch e.g. printing a character so does not load the varL2 values
 217+ E19F 3A 00 E0     asm_l2_320_next_bank:       ld      a,(varL2_BANK_SELECTED)
 218+ E1A2 3C                                       inc     a
 219+ E1A3 FE 05                                    cp      5
 220+ E1A5 C2 AA E1                                 jp      nz,.bankSelected
 221+ E1A8              .cycleToZero:               ZeroA
 221+ E1A8 AF          >                        xor a
 222+ E1A9 67                                       ld      h,a
 223+ E1AA 32 00 E0     .bankSelected:              ld      (varL2_BANK_SELECTED),a         ; mark new bank
 224+ E1AD A7                                       and     a
 225+ E1AE CA 0D E1                                 jp      z,asm_l2_320_col_bank_select.Bank1
 226+ E1B1 3D           .testBank2:                 dec     a
 227+ E1B2 CA 27 E1                                 jp      z,asm_l2_320_col_bank_select.Bank2
 228+ E1B5 3D           .testBank3:                 dec     a
 229+ E1B6 CA 46 E1                                 jp      z,asm_l2_320_col_bank_select.Bank3
 230+ E1B9 3D           .testBank4:                 dec     a
 231+ E1BA CA 65 E1                                 jp      z,asm_l2_320_col_bank_select.Bank4
 232+ E1BD C3 84 E1     .testBank5:                 jp      asm_l2_320_col_bank_select.Bank5
 233+ E1C0
 234+ E1C0              ; takes current bank saved in varL2_BANK_SELECTED, increments it cycling around and selects
 235+ E1C0              ; note this is for a temp bank switch e.g. printing a character so does not load the varL2 values
 236+ E1C0 3A 00 E0     asm_l2_320_next_bank_noSv:  ld      a,(varL2_BANK_SELECTED)
 237+ E1C3 3C                                       inc     a
 238+ E1C4 FE 05                                    cp      5
 239+ E1C6 C2 CA E1                                 jp      nz,.bankSelected
 240+ E1C9              .cycleToZero:               ZeroA
 240+ E1C9 AF          >                        xor a
 241+ E1CA A7           .bankSelected:              and     a
 242+ E1CB CA EC E1                                 jp      z,.Bank1
 243+ E1CE 3D           .testBank2:                 dec     a
 244+ E1CF CA FB E1                                 jp      z,.Bank2
 245+ E1D2 3D           .testBank3:                 dec     a
 246+ E1D3 CA 0A E2                                 jp      z,.Bank3
 247+ E1D6 3D           .testBank4:                 dec     a
 248+ E1D7 CA 19 E2                                 jp      z,.Bank4
 249+ E1DA 3D           .testBank5:                 dec     a
 250+ E1DB 3A 02 E0     .Bank5:                     ld      a,(varL2_BUFFER_MODE)
 251+ E1DE F6 83                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 252+ E1E0 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
 253+ E1E3 ED 79                                    out 	(c),a
 254+ E1E5 3E 12                                    ld      a,%00010010
 255+ E1E7 ED 79                                    out 	(c),a
 256+ E1E9 3E 04                                    ld      a,4						; set a to 0
 257+ E1EB C9                                       ret
 258+ E1EC 3A 02 E0     .Bank1:                     ld      a,(varL2_BUFFER_MODE)
 259+ E1EF F6 03                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
 260+ E1F1 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
 261+ E1F4 ED 79                                    out 	(c),a
 262+ E1F6 3E 10                                    ld      a,%00010000
 263+ E1F8 ED 79                                    out 	(c),a
 264+ E1FA C9                                       ret
 265+ E1FB 3A 02 E0     .Bank2:                     ld      a,(varL2_BUFFER_MODE)
 266+ E1FE F6 43                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
 267+ E200 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
 268+ E203 ED 79                                    out 	(c),a
 269+ E205 3E 10                                    ld      a,%00010000
 270+ E207 ED 79                                    out 	(c),a
 271+ E209 C9                                       ret
 272+ E20A 3A 02 E0     .Bank3:                     ld      a,(varL2_BUFFER_MODE)
 273+ E20D F6 83                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 274+ E20F 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
 275+ E212 ED 79                                    out 	(c),a
 276+ E214 3E 10                                    ld      a,%00010000
 277+ E216 ED 79                                    out 	(c),a
 278+ E218 C9                                       ret
 279+ E219 3A 02 E0     .Bank4:                     ld      a,(varL2_BUFFER_MODE)
 280+ E21C F6 83                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 281+ E21E 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
 282+ E221 ED 79                                    out 	(c),a
 283+ E223 3E 11                                    ld      a,%00010001
 284+ E225 ED 79                                    out 	(c),a
 285+ E227 C9                                       ret
 286+ E228
 287+ E228
 288+ E228
 289+ E228
# file closed: ../../Layer2Graphics/layer2_bank_select.asm
 702  E228                  INCLUDE "../../Layer2Graphics/layer2_cls.asm"
# file opened: ../../Layer2Graphics/layer2_cls.asm
   1+ E228
   2+ E228 00           l2_cls_byte	            DB 0
   3+ E229              ; ">DMA Command BLOCK"
   4+ E229
   5+ E229 83 C3 C7 CB  l2_fill                 DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   5+ E22D 7D
   6+ E22E 28 E2        l2_fill_astrt           DW l2_cls_byte
   7+ E230 00 40        l2_fill_length          DB $00,$40
   8+ E232 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
   9+ E235 00 00        l2_fill_bstrt           DB $00,$00
  10+ E237 82 CF B3 87                          DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
  11+ E23B              l2_fill_cmd_len	        EQU $ - l2_fill
  12+ E23B
  13+ E23B 83 C3 C7 CB  l2_fill_burst           DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
  13+ E23F 7D
  14+ E240 28 E2        .l2_fill_astrt          DW l2_cls_byte
  15+ E242 00 40        .l2_fill_length         DB $00,$40
  16+ E244 24 10 CD                             DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_BURST_MODE
  17+ E247 00 00        .l2_fill_bstrt          DB $00,$00
  18+ E249 82 CF B3 87                          DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
  19+ E24D              l2_fill_burst_cmd_len   EQU $ - l2_fill_burst
  20+ E24D
  21+ E24D              ; ">l2_cls_dma_bank sets a bank to"
  22+ E24D              l2_cls_dma_bank:
  23+ E24D 32 28 E2     .set_colour:            ld (l2_cls_byte),a
  24+ E250 21 29 E2     .write_dma:             ld hl, l2_fill
  25+ E253 06 12                                ld b, l2_fill_cmd_len
  26+ E255 0E 6B                                ld	c,IO_DATAGEAR_DMA_PORT
  27+ E257 ED B3                                otir
  28+ E259 C9                                   ret
  29+ E25A
  30+ E25A              ; ">l2_cls_dma_bank sets a bank to"
  31+ E25A              l2_cls_dma_bank_burst:
  32+ E25A 32 28 E2     .set_colour:            ld (l2_cls_byte),a
  33+ E25D 21 3B E2     .write_dma:             ld hl, l2_fill_burst
  34+ E260 06 12                                ld b, l2_fill_burst_cmd_len
  35+ E262 0E 6B                                ld	c,IO_DATAGEAR_DMA_PORT
  36+ E264 ED B3                                otir
  37+ E266 C9                                   ret
  38+ E267
  39+ E267 3E 00        l2_set_color_upper2:    ld      a,0
  40+ E269 CD 78 E0                             call asm_l2_row_bank_select
  41+ E26C 3A 28 E2                             ld      a,(l2_cls_byte)
  42+ E26F CD 4D E2                             call l2_cls_dma_bank
  43+ E272 3E 40                                ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
  44+ E274 CD 78 E0                             call asm_l2_row_bank_select
  45+ E277 3A 28 E2                             ld      a,(l2_cls_byte)
  46+ E27A CD 4D E2                             call l2_cls_dma_bank
  47+ E27D C9                                   ret
  48+ E27E
  49+ E27E
  50+ E27E              l2_cls_upper_two_thirds:;ld a,0								; pretend we are plotting pixel on row 0 to force top selection
  51+ E27E                                      asm_l2_bank_0_macro ; call asm_l2_row_bank_select
  51+ E27E 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  51+ E281 F6 03       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
  51+ E283 32 04 E0    >                            ld      (varL2_SAVED_SELECT),a  ; save selected option
  51+ E286 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  51+ E289 ED 79       >                            out 	(c),a
  51+ E28B 3E 10       >                            ld      a,%00010000             ; write bit 4 set so we can force a bank offset of 0 from top bank
  51+ E28D 32 05 E0    >                            ld      (varL2_SAVED_OFFSET),a
  51+ E290 ED 79       >                            out 	(c),a
  51+ E292             >                            ZeroA						; set a to 0
  51+ E292 AF          >                        xor a
  51+ E293 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  52+ E296 3E E3                                ld 	a,COLOUR_TRANSPARENT
  53+ E298 CD 4D E2                             call l2_cls_dma_bank
  54+ E29B                                      ;ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
  55+ E29B                                      asm_l2_bank_1_macro ;call asm_l2_row_bank_select
  55+ E29B 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  55+ E29E F6 43       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
  55+ E2A0 32 04 E0    >                            ld      (varL2_SAVED_SELECT),a  ; save selected option
  55+ E2A3 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  55+ E2A6 ED 79       >                            out 	(c),a
  55+ E2A8 3E 10       >                            ld      a,%00010000             ; write bit 4 set so we can force a bank offset of 0 from middle bank
  55+ E2AA 32 05 E0    >                            ld      (varL2_SAVED_OFFSET),a
  55+ E2AD ED 79       >                            out 	(c),a
  55+ E2AF 3E 01       >                            ld      a,1						; set a to 0
  55+ E2B1 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  56+ E2B4 3E E3                                ld 	a,COLOUR_TRANSPARENT
  57+ E2B6 CD 4D E2                             call l2_cls_dma_bank
  58+ E2B9 C9                                   ret
  59+ E2BA
  60+ E2BA              l2_cls_upper_two_thirds_burst:;ld a,0								; pretend we are plotting pixel on row 0 to force top selection
  61+ E2BA                                      asm_l2_bank_0_macro ; call asm_l2_row_bank_select
  61+ E2BA 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  61+ E2BD F6 03       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
  61+ E2BF 32 04 E0    >                            ld      (varL2_SAVED_SELECT),a  ; save selected option
  61+ E2C2 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  61+ E2C5 ED 79       >                            out 	(c),a
  61+ E2C7 3E 10       >                            ld      a,%00010000             ; write bit 4 set so we can force a bank offset of 0 from top bank
  61+ E2C9 32 05 E0    >                            ld      (varL2_SAVED_OFFSET),a
  61+ E2CC ED 79       >                            out 	(c),a
  61+ E2CE             >                            ZeroA						; set a to 0
  61+ E2CE AF          >                        xor a
  61+ E2CF 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  62+ E2D2 3E E3                                ld 	a,COLOUR_TRANSPARENT
  63+ E2D4 CD 5A E2                             call l2_cls_dma_bank_burst
  64+ E2D7                                      ;ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
  65+ E2D7                                      asm_l2_bank_1_macro ;call asm_l2_row_bank_select
  65+ E2D7 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  65+ E2DA F6 43       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
  65+ E2DC 32 04 E0    >                            ld      (varL2_SAVED_SELECT),a  ; save selected option
  65+ E2DF 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  65+ E2E2 ED 79       >                            out 	(c),a
  65+ E2E4 3E 10       >                            ld      a,%00010000             ; write bit 4 set so we can force a bank offset of 0 from middle bank
  65+ E2E6 32 05 E0    >                            ld      (varL2_SAVED_OFFSET),a
  65+ E2E9 ED 79       >                            out 	(c),a
  65+ E2EB 3E 01       >                            ld      a,1						; set a to 0
  65+ E2ED 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  66+ E2F0 3E E3                                ld 	a,COLOUR_TRANSPARENT
  67+ E2F2 CD 5A E2                             call l2_cls_dma_bank_burst
  68+ E2F5 C9                                   ret
  69+ E2F6
  70+ E2F6              l2_cls_lower_third:     ;ld a,128							; pretend we are plotting pixel on row 64 to force mid selection
  71+ E2F6                                      asm_l2_bank_2_macro; call asm_l2_row_bank_select
  71+ E2F6 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  71+ E2F9 F6 83       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
  71+ E2FB 32 04 E0    >                            ld      (varL2_SAVED_SELECT),a  ; save selected option
  71+ E2FE 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  71+ E301 ED 79       >                            out 	(c),a
  71+ E303 3E 10       >                            ld      a,%00010000             ; write bit 4 set so we can force a bank offset of 0 from bottom bank
  71+ E305 32 05 E0    >                            ld      (varL2_SAVED_OFFSET),a
  71+ E308 ED 79       >                            out 	(c),a
  71+ E30A 3E 02       >                            ld      a,2						; set a to 0
  71+ E30C 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  72+ E30F 3E E3                                ld 	a,COLOUR_TRANSPARENT
  73+ E311 CD 4D E2                             call l2_cls_dma_bank
  74+ E314 C9                                   ret
  75+ E315
  76+ E315              l2_cls_lower_third_burst:asm_l2_bank_2_macro; call asm_l2_row_bank_select
  76+ E315 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  76+ E318 F6 83       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
  76+ E31A 32 04 E0    >                            ld      (varL2_SAVED_SELECT),a  ; save selected option
  76+ E31D 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  76+ E320 ED 79       >                            out 	(c),a
  76+ E322 3E 10       >                            ld      a,%00010000             ; write bit 4 set so we can force a bank offset of 0 from bottom bank
  76+ E324 32 05 E0    >                            ld      (varL2_SAVED_OFFSET),a
  76+ E327 ED 79       >                            out 	(c),a
  76+ E329 3E 02       >                            ld      a,2						; set a to 0
  76+ E32B 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  77+ E32E 3E E3                                ld 	a,COLOUR_TRANSPARENT
  78+ E330 CD 5A E2                             call l2_cls_dma_bank_burst
  79+ E333 C9                                   ret
  80+ E334
  81+ E334
  82+ E334 CD BA E2     l2_cls_burst:           call l2_cls_upper_two_thirds_burst
  83+ E337 C3 15 E3                             jp   l2_cls_lower_third_burst
  84+ E33A
  85+ E33A
  86+ E33A CD 7E E2     l2_cls:                 call l2_cls_upper_two_thirds
  87+ E33D C3 F6 E2                             jp   l2_cls_lower_third
  88+ E340              	    IFDEF L2_640_SUPPORT
  89+ E340 ~            l2_640_cls:
  90+ E340                      ENDIF
  91+ E340 CD 7E E2     l2_320_cls:             call l2_cls_upper_two_thirds
  92+ E343 CD F6 E2                             call   l2_cls_lower_third
  93+ E346                                      ; need to clear banks 4 and 5 via normal paging, say into C000 with interrupts disabled
  94+ E346                                      asm_l2_bank_3_macro
  94+ E346 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  94+ E349 F6 83       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
  94+ E34B 32 04 E0    >                            ld      (varL2_SAVED_SELECT),a  ; save selected option
  94+ E34E 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  94+ E351 ED 79       >                            out 	(c),a
  94+ E353 3E 11       >                            ld      a,%00010001             ; write bit 4 set so we can force a bank offset of 1 from bottom bank
  94+ E355 32 05 E0    >                            ld      (varL2_SAVED_OFFSET),a
  94+ E358 ED 79       >                            out 	(c),a
  94+ E35A 3E 03       >                            ld      a,3						; set a to 0
  94+ E35C 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  95+ E35F 3E E3                                ld 	a,COLOUR_TRANSPARENT
  96+ E361 CD 4D E2                             call l2_cls_dma_bank
  97+ E364                                      asm_l2_bank_4_macro
  97+ E364 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  97+ E367 F6 83       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
  97+ E369 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  97+ E36C 32 04 E0    >                            ld      (varL2_SAVED_SELECT),a  ; save selected option
  97+ E36F ED 79       >                            out 	(c),a
  97+ E371 3E 12       >                            ld      a,%00010010             ; write bit 4 set so we can force a bank offset of 2 from bottom bank
  97+ E373 32 05 E0    >                            ld      (varL2_SAVED_OFFSET),a
  97+ E376 ED 79       >                            out 	(c),a
  97+ E378 3E 04       >                            ld      a,4						; set a to 0
  97+ E37A 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  98+ E37D 3E E3                                ld 	a,COLOUR_TRANSPARENT
  99+ E37F CD 4D E2                             call l2_cls_dma_bank
 100+ E382
 101+ E382 C9                                   ret
 102+ E383
# file closed: ../../Layer2Graphics/layer2_cls.asm
 703  E383                  INCLUDE "../../Layer2Graphics/layer2_initialise.asm"
# file opened: ../../Layer2Graphics/layer2_initialise.asm
   1+ E383
   2+ E383 00 00        l2_graphic_mode         DW          0
   3+ E385
   4+ E385 ED 91 70 00  l2_initialise:          nextreg     LAYER_2_CONTROL_REGISTER,           %00000000               ; 256x192x8bpp
   5+ E389 ED 91 1C 00                          nextreg     CLIP_WINDOW_CONTROL_REGISTER,       0
   6+ E38D ED 91 18 00                          nextreg     CLIP_WINDOW_LAYER2_REGISTER,        0
   7+ E391 ED 91 18 FF                          nextreg     CLIP_WINDOW_LAYER2_REGISTER,        255
   8+ E395 ED 91 18 00                          nextreg     CLIP_WINDOW_LAYER2_REGISTER,        0
   9+ E399 ED 91 18 C0                          nextreg     CLIP_WINDOW_LAYER2_REGISTER,        192
  10+ E39D ED 91 12 08                          nextreg		LAYER2_RAM_PAGE_REGISTER,          	LAYER2_SCREEN_BANK1
  11+ E3A1 ED 91 13 0D                          nextreg		LAYER2_RAM_SHADOW_REGISTER,     	LAYER2_SHADOW_BANK1
  12+ E3A5 ED 91 14 E3                          nextreg		TRANSPARENCY_COLOUR_REGISTER, 		COLOUR_TRANSPARENT
  13+ E3A9                                      ZeroA
  13+ E3A9 AF          >                        xor a
  14+ E3AA 32 83 E3                             ld          (l2_graphic_mode),a
  15+ E3AD                                      DoubleBufferIfPossible
  15+ E3AD             >                        IFDEF DOUBLEBUFFER
  15+ E3AD ~           >                            MMUSelectLayer2
  15+ E3AD ~           >                            call  l2_cls
  15+ E3AD ~           >                            call  l2_flip_buffers
  15+ E3AD             >                        ENDIF
  16+ E3AD                                      DoubleBufferIfPossible
  16+ E3AD             >                        IFDEF DOUBLEBUFFER
  16+ E3AD ~           >                            MMUSelectLayer2
  16+ E3AD ~           >                            call  l2_cls
  16+ E3AD ~           >                            call  l2_flip_buffers
  16+ E3AD             >                        ENDIF
  17+ E3AD CD 78 E0                             call        asm_l2_row_bank_select
  18+ E3B0 C9                                   ret
  19+ E3B1
  20+ E3B1
  21+ E3B1 ED 91 70 10  l2_320_initialise:      nextreg     LAYER_2_CONTROL_REGISTER,           %00010000               ; 320x256x8bpp
  22+ E3B5 ED 91 1C 00                          nextreg     CLIP_WINDOW_CONTROL_REGISTER,       0
  23+ E3B9 ED 91 18 00                          nextreg     CLIP_WINDOW_LAYER2_REGISTER,        0
  24+ E3BD ED 91 18 9F                          nextreg     CLIP_WINDOW_LAYER2_REGISTER,        159
  25+ E3C1 ED 91 18 00                          nextreg     CLIP_WINDOW_LAYER2_REGISTER,        0
  26+ E3C5 ED 91 18 FF                          nextreg     CLIP_WINDOW_LAYER2_REGISTER,        255
  27+ E3C9 ED 91 12 08                          nextreg		LAYER2_RAM_PAGE_REGISTER,          	LAYER2_SCREEN_BANK1
  28+ E3CD ED 91 13 0D                          nextreg		LAYER2_RAM_SHADOW_REGISTER,     	LAYER2_SHADOW_BANK1
  29+ E3D1 ED 91 14 E3                          nextreg		TRANSPARENCY_COLOUR_REGISTER, 		COLOUR_TRANSPARENT
  30+ E3D5 C9                                   ret
  31+ E3D6 3E 01                                ld          a,1
  32+ E3D8 32 83 E3                             ld          (l2_graphic_mode),a
  33+ E3DB                                      DoubleBuffer320IfPossible
  33+ E3DB             >                        IFDEF DOUBLEBUFFER
  33+ E3DB ~           >                            MMUSelectLayer2
  33+ E3DB ~           >                            call  l2_320_cls
  33+ E3DB ~           >                            call  l2_flip_buffers
  33+ E3DB             >                        ENDIF
  34+ E3DB                                      DoubleBuffer320IfPossible
  34+ E3DB             >                        IFDEF DOUBLEBUFFER
  34+ E3DB ~           >                            MMUSelectLayer2
  34+ E3DB ~           >                            call  l2_320_cls
  34+ E3DB ~           >                            call  l2_flip_buffers
  34+ E3DB             >                        ENDIF
  35+ E3DB C9                                   ret
  36+ E3DC                  IFDEF L2_640_SUPPORT
  37+ E3DC ~            l2_640_initialise:      nextreg     LAYER_2_CONTROL_REGISTER,           %00100000               ; 320x256x8bpp
  38+ E3DC ~                                    nextreg     CLIP_WINDOW_CONTROL_REGISTER,       0
  39+ E3DC ~                                    nextreg     CLIP_WINDOW_LAYER2_REGISTER,        0
  40+ E3DC ~                                    nextreg     CLIP_WINDOW_LAYER2_REGISTER,        159
  41+ E3DC ~                                    nextreg     CLIP_WINDOW_LAYER2_REGISTER,        0
  42+ E3DC ~                                    nextreg     CLIP_WINDOW_LAYER2_REGISTER,        255
  43+ E3DC ~                                    nextreg		LAYER2_RAM_PAGE_REGISTER,          	LAYER2_SCREEN_BANK1
  44+ E3DC ~                                    nextreg		LAYER2_RAM_SHADOW_REGISTER,     	LAYER2_SHADOW_BANK1
  45+ E3DC ~                                    nextreg		TRANSPARENCY_COLOUR_REGISTER, 		COLOUR_TRANSPARENT
  46+ E3DC ~                                    ld          a,2
  47+ E3DC ~                                    ld          (l2_graphic_mode),a
  48+ E3DC ~                                    DoubleBuffer640IfPossible
  49+ E3DC ~                                    DoubleBuffer640IfPossible
  50+ E3DC ~                                    call        asm_l2_640_col_bank_select
  51+ E3DC ~                                    ret
  52+ E3DC                  ENDIF
# file closed: ../../Layer2Graphics/layer2_initialise.asm
 704  E3DC                  INCLUDE "../../Layer2Graphics/l2_flip_buffers.asm"
# file opened: ../../Layer2Graphics/l2_flip_buffers.asm
   1+ E3DC              l2_flip_buffers:        GetNextReg LAYER2_RAM_PAGE_REGISTER
   1+ E3DC 01 3B 24    >            ld bc,$243B
   1+ E3DF 3E 12       >            ld a,LAYER2_RAM_PAGE_REGISTER
   1+ E3E1 ED 79       >            out (c),a
   1+ E3E3 04          >            inc b
   1+ E3E4 ED 78       >            in a,(c)
   2+ E3E6 57                                   ld      d,a
   3+ E3E7                                      GetNextReg LAYER2_RAM_SHADOW_REGISTER
   3+ E3E7 01 3B 24    >            ld bc,$243B
   3+ E3EA 3E 13       >            ld a,LAYER2_RAM_SHADOW_REGISTER
   3+ E3EC ED 79       >            out (c),a
   3+ E3EE 04          >            inc b
   3+ E3EF ED 78       >            in a,(c)
   4+ E3F1 5F                                   ld      e,a
   5+ E3F2 ED 92 12                             nextreg LAYER2_RAM_PAGE_REGISTER, a
   6+ E3F5 7A                                   ld      a,d
   7+ E3F6 ED 92 13                             nextreg LAYER2_RAM_SHADOW_REGISTER, a
   8+ E3F9 C9                                   ret
   9+ E3FA
# file closed: ../../Layer2Graphics/l2_flip_buffers.asm
 705  E3FA                  INCLUDE "../../Layer2Graphics/layer2_plot_pixel.asm"
# file opened: ../../Layer2Graphics/layer2_plot_pixel.asm
   1+ E3FA
   2+ E3FA DF           line_gfx_colour db $DF
   3+ E3FB
   4+ E3FB              l2_plot_macro:          MACRO
   5+ E3FB ~                                    ld      a,b
   6+ E3FB ~                                    JumpIfAGTENusng 192 ,.NoPlot
   7+ E3FB ~                                    ld      l,c
   8+ E3FB ~                                    call    asm_l2_row_bank_select
   9+ E3FB ~                                    ld      h,a
  10+ E3FB ~                                    ld      a,(line_gfx_colour)
  11+ E3FB ~                                    ld      (hl),a
  12+ E3FB ~            .NoPlot:
  13+ E3FB                                      ENDM
  14+ E3FB
  15+ E3FB
  16+ E3FB              ; ">l2_plot_pixel b= row number, c = column number, a = pixel col"
  17+ E3FB F5           l2_plot_pixel:          push    af
  18+ E3FC 78                                   ld      a,b
  19+ E3FD              l2_pp_row_valid:        JumpIfAGTENusng ScreenHeight,l2_pp_dont_plot
  19+ E3FD FE C0       >                        cp     ScreenHeight
  19+ E3FF D2 0D E4    >                        jp		nc,l2_pp_dont_plot
  20+ E402 C5                                   push    bc								; bank select destroys bc so need to save it
  21+ E403                                  ;	ld      a,b
  22+ E403 CD 78 E0                             call    asm_l2_row_bank_select
  23+ E406 C1                                   pop     bc
  24+ E407 47                                   ld      b,a
  25+ E408 60                                   ld      h,b								; hl now holds ram address after bank select
  26+ E409 69                                   ld      l,c
  27+ E40A F1                                   pop     af								; a = colour to plott
  28+ E40B 77                                   ld      (hl),a
  29+ E40C C9                                   ret
  30+ E40D F1           l2_pp_dont_plot:        pop     af
  31+ E40E C9                                   ret
  32+ E40F
  33+ E40F              ; ">l2_plot_pixel d= row number, hl = column number, e = pixel col"
  34+ E40F 7C           l2_plot_pixel_320:      ld      a,h
  35+ E410 A7           .checkXlt256:           and     a                               ; if h = 0 then must be < 256 so OK
  36+ E411 CA 1D E4                             jp      z,.DoneCheck
  37+ E414 FE 01        .checkXgt320:           cp      1                               ; if h <> 1 then must be > 320
  38+ E416 20 0B                                jr      nz,.DontPlot                    ;
  39+ E418 7D                                   ld      a,l                             ; so now its >= 256
  40+ E419 E6 C0        .checkXlt320:           and     %11000000                       ; if its 7 or 6 set then > 319
  41+ E41B 20 06                                jr      nz,.DontPlot
  42+ E41D CD F0 E0     .DoneCheck:             call    asm_l2_320_col_bank_select      ; adjust hl for hl address which is now in l only
  43+ E420 6A                                   ld      l,d                             ; low byte is row from d
  44+ E421 7B                                   ld      a,e                             ; a= color
  45+ E422 77                                   ld      (hl),a
  46+ E423 C9           .DontPlot:              ret
  47+ E424
  48+ E424              ; ">l2_plot_pixel d= row number, hl = column number"
  49+ E424              ; as per plot but just selects address and adjusts hl to target address column in h
  50+ E424 7C           l2_target_address_320:  ld      a,h
  51+ E425 A7                                   and     a                               ; if h = 0 then must be < 256 so OK
  52+ E426 CA 32 E4                             jp      z,.DoneCheck
  53+ E429 FE 01                                cp      1                               ; if h <> 1 then must be > 320
  54+ E42B 20 09                                jr      nz,.DontPlot                    ;
  55+ E42D 7D                                   ld      a,l                             ; so now its >= 256
  56+ E42E E6 C0                                and     %11000000                       ; if its 7 or 6 set then > 319
  57+ E430 20 04                                jr      nz,.DontPlot
  58+ E432 CD F0 E0     .DoneCheck:             call    asm_l2_320_col_bank_select      ; adjust hl for hl address which is now in l only
  59+ E435 6A                                   ld      l,d                             ; low byte is row from d
  60+ E436 C9           .DontPlot:              ret
  61+ E437
  62+ E437 CD F0 E0     l2_plot_pixel_320_no_check:   call    asm_l2_320_col_bank_select      ; adjust hl for column > h
  63+ E43A 6A                                   ld      l,d                             ; as they are horizontal now
  64+ E43B 7B                                   ld      a,e
  65+ E43C 77                                   ld      (hl),a
  66+ E43D C9                                   ret
  67+ E43E
  68+ E43E              ; y aixs bounds check must have been done before calling this
  69+ E43E F5           l2_plot_pixel_no_check: push    af
  70+ E43F C5                                   push    bc								; bank select destroys bc so need to save it
  71+ E440 78                                   ld      a,b                             ; determine target bank
  72+ E441 CD 78 E0                             call    asm_l2_row_bank_select
  73+ E444 C1                                   pop     bc
  74+ E445 47                                   ld      b,a                             ; b now adjusted for bank, c = column
  75+ E446 60 69                                ld      hl,bc                           ; hl now holds ram address after bank select
  76+ E448 F1                                   pop     af								; a = colour to plott
  77+ E449 77                                   ld      (hl),a                          ; poke to ram
  78+ E44A C9                                   ret
  79+ E44B
  80+ E44B              ; ">l2_plot_pixel_no_bank b= row number, c = column number, a = pixel col"
  81+ E44B              ; This version assues pixel is in the same bank as previously plotted ones. optimised for horizontal lines
  82+ E44B E5           l2_plot_pixel_no_bank:  push 	hl
  83+ E44C 60                                   ld 		h,b								; hl now holds ram address after bank select
  84+ E44D 69                                   ld 		l,c
  85+ E44E 77                                   ld 		(hl),a
  86+ E44F E1                                   pop		hl
  87+ E450 C9                                   ret
  88+ E451
  89+ E451              ; ">l2_plot_pixel_no_bank d= row number, h = column number, a = pixel col"
  90+ E451              ; This version assues pixel is in the same bank as previously plotted ones. optimised for horizontal lines
  91+ E451              l2_plot_pixel_320_no_bank:
  92+ E451 6A                                   ld 		l,d
  93+ E452 77                                   ld 		(hl),a
  94+ E453 C9                                   ret
  95+ E454              ; The more simpler h col l row is just ld (hl),a so no need for a function
  96+ E454
  97+ E454
  98+ E454 F5           ShipPixel:              push    af
  99+ E455 78                                   ld      a,b
 100+ E456 FE 7F                                cp      127
 101+ E458 D0                                   ret     nc
 102+ E459 F1                                   pop     af
 103+ E45A 18 E2                                jr      l2_plot_pixel_no_check
 104+ E45C                                      ;***Implicit ret due to jr
 105+ E45C
 106+ E45C              ; in bc = yx iyl = colour
 107+ E45C 78           DebrisPixel:            ld      a,b
 108+ E45D FE 7F                                cp      127
 109+ E45F D0                                   ret     nc
 110+ E460 FD 7D                                ld      a, iyl
 111+ E462 18 DA                                jr      l2_plot_pixel_no_check
 112+ E464                                      ;***Implicit ret due to jr
 113+ E464
 114+ E464 F5           l2_plot_pixel_y_test:   push	af
 115+ E465 78                                   ld		a,b
 116+ E466 FE C0                                cp		192
 117+ E468 30 03                                jr		nc,.clearup
 118+ E46A F1                                   pop		af
 119+ E46B 18 8E                                jr		l2_plot_pixel
 120+ E46D F1           .clearup:               pop		af
 121+ E46E C9                                   ret
 122+ E46F
 123+ E46F              l2_point_pixel_y_safe:	MACRO
 124+ E46F ~            						push	hl
 125+ E46F ~            						push	bc
 126+ E46F ~            						call	l2_plot_pixel
 127+ E46F ~            						pop		bc
 128+ E46F ~            						pop		hl
 129+ E46F              						ENDM
 130+ E46F
# file closed: ../../Layer2Graphics/layer2_plot_pixel.asm
 706  E46F                  INCLUDE "../../Layer2Graphics/layer2_print_character.asm"
# file opened: ../../Layer2Graphics/layer2_print_character.asm
   1+ E46F
   2+ E46F              ; "l2_print_chr_at, bc = col,row, d= character, e = colour"
   3+ E46F              ; "Need a version that also prints absence of character"
   4+ E46F
   5+ E46F              ; Counts next word at de, uses hl for current pixel col and counting characters
   6+ E46F              ; b = returned number of characters for word
   7+ E46F D5           L2LenWordAtDE:          push    de
   8+ E470 06 00                                ld      b,0
   9+ E472 1A           .preCheck               ld      a,(de)                  ; check for null
  10+ E473 A7                                   and     a
  11+ E474 CA 8A E4                             jp      z,.CountDone
  12+ E477 FE 20                                cp      ' '                     ; check if its just one space
  13+ E479 CA 89 E4                             jp      z,.WhiteSpaceOnly
  14+ E47C 04           .CountLoop:             inc     b                       ; ok we can move on 1 character
  15+ E47D 13           .OKLength:              inc     de
  16+ E47E 1A                                   ld      a,(de)                  ; get next character
  17+ E47F FE 00                                cp      0                       ; on first pass we will have done this
  18+ E481 28 07                                jr      z,.CountDone
  19+ E483 FE 20                                cp      ' '
  20+ E485 28 03                                jr      z,.CountDone            ; If its whitespace we can also just exit
  21+ E487 18 F3                                jr      .CountLoop
  22+ E489 04           .WhiteSpaceOnly:        inc     b                       ; set b to 1 as it was 0 before this call
  23+ E48A D1           .CountDone:             pop     de
  24+ E48B C9                                   ret
  25+ E48C
  26+ E48C
  27+ E48C 7A           l2_print_chr_at:        ld		a,d
  28+ E48D FE 20                                cp		32
  29+ E48F 38 3F                                jr		c,.InvalidCharacter		; Must be between 32 and 127
  30+ E491 FE 7F                                cp		127
  31+ E493 30 3B                                jr		nc,.InvalidCharacter
  32+ E495 26 00        .ValidCharater:         ld		h,0
  33+ E497 6A                                   ld		l,d
  34+ E498 29                                   add		hl,hl						; * 2
  35+ E499 29                                   add		hl,hl						; * 4
  36+ E49A 29                                   add		hl,hl						; * 8 to get byte address
  37+ E49B ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
  38+ E49F 04                                   inc		b							; start + 1 pixel x and y as we only print 7x7
  39+ E4A0 23                                   inc		hl							; skip first byte
  40+ E4A1 16 07                                ld		d,7
  41+ E4A3 D5           .PrintCharLoop:         push	de
  42+ E4A4 7E                                   ld		a,(hl)
  43+ E4A5 FE 00                                cp		0
  44+ E4A7 28 21                                jr		z,.NextRowNoBCPop
  45+ E4A9 C5           .PrintARow:             push	bc							; save row col
  46+ E4AA 16 07                                ld		d,7							; d is loop row number now
  47+ E4AC 0C           .PrintPixelLoop:	    inc		c							; we start at col 1 not 0 so can move inc here
  48+ E4AD CB 27        .PrintTheRow:           sla		a							; scroll char 1 pixel as we read from bit 7
  49+ E4AF F5                                   push	af							; save character byte
  50+ E4B0 CB 7F                                bit		7,a							; If left most pixel set then plot
  51+ E4B2 20 04                                jr		nz,.PixelToPrint
  52+ E4B4 3E E3        .NoPixelToPrint:        ld		a,$E3
  53+ E4B6 18 01                                jr		.HaveSetPixelColour
  54+ E4B8 7B           .PixelToPrint:          ld		a,e							; Get Colour
  55+ E4B9 E5           .HaveSetPixelColour		push	hl
  56+ E4BA              ;	push	bc						; at the moment we don't do paging on first plot so need to preserve BC
  57+ E4BA F5           .BankOnFirstOnly:       push	af
  58+ E4BB 7A                                   ld		a,d
  59+ E4BC FE 07                                cp		7
  60+ E4BE 28 11                                jr		z,.PlotWithBank
  61+ E4C0 F1           .PlotNoBank:            pop		af
  62+ E4C1 60                                   ld 		h,b								; hl now holds ram address after bank select
  63+ E4C2 69                                   ld 		l,c
  64+ E4C3 77                                   ld 		(hl),a
  65+ E4C4              .IterateLoop:	        ;	pop		bc
  66+ E4C4 E1                                   pop		hl
  67+ E4C5 F1                                   pop		af							; a= current byte shifted
  68+ E4C6 15                                   dec		d						 	; do dec after inc as we amy
  69+ E4C7 20 E3                                jr		nz,.PrintPixelLoop
  70+ E4C9 C1           .NextRow:               pop		bc							; Current Col Row
  71+ E4CA D1           .NextRowNoBCPop:	    pop		de							; d= row loop
  72+ E4CB 04                                   inc		b							; Down 1 row
  73+ E4CC 23                                   inc		hl							; Next character byte
  74+ E4CD 15                                   dec		d							; 1 done now
  75+ E4CE 20 D3                                jr		nz,.PrintCharLoop
  76+ E4D0 C9           .InvalidCharacter:      ret
  77+ E4D1 F1           .PlotWithBank:          pop		af
  78+ E4D2 CD FB E3                             call	l2_plot_pixel				; This will shift bc to poke row
  79+ E4D5 18 ED                                jr		.IterateLoop
  80+ E4D7
  81+ E4D7              ; "l2_print_at bc= colrow, hl = addr of message, e = colour"
  82+ E4D7              ; "No error trapping, if there is no null is will just cycle on the line"
  83+ E4D7 7E           l2_print_at:            ld	a,(hl)							; Return if empty string
  84+ E4D8 FE 00                                cp	0
  85+ E4DA C8                                   ret	z
  86+ E4DB E5                                   push	hl
  87+ E4DC D5                                   push	de
  88+ E4DD C5                                   push	bc
  89+ E4DE 57                                   ld		d,a							; bc = pos, de = char and colour
  90+ E4DF CD 8C E4                             call 	l2_print_chr_at
  91+ E4E2 C1                                   pop		bc
  92+ E4E3 D1                                   pop		de
  93+ E4E4 E1                                   pop		hl
  94+ E4E5 08           .Move8Pixlestoright:	ex		af,af'
  95+ E4E6 79                                   ld		a,c
  96+ E4E7 C6 08                                add		8
  97+ E4E9 4F                                   ld		c,a
  98+ E4EA 08                                   ex		af,af'
  99+ E4EB 23                                   inc		hl
 100+ E4EC 18 E9                                jr		l2_print_at					; Just loop until 0 found
 101+ E4EE
 102+ E4EE
 103+ E4EE              ; "l2_print_chr_at, bc = col,row, d= character, e = colour"
 104+ E4EE              ; "Need a version that also prints absence of character"
 105+ E4EE              ; removed blank line optimisation as we need spaces printed
 106+ E4EE 7A           l2_print_7chr_at:       ld		a,d
 107+ E4EF FE 1F                                cp		31
 108+ E4F1 38 3D                                jr		c,.InvalidCharacter		; Must be between 32 and 127
 109+ E4F3 FE 7F                                cp		127
 110+ E4F5 30 39                                jr		nc,.InvalidCharacter
 111+ E4F7 26 00        .ValidCharater:         ld		h,0
 112+ E4F9 6A                                   ld		l,d
 113+ E4FA 29                                   add		hl,hl						; * 2
 114+ E4FB 29                                   add		hl,hl						; * 4
 115+ E4FC 29                                   add		hl,hl						; * 8 to get byte address
 116+ E4FD ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
 117+ E501 04                                   inc		b							; start + 1 pixel x and y as we only print 7x7
 118+ E502 23                                   inc		hl							; skip first byte
 119+ E503 16 07                                ld		d,7
 120+ E505 D5           .PrintCharLoop:         push	de
 121+ E506 7E                                   ld		a,(hl)
 122+ E507                                      ;cp		0
 123+ E507                                      ;jr		z,.NextRowNoBCPop
 124+ E507 C5           .PrintARow:             push	bc							; save row col
 125+ E508 16 06                                ld		d,6							; d is loop row number now
 126+ E50A 0C           .PrintPixelLoop:        inc		c							; we start at col 1 not 0 so can move inc here
 127+ E50B 28 1C                                jr		z,.NextRow
 128+ E50D CB 27                                sla		a							; scroll char 1 pixel as we read from bit 7
 129+ E50F F5                                   push	af							; save character byte
 130+ E510 CB 7F                                bit		7,a							; If left most pixel set then plot
 131+ E512 20 04                                jr		nz,.PixelToPrint
 132+ E514 3E E3        .NoPixelToPrint:        ld		a,$E3
 133+ E516 18 01                                jr		.HaveSetPixelColour
 134+ E518 7B           .PixelToPrint:          ld		a,e							; Get Colour
 135+ E519 E5           .HaveSetPixelColour		push	hl
 136+ E51A                                      ;	push	bc							; at the moment we don't do paging on first plot so need to preserve BC
 137+ E51A F5           .BankOnFirstOnly:       push	af
 138+ E51B 7A                                   ld		a,d
 139+ E51C FE 06                                cp		6
 140+ E51E 28 11                                jr		z,.PlotWithBank
 141+ E520 F1           .PlotNoBank:            pop		af
 142+ E521 60                                   ld 		h,b								; hl now holds ram address after bank select
 143+ E522 69                                   ld 		l,c
 144+ E523 77                                   ld 		(hl),a
 145+ E524              .IterateLoop:	        ;	pop		bc
 146+ E524 E1                                   pop		hl
 147+ E525 F1                                   pop		af							; a= current byte shifted
 148+ E526 15                                   dec		d						 	; do dec after inc as we amy
 149+ E527 20 E1                                jr		nz,.PrintPixelLoop
 150+ E529 C1           .NextRow:               pop		bc							; Current Col Row
 151+ E52A D1           .NextRowNoBCPop:	    pop		de							; d= row loop
 152+ E52B 04                                   inc		b							; Down 1 row
 153+ E52C 23                                   inc		hl							; Next character byte
 154+ E52D 15                                   dec		d							; 1 done now
 155+ E52E 20 D5                                jr		nz,.PrintCharLoop
 156+ E530 C9           .InvalidCharacter:      ret
 157+ E531 F1           .PlotWithBank:          pop		af
 158+ E532 CD FB E3                             call	l2_plot_pixel				; This will shift bc to poke row
 159+ E535 18 ED                                jr		.IterateLoop
 160+ E537
 161+ E537              ; "l2_print_7at bc= colrow, hl = addr of message, e = colour"
 162+ E537              ; "No error trapping, if there is no null is will just cycle on the line"
 163+ E537 7E           l2_print_7at:           ld	a,(hl)							; Return if empty string
 164+ E538 FE 00                                cp	0
 165+ E53A C8                                   ret	z
 166+ E53B E5                                   push	hl
 167+ E53C D5                                   push	de
 168+ E53D C5                                   push	bc
 169+ E53E 57                                   ld		d,a							; bc = pos, de = char and colour
 170+ E53F CD EE E4                             call 	l2_print_7chr_at
 171+ E542 C1                                   pop		bc
 172+ E543 D1                                   pop		de
 173+ E544 E1                                   pop		hl
 174+ E545 08           .Move7Pixlestoright:	ex		af,af'
 175+ E546 79                                   ld		a,c
 176+ E547 C6 07                                add		7
 177+ E549 4F                                   ld		c,a
 178+ E54A 08                                   ex		af,af'
 179+ E54B 23                                   inc		hl
 180+ E54C 18 E9                                jr		l2_print_7at					; Just loop until 0 found
 181+ E54E
 182+ E54E
 183+ E54E              ; "l2_print_7at b= row, hl = col de = addr of message, c = colour"
 184+ E54E              ; "No error trapping, if there is no null is will just cycle on the line"
 185+ E54E
 186+ E54E 1A           l2_print_7at_320:       ld	a,(de)							; Return if empty string
 187+ E54F FE 00                                cp	0
 188+ E551 C8                                   ret	z
 189+ E552 E5 D5 C5                             push	hl,,de,,bc
 190+ E555 57                                   ld		d,a							; bc = pos, de = char and colour
 191+ E556                                      ;TODOcallcall 	l2_print_7chr_at_320
 192+ E556 C1 D1 E1                             pop		hl,,de,,bc
 193+ E559 08           .Move7Pixlestoright:	ex		af,af'
 194+ E55A 79                                   ld		a,c
 195+ E55B C6 07                                add		7
 196+ E55D 4F                                   ld		c,a
 197+ E55E 08                                   ex		af,af'
 198+ E55F 23                                   inc		hl
 199+ E560 18 EC                                jr		l2_print_7at_320		    ; Just loop until 0 found
 200+ E562
 201+ E562 50           l2_print_blank_at_320:  ld      d,b                         ; d = row
 202+ E563 CD 24 E4                             call    l2_target_address_320       ;
 203+ E566              ;... so now we have hl = address of 8 bytes of character, iyl = d = row , iyh = c = color, ixh = off colour, stack = column, b = 8
 204+ E566 06 08        .PrintCharPrep:         ld      b,8                         ;
 205+ E568 E5           .PrintCharLoop:         push    hl                          ; save row col address
 206+ E569                                      ZeroA
 206+ E569 AF          >                        xor a
 207+ E56A 77           .LineUnwarped:          ld      (hl),a                      ; write to screen
 208+ E56B 24                                   inc     h                           ; next colum = + 256
 209+ E56C 77                                   ld      (hl),a                      ; write to screen
 210+ E56D 24                                   inc     h                           ; next colum = + 256
 211+ E56E 77                                   ld      (hl),a                      ; write to screen
 212+ E56F 24                                   inc     h                           ; next colum = + 256
 213+ E570 77                                   ld      (hl),a                      ; write to screen
 214+ E571 24                                   inc     h                           ; next colum = + 256
 215+ E572 77                                   ld      (hl),a                      ; write to screen
 216+ E573 24                                   inc     h                           ; next colum = + 256
 217+ E574 77                                   ld      (hl),a                      ; write to screen
 218+ E575 24                                   inc     h                           ; next colum = + 256
 219+ E576 77                                   ld      (hl),a                      ; write to screen
 220+ E577 24                                   inc     h                           ; next colum = + 256
 221+ E578 77                                   ld      (hl),a                      ; write to screen
 222+ E579 24                                   inc     h                           ; next colum = + 256
 223+ E57A E1           .DoneLine:              pop     hl                          ; get back row col
 224+ E57B 23                                   inc     hl                          ; move down 1 pixel row
 225+ E57C 10 EA                                djnz    .PrintCharLoop
 226+ E57E C9                                   ret
 227+ E57F              ; l2_print_char_at_320, b = row, hl = col, a = code for charater, c = color
 228+ E57F FE 20        l2_print_char_at_320:   cp		32
 229+ E581 30 05                                jr		nc,.LowerValid          	; Must be between 32 and 127
 230+ E583 3E 20                                ld      a,32                        ; else we set it to space
 231+ E585 C3 8E E5                             jp      .ValidCharacter             ; .
 232+ E588 FE 7F        .LowerValid:            cp		127                         ; .
 233+ E58A 38 02                                jr		c,.ValidCharacter           ; .
 234+ E58C 3E 20        .UpperInvalid:          ld      a,32                        ; .
 235+ E58E              ; now translate row in b and col in hl to a valid address, in 320 mode high byte
 236+ E58E FE 20        .ValidCharacter:        cp      32                          ; now a holds valid ascii
 237+ E590 CA 62 E5                             jp      z,l2_print_blank_at_320     ; Optimisation for space character to just write blanks
 238+ E593                                      ; Implicit return on jp z
 239+ E593              ; calcualte target address and bring in correct bank hl = col, d = row
 240+ E593 50           .CaclulateWriteAddr:    ld      d,b                         ; d = row
 241+ E594 DD 2E 00                             ld      ixl,0                       ; pixel off
 242+ E597 DD 61                                ld      ixh,c                       ; pixel on
 243+ E599 08                                   ex      af,af'                      ; save a holding charachter code
 244+ E59A CD 24 E4                             call    l2_target_address_320       ;
 245+ E59D 08                                   ex      af,af'
 246+ E59E E5                                   push    hl                          ; save target address
 247+ E59F 1E 08        .CalculateCharacterAddr:ld      e,8                         ; de = offset address for character set
 248+ E5A1 57                                   ld      d,a                         ; d = ascii code so *8 gives de = offset in char set
 249+ E5A2 ED 30                                mul     de                          ;
 250+ E5A4 21 00 3C                             ld		hl,charactersetaddr			; hl = address of rom char,
 251+ E5A7 19                                   add     hl,de                       ; hl = address of rom character bytes
 252+ E5A8 D1                                   pop     de                          ; de = screen address
 253+ E5A9              ;... so now we have hl = address of 8 bytes of character, iyl = d = row , iyh = c = color, ixh = off colour, stack = column, b = 8
 254+ E5A9 06 08        .PrintCharPrep:         ld      b,8                         ;
 255+ E5AB C5           .PrintCharLoop:         push    bc
 256+ E5AC 7E                                   ld      a,(hl)                      ; a= byte to write
 257+ E5AD 06 08                                ld      b,8                         ; 8 pixels across
 258+ E5AF D5                                   push    de                          ; save row col address
 259+ E5B0 CB 27        .LineLoop:              sla      a
 260+ E5B2 38 06                                jr      c,.plotPixel
 261+ E5B4 08           .PlotSpace:             ex      af,af'                      ; save current byte
 262+ E5B5 DD 7D                                ld      a,ixl                       ; write 0
 263+ E5B7 C3 BD E5                             jp      .WritePixel                 ;
 264+ E5BA 08           .plotPixel:             ex      af,af'                      ; save currenty byte
 265+ E5BB DD 7C                                ld      a,ixh                       ; write color
 266+ E5BD 12           .WritePixel:            ld      (de),a                      ; write to screen
 267+ E5BE 08                                   ex      af,af'                      ; retrieve current byte
 268+ E5BF 14                                   inc     d                           ; next colum = + 256
 269+ E5C0 10 EE                                djnz    .LineLoop
 270+ E5C2 D1           .DoneLine:              pop     de                          ; get back row col
 271+ E5C3 13                                   inc     de                          ; move down 1 pixel row
 272+ E5C4 C1                                   pop     bc
 273+ E5C5 23                                   inc     hl                          ; move to next byte
 274+ E5C6 10 E3                                djnz    .PrintCharLoop
 275+ E5C8 C9                                   ret
 276+ E5C9              ; l2_print_char_at_320, b = row, hl = col, a = code for charater, c = color
 277+ E5C9              ; checks bank on every column
 278+ E5C9              l2_print_char_at_320_precise:
 279+ E5C9 FE 20                                cp		32
 280+ E5CB 30 05                                jr		nc,.LowerValid          	; Must be between 32 and 127
 281+ E5CD 3E 20                                ld      a,32                        ; else we set it to space
 282+ E5CF C3 D8 E5                             jp      .ValidCharacter             ; .
 283+ E5D2 FE 7F        .LowerValid:            cp		127                         ; .
 284+ E5D4 38 02                                jr		c,.ValidCharacter           ; .
 285+ E5D6 3E 20        .UpperInvalid:          ld      a,32                        ; .
 286+ E5D8              ; now translate row in b and col in hl to a valid address, in 320 mode high byte
 287+ E5D8 FE 20        .ValidCharacter:        cp      32                          ; now a holds valid ascii
 288+ E5DA CA 62 E5                             jp      z,l2_print_blank_at_320     ; Optimisation for space character to just write blanks
 289+ E5DD                                      ; Implicit return on jp z
 290+ E5DD              ; calcualte target address and bring in correct bank hl = col, d = row
 291+ E5DD 50           .CaclulateWriteAddr:    ld      d,b                         ; d = row
 292+ E5DE DD 2E 00                             ld      ixl,0                       ; pixel off
 293+ E5E1 DD 61                                ld      ixh,c                       ; pixel on
 294+ E5E3 08                                   ex      af,af'                      ; save a holding charachter code
 295+ E5E4 CD 24 E4                             call    l2_target_address_320       ;
 296+ E5E7 08                                   ex      af,af'
 297+ E5E8 E5                                   push    hl                          ; save target address
 298+ E5E9 1E 08        .CalculateCharacterAddr:ld      e,8                         ; de = offset address for character set
 299+ E5EB 57                                   ld      d,a                         ; d = ascii code so *8 gives de = offset in char set
 300+ E5EC ED 30                                mul     de                          ;
 301+ E5EE 21 00 3C                             ld		hl,charactersetaddr			; hl = address of rom char,
 302+ E5F1 19                                   add     hl,de                       ; hl = address of rom character bytes
 303+ E5F2 D1                                   pop     de                          ; de = screen address
 304+ E5F3              ;... so now we have hl = address of 8 bytes of character, iyl = d = row , iyh = c = color, ixh = off colour, stack = column, b = 8
 305+ E5F3 06 08        .PrintCharPrep:         ld      b,8                         ;
 306+ E5F5 C5           .PrintCharLoop:         push    bc
 307+ E5F6 7E                                   ld      a,(hl)                      ; a= byte to write
 308+ E5F7 06 08                                ld      b,8                         ; 8 pixels across
 309+ E5F9 D5                                   push    de                          ; save row col address
 310+ E5FA CB 27        .LineLoop:              sla      a
 311+ E5FC 38 06                                jr      c,.plotPixel
 312+ E5FE 08           .PlotSpace:             ex      af,af'                      ; save current byte
 313+ E5FF DD 7D                                ld      a,ixl                       ; write 0
 314+ E601 C3 07 E6                             jp      .WritePixel                 ;
 315+ E604 08           .plotPixel:             ex      af,af'                      ; save currenty byte
 316+ E605 DD 7C                                ld      a,ixh                       ; write color
 317+ E607 12           .WritePixel:            ld      (de),a                      ; write to screen
 318+ E608 14                                   inc     d                           ; next colum = + 256
 319+ E609 7A                                   ld      a,d
 320+ E60A                                      JumpIfALTNusng 64, .NoBankSwitch
 320+ E60A FE 40       >                        cp      64
 320+ E60C DA 16 E6    >                        jp		c, .NoBankSwitch
 321+ E60F C5           .NextBank:              push    bc
 322+ E610 CD C0 E1                             call    asm_l2_320_next_bank_noSv
 323+ E613 C1                                   pop     bc
 324+ E614 16 00                                ld      d,0                         ; as we have moved on reset address column
 325+ E616 08           .NoBankSwitch:          ex      af,af'                      ; retrieve current byte
 326+ E617 10 E1                                djnz    .LineLoop
 327+ E619 CD 6A E0     .DoneLine:              call    asm_l2_reselect_saved_bank
 328+ E61C D1                                   pop     de                          ; get back row col
 329+ E61D 13                                   inc     de                          ; move down 1 pixel row
 330+ E61E C1                                   pop     bc
 331+ E61F 23                                   inc     hl                          ; move to next byte
 332+ E620 10 D3                                djnz    .PrintCharLoop
 333+ E622 C9                                   ret
 334+ E623
 335+ E623              ; l2_print_at_320, b = row, hl = col, de = addr of message, c = color
 336+ E623              ; non optimised bank switching as it will do it for each character
 337+ E623              ; assumes each character is aligned to a bank so will only bank switch on new character cell
 338+ E623 1A           l2_print_at_320:        ld      a,(de)                      ; return if empty message
 339+ E624 A7                                   and     a
 340+ E625 C8                                   ret     z
 341+ E626 C5 D5 E5                             push    bc,,de,,hl
 342+ E629 1A                                   ld      a,(de)
 343+ E62A CD 7F E5                             call 	l2_print_char_at_320        ; l2_print_char_at_320, b = row, hl = col, a = code for chrater, c = color
 344+ E62D E1 D1 C1                             pop     bc,,de,,hl
 345+ E630 3E 08                                ld      a,8
 346+ E632 ED 31                                add     hl,a
 347+ E634 13                                   inc     de
 348+ E635 C3 23 E6                             jp      l2_print_at_320
 349+ E638
 350+ E638              ;l2_print_at_320_precise, b = row, hl = col, de = addr of message, c = color
 351+ E638              ; This version bank switch checks on every column, needs to be checked if optimisation of bank swtiching can be done
 352+ E638              ; assumes each character is aligned to a bank so will only bank switch on new character cell
 353+ E638 1A           l2_print_at_320_precise:ld      a,(de)                      ; return if empty message
 354+ E639 A7                                   and     a
 355+ E63A C8                                   ret     z
 356+ E63B C5 D5 E5                             push    bc,,de,,hl
 357+ E63E 1A                                   ld      a,(de)
 358+ E63F CD C9 E5                             call 	l2_print_char_at_320_precise       ; l2_print_char_at_320, b = row, hl = col, a = code for chrater, c = color
 359+ E642 E1 D1 C1                             pop     bc,,de,,hl
 360+ E645 3E 08                                ld      a,8
 361+ E647 ED 31                                add     hl,a
 362+ E649 13                                   inc     de
 363+ E64A C3 38 E6                             jp      l2_print_at_320_precise
 364+ E64D
 365+ E64D
 366+ E64D              ; l2_print_at_320, b = row, hl = col, de = addr of message, c = color, iyl = rowlength
 367+ E64D              ; loops printing line at a time wraps at colum 38
 368+ E64D              ; current col = start col
 369+ E64D              ; while char at ptr <> 0
 370+ E64D              ;  if char at ptr = white space
 371+ E64D              ;     word length = 8
 372+ E64D              ;  else
 373+ E64D              ;      get legnth of work at ptr
 374+ E64D              ;  end if
 375+ E64D              ;  if current col + word length > 310
 376+ E64D              ;     current col = start col
 377+ E64D              ;     currnet row += 8
 378+ E64D              ;   end if
 379+ E64D              ;   print word
 380+ E64D              ;   current col += word length
 381+ E64D              ; loop
 382+ E64D              ; Not for optimisation always works in 8 pixel alignment
 383+ E64D              l2_print_at_wrap_320:
 384+ E64D 1A           .PrintPrep:             ld      a,(de)                  ; intial trap null char at ptr <> 0
 385+ E64E A7                                   and     a                       ; .
 386+ E64F C8                                   ret     z                       ; .
 387+ E650 FD 69                                ld      iyl,c                   ; iyl = color
 388+ E652 E5                                   push    hl                      ; save pixel column address
 389+ E653 EB                                   ex      de,hl                   ; hl = hl / 8
 390+ E654 FD 60                                ld      iyh,b                   ; save b register
 391+ E656 06 03                                ld      b,3                     ; .
 392+ E658 ED 2A                                bsrl    de,b                    ; .
 393+ E65A EB                                   ex      de,hl                   ; .
 394+ E65B 4D                                   ld      c,l                     ; c = current column in characters rather than pixels
 395+ E65C DD 69                                ld      ixl,c                   ; ixl = colum in characters for new line
 396+ E65E E1                                   pop     hl                      ; get back pixel column address
 397+ E65F 1A           .PrintLoop:             ld      a,(de)                  ; while char at ptr <> 0
 398+ E660 A7                                   and     a                       ; .
 399+ E661 C8                                   ret     z
 400+ E662 CD 6F E4                             call    L2LenWordAtDE           ; b = length of string
 401+ E665 DD 60                                ld      ixh,b                   ; save string length
 402+ E667 79                                   ld      a,c                     ; a= total character length
 403+ E668 80                                   add     a,b                     ; a= projected end character position of string
 404+ E669 4F                                   ld      c,a                     ; c=total character length (needed to keep track of string length so far
 405+ E66A FD 44                                ld      b,iyh                   ; restore b saved in iyh above for row
 406+ E66C                                      JumpIfALTNusng 38,.printWord    ; if calcualted length > 38 chars then word wrap
 406+ E66C FE 26       >                        cp      38
 406+ E66E DA 81 E6    >                        jp		c, .printWord
 407+ E671 DD 4D        .wrapText:              ld      c,ixl                   ; start column
 408+ E673 EB                                   ex      de,hl                   ; update hl to be pixel start column
 409+ E674 DD 55                                ld      d,ixl                   ;
 410+ E676 1E 08                                ld      e,8                     ;
 411+ E678 ED 30                                mul     de                      ;
 412+ E67A EB                                   ex      de,hl                   ;
 413+ E67B 3E 08                                ld      a,8                     ; down one row
 414+ E67D 80                                   add     a,b                     ; .
 415+ E67E 47                                   ld      b,a                     ; .
 416+ E67F FD 67                                ld      iyh,a                   ; update iyh copy of b
 417+ E681              ; now bc = pxiel row, character column after string printed, de = start of string, hl = pixel col, iyl = color, ixl = column for start of line, iyh = original pixel row
 418+ E681 C5 D5 E5 DD  .printWord:             push    bc,,de,,hl,,ix          ; stack all registgers
 418+ E685 E5
 419+ E686                                      ;break
 420+ E686 1A           .CalculateColum:        ld      a,(de)                  ; get ascii code
 421+ E687 FD 4D                                ld      c,iyl                   ; get colour back
 422+ E689 CD 7F E5                             call    l2_print_char_at_320    ; b = row, hl = col, a = code for charater, c = color
 423+ E68C DD E1 E1 D1                          pop     bc,,de,,hl,,ix          ;
 423+ E690 C1
 424+ E691 13                                   inc     de                      ; move to next character
 425+ E692 3E 08                                ld      a,8                     ; move column 8 pixles
 426+ E694 ED 31                                add     hl,a                    ; loop until we get a space
 427+ E696 DD 25                                dec     ixh
 428+ E698 DD 7C                                ld      a,ixh
 429+ E69A A7                                   and     a
 430+ E69B C2 81 E6                             jp      nz,.printWord
 431+ E69E C3 5F E6                             jp      .PrintLoop
 432+ E6A1
 433+ E6A1
 434+ E6A1
# file closed: ../../Layer2Graphics/layer2_print_character.asm
 707  E6A1                  INCLUDE "../../Layer2Graphics/layer2_draw_box.asm"
# file opened: ../../Layer2Graphics/layer2_draw_box.asm
   1+ E6A1              ; "l2_draw_thick_box bc=rowcol, de=heightwidth h=color"
   2+ E6A1              ; TODO DMA Optimise
   3+ E6A1                              DISPLAY "TODO: dma optimise"
   4+ E6A1 C5 D5 E5     l2_draw_fill_box:       push    bc,,de,,hl
   5+ E6A4 53                                   ld      d,e
   6+ E6A5 5C                                   ld      e,h
   7+ E6A6 CD 8A E7                             call    l2_draw_horz_line           ; "bc = left side row,col, d = length, e = color"
   8+ E6A9 E1 D1 C1                             pop     bc,,de,,hl
   9+ E6AC 04                                   inc     b
  10+ E6AD 15                                   dec     d
  11+ E6AE C8                                   ret     z
  12+ E6AF 18 F0                                jr      l2_draw_fill_box
  13+ E6B1
  14+ E6B1              ; "l2_draw_box bc=rowcol, de=heightwidth a=color"
  15+ E6B1 C5 D5 F5     l2_draw_box:            push	bc,,de,,af
  16+ E6B4 53                                   ld		d,e
  17+ E6B5 5F                                   ld		e,a
  18+ E6B6 14                                   inc		d
  19+ E6B7 CD 8A E7                             call	l2_draw_horz_line
  20+ E6BA F1 D1 C1                             pop		bc,,de,,af
  21+ E6BD C5 D5 F5     .bottomhorzline:	    push	bc,,de,,af
  22+ E6C0 67                                   ld		h,a							;save color whilst b = row + height
  23+ E6C1 78                                   ld		a,b
  24+ E6C2 82                                   add		a,d
  25+ E6C3 47                                   ld		b,a
  26+ E6C4 53                                   ld		d,e							; d = width
  27+ E6C5 14                                   inc		d							; Extra pixel for width
  28+ E6C6 5C                                   ld		e,h							; e = colour
  29+ E6C7 CD 8A E7                             call	l2_draw_horz_line
  30+ E6CA F1 D1 C1                             pop		bc,,de,,af
  31+ E6CD C5 D5 F5     .leftvertline:          push	bc,,de,,af
  32+ E6D0 04                                   inc		b							; save 2 pixles
  33+ E6D1 15                                   dec		d
  34+ E6D2 5F                                   ld		e,a							; e = color
  35+ E6D3 CD 1C E8                             call	l2_draw_vert_line
  36+ E6D6 F1 D1 C1                             pop		bc,,de,,af
  37+ E6D9 04           .rightvertline:         inc		b							; save 2 pixles
  38+ E6DA 15                                   dec		d
  39+ E6DB 67                                   ld		h,a							;save color whilst c = col + width
  40+ E6DC 79                                   ld		a,c
  41+ E6DD 83                                   add		a,e
  42+ E6DE 4F                                   ld		c,a
  43+ E6DF 5C                                   ld		e,h							; e = color
  44+ E6E0 CD 1C E8                             call	l2_draw_vert_line
  45+ E6E3 C9                                   ret
  46+ E6E4
  47+ E6E4              ; "b = row, hl = col, c = height, de = width, a = colour"
  48+ E6E4 C5 D5 E5 F5  l2_draw_box_320:        push    bc,,de,,hl,,af
  49+ E6E8                                      ;TODOcall    l2_draw_horz_line_320       ; b = row, hl = col, e = width a = colour
  50+ E6E8 F1 E1 D1 C1                          pop     bc,,de,,hl,,af
  51+ E6EC C5 D5 E5 F5                          push    bc,,de,,hl,,af
  52+ E6F0 08                                   ex      af,af'
  53+ E6F1 78                                   ld      a,b
  54+ E6F2 3D                                   dec     a
  55+ E6F3 81                                   add     a,c
  56+ E6F4 41                                   ld      b,c
  57+ E6F5 08                                   ex      af,af'
  58+ E6F6                                      ;TODOcall    l2_draw_horz_line_320       ; b = row, hl = col, e = width a = colour
  59+ E6F6 F1 E1 D1 C1  .leftVertLine:          pop     bc,,de,,hl,,af
  60+ E6FA C5 D5 E5 F5                          push    bc,,de,,hl,,af
  61+ E6FE 16 00                                ld      d,0                             ; de = height
  62+ E700 59                                   ld      e,c
  63+ E701 4F                                   ld      c,a                             ; set colour
  64+ E702 CD 8E E8                             call    l2_draw_vert_line_320
  65+ E705 F1 E1 D1 C1                          pop     bc,,de,,hl,,af
  66+ E709 19                                   add     hl,de                           ; hl = right column
  67+ E70A 2B                                   dec     hl
  68+ E70B 16 00                                ld      d,0                             ; de = length
  69+ E70D 59                                   ld      e,c
  70+ E70E 4F                                   ld      c,a                             ; set colour
  71+ E70F CD 8E E8                             call    l2_draw_vert_line_320
  72+ E712 C9                                   ret
  73+ E713
  74+ E713 06 01        l2_draw_menu_border:    ld      b,1
  75+ E715 21 01 00                             ld      hl,1
  76+ E718 1E FD                                ld      e,255-2
  77+ E71A 0E C0                                ld      c,$C0
  78+ E71C CD 8E E8                             call    l2_draw_vert_line_320           ;b = row; hl = col, de = length, c = color"
  79+ E71F 06 01                                ld      b,1
  80+ E721 21 3E 01                             ld      hl,320-2
  81+ E724 1E FD                                ld      e,255-2
  82+ E726 0E C0                                ld      c,$C0
  83+ E728 CD 8E E8                             call    l2_draw_vert_line_320           ;b = row; hl = col, de = length, c = color"
  84+ E72B 06 01                                ld      b,1
  85+ E72D 21 01 00                             ld      hl,1
  86+ E730 11 3C 01                             ld      de,320-4
  87+ E733 0E C0                                ld      c,$C0
  88+ E735 CD E1 E7                             call    l2_draw_horz_line_320
  89+ E738 06 FD                                ld      b,253
  90+ E73A 21 02 00                             ld      hl,2
  91+ E73D 11 3C 01                             ld      de,320-4
  92+ E740 0E C0                                ld      c,$C0
  93+ E742 CD E1 E7                             call    l2_draw_horz_line_320
  94+ E745 06 0B                                ld      b,11
  95+ E747 21 02 00                             ld      hl,2
  96+ E74A 11 3C 01                             ld      de,320-4
  97+ E74D 0E C0                                ld      c,$C0
  98+ E74F CD E1 E7                             call    l2_draw_horz_line_320
  99+ E752 C9                                   ret
# file closed: ../../Layer2Graphics/layer2_draw_box.asm
 708  E753                  INCLUDE "../../Layer2Graphics/asm_l2_plot_horizontal.asm"
# file opened: ../../Layer2Graphics/asm_l2_plot_horizontal.asm
   1+ E753
   2+ E753              ;; NOTE DMA is little endian
   3+ E753 00           l2_horz_pixel           DB 0
   4+ E754
   5+ E754 83 C3 C7 CB  l2_horz_line            DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   5+ E758 7D
   6+ E759 53 E7        l2_horz_colr            DW l2_horz_pixel
   7+ E75B 00           l2_horz_lenlo           DB 0
   8+ E75C 00           l2_horz_lenhi           DB 0
   9+ E75D 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY, DMA_WR2_P2INC_MEMORY, DMA_WR4_CONT_MODE
  10+ E760 00 00        l2_horz_target          DB $00, $00
  11+ E762 CF 87                                DB DMA_LOAD, DMA_ENABLE
  12+ E764              l2_horz_cmd_len	        EQU $ - l2_horz_line
  13+ E764              ; "l2_draw_horz_dma"
  14+ E764              ; "plot at bc for length d colour e using dma, assumes bank already selected"
  15+ E764 7B           l2_draw_horz_dma:       ld		a,e                                               ; T=4      ;
  16+ E765 32 53 E7                             ld		(l2_horz_pixel),a                                 ; T=13     ;
  17+ E768 5A                                   ld      e,d ; saved 3 t states ld		a,d                                               ; T=4      ; e=d   4
  18+ E769 16 00                                ld      d,0; saved 3 t states ld 		(l2_horz_lenlo),a                                 ; T=13     ; d = 0  7
  19+ E76B ED 53 5B E7                          ld      (l2_horz_lenlo),de; saved 3 t states xor 	a                                                 ; T=4      ; t 20  31
  20+ E76F                                      ; saved 3 t states ld ld 		(l2_horz_lenhi),a                                 ; T=13     ;
  21+ E76F                                    ; saved 4 t states  ld		h,b                           ;          ;
  22+ E76F                                    ; saved 4 t states  ld		l,c                           ;          ;
  23+ E76F ED 43 60 E7                          ld      (l2_horz_target),bc ; saved 4 t states  was , hl  ; T=20     ;
  24+ E773 21 54 E7     .write_dma:             ld 		hl, l2_horz_line                                  ;          ;
  25+ E776 06 10                                ld 		b, l2_horz_cmd_len                                ;
  26+ E778 0E 6B                                ld		c,IO_DATAGEAR_DMA_PORT                            ;
  27+ E77A ED B3                                otir                                                      ;
  28+ E77C C9                                   ret
  29+ E77D
  30+ E77D              ; "bc = left side row,col, d = length, e = color"
  31+ E77D D5           l2_draw_horz_dma_bank:  push 	de							; save length and colour
  32+ E77E C5                                   push 	bc							; save row col
  33+ E77F 78                                   ld   	a,b
  34+ E780 CD 78 E0                             call 	asm_l2_row_bank_select		; now we have the correct bank, its a horizontal line so bank will not shift
  35+ E783 C1                                   pop  	bc
  36+ E784 47                                   ld	 	b,a	       					; fixed row by the call we can go straight into HL with row col
  37+ E785 D1                                   pop  	de							; get length back
  38+ E786 CD 64 E7                             call    l2_draw_horz_dma
  39+ E789 C9                                   ret
  40+ E78A
  41+ E78A              ; "l2_draw_horz_line"
  42+ E78A              ; "bc = left side row,col, d = length, e = color"
  43+ E78A              ; "optimisation if above min pix is will use dma call SCREEN_HOZ_MIN_PIX not implemented yet"
  44+ E78A 7A           l2_draw_horz_line:      ld		a,d
  45+ E78B FE 00                                cp 		0							; if its zero length then just return
  46+ E78D C8           .zerolengthexit:        ret		z
  47+ E78E FE 01        .isitlen1:              cp 		1
  48+ E790 CA B2 E7                             jp 		z,.l2_draw_horz_line_1
  49+ E793 FE 0A        .longenoughtfordma:     cp  10
  50+ E795 C3 7D E7                             jp  l2_draw_horz_dma_bank
  51+ E798 D5 C5        .plottableline:         push 	de,,bc  					; save length and colour an d row col
  52+ E79A 78                                   ld   	a,b
  53+ E79B CD 78 E0                             call 	asm_l2_row_bank_select		; now we have the correct bank, its a horizontal line so bank will not shift
  54+ E79E C1                                   pop  	bc
  55+ E79F 67                                   ld	 	h,a	       					; fixed row by the call we can go straight into HL with row col
  56+ E7A0 69                                   ld   	l,c
  57+ E7A1 D1                                   pop  	de							; get length back
  58+ E7A2 79           .cliptest:              ld	 	a,c							; get column + length
  59+ E7A3 42                                   ld  	b,d  						; speculate that we don't clip by pre-loading b with length
  60+ E7A4 82                                   add  	a,d
  61+ E7A5 30 06                                jr   	nc, .l2_draw_horz_plot_loop	; if carry is set c+d > 255
  62+ E7A7 3E FF        .clipat255:             ld   	a,$FF
  63+ E7A9 91                                   sub  	c							; a holds clipped length
  64+ E7AA 47                                   ld 		b, a 						; so now hl holds poke address  b = clipped length e = colour
  65+ E7AB 18 00                                jr		.l2_draw_horz_plot_loop
  66+ E7AD 73           .l2_draw_horz_plot_loop:ld (hl),e							; loop poking hl with e for b pixels
  67+ E7AE 23                                   inc hl
  68+ E7AF 10 FC                                djnz .l2_draw_horz_plot_loop
  69+ E7B1 C9                                   ret
  70+ E7B2 7B           .l2_draw_horz_line_1:   ld		a,e
  71+ E7B3                                      l2_plot_macro; jp		l2_plot_pixel				; hijack return
  71+ E7B3 78          >                        ld      a,b
  71+ E7B4             >                        JumpIfAGTENusng 192 ,.NoPlot
  71+ E7B4 FE C0       >                        cp     192
  71+ E7B6 D2 C2 E7    >                        jp		nc,.NoPlot
  71+ E7B9 69          >                        ld      l,c
  71+ E7BA CD 78 E0    >                        call    asm_l2_row_bank_select
  71+ E7BD 67          >                        ld      h,a
  71+ E7BE 3A FA E3    >                        ld      a,(line_gfx_colour)
  71+ E7C1 77          >                        ld      (hl),a
  71+ E7C2             >.NoPlot:
  72+ E7C2 C9                                   ret
  73+ E7C3
  74+ E7C3
  75+ E7C3              ; "l2_draw_horz_line_to"
  76+ E7C3              ; "bc = left side row,col, d right pixel, e = color"
  77+ E7C3 7A           l2_draw_horz_line_to:   ld 		a,d
  78+ E7C4 B9                                   cp 		c
  79+ E7C5 30 04                                jr		nc, .noswap
  80+ E7C7 28 07                                jr      z, .singlepixel
  81+ E7C9 51           .swap:                  ld		d,c
  82+ E7CA 4F                                   ld		c,a
  83+ E7CB 7A           .noswap:                ld		a,d
  84+ E7CC 91                                   sub		c
  85+ E7CD              ;                        dec		a							; so now its length not offset
  86+ E7CD 57                                   ld		d,a
  87+ E7CE 18 BA                                jr 		l2_draw_horz_line			; hijack routine and return statements
  88+ E7D0 7B           .singlepixel:           ld		a,e
  89+ E7D1                                      l2_plot_macro; jp		l2_plot_pixel				; hijack return
  89+ E7D1 78          >                        ld      a,b
  89+ E7D2             >                        JumpIfAGTENusng 192 ,.NoPlot
  89+ E7D2 FE C0       >                        cp     192
  89+ E7D4 D2 E0 E7    >                        jp		nc,.NoPlot
  89+ E7D7 69          >                        ld      l,c
  89+ E7D8 CD 78 E0    >                        call    asm_l2_row_bank_select
  89+ E7DB 67          >                        ld      h,a
  89+ E7DC 3A FA E3    >                        ld      a,(line_gfx_colour)
  89+ E7DF 77          >                        ld      (hl),a
  89+ E7E0             >.NoPlot:
  90+ E7E0 C9                                   ret
  91+ E7E1
  92+ E7E1
  93+ E7E1              ; "l2_draw_horz_line"
  94+ E7E1              ; ">b = row; hl = col, de = length, c = color"
  95+ E7E1 7A           l2_draw_horz_line_320:  ld		a,d
  96+ E7E2 B3                                   or      e
  97+ E7E3 C8           .zerolengthexit:        ret		z
  98+ E7E4                                      DISPLAY "TODO need 1 pixel logic"
  99+ E7E4 E5 C5        .longenoughtfordma:     push    hl,,bc                      ; copy row and colour to ixh and ixl
 100+ E7E6 CD F0 E0                             call    asm_l2_320_col_bank_select  ; Select the first bank to start writing to and adjust hl
 101+ E7E9 C1           .bankSelected:          pop     bc                          ; get back row and colour
 102+ E7EA 68                                   ld      l,b                         ; set target row
 103+ E7EB 71           .fillBank:              ld      (hl),c                      ; plot pixel
 104+ E7EC 7A                                   ld      a,d                         ; if we run out of DE then done
 105+ E7ED B3                                   or      e                           ; .
 106+ E7EE CA FC E7                             jp      z,.fillComplete             ; .
 107+ E7F1 24                                   inc     h                           ; move on one column
 108+ E7F2 7C                                   ld      a,h                         ; if we are done next bank
 109+ E7F3 FE 40                                cp      64                          ; .
 110+ E7F5 CA FE E7                             jp      z,.nextBank                 ; if inc H compeltes a carry then we have spanned a bank
 111+ E7F8 1B                                   dec     de                          ; one less still to do
 112+ E7F9 C3 EB E7                             jp      .fillBank                   ; else carry on
 113+ E7FC E1           .fillComplete:          pop     hl                          ; clean up stack on completion
 114+ E7FD C9                                   ret
 115+ E7FE C5           .nextBank:              push    bc
 116+ E7FF CD 9F E1                             call    asm_l2_320_next_bank        ; cycle on one bank as we always go left to right
 117+ E802 26 00                                ld      h,0                         ; reset banked memory address colum to 0
 118+ E804 1B                                   dec     de
 119+ E805 C3 E9 E7                             jp      .bankSelected
 120+ E808
# file closed: ../../Layer2Graphics/asm_l2_plot_horizontal.asm
 709  E808                  INCLUDE "../../Layer2Graphics/asm_l2_plot_vertical.asm"
# file opened: ../../Layer2Graphics/asm_l2_plot_vertical.asm
   1+ E808              ; ">l2_draw_vert_segment"
   2+ E808              ; ">hl = bank adjusted pixel poke address d = length, e = color"
   3+ E808              ; ">will always clip once h = 64 even if length > 64 destroys a and hl, d = resudual length not plotted"
   4+ E808 7A           l2_draw_vert_segment:   ld		a,d
   5+ E809 FE 00        .emptylinecheck:	    cp 		0
   6+ E80B C8                                   ret		z
   7+ E80C FE 01        .justonepixel	        cp		1
   8+ E80E 20 02                                jr		nz, .multiplepixelsLoop
   9+ E810 73                                   ld		(hl),e
  10+ E811 C9                                   ret
  11+ E812              .multiplepixelsLoop:
  12+ E812 7C           .endofbankcheck:        ld   	a,h
  13+ E813 FE 40                                cp   	64
  14+ E815 D0                                   ret		nc							; check before we poke data if we have hit a boundary
  15+ E816 73           .canplotapixel:         ld   	(hl),e						; set colour
  16+ E817 24                                   inc 	h							; we don't check here else we would need a dec d on ret could do for optimisation of loop though
  17+ E818 15                                   dec		d
  18+ E819 C8                                   ret		z
  19+ E81A 18 F6                                jr		.multiplepixelsLoop
  20+ E81C
  21+ E81C              ; ">l2_draw_vert_line"
  22+ E81C              ; ">bc = row col d = length, e = color"
  23+ E81C 78           l2_draw_vert_line:      ld 		a,b
  24+ E81D FE C0        .offscreencheck:        cp 		SCREEN_HEIGHT
  25+ E81F D0                                   ret 	nc							; can't start off the screen
  26+ E820 7A           .emptylinecheck:        ld		a,d
  27+ E821 FE 00                                cp		0
  28+ E823 C8                                   ret		z
  29+ E824 FE 01                                cp		1
  30+ E826 20 10                                jr		nz,.multiplepixels
  31+ E828              .itsonepixel:           l2_plot_macro; call	l2_plot_pixel
  31+ E828 78          >                        ld      a,b
  31+ E829             >                        JumpIfAGTENusng 192 ,.NoPlot
  31+ E829 FE C0       >                        cp     192
  31+ E82B D2 37 E8    >                        jp		nc,.NoPlot
  31+ E82E 69          >                        ld      l,c
  31+ E82F CD 78 E0    >                        call    asm_l2_row_bank_select
  31+ E832 67          >                        ld      h,a
  31+ E833 3A FA E3    >                        ld      a,(line_gfx_colour)
  31+ E836 77          >                        ld      (hl),a
  31+ E837             >.NoPlot:
  32+ E837 C9                                   ret
  33+ E838              .multiplepixels:						; so now we have at least 2 pixels to plot
  34+ E838 7A           .clipto192:             ld		a,d							; get length
  35+ E839 80                                   add		a,b							; a= row + length
  36+ E83A 38 04                                jr		c,.needtoclip				; if it was > 255 then there is a definite need
  37+ E83C FE C0                                cp		SCREEN_HEIGHT
  38+ E83E 38 08                                jr		c, .noclipneeded
  39+ E840 78           .needtoclip             ld		a,b
  40+ E841 82                                   add		a,d
  41+ E842 D6 C0                                sub		SCREEN_HEIGHT
  42+ E844 67                                   ld		h,a							; use h as a temp holding for (row + length) - 192
  43+ E845 7A                                   ld		a,d
  44+ E846 94                                   sub		h
  45+ E847 57                                   ld		d,a							; d = length - ((row + length) - 192)
  46+ E848              ; so now BC = row col, d = length clipped, e = color
  47+ E848 78           .noclipneeded:          ld		a,b
  48+ E849 C5 D5                                push	bc,,de
  49+ E84B CD 78 E0                             call 	asm_l2_row_bank_select
  49+ E84E               	 	; we now have poke address and a variable holding current bank number
  50+ E84E D1 C1                                pop		bc,,de
  51+ E850 67                                   ld		h,a							; b now tolds target pixel for first plot
  52+ E851 69                                   ld		l,c  						; and c holds pixel column for plotting
  53+ E852 CD 08 E8                             call 	l2_draw_vert_segment		; draw seg, d = pixels remaining
  54+ E855 7A                                   ld		a,d							; a and d = nbr pixels remaining
  55+ E856 FE 00                                cp		0
  56+ E858 28 27                                jr		z, .doneplotting
  57+ E85A 3A 00 E0     .anotherbank:           ld		a, (varL2_BANK_SELECTED)
  58+ E85D 3C                                   inc		a
  59+ E85E 06 00                                ld		b,0
  60+ E860 C5 D5                                push	bc,,de
  61+ E862 CD 53 E0                             call 	asm_l2_bank_n_select
  62+ E865 D1 C1                                pop     bc,,de
  63+ E867 60                                   ld		h,b							; b now tolds target pixel for first plot
  64+ E868 69                                   ld		l,c  						; and c holds pixel column for plotting
  65+ E869 CD 08 E8                             call	l2_draw_vert_segment
  66+ E86C 7A                                   ld		a,d
  67+ E86D FE 00                                cp		0
  68+ E86F 28 10                                jr		z,.doneplotting
  69+ E871 3A 00 E0     .yetanotherbank:        ld		a, (varL2_BANK_SELECTED)
  70+ E874 3C                                   inc		a
  71+ E875 06 00                                ld		b,0
  72+ E877 C5 D5                                push	bc,,de
  73+ E879 CD 53 E0                             call 	asm_l2_bank_n_select
  74+ E87C D1                                   pop		de
  75+ E87D E1                                   pop		hl							; hl = bc
  76+ E87E CD 08 E8                             call	l2_draw_vert_segment		; we have now hit 192 pixels so done
  77+ E881 C9           .doneplotting:	        ret
  78+ E882
  79+ E882              ; ">l2_draw_vert_line_to"
  80+ E882              ; ">bc = row col d = to position, e = color"
  81+ E882 78           l2_draw_vert_line_to:   ld		a,b
  82+ E883 BA                                   cp		d
  83+ E884 38 02                                jr		c, .noyswap
  84+ E886 42           .yswap:                 ld		b,d			; Swap round row numbers so we are always incrementing
  85+ E887 57                                   ld		d,a			; now we have a top to bottom to we we can calc length from bc
  86+ E888 7A           .noyswap:               ld		a,d 		; we still may have d in a but only if it was bottom to top
  87+ E889 90                                   sub		b
  88+ E88A 3C                                   inc		a			; so now its length not offset
  89+ E88B 57                                   ld		d,a
  90+ E88C 18 8E                                jr		l2_draw_vert_line	; we can hijack its clipping, 0 check and return logic
  91+ E88E                                      ; no return needed
  92+ E88E
  93+ E88E
  94+ E88E              ;; ">l2_draw_vert_line"
  95+ E88E              ; ">b = row; hl = col, e = length, c = color"
  96+ E88E              l2_draw_vert_line_320:  ZeroA
  96+ E88E AF          >                        xor a
  97+ E88F B3                                   or      e
  98+ E890 C8                                   ret     z							; if its zero length then just return
  99+ E891                                      DISPLAY "TODO need 1 pixel logic"
 100+ E891 C5                                   push    bc
 101+ E892 CD F0 E0     .selectBank:            call    asm_l2_320_col_bank_select  ; select bank and load row into h
 102+ E895 C1                                   pop     bc
 103+ E896 68                                   ld      l,b                         ; hl is adjusted address
 104+ E897 E5                                   push    hl
 105+ E898 2B                                   dec     hl
 106+ E899                                      ClearCarryFlag
 106+ E899 B7          >                        or a
 107+ E89A 78           .checkVertLength:       ld      a,b
 108+ E89B 3D                                   dec     a
 109+ E89C                                      ClearCarryFlag
 109+ E89C B7          >                        or a
 110+ E89D 8B                                   adc     e                           ; check if it oversplills
 111+ E89E D2 A4 E8                             jp      nc,.lengthOK
 112+ E8A1 8B           .tooLong:               adc     e                           ; as a now is negive add length results
 113+ E8A2 3D                                   dec     a                           ; a = adjsted length
 114+ E8A3 5F                                   ld      e,a                         ;
 115+ E8A4 79           .lengthOK:              ld		a,c                         ; set colour
 116+ E8A5 C1                                   pop     bc                          ; bc = memory address
 117+ E8A6              ; we now hijack l2_draw_horz_dma as in 320 mode the screen is in effect rotated 90 degrees from a memory perspective
 118+ E8A6              ; de is already length, bc is already target
 119+ E8A6 32 53 E7                             ld		(l2_horz_pixel),a
 120+ E8A9 16 00                                ld      d,0                         ; de = length
 121+ E8AB ED 53 5B E7                          ld      (l2_horz_lenlo),de
 122+ E8AF ED 43 60 E7                          ld      (l2_horz_target),bc
 123+ E8B3 21 54 E7     .write_dma:             ld 		hl, l2_horz_line            ;
 124+ E8B6 06 10                                ld 		b, l2_horz_cmd_len          ;
 125+ E8B8 0E 6B                                ld		c,IO_DATAGEAR_DMA_PORT      ;
 126+ E8BA ED B3                                otir                                ; run line draw
 127+ E8BC C9                                   ret
 128+ E8BD
# file closed: ../../Layer2Graphics/asm_l2_plot_vertical.asm
 710  E8BD                  INCLUDE "../../Layer2Graphics/layer2_plot_diagonal.asm"
# file opened: ../../Layer2Graphics/layer2_plot_diagonal.asm
   1+ E8BD
   2+ E8BD              l2_draw_box_to:
   3+ E8BD              ; ">l2_draw_box_to bc=rowcol, de=torowcol a=color"
   4+ E8BD              ; ">NOT IMPLEMENTED YET"
   5+ E8BD C9           	ret
   6+ E8BE
   7+ E8BE              ;; Note l2stepx is done via self modifying code rather than an if for speed
   8+ E8BE              ;; l2stepx1 and l2stepx2 are the addresses to stick the inc or dec in
   9+ E8BE              l2incbcstep EQU $03
  10+ E8BE              l2incbstep	EQU	$04
  11+ E8BE              l2decbstep	EQU $05
  12+ E8BE              l2decbcstep EQU $0B
  13+ E8BE              l2deccstep	EQU $0D
  14+ E8BE              l2inccstep	EQU	$0C
  15+ E8BE              l2incdestep EQU $13
  16+ E8BE              l2decdestep EQU $1B
  17+ E8BE              l2inchlstep EQU $23
  18+ E8BE              l2dechlstep EQU $2B
  19+ E8BE              		; l2 deltas are signed
  20+ E8BE 00 00        l2deltaY	DW	0
  21+ E8C0 00 00        l2deltaX	DW	0
  22+ E8C2 00           l2deltaYsq	db	0
  23+ E8C3 00           l2deltaXsq	db	0
  24+ E8C4 00           l2deltaYn	db	0
  25+ E8C5 00           l2deltaXn	db	0
  26+ E8C6 00           l2deltaYsqn	db	0
  27+ E8C7 00           l2deltaXsqn	db	0
  28+ E8C8 00           l2linecolor	db	0
  29+ E8C9 00 00        l2fraction	dw	0
  30+ E8CB 00 00        l2e2		dw	0
  31+ E8CD 00           l2way		db	0
  32+ E8CE 00 00        l2targetPtr	dw	0
  33+ E8D0              ;; These arrays should be 192 but if we use 256 then getting array2 value is just inc h rather than indexing again.
  34+ E8D0 00 00 00...  l2targetArray1 ds	256
  35+ E9D0 00 00 00...  l2targetArray2 ds	256
  36+ EAD0              ;; Using Bresenham Algorithm draw a diagonal line top to bottom. First we must sort of course
  37+ EAD0              ;;plotLine(int x0, int y0, int x1, int y1)
  38+ EAD0              ;;    dx =  abs(x1-x0);
  39+ EAD0              ;;    sx = x0<x1 ? 1 : -1;
  40+ EAD0              ;;    dy = -abs(y1-y0);
  41+ EAD0              ;;    sy = y0<y1 ? 1 : -1;
  42+ EAD0              ;;    err = dx+dy;  /* error value e_xy */
  43+ EAD0              ;;    while (true)   /* loop */
  44+ EAD0              ;;        plot(x0, y0);
  45+ EAD0              ;;        if (x0==x1 && y0==y1) break;
  46+ EAD0              ;;        e2 = 2*err;
  47+ EAD0              ;;        if (e2 >= dy) /* e_xy+e_x > 0 */
  48+ EAD0              ;;            err += dy;
  49+ EAD0              ;;            x0 += sx;
  50+ EAD0              ;;        end if
  51+ EAD0              ;;        if (e2 <= dx) /* e_xy+e_y < 0 */
  52+ EAD0              ;;            err += dx;
  53+ EAD0              ;;            y0 += sy;
  54+ EAD0              ;;        end if
  55+ EAD0              ;;    end while
  56+ EAD0              ; ">l2_draw_diagonal_save, bc = y0,x0 de=y1,x1,a=array nbr ESOURCE LL30 or LION"
  57+ EAD0              ; ">hl will be either l2targetArray1 or 2"
  58+ EAD0              ; For S15 version we can still use the current table as this will hold final fill data
  59+ EAD0              ; but we have to come in with X1Y1 X2Y2 being 16 bit
  60+ EAD0              ; if the Y1Y2 are both off same side of screen or X1X2 both off same side them line array is set as empty
  61+ EAD0              ; so
  62+ EAD0              ;       for each line from Y1 to Y2
  63+ EAD0              ;           if calculate as normal
  64+ EAD0              ;                if off screen we don't write
  65+ EAD0              ;                if on screen we clip to 0,255  which is easy as a horizontal line
  66+ EAD0              ;           we will need a special case were a line is not rendered    we have x1=255 and X1 = 0, i.e. they are flipped
  67+ EAD0              ;              we could also cheat and say view port as 1 pixel edge border so we can count x1 = 0 as no line
  68+ EAD0
  69+ EAD0              ; This must be called with  Y1 < Y2 as we won;t do a pre check
  70+ EAD0              ; Caulates the temp x. IY [01] = X1 [23]=Y1 [45]=X2 [67]=Y2 [89]=midY3
  71+ EAD0              ; Draw a line from BC to DE, with target Y position in a, all values must be 2's C at this points
  72+ EAD0              ; calculate deltaX, deltaY for line.
  73+ EAD0              ; calculate offsetY = TargetY - Y1
  74+ EAD0              ; calculate XTarget = X1 + (deltaX/deltaY) *  offsetY
  75+ EAD0              ;;;l2DiagDeltaX    DW 0
  76+ EAD0              ;;;l2_diagonal_getx:       ld		hl,0                            ;
  77+ EAD0              ;;;                        ld      ixh,0                           ; flag byte clear
  78+ EAD0              ;;;                        ld      (target_y),a                    ; save target
  79+ EAD0              ;;;.calculateDeltaX:       ld      hl,(IY+4)
  80+ EAD0              ;;;                        ld      de,(IY+0)
  81+ EAD0              ;;;                        ClearCarryFlag
  82+ EAD0              ;;;                        sbc     hl,de
  83+ EAD0              ;;;                        ld      (l2DiagDeltaX),hl
  84+ EAD0              ;;;.calculateDeltaY:       ld      hl,(IY+6)
  85+ EAD0              ;;;                        ld      de,(IY+2)
  86+ EAD0              ;;;                        ClearCarryFlag
  87+ EAD0              ;;;                        sbc     hl,de
  88+ EAD0              ;;;                        ld      (l2DiagDeltaY),hl
  89+ EAD0              ;;;.ABSDx:                 ld      hl,(l2DiagDeltaX)
  90+ EAD0              ;;;                        ld      a,h
  91+ EAD0              ;;;                        and     $80
  92+ EAD0              ;;;                        jr      nz,.DxPositive
  93+ EAD0              ;;;.DxNegative:            macronegate16hl
  94+ EAD0              ;;;.DxPositive:            ex      de,hl                               ; de = deltaX
  95+ EAD0              ;;;                        ld      hl,(l2DiagDeltaY)
  96+ EAD0              ;;;                        ld      a,h
  97+ EAD0              ;;;                        and     $80
  98+ EAD0              ;;;                        jr      nz,.DyPositive
  99+ EAD0              ;;;.DyNegative:            macronegate16hl
 100+ EAD0              ;;;.DyPositive:
 101+ EAD0              ;;;.ScaleLoop:             ld      a,h                                 ; At this point DX and DY are ABS values
 102+ EAD0              ;;;                        or      d                                   ; .
 103+ EAD0              ;;;                        jr      z,.ScaleDone                        ; .
 104+ EAD0              ;;;                        ShiftDERight1                               ; .
 105+ EAD0              ;;;                        ShiftHLRight1                               ; .
 106+ EAD0              ;;;                        jr      .ScaleLoop                          ; scaled down Dx and Dy to 8 bit, Dy may have been;;                                                                                               negative
 107+ EAD0              ;;;.ScaleDone:             ; hl = ABS DY, DE = ABS DX,  bc = Y1, ix = Y2,   note H and D will be zero
 108+ EAD0              ;;;.CalculateDelta:        ld      a,e                                 ; if DX < DY goto DX/DY
 109+ EAD0              ;;;                        JumpIfALTNusng l,.DXdivDY                   ; else do DY/DX
 110+ EAD0              ;;;.DYdivDX:               ld      a,l                                 ;    A = DY
 111+ EAD0              ;;;                        ld      d,e                                 ;    D = DX
 112+ EAD0              ;;;                        call    AEquAmul256DivD                     ;    A = R = 256 * DY / DX
 113+ EAD0              ;;;.SaveGradientDYDX:      ld      (Gradient),a
 114+ EAD0              ;;;                        ld      a,ixh
 115+ EAD0              ;;;                        or      16
 116+ EAD0              ;;;                        ld      ixh,a                               ;
 117+ EAD0              ;;;                        jp      .ClipP1                             ;
 118+ EAD0              ;;;.DXdivDY:               ld      a,e                                 ;    A = DX
 119+ EAD0              ;;;                        ld      d,l                                 ;    D = DY
 120+ EAD0              ;;;                        call    AEquAmul256DivD                     ;    A = R = 256 * DX / DY
 121+ EAD0              ;;;.SaveGradientDXDY:      ld      (Gradient),a
 122+ EAD0              ;;;
 123+ EAD0              ;;;have X1 -> X
 124+ EAD0              ;;;need deltaMidY = MidY - Y0
 125+ EAD0              ;;;                        X0 + (DeltaMY * Gradient) but if the graident is flipped then its X0+(deltaMY / Gradient)
 126+ EAD0              ;;;
 127+ EAD0              ;;;
 128+ EAD0              ;;;.calculateDeltaY:
 129+ EAD0              ;;;.calcualteDxDyOrDyDx
 130+ EAD0              ;;;.calculate
 131+ EAD0              ;;;
 132+ EAD0              ; Total unoptimised version
 133+ EAD0              ; use hl, de, bc, af,
 134+ EAD0              ; no used yet ix iy
 135+ EAD0              ; can we do an ex for hl' and de' holding x and hl, de holding y?
 136+ EAD0              ;;;l2_X0                   DW 0
 137+ EAD0              ;;;l2_Y0                   DW 0
 138+ EAD0              ;;;l2_X1                   DW 0
 139+ EAD0              ;;;l2_Y1                   DW 0
 140+ EAD0              ;;;l2_DX                   DW 0
 141+ EAD0              ;;;l2_DY                   DW 0
 142+ EAD0              ;;;l2_SX                   DW 0
 143+ EAD0              ;;;l2_SY                   DW 0
 144+ EAD0              ;;;l2_Error                DW 0
 145+ EAD0              ;;;l2_E2                   DW 0
 146+ EAD0              ;;;int_bren_save_Array1:   ld      hl,(l2_X1)          ; if X0 < X1
 147+ EAD0              ;;;                        ld      de,(l2_X0)          ; calculate SX DX
 148+ EAD0              ;;;                        ClearCarryFlag              ;
 149+ EAD0              ;;;                        sbc     hl,de               ;
 150+ EAD0              ;;;                        bit     7,h                 ;
 151+ EAD0              ;;;                        jr      z,.DXPositive       ;
 152+ EAD0              ;;;.DXNegative:            NegHL                       ;
 153+ EAD0              ;;;                        ld      bc,-1               ;
 154+ EAD0              ;;;                        jp      .DoneCalcDx         ;
 155+ EAD0              ;;;.DXPositive:            ld      bc,1                ;
 156+ EAD0              ;;;.DoneCalcDx:            ld      (l2_SX),bc          ;
 157+ EAD0              ;;;                        ld      (l2_DX),hl          ;
 158+ EAD0              ;;;.CalcDY:                ld      hl,(l2_Y1)          ; If Y1 < Y1
 159+ EAD0              ;;;                        ld      de,(l2_Y0)          ; calculate SY DY
 160+ EAD0              ;;;                        ClearCarryFlag              ;
 161+ EAD0              ;;;                        sbc     hl,de               ;
 162+ EAD0              ;;;                        bit     7,h                 ;
 163+ EAD0              ;;;                        jr      z,.DYPositive       ;
 164+ EAD0              ;;;.DYNegative:            ld      bc,-1               ;
 165+ EAD0              ;;;                        jp      .DoneCalcDx         ;
 166+ EAD0              ;;;.DYPositive:            NegHL                       ;
 167+ EAD0              ;;;                        ld      bc,1                ;
 168+ EAD0              ;;;.DoneCalcDy:            ld      (l2_SY),bc          ;
 169+ EAD0              ;;;                        ld      (l2_DY),hl
 170+ EAD0              ;;;.CalcError:             ld      hl,(l2_DX)
 171+ EAD0              ;;;                        ld      de,(l2_DY)
 172+ EAD0              ;;;                        add     hl,de
 173+ EAD0              ;;;                        ld      (l2_Error),hl
 174+ EAD0              ;;;.CalcLoop:              break
 175+ EAD0              ;;;                        ld      hl,(l2_X0)          ; get X0 and Y0
 176+ EAD0              ;;;.CheckYRange:           ld      de,(l2_Y0)
 177+ EAD0              ;;;                        ld      a,d                 ; if Y > 127
 178+ EAD0              ;;;                        and     a                   ; or Y is negative
 179+ EAD0              ;;;                        jr      nz,.YOutOfRange     ; then we can skip the plot
 180+ EAD0              ;;;                        ld      a,e                 ;
 181+ EAD0              ;;;                        and     $80                 ;
 182+ EAD0              ;;;                        jr      nz,.YOutOfRange     ;
 183+ EAD0              ;;;.CheckXRange:           ld      a,h                 ; if X0 is negative
 184+ EAD0              ;;;                        and     a
 185+ EAD0              ;;;                        jr      z,.XOKToPlot
 186+ EAD0              ;;;                        and     $80
 187+ EAD0              ;;;                        jr      z,.NotXNegative
 188+ EAD0              ;;;.XNegative:             ld      a,0
 189+ EAD0              ;;;                        jp      .ClipXDone
 190+ EAD0              ;;;.NotXNegative:          ld      a,255
 191+ EAD0              ;;;                        jp      .ClipXDone
 192+ EAD0              ;;;.XOKToPlot:             ld      a,l                 ; no clip therefore we can just use l
 193+ EAD0              ;;;.ClipXDone:             push    hl
 194+ EAD0              ;;;                        push    af                  ; using the Y coordinate
 195+ EAD0              ;;;                        ld      hl,l2targetArray1   ; plot the X value for this row
 196+ EAD0              ;;;                        ld      a,e
 197+ EAD0              ;;;                        add     hl,a
 198+ EAD0              ;;;                        pop     af
 199+ EAD0              ;;;                        ld      (hl),a
 200+ EAD0              ;;;                        pop     hl
 201+ EAD0              ;;;.YOutOfRange: ; At this point we have either plotted or its outside array range
 202+ EAD0              ;;;                        ld      bc,(l2_X1)
 203+ EAD0              ;;;.CheckEndXY:            cpHLEquBC .CheckEndXYOK     ; hl will equal X0 still by here
 204+ EAD0              ;;;                        jp      nz,.x0x1Differ
 205+ EAD0              ;;;.CheckEndXYOK:          ld      bc,(l2_Y1)
 206+ EAD0              ;;;                        cpDEEquBC  .x0x1Differ      ; de will equal Y0 still by here
 207+ EAD0              ;;;                        ret     z                   ; if they are both the same we are done
 208+ EAD0              ;;;.x0x1Differ:
 209+ EAD0              ;;;.SetError2:             ld      hl,(l2_Error)       ; e2 = 2 * error
 210+ EAD0              ;;;                        add     hl,hl               ; .
 211+ EAD0              ;;;                        ld      (l2_E2),hl          ; .
 212+ EAD0              ;;;.CheckE2gteDY:          ld      de,(l2_DY)          ; if e2 >= dy
 213+ EAD0              ;;;                        call    compare16HLDE       ; .
 214+ EAD0              ;;;                        jp      pe, .E2DyParitySet
 215+ EAD0              ;;;                        jp      m,  .E2ltDY         ; to get here overflow clear, so if m is set then HL<DE
 216+ EAD0              ;;;                        jp      .E2gteDY
 217+ EAD0              ;;;.E2DyParitySet:         jp      p,  .E2ltDY         ; if pe is set, then if sign is clear HL<DE
 218+ EAD0              ;;;.E2gteDY:               ld      hl,(l2_X0)          ;      if x0 == x1 break
 219+ EAD0              ;;;                        ld      de,(l2_X1)          ;      .
 220+ EAD0              ;;;                        cpHLEquDE .ErrorUpdateDY    ;      .
 221+ EAD0              ;;;                        ret     z                   ;      .
 222+ EAD0              ;;;.ErrorUpdateDY:         ld      hl,(l2_Error)       ;      error = error + dy
 223+ EAD0              ;;;                        ld      de,(l2_DY)          ;      .
 224+ EAD0              ;;;                        add     hl,de               ;      .
 225+ EAD0              ;;;                        ld      (l2_Error),hl       ;      .
 226+ EAD0              ;;;.UpdateX0:              ld      hl,(l2_X0)          ;      x0 = x0 + sx
 227+ EAD0              ;;;                        ld      bc,(l2_SX)          ;      .
 228+ EAD0              ;;;                        add     hl,bc               ;      .
 229+ EAD0              ;;;                        ld      (l2_X0),hl          ;      .
 230+ EAD0              ;;;.E2ltDY:
 231+ EAD0              ;;;.CheckE2lteDX:          ld      hl,(l2_E2)          ; if e2 <= dx
 232+ EAD0              ;;;                        ld      de,(l2_DX)          ; as we can't do skip on e2>dx
 233+ EAD0              ;;;                        call    compare16HLDE       ; we will jump based on e2 <= dx
 234+ EAD0              ;;;                        jp      z, .E2lteDX
 235+ EAD0              ;;;                        jp      pe, .E2DxParitySet
 236+ EAD0              ;;;                        jp      m,  .E2lteDX         ; to get here overflow clear, so if m is set then HL<DE
 237+ EAD0              ;;;                        jp      .E2gteDx
 238+ EAD0              ;;;.E2DxParitySet:         jp      p,  .E2lteDX
 239+ EAD0              ;;;                        jp      .E2gteDx
 240+ EAD0              ;;;.E2lteDX:               ld      hl,(l2_Y0)          ;      .
 241+ EAD0              ;;;                        ld      de,(l2_Y1)          ;      .
 242+ EAD0              ;;;                        cpHLEquDE .ErrorUdpateDX    ;      .
 243+ EAD0              ;;;                        ret     z                   ;      .
 244+ EAD0              ;;;.ErrorUdpateDX:         ld      hl,(l2_Error)       ;      error = error + dx
 245+ EAD0              ;;;                        ld      de,(l2_DX)          ;      .
 246+ EAD0              ;;;                        add     hl,de               ;      .
 247+ EAD0              ;;;                        ld      (l2_Error),hl       ;      .
 248+ EAD0              ;;;.UpdateY0:              ld      hl,(l2_Y0)          ;      x0 = x0 + sx
 249+ EAD0              ;;;                        ld      bc,(l2_SY)          ;      .
 250+ EAD0              ;;;                        add     hl,bc              ;      .
 251+ EAD0              ;;;                        ld      (l2_Y0),hl         ;      .
 252+ EAD0              ;;;.E2gteDx:               jp      .CalcLoop           ; repeat until we have a return
 253+ EAD0
 254+ EAD0
 255+ EAD0              ;;;;;;;; for this it myst always be sorted Y0 -> Y2
 256+ EAD0              ;;;;;;;;; note we ca't use this to do x? as it will clip inherently
 257+ EAD0              ;;;;;;;l2_save_diagnonal_signed_1:
 258+ EAD0              ;;;;;;;                        ld		hl,0                            ;
 259+ EAD0              ;;;;;;;                        ld		(l2deltaX),hl                   ;
 260+ EAD0              ;;;;;;;                        ld		(l2deltaY),hl
 261+ EAD0              ;;;;;;;.CheckYOnScreen:        ld      de,(l2_commonTopY)
 262+ EAD0              ;;;;;;;                        ld      hl,(l2_bottomY)
 263+ EAD0              ;;;;;;;                        ld      a,d
 264+ EAD0              ;;;;;;;                        and     h
 265+ EAD0              ;;;;;;;                        and     $80
 266+ EAD0              ;;;;;;;                        jr      nz,.OffScreen
 267+ EAD0              ;;;;;;;;...dy = y1 - y0
 268+ EAD0              ;;;;;;;.CalcDeltaY:            ClearCarryFlag
 269+ EAD0              ;;;;;;;                        sbc     hl,de                           ; now delta is signed, if its negative then something bad as gone wrong
 270+ EAD0              ;;;;;;;                        ld      a,h
 271+ EAD0              ;;;;;;;                        and     $80
 272+ EAD0              ;;;;;;;                        jr      nz,.OffScreen
 273+ EAD0              ;;;;;;;                        ld      (l2deltaY),hl                   ; Delta signed
 274+ EAD0              ;;;;;;;CheckXOnScreen:         ld      de,(l2_leftX)
 275+ EAD0              ;;;;;;;                        ld      hl,(l2_rightX)
 276+ EAD0              ;;;;;;;                        ld      a,d
 277+ EAD0              ;;;;;;;                        and     h
 278+ EAD0              ;;;;;;;                        and     $80
 279+ EAD0              ;;;;;;;                        jr      nz,.OffScreen
 280+ EAD0              ;;;;;;;                        ClearCarryFlag
 281+ EAD0              ;;;;;;;;...dx = x1 - x0
 282+ EAD0              ;;;;;;;.CalcDeltaX:            sbc     hl,de                           ; now delta is signed, could be negative
 283+ EAD0              ;;;;;;;                        ld      (l2deltaX),hl                   ; Delta signed
 284+ EAD0              ;;;;;;;                        ld      a,h
 285+ EAD0              ;;;;;;;                        and     $80
 286+ EAD0              ;;;;;;;                        jr      nz,.LeftToRight
 287+ EAD0              ;;;;;;;.RightToLeft:           set up instrnctin
 288+ EAD0              ;;;;;;;.LeftToRight:           set up instrnctin
 289+ EAD0              ;;;;;;;.setErr:									                    ;  LD H  := (D'-E')/2    round up if +ve or down if -ve
 290+ EAD0              ;;;;;;;,FracDYltDX:            ld		hl,(l2deltaY)					; Fraction = dY - dX
 291+ EAD0              ;;;;;;;                        ld		de,(l2deltaX)
 292+ EAD0              ;;;;;;;                        ClearCarryFlag
 293+ EAD0              ;;;;;;;                        sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
 294+ EAD0              ;;;;;;;                        ex		de,hl
 295+ EAD0              ;;;;;;;                        ld		iyh,d							; we will use IY reg for fractions
 296+ EAD0              ;;;;;;;                        ld		iyl,e
 297+ EAD0              ;;;;;;;                        jp		p,.fracIsPositive
 298+ EAD0              ;;;;;;;
 299+ EAD0              ;;;;;;;plotLine(x0, y0, x1, y1)
 300+ EAD0              ;;;;;;;    dx = x1 - x0
 301+ EAD0              ;;;;;;;    dy = y1 - y0
 302+ EAD0              ;;;;;;;    D = 2*dy - dx
 303+ EAD0              ;;;;;;;    y = y0
 304+ EAD0              ;;;;;;;
 305+ EAD0              ;;;;;;;    for x from x0 to x1
 306+ EAD0              ;;;;;;;        plot(x,y)
 307+ EAD0              ;;;;;;;        if D > 0
 308+ EAD0              ;;;;;;;            y = y + 1
 309+ EAD0              ;;;;;;;            D = D - 2*dx
 310+ EAD0              ;;;;;;;        end if
 311+ EAD0              ;;;;;;;        D = D + 2*dy
 312+ EAD0              ;;;;;;;
 313+ EAD0
 314+ EAD0
 315+ EAD0
 316+ EAD0              ;;;;;.fracIsNegative:        NegIY
 317+ EAD0              ;;;;;                        ShiftIYRight1
 318+ EAD0              ;;;;;                        NegIY
 319+ EAD0              ;;;;;                        jp		.SkipCalcInc					; so we have a negative frac
 320+ EAD0              ;;;;;.fracIsPositive:        ShiftIYRight1
 321+ EAD0              ;;;;;.SkipCalcInc:		                        			    	; As we loop, bc = to plot current XY
 322+ EAD0              ;;;;;.preTargetArray:	    ld		hl,l2targetArray1               ; Assuming row 0
 323+ EAD0              ;;;;;l2S_setTarget:	        ld		(l2targetPtr),hl
 324+ EAD0              ;;;;;                                                                ; set DE to current row
 325+ EAD0              ;;;;;.S_Loop:			    ld		hl,(l2targetPtr)				; Insert into respective array
 326+ EAD0              ;;;;;                                                                ; calculate current row
 327+ EAD0              ;;;;;                                                                ; if current row >= 0
 328+ EAD0              ;;;;;                                                                ; write current X value in DE to (hl)
 329+ EAD0              ;;;;;                        ld		a,b
 330+ EAD0              ;;;;;                        add		hl,a
 331+ EAD0              ;;;;;                        ld		(hl),c
 332+ EAD0              ;;;;;l2S_CheckIfEnd:	        ld		a,ixh
 333+ EAD0              ;;;;;                        JumpIfAGTENusng	  b,l2S_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
 334+ EAD0              ;;;;;                        jp		l2S_Continue
 335+ EAD0              ;;;;;l2S_CheckXPos:          ld      a,(l2S_adjustCol)
 336+ EAD0              ;;;;;                        cp      l2inccstep; if we self modified to inc the we can do a cp e else its cp c
 337+ EAD0              ;;;;;                        jr      z,.IncCP
 338+ EAD0              ;;;;;.DecCP:                 ld      a,c
 339+ EAD0              ;;;;;                        ReturnIfALTNusng ixl
 340+ EAD0              ;;;;;                        ReturnIfAEqNusng ixl
 341+ EAD0              ;;;;;                        jp      l2S_Continue
 342+ EAD0              ;;;;;.IncCP:                 ld		a,c
 343+ EAD0              ;;;;;                        ReturnIfAGTENusng ixl					; if X1 has reached or exceeded X2 then we are done
 344+ EAD0              ;;;;;l2S_Continue:
 345+ EAD0              ;;;;;l2S_HNegative:			ld		a,iyh
 346+ EAD0              ;;;;;                        bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
 347+ EAD0              ;;;;;                        jr		z,l2S_ErrNotNegative			;
 348+ EAD0              ;;;;;l2S_ErrNegative:		ld		a,(l2deltaY)					; if its a negative error update X
 349+ EAD0              ;;;;;                        ld		d,0
 350+ EAD0              ;;;;;                        ld		e,a
 351+ EAD0              ;;;;;                        add		iy,de							; add deltaY(unsinged) to l2fraction
 352+ EAD0              ;;;;;l2S_adjustCol:          nop										; this is our inc/dec of X
 353+ EAD0              ;;;;;                        jr		l2S_Loop							; repeat loop
 354+ EAD0              ;;;;;l2S_ErrNotNegative:     ld		a,iyh
 355+ EAD0              ;;;;;                        or		iyl
 356+ EAD0              ;;;;;                        JumpIfAIsZero l2S_ErrZero					; if there is no error then goto zeroerror
 357+ EAD0              ;;;;;l2S_ErrPositive:        ld      de,iy;  lddeiy								; if its a positive error then we update Y
 358+ EAD0              ;;;;;                        ex		de,hl
 359+ EAD0              ;;;;;                        ld		d,0
 360+ EAD0              ;;;;;                        ld		a,(l2deltaX)
 361+ EAD0              ;;;;;                        ld		e,a
 362+ EAD0              ;;;;;                        ClearCarryFlag
 363+ EAD0              ;;;;;                        sbc		hl,de
 364+ EAD0              ;;;;;                        ex		de,hl
 365+ EAD0              ;;;;;                        ld      iy,de;ldiyde
 366+ EAD0              ;;;;;l2S_adjustRow:          inc		b								; move Y down by one
 367+ EAD0              ;;;;;                        jr		l2S_Loop
 368+ EAD0              ;;;;;l2S_ErrZero:            ld		hl,(l2deltaX)
 369+ EAD0              ;;;;;                        ex		de,hl
 370+ EAD0              ;;;;;                        ld		hl,(l2deltaY)
 371+ EAD0              ;;;;;                        ClearCarryFlag
 372+ EAD0              ;;;;;                        sbc		hl,de
 373+ EAD0              ;;;;;                        ex		de,hl
 374+ EAD0              ;;;;;                        ld      iy,de; ldiyde
 375+ EAD0              ;;;;;l2S_adjustCol2:         nop										; update X and Y
 376+ EAD0              ;;;;;                        inc		b
 377+ EAD0              ;;;;;                        jr		l2S_Loop
 378+ EAD0              ;;;;;
 379+ EAD0              ;;;;;.OffScreen:             SetCarryFlag
 380+ EAD0              ;;;;;                        ret
 381+ EAD0              ;;;;;
 382+ EAD0              ;;;;;
 383+ EAD0
 384+ EAD0                      IFDEF L2_DIAGONAL_SAVE
 385+ EAD0 ~            l2_draw_diagonal_save:  cp		1
 386+ EAD0 ~                                    jr		z,l2S_ItsArray1
 387+ EAD0 ~                                    ld		hl,l2targetArray2
 388+ EAD0 ~                                    jp		l2S_setTarget
 389+ EAD0 ~            l2S_ItsArray1:	        ld		hl,l2targetArray1
 390+ EAD0 ~            l2S_setTarget:	        ld		(l2targetPtr),hl
 391+ EAD0 ~            ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
 392+ EAD0 ~                                    ld		(l2linecolor),a					;save colour for later
 393+ EAD0 ~                                    ld		hl,0                            ;
 394+ EAD0 ~                                    ld		(l2deltaX),hl                   ;
 395+ EAD0 ~                                    ld		(l2deltaY),hl                   ; initlaise deltas as we will only be loading 8 bit in there but workign in 16 bit later
 396+ EAD0 ~            l2S_preSort:            ld		a,b								;
 397+ EAD0 ~                                    JumpIfALTNusng	d,l2S_noYSort			; we must have Y1 < Y2 (if eqyal then verical line picked up earlier
 398+ EAD0 ~            l2S_SortBasedOnY:	    ldhlbc									;
 399+ EAD0 ~                                    ex		de,hl                           ;
 400+ EAD0 ~                                    ldbchl									; swap over bc and de using hl as an intermediate
 401+ EAD0 ~            l2S_noYSort:		    ld		ixh,d							; ixh now holds target Y coord post sorting
 402+ EAD0 ~                                    ld		ixl,e							; ixl now holds target X coord post sorting
 403+ EAD0 ~            l2S_setXLen:            ld		a,c                             ;
 404+ EAD0 ~                                    JumpIfALTNusng e,l2S_PosXLen			; if x1 < x2 then we have a positive increment
 405+ EAD0 ~            l2S_NegXLen:            ld		a,c                             ;
 406+ EAD0 ~                                    sub     e                               ;
 407+ EAD0 ~                                    ld		(l2deltaX),a					; As x1 > x2 we do deltaX = X1 - X2
 408+ EAD0 ~                                    ld		a,l2deccstep					; and set the value for inc dec self modifying to Dec
 409+ EAD0 ~                                    jr		l2S_XINCDEC
 410+ EAD0 ~            ; we set comparison
 411+ EAD0 ~            l2S_PosXLen:	        ld		a,e                             ;
 412+ EAD0 ~                                    sub		c                               ;
 413+ EAD0 ~                                    ld 		(l2deltaX),a                    ; As x1 < x2 we do deltaX = X2 - X1
 414+ EAD0 ~                                    ld		a,l2inccstep                    ; and set the value for inc dec self modifying to Inc
 415+ EAD0 ~            ; also need to fix the comparison, if its +x then compare with
 416+ EAD0 ~            l2S_XINCDEC:	        ld		(l2S_adjustCol),a				;
 417+ EAD0 ~                                    ld		(l2S_adjustCol2),a				; update self modifying code for X update with inc or dec from above
 418+ EAD0 ~            l2S_setYLen:            ld		a,d							 	; presorted on Y so it is now always positive
 419+ EAD0 ~                                    sub		b
 420+ EAD0 ~                                    ld 		(l2deltaY),a					; DeltaY = Y2 - Y1
 421+ EAD0 ~            l2S_setErr:									;  LD H  := (D'-E')/2    round up if +ve or down if -ve
 422+ EAD0 ~            ldS_FracDYltDX:         ld		hl,(l2deltaY)					; Fraction = dY - dX
 423+ EAD0 ~                                    ld		de,(l2deltaX)
 424+ EAD0 ~                                    ClearCarryFlag
 425+ EAD0 ~                                    sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
 426+ EAD0 ~                                    ex		de,hl
 427+ EAD0 ~                                    ld		iyh,d							; we will use IY reg for fractions
 428+ EAD0 ~                                    ld		iyl,e
 429+ EAD0 ~                                    jp		p,l2S_fracIsPositive
 430+ EAD0 ~            l2S_fracIsNegative:     NegIY
 431+ EAD0 ~                                    ShiftIYRight1
 432+ EAD0 ~                                    NegIY
 433+ EAD0 ~                                    jp		l2S_SkipCalcInc					; so we have a negative frac
 434+ EAD0 ~            l2S_fracIsPositive:     ShiftIYRight1
 435+ EAD0 ~            l2S_SkipCalcInc:		                        				; As we loop, bc = to plot current XY
 436+ EAD0 ~            l2S_Loop:			    ld		hl,(l2targetPtr)				; Insert into respective array
 437+ EAD0 ~                                    ld		a,b
 438+ EAD0 ~                                    add		hl,a
 439+ EAD0 ~                                    ld		(hl),c
 440+ EAD0 ~            l2S_CheckIfEnd:	        ld		a,ixh
 441+ EAD0 ~                                    JumpIfAGTENusng	  b,l2S_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
 442+ EAD0 ~                                    jp		l2S_Continue
 443+ EAD0 ~            l2S_CheckXPos:          ld      a,(l2S_adjustCol)
 444+ EAD0 ~                                    cp      l2inccstep; if we self modified to inc the we can do a cp e else its cp c
 445+ EAD0 ~                                    jr      z,.IncCP
 446+ EAD0 ~            .DecCP:                 ld      a,c
 447+ EAD0 ~                                    ReturnIfALTNusng ixl
 448+ EAD0 ~                                    ReturnIfAEqNusng ixl
 449+ EAD0 ~                                    jp      l2S_Continue
 450+ EAD0 ~            .IncCP:                 ld		a,c
 451+ EAD0 ~                                    ReturnIfAGTENusng ixl					; if X1 has reached or exceeded X2 then we are done
 452+ EAD0 ~            l2S_Continue:
 453+ EAD0 ~            l2S_HNegative:			ld		a,iyh
 454+ EAD0 ~                                    bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
 455+ EAD0 ~                                    jr		z,l2S_ErrNotNegative			;
 456+ EAD0 ~            l2S_ErrNegative:		ld		a,(l2deltaY)					; if its a negative error update X
 457+ EAD0 ~                                    ld		d,0
 458+ EAD0 ~                                    ld		e,a
 459+ EAD0 ~                                    add		iy,de							; add deltaY(unsinged) to l2fraction
 460+ EAD0 ~            l2S_adjustCol:          nop										; this is our inc/dec of X
 461+ EAD0 ~                                    jr		l2S_Loop							; repeat loop
 462+ EAD0 ~            l2S_ErrNotNegative:     ld		a,iyh
 463+ EAD0 ~                                    or		iyl
 464+ EAD0 ~                                    JumpIfAIsZero l2S_ErrZero					; if there is no error then goto zeroerror
 465+ EAD0 ~            l2S_ErrPositive:        ld      de,iy;  lddeiy								; if its a positive error then we update Y
 466+ EAD0 ~                                    ex		de,hl
 467+ EAD0 ~                                    ld		d,0
 468+ EAD0 ~                                    ld		a,(l2deltaX)
 469+ EAD0 ~                                    ld		e,a
 470+ EAD0 ~                                    ClearCarryFlag
 471+ EAD0 ~                                    sbc		hl,de
 472+ EAD0 ~                                    ex		de,hl
 473+ EAD0 ~                                    ld      iy,de;ldiyde
 474+ EAD0 ~            l2S_adjustRow:          inc		b								; move Y down by one
 475+ EAD0 ~                                    jr		l2S_Loop
 476+ EAD0 ~            l2S_ErrZero:            ld		hl,(l2deltaX)
 477+ EAD0 ~                                    ex		de,hl
 478+ EAD0 ~                                    ld		hl,(l2deltaY)
 479+ EAD0 ~                                    ClearCarryFlag
 480+ EAD0 ~                                    sbc		hl,de
 481+ EAD0 ~                                    ex		de,hl
 482+ EAD0 ~                                    ld      iy,de; ldiyde
 483+ EAD0 ~            l2S_adjustCol2:         nop										; update X and Y
 484+ EAD0 ~                                    inc		b
 485+ EAD0 ~                                    jr		l2S_Loop
 486+ EAD0                      ENDIF
 487+ EAD0                      DEFINE  L2_DRAW_DIAGONAL 1
 488+ EAD0                      IFDEF L2_DRAW_DIAGONAL
 489+ EAD0              ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
 490+ EAD0 32 C8 E8     l2_draw_diagonal:       ld		(l2linecolor),a					;save colour for later
 491+ EAD3 21 00 00                             ld		hl,0                            ;
 492+ EAD6 22 C0 E8                             ld		(l2deltaX),hl                   ;
 493+ EAD9 22 BE E8                             ld		(l2deltaY),hl                   ; initlaise deltas as we will only be loading 8 bit in there but workign in 16 bit later
 494+ EADC 78           l2D_preSort:            ld		a,b								;
 495+ EADD                                      JumpIfALTNusng	d,l2D_noYSort			; we must have Y1 < Y2 (if equal then verical line picked up earlier
 495+ EADD BA          >                        cp      d
 495+ EADE DA E6 EA    >                        jp		c, l2D_noYSort
 496+ EAE1              l2D_SortBasedOnY:	    ldhlbc									;
 496+ EAE1 60          >                        ld		h,b
 496+ EAE2 69          >                        ld		l,c
 497+ EAE3 EB                                   ex		de,hl                           ;
 498+ EAE4                                      ldbchl									; swap over bc and de using hl as an intermediate
 498+ EAE4 44          >                        ld		b,h
 498+ EAE5 4D          >                        ld		c,l
 499+ EAE6 DD 62        l2D_noYSort:		    ld		ixh,d							; ixh now holds target Y coord post sorting
 500+ EAE8 DD 6B                                ld		ixl,e							; ixl now holds target X coord post sorting
 501+ EAEA 79           l2D_setXLen:            ld		a,c                             ;
 502+ EAEB                                      JumpIfALTNusng e,l2D_PosXLen			; if x1 < x2 then we have a positive increment
 502+ EAEB BB          >                        cp      e
 502+ EAEC DA F8 EA    >                        jp		c, l2D_PosXLen
 503+ EAEF 79           l2D_NegXLen:            ld		a,c                             ;
 504+ EAF0 93                                   sub     e                               ;
 505+ EAF1 32 C0 E8                             ld		(l2deltaX),a					; As x1 > x2 we do deltaX = X1 - X2
 506+ EAF4 3E 0D                                ld		a,l2deccstep					; and set the value for inc dec self modifying to Dec
 507+ EAF6 18 07                                jr		l2D_XINCDEC
 508+ EAF8 7B           l2D_PosXLen:	        ld		a,e                             ;
 509+ EAF9 91                                   sub		c                               ;
 510+ EAFA 32 C0 E8                             ld 		(l2deltaX),a                    ; As x1 < x2 we do deltaX = X2 - X1
 511+ EAFD 3E 0C                                ld		a,l2inccstep                    ; and set the value for inc dec self modifying to Inc
 512+ EAFF 32 7A EB     l2D_XINCDEC:	        ld		(l2D_adjustCol),a				;
 513+ EB02 32 AA EB                             ld		(l2D_adjustCol2),a				; update self modifying code for X update with inc or dec from above
 514+ EB05 7A           l2D_setYLen				ld		a,d							 	; presorted on Y so it is now always positive
 515+ EB06 90                                   sub		b
 516+ EB07 32 BE E8                             ld 		(l2deltaY),a					; DeltaY = Y2 - Y1
 517+ EB0A              l2D_setErr:									;  LD H  := (D'-E')/2    round up if +ve or down if -ve
 518+ EB0A 2A BE E8     ldD_FracDYltDX:			ld		hl,(l2deltaY)					; Fraction = dY - dX
 519+ EB0D ED 5B C0 E8                          ld		de,(l2deltaX)
 520+ EB11                                      ClearCarryFlag
 520+ EB11 B7          >                        or a
 521+ EB12 ED 52                                sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
 522+ EB14 EB                                   ex		de,hl
 523+ EB15 FD 62                                ld		iyh,d							; we will use IY reg for fractions
 524+ EB17 FD 6B                                ld		iyl,e
 525+ EB19 F2 3E EB                             jp		p,l2D_fracIsPositive
 526+ EB1C              l2D_fracIsNegative:     NegIY
 526+ EB1C AF          >                    xor a
 526+ EB1D FD 95       >                    sub iyl
 526+ EB1F FD 6F       >                    ld iyl,a
 526+ EB21 9F          >                    sbc a,a
 526+ EB22 FD 94       >                    sub iyh
 526+ EB24 FD 67       >                    ld iyh,a
 527+ EB26                                      ShiftIYRight1
 527+ EB26 FD 7C       >               ld   a,iyh
 527+ EB28 CB 3F       >               srl  a
 527+ EB2A FD 67       >               ld   iyh,a
 527+ EB2C FD 7D       >               ld   a,iyl
 527+ EB2E 1F          >               rra
 527+ EB2F FD 6F       >               ld   iyl,a
 528+ EB31                                      NegIY
 528+ EB31 AF          >                    xor a
 528+ EB32 FD 95       >                    sub iyl
 528+ EB34 FD 6F       >                    ld iyl,a
 528+ EB36 9F          >                    sbc a,a
 528+ EB37 FD 94       >                    sub iyh
 528+ EB39 FD 67       >                    ld iyh,a
 529+ EB3B C3 49 EB                             jp		l2D_SkipCalcInc					; so we have a negative frac
 530+ EB3E              l2D_fracIsPositive:     ShiftIYRight1
 530+ EB3E FD 7C       >               ld   a,iyh
 530+ EB40 CB 3F       >               srl  a
 530+ EB42 FD 67       >               ld   iyh,a
 530+ EB44 FD 7D       >               ld   a,iyl
 530+ EB46 1F          >               rra
 530+ EB47 FD 6F       >               ld   iyl,a
 531+ EB49              l2D_SkipCalcInc:
 532+ EB49 C5 D5        l2D_Loop:				push	bc,,de                 			; l2DeltaY and l2DeltaX are set
 533+ EB4B 3A C8 E8                             ld		a,(l2linecolor)     			;
 534+ EB4E                                      l2_plot_macro;call	l2_plot_pixel       			; Plot Pixel
 534+ EB4E 78          >                        ld      a,b
 534+ EB4F             >                        JumpIfAGTENusng 192 ,.NoPlot
 534+ EB4F FE C0       >                        cp     192
 534+ EB51 D2 5D EB    >                        jp		nc,.NoPlot
 534+ EB54 69          >                        ld      l,c
 534+ EB55 CD 78 E0    >                        call    asm_l2_row_bank_select
 534+ EB58 67          >                        ld      h,a
 534+ EB59 3A FA E3    >                        ld      a,(line_gfx_colour)
 534+ EB5C 77          >                        ld      (hl),a
 534+ EB5D             >.NoPlot:
 535+ EB5D D1 C1                                pop     bc,,de
 536+ EB5F DD 7C        l2D_CheckIfEnd:	        ld		a,ixh
 537+ EB61                                      JumpIfAGTENusng	  b,l2D_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
 537+ EB61 B8          >                        cp     b
 537+ EB62 D2 68 EB    >                        jp		nc,l2D_CheckXPos
 538+ EB65 C3 6C EB                             jp		l2D_Continue
 539+ EB68 79           l2D_CheckXPos:          ld		a,c
 540+ EB69                                      ReturnIfAEqNusng ixl					; if X1 has reached or exceeded X2 then we are done
 540+ EB69 DD BD       >                        cp      ixl
 540+ EB6B C8          >                        ret     z
 541+ EB6C              l2D_Continue:
 542+ EB6C FD 7C        l2D_HNegative:			ld		a,iyh
 543+ EB6E CB 7F                                bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
 544+ EB70 28 0B                                jr		z,l2D_ErrNotNegative			;
 545+ EB72 3A BE E8     l2D_ErrNegative:		ld		a,(l2deltaY)
 546+ EB75 16 00                                ld		d,0
 547+ EB77 5F                                   ld		e,a
 548+ EB78 FD 19                                add		iy,de							; add deltaY(unsinged) to l2fraction
 549+ EB7A 00           l2D_adjustCol:          nop										; this is our inc/dec of X
 550+ EB7B 18 CC                                jr		l2D_Loop							; repeat loop
 551+ EB7D FD 7C        l2D_ErrNotNegative:     ld		a,iyh
 552+ EB7F FD B5                                or		iyl
 553+ EB81                                      JumpIfAIsZero l2D_ErrZero					; if there is no error then goto zeroerror
 553+ EB81 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 553+ EB82 CA 9B EB    >                        jp	    z, l2D_ErrZero
 554+ EB85 FD 54 FD 5D  l2D_ErrPositive:		ld      de,iy;lddeiy
 555+ EB89 EB                                   ex		de,hl
 556+ EB8A 16 00                                ld		d,0
 557+ EB8C 3A C0 E8                             ld		a,(l2deltaX)
 558+ EB8F 5F                                   ld		e,a
 559+ EB90                                      ClearCarryFlag
 559+ EB90 B7          >                        or a
 560+ EB91 ED 52                                sbc		hl,de
 561+ EB93 EB                                   ex		de,hl
 562+ EB94 FD 62 FD 6B                          ld      iy,de;ldiyde
 563+ EB98 04           l2D_adjustRow:			inc		b
 564+ EB99 18 AE                                jr		l2D_Loop
 565+ EB9B 2A C0 E8     l2D_ErrZero:            ld		hl,(l2deltaX)
 566+ EB9E EB                                   ex		de,hl
 567+ EB9F 2A BE E8                             ld		hl,(l2deltaY)
 568+ EBA2                                      ClearCarryFlag
 568+ EBA2 B7          >                        or a
 569+ EBA3 ED 52                                sbc		hl,de
 570+ EBA5 EB                                   ex		de,hl
 571+ EBA6 FD 62 FD 6B                          ld      iy,de;ldiyde
 572+ EBAA 00           l2D_adjustCol2:         nop										; update X and Y
 573+ EBAB 04                                   inc		b
 574+ EBAC 18 9B                                jr		l2D_Loop
 575+ EBAE              ;----------------------------------------------------------------------------------------------------------------------------------
 576+ EBAE                      ENDIF
 577+ EBAE
 578+ EBAE
 579+ EBAE
 580+ EBAE              ;Loin:				; BBC version of line draw
 581+ EBAE              ;; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color)"
 582+ EBAE              ;	ld		(l2linecolor),a					; save colour as a reg gets used alot, coudl move this into interrupt flag and disable interrups
 583+ EBAE              ;	ld		ixh,0							; ixh = s
 584+ EBAE              ;	ld		iyh,0							; iyh = swap
 585+ EBAE              ;	ld		l,0								; l will hold delta sign flags
 586+ EBAE              ;LoinCalcDeltaX:
 587+ EBAE              ;	ld		a,e
 588+ EBAE              ;	sub		c								; a = deltaX
 589+ EBAE              ;	JumpIfPositive LoinPosDx
 590+ EBAE              ;LoinNegDx:
 591+ EBAE              ;	neg										; carry flag will indicate deltaX was negative
 592+ EBAE              ;	ld		l,$80							; set bit 7 of l for negative
 593+ EBAE              ;LoinPosDx:
 594+ EBAE              ;	ld		ixl,a							; ixl = varP = deltaX
 595+ EBAE              ;LoinCalcDeltaY:
 596+ EBAE              ;	ld		a,d
 597+ EBAE              ;	sub		b								; a= deltaY
 598+ EBAE              ;	JumpIfPositive LoinPosDy
 599+ EBAE              ;LoinNegDy:
 600+ EBAE              ;	neg
 601+ EBAE              ;	set		6,l								; set bit 6 of l for negative deltaY
 602+ EBAE              ;LoinPosDy:
 603+ EBAE              ;	ld		iyl,a							; iyl = varQ = deltaY
 604+ EBAE              ;	JumpIfAGTENusng ixl, LoinSTPy			; if deltaY >= DeltaX then step along Y
 605+ EBAE              ;LoinSTPx:									; step along X
 606+ EBAE              ;	JumpOnBitClear l,7						; if l flags were clear then X2 < X2
 607+ EBAE              ;LoinSTPxSwapCoords:
 608+ EBAE              ;	dec		iyh								; swap flag now becomes FF
 609+ EBAE              ;	ld		a,l								; save l flags
 610+ EBAE              ;	ex		de,hl							; save de to hl
 611+ EBAE              ;	lddebc									; Point2 = point1
 612+ EBAE              ;	ldbchl									; Point1 = point2 that was saved
 613+ EBAE              ;	ld		l,a								; get back l flags
 614+ EBAE              ;LoinSTPxCorrectOrder:
 615+ EBAE              ;	l2_point_pixel_y_safe					; call plot pixel preseving bc hl
 616+ EBAE              ;	ld		a,iyl							; get delta Y back
 617+ EBAE              ;	ld		iy1,$FE							; roll counter
 618+ EBAE              ;LionSTPxRollQ:
 619+ EBAE              ;	sla		a								; highest bit of delta-Y
 620+ EBAE              ;	jp		c,LoinSTPxSteep
 621+ EBAE              ;	cp		ixl								; compare with DeltaX
 622+ EBAE              ;	jp		cs,LoinSTPxShallow
 623+ EBAE              ;LoinSTPxSteep:								;; LI4
 624+ EBAE              ;	sbc		a,ixl							; deltaYwork -= (deltaX+1)
 625+ EBAE              ;	scf										; force carry flag set
 626+ EBAE              ;LoinSTPxShallow:							;; LI5
 627+ EBAE              ;	rl		iyl								; rotate iyl which started as FE
 628+ EBAE              ;	jp		c,LionSTPxRollQ					; so we are doing a 6 bit loop
 629+ EBAE              ;	inc		ihl								; DeltaX += 1
 630+ EBAE              ;LoinSTPxYDirection:							; change this to self modifying code
 631+ EBAE              ;	ld		a,d
 632+ EBAE              ;	JumpIfAGTEn	b,LionDOWN:
 633+ EBAE              ;	ld		a,iyh							; swap flag
 634+ EBAE              ;	JumpIfANotZero	X1Inc  					; if swap flag was not set then no need to update R
 635+ EBAE              ;LoinSTPxX1Dec:
 636+ EBAE              ;	dec		c								; move left 1 pixel as we sawped
 637+ EBAE              ;LoinSTPxXCounter:							;; LIL2
 638+ EBAE              ;	sub		b
 639+ EBAE              ;	if
 640+ EBAE              ;
 641+ EBAE              ;85 82                   STA &82	   \ R	\ mask byte
 642+ EBAE              ;A5 81                   LDA &81	   \ Q	\ delta-Y
 643+ EBAE              ;A2 FE                   LDX #&FE	\ roll counter
 644+ EBAE              ;86 81                   STX &81		\ Q
 645+ EBAE              ;.LIL1	\ roll Q
 646+ EBAE              ;0A                      ASL A		\ highest bit of delta-Y
 647+ EBAE              ;B0 04                   BCS LI4		\ steep
 648+ EBAE              ;C5 1B                   CMP &1B	   \ P	\ delta-X
 649+ EBAE              ;90 03                   BCC LI5		\ shallow
 650+ EBAE              ;.LI4	\ steep
 651+ EBAE              ;E5 1B                   SBC &1B		\ P
 652+ EBAE              ;38                      SEC
 653+ EBAE              ;.LI5	\ shallow
 654+ EBAE              ;26 81                   ROL &81	   \ Q	\ #&FE
 655+ EBAE              ;B0 F2                   BCS LIL1 	\ loop Q, end with some low bits in Q
 656+ EBAE              ;A6 1B                   LDX &1B		\ P
 657+ EBAE              ;E8                      INX 		\ Xreg is width
 658+ EBAE              ;A5 37                   LDA &37		\ Y2
 659+ EBAE              ;E5 35                   SBC &35		\ Y1
 660+ EBAE              ;B0 2C                   BCS DOWN	\ draw line to the right and down
 661+ EBAE              ;A5 90                   LDA &90		\ SWAP
 662+ EBAE              ;D0 07                   BNE LI6		\ else Xreg was correct after all, no need to update R
 663+ EBAE              ;CA                      DEX
 664+ EBAE              ;.LIL2	\ counter X width
 665+ EBAE              ;A5 82                   LDA &82	   \ R	\ mask byte
 666+ EBAE              ;51 07                   EOR (&07),Y	\ (SC),Y
 667+ EBAE              ;91 07                   STA (&07),Y	\ (SC),Y
 668+ EBAE              ;.LI6	\ Xreg correct
 669+ EBAE              ;46 82                   LSR &82	   \ R	\ mask byte
 670+ EBAE              ;90 08                   BCC LI7   	\ else moving to next column to right. Bring carry in back
 671+ EBAE              ;66 82                   ROR &82		\ R
 672+ EBAE              ;A5 07                   LDA &07		\ SC
 673+ EBAE              ;69 08                   ADC #8		\ next column
 674+ EBAE              ;85 07                   STA &07		\ SC
 675+ EBAE              ;.LI7	\ S += Q. this is like an overflow monitor to update Y
 676+ EBAE              ;A5 83                   LDA &83		\ S
 677+ EBAE              ;65 81                   ADC &81	   \ Q	\ some low bits
 678+ EBAE              ;85 83                   STA &83		\ S
 679+ EBAE              ;90 07                   BCC LIC2	\ skip Y adjustment
 680+ EBAE              ;88                      DEY
 681+ EBAE              ;10 04                   BPL LIC2	\ skip Y adjustment
 682+ EBAE              ;C6 08                   DEC &08		\ SC+1
 683+ EBAE              ;A0 07                   LDY #7
 684+ EBAE              ;.LIC2	\ skip Y adjustment
 685+ EBAE              ;CA                      DEX
 686+ EBAE              ;D0 DC                   BNE LIL2	\ loop X width
 687+ EBAE              ;A4 85                   LDY &85	 \ YSAV \ restore Yreg
 688+ EBAE              ;60                      RTS
 689+ EBAE              ;
 690+ EBAE              ;.DOWN	\ Line is going to the right and down
 691+ EBAE              ;A5 90                   LDA &90		\ SWAP
 692+ EBAE              ;F0 07                   BEQ LI9		\ no swap
 693+ EBAE              ;CA                      DEX
 694+ EBAE              ;.LIL3	\ counter X width
 695+ EBAE              ;A5 82                   LDA &82	    \ R \ mask byte
 696+ EBAE              ;51 07                   EOR (&07),Y	\ (SC),Y
 697+ EBAE              ;91 07                   STA (&07),Y	\ (SC),Y
 698+ EBAE              ;.LI9	\ no swap
 699+ EBAE              ;46 82                   LSR &82		\ R
 700+ EBAE              ;90 08                   BCC LI10	\ still in correct column, hop
 701+ EBAE              ;66 82                   ROR &82		\ R
 702+ EBAE              ;A5 07                   LDA &07		\ SC
 703+ EBAE              ;69 08                   ADC #8		\ next column
 704+ EBAE              ;85 07                   STA &07		\ SC
 705+ EBAE              ;.LI10	\ this is like an overflow monitor to update Y
 706+ EBAE              ;A5 83                   LDA &83		\ S
 707+ EBAE              ;65 81                   ADC &81		\ Q
 708+ EBAE              ;85 83                   STA &83		\ S
 709+ EBAE              ;90 09                   BCC LIC3	\ skip Y adjustment
 710+ EBAE              ;C8                      INY
 711+ EBAE              ;C0 08                   CPY #8
 712+ EBAE              ;D0 04                   BNE LIC3	\ have not reached bottom byte of char, hop
 713+ EBAE              ;E6 08                   INC &08		\ SC+1
 714+ EBAE              ;A0 00                   LDY #0
 715+ EBAE              ;.LIC3	\ skipped Y adjustment
 716+ EBAE              ;CA                      DEX
 717+ EBAE              ;D0 DA                   BNE LIL3	\ loop X width
 718+ EBAE              ;A4 85                   LDY &85	 \ YSAV \ restore Yreg
 719+ EBAE              ;60                      RTS
 720+ EBAE              ;
 721+ EBAE              ;.STPY	\ -> &1797 \ Step along y for line, goes down and to right
 722+ EBAE              ;A4 35                   LDY &35		\ Y1
 723+ EBAE              ;98                      TYA
 724+ EBAE              ;A6 34                   LDX &34		\ X1
 725+ EBAE              ;C4 37                   CPY &37		\ Y2
 726+ EBAE              ;B0 10                   BCS LI15	\ skip swap if Y1 >= Y2
 727+ EBAE              ;C6 90                   DEC &90		\ SWAP
 728+ EBAE              ;A5 36                   LDA &36		\ X2
 729+ EBAE              ;85 34                   STA &34		\ X1
 730+ EBAE              ;86 36                   STX &36		\ X2
 731+ EBAE              ;AA                      TAX
 732+ EBAE              ;A5 37                   LDA &37		\ Y2
 733+ EBAE              ;85 35                   STA &35		\ Y1
 734+ EBAE              ;84 37                   STY &37		\ Y2
 735+ EBAE              ;A8                      TAY
 736+ EBAE              ;.LI15	\ Y1 Y2 order is now correct
 737+ EBAE              ;4A                      LSR A
 738+ EBAE              ;4A                      LSR A
 739+ EBAE              ;4A                      LSR A
 740+ EBAE              ;09 60                   ORA #&60
 741+ EBAE              ;85 08                   STA &08	 \ SC+1	\ screen hi
 742+ EBAE              ;8A                      TXA 		\ X1
 743+ EBAE              ;29 F8                   AND #&F8
 744+ EBAE              ;85 07                   STA &07	  \ SC	\ screen lo
 745+ EBAE              ;8A                      TXA
 746+ EBAE              ;29 07                   AND #7		\ mask index
 747+ EBAE              ;AA                      TAX
 748+ EBAE              ;BD AF 16                LDA &16AF,X \ TWOS,X \ Mode4 single pixel
 749+ EBAE              ;85 82                   STA &82	    \ R	\ mask
 750+ EBAE              ;A5 35                   LDA &35		\ Y1
 751+ EBAE              ;29 07                   AND #7
 752+ EBAE              ;A8                      TAY
 753+ EBAE              ;A5 1B                   LDA &1B	    \ P	\ delta-X
 754+ EBAE              ;A2 01                   LDX #1		\ roll counter
 755+ EBAE              ;86 1B                   STX &1B	    	\ P
 756+ EBAE              ;.LIL4	\ roll P
 757+ EBAE              ;0A                      ASL A
 758+ EBAE              ;B0 04                   BCS LI13	\ do subtraction
 759+ EBAE              ;C5 81                   CMP &81	    \ Q	\ delta-Y
 760+ EBAE              ;90 03                   BCC LI14	\ less than Q
 761+ EBAE              ;.LI13	\ do subtraction
 762+ EBAE              ;E5 81                   SBC &81		\ Q
 763+ EBAE              ;38                      SEC
 764+ EBAE              ;.LI14	\ less than Q
 765+ EBAE              ;26 1B                   ROL &1B		\ P
 766+ EBAE              ;90 F2                   BCC LIL4	\ loop P, end with some low bits in P
 767+ EBAE              ;A6 81                   LDX &81		\ Q
 768+ EBAE              ;E8                      INX 		\ adjust height
 769+ EBAE              ;A5 36                   LDA &36		\ X2
 770+ EBAE              ;E5 34                   SBC &34		\ X1
 771+ EBAE              ;90 2D                   BCC LFT		\ if C cleared then line moving to the left - hop down
 772+ EBAE              ;18                      CLC
 773+ EBAE              ;A5 90                   LDA &90		\ SWAP
 774+ EBAE              ;F0 07                   BEQ LI17 	\ skip first point
 775+ EBAE              ;CA                      DEX
 776+ EBAE              ;.LIL5	\ skipped first point, counter X
 777+ EBAE              ;A5 82                   LDA &82	    \ R \ mask byte
 778+ EBAE              ;51 07                   EOR (&07),Y	\ (SC),Y
 779+ EBAE              ;91 07                   STA (&07),Y	\ (SC),Y
 780+ EBAE              ;.LI17	\ skipped first point
 781+ EBAE              ;88                      DEY
 782+ EBAE              ;10 04                   BPL LI16	\ skip hi adjust
 783+ EBAE              ;C6 08                   DEC &08		\ SC+1
 784+ EBAE              ;A0 07                   LDY #7		\ new char
 785+ EBAE              ;	.LI16	\ skipped hi adjust
 786+ EBAE              ;A5 83                   LDA &83		\ S
 787+ EBAE              ;65 1B                   ADC &1B		\ P
 788+ EBAE              ;85 83                   STA &83		\ S
 789+ EBAE              ;90 0C                   BCC LIC5	\ skip, still in same column
 790+ EBAE              ;46 82                   LSR &82	  \ R	\ mask
 791+ EBAE              ;90 08                   BCC LIC5  	\ no mask bit hop
 792+ EBAE              ;66 82                   ROR &82   \ R	\ else moved over to next column, reset mask
 793+ EBAE              ;A5 07                   LDA &07	  \ SC  \ screen lo
 794+ EBAE              ;69 08                   ADC #8		\ next char below
 795+ EBAE              ;85 07                   STA &07		\ SC
 796+ EBAE              ;.LIC5	\ same column
 797+ EBAE              ;CA                      DEX
 798+ EBAE              ;D0 DC                   BNE LIL5	\ loop X height
 799+ EBAE              ;A4 85                   LDY &85	 \ YSAV	\ restore Yreg
 800+ EBAE              ;60                      RTS
 801+ EBAE              ;
 802+ EBAE              ;.LFT	\ going left
 803+ EBAE              ;A5 90                   LDA &90		\ SWAP
 804+ EBAE              ;F0 07                   BEQ LI18	\ skip first point
 805+ EBAE              ;CA                      DEX 		\ reduce height
 806+ EBAE              ;.LIL6	\ counter X height
 807+ EBAE              ;A5 82                   LDA &82	   \ R	\ mask byte
 808+ EBAE              ;51 07                   EOR (&07),Y	\ (SC),Y
 809+ EBAE              ;91 07                   STA (&07),Y	\ (SC),Y
 810+ EBAE              ;.LI18
 811+ EBAE              ;88                      DEY
 812+ EBAE              ;10 04                   BPL LI19	\ skip hi adjust
 813+ EBAE              ;C6 08                   DEC &08		\ SC+1
 814+ EBAE              ;A0 07                   LDY #7		\ rest char row
 815+ EBAE              ;.LI19	\ skipped hi adjust
 816+ EBAE              ;A5 83                   LDA &83		\ S
 817+ EBAE              ;65 1B                   ADC &1B	    \ P \ some low bits
 818+ EBAE              ;85 83                   STA &83		\ S
 819+ EBAE              ;90 0D                   BCC LIC6	\ no overflow
 820+ EBAE              ;06 82                   ASL &82	    \ R \ else move byte mask to the left
 821+ EBAE              ;90 09                   BCC LIC6	\ no overflow
 822+ EBAE              ;26 82                   ROL &82		\ R
 823+ EBAE              ;A5 07                   LDA &07		\ SC
 824+ EBAE              ;E9 07                   SBC #7		\ down 1 char
 825+ EBAE              ;85 07                   STA &07		\ SC
 826+ EBAE              ;18                      CLC
 827+ EBAE              ;.LIC6	\ no overflow
 828+ EBAE              ;CA                      DEX 		\ height
 829+ EBAE              ;D0 DB                   BNE LIL6	\ loop X
 830+ EBAE              ;A4 85                   LDY &85	 \ YSAV	\ restore Yreg
 831+ EBAE              ;.HL6
 832+ EBAE              ;60                      RTS 		\ end Line drawing
 833+ EBAE
 834+ EBAE
 835+ EBAE              ;;l2_draw_diagonalopt:
 836+ EBAE                              DISPLAY "TODO: optimisation"
 837+ EBAE              	; ">TODO l2_draw_diagonalopt fast horz vert optmisation"
 838+ EBAE              ;;	push	af
 839+ EBAE              ;;	ld		a,b
 840+ EBAE              ;;	cp		d
 841+ EBAE              ;;	jr		z,.RegularDiagnonal
 842+ EBAE              ;;.CheckHorz:
 843+ EBAE              ;;	ld		a,c
 844+ EBAE              ;;	cp		e
 845+ EBAE              ;;	jr		z,.horizontalLine
 846+ EBAE              ;;.RegularDiagnonal:
 847+ EBAE              ;;	pop		af
 848+ EBAE              ;;	call diag
 849+ EBAE
 850+ EBAE
 851+ EBAE              ;;l2_signed_mul2a:
 852+ EBAE              ;;; ">l2_signed_mul2a - Signed a = a * 2 using shift)"
 853+ EBAE              ;;	TEST	$80
 854+ EBAE              ;;	jr		nz, .negativecalc
 855+ EBAE              ;;.positivecalc:
 856+ EBAE              ;;	ccf
 857+ EBAE              ;;	rla
 858+ EBAE              ;;	ret
 859+ EBAE              ;;.negativecalc:
 860+ EBAE              ;;	neg
 861+ EBAE              ;;	ccf
 862+ EBAE              ;;	rla
 863+ EBAE              ;;	neg
 864+ EBAE              ;;	ret
 865+ EBAE              ;;
 866+ EBAE              ;;l2_signed_mul2atohl:
 867+ EBAE              ;;; ">l2_signed_mul2ahl - Signed hl = a * 2 using shift)"
 868+ EBAE              ;;	TEST	$80
 869+ EBAE              ;;	jr		nz, .negativecalc
 870+ EBAE              ;;.positivecalc:
 871+ EBAE              ;;	ld		hl,0
 872+ EBAE              ;;	ld		l,a
 873+ EBAE              ;;	add		hl,a
 874+ EBAE              ;;	ret
 875+ EBAE              ;;.negativecalc:
 876+ EBAE              ;;	neg
 877+ EBAE              ;;	ld		hl,0
 878+ EBAE              ;;	ld		l,a
 879+ EBAE              ;;	neghl
 880+ EBAE              ;;	ret
 881+ EBAE              ;;
 882+ EBAE              ;;l2_e2fractionby2:
 883+ EBAE              ;;	ld 		hl,(l2fraction)
 884+ EBAE              ;;	push	de
 885+ EBAE              ;;	ld		d,h
 886+ EBAE              ;;	ld		e,l
 887+ EBAE              ;;	add		hl,de
 888+ EBAE              ;;	pop		de
 889+ EBAE              ;;	ld		(l2e2),hl
 890+ EBAE              ;;	ret
 891+ EBAE
 892+ EBAE
 893+ EBAE
 894+ EBAE
 895+ EBAE
 896+ EBAE              ;;//	ld		(l2linecolor),a   			; could do an ex but it will be needed multiple times between many uses of a reg
 897+ EBAE              ;;//.catchLoop:
 898+ EBAE              ;;//	jp .catchLoop
 899+ EBAE              ;;//.continue:
 900+ EBAE              ;;//    ld      A,D
 901+ EBAE              ;;//    sub     H
 902+ EBAE              ;;//    jr      NC,.DXpositive    ;delta_x > 0
 903+ EBAE              ;;//.DXNegative:
 904+ EBAE              ;;//    neg
 905+ EBAE              ;;//.DXPositive:
 906+ EBAE              ;;//    ld      B,A              ;B <- |delta_x|
 907+ EBAE              ;;//    ld      A,E
 908+ EBAE              ;;//    sub     L
 909+ EBAE              ;;//    jr      NC,.DYpositive    ;delta_y > 0
 910+ EBAE              ;;//.DYNegative:
 911+ EBAE              ;;//    neg
 912+ EBAE              ;;//.DYPositive:
 913+ EBAE              ;;//    sub     B               ;|delta_y|
 914+ EBAE              ;;//	push	af
 915+ EBAE              ;;//	jr		c,.DeltaX
 916+ EBAE              ;;//.DeltaY
 917+ EBAE              ;;//	ld      A,H             			;if |delta_x| < |delta_y| then
 918+ EBAE              ;;//    ld      H,L             			;then values x and y are swapped
 919+ EBAE              ;;//    ld      L,A             			;so the loop will always be performed on the
 920+ EBAE              ;;//    ld      A,D             			;x value. A flag must be set to
 921+ EBAE              ;;//    ld      D,E             			;remind that data must be drawn (y,x)
 922+ EBAE              ;;//    ld      E,A             			;instead of (x,y)
 923+ EBAE              ;;//.DeltaX:
 924+ EBAE              ;;//	ld		a,d
 925+ EBAE              ;;//	sub		h
 926+ EBAE              ;;//	jr		nc,.TestDY					; x1 < x2
 927+ EBAE              ;;//.TestDX:
 928+ EBAE              ;;//	ex		de,hl
 929+ EBAE              ;;//.TestDY:
 930+ EBAE              ;;//	ld		a,e
 931+ EBAE              ;;//	sub		l
 932+ EBAE              ;;//    ld      A,$01
 933+ EBAE              ;;//    jr      NC,.StoreA
 934+ EBAE              ;;//    neg                     ;y1 > y2 : in case2 the 'y' variable
 935+ EBAE              ;;//.StoreA:
 936+ EBAE              ;;//        ld      (l2way),A
 937+ EBAE              ;;//.InitLine:
 938+ EBAE              ;;//        ld      B,H
 939+ EBAE              ;;//        ld      C,L
 940+ EBAE              ;;//        ld      A,E
 941+ EBAE              ;;//        sub     L
 942+ EBAE              ;;//        jr      NC,.EndInit
 943+ EBAE              ;;//        ld      A,L
 944+ EBAE              ;;//        ld      L,E
 945+ EBAE              ;;//        ld      E,A
 946+ EBAE              ;;//.EndInit:
 947+ EBAE              ;;//        ld      A,E
 948+ EBAE              ;;//        sub     L
 949+ EBAE              ;;//        rla
 950+ EBAE              ;;//        ld      L,A             ;value to add in case1 (d < 0)
 951+ EBAE              ;;//        add     A,H
 952+ EBAE              ;;//        sub     D
 953+ EBAE              ;;//        ld      E,A             ;'d' variable is initialised
 954+ EBAE              ;;//        add     A,H
 955+ EBAE              ;;//        sub     D
 956+ EBAE              ;;//        ld      H,A             ;value to add in case2 (d >= 0)
 957+ EBAE              ;;//.Loop:
 958+ EBAE              ;;//        ld      A,B
 959+ EBAE              ;;//        sub     D
 960+ EBAE              ;;//        jr      NC,.EndLine       ;the line is completely drawn.
 961+ EBAE              ;;//        pop     AF
 962+ EBAE              ;;//        bit     7,A
 963+ EBAE              ;;//        push    AF
 964+ EBAE              ;;//        push    AF
 965+ EBAE              ;;//        push    BC
 966+ EBAE              ;;//        jr      Z,.DrawPoint
 967+ EBAE              ;;//        ld      A,B
 968+ EBAE              ;;//        ld      B,C
 969+ EBAE              ;;//        ld      C,A
 970+ EBAE              ;;//.DrawPoint:
 971+ EBAE              ;;//		push	hl
 972+ EBAE              ;;//		pushbcdeaf
 973+ EBAE              ;;//		ld		b,e
 974+ EBAE              ;;//		ld		c,d
 975+ EBAE              ;;//	ld 		a,(l2linecolor)
 976+ EBAE              ;;//	call	l2_plot_pixel
 977+ EBAE              ;;//		popafdebc
 978+ EBAE              ;;//		pop		hl
 979+ EBAE              ;;//        pop     BC
 980+ EBAE              ;;//        pop     AF
 981+ EBAE              ;;//.TestD:
 982+ EBAE              ;;//        bit     7,E
 983+ EBAE              ;;//        jr      NZ,.Case1
 984+ EBAE              ;;//.Case2:                          ;d >= 0
 985+ EBAE              ;;//        ld      A,E
 986+ EBAE              ;;//        add     A,H
 987+ EBAE              ;;//        ld      E,A
 988+ EBAE              ;;//        ld      A,(l2way)
 989+ EBAE              ;;//        add     A,C
 990+ EBAE              ;;//        ld      C,A
 991+ EBAE              ;;//        jr      .EndLoop
 992+ EBAE              ;;//.Case1:                          ;d < 0
 993+ EBAE              ;;//        ld      A,E
 994+ EBAE              ;;//        add     A,L
 995+ EBAE              ;;//        ld      E,A
 996+ EBAE              ;;//.EndLoop:
 997+ EBAE              ;;//        inc     B
 998+ EBAE              ;;//        jr      .Loop
 999+ EBAE              ;;//.EndLine:
1000+ EBAE              ;;//        pop     AF              ;MUST NOT BE REMOVED
1001+ EBAE              ;;//        pop     HL              ;can be removed
1002+ EBAE              ;;//        pop     DE              ;can be removed
1003+ EBAE              ;;//        ret
1004+ EBAE
1005+ EBAE              ;;	ld		(.l2yadjust),a
1006+ EBAE              ;;	call	calcdeltax:
1007+ EBAE              ;;	ld		(.l2xadjust),a
1008+ EBAE              ;;.calcfraction:							; err(or fraction) = dx+dy;
1009+ EBAE              ;;	push	hl
1010+ EBAE              ;;	push	de
1011+ EBAE              ;;	ld		hl,(l2deltaX)
1012+ EBAE              ;;	ld		de,(l2deltaY)
1013+ EBAE              ;;	add		hl,de
1014+ EBAE              ;;	ld		(l2fraction),hl
1015+ EBAE              ;;	pop		de
1016+ EBAE              ;;	pop		hl
1017+ EBAE              ;;.mainloop:
1018+ EBAE              ;;	push	bc
1019+ EBAE              ;;	push	de
1020+ EBAE              ;;	ld 		a,(l2linecolor)
1021+ EBAE              ;;	call	l2_plot_pixel
1022+ EBAE              ;;	pop		de
1023+ EBAE              ;;	pop		bc
1024+ EBAE              ;;.arewefinishedtest
1025+ EBAE              ;;	ld		a,b
1026+ EBAE              ;;	cp		d
1027+ EBAE              ;;	jr		nz,.notthereyet
1028+ EBAE              ;;	ld		a,c
1029+ EBAE              ;;	cp		e
1030+ EBAE              ;;	ret		z
1031+ EBAE              ;;.notthereyet:
1032+ EBAE              ;;	push	de
1033+ EBAE              ;;	call	l2_e2fractionby2			; e2 = 2*err;
1034+ EBAE              ;;	pop		de
1035+ EBAE              ;;.e2dytest:								; if (e2 >= dy) /* e_xy+e_x > 0 */  then S and P/V are the same
1036+ EBAE              ;;	push	de							; so if m & pe  or p & po calc (m = sign set p = 0)
1037+ EBAE              ;;	ld		de,(l2deltaY)				;    if m & po  or p & pe skip  (pe = pv set po = pv 0)
1038+ EBAE              ;;	or		a							;
1039+ EBAE              ;;	sbc		hl,de						;
1040+ EBAE              ;;	pop		de
1041+ EBAE              ;;	jr		z,  .dodycalc				; if equal then calc
1042+ EBAE              ;;	jp		p,	.dodycalc				; sign clear to H>D even with negtives
1043+ EBAE              ;;	jr		.skipdycalc         		; sign = 0     so  skip as pe
1044+ EBAE              ;;.dodycalc:
1045+ EBAE              ;;	ld		hl,(l2fraction)
1046+ EBAE              ;;	push	de
1047+ EBAE              ;;	ld		de,(l2deltaY)
1048+ EBAE              ;;	add		hl,de
1049+ EBAE              ;;	ld		(l2fraction),de
1050+ EBAE              ;;	pop		de
1051+ EBAE              ;;.l2yadjust:
1052+ EBAE              ;;	nop
1053+ EBAE              ;;.skipdycalc:
1054+ EBAE              ;;.e2dxtest:								;  if (e2 <= dx) /* e_xy+e_y < 0 */ then S and P/V are different.
1055+ EBAE              ;;	ld		hl,(l2e2)
1056+ EBAE              ;;	push	de							;
1057+ EBAE              ;;	ld		de,(l2deltaX)				;
1058+ EBAE              ;;	or		a							; clear carry flag
1059+ EBAE              ;;	sbc		hl,de						; hl = hl - de is if de > hl will get pv and signed different?
1060+ EBAE              ;;	pop		de
1061+ EBAE              ;;	jr		z,.dodxcalc					; e2 == dx so do calc
1062+ EBAE              ;;	jp		m,.dodxcalc					; was sign bit set
1063+ EBAE              ;;	jr		.skipdxcalc         	    ; diff so skip ; pvclear = po        pvset = pe
1064+ EBAE              ;;.dodxcalc:
1065+ EBAE              ;;	ld		hl,(l2fraction)
1066+ EBAE              ;;	push	de
1067+ EBAE              ;;	ld		de,(l2deltaX)
1068+ EBAE              ;;	add		hl,de
1069+ EBAE              ;;	ld		(l2fraction),de
1070+ EBAE              ;;	pop		de
1071+ EBAE              ;;.l2xadjust:
1072+ EBAE              ;;	nop
1073+ EBAE              ;;.skipdxcalc:
1074+ EBAE              ;;	jr 		.mainloop
1075+ EBAE
1076+ EBAE
1077+ EBAE              ;;/l2_draw_diagonalold:
1078+ EBAE              ;;/MESSAGE ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color)"
1079+ EBAE              ;;/	ld		(l2linecolor),a   			; could do an ex but it will be needed multiple times between many uses of a reg
1080+ EBAE              ;;/.sortycoords:
1081+ EBAE              ;;/	ld		a,b							; Sort to Y0 is always > y1 so we don't have to deal with step y and only step x
1082+ EBAE              ;;/	cp		d
1083+ EBAE              ;;/	jr		nc, .nocoordswap
1084+ EBAE              ;;/.swapcoords:
1085+ EBAE              ;;/	ex		de,hl						; save de to hl ! effective code line 98 after macros
1086+ EBAE              ;;/	lddebc
1087+ EBAE              ;;/	ldbchl
1088+ EBAE              ;;/.nocoordswap:
1089+ EBAE              ;;/	ld		a,d							; l2_dy = -ABS(l2_vy1 - l2_vy0)
1090+ EBAE              ;;/	sub		b							; we have already sorted  so y1 > y0
1091+ EBAE              ;;/	ld		(l2deltaY),a
1092+ EBAE              ;;/	neg									; DEBUG
1093+ EBAE              ;;/	ld		(l2deltaYn),a				; DEBUG
1094+ EBAE              ;;/	neg									; DEBUG
1095+ EBAE              ;;/.deltaxequABSx0Minusx1:						; we need to set l2dx to abs x1-x0 and set
1096+ EBAE              ;;/    ld		a,c
1097+ EBAE              ;;/	cp		e
1098+ EBAE              ;;/	jr		c, .x1GTx0
1099+ EBAE              ;;/.x1LTx0
1100+ EBAE              ;;/	ld		a,c
1101+ EBAE              ;;/	sub		e
1102+ EBAE              ;;/	ld		(l2deltaX),a				; just 8 bit for now should it be 16?
1103+ EBAE              ;;/	neg									; DEBUG
1104+ EBAE              ;;/	ld		(l2deltaXn),a				; DEBUG
1105+ EBAE              ;;/	neg									; DEBUG
1106+ EBAE              ;;/	ld		a,l2incbstep
1107+ EBAE              ;;/	jr		.setlayershift0
1108+ EBAE              ;;/.x1GTx0:
1109+ EBAE              ;;/	ld		a,e
1110+ EBAE              ;;/	sub		c
1111+ EBAE              ;;/	ld		(l2deltaX),a					; just 8 bit for now should it be 16?
1112+ EBAE              ;;/	neg									; DEBUG
1113+ EBAE              ;;/	ld		(l2deltaXn),a				; DEBUG
1114+ EBAE              ;;/	neg									; DEBUG
1115+ EBAE              ;;/	ld		a,l2decbstep
1116+ EBAE              ;;/.setlayershift0:
1117+ EBAE              ;;/	ld		a,0
1118+ EBAE              ;;/	pushbcde
1119+ EBAE              ;;/	call	asm_l2_bank_n_select		; l2_layer_shift = 0 and bank 0 selected
1120+ EBAE              ;;/	popdebc
1121+ EBAE              ;;/; so now we have set inc or dec instruction, l2dy, l2dx and on bank 0,
1122+ EBAE              ;;/.dymuliplyby2:
1123+ EBAE              ;;/	ld		a, (l2deltaY)				; dy *= 2
1124+ EBAE              ;;/	call	l2_signed_mul2a
1125+ EBAE              ;;/	ld		(l2deltaYsq),a
1126+ EBAE              ;;/	neg									; DEBUG
1127+ EBAE              ;;/	ld		(l2deltaYsqn),a				; DEBUG
1128+ EBAE              ;;/	neg									; DEBUG
1129+ EBAE              ;;/.dxmuliplyby2:
1130+ EBAE              ;;/	ld		a, (l2deltaX)				; dx *= 2
1131+ EBAE              ;;/	call	l2_signed_mul2a
1132+ EBAE              ;;/	ld		(l2deltaXsq),a
1133+ EBAE              ;;/	neg									; DEBUG
1134+ EBAE              ;;/	ld		(l2deltaXsqn),a				; DEBUG
1135+ EBAE              ;;/	neg									; DEBUG
1136+ EBAE              ;;/.plotfirstpixel:
1137+ EBAE              ;;/	pushbcde
1138+ EBAE              ;;/	ld a,(l2linecolor)
1139+ EBAE              ;;/	call	l2_plot_pixel
1140+ EBAE              ;;/	popdebc
1141+ EBAE              ;;/.mainloop:								; if (l2_dx > l2_dy) signed
1142+ EBAE              ;;/	ld		a,(l2deltaX)				;If A < N, then S and P/V are different.
1143+ EBAE              ;;/	ld		hl,l2deltaY					;A >= N, then S and P/V are the same
1144+ EBAE              ;;/	cp		(hl)
1145+ EBAE              ;;/	jp		m,	.signset
1146+ EBAE              ;;/.signclear:
1147+ EBAE              ;;/	jp		pe,	.dxLTEdybranch
1148+ EBAE              ;;/	jr		.dxGTdybranch
1149+ EBAE              ;;/.signset:
1150+ EBAE              ;;/	jp		po,	.dxLTEdybranch
1151+ EBAE              ;;/.dxGTdybranch:
1152+ EBAE              ;;/	ld		a,(l2deltaYsq)
1153+ EBAE              ;;/	ld		hl,l2deltaX
1154+ EBAE              ;;/	sub		(hl)
1155+ EBAE              ;;/	ld		(l2fraction),a				; faction = dy - 1/2 dx
1156+ EBAE              ;;/.BranchAwhile							; while (l2_vx0 != l2_vx1)
1157+ EBAE              ;;/	ld		a,c
1158+ EBAE              ;;/	cp		e
1159+ EBAE              ;;/	ret		z							; if x0 = x1 then done
1160+ EBAE              ;;/.BranchAtestfraction:					; if (l2_fraction >= 0)
1161+ EBAE              ;;/	ld		a,(l2fraction)
1162+ EBAE              ;;/	TEST	$80
1163+ EBAE              ;;/	jr		nz,.BranchAskipYstep
1164+ EBAE              ;;/	inc		b							; 		++l2_vy0;
1165+ EBAE              ;;/	ld		hl,l2deltaXsq
1166+ EBAE              ;;/	sub		(hl)						; 		l2_fraction -= l2_dx;
1167+ EBAE              ;;/	ld		(l2fraction),a
1168+ EBAE              ;;/.BranchAskipYstep:
1169+ EBAE              ;;/.l2stepx1:
1170+ EBAE              ;;/	inc		b							; this is self modifying code point 1 l2_vx0 += l2_stepx
1171+ EBAE              ;;/	ld		a,(l2fraction)				; l2_fraction += l2_dy can optimise later as a already has this?
1172+ EBAE              ;;/	ld		hl,l2deltaYsq
1173+ EBAE              ;;/	add		a,(hl)
1174+ EBAE              ;;/	ld		(l2fraction),a
1175+ EBAE              ;;/.BranchAplotBCColA:						; l2_plot_pixel(l2_vx0,l2_vy0,color);
1176+ EBAE              ;;/	pushbcde
1177+ EBAE              ;;/	ld a,(l2linecolor)
1178+ EBAE              ;;/	call	l2_plot_pixel
1179+ EBAE              ;;/	popdebc
1180+ EBAE              ;;/.BranchAloop:
1181+ EBAE              ;;/	jr		.BranchAwhile
1182+ EBAE              ;;/.dxLTEdybranch:
1183+ EBAE              ;;/	ld		a,(l2deltaXsq)				; l2_fraction = l2_dx - (l2_dy >> 1);
1184+ EBAE              ;;/	ld		hl, l2deltaY
1185+ EBAE              ;;/	sub		(hl)
1186+ EBAE              ;;/	ld		(l2fraction),a				; faction = dy - 1/2 d
1187+ EBAE              ;;/.BranchBwhile:							; while (l2_vy0 != l2_vy1)
1188+ EBAE              ;;/	ld		a,b
1189+ EBAE              ;;/	cp		d
1190+ EBAE              ;;/	ret		z							; if x0 = x1 then done
1191+ EBAE              ;;/.BranchBtestfraction:					; if (l2_fraction >= 0)
1192+ EBAE              ;;/	ld		a,(l2fraction)
1193+ EBAE              ;;/	TEST	$80
1194+ EBAE              ;;/	jr		nz,.BranchBskipYstep
1195+ EBAE              ;;/.l2stepx2
1196+ EBAE              ;;/	inc		b							; l2_vx0 += l2_stepx; this is self modifying code point 2
1197+ EBAE              ;;/	ld		a,(l2fraction)				; l2_fraction -= l2_dy
1198+ EBAE              ;;/	ld		hl,l2deltaYsq
1199+ EBAE              ;;/	sub		(hl)
1200+ EBAE              ;;/	ld		(l2fraction),a
1201+ EBAE              ;;/.BranchBskipYstep:
1202+ EBAE              ;;/	ld		hl, l2deltaYsq
1203+ EBAE              ;;/	add		a,(hl)
1204+ EBAE              ;;/	ld		(l2fraction),a
1205+ EBAE              ;;/	inc		b							; ++l2_vy0;
1206+ EBAE              ;;/.BranchBplotBCColA:
1207+ EBAE              ;;/	pushbcde
1208+ EBAE              ;;/	ld a,(l2linecolor)
1209+ EBAE              ;;/	call	l2_plot_pixel
1210+ EBAE              ;;/	popdebc
1211+ EBAE              ;;/.BranchBloop:
1212+ EBAE              ;;/	jr		.BranchBwhile
1213+ EBAE
# file closed: ../../Layer2Graphics/layer2_plot_diagonal.asm
 711  EBAE                  INCLUDE "../../Layer2Graphics/int_bren_save.asm"
# file opened: ../../Layer2Graphics/int_bren_save.asm
   1+ EBAE              OPCODE_IncHL            EQU $23
   2+ EBAE              OPCODE_DecHL            EQU $2B
   3+ EBAE              OPCODE_IncHLIndirect    EQU $34
   4+ EBAE              OPCODE_DecHLIndirect    EQU $35
   5+ EBAE              OPCODE_IncDE            EQU $13
   6+ EBAE              OPCODE_DecDE            EQU $1B
   7+ EBAE              OPCODE_JpNCnn           EQU $D2
   8+ EBAE              OPCODE_JpCnn            EQU $DA
   9+ EBAE              LOWEST_SAVE             EQU 0
  10+ EBAE              HIGHEST_SAVE            EQU 1
  11+ EBAE
  12+ EBAE              SetIncrement:           MACRO   Location
  13+ EBAE ~                                    ld      a,OPCODE_IncDE
  14+ EBAE ~                                    ld      (Location),a
  15+ EBAE                                      ENDM
  16+ EBAE              SetDecrement:           MACRO   Location
  17+ EBAE ~                                    ld      a,OPCODE_DecDE
  18+ EBAE ~                                    ld      (Location),a
  19+ EBAE                                      ENDM
  20+ EBAE
  21+ EBAE              ; So next optimisation
  22+ EBAE              ; we know that we start from row y0 to row Y0
  23+ EBAE              ; so we can just reference that row range and zero it out rather than the whole
  24+ EBAE              ; data set
  25+ EBAE 00           l2_fillValue            DB 0
  26+ EBAF
  27+ EBAF 83 C3 C7 CB  l2_fill_line            DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
  27+ EBB3 7D
  28+ EBB4 AE EB        l2_fill_colr            DW l2_fillValue
  29+ EBB6 FF           l2_fill_lenlo           DB 255
  30+ EBB7 00           l2_fill_lenhi           DB 0
  31+ EBB8 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY, DMA_WR2_P2INC_MEMORY, DMA_WR4_CONT_MODE
  32+ EBBB 00 00        l2_fill_target          DB $00, $00
  33+ EBBD CF 87                                DB DMA_LOAD, DMA_ENABLE
  34+ EBBF              l2_bren_cmd_len	        EQU $ - l2_fill_line
  35+ EBBF
  36+ EBBF 32 AE EB     l2_fill_dma:            ld		(l2_fillValue),a                                 ; T=13     ;
  37+ EBC2 22 BB EB                             ld      (l2_fill_target),hl
  38+ EBC5 21 AF EB     .write_dma:             ld 		hl, l2_fill_line                                  ;          ;
  39+ EBC8 06 10                                ld 		b, l2_bren_cmd_len                                ;
  40+ EBCA 0E 6B                                ld		c,IO_DATAGEAR_DMA_PORT                            ;
  41+ EBCC ED B3                                otir                                                      ;
  42+ EBCE C9                                   ret
  43+ EBCF
  44+ EBCF              ; to find a point Y1 along a line X0Y0 to X2Y2
  45+ EBCF              ; DX = X2-X0, DY = Y2-Y0, D = DX/DY, X1 = X0+ ((Y1-Y0)*DX)
  46+ EBCF              ; will need 16.8 24 bit maths for DX DY unless we scale down and do a muliplier up
  47+ EBCF              ; so we could do DX = X2-X0, scale to 8.8  ... Note this will fail for extrmem near vertical or horizontal angles
  48+ EBCF              ;                DY = Y2-Y0, scale to 8.8  ... could we use an octlet lookup table?
  49+ EBCF              ;                D  = DX/DY which would give us an 8.2 proportion
  50+ EBCF              ; a look up table would not work for calc of DX DY but we could use a log table and anti log to simplify to add/subtract
  51+ EBCF              ; need a version of this that counts down to a trigger Y axis + 1, ideallign using DX DY if possible
  52+ EBCF              ; We may be able to use the flat top/flat botttom and pick up a calculated value 0nce it hits Y2?
  53+ EBCF              ; Yes logirithm table will work, need to build as a decimal set optimised
  54+ EBCF              ; logically if the ship is too close it will always be too close to render so we can exclude
  55+ EBCF              ; excessivley large values for X and Y as they will either be too far off side or span the whole screen
  56+ EBCF              ; and just flood fill
  57+ EBCF              ; Thsi means we can do log maths for jsut 0 to 1024
  58+ EBCF              ; 9/11 we assume that large values will either flood fill or be straight lines
  59+ EBCF              ; so we allow a range of -256 to + 512 ,i.e. off screen by a whole additional screen
  60+ EBCF              ; then divide becomes 16 bit div 16 bit to yeild an 8.8 result. This can then be used to work out the new position
  61+ EBCF              ; so                    DE = DX (Ignoring signs for now)
  62+ EBCF              ;                       HL = DY
  63+ EBCF              ; we need L2_DX, L2_DY output is HL
  64+ EBCF              ; After workign out in excel Formulas are:
  65+ EBCF              ; incomming X0, Y0, Y1, DX , DY
  66+ EBCF              ; dY2 = Y1-Y0
  67+ EBCF              ; dXHi = DX/DY*256
  68+ EBCF              ; dxRemainder = DX-dXHi
  69+ EBCF              ; dXRemainder = TRUNC((dxRemainder)/DY)*256
  70+ EBCF              ; Integer component = dY2 * dXHi /256
  71+ EBCF              ; Adj     component = DY2 * dXRemainder /256
  72+ EBCF              ; total = Integer + Adj + X0
  73+ EBCF
  74+ EBCF 00 00        l2_X0                   DW 0
  75+ EBD1 00 00        l2_Y0                   DW 0
  76+ EBD3 00 00        l2_X1                   DW 0
  77+ EBD5 00 00        l2_Y1                   DW 0
  78+ EBD7 00 00        ld_YMid                 DW 0
  79+ EBD9 00 00        l2_DX                   DW 0
  80+ EBDB 00 00        l2_DY                   DW 0
  81+ EBDD 00 00        l2_Error                DW 0
  82+ EBDF 00 00        l2_E2                   DW 0
  83+ EBE1 00 00        l2_dY2                  DW 0
  84+ EBE3 00 00        ld_dxHi                 DW 0
  85+ EBE5 00 00        l2_dxRemainder          DW 0
  86+ EBE7 00 00        l2_dxRemainder2         DW 0
  87+ EBE9 00 00        l2_dXRemainderAdj       DW 0
  88+ EBEB 00 00        l2_integer              DW 0
  89+ EBED 00 00        l2_integer2             DW 0
  90+ EBEF
  91+ EBEF 2A D9 EB     ScaleDXDY:              ld      hl,(l2_DX)
  92+ EBF2 ED 5B DB EB                          ld      de,(l2_DY)
  93+ EBF6 7C           .ScaleLoop:             ld      a,h
  94+ EBF7 B2                                   or      d
  95+ EBF8 28 0B                                jr      z,.ScaleDone
  96+ EBFA                                      ShiftHLRight1
  96+ EBFA CB 3C       >               srl h
  96+ EBFC CB 1D       >               rr  l
  97+ EBFE                                      ShiftDERight1
  97+ EBFE CB 3A       >               srl d
  97+ EC00 CB 1B       >               rr  e
  98+ EC02 C3 F6 EB                             jp      .ScaleLoop
  99+ EC05 22 D9 EB     .ScaleDone:             ld      (l2_DX),hl
 100+ EC08 ED 53 DB EB                          ld      (l2_DY),de
 101+ EC0C C9                                   ret
 102+ EC0D
 103+ EC0D 2A D3 EB     HLEquMidX:              ld      hl,(l2_X1)
 104+ EC10 ED 5B CF EB                          ld      de,(l2_X0)
 105+ EC14                                      ClearCarryFlag
 105+ EC14 B7          >                        or a
 106+ EC15 ED 52                                sbc     hl,de
 107+ EC17 22 D9 EB                             ld      (l2_DX),hl
 108+ EC1A 2A D5 EB                             ld      hl,(l2_Y1)
 109+ EC1D ED 5B D1 EB                          ld      de,(l2_Y0)
 110+ EC21                                      ClearCarryFlag
 110+ EC21 B7          >                        or a
 111+ EC22 ED 52                                sbc     hl,de
 112+ EC24 22 DB EB                             ld      (l2_DY),hl
 113+ EC27                                      ;break
 114+ EC27 CD EF EB                             call    ScaleDXDY
 115+ EC2A 2A D7 EB                             ld      hl,(ld_YMid)
 116+ EC2D                                      ClearCarryFlag
 116+ EC2D B7          >                        or a
 117+ EC2E ED 52                                sbc     hl,de
 118+ EC30 22 E1 EB                             ld      (l2_dY2),hl
 119+ EC33 ED 4B D9 EB                          ld      bc,(l2_DX)          ; dXHi(DE)= DX/DY*256
 120+ EC37 ED 5B DB EB                          ld      de,(l2_DY)          ; .
 121+ EC3B DD 62 DD 6B                          ld      ix,de               ; .
 122+ EC3F E5 FD E1                             ld      iy,hl               ; .
 123+ EC42              ;                       BC = DX/DY as 8.8           ; .
 124+ EC42 CD D4 70                             call    BC_Div_DE; DEequDEDivBC; DE is the result HL is the remainder
 125+ EC45 78                                   ld      a,b                 ; if DE is 8 bit only
 126+ EC46 A7                                   and     a                   ; .
 127+ EC47 28 06                                jr      z,.LT255            ; goto LT255
 128+ EC49 01 FF FF                             ld      bc,$FFFF            ; else set BC to $FFFF
 129+ EC4C C3 86 EC                             jp      .DoneCalc           ; .
 130+ EC4F ED 43 E3 EB  .LT255:                 ld      (ld_dxHi),bc        ;
 131+ EC53 22 E5 EB                             ld      (l2_dxRemainder),hl ; dxRemainder = DX-dXHi
 132+ EC56              .CalcIntegerComponent:  ;break
 133+ EC56 2A E1 EB                             ld      hl,(l2_dY2)         ; Integer component = dY2 * dXHi /256
 134+ EC59 ED 5B E3 EB                          ld      de,(ld_dxHi)        ; .
 135+ EC5D CD 6C 6C                             call    fixedS78_mulu; replaces DEHLequDEmulHL      ; .
 136+ EC60 ED 53 EB EB                          ld      (l2_integer),de     ; .
 137+ EC64 22 ED EB                             ld      (l2_integer2),hl    ; .
 138+ EC67 ED 4B E5 EB  .CalcRemainderFraction: ld      bc,(l2_dxRemainder) ; dXRemainder = TRUNC((dxRemainder)/DY)*256
 139+ EC6B ED 5B DB EB                          ld      de,(l2_DY)          ; .
 140+ EC6F CD D4 70                             call    BC_Div_DE           ; BC, remainder in HL
 141+ EC72 ED 43 E9 EB                          ld      (l2_dXRemainderAdj),bc
 142+ EC76 22 E7 EB                             ld      (l2_dxRemainder2),hl
 143+ EC79 2A E1 EB     .CalcAdjustment:        ld      hl,(l2_dY2)         ; Adj component = DY2 * dXRemainder /256
 144+ EC7C 50 59                                ld      de,bc               ;
 145+ EC7E CD 6C 6C                             call    fixedS78_mulu; replaces DEHLequDEmulHL      ;
 146+ EC81 2A EB EB                             ld      hl,(l2_integer)
 147+ EC84 19                                   add     hl,de
 148+ EC85 C9                                   ret
 149+ EC86
 150+ EC86
 151+ EC86              ;                       HL = (DE * B) /256
 152+ EC86 C5           .DoneCalc:              push    bc
 153+ EC87 58                                   ld      e,b
 154+ EC88 DD E5 E1                             ld      hl,ix
 155+ EC8B CD E5 6B                             call AHLequHLmulE
 156+ EC8E 6C                                   ld l,h
 157+ EC8F 67                                   ld h,a
 158+ EC90 E5 DD E1                             ld      ix,hl
 159+ EC93              ;                       DE = (DE * C) /256          ld e,c call AHLequHLmulE,ld l,h, ld h,a
 160+ EC93 C1                                   pop     bc
 161+ EC94 59                                   ld      e,c
 162+ EC95 FD E5 E1                             ld      hl,iy
 163+ EC98 CD E5 6B                             call AHLequHLmulE
 164+ EC9B 6C                                   ld l,h
 165+ EC9C 67                                   ld h,a
 166+ EC9D              ;                       HL + = DE
 167+ EC9D DD 54 DD 5D                          ld      de,ix
 168+ ECA1 19                                   add     hl,de
 169+ ECA2              ;                       HL + + X0
 170+ ECA2 ED 5B CF EB                          ld      de,(l2_X0)
 171+ ECA6 19                                   add     hl,de
 172+ ECA7 C9                                   ret
 173+ ECA8
 174+ ECA8
 175+ ECA8
 176+ ECA8
 177+ ECA8              ;; Need optimisation for vertical line and horizonal
 178+ ECA8              int_bren_save_Array1Low:
 179+ ECA8 3E FF                                ld      a,$FF
 180+ ECAA 21 D0 E8                             ld      hl,l2targetArray1   ; L2targetArray2 Population
 181+ ECAD CD BF EB                             call    l2_fill_dma
 182+ ECB0 3E DA                                ld      a,OPCODE_JpCnn
 183+ ECB2 21 D0 E8                             ld      hl,l2targetArray1   ; L2targetArray2 Population
 184+ ECB5 C3 E3 EC                             jp      int_bren_save_Array ;
 185+ ECB8              int_bren_save_Array1High:
 186+ ECB8                                      ZeroA
 186+ ECB8 AF          >                        xor a
 187+ ECB9 21 D0 E8                             ld      hl,l2targetArray1   ; L2targetArray2 Population
 188+ ECBC CD BF EB                             call    l2_fill_dma
 189+ ECBF 3E D2                                ld      a,OPCODE_JpNCnn
 190+ ECC1 21 D0 E8                             ld      hl,l2targetArray1   ; L2targetArray2 Population
 191+ ECC4 C3 E3 EC                             jp      int_bren_save_Array ;
 192+ ECC7              int_bren_save_Array2Low:
 193+ ECC7 3E FF                                ld      a,$FF
 194+ ECC9 21 D0 E9                             ld      hl,l2targetArray2   ; L2targetArray2 Population
 195+ ECCC CD BF EB                             call    l2_fill_dma
 196+ ECCF 3E DA                                ld      a,OPCODE_JpCnn
 197+ ECD1 21 D0 E9                             ld      hl,l2targetArray2   ; L2targetArray2 Population
 198+ ECD4 C3 E3 EC                             jp      int_bren_save_Array ;
 199+ ECD7              int_bren_save_Array2High:
 200+ ECD7                                      ZeroA
 200+ ECD7 AF          >                        xor a
 201+ ECD8 21 D0 E9                             ld      hl,l2targetArray2   ; L2targetArray2 Population
 202+ ECDB CD BF EB                             call    l2_fill_dma
 203+ ECDE 21 D0 E9                             ld      hl,l2targetArray2   ; L2targetArray2 Population
 204+ ECE1 3E D2                                ld      a,OPCODE_JpNCnn
 205+ ECE3              ; Uses HL DE
 206+ ECE3              ; Note this works out the last position for each point, not any intermediate
 207+ ECE3              ; so we need a version that plots lowest for left line & highest for right line
 208+ ECE3 22 6F ED     int_bren_save_Array:    ld      (.TargetArrayAddr+2),hl
 209+ ECE6 32 80 ED                             ld      (.TargetJump),a
 210+ ECE9 2A D3 EB                             ld      hl,(l2_X1)          ; if X0 < X1
 211+ ECEC ED 5B CF EB                          ld      de,(l2_X0)          ; calculate SX DX
 212+ ECF0              ; --- dx = abs(x1 - x0) & set up SX
 213+ ECF0                                      ClearCarryFlag              ;
 213+ ECF0 B7          >                        or a
 214+ ECF1 ED 52                                sbc     hl,de               ;
 215+ ECF3 CB 7C                                bit     7,h                 ;
 216+ ECF5 28 0E                                jr      z,.DXPositive       ;
 217+ ECF7              .DXNegative:            NegHL                       ;
 217+ ECF7 AF          >                    xor a
 217+ ECF8 95          >                    sub l
 217+ ECF9 6F          >                    ld l,a
 217+ ECFA 9F          >                    sbc a,a
 217+ ECFB 94          >                    sub h
 217+ ECFC 67          >                    ld h,a
 218+ ECFD                                      SetDecrement .UpdateX0Operation
 218+ ECFD 3E 1B       >                        ld      a,OPCODE_DecDE
 218+ ECFF 32 D0 ED    >                        ld      (.UpdateX0Operation),a
 219+ ED02 C3 0A ED                             jp      .DoneCalcDx         ;
 220+ ED05              .DXPositive:            SetIncrement .UpdateX0Operation
 220+ ED05 3E 13       >                        ld      a,OPCODE_IncDE
 220+ ED07 32 D0 ED    >                        ld      (.UpdateX0Operation),a
 221+ ED0A 22 D9 EB     .DoneCalcDx:            ld      (l2_DX),hl          ;
 222+ ED0D ED 5B CF EB                          ld      de,(l2_X0)          ; fetch in X0 so we can exx
 223+ ED11 ED 4B D3 EB                          ld      bc,(l2_X1)          ; and also X1
 224+ ED15 D9                                   exx                         ; ++now hl' = DX, DE'=X0, BC' = X1
 225+ ED16              ; --- dy = -abs(y1 - y0) & set up SY
 226+ ED16 2A D5 EB     .CalcDY:                ld      hl,(l2_Y1)          ; If Y1 < Y1
 227+ ED19 ED 5B D1 EB                          ld      de,(l2_Y0)          ; calculate SY DY
 228+ ED1D                                      ClearCarryFlag              ;
 228+ ED1D B7          >                        or a
 229+ ED1E ED 52                                sbc     hl,de               ;
 230+ ED20 CB 7C                                bit     7,h                 ;
 231+ ED22 28 08                                jr      z,.DYPositive       ;
 232+ ED24              .DYNegative:            SetDecrement .UpdateY0Operation
 232+ ED24 3E 1B       >                        ld      a,OPCODE_DecDE
 232+ ED26 32 07 EE    >                        ld      (.UpdateY0Operation),a
 233+ ED29 C3 0A ED                             jp      .DoneCalcDx         ;
 234+ ED2C              .DYPositive:            NegHL                       ;
 234+ ED2C AF          >                    xor a
 234+ ED2D 95          >                    sub l
 234+ ED2E 6F          >                    ld l,a
 234+ ED2F 9F          >                    sbc a,a
 234+ ED30 94          >                    sub h
 234+ ED31 67          >                    ld h,a
 235+ ED32                                      SetIncrement .UpdateY0Operation
 235+ ED32 3E 13       >                        ld      a,OPCODE_IncDE
 235+ ED34 32 07 EE    >                        ld      (.UpdateY0Operation),a
 236+ ED37 22 DB EB     .DoneCalcDy:            ld      (l2_DY),hl
 237+ ED3A ED 5B D1 EB                          ld      de,(l2_Y0)          ; fetch in X0
 238+ ED3E ED 4B D5 EB                          ld      bc,(l2_Y1)          ; now hl = DY, DE=Y0, BC = Y1
 239+ ED42              ; ---   error = dx + dy >> at this point hl' = DX, DE'=X0, BC' = X1 and hl = DY, DE=Y0, BC = Y1
 240+ ED42 E5 FD E1     .CalcError:             ld      iy,hl               ; fetch DY into IY
 241+ ED45 D9                                   exx                         ; ++now looking at DX data set and DY in alternate
 242+ ED46 EB                                   ex      de,hl               ; quickly flip over de and to support add instruction
 243+ ED47 FD 19                                add     iy,de               ; we have set up IY as L2_Error
 244+ ED49 EB                                   ex      de,hl
 245+ ED4A FD 22 DD EB                          ld      (l2_Error),iy
 246+ ED4E              ; --- While True        >> at this point we are looing at DX and need to consider state at iteration loop
 247+ ED4E D9           .CalcLoop:              exx                         ; ++now looking at DY data set and DX in alternate
 248+ ED4F                                      ;ld      hl,(l2_X0)         ; get X0 and Y0
 249+ ED4F              ; --- PLOT X0, Y0       >> now looking at DY data set and DX in alternate
 250+ ED4F              .CheckYRange:           ;ld      de,(l2_Y0)
 251+ ED4F 7A                                   ld      a,d                 ; if Y0 > 127
 252+ ED50 A7                                   and     a                   ; or Y0 is negative
 253+ ED51 20 35                                jr      nz,.YOutOfRange     ; then we can skip the plot
 254+ ED53 7B                                   ld      a,e                 ;
 255+ ED54 E6 80                                and     $80                 ;
 256+ ED56 20 30                                jr      nz,.YOutOfRange     ;
 257+ ED58 D9           .CheckXRange:           exx                         ; ++now looking at DX data set and DY in alternate
 258+ ED59 7A                                   ld      a,d                 ; if X0 is negative
 259+ ED5A A7                                   and     a
 260+ ED5B 28 0E                                jr      z,.XOKToPlot
 261+ ED5D E6 80                                and     $80
 262+ ED5F 28 05                                jr      z,.NotXNegative
 263+ ED61 3E 00        .XNegative:             ld      a,0                 ; if X0 <0 > 255 then clamp it
 264+ ED63 C3 6C ED                             jp      .ClipXDone          ;
 265+ ED66 3E FF        .NotXNegative:          ld      a,255               ;
 266+ ED68 C3 6C ED                             jp      .ClipXDone          ;
 267+ ED6B 7B           .XOKToPlot:             ld      a,e                 ; no clip therefore we can just use X0 as is
 268+ ED6C D9           .ClipXDone:             exx                         ; ++now looking at DY data set and DX in alternate
 269+ ED6D DD 21 D0 E8  .TargetArrayAddr:       ld      ix,l2targetArray1   ; later this will be self modifying
 270+ ED71 08                                   ex      af,af'
 271+ ED72 7B                                   ld      a,e
 272+ ED73 32 7E ED                             ld      (.TargetRead+2),a   ; Write Y0 offset to IX offset
 273+ ED76 32 86 ED                             ld      (.TargetWrite+2),a  ; Write Y0 offset to IX offset
 274+ ED79 08                                   ex      af,af'
 275+ ED7A C5                                   push    bc
 276+ ED7B 47                                   ld      b,a
 277+ ED7C DD 7E 00     .TargetRead:            ld      a,(IX+0)
 278+ ED7F B8                                   cp      b
 279+ ED80 DA 87 ED     .TargetJump:            jp      c,.SkipWrite
 280+ ED83 78                                   ld      a,b
 281+ ED84 DD 77 00     .TargetWrite:           ld      (IX+0),a            ; directly updates l2targetArray1
 282+ ED87 C1           .SkipWrite:             pop     bc
 283+ ED88              ; --- if x0 == x1 && y0 == y1 break
 284+ ED88              .YOutOfRange: ; At this point we have either plotted or its outside array range
 285+ ED88 D9                                   exx                         ; ++now looking at DX data set and DY in alternate
 286+ ED89              ;                        ld      bc,(l2_X1)
 287+ ED89              .CheckEndXY:            cpDEEquBC .CheckEndXYOK     ; de will equal X0 still by here
 287+ ED89 7A          >                        ld      a,d
 287+ ED8A B8          >                        cp      b
 287+ ED8B C2 93 ED    >                        jp      nz, .CheckEndXYOK
 287+ ED8E 7B          >                        ld      a,e
 287+ ED8F B9          >                        cp      c
 287+ ED90             >.NoTheSame:
 288+ ED90 C2 9D ED                             jp      nz,.x0x1Differ
 289+ ED93 D9           .CheckEndXYOK:          exx                         ; ++ in this branch in this branchnow looking at DY data set and DX in alternate
 290+ ED94              ;                        ld      bc,(l2_Y1)
 291+ ED94                                      cpDEEquBC  .x0x1Differ      ; de will equal Y0 still by here
 291+ ED94 7A          >                        ld      a,d
 291+ ED95 B8          >                        cp      b
 291+ ED96 C2 9D ED    >                        jp      nz, .x0x1Differ
 291+ ED99 7B          >                        ld      a,e
 291+ ED9A B9          >                        cp      c
 291+ ED9B             >.NoTheSame:
 292+ ED9B D9                                   exx                         ; ++ in this branch now looking at DX data set and DY in alternate
 293+ ED9C C8                                   ret     z                   ; if they are both the same we are done
 294+ ED9D              .x0x1Differ:                                        ; by this point we could be looking at DX on all branches
 295+ ED9D              ; --- e2 = 2 * error
 296+ ED9D D9           .SetError2:             exx                         ; ++now looking at DY data set and DX in alternate
 297+ ED9E E5 D5                                push    hl,,de              ; save HL
 298+ EDA0 EB                                   ex      de,hl               ; de = DY; could futher optimise to check DY>E2 and reduce instruction count
 299+ EDA1 FD E5 E1                             ld      hl,iy;(l2_Error)       ; e2 = 2 * error
 300+ EDA4 29                                   add     hl,hl               ; .
 301+ EDA5 22 DF EB                             ld      (l2_E2),hl          ; .
 302+ EDA8                                      ; before here we are looking at DY
 303+ EDA8              ; --- if e2 >= dy
 304+ EDA8 CD EA 73     .CheckE2gteDY:          call    compare16HLDE       ; .
 305+ EDAB D1 E1                                pop     hl,,de              ; before jumps get HL back
 306+ EDAD EA B6 ED                             jp      pe, .E2DyParitySet  ; Jump looking at DY
 307+ EDB0 FA D2 ED                             jp      m,  .E2ltDY         ; Jump looking at DY to get here overflow clear, so if m is set then HL<DE
 308+ EDB3 C3 B9 ED                             jp      .E2gteDY            ; Jump looking at DY
 309+ EDB6              .E2DyParitySet:         ; entering here looking at DY
 310+ EDB6 F2 D2 ED                             jp      p,  .E2ltDY         ; Jump looking at DY if pe is set, then if sign is clear HL<DE
 311+ EDB9              ; --- if x0 == x1 break
 312+ EDB9 D9           .E2gteDY:               exx                         ; ++ in this branch now looking at DX data set and DY in alternate
 313+ EDBA                                      cpDEEquBC .ErrorUpdateDY    ;      if x0 == x1 break
 313+ EDBA 7A          >                        ld      a,d
 313+ EDBB B8          >                        cp      b
 313+ EDBC C2 C2 ED    >                        jp      nz, .ErrorUpdateDY
 313+ EDBF 7B          >                        ld      a,e
 313+ EDC0 B9          >                        cp      c
 313+ EDC1             >.NoTheSame:
 314+ EDC1 C8                                   ret     z                   ;      .
 315+ EDC2              ; --- error = error + dy
 316+ EDC2 D9           .ErrorUpdateDY:         exx                         ; if we get here we are looking at DY data set and DX in alternate
 317+ EDC3 E5 D5                                push    hl,,de              ; save HL
 318+ EDC5 EB                                   ex      de,hl               ; de = DY
 319+ EDC6 FD E5 E1                             ld      hl,iy;(l2_Error)       ;      error = error + dy
 320+ EDC9 19                                   add     hl,de               ;      .
 321+ EDCA E5 FD E1                             ld      iy,hl;(l2_Error),hl       ;      .
 322+ EDCD D1 E1                                pop     hl,,de
 323+ EDCF              ; --- x0 = x0 + sx
 324+ EDCF D9           .UpdateX0:              exx                         ; now back looking at DX data set and DY in alternate
 325+ EDD0 00           .UpdateX0Operation:     nop                         ;      x0 = x0 +/- sx
 326+ EDD1 D9                                   exx                         ; correction on this brach so we are looking at DY
 327+ EDD2              .E2ltDY:                ; entering here, looking at DY in all branches
 328+ EDD2              ; --- if e2 <= dx
 329+ EDD2 D9           .CheckE2lteDX:          exx                         ; we want to look at DX
 330+ EDD3 E5 D5                                push    hl,,de
 331+ EDD5 EB                                   ex      de,hl               ; de = l2_DX
 332+ EDD6 2A DF EB                             ld      hl,(l2_E2)          ; if e2 <= dx
 333+ EDD9              ;                        ld      de,(l2_DX)          ; as we can't do skip on e2>dx
 334+ EDD9 CD EA 73                             call    compare16HLDE       ; we will jump based on e2 <= dx
 335+ EDDC D1 E1                                pop     hl,,de              ; recover saved HL DE
 336+ EDDE CA F0 ED                             jp      z, .E2lteDX         ; Jump looking at DX
 337+ EDE1 EA EA ED                             jp      pe, .E2DxParitySet  ; Jump looking at DX
 338+ EDE4 FA F0 ED                             jp      m,  .E2lteDX        ; Jump looking at DX : to get here overflow clear, so if m is set then HL<DE
 339+ EDE7 C3 09 EE                             jp      .E2gteDx            ; Jump looking at DX
 340+ EDEA F2 F0 ED     .E2DxParitySet:         jp      p,  .E2lteDX        ; Jump looking at DX
 341+ EDED C3 09 EE                             jp      .E2gteDx            ; Jump looking at DX
 342+ EDF0              ; ---  if y0 == y1 break
 343+ EDF0              .E2lteDX:               ; Entry looking at DX
 344+ EDF0 D9                                   exx                         ;      in branch looking at DY
 345+ EDF1                                      cpDEEquBC .ErrorUpdateDX    ;      .
 345+ EDF1 7A          >                        ld      a,d
 345+ EDF2 B8          >                        cp      b
 345+ EDF3 C2 FA ED    >                        jp      nz, .ErrorUpdateDX
 345+ EDF6 7B          >                        ld      a,e
 345+ EDF7 B9          >                        cp      c
 345+ EDF8             >.NoTheSame:
 346+ EDF8 D9                                   exx                         ;      in branch looking at DX
 347+ EDF9 C8                                   ret     z                   ;      .
 348+ EDFA              ; --- error = error + dx
 349+ EDFA              .ErrorUpdateDX:         ; at this point will be looking at DX
 350+ EDFA E5 D5                                push    hl,,de
 351+ EDFC EB                                   ex      de,hl               ;      de = DY
 352+ EDFD FD E5 E1                             ld      hl,iy;(l2_Error)       ;      error = error + dx
 353+ EE00 19                                   add     hl,de               ;      .
 354+ EE01 E5 FD E1                             ld      iy,hl;(l2_Error),hl       ;      .
 355+ EE04 D1 E1                                pop     hl,,de
 356+ EE06              ; --- y0 = y0 + sy
 357+ EE06 D9           .UpdateY0:              exx                         ;      in this branch we are looking at DY
 358+ EE07 00           .UpdateY0Operation:     nop                         ;      y0 = y0 + sy
 359+ EE08 D9                                   exx                         ;      in this branch we are looking at
 360+ EE09              ; --- Loop
 361+ EE09              .E2gteDx:               ; at this point will be looking at DX again
 362+ EE09 C3 4E ED                             jp      .CalcLoop           ; repeat until we have a return
 363+ EE0C
# file closed: ../../Layer2Graphics/int_bren_save.asm
 712  EE0C                  ;INCLUDE "../../Layer2Graphics/layer2_plot_circle.asm"
 713  EE0C                  ;INCLUDE "../../Layer2Graphics/layer2_plot_circle_fill.asm"
 714  EE0C                  INCLUDE "../../Layer2Graphics/BBCEliteDirectMappingLL118.asm"
# file opened: ../../Layer2Graphics/BBCEliteDirectMappingLL118.asm
   1+ EE0C                              IFDEF DEBUG_LL122_DIRECT
   2+ EE0C ~                                    ; (Y X) = (S R) * Q
   3+ EE0C ~                                    ; yxregpair = (20 * 140)/256 = 16d 10h
   4+ EE0C ~            Debug_LL122_6502:       ld      hl, 20
   4+ EE0C ~             ld      (SRvarPair),hl
   5+ EE0C ~                                    ld      a,  140
   5+ EE0C ~             ld      (Qvar),a
   6+ EE0C ~                                    call    LL122_6502  ; -10                               >> PASS
   7+ EE0C ~                                    ;break
   8+ EE0C ~                                    ; yxregpair = 20 * 140 = 17d 11h
   9+ EE0C ~                                    ld      hl, 20
   9+ EE0C ~             ld      (SRvarPair),hl
  10+ EE0C ~                                    ld      a,  230
  10+ EE0C ~             ld      (Qvar),a
  11+ EE0C ~                                    call    LL122_6502  ; -17                               >> PASS
  12+ EE0C ~                                    ret
  13+ EE0C                              ENDIF
  14+ EE0C
  15+ EE0C              ;--  The following calculates: (Y X) = (S R) / Q using the same shift-and-subtract algorithm that's documented in TIS2
  16+ EE0C
  17+ EE0C                              IFDEF DEBUG_LL121_DIRECT
  18+ EE0C ~                                    ; (Y X) = (S R) / Q
  19+ EE0C ~                                    ; yxregpair = 20 / 140 = 20*256 / 140 = 36d, 24h
  20+ EE0C ~            Debug_LL121_6502:       ld      hl, 20
  20+ EE0C ~             ld      (SRvarPair),hl
  21+ EE0C ~                                    ld      a,  140
  21+ EE0C ~             ld      (Qvar),a
  22+ EE0C ~                                    call    LL121_6502  ; -36                               >> PASS
  23+ EE0C ~                                    ;break
  24+ EE0C ~                                    ; yxregpair =  20 / 140 = 20*256 / 230 = 22d, 11h
  25+ EE0C ~                                    ld      hl, 20
  25+ EE0C ~             ld      (SRvarPair),hl
  26+ EE0C ~                                    ld      a,  230
  26+ EE0C ~             ld      (Qvar),a
  27+ EE0C ~                                    call    LL121_6502  ; -22                               >> PASS
  28+ EE0C ~                                    ;break
  29+ EE0C ~                                    ret
  30+ EE0C                              ENDIF
  31+ EE0C
  32+ EE0C                              IFDEF DEBUG_LL129_DIRECT
  33+ EE0C ~            Debug_LL129_6502:       ld      hl,-20
  33+ EE0C ~             ld     (SRvarPair),hl
  34+ EE0C ~                                    ld      a, 0
  34+ EE0C ~             ld     (XX12p3),a
  35+ EE0C ~                                    ld      a, 10
  35+ EE0C ~             ld     (XX12p2),a
  36+ EE0C ~                                    call    LL129_6502  ; expect q = 10, a = $FF SR = 20    >> PASS
  37+ EE0C ~                                    ;break
  38+ EE0C ~                                    ld      hl,20
  38+ EE0C ~             ld     (SRvarPair),hl
  39+ EE0C ~                                    ld      a, 0
  39+ EE0C ~             ld     (XX12p3),a
  40+ EE0C ~                                    ld      a, 40
  40+ EE0C ~             ld     (XX12p2),a
  41+ EE0C ~                                    call    LL129_6502  ; expect q = 40, a = 00 SR = 20     >> PASS
  42+ EE0C ~                                    ;break
  43+ EE0C ~                                    ld      hl,40
  43+ EE0C ~             ld     (SRvarPair),hl
  44+ EE0C ~                                    ld      a, $FF
  44+ EE0C ~             ld     (XX12p3),a
  45+ EE0C ~                                    ld      a, 40
  45+ EE0C ~             ld     (XX12p2),a
  46+ EE0C ~                                    call    LL129_6502  ; expect q = 40, a = $FF SR = 40    >> PASS
  47+ EE0C ~                                    ;break
  48+ EE0C ~                                    ld      hl,-40
  48+ EE0C ~             ld     (SRvarPair),hl
  49+ EE0C ~                                    ld      a, $FF
  49+ EE0C ~             ld     (XX12p3),a
  50+ EE0C ~                                    ld      a, 40
  50+ EE0C ~             ld     (XX12p2),a
  51+ EE0C ~                                    call    LL129_6502  ; expect q = 40, a = 00 SR = 40     >> PASS
  52+ EE0C ~                                    ;break
  53+ EE0C ~                                    ret
  54+ EE0C                              ENDIF
  55+ EE0C
  56+ EE0C                              IFDEF DEBUG_LL120_DIRECT
  57+ EE0C ~            Debug_LL120_6502:       ld      a,0
  57+ EE0C ~             ld      (Tvar),a                  ; SLOPE 0 so calcualte YX = S X1lo * XX12+2
  58+ EE0C ~                                    ld      hl,20
  58+ EE0C ~             ld a,h
  58+ EE0C ~              ld (Svar),a
  58+ EE0C ~              ld a,l
  58+ EE0C ~              ld (XX1510),a  ; S x1lo = 20
  59+ EE0C ~                                    ld      a,140
  59+ EE0C ~             ld      (XX12p2),a                ; XX12+2  140, gradient 0.546875
  60+ EE0C ~                                    ld      a,0
  60+ EE0C ~             ld      (XX12p3),a                ; SLOPE DIRECTION so -ve result
  61+ EE0C ~                                    ; post LL129 Q = 140 a = 00  SR YX = (20 * 140) /256 * -1 = -10
  62+ EE0C ~                                    call    LL120_6502  ; Expect mulitply so (Y X) -10      >> PASS
  63+ EE0C ~                                    ;break
  64+ EE0C ~                                    ld      a,0
  64+ EE0C ~             ld      (Tvar),a                  ; SLOPE 0 so calcualte YX = S X1lo * XX12+2
  65+ EE0C ~                                    ld      hl,20
  65+ EE0C ~             ld a,h
  65+ EE0C ~              ld (Svar),a
  65+ EE0C ~              ld a,l
  65+ EE0C ~              ld (XX1510),a  ; S x1lo = 20
  66+ EE0C ~                                    ld      a,140
  66+ EE0C ~             ld      (XX12p2),a                ; XX12+2 140, gradient 0.546875
  67+ EE0C ~                                    ld      a,$FF
  67+ EE0C ~             ld      (XX12p3),a                ; sLOPE DIRECTION so +ve result
  68+ EE0C ~                                    ; post LL129 Q = 140 a = FF  SR = 20  YX = (20 * 140) /256 = 10
  69+ EE0C ~                                    call    LL120_6502  ; Expect / so (Y X)10                   >> PASS
  70+ EE0C ~                                    ;break
  71+ EE0C ~                                    ld      a,$FF
  71+ EE0C ~             ld      (Tvar),a                  ; SLOPE <> 0 so calcualte YX = S X1lo / XX12+2
  72+ EE0C ~                                    ld      hl,20
  72+ EE0C ~             ld a,h
  72+ EE0C ~              ld (Svar),a
  72+ EE0C ~              ld a,l
  72+ EE0C ~              ld (XX1510),a  ; S x1lo = 20
  73+ EE0C ~                                    ld      a,140
  73+ EE0C ~             ld      (XX12p2),a                ; XX12+2 140, gradient 0.546875
  74+ EE0C ~                                    ld      a,$00
  74+ EE0C ~             ld      (XX12p3),a                ; sLOPE DIRECTION  so -ve result
  75+ EE0C ~                                    ; post LL129 Q = 140 a = 00  SR = 20  YX = (20 *256 / 140) = -36
  76+ EE0C ~                                    call    LL120_6502  ; Expect / so (Y X)-36
  77+ EE0C ~                                    ld      a,$FF
  77+ EE0C ~             ld      (Tvar),a                  ; SLOPE <> 0 so calcualte YX = S X1lo / XX12+2
  78+ EE0C ~                                    ld      hl,20
  78+ EE0C ~             ld a,h
  78+ EE0C ~              ld (Svar),a
  78+ EE0C ~              ld a,l
  78+ EE0C ~              ld (XX1510),a  ; S x1lo = 20
  79+ EE0C ~                                    ld      a,140
  79+ EE0C ~             ld      (XX12p2),a                ; XX12+2 140, gradient 0.546875
  80+ EE0C ~                                    ld      a,$FF
  80+ EE0C ~             ld      (XX12p3),a                ; sLOPE DIRECTION  so +ve result
  81+ EE0C ~                                    ; post LL129 Q = 140 a = 00 SR = 20 YX = (20 *256 / 140) = 36
  82+ EE0C ~                                    call    LL120_6502  ; Expect / so (Y X)  36                   >> PASS
  83+ EE0C ~                                    ret
  84+ EE0C                              ENDIF
  85+ EE0C              ;----------------------------------------------------------------------------------------------------------------------------
  86+ EE0C              ;-- Calculate the following:
  87+ EE0C              ;--         * If T = 0, this is a shallow slope, so calculate (Y X) = (S R) / XX12+2
  88+ EE0C              ;--         * If T <> 0, this is a steep slope, so calculate (Y X) = (S R) * XX12+2
  89+ EE0C              ;--             giving (Y X) the opposite sign to the slope direction in XX12+3.
  90+ EE0C                              IFDEF DEBUG_LL123_DIRECT
  91+ EE0C ~            Debug_LL123_6502:       ld      a,$00
  91+ EE0C ~             ld      (Tvar),a                  ; SLOPE 0 (Y X) = (S R) / XX12+2
  92+ EE0C ~                                    ld      hl,20
  92+ EE0C ~             ld      (SRvarPair),hl
  93+ EE0C ~                                    ld      a,140
  93+ EE0C ~             ld      (XX12p2),a                ; XX12+2 gradient 0.546875
  94+ EE0C ~                                    ld      a,0
  94+ EE0C ~             ld      (XX12p3),a                ; sLOPE DIRECTION
  95+ EE0C ~                                    call    LL123_6502  ; Expect * so (Y X)-36 = (20 / 140 ) * 256 * -1 PASS
  96+ EE0C ~                                    ;break
  97+ EE0C ~                                    ld      a,$00
  97+ EE0C ~             ld      (Tvar),a                  ; SLOPE 0 (Y X) = (S R) / XX12+2
  98+ EE0C ~                                    ld      hl,20
  98+ EE0C ~             ld      (SRvarPair),hl
  99+ EE0C ~                                    ld      a,140
  99+ EE0C ~             ld      (XX12p2),a                ; XX12+2 gradient 0.546875
 100+ EE0C ~                                    ld      a,$FF
 100+ EE0C ~             ld      (XX12p3),a                ; sLOPE DIRECTION
 101+ EE0C ~                                    call    LL123_6502  ; Expect * so (Y X)36 = (20 / 140 ) * 256  PASS
 102+ EE0C ~                                    ;break
 103+ EE0C ~                                    ld      a,$FF
 103+ EE0C ~             ld      (Tvar),a                  ; SLOPE <> 0 (Y X) = (S R) * XX12+2
 104+ EE0C ~                                    ld      hl,20
 104+ EE0C ~             ld      (SRvarPair),hl
 105+ EE0C ~                                    ld      a,140
 105+ EE0C ~             ld      (XX12p2),a                ; XX12+2 gradient 0.546875
 106+ EE0C ~                                    ld      a,$00
 106+ EE0C ~             ld      (XX12p3),a                ; sLOPE DIRECTION
 107+ EE0C ~                                    call    LL123_6502  ; Expect / so (Y X)-10 (20 * 140 ) / 256 * -1 PASS
 108+ EE0C ~                                    ld      a,$FF
 108+ EE0C ~             ld      (Tvar),a                  ; SLOPE <> 0 (Y X) = (S R) * XX12+2
 109+ EE0C ~                                    ld      hl,20
 109+ EE0C ~             ld      (SRvarPair),hl
 110+ EE0C ~                                    ld      a,140
 110+ EE0C ~             ld      (XX12p2),a                ; XX12+2 gradient 0.546875
 111+ EE0C ~                                    ld      a,$FF
 111+ EE0C ~             ld      (XX12p3),a                ; sLOPE DIRECTION
 112+ EE0C ~                                    call    LL123_6502  ; Expect / so (Y X) 10 (20 * 140 ) / 256  PASS
 113+ EE0C ~                                    ret
 114+ EE0C                              ENDIF
 115+ EE0C
 116+ EE0C                              IFDEF DEBUG_LL118_DIRECT
 117+ EE0C ~            Debug_LL118_6502:       ld      a,$FF
 117+ EE0C ~             ld      (Tvar),a                  ; SLOPE FF so steep
 118+ EE0C ~                                    ld      hl,-20
 118+ EE0C ~             ld      (XX1510),hl               ; x1 = -20
 119+ EE0C ~                                    ld      hl,-20
 119+ EE0C ~             ld      (XX1532),hl               ; y1 = -20
 120+ EE0C ~                                    ld      a,120
 120+ EE0C ~             ld      (XX12p2),a                ; XX12+2 = 120 (120/256) = 0.46875
 121+ EE0C ~                                    ld      a,0
 121+ EE0C ~             ld      (XX12p3),a                ; Slope Direction so TL to BR
 122+ EE0C ~                                    ; -20, -20 steep TL>BR, gradient 120/256: Dir -1 so
 123+ EE0C ~                                    call    LL118_6502  ; Expect * so x = 0 y =  -20 + (-20/(120/256)) = 22, x1 = 0 so stop there PASS
 124+ EE0C ~                                    ;break
 125+ EE0C ~
 126+ EE0C ~                                    ld      a,$FF
 126+ EE0C ~             ld      (Tvar),a                  ; SLOPE FF so steep
 127+ EE0C ~                                    ld      hl,-30
 127+ EE0C ~             ld      (XX1510),hl               ; x1 = -20
 128+ EE0C ~                                    ld      hl,-20
 128+ EE0C ~             ld      (XX1532),hl               ; y1 = -20
 129+ EE0C ~                                    ld      a,60
 129+ EE0C ~             ld      (XX12p2),a                ; XX12+2 = 120 (120/256) = 0.46875
 130+ EE0C ~                                    ld      a,0
 130+ EE0C ~             ld      (XX12p3),a                ; Slope Direction so TL to BR
 131+ EE0C ~                                    ; -20, -20 steep TL>BR, gradient 120/256: Dir -1 so
 132+ EE0C ~                                    call    LL118_6502  ; Expect * so 108,0  PASS (fixed carry flag issue in LL121 and re-tested LL121)
 133+ EE0C ~                                    ;break
 134+ EE0C ~
 135+ EE0C ~                                    ld      a,$0
 135+ EE0C ~             ld      (Tvar),a                  ; SLOPE FF so steep
 136+ EE0C ~                                    ld      hl,-20
 136+ EE0C ~             ld      (XX1510),hl               ; x1 = -20
 137+ EE0C ~                                    ld      hl,-20
 137+ EE0C ~             ld      (XX1532),hl               ; y1 = -20
 138+ EE0C ~                                    ld      a,60
 138+ EE0C ~             ld      (XX12p2),a                ; XX12+2 = 120 (120/256) = 0.46875
 139+ EE0C ~                                    ld      a,0
 139+ EE0C ~             ld      (XX12p3),a                ; Slope Direction so TL to BR
 140+ EE0C ~                                    ; -20, -20 steep TL>BR, gradient 120/256: Dir -1 so
 141+ EE0C ~                                    call    LL118_6502  ; Expect * so 108,0  PASS (fixed carry flag issue in LL121 and re-tested LL121)
 142+ EE0C ~                                    ;break
 143+ EE0C ~                                    ret
 144+ EE0C ~
 145+ EE0C                              ENDIF
 146+ EE0C
 147+ EE0C                              IFDEF DEBUG_LL28_6502
 148+ EE0C ~            Debug_LL28_6502:        ld      a,27
 148+ EE0C ~             ld     (Qvar),a
 149+ EE0C ~                                    ld      a,76
 150+ EE0C ~                                    call    LL28_6502   ; Expect $FF carry
 151+ EE0C ~                                    ;break
 152+ EE0C ~                                    ld      a,76
 152+ EE0C ~             ld     (Qvar),a
 153+ EE0C ~                                    ld      a,27        ; Expect 2
 154+ EE0C ~                                    call    LL28_6502
 155+ EE0C ~                                    ;break
 156+ EE0C ~                                    ld      a,200
 156+ EE0C ~             ld     (Qvar),a
 157+ EE0C ~                                    ld      a,50
 158+ EE0C ~                                    call    LL28_6502   ; Expect 4
 159+ EE0C ~                                    ;break
 160+ EE0C ~                                    ld      a,97
 160+ EE0C ~             ld     (Qvar),a
 161+ EE0C ~                                    ld      a,76
 162+ EE0C ~                                    call    LL28_6502   ; Expect 1
 163+ EE0C ~                                    ;break
 164+ EE0C ~                                    ld      a,$20
 164+ EE0C ~             ld     (Qvar),a
 165+ EE0C ~                                    ld      a,$10
 166+ EE0C ~                                    call    LL28_6502   ; Expect 1
 167+ EE0C ~                                    ;break
 168+ EE0C ~                                    ld      d,27
 169+ EE0C ~                                    ld      a,76
 170+ EE0C ~                                    call    AEquAmul256DivD
 171+ EE0C ~                                    ;break
 172+ EE0C ~                                    ld      d,76
 173+ EE0C ~                                    ld      a,27
 174+ EE0C ~                                    call    AEquAmul256DivD
 175+ EE0C ~                                    ;break
 176+ EE0C ~                                    ld      d,200
 177+ EE0C ~                                    ld      a,50
 178+ EE0C ~                                    call    AEquAmul256DivD
 179+ EE0C ~                                    ;break
 180+ EE0C ~                                    ld      d,$20
 181+ EE0C ~                                    ld      a,$10
 182+ EE0C ~                                    call    AEquAmul256DivD
 183+ EE0C ~                                    ;break
 184+ EE0C ~                                    ret
 185+ EE0C                              ENDIF
 186+ EE0C
 187+ EE0C
 188+ EE0C                              IFDEF DEBUG_LL145_6502
 189+ EE0C ~            Debug_LL145_6502:       ; ld  a,1      : ld  (UbnkLineArrayLen),a
 190+ EE0C ~                                    ; ld  hl,$0116 : ld  (UbnkLineArray),hl
 191+ EE0C ~                                    ; ld  hl,$004B : ld  (UbnkLineArray+2),hl
 192+ EE0C ~                                    ; ld  hl,$00F8 : ld  (UbnkLineArray+4),hl
 193+ EE0C ~                                    ; ld  hl,$002F : ld  (UbnkLineArray+6),hl
 194+ EE0C ~                                    ; call    DrawLinesLateClipping : ;break
 195+ EE0C ~                                    ; ld  a,1      : ld  (UbnkLineArrayLen),a
 196+ EE0C ~                                    ; ld  hl,$0033 : ld  (UbnkLineArray),hl
 197+ EE0C ~                                    ; ld  hl,$0016 : ld  (UbnkLineArray+2),hl
 198+ EE0C ~                                    ; ld  hl,$001D : ld  (UbnkLineArray+4),hl
 199+ EE0C ~                                    ; ld  hl,$FFBE : ld  (UbnkLineArray+6),hl
 200+ EE0C ~                                    ; call    DrawLinesLateClipping : ;break
 201+ EE0C ~                                    ; ld  a,1      : ld  (UbnkLineArrayLen),a
 202+ EE0C ~                                    ; ld  hl,$0055 : ld  (UbnkLineArray),hl
 203+ EE0C ~                                    ; ld  hl,$FF83 : ld  (UbnkLineArray+2),hl
 204+ EE0C ~                                    ; ld  hl,$0033 : ld  (UbnkLineArray+4),hl
 205+ EE0C ~                                    ; ld  hl,$0016 : ld  (UbnkLineArray+6),hl
 206+ EE0C ~                                    ; call    DrawLinesLateClipping :  ;break
 207+ EE0C ~
 208+ EE0C ~                                    ;ld  a,1      : ld  (UbnkLineArrayLen),a
 209+ EE0C ~                                    ;ld  hl,$00B3 : ld  (UbnkLineArray),hl
 210+ EE0C ~                                    ;ld  hl,$0054 : ld  (UbnkLineArray+2),hl
 211+ EE0C ~                                    ;ld  hl,$005d : ld  (UbnkLineArray+4),hl
 212+ EE0C ~                                    ;ld  hl,$ffd5 : ld  (UbnkLineArray+6),hl
 213+ EE0C ~                                    ;call    DrawLinesLateClipping :  ;break
 214+ EE0C ~                                    ;
 215+ EE0C ~                                    ;ld  a,1      : ld  (UbnkLineArrayLen),a
 216+ EE0C ~                                    ;ld  hl,$005d : ld  (UbnkLineArray),hl
 217+ EE0C ~                                    ;ld  hl,$ffd5 : ld  (UbnkLineArray+2),hl
 218+ EE0C ~                                    ;ld  hl,$00b9 : ld  (UbnkLineArray+4),hl
 219+ EE0C ~                                    ;ld  hl,$0028 : ld  (UbnkLineArray+6),hl
 220+ EE0C ~                                    ;call    DrawLinesLateClipping :  ;break
 221+ EE0C ~
 222+ EE0C ~                                    ld  a,1
 222+ EE0C ~              ld  (UbnkLineArrayLen),a
 223+ EE0C ~                                    ld  hl,$ffc7
 223+ EE0C ~              ld  (UbnkLineArray),hl
 224+ EE0C ~                                    ld  hl,$001a
 224+ EE0C ~              ld  (UbnkLineArray+2),hl
 225+ EE0C ~                                    ld  hl,$005d
 225+ EE0C ~              ld  (UbnkLineArray+4),hl
 226+ EE0C ~                                    ld  hl,$ffd5
 226+ EE0C ~              ld  (UbnkLineArray+6),hl
 227+ EE0C ~                                    call    DrawLinesLateClipping
 227+ EE0C ~               ;break
 228+ EE0C ~
 229+ EE0C ~                                    ;ld  a,1      : ld  (UbnkLineArrayLen),a
 230+ EE0C ~                                    ;ld  hl,$0089 : ld  (UbnkLineArray),hl
 231+ EE0C ~                                    ;ld  hl,$00e2 : ld  (UbnkLineArray+2),hl
 232+ EE0C ~                                    ;ld  hl,$fff3 : ld  (UbnkLineArray+4),hl
 233+ EE0C ~                                    ;ld  hl,$00b9 : ld  (UbnkLineArray+6),hl
 234+ EE0C ~                                    ;call    DrawLinesLateClipping :  ;break
 235+ EE0C ~
 236+ EE0C ~                                    ret
 237+ EE0C                              ENDIF
 238+ EE0C                      DEFINE DEBUG_6502_LINE_CLIPPING
 239+ EE0C                      IFDEF DEBUG_6502_LINE_CLIPPING
 240+ EE0C
 241+ EE0C 00           xX13        DB 0
 242+ EE0D 00 00        XX1510      DW 0    ; x1 as a 16-bit coordinate (x1_hi x1_lo)
 243+ EE0F 00 00        XX1532      DW 0    ; y1 as a 16-bit coordinate (y1_hi y1_lo)
 244+ EE11 00 00        XX1554      DW 0    ; x2
 245+ EE13              XX1554p1    EQU XX1554+1
 246+ EE13 00 00        XX1576      DW 0    ; y2
 247+ EE15              XX1210      EQU XX1576
 248+ EE15              XX12p1      EQU XX1210+1
 249+ EE15              XX15X1lo    EQU XX1510
 250+ EE15              XX15X1hi    EQU XX1510+1
 251+ EE15              XX15Y1lo    EQU XX1532
 252+ EE15              XX15Y1hi    EQU XX1532+1
 253+ EE15              XX15X2lo    EQU XX1554
 254+ EE15              XX15X2hi    EQU XX1554+1
 255+ EE15              XX15Y2lo    EQU XX1210
 256+ EE15              XX15Y2hi    EQU XX1210+1
 257+ EE15
 258+ EE15 00           XX12p2      DB 0    ; The line's gradient * 256 (so 1.0 = 256)
 259+ EE16 00           XX12p3      DB 0    ; The direction of slope ; + LT to BR; - TR to BL
 260+ EE17 00           XX12p4      DB 0
 261+ EE18 00           XX12p5      DB 0
 262+ EE19              Delta_x     EQU XX12p2
 263+ EE19              Delta_y     EQU XX12p4
 264+ EE19 00           Tvar        DB 0    ; The gradient of slope ; 0 if it's a shallow slope (DX > DY) ; &FF if it's a steep slope (DY > DX)
 265+ EE1A                                  ; Returns:  XX15        m         x1 as an 8-bit coordinate XX15+2               y1 as an 8-bit coordinate
 266+ EE1A 00           Qvar        DB 0
 267+ EE1B 00           Rvar        DB 0    ; general purpose for calcs  Paired with S must be done this way round for SUBHeightFromY1 etc to work
 268+ EE1C 00           Svar        DB 0    ; sign variable
 269+ EE1D              SRvarPair   EQU Rvar
 270+ EE1D 00           Xreg        DB 0
 271+ EE1E 00           Yreg        DB 0
 272+ EE1F              YXregPair   EQU Xreg
 273+ EE1F
 274+ EE1F              ;-- Name: LL28 Calculate R = 256 * A / Q
 275+ EE1F              ;-- LL28+4              Skips the A >= Q check and always returns with C flag cleared, so this can be called if we know the division will work
 276+ EE1F              ;-- LL31                Skips the A >= Q check and does not set the R counter, so this can be used for jumping straight into the division loop if R is already set to 254 and we know the division will work
 277+ EE1F              ;   Reg mapping 6502  Z80
 278+ EE1F              ;               a     a
 279+ EE1F              ;               b     x
 280+ EE1F              ;               c     q
 281+ EE1F              ;               d     r
 282+ EE1F              ;
 283+ EE1F 21 1A EE     LL28_6502:          ld      hl,Qvar                 ; CMP Q                  \ If A >= Q, then the answer will not fit in one byte,
 284+ EE22 4E                               ld      c,(hl)                  ; using c as Q var
 285+ EE23 B9                               cp      c
 286+ EE24                                  FlipCarryFlag
 286+ EE24 3F          >                        ccf
 287+ EE25 DA 4D EE                         jp      c, LL2_6502             ; BCS LL2                \ so jump to LL2 to return 255
 288+ EE28 06 FE                            ld      b,$FE                   ; LDX #%11111110         \ Set R to have bits 1-7 set, so we can rotate through 7 loop iterations, getting a 1 each time, and then we use b as Rvar
 289+ EE2A CB 27        LL31_6502:          sla     a                       ; ASL A                  \ Shift A to the left
 290+ EE2C DA 41 EE                         jp      c,LL29_6502             ; BCS LL29               \ If bit 7 of A was set, then jump straight to the subtraction
 291+ EE2F                                  FlipCarryFlag                   ;                          If A < N, then C flag is set.
 291+ EE2F 3F          >                        ccf
 292+ EE30                                  JumpIfALTNusng c, LL31_SKIPSUB_6502 ; CMP Q              \ If A < Q, skip the following subtraction
 292+ EE30 B9          >                        cp      c
 292+ EE31 DA 36 EE    >                        jp		c, LL31_SKIPSUB_6502
 293+ EE34                                                                  ; BCC P%+4
 294+ EE34 91                               sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
 295+ EE35                                  ClearCarryFlag
 295+ EE35 B7          >                        or a
 296+ EE36              LL31_SKIPSUB_6502:  FlipCarryFlag
 296+ EE36 3F          >                        ccf
 297+ EE37 CB 10                            rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
 298+ EE39 DA 2A EE                         jp      c, LL31_6502            ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
 299+ EE3C 78                               ld      a,b
 300+ EE3D 32 1B EE                         ld      (Rvar),a
 301+ EE40 C9                               ret                             ; RTS                    \ R left with remainder of division
 302+ EE41 91           LL29_6502:          sub     c                       ; SBC Q                  \ A >= Q, so set A = A - Q
 303+ EE42                                  SetCarryFlag                    ; SEC                    \ Set the C flag to rotate into the result in R
 303+ EE42 37          >                        scf
 304+ EE43 CB 10                            rl      b                       ; ROL R                  \ Rotate the counter in R to the left, and catch the result bit into bit 0 (which will be a 0 if we didn't do the subtraction, or 1 if we did)
 305+ EE45 DA 2A EE                         jp      c, LL31_6502            ; BCS LL31               \ If we still have set bits in R, loop back to LL31 to do the next iteration of 7
 306+ EE48 78                               ld      a,b                     ; RTS                    \ Return from the subroutine with R containing the
 307+ EE49 32 1B EE                         ld      (Rvar),a                ; .
 308+ EE4C C9                               ret                             ; .                      \ remainder of the division
 309+ EE4D 3E FF        LL2_6502:           ld      a,$FF                   ; LDA #255               \ The division is very close to 1, so return the closest
 310+ EE4F 32 1B EE                         ld      (Rvar),a                ; STA R                  \ possible answer to 256, i.e. R = 255
 311+ EE52                                  SetCarryFlag                    ; we failed so need carry flag set
 311+ EE52 37          >                        scf
 312+ EE53 C9                               ret                             ; RTS                    \ Return from the subroutine
 313+ EE54
 314+ EE54 3A 1D EE     ADDXRegtoY1:        ld      a,(Xreg)                ; Set y1 = y1 + (Y X)
 315+ EE57 4F                               ld      c,a
 316+ EE58 06 00                            ld      b,0
 317+ EE5A 2A 0F EE                         ld      hl,(XX1532)
 318+ EE5D                                  ClearCarryFlag
 318+ EE5D B7          >                        or a
 319+ EE5E ED 4A                            adc     hl,bc
 320+ EE60 22 0F EE                         ld      (XX1532),hl
 321+ EE63 C9                               ret
 322+ EE64
 323+ EE64 ED 4B 1D EE  ADDYXRegtoY1:       ld      bc,(YXregPair)          ; Set y1 = y1 + (Y X)
 324+ EE68 2A 0F EE                         ld      hl,(XX1532)
 325+ EE6B                                  ClearCarryFlag
 325+ EE6B B7          >                        or a
 326+ EE6C ED 4A                            adc     hl,bc
 327+ EE6E 22 0F EE                         ld      (XX1532),hl
 328+ EE71 C9                               ret
 329+ EE72
 330+ EE72 ED 4B 1D EE  ADDYXRegtoX1:       ld      bc,(YXregPair)          ; Set x1 = x1 + (Y X)
 331+ EE76 2A 0D EE                         ld      hl,(XX1510)
 332+ EE79                                  ClearCarryFlag
 332+ EE79 B7          >                        or a
 333+ EE7A ED 4A                            adc     hl,bc
 334+ EE7C 22 0D EE                         ld      (XX1510),hl
 335+ EE7F C9                               ret
 336+ EE80
 337+ EE80 2A 0F EE     SUBBCFromY1:        ld      hl,(XX1532)             ; Set (S R) = (y1_hi y1_lo) - BC where BC can be say screen height
 338+ EE83                                  ClearCarryFlag
 338+ EE83 B7          >                        or a
 339+ EE84 ED 42                            sbc     hl,bc
 340+ EE86 22 1B EE                         ld      (SRvarPair),hl
 341+ EE89 C9                               ret
 342+ EE8A
 343+ EE8A 2A 1D EE     AddSRToYX:          ld      hl,(YXregPair)
 344+ EE8D ED 5B 1B EE                      ld      de,(SRvarPair)
 345+ EE91                                  ClearCarryFlag
 345+ EE91 B7          >                        or a
 346+ EE92 ED 5A                            adc     hl,de
 347+ EE94 22 1D EE                         ld      (YXregPair),hl
 348+ EE97 C9                               ret
 349+ EE98
 350+ EE98
 351+ EE98
 352+ EE98 7C           ClampX:             ld      a,h
 353+ EE99 A7                               and     a
 354+ EE9A 7D                               ld      a,l
 355+ EE9B C8                               ret     z
 356+ EE9C F2 A1 EE                         jp      p,.Max255
 357+ EE9F              .Min0:              ZeroA
 357+ EE9F AF          >                        xor a
 358+ EEA0 C9                               ret
 359+ EEA1 3E FF        .Max255:            ld      a,$FF
 360+ EEA3 C9                               ret
 361+ EEA4
 362+ EEA4 7C           ClampY:             ld      a,h
 363+ EEA5 A7                               and     a
 364+ EEA6 CA B1 EE                         jp      z,.ClampYlo
 365+ EEA9 F2 AE EE                         jp      p,.Max127
 366+ EEAC              .Min0:              ZeroA
 366+ EEAC AF          >                        xor a
 367+ EEAD C9                               ret
 368+ EEAE 3E 7F        .Max127:            ld      a,127
 369+ EEB0 C9                               ret
 370+ EEB1 7D           .ClampYlo:          ld      a,l
 371+ EEB2 A7                               and     a
 372+ EEB3 F0                               ret     p
 373+ EEB4 3E 7F                            ld      a,127
 374+ EEB6 C9                               ret
 375+ EEB7
 376+ EEB7              ;-- Rountes to code:
 377+ EEB7              ;-- LL118
 378+ EEB7              ;-- LL120   Done
 379+ EEB7              ;-- LL129   Done
 380+ EEB7              ;-- LL123   Done
 381+ EEB7                              ; NOTE DOES ABS ONLY
 382+ EEB7
 383+ EEB7
 384+ EEB7                              ;--- LL118 Move along a point until on screen
 385+ EEB7              ; In XX1510 x1 as a 16-bit coordinate (x1_hi x1_lo)
 386+ EEB7              ;    XX1532 y1 as a 16-bit coordinate (y1_hi y1_lo)
 387+ EEB7              ;    XX12p2 The line's gradient * 256 (so 1.0 = 256)
 388+ EEB7              ;    XX12p3 The direction of slope: * Positive = top left to bottom right * Negative (bit 7 set) = top right to bottom left
 389+ EEB7              ;    T      The gradient of slope:* 0 if it's a shallow slope * &FF if it's a steep slope
 390+ EEB7              ;  Out  XX150               x1 as an 8-bit coordinate
 391+ EEB7              ;       XX152               y1 as an 8-bit coordinate
 392+ EEB7              ;----------------------------------------------------------------------------------------------------------------
 393+ EEB7
 394+ EEB7
 395+ EEB7              ;---------------------------------------------------------------------------------------------------------------------
 396+ EEB7              ;--  Calculate the following:
 397+ EEB7              ;--   * If T = 0, this is a shallow slope, so calculate (Y X) = (S x1_lo) * XX12+2
 398+ EEB7              ;--   * If T <> 0, this is a steep slope, so calculate (Y X) = (S x1_lo) / XX12+2
 399+ EEB7              ;-- giving (Y X) the opposite sign to the slope direction in XX12+3.
 400+ EEB7              ;---------------------------------------------------------------------------------------------------------------------
 401+ EEB7 3A 0D EE     LL120_6502:         ld      a,(XX1510)              ;LDA XX15               \ Set R = x1_lo
 402+ EEBA 32 1B EE                         ld      (Rvar),a                ;STA R
 403+ EEBD CD 69 EF                         call    LL129_6502              ;JSR LL129              \ Call LL129 to do the following:  Q = XX12+2 = line gradient, A = S EOR XX12+3 = S EOR slope direction  (S R) = |S R|
 404+ EEC0 F5                               push    af                      ;PHA                    \ Store A on the stack so we can use it later
 405+ EEC1              ; DONT NEED PLUS MESSES UP FLAGS                    push    af                      ;LDX T                  \ If T is non-zero, then it's a steep slope, so jump
 406+ EEC1 3A 19 EE                         ld      a,(Tvar)                ; .
 407+ EEC4 32 1D EE                         ld      (Xreg),a                ;. REDUNDANT REMOVE IN OPTIMISATION
 408+ EEC7 A7                               and     a                       ;BNE LL121              \ down to LL121 to calculate this instead (Y X) = (S R) / Q
 409+ EEC8              ; DONT NEED PLUS MESSES UP FLAGS                    pop     af                      ;.                      (recover teh saved A before the cp)
 410+ EEC8 20 48                            jr      nz,LL121_6502           ;.
 411+ EECA              ;..   (Y X) = (S R) * Q - must be ABS, sign determined by opposite of the sign of the value on top of stack
 412+ EECA              LL122_6502:         ZeroA                           ;LDA #0                 \ Set A = 0
 412+ EECA AF          >                        xor a
 413+ EECB                          IFDEF DEBUG_LL122_DIRECT
 414+ EECB ~                                DISPLAY "DIRECT CALL TO LL122 so dummy push a to stack with 0"
 415+ EECB ~                                push    af
 416+ EECB                          ENDIF
 417+ EECB 32 1D EE                         ld      (Xreg),a                ;TAX                    \ Set (Y X) = 0 so we can start building the answer here
 418+ EECE 32 1E EE                         ld      (Yreg),a                ;TAY
 419+ EED1 21 1C EE                         ld      hl,Svar
 420+ EED4 ED 4B 1B EE                      ld      bc,(SRvarPair)          ;LSR S                  \ Shift (S R) to the right, so we extract bit 0 of (S R)
 421+ EED8                                  ShiftBCRight1                   ;ROR R                  \ into the C flag
 421+ EED8 CB 38       >               srl b
 421+ EEDA CB 19       >               rr  c
 422+ EEDC ED 43 1B EE                      ld      (SRvarPair),bc
 423+ EEE0 21 1A EE                         ld      hl, Qvar                ;ASL Q                  \ Shift Q to the left, catching bit 7 in the C flag
 424+ EEE3 CB 26                            sla     (hl)                    ;.
 425+ EEE5 30 03                            jr      nc, LL126_6502          ;BCC LL126              \ If C (i.e. the next bit from Q) is clear, do not do
 426+ EEE7                                                                  ;                         the addition for this bit of Q, and instead skip to LL126 to just do the shifts
 427+ EEE7 CD 8A EE     LL125_6502:         call    AddSRToYX               ;TXA                    \ Set (Y X) = (Y X) + (S R)  starting with the low bytes And then doing the high bytes
 428+ EEEA ED 4B 1B EE  LL126_6502:         ld      bc,(SRvarPair)          ;LSR S                  \ Shift (S R) to the right
 429+ EEEE                                  ShiftBCRight1                   ;ROR R
 429+ EEEE CB 38       >               srl b
 429+ EEF0 CB 19       >               rr  c
 430+ EEF2 ED 43 1B EE                      ld      (SRvarPair),bc          ;.
 431+ EEF6 21 1A EE                         ld      hl, Qvar                ;ASL Q                  \ Shift Q to the left, catching bit 7 in the C flag
 432+ EEF9 CB 26                            sla     (hl)                    ;.
 433+ EEFB 38 EA                            jr      c,LL125_6502            ;BCS LL125              \ If C (i.e. the next bit from Q) is set, loop back to LL125 to do the addition for this bit of Q
 434+ EEFD 20 EB                            jr      nz,LL126_6502           ;BNE LL126              \ If Q has not yet run out of set bits, loop back to LL126 to do the "shift" part of shift-and-add until we have done additions for all the set bits in Q, to give us our multiplication result
 435+ EEFF F1                               pop     af                      ;PLA                    \ Restore A, which we calculated above, from the stack
 436+ EF00 A7                               and     a                       ;BPL LL133              \ If A is positive jump to LL133 to negate (Y X) and
 437+ EF01 F2 5A EF                         jp      p,LL133_6502            ;.
 438+ EF04              ;.. return from the subroutine using a tail call
 439+ EF04 C9                               ret                             ;RTS                    \ Return from the subroutine
 440+ EF05
 441+ EF05              ;----------------------------------------------------------------------------------------------------------------------------
 442+ EF05              ;-- Calculate the following:
 443+ EF05              ;--         * If T = 0, this is a shallow slope, so calculate (Y X) = (S R) / XX12+2 (does not use X1lo but directly SR)
 444+ EF05              ;--         * If T <> 0, this is a steep slope, so calculate (Y X) = (S R) * XX12+2  (does not use X1lo but directly SR)
 445+ EF05              ;--             giving (Y X) the opposite sign to the slope direction in XX12+3.
 446+ EF05 CD 69 EF     LL123_6502:         call    LL129_6502              ;JSR LL129              \ Call LL129 to do the following   Q = XX12+2   = line gradient
 447+ EF08 F5                               push    af                      ;PHA                    \ Store A on the stack so we can use it later
 448+ EF09              ; DONT NEED PLUS MESSES UP FLAGS                    push    af                      ;LDX T                  \ If T is non-zero, then it's a steep slope, so jump up
 449+ EF09 3A 19 EE                         ld      a,(Tvar)                ; .
 450+ EF0C 32 1D EE                         ld      (Xreg),a                ;BNE LL122              \ to LL122 to calculate this instead:
 451+ EF0F A7                               and     a                       ;.
 452+ EF10              ;  DONT NEED PLUS MESSES UP FLAGS                    pop     af                      ;.
 453+ EF10 20 B8                            jr      nz,LL122_6502           ;.
 454+ EF12              ;--  The following calculates: (Y X) = (S R) / Q using the same shift-and-subtract algorithm that's documented in TIS2
 455+ EF12 3E FF        LL121_6502:         ld      a,$FF                   ;LDA #%11111111         \ Set Y = %11111111
 456+ EF14 32 1E EE                         ld      (Yreg),a                ;TAY
 457+ EF17 CB 27                            sla     a                       ;ASL A                  \ Set X = %11111110
 458+ EF19 32 1D EE                         ld      (Xreg),a                ;TAX
 459+ EF1C              ;--  This sets (Y X) = %1111111111111110, so we can rotate through 15 loop iterations, getting a 1 each time, and then getting a 0 on the 16th iteration... and we can also use it to catch our result bits into bit 0 each time
 460+ EF1C ED 4B 1B EE  LL130_6502:         ld      bc,(SRvarPair)          ;ASL R                  \ Shift (S R) to the left
 461+ EF20                                  ShiftBCLeft1                    ;.
 461+ EF20 CB 21       >               sla c
 461+ EF22 CB 10       >               rl  b
 462+ EF24 ED 43 1B EE                      ld      (SRvarPair),bc          ;ROL S
 463+ EF28 3A 1C EE                         ld      a,(Svar)                ;LDA S                  \ Set A = S
 464+ EF2B 38 07                            jr      c, LL131_6502           ;BCS LL131              \ If bit 7 of S was set, then jump straight to the subtraction
 465+ EF2D 21 1A EE                         ld      hl,Qvar                 ;CMP Q                  \ If A < Q (i.e. S < Q), skip the following subtractions
 466+ EF30 BE                               cp      (hl)
 467+ EF31                                  FlipCarryFlag                   ; note flip carry flag here to simulate 6502 operation
 467+ EF31 3F          >                        ccf
 468+ EF32 30 12                            jr      nc,LL132A_6502          ;BCC LL132  (NOTE Carry flag reversed in Z80 for CP)
 469+ EF34              LL131_6502:         FlipCarryFlag                   ;flip carry to make it act like a 6502 borrow
 469+ EF34 3F          >                        ccf
 470+ EF35 9E                               sbc     (hl)                    ;SBC Q                  \ A >= Q (i.e. S >= Q) so set:
 471+ EF36 32 1C EE                         ld      (Svar),a                ;STA S
 472+ EF39 3A 1B EE                         ld      a,(Rvar)                ;LDA R                  \ And then doing the high bytes
 473+ EF3C                                  ClearCarryFlag                  ;\   S = (A R) - Q  = (S R) - Q starting with the low bytes (we know the C flag is set so the subtraction will be correct)
 473+ EF3C B7          >                        or a
 474+ EF3D DE 00                            sbc     0                       ;SBC #0
 475+ EF3F 32 1B EE                         ld      (Rvar),a                ;STA R
 476+ EF42                                  SetCarryFlag                    ;SEC                    \ Set the C flag to rotate into the result in (Y X)
 476+ EF42 37          >                        scf
 477+ EF43 C3 47 EF                         jp      LL132_6502              ;added so that we can do a 6502 style carry above
 478+ EF46 00           LL132A_6502:        nop; FlipCarryFlag
 479+ EF47 ED 4B 1D EE  LL132_6502:         ld      bc,(YXregPair)          ; Rotate the counter in (Y X) to the left, and catch the
 480+ EF4B                                  RollBCLeft1                     ; ROL A                  \ result bit into bit 0 (which will be a 0 if we didn't
 480+ EF4B CB 11       >               rl  c
 480+ EF4D CB 10       >               rl  b
 481+ EF4F ED 43 1D EE                      ld      (YXregPair),bc          ; TAX                    \ do the subtraction, or 1 if we did)
 482+ EF53 38 C7                            jr      c, LL130_6502           ; BCS LL130              \ If we still have set bits in (Y X), loop back to LL130 to do the next iteration of 15, until we have done the whole division
 483+ EF55                          IFDEF DEBUG_LL121_DIRECT
 484+ EF55 ~                                DISPLAY "DIRECT CALL TO LL121 so dummy push"
 485+ EF55 ~                                push    af
 486+ EF55                          ENDIF
 487+ EF55 F1                               pop     af                      ; PLA                    \ Restore A, which we calculated above, from the stack
 488+ EF56 A7                               and     a                       ; BMI LL128              \ If A is negative jump to LL128 to return from the
 489+ EF57 FA 68 EF                         jp      m, LL128_6502           ; .                      \ subroutine with (Y X) as is
 490+ EF5A ED 4B 1D EE  LL133_6502:         ld      bc,(YXregPair)          ; TXA                    \ Otherwise negate (Y X) using two's complement by first
 491+ EF5E                                  macronegate16bc                 ; EOR #%11111111         \ setting the low byte to ~X + 1
 491+ EF5E AF          >					xor 	a
 491+ EF5F 91          >                    sub 	c
 491+ EF60 4F          >                    ld 		c,a
 491+ EF61 9F          >                    sbc 	a,a
 491+ EF62 90          >                    sub 	b
 491+ EF63 47          >                    ld 		b,a
 492+ EF64 ED 43 1D EE                      ld      (YXregPair),bc          ; ADC #1                 \ The addition works as we know the C flag is clear from\ when we passed through the BCS above
 493+ EF68 C9           LL128_6502:         ret                             ; RTS                    \ Return from the subroutine
 494+ EF69              ;-------------------------------------------------------------------------------------------------------
 495+ EF69              ;..  Do the following, in this order: Q = XX12+2 A = S EOR XX12+3 (S R) = |S R|
 496+ EF69              ;..  This sets up the variables required above to calculate (S R) / XX12+2 and give the result the opposite sign to XX13+3.
 497+ EF69 F5           LL129_6502:         push    af                      ;LDX XX12+2             \ Set Q = XX12+2
 498+ EF6A 3A 15 EE                         ld      a,(XX12p2)              ;.
 499+ EF6D 32 1D EE                         ld      (Xreg),a                ;.
 500+ EF70 32 1A EE                         ld      (Qvar),a                ;STX Q
 501+ EF73 F1                               pop     af                      ;.
 502+ EF74 3A 1C EE                         ld      a,(Svar)                ;LDA S                  \ If S is positive, jump to LL127
 503+ EF77 A7                               and     a                       ;BPL LL127
 504+ EF78 F2 90 EF                         jp      p,LL127_6502            ;.
 505+ EF7B                                  ZeroA                           ;.LDA #0                \ Otherwise set R = -R
 505+ EF7B AF          >                        xor a
 506+ EF7C                                  ClearCarryFlag                  ;SEC
 506+ EF7C B7          >                        or a
 507+ EF7D 21 1B EE                         ld      hl, Rvar                ;SBC R
 508+ EF80 9E                               sbc     (hl)                    ;.
 509+ EF81 32 1B EE                         ld      (Rvar),a                ;STA R
 510+ EF84 3A 1C EE                         ld      a,(Svar)                ;LDA S                  \ Push S onto the stack
 511+ EF87 F5                               push    af                      ;PHA
 512+ EF88 EE FF                            xor     $FF                     ;EOR #%11111111         \ Set S = ~S + 1 + C  ?? is this all just doing |Svar|?
 513+ EF8A CE 00                            adc     0                       ;ADC #0
 514+ EF8C 32 1C EE                         ld      (Svar),a                ;STA S
 515+ EF8F F1                               pop     af                      ;PLA                    \ Pull the original, negative S from the stack into A
 516+ EF90 21 16 EE     LL127_6502:         ld      hl,XX12p3               ;EOR XX12+3             \ Set A = original argument S EOR'd with XX12+3
 517+ EF93 AE                               xor     (hl)                    ;.
 518+ EF94 C9                               ret                             ;RTS                    \ Return from the subroutine
 519+ EF95              ;----------------------------------------------------------------------------------------------------------------
 520+ EF95              ;--- LL118 Move along a point until on screen
 521+ EF95              ; In XX1510 x1 as a 16-bit coordinate (x1_hi x1_lo)
 522+ EF95              ;    XX1532 y1 as a 16-bit coordinate (y1_hi y1_lo)
 523+ EF95              ;    XX12p2 The line's gradient * 256 (so 1.0 = 256)
 524+ EF95              ;    XX12p3 The direction of slope: * Positive = top left to bottom right * Negative (bit 7 set) = top right to bottom left
 525+ EF95              ;    T      The gradient of slope:* 0 if it's a shallow slope * &FF if it's a steep slope
 526+ EF95              ;  Out  XX150               x1 as an 8-bit coordinate
 527+ EF95              ;       XX152               y1 as an 8-bit coordinate
 528+ EF95              ;----------------------------------------------------------------------------------------------------------------
 529+ EF95
 530+ EF95 3A 0E EE     LL118_6502:         ld      a,(XX1510+1)            ; LDA XX15+1             \ If x1_hi is positive, jump down to LL119 to skip the
 531+ EF98 A7                               and     a                       ; BPL LL119              \ .
 532+ EF99 F2 B6 EF                         jp      p, LL119_6502           ;                        \ following
 533+ EF9C 32 1C EE     .X1Negative:        ld      (Svar),a                ; STA S                  \ Otherwise x1_hi is negative, i.e. off the left of the screen, so set S = x1_hi
 534+ EF9F CD B7 EE                         call    LL120_6502              ; Call LL120 to calculate:  (Y X) = (S x1_lo) * XX12+2      if T = 0   = x1 * gradient
 535+ EFA2                                                                  ;                            (Y X) = (S x1_lo) / XX12+2      if T <> 0  = x1 / gradient
 536+ EFA2                                                                  ; with the sign of (Y X) set to the opposite of the line's direction of slope
 537+ EFA2 CD 64 EE                         call    ADDYXRegtoY1             ; Set y1 = y1 + (Y X)
 538+ EFA5 22 0F EE                         ld      (XX1532),hl             ; .
 539+ EFA8 21 00 00                         ld      hl,0                    ; Set x1 = 0
 540+ EFAB 22 0D EE                         ld      (XX1510),hl             ; .
 541+ EFAE 3E 00                            ld      a,0                     ; set 0 up for replacemetn of the TAX and BEQ bit
 542+ EFB0 32 1D EE                         ld      (Xreg),a                ; TAX                    \ Set X = 0 so the next BEQ becomes a jmp but we will do it anyway in next line
 543+ EFB3 C3 CC EF                         jp      LL134_6502              ; just do the jump to LL134 rather than setting to equal flag and then jumping
 544+ EFB6              ;-- Entering LL119 a will always be the value of X1 Hi byte
 545+ EFB6 CA CC EF     LL119_6502:         jp      z,LL134_6502            ; BEQ LL134              \ x1_hi = 0 then jump down to LL134 to skip the following, as the x-coordinate is already on-screen
 546+ EFB9                                                                  ;                        \ (as 0 <= (x_hi x_lo) <= 255)
 547+ EFB9 32 1C EE                         ld      (Svar),a                ; STA S                  \ Otherwise x1_hi is positive, i.e. x1 >= 256 and off
 548+ EFBC 3D                               dec     a                       ; DEC S                  \ the right side of the screen, so set S = x1_hi - 1
 549+ EFBD 32 1C EE                         ld      (Svar),a                ;
 550+ EFC0 CD B7 EE                         call    LL120_6502              ; JSR LL120              \ Call LL120 to calculate:  (Y X) = (S x1_lo) * XX12+2      if T = 0   = (x1 - 256) * gradient
 551+ EFC3                                                                  ;                        \                           (Y X) = (S x1_lo) / XX12+2      if T <> 0 = (x1 - 256) / gradient
 552+ EFC3                                                                  ;                        \ with the sign of (Y X) set to the opposite of the line's direction of slope
 553+ EFC3 CD 64 EE                         call    ADDYXRegtoY1             ; TXA                    \ Set y1 = y1 + (Y X)
 554+ EFC6 21 FF 00                         ld      hl,255                  ; LDX #255               \ Set x1 = 255
 555+ EFC9 22 0D EE                         ld      (XX1510),hl             ; STX XX15 ;INX; STX XX15+1
 556+ EFCC              ;--  We have moved the point so the x-coordinate is on  screen (i.e. in the range 0-255), so now for the  y-coordinate
 557+ EFCC 3A 10 EE     LL134_6502:         ld      a,(XX1532+1)            ; LDA XX15+3             \ If y1_hi is positive, jump down to LL119 to skip
 558+ EFCF A7                               and     a                       ; BPL LL135              \ the following
 559+ EFD0 F2 E8 EF                         jp      p, LL135_6502           ; .
 560+ EFD3 32 1C EE                         ld      (Svar),a                ; STA S                  \ Otherwise y1_hi is negative, i.e. off the top of the screen, so set S = y1_hi
 561+ EFD6 3A 0F EE                         ld      a, (XX1532)             ; LDA XX15+2             \ Set R = y1_lo
 562+ EFD9 32 1B EE                         ld      (Rvar),a                ; STA R
 563+ EFDC CD 05 EF                         call    LL123_6502              ; JSR LL123              \ Call LL123 to calculate:  (Y X) = (S R) / XX12+2      if T = 0 = y1 / gradient
 564+ EFDF                                                                  ;                        \                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
 565+ EFDF                                                                  ;                         with the sign of (Y X) set to the opposite of the line's direction of slope
 566+ EFDF CD 72 EE                         call    ADDYXRegtoX1            ; TXA                    \ Set x1 = x1 + (Y X)
 567+ EFE2 21 00 00                         ld      hl,0                    ; LDA #0                 \ Set y1 = 0
 568+ EFE5 22 0F EE                         ld      (XX1532),hl             ; STA XX15+2, XX15+3
 569+ EFE8 01 80 00     LL135_6502:         ld      bc,128                  ; LDA XX15+2             \ Set (S R) = (y1_hi y1_lo) - screen height
 570+ EFEB CD 80 EE                         call    SUBBCFromY1             ; .                      \ .
 571+ EFEE 38 0C                            jr      c, LL136_6502           ; BCC LL136              \ If the subtraction underflowed, i.e. if y1 < screen height, then y1 is already on-screen, so jump to LL136
 572+ EFF0                                                                  ;                        \ to return from the subroutine, as we are done
 573+ EFF0              ;;-   If we get here then y1 >= screen height, i.e. off the bottom of the screen
 574+ EFF0 CD 05 EF     LL139_6502:         call    LL123_6502              ; JSR LL123              \ Call LL123 to calculate:   (Y X) = (S R) / XX12+2      if T = 0  = (y1 - screen height) / gradient
 575+ EFF3                                                                  ;                        \                            (Y X) = (S R) * XX12+2      if T <> 0 = (y1 - screen height) * gradient
 576+ EFF3                                                                  ;                          with the sign of (Y X) set to the opposite of the line's direction of slope
 577+ EFF3 CD 72 EE                         call    ADDYXRegtoX1            ; TXA                    \ Set x1 = x1 + (Y X)
 578+ EFF6 21 7F 00                         ld      hl, 127                 ; LDA #Y*2-1             \ Set y1 = 2 * #Y - 1. The constant #Y is 96, the y-coordinate of the mid-point of the space view (or in our case 127)
 579+ EFF9 22 0F EE                         ld      (XX1532),hl             ; STA XX15+3             \ pixel row of the space view
 580+ EFFC C9           LL136_6502:         ret                             ; RTS                    \ Return from the subroutine
 581+ EFFD              ;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 582+ EFFD              ;-- LL145 LINE CLIP
 583+ EFFD              ;-- OPTISIATIONS - VERTICAL HORZONTAL POINT |DX| = |DY| (and all the veriants for +/-)
 584+ EFFD              ;-- This routine clips the line from (x1, y1) to (x2, y2) so it fits on-screen, or returns an error if it can't be clipped to fit. The arguments are 16-bit coordinates, and the clipped line is returned using 8-bit screen coordinates.
 585+ EFFD              ;-- This part sets XX13 to reflect which of the two points are on-screen and off-screen.
 586+ EFFD              ;-- IN  : XX15(1 0) x1 XX15(3 2) y1 XX15(5 4) x2 XX12(1 0) y2
 587+ EFFD              ;-- OUT : (X1, Y1), (X2, Y2) Screen coordinate C flag  Clear if the clipped line fits on-screen, set if itdoesn't
 588+ EFFD              ;         XX13 The state of the original coordinates on-screen:* 0   = (x2, y2) on-screen* 95(64)  = (x1, y1) on-screen,  (x2, y2) off-screen* 191(128) = (x1, y1) off-screen, (x2, y2) off-screen
 589+ EFFD              ;              So XX13 is non-zero if the end of the line was clipped,meaning the next line sent to BLINE can't join onto the end but has to start a new segment
 590+ EFFD              ;         SWAP The swap status of the returned coordinates:* &FF if we swapped the values of (x1, y1) and(x2, y2) as part of the clipping process* 0 if the coordinates are still in the same order
 591+ EFFD                                  DISPLAY "TODO: treat horz vert and sigle pixel as special cases"
 592+ EFFD              ; TODO treat horizonal/vert and single pixel as special cases
 593+ EFFD              LL145_6502:         ZeroA                           ; LDA #0                 \ Set SWAP = 0
 593+ EFFD AF          >                        xor a
 594+ EFFE 32 E1 C7                         ld      (SWAP),a                ; STA SWAP
 595+ F001 3A 12 EE                         ld      a,(XX1554+1)            ; LDA XX15+5             \ Set A = x2_hi (use b as a substibute for a)
 596+ F004 47                               ld      b,a                     ; .
 597+ F005              ; Note that as we are interested in the sign of XX113 then this needs to be >= 128 or < 128 or 0, we will use 191 as per bbc for now
 598+ F005              ; for the screen coord we will use 127 though, we use c as a temporay X register
 599+ F005 3E BF        LL147_6502:         ld      a,191                   ; LDX #Y*2-1             \ Set X = #Y * 2 - 1. The constant #Y is 96, the y-coordinate of the mid-point of the space view, so this sets Y2 to 191, the y-coordinate of the bottom pixel row of the space view
 600+ F007 32 1D EE                         ld      (Xreg),a                ; .
 601+ F00A              ;                    ld      a,127
 602+ F00A              ;                    ld      c,a
 603+ F00A 78           .CheckX2Y2High:     ld      a,b                     ; ORA XX12+1             \ If one or both of x2_hi and y2_hi are non-zero, jump
 604+ F00B 21 14 EE                         ld      hl,XX12p1               ; .
 605+ F00E B6                               or      (hl)                    ; .
 606+ F00F C2 1F F0                         jp      nz,LL107_6502           ; BNE LL107              \ to LL107 to skip the following, leaving X at 191
 607+ F012 3E 7F        .CheckY2Lo:         ld      a,127 ;,c               ; get back the temporary x reg from c
 608+ F014 21 13 EE                         ld      hl,XX1210               ; CPX XX12               \ If y2_lo > the y-coordinate of the bottom of screen (a is being used as X at this point still)
 609+ F017 BE                               cp      (hl)                    ; .
 610+ F018 DA 1F F0                         jp      c,LL107_6502            ; BCC LL107              \ then (x2, y2) is off the bottom of the screen, so skip the following instruction, leaving X at 127
 611+ F01B                                  ZeroA                           ; LDX #0                 \ Set X = 0
 611+ F01B AF          >                        xor a
 612+ F01C 32 1D EE                         ld      (Xreg),a
 613+ F01F 3A 1D EE     LL107_6502:         ld      a,(Xreg)                ; STX XX13               \ Set XX13 = X, so we have * XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen* XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lois off the bottom of the screen
 614+ F022 32 14 67                         ld      (XX13),a                ; now c is released as a temporary x reg
 615+ F025 3A 0E EE                         ld      a,(XX1510+1)            ; LDA XX15+1             \ If one or both of x1_hi and y1_hi are non-zero, jump
 616+ F028 21 10 EE                         ld      hl,XX1532+1             ; ORA XX15+3             \ to LL83
 617+ F02B B6                               or      (hl)                    ; .
 618+ F02C C2 6C F0                         jp      nz,LL83_6502            ; BNE LL83
 619+ F02F              ; DEBUG SIMPLIFIED CODE, now we just compare y1 lo > 127
 620+ F02F 3A 0F EE                         ld      a,(XX1532)              ; If y1_lo > the y-coordinate of the bottom of screen (If A >= N, then C flag is reset.) ;ld      a,127                   ; LDA #Y*2-1             \ If y1_lo > the y-coordinate of the bottom of screen (If A >= N, then C flag is reset.)
 621+ F032 26 7F                            ld      h,127                   ; then (x1, y1) is off the bottom of the screen, so jump                                 ;ld      hl,XX1532               ; CMP XX15+2             \ then (x1, y1) is off the bottom of the screen, so jump
 622+ F034 BC                               cp      h                       ; to LL83                                                                                ;cp      (hl)                    ; .                      \ to LL83
 623+ F035 D2 6C F0                         jp      nc, LL83_6502         ; BCC LL83               \ . (y1 > 127 jump, i.e. 127 <= y1 )
 624+ F038 3A 14 67                         ld      a,(XX13)                ; LDA XX13               \ If we get here, (x1, y1) is on-screen. If XX13 is non-zero, i.e. (x2, y2) is off-screen, jump
 625+ F03B A7                               and     a                       ; BNE LL108              \ to LL108 to halve it before continuing at LL83
 626+ F03C C2 67 F0                         jp      nz,LL108_6502
 627+ F03F              ; If we get here, the high bytes are all zero, which means the x-coordinates are < 256 and therefore fit on screen, and neither coordinate is off the bottom of the screen. That means both coordinates are already on
 628+ F03F              ; screen, so we don't need to do any clipping, all weneed to do is move the low bytes into (X1, Y1) and X2, Y2) and return
 629+ F03F              ; X1 = XX15 (10)  Y1 = XX15+1 X2 = XX15+2 Y2 = XX15+3
 630+ F03F                  DEFINE CLAMPINGEXTREMES
 631+ F03F              LL146_6502: IFDEF CLAMPINGEXTREMES
 632+ F03F 2A 0D EE                         ld      hl,(XX1510)             ;  Save X1 to XX1510
 633+ F042 CD 98 EE                         call    ClampX
 634+ F045 32 0D EE                         ld      (XX1510),a
 635+ F048                          ENDIF
 636+ F048 2A 0F EE                         ld      hl,(XX1532)             ;  hl = y1
 637+ F04B CD A4 EE                         call    ClampY
 638+ F04E 32 0E EE                         ld      (XX1510+1),a            ;  XX1510... = [X1][Y1]
 639+ F051
 640+ F051 2A 11 EE                         ld      hl,(XX1554)             ;  de = x2
 641+ F054 CD 98 EE                         call    ClampX
 642+ F057 32 0F EE                         ld      (XX1510+2),a            ;  XX1510... = [X1][Y1][X2]
 643+ F05A
 644+ F05A 2A 13 EE                         ld      hl,(XX1576)             ;  bc = y2
 645+ F05D CD A4 EE                         call    ClampY
 646+ F060 32 10 EE                         ld      (XX1510+3),a            ;  XX1510... = [X1][Y1][X2][Y2]
 647+ F063
 648+ F063                                  ClearCarryFlag                  ; CLC                    \ Clear the C flag as the clipped line fits on-screen
 648+ F063 B7          >                        or a
 649+ F064 C9                               ret                             ; RTS                    \ Return from the subroutine
 650+ F065              LL109_6502:         SetCarryFlag                    ; SEC                    \ Set the C flag to indicate the clipped line does not fit on-screen
 650+ F065 37          >                        scf
 651+ F066 C9                               ret                             ; RTS                    \ Return from the subroutine
 652+ F067 21 14 67     LL108_6502:         ld      hl,XX13                 ; LSR XX13               \ If we get here then (x2, y2) is off-screen and XX13 is
 653+ F06A CB 3E                            srl     (hl)                    ;                        \ 191, (128)  so shift XX13 right to halve it to 95 (64)
 654+ F06C              ;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 655+ F06C              ;-- LL145 (Part 2 of 4)
 656+ F06C 3A 14 67     LL83_6502:          ld      a,(XX13)                ; LDA XX13               \ If XX13 < 128 then only one of the points is on-screen
 657+ F06F A7                               and     a                       ; BPL LL115              \ so jump down to LL115 to skip the checks of whether
 658+ F070 F2 BC F0                         jp      p,LL115_6502            ;                        \ both points are in the strips to the right or bottom of the screen
 659+ F073              ;-- If we get here, both points are off-screen
 660+ F073 3A 0E EE                         ld      a,(XX1510+1)            ; LDA XX15+1             \ If both x1_hi and x2_hi have bit 7 set, jump to LL109
 661+ F076 21 12 EE                         ld      hl,XX1554+1             ; AND XX15+5             \ to return from the subroutine with the C flag set, as
 662+ F079 A6                               and     (hl)
 663+ F07A FA 65 F0                         jp      m, LL109_6502           ; BMI LL109              \ the entire line is above the top of the screen
 664+ F07D 3A 10 EE                         ld      a,(XX1532+1)            ; LDA XX15+3             \ If both y1_hi and y2_hi have bit 7 set, jump to LL109
 665+ F080 21 14 EE                         ld      hl,XX1576+1             ; AND XX12+1             \ to return from the subroutine with the C flag set, as
 666+ F083 A6                               and     (hl)                    ; BMI LL109              \ the entire line is to the left of the screen
 667+ F084 FA 65 F0                         jp      m,LL109_6502            ; .
 668+ F087 3A 0E EE                         ld      a,(XX1510+1)            ; LDX XX15+1             \ Set A = X = x1_hi - 1
 669+ F08A 3D                               dec     a                       ; DEX
 670+ F08B 32 1D EE                         ld      (Xreg),a                ; TXA
 671+ F08E F5                               push    af                      ; LDX XX15+5     SP+1    \ Set XX12+2 = x2_hi - 1, we need to save a register first
 672+ F08F 3A 12 EE                         ld      a,(XX1554+1)            ; .
 673+ F092 3D                               dec     a                       ; DEX
 674+ F093 32 1D EE                         ld      (Xreg),a                ; STX XX12+2
 675+ F096 F1                               pop     af                      ; .              SP+0    restore a register
 676+ F097 21 14 EE                         ld      hl,XX1576+1             ; ORA XX12+2             \ If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set,
 677+ F09A B6                               or      (hl)                    ; .
 678+ F09B F2 65 F0                         jp      p, LL109_6502           ; BPL LL109              \ jump to LL109 to return from the subroutine with the C flag set, as the line doesn't fit on-screen
 679+ F09E              ; for this bit, while z80 uses carry the opposite way to 6502, 6502 uses borrow, in effect inverting the flip
 680+ F09E              ;NOTEFOUND A PATH WHERE IT DOES NOT DO THIS CHECK e.g. 90 B2 8D A2
 681+ F09E 3A 0F EE     LL83_DEBUG:         ld      a,(XX1532)              ; LDA XX15+2             \ If y1_lo < y-coordinate of screen bottom, clear the C
 682+ F0A1 FE 80                            cp      128                     ; CMP #Y*2               \ flag, otherwise set it (NOTE FLIPPED IN z80)
 683+ F0A3 3A 10 EE                         ld      a,(XX1532+1)            ; LDA XX15+3             \ Set XX12+2 = y1_hi - (1 - C), so:
 684+ F0A6              ;                    FlipCarryFlag                   ; as 6502 uses borrow in subtracts we flip for SBC as z80 CP does opposite too, if A < N carry set so flip
 685+ F0A6 DE 00                            sbc     0                       ; SBC #0                 \ .
 686+ F0A8 32 15 EE                         ld      (XX12p2),a              ; STA XX12+2             \  * Set XX12+2 = y1_hi - 1 if y1_lo is on-screen * Set XX12+2 = y1_hi  otherwise We do this subtraction because we are only interested
 687+ F0AB 3A 13 EE                         ld      a,(XX1576)              ; LDA XX12               \ If y2_lo < y-coordinate of screen bottom, clear the C
 688+ F0AE FE 80                            cp      128                     ; CMP #Y*2               \ flag, otherwise set it
 689+ F0B0 3A 14 EE                         ld      a,(XX1576+1)            ; LDA XX12+1             \ Set XX12+2 = y2_hi - (1 - C), so:
 690+ F0B3              ;                    FlipCarryFlag
 691+ F0B3 DE 00                            sbc     0                       ; SBC #0                   * Set XX12+1 = y2_hi - 1 if y2_lo is on-screen  * Set XX12+1 = y2_hi     otherwise
 692+ F0B5 21 15 EE                         ld      hl,XX12p2               ; ORA XX12+2             \ If neither XX12+1 or XX12+2 have bit 7 set, jump to
 693+ F0B8 B6                               or      (hl)                    ; .
 694+ F0B9 F2 65 F0                         jp      p,LL109_6502            ; BPL LL109              \ LL109 to return from the subroutine with the C flag set, as the line doesn't fit on-screen
 695+ F0BC              ;-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 696+ F0BC              ;-- LL145 (Part 3 of 4) Summary: Clip line: Calculate the line's gradient
 697+ F0BC 3A 1E EE     LL115_6502:         ld      a,(Yreg)                ; TYA                    \ Store Y on the stack so we can preserve it through the call to this routine
 698+ F0BF F5                               push    af                      ; PHA            SP+1    \ call to this subroutine
 699+ F0C0 2A 11 EE                         ld      hl,(XX1554)             ; LDA XX15+4             \ Set XX12+2 = x2_lo - x1_lo
 700+ F0C3 ED 5B 0D EE                      ld      de,(XX1510)             ; LDA XX15+5             \ Set XX12+3 = x2_hi - x1_hi
 701+ F0C7                                  ClearCarryFlag                  ; SBC XX15+1
 701+ F0C7 B7          >                        or a
 702+ F0C8 ED 52                            sbc     hl,de                   ; .
 703+ F0CA 22 6B F2                         ld      (delta_x),hl            ; .
 704+ F0CD 2A 13 EE                         ld      hl,(XX1576)             ; LDA XX12               \ Set XX12+4 = y2_lo - y1_lo
 705+ F0D0 ED 5B 0F EE                      ld      de,(XX1532)             ;
 706+ F0D4                                  ClearCarryFlag                  ; SBC XX15+2
 706+ F0D4 B7          >                        or a
 707+ F0D5 ED 52                            sbc     hl,de                   ; .
 708+ F0D7 22 6D F2                         ld      (delta_y),hl            ; .
 709+ F0DA              ; So we now have:  delta_x in XX12(3 2)  delta_y in XX12(5 4) where the delta is (x1, y1) - (x2, y2))
 710+ F0DA 3A 6E F2                         ld      a,(delta_y+1)           ; EOR XX12+3             \ Set S = the sign of delta_x * the sign of delta_y, so
 711+ F0DD 21 6C F2                         ld      hl,delta_x+1
 712+ F0E0 AE                               xor     (hl)
 713+ F0E1 32 1C EE                         ld      (Svar),a                ; STA S                  \ if bit 7 of S is set, the deltas have different signs (perhaps we should do bit 7 mask ?????????
 714+ F0E4 2A 6D F2                         ld      hl,(delta_y)            ; LDA XX12+5             \ If delta_y_hi is positive, jump down to LL110 to skip
 715+ F0E7 7C                               ld      a,h
 716+ F0E8 A7                               and     a
 717+ F0E9 F2 F5 F0                         jp      p, LL110_6502           ; BPL LL110              \ the following
 718+ F0EC                                  NegHL                           ; LDA #0                 \ Otherwise flip the sign of delta_y to make it
 718+ F0EC AF          >                    xor a
 718+ F0ED 95          >                    sub l
 718+ F0EE 6F          >                    ld l,a
 718+ F0EF 9F          >                    sbc a,a
 718+ F0F0 94          >                    sub h
 718+ F0F1 67          >                    ld h,a
 719+ F0F2 22 6D F2                         ld      (delta_y),hl            ; positive, starting with the low bytes
 720+ F0F5 2A 6B F2     LL110_6502:         ld      hl,(delta_x)            ; LDA XX12+3             \ If delta_x_hi is positive, jump down to LL111 to skip
 721+ F0F8 7C                               ld      a,h                     ; BPL LL111              \ the following
 722+ F0F9 A7                               and     a                       ; .
 723+ F0FA F2 06 F1                         jp      p,LL111_6502            ; .
 724+ F0FD                                  NegHL                           ; SEC                    \ Otherwise flip the sign of delta_x to make it
 724+ F0FD AF          >                    xor a
 724+ F0FE 95          >                    sub l
 724+ F0FF 6F          >                    ld l,a
 724+ F100 9F          >                    sbc a,a
 724+ F101 94          >                    sub h
 724+ F102 67          >                    ld h,a
 725+ F103 22 6B F2                         ld      (delta_x),hl            ; LDA #0                 \ positive, starting with the low bytes
 726+ F106              ;--  We now keep halving |delta_x| and |delta_y| until both of them have zero in their high bytes
 727+ F106 2A 6B F2     LL111_6502:         ld      hl,(delta_x)
 728+ F109 ED 5B 6D F2                      ld      de,(delta_y)
 729+ F10D 7C                               ld      a,h                     ; TAX                    \ If |delta_x_hi| is non-zero, skip the following
 730+ F10E B2                               or      d                       ; BNE LL112
 731+ F10F CA 24 F1                         jp      z,LL113_6502            ; LDX XX12+5             \ If |delta_y_hi| = 0, jump down to LL113 (as both |delta_x_hi| and |delta_y_hi| are 0)
 732+ F112              LL112_6502:         ShiftHLRight1                   ; LSR A                  \ Halve the value of delta_x in (A XX12+2)
 732+ F112 CB 3C       >               srl h
 732+ F114 CB 1D       >               rr  l
 733+ F116                                  ShiftDERight1                   ; LSR XX12+5             \ Halve the value of delta_y XX12(5 4)
 733+ F116 CB 3A       >               srl d
 733+ F118 CB 1B       >               rr  e
 734+ F11A 22 6B F2                         ld      (delta_x),hl
 735+ F11D ED 53 6D F2                      ld      (delta_y),de            ; write them back so we don't end up in an infinite loop
 736+ F121 C3 06 F1                         jp  LL111_6502                  ; JMP LL111              \ Loop back to LL111
 737+ F124              ;-- By now, the high bytes of both |delta_x| and |delta_y| are zero
 738+ F124              LL113_6502:         ZeroA                           ; STX T                  \ We know that X = 0 as that's what we tested with a BEQ  above, so this sets T = 0
 738+ F124 AF          >                        xor a
 739+ F125 32 19 EE                         ld  (Tvar),a
 740+ F128 3A 6B F2                         ld      a,(delta_x)             ; LDA XX12+2             \ If delta_x_lo < delta_y_lo, so our line is more
 741+ F12B 21 6D F2                         ld      hl,delta_y              ; CMP XX12+4             \ vertical than horizontal, jump to LL114
 742+ F12E BE                               cp      (hl)
 743+ F12F DA 41 F1                         jp      c, LL114_6502           ; BCC LL114              ; if delta y > delta x then its a steep slope so we do 256*dy/dx
 744+ F132              ;-- If we get here then our line is more horizontal than vertical, so it is a shallow slope
 745+ F132 3A 6B F2                         ld      a,(delta_x)             ; STA Q                  \ Set Q = delta_x_lo
 746+ F135 32 1A EE                         ld      (Qvar),a                ; .
 747+ F138 3A 6D F2                         ld      a,(delta_y)             ; LDA XX12+4             \ Set A = delta_y_lo
 748+ F13B CD 1F EE                         call    LL28_6502               ; JSR LL28               \ Call LL28 to calculate: R = 256 * A / Q = 256 * delta_y_lo / delta_x_lo
 749+ F13E C3 52 F1                         jp      LL116_6502              ; JMP LL116              \ Jump to LL116, as we now have the line's gradient in R
 750+ F141              ;-- If we get here then our line is more vertical than horizontal, so it is a steep slope
 751+ F141 3A 6D F2     LL114_6502:         ld      a,(delta_y)             ; LDA XX12+4             \ Set Q = delta_y_lo
 752+ F144 32 1A EE                         ld      (Qvar),a                ; STA Q
 753+ F147 3A 6B F2                         ld      a,(delta_x)             ; LDA XX12+2             \ Set A = delta_x_lo
 754+ F14A CD 1F EE                         call    LL28_6502               ; JSR LL28               \ Call LL28 to calculate: R = 256 * A / Q = 256 * delta_x_lo / delta_y_lo
 755+ F14D 3E FF                            ld      a,$FF                   ; DEC T                  \ T was set to 0 above, so this sets T = &FF when our
 756+ F14F 32 19 EE                         ld      (Tvar),a                ;                        \ line is steep
 757+ F152              ;----------------------------------------------------------------------------------------------------------------
 758+ F152              ;--- LL116 This part sets things up to call the routine in LL188, which does the actual clipping.
 759+ F152              ;--  If we get here, then R has been set to the gradient of the line (x1, y1) to(x2, y2), with T indicating the gradient of slope: * 0   = shallow slope (more horizontal than vertical)
 760+ F152              ;--                                                                                                                                * &FF = steep slope (more vertical than horizontal)
 761+ F152              ;-- XX13 has been set as follows: * 0   = (x1, y1) off-screen, (x2, y2) on-screen * 95(64)  = (x1, y1) on-screen,  (x2, y2) off-screen * 191(128) = (x1, y1) off-screen, (x2, y2) off-screen
 762+ F152 3A 1B EE     LL116_6502:         ld      a,(Rvar)                ; LDA R                  \ Store the gradient in XX12+2
 763+ F155 32 15 EE                         ld      (XX12p2),a              ; STA XX12+2
 764+ F158 3A 1C EE                         ld      a,(Svar)                ; LDA S                  \ Store the type of slope in XX12+3, bit 7 clear means
 765+ F15B 32 16 EE                         ld      (XX12p3),a              ; STA XX12+3             \ top left to bottom right, bit 7 set means top right to bottom left
 766+ F15E 3A 14 67                         ld      a,(XX13)                ; LDA XX13               \ If XX13 = 0, skip the following instruction
 767+ F161 FE 00                            cp      0                       ; BEQ LL138
 768+ F163 CA 69 F1                         jp      z,LL138_6502            ; .
 769+ F166 F2 85 F1                         jp      p, LLX117_6502          ; If XX13 is positive, it must be 95 (64) as 128 would be negative). This means (x1, y1) is on-screen but (x2, y2) isn't, so we jump
 770+ F169              ;-- If we get here, XX13 = 0 or 191, so (x1, y1) is off-screen and needs clipping
 771+ F169 CD 95 EF     LL138_6502:         call    LL118_6502              ; JSR LL118              \ Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 772+ F16C 3A 14 67                         ld      a,(XX13)                ; LDA XX13               \ If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to
 773+ F16F A7                               and     a
 774+ F170 F2 A8 F1                         jp      p,LL124_6502            ; BPL LL124              \ LL124 to return with a successfully clipped line
 775+ F173              ;-- If we get here, XX13 = 191 (128) (both coordinates areoff-screen)
 776+ F173 3A 0E EE     LL117_6502:         ld      a,(XX1510+1)            ; LDA XX15+1             \ If either of x1_hi or y1_hi are non-zero, jump to
 777+ F176 21 10 EE                         ld      hl,XX1532+1             ; ORA XX15+3             \ LL137 to return from the subroutine with the C flag
 778+ F179 B6                               or      (hl)
 779+ F17A C2 B0 F1                         jp      nz, LL137_6502          ; BNE LL137              \ set, as the line doesn't fit on-screen
 780+ F17D 3A 0F EE                         ld      a,(XX1532)              ; LDA XX15+2             \ If y1_lo > y-coordinate of the bottom of the screen
 781+ F180 FE 80                            cp      128                     ; CMP #Y*2               \ jump to LL137 to return from the subroutine with the
 782+ F182 D2 B0 F1                         jp      nc, LL137_6502          ; BCS LL137              \ C flag set, as the line doesn't fit on-screen
 783+ F185              ;-- If we get here, XX13 = 95 or 191, and in both cases (x2, y2) is off-screen, so we now need to swap the (x1, y1) and (x2, y2) coordinates around before doing the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
 784+ F185 2A 0D EE     LLX117_6502:        ld      hl,(XX1510)             ; LDX XX15               \ Swap x1_lo = x2_lo
 785+ F188 ED 5B 11 EE                      ld      de,(XX1554)
 786+ F18C ED 53 0D EE                      ld      (XX1510),de
 787+ F190 22 11 EE                         ld      (XX1554),hl
 788+ F193 2A 0F EE                         ld      hl,(XX1532)             ; LDX XX15+2             \ Swap y1_lo = y2_lo
 789+ F196 ED 5B 13 EE                      ld      de,(XX1576)
 790+ F19A ED 53 0F EE                      ld      (XX1532),de
 791+ F19E 22 13 EE                         ld      (XX1576),hl
 792+ F1A1 CD 95 EF                         call    LL118_6502              ; JSR LL118              \ Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 793+ F1A4 21 E1 C7                         ld      hl,SWAP
 794+ F1A7 35                               dec     (hl)                    ; DEC SWAP               \ Set SWAP = &FF to indicate that we just clipped the line at the (x2, y2) end by swapping the coordinates (the DEC does this as we set SWAP to 0 at the start of this subroutine)
 795+ F1A8 F1           LL124_6502:         pop     af                      ; PLA            SP+0    \ Restore Y from the stack so it gets preserved through
 796+ F1A9 32 1E EE                         ld      (Yreg),a                ; TAY                    \ the call to this subroutine
 797+ F1AC CD 3F F0                         call    LL146_6502              ; JMP LL146              \ Jump up to LL146 to move the low bytes of (x1, y1) and (x2, y2) into (X1, Y1) and (X2, Y2), and return from the subroutine with a successfully clipped line
 798+ F1AF C9                               ret                             ; then exit so we don't pop it twice
 799+ F1B0 F1           LL137_6502:         pop     af                      ; PLA            SP+0    \ Restore Y from the stack so it gets preserved through
 800+ F1B1 32 1E EE                         ld      (Yreg),a                ; TAY                    \ the call to this subroutine
 801+ F1B4                                  SetCarryFlag                    ; SEC                    \ Set the C flag to indicate the clipped line does not fit on-screen
 801+ F1B4 37          >                        scf
 802+ F1B5 C9                               ret                             ; RTS                    \ Return from the subroutine
 803+ F1B6                      ENDIF
# file closed: ../../Layer2Graphics/BBCEliteDirectMappingLL118.asm
 715  F1B6                  INCLUDE "../../Layer2Graphics/l2_draw_any_line.asm"
# file opened: ../../Layer2Graphics/l2_draw_any_line.asm
   1+ F1B6
   2+ F1B6 FF FF        starty                  DW     $FFFF
   3+ F1B8 FF FF        endy                    DW     $FFFF
   4+ F1BA CF           traingleColor           DB     $CF
   5+ F1BB                      IFDEF SOLIDTRIANGLES
   6+ F1BB ~            SaveArrayS1             DS     128*2
   7+ F1BB ~            SaveArrayS2             DS     128*2
   8+ F1BB                      ENDIF
   9+ F1BB                      IFDEF Add_l2_drawHorzClipY
  10+ F1BB ~            l2_drawHorzClipY:
  11+ F1BB ~            .ClipY:                 ex      de,hl                       ; get X1 into de
  12+ F1BB ~            .ClipDE:                bit     7,d
  13+ F1BB ~                                    jr      z,.DEPositive
  14+ F1BB ~            .DENegative:            ld      de,0
  15+ F1BB ~                                    jp      .ClipDEDone
  16+ F1BB ~            .DEPositive:            ld      a,d
  17+ F1BB ~                                    and     a
  18+ F1BB ~                                    jp      z,.ClipDE127
  19+ F1BB ~            .ClipDE256:             ld      de,127
  20+ F1BB ~                                    jp      .ClipDEDone
  21+ F1BB ~            .ClipDE127:             bit     7,e
  22+ F1BB ~                                    jp      z,.ClipDEDone
  23+ F1BB ~                                    ld      de,127
  24+ F1BB ~            .ClipDEDone:
  25+ F1BB ~            .AdjustStartY:          ld      hl,(starty)
  26+ F1BB ~                                    call    CompareHLDESgn           ; if de < HL
  27+ F1BB ~                                    jr      z,.AdjustEndY               ;
  28+ F1BB ~                                    jr      c,.AdjustEndY               ;
  29+ F1BB ~            .ClipStartY:            ld      (starty),de                 ; .
  30+ F1BB ~            .AdjustEndY:            ld      hl,(endy)                   ; is endy still uninitialised
  31+ F1BB ~            .InitEndY:              ld      a,h                         ;
  32+ F1BB ~                                    and     l                           ;
  33+ F1BB ~                                    cp      $FF                         ;
  34+ F1BB ~                                    jr      z,.ForceEndYSet
  35+ F1BB ~            .CheckEndY:             call    CompareHLDESgn           ; if de < HL
  36+ F1BB ~                                    ret     z
  37+ F1BB ~                                    ret     nc
  38+ F1BB ~            .ForceEndYSet:          ld      (endy),de
  39+ F1BB ~                                    ret
  40+ F1BB                      ENDIF
  41+ F1BB
  42+ F1BB
  43+ F1BB 2A 43 F2     l2_drawVertClip:        ld      hl,(y1)
  44+ F1BE ED 5B 47 F2                          ld      de,(y2)
  45+ F1C2 CD BC 73                             call    CompareHLDESgn
  46+ F1C5 30 01                                jr      nc,.y1ltey2
  47+ F1C7 EB                                   ex      de,hl
  48+ F1C8 CB 7C        .y1ltey2:               bit     7,h
  49+ F1CA CA D0 F1                             jp      z,.y1Positive
  50+ F1CD 21 00 00                             ld      hl,0
  51+ F1D0 7A           .y1Positive             ld      a,d
  52+ F1D1 A7                                   and     a
  53+ F1D2 CA DA F1                             jp      z,.y2lt255
  54+ F1D5 1E 7F                                ld      e,127
  55+ F1D7 C3 E1 F1                             jp      .y2Clipped
  56+ F1DA CB 7B        .y2lt255:               bit     7,e
  57+ F1DC CA E1 F1                             jp      z,.y2Clipped
  58+ F1DF 1E 7F                                ld      e,127
  59+ F1E1 ED 4B 41 F2  .y2Clipped:             ld      bc,(x1)
  60+ F1E5 45                                   ld      b,l
  61+ F1E6 53                                   ld      d,e
  62+ F1E7 1E BF                                ld      e,$BF
  63+ F1E9 C3 82 E8                             jp      l2_draw_vert_line_to                ; ">bc = row col d = to position, e = color"
  64+ F1EC
  65+ F1EC                          DISPLAY "TODO: May be able to optimise as x1 and x2 should already be 8 bit"
  66+ F1EC 2A 41 F2     l2_drawHorzClip:        ld      hl,(x1)
  67+ F1EF ED 5B 45 F2                          ld      de,(x2)
  68+ F1F3 CD BC 73                             call    CompareHLDESgn
  69+ F1F6 30 01                                jr      nc,.x1ltex2
  70+ F1F8 EB                                   ex      de,hl
  71+ F1F9 CB 7C        .x1ltex2:               bit     7,h
  72+ F1FB CA 01 F2                             jp      z,.x1Positive
  73+ F1FE 21 00 00                             ld      hl,0
  74+ F201 7A           .x1Positive             ld      a,d
  75+ F202 A7                                   and     a
  76+ F203 CA 08 F2                             jp      z,.x2Clipped
  77+ F206 1E FF                                ld      e,255
  78+ F208 ED 4B 43 F2  .x2Clipped:             ld      bc,(y1)
  79+ F20C 41                                   ld      b,c
  80+ F20D 4D                                   ld      c,l
  81+ F20E 53                                   ld      d,e
  82+ F20F 1E BF                                ld      e,$BF
  83+ F211 C3 C3 E7                             jp      l2_draw_horz_line_to                ; "bc = left side row,col, d right pixel, e = color"
  84+ F214
  85+ F214                      IFDEF Add_l2_drawVertClipY
  86+ F214 ~            l2_drawVertClipY:       bit     7,d                     ; i = (py1<0?0:py1);
  87+ F214 ~                                    jr      z,.PYIsOK
  88+ F214 ~            .SetPYTo0:              ld      de,0
  89+ F214 ~            .PYIsOK:                ld      hl,(starty)
  90+ F214 ~                                    IsHLEqu255
  91+ F214 ~                                    jp      z,.UpdateStartY
  92+ F214 ~                                    call    CompareHLDESgn       ; or starty > py
  93+ F214 ~                                    jr      nc,.UpdateStartY        ;
  94+ F214 ~                                    jp      .PrepareUpdateArray
  95+ F214 ~            .UpdateStartY:          ld      (starty),de
  96+ F214 ~            .PrepareUpdateArray:    JumpIfRegLTE c, 127, .UpdateCounters ; we loop from
  97+ F214 ~                                    ld      c,127
  98+ F214 ~            .UpdateEndY:            ld      (endy),bc               ; save BC to endy y as its now clamped, thsi frees up BC regsiters
  99+ F214 ~            .UpdateCounters:        ld      hl,ix                   ; get target array index and set it to
 100+ F214 ~                                    add     hl,de                   ; targetArray[de]
 101+ F214 ~                                    add     hl,de                   ; .
 102+ F214 ~                                    ld      a,c                     ; now set up B as an iterator
 103+ F214 ~                                    sub     b                       ; for py2 - py1 + 1 entries
 104+ F214 ~                                    inc     a                       ; .
 105+ F214 ~                                    ld      b,a                     ; .
 106+ F214 ~                                    ld      de,ix                   ; we don't need de anymore to move ix for faster instructions
 107+ F214 ~            .UpdateArray:           ld      (hl),de                 ; use sjasm fake as it does (hl)=e,inc hl, (hl)=d,inc hl
 108+ F214 ~                                    inc     a                       ; use a as a counter for the end when we update EndY
 109+ F214 ~                                    djnz    .UpdateArray            ; .
 110+ F214 ~                                    ret                             ; we are now done
 111+ F214                      ENDIF
 112+ F214
 113+ F214
 114+ F214              ; ">l2_draw_any_line, bc = y0,x0 de=y1,x1,a=color: determines if its horizontal, vertical or diagonal then hands off the work"
 115+ F214              ; b - y0 c - x0, d - y1 e - x1 a - colour
 116+ F214 08           l2_draw_any_line:       ex		af,af'              ; save colour into a'
 117+ F215 79                                   ld		a,c                 ; if x and e are the same its horizontal
 118+ F216 BB                                   cp		e
 119+ F217 28 08                                jr		z,.HorizontalLineCheck
 120+ F219 78                                   ld		a,b                 ; if b and d are the same its vertica;
 121+ F21A BA                                   cp		d
 122+ F21B 28 0E                                jr		z,.VerticalLine
 123+ F21D              ; use jp and get a free ret instruction optimisation
 124+ F21D 08           .DiagonalLine:		    ex		af,af'			     ; get colour back into a
 125+ F21E C3 D0 EA                             jp		l2_draw_diagonal
 126+ F221
 127+ F221 78           .HorizontalLineCheck:   ld      a,b
 128+ F222 BA                                   cp      d
 129+ F223 28 0B                                jr      z, .SinglePixel
 130+ F225 08           .HorizontalLine:        ex		af,af'              ; get colour back into a
 131+ F226 53                                   ld		d,e				    ; set d as target right pixel
 132+ F227 5F                                   ld		e,a				    ; e holds colour on this call
 133+ F228 C3 C3 E7                             jp		l2_draw_horz_line_to
 134+ F22B 08           .VerticalLine:          ex		af,af'
 135+ F22C 5F                                   ld		e,a				    ; e holds colour on this call
 136+ F22D C3 82 E8                             jp		l2_draw_vert_line_to
 137+ F230 08           .SinglePixel:           ex		af,af'              ; get colour back into a
 138+ F231                                      l2_plot_macro; jp      l2_plot_pixel
 138+ F231 78          >                        ld      a,b
 138+ F232             >                        JumpIfAGTENusng 192 ,.NoPlot
 138+ F232 FE C0       >                        cp     192
 138+ F234 D2 40 F2    >                        jp		nc,.NoPlot
 138+ F237 69          >                        ld      l,c
 138+ F238 CD 78 E0    >                        call    asm_l2_row_bank_select
 138+ F23B 67          >                        ld      h,a
 138+ F23C 3A FA E3    >                        ld      a,(line_gfx_colour)
 138+ F23F 77          >                        ld      (hl),a
 138+ F240             >.NoPlot:
 139+ F240 C9                                   ret
 140+ F241
 141+ F241 00 00        x1                      dw 0
 142+ F243 00 00        y1                      dw 0
 143+ F245 00 00        x2                      dw 0
 144+ F247 00 00        y2                      dw 0
 145+ F249 00 00        savex1                  dw 0
 146+ F24B 00 00        savey1                  dw 0
 147+ F24D 00 00        savex2                  dw 0
 148+ F24F 00 00        savey2                  dw 0
 149+ F251 00 00        temp                    dw 0
 150+ F253 00           longest:                DB 0
 151+ F254 00 00        x1Work:                 DW 0
 152+ F256 00 00        y1Work:                 DW 0
 153+ F258 00 00        x2Work:                 DW 0
 154+ F25A 00 00        y2Work:                 DW 0
 155+ F25C 00 00        x_pos:                  DW 0
 156+ F25E 00 00        y_pos:                  DW 0
 157+ F260 00 00        x_pos_end:              DW 0
 158+ F262 00 00        y_pos_end:              DW 0
 159+ F264 00 00        clip_xmax:              DW 0
 160+ F266 00 00        clip_xmin:              DW 0
 161+ F268 00 00        sign_x                  DW 0
 162+ F26A 00           sign_y                  DB 0
 163+ F26B 00 00        delta_x                 DW 0
 164+ F26D 00 00        delta_y                 DW 0
 165+ F26F 00 00        delta_y_x               DW 0 ; holds the compressed version for elite line draw
 166+ F271 00 00        delta_x_step            DW 0
 167+ F273 00 00        delta_y_step            DW 0
 168+ F275 00 00        linetemp                DW 0
 169+ F277 00 00        gradient                DW 0
 170+ F279 00 00        tSlope                  DW 0
 171+ F27B 00 00        msd                     DW 0
 172+ F27D 00 00        error                   DW 0
 173+ F27F 00           set_exit                DB 0
 174+ F280 00 00        rem                     DW 0
 175+ F282              InstrDECBC              equ $0B
 176+ F282              InstrINCBC              equ $03
 177+ F282              InstrDECIY              equ $2B
 178+ F282              InstrINCIY              equ $23
 179+ F282
 180+ F282              MACROAequBMinusC16:     MACRO   pA, pB, pC
 181+ F282 ~                                    ld      hl,(pB)                         ;       error = delta_y_step - delta_x;
 182+ F282 ~                                    ld      de,(pC)                         ; .
 183+ F282 ~                                    ClearCarryFlag                          ; .
 184+ F282 ~                                    sbc     hl,de                           ; .
 185+ F282 ~                                    ld      (pA),hl
 186+ F282                                      ENDM
 187+ F282              ;--- Swaps point 1 and point 2 around (i.e x1 y1 <--> x2 y2)
 188+ F282 2A 43 F2     SwapCoords:             ld      hl,(y1)                         ;       then swap point 1 and point 2
 189+ F285 ED 5B 47 F2                          ld      de,(y2)                         ;       .
 190+ F289 ED 53 43 F2                          ld      (y1),de                         ;       .
 191+ F28D 22 47 F2                             ld      (y2),hl                         ;       .
 192+ F290 2A 41 F2                             ld      hl,(x1)                         ;       .
 193+ F293 ED 5B 45 F2                          ld      de,(x2)                         ;       .
 194+ F297 ED 53 41 F2                          ld      (x1),de                         ;       .
 195+ F29B 22 45 F2                             ld      (x2),hl                         ;       .
 196+ F29E C9                                   ret
 197+ F29F
 198+ F29F                      ; DEFINE SPLITLINE 1
 199+ F29F
 200+ F29F                      ;DEFINE CLIPPED_LINEX 1
 201+ F29F                      DEFINE SPLITORLINEX  1
 202+ F29F                      IFDEF SPLITLINE
 202+ F29F ~
 203+ F29F ~            l2_draw_clipped_line:
 204+ F29F                      ENDIF
 205+ F29F                      IFDEF SPLITORLINEX
 206+ F29F              l2_draw_clipped_line:
 207+ F29F                      ENDIF
 208+ F29F                      IFDEF CLIPPED_LINEX
 208+ F29F ~
 209+ F29F ~            l2_draw_clipped_lineX:
 210+ F29F                      ENDIF
 211+ F29F                      IFDEF SPLITORLINEX
 212+ F29F 2A 43 F2                             ld      hl,(y1)                         ; if (y1 > y2)
 213+ F2A2 ED 5B 47 F2                          ld      de,(y2)                         ; .
 214+ F2A6 CD BC 73                             call    CompareHLDESgn                  ; .
 215+ F2A9 DA AF F2                             jp      c,.NoSwapCoords
 216+ F2AC CD 82 F2     .SwapCoords:            call    SwapCoords
 217+ F2AF              .NoSwapCoords:
 218+ F2AF ED 5B 43 F2  .CalcDX:                ld      de,(y1)                         ; Calculate |dy|
 219+ F2B3 2A 47 F2                             ld      hl,(y2)                         ; .
 220+ F2B6                                      ClearCarryFlag                          ; .
 220+ F2B6 B7          >                        or a
 221+ F2B7 ED 52                                sbc     hl,de                           ; .
 222+ F2B9 E5 FD E1                             ld      iy,hl                           ; iy = |dy|
 223+ F2BC ED 5B 41 F2  .CalcDy:                ld      de,(x1)                         ; Calculate |dx|
 224+ F2C0 2A 45 F2                             ld      hl,(x2)                         ; .
 225+ F2C3 06 00                                ld      b,0                             ; assume x1 < x2 and assume no negate needed
 226+ F2C5 CD BC 73                             call    CompareHLDESgn                  ;
 227+ F2C8 D2 CD F2                             jp      nc,.DxNoSwap                     ;
 228+ F2CB EB           .DxSwap:                ex      de,hl                           ; swap just x over
 229+ F2CC 04                                   inc     b                               ; and flag that we had to do it
 230+ F2CD              .DxNoSwap:              ClearCarryFlag                          ;
 230+ F2CD B7          >                        or a
 231+ F2CE ED 52                                sbc     hl,de                           ;
 232+ F2D0 E5 DD E1                             ld      ix,hl                           ; ix = |dx|
 233+ F2D3 DD 7C        .CheckForHuge:          ld      a,ixh                           ; if either dx or dy > 255 then split line
 234+ F2D5 FD B4                                or      iyh                             ; .
 235+ F2D7 C2 EB F2                             jp      nz, .BreakNeeded                ; .
 236+ F2DA DD 7D        .ChecktGT180:           ld      a,ixl
 237+ F2DC FE B4                                cp      180
 238+ F2DE D2 EB F2                             jp      nc,.BreakNeeded
 239+ F2E1 FD 7D                                ld      a,iyl
 240+ F2E3 FE B4                                cp      180
 241+ F2E5 D2 EB F2                             jp      nc,.BreakNeeded
 242+ F2E8 C3 4C F3                             jp      .noBreakNeeded
 243+ F2EB              .BreakNeeded:           ldCopy2Byte y1, savey1                  ;       savey1 = y1                     create savey1 (y1) to savey2 (y break)
 243+ F2EB 2A 43 F2    >                        ld       hl,(y1)
 243+ F2EE 22 4B F2    >                        ld       (savey1),hl
 244+ F2F1                                      ShiftIYRight1                           ;       savey2 = y1 + (work_dy/2)
 244+ F2F1 FD 7C       >               ld   a,iyh
 244+ F2F3 CB 3F       >               srl  a
 244+ F2F5 FD 67       >               ld   iyh,a
 244+ F2F7 FD 7D       >               ld   a,iyl
 244+ F2F9 1F          >               rra
 244+ F2FA FD 6F       >               ld   iyl,a
 245+ F2FC 2A 43 F2                             ld      hl,(y1)                         ;       .
 246+ F2FF                                      ClearCarryFlag                          ;       .
 246+ F2FF B7          >                        or a
 247+ F300 FD 54 FD 5D                          ld      de,iy
 248+ F304 ED 5A                                adc     hl,de                           ;       .
 249+ F306 22 4F F2                             ld      (savey2),hl                     ;       .
 250+ F309 22 43 F2                             ld      (y1),hl                         ;       y1     = savey2, y2 untouched   create y1 (break) to y2
 251+ F30C 05                                   dec     b                               ;       if b was 1 then decb would set z flag so we know that x1 > x2
 252+ F30D C2 13 F3                             jp      nz,.X1gtX2
 253+ F310 CD 82 F2     .X1lteX2:               call    SwapCoords
 254+ F313              .X1gtX2:                ldCopy2Byte x1, savex1                  ;       savex1 = x1                     create savex1 (x1) to savex2 (x break)
 254+ F313 2A 41 F2    >                        ld       hl,(x1)
 254+ F316 22 49 F2    >                        ld       (savex1),hl
 255+ F319                                      ShiftIXRight1                           ;       savex2 = x1 + (work_dx/2)
 255+ F319 DD 7C       >               ld   a,ixh
 255+ F31B CB 3F       >               srl  a
 255+ F31D DD 67       >               ld   ixh,a
 255+ F31F DD 7D       >               ld   a,ixl
 255+ F321 1F          >               rra
 255+ F322 DD 6F       >               ld   ixl,a
 256+ F324 2A 41 F2                             ld      hl,(x1)                         ;       .
 257+ F327                                      ClearCarryFlag                          ;       .
 257+ F327 B7          >                        or a
 258+ F328 DD 54 DD 5D                          ld      de,ix
 259+ F32C ED 5A                                adc     hl,de                           ;       .
 260+ F32E 22 4D F2                             ld      (savex2),hl                     ;       .
 261+ F331 22 41 F2                             ld      (x1),hl                         ;       x1     = savex1, x2 untouched  create x1 (break to x2)
 262+ F334                      ENDIF
 263+ F334                      IFDEF SPLITLINE
 264+ F334 ~                                    call    l2_draw_short_line              ;       drawshortLine
 265+ F334                      ENDIF
 266+ F334                      IFDEF CLIPPED_LINEX
 267+ F334 ~                                    call    l2_draw_clipped_line
 268+ F334                      ENDIF
 269+ F334                      IFDEF SPLITORLINEX
 270+ F334                                      ldCopyWord savex1,x1
 270+ F334             >                        ldCopy2Byte savex1, x1
 270+ F334 2A 49 F2    >                        ld       hl,(savex1)
 270+ F337 22 41 F2    >                        ld       (x1),hl
 271+ F33A                                      ldCopyWord savey1,y1
 271+ F33A             >                        ldCopy2Byte savey1, y1
 271+ F33A 2A 4B F2    >                        ld       hl,(savey1)
 271+ F33D 22 43 F2    >                        ld       (y1),hl
 272+ F340                                      ldCopyWord savex2,x2
 272+ F340             >                        ldCopy2Byte savex2, x2
 272+ F340 2A 4D F2    >                        ld       hl,(savex2)
 272+ F343 22 45 F2    >                        ld       (x2),hl
 273+ F346                                      ldCopyWord savey2,y2
 273+ F346             >                        ldCopy2Byte savey2, y2
 273+ F346 2A 4F F2    >                        ld       hl,(savey2)
 273+ F349 22 47 F2    >                        ld       (y2),hl
 274+ F34C              .noBreakNeeded:         // Falls straight into l2_draw_short_line
 275+ F34C                      ENDIF
 276+ F34C                      IFDEF SPLITLINE
 276+ F34C ~
 277+ F34C ~            l2_draw_short_line:     ; check out of bounds
 278+ F34C                      ENDIF
 279+ F34C                      IFDEF CLIPPED_LINEX
 280+ F34C ~            l2_draw_clipped_line:
 281+ F34C                      ENDIF
 282+ F34C                      IFDEF SPLITORLINEX
 283+ F34C 2A 41 F2     CheckForOnScreen:       ld      hl,(x1)
 284+ F34F ED 5B 45 F2                          ld      de,(x2)
 285+ F353 CB 7C        .X1X2NegativeCheck:     bit     7,h                             ; if they are both negative then bail out
 286+ F355 28 03                                jr      z,.X1X2NotNegative
 287+ F357 CB 7A                                bit     7,d
 288+ F359 C0           .X1X2IsNegative:        ret     nz
 289+ F35A 7C           .X1X2NotNegative:       ld      a,h                             ; if they are both not negative then if one is negative that is good
 290+ F35B AA                                   xor     d
 291+ F35C FA 67 F3                             jp      m,.X1X2SpanScreen
 292+ F35F 7C           .X1X2BothPositive:      ld      a,h                             ; if x1 or x2 high is zero then at least one pixel is on screen
 293+ F360 A7                                   and     a
 294+ F361 CA 67 F3                             jp      z,.X1X2SpanScreen
 295+ F364 7A                                   ld      a,d                             ; if x1 was > 255 then if x2 > 255 bail out
 296+ F365 A7                                   and     a
 297+ F366 C0                                   ret     nz
 298+ F367 2A 43 F2     .X1X2SpanScreen:        ld      hl,(y1)
 299+ F36A ED 5B 47 F2                          ld      de,(y2)
 300+ F36E CB 7C        .Y1Y2NegativeCheck:     bit     7,h                             ; if they are both negative then bail out
 301+ F370 28 03                                jr      z,.Y1Y2NotNegative
 302+ F372 CB 7A                                bit     7,d
 303+ F374 C0           .Y1Y2IsNegative:        ret     nz
 304+ F375 7C           .Y1Y2NotNegative:       ld      a,h                             ; if they are both not negative then if one is negative that is good
 305+ F376 AA                                   xor     d
 306+ F377 FA 89 F3                             jp      m,.Y1Y2SpanScreen
 307+ F37A 01 80 00     .Y1Y2BothPositive:      ld      bc,128                          ; if they are both positive and at least one is < 128 then carry on
 308+ F37D CD F0 73                             call    CompareHLBC
 309+ F380 38 07                                jr      c,.Y1Y2SpanScreen
 310+ F382 EB                                   ex      de,hl                           ; save y1 into de
 311+ F383 CD F0 73                             call    CompareHLBC
 312+ F386 38 01                                jr      c,.Y1Y2SpanScreen
 313+ F388 C9                                   ret
 314+ F389              .Y1Y2SpanScreen:
 315+ F389 CD D3 73     CheckForHorizontal:     call    CompareHLDESame                 ; de = saved y1 , hl = y2
 316+ F38C CA BB F1                             jp      z, l2_drawVertClip
 317+ F38F 2A 41 F2     CheckForVertical:       ld      hl,(x1)
 318+ F392 ED 5B 45 F2                          ld      de,(x2)
 319+ F396 CD D3 73                             call    CompareHLDESame
 320+ F399 CA EC F1                             jp      z, l2_drawHorzClip
 321+ F39C                                      ; Need horizontal and vertical optimisation code in at thispoint
 322+ F39C 2A 43 F2     CheckForSwap:           ld      hl,(y1)                         ; if (y1 > y2)
 323+ F39F ED 5B 47 F2                          ld      de,(y2)                         ; .
 324+ F3A3 CD BC 73                             call    CompareHLDESgn                  ; .
 325+ F3A6 DA AC F3                             jp      c,.NoSwapCoords
 326+ F3A9 CD 82 F2     .SwapCoords:            call    SwapCoords
 327+ F3AC                                      ; Default in sign and clip ranges, sign 16 bit for now
 328+ F3AC 21 00 00     .NoSwapCoords:          ld      hl,0                            ; clip_xmin = 0;
 329+ F3AF 22 66 F2                             ld      (clip_xmin),hl                  ; .
 330+ F3B2 2E FF                                ld      l,255                           ; clip xmax = 255;
 331+ F3B4 22 64 F2                             ld      (clip_xmax),hl                  ; .
 332+ F3B7 21 01 00                             ld      hl,1                            ; sign_x = 1
 333+ F3BA 22 68 F2                             ld      (sign_x),hl                     ; .
 334+ F3BD                                      ; if moving right to left then swap signs and clip
 335+ F3BD 2A 41 F2                             ld      hl,(x1)                         ; if x1 > x2
 336+ F3C0 ED 5B 45 F2                          ld      de,(x2)                         ; .
 337+ F3C4 CD BC 73                             call    CompareHLDESgn                  ; .
 338+ F3C7 38 2C                                jr      c,.X1tlX2                       ; .
 339+ F3C9 21 FF FF     .X1gteX2:               ld      hl, -1                          ;        sign_x = 01
 340+ F3CC 22 68 F2                             ld      (sign_x),hl                     ;        .
 341+ F3CF 2A 41 F2                             ld      hl,(x1)                         ;        x1 = -x1;
 342+ F3D2                                      macronegate16hl                         ;        .
 342+ F3D2 AF          >					xor 	a
 342+ F3D3 95          >					sub 	l
 342+ F3D4 6F          >					ld 		l,a
 342+ F3D5 9F          >					sbc 	a,a
 342+ F3D6 94          >					sub 	h
 342+ F3D7 67          >					ld 		h,a
 343+ F3D8 22 41 F2                             ld      (x1),hl                         ;        .
 344+ F3DB ED 5B 45 F2                          ld      de,(x2)                         ;        x2 = -x2;
 345+ F3DF                                      macronegate16de                         ;        .
 345+ F3DF AF          >					xor 	a
 345+ F3E0 93          >                    sub 	e
 345+ F3E1 5F          >                    ld 		e,a
 345+ F3E2 9F          >                    sbc 	a,a
 345+ F3E3 92          >                    sub 	d
 345+ F3E4 57          >                    ld 		d,a
 346+ F3E5 ED 53 45 F2                          ld      (x2),de                         ;        .
 347+ F3E9 21 01 FF                             ld      hl,-255                         ;        clip_xmin =-255;
 348+ F3EC 22 66 F2                             ld      (clip_xmin),hl                  ;        .
 349+ F3EF 21 00 00                             ld      hl,0                            ;        clip_xmax = 0;
 350+ F3F2 22 64 F2                             ld      (clip_xmax),hl                  ;        .
 351+ F3F5              .X1tlX2:                                                        ;
 352+ F3F5                                      ; calculate deltas
 353+ F3F5 2A 45 F2     .DxEquX2MinusX1:        ld      hl,(x2)                         ; delta_x = x2 - x1;
 354+ F3F8 ED 5B 41 F2                          ld      de,(x1)                         ; .
 355+ F3FC                                      ClearCarryFlag                          ; .
 355+ F3FC B7          >                        or a
 356+ F3FD ED 52                                sbc     hl,de                           ; .
 357+ F3FF 22 6B F2                             ld      (delta_x),hl                    ; .
 358+ F402 2A 47 F2     .DyEquY2MinusY1:        ld      hl,(y2)                         ; delta_y = y2 - y1;
 359+ F405 ED 5B 43 F2                          ld      de,(y1)                         ; .
 360+ F409                                      ClearCarryFlag                          ; .
 360+ F409 B7          >                        or a
 361+ F40A ED 52                                sbc     hl,de                           ; .
 362+ F40C 22 6D F2                             ld      (delta_y),hl                    ; .
 363+ F40F ED 5B 6B F2  .ScaleDeltaXY:          ld      de,(delta_x)                    ; we already have delta y but x could be negative
 364+ F413 06 00                                ld      b,0
 365+ F415 CB 7A                                bit     7,d
 366+ F417 CA 21 F4                             jp      z,.DeltaYABSDone                ; de = | de |, b = 1 to denote negative needs resetting
 367+ F41A 04                                   inc     b
 368+ F41B                                      macronegate16de
 368+ F41B AF          >					xor 	a
 368+ F41C 93          >                    sub 	e
 368+ F41D 5F          >                    ld 		e,a
 368+ F41E 9F          >                    sbc 	a,a
 368+ F41F 92          >                    sub 	d
 368+ F420 57          >                    ld 		d,a
 369+ F421              .DeltaYABSDone:
 370+ F421 ~            /*.ScaleHighLoop:         ld      a,d
 371+ F421 ~                                    or      h
 372+ F421 ~                                    jr      z,.HighScaleDone
 373+ F421 ~                                    ShiftDERight1
 374+ F421 ~                                    ShiftHLRight1
 375+ F421 ~                                    jp      .ScaleHighLoop
 376+ F421 ~            .HighScaleDone:
 377+ F421 ~            .LowScaleLoop:          ld      a,e
 378+ F421 ~                                    or      l
 379+ F421 ~                                    and     $80
 380+ F421 ~                                    jr      z,.LowScaleDone
 381+ F421 ~                                    ShiftDERight1
 382+ F421 ~                                    ShiftHLRight1
 383+ F421 ~                                    jp      .LowScaleLoop
 384+ F421 ~            .LowScaleDone:          bit     0,b
 385+ F421 ~                                    jr      z,.DeltaDone
 386+ F421 ~            .SortDXSign:            macronegate16de
 387+ F421 ~            .DeltaDone:             ld      (delta_x),de
 388+ F421 ~                                    ld      (delta_y),hl*/
 389+ F421 2A 6B F2     .DeltaXStepCalc:        ld     hl, (delta_x)
 390+ F424                                      ClearCarryFlag                          ; delta_x_step = 2 * delta_x;
 390+ F424 B7          >                        or a
 391+ F425 ED 6A                                adc     hl,hl                           ; .
 392+ F427 22 71 F2                             ld      (delta_x_step),hl               ; .
 393+ F42A 2A 6D F2     .DeltaYStepCalc:        ld     hl, (delta_y)
 394+ F42D                                      ClearCarryFlag                          ; delta_y_step = 2 * delta_y;
 394+ F42D B7          >                        or a
 395+ F42E ED 6A                                adc     hl,hl                           ; .
 396+ F430 22 73 F2                             ld      (delta_y_step),hl               ; .
 397+ F433 2A 41 F2                             ld      hl,(x1)                         ; x_pos = x1;
 398+ F436 22 5C F2                             ld      (x_pos),hl                      ; .
 399+ F439 ED 5B 43 F2                          ld      de,(y1)                         ; y_pos = y1;
 400+ F43D ED 53 5E F2                          ld      (y_pos),de                      ; .
 401+ F441                                      ; check if we are workign on dx or dy
 402+ F441 2A 6B F2     .CompareDxDy:           ld      hl,(delta_x)                    ; if (delta_x >= delta_y)
 403+ F444 ED 5B 6D F2                          ld      de,(delta_y)
 404+ F448 CD BC 73                             call    CompareHLDESgn
 405+ F44B DA 92 F6                             jp      c, LineDrawDxLTDy
 406+ F44E              ;.......................DxGteDy branch.............................................................................................
 407+ F44E 2A 73 F2     LineDrawDxGteDy:        ld      hl,(delta_y_step)               ;       error = delta_y_step - delta_x;
 408+ F451 ED 5B 6B F2                          ld      de,(delta_x)                    ;       .
 409+ F455                                      ClearCarryFlag                          ;       .
 409+ F455 B7          >                        or a
 410+ F456 ED 52                                sbc     hl,de                           ;       .
 411+ F458 22 7D F2                             ld      (error),hl                      ;       .
 412+ F45B                                      ZeroA                                   ;       set exit false (0 == false)
 412+ F45B AF          >                        xor a
 413+ F45C 32 7F F2                             ld      (set_exit),a                    ;       .
 414+ F45F                                      ; clipping of negative y1
 415+ F45F 2A 43 F2                             ld      hl,(y1)                         ;       if (y1 < 0)
 416+ F462 CB 7C                                bit     7,h                             ;       .
 417+ F464 CA FC F4                             jp      z,.y1GTE0                       ;       .
 418+ F467 2A 43 F2     .y1LT0:                 ld      hl,(y1)                         ;           temp = (2 * (0 - y1) - 1) * delta_x;
 419+ F46A                                      macronegate16hl                         ;               hl = |y1|
 419+ F46A AF          >					xor 	a
 419+ F46B 95          >					sub 	l
 419+ F46C 6F          >					ld 		l,a
 419+ F46D 9F          >					sbc 	a,a
 419+ F46E 94          >					sub 	h
 419+ F46F 67          >					ld 		h,a
 420+ F470                                      ClearCarryFlag
 420+ F470 B7          >                        or a
 421+ F471 ED 6A                                adc     hl,hl                           ;               hl = (2 * |y1|)
 422+ F473 2B                                   dec     hl                              ;               hl = (2 * |y1| - 1)
 423+ F474 ED 5B 6B F2                          ld      de,(delta_x)                    ;               hl = hl * delta_x
 424+ F478 CD 79 6B                             call    HLequHLmulDE2sc; replaces mulHLbyDE2sc                    ;               .
 425+ F47B 22 51 F2                             ld      (temp),hl                       ;               save to temp
 426+ F47E 44 4D                                ld      bc,hl                           ;            msd = temp / delta_y_step
 427+ F480 ED 5B 73 F2                          ld      de,(delta_y_step)               ;               BC = BC / DE, HL = BC % DE
 428+ F484 CD 79 71                             call    Floor_DivQ                      ;               .
 429+ F487 ED 43 7B F2                          ld      (msd),bc                        ;               .
 430+ F48B 2A 5C F2                             ld      hl,(x_pos)                      ;            x_pos += msd
 431+ F48E                                      ClearCarryFlag
 431+ F48E B7          >                        or a
 432+ F48F ED 4A                                adc     hl,bc                           ;            .
 433+ F491 22 5C F2                             ld      (x_pos),hl                      ;            .
 434+ F494 ED 5B 64 F2                          ld      de,(clip_xmax)                  ;            if (x_pos >= clip_xmax)
 435+ F498 CD D3 73                             call    CompareHLDESame                 ;            .
 436+ F49B CA A2 F4                             jp      z,.xposLTEClipxmax              ;            .
 437+ F49E CD BC 73                             call    CompareHLDESgn                  ;            .
 438+ F4A1 D0                                   ret     nc                              ;               return
 439+ F4A2 2A 5C F2     .xposLTEClipxmax:       ld      hl,(x_pos)                      ;            if (x_pos >= clip_xmin)
 440+ F4A5 ED 5B 66 F2                          ld      de,(clip_xmin)                  ;            .
 441+ F4A9 CD BC 73                             call    CompareHLDESgn                  ;            .
 442+ F4AC DA FC F4                             jp      c,.xposLTxmin                   ;            .
 443+ F4AF 2A 7B F2     .xposGTExmin:           ld      hl,(msd)                        ;               rem = temp - (msd * delta_y_step) (its really IY from floor_divq)
 444+ F4B2 ED 5B 73 F2                          ld      de,(delta_y_step)               ;                   de = msd * delta_y_step
 445+ F4B6 CD 79 6B                             call    HLequHLmulDE2sc; replaces mulHLbyDE2sc                    ;                   .
 446+ F4B9 EB                                   ex      de,hl                           ;                   .
 447+ F4BA 2A 51 F2                             ld      hl,(temp)                       ;                   hl = temp - de
 448+ F4BD                                      ClearCarryFlag                          ;                   .
 448+ F4BD B7          >                        or a
 449+ F4BE ED 52                                sbc     hl,de                           ;                   .
 450+ F4C0 22 80 F2                             ld      (rem),hl                        ;                   .
 451+ F4C3 11 00 00                             ld      de,0                            ;               y_pos = 0
 452+ F4C6 ED 53 5E F2                          ld      (y_pos),de                      ;               .
 453+ F4CA ED 5B 80 F2                          ld      de,(rem)                        ;               error -= rem + delta_x
 454+ F4CE                                      ClearCarryFlag
 454+ F4CE B7          >                        or a
 455+ F4CF ED 5A                                adc     hl,de                           ;                   de = rem+delta_x
 456+ F4D1 EB                                   ex      de,hl                           ;                   .
 457+ F4D2 2A 7D F2                             ld      hl,(error)                      ;                   hl = error - de
 458+ F4D5                                      ClearCarryFlag                          ;                   .
 458+ F4D5 B7          >                        or a
 459+ F4D6 ED 52                                sbc     hl,de                           ;                   .
 460+ F4D8 22 7D F2                             ld      (error),hl                      ;                   write to error
 461+ F4DB 2A 80 F2                             ld      hl,(rem)                        ;               if (rem > 0)
 462+ F4DE 7C                                   ld      a,h                             ;               .
 463+ F4DF B5                                   or      l                               ;               .
 464+ F4E0 CA F7 F4                             jp      z,.remLte0                      ;               .
 465+ F4E3 2A 5C F2     .remGT0:                ld      hl,(x_pos)                      ;                   x_pos += 1;
 466+ F4E6 23                                   inc     hl                              ;                   .
 467+ F4E7 22 5C F2                             ld      (x_pos),hl                      ;                   .
 468+ F4EA 2A 7D F2                             ld      hl,(error)                      ;                   error += delta_y_step;
 469+ F4ED ED 5B 73 F2                          ld      de,(delta_y_step)               ;                   .
 470+ F4F1                                      ClearCarryFlag                          ;                   .
 470+ F4F1 B7          >                        or a
 471+ F4F2 ED 5A                                adc     hl,de                           ;                   .
 472+ F4F4 22 7D F2                             ld      (error),hl                      ;                   .
 473+ F4F7 3E 01        .remLte0:               ld      a,1                             ;               set exit = true
 474+ F4F9 32 7F F2                             ld      (set_exit),a                    ;               .
 475+ F4FC              .xposLTxmin:
 476+ F4FC 3A 7F F2     .y1GTE0:                ld      a,(set_exit)                    ;           if (!set_exit && x1 < clip_xmin)
 477+ F4FF A7                                   and     a                               ;           .
 478+ F500 C2 90 F5                             jp      nz,.exit_false                  ;           .   Exit if set_exit is true
 479+ F503 2A 41 F2                             ld      hl,(x1)                         ;           .
 480+ F506 ED 5B 66 F2                          ld      de,(clip_xmin)                  ;           .   Exit if x1 > xmin
 481+ F50A CD BC 73                             call    CompareHLDESgn                  ;           .
 482+ F50D D2 90 F5                             jp      nc,.exit_false                  ;           .
 483+ F510 EB                                   ex      de,hl                           ;               temp = delta_y_step * (clip_xmin - x1)
 484+ F511 ED 5B 41 F2                          ld      de,(x1)                         ;                   (clip_xmin - x1) (already have clip_xmin in de)
 485+ F515                                      ClearCarryFlag                          ;                   .
 485+ F515 B7          >                        or a
 486+ F516 ED 52                                sbc     hl,de                           ;                   .
 487+ F518 ED 5B 73 F2                          ld      de,(delta_y_step)               ;                   hl = delta_y_step * (clip_xmin - x1)
 488+ F51C CD 79 6B                             call    HLequHLmulDE2sc; repalces mulHLbyDE2sc                    ;                   .
 489+ F51F 22 51 F2                             ld      (temp),hl                       ;                   .
 490+ F522 44 4D        .msdEQtempDIVdxstep:    ld      bc,hl                           ;               msd = temp / delta_x_step
 491+ F524 ED 5B 71 F2                          ld      de,(delta_x_step)               ;                  BC = BC / DE, HL = BC % DE
 492+ F528 CD 79 71                             call    Floor_DivQ                      ;                  .
 493+ F52B ED 43 7B F2                          ld      (msd),bc                        ;                  .
 494+ F52F E5 FD E1                             ld      iy,hl                           ;                  save BC%DE into HL (temp % delta x step0
 495+ F532 2A 5E F2     .yposPlusmsd:           ld      hl,(y_pos)                      ;               y_pos += msd
 496+ F535                                      ClearCarryFlag                          ;                   bc already is msd
 496+ F535 B7          >                        or a
 497+ F536 ED 4A                                adc     hl,bc                           ;                   hl += bc
 498+ F538 22 5E F2                             ld      (y_pos),hl                      ;                   .
 499+ F53B FD E5 E1                             ld      hl,iy                           ;               rem = temp % delta_x_step (which is in IY)
 500+ F53E 22 80 F2                             ld      (rem),hl                        ;               .
 501+ F541 2A 5E F2                             ld      hl,(y_pos)                      ;           if ((y_pos > 127) || (y_pos == 127 && rem >= delta_x))
 502+ F544 11 7F 00                             ld      de,127                          ;           .
 503+ F547 CD D3 73                             call    CompareHLDESame                 ;           .    if y_pos != clipxmax skip the abort test
 504+ F54A 20 0B                                jr      nz,.YPosNotClipymax             ;           .
 505+ F54C 2A 80 F2                             ld      hl,(rem)                        ;           .    if rem < delta_y  skip the abort test
 506+ F54F ED 5B 6B F2                          ld      de,(delta_x)                    ;           .
 507+ F553 CD BC 73                             call    CompareHLDESgn                  ;           .
 508+ F556 D8                                   ret     c                               ;           .
 509+ F557 EB           .YPosNotClipymax:       ex      de,hl                           ;           .    swap over xpos and max to compare xpos > xmax
 510+ F558 CD BC 73                             call    CompareHLDESgn                  ;           .    if xpos > clipxmax then return (i.e clipxmax - xpos had a carry)
 511+ F55B D8                                   ret     c
 512+ F55C 2A 66 F2     .yposLT127:             ld      hl,(clip_xmin)                  ;               x_pos = clip_xmin;
 513+ F55F 22 5C F2                             ld      (x_pos),hl                      ;               .
 514+ F562 2A 7D F2                             ld      hl,(error)                      ;               error += rem
 515+ F565 ED 5B 80 F2                          ld      de,(rem)                        ;               .
 516+ F569                                      ClearCarryFlag                          ;               .
 516+ F569 B7          >                        or a
 517+ F56A ED 5A                                adc     hl,de                           ;               .
 518+ F56C 22 7D F2                             ld      (error),hl                      ;               .
 519+ F56F 2A 80 F2                             ld      hl,(rem)                        ;               if (rem >= delta_x)
 520+ F572 ED 5B 6B F2                          ld      de,(delta_x)                    ;               .
 521+ F576 CD BC 73                             call    CompareHLDESgn                  ;               .
 522+ F579 DA 90 F5                             jp      c,.remLTDeltaX                  ;               .
 523+ F57C 2A 5E F2     .remGTEDeltaX:          ld      hl,(y_pos)                      ;                   y_pos++
 524+ F57F 23                                   inc     hl
 525+ F580 22 5E F2                             ld      (y_pos),hl
 526+ F583 2A 7D F2                             ld      hl,(error)                      ;                    error -= delta_x_step;
 527+ F586 ED 5B 71 F2                          ld      de,(delta_x_step)               ;                    .
 528+ F58A                                      ClearCarryFlag                          ;                    .
 528+ F58A B7          >                        or a
 529+ F58B ED 52                                sbc     hl,de                           ;                    .
 530+ F58D 22 7D F2                             ld      (error),hl                      ;                    .
 531+ F590              .remLTDeltaX:
 532+ F590 2A 45 F2     .exit_false:            ld      hl,(x2)                         ;           x_pos_end = x2;
 533+ F593 22 60 F2                             ld      (x_pos_end),hl                  ;           .
 534+ F596 2A 47 F2                             ld      hl,(y2)                         ;           if (y2 > 127)
 535+ F599 11 7F 00                             ld      de,127                          ;           .
 536+ F59C CD D3 73                             call    CompareHLDESame                 ;           .   if y2 is zero fails check
 537+ F59F CA F6 F5                             jp      z,.y2LTE127                     ;           .
 538+ F5A2 CD BC 73                             call    CompareHLDESgn                  ;           .   if y2 < 127 then there is carry so fails check
 539+ F5A5 DA F6 F5                             jp      c,.y2LTE127                      ;           .
 540+ F5A8 21 7F 00     .y2GT127:               ld      hl,127                          ;               temp = delta_x_step * (127 - y1) + delta_x;
 541+ F5AB ED 5B 43 F2                          ld      de,(y1)                         ;                   hl = 127-y1
 542+ F5AF                                      ClearCarryFlag                          ;
 542+ F5AF B7          >                        or a
 543+ F5B0 ED 52                                sbc     hl,de
 544+ F5B2 ED 5B 71 F2                          ld      de,(delta_x_step)               ;                   hl = delta_x_step * (127-y1)
 545+ F5B6 CD 79 6B                             call    HLequHLmulDE2sc; replacesmulHLbyDE2sc                    ;                   .
 546+ F5B9 ED 5B 6B F2                          ld      de,(delta_x)                    ;                   hl += delta_x
 547+ F5BD                                      ClearCarryFlag                          ;                   .
 547+ F5BD B7          >                        or a
 548+ F5BE ED 5A                                adc     hl,de                           ;                   .
 549+ F5C0 22 51 F2                             ld      (temp),hl
 550+ F5C3 44 4D                                ld      bc,hl
 551+ F5C5 ED 5B 73 F2                          ld      de,(delta_y_step)               ;               msd = temp / delta y step
 552+ F5C9 CD 79 71                             call    Floor_DivQ                      ;               .
 553+ F5CC ED 43 7B F2                          ld      (msd),bc                        ;               .
 554+ F5D0 2A 41 F2                             ld      hl,(x1)                         ;               x_pos_end = x1 + msd;
 555+ F5D3                                      ClearCarryFlag                          ;               .
 555+ F5D3 B7          >                        or a
 556+ F5D4 ED 4A                                adc     hl,bc                           ;               .
 557+ F5D6 22 60 F2                             ld      (x_pos_end),hl                  ;               .
 558+ F5D9 2A 7B F2                             ld      hl,(msd)                        ;               if ((temp - msd * delta_y_step) == 0) --x_pos_end
 559+ F5DC ED 5B 73 F2                          ld      de,(delta_y_step)               ;               .
 560+ F5E0 CD 79 6B                             call    HLequHLmulDE2sc; replacesmulHLbyDE2sc                    ;               .
 561+ F5E3 EB                                   ex      de,hl                           ;               .
 562+ F5E4 2A 51 F2                             ld      hl,(temp)                       ;               .
 563+ F5E7                                      ClearCarryFlag                          ;               .
 563+ F5E7 B7          >                        or a
 564+ F5E8 ED 52                                sbc     hl,de                           ;               .
 565+ F5EA 7C                                   ld      a,h                             ;               .
 566+ F5EB B5                                   or      l                               ;               .
 567+ F5EC C2 F6 F5                             jp      nz,.NotTheSame                  ;               .
 568+ F5EF 2A 60 F2     .IsTheSame:             ld      hl,(x_pos_end)                  ;                   --x_pos_end
 569+ F5F2 2B                                   dec     hl                              ;                   .
 570+ F5F3 22 60 F2                             ld      (x_pos_end),hl                  ;                   .
 571+ F5F6              .NotTheSame:
 572+ F5F6 2A 60 F2     .y2LTE127:              ld      hl,(x_pos_end)                  ;           x_pos_end = min (x_pos_end,clip_xmax) + 1
 573+ F5F9 ED 5B 64 F2                          ld      de,(clip_xmax)                  ;           .
 574+ F5FD CD BC 73                             call    CompareHLDESgn                  ;           .
 575+ F600 D2 0D F6                             jp      nc,.xposgtexmax                 ;           .
 576+ F603 2A 60 F2     .xposltxmax:            ld      hl,(x_pos_end)                  ;           .
 577+ F606 23                                   inc     hl                              ;               x_pos_end+1
 578+ F607 22 60 F2                             ld      (x_pos_end),hl                  ;               .
 579+ F60A C3 12 F6                             jp      .DoneXposAdjust                 ;               .
 580+ F60D 13           .xposgtexmax:           inc     de                              ;               else
 581+ F60E ED 53 60 F2                          ld      (x_pos_end),de                  ;               clip_xmax+1
 582+ F612 3A 68 F2     .DoneXposAdjust:        ld      a,(sign_x)                      ;           if (sign_x == -1)
 583+ F615 3C                                   inc     a
 584+ F616 C2 31 F6                             jp      nz,.SignNotMinus1
 585+ F619 2A 5C F2     .SignEquMinus1:         ld      hl,(x_pos)                      ;               x_pos = -x_pos;
 586+ F61C                                      macronegate16hl
 586+ F61C AF          >					xor 	a
 586+ F61D 95          >					sub 	l
 586+ F61E 6F          >					ld 		l,a
 586+ F61F 9F          >					sbc 	a,a
 586+ F620 94          >					sub 	h
 586+ F621 67          >					ld 		h,a
 587+ F622 22 5C F2                             ld      (x_pos),hl
 588+ F625 2A 60 F2                             ld      hl,(x_pos_end)                  ;               x_pos_end = -x_pos_end;
 589+ F628                                      macronegate16hl
 589+ F628 AF          >					xor 	a
 589+ F629 95          >					sub 	l
 589+ F62A 6F          >					ld 		l,a
 589+ F62B 9F          >					sbc 	a,a
 589+ F62C 94          >					sub 	h
 589+ F62D 67          >					ld 		h,a
 590+ F62E 22 60 F2                             ld      (x_pos_end),hl
 591+ F631              .y2LTE27:
 592+ F631              .SignNotMinus1:
 593+ F631 ED 5B 73 F2                          ld      de,(delta_y_step)               ;        delta_x_step -= delta_y_step;
 594+ F635 2A 71 F2                             ld      hl,(delta_x_step)               ;        .
 595+ F638                                      ClearCarryFlag                          ;        .
 595+ F638 B7          >                        or a
 596+ F639 ED 52                                sbc     hl,de                           ;        .
 597+ F63B 22 71 F2                             ld      (delta_x_step),hl               ;        .
 598+ F63E 2A 5C F2     .PlottingLoop:          ld      hl,(x_pos)                      ;        while (x_pos != x_pos_end)
 599+ F641 ED 5B 60 F2                          ld      de,(x_pos_end)                  ;        .
 600+ F645 CD D3 73                             call    CompareHLDESame                 ;        .
 601+ F648 C8                                   ret     z                               ;        .
 602+ F649 2A 5C F2                             ld      hl,(x_pos)                      ;               drawpixel at xpos, ypos, Colour
 603+ F64C 4D                                   ld      c,l                             ;               .
 604+ F64D 2A 5E F2                             ld      hl,(y_pos)                      ;               .
 605+ F650 45                                   ld      b,l                             ;               .
 606+ F651 3E BF                                ld      a,$BF                           ;               .
 607+ F653 CD FB E3     .PlotPixel:             call    l2_plot_pixel                   ;               .
 608+ F656 2A 7D F2                             ld      hl,(error)                      ;               if (error >= 0)
 609+ F659 CB 7C                                bit     7,h                             ;               .
 610+ F65B C2 75 F6                             jp      nz,.errorLT0                    ;               .
 611+ F65E 2A 5E F2     .errorGTE0:             ld	    hl,(y_pos)                      ;                   ++y_pos;
 612+ F661 23                                   inc	    hl                              ;                   .
 613+ F662 22 5E F2                             ld	    (y_pos),hl                      ;                   .
 614+ F665 2A 7D F2                             ld	    hl,(error)                      ;                   error -= delta_x_step;
 615+ F668 ED 5B 71 F2                          ld	    de,(delta_x_step)               ;                   .
 616+ F66C                                      ClearCarryFlag                          ;                   .
 616+ F66C B7          >                        or a
 617+ F66D ED 52                                sbc	    hl,de                           ;                   .
 618+ F66F 22 7D F2                             ld	    (error),hl                      ;                   .
 619+ F672 C3 82 F6                             jp      .DoneErrorAdjust                ;                   .
 620+ F675 2A 7D F2     .errorLT0:              ld	    hl,(error)                      ;                   error += delta_y_step;
 621+ F678 ED 5B 73 F2                          ld	    de,(delta_y_step)
 622+ F67C                                      ClearCarryFlag
 622+ F67C B7          >                        or a
 623+ F67D ED 5A                                adc	    hl,de
 624+ F67F 22 7D F2                             ld	    (error),hl
 625+ F682 ED 5B 68 F2  .DoneErrorAdjust:       ld      de,(sign_x)
 626+ F686 2A 5C F2                             ld      hl,(x_pos)
 627+ F689                                      ClearCarryFlag
 627+ F689 B7          >                        or a
 628+ F68A ED 5A                                adc     hl,de
 629+ F68C 22 5C F2                             ld      (x_pos),hl
 630+ F68F C3 3E F6                             jp      .PlottingLoop
 631+ F692              ;.......................DxGltDy branch.............................................................................................
 632+ F692              LineDrawDxLTDy:         ;ret
 633+ F692 2A 71 F2                             ld      hl,(delta_x_step)               ;       error = delta_x_step - delta_y;
 634+ F695 ED 5B 6D F2                          ld      de,(delta_y)
 635+ F699                                      ClearCarryFlag
 635+ F699 B7          >                        or a
 636+ F69A ED 52                                sbc     hl,de
 637+ F69C 22 7D F2                             ld      (error),hl
 638+ F69F                                      ZeroA                                   ;        set exit false (0 == false)
 638+ F69F AF          >                        xor a
 639+ F6A0 32 7F F2                             ld      (set_exit),a
 640+ F6A3 2A 41 F2                             ld      hl,(x1)                         ;        if (x1 < clip_xmin)
 641+ F6A6 ED 5B 66 F2                          ld      de,(clip_xmin)                  ;        .
 642+ F6AA CD BC 73                             call    CompareHLDESgn                  ;        .
 643+ F6AD D2 41 F7                             jp      nc,.x1GTEClipXmin               ;        .
 644+ F6B0 ED 5B 41 F2  .x1LTClipXmin:          ld      de,(x1)                         ;           temp = (2 * (cllp_xmin - x1) - 1) * delta_y;
 645+ F6B4 2A 66 F2                             ld      hl,(clip_xmin)                  ;               hl = clip_xmin - x1
 646+ F6B7                                      ClearCarryFlag                          ;               .
 646+ F6B7 B7          >                        or a
 647+ F6B8 ED 52                                sbc     hl,de                           ;               .
 648+ F6BA                                      ClearCarryFlag
 648+ F6BA B7          >                        or a
 649+ F6BB ED 6A                                adc     hl,hl                           ;               hl = (2* hl)
 650+ F6BD 2B                                   dec     hl                              ;               hl = (2 *  hl - 1)
 651+ F6BE ED 5B 6D F2                          ld      de,(delta_y)                    ;               hl = hl  * delta_y
 652+ F6C2 CD 79 6B                             call    HLequHLmulDE2sc; replacesmulHLbyDE2sc                    ;               .
 653+ F6C5 22 51 F2                             ld      (temp),hl                       ;               .
 654+ F6C8 44 4D                                ld      bc,hl                           ;            msd = temp / delta_x_step
 655+ F6CA ED 5B 71 F2                          ld      de,(delta_x_step)               ;               BC = BC / DE, HL = BC % DE
 656+ F6CE CD 79 71                             call    Floor_DivQ                      ;               .
 657+ F6D1 ED 43 7B F2                          ld      (msd),bc                        ;               .
 658+ F6D5 2A 5E F2                             ld      hl,(y_pos)                      ;            y_pos += msd
 659+ F6D8                                      ClearCarryFlag
 659+ F6D8 B7          >                        or a
 660+ F6D9 ED 4A                                adc     hl,bc                           ;            .
 661+ F6DB 22 5E F2                             ld      (y_pos),hl                      ;            .
 662+ F6DE 11 7F 00                             ld      de,127                          ;            if (y_pos >= 127)
 663+ F6E1 CD D3 73                             call    CompareHLDESame                 ;            .
 664+ F6E4 CA EB F6                             jp      z,.yposGT127                    ;            .
 665+ F6E7 CD BC 73                             call    CompareHLDESgn                  ;            .
 666+ F6EA D0                                   ret     nc                              ;               return
 667+ F6EB 2A 5E F2     .yposGT127:             ld      hl,(y_pos)                      ;            if (y_pos >= 0)
 668+ F6EE CB 7C                                bit     7,h
 669+ F6F0 C2 41 F7                             jp      nz,.yposLT0
 670+ F6F3 2A 7B F2     .yposGT0:               ld      hl,(msd)                        ;               rem = temp - (msd * delta_x_step)
 671+ F6F6 ED 5B 71 F2                          ld      de,(delta_x_step)               ;                   de = msd * delta_x_step
 672+ F6FA CD 79 6B                             call   HLequHLmulDE2sc; replaces mulHLbyDE2sc                    ;                   .
 673+ F6FD EB                                   ex      de,hl                           ;                   .
 674+ F6FE 2A 51 F2                             ld      hl,(temp)                       ;                   hl = temp - de
 675+ F701                                      ClearCarryFlag                          ;                   .
 675+ F701 B7          >                        or a
 676+ F702 ED 52                                sbc     hl,de                           ;                   .
 677+ F704 22 80 F2                             ld      (rem),hl                        ;                   .
 678+ F707 ED 5B 66 F2                          ld      de,(clip_xmin)                  ;               x_pos = clip_xmin
 679+ F70B ED 53 5C F2                          ld      (x_pos),de                      ;               .
 680+ F70F ED 5B 80 F2                          ld      de,(rem)                        ;               error -= rem + delta_y
 681+ F713                                      ClearCarryFlag                          ;               .
 681+ F713 B7          >                        or a
 682+ F714 ED 5A                                adc     hl,de                           ;                   de = rem+delta_x
 683+ F716 EB                                   ex      de,hl                           ;                   .
 684+ F717 2A 7D F2                             ld      hl,(error)                      ;                   hl = error - de
 685+ F71A                                      ClearCarryFlag                          ;                   .
 685+ F71A B7          >                        or a
 686+ F71B ED 52                                sbc     hl,de                           ;                   .
 687+ F71D 22 7D F2                             ld      (error),hl                      ;                   .
 688+ F720 2A 80 F2                             ld      hl,(rem)                        ;               if (rem > 0)
 689+ F723 7C                                   ld      a,h                             ;               .
 690+ F724 B5                                   or      l                               ;               .
 691+ F725 CA 3C F7                             jp      z,.remLte0                      ;               .
 692+ F728 2A 5E F2     .remGT0:                ld      hl,(y_pos)                      ;                   y_pos += 1;
 693+ F72B 23                                   inc     hl
 694+ F72C 22 5E F2                             ld      (y_pos),hl
 695+ F72F 2A 7D F2                             ld      hl,(error)                      ;                   error += delta_x_step;
 696+ F732 ED 5B 71 F2                          ld      de,(delta_x_step)
 697+ F736                                      ClearCarryFlag
 697+ F736 B7          >                        or a
 698+ F737 ED 5A                                adc     hl,de
 699+ F739 22 7D F2                             ld      (error),hl
 700+ F73C 3E 01        .remLte0:               ld      a,1                             ;               set exit = true
 701+ F73E 32 7F F2                             ld      (set_exit),a                    ;               .
 702+ F741
 703+ F741              .yposLT0:
 704+ F741 3A 7F F2     .x1GTEClipXmin:         ld      a,(set_exit)                    ;        if (!set_exit && y1 < 0)
 705+ F744 A7                                   and     a                               ;        .
 706+ F745 C2 CF F7                             jp      nz,.exit_false                  ;        .  if exit is 1 then its true so exit branch
 707+ F748 2A 43 F2                             ld      hl,(y1)                         ;        .  if y1 is positive (including 0) then exit branch
 708+ F74B CB 7C                                bit     7,h                             ;        .
 709+ F74D CA CF F7                             jp      z,.exit_false                   ;        .
 710+ F750 2A 43 F2                             ld      hl,(y1)                         ;           temp = delta_x_step * (0 - y1)
 711+ F753                                      macronegate16hl                         ;           .
 711+ F753 AF          >					xor 	a
 711+ F754 95          >					sub 	l
 711+ F755 6F          >					ld 		l,a
 711+ F756 9F          >					sbc 	a,a
 711+ F757 94          >					sub 	h
 711+ F758 67          >					ld 		h,a
 712+ F759 ED 5B 71 F2                          ld      de,(delta_x_step)               ;           .       hl = delta_x_step * (- y1)
 713+ F75D CD 79 6B                             call    HLequHLmulDE2sc; replacesmulHLbyDE2sc                    ;           .
 714+ F760 22 51 F2                             ld      (temp),hl                       ;           .
 715+ F763 44 4D        .msdEQtempDIVdxstep:    ld      bc,hl                           ;           msd = temp / delta_y_step
 716+ F765 ED 5B 73 F2                          ld      de,(delta_y_step)               ;               BC = BC / DE, HL = BC % DE
 717+ F769 CD 79 71                             call    Floor_DivQ                      ;               .
 718+ F76C ED 43 7B F2                          ld      (msd),bc                        ;               .
 719+ F770 E5 FD E1                             ld      iy,hl                           ;               same remainders (which is also mod result)
 720+ F773 22 80 F2                             ld      (rem),hl                        ;           rem = temp % delta_y_step (swapped from being after x_pos += msd)
 721+ F776 2A 5C F2     .yposPlusmsd:           ld      hl,(x_pos)                      ;           x_pos += msd
 722+ F779                                      ClearCarryFlag                          ;           .   bc already is msd
 722+ F779 B7          >                        or a
 723+ F77A ED 4A                                adc     hl,bc                           ;           .   hl += bc
 724+ F77C 22 5C F2                             ld      (x_pos),hl                      ;           .
 725+ F77F 2A 5C F2                             ld      hl,(x_pos)                      ;           if ((x_pos > clip_xmax) || (x_pos == clip_xmax && rem >= delta_y))
 726+ F782 ED 5B 64 F2                          ld      de,(clip_xmax)                  ;           .
 727+ F786 CD D3 73                             call    CompareHLDESame                 ;           .    if xpos != clipxmax skip the abort test
 728+ F789 20 0B                                jr      nz,.XPosNotClipxmax             ;           .
 729+ F78B 2A 80 F2                             ld      hl,(rem)                        ;           .    if rem < delta_y  skip the abort test
 730+ F78E ED 5B 6D F2                          ld      de,(delta_y)                    ;           .
 731+ F792 CD BC 73                             call    CompareHLDESgn                  ;           .
 732+ F795 D8                                   ret     c                               ;           .
 733+ F796 EB           .XPosNotClipxmax:       ex      de,hl                           ;           .    swap over xpos and max to compare xpos > xmax
 734+ F797 CD BC 73                             call    CompareHLDESgn                  ;           .    if xpos > clipxmax then return (i.e clipxmax - xpos had a carry)
 735+ F79A D8                                   ret     c
 736+ F79B 21 00 00     .xposLT127:             ld      hl,0                            ;           y_pos = 0;
 737+ F79E 22 5E F2                             ld      (y_pos),hl                      ;           .
 738+ F7A1 2A 7D F2                             ld      hl,(error)                      ;           error += rem
 739+ F7A4 ED 5B 80 F2                          ld      de,(rem)                        ;           .
 740+ F7A8                                      ClearCarryFlag                          ;           .
 740+ F7A8 B7          >                        or a
 741+ F7A9 ED 5A                                adc     hl,de                           ;           .
 742+ F7AB 22 7D F2                             ld      (error),hl                      ;           .
 743+ F7AE 2A 80 F2                             ld      hl,(rem)                        ;           if (rem >= delta_y)
 744+ F7B1 ED 5B 6D F2                          ld      de,(delta_y)                    ;           .
 745+ F7B5 CD BC 73                             call    CompareHLDESgn                  ;           .
 746+ F7B8 DA CF F7                             jp      c,.remLTDeltaY                  ;           .
 747+ F7BB 2A 5C F2     .remGTEDeltaY:          ld      hl,(x_pos)                      ;                x_pos++
 748+ F7BE 23                                   inc     hl
 749+ F7BF 22 5C F2                             ld      (x_pos),hl
 750+ F7C2 2A 7D F2                             ld      hl,(error)                      ;                error -= delta_y_step;
 751+ F7C5 ED 5B 73 F2                          ld      de,(delta_y_step)               ;                .
 752+ F7C9                                      ClearCarryFlag                          ;                .
 752+ F7C9 B7          >                        or a
 753+ F7CA ED 52                                sbc     hl,de                           ;                .
 754+ F7CC 22 7D F2                             ld      (error),hl                      ;                .
 755+ F7CF              .remLTDeltaY:
 756+ F7CF 2A 47 F2     .exit_false:            ld      hl,(y2)                         ;           y_pos_end = y2;
 757+ F7D2 22 62 F2                             ld      (y_pos_end),hl                  ;           .
 758+ F7D5 2A 45 F2                             ld      hl,(x2)                         ;           if (x2 > clip_xmax)
 759+ F7D8 ED 5B 64 F2                          ld      de,(clip_xmax)                  ;           .
 760+ F7DC CD D3 73                             call    CompareHLDESame                 ;           .
 761+ F7DF CA 36 F8                             jp      z,.x2LTEclipxmax                ;           .
 762+ F7E2 CD BC 73                             call    CompareHLDESgn                  ;           .
 763+ F7E5 DA 36 F8                             jp      c,.x2LTEclipxmax                ;           .
 764+ F7E8 2A 64 F2     .x2GTclipxmax:          ld      hl,(clip_xmax)                  ;               temp = delta_y_step * (clip_xmax - x1) + delta_y;
 765+ F7EB ED 5B 41 F2                          ld      de,(x1)                         ;                   hl = 127-y1
 766+ F7EF                                      ClearCarryFlag                          ;
 766+ F7EF B7          >                        or a
 767+ F7F0 ED 52                                sbc     hl,de
 768+ F7F2 ED 5B 73 F2                          ld      de,(delta_y_step)               ;                   hl = delta_x_step * (clip_xmax - x1)
 769+ F7F6 CD 79 6B                             call    HLequHLmulDE2sc; replacesmulHLbyDE2sc                    ;                   .
 770+ F7F9 ED 5B 6D F2                          ld      de,(delta_y)                    ;                   hl += delta_y
 771+ F7FD                                      ClearCarryFlag                          ;                   .
 771+ F7FD B7          >                        or a
 772+ F7FE ED 5A                                adc     hl,de                           ;                   .
 773+ F800 22 51 F2                             ld      (temp),hl
 774+ F803 44 4D                                ld      bc,hl
 775+ F805 ED 5B 71 F2                          ld      de,(delta_x_step)               ;               msd = temp / delta x step
 776+ F809 CD 79 71                             call    Floor_DivQ                      ;               .
 777+ F80C ED 43 7B F2                          ld      (msd),bc                        ;               .
 778+ F810 2A 43 F2                             ld      hl,(y1)                         ;               y_pos_end = y1 + msd;
 779+ F813                                      ClearCarryFlag                          ;               .
 779+ F813 B7          >                        or a
 780+ F814 ED 4A                                adc     hl,bc                           ;               .
 781+ F816 22 62 F2                             ld      (y_pos_end),hl                  ;               .
 782+ F819 2A 7B F2                             ld      hl,(msd)                        ;               if ((temp - msd * delta_x_step) == 0) --y_pos_end
 783+ F81C ED 5B 71 F2                          ld      de,(delta_x_step)               ;               .
 784+ F820 CD 79 6B                             call    HLequHLmulDE2sc; replacesmulHLbyDE2sc                    ;               .
 785+ F823 EB                                   ex      de,hl                           ;               .
 786+ F824 2A 51 F2                             ld      hl,(temp)                       ;               .
 787+ F827                                      ClearCarryFlag                          ;               .
 787+ F827 B7          >                        or a
 788+ F828 ED 52                                sbc     hl,de                           ;               .
 789+ F82A 7C                                   ld      a,h                             ;               .
 790+ F82B B5                                   or      l                               ;               .
 791+ F82C C2 36 F8                             jp      nz,.NotTheSame                  ;               .
 792+ F82F 2A 62 F2     .IsTheSame:             ld      hl,(y_pos_end)                  ;                   --x_pos_end
 793+ F832 2B                                   dec     hl                              ;                   .
 794+ F833 22 62 F2                             ld      (y_pos_end),hl                  ;                   .
 795+ F836              .NotTheSame:
 796+ F836 2A 62 F2     .x2LTEclipxmax:         ld      hl,(y_pos_end)                  ;           y_pos_end = min(y_pos_end, clip_ymax) + 1
 797+ F839 11 7F 00                             ld      de,127                          ;           .
 798+ F83C CD BC 73                             call    CompareHLDESgn                  ;           .
 799+ F83F D2 4C F8                             jp      nc,.yposgteymax                 ;           .
 800+ F842 2A 62 F2     .yposltymax:            ld      hl,(y_pos_end)                  ;           .
 801+ F845 23                                   inc     hl                              ;           .
 802+ F846 22 62 F2                             ld      (y_pos_end),hl                  ;           .
 803+ F849 C3 51 F8                             jp      .DoneYposAdjust                 ;           .
 804+ F84C 13           .yposgteymax:           inc     de                              ;           .
 805+ F84D ED 53 62 F2                          ld      (y_pos_end),de                  ;           .
 806+ F851 3A 68 F2     .DoneYposAdjust:        ld      a,(sign_x)                      ;           if (sign_x == -1)
 807+ F854 3C                                   inc     a
 808+ F855 C2 70 F8                             jp      nz,.SignNotMinus1
 809+ F858 2A 5C F2     .SignEquMinus1:         ld      hl,(x_pos)                      ;               x_pos = -x_pos;
 810+ F85B                                      macronegate16hl
 810+ F85B AF          >					xor 	a
 810+ F85C 95          >					sub 	l
 810+ F85D 6F          >					ld 		l,a
 810+ F85E 9F          >					sbc 	a,a
 810+ F85F 94          >					sub 	h
 810+ F860 67          >					ld 		h,a
 811+ F861 22 5C F2                             ld      (x_pos),hl
 812+ F864 2A 60 F2                             ld      hl,(x_pos_end)                  ;               x_pos_end = -x_pos_end;
 813+ F867                                      macronegate16hl
 813+ F867 AF          >					xor 	a
 813+ F868 95          >					sub 	l
 813+ F869 6F          >					ld 		l,a
 813+ F86A 9F          >					sbc 	a,a
 813+ F86B 94          >					sub 	h
 813+ F86C 67          >					ld 		h,a
 814+ F86D 22 60 F2                             ld      (x_pos_end),hl
 815+ F870 ED 5B 71 F2  .SignNotMinus1:         ld      de,(delta_x_step)               ;        delta_y_step -= delta_x_step;
 816+ F874 2A 73 F2                             ld      hl,(delta_y_step)               ;        .
 817+ F877                                      ClearCarryFlag                          ;        .
 817+ F877 B7          >                        or a
 818+ F878 ED 52                                sbc     hl,de                           ;        .
 819+ F87A 22 73 F2                             ld      (delta_y_step),hl               ;        .
 820+ F87D 2A 5E F2     .PlottingLoop:          ld      hl,(y_pos)                      ;        while (y_pos != y_pos_end)
 821+ F880 ED 5B 62 F2                          ld      de,(y_pos_end)
 822+ F884 CD D3 73                             call    CompareHLDESame
 823+ F887 C8                                   ret     z
 824+ F888 2A 5C F2     .PlotPixel:             ld      hl,(x_pos)
 825+ F88B 4D                                   ld      c,l
 826+ F88C 2A 5E F2                             ld      hl,(y_pos)
 827+ F88F 45                                   ld      b,l
 828+ F890 3E BF                                ld      a,$BF
 829+ F892 CD FB E3                             call    l2_plot_pixel                   ;               drawpixel at xpos, ypos, Colour
 830+ F895 2A 7D F2                             ld      hl,(error)                      ;               if (error >= 0)
 831+ F898 CB 7C                                bit     7,h
 832+ F89A C2 BA F8                             jp      nz,.errorLT0
 833+ F89D 2A 5C F2     .errorGTE0:             ld	    hl,(x_pos)                      ;                   ++x_pos
 834+ F8A0 ED 5B 68 F2                          ld      de,(sign_x)
 835+ F8A4                                      ClearCarryFlag
 835+ F8A4 B7          >                        or a
 836+ F8A5 ED 5A                                adc     hl,de
 837+ F8A7 22 5C F2                             ld	    (x_pos),hl
 838+ F8AA 2A 7D F2                             ld	    hl,(error)                      ;                   error -= delta_y_step;
 839+ F8AD ED 5B 73 F2                          ld	    de,(delta_y_step)
 840+ F8B1                                      ClearCarryFlag
 840+ F8B1 B7          >                        or a
 841+ F8B2 ED 52                                sbc	    hl,de
 842+ F8B4 22 7D F2                             ld	    (error),hl
 843+ F8B7 C3 C7 F8                             jp      .DoneErrorAdjust
 844+ F8BA 2A 7D F2     .errorLT0:              ld	    hl,(error)                      ;                   error += delta_x_step;
 845+ F8BD ED 5B 71 F2                          ld	    de,(delta_x_step)
 846+ F8C1                                      ClearCarryFlag
 846+ F8C1 B7          >                        or a
 847+ F8C2 ED 5A                                adc	    hl,de
 848+ F8C4 22 7D F2                             ld	    (error),hl
 849+ F8C7 2A 5E F2     .DoneErrorAdjust:       ld      hl,(y_pos)
 850+ F8CA 23                                   inc     hl
 851+ F8CB 22 5E F2                             ld      (y_pos),hl
 852+ F8CE C3 7D F8                             jp      .PlottingLoop
 853+ F8D1                      ENDIF
 854+ F8D1
 855+ F8D1
 856+ F8D1 21 41 F2     l2_draw_6502_line:      ld      hl,x1                           ; copy from currnet position to 6502 variables
 857+ F8D4 11 0D EE                             ld      de,XX1510
 858+ F8D7 01 08 00                             ld      bc,4*2
 859+ F8DA ED B0                                ldir
 860+ F8DC CD FD EF                             call    LL145_6502                      ; perform 6502 version
 861+ F8DF D8                                   ret     c                               ; returns if carry is set as its a no draw
 862+ F8E0 21 00 00     .CopyBackResults:       ld      hl,0                            ; Clear out high bytes
 863+ F8E3 22 41 F2                             ld      (x1),hl
 864+ F8E6 22 43 F2                             ld      (y1),hl
 865+ F8E9 22 45 F2                             ld      (x2),hl
 866+ F8EC 22 47 F2                             ld      (y2),hl
 867+ F8EF 3A 0D EE                             ld      a,(XX1510)                      ; write low bytes with actual values to plot from XX1510
 868+ F8F2 32 41 F2                             ld      (x1),a
 869+ F8F5 4F                                   ld      c,a
 870+ F8F6 3A 0E EE                             ld      a,(XX1510+1)
 871+ F8F9 32 43 F2                             ld      (y1),a
 872+ F8FC 47                                   ld      b,a
 873+ F8FD 3A 0F EE                             ld      a,(XX1510+2)
 874+ F900 32 45 F2                             ld      (x2),a
 875+ F903 5F                                   ld      e,a
 876+ F904 3A 10 EE                             ld      a,(XX1510+3)
 877+ F907 32 47 F2                             ld      (y2),a
 878+ F90A 57                                   ld      d,a
 879+ F90B 3E FF                                ld      a,$FF
 880+ F90D                                      ClearCarryFlag
 880+ F90D B7          >                        or a
 881+ F90E C9                                   ret
 882+ F90F                                 ;     call    l2_draw_clipped_line
 883+ F90F              ;                        call    l2_draw_diagonal                ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
 884+ F90F              ;................................................................
 885+ F90F 00 00        result                  dw      0
 886+ F911              ;    swap = 0;
 887+ F911              ;    if (y1 > y2)
 888+ F911              ;    draws line from x1,y1 to x2,y2 memory locations in colour held in a
 889+ F911              l2_draw_elite_line:     ;............................................................
 890+ F911 2A 26 C0                             ld      hl,(UBnKzlo)
 891+ F914 7C                                   ld      a,h
 892+ F915 A7                                   and     a
 893+ F916 C2 1B F9                             jp      nz,.noBreak
 894+ F919 DD 01        .DoBreak:               break
 895+ F91B              .noBreak:
 896+ F91B 2A 43 F2                             ld      hl,(y1)                         ; if (y1 > y2)
 897+ F91E ED 5B 47 F2                          ld      de,(y2)                         ; .
 898+ F922 CD BC 73                             call    CompareHLDESgn                  ; .
 899+ F925 DA 2B F9                             jp      c,.NoSwapCoords                 ;
 900+ F928              ;        swapp1p2();
 901+ F928 CD 82 F2     .SwapCoords:            call    SwapCoords                      ;       swap them so y1 <= y2
 902+ F92B 2A 41 F2     .NoSwapCoords:          ld      hl,(x1)                         ; hl = x1
 903+ F92E ED 5B 45 F2                          ld      de,(x2)                         ; de = x2
 904+ F932 ED 4B 43 F2                          ld      bc,(y1)                         ; bc = y1
 905+ F936 DD 2A 47 F2                          ld      ix,(y2)                         ; ix = y2
 906+ F93A              .CheckForVertical:
 907+ F93A              .CheckForHorizontal:
 908+ F93A FD 26 80                             ld      iyh,128                         ; iyh = xx13 = 128
 909+ F93D              ;    xx13 = 128;
 910+ F93D              ;    if (x2 >= 0 && x2 <= 255 && y2 >= 0 && y2 <= 127)
 911+ F93D 7A                                   ld      a,d                             ; if (x2 >= 0 && x2 <= 255 && y2 >= 0 && y2 <= 127)
 912+ F93E DD B4                                or      ixh                             ; .  [if x2 and y2 > 255 goto point2clip]
 913+ F940 20 09                                jr      nz,.Point2Clip                  ; .  .
 914+ F942 DD 7D                                ld      a,ixl                           ; .  [if y2 low > 127 goto point2clip]
 915+ F944 CB 7F                                bit     7,a                             ; .  .
 916+ F946 20 03                                jr      nz,.Point2Clip                  ; .  .
 917+ F948              ;        xx13 = 0;
 918+ F948 FD 26 00     .Point2NoClip:          ld      iyh,0                           ;       iyh = xx13 = 0
 919+ F94B              ;    if (x1 >= 0 && x1 <= 255 && y1 >= 0 && y1 <= 127)
 920+ F94B 7C           .Point2Clip:            ld      a,h                             ; if (x1 >= 0 && x1 <= 255 && y1 >= 0 && y1 <= 127)
 921+ F94C B0                                   or      b                               ; . [ if x1 or y1 > 255 goto clip needed]
 922+ F94D C2 5E F9                             jp      nz,.ClipNeeded                  ; .
 923+ F950 CB 79                                bit     7,c                             ; . [ if y1 low > 127 goto clip needed]
 924+ F952 C2 5E F9                             jp      nz,.ClipNeeded                  ; .
 925+ F955              ;        if (xx13 != 0)
 926+ F955 FD 7C        .ClipPoint1:            ld      a,iyh                           ;       if (xx13 = 0)
 927+ F957 A7                                   and     a                               ;       .
 928+ F958 CA 55 FA                             jp      z,.ClipComplete                 ;               clipping not needed so treat as done an ddraw the line
 929+ F95B FD 26 40                             ld      iyh,64                          ;       else xx13 = 64 (xx13 /2 but if xx13 is 0 it never hits here so can just set to 64)
 930+ F95E              ;.......................LL138
 931+ F95E FD 7C        .ClipNeeded:            ld      a,iyh                           ; if (xx13 == 128)
 932+ F960 CB 7F                                bit     7,a                             ; . [ jump if bit 7 is not set so <> 128]
 933+ F962 CA 9B F9                             jp      z,.xx13Not128                   ; .
 934+ F965 7C           .xx13Is128:             ld      a,h                             ;       if (x1 < 0 && x2 < 0)
 935+ F966 A2                                   and     d                               ;       . [ x1 and x2 high bits 7 are both set then its off to the left]
 936+ F967 F8                                   ret     m                               ;               return
 937+ F968 78                                   ld      a,b                             ;       if (y1 < 0 && y2 < 0)
 938+ F969 DD A4                                and     ixh                             ;       . [ y1 and y2 high bits 7 are both set then its off the top]
 939+ F96B F8                                   ret     m                               ;               return
 940+ F96C 7C                                   ld      a,h                             ;       if (x1 > 255  && x2 > 255)
 941+ F96D CB 7F                                bit     7,a                             ;       . [test if x1 is negative and if so skip]
 942+ F96F C2 7E F9                             jp      nz,.x1x2LessThan256             ;       .
 943+ F972 A7                                   and     a                               ;       . [ if x1 is not negative then if high has any value its > 256]
 944+ F973 CA 7E F9                             jp      z,.x1x2LessThan256              ;       .
 945+ F976 7A                                   ld      a,d                             ;       . [test if x2 is negative]
 946+ F977 CB 7F                                bit     7,a                             ;       .
 947+ F979 C2 7E F9                             jp      nz,.x1x2LessThan256             ;       . < can simplify with with an xor test to detect if opposite signs first >
 948+ F97C A7                                   and     a                               ;       . [ if x2 is not negative then if high has any value its > 256]
 949+ F97D C0                                   ret     nz                              ;               return
 950+ F97E 78           .x1x2LessThan256:       ld      a,b                             ;       if (y1 > 127  && y2 > 127)
 951+ F97F CB 7F                                bit     7,a                             ;       . [test if y1 is negative]
 952+ F981 C2 9B F9                             jp      nz,.y1y2LessThan128             ;       .
 953+ F984 A7                                   and     a                               ;       . [ if y1 is not negative then if high has any value its > 256]
 954+ F985 CA 9B F9                             jp      z,.y1y2LessThan128              ;       .
 955+ F988 CB 79                                bit     7,c                             ;       . [ if y1 low bit 7 is set then its > 127]
 956+ F98A CA 9B F9                             jp      z,.y1y2LessThan128              ;       .
 957+ F98D DD 7C                                ld      a,ixh                           ;       . [test if y2 is negative]
 958+ F98F A7                                   and     a                               ;       .
 959+ F990 FA 9B F9                             jp      m,.y1y2LessThan128              ;       .
 960+ F993 A7                                   and     a                               ;       . [ if y2 is not negative then if high has any value its > 256]
 961+ F994 CA 9B F9                             jp      z,.y1y2LessThan128              ;       .
 962+ F997 DD 7D                                ld      a,ixl                           ;       .
 963+ F999 A7                                   and     a                               ;       . [ if y2 low bit 7 is set then its > 127]
 964+ F99A F8                                   ret     m                               ;               return
 965+ F99B              ;.......................LL115
 966+ F99B              .xx13Not128:                        // check right point
 967+ F99B EB           .y1y2LessThan128:       ex      de,hl                           ; delta_x = x2 - x1;
 968+ F99C                                      ClearCarryFlag                          ; .
 968+ F99C B7          >                        or a
 969+ F99D ED 52                                sbc     hl,de                           ; .
 970+ F99F 22 6B F2                             ld      (delta_x),hl                    ; redundant as its in DE TODO OPTIMISE
 971+ F9A2 EB                                   ex      de,hl                           ; de = delta_x for next bit
 972+ F9A3 DD E5 E1     .DyEquY2MinusY1:        ld      hl,ix                           ; delta_y = y2 - y1;
 973+ F9A6                                      ClearCarryFlag                          ; .
 973+ F9A6 B7          >                        or a
 974+ F9A7 ED 42                                sbc     hl,bc                           ; .
 975+ F9A9 22 6D F2                             ld      (delta_y),hl                    ; . [ so now de = dx and hl = dy]
 976+ F9AC FD 2E 80                             ld      iyl,128                         ; assuming sign is iyl is positive dx dy
 977+ F9AF CB 7A        .SignDeltaXY:           bit     7,d                             ; if delta x is negative (delta y will always be positive)
 978+ F9B1 CA BD F9                             jp      z,.DeltaXPositive               ; .
 979+ F9B4 FD 2E 00     .DeltaXNegative:        ld      iyl,0                           ;       so we set sign to 0
 980+ F9B7                                      macronegate16de                         ;       and set delta x to |delta x|
 980+ F9B7 AF          >					xor 	a
 980+ F9B8 93          >                    sub 	e
 980+ F9B9 5F          >                    ld 		e,a
 980+ F9BA 9F          >                    sbc 	a,a
 980+ F9BB 92          >                    sub 	d
 980+ F9BC 57          >                    ld 		d,a
 981+ F9BD ED 53 6B F2  .DeltaXPositive:        ld      (delta_x),de                    ;       .
 982+ F9C1              ;.......................Scale down DY and DY to 7 bit
 983+ F9C1 7C           .ScaleDXDY:             ld      a,h                             ; scale down so that dx and dx are < 256
 984+ F9C2 B2                                   or      d                               ; .
 985+ F9C3 CA D1 F9                             jp      z,.ScaleDXDYHighDone            ; .
 986+ F9C6                                      ShiftDERight1                           ; .
 986+ F9C6 CB 3A       >               srl d
 986+ F9C8 CB 1B       >               rr  e
 987+ F9CA                                      ShiftHLRight1                           ; .
 987+ F9CA CB 3C       >               srl h
 987+ F9CC CB 1D       >               rr  l
 988+ F9CE C3 C1 F9                             jp      .ScaleDXDY                      ; .
 989+ F9D1 7B           .ScaleDXDYHighDone:     ld      a,e                             ; because of signed maths we will scale down to 7 bits to be safe
 990+ F9D2 B5                                   or      l                               ; .
 991+ F9D3 F2 DE F9                             jp      p,.LowScaleDone                 ; .
 992+ F9D6                                      ShiftDERight1                           ; .
 992+ F9D6 CB 3A       >               srl d
 992+ F9D8 CB 1B       >               rr  e
 993+ F9DA                                      ShiftHLRight1                           ; .
 993+ F9DA CB 3C       >               srl h
 993+ F9DC CB 1D       >               rr  l
 994+ F9DE              ;.......................Work out slope and gradient - later on we will work with deltax beign abs
 995+ F9DE ED 53 6B F2  .LowScaleDone:          ld      (delta_x),de                    ; save adjusted dx and dy back
 996+ F9E2 22 6D F2                             ld      (delta_y),hl                    ; .
 997+ F9E5 55                                   ld      d,l                             ; now d = dy e = dx
 998+ F9E6 ED 53 6F F2                          ld      (delta_y_x),de                  ; save for diagnostics
 999+ F9EA              .SetUpTSlope:           ZeroA                                   ; Initialise tSlope to 0
 999+ F9EA AF          >                        xor a
1000+ F9EB 32 79 F2                             ld      (tSlope),a                      ; .
1001+ F9EE 7B                                   ld      a,e                             ; a = dx
1002+ F9EF                                      JumpIfAGTENusng d, .deltaxGTEdeltaY     ; if dx < dy
1002+ F9EF BA          >                        cp     d
1002+ F9F0 D2 03 FA    >                        jp		nc,.deltaxGTEdeltaY
1003+ F9F3 43           .deltaXLTdeltaY:        ld      b,e                             ;       bc = dx $00
1004+ F9F4 0E 00                                ld      c,0                             ;       .
1005+ F9F6 5A                                   ld      e,d                             ;       de = $00 dy
1006+ F9F7 16 00                                ld      d,0                             ;       .
1007+ F9F9 CD 79 71                             call    Floor_DivQ                      ;       bc = bc / de  (dx * 256 / dy)
1008+ F9FC ED 43 77 F2                          ld      (gradient),bc                   ;       in reality this is 8 bit little endian
1009+ FA00 C3 14 FA                             jp      .donedxdycheck                  ;       .
1010+ FA03                                                                              ; else
1011+ FA03 42           .deltaxGTEdeltaY:       ld      b,d                             ;       bc = dy << 0
1012+ FA04 0E 00                                ld      c,0                             ;       .
1013+ FA06 16 00                                ld      d,0                             ;       de = 0dx
1014+ FA08 CD 79 71                             call    Floor_DivQ                      ;       bc = bc / de (dy * 256 / dx)
1015+ FA0B ED 43 77 F2                          ld      (gradient),bc                   ;       in reality this is 8 bit little endian
1016+ FA0F 3E FF                                ld      a,255                           ;       set tslope to -1
1017+ FA11 32 79 F2                             ld      (tSlope),a                      ;       .
1018+ FA14              .donedxdycheck:                 // CHECK CORRECT POINT
1019+ FA14              ;.......................Clipping point 1
1020+ FA14                                      ;break
1021+ FA14 FD 7C                                ld      a,iyh                           ; if xx13 = 0 or xx13 = 128 (values can be 0, 128, 64 later we can optimise to see if its <> 64)
1022+ FA16 A7                                   and     a                               ; . [xx13 = 0  enter the block]
1023+ FA17 CA 1D FA                             jp      z,.xx13is0or128                 ; .
1024+ FA1A F2 3E FA                             jp      p,.xx13not0or128                ; . [xx13 <> 128 then skip block]
1025+ FA1D CD 5B FA     .xx13is0or128:          call    ClipLL118Elite                  ;       clip point 1
1026+ FA20 FD 7C                                ld      a,iyh                           ;       if xx13 <> 0
1027+ FA22 A7                                   and     a                               ;       .
1028+ FA23 CA 3A FA                             jp      z,.ImmediateDraw                ;       .
1029+ FA26 3A 42 F2                             ld      a,(x1+1)                        ;               if (if (x1 <0 || x1 > 255 || y1 <0 || y1 > 127)) return
1030+ FA29 A7                                   and     a                               ;               .
1031+ FA2A F8                                   ret     m                               ;               . [x1 high is negative then return]
1032+ FA2B C0                                   ret     nz                              ;               . [if x1 high is not zero, x1 > 255 return (above will have sorted negative test on bit 7)]
1033+ FA2C 3A 44 F2                             ld      a,(y1+1)                        ;               . [a = x1 high]
1034+ FA2F A7                                   and     a                               ;               .
1035+ FA30 F8                                   ret     m                               ;               . [if y1 negative return]
1036+ FA31 C0                                   ret     nz                              ;               . [if y1 > 255 return (above will have sorted negative test on bit 7)]
1037+ FA32 3A 43 F2                             ld      a,(y1)                          ;               . [a = y1 low]
1038+ FA35 A7                                   and     a                               ;               .
1039+ FA36 F8                                   ret     m                               ;               . [if y1 > 127 then low byte would appear as negative in bit 7]
1040+ FA37 C3 3E FA                             jp      .SkipCheckP1OnScreen            ;               else goto SkipCheckP1OnScreen
1041+ FA3A              .ImmediateDraw:         IFDEF SPLITORLINEX
1042+ FA3A CD 9F F2                             call    l2_draw_clipped_line            ;        else if we get here we only needed to clip one point so draw the line
1043+ FA3D                                      ENDIF
1044+ FA3D C9                                   ret                                     ;             and we are done
1045+ FA3E              .xx13not0or128:
1046+ FA3E CD 82 F2     .SkipCheckP1OnScreen:   call    SwapCoords                      ; swap point 1 and point 2 so we can now process P2
1047+ FA41 CD 5B FA                             call    ClipLL118Elite                  ; clip P2
1048+ FA44 3A 42 F2                             ld      a,(x1+1)                        ; if (x1 <0 || x1 > 255 || y1 <0 || y1 > 127) return
1049+ FA47 A7                                   and     a                               ; .
1050+ FA48 F8                                   ret     m                               ; . [if x1 negative return]
1051+ FA49 C0                                   ret     nz                              ; . [if x1 > 255 return (above will have sorted negative test on bit 7)]
1052+ FA4A 3A 44 F2                             ld      a,(y1+1)                        ; . [a = y1 high]
1053+ FA4D A7                                   and     a                               ;
1054+ FA4E F8                                   ret     m                               ; . [if y1 negative return]
1055+ FA4F C0                                   ret     nz                              ; . [if y1 > 255 return (above will have sorted negative test on bit 7)]
1056+ FA50 3A 43 F2                             ld      a,(y1)                          ; . [a = y1 low]
1057+ FA53 A7                                   and     a                               ; .
1058+ FA54 F8                                   ret     m                               ; . [if y1 low > 127 then low byte would appear as negative in bit 7]
1059+ FA55              .ClipComplete:
1060+ FA55              .xx13is0or128Draw:      IFDEF SPLITORLINEX
1061+ FA55 CD 9F F2                             call    l2_draw_clipped_line            ; if we get here we only needed to clip one point/have done all slipping needed
1062+ FA58                                      ENDIF
1063+ FA58 C9                                   ret
1064+ FA59              ;................................................................
1065+ FA59 00 00        ClipSign                dw      0
1066+ FA5B              ClipLL118Elite:        ;break
1067+ FA5B 2A 41 F2     .checkX1IsNegative      ld      hl,(x1)                         ; if x1 is negative
1068+ FA5E CB 7C                                bit     7,h                             ; .
1069+ FA60 CA 7F FA                             jp      z,.x1GTE0                       ; .
1070+ FA63 3E FF        .x1LT0:                 ld      a,255                           ;       clip sign = -1
1071+ FA65 32 59 FA                             ld      (ClipSign),a                    ;       .
1072+ FA68 CD E7 FA                             call    CalcLL120                       ;       calc ll120
1073+ FA6B 21 00 00                             ld      hl,0                            ;       x1 = 0
1074+ FA6E 22 41 F2                             ld      (x1),hl                         ;       .
1075+ FA71 2A 43 F2                             ld      hl,(y1)                         ;       y1 = y1 + result
1076+ FA74 ED 5B 0F F9                          ld      de,(result)                     ;       . [and save in hl for optimisation processing y1]
1077+ FA78 19                                   add     hl,de                           ;       .
1078+ FA79 22 43 F2                             ld      (y1),hl                         ;       .
1079+ FA7C C3 9C FA                             jp      .checkY1IsNegative              ;       .
1080+ FA7F 7C           .x1GTE0:                ld      a,h                             ; else
1081+ FA80 A7                                   and     a                               ;       if x1 > 255
1082+ FA81 CA 9C FA                             jp      z,.checkY1IsNegative            ;       .
1083+ FA84                                      ZeroA                                   ;               sign must be 0 for postive adjustment
1083+ FA84 AF          >                        xor a
1084+ FA85 32 59 FA                             ld      (ClipSign),a                    ;               .
1085+ FA88 CD E7 FA                             call    CalcLL120                       ;               Calc LL120
1086+ FA8B 21 FF 00                             ld      hl,255                          ;               x1 = 255
1087+ FA8E 22 41 F2                             ld      (x1),hl                         ;               .
1088+ FA91 2A 43 F2                             ld      hl,(y1)                         ;               y1 = y1 + result
1089+ FA94 ED 5B 0F F9                          ld      de,(result)                     ;               . [and save in hl for optimisation processing y1]
1090+ FA98 19                                   add     hl,de                           ;               .
1091+ FA99 22 43 F2                             ld      (y1),hl                         ;               .
1092+ FA9C                                                                              ; end if
1093+ FA9C 2A 43 F2     .checkY1IsNegative:     ld      hl,(y1)                         ; if (y1 <0) [if we don;t need to clip x1 then we need to load hl with y1 as it never got loaded]
1094+ FA9F CB 7C                                bit     7,h                             ; .
1095+ FAA1 CA BD FA                             jp      z,.checkY1LT128                 ; .
1096+ FAA4 3E FF                                ld      a,255                           ;       set sign to -1 for calc
1097+ FAA6 32 59 FA                             ld      (ClipSign),a                    ;       .
1098+ FAA9 CD 34 FB                             call    CalcLL123                       ;       calc LL123
1099+ FAAC 2A 41 F2                             ld      hl,(x1)                         ;       x1 = x1 + result
1100+ FAAF ED 5B 0F F9                          ld      de,(result)                     ;       .
1101+ FAB3 19                                   add     hl,de                           ;       .
1102+ FAB4 22 41 F2                             ld      (x1),hl                         ;       .
1103+ FAB7 21 00 00                             ld      hl,0                            ;       y1 = 0
1104+ FABA 22 43 F2                             ld      (y1),hl                         ;       .
1105+ FABD 7C           .checkY1LT128:          ld      a,h                             ; finished if y < 128
1106+ FABE A7                                   and     a                               ; .
1107+ FABF C2 C5 FA                             jp      nz,.mopUpY1                     ; . [jump to mop up if y1 high <> 0, wehave already dealt with negatvies so don't need to consider that]
1108+ FAC2 7D                                   ld      a,l                             ; . [now check y1 low and return if y1 low > 127]
1109+ FAC3 A7                                   and     a                               ; .
1110+ FAC4 F0                                   ret     p                               ; . [ if y1 low was positive then we are done as it means y1 < 128]
1111+ FAC5 11 80 00     .mopUpY1:               ld      de,128                          ; y1 = y1 - 128
1112+ FAC8                                      ClearCarryFlag                          ; .
1112+ FAC8 B7          >                        or a
1113+ FAC9 ED 52                                sbc     hl,de                           ; .
1114+ FACB 22 43 F2                             ld      (y1),hl                         ; .
1115+ FACE                                      ZeroA                                   ; set clip sign to 0
1115+ FACE AF          >                        xor a
1116+ FACF 32 59 FA                             ld      (ClipSign),a                    ; to get to here if y1 < 0, y is set to 0, if its < 128 then it never reaches here, so y1 must be > 128 to get here
1117+ FAD2 CD 34 FB                             call    CalcLL123                       ; calc LL123
1118+ FAD5 2A 41 F2                             ld      hl,(x1)                         ; x1 = x1 + result
1119+ FAD8 ED 5B 0F F9                          ld      de,(result)                     ; .
1120+ FADC 19                                   add     hl,de                           ; .
1121+ FADD 22 41 F2                             ld      (x1),hl                         ; .
1122+ FAE0 21 7F 00                             ld      hl,127                          ; y1 = 127
1123+ FAE3 22 43 F2                             ld      (y1),hl                         ; .
1124+ FAE6 C9                                   ret
1125+ FAE7
1126+ FAE7 2A 41 F2     CalcLL120:              ld      hl,(x1)                         ; x1= |x1|
1127+ FAEA                                      macroAbsHL                              ; .
1127+ FAEA CB 7C       >                    bit     7,h
1127+ FAEC CA F5 FA    >                    jp      z,.alreadyABS
1127+ FAEF AF          >					xor 	a
1127+ FAF0 95          >					sub 	l
1127+ FAF1 6F          >					ld 		l,a
1127+ FAF2 9F          >					sbc 	a,a
1127+ FAF3 94          >					sub 	h
1127+ FAF4 67          >					ld 		h,a
1127+ FAF5             >.alreadyABS:
1128+ FAF5 3A 79 F2                             ld      a,(tSlope)                      ; if (tslope == 0)
1129+ FAF8 A7                                   and     a                               ; .
1130+ FAF9 C2 18 FB                             jp      nz,.tSlopeNonZero               ; .
1131+ FAFC 55           .tSlopeZero:            ld      d,l                             ;       d = x1 & 255
1132+ FAFD 3A 77 F2                             ld      a,(gradient)                    ;       e = gradient
1133+ FB00 5F                                   ld      e,a                             ;
1134+ FB01 ED 30                                mul     de                              ;       de = x1 & 255 * gradient
1135+ FB03 5A                                   ld      e,d                             ;       de = x1 * gradient /256
1136+ FB04 16 00                                ld      d,0                             ;       .
1137+ FB06 3A 59 FA                             ld      a,(ClipSign)                    ;       if clipsign != 0
1138+ FB09 A7                                   and     a                               ;       .
1139+ FB0A CA 13 FB                             jp      z,.tSlopeZeroDone               ;       .
1140+ FB0D              .tSlopeZeroNegate:      macronegate16de                         ;               result = - result
1140+ FB0D AF          >					xor 	a
1140+ FB0E 93          >                    sub 	e
1140+ FB0F 5F          >                    ld 		e,a
1140+ FB10 9F          >                    sbc 	a,a
1140+ FB11 92          >                    sub 	d
1140+ FB12 57          >                    ld 		d,a
1141+ FB13 ED 53 0F F9  .tSlopeZeroDone:        ld      (result),de                     ;
1142+ FB17 C9                                   ret                                     ;
1143+ FB18              .tSlopeNonZero:         ;ld      a,(gradient)                    ; else  c = gradient
1144+ FB18                                      ;ld      c,a                             ;       .
1145+ FB18                                      ;ld      a,l                             ;       a = x1 & 255
1146+ FB18                                      ;call    DIV16Amul256dCUNDOC             ;       bc = a * 256/c
1147+ FB18
1148+ FB18 ED 5B 77 F2                          ld      de,(gradient)                   ; BC = BC / DE
1149+ FB1C 45                                   ld      b,l
1150+ FB1D 0E 00                                ld      c,0
1151+ FB1F                                      ;; CORRECTED TO LADO INTO B ld      bc,hl                           ; HL = BC % DE
1152+ FB1F CD 79 71                             call    Floor_DivQ
1153+ FB22
1154+ FB22 3A 59 FA                             ld      a,(ClipSign)                    ;       if clipsign != 0
1155+ FB25 A7                                   and     a                               ;       .
1156+ FB26 CA 2F FB                             jp      z,.tSlopeNonZeroDone            ;       .
1157+ FB29              .tSlopeNonZeroNegate:   macronegate16bc                         ;               result = - result
1157+ FB29 AF          >					xor 	a
1157+ FB2A 91          >                    sub 	c
1157+ FB2B 4F          >                    ld 		c,a
1157+ FB2C 9F          >                    sbc 	a,a
1157+ FB2D 90          >                    sub 	b
1157+ FB2E 47          >                    ld 		b,a
1158+ FB2F ED 43 0F F9  .tSlopeNonZeroDone:     ld      (result),bc
1159+ FB33 C9                                   ret
1160+ FB34              ;.......................LL123
1161+ FB34              CalcLL123:              ;break
1162+ FB34 2A 43 F2                             ld      hl,(y1)                         ; hl = |y1|
1163+ FB37                                      macroAbsHL                              ; .
1163+ FB37 CB 7C       >                    bit     7,h
1163+ FB39 CA 42 FB    >                    jp      z,.alreadyABS
1163+ FB3C AF          >					xor 	a
1163+ FB3D 95          >					sub 	l
1163+ FB3E 6F          >					ld 		l,a
1163+ FB3F 9F          >					sbc 	a,a
1163+ FB40 94          >					sub 	h
1163+ FB41 67          >					ld 		h,a
1163+ FB42             >.alreadyABS:
1164+ FB42 3A 79 F2                             ld      a,(tSlope)                      ; if tSlope = 0
1165+ FB45 A7                                   and     a                               ; .
1166+ FB46 C2 64 FB                             jp      nz,.tSlopeNonZero               ; .
1167+ FB49              .tSlopeZero:           ; ld      a,(gradient)                    ;       c = gradient
1168+ FB49              ;                        ld      c,a                             ;       .
1169+ FB49              ;                        ld      a,l                             ;       hl = y1 (which is now abs and < 256)
1170+ FB49              ;                        call    DIV16Amul256dCUNDOC             ;       bc = A * 256 / c
1171+ FB49 ED 5B 77 F2                          ld      de,(gradient)                   ; BC = BC / DE
1172+ FB4D 44 4D                                ld      bc,hl                           ; HL = BC % DE
1173+ FB4F CD 79 71                             call    Floor_DivQ
1174+ FB52 3A 59 FA                             ld      a,(ClipSign)                    ;       if clipsign != 0
1175+ FB55 A7                                   and     a                               ;       .
1176+ FB56 CA 5F FB                             jp      z, .tSlopeZeroDone              ;       .
1177+ FB59              .tSlopeZeroNegate:      macronegate16bc                         ;               result = -result
1177+ FB59 AF          >					xor 	a
1177+ FB5A 91          >                    sub 	c
1177+ FB5B 4F          >                    ld 		c,a
1177+ FB5C 9F          >                    sbc 	a,a
1177+ FB5D 90          >                    sub 	b
1177+ FB5E 47          >                    ld 		b,a
1178+ FB5F ED 43 0F F9  .tSlopeZeroDone:        ld      (result),bc                     ;       . save result in either case
1179+ FB63 C9                                   ret                                     ;       .
1180+ FB64 55           .tSlopeNonZero:         ld      d,l                             ; else  d = |y1| low
1181+ FB65 3A 77 F2                             ld      a,(gradient)                    ;       e = gradient
1182+ FB68 5F                                   ld      e,a                             ;       .
1183+ FB69 ED 30                                mul     de                              ;       de = l * gradient
1184+ FB6B 5A                                   ld      e,d                             ;       de = l * gradient /256
1185+ FB6C 16 00                                ld      d,0                             ;       .
1186+ FB6E 3A 59 FA                             ld      a,(ClipSign)                    ;       if clipsign != 0
1187+ FB71 A7                                   and     a                               ;
1188+ FB72 CA 7B FB                             jp      z,.tSlopeNonZeroDone            ;
1189+ FB75              .tSlopeNonZeroNegate:   macronegate16de                         ;               result = -result
1189+ FB75 AF          >					xor 	a
1189+ FB76 93          >                    sub 	e
1189+ FB77 5F          >                    ld 		e,a
1189+ FB78 9F          >                    sbc 	a,a
1189+ FB79 92          >                    sub 	d
1189+ FB7A 57          >                    ld 		d,a
1190+ FB7B ED 53 0F F9  .tSlopeNonZeroDone:     ld      (result),de                     ;       . save result in either case
1191+ FB7F C9                                   ret                                     ;       .
1192+ FB80
# file closed: ../../Layer2Graphics/l2_draw_any_line.asm
 716  FB80                  INCLUDE "../../Layer2Graphics/l2_draw_line_v2.asm"
# file opened: ../../Layer2Graphics/l2_draw_line_v2.asm
   1+ FB80              ; ******************************************************************************
   2+ FB80              ;
   3+ FB80              ;	Draw a pixel line from (x0,y0) defined in (COORDS) - the current plot
   4+ FB80              ;	coordinate, to the relative distance points (x0+x,y0+y).
   5+ FB80              ;
   6+ FB80              ;	Design & programming by Gunther Strube,	Copyright (C) InterLogic 1995
   7+ FB80              ;
   8+ FB80              ;	The (COORDS+0)	pointer contains the current y coordinate, (COORDS+1) the
   9+ FB80              ;	current x coordinate. The main program should reset the (COORDS) variables
  10+ FB80              ;	before using line drawing.
  11+ FB80              ;
  12+ FB80              ;	The routine checks the range of specified coordinates which is the
  13+ FB80              ;	boundaries of the graphics area (256x64	pixels).
  14+ FB80              ;	If a boundary error occurs the routine exits automatically.	This may be
  15+ FB80              ;	useful if you are trying to draw a line longer than allowed. Only the
  16+ FB80              ;	visible part will be drawn.
  17+ FB80              ;
  18+ FB80              ;	The hardware graphics memory is organized as (0,0) in the top left corner.
  19+ FB80              ;
  20+ FB80              ;	The plot routine is	defined by an address pointer	in IX.
  21+ FB80              ;
  22+ FB80              ;	IN:	HL =	move	relative x horisontal points (maximum +/- 255).
  23+ FB80              ;		DE =	move	relative y vertical	points (maximum +/-	255).
  24+ FB80              ;		IX =	pointer to plot routine that uses HL = (x,y)	of plot coordinate.
  25+ FB80              ;
  26+ FB80              ;	OUT:	None.
  27+ FB80              ;
  28+ FB80              ;	Registers	used	by routine:
  29+ FB80              ;		   N	:	B, loop counter
  30+ FB80              ;		   i	:	line	balance variable
  31+ FB80              ;		   x	:	H/L,	horisontal, vertical distance	variables
  32+ FB80              ;		   y	:	H/L,	horisontal, vertical distance	variables
  33+ FB80              ;	  (x0,y0)	:	(h,l)
  34+ FB80              ;	  direc_x	:	d, horisontal step increment
  35+ FB80              ;	  direc_y	:	e, vertical step increment
  36+ FB80              ;		 ddx	:	b, horisontal step increment
  37+ FB80              ;		 ddy	:	c, vertical step increment
  38+ FB80              ;
  39+ FB80              ;		DE, A work registers.
  40+ FB80              ;
  41+ FB80              ; The algorithm in pseudo-code:
  42+ FB80              ;
  43+ FB80              ;	direc_x =	SGN x: direc_y	= SGN y
  44+ FB80              ;	x = ABS x: y =	ABS y
  45+ FB80              ;
  46+ FB80              ;	if x	>= y
  47+ FB80              ;		if x+y=0 then return
  48+ FB80              ;		H = x
  49+ FB80              ;		L = y
  50+ FB80              ;		ddx = direc_x
  51+ FB80              ;		ddy = 0
  52+ FB80              ;	else
  53+ FB80              ;		H = y
  54+ FB80              ;		L = x
  55+ FB80              ;		ddx = 0
  56+ FB80              ;		ddy = direc_y
  57+ FB80              ;	endif
  58+ FB80              ;
  59+ FB80              ;	B = H
  60+ FB80              ;	i = INT(B/2)
  61+ FB80              ;	FOR N=B TO 1 STEP -1
  62+ FB80              ;		i = i + L
  63+ FB80              ;		if i	< H
  64+ FB80              ;			ix =	ddx
  65+ FB80              ;			iy =	ddy
  66+ FB80              ;		else
  67+ FB80              ;			i = i - H
  68+ FB80              ;			ix =	direc_x
  69+ FB80              ;			iy =	direc_y
  70+ FB80              ;		endif
  71+ FB80              ;		x0 =	x0 +	ix
  72+ FB80              ;		y0 =	y0 +	iy
  73+ FB80              ;		plot	(x0,y0)
  74+ FB80              ;	NEXT	N
  75+ FB80              ;
  76+ FB80              ;
  77+ FB80              ;	Registers	changed after return:
  78+ FB80              ;		..BCDEHL/IXIY/af......	same
  79+ FB80              ;		AF....../..../..bcdehl	different
  80+ FB80              ;
  81+ FB80 00 00        line_gfx_coords         dw  0
  82+ FB82
  83+ FB82              LineHLtoDE:
  84+ FB82 7C           TestMaxY:               ld	a,h ; were h = y or l = y?
  85+ FB83 FE C0                                cp	192
  86+ FB85 30 26                                jr	nc, exit_line		; y0	coordinate out	of range
  87+ FB87 7A                                   ld	a,d
  88+ FB88 FE C0                                cp	192
  89+ FB8A 30 21                                jr	nc, exit_line		; y1	coordinate out	of range
  90+ FB8C 22 80 FB                             ld	(line_gfx_coords),hl		; the starting	point is now default
  91+ FB8F E5                                   push	hl
  92+ FB90 D5                                   push	de
  93+ FB91 6C                                   ld	l,h				; L = x0
  94+ FB92 62                                   ld	h,d				; H = x1
  95+ FB93 7C           distanceX:		        ld	a,h
  96+ FB94 95                                   sub	l
  97+ FB95 6F                                   ld	l,a
  98+ FB96 26 00                                ld	h,0
  99+ FB98 30 02                                jr	nc, distanceXDone
 100+ FB9A 26 FF                                ld	h,-1
 101+ FB9C D1           distanceXDone:          pop	de
 102+ FB9D E3                                   ex	(sp),hl			; L = y0
 103+ FB9E 63                                   ld	h,e				; H = y1
 104+ FB9F 7C           distanceY:		        ld	a,h
 105+ FBA0 95                                   sub	l
 106+ FBA1 6F                                   ld	l,a
 107+ FBA2 26 00                                ld	h,0
 108+ FBA4 30 02                                jr	nc, distanceYDone
 109+ FBA6 26 FF                                ld	h,-1
 110+ FBA8 D1           distanceYDone:          pop	de
 111+ FBA9 EB                                   ex	de,hl			; h.dist.	= HL, v.dist. = DE
 112+ FBAA CD AE FB                             call	DrawLineRelative			; draw line...
 113+ FBAD C9           exit_line:              ret
 114+ FBAE
 115+ FBAE              ; ***************************************************************************
 116+ FBAE              ;
 117+ FBAE              ;	IN:	HL =	move	relative x horisontal points (maximum +/- 255).
 118+ FBAE              ;		DE =	move	relative y vertical	points (maximum +/-	255).
 119+ FBAE              ;
 120+ FBAE              ; OUT: h - l distance in	HL
 121+ FBAE              ;
 122+ FBAE
 123+ FBAE D5           DrawLineRelative:       push	de
 124+ FBAF E5                                   push	hl
 125+ FBB0 D9                                   exx
 126+ FBB1 E1                                   pop	hl					; get relative	horisontal movement
 127+ FBB2 CD 29 FC                             call	sgn
 128+ FBB5 57                                   ld	d,a					; direc_x	= SGN(x) installed d = +/-1 for horizontal update
 129+ FBB6 CD 36 FC                             call	absValue
 130+ FBB9 45                                   ld	b,l					; x = ABS(x)
 131+ FBBA E1           DrawLineGetVertRelative:pop	hl					; get relative	vertical movement
 132+ FBBB CD 29 FC                             call	sgn
 133+ FBBE 5F                                   ld	e,a					; direc_y	= SGN(y) installed  = +/-1 for vertical update
 134+ FBBF CD 36 FC                             call	absValue
 135+ FBC2 4D                                   ld	c,l					; y = ABS(y) so now bc = dxdy
 136+ FBC3              ; so by here BC = dx dy HL in increment/decrement x y
 137+ FBC3 C5                                   push	bc
 138+ FBC4 D9                                   exx
 139+ FBC5 E1                                   pop	hl					; H = absolute	x dist., L = absolute y distance
 140+ FBC6 7C                                   ld	a,h
 141+ FBC7 BD                                   cp	l
 142+ FBC8 38 0A                                jr	c, x_smaller_y		; if	x >=	y
 143+ FBCA B4           areXandYZero:           or	h					;	if x+y = 0
 144+ FBCB 28 5B                                jr	z, exit_draw		;		return
 145+ FBCD D9           y_lessorequal_x:        exx						;	else
 146+ FBCE 42                                   ld	b,d					;		ddx = direc_x
 147+ FBCF 0E 00                                ld	c,0					;		ddy = 0
 148+ FBD1 D9                                   exx
 149+ FBD2 18 08                                jr	init_drawloop		; else
 150+ FBD4 7C           x_smaller_y:	        ld	a,h
 151+ FBD5 65                                   ld	h,l					;	H = y
 152+ FBD6 6F                                   ld	l,a					;	L = x
 153+ FBD7 D9                                   exx
 154+ FBD8 06 00                                ld	b,0					;	ddx = 0
 155+ FBDA 4B                                   ld	c,e					;	ddy = direc_y
 156+ FBDB D9                                   exx
 157+ FBDC 44           init_drawloop:	        ld	b,h
 158+ FBDD 4C                                   ld	c,h					; B = H
 159+ FBDE CB 39                                srl	c					; i = INT(B/2)
 160+ FBE0              										; FOR N=B	TO 1	STEP	-1
 161+ FBE0 79           drawloop:		        ld	a,c
 162+ FBE1 85                                   add	a,l
 163+ FBE2 38 09                                jr	c, i_greater		;	i + L > 255  (i > H)
 164+ FBE4 BC                                   cp	h
 165+ FBE5 30 06                                jr	nc, i_greater		;	if i	< H
 166+ FBE7 4F                                   ld	c,a					;		i = i + L
 167+ FBE8 D9                                   exx
 168+ FBE9 C5                                   push	bc				;		ix =	ddx:	iy =	ddy
 169+ FBEA D9                                   exx
 170+ FBEB 18 05                                jr	check_plot			;	else
 171+ FBED 94           i_greater:		        sub	h					;		i = i - H
 172+ FBEE 4F                                   ld	c,a
 173+ FBEF D9                                   exx
 174+ FBF0 D5                                   push	de				;		ix =	direc_x: iy = direc_y
 175+ FBF1 D9                                   exx						;	endif
 176+ FBF2 E3           check_plot:		        ex	(sp),hl				;	preserve H,L distances on stack
 177+ FBF3 EB                                   ex	de,hl				;	D,E = ix,	iy
 178+ FBF4 2A 80 FB                             ld	hl,(line_gfx_coords)
 179+ FBF7 7D                                   ld	a,l
 180+ FBF8 83                                   add	a,e					;
 181+ FBF9 6F                                   ld	l,a					;	y0 =	y0 +	iy (y0 is	checked by plot)
 182+ FBFA 7A                                   ld	a,d
 183+ FBFB 3C                                   inc	a
 184+ FBFC 84                                   add	a,h
 185+ FBFD 38 04                                jr	c, check_range		;	check out	of range
 186+ FBFF 28 26                                jr	z, range_error		;	Fz=1	& Fc=0 denotes	x0 <	0
 187+ FC01 18 02                                jr	plot_point
 188+ FC03 20 22        check_range:            jr	nz, range_error	;	Fz=0	& Fc=1 denotes	x0 >	255
 189+ FC05
 190+ FC05 3D           plot_point:             dec	a
 191+ FC06 C5                                   push	bc
 192+ FC07 F5                                   push	af
 193+ FC08 47                                   ld	    b,a					;	x0 =	x0 +	ix
 194+ FC09 4D                                   ld		c,l
 195+ FC0A 3A FA E3                             ld		a,(line_gfx_colour)
 196+ FC0D ED 43 80 FB                          ld      (line_gfx_coords),bc
 197+ FC11                                      l2_plot_macro; call	l2_plot_pixel:
 197+ FC11 78          >                        ld      a,b
 197+ FC12             >                        JumpIfAGTENusng 192 ,.NoPlot
 197+ FC12 FE C0       >                        cp     192
 197+ FC14 D2 20 FC    >                        jp		nc,.NoPlot
 197+ FC17 69          >                        ld      l,c
 197+ FC18 CD 78 E0    >                        call    asm_l2_row_bank_select
 197+ FC1B 67          >                        ld      h,a
 197+ FC1C 3A FA E3    >                        ld      a,(line_gfx_colour)
 197+ FC1F 77          >                        ld      (hl),a
 197+ FC20             >.NoPlot:
 198+ FC20 F1                                   pop		af
 199+ FC21 C1                                   pop		bc
 200+ FC22 E1           plot_RET:		        pop	hl					;	restore H,L distances...
 201+ FC23 10 BB                                djnz	drawloop		; NEXT N
 202+ FC25 18 01                                jr	exit_draw
 203+ FC27
 204+ FC27 E1           range_error:	        pop	hl					; remove H,L distances...
 205+ FC28 C9           exit_draw:		        ret
 206+ FC29
 207+ FC29
 208+ FC29              ; ******************************************************************************
 209+ FC29              ;
 210+ FC29              ;	SGN (Signum value) of 16	bit signed integer.
 211+ FC29              ;
 212+ FC29              ;	IN:		HL =	integer
 213+ FC29              ;	OUT:		A = result: 0,1,-1 (if zero, positive, negative)
 214+ FC29              ;
 215+ FC29              ;	Registers	changed after return:
 216+ FC29              ;	..BCDEHL/IXIY	same
 217+ FC29              ;	AF....../....	different
 218+ FC29              ;
 219+ FC29 7C           sgn:				    ld	a,h
 220+ FC2A B5                                   or	l
 221+ FC2B C8                                   ret	z				; integer	is zero, return 0...
 222+ FC2C CB 7C                                bit	7,h
 223+ FC2E 20 03                                jr	nz, negative_int
 224+ FC30 3E 01                                ld	a,1
 225+ FC32 C9                                   ret
 226+ FC33 3E FF        negative_int:		    ld	a,-1
 227+ FC35 C9                                   ret
 228+ FC36
 229+ FC36
 230+ FC36              ; ******************************************************************************
 231+ FC36              ;
 232+ FC36              ;	ABS (Absolute value) of 16 bit signed integer.
 233+ FC36              ;
 234+ FC36              ;	IN:		HL =	integer
 235+ FC36              ;	OUT:		HL =	converted	integer
 236+ FC36              ;
 237+ FC36              ;	Registers	changed after return:
 238+ FC36              ;	A.BCDE../IXIY	same
 239+ FC36              ;	.F....HL/....	different
 240+ FC36              ;
 241+ FC36 CB 7C        absValue:			    bit	7,h
 242+ FC38 C8                                   ret	z				; integer	is positive...
 243+ FC39 D5                                   push	de
 244+ FC3A EB                                   ex	de,hl
 245+ FC3B 21 00 00                             ld	hl,0
 246+ FC3E BF                                   cp	a				; Fc	= 0,	may not be used...
 247+ FC3F ED 52                                sbc	hl,de			; convert	negative integer
 248+ FC41 D1                                   pop	de
 249+ FC42 C9                                   ret
 250+ FC43
# file closed: ../../Layer2Graphics/l2_draw_line_v2.asm
 717  FC43                  DISPLAY "Bank ",BankLAYER2," - Bytes free ",/D, $2000 - ($-LAYER2Addr), " - BankLAYER2"
 718  FC43              ; Bank 58  ------------------------------------------------------------------------------------------------------------------------
 719  FC43                  SLOT    LAYER1Addr
 720  FC43                  PAGE    BankLAYER1
 721  FC43                  ORG     LAYER1Addr, BankLAYER1
 722  E000 42 61 6E 6B  Layer1Header:  DB "Bank L1 Utils--"
 722  E004 20 4C 31 20
 722  E008 55 74 69 6C
 722  E00C 73 2D 2D
 723  E00F
 724  E00F                  INCLUDE "../../Layer1Graphics/layer1_attr_utils.asm"
# file opened: ../../Layer1Graphics/layer1_attr_utils.asm
   1+ E00F
   2+ E00F 00 58        L1AttrRow00:            DW $5800                    ;Row 1    */
   3+ E011 20 58        L1AttrRow01:            DW $5820                    ;Row 2    */
   4+ E013 40 58        L1AttrRow02:            DW $5840                    ;Row 3    */
   5+ E015 60 58        L1AttrRow03:            DW $5860                    ;Row 4    */
   6+ E017 80 58        L1AttrRow04:            DW $5880                    ;Row 5    */
   7+ E019 A0 58        L1AttrRow05:            DW $58A0                    ;Row 6    */
   8+ E01B C0 58        L1AttrRow06:            DW $58C0                    ;Row 7    */
   9+ E01D E0 58        L1AttrRow07:            DW $58E0                    ;Row 8    */
  10+ E01F 00 59        L1AttrRow08:            DW $5900                    ;Row 9    */
  11+ E021 20 59        L1AttrRow09:            DW $5920                    ;Row 10   */
  12+ E023 40 59        L1AttrRow10:            DW $5940                    ;Row 11   */
  13+ E025 60 59        L1AttrRow11:            DW $5960                    ;Row 12   */
  14+ E027 80 59        L1AttrRow12:            DW $5980                    ;Row 13   */
  15+ E029 A0 59        L1AttrRow13:            DW $59A0                    ;Row 14   */
  16+ E02B C0 59        L1AttrRow14:            DW $59C0                    ;Row 15   */
  17+ E02D E0 59        L1AttrRow15:            DW $59E0                    ;Row 16   */
  18+ E02F 00 5A        L1AttrRow16:            DW $5A00                    ;Row 17   */
  19+ E031 20 5A        L1AttrRow17:            DW $5A20                    ;Row 18   */
  20+ E033 40 5A        L1AttrRow18:            DW $5A40                    ;Row 19   */
  21+ E035 60 5A        L1AttrRow19:            DW $5A60                    ;Row 20   */
  22+ E037 80 5A        L1AttrRow20:            DW $5A80                    ;Row 21   */
  23+ E039 A0 5A        L1AttrRow21:            DW $5AA0                    ;Row 22   */
  24+ E03B C0 5A        L1AttrRow22:            DW $5AC0                    ;Row 23   */
  25+ E03D E0 5A        L1AttrRow23:            DW $5AE0                    ;Row 23   */
  26+ E03F
  27+ E03F              ; "l2_hilight_row, d = row, e = colour"
  28+ E03F 21 0F E0     l1_hilight_row:         ld      hl, L1AttrRow00
  29+ E042 4B                                   ld      c,e
  30+ E043 7A                                   ld      a,d
  31+ E044 CB 27                                sla     a
  32+ E046 ED 31                                add     hl,a
  33+ E048 7E                                   ld      a,(hl)
  34+ E049 5F                                   ld      e,a
  35+ E04A 23                                   inc     hl
  36+ E04B 7E                                   ld      a,(hl)
  37+ E04C 57                                   ld      d,a
  38+ E04D EB                                   ex      hl,de
  39+ E04E 79                                   ld		a,c
  40+ E04F 11 20 00                             ld		de, 32
  41+ E052 CD 81 65                             call	memfill_dma
  42+ E055 C9                                   ret
  43+ E056
# file closed: ../../Layer1Graphics/layer1_attr_utils.asm
 725  E056                  INCLUDE "../../Layer1Graphics/layer1_cls.asm"
# file opened: ../../Layer1Graphics/layer1_cls.asm
   1+ E056 AF           l1_cls_top:             xor     a
   2+ E057 21 00 40                             ld      hl, $4000
   3+ E05A 11 00 08                             ld      de, $0800
   4+ E05D CD 81 65                             call    memfill_dma
   5+ E060 C9                                   ret
   6+ E061
   7+ E061 AF           l1_cls_mid:             xor     a
   8+ E062 21 00 48                             ld      hl, $4800
   9+ E065 11 00 08                             ld      de, $0800
  10+ E068 CD 81 65                             call    memfill_dma
  11+ E06B C9                                   ret
  12+ E06C
  13+ E06C AF           l1_cls_bottom:          xor     a
  14+ E06D 21 00 50                             ld      hl, $5000
  15+ E070 11 00 08                             ld      de, $0800
  16+ E073 CD 81 65                             call    memfill_dma
  17+ E076 C9                                   ret
  18+ E077
  19+ E077              ; Designed specifically to clear a whole character aligned line
  20+ E077 1E 00        l1_cls_line_d:          ld      e,0
  21+ E079 ED 94                                pixelad
  22+ E07B 11 00 01                             ld      de,32 * 8
  23+ E07E AF                                   xor     a
  24+ E07F CD 81 65                             call    memfill_dma
  25+ E082 C9                                   ret
  26+ E083
  27+ E083              ; Designed specifically to clear a whole character aligned 2 lines line, used for say clearing hyperspace message
  28+ E083 1E 00        l1_cls_2_lines_d:       ld      e,0
  29+ E085 ED 94                                pixelad
  30+ E087 11 00 02                             ld      de,32 * 16
  31+ E08A AF                                   xor     a
  32+ E08B CD 81 65                             call    memfill_dma
  33+ E08E C9                                   ret
  34+ E08F
  35+ E08F AF           l1_cls:                 xor		a
  36+ E090 21 00 40     l1_cls_to_a:            ld		hl,	$4000
  37+ E093 11 00 18                             ld		de, $1800
  38+ E096 CD 81 65                             call	memfill_dma
  39+ E099 C9                                   ret
  40+ E09A
  41+ E09A 21 00 58     l1_attr_cls_2DlinesA:   ld		hl,	$5800
  42+ E09D 1E 20                                ld      e,32
  43+ E09F ED 30                                mul
  44+ E0A1 19                                   add     hl,de
  45+ E0A2 11 40 00                             ld		de, 32 * 2
  46+ E0A5 CD 81 65                             call	memfill_dma
  47+ E0A8 C9                                   ret
  48+ E0A9
  49+ E0A9
  50+ E0A9 AF           l1_attr_cls:            xor		a
  51+ E0AA 21 00 58     l1_attr_cls_to_a:       ld		hl,	$5800
  52+ E0AD 11 00 03                             ld		de, $0300
  53+ E0B0 CD 81 65                             call	memfill_dma
  54+ E0B3 C9                                   ret
  55+ E0B4
  56+ E0B4 01 FE FE     l1_set_border:          ld	    bc, 0xFEFE
  57+ E0B7 ED 79                                out		(c),a
  58+ E0B9 C9                                   ret
# file closed: ../../Layer1Graphics/layer1_cls.asm
 726  E0BA                  INCLUDE "../../Layer1Graphics/layer1_print_at.asm"
# file opened: ../../Layer1Graphics/layer1_print_at.asm
   1+ E0BA              ; "l1 print char a = character, de = Ypixel Xpxiel rounded to char of print"
   2+ E0BA D5 E5        l1_print_char:          push	de,,hl
   3+ E0BC ED 94                                pixelad								; hl = address of de
   4+ E0BE E5                                   push	hl							; save hl for loop
   5+ E0BF 26 00                                ld		h,0
   6+ E0C1 6F                                   ld		l,a
   7+ E0C2 29                                   add		hl,hl						; * 2
   8+ E0C3 29                                   add		hl,hl						; * 4
   9+ E0C4 29                                   add		hl,hl						; * 8 to get byte address
  10+ E0C5 ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
  11+ E0C9 EB                                   ex		de,hl						; save address into de
  12+ E0CA E1                                   pop		hl							; get back hl for loop
  13+ E0CB 06 08                                ld		b,8							; do 8 rows
  14+ E0CD 1A           .PrintCharLoop:         ld		a,(de)						; row byte
  15+ E0CE 13                                   inc		de							; next byte
  16+ E0CF 77                                   ld		(hl),a						; poke to screen
  17+ E0D0 ED 93                                pixeldn								; Down 1 row
  18+ E0D2 10 F9                                djnz	.PrintCharLoop				; loop for 8 bytes
  19+ E0D4 E1 D1                                pop		de,,hl					    ; restore hl
  20+ E0D6 C9                                   ret
  21+ E0D7
  22+ E0D7              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
  23+ E0D7              ; now skips ascii code < 32 but moves on cursor by 1 char
  24+ E0D7              l1_print_at_char
  24+ E0D7 CB 22           sla     d       ; Convert D from char to pixel
  25+ E0D9 CB 22                                sla     d       ; by muliplying by 8
  26+ E0DB CB 22                                sla     d       ;
  27+ E0DD CB 23                                sla     e       ; Convert E from char to pixel
  28+ E0DF CB 23                                sla     e
  29+ E0E1 CB 23                                sla     e
  30+ E0E3              l1_print_at:
  31+ E0E3 7E           .PrintLoop:             ld		a,(hl)
  32+ E0E4 FE 00                                cp		0
  33+ E0E6 C8                                   ret		z
  34+ E0E7                                      CallIfAGTENusng " ", l1_print_char
  34+ E0E7 FE 20       >                        cp      " "
  34+ E0E9 D4 BA E0    >                        call	nc,l1_print_char
  35+ E0EC 23                                   inc		hl							; move 1 message character right
  36+ E0ED 7B                                   ld		a,e
  37+ E0EE C6 08                                add		a,8
  38+ E0F0 5F                                   ld		e,a							; move 1 screen character right
  39+ E0F1 18 F0                                jr		.PrintLoop
  40+ E0F3                                                      DISPLAY "TODO: looks liek rogue popde"
  41+ E0F3              .Clearstackandfinish:   ;pop		de                      ; TODO LOOOKS TO BE A ROGUE POPDE
  42+ E0F3 C9                                   ret
  43+ E0F4
  44+ E0F4
  45+ E0F4
  46+ E0F4 30 30 00     HexU8Char:       DB "00",0
  47+ E0F7 30 30 30 30  HexU16Char:      DB "0000",0
  47+ E0FB 00
  48+ E0FC 2B 30 30 00  HexS8Char:       DB "+00",0
  49+ E100 2B 30 30 30  HexS16Char:      DB "+0000",0
  49+ E104 30 00
  50+ E106 2B 30 30 30  HexS24Char:      DB "+0000.00",0
  50+ E10A 30 2E 30 30
  50+ E10E 00
  51+ E10F 2A 2A 00     HexU8NaN:        DB "**",0
  52+ E112 30 30 30 30  Bin8Bit:         DB "00000000",0
  52+ E116 30 30 30 30
  52+ E11A 00
  53+ E11B              ; prints + sign for bit 7 clear in a else - sign for bit 7 set, Load to buffer location in ix
  54+ E11B CB 7F        l1_buffer_sign_at_ix:   bit     7,a
  55+ E11D CA 26 E1                             jp      z,.PrintPlus
  56+ E120 3E 2D        .PrintMinus:            ld      a,"-"
  57+ E122 DD 77 00                             ld      (ix+0),a
  58+ E125 C9                                   ret
  59+ E126 3E 2B        .PrintPlus:             ld      a,"+"
  60+ E128 DD 77 00                             ld      (ix+0),a
  61+ E12B C9                                   ret
  62+ E12C
  63+ E12C 30 31 32 33  HexMapping:     DB "0123456789ABCDEF"
  63+ E130 34 35 36 37
  63+ E134 38 39 41 42
  63+ E138 43 44 45 46
  64+ E13C              ; writes hex 8 bit to ix buffer position
  65+ E13C C5 E5        l1_buffer_hex_8_at_ix:  push    bc,,hl
  66+ E13E 47                                   ld      b,a
  67+ E13F ED 23                                swapnib
  68+ E141 E6 0F                                and     $0F
  69+ E143 21 2C E1                             ld      hl,HexMapping
  70+ E146 ED 31                                add     hl,a
  71+ E148 7E                                   ld      a,(hl)
  72+ E149 DD 77 00                             ld      (ix+0),a
  73+ E14C 21 2C E1                             ld      hl,HexMapping
  74+ E14F 78                                   ld      a,b
  75+ E150 E6 0F                                and     $0F
  76+ E152 ED 31                                add     hl,a
  77+ E154 7E                                   ld      a,(hl)
  78+ E155 DD 77 01                             ld      (ix+1),a
  79+ E158 E1 C1                                pop     bc,,hl
  80+ E15A C9                                   ret
  81+ E15B F5 C5 D5 E5  l1_print_bin8_at_char:    push  af,,bc,,de,,hl
  82+ E15F DD 21 12 E1                            ld    ix,Bin8Bit
  83+ E163 06 08                                  ld    b,8
  84+ E165 CB 27        .WriteLoop:               sla   a
  85+ E167 38 05                                  jr    c,.ItsaOne
  86+ E169 0E 30        .ItsAZero:                ld    c,'0'
  87+ E16B C3 70 E1                               jp    .DoWrite
  88+ E16E 0E 31        .ItsaOne:                 ld    c,'1'
  89+ E170 DD 71 00     .DoWrite:                 ld    (ix+0),c
  90+ E173 DD 23                                  inc   ix
  91+ E175 10 EE                                  djnz  .WriteLoop
  92+ E177 E1 D1 C1 F1                            pop   af,,bc,,de,,hl
  93+ E17B 21 12 E1                               ld    hl,Bin8Bit
  94+ E17E CD D7 E0                               call  l1_print_at_char
  95+ E181 C9                                     ret
  96+ E182
  97+ E182 F5 C5 D5 E5  l1_print_bin8_r2l_at_char:push  af,,bc,,de,,hl
  98+ E186 DD 21 12 E1                            ld    ix,Bin8Bit
  99+ E18A 06 08                                  ld    b,8
 100+ E18C CB 3F        .WriteLoop:               srl   a
 101+ E18E 38 05                                  jr    c,.ItsaOne
 102+ E190 0E 30        .ItsAZero:                ld    c,'0'
 103+ E192 C3 97 E1                               jp    .DoWrite
 104+ E195 0E 31        .ItsaOne:                 ld    c,'1'
 105+ E197 DD 71 00     .DoWrite:                 ld    (ix+0),c
 106+ E19A DD 23                                  inc   ix
 107+ E19C 10 EE                                  djnz  .WriteLoop
 108+ E19E E1 D1 C1 F1                            pop   af,,bc,,de,,hl
 109+ E1A2 21 12 E1                               ld    hl,Bin8Bit
 110+ E1A5 CD D7 E0                               call  l1_print_at_char
 111+ E1A8 C9                                     ret
 112+ E1A9
 113+ E1A9 F5 C5 D5 E5  l1_print_bin8_l2r_at_char:push  af,,bc,,de,,hl
 114+ E1AD DD 21 12 E1                            ld    ix,Bin8Bit
 115+ E1B1 06 08                                  ld    b,8
 116+ E1B3 CB 27        .WriteLoop:               sla   a
 117+ E1B5 38 05                                  jr    c,.ItsaOne
 118+ E1B7 0E 30        .ItsAZero:                ld    c,'0'
 119+ E1B9 C3 BE E1                               jp    .DoWrite
 120+ E1BC 0E 31        .ItsaOne:                 ld    c,'1'
 121+ E1BE DD 71 00     .DoWrite:                 ld    (ix+0),c
 122+ E1C1 DD 23                                  inc   ix
 123+ E1C3 10 EE                                  djnz  .WriteLoop
 124+ E1C5 E1 D1 C1 F1                            pop   af,,bc,,de,,hl
 125+ E1C9 21 12 E1                               ld    hl,Bin8Bit
 126+ E1CC CD D7 E0                               call  l1_print_at_char
 127+ E1CF C9                                     ret
 128+ E1D0
 129+ E1D0              ; prints 16 bit lead sign hex value in HLA at char pos DE
 130+ E1D0 F5           l1_print_s24_hex_at_char: push  af                      ; first off do sign
 131+ E1D1 DD 21 06 E1                            ld    ix,HexS24Char
 132+ E1D5 7C                                     ld    a,h
 133+ E1D6 CD 1B E1                               call  l1_buffer_sign_at_ix
 134+ E1D9 F1                                     pop   af                      ; now do hl as an unsigned by clearing bit 7
 135+ E1DA DD 23                                  inc   ix                      ; move to actual digits
 136+ E1DC F5                                     push  af
 137+ E1DD 7C                                     ld    a,h
 138+ E1DE CB BF                                  res   7,a                     ; clear sign bit regardless
 139+ E1E0 CD 3C E1                               call  l1_buffer_hex_8_at_ix
 140+ E1E3 DD 23                                  inc   ix
 141+ E1E5 DD 23                                  inc   ix
 142+ E1E7 7D                                     ld    a,l
 143+ E1E8 CD 3C E1                               call  l1_buffer_hex_8_at_ix
 144+ E1EB DD 23                                  inc   ix
 145+ E1ED DD 23                                  inc   ix
 146+ E1EF DD 23                                  inc   ix                      ; also skip decimal point
 147+ E1F1 F1                                     pop   af
 148+ E1F2 CD 3C E1                               call  l1_buffer_hex_8_at_ix
 149+ E1F5 21 06 E1                               ld    hl,HexS24Char           ; by here de is still unaffected
 150+ E1F8 CD D7 E0                               call  l1_print_at_char
 151+ E1FB C9                                     ret
 152+ E1FC              ; prints 16 bit lead sign hex value in HL at char pos DE
 153+ E1FC DD 21 00 E1  l1_print_s16_hex_at_char: ld    ix,HexS16Char
 154+ E200 7C                                     ld    a,h
 155+ E201 CD 1B E1                               call  l1_buffer_sign_at_ix
 156+ E204 DD 23                                  inc   ix                      ; move to actual digits
 157+ E206 7C                                     ld    a,h
 158+ E207 CB BF                                  res   7,a
 159+ E209 CD 3C E1                               call  l1_buffer_hex_8_at_ix
 160+ E20C DD 23                                  inc   ix
 161+ E20E DD 23                                  inc   ix
 162+ E210 7D                                     ld    a,l
 163+ E211 CD 3C E1                               call  l1_buffer_hex_8_at_ix
 164+ E214 21 00 E1                               ld    hl,HexS16Char           ; by here de is still unaffected
 165+ E217 CD D7 E0                               call  l1_print_at_char
 166+ E21A C9                                     ret
 167+ E21B              ; prints 16 bit unsigned hext value in HL at char pos DE
 168+ E21B DD 21 F7 E0  l1_print_u16_hex_at_char: ld    ix,HexU16Char
 169+ E21F 7C                                     ld    a,h
 170+ E220 CD 3C E1                               call  l1_buffer_hex_8_at_ix
 171+ E223 DD 23                                  inc   ix
 172+ E225 DD 23                                  inc   ix
 173+ E227 7D                                     ld    a,l
 174+ E228 CD 3C E1                               call  l1_buffer_hex_8_at_ix
 175+ E22B 21 F7 E0                               ld    hl,HexU16Char           ; by here de is still unaffected
 176+ E22E CD D7 E0                               call  l1_print_at_char
 177+ E231 C9                                     ret
 178+ E232              ; prints 8 bit signed hext value in a at char pos DE
 179+ E232 DD 21 FC E0  l1_print_s8_hex_at_char:  ld    ix,HexS8Char
 180+ E236 67                                     ld    h,a                     ; save a into h
 181+ E237 CD 1B E1                               call  l1_buffer_sign_at_ix
 182+ E23A DD 23                                  inc   ix                      ; move to actual digits
 183+ E23C 7C                                     ld    a,h                     ; get a back
 184+ E23D CB BF                                  res   7,a                     ; clear sign bit regardless
 185+ E23F CD 3C E1                               call  l1_buffer_hex_8_at_ix
 186+ E242 21 FC E0                               ld    hl,HexS8Char           ; by here de is still unaffected
 187+ E245 CD D7 E0                               call  l1_print_at_char
 188+ E248 C9                                     ret
 189+ E249              ; prints 8 bit 2s compliment value in a at char pos DE
 190+ E249 DD 21 FC E0  l1_print_82c_hex_at_char: ld    ix,HexS8Char
 191+ E24D 67                                     ld    h,a                     ; save a into h
 192+ E24E CD 1B E1                               call  l1_buffer_sign_at_ix
 193+ E251 DD 23                                  inc   ix                      ; move to actual digits
 194+ E253 7C                                     ld    a,h                     ; get a back
 195+ E254 CB 7F                                  bit   7,a
 196+ E256 CA 5B E2                               jp    z,.NoNeg
 197+ E259 ED 44                                  neg
 198+ E25B CD 3C E1     .NoNeg:                   call  l1_buffer_hex_8_at_ix
 199+ E25E 21 FC E0                               ld    hl,HexS8Char           ; by here de is still unaffected
 200+ E261 CD D7 E0                               call  l1_print_at_char
 201+ E264 C9                                     ret
 202+ E265
 203+ E265              ; prints Lead Sign byte 8 bit signed hex value in hl at char pos DE, reuse HexS8Char buffer
 204+ E265 DD 21 FC E0  l1_print_s08_hex_at_char: ld    ix,HexS8Char
 205+ E269 CD 1B E1                               call  l1_buffer_sign_at_ix    ; h holds sign bit
 206+ E26C DD 23                                  inc   ix                      ; move to actual digits
 207+ E26E 7D                                     ld    a,l                     ; l holds value
 208+ E26F CD 3C E1                               call  l1_buffer_hex_8_at_ix
 209+ E272 21 FC E0                               ld    hl,HexS8Char           ; by here de is still unaffected
 210+ E275 CD D7 E0                               call  l1_print_at_char
 211+ E278 C9                                     ret
 212+ E279              ; prints 8 bit signed hext value in a at char pos DE
 213+ E279 DD 21 F4 E0  l1_print_u8_hex_at_char:  ld    ix,HexU8Char
 214+ E27D CD 3C E1                               call  l1_buffer_hex_8_at_ix
 215+ E280 21 F4 E0                               ld    hl,HexU8Char           ; by here de is still unaffected
 216+ E283 CD D7 E0                               call  l1_print_at_char
 217+ E286 C9                                     ret
 218+ E287 2B 00        l1_PlusSign:              DB      "+",0
 219+ E289 2D 00        l1_MinusSign:             DB      "-",0
 220+ E28B 20 00        l1_ClearSign:             DB      " ",0
 221+ E28D              ; Displays sign byte in A at DE
 222+ E28D FE 80        l1_printSignByte:         cp      $80
 223+ E28F C2 A5 E2                               jp      nz,.DisplayPlus
 224+ E292 FE 01                                  cp      1
 225+ E294 C2 9E E2                               jp      nz,.DisplayMinus
 226+ E297 21 8B E2     .DisplayClear:            ld      hl,l1_ClearSign
 227+ E29A CD D7 E0                               call    l1_print_at_char
 228+ E29D C9                                     ret
 229+ E29E 21 89 E2     .DisplayMinus             ld      hl,l1_MinusSign
 230+ E2A1 CD D7 E0                               call    l1_print_at_char
 231+ E2A4 C9                                     ret
 232+ E2A5 21 87 E2     .DisplayPlus:             ld      hl,l1_PlusSign
 233+ E2A8 CD D7 E0                               call    l1_print_at_char
 234+ E2AB C9                                     ret
 235+ E2AC
 236+ E2AC 21 0F E1     l1_print_u8_nan_at_char:  ld    hl,HexU8NaN
 237+ E2AF CD D7 E0                               call  l1_print_at_char
 238+ E2B2 C9                                     ret
 239+ E2B3
 240+ E2B3
 241+ E2B3              ;l1_print_at_wrap:
 242+ E2B3              ;; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
 243+ E2B3              ;	ld      iyh,e
 244+ E2B3              ;.PrintLoop:
 245+ E2B3              ;	ld		a,(hl)
 246+ E2B3              ;	cp		0
 247+ E2B3              ;	ret		z
 248+ E2B3              ;.CountWordCharLen
 249+ E2B3              ;; Need to change to word wrap, so it will loop through string as before
 250+ E2B3              ;; but read up until a null or space, take the character count * 8 for pixels
 251+ E2B3              ;; if that is > 238 then force a premature line wrap
 252+ E2B3              ;
 253+ E2B3              ;
 254+ E2B3              ;    push    iy
 255+ E2B3              ;    call	l1_print_char
 256+ E2B3              ;    pop     iy
 257+ E2B3              ;	inc		hl							; move 1 message character right
 258+ E2B3              ;	ld		a,e
 259+ E2B3              ;    cp      238
 260+ E2B3              ;    jr      nc,.NextLine
 261+ E2B3              ;	add		a,8
 262+ E2B3              ;	ld		e,a							; move 1 screen character right
 263+ E2B3              ;	jr		.PrintLoop
 264+ E2B3              ;.Clearstackandfinish:
 265+ E2B3              ;	pop		de
 266+ E2B3              ;	ret
 267+ E2B3              ;.NextLine:
 268+ E2B3              ;    ld      a,(hl)
 269+ E2B3              ;    cp      " "
 270+ E2B3              ;    ld      e,iyh
 271+ E2B3              ;    ld      a,d
 272+ E2B3              ;    add     a,8
 273+ E2B3              ;    ld      d,a
 274+ E2B3              ;    jr		.PrintLoop
 275+ E2B3
 276+ E2B3              ; Counts next word at hl, uses e and forces a wrap if it would over flow puts value in c
 277+ E2B3 E5           L1LenWordAtHL:          push    hl
 278+ E2B4 D5                                   push    de
 279+ E2B5 7E           .CountLoop:             ld      a,(hl)
 280+ E2B6 FE 00                                cp      0
 281+ E2B8 28 0F                                jr      z,.CountDone
 282+ E2BA FE 20                                cp      32
 283+ E2BC 28 0B                                jr      z,.CountDone
 284+ E2BE 7B                                   ld      a,e
 285+ E2BF C6 08                                add     a,8
 286+ E2C1 5F                                   ld      e,a
 287+ E2C2 FE EE                                cp      238
 288+ E2C4 30 07                                jr      nc,.TooLong
 289+ E2C6 23                                   inc     hl
 290+ E2C7 18 EC                                jr      .CountLoop
 291+ E2C9 D1           .CountDone:             pop     de
 292+ E2CA E1                                   pop     hl
 293+ E2CB AF                                   xor     a
 294+ E2CC C9                                   ret
 295+ E2CD D1           .TooLong                pop     de
 296+ E2CE E1                                   pop     hl
 297+ E2CF 3E FF                                ld      a,$FF
 298+ E2D1 C9                                   ret
 299+ E2D2
 300+ E2D2 7E           L1PrintWordAtHL:        ld      a,(hl)
 301+ E2D3 FE 00                                cp      0
 302+ E2D5 C8                                   ret     z
 303+ E2D6 FE 20                                cp      32
 304+ E2D8 28 0F                                jr      z,.ItsASpace
 305+ E2DA FD E5                                push    iy
 306+ E2DC CD BA E0                             call	l1_print_char
 307+ E2DF FD E1                                pop     iy
 308+ E2E1 7B                                   ld      a,e
 309+ E2E2 C6 08                                add     a,8
 310+ E2E4 5F                                   ld      e,a
 311+ E2E5 23                                   inc     hl
 312+ E2E6 C3 D2 E2                             jp      L1PrintWordAtHL
 313+ E2E9 23           .ItsASpace:             inc     hl      ;  Just a bodge for now
 314+ E2EA 7B                                   ld      a,e
 315+ E2EB C6 08                                add     a,8
 316+ E2ED 5F                                   ld      e,a
 317+ E2EE C9                                   ret
 318+ E2EF
 319+ E2EF
 320+ E2EF              ; print at based whole character positions DE=yx, HL = message Addr
 321+ E2EF              ;
 322+ E2EF CB 22        l1_print_at_char_wrap:  sla     d       ; Convert D from char to pixel
 323+ E2F1 CB 22                                sla     d       ; by muliplying by 8
 324+ E2F3 CB 22                                sla     d       ;
 325+ E2F5              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
 326+ E2F5              ; Now has full word level wrapping
 327+ E2F5 FD 63        l1_print_at_wrap:       ld      iyh,e
 328+ E2F7 7E           .PrintLoop:             ld		a,(hl)
 329+ E2F8 FE 00                                cp		0
 330+ E2FA C8                                   ret		z
 331+ E2FB CD B3 E2     .CountWordCharLen:      call    L1LenWordAtHL
 332+ E2FE FE FF                                cp      $FF
 333+ E300 28 06                                jr      z,.WrapNextLine
 334+ E302 CD D2 E2     .NotTooLong:            call    L1PrintWordAtHL
 335+ E305              ; Need to change to word wrap, so it will loop through string as before
 336+ E305              ; but read up until a null or space, take the character count * 8 for pixels
 337+ E305              ; if that is > 238 then force a premature line wrap
 338+ E305 18 F0                                jr		.PrintLoop
 339+ E307              .Clearstackandfinish:   ;op		de
 340+ E307 C9                                   ret
 341+ E308              .WrapNextLine:
 342+ E308 FD 5C        .NextLine:              ld      e,iyh
 343+ E30A 7A                                   ld      a,d
 344+ E30B C6 08                                add     a,8
 345+ E30D 57                                   ld      d,a
 346+ E30E 18 E7                                jr		.PrintLoop
 347+ E310
 348+ E310
# file closed: ../../Layer1Graphics/layer1_print_at.asm
 727  E310                  DISPLAY "Bank ",BankLAYER1," - Bytes free ",/D, $2000 - ($-LAYER1Addr), " - BankLAYER1"
 728  E310              ; Bank 59  ------------------------------------------------------------------------------------------------------------------------
 729  E310              ; In the first copy of the banks the "Non number" labels exist. They will map directly in other banks
 730  E310              ; as the is aligned and data tables are after that
 731  E310              ; need to make the ship index tables same size in each to simplify further
 732  E310                  SLOT    ShipModelsAddr
 733  E310                  PAGE    BankShipModels1
 734  E310              	ORG     ShipModelsAddr, BankShipModels1
 735  E000
 736  E000              MShipBankTable          MACRO
 737  E000 ~                                    DW      BankShipModels1
 738  E000 ~                                    DW      BankShipModels2
 739  E000 ~                                    DW      BankShipModels3
 740  E000 ~                                    DW      BankShipModels4
 741  E000                                      ENDM
 742  E000              ; For ship number A fetch
 743  E000              ;           the adjusted ship number in B , C = original number
 744  E000              ;           bank number in A for the respective ship based on the ship table
 745  E000              MGetShipBankId:         MACRO   banktable
 746  E000 ~                                    ld      b,0
 747  E000 ~                                    ld      c,a                                 ; c= original ship id
 748  E000 ~            .ShiftLoop:             srl     a
 749  E000 ~                                    srl     a
 750  E000 ~                                    srl     a
 751  E000 ~                                    srl     a                                   ; divide by 16
 752  E000 ~                                    ld      b,a                                 ; b = bank nbr
 753  E000 ~                                    ld      a,c
 754  E000 ~                                    ld      d,b
 755  E000 ~                                    ld      e,16
 756  E000 ~                                    mul                                         ; de = 16 * bank number (max is about 15 banks)
 757  E000 ~                                    sub     e                                   ; a= actual model id now
 758  E000 ~            .SelectedBank:          ld      d,b                                 ; save current bank number
 759  E000 ~                                    ld      b,a                                 ; b = adjusted ship nbr
 760  E000 ~                                    ld      a,d                                 ; a = bank number
 761  E000 ~            ;.. Now b = bank and a = adjusted ship nbr
 762  E000 ~                                    ld      hl,banktable                        ; a= bank index
 763  E000 ~                                    add     hl,a
 764  E000 ~                                    add     hl,a
 765  E000 ~                                    ld      a,(hl)                              ; a = actual bank now
 766  E000 ~                                    ClearCarryFlag
 767  E000 ~                                    ret
 768  E000                                      ENDM
 769  E000
 770  E000              McopyVertsToUniverse:   MACRO
 771  E000 ~                                    ld          hl,(VerticesAddyAddr)       ; now the pointers are in Ubnk its easy to read
 772  E000 ~                                    ld          de,UBnkHullVerticies
 773  E000 ~                                    ld          b,0
 774  E000 ~                                    ld			a,(VertexCtX6Addr)
 775  E000 ~                                    ld          c,a
 776  E000 ~                                    ex          de,hl                       ; dma transfer goes de -> hl i.e. opposite of ldir
 777  E000 ~                                    call        memcopy_dma
 778  E000 ~                                    ret
 779  E000                                      ENDM
 780  E000
 781  E000              McopyEdgesToUniverse:   MACRO
 782  E000 ~                                    ld          hl,(EdgeAddyAddr)          ; now the pointers are in Ubnk its easy to read
 783  E000 ~                                    ld          de,UBnkHullEdges
 784  E000 ~                                    ld          b,0
 785  E000 ~                                    ld			a,(LineX4Addr)
 786  E000 ~                                    ld          c,a
 787  E000 ~                                    ex          de,hl                       ; dma transfer goes de -> hl i.e. opposite of ldir
 788  E000 ~                                    call        memcopy_dma
 789  E000 ~                                    ret
 790  E000                                      ENDM
 791  E000
 792  E000              McopyNormsToUniverse:   MACRO
 793  E000 ~                                    ld          hl,(FaceAddyAddr)          ; now the pointers are in Ubnk its easy to read
 794  E000 ~                                    ld          de,UBnkHullNormals
 795  E000 ~                                    ld          b,0
 796  E000 ~                                    ld          a,(FaceCtX4Addr)
 797  E000 ~                                    ld          c,a
 798  E000 ~                                    ex          de,hl                       ; dma transfer goes de -> hl i.e. opposite of ldir
 799  E000 ~                                    call        memcopy_dma
 800  E000 ~                                    ret
 801  E000                                      ENDM
 802  E000
 803  E000              ; Passes in ship nbr in A and bank is part of MACRO
 804  E000              MCopyShipToUniverse:    MACRO       banklabel
 805  E000 ~                                    ld          hl,UBnkShipModelBank
 806  E000 ~                                    ld          (hl),banklabel
 807  E000 ~                                    push        af
 808  E000 ~                                    ld          a,iyl
 809  E000 ~                                    ld          (UBnKShipModelId),a
 810  E000 ~                                    pop         af
 811  E000 ~                                    ld          (UBnKShipModelNbr),a
 812  E000 ~            .GetHullDataLength:     ld          hl,ShipModelSizeTable
 813  E000 ~                                    add         hl,a
 814  E000 ~                                    add         hl,a                        ; we won't multiply by 2 as GetInfo is a general purpose routines so would end up x 4
 815  E000 ~                                    ld          c,(hl)
 816  E000 ~                                    inc         hl
 817  E000 ~                                    ld          b,(hl)                      ; bc now equals length of data set
 818  E000 ~            .GetHullDataAddress:    ld          hl,ShipModelTable
 819  E000 ~                                    add         hl,a
 820  E000 ~                                    add         hl,a                        ; now hl = address of ship data value
 821  E000 ~                                    ld          a,(hl)
 822  E000 ~                                    inc         hl
 823  E000 ~                                    ld          h,(hl)
 824  E000 ~                                    ld          l,a                         ; now hl = address of ship hull data
 825  E000 ~                                    ld          de,UBnkHullCopy             ; Universe bank
 826  E000 ~                                    ld          bc,ShipDataLength
 827  E000 ~                                    ldir
 828  E000 ~                                    call        CopyVertsToUniv
 829  E000 ~                                    call        CopyEdgesToUniv
 830  E000 ~                                    call        CopyNormsToUniv
 831  E000 ~            .ClearName:             ld          hl,StartOfUnivName
 832  E000 ~                                    ld          a," "
 833  E000 ~                                    ld          b,16
 834  E000 ~            .fillLoop:              ld          (hl),a
 835  E000 ~                                    inc         hl
 836  E000 ~                                    djnz        .fillLoop
 837  E000 ~                                    ret
 838  E000                                      ENDM
 839  E000
 840  E000              MCopyBodyToUniverse:    MACRO       copyRoutine
 841  E000 ~                                    ld          a,13
 842  E000 ~                                    call        copyRoutine
 843  E000 ~                                    ret
 844  E000                                      ENDM
 845  E000
 846  E000
 847  E000              MCopyShipIdToUniverse:  MACRO
 848  E000 ~                                    call        GetShipModelId
 849  E000 ~                                    MMUSelectShipBankA
 850  E000 ~                                    ld          a,b
 851  E000 ~                                    jp          CopyShipToUniverse
 852  E000                                      ENDM
 853  E000
 854  E000
 855  E000
 856  E000
 857  E000                  INCLUDE "../../Data/ShipBank1Label.asm"
# file opened: ../../Data/ShipBank1Label.asm
   1+ E000 53 68 69 70  ShipBank1Label:         DB  "ShipBank1      "
   1+ E004 42 61 6E 6B
   1+ E008 31 20 20 20
   1+ E00C 20 20 20
   2+ E00F
# file closed: ../../Data/ShipBank1Label.asm
 858  E00F              GetShipBankId:
 859  E00F              GetShipBank1Id:         MGetShipBankId ShipBankTable
 859  E00F 06 00       >                        ld      b,0
 859  E011 4F          >                        ld      c,a                                 ; c= original ship id
 859  E012 CB 3F       >.ShiftLoop:             srl     a
 859  E014 CB 3F       >                        srl     a
 859  E016 CB 3F       >                        srl     a
 859  E018 CB 3F       >                        srl     a                                   ; divide by 16
 859  E01A 47          >                        ld      b,a                                 ; b = bank nbr
 859  E01B 79          >                        ld      a,c
 859  E01C 50          >                        ld      d,b
 859  E01D 1E 10       >                        ld      e,16
 859  E01F ED 30       >                        mul                                         ; de = 16 * bank number (max is about 15 banks)
 859  E021 93          >                        sub     e                                   ; a= actual model id now
 859  E022 50          >.SelectedBank:          ld      d,b                                 ; save current bank number
 859  E023 47          >                        ld      b,a                                 ; b = adjusted ship nbr
 859  E024 7A          >                        ld      a,d                                 ; a = bank number
 859  E025             >;.. Now b = bank and a = adjusted ship nbr
 859  E025 21 62 E0    >                        ld      hl,ShipBankTable                        ; a= bank index
 859  E028 ED 31       >                        add     hl,a
 859  E02A ED 31       >                        add     hl,a
 859  E02C 7E          >                        ld      a,(hl)                              ; a = actual bank now
 859  E02D             >                        ClearCarryFlag
 859  E02D B7          >                        or a
 859  E02E C9          >                        ret
 860  E02F              CopyVertsToUniv:
 861  E02F              CopyVertsToUniv1:       McopyVertsToUniverse
 861  E02F 2A 4C C4    >                        ld          hl,(VerticesAddyAddr)       ; now the pointers are in Ubnk its easy to read
 861  E032 11 52 C4    >                        ld          de,UBnkHullVerticies
 861  E035 06 00       >                        ld          b,0
 861  E037 3A 40 C4    >                        ld			a,(VertexCtX6Addr)
 861  E03A 4F          >                        ld          c,a
 861  E03B EB          >                        ex          de,hl                       ; dma transfer goes de -> hl i.e. opposite of ldir
 861  E03C CD A7 65    >                        call        memcopy_dma
 861  E03F C9          >                        ret
 862  E040              CopyEdgesToUniv:
 863  E040              CopyEdgesToUniv1:       McopyEdgesToUniverse
 863  E040 2A 3A C4    >                        ld          hl,(EdgeAddyAddr)          ; now the pointers are in Ubnk its easy to read
 863  E043 11 42 C5    >                        ld          de,UBnkHullEdges
 863  E046 06 00       >                        ld          b,0
 863  E048 3A 3C C4    >                        ld			a,(LineX4Addr)
 863  E04B 4F          >                        ld          c,a
 863  E04C EB          >                        ex          de,hl                       ; dma transfer goes de -> hl i.e. opposite of ldir
 863  E04D CD A7 65    >                        call        memcopy_dma
 863  E050 C9          >                        ret
 864  E051              CopyNormsToUniv:
 865  E051              CopyNormsToUniv1:       McopyNormsToUniverse
 865  E051 2A 48 C4    >                        ld          hl,(FaceAddyAddr)          ; now the pointers are in Ubnk its easy to read
 865  E054 11 0A C6    >                        ld          de,UBnkHullNormals
 865  E057 06 00       >                        ld          b,0
 865  E059 3A 44 C4    >                        ld          a,(FaceCtX4Addr)
 865  E05C 4F          >                        ld          c,a
 865  E05D EB          >                        ex          de,hl                       ; dma transfer goes de -> hl i.e. opposite of ldir
 865  E05E CD A7 65    >                        call        memcopy_dma
 865  E061 C9          >                        ret
 866  E062              ShipBankTable:
 867  E062              ShipBankTable1:         MShipBankTable
 867  E062 3B 00       >                        DW      BankShipModels1
 867  E064 43 00       >                        DW      BankShipModels2
 867  E066 44 00       >                        DW      BankShipModels3
 867  E068 45 00       >                        DW      BankShipModels4
 868  E06A              CopyShipToUniverse:
 869  E06A              CopyShipToUniverse1     MCopyShipToUniverse     BankShipModels1
 869  E06A 21 42 C0    >                        ld          hl,UBnkShipModelBank
 869  E06D 36 3B       >                        ld          (hl),BankShipModels1
 869  E06F F5          >                        push        af
 869  E070 FD 7D       >                        ld          a,iyl
 869  E072 32 44 C0    >                        ld          (UBnKShipModelId),a
 869  E075 F1          >                        pop         af
 869  E076 32 43 C0    >                        ld          (UBnKShipModelNbr),a
 869  E079 21 31 E1    >.GetHullDataLength:     ld          hl,ShipModelSizeTable
 869  E07C ED 31       >                        add         hl,a
 869  E07E ED 31       >                        add         hl,a                        ; we won't multiply by 2 as GetInfo is a general purpose routines so would end up x 4
 869  E080 4E          >                        ld          c,(hl)
 869  E081 23          >                        inc         hl
 869  E082 46          >                        ld          b,(hl)                      ; bc now equals length of data set
 869  E083 21 B1 E0    >.GetHullDataAddress:    ld          hl,ShipModelTable
 869  E086 ED 31       >                        add         hl,a
 869  E088 ED 31       >                        add         hl,a                        ; now hl = address of ship data value
 869  E08A 7E          >                        ld          a,(hl)
 869  E08B 23          >                        inc         hl
 869  E08C 66          >                        ld          h,(hl)
 869  E08D 6F          >                        ld          l,a                         ; now hl = address of ship hull data
 869  E08E 11 37 C4    >                        ld          de,UBnkHullCopy             ; Universe bank
 869  E091 01 1B 00    >                        ld          bc,ShipDataLength
 869  E094 ED B0       >                        ldir
 869  E096 CD 2F E0    >                        call        CopyVertsToUniv
 869  E099 CD 40 E0    >                        call        CopyEdgesToUniv
 869  E09C CD 51 E0    >                        call        CopyNormsToUniv
 869  E09F 21 10 C0    >.ClearName:             ld          hl,StartOfUnivName
 869  E0A2 3E 20       >                        ld          a," "
 869  E0A4 06 10       >                        ld          b,16
 869  E0A6 77          >.fillLoop:              ld          (hl),a
 869  E0A7 23          >                        inc         hl
 869  E0A8 10 FC       >                        djnz        .fillLoop
 869  E0AA C9          >                        ret
 870  E0AB              CopyBodyToUniverse:
 871  E0AB              CopyBodyToUniverse1:    MCopyBodyToUniverse     CopyShipToUniverse1
 871  E0AB 3E 0D       >                        ld          a,13
 871  E0AD CD 6A E0    >                        call        CopyShipToUniverse1
 871  E0B0 C9          >                        ret
 872  E0B1              ShipModelTable:
 873  E0B1 51 E1        ShipModelTable1:         DW Adder                                   ;00 $00
 874  E0B3 8C E2                                 DW Anaconda                                ;01 $01
 875  E0B5 99 E3                                 DW Asp_Mk_2                                ;02 $02
 876  E0B7 CA E4                                 DW Boa                                     ;03 $03
 877  E0B9 C7 E5                                 DW CargoType5                              ;04 $04
 878  E0BB 9B E6                                 DW Boulder                                 ;05 $05
 879  E0BD 48 E7                                 DW Asteroid                                ;06 $06
 880  E0BF 29 E8                                 DW Bushmaster                              ;07 $07
 881  E0C1 00 E9                                 DW Chameleon                               ;08 $08
 882  E0C3 32 EA                                 DW CobraMk3                                ;09 $09
 883  E0C5 C5 EB                                 DW Cobra_Mk_1                              ;10 $0A
 884  E0C7 96 EC                                 DW Cobra_Mk_3_P                            ;11 $0B
 885  E0C9 29 EE                                 DW Constrictor                             ;12 $0C
 886  E0CB 36 EF                                 DW Coriolis                                ;13 $0D
 887  E0CD 5D F0                                 DW Cougar                                  ;14 $0E
 888  E0CF 6A F1                                 DW Dodo                                    ;15 $0F
 889  E0D1              ShipVertexTable:
 890  E0D1 70 E1        ShipVertexTable1:        DW AdderVertices                           ;00 $00
 891  E0D3 AB E2                                 DW AnacondaVertices                        ;01 $01
 892  E0D5 B8 E3                                 DW Asp_Mk_2Vertices                        ;02 $02
 893  E0D7 E9 E4                                 DW BoaVertices                             ;03 $03
 894  E0D9 E6 E5                                 DW CargoType5Vertices                      ;04 $04
 895  E0DB BA E6                                 DW BoulderVertices                         ;05 $05
 896  E0DD 67 E7                                 DW AsteroidVertices                        ;06 $06
 897  E0DF 48 E8                                 DW BushmasterVertices                      ;07 $07
 898  E0E1 1E E9                                 DW ChameleonVertices                       ;08 $08
 899  E0E3 51 EA                                 DW CobraMk3Vertices                        ;09 $09
 900  E0E5 E4 EB                                 DW Cobra_Mk_1Vertices                      ;10 $0A
 901  E0E7 B5 EC                                 DW Cobra_Mk_3_PVertices                    ;11 $0B
 902  E0E9 48 EE                                 DW ConstrictorVertices                     ;12 $0C
 903  E0EB 55 EF                                 DW CoriolisVertices                        ;13 $0D
 904  E0ED 7C F0                                 DW CougarVertices                          ;14 $0E
 905  E0EF 89 F1                                 DW DodoVertices                            ;15 $0F
 906  E0F1              ShipEdgeTable:
 907  E0F1 DC E1        ShipEdgeTable1:          DW AdderEdges                              ;00 $00
 908  E0F3 05 E3                                 DW AnacondaEdges                           ;01 $01
 909  E0F5 2A E4                                 DW Asp_Mk_2Edges                           ;02 $02
 910  E0F7 37 E5                                 DW BoaEdges                                ;03 $03
 911  E0F9 22 E6                                 DW CargoType5Edges                         ;04 $04
 912  E0FB E4 E6                                 DW BoulderEdges                            ;05 $05
 913  E0FD 9D E7                                 DW AsteroidEdges                           ;06 $06
 914  E0FF 90 E8                                 DW BushmasterEdges                         ;07 $07
 915  E101 8A E9                                 DW ChameleonEdges                          ;08 $08
 916  E103 F9 EA                                 DW CobraMk3Edges                           ;09 $09
 917  E105 26 EC                                 DW Cobra_Mk_1Edges                         ;10 $0A
 918  E107 5D ED                                 DW Cobra_Mk_3_PEdges                       ;11 $0B
 919  E109 AE EE                                 DW ConstrictorEdges                        ;12 $0C
 920  E10B B5 EF                                 DW CoriolisEdges                           ;13 $0D
 921  E10D EE F0                                 DW CougarEdges                             ;14 $0E
 922  E10F 19 F2                                 DW DodoEdges                               ;15 $0F
 923  E111              ShipNormalTable:
 924  E111 50 E2        ShipNormalTable1:        DW AdderNormals                            ;00 $00
 925  E113 69 E3                                 DW AnacondaNormals                         ;01 $01
 926  E115 9A E4                                 DW Asp_Mk_2Normals                         ;02 $02
 927  E117 97 E5                                 DW BoaNormals                              ;03 $03
 928  E119 5E E6                                 DW CargoType5Normals                       ;04 $04
 929  E11B 20 E7                                 DW BoulderNormals                          ;05 $05
 930  E11D F1 E7                                 DW AsteroidNormals                         ;06 $06
 931  E11F DC E8                                 DW BushmasterNormals                       ;07 $07
 932  E121 FE E9                                 DW ChameleonNormals                        ;08 $08
 933  E123 91 EB                                 DW CobraMk3Normals                         ;09 $09
 934  E125 6E EC                                 DW Cobra_Mk_1Normals                       ;10 $0A
 935  E127 F5 ED                                 DW Cobra_Mk_3_PNormals                     ;11 $0B
 936  E129 0E EF                                 DW ConstrictorNormals                      ;12 $0C
 937  E12B 25 F0                                 DW CoriolisNormals                         ;13 $0D
 938  E12D 52 F1                                 DW CougarNormals                           ;14 $0E
 939  E12F A1 F2                                 DW DodoNormals                             ;15 $0F
 940  E131              ShipModelSizeTable:
 941  E131 3B 01        ShipModelSizeTable1:     DW AdderLen                                ;00 $00
 942  E133 0D 01                                 DW AnacondaLen                             ;01 $01
 943  E135 31 01                                 DW Asp_Mk_2Len                             ;02 $02
 944  E137 FD 00                                 DW BoaLen                                  ;03 $03
 945  E139 B3 00                                 DW CargoType5Len                           ;04 $04
 946  E13B AD 00                                 DW BoulderLen                              ;05 $05
 947  E13D E1 00                                 DW AsteroidLen                             ;06 $06
 948  E13F D7 00                                 DW BushmasterLen                           ;07 $07
 949  E141 32 01                                 DW ChameleonLen                            ;08 $08
 950  E143 93 01                                 DW CobraMk3Len                             ;09 $09
 951  E145 D1 00                                 DW Cobra_Mk_1Len                           ;10 $0A
 952  E147 93 01                                 DW Cobra_Mk_3_PLen                         ;11 $0B
 953  E149 0D 01                                 DW ConstrictorLen                          ;12 $0C
 954  E14B 27 01                                 DW CoriolisLen                             ;13 $0D
 955  E14D 0D 01                                 DW CougarLen                               ;14 $0E
 956  E14F 67 01                                 DW DodoLen                                 ;15 $0F
 957  E151
 958  E151                                      include "../../Data/ships/Adder.asm"
# file opened: ../../Data/ships/Adder.asm
   1+ E151 00           Adder:	                DB $00                              ; Number of cargo canisters released when destroyed
   2+ E152 C4 09                                DW 50 * 50                          ; Ship's targetable area LoHi
   3+ E154 DC E1                                DW AdderEdges                       ; Edge Data
   4+ E156 74                                   DB AdderEdgesSize                   ; Size of Edge Data
   5+ E157 00                                   DB $00                              ; Gun Vertex Byte offset
   6+ E158 16                                   DB $16                              ; Explosion Count
   7+ E159 12                                   DB AdderVertSize / 6                ; Vertex Count /6
   8+ E15A 6C                                   DB AdderVertSize                    ; Vertex Count
   9+ E15B 1D                                   DB AdderEdgesCnt                    ; Edges Count
  10+ E15C 28 00                                DW $0028                            ; Bounty LoHi
  11+ E15E 3C                                   DB AdderNormalsSize                 ; Face (Normal) Count
  12+ E15F 17                                   DB $17                              ; Range when it turns to a dot
  13+ E160 48                                   DB $48                              ; Energy Max
  14+ E161 18                                   DB $18                              ; Speed Max
  15+ E162 50 E2                                DW AdderNormals                     ; Normals
  16+ E164 12                                   DB $12                              ; Q scaling
  17+ E165 21                                   DB $21                              ; Laser power and Nbr Missiles
  18+ E166 70 E1                                DW AdderVertices                    ; Verticles Address
  19+ E168 00                                   DB ShipTypeNormal                   ; Ship Type
  20+ E169 00                                   DB 0                                ; NewB Tactics
  21+ E16A 80                                   DB ShipCanAnger                     ; AI Flags
  22+ E16B 80                                   DB $80                              ; chance of ECM module
  23+ E16C FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ E16D 00 00                                DW $0000                            ; no solid data
  25+ E16F 00                                   DB $00                              ; no solid data
  26+ E170
  27+ E170                                                     ; chance of ECM module
  28+ E170 12 00 28 9F  AdderVertices:	        DB $12, $00, $28, $9F, $01, $BC     ;01
  28+ E174 01 BC
  29+ E176 12 00 28 1F                          DB $12, $00, $28, $1F, $01, $23     ;02
  29+ E17A 01 23
  30+ E17C 1E 00 18 3F                          DB $1E, $00, $18, $3F, $23, $45     ;03
  30+ E180 23 45
  31+ E182 1E 00 28 3F                          DB $1E, $00, $28, $3F, $45, $66     ;04
  31+ E186 45 66
  32+ E188 12 07 28 7F                          DB $12, $07, $28, $7F, $56, $7E     ;05
  32+ E18C 56 7E
  33+ E18E 12 07 28 FF                          DB $12, $07, $28, $FF, $78, $AE     ;06
  33+ E192 78 AE
  34+ E194 1E 00 28 BF                          DB $1E, $00, $28, $BF, $89, $AA     ;07
  34+ E198 89 AA
  35+ E19A 1E 00 18 BF                          DB $1E, $00, $18, $BF, $9A, $BC     ;08
  35+ E19E 9A BC
  36+ E1A0 12 07 28 BF                          DB $12, $07, $28, $BF, $78, $9D     ;09
  36+ E1A4 78 9D
  37+ E1A6 12 07 28 3F                          DB $12, $07, $28, $3F, $46, $7D     ;10
  37+ E1AA 46 7D
  38+ E1AC 12 07 0D 9F                          DB $12, $07, $0D, $9F, $09, $BD     ;11
  38+ E1B0 09 BD
  39+ E1B2 12 07 0D 1F                          DB $12, $07, $0D, $1F, $02, $4D     ;12
  39+ E1B6 02 4D
  40+ E1B8 12 07 0D DF                          DB $12, $07, $0D, $DF, $1A, $CE     ;13
  40+ E1BC 1A CE
  41+ E1BE 12 07 0D 5F                          DB $12, $07, $0D, $5F, $13, $5E     ;14
  41+ E1C2 13 5E
  42+ E1C4 0B 03 1D 85                          DB $0B, $03, $1D, $85, $00, $00     ;15
  42+ E1C8 00 00
  43+ E1CA 0B 03 1D 05                          DB $0B, $03, $1D, $05, $00, $00     ;16
  43+ E1CE 00 00
  44+ E1D0 0B 04 18 04                          DB $0B, $04, $18, $04, $00, $00     ;17
  44+ E1D4 00 00
  45+ E1D6 0B 04 18 84                          DB $0B, $04, $18, $84, $00, $00     ;18
  45+ E1DA 00 00
  46+ E1DC              AdderVertSize:          equ $ - AdderVertices
  47+ E1DC 1F 01 00 04  AdderEdges:	            DB $1F, $01, $00, $04               ;01
  48+ E1E0 07 23 04 08                          DB $07, $23, $04, $08               ;02
  49+ E1E4 1F 45 08 0C                          DB $1F, $45, $08, $0C               ;03
  50+ E1E8 1F 56 0C 10                          DB $1F, $56, $0C, $10               ;04
  51+ E1EC 1F 7E 10 14                          DB $1F, $7E, $10, $14               ;05
  52+ E1F0 1F 8A 14 18                          DB $1F, $8A, $14, $18               ;06
  53+ E1F4 1F 9A 18 1C                          DB $1F, $9A, $18, $1C               ;07
  54+ E1F8 07 BC 1C 00                          DB $07, $BC, $1C, $00               ;08
  55+ E1FC 1F 46 0C 24                          DB $1F, $46, $0C, $24               ;09
  56+ E200 1F 7D 24 20                          DB $1F, $7D, $24, $20               ;10
  57+ E204 1F 89 20 18                          DB $1F, $89, $20, $18               ;11
  58+ E208 1F 0B 00 28                          DB $1F, $0B, $00, $28               ;12
  59+ E20C 1F 9B 1C 28                          DB $1F, $9B, $1C, $28               ;13
  60+ E210 1F 02 04 2C                          DB $1F, $02, $04, $2C               ;14
  61+ E214 1F 24 08 2C                          DB $1F, $24, $08, $2C               ;15
  62+ E218 1F 1C 00 30                          DB $1F, $1C, $00, $30               ;16
  63+ E21C 1F AC 1C 30                          DB $1F, $AC, $1C, $30               ;17
  64+ E220 1F 13 04 34                          DB $1F, $13, $04, $34               ;18
  65+ E224 1F 35 08 34                          DB $1F, $35, $08, $34               ;19
  66+ E228 1F 0D 28 2C                          DB $1F, $0D, $28, $2C               ;20
  67+ E22C 1F 1E 30 34                          DB $1F, $1E, $30, $34               ;21
  68+ E230 1F 9D 20 28                          DB $1F, $9D, $20, $28               ;22
  69+ E234 1F 4D 24 2C                          DB $1F, $4D, $24, $2C               ;23
  70+ E238 1F AE 14 30                          DB $1F, $AE, $14, $30               ;24
  71+ E23C 1F 5E 10 34                          DB $1F, $5E, $10, $34               ;25
  72+ E240 05 00 38 3C                          DB $05, $00, $38, $3C               ;26
  73+ E244 03 00 3C 40                          DB $03, $00, $3C, $40               ;27
  74+ E248 04 00 40 44                          DB $04, $00, $40, $44               ;28
  75+ E24C 03 00 44 38                          DB $03, $00, $44, $38               ;29
  76+ E250              AdderEdgesSize:         equ $ - AdderEdges
  77+ E250              AdderEdgesCnt:          equ AdderEdgesSize/4
  78+ E250 1F 00 27 0A  AdderNormals:	        DB $1F, $00, $27, $0A               ;01
  79+ E254 5F 00 27 0A                          DB $5F, $00, $27, $0A               ;02
  80+ E258 1F 45 32 0D                          DB $1F, $45, $32, $0D               ;03
  81+ E25C 5F 45 32 0D                          DB $5F, $45, $32, $0D               ;04
  82+ E260 1F 1E 34 00                          DB $1F, $1E, $34, $00               ;05
  83+ E264 5F 1E 34 00                          DB $5F, $1E, $34, $00               ;06
  84+ E268 3F 00 00 A0                          DB $3F, $00, $00, $A0               ;07
  85+ E26C 3F 00 00 A0                          DB $3F, $00, $00, $A0               ;08
  86+ E270 3F 00 00 A0                          DB $3F, $00, $00, $A0               ;09
  87+ E274 9F 1E 34 00                          DB $9F, $1E, $34, $00               ;10
  88+ E278 DF 1E 34 00                          DB $DF, $1E, $34, $00               ;11
  89+ E27C 9F 45 32 0D                          DB $9F, $45, $32, $0D               ;12
  90+ E280 DF 45 32 0D                          DB $DF, $45, $32, $0D               ;13
  91+ E284 1F 00 1C 00                          DB $1F, $00, $1C, $00               ;14
  92+ E288 5F 00 1C 00                          DB $5F, $00, $1C, $00               ;15
  93+ E28C
  94+ E28C              AdderNormalsSize:       equ $ - AdderNormals
  95+ E28C              AdderLen:                equ $ - Adder
  96+ E28C
  97+ E28C
  98+ E28C
  99+ E28C
 100+ E28C
 101+ E28C
 102+ E28C
 103+ E28C
 104+ E28C
 105+ E28C
 106+ E28C
# file closed: ../../Data/ships/Adder.asm
 959  E28C                                      include "../../Data/ships/Anaconda.asm"
# file opened: ../../Data/ships/Anaconda.asm
   1+ E28C 07           Anaconda:	            DB $07                                                        ; Number of cargo canisters released when destroyed
   2+ E28D 10 27                                DW 100 * 100                                                  ; Ship's targetable area LoHi
   3+ E28F 05 E3                                DW AnacondaEdges                                              ; Edge Data
   4+ E291 64                                   DB AnacondaEdgesSize                                          ; Size of Edge Data
   5+ E292 30                                   DB $30                                                        ; Gun Vertex Byte offset
   6+ E293 2E                                   DB $2E                                                        ; Explosion Count
   7+ E294 0F                                   DB AnacondaVertSize / 6                                       ; Vertex Count /6
   8+ E295 5A                                   DB AnacondaVertSize                                           ; Vertex Count
   9+ E296 19                                   DB AnacondaEdgesCnt                                           ; Edges Count
  10+ E297 00 00                                DW $0000                                                      ; Bounty LoHi
  11+ E299 30                                   DB AnacondaNormalsSize                                        ; Face (Normal) Count
  12+ E29A 24                                   DB $24                                                        ; Range when it turns to a dot
  13+ E29B FC                                   DB $FC                                                        ; Energy Max
  14+ E29C 0E                                   DB $0E                                                        ; Speed Max
  15+ E29D 69 E3                                DW AnacondaNormals                                            ; Normals
  16+ E29F 11                                   DB $11                                                        ; Q scaling
  17+ E2A0 3F                                   DB $3F                                                        ; Laser power and Nbr Missiles
  18+ E2A1 AB E2                                DW AnacondaVertices                                           ; Verticles Address
  19+ E2A3 00                                   DB ShipTypeNormal                                             ; Ship Type
  20+ E2A4 00                                   DB 0                                                          ; NewB Tactics
  21+ E2A5 A4                                   DB ShipCanAnger | ShipFighterBaySize2 | ShipFighterSidewinder ; AI Flags
  22+ E2A6 D0                                   DB $D0                                                        ; chance of ECM module
  23+ E2A7 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ E2A8 00 00                                DW $0000                            ; no solid data
  25+ E2AA 00                                   DB $00                              ; no solid data
  26+ E2AB
  27+ E2AB 00 07 3A 3E  AnacondaVertices:	    DB $00, $07, $3A, $3E, $01, $55 ;01
  27+ E2AF 01 55
  28+ E2B1 2B 0D 25 FE                          DB $2B, $0D, $25, $FE, $01, $22 ;02
  28+ E2B5 01 22
  29+ E2B7 1A 2F 03 FE                          DB $1A, $2F, $03, $FE, $02, $33 ;03
  29+ E2BB 02 33
  30+ E2BD 1A 2F 03 7E                          DB $1A, $2F, $03, $7E, $03, $44 ;04
  30+ E2C1 03 44
  31+ E2C3 2B 0D 25 7E                          DB $2B, $0D, $25, $7E, $04, $55 ;05
  31+ E2C7 04 55
  32+ E2C9 00 30 31 3E                          DB $00, $30, $31, $3E, $15, $66 ;06
  32+ E2CD 15 66
  33+ E2CF 45 0F 0F BE                          DB $45, $0F, $0F, $BE, $12, $77 ;07
  33+ E2D3 12 77
  34+ E2D5 2B 27 28 DF                          DB $2B, $27, $28, $DF, $23, $88 ;08
  34+ E2D9 23 88
  35+ E2DB 2B 27 28 5F                          DB $2B, $27, $28, $5F, $34, $99 ;09
  35+ E2DF 34 99
  36+ E2E1 45 0F 0F 3E                          DB $45, $0F, $0F, $3E, $45, $AA ;10
  36+ E2E5 45 AA
  37+ E2E7 2B 35 17 BF                          DB $2B, $35, $17, $BF, $FF, $FF ;11
  37+ E2EB FF FF
  38+ E2ED 45 01 20 DF                          DB $45, $01, $20, $DF, $27, $88 ;12
  38+ E2F1 27 88
  39+ E2F3 00 00 FE 1F                          DB $00, $00, $FE, $1F, $FF, $FF ;13
  39+ E2F7 FF FF
  40+ E2F9 45 01 20 5F                          DB $45, $01, $20, $5F, $49, $AA ;14
  40+ E2FD 49 AA
  41+ E2FF 2B 35 17 3F                          DB $2B, $35, $17, $3F, $FF, $FF ;15
  41+ E303 FF FF
  42+ E305              AnacondaVertSize:       equ $ - AnacondaVertices
  43+ E305 1E 01 00 04  AnacondaEdges:	        DB $1E, $01, $00, $04           ;01
  44+ E309 1E 02 04 08                          DB $1E, $02, $04, $08           ;02
  45+ E30D 1E 03 08 0C                          DB $1E, $03, $08, $0C           ;03
  46+ E311 1E 04 0C 10                          DB $1E, $04, $0C, $10           ;04
  47+ E315 1E 05 00 10                          DB $1E, $05, $00, $10           ;05
  48+ E319 1D 15 00 14                          DB $1D, $15, $00, $14           ;06
  49+ E31D 1D 12 04 18                          DB $1D, $12, $04, $18           ;07
  50+ E321 1D 23 08 1C                          DB $1D, $23, $08, $1C           ;08
  51+ E325 1D 34 0C 20                          DB $1D, $34, $0C, $20           ;09
  52+ E329 1D 45 10 24                          DB $1D, $45, $10, $24           ;10
  53+ E32D 1E 16 14 28                          DB $1E, $16, $14, $28           ;11
  54+ E331 1E 17 18 28                          DB $1E, $17, $18, $28           ;12
  55+ E335 1E 27 18 2C                          DB $1E, $27, $18, $2C           ;13
  56+ E339 1E 28 1C 2C                          DB $1E, $28, $1C, $2C           ;14
  57+ E33D 1F 38 1C 30                          DB $1F, $38, $1C, $30           ;15
  58+ E341 1F 39 20 30                          DB $1F, $39, $20, $30           ;16
  59+ E345 1E 49 20 34                          DB $1E, $49, $20, $34           ;17
  60+ E349 1E 4A 24 34                          DB $1E, $4A, $24, $34           ;18
  61+ E34D 1E 5A 24 38                          DB $1E, $5A, $24, $38
  62+ E351 1E 56 14 38                          DB $1E, $56, $14, $38
  63+ E355 1E 6B 28 38                          DB $1E, $6B, $28, $38
  64+ E359 1F 7B 28 30                          DB $1F, $7B, $28, $30
  65+ E35D 1F 78 2C 30                          DB $1F, $78, $2C, $30
  66+ E361 1F 9A 30 34                          DB $1F, $9A, $30, $34
  67+ E365 1F AB 30 38                          DB $1F, $AB, $30, $38
  68+ E369              AnacondaEdgesSize:      equ $ - AnacondaEdges
  69+ E369              AnacondaEdgesCnt:       equ AnacondaEdgesSize/4
  70+ E369 7E 00 33 31  AnacondaNormals:	    DB $7E, $00, $33, $31           ;01
  71+ E36D BE 33 12 57                          DB $BE, $33, $12, $57           ;02
  72+ E371 FE 4D 39 13                          DB $FE, $4D, $39, $13           ;03
  73+ E375 5F 00 5A 10                          DB $5F, $00, $5A, $10           ;04
  74+ E379 7E 4D 39 13                          DB $7E, $4D, $39, $13           ;05
  75+ E37D 3E 33 12 57                          DB $3E, $33, $12, $57           ;06
  76+ E381 3E 00 6F 14                          DB $3E, $00, $6F, $14           ;07
  77+ E385 9F 61 48 18                          DB $9F, $61, $48, $18           ;08
  78+ E389 DF 6C 44 22                          DB $DF, $6C, $44, $22           ;09
  79+ E38D 5F 6C 44 22                          DB $5F, $6C, $44, $22           ;10
  80+ E391 1F 61 48 18                          DB $1F, $61, $48, $18           ;11
  81+ E395 1F 00 5E 12                          DB $1F, $00, $5E, $12           ;12
  82+ E399              AnacondaNormalsSize:    equ $ - AnacondaNormals
  83+ E399              AnacondaLen:            equ $ - Anaconda
  84+ E399
  85+ E399
  86+ E399
  87+ E399
# file closed: ../../Data/ships/Anaconda.asm
 960  E399                                      include "../../Data/ships/Asp_Mk_2.asm"
# file opened: ../../Data/ships/Asp_Mk_2.asm
   1+ E399 00           Asp_Mk_2:	            DB $00                          ; Number of cargo canisters released when destroyed
   2+ E39A 10 0E                                DW 60 * 60                      ; Ship's targetable area LoHi
   3+ E39C 2A E4                                DW Asp_Mk_2Edges                ; Edge Data
   4+ E39E 70                                   DB Asp_Mk_2EdgesSize            ; Size of Edge Data
   5+ E39F 20                                   DB $20                          ; Gun Vertex Byte offset
   6+ E3A0 1A                                   DB $1A                          ; Explosion Count
   7+ E3A1 13                                   DB Asp_Mk_2VertSize /6          ; Vertex Count /6
   8+ E3A2 72                                   DB Asp_Mk_2VertSize             ; Vertex Count
   9+ E3A3 1C                                   DB Asp_Mk_2EdgesCnt             ; Edges Count
  10+ E3A4 C8 00                                DW $00C8                        ; Bounty LoHi
  11+ E3A6 30                                   DB Asp_Mk_2NormalsSize          ; Face (Normal) Count
  12+ E3A7 28                                   DB $28                          ; Range when it turns to a dot
  13+ E3A8 96                                   DB $96                          ; Energy Max
  14+ E3A9 28                                   DB $28                          ; Speed Max
  15+ E3AA 9A E4                                DW Asp_Mk_2Normals              ; Normals
  16+ E3AC 01                                   DB $01                          ; Q scaling
  17+ E3AD 29                                   DB $29                          ; Laser power and Nbr Missiles
  18+ E3AE B8 E3                                DW Asp_Mk_2Vertices             ; Verticles Address
  19+ E3B0 00                                   DB ShipTypeNormal               ; Ship Type
  20+ E3B1 00                                   DB 0                            ; NewB Tactics
  21+ E3B2 80                                   DB ShipCanAnger                 ; AI Flags
  22+ E3B3 80                                   DB $80                          ; chance of ECM module
  23+ E3B4 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ E3B5 00 00                                DW $0000                            ; no solid data
  25+ E3B7 00                                   DB $00                              ; no solid data
  26+ E3B8
  27+ E3B8 00 12 00 56  Asp_Mk_2Vertices:	    DB $00, $12, $00, $56, $01, $22 ;01
  27+ E3BC 01 22
  28+ E3BE 00 09 2D 7F                          DB $00, $09, $2D, $7F, $12, $BB ;02
  28+ E3C2 12 BB
  29+ E3C4 2B 00 2D 3F                          DB $2B, $00, $2D, $3F, $16, $BB ;03
  29+ E3C8 16 BB
  30+ E3CA 45 03 00 5F                          DB $45, $03, $00, $5F, $16, $79 ;04
  30+ E3CE 16 79
  31+ E3D0 2B 0E 1C 5F                          DB $2B, $0E, $1C, $5F, $01, $77 ;05
  31+ E3D4 01 77
  32+ E3D6 2B 00 2D BF                          DB $2B, $00, $2D, $BF, $25, $BB ;06
  32+ E3DA 25 BB
  33+ E3DC 45 03 00 DF                          DB $45, $03, $00, $DF, $25, $8A ;07
  33+ E3E0 25 8A
  34+ E3E2 2B 0E 1C DF                          DB $2B, $0E, $1C, $DF, $02, $88 ;08
  34+ E3E6 02 88
  35+ E3E8 1A 07 49 5F                          DB $1A, $07, $49, $5F, $04, $79 ;09
  35+ E3EC 04 79
  36+ E3EE 1A 07 49 DF                          DB $1A, $07, $49, $DF, $04, $8A ;10
  36+ E3F2 04 8A
  37+ E3F4 2B 0E 1C 1F                          DB $2B, $0E, $1C, $1F, $34, $69 ;11
  37+ E3F8 34 69
  38+ E3FA 2B 0E 1C 9F                          DB $2B, $0E, $1C, $9F, $34, $5A ;12
  38+ E3FE 34 5A
  39+ E400 00 09 2D 3F                          DB $00, $09, $2D, $3F, $35, $6B ;13
  39+ E404 35 6B
  40+ E406 11 00 2D AA                          DB $11, $00, $2D, $AA, $BB, $BB ;14
  40+ E40A BB BB
  41+ E40C 11 00 2D 29                          DB $11, $00, $2D, $29, $BB, $BB ;15
  41+ E410 BB BB
  42+ E412 00 04 2D 6A                          DB $00, $04, $2D, $6A, $BB, $BB ;16
  42+ E416 BB BB
  43+ E418 00 04 2D 28                          DB $00, $04, $2D, $28, $BB, $BB ;17
  43+ E41C BB BB
  44+ E41E 00 07 49 4A                          DB $00, $07, $49, $4A, $04, $04 ;18
  44+ E422 04 04
  45+ E424 00 07 53 4A                          DB $00, $07, $53, $4A, $04, $04 ;19
  45+ E428 04 04
  46+ E42A              Asp_Mk_2VertSize:       equ $ - Asp_Mk_2Vertices
  47+ E42A 16 12 00 04  Asp_Mk_2Edges:	        DB $16, $12, $00, $04           ;01
  48+ E42E 16 01 00 10                          DB $16, $01, $00, $10           ;02
  49+ E432 16 02 00 1C                          DB $16, $02, $00, $1C           ;03
  50+ E436 1F 1B 04 08                          DB $1F, $1B, $04, $08           ;04
  51+ E43A 1F 16 08 0C                          DB $1F, $16, $08, $0C           ;05
  52+ E43E 10 79 0C 20                          DB $10, $79, $0C, $20           ;06
  53+ E442 1F 04 20 24                          DB $1F, $04, $20, $24           ;07
  54+ E446 10 8A 18 24                          DB $10, $8A, $18, $24           ;08
  55+ E44A 1F 25 14 18                          DB $1F, $25, $14, $18           ;09
  56+ E44E 1F 2B 04 14                          DB $1F, $2B, $04, $14           ;10
  57+ E452 1F 17 0C 10                          DB $1F, $17, $0C, $10           ;11
  58+ E456 1F 07 10 20                          DB $1F, $07, $10, $20           ;12
  59+ E45A 1F 28 18 1C                          DB $1F, $28, $18, $1C           ;13
  60+ E45E 1F 08 1C 24                          DB $1F, $08, $1C, $24           ;14
  61+ E462 1F 6B 08 30                          DB $1F, $6B, $08, $30           ;15
  62+ E466 1F 5B 14 30                          DB $1F, $5B, $14, $30           ;16
  63+ E46A 16 36 28 30                          DB $16, $36, $28, $30           ;17
  64+ E46E 16 35 2C 30                          DB $16, $35, $2C, $30           ;18
  65+ E472 16 34 28 2C                          DB $16, $34, $28, $2C
  66+ E476 1F 5A 18 2C                          DB $1F, $5A, $18, $2C
  67+ E47A 1F 4A 24 2C                          DB $1F, $4A, $24, $2C
  68+ E47E 1F 69 0C 28                          DB $1F, $69, $0C, $28
  69+ E482 1F 49 20 28                          DB $1F, $49, $20, $28
  70+ E486 0A BB 34 3C                          DB $0A, $BB, $34, $3C
  71+ E48A 09 BB 3C 38                          DB $09, $BB, $3C, $38
  72+ E48E 08 BB 38 40                          DB $08, $BB, $38, $40
  73+ E492 08 BB 40 34                          DB $08, $BB, $40, $34
  74+ E496 0A 04 48 44                          DB $0A, $04, $48, $44
  75+ E49A              Asp_Mk_2EdgesSize:      equ $ - Asp_Mk_2Edges
  76+ E49A              Asp_Mk_2EdgesCnt:       equ Asp_Mk_2EdgesSize/4
  77+ E49A 5F 00 23 05  Asp_Mk_2Normals:	    DB $5F, $00, $23, $05           ;01
  78+ E49E 7F 08 26 07                          DB $7F, $08, $26, $07           ;02
  79+ E4A2 FF 08 26 07                          DB $FF, $08, $26, $07           ;03
  80+ E4A6 36 00 18 01                          DB $36, $00, $18, $01           ;04
  81+ E4AA 1F 00 2B 13                          DB $1F, $00, $2B, $13           ;05
  82+ E4AE BF 06 1C 02                          DB $BF, $06, $1C, $02           ;06
  83+ E4B2 3F 06 1C 02                          DB $3F, $06, $1C, $02           ;07
  84+ E4B6 5F 3B 40 1F                          DB $5F, $3B, $40, $1F           ;08
  85+ E4BA DF 3B 40 1F                          DB $DF, $3B, $40, $1F           ;09
  86+ E4BE 1F 50 2E 32                          DB $1F, $50, $2E, $32           ;10
  87+ E4C2 9F 50 2E 32                          DB $9F, $50, $2E, $32           ;11
  88+ E4C6 3F 00 00 5A                          DB $3F, $00, $00, $5A           ;12
  89+ E4CA              Asp_Mk_2NormalsSize:    equ $ - Asp_Mk_2Normals
  90+ E4CA              Asp_Mk_2Len:            equ $ - Asp_Mk_2
  91+ E4CA
  92+ E4CA
  93+ E4CA
  94+ E4CA
# file closed: ../../Data/ships/Asp_Mk_2.asm
 961  E4CA                                      include "../../Data/ships/Boa.asm"
# file opened: ../../Data/ships/Boa.asm
   1+ E4CA 05           Boa:	                DB $05                          ; Number of cargo canisters released when destroyed
   2+ E4CB 24 13                                DW 70 * 70                      ; Ship's targetable area LoHi
   3+ E4CD 37 E5                                DW BoaEdges                     ; Edge Data
   4+ E4CF 60                                   DB BoaEdgesSize                 ; Size of Edge Data
   5+ E4D0 00                                   DB $00                          ; Gun Vertex Byte offset
   6+ E4D1 26                                   DB $26                          ; Explosion Count
   7+ E4D2 0D                                   DB BoaVertSize /6               ; Vertex Count /6
   8+ E4D3 4E                                   DB BoaVertSize                  ; Vertex Count
   9+ E4D4 18                                   DB BoaEdgesCnt                  ; Edges Count
  10+ E4D5 00 00                                DW $0000                        ; Bounty LoHi
  11+ E4D7 30                                   DB BoaNormalsSize               ; Face (Normal) Count
  12+ E4D8 28                                   DB $28                          ; Range when it turns to a dot
  13+ E4D9 FA                                   DB $FA                          ; Energy Max
  14+ E4DA 18                                   DB $18                          ; Speed Max
  15+ E4DB 97 E5                                DW BoaNormals                   ; Normals
  16+ E4DD 00                                   DB $00                          ; Q scaling
  17+ E4DE 1C                                   DB $1C                          ; Laser power and Nbr Missiles
  18+ E4DF E9 E4                                DW BoaVertices                  ; Verticles Address
  19+ E4E1 00                                   DB ShipTypeNormal               ; Ship Type
  20+ E4E2 00                                   DB 0                            ; NewB Tactics
  21+ E4E3 80                                   DB ShipCanAnger                 ; AI Flags
  22+ E4E4 A0                                   DB $A0                          ; chance of ECM module
  23+ E4E5 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ E4E6 00 00                                DW $0000                            ; no solid data
  25+ E4E8 00                                   DB $00                              ; no solid data
  26+ E4E9
  27+ E4E9 00 00 5D 1F  BoaVertices:	        DB $00, $00, $5D, $1F, $FF, $FF ; 01
  27+ E4ED FF FF
  28+ E4EF 00 28 57 38                          DB $00, $28, $57, $38, $02, $33 ; 02
  28+ E4F3 02 33
  29+ E4F5 26 19 63 78                          DB $26, $19, $63, $78, $01, $44 ; 03
  29+ E4F9 01 44
  30+ E4FB 26 19 63 F8                          DB $26, $19, $63, $F8, $12, $55 ; 04
  30+ E4FF 12 55
  31+ E501 26 28 3B BF                          DB $26, $28, $3B, $BF, $23, $69 ; 05
  31+ E505 23 69
  32+ E507 26 28 3B 3F                          DB $26, $28, $3B, $3F, $03, $6B ; 06
  32+ E50B 03 6B
  33+ E50D 3E 00 43 3F                          DB $3E, $00, $43, $3F, $04, $8B ; 07
  33+ E511 04 8B
  34+ E513 18 41 4F 7F                          DB $18, $41, $4F, $7F, $14, $8A ; 08
  34+ E517 14 8A
  35+ E519 18 41 4F FF                          DB $18, $41, $4F, $FF, $15, $7A ; 09
  35+ E51D 15 7A
  36+ E51F 3E 00 43 BF                          DB $3E, $00, $43, $BF, $25, $79 ; 10
  36+ E523 25 79
  37+ E525 00 07 6B 36                          DB $00, $07, $6B, $36, $02, $AA ; 11
  37+ E529 02 AA
  38+ E52B 0D 09 6B 76                          DB $0D, $09, $6B, $76, $01, $AA ; 12
  38+ E52F 01 AA
  39+ E531 0D 09 6B F6                          DB $0D, $09, $6B, $F6, $12, $CC ; 13
  39+ E535 12 CC
  40+ E537              BoaVertSize:            equ $ - BoaVertices
  41+ E537 1F 6B 00 14  BoaEdges:	            DB $1F, $6B, $00, $14
  42+ E53B 1F 8A 00 1C                          DB $1F, $8A, $00, $1C
  43+ E53F 1F 79 00 24                          DB $1F, $79, $00, $24
  44+ E543 1D 69 00 10                          DB $1D, $69, $00, $10
  45+ E547 1D 8B 00 18                          DB $1D, $8B, $00, $18
  46+ E54B 1D 7A 00 20                          DB $1D, $7A, $00, $20
  47+ E54F 1F 36 10 14                          DB $1F, $36, $10, $14
  48+ E553 1F 0B 14 18                          DB $1F, $0B, $14, $18
  49+ E557 1F 48 18 1C                          DB $1F, $48, $18, $1C
  50+ E55B 1F 1A 1C 20                          DB $1F, $1A, $1C, $20
  51+ E55F 1F 57 20 24                          DB $1F, $57, $20, $24
  52+ E563 1F 29 10 24                          DB $1F, $29, $10, $24
  53+ E567 18 23 04 10                          DB $18, $23, $04, $10
  54+ E56B 18 03 04 14                          DB $18, $03, $04, $14
  55+ E56F 18 25 0C 24                          DB $18, $25, $0C, $24
  56+ E573 18 15 0C 20                          DB $18, $15, $0C, $20
  57+ E577 18 04 08 18                          DB $18, $04, $08, $18
  58+ E57B 18 14 08 1C                          DB $18, $14, $08, $1C
  59+ E57F 16 02 04 28                          DB $16, $02, $04, $28
  60+ E583 16 01 08 2C                          DB $16, $01, $08, $2C
  61+ E587 16 12 0C 30                          DB $16, $12, $0C, $30
  62+ E58B 0E 0C 28 2C                          DB $0E, $0C, $28, $2C
  63+ E58F 0E 1C 2C 30                          DB $0E, $1C, $2C, $30
  64+ E593 0E 2C 30 28                          DB $0E, $2C, $30, $28
  65+ E597              BoaEdgesSize:           equ $ - BoaEdges
  66+ E597              BoaEdgesCnt:            equ BoaEdgesSize/4
  67+ E597 3F 2B 25 3C  BoaNormals:	            DB $3F, $2B, $25, $3C
  68+ E59B 7F 00 2D 59                          DB $7F, $00, $2D, $59
  69+ E59F BF 2B 25 3C                          DB $BF, $2B, $25, $3C
  70+ E5A3 1F 00 28 00                          DB $1F, $00, $28, $00
  71+ E5A7 7F 3E 20 14                          DB $7F, $3E, $20, $14
  72+ E5AB FF 3E 20 14                          DB $FF, $3E, $20, $14
  73+ E5AF 1F 00 17 06                          DB $1F, $00, $17, $06
  74+ E5B3 DF 17 0F 09                          DB $DF, $17, $0F, $09
  75+ E5B7 5F 17 0F 09                          DB $5F, $17, $0F, $09
  76+ E5BB 9F 1A 0D 0A                          DB $9F, $1A, $0D, $0A
  77+ E5BF 5F 00 1F 0C                          DB $5F, $00, $1F, $0C
  78+ E5C3 1F 1A 0D 0A                          DB $1F, $1A, $0D, $0A
  79+ E5C7              BoaNormalsSize:         equ $ - BoaNormals
  80+ E5C7              BoaLen:                 equ $ - Boa
  81+ E5C7
# file closed: ../../Data/ships/Boa.asm
 962  E5C7                                      include "../../Data/ships/CargoType5.asm"
# file opened: ../../Data/ships/CargoType5.asm
   1+ E5C7 00           CargoType5              DB $00                                     ; Number of cargo canisters released when destroyed
   2+ E5C8 90 01                                DW 20 * 20                                 ; Ship's targetable area LoHi
   3+ E5CA 22 E6                                DW CargoType5Edges                         ; Edge Data
   4+ E5CC 3C                                   DB CargoType5EdgesSize                     ; Size of Edge Data
   5+ E5CD 00                                   DB $00                                     ; Gun Vertex Byte offset
   6+ E5CE 12                                   DB $12                                     ; Explosion Count
   7+ E5CF 0A                                   DB CargoType5VertSize /6                   ; Vertex Count /6
   8+ E5D0 3C                                   DB CargoType5VertSize                      ; Vertex Count
   9+ E5D1 0F                                   DB CargoType5EdgesCnt                      ; Edges Count
  10+ E5D2 00 00                                DW $0000                                   ; Bounty LoHi
  11+ E5D4 1C                                   DB CargoType5NormalsSize                   ; Face (Normal) Count
  12+ E5D5 0C                                   DB $0C                                     ; Range when it turns to a dot
  13+ E5D6 11                                   DB $11                                     ; Energy Max
  14+ E5D7 0F                                   DB $0F                                     ; Speed Max
  15+ E5D8 5E E6                                DW CargoType5Normals                       ; Normals
  16+ E5DA 02                                   DB $02                                     ; Q scaling
  17+ E5DB 00                                   DB $00                                     ; Laser power and Nbr Missiles
  18+ E5DC E6 E5                                DW CargoType5Vertices                      ; Verticles Address
  19+ E5DE 04                                   DB ShipTypeScoopable                       ; Ship Type
  20+ E5DF 00                                   DB 0                                       ; NewB Tactics
  21+ E5E0 00                                   DB 0                                       ; AI Flags
  22+ E5E1 00                                   DB $0                                      ; chance of ECM module
  23+ E5E2 00                                   DB $00                                     ; Supports Solid Fill
  24+ E5E3 7A E6                                DW CargoType5Traingles                  ;
  25+ E5E5 21                                   DB CargoType5TrainglesSize
  26+ E5E6              ; So cargo is               Edge offset $0050  Face Offset $008C, Verices will alwys be +20, LineMax 31 -> 4  EdgeCnt 15  VertexCnt 60 -> 10     FaceCn 28 -> 7
  27+ E5E6              ;                                       Faces
  28+ E5E6              ;                            X  Y    Z  12 34  Vis
  29+ E5E6 18 10 00 1F  CargoType5Vertices		DB $18,$10,$00,$1F,$10,$55 	               ;00  Top Right
  29+ E5EA 10 55
  30+ E5EC 18 05 0F 1F                          DB $18,$05,$0F,$1F,$10,$22                 ;01  Mid Right Near
  30+ E5F0 10 22
  31+ E5F2 18 0D 09 5F                          DB $18,$0D,$09,$5F,$20,$33                 ;02  Bottom right Near
  31+ E5F6 20 33
  32+ E5F8 18 0D 09 7F                          DB $18,$0D,$09,$7F,$30,$44                 ;03  Bottom Right Rear
  32+ E5FC 30 44
  33+ E5FE 18 05 0F 3F                          DB $18,$05,$0F,$3F,$40,$55                 ;04  Mid Right Rear
  33+ E602 40 55
  34+ E604 18 10 00 9F                          DB $18,$10,$00,$9F,$51,$66                 ;05  Left versions
  34+ E608 51 66
  35+ E60A 18 05 0F 9F                          DB $18,$05,$0F,$9F,$21,$66                 ;06
  35+ E60E 21 66
  36+ E610 18 0D 09 DF                          DB $18,$0D,$09,$DF,$32,$66                 ;07
  36+ E614 32 66
  37+ E616 18 0D 09 FF                          DB $18,$0D,$09,$FF,$43,$66                 ;08
  37+ E61A 43 66
  38+ E61C 18 05 0F BF                          DB $18,$05,$0F,$BF,$54,$66                 ;09
  38+ E620 54 66
  39+ E622              CargoType5VertSize      equ $  - CargoType5Vertices
  40+ E622              ;                          Vis  FacVert Offset (4 bytexVertnbr)
  41+ E622              ;                               12  01 02
  42+ E622 1F 10 00 04  CargoType5Edges			DB $1F,$10,$00,$04 	       ;00 Face  0,1
  43+ E626 1F 20 04 08                          DB $1F,$20,$04,$08         ;01
  44+ E62A 1F 30 08 0C                          DB $1F,$30,$08,$0C         ;02
  45+ E62E 1F 40 0C 10                          DB $1F,$40,$0C,$10         ;03
  46+ E632 1F 50 00 10                          DB $1F,$50,$00,$10         ;04
  47+ E636 1F 51 00 14                          DB $1F,$51,$00,$14         ;05
  48+ E63A 1F 21 04 18                          DB $1F,$21,$04,$18         ;06
  49+ E63E 1F 32 08 1C                          DB $1F,$32,$08,$1C         ;07
  50+ E642 1F 43 0C 20                          DB $1F,$43,$0C,$20         ;08
  51+ E646 1F 54 10 24                          DB $1F,$54,$10,$24         ;19
  52+ E64A 1F 61 14 18                          DB $1F,$61,$14,$18         ;10
  53+ E64E 1F 62 18 1C                          DB $1F,$62,$18,$1C         ;11
  54+ E652 1F 63 1C 20                          DB $1F,$63,$1C,$20         ;12
  55+ E656 1F 64 20 24                          DB $1F,$64,$20,$24         ;13
  56+ E65A 1F 65 24 14                          DB $1F,$65,$24,$14         ;14
  57+ E65E              CargoType5EdgesSize     equ $  - CargoType5Edges
  58+ E65E              CargoType5EdgesCnt      equ CargoType5EdgesSize / 4
  59+ E65E              ;                           x  y    z   vis
  60+ E65E 1F 60 00 00  CargoType5Normals    	DB $1F,$60,$00,$00 			               ;00 Right side
  61+ E662 1F 00 29 1E                          DB $1F,$00,$29,$1E                         ;01
  62+ E666 5F 00 12 30                          DB $5F,$00,$12,$30                         ;02
  63+ E66A 5F 00 33 00                          DB $5F,$00,$33,$00                         ;03
  64+ E66E 7F 00 12 30                          DB $7F,$00,$12,$30                         ;04
  65+ E672 3F 00 29 1E                          DB $3F,$00,$29,$1E                         ;05 Left
  66+ E676 9F 60 00 00                          DB $9F,$60,$00,$00   ; end Cargo cannister ;06 right side
  67+ E67A              CargoType5NormalsSize   equ $  - CargoType5Normals
  68+ E67A              CargoType5Len           equ $  - CargoType5
  69+ E67A                                      ; Triangles is made of a list of edges
  70+ E67A              ; Ideal is pointers have a DW at the end to the list of triangles and count
  71+ E67A              ; for testing we will do a simple search
  72+ E67A              ;                          Nrm NodeOffset X 1
  73+ E67A              ;                                0    1    2
  74+ E67A 00 00 04 10  CargoType5Traingles     DB $00,$00*4, $01*4, $04*4
  75+ E67E 00 04 08 10                          DB $00,$01*4, $02*4, $04*4
  76+ E682 00 08 0C 10                          DB $00,$02*4, $03*4, $04*4
  77+ E686 01 00 10 14                          DB $01,$00*4, $04*4, $05*4
  78+ E68A 01 10 14 18                          DB $01,$04*4, $05*4, $06*4
  79+ E68E                                  ;   DB $02,
  80+ E68E                                  ;   DB $03,
  81+ E68E                                  ;   DB $03,
  82+ E68E                                  ;   DB $04,
  83+ E68E                                  ;   DB $04,
  84+ E68E                                  ;   DB $01,
  85+ E68E                                  ;   DB $01,
  86+ E68E                                  ;   DB $01,
  87+ E68E                                  ;   DB $01,
  88+ E68E 06 14 18 24                          DB $06,$05*4, $06*4, $09*4 ; its we store UBNkNodeArray + this offset it will save one memroy ready
  89+ E692 06 18 1C 24                          DB $06,$06*4, $07*4, $09*4
  90+ E696 06 1C 20 24                          DB $06,$07*4, $08*4, $09*4
  91+ E69A FF                                   DB $FF ; Very important end of traingle list marker
  92+ E69B              CargoType5TrainglesSize:equ $  -  CargoType5Traingles
  93+ E69B
  94+ E69B
  95+ E69B
# file closed: ../../Data/ships/CargoType5.asm
 963  E69B                                      include "../../Data/ships/Boulder.asm"
# file opened: ../../Data/ships/Boulder.asm
   1+ E69B 00           Boulder:	            DB $00                               ; Number of cargo canisters released when destroyed
   2+ E69C 84 03                                DW 30 * 30                           ; Ship's targetable area LoHi
   3+ E69E E4 E6                                DW BoulderEdges                      ; Edge Data
   4+ E6A0 3C                                   DB BoulderEdgesSize                  ; Size of Edge Data
   5+ E6A1 00                                   DB $00                               ; Gun Vertex Byte offset
   6+ E6A2 0E                                   DB $0E                               ; Explosion Count
   7+ E6A3 07                                   DB BoulderVertSize /6                ; Vertex Count /6
   8+ E6A4 2A                                   DB BoulderVertSize                   ; Vertex Count
   9+ E6A5 0F                                   DB BoulderEdgesCnt                   ; Edges Count
  10+ E6A6 01 00                                DW $0001                             ; Bounty LoHi
  11+ E6A8 28                                   DB BoulderNormalsSize                ; Face (Normal) Count
  12+ E6A9 14                                   DB $14                               ; Range when it turns to a dot
  13+ E6AA 14                                   DB $14                               ; Energy Max
  14+ E6AB 1E                                   DB $1E                               ; Speed Max
  15+ E6AC 20 E7                                DW BoulderNormals                    ; Normals
  16+ E6AE 02                                   DB $02                               ; Q scaling
  17+ E6AF 00                                   DB $00                               ; Laser power and Nbr Missiles
  18+ E6B0 BA E6                                DW BoulderVertices                   ; Verticles Address
  19+ E6B2 03                                   DB ShipTypeJunk                      ; Ship Type
  20+ E6B3 00                                   DB 0                                 ; NewB Tactics
  21+ E6B4 00                                   DB 0                                 ; AI Flags
  22+ E6B5 A0                                   DB $A0                               ; chance of ECM module
  23+ E6B6 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ E6B7 00 00                                DW $0000                            ; no solid data
  25+ E6B9 00                                   DB $00                              ; no solid data
  26+ E6BA
  27+ E6BA 12 25 0B BF  BoulderVertices:	    DB $12, $25, $0B, $BF, $01, $59
  27+ E6BE 01 59
  28+ E6C0 1E 07 0C 1F                          DB $1E, $07, $0C, $1F, $12, $56
  28+ E6C4 12 56
  29+ E6C6 1C 07 0C 7F                          DB $1C, $07, $0C, $7F, $23, $67
  29+ E6CA 23 67
  30+ E6CC 02 00 27 3F                          DB $02, $00, $27, $3F, $34, $78
  30+ E6D0 34 78
  31+ E6D2 1C 22 1E BF                          DB $1C, $22, $1E, $BF, $04, $89
  31+ E6D6 04 89
  32+ E6D8 05 0A 0D 5F                          DB $05, $0A, $0D, $5F, $FF, $FF
  32+ E6DC FF FF
  33+ E6DE 14 11 1E 3F                          DB $14, $11, $1E, $3F, $FF, $FF
  33+ E6E2 FF FF
  34+ E6E4              BoulderVertSize:        equ $ - BoulderVertices
  35+ E6E4 1F 15 00 04  BoulderEdges:	        DB $1F, $15, $00, $04
  36+ E6E8 1F 26 04 08                          DB $1F, $26, $04, $08
  37+ E6EC 1F 37 08 0C                          DB $1F, $37, $08, $0C
  38+ E6F0 1F 48 0C 10                          DB $1F, $48, $0C, $10
  39+ E6F4 1F 09 10 00                          DB $1F, $09, $10, $00
  40+ E6F8 1F 01 00 14                          DB $1F, $01, $00, $14
  41+ E6FC 1F 12 04 14                          DB $1F, $12, $04, $14
  42+ E700 1F 23 08 14                          DB $1F, $23, $08, $14
  43+ E704 1F 34 0C 14                          DB $1F, $34, $0C, $14
  44+ E708 1F 04 10 14                          DB $1F, $04, $10, $14
  45+ E70C 1F 59 00 18                          DB $1F, $59, $00, $18
  46+ E710 1F 56 04 18                          DB $1F, $56, $04, $18
  47+ E714 1F 67 08 18                          DB $1F, $67, $08, $18
  48+ E718 1F 78 0C 18                          DB $1F, $78, $0C, $18
  49+ E71C 1F 89 10 18                          DB $1F, $89, $10, $18
  50+ E720              BoulderEdgesSize:       equ $ - BoulderEdges
  51+ E720              BoulderEdgesCnt:        equ BoulderEdgesSize/4
  52+ E720 DF 0F 03 08  BoulderNormals:	        DB $DF, $0F, $03, $08
  53+ E724 9F 07 0C 1E                          DB $9F, $07, $0C, $1E
  54+ E728 5F 20 2F 18                          DB $5F, $20, $2F, $18
  55+ E72C FF 03 27 07                          DB $FF, $03, $27, $07
  56+ E730 FF 05 04 01                          DB $FF, $05, $04, $01
  57+ E734 1F 31 54 08                          DB $1F, $31, $54, $08
  58+ E738 3F 70 15 15                          DB $3F, $70, $15, $15
  59+ E73C 7F 4C 23 52                          DB $7F, $4C, $23, $52
  60+ E740 3F 16 38 89                          DB $3F, $16, $38, $89
  61+ E744 3F 28 6E 26                          DB $3F, $28, $6E, $26
  62+ E748              BoulderNormalsSize:     equ $ - BoulderNormals
  63+ E748              BoulderLen:             equ $ - Boulder
  64+ E748
# file closed: ../../Data/ships/Boulder.asm
 964  E748                                      include "../../Data/ships/Asteroid.asm"
# file opened: ../../Data/ships/Asteroid.asm
   1+ E748 00           Asteroid:	            DB $00                          ; Number of cargo canisters released when destroyed
   2+ E749 00 19                                DW 80 * 80                      ; Ship's targetable area LoHi
   3+ E74B 9D E7                                DW AsteroidEdges                ; Edge Data
   4+ E74D 54                                   DB AsteroidEdgesSize            ; Size of Edge Data
   5+ E74E 00                                   DB $00                          ; Gun Vertex Byte offset
   6+ E74F 22                                   DB $22                          ; Explosion Count
   7+ E750 09                                   DB AsteroidVertSize /6          ; Vertex Count /6
   8+ E751 36                                   DB AsteroidVertSize             ; Vertex Count
   9+ E752 15                                   DB AsteroidEdgesCnt             ; Edges Count
  10+ E753 05 00                                DW $0005                        ; Bounty LoHi
  11+ E755 38                                   DB AsteroidNormalsSize          ; Face (Normal) Count
  12+ E756 32                                   DB $32                          ; Range when it turns to a dot
  13+ E757 3C                                   DB $3C                          ; Energy Max
  14+ E758 1E                                   DB $1E                          ; Speed Max
  15+ E759 F1 E7                                DW AsteroidNormals              ; Normals
  16+ E75B 01                                   DB $01                          ; Q scaling
  17+ E75C 00                                   DB $00                          ; Laser power and Nbr Missiles
  18+ E75D 67 E7                                DW AsteroidVertices             ; Verticles Address
  19+ E75F 03                                   DB ShipTypeJunk                 ; Ship Type
  20+ E760 00                                   DB 0                            ; NewB Tactics
  21+ E761 00                                   DB 0                            ; AI Flags
  22+ E762 00                                   DB $00                          ; chance of ECM module
  23+ E763 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ E764 00 00                                DW $0000                            ; no solid data
  25+ E766 00                                   DB $00                              ; no solid data
  26+ E767
  27+ E767 00 50 00 1F  AsteroidVertices:	    DB $00, $50, $00, $1F, $FF, $FF ;01
  27+ E76B FF FF
  28+ E76D 50 0A 00 DF                          DB $50, $0A, $00, $DF, $FF, $FF ;02
  28+ E771 FF FF
  29+ E773 00 50 00 5F                          DB $00, $50, $00, $5F, $FF, $FF ;03
  29+ E777 FF FF
  30+ E779 46 28 00 5F                          DB $46, $28, $00, $5F, $FF, $FF ;04
  30+ E77D FF FF
  31+ E77F 3C 32 00 1F                          DB $3C, $32, $00, $1F, $65, $DC ;05
  31+ E783 65 DC
  32+ E785 32 00 3C 1F                          DB $32, $00, $3C, $1F, $FF, $FF ;06
  32+ E789 FF FF
  33+ E78B 28 00 46 9F                          DB $28, $00, $46, $9F, $10, $32 ;07
  33+ E78F 10 32
  34+ E791 00 1E 4B 3F                          DB $00, $1E, $4B, $3F, $FF, $FF ;08
  34+ E795 FF FF
  35+ E797 00 32 3C 7F                          DB $00, $32, $3C, $7F, $98, $BA ;09
  35+ E79B 98 BA
  36+ E79D              AsteroidVertSize:       equ $ - AsteroidVertices
  37+ E79D 1F 72 00 04  AsteroidEdges:	        DB $1F, $72, $00, $04           ;01
  38+ E7A1 1F D6 00 10                          DB $1F, $D6, $00, $10           ;02
  39+ E7A5 1F C5 0C 10                          DB $1F, $C5, $0C, $10           ;03
  40+ E7A9 1F B4 08 0C                          DB $1F, $B4, $08, $0C           ;04
  41+ E7AD 1F A3 04 08                          DB $1F, $A3, $04, $08           ;05
  42+ E7B1 1F 32 04 18                          DB $1F, $32, $04, $18           ;06
  43+ E7B5 1F 31 08 18                          DB $1F, $31, $08, $18           ;07
  44+ E7B9 1F 41 08 14                          DB $1F, $41, $08, $14           ;08
  45+ E7BD 1F 10 14 18                          DB $1F, $10, $14, $18           ;09
  46+ E7C1 1F 60 00 14                          DB $1F, $60, $00, $14           ;10
  47+ E7C5 1F 54 0C 14                          DB $1F, $54, $0C, $14           ;11
  48+ E7C9 1F 20 00 18                          DB $1F, $20, $00, $18           ;12
  49+ E7CD 1F 65 10 14                          DB $1F, $65, $10, $14           ;13
  50+ E7D1 1F A8 04 20                          DB $1F, $A8, $04, $20           ;14
  51+ E7D5 1F 87 04 1C                          DB $1F, $87, $04, $1C           ;15
  52+ E7D9 1F D7 00 1C                          DB $1F, $D7, $00, $1C           ;16
  53+ E7DD 1F DC 10 1C                          DB $1F, $DC, $10, $1C           ;17
  54+ E7E1 1F C9 0C 1C                          DB $1F, $C9, $0C, $1C           ;18
  55+ E7E5 1F B9 0C 20                          DB $1F, $B9, $0C, $20
  56+ E7E9 1F BA 08 20                          DB $1F, $BA, $08, $20
  57+ E7ED 1F 98 1C 20                          DB $1F, $98, $1C, $20
  58+ E7F1
  59+ E7F1              AsteroidEdgesSize:      equ $ - AsteroidEdges
  60+ E7F1              AsteroidEdgesCnt:       equ AsteroidEdgesSize/4
  61+ E7F1 1F 09 42 51  AsteroidNormals:	    DB $1F, $09, $42, $51           ;01
  62+ E7F5 5F 09 42 51                          DB $5F, $09, $42, $51           ;02
  63+ E7F9 9F 48 40 1F                          DB $9F, $48, $40, $1F           ;03
  64+ E7FD DF 40 49 2F                          DB $DF, $40, $49, $2F           ;04
  65+ E801 5F 2D 4F 41                          DB $5F, $2D, $4F, $41           ;05
  66+ E805 1F 87 0F 23                          DB $1F, $87, $0F, $23           ;06
  67+ E809 1F 26 4C 46                          DB $1F, $26, $4C, $46           ;07
  68+ E80D BF 42 3B 27                          DB $BF, $42, $3B, $27           ;08
  69+ E811 FF 43 0F 50                          DB $FF, $43, $0F, $50           ;09
  70+ E815 7F 42 0E 4B                          DB $7F, $42, $0E, $4B           ;10
  71+ E819 FF 46 50 28                          DB $FF, $46, $50, $28           ;11
  72+ E81D 7F 3A 66 33                          DB $7F, $3A, $66, $33           ;12
  73+ E821 3F 51 09 43                          DB $3F, $51, $09, $43           ;13
  74+ E825 3F 2F 5E 3F                          DB $3F, $2F, $5E, $3F           ;14
  75+ E829              AsteroidNormalsSize:    equ $ - AsteroidNormals
  76+ E829              AsteroidLen:            equ $ - Asteroid
  77+ E829
  78+ E829
# file closed: ../../Data/ships/Asteroid.asm
 965  E829                                      include "../../Data/ships/Bushmaster.asm"
# file opened: ../../Data/ships/Bushmaster.asm
   1+ E829 00           Bushmaster:	            DB $00                           ; Number of cargo canisters released when destroyed
   2+ E82A 9A 10                                DW $109A                         ; Ship's targetable area LoHi
   3+ E82C 90 E8                                DW BushmasterEdges               ; Edge Data
   4+ E82E 4C                                   DB BushmasterEdgesSize           ; Size of Edge Data
   5+ E82F 00                                   DB $00                           ; Gun Vertex Byte offset
   6+ E830 1E                                   DB $1E                           ; Explosion Count
   7+ E831 0C                                   DB BushmasterVertSize /6         ; Vertex Count /6
   8+ E832 48                                   DB BushmasterVertSize            ; Vertex Count
   9+ E833 13                                   DB BushmasterEdgesCnt            ; Edges Count
  10+ E834 96 00                                DW $0096                         ; Bounty LoHi
  11+ E836 24                                   DB BushmasterNormalsSize         ; Face (Normal) Count
  12+ E837 14                                   DB $14                           ; Range when it turns to a dot
  13+ E838 4A                                   DB $4A                           ; Energy Max
  14+ E839 23                                   DB $23                           ; Speed Max
  15+ E83A DC E8                                DW BushmasterNormals             ; Normals
  16+ E83C 02                                   DB $02                           ; Q scaling
  17+ E83D 21                                   DB $20 | ShipMissiles1           ; Laser power and Nbr Missiles
  18+ E83E 48 E8                                DW BushmasterVertices            ; Verticles Address
  19+ E840 00                                   DB ShipTypeNormal                ; Ship Type
  20+ E841 00                                   DB 0                             ; NewB Tactics
  21+ E842 80                                   DB ShipCanAnger                  ; AI Flags
  22+ E843 70                                   DB $70                           ; chance of ECM module
  23+ E844 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ E845 00 00                                DW $0000                            ; no solid data
  25+ E847 00                                   DB $00                              ; no solid data
  26+ E848
  27+ E848 00 00 3C 1F  BushmasterVertices:	    DB $00, $00, $3C, $1F, $23, $01  ; 01
  27+ E84C 23 01
  28+ E84E 32 00 14 1F                          DB $32, $00, $14, $1F, $57, $13  ; 02
  28+ E852 57 13
  29+ E854 32 00 14 9F                          DB $32, $00, $14, $9F, $46, $02  ; 03
  29+ E858 46 02
  30+ E85A 00 14 00 1F                          DB $00, $14, $00, $1F, $45, $01  ; 04
  30+ E85E 45 01
  31+ E860 00 14 28 7F                          DB $00, $14, $28, $7F, $FF, $FF  ; 05
  31+ E864 FF FF
  32+ E866 00 0E 28 3F                          DB $00, $0E, $28, $3F, $88, $45  ; 06
  32+ E86A 88 45
  33+ E86C 28 00 28 3F                          DB $28, $00, $28, $3F, $88, $57  ; 07
  33+ E870 88 57
  34+ E872 28 00 28 BF                          DB $28, $00, $28, $BF, $88, $46  ; 08
  34+ E876 88 46
  35+ E878 00 04 28 2A                          DB $00, $04, $28, $2A, $88, $88  ; 09
  35+ E87C 88 88
  36+ E87E 0A 00 28 2A                          DB $0A, $00, $28, $2A, $88, $88  ; 10
  36+ E882 88 88
  37+ E884 00 04 28 6A                          DB $00, $04, $28, $6A, $88, $88  ; 11
  37+ E888 88 88
  38+ E88A 0A 00 28 AA                          DB $0A, $00, $28, $AA, $88, $88  ; 12           ; 12 * 6 = 72
  38+ E88E 88 88
  39+ E890              BushmasterVertSize:     equ $ - BushmasterVertices
  40+ E890 1F 13 00 04  BushmasterEdges:	    DB $1F, $13, $00, $04            ; 01
  41+ E894 1F 02 00 08                          DB $1F, $02, $00, $08            ; 02
  42+ E898 1F 01 00 0C                          DB $1F, $01, $00, $0C            ; 03
  43+ E89C 1F 23 00 10                          DB $1F, $23, $00, $10            ; 04
  44+ E8A0 1F 45 0C 14                          DB $1F, $45, $0C, $14            ; 05
  45+ E8A4 1F 04 08 0C                          DB $1F, $04, $08, $0C            ; 06
  46+ E8A8 1F 15 04 0C                          DB $1F, $15, $04, $0C            ; 07
  47+ E8AC 1F 46 08 1C                          DB $1F, $46, $08, $1C            ; 08
  48+ E8B0 1F 57 04 18                          DB $1F, $57, $04, $18            ; 09
  49+ E8B4 1F 26 08 10                          DB $1F, $26, $08, $10            ; 10
  50+ E8B8 1F 37 04 10                          DB $1F, $37, $04, $10            ; 11
  51+ E8BC 1F 48 14 1C                          DB $1F, $48, $14, $1C            ; 12
  52+ E8C0 1F 58 14 18                          DB $1F, $58, $14, $18            ; 13
  53+ E8C4 1F 68 10 1C                          DB $1F, $68, $10, $1C            ; 14
  54+ E8C8 1F 78 10 18                          DB $1F, $78, $10, $18            ; 15
  55+ E8CC 0A 88 20 24                          DB $0A, $88, $20, $24            ; 16
  56+ E8D0 0A 88 24 28                          DB $0A, $88, $24, $28            ; 17
  57+ E8D4 0A 88 28 2C                          DB $0A, $88, $28, $2C            ; 18
  58+ E8D8 0A 88 2C 20                          DB $0A, $88, $2C, $20            ; 19           ; 19 * 4 = 76
  59+ E8DC              BushmasterEdgesSize:    equ $ - BushmasterEdges
  60+ E8DC              BushmasterEdgesCnt:     equ BushmasterEdgesSize/4        ;
  61+ E8DC 9F 17 58 1D  BushmasterNormals:	    DB $9F, $17, $58, $1D            ; 01
  62+ E8E0 1F 17 58 1D                          DB $1F, $17, $58, $1D            ; 02
  63+ E8E4 DF 0E 5D 12                          DB $DF, $0E, $5D, $12            ; 03
  64+ E8E8 5F 0E 5D 12                          DB $5F, $0E, $5D, $12            ; 04
  65+ E8EC BF 1F 59 0D                          DB $BF, $1F, $59, $0D            ; 05
  66+ E8F0 3F 1F 59 0D                          DB $3F, $1F, $59, $0D            ; 06
  67+ E8F4 FF 2A 55 07                          DB $FF, $2A, $55, $07            ; 07
  68+ E8F8 7F 2A 55 07                          DB $7F, $2A, $55, $07            ; 08
  69+ E8FC 3F 00 00 60                          DB $3F, $00, $00, $60            ; 09           ; 9 * 4 = 36
  70+ E900              BushmasterNormalsSize:  equ $ - BushmasterNormals
  71+ E900              BushmasterLen:          equ $ - Bushmaster
  72+ E900
# file closed: ../../Data/ships/Bushmaster.asm
 966  E900                                      include "../../Data/ships/Chameleon.asm"
# file opened: ../../Data/ships/Chameleon.asm
   1+ E900 03           Chameleon:	            DB $03                          ; Number of cargo canisters released when destroyed
   2+ E901 A0 0F                                DW $0FA0                        ; Ship's targetable area LoHi
   3+ E903 8A E9                                DW ChameleonEdges               ; Edge Data
   4+ E905 74                                   DB ChameleonEdgesSize           ; Size of Edge Data
   5+ E906 00                                   DB $00                          ; Gun Vertex Byte offset
   6+ E907 1A                                   DB $1A                          ; Explosion Count
   7+ E908 12                                   DB ChameleonVertSize /6         ; Vertex Count /6
   8+ E909 6C                                   DB ChameleonVertSize            ; Vertex Count
   9+ E90A 1D                                   DB ChameleonEdgesCnt            ; Edges Count
  10+ E90B C8                                   DB $00C8                        ; Bounty LoHi
  11+ E90C 34                                   DB ChameleonNormalsSize         ; Face (Normal) Count
  12+ E90D 0A                                   DB $0A                          ; Range when it turns to a dot
  13+ E90E 64                                   DB $64                          ; Energy Max
  14+ E90F 1D                                   DB $1D                          ; Speed Max
  15+ E910 FE E9                                DW ChameleonNormals             ; Normals
  16+ E912 01                                   DB $01                          ; Q scaling
  17+ E913 23                                   DB $23                          ; Laser power and Nbr Missiles
  18+ E914 1E E9                                DW ChameleonVertices            ; Verticles Address
  19+ E916 00                                   DB ShipTypeNormal               ; Ship Type
  20+ E917 00                                   DB 0                            ; NewB Tactics
  21+ E918 80                                   DB ShipCanAnger                 ; AI Flags
  22+ E919 40                                   DB $40                          ; chance of ECM module
  23+ E91A FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ E91B 00 00                                DW $0000                            ; no solid data
  25+ E91D 00                                   DB $00                              ; no solid data
  26+ E91E
  27+ E91E 12 00 6E 9F  ChameleonVertices:	    DB $12, $00, $6E, $9F, $25, $01
  27+ E922 25 01
  28+ E924 12 00 6E 1F                          DB $12, $00, $6E, $1F, $34, $01
  28+ E928 34 01
  29+ E92A 28 00 00 9F                          DB $28, $00, $00, $9F, $8B, $25
  29+ E92E 8B 25
  30+ E930 08 18 00 9F                          DB $08, $18, $00, $9F, $68, $22
  30+ E934 68 22
  31+ E936 08 18 00 1F                          DB $08, $18, $00, $1F, $69, $33
  31+ E93A 69 33
  32+ E93C 28 00 00 1F                          DB $28, $00, $00, $1F, $9A, $34
  32+ E940 9A 34
  33+ E942 08 18 00 5F                          DB $08, $18, $00, $5F, $7A, $44
  33+ E946 7A 44
  34+ E948 08 18 00 DF                          DB $08, $18, $00, $DF, $7B, $55
  34+ E94C 7B 55
  35+ E94E 00 18 28 1F                          DB $00, $18, $28, $1F, $36, $02
  35+ E952 36 02
  36+ E954 00 18 28 5F                          DB $00, $18, $28, $5F, $57, $14
  36+ E958 57 14
  37+ E95A 20 00 28 BF                          DB $20, $00, $28, $BF, $BC, $88
  37+ E95E BC 88
  38+ E960 00 18 28 3F                          DB $00, $18, $28, $3F, $9C, $68
  38+ E964 9C 68
  39+ E966 20 00 28 3F                          DB $20, $00, $28, $3F, $AC, $99
  39+ E96A AC 99
  40+ E96C 00 18 28 7F                          DB $00, $18, $28, $7F, $BC, $7A
  40+ E970 BC 7A
  41+ E972 08 00 28 AA                          DB $08, $00, $28, $AA, $CC, $CC
  41+ E976 CC CC
  42+ E978 00 08 28 2A                          DB $00, $08, $28, $2A, $CC, $CC
  42+ E97C CC CC
  43+ E97E 08 00 28 2A                          DB $08, $00, $28, $2A, $CC, $CC
  43+ E982 CC CC
  44+ E984 00 08 28 6A                          DB $00, $08, $28, $6A, $CC, $CC
  44+ E988 CC CC
  45+ E98A              ChameleonVertSize:      equ $ - ChameleonVertices
  46+ E98A 1F 01 00 04  ChameleonEdges:	        DB $1F, $01, $00, $04
  47+ E98E 1F 02 00 20                          DB $1F, $02, $00, $20
  48+ E992 1F 15 00 24                          DB $1F, $15, $00, $24
  49+ E996 1F 03 04 20                          DB $1F, $03, $04, $20
  50+ E99A 1F 14 04 24                          DB $1F, $14, $04, $24
  51+ E99E 1F 34 04 14                          DB $1F, $34, $04, $14
  52+ E9A2 1F 25 00 08                          DB $1F, $25, $00, $08
  53+ E9A6 1F 26 0C 20                          DB $1F, $26, $0C, $20
  54+ E9AA 1F 36 10 20                          DB $1F, $36, $10, $20
  55+ E9AE 1F 75 1C 24                          DB $1F, $75, $1C, $24
  56+ E9B2 1F 74 18 24                          DB $1F, $74, $18, $24
  57+ E9B6 1F 39 10 14                          DB $1F, $39, $10, $14
  58+ E9BA 1F 4A 14 18                          DB $1F, $4A, $14, $18
  59+ E9BE 1F 28 08 0C                          DB $1F, $28, $08, $0C
  60+ E9C2 1F 5B 08 1C                          DB $1F, $5B, $08, $1C
  61+ E9C6 1F 8B 08 28                          DB $1F, $8B, $08, $28
  62+ E9CA 1F 9A 14 30                          DB $1F, $9A, $14, $30
  63+ E9CE 1F 68 0C 2C                          DB $1F, $68, $0C, $2C
  64+ E9D2 1F 7B 1C 34                          DB $1F, $7B, $1C, $34
  65+ E9D6 1F 69 10 2C                          DB $1F, $69, $10, $2C
  66+ E9DA 1F 7A 18 34                          DB $1F, $7A, $18, $34
  67+ E9DE 1F 8C 28 2C                          DB $1F, $8C, $28, $2C
  68+ E9E2 1F BC 28 34                          DB $1F, $BC, $28, $34
  69+ E9E6 1F 9C 2C 30                          DB $1F, $9C, $2C, $30
  70+ E9EA 1F AC 30 34                          DB $1F, $AC, $30, $34
  71+ E9EE 0A CC 38 3C                          DB $0A, $CC, $38, $3C
  72+ E9F2 0A CC 3C 40                          DB $0A, $CC, $3C, $40
  73+ E9F6 0A CC 40 44                          DB $0A, $CC, $40, $44
  74+ E9FA 0A CC 44 38                          DB $0A, $CC, $44, $38
  75+ E9FE              ChameleonEdgesSize:     equ $ - ChameleonEdges
  76+ E9FE              ChameleonEdgesCnt:      equ ChameleonEdgesSize/4
  77+ E9FE 1F 00 5A 1F  ChameleonNormals:	    DB $1F, $00, $5A, $1F
  78+ EA02 5F 00 5A 1F                          DB $5F, $00, $5A, $1F
  79+ EA06 9F 39 4C 0B                          DB $9F, $39, $4C, $0B
  80+ EA0A 1F 39 4C 0B                          DB $1F, $39, $4C, $0B
  81+ EA0E 5F 39 4C 0B                          DB $5F, $39, $4C, $0B
  82+ EA12 DF 39 4C 0B                          DB $DF, $39, $4C, $0B
  83+ EA16 1F 00 60 00                          DB $1F, $00, $60, $00
  84+ EA1A 5F 00 60 00                          DB $5F, $00, $60, $00
  85+ EA1E BF 39 4C 0B                          DB $BF, $39, $4C, $0B
  86+ EA22 3F 39 4C 0B                          DB $3F, $39, $4C, $0B
  87+ EA26 7F 39 4C 0B                          DB $7F, $39, $4C, $0B
  88+ EA2A FF 39 4C 0B                          DB $FF, $39, $4C, $0B
  89+ EA2E 3F 00 00 60                          DB $3F, $00, $00, $60
  90+ EA32              ChameleonNormalsSize:   equ $ - ChameleonNormals
  91+ EA32              ChameleonLen:           equ $ - Chameleon
  92+ EA32
# file closed: ../../Data/ships/Chameleon.asm
 967  EA32                                      include "../../Data/ships/CobraMk3.asm"
# file opened: ../../Data/ships/CobraMk3.asm
   1+ EA32              ; Corrected pointers
   2+ EA32              ;                      0    1    2  3  4  5   6   7   8   9   10  11  12   13  14  15   16 17 18 19    20    21
   3+ EA32              ;					   Scp  Missile Edge  Lin Gun Exp Vtx Edg Bounty  Face              Face           Vertices
   4+ EA32              ;                      Deb  Lock    Lo Hi x4  Vtx Cnt x6  X1  lo  hi  x4   Dot Erg Spd  Lo Hi Q  Laser Lo    hi
   5+ EA32 03           CobraMk3    		    DB $03                            ; Number of cargo canisters released when destroyed
   6+ EA33 41 23                                DW $2341                          ; Ship's targetable area LoHi
   7+ EA35 F9 EA                                DW CobraMk3Edges                  ; Edge Data
   8+ EA37 98                                   DB CobraMkEdgesSize               ; Size of Edge Data
   9+ EA38 54                                   DB $54                            ; Gun Vertex Byte offset
  10+ EA39 2A                                   DB $2A                            ; Explosion Count
  11+ EA3A 1C                                   DB CobraMkVertSize /6             ; Vertex Count /6
  12+ EA3B A8                                   DB CobraMkVertSize                ; Vertex Count
  13+ EA3C 26                                   DB CobraMkEdgesCnt                ; Edges Count
  14+ EA3D 00 00                                DW $0000                          ; Bounty LoHi
  15+ EA3F 34                                   DB CobraMk3NormalsSize            ; Face (Normal) Count
  16+ EA40 32                                   DB $32                            ; Range when it turns to a dot
  17+ EA41 96                                   DB $96                            ; Energy Max
  18+ EA42 1C                                   DB $1C                            ; Speed Max
  19+ EA43 91 EB                                DW CobraMk3Normals                ; Normals
  20+ EA45 01                                   DB $01                            ; Q scaling
  21+ EA46 34                                   DB $30 | ShipMissiles4            ; Laser power and Nbr Missiles
  22+ EA47 51 EA                                DW CobraMk3Vertices               ; Verticles Address
  23+ EA49 00                                   DB ShipTypeNormal                 ; Ship Type
  24+ EA4A 00                                   DB 0                              ; NewB Tactics
  25+ EA4B 80                                   DB ShipCanAnger                   ; AI Flags
  26+ EA4C 70                                   DB $70                            ; chance of ECM module
  27+ EA4D FF                                   DB $FF                              ; Supports Solid Fill = false
  28+ EA4E 00 00                                DW $0000                            ; no solid data
  29+ EA50 00                                   DB $00                              ; no solid data
  30+ EA51
  31+ EA51 20 00 4C 1F  CobraMk3Vertices	    DB $20,$00,$4C,$1F,$FF,$FF
  31+ EA55 FF FF
  32+ EA57 20 00 4C 9F                          DB $20,$00,$4C,$9F,$FF,$FF
  32+ EA5B FF FF
  33+ EA5D 00 1A 18 1F                          DB $00,$1A,$18,$1F,$FF,$FF
  33+ EA61 FF FF
  34+ EA63 78 03 08 FF                          DB $78,$03,$08,$FF,$73,$AA
  34+ EA67 73 AA
  35+ EA69 78 03 08 7F                          DB $78,$03,$08,$7F,$84,$CC
  35+ EA6D 84 CC
  36+ EA6F 58 10 28 BF                          DB $58,$10,$28,$BF,$FF,$FF
  36+ EA73 FF FF
  37+ EA75 58 10 28 3F                          DB $58,$10,$28,$3F,$FF,$FF
  37+ EA79 FF FF
  38+ EA7B 80 08 28 7F                          DB $80,$08,$28,$7F,$98,$CC
  38+ EA7F 98 CC
  39+ EA81 80 08 28 FF                          DB $80,$08,$28,$FF,$97,$AA
  39+ EA85 97 AA
  40+ EA87 00 1A 28 3F                          DB $00,$1A,$28,$3F,$65,$99
  40+ EA8B 65 99
  41+ EA8D 20 18 28 FF                          DB $20,$18,$28,$FF,$A9,$BB
  41+ EA91 A9 BB
  42+ EA93 20 18 28 7F                          DB $20,$18,$28,$7F,$B9,$CC
  42+ EA97 B9 CC
  43+ EA99 24 08 28 B4                          DB $24,$08,$28,$B4,$99,$99
  43+ EA9D 99 99
  44+ EA9F 08 0C 28 B4                          DB $08,$0C,$28,$B4,$99,$99
  44+ EAA3 99 99
  45+ EAA5 08 0C 28 34                          DB $08,$0C,$28,$34,$99,$99
  45+ EAA9 99 99
  46+ EAAB 24 08 28 34                          DB $24,$08,$28,$34,$99,$99
  46+ EAAF 99 99
  47+ EAB1 24 0C 28 74                          DB $24,$0C,$28,$74,$99,$99
  47+ EAB5 99 99
  48+ EAB7 08 10 28 74                          DB $08,$10,$28,$74,$99,$99
  48+ EABB 99 99
  49+ EABD 08 10 28 F4                          DB $08,$10,$28,$F4,$99,$99
  49+ EAC1 99 99
  50+ EAC3 24 0C 28 F4                          DB $24,$0C,$28,$F4,$99,$99
  50+ EAC7 99 99
  51+ EAC9 00 00 4C 06                          DB $00,$00,$4C,$06,$B0,$BB
  51+ EACD B0 BB
  52+ EACF 00 00 5A 1F                          DB $00,$00,$5A,$1F,$B0,$BB
  52+ EAD3 B0 BB
  53+ EAD5 50 06 28 E8                          DB $50,$06,$28,$E8,$99,$99
  53+ EAD9 99 99
  54+ EADB 50 06 28 A8                          DB $50,$06,$28,$A8,$99,$99
  54+ EADF 99 99
  55+ EAE1 58 00 28 A6                          DB $58,$00,$28,$A6,$99,$99
  55+ EAE5 99 99
  56+ EAE7 50 06 28 28                          DB $50,$06,$28,$28,$99,$99
  56+ EAEB 99 99
  57+ EAED 58 00 28 26                          DB $58,$00,$28,$26,$99,$99
  57+ EAF1 99 99
  58+ EAF3 50 06 28 68                          DB $50,$06,$28,$68,$99,$99
  58+ EAF7 99 99
  59+ EAF9              CobraMkVertSize         equ $  - CobraMk3Vertices
  60+ EAF9 1F B0 00 04  CobraMk3Edges		    DB $1F,$B0,$00,$04
  61+ EAFD 1F C4 00 10                          DB $1F,$C4,$00,$10
  62+ EB01 1F A3 04 0C                          DB $1F,$A3,$04,$0C
  63+ EB05 1F A7 0C 20                          DB $1F,$A7,$0C,$20
  64+ EB09 1F C8 10 1C                          DB $1F,$C8,$10,$1C
  65+ EB0D 1F 98 18 1C                          DB $1F,$98,$18,$1C
  66+ EB11 1F 96 18 24                          DB $1F,$96,$18,$24
  67+ EB15 1F 95 14 24                          DB $1F,$95,$14,$24
  68+ EB19 1F 97 14 20                          DB $1F,$97,$14,$20
  69+ EB1D 1F 51 08 14                          DB $1F,$51,$08,$14
  70+ EB21 1F 62 08 18                          DB $1F,$62,$08,$18
  71+ EB25 1F 73 0C 14                          DB $1F,$73,$0C,$14
  72+ EB29 1F 84 10 18                          DB $1F,$84,$10,$18
  73+ EB2D 1F 10 04 08                          DB $1F,$10,$04,$08
  74+ EB31 1F 20 00 08                          DB $1F,$20,$00,$08
  75+ EB35 1F A9 20 28                          DB $1F,$A9,$20,$28
  76+ EB39 1F B9 28 2C                          DB $1F,$B9,$28,$2C
  77+ EB3D 1F C9 1C 2C                          DB $1F,$C9,$1C,$2C
  78+ EB41 1F BA 04 28                          DB $1F,$BA,$04,$28
  79+ EB45 1F CB 00 2C                          DB $1F,$CB,$00,$2C
  80+ EB49 1D 31 04 14                          DB $1D,$31,$04,$14
  81+ EB4D 1D 42 00 18                          DB $1D,$42,$00,$18
  82+ EB51 06 B0 50 54                          DB $06,$B0,$50,$54
  83+ EB55 14 99 30 34                          DB $14,$99,$30,$34
  84+ EB59 14 99 48 4C                          DB $14,$99,$48,$4C
  85+ EB5D 14 99 38 3C                          DB $14,$99,$38,$3C
  86+ EB61 14 99 40 44                          DB $14,$99,$40,$44
  87+ EB65 13 99 3C 40                          DB $13,$99,$3C,$40
  88+ EB69 11 99 38 44                          DB $11,$99,$38,$44
  89+ EB6D 13 99 34 48                          DB $13,$99,$34,$48
  90+ EB71 13 99 30 4C                          DB $13,$99,$30,$4C
  91+ EB75 1E 65 08 24                          DB $1E,$65,$08,$24
  92+ EB79 06 99 58 60                          DB $06,$99,$58,$60
  93+ EB7D 06 99 5C 60                          DB $06,$99,$5C,$60
  94+ EB81 08 99 58 5C                          DB $08,$99,$58,$5C
  95+ EB85 06 99 64 68                          DB $06,$99,$64,$68
  96+ EB89 06 99 68 6C                          DB $06,$99,$68,$6C
  97+ EB8D 08 99 64 6C                          DB $08,$99,$64,$6C
  98+ EB91              CobraMkEdgesSize        equ $  - CobraMk3Edges
  99+ EB91              CobraMkEdgesCnt         equ CobraMkEdgesSize/4
 100+ EB91              ; start normals #0 = top f,$on,$ p,$at,$ o,$ C,$br,$ Mk III
 101+ EB91 1F 00 3E 1F  CobraMk3Normals		    DB $1F,$00,$3E,$1F
 102+ EB95 9F 12 37 10                          DB $9F,$12,$37,$10
 103+ EB99 1F 12 37 10                          DB $1F,$12,$37,$10
 104+ EB9D 9F 10 34 0E                          DB $9F,$10,$34,$0E
 105+ EBA1 1F 10 34 0E                          DB $1F,$10,$34,$0E
 106+ EBA5 9F 0E 2F 00                          DB $9F,$0E,$2F,$00
 107+ EBA9 1F 0E 2F 00                          DB $1F,$0E,$2F,$00
 108+ EBAD 9F 3D 66 00                          DB $9F,$3D,$66,$00
 109+ EBB1 1F 3D 66 00                          DB $1F,$3D,$66,$00
 110+ EBB5 3F 00 00 50                          DB $3F,$00,$00,$50
 111+ EBB9 DF 07 2A 09                          DB $DF,$07,$2A,$09
 112+ EBBD 5F 00 1E 06                          DB $5F,$00,$1E,$06
 113+ EBC1 5F 07 2A 09                          DB $5F,$07,$2A,$09 		;end of Cobra Mk III
 114+ EBC5              CobraMk3NormalsSize     equ $  - CobraMk3Normals
 115+ EBC5              CobraMk3Len             equ $  - CobraMk3
 116+ EBC5
# file closed: ../../Data/ships/CobraMk3.asm
 968  EBC5                                      include "../../Data/ships/Cobra_Mk_1.asm"
# file opened: ../../Data/ships/Cobra_Mk_1.asm
   1+ EBC5 03           Cobra_Mk_1:	            DB $03                              ; Number of cargo canisters released when destroyed
   2+ EBC6 49 26                                DW $2649                            ; Ship's targetable area LoHi
   3+ EBC8 26 EC                                DW Cobra_Mk_1Edges                  ; Edge Data
   4+ EBCA 48                                   DB Cobra_Mk_1EdgesSize              ; Size of Edge Data
   5+ EBCB 28                                   DB $28                              ; Gun Vertex Byte offset
   6+ EBCC 1A                                   DB $1A                              ; Explosion Count
   7+ EBCD 0B                                   DB Cobra_Mk_1VertSize /6            ; Vertex Count /6
   8+ EBCE 42                                   DB Cobra_Mk_1VertSize               ; Vertex Count
   9+ EBCF 12                                   DB Cobra_Mk_1EdgesCnt               ; Edges Count
  10+ EBD0 00 4B                                DW $4B00                            ; Bounty LoHi
  11+ EBD2 28                                   DB Cobra_Mk_1NormalsSize            ; Face (Normal) Count
  12+ EBD3 13                                   DB $13                              ; Range when it turns to a dot
  13+ EBD4 51                                   DB $51                              ; Energy Max
  14+ EBD5 1A                                   DB $1A                              ; Speed Max
  15+ EBD6 6E EC                                DW Cobra_Mk_1Normals                ; Normals
  16+ EBD8 02                                   DB $02                              ; Q scaling
  17+ EBD9 23                                   DB $20 | ShipMissiles3              ; Laser power and Nbr Missiles
  18+ EBDA E4 EB                                DW Cobra_Mk_1Vertices               ; Verticles Address
  19+ EBDC 00                                   DB ShipTypeNormal                   ; Ship Type
  20+ EBDD 00                                   DB 0                                ; NewB Tactics
  21+ EBDE 80                                   DB ShipCanAnger                     ; AI Flags
  22+ EBDF 30                                   DB $30                              ; chance of ECM module
  23+ EBE0 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ EBE1 00 00                                DW $0000                            ; no solid data
  25+ EBE3 00                                   DB $00                              ; no solid data
  26+ EBE4
  27+ EBE4 12 01 32 DF  Cobra_Mk_1Vertices:	    DB $12, $01, $32, $DF, $01, $23
  27+ EBE8 01 23
  28+ EBEA 12 01 32 5F                          DB $12, $01, $32, $5F, $01, $45
  28+ EBEE 01 45
  29+ EBF0 42 00 07 9F                          DB $42, $00, $07, $9F, $23, $88
  29+ EBF4 23 88
  30+ EBF6 42 00 07 1F                          DB $42, $00, $07, $1F, $45, $99
  30+ EBFA 45 99
  31+ EBFC 20 0C 26 BF                          DB $20, $0C, $26, $BF, $26, $78
  31+ EC00 26 78
  32+ EC02 20 0C 26 3F                          DB $20, $0C, $26, $3F, $46, $79
  32+ EC06 46 79
  33+ EC08 36 0C 26 FF                          DB $36, $0C, $26, $FF, $13, $78
  33+ EC0C 13 78
  34+ EC0E 36 0C 26 7F                          DB $36, $0C, $26, $7F, $15, $79
  34+ EC12 15 79
  35+ EC14 00 0C 06 34                          DB $00, $0C, $06, $34, $02, $46
  35+ EC18 02 46
  36+ EC1A 00 01 32 42                          DB $00, $01, $32, $42, $01, $11
  36+ EC1E 01 11
  37+ EC20 00 01 3C 5F                          DB $00, $01, $3C, $5F, $01, $11
  37+ EC24 01 11
  38+ EC26              Cobra_Mk_1VertSize:     equ $ - Cobra_Mk_1Vertices
  39+ EC26 1F 01 04 00  Cobra_Mk_1Edges:	    DB $1F, $01, $04, $00
  40+ EC2A 1F 23 00 08                          DB $1F, $23, $00, $08
  41+ EC2E 1F 38 08 18                          DB $1F, $38, $08, $18
  42+ EC32 1F 17 18 1C                          DB $1F, $17, $18, $1C
  43+ EC36 1F 59 1C 0C                          DB $1F, $59, $1C, $0C
  44+ EC3A 1F 45 0C 04                          DB $1F, $45, $0C, $04
  45+ EC3E 1F 28 08 10                          DB $1F, $28, $08, $10
  46+ EC42 1F 67 10 14                          DB $1F, $67, $10, $14
  47+ EC46 1F 49 14 0C                          DB $1F, $49, $14, $0C
  48+ EC4A 14 02 00 20                          DB $14, $02, $00, $20
  49+ EC4E 14 04 20 04                          DB $14, $04, $20, $04
  50+ EC52 10 26 10 20                          DB $10, $26, $10, $20
  51+ EC56 10 46 20 14                          DB $10, $46, $20, $14
  52+ EC5A 1F 78 10 18                          DB $1F, $78, $10, $18
  53+ EC5E 1F 79 14 1C                          DB $1F, $79, $14, $1C
  54+ EC62 14 13 00 18                          DB $14, $13, $00, $18
  55+ EC66 14 15 04 1C                          DB $14, $15, $04, $1C
  56+ EC6A 02 01 28 24                          DB $02, $01, $28, $24
  57+ EC6E              Cobra_Mk_1EdgesSize:    equ $ - Cobra_Mk_1Edges
  58+ EC6E              Cobra_Mk_1EdgesCnt:     equ Cobra_Mk_1EdgesSize/4
  59+ EC6E 1F 00 29 0A  Cobra_Mk_1Normals:	    DB $1F, $00, $29, $0A
  60+ EC72 5F 00 1B 03                          DB $5F, $00, $1B, $03
  61+ EC76 9F 08 2E 08                          DB $9F, $08, $2E, $08
  62+ EC7A DF 0C 39 0C                          DB $DF, $0C, $39, $0C
  63+ EC7E 1F 08 2E 08                          DB $1F, $08, $2E, $08
  64+ EC82 5F 0C 39 0C                          DB $5F, $0C, $39, $0C
  65+ EC86 1F 00 31 00                          DB $1F, $00, $31, $00
  66+ EC8A 3F 00 00 9A                          DB $3F, $00, $00, $9A
  67+ EC8E BF 79 6F 3E                          DB $BF, $79, $6F, $3E
  68+ EC92 3F 79 6F 3E                          DB $3F, $79, $6F, $3E
  69+ EC96              Cobra_Mk_1NormalsSize:  equ $ - Cobra_Mk_1Normals
  70+ EC96              Cobra_Mk_1Len:          equ $ - Cobra_Mk_1
  71+ EC96
# file closed: ../../Data/ships/Cobra_Mk_1.asm
 969  EC96                                      include "../../Data/ships/Cobra_Mk_3_P.asm"
# file opened: ../../Data/ships/Cobra_Mk_3_P.asm
   1+ EC96 01           Cobra_Mk_3_P:	        DB $01                              ; Number of cargo canisters released when destroyed
   2+ EC97 41 23                                DW $2341                            ; Ship's targetable area LoHi
   3+ EC99 5D ED                                DW Cobra_Mk_3_PEdges                ; Edge Data
   4+ EC9B 98                                   DB Cobra_Mk_3_PEdgesSize            ; Size of Edge Data
   5+ EC9C 54                                   DB $54                              ; Gun Vertex Byte offset
   6+ EC9D 2A                                   DB $2A                              ; Explosion Count
   7+ EC9E 1C                                   DB Cobra_Mk_3_PVertSize /6          ; Vertex Count /6
   8+ EC9F A8                                   DB Cobra_Mk_3_PVertSize             ; Vertex Count
   9+ ECA0 26                                   DB Cobra_Mk_3_PEdgesCnt             ; Edges Count
  10+ ECA1 00 AF                                DW $AF00                            ; Bounty LoHi
  11+ ECA3 34                                   DB Cobra_Mk_3_PNormalsSize          ; Face (Normal) Count
  12+ ECA4                                      ; Add in a new byte for range for LoD, if this is zero then no LoD Data
  13+ ECA4 32                                   DB $32                              ; Range when it turns to a dot
  14+ ECA5 96                                   DB $96                              ; Energy Max
  15+ ECA6 1C                                   DB $1C                              ; Speed Max
  16+ ECA7 F5 ED                                DW Cobra_Mk_3_PNormals              ; Normals
  17+ ECA9 01                                   DB $01                              ; Q scaling
  18+ ECAA 14                                   DB $10 | ShipMissiles4              ; Laser power and Nbr Missiles
  19+ ECAB B5 EC                                DW Cobra_Mk_3_PVertices             ; Verticles Address
  20+ ECAD 00                                   DB ShipTypeNormal                   ; Ship Type
  21+ ECAE 00                                   DB 0                                ; NewB Tactics
  22+ ECAF 80                                   DB ShipCanAnger                     ; AI Flags
  23+ ECB0 90                                   DB $90                              ; chance of ECM module
  24+ ECB1 FF                                   DB $FF                              ; Supports Solid Fill = false
  25+ ECB2 00 00                                DW $0000                            ; no solid data
  26+ ECB4 00                                   DB $00                              ; no solid data
  27+ ECB5
  28+ ECB5 20 00 4C 1F  Cobra_Mk_3_PVertices:	DB $20, $00, $4C, $1F, $FF, $FF
  28+ ECB9 FF FF
  29+ ECBB 20 00 4C 9F                          DB $20, $00, $4C, $9F, $FF, $FF
  29+ ECBF FF FF
  30+ ECC1 00 1A 18 1F                          DB $00, $1A, $18, $1F, $FF, $FF
  30+ ECC5 FF FF
  31+ ECC7 78 03 08 FF                          DB $78, $03, $08, $FF, $73, $AA
  31+ ECCB 73 AA
  32+ ECCD 78 03 08 7F                          DB $78, $03, $08, $7F, $84, $CC
  32+ ECD1 84 CC
  33+ ECD3 58 10 28 BF                          DB $58, $10, $28, $BF, $FF, $FF
  33+ ECD7 FF FF
  34+ ECD9 58 10 28 3F                          DB $58, $10, $28, $3F, $FF, $FF
  34+ ECDD FF FF
  35+ ECDF 80 08 28 7F                          DB $80, $08, $28, $7F, $98, $CC
  35+ ECE3 98 CC
  36+ ECE5 80 08 28 FF                          DB $80, $08, $28, $FF, $97, $AA
  36+ ECE9 97 AA
  37+ ECEB 00 1A 28 3F                          DB $00, $1A, $28, $3F, $65, $99
  37+ ECEF 65 99
  38+ ECF1 20 18 28 FF                          DB $20, $18, $28, $FF, $A9, $BB
  38+ ECF5 A9 BB
  39+ ECF7 20 18 28 7F                          DB $20, $18, $28, $7F, $B9, $CC
  39+ ECFB B9 CC
  40+ ECFD 24 08 28 B4                          DB $24, $08, $28, $B4, $99, $99
  40+ ED01 99 99
  41+ ED03 08 0C 28 B4                          DB $08, $0C, $28, $B4, $99, $99
  41+ ED07 99 99
  42+ ED09 08 0C 28 34                          DB $08, $0C, $28, $34, $99, $99
  42+ ED0D 99 99
  43+ ED0F 24 08 28 34                          DB $24, $08, $28, $34, $99, $99
  43+ ED13 99 99
  44+ ED15 24 0C 28 74                          DB $24, $0C, $28, $74, $99, $99
  44+ ED19 99 99
  45+ ED1B 08 10 28 74                          DB $08, $10, $28, $74, $99, $99
  45+ ED1F 99 99
  46+ ED21 08 10 28 F4                          DB $08, $10, $28, $F4, $99, $99
  46+ ED25 99 99
  47+ ED27 24 0C 28 F4                          DB $24, $0C, $28, $F4, $99, $99
  47+ ED2B 99 99
  48+ ED2D 00 00 4C 06                          DB $00, $00, $4C, $06, $B0, $BB
  48+ ED31 B0 BB
  49+ ED33 00 00 5A 1F                          DB $00, $00, $5A, $1F, $B0, $BB
  49+ ED37 B0 BB
  50+ ED39 50 06 28 E8                          DB $50, $06, $28, $E8, $99, $99
  50+ ED3D 99 99
  51+ ED3F 50 06 28 A8                          DB $50, $06, $28, $A8, $99, $99
  51+ ED43 99 99
  52+ ED45 58 00 28 A6                          DB $58, $00, $28, $A6, $99, $99
  52+ ED49 99 99
  53+ ED4B 50 06 28 28                          DB $50, $06, $28, $28, $99, $99
  53+ ED4F 99 99
  54+ ED51 58 00 28 26                          DB $58, $00, $28, $26, $99, $99
  54+ ED55 99 99
  55+ ED57 50 06 28 68                          DB $50, $06, $28, $68, $99, $99
  55+ ED5B 99 99
  56+ ED5D              Cobra_Mk_3_PVertSize:   equ $ - Cobra_Mk_3_PVertices
  57+ ED5D 1F B0 00 04  Cobra_Mk_3_PEdges:	    DB $1F, $B0, $00, $04
  58+ ED61 1F C4 00 10                          DB $1F, $C4, $00, $10
  59+ ED65 1F A3 04 0C                          DB $1F, $A3, $04, $0C
  60+ ED69 1F A7 0C 20                          DB $1F, $A7, $0C, $20
  61+ ED6D 1F C8 10 1C                          DB $1F, $C8, $10, $1C
  62+ ED71 1F 98 18 1C                          DB $1F, $98, $18, $1C
  63+ ED75 1F 96 18 24                          DB $1F, $96, $18, $24
  64+ ED79 1F 95 14 24                          DB $1F, $95, $14, $24
  65+ ED7D 1F 97 14 20                          DB $1F, $97, $14, $20
  66+ ED81 1F 51 08 14                          DB $1F, $51, $08, $14
  67+ ED85 1F 62 08 18                          DB $1F, $62, $08, $18
  68+ ED89 1F 73 0C 14                          DB $1F, $73, $0C, $14
  69+ ED8D 1F 84 10 18                          DB $1F, $84, $10, $18
  70+ ED91 1F 10 04 08                          DB $1F, $10, $04, $08
  71+ ED95 1F 20 00 08                          DB $1F, $20, $00, $08
  72+ ED99 1F A9 20 28                          DB $1F, $A9, $20, $28
  73+ ED9D 1F B9 28 2C                          DB $1F, $B9, $28, $2C
  74+ EDA1 1F C9 1C 2C                          DB $1F, $C9, $1C, $2C
  75+ EDA5 1F BA 04 28                          DB $1F, $BA, $04, $28
  76+ EDA9 1F CB 00 2C                          DB $1F, $CB, $00, $2C
  77+ EDAD 1D 31 04 14                          DB $1D, $31, $04, $14
  78+ EDB1 1D 42 00 18                          DB $1D, $42, $00, $18
  79+ EDB5 06 B0 50 54                          DB $06, $B0, $50, $54
  80+ EDB9 14 99 30 34                          DB $14, $99, $30, $34
  81+ EDBD 14 99 48 4C                          DB $14, $99, $48, $4C
  82+ EDC1 14 99 38 3C                          DB $14, $99, $38, $3C
  83+ EDC5 14 99 40 44                          DB $14, $99, $40, $44
  84+ EDC9 13 99 3C 40                          DB $13, $99, $3C, $40
  85+ EDCD 11 99 38 44                          DB $11, $99, $38, $44
  86+ EDD1 13 99 34 48                          DB $13, $99, $34, $48
  87+ EDD5 13 99 30 4C                          DB $13, $99, $30, $4C
  88+ EDD9 1E 65 08 24                          DB $1E, $65, $08, $24
  89+ EDDD 06 99 58 60                          DB $06, $99, $58, $60
  90+ EDE1 06 99 5C 60                          DB $06, $99, $5C, $60
  91+ EDE5 08 99 58 5C                          DB $08, $99, $58, $5C
  92+ EDE9 06 99 64 68                          DB $06, $99, $64, $68
  93+ EDED 06 99 68 6C                          DB $06, $99, $68, $6C
  94+ EDF1 08 99 64 6C                          DB $08, $99, $64, $6C
  95+ EDF5              Cobra_Mk_3_PEdgesSize:  equ $ - Cobra_Mk_3_PEdges
  96+ EDF5              Cobra_Mk_3_PEdgesCnt:   equ Cobra_Mk_3_PEdgesSize/4
  97+ EDF5 1F 00 3E 1F  Cobra_Mk_3_PNormals:	DB $1F, $00, $3E, $1F
  98+ EDF9 9F 12 37 10                          DB $9F, $12, $37, $10
  99+ EDFD 1F 12 37 10                          DB $1F, $12, $37, $10
 100+ EE01 9F 10 34 0E                          DB $9F, $10, $34, $0E
 101+ EE05 1F 10 34 0E                          DB $1F, $10, $34, $0E
 102+ EE09 9F 0E 2F 00                          DB $9F, $0E, $2F, $00
 103+ EE0D 1F 0E 2F 00                          DB $1F, $0E, $2F, $00
 104+ EE11 9F 3D 66 00                          DB $9F, $3D, $66, $00
 105+ EE15 1F 3D 66 00                          DB $1F, $3D, $66, $00
 106+ EE19 3F 00 00 50                          DB $3F, $00, $00, $50
 107+ EE1D DF 07 2A 09                          DB $DF, $07, $2A, $09
 108+ EE21 5F 00 1E 06                          DB $5F, $00, $1E, $06
 109+ EE25 5F 07 2A 09                          DB $5F, $07, $2A, $09
 110+ EE29              Cobra_Mk_3_PNormalsSize:equ $ - Cobra_Mk_3_PNormals
 111+ EE29              Cobra_Mk_3_PLen:        equ $ - Cobra_Mk_3_P
 112+ EE29
# file closed: ../../Data/ships/Cobra_Mk_3_P.asm
 970  EE29                                      include "../../Data/ships/Constrictor.asm"
# file opened: ../../Data/ships/Constrictor.asm
   1+ EE29 F3           Constrictor:    	    DB $F3                         ; Number of cargo canisters released when destroyed
   2+ EE2A 49 26                                DW $2649                       ; Ship's targetable area LoHi
   3+ EE2C AE EE                                DW ConstrictorEdges            ; Edge Data
   4+ EE2E 60                                   DB ConstrictorEdgesSize        ; Size of Edge Data
   5+ EE2F 00                                   DB $00                         ; Gun Vertex Byte offset
   6+ EE30 2E                                   DB $2E                         ; Explosion Count
   7+ EE31 11                                   DB ConstrictorVertSize /6      ; Vertex Count /6
   8+ EE32 66                                   DB ConstrictorVertSize         ; Vertex Count
   9+ EE33 18                                   DB ConstrictorEdgesCnt         ; Edges Count
  10+ EE34 18 00                                DW $0018                       ; Bounty LoHi
  11+ EE36 28                                   DB ConstrictorNormalsSize      ; Face (Normal) Count
  12+ EE37 2D                                   DB $2D                         ; Range when it turns to a dot
  13+ EE38 C8                                   DB $C8                         ; Energy Max
  14+ EE39 37                                   DB $37                         ; Speed Max
  15+ EE3A 0E EF                                DW ConstrictorNormals          ; Normals
  16+ EE3C 02                                   DB $02                         ; Q scaling
  17+ EE3D 2F                                   DB $20 | ShipMissiles15        ; Laser power and Nbr Missiles
  18+ EE3E 48 EE                                DW ConstrictorVertices         ; Verticles Address
  19+ EE40 00                                   DB ShipTypeNormal              ; Ship Type
  20+ EE41 00                                   DB 0                           ; NewB Tactics
  21+ EE42 80                                   DB ShipCanAnger                ; AI Flags
  22+ EE43 FF                                   DB $FF                         ; chance of ECM module
  23+ EE44 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ EE45 00 00                                DW $0000                            ; no solid data
  25+ EE47 00                                   DB $00                              ; no solid data
  26+ EE48
  27+ EE48 14 07 50 5F  ConstrictorVertices     DB $14, $07, $50, $5F, $02, $99
  27+ EE4C 02 99
  28+ EE4E 14 07 50 DF                          DB $14, $07, $50, $DF, $01, $99
  28+ EE52 01 99
  29+ EE54 36 07 28 DF                          DB $36, $07, $28, $DF, $14, $99
  29+ EE58 14 99
  30+ EE5A 36 07 28 FF                          DB $36, $07, $28, $FF, $45, $89
  30+ EE5E 45 89
  31+ EE60 14 0D 28 BF                          DB $14, $0D, $28, $BF, $56, $88
  31+ EE64 56 88
  32+ EE66 14 0D 28 3F                          DB $14, $0D, $28, $3F, $67, $88
  32+ EE6A 67 88
  33+ EE6C 36 07 28 7F                          DB $36, $07, $28, $7F, $37, $89
  33+ EE70 37 89
  34+ EE72 36 07 28 5F                          DB $36, $07, $28, $5F, $23, $99
  34+ EE76 23 99
  35+ EE78 14 0D 05 1F                          DB $14, $0D, $05, $1F, $FF, $FF
  35+ EE7C FF FF
  36+ EE7E 14 0D 05 9F                          DB $14, $0D, $05, $9F, $FF, $FF
  36+ EE82 FF FF
  37+ EE84 14 07 3E 52                          DB $14, $07, $3E, $52, $99, $99
  37+ EE88 99 99
  38+ EE8A 14 07 3E D2                          DB $14, $07, $3E, $D2, $99, $99
  38+ EE8E 99 99
  39+ EE90 19 07 19 72                          DB $19, $07, $19, $72, $99, $99
  39+ EE94 99 99
  40+ EE96 19 07 19 F2                          DB $19, $07, $19, $F2, $99, $99
  40+ EE9A 99 99
  41+ EE9C 0F 07 0F 6A                          DB $0F, $07, $0F, $6A, $99, $99
  41+ EEA0 99 99
  42+ EEA2 0F 07 0F EA                          DB $0F, $07, $0F, $EA, $99, $99
  42+ EEA6 99 99
  43+ EEA8 00 07 00 40                          DB $00, $07, $00, $40, $9F, $01
  43+ EEAC 9F 01
  44+ EEAE              ConstrictorVertSize     equ $  - ConstrictorVertices
  45+ EEAE 1F 09 00 04  ConstrictorEdges        DB $1F, $09, $00, $04
  46+ EEB2 1F 19 04 08                          DB $1F, $19, $04, $08
  47+ EEB6 1F 01 04 24                          DB $1F, $01, $04, $24
  48+ EEBA 1F 02 00 20                          DB $1F, $02, $00, $20
  49+ EEBE 1F 29 00 1C                          DB $1F, $29, $00, $1C
  50+ EEC2 1F 23 1C 20                          DB $1F, $23, $1C, $20
  51+ EEC6 1F 14 08 24                          DB $1F, $14, $08, $24
  52+ EECA 1F 49 08 0C                          DB $1F, $49, $08, $0C
  53+ EECE 1F 39 18 1C                          DB $1F, $39, $18, $1C
  54+ EED2 1F 37 18 20                          DB $1F, $37, $18, $20
  55+ EED6 1F 67 14 20                          DB $1F, $67, $14, $20
  56+ EEDA 1F 56 10 24                          DB $1F, $56, $10, $24
  57+ EEDE 1F 45 0C 24                          DB $1F, $45, $0C, $24
  58+ EEE2 1F 58 0C 10                          DB $1F, $58, $0C, $10
  59+ EEE6 1F 68 10 14                          DB $1F, $68, $10, $14
  60+ EEEA 1F 78 14 18                          DB $1F, $78, $14, $18
  61+ EEEE 1F 89 0C 18                          DB $1F, $89, $0C, $18
  62+ EEF2 1F 06 20 24                          DB $1F, $06, $20, $24
  63+ EEF6 12 99 28 30                          DB $12, $99, $28, $30
  64+ EEFA 05 99 30 38                          DB $05, $99, $30, $38
  65+ EEFE 0A 99 38 28                          DB $0A, $99, $38, $28
  66+ EF02 0A 99 2C 3C                          DB $0A, $99, $2C, $3C
  67+ EF06 05 99 34 3C                          DB $05, $99, $34, $3C
  68+ EF0A 12 99 2C 34                          DB $12, $99, $2C, $34
  69+ EF0E              ConstrictorEdgesSize    equ $  - ConstrictorEdges
  70+ EF0E              ConstrictorEdgesCnt     equ ConstrictorEdgesSize/4
  71+ EF0E 1F 00 37 0F  ConstrictorNormals      DB $1F, $00, $37, $0F, $9F, $18, $4B, $14
  71+ EF12 9F 18 4B 14
  72+ EF16 1F 18 4B 14                          DB $1F, $18, $4B, $14, $1F, $2C, $4B, $00
  72+ EF1A 1F 2C 4B 00
  73+ EF1E 9F 2C 4B 00                          DB $9F, $2C, $4B, $00, $9F, $2C, $4B, $00
  73+ EF22 9F 2C 4B 00
  74+ EF26 1F 00 35 00                          DB $1F, $00, $35, $00, $1F, $2C, $4B, $00
  74+ EF2A 1F 2C 4B 00
  75+ EF2E 3F 00 00 A0                          DB $3F, $00, $00, $A0, $5F, $00, $1B, $00
  75+ EF32 5F 00 1B 00
  76+ EF36              ConstrictorNormalsSize  equ $  - ConstrictorNormals
  77+ EF36              ConstrictorLen          equ $  - Constrictor
  78+ EF36
# file closed: ../../Data/ships/Constrictor.asm
 971  EF36                                      include "../../Data/ships/Coriolis.asm"
# file opened: ../../Data/ships/Coriolis.asm
   1+ EF36 00           Coriolis:	            DB $00                                      ; Number of cargo canisters released when destroyed
   2+ EF37 00 64                                DW $6400                                    ; Ship's targetable area LoHi
   3+ EF39 B5 EF                                DW CoriolisEdges                            ; Edge Data
   4+ EF3B 70                                   DB CoriolisEdgesSize                        ; Size of Edge Data
   5+ EF3C 00                                   DB $00                                      ; Gun Vertex Byte offset
   6+ EF3D 36                                   DB $36                                      ; Explosion Count
   7+ EF3E 10                                   DB CoriolisVertSize /6                      ; Vertex Count /6
   8+ EF3F 60                                   DB CoriolisVertSize                         ; Vertex Count
   9+ EF40 1C                                   DB CoriolisEdgesCnt                         ; Edges Count
  10+ EF41 00 00                                DW $0000                                    ; Bounty LoHi
  11+ EF43 38                                   DB CoriolisNormalsSize                      ; Face (Normal) Count
  12+ EF44 78                                   DB $78                                      ; Range when it turns to a dot
  13+ EF45 F0                                   DB $F0                                      ; Energy Max
  14+ EF46 00                                   DB $00                                      ; Speed Max
  15+ EF47 25 F0                                DW CoriolisNormals                          ; Normals
  16+ EF49 00                                   DB $00                                      ; Q scaling
  17+ EF4A 06                                   DB $06                                      ; Laser power and Nbr Missiles
  18+ EF4B 55 EF                                DW CoriolisVertices                         ; Verticles Address
  19+ EF4D 02                                   DB ShipTypeStation                          ; Ship Type
  20+ EF4E 00                                   DB 0                                        ; NewB Tactics
  21+ EF4F 78                                   DB ShipFighterBaySize | ShipFighterViper    ; AI Flags
  22+ EF50 FF                                   DB $FF                                      ; chance of ECM module
  23+ EF51 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ EF52 00 00                                DW $0000                            ; no solid data
  25+ EF54 00                                   DB $00                              ; no solid data
  26+ EF55              ;Need to do a debug cube and test that, even better a debug square only
  27+ EF55              ; a debug cube would be -160, 160, 160  to -160,160,-160    top left forward     to top left rear         TLF   $A0, $A0, $A0, $9F, $14, $50
  28+ EF55              ;                       -160, 160, 160  to -160,-160,160    top left forward     to bottom left forward   TLR   $A0, $A0, $A0, $BF, $45, $60
  29+ EF55              ;                       -160, 160,-160  to  160,160,-160    top left rear        to top right rear        BLF   $A0, $A0, $A0, $DF, $12, $40
  30+ EF55              ;                       -160, 160,-160  to -160,-160,-160   top left rear        to bottom left rear      TRR   $A0, $A0, $A0, $3F, $35, $60
  31+ EF55              ;                       -160,-160,-160  to -160,-160,-160   bottom left forward  to bottom left rear      BLR   $A0, $A0, $A0, $FF, $24, $60
  32+ EF55              ;                       -160, 160, 160  to  160, 160, 160   top left forward     to top right forward     TRF   $A0, $A0, $A0, $1F, $13, $60
  33+ EF55              ;                       -160,-160, 160  to  160,-160, 160   bottom left forward  to bottom right forward  BRF   $A0, $A0, $A0, $5F, $12, $30
  34+ EF55              ;                       -160,-160,-160  to  160,-160,-160   bottom left rear     to bottom right rear     BRR   $A0, $A0, $A0, $7F, $23, $50
  35+ EF55              ;                        160, 160, 160  to  160, 160,-160   top right forward    to top right rear
  36+ EF55              ;                        160,-160, 160  to  160,-160,-160   bottom right forward to bottom right rear
  37+ EF55              ;                        160, 160, 160  to  160,-160, 160   top right forward    to bottom right forward
  38+ EF55              ;                        160, 160,-160  to  160,-160,-160   top right rear       to bottom right rear
  39+ EF55              CoriolisVertices:	    ; DB $A0, $A0, $A0, $9F, $14, $50    ; TLF 1
  40+ EF55                                      ; DB $A0, $A0, $A0, $BF, $45, $60    ; TLR 2
  41+ EF55                                      ; DB $A0, $A0, $A0, $DF, $12, $40    ; BLF 3
  42+ EF55                                      ; DB $A0, $A0, $A0, $3F, $35, $60    ; TRR 4
  43+ EF55                                      ; DB $A0, $A0, $A0, $FF, $24, $60    ; BLR 5
  44+ EF55                                      ; DB $A0, $A0, $A0, $1F, $13, $60    ; TRF 6
  45+ EF55                                      ; DB $A0, $A0, $A0, $5F, $12, $30    ; BRF 7
  46+ EF55                                      ; DB $A0, $A0, $A0, $7F, $23, $50    ; BRR 8
  47+ EF55 A0 00 A0 1F                           DB $A0, $00, $A0, $1F, $10, $62     ; 160,   0 , 160
  47+ EF59 10 62
  48+ EF5B 00 A0 A0 1F                           DB $00, $A0, $A0, $1F, $20, $83     ;   0, 160 , 160
  48+ EF5F 20 83
  49+ EF61 A0 00 A0 9F                           DB $A0, $00, $A0, $9F, $30, $74     ;-160,   0 , 160
  49+ EF65 30 74
  50+ EF67 00 A0 A0 5F                           DB $00, $A0, $A0, $5F, $10, $54     ;   0,-160 , 160
  50+ EF6B 10 54
  51+ EF6D A0 A0 00 5F                           DB $A0, $A0, $00, $5F, $51, $A6     ; 160,-160 ,   0
  51+ EF71 51 A6
  52+ EF73 A0 A0 00 1F                           DB $A0, $A0, $00, $1F, $62, $B8     ; 160, 160 ,   0
  52+ EF77 62 B8
  53+ EF79 A0 A0 00 9F                           DB $A0, $A0, $00, $9F, $73, $C8     ;-160, 160 ,   0
  53+ EF7D 73 C8
  54+ EF7F A0 A0 00 DF                           DB $A0, $A0, $00, $DF, $54, $97     ;-160,-160 ,   0
  54+ EF83 54 97
  55+ EF85 A0 00 A0 3F                           DB $A0, $00, $A0, $3F, $A6, $DB     ; 160,   0 ,-160
  55+ EF89 A6 DB
  56+ EF8B 00 A0 A0 3F                           DB $00, $A0, $A0, $3F, $B8, $DC     ;   0, 160 ,-160
  56+ EF8F B8 DC
  57+ EF91 A0 00 A0 BF                           DB $A0, $00, $A0, $BF, $97, $DC     ;-160,   0 ,-160
  57+ EF95 97 DC
  58+ EF97 00 A0 A0 7F                           DB $00, $A0, $A0, $7F, $95, $DA     ;   0,-160 ,-160
  58+ EF9B 95 DA
  59+ EF9D 0A 1E A0 5E                           DB $0A, $1E, $A0, $5E, $00, $00     ; 160, -30 , 160
  59+ EFA1 00 00
  60+ EFA3 0A 1E A0 1E                           DB $0A, $1E, $A0, $1E, $00, $00     ; 160,  30 , 160
  60+ EFA7 00 00
  61+ EFA9 0A 1E A0 9E                           DB $0A, $1E, $A0, $9E, $00, $00     ;-160,  30 , 160
  61+ EFAD 00 00
  62+ EFAF 0A 1E A0 DE                          DB $0A, $1E, $A0, $DE, $00, $00     ;-160, -30 , 160
  62+ EFB3 00 00
  63+ EFB5              CoriolisVertSize:       equ $ - CoriolisVertices
  64+ EFB5              CoriolisEdges:	        ; DB $1F, $46, $01, $02
  65+ EFB5                                      ; DB $1F, $56, $02, $04
  66+ EFB5                                      ; DB $1F, $36, $06, $04
  67+ EFB5                                      ; DB $1F, $16, $01, $06
  68+ EFB5                                      ; DB $1F, $14, $01, $03
  69+ EFB5                                      ; DB $1F, $46, $02, $05
  70+ EFB5                                      ; DB $1F, $35, $04, $08
  71+ EFB5                                      ; DB $1F, $23, $06, $07
  72+ EFB5                                      ; DB $1F, $24, $03, $05
  73+ EFB5                                      ; DB $1F, $25, $05, $08
  74+ EFB5                                      ; DB $1F, $23, $07, $08
  75+ EFB5                                      ; DB $1F, $12, $03, $07
  76+ EFB5
  77+ EFB5 1F 10 00 0C                          DB $1F, $10, $00, $0C
  78+ EFB9 1F 20 00 04                          DB $1F, $20, $00, $04
  79+ EFBD 1F 30 04 08                          DB $1F, $30, $04, $08
  80+ EFC1 1F 40 08 0C                          DB $1F, $40, $08, $0C
  81+ EFC5 1F 51 0C 10                          DB $1F, $51, $0C, $10
  82+ EFC9 1F 61 00 10                          DB $1F, $61, $00, $10
  83+ EFCD 1F 62 00 14                          DB $1F, $62, $00, $14
  84+ EFD1 1F 82 14 04                          DB $1F, $82, $14, $04
  85+ EFD5 1F 83 04 18                          DB $1F, $83, $04, $18
  86+ EFD9 1F 73 08 18                          DB $1F, $73, $08, $18
  87+ EFDD 1F 74 08 1C                          DB $1F, $74, $08, $1C
  88+ EFE1 1F 54 0C 1C                          DB $1F, $54, $0C, $1C
  89+ EFE5 1F DA 20 2C                          DB $1F, $DA, $20, $2C
  90+ EFE9 1F DB 20 24                          DB $1F, $DB, $20, $24
  91+ EFED 1F DC 24 28                          DB $1F, $DC, $24, $28
  92+ EFF1 1F D9 28 2C                          DB $1F, $D9, $28, $2C
  93+ EFF5 1F A5 10 2C                          DB $1F, $A5, $10, $2C
  94+ EFF9 1F A6 10 20                          DB $1F, $A6, $10, $20
  95+ EFFD 1F B6 14 20                          DB $1F, $B6, $14, $20
  96+ F001 1F B8 14 24                          DB $1F, $B8, $14, $24
  97+ F005 1F C8 18 24                          DB $1F, $C8, $18, $24
  98+ F009 1F C7 18 28                          DB $1F, $C7, $18, $28
  99+ F00D 1F 97 1C 28                          DB $1F, $97, $1C, $28
 100+ F011 1F 95 1C 2C                          DB $1F, $95, $1C, $2C
 101+ F015 1E 00 30 34                          DB $1E, $00, $30, $34
 102+ F019 1E 00 34 38                          DB $1E, $00, $34, $38
 103+ F01D 1E 00 38 3C                          DB $1E, $00, $38, $3C
 104+ F021 1E 00 3C 30                          DB $1E, $00, $3C, $30
 105+ F025              CoriolisEdgesSize:      equ $ - CoriolisEdges
 106+ F025              CoriolisEdgesCnt:       equ CoriolisEdgesSize/4
 107+ F025              CoriolisNormals:	    ; DB $1F, $6B, $00, $00
 108+ F025                                      ; DB $5F, $00, $6B, $00
 109+ F025                                      ; DB $1F, $6B, $00, $00
 110+ F025                                      ; DB $9F, $6B, $00, $00
 111+ F025                                      ; DB $3F, $00, $00, $6B
 112+ F025                                      ; DB $1F, $00, $6B, $00
 113+ F025
 114+ F025 1F 00 00 A0                          DB $1F, $00, $00, $A0
 115+ F029 5F 6B 6B 6B                          DB $5F, $6B, $6B, $6B
 116+ F02D 1F 6B 6B 6B                          DB $1F, $6B, $6B, $6B
 117+ F031 9F 6B 6B 6B                          DB $9F, $6B, $6B, $6B
 118+ F035 DF 6B 6B 6B                          DB $DF, $6B, $6B, $6B
 119+ F039 5F 00 A0 00                          DB $5F, $00, $A0, $00
 120+ F03D 1F A0 00 00                          DB $1F, $A0, $00, $00
 121+ F041 9F A0 00 00                          DB $9F, $A0, $00, $00
 122+ F045 1F 00 A0 00                          DB $1F, $00, $A0, $00
 123+ F049 FF 6B 6B 6B                          DB $FF, $6B, $6B, $6B
 124+ F04D 7F 6B 6B 6B                          DB $7F, $6B, $6B, $6B
 125+ F051 3F 6B 6B 6B                          DB $3F, $6B, $6B, $6B
 126+ F055 BF 6B 6B 6B                          DB $BF, $6B, $6B, $6B
 127+ F059 3F 00 00 A0                          DB $3F, $00, $00, $A0
 128+ F05D              CoriolisNormalsSize:    equ $ - CoriolisNormals
 129+ F05D              CoriolisLen:            equ $ - Coriolis
 130+ F05D
# file closed: ../../Data/ships/Coriolis.asm
 972  F05D                                      include "../../Data/ships/Cougar.asm"
# file opened: ../../Data/ships/Cougar.asm
   1+ F05D 03           Cougar:	                DB $03                         ; Number of cargo canisters released when destroyed
   2+ F05E 24 13                                DW $1324                       ; Ship's targetable area LoHi
   3+ F060 EE F0                                DW CougarEdges                 ; Edge Data
   4+ F062 64                                   DB CougarEdgesSize             ; Size of Edge Data
   5+ F063 00                                   DB $00                         ; Gun Vertex Byte offset
   6+ F064 2A                                   DB $2A                         ; Explosion Count
   7+ F065 13                                   DB CougarVertSize /6           ; Vertex Count /6
   8+ F066 72                                   DB CougarVertSize              ; Vertex Count
   9+ F067 19                                   DB CougarEdgesCnt              ; Edges Count
  10+ F068 00 00                                DW $0000                       ; Bounty LoHi
  11+ F06A 18                                   DB CougarNormalsSize           ; Face (Normal) Count
  12+ F06B 22                                   DB $22                         ; Range when it turns to a dot
  13+ F06C FC                                   DB $FC                         ; Energy Max
  14+ F06D 28                                   DB $28                         ; Speed Max
  15+ F06E 52 F1                                DW CougarNormals               ; Normals
  16+ F070 02                                   DB $02                         ; Q scaling
  17+ F071 34                                   DB $30 | ShipMissiles4         ; Laser power and Nbr Missiles
  18+ F072 7C F0                                DW CougarVertices              ; Verticles Address
  19+ F074 00                                   DB ShipTypeNormal              ; Ship Type
  20+ F075 00                                   DB 0                           ; NewB Tactics
  21+ F076 80                                   DB ShipCanAnger                ; AI Flags
  22+ F077 B0                                   DB $B0                         ; chance of ECM module
  23+ F078 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ F079 00 00                                DW $0000                            ; no solid data
  25+ F07B 00                                   DB $00                              ; no solid data
  26+ F07C
  27+ F07C 00 05 43 1F  CougarVertices:	        DB $00, $05, $43, $1F, $02, $44
  27+ F080 02 44
  28+ F082 14 00 28 9F                          DB $14, $00, $28, $9F, $01, $22
  28+ F086 01 22
  29+ F088 28 00 28 BF                          DB $28, $00, $28, $BF, $01, $55
  29+ F08C 01 55
  30+ F08E 00 0E 28 3E                          DB $00, $0E, $28, $3E, $04, $55
  30+ F092 04 55
  31+ F094 00 0E 28 7E                          DB $00, $0E, $28, $7E, $12, $35
  31+ F098 12 35
  32+ F09A 14 00 28 1F                          DB $14, $00, $28, $1F, $23, $44
  32+ F09E 23 44
  33+ F0A0 28 00 28 3F                          DB $28, $00, $28, $3F, $34, $55
  33+ F0A4 34 55
  34+ F0A6 24 00 38 9F                          DB $24, $00, $38, $9F, $01, $11
  34+ F0AA 01 11
  35+ F0AC 3C 00 14 BF                          DB $3C, $00, $14, $BF, $01, $11
  35+ F0B0 01 11
  36+ F0B2 24 00 38 1F                          DB $24, $00, $38, $1F, $34, $44
  36+ F0B6 34 44
  37+ F0B8 3C 00 14 3F                          DB $3C, $00, $14, $3F, $34, $44
  37+ F0BC 34 44
  38+ F0BE 00 07 23 12                          DB $00, $07, $23, $12, $00, $44
  38+ F0C2 00 44
  39+ F0C4 00 08 19 14                          DB $00, $08, $19, $14, $00, $44
  39+ F0C8 00 44
  40+ F0CA 0C 02 2D 94                          DB $0C, $02, $2D, $94, $00, $00
  40+ F0CE 00 00
  41+ F0D0 0C 02 2D 14                          DB $0C, $02, $2D, $14, $44, $44
  41+ F0D4 44 44
  42+ F0D6 0A 06 28 B4                          DB $0A, $06, $28, $B4, $55, $55
  42+ F0DA 55 55
  43+ F0DC 0A 06 28 F4                          DB $0A, $06, $28, $F4, $55, $55
  43+ F0E0 55 55
  44+ F0E2 0A 06 28 74                          DB $0A, $06, $28, $74, $55, $55
  44+ F0E6 55 55
  45+ F0E8 0A 06 28 34                          DB $0A, $06, $28, $34, $55, $55
  45+ F0EC 55 55
  46+ F0EE              CougarVertSize:         equ $ - CougarVertices
  47+ F0EE 1F 02 00 04  CougarEdges:	        DB $1F, $02, $00, $04
  48+ F0F2 1F 01 04 1C                          DB $1F, $01, $04, $1C
  49+ F0F6 1F 01 1C 20                          DB $1F, $01, $1C, $20
  50+ F0FA 1F 01 20 08                          DB $1F, $01, $20, $08
  51+ F0FE 1E 05 08 0C                          DB $1E, $05, $08, $0C
  52+ F102 1E 45 0C 18                          DB $1E, $45, $0C, $18
  53+ F106 1E 15 08 10                          DB $1E, $15, $08, $10
  54+ F10A 1E 35 10 18                          DB $1E, $35, $10, $18
  55+ F10E 1F 34 18 28                          DB $1F, $34, $18, $28
  56+ F112 1F 34 28 24                          DB $1F, $34, $28, $24
  57+ F116 1F 34 24 14                          DB $1F, $34, $24, $14
  58+ F11A 1F 24 14 00                          DB $1F, $24, $14, $00
  59+ F11E 1B 04 00 0C                          DB $1B, $04, $00, $0C
  60+ F122 1B 12 04 10                          DB $1B, $12, $04, $10
  61+ F126 1B 23 14 10                          DB $1B, $23, $14, $10
  62+ F12A 1A 01 04 08                          DB $1A, $01, $04, $08
  63+ F12E 1A 34 14 18                          DB $1A, $34, $14, $18
  64+ F132 14 00 30 34                          DB $14, $00, $30, $34
  65+ F136 12 00 34 2C                          DB $12, $00, $34, $2C
  66+ F13A 12 44 2C 38                          DB $12, $44, $2C, $38
  67+ F13E 14 44 38 30                          DB $14, $44, $38, $30
  68+ F142 12 55 3C 40                          DB $12, $55, $3C, $40
  69+ F146 14 55 40 48                          DB $14, $55, $40, $48
  70+ F14A 12 55 48 44                          DB $12, $55, $48, $44
  71+ F14E 14 55 44 3C                          DB $14, $55, $44, $3C
  72+ F152              CougarEdgesSize:        equ $ - CougarEdges
  73+ F152              CougarEdgesCnt:         equ CougarEdgesSize/4
  74+ F152 9F 10 2E 04  CougarNormals:	        DB $9F, $10, $2E, $04
  75+ F156 DF 10 2E 04                          DB $DF, $10, $2E, $04
  76+ F15A 5F 00 1B 05                          DB $5F, $00, $1B, $05
  77+ F15E 5F 10 2E 04                          DB $5F, $10, $2E, $04
  78+ F162 1F 10 2E 04                          DB $1F, $10, $2E, $04
  79+ F166 3E 00 00 A0                          DB $3E, $00, $00, $A0
  80+ F16A              CougarNormalsSize:      equ $ - CougarNormals
  81+ F16A              CougarLen:              equ $ - Cougar
  82+ F16A
# file closed: ../../Data/ships/Cougar.asm
 973  F16A                                      include "../../Data/ships/Dodo.asm"
# file opened: ../../Data/ships/Dodo.asm
   1+ F16A 00           Dodo:	                DB $00                        ; Number of cargo canisters released when destroyed
   2+ F16B 90 7E                                DW $7E90                      ; Ship's targetable area LoHi
   3+ F16D 19 F2                                DW DodoEdges                  ; Edge Data
   4+ F16F 88                                   DB DodoEdgesSize              ; Size of Edge Data
   5+ F170 00                                   DB $00                        ; Gun Vertex Byte offset
   6+ F171 36                                   DB $36                        ; Explosion Count
   7+ F172 18                                   DB DodoVertSize /6            ; Vertex Count /6
   8+ F173 90                                   DB DodoVertSize               ; Vertex Count
   9+ F174 22                                   DB DodoEdgesCnt               ; Edges Count
  10+ F175 00 00                                DW $0000                      ; Bounty LoHi
  11+ F177 30                                   DB DodoNormalsSize            ; Face (Normal) Count
  12+ F178 7D                                   DB $7D                        ; Range when it turns to a dot
  13+ F179 F0                                   DB $F0                        ; Energy Max
  14+ F17A 00                                   DB $00                        ; Speed Max
  15+ F17B A1 F2                                DW DodoNormals                ; Normals
  16+ F17D 00                                   DB $00                        ; Q scaling
  17+ F17E 00                                   DB $00                        ; Laser power and Nbr Missiles
  18+ F17F 89 F1                                DW DodoVertices               ; Verticles Address
  19+ F181 02                                   DB ShipTypeStation            ; Ship Type
  20+ F182 00                                   DB 0                          ; NewB Tactics
  21+ F183 00                                   DB 0                          ; AI Flags
  22+ F184 FF                                   DB $FF                        ; chance of ECM module
  23+ F185 FF                                   DB $FF                              ; Supports Solid Fill = false
  24+ F186 00 00                                DW $0000                            ; no solid data
  25+ F188 00                                   DB $00                              ; no solid data
  26+ F189
  27+ F189 00 96 C4 1F  DodoVertices:	        DB $00, $96, $C4, $1F, $01, $55
  27+ F18D 01 55
  28+ F18F 8F 2E C4 1F                          DB $8F, $2E, $C4, $1F, $01, $22
  28+ F193 01 22
  29+ F195 58 79 C4 5F                          DB $58, $79, $C4, $5F, $02, $33
  29+ F199 02 33
  30+ F19B 58 79 C4 DF                          DB $58, $79, $C4, $DF, $03, $44
  30+ F19F 03 44
  31+ F1A1 8F 2E C4 9F                          DB $8F, $2E, $C4, $9F, $04, $55
  31+ F1A5 04 55
  32+ F1A7 00 F3 2E 1F                          DB $00, $F3, $2E, $1F, $15, $66
  32+ F1AB 15 66
  33+ F1AD E7 4B 2E 1F                          DB $E7, $4B, $2E, $1F, $12, $77
  33+ F1B1 12 77
  34+ F1B3 8F C4 2E 5F                          DB $8F, $C4, $2E, $5F, $23, $88
  34+ F1B7 23 88
  35+ F1B9 8F C4 2E DF                          DB $8F, $C4, $2E, $DF, $34, $99
  35+ F1BD 34 99
  36+ F1BF E7 4B 2E 9F                          DB $E7, $4B, $2E, $9F, $45, $AA
  36+ F1C3 45 AA
  37+ F1C5 8F C4 2E 3F                          DB $8F, $C4, $2E, $3F, $16, $77
  37+ F1C9 16 77
  38+ F1CB E7 4B 2E 7F                          DB $E7, $4B, $2E, $7F, $27, $88
  38+ F1CF 27 88
  39+ F1D1 00 F3 2E 7F                          DB $00, $F3, $2E, $7F, $38, $99
  39+ F1D5 38 99
  40+ F1D7 E7 4B 2E FF                          DB $E7, $4B, $2E, $FF, $49, $AA
  40+ F1DB 49 AA
  41+ F1DD 8F C4 2E BF                          DB $8F, $C4, $2E, $BF, $56, $AA
  41+ F1E1 56 AA
  42+ F1E3 58 79 C4 3F                          DB $58, $79, $C4, $3F, $67, $BB
  42+ F1E7 67 BB
  43+ F1E9 8F 2E C4 7F                          DB $8F, $2E, $C4, $7F, $78, $BB
  43+ F1ED 78 BB
  44+ F1EF 00 96 C4 7F                          DB $00, $96, $C4, $7F, $89, $BB
  44+ F1F3 89 BB
  45+ F1F5 8F 2E C4 FF                          DB $8F, $2E, $C4, $FF, $9A, $BB
  45+ F1F9 9A BB
  46+ F1FB 58 79 C4 BF                          DB $58, $79, $C4, $BF, $6A, $BB
  46+ F1FF 6A BB
  47+ F201 10 20 C4 9E                          DB $10, $20, $C4, $9E, $00, $00
  47+ F205 00 00
  48+ F207 10 20 C4 DE                          DB $10, $20, $C4, $DE, $00, $00
  48+ F20B 00 00
  49+ F20D 10 20 C4 17                          DB $10, $20, $C4, $17, $00, $00
  49+ F211 00 00
  50+ F213 10 20 C4 57                          DB $10, $20, $C4, $57, $00, $00
  50+ F217 00 00
  51+ F219              DodoVertSize:           equ $ - DodoVertices
  52+ F219 1F 01 00 04  DodoEdges:	            DB $1F, $01, $00, $04
  53+ F21D 1F 02 04 08                          DB $1F, $02, $04, $08
  54+ F221 1F 03 08 0C                          DB $1F, $03, $08, $0C
  55+ F225 1F 04 0C 10                          DB $1F, $04, $0C, $10
  56+ F229 1F 05 10 00                          DB $1F, $05, $10, $00
  57+ F22D 1F 16 14 28                          DB $1F, $16, $14, $28
  58+ F231 1F 17 28 18                          DB $1F, $17, $28, $18
  59+ F235 1F 27 18 2C                          DB $1F, $27, $18, $2C
  60+ F239 1F 28 2C 1C                          DB $1F, $28, $2C, $1C
  61+ F23D 1F 38 1C 30                          DB $1F, $38, $1C, $30
  62+ F241 1F 39 30 20                          DB $1F, $39, $30, $20
  63+ F245 1F 49 20 34                          DB $1F, $49, $20, $34
  64+ F249 1F 4A 34 24                          DB $1F, $4A, $34, $24
  65+ F24D 1F 5A 24 38                          DB $1F, $5A, $24, $38
  66+ F251 1F 56 38 14                          DB $1F, $56, $38, $14
  67+ F255 1F 7B 3C 40                          DB $1F, $7B, $3C, $40
  68+ F259 1F 8B 40 44                          DB $1F, $8B, $40, $44
  69+ F25D 1F 9B 44 48                          DB $1F, $9B, $44, $48
  70+ F261 1F AB 48 4C                          DB $1F, $AB, $48, $4C
  71+ F265 1F 6B 4C 3C                          DB $1F, $6B, $4C, $3C
  72+ F269 1F 15 00 14                          DB $1F, $15, $00, $14
  73+ F26D 1F 12 04 18                          DB $1F, $12, $04, $18
  74+ F271 1F 23 08 1C                          DB $1F, $23, $08, $1C
  75+ F275 1F 34 0C 20                          DB $1F, $34, $0C, $20
  76+ F279 1F 45 10 24                          DB $1F, $45, $10, $24
  77+ F27D 1F 67 28 3C                          DB $1F, $67, $28, $3C
  78+ F281 1F 78 2C 40                          DB $1F, $78, $2C, $40
  79+ F285 1F 89 30 44                          DB $1F, $89, $30, $44
  80+ F289 1F 9A 34 48                          DB $1F, $9A, $34, $48
  81+ F28D 1F 6A 38 4C                          DB $1F, $6A, $38, $4C
  82+ F291 1E 00 50 54                          DB $1E, $00, $50, $54
  83+ F295 14 00 54 5C                          DB $14, $00, $54, $5C
  84+ F299 17 00 5C 58                          DB $17, $00, $5C, $58
  85+ F29D 14 00 58 50                          DB $14, $00, $58, $50
  86+ F2A1              DodoEdgesSize:          equ $ - DodoEdges
  87+ F2A1              DodoEdgesCnt:           equ DodoEdgesSize/4
  88+ F2A1 1F 00 00 C4  DodoNormals:	        DB $1F, $00, $00, $C4
  89+ F2A5 1F 67 8E 58                          DB $1F, $67, $8E, $58
  90+ F2A9 5F A9 37 59                          DB $5F, $A9, $37, $59
  91+ F2AD 5F 00 B0 58                          DB $5F, $00, $B0, $58
  92+ F2B1 DF A9 37 59                          DB $DF, $A9, $37, $59
  93+ F2B5 9F 67 8E 58                          DB $9F, $67, $8E, $58
  94+ F2B9 3F 00 B0 58                          DB $3F, $00, $B0, $58
  95+ F2BD 3F A9 37 59                          DB $3F, $A9, $37, $59
  96+ F2C1 7F 67 8E 58                          DB $7F, $67, $8E, $58
  97+ F2C5 FF 67 8E 58                          DB $FF, $67, $8E, $58
  98+ F2C9 BF A9 37 59                          DB $BF, $A9, $37, $59
  99+ F2CD 3F 00 00 C4                          DB $3F, $00, $00, $C4
 100+ F2D1              DodoNormalsSize:        equ $ - DodoNormals
 101+ F2D1              DodoLen:                equ $ - Dodo
 102+ F2D1
# file closed: ../../Data/ships/Dodo.asm
 974  F2D1
 975  F2D1
 976  F2D1                  DISPLAY "Bank ",BankShipModels1," - Bytes free ",/D, $2000 - ($-ShipModelsAddr), " - BankShipModels1"
 977  F2D1              ; Bank 70  ------------------------------------------------------------------------------------------------------------------------
 978  F2D1                                  SLOT    UniverseBankAddr
 979  F2D1                                  PAGE    BankUNIVDATA0
 980  F2D1                                  ORG	    UniverseBankAddr,BankUNIVDATA0
 981  C000                                  INCLUDE "../../Tests/3DTest/univ_ship_data.asm"
# file opened: ../../Tests/3DTest/univ_ship_data.asm
   1+ C000              ;    DEFINE DEBUGMISSILELAUNCH 1
   2+ C000              ;    DEFINE PLOTPOINTSONLY 1
   3+ C000              ;   DEFINE OVERLAYNODES 1
   4+ C000              ; In  flight ship data tables
   5+ C000              ; In  flight ship data tables
   6+ C000              ; There can be upto &12 objects in flight.
   7+ C000              ; To avoid hassle of memory heap managment, the free list
   8+ C000              ; will correspond to a memory bank offset so data will be held in
   9+ C000              ; 1 bank per universe object. Its a waste of a lot of memory but really
  10+ C000              ; 1 bank per universe object. Its a waste of a lot of memory but really
  11+ C000              ; simple that way. Each bank will be 8K and swapped on 8K slot 7 $E000 to $FFFF
  12+ C000              ; This means each gets its own line list, inwork etc
  13+ C000
  14+ C000              ; "Runtime Ship Data paged into in Bank 7"
  15+ C000              ;                       1234567890123456
  16+ C000 55 6E 69 76  StartOfUniv:        DB "Universe PG"
  16+ C004 65 72 73 65
  16+ C008 20 50 47
  17+ C00B 58           StartOfUnivN:       DB "X"
  18+ C00C 00 00        StartOfUnivPad:     DS 2
  19+ C00E 00           StartOfUnivM:       DB 0
  20+ C00F 00           StartOfUnivT        DB 0
  21+ C010 00 00 00...  StartOfUnivName     DS 16
  22+ C020              ;-Camera Position of Ship----------------------------------------------------------------------------------------------------------
  23+ C020                                     INCLUDE "../../Universe/Ships/AIRuntimeData.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/AIRuntimeData.asm
   1++C020              ;-Camera Position of Ship----------------------------------------------------------------------------------------------------------
   2++C020              ;--NOTE POSTITION AND MATRIX are loaded by a single LDIR in cases so must be contiguous
   3++C020              StartOfShipRuntimeData      EQU $
   4++C020 00           UBnKxlo                     DB  0                       ; INWK+0
   5++C021 00           UBnKxhi                     DB  0                       ; there are hi medium low as some times these are 24 bit
   6++C022 00           UBnKxsgn                    DB  0                       ; INWK+2
   7++C023 00           UBnKylo                     DB  0                       ; INWK+3 \ ylo
   8++C024 00           UBnKyhi                     DB  0                       ; INWK+4 \ yHi
   9++C025 00           UBnKysgn                    DB  0                       ; INWK +5
  10++C026 00           UBnKzlo                     DB  0                       ; INWK +6
  11++C027 00           UBnKzhi                     DB  0                       ; INWK +7
  12++C028 00           UBnKzsgn                    DB  0                       ; INWK +8
  13++C029              ;-Rotation Matrix of Ship----------------------------------------------------------------------------------------------------------
  14++C029              ; Rotation data is stored as lohi, but only 15 bits with 16th bit being  a sign bit. Note this is NOT 2'c compliment
  15++C029              ; Note they seem to have to be after camera position not quite found why yet, can only assume it does an iy or ix indexed copy? Bu oddly does not affect space station.
  16++C029 00           UBnkTidyCounter             DB  0                       ; every 16 iterations the rotation matrix is normalised
  17++C02A 00 00        UBnkrotmatSidevX            DW  0                       ; INWK +21
  18++C02C              UBnkrotmatSidev             equ UBnkrotmatSidevX
  19++C02C 00 00        UBnkrotmatSidevY            DW  0                       ; INWK +23
  20++C02E 00 00        UBnkrotmatSidevZ            DW  0                       ; INWK +25
  21++C030 00 00        UBnkrotmatRoofvX            DW  0                       ; INWK +15
  22++C032              UBnkrotmatRoofv             equ UBnkrotmatRoofvX
  23++C032 00 00        UBnkrotmatRoofvY            DW  0                       ; INWK +17
  24++C034 00 00        UBnkrotmatRoofvZ            DW  0                       ; INWK +19
  25++C036 00 00        UBnkrotmatNosevX            DW  0                       ; INWK +9
  26++C038              UBnkrotmatNosev             EQU UBnkrotmatNosevX
  27++C038 00 00        UBnkrotmatNosevY            DW  0                       ; INWK +11
  28++C03A 00 00        UBnkrotmatNosevZ            DW  0                       ; INWK +13
  29++C03C              ; -- Note these must be here for initialise blast as it does a 12 byte ldir
  30++C03C              ; . Note missile explosion will have to have logic to cause linger if a blast is to be enqued
  31++C03C 00           UBnKMissileBlastRange:      DB  0                       ; copied in when setting up a missile
  32++C03D 00           UBnKMissileBlastDamage:     DB  0                       ; copied in when setting up a missile
  33++C03E 00           UBnKMissileDetonateRange:   DB  0                       ; copied in when setting up a missile, allows for proximity missiles
  34++C03F 00           UBnKMissileDetonateDamage:  DB  0                       ; copied in when setting up a missile
  35++C040              ; -- Metadata for ship to help with bank managment
  36++C040              UBnKStartOfRuntimeData:
  37++C040 00           UBnKSlotNumber              DB  0
  38++C041 00           UbnKShipUnivBankNbr         DB  0                       ; Present ship universe bank number
  39++C042 00           UBnkShipModelBank           DB  0                       ; Bank nbr ship was from
  40++C043 00           UBnKShipModelNbr            DB  0                       ; Ship Id with in the bank
  41++C044 00           UBnKShipModelId             DB  0                       ; Absolute ship id
  42++C045              ; -- Ship AI data
  43++C045              ; -- Targetting runtime data
  44++C045 00           UBnKMissleHitToProcess      DB  0                       ; This is used for enquing missle blasts as we can only do one missile at a time, could make it multi but neeed to smooth CPU usage
  45++C046 00           UBnKMissileTarget           DB  0                       ; This is the ship slot number for the target from 0 to n if the missile is not hostile to us, if the target is $FF then its us
  46++C047 00 00 00     UBnKTargetXPos              DS  3                       ; target position for AI
  47++C04A 00 00 00     UBnKTargetYPos              DS  3                       ; .
  48++C04D 00 00 00     UBnKTargetZPos              DS  3                       ; .
  49++C050 00           UBnKTargetXPosSgn           DS  1                       ; target position sign for AI
  50++C051 00           UBnKTargetYPosSgn           DS  1                       ; .
  51++C052 00           UBnKTargetZPosSgn           DS  1                       ; .
  52++C053 00 00        UBnKTargetVectorX           DS  2                       ; target vector for AI
  53++C055 00 00        UBnKTargetVectorY           DS  2                       ; .
  54++C057 00 00        UBnKTargetVectorZ           DS  2                       ; .
  55++C059 00 00        UBnKTargetDotProduct1       DS  2
  56++C05B 00 00        UBnKTargetDotProduct2       DS  2
  57++C05D 00 00        UBnKTargetDotProduct3       DS  2
  58++C05F 00           UBnKTacticsRotMatX          DB  0
  59++C060 00           UBnKTacticsRotMatXSign      DB  0
  60++C061 00           UBnKTacticsRotMatY          DB  0
  61++C062 00           UBnKTacticsRotMatYSign      DB  0
  62++C063 00           UBnKTacticsRotMatZ          DB  0
  63++C064 00           UBnKTacticsRotMatZSign      DB  0
  64++C065 00 00 00...  UBnKOffset                  DS  3 * 3                   ; Offset position for target
  65++C06E              UBnKOffsetX                 equ UBnKOffset
  66++C06E              UBnKOffsetXHi               equ UBnKOffsetX+1
  67++C06E              UBnKOffsetXSign             equ UBnKOffsetX+2
  68++C06E              UBnKOffsetY                 equ UBnKOffset+3
  69++C06E              UBnKOffsetYHi               equ UBnKOffsetY+1
  70++C06E              UBnKOffsetYSign             equ UBnKOffsetY+2
  71++C06E              UBnKOffsetZ                 equ UBnKOffset+6
  72++C06E              UBnKOffsetZHi               equ UBnKOffsetZ+1
  73++C06E              UBnKOffsetZSign             equ UBnKOffsetZ+2
  74++C06E 00           UBnKDirectionX              DB  0
  75++C06F 00           UBnKDirectionXHi            DB  0
  76++C070 00           UBnKDirectionXSign          DB  0
  77++C071 00           UBnKDirectionY              DB  0
  78++C072 00           UBnKDirectionYHi            DB  0
  79++C073 00           UBnKDirectionYSign          DB  0
  80++C074 00           UBnKDirectionZ              DB  0
  81++C075 00           UBnKDirectionZHi            DB  0
  82++C076 00           UBnKDirectionZSign          DB  0
  83++C077 00           UBnKDirNormX                DB  0
  84++C078 00           UBnKDirNormXSign            DB  0
  85++C079 00           UBnKDirNormY                DB  0
  86++C07A 00           UBnKDirNormYSign            DB  0
  87++C07B 00           UBnKDirNormZ                DB  0
  88++C07C 00           UBnKDirNormZSign            DB  0
  89++C07D              UBnKDirection               equ UBnKDirectionX          ; Direction Vector
  90++C07D 00 00        UBnKDotProductNose          DW  0                       ; Dot Product
  91++C07F 00           UBnKDotProductNoseSign      DB  0
  92++C080 00 00        UBnKDotProductRoof          DW  0                       ; Dot Product
  93++C082 00           UBnKDotProductRoofSign      DB  0
  94++C083 00 00        UBnKDotProductSide          DW  0                       ; Dot Product
  95++C085 00           UBnKDotProductSideSign      DB  0
  96++C086 00           UBnKSpeed                   DB  0                       ; INWK +27
  97++C087 00           UBnKAccel                   DB  0                       ; INWK +28
  98++C088 00           UBnKRotXCounter             DB  0                       ; INWK +29
  99++C089              UBnKRollCounter             equ UBnKRotXCounter         ; change over to this in code
 100++C089 00           UBnKRotZCounter             DB  0                       ; INWK +30
 101++C08A              UBnKPitchCounter            equ UBnKRotZCounter
 102++C08A 00           UBnKRAT                     DB  0                       ; temporary for rotation magnitude or roll counter, for debugging state
 103++C08B 00           UBnKRAT2                    DB  0                       ; temporary for rotation threshold
 104++C08C 00           UBnKCNT                     DB  0                       ; temp for calculating roll and pitch
 105++C08D 00           UBnKCNT2                    DB  0                       ; roll threshold, max angle boynd ship will slow down
 106++C08E 00           univRAT                     DB  0               ; 99
 107++C08F 00           univRAT2                    DB  0               ; 9A
 108++C090 00           univRAT2Val                 DB  0               ; 9A
 109++C091 00           UBnKexplDsp                 DB  0                       ; INWK +31 clear exploding/display state|missiles
 110++C092 00           UBnkDrawAllFaces            DB  0
 111++C093 00           UBnKShipAggression          DB  0                       ; calculated agression factor
 112++C094 00           UBnkaiatkecm                DB  0                       ; INWK +32 ai_attack_univ_ecm i.e. AI type
 113++C095 00           UBnKSpawnObject             DB  0
 114++C096 00           UBnkCam0yLo                 DB  0                       ; INWK +33 ????
 115++C097 00           UBnkCam0yHi                 DB  0                       ; INWK +34?????
 116++C098 00           UBnKEnergy                  DB  0                       ; INWK +35
 117++C099 00           UBnKECMCountDown            DB  0                       ; counts down ECM usage if activated reducing energy too in update loop
 118++C09A 00           UBnKECMFitted               DB  0                       ; Does ship have ECM, true false
 119++C09B 00           UBnKLaserPower              DB  0                       ; Type of laser fitted
 120++C09C 00           UBnKMissilesLeft            DB  0
 121++C09D 00           UBnKFighterShipId           DB  0                       ; computed ship Id for any carriers
 122++C09E 00           UBnKFightersLeft            DB  0                       ; the number of ships left in hanger, 255 = infinite
 123++C09F 00           UBnKCloudCounter            DB  0                       ; cloud pixels
 124++C0A0 00           UBnKCloudRadius             DB  0                       ; cloud pixels
 125++C0A1 00           UBnKHeadingToPlanetOrSun    DB  0                       ; 0 = undefined 1 = heading to planet 2 = heading to sun, if it reaches planet then will move to docking, if it heads to sun then will jump
 126++C0A2
 127++C0A2              UBnKRuntimeSize             EQU $-UBnKStartOfRuntimeData
 128++C0A2              ; Flags work as follows:
 129++C0A2              ; UBnKSpawnObject - signals on death to spawn cargo items
 130++C0A2              ; 0 -                   Spawn Cargo 1
 131++C0A2              ; 1 -                   Spawn Cargo 2
 132++C0A2              ; 2 -                   Spawn Cargo 3
 133++C0A2              ; 3 -                   Spawn Cargo 4
 134++C0A2              ; 4 -                   Spawn Alloy 1
 135++C0A2              ; 5 -                   Spawn Alloy 2
 136++C0A2              ; 6 -                   Spawn Alloy 3
 137++C0A2              ; 7 -                   Spawn Alloy 4
 138++C0A2
 139++C0A2              ; UBnkaiatkecm
 140++C0A2              ; Bit	                Description
 141++C0A2              ; 7 -                   AI Enabled Flag
 142++C0A2              ; 6 -                   Ship Visible = ShipOnScreen/NotCloaked (cleared or set by check visible or cloaking override)
 143++C0A2              ; 5 -                   Ship is exploding if set, note if its a missile and one already equeued this will have to linger
 144++C0A2              ;                       linger can be done by not erasing ship unit missile equeue handled
 145++C0A2              ; 4 -                   Ship marked as exploded, cleared once aknowledged then bit 5 takes over and UBnKCloudCounter
 146++C0A2              ; 3 -                   Display state - Plot as a Dot
 147++C0A2              ; 2 -                   Nbr of Missiles bit 2
 148++C0A2              ; 1 -                   Nbr of Missiles bit 1
 149++C0A2              ; 0 -                   ECM present flag
 150++C0A2              ; ShipNewBitsAddr (in blueprint)
 151++C0A2              ;Bit	                Description
 152++C0A2              ;#0	Trader flag         * 0 = not a trader  * 1 = trader
 153++C0A2              ;                       80% of traders are peaceful and mind their own business plying their trade between the planet and space station, but 20% of them moonlight as bounty hunters (see bit #1)
 154++C0A2              ;                       Ships that are traders: Escape pod, Shuttle, Transporter, Anaconda, Rock hermit, Worm
 155++C0A2              ;#1 Bounty hunter flag  * 0 = not a bounty hunter* 1 = bounty hunter
 156++C0A2              ;                       If we are a fugitive or a serious offender and we bump into a bounty hunter, they will become hostile and attack us (see bit #2)
 157++C0A2              ;                       Ships that are bounty hunters: Viper, Fer-de-lance
 158++C0A2              ;#2	Hostile flag        * 0 = not hostile  * 1 = hostile
 159++C0A2              ;                       Hostile ships will attack us on sight; there are quite a few of them
 160++C0A2              ;                       Ships that are hostile: Sidewinder, Mamba, Krait, Adder, Gecko, Cobra Mk I, Worm, Cobra Mk III, Asp Mk II, Python (pirate), Moray, Thargoid, Thargon, Constrictor
 161++C0A2              ;#3	Pirate flag         * 0 = not a pirate * 1 = pirate
 162++C0A2              ;                       Hostile pirates will attack us on sight, but once we get inside the space station safe zone, they will stop
 163++C0A2              ;                       Ships that are pirates: Sidewinder, Mamba, Krait, Adder, Gecko, Cobra Mk I, Cobra Mk III, Asp Mk II, Python (pirate), Moray, Thargoid
 164++C0A2              ;#4	Docking flag        * 0 = not docking * 1 = docking
 165++C0A2              ;                       Traders with their docking flag set fly towards the space station to try to dock, otherwise they aim for the planet
 166++C0A2              ;                       This flag is randomly set for traders when they are spawned
 167++C0A2              ;                       Ships that can be docking: Escape pod, Shuttle, Transporter, Anaconda, Rock hermit, Worm
 168++C0A2              ;#5	Innocent bystander  * 0 = normal * 1 = innocent bystander
 169++C0A2              ;                       If we attack an innocent ship within the space station safe zone, then the station will get angry with us and start spawning cops
 170++C0A2              ;                       Ships that are innocent bystanders: Shuttle, Transporter, Cobra Mk III, Python, Boa, Anaconda, Rock hermit, Cougar
 171++C0A2              ;#6	Cop flag            * 0 = not a cop * 1 = cop
 172++C0A2              ;                       If we destroy a cop, then we instantly become a fugitive (the Transporter isn't actually a cop, but it's clearly under police protection)
 173++C0A2              ;                       Ships that are cops: Viper, Transporter
 174++C0A2              ;#7	Scooped, docked, escape pod flag
 175++C0A2              ;                       For spawned ships, this flag indicates that the ship been scooped or has docked (bit 7 is always clear on spawning)
 176++C0A2              ;                       For blueprints, this flag indicates whether the ship type has an escape pod fitted, so it can launch it when in dire straits
 177++C0A2              ;                       Ships that have escape pods: Cobra Mk III, Python, Boa, Anaconda, Rock hermit, Viper, Mamba, Krait, Adder, Cobra Mk I, Cobra Mk III (pirate), Asp Mk II, Python (pirate), Fer-de-lance
 178++C0A2
# file closed: ../../Tests/3DTest/../../Universe/Ships/AIRuntimeData.asm
  24+ C0A2                                      INCLUDE "../../Universe/Ships/XX16Vars.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/XX16Vars.asm
   1++C0A2              ;-- XX16 --------------------------------------------------------------------------------------------------------------------------
   2++C0A2 00 00        UBnkTransmatSidevX          DW  0               ; XX16+0
   3++C0A4              UBnkTransmatSidev           EQU UBnkTransmatSidevX
   4++C0A4 00 00        UBnkTransmatSidevY          DW 0                ; XX16+2
   5++C0A6 00 00        UBnkTransmatSidevZ          DW 0                ; XX16+2
   6++C0A8 00 00        UBnkTransmatRoofvX          DW 0
   7++C0AA              UBnkTransmatRoofv           EQU UBnkTransmatRoofvX
   8++C0AA 00 00        UBnkTransmatRoofvY          DW 0                ; XX16+2
   9++C0AC 00 00        UBnkTransmatRoofvZ          DW 0                ; XX16+2
  10++C0AE 00 00        UBnkTransmatNosevX          DW 0
  11++C0B0              UBnkTransmatNosev           EQU UBnkTransmatNosevX
  12++C0B0 00 00        UBnkTransmatNosevY          DW 0                ; XX16+2
  13++C0B2 00 00        UBnkTransmatNosevZ          DW 0                ; XX16+2
  14++C0B4 00 00        UbnkTransmatTransX          DW 0
  15++C0B6 00 00        UbnkTransmatTransY          DW 0
  16++C0B8 00 00        UbnkTransmatTransZ          DW 0
  17++C0BA              XX16                        equ UBnkTransmatSidev
  18++C0BA              ;-- XX16Inv --------------------------------------------------------------------------------------------------------------------------
  19++C0BA 00 00        UbnkTransInvRow0x0          DW 0
  20++C0BC 00 00        UbnkTransInvRow0x1          DW 0
  21++C0BE 00 00        UbnkTransInvRow0x2          DW 0
  22++C0C0 00 00        UbnkTransInvRow0x3          DW 0
  23++C0C2 00 00        UbnkTransInvRow1y0          DW 0
  24++C0C4 00 00        UbnkTransInvRow1y1          DW 0
  25++C0C6 00 00        UbnkTransInvRow1y2          DW 0
  26++C0C8 00 00        UbnkTransInvRow1y3          DW 0
  27++C0CA 00 00        UbnkTransInvRow2z0          DW 0
  28++C0CC 00 00        UbnkTransInvRow2z1          DW 0
  29++C0CE 00 00        UbnkTransInvRow2z2          DW 0
  30++C0D0 00 00        UbnkTransInvRow2z3          DW 0
  31++C0D2
  32++C0D2              XX16Inv             equ UbnkTransInvRow0x0
  33++C0D2
# file closed: ../../Tests/3DTest/../../Universe/Ships/XX16Vars.asm
  25+ C0D2                                      INCLUDE "../../Universe/Ships/XX25Vars.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/XX25Vars.asm
   1++C0D2              ;-- XX25 --------------------------------------------------------------------------------------------------------------------------
   2++C0D2 00           UbnkProjxLo                 DB  0
   3++C0D3 00           UbnkProjxHi                 DB  0
   4++C0D4 00           UbnkProjxSgn                DB  0
   5++C0D5              UbnkProjx                   EQU UbnkProjxLo
   6++C0D5 00           UbnkProjyLo                 DB  0
   7++C0D6 00           UbnkProjyHi                 DB  0
   8++C0D7 00           UbnkProjySgn                DB  0
   9++C0D8              UbnkProjy                   EQU UbnkProjyLo
  10++C0D8 00           UbnkProjzLo                 DB  0
  11++C0D9 00           UbnkProjzHi                 DB  0
  12++C0DA 00           UbnkProjzSgn                DB  0
  13++C0DB              UbnkProjz                   EQU UbnkProjzLo
  14++C0DB              XX25                        EQU UbnkProjxLo
  15++C0DB
# file closed: ../../Tests/3DTest/../../Universe/Ships/XX25Vars.asm
  26+ C0DB                                      INCLUDE "../../Universe/Ships/XX18Vars.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/XX18Vars.asm
   1++C0DB              ;-- XX18 --------------------------------------------------------------------------------------------------------------------------
   2++C0DB 00           UBnkDrawCam0xLo             DB  0               ; XX18+0
   3++C0DC 00           UBnkDrawCam0xHi             DB  0               ; XX18+1
   4++C0DD 00           UBnkDrawCam0xSgn            DB  0               ; XX18+2
   5++C0DE              UBnkDrawCam0x               equ UBnkDrawCam0xLo
   6++C0DE 00           UBnkDrawCam0yLo             DB  0               ; XX18+3
   7++C0DF 00           UBnkDrawCam0yHi             DB  0               ; XX18+4
   8++C0E0 00           UBnkDrawCam0ySgn            DB  0               ; XX18+5
   9++C0E1              UBnkDrawCam0y               equ UBnkDrawCam0yLo
  10++C0E1 00           UBnkDrawCam0zLo             DB  0               ; XX18+6
  11++C0E2 00           UBnkDrawCam0zHi             DB  0               ; XX18+7
  12++C0E3 00           UBnkDrawCam0zSgn            DB  0               ; XX18+8
  13++C0E4              UBnkDrawCam0z               equ UBnkDrawCam0zLo
  14++C0E4              XX18                        equ UBnkDrawCam0xLo
  15++C0E4
# file closed: ../../Tests/3DTest/../../Universe/Ships/XX18Vars.asm
  27+ C0E4
  28+ C0E4              ; Used to make 16 bit reads a little cleaner in source code
  29+ C0E4 00 00 00     UbnkZPoint                  DS  3
  30+ C0E7              UbnkZPointLo                equ UbnkZPoint
  31+ C0E7              UbnkZPointHi                equ UbnkZPoint+1
  32+ C0E7              UbnkZPointSign              equ UbnkZPoint+2
  33+ C0E7                                      INCLUDE "../../Universe/Ships/XX15Vars.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/XX15Vars.asm
   1++C0E7              ;-- XX15 --------------------------------------------------------------------------------------------------------------------------
   2++C0E7 00           UBnkXScaled                 DB  0               ; XX15+0Xscaled
   3++C0E8 00           UBnkXScaledSign             DB  0               ; XX15+1xsign
   4++C0E9 00           UBnkYScaled                 DB  0               ; XX15+2yscaled
   5++C0EA 00           UBnkYScaledSign             DB  0               ; XX15+3ysign
   6++C0EB 00           UBnkZScaled                 DB  0               ; XX15+4zscaled
   7++C0EC 00           UBnkZScaledSign             DB  0               ; XX15+5zsign
   8++C0ED
   9++C0ED              XX15                        equ UBnkXScaled
  10++C0ED              XX15VecX                    equ XX15
  11++C0ED              XX15VecY                    equ XX15+1
  12++C0ED              XX15VecZ                    equ XX15+2
  13++C0ED              UbnkXPoint                  equ XX15
  14++C0ED              UbnkXPointLo                equ XX15+0
  15++C0ED              UbnkXPointHi                equ XX15+1
  16++C0ED              UbnkXPointSign              equ XX15+2
  17++C0ED              UbnkYPoint                  equ XX15+3
  18++C0ED              UbnkYPointLo                equ XX15+3
  19++C0ED              UbnkYPointHi                equ XX15+4
  20++C0ED              UbnkYPointSign              equ XX15+5
  21++C0ED              ; Repurposed XX15 pre clip plines
  22++C0ED              UbnkPreClipX1               equ XX15+0
  23++C0ED              UbnkPreClipY1               equ XX15+2
  24++C0ED              UbnkPreClipX2               equ XX15+4
  25++C0ED              UbnkPreClipY2               equ XX15+6
  26++C0ED              ; Repurposed XX15 post clip lines
  27++C0ED              UBnkNewX1                   equ XX15+0
  28++C0ED              UBnkNewY1                   equ XX15+1
  29++C0ED              UBnkNewX2                   equ XX15+2
  30++C0ED              UBnkNewY2                   equ XX15+3
  31++C0ED              ; Repurposed XX15
  32++C0ED              regXX15fx                   equ UBnkXScaled
  33++C0ED              regXX15fxSgn                equ UBnkXScaledSign
  34++C0ED              regXX15fy                   equ UBnkYScaled
  35++C0ED              regXX15fySgn                equ UBnkYScaledSign
  36++C0ED              regXX15fz                   equ UBnkZScaled
  37++C0ED              regXX15fzSgn                equ UBnkZScaledSign
  38++C0ED              ; Repurposed XX15
  39++C0ED              varX1                       equ UBnkXScaled       ; Reused, verify correct position
  40++C0ED              varY1                       equ UBnkXScaledSign   ; Reused, verify correct position
  41++C0ED              varZ1                       equ UBnkYScaled       ; Reused, verify correct position
  42++C0ED              ; After clipping the coords are two 8 bit pairs
  43++C0ED              UBnkPoint1Clipped           equ UBnkXScaled
  44++C0ED              UBnkPoint2Clipped           equ UBnkYScaled
  45++C0ED              ; Repurposed XX15 when plotting lines
  46++C0ED              ; Repurposed XX15 before calling clip routine
  47++C0ED              UBnkX1                      equ XX15
  48++C0ED              UBnKx1Lo                    equ XX15
  49++C0ED              UBnKx1Hi                    equ XX15+1
  50++C0ED              UBnkY1                      equ XX15+2
  51++C0ED              UbnKy1Lo                    equ XX15+2
  52++C0ED              UBnkY1Hi                    equ XX15+3
  53++C0ED              UBnkX2                      equ XX15+4
  54++C0ED              UBnkX2Lo                    equ XX15+4
  55++C0ED              UBnkX2Hi                    equ XX15+5
  56++C0ED
# file closed: ../../Tests/3DTest/../../Universe/Ships/XX15Vars.asm
  34+ C0ED                                      INCLUDE "../../Universe/Ships/XX12Vars.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/XX12Vars.asm
   1++C0ED              ;-- transmat0 --------------------------------------------------------------------------------------------------------------------------
   2++C0ED              ; Note XX12 comes after as some logic in normal processing uses XX15 and XX12 combines
   3++C0ED 00           UBnkXX12xLo                 DB  0               ; XX12+0
   4++C0EE 00           UBnkXX12xSign               DB  0               ; XX12+1
   5++C0EF 00           UBnkXX12yLo                 DB  0               ; XX12+2
   6++C0F0 00           UBnkXX12ySign               DB  0               ; XX12+3
   7++C0F1 00           UBnkXX12zLo                 DB  0               ; XX12+4
   8++C0F2 00           UBnkXX12zSign               DB  0               ; XX12+5
   9++C0F3 00 00 00...  XX12Save                    DS  6
  10++C0F9 00 00 00...  XX12Save2                   DS  6
  11++C0FF              XX12                        equ UBnkXX12xLo
  12++C0FF              varXX12                     equ UBnkXX12xLo
  13++C0FF              ; Repurposed XX12 when plotting lines
  14++C0FF              UBnkY2                      equ XX12+0
  15++C0FF              UbnKy2Lo                    equ XX12+0
  16++C0FF              UBnkY2Hi                    equ XX12+1
  17++C0FF              UBnkDeltaXLo                equ XX12+2
  18++C0FF              UBnkDeltaXHi                equ XX12+3
  19++C0FF              UBnkDeltaYLo                equ XX12+4
  20++C0FF              UBnkDeltaYHi                equ XX12+5
  21++C0FF              UbnkGradient                equ XX12+2
  22++C0FF              UBnkTemp1                   equ XX12+2
  23++C0FF              UBnkTemp1Lo                 equ XX12+2
  24++C0FF              UBnkTemp1Hi                 equ XX12+3
  25++C0FF              UBnkTemp2                   equ XX12+3
  26++C0FF              UBnkTemp2Lo                 equ XX12+3
  27++C0FF              UBnkTemp2Hi                 equ XX12+4
  28++C0FF
# file closed: ../../Tests/3DTest/../../Universe/Ships/XX12Vars.asm
  35+ C0FF
  36+ C0FF
  37+ C0FF              ; Post clipping the results are now 8 bit
  38+ C0FF 00           UBnkVisibility              DB  0               ; replaces general purpose xx4 in rendering
  39+ C100 00           UBnkProjectedY              DB  0
  40+ C101 00           UBnkProjectedX              DB  0
  41+ C102              UBnkProjected               equ UBnkProjectedY  ; resultant projected position
  42+ C102 00 00 00...  XX15Save                    DS  8
  43+ C10A 00 00 00...  XX15Save2                   DS  8
  44+ C112 00           VarBackface                 DB 0
  45+ C113              ; Heap (or array) information for lines and normals
  46+ C113              ; Coords are stored XY,XY,XY,XY
  47+ C113              ; Normals
  48+ C113              ; This needs re-oprganising now.
  49+ C113              ; Runtime Calculation Store
  50+ C113
  51+ C113              FaceArraySize               equ 30
  52+ C113              EdgeHeapSize                equ 40
  53+ C113              NodeArraySize               equ 40
  54+ C113              LineArraySize               equ 50; incerased for max of 28 lines, of 4 points of 16 bits each
  55+ C113              ; ONLY IF TESTING SOLID FILL TraingleArraySize           equ 25
  56+ C113              ; Storage arrays for data
  57+ C113              ; Structure of arrays
  58+ C113              ; Visibility array  - 1 Byte per face/normal on ship model Bit 7 (or FF) visible, 0 Invisible
  59+ C113              ; Node array corresponds to a processed vertex from the ship model transformed into world coordinates and tracks the node list from model
  60+ C113              ; NodeArray         -  4 bytes per element      0           1            2          3
  61+ C113              ;                                               X Coord Lo  Y Coord Lo   Z CoordLo  Sign Bits 7 6 5 for X Y Z Signs (set = negative)
  62+ C113              ; Line Array        -  4 bytes per eleement     0           1            2          3
  63+ C113              ;                                               X1          Y1           X2         Y2
  64+ C113 00 00 00...  UbnkFaceVisArray            DS FaceArraySize            ; XX2 Up to 16 faces this may be normal list, each entry is controlled by bit 7, 1 visible, 0 hidden
  65+ C131              ; Node array holds the projected to screen position regardless of if its clipped or not
  66+ C131              ; When we use traingles we can cheat a bit on clipping as all lines will be horizontal so clipping is much simplified
  67+ C131 00 00 00...  UBnkNodeArray               DS NodeArraySize * 4        ; XX3 Holds the points as an array, its an array not a heap
  68+ C1D1 00 00 00...  UBnkNodeArray2              DS NodeArraySize * 4        ; XX3 Holds the points as an array, its an array not a heap
  69+ C271 00 00 00...  UbnkLineArray               DS LineArraySize * 8        ; XX19 Holds the clipped line details
  70+ C401              ; ONLY IF TESTING SOLID FILL UBnkTriangleOverspill       DS TraingleArraySize * 4    ; jsut a padding for testing
  71+ C401              UBnkLinesHeapMax            EQU $ - UbnkLineArray
  72+ C401              UBnkTraingleArray           EQU UbnkLineArray           ; We can use the line array as we draw lines or traingles
  73+ C401 00 00 00...  UbnkEdgeProcessedList DS EdgeHeapSize
  74+ C429              ; Array current Lengths
  75+ C429 00           UbnkFaceVisArrayLen         DS 1
  76+ C42A 00           UBnkNodeArrayLen            DS 1
  77+ C42B 00           UbnkLineArrayLen            DS 1                        ; total number of lines loaded to array
  78+ C42C 00           UbnkLineArrayBytes          DS 1                        ; total number of bytes loaded to array  = array len * 4
  79+ C42D              XX20                        equ UbnkLineArrayLen
  80+ C42D              varXX20                     equ UbnkLineArrayLen
  81+ C42D
  82+ C42D 00           UbnkEdgeHeapSize            DS 1
  83+ C42E 00           UbnkEdgeHeapBytes           DS 1
  84+ C42F 00           UBnkLinesHeapLen            DS 1
  85+ C430 00           UbnKEdgeHeapCounter         DS 1
  86+ C431 00           UbnKEdgeRadius              DS 1
  87+ C432 00           UbnKEdgeShipType            DS 1
  88+ C433 00           UbnKEdgeExplosionType       DS 1
  89+ C434
  90+ C434              ; Node heap is used to write out transformed Vertexs
  91+ C434
  92+ C434              ; Lines
  93+ C434 00 00 00     UBnkXX19                    DS  3
  94+ C437
  95+ C437 00 00 00...  UBnkHullCopy                DS  ShipDataLength
  96+ C452              ScoopDebrisAddr             equ UBnkHullCopy + ScoopDebrisOffset
  97+ C452              MissileLockLoAddr           equ UBnkHullCopy + MissileLockLoOffset
  98+ C452              MissileLockHiAddr           equ UBnkHullCopy + MissileLockHiOffset
  99+ C452              EdgeAddyAddr                equ UBnkHullCopy + EdgeAddyOffset
 100+ C452              LineX4Addr                  equ UBnkHullCopy + LineX4Offset
 101+ C452              GunVertexAddr               equ UBnkHullCopy + GunVertexOffset
 102+ C452              ExplosionCtAddr             equ UBnkHullCopy + ExplosionCtOffset
 103+ C452              VertexCountAddr             equ UBnkHullCopy + VertexCountOffset
 104+ C452              VertexCtX6Addr              equ UBnkHullCopy + VertexCtX6Offset
 105+ C452              EdgeCountAddr               equ UBnkHullCopy + EdgeCountOffset
 106+ C452              BountyLoAddr                equ UBnkHullCopy + BountyLoOffset
 107+ C452              BountyHiAddr                equ UBnkHullCopy + BountyHiOffset
 108+ C452              FaceCtX4Addr                equ UBnkHullCopy + FaceCtX4Offset
 109+ C452              DotAddr                     equ UBnkHullCopy + DotOffset
 110+ C452              EnergyAddr                  equ UBnkHullCopy + EnergyOffset
 111+ C452              SpeedAddr                   equ UBnkHullCopy + SpeedOffset
 112+ C452              FaceAddyAddr                equ UBnkHullCopy + FaceAddyOffset
 113+ C452              QAddr                       equ UBnkHullCopy + QOffset
 114+ C452              LaserAddr                   equ UBnkHullCopy + LaserOffset
 115+ C452              VerticesAddyAddr            equ UBnkHullCopy + VerticiesAddyOffset
 116+ C452              ShipTypeAddr                equ UBnkHullCopy + ShipTypeOffset
 117+ C452              ShipNewBitsAddr             equ UBnkHullCopy + ShipNewBitsOffset
 118+ C452              ShipAIFlagsAddr             equ UBnkHullCopy + ShipAIFlagsOffset
 119+ C452              ShipECMFittedChanceAddr     equ UBnkHullCopy + ShipECMFittedChanceOffset
 120+ C452              ShipSolidFlagAddr           equ UBnkHullCopy + ShipSolidFlagOffset
 121+ C452              ShipSolidFillAddr           equ UBnkHullCopy + ShipSolidFillOffset
 122+ C452              ShipSolidLenAddr            equ UBnkHullCopy + ShipSolidLenOffset
 123+ C452              ; Static Ship Data. This is copied in when creating the universe object
 124+ C452              XX0                         equ UBnkHullCopy        ; general hull index pointer TODO find biggest ship design
 125+ C452
 126+ C452 00 00 00...  UBnkHullVerticies           DS  40 * 6              ; largetst is trasnport type 10 at 37 vericies so alows for 40 * 6 Bytes  =
 127+ C542 00 00 00...  UBnkHullEdges               DS  50 * 4              ; ype 10 is 46 edges so allow 50
 128+ C60A 00 00 00...  UBnkHullNormals             DS  20 * 4              ; type 10 is 14 edges so 20 to be safe
 129+ C65A                  IFDEF SOLIDHULLTEST
 130+ C65A ~            UBnkHullSolid               DS  100 * 4             ; Up to 100 triangles (May optimise so only loads non hidden faces later
 131+ C65A                  ENDIF
 132+ C65A 0C           OrthagCountdown             DB  12
 133+ C65B
 134+ C65B              UBnkShipCopy                equ UBnkHullVerticies               ; Buffer for copy of ship data, for speed will copy to a local memory block, Cobra is around 400 bytes on creation of a new ship so should be plenty
 135+ C65B              UBnk_Data_len               EQU $ - StartOfUniv
 136+ C65B
 137+ C65B
 138+ C65B              ZeroUnivPitch:          MACRO
 139+ C65B ~                                    xor     a
 140+ C65B ~                                    ld      (UBnKRotZCounter),a
 141+ C65B                                      ENDM
 142+ C65B
 143+ C65B              ZeroUnivRoll:           MACRO
 144+ C65B ~                                    xor     a
 145+ C65B ~                                    ld      (UBnKRotXCounter),a
 146+ C65B                                      ENDM
 147+ C65B
 148+ C65B              ZeroUnivPitchAndRoll:   MACRO
 149+ C65B ~                                    xor     a
 150+ C65B ~                                    ld      (UBnKRotXCounter),a
 151+ C65B ~                                    ld      (UBnKRotZCounter),a
 152+ C65B                                      ENDM
 153+ C65B
 154+ C65B
 155+ C65B              MaxUnivPitchAndRoll:    MACRO
 156+ C65B ~                                    ld      a,127
 157+ C65B ~                                    ld      (UBnKRotXCounter),a
 158+ C65B ~                                    ld      (UBnKRotZCounter),a
 159+ C65B                                      ENDM
 160+ C65B
 161+ C65B              InfinitePitch:          MACRO
 162+ C65B ~                                    ld      a,$FF
 163+ C65B ~                                    ld      (UBnKRotZCounter),a
 164+ C65B                                      ENDM
 165+ C65B
 166+ C65B              InfiniteRoll:           MACRO
 167+ C65B ~                                    ld      a,$FF
 168+ C65B ~                                    ld      (UBnKRotXCounter),a
 169+ C65B                                      ENDM
 170+ C65B
 171+ C65B              InfinitePitchAndRoll:    MACRO
 172+ C65B ~                                    ld      a,$FF
 173+ C65B ~                                    ld      (UBnKRotXCounter),a
 174+ C65B ~                                    ld      (UBnKRotZCounter),a
 175+ C65B                                      ENDM
 176+ C65B
 177+ C65B              RandomUnivPitchAndRoll: MACRO
 178+ C65B ~                                    call    doRandom
 179+ C65B ~                                    or      %01101111
 180+ C65B ~                                    ld      (UBnKRotXCounter),a
 181+ C65B ~                                    call    doRandom
 182+ C65B ~                                    or      %01101111
 183+ C65B ~                                    ld      (UBnKRotZCounter),a
 184+ C65B                                      ENDM
 185+ C65B
 186+ C65B              RandomUnivSpeed:        MACRO
 187+ C65B ~                                    call    doRandom
 188+ C65B ~                                    and     31
 189+ C65B ~                                    ld      (UBnKSpeed),a
 190+ C65B                                      ENDM
 191+ C65B
 192+ C65B              MaxUnivSpeed:           MACRO
 193+ C65B ~                                    ld      a,31
 194+ C65B ~                                    ld      (UBnKSpeed),a
 195+ C65B                                      ENDM
 196+ C65B
 197+ C65B              ZeroUnivAccelleration:  MACRO
 198+ C65B ~                                    xor     a
 199+ C65B ~                                    ld      (UBnKAccel),a
 200+ C65B                                      ENDM
 201+ C65B
 202+ C65B 3A 4F C4     SetShipHostile:         ld      a,(ShipNewBitsAddr)
 203+ C65E F6 04                                or      ShipIsHostile
 204+ C660 32 4F C4                             ld      (ShipNewBitsAddr),a
 205+ C663 C9                                   ret
 206+ C664
 207+ C664 3A 4F C4     ClearShipHostile:       ld      a,(ShipNewBitsAddr)
 208+ C667 E6 FB                                and     ShipNotHostile
 209+ C669 32 4F C4                             ld      (ShipNewBitsAddr),a
 210+ C66C C9                                   ret
 211+ C66D
 212+ C66D                                      ; --------------------------------------------------------------
 213+ C66D              ; Sets visibile and not a dot
 214+ C66D 3A 94 C0     UnivVisibleNonDot:      ld      a,(UBnkaiatkecm)                ;  disable ship AI hostily and ECM
 215+ C670 F6 40                                or      ShipIsVisible
 216+ C672 E6 F7                                and     ShipIsNotDot
 217+ C674 32 94 C0                             ld      (UBnkaiatkecm),a                ;  .
 218+ C677 C9                                   ret
 219+ C678              ; --------------------------------------------------------------
 220+ C678              ; Sets visibile and  a dot
 221+ C678 3A 94 C0     UnivVisibleDot:         ld      a,(UBnkaiatkecm)                ;  disable ship AI hostily and ECM
 222+ C67B F6 48                                or      ShipIsVisible | ShipIsDot
 223+ C67D 32 94 C0                             ld      (UBnkaiatkecm),a                ;  .
 224+ C680 C9                                   ret
 225+ C681              ; --------------------------------------------------------------
 226+ C681              ; Sets invisibile
 227+ C681              UnivInvisible:          ClearMemBitN  UBnkaiatkecm  , ShipIsVisibleBitNbr ; Assume its hidden
 227+ C681 21 94 C0    >                        ld      hl,UBnkaiatkecm
 227+ C684 CB B6       >                        res     ShipIsVisibleBitNbr,(hl)
 228+ C686 C9                                   ret
 229+ C687              ; --------------------------------------------------------------
 230+ C687 21 00 C0     ResetUBnkData:          ld      hl,StartOfUniv
 231+ C68A 11 5B 06                             ld      de,UBnk_Data_len
 232+ C68D AF                                   xor     a
 233+ C68E CD 81 65                             call    memfill_dma
 234+ C691 C9                                   ret
 235+ C692              ; --------------------------------------------------------------
 236+ C692 21 20 C0     ResetUbnkPosition:      ld      hl,UBnKxlo
 237+ C695 06 09                                ld      b, 3*3
 238+ C697 AF                                   xor     a
 239+ C698 77           .zeroLoop:              ld      (hl),a
 240+ C699 23                                   inc     hl
 241+ C69A 10 FC                                djnz    .zeroLoop
 242+ C69C C9                                   ret
 243+ C69D
 244+ C69D              ;-- This takes an Axis and subtracts 1, handles leading sign and boundary of 0 going negative
 245+ C69D              JumpOffSet:             MACRO   Axis
 246+ C69D ~                                    ld      hl,(Axis)
 247+ C69D ~                                    ld      a,h
 248+ C69D ~                                    and     SignOnly8Bit
 249+ C69D ~                                    jr      nz,.NegativeAxis
 250+ C69D ~            .PositiveAxis:          dec     l
 251+ C69D ~                                    jp      m,.MovingNegative
 252+ C69D ~                                    jp      .Done
 253+ C69D ~            .NegativeAxis:          inc     l                               ; negative means increment the z
 254+ C69D ~                                    jp      .Done
 255+ C69D ~            .MovingNegative:        ld      hl,$8001                        ; -1
 256+ C69D ~            .Done                   ld      (Axis),hl
 257+ C69D                                      ENDM
 258+ C69D
 259+ C69D
 260+ C69D              WarpOffset:             JumpOffSet  UBnKzhi                     ; we will simplify on just moving Z
 260+ C69D 2A 27 C0    >                        ld      hl,(UBnKzhi)
 260+ C6A0 7C          >                        ld      a,h
 260+ C6A1 E6 80       >                        and     SignOnly8Bit
 260+ C6A3 20 07       >                        jr      nz,.NegativeAxis
 260+ C6A5 2D          >.PositiveAxis:          dec     l
 260+ C6A6 FA B0 C6    >                        jp      m,.MovingNegative
 260+ C6A9 C3 B3 C6    >                        jp      .Done
 260+ C6AC 2C          >.NegativeAxis:          inc     l                               ; negative means increment the z
 260+ C6AD C3 B3 C6    >                        jp      .Done
 260+ C6B0 21 01 80    >.MovingNegative:        ld      hl,$8001                        ; -1
 260+ C6B3 22 27 C0    >.Done                   ld      (UBnKzhi),hl
 261+ C6B6 C9                                   ret
 262+ C6B7
 263+ C6B7 44           WarpUnivByHL:           ld      b,h
 264+ C6B8 4D                                   ld      c,l
 265+ C6B9 26 00                                ld      h,0
 266+ C6BB ED 5B 27 C0                          ld      de,(UBnKzhi)
 267+ C6BF 3A 26 C0                             ld      a,(UBnKzlo)
 268+ C6C2 6F                                   ld      l,a
 269+ C6C3                                      MMUSelectMathsBankedFns
 269+ C6C3 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 269+ C6C7 CD 10 01       call  SubBCHfromDELsigned
 270+ C6CA ED 53 27 C0                          ld      (UBnKzhi),de
 271+ C6CE 7D                                   ld      a,l
 272+ C6CF 32 26 C0                             ld      (UBnKzlo),a
 273+ C6D2 C9                                   ret
 274+ C6D3
 275+ C6D3              ; --------------------------------------------------------------
 276+ C6D3              ; update ship speed and pitch based on adjustments from AI Tactics
 277+ C6D3 3A 87 C0     UpdateSpeedAndPitch:    ld      a,(UBnKAccel)                   ; only apply non zero accelleration
 278+ C6D6                                      JumpIfAIsZero .SkipAccelleration
 278+ C6D6 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 278+ C6D7 CA F5 C6    >                        jp	    z, .SkipAccelleration
 279+ C6DA 47                                   ld      b,a                             ; b = accelleration in 2's c
 280+ C6DB 3A 86 C0                             ld      a,(UBnKSpeed)                   ; a = speed + accelleration
 281+ C6DE                                      ClearCarryFlag
 281+ C6DE B7          >                        or a
 282+ C6DF 88                                   adc     a,b
 283+ C6E0                                      JumpIfPositive  .DoneAccelleration      ; if speed < 0
 283+ C6E0 F2 E4 C6    >                        jp		p, .DoneAccelleration
 284+ C6E3              .SpeedNegative:         ZeroA                                   ;    then speed = 0
 284+ C6E3 AF          >                        xor a
 285+ C6E4 47           .DoneAccelleration:     ld      b,a                             ; if speed > speed limit
 286+ C6E5 3A 47 C4                             ld      a,(SpeedAddr)                   ;    speed = limit
 287+ C6E8                                      JumpIfAGTENusng b, .SpeedInLimits       ; .
 287+ C6E8 B8          >                        cp     b
 287+ C6E9 D2 ED C6    >                        jp		nc,.SpeedInLimits
 288+ C6EC 47                                   ld      b,a                             ; .
 289+ C6ED 78           .SpeedInLimits:         ld      a,b                             ; .
 290+ C6EE 32 86 C0                             ld      (UBnKSpeed),a                   ; .
 291+ C6F1                                      ZeroA                                   ; acclleration = 0
 291+ C6F1 AF          >                        xor a
 292+ C6F2 32 87 C0                             ld      (UBnKAccel),a                   ; for next AI update
 293+ C6F5              .SkipAccelleration:     ; handle roll and pitch rates
 294+ C6F5 C9                                   ret
 295+ C6F6
 296+ C6F6
 297+ C6F6 CD 2F C7     UnivSetDemoPostion:     call    UnivSetSpawnPosition
 298+ C6F9 3E 81                                ld      a,%10000001                     ; AI Enabled has 1 missile
 299+ C6FB 32 94 C0                             ld      (UBnkaiatkecm),a                ; set hostinle, no AI, has ECM
 300+ C6FE 32 4F C4                             ld      (ShipNewBitsAddr),a             ; initialise new bits logic
 301+ C701 3E 00                                ld      a,0
 302+ C703 32 89 C0                             ld      (UBnKRotZCounter),a             ; no pitch
 303+ C706 32 88 C0                             ld      (UBnKRotXCounter),a             ; set roll to maxi on station
 304+ C709                                      ZeroA
 304+ C709 AF          >                        xor a
 305+ C70A 32 22 C0                             ld      (UBnKxsgn),a
 306+ C70D 32 25 C0                             ld      (UBnKysgn),a
 307+ C710 32 28 C0                             ld      (UBnKzsgn),a
 308+ C713 21 00 00                             ld      hl,0
 309+ C716 22 20 C0                             ld      (UBnKxlo),hl
 310+ C719 22 23 C0                             ld      (UBnKylo),hl
 311+ C71C 3A 4E C4                             ld      a,(ShipTypeAddr)
 312+ C71F 21 B0 05                             ld      hl,$05B0                            ; so its a negative distance behind
 313+ C722                                      JumpIfANENusng ShipTypeStation, .SkipFurther
 313+ C722 FE 02       >                        cp     ShipTypeStation
 313+ C724 C2 2B C7    >                        jp      nz,.SkipFurther
 314+ C727 3E 05                                ld      a,5
 315+ C729 84                                   add     h
 316+ C72A 67                                   ld      h,a
 317+ C72B 22 26 C0     .SkipFurther            ld      (UBnKzlo),hl
 318+ C72E C9                                   ret
 319+ C72F                  DISPLAY "Tracing 1", $
 320+ C72F              ; --------------------------------------------------------------
 321+ C72F              ; This sets the position of the current ship randomly, called after spawing
 322+ C72F              ; Spawns in withink 16 bit range so 24 bit friendly
 323+ C72F CD 8F C7     UnivSetSpawnPosition:   call    InitialiseOrientation
 324+ C732                                      RandomUnivPitchAndRoll
 324+ C732 CD 08 6B    >                        call    doRandom
 324+ C735 F6 6F       >                        or      %01101111
 324+ C737 32 88 C0    >                        ld      (UBnKRotXCounter),a
 324+ C73A CD 08 6B    >                        call    doRandom
 324+ C73D F6 6F       >                        or      %01101111
 324+ C73F 32 89 C0    >                        ld      (UBnKRotZCounter),a
 325+ C742 CD 08 6B                             call    doRandom                        ; set x lo and y lo to random
 326+ C745 32 20 C0     .setXlo:                ld      (UBnKxlo),a
 327+ C748 32 23 C0     .setYlo:                ld      (UBnKylo),a
 328+ C74B 0F           .setXsign:              rrca                                    ; rotate by 1 bit right
 329+ C74C 47                                   ld      b,a
 330+ C74D E6 80                                and     SignOnly8Bit
 331+ C74F 32 22 C0                             ld      (UBnKxsgn),a
 332+ C752 78           .setYSign:              ld      a,b                             ; get random back again
 333+ C753 0F                                   rrca                                    ; rotate by 1 bit right
 334+ C754 47                                   ld      b,a
 335+ C755 E6 80                                and     SignOnly8Bit                    ; and set y sign
 336+ C757 32 25 C0                             ld      (UBnKysgn),a
 337+ C75A CB 08        .setYHigh:              rrc     b                               ; as value is in b rotate again
 338+ C75C 78                                   ld      a,b                             ;
 339+ C75D E6 1F                                and     31                              ; set y hi to random 0 to 31
 340+ C75F 32 24 C0                             ld      (UBnKyhi),a                     ;
 341+ C762 CB 08        .setXHigh:              rrc     b                               ; as value is in b rotate again
 342+ C764 78                                   ld      a,b
 343+ C765 E6 1F                                and     31                              ; set x hi to random 0 to 31
 344+ C767 4F                                   ld      c,a                             ; save shifted into c as well
 345+ C768 32 21 C0                             ld      (UBnKxhi),a
 346+ C76B 3E 50        .setZHigh:              ld      a,80                            ; set z hi to 80 - xhi - yhi - carry
 347+ C76D 98                                   sbc     b
 348+ C76E 99                                   sbc     c
 349+ C76F 32 27 C0                             ld      (UBnKzhi),a
 350+ C772 3A 4E C4     .CheckIfBodyOrJunk:     ld      a,(ShipTypeAddr)
 351+ C775                                      ReturnIfAEqNusng ShipTypeJunk
 351+ C775 FE 03       >                        cp      ShipTypeJunk
 351+ C777 C8          >                        ret     z
 352+ C778                                      ReturnIfAEqNusng ShipTypeScoopable
 352+ C778 FE 04       >                        cp      ShipTypeScoopable
 352+ C77A C8          >                        ret     z
 353+ C77B 78                                   ld      a,b                             ; its not junk to set z sign
 354+ C77C 0F                                   rrca                                    ; as it can jump in
 355+ C77D E6 80                                and     SignOnly8Bit
 356+ C77F 32 28 C0                             ld      (UBnKzsgn),a
 357+ C782 C9                                   ret
 358+ C783                  ;Input: BC = Dividend, DE = Divisor, HL = 0
 359+ C783              ;Output: BC = Quotient, HL = Remainder
 360+ C783
 361+ C783              ; Initialiase data, iyh must equal slot number
 362+ C783              ;                   iyl must be ship type
 363+ C783              ;                   a  = current bank number
 364+ C783 01 62 00     UnivInitRuntime:        ld      bc,UBnKRuntimeSize
 365+ C786 21 40 C0                             ld      hl,UBnKStartOfRuntimeData
 366+ C789                                      ZeroA
 366+ C789 AF          >                        xor a
 367+ C78A 77           .InitLoop:              ld      (hl),a
 368+ C78B 23                                   inc     hl
 369+ C78C 10 FC                                djnz    .InitLoop
 370+ C78E C9                                   ret
 371+ C78F
 372+ C78F
 373+ C78F
 374+ C78F                                      include "../../Universe/Ships/InitialiseOrientation.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/InitialiseOrientation.asm
   1++C78F              ;  sidev = (1,  0,  0)  sidev = (&6000, 0, 0)
   2++C78F              ;  roofv = (0,  1,  0)  roofv = (0, &6000, 0)
   3++C78F              ;  nosev = (0,  0, -1)  nosev = (0, 0, &E000)   E000 = SignBit[96]
   4++C78F              InitialiseOrientation:
   5++C78F 21 00 00     ZI1:                    ld      hl, 0
   6++C792 22 2C C0                             ld      (UBnkrotmatSidevY),hl                ; set the zeroes
   7++C795 22 2E C0                             ld      (UBnkrotmatSidevZ),hl                ; set the zeroes
   8++C798 22 30 C0                             ld      (UBnkrotmatRoofvX),hl                ; set the zeroes
   9++C79B 22 34 C0                             ld      (UBnkrotmatRoofvZ),hl                ; set the zeroes
  10++C79E 22 36 C0                             ld      (UBnkrotmatNosevX),hl                ; set the zeroes
  11++C7A1 22 38 C0                             ld      (UBnkrotmatNosevY),hl                ; set the zeroes
  12++C7A4              ; Optimised as already have 0 in l
  13++C7A4 26 60                                ld      h, $60	             				; 96 in hi byte
  14++C7A6                                      ;ld      hl,1
  15++C7A6 22 2A C0                             ld      (UBnkrotmatSidevX),hl
  16++C7A9 22 32 C0                             ld      (UBnkrotmatRoofvY),hl
  17++C7AC              ; Optimised as already have 0 in l
  18++C7AC 26 E0                                ld      h, $E0					            ; -96 in hi byte which is +96 with hl bit 7 set
  19++C7AE 22 3A C0                             ld      (UBnkrotmatNosevZ),hl
  20++C7B1 C9                                   ret
  21++C7B2
  22++C7B2              InitialisePlayerMissileOrientation:
  23++C7B2 CD 8F C7                             call    InitialiseOrientation
  24++C7B5 21 00 60                             ld      hl,$6000
  25++C7B8 22 3A C0                             ld      (UBnkrotmatNosevZ),hl           ; mius
  26++C7BB C9                                   ret
  27++C7BC
  28++C7BC
  29++C7BC              ;  sidev = (1,  0,  0)  sidev = (&6000, 0, 0)
  30++C7BC              ;  roofv = (0,  1,  0)  roofv = (0, &6000, 0)
  31++C7BC              ;  nosev = (-0,  -0, 1) nosev = (0, 0, &6000)
  32++C7BC CD 8F C7     LaunchedOrientation:    call    InitialiseOrientation
  33++C7BF                                      FlipSignMem UBnkrotmatNosevX+1;  as its 0 flipping will make no difference
  33++C7BF 3A 37 C0    >                        ld  a,(UBnkrotmatNosevX+1)
  33++C7C2 EE 80       >                        xor SignOnly8Bit
  33++C7C4 32 37 C0    >                        ld  (UBnkrotmatNosevX+1),a
  34++C7C7                                      FlipSignMem UBnkrotmatNosevY+1;  as its 0 flipping will make no difference
  34++C7C7 3A 39 C0    >                        ld  a,(UBnkrotmatNosevY+1)
  34++C7CA EE 80       >                        xor SignOnly8Bit
  34++C7CC 32 39 C0    >                        ld  (UBnkrotmatNosevY+1),a
  35++C7CF                                      FlipSignMem UBnkrotmatNosevZ+1
  35++C7CF 3A 3B C0    >                        ld  a,(UBnkrotmatNosevZ+1)
  35++C7D2 EE 80       >                        xor SignOnly8Bit
  35++C7D4 32 3B C0    >                        ld  (UBnkrotmatNosevZ+1),a
  36++C7D7 C9                                   ret
  37++C7D8
# file closed: ../../Tests/3DTest/../../Universe/Ships/InitialiseOrientation.asm
 375+ C7D8
 376+ C7D8              ;--------------------------------------------------------------------------------------------------------
 377+ C7D8                                      INCLUDE "../../ModelRender/CLIP-LL145.asm"
# file opened: ../../Tests/3DTest/../../ModelRender/CLIP-LL145.asm
   1++C7D8              ;--------------------------------------------------------------------------------------------------------------------
   2++C7D8
   3++C7D8 00           clipDx                  DB      0           ; also XX12+2
   4++C7D9 00           clipDxHigh              DB      0           ; also XX12+3
   5++C7DA 00           clipDxHighNonABS        DB      0           ; also XX12+3
   6++C7DB 00           clipDy                  DB      0           ; also XX12+4
   7++C7DC 00           clipDyHigh              DB      0           ; also XX12+5
   8++C7DD 00           clipGradient            DB      0
   9++C7DE 00           clipDxySign             DB      0
  10++C7DF              varX12p3                equ     clipDxySign
  11++C7DF 00           clipXGTY                DB      0
  12++C7E0 00           clipFlags               DB      0
  13++C7E1 00           SWAP                    DB      0
  14++C7E2 00 00        varYX                   DW      0
  15++C7E4              ;varRegX                 DB      0
  16++C7E4              ;varXX12p2               DB      0
  17++C7E4 00           clipXX13                 DB      0
  18++C7E5 00           Gradient                DB      0
  19++C7E6              ; for start and end y. bit7 of lower determines its not been setup yet
  20++C7E6
  21++C7E6              ;--------------------------------------------------------------------------------------
  22++C7E6                      IFNDEF       CLIPVersion3
  23++C7E6 ED 4B E9 C0  ClipLine:               ld      bc,(UbnkPreClipY1)          ; bc - XX15(2,3) Y1
  24++C7EA DD 2A ED C0                          ld      ix,(UbnkPreClipY2)          ; ix - XX12(0,1) Y2
  25++C7EE 2A E7 C0                             ld      hl,(UbnkPreClipX1)          ; hl - XX15(0,1) X1
  26++C7F1 ED 5B EB C0                          ld      de,(UbnkPreClipX2)          ; de - XX15(4,5) X2
  27++C7F5 AF                                   xor     a
  28++C7F6 32 E1 C7                             ld      (SWAP),a                    ; SWAP = 0
  29++C7F9 7A                                   ld      a,d                         ; A = X2Hi
  30++C7FA FD 26 BF     .LL147:                 ld      iyh,$BF                     ; we need to be 191 as its 128 + another bit set from 0 to 6, we are using iyh as regX (128 will actually do)
  31++C7FD DD B4                                or      ixh                         ; if (X2Hi L-OR Y2 Hi <> 0) goto LL107             -- X2Y2 off screen
  32++C7FF 20 0A                                jr      nz, .LL107
  33++C801 DD 7D                                ld      a,ixl
  34++C803 ED 27 80                             test    $80                         ; if screen hight < y2 lo, i.e y2 lo >127 goto LL107,
  35++C806 20 03                                jr      nz,.LL107
  36++C808 FD 26 00                             ld      iyh, 0                      ; else iyh = regX = 0                                                                        -- X2Y2 on screen
  37++C80B              ; XX13 = regX (i.e. iyh)      ( if XX13 = XX13 is 191 if (x2, y2) is off-screen else 0) we bin XX13 as not needed
  38++C80B              ; so XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen,  XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lo is off the bottom of the screen
  39++C80B FD 7C        .LL107                  ld      a,iyh
  40++C80D 32 E4 C7                             ld      (clipXX13),a                ; debug copy iyh to xx13
  41++C810 7C                                   ld      a,h                         ; If (X1 hi L-OR Y1) hi  goto LL83                   -- X1Y1 off screen and maybe X2Y2
  42++C811 B0                                   or      b                           ;
  43++C812 20 27                                jr      nz,.LL83                    ;
  44++C814 79                                   ld      a,c                         ; or (y1 lo > bottom of screen)
  45++C815 ED 27 80                             test    $80                         ; i.e  screen height < y1)
  46++C818 20 21                                jr      nz,.LL83
  47++C81A              ; If we get here, (x1, y1) is on-screen
  48++C81A FD 7C                                ld      a,iyh                       ; iyh = xx13 at this point if  XX13 <> 0 goto LL108                                                        -- X1Y1 on screen, if we flagged X2Y2 off screen goto LL108
  49++C81C FE 00                                cp      0
  50++C81E 20 15                                jr      nz, .LL108
  51++C820              ; Finished clipping exit point ----------------------------------------------------------------------------------------
  52++C820 79           .ClipDone:              ld      a,c                         ; LL146 (Clip Done)               Y1 = y1 lo, x2 = x2 lo, x1 = x1 lo y1 = y1 lo                                   -- Nothing off screen
  53++C821 32 E8 C0                             ld      (UBnkNewY1),a
  54++C824 DD 7D                                ld      a,ixl
  55++C826 32 EA C0                             ld      (UBnkNewY2),a
  56++C829 7D                                   ld      a,l
  57++C82A 32 E7 C0                             ld      (UBnkNewX1),a
  58++C82D 7B                                   ld      a,e
  59++C82E 32 E9 C0                             ld      (UBnkNewX2),a
  60++C831                                      ClearCarryFlag                      ; carry is clear so valid to plot is in XX15(0to3)
  60++C831 B7          >                        or a
  61++C832 C9                                   ret                                 ; 2nd pro different, it swops based on swop flag around here.
  62++C833              ; Finished out of bounds exit point -----------------------------------------------------------------------------------
  63++C833              .PointsOutofBounds:     SetCarryFlag                        ; LL109 (ClipFailed) carry flag set as not visible
  63++C833 37          >                        scf
  64++C834 C9                                   ret
  65++C835 FD 7C        .LL108:                 ld      a,iyh
  66++C837 B7                                   or      a
  67++C838 1F                                   rra
  68++C839 FD 67                                ld      iyh,a                       ; (X2Y2 Off Screen)         XX13 = 95 (i.e. divide it by 2)                                                 -- X1Y1 on screen X2Y2 off screen
  69++C83B FD 7C        .LL83:                  ld      a,iyh                       ; (Line On screen Test)      if XX13 < 128 then only 1 point is on screen so goto LL115                      -- We only need to deal with X2Y2
  70++C83D ED 27 80                             test    $80                         ;
  71++C840 28 28                                jr      z, .LL115                   ;
  72++C842              ;                       Check for X1 and X2 negative
  73++C842 7C                                   ld      a,h                         ; If both x1_hi and x2_hi have bit 7 set, jump to LL109  to return from the subroutine with the C flag set, as the entire line is above the top of the screen
  74++C843 A2                                   and     d
  75++C844                                      JumpIfNegative  .PointsOutofBounds
  75++C844 FA 33 C8    >                        jp		m, .PointsOutofBounds
  76++C847              ;                       Check for Y1 and Y2 negative
  77++C847 78                                   ld      a,b                         ; If both y1_hi and y2_hi have bit 7 set, jump to LL109  to return from the subroutine with the C flag set, as the entire line is above the top of the screen
  78++C848 DD A4                                and     ixh
  79++C84A                                      JumpIfNegative  .PointsOutofBounds
  79++C84A FA 33 C8    >                        jp		m, .PointsOutofBounds
  80++C84D              ;                       Check for X1 and X2 both > 255
  81++C84D 7C                                   ld      a,h                         ; If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set, jump to LL109 to return from the subroutine with the C  flag set, as the line doesn't fit on-screen
  82++C84E 3D                                   dec     a
  83++C84F FD 6F                                ld      iyl,a                       ; using iyl as XX12+2 var
  84++C851 7A                                   ld      a,d                         ; a = x2 hi
  85++C852 3D                                   dec     a
  86++C853 FD B5                                or      iyl                         ; (x2 hi -1 ) or (x1 hi -1)
  87++C855                                      JumpIfPositive .PointsOutofBounds   ; if both x1 and x2hi were > 0 then subtracting 1 would result in 0..254 so either being negative means it was 0 before
  87++C855 F2 33 C8    >                        jp		p, .PointsOutofBounds
  88++C858              ; by here we have eliminated -ve Y1 bounds so can just test for positive high and bit 7 of lo
  89++C858 DD 7C                                ld      a,ixh
  90++C85A 3D                                   dec     a
  91++C85B FD 6F                                ld      iyl,a
  92++C85D 78                                   ld      a,b
  93++C85E 3D                                   dec     a
  94++C85F FD B5                                or      iyl
  95++C861                                      JumpIfPositive .PointsOutofBounds   ; if both x1 and x2hi were > 0 then subtracting 1 would result in 0..254 so either being negative means it was 0 before
  95++C861 F2 33 C8    >                        jp		p, .PointsOutofBounds
  96++C864 79                                   ld      a,c
  97++C865 DD A5                                and     ixl
  98++C867                                      JumpIfNegative .PointsOutofBounds   ; really if both are > 127
  98++C867 FA 33 C8    >                        jp		m, .PointsOutofBounds
  99++C86A              ; Clip line: calulate the line's gradient
 100++C86A              ; here as an optimisation we make sure X1 is always < X2  later on
 101++C86A              .LL115:                 ClearCarryFlag
 101++C86A B7          >                        or a
 102++C86B E5 D5        .CalcDX:                push    hl,,de
 103++C86D EB                                   ex      hl,de                       ; so hl is x2 and de = x1
 104++C86E ED 52                                sbc     hl,de
 105++C870 22 D8 C7                             ld      (clipDx),hl
 106++C873 7C                                   ld      a,h
 107++C874 32 DA C7                             ld      (clipDxHighNonABS),a
 108++C877              .CalcDy:                ClearCarryFlag
 108++C877 B7          >                        or a
 109++C878 DD E5 E1                             ld      hl,ix
 110++C87B ED 42                                sbc     hl,bc
 111++C87D 54 5D                                ld      de,hl           ;;OPTIMISATION 6/11/21
 112++C87F 22 DB C7                             ld      (clipDy),hl     ;OPTIMISATION 6/11/21 commented out
 113++C882 7C           .CalcQuadrant:          ld      a,h
 114++C883 32 DC C7                             ld      (clipDyHigh),a              ; so A = sign of deltay in effect
 115++C886              ; So we now have delta_x in XX12(3 2), delta_y in XX12(5 4)  where the delta is (x1, y1) - (x2, y2))
 116++C886 21 D9 C7                             ld      hl,clipDxHigh
 117++C889 AE                                   xor     (hl)                        ; now a = sign dx xor sign dy
 118++C88A 32 07 67                             ld      (varS),a                    ; DEBGU putting it in var S too for now
 119++C88D 32 DE C7                             ld      (clipDxySign),a
 120++C890 3A DC C7     .AbsDy:                 ld      a,(clipDyHigh)
 121++C893 ED 27 80                             test    $80
 122++C896 28 0E                                jr      z,.LL110                    ; If delta_y_hi is positive, jump down to LL110 to skip the following
 123++C898 ED 5B DB C7                          ld      de,(clipDy)                 ;OPTIMISATION 6/11/21 commented out
 124++C89C                                      macronegate16de                     ; Otherwise flip the sign of delta_y to make it  positive, starting with the low bytes
 124++C89C AF          >					xor 	a
 124++C89D 93          >                    sub 	e
 124++C89E 5F          >                    ld 		e,a
 124++C89F 9F          >                    sbc 	a,a
 124++C8A0 92          >                    sub 	d
 124++C8A1 57          >                    ld 		d,a
 125++C8A2 ED 53 DB C7                          ld      (clipDy),de                 ;OPTIMISATION 6/11/21 commented out
 126++C8A6 2A D8 C7     .LL110:                 ld      hl,(clipDx)
 127++C8A9 3A D9 C7                             ld      a,(clipDxHigh)
 128++C8AC ED 27 80                             test    $80                         ; is it a negative X
 129++C8AF 28 06                                jr      z,.LL111                    ; If delta_x_hi is positive, jump down to LL110 to skip the following
 130++C8B1                                      ;ld      hl,(clipDx)                 ;OPTIMISATION 6/11/21 commented out
 131++C8B1                                      macronegate16hl                     ; Otherwise flip the sign of delta_y to make it  positive, starting with the low bytes
 131++C8B1 AF          >					xor 	a
 131++C8B2 95          >					sub 	l
 131++C8B3 6F          >					ld 		l,a
 131++C8B4 9F          >					sbc 	a,a
 131++C8B5 94          >					sub 	h
 131++C8B6 67          >					ld 		h,a
 132++C8B7              .LL111:
 133++C8B7 7C           .ScaleLoop:             ld      a,h                         ; At this point DX and DY are ABS values
 134++C8B8 B2                                   or      d
 135++C8B9 28 0A                                jr      z,.CalculateDelta
 136++C8BB                                      ShiftDERight1
 136++C8BB CB 3A       >               srl d
 136++C8BD CB 1B       >               rr  e
 137++C8BF                                      ShiftHLRight1
 137++C8BF CB 3C       >               srl h
 137++C8C1 CB 1D       >               rr  l
 138++C8C3 18 F2                                jr      .ScaleLoop                  ; scaled down Dx and Dy to 8 bit, Dy may have been negative
 139++C8C5              .CalculateDelta:
 140++C8C5              ; By now, the high bytes of both |delta_x| and |delta_y| are zero We know that h and d are both = 0 as that's what we tested with a BEQ
 141++C8C5 AF           .LL113:                 xor     a
 142++C8C6 32 21 67                             ld      (varT),a                    ; t = 0
 143++C8C9 7D                                   ld      a,l                         ; If delta_x_lo < delta_y_lo, so our line is more vertical than horizontal, jump to LL114
 144++C8CA                                      JumpIfALTNusng  e, .LL114           ;
 144++C8CA BB          >                        cp      e
 144++C8CB DA DB C8    >                        jp		c, .LL114
 145++C8CE              ; Here Dx >= Dy sp calculate Delta Y / delta X
 146++C8CE 32 05 67     .DxGTEDy:               ld      (varQ),a                    ; Set Q = delta_x_lo
 147++C8D1 57                                   ld      d,a                         ; d = also Q for calc
 148++C8D2 7B                                   ld      a,e                         ; Set A = delta_y_lo
 149++C8D3 CD 96 6F                             call    AEquAmul256DivD; LL28Amul256DivD             ; Call LL28 to calculate:  R (actually a reg) = 256 * A / Q   = 256 * delta_y_lo / delta_x_lo
 150++C8D6 32 06 67                             ld      (varR),a                    ;
 151++C8D9 18 10                                jr      .LL116                      ; Jump to LL116, as we now have the line's gradient in R
 152++C8DB              ; Here Delta Y > Delta X so calulate delta X / delta Y
 153++C8DB 7B           .LL114:                 ld      a,e                         ; Set Q = delta_y_lo
 154++C8DC 57                                   ld      d,a
 155++C8DD 32 05 67                             ld      (varQ),a
 156++C8E0 7D                                   ld      a,l                         ; Set A = delta_x_lo
 157++C8E1 CD 96 6F                             call    AEquAmul256DivD; LL28Amul256DivD             ; Call LL28 to calculate: R = 256 * A / Q  = 256 * delta_x_lo / delta_y_lo
 158++C8E4 32 06 67                             ld      (varR),a                    ;
 159++C8E7 21 21 67                             ld      hl,varT                     ; T was set to 0 above, so this sets T = &FF
 160++C8EA 35                                   dec     (hl)
 161++C8EB D1           .LL116:                 pop     de                          ; get back X2
 162++C8EC E1                                   pop     hl                          ; get back X1 into hl,
 163++C8ED 3A 06 67                             ld      a,(varR)                    ; Store the gradient in XX12+2 this can be optimised later
 164++C8F0 32 DD C7                             ld      (clipGradient),a
 165++C8F3 FD 6F                                ld      iyl,a
 166++C8F5 3A 07 67                             ld      a,(varS)
 167++C8F8 32 DE C7                             ld      (clipDxySign),a             ;  Store the type of slope in XX12+3, bit 7 clear means ?Not needed as clipDxySign is used for varS earlier?
 168++C8FB                                                                          ; top left to bottom right, bit 7 set means top right to bottom left **CODE IS WRONG HERE A TEST IS BL to TR
 169++C8FB FD 7C                                ld      a,iyh                       ; iyh was XX13 from earlier
 170++C8FD FE 00                                cp      0                           ; If XX13 = 0, skip the following instruction
 171++C8FF 28 05                                jr      z,.LL138                    ;
 172++C901 ED 27 80                             test    $80                         ; If XX13 is positive, it must be 95. This means (x1, y1) is on-screen but (x2, y2) isn't, so we jump to LLX117 to swap the (x1, y1) and (x2, y2)
 173++C904 28 13                                jr      z,.LLX117                   ; coordinates around before doing the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
 174++C906              ; If we get here, XX13 = 0 or 191, so (x1, y1) is off-screen and needs clipping
 175++C906 CD 2D C9     .LL138                  call    ClipPointHLBC               ; Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 176++C909 FD 7C                                ld      a,iyh                       ; If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to LL124 to return with a successfully clipped line
 177++C90B ED 27 80                             test    $80
 178++C90E 28 1A                                jr      z,.LL124
 179++C910              ; If we get here, XX13 = 191 (both coordinates are off-screen)
 180++C910 7C           .LL117:                 ld      a,h                         ; If either of x1_hi or y1_hi are non-zero, jump to
 181++C911 B0                                   or      b                           ; LL137 to return from the subroutine with the C flag
 182++C912 C2 33 C8                             jp      nz, .PointsOutofBounds      ; set, as the line doesn't fit on-screen
 183++C915 B1                                   or      c                           ; if x1 and y1 hi are both zero test bit 8 or Y1 to see if its > 128
 184++C916 FA 33 C8                             jp      m, .PointsOutofBounds       ; set, as the line doesn't fit on-screen
 185++C919              ; If we get here, XX13 = 95 or 191, and in both cases (x2, y2) is off-screen, so we now need to swap the (x1, y1) and (x2, y2) coordinates around before doing
 186++C919              ; the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
 187++C919 EB           .LLX117:                ex      de,hl                       ;  swap X1 and X2
 188++C91A DD E5                                push    ix                          ;  swap Y1 and Y2
 189++C91C C5                                   push    bc
 190++C91D DD E1                                pop     ix
 191++C91F C1                                   pop     bc
 192++C920 CD 2D C9                             call    ClipPointHLBC               ;  Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 193++C923 3A E1 C7                             ld      a,(SWAP)
 194++C926 3D                                   dec     a
 195++C927 32 E1 C7                             ld      (SWAP),a                    ; Set SWAP = &FF to indicate that we just clipped the line at the (x2, y2) end by swapping the coordinates (the DEC does this as we set SWAP to 0 at the start of this subroutine)
 196++C92A C3 20 C8     .LL124:                 jp      .ClipDone                    ; now put points in place
 197++C92D              ; Move a point along a line until it is on-screen point is held in HL(X) BC(Y) LL118
 198++C92D              ; iyh still holds XX13 iyl still holds gradient
 199++C92D 7C           ClipPointHLBC:          ld      a,h                         ; If x1_hi is positive, jump down to LL119 to skip the following
 200++C92E ED 27 80                             test    $80
 201++C931 28 17                                jr      z,.LL119
 202++C933 32 07 67     .X1isNegative:          ld      (varS),a                    ;  Otherwise x1_hi is negative, i.e. off the left of the screen, so set S = x1_hi
 203++C936 E5 D5 C5                             push    hl,,de,,bc
 204++C939 CD AF C9                             call    LL120                       ;  Call LL120 to calculate:   (Y X) = (S x1_lo) * XX12+2      if T = 0   = x1 * gradient
 205++C93C                                                                          ;                             (Y X) = (S x1_lo) / XX12+2      if T <> 0  = x1 / gradient
 206++C93C                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
 207++C93C C1 D1 E1                             pop    hl,,de,,bc                   ;  get coordinates back
 208++C93F 2A E2 C7                             ld      hl,(varYX)
 209++C942 09                                   add     hl,bc                       ; y1 = y1 + varYX
 210++C943 44 4D                                ld      bc,hl
 211++C945 21 00 00                             ld      hl,0                        ; Set x1 = 0
 212++C948 18 1A                                jr      .LL134                      ; in BBC is set x to 0 to force jump, we will just jump
 213++C94A FE 00        .LL119:                 cp      0
 214++C94C 28 16                                jr      z,.LL134                    ;  If x1_hi = 0 then jump down to LL134 to skip the following, as the x-coordinate is already on-screen (as 0 <= (x_hi x_lo) <= 255)
 215++C94E 3D                                   dec     a
 216++C94F 32 07 67                             ld      (varS),a                    ;  Otherwise x1_hi is positive, i.e. x1 >= 256 and off the right side of the screen, so set S = x1_hi - 1
 217++C952 E5 D5 C5                             push    hl,,de,,bc
 218++C955 CD AF C9                             call    LL120                      ;  Call LL120 to calculate: (Y X) = (S x1_lo) * XX12+2      if T = 0  = (x1 - 256) * gradient
 219++C958                                                                          ;                           (Y X) = (S x1_lo) / XX12+2      if T <> 0 = (x1 - 256) / gradient
 220++C958                                                                          ;  with the sign of (Y X) set to the opposite of theline's direction of slope
 221++C958 C1 D1 E1                             pop     hl,,de,,bc
 222++C95B 2A E2 C7                             ld      hl,(varYX)
 223++C95E 09                                   add     hl,bc                        ;OPTIMISATION 6/11/21 simplfied post debug
 224++C95F 44 4D                                ld      bc,hl                        ;OPTIMISATION 6/11/21 simplfied post debug
 225++C961 21 FF 00                             ld      hl,255                      ; Set x1 = 255
 226++C964              ; We have moved the point so the x-coordinate is on screen (i.e. in the range 0-255), so now for they-coordinate
 227++C964 78           .LL134:                 ld      a,b                         ; If y1_hi is positive, jump down to LL135  to skip the following
 228++C965 ED 27 80                             test    $80                         ;
 229++C968 28 1A                                jr      z,.LL135                    ;
 230++C96A 32 07 67                             ld      (varS),a                    ; Otherwise y1_hi is negative, i.e. off the top of the screen, so set S = y1_hi
 231++C96D 79                                   ld      a,c                         ; Set R = y1_lo
 232++C96E 32 06 67                             ld      (varR),a                    ;
 233++C971 E5 D5 C5                             push    hl,,de,,bc
 234++C974 CD 10 CA                             call    LL123                       ;  Call LL123 to calculate: (Y X) = (S R) / XX12+2      if T = 0  = y1 / gradient
 235++C977                                                                          ;                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
 236++C977                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
 237++C977 C1 D1 E1                             pop     hl,,de,,bc
 238++C97A D5                                   push    de
 239++C97B EB                                   ex      hl,de                       ; de = x1
 240++C97C 2A E2 C7                             ld      hl,(varYX)                  ; hl = varYX
 241++C97F 19                                   add     hl,de                       ; we don't need to swap back as its an add, Set x1 = x1 + (Y X)
 242++C980 D1                                   pop     de                          ; de = x2 again
 243++C981 01 00 00                             ld      bc,0                        ; Set y1 = 0
 244++C984 79           .LL135:                 ld      a,c                         ; if bc < 128 then no work to do
 245++C985 E6 80                                and     $80
 246++C987 B0                                   or      b                           ; here we see if c bit 8 is set or anything in b as we know if its 0 this would mean there is no need to clip
 247++C988 C8                                   ret     z
 248++C989 E5                                   push    hl
 249++C98A 60 69                                ld      hl,bc
 250++C98C 01 80 00                             ld      bc,128
 251++C98F B7                                   or      a
 252++C990 ED 42                                sbc     hl,bc                       ; hl =  (S R) = (y1_hi y1_lo) - 128
 253++C992 22 06 67                             ld      (varRS), hl                 ; and now RS (or SR)
 254++C995 7C                                   ld      a,h
 255++C996 E1                                   pop     hl
 256++C997 ED 27 80                             test    $80                         ; If the subtraction underflowed, i.e. if y1 < 192, then y1 is already on-screen, so jump to LL136 to return from the subroutine, as we are done
 257++C99A C0                                   ret     nz
 258++C99B              ; If we get here then y1 >= 192, i.e. off the bottom of the screen
 259++C99B E5 D5 C5     .LL139:                 push    hl,,de,,bc
 260++C99E CD 10 CA                             call    LL123                       ;  Call LL123 to calculate: (Y X) = (S R) / XX12+2      if T = 0  = y1 / gradient
 261++C9A1                                                                          ;                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
 262++C9A1                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
 263++C9A1 C1 D1 E1                             pop     hl,,de,,bc
 264++C9A4 D5                                   push    de
 265++C9A5 EB                                   ex      hl,de
 266++C9A6 2A E2 C7                             ld      hl,(varYX)
 267++C9A9 19                                   add     hl,de                       ; we don't need to swap back as its an add, Set x1 = x1 + (Y X)
 268++C9AA 01 7F 00                             ld      bc,127                      ; set bc to 127 bottom of screen
 269++C9AD D1                                   pop     de
 270++C9AE C9           .LL136:                 ret                                 ;  Return from the subroutine
 271++C9AF                      ENDIF
 272++C9AF
 273++C9AF              ; Calculate the following:   * If T = 0  (more vertical than horizontal), (Y X) = (S x1_lo) * XX12+2
 274++C9AF              ;                            * If T <> 0 (more horizontal than vertical), (Y X) = (S x1_lo) / XX12+2
 275++C9AF              ;                              giving (Y X) the opposite sign to the slope direction in XX12+3.
 276++C9AF              ; Other entry points        LL122                Calculate (Y X) = (S R) * Q and set the sign to the opposite of the top byte on the stack
 277++C9AF 7D           LL120:                  ld      a,l                          ; Set R = x1_lo
 278++C9B0 32 06 67                             ld      (varR),a
 279++C9B3 CD 6D CA                             call    LL129                        ;  Call LL129 to do the following:  Q = XX12+2   = line gradient  A = S EOR XX12+3 = S EOR slope direction (S R) = |S R| So A contains the sign of S * slope direction
 280++C9B6 F5                                   push    af                           ;  Store A on the stack so we can use it later
 281++C9B7 C5                                   push    bc
 282++C9B8 47                                   ld      b,a
 283++C9B9 3A 21 67                             ld      a,(varT)                     ; instead : (Y X) = (S R ) / Q
 284++C9BC FE 00                                cp      0
 285++C9BE 78                                   ld      a,b
 286++C9BF C1                                   pop     bc                           ; we can't use af as that would disrupt the flags
 287++C9C0 C2 D7 C9                             jp      nz, .LL121
 288++C9C3              ; The following calculates:  (Y X) = (S R) * Q using the same shift-and-add algorithm that's documented in MULT1
 289++C9C3 3A DD C7     .LL122:                  ld      a,(clipGradient)
 290++C9C6 32 05 67                             ld      (varQ),a; optimise
 291++C9C9 CD F4 6B                             call    HLequSRmulQdiv256
 292++C9CC 22 E2 C7                             ld      (varYX),hl
 293++C9CF F1                                   pop     af
 294++C9D0 ED 27 80                             test    $80
 295++C9D3 CA 03 CA                             jp      z,.LL133
 296++C9D6 C9                                   ret
 297++C9D7 11 FE FF     .LL121:                  ld      de,$FFFE                    ; set XY to &FFFE at start, de holds XY
 298++C9DA 2A 06 67                             ld      hl,(varRS)                  ; hl = RS
 299++C9DD 3A 05 67                             ld      a,(varQ)
 300++C9E0 47                                   ld      b,a                         ; b = q
 301++C9E1              .LL130:                 ShiftHLLeft1                        ; RS *= 2
 301++C9E1 CB 25       >               sla l
 301++C9E3 CB 14       >               rl  h
 302++C9E5 7C                                   ld      a,h
 303++C9E6 38 04                                jr      c,.LL131                    ; if S overflowed skip Q test and do subtractions
 304++C9E8                                      JumpIfALTNusng b, .LL132            ; if S <  Q = 256/gradient skip subtractions
 304++C9E8 B8          >                        cp      b
 304++C9E9 DA F4 C9    >                        jp		c, .LL132
 305++C9EC 3F           .LL131:                 ccf                                 ; compliment carry
 306++C9ED 98                                   sbc     a,b                         ; q
 307++C9EE 67                                   ld      h,a                         ; h (s)
 308++C9EF 7D                                   ld      a,l                         ; r
 309++C9F0 DE 00                                sbc     a,0                         ; 0 - so in effect SR - Q*256
 310++C9F2 37                                   scf                                 ; set carry for next rolls
 311++C9F3 3F                                   ccf
 312++C9F4              .LL132:                 RollDELeft1                         ; Rotate de bits left
 312++C9F4 CB 13       >               rl  e
 312++C9F6 CB 12       >               rl  d
 313++C9F8 38 E7                                jr      c,.LL130                    ;
 314++C9FA ED 53 E2 C7                          ld      (varYX),de
 315++C9FE F1                                   pop     af              ; get back sign
 316++C9FF ED 27 80                             test    $80
 317++CA02 C8                                   ret     z               ; if negative then return with value as is reversed sign
 318++CA03 2A E2 C7     .LL133:                 ld      hl,(varYX)      ; may not actually need this?
 319++CA06                                      NegHL
 319++CA06 AF          >                    xor a
 319++CA07 95          >                    sub l
 319++CA08 6F          >                    ld l,a
 319++CA09 9F          >                    sbc a,a
 319++CA0A 94          >                    sub h
 319++CA0B 67          >                    ld h,a
 320++CA0C 22 E2 C7                             ld      (varYX),hl
 321++CA0F C9           .LL128:                 ret
 322++CA10
 323++CA10
 324++CA10
 325++CA10
 326++CA10              ; Calculate the following: * If T = 0,  calculate (Y X) = (S R) / XX12+2 (actually SR & XX12+2 /256)
 327++CA10              ;                          * If T <> 0, calculate (Y X) = (S R) * XX12+2
 328++CA10              ;                          giving (Y X) the opposite sign to the slope direction in XX12+3.
 329++CA10              ;
 330++CA10              ; Other entry points:      LL121                Calculate (Y X) = (S R) / Q and set the sign to the opposite of the top byte on the stack
 331++CA10              ;                          LL133                Negate (Y X) and return from the subroutine
 332++CA10              ;                          LL128                Contains an RTS
 333++CA10 CD 6D CA     LL123:                  call    LL129                       ; Call LL129 to do the following: Q = XX12+2   = line gradient  A = S EOR XX12+3 = S EOR slope direction (S R) = |S R| So A contains the sign of S * slope direction
 334++CA13 F5                                   push    af                          ; Store A on the stack so we can use it later
 335++CA14 C5                                   push    bc                          ; If T is non-zero, so it's more horizontal than vertical, jump down to LL121 to calculate this
 336++CA15 47                                   ld      b,a
 337++CA16 3A 21 67                             ld      a,(varT)                    ; instead : (Y X) = (S R) * Q *** this looks to be the wrong way roudn for Y!!!!
 338++CA19 FE 00                                cp      0
 339++CA1B 78                                   ld      a,b
 340++CA1C C1                                   pop     bc
 341++CA1D C2 59 CA                             jp      nz, .LL122
 342++CA20              ; The following calculates: (Y X) = (S R) / Q using the same shift-and-subtract algorithm that's documented in TIS2, its actually X.Y=R.S*256/Q
 343++CA20 11 FE FF     .LL121:                 ld      de,$FFFE                    ; set XY to &FFFE at start, de holds XY
 344++CA23 2A 06 67                             ld      hl,(varRS)                  ; hl = RS
 345++CA26 3A 05 67                             ld      a,(varQ)
 346++CA29 47                                   ld      b,a                         ; b = q
 347++CA2A              .LL130:                 ShiftHLLeft1                        ; RS *= 2
 347++CA2A CB 25       >               sla l
 347++CA2C CB 14       >               rl  h
 348++CA2E 7C                                   ld      a,h
 349++CA2F 38 04                                jr      c,.LL131                    ; if S overflowed skip Q test and do subtractions
 350++CA31                                      JumpIfALTNusng b, .LL132            ; if S <  Q = 256/gradient skip subtractions
 350++CA31 B8          >                        cp      b
 350++CA32 DA 3D CA    >                        jp		c, .LL132
 351++CA35 3F           .LL131:                 ccf                                 ; compliment carry
 352++CA36 98                                   sbc     a,b                         ; q
 353++CA37 67                                   ld      h,a                         ; h (s)
 354++CA38 7D                                   ld      a,l                         ; r
 355++CA39 DE 00                                sbc     a,0                         ; 0 - so in effect SR - Q*256
 356++CA3B 37                                   scf                                 ; set carry for next rolls
 357++CA3C 3F                                   ccf
 358++CA3D              .LL132:                 RollDELeft1                         ; Rotate de bits left
 358++CA3D CB 13       >               rl  e
 358++CA3F CB 12       >               rl  d
 359++CA41 38 E7                                jr      c,.LL130                    ;
 360++CA43 ED 53 E2 C7                          ld      (varYX),de
 361++CA47 F1                                   pop     af              ; get back sign
 362++CA48 ED 27 80                             test    $80
 363++CA4B C8                                   ret     z               ; if negative then return with value as is reversed sign
 364++CA4C 2A E2 C7     .LL133:                 ld      hl,(varYX)      ; may not actually need this?
 365++CA4F                                      NegHL
 365++CA4F AF          >                    xor a
 365++CA50 95          >                    sub l
 365++CA51 6F          >                    ld l,a
 365++CA52 9F          >                    sbc a,a
 365++CA53 94          >                    sub h
 365++CA54 67          >                    ld h,a
 366++CA55 22 E2 C7                             ld      (varYX),hl
 367++CA58 C9           .LL128:                 ret
 368++CA59              ; The following calculates:  (Y X) = (S R) * Q using the same shift-and-add algorithm that's documented in MULT1
 369++CA59 3A DD C7     .LL122:                 ld      a,(clipGradient)
 370++CA5C 32 05 67                             ld      (varQ),a; optimise
 371++CA5F CD F4 6B                             call    HLequSRmulQdiv256
 372++CA62 22 E2 C7                             ld      (varYX),hl
 373++CA65 F1                                   pop     af
 374++CA66 ED 27 80                             test    $80
 375++CA69 CA 4C CA                             jp      z,.LL133
 376++CA6C C9                                   ret
 377++CA6D
 378++CA6D              ; Do the following, in this order:  Q = XX12+2
 379++CA6D              ;                                   A = S EOR XX12+3
 380++CA6D              ;                                   (S R) = |S R|
 381++CA6D              ; This sets up the variables required above to calculate (S R) / XX12+2 and give the result the opposite sign to XX13+3.
 382++CA6D 3A DD C7     LL129:                  ld      a,(clipGradient)
 383++CA70 32 05 67                             ld      (varQ),a                    ; Set Q = XX12+2
 384++CA73 3A 07 67                             ld      a,(varS)                    ; If S is positive, jump to LL127
 385++CA76 E5 F5                                push    hl,,af                      ; else
 386++CA78 ED 27 80                             test    $80                         ;   if bit 7 is clear
 387++CA7B 28 0C                                jr      z,.LL127                    ;      RS = ABS RS
 388++CA7D 2A 06 67                             ld      hl,(varRS)                  ;      .
 389++CA80                                      NegHL                               ;      .
 389++CA80 AF          >                    xor a
 389++CA81 95          >                    sub l
 389++CA82 6F          >                    ld l,a
 389++CA83 9F          >                    sbc a,a
 389++CA84 94          >                    sub h
 389++CA85 67          >                    ld h,a
 390++CA86 22 06 67                             ld      (varRS),hl                  ;      .
 391++CA89 21 DE C7     .LL127:                 ld      hl,clipDxySign              ;   hl = dxy sign
 392++CA8C F1                                   pop     af                          ;
 393++CA8D AE                                   xor     (hl)                        ; a = S XOR clipDxySign
 394++CA8E E1                                   pop     hl
 395++CA8F C9                                   ret
 396++CA90
 397++CA90              ;--------------------------------------------------------------------------------------
 398++CA90              ; Thow away out of bounds by more than 250
 399++CA90              ClipLineV3:             ;break
 400++CA90                      IFDEF       CLIPVersion3
 401++CA90 ~            ;My logic version
 402++CA90 ~            .CheckYorder:
 403++CA90 ~                                    ld      hl,(UbnkPreClipY1)
 404++CA90 ~                                    ld      de,(UbnkPreClipY2)
 405++CA90 ~                                    call    CompareHLDESgn
 406++CA90 ~                                    jr      c,.LineP1toP2                          ; if Y1 < Y2 then we can use the points as is else we have to swap
 407++CA90 ~            .LineP2toP1:            ld      bc,(UbnkPreClipY2)                      ; fetch and write out in reverse
 408++CA90 ~                                    ld      ix,(UbnkPreClipY1)
 409++CA90 ~                                    ld      de,(UbnkPreClipX1)
 410++CA90 ~                                    ld      hl,(UbnkPreClipX2)
 411++CA90 ~                                    ld      (UbnkPreClipY1),bc                      ; bc - XX15(2,3) Y1
 412++CA90 ~                                    ld      (UbnkPreClipY2),ix                      ; ix - XX12(0,1) Y2
 413++CA90 ~                                    ld      (UbnkPreClipX1),hl                      ; hl - XX15(0,1) X1
 414++CA90 ~                                    ld      (UbnkPreClipX2),de                      ;  de - XX15(4,5) X2
 415++CA90 ~                                    jp      .CheckNoClip
 416++CA90 ~            .LineP1toP2             ld      bc,(UbnkPreClipY1)                      ; bc - XX15(2,3) Y1
 417++CA90 ~                                    ld      ix,(UbnkPreClipY2)                      ; ix - XX12(0,1) Y2
 418++CA90 ~                                    ld      hl,(UbnkPreClipX1)                      ; hl - XX15(0,1) X1
 419++CA90 ~                                    ld      de,(UbnkPreClipX2)                      ; de - XX15(4,5) X2
 420++CA90 ~            .CheckNoClip:           ld      a,b
 421++CA90 ~                                    or      d
 422++CA90 ~                                    or      h
 423++CA90 ~                                    or      ixh
 424++CA90 ~                                    jp      nz,.CheckXOffScreen                 ; if both Y1 and y2 have bit 7 set
 425++CA90 ~                                    ld      a,c                                 ; then we clip
 426++CA90 ~                                    and     ixl
 427++CA90 ~                                    test    $80
 428++CA90 ~                                    jp      z, .ClipComplete
 429++CA90 ~            ;if either x1hi x2hi are 0 then we clip. if both <> 0and both same sign exit
 430++CA90 ~            .CheckXOffScreen:       ld      a,h
 431++CA90 ~                                    xor     d
 432++CA90 ~                                    test    $80                                 ; non descructive test of bit 7 is set
 433++CA90 ~                                    jp      nz,.X1X2OppositeSign                ; if bit 7 was set then x1 and x2 must be opposite signs so its on screen
 434++CA90 ~            .X1X2SameSigns:         ld      a,h                                 ; so to get there h and d must be the same sign
 435++CA90 ~                                    test    $80                                 ; if they are the same sign and at x1 is negative then x2 must be negative so off screen
 436++CA90 ~                                    JumpIfAIsZero .X1X2CheckIfBothRight
 437++CA90 ~            .X1X2BothNegative:      SetCarryFlag                                ; to get to here x1 and x2 must be high and off the same sign so its not to draw
 438++CA90 ~                                    ret
 439++CA90 ~            .X1X2CheckIfBothRight:  and     a                                   ; we have h in a already
 440++CA90 ~                                    jr      z,.X1OnScreen
 441++CA90 ~                                    ld      a,d
 442++CA90 ~                                    and     a
 443++CA90 ~                                    jr      z,.X2OnScreen
 444++CA90 ~            .X1X2OffRightSide:      SetCarryFlag                                ; to get to here x1 and x2 must be high and off the same sign so its not to draw
 445++CA90 ~                                    ret
 446++CA90 ~            ;                       to get to here x1 and x2 either span -ve to +ve or from on screen to off screen
 447++CA90 ~            .X1OnScreen:
 448++CA90 ~            .X2OnScreen:
 449++CA90 ~            .X1X2OppositeSign:
 450++CA90 ~            ;                       Now check to see if Y is off screen
 451++CA90 ~            .CheckYOffScreen:       ld      a,b                                     ; Check if y1 and y2 are opposite signs, fi so it spans screen so we are good
 452++CA90 ~            .CheckBothYNegative:    xor     ixh
 453++CA90 ~                                    test    $80                                     ; if bit 7 is set then opposite signs
 454++CA90 ~                                    jp      nz,.Y1Y2OppositeSign                    ; if y1 and y2 are opposite signs its on screen and spans at least one side
 455++CA90 ~            .Y1Y2SameSign:          ld      a,b                                     ; if they are the same sign then if one is negative, so is the other so off screen
 456++CA90 ~                                    test    $80
 457++CA90 ~                                    jp      z,.Y1Y2Positive
 458++CA90 ~            .Y1Y2Negative:          SetCarryFlag
 459++CA90 ~                                    ret
 460++CA90 ~            .Y1Y2Positive:          ld      a,c                                     ; if its the same sign y1 or y2 could be 0 and if they are
 461++CA90 ~                                    and     $80                                     ; this will test to see if b >0 or c > 127
 462++CA90 ~                                    or      b                                       ;
 463++CA90 ~                                    jp      z,.Y1OnScreen
 464++CA90 ~                                    ld      a,ixl
 465++CA90 ~                                    and     $80
 466++CA90 ~                                    or      ixh
 467++CA90 ~                                    jp      z,.Y2OnScreen
 468++CA90 ~            .Y1Y2OffBottomSide:     SetCarryFlag
 469++CA90 ~                                    ret
 470++CA90 ~            .Y1OnScreen:
 471++CA90 ~            .Y2OnScreen:
 472++CA90 ~            .Y1Y2OppositeSign:
 473++CA90 ~            .StartProcessing:       ld      hl,(UbnkPreClipX1)                      ; Now we can test and Clip
 474++CA90 ~                                    ld      de,(UbnkPreClipX2)                      ; de - XX15(4,5)
 475++CA90 ~                                    ld      iyh,0                                   ; set iyh flags to 0
 476++CA90 ~            ; if x1hi or y1 high <> 0 or y1 > 127 then set bit 1 of clipcoord       ; we can optimise this later
 477++CA90 ~                                    ld      a,h
 478++CA90 ~                                    or      b
 479++CA90 ~                                    jr      z,.CheckP1Ylo
 480++CA90 ~            ;                       iyh     bit 0 - P1 Needs Clipping
 481++CA90 ~            ;                               bit 1 - P2 Needs Clipping
 482++CA90 ~            ;                               bit 2 - x1 >= x2 (left to right)
 483++CA90 ~            ;                               bit 3 - y1 >= y2 (top to bottom)
 484++CA90 ~            ;                               bit 4 -  DY/DX (steep)
 485++CA90 ~            .P1OffScreen:           ld      iyh,1                                   ; if either p1 x or y was off screen set bit 0 to 1
 486++CA90 ~                                    jp      .CheckP2OffScreen                       ; .
 487++CA90 ~            .CheckP1Ylo:            ld      a,c                                     ; .
 488++CA90 ~                                    and     $80                                     ; .
 489++CA90 ~                                    jr      z,.CheckP2OffScreen                     ; .
 490++CA90 ~                                    ld      iyh,1                                   ; .
 491++CA90 ~            .CheckP2OffScreen:      ld      a,d                                     ; if x2hi or y2 off screen then set bit 2 of clipcoord to 1
 492++CA90 ~                                    or      ixh                                     ; .
 493++CA90 ~                                    jr      z,.CheckP2Ylo                           ; .
 494++CA90 ~            .P2OffScreen:           ld      a,iyh                                   ; .
 495++CA90 ~                                    or      2                                       ; .
 496++CA90 ~                                    ld      iyh,a                                   ; .
 497++CA90 ~                                    jp      .CheckXDirection                        ; .
 498++CA90 ~            .CheckP2Ylo:            ld      a,ixl                                   ; .
 499++CA90 ~                                    and     $80                                     ; .
 500++CA90 ~                                    jr      z,.CheckXDirection                      ; .
 501++CA90 ~                                    ld      a,iyh                                   ; .
 502++CA90 ~                                    or      2                                       ; .
 503++CA90 ~                                    ld      iyh,a                                   ; .
 504++CA90 ~            .CheckXDirection:       push    de,,hl
 505++CA90 ~                                    call    CompareHLDESgn                          ; IF HL equals DE, Z=1,C=0, IF HL is less than DE, Z=0,C=1, IF HL is more than DE, Z=0,C=0
 506++CA90 ~                                    pop     de,,hl
 507++CA90 ~                                    jp      c,.CalculateDx                          ;
 508++CA90 ~            .X1gteX2:               ld      a,iyh                                   ; if x1 >= x2 then set bit 3 to denote -ve x direction, note we will eliminate horziontal / vertical early as an optimisation
 509++CA90 ~                                    or      4                                       ; .
 510++CA90 ~                                    ld      iyh,a                                   ; .
 511++CA90 ~                                    ; Y Direction is now always top to bottom
 512++CA90 ~            .CalculateDx:           ClearCarryFlag                                  ;                       calculate DX
 513++CA90 ~                                    sbc     hl,de                                   ; .
 514++CA90 ~            .ABSDX:                 ld      a,h                                     ; HL = | HL - DE |
 515++CA90 ~                                    test    $80                                     ; .
 516++CA90 ~                                    jr      z,.DXPositive                           ; .
 517++CA90 ~                                    macronegate16hl                                 ; .
 518++CA90 ~            .DXPositive:            ex      de,hl                                   ; de = abs delta x
 519++CA90 ~            .CalculateDy:           ClearCarryFlag                                  ; hl = Y2 -Y1 as its pre sorted its always positive if on screen
 520++CA90 ~                                    ld      hl,ix                                   ; iy = hl = Y2 - Y1
 521++CA90 ~                                    sbc     hl,bc                                   ; .
 522++CA90 ~            .DYPositive:            ; Scale DX and DY to 8 bit, by here hl = abs dy, de = abs dx
 523++CA90 ~            ;calculate DY
 524++CA90 ~            .ScaleLoop:             ld      a,h                                     ; At this point DX and DY are ABS values
 525++CA90 ~                                    or      d                                       ; .
 526++CA90 ~                                    jr      z,.ScaleDone                            ; .
 527++CA90 ~                                    ShiftDERight1                                   ; .
 528++CA90 ~                                    ShiftHLRight1                                   ; .
 529++CA90 ~                                    jr      .ScaleLoop                              ; scaled down Dx and Dy to 8 bit, Dy may have been;;                                                                                               negative
 530++CA90 ~            .ScaleDone:             ; hl = ABS DY, DE = ABS DX,  bc = Y1, ix = Y2,   note H and D will be zero
 531++CA90 ~            ; if Dx = 0 then horizontal line and clip X1 & X2 only then exit
 532++CA90 ~            ; if Dy = 0 then vertical line and clip Y1 & Y2 only then exit
 533++CA90 ~
 534++CA90 ~            ; if DX < DY  gradient = 256 * delta_x_lo / delta_y_lo
 535++CA90 ~            ;        else gradient = 256 * delta_y_lo / delta_x_lo, set bit 5 of clipcord
 536++CA90 ~            .CalculateDelta:        ld      a,e                                     ; if DX < DY goto DX/DY
 537++CA90 ~                                    JumpIfALTNusng l,.DXdivDY                       ; else do DY/DX
 538++CA90 ~            .DYdivDX:               ld      a,l                                     ;    A = DY
 539++CA90 ~                                    ld      d,e                                     ;    D = DX
 540++CA90 ~                                    call    AEquAmul256DivD                         ;    A = R = 256 * DY / DX
 541++CA90 ~            .SaveGradientDYDX:      ld      (Gradient),a
 542++CA90 ~                                    ld      a,iyh                                   ;    bit 5 of iyh denotes that its a DX/DY (steep), if its clear its DY/DX (shallow)
 543++CA90 ~                                    or      16                                      ;    .
 544++CA90 ~                                    ld      iyh,a                                   ;    .
 545++CA90 ~                                    jp      .ClipP1                                 ;    .
 546++CA90 ~            .DXdivDY:               ld      a,e                                     ;    A = DX
 547++CA90 ~                                    ld      d,l                                     ;    D = DY
 548++CA90 ~                                    call    AEquAmul256DivD                         ;    A = R = 256 * DX / DY
 549++CA90 ~            .SaveGradientDXDY:      ld      (Gradient),a
 550++CA90 ~            ; if bit 1 of clipccord is set call    LL118
 551++CA90 ~            .ClipP1:                ld      a,iyh                                   ; if bit 1 is clear to say no need to clip pont 1 we just jump to point 2
 552++CA90 ~                                    test    1                                       ; .
 553++CA90 ~                                    jp      z,.ClipP2                               ; .
 554++CA90 ~                                    call    LL118v3                                 ; else clip P1 first
 555++CA90 ~                                    ld      a,b                                     ;      and if b or h have a value its failed to totally clip  as it may be only in bounds on just x or y
 556++CA90 ~                                    or      h                                       ;      .
 557++CA90 ~                                    jr      z, .P1Ygt127Check                       ;      .
 558++CA90 ~            .P1HighOutofBounds:     SetCarryFlag                                    ;      .
 559++CA90 ~                                    ret                                             ;      .
 560++CA90 ~            .P1Ygt127Check:         ld      a,c                                     ;      or if y > 127 its failed to totally clip
 561++CA90 ~                                    test    $80                                     ;      .
 562++CA90 ~                                    SetCarryFlag                                    ;      .
 563++CA90 ~                                    ret     nz                                      ;      .
 564++CA90 ~                                    ld      (UbnkPreClipY1), bc                     ;      else its valid and clipped point 1 so save ti back
 565++CA90 ~                                    ld      (UbnkPreClipX1), hl
 566++CA90 ~            ; if bit 2 of clipcoord is set
 567++CA90 ~            ;        swap x1y1 with x2y2
 568++CA90 ~            ;        call    LL118
 569++CA90 ~            .ClipP2:                ld      a,iyh                                   ; so now repeat all that for point 2
 570++CA90 ~                                    and     2
 571++CA90 ~                                    jp      z,.ClipComplete
 572++CA90 ~                                    call    LL118v3PreSwap                          ; now clip p2
 573++CA90 ~                                    ld      a,b                                     ; if either high is set then it failed to properly clip
 574++CA90 ~                                    or      h                                       ; .
 575++CA90 ~                                    jr      z, .P2Ygt127Check                       ; .
 576++CA90 ~            .P2HighOutofBounds:     SetCarryFlag                                    ; .
 577++CA90 ~                                    ret                                             ; .
 578++CA90 ~            .P2Ygt127Check:         ld      a,c                                     ; if c > 127 then it also failed to clip
 579++CA90 ~                                    test    $80                                     ; .
 580++CA90 ~                                    SetCarryFlag                                    ; .
 581++CA90 ~                                    ret     nz                                      ; .
 582++CA90 ~                                    ld      (UbnkPreClipY2), bc                     ; bc - XX15(2,3);;
 583++CA90 ~                                    ld      (UbnkPreClipX2), hl
 584++CA90 ~            ;clip compelte exit
 585++CA90 ~            .ClipComplete:          ld      bc,(UbnkPreClipY1)                      ; bc - XX15(2,3);;
 586++CA90 ~                                    ld      hl,(UbnkPreClipX1)
 587++CA90 ~                                    ld      ix,(UbnkPreClipY2)                      ; bc - XX15(2,3);;
 588++CA90 ~                                    ld      de,(UbnkPreClipX2)
 589++CA90 ~            .SaveClippedLine:       ld      a,c                                     ; Y1 = y1 lo, x2 = x2 lo, x1 = x1 lo y1 = y1 lo                                   -- Nothing off screen
 590++CA90 ~                                    ld      (UBnkNewY1),a
 591++CA90 ~                                    ld      a,ixl
 592++CA90 ~                                    ld      (UBnkNewY2),a
 593++CA90 ~                                    ld      a,l
 594++CA90 ~                                    ld      (UBnkNewX1),a
 595++CA90 ~                                    ld      a,e
 596++CA90 ~                                    ld      (UBnkNewX2),a
 597++CA90 ~                                    ClearCarryFlag                              ; we have a success so not carry
 598++CA90 ~                                    ret
 599++CA90 ~            ;-----------------------------------------------------------------------------------------------------------------------------------
 600++CA90 ~            LL118v3PreSwap:         ld      bc,(UbnkPreClipY2)                  ; bc - XX15(2,3);;
 601++CA90 ~                                    ld      hl,(UbnkPreClipX2)
 602++CA90 ~                                    jp      LL118v3Fetched
 603++CA90 ~            ;-----------------------------------------------------------------------------------------------------------------------------------
 604++CA90 ~            LL118v3:                ld      bc,(UbnkPreClipY1)                  ; bc - XX15(2,3);;
 605++CA90 ~                                    ld      hl,(UbnkPreClipX1)
 606++CA90 ~            ;-----------------------------------------------------------------------------------------------------------------------------------
 607++CA90 ~            LL118v3Fetched:
 608++CA90 ~            ;                       At this point bc = y position, hl = x position both 16 bit
 609++CA90 ~            ;                       if x < 0 then x = 0
 610++CA90 ~            ;                                     adjust = -x */ gradient depending on if its steep or shallow
 611++CA90 ~            ;                                     y = y +- adjust depending on if we are going +ve direction or negative direction  (or simplify it, that it will always be + for x1y1 and - for x2y2 as we pre-sort)
 612++CA90 ~            ;                       if x > 255 then x = 255
 613++CA90 ~            ;                                     adjust = x-255 */ gradient
 614++CA90 ~            ;                                     y = y +- adjust depending on if we are going +ve direction or negative direction  (or simplify it, that it will always be + for x1y1 and - for x2y2 as we pre-sort)
 615++CA90 ~            ;                       if y < 0 then y = 0
 616++CA90 ~            ;                                     adjust = -y */ gradient
 617++CA90 ~            ;                                     x = x +- adjust depending on if we are going left to right or visa versa
 618++CA90 ~            ;                       if y >127 then y = 127
 619++CA90 ~            ;                                     adjust = y-127 */ gradient
 620++CA90 ~            ;                                     x = x +- adjust depending on if we are going left to right or visa versa
 621++CA90 ~            ;
 622++CA90 ~            ;                       iyh     bit 0 - P1 Needs Clipping
 623++CA90 ~            ;                               bit 1 - P2 Needs Clipping
 624++CA90 ~            ;                               bit 2 - x1 >= x2 (left to right)
 625++CA90 ~            ;                               bit 3 - y1 >= y2 (top to bottom)
 626++CA90 ~            ;                               bit 4 -  DY/DX (steep)
 627++CA90 ~            ; if X1 hi <> 0
 628++CA90 ~            LL118:                  ;break
 629++CA90 ~                                    ld      a,h                                     ; if x1 high is 0 then we don't need to clip x at all
 630++CA90 ~                                    and     a
 631++CA90 ~                                    jp      z,.X1NoClipNeeded
 632++CA90 ~            ;                       if x1 hi bit 7 is set (so negative)
 633++CA90 ~            .CalcBlockX:            test    $80                                     ; if h is postiive then jump to the XPositive Calc block
 634++CA90 ~                                    jr      z,.CalcBlockXPositive
 635++CA90 ~            ;                       if clipccord bit 5 is set Adjust = abs(X1) / Gradient (may need to swap bit check?)
 636++CA90 ~            .CalcBlockXNegative:    ld      a,iyh                                   ;
 637++CA90 ~                                    test    16                                      ; bit 5 of iyh denotes that its a DY/DX, if its clear its DX/DY
 638++CA90 ~                                    jr      nz,.CalcBlockXNegMulGrad
 639++CA90 ~            .CaclBlockXNegDivGrad:  macronegate16hl
 640++CA90 ~                                    ld      a,(Gradient)
 641++CA90 ~                                    push    bc                                      ; abs(X1) / Gradient
 642++CA90 ~                                    ld      h,c                     ; move offset into high byte of h
 643++CA90 ~                                    ld      l,0
 644++CA90 ~                                    ld      c,a
 645++CA90 ~                                    call    div_hl_c
 646++CA90 ~                                    pop     bc
 647++CA90 ~                                    jp      .DoneXNegCalc
 648++CA90 ~            ;                       else set Adjust = abs(X1) * Gradient
 649++CA90 ~            .CalcBlockXNegMulGrad:  push    bc                                      ; abs(X1) * Gradient
 650++CA90 ~                                    macronegate16hl
 651++CA90 ~                                    ld      a,(Gradient)
 652++CA90 ~                                    call    HLeqyHLmulAdiv256
 653++CA90 ~                                    pop     bc
 654++CA90 ~            ;                       y1 += adjust * (-1 if bit 4 of clipcoord is set)
 655++CA90 ~            ;                       x1 = 0 then call into DonrX1Calc
 656++CA90 ~            ;                       we can skip the test for negative Y direection
 657++CA90 ~            .DoneXNegCalc:          macronegate16hl
 658++CA90 ~            .XNegSkipNegate:        ld      de,bc
 659++CA90 ~                                    ex      hl,de
 660++CA90 ~                                    add     hl,de
 661++CA90 ~                                    ld      bc,hl
 662++CA90 ~                                    ld      hl,0
 663++CA90 ~                                    jp      .DoneXCalc
 664++CA90 ~            ;                       else x1 hi is positive
 665++CA90 ~            ;                       if clipccord bit 5 is set Adjust = X1 lo / Gradient (may need to swap bit check?)
 666++CA90 ~            .CalcBlockXPositive:    ld      a,iyh
 667++CA90 ~                                    test    16
 668++CA90 ~                                    jr      nz,.CalcBlockXPosMulGrad
 669++CA90 ~            .CalcBlockXPosDivGrad:  ld      a,(Gradient)            ;Q = gradient
 670++CA90 ~                                    push    bc
 671++CA90 ~                                    ld      c,a
 672++CA90 ~                                    ld      de,255
 673++CA90 ~                                    sub     hl,de
 674++CA90 ~                                    ld      h,l
 675++CA90 ~                                    ld      l,0
 676++CA90 ~                                    call    div_hl_c
 677++CA90 ~                                    pop     bc
 678++CA90 ~                                    jp      .DoneX2Calc
 679++CA90 ~            ;                                 else set Adjust = X1 lo * Gradient
 680++CA90 ~            .CalcBlockXPosMulGrad:  push    bc
 681++CA90 ~                                    ld      a,(Gradient)            ;Q = gradient
 682++CA90 ~                                    ld      de,255
 683++CA90 ~                                    sub     hl,de
 684++CA90 ~                                    call    HLeqyHLmulAdiv256       ; hl = YX = SR / Q
 685++CA90 ~                                    pop     bc
 686++CA90 ~            ;                       y1 += adjust * (-1 if bit 4 of clipcoord is set)
 687++CA90 ~            ;                       x1 = 255
 688++CA90 ~            ;                       we can skip the test for negative Y direection
 689++CA90 ~            .DoneX2Calc:            macronegate16hl
 690++CA90 ~            .X2SkipNegate:          ex      de,hl
 691++CA90 ~                                    ld      hl,bc
 692++CA90 ~                                    add     hl,de
 693++CA90 ~                                    ld      bc,hl
 694++CA90 ~                                    ld      hl,255
 695++CA90 ~            ;                       if Y1 hi <> 0 or Y1 low >= 128 then y coordinate is good
 696++CA90 ~            .DoneXCalc:             ld      a,b
 697++CA90 ~                                    and     a
 698++CA90 ~                                    jr      nz,.CalcBlockY1Test
 699++CA90 ~                                    ld      a,c
 700++CA90 ~                                    and     $80
 701++CA90 ~                                    ClearCarryFlag                  ; speculative clear of carry in case its good
 702++CA90 ~                                    ret     z
 703++CA90 ~            ;                       if Y1 hi bit 7 is set
 704++CA90 ~            .X1NoClipNeeded:
 705++CA90 ~            .CalcBlockY1Test:       ld      a,b
 706++CA90 ~                                    test    $80
 707++CA90 ~                                    jr      z,.CalcBlockYPos       ; if Y is positive jump forward
 708++CA90 ~            ;                       if clipccord bit 5 is set Adjust = abs(Y1) / Gradient (may need to swap bit check?)
 709++CA90 ~                                    break
 710++CA90 ~            .CalcBlockY1:           ld      a,iyh
 711++CA90 ~                                    test    16
 712++CA90 ~                                    jr      nz,.CalcBlockYNegMulGrad
 713++CA90 ~            .CalcBlockYNegDivGrad:  macronegate16bc
 714++CA90 ~                                    ld      a,(Gradient)            ;Q = gradient
 715++CA90 ~                                    push    hl
 716++CA90 ~                                    ld      h,c                     ; move offset into high byte of h
 717++CA90 ~                                    ld      l,0
 718++CA90 ~                                    ld      c,a
 719++CA90 ~                                    call    div_hl_c;LLHLdivC;div_hl_c
 720++CA90 ~                                    pop     de
 721++CA90 ~                                    ex      de,hl
 722++CA90 ~                                    jp      .DoneBlockY1
 723++CA90 ~            ;                                 else set Adjust = abs(Y1) * Gradient
 724++CA90 ~            .CalcBlockYNegMulGrad:  macronegate16bc
 725++CA90 ~                                    push    hl
 726++CA90 ~                                    ld      hl,bc
 727++CA90 ~                                    ld      a,(Gradient)            ;Q = gradient
 728++CA90 ~                                    call    HLeqyHLmulAdiv256       ; hl = YX = SR / Q
 729++CA90 ~                                    pop     de
 730++CA90 ~                                    ex      de,hl
 731++CA90 ~            ;                       x1 += adjust * (-1 if bit 3 of clipcoord is set)
 732++CA90 ~            ;                       y1 = 0
 733++CA90 ~            ;                       ret
 734++CA90 ~            ;                       now we have done the adjustment, if y or x are off screen then the line spans screen in only 1 dimension so doesn't get drawn
 735++CA90 ~            .DoneBlockY1:           ld      a,iyh
 736++CA90 ~                                    test    4
 737++CA90 ~                                    jr      z,.Y1SkipNegate
 738++CA90 ~                                    macronegate16de
 739++CA90 ~            .Y1SkipNegate:          add     hl,de
 740++CA90 ~                                    ld      bc,0
 741++CA90 ~                                    ret
 742++CA90 ~            ;                       if clipccord bit 5 is set Adjust = Y1 lo / Gradient (may need to swap bit check?)
 743++CA90 ~            .CalcBlockYPos:         ld      a,iyh
 744++CA90 ~                                    test    16
 745++CA90 ~                                    jr      z,.CalcBlockYPosMulGrad
 746++CA90 ~            .CalcBlockYPosDivGrad:  ld      a,(Gradient)            ;Q = gradient
 747++CA90 ~                                    push    hl
 748++CA90 ~                                    ld      hl,bc
 749++CA90 ~                                    ld      de,127
 750++CA90 ~                                    sub     hl,de
 751++CA90 ~                                    ld      h,l
 752++CA90 ~                                    ld      l,0
 753++CA90 ~                                    ld      c,a
 754++CA90 ~                                    call    div_hl_c;LLHLdivC
 755++CA90 ~                                    pop     de
 756++CA90 ~                                    ex      de,hl
 757++CA90 ~                                    jp      .DoneBlockY2
 758++CA90 ~            ;                                 else set Adjust = Y1 lo * Gradient
 759++CA90 ~            .CalcBlockYPosMulGrad:  push    hl
 760++CA90 ~                                    ld      hl,bc
 761++CA90 ~                                    ld      de,127
 762++CA90 ~                                    sub     hl,de
 763++CA90 ~                                    ld      a,(Gradient)
 764++CA90 ~                                    call    HLeqyHLmulAdiv256       ; hl = YX = SR / Q
 765++CA90 ~                                    pop     de
 766++CA90 ~                                    ex      de,hl
 767++CA90 ~            ;                x1 += adjust * (-1 if bit 3 of clipcoord is set)
 768++CA90 ~            ;                y1 = 127
 769++CA90 ~            .DoneBlockY2:           ld      a,iyh
 770++CA90 ~                                    test    4
 771++CA90 ~                                    jr      nz,.Y2SkipNegate
 772++CA90 ~                                    macronegate16de
 773++CA90 ~            .Y2SkipNegate:          add     hl,de
 774++CA90 ~                                    ld      bc,127
 775++CA90 ~                                    ret
 776++CA90                      ELSE
 777++CA90 C9                       ret
 778++CA91                      ENDIF
 779++CA91              ; old code for on screen test
 780++CA91              ;;;;;;; if y1 > 127 and y2 > 127 then same sing and exit
 781++CA91              ;;;;;;
 782++CA91              ;;;;;;;if y1hi y2hi are <> 0 and both same sign exit
 783++CA91              ;;;;;;.CheckYOffScreen:       ld      a,b                                 ; y1 and y2 high tests
 784++CA91              ;;;;;;                        and     ixh
 785++CA91              ;;;;;;                        jp      .CheckYLow
 786++CA91              ;;;;;;                        ld
 787++CA91              ;;;;;;                        and     a                                   ; if either is zero then we can check for > 127
 788++CA91              ;;;;;;                        jr      z,.YHighNegativeCheck               ;
 789++CA91              ;;;;;;                        ld      a,ixh                               ;
 790++CA91              ;;;;;;                        and     a                                   ;
 791++CA91              ;;;;;;                        ret     nz                                  ;
 792++CA91              ;;;;;;;if y1h bit 7 and y2h bit 7 set then exit as both -ve
 793++CA91              ;;;;;;                        ld      a,b                                 ;
 794++CA91              ;;;;;;                        and     ixh                                 ;
 795++CA91              ;;;;;;                        and     $80                                 ;
 796++CA91              ;;;;;;                        ret     z                                   ;
 797++CA91              ;;;;;;;if y1h > 0 and y2h > 0 then exit as both are +ve high
 798++CA91              ;;;;;;                        ld      a,b                                 ;
 799++CA91              ;;;;;;                        and     ixh                                 ;
 800++CA91              ;;;;;;                        ret     nz                                  ;
 801++CA91              ;;;;;;;if y1h or y2h is not 0 then proceed to clip
 802++CA91              ;;;;;;                        ld      a,b
 803++CA91              ;;;;;;                        or      ixh
 804++CA91              ;;;;;;                        jr      nz,.StartProcessing
 805++CA91              ;;;;;;;if (y1l bit 7 is set and y1h is clear ) or (y2l bit 7 is set and y2h is clear) the proceed to clip
 806++CA91              ;;;;;;                        ld      a,c
 807++CA91              ;;;;;;                        or      ixl
 808++CA91              ;;;;;;                        and     $80
 809++CA91              ;;;;;;                        jr      z,.StartProcessing
 810++CA91              ;;;;;;
 811++CA91              ;;;;;;.CheckYOffScreen:       ld      a,b                                 ;
 812++CA91              ;;;;;;                        cp      0                                   ;
 813++CA91              ;;;;;;                        jr      z,.Y1HighIsZero                     ;
 814++CA91              ;;;;;;                        ld      a,ixh                               ; if we get here Y1 high <> 0
 815++CA91              ;;;;;;                        cp      0                                   ;
 816++CA91              ;;;;;;                        jr      z,.Y2HighIsZero                     ; if they are both non zero we can do a sign check
 817++CA91              ;;;;;;.CheckYSameSign:        ld      a,b                                 ; if we get here Y1 high and Y2 high are not zero
 818++CA91              ;;;;;;                        xor     ixh                                 ; so same sign then bail out if they are
 819++CA91              ;;;;;;                        and     $80                                 ;
 820++CA91              ;;;;;;                        ret     z                                   ;
 821++CA91              ;;;;;;;if we get here either y1hi or y2 hi are 0, now check and y1 low > 127 & y2 low > 127, exit
 822++CA91              ;;;;;;.Y1HighIsZero:          ld      a,ixh                               ; as y1h is zero, if y2h is zero we do y1 y2 test
 823++CA91              ;;;;;;                        cp      0                                   ;
 824++CA91              ;;;;;;                        jr      nz,.Startprocessing                 ;
 825++CA91              ;;;;;;                        ld      a,c                                 ; so by here y1h and y2h must be zero
 826++CA91              ;;;;;;                        and     ixl
 827++CA91              ;;;;;;
 828++CA91              ;;;;;;                        .CheckY2Lo                        ;
 829++CA91              ;;;;;;.CheckY1Lo:             ld      a,c
 830++CA91              ;;;;;;                        and     $80
 831++CA91              ;;;;;;                        jr      z,.StartProcessing
 832++CA91              ;;;;;;.CheckY2Lo:             ld      a,ixl
 833++CA91              ;;;;;;                        and     $80
 834++CA91              ;;;;;;                        ret     nz
 835++CA91              ;;;;;;;clip = 0
# file closed: ../../Tests/3DTest/../../ModelRender/CLIP-LL145.asm
 378+ CA91              ;--------------------------------------------------------------------------------------------------------
 379+ CA91                                      INCLUDE "../../Universe/Ships/CopyRotmatToTransMat.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/CopyRotmatToTransMat.asm
   1++CA91              ; Set TransMatTo
   2++CA91              ; XX16(1 0)   (3 2)   (5 4)   = sidev_x sidev_y sidev_z XX16(13,12) (15 14) (17 16)
   3++CA91              ; XX16(7 6)   (9 8)   (11 10) = roofv_x roofv_y roofv_z XX16(7 6)   (9 8)   (11 10)
   4++CA91              ; XX16(13 12) (15 14) (17 16) = nosev_x nosev_y nosev_z XX16(1 0)   (3 2)   (5 4)
   5++CA91              ; This moves Side XYZ to position 0, Roof XYZ to position 1 annd nose XYZ to position 2 as a copy of each batch of 6 bytes
   6++CA91              ; 18 byte fast copy
   7++CA91
   8++CA91              ; Fast copy using the stack                                                         ; T states
   9++CA91 F3           CopyRotmatToTransMat:   di                                                          ; disable interrups to protect during copy
  10++CA92 DD 21 00 00                          ld      ix,0                                                ; 14
  11++CA96 DD 39                                add     ix,sp                                               ; 15
  12++CA98 31 2A C0                             ld      sp,UBnkrotmatSidevX ; Source                        ; 10
  13++CA9B E1                                   pop     hl                  ; UBnkrotmatSidevX              ; 10
  14++CA9C D1                                   pop     de                  ; UBnkrotmatSidevY              ; 10
  15++CA9D C1                                   pop     bc                  ; UBnkrotmatSidevZ              ; 10
  16++CA9E D9                                   exx                                                         ; 4
  17++CA9F E1                                   pop     hl                  ; UBnkrotmatRoofvX              ; 10
  18++CAA0 D1                                   pop     de                  ; UBnkrotmatRoofvY              ; 10
  19++CAA1 C1                                   pop     bc                  ; UBnkrotmatRoofvZ              ; 10
  20++CAA2 31 AE C0                             ld      sp,UBnkTransmatRoofvZ+2 ; Target + 2 reversed       ; 10
  21++CAA5 C5                                   push    bc                                                  ; 10
  22++CAA6 D5                                   push    de                                                  ; 10
  23++CAA7 E5                                   push    hl                                                  ; 10
  24++CAA8 D9                                   exx                                                         ; 4
  25++CAA9 C5                                   push    bc                                                  ; 10
  26++CAAA D5                                   push    de                                                  ; 10
  27++CAAB E5                                   push    hl                                                  ; 10
  28++CAAC 31 36 C0                             ld      sp,UBnkrotmatNosevX ; Source                        ; 10
  29++CAAF E1                                   pop     hl                  ; UBnkrotmatSidevX              ; 10
  30++CAB0 D1                                   pop     de                  ; UBnkrotmatSidevY              ; 10
  31++CAB1 C1                                   pop     bc                  ; UBnkrotmatSidevZ              ; 10
  32++CAB2 31 B4 C0                             ld      sp,UBnkTransmatNosevZ+2                             ; 10
  33++CAB5 C5                                   push    bc                                                  ; 10
  34++CAB6 D5                                   push    de                                                  ; 10
  35++CAB7 E5                                   push    hl                                                  ; 10
  36++CAB8 DD F9                                ld      sp,ix               ; restore stack                 ; 10
  37++CABA                                  IFNDEF INTERRUPS_DISABLE
  38++CABA ~                                    ei
  39++CABA                                  ENDIF
  40++CABA C9                                   ret                                                         ; 10 Total 267 (LDI version is 318)
  41++CABB
  42++CABB
  43++CABB
  44++CABB              ;CopyRotmatToTransMat:
  45++CABB              ;                        ld      hl,UBnkrotmatSidevX
  46++CABB              ;                        ld      de,UBnkTransmatSidevX
  47++CABB              ;                        SixLDIInstrunctions
  48++CABB              ;                        ld      hl,UBnkrotmatRoofvX
  49++CABB              ;                        ld      de, UBnkTransmatRoofvX
  50++CABB              ;                        SixLDIInstrunctions
  51++CABB              ;                        ld      hl,UBnkrotmatNosevX
  52++CABB              ;                        ld      de, UBnkTransmatNosevX
  53++CABB              ;                        SixLDIInstrunctions
  54++CABB              ;                        ret
  55++CABB
  56++CABB              CopyRotToTransMacro:    MACRO
  57++CABB ~                                    ld      hl,UBnkrotmatSidevX
  58++CABB ~                                    ld      de,UBnkTransmatSidevX
  59++CABB ~                                    SixLDIInstrunctions
  60++CABB ~                                    SixLDIInstrunctions
  61++CABB ~                                    SixLDIInstrunctions
  62++CABB                                      ENDM
  63++CABB
# file closed: ../../Tests/3DTest/../../Universe/Ships/CopyRotmatToTransMat.asm
 380+ CABB                                      INCLUDE "../../Universe/Ships/TransposeXX12ByShipToXX15.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/TransposeXX12ByShipToXX15.asm
   1++CABB              TransposeXX12ByShipToXX15:
   2++CABB 2A ED C0             ld		hl,(UBnkXX12xLo)					; get X into HL
   3++CABE 7C           		ld		a,h			                        ; get XX12 Sign
   4++CABF E6 80        		and		$80									; check sign bit on high byte
   5++CAC1 47           		ld		b,a									; and put it in of 12xlo in b
   6++CAC2                      ;110921 debugld      h,0
   7++CAC2 7C                   ld      a,h
   8++CAC3 E6 7F                and     $7F
   9++CAC5 67                   ld      h,a
  10++CAC6                      ;110921 debugld      h,0
  11++CAC6 ED 5B 20 C0  		ld		de,(UBnKxlo)						;
  12++CACA 3A 22 C0     		ld		a,(UBnKxsgn)						; get Ship Pos (low,high,sign)
  13++CACD E6 80        		and		$80									; make sure we only have bit 7
  14++CACF 4F           		ld		c,a									; and put sign of unkxsgn c
  15++CAD0 CD 33 00     		call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC		; this will result in HL = result and A = sign
  16++CAD3 B4           		or		h									; combine sign in A with H to give 15 bit signed (*NOT* 2's c)
  17++CAD4 67           		ld		h,a
  18++CAD5 22 E7 C0     		ld		(UBnkXScaled),hl					; now write it out to XX15 X pos
  19++CAD8              ; ..................................
  20++CAD8 2A EF C0     		ld		hl,(UBnkXX12yLo)					; Repeat above for Y coordinate
  21++CADB 7C           		ld		a,h
  22++CADC E6 80        		and		$80
  23++CADE 47           		ld		b,a
  24++CADF                      ;110921 debugld      h,0
  25++CADF 7C                   ld      a,h
  26++CAE0 E6 7F                and     $7F
  27++CAE2 67                   ld      h,a
  28++CAE3                      ;110921 debugld      h,0
  29++CAE3 ED 5B 23 C0  		ld		de,(UBnKylo)
  30++CAE7 3A 25 C0     		ld		a,(UBnKysgn)
  31++CAEA E6 80        		and		$80									; make sure we only have bit 7
  32++CAEC 4F           		ld		c,a
  33++CAED CD 33 00     		call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC
  34++CAF0 B4           		or		h									; combine sign in A with H
  35++CAF1 67           		ld		h,a
  36++CAF2 22 E9 C0     		ld		(UBnkYScaled),hl
  37++CAF5              ; ..................................
  38++CAF5 2A F1 C0     		ld		hl,(UBnkXX12zLo)					; and now repeat for Z cooord
  39++CAF8 7C           		ld		a,h
  40++CAF9 E6 80        		and		$80
  41++CAFB 47           		ld		b,a
  42++CAFC                      ;110921 debugld      h,0
  43++CAFC 7C                   ld      a,h
  44++CAFD E6 7F                and     $7F
  45++CAFF 67                   ld      h,a
  46++CB00                      ;110921 debugld      h,0
  47++CB00 ED 5B 26 C0  		ld		de,(UBnKzlo)
  48++CB04 3A 28 C0     		ld		a,(UBnKzsgn)
  49++CB07 E6 80        		and		$80									; make sure we only have bit 7
  50++CB09 4F           		ld		c,a
  51++CB0A CD 33 00     		call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC
  52++CB0D B4           		or		h									; combine sign in A with H
  53++CB0E 67           		ld		h,a
  54++CB0F CB 7C        		bit		7,h                                 ; if sign if positive then we don't need to do the clamp so we ony jump
  55++CB11 20 16        		jr		nz,ClampZto4                        ; result was negative so we need to clamp to 4
  56++CB13 E6 7F                and     $7F                                 ; a = value unsigned
  57++CB15 20 06                jr      nz,NoClampZto4                      ; if high byte was 0 then we could need to clamp still by this stage its +v but and will set z flag if high byte is zero
  58++CB17 7D                   ld      a,l                                 ; get low byte now
  59++CB18              		JumpIfALTNusng 4,ClampZto4					; if its < 4 then fix at 4
  59++CB18 FE 04       >                        cp      4
  59++CB1A DA 29 CB    >                        jp		c, ClampZto4
  60++CB1D              NoClampZto4:
  61++CB1D 22 EB C0     		ld		(UBnkZScaled),hl					; hl = signed calculation and > 4
  62++CB20 7D           		ld		a,l									; in addition write out the z cooord to UT for now for backwards compat (DEBUG TODO remove later)
  63++CB21 32 21 67             ld      (varT),a
  64++CB24 7C           		ld		a,h
  65++CB25 32 04 67             ld      (varU),a
  66++CB28 C9           		ret
  67++CB29              ClampZto4:											; This is where we limit 4 to a minimum of 4
  68++CB29 21 04 00     		ld		hl,4
  69++CB2C 22 EB C0     		ld		(UBnkZScaled),hl; BODGE FOR NOW
  70++CB2F 7D           		ld		a,l
  71++CB30 32 21 67             ld      (varT),a                            ;                                                                           ;;;
  72++CB33 7C           		ld		a,h
  73++CB34 32 04 67             ld      (varU),a 						; compatibility for now
  74++CB37 C9           		ret
  75++CB38
# file closed: ../../Tests/3DTest/../../Universe/Ships/TransposeXX12ByShipToXX15.asm
 381+ CB38                                      INCLUDE "../../Maths/Utilities/ScaleNodeTo8Bit.asm"
# file opened: ../../Tests/3DTest/../../Maths/Utilities/ScaleNodeTo8Bit.asm
   1++CB38              ScaleNodeTo8Bit:								; TODO make signed
   2++CB38 ED 4B EB C0  	ld			bc,(UBnkZScaled)
   3++CB3C 2A E7 C0     	ld			hl,(UBnkXScaled)
   4++CB3F ED 5B E9 C0  	ld			de,(UBnkYScaled)
   5++CB43              SetABSbc:
   6++CB43 78           	ld			a,b
   7++CB44 DD 67        	ld			ixh,a
   8++CB46 E6 7F        	and			SignMask8Bit
   9++CB48 47           	ld			b,a									; bc = ABS bc
  10++CB49              SetABShl:
  11++CB49 7C           	ld			a,h
  12++CB4A DD 6F        	ld			ixl,a
  13++CB4C E6 7F        	and			SignMask8Bit
  14++CB4E 67           	ld			h,a									; hl = ABS hl
  15++CB4F              SetABSde:
  16++CB4F 7A           	ld			a,d
  17++CB50 FD 67        	ld			iyh,a
  18++CB52 E6 7F        	and			SignMask8Bit
  19++CB54 57           	ld			d,a									; de = ABS de
  20++CB55              ScaleNodeTo8BitLoop:
  21++CB55 78               ld          a,b		                            ; U	\ z hi
  22++CB56 B4           	or			h                                   ; XX15+1	\ x hi
  23++CB57 B2           	or			d                                   ; XX15+4	\ y hi
  24++CB58 28 0F            jr          z,ScaleNodeDone                   ; if X, Y, Z = 0  exit loop down once hi U rolled to 0
  25++CB5A                  ShiftHLRight1
  25++CB5A CB 3C       >               srl h
  25++CB5C CB 1D       >               rr  l
  26++CB5E                  ShiftDERight1
  26++CB5E CB 3A       >               srl d
  26++CB60 CB 1B       >               rr  e
  27++CB62              	ShiftBCRight1
  27++CB62 CB 38       >               srl b
  27++CB64 CB 19       >               rr  c
  28++CB66 C3 55 CB         jp          ScaleNodeTo8BitLoop
  29++CB69              ScaleNodeDone:										; now we have scaled values we have to deal with sign
  30++CB69 DD 7C        	ld			a,ixh								; get sign bit and or with b
  31++CB6B E6 80        	and			SignOnly8Bit
  32++CB6D B0           	or			b
  33++CB6E 47           	ld			b,a
  34++CB6F              SignforHL:
  35++CB6F DD 7D        	ld			a,ixl								; get sign bit and or with b
  36++CB71 E6 80        	and			SignOnly8Bit
  37++CB73 B4           	or			h
  38++CB74 67           	ld			h,a
  39++CB75              SignforDE:
  40++CB75 FD 7C        	ld			a,iyh								; get sign bit and or with b
  41++CB77 E6 80        	and			SignOnly8Bit
  42++CB79 B2           	or			d
  43++CB7A 57           	ld			d,a
  44++CB7B              SignsDoneSaveResult:
  45++CB7B ED 43 EB C0  	ld			(UBnkZScaled),bc
  46++CB7F 22 E7 C0     	ld			(UBnkXScaled),hl
  47++CB82 ED 53 E9 C0  	ld			(UBnkYScaled),de
  48++CB86 78           	ld			a,b
  49++CB87 32 04 67     	ld			(varU),a
  50++CB8A 79           	ld			a,c
  51++CB8B 32 21 67     	ld			(varT),a
  52++CB8E C9           	ret
  53++CB8F
# file closed: ../../Tests/3DTest/../../Maths/Utilities/ScaleNodeTo8Bit.asm
 382+ CB8F
 383+ CB8F              ;--------------------------------------------------------------------------------------------------------
 384+ CB8F 21 13 C1     SetFaceAVisible:        ld      hl,UbnkFaceVisArray
 385+ CB92 ED 31                                add     hl,a
 386+ CB94 3E FF                                ld      a,$FF
 387+ CB96 77                                   ld      (hl),a
 388+ CB97 C9                                   ret
 389+ CB98              ;--------------------------------------------------------------------------------------------------------
 390+ CB98 21 13 C1     SetFaceAHidden:         ld      hl,UbnkFaceVisArray
 391+ CB9B ED 31                                add     hl,a
 392+ CB9D AF                                   xor     a
 393+ CB9E 77                                   ld      (hl),a
 394+ CB9F C9                                   ret
 395+ CBA0              ;--------------------------------------------------------------------------------------------------------
 396+ CBA0 3A 44 C4     SetAllFacesVisible:     ld      a,(FaceCtX4Addr)            ; (XX0),Y which is XX0[0C] or UBnkHullCopy+FaceCtX4Addr                                 ;;; Faces count (previously loaded into b up front but no need to shave bytes for clarity
 397+ CBA3 CB 3F                                srl     a                           ; else do explosion needs all vertices                                                  ;;;
 398+ CBA5 CB 3F                                srl     a                           ;  /=4  TODO add this into blueprint data for speed                                                           ;;; For loop = 15 to 0
 399+ CBA7 47                                   ld      b,a                         ; b = Xreg = number of normals, faces
 400+ CBA8 21 13 C1                             ld      hl,UbnkFaceVisArray
 401+ CBAB 3E FF                                ld      a,$FF
 402+ CBAD              SetAllFacesVisibleLoop:
 403+ CBAD 77           EE30:                   ld      (hl),a
 404+ CBAE 23                                   inc     hl
 405+ CBAF 10 FC                                djnz    SetAllFacesVisibleLoop
 406+ CBB1 C9                                   ret
 407+ CBB2              ;--------------------------------------------------------------------------------------------------------
 408+ CBB2 3A 44 C4     SetAllFacesHidden:      ld      a,(FaceCtX4Addr)            ; (XX0),Y which is XX0[0C] or UBnkHullCopy+ShipHullFacesCount                           ;;; Faces count (previously loaded into b up front but no need to shave bytes for clarity
 409+ CBB5 CB 3F                                srl     a                           ; else do explosion needs all vertices                                                  ;;;
 410+ CBB7 CB 3F                                srl     a                           ;  /=4                                                                                  ;;; For loop = 15 to 0
 411+ CBB9 47                                   ld      b,a                         ; b = Xreg = number of normals, faces
 412+ CBBA 06 10                                ld      b,16
 413+ CBBC 21 13 C1                             ld      hl,UbnkFaceVisArray
 414+ CBBF 3E 00                                ld      a,$00
 415+ CBC1 77           SetAllFacesHiddenLoop:  ld      (hl),a
 416+ CBC2 23                                   inc     hl
 417+ CBC3 10 FC                                djnz    SetAllFacesHiddenLoop
 418+ CBC5 C9                                   ret
 419+ CBC6              ;--------------------------------------------------------------------------------------------------------
 420+ CBC6                                      include "../../Universe/Ships/NormaliseTransMat.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/NormaliseTransMat.asm
   1++CBC6              ;divdide by 16 using undocumented instrunctions
   2++CBC6 47           Norm256mulAdivQ:        ld      b,a
   3++CBC7 0E 00                                ld      c,0
   4++CBC9 16 00                                ld      d,0
   5++CBCB 3A 05 67                             ld      a,(varQ)
   6++CBCE 5F                                   ld      e,a
   7++CBCF              ;Input: BC = Dividend, DE = Divisor, HL = 0
   8++CBCF              ;Output: BC = Quotient, HL = Remainder
   9++CBCF 21 00 00     NormDIV16UNDOC:         ld      hl,0
  10++CBD2 78                                   ld      a,b
  11++CBD3 06 10                                ld      b,16
  12++CBD5 CB 31        NormDIV16UNDOCLOOP:     sll	    c		; unroll 16 times
  13++CBD7 17                                   rla	    		; ...
  14++CBD8 ED 6A                                adc	    hl,hl		; ...
  15++CBDA ED 52                                sbc	    hl,de		; ...
  16++CBDC 30 02                                jr	    nc,NormDIV16UNDOCSKIP		; ...
  17++CBDE 19                                   add	    hl,de		; ...
  18++CBDF 0D                                   dec	    c		; ...
  19++CBE0 10 F3        NormDIV16UNDOCSKIP:     djnz    NormDIV16UNDOCLOOP
  20++CBE2 79                                   ld      a,c
  21++CBE3 32 06 67                             ld      (varR),a
  22++CBE6 C9                                   ret
  23++CBE7
  24++CBE7 FD 67        Norm256mulAdivQSignA:   ld      iyh,a
  25++CBE9                                      ClearSignBitA
  25++CBE9 E6 7F       >                        and     SignMask8Bit
  26++CBEB CD C6 CB                             call    Norm256mulAdivQ              ; do 15 bit unsigned
  27++CBEE FD 7C                                ld      a,iyh                       ; now correct R reg
  28++CBF0                                      SignBitOnlyA
  28++CBF0 E6 80       >                        and     SignOnly8Bit
  29++CBF2 B1                                   or      c
  30++CBF3 32 06 67                             ld      (varR),a
  31++CBF6 C9                                   ret
  32++CBF7
  33++CBF7              ; Tested OK
  34++CBF7              ;LL21
  35++CBF7              NormaliseTransMat:
  36++CBF7                      IFDEF LOGMATHS
  37++CBF7 ~                            ld      hl,UBnkTransmatNosevZ+1     ; initialise loop
  38++CBF7 ~                            ld      b,9                         ; total of 9 elements to transform
  39++CBF7 ~                            MMUSelectMathsTables
  40++CBF7 ~            .LL21Loop:      ld      d,(hl)
  41++CBF7 ~                            dec     hl
  42++CBF7 ~                            ld      e,(hl)                      ; de = hilo now   hl now = pointer to low byte
  43++CBF7 ~                            ShiftDELeft1                        ; De = DE * 2
  44++CBF7 ~                            ld      a,d                         ; a = hi byte after shifting
  45++CBF7 ~                            push	hl
  46++CBF7 ~                            push	bc
  47++CBF7 ~                            call    AEquAmul256Div197Log        ; R = (2(hi).0)/ConstNorm - LL28 Optimised BFRDIV R=A*256/Q = delta_y / delta_x Use Y/X grad. as not steep
  48++CBF7 ~                            ;ld      a,c                         ; BFRDIV returns R also in l reg
  49++CBF7 ~                            pop		bc
  50++CBF7 ~                            pop		hl							; bc gets wrecked by BFRDIV
  51++CBF7 ~                            ld      (hl),a                      ; write low result to low byte so zlo = (zhl *2)/197, we keep hi byte in tact as we need the sign bit
  52++CBF7 ~                            dec     hl                          ; now hl = hi byte of pre val e.g z->y->x
  53++CBF7 ~                            djnz    .LL21Loop                   ; loop from 2zLo through to 0xLo
  54++CBF7 ~                            MMUSelectROM0
  55++CBF7 ~                            ret
  56++CBF7                      ELSE
  57++CBF7 21 B3 C0                     ld      hl,UBnkTransmatNosevZ+1         ; initialise loop
  58++CBFA 0E C5                        ld      c,ConstNorm                 ; c = Q = norm = 197
  59++CBFC 79                           ld      a,c
  60++CBFD 32 05 67                     ld      (varQ),a                    ; set up varQ
  61++CC00 06 09                        ld      b,9                         ; total of 9 elements to transform
  62++CC02 56           LL21Loop:       ld      d,(hl)
  63++CC03 2B                           dec     hl
  64++CC04 5E                           ld      e,(hl)                      ; de = hilo now   hl now = pointer to low byte
  65++CC05                              ShiftDELeft1                        ; De = DE * 2
  65++CC05 CB 23       >               sla e
  65++CC07 CB 12       >               rl  d
  66++CC09 7A                           ld      a,d                         ; a = hi byte after shifting
  67++CC0A E5                           push	hl
  68++CC0B C5                           push	bc
  69++CC0C CD C6 CB                     call    Norm256mulAdivQ
  70++CC0F                              ;===call    RequAmul256divC				; R = (2(hi).0)/ConstNorm - LL28 Optimised BFRDIV R=A*256/Q = delta_y / delta_x Use Y/X grad. as not steep
  71++CC0F 79                           ld      a,c                         ; BFRDIV returns R also in l reg
  72++CC10 C1                           pop		bc
  73++CC11 E1                           pop		hl							; bc gets wrecked by BFRDIV
  74++CC12 77                           ld      (hl),a                      ; write low result to low byte so zlo = (zhl *2)/197, we keep hi byte in tact as we need the sign bit
  75++CC13 2B                           dec     hl                          ; now hl = hi byte of pre val e.g z->y->x
  76++CC14 10 EC                        djnz    LL21Loop                    ; loop from 2zLo through to 0xLo
  77++CC16 C9                           ret
  78++CC17                      ENDIF
# file closed: ../../Tests/3DTest/../../Universe/Ships/NormaliseTransMat.asm
 421+ CC17              ;--------------------------------------------------------------------------------------------------------
 422+ CC17                                      include "../../Universe/Ships/InverseXX16.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/InverseXX16.asm
   1++CC17              ; TESTEDOK
   2++CC17
   3++CC17              ;ScaleOrientationXX16:                       ; DEBUG TODO will combine with inverse later
   4++CC17              ;        ld      a,(XX17)
   5++CC17              ;        ld      ixl,a
   6++CC17              ;        ld      ixh,9
   7++CC17              ;        ld      hl,UBnkTransInv0x
   8++CC17              ;        ld      a,(hl)
   9++CC17              ;ScaleNode:
  10++CC17              ;        ld      b,ixl
  11++CC17              ;ScaleNodeLoop:
  12++CC17              ;        sla      a
  13++CC17              ;        djnz    ScaleNodeLoop
  14++CC17              ;        ld      (hl),a
  15++CC17              ;        inc     hl
  16++CC17              ;        inc     hl
  17++CC17              ;        dec     ixh
  18++CC17              ;        jr      nz,ScaleNode
  19++CC17              ;        ret
  20++CC17
  21++CC17
  22++CC17              InverseXX16:								; lead routine into .LL42	\ ->  &4B04 \ DO nodeX-Ycoords their comment  \  TrnspMat
  23++CC17              ; we coudl combine this with move to transmat later as an optimisation
  24++CC17              ; INPUT - All Scaled
  25++CC17              ;  They transmat has already been put into side, roof nose order
  26++CC17              ;  XX16   = |sidev_x| |sidev_y| |sidev_z|  1  0  3  2  5  4 note each bytepair is Scaled value in low and high byte just for sign
  27++CC17              ;  XX16   = |roofv_x| |roofv_y| |roofv_z|  7  6  8  9 11 10
  28++CC17              ;  XX16   = |nosev_x| |nosev_y| |nosev_z| 13 12 15 14 17 16
  29++CC17              ; OUTPUT
  30++CC17              ;  XX16(1 0)   ( 3 2) ( 5 4 ) =  sidev_x roofv_x nosev_x
  31++CC17              ;  XX16(7 6)   ( 8 9) (11 10) =  sidev_y roofv_y nosev_y
  32++CC17              ;  XX16(13 12) (15 14)(17 16) =  sidev_z roofv_z nosev_z
  33++CC17              ; First all side values become compoment 0 of each vector
  34++CC17 2A A2 C0             ld      hl,(UBnkTransmatSidevX)     ;
  35++CC1A ED 5B A8 C0          ld      de,(UBnkTransmatRoofvX)     ;
  36++CC1E ED 4B AE C0          ld      bc,(UBnkTransmatNosevX)     ;
  37++CC22 22 BA C0             ld      (UbnkTransInvRow0x0),hl     ;
  38++CC25 ED 53 BC C0          ld      (UbnkTransInvRow0x1),de     ;
  39++CC29 ED 43 BE C0          ld      (UbnkTransInvRow0x2),bc     ;
  40++CC2D 2A A4 C0             ld      hl,(UBnkTransmatSidevY)     ;
  41++CC30 ED 5B AA C0          ld      de,(UBnkTransmatRoofvY)     ;
  42++CC34 ED 4B B0 C0          ld      bc,(UBnkTransmatNosevY)     ;
  43++CC38 22 C2 C0             ld      (UbnkTransInvRow1y0),hl     ;
  44++CC3B ED 53 C4 C0          ld      (UbnkTransInvRow1y1),de     ;
  45++CC3F ED 43 C6 C0          ld      (UbnkTransInvRow1y2),bc     ;
  46++CC43 2A A6 C0             ld      hl,(UBnkTransmatSidevZ)     ;
  47++CC46 ED 5B AC C0          ld      de,(UBnkTransmatRoofvZ)     ;
  48++CC4A ED 4B B2 C0          ld      bc,(UBnkTransmatNosevZ)     ;
  49++CC4E 22 CA C0             ld      (UbnkTransInvRow2z0),hl     ;
  50++CC51 ED 53 CC C0          ld      (UbnkTransInvRow2z1),de     ;
  51++CC55 ED 43 CE C0          ld      (UbnkTransInvRow2z2),bc     ;
  52++CC59 C9                   ret
  53++CC5A
  54++CC5A
# file closed: ../../Tests/3DTest/../../Universe/Ships/InverseXX16.asm
 423+ CC5A              ;--------------------------------------------------------------------------------------------------------
 424+ CC5A              XX12DotOneRow:
 425+ CC5A              XX12CalcX:              N0equN1byN2div256 varT, (hl), (UBnkXScaled)       ; T = (hl) * regXX15fx /256
 425+ CC5A 3A E7 C0    >                        ld      a,(UBnkXScaled)                        ;
 425+ CC5D 5F          >                        ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 425+ CC5E 7E          >                        ld      a,(hl)                        ; A = XX16 element
 425+ CC5F 57          >                        ld      d,a
 425+ CC60 ED 30       >                        mul
 425+ CC62 7A          >                        ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 425+ CC63 32 21 67    >                        ld      (varT),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 426+ CC66 23                                   inc     hl                                  ; move to sign byte
 427+ CC67              XX12CalcXSign:          AequN1xorN2 UBnkXScaledSign,(hl)             ;
 427+ CC67 3A E8 C0    >                        ld      a,(UBnkXScaledSign)
 427+ CC6A AE          >                        xor     (hl)
 428+ CC6B 32 07 67                             ld      (varS),a                            ; Set S to the sign of x_sign * sidev_x
 429+ CC6E 23                                   inc     hl
 430+ CC6F              XX12CalcY:              N0equN1byN2div256 varQ, (hl),(UBnkYScaled)       ; Q = XX16 * XX15 /256 using varQ to hold regXX15fx
 430+ CC6F 3A E9 C0    >                        ld      a,(UBnkYScaled)                        ;
 430+ CC72 5F          >                        ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 430+ CC73 7E          >                        ld      a,(hl)                        ; A = XX16 element
 430+ CC74 57          >                        ld      d,a
 430+ CC75 ED 30       >                        mul
 430+ CC77 7A          >                        ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 430+ CC78 32 05 67    >                        ld      (varQ),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 431+ CC7B                                      ldCopyByte varT,varR                        ; R = T =  |sidev_x| * x_lo / 256
 431+ CC7B 3A 21 67    >                        ld       a,(varT)
 431+ CC7E 32 06 67    >                        ld       (varR),a
 432+ CC81 23                                   inc     hl
 433+ CC82                                      AequN1xorN2 UBnkYScaledSign,(hl)             ; Set A to the sign of y_sign * sidev_y
 433+ CC82 3A EA C0    >                        ld      a,(UBnkYScaledSign)
 433+ CC85 AE          >                        xor     (hl)
 434+ CC86              ; (S)A = |sidev_x| * x_lo / 256  = |sidev_x| * x_lo + |sidev_y| * y_lo
 435+ CC86 E5           STequSRplusAQ           push    hl
 436+ CC87 CD CE 76                             call    baddll38                            ; JSR &4812 \ LL38   \ BADD(S)A=R+Q(SA) \ 1byte add (subtract)
 437+ CC8A E1                                   pop     hl
 438+ CC8B 32 21 67                             ld      (varT),a                            ; T = |sidev_x| * x_lo + |sidev_y| * y_lo
 439+ CC8E 23                                   inc     hl
 440+ CC8F              XX12CalcZ:              N0equN1byN2div256 varQ,(hl),(UBnkZScaled)       ; Q = |sidev_z| * z_lo / 256
 440+ CC8F 3A EB C0    >                        ld      a,(UBnkZScaled)                        ;
 440+ CC92 5F          >                        ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 440+ CC93 7E          >                        ld      a,(hl)                        ; A = XX16 element
 440+ CC94 57          >                        ld      d,a
 440+ CC95 ED 30       >                        mul
 440+ CC97 7A          >                        ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 440+ CC98 32 05 67    >                        ld      (varQ),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 441+ CC9B                                      ldCopyByte varT,varR                        ; R = |sidev_x| * x_lo + |sidev_y| * y_lo
 441+ CC9B 3A 21 67    >                        ld       a,(varT)
 441+ CC9E 32 06 67    >                        ld       (varR),a
 442+ CCA1 23                                   inc     hl
 443+ CCA2                                      AequN1xorN2 UBnkZScaledSign,(hl)             ; A = sign of z_sign * sidev_z
 443+ CCA2 3A EC C0    >                        ld      a,(UBnkZScaledSign)
 443+ CCA5 AE          >                        xor     (hl)
 444+ CCA6              ; (S)A= |sidev_x| * x_lo + |sidev_y| * y_lo + |sidev_z| * z_lo
 445+ CCA6 CD CE 76                             call    baddll38                            ; JSR &4812 \ LL38   \ BADD(S)A=R+Q(SA)   \ 1byte add (subtract)
 446+ CCA9              ; Now we exit with A = result S = Sign
 447+ CCA9 C9                                   ret
 448+ CCAA
 449+ CCAA
 450+ CCAA                  DISPLAY "Tracing 4", $
 451+ CCAA
 452+ CCAA              ;-- LL51---------------------------------------------------------------------------------------------------------------------------
 453+ CCAA              ;TESTED OK
 454+ CCAA              ;XX12EquScaleDotOrientation:                         ; .LL51 \ -> &4832 \ XX12=XX15.XX16  each vector is 16-bit x,y,z
 455+ CCAA              XX12EquXX15DotProductXX16:
 456+ CCAA 01 00 00                             ld      bc,0                                ; LDX, LDY 0
 457+ CCAD 21 A2 C0                             ld      hl,UBnkTransmatSidevX
 458+ CCB0 CD 5A CC                             call    XX12DotOneRow
 459+ CCB3 32 ED C0                             ld      (UBnkXX12xLo),a
 460+ CCB6 3A 07 67                             ld      a,(varS)
 461+ CCB9 32 EE C0                             ld      (UBnkXX12xSign),a
 462+ CCBC 21 A8 C0                             ld      hl,UBnkTransmatRoofvX
 463+ CCBF CD 5A CC                             call    XX12DotOneRow
 464+ CCC2 32 EF C0                             ld      (UBnkXX12yLo),a
 465+ CCC5 3A 07 67                             ld      a,(varS)
 466+ CCC8 32 F0 C0                             ld      (UBnkXX12ySign),a
 467+ CCCB 21 AE C0                             ld      hl,UBnkTransmatNosevX
 468+ CCCE CD 5A CC                             call    XX12DotOneRow
 469+ CCD1 32 F1 C0                             ld      (UBnkXX12zLo),a
 470+ CCD4 3A 07 67                             ld      a,(varS)
 471+ CCD7 32 F2 C0                             ld      (UBnkXX12zSign),a
 472+ CCDA C9                                   ret
 473+ CCDB              ;--------------------------------------------------------------------------------------------------------
 474+ CCDB                                      INCLUDE "../../Universe/Ships/CopyXX12ScaledToXX18.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/CopyXX12ScaledToXX18.asm
   1++CCDB              CopyXX12ScaledToXX18:
   2++CCDB              CopyResultToDrawCam:
   3++CCDB                      ldCopyByte XX12         ,XX18             ; XX12+0 => XX18+0  Set XX18(2 0) = dot_sidev
   3++CCDB 3A ED C0    >                        ld       a,(XX12)
   3++CCDE 32 DB C0    >                        ld       (XX18),a
   4++CCE1                      ldCopyByte XX12+1       ,XX18+2           ; XX12+1 => XX18+2
   4++CCE1 3A EE C0    >                        ld       a,(XX12+1)
   4++CCE4 32 DD C0    >                        ld       (XX18+2),a
   5++CCE7                      ldCopyByte XX12+2       ,XX18+3           ; XX12+2 => XX18+3  Set XX12+1 => XX18+2
   5++CCE7 3A EF C0    >                        ld       a,(XX12+2)
   5++CCEA 32 DE C0    >                        ld       (XX18+3),a
   6++CCED                      ldCopyByte XX12+3       ,XX18+5           ; XX12+3 => XX18+5
   6++CCED 3A F0 C0    >                        ld       a,(XX12+3)
   6++CCF0 32 E0 C0    >                        ld       (XX18+5),a
   7++CCF3                      ldCopyByte XX12+4       ,XX18+6           ; XX12+4 => XX18+6  Set XX18(8 6) = dot_nosev
   7++CCF3 3A F1 C0    >                        ld       a,(XX12+4)
   7++CCF6 32 E1 C0    >                        ld       (XX18+6),a
   8++CCF9                      ldCopyByte XX12+5       ,XX18+8           ; XX12+5 => XX18+8
   8++CCF9 3A F2 C0    >                        ld       a,(XX12+5)
   8++CCFC 32 E3 C0    >                        ld       (XX18+8),a
   9++CCFF C9                   ret
  10++CD00
# file closed: ../../Tests/3DTest/../../Universe/Ships/CopyXX12ScaledToXX18.asm
 475+ CD00                                      INCLUDE "../../Universe/Ships/CopyXX12toXX15.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/CopyXX12toXX15.asm
   1++CD00              CopyXX12toXX15:         ldCopyByte  UBnkXX12xLo     ,UBnkXScaled        ; xlo
   1++CD00 3A ED C0    >                        ld       a,(UBnkXX12xLo)
   1++CD03 32 E7 C0    >                        ld       (UBnkXScaled),a
   2++CD06                                      ldCopyByte  UBnkXX12xSign   ,UBnkXScaledSign    ; xsg
   2++CD06 3A EE C0    >                        ld       a,(UBnkXX12xSign)
   2++CD09 32 E8 C0    >                        ld       (UBnkXScaledSign),a
   3++CD0C                                      ldCopyByte  UBnkXX12yLo     ,UBnkYScaled        ; xlo
   3++CD0C 3A EF C0    >                        ld       a,(UBnkXX12yLo)
   3++CD0F 32 E9 C0    >                        ld       (UBnkYScaled),a
   4++CD12                                      ldCopyByte  UBnkXX12ySign   ,UBnkYScaledSign    ; xsg
   4++CD12 3A F0 C0    >                        ld       a,(UBnkXX12ySign)
   4++CD15 32 EA C0    >                        ld       (UBnkYScaledSign),a
   5++CD18                                      ldCopyByte  UBnkXX12zLo     ,UBnkZScaled        ; xlo
   5++CD18 3A F1 C0    >                        ld       a,(UBnkXX12zLo)
   5++CD1B 32 EB C0    >                        ld       (UBnkZScaled),a
   6++CD1E                                      ldCopyByte  UBnkXX12zSign   ,UBnkZScaledSign    ; xsg
   6++CD1E 3A F2 C0    >                        ld       a,(UBnkXX12zSign)
   6++CD21 32 EC C0    >                        ld       (UBnkZScaledSign),a
   7++CD24 C9                                   ret
   8++CD25
# file closed: ../../Tests/3DTest/../../Universe/Ships/CopyXX12toXX15.asm
 476+ CD25                                      INCLUDE "../../Universe/Ships/CopyXX18toXX15.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/CopyXX18toXX15.asm
   1++CD25              CopyXX18toXX15:
   2++CD25              CopyDrawCamToScaled:
   3++CD25                      ldCopyByte  UBnkDrawCam0xLo ,UBnkXScaled        ; xlo
   3++CD25 3A DB C0    >                        ld       a,(UBnkDrawCam0xLo)
   3++CD28 32 E7 C0    >                        ld       (UBnkXScaled),a
   4++CD2B                      ldCopyByte  UBnkDrawCam0xSgn,UBnkXScaledSign    ; xsg
   4++CD2B 3A DD C0    >                        ld       a,(UBnkDrawCam0xSgn)
   4++CD2E 32 E8 C0    >                        ld       (UBnkXScaledSign),a
   5++CD31                      ldCopyByte  UBnkDrawCam0yLo ,UBnkYScaled        ; xlo
   5++CD31 3A DE C0    >                        ld       a,(UBnkDrawCam0yLo)
   5++CD34 32 E9 C0    >                        ld       (UBnkYScaled),a
   6++CD37                      ldCopyByte  UBnkDrawCam0ySgn,UBnkYScaledSign    ; xsg
   6++CD37 3A E0 C0    >                        ld       a,(UBnkDrawCam0ySgn)
   6++CD3A 32 EA C0    >                        ld       (UBnkYScaledSign),a
   7++CD3D                      ldCopyByte  UBnkDrawCam0zLo ,UBnkZScaled        ; xlo
   7++CD3D 3A E1 C0    >                        ld       a,(UBnkDrawCam0zLo)
   7++CD40 32 EB C0    >                        ld       (UBnkZScaled),a
   8++CD43                      ldCopyByte  UBnkDrawCam0zSgn,UBnkZScaledSign    ; xsg
   8++CD43 3A E3 C0    >                        ld       a,(UBnkDrawCam0zSgn)
   8++CD46 32 EC C0    >                        ld       (UBnkZScaledSign),a
   9++CD49 C9                   ret
  10++CD4A
# file closed: ../../Tests/3DTest/../../Universe/Ships/CopyXX18toXX15.asm
 477+ CD4A                                      INCLUDE "../../Universe/Ships/CopyXX18ScaledToXX15.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/CopyXX18ScaledToXX15.asm
   1++CD4A 2A 20 C0     LoadCraftToCamera:      ld      hl,(UBnKxlo)            ; UBnKxlo, UBnKxhi
   2++CD4D ED 5B 22 C0                          ld      de,(UBnKxsgn)           ; UBnKxsgn, UBnKylo
   3++CD51 ED 4B 24 C0                          ld      bc,(UBnKyhi)            ; UBnKyhi, UBnKysgn
   4++CD55 22 DB C0                             ld      (UBnkDrawCam0xLo),hl    ; UBnkDrawCam0xLo, UBnkDrawCam0xHi
   5++CD58 ED 53 DD C0                          ld      (UBnkDrawCam0xSgn),de   ; UBnkDrawCam0xSgn,UBnkDrawCam0yLo
   6++CD5C ED 43 DF C0                          ld      (UBnkDrawCam0yHi),bc    ; UBnkDrawCam0yHi, UBnkDrawCam0ySgn
   7++CD60
   8++CD60 2A 26 C0                             ld      hl,(UBnKzlo)            ; UBnKzlo, UBnKzhi
   9++CD63 3A 28 C0                             ld      a,(UBnKzsgn)             ; UBnKzlo
  10++CD66 22 E1 C0                             ld      (UBnkDrawCam0zLo),hl    ; UBnkDrawCam0zLo, UBnkDrawCam0zHi
  11++CD69 32 E3 C0                             ld      (UBnkDrawCam0zSgn),a    ; UBnkDrawCam0zSgn
  12++CD6C C9                                   ret
  13++CD6D              ;                       ld      hl,UBnKxlo
  14++CD6D              ;                       ld      de,UBnkDrawCam0xLo
  15++CD6D              ;                       NineLDIInstrunctions                ; transfer 9 bytes
  16++CD6D C9                                   ret
  17++CD6E
  18++CD6E 2A DB C0     CopyCameraToXX15Signed: ld  hl,(UBnkDrawCam0xLo)
  19++CD71 3A DD C0                             ld  a,(UBnkDrawCam0xSgn)
  20++CD74 B4                                   or  h
  21++CD75 67                                   ld  h,a
  22++CD76 22 E7 C0                             ld  (UBnkXScaled),hl
  23++CD79 2A DE C0                             ld  hl,(UBnkDrawCam0yLo)
  24++CD7C 3A E0 C0                             ld  a,(UBnkDrawCam0ySgn)
  25++CD7F B4                                   or  h
  26++CD80 67                                   ld  h,a
  27++CD81 22 E9 C0                             ld  (UBnkYScaled),hl
  28++CD84 2A E1 C0                             ld  hl,(UBnkDrawCam0zLo)
  29++CD87 3A E3 C0                             ld  a,(UBnkDrawCam0zSgn)
  30++CD8A B4                                   or  h
  31++CD8B 67                                   ld  h,a
  32++CD8C 22 EB C0                             ld  (UBnkZScaled),hl
  33++CD8F C9                                   ret
  34++CD90
  35++CD90              ;;;CopyXX18ScaledToXX15:
  36++CD90              ;;;CopyDrawCamToScaledMatrix:
  37++CD90              ;;;        ldCopyByte  UBnkDrawCam0zSgn, UBnkZScaledSign   ; XX18+8 => XX15+5
  38++CD90              ;;;        ldCopyByte  UBnkDrawCam0xLo,  UBnkXScaled       ; XX18+0 => XX15+0
  39++CD90              ;;;        ldCopyByte  UBnkDrawCam0xSgn, UBnkXScaledSign   ; XX18+2 => XX15+1
  40++CD90              ;;;        ldCopyByte  UBnkDrawCam0yLo,  UBnkYScaled       ; XX18+3 => XX15+2
  41++CD90              ;;;        ldCopyByte  UBnkDrawCam0ySgn, UBnkYScaledSign   ; XX18+5 => XX15+3
  42++CD90              ;;;        ldCopyByte  UBnkDrawCam0zLo,  UBnkZScaled       ; XX18+6 => XX15+4
  43++CD90              ;;;        ret
  44++CD90
  45++CD90              ;;;CopyXX15ToXX18Scaled:
  46++CD90              ;;;CopyScaledMatrixToDrawCam:
  47++CD90              ;;;        ldCopyByte UBnkZScaledSign,   UBnkDrawCam0zSgn  ; XX15+5 => XX18+8
  48++CD90              ;;;        ldCopyByte UBnkXScaled,       UBnkDrawCam0xLo   ; XX15+0 => XX18+0
  49++CD90              ;;;        ldCopyByte UBnkXScaledSign,   UBnkDrawCam0xSgn  ; XX15+1 => XX18+2
  50++CD90              ;;;        ldCopyByte UBnkYScaled,       UBnkDrawCam0yLo   ; XX15+2 => XX18+3
  51++CD90              ;;;        ldCopyByte UBnkYScaledSign,   UBnkDrawCam0ySgn  ; XX15+3 => XX18+5
  52++CD90              ;;;        ldCopyByte UBnkZScaled,       UBnkDrawCam0zLo   ; XX15+4 => XX18+6
  53++CD90              ;;;        ret
  54++CD90
  55++CD90
  56++CD90              XX15EquXX15AddXX18:
  57++CD90              LL94Z:
  58++CD90 26 00                ld      h,0                                                     ;           AddZ = FaceData (XX12)z +  ShipPos (XX18)z
  59++CD92 16 00                ld      d,0                                                     ;
  60++CD94 3A EB C0             ld      a,(UBnkZScaled)                                         ;
  61++CD97 6F                   ld      l,a                                                     ;
  62++CD98 3A EC C0             ld      a,(UBnkZScaledSign)                                     ;
  63++CD9B 47                   ld      b,a                                                     ;
  64++CD9C 3A E1 C0             ld      a,(UBnkDrawCam0zLo)                                     ;
  65++CD9F 5F                   ld      e,a                                                     ;
  66++CDA0 3A E3 C0             ld      a,(UBnkDrawCam0zSgn)                                    ;
  67++CDA3 4F                   ld      c,a                                                     ;
  68++CDA4 CD 33 00             call    ADDHLDESignBC                                           ;
  69++CDA7 47                   ld      b,a                                                     ;
  70++CDA8 7C                   ld      a,h                                                     ;
  71++CDA9 78                   ld      a,b                                                     ;           else  Scaled (XX15) Z = AddZ
  72++CDAA 32 EC C0             ld      (UBnkZScaledSign),a                                     ;
  73++CDAD 7D                   ld      a,l                                                     ;
  74++CDAE 32 EB C0             ld      (UBnkZScaled),a                                         ;           endif
  75++CDB1              LL94X:
  76++CDB1 26 00                ld      h,0                                                     ;           AddZ = FaceData (XX12)z +  ShipPos (XX18)z
  77++CDB3 16 00                ld      d,0                                                     ;
  78++CDB5 3A E7 C0             ld      a,(UBnkXScaled)                                         ;
  79++CDB8 6F                   ld      l,a                                                     ;
  80++CDB9 3A E8 C0             ld      a,(UBnkXScaledSign)                                     ;
  81++CDBC 47                   ld      b,a                                                     ;
  82++CDBD 3A DB C0             ld      a,(UBnkDrawCam0xLo)                                     ;
  83++CDC0 5F                   ld      e,a                                                     ;
  84++CDC1 3A DD C0             ld      a,(UBnkDrawCam0xSgn)                                    ;
  85++CDC4 4F                   ld      c,a                                                     ;
  86++CDC5 CD 33 00             call    ADDHLDESignBC                                           ;
  87++CDC8 47                   ld      b,a                                                     ;
  88++CDC9 7C                   ld      a,h                                                     ;
  89++CDCA 78                   ld      a,b                                                     ;           else  Scaled (XX15) Z = AddZ
  90++CDCB 32 E8 C0             ld      (UBnkXScaledSign),a                                     ;
  91++CDCE 7D                   ld      a,l                                                     ;
  92++CDCF 32 E7 C0             ld      (UBnkXScaled),a                                         ;           endif
  93++CDD2              LL94Y:
  94++CDD2 26 00                ld      h,0                                                     ;           AddZ = FaceData (XX12)z +  ShipPos (XX18)z
  95++CDD4 16 00                ld      d,0                                                     ;
  96++CDD6 3A E9 C0             ld      a,(UBnkYScaled)                                         ;
  97++CDD9 6F                   ld      l,a                                                     ;
  98++CDDA 3A EA C0             ld      a,(UBnkYScaledSign)                                     ;
  99++CDDD 47                   ld      b,a                                                     ;
 100++CDDE 3A DE C0             ld      a,(UBnkDrawCam0yLo)                                     ;
 101++CDE1 5F                   ld      e,a                                                     ;
 102++CDE2 3A E0 C0             ld      a,(UBnkDrawCam0ySgn)                                    ;
 103++CDE5 4F                   ld      c,a                                                     ;
 104++CDE6 CD 33 00             call    ADDHLDESignBC                                           ;
 105++CDE9 47                   ld      b,a                                                     ;
 106++CDEA 7C                   ld      a,h                                                     ;
 107++CDEB 78                   ld      a,b                                                     ;           else  Scaled (XX15) Z = AddZ
 108++CDEC 32 EA C0             ld      (UBnkYScaledSign),a                                     ;
 109++CDEF 7D                   ld      a,l                                                     ;
 110++CDF0 32 E9 C0             ld      (UBnkYScaled),a                                         ;
 111++CDF3 C9                   ret
 112++CDF4
# file closed: ../../Tests/3DTest/../../Universe/Ships/CopyXX18ScaledToXX15.asm
 478+ CDF4                                      INCLUDE "../../Universe/Ships/CopyXX12ToScaled.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/CopyXX12ToScaled.asm
   1++CDF4              CopyXX12ToScaled:
   2++CDF4              CopyResultToScaled:
   3++CDF4                      ldCopyByte  XX12+0,UBnkXScaled      ; xnormal lo
   3++CDF4 3A ED C0    >                        ld       a,(XX12+0)
   3++CDF7 32 E7 C0    >                        ld       (UBnkXScaled),a
   4++CDFA                      ldCopyByte  XX12+2,UBnkYScaled      ; ynormal lo
   4++CDFA 3A EF C0    >                        ld       a,(XX12+2)
   4++CDFD 32 E9 C0    >                        ld       (UBnkYScaled),a
   5++CE00                      ldCopyByte  XX12+4,UBnkZScaled      ; znormal lo and leaves a holding zscaled normal
   5++CE00 3A F1 C0    >                        ld       a,(XX12+4)
   5++CE03 32 EB C0    >                        ld       (UBnkZScaled),a
   6++CE06 C9                   ret
   7++CE07
# file closed: ../../Tests/3DTest/../../Universe/Ships/CopyXX12ToScaled.asm
 479+ CE07              ;--------------------------------------------------------------------------------------------------------
 480+ CE07                                      INCLUDE "../../Maths/Utilities/DotProductXX12XX15.asm"
# file opened: ../../Tests/3DTest/../../Maths/Utilities/DotProductXX12XX15.asm
   1++CE07              ;;; Q = XX12 xLo ,A = XX15 xLo
   2++CE07              ;;; T = A * Q/256 Usgined  (FMLTU)
   3++CE07              ;;; S = XX12 XSign Xor XX15 XSign
   4++CE07              ;;; Q = XX12 Ynormal Lo, A = XX15+2 (y lo)
   5++CE07              ;;; Q = A * Q/256 Usigned (FMLTI)
   6++CE07              ;;; R = T
   7++CE07              ;;; A = XX12+3 (ySign) Xor XX15+3 (ySign)
   8++CE07              ;;; T = BADD s(A) = R + Q(SA) (xdot + ydot)
   9++CE07              ;;; Q = XX12+4 (znormal lo) A = XX15+4 z lo
  10++CE07              ;;; Q = A * Q /256 usigned (zdot)
  11++CE07              ;;; R = T
  12++CE07              ;;; A - XX15+ 5 Zsign Xor XX12+5 Z Sign
  13++CE07
  14++CE07
  15++CE07
  16++CE07
  17++CE07
  18++CE07              MacroAequDxEdiv256usgn:	MACRO
  19++CE07 ~            						mul
  20++CE07 ~            						ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
  21++CE07              						ENDM
  22++CE07              DotProductXX12XX15:
  23++CE07 3A ED C0             ld          a,(UBnkXX12xLo)         ; Use e as var Q for xnormal lo
  24++CE0A                      JumpIfAIsZero dotxskipzero
  24++CE0A A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  24++CE0B CA 28 CE    >                        jp	    z, dotxskipzero
  25++CE0E 5F                   ld          e,a
  26++CE0F 3A E7 C0             ld          a,(UBnkXScaled)         ; use d as XX12 world xform x, e = norm x
  27++CE12 57                   ld          d,a                     ; de = xx12 x signed
  28++CE13                      JumpIfAIsZero dotxskipzero
  28++CE13 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  28++CE14 CA 28 CE    >                        jp	    z, dotxskipzero
  29++CE17 ED 30        		mul
  30++CE19 42                   ld          b,d                     ; b = result
  31++CE1A 3A EE C0             ld          a,(UBnkXX12xSign)
  32++CE1D 21 E8 C0             ld          hl,UBnkXScaledSign
  33++CE20 AE                   xor         (hl)
  34++CE21 E6 80                and         $80                     ; so sign bit only
  35++CE23 FD 67                ld          iyh ,a                   ; we actually need to preserve sign in iyh here
  36++CE25 C3 2C CE             jp          dotmuly
  37++CE28              dotxskipzero:
  38++CE28 AF                   xor         a
  39++CE29 47                   ld          b,a
  40++CE2A FD 67                ld          iyh,a
  41++CE2C              dotmuly:
  42++CE2C              ; now we have b = XX12 x &d  norm x signed
  43++CE2C 3A EF C0             ld          a,(UBnkXX12yLo)
  44++CE2F                      JumpIfAIsZero dotyskipzero
  44++CE2F A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  44++CE30 CA 4F CE    >                        jp	    z, dotyskipzero
  45++CE33 5F                   ld          e,a
  46++CE34 3A E9 C0             ld          a,(UBnkYScaled)         ; XX15+2
  47++CE37                      JumpIfAIsZero dotyskipzero
  47++CE37 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  47++CE38 CA 4F CE    >                        jp	    z, dotyskipzero
  48++CE3B 57                   ld          d,a                     ; de = xx12 x signed
  49++CE3C ED 30                mul
  50++CE3E 4A                   ld          c,d                     ; c = result
  51++CE3F DD 69                ld          ixl,c
  52++CE41 3A F0 C0             ld          a,(UBnkXX12ySign)       ; A = ysg
  53++CE44 21 EA C0             ld          hl, UBnkYScaledSign     ; a= y sign XOR Y scaled sign
  54++CE47 AE                   xor         (hl)                    ; XX15+3
  55++CE48 E6 80                and         $80                     ; do b = x mul c = y mul, iyh = sign for b and a = sign for c
  56++CE4A DD 67                ld          ixh,a
  57++CE4C C3 53 CE             jp          dotaddxy
  58++CE4F              dotyskipzero:
  59++CE4F AF                   xor         a
  60++CE50 4F                   ld          c,a
  61++CE51 DD 67                ld          ixh,a
  62++CE53              dotaddxy:
  63++CE53              ; Optimise later as this is 16 bit
  64++CE53 26 00                ld          h,0                     ;
  65++CE55 68                   ld          l,b                     ; hl = xlo + x scaled
  66++CE56 16 00                ld          d,0                     ;
  67++CE58 59                   ld          e,c                     ; de = ylo + yscaled
  68++CE59 FD 44                ld          b,iyh                   ; b = sign of xlo + xscaled
  69++CE5B 4F                   ld          c,a                     ; c = sign of ylo + yscaled
  70++CE5C CD 33 00             call ADDHLDESignBC                  ; so now hl = result so will push sign to h
  71++CE5F 47                   ld          b,a                     ; b = resultant sign , hl = add so far
  72++CE60 3A F1 C0             ld          a,(UBnkXX12zLo)         ;
  73++CE63                      JumpIfAIsZero dotzskipzero
  73++CE63 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  73++CE64 CA 89 CE    >                        jp	    z, dotzskipzero
  74++CE67 5F                   ld          e,a                     ;
  75++CE68 3A EB C0             ld          a,(UBnkZScaled)         ;
  76++CE6B                      JumpIfAIsZero dotzskipzero
  76++CE6B A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  76++CE6C CA 89 CE    >                        jp	    z, dotzskipzero
  77++CE6F 57                   ld          d,a
  78++CE70 ED 30                mul
  79++CE72 E5                   push        hl                      ; save prev result
  80++CE73 3A EC C0             ld          a,(UBnkZScaledSign)
  81++CE76 21 F2 C0             ld          hl, UBnkXX12zSign       ; XX15+5
  82++CE79 AE                   xor         (hl)                    ; hi sign
  83++CE7A E6 80                and         $80                     ; a = sign of multiply
  84++CE7C 4F                   ld          c,a                     ; c = sign of z lo & z scaled
  85++CE7D E1                   pop         hl
  86++CE7E 5A                   ld          e,d
  87++CE7F 16 00                ld          d,0
  88++CE81 CD 33 00             call ADDHLDESignBC
  89++CE84 32 07 67             ld          (varS),a
  90++CE87 7D                   ld          a,l
  91++CE88 C9                   ret                                 ; returns with A = value, varS = sign
  92++CE89              dotzskipzero:                               ; if we got here then z was zero so no component so just tidy up from last add
  93++CE89 78                   ld          a,b
  94++CE8A 32 07 67             ld          (varS),a
  95++CE8D 7D                   ld          a,l
  96++CE8E C9                   ret
  97++CE8F              ;;;;       DotProductXX12XX15:
  98++CE8F              ;;;;       ld          a,(UBnkXX12xLo)         ; Use e as var Q for xnormal lo
  99++CE8F              ;;;;       ld          e,a
 100++CE8F              ;;;;       ld          a,(UBnkXScaled)         ; use d as XX12 world xform x, e = norm x
 101++CE8F              ;;;;       ld          d,a                     ; de = xx12 x signed
 102++CE8F              ;;;;		; FMLTU	\ A=A*Q/256unsg using D as A and E as Q
 103++CE8F              ;;;;		mul
 104++CE8F              ;;;;       ld          b,d                     ; b as var T
 105++CE8F              ;;;;       ld          a,(UBnkXX12xSign)
 106++CE8F              ;;;;       ld          hl,UBnkXScaledSign
 107++CE8F              ;;;;       xor         (hl)
 108++CE8F              ;;;;       and         $80                     ; so sign bit only
 109++CE8F              ;;;;       ld          (varS),a                ; we did use c as S \ S	\ x-sign, but we actually need it in varS for BADD
 110++CE8F              ;;;; now we have b = XX12 x & norm x signed
 111++CE8F              ;;;; by here B = xlo & xscaled C = result sign
 112++CE8F              ;;;;       ld          a,(UBnkXX12yLo)
 113++CE8F              ;;;;       ld          e,a
 114++CE8F              ;;;;       ld          a,(UBnkYScaled)         ; XX15+2
 115++CE8F              ;;;;		ld          d,a						; MISSED THIS EARLIER BUG FIX
 116++CE8F              ;;;;       mul
 117++CE8F              ;;;;       ld          a,d
 118++CE8F              ;;;;       ld          (varQ),a                ; Q = Y y-dot
 119++CE8F              ;;;;       ld          a,b                     ; get back T from above held in b
 120++CE8F              ;;;;       ld          (varR),a                ; R= b \ T	\ x-dot
 121++CE8F              ;;;;       ld          a,(UBnkXX12ySign)       ; A = ysg
 122++CE8F              ;;;;       ld          hl, UBnkYScaledSign     ; a= y sign XOR Y scaled sign
 123++CE8F              ;;;;       xor         (hl)                    ; XX15+3
 124++CE8F              ;;;;       and         $80
 125++CE8F              ;;;;       call        baddll38                ; LL38	\ BADD(S)A=R+Q(SA)   \ 1byte add (subtract)
 126++CE8F              ;;;;       ld          (varT),a                ; var T	\ xdot+ydot
 127++CE8F              ;;;;       ld          a,(UBnkXX12zLo)         ; use d as  varQ        ; XX12+4	\ znormal lo to varQ
 128++CE8F              ;;;;       ld          e,a                     ; use e as var Q
 129++CE8F              ;;;;       ld          a,(UBnkZScaled)         ;
 130++CE8F              ;;;;       ld          d,a
 131++CE8F              ;;;;       mul
 132++CE8F              ;;;;       ld          a,d
 133++CE8F              ;;;;       ld          (varQ),a                ; Q	\ zdot
 134++CE8F              ;;;;       ldCopyByte  varT,varR               ; copy T to R so R = resutl of previous calc
 135++CE8F              ;;;;       ld          a,(UBnkZScaledSign)
 136++CE8F              ;;;;       ld          hl, UBnkXX12zSign       ; XX15+5
 137++CE8F              ;;;;       xor         (hl)                    ; hi sign
 138++CE8F              ;;;;       and         $80
 139++CE8F              ;;;;       call        baddll38                ; LL38	\ BADD(S)A=R+Q(SA)   \ 1byte add (subtract)
 140++CE8F              ;;;;       ret                                 ; returns with A = value, varS = sign
 141++CE8F
# file closed: ../../Tests/3DTest/../../Maths/Utilities/DotProductXX12XX15.asm
 481+ CE8F              ;--------------------------------------------------------------------------------------------------------
 482+ CE8F              ; scale Normal. IXL is xReg and A is loaded with XX17 holds the scale factor to apply
 483+ CE8F              ; Not Used in code      include "Universe/Ships/ScaleNormal.asm"
 484+ CE8F              ;--------------------------------------------------------------------------------------------------------
 485+ CE8F                                      INCLUDE "../../Universe/Ships/ScaleObjectDistance.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/ScaleObjectDistance.asm
   1++CE8F              ScaleObjectDistance:
   2++CE8F              ; ">ScaleObjectDistance, scales camera location and returns c = scaling factor (equiv of X reg)"
   3++CE8F 3A 4A C4             ld      a,(QAddr)                   ; Hull byte #18 normals scaled by 2^Q% DtProd^XX2  their comment   Dot product gives  normals' visibility in XX2
   4++CE92 4F                   ld      c,a                         ; c = Q factor for scaling of normals
   5++CE93              LL90:                                       ; scaling object distance
   6++CE93 3A E2 C0             ld      a,(UBnkDrawCam0zHi)         ; z_hi
   7++CE96 47                   ld      b,a                         ; z_hi (yReg)
   8++CE97                      ReturnIfAIsZero                     ; if zHi 0 test ifis object close/small, i.e. zhi already zero then we are done
   8++CE97 A7          >                        and     a
   8++CE98 C8          >                        ret     z
   9++CE99              LL90Loop:
  10++CE99              ; Loop dividing camera by 2 until zhi is 0 and updating scale factor
  11++CE99 0C                   inc     c                           ; LL90+3 \ repeat INWK z brought closer, take Qscale X up
  12++CE9A                      ShiftMem16Right1 UBnkDrawCam0yLo    ; cam Y /= 2
  12++CE9A 2A DE C0    >                    ld    hl,(UBnkDrawCam0yLo)
  12++CE9D CB 3C       >                    srl   h
  12++CE9F CB 1D       >                    rr    l
  12++CEA1 22 DE C0    >                    ld    (UBnkDrawCam0yLo),hl
  13++CEA4                      ShiftMem16Right1 UBnkDrawCam0xLo    ; cam X /= 2
  13++CEA4 2A DB C0    >                    ld    hl,(UBnkDrawCam0xLo)
  13++CEA7 CB 3C       >                    srl   h
  13++CEA9 CB 1D       >                    rr    l
  13++CEAB 22 DB C0    >                    ld    (UBnkDrawCam0xLo),hl
  14++CEAE                      ShiftMem16Right1 UBnkDrawCam0zLo    ; cam Z /= 2
  14++CEAE 2A E1 C0    >                    ld    hl,(UBnkDrawCam0zLo)
  14++CEB1 CB 3C       >                    srl   h
  14++CEB3 CB 1D       >                    rr    l
  14++CEB5 22 E1 C0    >                    ld    (UBnkDrawCam0zLo),hl
  15++CEB8 7C                   ld      a,h                         ; last shift will result in zhi adjusted into h reg.
  16++CEB9                      JumpIfAIsNotZero LL90Loop           ; loop until z hi = 0 this gives scalinging in c
  16++CEB9 A7          >                        and     a
  16++CEBA C2 99 CE    >                        jp	    nz,LL90Loop
  17++CEBD C9                   ret
  18++CEBE
# file closed: ../../Tests/3DTest/../../Universe/Ships/ScaleObjectDistance.asm
 486+ CEBE              ;--------------------------------------------------------------------------------------------------------
 487+ CEBE
 488+ CEBE              ; Backface cull
 489+ CEBE              ; is the angle between the ship -> camera vector and the normal of the face as long as both are unit vectors soo we can check that normal z > 0
 490+ CEBE              ; normal vector = cross product of ship ccordinates
 491+ CEBE              ;
 492+ CEBE                                      INCLUDE "../../Universe/Ships/CopyFaceToXX15.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/CopyFaceToXX15.asm
   1++CEBE 7E           CopyFaceToXX15:         ld      a,(hl)                      ; get Normal byte 0                                                                    ;;;     if visibility (bits 4 to 0 of byte 0) > XX4
   2++CEBF 47                                   ld      b,a                                                    ;;;
   3++CEC0 E6 80                                and     SignOnly8Bit
   4++CEC2 32 E8 C0                             ld      (UBnkXScaledSign),a           ; write Sign bits to x sign                                                            ;;;
   5++CEC5 78                                   ld      a,b
   6++CEC6 CB 27                                sla     a                           ; move y sign to bit 7                                                                 ;;;   copy sign bits to XX12
   7++CEC8 47                                   ld      b,a
   8++CEC9 E6 80                                and     SignOnly8Bit
   9++CECB 32 EA C0                             ld      (UBnkYScaledSign),a           ;                                                                                      ;;;
  10++CECE 78                                   ld      a,b
  11++CECF CB 27                                sla     a                           ; move y sign to bit 7                                                                 ;;;   copy sign bits to XX12
  12++CED1 E6 80                                and     SignOnly8Bit
  13++CED3 32 EC C0                             ld      (UBnkZScaledSign),a           ;                                                                                      ;;;
  14++CED6 23                                   inc     hl                          ; move to X ccord
  15++CED7 7E                                   ld      a,(hl)                      ;                                                                                      ;;;   XX12 x,y,z lo = Normal[loop].x,y,z
  16++CED8 32 E7 C0                             ld      (UBnkXScaled),a                                                                                                    ;;;
  17++CEDB 23                                   inc     hl                                                                                                                 ;;;
  18++CEDC 7E                                   ld      a,(hl)                      ;                                                                                      ;;;
  19++CEDD 32 E9 C0                             ld      (UBnkYScaled),a                                                                                                    ;;;
  20++CEE0 23                                   inc     hl                                                                                                                 ;;;
  21++CEE1 7E                                   ld      a,(hl)                      ;                                                                                      ;;;
  22++CEE2 32 EB C0                             ld      (UBnkZScaled),a
  23++CEE5 C9                                   ret
  24++CEE6
# file closed: ../../Tests/3DTest/../../Universe/Ships/CopyFaceToXX15.asm
 493+ CEE6                                      INCLUDE "../../Universe/Ships/CopyFaceToXX12.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/CopyFaceToXX12.asm
   1++CEE6 7E           CopyFaceToXX12:         ld      a,(hl)                      ; get Normal byte 0                                                                    ;;;     if visibility (bits 4 to 0 of byte 0) > XX4
   2++CEE7 47                                   ld      b,a                         ; save sign bits to b
   3++CEE8 E6 80                                and     SignOnly8Bit
   4++CEEA 32 EE C0                             ld      (UBnkXX12xSign),a           ; write Sign bits to x sign                                                            ;;;
   5++CEED 78                                   ld      a,b
   6++CEEE CB 27                                sla     a                           ; move y sign to bit 7                                                                 ;;;   copy sign bits to XX12
   7++CEF0 47                                   ld      b,a
   8++CEF1 E6 80                                and     SignOnly8Bit
   9++CEF3 32 F0 C0                             ld      (UBnkXX12ySign),a           ;                                                                                      ;;;
  10++CEF6 78                                   ld      a,b
  11++CEF7 CB 27                                sla     a                           ; move y sign to bit 7                                                                 ;;;   copy sign bits to XX12
  12++CEF9 E6 80                                and     SignOnly8Bit
  13++CEFB 32 F2 C0                             ld      (UBnkXX12zSign),a           ;                                                                                      ;;;
  14++CEFE 23                                   inc     hl                          ; move to X ccord
  15++CEFF 7E                                   ld      a,(hl)                      ;                                                                                      ;;;   XX12 x,y,z lo = Normal[loop].x,y,z
  16++CF00 32 ED C0                             ld      (UBnkXX12xLo),a                                                                                                    ;;;
  17++CF03 23                                   inc     hl                                                                                                                 ;;;
  18++CF04 7E                                   ld      a,(hl)                      ;                                                                                      ;;;
  19++CF05 32 EF C0                             ld      (UBnkXX12yLo),a                                                                                                    ;;;
  20++CF08 23                                   inc     hl                                                                                                                 ;;;
  21++CF09 7E                                   ld      a,(hl)                      ;                                                                                      ;;;
  22++CF0A 32 F1 C0                             ld      (UBnkXX12zLo),a
  23++CF0D C9                                   ret
  24++CF0E
# file closed: ../../Tests/3DTest/../../Universe/Ships/CopyFaceToXX12.asm
 494+ CF0E              ;--------------------------------------------------------------
 495+ CF0E              ;--------------------------------------------------------------
 496+ CF0E                                      INCLUDE "../../ModelRender/BackfaceCull.asm"
# file opened: ../../Tests/3DTest/../../ModelRender/BackfaceCull.asm
   1++CF0E              ;    DEFINE DEBUGDRAWDISTANCE 1
   2++CF0E                  DEFINE CHECKDOTSHIPDATA  1
   3++CF0E               ;   DEFINE DEBUGFORCEFACEDRAW 1
   4++CF0E 00           CurrentNormIdx  DB 0
   5++CF0F              ; SomeFacesVisible:
   6++CF0F              ; EE29:
   7++CF0F
   8++CF0F              ;   Backface cull logic  line of sight vector . face normal vector
   9++CF0F              ;       line of sight vector . face normal vector
  10++CF0F              ;       => line of sight vector = [x y z] + face normal vector
  11++CF0F              ;       Where [x y z] =
  12++CF0F              ;                                               [ [x y z] . sidev ]
  13++CF0F              ;                    projected [x y z] vector = [ [x y z] . roofv ]
  14++CF0F              ;                                               [ [x y z] . nosev ]
  15++CF0F              ;
  16++CF0F              ;   so project the [x y z] vector into the face's normal space
  17++CF0F              ;  line of sight vector = projected [x y z] vector + face normal vector
  18++CF0F              ;                         [ [x y z] . sidev ]   [ normal_x ]
  19++CF0F              ;                       = [ [x y z] . roofv ] + [ normal_y ]
  20++CF0F              ;                         [ [x y z] . nosev ]   [ normal_z ]
  21++CF0F              ;
  22++CF0F              ;                         [ [x y z] . sidev + normal_x ]
  23++CF0F              ;                       = [ [x y z] . roofv + normal_y ]
  24++CF0F              ;                         [ [x y z] . nosev + normal_z ]
  25++CF0F              ;
  26++CF0F              ; so
  27++CF0F              ;              visibility = [ [x y z] . sidev + normal_x ]   [ normal_x ]
  28++CF0F              ;                            [ [x y z] . roofv + normal_y ] . [ normal_y ]
  29++CF0F              ;                           [ [x y z] . nosev + normal_z ]   [ normal_z ]
  30++CF0F              ;
  31++CF0F              ; where face is visible if visibility < 0
  32++CF0F              ;
  33++CF0F              ;   so we set XX15 to [x y z] . sidev
  34++CF0F              ;                     [x y z] . roofv
  35++CF0F              ;                     [x y z] . nosev
  36++CF0F              ;
  37++CF0F
  38++CF0F
  39++CF0F
  40++CF0F 3A E2 C0     ScaleDrawcam:           ld      a,(UBnkDrawCam0zHi)         ; if z hi is 0 then we have scaled XX18
  41++CF12                                      JumpIfAIsZero .ScaleDone            ;
  41++CF12 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  41++CF13 CA 3F CF    >                        jp	    z, .ScaleDone
  42++CF16 2A DB C0                             ld      hl,(UBnkDrawCam0xLo)        ; pull postition into registers
  43++CF19 ED 5B DE C0                          ld      de,(UBnkDrawCam0yLo)        ; we only pull in if needed to save fetches
  44++CF1D ED 4B E1 C0                          ld      bc,(UBnkDrawCam0zLo)        ;
  45++CF21 FD 2C        .ScaleNormalLoop:       inc     iyl                         ; Q goes up by one
  46++CF23                                      ShiftHLRight1                       ; divide cam position by 2
  46++CF23 CB 3C       >               srl h
  46++CF25 CB 1D       >               rr  l
  47++CF27                                      ShiftDERight1                       ;
  47++CF27 CB 3A       >               srl d
  47++CF29 CB 1B       >               rr  e
  48++CF2B                                      ShiftBCRight1                       ;
  48++CF2B CB 38       >               srl b
  48++CF2D CB 19       >               rr  c
  49++CF2F 78                                   ld      a,b                         ; loop if not scaled down
  50++CF30                                      JumpIfAIsNotZero .ScaleNormalLoop     ;
  50++CF30 A7          >                        and     a
  50++CF31 C2 21 CF    >                        jp	    nz,.ScaleNormalLoop
  51++CF34 22 DB C0                             ld      (UBnkDrawCam0xLo),hl        ; save position back to XX18
  52++CF37 ED 53 DE C0                          ld      (UBnkDrawCam0yLo),de        ;
  53++CF3B ED 43 E1 C0                          ld      (UBnkDrawCam0zLo),bc        ;
  54++CF3F FD 7D        .ScaleDone:             ld      a,iyl
  55++CF41 32 0C 67                             ld      (varXX17),a                  ; XX17 = normal scale factor for current ship adjusted for camera
  56++CF44 C9                                   ret
  57++CF45
  58++CF45 3A 28 C0     CheckVisible:           ld      a,(UBnKzsgn)                 ; Is the ship behind us
  59++CF48 E6 80        .CheckBehind:           and     SignOnly8Bit                 ; which means z sign is negative
  60++CF4A 20 2A                                jr      nz,.ShipNoDraw               ; .
  61++CF4C 2A 26 C0     .CheckViewPort:         ld      hl,(UBnKzlo)                 ; now check to see if its within 90 degree arc
  62++CF4F 7C                                   ld      a,h
  63++CF50                                      JumpIfAGTENusng ShipMaxDistance, .ShipNoDraw
  63++CF50 FE C0       >                        cp     ShipMaxDistance
  63++CF52 D2 76 CF    >                        jp		nc,.ShipNoDraw
  64++CF55 ED 5B 20 C0  .CheckXAxis:            ld      de,(UBnKxlo)                 ; if abs x > abx z then its out side of view port
  65++CF59 CD EA 73                             call    compare16HLDE
  66++CF5C 38 18                                jr      c,.ShipNoDraw               ; ship is too far out on the X Axis
  67++CF5E ED 5B 23 C0  .CheckYAxis:            ld      de,(UBnKylo)                ; if abs y > abx z then its out side of view port
  68++CF62 CD EA 73                             call    compare16HLDE
  69++CF65 38 0F                                jr      c,.ShipNoDraw               ; ship is too far out on the X Axis
  70++CF67                                      IFDEF   CHECKDOTSHIPDATA
  71++CF67 3A 45 C4     .CheckDotV2:                ld      a,(DotAddr)
  72++CF6A                                          JumpIfAGTENusng h, .DrawFull
  72++CF6A BC          >                        cp     h
  72++CF6B D2 71 CF    >                        jp		nc,.DrawFull
  73++CF6E C3 7A CF                                 jp      .ShipIsADot
  74++CF71 CD 6D C6     .DrawFull:                  call    UnivVisibleNonDot           ;
  75++CF74                                          ClearCarryFlag
  75++CF74 B7          >                        or a
  76++CF75 C9                                       ret
  77++CF76                                      ELSE
  78++CF76 ~            .CalculateXX4:              ShiftHLRight1                       ; hl = z pos / 8
  79++CF76 ~                                        ShiftHLRight1                       ; .
  80++CF76 ~                                        ShiftHLRight1                       ; .
  81++CF76 ~                                        ld      a,h
  82++CF76 ~                                        srl     a                           ; if a / 16 <> 0 then ship is a dot
  83++CF76 ~            .DrawAsDotCheck:            JumpIfNotZero   .ShipIsADot
  84++CF76 ~                                        ; Check visbility distance
  85++CF76 ~            .SetXX4Dist:                ;break
  86++CF76 ~                                        ld      a,l
  87++CF76 ~                                        rra                                 ; l may have had bit 0 of h carried in
  88++CF76 ~                                        srl     a                           ; so move it to bit 4 giving A as distance $000xxxxx
  89++CF76 ~                                        srl     a
  90++CF76 ~                                        srl     a
  91++CF76 ~                                        ld      (UBnkDrawAllFaces),a        ; XX4 = "all faces" distance
  92++CF76 ~                                        call    UnivVisibleNonDot               ;
  93++CF76 ~                                        ClearCarryFlag
  94++CF76 ~                                        ret
  95++CF76                                      ENDIF
  96++CF76 CD 81 C6     .ShipNoDraw:            call    UnivInvisible
  97++CF79 C9                                   ret
  98++CF7A              .ShipIsADot:            IFDEF DEBUGDRAWDISTANCE
  99++CF7A ~                                        call    UnivVisible  ;
 100++CF7A                                      ELSE
 101++CF7A CD 78 C6                                 call    UnivVisibleDot
 102++CF7D                                      ENDIF
 103++CF7D C9                                   ret
 104++CF7E
 105++CF7E                                                  DISPLAY "TODO:remove all teh processing of rotmat to load craft to camera as its already been done"
 106++CF7E              CullV2:                 ReturnIfMemisZero FaceCtX4Addr      ;
 106++CF7E 3A 44 C4    >                        ld   a,(FaceCtX4Addr)
 106++CF81 A7          >                        and a
 106++CF82 C8          >                        ret    z
 107++CF83                                      ;break
 108++CF83 CD 91 CA                             call    CopyRotmatToTransMat        ; XX16 = UBNKRotMat
 109++CF86 CD 48 65                             call    ScaleXX16Matrix197          ; scale rotation matrix in XX16
 110++CF89 CD 4A CD                             call    LoadCraftToCamera           ; XX18 = camera
 111++CF8C                                      ;call    CopyCameraToXX15Signed      ; Copy the camera to XX15 as signed 15 bit
 112++CF8C 3A 4A C4     .BackfaceLoop:          ld      a,(QAddr)                   ;
 113++CF8F FD 6F                                ld      iyl,a                       ; iyl = scale factor
 114++CF91              ; By this point XX18 = scaled draw cam and iyl = scale factor
 115++CF91 CD 0F CF                             call    ScaleDrawcam                ; XX18 = scaled camera XX17 = scale
 116++CF94 CD 6E CD                             call    CopyCameraToXX15Signed      ; Xx18 -> xx15 sign + 15 bit
 117++CF97 CD DB 64     .LL91:                  call    XX12EquNodeDotXX16          ; xx12 = Scaled Camera . Rotation matrix (Note Xx16 no Xx16 inv)
 118++CF9A CD DB CC                             call    CopyXX12ScaledToXX18        ; now xx18 = XX12 = xx15.xx16
 119++CF9D 21 0A C6     .PrepNormals:           ld      hl,UBnkHullNormals                                                                                                 ;;; V = address of Normal start
 120++CFA0 22 0B 66                             ld      (varV),hl
 121++CFA3 3A 44 C4                             ld      a,(FaceCtX4Addr)                                        ; For each face
 122++CFA6 CB 3F                                srl     a                                              ;
 123++CFA8 CB 3F                                srl     a                                              ;
 124++CFAA 47                                   ld      b,a                                            ;
 125++CFAB AF                                   xor     a
 126++CFAC 32 0E CF                             ld      (CurrentNormIdx),a                                          ; used to increment up face incdex as b decrements
 127++CFAF E5           .ProcessNormalsLoop:    push    hl
 128++CFB0 C5                                   push    bc
 129++CFB1 7E           .LL86:                  ld      a,(hl)                                         ; Get Face sign and visibility distance byte
 130++CFB2 E6 1F                                and     $1F                                            ; if normal visibility range  < XX4
 131++CFB4 E5                                   push    hl
 132++CFB5 21 92 C0                             ld      hl,UBnkDrawAllFaces
 133++CFB8 BE                                   cp      (hl)
 134++CFB9 E1                                   pop     hl
 135++CFBA                                      IFDEF DEBUGFORCEFACEDRAW
 136++CFBA ~                                        jp      .FaceVisible
 137++CFBA                                      ELSE
 138++CFBA DA FF D0                                 jp      c,.FaceVisible              ; then we always draw
 139++CFBD                                      ENDIF
 140++CFBD              ; This bit needs to be added to force face visible
 141++CFBD CD E6 CE     .LL87:                  call    CopyFaceToXX12              ; XX12 = normal (repolaced scale version) as a working copy
 142++CFC0 3A 0C 67                             ld      a,(XX17)                    ; a = q scale XX17 cauclated by the call to ScaleDrawcam
 143++CFC3 47                                   ld      b,a
 144++CFC4                                      JumpIfALTNusng 4,.ScaleNormByXX17   ; if q >= 4 then is so big we don;t factor in + normal for dot product
 144++CFC4 FE 04       >                        cp      4
 144++CFC6 DA 01 D0    >                        jp		c, .ScaleNormByXX17
 145++CFC9 CD 25 CD     .LL143:                 call    CopyXX18toXX15              ; and we just set XX15 = scaled Camera dot rotation matrix
 146++CFCC C3 90 D0                             jp      .DoneScalingIntoXX15        ; Now Process XX12 normal
 147++CFCF 3A DB C0     .Ovflw:                 ld      a,(UBnkDrawCam0xLo)         ; divide camera by 2 if overflow
 148++CFD2 CB 3F                                srl     a                           ; which is held in XX18
 149++CFD4 32 DB C0                             ld      (UBnkDrawCam0xLo),a         ; .
 150++CFD7 3A E1 C0                             ld      a,(UBnkDrawCam0zLo)         ; .
 151++CFDA CB 3F                                srl     a                           ; .
 152++CFDC 32 E1 C0                             ld      (UBnkDrawCam0zLo),a         ; .
 153++CFDF 3A DE C0                             ld      a,(UBnkDrawCam0yLo)         ; .
 154++CFE2 CB 3F                                srl     a                           ; .
 155++CFE4 32 DE C0                             ld      (UBnkDrawCam0yLo),a        ; .
 156++CFE7 06 01        .ScaleXScaledAgain:     ld      b,1                         ; set scale to 1 so we divide original normal by 2 into face and try again and hope we didn't scaled down XX12 earlier so if we did then we must be in the do doo as the object was obscenely large and very close
 157++CFE9                                      ShiftMem8Right1 UBnkXScaled         ; Divide XX15 by 2^B
 157++CFE9 3A E7 C0    >                    ld      a,(UBnkXScaled)
 157++CFEC CB 3F       >                    srl     a
 157++CFEE 32 E7 C0    >                    ld      (UBnkXScaled),a
 158++CFF1                                      ShiftMem8Right1 UBnkYScaled         ;
 158++CFF1 3A E9 C0    >                    ld      a,(UBnkYScaled)
 158++CFF4 CB 3F       >                    srl     a
 158++CFF6 32 E9 C0    >                    ld      (UBnkYScaled),a
 159++CFF9                                      ShiftMem8Right1 UBnkZScaled         ;
 159++CFF9 3A EB C0    >                    ld      a,(UBnkZScaled)
 159++CFFC CB 3F       >                    srl     a
 159++CFFE 32 EB C0    >                    ld      (UBnkZScaled),a
 160++D001              ; if we jumped to here scale factor < 4 so we copy in normal to XX15 (scaled) LL92
 161++D001              .ScaleNormByXX17:       ;ld      b,a
 162++D001 CD 00 CD                             call    CopyXX12toXX15
 163++D004 05           .LL93                   dec     b
 164++D005 FA 24 D0                             jp      m, .ScaledNorm
 165++D008              .LL93Loop:              ShiftMem8Right1 UBnkXScaled        ; Divide XX15 by 2^B, I think this should be really XX12 and is a bug in the original code
 165++D008 3A E7 C0    >                    ld      a,(UBnkXScaled)
 165++D00B CB 3F       >                    srl     a
 165++D00D 32 E7 C0    >                    ld      (UBnkXScaled),a
 166++D010                                      ShiftMem8Right1 UBnkYScaled        ;
 166++D010 3A E9 C0    >                    ld      a,(UBnkYScaled)
 166++D013 CB 3F       >                    srl     a
 166++D015 32 E9 C0    >                    ld      (UBnkYScaled),a
 167++D018                                      ShiftMem8Right1 UBnkZScaled        ;
 167++D018 3A EB C0    >                    ld      a,(UBnkZScaled)
 167++D01B CB 3F       >                    srl     a
 167++D01D 32 EB C0    >                    ld      (UBnkZScaled),a
 168++D020 05                                   dec     b                          ;
 169++D021 F2 08 D0                             jp      p,.LL93Loop                ; Now we have XX15 as scaled Normal, XX15 as camera, don;t really knwo why as cals work on XX12 and XX18
 170++D024              .ScaledNorm:            ;ORIG CODE DOES NOT HAVE THIS call    CopyXX15ToXX12 ; DEBUG as XX15 shoudl be a sacled nromal
 171++D024              ; Add normal to XX15
 172++D024              ; if we jumped here direct from LL143 then XX15 = drawcam scaled by Q, XX12 = face normal unscaled, XX18 = drawcam scaled also
 173++D024              ; if we jumped here via scaling       then XX15 = normal scaled by Q,  XX12 = face normal unscaled, XX16 = drawcam scaled
 174++D024              ; if we hit an overflow               then XX15 = drawcam scaled by Q  XX12 = face normal unscaled, XX18 = (drawcam scaled / 2 ) / 2^ nbr overflows (if we cam in vai scaling then its a mess?
 175++D024              ; So LL94 is wrong as it shoud be operating on XX12 not XX15
 176++D024              .LL94:                  ldCopyByte UBnkZScaled, varR        ; ldCopyByte  UBnkZScaled,     varR  ; if we jumped direct XX15 = drawcam scaled, Xx12 = normal xx18 = drawcam
 176++D024 3A EB C0    >                        ld       a,(UBnkZScaled)
 176++D027 32 06 67    >                        ld       (varR),a
 177++D02A                                      ldCopyByte UBnkXX12zSign, varS      ; ldCopyByte  UBnkYScaled,     varS  ; if we did scaling then xx15 = norm scaled XX18 = drawcam
 177++D02A 3A F2 C0    >                        ld       a,(UBnkXX12zSign)
 177++D02D 32 07 67    >                        ld       (varS),a
 178++D030                                      ldCopyByte  UBnkDrawCam0zLo, varQ   ; AQ = drawcam Z signed
 178++D030 3A E1 C0    >                        ld       a,(UBnkDrawCam0zLo)
 178++D033 32 05 67    >                        ld       (varQ),a
 179++D036 3A E3 C0                             ld      a,(UBnkDrawCam0zSgn)        ; .
 180++D039 CD CE 76                             call    SAEquSRPlusAQ               ; SA = drawcam Z dot + z
 181++D03C DA CF CF                             jp      c,.Ovflw
 182++D03F 32 EB C0                             ld      (UBnkZScaled),a             ; XX15Z = SA
 183++D042                                      ldCopyByte  varS, UBnkZScaledSign   ;
 183++D042 3A 07 67    >                        ld       a,(varS)
 183++D045 32 EC C0    >                        ld       (UBnkZScaledSign),a
 184++D048                                      ldCopyByte  UBnkXScaled,     varR   ; SR = normal X
 184++D048 3A E7 C0    >                        ld       a,(UBnkXScaled)
 184++D04B 32 06 67    >                        ld       (varR),a
 185++D04E                                      ldCopyByte  UBnkXX12xSign,   varS   ; .
 185++D04E 3A EE C0    >                        ld       a,(UBnkXX12xSign)
 185++D051 32 07 67    >                        ld       (varS),a
 186++D054                                      ldCopyByte  UBnkDrawCam0xLo, varQ   ; AQ = drawcam x dot
 186++D054 3A DB C0    >                        ld       a,(UBnkDrawCam0xLo)
 186++D057 32 05 67    >                        ld       (varQ),a
 187++D05A 3A DD C0                             ld      a,(UBnkDrawCam0xSgn)        ; .
 188++D05D CD CE 76                             call    SAEquSRPlusAQ               ; SA = normal x + drawcam x dot
 189++D060 DA CF CF                             jp      c,.Ovflw
 190++D063 32 E7 C0                             ld      (UBnkXScaled),a             ; XX15Z = SA
 191++D066                                      ldCopyByte  varS, UBnkXScaledSign   ; .
 191++D066 3A 07 67    >                        ld       a,(varS)
 191++D069 32 E8 C0    >                        ld       (UBnkXScaledSign),a
 192++D06C                                      ldCopyByte  UBnkYScaled, varR       ; SR = normal Y
 192++D06C 3A E9 C0    >                        ld       a,(UBnkYScaled)
 192++D06F 32 06 67    >                        ld       (varR),a
 193++D072                                      ldCopyByte  UBnkXX12ySign, varS     ; .
 193++D072 3A F0 C0    >                        ld       a,(UBnkXX12ySign)
 193++D075 32 07 67    >                        ld       (varS),a
 194++D078                                      ldCopyByte  UBnkDrawCam0yLo, varQ   ; AQ = drawcam y dot
 194++D078 3A DE C0    >                        ld       a,(UBnkDrawCam0yLo)
 194++D07B 32 05 67    >                        ld       (varQ),a
 195++D07E 3A E0 C0                             ld      a,(UBnkDrawCam0ySgn)        ; .
 196++D081 CD CE 76                             call    SAEquSRPlusAQ               ; SA = normal y + drawcam y dot
 197++D084 DA CF CF                             jp      c,.Ovflw                    ; .
 198++D087 32 E9 C0                             ld      (UBnkYScaled),a             ; XX15 Y = SA
 199++D08A                                      ldCopyByte   varS, UBnkYScaledSign  ; .
 199++D08A 3A 07 67    >                        ld       a,(varS)
 199++D08D 32 EA C0    >                        ld       (UBnkYScaledSign),a
 200++D090              ; calculate dot product LL89
 201++D090              .DoneScalingIntoXX15:   ldCopyByte  UBnkXX12xLo, varQ       ; Q = norm X XX12
 201++D090 3A ED C0    >                        ld       a,(UBnkXX12xLo)
 201++D093 32 05 67    >                        ld       (varQ),a
 202++D096 3A E7 C0                             ld      a,(UBnkXScaled)             ; A = XX15 X
 203++D099 CD 96 76                             call    AequAmulQdiv256             ; A = XX15 X * XX 12 X
 204++D09C 32 21 67                             ld      (varT),a                    ; T = XX15 X * XX 12 X
 205++D09F 3A EE C0                             ld      a,(UBnkXX12xSign)           ; S = sign of XX15 X * XX12 X
 206++D0A2 21 E8 C0                             ld      hl,UBnkXScaledSign          ; .
 207++D0A5 AE                                   xor     (hl)                        ; .
 208++D0A6 32 07 67                             ld      (varS),a                    ; .
 209++D0A9                                      ldCopyByte  UBnkXX12yLo, varQ       ; Q = norm Y XX12
 209++D0A9 3A EF C0    >                        ld       a,(UBnkXX12yLo)
 209++D0AC 32 05 67    >                        ld       (varQ),a
 210++D0AF 3A E9 C0                             ld      a,(UBnkYScaled)             ; A = XX15 Y
 211++D0B2 CD 96 76                             call    AequAmulQdiv256             ; A = XX15 Y * XX 12 Y
 212++D0B5 32 05 67                             ld      (varQ),a                    ; Q = XX15 Y * XX 12 Y
 213++D0B8                                      ldCopyByte  varT,varR               ; R = XX15 X * XX 12 X
 213++D0B8 3A 21 67    >                        ld       a,(varT)
 213++D0BB 32 06 67    >                        ld       (varR),a
 214++D0BE 3A F0 C0                             ld      a,  (UBnkXX12ySign)         ; A = sign of XX15 Y * XX 12 Y
 215++D0C1 21 EA C0                             ld      hl, UBnkYScaledSign         ; .
 216++D0C4 AE                                   xor     (hl)                        ; .
 217++D0C5 CD CE 76                             call    SAEquSRPlusAQ               ; SA = SR+AQ = (X calc) + (Y calc)
 218++D0C8 32 21 67                             ld      (varT),a                    ; T = usigned (X calc) + (Y calc)
 219++D0CB                                      ldCopyByte  UBnkXX12zLo, varQ       ; Q = XX12 Z
 219++D0CB 3A F1 C0    >                        ld       a,(UBnkXX12zLo)
 219++D0CE 32 05 67    >                        ld       (varQ),a
 220++D0D1 3A EB C0                             ld      a,  (UBnkZScaled)           ; A = XX15 Z
 221++D0D4 CD 96 76                             call    AequAmulQdiv256             ; A = XX12 Z * XX15 Z
 222++D0D7 32 05 67                             ld      (varQ),a                    ; Q = XX12 Z * XX15 Z
 223++D0DA                                      ldCopyByte  varT, varR              ; R = usigned (X calc) + (Y calc)
 223++D0DA 3A 21 67    >                        ld       a,(varT)
 223++D0DD 32 06 67    >                        ld       (varR),a
 224++D0E0 3A EC C0                             ld      a,  (UBnkZScaledSign)       ; A = sign of XX12 Z * XX15 Z
 225++D0E3 21 F2 C0                             ld      hl, UBnkXX12zSign           ; .
 226++D0E6 AE                                   xor     (hl)                        ; .
 227++D0E7 CD CE 76                             call    SAEquSRPlusAQ               ; SA = ((X+Y signed)) (Z signed)
 228++D0EA FE 00                                cp      0                           ; was the result 0, if so then there are scenarios where SAEquSRPlusAQ can return -ve 0
 229++D0EC 28 08                                jr      z,.FaceNotVisible           ; in which case face is not visible
 230++D0EE 3A 07 67                             ld      a,(varS)                    ; if the cacl was a negative number then its visible
 231++D0F1 ED 27 80                             test    $80                         ; this should test S not A
 232++D0F4 20 09                                jr      nz,.FaceVisible                                      ;        if dot product < 0 set face visible
 233++D0F6 3A 0E CF     .FaceNotVisible:         ld          a,(CurrentNormIdx)
 234++D0F9 CD 98 CB                             call        SetFaceAHidden                                      ;           set face invisible
 235++D0FC C3 05 D1                             jp          .ProcessNormalLoopEnd                                ;        end if
 236++D0FF 3A 0E CF     .FaceVisible:            ld          a,(CurrentNormIdx)
 237++D102 CD 8F CB                             call        SetFaceAVisible
 238++D105 21 0E CF     .ProcessNormalLoopEnd:  ld          hl, CurrentNormIdx
 239++D108 34                                   inc         (hl)                    ; move index pointer up by one
 240++D109 C1                                   pop         bc
 241++D10A E1                                   pop         hl                      ; get normal data pointer back
 242++D10B 3E 04                                ld          a,4
 243++D10D ED 31                                add         hl,a                    ; move to next normal entry
 244++D10F 22 0B 66                             ld          (varV),hl               ; save as we need it again
 245++D112 05                                   dec         b
 246++D113 C2 AF CF                             jp          nz,.ProcessNormalsLoop
 247++D116 C9                                   ret
 248++D117
# file closed: ../../Tests/3DTest/../../ModelRender/BackfaceCull.asm
 497+ D117              ;--LL52 to LL55-----------------------------------------------------------------------------------------------------------------
 498+ D117
 499+ D117              TransposeXX12NodeToXX15:
 500+ D117                      ldCopyByte  UBnKxsgn,UbnkXPointSign           ; UBnkXSgn => XX15+2 x sign
 500+ D117 3A 22 C0    >                        ld       a,(UBnKxsgn)
 500+ D11A 32 E9 C0    >                        ld       (UbnkXPointSign),a
 501+ D11D ED 4B ED C0          ld          bc,(UBnkXX12xLo)                   ; c = lo, b = sign   XX12XLoSign
 502+ D121 A8                   xor         b                                   ; a = UBnkKxsgn (or XX15+2) here and b = XX12xsign,  XX12+1 \ rotated xnode h                                                                             ;;;           a = a XOR XX12+1                              XCALC
 503+ D122 FA 38 D1             jp          m,NodeNegativeX                                                                                                                                                            ;;;           if sign is +ve                        ::LL52   XCALC
 504+ D125              ; XX15 [0,1] = INWK[0]+ XX12[0] + 256*INWK[1]                                                                                       ;;;          while any of x,y & z hi <> 0
 505+ D125              NodeXPositiveX:
 506+ D125 79                   ld          a,c                                 ; We picked up XX12+0 above in bc Xlo
 507+ D126 06 00                ld          b,0                                 ; but only want to work on xlo                                                           ;;;              XX15xHiLo = XX12HiLo + xpos lo             XCALC
 508+ D128 2A 20 C0             ld          hl,(UBnKxlo)                       ; hl = XX1 UBNKxLo
 509+ D12B 26 00                ld          h,0                                 ; but we don;t want the sign
 510+ D12D 09                   add         hl,bc                               ; its a 16 bit add
 511+ D12E 22 E7 C0             ld          (UbnkXPoint),hl                    ; And written to XX15 0,1
 512+ D131 AF                   xor         a                                   ; we want to write 0 as sign bit (not in original code)
 513+ D132 32 E9 C0             ld          (UbnkXPointSign),a
 514+ D135 C3 54 D1             jp          FinishedThisNodeX
 515+ D138              ; If we get here then _sign and vertv_ have different signs so do subtract
 516+ D138              NodeNegativeX:
 517+ D138              LL52X:                                                 ;
 518+ D138 2A 20 C0             ld          hl,(UBnKxlo)                       ; Coord
 519+ D13B ED 4B ED C0          ld          bc,(UBnkXX12xLo)                   ; XX12
 520+ D13F 06 00                ld          b,0                                 ; XX12 lo byte only
 521+ D141 ED 42                sbc         hl,bc                               ; hl = UBnKx - UBnkXX12xLo
 522+ D143 F2 51 D1             jp          p,SetAndMopX                       ; if result is positive skip to write back
 523+ D146              NodeXNegSignChangeX:
 524+ D146              ; If we get here the result is 2'c compliment so we reverse it and flip sign
 525+ D146 CD 86 6D             call        negate16hl                          ; Convert back to positive and flip sign
 526+ D149 3A E9 C0             ld          a,(UbnkXPointSign)                 ; XX15+2
 527+ D14C EE 80                xor         $80                                 ; Flip bit 7
 528+ D14E 32 E9 C0             ld          (UbnkXPointSign),a                 ; XX15+2
 529+ D151              SetAndMopX:
 530+ D151 22 20 C0             ld          (UBnKxlo),hl                       ; XX15+0
 531+ D154              FinishedThisNodeX:
 532+ D154
 533+ D154              LL53:
 534+ D154
 535+ D154                      ldCopyByte  UBnKysgn,UbnkYPointSign           ; UBnkXSgn => XX15+2 x sign
 535+ D154 3A 25 C0    >                        ld       a,(UBnKysgn)
 535+ D157 32 EC C0    >                        ld       (UbnkYPointSign),a
 536+ D15A ED 4B EF C0          ld          bc,(UBnkXX12yLo)                   ; c = lo, b = sign   XX12XLoSign
 537+ D15E A8                   xor         b                                   ; a = UBnkKxsgn (or XX15+2) here and b = XX12xsign,  XX12+1 \ rotated xnode h                                                                             ;;;           a = a XOR XX12+1                              XCALC
 538+ D15F FA 75 D1             jp          m,NodeNegativeY                                                                                                                                                            ;;;           if sign is +ve                        ::LL52   XCALC
 539+ D162              ; XX15 [0,1] = INWK[0]+ XX12[0] + 256*INWK[1]                                                                                       ;;;          while any of x,y & z hi <> 0
 540+ D162              NodeXPositiveY:
 541+ D162 79                   ld          a,c                                 ; We picked up XX12+0 above in bc Xlo
 542+ D163 06 00                ld          b,0                                 ; but only want to work on xlo                                                           ;;;              XX15xHiLo = XX12HiLo + xpos lo             XCALC
 543+ D165 2A 23 C0             ld          hl,(UBnKylo)                       ; hl = XX1 UBNKxLo
 544+ D168 26 00                ld          h,0                                 ; but we don;t want the sign
 545+ D16A 09                   add         hl,bc                               ; its a 16 bit add
 546+ D16B 22 EA C0             ld          (UbnkYPoint),hl                    ; And written to XX15 0,1
 547+ D16E AF                   xor         a                                   ; we want to write 0 as sign bit (not in original code)
 548+ D16F 32 E9 C0             ld          (UbnkXPointSign),a
 549+ D172 C3 91 D1             jp          FinishedThisNodeY
 550+ D175              ; If we get here then _sign and vertv_ have different signs so do subtract
 551+ D175              NodeNegativeY:
 552+ D175              LL52Y:                                                 ;
 553+ D175 2A 23 C0             ld          hl,(UBnKylo)                       ; Coord
 554+ D178 ED 4B EF C0          ld          bc,(UBnkXX12yLo)                   ; XX12
 555+ D17C 06 00                ld          b,0                                 ; XX12 lo byte only
 556+ D17E ED 42                sbc         hl,bc                               ; hl = UBnKx - UBnkXX12xLo
 557+ D180 F2 8E D1             jp          p,SetAndMopY                       ; if result is positive skip to write back
 558+ D183              NodeXNegSignChangeY:
 559+ D183              ; If we get here the result is 2'c compliment so we reverse it and flip sign
 560+ D183 CD 86 6D             call        negate16hl                          ; Convert back to positive and flip sign
 561+ D186 3A EC C0             ld          a,(UbnkYPointSign)                 ; XX15+2
 562+ D189 EE 80                xor         $80                                 ; Flip bit 7
 563+ D18B 32 EC C0             ld          (UbnkYPointSign),a                 ; XX15+2
 564+ D18E              SetAndMopY:
 565+ D18E 22 23 C0             ld          (UBnKylo),hl                       ; XX15+0
 566+ D191              FinishedThisNodeY:
 567+ D191
 568+ D191                  DISPLAY "Tracing 5", $
 569+ D191
 570+ D191              TransposeZ:
 571+ D191              LL55:                                                   ; Both y signs arrive here, Onto z                                          ;;;
 572+ D191 3A F2 C0             ld          a,(UBnkXX12zSign)                   ; XX12+5    \ rotated znode hi                                              ;;;
 573+ D194                      JumpOnBitSet a,7,NegativeNodeZ                    ; LL56 -ve Z node                                                           ;;;
 573+ D194 CB 7F       >                        bit 	7,a
 573+ D196 C2 AA D1    >                        jp      nz,NegativeNodeZ
 574+ D199 3A F1 C0             ld          a,(UBnkXX12zLo)                     ; XX12+4 \ rotated znode lo                                                 ;;;
 575+ D19C 2A 26 C0             ld          hl,(UBnKzlo)                        ; INWK+6    \ zorg lo                                                       ;;;
 576+ D19F ED 31                add         hl,a                                ; hl = INWKZ + XX12z                                                        ;;;
 577+ D1A1 7D                   ld          a,l
 578+ D1A2 32 21 67             ld          (varT),a                            ;                                                                           ;;;
 579+ D1A5 7C                   ld          a,h
 580+ D1A6 32 04 67             ld          (varU),a                            ; now z = hl or U(hi).T(lo)                                                 ;;;
 581+ D1A9 C9                   ret                                             ; LL57  \ Node additions done, z = U.T                                      ;;;
 582+ D1AA              ; Doing additions and scalings for each visible node around here                                                                    ;;;
 583+ D1AA              NegativeNodeZ:
 584+ D1AA              LL56:                                                   ; Enter XX12+5 -ve Z node case  from above                                  ;;;
 585+ D1AA 2A 26 C0             ld          hl,(UBnKzlo)                        ; INWK+6 \ z org lo                                                         ;;;
 586+ D1AD ED 4B F1 C0          ld          bc,(UBnkXX12zLo)                    ; XX12+4    \ rotated z node lo                                                 ......................................................
 587+ D1B1 06 00                ld          b,0                                 ; upper byte will be garbage
 588+ D1B3                      ClearCarryFlag
 588+ D1B3 B7          >                        or a
 589+ D1B4 ED 42                sbc         hl,bc                               ; 6502 used carry flag compliment
 590+ D1B6 7D                   ld          a,l
 591+ D1B7 32 21 67             ld          (varT),a                            ; t = result low
 592+ D1BA 7C                   ld          a,h
 593+ D1BB 32 04 67             ld          (varU),a                            ; u = result high
 594+ D1BE E2 CB D1             jp          po,MakeNodeClose                    ; no overflow to parity would be clear
 595+ D1C1              LL56Overflow:
 596+ D1C1 FE 00                cp          0                                   ; is varU 0?
 597+ D1C3 20 16                jr          nz,NodeAdditionsDone                ; Enter Node additions done, UT=z
 598+ D1C5 3A 21 67             ld          a,(varT)                            ; T \ restore z lo
 599+ D1C8                      ReturnIfAGTENusng 4                              ; >= 4 ? zlo big enough, Enter Node additions done.
 599+ D1C8 FE 04       >                        cp    4
 599+ D1CA D0          >                        ret	 nc
 600+ D1CB              MakeNodeClose:
 601+ D1CB              LL140:                                                  ; else make node close
 602+ D1CB AF                   xor         a                                   ; hi This needs tuning to use a 16 bit variable
 603+ D1CC 32 04 67             ld          (varU),a                            ; U
 604+ D1CF 3E 04                ld          a,4                                 ; lo
 605+ D1D1 32 21 67             ld          (varT),a                            ; T
 606+ D1D4 C9                   ret
 607+ D1D5              ;--LL49-------------------------------------------------------------------------------------------------------------------------
 608+ D1D5              ProcessVisibleNode:
 609+ D1D5              RotateNode:                                                                                                                         ;;;
 610+ D1D5 CD AA CC             call        XX12EquXX15DotProductXX16                                                                                       ;;;           call      XX12=XX15.XX16
 611+ D1D8              LL52LL53LL54LL55
 612+ D1D8              TransposeNode:
 613+ D1D8 CD 17 D1             call        TransposeXX12NodeToXX15
 614+ D1DB
 615+ D1DB              ; ......................................................                                                         ;;;
 616+ D1DB              NodeAdditionsDone:
 617+ D1DB              Scale16BitTo8Bit:
 618+ D1DB              LL57:                                                   ; Enter Node additions done, z=T.U set up from LL55
 619+ D1DB 3A 04 67             ld          a,(varU)                            ; U \ z hi
 620+ D1DE 21 E8 C0             ld          hl,UbnkXPointHi
 621+ D1E1 B6                   or          (hl)                                ; XX15+1    \ x hi
 622+ D1E2 21 EB C0             ld          hl,UbnkYPointHi
 623+ D1E5 B6                   or          (hl)                                ; XX15+4    \ y hi
 624+ D1E6              AreXYZHiAllZero:
 625+ D1E6 28 2B                jr          z,NodeScalingDone                   ; if X, Y, Z = 0  exit loop down once hi U rolled to 0
 626+ D1E8              DivideXYZBy2:
 627+ D1E8                      ShiftMem16Right1    UbnkXPoint                  ; XX15[0,1]
 627+ D1E8 2A E7 C0    >                    ld    hl,(UbnkXPoint)
 627+ D1EB CB 3C       >                    srl   h
 627+ D1ED CB 1D       >                    rr    l
 627+ D1EF 22 E7 C0    >                    ld    (UbnkXPoint),hl
 628+ D1F2                      ShiftMem16Right1    UbnkYPoint                  ; XX15[3,4]
 628+ D1F2 2A EA C0    >                    ld    hl,(UbnkYPoint)
 628+ D1F5 CB 3C       >                    srl   h
 628+ D1F7 CB 1D       >                    rr    l
 628+ D1F9 22 EA C0    >                    ld    (UbnkYPoint),hl
 629+ D1FC 3A 04 67             ld          a,(varU)                            ; U \ z hi
 630+ D1FF 67                   ld          h,a
 631+ D200 3A 21 67             ld          a,(varT)                            ; T \ z lo
 632+ D203 6F                   ld          l,a
 633+ D204                      ShiftHLRight1
 633+ D204 CB 3C       >               srl h
 633+ D206 CB 1D       >               rr  l
 634+ D208 7C                   ld          a,h
 635+ D209 32 04 67             ld          (varU),a
 636+ D20C 7D                   ld          a,l
 637+ D20D 32 21 67             ld          (varT),a                            ; T \ z lo
 638+ D210 C3 DB D1             jp          Scale16BitTo8Bit                    ; loop U
 639+ D213              NodeScalingDone:
 640+ D213              LL60:                                                   ; hi U rolled to 0, exited loop above.
 641+ D213              ProjectNodeToScreen:
 642+ D213                      ldCopyByte  varT,varQ                           ; T =>  Q   \ zdist lo
 642+ D213 3A 21 67    >                        ld       a,(varT)
 642+ D216 32 05 67    >                        ld       (varQ),a
 643+ D219 3A E7 C0             ld          a,(UbnkXPointLo)                    ; XX15  \ rolled x lo
 644+ D21C 21 05 67             ld          hl,varQ
 645+ D21F BE                   cp          (hl)                                ; Q
 646+ D220                      JumpIfALTusng DoSmallAngle                      ; LL69 if xdist < zdist hop over jmp to small x angle
 646+ D220 DA 29 D2    >                        jp		c,DoSmallAngle
 647+ D223 CD CE 6D             call        RequAmul256divQ; RequAdivQ                           ; LL61  \ visit up  R = A/Q = x/z
 648+ D226 C3 31 D2             jp          SkipSmallAngle                      ; LL65  \ hop over small xangle
 649+ D229              DoSmallAngle:                                           ; small x angle
 650+ D229              LL69:
 651+ D229              ; TODO check if we need to retain BC as this trashes it
 652+ D229              ;Input: BC = Dividend, DE = Divisor, HL = 0
 653+ D229              ;Output: BC = Quotient, HL = Remainder
 654+ D229 47                   ld      b,a
 655+ D22A CD 5F 70             call    DIV16UNDOC
 656+ D22D 79                   ld      a,c
 657+ D22E 32 06 67             ld      (varR),a
 658+ D231               ;;;       call        RequAmul256divQ                     ; LL28  \ BFRDIV R=A*256/Q byte for remainder of division
 659+ D231              SkipSmallAngle:
 660+ D231              ScaleX:
 661+ D231              LL65:                                                   ; both continue for scaling based on z
 662+ D231 3A E9 C0             ld          a,(UbnkXPointSign)                  ; XX15+2 \ sign of X dist
 663+ D234                      JumpOnBitSet a,7,NegativeXPoint                 ; LL62 up, -ve Xdist, RU screen onto XX3 heap
 663+ D234 CB 7F       >                        bit 	7,a
 663+ D236 C2 49 D2    >                        jp      nz,NegativeXPoint
 664+ D239              ; ......................................................
 665+ D239              PositiveXPoint:
 666+ D239 3A 06 67             ld          a,(varR)
 667+ D23C 6F                   ld          l,a
 668+ D23D 3A 04 67             ld          a,(varU)
 669+ D240 67                   ld          h,a
 670+ D241 3E 80                ld          a,ScreenCenterX
 671+ D243 ED 31                add         hl,a
 672+ D245 EB                   ex          de,hl
 673+ D246 C3 59 D2             jp          StoreXPoint
 674+ D249              NegativeXPoint:
 675+ D249              LL62:                                                   ; Arrive from LL65 just below, screen for -ve RU onto XX3 heap, index X=CNT ;;;
 676+ D249 3A 06 67             ld          a,(varR)
 677+ D24C 6F                   ld          l,a
 678+ D24D 3A 04 67             ld          a,(varU)
 679+ D250 67                   ld          h,a
 680+ D251 0E 80                ld          c,ScreenCenterX
 681+ D253 06 00                ld          b,0
 682+ D255                      ClearCarryFlag
 682+ D255 B7          >                        or a
 683+ D256 ED 42                sbc         hl,bc                               ; hl = RU-ScreenCenterX
 684+ D258 EB                   ex          de,hl
 685+ D259              StoreXPoint:                                            ; also from LL62, XX3 node heap has xscreen node so far.
 686+ D259 FD 73 00             ld          (iy+0),e                            ; Update X Point
 687+ D25C FD 72 01             ld          (iy+1),d                            ; Update X Point
 688+ D25F FD 23                inc         iy
 689+ D261 FD 23                inc         iy
 690+ D263              ; ......................................................
 691+ D263              LL66:
 692+ D263              ProcessYPoint:
 693+ D263 AF                   xor         a                                   ; y hi = 0
 694+ D264 32 04 67             ld          (varU),a                            ; U
 695+ D267                      ldCopyByte  varT,varQ                           ; Q \ zdist lo
 695+ D267 3A 21 67    >                        ld       a,(varT)
 695+ D26A 32 05 67    >                        ld       (varQ),a
 696+ D26D 3A EA C0             ld          a,(UbnkYPointLo)                    ; XX15+3 \ rolled y low
 697+ D270 21 05 67             ld          hl,varQ
 698+ D273 BE                   cp          (hl)                                ; Q
 699+ D274                      JumpIfALTusng SmallYHop                         ; if ydist < zdist hop to small yangle
 699+ D274 DA 7D D2    >                        jp		c,SmallYHop
 700+ D277              SmallYPoint:
 701+ D277 CD CE 6D             call        RequAmul256divQ;RequAdivQ                           ; LL61  \ else visit up R = A/Q = y/z
 702+ D27A C3 80 D2             jp          SkipYScale                          ; LL68 hop over small y yangle
 703+ D27D              SmallYHop:
 704+ D27D              LL67:                                                   ; Arrive from LL66 above if XX15+3 < Q \ small yangle
 705+ D27D CD CE 6D             call        RequAmul256divQ                     ; LL28  \ BFRDIV R=A*256/Q byte for remainder of division
 706+ D280              SkipYScale:
 707+ D280              LL68:                                                   ; both carry on, also arrive from LL66, yscaled based on z
 708+ D280 3A EC C0             ld          a,(UbnkYPointSign)                  ; XX15+5 \ sign of X dist
 709+ D283 CB 7F                bit         7,a
 710+ D285 C2 98 D2             jp          nz,NegativeYPoint                   ; LL62 up, -ve Xdist, RU screen onto XX3 heap
 711+ D288              PositiveYPoint:
 712+ D288 3A 06 67             ld          a,(varR)
 713+ D28B 6F                   ld          l,a
 714+ D28C 3A 04 67             ld          a,(varU)
 715+ D28F 67                   ld          h,a
 716+ D290 3E 60                ld          a,ScreenHeightHalf
 717+ D292 ED 31                add         hl,a
 718+ D294 EB                   ex          de,hl
 719+ D295 C3 A8 D2             jp          LL50
 720+ D298              NegativeYPoint:
 721+ D298              LL70:                                                   ; Arrive from LL65 just below, screen for -ve RU onto XX3 heap, index X=CNT ;;;
 722+ D298 3A 06 67             ld          a,(varR)
 723+ D29B 6F                   ld          l,a
 724+ D29C 3A 04 67             ld          a,(varU)
 725+ D29F 67                   ld          h,a
 726+ D2A0 0E 60                ld          c,ScreenHeightHalf
 727+ D2A2 06 00                ld          b,0
 728+ D2A4                      ClearCarryFlag
 728+ D2A4 B7          >                        or a
 729+ D2A5 ED 42                sbc         hl,bc                               ; hl = RU-ScreenCenterX
 730+ D2A7 EB                   ex          de,hl
 731+ D2A8              LL50:                                                   ; also from LL62, XX3 node heap has xscreen node so far.
 732+ D2A8 FD 73 00             ld          (iy+0),e                            ; Update X Point
 733+ D2AB FD 72 01             ld          (iy+1),d                            ; Update X Point
 734+ D2AE FD 23                inc         iy
 735+ D2B0 FD 23                inc         iy
 736+ D2B2 C9                   ret
 737+ D2B3              ;--------------------------------------------------------------------------------------------------------
 738+ D2B3              ;;;     Byte 0 = X magnitide with origin at middle of ship
 739+ D2B3              ;;;     Byte 1 = Y magnitide with origin at middle of ship
 740+ D2B3              ;;;     Byte 2 = Z magnitide with origin at middle of ship
 741+ D2B3              ;;;     Byte 3 = Sign Bits of Vertex 7=X 6=Y 5 = Z 4 - 0 = visibility beyond which vertix is not shown
 742+ D2B3              CopyNodeToXX15:
 743+ D2B3                      ldCopyByte  hl, UBnkXScaled                     ; Load into XX15                                                                     Byte 0;;;     XX15 xlo   = byte 0
 743+ D2B3 7E          >                        ld       a,(hl)
 743+ D2B4 32 E7 C0    >                        ld       (UBnkXScaled),a
 744+ D2B7 23                   inc         hl
 745+ D2B8                      ldCopyByte  hl, UBnkYScaled                     ; Load into XX15                                                                     Byte 0;;;     XX15 xlo   = byte 0
 745+ D2B8 7E          >                        ld       a,(hl)
 745+ D2B9 32 E9 C0    >                        ld       (UBnkYScaled),a
 746+ D2BC 23                   inc         hl
 747+ D2BD                      ldCopyByte  hl, UBnkZScaled                     ; Load into XX15                                                                     Byte 0;;;     XX15 xlo   = byte 0
 747+ D2BD 7E          >                        ld       a,(hl)
 747+ D2BE 32 EB C0    >                        ld       (UBnkZScaled),a
 748+ D2C1 23                   inc         hl
 749+ D2C2              PopulateXX15SignBits:
 750+ D2C2              ; Simplfied for debugging, needs optimising back to original DEBUG TODO
 751+ D2C2 7E                   ld          a,(hl)
 752+ D2C3 4F                   ld          c,a                                 ; copy sign and visibility to c
 753+ D2C4 47                   ld          b,a
 754+ D2C5 E6 80                and         $80                                 ; keep high 3 bits
 755+ D2C7 32 E8 C0             ld          (UBnkXScaledSign),a                 ; Copy Sign Bits                                                            ;;;
 756+ D2CA 78                   ld          a,b
 757+ D2CB E6 40                and         $40
 758+ D2CD CB 27                sla         a                                   ; Copy Sign Bits                                                            ;;;
 759+ D2CF 32 EA C0             ld          (UBnkYScaledSign),a                 ; Copy Sign Bits                                                            ;;;
 760+ D2D2 78                   ld          a,b
 761+ D2D3 E6 20                and         $20
 762+ D2D5 CB 27                sla         a                                   ; Copy Sign Bits                                                            ;;;
 763+ D2D7 CB 27                sla         a                                   ; Copy Sign Bits                                                            ;;;
 764+ D2D9 32 EC C0             ld          (UBnkZScaledSign),a                 ; Copy Sign Bits                                                            ;;;
 765+ D2DC 79                   ld          a,c                                 ; returns a with visibility sign byte
 766+ D2DD E6 1F                and         $1F                                 ; visibility is held in bits 0 to 4                                                              ;;;     A = XX15 Signs AND &1F (to get lower 5 visibility)
 767+ D2DF 32 21 67             ld          (varT),a                            ; and store in varT as its needed later
 768+ D2E2 C9                   ret
 769+ D2E3
 770+ D2E3              ;;;     Byte 4 = High 4 bits Face 2 Index Low 4 bits = Face 1 Index
 771+ D2E3              ;;;     Byte 5 = High 4 bits Face 4 Index Low 4 bits = Face 3 Index
 772+ D2E3              ;..............................................................................................................................
 773+ D2E3              ProcessANode:                                           ; Start loop on Nodes for visibility, each node has 4 faces associated with ;;; For each node (point) in model                  ::LL48
 774+ D2E3              LL48GetScale:
 775+ D2E3 3A F6 65             ld          a,(LastNormalVisible)               ; get Normal visible range into e before we copy node
 776+ D2E6 5F                   ld          e,a
 777+ D2E7 CD B3 D2             call        CopyNodeToXX15
 778+ D2EA              LL48GetVertices:
 779+ D2EA              LL48GetVertSignAndVisDist:
 780+ D2EA                      JumpIfALTNusng e,NodeIsNotVisible               ; if XX4 > Visibility distance then vertext too far away , next vertex.                                             ;;;        goto LL50 (end of loop)
 780+ D2EA BB          >                        cp      e
 780+ D2EB DA 28 D3    >                        jp		c, NodeIsNotVisible
 781+ D2EE              CheckFace1:                                                                                                                         ;;;     if all FaceVisile[point face any of idx1,2,3 or 4] = 0
 782+ D2EE                      CopyByteAtNextHL varP                           ; vertex byte#4, first 2 faces two 4-bit indices 0:15 into XX2 for 2 of the ;;;     get point face idx from byte 4 & 5 of normal
 782+ D2EE 23          >                    inc         hl                                  ; vertex byte#1
 782+ D2EF 7E          >                    ld          a,(hl)                              ;
 782+ D2F0 32 05 66    >                    ld          (varP),a                     ; SunXX15+2 = (V),Y
 783+ D2F3 57                   ld          d,a                                 ; use d to hold a as a temp                                                 ;;;
 784+ D2F4 E6 0F                and         $0F                                 ; face 1                                                                    ;;;
 785+ D2F6 E5                   push        hl                                  ; we need to save HL                                                        ;;;
 786+ D2F7                      ldHLIdxAToA UbnkFaceVisArray                    ; visibility at face 1                                                Byte 4;;;
 786+ D2F7 21 13 C1    >                    ld          hl,UbnkFaceVisArray
 786+ D2FA ED 31       >                    add         hl,a
 786+ D2FC 7E          >                    ld          a,(hl)
 787+ D2FD E1                   pop         hl                                  ;                                                                           ;;;
 788+ D2FE                      JumpIfAIsNotZero NodeIsVisible                  ; is face 1 visible                                                         ;;;
 788+ D2FE A7          >                        and     a
 788+ D2FF C2 2E D3    >                        jp	    nz,NodeIsVisible
 789+ D302              CheckFace2:                                                                                                                         ;;;
 790+ D302 7A                   ld          a,d                                                                                                             ;;;
 791+ D303 ED 23                swapnib                                                                                                                     ;;;
 792+ D305 E6 0F                and         $0F                                 ; this is face 2                                                            ;;;
 793+ D307                      JumpIfAIsNotZero NodeIsVisible                  ; is face 1 visible                                                         ;;;
 793+ D307 A7          >                        and     a
 793+ D308 C2 2E D3    >                        jp	    nz,NodeIsVisible
 794+ D30B              CheckFace3:                                                                                                                         ;;;
 795+ D30B                      CopyByteAtNextHL varP                           ; vertex byte#4, first 2 faces two 4-bit indices 0:15 into XX2 for 2 of the ;;;
 795+ D30B 23          >                    inc         hl                                  ; vertex byte#1
 795+ D30C 7E          >                    ld          a,(hl)                              ;
 795+ D30D 32 05 66    >                    ld          (varP),a                     ; SunXX15+2 = (V),Y
 796+ D310 57                   ld          d,a                                 ; use d to hold a as a temp                                                 ;;;
 797+ D311 E6 0F                and         $0F                                 ; face 1                                                                    ;;;
 798+ D313 E5                   push        hl                                  ; we need to save HL                                                        ;;;
 799+ D314                      ldHLIdxAToA UbnkFaceVisArray                  ; visibility at face 1                                                Byte 5;;;
 799+ D314 21 13 C1    >                    ld          hl,UbnkFaceVisArray
 799+ D317 ED 31       >                    add         hl,a
 799+ D319 7E          >                    ld          a,(hl)
 800+ D31A E1                   pop         hl                                  ;                                                                           ;;;
 801+ D31B                      JumpIfAIsNotZero NodeIsVisible                  ; is face 1 visible                                                         ;;;
 801+ D31B A7          >                        and     a
 801+ D31C C2 2E D3    >                        jp	    nz,NodeIsVisible
 802+ D31F              CheckFace4:                                                                                                                         ;;;
 803+ D31F 7A                   ld          a,d                                                                                                             ;;;
 804+ D320 ED 23                swapnib                                                                                                                     ;;;
 805+ D322 E6 0F                and         $0F                                 ; this is face 2                                                            ;;;
 806+ D324                      JumpIfAIsNotZero NodeIsVisible                  ; is face 1 visible                                                         ;;;
 806+ D324 A7          >                        and     a
 806+ D325 C2 2E D3    >                        jp	    nz,NodeIsVisible
 807+ D328              NodeIsNotVisible:                                                                                                                   ;;;
 808+ D328 01 04 00             ld          bc,4
 809+ D32B FD 09                add         iy,bc                               ; if not visible then move to next element in array anyway                  ;;;
 810+ D32D                      ;;; Should we be loading FFFFFFFF into 4 bytes or just ignore?
 811+ D32D C9                   ret                                                                                                      ;;;        goto LL50 (end of loop)
 812+ D32E              NodeIsVisible:
 813+ D32E              LL49:
 814+ D32E CD D5 D1             call        ProcessVisibleNode                  ; Process node to determine if it goes on heap
 815+ D331 C9                   ret
 816+ D332
 817+ D332                  DISPLAY "Tracing 6", $
 818+ D332
 819+ D332              ProjectNodeToEye:
 820+ D332 ED 4B EB C0      ld          bc,(UBnkZScaled)                    ; BC = Z Cordinate. By here it MUST be positive as its clamped to 4 min
 821+ D336 79               ld          a,c                                 ;  so no need for a negative check
 822+ D337 32 05 67         ld          (varQ),a                            ; VarQ = z
 823+ D33A 3A E7 C0         ld          a,(UBnkXScaled)                     ; XX15  \ rolled x lo which is signed
 824+ D33D CD 48 70         call        DIV16Amul256dCUNDOC                 ; result in BC which is 16 bit TODO Move to 16 bit below not just C reg
 825+ D340 3A E8 C0         ld          a,(UBnkXScaledSign)                 ; XX15+2 \ sign of X dist
 826+ D343                  JumpOnBitSet a,7,EyeNegativeXPoint             ; LL62 up, -ve Xdist, RU screen onto XX3 heap
 826+ D343 CB 7F       >                        bit 	7,a
 826+ D345 C2 50 D3    >                        jp      nz,EyeNegativeXPoint
 827+ D348              EyePositiveXPoint:                                  ; x was positive result
 828+ D348 2E 80            ld          l,ScreenCenterX                     ;
 829+ D34A 26 00            ld          h,0
 830+ D34C 09               add         hl,bc                               ; hl = Screen Centre + X
 831+ D34D C3 57 D3         jp          EyeStoreXPoint
 832+ D350              EyeNegativeXPoint:                                 ; x < 0 so need to subtract from the screen centre position
 833+ D350 2E 80            ld          l,ScreenCenterX
 834+ D352 26 00            ld          h,0
 835+ D354                  ClearCarryFlag
 835+ D354 B7          >                        or a
 836+ D355 ED 42            sbc         hl,bc                               ; hl = Screen Centre - X
 837+ D357              EyeStoreXPoint:                                    ; also from LL62, XX3 node heap has xscreen node so far.
 838+ D357 EB               ex          de,hl
 839+ D358 FD 73 00         ld          (iy+0),e                            ; Update X Point TODO this bit is 16 bit aware just need to fix above bit
 840+ D35B FD 72 01         ld          (iy+1),d                            ; Update X Point
 841+ D35E              EyeProcessYPoint:
 842+ D35E ED 4B EB C0      ld          bc,(UBnkZScaled)                    ; Now process Y co-ordinate
 843+ D362 79               ld          a,c
 844+ D363 32 05 67         ld          (varQ),a
 845+ D366 3A E9 C0         ld          a,(UBnkYScaled)                     ; XX15  \ rolled x lo
 846+ D369 CD 48 70         call        DIV16Amul256dCUNDOC                 ; a = Y scaled * 256 / zscaled
 847+ D36C 3A EA C0         ld          a,(UBnkYScaledSign)                 ; XX15+2 \ sign of X dist
 848+ D36F                  JumpOnBitSet a,7,EyeNegativeYPoint             ; LL62 up, -ve Xdist, RU screen onto XX3 heap top of screen is Y = 0
 848+ D36F CB 7F       >                        bit 	7,a
 848+ D371 C2 7C D3    >                        jp      nz,EyeNegativeYPoint
 849+ D374              EyePositiveYPoint:                                  ; Y is positive so above the centre line
 850+ D374 2E 60            ld          l,ScreenCenterY
 851+ D376                  ClearCarryFlag
 851+ D376 B7          >                        or a
 852+ D377 ED 42            sbc         hl,bc                               ; hl = ScreenCentreY - Y coord (as screen is 0 at top)
 853+ D379 C3 81 D3         jp          EyeStoreYPoint
 854+ D37C              EyeNegativeYPoint:                                  ; this bit is only 8 bit aware TODO FIX
 855+ D37C 2E 60            ld          l,ScreenCenterY
 856+ D37E 26 00            ld          h,0
 857+ D380 09               add         hl,bc                               ; hl = ScreenCenterY + Y as negative is below the center of screen
 858+ D381              EyeStoreYPoint:                                    ; also from LL62, XX3 node heap has xscreen node so far.
 859+ D381 EB               ex          de,hl
 860+ D382 FD 73 02         ld          (iy+2),e                            ; Update Y Point
 861+ D385 FD 72 03         ld          (iy+3),d                            ; Update Y Point
 862+ D388 C9               ret
 863+ D389              ; ---------------------------------------------------------------------------------------------------------------------------------
 864+ D389                          INCLUDE "../../Universe/Ships/ApplyMyRollAndPitch.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/ApplyMyRollAndPitch.asm
   1++D389
   2++D389              ; Full version
   3++D389              ; 1. K2 = y - alpha * x
   4++D389              ; 2. z = z + beta * K2
   5++D389              ; 3. y = K2 - beta * z
   6++D389              ; 4. x = x + alpha * y
   7++D389
   8++D389                  IFDEF USE_24BIT_ROLL_AND_PITCH
   9++D389 ~            UBnK24BitAlphaMulX      DB $00,$00, $00, $00
  10++D389 ~            UBnK24BitAlphaMulY      DB $00,$00, $00, $00
  11++D389 ~            UBnK24BitAlphaMulZ      DB $00,$00, $00, $00
  12++D389 ~            UBnK24BitBetaMulZ       DB $00,$00, $00, $00
  13++D389 ~            UBnK24BitBetaMulY       DB $00,$00, $00, $00
  14++D389 ~            UBnK24BitK2             DS 3
  15++D389 ~
  16++D389 ~            PitchBlock              DB  1
  17++D389 ~
  18++D389 ~            ApplyMyRollAndPitch:    ld      a,(ALPHA)                   ; no roll or pitch, no calc needed
  19++D389 ~            .CheckForRoll:          and		a
  20++D389 ~            						call	nz,UBnKRoll_24Bit
  21++D389 ~            .CheckForPitch:			ld		a,(BETA)
  22++D389 ~            						and		a
  23++D389 ~            						call	nz,UBnKPitch_24Bit
  24++D389 ~            .ApplySpeed:            ld      a,(DELTA)                   ; BCH = - Delta
  25++D389 ~                                    and     a
  26++D389 ~                                    jp      z,.ApplyOrientation
  27++D389 ~            						;ReturnIfAIsZero
  28++D389 ~            						ld      c,0                         ;
  29++D389 ~            						ld      h,a                         ;
  30++D389 ~            						ld      b,$80                       ;
  31++D389 ~            						ld      de,(UBnKzhi)                ; DEL = z position
  32++D389 ~            						ld      a,(UBnKzlo)                 ; .
  33++D389 ~            						ld      l,a                         ; .
  34++D389 ~            						call    AddBCHtoDELsigned           ; update speed
  35++D389 ~            						ld      (UBnKzhi),DE                ; write back to zpos
  36++D389 ~            						ld      a,l
  37++D389 ~                                    ld      (UBnKzlo),a                ;
  38++D389 ~            .ApplyOrientation:      ld      a,(ALPHA)
  39++D389 ~                                    ld      hl,BETA
  40++D389 ~                                    or      (hl)
  41++D389 ~                                    ret     z
  42++D389 ~                                    ld      a,(PitchBlock)
  43++D389 ~                                    and     a
  44++D389 ~                                    ret     z
  45++D389 ~                                    ;break
  46++D389 ~            PitchBreak:             ld      ix,UBnkrotmatSidevX
  47++D389 ~            DebugAlert1:            ld      a,(ix+1)
  48++D389 ~                                    ld      d,(ix+3)
  49++D389 ~                                    ld      e,(ix+5)
  50++D389 ~                                    or     d
  51++D389 ~                                    or     e
  52++D389 ~                                    and     $7F
  53++D389 ~                                    jp      nz,.NoBreak
  54++D389 ~                                    break
  55++D389 ~            .NoBreak
  56++D389 ~
  57++D389 ~                                    call    ApplyRollAndPitchToIX
  58++D389 ~            DebugAlert2:             ld      a,(ix+1)
  59++D389 ~                                    ld      d,(ix+3)
  60++D389 ~                                    ld      e,(ix+5)
  61++D389 ~                                    or     d
  62++D389 ~                                    or     e
  63++D389 ~                                    and     $7F
  64++D389 ~                                    jp      nz,.NoBreak
  65++D389 ~                                    break
  66++D389 ~            .NoBreak
  67++D389 ~                                    ld      ix,UBnkrotmatRoofvX
  68++D389 ~                                    call    ApplyRollAndPitchToIX
  69++D389 ~                                    ld      ix,UBnkrotmatNosevX
  70++D389 ~                                    call    ApplyRollAndPitchToIX
  71++D389 ~                                    ret
  72++D389 ~
  73++D389 ~            UBnKRoll_24Bit:			ld      a,(ALPHA)                   ; get roll value
  74++D389 ~            						and 	$7F
  75++D389 ~            						ld      d,a                         ; .
  76++D389 ~            						ld      a,(UBnKylo)                ; HLE = x sgn, hi, lo
  77++D389 ~            						ld      e,a                         ; .
  78++D389 ~            						ld      hl,(UBnKyhi)               ; .
  79++D389 ~            						call    DELCequHLEmulDs; replacesmulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * -alpha / 256
  80++D389 ~            						ld		a,l
  81++D389 ~            						ld		(UBnK24BitAlphaMulY),a			; save result
  82++D389 ~            						ld		(UBnK24BitAlphaMulY+1),de		; save result
  83++D389 ~            						ld      a,(ALPHA)                   ; get roll value
  84++D389 ~            						and 	$7F
  85++D389 ~            						ld      d,a                         ; .
  86++D389 ~            						ld      a,(UBnKxlo)                ; HLE = x sgn, hi, lo
  87++D389 ~            						ld      e,a                         ; .
  88++D389 ~            						ld      hl,(UBnKxhi)               ; .
  89++D389 ~            						call    DELCequHLEmulDs; replacesmulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * -alpha / 256
  90++D389 ~            						ld		a,l
  91++D389 ~            						ld		(UBnK24BitAlphaMulX),a			; save result
  92++D389 ~            						ld		(UBnK24BitAlphaMulX+1),de		; save result
  93++D389 ~            						ld		a,(ALPHA)
  94++D389 ~            						and		$80
  95++D389 ~            						jp		z,.RollingRight
  96++D389 ~            .RollingLeft:			ld		ix,UBnKxlo
  97++D389 ~            						ld		iy,UBnK24BitAlphaMulY
  98++D389 ~            						call	AddAtIXtoAtIY24Signed
  99++D389 ~            						ld		ix,UBnKylo
 100++D389 ~            						ld		iy,UBnK24BitAlphaMulX
 101++D389 ~            						call	SubAtIXtoAtIY24Signed
 102++D389 ~            						ret
 103++D389 ~            .RollingRight:			ld		ix,UBnKxlo
 104++D389 ~            						ld		iy,UBnK24BitAlphaMulY
 105++D389 ~            						call	SubAtIXtoAtIY24Signed
 106++D389 ~            						ld		ix,UBnKylo
 107++D389 ~            						ld		iy,UBnK24BitAlphaMulX
 108++D389 ~            						call	AddAtIXtoAtIY24Signed
 109++D389 ~            						ret
 110++D389 ~
 111++D389 ~            UBnKPitch_24Bit:		ld      a,(BETA)                   ; get roll value
 112++D389 ~            						and 	$7F
 113++D389 ~            						ld      d,a                         ; .
 114++D389 ~            						ld      a,(UBnKylo)                ; HLE = x sgn, hi, lo
 115++D389 ~            						ld      e,a                         ; .
 116++D389 ~            						ld      hl,(UBnKyhi)               ; .
 117++D389 ~            						call    DELCequHLEmulDs; replaces mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * -alpha / 256
 118++D389 ~            						ld		a,l
 119++D389 ~            						ld		(UBnK24BitBetaMulY),a			; save result
 120++D389 ~            						ld		(UBnK24BitBetaMulY+1),de		; save result
 121++D389 ~            						ld      a,(BETA)                   ; get roll value
 122++D389 ~            						and 	$7F
 123++D389 ~            						ld      d,a                         ; .
 124++D389 ~            						ld      a,(UBnKzlo)                ; HLE = x sgn, hi, lo
 125++D389 ~            						ld      e,a                         ; .
 126++D389 ~            						ld      hl,(UBnKzhi)               ; .
 127++D389 ~            						call    DELCequHLEmulDs; replaces mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * -alpha / 256
 128++D389 ~            						ld		a,l
 129++D389 ~            						ld		(UBnK24BitBetaMulZ),a			; save result
 130++D389 ~            						ld		(UBnK24BitBetaMulZ+1),de		; save result
 131++D389 ~            						ld		a,(BETA)
 132++D389 ~            						and		$80
 133++D389 ~            						jp		z,.Climbing
 134++D389 ~            .Diving:				ld		ix,UBnKylo
 135++D389 ~            						ld		iy,UBnK24BitBetaMulZ
 136++D389 ~            						call	AddAtIXtoAtIY24Signed
 137++D389 ~            						ld		ix,UBnKzlo
 138++D389 ~            						ld		iy,UBnK24BitBetaMulY
 139++D389 ~            						call	SubAtIXtoAtIY24Signed
 140++D389 ~            						ret
 141++D389 ~            .Climbing:		     	ld		ix,UBnKylo
 142++D389 ~            						ld		iy,UBnK24BitBetaMulZ
 143++D389 ~            						call	SubAtIXtoAtIY24Signed
 144++D389 ~            						ld		ix,UBnKzlo
 145++D389 ~            						ld		iy,UBnK24BitBetaMulY
 146++D389 ~            						call	AddAtIXtoAtIY24Signed
 147++D389 ~            						ret
 148++D389 ~
 149++D389                  ELSE
 150++D389              APPequPosPlusAPP:       MACRO    Position, PositionSign
 151++D389 ~                                    push    bc
 152++D389 ~                                    ld      c,a                         ; save original value of a into c
 153++D389 ~                                    ld      a,(PositionSign)
 154++D389 ~                                    ld      b,a
 155++D389 ~                                    ld      a,c
 156++D389 ~                                    xor     b                           ; a = a xor x postition sign
 157++D389 ~                                    jp      m,.MV50                     ; if the sign is negative then A and X are both opposite signs
 158++D389 ~            ; Signs are the same to we just add and take which ever sign
 159++D389 ~                                    ld      de,(varPp1)                  ; Note we take p+2,p+1 we we did a previous 24 bit mulitple
 160++D389 ~                                    ld      hl,(Position)
 161++D389 ~                                    add     hl,de
 162++D389 ~                                    ld      (varPp1),hl                  ; now we have P1 and p2 with lo hi and
 163++D389 ~                                    ld      a,c                         ; and a = original sign as they were both the same
 164++D389 ~                                    pop     bc
 165++D389 ~                                    ret
 166++D389 ~            ; Signs are opposite so we subtract
 167++D389 ~            .MV50:                  ld      de,(varPp1)
 168++D389 ~                                    ld      hl,(Position)
 169++D389 ~                                    or      a
 170++D389 ~                                    sbc     hl,de
 171++D389 ~                                    jr      c,.MV51                     ; if the result was negative then negate result
 172++D389 ~                                    ld      a,c                         ; get back the original sign
 173++D389 ~                                    ld      (varPp1),hl                 ; and save result to P[2][1]
 174++D389 ~                                    xor     SignOnly8Bit                ; flip sign and exit A = flip of a
 175++D389 ~                                    pop     bc
 176++D389 ~                                    ret
 177++D389 ~            .MV51:                  NegHL
 178++D389 ~                                    ld      (varPp1),hl
 179++D389 ~                                    ld      a,c                         ; the original sign will still be good
 180++D389 ~                                    pop     bc
 181++D389 ~                                    ret
 182++D389                                      ENDM
 183++D389
 184++D389
 185++D389              APPequXPosPlusAPP:     APPequPosPlusAPP UBnKxlo, UBnKxsgn
 185++D389 C5          >                        push    bc
 185++D38A 4F          >                        ld      c,a                         ; save original value of a into c
 185++D38B 3A 22 C0    >                        ld      a,(UBnKxsgn)
 185++D38E 47          >                        ld      b,a
 185++D38F 79          >                        ld      a,c
 185++D390 A8          >                        xor     b                           ; a = a xor x postition sign
 185++D391 FA A2 D3    >                        jp      m,.MV50                     ; if the sign is negative then A and X are both opposite signs
 185++D394             >; Signs are the same to we just add and take which ever sign
 185++D394 ED 5B 06 66 >                        ld      de,(varPp1)                  ; Note we take p+2,p+1 we we did a previous 24 bit mulitple
 185++D398 2A 20 C0    >                        ld      hl,(UBnKxlo)
 185++D39B 19          >                        add     hl,de
 185++D39C 22 06 66    >                        ld      (varPp1),hl                  ; now we have P1 and p2 with lo hi and
 185++D39F 79          >                        ld      a,c                         ; and a = original sign as they were both the same
 185++D3A0 C1          >                        pop     bc
 185++D3A1 C9          >                        ret
 185++D3A2             >; Signs are opposite so we subtract
 185++D3A2 ED 5B 06 66 >.MV50:                  ld      de,(varPp1)
 185++D3A6 2A 20 C0    >                        ld      hl,(UBnKxlo)
 185++D3A9 B7          >                        or      a
 185++D3AA ED 52       >                        sbc     hl,de
 185++D3AC 38 08       >                        jr      c,.MV51                     ; if the result was negative then negate result
 185++D3AE 79          >                        ld      a,c                         ; get back the original sign
 185++D3AF 22 06 66    >                        ld      (varPp1),hl                 ; and save result to P[2][1]
 185++D3B2 EE 80       >                        xor     SignOnly8Bit                ; flip sign and exit A = flip of a
 185++D3B4 C1          >                        pop     bc
 185++D3B5 C9          >                        ret
 185++D3B6             >.MV51:                  NegHL
 185++D3B6 AF          >                    xor a
 185++D3B7 95          >                    sub l
 185++D3B8 6F          >                    ld l,a
 185++D3B9 9F          >                    sbc a,a
 185++D3BA 94          >                    sub h
 185++D3BB 67          >                    ld h,a
 185++D3BC 22 06 66    >                        ld      (varPp1),hl
 185++D3BF 79          >                        ld      a,c                         ; the original sign will still be good
 185++D3C0 C1          >                        pop     bc
 185++D3C1 C9          >                        ret
 186++D3C2
 187++D3C2              APPequYPosPlusAPP:     APPequPosPlusAPP UBnKylo, UBnKysgn
 187++D3C2 C5          >                        push    bc
 187++D3C3 4F          >                        ld      c,a                         ; save original value of a into c
 187++D3C4 3A 25 C0    >                        ld      a,(UBnKysgn)
 187++D3C7 47          >                        ld      b,a
 187++D3C8 79          >                        ld      a,c
 187++D3C9 A8          >                        xor     b                           ; a = a xor x postition sign
 187++D3CA FA DB D3    >                        jp      m,.MV50                     ; if the sign is negative then A and X are both opposite signs
 187++D3CD             >; Signs are the same to we just add and take which ever sign
 187++D3CD ED 5B 06 66 >                        ld      de,(varPp1)                  ; Note we take p+2,p+1 we we did a previous 24 bit mulitple
 187++D3D1 2A 23 C0    >                        ld      hl,(UBnKylo)
 187++D3D4 19          >                        add     hl,de
 187++D3D5 22 06 66    >                        ld      (varPp1),hl                  ; now we have P1 and p2 with lo hi and
 187++D3D8 79          >                        ld      a,c                         ; and a = original sign as they were both the same
 187++D3D9 C1          >                        pop     bc
 187++D3DA C9          >                        ret
 187++D3DB             >; Signs are opposite so we subtract
 187++D3DB ED 5B 06 66 >.MV50:                  ld      de,(varPp1)
 187++D3DF 2A 23 C0    >                        ld      hl,(UBnKylo)
 187++D3E2 B7          >                        or      a
 187++D3E3 ED 52       >                        sbc     hl,de
 187++D3E5 38 08       >                        jr      c,.MV51                     ; if the result was negative then negate result
 187++D3E7 79          >                        ld      a,c                         ; get back the original sign
 187++D3E8 22 06 66    >                        ld      (varPp1),hl                 ; and save result to P[2][1]
 187++D3EB EE 80       >                        xor     SignOnly8Bit                ; flip sign and exit A = flip of a
 187++D3ED C1          >                        pop     bc
 187++D3EE C9          >                        ret
 187++D3EF             >.MV51:                  NegHL
 187++D3EF AF          >                    xor a
 187++D3F0 95          >                    sub l
 187++D3F1 6F          >                    ld l,a
 187++D3F2 9F          >                    sbc a,a
 187++D3F3 94          >                    sub h
 187++D3F4 67          >                    ld h,a
 187++D3F5 22 06 66    >                        ld      (varPp1),hl
 187++D3F8 79          >                        ld      a,c                         ; the original sign will still be good
 187++D3F9 C1          >                        pop     bc
 187++D3FA C9          >                        ret
 188++D3FB
 189++D3FB              APPequZPosPlusAPP:     APPequPosPlusAPP UBnKzlo, UBnKzsgn
 189++D3FB C5          >                        push    bc
 189++D3FC 4F          >                        ld      c,a                         ; save original value of a into c
 189++D3FD 3A 28 C0    >                        ld      a,(UBnKzsgn)
 189++D400 47          >                        ld      b,a
 189++D401 79          >                        ld      a,c
 189++D402 A8          >                        xor     b                           ; a = a xor x postition sign
 189++D403 FA 14 D4    >                        jp      m,.MV50                     ; if the sign is negative then A and X are both opposite signs
 189++D406             >; Signs are the same to we just add and take which ever sign
 189++D406 ED 5B 06 66 >                        ld      de,(varPp1)                  ; Note we take p+2,p+1 we we did a previous 24 bit mulitple
 189++D40A 2A 26 C0    >                        ld      hl,(UBnKzlo)
 189++D40D 19          >                        add     hl,de
 189++D40E 22 06 66    >                        ld      (varPp1),hl                  ; now we have P1 and p2 with lo hi and
 189++D411 79          >                        ld      a,c                         ; and a = original sign as they were both the same
 189++D412 C1          >                        pop     bc
 189++D413 C9          >                        ret
 189++D414             >; Signs are opposite so we subtract
 189++D414 ED 5B 06 66 >.MV50:                  ld      de,(varPp1)
 189++D418 2A 26 C0    >                        ld      hl,(UBnKzlo)
 189++D41B B7          >                        or      a
 189++D41C ED 52       >                        sbc     hl,de
 189++D41E 38 08       >                        jr      c,.MV51                     ; if the result was negative then negate result
 189++D420 79          >                        ld      a,c                         ; get back the original sign
 189++D421 22 06 66    >                        ld      (varPp1),hl                 ; and save result to P[2][1]
 189++D424 EE 80       >                        xor     SignOnly8Bit                ; flip sign and exit A = flip of a
 189++D426 C1          >                        pop     bc
 189++D427 C9          >                        ret
 189++D428             >.MV51:                  NegHL
 189++D428 AF          >                    xor a
 189++D429 95          >                    sub l
 189++D42A 6F          >                    ld l,a
 189++D42B 9F          >                    sbc a,a
 189++D42C 94          >                    sub h
 189++D42D 67          >                    ld h,a
 189++D42E 22 06 66    >                        ld      (varPp1),hl
 189++D431 79          >                        ld      a,c                         ; the original sign will still be good
 189++D432 C1          >                        pop     bc
 189++D433 C9          >                        ret
 190++D434
 191++D434              ; rollWork holds Alpha intermidate results
 192++D434 00 00 00     rollWork      DS 3
 193++D437              rollWorkp1    equ rollWork
 194++D437              rollWorkp2    equ rollWork+1
 195++D437              rollWorkp3    equ rollWork+2
 196++D437
 197++D437              ;----------------------------------------------------------------------------------------------------------------------------------
 198++D437              ; based on MVEIT part 4 of 9
 199++D437 3A 1F 66     ApplyMyRollAndPitch:    ld      a,(ALP1)                    ; get roll magnitude
 200++D43A 21 13 66                             ld      hl,BET1                     ; and pitch
 201++D43D B6                                   or      (hl)
 202++D43E CA FC D4                             jp      z,.NoRotation               ; if both zero then don't compute
 203++D441              ; If the xsgn,ysng or zsng are not 0 or $80 then we use 24 bit routines
 204++D441              ; else we can just continue to use 16 bit
 205++D441                                     ;jp      ApplyMyRollAndPitch24Bit
 206++D441
 207++D441 3A 22 C0     .CheckFor24Bit:         ld      a,(UBnKxsgn)
 208++D444 21 25 C0                             ld      hl,UBnKysgn
 209++D447 B6                                   or      (hl)
 210++D448 21 28 C0                             ld      hl,UBnKzsgn
 211++D44B B6                                   or      (hl)
 212++D44C E6 7F                                and     $7F
 213++D44E C2 86 D5                             jp      nz,ApplyMyRollAndPitch24Bit
 214++D451                                      ;break
 215++D451              ; P[210] = x * alph (we use P[2]P[1] later as result/256
 216++D451 5F           .Not24BitCalcs:         ld      e,a                         ; e = roll magnitude
 217++D452 2A 20 C0                             ld      hl,(UBnKxlo)                ; hl = ship x pos
 218++D455 CD E5 6B                             call    AHLequHLmulE                ; MULTU2-2 AHL = UbnkXlo * Alp1 both unsigned
 219++D458 32 07 66                             ld      (varPhi2),a                 ; set P[2] to high byte to help with ./256
 220++D45B 22 05 66                             ld      (varP),hl                   ; P (2 1 0) = UbnkXlo * Alph1
 221++D45E              ; A = Flip sign
 222++D45E 3A 20 66                             ld      a,(ALP2)                ; flip the current roll angle alpha and xor with x sign
 223++D461 21 22 C0                             ld      hl,UBnKxsgn                 ; and xor with x pos sign
 224++D464 AE                                   xor     (hl)                        ; so now  (A P+2 P+1) = - (x_sign x_hi x_lo) * alpha / 256
 225++D465              ; AP[2]P[1] =Y + AP[2]P[1] (i.e. Previous APP/256)
 226++D465 CD C2 D3                             call    APPequYPosPlusAPP           ; MVT6 calculate APP = y - (x * alpha / 256)
 227++D468              ; K2 = AP[2][1] K2(3 2 1) = (A P+2 P+1) = y - x * alpha / 256
 228++D468 32 36 D4                             ld      (rollWorkp3),a               ; k2+3 = sign of result
 229++D46B 22 34 D4                             ld      (rollWorkp1),hl             ; k2+1,2 = result
 230++D46E              ; P[210] = K2[2 1] * Beta  = (A ~P) * X
 231++D46E 3A 13 66                             ld      a,(BET1)                    ; a = magnitude of pitch
 232++D471 5F                                   ld      e,a
 233++D472 CD E5 6B                             call    AHLequHLmulE                ; MLTU2-2 AHL = (P+2 P+1) * BET1 or by now ((UbnkXlo * Alph1)/256 * Bet1)
 234++D475 32 07 66                             ld      (varPp2),a                   ; save highest byte in P2
 235++D478 22 05 66                             ld      (varP),hl
 236++D47B              ; Fetch sign of previosu cal and xor with BETA inverted
 237++D47B 3A 36 D4                             ld      a,(rollWorkp3)
 238++D47E 5F                                   ld      e,a
 239++D47F 3A 14 66                             ld      a,(BET2)
 240++D482 AB                                   xor     e                           ; so we get the sign of K3 and xor with pitch sign
 241++D483              ; Z = P[210] =Z + APP
 242++D483 CD FB D3                             call    APPequZPosPlusAPP           ; MVT6
 243++D486 32 28 C0                             ld      (UBnKzsgn),a                ; save result back into z
 244++D489 22 26 C0                             ld      (UBnKzlo),hl
 245++D48C              ; A[P1]P[0] = z * Beta
 246++D48C 3A 13 66                             ld      a,(BET1)                    ; get pitch back again for mulitply in original it was kept in Q so no fetch needed
 247++D48F 5F                                   ld      e,a
 248++D490 CD E5 6B                             call    AHLequHLmulE                ; MULTU2 P2 P1 was already in hl (A P+1 P) = (z_hi z_lo) * beta
 249++D493 32 07 66                             ld      (varPp2),a                  ; P2 = high byte of result
 250++D496 22 05 66                             ld      (varP),hl                   ; P (2 1 0) = UbnkXlo & Alph1
 251++D499              ; A xor BET2,Zsign
 252++D499 3A 36 D4                             ld      a,(rollWorkp3)               ; get K3 (sign of y) and store it in y pos
 253++D49C 32 25 C0                             ld      (UBnKysgn),a                ; save result back into y
 254++D49F 5F                                   ld      e,a                         ; a = y sign Xor pitch rate sign
 255++D4A0 3A 14 66                             ld      a,(BET2)                    ;
 256++D4A3 AB                                   xor     e                           ;
 257++D4A4 5F                                   ld      e,a                         ; now xor it with z sign too
 258++D4A5 3A 28 C0                             ld      a,(UBnKzsgn)                ;
 259++D4A8 AB                                   xor     e                           ; so now a = sign of y * beta * sign y * sign z
 260++D4A9 F2 B8 D4                             jp      p,.MV43                     ; if result is pve beta * z and y have differetn signs
 261++D4AC 2A 06 66                             ld      hl,(varPp1)
 262++D4AF ED 5B 34 D4                          ld      de,(rollWorkp1)
 263++D4B3 B7                                   or      a
 264++D4B4 19                                   add     hl,de
 265++D4B5 C3 D2 D4                             jp      .MV44
 266++D4B8 2A 34 D4     .MV43:                  ld      hl,(rollWorkp1)
 267++D4BB ED 5B 06 66                          ld      de,(varPp1)
 268++D4BF B7                                   or      a
 269++D4C0 ED 52                                sbc     hl,de                       ; (y_hi y_lo) = K2(2 1) - P(2 1)
 270++D4C2 30 0E                                jr      nc,.MV44                    ; if there was no over flow carry on
 271++D4C4                                      NegHL
 271++D4C4 AF          >                    xor a
 271++D4C5 95          >                    sub l
 271++D4C6 6F          >                    ld l,a
 271++D4C7 9F          >                    sbc a,a
 271++D4C8 94          >                    sub h
 271++D4C9 67          >                    ld h,a
 272++D4CA 3A 25 C0                             ld      a,(UBnKysgn)                ; flip sign bit TODO, we may have to remove xor as planets and Univs are sign + 23 bit xpos
 273++D4CD EE 80                                xor     SignOnly8Bit
 274++D4CF 32 25 C0                             ld      (UBnKysgn),a
 275++D4D2              ; by here we have (y_sign y_hi y_lo) = K2(2 1) - P(2 1) = K2 - beta * z
 276++D4D2 22 23 C0     .MV44:                  ld      (UBnKylo),hl                ; we do save here to avoid two writes if MV43 ended up with a 2s'c conversion
 277++D4D5 3A 1F 66                             ld      a,(ALP1)                    ; get roll magnitude
 278++D4D8 5F                                   ld      e,a
 279++D4D9 2A 23 C0                             ld      hl,(UBnKylo)
 280++D4DC CD E5 6B                             call    AHLequHLmulE                ; MLTU2-2 AHL = (y_hi y_lo) * alpha
 281++D4DF 32 07 66                             ld      (varPp2),a                  ; store high byte P(2 1 0) = (y_hi y_lo) * alpha
 282++D4E2 22 05 66                             ld      (varP),hl
 283++D4E5 3A 21 66                             ld      a,(ALP2FLIP)
 284++D4E8 5F                                   ld      e,a
 285++D4E9 3A 25 C0                             ld      a,(UBnKysgn)
 286++D4EC AB                                   xor     e                           ; a = sign of roll xor y so now we have (A P+2 P+1) = (y_sign y_hi y_lo) * alpha / 256
 287++D4ED CD 89 D3                             call    APPequXPosPlusAPP           ; MVT6 Set (A P+2 P+1) = (x_sign x_hi x_lo) + (A P+2 P+1) = x + y * alpha / 256
 288++D4F0 32 22 C0                             ld      (UBnKxsgn),a                ; save resutl stright into X pos
 289++D4F3 22 20 C0                             ld      (UBnKxlo),hl
 290++D4F6                                      ;break
 291++D4F6 CD 15 D5                             call    ApplyMyRollToOrientation
 292++D4F9 CD 44 D5                             call    ApplyMyPitchToOrientation
 293++D4FC                                      ; if its not a Univ then apply to local orientation
 294++D4FC 3A FF 66     .NoRotation:            ld      a,(DELTA)                   ; get speed
 295++D4FF 16 00                                ld      d,0
 296++D501 5F                                   ld      e,a                         ; de = speed in low byte
 297++D502 2A 26 C0                             ld      hl,(UBnKzlo)                ; hl = z position
 298++D505 3A 28 C0                             ld      a,(UBnKzsgn)                ; b = z sign
 299++D508 47                                   ld      b,a                         ;
 300++D509 0E 80                                ld      c,$80                       ; c = -ve as we are always moving forwards
 301++D50B CD 33 00                             call    ADDHLDESignBC               ; update speed
 302++D50E 22 26 C0                             ld      (UBnKzlo),hl                ; write back to zpos
 303++D511 32 28 C0                             ld      (UBnKzsgn),a                ;
 304++D514 C9                                   ret
 305++D515
 306++D515                             DISPLAY "TODO: Looks like pitch is always being applied as positive"
 307++D515              ApplyMyRollToOrientation:MMUSelectMathsBankedFns
 307++D515 ED 91 50 66 >                     nextreg MathsBankedFnsMMU, BankMathsBankedFns
 308++D519 3A 1E 66                             ld      a,(ALPHA)
 308++D51C DD 21 36 C0    ld ix,UBnkrotmatNosevX
 308++D520 FD 21 38 C0    ld iy,UBnkrotmatNosevY
 308++D524 CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyRollToNosev:
 309++D527 3A 1E 66                             ld      a,(ALPHA)
 309++D52A DD 21 2A C0    ld ix,UBnkrotmatSidevX
 309++D52E FD 21 2C C0    ld iy,UBnkrotmatSidevY
 309++D532 CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyRollToSidev:
 310++D535 3A 1E 66                             ld      a,(ALPHA)
 310++D538 DD 21 30 C0    ld ix,UBnkrotmatRoofvX
 310++D53C FD 21 32 C0    ld iy,UBnkrotmatRoofvY
 310++D540 CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyRollToRoofv:
 311++D543 C9                                   ret
 312++D544
 313++D544              ApplyMyPitchToOrientation:
 314++D544 3A 11 66                             ld      a,(BETA)
 314++D547 DD 21 3A C0    ld ix,UBnkrotmatNosevZ
 314++D54B FD 21 38 C0    ld iy,UBnkrotmatNosevY
 314++D54F CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyPitchToNosev:
 315++D552 3A 11 66                             ld      a,(BETA)
 315++D555 DD 21 2E C0    ld ix,UBnkrotmatSidevZ
 315++D559 FD 21 2C C0    ld iy,UBnkrotmatSidevY
 315++D55D CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyPitchToSidev:
 316++D560 3A 11 66                             ld      a,(BETA)
 316++D563 DD 21 34 C0    ld ix,UBnkrotmatRoofvZ
 316++D567 FD 21 32 C0    ld iy,UBnkrotmatRoofvY
 316++D56B CD 8B 02       call ApplyMyAngleAToIXIY ; ApplyMyPitchToRoofv:
 317++D56E C9                                   ret
 318++D56F              ;----------------------------------------------------------------------------------------------------------------------------------
 319++D56F              ; 24 bit version of pitch and roll is a 24 bit calculation 1 bit sign + 23 bit value
 320++D56F              ; Need to write a test routine for roll and pitchs
 321++D56F              ; Minsky Roll       Minsky Pitch
 322++D56F              ;  y -= alpha * x    y -= beta * z
 323++D56F              ;  x += alpha * y    z += beta * y
 324++D56F              ; or once combined
 325++D56F              ;   1. K2 = y - alpha * x
 326++D56F              ;   2. z = z + beta * K2
 327++D56F              ;   3. y = K2 - beta * z
 328++D56F              ;   4. x = x + alpha * y
 329++D56F              ;----------------------------------------------------------------------------------------------------------------------------------
 330++D56F              ; Based on non optimised version of Planet pitch and roll is a 24 bit calculation 1 bit sign + 23 bit value
 331++D56F              ; Now at least rolls the correct direction
 332++D56F 00 00 00 00  UnivAlphaMulX               DB $00,$00, $00, $00
 333++D573 00 00 00 00  UnivAlphaMulY               DB $00,$00, $00, $00
 334++D577 00 00 00 00  UnivAlphaMulZ               DB $00,$00, $00, $00
 335++D57B 00 00 00 00  UnivBetaMulZ                DB $00,$00, $00, $00
 336++D57F 00 00 00 00  UnivBetaMulY                DB $00,$00, $00, $00
 337++D583 00 00 00     UnivK2                      DS 3
 338++D586
 339++D586 3A 1E 66     ApplyMyRollAndPitch24Bit: 	 ld     a,(ALPHA)                   ; no roll or pitch, no calc needed
 340++D589 21 11 66                                  ld     hl,BETA
 341++D58C B6                                        or     (hl)
 342++D58D C4 B1 D5                                  call   nz, Univ_Roll_And_Pitch
 343++D590              ;.CheckForRoll:              and		a
 344++D590              ;							call	nz,Univ_Roll
 345++D590              ;.CheckForPitch:				ld		a,(BETA)
 346++D590              ;							and		a
 347++D590              ;							call	nz,Univ_Pitch
 348++D590 3A FF 66     .ApplySpeed:            	ld      a,(DELTA)                   ; BCH = - Delta
 349++D593              							ReturnIfAIsZero
 349++D593 A7          >                        and     a
 349++D594 C8          >                        ret     z
 350++D595 0E 00        							ld      c,0                         ;
 351++D597 67           							ld      h,a                         ;
 352++D598 06 80        							ld      b,$80                       ;
 353++D59A ED 5B 27 C0  							ld      de,(UBnKzhi)                ; DEL = z position
 354++D59E 3A 26 C0     							ld      a,(UBnKzlo)                 ; .
 355++D5A1 6F           							ld      l,a                         ; .
 356++D5A2 CD 14 01     							call    AddBCHtoDELsigned           ; update speed
 357++D5A5 ED 53 27 C0  							ld      (UBnKzhi),DE                ; write back to zpos
 358++D5A9 7D           							ld      a,l
 359++D5AA 32 26 C0     							ld      (UBnKzlo),a                ;
 360++D5AD C9           							ret
 361++D5AE
 362++D5AE              ; Performs minsky rotation
 363++D5AE              ; Joystick left          Joystick right
 364++D5AE              ; ---------------------  ---------------------
 365++D5AE              ; x :=  x      + y / 64  x :=  x -  y / 64  so rather than /64  is z * alpha / 256
 366++D5AE              ; y :=  y      - x /64   y :=  y +  x / 64
 367++D5AE              ;
 368++D5AE              ; Joystick down          Joystick up
 369++D5AE              ; ---------------------  ---------------------
 370++D5AE              ; y :=  y      + z / 64  y :=  y - z / 64
 371++D5AE              ; z :=  z      - y / 64  z :=  z + y / 64
 372++D5AE              ;
 373++D5AE              ; get z, multiply by alpha, pick top 3 bytes with sign
 374++D5AE              ; get x, multiply by alpha, pick top 3 bytes with sign
 375++D5AE              ; if alpha +ve subtract x = x - z adj, z =z + x adj , else x += z adj z -= z adj
 376++D5AE              ; so we can assume 24 bit maths and just do 16 bit multiply of say HL = nosev x [sgn][hi] and de = [0][alpha] by calling AHLequHLmulE
 377++D5AE              ; for roll
 378++D5AE              ; nosev_y = nosev_y - alpha * nosev_x_hi
 379++D5AE              ; nosev_x = nosev_x + alpha * nosev_y_hi
 380++D5AE              ; and for pitch
 381++D5AE              ; nosev_y = nosev_y - beta * nosev_z_hi
 382++D5AE              ; nosev_z = nosev_z + beta * nosev_y_hi
 383++D5AE              ;  1. K2 = y - alpha * x
 384++D5AE              ;   2. z = z + beta * K2
 385++D5AE              ;   3. y = K2 - beta * z
 386++D5AE              ;   4. x = x + alpha * y
 387++D5AE              ;
 388++D5AE              ;   1a. K [3 2 1 0] = -alpha * (x sign hi lo)
 389++D5AE              ;   1b. K [3 2 1]   = y sign hi lo + K [321] (in effect y minus (alpha * x / 256)
 390++D5AE              ;   1c. K2 [3 2 1]  = k [3 2 1 ]
 391++D5AE              ;   2a. K[3 2 1 0]  = k2 [3 2 1] * beta
 392++D5AE              ;   2b. z sign hi lo += K[3 2 1] ( in effect z += (beta * K2)/256
 393++D5AE              ;   3a. K [3 2 1 0] = z sign hi lo * -beta
 394++D5AE              ;   3b. y sign hi lo = K2 [3 2 1] - K [3 2 1] ( in effect K2 - (beta * z) /256
 395++D5AE              ;
 396++D5AE              ;   4. x = x + alpha * y
 397++D5AE
 398++D5AE
 399++D5AE
 400++D5AE              ;-- Q = - ALPHA
 401++D5AE              ;-- A P[1 0] = xsign xhi xlo
 402++D5AE              ;-- call K[3 2 1 0] = A P[1 0] * Q which means  K(3 2 1) = (A P+1 P) * Q / 256 = x * -alpha / 256 = - alpha * x / 256
 403++D5AE              ;-- call K[3 2 1] = ysign hi lo + K[3 2 1] (= y - alpha * x / 256)
 404++D5AE              ;-- K2 [3 2 1 ] = K [ 3 2 1 ]
 405++D5AE              ;-- A P [1 0]   = K [3 2 1]
 406++D5AE              ;-- Q = BETA
 407++D5AE              ;-- K[3 2 1 0] = A P[1 0] * Q
 408++D5AE              ;-- K3[3 2 1] = z sign hi lo + K[3 2 1]
 409++D5AE              ;-- A P [1 0] = -K [3 2 1]
 410++D5AE              ;-- z sign hi lo = K[3 2 1]
 411++D5AE              ;-- K[3 2 1 0] = A P[1 0] * Q
 412++D5AE              ;-- T = K[3] sign bit
 413++D5AE              ;-- A = K[3] sign bit xor K2[3]
 414++D5AE              ;-- if positive A yhi lo - = K [3 2 1 0] + K2[3 2 1 0] so A yhi ylo = K + K2 /256 as we abandon low byte
 415++D5AE              ;-- if negative A yhi lo = (K - k2 )/256
 416++D5AE              ;-- A = A xor T
 417++D5AE              ;-- y sign = A
 418++D5AE              ;-- Q = alpha
 419++D5AE              ;-- A P(1 0) = y sign hi lo
 420++D5AE              ;-- K[3 2 1 0 ] A P[1 0] * Q
 421++D5AE              ;-- x sign hi lo = K[3 2 1] = xsign hi lo * K[3 2 1]
 422++D5AE
 423++D5AE 00 00 00     K2      DS  3
 424++D5B1
 425++D5B1 3A 1E 66     Univ_Roll_And_Pitch:	    ld      a,(ALPHA)                   ; get roll value
 426++D5B4              ;** 1. K2 = y - alpha * x **************************************
 427++D5B4              ;-- DEL = alpha * (x sign hi lo) /256
 428++D5B4 57           							ld      d,a                         ; d = alpha
 429++D5B5 3A 20 C0     							ld      a,(UBnKxlo)                 ; HLE = x sgn, hi, lo
 430++D5B8 5F           							ld      e,a                         ; .
 431++D5B9 2A 21 C0     							ld      hl,(UBnKxhi)                ; hl = UBnKchi sgn
 432++D5BC CD A0 6B     							call    DELCequHLEmulDs; replaces mulHLEbyDSigned             ; DELC = x * alpha, so DEL = X * alpha / 256
 433++D5BF              ;-- DEL = K2 = y - alpha * x
 434++D5BF 42 4B                                    ld      bc,de                       ; transfer to BCH for now
 435++D5C1 65                                       ld      h,l
 436++D5C2 ED 5B 24 C0                              ld      de,(UBnKyhi)
 437++D5C6 3A 23 C0                                 ld      a,(UBnKylo)
 438++D5C9 6F                                       ld      l,a
 439++D5CA CD 10 01                                 call    SubBCHfromDELsigned
 440++D5CD ED 53 AF D5                              ld      (K2+1),de
 441++D5D1 7D                                       ld      a,l
 442++D5D2 32 AE D5                                 ld      (K2),a
 443++D5D5              ;** 2. z = z + beta * K2 ***************************************
 444++D5D5              ;-- HLE = DEL ..................................................
 445++D5D5 EB                                       ex      de,hl                       ; will set hl to de and e to l in one go
 446++D5D6              ;-- DELC = beta * HLE, i.e. beta * K2
 447++D5D6 3A 11 66                                 ld      a,(BETA)
 448++D5D9 57                                       ld      d,a
 449++D5DA CD A0 6B                                 call    DELCequHLEmulDs; replacesmulHLEbyDSigned             ; DELC = beta * K2
 450++D5DD              ;-- DEL = z + DEL, i.e. z + Beta * K2 /256
 451++D5DD ED 4B 27 C0                              ld      bc,(UBnKzhi)                ; BCH = z
 452++D5E1 3A 26 C0                                 ld      a,(UBnKzlo)                 ; .
 453++D5E4 67                                       ld      h,a                         ; .
 454++D5E5 CD 14 01                                 call    AddBCHtoDELsigned           ; DEL =z + (beta * K2)/256
 455++D5E8 ED 53 27 C0                              ld      (UBnKzhi),de                ; and save to Z
 456++D5EC 7D                                       ld      a,l                         ; .
 457++D5ED 32 26 C0                                 ld      (UBnKzlo),a                 ; .
 458++D5F0              ;** 3. y = K2 - beta * z ***************************************
 459++D5F0              ;-- DEL = beta * z / 256
 460++D5F0 3A 11 66                                 ld      a,(BETA)                    ; get pitch value
 461++D5F3 57           							ld      d,a                         ; d = pitch
 462++D5F4 3A 26 C0     							ld      a,(UBnKzlo)                 ; HLE = z sgn, hi, lo
 463++D5F7 5F           							ld      e,a                         ; .
 464++D5F8 2A 27 C0     							ld      hl,(UBnKzhi)                ; hl = UBnKchi sgn
 465++D5FB CD A0 6B     							call    DELCequHLEmulDs; replacesmulHLEbyDSigned             ; DELC = z * beta, so DEL = z * beta / 256
 466++D5FE              ;-- BCH = DEL ..................................................
 467++D5FE 42 4B                                    ld      bc,de                       ; transfer to BCH for now
 468++D600 65                                       ld      h,l
 469++D601              ;-- y = DEL = K2 - beta * z = DEL - BCH
 470++D601 ED 5B AF D5                              ld      de,(K2+1)                   ; del = K2
 471++D605 3A AE D5                                 ld      a,(K2)                      ; .
 472++D608 6F                                       ld      l,a                         ; .
 473++D609 CD 10 01                                 call    SubBCHfromDELsigned         ; .
 474++D60C ED 53 24 C0                              ld      (UBnKyhi),de                ; and save to y
 475++D610 7D                                       ld      a,l                         ; .
 476++D611 32 23 C0                                 ld      (UBnKylo),a                 ; .
 477++D614              ;** 4. x = x + alpha * y ***************************************
 478++D614              ;-- DEL = alpha * y
 479++D614 3A 1E 66                                 ld      a,(ALPHA)                   ; get roll value
 480++D617              ;-- DEL = alpha * (y sign hi lo) /256
 481++D617 57           							ld      d,a                         ; d = alpha
 482++D618 3A 23 C0     							ld      a,(UBnKylo)                 ; HLE = y sgn, hi, lo
 483++D61B 5F           							ld      e,a                         ; .
 484++D61C 2A 24 C0     							ld      hl,(UBnKyhi)                ; hl = UBnKyhi sgn
 485++D61F CD A0 6B     							call    DELCequHLEmulDs; replacesmulHLEbyDSigned             ; DELC = y * alpha, so DEL = Y * alpha / 256
 486++D622              ;-- DEL = x + alpha * y
 487++D622 42 4B                                    ld      bc,de                       ; transfer to BCH for now
 488++D624 65                                       ld      h,l                         ; .
 489++D625 ED 5B 21 C0                              ld      de,(UBnKxhi)                ; del = x
 490++D629 3A 20 C0                                 ld      a,(UBnKxlo)                 ; .
 491++D62C 6F                                       ld      l,a                         ; .
 492++D62D CD 14 01                                 call    AddBCHtoDELsigned           ; del = del + bch = x + alpha * y
 493++D630 ED 53 21 C0                              ld      (UBnKxhi),de                ; and save to x
 494++D634 7D                                       ld      a,l                         ; .
 495++D635 32 20 C0                                 ld      (UBnKxlo),a                 ; .
 496++D638              .ApplyRollToRight:          ;call    ApplyMyRollToOrientation
 497++D638 CD 44 D5     .ApplyPitchToClimb:         call    ApplyMyPitchToOrientation
 498++D63B                                        ;  call    TidyVectorsIX ; doesn't work
 499++D63B C9           							ret
 500++D63C                  ENDIF
 501++D63C
# file closed: ../../Tests/3DTest/../../Universe/Ships/ApplyMyRollAndPitch.asm
 865+ D63C                          INCLUDE "../../Universe/Ships/ApplyShipRollAndPitch.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/ApplyShipRollAndPitch.asm
   1++D63C
   2++D63C
   3++D63C              ;----------------------------------------------------------------------------------------------------------------------------------
   4++D63C              ; based on MVEIT part 4 of 9
   5++D63C              ; x and z counters are proper 2's c values
   6++D63C 3A 89 C0     ApplyShipRollAndPitch:  ld      a,(UBnKRotZCounter)
   7++D63F FE FF                                cp      $FF
   8++D641 28 18                                jr      z,.PitchSAxes
   9++D643 47           .splitAndDampenZ:       ld      b,a                     ; preserve S7 counter
  10++D644 E6 7F                                and     SignMask8Bit            ; if abs (Rotz) is 0 then skip pitch
  11++D646 CA 88 D6                             jp      z,.ProcessRoll
  12++D649 78                                   ld      a,b                     ; b = rotate counter S7
  13++D64A E6 80                                and     SignOnly8Bit            ; a = sign rat2 = c = sign
  14++D64C 4F                                   ld      c,a                     ; .
  15++D64D 32 8F C0                             ld      (univRAT2),a            ; .
  16++D650 78                                   ld      a,b                     ; a = abs b
  17++D651 E6 7F                                and     SignMask8Bit            ; .
  18++D653 3D                                   dec     a                       ; dampen
  19++D654 32 90 C0                             ld      (univRAT2Val),a
  20++D657 B1                                   or      c                       ; make S7 again after dampening
  21++D658 32 89 C0                             ld      (UBnKRotZCounter),a     ; Update Rotation Counter
  22++D65B 21 30 C0     .PitchSAxes:            ld	    hl,UBnkrotmatRoofvX; UBnkrotmatSidevY
  23++D65E 22 EA 65                             ld	    (varAxis1),hl
  24++D661 21 36 C0                             ld	    hl,UBnkrotmatNosevX; UBnkrotmatSidevZ
  25++D664 22 EC 65                             ld	    (varAxis2),hl
  26++D667 CD D4 D6                             call    MVS5RotateAxis
  27++D66A 21 32 C0     .PitchRAxes:            ld	    hl,UBnkrotmatRoofvY
  28++D66D 22 EA 65                             ld	    (varAxis1),hl
  29++D670 21 38 C0                             ld	    hl,UBnkrotmatNosevY;UBnkrotmatRoofvZ
  30++D673 22 EC 65                             ld	    (varAxis2),hl
  31++D676 CD D4 D6                             call    MVS5RotateAxis
  32++D679 21 34 C0     .PitchNAxes:            ld	    hl,UBnkrotmatRoofvZ; UBnkrotmatNosevY
  33++D67C 22 EA 65                             ld	    (varAxis1),hl
  34++D67F 21 3A C0                             ld	    hl,UBnkrotmatNosevZ
  35++D682 22 EC 65                             ld	    (varAxis2),hl
  36++D685 CD D4 D6                             call    MVS5RotateAxis
  37++D688 3A 88 C0     .ProcessRoll:           ld      a,(UBnKRotXCounter)
  38++D68B FE FF                                cp      $FF
  39++D68D 28 17                                jr      z,.RollSAxis
  40++D68F 47           .splitAndDampenX:       ld      b,a
  41++D690 E6 7F                                and     SignMask8Bit            ; exit early is ABS = 0
  42++D692 A7                                   and     a                       ; .
  43++D693 C8                                   ret     z                       ; .
  44++D694 78                                   ld      a,b                     ; a = rotate counter S7
  45++D695 E6 80                                and     SignOnly8Bit            ; rat2 = c = sign
  46++D697 4F                                   ld      c,a                     ; .
  47++D698 32 8F C0                             ld      (univRAT2),a            ; .
  48++D69B 78                                   ld      a,b                     ; a = abs b
  49++D69C E6 7F                                and     SignMask8Bit            ; .
  50++D69E 3D                                   dec     a                       ; dampen
  51++D69F 32 90 C0                             ld      (univRAT2Val),a
  52++D6A2 B1                                   or      c                       ; make S7 again after dampening
  53++D6A3 32 88 C0                             ld      (UBnKRotXCounter),a
  54++D6A6 21 30 C0     .RollSAxis:           	ld	    hl,UBnkrotmatRoofvX; UBnkrotmatSidevX
  55++D6A9 22 EA 65                             ld	    (varAxis1),hl
  56++D6AC 21 2A C0                             ld	    hl,UBnkrotmatSidevX; UBnkrotmatSidevY
  57++D6AF 22 EC 65                             ld	    (varAxis2),hl
  58++D6B2 CD D4 D6                             call    MVS5RotateAxis
  59++D6B5 21 32 C0     .RollRAxis:             ld	    hl,UBnkrotmatRoofvY; UBnkrotmatRoofvX
  60++D6B8 22 EA 65                             ld	    (varAxis1),hl
  61++D6BB 21 2C C0                             ld	    hl,UBnkrotmatSidevY; UBnkrotmatRoofvY
  62++D6BE 22 EC 65                             ld	    (varAxis2),hl
  63++D6C1 CD D4 D6                             call    MVS5RotateAxis
  64++D6C4 21 34 C0     .RollNAxis:             ld	    hl,UBnkrotmatRoofvZ; UBnkrotmatNosevX
  65++D6C7 22 EA 65                             ld	    (varAxis1),hl
  66++D6CA 21 2E C0                             ld	    hl,UBnkrotmatSidevZ; UBnkrotmatNosevY
  67++D6CD 22 EC 65                             ld	    (varAxis2),hl
  68++D6D0 CD D4 D6                             call    MVS5RotateAxis
  69++D6D3 C9                                   ret
  70++D6D4
  71++D6D4
  72++D6D4
  73++D6D4              ; Roate around axis
  74++D6D4              ; varAxis1 and varAxis2 point to the address of the axis to rotate
  75++D6D4              ; so the axis x1 points to roofv  x , y or z
  76++D6D4              ;             x2           nosev or sidev  x, y or z
  77++D6D4              ;   Axis1 = Axis1 * (1 - 1/512)  + Axis2 / 16
  78++D6D4              ;   Axis2 = Axis2 * (1 - 1/512)  - Axis1 / 16
  79++D6D4              ; var RAT2 gives direction
  80++D6D4              ; for pitch x we come in with Axis1 = roofv_x and Axis2 = nosev_x
  81++D6D4              ;-Set up S R -----------------------------------------
  82++D6D4              ; optimised we don't deal with sign here just the value of roof axis / 512
  83++D6D4 2A EA 65     MVS5RotateAxis:         ld      hl,(varAxis1)   ; work on roofv axis to get (1- 1/152) * roofv axis
  84++D6D7 5E                                   ld      e,(hl)
  85++D6D8 23                                   inc     hl
  86++D6D9 56                                   ld      d,(hl)          ; de = Axis1 (roofv x for pitch x)
  87++D6DA EB                                   ex      de,hl           ; hl = Axis1 (roofv x for pitch x)
  88++D6DB 7C                                   ld      a,h
  89++D6DC E6 80                                and     SignOnly8Bit
  90++D6DE FD 67                                ld      iyh,a           ; iyh = sign Axis1
  91++D6E0 7C                                   ld      a,h
  92++D6E1 E6 7F                                and     SignMask8Bit    ; a = Axis1 (roof hi axis  unsigned)
  93++D6E3 CB 3F                                srl     a               ; a = Axis1/2
  94++D6E5 5F                                   ld      e,a             ;
  95++D6E6 FD 7C                                ld      a,iyh           ; A = Axis 1 sign
  96++D6E8 57                                   ld      d,a             ; de = signed Axis1 / 512
  97++D6E9 B7                                   or      a               ; clear carry
  98++D6EA CD 75 01                             call    subHLDES15      ; hl = roof axis - (roof axis /512) which in effect is roof * (1-1/512)
  99++D6ED              ;-Push to stack roof axis - (roofaxis/152)  ----------------------------------------------------------------------------------
 100++D6ED E5                                   push    hl              ; save hl on stack PUSH ID 1 (roof axis - roofv aixs /512)
 101++D6EE 7D                                   ld      a,l
 102++D6EF 32 06 67                             ld      (varR),a
 103++D6F2 7C                                   ld      a,h
 104++D6F3 32 07 67                             ld      (varS),a        ;  RS now equals (1- 1/152) * roofv axis or (roof axis - roofv aixs /512)
 105++D6F6              ;-calculate roofv latter half of calc
 106++D6F6 2A EC 65                             ld      hl,(varAxis2)   ; now work on nosev axis to get nosev axis / 16
 107++D6F9 5E                                   ld      e,(hl)
 108++D6FA 23                                   inc     hl
 109++D6FB 56                                   ld      d,(hl)          ; de = value of roof axis
 110++D6FC 7A                                   ld      a,d
 111++D6FD E6 80                                and     SignOnly8Bit
 112++D6FF FD 67                                ld      iyh,a           ; save sign
 113++D701 7A                                   ld      a,d
 114++D702 E6 7F                                and     SignMask8Bit    ; a = nosev hi axis  unsigned
 115++D704 57                                   ld      d,a             ; de = abs (nosev)
 116++D705                                      ShiftDERight1
 116++D705 CB 3A       >               srl d
 116++D707 CB 1B       >               rr  e
 117++D709                                      ShiftDERight1
 117++D709 CB 3A       >               srl d
 117++D70B CB 1B       >               rr  e
 118++D70D                                      ShiftDERight1
 118++D70D CB 3A       >               srl d
 118++D70F CB 1B       >               rr  e
 119++D711                                      ShiftDERight1           ; de = nosev /16 unsigned
 119++D711 CB 3A       >               srl d
 119++D713 CB 1B       >               rr  e
 120++D715 3A 8F C0                             ld      a,(univRAT2)     ; need to consider direction, so by defautl we use rat2, but flip via sign bit
 121++D718 FD AC                                xor     iyh             ; get the sign back we saveded from DE in so de = nosev axis / 16 signed
 122++D71A E6 80                                and     SignOnly8Bit
 123++D71C B2                                   or      d
 124++D71D 57                                   ld      d,a             ; de = nosev /16 signed and ready as if we were doing a + or - based on RAT2
 125++D71E              ;;; ld      a,e
 126++D71E              ;;;     or      iyh
 127++D71E              ;;; ld      (varP),a        ; PA now equals nosev axis / 16 signed
 128++D71E              ;-now AP = nosev /16  --------------------------------------------------------------------------------------------------------
 129++D71E E1                                   pop     hl              ; get back RS POP ID 1
 130++D71F                  ;ex     de,hl           ; swapping around so hl = AP and de = SR , shoud not matter though as its an add
 131++D71F              ;-now DE = (roofaxis/512) hl - abs(nosevaxis) --------------------------------------------------------------------------------
 132++D71F CD 56 00                             call    ADDHLDESignedV4 ; do add using hl and de
 133++D722 E5                                   push    hl              ; we use stack to represent var K here now varK = Nosev axis /16 + (1 - 1/512) * roofv axis PUSH ID 2
 134++D723              ;-push to stack nosev axis + roofvaxis /512  which is what roofv axis will be ------------------------------------------------
 135++D723              ;-- Set up SR = 1 - 1/512 * nosev-----------------------
 136++D723 2A EC 65                             ld      hl,(varAxis2)   ; work on nosev again to get nosev - novesv / 512
 137++D726 5E                                   ld      e,(hl)
 138++D727 23                                   inc     hl
 139++D728 56                                   ld      d,(hl)
 140++D729 EB                                   ex      de,hl
 141++D72A 7C                                   ld      a,h
 142++D72B E6 80                                and     $80
 143++D72D FD 67                                ld      iyh,a
 144++D72F 7C                                   ld      a,h
 145++D730 E6 7F                                and     SignMask8Bit    ; a = roof hi axis  unsigned
 146++D732 CB 3F                                srl     a               ; now A = unsigned 15 bit nosev axis hi / 2 (or in effect nosev / 512
 147++D734 5F                                   ld      e,a
 148++D735 FD 7C                                ld      a,iyh
 149++D737 57                                   ld      d,a
 150++D738 B7                                   or      a               ; clear carry
 151++D739 CD 75 01                             call    subHLDES15
 152++D73C              ;   sbc     hl,de           ; hl = nosev - novesv / 512
 153++D73C E5                                   push    hl              ; save hl on stack  PUSH ID 3
 154++D73D 7D                                   ld      a,l
 155++D73E 32 05 66                             ld      (varP),a        ; p = low of resuilt
 156++D741 7C                                   ld      a,h
 157++D742 E6 7F                                and     SignMask8Bit    ; a = roof hi axis  unsigned
 158++D744 32 21 67                             ld      (varT),a        ; t = high of result
 159++D747              ;-- Set up TQ
 160++D747 2A EA 65                             ld      hl,(varAxis1)   ; now work on roofv axis / 16
 161++D74A              ;   ld      hl,(varAxis2)   ; work on nosev again
 162++D74A 5E                                   ld      e,(hl)
 163++D74B 23                                   inc     hl
 164++D74C 56                                   ld      d,(hl)
 165++D74D 7A                                   ld      a,d
 166++D74E E6 80                                and     $80
 167++D750 FD 67                                ld      iyh,a           ; save sign
 168++D752 7A                                   ld      a,d
 169++D753 E6 7F                                and     SignMask8Bit    ; a = nosev hi axis  unsigned
 170++D755 57                                   ld      d,a             ; de = abs (nosev)
 171++D756                                      ShiftDERight1
 171++D756 CB 3A       >               srl d
 171++D758 CB 1B       >               rr  e
 172++D75A                                      ShiftDERight1
 172++D75A CB 3A       >               srl d
 172++D75C CB 1B       >               rr  e
 173++D75E                                      ShiftDERight1
 173++D75E CB 3A       >               srl d
 173++D760 CB 1B       >               rr  e
 174++D762                                      ShiftDERight1           ; de = nosev /16 unsigned
 174++D762 CB 3A       >               srl d
 174++D764 CB 1B       >               rr  e
 175++D766 3A 8F C0                             ld      a,(univRAT2)
 176++D769 FD AC                                xor     iyh             ; get the sign back in so de = nosev axis / 16 signed
 177++D76B E6 80                                and     $80
 178++D76D B2                                   or      d
 179++D76E 57                                   ld      d,a
 180++D76F              ;;; ld      a,e
 181++D76F              ;;;     or      iyh
 182++D76F              ;;; ld      (varP),a        ; PA now equals nosev axis / 16 signed
 183++D76F E1                                   pop     hl              ; get back RS   POP ID 3
 184++D770              ;   ex      de,hl           ; swapping around so hl = AP and de = SR , shoud not matter though as its an add
 185++D770 CD 75 01                             call    subHLDES15 ; do add using hl and de
 186++D773              ;-- Update nosev ---------------------------------------
 187++D773 EB                                   ex      de,hl           ; save hl to de
 188++D774 2A EC 65                             ld      hl,(varAxis2)
 189++D777 73                                   ld      (hl),e
 190++D778 23                                   inc     hl
 191++D779 72                                   ld      (hl),d          ; copy result into nosev
 192++D77A              ;-- Update roofv ---------------------------------------
 193++D77A D1                                   pop     de              ; get calc saved on stack POP ID 2
 194++D77B 2A EA 65                             ld      hl,(varAxis1)
 195++D77E 73                                   ld      (hl),e
 196++D77F 23                                   inc     hl
 197++D780 72                                   ld      (hl),d          ; copy result into nosev
 198++D781 C9                                   ret
 199++D782
 200++D782
# file closed: ../../Tests/3DTest/../../Universe/Ships/ApplyShipRollAndPitch.asm
 866+ D782                          INCLUDE "../../Universe/Ships/ApplyShipSpeed.asm"
# file opened: ../../Tests/3DTest/../../Universe/Ships/ApplyShipSpeed.asm
   1++D782
   2++D782
   3++D782              ;AddSpeedToVert:         MACRO   vertex
   4++D782              ;                        ld      hl,(vertex)
   5++D782              ;                        ld      a,(vertex+2)
   6++D782              ;                        ld      b,a
   7++D782              ;                        call    AHLEquBHLaddCDE
   8++D782              ;                        ld      (vertex),hl
   9++D782              ;                        ld      (vertex+2),a
  10++D782              ;                        ENDM
  11++D782
  12++D782
  13++D782              ; ---------------------------------------------------------------------------------------------------------------------------------
  14++D782 3A 86 C0     ApplyShipSpeed:         ld      a,(UBnKSpeed)                   ; get speed * 4
  15++D785 FE 00                                cp      0
  16++D787 C8                                   ret     z
  17++D788 CB 27                                sla     a
  18++D78A CB 27                                sla     a
  19++D78C FD 6F                                ld      iyl,a                           ; save pre calculated speed
  20++D78E              .ApplyToX:              SpeedMulAxis    a, UBnkrotmatNosevX     ; e =  ABS (nosev x hi) c = sign
  20++D78E 5F          >                        ld      e,a
  20++D78F 2A 36 C0    >                        ld      hl,(UBnkrotmatNosevX)
  20++D792 7C          >                        ld      a,h
  20++D793             >                        ClearSignBitA
  20++D793 E6 7F       >                        and     SignMask8Bit
  20++D795 57          >                        ld      d,a
  20++D796 ED 30       >                        mul     de
  20++D798 7C          >                        ld      a,h
  20++D799             >                        SignBitOnlyA
  20++D799 E6 80       >                        and     SignOnly8Bit
  20++D79B 47          >                        ld      b,a;ld      c,a
  20++D79C 62          >                        ld      h,d;ld      e,d
  20++D79D 0E 00       >                        ld      c,0;ld      d,0
  21++D79F              .AddSpeedToX:           AddSpeedToVert UBnKxlo
  21++D79F ED 5B 21 C0 >                        ld      de,(UBnKxlo+1)
  21++D7A3 3A 20 C0    >                        ld      a,(UBnKxlo)
  21++D7A6 6F          >                        ld      l,a
  21++D7A7 CD 14 01    >                        call    AddBCHtoDELsigned               ; DEL = DEL + BCH
  21++D7AA 7D          >                        ld      a,l
  21++D7AB 32 20 C0    >                        ld      (UBnKxlo),a
  21++D7AE ED 53 21 C0 >                        ld      (UBnKxlo+1),de
  22++D7B2              .ApplyToY:              SpeedMulAxis    iyl, UBnkrotmatNosevY
  22++D7B2 FD 5D       >                        ld      e,iyl
  22++D7B4 2A 38 C0    >                        ld      hl,(UBnkrotmatNosevY)
  22++D7B7 7C          >                        ld      a,h
  22++D7B8             >                        ClearSignBitA
  22++D7B8 E6 7F       >                        and     SignMask8Bit
  22++D7BA 57          >                        ld      d,a
  22++D7BB ED 30       >                        mul     de
  22++D7BD 7C          >                        ld      a,h
  22++D7BE             >                        SignBitOnlyA
  22++D7BE E6 80       >                        and     SignOnly8Bit
  22++D7C0 47          >                        ld      b,a;ld      c,a
  22++D7C1 62          >                        ld      h,d;ld      e,d
  22++D7C2 0E 00       >                        ld      c,0;ld      d,0
  23++D7C4              .AddSpeedToY:           AddSpeedToVert UBnKylo
  23++D7C4 ED 5B 24 C0 >                        ld      de,(UBnKylo+1)
  23++D7C8 3A 23 C0    >                        ld      a,(UBnKylo)
  23++D7CB 6F          >                        ld      l,a
  23++D7CC CD 14 01    >                        call    AddBCHtoDELsigned               ; DEL = DEL + BCH
  23++D7CF 7D          >                        ld      a,l
  23++D7D0 32 23 C0    >                        ld      (UBnKylo),a
  23++D7D3 ED 53 24 C0 >                        ld      (UBnKylo+1),de
  24++D7D7              .ApplyToZ:              SpeedMulAxis    iyl, UBnkrotmatNosevZ
  24++D7D7 FD 5D       >                        ld      e,iyl
  24++D7D9 2A 3A C0    >                        ld      hl,(UBnkrotmatNosevZ)
  24++D7DC 7C          >                        ld      a,h
  24++D7DD             >                        ClearSignBitA
  24++D7DD E6 7F       >                        and     SignMask8Bit
  24++D7DF 57          >                        ld      d,a
  24++D7E0 ED 30       >                        mul     de
  24++D7E2 7C          >                        ld      a,h
  24++D7E3             >                        SignBitOnlyA
  24++D7E3 E6 80       >                        and     SignOnly8Bit
  24++D7E5 47          >                        ld      b,a;ld      c,a
  24++D7E6 62          >                        ld      h,d;ld      e,d
  24++D7E7 0E 00       >                        ld      c,0;ld      d,0
  25++D7E9              .AddSpeedToZ:           AddSpeedToVert UBnKzlo
  25++D7E9 ED 5B 27 C0 >                        ld      de,(UBnKzlo+1)
  25++D7ED 3A 26 C0    >                        ld      a,(UBnKzlo)
  25++D7F0 6F          >                        ld      l,a
  25++D7F1 CD 14 01    >                        call    AddBCHtoDELsigned               ; DEL = DEL + BCH
  25++D7F4 7D          >                        ld      a,l
  25++D7F5 32 26 C0    >                        ld      (UBnKzlo),a
  25++D7F8 ED 53 27 C0 >                        ld      (UBnKzlo+1),de
  26++D7FC C9                                   ret
  27++D7FD
# file closed: ../../Tests/3DTest/../../Universe/Ships/ApplyShipSpeed.asm
 867+ D7FD                          INCLUDE "../../ModelRender/DrawLines.asm"
# file opened: ../../Tests/3DTest/../../ModelRender/DrawLines.asm
   1++D7FD
   2++D7FD
   3++D7FD              ; ---------------------------------------------------------------------------------------------------------------------------------
   4++D7FD 00           DrawLinesCounter		db	0
   5++D7FE              ; Initial tests look OK
   6++D7FE              LL155:;
   7++D7FE              ClearLine:                                  ; CLEAR LINEstr visited by EE31 when XX3 heap ready to draw/erase lines in XX19 heap.
   8++D7FE                    ;break                                                                             ; ObjectInFront:
   9++D7FE 3E 65        DrawLines:              ld	a,$65 ; DEBUG
  10++D800 FD 6F                                ld    iyl,a							; set ixl to colour (assuming we come in here with a = colour to draw)
  11++D802 3A 2B C4                             ld	a,(UbnkLineArrayLen)			; get number of lines
  12++D805                                      ReturnIfAIsZero   						; No lines then bail out.
  12++D805 A7          >                        and     a
  12++D806 C8          >                        ret     z
  13++D807 FD 67                                ld	iyh,a			                ; number of lines still to draw
  14++D809 21 71 C2                             ld	hl,UbnkLineArray
  15++D80C 4E           .DrawLinesLoop:         ld    c,(hl)                          ; (XX19),Y c = varX1
  16++D80D 23                                   inc   hl
  17++D80E 46                                   ld    b,(hl)                          ; bc = point1 Y,X
  18++D80F 23                                   inc   hl
  19++D810 5E                                   ld    e,(hl)                          ; c = varX1
  20++D811 23                                   inc   hl
  21++D812 56                                   ld    d,(hl)                          ; de = point2 Y,X
  22++D813 23                                   inc   hl
  23++D814 E5 FD E5                             push  hl,,iy
  24++D817 60                                   ld    h,b
  25++D818 69                                   ld    l,c
  26++D819                ;  call    l2_draw_any_line                ; call version of LOIN that used BCDE
  27++D819 FD 7D                                ld	a,iyl							; get colour back before calling line draw
  28++D81B                                      MMUSelectLayer2
  28++D81B ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
  29++D81F CD 82 FB                             call  LineHLtoDE
  30++D822 FD E1 E1                             pop   hl,,iy
  31++D825 FD 25                                dec   iyh
  32++D827 20 E3                                jr	nz, .DrawLinesLoop
  33++D829 C9                                   ret                                     ; --- Wireframe end  \ LL118-1
  34++D82A
  35++D82A 3E 65        DrawLinesLateClipping:  ld	a,$65 ; DEBUG
  36++D82C FD 6F                                ld    iyl,a					            ; set ixl to colour (assuming we come in here with a = colour to draw)
  37++D82E 3A 2B C4                             ld	a,(UbnkLineArrayLen)			; get number of lines
  38++D831                                      ReturnIfAIsZero   				    ; No lines then bail out.
  38++D831 A7          >                        and     a
  38++D832 C8          >                        ret     z
  39++D833 FD 67                                ld	iyh,a			                  ; number of lines still to draw
  40++D835 21 71 C2                             ld	hl,UbnkLineArray
  41++D838                                      MMUSelectLayer2
  41++D838 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
  42++D83C 3E BF                                ld    a,$BF
  43++D83E 32 FA E3                             ld    (line_gfx_colour),a
  44++D841 11 41 F2     LateDrawLinesLoop:      ld    de,x1
  45++D844                                      FourLDIInstrunctions
  45++D844 ED A0       >                        ldi
  45++D846 ED A0       >                        ldi
  45++D848 ED A0       >                        ldi
  45++D84A ED A0       >                        ldi
  46++D84C                                      FourLDIInstrunctions
  46++D84C ED A0       >                        ldi
  46++D84E ED A0       >                        ldi
  46++D850 ED A0       >                        ldi
  46++D852 ED A0       >                        ldi
  47++D854 E5 FD E5                             push  hl,,iy
  48++D857                                      //call  l2_draw_clipped_line
  49++D857                                      //call  l2_draw_elite_line
  50++D857 CD D1 F8                             call    l2_draw_6502_line
  51++D85A DA 96 D8                             jp      c,LateNoLineToDraw
  52++D85D                                      DISPLAY "TODO - Optimise fetching direct from XX1510 rather than using x1 to y2 as an interface"
  53++D85D E5 C5 D5 FD  PreLate:                push    hl,,bc,,de,,iy
  53++D861 E5
  54++D862 3A 41 F2                             ld      a,(x1)
  55++D865 4F                                   ld      c,a
  56++D866 3A 43 F2                             ld      a,(y1)
  57++D869 47                                   ld      b,a
  58++D86A 3A 45 F2                             ld      a,(x2)
  59++D86D 5F                                   ld      e,a
  60++D86E 3A 47 F2                             ld      a,(y2)
  61++D871 57                                   ld      d,a
  62++D872                                      ; bc = y0,x0 de=y1,x1,a=color)
  63++D872 3E D5                                ld	    a, $D5 ; colour
  64++D874              ReadyToDraw:            MMUSelectLayer2
  64++D874 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
  65++D878 78           .CheckHorz:             ld      a,b                      ; Are y1 and y2 the same?
  66++D879 BA                                   cp      d                        ; .
  67++D87A C2 83 D8                             jp      nz,.ItsNotHorizontal     ; .
  68++D87D CD EC F1     .ItsHorizontal:         call    l2_drawHorzClip          ; if so its a horizontal line
  69++D880 C3 91 D8                             jp      DrawnLine                ; done draw
  70++D883 79           .ItsNotHorizontal:      ld      a,c                      ; Are x1 and x2 the same?
  71++D884 BB                                   cp      e
  72++D885 C2 8E D8                             jp      nz,LateLine
  73++D888 CD BB F1     .ItsVertical:           call    l2_drawVertClip
  74++D88B C3 91 D8                             jp      DrawnLine
  75++D88E CD 11 F9     LateLine:               call    l2_draw_elite_line; l2_draw_diagonal ** NOTE DOESNT DO HORZ OR VERT
  76++D891 FD E1 D1 C1  DrawnLine:              pop     hl,,bc,,de,,iy
  76++D895 E1
  77++D896 FD E1 E1     LateNoLineToDraw:       pop   hl,,iy
  78++D899 FD 25                                dec   iyh
  79++D89B 20 A4                                jr	nz, LateDrawLinesLoop
  80++D89D C9                                   ret                                     ; --- Wireframe end  \ LL118-1
# file closed: ../../Tests/3DTest/../../ModelRender/DrawLines.asm
 868+ D89E              ; ---------------------------------------------------------------------------------------------------------------------------------
 869+ D89E
 870+ D89E              ; DIot seem to lawyas have Y = 0???
 871+ D89E              ProcessDot:            ; break
 872+ D89E CD 91 CA                             call    CopyRotmatToTransMat             ;#01; Load to Rotation Matrix to XX16, 16th bit is sign bit
 873+ D8A1 CD 48 65                             call    ScaleXX16Matrix197               ;#02; Normalise XX16
 874+ D8A4 CD 4A CD                             call    LoadCraftToCamera                ;#04; Load Ship Coords to XX18
 875+ D8A7 CD 17 CC                             call    InverseXX16                      ;#11; Invert rotation matrix
 876+ D8AA 21 00 00                             ld      hl,0
 877+ D8AD 22 E7 C0                             ld      (UBnkXScaled),hl
 878+ D8B0 22 E9 C0                             ld      (UBnkYScaled),hl
 879+ D8B3 22 EB C0                             ld      (UBnkZScaled),hl
 880+ D8B6 AF                                   xor     a
 881+ D8B7 CD AA 64                             call    XX12EquNodeDotOrientation
 882+ D8BA CD BB CA                             call    TransposeXX12ByShipToXX15
 883+ D8BD CD 38 CB                             call    ScaleNodeTo8Bit                     ; scale to 8 bit values, why don't we hold the magnitude here?x
 884+ D8C0 FD 21 31 C1                          ld      iy,UBnkNodeArray
 885+ D8C4 CD 32 D3                             call    ProjectNodeToEye
 886+ D8C7 C9                                   ret
 887+ D8C8
 888+ D8C8              ; .....................................................
 889+ D8C8              ; Plot Node points as part of debugging
 890+ D8C8 3A 40 C4     PlotAllNodes:           ld      a,(VertexCtX6Addr)               ; get Hull byte#9 = number of vertices *6                                   ;;;
 891+ D8CB 4F           .GetActualVertexCount:  ld      c,a                              ; XX20 also c = number of vertices * 6 (or XX20)
 892+ D8CC 4F                                   ld      c,a                              ; XX20 also c = number of vertices * 6 (or XX20)
 893+ D8CD 16 06                                ld      d,6
 894+ D8CF CD 78 70                             call    asm_div8                         ; asm_div8 C_Div_D - C is the numerator, D is the denominator, A is the remainder, B is 0, C is the result of C/D,D,E,H,L are not changed"
 895+ D8D2 41                                   ld      b,c                              ; c = number of vertices
 896+ D8D3 FD 21 31 C1                          ld      iy,UBnkNodeArray
 897+ D8D7 FD 5E 00     .PlotLoop:              ld      e,(iy)
 898+ D8DA FD 56 01                             ld      d,(iy+1)
 899+ D8DD FD 6E 02                             ld      l,(iy+2)
 900+ D8E0 FD 66 03                             ld      h,(iy+3)
 901+ D8E3 C5 FD E5                             push    bc,,iy
 902+ D8E6 CD F7 D8                             call    PlotAtDEHL
 903+ D8E9 FD E1 C1                             pop     bc,,iy
 904+ D8EC FD 23                                inc     iy
 905+ D8EE FD 23                                inc     iy
 906+ D8F0 FD 23                                inc     iy
 907+ D8F2 FD 23                                inc     iy
 908+ D8F4 10 E1                                djnz    .PlotLoop
 909+ D8F6 C9                                   ret
 910+ D8F7
 911+ D8F7 7A           PlotAtDEHL:             ld      a,d
 912+ D8F8 A7                                   and     a
 913+ D8F9 C0                                   ret     nz
 914+ D8FA 7C                                   ld      a,h
 915+ D8FB A7                                   and     a
 916+ D8FC C0                                   ret     nz
 917+ D8FD 7D                                   ld      a,l
 918+ D8FE E6 80                                and     $80
 919+ D900 C0                                   ret     nz
 920+ D901                                      MMUSelectLayer2
 920+ D901 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 921+ D905 45                                   ld      b,l
 922+ D906 4B                                   ld      c,e
 923+ D907 3E 88                                ld      a,$88
 924+ D909 CD FB E3                             call    l2_plot_pixel
 925+ D90C C9                                   ret
 926+ D90D
 927+ D90D
 928+ D90D              ; .....................................................
 929+ D90D              ; Process Nodes does the following:
 930+ D90D              ; for each node:
 931+ D90D              ;     see if node >
 932+ D90D 00           PNXX20DIV6          DB      0
 933+ D90E 00 00        PNVERTEXPTR         DW      0   ; DEBUG WILL USE LATER
 934+ D910 00 00        PNNODEPRT           DW      0   ; DEBUG WILL USE LATER
 935+ D912 00           PNLASTNORM          DB      0
 936+ D913              ProcessNodes:           ZeroA
 936+ D913 AF          >                        xor a
 937+ D914 32 2B C4                             ld      (UbnkLineArrayLen),a
 938+ D917 CD 91 CA                             call    CopyRotmatToTransMat ; CopyRotToTransMacro                      ;#01; Load to Rotation Matrix to XX16, 16th bit is sign bit
 939+ D91A CD 48 65                             call    ScaleXX16Matrix197               ;#02; Normalise XX16
 940+ D91D CD 4A CD                             call    LoadCraftToCamera                ;#04; Load Ship Coords to XX18
 941+ D920 CD 17 CC                             call    InverseXX16                      ;#11; Invert rotation matrix
 942+ D923 21 52 C4                             ld      hl,UBnkHullVerticies
 943+ D926 3A 40 C4                             ld      a,(VertexCtX6Addr)               ; get Hull byte#9 = number of vertices *6                                   ;;;
 944+ D929 4F           GetActualVertexCount:   ld      c,a                              ; XX20 also c = number of vertices * 6 (or XX20)
 945+ D92A 4F                                   ld      c,a                              ; XX20 also c = number of vertices * 6 (or XX20)
 946+ D92B 16 06                                ld      d,6
 947+ D92D CD 78 70                             call    asm_div8                         ; asm_div8 C_Div_D - C is the numerator, D is the denominator, A is the remainder, B is 0, C is the result of C/D,D,E,H,L are not changed"
 948+ D930 41                                   ld      b,c                              ; c = number of vertices
 949+ D931 FD 21 31 C1                          ld      iy,UBnkNodeArray
 950+ D935              LL48:
 951+ D935 C5           PointLoop:              push    bc                                  ; save counters
 952+ D936 E5                                   push    hl                                  ; save verticies list pointer
 953+ D937 FD E5                                push    iy                                  ; save Screen plot array pointer
 954+ D939 78                                   ld      a,b
 955+ D93A                                      ;break
 956+ D93A CD B3 D2                             call    CopyNodeToXX15                      ; copy verices at hl to xx15
 957+ D93D 3A E8 C0                             ld      a,(UBnkXScaledSign)
 958+ D940 CD AA 64                             call    XX12EquNodeDotOrientation
 959+ D943 CD BB CA                             call    TransposeXX12ByShipToXX15
 960+ D946 CD 38 CB                             call    ScaleNodeTo8Bit                     ; scale to 8 bit values, why don't we hold the magnitude here?x
 961+ D949 FD E1                                pop     iy                                  ; get back screen plot array pointer
 962+ D94B CD 32 D3                             call    ProjectNodeToEye                     ; set up screen plot list entry
 963+ D94E                 ; ld      hl,UbnkLineArrayLen
 964+ D94E                ;  inc     (hl)                                ; another node done
 965+ D94E FD E5        ReadyForNextPoint:      push    iy                                  ; copy screen plot pointer to hl
 966+ D950 E1                                   pop     hl
 967+ D951 3E 04                                ld      a,4
 968+ D953 ED 31                                add     hl,a
 969+ D955 E5                                   push    hl                                  ; write it back at iy + 4
 970+ D956 FD E1                                pop     iy                                  ; and put it in iy again
 971+ D958 E1                                   pop     hl                                  ; get hl back as vertex list
 972+ D959 3E 06                                ld      a,6
 973+ D95B ED 31                                add     hl,a                                ; and move to next vertex
 974+ D95D C1                                   pop     bc                                  ; get counter back
 975+ D95E 10 D5                                djnz    PointLoop
 976+ D960              ; ......................................................
 977+ D960                                      ClearCarryFlag
 977+ D960 B7          >                        or a
 978+ D961 C9                                   ret
 979+ D962              ; ...........................................................
 980+ D962 CD 45 CF     ProcessShip:            call    CheckVisible                ; checks for z -ve and outside view frustrum, sets up flags for next bit
 981+ D965              ;............................................................
 982+ D965              .DetermineDrawType:     ReturnOnBitClear    a, ShipIsVisibleBitNbr          ; if its not visible exit early
 982+ D965 CB 77       >                        bit 	ShipIsVisibleBitNbr,a
 982+ D967 C8          >                        ret		z
 983+ D968
 984+ D968              ;............................................................
 985+ D968
 986+ D968 CD 13 D9     .CarryOnWithDraw:       call    ProcessNodes                ; process notes is the poor performer or check distnace is not culling
 987+ D96B                                     ; break
 988+ D96B 3E E3                                ld      a,$E3
 989+ D96D 32 FA E3                             ld      (line_gfx_colour),a
 990+ D970 CD 7E CF                             call    CullV2
 991+ D973 CD 8A D9                             call    PrepLines                       ; With late clipping this just moves the data to the line array which is now x2 size
 992+ D976 CD 2A D8                             call    DrawLinesLateClipping
 993+ D979 C9                                   ret
 994+ D97A
 995+ D97A                  ;INCLUDE "../../Universe/Ships/PrepLines.asm"
 996+ D97A              ;--------------------------------------------------------------------------------------------------------
 997+ D97A                      DISPLAY "Tracing 8", $
 998+ D97A
 999+ D97A                  INCLUDE "../../ModelRender/getVertexNodeAtAToX1Y1.asm"
# file opened: ../../Tests/3DTest/../../ModelRender/getVertexNodeAtAToX1Y1.asm
   1++D97A              ;--------------------------------------------------------------------------------------------------------
   2++D97A              ; a = byteoffset to node array as its pre computed to x4 bytes
   3++D97A 21 31 C1     getVertexNodeAtAToDE:   ld          hl,UBnkNodeArray                    ; hl = edgelist  current pointer
   4++D97D ED 31                                add         hl,a                                ; hl = address of Node
   5++D97F 7E                                   ld          a,(hl)                              ; get edge list nbr 1 edge
   6++D980 ED A0                                ldi                                             ; x1 lo
   7++D982 ED A0                                ldi                                             ; x1 hi
   8++D984 ED A0                                ldi                                             ; y1 lo
   9++D986 ED A0                                ldi                                             ; y1 hi
  10++D988 C9                                   ret
  11++D989
  12++D989              ;getVertexNodeAtAToX1Y1: ld          hl,UBnkNodeArray                    ; hl = edgelist  current pointer
  13++D989              ;                        add         hl,a                                ; hl = address of Node
  14++D989              ;                        ld          a,(hl)                              ; get edge list nbr 1 edge
  15++D989              ;                        ld          de,UBnkX1
  16++D989              ;                        ldi                                             ; x1 lo
  17++D989              ;                        ldi                                             ; x1 hi
  18++D989              ;                        ldi                                             ; y1 lo
  19++D989              ;                        ldi                                             ; y1 hi
  20++D989              ;                        ret
  21++D989
# file closed: ../../Tests/3DTest/../../ModelRender/getVertexNodeAtAToX1Y1.asm
1000+ D989
1001+ D989                      DISPLAY "Tracing 9", $
1002+ D989
1003+ D989                  INCLUDE "../../ModelRender/getVertexNodeAtAToX2Y2.asm"
# file opened: ../../Tests/3DTest/../../ModelRender/getVertexNodeAtAToX2Y2.asm
   1++D989              ;--------------------------------------------------------------------------------------------------------
   2++D989              ; a = byteoffset to node array as its pre computed to x4 bytes
   3++D989              ;getVertexNodeAtAToX2Y2: ld          hl,UBnkNodeArray                    ; hl = edgelist  current pointer
   4++D989              ;                        add         hl,a                                ; hl = address of Node
   5++D989              ;                        ld          a,(hl)                              ; get edge list nbr 1 edge
   6++D989              ;                        ld          de,UBnkX2
   7++D989              ;                        ldi                                             ; x1 lo
   8++D989              ;                        ldi                                             ; x1 hi
   9++D989              ;                        ldi                                             ; y1 lo
  10++D989              ;                        ldi                                             ; y1 hi
  11++D989              ;                        ret
# file closed: ../../Tests/3DTest/../../ModelRender/getVertexNodeAtAToX2Y2.asm
1004+ D989                      DISPLAY "Tracing 10", $
1005+ D989
1006+ D989                  INCLUDE "../../ModelRender/GetFaceAtA.asm"
# file opened: ../../Tests/3DTest/../../ModelRender/GetFaceAtA.asm
   1++D989              ;--------------------------------------------------------------------------------------------------------
   2++D989              GetFaceAtA:         MACRO
   3++D989 ~                                ld          hl,UbnkFaceVisArray
   4++D989 ~                                add         hl,a
   5++D989 ~                                ld          a,(hl)                              ; get face visibility
   6++D989                                  ENDM
   7++D989
# file closed: ../../Tests/3DTest/../../ModelRender/GetFaceAtA.asm
1007+ D989                      DISPLAY "Tracing 11", $
1008+ D989
1009+ D989              ;--------------------------------------------------------------------------------------------------------
1010+ D989              ; LL72 Goes through each edge in to determine if they are on a visible face, if so load start and end to line array as clipped lines
1011+ D989               ;   DEFINE NOBACKFACECULL 1
1012+ D989 00           PLEDGECTR           DB          0
1013+ D98A
1014+ D98A              PrepLines:
1015+ D98A              InitialiseLineRead:
1016+ D98A                      ;break
1017+ D98A                      ldWriteZero UbnkLineArrayLen                    ; current line array index = 0
1017+ D98A AF          >                        xor      a
1017+ D98B 32 2B C4    >                        ld       (UbnkLineArrayLen),a
1018+ D98E 32 2C C4             ld          (UbnkLineArrayBytes),a              ; UbnkLineArrayBytes= nbr of bytes of lines laoded = array len * 4
1019+ D991 32 89 D9             ld          (PLEDGECTR),a
1020+ D994 3A 41 C4             ld          a,(EdgeCountAddr)
1021+ D997 DD 67                ld          ixh,a                               ; ixh = XX17 = Total number of edges to traverse
1022+ D999 FD 2E 00             ld          iyl,0                               ; ixl = current edge index
1023+ D99C 21 71 C2             ld          hl,UbnkLineArray                    ; head of array
1024+ D99F 22 08 67             ld          (varU16),hl                         ; store current line array pointer un varU16
1025+ D9A2                      ldCopyByte  EdgeCountAddr, XX17                 ; XX17  = total number of edges to traverse edge counter
1025+ D9A2 3A 41 C4    >                        ld       a,(EdgeCountAddr)
1025+ D9A5 32 0C 67    >                        ld       (XX17),a
1026+ D9A8 3A 91 C0             ld          a,(UBnKexplDsp)                     ; get explosion status
1027+ D9AB                      JumpOnBitClear a,6,CalculateNewLines            ; LL170 bit6 of display state clear (laser not firing) \ Calculate new lines
1027+ D9AB CB 77       >                        bit 	6,a
1027+ D9AD CA B5 D9    >                        jp      z,CalculateNewLines
1028+ D9B0 E6 BF                and         $BF                                 ; else laser is firing, clear bit6.
1029+ D9B2 32 91 C0             ld          (UBnKexplDsp),a                     ; INWK+31
1030+ D9B5              ;   TODO commentedout as teh subroutine is a mess   call        AddLaserBeamLine                    ; add laser beam line to draw list
1031+ D9B5              ; NOw we can calculate hull after including laser line
1032+ D9B5              CalculateNewLines:
1033+ D9B5              LL170:                                                  ;(laser not firing) \ Calculate new lines   \ their comment
1034+ D9B5              CheckEdgesForVisibility:
1035+ D9B5 21 42 C5             ld          hl,UBnkHullEdges
1036+ D9B8                      ; TODO change heap to 3 separate arrays and break them down during copy of ship hull data
1037+ D9B8 22 0B 66             ld          (varV),hl                           ; V \ is pointer to where edges data start
1038+ D9BB 3A 3C C4             ld          a,(LineX4Addr)
1039+ D9BE 47                   ld          b,a                                 ; nbr of bytes of edge data
1040+ D9BF              LL75Loop:                                               ; count Visible edges
1041+ D9BF              IsEdgeInVisibilityRange:
1042+ D9BF 2A 0B 66             ld          hl,(varV)
1043+ D9C2 E5                   push        hl
1044+ D9C3 FD E1                pop         iy
1045+ D9C5 3A F6 65             ld          a,(LastNormalVisible)               ; XX4 is visibility range
1046+ D9C8 57                   ld          d,a                                 ; d holds copy of XX4
1047+ D9C9              ; Get Edge Byte 0
1048+ D9C9 FD 7E 00             ld          a,(IY+0)                            ; edge data byte#0 is visibility distance
1049+ D9CC                      JumpIfALTNusng d,LL78EdgeNotVisible             ; XX4   \ visibility LLx78 edge not visible
1049+ D9CC BA          >                        cp      d
1049+ D9CD DA 28 DA    >                        jp		c, LL78EdgeNotVisible
1050+ D9D0              EdgeMayBeVisibile:
1051+ D9D0              ; Get Edge Byte 1
1052+ D9D0              IsFace1Visibile:                                        ; edges have 2 faces to test
1053+ D9D0 FD 7E 01             ld          a,(IY+1)                            ; (V),Y \ edge data byte#1 bits 0 to 3 face 1 4 to 7 face 2
1054+ D9D3 4F                   ld          c,a                                 ;  c = a copy of byte 1
1055+ D9D4 E6 0F                and         $0F                                 ;
1056+ D9D6                      GetFaceAtA
1056+ D9D6 21 13 C1    >                    ld          hl,UbnkFaceVisArray
1056+ D9D9 ED 31       >                    add         hl,a
1056+ D9DB 7E          >                    ld          a,(hl)                              ; get face visibility
1057+ D9DC              ;       jp  VisibileEdge; DEBUG BODGE TEST TODO
1058+ D9DC                      JumpIfAIsNotZero VisibileEdge                     ; LL70 visible edge
1058+ D9DC A7          >                        and     a
1058+ D9DD C2 F1 D9    >                        jp	    nz,VisibileEdge
1059+ D9E0              IsFace2Visibile:
1060+ D9E0 79                   ld          a,c                                 ; restore byte 1 from c register
1061+ D9E1 ED 23                swapnib                                         ;
1062+ D9E3 E6 0F                and         $0F                                 ; swap high byte into low byte
1063+ D9E5 E5                   push        hl
1064+ D9E6                      GetFaceAtA
1064+ D9E6 21 13 C1    >                    ld          hl,UbnkFaceVisArray
1064+ D9E9 ED 31       >                    add         hl,a
1064+ D9EB 7E          >                    ld          a,(hl)                              ; get face visibility
1065+ D9EC E1                   pop         hl
1066+ D9ED                      JumpIfAIsZero LL78EdgeNotVisible                ; edge not visible
1066+ D9ED A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
1066+ D9EE CA 28 DA    >                        jp	    z, LL78EdgeNotVisible
1067+ D9F1              VisibileEdge:                                           ; Now we need to node id from bytes 2 - start and 3 - end
1068+ D9F1              ;LL79--Visible edge--------------------------------------
1069+ D9F1              ; Get Edge Byte 2
1070+ D9F1 FD 7E 02             ld          a,(IY+2)                            ; get Node id
1071+ D9F4 11 E7 C0             ld          de,UBnkX1
1072+ D9F7 CD 7A D9             call        getVertexNodeAtAToDE; getVertexNodeAtAToX1Y1              ; get the points X1Y1 from node
1073+ D9FA FD 7E 03             ld          a,(IY+3)
1074+ D9FD 11 EB C0             ld          de,UBnkX2
1075+ DA00 CD 7A D9             call        getVertexNodeAtAToDE; getVertexNodeAtAToX2Y2              ; get the points X2Y2 from node
1076+ DA03              LL80:                                                   ; ll80 \ Shove visible edge onto XX19 ship lines heap counter U
1077+ DA03 ED 5B 08 67          ld          de,(varU16)                         ; clipped edges heap address
1078+ DA07 21 E7 C0             ld          hl,UbnkPreClipX1
1079+ DA0A                      FourLDIInstrunctions
1079+ DA0A ED A0       >                        ldi
1079+ DA0C ED A0       >                        ldi
1079+ DA0E ED A0       >                        ldi
1079+ DA10 ED A0       >                        ldi
1080+ DA12                      FourLDIInstrunctions
1080+ DA12 ED A0       >                        ldi
1080+ DA14 ED A0       >                        ldi
1080+ DA16 ED A0       >                        ldi
1080+ DA18 ED A0       >                        ldi
1081+ DA1A ED 53 08 67          ld          (varU16),de                         ; update U16 with current address
1082+ DA1E 21 2B C4             ld          hl,UbnkLineArrayLen                 ; we have loaded one line
1083+ DA21 34                   inc         (hl)
1084+ DA22 7E                   ld          a,(hl)
1085+ DA23                      JumpIfAGTENusng LineArraySize,CompletedLineGeneration   ; have we hit max lines for a model hop over jmp to Exit edge data loop
1085+ DA23 FE 32       >                        cp     LineArraySize
1085+ DA25 D2 3E DA    >                        jp		nc,CompletedLineGeneration
1086+ DA28              ; If we hit here we skip the write of line arryay u16
1087+ DA28              LL78EdgeNotVisible:                                     ; also arrive here if Edge not visible, loop next data edge.
1088+ DA28              LL78:
1089+ DA28 2A 0B 66             ld          hl,(varV)                           ; varV is current edge address
1090+ DA2B 3E 04                ld          a,4
1091+ DA2D ED 31                add         hl,a
1092+ DA2F 22 0B 66             ld          (varV),hl
1093+ DA32 21 89 D9             ld          hl,PLEDGECTR                        ;
1094+ DA35 34                   inc         (hl)                                ;
1095+ DA36 7E                   ld          a,(hl)                              ; current edge index ++
1096+ DA37                      JumpIfANEMemusng XX17,LL75Loop                  ; compare with total number of edges
1096+ DA37 21 0C 67    >                        ld    hl,XX17
1096+ DA3A BE          >                        cp    (hl)
1096+ DA3B C2 BF D9    >                        jp      nz,LL75Loop
1097+ DA3E              CompletedLineGeneration:
1098+ DA3E              LL81:
1099+ DA3E              LL81SHPPT:                                              ; SHPPT ship is a point arrives here with Acc=2, bottom entry in heap
1100+ DA3E 3A 2B C4             ld          a,(UbnkLineArrayLen)                ; UbnkLineArrayLen = nbr of lines loaded
1101+ DA41 CB 27                sla         a
1102+ DA43 CB 27                sla         a                                   ; multiple by 4 to equal number of bytes
1103+ DA45 CB 27                sla         a                           ; multiple by 8 to equal number of bytes
1104+ DA47 32 2C C4             ld          (UbnkLineArrayBytes),a              ; UbnkLineArrayBytes= nbr of bytes of lines laoded = array len * 4
1105+ DA4A              ExitEdgeDataLoop:
1106+ DA4A C9                   ret
1107+ DA4B
1108+ DA4B
1109+ DA4B                  DISPLAY "Tracing XX", $
1110+ DA4B
1111+ DA4B              UnivBankSize  EQU $ - StartOfUniv
1112+ DA4B
# file closed: ../../Tests/3DTest/univ_ship_data.asm
 982  DA4B                                  DISPLAY "Sizing Bank ",BankUNIVDATA0," - Start ",UniverseBankAddr," End - ",$, "- Universe Data A"
 983  DA4B                                  DISPLAY "Bank ",BankUNIVDATA0," - Bytes free ",/D, $2000 - ($-UniverseBankAddr), "- Universe Data A"
 984  DA4B                                  ASSERT $-UniverseBankAddr <8912, Bank code leaks over 8K boundary
 985  DA4B              ; Bank 99  ------------------------------------------------------------------------------------------------------------------------
 986  DA4B                                  SLOT    MathsTablesAddr
 987  DA4B                                  PAGE    BankMathsTables
 988  DA4B                                  ORG     MathsTablesAddr,BankMathsTables
 989  0000                                  INCLUDE "../../Maths/logmaths.asm"
# file opened: ../../Maths/logmaths.asm
   1+ 0000 4C 6F 67 4D  logmaths_page_marker    DB "LogMaths   PG99"
   1+ 0004 61 74 68 73
   1+ 0008 20 20 20 50
   1+ 000C 47 39 39
   2+ 000F
   3+ 000F EB           AntiLogHL:              ex      de,hl
   4+ 0010 21 83 05                             ld      hl,LogReverseHighByte
   5+ 0013 01 14 02                             ld      bc,LogReverseTableLen
   6+ 0016 7A                                   ld      a,d
   7+ 0017 ED A1        .SearchLoop:            cpi                                     ; first pass index into high byte
   8+ 0019 28 03                                jr      z,.FoundHighByte
   9+ 001B 23                                   inc     hl
  10+ 001C 18 F9                                jr      .SearchLoop
  11+ 001E 23           .FoundHighByte:         inc     hl                              ; now we have high double it for table of words
  12+ 001F 7E                                   ld      a,(hl)                          ; .
  13+ 0020 21 83 03                             ld      hl,LogTable                     ; .
  14+ 0023 ED 31                                add     hl,a                            ; .
  15+ 0025 ED 31                                add     hl,a                            ; .
  16+ 0027 7A           .LookForLowByteLoop:    ld      a,d                             ; search for low byte or change in high byte
  17+ 0028 BE                                   cp      (hl)
  18+ 0029 20 09                                jr      nz,.SkippedPastHigh
  19+ 002B 23                                   inc     hl
  20+ 002C 7B                                   ld      a,e
  21+ 002D                                      JumpIfAGTENusng (hl), .SkippedPastLow
  21+ 002D BE          >                        cp     (hl)
  21+ 002E D2 35 00    >                        jp		nc,.SkippedPastLow
  22+ 0031 C3 27 00                             jp      .LookForLowByteLoop
  23+ 0034
  24+ 0034 2B           .SkippedPastHigh:       dec     hl                              ; for high we are on next word
  25+ 0035 2B           .SkippedPastLow:        dec     hl                              ; for low we are no next byte
  26+ 0036 EB                                   ex      de,hl                           ; move address to de for subtract
  27+ 0037 21 83 03                             ld      hl,LogTable                     ; subtract from log table address
  28+ 003A                                      ClearCarryFlag
  28+ 003A B7          >                        or a
  29+ 003B ED 52                                sbc     hl,de                           ; so nwo we have nbr of words, i.e anito log * 2
  30+ 003D                                      ShiftHLRight1                           ; now must be >= 255
  30+ 003D CB 3C       >               srl h
  30+ 003F CB 1D       >               rr  l
  31+ 0041 7D                                   ld      a,l
  32+ 0042 C9                                   ret
  33+ 0043
  34+ 0043              ; calculates R = 256 * A / Q
  35+ 0043              Requ256mulAdivQ_Log:    JumpIfAGTEMemusng varQ, LL2             ; If A >= Q, then the answer will not fit in one byte, return 255
  35+ 0043 21 05 67    >                        ld      hl,varQ
  35+ 0046 BE          >                        cp      (hl)
  35+ 0047 D2 BB 00    >                        jp		nc,LL2
  36+ 004A FD 6F                                ld      iyl,a                           ; STA widget             \ Store A in widget, so now widget = argument A
  37+ 004C DD 67                                ld      ixh,a                           ; TAX                    \ Transfer A into X, so now X = argument A
  38+ 004E                                      JumpIfAIsZero LLfix                     ; If A = 0, jump to LLfix to return a result of 0
  38+ 004E A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
  38+ 004F CA B7 00    >                        jp	    z, LLfix
  39+ 0052              ; calculate log(A) - log(Q), first adding the low bytes (from the logL table), and then the high bytes (from the log table)
  40+ 0052              ; this determins if we branch to antilog or antilogodd for negative value
  41+ 0052 21 83 03     .GetLogA:               ld      hl,LogTable                     ; LDA logL,X             \ e = low byte of log(X)
  42+ 0055 ED 31                                add     hl,a                            ; have to add twice as ist 8 bit so cant shift
  43+ 0057 ED 31                                add     hl,a                            ;
  44+ 0059 5E                                   ld      e,(hl)                          ;
  45+ 005A 23                                   inc     hl                              ;
  46+ 005B 56                                   ld      d,(hl)                          ; de = logH[X] logL[X]
  47+ 005C 21 83 03                             ld      hl,LogTable                     ;
  48+ 005F 3A 05 67                             ld      a,(varQ)                        ;
  49+ 0062 ED 31                                add     hl,a                            ;
  50+ 0064 ED 31                                add     hl,a                            ;
  51+ 0066 4E                                   ld      c,(hl)                          ;
  52+ 0067 23                                   inc     hl                              ;
  53+ 0068 46                                   ld      b,(hl)                          ; bc = logH[X] logL[X]
  54+ 0069 7B                                   ld      a,e                             ; SBC logL,X             \       = low byte of log(A) - low byte of log(Q)
  55+ 006A                                      ClearCarryFlag                          ; .
  55+ 006A B7          >                        or a
  56+ 006B 99                                   sbc     a,c                             ; .
  57+ 006C D2 93 00                             jp      nc,NoCarryBranch
  58+ 006F FA 83 00     CarryBranch:            jp      m,.noddlog                     ; BMI noddlog            \ If the subtraction is negative, jump to noddlog
  59+ 0072 5F                                   ld      e,a                             ; save logL[A] - logL[Q] in e, probabyl dont need this
  60+ 0073 7A                                   ld      a,d                             ; a = logH(a)
  61+ 0074              .CarryFlagPoint1:       SetCarryFlag
  61+ 0074 37          >                        scf
  62+ 0075 98                                   sbc     a,b                             ; a = high byte of logH[A] - logH[Q] note carry is not affected from prev sbc
  63+ 0076 D2 BB 00                             jp      nc,LL2                          ; If the subtraction fitted into one byte and didn't underflow, then log(A) - log(Q) < 256, so we jump to LL2 return a result of 255
  64+ 0079 21 83 01                             ld      hl,AntiLogTable                 ; TAX                    \ Otherwise we return the A-th entry from the antilog
  65+ 007C ED 31                                add     hl,a                            ; LDA antilog,X          \ table
  66+ 007E 7E                                   ld      a,(hl)
  67+ 007F 32 06 67                             ld      (varR),a                        ; STA R                  \ Set the result in R to the value of A
  68+ 0082 C9                                   ret                                     ; RTS                    \ Return from the subroutine
  69+ 0083 7A           .noddlog:               ld      a,d                             ; LDX widget             \ Set d = high byte of log(A) - high byte of log(Q)
  70+ 0084              .CarryFlagPoint2:       SetCarryFlag
  70+ 0084 37          >                        scf
  71+ 0085 98                                   sbc     a,b
  72+ 0086 D2 BB 00                             jp      nc,LL2                          ; BCS LL2                \ If the subtraction fitted into one byte and didn't underflow, then log(A) - log(Q) < 256, so we jump to LL2 to return a result of 255
  73+ 0089 21 83 02                             ld      hl, AnitLogODDTable             ; TAX                    \ Otherwise we return the A-th entry from the antilogODD
  74+ 008C ED 31                                add     hl,a                            ; LDA antilogODD,X       \ table
  75+ 008E 7E                                   ld      a,(hl)
  76+ 008F 32 06 67                             ld      (varR),a                        ; STA R                  \ Set the result in R to the value of A
  77+ 0092 C9                                   ret                                     ; RTS                    \ Return from the subroutine
  78+ 0093 FA A7 00     NoCarryBranch:          jp      m,.noddlog                     ; BMI noddlog            \ If the subtraction is negative, jump to noddlog
  79+ 0096 5F                                   ld      e,a                             ; save logL[A] - logL[Q] in e, probabyl dont need this
  80+ 0097 7A                                   ld      a,d                             ; a = logH(a)
  81+ 0098              .CarryFlagPoint1:       ClearCarryFlag
  81+ 0098 B7          >                        or a
  82+ 0099 98                                   sbc     a,b                             ; a = high byte of logH[A] - logH[Q] note carry is not affected from prev sbc
  83+ 009A D2 BB 00                             jp      nc,LL2                          ; If the subtraction fitted into one byte and didn't underflow, then log(A) - log(Q) < 256, so we jump to LL2 return a result of 255
  84+ 009D 21 83 01                             ld      hl,AntiLogTable                 ; TAX                    \ Otherwise we return the A-th entry from the antilog
  85+ 00A0 ED 31                                add     hl,a                            ; LDA antilog,X          \ table
  86+ 00A2 7E                                   ld      a,(hl)
  87+ 00A3 32 06 67                             ld      (varR),a                        ; STA R                  \ Set the result in R to the value of A
  88+ 00A6 C9                                   ret                                     ; RTS                    \ Return from the subroutine
  89+ 00A7 7A           .noddlog:               ld      a,d                             ; LDX widget             \ Set d = high byte of log(A) - high byte of log(Q)
  90+ 00A8              .CarryFlagPoint2:       ClearCarryFlag
  90+ 00A8 B7          >                        or a
  91+ 00A9 98                                   sbc     a,b
  92+ 00AA D2 BB 00                             jp      nc,LL2                          ; BCS LL2                \ If the subtraction fitted into one byte and didn't underflow, then log(A) - log(Q) < 256, so we jump to LL2 to return a result of 255
  93+ 00AD 21 83 02                             ld      hl, AnitLogODDTable             ; TAX                    \ Otherwise we return the A-th entry from the antilogODD
  94+ 00B0 ED 31                                add     hl,a                            ; LDA antilogODD,X       \ table
  95+ 00B2 7E                                   ld      a,(hl)
  96+ 00B3 32 06 67                             ld      (varR),a                        ; STA R                  \ Set the result in R to the value of A
  97+ 00B6 C9                                   ret                                     ; RTS                    \ Return from the subroutine
  98+ 00B7 32 06 67     LLfix:                  ld      (varR),a                        ; Set the result in R to the value of A
  99+ 00BA C9                                   ret                                     ; RTS                    \ Return from the subroutine
 100+ 00BB 3E FF        LL2:                    ld      a,$FF
 101+ 00BD 32 06 67                             ld      (varR),a
 102+ 00C0 C9                                   ret
 103+ 00C1
 104+ 00C1
 105+ 00C1              AEquAmul256DivBLogLT:   JumpIfAIsZero   .ResultIsZero
 105+ 00C1 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 105+ 00C2 CA EA 00    >                        jp	    z, .ResultIsZero
 106+ 00C5 21 83 03                             ld      hl,LogTable                     ; de = log a
 107+ 00C8 ED 31                                add     hl,a                            ; .
 108+ 00CA ED 31                                add     hl,a                            ; .
 109+ 00CC 5E                                   ld      e,(hl)                          ; .
 110+ 00CD 23                                   inc     hl                              ; .
 111+ 00CE 56                                   ld      d,(hl)                          ; .
 112+ 00CF 21 83 03                             ld      hl,LogTable                     ; hl = log b
 113+ 00D2 78                                   ld      a,b                             ; .
 114+ 00D3 ED 31                                add     hl,a                            ; .
 115+ 00D5 ED 31                                add     hl,a                            ; .
 116+ 00D7 7E                                   ld      a,(hl)                          ; .
 117+ 00D8 23                                   inc     hl                              ; .
 118+ 00D9 66                                   ld      h,(hl)                          ; .
 119+ 00DA 6F                                   ld      l,a                             ; .
 120+ 00DB                                      ClearCarryFlag                          ;
 120+ 00DB B7          >                        or a
 121+ 00DC EB                                   ex      de,hl                           ; now hl = log a and de = log b
 122+ 00DD ED 52                                sbc     hl,de                           ; hl = log a - log b
 123+ 00DF 7C                                   ld      a,h                             ; .
 124+ 00E0 21 83 02                             ld      hl,AnitLogODDTable               ; hl = anti log (log a - log b)
 125+ 00E3 ED 31                                add     hl,a                            ; which is also a / b
 126+ 00E5 ED 31                                add     hl,a                            ; .
 127+ 00E7 7E                                   ld      a,(hl)                          ; .
 128+ 00E8                                      ClearCarryFlag                          ;
 128+ 00E8 B7          >                        or a
 129+ 00E9 C9                                   ret
 130+ 00EA              .ResultIsZero:          ClearCarryFlag
 130+ 00EA B7          >                        or a
 131+ 00EB                                      ZeroA
 131+ 00EB AF          >                        xor a
 132+ 00EC C9                                   ret
 133+ 00ED
 134+ 00ED              AEquAmul256DivBLog:     JumpIfAIsZero   .ResultIsZero
 134+ 00ED A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 134+ 00EE CA 24 01    >                        jp	    z, .ResultIsZero
 135+ 00F1                                      JumpIfAGTENusng d, AEquAmul256DivBLogLT
 135+ 00F1 BA          >                        cp     d
 135+ 00F2 D2 C1 00    >                        jp		nc,AEquAmul256DivBLogLT
 136+ 00F5 21 83 03                             ld      hl,LogTable                     ; de = log a
 137+ 00F8 ED 31                                add     hl,a                            ; .
 138+ 00FA ED 31                                add     hl,a                            ; .
 139+ 00FC 5E                                   ld      e,(hl)                          ; .
 140+ 00FD 23                                   inc     hl                              ; .
 141+ 00FE 56                                   ld      d,(hl)                          ; .
 142+ 00FF 21 83 03                             ld      hl,LogTable                     ; hl = log b
 143+ 0102 78                                   ld      a,b                             ; .
 144+ 0103 ED 31                                add     hl,a                            ; .
 145+ 0105 ED 31                                add     hl,a                            ; .
 146+ 0107 7E                                   ld      a,(hl)                          ; .
 147+ 0108 23                                   inc     hl                              ; .
 148+ 0109 66                                   ld      h,(hl)                          ; .
 149+ 010A 6F                                   ld      l,a                             ; .
 150+ 010B                                      ClearCarryFlag                          ;
 150+ 010B B7          >                        or a
 151+ 010C EB                                   ex      de,hl                           ; now hl = log a and de = log b
 152+ 010D ED 52                                sbc     hl,de                           ; hl = log a - log b
 153+ 010F 38 0B                                jr      c,.ResultIsOne                  ; .
 154+ 0111 7C                                   ld      a,h                             ; .
 155+ 0112 21 83 01                             ld      hl,AntiLogTable                 ; hl = anti log (log a - log b)
 156+ 0115 ED 31                                add     hl,a                            ; which is also a / b
 157+ 0117 ED 31                                add     hl,a                            ; .
 158+ 0119 7E                                   ld      a,(hl)                          ; .
 159+ 011A                                      ClearCarryFlag                          ;
 159+ 011A B7          >                        or a
 160+ 011B C9                                   ret
 161+ 011C              .ResultIsOne:           ClearCarryFlag
 161+ 011C B7          >                        or a
 162+ 011D 3E FF                                ld      a,$FF
 163+ 011F C9                                   ret
 164+ 0120              .ResultIsInfinte:       SetCarryFlag
 164+ 0120 37          >                        scf
 165+ 0121 3E FF                                ld      a,$FF
 166+ 0123 C9                                   ret
 167+ 0124              .ResultIsZero:          ClearCarryFlag
 167+ 0124 B7          >                        or a
 168+ 0125 C9                                   ret
 169+ 0126
 170+ 0126              AEquAmul256Div197LogLT: JumpIfAIsZero   .ResultIsZero
 170+ 0126 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 170+ 0127 CA 46 01    >                        jp	    z, .ResultIsZero
 171+ 012A 21 83 03                             ld      hl,LogTable                     ; point to log a in LogTable
 172+ 012D ED 31                                add     hl,a                            ; Note we can't sla in case a > 127
 173+ 012F ED 31                                add     hl,a
 174+ 0131 5E                                   ld      e,(hl)                          ; de = log a
 175+ 0132 23                                   inc     hl                              ; .
 176+ 0133 56                                   ld      d,(hl)                          ; .
 177+ 0134 21 A9 F3                             ld      hl,$F3A9                        ; hl = $F3A9 = log 197
 178+ 0137                                      ClearCarryFlag
 178+ 0137 B7          >                        or a
 179+ 0138 EB                                   ex      hl,de                           ; hl = log a, de = log 197
 180+ 0139 ED 52                                sbc     hl,de
 181+ 013B 7C                                   ld      a,h
 182+ 013C 21 83 02                             ld      hl,AnitLogODDTable
 183+ 013F ED 31                                add     hl,a
 184+ 0141 ED 31                                add     hl,a
 185+ 0143 7E                                   ld      a,(hl)
 186+ 0144                                      ClearCarryFlag
 186+ 0144 B7          >                        or a
 187+ 0145 C9                                   ret
 188+ 0146              .ResultIsZero:          ClearCarryFlag
 188+ 0146 B7          >                        or a
 189+ 0147                                      ZeroA
 189+ 0147 AF          >                        xor a
 190+ 0148 C9                                   ret
 191+ 0149
 192+ 0149
 193+ 0149              AEquAmul256Div197Log:   JumpIfAIsZero   .ResultIsZero
 193+ 0149 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 193+ 014A CA 73 01    >                        jp	    z, .ResultIsZero
 194+ 014D                                      JumpIfAGTENusng d, AEquAmul256Div197LogLT
 194+ 014D BA          >                        cp     d
 194+ 014E D2 26 01    >                        jp		nc,AEquAmul256Div197LogLT
 195+ 0151 21 83 03                             ld      hl,LogTable                     ; point to log a in LogTable
 196+ 0154 ED 31                                add     hl,a                            ; Note we can't sla in case a > 127
 197+ 0156 ED 31                                add     hl,a
 198+ 0158 5E                                   ld      e,(hl)                          ; de = log a
 199+ 0159 23                                   inc     hl                              ; .
 200+ 015A 56                                   ld      d,(hl)                          ; .
 201+ 015B 21 A9 F3                             ld      hl,$F3A9                        ; hl = $F3A9 = log 197
 202+ 015E                                      ClearCarryFlag
 202+ 015E B7          >                        or a
 203+ 015F EB                                   ex      hl,de                           ; hl = log a, de = log 197
 204+ 0160 ED 52                                sbc     hl,de
 205+ 0162 38 0B                                jr      c,.ResultIsOne
 206+ 0164 7C                                   ld      a,h
 207+ 0165 21 83 01                             ld      hl,AntiLogTable
 208+ 0168 ED 31                                add     hl,a
 209+ 016A ED 31                                add     hl,a
 210+ 016C 7E                                   ld      a,(hl)
 211+ 016D                                      ClearCarryFlag
 211+ 016D B7          >                        or a
 212+ 016E C9                                   ret
 213+ 016F              .ResultIsOne:           ClearCarryFlag
 213+ 016F B7          >                        or a
 214+ 0170 3E FF                                ld      a,$FF
 215+ 0172 C9                                   ret
 216+ 0173              .ResultIsZero:          ClearCarryFlag
 216+ 0173 B7          >                        or a
 217+ 0174 C9                                   ret
 218+ 0175
 219+ 0175              AEquAmul256Div197LogSignA:
 220+ 0175 FD 67                                ld      iyh,a
 221+ 0177                                      ClearSignBitA
 221+ 0177 E6 7F       >                        and     SignMask8Bit
 222+ 0179 CD 49 01                             call    AEquAmul256Div197Log
 223+ 017C 47                                   ld      b,a
 224+ 017D FD 7C                                ld      a,iyh
 225+ 017F                                      SignBitOnlyA
 225+ 017F E6 80       >                        and     SignOnly8Bit
 226+ 0181 B0                                   or      b
 227+ 0182 C9                                   ret
# file closed: ../../Maths/logmaths.asm
 990  0183                                  INCLUDE "../../Tables/antilogtable.asm"
# file opened: ../../Tables/antilogtable.asm
   1+ 0183 01 01 01 01  AntiLogTable:           DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 0 to 9
   1+ 0187 01 01 01 01
   1+ 018B 01 01
   2+ 018D 01 01 01 01                          DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 10 to 19
   2+ 0191 01 01 01 01
   2+ 0195 01 01
   3+ 0197 01 01 01 01                          DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 20 to 29
   3+ 019B 01 01 01 01
   3+ 019F 01 01
   4+ 01A1 01 01 02 02                          DB $01, $01, $02, $02, $02, $02, $02, $02, $02, $02 ; 30 to 39
   4+ 01A5 02 02 02 02
   4+ 01A9 02 02
   5+ 01AB 02 02 02 02                          DB $02, $02, $02, $02, $02, $02, $02, $02, $02, $02 ; 40 to 49
   5+ 01AF 02 02 02 02
   5+ 01B3 02 02
   6+ 01B5 02 03 03 03                          DB $02, $03, $03, $03, $03, $03, $03, $03, $03, $03 ; 50 to 59
   6+ 01B9 03 03 03 03
   6+ 01BD 03 03
   7+ 01BF 03 03 03 03                          DB $03, $03, $03, $03, $04, $04, $04, $04, $04, $04 ; 60 to 69
   7+ 01C3 04 04 04 04
   7+ 01C7 04 04
   8+ 01C9 04 04 04 04                          DB $04, $04, $04, $04, $04, $05, $05, $05, $05, $05 ; 70 to 79
   8+ 01CD 04 05 05 05
   8+ 01D1 05 05
   9+ 01D3 05 05 05 06                          DB $05, $05, $05, $06, $06, $06, $06, $06, $06, $06 ; 80 to 89
   9+ 01D7 06 06 06 06
   9+ 01DB 06 06
  10+ 01DD 07 07 07 07                          DB $07, $07, $07, $07, $07, $07, $08, $08, $08, $08 ; 90 to 99
  10+ 01E1 07 07 08 08
  10+ 01E5 08 08
  11+ 01E7 08 08 09 09                          DB $08, $08, $09, $09, $09, $09, $09, $0A, $0A, $0A ; 100 to 109
  11+ 01EB 09 09 09 0A
  11+ 01EF 0A 0A
  12+ 01F1 0A 0B 0B 0B                          DB $0A, $0B, $0B, $0B, $0B, $0C, $0C, $0C, $0C, $0D ; 110 to 119
  12+ 01F5 0B 0C 0C 0C
  12+ 01F9 0C 0D
  13+ 01FB 0D 0D 0E 0E                          DB $0D, $0D, $0E, $0E, $0E, $0E, $0F, $0F, $10, $10 ; 120 to 129
  13+ 01FF 0E 0E 0F 0F
  13+ 0203 10 10
  14+ 0205 10 11 11 11                          DB $10, $11, $11, $11, $12, $12, $13, $13, $13, $14 ; 130 to 139
  14+ 0209 12 12 13 13
  14+ 020D 13 14
  15+ 020F 14 15 15 16                          DB $14, $15, $15, $16, $16, $17, $17, $18, $18, $19 ; 140 to 149
  15+ 0213 16 17 17 18
  15+ 0217 18 19
  16+ 0219 19 1A 1A 1B                          DB $19, $1A, $1A, $1B, $1C, $1C, $1D, $1D, $1E, $1F ; 150 to 159
  16+ 021D 1C 1C 1D 1D
  16+ 0221 1E 1F
  17+ 0223 20 20 21 22                          DB $20, $20, $21, $22, $22, $23, $24, $25, $26, $26 ; 160 to 169
  17+ 0227 22 23 24 25
  17+ 022B 26 26
  18+ 022D 27 28 29 2A                          DB $27, $28, $29, $2A, $2B, $2C, $2D, $2E, $2F, $30 ; 170 to 179
  18+ 0231 2B 2C 2D 2E
  18+ 0235 2F 30
  19+ 0237 31 32 33 34                          DB $31, $32, $33, $34, $35, $36, $38, $39, $3A, $3B ; 180 to 189
  19+ 023B 35 36 38 39
  19+ 023F 3A 3B
  20+ 0241 3D 3E 40 41                          DB $3D, $3E, $40, $41, $42, $44, $45, $47, $48, $4A ; 190 to 199
  20+ 0245 42 44 45 47
  20+ 0249 48 4A
  21+ 024B 4C 4D 4F 51                          DB $4C, $4D, $4F, $51, $52, $54, $56, $58, $5A, $5C ; 200 to 219
  21+ 024F 52 54 56 58
  21+ 0253 5A 5C
  22+ 0255 5E 60 62 64                          DB $5E, $60, $62, $64, $67, $69, $6B, $6D, $70, $72 ; 210 to 229
  22+ 0259 67 69 6B 6D
  22+ 025D 70 72
  23+ 025F 75 77 7A 7D                          DB $75, $77, $7A, $7D, $80, $82, $85, $88, $8B, $8E ; 220 to 239
  23+ 0263 80 82 85 88
  23+ 0267 8B 8E
  24+ 0269 91 94 98 9B                          DB $91, $94, $98, $9B, $9E, $A2, $A5, $A9, $AD, $B1 ; 230 to 239
  24+ 026D 9E A2 A5 A9
  24+ 0271 AD B1
  25+ 0273 B5 B8 BD C1                          DB $B5, $B8, $BD, $C1, $C5, $C9, $CE, $D2, $D7, $DB ; 240 to 249
  25+ 0277 C5 C9 CE D2
  25+ 027B D7 DB
  26+ 027D E0 E5 EA EF                          DB $E0, $E5, $EA, $EF, $F5, $FA                     ; 250 to 255
  26+ 0281 F5 FA
  27+ 0283
  28+ 0283 01 01 01 01  AnitLogODDTable:        DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 0 to 9
  28+ 0287 01 01 01 01
  28+ 028B 01 01
  29+ 028D 01 01 01 01                          DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 10 to 19
  29+ 0291 01 01 01 01
  29+ 0295 01 01
  30+ 0297 01 01 01 01                          DB $01, $01, $01, $01, $01, $01, $01, $01, $01, $01 ; 20 to 29
  30+ 029B 01 01 01 01
  30+ 029F 01 01
  31+ 02A1 01 01 02 02                          DB $01, $01, $02, $02, $02, $02, $02, $02, $02, $02 ; 30 to 39
  31+ 02A5 02 02 02 02
  31+ 02A9 02 02
  32+ 02AB 02 02 02 02                          DB $02, $02, $02, $02, $02, $02, $02, $02, $02, $02 ; 40 to 49
  32+ 02AF 02 02 02 02
  32+ 02B3 02 02
  33+ 02B5 02 03 03 03                          DB $02, $03, $03, $03, $03, $03, $03, $03, $03, $03 ; 50 to 59
  33+ 02B9 03 03 03 03
  33+ 02BD 03 03
  34+ 02BF 03 03 03 03                          DB $03, $03, $03, $03, $04, $04, $04, $04, $04, $04 ; 60 to 69
  34+ 02C3 04 04 04 04
  34+ 02C7 04 04
  35+ 02C9 04 04 04 04                          DB $04, $04, $04, $04, $05, $05, $05, $05, $05, $05 ; 70 to 79
  35+ 02CD 05 05 05 05
  35+ 02D1 05 05
  36+ 02D3 05 05 05 06                          DB $05, $05, $05, $06, $06, $06, $06, $06, $06, $06 ; 80 to 89
  36+ 02D7 06 06 06 06
  36+ 02DB 06 06
  37+ 02DD 07 07 07 07                          DB $07, $07, $07, $07, $07, $07, $08, $08, $08, $08 ; 90 to 99
  37+ 02E1 07 07 08 08
  37+ 02E5 08 08
  38+ 02E7 08 09 09 09                          DB $08, $09, $09, $09, $09, $09, $0A, $0A, $0A, $0A ; 100 to 109
  38+ 02EB 09 09 0A 0A
  38+ 02EF 0A 0A
  39+ 02F1 0A 0B 0B 0B                          DB $0A, $0B, $0B, $0B, $0B, $0C, $0C, $0C, $0D, $0D ; 110 to 119
  39+ 02F5 0B 0C 0C 0C
  39+ 02F9 0D 0D
  40+ 02FB 0D 0D 0E 0E                          DB $0D, $0D, $0E, $0E, $0E, $0F, $0F, $0F, $10, $10 ; 120 to 129
  40+ 02FF 0E 0F 0F 0F
  40+ 0303 10 10
  41+ 0305 10 11 11 12                          DB $10, $11, $11, $12, $12, $12, $13, $13, $14, $14 ; 130 to 139
  41+ 0309 12 12 13 13
  41+ 030D 14 14
  42+ 030F 14 15 15 16                          DB $14, $15, $15, $16, $16, $17, $17, $18, $18, $19 ; 140 to 149
  42+ 0313 16 17 17 18
  42+ 0317 18 19
  43+ 0319 1A 1A 1B 1B                          DB $1A, $1A, $1B, $1B, $1C, $1D, $1D, $1E, $1E, $1F ; 150 to 159
  43+ 031D 1C 1D 1D 1E
  43+ 0321 1E 1F
  44+ 0323 20 21 21 22                          DB $20, $21, $21, $22, $23, $24, $24, $25, $26, $27 ; 160 to 169
  44+ 0327 23 24 24 25
  44+ 032B 26 27
  45+ 032D 28 29 29 2A                          DB $28, $29, $29, $2A, $2B, $2C, $2D, $2E, $2F, $30 ; 170 to 179
  45+ 0331 2B 2C 2D 2E
  45+ 0335 2F 30
  46+ 0337 31 32 34 35                          DB $31, $32, $34, $35, $36, $37, $38, $3A, $3B, $3C ; 180 to 189
  46+ 033B 36 37 38 3A
  46+ 033F 3B 3C
  47+ 0341 3D 3F 40 42                          DB $3D, $3F, $40, $42, $43, $45, $46, $48, $49, $4B ; 190 to 199
  47+ 0345 43 45 46 48
  47+ 0349 49 4B
  48+ 034B 4C 4E 50 52                          DB $4C, $4E, $50, $52, $53, $55, $57, $59, $5B, $5D ; 200 to 219
  48+ 034F 53 55 57 59
  48+ 0353 5B 5D
  49+ 0355 5F 61 63 65                          DB $5F, $61, $63, $65, $68, $6A, $6C, $6F, $71, $74 ; 210 to 229
  49+ 0359 68 6A 6C 6F
  49+ 035D 71 74
  50+ 035F 76 79 7B 7E                          DB $76, $79, $7B, $7E, $81, $84, $87, $8A, $8D, $90 ; 220 to 239
  50+ 0363 81 84 87 8A
  50+ 0367 8D 90
  51+ 0369 93 96 99 9D                          DB $93, $96, $99, $9D, $A0, $A4, $A7, $AB, $AF, $B3 ; 230 to 239
  51+ 036D A0 A4 A7 AB
  51+ 0371 AF B3
  52+ 0373 B6 BA BF C3                          DB $B6, $BA, $BF, $C3, $C7, $CB, $D0, $D4, $D9, $DE ; 240 to 249
  52+ 0377 C7 CB D0 D4
  52+ 037B D9 DE
  53+ 037D E3 E8 ED F2                          DB $E3, $E8, $ED, $F2, $F7, $FD                     ; 250 to 255
  53+ 0381 F7 FD
  54+ 0383
# file closed: ../../Tables/antilogtable.asm
 991  0383                                  INCLUDE "../../Tables/logtable.asm"
# file opened: ../../Tables/logtable.asm
   1+ 0383 00 00        LogTable:               DW $0000                                                                   ; 0
   2+ 0385 00 00 00 20                          DW $0000, $2000, $32B8, $4000, $4A4D, $52B8, $59D6, $6000, $6570, $6A4D    ;   1 TO  10
   2+ 0389 B8 32 00 40
   2+ 038D 4D 4A B8 52
   2+ 0391 D6 59 00 60
   2+ 0395 70 65 4D 6A
   3+ 0399 B4 6E B8 72                          DW $6EB4, $72B8, $766A, $79D6, $7D05, $8000, $82CC, $8570, $87EF, $8A4D    ;  11 TO  20
   3+ 039D 6A 76 D6 79
   3+ 03A1 05 7D 00 80
   3+ 03A5 CC 82 70 85
   3+ 03A9 EF 87 4D 8A
   4+ 03AD 8E 8C B4 8E                          DW $8C8E, $8EB4, $90C1, $92B8, $949A, $966A, $9828, $99D6, $9B75, $9D05    ;  21 TO  30
   4+ 03B1 C1 90 B8 92
   4+ 03B5 9A 94 6A 96
   4+ 03B9 28 98 D6 99
   4+ 03BD 75 9B 05 9D
   5+ 03C1 89 9E 00 A0                          DW $9E89, $A000, $A16C, $A2CC, $A423, $A570, $A6B4, $A7EF, $A922, $AA4D    ;  31 TO  40
   5+ 03C5 6C A1 CC A2
   5+ 03C9 23 A4 70 A5
   5+ 03CD B4 A6 EF A7
   5+ 03D1 22 A9 4D AA
   6+ 03D5 71 AB 8E AC                          DW $AB71, $AC8E, $ADA4, $AEB4, $AFBD, $B0C1, $B1BF, $B2B8, $B3AC, $B49A    ;  41 TO  50
   6+ 03D9 A4 AD B4 AE
   6+ 03DD BD AF C1 B0
   6+ 03E1 BF B1 B8 B2
   6+ 03E5 AC B3 9A B4
   7+ 03E9 85 B5 6A B6                          DW $B585, $B66A, $B74B, $B828, $B901, $B9D6, $BAA7, $BB75, $BC3F, $BD05    ;  51 TO  60
   7+ 03ED 4B B7 28 B8
   7+ 03F1 01 B9 D6 B9
   7+ 03F5 A7 BA 75 BB
   7+ 03F9 3F BC 05 BD
   8+ 03FD C9 BD 89 BE                          DW $BDC9, $BE89, $BF46, $C000, $C0B7, $C16C, $C21D, $C2CC, $C379, $C423    ;  61 TO  70
   8+ 0401 46 BF 00 C0
   8+ 0405 B7 C0 6C C1
   8+ 0409 1D C2 CC C2
   8+ 040D 79 C3 23 C4
   9+ 0411 CB C4 70 C5                          DW $C4CB, $C570, $C613, $C6B4, $C752, $C7EF, $C88A, $C922, $C9B9, $CA4D    ;  71 TO  80
   9+ 0415 13 C6 B4 C6
   9+ 0419 52 C7 EF C7
   9+ 041D 8A C8 22 C9
   9+ 0421 B9 C9 4D CA
  10+ 0425 E0 CA 71 CB                          DW $CAE0, $CB71, $CC00, $CC8E, $CD1A, $CDA4, $CE2D, $CEB4, $CF39, $CFBD    ;  81 TO  90
  10+ 0429 00 CC 8E CC
  10+ 042D 1A CD A4 CD
  10+ 0431 2D CE B4 CE
  10+ 0435 39 CF BD CF
  11+ 0439 40 D0 C1 D0                          DW $D040, $D0C1, $D141, $D1BF, $D23C, $D2B8, $D332, $D3AC, $D424, $D49A    ;  91 TO 100
  11+ 043D 41 D1 BF D1
  11+ 0441 3C D2 B8 D2
  11+ 0445 32 D3 AC D3
  11+ 0449 24 D4 9A D4
  12+ 044D 10 D5 85 D5                          DW $D510, $D585, $D5F8, $D66A, $D6DB, $D74B, $D7BA, $D828, $D895, $D901    ; 101 TO 110
  12+ 0451 F8 D5 6A D6
  12+ 0455 DB D6 4B D7
  12+ 0459 BA D7 28 D8
  12+ 045D 95 D8 01 D9
  13+ 0461 6C D9 D6 D9                          DW $D96C, $D9D6, $DA3F, $DAA7, $DB0E, $DB75, $DBDA, $DC3F, $DCA2, $DD05    ; 111 TO 120
  13+ 0465 3F DA A7 DA
  13+ 0469 0E DB 75 DB
  13+ 046D DA DB 3F DC
  13+ 0471 A2 DC 05 DD
  14+ 0475 67 DD C9 DD                          DW $DD67, $DDC9, $DE29, $DE89, $DEE8, $DF46, $DFA3, $E000, $E05C, $E0B7    ; 121 TO 130
  14+ 0479 29 DE 89 DE
  14+ 047D E8 DE 46 DF
  14+ 0481 A3 DF 00 E0
  14+ 0485 5C E0 B7 E0
  15+ 0489 12 E1 6C E1                          DW $E112, $E16C, $E1C5, $E21D, $E275, $E2CC, $E323, $E379, $E3CE, $E423    ; 131 TO 140
  15+ 048D C5 E1 1D E2
  15+ 0491 75 E2 CC E2
  15+ 0495 23 E3 79 E3
  15+ 0499 CE E3 23 E4
  16+ 049D 77 E4 CB E4                          DW $E477, $E4CB, $E51E, $E570, $E5C2, $E613, $E664, $E6B4, $E703, $E752    ; 141 TO 150
  16+ 04A1 1E E5 70 E5
  16+ 04A5 C2 E5 13 E6
  16+ 04A9 64 E6 B4 E6
  16+ 04AD 03 E7 52 E7
  17+ 04B1 A1 E7 EF E7                          DW $E7A1, $E7EF, $E83D, $E88A, $E8D6, $E922, $E96E, $E9B9, $EA03, $EA4D    ; 151 TO 160
  17+ 04B5 3D E8 8A E8
  17+ 04B9 D6 E8 22 E9
  17+ 04BD 6E E9 B9 E9
  17+ 04C1 03 EA 4D EA
  18+ 04C5 97 EA E0 EA                          DW $EA97, $EAE0, $EB29, $EB71, $EBB9, $EC00, $EC47, $EC8E, $ECD4, $ED1A    ; 161 TO 170
  18+ 04C9 29 EB 71 EB
  18+ 04CD B9 EB 00 EC
  18+ 04D1 47 EC 8E EC
  18+ 04D5 D4 EC 1A ED
  19+ 04D9 5F ED A4 ED                          DW $ED5F, $EDA4, $EDE8, $EE2D, $EE70, $EEB4, $EEF7, $EF39, $EF7B, $EFBD    ; 171 TO 180
  19+ 04DD E8 ED 2D EE
  19+ 04E1 70 EE B4 EE
  19+ 04E5 F7 EE 39 EF
  19+ 04E9 7B EF BD EF
  20+ 04ED FF EF 40 F0                          DW $EFFF, $F040, $F081, $F0C1, $F101, $F141, $F180, $F1BF, $F1FE, $F23C    ; 181 TO 190
  20+ 04F1 81 F0 C1 F0
  20+ 04F5 01 F1 41 F1
  20+ 04F9 80 F1 BF F1
  20+ 04FD FE F1 3C F2
  21+ 0501 7A F2 B8 F2                          DW $F27A, $F2B8, $F2F5, $F332, $F36F, $F3AC, $F3E8, $F424, $F45F, $F49A    ; 191 TO 290
  21+ 0505 F5 F2 32 F3
  21+ 0509 6F F3 AC F3
  21+ 050D E8 F3 24 F4
  21+ 0511 5F F4 9A F4
  22+ 0515 D5 F4 10 F5                          DW $F4D5, $F510, $F54A, $F585, $F5BE, $F5F8, $F631, $F66A, $F6A3, $F6DB    ; 201 TO 210
  22+ 0519 4A F5 85 F5
  22+ 051D BE F5 F8 F5
  22+ 0521 31 F6 6A F6
  22+ 0525 A3 F6 DB F6
  23+ 0529 13 F7 4B F7                          DW $F713, $F74B, $F783, $F7BA, $F7F1, $F828, $F85F, $F895, $F8CB, $F901    ; 211 TO 220
  23+ 052D 83 F7 BA F7
  23+ 0531 F1 F7 28 F8
  23+ 0535 5F F8 95 F8
  23+ 0539 CB F8 01 F9
  24+ 053D 36 F9 6C F9                          DW $F936, $F96C, $F9A1, $F9D6, $FA0A, $FA3F, $FA73, $FAA7, $FADB, $FB0E    ; 221 TO 230
  24+ 0541 A1 F9 D6 F9
  24+ 0545 0A FA 3F FA
  24+ 0549 73 FA A7 FA
  24+ 054D DB FA 0E FB
  25+ 0551 42 FB 75 FB                          DW $FB42, $FB75, $FBA7, $FBDA, $FC0C, $FC3F, $FC71, $FCA2, $FCD4, $FD05    ; 231 TO 240
  25+ 0555 A7 FB DA FB
  25+ 0559 0C FC 3F FC
  25+ 055D 71 FC A2 FC
  25+ 0561 D4 FC 05 FD
  26+ 0565 36 FD 67 FD                          DW $FD36, $FD67, $FD98, $FDC9, $FDF9, $FE29, $FE59, $FE89, $FEB8, $FEE8    ; 241 TO 250
  26+ 0569 98 FD C9 FD
  26+ 056D F9 FD 29 FE
  26+ 0571 59 FE 89 FE
  26+ 0575 B8 FE E8 FE
  27+ 0579 17 FF 46 FF                          DW $FF17, $FF46, $FF75, $FFA3, $FFA3                                       ; 251 TO 255
  27+ 057D 75 FF A3 FF
  27+ 0581 A3 FF
  28+ 0583
  29+ 0583
  30+ 0583
  31+ 0583 00 00 00 00  LogReverseHighByte:     DW $00, 000, $20, 002, $32, 003, $40, 004, $4A, 005, $52, 006
  31+ 0587 20 00 02 00
  31+ 058B 32 00 03 00
  31+ 058F 40 00 04 00
  31+ 0593 4A 00 05 00
  31+ 0597 52 00 06 00
  32+ 059B 59 00 07 00                          DW $59, 007, $60, 008, $65, 009, $6A, 010, $6E, 011, $72, 012
  32+ 059F 60 00 08 00
  32+ 05A3 65 00 09 00
  32+ 05A7 6A 00 0A 00
  32+ 05AB 6E 00 0B 00
  32+ 05AF 72 00 0C 00
  33+ 05B3 76 00 0D 00                          DW $76, 013, $79, 014, $7D, 015, $80, 016, $82, 017, $85, 018
  33+ 05B7 79 00 0E 00
  33+ 05BB 7D 00 0F 00
  33+ 05BF 80 00 10 00
  33+ 05C3 82 00 11 00
  33+ 05C7 85 00 12 00
  34+ 05CB 87 00 13 00                          DW $87, 019, $8A, 020, $8C, 021, $8E, 022, $90, 023, $92, 024
  34+ 05CF 8A 00 14 00
  34+ 05D3 8C 00 15 00
  34+ 05D7 8E 00 16 00
  34+ 05DB 90 00 17 00
  34+ 05DF 92 00 18 00
  35+ 05E3 94 00 19 00                          DW $94, 025, $96, 026, $98, 027, $99, 028, $9B, 029, $9D, 030
  35+ 05E7 96 00 1A 00
  35+ 05EB 98 00 1B 00
  35+ 05EF 99 00 1C 00
  35+ 05F3 9B 00 1D 00
  35+ 05F7 9D 00 1E 00
  36+ 05FB 9E 00 1F 00                          DW $9E, 031, $A0, 032, $A1, 033, $A2, 034, $A4, 035, $A5, 036
  36+ 05FF A0 00 20 00
  36+ 0603 A1 00 21 00
  36+ 0607 A2 00 22 00
  36+ 060B A4 00 23 00
  36+ 060F A5 00 24 00
  37+ 0613 A6 00 25 00                          DW $A6, 037, $A7, 038, $A9, 039, $AA, 040, $AB, 041, $AC, 042
  37+ 0617 A7 00 26 00
  37+ 061B A9 00 27 00
  37+ 061F AA 00 28 00
  37+ 0623 AB 00 29 00
  37+ 0627 AC 00 2A 00
  38+ 062B AD 00 2B 00                          DW $AD, 043, $AE, 044, $AF, 045, $B0, 046, $B1, 047, $B2, 048
  38+ 062F AE 00 2C 00
  38+ 0633 AF 00 2D 00
  38+ 0637 B0 00 2E 00
  38+ 063B B1 00 2F 00
  38+ 063F B2 00 30 00
  39+ 0643 B3 00 31 00                          DW $B3, 049, $B4, 050, $B5, 051, $B6, 052, $B7, 053, $B8, 054
  39+ 0647 B4 00 32 00
  39+ 064B B5 00 33 00
  39+ 064F B6 00 34 00
  39+ 0653 B7 00 35 00
  39+ 0657 B8 00 36 00
  40+ 065B B9 00 38 00                          DW $B9, 056, $B9, 056, $BA, 057, $BB, 058, $BC, 059, $BD, 060
  40+ 065F B9 00 38 00
  40+ 0663 BA 00 39 00
  40+ 0667 BB 00 3A 00
  40+ 066B BC 00 3B 00
  40+ 066F BD 00 3C 00
  41+ 0673 BE 00 3E 00                          DW $BE, 062, $BF, 063, $C0, 064, $C1, 066, $C2, 067, $C3, 069
  41+ 0677 BF 00 3F 00
  41+ 067B C0 00 40 00
  41+ 067F C1 00 42 00
  41+ 0683 C2 00 43 00
  41+ 0687 C3 00 45 00
  42+ 068B C4 00 46 00                          DW $C4, 070, $C5, 072, $C6, 072, $C7, 074, $C8, 076, $C9, 077
  42+ 068F C5 00 48 00
  42+ 0693 C6 00 48 00
  42+ 0697 C7 00 4A 00
  42+ 069B C8 00 4C 00
  42+ 069F C9 00 4D 00
  43+ 06A3 CA 00 50 00                          DW $CA, 080, $CB, 082, $CC, 083, $CD, 085, $CE, 087, $CF, 088
  43+ 06A7 CB 00 52 00
  43+ 06AB CC 00 53 00
  43+ 06AF CD 00 55 00
  43+ 06B3 CE 00 57 00
  43+ 06B7 CF 00 58 00
  44+ 06BB D0 00 5A 00                          DW $D0, 090, $D1, 092, $D2, 094, $D3, 097, $D4, 100, $D5, 102
  44+ 06BF D1 00 5C 00
  44+ 06C3 D2 00 5E 00
  44+ 06C7 D3 00 61 00
  44+ 06CB D4 00 64 00
  44+ 06CF D5 00 66 00
  45+ 06D3 D6 00 68 00                          DW $D6, 104, $D6, 105, $D7, 106, $D7, 107, $D8, 108, $D8, 109
  45+ 06D7 D6 00 69 00
  45+ 06DB D7 00 6A 00
  45+ 06DF D7 00 6B 00
  45+ 06E3 D8 00 6C 00
  45+ 06E7 D8 00 6D 00
  46+ 06EB D9 00 6E 00                          DW $D9, 110, $D9, 111, $D9, 112, $DA, 113, $DB, 114, $DC, 117
  46+ 06EF D9 00 6F 00
  46+ 06F3 D9 00 70 00
  46+ 06F7 DA 00 71 00
  46+ 06FB DB 00 72 00
  46+ 06FF DC 00 75 00
  47+ 0703 DD 00 78 00                          DW $DD, 120, $DE, 123, $DF, 126, $E0, 128, $E1, 131, $E2, 134
  47+ 0707 DE 00 7B 00
  47+ 070B DF 00 7E 00
  47+ 070F E0 00 80 00
  47+ 0713 E1 00 83 00
  47+ 0717 E2 00 86 00
  48+ 071B E3 00 89 00                          DW $E3, 137, $E4, 140, $E5, 143, $E6, 146, $E7, 149, $E8, 153
  48+ 071F E4 00 8C 00
  48+ 0723 E5 00 8F 00
  48+ 0727 E6 00 92 00
  48+ 072B E7 00 95 00
  48+ 072F E8 00 99 00
  49+ 0733 E9 00 9C 00                          DW $E9, 156, $EA, 159, $EB, 163, $EC, 166, $ED, 170, $EE, 174
  49+ 0737 EA 00 9F 00
  49+ 073B EB 00 A3 00
  49+ 073F EC 00 A6 00
  49+ 0743 ED 00 AA 00
  49+ 0747 EE 00 AE 00
  50+ 074B EF 00 B2 00                          DW $EF, 178, $F0, 182, $F1, 185, $F2, 190, $F3, 194, $F4, 198
  50+ 074F F0 00 B6 00
  50+ 0753 F1 00 B9 00
  50+ 0757 F2 00 BE 00
  50+ 075B F3 00 C2 00
  50+ 075F F4 00 C6 00
  51+ 0763 F5 00 CA 00                          DW $F5, 202, $F6, 207, $F7, 211, $F8, 216, $F8, 217, $F9, 220
  51+ 0767 F6 00 CF 00
  51+ 076B F7 00 D3 00
  51+ 076F F8 00 D8 00
  51+ 0773 F8 00 D9 00
  51+ 0777 F9 00 DC 00
  52+ 077B FA 00 E1 00                          DW $FA, 225, $FB, 230, $FB, 233, $FC, 235, $FD, 240, $FE, 246
  52+ 077F FB 00 E6 00
  52+ 0783 FB 00 E9 00
  52+ 0787 FC 00 EB 00
  52+ 078B FD 00 F0 00
  52+ 078F FE 00 F6 00
  53+ 0793 FF 00 FB 00                          DW $FF, 251
  54+ 0797              LogReverseTableLen:     EQU $ - LogReverseHighByte
# file closed: ../../Tables/logtable.asm
 992  0797                                  DISPLAY "Bank ",BankMathsTables," - Bytes free ",/D, $2000 - ($-MathsTablesAddr), " - BankMathsTables"
 993  0797                                  ASSERT $-MathsTablesAddr <8912, Bank code leaks over 8K boundary
 994  0797              ; Bank 100  -----------------------------------------------------------------------------------------------------------------------
 995  0797                                  SLOT    KeyboardAddr
 996  0797                                  PAGE    BankKeyboard
 997  0797                                  ORG SoundAddr, BankKeyboard
 998  E000                                  INCLUDE "../../Hardware/keyboard.asm"
# file opened: ../../Hardware/keyboard.asm
   1+ E000              ;
   2+ E000              ; $FEFE;65278 V, C, X, Z, Caps Shifts       4  3  2  1  0
   3+ E000              ; $FDFE;65022 G, F, D, S, A                 9  8  7  6  5
   4+ E000              ; $FBFE;64510 T, R, E, W, Q                14 13 12 11 10
   5+ E000              ; $F7FE;63486 5, 4, 3, 2, 1                19 18 17 16 15
   6+ E000              ; $EFFE;61438 6, 7, 8, 9, 0                24 23 22 23 20
   7+ E000              ; $DFFE;57342 Y, U, I, O, P                29 28 27 26 25
   8+ E000              ; $BFFE;49150 H, J, K, L, Enter            34 33 32 31 30
   9+ E000              ; $7FFE;32766 B, N, M, Symbol Shift, Space 39 38 37 36 35
  10+ E000              ;
  11+ E000              ; Keyboard
  12+ E000              ;
  13+ E000              ;   0      1       2       3       4       5        6       7       8       9
  14+ E000              ;  VK_CAPS, VK_Z,  VK_X,   VK_C,   VK_V,   VK_A,    VK_S,   VK_D,   VK_F,   VK_G
  15+ E000              ;   10     11      12      13      14      15       16      17      18      19
  16+ E000              ;  VK_Q,   VK_W,   VK_E,   VK_R,   VK_T,   VK_1,    VK_2,   VK_3,   VK_4,   VK_5
  17+ E000              ;   20     21      22      23      24      25       26      27      28      29
  18+ E000              ;  VK_0    VK_9,   VK_8,   VK_7,   VK_6,   VK_P ,    VK_O,  VK_I,   VK_U,   VK_Y
  19+ E000              ;   30     31      32      33      34      35       36      37      38      39
  20+ E000              ; VK_ENTER VK_L,   VK_K,   VK_J,   VK_H,   VK_SPACE VK_SYM, VK_M,   VK_N,   VK_B
  21+ E000              ;
  22+ E000              ; ZX Spectrum Next Compound keys
  23+ E000              ;   40     41       42       43      44      45       46       47
  24+ E000              ;  VK_SEMI VK_QUOTE VK_COMMA VK_STOP VK_UP   VK_DOWN  VK_LEFT  VK _RIGHT        $Register B0 bits 7 to 0    (Set to set ULA Register ($68) bit to to prevent default keystrokes
  25+ E000              ;   48       49      50       51         52          53       54      55
  26+ E000              ;  VK_DELETE VK_EDIT VK_BREAK VK_INV_VID VK_TRUE_VID VK_GRAPH VK_CAPS VK_EXTEND $Register B1 bits 7 to 0
  27+ E000              ; Default map
  28+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  29+ E000              ;   0          1           2             3              4           5           6           7           8           9
  30+ E000              ;   VK_CAPS    VK_Z        VK_X,         VK_C,          VK_V,       VK_A        VK_S,       VK_D,       VK_F,       VK_G
  31+ E000              ;              GameSkip                  Equip          SelLCargo   Climb       Decelerate  Recentre    FireM       HomeCursor
  32+ E000              ;                                                                                                       Find System
  33+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  34+ E000              ;   10         11          12            13             14          15          16          17          18          19
  35+ E000              ;   VK_Q       VK_W,       VK_E,         VK_R,          VK_T,       VK_1        VK_2        VK_3        VK_4        VK_5
  36+ E000              ;   Dive       Accelerate  ECM           UnarmMissile   TargetM     FrontV      AftV        LeftV       RightV      GalacticChart
  37+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  38+ E000              ;   20         Accel       22            23             24          25          26          27          28          29
  39+ E000              ;   VK_0       VK_9,       VK_8,         VK_7,          VK_6,       VK_P ,      VK_O,       VK_I,       VK_U,       VK_Y
  40+ E000              ;   EscapePod  Inventory   Status        MarketPrices   LocalChart  RollRight   RolLLeft                EnergyBomb  Quit
  41+ E000              ;   PlanetData                                                      PauseGame   SaveGame
  42+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  43+ E000              ;   30         31          32            33             34          Right       36          37          EnergyBomb  39
  44+ E000              ;   VK_ENTER   VK_L,       VK_K,         VK_J,          VK_H,       VK_SPACE    VK_SYM,     VK_M,       VK_N,       VK_B
  45+ E000              ;              Launch                    Distance       Hyperspace  Laser                               DockComp    BuyCargo
  46+ E000              ;              ResumeGame                WarpJump
  47+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  48+ E000              ;   40         41          42            43             44          45          46          47          48          49
  49+ E000              ;   VK_SEMI    VK_QUOTE    VK_COMMA      VK_STOP        VK_UP       VK_DOWN     VK_LEFT     VK _RIGHT   VK_DELETE   VK_EDIT
  50+ E000              ;   Market     EquipShip   PlanetData    NearestObject  Map Cursor no auto repeat....................   Delete      Find System
  51+ E000              ;
  52+ E000              ;-----------------------------------------------------------------------------------------------------------------------------------
  53+ E000              ;   50         51          52            53             54          55
  54+ E000              ;   VK_BREAK   VK_INV_VID  VK_TRUE_VID   VK_GRAPH       VK_EXTCAPS  VK_EXTEND
  55+ E000              ;   EscapePod  Inventory   Status        GalacticChart  LocalChart  SystemJump
  56+ E000              ;
  57+ E000
  58+ E000              ; You can read address to check keystate by address KeyboardMap + c_Pressed corresponding key. There is also an addr_ helper too
  59+ E000
  60+ E000              c_Pressed_Front         equ 0  * 2
  61+ E000              c_Pressed_Aft           equ 1  * 2
  62+ E000              c_Pressed_Left          equ 2  * 2
  63+ E000              c_Pressed_Right         equ 3  * 2
  64+ E000              c_Pressed_RollLeft      equ 4  * 2
  65+ E000              c_Pressed_RollRight     equ 5  * 2
  66+ E000              c_Pressed_Dive          equ 6  * 2
  67+ E000              c_Pressed_Climb         equ 7  * 2
  68+ E000              c_Pressed_Accellerate   equ 8  * 2
  69+ E000              c_Pressed_Decellerate   equ 9  * 2
  70+ E000              c_Pressed_FireLaser     equ 10 * 2
  71+ E000              c_Pressed_TargetMissle  equ 11 * 2
  72+ E000              c_Pressed_FireMissile   equ 12 * 2
  73+ E000              c_Pressed_UnarmMissile  equ 13 * 2
  74+ E000              c_Pressed_ECM           equ 14 * 2
  75+ E000              c_Pressed_EnergyBomb    equ 15 * 2
  76+ E000              c_Pressed_EscapePod     equ 16 * 2
  77+ E000              c_Pressed_DockingComp   equ 17 * 2
  78+ E000              c_Pressed_Hyperspace    equ 18 * 2
  79+ E000              c_Pressed_Distance      equ 19 * 2
  80+ E000              c_Pressed_HomeCursor    equ 20 * 2
  81+ E000              c_Pressed_Launch        equ 21 * 2
  82+ E000              c_Pressed_BuyCargo      equ 22 * 2
  83+ E000              c_Pressed_SellCargo     equ 23 * 2
  84+ E000              c_Pressed_Equip         equ 24 * 2
  85+ E000              c_Pressed_GalacticChrt  equ 25 * 2
  86+ E000              c_Pressed_LocalChart    equ 26 * 2
  87+ E000              c_Pressed_MarketPrices  equ 27 * 2
  88+ E000              c_Pressed_Status        equ 28 * 2
  89+ E000              c_Pressed_Inventory     equ 29 * 2
  90+ E000              c_Pressed_GameSkip      equ 30 * 2
  91+ E000              c_Pressed_Save          equ 31 * 2
  92+ E000              c_Pressed_Freeze        equ 32 * 2
  93+ E000              c_Pressed_Resume        equ 33 * 2
  94+ E000              c_Pressed_Recentre      equ 34 * 2
  95+ E000              c_Pressed_Quit          equ 35 * 2
  96+ E000              c_Pressed_PlanetData    equ 36 * 2
  97+ E000              c_Pressed_CursorUp      equ 37 * 2
  98+ E000              c_Pressed_CursorDown    equ 38 * 2
  99+ E000              c_Pressed_Find          equ 39 * 2
 100+ E000              c_Pressed_Yes           equ 40 * 2
 101+ E000              c_Pressed_No            equ 41 * 2
 102+ E000              c_Pressed_Warp          equ 42 * 2
 103+ E000              c_Pressed_ExtMarket     equ 43 * 2
 104+ E000              c_Pressed_ExtEquip      equ 44 * 2
 105+ E000              c_Pressed_ExtPlanet     equ 45 * 2
 106+ E000              c_Pressed_ExtNearest    equ 46 * 2
 107+ E000              c_Pressed_ExtCurUp      equ 47 * 2
 108+ E000              c_Pressed_ExtCurDown    equ 48 * 2
 109+ E000              c_Pressed_ExtCurLeft    equ 49 * 2
 110+ E000              c_Pressed_ExtCurRight   equ 50 * 2
 111+ E000              c_Pressed_ExtDelete     equ 51 * 2
 112+ E000              c_Pressed_ExtFindSystem equ 52 * 2
 113+ E000              c_Pressed_ExtEscapePod  equ 53 * 2
 114+ E000              c_Pressed_ExtInventory  equ 54 * 2
 115+ E000              c_Pressed_ExtStatus     equ 55 * 2
 116+ E000              c_Pressed_ExtGlactic    equ 56 * 2
 117+ E000              c_Pressed_ExtLocal      equ 57 * 2
 118+ E000              c_Pressed_ExtSystemJump equ 58 * 2
 119+ E000
 120+ E000              ; half row 1
 121+ E000              VK_CAPS  				equ 0
 122+ E000              VK_Z  					equ 1
 123+ E000              VK_X  					equ 2
 124+ E000              VK_C  					equ 3
 125+ E000              VK_V  					equ 4
 126+ E000              ; half row 2
 127+ E000              VK_A  					equ 5
 128+ E000              VK_S  					equ 6
 129+ E000              VK_D  					equ 7
 130+ E000              VK_F					equ 8
 131+ E000              VK_G  					equ 9
 132+ E000              ; half row 3
 133+ E000              VK_Q  					equ 10
 134+ E000              VK_W  					equ 11
 135+ E000              VK_E  					equ 12
 136+ E000              VK_R  					equ 13
 137+ E000              VK_T  					equ 14
 138+ E000              ; half row 4
 139+ E000              VK_1  					equ 15
 140+ E000              VK_2  					equ 16
 141+ E000              VK_3  					equ 17
 142+ E000              VK_4  					equ 18
 143+ E000              VK_5  					equ 19
 144+ E000              ; half row 5
 145+ E000              VK_0 					equ 20
 146+ E000              VK_9 					equ 21
 147+ E000              VK_8 					equ 22
 148+ E000              VK_7 					equ 23
 149+ E000              VK_6 					equ 24
 150+ E000              ; half row 6
 151+ E000              VK_P  					equ 25
 152+ E000              VK_O  					equ 26
 153+ E000              VK_I  					equ 27
 154+ E000              VK_U  					equ 28
 155+ E000              VK_Y  					equ 29
 156+ E000              ; half row 7
 157+ E000              VK_ENTER 				equ 30
 158+ E000              VK_L  					equ 31
 159+ E000              VK_K  					equ 32
 160+ E000              VK_J  					equ 33
 161+ E000              VK_H  					equ 34
 162+ E000              ; half row 8
 163+ E000              VK_SPACE 				equ 35
 164+ E000              VK_SYM  				equ 36
 165+ E000              VK_M  					equ 37
 166+ E000              VK_N  					equ 38
 167+ E000              VK_B  					equ 39
 168+ E000              ; Extended Group B0
 169+ E000              VK_SEMI                 equ 40
 170+ E000              VK_QUOTE                equ 41
 171+ E000              VK_COMMA                equ 42
 172+ E000              VK_STOP                 equ 43
 173+ E000              VK_UP                   equ 44
 174+ E000              VK_DOWN                 equ 45
 175+ E000              VK_LEFT                 equ 46
 176+ E000              VK_RIGHT                equ 47
 177+ E000              ; Extended Group B1
 178+ E000              VK_DELETE               equ 48
 179+ E000              VK_EDIT                 equ 49
 180+ E000              VK_BREAK                equ 50
 181+ E000              VK_INV_VID              equ 51
 182+ E000              VK_TRUE_VID             equ 52
 183+ E000              VK_GRAPH                equ 53
 184+ E000              VK_EXTCAPS              equ 54
 185+ E000              VK_EXTEND               equ 55
 186+ E000              ;KeyboardMapping
 187+ E000              KeyCode_Front        	equ VK_1
 188+ E000              KeyCode_Aft          	equ VK_2
 189+ E000              KeyCode_Left         	equ VK_3
 190+ E000              KeyCode_Right        	equ VK_4
 191+ E000              KeyCode_RollLeft     	equ VK_O
 192+ E000              KeyCode_RollRight    	equ VK_P
 193+ E000              KeyCode_Dive         	equ VK_Q
 194+ E000              KeyCode_Climb        	equ VK_A
 195+ E000              KeyCode_Accellerate  	equ VK_W
 196+ E000              KeyCode_Decellerate  	equ VK_S
 197+ E000              KeyCode_FireLaser    	equ VK_SPACE
 198+ E000              KeyCode_TargetMissle 	equ VK_T
 199+ E000              KeyCode_FireMissile  	equ VK_STOP
 200+ E000              KeyCode_Find        	equ VK_F
 201+ E000              KeyCode_UnarmMissile 	equ VK_R
 202+ E000              KeyCode_ECM          	equ VK_E
 203+ E000              KeyCode_EnergyBomb   	equ VK_U
 204+ E000              KeyCode_EscapePod    	equ VK_CAPS
 205+ E000              KeyCode_DockingComp  	equ VK_N
 206+ E000              KeyCode_Hyperspace   	equ VK_H
 207+ E000              KeyCode_Distance     	equ VK_J
 208+ E000              KeyCode_HomeCursor   	equ VK_G
 209+ E000              KeyCode_Launch       	equ VK_L
 210+ E000              KeyCode_BuyCargo     	equ VK_B
 211+ E000              KeyCode_SellCargo    	equ VK_V
 212+ E000              KeyCode_Equip        	equ VK_C
 213+ E000              KeyCode_GalacticChrt 	equ VK_5
 214+ E000              KeyCode_LocalChart   	equ VK_6
 215+ E000              KeyCode_MarketPrices 	equ VK_7
 216+ E000              KeyCode_Status       	equ VK_8
 217+ E000              KeyCode_Inventory    	equ VK_9
 218+ E000              KeyCode_GameSkip     	equ VK_Z
 219+ E000              KeyCode_Save         	equ VK_O
 220+ E000              KeyCode_Freeze       	equ VK_B
 221+ E000              KeyCode_Resume       	equ VK_L
 222+ E000              KeyCode_Recentre     	equ VK_H
 223+ E000              KeyCode_Quit         	equ VK_Y
 224+ E000              KeyCode_PlanetData   	equ VK_0
 225+ E000              KeyCode_CursorUp        equ VK_Q
 226+ E000              KeyCode_CursorDown      equ VK_A
 227+ E000              KeyCode_PressedYes      equ VK_Y
 228+ E000              KeyCode_PressedNo       equ VK_N
 229+ E000              KeyCode_Warp            equ VK_J
 230+ E000              KeyCode_ExtMarket       equ VK_SEMI
 231+ E000              KeyCode_ExtEquip        equ VK_QUOTE
 232+ E000              KeyCode_ExtPlanet       equ VK_COMMA
 233+ E000              KeyCode_ExtNearest      equ VK_STOP
 234+ E000              KeyCode_ExtCurUp        equ VK_UP
 235+ E000              KeyCode_ExtCurDown      equ VK_DOWN
 236+ E000              KeyCode_ExtCurLeft      equ VK_LEFT
 237+ E000              KeyCode_ExtCurRight     equ VK_RIGHT
 238+ E000              KeyCode_ExtDelete       equ VK_DELETE
 239+ E000              KeyCode_ExtFindSystem   equ VK_EDIT
 240+ E000              KeyCode_ExtEscapePod    equ VK_BREAK
 241+ E000              KeyCode_ExtInventory    equ VK_INV_VID
 242+ E000              KeyCode_ExtStatus       equ VK_TRUE_VID
 243+ E000              KeyCode_ExtGlactic      equ VK_GRAPH
 244+ E000              KeyCode_ExtLocal        equ VK_EXTCAPS
 245+ E000              KeyCode_ExtSystemJump   equ VK_EXTEND
 246+ E000
 247+ E000 00 00 00...  Keys					DS	55          ; This is the list of key states for all the VK keys presssed i.e. VK_CAPS through to VK_B
 248+ E037              c_KeyBoardLen 			equ $ - Keys
 249+ E037 00 00 00...  RawKeys					DS	10          ; increased for extended keys
 250+ E041 FE FD FB F7  KeyAddrTab				DB	$FE, $FD, $FB, $F7, $EF, $DF, $BF, $7F
 250+ E045 EF DF BF 7F
 251+ E049              ; Now keyboard map lists each game key and the corresponding address in the Keys table to get the value. This way redefining keys is just a case
 252+ E049              ; of updating this table with the respective location to look up
 253+ E049              ; key list sequence is in table above
 254+ E049 0F E0 10 E0  KeyboardMap             DW  Keys+KeyCode_Front        ,Keys+KeyCode_Aft          ,Keys+KeyCode_Left         ,Keys+KeyCode_Right        ,Keys+KeyCode_RollLeft
 254+ E04D 11 E0 12 E0
 254+ E051 1A E0
 255+ E053 19 E0 0A E0                          DW  Keys+KeyCode_RollRight    ,Keys+KeyCode_Dive         ,Keys+KeyCode_Climb        ,Keys+KeyCode_Accellerate  ,Keys+KeyCode_Decellerate
 255+ E057 05 E0 0B E0
 255+ E05B 06 E0
 256+ E05D 23 E0 0E E0                          DW  Keys+KeyCode_FireLaser    ,Keys+KeyCode_TargetMissle ,Keys+KeyCode_FireMissile  ,Keys+KeyCode_UnarmMissile ,Keys+KeyCode_ECM
 256+ E061 2B E0 0D E0
 256+ E065 0C E0
 257+ E067 1C E0 00 E0                          DW  Keys+KeyCode_EnergyBomb   ,Keys+KeyCode_EscapePod    ,Keys+KeyCode_DockingComp  ,Keys+KeyCode_Hyperspace   ,Keys+KeyCode_Distance
 257+ E06B 26 E0 22 E0
 257+ E06F 21 E0
 258+ E071 09 E0 1F E0                          DW  Keys+KeyCode_HomeCursor   ,Keys+KeyCode_Launch       ,Keys+KeyCode_BuyCargo     ,Keys+KeyCode_SellCargo    ,Keys+KeyCode_Equip
 258+ E075 27 E0 04 E0
 258+ E079 03 E0
 259+ E07B 13 E0 18 E0                          DW  Keys+KeyCode_GalacticChrt ,Keys+KeyCode_LocalChart   ,Keys+KeyCode_MarketPrices ,Keys+KeyCode_Status       ,Keys+KeyCode_Inventory
 259+ E07F 17 E0 16 E0
 259+ E083 15 E0
 260+ E085 01 E0 1A E0                          DW  Keys+KeyCode_GameSkip     ,Keys+KeyCode_Save         ,Keys+KeyCode_Freeze       ,Keys+KeyCode_Resume       ,Keys+KeyCode_Recentre
 260+ E089 27 E0 1F E0
 260+ E08D 22 E0
 261+ E08F 1D E0 14 E0                          DW  Keys+KeyCode_Quit         ,Keys+KeyCode_PlanetData   ,Keys+KeyCode_CursorUp     ,Keys+KeyCode_CursorDown   ,Keys+KeyCode_Find
 261+ E093 0A E0 05 E0
 261+ E097 08 E0
 262+ E099 1D E0 26 E0                          DW  Keys+KeyCode_PressedYes   ,Keys+KeyCode_PressedNo    ,Keys+KeyCode_Warp         ,Keys+KeyCode_ExtMarket    ,Keys+KeyCode_ExtEquip
 262+ E09D 21 E0 28 E0
 262+ E0A1 29 E0
 263+ E0A3 2A E0 2B E0                          DW  Keys+KeyCode_ExtPlanet    ,Keys+KeyCode_ExtNearest   ,Keys+KeyCode_ExtCurUp     ,Keys+KeyCode_ExtCurDown   ,Keys+KeyCode_ExtCurLeft
 263+ E0A7 2C E0 2D E0
 263+ E0AB 2E E0
 264+ E0AD 2F E0 30 E0                          DW  Keys+KeyCode_ExtCurRight  ,Keys+KeyCode_ExtDelete    ,Keys+KeyCode_ExtFindSystem,Keys+KeyCode_ExtEscapePod ,Keys+KeyCode_ExtInventory
 264+ E0B1 31 E0 32 E0
 264+ E0B5 33 E0
 265+ E0B7 34 E0 35 E0                          DW  Keys+KeyCode_ExtStatus    ,Keys+KeyCode_ExtGlactic   ,Keys+KeyCode_ExtLocal     ,Keys+KeyCode_ExtSystemJump
 265+ E0BB 36 E0 37 E0
 266+ E0BF
 267+ E0BF
 268+ E0BF 3F 5A 58 43  ASCII_Map:              DB "?","Z","X","C","V"
 268+ E0C3 56
 269+ E0C4 41 53 44 46                          DB "A","S","D","F","G"
 269+ E0C8 47
 270+ E0C9 51 57 45 52                          DB "Q","W","E","R","T"
 270+ E0CD 54
 271+ E0CE 31 32 33 34                          DB "1","2","3","4","5"
 271+ E0D2 35
 272+ E0D3 30 39 38 37                          DB "0","9","8","7","6"
 272+ E0D7 36
 273+ E0D8 50 4F 49 55                          DB "P","O","I","U","Y"
 273+ E0DC 59
 274+ E0DD 3E 4C 4B 4A                          DB ">","L","K","J","H"
 274+ E0E1 48
 275+ E0E2 20 5E 4D 4E                          DB " ","^","M","N","B"
 275+ E0E6 42
 276+ E0E7 3B 22 2C 2E                          DB ";",'"',",",".","^","v","[","]"  ; Extended keys register 0 semicolon, quote, comman, fullstop, up, down, left, right
 276+ E0EB 5E 76 5B 5D
 277+ E0EF 23 65 62 69                          DB "#","e","b","i","t","g","c","x"  ; Extended keys register 1 delete, edit, break, inv video, true video graph, caps, extend
 277+ E0F3 74 67 63 78
 278+ E0F7              ; mapping of a code to the lookup table Keyboard map. So if you are using an addr_Pressed you can then fetch from KeyboardMap the address in Keys
 279+ E0F7              ; for the raw key press status
 280+ E0F7              addr_Pressed_Front         equ KeyboardMap+c_Pressed_Front
 281+ E0F7              addr_Pressed_Aft           equ KeyboardMap+c_Pressed_Aft
 282+ E0F7              addr_Pressed_Left          equ KeyboardMap+c_Pressed_Left
 283+ E0F7              addr_Pressed_Right         equ KeyboardMap+c_Pressed_Right
 284+ E0F7              addr_Pressed_RollLeft      equ KeyboardMap+c_Pressed_RollLeft
 285+ E0F7              addr_Pressed_RollRight     equ KeyboardMap+c_Pressed_RollRight
 286+ E0F7              addr_Pressed_Dive          equ KeyboardMap+c_Pressed_Dive
 287+ E0F7              addr_Pressed_Climb         equ KeyboardMap+c_Pressed_Climb
 288+ E0F7              addr_Pressed_Accellerate   equ KeyboardMap+c_Pressed_Accellerate
 289+ E0F7              addr_Pressed_Decellerate   equ KeyboardMap+c_Pressed_Decellerate
 290+ E0F7              addr_Pressed_FireLaser     equ KeyboardMap+c_Pressed_FireLaser
 291+ E0F7              addr_Pressed_TargetMissle  equ KeyboardMap+c_Pressed_TargetMissle
 292+ E0F7              addr_Pressed_FireMissile   equ KeyboardMap+c_Pressed_FireMissile
 293+ E0F7              addr_Pressed_UnarmMissile  equ KeyboardMap+c_Pressed_UnarmMissile
 294+ E0F7              addr_Pressed_ECM           equ KeyboardMap+c_Pressed_ECM
 295+ E0F7              addr_Pressed_EnergyBomb    equ KeyboardMap+c_Pressed_EnergyBomb
 296+ E0F7              addr_Pressed_EscapePod     equ KeyboardMap+c_Pressed_EscapePod
 297+ E0F7              addr_Pressed_DockingComp   equ KeyboardMap+c_Pressed_DockingComp
 298+ E0F7              addr_Pressed_Hyperspace    equ KeyboardMap+c_Pressed_Hyperspace
 299+ E0F7              addr_Pressed_Distance      equ KeyboardMap+c_Pressed_Distance
 300+ E0F7              addr_Pressed_HomeCursor    equ KeyboardMap+c_Pressed_HomeCursor
 301+ E0F7              addr_Pressed_Launch        equ KeyboardMap+c_Pressed_Launch
 302+ E0F7              addr_Pressed_BuyCargo      equ KeyboardMap+c_Pressed_BuyCargo
 303+ E0F7              addr_Pressed_SellCargo     equ KeyboardMap+c_Pressed_SellCargo
 304+ E0F7              addr_Pressed_Equip         equ KeyboardMap+c_Pressed_Equip
 305+ E0F7              addr_Pressed_GalacticChrt  equ KeyboardMap+c_Pressed_GalacticChrt
 306+ E0F7              addr_Pressed_LocalChart    equ KeyboardMap+c_Pressed_LocalChart
 307+ E0F7              addr_Pressed_MarketPrices  equ KeyboardMap+c_Pressed_MarketPrices
 308+ E0F7              addr_Pressed_Status        equ KeyboardMap+c_Pressed_Status
 309+ E0F7              addr_Pressed_Inventory     equ KeyboardMap+c_Pressed_Inventory
 310+ E0F7              addr_Pressed_GameSkip      equ KeyboardMap+c_Pressed_GameSkip
 311+ E0F7              addr_Pressed_Save          equ KeyboardMap+c_Pressed_Save
 312+ E0F7              addr_Pressed_Freeze        equ KeyboardMap+c_Pressed_Freeze
 313+ E0F7              addr_Pressed_Resume        equ KeyboardMap+c_Pressed_Resume
 314+ E0F7              addr_Pressed_Recentre      equ KeyboardMap+c_Pressed_Recentre
 315+ E0F7              addr_Pressed_Quit          equ KeyboardMap+c_Pressed_Quit
 316+ E0F7              addr_Pressed_PlanetData    equ KeyboardMap+c_Pressed_PlanetData
 317+ E0F7              addr_Pressed_CursorUp      equ KeyboardMap+c_Pressed_CursorUp
 318+ E0F7              addr_Pressed_CursorDown    equ KeyboardMap+c_Pressed_CursorDown
 319+ E0F7              addr_Pressed_Find          equ KeyboardMap+c_Pressed_Find
 320+ E0F7              addr_Pressed_Warp          equ KeyboardMap+c_Pressed_Warp
 321+ E0F7
 322+ E0F7
 323+ E0F7              MIsKeyPressed:          MACRO   keyaddress, misstarget
 324+ E0F7 ~                                    MMUSelectKeyboard
 325+ E0F7 ~                                    ld      hl,(keyaddress)
 326+ E0F7 ~                                    ld      a,(hl)
 327+ E0F7 ~                                    JumpIfAIsZero   misstarget
 328+ E0F7                                      ENDM
 329+ E0F7
 330+ E0F7
 331+ E0F7 21 00 E0     init_keyboard:          ld		hl,Keys                         ; no key s are pressed by default
 332+ E0FA 11 37 00                             ld		de, c_KeyBoardLen               ;
 333+ E0FD 3E 00                                ld		a,0                             ;
 334+ E0FF CD 81 65                             call	memfill_dma                     ;
 335+ E102 C9                                   ret                                     ;
 336+ E103
 337+ E103
 338+ E103
 339+ E103 DD 21 37 E0  scan_keyboard:          ld		ix,RawKeys                      ; hl = table of raw IO port readings
 340+ E107 21 41 E0                             ld		hl,KeyAddrTab                   ; de = table of IO ports to read
 341+ E10A 0E 08                                ld		c,8                             ; 8 ports to ready
 342+ E10C 11 00 E0                             ld      de,Keys                         ; ix = table of key states from raw read
 343+ E10F 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
 344+ E110 DB FE                                in		a,($FE)							; read port to a
 345+ E112 DD 77 00                             ld      (ix+0),a                        ; save raw scan
 346+ E115 DD 23                                inc     ix
 347+ E117 23                                   inc		hl                              ; and ready for next read
 348+ E118 06 05        .ProcessInputBits:      ld		b,5								; loop all bits (there are only 5 keys to a group)
 349+ E11A 1F           .ProcessBitsLoop:       rra                                     ; shit bit 0 into carry
 350+ E11B 30 08                                jr      nc,.SetKeyPressed               ; low bit means it was pressed
 351+ E11D FD 6F                                ld      iyl,a
 352+ E11F                                      ZeroA
 352+ E11F AF          >                        xor a
 353+ E120 C3 2D E1                             jp      .SetKey
 354+ E123 20 0B                                jr		nz,.SkipKeySet
 355+ E125 FD 6F        .SetKeyPressed:	        ld      iyl,a                           ; save current input byte
 356+ E127 1A                                   ld      a,(de)                          ; get current keystate
 357+ E128 FE 02                                cp      2
 358+ E12A 28 02                                jr      z,.AlreadyHeld
 359+ E12C 3C                                   inc     a                               ; and increment by 1 as its moved from previous state
 360+ E12D 12           .SetKey:                ld		(de),a				  	        ; save key Pressed state
 361+ E12E FD 7D        .AlreadyHeld:           ld      a,iyl                           ; and retrieve the current input byte
 362+ E130 13           .SkipKeySet:	        inc		de								; move to next key
 363+ E131 10 E7                                djnz	.ProcessBitsLoop				; Process all key group bits
 364+ E133 0D                                   dec     c                               ; thats one row of bits all processed
 365+ E134 20 D9                                jr      nz,.PortReadLoop				; Read next input port
 366+ E136              .ReadExtend0:           ; bits are set to 1 for press on the next register
 367+ E136                                      GetNextReg EXTENDED_KEYS_0_REGISTER
 367+ E136 01 3B 24    >            ld bc,$243B
 367+ E139 3E B0       >            ld a,EXTENDED_KEYS_0_REGISTER
 367+ E13B ED 79       >            out (c),a
 367+ E13D 04          >            inc b
 367+ E13E ED 78       >            in a,(c)
 368+ E140 32 3F E0                             ld      (RawKeys+8),a                   ; save to extended slot
 369+ E143 06 08                                ld      b,8
 370+ E145 21 28 E0                             ld      hl,Keys + VK_SEMI
 371+ E148 5F                                   ld      e,a                             ; e now holds the raw keys for shifting
 372+ E149 CB 13        .ProcessExtend0:        rl      e                               ; shift bits left into carry for extended keys
 373+ E14B 38 04                                jr      c,.SetExtend0KeyPressed         ; if carry they key was pressedw
 374+ E14D              .Extend0NotPressed:     ZeroA
 374+ E14D AF          >                        xor a
 375+ E14E C3 57 E1                             jp      .SetExtend0Key
 376+ E151 7E           .SetExtend0KeyPressed:  ld      a,(hl)                          ; consider if key was already held down
 377+ E152 FE 02                                cp      2
 378+ E154 28 02                                jr      z,.Extend0AlreadyHeld
 379+ E156 3C                                   inc     a
 380+ E157 77           .SetExtend0Key:         ld      (hl),a
 381+ E158 23           .Extend0AlreadyHeld:    inc     hl
 382+ E159 10 EE                                djnz    .ProcessExtend0
 383+ E15B              .ReadExtend1:           GetNextReg EXTENDED_KEYS_1_REGISTER
 383+ E15B 01 3B 24    >            ld bc,$243B
 383+ E15E 3E B1       >            ld a,EXTENDED_KEYS_1_REGISTER
 383+ E160 ED 79       >            out (c),a
 383+ E162 04          >            inc b
 383+ E163 ED 78       >            in a,(c)
 384+ E165 32 40 E0                             ld      (RawKeys+9),a                      ; save to extended slot
 385+ E168 06 08                                ld      b,8
 386+ E16A 21 30 E0                             ld      hl,Keys + VK_DELETE
 387+ E16D 5F                                   ld      e,a
 388+ E16E CB 13        .ProcessExtend1:        rl      e                                 ; shift bits left into carry for extended keys
 389+ E170 38 04                                jr      c,.SetExtend1KeyPressed
 390+ E172              .Extend1NotPressed:     ZeroA
 390+ E172 AF          >                        xor a
 391+ E173 C3 7C E1                             jp      .SetExtend1Key
 392+ E176 7E           .SetExtend1KeyPressed:  ld      a,(hl)
 393+ E177 FE 02                                cp      2
 394+ E179 28 02                                jr      z,.Extend1AlreadyHeld
 395+ E17B 3C                                   inc     a
 396+ E17C 77           .SetExtend1Key:         ld      (hl),a
 397+ E17D 23           .Extend1AlreadyHeld:    inc     hl
 398+ E17E 10 EE                                djnz    .ProcessExtend1
 399+ E180 C9                                   ret
 400+ E181
 401+ E181
 402+ E181
 403+ E181              GetKeyStateAddressDE:   MACRO
 404+ E181 ~                                    ld      hl,KeyboardMap                  ; work our address to read from
 405+ E181 ~                                    add     hl,a
 406+ E181 ~                                    ld      e,(hl)
 407+ E181 ~                                    inc     hl
 408+ E181 ~                                    ld      d,(hl)                          ; now de = address in keypress list
 409+ E181                                      ENDM
 410+ E181
 411+ E181              GetKeyStateAddressHL:   MACRO
 412+ E181 ~                                    ld      hl,KeyboardMap                  ; work our address to read from
 413+ E181 ~                                    add     hl,a
 414+ E181 ~                                    ld      a,(hl)
 415+ E181 ~                                    inc     hl
 416+ E181 ~                                    ld      h,(hl)                          ; now hl = address in keypress list
 417+ E181 ~                                    ld      l,a
 418+ E181                                      ENDM
 419+ E181
 420+ E181
 421+ E181              ;;old debug codeCurrentX            DB 0
 422+ E181              ;;old debug codeCurrentY            DB 0
 423+ E181              ;;old debug code
 424+ E181              ;;old debug codedisplayKeyStatus:       xor         a
 425+ E181              ;;old debug code                        ld          (CurrentX),a
 426+ E181              ;;old debug code                        ld          hl,RawKeys
 427+ E181              ;;old debug code                        ld          a,(hl)
 428+ E181              ;;old debug code                        and         %00011111
 429+ E181              ;;old debug code                        ld          b,5
 430+ E181              ;;old debug code.displayLoop:           push        bc,,hl
 431+ E181              ;;old debug code                        rra
 432+ E181              ;;old debug code                        jr          c,.displayNoPress
 433+ E181              ;;old debug code.displayPress:          push        af
 434+ E181              ;;old debug code                        ld          a,(CurrentX)
 435+ E181              ;;old debug code                        ld          e,a
 436+ E181              ;;old debug code                        ld          a,(CurrentY)
 437+ E181              ;;old debug code                        ld          d,a
 438+ E181              ;;old debug code                        ld          a,'*'
 439+ E181              ;;old debug code                        MMUSelectLayer1
 440+ E181              ;;old debug code                        call        l1_print_char
 441+ E181              ;;old debug code                        ld          a,(CurrentX)
 442+ E181              ;;old debug code                        add         a,8
 443+ E181              ;;old debug code                        ld          (CurrentX),a
 444+ E181              ;;old debug code                        pop         af
 445+ E181              ;;old debug code                        pop         bc,,hl
 446+ E181              ;;old debug code                        djnz        .displayLoop
 447+ E181              ;;old debug code                        ret
 448+ E181              ;;old debug code.displayNoPress:        push        af
 449+ E181              ;;old debug code                        ld          a,(CurrentX)
 450+ E181              ;;old debug code                        ld          e,a
 451+ E181              ;;old debug code                        ld          a,(CurrentY)
 452+ E181              ;;old debug code                        ld          d,a
 453+ E181              ;;old debug code                        ld          a,'O'
 454+ E181              ;;old debug code                        MMUSelectLayer1
 455+ E181              ;;old debug code                        call        l1_print_char
 456+ E181              ;;old debug code                        ld          a,(CurrentX)
 457+ E181              ;;old debug code                        add         a,8
 458+ E181              ;;old debug code                        ld          (CurrentX),a
 459+ E181              ;;old debug code                        pop         af
 460+ E181              ;;old debug code                        pop         bc,,hl
 461+ E181              ;;old debug code                        djnz        .displayLoop
 462+ E181              ;;old debug code                        ret
 463+ E181              ;;old debug code
 464+ E181              ;;old debug codedisplayDownStatus:      ld  a,(Keys+      KeyCode_CursorUp)
 465+ E181              ;;old debug code                        cp  0
 466+ E181              ;;old debug code                        jr      z,.displayNoUp
 467+ E181              ;;old debug code                        cp  1
 468+ E181              ;;old debug code                        jr      z,.displayUp
 469+ E181              ;;old debug code.displayHeld:           ld      de,8*15
 470+ E181              ;;old debug code                        ld      a,"*"
 471+ E181              ;;old debug code                        MMUSelectLayer1
 472+ E181              ;;old debug code                        call        l1_print_char
 473+ E181              ;;old debug code                        ret
 474+ E181              ;;old debug code.displayUp:             ld      de,8*15
 475+ E181              ;;old debug code                        ld      a,"+"
 476+ E181              ;;old debug code                        MMUSelectLayer1
 477+ E181              ;;old debug code                        call        l1_print_char
 478+ E181              ;;old debug code                        ret
 479+ E181              ;;old debug code.displayNoUp:             ld      de,8*15
 480+ E181              ;;old debug code                        ld      a,"O"
 481+ E181              ;;old debug code                        MMUSelectLayer1
 482+ E181              ;;old debug code                        call        l1_print_char
 483+ E181              ;;old debug code                        ret
 484+ E181              ;;old debug code
 485+ E181
 486+ E181
 487+ E181              ; call with a = c_Pressed key, will then read mapping does this with keyboard scan, waits until key gets to state 1, if it was already held then#
 488+ E181              ; it will have to be let go to reset of 0 and scan again
 489+ E181              ; Deprecated as not used as yet
 490+ E181              ;;;;;;wait_for_key_a_press:   GetKeyStateAddressHL
 491+ E181              ;;;;;;                        push    hl
 492+ E181              ;;;;;;.wait_loop:             call    scan_keyboard
 493+ E181              ;;;;;;                        pop     hl                              ; get key address into hl
 494+ E181              ;;;;;;                        push    hl
 495+ E181              ;;;;;;                        ld      a,(hl)
 496+ E181              ;;;;;;                        JumpIfANENusng  1,.wait_loop             ; will also loop if held down when entering this routine
 497+ E181              ;;;;;;                        pop     hl                              ; tidy up rogue push, less t states than detecting if we want to push or not
 498+ E181              ;;;;;;                        ret
 499+ E181              ;;;;;;; call with a = c_Pressed key, will then read mapping does this with keyboard scan waits until key gets to state 2
 500+ E181              ;;;;;;wait_for_key_a_held:    GetKeyStateAddressDE
 501+ E181              ;;;;;;                        push    hl
 502+ E181              ;;;;;;.wait_loop:             call    scan_keyboard
 503+ E181              ;;;;;;                        pop     hl
 504+ E181              ;;;;;;                        push    hl
 505+ E181              ;;;;;;                        ld      a,(hl)
 506+ E181              ;;;;;;                        JumpIfALTNusng  2, .wait_loop
 507+ E181              ;;;;;;                        pop     hl
 508+ E181              ;;;;;;                        ret
 509+ E181
 510+ E181              ; Gets the current keystate of the c_Pressed Key in a register
 511+ E181 21 00 E0     get_vkey_a_state:       ld      hl,Keys
 512+ E184 ED 31                                add     hl,a
 513+ E186 7E                                   ld      a,(hl)
 514+ E187 C9                                   ret
 515+ E188
 516+ E188 21 00 E0     is_vkey_held:           ld      hl,Keys
 517+ E18B ED 31                                add     hl,a
 518+ E18D 7E                                   ld      a,(hl)
 519+ E18E E6 02                                and     Bit1Only
 520+ E190 C9                                   ret
 521+ E191
 522+ E191 21 00 E0     is_vkey_pressed:        ld      hl,Keys
 523+ E194 ED 31                                add     hl,a
 524+ E196 7E                                   ld      a,(hl)
 525+ E197 FE 01                                cp      1
 526+ E199 C9                                   ret
 527+ E19A
 528+ E19A              get_key_a_state:        GetKeyStateAddressHL                    ; reads a mapped key and sets a to key staus, e.g. 0 1 or >=2 DOES NOT SCAN KEYBOARD
 528+ E19A 21 49 E0    >                        ld      hl,KeyboardMap                  ; work our address to read from
 528+ E19D ED 31       >                        add     hl,a
 528+ E19F 7E          >                        ld      a,(hl)
 528+ E1A0 23          >                        inc     hl
 528+ E1A1 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 528+ E1A2 6F          >                        ld      l,a
 529+ E1A3 7E                                   ld      a,(hl)                          ; a = keystate
 530+ E1A4 C9                                   ret
 531+ E1A5
 532+ E1A5              ; sets they keystate of c pressed key in a register to 1 (pressed)
 533+ E1A5              ; This will be used by auto dock
 534+ E1A5              force_key_press:        GetKeyStateAddressHL                    ; read key locations
 534+ E1A5 21 49 E0    >                        ld      hl,KeyboardMap                  ; work our address to read from
 534+ E1A8 ED 31       >                        add     hl,a
 534+ E1AA 7E          >                        ld      a,(hl)
 534+ E1AB 23          >                        inc     hl
 534+ E1AC 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 534+ E1AD 6F          >                        ld      l,a
 535+ E1AE 3E 01                                ld      a,1
 536+ E1B0 77                                   ld      (hl),a
 537+ E1B1 C9                                   ret
 538+ E1B2
 539+ E1B2              is_key_up_state:        GetKeyStateAddressHL
 539+ E1B2 21 49 E0    >                        ld      hl,KeyboardMap                  ; work our address to read from
 539+ E1B5 ED 31       >                        add     hl,a
 539+ E1B7 7E          >                        ld      a,(hl)
 539+ E1B8 23          >                        inc     hl
 539+ E1B9 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 539+ E1BA 6F          >                        ld      l,a
 540+ E1BB 7E                                   ld      a,(hl)
 541+ E1BC FE 00                                cp      0
 542+ E1BE C9                                   ret
 543+ E1BF
 544+ E1BF              ; returns z is set if c_ key is pressed
 545+ E1BF              is_key_pressed:         GetKeyStateAddressHL
 545+ E1BF 21 49 E0    >                        ld      hl,KeyboardMap                  ; work our address to read from
 545+ E1C2 ED 31       >                        add     hl,a
 545+ E1C4 7E          >                        ld      a,(hl)
 545+ E1C5 23          >                        inc     hl
 545+ E1C6 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 545+ E1C7 6F          >                        ld      l,a
 546+ E1C8 7E                                   ld      a,(hl)                          ; a = keystate
 547+ E1C9 FE 01                                cp      1                               ; we cant just test bit 0 as this may have been held long
 548+ E1CB C9                                   ret
 549+ E1CC
 550+ E1CC              ; returns nz is set if c_ key is held, if key was held then keystate would be 2 or 3, i.e. bit 1 set
 551+ E1CC              is_key_held:            GetKeyStateAddressHL
 551+ E1CC 21 49 E0    >                        ld      hl,KeyboardMap                  ; work our address to read from
 551+ E1CF ED 31       >                        add     hl,a
 551+ E1D1 7E          >                        ld      a,(hl)
 551+ E1D2 23          >                        inc     hl
 551+ E1D3 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 551+ E1D4 6F          >                        ld      l,a
 552+ E1D5 7E                                   ld      a,(hl)                          ; a = keystate
 553+ E1D6 E6 02                                and     Bit1Only                        ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
 554+ E1D8 C9                                   ret
 555+ E1D9
 556+ E1D9              ; checks to see if any key is pressed in the key table
 557+ E1D9 21 00 E0     is_any_key_pressed:     ld      hl,Keys
 558+ E1DC 01 28 00                             ld      bc,40
 559+ E1DF 3E 01                                ld      a,1
 560+ E1E1 ED B1                                cpir                                    ; search for the value 1
 561+ E1E3 28 03                                jr      z,.KeyPressed                   ; if a key was pressed then handle press
 562+ E1E5                                      SetAFalse
 562+ E1E5 3E FF       >                        ld      a,$FF
 563+ E1E7 C9                                   ret
 564+ E1E8 3E 27        .KeyPressed:            ld      a,39                            ; so c will be how many keys still to scan
 565+ E1EA 91                                   sub     c                               ; so a = 40 - c to get to result
 566+ E1EB C9                                   ret
 567+ E1EC
 568+ E1EC 21 00 E0     is_any_key_held:        ld      hl,Keys
 569+ E1EF 06 28                                ld      b,40
 570+ E1F1 0E 00                                ld      c,0
 571+ E1F3 7E           .KeyReadLoop:           ld      a,(hl)
 572+ E1F4 E6 02                                and     Bit1Only                        ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
 573+ E1F6 C2 00 E2                             jp      nz,.KeyPressed
 574+ E1F9 23                                   inc     hl
 575+ E1FA 0C                                   inc     c
 576+ E1FB 10 F6                                djnz    .KeyReadLoop
 577+ E1FD                                      SetAFalse
 577+ E1FD 3E FF       >                        ld      a,$FF
 578+ E1FF C9                                   ret
 579+ E200 79           .KeyPressed:            ld      a,c
 580+ E201 C9                                   ret
 581+ E202
 582+ E202
 583+ E202 21 41 E0     WaitForNoKey:           ld      hl,KeyAddrTab                   ; de = table of IO ports to read
 584+ E205 06 08                                ld		b,8                             ; 8 ports to ready
 585+ E207 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
 586+ E208 DB FE                                in		a,($FE)							; read port to a
 587+ E20A E6 1F                                and     %00011111
 588+ E20C FE 1F                                cp      %00011111
 589+ E20E 20 F2                                jr      nz ,WaitForNoKey
 590+ E210 23                                   inc		hl                              ; and ready for next read
 591+ E211 10 F4                                djnz    .PortReadLoop
 592+ E213 C9                                   ret
 593+ E214
 594+ E214 F5 D5 C5 E5  WaitForAnyKey:          push    af,,de,,bc,,hl
 595+ E218 CD 02 E2                             call    WaitForNoKey
 596+ E21B 21 41 E0     .waitKeyLoop:           ld		hl,KeyAddrTab                   ; de = table of IO ports to read
 597+ E21E 06 08                                ld		b,8                             ; 8 ports to ready
 598+ E220 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
 599+ E221 DB FE                                in		a,($FE)							; read port to a
 600+ E223 E6 1F                                and     %00011111
 601+ E225 FE 1F                                cp      %00011111
 602+ E227 C2 31 E2                             jp      nz,.WaitComplete
 603+ E22A C0                                   ret     nz
 604+ E22B 23                                   inc		hl                              ; and ready for next read
 605+ E22C 10 F2                                djnz    .PortReadLoop
 606+ E22E C3 1B E2                             jp      .waitKeyLoop
 607+ E231 E1 C1 D1 F1  .WaitComplete:          pop     af,,de,,bc,,hl
 608+ E235 C9                                   ret
 609+ E236
 610+ E236
 611+ E236 00 00 00...  InputString             DS  30              ; used for a 30 character input buffer
 612+ E254 00                                   DB  0               ; end of string marker as a safety
 613+ E255 00           InputLength             DB  0               ; Current String length
 614+ E256 00           InputCursor             DB  0               ; Current Cursor Position
 615+ E257 00           EnterPressed            DB  0               ; zero notpressed FF pressed
 616+ E258 00           InputChanged            DB  0
 617+ E259 00           InsertMode              DB  0
 618+ E25A              InputLimit              EQU 15
 619+ E25A
 620+ E25A 21 36 E2     keyboard_copy_input_to_de:  ld      hl,InputString
 621+ E25D 3A 56 E2                                 ld      a,(InputCursor)
 622+ E260 FE 00                                    cp      0
 623+ E262 28 05                                    jr      z,.NoString
 624+ E264 4F                                       ld      c,a
 625+ E265 06 00                                    ld      b,0
 626+ E267 ED B0                                    ldir
 627+ E269 3E 00        .NoString                   ld      a,0
 628+ E26B 12                                       ld      (de),a
 629+ E26C C9                                       ret
 630+ E26D
 631+ E26D               ;Input routine logic
 632+ E26D               ;Intialise input state
 633+ E26D
 634+ E26D              ; Scans the key pressed to determine if its an alpha, returns ascii code or 0 if not alpha
 635+ E26D              ; Input a = key pressed, returns with carry set if no alpha else carry is clear
 636+ E26D              isKeyAlpha:             JumpIfALTNusng  "A",   .NotAlpha
 636+ E26D FE 41       >                        cp      "A"
 636+ E26F DA 79 E2    >                        jp		c, .NotAlpha
 637+ E272                                      JumpIfAGTENusng "Z"+1, .NotAlpha
 637+ E272 FE 5B       >                        cp     "Z"+1
 637+ E274 D2 79 E2    >                        jp		nc,.NotAlpha
 638+ E277                                      ClearCarryFlag
 638+ E277 B7          >                        or a
 639+ E278 C9                                   ret
 640+ E279              .NotAlpha               SetCarryFlag
 640+ E279 37          >                        scf
 641+ E27A C9                                   ret
 642+ E27B
 643+ E27B 3A 56 E2     InsertKeystroke:        ld      a,(InputCursor)                         ; Current Cursor position
 644+ E27E FE 1E                                cp      30                                      ; protect from buffer overflow
 645+ E280 C8                                   ret     z                                       ; .
 646+ E281 21 36 E2                             ld      hl,InputString                          ; position hl to position in input string
 647+ E284 ED 31                                add     hl,a                                    ; .
 648+ E286 E5                                   push    hl                                      ; save current cursor position
 649+ E287 47                                   ld      b,a                                     ; as a quick optimisation
 650+ E288                                      JumpIfMemFalse InsertMode, .NoCopyNeeded        ; if we are in overtype mode skip copy
 650+ E288 3A 59 E2    >                        ld      a,(InsertMode)
 650+ E28B A7          >                        and     a
 650+ E28C C2 AC E2    >                        jp      nz, .NoCopyNeeded
 651+ E28F 3A 55 E2                             ld      a,(InputLength)                         ; no need to shuffle string
 652+ E292 B8                                   cp      b                                       ; if we are at the end already
 653+ E293 78                                   ld      a,b                                     ; .
 654+ E294 CA AC E2                             jp      z,.NoCopyNeeded                         ; so we can behave like overtype mode
 655+ E297 11 53 E2                             ld      de,InputString+29                       ; now from the end of the string
 656+ E29A 21 52 E2                             ld      hl,InputString+28                       ; .
 657+ E29D 06 1D                                ld      b,29                                    ; for up to 29 characters
 658+ E29F 4F                                   ld      c,a                                     ; back to the current cursor position
 659+ E2A0 C5           .CopyLoop:              push    bc                                      ; save current position
 660+ E2A1 7E                                   ld      a,(hl)                                  ; now suffle from left char to right char
 661+ E2A2 12                                   ld      (de),a                                  ; .
 662+ E2A3 2B                                   dec     hl                                      ; moving back one byte at a time
 663+ E2A4 1B                                   dec     de                                      ;
 664+ E2A5 05                                   dec     b                                       ; and reducing the current copy position
 665+ E2A6 79                                   ld      a,c                                     ; have we reached the input cursor pos
 666+ E2A7 B8                                   cp      b                                       ;
 667+ E2A8 C1                                   pop     bc
 668+ E2A9 C2 A0 E2                             jp      nz,.CopyLoop
 669+ E2AC E1           .NoCopyNeeded:          pop     hl
 670+ E2AD 3A B8 E2                             ld      a,(LastKeyPressed)
 671+ E2B0 77                                   ld      (hl),a
 672+ E2B1 21 55 E2                             ld      hl,InputLength
 673+ E2B4 34                                   inc     (hl)
 674+ E2B5 23                                   inc     hl                                      ;  to input cursor as a short cut to logic
 675+ E2B6 34                                   inc     (hl)
 676+ E2B7 C9                                   ret
 677+ E2B8
 678+ E2B8
 679+ E2B8              ; We won't have any auto repeat on input
 680+ E2B8 00           LastKeyPressed:         db 0
 681+ E2B9
 682+ E2B9              initInputText:          ZeroA
 682+ E2B9 AF          >                        xor a
 683+ E2BA 32 56 E2                             ld      (InputCursor),a
 684+ E2BD 3E 2A                                ld      a,InputBlinkOn
 685+ E2BF 32 EE E2                             ld      (InputBlinkSymbol),a
 686+ E2C2 21 EE 02                             ld      hl,InputBlinkDelay
 687+ E2C5 22 EC E2                             ld      (InputBlinkCounter),hl
 688+ E2C8 32 B8 E2                             ld      (LastKeyPressed),a
 689+ E2CB 32 55 E2                             ld      (InputLength),a
 690+ E2CE                                      SetMemTrue  InsertMode
 690+ E2CE AF          >                        xor     a
 690+ E2CF 32 59 E2    >                        ld      (InsertMode),a
 691+ E2D2                                      SetMemFalse EnterPressed
 691+ E2D2 3E FF       >                        ld      a,$FF
 691+ E2D4 32 57 E2    >                        ld      (EnterPressed),a
 692+ E2D7                                      SetMemFalse InputChanged
 692+ E2D7 3E FF       >                        ld      a,$FF
 692+ E2D9 32 58 E2    >                        ld      (InputChanged),a
 693+ E2DC                                      ZeroA
 693+ E2DC AF          >                        xor a
 694+ E2DD 21 36 E2                             ld      hl,InputString
 695+ E2E0 06 1E                                ld      b,30
 696+ E2E2 77           .wipeloop:              ld      (hl),a
 697+ E2E3 23                                   inc     hl
 698+ E2E4 10 FC                                djnz    .wipeloop
 699+ E2E6 C9                                   ret
 700+ E2E7
 701+ E2E7              ;;;InputNameV2:            call    is_any_key_pressed              ; scan for key states
 702+ E2E7              ;;;                        cp      $FF                             ; no key means we reset auto repeat
 703+ E2E7              ;;;                        jp      z,.NoKeyPressed                 ;
 704+ E2E7              ;;;.IsItLastKeyHeld:       ld      hl,LastKeyPressed               ; is it the same key as before
 705+ E2E7              ;;;                        cp      (hl)                            ;
 706+ E2E7              ;;;                        ret     z                               ; if so just ignore it to avoid auto repeat
 707+ E2E7              ;;;.SetNewAntiRepeat:      ld      (LastKeyPressed),a
 708+ E2E7              ;;;.CheckKeyPressed:       call    isKeyAlpha
 709+ E2E7              ;;;                        jp      nc,.AlphaKeyPressed
 710+ E2E7              ;;;.CheckSpaceKeyPressed:  cp      " "
 711+ E2E7              ;;;                        jp      z,.SpacePressed
 712+ E2E7              ;;;.CheckEnterPressed:     cp      ">"
 713+ E2E7              ;;;                        jp      z,.EnterPressed
 714+ E2E7              ;;;.CheckLeftPressed:      cp      "["
 715+ E2E7              ;;;                        jp      z,.LeftPressed
 716+ E2E7              ;;;.CheckRightPressed:     cp      "]"
 717+ E2E7              ;;;                        jp      z,.RightPressed
 718+ E2E7              ;;;.CheckDeletePressed:    cp      "#"
 719+ E2E7              ;;;                        jp      z,.DeletePressed
 720+ E2E7              ;;;.AnyOtherKeyIsIgnored:  ret
 721+ E2E7              ;;;.AlphaKeyPressed:       ld      a,(InputLength)
 722+ E2E7              ;;;                        JumpIfAGTENusng 30,.MaxInputReached
 723+ E2E7              ;;;.InsertKey:             call    InsertKeystroke
 724+ E2E7              ;;;                        ret
 725+ E2E7              ;;;.SpacePressed:          call    InsertKeystroke
 726+ E2E7              ;;;                        ret
 727+ E2E7              ;;;.EnterPressed:
 728+ E2E7              ;;;
 729+ E2E7              ;;;.LeftPressed:           ld      a,(InputCusor)
 730+ E2E7              ;;;                        JumpIfAIsZero, .MaxInputReached
 731+ E2E7              ;;;                        dec     a
 732+ E2E7              ;;;                        ld      (InputCursor),a
 733+ E2E7              ;;;                        ret
 734+ E2E7              ;;;.RightPressed:          ld      a,(InputLength)
 735+ E2E7              ;;;                        inc     a
 736+ E2E7              ;;;                        ld      b,a
 737+ E2E7              ;;;                        ld      a,(InputCursor)
 738+ E2E7              ;;;                        JumpIfMemGTENusng b, .MaxInputReached
 739+ E2E7              ;;;                        inc     a
 740+ E2E7              ;;;                        ld      (InputCursor),a
 741+ E2E7              ;;;                        ret
 742+ E2E7              ;;;.DeletaPressed:         ld      a,(InputCusor)
 743+ E2E7              ;;;                        ld      c,a
 744+ E2E7              ;;;                        JumpIfAisZero, .MaxInputReached
 745+ E2E7              ;;;                        ld      a,(InputLength)
 746+ E2E7              ;;;                        JumpIfAisZero, .MaxInputReached
 747+ E2E7              ;;;                        ld      de,InputString
 748+ E2E7              ;;;                        ld      hl,de
 749+ E2E7              ;;;                        inc     hl
 750+ E2E7              ;;;                        ld      a,(InputLength)                 ; copy backwards
 751+ E2E7              ;;;                        dec     c                               ; for string length - curretn cursor
 752+ E2E7              ;;;                        ld      c,a
 753+ E2E7              ;;;                        ld      b,0
 754+ E2E7              ;;;                        ldir
 755+ E2E7              ;;;                        ret
 756+ E2E7              ;;;GOTTOHERE
 757+ E2E7
 758+ E2E7
 759+ E2E7
 760+ E2E7 C9           .MaxInputReached:       ret ; will add a beep later
 761+ E2E8
 762+ E2E8
 763+ E2E8
 764+ E2E8
 765+ E2E8              .NoKeyPressed:          ZeroA
 765+ E2E8 AF          >                        xor a
 766+ E2E9 32 B8 E2                             ld      (LastKeyPressed),a              ; Clear last key pressed
 767+ E2EC
 768+ E2EC              InputBlinkDelay         EQU     750
 769+ E2EC              InputBlinkOn            EQU     "*"
 770+ E2EC              InputBlinkOff:          EQU     "-"
 771+ E2EC EE 02        InputBlinkCounter:      DW      InputBlinkDelay
 772+ E2EE 2A           InputBlinkSymbol:       DB      InputBlinkOn
 773+ E2EF
 774+ E2EF              InputName:              SetMemFalse InputChanged
 774+ E2EF 3E FF       >                        ld      a,$FF
 774+ E2F1 32 58 E2    >                        ld      (InputChanged),a
 775+ E2F4 CD D9 E1                             call    is_any_key_pressed
 776+ E2F7 FE FF                                cp      $FF
 777+ E2F9 CA 5F E3                             jp      z,InputBlinkCursor
 778+ E2FC 4F           .KeyPressed:            ld      c,a
 779+ E2FD 3A 56 E2                             ld      a,(InputCursor)                 ; No key so we can now look at if we are at the end of the buffer
 780+ E300 FE 0F                                cp      InputLimit                      ; move to variable later and then cp (hl)
 781+ E302 28 0B                                jr      z,.DeleteOrEnterOnly            ;
 782+ E304 21 BF E0                             ld      hl,ASCII_Map
 783+ E307 79                                   ld      a,c
 784+ E308 ED 31                                add     hl,a
 785+ E30A 7E                                   ld      a,(hl)
 786+ E30B FE 41                                cp      "A"
 787+ E30D 30 0B                                jr      nc,.AlphaPressed
 788+ E30F              ; CAPS and Symbol act as delete for now
 789+ E30F FE 23        .DeleteOrEnterOnly      cp      "#"                             ; if space was  pressed (mapped to Hash in ASCII table))
 790+ E311 28 37                                jr      z,.SpacePressed                 ; for now we will ignore the shift and just assume delete
 791+ E313 FE 3E                                cp      ">"         ; ENTER
 792+ E315 28 1B                                jr      z,.EnterPressed
 793+ E317 C3 5F E3                             jp      InputBlinkCursor
 794+ E31A 47           .AlphaPressed:          ld      b,a
 795+ E31B 3A 56 E2                             ld      a,(InputCursor)
 796+ E31E 4F                                   ld      c,a
 797+ E31F 21 36 E2                             ld      hl,InputString
 798+ E322 ED 31                                add     hl,a
 799+ E324 78                                   ld      a,b
 800+ E325 70                                   ld      (hl),b
 801+ E326 79                                   ld      a,c
 802+ E327 21 56 E2                             ld      hl,InputCursor
 803+ E32A 34                                   inc     (hl)
 804+ E32B                                      SetMemTrue InputChanged
 804+ E32B AF          >                        xor     a
 804+ E32C 32 58 E2    >                        ld      (InputChanged),a
 805+ E32F C3 5F E3                             jp      InputBlinkCursor
 806+ E332 3A 56 E2     .EnterPressed:          ld      a,(InputCursor)
 807+ E335 21 36 E2                             ld      hl,InputString
 808+ E338 ED 31                                add     hl,a
 809+ E33A                                      ZeroA
 809+ E33A AF          >                        xor a
 810+ E33B 77                                   ld      (hl),a
 811+ E33C                                      SetMemTrue EnterPressed
 811+ E33C AF          >                        xor     a
 811+ E33D 32 57 E2    >                        ld      (EnterPressed),a
 812+ E340                                      SetMemTrue InputChanged
 812+ E340 AF          >                        xor     a
 812+ E341 32 58 E2    >                        ld      (InputChanged),a
 813+ E344 CD F7 E0                             call    init_keyboard           ; Flush keyboard status so futher inputs don't auto read the enter key as a second press
 814+ E347 C3 5F E3                             jp      InputBlinkCursor
 815+ E34A 3A 56 E2     .SpacePressed:          ld      a,(InputCursor)         ; Space = delete
 816+ E34D FE 00                                cp      0                       ; if input is zero length then can not delete
 817+ E34F C8                                   ret     z
 818+ E350 3D                                   dec     a                       ; move back one and update cursor pos
 819+ E351 32 56 E2                             ld      (InputCursor),a         ;
 820+ E354 21 36 E2                             ld      hl,InputString          ; now update end of line to null
 821+ E357 ED 31                                add     hl,a                    ; .
 822+ E359                                      ZeroA                           ; .
 822+ E359 AF          >                        xor a
 823+ E35A 77                                   ld      (hl),a                  ; .
 824+ E35B                                      SetMemTrue InputChanged
 824+ E35B AF          >                        xor     a
 824+ E35C 32 58 E2    >                        ld      (InputChanged),a
 825+ E35F 2A EC E2     InputBlinkCursor:       ld      hl,(InputBlinkCounter)
 826+ E362 2B                                   dec     hl
 827+ E363 7C                                   ld      a,h
 828+ E364 B5                                   or      l
 829+ E365 CA 6C E3                             jp      z,.ToggleBlink
 830+ E368 22 EC E2                             ld      (InputBlinkCounter),hl
 831+ E36B C9                                   ret
 832+ E36C 21 EE 02     .ToggleBlink:           ld      hl,InputBlinkDelay
 833+ E36F 22 EC E2                             ld      (InputBlinkCounter),hl
 834+ E372 3A EE E2                             ld      a,(InputBlinkSymbol)
 835+ E375 FE 2A                                cp      InputBlinkOn
 836+ E377 3E 2D                                ld      a,InputBlinkOff
 837+ E379 CA 7E E3                             jp      z,.UpdateBlink
 838+ E37C 3E 2A        .SetBlinkOn:            ld      a,InputBlinkOn
 839+ E37E 32 EE E2     .UpdateBlink:           ld      (InputBlinkSymbol),a
 840+ E381 47                                   ld      b,a
 841+ E382 3A 56 E2                             ld      a,(InputCursor)
 842+ E385 21 36 E2                             ld      hl,InputString
 843+ E388 ED 31                                add     hl,a
 844+ E38A 70                                   ld      (hl),b
 845+ E38B 23                                   inc     hl
 846+ E38C 36 00                                ld      (hl),0
 847+ E38E                                      SetMemTrue InputChanged
 847+ E38E AF          >                        xor     a
 847+ E38F 32 58 E2    >                        ld      (InputChanged),a
 848+ E392 C9                                   ret
 849+ E393
 850+ E393
 851+ E393              TargetMissileTest:      AnyMissilesLeft
 851+ E393 3A B4 67    >                        ld      a,(NbrMissiles)
 851+ E396 A7          >                        and     a
 852+ E397                                      JumpIfZero      .ClearTargetting
 852+ E397 CA AE E3    >                        jp	z,.ClearTargetting
 853+ E39A                                      IsMissileLaunchFlagged                      ; if we are comitted to launch
 853+ E39A 3A A7 69    >                        ld      a,(MissileTargettingFlag)
 853+ E39D E6 80       >                        and     $80
 854+ E39F C8                                   ret             z                           ; then don't scan as it will be cleared on launch
 855+ E3A0 3E 16        .ScanForKey:            ld              a,c_Pressed_TargetMissle    ; if not pressed we are done
 856+ E3A2 CD BF E1                             call            is_key_pressed              ; .
 857+ E3A5 C0                                   ret             nz                          ; .
 858+ E3A6 3A A7 69     .TargetPressed:         ld              a,(MissileTargettingFlag)   ; get flag back
 859+ E3A9                                      JumpIfAEqNusng  StageMissileNotTargeting, .SetTargetting
 859+ E3A9 FE FF       >                        cp     StageMissileNotTargeting
 859+ E3AB CA B4 E3    >                        jp      z,.SetTargetting
 860+ E3AE              .ClearTargetting:       ClearMissileTargetting
 860+ E3AE 3E FF       >                        ld      a,StageMissileNotTargeting
 860+ E3B0 32 A7 69    >                        ld      (MissileTargettingFlag),a
 861+ E3B3 C9                                   ret
 862+ E3B4              .SetTargetting:         SetMissileTargetting
 862+ E3B4 3E FE       >                        ld      a,StageMissileTargeting
 862+ E3B6 32 A7 69    >                        ld      (MissileTargettingFlag),a
 863+ E3B9 C9                                   ret
 864+ E3BA
 865+ E3BA AF           MovementKeyTest:        xor     a
 866+ E3BB 32 10 69                             ld      (CursorKeysPressed),a
 867+ E3BE 3A 12 67                             ld      a,(MenuIdMax)
 868+ E3C1 E6 FC                                and     $FC
 869+ E3C3 20 26                                jr      nz,CursorKeys
 870+ E3C5 2A 57 E0     ClimbDiveKeys:          ld      hl,(addr_Pressed_Climb)                 ; Check for Climb
 871+ E3C8 7E                                   ld      a,(hl)
 872+ E3C9                                      JumpIfAIsZero ScanDiveKey
 872+ E3C9 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 872+ E3CA CA D8 E3    >                        jp	    z, ScanDiveKey
 873+ E3CD 3A 10 69                             ld      a,(CursorKeysPressed)
 874+ E3D0 F6 80                                or      CursorClimb
 875+ E3D2 32 10 69                             ld      (CursorKeysPressed),a
 876+ E3D5 C3 0E E4                             jp      ScanLeftKey
 877+ E3D8 2A 55 E0     ScanDiveKey:            ld      hl,(addr_Pressed_Dive)                  ; Check for Dive
 878+ E3DB 7E                                   ld      a,(hl)
 879+ E3DC                                      JumpIfAIsZero ScanLeftKey
 879+ E3DC A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 879+ E3DD CA 0E E4    >                        jp	    z, ScanLeftKey
 880+ E3E0 3A 10 69                             ld      a,(CursorKeysPressed)
 881+ E3E3 F6 40                                or      CursorDive
 882+ E3E5 32 10 69                             ld      (CursorKeysPressed),a
 883+ E3E8 C3 0E E4                             jp      ScanLeftKey
 884+ E3EB 2A 93 E0     CursorKeys:             ld      hl,(addr_Pressed_CursorUp)              ; Check cursor keys
 885+ E3EE 7E                                   ld      a,(hl)
 886+ E3EF                                      JumpIfAIsZero ScanCursorDownKey
 886+ E3EF A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 886+ E3F0 CA FE E3    >                        jp	    z, ScanCursorDownKey
 887+ E3F3 3A 10 69                             ld      a,(CursorKeysPressed)
 888+ E3F6 F6 80                                or      CursorClimb
 889+ E3F8 32 10 69                             ld      (CursorKeysPressed),a
 890+ E3FB C3 0E E4                             jp      ScanLeftKey
 891+ E3FE 2A 95 E0     ScanCursorDownKey:      ld      hl,(addr_Pressed_CursorDown)
 892+ E401 7E                                   ld      a,(hl)
 893+ E402                                      JumpIfAIsZero ScanLeftKey
 893+ E402 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 893+ E403 CA 0E E4    >                        jp	    z, ScanLeftKey
 894+ E406 3A 10 69                             ld      a,(CursorKeysPressed)
 895+ E409 F6 40                                or      CursorDive
 896+ E40B 32 10 69                             ld      (CursorKeysPressed),a
 897+ E40E 2A 51 E0     ScanLeftKey:            ld      hl,(addr_Pressed_RollLeft)
 898+ E411 7E                                   ld      a,(hl)
 899+ E412                                      JumpIfAIsZero ScanRightKey
 899+ E412 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 899+ E413 CA 1F E4    >                        jp	    z, ScanRightKey
 900+ E416 3A 10 69                             ld      a,(CursorKeysPressed)
 901+ E419 F6 20                                or      CursorLeft
 902+ E41B 32 10 69                             ld      (CursorKeysPressed),a
 903+ E41E C9                                   ret
 904+ E41F 2A 53 E0     ScanRightKey:           ld      hl,(addr_Pressed_RollRight)
 905+ E422 7E                                   ld      a,(hl)
 906+ E423                                      JumpIfAIsZero ScanHomeKey
 906+ E423 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 906+ E424 CA 30 E4    >                        jp	    z, ScanHomeKey
 907+ E427 3A 10 69                             ld      a,(CursorKeysPressed)
 908+ E42A F6 10                                or      CursorRight
 909+ E42C 32 10 69                             ld      (CursorKeysPressed),a
 910+ E42F C9                                   ret
 911+ E430 2A 71 E0     ScanHomeKey:            ld      hl,(addr_Pressed_HomeCursor)
 912+ E433 7E                                   ld      a,(hl)
 913+ E434                                      JumpIfAIsZero ScanRecentreKey
 913+ E434 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 913+ E435 CA 41 E4    >                        jp	    z, ScanRecentreKey
 914+ E438 3A 10 69                             ld      a,(CursorKeysPressed)
 915+ E43B F6 08                                or      CursorHome
 916+ E43D 32 10 69                             ld      (CursorKeysPressed),a
 917+ E440 C9                                   ret
 918+ E441 2A 8D E0     ScanRecentreKey:        ld      hl,(addr_Pressed_Recentre)
 919+ E444 7E                                   ld      a,(hl)
 920+ E445                                      ReturnIfAIsZero
 920+ E445 A7          >                        and     a
 920+ E446 C8          >                        ret     z
 921+ E447 3A 10 69                             ld      a,(CursorKeysPressed)
 922+ E44A F6 04                                or      CursorRecenter
 923+ E44C 32 10 69                             ld      (CursorKeysPressed),a
 924+ E44F C9                                   ret
 925+ E450
 926+ E450
# file closed: ../../Hardware/keyboard.asm
 999  E450                                  DISPLAY "Keyboard ",BankKeyboard," - Bytes free ",/D, $2000 - ($-KeyboardAddr), " - BankKeyboard"
1000  E450                                  ASSERT $-KeyboardAddr <8912, Bank code leaks over 8K boundary
1001  E450               ; Bank 102  -----------------------------------------------------------------------------------------------------------------------
1002  E450                                  SLOT    MathsBankedFnsAddr
1003  E450                                  PAGE    BankMathsBankedFns
1004  E450                                  ORG     MathsBankedFnsAddr,BankMathsBankedFns
1005  0000                                  INCLUDE "../../Maths/MathsBankedFns.asm"
# file opened: ../../Maths/MathsBankedFns.asm
   1+ 0000              ;------------------------------------------------------------
   2+ 0000              ; HL Signed = HL - DE
   3+ 0000 7A           SubDEfromHLSigned:      ld      a,d
   4+ 0001 EE 80                                xor     $80
   5+ 0003 57                                   ld      d,a
   6+ 0004              ;------------------------------------------------------------
   7+ 0004              ; Adds DE to HL, in form S15 result will also be S15 rather than 2's C
   8+ 0004 7C           AddDEtoHLSigned:        ld      a,h                         ; extract h sign to b
   9+ 0005 E6 80                                and     $80                         ; hl = abs (hl)
  10+ 0007 47                                   ld      b,a
  11+ 0008 7C                                   ld      a,h
  12+ 0009 E6 7F                                and     $7F
  13+ 000B 67                                   ld      h,a
  14+ 000C 7A                                   ld      a,d                         ; extract d sign to c
  15+ 000D E6 80                                and     $80                         ; de = abs (de)
  16+ 000F 4F                                   ld      c,a
  17+ 0010 7A                                   ld      a,d
  18+ 0011 E6 7F                                and     $7F
  19+ 0013 57                                   ld      d,a
  20+ 0014 78                                   ld      a,b
  21+ 0015 A9                                   xor     c
  22+ 0016 C2 1E 00                             jp      nz,.OppositeSigns
  23+ 0019 19           .SameSigns              add     hl,de                       ; same signs so just add
  24+ 001A 78                                   ld      a,b                         ; and bring in the sign from b
  25+ 001B B4                                   or      h                           ; note this has to be 15 bit result
  26+ 001C 67                                   ld      h,a                         ; but we can assume that
  27+ 001D C9                                   ret
  28+ 001E              .OppositeSigns:         ClearCarryFlag
  28+ 001E B7          >                        or a
  29+ 001F ED 52                                sbc     hl,de
  30+ 0021 38 04                                jr      c,.OppsiteSignInvert
  31+ 0023 78           .OppositeSignNoInvert:  ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
  32+ 0024 B4                                   or      h
  33+ 0025 67                                   ld      h,a                         ; set the previou sign value
  34+ 0026 C9                                   ret
  35+ 0027              .OppsiteSignInvert:     NegHL                              ; we need to flip the sign and 2'c the Hl result
  35+ 0027 AF          >                    xor a
  35+ 0028 95          >                    sub l
  35+ 0029 6F          >                    ld l,a
  35+ 002A 9F          >                    sbc a,a
  35+ 002B 94          >                    sub h
  35+ 002C 67          >                    ld h,a
  36+ 002D 78                                   ld      a,b
  37+ 002E EE 80                                xor     SignOnly8Bit               ; flip sign bit
  38+ 0030 B4                                   or      h
  39+ 0031 67                                   ld      h,a                         ; recover sign
  40+ 0032 C9                                   ret
  41+ 0033
  42+ 0033              ;------------------------------------------------------------
  43+ 0033              ; AHL = BHL+CDE where signs are held in B and C
  44+ 0033 78           ADDHLDESignBC:          ld      a,b
  45+ 0034 E6 80                                and     SignOnly8Bit
  46+ 0036 A9                                   xor     c                           ;if b sign and c sign were different then bit 7 of a will be 1 which means
  47+ 0037                                      JumpIfNegative .ADDHLDEsBCOppSGN     ;Signs are opposite there fore we can subtract to get difference
  47+ 0037 FA 45 00    >                        jp		m, .ADDHLDEsBCOppSGN
  48+ 003A 78           .ADDHLDEsBCSameSigns:   ld      a,b
  49+ 003B B1                                   or      c
  50+ 003C                                      JumpIfNegative .ADDHLDEsBCSameNeg    ; optimisation so we can just do simple add if both positive
  50+ 003C FA 41 00    >                        jp		m, .ADDHLDEsBCSameNeg
  51+ 003F 19                                   add     hl,de                       ; both positive so a will already be zero
  52+ 0040 C9                                   ret
  53+ 0041 19           .ADDHLDEsBCSameNeg:      add     hl,de
  54+ 0042 78                                   ld      a,b
  55+ 0043                                      DISPLAY "TODO: don't bother with overflow for now"
  56+ 0043 B1                                   or      c                           ; now set bit for negative value, we won't bother with overflow for now TODO
  57+ 0044 C9                                   ret
  58+ 0045              .ADDHLDEsBCOppSGN:      ClearCarryFlag
  58+ 0045 B7          >                        or a
  59+ 0046 ED 52                                sbc     hl,de
  60+ 0048 38 02                                jr      c,.ADDHLDEsBCOppInvert
  61+ 004A 78           .ADDHLDEsBCOppSGNNoCarry:ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
  62+ 004B C9                                   ret
  63+ 004C              .ADDHLDEsBCOppInvert:   NegHL                               ; if result was zero then set sign to zero (which doing h or l will give us for free)
  63+ 004C AF          >                    xor a
  63+ 004D 95          >                    sub l
  63+ 004E 6F          >                    ld l,a
  63+ 004F 9F          >                    sbc a,a
  63+ 0050 94          >                    sub h
  63+ 0051 67          >                    ld h,a
  64+ 0052 78                                   ld      a,b
  65+ 0053 EE 80                                xor     SignOnly8Bit                ; flip sign bit
  66+ 0055 C9                                   ret
  67+ 0056                  DISPLAY "TODO: Check if ADDHLDESignedV4 is deprecated by AddDEtoHLSigned"
  68+ 0056 7C           ADDHLDESignedV4:        ld      a,h
  69+ 0057 E6 80                                and     SignOnly8Bit
  70+ 0059 47                                   ld      b,a                         ;save sign bit in b
  71+ 005A AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
  72+ 005B                                      JumpIfNegative .ADDHLDEOppSGN       ;Signs are opposite there fore we can subtract to get difference
  72+ 005B FA 73 00    >                        jp		m, .ADDHLDEOppSGN
  73+ 005E 78           .ADDHLDESameSigns:      ld      a,b
  74+ 005F B2                                   or      d
  75+ 0060                                      JumpIfNegative .ADDHLDESameNeg      ; optimisation so we can just do simple add if both positive
  75+ 0060 FA 65 00    >                        jp		m, .ADDHLDESameNeg
  76+ 0063 19                                   add     hl,de
  77+ 0064 C9                                   ret
  78+ 0065 7C           .ADDHLDESameNeg:        ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
  79+ 0066 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
  80+ 0068 67                                   ld      h,a
  81+ 0069 7A                                   ld      a,d
  82+ 006A E6 7F                                and     SignMask8Bit
  83+ 006C 57                                   ld      d,a
  84+ 006D 19                                   add     hl,de
  85+ 006E 3E 80                                ld      a,SignOnly8Bit
  86+ 0070                                      DISPLAY "TODO:  dont bother with overflow for now"
  87+ 0070 B4                                   or      h                           ; now set bit for negative value, we won't bother with overflow for now TODO
  88+ 0071 67                                   ld      h,a
  89+ 0072 C9                                   ret
  90+ 0073 7C           .ADDHLDEOppSGN:         ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit                     ; here HL and DE are opposite
  91+ 0074 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
  92+ 0076 67                                   ld      h,a
  93+ 0077 7A                                   ld      a,d
  94+ 0078 E6 7F                                and     SignMask8Bit
  95+ 007A 57                                   ld      d,a
  96+ 007B                                      ClearCarryFlag
  96+ 007B B7          >                        or a
  97+ 007C ED 52                                sbc     hl,de
  98+ 007E 38 04                                jr      c,.ADDHLDEOppInvert
  99+ 0080 78           .ADDHLDEOppSGNNoCarry:  ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
 100+ 0081 B4                                   or      h
 101+ 0082 67                                   ld      h,a                         ; set the previou sign value
 102+ 0083 C9                                   ret
 103+ 0084              .ADDHLDEOppInvert:      NegHL                                                   ; we need to flip the sign and 2'c the Hl result
 103+ 0084 AF          >                    xor a
 103+ 0085 95          >                    sub l
 103+ 0086 6F          >                    ld l,a
 103+ 0087 9F          >                    sbc a,a
 103+ 0088 94          >                    sub h
 103+ 0089 67          >                    ld h,a
 104+ 008A 78                                   ld      a,b
 105+ 008B EE 80                                xor     SignOnly8Bit                ; flip sign bit
 106+ 008D B4                                   or      h
 107+ 008E 67                                   ld      h,a                         ; recover sign
 108+ 008F C9                                   ret
 109+ 0090
 110+ 0090              ;------------------------------------------------------------
 111+ 0090              ; extension to AddBCHtoDELsigned
 112+ 0090              ; takes ix as the address of the values to load into DEL
 113+ 0090              ;       iy as the address of the values to load into BCH
 114+ 0090 DD 6E 00     AddAtIXtoAtIY24Signed:  ld      l,(ix+0)            ; del = ix (sign hi lo)
 115+ 0093 DD 5E 01                             ld      e,(ix+1)            ; .
 116+ 0096 DD 56 02                             ld      d,(ix+2)            ; .
 117+ 0099 FD 66 00                             ld      h,(iy+0)            ; bch = iy (sign, hi, lo)
 118+ 009C FD 4E 01                             ld      c,(iy+1)            ; .
 119+ 009F FD 46 02                             ld      b,(iy+2)            ; .
 120+ 00A2 FD E5                                push    iy                  ; save iy as add function changes is
 121+ 00A4 CD 14 01                             call    AddBCHtoDELsigned   ; Perform del += bch
 122+ 00A7 FD E1                                pop     iy                  ; get iy back
 123+ 00A9 DD 75 00                             ld      (ix+0),l            ; put result into (ix)
 124+ 00AC DD 73 01                             ld      (ix+1),e            ; .
 125+ 00AF DD 72 02                             ld      (ix+2),d            ; .
 126+ 00B2 C9                                   ret
 127+ 00B3              ;------------------------------------------------------------
 128+ 00B3              ; DEL = @IX + @IY 24 bit signed
 129+ 00B3              AddDELequAtIXPlusIY24Signed:
 130+ 00B3 DD 6E 00                             ld      l,(ix+0)            ; del = ix (sign hi lo)
 131+ 00B6 DD 5E 01                             ld      e,(ix+1)            ; .
 132+ 00B9 DD 56 02                             ld      d,(ix+2)            ; .
 133+ 00BC FD 66 00                             ld      h,(iy+0)            ; bch = iy (sign, hi, lo)
 134+ 00BF FD 4E 01                             ld      c,(iy+1)            ; .
 135+ 00C2 FD 46 02                             ld      b,(iy+2)            ; .
 136+ 00C5 FD E5                                push    iy                  ; save iy as add function changes is
 137+ 00C7 CD 14 01                             call    AddBCHtoDELsigned   ; Perform del += bch
 138+ 00CA FD E1                                pop     iy                  ; get iy back
 139+ 00CC C9                                   ret
 140+ 00CD              ;------------------------------------------------------------
 141+ 00CD              ; extension to AddBCHtoDELsigned
 142+ 00CD              ; takes ix as the address of the values to load into DEL
 143+ 00CD              ;       iy as the address of the values to load into BCH
 144+ 00CD              ; subtracts iy from ix putting result in ix
 145+ 00CD              ; DEL = @IX - @IY 24 bit signed
 146+ 00CD DD 6E 00     SubAtIXtoAtIY24Signed:  ld      l,(ix+0)            ; del = ix (sign hi lo)
 147+ 00D0 DD 5E 01                             ld      e,(ix+1)            ; .
 148+ 00D3 DD 56 02                             ld      d,(ix+2)            ; .
 149+ 00D6 FD 66 00                             ld      h,(iy+0)            ; bch = -iy (sign, hi, lo)
 150+ 00D9 FD 4E 01                             ld      c,(iy+1)            ; .
 151+ 00DC FD 7E 02                             ld      a,(iy+2)            ; .
 152+ 00DF EE 80                                xor     SignOnly8Bit        ; . this is where we flip sign to make add subtract
 153+ 00E1 47                                   ld      b,a                 ; .
 154+ 00E2 FD E5                                push    iy                  ; save iy as add function changes is
 155+ 00E4 CD 14 01                             call    AddBCHtoDELsigned   ; perform del += bch which as we flipped bch sign means (ix [210] -= iy [210])
 156+ 00E7 FD E1                                pop     iy                  ; get iy back
 157+ 00E9 DD 75 00                             ld      (ix+0),l            ; put result into (ix)
 158+ 00EC DD 73 01                             ld      (ix+1),e            ; .
 159+ 00EF DD 72 02                             ld      (ix+2),d            ; .
 160+ 00F2 C9                                   ret
 161+ 00F3              ;------------------------------------------------------------
 162+ 00F3              ; extension to AddBCHtoDELsigned
 163+ 00F3              ; takes ix as the address of the values to load into DEL
 164+ 00F3              ;       iy as the address of the values to load into BCH
 165+ 00F3              ; subtracts iy from ix leaving result in del
 166+ 00F3              SubDELequAtIXMinusAtIY24Signed:
 167+ 00F3 DD 6E 00                             ld      l,(ix+0)            ; del = ix (sign hi lo)
 168+ 00F6 DD 5E 01                             ld      e,(ix+1)            ; .
 169+ 00F9 DD 56 02                             ld      d,(ix+2)            ; .
 170+ 00FC FD 66 00                             ld      h,(iy+0)            ; bch = -iy (sign, hi, lo)
 171+ 00FF FD 4E 01                             ld      c,(iy+1)            ; .
 172+ 0102 FD 7E 02                             ld      a,(iy+2)            ; .
 173+ 0105 EE 80                                xor     SignOnly8Bit        ; . this is where we flip sign to make add subtract
 174+ 0107 47                                   ld      b,a                 ; .
 175+ 0108 FD E5                                push    iy                  ; save iy as add function changes is
 176+ 010A CD 14 01                             call    AddBCHtoDELsigned   ; perform del += bch which as we flipped bch sign means (ix [210] -= iy [210])
 177+ 010D FD E1                                pop     iy                  ; get iy back
 178+ 010F C9                                   ret
 179+ 0110              ;------------------------------------------------------------
 180+ 0110              ;tested mathstestsun2
 181+ 0110              ; DEL = DEL - BCH signed, uses BC, DE, HL, IY, A
 182+ 0110              ; Just flips sign on b then performs add
 183+ 0110 78           SubBCHfromDELsigned:    ld      a,b
 184+ 0111 EE 80                                xor     SignOnly8Bit
 185+ 0113 47                                   ld      b,a
 186+ 0114              ; DEL = DEL + BCH signed, uses BC, DE, HL, IY, A
 187+ 0114 78           AddBCHtoDELsigned:      ld      a,b                 ; Are the values both the same sign?
 188+ 0115 AA                                   xor     d                   ; .
 189+ 0116 E6 80                                and     SignOnly8Bit        ; .
 190+ 0118 20 19                                jr      nz,.SignDifferent   ; .
 191+ 011A 78           .SignSame:              ld      a,b                 ; if they are then we only need 1 signe
 192+ 011B E6 80                                and     SignOnly8Bit        ; so store it in iyh
 193+ 011D FD 67                                ld      iyh,a               ;
 194+ 011F 78                                   ld      a,b                 ; bch = abs bch
 195+ 0120 E6 7F                                and     SignMask8Bit        ; .
 196+ 0122 47                                   ld      b,a                 ; .
 197+ 0123 7A                                   ld      a,d                 ; del = abs del
 198+ 0124 E6 7F                                and     SignMask8Bit        ; .
 199+ 0126 57                                   ld      d,a                 ; .
 200+ 0127 7C                                   ld      a,h                 ; l = h + l
 201+ 0128 85                                   add     l                   ; .
 202+ 0129 6F                                   ld      l,a                 ; .
 203+ 012A 79                                   ld      a,c                 ; e = e + c + carry
 204+ 012B 8B                                   adc     e                   ; .
 205+ 012C 5F                                   ld      e,a                 ; .
 206+ 012D 78                                   ld      a,b                 ; d = b + d + carry (signed)
 207+ 012E 8A                                   adc     d                   ;
 208+ 012F FD B4                                or      iyh                 ; d = or back in sign bit
 209+ 0131 57                                   ld      d,a                 ;
 210+ 0132 C9                                   ret                         ; done
 211+ 0133 78           .SignDifferent:         ld      a,b                 ; bch = abs bch
 212+ 0134 FD 67                                ld      iyh,a               ; iyh = b sign
 213+ 0136 E6 7F                                and     SignMask8Bit        ; .
 214+ 0138 47                                   ld      b,a                 ; .
 215+ 0139 7A                                   ld      a,d                 ; del = abs del
 216+ 013A FD 6F                                ld      iyl,a               ; iyl = d sign
 217+ 013C E6 7F                                and     SignMask8Bit        ; .
 218+ 013E 57                                   ld      d,a                 ; .
 219+ 013F E5                                   push    hl                  ; save hl
 220+ 0140 60 69                                ld      hl,bc               ; hl = bc - de, if bc < de then there is a carry
 221+ 0142 ED 52                                sbc     hl,de               ;
 222+ 0144 E1                                   pop     hl                  ;
 223+ 0145 38 0E                                jr      c,.BCHltDEL
 224+ 0147 20 1C                                jr      nz,.DELltBCH        ; if the result was not zero then DEL > BCH
 225+ 0149 7C           .BCeqDE:                ld      a,h                 ; if the result was zero then check lowest bits
 226+ 014A                                      JumpIfALTNusng l,.BCHltDEL
 226+ 014A BD          >                        cp      l
 226+ 014B DA 55 01    >                        jp		c, .BCHltDEL
 227+ 014E 20 15                                jr      nz,.DELltBCH
 228+ 0150              ; The same so its just zero
 229+ 0150 AF           .BCHeqDEL:              xor     a                  ; its just zero
 230+ 0151 57                                   ld      d,a                ; .
 231+ 0152 5F                                   ld      e,a                ; .
 232+ 0153 6F                                   ld      l,a                ; .
 233+ 0154 C9                                   ret                        ; .
 234+ 0155              ;BCH is less than DEL so its DEL - BCH the sort out sign
 235+ 0155 7D           .BCHltDEL:              ld      a,l                ; l = l - h                      ; ex
 236+ 0156 94                                   sub     h                  ; .                              ;   01D70F DEL
 237+ 0157 6F                                   ld      l,a                ; .                              ;  -000028 BCH
 238+ 0158 7B                                   ld      a,e                ; e = e - c - carry              ;1.
 239+ 0159 99                                   sbc     c                  ; .                              ;
 240+ 015A 5F                                   ld      e,a                ; .                              ;
 241+ 015B 7A                                   ld      a,d                ; d = d - b - carry              ;
 242+ 015C 98                                   sbc     b                  ; .                              ;
 243+ 015D 57                                   ld      d,a                ; .                              ;
 244+ 015E FD 7D                                ld      a,iyl              ; as d was larger, take d sign
 245+ 0160 E6 80                                and     SignOnly8Bit       ;
 246+ 0162 B2                                   or      d                  ;
 247+ 0163 57                                   ld      d,a                ;
 248+ 0164 C9                                   ret
 249+ 0165 7C           .DELltBCH:              ld      a,h                ; l = h - l
 250+ 0166 95                                   sub     l                  ;
 251+ 0167 6F                                   ld      l,a                ;
 252+ 0168 79                                   ld      a,c                ; e = c - e - carry
 253+ 0169 9B                                   sbc     e                  ;
 254+ 016A 5F                                   ld      e,a                ;
 255+ 016B 78                                   ld      a,b                ; d = b - d - carry
 256+ 016C 9A                                   sbc     d                  ;
 257+ 016D 57                                   ld      d,a                ;
 258+ 016E FD 7C                                ld      a,iyh              ; as b was larger, take b sign into d
 259+ 0170 E6 80                                and     SignOnly8Bit       ;
 260+ 0172 B2                                   or      d                  ;
 261+ 0173 57                                   ld      d,a                ;
 262+ 0174 C9                                   ret
 263+ 0175              ;-----------------------------------------------------------------------------------------------------------
 264+ 0175              ; Subtract Functions
 265+ 0175              ;...subtract routines
 266+ 0175              ; we could cheat, flip the sign of DE and just add but its not very optimised
 267+ 0175 7C           subHLDES15:             ld      a,h
 268+ 0176 E6 80                                and     SignOnly8Bit
 269+ 0178 47                                   ld      b,a                         ;save sign bit in b
 270+ 0179 AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
 271+ 017A                                      JumpIfNegative .SUBHLDEOppSGN        ;Signs are opposite therefore we can add
 271+ 017A FA A8 01    >                        jp		m, .SUBHLDEOppSGN
 272+ 017D 78           .SUBHLDESameSigns:      ld      a,b
 273+ 017E B2                                   or      d
 274+ 017F                                      JumpIfNegative .SUBHLDESameNeg       ; optimisation so we can just do simple add if both positive
 274+ 017F FA 89 01    >                        jp		m, .SUBHLDESameNeg
 275+ 0182                                      ClearCarryFlag
 275+ 0182 B7          >                        or a
 276+ 0183 ED 52                                sbc     hl,de
 277+ 0185                                      JumpIfNegative .SUBHLDESameOvrFlw
 277+ 0185 FA 9C 01    >                        jp		m, .SUBHLDESameOvrFlw
 278+ 0188 C9                                   ret
 279+ 0189 7C           .SUBHLDESameNeg:        ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 280+ 018A E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 281+ 018C 67                                   ld      h,a
 282+ 018D 7A                                   ld      a,d
 283+ 018E E6 7F                                and     SignMask8Bit
 284+ 0190 57                                   ld      d,a
 285+ 0191                                      ClearCarryFlag
 285+ 0191 B7          >                        or a
 286+ 0192 ED 52                                sbc     hl,de
 287+ 0194                                      JumpIfNegative .SUBHLDESameOvrFlw
 287+ 0194 FA 9C 01    >                        jp		m, .SUBHLDESameOvrFlw
 288+ 0197                                                          DISPLAY "TODO:  don't bother with overflow for now"
 289+ 0197 7C                                   ld      a,h                         ; now set bit for negative value, we won't bother with overflow for now TODO
 290+ 0198 F6 80                                or      SignOnly8Bit
 291+ 019A 67                                   ld      h,a
 292+ 019B C9                                   ret
 293+ 019C              .SUBHLDESameOvrFlw:     NegHL
 293+ 019C AF          >                    xor a
 293+ 019D 95          >                    sub l
 293+ 019E 6F          >                    ld l,a
 293+ 019F 9F          >                    sbc a,a
 293+ 01A0 94          >                    sub h
 293+ 01A1 67          >                    ld h,a
 294+ 01A2 78                                   ld      a,b
 295+ 01A3 EE 80                                xor     SignOnly8Bit                ; flip sign bit
 296+ 01A5 B4                                   or      h
 297+ 01A6 67                                   ld      h,a                         ; recover sign
 298+ 01A7 C9                                   ret
 299+ 01A8 B7           .SUBHLDEOppSGN:         or      a
 300+ 01A9 7C                                   ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 301+ 01AA E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 302+ 01AC 67                                   ld      h,a
 303+ 01AD 7A                                   ld      a,d
 304+ 01AE E6 7F                                and     SignMask8Bit
 305+ 01B0 57                                   ld      d,a
 306+ 01B1 19                                   add     hl,de
 307+ 01B2 78                                   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
 308+ 01B3 B4                                   or      h
 309+ 01B4 67                                   ld      h,a                         ; set the previou sign value
 310+ 01B5 C9                                   ret
 311+ 01B6              ;------------------------------------------------------------------------------------------------
 312+ 01B6              ;-- checks to see if a postition is in range of another, e.g. missile hit
 313+ 01B6              ;-- ix = ship position    - pointer to xyz vector as 3 bytes per element
 314+ 01B6              ;-- oy = misisle position - pointer to xyz vector as 3 bytes per element
 315+ 01B6              ;-- sets carry if in blast range, else not carry
 316+ 01B6              ;-- blast range will always be an 8 bit value
 317+ 01B6              CheckInCollisionRange:
 318+ 01B6 CD F3 00     .CheckXDistance:        call    SubDELequAtIXMinusAtIY24Signed ; get distance between x coordinates
 319+ 01B9 7A                                   ld      a,d                 ; check abs distance
 320+ 01BA E6 7F                                and     SignMask8Bit        ; if high bytes are set
 321+ 01BC B3                                   or      e                   ; then no hit
 322+ 01BD C2 FC 01                             jp      nz,.NoCollision     ; if high bytes are set no collision
 323+ 01C0 7D                                   ld      a,l
 324+ 01C1                                      JumpIfAGTEMemusng  CurrentMissileBlastRange ,.NoCollision
 324+ 01C1 21 1B 68    >                        ld      hl,CurrentMissileBlastRange
 324+ 01C4 BE          >                        cp      (hl)
 324+ 01C5 D2 FC 01    >                        jp		nc,.NoCollision
 325+ 01C8 01 03 00     .CheckYDistance:        ld      bc,3                ; move ix and iy
 326+ 01CB DD 09                                add     ix,bc               ; on 3 bytes
 327+ 01CD FD 09                                add     iy,bc               ;
 328+ 01CF CD F3 00                             call    SubDELequAtIXMinusAtIY24Signed ; get distance between x coordinates
 329+ 01D2 7A                                   ld      a,d                 ; check abs distance
 330+ 01D3 E6 7F                                and     SignMask8Bit        ; if high bytes are set
 331+ 01D5 B3                                   or      e                   ; then no hit
 332+ 01D6 C2 FC 01                             jp      nz,.NoCollision     ; if high bytes are set no collision
 333+ 01D9 7D                                   ld      a,l
 334+ 01DA                                      JumpIfAGTEMemusng  CurrentMissileBlastRange ,.NoCollision
 334+ 01DA 21 1B 68    >                        ld      hl,CurrentMissileBlastRange
 334+ 01DD BE          >                        cp      (hl)
 334+ 01DE D2 FC 01    >                        jp		nc,.NoCollision
 335+ 01E1 01 03 00     .CheckZDistance:        ld      bc,3                ; move ix and iy
 336+ 01E4 DD 09                                add     ix,bc               ; on 3 bytes
 337+ 01E6 FD 09                                add     iy,bc               ;
 338+ 01E8 CD F3 00                             call    SubDELequAtIXMinusAtIY24Signed ; get distance between x coordinates
 339+ 01EB 7A                                   ld      a,d                 ; check abs distance
 340+ 01EC E6 7F                                and     SignMask8Bit        ; if high bytes are set
 341+ 01EE B3                                   or      e                   ; then no hit
 342+ 01EF C2 FC 01                             jp      nz,.NoCollision     ; if high bytes are set no collision
 343+ 01F2 7D                                   ld      a,l
 344+ 01F3                                      JumpIfAGTEMemusng  CurrentMissileBlastRange ,.NoCollision
 344+ 01F3 21 1B 68    >                        ld      hl,CurrentMissileBlastRange
 344+ 01F6 BE          >                        cp      (hl)
 344+ 01F7 D2 FC 01    >                        jp		nc,.NoCollision
 345+ 01FA              .CollisionDetected:     SetCarryFlag                ; collision in blast range
 345+ 01FA 37          >                        scf
 346+ 01FB C9                                   ret
 347+ 01FC              .NoCollision:           ClearCarryFlag              ; no collision in blast range
 347+ 01FC B7          >                        or a
 348+ 01FD C9                                   ret
 349+ 01FE
 350+ 01FE              ;------------------------------------------------------------------------------------------------
 351+ 01FE              ; -- Checks if 24 bit value at ix > iy and returns ix pointing to the correct value
 352+ 01FE              ; -- Sets carryflag if a swap occured as part of the Jump If A LessThan check
 353+ 01FE FD 7E 02     CompareAtIXtoIYABS:     ld      a,(iy+2)
 354+ 0201 E6 7F        .CheckSignByte:         and     SignMask8Bit
 355+ 0203 47                                   ld      b,a
 356+ 0204 DD 7E 02                             ld      a,(ix+2)
 357+ 0207 E6 7F                                and     SignMask8Bit
 358+ 0209                                      JumpIfALTNusng b,.SwapIXIY
 358+ 0209 B8          >                        cp      b
 358+ 020A DA 22 02    >                        jp		c, .SwapIXIY
 359+ 020D DD 7E 01     .CheckHighByte:         ld      a,(ix+1)
 360+ 0210 FD BE 01                             cp      (iy+1)
 361+ 0213                                      JumpIfALTNusng b,.SwapIXIY
 361+ 0213 B8          >                        cp      b
 361+ 0214 DA 22 02    >                        jp		c, .SwapIXIY
 362+ 0217 DD 7E 00     .CheckLowByte:          ld      a,(ix+0)
 363+ 021A FD BE 00                             cp      (iy+0)
 364+ 021D                                      JumpIfALTNusng b,.SwapIXIY
 364+ 021D B8          >                        cp      b
 364+ 021E DA 22 02    >                        jp		c, .SwapIXIY
 365+ 0221 C9                                   ret
 366+ 0222 DD E5        .SwapIXIY               push    ix                  ; swap over ix and iy
 367+ 0224 FD E5                                push    iy                  ; this means that ix is always larger of two or ix if they are the same value
 368+ 0226 DD E1                                pop     ix                  ; iy is a smaller of the two values, or untouched in the same value
 369+ 0228 FD E1                                pop     iy                  ; Thsi means we can do a compare and pick which one we preferr after, carry says if swap occured if we need that
 370+ 022A C9                                   ret
 371+ 022B              ;------------------------------------------------------------------------------------------------
 372+ 022B              ; -- Manhattan distance
 373+ 022B              ; -- very quick distance calculation based on a cube
 374+ 022B              ; -- ix = pointer to vector of 3x3, iy = distance to check
 375+ 022B              ; simploy done by ABS (ix)
 376+ 022B              ; returns z if outside box, nz if inside box
 377+ 022B DD 6E 00     ManhattanDistanceIXIY:  ld      l,(ix+0)            ; del = abs ix (sign hi lo)
 378+ 022E DD 5E 01     .checkX:                ld      e,(ix+1)            ; .
 379+ 0231 DD 7E 02                             ld      a,(ix+2)            ; .
 380+ 0234 E6 7F                                and     SignMask8Bit        ;
 381+ 0236 57                                   ld      d,a                 ;
 382+ 0237 FD 66 00                             ld      h,(iy+0)            ; bch = distiance to check
 383+ 023A FD 4E 01                             ld      c,(iy+1)            ; .
 384+ 023D FD 7E 02                             ld      a,(iy+2)            ; .
 385+ 0240 EE 80                                xor     SignOnly8Bit        ; . this is where we flip sign to make add subtract
 386+ 0242 47                                   ld      b,a                 ; .
 387+ 0243 C5 E5                                push    bc,,hl              ; save this for 2nd and 3rd test
 388+ 0245 FD E5                                push    iy                  ; save iy as add function changes is
 389+ 0247 CD 14 01                             call    AddBCHtoDELsigned   ; perform del += bch which as we flipped bch sign means (ix [210] -= iy [210])
 390+ 024A FD E1                                pop     iy                  ; get iy back
 391+ 024C 7A                                   ld      a,d
 392+ 024D E6 80                                and     SignOnly8Bit
 393+ 024F CA 88 02                             jp      z,.ClearUp          ; so if its positive then outside boundary
 394+ 0252 E1 C1        .checkY:                pop     bc,,hl
 395+ 0254 C5 E5                                push    bc,,hl
 396+ 0256 DD 6E 03                             ld      l,(ix+3)            ; del = abs ix (sign hi lo)
 397+ 0259 DD 5E 04                             ld      e,(ix+4)            ; .
 398+ 025C DD 7E 05                             ld      a,(ix+5)            ; .
 399+ 025F E6 7F                                and     SignMask8Bit        ;
 400+ 0261 57                                   ld      d,a                 ;
 401+ 0262 FD E5                                push    iy                  ; save iy as add function changes is
 402+ 0264 CD 14 01                             call    AddBCHtoDELsigned   ; perform del += bch which as we flipped bch sign means (ix [210] -= iy [210])
 403+ 0267 FD E1                                pop     iy                  ; get iy back
 404+ 0269 7A                                   ld      a,d
 405+ 026A E6 80                                and     SignOnly8Bit
 406+ 026C CA 88 02                             jp      z,.ClearUp          ; so if its positive then outside boundary
 407+ 026F E1 C1        .checkZ:                pop     bc,,hl
 408+ 0271 DD 6E 06                             ld      l,(ix+6)            ; del = abs ix (sign hi lo)
 409+ 0274 DD 5E 07                             ld      e,(ix+7)            ; .
 410+ 0277 DD 7E 08                             ld      a,(ix+8)            ; .
 411+ 027A E6 7F                                and     SignMask8Bit        ;
 412+ 027C 57                                   ld      d,a                 ;
 413+ 027D FD E5                                push    iy                  ; save iy as add function changes is
 414+ 027F CD 14 01                             call    AddBCHtoDELsigned   ; perform del += bch which as we flipped bch sign means (ix [210] -= iy [210])
 415+ 0282 FD E1                                pop     iy                  ; get iy back
 416+ 0284 7A                                   ld      a,d
 417+ 0285 E6 80                                and     SignOnly8Bit
 418+ 0287 C9                                   ret
 419+ 0288 E1 C1        .ClearUp:               pop     bc,,hl
 420+ 028A C9                                   ret
 421+ 028B
 422+ 028B
 423+ 028B              ;------------------------------------------------------------
 424+ 028B              ; Note vectors are 2 byte lead sign, angle is 8 bit lead sign
 425+ 028B              ApplyMyAngleAToIXIY:    ;break
 426+ 028B F5                                   push    af                          ; save angle
 427+ 028C              ; Calculate Angle * vector /256, i.e take angle and mutiple by high byte of vector
 428+ 028C 5F           .processVector1:        ld      e,a                         ; e = angle
 429+ 028D DD 56 01                             ld      d,(ix+1)                    ; d = vector 1 / 256
 430+ 0290 CD 51 6B                             call    DEequDmulEs               ; calcualte DE = Vector * angle /256
 431+ 0293 FD 6E 00 FD                          ld      hl,(iy+0)                   ; hl = vector 2
 431+ 0297 66 01
 432+ 0299 CD 00 00                             call    SubDEfromHLSigned           ; hl = vector 2 - (vector 1 * angle / 256)
 433+ 029C FD 75 00 FD                          ld      (iy+0),hl                   ; .
 433+ 02A0 74 01
 434+ 02A2 F1           .processVector2:        pop     af
 435+ 02A3 5F                                   ld      e,a                         ; e = angle
 436+ 02A4 FD 56 01                             ld      d,(iy+1)                    ; d = vector 2 / 256
 437+ 02A7 CD 51 6B                             call    DEequDmulEs               ; de = vector 2 * angle /256
 438+ 02AA DD 6E 00 DD                          ld      hl,(ix+0)                   ; hl = vector 1
 438+ 02AE 66 01
 439+ 02B0 CD 04 00                             call    AddDEtoHLSigned             ; hl = hl + de
 440+ 02B3 DD 75 00 DD                          ld      (ix+0),hl                   ; .
 440+ 02B7 74 01
 441+ 02B9 C9                                   ret
 442+ 02BA              ;------------------------------------------------------------
 443+ 02BA              ; Applies Roll Alpha and Pitch Beta to vector at IX
 444+ 02BA              ApplyRollAndPitchToIX:
 445+ 02BA              ;-- y Vector = y - alpha * nosev_x_hi
 446+ 02BA DD 5E 01                             ld      e,(ix+1)                    ; e = X component hi
 447+ 02BD 3A 1E 66                             ld      a,(ALPHA)                   ; alpha S7
 448+ 02C0 57                                   ld      d,a
 449+ 02C1 CD 51 6B                             call    DEequDmulEs               ; d = X Vector * alpha / 256
 450+ 02C4 DD 6E 02                             ld      l,(ix+2)                    ; hl = Y Vector component
 451+ 02C7 DD 66 03                             ld      h,(ix+3)                    ;
 452+ 02CA CD 00 00                             call    SubDEfromHLSigned           ; hl = Y - (alpha * nosev x hi)
 453+ 02CD DD 75 02                             ld      (ix+2),l                    ; dont round Y up yet
 454+ 02D0 DD 74 03                             ld      (ix+3),h
 455+ 02D3              ;-- x Vector = x Vector + alpha * y_hi
 456+ 02D3 DD 5E 03                             ld      e,(ix+3)                    ; e = y component hi
 457+ 02D6 3A 1E 66                             ld      a,(ALPHA)                   ; alpha S7
 458+ 02D9 57                                   ld      d,a
 459+ 02DA CD 51 6B                             call    DEequDmulEs               ; d = y Vector * alpha / 256
 460+ 02DD DD 6E 00                             ld      l,(ix+0)                    ; hl = x Vector component
 461+ 02E0 DD 66 01                             ld      h,(ix+1)                    ;
 462+ 02E3 CD 04 00                             call    AddDEtoHLSigned             ; hl = x + (alpha * nosev x hi)
 463+ 02E6                                  IFDEF ROUND_ROLL_AND_PITCH
 464+ 02E6 ~                                    ld      l,0                         ; round up x
 465+ 02E6                                  ENDIF
 466+ 02E6 DD 75 00                             ld      (ix+0),l
 467+ 02E9 DD 74 01                             ld      (ix+1),h
 468+ 02EC              ;-- nosev_y = nosev_y - beta * nosev_z_hi
 469+ 02EC DD 5E 05                             ld      e,(ix+5)                    ; e = z component hi
 470+ 02EF 3A 11 66                             ld      a,(BETA)                    ; beta S7
 471+ 02F2 57                                   ld      d,a
 472+ 02F3 CD 51 6B                             call    DEequDmulEs               ; d = Z Vector * beta / 256
 473+ 02F6 DD 6E 02                             ld      l,(ix+2)                    ; hl = y Vector component
 474+ 02F9 DD 66 03                             ld      h,(ix+3)                    ;
 475+ 02FC CD 00 00                             call    SubDEfromHLSigned           ; hl = Y - (beta * nosev z hi)
 476+ 02FF                                  IFDEF ROUND_ROLL_AND_PITCH
 477+ 02FF ~                                    ld      l,0                         ; round up Y
 478+ 02FF                                  ENDIF
 479+ 02FF DD 75 02                             ld      (ix+2),l
 480+ 0302 DD 74 03                             ld      (ix+3),h
 481+ 0305              ;-- nosev_z = nosev_z + beta * nosev_y_hi
 482+ 0305 DD 5E 03                             ld      e,(ix+3)                    ; e = y component hi
 483+ 0308 3A 11 66                             ld      a,(BETA)                    ; beta S7
 484+ 030B 57                                   ld      d,a
 485+ 030C CD 51 6B                             call    DEequDmulEs               ; d = y Vector * beta / 256
 486+ 030F DD 6E 04                             ld      l,(ix+4)                    ; hl = z Vector component
 487+ 0312 DD 66 05                             ld      h,(ix+5)                    ;
 488+ 0315 CD 04 00                             call    AddDEtoHLSigned             ; hl = z + (beta * nosev z hi)
 489+ 0318                                  IFDEF ROUND_ROLL_AND_PITCH
 490+ 0318 ~                                    ld      l,0                         ; round up zwd
 491+ 0318                                  ENDIF
 492+ 0318 DD 75 04                             ld      (ix+4),l
 493+ 031B DD 74 05                             ld      (ix+5),h
 494+ 031E C9                                   ret
 495+ 031F              ;------------------------------------------------------------
 496+ 031F              ; Calculates the following:
 497+ 031F              ; loads UBnKTargetVector from UBnkPostion to IY as IY - position
 498+ 031F DD 21 20 C0  VectorUnivtoIY:     ld      ix,UBnKxlo                      ; target x = iy [x] - Univ XPos
 499+ 0323 CD F3 00                         call    SubDELequAtIXMinusAtIY24Signed  ; .
 500+ 0326 7D                               ld      a,l                             ; .
 501+ 0327 32 47 C0                         ld      (UBnKTargetXPos),a              ; .
 502+ 032A ED 53 48 C0                      ld      (UBnKTargetXPos+1),de           ; .
 503+ 032E DD 21 23 C0                      ld      ix,UBnKylo                      ; move to y component
 504+ 0332 01 03 00                         ld      bc,3                            ; .
 505+ 0335 FD 09                            add     iy,bc                           ; .
 506+ 0337 CD F3 00                         call    SubDELequAtIXMinusAtIY24Signed  ; target y = iy [y] - Univ YPos
 507+ 033A 7D                               ld      a,l                             ; .
 508+ 033B 32 4A C0                         ld      (UBnKTargetYPos),a              ; .
 509+ 033E ED 53 4B C0                      ld      (UBnKTargetYPos+1),de           ; .
 510+ 0342 DD 21 26 C0                      ld      ix,UBnKzlo                      ; move to y component
 511+ 0346 01 03 00                         ld      bc,3                            ; move to z component
 512+ 0349 FD 09                            add     iy,bc                           ; .
 513+ 034B CD F3 00                         call    SubDELequAtIXMinusAtIY24Signed  ; target z = iy [z] - Univ ZPos
 514+ 034E 7D                               ld      a,l                             ; .
 515+ 034F 32 4D C0                         ld      (UBnKTargetZPos),a              ; .
 516+ 0352 ED 53 4E C0                      ld      (UBnKTargetZPos+1),de           ; .
 517+ 0356 C9                               ret
 518+ 0357              ;------------------------------------------------------------
 519+ 0357              ; Takes the UBnKTarget position and works out if its ready for a docking routine or jump
 520+ 0357              ; returns carry flag if move to docking else leaves carry unset
 521+ 0357              UnivDistanceToTarget:DISPLAY "TODO : WRITE CODE FOR UnivDistanceToTarget"
 522+ 0357                                  ClearCarryFlag                              ; for now clear carry flag so its not at target
 522+ 0357 B7          >                        or a
 523+ 0358 C9                               ret
 524+ 0359              ;------------------------------------------------------------
 525+ 0359              ; Takes the UBnKTarget position and works out if its ready for a docking routine or jump
 526+ 0359
 527+ 0359
 528+ 0359                      IFNDEF  DEBUG_NO_TACTICS_CODE
 529+ 0359 ~
 530+ 0359 ~            TacticsVarResult        DW 0
 531+ 0359 ~            TacticsDotRoofv:        ld      hl,UBnkrotmatRoofvX
 532+ 0359 ~                                    jp      TacticsDotHL
 533+ 0359 ~
 534+ 0359 ~            TacticsDotSidev:        ld      hl,UBnkrotmatSidevX
 535+ 0359 ~                                    jp      TacticsDotHL
 536+ 0359 ~
 537+ 0359 ~            TacticsDotNosev:        call    CopyRotNoseToUBnKTacticsMat
 538+ 0359 ~            TacticsDotHL:           ld      hl,UBnKTacticsRotMatX; UBnkTransmatNosevX    ; ROTMATX HI
 539+ 0359 ~            .CalcXValue:            ld      a,(hl)                              ; DE = RotMatX & Vect X
 540+ 0359 ~                                    ld      e,a                                 ; .
 541+ 0359 ~                                    ld      a,(UBnKTargetVectorX)                  ; .
 542+ 0359 ~                                    ld      d,a                                 ; .
 543+ 0359 ~                                    mul                                         ; .
 544+ 0359 ~                                    ld      a,d                                 ; S = A = Hi (RotMatX & Vect X)
 545+ 0359 ~                                    ld      (varS),a                            ; .
 546+ 0359 ~                                    inc     hl                                  ; move to sign byte
 547+ 0359 ~            .CalcXSign:             ld      a,(UBnKTargetVectorX+2)                ; B  = A = Sign VecX xor sign RotMatX
 548+ 0359 ~                                    xor     (hl)                                ; .
 549+ 0359 ~                                    ld      b,a                                 ; .
 550+ 0359 ~            .MoveToY:               inc     hl                                  ; Move on to Y component
 551+ 0359 ~            .CalcYValue:            ld      a,(hl)                              ; D = 0, E = Hi (RotMatY & Vect Y)
 552+ 0359 ~                                    ld      e,a                                 ; .
 553+ 0359 ~                                    ld      a,(UBnKTargetVectorY)                  ; .
 554+ 0359 ~                                    ld      d,a                                 ; .
 555+ 0359 ~                                    mul     de                                  ; .
 556+ 0359 ~                                    ld      e,d                                 ; .
 557+ 0359 ~                                    ld      d,0                                 ; .
 558+ 0359 ~                                    inc     hl                                  ; move to sign byte
 559+ 0359 ~            .CalcYSign:             ld      a,(UBnKTargetVectorY+2)                ; c = sign of y_sign * sidev_y
 560+ 0359 ~                                    xor     (hl)                                ;
 561+ 0359 ~                                    ld      c,a                                 ;
 562+ 0359 ~            .MoveToZ:               inc     hl                                  ; Move on to Z component
 563+ 0359 ~            .AddXandY:              push    hl                                  ; but save HL as we need that
 564+ 0359 ~                                    ld      a,(varS)                            ; hl = Hi (RotMatX & Vect X) b= sign
 565+ 0359 ~                                    ld      h,0                                 ; de = Hi (RotMatY & Vect Y) c= sign
 566+ 0359 ~                                    ld      l,a                                 ;
 567+ 0359 ~                                    call    ADDHLDESignBC                       ; a(sign) hl = sum
 568+ 0359 ~                                    ld      b,a                                 ; b = sign of result
 569+ 0359 ~                                    ld      (TacticsVarResult),hl               ; save sub in TacticsVarResult
 570+ 0359 ~            .CalcZValue:            pop     hl                                  ; get back to the rotation mat z
 571+ 0359 ~                                    ld      a,(hl)                              ; D = 0, E = Hi (RotMatZ & Vect Z)
 572+ 0359 ~                                    ld      e,a                                 ; .
 573+ 0359 ~                                    ld      a,(UBnKTargetVectorZ)                  ; .
 574+ 0359 ~                                    ld      d,a                                 ; .
 575+ 0359 ~                                    mul     de                                  ; .
 576+ 0359 ~                                    ld      e,d                                 ; .
 577+ 0359 ~                                    ld      d,0                                 ; .
 578+ 0359 ~                                    inc     hl                                  ; move to sign byte
 579+ 0359 ~            .CalcZSign:             ld      a,(UBnKTargetVectorZ+2)
 580+ 0359 ~                                    xor     (hl)
 581+ 0359 ~                                    ld      c,a                                 ; Set C to the sign of z_sign * sidev_z
 582+ 0359 ~                                    ld      hl, (TacticsVarResult)              ; CHL = x + y, BDE = z products
 583+ 0359 ~                                    call    ADDHLDESignBC                       ; so AHL = X y z products
 584+ 0359 ~                                    ld      (varS),a                            ; for backwards compatibility
 585+ 0359 ~                                    ld      a,l                                  ; .
 586+ 0359 ~                                    ret
 587+ 0359 ~
 588+ 0359 ~            CopyRotSideToUBnKTacticsMat:ld      hl,UBnkrotmatSidevX+1
 589+ 0359 ~                                    jp      CopyRotmatToTacticsMat
 590+ 0359 ~
 591+ 0359 ~            CopyRotNoseToUBnKTacticsMat:ld      hl,UBnkrotmatNosevX+1
 592+ 0359 ~                                    jp      CopyRotmatToTacticsMat
 593+ 0359 ~
 594+ 0359 ~            CopyRotRoofToBnKTacticsMat:ld      hl,UBnkrotmatRoofvX+1
 595+ 0359 ~            ; Coy rotation matrix high byte to trans rot mat, strip off sign and separate to rotmat byte 2
 596+ 0359 ~            CopyRotmatToUBnKTacticsMat: ld      de,UBnKTacticsRotMatX
 597+ 0359 ~                                    ld      a,(hl)              ; matrix high byte of x
 598+ 0359 ~                                    ld      b,a
 599+ 0359 ~                                    and     SignMask8Bit
 600+ 0359 ~                                    ld      (de),a              ; set rot mat value
 601+ 0359 ~                                    inc     de
 602+ 0359 ~                                    ld      a,b
 603+ 0359 ~                                    and     SignOnly8Bit
 604+ 0359 ~                                    ld      (de),a              ; set rot mat sign
 605+ 0359 ~                                    inc     de                  ; move to next rot mat element
 606+ 0359 ~                                    inc     hl
 607+ 0359 ~                                    inc     hl                  ; matrix high byte of y
 608+ 0359 ~            .processYElement:       ld      a,(hl)              ; matrix high byte of y
 609+ 0359 ~                                    ld      b,a
 610+ 0359 ~                                    and     SignMask8Bit
 611+ 0359 ~                                    ld      (de),a              ; set rot mat value
 612+ 0359 ~                                    inc     de
 613+ 0359 ~                                    ld      a,b
 614+ 0359 ~                                    and     SignOnly8Bit
 615+ 0359 ~                                    ld      (de),a              ; set rot mat sign
 616+ 0359 ~                                    inc     de                  ; move to next rot mat element
 617+ 0359 ~                                    inc     hl
 618+ 0359 ~                                    inc     hl                  ; matrix high byte of z
 619+ 0359 ~            .ProcessZElement:       ld      a,(hl)              ; matrix high byte of z
 620+ 0359 ~                                    ld      b,a
 621+ 0359 ~                                    and     SignMask8Bit
 622+ 0359 ~                                    ld      (de),a              ; set rot mat value
 623+ 0359 ~                                    inc     de
 624+ 0359 ~                                    ld      a,b
 625+ 0359 ~                                    and     SignOnly8Bit
 626+ 0359 ~                                    ld      (de),a              ; set rot mat sign
 627+ 0359 ~                                    ret
 628+ 0359                      ENDIF
 629+ 0359
 630+ 0359
 631+ 0359
# file closed: ../../Maths/MathsBankedFns.asm
1006  0359                                  DISPLAY "Bank ",MathsBankedFnsAddr," - Bytes free ",/D, $2000 - ($-MathsBankedFnsAddr), " - BankMathsBankedAdd"
1007  0359                                  ASSERT $-MathsBankedFnsAddr <8912, Bank code leaks over 8K boundary
1008  0359
1009  0359                  SAVENEX OPEN "3DTest.nex", EliteNextStartup , TopOfStack
1010  0359                  SAVENEX CFG  0,0,0,1
1011  0359                  SAVENEX AUTO
1012  0359                  SAVENEX CLOSE
1013  0359                  DISPLAY "Main Non Banked Code End ", MainNonBankedCodeEnd , " Bytes free ", 0B000H - MainNonBankedCodeEnd
1014  0359                  ASSERT MainNonBankedCodeEnd < 0B000H, Program code leaks intot interrup vector table
1015  0359
# file closed: 3DTest.asm
