# file opened: piiotest.asm
  1   0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
  2   0000                              DISPLAY "Piio test"
  3   0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
  4   0000
  5   0000
  6   0000                  DEFINE DEBUGMODE 1
  7   0000                  DEVICE ZXSPECTRUMNEXT
  8   0000                  SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
  9   0000               CSPECTMAP piiotest.map
 10   0000               OPT --zxnext=cspect --syntax=a --reversepop
 11   0000                              DEFINE  SOUNDPACE 3
 12   0000              ;                DEFINE  ENABLE_SOUND 1
 13   0000                             DEFINE     MAIN_INTERRUPTENABLE 1
 14   0000              ;               DEFINE INTERRUPT_BLOCKER 1
 15   0000              DEBUGSEGSIZE   equ 1
 16   0000              DEBUGLOGSUMMARY equ 1
 17   0000              ;DEBUGLOGDETAIL equ 1
 18   0000
 19   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 20   0000              ; Game Defines
 21   0000              ScreenLocal      EQU 0
 22   0000              ScreenGalactic   EQU ScreenLocal + 1
 23   0000              ScreenMarket     EQU ScreenGalactic + 1
 24   0000              ScreenMarketDsp  EQU ScreenMarket + 1
 25   0000              ScreenStatus     EQU ScreenMarketDsp + 1
 26   0000              ScreenInvent     EQU ScreenStatus + 1
 27   0000              ScreenPlanet     EQU ScreenInvent + 1
 28   0000              ScreenEquip      EQU ScreenPlanet + 1
 29   0000              ScreenLaunch     EQU ScreenEquip + 1
 30   0000              ScreenFront      EQU ScreenLaunch + 1
 31   0000              ScreenAft        EQU ScreenFront+1
 32   0000              ScreenLeft       EQU ScreenAft+1
 33   0000              ScreenRight      EQU ScreenLeft+1
 34   0000              ScreenDocking    EQU ScreenRight+1
 35   0000              ScreenHyperspace EQU ScreenDocking+1
 36   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 37   0000              ; Colour Defines
 38   0000                  INCLUDE "../../Hardware/L2ColourDefines.asm"
# file opened: ../../Hardware/L2ColourDefines.asm
  1+  0000              L2ColourBLACK           EQU   0
  2+  0000              L2ColourRED_1           EQU 224                 ; RGB 255,  0,  0
  3+  0000              L2ColourRED_2           EQU 192                 ; RGB 218,  0,  0
  4+  0000              L2ColourRED_3           EQU 160                 ; RGB 182,  0,  0
  5+  0000              L2ColourRED_4           EQU 128                 ; RGB 145,  0,  0
  6+  0000              L2ColourRED_5           EQU  96                 ; RGB 109,  0,  0
  7+  0000              L2ColourRED_6           EQU  64                 ; RGB  72,  0,  0
  8+  0000              L2ColourRED_7           EQU  32                 ; RGB  36,  0,  0
  9+  0000              L2ColourYELLOW_1        EQU 252                 ; RGB 255,255,  0
 10+  0000              L2ColourYELLOW_2        EQU 216                 ; RGB 218,218,  0
 11+  0000              L2ColourYELLOW_3        EQU 180                 ; RGB 182,182,  0
 12+  0000              L2ColourYELLOW_4        EQU 144                 ; RGB 145,145,  0
 13+  0000              L2ColourYELLOW_5        EQU 108                 ; RGB 109.109,  0
 14+  0000              L2ColourYELLOW_6        EQU  72                 ; RGB  72, 72,  0
 15+  0000              L2ColourYELLOW_7        EQU  36                 ; RGB  36, 36,  0
 16+  0000              L2ColourGREEN_1		    EQU  28                 ; RGB   0,255,  0
 17+  0000              L2ColourGREEN_2		    EQU  24                 ; RGB   0,218,  0
 18+  0000              L2ColourGREEN_3		    EQU  16                 ; RGB   0,145,  0
 19+  0000              L2ColourGREEN_4         EQU  12                 ; RGB   0,109,  0
 20+  0000              L2ColourGREEN_5         EQU   8                 ; RGB   0, 72,  0
 21+  0000              L2ColourGREEN_6         EQU   4                 ; RGB   0, 36,  0
 22+  0000              L2ColourBLUE_1          EQU   3                 ; RGB 0,0,255
 23+  0000              L2ColourBLUE_2          EQU   2                 ; RGB 0,0,170
 24+  0000              L2ColourBLUE_3          EQU   1                 ; RGB 0,0,85
 25+  0000
 26+  0000
 27+  0000              L2ColourWHITE_1         EQU 255                 ; RGB 255,255,255
 28+  0000              L2ColourWHITE_2         EQU 146
 29+  0000              L2ColourGREY_1		    EQU L2ColourWHITE_2
 30+  0000              L2ColourGREY_2		    EQU 109
 31+  0000              L2ColourGREY_3		    EQU  73
 32+  0000              L2ColourGREY_4		    EQU  37
 33+  0000
 34+  0000              L2ColourGREEN_MB        EQU  29                 ;RGB 0,255,85
 35+  0000              L2ColourGREEN_MR        EQU 124                 ;RGB 109.255,0
 36+  0000              L2ColourCREAM_1         EQU 218                 ; RGB 218,218,170
 37+  0000              L2ColourCREAM_2         EQU 182                 ; RGB 182,182,170
 38+  0000              L2ColourCREAM_3         EQU 146                 ; RGB 145,145,170
 39+  0000
 40+  0000              L2ColourTRANSPARENT     EQU 227                 ; RGB 255,  0,255
 41+  0000              L2ColourMAGENTA_1       EQU 162                 ; RGB 182,  0,170
 42+  0000              L2ColourMAGENTA_2       EQU 130                 ; RGB 145,  0,170
 43+  0000              L2ColourMAGENTA_3       EQU  97                 ; RGB 109,  0, 85
 44+  0000              L2ColourMAGENTA_4       EQU  65                 ; RGB  72,  0, 85
 45+  0000              L2ColourORANGE_1        EQU 236                 ; RGB
 46+  0000              L2ColourORANGE_2        EQU 168                 ; RGB
 47+  0000              L2ColourORANGE_3        EQU  68                 ; RGB
 48+  0000              L2ColourCYAN_1          EQU  31                 ; RGB   0,255, 255
 49+  0000              L2ColourCYAN_2          EQU  18                 ; RGB
 50+  0000              L2ColourCYAN_3          EQU   9                 ; RGB
 51+  0000              L2ColourPURPLE_1        EQU 109                 ; RGB
 52+  0000              L2ColourPURPLE_2        EQU  66                 ; RGB
 53+  0000              L2ColourPURPLE_3        EQU  33                 ; RGB
 54+  0000              L2ColourPINK_1		    EQU 231                 ; RGB
 55+  0000              L2ColourPINK_2		    EQU 226                 ; RGB
 56+  0000              L2ColourPINK_3		    EQU 225                 ; RGB
 57+  0000              L2ColourPINK_4		    EQU 224                 ; RGB
 58+  0000
# file closed: ../../Hardware/L2ColourDefines.asm
 39   0000                  INCLUDE "../../Hardware/L1ColourDefines.asm"
# file opened: ../../Hardware/L1ColourDefines.asm
  1+  0000
  2+  0000              L1ColourInkBlack        EQU %00000000
  3+  0000              L1ColourInkBlue         EQU %00000001
  4+  0000              L1ColourInkRed          EQU %00000010
  5+  0000              L1ColourInkMagenta      EQU %00000011
  6+  0000              L1ColourInkGreen        EQU %00000100
  7+  0000              L1ColourInkCyan         EQU %00000101
  8+  0000              L1ColourInkYellow       EQU %00000110
  9+  0000              L1ColourInkWhite        EQU %00000111
 10+  0000              L1ColourPaperBlack      EQU %00000000
 11+  0000              L1ColourPaperBlue       EQU %00001000
 12+  0000              L1ColourPaperRed        EQU %00010000
 13+  0000              L1ColourPaperMagenta    EQU %00011000
 14+  0000              L1ColourPaperGreen      EQU %00100000
 15+  0000              L1ColourPaperCyan       EQU %00101000
 16+  0000              L1ColourPaperYellow     EQU %00110000
 17+  0000              L1ColourPaperWhite      EQU %00111000
 18+  0000              L1ColourFlash           EQU %10000000
 19+  0000              L1ColourBright          EQU %01000000
 20+  0000              ;----------------------------------------------------------------------------------------------------------------------------------
 21+  0000              ; Screen Specific Colour Defines
 22+  0000              L1InvHighlight          EQU L1ColourBright | L1ColourPaperRed   | L1ColourInkYellow
 23+  0000              L1InvLowlight           EQU                  L1ColourPaperBlack | L1ColourInkWhite
# file closed: ../../Hardware/L1ColourDefines.asm
 40   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 41   0000              ; Total screen list
 42   0000              ; Local Chart
 43   0000              ; Galactic Chart
 44   0000              ; Market Prices
 45   0000              ; Inventory
 46   0000              ; Comander status
 47   0000              ; System Data
 48   0000              ; Mission Briefing
 49   0000              ; missio completion
 50   0000              ; Docked  Menu (only place otehr than pause you can load and save)
 51   0000              ; Pause Menu (only place you can load from )
 52   0000              ; byint and selling equipment
 53   0000              ; bying and selling stock
 54   0000
 55   0000                                      INCLUDE "../../Hardware/register_defines.asm"
# file opened: ../../Hardware/register_defines.asm
  1+  0000              ; Peripheral 2
  2+  0000              ENABLE_CPU_SPEED_MODE                   EQU %10000000
  3+  0000              DIVERT_BEEP_ONLY                        EQU %01000000
  4+  0000              ENABLE_50_60_SWITCH                     EQU %00100000
  5+  0000              ENABLE_MMCAUTO_SWITCH                   EQU %00010000
  6+  0000              ENABLE_MULTIFACE_M1                     EQU %00001000
  7+  0000              PS2MODE_KEYBOARD                        EQU %00000000
  8+  0000              PS2MODE_MOUSE                           EQU %00000100
  9+  0000              AUDIO_CHIPMODE_YM                       EQU %00000000
 10+  0000              AUDIO_CHIPMODE_AY                       EQU %00000001
 11+  0000              AUDIO_CHIPMODE_DISABLED                 EQU %00000010
 12+  0000              INTERNAL_SPEAKER_ENABLE                 EQU %00010000
 13+  0000              ; Peripheral 3
 14+  0000              UNLOCK_PORT_7FFD_PAGING                 EQU %10000000
 15+  0000              DISABLE_RAM_IO_CONTENTION               EQU %01000000
 16+  0000              AY_STEREO_MODE_ACB                      EQU %00100000
 17+  0000              INTERNAL_SPEAKER                        EQU %00010000
 18+  0000              ENABLE_DACS                             EQU %00001000
 19+  0000              ENABLE_TIMEX_VIDEO_MODE                 EQU %00000100
 20+  0000              ENABLE_TURBO_SOUND                      EQU %00000010
 21+  0000              ENABLE_ISSUE2_KEYBOARD                  EQU %00000001
 22+  0000              ; Peripheral 4
 23+  0000              ENABLE_AY2_MONO                         EQU %10000000
 24+  0000              ENABLE_AY1_MONO                         EQU %01000000
 25+  0000              ENABLE_AY0_MONO                         EQU %00100000
 26+  0000              SPRITE_ID_LOCKSTEP                      EQU %00010000
 27+  0000              RESET_DIVMMC_MAPRAM                     EQU %00001000
 28+  0000              SILENCE_HDMI_AUDIO                      EQU %00000100
 29+  0000              SCALLINES_50PCT                         EQU %00000001
 30+  0000              SCANLINES_25PCT                         EQU %00000010
 31+  0000              SCANLINES_125PCT                        EQU %00000011
 32+  0000              ; Audio Registers
 33+  0000              CHANNEL_A_FINE                          EQU 0
 34+  0000              CHANNEL_A_COARSE                        EQU 1
 35+  0000              CHANNEL_B_FINE                          EQU 2
 36+  0000              CHANNEL_B_COARSE                        EQU 3
 37+  0000              CHANNEL_C_FINE                          EQU 4
 38+  0000              CHANNEL_C_COARSE                        EQU 5
 39+  0000              NOISE_PERIOD                            EQU 6
 40+  0000              TONE_ENABLE                             EQU 7
 41+  0000              CHANNEL_A_AMPLITUDE                     EQU 8
 42+  0000              CHANNEL_B_AMPLITUDE                     EQU 9
 43+  0000              CHANNEL_C_AMPLITUDE                     EQU 10
 44+  0000              ENVELOPE_PERIOD_FINE                    EQU 11
 45+  0000              ENVELOPE_PERIOD_COARSE                  EQU 12
 46+  0000              ENVELOPE_SHAPE                          EQU 13
 47+  0000
 48+  0000              ENVELOPE_HOLD_ON                        EQU 1
 49+  0000              ENVELOPE_ALTERNATE_ON                   EQU 2
 50+  0000              ENVELOPE_ATTACK_ON                      EQU 4
 51+  0000              ENVELOPE_CONTINUE_ON                    EQU 8
 52+  0000
 53+  0000              ENVELOPE_SHAPE_SINGLE_DECAY             EQU 0                                                                                    ; \____________
 54+  0000              ENVELOPE_SHAPE_SINGLE_ATTACK            EQU                        ENVELOPE_ATTACK_ON                                            ; /|___________
 55+  0000              ENVELOPE_SHAPE_REPEAT_DECAY             EQU ENVELOPE_CONTINUE_ON                                                                 ; \|\|\|\|\|\|\
 56+  0000              ENVELOPE_SHAPE_REPEAT_DECAY_ATTACK      EQU ENVELOPE_CONTINUE_ON |                      ENVELOPE_ALTERNATE_ON                    ; \/\/\/\/\/\/\
 57+  0000              ENVELOPE_SHAPE_SINGLE_DECAY_HOLD        EQU ENVELOPE_CONTINUE_ON |                      ENVELOPE_ALTERNATE_ON | ENVELOPE_HOLD_ON ; \|-----------
 58+  0000              ENVELOPE_SHAPE_REPEAT_ATTACK            EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON                                            ; /|/|/|/|/|/|/|
 59+  0000              ENVELOPE_SHAPE_SINGLE_ATTACK_HOLD       EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON |                         ENVELOPE_HOLD_ON ; /------------
 60+  0000              ENVELOPE_SHAPE_REPEAT_ATTACK_DECAY      EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON | ENVELOPE_ALTERNATE_ON                    ; /\/\/\/\/\/\/
 61+  0000
 62+  0000              ENVELOPE_HOLD                           EQU %00000001
 63+  0000              ENVELOPE_ALTERNATE                      EQU %00000010
 64+  0000              ENVELOPE_ATTACK                         EQU %00000010
 65+  0000              ENVELOPE_CONTINUE                       EQU %00000010
 66+  0000              ; Sound Control
 67+  0000              TONE_CHANNEL_A                          EQU %00000001
 68+  0000              TONE_CHANNEL_B                          EQU %00000010
 69+  0000              TONE_CHANNEL_C                          EQU %00000100
 70+  0000              NOISE_CHANNEL_A                         EQU %00001000
 71+  0000              NOISE_CHANNEL_B                         EQU %00010000
 72+  0000              NOISE_CHANNEL_C                         EQU %00100000
 73+  0000              ; Version for AND to enabled (its inverted)
 74+  0000              TONE_CHANNEL_A_ON                       EQU %11111110
 75+  0000              TONE_CHANNEL_B_ON                       EQU %11111101
 76+  0000              TONE_CHANNEL_C_ON                       EQU %11111011
 77+  0000              NOISE_CHANNEL_A_ON                      EQU %11110111
 78+  0000              NOISE_CHANNEL_B_ON                      EQU %11101111
 79+  0000              NOISE_CHANNEL_C_ON                      EQU %11011111
 80+  0000
 81+  0000              ; Turbo Sound Control
 82+  0000              TURBO_MANDATORY                         EQU %10011100
 83+  0000              TURBO_LEFT                              EQU %01000000
 84+  0000              TURBO_RIGHT                             EQU %00100000
 85+  0000              TURBO_CHIP_AY3                          EQU %00000011
 86+  0000              TURBO_CHIP_AY2                          EQU %00000010
 87+  0000              TURBO_CHIP_AY1                          EQU %00000001
 88+  0000
 89+  0000              IO_LAYER2_PORT                          EQU $123B
 90+  0000              IO_EXT_BANK_PORT 			            EQU $DFFD ; 57341
 91+  0000              IO_BANK_PORT                            EQU $7FFD ; 32765
 92+  0000              REGISTER_NUMBER_PORT					EQU $243B
 93+  0000              REGISTER_VALUE_PORT						EQU $253B
 94+  0000              SPRITE_SLOT_PORT						EQU $303B ; port for sprite and pattern index
 95+  0000              SPRITE_INFO_PORT                        EQU $0057
 96+  0000              SPRITE_PATTERN_UPLOAD_PORT				EQU $005B
 97+  0000              TURBO_SOUND_NEXT_CONTROL                EQU $FFFD
 98+  0000              SOUND_CHIP_REGISTER_WRITE               EQU $BFFD
 99+  0000              IO_KEYBOARD_PORT                        EQU $FE
100+  0000              IO_DATAGEAR_DMA_PORT 		            EQU $6B
101+  0000              UART_TX_PORT_PORT                       EQU $133B
102+  0000              UART_RX_PORT_PORT                       EQU $143B
103+  0000              UART_CONTROL_PORT                       EQU $153B
104+  0000              UART_FRAME_PORT                         EQU $163B
105+  0000              CTC_CHANNEL1_PORT                       EQU $183B
106+  0000              CTC_CHANNEL2_PORT                       EQU $193B
107+  0000              CTC_CHANNEL3_PORT                       EQU $1A3B
108+  0000              CTC_CHANNEL4_PORT                       EQU $1B3B
109+  0000              PLUS_3_MEMORY_PAGING_CONTROL_PORT       EQU $1FFD
110+  0000              MB02_DMA_PORT                           EQU $0B
111+  0000              SPECDRUM_DAC_OUTPUT                     EQU $DF
112+  0000
113+  0000              Speed_3_5MHZ                            EQU 0
114+  0000              Speed_7MHZ                              EQU 1
115+  0000              Speed_14MHZ                             EQU 2
116+  0000              Speed_28MHZ                             EQU 3
117+  0000
118+  0000
119+  0000              MACHINE_ID_REGISTER						EQU $00
120+  0000              VERSION_REGISTER						EQU $01
121+  0000              RESET_REGISTER		    				EQU $02
122+  0000              MACHINE_TYPE_REGISTER					EQU $03
123+  0000              PAGE_RAM_REGISTER						EQU $04
124+  0000              PERIPHERAL_1_REGISTER					EQU $05   ; Sets joystick mode, video frequency and Scandoubler
125+  0000              PERIPHERAL_2_REGISTER					EQU $06   ; Enables CPU Speed key, DivMMC, Multiface, Mouse and AY audio.
126+  0000              TURBO_MODE_REGISTER						EQU $07
127+  0000              PERIPHERAL_3_REGISTER					EQU $08   ; ABC/ACB Stereo, Internal Speaker, SpecDrum, Timex Video Modes, Turbo Sound Next, RAM contention and [un]lock 128k paging
128+  0000              PERIPHERAL_4_REGISTER                   EQU $09   ; Sets scanlines, AY mono output, Sprite-id lockstep, reset DivMMC mapram and disable HDMI audio
129+  0000              PERIPHERAL_5_REGISTER                   EQU $0A  ; Mouse
130+  0000              CORE_VERSION_REGISTER                   EQU $0E
131+  0000              ANTI_BRICK_SYSTEM_REGISTER				EQU $10
132+  0000              VIDEO_TIMING_REGISTER                   EQU $11
133+  0000              LAYER2_RAM_PAGE_REGISTER				EQU $12
134+  0000              LAYER2_RAM_SHADOW_REGISTER      		EQU $13
135+  0000              TRANSPARENCY_COLOUR_REGISTER			EQU $14
136+  0000              SPRITE_LAYERS_SYSTEM_REGISTER			EQU $15
137+  0000              LAYER2_OFFSET_X_REGISTER				EQU $16
138+  0000              LAYER2_OFFSET_Y_REGISTER				EQU $17
139+  0000              CLIP_WINDOW_LAYER2_REGISTER				EQU $18
140+  0000              CLIP_WINDOW_SPRITES_REGISTER			EQU $19
141+  0000              CLIP_WINDOW_ULA_REGISTER				EQU $1A
142+  0000              CLIP_WINDOW_TILEMAP_REGISTER            EQU $1B
143+  0000              CLIP_WINDOW_CONTROL_REGISTER			EQU $1C
144+  0000              ;29 not used
145+  0000              ACTIVE_VIDEO_LINE_MSB_REGISTER			EQU $1E
146+  0000              ACTIVE_VIDEO_LINE_LSB_REGISTER			EQU $1F
147+  0000              ; 32 to 34 not used
148+  0000              LINE_INTERRUPT_CONTROL_REGISTER			EQU $22
149+  0000              LINE_INTERRUPT_VALUE_LSB_REGISTER		EQU $23
150+  0000              ULA_X_OFFSET_REGISTER                   EQU $26
151+  0000              ULA_Y_OFFSET_REGSITER                   EQU $27
152+  0000              KEYMAP_HIGH_ADDRESS_REGISTER			EQU $28
153+  0000              KEYMAP_LOW_ADDRESS_REGISTER				EQU $29
154+  0000              KEYMAP_HIGH_DATA_REGISTER				EQU $2A
155+  0000              KEYMAP_LOW_DATA_REGISTER				EQU $2B
156+  0000              DAC_B_MIRROR_REGISTER                   EQU $2C
157+  0000              DAC_AB_MIRROR_REGISTER                  EQU $2D
158+  0000              DAC_C_MORROR_REGISTER                   EQU $2E
159+  0000              TILEMAP_OFFSET_XMSB_REGISTER            EQU $2F
160+  0000              TILEMAP_OFFSET_XLSB_REGISTER            EQU $30
161+  0000              TILEMAP_OFFSET_YMSB_REGISTER            EQU $31
162+  0000              LORES_OFFSET_X_REGISTER					EQU $32
163+  0000              LORES_OFFSET_Y_REGISTER					EQU $33
164+  0000              SPRITE_PORT_INDEX_REGISTER              EQU $34
165+  0000              SPRITE_PORT_ATTR0_REGISTER              EQU $35
166+  0000              SPRITE_PORT_ATTR1_REGISTER              EQU $36
167+  0000              SPRITE_PORT_ATTR2_REGISTER              EQU $37
168+  0000              SPRITE_PORT_ATTR3_REGISTER              EQU $38
169+  0000              SPRITE_PORT_ATTR4_REGISTER              EQU $39
170+  0000              PALETTE_INDEX_REGISTER					EQU $40
171+  0000              PALETTE_VALUE_8BIT_REGISTER				EQU $41
172+  0000              PALETTE_FORMAT_REGISTER					EQU $42
173+  0000              PALETTE_CONTROL_REGISTER				EQU $43
174+  0000              PALETTE_VALUE_9BIT_REGISTER				EQU $44
175+  0000              TRANSPARENCY_COLOUR_FALLBACK_REGISTER   EQU $4A
176+  0000              SPRITES_TRANSPARENCY_INDEX_REGISTER     EQU $4B
177+  0000              TILEMAP_TRANSPARENCY_INDEX_REGISTER     EQU $4C
178+  0000              ; 72 to 79 unused
179+  0000              MMU_SLOT_0_REGISTER						EQU $50
180+  0000              MMU_SLOT_1_REGISTER						EQU $51
181+  0000              MMU_SLOT_2_REGISTER						EQU $52
182+  0000              MMU_SLOT_3_REGISTER						EQU $53
183+  0000              MMU_SLOT_4_REGISTER						EQU $54
184+  0000              MMU_SLOT_5_REGISTER						EQU $55
185+  0000              MMU_SLOT_6_REGISTER						EQU $56
186+  0000              MMU_SLOT_7_REGISTER						EQU $57
187+  0000              ; 88 to 95 unused
188+  0000              COPPER_DATA_REGISTER					EQU $60
189+  0000              COPPER_CONTROL_LOW_REGISTER				EQU $61
190+  0000              COPPER_CONTROL_HIGH_REGISTER			EQU $62
191+  0000              COPPER_DATA_16BIT_WRITE_REGISTER        EQU $63
192+  0000              VERTICAL_VIDEO_LINE_OFFSET_REGISTER     EQU $64
193+  0000              ULA_CONTROL_REGISTER                    EQU $68
194+  0000              DISPLAY_CONTROL_1_REGISTER              EQU $69
195+  0000              LORES_CONTROL_REGISTER                  EQU $6A
196+  0000              TILEMAP_CONTROL_REGISTER                EQU $6B
197+  0000              DEFAULT_TILEMAP_ATTRIBUTE_REGISTER      EQU $6C
198+  0000              ; 109 unused
199+  0000              TILEMAP_BASE_ADDRESS_REGISTER           EQU $6E
200+  0000              TILE_DEFINITIONS_BASE_ADDRESS_REGISTER  EQU $6F
201+  0000              LAYER_2_CONTROL_REGISTER                EQU $70
202+  0000              LAYER_2_X_OFFSET_MSB_REGISTER           EQU $71
203+  0000              SPRITE_PORT_MIRROR_ATTRIBUTE_0_WITH_INC EQU $75
204+  0000              SPRITE_PORT_MIRROR_ATTRIBUTE_1_WITH_INC EQU $76
205+  0000              SPRITE_PORT_MIRROR_ATTRIBUTE_2_WITH_INC EQU $77
206+  0000              SPRITE_PORT_MIRROR_ATTRIBUTE_3_WITH_INC EQU $78
207+  0000              SPRITE_PORT_MIRROR_ATTRIBUTE_4_WITH_INC EQU $79
208+  0000              USER_STORAGE_0_REGISTER                 EQU $7F ; general purpose variable, e.g. for copper
209+  0000              EXPANSION_BUS_ENABLE_REGISTER           EQU $80
210+  0000              EXPANSION_BUS_CONTROL_REGISTER          EQU $81
211+  0000              INTERNAL_PORT_DECODING_B0_7_REGISTER    EQU $82
212+  0000              INTERNAL_PORT_DECODING_B8_15_REGISTER   EQU $83
213+  0000              INTERNAL_PORT_DECODING_B16_23_REGISTER  EQU $84
214+  0000              INTERNAL_PORT_DECODING_B24_31_REGISTER  EQU $85
215+  0000              EXPANSION_BUS_DECODING_B0_7_REGISTER    EQU $86
216+  0000              EXPANSION_BUS_DECODING_B8_15_REGISTER   EQU $87
217+  0000              EXPANSION_BUS_DECODING_B16_23_REGISTER  EQU $88
218+  0000              EXPANSION_BUS_DECODING_B24_31_REGISTER  EQU $89
219+  0000              EXPANSION_BUS_IO_PROPAGE_REGISTER       EQU $8A
220+  0000              ALTERNATE_ROM_REGISTER                  EQU $8C
221+  0000              MEMORY_MAPPING_REGISTER                 EQU $8E
222+  0000              PI_GPI_OUTPUT_ENABLE_0_REIGISTER        EQU $98
223+  0000              PI_GPI_OUTPUT_ENABLE_1_REIGISTER        EQU $99
224+  0000              PI_GPI_OUTPUT_ENABLE_2_REIGISTER        EQU $9A
225+  0000              PI_GPI_OUTPUT_ENABLE_3_REIGISTER        EQU $9B
226+  0000              PI_PERPIPHERAL_ENABLE_REGISTER          EQU $A0
227+  0000              PI_I2S_AUDIO_CONTROL_REGISTER           EQU $A2
228+  0000              PI_I2S_CLOCK_DIVIDE_REGISTER            EQU $A3
229+  0000              ESP_WIFI_GPIO_OUTPUT_REGISTER           EQU $A8
230+  0000              ESP_WIFI_GPIO_REGISTER                  EQU $A9
231+  0000              EXTENDED_KEYS_0_REGISTER                EQU $B0
232+  0000              EXTENDED_KEYS_1_REGISTER                EQU $B1
233+  0000              DIVMMC_TRAP_ENABLE_1                    EQU $B2
234+  0000              DIVMMC_TRAP_ENABLE_2                    EQU $B4
235+  0000              DEBUG_LED_CONTROL_REGISTER              EQU $FF
236+  0000
237+  0000              INTERUPT_CONTROL                        EQU $0C ; Interrupt control
238+  0000              NMI_RETURN_LSB				            EQU	$0C2	; NMI Return Address LSB
239+  0000              NMI_RETURN_MSB				            EQU	$0C3	; NMI Return Address MSB
240+  0000              INTERRUPT_EN0				            EQU	$0C4	; INT EN 0
241+  0000              INTERRUPT_EN1				            EQU	$0C5	; INT EN 1
242+  0000              INTERRUPT_EN2				            EQU	$0C6	; INT EN 2
243+  0000              INTERRUPT_ST0				            EQU	$0C8	; INT status 0
244+  0000              INTERRUPT_ST1				            EQU	$0C9	; INT status 1
245+  0000              INTERRUPT_ST2				            EQU	$0CA	; INT status 2
246+  0000              INTERRUPT_DM0				            EQU	$0CC	; INT DMA EN 0
247+  0000              INTERRUPT_DM1				            EQU	$0CD	; INT DMA EN 1
248+  0000              INTERRUPT_DM2				            EQU	$0CE	; INT DMA EN 2
249+  0000              CTC_CHANNEL_0				            EQU	$183B	; CTC channel 0 port
250+  0000              CTC_CHANNEL_1				            EQU	$193B	; CTC channel 1 port
251+  0000              CTC_CHANNEL_2				            EQU	$1A3B	; CTC channel 2 port
252+  0000              CTC_CHANNEL_3				            EQU	$1B3B	; CTC channel 3 port
253+  0000              CTC_CHANNEL_4				            EQU	$1C3B	; CTC channel 4 port
254+  0000              CTC_CHANNEL_5				            EQU	$1D3B	; CTC channel 5 port
255+  0000              CTC_CHANNEL_6				            EQU	$1E3B	; CTC channel 6 port
256+  0000              CTC_CHANNEL_7				            EQU	$1F3B	; CTC channel 7 port
257+  0000              CTCBASE                                 EQU $c0		; MSB Base address of buffer
258+  0000              CTCSIZE                                 EQU $04 	; MSB buffer length
259+  0000              CTCEND                                  EQU CTCBASE+(CTCSIZE*2)
260+  0000
261+  0000
262+  0000              DEBUG_LEDS_REGISTER						EQU 255
263+  0000
264+  0000
265+  0000              GetNextRegSaveBC:	MACRO register
266+  0000 ~                                push bc
267+  0000 ~                                ld bc,$243B
268+  0000 ~                                ld a,register
269+  0000 ~                                out (c),a
270+  0000 ~                                inc b
271+  0000 ~                                in a,(c)
272+  0000 ~                                pop bc
273+  0000                                  ENDM
274+  0000
275+  0000              GetNextReg:	MACRO register
276+  0000 ~                        ld bc,$243B
277+  0000 ~                        ld a,register
278+  0000 ~                        out (c),a
279+  0000 ~                        inc b
280+  0000 ~                        in a,(c)
281+  0000                          ENDM
282+  0000
# file closed: ../../Hardware/register_defines.asm
 56   0000                                      INCLUDE "../../Layer2Graphics/layer2_defines.asm"
# file opened: ../../Layer2Graphics/layer2_defines.asm
  1+  0000
  2+  0000
  3+  0000              LAYER2_SHIFTED_SCREEN_TOP  	 equ 0
  4+  0000              LAYER2_SHIFTED_SCREEN_MIDDLE equ $40
  5+  0000              LAYER2_SHIFTED_SCREEN_BOTTOM equ $80
  6+  0000
  7+  0000
  8+  0000              ; note hi byte is not decoded on DMA port so can out OUTIR
  9+  0000
 10+  0000              IO_SPRITE_SLOT_PORT 		 equ 12347
 11+  0000              IO_SPRITE_PATTERN_PORT       equ 91
 12+  0000              IO_SPRITE_ATTRIBUTES_PORT    equ 87
 13+  0000
 14+  0000              LAYER2_VISIBLE_MASK 		equ $02
 15+  0000              ; DEBUG 0 for always write to primary 08 for double buffering
 16+  0000                  IFDEF DOUBLEBUFFER
 17+  0000 ~            LAYER2_SHADOW_SCREEN_MASK 	equ $08
 18+  0000                  ELSE
 19+  0000              LAYER2_SHADOW_SCREEN_MASK 	equ $00
 20+  0000                  ENDIF
 21+  0000              LAYER2_READ_ENABLE_MASK 	equ %00000100
 22+  0000              LAYER2_WRITE_ENABLE_MASK 	equ %00000001
 23+  0000              LAYER2_READ_WRITE_MASK      equ %00000101
 24+  0000              LAYER2_SCREEN_SECTION_MASK 	equ $03
 25+  0000              LAYER2_SCREEN_SECTION_SHIFT equ 6
 26+  0000
 27+  0000              LAYER2_DISABLE_MEM_WRITE    equ %11111110
 28+  0000              LAYER2_DISABLE_MEM_READ     equ %11111011
 29+  0000              LAYER2_DISABLE_MEM_ACCESS   equ %11111010
 30+  0000
 31+  0000              LAYER2_SCREEN_BANK1          equ 8
 32+  0000              LAYER2_SCREEN_BANK2          equ 9
 33+  0000              LAYER2_SCREEN_BANK3          equ 10
 34+  0000              LAYER2_SCREEN_BANK4          equ 11     ; used by 320 and 640 mode
 35+  0000              LAYER2_SCREEN_BANK5          equ 12     ; used by 320 and 640 mode
 36+  0000              LAYER2_SHADOW_BANK1          equ 13
 37+  0000              LAYER2_SHADOW_BANK2          equ 14
 38+  0000              LAYER2_SHADOW_BANK3          equ 15
 39+  0000              LAYER2_SHADOW_BANK4          equ 16     ; used by 320 and 640 mode
 40+  0000              LAYER2_SHADOW_BANK5          equ 17     ; used by 320 and 640 mode
 41+  0000
 42+  0000              SCREEN_HEIGHT 				 equ 192
 43+  0000              SCREEN_RAM_BASE				 equ $0000
 44+  0000              SCREEN_HOZ_MIN_PIX		     equ 10
 45+  0000
 46+  0000              SPRITES_VISIBLE_MASK         equ $01
 47+  0000              SPRITES_ON_BORDER_MASK       equ $02
 48+  0000              LAYER_PRIORITIES_MASK        equ $07
 49+  0000              LORES_MODE_MASK              equ $80
 50+  0000              LAYER_PRIORITIES_SHIFT       equ 2
 51+  0000
 52+  0000              LAYER_PRIORITIES_S_L_U 		equ 0
 53+  0000              LAYER_PRIORITIES_L_S_U 		equ 1
 54+  0000              LAYER_PRIORITIES_S_U_L  	equ 2
 55+  0000              LAYER_PRIORITIES_L_U_S 		equ 3
 56+  0000              LAYER_PRIORITIES_U_S_L 		equ 4
 57+  0000              LAYER_PRIORITIES_U_L_S 		equ 5
 58+  0000
 59+  0000              DMA_WRO_BLOCK_PORTA_A2B_XFR  equ $7D
 60+  0000              DMA_WRO_BLOCK_PORTA_B2A_XFR  equ $79
 61+  0000              DMA_WR1_P1FIXED_MEMORY       equ $24
 62+  0000              DMA_WR1_P1DEC_MEMORY         equ $04
 63+  0000              DMA_WR1_P1INC_MEMORY         equ $14
 64+  0000              DMA_WR2_P2FIXED_MEMORY       equ $20
 65+  0000              DMA_WR2_P2DEC_MEMORY         equ $00
 66+  0000              DMA_WR2_P2INC_MEMORY         equ $10
 67+  0000              DMA_WR4_CONT_MODE            equ $AD
 68+  0000              DMA_WR4_BURST_MODE           equ $CD
 69+  0000              DMA_RESET                    equ $c3
 70+  0000              DMA_RESET_PORT_A_TIMING      equ $c7
 71+  0000              DMA_RESET_PORT_B_TIMING      equ $cb
 72+  0000              DMA_LOAD                     equ $cf
 73+  0000              DMA_CONTINUE                 equ $d3
 74+  0000              DMA_DISABLE_INTERUPTS        equ $af
 75+  0000              DMA_ENABLE_INTERUPTS         equ $ab
 76+  0000              DMA_RESET_DISABLE_INTERUPTS  equ $a3
 77+  0000              DMA_ENABLE_AFTER_RETI        equ $b7
 78+  0000              DMA_READ_STATUS_BYTE         equ $bf
 79+  0000              DMA_REINIT_STATUS_BYTE       equ $8b
 80+  0000              DMA_START_READ_SEQUENCE      equ $a7
 81+  0000              DMA_FORCE_READY              equ $b3
 82+  0000              DMA_STOP_AT_END			     equ $82
 83+  0000              DMA_DISABLE                  equ $83
 84+  0000              DMA_ENABLE                   equ $87
 85+  0000              DMA_WRITE_REGISTER_COMMAND   equ $bb
 86+  0000              DMA_BURST                    equ $cd
 87+  0000              DMA_CONTINUOUS               equ $ad
 88+  0000              ZXN_DMA_PORT                 equ $6b
 89+  0000
 90+  0000
 91+  0000              COLOUR_TRANSPARENT			 equ $E3
 92+  0000
 93+  0000
 94+  0000
 95+  0000
# file closed: ../../Layer2Graphics/layer2_defines.asm
 57   0000                                      INCLUDE	"../../Hardware/memory_bank_defines.asm"
# file opened: ../../Hardware/memory_bank_defines.asm
  1+  0000
  2+  0000              membanksize			    equ	$1FFF
  3+  0000
  4+  0000              StartOfBank     	    equ $0000
  5+  0000
  6+  0000              membank0 			    equ $0000
  7+  0000              dmaCopySrcAddr		    equ	$0000
  8+  0000              MathsTablesAddr         equ $0000
  9+  0000              membank1 			    equ $2000
 10+  0000              membank2 			    equ $4000
 11+  0000              membank3 			    equ $6000
 12+  0000              membank4 			    equ $8000
 13+  0000              membank5 			    equ $a000
 14+  0000              membank6 			    equ $c000
 15+  0000              ScreenBank              equ $c000
 16+  0000              MenuGalChtAddr          equ $c000
 17+  0000              MenuEquipSAddr          equ $c000
 18+  0000              MenuInventAddr          equ $c000
 19+  0000              MenuMarketAddr          equ $c000
 20+  0000              DispMarketAddr          equ $c000
 21+  0000              MenuShrChtAddr          equ $c000
 22+  0000              MenuStatusAddr          equ $c000
 23+  0000              MenuSystemAddr          equ $c000
 24+  0000              ViewFrontAddr           equ $c000
 25+  0000              SunBankAddr             equ $c000
 26+  0000              PlanetBankAddr          equ $c000
 27+  0000              SpaceStationBankAddr    equ $c000
 28+  0000              UniverseBankAddr	    equ $c000
 29+  0000              LaunchShipAddr          equ $c000
 30+  0000              membank7 			    equ $e000
 31+  0000              L1membankAddr   	    equ $e000
 32+  0000              L2membankAddr   	    equ $e000
 33+  0000              ShipModelsAddr	        equ $e000
 34+  0000              SpritemembankAddr       equ $e000
 35+  0000              ResetUniverseAddr       equ $e000
 36+  0000              StockTableAddr	        equ $e000
 37+  0000              CommanderAddr           equ $e000
 38+  0000              LAYER2Addr              equ $e000
 39+  0000              LAYER1Addr              equ $e000
 40+  0000              SPRITEAddr              equ $e000
 41+  0000              ConsoleImageAddr        equ $e000
 42+  0000              GalaxyDataAddr          equ $e000
 43+  0000              SoundAddr               equ $e000
 44+  0000              KeyboardAddr            equ $e000
 45+  0000              MathsBankedFnsAddr      equ $0000
 46+  0000
 47+  0000              EXSDOSMMU0              equ MMU_SLOT_0_REGISTER
 48+  0000              MathsTablesMMU          equ MMU_SLOT_0_REGISTER
 49+  0000              MathsBankedFnsMMU       equ MMU_SLOT_0_REGISTER
 50+  0000              ShipReadMMU             equ MMU_SLOT_0_REGISTER
 51+  0000              DMACpySourceMMU		    equ	MMU_SLOT_0_REGISTER
 52+  0000              EXSDOSMMU1              equ MMU_SLOT_1_REGISTER
 53+  0000              SunMMU 		            equ MMU_SLOT_6_REGISTER
 54+  0000              PlanetMMU 		        equ MMU_SLOT_6_REGISTER
 55+  0000              UniverseMMU 		    equ MMU_SLOT_6_REGISTER
 56+  0000              SpaceStationMMU         equ MMU_SLOT_6_REGISTER
 57+  0000              ScreenBankMMU           equ MMU_SLOT_6_REGISTER
 58+  0000              MenuEquipSMMU           equ MMU_SLOT_6_REGISTER
 59+  0000              MenuShrChtMMU           equ MMU_SLOT_6_REGISTER
 60+  0000              MenuGalChtMMU           equ MMU_SLOT_6_REGISTER
 61+  0000              MenuInventMMU           equ MMU_SLOT_6_REGISTER
 62+  0000              MenuSystemMMU           equ MMU_SLOT_6_REGISTER
 63+  0000              MenuMarketMMU           equ MMU_SLOT_6_REGISTER
 64+  0000              DispMarketMMU           equ MMU_SLOT_6_REGISTER
 65+  0000              MenuStatusMMU           equ MMU_SLOT_6_REGISTER
 66+  0000              LaunchShipMMU           equ MMU_SLOT_6_REGISTER
 67+  0000              L1memMMU       		    equ MMU_SLOT_7_REGISTER
 68+  0000              L2memMMU       		    equ MMU_SLOT_7_REGISTER
 69+  0000              SpritememMMU   		    equ MMU_SLOT_7_REGISTER
 70+  0000              ShipModelMMU  		    equ MMU_SLOT_7_REGISTER
 71+  0000              ResetUniverseMMU	    equ MMU_SLOT_7_REGISTER
 72+  0000              CommanderMMU	        equ MMU_SLOT_7_REGISTER
 73+  0000              StockTableMMU		    equ MMU_SLOT_7_REGISTER
 74+  0000              ConsoleImageDataMMU	    equ MMU_SLOT_7_REGISTER
 75+  0000              GalaxyDataMMU	        equ MMU_SLOT_7_REGISTER
 76+  0000              SoundMMU                equ MMU_SLOT_7_REGISTER
 77+  0000              KeyboardMMU             equ MMU_SLOT_7_REGISTER
 78+  0000
 79+  0000              ; banks 8 to 17 are reserved for layer 2 memory
 80+  0000              BankResetUniv           equ 49
 81+  0000              BankMenuShrCht          equ 50
 82+  0000              BankMenuGalCht          equ 51
 83+  0000              BankMenuInvent          equ 52
 84+  0000              BankMenuSystem          equ 53
 85+  0000              BankMenuMarket          equ 54
 86+  0000              BankStockTable          equ 55
 87+  0000              BankCommander           equ 56
 88+  0000              BankLAYER2              equ 57
 89+  0000              BankLAYER1              equ 58
 90+  0000              BankShipModels1         equ 59
 91+  0000              BankSPRITE              equ 60
 92+  0000              BankConsole             equ 61
 93+  0000              BankFrontView           equ 62
 94+  0000              BankMenuStatus          equ 63
 95+  0000              BankMenuEquipS          equ 64
 96+  0000              BankLaunchShip          equ 65
 97+  0000              BankDispMarket          equ 66
 98+  0000              BankShipModels2         equ 67
 99+  0000              BankShipModels3         equ 68
100+  0000              BankShipModels4         equ 69
101+  0000
102+  0000              BankUNIVDATA0           equ 70
103+  0000              BankSpaceStationData    equ 70
104+  0000              BankUNIVDATA1           equ 71
105+  0000              BankUNIVDATA2           equ 72
106+  0000              BankUNIVDATA3           equ 73
107+  0000              BankUNIVDATA4           equ 74
108+  0000              BankUNIVDATA5           equ 75
109+  0000              BankUNIVDATA6           equ 76
110+  0000              BankUNIVDATA7           equ 77
111+  0000              BankUNIVDATA8           equ 78
112+  0000              BankUNIVDATA9           equ 79
113+  0000              BankUNIVDATA10          equ 80
114+  0000              BankUNIVDATA11          equ 81
115+  0000              BankUNIVDATA12          equ 82
116+  0000              BankSunData             equ 83
117+  0000              BankPlanetData          equ 84
118+  0000
119+  0000              BankGalaxyData0         equ 91
120+  0000              BankGalaxyData1         equ 92
121+  0000              BankGalaxyData2         equ 93
122+  0000              BankGalaxyData3         equ 94
123+  0000              BankGalaxyData4         equ 95
124+  0000              BankGalaxyData5         equ 96
125+  0000              BankGalaxyData6         equ 97
126+  0000              BankGalaxyData7         equ 98
127+  0000
128+  0000              BankMathsTables         equ 99
129+  0000              BankSound               equ 100
130+  0000              BankKeyboard            equ 101
131+  0000              BankMathsBankedFns      equ 102
132+  0000
133+  0000              BankROM                 equ 255
134+  0000
135+  0000
# file closed: ../../Hardware/memory_bank_defines.asm
 58   0000                                      INCLUDE "../../Hardware/screen_equates.asm"
# file opened: ../../Hardware/screen_equates.asm
  1+  0000              ScreenHeight 		equ 192
  2+  0000              ScreenLastRow       equ ScreenHeight -1
  3+  0000              ScreenWidth  		equ 256
  4+  0000              ScreenLastCol       equ ScreenWidth -1
  5+  0000              ScreenHeightHalf	equ 96
  6+  0000              ScreenWidthHalf  	equ 128
  7+  0000              ScreenCenterY		equ 96
  8+  0000              ScreenCenterX       equ 128
  9+  0000              ViewHeight          equ 128
 10+  0000              ViewHeightPlus1     equ 128+1
 11+  0000              ViewLastRow       	equ ViewHeight -1
 12+  0000              ViewWidth  			equ 256
 13+  0000              ViewLastCol         equ ViewWidth -1
 14+  0000              ViewHeightHalf      equ 63
 15+  0000              ViewWidthHalf       equ 127
 16+  0000              ViewCenterY         equ 64
 17+  0000              ViewCenterX         equ 128
 18+  0000                                      DISPLAY "TODO: place odler for debugging"
 19+  0000              ShipColour			equ $FF		; place holder for debugging TODO
 20+  0000              ScreenL1Bottom      equ $5000
 21+  0000              ScreenL1BottomLen   equ 32 * 8 * 8
 22+  0000              ScreenL1AttrBtm     equ $5A00
 23+  0000              ScreenL1AttrBtmLen  equ 32 * 8
 24+  0000
# file closed: ../../Hardware/screen_equates.asm
 59   0000                                      INCLUDE "../../Macros/graphicsMacros.asm"
# file opened: ../../Macros/graphicsMacros.asm
  1+  0000              ; General Graphics macros
  2+  0000              DoubleBufferIfPossible: MACRO
  3+  0000 ~                                    IFDEF DOUBLEBUFFER
  4+  0000 ~                                        MMUSelectLayer2
  5+  0000 ~                                        call  l2_cls
  6+  0000 ~                                        call  l2_flip_buffers
  7+  0000 ~                                    ENDIF
  8+  0000                                      ENDM
  9+  0000
 10+  0000              DoubleBuffer320IfPossible: MACRO
 11+  0000 ~                                    IFDEF DOUBLEBUFFER
 12+  0000 ~                                        MMUSelectLayer2
 13+  0000 ~                                        call  l2_320_cls
 14+  0000 ~                                        call  l2_flip_buffers
 15+  0000 ~                                    ENDIF
 16+  0000                                      ENDM
 17+  0000
 18+  0000                  IFDEF L2_640_SUPPORT
 19+  0000 ~            DoubleBuffer640IfPossible: MACRO
 20+  0000 ~                                    IFDEF DOUBLEBUFFER
 21+  0000 ~                                        MMUSelectLayer2
 22+  0000 ~                                        call  l2_640_cls
 23+  0000 ~                                        call  l2_flip_buffers
 24+  0000 ~                                    ENDIF
 25+  0000 ~                                    ENDM
 26+  0000                  ENDIF
 27+  0000
 28+  0000
 29+  0000              ErrorEquStepMinusDelta: MACRO   delta_step, delta_value
 30+  0000 ~                                    ld      hl,(delta_step)
 31+  0000 ~                                    ld      de,(delta_value)
 32+  0000 ~                                    ClearCarryFlag
 33+  0000 ~                                    sbc     hl,de
 34+  0000 ~                                    ld      (error),hl
 35+  0000                                      ENDM
 36+  0000
 37+  0000              ; we could hold steps and deltas in alternate registers later
 38+  0000              ErrorPlusStep:          MACRO   delta_step
 39+  0000 ~                                    ld      hl,(error)
 40+  0000 ~                                    ld      de,(delta_step)
 41+  0000 ~                                    add     hl,de
 42+  0000 ~                                    ld      (error),hl
 43+  0000                                      ENDM
 44+  0000
 45+  0000              ErrorMinusStep:         MACRO   delta_step
 46+  0000 ~                                    ld      hl,(error)
 47+  0000 ~                                    ld      de,(delta_step)
 48+  0000 ~                                    ClearCarryFlag
 49+  0000 ~                                    sbc     hl,de
 50+  0000 ~                                    ld      (error),hl
 51+  0000                                      ENDM
 52+  0000
 53+  0000              SetExitFalse:           MACRO
 54+  0000 ~                                    xor     a
 55+  0000 ~                                    ld      (set_exit),a
 56+  0000                                      ENDM
 57+  0000
 58+  0000              ; pulls axis high byte to a, returns nz if negative, z if positive
 59+  0000              IsAxisLT0:              MACRO   axis
 60+  0000 ~                                    ld      a,(axis+1)
 61+  0000 ~                                    and     $80
 62+  0000                                      ENDM
 63+  0000
 64+  0000              ; modifies HL, loaded with register, returns z if >=0, nz if negative
 65+  0000              IsMemld16GTE0           MACRO   mem
 66+  0000 ~                                    ld      hl, (mem)
 67+  0000 ~                                    bit     7,h
 68+  0000                                      ENDM
 69+  0000
 70+  0000              IsMemNegative8JumpFalse:MACRO   mem, target
 71+  0000 ~                                    ld      a,(mem)
 72+  0000 ~                                    and     $80
 73+  0000 ~                                    jp      z, target
 74+  0000                                      ENDM
 75+  0000
 76+  0000              IsMem16GT0JumpFalse:    MACRO   mem, target
 77+  0000 ~                                    ld      hl, (mem)
 78+  0000 ~                                    bit     7,h
 79+  0000 ~                                    jp      nz, target
 80+  0000 ~                                    ld      a,h
 81+  0000 ~                                    or      l
 82+  0000 ~                                    jp      z,  target
 83+  0000                                      ENDM
 84+  0000
 85+  0000              FloorHLdivDETarget:     MACRO   target
 86+  0000 ~                                    call    l_div                   ;       .  (so we swap and call l_div) HL = DE / HL, DE = DE % HL
 87+  0000 ~                                    ld      a,d                     ;       .  get bit 7 into carry (set if negative)
 88+  0000 ~                                    sla     a                       ;
 89+  0000 ~                                    jr      nc,.FloorIsOK           ;
 90+  0000 ~            .FloorAdjust:           dec     hl                      ;       .  if remainder >= adjust by 1 for negative
 91+  0000 ~            .FloorIsOK:             ld      (target),hl             ;       .  now save the msd value
 92+  0000                                      ENDM
 93+  0000
# file closed: ../../Macros/graphicsMacros.asm
 60   0000                                      INCLUDE "../../Macros/callMacros.asm"
# file opened: ../../Macros/callMacros.asm
  1+  0000
  2+  0000              CallIfAEqNusng:         MACRO   reg,target
  3+  0000 ~                                    cp      reg
  4+  0000 ~                                    call	z,target
  5+  0000                                      ENDM
  6+  0000
  7+  0000              CallIfAGTENusng:        MACRO   reg,target
  8+  0000 ~                                    cp      reg
  9+  0000 ~                                    call	nc,target
 10+  0000                                      ENDM
 11+  0000
 12+  0000              CallIfAGTEMemusng:      MACRO   reg,target
 13+  0000 ~                                    ld      hl,reg
 14+  0000 ~                                    cp      (hl)
 15+  0000 ~                                    call	nc,target
 16+  0000                                      ENDM
 17+  0000
 18+  0000              CallIfALTMemusng:       MACRO   reg,target
 19+  0000 ~                                    ld      hl,reg
 20+  0000 ~                                    cp      (hl)
 21+  0000 ~                                    call	c,target
 22+  0000                                      ENDM
 23+  0000
 24+  0000              CallIfALTNusng:         MACRO   reg,target
 25+  0000 ~                                    cp      reg
 26+  0000 ~                                    call	c,target
 27+  0000                                      ENDM
 28+  0000
 29+  0000              CallIfMemEqMemusng:     MACRO mem, address, target
 30+  0000 ~                                    ld      a,(mem)
 31+  0000 ~                                    ld      hl,address
 32+  0000 ~                                    cp      (hl)
 33+  0000 ~                                    call    z,target
 34+  0000                                      ENDM
 35+  0000
 36+  0000              CallIfMemEqNusng:       MACRO mem, value, target
 37+  0000 ~                                    ld      a,(mem)
 38+  0000 ~                                    cp      value
 39+  0000 ~                                    call    z,target
 40+  0000                                      ENDM
 41+  0000
 42+  0000
 43+  0000              CallIfMemGTENusng:      MACRO mem, value, target
 44+  0000 ~                                    ld      a,(mem)
 45+  0000 ~                                    cp      value
 46+  0000 ~                                    call    nc,target
 47+  0000                                      ENDM
 48+  0000
 49+  0000              CallIfMemTrue:          MACRO mem, target
 50+  0000 ~                                    ld      a,(mem)
 51+  0000 ~                                    and     a
 52+  0000 ~                                    call    z, target
 53+  0000                                      ENDM
 54+  0000
 55+  0000              CallIfMemFalse:         MACRO mem, target
 56+  0000 ~                                    ld      a,(mem)
 57+  0000 ~                                    and     a
 58+  0000 ~                                    call    nz, target
 59+  0000                                      ENDM
 60+  0000
 61+  0000              CallIfMemZero:          MACRO mem, target
 62+  0000 ~                                    ld      a,(mem)
 63+  0000 ~                                    and     a
 64+  0000 ~                                    call    z, target
 65+  0000                                      ENDM
 66+  0000
 67+  0000              CallIfMemNotZero:       MACRO mem, target
 68+  0000 ~                                    ld      a,(mem)
 69+  0000 ~                                    and     a
 70+  0000 ~                                    call    nz, target
 71+  0000                                      ENDM
 72+  0000              CallIfATrue:            MACRO target
 73+  0000 ~                                    and     a
 74+  0000 ~                                    call    z, target
 75+  0000                                      ENDM
 76+  0000
 77+  0000              CallIfAFalse:           MACRO target
 78+  0000 ~                                    and     a
 79+  0000 ~                                    call    nz, target
 80+  0000                                      ENDM
 81+  0000
 82+  0000              CallIfAZero:            MACRO target
 83+  0000 ~                                    and     a
 84+  0000 ~                                    call    z, target
 85+  0000                                      ENDM
 86+  0000
 87+  0000              CallIfANotZero:         MACRO target
 88+  0000 ~                                    and     a
 89+  0000 ~                                    call    nz, target
 90+  0000                                      ENDM
# file closed: ../../Macros/callMacros.asm
 61   0000                                      INCLUDE "../../Macros/carryFlagMacros.asm"
# file opened: ../../Macros/carryFlagMacros.asm
  1+  0000
  2+  0000              SetCarryFlag:           MACRO
  3+  0000 ~                                    scf
  4+  0000                                      ENDM
  5+  0000
  6+  0000              ClearCarryFlag:	        MACRO
  7+  0000 ~                                    or a
  8+  0000                                      ENDM
  9+  0000
 10+  0000              FlipCarryFlag:          MACRO
 11+  0000 ~                                    ccf
 12+  0000                                      ENDM
 13+  0000
# file closed: ../../Macros/carryFlagMacros.asm
 62   0000                                      INCLUDE "../../Macros/CopyByteMacros.asm"
# file opened: ../../Macros/CopyByteMacros.asm
  1+  0000              CopyByteAtHLixToA:		MACRO memloc
  2+  0000 ~            						ex          de,hl                               ; save hl
  3+  0000 ~            						ld          hl,memloc
  4+  0000 ~            						add         hl,a
  5+  0000 ~            						ld          a,(hl)                              ; get XX2[x]
  6+  0000 ~            						ex          de,hl                               ; get hl back as we need it in loop
  7+  0000              						ENDM
  8+  0000
  9+  0000              ; Increments IYL
 10+  0000              ; Increments IHL
 11+  0000              ; Gets value at hl and loads into Parameter 1 address
 12+  0000
 13+  0000              CopyByteAtNextHLiyl: 	MACRO memloc
 14+  0000 ~            						inc         iyl                                 ;
 15+  0000 ~            						inc         hl                                  ; vertex byte#1
 16+  0000 ~            						ld          a,(hl)                              ;
 17+  0000 ~            						ld          (memloc),a                     ; XX15+2 = (V),Y
 18+  0000              						ENDM
 19+  0000
 20+  0000              ;------------------------------------------------------------------------------------------------------------------------------
 21+  0000              CopyByteAtNextHL:   MACRO targetaddr
 22+  0000 ~                                inc         hl                                  ; vertex byte#1
 23+  0000 ~                                ld          a,(hl)                              ;
 24+  0000 ~                                ld          (targetaddr),a                     ; SunXX15+2 = (V),Y
 25+  0000                                  ENDM
# file closed: ../../Macros/CopyByteMacros.asm
 63   0000                                      INCLUDE "../../Macros/ldCopyMacros.asm"
# file opened: ../../Macros/ldCopyMacros.asm
  1+  0000              ZeroA:		            MACRO
  2+  0000 ~                                    xor a
  3+  0000                                      ENDM
  4+  0000
  5+  0000              SetATrue:               MACRO
  6+  0000 ~                                    xor     a
  7+  0000                                      ENDM
  8+  0000
  9+  0000              SetAFalse:              MACRO
 10+  0000 ~                                    ld      a,$FF
 11+  0000                                      ENDM
 12+  0000
 13+  0000              SetMemFalse             MACRO   mem
 14+  0000 ~                                    ld      a,$FF
 15+  0000 ~                                    ld      (mem),a
 16+  0000                                      ENDM
 17+  0000
 18+  0000              SetMemTrue              MACRO   mem
 19+  0000 ~                                    xor     a
 20+  0000 ~                                    ld      (mem),a
 21+  0000                                      ENDM
 22+  0000
 23+  0000              SetMemZero:             MACRO   mem
 24+  0000 ~                                    xor     a
 25+  0000 ~                                    ld      (mem),a
 26+  0000                                      ENDM
 27+  0000
 28+  0000              SetMemToN:              MACRO   mem,value
 29+  0000 ~                                    ld      a,value
 30+  0000 ~                                    ld      (mem),a
 31+  0000                                      ENDM
 32+  0000
 33+  0000              ldCopyStringLen:        MACRO   source, target, strlen
 34+  0000 ~                                    ld      hl,source
 35+  0000 ~                                    ld      de, target
 36+  0000 ~                                    ld      bc, strlen
 37+  0000 ~                                    ldir
 38+  0000                                      ENDM
 39+  0000
 40+  0000              ldCopyTextAtHLtoDE:     MACRO
 41+  0000 ~            .CopyLoop:              ld      a,(hl)
 42+  0000 ~                                    ld      (de),a
 43+  0000 ~                                    cp      0
 44+  0000 ~                                    jp      z,.DoneCopy
 45+  0000 ~                                    inc     hl
 46+  0000 ~                                    inc     de
 47+  0000 ~                                    jr      .CopyLoop
 48+  0000 ~            .DoneCopy:
 49+  0000                                      ENDM
 50+  0000
 51+  0000              ldClearTextLoop:        MACRO   TextSize
 52+  0000 ~                                    ld      b,a
 53+  0000 ~                                    ld      a,TextSize
 54+  0000 ~            .ClearLoop:             ld      (hl),a
 55+  0000 ~                                    inc     hl
 56+  0000 ~                                    djnz    .ClearLoop
 57+  0000                                      ENDM
 58+  0000
 59+  0000              ldCopyByte:             MACRO memfrom, memto
 60+  0000 ~                                    ld       a,(memfrom)
 61+  0000 ~                                    ld       (memto),a
 62+  0000                                      ENDM
 63+  0000
 64+  0000
 65+  0000              ldCopyByteABS:          MACRO memfrom, memto
 66+  0000 ~                                    ld       a,(memfrom)
 67+  0000 ~                                    and		$7F
 68+  0000 ~                                    ld       (memto),a
 69+  0000                                      ENDM
 70+  0000
 71+  0000              ldAtHLtoMem:            MACRO   memto
 72+  0000 ~                                    ld      a,(hl)
 73+  0000 ~                                    ld      (memto),a
 74+  0000                                      ENDM
 75+  0000
 76+  0000              ldCopyWord:             MACRO memfrom, memto
 77+  0000 ~                                    ldCopy2Byte memfrom, memto
 78+  0000                                      ENDM
 79+  0000
 80+  0000              ldCopy2Byte:            MACRO  memfrom, memto
 81+  0000 ~                                    ld       hl,(memfrom)
 82+  0000 ~                                    ld       (memto),hl
 83+  0000                                      ENDM
 84+  0000
 85+  0000              ldWriteConst            MACRO  memfrom, memto
 86+  0000 ~                                    ld       a,memfrom
 87+  0000 ~                                    ld       (memto),a
 88+  0000                                      ENDM
 89+  0000
 90+  0000              ldWriteZero             MACRO  memto
 91+  0000 ~                                    xor      a
 92+  0000 ~                                    ld       (memto),a
 93+  0000                                      ENDM
 94+  0000
 95+  0000              ldIXLaFromN:	        MACRO memfrom
 96+  0000 ~                                    ld		a,(memfrom)
 97+  0000 ~                                    ld		ixl,a
 98+  0000                                      ENDM
 99+  0000
100+  0000              ldIXHaFromN:	        MACRO memfrom
101+  0000 ~                                    ld		a,(memfrom)
102+  0000 ~                                    ld		ixh,a
103+  0000                                      ENDM
104+  0000
105+  0000              ldIYLaFromN:	        MACRO memfrom
106+  0000 ~                                    ld		a,(memfrom)
107+  0000 ~                                    ld		iyl,a
108+  0000                                      ENDM
109+  0000
110+  0000              ldIYHaFromN:	        MACRO memfrom
111+  0000 ~                                    ld		a,(memfrom)
112+  0000 ~                                    ld		iyh,a
113+  0000                                      ENDM
114+  0000
115+  0000              ; Read a 32 bit value from address HL into BCDE
116+  0000              ldBCDEatHL:             MACRO
117+  0000 ~                                    ld      e,(hl)
118+  0000 ~                                    inc     hl
119+  0000 ~                                    ld      d,(hl)
120+  0000 ~                                    inc     hl
121+  0000 ~                                    ld      c,(hl)
122+  0000 ~                                    inc     hl
123+  0000 ~                                    ld      b,(hl)
124+  0000 ~                                    inc     hl
125+  0000                                      ENDM
126+  0000
127+  0000              ldBCatHL:               MACRO
128+  0000 ~                                    ld      c,(hl)
129+  0000 ~                                    inc     hl
130+  0000 ~                                    ld      b,(hl)
131+  0000 ~                                    inc     hl
132+  0000                                      ENDM
133+  0000
134+  0000              ldhlde:			        MACRO
135+  0000 ~                                    ld		h,d
136+  0000 ~                                    ld		l,e
137+  0000                                      ENDM
138+  0000
139+  0000              ldhlbc:			        MACRO
140+  0000 ~                                    ld		h,b
141+  0000 ~                                    ld		l,c
142+  0000                                      ENDM
143+  0000
144+  0000              ldbcde:			        MACRO
145+  0000 ~                                    ld		b,d
146+  0000 ~                                    ld		c,e
147+  0000                                      ENDM
148+  0000
149+  0000              lddebc:			        MACRO
150+  0000 ~                                    ld		d,b
151+  0000 ~                                    ld		e,c
152+  0000                                      ENDM
153+  0000
154+  0000              ldbchl:			        MACRO
155+  0000 ~                                    ld		b,h
156+  0000 ~                                    ld		c,l
157+  0000                                      ENDM
158+  0000
159+  0000              lddeiy:			        MACRO
160+  0000 ~                                    ld		d,iyh
161+  0000 ~                                    ld		e,iyl
162+  0000                                      ENDM
163+  0000
164+  0000              ldiyde:			        MACRO
165+  0000 ~                                    ld		iyh,d
166+  0000 ~                                    ld		iyl,e
167+  0000                                      ENDM
168+  0000
169+  0000
170+  0000              FourLDIInstrunctions:   MACRO
171+  0000 ~                                    ldi
172+  0000 ~                                    ldi
173+  0000 ~                                    ldi
174+  0000 ~                                    ldi
175+  0000                                      ENDM
176+  0000
177+  0000              FiveLDIInstrunctions:   MACRO
178+  0000 ~                                    ldi
179+  0000 ~                                    ldi
180+  0000 ~                                    ldi
181+  0000 ~                                    ldi
182+  0000 ~                                    ldi
183+  0000                                      ENDM
184+  0000
185+  0000              SixLDIInstrunctions:    MACRO
186+  0000 ~                                    ldi
187+  0000 ~                                    ldi
188+  0000 ~                                    ldi
189+  0000 ~                                    ldi
190+  0000 ~                                    ldi
191+  0000 ~                                    ldi
192+  0000                                      ENDM
193+  0000
194+  0000              EightLDIInstrunctions:  MACRO
195+  0000 ~            		                ldi
196+  0000 ~            		                ldi
197+  0000 ~            		                ldi
198+  0000 ~            		                ldi
199+  0000 ~            		                ldi
200+  0000 ~            		                ldi
201+  0000 ~            		                ldi
202+  0000 ~            		                ldi
203+  0000                                      ENDM
204+  0000
205+  0000              NineLDIInstrunctions:  MACRO
206+  0000 ~            		                ldi
207+  0000 ~            		                ldi
208+  0000 ~            		                ldi
209+  0000 ~            		                ldi
210+  0000 ~            		                ldi
211+  0000 ~            		                ldi
212+  0000 ~            		                ldi
213+  0000 ~            		                ldi
214+  0000 ~            		                ldi
215+  0000                                      ENDM
# file closed: ../../Macros/ldCopyMacros.asm
 64   0000                                      INCLUDE "../../Macros/ldIndexedMacros.asm"
# file opened: ../../Macros/ldIndexedMacros.asm
  1+  0000              GetByteAInTable:    MACRO table
  2+  0000 ~                                ld          hl,table
  3+  0000 ~                                add         hl,a
  4+  0000 ~                                ld          a,(hl)
  5+  0000                                  ENDM
  6+  0000
  7+  0000              HLWordAInTable:     MACRO table
  8+  0000 ~                                ld          hl,table
  9+  0000 ~                                sla         a
 10+  0000 ~                                add         hl,a
 11+  0000 ~                                ld          a,(hl)
 12+  0000 ~                                inc         hl
 13+  0000 ~                                ld          h,(hl)
 14+  0000 ~                                ld          l,a
 15+  0000                                  ENDM
 16+  0000
 17+  0000
 18+  0000              ldAToHLixl:			MACRO value
 19+  0000 ~            					ld          hl,value
 20+  0000 ~            					ex          af,af'
 21+  0000 ~            					ld          a,ixl
 22+  0000 ~            					add         hl,a
 23+  0000 ~            					ex          af,af'
 24+  0000 ~            					ld          (hl),a
 25+  0000              					ENDM
 26+  0000
 27+  0000              ldAToHLiyl:			MACRO value
 28+  0000 ~            					ld          hl,value
 29+  0000 ~            					ex          af,af'
 30+  0000 ~            					ld          a,iyl
 31+  0000 ~            					add         hl,a
 32+  0000 ~            					ex          af,af'
 33+  0000 ~            					ld          (hl),a
 34+  0000              					ENDM
 35+  0000
 36+  0000
 37+  0000              ldHLixlToA:         MACRO value
 38+  0000 ~                                ld          hl,value
 39+  0000 ~                                ex          af,af'
 40+  0000 ~                                ld          a,ixl
 41+  0000 ~                                add         hl,a
 42+  0000 ~                                ld          a,(hl)
 43+  0000                                  ENDM
 44+  0000
 45+  0000              ldHLiylToA:         MACRO value
 46+  0000 ~                                ld          hl,value
 47+  0000 ~                                ex          af,af'
 48+  0000 ~                                ld          a,iyl
 49+  0000 ~                                add         hl,a
 50+  0000 ~                                ld          a,(hl)
 51+  0000                                  ENDM
 52+  0000
 53+  0000              ldHLIdxAToA:        MACRO value
 54+  0000 ~                                ld          hl,value
 55+  0000 ~                                add         hl,a
 56+  0000 ~                                ld          a,(hl)
 57+  0000                                  ENDM
 58+  0000
 59+  0000              HLEquAddrAtHLPlusA: MACRO
 60+  0000 ~                                sla         a
 61+  0000 ~                                add         hl,a
 62+  0000 ~                                ld          a,(hl)
 63+  0000 ~                                inc         hl
 64+  0000 ~                                ld          h,(hl)
 65+  0000 ~                                ld          l,a
 66+  0000                                  ENDM
 67+  0000
 68+  0000              ;-- Performs HL = |HL| - 1
 69+  0000              DecHLABS:           MACRO
 70+  0000 ~                                bit         7,h
 71+  0000 ~                                jp          nz,.NegativeDec
 72+  0000 ~            .IsHLZero:          ld          a,h                 ; if its zero it becomes negative
 73+  0000 ~                                or          l
 74+  0000 ~                                jp          z,.HLZero
 75+  0000 ~            .PositiveDec:       dec         hl
 76+  0000 ~                                jp          .Done
 77+  0000 ~            .NegativeDec:       ld          a,h
 78+  0000 ~                                and         $7F
 79+  0000 ~                                ld          h,a
 80+  0000 ~                                dec         hl
 81+  0000 ~                                set         7,h
 82+  0000 ~                                jp          .Done
 83+  0000 ~            .HLZero:            ld          hl,$8001
 84+  0000 ~            .Done:
 85+  0000                                  ENDM
 86+  0000
 87+  0000              ;-- Performs HL = HL - 1
 88+  0000              DecHLSigned:        MACRO
 89+  0000 ~                                bit         7,h
 90+  0000 ~                                jp          nz,.NegativeDec
 91+  0000 ~            .IsHLZero:          ld          a,h                 ; if its zero it becomes negative
 92+  0000 ~                                or          l
 93+  0000 ~                                jp          z,.HLZero
 94+  0000 ~            .PositiveDec:       dec         hl
 95+  0000 ~                                jp          .Done
 96+  0000 ~            .NegativeDec:       ld          a,h
 97+  0000 ~                                and         $7F
 98+  0000 ~                                ld          h,a
 99+  0000 ~                                inc         hl                  ; if its already negative then add 1 to make it further
100+  0000 ~                                set         7,h
101+  0000 ~                                jp          .Done
102+  0000 ~            .HLZero:            ld          hl,$8001
103+  0000 ~            .Done:
104+  0000                                  ENDM
105+  0000
# file closed: ../../Macros/ldIndexedMacros.asm
 65   0000                                      INCLUDE "../../Macros/jumpMacros.asm"
# file opened: ../../Macros/jumpMacros.asm
  1+  0000              JumpIfHLNegative:       MACRO target
  2+  0000 ~                                    bit     7,h
  3+  0000 ~                                    jp      nz,target
  4+  0000                                      ENDM
  5+  0000
  6+  0000              JumpIfPositive:	        MACRO target
  7+  0000 ~                                    jp		p, target
  8+  0000                                      ENDM
  9+  0000
 10+  0000              JumpIfNegative:	        MACRO target
 11+  0000 ~                                    jp		m, target
 12+  0000                                      ENDM
 13+  0000
 14+  0000
 15+  0000              JumpIfUnderflow:	    MACRO target
 16+  0000 ~                                    jp		po, target
 17+  0000                                      ENDM
 18+  0000
 19+  0000              JumpIfOverflow:	        MACRO target
 20+  0000 ~                                    jp		po, target
 21+  0000                                      ENDM
 22+  0000
 23+  0000
 24+  0000              JumpIfNotZero:	        MACRO target
 25+  0000 ~                                    jp	nz,target
 26+  0000                                      ENDM
 27+  0000
 28+  0000              JumpIfZero:	            MACRO target
 29+  0000 ~                                    jp	z,target
 30+  0000                                      ENDM
 31+  0000
 32+  0000              ;.. Bit routines
 33+  0000              JumpOnLeadSignSet:      MACRO   reg, target
 34+  0000 ~                                    ld      a,reg
 35+  0000 ~                                    and     SignOnly8Bit
 36+  0000 ~                                    jp      nz,target
 37+  0000                                      ENDM
 38+  0000
 39+  0000              JumpOnLeadSignClear:    MACRO   reg, target
 40+  0000 ~                                    ld      a,reg
 41+  0000 ~                                    and     SignOnly8Bit
 42+  0000 ~                                    jp      z,target
 43+  0000                                      ENDM
 44+  0000
 45+  0000              JumpOnLeadSignSetA:     MACRO   target
 46+  0000 ~                                    and     SignOnly8Bit
 47+  0000 ~                                    jp      nz,target
 48+  0000                                      ENDM
 49+  0000
 50+  0000              JumpOnLeadSignClearA:   MACRO   target
 51+  0000 ~                                    and     SignOnly8Bit
 52+  0000 ~                                    jp      z,target
 53+  0000                                      ENDM
 54+  0000
 55+  0000              JumpOnMemBitSet:        MACRO mem, bitnbr, target
 56+  0000 ~                                    ld      a,(mem)
 57+  0000 ~                                    bit 	bitnbr,a
 58+  0000 ~                                    jp      nz,target
 59+  0000                                      ENDM
 60+  0000
 61+  0000              JumpOnMemBitClear:      MACRO mem, bitnbr, target
 62+  0000 ~                                    ld      a,(mem)
 63+  0000 ~                                    bit 	bitnbr,a
 64+  0000 ~                                    jp      z,target
 65+  0000                                      ENDM
 66+  0000
 67+  0000
 68+  0000              JumpOnABitSet:          MACRO   bitnbr, target
 69+  0000 ~                                    bit 	bitnbr, a
 70+  0000 ~                                    jp      nz,target
 71+  0000                                      ENDM
 72+  0000
 73+  0000              JumpOnABitClear:        MACRO   bitnbr, target
 74+  0000 ~                                    bit 	bitnbr, a
 75+  0000 ~                                    jp      z,target
 76+  0000                                      ENDM
 77+  0000
 78+  0000              JumpOnABit5Set:         MACRO   target
 79+  0000 ~                                    and     Bit5Only
 80+  0000 ~                                    jp      nz,target
 81+  0000                                      ENDM
 82+  0000
 83+  0000              JumpOnABit5Clear:       MACRO   target
 84+  0000 ~                                    and     Bit5Only
 85+  0000 ~                                    jp      z,target
 86+  0000                                      ENDM
 87+  0000
 88+  0000              JumpOnBitMaskSet:       MACRO   bitmask, target
 89+  0000 ~                                    and     bitmask
 90+  0000 ~                                    jp      nz,target
 91+  0000                                      ENDM
 92+  0000
 93+  0000              JumpOnBitMaskClear:     MACRO   bitmask, target
 94+  0000 ~                                    and     bitmask
 95+  0000 ~                                    jp      z,target
 96+  0000                                      ENDM
 97+  0000
 98+  0000              JumpOnMemBitMaskSet:    MACRO   mem, bitmask, target
 99+  0000 ~                                    ld      a,(mem)
100+  0000 ~                                    and     bitmask
101+  0000 ~                                    jp      nz,target
102+  0000                                      ENDM
103+  0000
104+  0000              JumpOnMemBitMaskClear:  MACRO   mem, bitmask, target
105+  0000 ~                                    ld      a,(mem)
106+  0000 ~                                    and     bitmask
107+  0000 ~                                    jp      z,target
108+  0000                                      ENDM
109+  0000
110+  0000              JumpOnBitSet:           MACRO  reg, bitnbr, target
111+  0000 ~                                    bit 	bitnbr,reg
112+  0000 ~                                    jp      nz,target
113+  0000                                      ENDM
114+  0000
115+  0000              JumpOnBitClear:         MACRO  reg, bitnbr, target
116+  0000 ~                                    bit 	bitnbr,reg
117+  0000 ~                                    jp      z,target
118+  0000                                      ENDM
119+  0000
120+  0000              ; Comparison Routines
121+  0000              JumpIfAGTEusng:         MACRO
122+  0000 ~                                    jp		nc,target
123+  0000                                      ENDM
124+  0000
125+  0000              JumpIfAGTENusng:        MACRO reg,target
126+  0000 ~                                    cp     reg
127+  0000 ~                                    jp		nc,target
128+  0000                                      ENDM
129+  0000
130+  0000              JumpIfAGTEMemusng:      MACRO mem,target
131+  0000 ~                                    ld      hl,mem
132+  0000 ~                                    cp      (hl)
133+  0000 ~                                    jp		nc,target
134+  0000                                      ENDM
135+  0000              JumpIfMemGTENusng:      MACRO mem, value, target
136+  0000 ~                                    ld     a,(mem)
137+  0000 ~                                    cp     value
138+  0000 ~                                    jp	  nc,target
139+  0000                                      ENDM
140+  0000
141+  0000              JumpIfMemGTEMemusng:    MACRO mem, address, target
142+  0000 ~                                    ld   a,(mem)
143+  0000 ~                                    ld   hl,address
144+  0000 ~                                    cp   (hl)
145+  0000 ~                                    jp	  nc,target
146+  0000                                      ENDM
147+  0000
148+  0000              JumpIfMemEqMemusng:     MACRO mem, address, target
149+  0000 ~                                    ld   a,(mem)
150+  0000 ~                                    ld   hl,address
151+  0000 ~                                    cp   (hl)
152+  0000 ~                                    jp	  z,target
153+  0000                                      ENDM
154+  0000
155+  0000              JumpIfMemNeMemusng:     MACRO mem, address, target
156+  0000 ~                                    ld   a,(mem)
157+  0000 ~                                    ld   hl,address
158+  0000 ~                                    cp   (hl)
159+  0000 ~                                    jp	  nz,target
160+  0000                                      ENDM
161+  0000
162+  0000              JumpIfMemTrue:          MACRO mem, target
163+  0000 ~                                    ld      a,(mem)
164+  0000 ~                                    and     a
165+  0000 ~                                    jp      z, target
166+  0000                                      ENDM
167+  0000
168+  0000              JumpIfMemFalse:         MACRO mem, target
169+  0000 ~                                    ld      a,(mem)
170+  0000 ~                                    and     a
171+  0000 ~                                    jp      nz, target
172+  0000                                      ENDM
173+  0000
174+  0000              JumpIfATrue:            MACRO target
175+  0000 ~                                    and     a
176+  0000 ~                                    jp      z, target
177+  0000                                      ENDM
178+  0000
179+  0000              JumpIfAFalse:           MACRO target
180+  0000 ~                                    and     a
181+  0000 ~                                    jp      nz, target
182+  0000                                      ENDM
183+  0000
184+  0000              JumpIfANotFalse:        MACRO target
185+  0000 ~                                    cp      $FF
186+  0000 ~                                    jp      nz, target
187+  0000                                      ENDM
188+  0000
189+  0000              ;-- Less than Macros -------------------------------------------
190+  0000              JumpIfALTMemHLusng:     MACRO target
191+  0000 ~                                    cp    (hl)
192+  0000 ~                                    jp	  c,target
193+  0000                                      ENDM
194+  0000
195+  0000              JumpIfRegLTE:           MACRO   reg, value, target
196+  0000 ~                                    ld      a,reg
197+  0000 ~                                    cp      value
198+  0000 ~                                    jp	    z,target
199+  0000 ~                                    jp		c, target
200+  0000                                      ENDM
201+  0000
202+  0000              JumpIfALTMemusng:       MACRO mem,target
203+  0000 ~                                    ld      hl,mem
204+  0000 ~                                    cp      (hl)
205+  0000 ~                                    jp		c,target
206+  0000                                      ENDM
207+  0000
208+  0000
209+  0000              JumpIfALTusng:          MACRO target
210+  0000 ~                                    jp		c,target
211+  0000                                      ENDM
212+  0000
213+  0000              JumpIfALTNusng:         MACRO value, target
214+  0000 ~                                    cp      value
215+  0000 ~                                    jp		c, target
216+  0000                                      ENDM
217+  0000
218+  0000              JumpIfALTNsigned:       MACRO   value, target
219+  0000 ~                                    cp      value
220+  0000 ~                                    jp      m,.SignSet
221+  0000 ~            .SignClear:             jp      pe,target       ; Sign (0), P/V (1)
222+  0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (0)
223+  0000 ~            .SignSet:               jp      po,target
224+  0000 ~            .CheckComplete:
225+  0000                                      ENDM
226+  0000
227+  0000              JumpIfMemLTNusng:       MACRO mem, value, target
228+  0000 ~                                    ld      a,(mem)
229+  0000 ~                                    cp      value
230+  0000 ~                                    jp	  c,target
231+  0000                                      ENDM
232+  0000
233+  0000              JumpIfMemLTMemusng:     MACRO mem, value, target
234+  0000 ~                                    ld    a,(mem)
235+  0000 ~                                    ld    hl,value
236+  0000 ~                                    cp    (hl)
237+  0000 ~                                    jp	  c,target
238+  0000                                      ENDM
239+  0000              ;-- ------------------------------------------------------------
240+  0000              JumpIfAGTENsigned       MACRO   value, target
241+  0000 ~                                    cp      value
242+  0000 ~                                    jp      m,.SignSet
243+  0000 ~            .SignClear:             jp      po,target       ; Sign (0), P/V (0)
244+  0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (1)
245+  0000 ~            .SignSet:               jp      pe,target
246+  0000 ~            .CheckComplete:
247+  0000                                      ENDM
248+  0000
249+  0000              JumpIfMemEqNusng:       MACRO mem,value,target
250+  0000 ~                                    ld  a,(mem)
251+  0000 ~                                    cp  value
252+  0000 ~                                    jp  z,target
253+  0000                                      ENDM
254+  0000
255+  0000              JumpIfMemNeNusng:       MACRO mem,value,target
256+  0000 ~                                    ld  a,(mem)
257+  0000 ~                                    cp  value
258+  0000 ~                                    jp  nz,target
259+  0000                                      ENDM
260+  0000
261+  0000              JumpIfMemZero:          MACRO mem,target
262+  0000 ~                                    ld  a,(mem)
263+  0000 ~                                    and a
264+  0000 ~                                    jp  z,target
265+  0000                                      ENDM
266+  0000
267+  0000              JumpIfMemNotZero:       MACRO mem,target
268+  0000 ~                                    ld  a,(mem)
269+  0000 ~                                    and a
270+  0000 ~                                    jp  nz,target
271+  0000                                      ENDM
272+  0000
273+  0000              JumpIfANENusng:         MACRO value, target
274+  0000 ~                                    cp     value
275+  0000 ~                                    jp      nz,target
276+  0000                                      ENDM
277+  0000
278+  0000              JumpIfANEquNusng:       MACRO value, target
279+  0000 ~                                    cp     value
280+  0000 ~                                    jp     z,target
281+  0000                                      ENDM
282+  0000
283+  0000              JumpIfANEMemusng:       MACRO  value, target
284+  0000 ~                                    ld    hl,value
285+  0000 ~                                    cp    (hl)
286+  0000 ~                                    jp      nz,target
287+  0000                                      ENDM
288+  0000
289+  0000              JumpIfAEqNusng:         MACRO value, target
290+  0000 ~                                    cp     value
291+  0000 ~                                    jp      z,target
292+  0000                                      ENDM
293+  0000
294+  0000              JumpIfAIsZero:	        MACRO target
295+  0000 ~                                    and     a   ; cp 0 - changed to and a for optimisation but affects other flags
296+  0000 ~                                    jp	    z, target
297+  0000                                      ENDM
298+  0000
299+  0000              JumpIfRegIsNotZero:     MACRO   reg, target
300+  0000 ~                                    ld      a,reg
301+  0000 ~                                    and     a
302+  0000 ~                                    jp	    nz,target
303+  0000                                      ENDM
304+  0000
305+  0000
306+  0000              JumpIfAIsNotZero:       MACRO target
307+  0000 ~                                    and     a
308+  0000 ~                                    jp	    nz,target
309+  0000                                      ENDM
310+  0000
311+  0000              JumpIfMemIsNotZero:     MACRO value, target
312+  0000 ~                                    ld      a,(value)
313+  0000 ~                                    and     a
314+  0000 ~                                    jp	    nz,target
315+  0000                                      ENDM
316+  0000              IfResultZeroGoto:	    MACRO target
317+  0000 ~                                    jp	z,target
318+  0000                                      ENDM
319+  0000
320+  0000              IfResultNotZeroGoto:    MACRO target
321+  0000 ~                                    jp	nz,target
322+  0000                                      ENDM
323+  0000
# file closed: ../../Macros/jumpMacros.asm
 66   0000                                      INCLUDE "../../Macros/MathsMacros.asm"
# file opened: ../../Macros/MathsMacros.asm
  1+  0000              ; sets z flag is HL less than 255 else sets it to nz (note opposite of GT127)
  2+  0000              IsHLGT255:              MACRO
  3+  0000 ~                                    bit     7,h
  4+  0000 ~                                    ret     z
  5+  0000 ~                                    ld      a,h
  6+  0000 ~                                    and     a
  7+  0000                                      ENDM
  8+  0000
  9+  0000              ; Sets z flat if HL = 255 else sets it to nz
 10+  0000              IsHLEqu255:             MACRO
 11+  0000 ~                                    ld      a,h
 12+  0000 ~                                    and     a               ; if its non zero then it can't be 255
 13+  0000 ~                                    ret     nz
 14+  0000 ~                                    ld      a,l
 15+  0000 ~                                    inc     a               ; if it was 255 the inc will set it to zero
 16+  0000                                      ENDM
 17+  0000
 18+  0000              ; Sets Z flag if GT 127 else nz
 19+  0000              IsHLGT127:              MACRO
 20+  0000 ~                                    bit     7,h             ; -ve?
 21+  0000 ~                                    jr      nz,.DoneCheck
 22+  0000 ~                                    ld      a,h             ; +ve > 256?
 23+  0000 ~                                    and     a
 24+  0000 ~                                    jr      nz,.DoneCheck
 25+  0000 ~                                    ld      a,l
 26+  0000 ~                                    and     $80             ; this will set z to false if bit 7 set and clear lower bits
 27+  0000 ~                                    cp      $80             ; this will set z to true if bit 7 set
 28+  0000 ~            .DoneCheck:
 29+  0000                                      ENDM
 30+  0000
 31+  0000              ReturnIfHLGT127:        MACRO
 32+  0000 ~                                    bit     7,h             ; -ve?
 33+  0000 ~                                    jr      nz,.DoneCheck   ; forces check complete
 34+  0000 ~                                    ld      a,h             ; +ve > 256?
 35+  0000 ~                                    and     a               ;
 36+  0000 ~                                    ret     nz              ; forces a return
 37+  0000 ~                                    bit     7,l             ; bit 7 of lower set?
 38+  0000 ~                                    ret     nz              ; forces a return
 39+  0000 ~            .DoneCheck:
 40+  0000                                      ENDM
 41+  0000
 42+  0000              IsDEGT127:              MACRO
 43+  0000 ~                                    bit     7,d
 44+  0000 ~                                    jr      nz,.DoneCheck
 45+  0000 ~                                    ld      a,d
 46+  0000 ~                                    jr      nz,.DoneCheck
 47+  0000 ~                                    ld      a,e
 48+  0000 ~                                    and     $80
 49+  0000 ~            .DoneCheck:
 50+  0000                                      ENDM
 51+  0000
 52+  0000              ABSa2c:                 MACRO
 53+  0000 ~                                    bit     7,a
 54+  0000 ~                                    jp      z,.DoneABSa
 55+  0000 ~                                    neg
 56+  0000 ~            .DoneABSa:
 57+  0000                                      ENDM
 58+  0000
 59+  0000              DEEquSquareA:           MACRO
 60+  0000 ~                                    ld  d,a
 61+  0000 ~                                    ld  e,a
 62+  0000 ~                                    mul de
 63+  0000                                      ENDM
 64+  0000
 65+  0000              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
 66+  0000 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
 67+  0000 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
 68+  0000 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
 69+  0000 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
 70+  0000 ~                                    xor $80                             ;
 71+  0000 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
 72+  0000 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
 73+  0000 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
 74+  0000 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
 75+  0000 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
 76+  0000 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
 77+  0000                                      ENDM
 78+  0000
 79+  0000              SignedHLTo2C:           MACRO
 80+  0000 ~                                    bit     7,h
 81+  0000 ~                                    jr      z,.Done2c
 82+  0000 ~                                    ld      a,h
 83+  0000 ~                                    and     SignMask8Bit
 84+  0000 ~                                    ld      h,a
 85+  0000 ~                                    NegHL
 86+  0000 ~            .Done2c:
 87+  0000                                      ENDM
 88+  0000
 89+  0000              MemSignedTo2C:          MACRO   memfrom
 90+  0000 ~                                    ld      hl,(memfrom)
 91+  0000 ~                                    bit     7,h
 92+  0000 ~                                    jr      z,.Done2c
 93+  0000 ~                                    ld      a,h
 94+  0000 ~                                    and     SignMask8Bit
 95+  0000 ~                                    ld      h,a
 96+  0000 ~            .Done2c:                ld      (memfrom),hl
 97+  0000                                      ENDM
 98+  0000
 99+  0000
100+  0000                  ;returns result in H
101+  0000              EDiv10Inline:           MACRO
102+  0000 ~                                    ld      d,0
103+  0000 ~                                    ld      hl,de
104+  0000 ~                                    add     hl,hl
105+  0000 ~                                    add     hl,de
106+  0000 ~                                    add     hl,hl
107+  0000 ~                                    add     hl,hl
108+  0000 ~                                    add     hl,de
109+  0000 ~                                    add     hl,hl
110+  0000                                      ENDM
111+  0000
112+  0000              cpHLDE:                 MACRO
113+  0000 ~                                    push    hl
114+  0000 ~                                    and     a
115+  0000 ~                                    sbc     hl,de
116+  0000 ~                                    pop     hl
117+  0000                                      ENDM
118+  0000
119+  0000              cpABSDEHL:              MACRO
120+  0000 ~                                    push     hl,,de
121+  0000 ~                                    ld      a,h
122+  0000 ~                                    and     $7F
123+  0000 ~                                    ld      h,a
124+  0000 ~                                    ld      a,d
125+  0000 ~                                    and     $7F
126+  0000 ~                                    ld      d,a
127+  0000 ~                                    ex      de,hl
128+  0000 ~                                    sbc     hl,de
129+  0000 ~                                    pop     hl,,de
130+  0000                                      ENDM
131+  0000
132+  0000              ; Simple are they both the same setting z if they are
133+  0000              ; tehcicall this works but it measn the final ret z is alwys done
134+  0000              ; so jp needs to be to a target
135+  0000              cpHLEquDE:              MACRO   passedCheck
136+  0000 ~                                    ld      a,h
137+  0000 ~                                    cp      d
138+  0000 ~                                    jp      nz, passedCheck
139+  0000 ~                                    ld      a,l
140+  0000 ~                                    cp      e
141+  0000 ~            .NoTheSame:
142+  0000                                      ENDM
143+  0000
144+  0000              cpHLEquBC:              MACRO   passedCheck
145+  0000 ~                                    ld      a,h
146+  0000 ~                                    cp      b
147+  0000 ~                                    jp      nz, passedCheck
148+  0000 ~                                    ld      a,l
149+  0000 ~                                    cp      c
150+  0000 ~            .NoTheSame:
151+  0000                                      ENDM
152+  0000
153+  0000              cpDEEquBC:              MACRO   passedCheck
154+  0000 ~                                    ld      a,d
155+  0000 ~                                    cp      b
156+  0000 ~                                    jp      nz, passedCheck
157+  0000 ~                                    ld      a,e
158+  0000 ~                                    cp      c
159+  0000 ~            .NoTheSame:
160+  0000                                      ENDM
161+  0000              ; Simple version just sets carry if HL < DE reset, does an initial compare for z
162+  0000              cpHLDELeadSign:         MACRO
163+  0000 ~                                    ld      a,h
164+  0000 ~                                    cp      d
165+  0000 ~                                    jr      nz,.FullCompare
166+  0000 ~                                    ld      a,l
167+  0000 ~                                    cp      e
168+  0000 ~                                    ret     z
169+  0000 ~            .FullCompare:           ld      a,h
170+  0000 ~                                    xor     d
171+  0000 ~                                    and     $80
172+  0000 ~                                    jr      nz,.OppositeSigns   ; If opposite signs is a simple sign test
173+  0000 ~                                    ld      a,h                 ; same signs so a little simpler
174+  0000 ~                                    and     $80
175+  0000 ~                                    jp      z,cpHLDE            ; if h is positive then both are positive by here so just cpHLDE
176+  0000 ~                                    jp      cpABSDEHL           ; else we have to do ABScpDEHL
177+  0000 ~            .OppositeSigns:         ld      a,h
178+  0000 ~                                    and     $80
179+  0000 ~                                    and     $80
180+  0000 ~                                    jp      z,.HLGTDE
181+  0000 ~            .HLLTDE:                SetCarryFlag
182+  0000 ~                                    ret
183+  0000 ~            .HLGTDE:                ClearCarryFlag
184+  0000 ~                                    ret
185+  0000                                      ENDM
186+  0000
187+  0000              ;Unsigned
188+  0000              ;If HL == DE, then Z flag is set.
189+  0000              ;If HL != DE, then Z flag is reset.
190+  0000              ;If HL <  DE, then C flag is set.
191+  0000              ;If HL >= DE, then C flag is reset.
192+  0000              ;
193+  0000              ;Signed
194+  0000              ;If HL == DE, then Z flag is set.
195+  0000              ;If HL != DE, then Z flag is reset.
196+  0000              ;If HL <  DE, then S and P/V are different.
197+  0000              ;If HL >= DE, then S and P/V are the same.
198+  0000
199+  0000
200+  0000              N0equN1byN2div256:      MACRO param1,param2,param3
201+  0000 ~                                    ld      a,param3                        ;
202+  0000 ~                                    ld      e,a                         ; use e as var Q = value of XX15 [n] lo
203+  0000 ~                                    ld      a,param2                        ; A = XX16 element
204+  0000 ~                                    ld      d,a
205+  0000 ~                                    mul
206+  0000 ~                                    ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
207+  0000 ~                                    ld      (param1),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
208+  0000                                      ENDM
209+  0000
210+  0000              AequN1xorN2:            MACRO  param1,param2
211+  0000 ~                                    ld      a,(param1)
212+  0000 ~                                    xor     param2
213+  0000                                      ENDM
214+  0000
215+  0000              SpeedMulAxis:           MACRO   speedreg, axis
216+  0000 ~                                    ld      e,speedreg
217+  0000 ~                                    ld      hl,(axis)
218+  0000 ~                                    ld      a,h
219+  0000 ~                                    ClearSignBitA
220+  0000 ~                                    ld      d,a
221+  0000 ~                                    mul     de
222+  0000 ~                                    ld      a,h
223+  0000 ~                                    SignBitOnlyA
224+  0000 ~                                    ld      b,a;ld      c,a
225+  0000 ~                                    ld      h,d;ld      e,d
226+  0000 ~                                    ld      c,0;ld      d,0
227+  0000                                      ENDM
228+  0000
229+  0000              ; Adds speed (8 bit) to vertex (24 bit signed)
230+  0000              AddSpeedToVert:         MACRO   vertex
231+  0000 ~                                    ld      de,(vertex+1)
232+  0000 ~                                    ld      a,(vertex)
233+  0000 ~                                    ld      l,a
234+  0000 ~                                    call    AddBCHtoDELsigned               ; DEL = DEL + BCH
235+  0000 ~                                    ld      a,l
236+  0000 ~                                    ld      (vertex),a
237+  0000 ~                                    ld      (vertex+1),de
238+  0000                                      ENDM
# file closed: ../../Macros/MathsMacros.asm
 67   0000                                      INCLUDE "../../Macros/MMUMacros.asm"
# file opened: ../../Macros/MMUMacros.asm
  1+  0000              MMUSelectROM0:       MACRO
  2+  0000 ~                                 nextreg EXSDOSMMU0,        BankROM
  3+  0000                                   ENDM
  4+  0000
  5+  0000              MMUSelectROMS:       MACRO
  6+  0000 ~                                 nextreg EXSDOSMMU0,        BankROM
  7+  0000 ~                                 nextreg EXSDOSMMU1,        BankROM
  8+  0000                                   ENDM
  9+  0000
 10+  0000              MMUSelectMathsTables:MACRO
 11+  0000 ~                                 nextreg MathsTablesMMU,    BankMathsTables
 12+  0000                                   ENDM
 13+  0000
 14+  0000              MMUSelectKeyboard:   MACRO
 15+  0000 ~                                 nextreg KeyboardMMU,       BankKeyboard
 16+  0000                                   ENDM
 17+  0000
 18+  0000              MMUSelectSpriteBank: MACRO
 19+  0000 ~            					 nextreg SpritememMMU,	    BankSPRITE
 20+  0000              					 ENDM
 21+  0000
 22+  0000              MMUSelectConsoleBank: MACRO
 23+  0000 ~            					 nextreg ConsoleImageDataMMU,  BankConsole
 24+  0000              					 ENDM
 25+  0000
 26+  0000              MMUSelectLayer1: 	 MACRO
 27+  0000 ~            					 nextreg L1memMMU,		    BankLAYER1
 28+  0000              					 ENDM
 29+  0000
 30+  0000              MMUSelectLayer2: 	 MACRO
 31+  0000 ~            					 nextreg L2memMMU,		    BankLAYER2
 32+  0000              					 ENDM
 33+  0000
 34+  0000              MMUSelectResetUniv:  MACRO
 35+  0000 ~                                 nextreg ResetUniverseMMU, BankResetUniv
 36+  0000                                   ENDM
 37+  0000
 38+  0000              MMUSelectShipARead:  MACRO
 39+  0000 ~                                 add    a,BankUNIVDATA0
 40+  0000 ~                                 nextreg ShipReadMMU,       a
 41+  0000                                   ENDM
 42+  0000
 43+  0000              MMUSelectShipBank1:  MACRO
 44+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModels1
 45+  0000              					 ENDM
 46+  0000              MMUSelectShipBank2:  MACRO
 47+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModels2
 48+  0000              					 ENDM
 49+  0000              MMUSelectShipBank3:  MACRO
 50+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModels3
 51+  0000              					 ENDM
 52+  0000              MMUSelectShipBank4:  MACRO
 53+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModels4
 54+  0000              					 ENDM
 55+  0000
 56+  0000              MMUSelectShipBankA   MACRO
 57+  0000 ~            					 nextreg ShipModelMMU,	    a
 58+  0000              					 ENDM
 59+  0000
 60+  0000              MMUSelectShipBankN:  MACRO value
 61+  0000 ~            					 nextreg ShipModelMMU,	    value
 62+  0000              					 ENDM
 63+  0000
 64+  0000              MMUSelectCommander:	 MACRO
 65+  0000 ~                                 nextreg CommanderMMU,       BankCommander
 66+  0000              					 ENDM
 67+  0000
 68+  0000              MMUSelectStockTable: MACRO
 69+  0000 ~                                 nextreg StockTableMMU,     BankStockTable
 70+  0000              					 ENDM
 71+  0000
 72+  0000              MMUSelectCpySrcA:    MACRO
 73+  0000 ~                                 nextreg DMACpySourceMMU,	a
 74+  0000              					 ENDM
 75+  0000
 76+  0000              MMUSelectCpySrcN:    MACRO value
 77+  0000 ~                                 nextreg DMACpySourceMMU,	value
 78+  0000              					 ENDM
 79+  0000
 80+  0000              MMUSelectSun:        MACRO
 81+  0000 ~                                 nextreg SunMMU,            BankSunData
 82+  0000                                   ENDM
 83+  0000
 84+  0000              MMUSelectPlanet:     MACRO
 85+  0000 ~                                 nextreg PlanetMMU,         BankPlanetData
 86+  0000                                   ENDM
 87+  0000
 88+  0000              MMUSelectUniverseA:  MACRO
 89+  0000 ~                                 add    a,BankUNIVDATA0
 90+  0000 ~                                 nextreg UniverseMMU,       a
 91+  0000                                   ENDM
 92+  0000              ;Version that assumes a pre calulated A, used whn optimising many switches
 93+  0000              MMUSelectUnivBankA:  MACRO
 94+  0000 ~                                 nextreg UniverseMMU,       a
 95+  0000                                   ENDM
 96+  0000
 97+  0000              MMUSelectUniverseN:  MACRO value
 98+  0000 ~                                 nextreg UniverseMMU,       BankUNIVDATA0+value
 99+  0000                                   ENDM
100+  0000
101+  0000              MMUSelectSpaceStation: MACRO
102+  0000 ~                                 nextreg SpaceStationMMU,   BankSpaceStationData
103+  0000                                   ENDM
104+  0000
105+  0000              MMUSelectMathsBankedFns   MACRO
106+  0000 ~                                 nextreg MathsBankedFnsMMU, BankMathsBankedFns
107+  0000                                   ENDM
108+  0000
109+  0000              MMUSelectGalaxyA:    MACRO
110+  0000 ~                                 nextreg GalaxyDataMMU,     a
111+  0000                                   ENDM
112+  0000
113+  0000              MMUSelectGalaxyN:    MACRO value
114+  0000 ~                                 nextreg GalaxyDataMMU,     BankGalaxyData0+value
115+  0000                                   ENDM
116+  0000              MMUSelectGalaxyACopy:MACRO
117+  0000 ~                                 nextreg UniverseMMU,       a
118+  0000                                   ENDM
119+  0000
120+  0000              MMUSelectUniverseAbs:MACRO value
121+  0000 ~                                 nextreg UniverseMMU,       value
122+  0000                                   ENDM
123+  0000
124+  0000              MMUSelectMenuGalCht: MACRO
125+  0000 ~                                 nextreg MenuGalChtMMU,		BankMenuGalCht
126+  0000              					 ENDM
127+  0000
128+  0000              MMUSelectMenuShrCht: MACRO
129+  0000 ~            					 nextreg MenuShrChtMMU,		BankMenuShrCht
130+  0000              					 ENDM
131+  0000
132+  0000              MMUSelectMenuInvent: MACRO
133+  0000 ~                                 nextreg MenuInventMMU,		BankMenuInvent
134+  0000              					 ENDM
135+  0000
136+  0000              MMUSelectMenuSystem: MACRO
137+  0000 ~                                 nextreg MenuSystemMMU,		BankMenuSystem
138+  0000              					 ENDM
139+  0000
140+  0000              MMUSelectMenuMarket: MACRO
141+  0000 ~                                 nextreg MenuMarketMMU,		BankMenuMarket
142+  0000              					 ENDM
143+  0000
144+  0000              MMUSelectMenuStatus: MACRO
145+  0000 ~                                 nextreg MenuStatusMMU,		BankMenuStatus
146+  0000              					 ENDM
147+  0000
148+  0000              MMUSelectViewFront:  MACRO
149+  0000 ~                                 nextreg ScreenBankMMU,		BankFrontView
150+  0000              					 ENDM
151+  0000
152+  0000              MMUSelectScreenA:    MACRO
153+  0000 ~                                 nextreg ScreenBankMMU,		a
154+  0000              					 ENDM
155+  0000
156+  0000              MMUSelectSound:      MACRO
157+  0000 ~                                 nextreg SoundMMU,		    BankSound
158+  0000              					 ENDM
159+  0000
160+  0000
161+  0000
162+  0000              SaveMMU6:           MACRO
163+  0000 ~                                GetNextReg  MMU_SLOT_6_REGISTER
164+  0000 ~                                ld      (SavedMMU6),a
165+  0000                                  ENDM
166+  0000
167+  0000              RestoreMMU6:        MACRO
168+  0000 ~                                ld      a,(SavedMMU6)               ; now restore up post interrupt
169+  0000 ~                                nextreg MMU_SLOT_6_REGISTER,a       ; Restore MMU7
170+  0000                                  ENDM
171+  0000
172+  0000              SaveMMU7:           MACRO
173+  0000 ~                                GetNextReg  MMU_SLOT_7_REGISTER
174+  0000 ~                                ld      (SavedMMU7),a
175+  0000                                  ENDM
176+  0000
177+  0000              RestoreMMU7:        MACRO
178+  0000 ~                                ld      a,(SavedMMU7)               ; now restore up post interrupt
179+  0000 ~                                nextreg MMU_SLOT_7_REGISTER,a       ; Restore MMU7
180+  0000                                  ENDM
# file closed: ../../Macros/MMUMacros.asm
 68   0000                                      INCLUDE "../../Macros/NegateMacros.asm"
# file opened: ../../Macros/NegateMacros.asm
  1+  0000
  2+  0000              macronegate16hl:	MACRO
  3+  0000 ~            					xor 	a
  4+  0000 ~            					sub 	l
  5+  0000 ~            					ld 		l,a
  6+  0000 ~            					sbc 	a,a
  7+  0000 ~            					sub 	h
  8+  0000 ~            					ld 		h,a
  9+  0000              					ENDM
 10+  0000
 11+  0000
 12+  0000              macroAbsHL:         MACRO
 13+  0000 ~                                bit     7,h
 14+  0000 ~                                jp      z,.alreadyABS
 15+  0000 ~            					xor 	a
 16+  0000 ~            					sub 	l
 17+  0000 ~            					ld 		l,a
 18+  0000 ~            					sbc 	a,a
 19+  0000 ~            					sub 	h
 20+  0000 ~            					ld 		h,a
 21+  0000 ~            .alreadyABS:
 22+  0000                                  ENDM
 23+  0000
 24+  0000              macronegate16de:	MACRO
 25+  0000 ~            					xor 	a
 26+  0000 ~                                sub 	e
 27+  0000 ~                                ld 		e,a
 28+  0000 ~                                sbc 	a,a
 29+  0000 ~                                sub 	d
 30+  0000 ~                                ld 		d,a
 31+  0000              					ENDM
 32+  0000
 33+  0000              macronegate16bc:	MACRO
 34+  0000 ~            					xor 	a
 35+  0000 ~                                sub 	c
 36+  0000 ~                                ld 		c,a
 37+  0000 ~                                sbc 	a,a
 38+  0000 ~                                sub 	b
 39+  0000 ~                                ld 		b,a
 40+  0000              					ENDM
 41+  0000
 42+  0000              macronegate16ix:	MACRO
 43+  0000 ~            					xor 	a
 44+  0000 ~                                sub 	ixl
 45+  0000 ~                                ld 		ixl,a
 46+  0000 ~                                sbc 	a,a
 47+  0000 ~                                sub 	ixh
 48+  0000 ~                                ld 		ixh,a
 49+  0000              					ENDM
 50+  0000
 51+  0000
 52+  0000              NegIY:			    MACRO
 53+  0000 ~                                xor a
 54+  0000 ~                                sub iyl
 55+  0000 ~                                ld iyl,a
 56+  0000 ~                                sbc a,a
 57+  0000 ~                                sub iyh
 58+  0000 ~                                ld iyh,a
 59+  0000                                  ENDM
 60+  0000
 61+  0000              NegHL:			    MACRO
 62+  0000 ~                                xor a
 63+  0000 ~                                sub l
 64+  0000 ~                                ld l,a
 65+  0000 ~                                sbc a,a
 66+  0000 ~                                sub h
 67+  0000 ~                                ld h,a
 68+  0000                                  ENDM
 69+  0000
 70+  0000              NegDE:			    MACRO
 71+  0000 ~                                xor a
 72+  0000 ~                                sub e
 73+  0000 ~                                ld e,a
 74+  0000 ~                                sbc a,a
 75+  0000 ~                                sub d
 76+  0000 ~                                ld d,a
 77+  0000                                  ENDM
 78+  0000
 79+  0000              NegBC:			    MACRO
 80+  0000 ~                                xor a
 81+  0000 ~                                sub c
 82+  0000 ~                                ld c,a
 83+  0000 ~                                sbc a,a
 84+  0000 ~                                sub  b
 85+  0000 ~                                ld b,a
 86+  0000                                  ENDM
 87+  0000
 88+  0000              NegH                MACRO
 89+  0000 ~                                ld      a,h
 90+  0000 ~                                neg
 91+  0000 ~                                ld      h,a
 92+  0000                                  ENDM
 93+  0000
 94+  0000              NegD                MACRO
 95+  0000 ~                                ld      a,d
 96+  0000 ~                                neg
 97+  0000 ~                                ld      d,a
 98+  0000                                  ENDM
 99+  0000
100+  0000              NegB                MACRO
101+  0000 ~                                ld      a,b
102+  0000 ~                                neg
103+  0000 ~                                ld      b,a
104+  0000                                  ENDM
105+  0000
# file closed: ../../Macros/NegateMacros.asm
 69   0000                                      INCLUDE "../../Macros/returnMacros.asm"
# file opened: ../../Macros/returnMacros.asm
  1+  0000              ReturnIfHLNegative:     MACRO   target
  2+  0000 ~                                    bit     7,h
  3+  0000 ~                                    ret     nz
  4+  0000                                      ENDM
  5+  0000
  6+  0000              ReturnIfDENegative:     MACRO   target
  7+  0000 ~                                    bit     7,d
  8+  0000 ~                                    ret     nz
  9+  0000                                      ENDM
 10+  0000
 11+  0000              ReturnOnBitSet:         MACRO  reg, bitnbr
 12+  0000 ~                                    bit 	bitnbr,reg
 13+  0000 ~                                    ret     nz
 14+  0000                                      ENDM
 15+  0000
 16+  0000              ReturnOnMemBitSet:      MACRO mem, bitnbr
 17+  0000 ~                                    ld   a,(mem)
 18+  0000 ~                                    bit 	bitnbr,a
 19+  0000 ~                                    ret     nz
 20+  0000                                      ENDM
 21+  0000
 22+  0000              ReturnOnBitClear:       MACRO reg, bitnbr
 23+  0000 ~                                    bit 	bitnbr,reg
 24+  0000 ~                                    ret		z
 25+  0000                                      ENDM
 26+  0000
 27+  0000              ReturnOnMemBitClear:    MACRO mem, bitnbr
 28+  0000 ~                                    ld     a,(mem)
 29+  0000 ~                                    bit 	bitnbr,a
 30+  0000 ~                                    ret		z
 31+  0000                                      ENDM
 32+  0000
 33+  0000              ReturnIfMemFalse:       MACRO   mem
 34+  0000 ~                                    ld      a,(mem)
 35+  0000 ~                                    and     a
 36+  0000 ~                                    ret     nz
 37+  0000                                      ENDM
 38+  0000
 39+  0000              ReturnIfMemTrue:        MACRO   mem
 40+  0000 ~                                    ld      a,(mem)
 41+  0000 ~                                    and     a
 42+  0000 ~                                    ret     z
 43+  0000                                      ENDM
 44+  0000
 45+  0000              ReturnIfAIsZero:        MACRO
 46+  0000 ~                                    and     a
 47+  0000 ~                                    ret     z
 48+  0000                                      ENDM
 49+  0000
 50+  0000              ReturnIfMemisZero:      MACRO mem
 51+  0000 ~                                    ld   a,(mem)
 52+  0000 ~                                    and a
 53+  0000 ~                                    ret    z
 54+  0000                                      ENDM
 55+  0000
 56+  0000              ReturnIfMemIsNegative:  MACRO mem
 57+  0000 ~                                    ld      a,(mem)
 58+  0000 ~                                    and     $80
 59+  0000 ~                                    ret     nz
 60+  0000                                      ENDM
 61+  0000
 62+  0000              ReturnIfBitMaskClear    MACRO   bitmask
 63+  0000 ~                                    and     bitmask
 64+  0000 ~                                    ret     z
 65+  0000                                      ENDM
 66+  0000
 67+  0000              ReturnIfBitMaskSet      MACRO   bitmask
 68+  0000 ~                                    and     bitmask
 69+  0000 ~                                    ret     nz
 70+  0000                                      ENDM
 71+  0000
 72+  0000              ReturnIfMemEquN:        MACRO mem, value
 73+  0000 ~                                    ld     a,(mem)
 74+  0000 ~                                    cp     value
 75+  0000 ~                                    ret    nz
 76+  0000                                      ENDM
 77+  0000
 78+  0000              ReturnIfMemNeNusng:     MACRO mem, value
 79+  0000 ~                                    ld   a,(mem)
 80+  0000 ~                                    cp     value
 81+  0000 ~                                    ret    z
 82+  0000                                      ENDM
 83+  0000
 84+  0000              ReturnIfRegNotZero:     MACRO reg
 85+  0000 ~                                    ld      a, reg
 86+  0000 ~                                    and     a
 87+  0000 ~                                    ret     nz
 88+  0000                                      ENDM
 89+  0000
 90+  0000              ReturnIfANotZero:       MACRO
 91+  0000 ~                                    and     a
 92+  0000 ~                                    ret     nz
 93+  0000                                      ENDM
 94+  0000
 95+  0000              ReturnIfNotZero:        MACRO
 96+  0000 ~                                    ret     nz
 97+  0000                                      ENDM
 98+  0000
 99+  0000              ReturnIfZero:           MACRO
100+  0000 ~                                    ret     z
101+  0000                                      ENDM
102+  0000
103+  0000              ReturnIfNegative:       MACRO
104+  0000 ~                                    ret     m
105+  0000                                      ENDM
106+  0000
107+  0000
108+  0000              ReturnIfMemNotZero:     MACRO mem
109+  0000 ~                                    ld     a,(mem)
110+  0000 ~                                    and     a
111+  0000 ~                                    ret    nz
112+  0000                                      ENDM
113+  0000
114+  0000              ReturnIfAGTEusng:       MACRO value
115+  0000 ~                                    cp    value
116+  0000 ~                                    ret	 nc
117+  0000                                      ENDM
118+  0000
119+  0000              ReturnIfRegLTNusng:     MACRO reg, value
120+  0000 ~                                    ld      a,reg
121+  0000 ~                                    cp      value
122+  0000 ~                                    ret	    c
123+  0000                                      ENDM
124+  0000
125+  0000              ReturnIfALTNusng:       MACRO value
126+  0000 ~                                    cp    value
127+  0000 ~                                    ret	 c
128+  0000                                      ENDM
129+  0000
130+  0000              ReturnIfAGTENusng:      MACRO value
131+  0000 ~                                    cp    value
132+  0000 ~                                    ret	 nc
133+  0000                                      ENDM
134+  0000
135+  0000              ReturnIfAGTEMemusng:    MACRO value
136+  0000 ~                                    ld      hl,value
137+  0000 ~                                    cp      (hl)
138+  0000 ~                                    ret	    nc
139+  0000                                      ENDM
140+  0000
141+  0000              ReturnIfANENusng:       MACRO value
142+  0000 ~                                    cp      value
143+  0000 ~                                    ret     nz
144+  0000                                      ENDM
145+  0000
146+  0000              ReturnIfAEqNusng:       MACRO value
147+  0000 ~                                    cp      value
148+  0000 ~                                    ret     z
149+  0000                                      ENDM
150+  0000
# file closed: ../../Macros/returnMacros.asm
 70   0000                                      INCLUDE "../../Macros/ShiftMacros.asm"
# file opened: ../../Macros/ShiftMacros.asm
  1+  0000              ShiftIYRight1: MACRO
  2+  0000 ~            			   ld 	a,iyh
  3+  0000 ~            			   srl 	a
  4+  0000 ~            			   ld	iyh,a
  5+  0000 ~            			   ld 	a,iyl
  6+  0000 ~            			   rra
  7+  0000 ~            			   ld	iyl,a
  8+  0000              			   ENDM
  9+  0000
 10+  0000              ShiftIXRight1: MACRO
 11+  0000 ~            			   ld 	a,ixh
 12+  0000 ~            			   srl 	a
 13+  0000 ~            			   ld	ixh,a
 14+  0000 ~            			   ld 	a,ixl
 15+  0000 ~            			   rra
 16+  0000 ~            			   ld	ixl,a
 17+  0000              			   ENDM
 18+  0000
 19+  0000              ShiftIXhHLRight1: MACRO
 20+  0000 ~                           ld  a,ixh
 21+  0000 ~                           srl a
 22+  0000 ~                           ld  ixh,a
 23+  0000 ~            			   rr  h
 24+  0000 ~            			   rr  l
 25+  0000              			   ENDM
 26+  0000
 27+  0000              ShiftIYhDERight1: MACRO
 28+  0000 ~                           ld  a,iyh
 29+  0000 ~                           srl a
 30+  0000 ~                           ld  iyh,a
 31+  0000 ~                           rr  d
 32+  0000 ~            			   rr  e
 33+  0000              			   ENDM
 34+  0000
 35+  0000              ShiftIYlBCRight1: MACRO
 36+  0000 ~                           ld  a,iyl
 37+  0000 ~                           srl a
 38+  0000 ~                           ld  iyl,a
 39+  0000 ~            			   rr  b
 40+  0000 ~                           rr  c
 41+  0000              			   ENDM
 42+  0000
 43+  0000              ShiftIXlBCRight1: MACRO
 44+  0000 ~                           ld  a,ixl
 45+  0000 ~                           srl a
 46+  0000 ~                           ld  ixl,a
 47+  0000 ~            			   rr  b
 48+  0000 ~                           rr  c
 49+  0000              			   ENDM
 50+  0000
 51+  0000              ShiftHLRight1: MACRO
 52+  0000 ~            			   srl h
 53+  0000 ~            			   rr  l
 54+  0000              			   ENDM
 55+  0000
 56+  0000              ShiftDERight1: MACRO
 57+  0000 ~            			   srl d
 58+  0000 ~            			   rr  e
 59+  0000              			   ENDM
 60+  0000
 61+  0000              ShiftBCRight1: MACRO
 62+  0000 ~            			   srl b
 63+  0000 ~            			   rr  c
 64+  0000              			   ENDM
 65+  0000
 66+  0000
 67+  0000
 68+  0000              ShiftHLDiv8:   MACRO
 69+  0000 ~            			   srl h
 70+  0000 ~            			   rr  l
 71+  0000 ~            			   srl h
 72+  0000 ~            			   rr  l
 73+  0000 ~            			   srl h
 74+  0000 ~            			   rr  l
 75+  0000              			   ENDM
 76+  0000
 77+  0000              ShiftHLLeft1:  MACRO    ; 16 T states
 78+  0000 ~            			   sla l
 79+  0000 ~            			   rl  h
 80+  0000              			   ENDM
 81+  0000
 82+  0000              ShiftDELeft1:  MACRO    ; 16 T states
 83+  0000 ~            			   sla e
 84+  0000 ~            			   rl  d
 85+  0000              			   ENDM
 86+  0000
 87+  0000              BarrelHLLeft3: MACRO
 88+  0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
 89+  0000 ~                           push     bc      ; 10
 90+  0000 ~                           ld       b,3     ; 7
 91+  0000 ~                           bsrl     de,b    ; 8
 92+  0000 ~                           pop      bc      ; 10
 93+  0000 ~                           ex       de,hl   ; 4
 94+  0000                             ENDM
 95+  0000
 96+  0000              BarrelHLRight3: MACRO
 97+  0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
 98+  0000 ~                           push     bc      ; 10
 99+  0000 ~                           ld       b,3     ; 7
100+  0000 ~                           bsrl     de,b    ; 8
101+  0000 ~                           pop      bc      ; 10
102+  0000 ~                           ex       de,hl   ; 4
103+  0000                             ENDM
104+  0000
105+  0000              RollBCLeft1:   MACRO	; 16 T states
106+  0000 ~                           rl  c
107+  0000 ~                           rl  b
108+  0000                             ENDM
109+  0000
110+  0000              RollDELeft1:   MACRO	; 16 T states
111+  0000 ~                           rl  e
112+  0000 ~                           rl  d
113+  0000                             ENDM
114+  0000
115+  0000              ShiftBCLeft1:  MACRO    ; 16 T states
116+  0000 ~            			   sla c
117+  0000 ~            			   rl  b
118+  0000              			   ENDM
119+  0000
120+  0000              ShiftLeftMem:       MACRO   reg
121+  0000 ~                                ld      hl,reg
122+  0000 ~                                sla     (hl)
123+  0000                                  ENDM
124+  0000
125+  0000
126+  0000
127+  0000              ShiftMem16Right1:   MACRO memaddr
128+  0000 ~                                ld    hl,(memaddr)
129+  0000 ~                                srl   h
130+  0000 ~                                rr    l
131+  0000 ~                                ld    (memaddr),hl
132+  0000                                  ENDM
133+  0000
134+  0000              ShiftMem8Right1:    MACRO memaddr
135+  0000 ~                                ld      a,(memaddr)
136+  0000 ~                                srl     a
137+  0000 ~                                ld      (memaddr),a
138+  0000                                  ENDM
139+  0000
140+  0000
141+  0000              ShiftMem8Left1A:    MACRO memaddr
142+  0000 ~                                ld      a,(memaddr)
143+  0000 ~                                sla     a
144+  0000 ~                                ld      (memaddr),a
145+  0000                                  ENDM
146+  0000
# file closed: ../../Macros/ShiftMacros.asm
 71   0000                                      INCLUDE "../../Macros/signBitMacros.asm"
# file opened: ../../Macros/signBitMacros.asm
  1+  0000              SetMemBitN              MACRO mem,bitnbr
  2+  0000 ~                                    ld      hl,mem
  3+  0000 ~                                    set     bitnbr,(hl)
  4+  0000                                      ENDM
  5+  0000
  6+  0000              ClearMemBitN            MACRO mem,bitnbr
  7+  0000 ~                                    ld      hl,mem
  8+  0000 ~                                    res     bitnbr,(hl)
  9+  0000                                      ENDM
 10+  0000
 11+  0000
 12+  0000              ClearSignBitMem:        MACRO mem
 13+  0000 ~                                    ld      a,(mem)
 14+  0000 ~                                    and     SignMask8Bit
 15+  0000 ~                                    ld      (mem),a
 16+  0000                                      ENDM
 17+  0000
 18+  0000              SetSignBitMem:          MACRO   mem
 19+  0000 ~                                    ld      a,(mem)
 20+  0000 ~                                    or      SignOnly8Bit
 21+  0000 ~                                    ld      (mem),a
 22+  0000                                      ENDM
 23+  0000
 24+  0000              FlipSignMem:            MACRO mem
 25+  0000 ~                                    ld  a,(mem)
 26+  0000 ~                                    xor SignOnly8Bit
 27+  0000 ~                                    ld  (mem),a
 28+  0000                                      ENDM
 29+  0000
 30+  0000              SignBitOnlyMem:         MACRO mem
 31+  0000 ~                                    ld      a, (mem)
 32+  0000 ~                                    and     SignOnly8Bit
 33+  0000 ~                                    ld      (mem),a
 34+  0000                                      ENDM
 35+  0000
 36+  0000              ClearSignBit:           MACRO reg
 37+  0000 ~                                    ld      a,reg
 38+  0000 ~                                    and     SignMask8Bit
 39+  0000 ~                                    ld      reg,a
 40+  0000                                      ENDM
 41+  0000
 42+  0000              SetSignBit:             MACRO   reg
 43+  0000 ~                                    ld      a,reg
 44+  0000 ~                                    or      SignOnly8Bit
 45+  0000 ~                                    ld      reg,a
 46+  0000                                      ENDM
 47+  0000
 48+  0000              FlipSignBit:            MACRO   reg
 49+  0000 ~                                    ld      a, reg
 50+  0000 ~                                    xor     SignOnly8Bit
 51+  0000 ~                                    ld      reg,a
 52+  0000                                      ENDM
 53+  0000
 54+  0000              SignBitOnly:            MACRO   reg
 55+  0000 ~                                    ld      a, reg
 56+  0000 ~                                    and     SignOnly8Bit
 57+  0000 ~                                    ld      reg,a
 58+  0000                                      ENDM
 59+  0000
 60+  0000              ClearSignBitA:          MACRO
 61+  0000 ~                                    and     SignMask8Bit
 62+  0000                                      ENDM
 63+  0000
 64+  0000              SetSignBitA:            MACRO
 65+  0000 ~                                    or      SignOnly8Bit
 66+  0000                                      ENDM
 67+  0000
 68+  0000              FlipSignBitA:           MACRO
 69+  0000 ~                                    xor     SignOnly8Bit
 70+  0000                                      ENDM
 71+  0000
 72+  0000              SignBitOnlyA:           MACRO
 73+  0000 ~                                    and     SignOnly8Bit
 74+  0000                                      ENDM
# file closed: ../../Macros/signBitMacros.asm
 72   0000                                      INCLUDE "../../Macros/print_text_macros.asm"
# file opened: ../../Macros/print_text_macros.asm
  1+  0000
  2+  0000              print_msg_at_de_at_b_hl_macro:  MACRO   varcolour
  3+  0000 ~                                    ld      c,varcolour
  4+  0000 ~                                    call    l2_print_at_320
  5+  0000                                      ENDM
  6+  0000
  7+  0000              print_msg_ld_bc_at_de_macro:  MACRO  varcol
  8+  0000 ~                                    ld      hl,varcol
  9+  0000 ~                                    call    l2_print_at_320
 10+  0000                                      ENDM
 11+  0000
 12+  0000              print_msg_at_de_macro:  MACRO   varcolour, varrow, varcol
 13+  0000 ~                                    ld      c,varcolour
 14+  0000 ~                                    ld      b,varrow
 15+  0000 ~                                    ld      hl,varcol
 16+  0000 ~                                    call    l2_print_at_320
 17+  0000                                      ENDM
 18+  0000
 19+  0000              print_msg_ld_bc_macro:  MACRO   varcol, varmessage
 20+  0000 ~                                    ld      hl,varcol
 21+  0000 ~                                    ld      de,varmessage
 22+  0000 ~                                    call    l2_print_at_320
 23+  0000                                      ENDM
 24+  0000
 25+  0000              print_msg_macro:        MACRO   varcolour, varrow, varcol, varmessage
 26+  0000 ~                                    ld      c,varcolour
 27+  0000 ~                                    ld      b,varrow
 28+  0000 ~                                    ld      hl,varcol
 29+  0000 ~                                    ld      de,varmessage
 30+  0000 ~                                    call    l2_print_at_320
 31+  0000                                      ENDM
 32+  0000
 33+  0000              print_msg_wrap_macro:   MACRO   varcolour, varrow, varcol, varmessage
 34+  0000 ~                                    ld      c,varcolour
 35+  0000 ~                                    ld      b,varrow
 36+  0000 ~                                    ld      hl,varcol
 37+  0000 ~                                    ld      de,varmessage
 38+  0000 ~                                    call    l2_print_at_wrap_320
 39+  0000                                      ENDM
 40+  0000
# file closed: ../../Macros/print_text_macros.asm
 73   0000
 74   0000              MessageAt:              MACRO   x,y,message
 75   0000 ~                                    push    af,,bc,,de,,hl
 76   0000 ~                                    ld      d,y
 77   0000 ~                                    ld      e,x*8
 78   0000 ~                                    ld      hl,message
 79   0000 ~                                    call    l1_print_at_char_wrap
 80   0000 ~                                    pop     af,,bc,,de,,hl
 81   0000                                      ENDM
 82   0000
 83   0000              PrintHexARegAt:         MACRO   x,y
 84   0000 ~                                    push    af,,bc,,de,,hl
 85   0000 ~                                    ld      d,y
 86   0000 ~                                    ld      e,x*8
 87   0000 ~                                    call    l1_print_u8_hex_at_char
 88   0000 ~                                    pop     af,,bc,,de,,hl
 89   0000                                      ENDM
 90   0000
 91   0000              SetBorder:              MACRO   value
 92   0000 ~                                    ld          a,value
 93   0000 ~                                    call        l1_set_border
 94   0000                                      ENDM
 95   0000
 96   0000              DumpDataTest:           MACRO   command, recordcount, recordlen, dataaddr
 97   0000 ~                                    ld      a,recordcount
 98   0000 ~                                    ld      d,a
 99   0000 ~                                    ld      e,recordlen
100   0000 ~                                    mul     de
101   0000 ~                                    ld      hl,dataaddr
102   0000 ~                                    ld      a,command
103   0000 ~                                    call    ENPiDumpDataTest
104   0000                                      ENDM
105   0000              DumpDataToPi:           MACRO   command, recordcount, recordlen, dataaddr
106   0000 ~                                    ld      a,recordcount
107   0000 ~                                    ld      d,a
108   0000 ~                                    ld      e,recordlen
109   0000 ~                                    mul     de
110   0000 ~                                    ld      hl,dataaddr
111   0000 ~                                    ld      a,command
112   0000 ~                                    call    ENPiDumpData
113   0000                                      ENDM
114   0000
115   0000
116   0000              charactersetaddr		equ 15360
117   0000              STEPDEBUG               equ 1
118   0000
119   0000              TopOfStack              equ $5CCB ;$6100
120   0000
121   0000                                      ORG $5DCB;      $6200
122   5DCB F3           EliteNextStartup:       di
123   5DCC ED 91 07 03  .InitialiseClockSpeed:  nextreg     TURBO_MODE_REGISTER,Speed_28MHZ
124   5DD0              .InitialiseLayerOrder:  DISPLAY "Starting Assembly At ", EliteNextStartup
125   5DD0                                      ; "STARTUP"
126   5DD0                                      ; Make sure  rom is in page 0 during load
127   5DD0 ED 91 15 05                          nextreg 	SPRITE_LAYERS_SYSTEM_REGISTER,%00000101 ; ULS
128   5DD4                                      SetBorder   0
128   5DD4 3E 00       >                        ld          a,0
128   5DD6 CD 44 6C    >                        call        l1_set_border
129   5DD9 CD 1F 6C                             call        l1_cls
130   5DDC 3E 07                                ld          a,7
131   5DDE CD 3A 6C                             call        l1_attr_cls_to_a
132   5DE1 ED 91 06 01  .InitialisePeripherals: nextreg     PERIPHERAL_2_REGISTER, AUDIO_CHIPMODE_AY ; Enable Turbo Sound
133   5DE5 ED 91 08 52                          nextreg     PERIPHERAL_3_REGISTER, DISABLE_RAM_IO_CONTENTION | ENABLE_TURBO_SOUND | INTERNAL_SPEAKER_ENABLE
134   5DE9 ED 91 09 00                          nextreg     PERIPHERAL_4_REGISTER, %00000000
135   5DED ED 91 68 10                          nextreg     ULA_CONTROL_REGISTER,  %00010000                ; set up ULA CONRTROL may need to change bit 0 at least, but bit 4 is separate extended keys from main matrix
136   5DF1              .InitialisingMessage:   MessageAt   0,0,InitialiseMessage
136   5DF1 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
136   5DF5 16 00       >                        ld      d,0
136   5DF7 1E 00       >                        ld      e,0*8
136   5DF9 21 96 5E    >                        ld      hl,InitialiseMessage
136   5DFC CD 7F 6E    >                        call    l1_print_at_char_wrap
136   5DFF E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
137   5E03 CD A9 68                             call        PiReset
138   5E06                                      MessageAt   15,0,ResetMessage
138   5E06 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
138   5E0A 16 00       >                        ld      d,0
138   5E0C 1E 78       >                        ld      e,15*8
138   5E0E 21 9F 5E    >                        ld      hl,ResetMessage
138   5E11 CD 7F 6E    >                        call    l1_print_at_char_wrap
138   5E14 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
139   5E18 DD 01                                break
140   5E1A CD DE 6E                             call        WaitForAnyKey
141   5E1D              DumpTest:               DumpDataTest $F0, (LineHeapSize), 5, LineHeap
141   5E1D 3A A9 5E    >                        ld      a,(LineHeapSize)
141   5E20 57          >                        ld      d,a
141   5E21 1E 05       >                        ld      e,5
141   5E23 ED 30       >                        mul     de
141   5E25 21 AA 5E    >                        ld      hl,LineHeap
141   5E28 3E F0       >                        ld      a,$F0
141   5E2A CD 4D 67    >                        call    ENPiDumpDataTest
142   5E2D CD DE 6E                             call        WaitForAnyKey
143   5E30
144   5E30 CD AA 63     TestCode:               call        ENPiHello
145   5E33 CD DE 6E                             call        WaitForAnyKey
146   5E36 CD 1F 6C                             call        l1_cls
147   5E39 CD 30 64                             call        ENPiPingTest
148   5E3C CD DE 6E                             call        WaitForAnyKey
149   5E3F CD 1F 6C                             call        l1_cls
150   5E42 3E 01                                ld          a,1
151   5E44 32 A7 5E                             ld          (Var_ViewPort),a
152   5E47 CD 87 64                             call        ENPiSetView
153   5E4A CD DE 6E                             call        WaitForAnyKey
154   5E4D CD 1F 6C                             call        l1_cls
155   5E50 CD A0 66                             call        ENPiPlayerInput
156   5E53 CD DE 6E                             call        WaitForAnyKey
157   5E56 CD 1F 6C                             call        l1_cls
158   5E59 CD 0B 66                             call        ENPiAddShip
159   5E5C CD DE 6E                             call        WaitForAnyKey
160   5E5F CD 1F 6C                             call        l1_cls
161   5E62 CD AE 66                             call        ENPiUpdateUniverse
162   5E65 CD DE 6E                             call        WaitForAnyKey
163   5E68 CD 1F 6C                             call        l1_cls
164   5E6B CD E1 65                             call        ENPiFireECM
165   5E6E CD DE 6E                             call        WaitForAnyKey
166   5E71 CD 1F 6C                             call        l1_cls
167   5E74 CD DC 64                             call        ENPiRenderData
168   5E77 CD DE 6E                             call        WaitForAnyKey
169   5E7A                                      DumpDataToPi $F0, (LineHeapSize), 5, LineHeap
169   5E7A 3A A9 5E    >                        ld      a,(LineHeapSize)
169   5E7D 57          >                        ld      d,a
169   5E7E 1E 05       >                        ld      e,5
169   5E80 ED 30       >                        mul     de
169   5E82 21 AA 5E    >                        ld      hl,LineHeap
169   5E85 3E F0       >                        ld      a,$F0
169   5E87 CD 3D 67    >                        call    ENPiDumpData
170   5E8A CD DE 6E                             call        WaitForAnyKey
171   5E8D CD 1F 6C                             call        l1_cls
172   5E90 CD 87 64                             call        ENPiSetView ; to test that redner data was OK
173   5E93 C3 93 5E     EndLoop:                jp          EndLoop
174   5E96 53 74 61 72  InitialiseMessage:      db 'Starting',0
174   5E9A 74 69 6E 67
174   5E9E 00
175   5E9F 50 69 52 65  ResetMessage:           db 'PiReset',0
175   5EA3 73 65 74 00
176   5EA7              ;--------------------------------------------------------------------------------------
177   5EA7              ; Elite Pi Commands
178   5EA7              ;
179   5EA7 00           Var_ViewPort:           DB      0
180   5EA8 00           Var_BYTE                DB      0
181   5EA9              PiSendCommand:          MACRO   cmd
182   5EA9 ~                                    ld      d,cmd
183   5EA9 ~                                    call    PiWriteByte
184   5EA9                                      ENDM
185   5EA9              PiSendShortDataBlock:   MACRO   dataAddr, dataLen
186   5EA9 ~                                    ld      hl,dataAddr
187   5EA9 ~                                    ld      b,dataLen
188   5EA9 ~                                    call    PiWriteDataBlock
189   5EA9                                      ENDM
190   5EA9
191   5EA9              ;--------------------------------------------------------------------------------------
192   5EA9              ;Receiving data heap
193   5EA9              ; Size aliases
194   5EA9              CloudHeapSize:
195   5EA9              CompassHeapSize:
196   5EA9              PositionHeapSize:
197   5EA9              MatrixHeapSize:
198   5EA9              LaserHeapSize:
199   5EA9              ScannerDataSize:
200   5EA9 00           LineHeapSize:           DB      0
201   5EAA              ; Data aliases
202   5EAA              CloudHeap:              ; DS      4 * 16
203   5EAA              LaserHeap:
204   5EAA              MatrixHeap:
205   5EAA              PositionHeap:
206   5EAA              CompassHeap:
207   5EAA              StatusHeap:
208   5EAA              ScannerHeap:            ; DS (3*15) + 9                       ; so its ships + star, planet,scanner, data size determins the poitn where it bedomes star data
209   5EAA 00 00 00...  LineHeap:               DS      256*5
210   63AA              ;--------------------------------------------------------------------------------------
211   63AA              ENPiHello:              MessageAt 0,2,CommandMessage
211   63AA F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
211   63AE 16 02       >                        ld      d,2
211   63B0 1E 00       >                        ld      e,0*8
211   63B2 21 5F 67    >                        ld      hl,CommandMessage
211   63B5 CD 7F 6E    >                        call    l1_print_at_char_wrap
211   63B8 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
212   63BC                                      PiSendCommand   1
212   63BC 16 01       >                        ld      d,1
212   63BE CD C9 68    >                        call    PiWriteByte
213   63C1                                      MessageAt 9,2,SentMessage
213   63C1 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
213   63C5 16 02       >                        ld      d,2
213   63C7 1E 48       >                        ld      e,9*8
213   63C9 21 67 67    >                        ld      hl,SentMessage
213   63CC CD 7F 6E    >                        call    l1_print_at_char_wrap
213   63CF E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
214   63D3                                      MessageAt 13,2,HelloMessage
214   63D3 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
214   63D7 16 02       >                        ld      d,2
214   63D9 1E 68       >                        ld      e,13*8
214   63DB 21 59 67    >                        ld      hl,HelloMessage
214   63DE CD 7F 6E    >                        call    l1_print_at_char_wrap
214   63E1 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
215   63E5 21 59 67                             ld      hl,HelloMessage
216   63E8 06 05                                ld      b,5             ; 5 characters
217   63EA 1E 01                                ld      e,1             ; fixed, no terminating 0
218   63EC CD 08 6B                             call    PiWriteString
219   63EF                                      MessageAt 18,2,SentHello
219   63EF F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
219   63F3 16 02       >                        ld      d,2
219   63F5 1E 90       >                        ld      e,18*8
219   63F7 21 6C 67    >                        ld      hl,SentHello
219   63FA CD 7F 6E    >                        call    l1_print_at_char_wrap
219   63FD E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
220   6401                                      MessageAt 22,2,ReadingMessage
220   6401 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
220   6405 16 02       >                        ld      d,2
220   6407 1E B0       >                        ld      e,22*8
220   6409 21 79 67    >                        ld      hl,ReadingMessage
220   640C CD 7F 6E    >                        call    l1_print_at_char_wrap
220   640F E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
221   6413 21 88 67                             ld      hl,HelloResponse
222   6416 16 05                                ld      d,5             ; 5 characters
223   6418 1E 01                                ld      e,1             ; fixed, no terminating 0
224   641A CD 1A 6B                             call    PiReadString
225   641D                                      MessageAt  0,3,HelloResponse
225   641D F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
225   6421 16 03       >                        ld      d,3
225   6423 1E 00       >                        ld      e,0*8
225   6425 21 88 67    >                        ld      hl,HelloResponse
225   6428 CD 7F 6E    >                        call    l1_print_at_char_wrap
225   642B E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
226   642F C9                                   ret
227   6430              ;--------------------------------------------------------------------------------------
228   6430              ENPiPingTest:           MessageAt 0,4,CommandMessage
228   6430 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
228   6434 16 04       >                        ld      d,4
228   6436 1E 00       >                        ld      e,0*8
228   6438 21 5F 67    >                        ld      hl,CommandMessage
228   643B CD 7F 6E    >                        call    l1_print_at_char_wrap
228   643E E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
229   6442                                      PiSendCommand 2
229   6442 16 02       >                        ld      d,2
229   6444 CD C9 68    >                        call    PiWriteByte
230   6447                                      MessageAt 9,4,SentMessage
230   6447 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
230   644B 16 04       >                        ld      d,4
230   644D 1E 48       >                        ld      e,9*8
230   644F 21 67 67    >                        ld      hl,SentMessage
230   6452 CD 7F 6E    >                        call    l1_print_at_char_wrap
230   6455 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
231   6459                                      MessageAt 13,4,PingMessage
231   6459 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
231   645D 16 04       >                        ld      d,4
231   645F 1E 68       >                        ld      e,13*8
231   6461 21 81 67    >                        ld      hl,PingMessage
231   6464 CD 7F 6E    >                        call    l1_print_at_char_wrap
231   6467 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
232   646B CD A7 69                             call    PiReadByte
233   646E 21 B5 67                             ld      hl,PingCode
234   6471 C6 30                                add     a,'0'
235   6473 77                                   ld      (hl),a
236   6474                                      MessageAt   0,5,ResponseMessage
236   6474 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
236   6478 16 05       >                        ld      d,5
236   647A 1E 00       >                        ld      e,0*8
236   647C 21 A7 67    >                        ld      hl,ResponseMessage
236   647F CD 7F 6E    >                        call    l1_print_at_char_wrap
236   6482 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
237   6486 C9                                   ret
238   6487              ;--------------------------------------------------------------------------------------
239   6487              ENPiSetView:            MessageAt 0,6,CommandMessage
239   6487 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
239   648B 16 06       >                        ld      d,6
239   648D 1E 00       >                        ld      e,0*8
239   648F 21 5F 67    >                        ld      hl,CommandMessage
239   6492 CD 7F 6E    >                        call    l1_print_at_char_wrap
239   6495 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
240   6499                                      PiSendCommand 18
240   6499 16 12       >                        ld      d,18
240   649B CD C9 68    >                        call    PiWriteByte
241   649E                                      MessageAt 9,6,SentMessage
241   649E F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
241   64A2 16 06       >                        ld      d,6
241   64A4 1E 48       >                        ld      e,9*8
241   64A6 21 67 67    >                        ld      hl,SentMessage
241   64A9 CD 7F 6E    >                        call    l1_print_at_char_wrap
241   64AC E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
242   64B0                                      MessageAt 13,6,ViewMessage
242   64B0 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
242   64B4 16 06       >                        ld      d,6
242   64B6 1E 68       >                        ld      e,13*8
242   64B8 21 95 67    >                        ld      hl,ViewMessage
242   64BB CD 7F 6E    >                        call    l1_print_at_char_wrap
242   64BE E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
243   64C2 3A A7 5E                             ld      a,(Var_ViewPort)
244   64C5 57                                   ld      d,a
245   64C6 CD C9 68                             call    PiWriteByte
246   64C9                                      MessageAt  25,6,SentMessage
246   64C9 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
246   64CD 16 06       >                        ld      d,6
246   64CF 1E C8       >                        ld      e,25*8
246   64D1 21 67 67    >                        ld      hl,SentMessage
246   64D4 CD 7F 6E    >                        call    l1_print_at_char_wrap
246   64D7 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
247   64DB C9                                   ret
248   64DC              ;--------------------------------------------------------------------------------------
249   64DC              ; 0x15 To Test    Request Render data
250   64DC              ENPiRenderData:         PiSendCommand   $15
250   64DC 16 15       >                        ld      d,$15
250   64DE CD C9 68    >                        call    PiWriteByte
251   64E1                                      MessageAt 9,6,SentMessage
251   64E1 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
251   64E5 16 06       >                        ld      d,6
251   64E7 1E 48       >                        ld      e,9*8
251   64E9 21 67 67    >                        ld      hl,SentMessage
251   64EC CD 7F 6E    >                        call    l1_print_at_char_wrap
251   64EF E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
252   64F3                                      MessageAt 13,6,RenderMessage
252   64F3 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
252   64F7 16 06       >                        ld      d,6
252   64F9 1E 68       >                        ld      e,13*8
252   64FB 21 A0 67    >                        ld      hl,RenderMessage
252   64FE CD 7F 6E    >                        call    l1_print_at_char_wrap
252   6501 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
253   6505 CD A7 69                             call    PiReadByte                  ; Read number of lines to render
254   6508 A7                                   and     a
255   6509 C8                                   ret     z
256   650A 32 A9 5E                             ld      (LineHeapSize),a            ; Cache line list
257   650D                                      PrintHexARegAt 0,0
257   650D F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
257   6511 16 00       >                        ld      d,0
257   6513 1E 00       >                        ld      e,0*8
257   6515 CD 09 6E    >                        call    l1_print_u8_hex_at_char
257   6518 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
258   651C 3A A9 5E                             ld      a,(LineHeapSize)
259   651F 21 AA 5E                             ld      hl,LineHeap
260   6522 16 05                                ld      d,5                         ; de = 5 byte blocks of data includin gline colour
261   6524 5F                                   ld      e,a
262   6525 ED 30                                mul     de
263   6527 CD 30 6A                             call    PiReadBlock
264   652A                                      ; Stick in here drawing lines later
265   652A C9                                   ret
266   652B              ;--------------------------------------------------------------------------------------
267   652B              ; 0x16 Input......Request Explode Cloud data, returns render position as xy, age, & ship size, leaves drawing to main game engine
268   652B              ENPiCloudList:          PiSendCommand   $16
268   652B 16 16       >                        ld      d,$16
268   652D CD C9 68    >                        call    PiWriteByte
269   6530 CD A7 69                             call    PiReadByte
270   6533 32 A9 5E                             ld      (CloudHeapSize),a
271   6536 A7                                   and     a
272   6537 C8                                   ret     z
273   6538 21 AA 5E                             ld      hl,CloudHeap
274   653B 57                                   ld      d,a
275   653C 1E 04                                ld      e,4
276   653E ED 30                                mul     de
277   6540 CD 30 6A                             call    PiReadBlock
278   6543 C9                                   ret
279   6544              ;--------------------------------------------------------------------------------------
280   6544              ; 0x1A To Test    Request Compass Position Data,Retubnr
281   6544              ENPiCompassList:        PiSendCommand   $1A
281   6544 16 1A       >                        ld      d,$1A
281   6546 CD C9 68    >                        call    PiWriteByte
282   6549 CD A7 69                             call    PiReadByte
283   654C 32 A9 5E                             ld      (CompassHeapSize),a
284   654F A7                                   and     a
285   6550 21 AA 5E                             ld      hl,CompassHeap
286   6553 16 03                                ld      d,3         ; x y z (255 rear, else front)
287   6555 C6 03                                add     a,3         ; factor in star,planet,station, if no ships then a is 0
288   6557 5F                                   ld      e,a
289   6558 ED 30                                mul     de
290   655A CD 30 6A                             call    PiReadBlock
291   655D C9                                   ret
292   655E              ; 0x1B To Test    Request Compass Position (ship nbr, if bit 7 set then 1 = sun 2 = planet 3 = station) > 4x8 bit values for color, x,y,stick length (signed)
293   655E              ;                 writes to ixh = x ixl = y a = z
294   655E              ENPiCompassNbr:         PiSendCommand   $1B
294   655E 16 1B       >                        ld      d,$1B
294   6560 CD C9 68    >                        call    PiWriteByte
295   6563 CD A7 69                             call    PiReadByte
296   6566 DD 67                                ld      ixh,a
297   6568 CD A7 69                             call    PiReadByte
298   656B DD 6F                                ld      ixl,a
299   656D CD A7 69                             call    PiReadByte
300   6570 C9                                   ret
301   6571              ; 0x1C To Test    Request all 3d Position Data > next byte is number of ships, followed by 3x24 bit for sun, 3x24 bit for planet, 3x24 bit for space station, nbr ships x 1x8 bit ship index, 3x16 bit for ships
302   6571              ENPiPositionList:       PiSendCommand   $1C
302   6571 16 1C       >                        ld      d,$1C
302   6573 CD C9 68    >                        call    PiWriteByte
303   6576 CD A7 69                             call    PiReadByte
304   6579 32 A9 5E                             ld      (PositionHeapSize),a
305   657C 16 0A                                ld      d,10            ; Ship Nbr x y z are all 16.8 format
306   657E ED 30                                mul     de
307   6580 21 09 00                             ld      hl,3*3          ; star, planet,station
308   6583 19                                   add     hl,de
309   6584 EB                                   ex      de,hl           ; de = length
310   6585 21 AA 5E                             ld      hl,PositionHeap
311   6588 CD 30 6A                             call    PiReadBlock
312   658B C9                                   ret
313   658C              ; 0x1D To Test    Request ship n Position Data (ship nbr, if bit 7 set then 1 = sun 2 = planet 3 = station) >  followed by 3x24 bit for sun, 3x24 bit for planet, 3x24 bit for space station, nbr ships x 3x16 bit for ships
314   658C              ENPiPositionNbr:        PiSendCommand   $1D
314   658C 16 1D       >                        ld      d,$1D
314   658E CD C9 68    >                        call    PiWriteByte
315   6591 32 A9 5E                             ld      (PositionHeapSize),a
316   6594 21 AA 5E                             ld      hl,PositionHeap
317   6597 11 1B 00                             ld      de, 9*3            ; x y z are all 16.8 format
318   659A CD 30 6A                             call    PiReadBlock
319   659D C9                                   ret
320   659E              ; 0x1E To Test    Request Matrix data (ships + space station)
321   659E              ENPiMatrixList:         PiSendCommand   $1E
321   659E 16 1E       >                        ld      d,$1E
321   65A0 CD C9 68    >                        call    PiWriteByte
322   65A3 32 A9 5E                             ld      (MatrixHeapSize),a
323   65A6 16 13                                ld      d,(2*9)+1           ; ship nbr 3 x 3 grid of 2 byte values
324   65A8 3C                                   inc     a                   ; add in space station
325   65A9 5F                                   ld      e,a
326   65AA ED 30                                mul     de
327   65AC 1B                                   dec     de                  ; space station does not have a ship nbr
328   65AD CD 30 6A                             call    PiReadBlock
329   65B0 C9                                   ret
330   65B1              ; 0x1F To Test    Request Ship matrix (ship nbr, if bit 7 set then 1 = sun 2 = planet 3 = station)
331   65B1              ENPiMatrixNbr:          PiSendCommand   $1F
331   65B1 16 1F       >                        ld      d,$1F
331   65B3 CD C9 68    >                        call    PiWriteByte
332   65B6 21 AA 5E                             ld      hl,MatrixHeap
333   65B9 11 12 00                             ld      de,9*2
334   65BC CD 30 6A                             call    PiReadBlock
335   65BF C9                                   ret
336   65C0              ; 0x20 To Test    Firing > next byte is ship id that would be hit by laser in low byte, bit 7 is 0 for front 1 for rear, FF means no hit
337   65C0              ENPiFiringLaser:        PiSendCommand   $20
337   65C0 16 20       >                        ld      d,$20
337   65C2 CD C9 68    >                        call    PiWriteByte
338   65C5 CD A7 69                             call    PiReadByte
339   65C8 C9                                   ret
340   65C9              ; 0x21 Input      List of lasers hitting player and direction, first byte count follwoed by ship id and facing as per 0x20
341   65C9              ENPiLaserList:          PiSendCommand   $21
341   65C9 16 21       >                        ld      d,$21
341   65CB CD C9 68    >                        call    PiWriteByte
342   65CE CD A7 69                             call    PiReadByte
343   65D1 32 A9 5E                             ld      (LaserHeapSize),a
344   65D4 C8                                   ret     z
345   65D5 21 AA 5E                             ld      hl,LaserHeap
346   65D8 16 02                                ld      d,2
347   65DA 7F                                   ld      a,a
348   65DB ED 30                                mul     de
349   65DD CD 30 6A                             call    PiReadBlock
350   65E0 C9                                   ret
351   65E1              ; 0x22 Input      Missile Hit Check, loops through all missiles in flight: first byte is missile id (low nibble), high nibble nbr of ships hit, list of ships his and distance from missile, if ship id is hit bit 7 then direect hit and no distance byte
352   65E1
353   65E1              ;--------------------------------------------------------------------------------------
354   65E1              ; 0x23 To Test    Fire ECM, byte = duration
355   65E1              ENPiFireECM:            PiSendCommand   $23
355   65E1 16 23       >                        ld      d,$23
355   65E3 CD C9 68    >                        call    PiWriteByte
356   65E6 16 50                                ld      d,$50
357   65E8 CD C9 68                             call    PiWriteByte
358   65EB C9                                   ret
359   65EC              ; 0x30 To Test    Add Ship    > next bytes are Type, position, rotation, state (what here) also used for launch missile, flags as bit mask for overides 7=Angry,6 = scared, 5 = hunter, 4 trader, 3 = courier, 2 = bezerk, 1 = has cloak,, 0=has_ecm
360   65EC              ; Note position needs to move to 16.8 code is currently 8.8
361   65EC 01           AddType:                DB 1
362   65ED 01 10 02 20  AddPosition:            DW $1001, $2002, $0F03
362   65F1 03 0F
363   65F3 00 01 01 00  AddRotation:            DW $0100, $0001, $0001, $0001, $0100, $0001, $0001,$0001, $0100
363   65F7 01 00 01 00
363   65FB 00 01 01 00
363   65FF 01 00 01 00
363   6603 00 01
364   6605 01 02 03 04  AddRotandSpeed:         DB $01, $02, $03, $04, $05
364   6609 05
365   660A 00           AddFlags:               DB 0
366   660B              AddLen:                 equ 31
367   660B              ENPiAddShip:            PiSendCommand $30
367   660B 16 30       >                        ld      d,$30
367   660D CD C9 68    >                        call    PiWriteByte
368   6610                                      PiSendShortDataBlock AddType, AddLen
368   6610 21 EC 65    >                        ld      hl,AddType
368   6613 06 1F       >                        ld      b,AddLen
368   6615 CD E0 6A    >                        call    PiWriteDataBlock
369   6618 C9                                   ret
370   6619              ; 0x31 To Test    Ship Dead   > next byte is ship number
371   6619              ENPiShipDead:           PiSendCommand   $31
371   6619 16 31       >                        ld      d,$31
371   661B CD C9 68    >                        call    PiWriteByte
372   661E 16 00                                ld      d,0
373   6620 CD C9 68                             call    PiWriteByte
374   6623 C9                                   ret
375   6624              ; 0x32 To Test    Remove Ship > next byte is ship number
376   6624              ENPiRemoveShip:         PiSendCommand   $33
376   6624 16 33       >                        ld      d,$33
376   6626 CD C9 68    >                        call    PiWriteByte
377   6629 16 00                                ld      d,0
378   662B CD C9 68                             call    PiWriteByte
379   662E C9                                   ret
380   662F              ; 0x40 Input      Request ship nbrs in range X of position , 3x8 bit for position, 1x8bit for range
381   662F 20 20 20 30  RangeData:              DB      $20,$20,$20,$30
382   6633 00 00 00...  RangeResult:            DS      16
383   6643              ENPiShipsInRange:       PiSendCommand   $40
383   6643 16 40       >                        ld      d,$40
383   6645 CD C9 68    >                        call    PiWriteByte
384   6648                                      PiSendShortDataBlock RangeData,4
384   6648 21 2F 66    >                        ld      hl,RangeData
384   664B 06 04       >                        ld      b,4
384   664D CD E0 6A    >                        call    PiWriteDataBlock
385   6650 CD A7 69                             call    PiReadByte
386   6653 C8                                   ret     z                       ; if zero then no data
387   6654 5F                                   ld      e,a
388   6655 16 00                                ld      d,0
389   6657 21 33 66                             ld      hl,RangeResult
390   665A CD 30 6A                             call    PiReadBlock
391   665D C9                                   ret
392   665E              ;--------------------------------------------------------------------------------------
393   665E              ; 0x66 To Test    Shutdown
394   665E              ENPisShutdown:          PiSendCommand   $66
394   665E 16 66       >                        ld      d,$66
394   6660 CD C9 68    >                        call    PiWriteByte
395   6663 C9                                   ret
396   6664              ;--------------------------------------------------------------------------------------
397   6664              ; 0x67 To Test    Restart Universe
398   6664              ENPiResetUniverse:      PiSendCommand   $67
398   6664 16 67       >                        ld      d,$67
398   6666 CD C9 68    >                        call    PiWriteByte
399   6669 C9                                   ret
400   666A              ;--------------------------------------------------------------------------------------
401   666A              ; 0x68 Input      Performed Jump
402   666A AF 00 B0 00  JumpSampleSeeds:        DW  $AF, $B0, $34, $54, $76, $01
402   666E 34 00 54 00
402   6672 76 00 01 00
403   6676              ENPiPerformedJump:      PiSendCommand   $68
403   6676 16 68       >                        ld      d,$68
403   6678 CD C9 68    >                        call    PiWriteByte
404   667B                                      PiSendShortDataBlock JumpSampleSeeds,6
404   667B 21 6A 66    >                        ld      hl,JumpSampleSeeds
404   667E 06 06       >                        ld      b,6
404   6680 CD E0 6A    >                        call    PiWriteDataBlock
405   6683 C9                                   ret
406   6684              ;--------------------------------------------------------------------------------------
407   6684              ; 0x69 Input      Undock Player assuming existing seed it valid
408   6684              ENPiUndock:             PiSendCommand   $69
408   6684 16 69       >                        ld      d,$69
408   6686 CD C9 68    >                        call    PiWriteByte
409   6689 C9                                   ret
410   668A              ;--------------------------------------------------------------------------------------
411   668A              ; 0x6A Input      Undock Player Seeded, used if we need to set new seed, e.g. after load game
412   668A              ENPiUndockSeeded:       PiSendCommand   $6A
412   668A 16 6A       >                        ld      d,$6A
412   668C CD C9 68    >                        call    PiWriteByte
413   668F                                      PiSendShortDataBlock JumpSampleSeeds,6
413   668F 21 6A 66    >                        ld      hl,JumpSampleSeeds
413   6692 06 06       >                        ld      b,6
413   6694 CD E0 6A    >                        call    PiWriteDataBlock
414   6697 C9                                   ret
415   6698              ;--------------------------------------------------------------------------------------
416   6698              ; 0x70 Input      Player input
417   6698 01 02 03 04  PlayerInput:            DW $0201, $0403,$0605,$0807
417   669C 05 06 07 08
418   66A0              ENPiPlayerInput:        PiSendCommand   $70
418   66A0 16 70       >                        ld      d,$70
418   66A2 CD C9 68    >                        call    PiWriteByte
419   66A5                                      PiSendShortDataBlock PlayerInput, 8
419   66A5 21 98 66    >                        ld      hl,PlayerInput
419   66A8 06 08       >                        ld      b,8
419   66AA CD E0 6A    >                        call    PiWriteDataBlock
420   66AD C9                                   ret
421   66AE              ;--------------------------------------------------------------------------------------
422   66AE              ; 0x71 Input      Update Universe
423   66AE              ENPiUpdateUniverse:     PiSendCommand   $71
423   66AE 16 71       >                        ld      d,$71
423   66B0 CD C9 68    >                        call    PiWriteByte
424   66B3 C9                                   ret
425   66B4              ;--------------------------------------------------------------------------------------
426   66B4              ; 0x72 Input      Update Universe n ticks, tick count in d
427   66B4 D5           EMPiUpdateTicks:        push    de
428   66B5                                      PiSendCommand   $72
428   66B5 16 72       >                        ld      d,$72
428   66B7 CD C9 68    >                        call    PiWriteByte
429   66BA D1                                   pop     de
430   66BB CD C9 68                             call    PiWriteByte
431   66BE C9                                   ret
432   66BF              ; 0x73 Input      Update tactics all
433   66BF              ENPiUndateTactics:      PiSendCommand   $73
433   66BF 16 73       >                        ld      d,$73
433   66C1 CD C9 68    >                        call    PiWriteByte
434   66C4 C9                                   ret
435   66C5              ;--------------------------------------------------------------------------------------
436   66C5              ; 0x74 Input      Update tactics ship n (bit 7 means space station), ship Id in d
437   66C5 D5           ENPiTacticsNbr:         push    de
438   66C6                                      PiSendCommand   $74
438   66C6 16 74       >                        ld      d,$74
438   66C8 CD C9 68    >                        call    PiWriteByte
439   66CB D1                                   pop     de
440   66CC CD C9 68                             call    PiWriteByte
441   66CF C9                                   ret
442   66D0              ; 0x75 Input      get all status data upper nibble byte 1 ship nbr lowe nibble + next byte 12 bit mask + 2 bytes for space station
443   66D0              ;                 Bit Mask   11, 10, 9 111 In Use and alive
444   66D0              ;                                      100 In Use Dead
445   66D0              ;                                      101 In Use Exploding
446   66D0              ;                                      110 In Use to remove
447   66D0              ;                             8 Is Angry
448   66D0              ;                             7 Is Scared
449   66D0              ;                             6 Is Firing
450   66D0              ;                             5 Is Berzerk
451   66D0              ;                             4 Is cloaked
452   66D0              ;                             3 Is hunter
453   66D0              ;                             2 ,1 0    111 Is Trader
454   66D0              ;                                       100 Is Pirate
455   66D0              ;                                       101 Is Authority
456   66D0              ;                                       110 Is Courier
457   66D0              ;                                       001 Is Thargoid
458   66D0              ;                             1 ECM Active
459   66D0              ;                             0
460   66D0              ENPiGetStatusAll:       PiSendCommand  $75
460   66D0 16 75       >                        ld      d,$75
460   66D2 CD C9 68    >                        call    PiWriteByte
461   66D5 CD A7 69                             call    PiReadByte
462   66D8 3C                                   inc     a
463   66D9 57                                   ld      d,a
464   66DA 1E 02                                ld      e,2
465   66DC ED 30                                mul     de
466   66DE 21 AA 5E                             ld      hl,StatusHeap
467   66E1 CD 30 6A                             call    PiReadBlock
468   66E4 C9                                   ret
469   66E5              ; 0x76 Input      get ship n status data (bit 7 means space station), returns status in de
470   66E5 D5           ENPiGetStatusNbr:       push    de
471   66E6                                      PiSendCommand  $76
471   66E6 16 76       >                        ld      d,$76
471   66E8 CD C9 68    >                        call    PiWriteByte
472   66EB D1                                   pop     de
473   66EC CD C9 68                             call    PiWriteByte
474   66EF CD BA 6A                             call    PiReadWord
475   66F2 C9                                   ret
476   66F3              ; 0x80 Input      get all scanner data next byte is number of ships, followed by 1 byte ship nbr, 3x1 byte, x1,y1,y2, blob is draw at y2
477   66F3              ENPiGetScannerAll:      PiSendCommand   $80
477   66F3 16 80       >                        ld      d,$80
477   66F5 CD C9 68    >                        call    PiWriteByte
478   66F8 CD A7 69                             call    PiReadByte
479   66FB 32 A9 5E                             ld      (ScannerDataSize),a
480   66FE 57                                   ld      d,a
481   66FF 1E 04                                ld      e,4                         ; ship nbr, x1 y1 y2
482   6701 ED 30                                mul     de
483   6703 21 09 00                             ld      hl,9                        ; Star, Planet Station
484   6706 19                                   add     hl,de
485   6707 EB                                   ex      hl,de                       ; de = total data block now
486   6708 21 AA 5E                             ld      hl,ScannerHeap
487   670B CD 30 6A                             call    PiReadBlock
488   670E C9                                   ret
489   670F              ; 0x81 Input      get ship scanner data > object id, bit 7 shifs to bodies < returns 3x1 byte, x1,y1,y2, blob is draw at y2
490   670F              ;                 d = ship nbr, returns de x1 y1 a y2
491   670F D5           ENPiGetScannerNbr:      push    de
492   6710                                      PiSendCommand   $80
492   6710 16 80       >                        ld      d,$80
492   6712 CD C9 68    >                        call    PiWriteByte
493   6715 D1                                   pop     de
494   6716 CD C9 68                             call    PiWriteByte
495   6719 CD A7 69                             call    PiReadByte
496   671C 57                                   ld      d,a
497   671D CD A7 69                             call    PiReadByte
498   6720 5F                                   ld      e,a
499   6721 CD A7 69                             call    PiReadByte
500   6724 C9                                   ret
501   6725              ; 0x90 Input      set object status > object nbr
502   6725              ;                 a = object nbr, de = status mask as per get status TODO shall we do as a word instead of two bytes?
503   6725 D5 F5        ENPiSetObjectStatus:    push    de,,af
504   6727                                      PiSendCommand   $90
504   6727 16 90       >                        ld      d,$90
504   6729 CD C9 68    >                        call    PiWriteByte
505   672C F1                                   pop     af
506   672D 57                                   ld      d,a
507   672E CD C9 68                             call    PiWriteByte
508   6731 D1                                   pop     de
509   6732 DD 6B                                ld      ixl,e
510   6734 CD C9 68                             call    PiWriteByte
511   6737 DD 5D                                ld      e,ixl
512   6739 CD C9 68                             call    PiWriteByte
513   673C C9                                   ret
514   673D              ; 0xA0 Input      set all mode 1 = all objects regarless of if they exist, 0 = only ones where object used = true
515   673D              ; 0xF0 to 0xFF    send command in a reg then send b messages from memory location hl with d a multiplier based on packet size
516   673D              ;                 d = 1 for byte, 2 for word, 3 for 8.8 etc
517   673D              ; Raw data dump, hl = address, de  length in bytes
518   673D E5 D5 C5     ENPiDumpData:           push    hl,,de,,bc
519   6740                                      PiSendCommand   a
519   6740 57          >                        ld      d,a
519   6741 CD C9 68    >                        call    PiWriteByte
520   6744 D1 C1 E1                             pop     hl,,bc,,de
521   6747 42 4B                                ld      bc,de
522   6749 CD C2 6A                             call    PiWriteLongDataBlock        ; hl = address of string to write, bc  = length
523   674C C9                                   ret
524   674D E5 D5 C5     ENPiDumpDataTest:       push    hl,,de,,bc
525   6750 C1 D1 E1                             pop     hl,,de,,bc
526   6753 42 4B                                ld      bc,de
527   6755 CD D2 6A                             call    PiTestLongDataBlock        ; hl = address of string to write, bc  = length
528   6758 C9                                   ret
529   6759
530   6759              ;--------------------------------------------------------------------------------------
531   6759              ; Tests to implement
532   6759
533   6759              ;--------------------------------------------------------------------------------------
534   6759              ; viarables for printing
535   6759 48 65 6C 6C  HelloMessage:           DB 'Hello',0
535   675D 6F 00
536   675F 43 6F 6D 6D  CommandMessage:         DB 'Command',0
536   6763 61 6E 64 00
537   6767 53 65 6E 74  SentMessage:            DB 'Sent',0
537   676B 00
538   676C 53 74 72 69  SentHello:              DB 'String Hello',0
538   6770 6E 67 20 48
538   6774 65 6C 6C 6F
538   6778 00
539   6779 52 65 61 64  ReadingMessage:         DB 'Reading',0
539   677D 69 6E 67 00
540   6781 50 69 6E 67  PingMessage:            db 'Ping ',0,0
540   6785 20 00 00
541   6788 58 58 58 58  HelloResponse:          db 'XXXXX',0,0,0,0,0,0,0,0
541   678C 58 00 00 00
541   6790 00 00 00 00
541   6794 00
542   6795 56 69 65 77  ViewMessage:            db 'View Set',0,0,0
542   6799 20 53 65 74
542   679D 00 00 00
543   67A0 52 65 6E 64  RenderMessage:          db 'Render',0
543   67A4 65 72 00
544   67A7 50 69 6E 67  ResponseMessage:        DB      'Ping Result : '
544   67AB 20 52 65 73
544   67AF 75 6C 74 20
544   67B3 3A 20
545   67B5 30 00        PingCode:               DB      '0', 0
546   67B7 20 20 20 20  StringMessage:          DB '                               ',0
546   67BB 20 20 20 20
546   67BF 20 20 20 20
546   67C3 20 20 20 20
546   67C7 20 20 20 20
546   67CB 20 20 20 20
546   67CF 20 20 20 20
546   67D3 20 20 20 00
547   67D7 2E 2E 2E 2E  StringClear:            DB '...............................',0
547   67DB 2E 2E 2E 2E
547   67DF 2E 2E 2E 2E
547   67E3 2E 2E 2E 2E
547   67E7 2E 2E 2E 2E
547   67EB 2E 2E 2E 2E
547   67EF 2E 2E 2E 2E
547   67F3 2E 2E 2E 00
548   67F7              ;--------------------------------------------------------------------------------------
549   67F7              ; Pi diagnostics
550   67F7              ; d = row char e = col pixel
551   67F7 F5 C5 E5 D5  ClearMessageArea:       push    af,,bc,,hl,,de
552   67FB 21 B7 67                             ld      hl,StringMessage
553   67FE 06 1E                                ld      b,30
554   6800 3E 00                                ld      a,0
555   6802 77           .fillLoop:              ld      (hl),a
556   6803 23                                   inc     hl
557   6804 10 FC                                djnz    .fillLoop
558   6806 D1 E1 C1 F1                          pop     af,,bc,,hl,,de
559   680A C9                                   ret
560   680B F5 C5 E5 D5  PrintPortBinary:        push    af,,bc,,hl,,de
561   680F 16 0C                                ld      d,12
562   6811 1E 14                                ld      e,20
563   6813                                      GetNextReg 152
563   6813 01 3B 24    >            ld bc,$243B
563   6816 3E 98       >            ld a,152
563   6818 ED 79       >            out (c),a
563   681A 04          >            inc b
563   681B ED 78       >            in a,(c)
564   681D CD 39 6D                             call    l1_print_bin8_l2r_at_char
565   6820 16 0C                                ld      d,12
566   6822 1E 0A                                ld      e,10
567   6824                                      GetNextReg 153
567   6824 01 3B 24    >            ld bc,$243B
567   6827 3E 99       >            ld a,153
567   6829 ED 79       >            out (c),a
567   682B 04          >            inc b
567   682C ED 78       >            in a,(c)
568   682E CD 39 6D                             call    l1_print_bin8_l2r_at_char
569   6831 16 0C                                ld      d,12
570   6833 1E 00                                ld      e,0
571   6835                                      GetNextReg 155
571   6835 01 3B 24    >            ld bc,$243B
571   6838 3E 9B       >            ld a,155
571   683A ED 79       >            out (c),a
571   683C 04          >            inc b
571   683D ED 78       >            in a,(c)
572   683F CD 39 6D                             call    l1_print_bin8_l2r_at_char
573   6842 D1 E1 C1 F1                          pop     af,,bc,,hl,,de
574   6846 C9                                   ret
575   6847              ;--------------------------------------------------------------------------------------
576   6847              ; Pi Library
577   6847
578   6847              PiSetnDSRnCTSnACK:      MACRO
579   6847 ~                                    nextreg 155,0
580   6847                                      ENDM
581   6847              PiSetnDSRCTSnACK:       MACRO
582   6847 ~                                    nextreg 155,2
583   6847                                      ENDM
584   6847              PiSetDSR:               MACRO
585   6847 ~                                    nextreg 155,1           ; Set DSR high andy anything else writable low
586   6847                                      ENDM
587   6847              PiSetnCTSACK:           MACRO
588   6847 ~                                    nextreg 155,4           ; Set ACK high andy anything else writable low
589   6847                                      ENDM
590   6847 ED 91 90 00  PiSetReadMode:          nextreg 144, 0              ; pins 4 to 7 read  enable
591   684B ED 91 91 00                          nextreg 145, 0              ; pins 0 to 3 read enable
592   684F ED 91 93 06                          nextreg 147,2+4             ; data ready pin read, CTS write, ack write , Desync read
593   6853                                      MessageAt 0,15,PiInReadMode
593   6853 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
593   6857 16 0F       >                        ld      d,15
593   6859 1E 00       >                        ld      e,0*8
593   685B 21 4D 6A    >                        ld      hl,PiInReadMode
593   685E CD 7F 6E    >                        call    l1_print_at_char_wrap
593   6861 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
594   6865                                      MessageAt 15,15,PiClearMode
594   6865 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
594   6869 16 0F       >                        ld      d,15
594   686B 1E 78       >                        ld      e,15*8
594   686D 21 5B 6A    >                        ld      hl,PiClearMode
594   6870 CD 7F 6E    >                        call    l1_print_at_char_wrap
594   6873 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
595   6877 C9                                   ret
596   6878
597   6878 ED 91 90 F0  PiSetWriteMode:         nextreg 144, 16+32+64+128   ;pins 4 to 7 write enable
598   687C ED 91 91 0F                          nextreg 145, 1+2+4+8        ;pins 0 to 3 write enable
599   6880 ED 91 93 09                          nextreg 147, 1 + 8          ;DSR and Desync pins write enable
600   6884                                      MessageAt 15,15,PiInWriteMode
600   6884 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
600   6888 16 0F       >                        ld      d,15
600   688A 1E 78       >                        ld      e,15*8
600   688C 21 3E 6A    >                        ld      hl,PiInWriteMode
600   688F CD 7F 6E    >                        call    l1_print_at_char_wrap
600   6892 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
601   6896                                      MessageAt 0,15,PiClearMode
601   6896 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
601   689A 16 0F       >                        ld      d,15
601   689C 1E 00       >                        ld      e,0*8
601   689E 21 5B 6A    >                        ld      hl,PiClearMode
601   68A1 CD 7F 6E    >                        call    l1_print_at_char_wrap
601   68A4 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
602   68A8 C9                                   ret
603   68A9              ;--------------------------------------------------------------------------------------
604   68A9 ED 91 93 07  PiReset:                nextreg 147,1+2+4           ; data ready 0, cts 0, ack 0
605   68AD ED 91 9B 00                          nextreg 155,0               ;
606   68B1 C9                                   ret
607   68B2 CD 78 68                             call    PiSetWriteMode      ; clear out bits on data line
608   68B5 ED 91 98 00                          nextreg 152,0
609   68B9 ED 91 99 00                          nextreg 153,0
610   68BD ED 91 9B 00                          nextreg 155,0               ; and clear DSR,DeSync
611   68C1 CD 47 68                             call    PiSetReadMode
612   68C4 ED 91 9B 00                          nextreg 155,0               ; and clear CTS,ACK
613   68C8 C9                                   ret
614   68C9
615   68C9              ;--------------------------------------------------------------------------------------
616   68C9              ;  Write byte held in d (data)
617   68C9              PiWriteByte:            IFDEF DEBUGMODE
618   68C9 7A                                       ld      a,d
619   68CA 32 A8 5E                                 ld      (Var_BYTE),a
620   68CD                                      ENDIF
621   68CD CD 78 68                             call    PiSetWriteMode      ; Write Mode
622   68D0                                      PiSetnDSRnCTSnACK
622   68D0 ED 91 9B 00 >                        nextreg 155,0
623   68D4                                      IFDEF DEBUGMODE
624   68D4                                          MessageAt 0,16,PiWaitCTS
624   68D4 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
624   68D8 16 10       >                        ld      d,16
624   68DA 1E 00       >                        ld      e,0*8
624   68DC 21 85 6A    >                        ld      hl,PiWaitCTS
624   68DF CD 7F 6E    >                        call    l1_print_at_char_wrap
624   68E2 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
625   68E6                                          MessageAt 15,16,PiClearMode
625   68E6 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
625   68EA 16 10       >                        ld      d,16
625   68EC 1E 78       >                        ld      e,15*8
625   68EE 21 5B 6A    >                        ld      hl,PiClearMode
625   68F1 CD 7F 6E    >                        call    l1_print_at_char_wrap
625   68F4 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
626   68F8                                          MessageAt 0,17,PiClearMode
626   68F8 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
626   68FC 16 11       >                        ld      d,17
626   68FE 1E 00       >                        ld      e,0*8
626   6900 21 5B 6A    >                        ld      hl,PiClearMode
626   6903 CD 7F 6E    >                        call    l1_print_at_char_wrap
626   6906 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
627   690A                                      ENDIF
628   690A CD 50 6B                             call    PiWaitforCTSnACK    ; wait for Clear to send
629   690D                                      IFDEF DEBUGMODE
630   690D                                          MessageAt 15,16,PiWriting
630   690D F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
630   6911 16 10       >                        ld      d,16
630   6913 1E 78       >                        ld      e,15*8
630   6915 21 69 6A    >                        ld      hl,PiWriting
630   6918 CD 7F 6E    >                        call    l1_print_at_char_wrap
630   691B E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
631   691F                                          MessageAt 0,16,PiClearMode
631   691F F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
631   6923 16 10       >                        ld      d,16
631   6925 1E 00       >                        ld      e,0*8
631   6927 21 5B 6A    >                        ld      hl,PiClearMode
631   692A CD 7F 6E    >                        call    l1_print_at_char_wrap
631   692D E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
632   6931 3A A8 5E                                 ld      a,(Var_BYTE)
633   6934                                          PrintHexARegAt 25,19
633   6934 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
633   6938 16 13       >                        ld      d,19
633   693A 1E C8       >                        ld      e,25*8
633   693C CD 09 6E    >                        call    l1_print_u8_hex_at_char
633   693F E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
634   6943                                      ENDIF
635   6943 7A                                   ld      a,d                 ; build up port values and send
636   6944                                      IFDEF DEBUGMODE
637   6944 3A A8 5E                                 ld      a,(Var_BYTE)    ; DEBUG
638   6947 57                                       ld      d,a
639   6948                                      ENDIF
640   6948 E6 F0                                and     %11110000           ; we don't swap here and let the pi
641   694A ED 92 98                             nextreg 152,a               ; handle that
642   694D 7A                                   ld      a,d                 ; .
643   694E E6 0F                                and     %00001111           ; .
644   6950 ED 92 99                             nextreg 153,a               ; .
645   6953                                      PiSetDSR                    ; Data Set is Ready
645   6953 ED 91 9B 01 >                        nextreg 155,1           ; Set DSR high andy anything else writable low
646   6957                                      IFDEF DEBUGMODE
647   6957                                          MessageAt 0,17,PiWaitACK
647   6957 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
647   695B 16 11       >                        ld      d,17
647   695D 1E 00       >                        ld      e,0*8
647   695F 21 A1 6A    >                        ld      hl,PiWaitACK
647   6962 CD 7F 6E    >                        call    l1_print_at_char_wrap
647   6965 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
648   6969                                          MessageAt 15,16,PiClearMode
648   6969 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
648   696D 16 10       >                        ld      d,16
648   696F 1E 78       >                        ld      e,15*8
648   6971 21 5B 6A    >                        ld      hl,PiClearMode
648   6974 CD 7F 6E    >                        call    l1_print_at_char_wrap
648   6977 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
649   697B                                      ENDIF
650   697B CD 2A 6B                             call    PiWaitforACK        ; Poll for Ackowledge
651   697E                                      IFDEF DEBUGMODE
652   697E                                          MessageAt 0,17,PiClearMode
652   697E F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
652   6982 16 11       >                        ld      d,17
652   6984 1E 00       >                        ld      e,0*8
652   6986 21 5B 6A    >                        ld      hl,PiClearMode
652   6989 CD 7F 6E    >                        call    l1_print_at_char_wrap
652   698C E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
653   6990                                          MessageAt 15,16,PiClearMode
653   6990 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
653   6994 16 10       >                        ld      d,16
653   6996 1E 78       >                        ld      e,15*8
653   6998 21 5B 6A    >                        ld      hl,PiClearMode
653   699B CD 7F 6E    >                        call    l1_print_at_char_wrap
653   699E E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
654   69A2                                      ENDIF
655   69A2                                      PiSetnDSRnCTSnACK           ; clear DSR
655   69A2 ED 91 9B 00 >                        nextreg 155,0
656   69A6 C9                                   ret
657   69A7              ;--------------------------------------------------------------------------------------
658   69A7              ; result in a, affects af, hl, de
659   69A7 CD 47 68     PiReadByte:             call    PiSetReadMode       ; read mode
660   69AA                                      PiSetnDSRCTSnACK            ; CTS and nACK (DSR is write only so won't matter)
660   69AA ED 91 9B 02 >                        nextreg 155,2
661   69AE                                      IFDEF DEBUGMODE
662   69AE                                          MessageAt 0,16,PiWaitDSR
662   69AE F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
662   69B2 16 10       >                        ld      d,16
662   69B4 1E 00       >                        ld      e,0*8
662   69B6 21 93 6A    >                        ld      hl,PiWaitDSR
662   69B9 CD 7F 6E    >                        call    l1_print_at_char_wrap
662   69BC E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
663   69C0                                          MessageAt 15,16,PiClearMode
663   69C0 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
663   69C4 16 10       >                        ld      d,16
663   69C6 1E 78       >                        ld      e,15*8
663   69C8 21 5B 6A    >                        ld      hl,PiClearMode
663   69CB CD 7F 6E    >                        call    l1_print_at_char_wrap
663   69CE E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
664   69D2                                      ENDIF
665   69D2 CD 65 6B                             call    PiWaitforDSR        ; Wait for data to be ready
666   69D5                                      IFDEF DEBUGMODE
667   69D5                                          MessageAt 15,16,PiReading
667   69D5 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
667   69D9 16 10       >                        ld      d,16
667   69DB 1E 78       >                        ld      e,15*8
667   69DD 21 77 6A    >                        ld      hl,PiReading
667   69E0 CD 7F 6E    >                        call    l1_print_at_char_wrap
667   69E3 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
668   69E7                                      ENDIF
669   69E7                                      GetNextReg  152             ; Read data and re-assemble byte
669   69E7 01 3B 24    >            ld bc,$243B
669   69EA 3E 98       >            ld a,152
669   69EC ED 79       >            out (c),a
669   69EE 04          >            inc b
669   69EF ED 78       >            in a,(c)
670   69F1 E6 F0                                and     %11110000           ; it will be pre swapnib on the pi side
671   69F3 6F                                   ld      l,a                 ; so we don't have to here
672   69F4                                      GetNextReg  153             ; .
672   69F4 01 3B 24    >            ld bc,$243B
672   69F7 3E 99       >            ld a,153
672   69F9 ED 79       >            out (c),a
672   69FB 04          >            inc b
672   69FC ED 78       >            in a,(c)
673   69FE E6 0F                                and     %00001111           ; .
674   6A00 B5                                   or      l                   ; .
675   6A01                                      IFDEF DEBUGMODE
676   6A01 32 A8 5E                                 ld      (Var_BYTE),a
677   6A04                                      ENDIF
678   6A04                                      PiSetnCTSACK                ; not clear to send, ACK set
678   6A04 ED 91 9B 04 >                        nextreg 155,4           ; Set ACK high andy anything else writable low
679   6A08                                      IFDEF DEBUGMODE
680   6A08 3A A8 5E                                 ld      a,(Var_BYTE)
681   6A0B                                          PrintHexARegAt 25,19
681   6A0B F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
681   6A0F 16 13       >                        ld      d,19
681   6A11 1E C8       >                        ld      e,25*8
681   6A13 CD 09 6E    >                        call    l1_print_u8_hex_at_char
681   6A16 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
682   6A1A 3A A8 5E                                 ld      a,(Var_BYTE)
683   6A1D                                          MessageAt 15,16,PiClearMode
683   6A1D F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
683   6A21 16 10       >                        ld      d,16
683   6A23 1E 78       >                        ld      e,15*8
683   6A25 21 5B 6A    >                        ld      hl,PiClearMode
683   6A28 CD 7F 6E    >                        call    l1_print_at_char_wrap
683   6A2B E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
684   6A2F                                      ENDIF
685   6A2F C9                                   ret
686   6A30              ;--------------------------------------------------------------------------------------
687   6A30              ; hl = target, de = length
688   6A30 D9           PiReadBlock:            exx                         ; preserve hl and de
689   6A31 CD A7 69                             call    PiReadByte          ; read data
690   6A34 D9                                   exx                         ; recover hl and de
691   6A35 77                                   ld      (hl),a              ; of course exx does not affect af so we can do this
692   6A36 23                                   inc     hl                  ; next memory addr
693   6A37 1B                                   dec     de                  ; a byte done
694   6A38 7A                                   ld      a,d                 ; have we reached the last byte
695   6A39 B3                                   or      e                   ; .
696   6A3A C2 30 6A                             jp      nz,PiReadBlock      ; if no loop
697   6A3D C9                                   ret
698   6A3E              ;--------------------------------------------------------------------------------------
699   6A3E              ; Diag messages
700   6A3E 49 6E 20 57  PiInWriteMode:          DB 'In Write  Mode',0
700   6A42 72 69 74 65
700   6A46 20 20 4D 6F
700   6A4A 64 65 00
701   6A4D 49 6E 20 52  PiInReadMode:           DB 'In Read Mode ',0
701   6A51 65 61 64 20
701   6A55 4D 6F 64 65
701   6A59 20 00
702   6A5B 2E 2E 2E 2E  PiClearMode:            DB '.............',0
702   6A5F 2E 2E 2E 2E
702   6A63 2E 2E 2E 2E
702   6A67 2E 00
703   6A69 57 72 69 74  PiWriting               DB 'Writing      ',0
703   6A6D 69 6E 67 20
703   6A71 20 20 20 20
703   6A75 20 00
704   6A77 52 65 61 64  PiReading               DB 'Reading      ',0
704   6A7B 69 6E 67 20
704   6A7F 20 20 20 20
704   6A83 20 00
705   6A85 57 61 69 74  PiWaitCTS:              DB 'Waiting CTS  ',0
705   6A89 69 6E 67 20
705   6A8D 43 54 53 20
705   6A91 20 00
706   6A93 57 61 69 74  PiWaitDSR:              DB 'Waiting DSR  ',0
706   6A97 69 6E 67 20
706   6A9B 44 53 52 20
706   6A9F 20 00
707   6AA1 57 61 69 74  PiWaitACK:              DB 'Waiting ACK  ',0
707   6AA5 69 6E 67 20
707   6AA9 41 43 4B 20
707   6AAD 20 00
708   6AAF              ;--------------------------------------------------------------------------------------
709   6AAF              ; hl = word to write
710   6AAF 55           PiWriteWord:            ld      d,l
711   6AB0 E5                                   push    hl
712   6AB1 CD C9 68                             call    PiWriteByte
713   6AB4 E1                                   pop     hl
714   6AB5 54                                   ld      d,h
715   6AB6 CD C9 68                             call    PiWriteByte
716   6AB9 C9                                   ret
717   6ABA              ;--------------------------------------------------------------------------------------
718   6ABA              ; de = word read - low high sequence
719   6ABA CD A7 69     PiReadWord:             call    PiReadByte
720   6ABD 5F                                   ld      e,a
721   6ABE CD A7 69                             call    PiReadByte
722   6AC1 57                                   ld      d,a
723   6AC2
724   6AC2              ; hl = address of string to write, bc  = length
725   6AC2 56           PiWriteLongDataBlock:   ld      d,(hl)              ; assume that if d = 0 then we are writing 256 bytes
726   6AC3 C5 E5                                push    bc,,hl
727   6AC5 CD C9 68                             call    PiWriteByte
728   6AC8 E1 C1                                pop     bc,,hl
729   6ACA 23                                   inc     hl
730   6ACB 0B                                   dec     bc
731   6ACC 78                                   ld      a,b
732   6ACD B1                                   or      c
733   6ACE C2 C2 6A                             jp      nz,PiWriteLongDataBlock ; if d has not hit zero then loop
734   6AD1 C9                                   ret
735   6AD2              ; hl = address of string to write, bc  = length
736   6AD2 56           PiTestLongDataBlock:    ld      d,(hl)              ; assume that if d = 0 then we are writing 256 bytes
737   6AD3 C5 E5                                push    bc,,hl
738   6AD5 00                                   nop
739   6AD6 E1 C1                                pop     bc,,hl
740   6AD8 23                                   inc     hl
741   6AD9 0B                                   dec     bc
742   6ADA 78                                   ld      a,b
743   6ADB B1                                   or      c
744   6ADC C2 D2 6A                             jp      nz,PiTestLongDataBlock ; if d has not hit zero then loop
745   6ADF C9                                   ret
746   6AE0              ; hl = address of string to write, b = length
747   6AE0 C5           PiWriteDataBlock:       push    bc
748   6AE1 56                                   ld      d,(hl)              ; assume that if d = 0 then we are writing 256 bytes
749   6AE2                                      IFDEF DEBUGMODE
750   6AE2 DD E5                                    push ix
751   6AE4 F5                                       push af
752   6AE5 7A                                       ld  a,d
753   6AE6 DD 77 00                                 ld (ix+0),a
754   6AE9                                          MessageAt 20,5,StringMessage
754   6AE9 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
754   6AED 16 05       >                        ld      d,5
754   6AEF 1E A0       >                        ld      e,20*8
754   6AF1 21 B7 67    >                        ld      hl,StringMessage
754   6AF4 CD 7F 6E    >                        call    l1_print_at_char_wrap
754   6AF7 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
755   6AFB F1                                       pop  af
756   6AFC                                      ENDIF
757   6AFC CD C9 68                             call    PiWriteByte
758   6AFF 23                                   inc     hl
759   6B00                                      IFDEF DEBUGMODE
760   6B00 DD E1                                    pop  ix
761   6B02 DD 23                                    inc  ix
762   6B04                                      ENDIF
763   6B04 C1                                   pop     bc
764   6B05 10 D9                                djnz    PiWriteDataBlock ; if d has not hit zero then loop
765   6B07 C9                                   ret
766   6B08              ; hl = address of string to write, b = length, if e = 0 then send terminating /0
767   6B08              ; Max string length 256 characters
768   6B08              PiWriteString:          IFDEF DEBUGMODE
769   6B08 CD F7 67                                 call    ClearMessageArea
770   6B0B DD 21 B7 67                              ld      ix,StringMessage
771   6B0F                                      ENDIF
772   6B0F CD E0 6A                             call    PiWriteDataBlock
773   6B12                                      ZeroA                       ; if e is zero then send a /0 to finish
773   6B12 AF          >                        xor a
774   6B13 B3                                   or      e                   ; .
775   6B14 C0                                   ret     nz                  ; this is done if receiving end is expecting variable string length
776   6B15 57                                   ld      d,a                 ; d is data to write
777   6B16 CD C9 68                             call    PiWriteByte         ; a will stil be /0
778   6B19 C9                                   ret
779   6B1A              ; hl = address to write to, d = Limit, if e = 0 then expecting terminating /0 (i.e. variable length) else d = fixed string length
780   6B1A D5 E5        PiReadString:           push    de,,hl              ; Recived
781   6B1C CD A7 69                             call    PiReadByte
782   6B1F E1                                   pop     hl
783   6B20 77                                   ld      (hl),a
784   6B21 23                                   inc     hl
785   6B22 D1                                   pop     de
786   6B23 15                                   dec     d
787   6B24 C8                                   ret     z                   ; d provides a hard limit or fixed string length depending on e
788   6B25 B3                                   or      e                   ; if the byte read the a is 0 and e was zero then this will be zero
789   6B26 C2 1A 6B                             jp      nz,PiReadString
790   6B29 C9                                   ret
791   6B2A
792   6B2A              PiWaitforACK:           GetNextReg  155             ; read status until bit 2 (ACK) is set
792   6B2A 01 3B 24    >            ld bc,$243B
792   6B2D 3E 9B       >            ld a,155
792   6B2F ED 79       >            out (c),a
792   6B31 04          >            inc b
792   6B32 ED 78       >            in a,(c)
793   6B34 CD 0B 68                             call    PrintPortBinary
794   6B37 E6 04                                and %00000100               ;
795   6B39 CA 2A 6B                             jp  z,PiWaitforACK          ; if not then spin waiting
796   6B3C C9                                   ret
797   6B3D
798   6B3D              PiWaitforCTS:           GetNextReg  155             ; read status until bit 1 (CTS) is set
798   6B3D 01 3B 24    >            ld bc,$243B
798   6B40 3E 9B       >            ld a,155
798   6B42 ED 79       >            out (c),a
798   6B44 04          >            inc b
798   6B45 ED 78       >            in a,(c)
799   6B47                                      IFDEF DEBUGMODE
800   6B47 CD 0B 68                                 call    PrintPortBinary
801   6B4A                                      ENDIF
802   6B4A E6 02                                and %00000010               ;
803   6B4C CA 3D 6B                             jp  z,PiWaitforCTS          ; if not then spin waiting
804   6B4F C9                                   ret
805   6B50              PiWaitforCTSnACK:       GetNextReg  155             ; read status for ACK low and CTS High
805   6B50 01 3B 24    >            ld bc,$243B
805   6B53 3E 9B       >            ld a,155
805   6B55 ED 79       >            out (c),a
805   6B57 04          >            inc b
805   6B58 ED 78       >            in a,(c)
806   6B5A                                      IFDEF DEBUGMODE
807   6B5A CD 0B 68                                 call    PrintPortBinary
808   6B5D                                      ENDIF
809   6B5D E6 06                                and %00000110               ; just want ACK and CTS bits
810   6B5F FE 02                                cp  %00000010               ; if CTS is set and ACK is clear
811   6B61 C2 50 6B                             jp  nz,PiWaitforCTSnACK     ; reg value is just CTS then we are good
812   6B64 C9                                   ret
813   6B65
814   6B65              PiWaitforDSR:           GetNextReg  155             ; read status until bit 2 (DSR) is set
814   6B65 01 3B 24    >            ld bc,$243B
814   6B68 3E 9B       >            ld a,155
814   6B6A ED 79       >            out (c),a
814   6B6C 04          >            inc b
814   6B6D ED 78       >            in a,(c)
815   6B6F                                      IFDEF DEBUGMODE
816   6B6F CD 0B 68                                 call    PrintPortBinary
817   6B72                                      ENDIF
818   6B72 E6 01                                and %00000001               ;
819   6B74 CA 65 6B                             jp  z,PiWaitforDSR          ; if not then spin waiting
820   6B77 C9                                   ret
821   6B78
822   6B78
823   6B78              SetPiDesycMode:
824   6B78
825   6B78              PIDescyncReceived:
826   6B78
827   6B78
828   6B78              SendAddObject:
829   6B78
830   6B78
831   6B78                                      INCLUDE	"../../Hardware/memfill_dma.asm"
# file opened: ../../Hardware/memfill_dma.asm
  1+  6B78
  2+  6B78 00           memfillvalue		DB 0
  3+  6B79 83 C3 C7 CB  memfill        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
  3+  6B7D 7D
  4+  6B7E 78 6B        memfill_astrt  		DW memfillvalue
  5+  6B80 00 40        memfill_length 		DB $00,$40
  6+  6B82 24 10 AD     					DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
  7+  6B85 00 00        memfill_bstrt  		DB $00,$00
  8+  6B87 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
  9+  6B8B              memfill_cmd_len	  	EQU $ - memfill
 10+  6B8B
 11+  6B8B              memfill_dma:
 12+  6B8B              ; "memfill_dma, hl = address to fill, a = value, de = length"
 13+  6B8B              .set_fill_value:
 14+  6B8B 32 78 6B     	ld 		(memfillvalue),a
 15+  6B8E              .set_target:
 16+  6B8E 22 85 6B     	ld		(memfill_bstrt),hl
 17+  6B91              .set_length:
 18+  6B91 ED 53 80 6B  	ld		(memfill_length),de
 19+  6B95              .write_dma:
 20+  6B95 21 79 6B     	ld 		hl, memfill
 21+  6B98 06 12        	ld 		b, memfill_cmd_len
 22+  6B9A 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
 23+  6B9C ED B3        	otir
 24+  6B9E C9           	ret
 25+  6B9F
# file closed: ../../Hardware/memfill_dma.asm
832   6B9F              ; Layer 1  ------------------------------------------------------------------------------------------------------------------------
833   6B9F                  INCLUDE "../../Layer1Graphics/layer1_attr_utils.asm"
# file opened: ../../Layer1Graphics/layer1_attr_utils.asm
  1+  6B9F
  2+  6B9F 00 58        L1AttrRow00:            DW $5800                    ;Row 1    */
  3+  6BA1 20 58        L1AttrRow01:            DW $5820                    ;Row 2    */
  4+  6BA3 40 58        L1AttrRow02:            DW $5840                    ;Row 3    */
  5+  6BA5 60 58        L1AttrRow03:            DW $5860                    ;Row 4    */
  6+  6BA7 80 58        L1AttrRow04:            DW $5880                    ;Row 5    */
  7+  6BA9 A0 58        L1AttrRow05:            DW $58A0                    ;Row 6    */
  8+  6BAB C0 58        L1AttrRow06:            DW $58C0                    ;Row 7    */
  9+  6BAD E0 58        L1AttrRow07:            DW $58E0                    ;Row 8    */
 10+  6BAF 00 59        L1AttrRow08:            DW $5900                    ;Row 9    */
 11+  6BB1 20 59        L1AttrRow09:            DW $5920                    ;Row 10   */
 12+  6BB3 40 59        L1AttrRow10:            DW $5940                    ;Row 11   */
 13+  6BB5 60 59        L1AttrRow11:            DW $5960                    ;Row 12   */
 14+  6BB7 80 59        L1AttrRow12:            DW $5980                    ;Row 13   */
 15+  6BB9 A0 59        L1AttrRow13:            DW $59A0                    ;Row 14   */
 16+  6BBB C0 59        L1AttrRow14:            DW $59C0                    ;Row 15   */
 17+  6BBD E0 59        L1AttrRow15:            DW $59E0                    ;Row 16   */
 18+  6BBF 00 5A        L1AttrRow16:            DW $5A00                    ;Row 17   */
 19+  6BC1 20 5A        L1AttrRow17:            DW $5A20                    ;Row 18   */
 20+  6BC3 40 5A        L1AttrRow18:            DW $5A40                    ;Row 19   */
 21+  6BC5 60 5A        L1AttrRow19:            DW $5A60                    ;Row 20   */
 22+  6BC7 80 5A        L1AttrRow20:            DW $5A80                    ;Row 21   */
 23+  6BC9 A0 5A        L1AttrRow21:            DW $5AA0                    ;Row 22   */
 24+  6BCB C0 5A        L1AttrRow22:            DW $5AC0                    ;Row 23   */
 25+  6BCD E0 5A        L1AttrRow23:            DW $5AE0                    ;Row 23   */
 26+  6BCF
 27+  6BCF              ; "l2_hilight_row, d = row, e = colour"
 28+  6BCF 21 9F 6B     l1_hilight_row:         ld      hl, L1AttrRow00
 29+  6BD2 4B                                   ld      c,e
 30+  6BD3 7A                                   ld      a,d
 31+  6BD4 CB 27                                sla     a
 32+  6BD6 ED 31                                add     hl,a
 33+  6BD8 7E                                   ld      a,(hl)
 34+  6BD9 5F                                   ld      e,a
 35+  6BDA 23                                   inc     hl
 36+  6BDB 7E                                   ld      a,(hl)
 37+  6BDC 57                                   ld      d,a
 38+  6BDD EB                                   ex      hl,de
 39+  6BDE 79                                   ld		a,c
 40+  6BDF 11 20 00                             ld		de, 32
 41+  6BE2 CD 8B 6B                             call	memfill_dma
 42+  6BE5 C9                                   ret
 43+  6BE6
# file closed: ../../Layer1Graphics/layer1_attr_utils.asm
834   6BE6                  INCLUDE "../../Layer1Graphics/layer1_cls.asm"
# file opened: ../../Layer1Graphics/layer1_cls.asm
  1+  6BE6 AF           l1_cls_top:             xor     a
  2+  6BE7 21 00 40                             ld      hl, $4000
  3+  6BEA 11 00 08                             ld      de, $0800
  4+  6BED CD 8B 6B                             call    memfill_dma
  5+  6BF0 C9                                   ret
  6+  6BF1
  7+  6BF1 AF           l1_cls_mid:             xor     a
  8+  6BF2 21 00 48                             ld      hl, $4800
  9+  6BF5 11 00 08                             ld      de, $0800
 10+  6BF8 CD 8B 6B                             call    memfill_dma
 11+  6BFB C9                                   ret
 12+  6BFC
 13+  6BFC AF           l1_cls_bottom:          xor     a
 14+  6BFD 21 00 50                             ld      hl, $5000
 15+  6C00 11 00 08                             ld      de, $0800
 16+  6C03 CD 8B 6B                             call    memfill_dma
 17+  6C06 C9                                   ret
 18+  6C07
 19+  6C07              ; Designed specifically to clear a whole character aligned line
 20+  6C07 1E 00        l1_cls_line_d:          ld      e,0
 21+  6C09 ED 94                                pixelad
 22+  6C0B 11 00 01                             ld      de,32 * 8
 23+  6C0E AF                                   xor     a
 24+  6C0F CD 8B 6B                             call    memfill_dma
 25+  6C12 C9                                   ret
 26+  6C13
 27+  6C13              ; Designed specifically to clear a whole character aligned 2 lines line, used for say clearing hyperspace message
 28+  6C13 1E 00        l1_cls_2_lines_d:       ld      e,0
 29+  6C15 ED 94                                pixelad
 30+  6C17 11 00 02                             ld      de,32 * 16
 31+  6C1A AF                                   xor     a
 32+  6C1B CD 8B 6B                             call    memfill_dma
 33+  6C1E C9                                   ret
 34+  6C1F
 35+  6C1F AF           l1_cls:                 xor		a
 36+  6C20 21 00 40     l1_cls_to_a:            ld		hl,	$4000
 37+  6C23 11 00 18                             ld		de, $1800
 38+  6C26 CD 8B 6B                             call	memfill_dma
 39+  6C29 C9                                   ret
 40+  6C2A
 41+  6C2A 21 00 58     l1_attr_cls_2DlinesA:   ld		hl,	$5800
 42+  6C2D 1E 20                                ld      e,32
 43+  6C2F ED 30                                mul
 44+  6C31 19                                   add     hl,de
 45+  6C32 11 40 00                             ld		de, 32 * 2
 46+  6C35 CD 8B 6B                             call	memfill_dma
 47+  6C38 C9                                   ret
 48+  6C39
 49+  6C39
 50+  6C39 AF           l1_attr_cls:            xor		a
 51+  6C3A 21 00 58     l1_attr_cls_to_a:       ld		hl,	$5800
 52+  6C3D 11 00 03                             ld		de, $0300
 53+  6C40 CD 8B 6B                             call	memfill_dma
 54+  6C43 C9                                   ret
 55+  6C44
 56+  6C44 01 FE FE     l1_set_border:          ld	    bc, 0xFEFE
 57+  6C47 ED 79                                out		(c),a
 58+  6C49 C9                                   ret
# file closed: ../../Layer1Graphics/layer1_cls.asm
835   6C4A                  INCLUDE "../../Layer1Graphics/layer1_print_at.asm"
# file opened: ../../Layer1Graphics/layer1_print_at.asm
  1+  6C4A              ; "l1 print char a = character, de = Ypixel Xpxiel rounded to char of print"
  2+  6C4A D5 E5        l1_print_char:          push	de,,hl
  3+  6C4C ED 94                                pixelad								; hl = address of de
  4+  6C4E E5                                   push	hl							; save hl for loop
  5+  6C4F 26 00                                ld		h,0
  6+  6C51 6F                                   ld		l,a
  7+  6C52 29                                   add		hl,hl						; * 2
  8+  6C53 29                                   add		hl,hl						; * 4
  9+  6C54 29                                   add		hl,hl						; * 8 to get byte address
 10+  6C55 ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
 11+  6C59 EB                                   ex		de,hl						; save address into de
 12+  6C5A E1                                   pop		hl							; get back hl for loop
 13+  6C5B 06 08                                ld		b,8							; do 8 rows
 14+  6C5D 1A           .PrintCharLoop:         ld		a,(de)						; row byte
 15+  6C5E 13                                   inc		de							; next byte
 16+  6C5F 77                                   ld		(hl),a						; poke to screen
 17+  6C60 ED 93                                pixeldn								; Down 1 row
 18+  6C62 10 F9                                djnz	.PrintCharLoop				; loop for 8 bytes
 19+  6C64 E1 D1                                pop		de,,hl					    ; restore hl
 20+  6C66 C9                                   ret
 21+  6C67
 22+  6C67              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
 23+  6C67              ; now skips ascii code < 32 but moves on cursor by 1 char
 24+  6C67              l1_print_at_char
 24+  6C67 CB 22           sla     d       ; Convert D from char to pixel
 25+  6C69 CB 22                                sla     d       ; by muliplying by 8
 26+  6C6B CB 22                                sla     d       ;
 27+  6C6D CB 23                                sla     e       ; Convert E from char to pixel
 28+  6C6F CB 23                                sla     e
 29+  6C71 CB 23                                sla     e
 30+  6C73              l1_print_at:
 31+  6C73 7E           .PrintLoop:             ld		a,(hl)
 32+  6C74 FE 00                                cp		0
 33+  6C76 C8                                   ret		z
 34+  6C77                                      CallIfAGTENusng " ", l1_print_char
 34+  6C77 FE 20       >                        cp      " "
 34+  6C79 D4 4A 6C    >                        call	nc,l1_print_char
 35+  6C7C 23                                   inc		hl							; move 1 message character right
 36+  6C7D 7B                                   ld		a,e
 37+  6C7E C6 08                                add		a,8
 38+  6C80 5F                                   ld		e,a							; move 1 screen character right
 39+  6C81 18 F0                                jr		.PrintLoop
 40+  6C83                                                      DISPLAY "TODO: looks liek rogue popde"
 41+  6C83              .Clearstackandfinish:   ;pop		de                      ; TODO LOOOKS TO BE A ROGUE POPDE
 42+  6C83 C9                                   ret
 43+  6C84
 44+  6C84
 45+  6C84
 46+  6C84 30 30 00     HexU8Char:       DB "00",0
 47+  6C87 30 30 30 30  HexU16Char:      DB "0000",0
 47+  6C8B 00
 48+  6C8C 2B 30 30 00  HexS8Char:       DB "+00",0
 49+  6C90 2B 30 30 30  HexS16Char:      DB "+0000",0
 49+  6C94 30 00
 50+  6C96 2B 30 30 30  HexS24Char:      DB "+0000.00",0
 50+  6C9A 30 2E 30 30
 50+  6C9E 00
 51+  6C9F 2A 2A 00     HexU8NaN:        DB "**",0
 52+  6CA2 30 30 30 30  Bin8Bit:         DB "00000000",0
 52+  6CA6 30 30 30 30
 52+  6CAA 00
 53+  6CAB              ; prints + sign for bit 7 clear in a else - sign for bit 7 set, Load to buffer location in ix
 54+  6CAB CB 7F        l1_buffer_sign_at_ix:   bit     7,a
 55+  6CAD CA B6 6C                             jp      z,.PrintPlus
 56+  6CB0 3E 2D        .PrintMinus:            ld      a,"-"
 57+  6CB2 DD 77 00                             ld      (ix+0),a
 58+  6CB5 C9                                   ret
 59+  6CB6 3E 2B        .PrintPlus:             ld      a,"+"
 60+  6CB8 DD 77 00                             ld      (ix+0),a
 61+  6CBB C9                                   ret
 62+  6CBC
 63+  6CBC 30 31 32 33  HexMapping:     DB "0123456789ABCDEF"
 63+  6CC0 34 35 36 37
 63+  6CC4 38 39 41 42
 63+  6CC8 43 44 45 46
 64+  6CCC              ; writes hex 8 bit to ix buffer position
 65+  6CCC C5 E5        l1_buffer_hex_8_at_ix:  push    bc,,hl
 66+  6CCE 47                                   ld      b,a
 67+  6CCF ED 23                                swapnib
 68+  6CD1 E6 0F                                and     $0F
 69+  6CD3 21 BC 6C                             ld      hl,HexMapping
 70+  6CD6 ED 31                                add     hl,a
 71+  6CD8 7E                                   ld      a,(hl)
 72+  6CD9 DD 77 00                             ld      (ix+0),a
 73+  6CDC 21 BC 6C                             ld      hl,HexMapping
 74+  6CDF 78                                   ld      a,b
 75+  6CE0 E6 0F                                and     $0F
 76+  6CE2 ED 31                                add     hl,a
 77+  6CE4 7E                                   ld      a,(hl)
 78+  6CE5 DD 77 01                             ld      (ix+1),a
 79+  6CE8 E1 C1                                pop     bc,,hl
 80+  6CEA C9                                   ret
 81+  6CEB F5 C5 D5 E5  l1_print_bin8_at_char:    push  af,,bc,,de,,hl
 82+  6CEF DD 21 A2 6C                            ld    ix,Bin8Bit
 83+  6CF3 06 08                                  ld    b,8
 84+  6CF5 CB 27        .WriteLoop:               sla   a
 85+  6CF7 38 05                                  jr    c,.ItsaOne
 86+  6CF9 0E 30        .ItsAZero:                ld    c,'0'
 87+  6CFB C3 00 6D                               jp    .DoWrite
 88+  6CFE 0E 31        .ItsaOne:                 ld    c,'1'
 89+  6D00 DD 71 00     .DoWrite:                 ld    (ix+0),c
 90+  6D03 DD 23                                  inc   ix
 91+  6D05 10 EE                                  djnz  .WriteLoop
 92+  6D07 E1 D1 C1 F1                            pop   af,,bc,,de,,hl
 93+  6D0B 21 A2 6C                               ld    hl,Bin8Bit
 94+  6D0E CD 67 6C                               call  l1_print_at_char
 95+  6D11 C9                                     ret
 96+  6D12
 97+  6D12 F5 C5 D5 E5  l1_print_bin8_r2l_at_char:push  af,,bc,,de,,hl
 98+  6D16 DD 21 A2 6C                            ld    ix,Bin8Bit
 99+  6D1A 06 08                                  ld    b,8
100+  6D1C CB 3F        .WriteLoop:               srl   a
101+  6D1E 38 05                                  jr    c,.ItsaOne
102+  6D20 0E 30        .ItsAZero:                ld    c,'0'
103+  6D22 C3 27 6D                               jp    .DoWrite
104+  6D25 0E 31        .ItsaOne:                 ld    c,'1'
105+  6D27 DD 71 00     .DoWrite:                 ld    (ix+0),c
106+  6D2A DD 23                                  inc   ix
107+  6D2C 10 EE                                  djnz  .WriteLoop
108+  6D2E E1 D1 C1 F1                            pop   af,,bc,,de,,hl
109+  6D32 21 A2 6C                               ld    hl,Bin8Bit
110+  6D35 CD 67 6C                               call  l1_print_at_char
111+  6D38 C9                                     ret
112+  6D39
113+  6D39 F5 C5 D5 E5  l1_print_bin8_l2r_at_char:push  af,,bc,,de,,hl
114+  6D3D DD 21 A2 6C                            ld    ix,Bin8Bit
115+  6D41 06 08                                  ld    b,8
116+  6D43 CB 27        .WriteLoop:               sla   a
117+  6D45 38 05                                  jr    c,.ItsaOne
118+  6D47 0E 30        .ItsAZero:                ld    c,'0'
119+  6D49 C3 4E 6D                               jp    .DoWrite
120+  6D4C 0E 31        .ItsaOne:                 ld    c,'1'
121+  6D4E DD 71 00     .DoWrite:                 ld    (ix+0),c
122+  6D51 DD 23                                  inc   ix
123+  6D53 10 EE                                  djnz  .WriteLoop
124+  6D55 E1 D1 C1 F1                            pop   af,,bc,,de,,hl
125+  6D59 21 A2 6C                               ld    hl,Bin8Bit
126+  6D5C CD 67 6C                               call  l1_print_at_char
127+  6D5F C9                                     ret
128+  6D60
129+  6D60              ; prints 16 bit lead sign hex value in HLA at char pos DE
130+  6D60 F5           l1_print_s24_hex_at_char: push  af                      ; first off do sign
131+  6D61 DD 21 96 6C                            ld    ix,HexS24Char
132+  6D65 7C                                     ld    a,h
133+  6D66 CD AB 6C                               call  l1_buffer_sign_at_ix
134+  6D69 F1                                     pop   af                      ; now do hl as an unsigned by clearing bit 7
135+  6D6A DD 23                                  inc   ix                      ; move to actual digits
136+  6D6C F5                                     push  af
137+  6D6D 7C                                     ld    a,h
138+  6D6E CB BF                                  res   7,a                     ; clear sign bit regardless
139+  6D70 CD CC 6C                               call  l1_buffer_hex_8_at_ix
140+  6D73 DD 23                                  inc   ix
141+  6D75 DD 23                                  inc   ix
142+  6D77 7D                                     ld    a,l
143+  6D78 CD CC 6C                               call  l1_buffer_hex_8_at_ix
144+  6D7B DD 23                                  inc   ix
145+  6D7D DD 23                                  inc   ix
146+  6D7F DD 23                                  inc   ix                      ; also skip decimal point
147+  6D81 F1                                     pop   af
148+  6D82 CD CC 6C                               call  l1_buffer_hex_8_at_ix
149+  6D85 21 96 6C                               ld    hl,HexS24Char           ; by here de is still unaffected
150+  6D88 CD 67 6C                               call  l1_print_at_char
151+  6D8B C9                                     ret
152+  6D8C              ; prints 16 bit lead sign hex value in HL at char pos DE
153+  6D8C DD 21 90 6C  l1_print_s16_hex_at_char: ld    ix,HexS16Char
154+  6D90 7C                                     ld    a,h
155+  6D91 CD AB 6C                               call  l1_buffer_sign_at_ix
156+  6D94 DD 23                                  inc   ix                      ; move to actual digits
157+  6D96 7C                                     ld    a,h
158+  6D97 CB BF                                  res   7,a
159+  6D99 CD CC 6C                               call  l1_buffer_hex_8_at_ix
160+  6D9C DD 23                                  inc   ix
161+  6D9E DD 23                                  inc   ix
162+  6DA0 7D                                     ld    a,l
163+  6DA1 CD CC 6C                               call  l1_buffer_hex_8_at_ix
164+  6DA4 21 90 6C                               ld    hl,HexS16Char           ; by here de is still unaffected
165+  6DA7 CD 67 6C                               call  l1_print_at_char
166+  6DAA C9                                     ret
167+  6DAB              ; prints 16 bit unsigned hext value in HL at char pos DE
168+  6DAB DD 21 87 6C  l1_print_u16_hex_at_char: ld    ix,HexU16Char
169+  6DAF 7C                                     ld    a,h
170+  6DB0 CD CC 6C                               call  l1_buffer_hex_8_at_ix
171+  6DB3 DD 23                                  inc   ix
172+  6DB5 DD 23                                  inc   ix
173+  6DB7 7D                                     ld    a,l
174+  6DB8 CD CC 6C                               call  l1_buffer_hex_8_at_ix
175+  6DBB 21 87 6C                               ld    hl,HexU16Char           ; by here de is still unaffected
176+  6DBE CD 67 6C                               call  l1_print_at_char
177+  6DC1 C9                                     ret
178+  6DC2              ; prints 8 bit signed hext value in a at char pos DE
179+  6DC2 DD 21 8C 6C  l1_print_s8_hex_at_char:  ld    ix,HexS8Char
180+  6DC6 67                                     ld    h,a                     ; save a into h
181+  6DC7 CD AB 6C                               call  l1_buffer_sign_at_ix
182+  6DCA DD 23                                  inc   ix                      ; move to actual digits
183+  6DCC 7C                                     ld    a,h                     ; get a back
184+  6DCD CB BF                                  res   7,a                     ; clear sign bit regardless
185+  6DCF CD CC 6C                               call  l1_buffer_hex_8_at_ix
186+  6DD2 21 8C 6C                               ld    hl,HexS8Char           ; by here de is still unaffected
187+  6DD5 CD 67 6C                               call  l1_print_at_char
188+  6DD8 C9                                     ret
189+  6DD9              ; prints 8 bit 2s compliment value in a at char pos DE
190+  6DD9 DD 21 8C 6C  l1_print_82c_hex_at_char: ld    ix,HexS8Char
191+  6DDD 67                                     ld    h,a                     ; save a into h
192+  6DDE CD AB 6C                               call  l1_buffer_sign_at_ix
193+  6DE1 DD 23                                  inc   ix                      ; move to actual digits
194+  6DE3 7C                                     ld    a,h                     ; get a back
195+  6DE4 CB 7F                                  bit   7,a
196+  6DE6 CA EB 6D                               jp    z,.NoNeg
197+  6DE9 ED 44                                  neg
198+  6DEB CD CC 6C     .NoNeg:                   call  l1_buffer_hex_8_at_ix
199+  6DEE 21 8C 6C                               ld    hl,HexS8Char           ; by here de is still unaffected
200+  6DF1 CD 67 6C                               call  l1_print_at_char
201+  6DF4 C9                                     ret
202+  6DF5
203+  6DF5              ; prints Lead Sign byte 8 bit signed hex value in hl at char pos DE, reuse HexS8Char buffer
204+  6DF5 DD 21 8C 6C  l1_print_s08_hex_at_char: ld    ix,HexS8Char
205+  6DF9 CD AB 6C                               call  l1_buffer_sign_at_ix    ; h holds sign bit
206+  6DFC DD 23                                  inc   ix                      ; move to actual digits
207+  6DFE 7D                                     ld    a,l                     ; l holds value
208+  6DFF CD CC 6C                               call  l1_buffer_hex_8_at_ix
209+  6E02 21 8C 6C                               ld    hl,HexS8Char           ; by here de is still unaffected
210+  6E05 CD 67 6C                               call  l1_print_at_char
211+  6E08 C9                                     ret
212+  6E09              ; prints 8 bit signed hext value in a at char pos DE
213+  6E09 DD 21 84 6C  l1_print_u8_hex_at_char:  ld    ix,HexU8Char
214+  6E0D CD CC 6C                               call  l1_buffer_hex_8_at_ix
215+  6E10 21 84 6C                               ld    hl,HexU8Char           ; by here de is still unaffected
216+  6E13 CD 67 6C                               call  l1_print_at_char
217+  6E16 C9                                     ret
218+  6E17 2B 00        l1_PlusSign:              DB      "+",0
219+  6E19 2D 00        l1_MinusSign:             DB      "-",0
220+  6E1B 20 00        l1_ClearSign:             DB      " ",0
221+  6E1D              ; Displays sign byte in A at DE
222+  6E1D FE 80        l1_printSignByte:         cp      $80
223+  6E1F C2 35 6E                               jp      nz,.DisplayPlus
224+  6E22 FE 01                                  cp      1
225+  6E24 C2 2E 6E                               jp      nz,.DisplayMinus
226+  6E27 21 1B 6E     .DisplayClear:            ld      hl,l1_ClearSign
227+  6E2A CD 67 6C                               call    l1_print_at_char
228+  6E2D C9                                     ret
229+  6E2E 21 19 6E     .DisplayMinus             ld      hl,l1_MinusSign
230+  6E31 CD 67 6C                               call    l1_print_at_char
231+  6E34 C9                                     ret
232+  6E35 21 17 6E     .DisplayPlus:             ld      hl,l1_PlusSign
233+  6E38 CD 67 6C                               call    l1_print_at_char
234+  6E3B C9                                     ret
235+  6E3C
236+  6E3C 21 9F 6C     l1_print_u8_nan_at_char:  ld    hl,HexU8NaN
237+  6E3F CD 67 6C                               call  l1_print_at_char
238+  6E42 C9                                     ret
239+  6E43
240+  6E43
241+  6E43              ;l1_print_at_wrap:
242+  6E43              ;; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
243+  6E43              ;	ld      iyh,e
244+  6E43              ;.PrintLoop:
245+  6E43              ;	ld		a,(hl)
246+  6E43              ;	cp		0
247+  6E43              ;	ret		z
248+  6E43              ;.CountWordCharLen
249+  6E43              ;; Need to change to word wrap, so it will loop through string as before
250+  6E43              ;; but read up until a null or space, take the character count * 8 for pixels
251+  6E43              ;; if that is > 238 then force a premature line wrap
252+  6E43              ;
253+  6E43              ;
254+  6E43              ;    push    iy
255+  6E43              ;    call	l1_print_char
256+  6E43              ;    pop     iy
257+  6E43              ;	inc		hl							; move 1 message character right
258+  6E43              ;	ld		a,e
259+  6E43              ;    cp      238
260+  6E43              ;    jr      nc,.NextLine
261+  6E43              ;	add		a,8
262+  6E43              ;	ld		e,a							; move 1 screen character right
263+  6E43              ;	jr		.PrintLoop
264+  6E43              ;.Clearstackandfinish:
265+  6E43              ;	pop		de
266+  6E43              ;	ret
267+  6E43              ;.NextLine:
268+  6E43              ;    ld      a,(hl)
269+  6E43              ;    cp      " "
270+  6E43              ;    ld      e,iyh
271+  6E43              ;    ld      a,d
272+  6E43              ;    add     a,8
273+  6E43              ;    ld      d,a
274+  6E43              ;    jr		.PrintLoop
275+  6E43
276+  6E43              ; Counts next word at hl, uses e and forces a wrap if it would over flow puts value in c
277+  6E43 E5           L1LenWordAtHL:          push    hl
278+  6E44 D5                                   push    de
279+  6E45 7E           .CountLoop:             ld      a,(hl)
280+  6E46 FE 00                                cp      0
281+  6E48 28 0F                                jr      z,.CountDone
282+  6E4A FE 20                                cp      32
283+  6E4C 28 0B                                jr      z,.CountDone
284+  6E4E 7B                                   ld      a,e
285+  6E4F C6 08                                add     a,8
286+  6E51 5F                                   ld      e,a
287+  6E52 FE EE                                cp      238
288+  6E54 30 07                                jr      nc,.TooLong
289+  6E56 23                                   inc     hl
290+  6E57 18 EC                                jr      .CountLoop
291+  6E59 D1           .CountDone:             pop     de
292+  6E5A E1                                   pop     hl
293+  6E5B AF                                   xor     a
294+  6E5C C9                                   ret
295+  6E5D D1           .TooLong                pop     de
296+  6E5E E1                                   pop     hl
297+  6E5F 3E FF                                ld      a,$FF
298+  6E61 C9                                   ret
299+  6E62
300+  6E62 7E           L1PrintWordAtHL:        ld      a,(hl)
301+  6E63 FE 00                                cp      0
302+  6E65 C8                                   ret     z
303+  6E66 FE 20                                cp      32
304+  6E68 28 0F                                jr      z,.ItsASpace
305+  6E6A FD E5                                push    iy
306+  6E6C CD 4A 6C                             call	l1_print_char
307+  6E6F FD E1                                pop     iy
308+  6E71 7B                                   ld      a,e
309+  6E72 C6 08                                add     a,8
310+  6E74 5F                                   ld      e,a
311+  6E75 23                                   inc     hl
312+  6E76 C3 62 6E                             jp      L1PrintWordAtHL
313+  6E79 23           .ItsASpace:             inc     hl      ;  Just a bodge for now
314+  6E7A 7B                                   ld      a,e
315+  6E7B C6 08                                add     a,8
316+  6E7D 5F                                   ld      e,a
317+  6E7E C9                                   ret
318+  6E7F
319+  6E7F
320+  6E7F              ; print at based whole character positions DE=yx, HL = message Addr
321+  6E7F              ;
322+  6E7F CB 22        l1_print_at_char_wrap:  sla     d       ; Convert D from char to pixel
323+  6E81 CB 22                                sla     d       ; by muliplying by 8
324+  6E83 CB 22                                sla     d       ;
325+  6E85              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
326+  6E85              ; Now has full word level wrapping
327+  6E85 FD 63        l1_print_at_wrap:       ld      iyh,e
328+  6E87 7E           .PrintLoop:             ld		a,(hl)
329+  6E88 FE 00                                cp		0
330+  6E8A C8                                   ret		z
331+  6E8B CD 43 6E     .CountWordCharLen:      call    L1LenWordAtHL
332+  6E8E FE FF                                cp      $FF
333+  6E90 28 06                                jr      z,.WrapNextLine
334+  6E92 CD 62 6E     .NotTooLong:            call    L1PrintWordAtHL
335+  6E95              ; Need to change to word wrap, so it will loop through string as before
336+  6E95              ; but read up until a null or space, take the character count * 8 for pixels
337+  6E95              ; if that is > 238 then force a premature line wrap
338+  6E95 18 F0                                jr		.PrintLoop
339+  6E97              .Clearstackandfinish:   ;op		de
340+  6E97 C9                                   ret
341+  6E98              .WrapNextLine:
342+  6E98 FD 5C        .NextLine:              ld      e,iyh
343+  6E9A 7A                                   ld      a,d
344+  6E9B C6 08                                add     a,8
345+  6E9D 57                                   ld      d,a
346+  6E9E 18 E7                                jr		.PrintLoop
347+  6EA0
348+  6EA0
# file closed: ../../Layer1Graphics/layer1_print_at.asm
836   6EA0
837   6EA0              ; Keyboard
838   6EA0 FE FD FB F7  KeyAddrTab				DB	$FE, $FD, $FB, $F7, $EF, $DF, $BF, $7F
838   6EA4 EF DF BF 7F
839   6EA8
840   6EA8 21 A0 6E     WaitForNoKey:           ld      hl,KeyAddrTab                   ; de = table of IO ports to read
841   6EAB 06 08                                ld		b,8                             ; 8 ports to ready
842   6EAD 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
843   6EAE DB FE                                in		a,($FE)							; read port to a
844   6EB0 E6 1F                                and     %00011111
845   6EB2 FE 1F                                cp      %00011111
846   6EB4 20 F2                                jr      nz ,WaitForNoKey
847   6EB6 23                                   inc		hl                              ; and ready for next read
848   6EB7 10 F4                                djnz    .PortReadLoop
849   6EB9 C9                                   ret
850   6EBA 57 61 69 74  WaitMsg:                DB "Waiting for Input",0
850   6EBE 69 6E 67 20
850   6EC2 66 6F 72 20
850   6EC6 49 6E 70 75
850   6ECA 74 00
851   6ECC 2E 2E 2E 2E  WaitClear:              DB ".................",0
851   6ED0 2E 2E 2E 2E
851   6ED4 2E 2E 2E 2E
851   6ED8 2E 2E 2E 2E
851   6EDC 2E 00
852   6EDE F5 D5 C5 E5  WaitForAnyKey:          push    af,,de,,bc,,hl
853   6EE2                                      IFDEF DEBUGMODE
854   6EE2                                          MessageAt 10,20,WaitMsg
854   6EE2 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
854   6EE6 16 14       >                        ld      d,20
854   6EE8 1E 50       >                        ld      e,10*8
854   6EEA 21 BA 6E    >                        ld      hl,WaitMsg
854   6EED CD 7F 6E    >                        call    l1_print_at_char_wrap
854   6EF0 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
855   6EF4                                      ENDIF
856   6EF4 CD A8 6E                             call    WaitForNoKey
857   6EF7 21 A0 6E     .waitKeyLoop:           ld		hl,KeyAddrTab                   ; de = table of IO ports to read
858   6EFA 06 08                                ld		b,8                             ; 8 ports to ready
859   6EFC 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
860   6EFD DB FE                                in		a,($FE)							; read port to a
861   6EFF E6 1F                                and     %00011111
862   6F01 FE 1F                                cp      %00011111
863   6F03 C2 0D 6F                             jp      nz,.WaitComplete
864   6F06 C0                                   ret     nz
865   6F07 23                                   inc		hl                              ; and ready for next read
866   6F08 10 F2                                djnz    .PortReadLoop
867   6F0A C3 F7 6E                             jp      .waitKeyLoop
868   6F0D E1 C1 D1 F1  .WaitComplete:          pop     af,,de,,bc,,hl
869   6F11                                      IFDEF DEBUGMODE
870   6F11                                          MessageAt 10,20,WaitClear
870   6F11 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
870   6F15 16 14       >                        ld      d,20
870   6F17 1E 50       >                        ld      e,10*8
870   6F19 21 CC 6E    >                        ld      hl,WaitClear
870   6F1C CD 7F 6E    >                        call    l1_print_at_char_wrap
870   6F1F E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
871   6F23                                      ENDIF
872   6F23 C9                                   ret
873   6F24
874   6F24              MainNonBankedCodeEnd:
875   6F24
876   6F24
877   6F24                  SAVENEX OPEN "piiotest.nex", EliteNextStartup , TopOfStack
878   6F24                  SAVENEX CFG  0,0,0,1
879   6F24                  SAVENEX AUTO
880   6F24                  SAVENEX CLOSE
881   6F24                  DISPLAY "Main Non Banked Code End ", MainNonBankedCodeEnd , " Bytes free ", 0B000H - MainNonBankedCodeEnd
882   6F24                  ASSERT MainNonBankedCodeEnd < 0B000H, Program code leaks intot interrup vector table
883   6F24
# file closed: piiotest.asm
