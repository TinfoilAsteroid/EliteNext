# file opened: piiotest.asm
  1   0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
  2   0000                              DISPLAY "Piio test"
  3   0000                              DISPLAY "-------------------------------------------------------------------------------------------------------------------------"
  4   0000
  5   0000
  6   0000                  DEFINE DEBUGMODE 1
  7   0000                  DEVICE ZXSPECTRUMNEXT
  8   0000                  SLDOPT COMMENT WPMEM, LOGPOINT, ASSERTION
  9   0000               CSPECTMAP piiotest.map
 10   0000               OPT --zxnext=cspect --syntax=a --reversepop
 11   0000                              DEFINE  SOUNDPACE 3
 12   0000              ;                DEFINE  ENABLE_SOUND 1
 13   0000                             DEFINE     MAIN_INTERRUPTENABLE 1
 14   0000              ;               DEFINE INTERRUPT_BLOCKER 1
 15   0000              DEBUGSEGSIZE   equ 1
 16   0000              DEBUGLOGSUMMARY equ 1
 17   0000              ;DEBUGLOGDETAIL equ 1
 18   0000
 19   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 20   0000              ; Game Defines
 21   0000              ScreenLocal      EQU 0
 22   0000              ScreenGalactic   EQU ScreenLocal + 1
 23   0000              ScreenMarket     EQU ScreenGalactic + 1
 24   0000              ScreenMarketDsp  EQU ScreenMarket + 1
 25   0000              ScreenStatus     EQU ScreenMarketDsp + 1
 26   0000              ScreenInvent     EQU ScreenStatus + 1
 27   0000              ScreenPlanet     EQU ScreenInvent + 1
 28   0000              ScreenEquip      EQU ScreenPlanet + 1
 29   0000              ScreenLaunch     EQU ScreenEquip + 1
 30   0000              ScreenFront      EQU ScreenLaunch + 1
 31   0000              ScreenAft        EQU ScreenFront+1
 32   0000              ScreenLeft       EQU ScreenAft+1
 33   0000              ScreenRight      EQU ScreenLeft+1
 34   0000              ScreenDocking    EQU ScreenRight+1
 35   0000              ScreenHyperspace EQU ScreenDocking+1
 36   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 37   0000              ; Colour Defines
 38   0000                  INCLUDE "../../Hardware/L2ColourDefines.asm"
# file opened: ../../Hardware/L2ColourDefines.asm
  1+  0000              L2ColourBLACK           EQU   0
  2+  0000              L2ColourRED_1           EQU 224                 ; RGB 255,  0,  0
  3+  0000              L2ColourRED_2           EQU 192                 ; RGB 218,  0,  0
  4+  0000              L2ColourRED_3           EQU 160                 ; RGB 182,  0,  0
  5+  0000              L2ColourRED_4           EQU 128                 ; RGB 145,  0,  0
  6+  0000              L2ColourRED_5           EQU  96                 ; RGB 109,  0,  0
  7+  0000              L2ColourRED_6           EQU  64                 ; RGB  72,  0,  0
  8+  0000              L2ColourRED_7           EQU  32                 ; RGB  36,  0,  0
  9+  0000              L2ColourYELLOW_1        EQU 252                 ; RGB 255,255,  0
 10+  0000              L2ColourYELLOW_2        EQU 216                 ; RGB 218,218,  0
 11+  0000              L2ColourYELLOW_3        EQU 180                 ; RGB 182,182,  0
 12+  0000              L2ColourYELLOW_4        EQU 144                 ; RGB 145,145,  0
 13+  0000              L2ColourYELLOW_5        EQU 108                 ; RGB 109.109,  0
 14+  0000              L2ColourYELLOW_6        EQU  72                 ; RGB  72, 72,  0
 15+  0000              L2ColourYELLOW_7        EQU  36                 ; RGB  36, 36,  0
 16+  0000              L2ColourGREEN_1		    EQU  28                 ; RGB   0,255,  0
 17+  0000              L2ColourGREEN_2		    EQU  24                 ; RGB   0,218,  0
 18+  0000              L2ColourGREEN_3		    EQU  16                 ; RGB   0,145,  0
 19+  0000              L2ColourGREEN_4         EQU  12                 ; RGB   0,109,  0
 20+  0000              L2ColourGREEN_5         EQU   8                 ; RGB   0, 72,  0
 21+  0000              L2ColourGREEN_6         EQU   4                 ; RGB   0, 36,  0
 22+  0000              L2ColourBLUE_1          EQU   3                 ; RGB 0,0,255
 23+  0000              L2ColourBLUE_2          EQU   2                 ; RGB 0,0,170
 24+  0000              L2ColourBLUE_3          EQU   1                 ; RGB 0,0,85
 25+  0000
 26+  0000
 27+  0000              L2ColourWHITE_1         EQU 255                 ; RGB 255,255,255
 28+  0000              L2ColourWHITE_2         EQU 146
 29+  0000              L2ColourGREY_1		    EQU L2ColourWHITE_2
 30+  0000              L2ColourGREY_2		    EQU 109
 31+  0000              L2ColourGREY_3		    EQU  73
 32+  0000              L2ColourGREY_4		    EQU  37
 33+  0000
 34+  0000              L2ColourGREEN_MB        EQU  29                 ;RGB 0,255,85
 35+  0000              L2ColourGREEN_MR        EQU 124                 ;RGB 109.255,0
 36+  0000              L2ColourCREAM_1         EQU 218                 ; RGB 218,218,170
 37+  0000              L2ColourCREAM_2         EQU 182                 ; RGB 182,182,170
 38+  0000              L2ColourCREAM_3         EQU 146                 ; RGB 145,145,170
 39+  0000
 40+  0000              L2ColourTRANSPARENT     EQU 227                 ; RGB 255,  0,255
 41+  0000              L2ColourMAGENTA_1       EQU 162                 ; RGB 182,  0,170
 42+  0000              L2ColourMAGENTA_2       EQU 130                 ; RGB 145,  0,170
 43+  0000              L2ColourMAGENTA_3       EQU  97                 ; RGB 109,  0, 85
 44+  0000              L2ColourMAGENTA_4       EQU  65                 ; RGB  72,  0, 85
 45+  0000              L2ColourORANGE_1        EQU 236                 ; RGB
 46+  0000              L2ColourORANGE_2        EQU 168                 ; RGB
 47+  0000              L2ColourORANGE_3        EQU  68                 ; RGB
 48+  0000              L2ColourCYAN_1          EQU  31                 ; RGB   0,255, 255
 49+  0000              L2ColourCYAN_2          EQU  18                 ; RGB
 50+  0000              L2ColourCYAN_3          EQU   9                 ; RGB
 51+  0000              L2ColourPURPLE_1        EQU 109                 ; RGB
 52+  0000              L2ColourPURPLE_2        EQU  66                 ; RGB
 53+  0000              L2ColourPURPLE_3        EQU  33                 ; RGB
 54+  0000              L2ColourPINK_1		    EQU 231                 ; RGB
 55+  0000              L2ColourPINK_2		    EQU 226                 ; RGB
 56+  0000              L2ColourPINK_3		    EQU 225                 ; RGB
 57+  0000              L2ColourPINK_4		    EQU 224                 ; RGB
 58+  0000
# file closed: ../../Hardware/L2ColourDefines.asm
 39   0000                  INCLUDE "../../Hardware/L1ColourDefines.asm"
# file opened: ../../Hardware/L1ColourDefines.asm
  1+  0000
  2+  0000              L1ColourInkBlack        EQU %00000000
  3+  0000              L1ColourInkBlue         EQU %00000001
  4+  0000              L1ColourInkRed          EQU %00000010
  5+  0000              L1ColourInkMagenta      EQU %00000011
  6+  0000              L1ColourInkGreen        EQU %00000100
  7+  0000              L1ColourInkCyan         EQU %00000101
  8+  0000              L1ColourInkYellow       EQU %00000110
  9+  0000              L1ColourInkWhite        EQU %00000111
 10+  0000              L1ColourPaperBlack      EQU %00000000
 11+  0000              L1ColourPaperBlue       EQU %00001000
 12+  0000              L1ColourPaperRed        EQU %00010000
 13+  0000              L1ColourPaperMagenta    EQU %00011000
 14+  0000              L1ColourPaperGreen      EQU %00100000
 15+  0000              L1ColourPaperCyan       EQU %00101000
 16+  0000              L1ColourPaperYellow     EQU %00110000
 17+  0000              L1ColourPaperWhite      EQU %00111000
 18+  0000              L1ColourFlash           EQU %10000000
 19+  0000              L1ColourBright          EQU %01000000
 20+  0000              ;----------------------------------------------------------------------------------------------------------------------------------
 21+  0000              ; Screen Specific Colour Defines
 22+  0000              L1InvHighlight          EQU L1ColourBright | L1ColourPaperRed   | L1ColourInkYellow
 23+  0000              L1InvLowlight           EQU                  L1ColourPaperBlack | L1ColourInkWhite
# file closed: ../../Hardware/L1ColourDefines.asm
 40   0000              ;----------------------------------------------------------------------------------------------------------------------------------
 41   0000              ; Total screen list
 42   0000              ; Local Chart
 43   0000              ; Galactic Chart
 44   0000              ; Market Prices
 45   0000              ; Inventory
 46   0000              ; Comander status
 47   0000              ; System Data
 48   0000              ; Mission Briefing
 49   0000              ; missio completion
 50   0000              ; Docked  Menu (only place otehr than pause you can load and save)
 51   0000              ; Pause Menu (only place you can load from )
 52   0000              ; byint and selling equipment
 53   0000              ; bying and selling stock
 54   0000
 55   0000                                      INCLUDE "../../Hardware/register_defines.asm"
# file opened: ../../Hardware/register_defines.asm
  1+  0000              ; Peripheral 2
  2+  0000              ENABLE_CPU_SPEED_MODE                   EQU %10000000
  3+  0000              DIVERT_BEEP_ONLY                        EQU %01000000
  4+  0000              ENABLE_50_60_SWITCH                     EQU %00100000
  5+  0000              ENABLE_MMCAUTO_SWITCH                   EQU %00010000
  6+  0000              ENABLE_MULTIFACE_M1                     EQU %00001000
  7+  0000              PS2MODE_KEYBOARD                        EQU %00000000
  8+  0000              PS2MODE_MOUSE                           EQU %00000100
  9+  0000              AUDIO_CHIPMODE_YM                       EQU %00000000
 10+  0000              AUDIO_CHIPMODE_AY                       EQU %00000001
 11+  0000              AUDIO_CHIPMODE_DISABLED                 EQU %00000010
 12+  0000              INTERNAL_SPEAKER_ENABLE                 EQU %00010000
 13+  0000              ; Peripheral 3
 14+  0000              UNLOCK_PORT_7FFD_PAGING                 EQU %10000000
 15+  0000              DISABLE_RAM_IO_CONTENTION               EQU %01000000
 16+  0000              AY_STEREO_MODE_ACB                      EQU %00100000
 17+  0000              INTERNAL_SPEAKER                        EQU %00010000
 18+  0000              ENABLE_DACS                             EQU %00001000
 19+  0000              ENABLE_TIMEX_VIDEO_MODE                 EQU %00000100
 20+  0000              ENABLE_TURBO_SOUND                      EQU %00000010
 21+  0000              ENABLE_ISSUE2_KEYBOARD                  EQU %00000001
 22+  0000              ; Peripheral 4
 23+  0000              ENABLE_AY2_MONO                         EQU %10000000
 24+  0000              ENABLE_AY1_MONO                         EQU %01000000
 25+  0000              ENABLE_AY0_MONO                         EQU %00100000
 26+  0000              SPRITE_ID_LOCKSTEP                      EQU %00010000
 27+  0000              RESET_DIVMMC_MAPRAM                     EQU %00001000
 28+  0000              SILENCE_HDMI_AUDIO                      EQU %00000100
 29+  0000              SCALLINES_50PCT                         EQU %00000001
 30+  0000              SCANLINES_25PCT                         EQU %00000010
 31+  0000              SCANLINES_125PCT                        EQU %00000011
 32+  0000              ; Audio Registers
 33+  0000              CHANNEL_A_FINE                          EQU 0
 34+  0000              CHANNEL_A_COARSE                        EQU 1
 35+  0000              CHANNEL_B_FINE                          EQU 2
 36+  0000              CHANNEL_B_COARSE                        EQU 3
 37+  0000              CHANNEL_C_FINE                          EQU 4
 38+  0000              CHANNEL_C_COARSE                        EQU 5
 39+  0000              NOISE_PERIOD                            EQU 6
 40+  0000              TONE_ENABLE                             EQU 7
 41+  0000              CHANNEL_A_AMPLITUDE                     EQU 8
 42+  0000              CHANNEL_B_AMPLITUDE                     EQU 9
 43+  0000              CHANNEL_C_AMPLITUDE                     EQU 10
 44+  0000              ENVELOPE_PERIOD_FINE                    EQU 11
 45+  0000              ENVELOPE_PERIOD_COARSE                  EQU 12
 46+  0000              ENVELOPE_SHAPE                          EQU 13
 47+  0000
 48+  0000              ENVELOPE_HOLD_ON                        EQU 1
 49+  0000              ENVELOPE_ALTERNATE_ON                   EQU 2
 50+  0000              ENVELOPE_ATTACK_ON                      EQU 4
 51+  0000              ENVELOPE_CONTINUE_ON                    EQU 8
 52+  0000
 53+  0000              ENVELOPE_SHAPE_SINGLE_DECAY             EQU 0                                                                                    ; \____________
 54+  0000              ENVELOPE_SHAPE_SINGLE_ATTACK            EQU                        ENVELOPE_ATTACK_ON                                            ; /|___________
 55+  0000              ENVELOPE_SHAPE_REPEAT_DECAY             EQU ENVELOPE_CONTINUE_ON                                                                 ; \|\|\|\|\|\|\
 56+  0000              ENVELOPE_SHAPE_REPEAT_DECAY_ATTACK      EQU ENVELOPE_CONTINUE_ON |                      ENVELOPE_ALTERNATE_ON                    ; \/\/\/\/\/\/\
 57+  0000              ENVELOPE_SHAPE_SINGLE_DECAY_HOLD        EQU ENVELOPE_CONTINUE_ON |                      ENVELOPE_ALTERNATE_ON | ENVELOPE_HOLD_ON ; \|-----------
 58+  0000              ENVELOPE_SHAPE_REPEAT_ATTACK            EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON                                            ; /|/|/|/|/|/|/|
 59+  0000              ENVELOPE_SHAPE_SINGLE_ATTACK_HOLD       EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON |                         ENVELOPE_HOLD_ON ; /------------
 60+  0000              ENVELOPE_SHAPE_REPEAT_ATTACK_DECAY      EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON | ENVELOPE_ALTERNATE_ON                    ; /\/\/\/\/\/\/
 61+  0000
 62+  0000              ENVELOPE_HOLD                           EQU %00000001
 63+  0000              ENVELOPE_ALTERNATE                      EQU %00000010
 64+  0000              ENVELOPE_ATTACK                         EQU %00000010
 65+  0000              ENVELOPE_CONTINUE                       EQU %00000010
 66+  0000              ; Sound Control
 67+  0000              TONE_CHANNEL_A                          EQU %00000001
 68+  0000              TONE_CHANNEL_B                          EQU %00000010
 69+  0000              TONE_CHANNEL_C                          EQU %00000100
 70+  0000              NOISE_CHANNEL_A                         EQU %00001000
 71+  0000              NOISE_CHANNEL_B                         EQU %00010000
 72+  0000              NOISE_CHANNEL_C                         EQU %00100000
 73+  0000              ; Version for AND to enabled (its inverted)
 74+  0000              TONE_CHANNEL_A_ON                       EQU %11111110
 75+  0000              TONE_CHANNEL_B_ON                       EQU %11111101
 76+  0000              TONE_CHANNEL_C_ON                       EQU %11111011
 77+  0000              NOISE_CHANNEL_A_ON                      EQU %11110111
 78+  0000              NOISE_CHANNEL_B_ON                      EQU %11101111
 79+  0000              NOISE_CHANNEL_C_ON                      EQU %11011111
 80+  0000
 81+  0000              ; Turbo Sound Control
 82+  0000              TURBO_MANDATORY                         EQU %10011100
 83+  0000              TURBO_LEFT                              EQU %01000000
 84+  0000              TURBO_RIGHT                             EQU %00100000
 85+  0000              TURBO_CHIP_AY3                          EQU %00000011
 86+  0000              TURBO_CHIP_AY2                          EQU %00000010
 87+  0000              TURBO_CHIP_AY1                          EQU %00000001
 88+  0000
 89+  0000              IO_LAYER2_PORT                          EQU $123B
 90+  0000              IO_EXT_BANK_PORT 			            EQU $DFFD ; 57341
 91+  0000              IO_BANK_PORT                            EQU $7FFD ; 32765
 92+  0000              REGISTER_NUMBER_PORT					EQU $243B
 93+  0000              REGISTER_VALUE_PORT						EQU $253B
 94+  0000              SPRITE_SLOT_PORT						EQU $303B ; port for sprite and pattern index
 95+  0000              SPRITE_INFO_PORT                        EQU $0057
 96+  0000              SPRITE_PATTERN_UPLOAD_PORT				EQU $005B
 97+  0000              TURBO_SOUND_NEXT_CONTROL                EQU $FFFD
 98+  0000              SOUND_CHIP_REGISTER_WRITE               EQU $BFFD
 99+  0000              IO_KEYBOARD_PORT                        EQU $FE
100+  0000              IO_DATAGEAR_DMA_PORT 		            EQU $6B
101+  0000              UART_TX_PORT_PORT                       EQU $133B
102+  0000              UART_RX_PORT_PORT                       EQU $143B
103+  0000              UART_CONTROL_PORT                       EQU $153B
104+  0000              UART_FRAME_PORT                         EQU $163B
105+  0000              CTC_CHANNEL1_PORT                       EQU $183B
106+  0000              CTC_CHANNEL2_PORT                       EQU $193B
107+  0000              CTC_CHANNEL3_PORT                       EQU $1A3B
108+  0000              CTC_CHANNEL4_PORT                       EQU $1B3B
109+  0000              PLUS_3_MEMORY_PAGING_CONTROL_PORT       EQU $1FFD
110+  0000              MB02_DMA_PORT                           EQU $0B
111+  0000              SPECDRUM_DAC_OUTPUT                     EQU $DF
112+  0000
113+  0000              Speed_3_5MHZ                            EQU 0
114+  0000              Speed_7MHZ                              EQU 1
115+  0000              Speed_14MHZ                             EQU 2
116+  0000              Speed_28MHZ                             EQU 3
117+  0000
118+  0000
119+  0000              MACHINE_ID_REGISTER						EQU $00
120+  0000              VERSION_REGISTER						EQU $01
121+  0000              RESET_REGISTER		    				EQU $02
122+  0000              MACHINE_TYPE_REGISTER					EQU $03
123+  0000              PAGE_RAM_REGISTER						EQU $04
124+  0000              PERIPHERAL_1_REGISTER					EQU $05   ; Sets joystick mode, video frequency and Scandoubler
125+  0000              PERIPHERAL_2_REGISTER					EQU $06   ; Enables CPU Speed key, DivMMC, Multiface, Mouse and AY audio.
126+  0000              TURBO_MODE_REGISTER						EQU $07
127+  0000              PERIPHERAL_3_REGISTER					EQU $08   ; ABC/ACB Stereo, Internal Speaker, SpecDrum, Timex Video Modes, Turbo Sound Next, RAM contention and [un]lock 128k paging
128+  0000              PERIPHERAL_4_REGISTER                   EQU $09   ; Sets scanlines, AY mono output, Sprite-id lockstep, reset DivMMC mapram and disable HDMI audio
129+  0000              PERIPHERAL_5_REGISTER                   EQU $0A  ; Mouse
130+  0000              CORE_VERSION_REGISTER                   EQU $0E
131+  0000              ANTI_BRICK_SYSTEM_REGISTER				EQU $10
132+  0000              VIDEO_TIMING_REGISTER                   EQU $11
133+  0000              LAYER2_RAM_PAGE_REGISTER				EQU $12
134+  0000              LAYER2_RAM_SHADOW_REGISTER      		EQU $13
135+  0000              TRANSPARENCY_COLOUR_REGISTER			EQU $14
136+  0000              SPRITE_LAYERS_SYSTEM_REGISTER			EQU $15
137+  0000              LAYER2_OFFSET_X_REGISTER				EQU $16
138+  0000              LAYER2_OFFSET_Y_REGISTER				EQU $17
139+  0000              CLIP_WINDOW_LAYER2_REGISTER				EQU $18
140+  0000              CLIP_WINDOW_SPRITES_REGISTER			EQU $19
141+  0000              CLIP_WINDOW_ULA_REGISTER				EQU $1A
142+  0000              CLIP_WINDOW_TILEMAP_REGISTER            EQU $1B
143+  0000              CLIP_WINDOW_CONTROL_REGISTER			EQU $1C
144+  0000              ;29 not used
145+  0000              ACTIVE_VIDEO_LINE_MSB_REGISTER			EQU $1E
146+  0000              ACTIVE_VIDEO_LINE_LSB_REGISTER			EQU $1F
147+  0000              ; 32 to 34 not used
148+  0000              LINE_INTERRUPT_CONTROL_REGISTER			EQU $22
149+  0000              LINE_INTERRUPT_VALUE_LSB_REGISTER		EQU $23
150+  0000              ULA_X_OFFSET_REGISTER                   EQU $26
151+  0000              ULA_Y_OFFSET_REGSITER                   EQU $27
152+  0000              KEYMAP_HIGH_ADDRESS_REGISTER			EQU $28
153+  0000              KEYMAP_LOW_ADDRESS_REGISTER				EQU $29
154+  0000              KEYMAP_HIGH_DATA_REGISTER				EQU $2A
155+  0000              KEYMAP_LOW_DATA_REGISTER				EQU $2B
156+  0000              DAC_B_MIRROR_REGISTER                   EQU $2C
157+  0000              DAC_AB_MIRROR_REGISTER                  EQU $2D
158+  0000              DAC_C_MORROR_REGISTER                   EQU $2E
159+  0000              TILEMAP_OFFSET_XMSB_REGISTER            EQU $2F
160+  0000              TILEMAP_OFFSET_XLSB_REGISTER            EQU $30
161+  0000              TILEMAP_OFFSET_YMSB_REGISTER            EQU $31
162+  0000              LORES_OFFSET_X_REGISTER					EQU $32
163+  0000              LORES_OFFSET_Y_REGISTER					EQU $33
164+  0000              SPRITE_PORT_INDEX_REGISTER              EQU $34
165+  0000              SPRITE_PORT_ATTR0_REGISTER              EQU $35
166+  0000              SPRITE_PORT_ATTR1_REGISTER              EQU $36
167+  0000              SPRITE_PORT_ATTR2_REGISTER              EQU $37
168+  0000              SPRITE_PORT_ATTR3_REGISTER              EQU $38
169+  0000              SPRITE_PORT_ATTR4_REGISTER              EQU $39
170+  0000              PALETTE_INDEX_REGISTER					EQU $40
171+  0000              PALETTE_VALUE_8BIT_REGISTER				EQU $41
172+  0000              PALETTE_FORMAT_REGISTER					EQU $42
173+  0000              PALETTE_CONTROL_REGISTER				EQU $43
174+  0000              PALETTE_VALUE_9BIT_REGISTER				EQU $44
175+  0000              TRANSPARENCY_COLOUR_FALLBACK_REGISTER   EQU $4A
176+  0000              SPRITES_TRANSPARENCY_INDEX_REGISTER     EQU $4B
177+  0000              TILEMAP_TRANSPARENCY_INDEX_REGISTER     EQU $4C
178+  0000              ; 72 to 79 unused
179+  0000              MMU_SLOT_0_REGISTER						EQU $50
180+  0000              MMU_SLOT_1_REGISTER						EQU $51
181+  0000              MMU_SLOT_2_REGISTER						EQU $52
182+  0000              MMU_SLOT_3_REGISTER						EQU $53
183+  0000              MMU_SLOT_4_REGISTER						EQU $54
184+  0000              MMU_SLOT_5_REGISTER						EQU $55
185+  0000              MMU_SLOT_6_REGISTER						EQU $56
186+  0000              MMU_SLOT_7_REGISTER						EQU $57
187+  0000              ; 88 to 95 unused
188+  0000              COPPER_DATA_REGISTER					EQU $60
189+  0000              COPPER_CONTROL_LOW_REGISTER				EQU $61
190+  0000              COPPER_CONTROL_HIGH_REGISTER			EQU $62
191+  0000              COPPER_DATA_16BIT_WRITE_REGISTER        EQU $63
192+  0000              VERTICAL_VIDEO_LINE_OFFSET_REGISTER     EQU $64
193+  0000              ULA_CONTROL_REGISTER                    EQU $68
194+  0000              DISPLAY_CONTROL_1_REGISTER              EQU $69
195+  0000              LORES_CONTROL_REGISTER                  EQU $6A
196+  0000              TILEMAP_CONTROL_REGISTER                EQU $6B
197+  0000              DEFAULT_TILEMAP_ATTRIBUTE_REGISTER      EQU $6C
198+  0000              ; 109 unused
199+  0000              TILEMAP_BASE_ADDRESS_REGISTER           EQU $6E
200+  0000              TILE_DEFINITIONS_BASE_ADDRESS_REGISTER  EQU $6F
201+  0000              LAYER_2_CONTROL_REGISTER                EQU $70
202+  0000              LAYER_2_X_OFFSET_MSB_REGISTER           EQU $71
203+  0000              SPRITE_PORT_MIRROR_ATTRIBUTE_0_WITH_INC EQU $75
204+  0000              SPRITE_PORT_MIRROR_ATTRIBUTE_1_WITH_INC EQU $76
205+  0000              SPRITE_PORT_MIRROR_ATTRIBUTE_2_WITH_INC EQU $77
206+  0000              SPRITE_PORT_MIRROR_ATTRIBUTE_3_WITH_INC EQU $78
207+  0000              SPRITE_PORT_MIRROR_ATTRIBUTE_4_WITH_INC EQU $79
208+  0000              USER_STORAGE_0_REGISTER                 EQU $7F ; general purpose variable, e.g. for copper
209+  0000              EXPANSION_BUS_ENABLE_REGISTER           EQU $80
210+  0000              EXPANSION_BUS_CONTROL_REGISTER          EQU $81
211+  0000              INTERNAL_PORT_DECODING_B0_7_REGISTER    EQU $82
212+  0000              INTERNAL_PORT_DECODING_B8_15_REGISTER   EQU $83
213+  0000              INTERNAL_PORT_DECODING_B16_23_REGISTER  EQU $84
214+  0000              INTERNAL_PORT_DECODING_B24_31_REGISTER  EQU $85
215+  0000              EXPANSION_BUS_DECODING_B0_7_REGISTER    EQU $86
216+  0000              EXPANSION_BUS_DECODING_B8_15_REGISTER   EQU $87
217+  0000              EXPANSION_BUS_DECODING_B16_23_REGISTER  EQU $88
218+  0000              EXPANSION_BUS_DECODING_B24_31_REGISTER  EQU $89
219+  0000              EXPANSION_BUS_IO_PROPAGE_REGISTER       EQU $8A
220+  0000              ALTERNATE_ROM_REGISTER                  EQU $8C
221+  0000              MEMORY_MAPPING_REGISTER                 EQU $8E
222+  0000              PI_GPI_OUTPUT_ENABLE_0_REIGISTER        EQU $98
223+  0000              PI_GPI_OUTPUT_ENABLE_1_REIGISTER        EQU $99
224+  0000              PI_GPI_OUTPUT_ENABLE_2_REIGISTER        EQU $9A
225+  0000              PI_GPI_OUTPUT_ENABLE_3_REIGISTER        EQU $9B
226+  0000              PI_PERPIPHERAL_ENABLE_REGISTER          EQU $A0
227+  0000              PI_I2S_AUDIO_CONTROL_REGISTER           EQU $A2
228+  0000              PI_I2S_CLOCK_DIVIDE_REGISTER            EQU $A3
229+  0000              ESP_WIFI_GPIO_OUTPUT_REGISTER           EQU $A8
230+  0000              ESP_WIFI_GPIO_REGISTER                  EQU $A9
231+  0000              EXTENDED_KEYS_0_REGISTER                EQU $B0
232+  0000              EXTENDED_KEYS_1_REGISTER                EQU $B1
233+  0000              DIVMMC_TRAP_ENABLE_1                    EQU $B2
234+  0000              DIVMMC_TRAP_ENABLE_2                    EQU $B4
235+  0000              DEBUG_LED_CONTROL_REGISTER              EQU $FF
236+  0000
237+  0000              INTERUPT_CONTROL                        EQU $0C ; Interrupt control
238+  0000              NMI_RETURN_LSB				            EQU	$0C2	; NMI Return Address LSB
239+  0000              NMI_RETURN_MSB				            EQU	$0C3	; NMI Return Address MSB
240+  0000              INTERRUPT_EN0				            EQU	$0C4	; INT EN 0
241+  0000              INTERRUPT_EN1				            EQU	$0C5	; INT EN 1
242+  0000              INTERRUPT_EN2				            EQU	$0C6	; INT EN 2
243+  0000              INTERRUPT_ST0				            EQU	$0C8	; INT status 0
244+  0000              INTERRUPT_ST1				            EQU	$0C9	; INT status 1
245+  0000              INTERRUPT_ST2				            EQU	$0CA	; INT status 2
246+  0000              INTERRUPT_DM0				            EQU	$0CC	; INT DMA EN 0
247+  0000              INTERRUPT_DM1				            EQU	$0CD	; INT DMA EN 1
248+  0000              INTERRUPT_DM2				            EQU	$0CE	; INT DMA EN 2
249+  0000              CTC_CHANNEL_0				            EQU	$183B	; CTC channel 0 port
250+  0000              CTC_CHANNEL_1				            EQU	$193B	; CTC channel 1 port
251+  0000              CTC_CHANNEL_2				            EQU	$1A3B	; CTC channel 2 port
252+  0000              CTC_CHANNEL_3				            EQU	$1B3B	; CTC channel 3 port
253+  0000              CTC_CHANNEL_4				            EQU	$1C3B	; CTC channel 4 port
254+  0000              CTC_CHANNEL_5				            EQU	$1D3B	; CTC channel 5 port
255+  0000              CTC_CHANNEL_6				            EQU	$1E3B	; CTC channel 6 port
256+  0000              CTC_CHANNEL_7				            EQU	$1F3B	; CTC channel 7 port
257+  0000              CTCBASE                                 EQU $c0		; MSB Base address of buffer
258+  0000              CTCSIZE                                 EQU $04 	; MSB buffer length
259+  0000              CTCEND                                  EQU CTCBASE+(CTCSIZE*2)
260+  0000
261+  0000
262+  0000              DEBUG_LEDS_REGISTER						EQU 255
263+  0000
264+  0000
265+  0000              GetNextRegSaveBC:	MACRO register
266+  0000 ~                                push bc
267+  0000 ~                                ld bc,$243B
268+  0000 ~                                ld a,register
269+  0000 ~                                out (c),a
270+  0000 ~                                inc b
271+  0000 ~                                in a,(c)
272+  0000 ~                                pop bc
273+  0000                                  ENDM
274+  0000
275+  0000              GetNextReg:	MACRO register
276+  0000 ~                        ld bc,$243B
277+  0000 ~                        ld a,register
278+  0000 ~                        out (c),a
279+  0000 ~                        inc b
280+  0000 ~                        in a,(c)
281+  0000                          ENDM
282+  0000
# file closed: ../../Hardware/register_defines.asm
 56   0000                                      INCLUDE "../../Layer2Graphics/layer2_defines.asm"
# file opened: ../../Layer2Graphics/layer2_defines.asm
  1+  0000
  2+  0000
  3+  0000              LAYER2_SHIFTED_SCREEN_TOP  	 equ 0
  4+  0000              LAYER2_SHIFTED_SCREEN_MIDDLE equ $40
  5+  0000              LAYER2_SHIFTED_SCREEN_BOTTOM equ $80
  6+  0000
  7+  0000
  8+  0000              ; note hi byte is not decoded on DMA port so can out OUTIR
  9+  0000
 10+  0000              IO_SPRITE_SLOT_PORT 		 equ 12347
 11+  0000              IO_SPRITE_PATTERN_PORT       equ 91
 12+  0000              IO_SPRITE_ATTRIBUTES_PORT    equ 87
 13+  0000
 14+  0000              LAYER2_VISIBLE_MASK 		equ $02
 15+  0000              ; DEBUG 0 for always write to primary 08 for double buffering
 16+  0000                  IFDEF DOUBLEBUFFER
 17+  0000 ~            LAYER2_SHADOW_SCREEN_MASK 	equ $08
 18+  0000                  ELSE
 19+  0000              LAYER2_SHADOW_SCREEN_MASK 	equ $00
 20+  0000                  ENDIF
 21+  0000              LAYER2_READ_ENABLE_MASK 	equ %00000100
 22+  0000              LAYER2_WRITE_ENABLE_MASK 	equ %00000001
 23+  0000              LAYER2_READ_WRITE_MASK      equ %00000101
 24+  0000              LAYER2_SCREEN_SECTION_MASK 	equ $03
 25+  0000              LAYER2_SCREEN_SECTION_SHIFT equ 6
 26+  0000
 27+  0000              LAYER2_DISABLE_MEM_WRITE    equ %11111110
 28+  0000              LAYER2_DISABLE_MEM_READ     equ %11111011
 29+  0000              LAYER2_DISABLE_MEM_ACCESS   equ %11111010
 30+  0000
 31+  0000              LAYER2_SCREEN_BANK1          equ 8
 32+  0000              LAYER2_SCREEN_BANK2          equ 9
 33+  0000              LAYER2_SCREEN_BANK3          equ 10
 34+  0000              LAYER2_SCREEN_BANK4          equ 11     ; used by 320 and 640 mode
 35+  0000              LAYER2_SCREEN_BANK5          equ 12     ; used by 320 and 640 mode
 36+  0000              LAYER2_SHADOW_BANK1          equ 13
 37+  0000              LAYER2_SHADOW_BANK2          equ 14
 38+  0000              LAYER2_SHADOW_BANK3          equ 15
 39+  0000              LAYER2_SHADOW_BANK4          equ 16     ; used by 320 and 640 mode
 40+  0000              LAYER2_SHADOW_BANK5          equ 17     ; used by 320 and 640 mode
 41+  0000
 42+  0000              SCREEN_HEIGHT 				 equ 192
 43+  0000              SCREEN_RAM_BASE				 equ $0000
 44+  0000              SCREEN_HOZ_MIN_PIX		     equ 10
 45+  0000
 46+  0000              SPRITES_VISIBLE_MASK         equ $01
 47+  0000              SPRITES_ON_BORDER_MASK       equ $02
 48+  0000              LAYER_PRIORITIES_MASK        equ $07
 49+  0000              LORES_MODE_MASK              equ $80
 50+  0000              LAYER_PRIORITIES_SHIFT       equ 2
 51+  0000
 52+  0000              LAYER_PRIORITIES_S_L_U 		equ 0
 53+  0000              LAYER_PRIORITIES_L_S_U 		equ 1
 54+  0000              LAYER_PRIORITIES_S_U_L  	equ 2
 55+  0000              LAYER_PRIORITIES_L_U_S 		equ 3
 56+  0000              LAYER_PRIORITIES_U_S_L 		equ 4
 57+  0000              LAYER_PRIORITIES_U_L_S 		equ 5
 58+  0000
 59+  0000              DMA_WRO_BLOCK_PORTA_A2B_XFR  equ $7D
 60+  0000              DMA_WRO_BLOCK_PORTA_B2A_XFR  equ $79
 61+  0000              DMA_WR1_P1FIXED_MEMORY       equ $24
 62+  0000              DMA_WR1_P1DEC_MEMORY         equ $04
 63+  0000              DMA_WR1_P1INC_MEMORY         equ $14
 64+  0000              DMA_WR2_P2FIXED_MEMORY       equ $20
 65+  0000              DMA_WR2_P2DEC_MEMORY         equ $00
 66+  0000              DMA_WR2_P2INC_MEMORY         equ $10
 67+  0000              DMA_WR4_CONT_MODE            equ $AD
 68+  0000              DMA_WR4_BURST_MODE           equ $CD
 69+  0000              DMA_RESET                    equ $c3
 70+  0000              DMA_RESET_PORT_A_TIMING      equ $c7
 71+  0000              DMA_RESET_PORT_B_TIMING      equ $cb
 72+  0000              DMA_LOAD                     equ $cf
 73+  0000              DMA_CONTINUE                 equ $d3
 74+  0000              DMA_DISABLE_INTERUPTS        equ $af
 75+  0000              DMA_ENABLE_INTERUPTS         equ $ab
 76+  0000              DMA_RESET_DISABLE_INTERUPTS  equ $a3
 77+  0000              DMA_ENABLE_AFTER_RETI        equ $b7
 78+  0000              DMA_READ_STATUS_BYTE         equ $bf
 79+  0000              DMA_REINIT_STATUS_BYTE       equ $8b
 80+  0000              DMA_START_READ_SEQUENCE      equ $a7
 81+  0000              DMA_FORCE_READY              equ $b3
 82+  0000              DMA_STOP_AT_END			     equ $82
 83+  0000              DMA_DISABLE                  equ $83
 84+  0000              DMA_ENABLE                   equ $87
 85+  0000              DMA_WRITE_REGISTER_COMMAND   equ $bb
 86+  0000              DMA_BURST                    equ $cd
 87+  0000              DMA_CONTINUOUS               equ $ad
 88+  0000              ZXN_DMA_PORT                 equ $6b
 89+  0000
 90+  0000
 91+  0000              COLOUR_TRANSPARENT			 equ $E3
 92+  0000
 93+  0000
 94+  0000
 95+  0000
# file closed: ../../Layer2Graphics/layer2_defines.asm
 57   0000                                      INCLUDE	"../../Hardware/memory_bank_defines.asm"
# file opened: ../../Hardware/memory_bank_defines.asm
  1+  0000
  2+  0000              membanksize			    equ	$1FFF
  3+  0000
  4+  0000              StartOfBank     	    equ $0000
  5+  0000
  6+  0000              membank0 			    equ $0000
  7+  0000              dmaCopySrcAddr		    equ	$0000
  8+  0000              MathsTablesAddr         equ $0000
  9+  0000              membank1 			    equ $2000
 10+  0000              membank2 			    equ $4000
 11+  0000              membank3 			    equ $6000
 12+  0000              membank4 			    equ $8000
 13+  0000              membank5 			    equ $a000
 14+  0000              membank6 			    equ $c000
 15+  0000              ScreenBank              equ $c000
 16+  0000              MenuGalChtAddr          equ $c000
 17+  0000              MenuEquipSAddr          equ $c000
 18+  0000              MenuInventAddr          equ $c000
 19+  0000              MenuMarketAddr          equ $c000
 20+  0000              DispMarketAddr          equ $c000
 21+  0000              MenuShrChtAddr          equ $c000
 22+  0000              MenuStatusAddr          equ $c000
 23+  0000              MenuSystemAddr          equ $c000
 24+  0000              ViewFrontAddr           equ $c000
 25+  0000              SunBankAddr             equ $c000
 26+  0000              PlanetBankAddr          equ $c000
 27+  0000              SpaceStationBankAddr    equ $c000
 28+  0000              UniverseBankAddr	    equ $c000
 29+  0000              LaunchShipAddr          equ $c000
 30+  0000              membank7 			    equ $e000
 31+  0000              L1membankAddr   	    equ $e000
 32+  0000              L2membankAddr   	    equ $e000
 33+  0000              ShipModelsAddr	        equ $e000
 34+  0000              SpritemembankAddr       equ $e000
 35+  0000              ResetUniverseAddr       equ $e000
 36+  0000              StockTableAddr	        equ $e000
 37+  0000              CommanderAddr           equ $e000
 38+  0000              LAYER2Addr              equ $e000
 39+  0000              LAYER1Addr              equ $e000
 40+  0000              SPRITEAddr              equ $e000
 41+  0000              ConsoleImageAddr        equ $e000
 42+  0000              GalaxyDataAddr          equ $e000
 43+  0000              SoundAddr               equ $e000
 44+  0000              KeyboardAddr            equ $e000
 45+  0000              MathsBankedFnsAddr      equ $0000
 46+  0000
 47+  0000              EXSDOSMMU0              equ MMU_SLOT_0_REGISTER
 48+  0000              MathsTablesMMU          equ MMU_SLOT_0_REGISTER
 49+  0000              MathsBankedFnsMMU       equ MMU_SLOT_0_REGISTER
 50+  0000              ShipReadMMU             equ MMU_SLOT_0_REGISTER
 51+  0000              DMACpySourceMMU		    equ	MMU_SLOT_0_REGISTER
 52+  0000              EXSDOSMMU1              equ MMU_SLOT_1_REGISTER
 53+  0000              SunMMU 		            equ MMU_SLOT_6_REGISTER
 54+  0000              PlanetMMU 		        equ MMU_SLOT_6_REGISTER
 55+  0000              UniverseMMU 		    equ MMU_SLOT_6_REGISTER
 56+  0000              SpaceStationMMU         equ MMU_SLOT_6_REGISTER
 57+  0000              ScreenBankMMU           equ MMU_SLOT_6_REGISTER
 58+  0000              MenuEquipSMMU           equ MMU_SLOT_6_REGISTER
 59+  0000              MenuShrChtMMU           equ MMU_SLOT_6_REGISTER
 60+  0000              MenuGalChtMMU           equ MMU_SLOT_6_REGISTER
 61+  0000              MenuInventMMU           equ MMU_SLOT_6_REGISTER
 62+  0000              MenuSystemMMU           equ MMU_SLOT_6_REGISTER
 63+  0000              MenuMarketMMU           equ MMU_SLOT_6_REGISTER
 64+  0000              DispMarketMMU           equ MMU_SLOT_6_REGISTER
 65+  0000              MenuStatusMMU           equ MMU_SLOT_6_REGISTER
 66+  0000              LaunchShipMMU           equ MMU_SLOT_6_REGISTER
 67+  0000              L1memMMU       		    equ MMU_SLOT_7_REGISTER
 68+  0000              L2memMMU       		    equ MMU_SLOT_7_REGISTER
 69+  0000              SpritememMMU   		    equ MMU_SLOT_7_REGISTER
 70+  0000              ShipModelMMU  		    equ MMU_SLOT_7_REGISTER
 71+  0000              ResetUniverseMMU	    equ MMU_SLOT_7_REGISTER
 72+  0000              CommanderMMU	        equ MMU_SLOT_7_REGISTER
 73+  0000              StockTableMMU		    equ MMU_SLOT_7_REGISTER
 74+  0000              ConsoleImageDataMMU	    equ MMU_SLOT_7_REGISTER
 75+  0000              GalaxyDataMMU	        equ MMU_SLOT_7_REGISTER
 76+  0000              SoundMMU                equ MMU_SLOT_7_REGISTER
 77+  0000              KeyboardMMU             equ MMU_SLOT_7_REGISTER
 78+  0000
 79+  0000              ; banks 8 to 17 are reserved for layer 2 memory
 80+  0000              BankResetUniv           equ 49
 81+  0000              BankMenuShrCht          equ 50
 82+  0000              BankMenuGalCht          equ 51
 83+  0000              BankMenuInvent          equ 52
 84+  0000              BankMenuSystem          equ 53
 85+  0000              BankMenuMarket          equ 54
 86+  0000              BankStockTable          equ 55
 87+  0000              BankCommander           equ 56
 88+  0000              BankLAYER2              equ 57
 89+  0000              BankLAYER1              equ 58
 90+  0000              BankShipModels1         equ 59
 91+  0000              BankSPRITE              equ 60
 92+  0000              BankConsole             equ 61
 93+  0000              BankFrontView           equ 62
 94+  0000              BankMenuStatus          equ 63
 95+  0000              BankMenuEquipS          equ 64
 96+  0000              BankLaunchShip          equ 65
 97+  0000              BankDispMarket          equ 66
 98+  0000              BankShipModels2         equ 67
 99+  0000              BankShipModels3         equ 68
100+  0000              BankShipModels4         equ 69
101+  0000
102+  0000              BankUNIVDATA0           equ 70
103+  0000              BankSpaceStationData    equ 70
104+  0000              BankUNIVDATA1           equ 71
105+  0000              BankUNIVDATA2           equ 72
106+  0000              BankUNIVDATA3           equ 73
107+  0000              BankUNIVDATA4           equ 74
108+  0000              BankUNIVDATA5           equ 75
109+  0000              BankUNIVDATA6           equ 76
110+  0000              BankUNIVDATA7           equ 77
111+  0000              BankUNIVDATA8           equ 78
112+  0000              BankUNIVDATA9           equ 79
113+  0000              BankUNIVDATA10          equ 80
114+  0000              BankUNIVDATA11          equ 81
115+  0000              BankUNIVDATA12          equ 82
116+  0000              BankSunData             equ 83
117+  0000              BankPlanetData          equ 84
118+  0000
119+  0000              BankGalaxyData0         equ 91
120+  0000              BankGalaxyData1         equ 92
121+  0000              BankGalaxyData2         equ 93
122+  0000              BankGalaxyData3         equ 94
123+  0000              BankGalaxyData4         equ 95
124+  0000              BankGalaxyData5         equ 96
125+  0000              BankGalaxyData6         equ 97
126+  0000              BankGalaxyData7         equ 98
127+  0000
128+  0000              BankMathsTables         equ 99
129+  0000              BankSound               equ 100
130+  0000              BankKeyboard            equ 101
131+  0000              BankMathsBankedFns      equ 102
132+  0000
133+  0000              BankROM                 equ 255
134+  0000
135+  0000
# file closed: ../../Hardware/memory_bank_defines.asm
 58   0000                                      INCLUDE "../../Hardware/screen_equates.asm"
# file opened: ../../Hardware/screen_equates.asm
  1+  0000              ScreenHeight 		equ 192
  2+  0000              ScreenLastRow       equ ScreenHeight -1
  3+  0000              ScreenWidth  		equ 256
  4+  0000              ScreenLastCol       equ ScreenWidth -1
  5+  0000              ScreenHeightHalf	equ 96
  6+  0000              ScreenWidthHalf  	equ 128
  7+  0000              ScreenCenterY		equ 96
  8+  0000              ScreenCenterX       equ 128
  9+  0000              ViewHeight          equ 128
 10+  0000              ViewHeightPlus1     equ 128+1
 11+  0000              ViewLastRow       	equ ViewHeight -1
 12+  0000              ViewWidth  			equ 256
 13+  0000              ViewLastCol         equ ViewWidth -1
 14+  0000              ViewHeightHalf      equ 63
 15+  0000              ViewWidthHalf       equ 127
 16+  0000              ViewCenterY         equ 64
 17+  0000              ViewCenterX         equ 128
 18+  0000                                      DISPLAY "TODO: place odler for debugging"
 19+  0000              ShipColour			equ $FF		; place holder for debugging TODO
 20+  0000              ScreenL1Bottom      equ $5000
 21+  0000              ScreenL1BottomLen   equ 32 * 8 * 8
 22+  0000              ScreenL1AttrBtm     equ $5A00
 23+  0000              ScreenL1AttrBtmLen  equ 32 * 8
 24+  0000
# file closed: ../../Hardware/screen_equates.asm
 59   0000                                      INCLUDE "../../Macros/graphicsMacros.asm"
# file opened: ../../Macros/graphicsMacros.asm
  1+  0000              ; General Graphics macros
  2+  0000              DoubleBufferIfPossible: MACRO
  3+  0000 ~                                    IFDEF DOUBLEBUFFER
  4+  0000 ~                                        MMUSelectLayer2
  5+  0000 ~                                        call  l2_cls
  6+  0000 ~                                        call  l2_flip_buffers
  7+  0000 ~                                    ENDIF
  8+  0000                                      ENDM
  9+  0000
 10+  0000              DoubleBuffer320IfPossible: MACRO
 11+  0000 ~                                    IFDEF DOUBLEBUFFER
 12+  0000 ~                                        MMUSelectLayer2
 13+  0000 ~                                        call  l2_320_cls
 14+  0000 ~                                        call  l2_flip_buffers
 15+  0000 ~                                    ENDIF
 16+  0000                                      ENDM
 17+  0000
 18+  0000                  IFDEF L2_640_SUPPORT
 19+  0000 ~            DoubleBuffer640IfPossible: MACRO
 20+  0000 ~                                    IFDEF DOUBLEBUFFER
 21+  0000 ~                                        MMUSelectLayer2
 22+  0000 ~                                        call  l2_640_cls
 23+  0000 ~                                        call  l2_flip_buffers
 24+  0000 ~                                    ENDIF
 25+  0000 ~                                    ENDM
 26+  0000                  ENDIF
 27+  0000
 28+  0000
 29+  0000              ErrorEquStepMinusDelta: MACRO   delta_step, delta_value
 30+  0000 ~                                    ld      hl,(delta_step)
 31+  0000 ~                                    ld      de,(delta_value)
 32+  0000 ~                                    ClearCarryFlag
 33+  0000 ~                                    sbc     hl,de
 34+  0000 ~                                    ld      (error),hl
 35+  0000                                      ENDM
 36+  0000
 37+  0000              ; we could hold steps and deltas in alternate registers later
 38+  0000              ErrorPlusStep:          MACRO   delta_step
 39+  0000 ~                                    ld      hl,(error)
 40+  0000 ~                                    ld      de,(delta_step)
 41+  0000 ~                                    add     hl,de
 42+  0000 ~                                    ld      (error),hl
 43+  0000                                      ENDM
 44+  0000
 45+  0000              ErrorMinusStep:         MACRO   delta_step
 46+  0000 ~                                    ld      hl,(error)
 47+  0000 ~                                    ld      de,(delta_step)
 48+  0000 ~                                    ClearCarryFlag
 49+  0000 ~                                    sbc     hl,de
 50+  0000 ~                                    ld      (error),hl
 51+  0000                                      ENDM
 52+  0000
 53+  0000              SetExitFalse:           MACRO
 54+  0000 ~                                    xor     a
 55+  0000 ~                                    ld      (set_exit),a
 56+  0000                                      ENDM
 57+  0000
 58+  0000              ; pulls axis high byte to a, returns nz if negative, z if positive
 59+  0000              IsAxisLT0:              MACRO   axis
 60+  0000 ~                                    ld      a,(axis+1)
 61+  0000 ~                                    and     $80
 62+  0000                                      ENDM
 63+  0000
 64+  0000              ; modifies HL, loaded with register, returns z if >=0, nz if negative
 65+  0000              IsMemld16GTE0           MACRO   mem
 66+  0000 ~                                    ld      hl, (mem)
 67+  0000 ~                                    bit     7,h
 68+  0000                                      ENDM
 69+  0000
 70+  0000              IsMemNegative8JumpFalse:MACRO   mem, target
 71+  0000 ~                                    ld      a,(mem)
 72+  0000 ~                                    and     $80
 73+  0000 ~                                    jp      z, target
 74+  0000                                      ENDM
 75+  0000
 76+  0000              IsMem16GT0JumpFalse:    MACRO   mem, target
 77+  0000 ~                                    ld      hl, (mem)
 78+  0000 ~                                    bit     7,h
 79+  0000 ~                                    jp      nz, target
 80+  0000 ~                                    ld      a,h
 81+  0000 ~                                    or      l
 82+  0000 ~                                    jp      z,  target
 83+  0000                                      ENDM
 84+  0000
 85+  0000              FloorHLdivDETarget:     MACRO   target
 86+  0000 ~                                    call    l_div                   ;       .  (so we swap and call l_div) HL = DE / HL, DE = DE % HL
 87+  0000 ~                                    ld      a,d                     ;       .  get bit 7 into carry (set if negative)
 88+  0000 ~                                    sla     a                       ;
 89+  0000 ~                                    jr      nc,.FloorIsOK           ;
 90+  0000 ~            .FloorAdjust:           dec     hl                      ;       .  if remainder >= adjust by 1 for negative
 91+  0000 ~            .FloorIsOK:             ld      (target),hl             ;       .  now save the msd value
 92+  0000                                      ENDM
 93+  0000
# file closed: ../../Macros/graphicsMacros.asm
 60   0000                                      INCLUDE "../../Macros/callMacros.asm"
# file opened: ../../Macros/callMacros.asm
  1+  0000
  2+  0000              CallIfAEqNusng:         MACRO   reg,target
  3+  0000 ~                                    cp      reg
  4+  0000 ~                                    call	z,target
  5+  0000                                      ENDM
  6+  0000
  7+  0000              CallIfAGTENusng:        MACRO   reg,target
  8+  0000 ~                                    cp      reg
  9+  0000 ~                                    call	nc,target
 10+  0000                                      ENDM
 11+  0000
 12+  0000              CallIfAGTEMemusng:      MACRO   reg,target
 13+  0000 ~                                    ld      hl,reg
 14+  0000 ~                                    cp      (hl)
 15+  0000 ~                                    call	nc,target
 16+  0000                                      ENDM
 17+  0000
 18+  0000              CallIfALTMemusng:       MACRO   reg,target
 19+  0000 ~                                    ld      hl,reg
 20+  0000 ~                                    cp      (hl)
 21+  0000 ~                                    call	c,target
 22+  0000                                      ENDM
 23+  0000
 24+  0000              CallIfALTNusng:         MACRO   reg,target
 25+  0000 ~                                    cp      reg
 26+  0000 ~                                    call	c,target
 27+  0000                                      ENDM
 28+  0000
 29+  0000              CallIfMemEqMemusng:     MACRO mem, address, target
 30+  0000 ~                                    ld      a,(mem)
 31+  0000 ~                                    ld      hl,address
 32+  0000 ~                                    cp      (hl)
 33+  0000 ~                                    call    z,target
 34+  0000                                      ENDM
 35+  0000
 36+  0000              CallIfMemEqNusng:       MACRO mem, value, target
 37+  0000 ~                                    ld      a,(mem)
 38+  0000 ~                                    cp      value
 39+  0000 ~                                    call    z,target
 40+  0000                                      ENDM
 41+  0000
 42+  0000
 43+  0000              CallIfMemGTENusng:      MACRO mem, value, target
 44+  0000 ~                                    ld      a,(mem)
 45+  0000 ~                                    cp      value
 46+  0000 ~                                    call    nc,target
 47+  0000                                      ENDM
 48+  0000
 49+  0000              CallIfMemTrue:          MACRO mem, target
 50+  0000 ~                                    ld      a,(mem)
 51+  0000 ~                                    and     a
 52+  0000 ~                                    call    z, target
 53+  0000                                      ENDM
 54+  0000
 55+  0000              CallIfMemFalse:         MACRO mem, target
 56+  0000 ~                                    ld      a,(mem)
 57+  0000 ~                                    and     a
 58+  0000 ~                                    call    nz, target
 59+  0000                                      ENDM
 60+  0000
 61+  0000              CallIfMemZero:          MACRO mem, target
 62+  0000 ~                                    ld      a,(mem)
 63+  0000 ~                                    and     a
 64+  0000 ~                                    call    z, target
 65+  0000                                      ENDM
 66+  0000
 67+  0000              CallIfMemNotZero:       MACRO mem, target
 68+  0000 ~                                    ld      a,(mem)
 69+  0000 ~                                    and     a
 70+  0000 ~                                    call    nz, target
 71+  0000                                      ENDM
 72+  0000              CallIfATrue:            MACRO target
 73+  0000 ~                                    and     a
 74+  0000 ~                                    call    z, target
 75+  0000                                      ENDM
 76+  0000
 77+  0000              CallIfAFalse:           MACRO target
 78+  0000 ~                                    and     a
 79+  0000 ~                                    call    nz, target
 80+  0000                                      ENDM
 81+  0000
 82+  0000              CallIfAZero:            MACRO target
 83+  0000 ~                                    and     a
 84+  0000 ~                                    call    z, target
 85+  0000                                      ENDM
 86+  0000
 87+  0000              CallIfANotZero:         MACRO target
 88+  0000 ~                                    and     a
 89+  0000 ~                                    call    nz, target
 90+  0000                                      ENDM
# file closed: ../../Macros/callMacros.asm
 61   0000                                      INCLUDE "../../Macros/carryFlagMacros.asm"
# file opened: ../../Macros/carryFlagMacros.asm
  1+  0000
  2+  0000              SetCarryFlag:           MACRO
  3+  0000 ~                                    scf
  4+  0000                                      ENDM
  5+  0000
  6+  0000              ClearCarryFlag:	        MACRO
  7+  0000 ~                                    or a
  8+  0000                                      ENDM
  9+  0000
 10+  0000              FlipCarryFlag:          MACRO
 11+  0000 ~                                    ccf
 12+  0000                                      ENDM
 13+  0000
# file closed: ../../Macros/carryFlagMacros.asm
 62   0000                                      INCLUDE "../../Macros/CopyByteMacros.asm"
# file opened: ../../Macros/CopyByteMacros.asm
  1+  0000              CopyByteAtHLixToA:		MACRO memloc
  2+  0000 ~            						ex          de,hl                               ; save hl
  3+  0000 ~            						ld          hl,memloc
  4+  0000 ~            						add         hl,a
  5+  0000 ~            						ld          a,(hl)                              ; get XX2[x]
  6+  0000 ~            						ex          de,hl                               ; get hl back as we need it in loop
  7+  0000              						ENDM
  8+  0000
  9+  0000              ; Increments IYL
 10+  0000              ; Increments IHL
 11+  0000              ; Gets value at hl and loads into Parameter 1 address
 12+  0000
 13+  0000              CopyByteAtNextHLiyl: 	MACRO memloc
 14+  0000 ~            						inc         iyl                                 ;
 15+  0000 ~            						inc         hl                                  ; vertex byte#1
 16+  0000 ~            						ld          a,(hl)                              ;
 17+  0000 ~            						ld          (memloc),a                     ; XX15+2 = (V),Y
 18+  0000              						ENDM
 19+  0000
 20+  0000              ;------------------------------------------------------------------------------------------------------------------------------
 21+  0000              CopyByteAtNextHL:   MACRO targetaddr
 22+  0000 ~                                inc         hl                                  ; vertex byte#1
 23+  0000 ~                                ld          a,(hl)                              ;
 24+  0000 ~                                ld          (targetaddr),a                     ; SunXX15+2 = (V),Y
 25+  0000                                  ENDM
# file closed: ../../Macros/CopyByteMacros.asm
 63   0000                                      INCLUDE "../../Macros/ldCopyMacros.asm"
# file opened: ../../Macros/ldCopyMacros.asm
  1+  0000              ZeroA:		            MACRO
  2+  0000 ~                                    xor a
  3+  0000                                      ENDM
  4+  0000
  5+  0000              SetATrue:               MACRO
  6+  0000 ~                                    xor     a
  7+  0000                                      ENDM
  8+  0000
  9+  0000              SetAFalse:              MACRO
 10+  0000 ~                                    ld      a,$FF
 11+  0000                                      ENDM
 12+  0000
 13+  0000              SetMemFalse             MACRO   mem
 14+  0000 ~                                    ld      a,$FF
 15+  0000 ~                                    ld      (mem),a
 16+  0000                                      ENDM
 17+  0000
 18+  0000              SetMemTrue              MACRO   mem
 19+  0000 ~                                    xor     a
 20+  0000 ~                                    ld      (mem),a
 21+  0000                                      ENDM
 22+  0000
 23+  0000              SetMemZero:             MACRO   mem
 24+  0000 ~                                    xor     a
 25+  0000 ~                                    ld      (mem),a
 26+  0000                                      ENDM
 27+  0000
 28+  0000              SetMemToN:              MACRO   mem,value
 29+  0000 ~                                    ld      a,value
 30+  0000 ~                                    ld      (mem),a
 31+  0000                                      ENDM
 32+  0000
 33+  0000              ldCopyStringLen:        MACRO   source, target, strlen
 34+  0000 ~                                    ld      hl,source
 35+  0000 ~                                    ld      de, target
 36+  0000 ~                                    ld      bc, strlen
 37+  0000 ~                                    ldir
 38+  0000                                      ENDM
 39+  0000
 40+  0000              ldCopyTextAtHLtoDE:     MACRO
 41+  0000 ~            .CopyLoop:              ld      a,(hl)
 42+  0000 ~                                    ld      (de),a
 43+  0000 ~                                    cp      0
 44+  0000 ~                                    jp      z,.DoneCopy
 45+  0000 ~                                    inc     hl
 46+  0000 ~                                    inc     de
 47+  0000 ~                                    jr      .CopyLoop
 48+  0000 ~            .DoneCopy:
 49+  0000                                      ENDM
 50+  0000
 51+  0000              ldClearTextLoop:        MACRO   TextSize
 52+  0000 ~                                    ld      b,a
 53+  0000 ~                                    ld      a,TextSize
 54+  0000 ~            .ClearLoop:             ld      (hl),a
 55+  0000 ~                                    inc     hl
 56+  0000 ~                                    djnz    .ClearLoop
 57+  0000                                      ENDM
 58+  0000
 59+  0000              ldCopyByte:             MACRO memfrom, memto
 60+  0000 ~                                    ld       a,(memfrom)
 61+  0000 ~                                    ld       (memto),a
 62+  0000                                      ENDM
 63+  0000
 64+  0000
 65+  0000              ldCopyByteABS:          MACRO memfrom, memto
 66+  0000 ~                                    ld       a,(memfrom)
 67+  0000 ~                                    and		$7F
 68+  0000 ~                                    ld       (memto),a
 69+  0000                                      ENDM
 70+  0000
 71+  0000              ldAtHLtoMem:            MACRO   memto
 72+  0000 ~                                    ld      a,(hl)
 73+  0000 ~                                    ld      (memto),a
 74+  0000                                      ENDM
 75+  0000
 76+  0000              ldCopyWord:             MACRO memfrom, memto
 77+  0000 ~                                    ldCopy2Byte memfrom, memto
 78+  0000                                      ENDM
 79+  0000
 80+  0000              ldCopy2Byte:            MACRO  memfrom, memto
 81+  0000 ~                                    ld       hl,(memfrom)
 82+  0000 ~                                    ld       (memto),hl
 83+  0000                                      ENDM
 84+  0000
 85+  0000              ldWriteConst            MACRO  memfrom, memto
 86+  0000 ~                                    ld       a,memfrom
 87+  0000 ~                                    ld       (memto),a
 88+  0000                                      ENDM
 89+  0000
 90+  0000              ldWriteZero             MACRO  memto
 91+  0000 ~                                    xor      a
 92+  0000 ~                                    ld       (memto),a
 93+  0000                                      ENDM
 94+  0000
 95+  0000              ldIXLaFromN:	        MACRO memfrom
 96+  0000 ~                                    ld		a,(memfrom)
 97+  0000 ~                                    ld		ixl,a
 98+  0000                                      ENDM
 99+  0000
100+  0000              ldIXHaFromN:	        MACRO memfrom
101+  0000 ~                                    ld		a,(memfrom)
102+  0000 ~                                    ld		ixh,a
103+  0000                                      ENDM
104+  0000
105+  0000              ldIYLaFromN:	        MACRO memfrom
106+  0000 ~                                    ld		a,(memfrom)
107+  0000 ~                                    ld		iyl,a
108+  0000                                      ENDM
109+  0000
110+  0000              ldIYHaFromN:	        MACRO memfrom
111+  0000 ~                                    ld		a,(memfrom)
112+  0000 ~                                    ld		iyh,a
113+  0000                                      ENDM
114+  0000
115+  0000              ; Read a 32 bit value from address HL into BCDE
116+  0000              ldBCDEatHL:             MACRO
117+  0000 ~                                    ld      e,(hl)
118+  0000 ~                                    inc     hl
119+  0000 ~                                    ld      d,(hl)
120+  0000 ~                                    inc     hl
121+  0000 ~                                    ld      c,(hl)
122+  0000 ~                                    inc     hl
123+  0000 ~                                    ld      b,(hl)
124+  0000 ~                                    inc     hl
125+  0000                                      ENDM
126+  0000
127+  0000              ldBCatHL:               MACRO
128+  0000 ~                                    ld      c,(hl)
129+  0000 ~                                    inc     hl
130+  0000 ~                                    ld      b,(hl)
131+  0000 ~                                    inc     hl
132+  0000                                      ENDM
133+  0000
134+  0000              ldhlde:			        MACRO
135+  0000 ~                                    ld		h,d
136+  0000 ~                                    ld		l,e
137+  0000                                      ENDM
138+  0000
139+  0000              ldhlbc:			        MACRO
140+  0000 ~                                    ld		h,b
141+  0000 ~                                    ld		l,c
142+  0000                                      ENDM
143+  0000
144+  0000              ldbcde:			        MACRO
145+  0000 ~                                    ld		b,d
146+  0000 ~                                    ld		c,e
147+  0000                                      ENDM
148+  0000
149+  0000              lddebc:			        MACRO
150+  0000 ~                                    ld		d,b
151+  0000 ~                                    ld		e,c
152+  0000                                      ENDM
153+  0000
154+  0000              ldbchl:			        MACRO
155+  0000 ~                                    ld		b,h
156+  0000 ~                                    ld		c,l
157+  0000                                      ENDM
158+  0000
159+  0000              lddeiy:			        MACRO
160+  0000 ~                                    ld		d,iyh
161+  0000 ~                                    ld		e,iyl
162+  0000                                      ENDM
163+  0000
164+  0000              ldiyde:			        MACRO
165+  0000 ~                                    ld		iyh,d
166+  0000 ~                                    ld		iyl,e
167+  0000                                      ENDM
168+  0000
169+  0000
170+  0000              FourLDIInstrunctions:   MACRO
171+  0000 ~                                    ldi
172+  0000 ~                                    ldi
173+  0000 ~                                    ldi
174+  0000 ~                                    ldi
175+  0000                                      ENDM
176+  0000
177+  0000              FiveLDIInstrunctions:   MACRO
178+  0000 ~                                    ldi
179+  0000 ~                                    ldi
180+  0000 ~                                    ldi
181+  0000 ~                                    ldi
182+  0000 ~                                    ldi
183+  0000                                      ENDM
184+  0000
185+  0000              SixLDIInstrunctions:    MACRO
186+  0000 ~                                    ldi
187+  0000 ~                                    ldi
188+  0000 ~                                    ldi
189+  0000 ~                                    ldi
190+  0000 ~                                    ldi
191+  0000 ~                                    ldi
192+  0000                                      ENDM
193+  0000
194+  0000              EightLDIInstrunctions:  MACRO
195+  0000 ~            		                ldi
196+  0000 ~            		                ldi
197+  0000 ~            		                ldi
198+  0000 ~            		                ldi
199+  0000 ~            		                ldi
200+  0000 ~            		                ldi
201+  0000 ~            		                ldi
202+  0000 ~            		                ldi
203+  0000                                      ENDM
204+  0000
205+  0000              NineLDIInstrunctions:  MACRO
206+  0000 ~            		                ldi
207+  0000 ~            		                ldi
208+  0000 ~            		                ldi
209+  0000 ~            		                ldi
210+  0000 ~            		                ldi
211+  0000 ~            		                ldi
212+  0000 ~            		                ldi
213+  0000 ~            		                ldi
214+  0000 ~            		                ldi
215+  0000                                      ENDM
# file closed: ../../Macros/ldCopyMacros.asm
 64   0000                                      INCLUDE "../../Macros/ldIndexedMacros.asm"
# file opened: ../../Macros/ldIndexedMacros.asm
  1+  0000              GetByteAInTable:    MACRO table
  2+  0000 ~                                ld          hl,table
  3+  0000 ~                                add         hl,a
  4+  0000 ~                                ld          a,(hl)
  5+  0000                                  ENDM
  6+  0000
  7+  0000              HLWordAInTable:     MACRO table
  8+  0000 ~                                ld          hl,table
  9+  0000 ~                                sla         a
 10+  0000 ~                                add         hl,a
 11+  0000 ~                                ld          a,(hl)
 12+  0000 ~                                inc         hl
 13+  0000 ~                                ld          h,(hl)
 14+  0000 ~                                ld          l,a
 15+  0000                                  ENDM
 16+  0000
 17+  0000
 18+  0000              ldAToHLixl:			MACRO value
 19+  0000 ~            					ld          hl,value
 20+  0000 ~            					ex          af,af'
 21+  0000 ~            					ld          a,ixl
 22+  0000 ~            					add         hl,a
 23+  0000 ~            					ex          af,af'
 24+  0000 ~            					ld          (hl),a
 25+  0000              					ENDM
 26+  0000
 27+  0000              ldAToHLiyl:			MACRO value
 28+  0000 ~            					ld          hl,value
 29+  0000 ~            					ex          af,af'
 30+  0000 ~            					ld          a,iyl
 31+  0000 ~            					add         hl,a
 32+  0000 ~            					ex          af,af'
 33+  0000 ~            					ld          (hl),a
 34+  0000              					ENDM
 35+  0000
 36+  0000
 37+  0000              ldHLixlToA:         MACRO value
 38+  0000 ~                                ld          hl,value
 39+  0000 ~                                ex          af,af'
 40+  0000 ~                                ld          a,ixl
 41+  0000 ~                                add         hl,a
 42+  0000 ~                                ld          a,(hl)
 43+  0000                                  ENDM
 44+  0000
 45+  0000              ldHLiylToA:         MACRO value
 46+  0000 ~                                ld          hl,value
 47+  0000 ~                                ex          af,af'
 48+  0000 ~                                ld          a,iyl
 49+  0000 ~                                add         hl,a
 50+  0000 ~                                ld          a,(hl)
 51+  0000                                  ENDM
 52+  0000
 53+  0000              ldHLIdxAToA:        MACRO value
 54+  0000 ~                                ld          hl,value
 55+  0000 ~                                add         hl,a
 56+  0000 ~                                ld          a,(hl)
 57+  0000                                  ENDM
 58+  0000
 59+  0000              HLEquAddrAtHLPlusA: MACRO
 60+  0000 ~                                sla         a
 61+  0000 ~                                add         hl,a
 62+  0000 ~                                ld          a,(hl)
 63+  0000 ~                                inc         hl
 64+  0000 ~                                ld          h,(hl)
 65+  0000 ~                                ld          l,a
 66+  0000                                  ENDM
 67+  0000
 68+  0000              ;-- Performs HL = |HL| - 1
 69+  0000              DecHLABS:           MACRO
 70+  0000 ~                                bit         7,h
 71+  0000 ~                                jp          nz,.NegativeDec
 72+  0000 ~            .IsHLZero:          ld          a,h                 ; if its zero it becomes negative
 73+  0000 ~                                or          l
 74+  0000 ~                                jp          z,.HLZero
 75+  0000 ~            .PositiveDec:       dec         hl
 76+  0000 ~                                jp          .Done
 77+  0000 ~            .NegativeDec:       ld          a,h
 78+  0000 ~                                and         $7F
 79+  0000 ~                                ld          h,a
 80+  0000 ~                                dec         hl
 81+  0000 ~                                set         7,h
 82+  0000 ~                                jp          .Done
 83+  0000 ~            .HLZero:            ld          hl,$8001
 84+  0000 ~            .Done:
 85+  0000                                  ENDM
 86+  0000
 87+  0000              ;-- Performs HL = HL - 1
 88+  0000              DecHLSigned:        MACRO
 89+  0000 ~                                bit         7,h
 90+  0000 ~                                jp          nz,.NegativeDec
 91+  0000 ~            .IsHLZero:          ld          a,h                 ; if its zero it becomes negative
 92+  0000 ~                                or          l
 93+  0000 ~                                jp          z,.HLZero
 94+  0000 ~            .PositiveDec:       dec         hl
 95+  0000 ~                                jp          .Done
 96+  0000 ~            .NegativeDec:       ld          a,h
 97+  0000 ~                                and         $7F
 98+  0000 ~                                ld          h,a
 99+  0000 ~                                inc         hl                  ; if its already negative then add 1 to make it further
100+  0000 ~                                set         7,h
101+  0000 ~                                jp          .Done
102+  0000 ~            .HLZero:            ld          hl,$8001
103+  0000 ~            .Done:
104+  0000                                  ENDM
105+  0000
# file closed: ../../Macros/ldIndexedMacros.asm
 65   0000                                      INCLUDE "../../Macros/jumpMacros.asm"
# file opened: ../../Macros/jumpMacros.asm
  1+  0000              JumpIfHLNegative:       MACRO target
  2+  0000 ~                                    bit     7,h
  3+  0000 ~                                    jp      nz,target
  4+  0000                                      ENDM
  5+  0000
  6+  0000              JumpIfPositive:	        MACRO target
  7+  0000 ~                                    jp		p, target
  8+  0000                                      ENDM
  9+  0000
 10+  0000              JumpIfNegative:	        MACRO target
 11+  0000 ~                                    jp		m, target
 12+  0000                                      ENDM
 13+  0000
 14+  0000
 15+  0000              JumpIfUnderflow:	    MACRO target
 16+  0000 ~                                    jp		po, target
 17+  0000                                      ENDM
 18+  0000
 19+  0000              JumpIfOverflow:	        MACRO target
 20+  0000 ~                                    jp		po, target
 21+  0000                                      ENDM
 22+  0000
 23+  0000
 24+  0000              JumpIfNotZero:	        MACRO target
 25+  0000 ~                                    jp	nz,target
 26+  0000                                      ENDM
 27+  0000
 28+  0000              JumpIfZero:	            MACRO target
 29+  0000 ~                                    jp	z,target
 30+  0000                                      ENDM
 31+  0000
 32+  0000              ;.. Bit routines
 33+  0000              JumpOnLeadSignSet:      MACRO   reg, target
 34+  0000 ~                                    ld      a,reg
 35+  0000 ~                                    and     SignOnly8Bit
 36+  0000 ~                                    jp      nz,target
 37+  0000                                      ENDM
 38+  0000
 39+  0000              JumpOnLeadSignClear:    MACRO   reg, target
 40+  0000 ~                                    ld      a,reg
 41+  0000 ~                                    and     SignOnly8Bit
 42+  0000 ~                                    jp      z,target
 43+  0000                                      ENDM
 44+  0000
 45+  0000              JumpOnLeadSignSetA:     MACRO   target
 46+  0000 ~                                    and     SignOnly8Bit
 47+  0000 ~                                    jp      nz,target
 48+  0000                                      ENDM
 49+  0000
 50+  0000              JumpOnLeadSignClearA:   MACRO   target
 51+  0000 ~                                    and     SignOnly8Bit
 52+  0000 ~                                    jp      z,target
 53+  0000                                      ENDM
 54+  0000
 55+  0000              JumpOnMemBitSet:        MACRO mem, bitnbr, target
 56+  0000 ~                                    ld      a,(mem)
 57+  0000 ~                                    bit 	bitnbr,a
 58+  0000 ~                                    jp      nz,target
 59+  0000                                      ENDM
 60+  0000
 61+  0000              JumpOnMemBitClear:      MACRO mem, bitnbr, target
 62+  0000 ~                                    ld      a,(mem)
 63+  0000 ~                                    bit 	bitnbr,a
 64+  0000 ~                                    jp      z,target
 65+  0000                                      ENDM
 66+  0000
 67+  0000
 68+  0000              JumpOnABitSet:          MACRO   bitnbr, target
 69+  0000 ~                                    bit 	bitnbr, a
 70+  0000 ~                                    jp      nz,target
 71+  0000                                      ENDM
 72+  0000
 73+  0000              JumpOnABitClear:        MACRO   bitnbr, target
 74+  0000 ~                                    bit 	bitnbr, a
 75+  0000 ~                                    jp      z,target
 76+  0000                                      ENDM
 77+  0000
 78+  0000              JumpOnABit5Set:         MACRO   target
 79+  0000 ~                                    and     Bit5Only
 80+  0000 ~                                    jp      nz,target
 81+  0000                                      ENDM
 82+  0000
 83+  0000              JumpOnABit5Clear:       MACRO   target
 84+  0000 ~                                    and     Bit5Only
 85+  0000 ~                                    jp      z,target
 86+  0000                                      ENDM
 87+  0000
 88+  0000              JumpOnBitMaskSet:       MACRO   bitmask, target
 89+  0000 ~                                    and     bitmask
 90+  0000 ~                                    jp      nz,target
 91+  0000                                      ENDM
 92+  0000
 93+  0000              JumpOnBitMaskClear:     MACRO   bitmask, target
 94+  0000 ~                                    and     bitmask
 95+  0000 ~                                    jp      z,target
 96+  0000                                      ENDM
 97+  0000
 98+  0000              JumpOnMemBitMaskSet:    MACRO   mem, bitmask, target
 99+  0000 ~                                    ld      a,(mem)
100+  0000 ~                                    and     bitmask
101+  0000 ~                                    jp      nz,target
102+  0000                                      ENDM
103+  0000
104+  0000              JumpOnMemBitMaskClear:  MACRO   mem, bitmask, target
105+  0000 ~                                    ld      a,(mem)
106+  0000 ~                                    and     bitmask
107+  0000 ~                                    jp      z,target
108+  0000                                      ENDM
109+  0000
110+  0000              JumpOnBitSet:           MACRO  reg, bitnbr, target
111+  0000 ~                                    bit 	bitnbr,reg
112+  0000 ~                                    jp      nz,target
113+  0000                                      ENDM
114+  0000
115+  0000              JumpOnBitClear:         MACRO  reg, bitnbr, target
116+  0000 ~                                    bit 	bitnbr,reg
117+  0000 ~                                    jp      z,target
118+  0000                                      ENDM
119+  0000
120+  0000              ; Comparison Routines
121+  0000              JumpIfAGTEusng:         MACRO
122+  0000 ~                                    jp		nc,target
123+  0000                                      ENDM
124+  0000
125+  0000              JumpIfAGTENusng:        MACRO reg,target
126+  0000 ~                                    cp     reg
127+  0000 ~                                    jp		nc,target
128+  0000                                      ENDM
129+  0000
130+  0000              JumpIfAGTEMemusng:      MACRO mem,target
131+  0000 ~                                    ld      hl,mem
132+  0000 ~                                    cp      (hl)
133+  0000 ~                                    jp		nc,target
134+  0000                                      ENDM
135+  0000              JumpIfMemGTENusng:      MACRO mem, value, target
136+  0000 ~                                    ld     a,(mem)
137+  0000 ~                                    cp     value
138+  0000 ~                                    jp	  nc,target
139+  0000                                      ENDM
140+  0000
141+  0000              JumpIfMemGTEMemusng:    MACRO mem, address, target
142+  0000 ~                                    ld   a,(mem)
143+  0000 ~                                    ld   hl,address
144+  0000 ~                                    cp   (hl)
145+  0000 ~                                    jp	  nc,target
146+  0000                                      ENDM
147+  0000
148+  0000              JumpIfMemEqMemusng:     MACRO mem, address, target
149+  0000 ~                                    ld   a,(mem)
150+  0000 ~                                    ld   hl,address
151+  0000 ~                                    cp   (hl)
152+  0000 ~                                    jp	  z,target
153+  0000                                      ENDM
154+  0000
155+  0000              JumpIfMemNeMemusng:     MACRO mem, address, target
156+  0000 ~                                    ld   a,(mem)
157+  0000 ~                                    ld   hl,address
158+  0000 ~                                    cp   (hl)
159+  0000 ~                                    jp	  nz,target
160+  0000                                      ENDM
161+  0000
162+  0000              JumpIfMemTrue:          MACRO mem, target
163+  0000 ~                                    ld      a,(mem)
164+  0000 ~                                    and     a
165+  0000 ~                                    jp      z, target
166+  0000                                      ENDM
167+  0000
168+  0000              JumpIfMemFalse:         MACRO mem, target
169+  0000 ~                                    ld      a,(mem)
170+  0000 ~                                    and     a
171+  0000 ~                                    jp      nz, target
172+  0000                                      ENDM
173+  0000
174+  0000              JumpIfATrue:            MACRO target
175+  0000 ~                                    and     a
176+  0000 ~                                    jp      z, target
177+  0000                                      ENDM
178+  0000
179+  0000              JumpIfAFalse:           MACRO target
180+  0000 ~                                    and     a
181+  0000 ~                                    jp      nz, target
182+  0000                                      ENDM
183+  0000
184+  0000              JumpIfANotFalse:        MACRO target
185+  0000 ~                                    cp      $FF
186+  0000 ~                                    jp      nz, target
187+  0000                                      ENDM
188+  0000
189+  0000              ;-- Less than Macros -------------------------------------------
190+  0000              JumpIfALTMemHLusng:     MACRO target
191+  0000 ~                                    cp    (hl)
192+  0000 ~                                    jp	  c,target
193+  0000                                      ENDM
194+  0000
195+  0000              JumpIfRegLTE:           MACRO   reg, value, target
196+  0000 ~                                    ld      a,reg
197+  0000 ~                                    cp      value
198+  0000 ~                                    jp	    z,target
199+  0000 ~                                    jp		c, target
200+  0000                                      ENDM
201+  0000
202+  0000              JumpIfALTMemusng:       MACRO mem,target
203+  0000 ~                                    ld      hl,mem
204+  0000 ~                                    cp      (hl)
205+  0000 ~                                    jp		c,target
206+  0000                                      ENDM
207+  0000
208+  0000
209+  0000              JumpIfALTusng:          MACRO target
210+  0000 ~                                    jp		c,target
211+  0000                                      ENDM
212+  0000
213+  0000              JumpIfALTNusng:         MACRO value, target
214+  0000 ~                                    cp      value
215+  0000 ~                                    jp		c, target
216+  0000                                      ENDM
217+  0000
218+  0000              JumpIfALTNsigned:       MACRO   value, target
219+  0000 ~                                    cp      value
220+  0000 ~                                    jp      m,.SignSet
221+  0000 ~            .SignClear:             jp      pe,target       ; Sign (0), P/V (1)
222+  0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (0)
223+  0000 ~            .SignSet:               jp      po,target
224+  0000 ~            .CheckComplete:
225+  0000                                      ENDM
226+  0000
227+  0000              JumpIfMemLTNusng:       MACRO mem, value, target
228+  0000 ~                                    ld      a,(mem)
229+  0000 ~                                    cp      value
230+  0000 ~                                    jp	  c,target
231+  0000                                      ENDM
232+  0000
233+  0000              JumpIfMemLTMemusng:     MACRO mem, value, target
234+  0000 ~                                    ld    a,(mem)
235+  0000 ~                                    ld    hl,value
236+  0000 ~                                    cp    (hl)
237+  0000 ~                                    jp	  c,target
238+  0000                                      ENDM
239+  0000              ;-- ------------------------------------------------------------
240+  0000              JumpIfAGTENsigned       MACRO   value, target
241+  0000 ~                                    cp      value
242+  0000 ~                                    jp      m,.SignSet
243+  0000 ~            .SignClear:             jp      po,target       ; Sign (0), P/V (0)
244+  0000 ~                                    jp      .CheckComplete  ; Sign (1), P/V (1)
245+  0000 ~            .SignSet:               jp      pe,target
246+  0000 ~            .CheckComplete:
247+  0000                                      ENDM
248+  0000
249+  0000              JumpIfMemEqNusng:       MACRO mem,value,target
250+  0000 ~                                    ld  a,(mem)
251+  0000 ~                                    cp  value
252+  0000 ~                                    jp  z,target
253+  0000                                      ENDM
254+  0000
255+  0000              JumpIfMemNeNusng:       MACRO mem,value,target
256+  0000 ~                                    ld  a,(mem)
257+  0000 ~                                    cp  value
258+  0000 ~                                    jp  nz,target
259+  0000                                      ENDM
260+  0000
261+  0000              JumpIfMemZero:          MACRO mem,target
262+  0000 ~                                    ld  a,(mem)
263+  0000 ~                                    and a
264+  0000 ~                                    jp  z,target
265+  0000                                      ENDM
266+  0000
267+  0000              JumpIfMemNotZero:       MACRO mem,target
268+  0000 ~                                    ld  a,(mem)
269+  0000 ~                                    and a
270+  0000 ~                                    jp  nz,target
271+  0000                                      ENDM
272+  0000
273+  0000              JumpIfANENusng:         MACRO value, target
274+  0000 ~                                    cp     value
275+  0000 ~                                    jp      nz,target
276+  0000                                      ENDM
277+  0000
278+  0000              JumpIfANEquNusng:       MACRO value, target
279+  0000 ~                                    cp     value
280+  0000 ~                                    jp     z,target
281+  0000                                      ENDM
282+  0000
283+  0000              JumpIfANEMemusng:       MACRO  value, target
284+  0000 ~                                    ld    hl,value
285+  0000 ~                                    cp    (hl)
286+  0000 ~                                    jp      nz,target
287+  0000                                      ENDM
288+  0000
289+  0000              JumpIfAEqNusng:         MACRO value, target
290+  0000 ~                                    cp     value
291+  0000 ~                                    jp      z,target
292+  0000                                      ENDM
293+  0000
294+  0000              JumpIfAIsZero:	        MACRO target
295+  0000 ~                                    and     a   ; cp 0 - changed to and a for optimisation but affects other flags
296+  0000 ~                                    jp	    z, target
297+  0000                                      ENDM
298+  0000
299+  0000              JumpIfRegIsNotZero:     MACRO   reg, target
300+  0000 ~                                    ld      a,reg
301+  0000 ~                                    and     a
302+  0000 ~                                    jp	    nz,target
303+  0000                                      ENDM
304+  0000
305+  0000
306+  0000              JumpIfAIsNotZero:       MACRO target
307+  0000 ~                                    and     a
308+  0000 ~                                    jp	    nz,target
309+  0000                                      ENDM
310+  0000
311+  0000              JumpIfMemIsNotZero:     MACRO value, target
312+  0000 ~                                    ld      a,(value)
313+  0000 ~                                    and     a
314+  0000 ~                                    jp	    nz,target
315+  0000                                      ENDM
316+  0000              IfResultZeroGoto:	    MACRO target
317+  0000 ~                                    jp	z,target
318+  0000                                      ENDM
319+  0000
320+  0000              IfResultNotZeroGoto:    MACRO target
321+  0000 ~                                    jp	nz,target
322+  0000                                      ENDM
323+  0000
# file closed: ../../Macros/jumpMacros.asm
 66   0000                                      INCLUDE "../../Macros/MathsMacros.asm"
# file opened: ../../Macros/MathsMacros.asm
  1+  0000              ; sets z flag is HL less than 255 else sets it to nz (note opposite of GT127)
  2+  0000              IsHLGT255:              MACRO
  3+  0000 ~                                    bit     7,h
  4+  0000 ~                                    ret     z
  5+  0000 ~                                    ld      a,h
  6+  0000 ~                                    and     a
  7+  0000                                      ENDM
  8+  0000
  9+  0000              ; Sets z flat if HL = 255 else sets it to nz
 10+  0000              IsHLEqu255:             MACRO
 11+  0000 ~                                    ld      a,h
 12+  0000 ~                                    and     a               ; if its non zero then it can't be 255
 13+  0000 ~                                    ret     nz
 14+  0000 ~                                    ld      a,l
 15+  0000 ~                                    inc     a               ; if it was 255 the inc will set it to zero
 16+  0000                                      ENDM
 17+  0000
 18+  0000              ; Sets Z flag if GT 127 else nz
 19+  0000              IsHLGT127:              MACRO
 20+  0000 ~                                    bit     7,h             ; -ve?
 21+  0000 ~                                    jr      nz,.DoneCheck
 22+  0000 ~                                    ld      a,h             ; +ve > 256?
 23+  0000 ~                                    and     a
 24+  0000 ~                                    jr      nz,.DoneCheck
 25+  0000 ~                                    ld      a,l
 26+  0000 ~                                    and     $80             ; this will set z to false if bit 7 set and clear lower bits
 27+  0000 ~                                    cp      $80             ; this will set z to true if bit 7 set
 28+  0000 ~            .DoneCheck:
 29+  0000                                      ENDM
 30+  0000
 31+  0000              ReturnIfHLGT127:        MACRO
 32+  0000 ~                                    bit     7,h             ; -ve?
 33+  0000 ~                                    jr      nz,.DoneCheck   ; forces check complete
 34+  0000 ~                                    ld      a,h             ; +ve > 256?
 35+  0000 ~                                    and     a               ;
 36+  0000 ~                                    ret     nz              ; forces a return
 37+  0000 ~                                    bit     7,l             ; bit 7 of lower set?
 38+  0000 ~                                    ret     nz              ; forces a return
 39+  0000 ~            .DoneCheck:
 40+  0000                                      ENDM
 41+  0000
 42+  0000              IsDEGT127:              MACRO
 43+  0000 ~                                    bit     7,d
 44+  0000 ~                                    jr      nz,.DoneCheck
 45+  0000 ~                                    ld      a,d
 46+  0000 ~                                    jr      nz,.DoneCheck
 47+  0000 ~                                    ld      a,e
 48+  0000 ~                                    and     $80
 49+  0000 ~            .DoneCheck:
 50+  0000                                      ENDM
 51+  0000
 52+  0000              ABSa2c:                 MACRO
 53+  0000 ~                                    bit     7,a
 54+  0000 ~                                    jp      z,.DoneABSa
 55+  0000 ~                                    neg
 56+  0000 ~            .DoneABSa:
 57+  0000                                      ENDM
 58+  0000
 59+  0000              DEEquSquareA:           MACRO
 60+  0000 ~                                    ld  d,a
 61+  0000 ~                                    ld  e,a
 62+  0000 ~                                    mul de
 63+  0000                                      ENDM
 64+  0000
 65+  0000              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
 66+  0000 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
 67+  0000 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
 68+  0000 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
 69+  0000 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
 70+  0000 ~                                    xor $80                             ;
 71+  0000 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
 72+  0000 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
 73+  0000 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
 74+  0000 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
 75+  0000 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
 76+  0000 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
 77+  0000                                      ENDM
 78+  0000
 79+  0000              SignedHLTo2C:           MACRO
 80+  0000 ~                                    bit     7,h
 81+  0000 ~                                    jr      z,.Done2c
 82+  0000 ~                                    ld      a,h
 83+  0000 ~                                    and     SignMask8Bit
 84+  0000 ~                                    ld      h,a
 85+  0000 ~                                    NegHL
 86+  0000 ~            .Done2c:
 87+  0000                                      ENDM
 88+  0000
 89+  0000              MemSignedTo2C:          MACRO   memfrom
 90+  0000 ~                                    ld      hl,(memfrom)
 91+  0000 ~                                    bit     7,h
 92+  0000 ~                                    jr      z,.Done2c
 93+  0000 ~                                    ld      a,h
 94+  0000 ~                                    and     SignMask8Bit
 95+  0000 ~                                    ld      h,a
 96+  0000 ~            .Done2c:                ld      (memfrom),hl
 97+  0000                                      ENDM
 98+  0000
 99+  0000
100+  0000                  ;returns result in H
101+  0000              EDiv10Inline:           MACRO
102+  0000 ~                                    ld      d,0
103+  0000 ~                                    ld      hl,de
104+  0000 ~                                    add     hl,hl
105+  0000 ~                                    add     hl,de
106+  0000 ~                                    add     hl,hl
107+  0000 ~                                    add     hl,hl
108+  0000 ~                                    add     hl,de
109+  0000 ~                                    add     hl,hl
110+  0000                                      ENDM
111+  0000
112+  0000              cpHLDE:                 MACRO
113+  0000 ~                                    push    hl
114+  0000 ~                                    and     a
115+  0000 ~                                    sbc     hl,de
116+  0000 ~                                    pop     hl
117+  0000                                      ENDM
118+  0000
119+  0000              cpABSDEHL:              MACRO
120+  0000 ~                                    push     hl,,de
121+  0000 ~                                    ld      a,h
122+  0000 ~                                    and     $7F
123+  0000 ~                                    ld      h,a
124+  0000 ~                                    ld      a,d
125+  0000 ~                                    and     $7F
126+  0000 ~                                    ld      d,a
127+  0000 ~                                    ex      de,hl
128+  0000 ~                                    sbc     hl,de
129+  0000 ~                                    pop     hl,,de
130+  0000                                      ENDM
131+  0000
132+  0000              ; Simple are they both the same setting z if they are
133+  0000              ; tehcicall this works but it measn the final ret z is alwys done
134+  0000              ; so jp needs to be to a target
135+  0000              cpHLEquDE:              MACRO   passedCheck
136+  0000 ~                                    ld      a,h
137+  0000 ~                                    cp      d
138+  0000 ~                                    jp      nz, passedCheck
139+  0000 ~                                    ld      a,l
140+  0000 ~                                    cp      e
141+  0000 ~            .NoTheSame:
142+  0000                                      ENDM
143+  0000
144+  0000              cpHLEquBC:              MACRO   passedCheck
145+  0000 ~                                    ld      a,h
146+  0000 ~                                    cp      b
147+  0000 ~                                    jp      nz, passedCheck
148+  0000 ~                                    ld      a,l
149+  0000 ~                                    cp      c
150+  0000 ~            .NoTheSame:
151+  0000                                      ENDM
152+  0000
153+  0000              cpDEEquBC:              MACRO   passedCheck
154+  0000 ~                                    ld      a,d
155+  0000 ~                                    cp      b
156+  0000 ~                                    jp      nz, passedCheck
157+  0000 ~                                    ld      a,e
158+  0000 ~                                    cp      c
159+  0000 ~            .NoTheSame:
160+  0000                                      ENDM
161+  0000              ; Simple version just sets carry if HL < DE reset, does an initial compare for z
162+  0000              cpHLDELeadSign:         MACRO
163+  0000 ~                                    ld      a,h
164+  0000 ~                                    cp      d
165+  0000 ~                                    jr      nz,.FullCompare
166+  0000 ~                                    ld      a,l
167+  0000 ~                                    cp      e
168+  0000 ~                                    ret     z
169+  0000 ~            .FullCompare:           ld      a,h
170+  0000 ~                                    xor     d
171+  0000 ~                                    and     $80
172+  0000 ~                                    jr      nz,.OppositeSigns   ; If opposite signs is a simple sign test
173+  0000 ~                                    ld      a,h                 ; same signs so a little simpler
174+  0000 ~                                    and     $80
175+  0000 ~                                    jp      z,cpHLDE            ; if h is positive then both are positive by here so just cpHLDE
176+  0000 ~                                    jp      cpABSDEHL           ; else we have to do ABScpDEHL
177+  0000 ~            .OppositeSigns:         ld      a,h
178+  0000 ~                                    and     $80
179+  0000 ~                                    and     $80
180+  0000 ~                                    jp      z,.HLGTDE
181+  0000 ~            .HLLTDE:                SetCarryFlag
182+  0000 ~                                    ret
183+  0000 ~            .HLGTDE:                ClearCarryFlag
184+  0000 ~                                    ret
185+  0000                                      ENDM
186+  0000
187+  0000              ;Unsigned
188+  0000              ;If HL == DE, then Z flag is set.
189+  0000              ;If HL != DE, then Z flag is reset.
190+  0000              ;If HL <  DE, then C flag is set.
191+  0000              ;If HL >= DE, then C flag is reset.
192+  0000              ;
193+  0000              ;Signed
194+  0000              ;If HL == DE, then Z flag is set.
195+  0000              ;If HL != DE, then Z flag is reset.
196+  0000              ;If HL <  DE, then S and P/V are different.
197+  0000              ;If HL >= DE, then S and P/V are the same.
198+  0000
199+  0000
200+  0000              N0equN1byN2div256:      MACRO param1,param2,param3
201+  0000 ~                                    ld      a,param3                        ;
202+  0000 ~                                    ld      e,a                         ; use e as var Q = value of XX15 [n] lo
203+  0000 ~                                    ld      a,param2                        ; A = XX16 element
204+  0000 ~                                    ld      d,a
205+  0000 ~                                    mul
206+  0000 ~                                    ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
207+  0000 ~                                    ld      (param1),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
208+  0000                                      ENDM
209+  0000
210+  0000              AequN1xorN2:            MACRO  param1,param2
211+  0000 ~                                    ld      a,(param1)
212+  0000 ~                                    xor     param2
213+  0000                                      ENDM
214+  0000
215+  0000              SpeedMulAxis:           MACRO   speedreg, axis
216+  0000 ~                                    ld      e,speedreg
217+  0000 ~                                    ld      hl,(axis)
218+  0000 ~                                    ld      a,h
219+  0000 ~                                    ClearSignBitA
220+  0000 ~                                    ld      d,a
221+  0000 ~                                    mul     de
222+  0000 ~                                    ld      a,h
223+  0000 ~                                    SignBitOnlyA
224+  0000 ~                                    ld      b,a;ld      c,a
225+  0000 ~                                    ld      h,d;ld      e,d
226+  0000 ~                                    ld      c,0;ld      d,0
227+  0000                                      ENDM
228+  0000
229+  0000              ; Adds speed (8 bit) to vertex (24 bit signed)
230+  0000              AddSpeedToVert:         MACRO   vertex
231+  0000 ~                                    ld      de,(vertex+1)
232+  0000 ~                                    ld      a,(vertex)
233+  0000 ~                                    ld      l,a
234+  0000 ~                                    call    AddBCHtoDELsigned               ; DEL = DEL + BCH
235+  0000 ~                                    ld      a,l
236+  0000 ~                                    ld      (vertex),a
237+  0000 ~                                    ld      (vertex+1),de
238+  0000                                      ENDM
# file closed: ../../Macros/MathsMacros.asm
 67   0000                                      INCLUDE "../../Macros/MMUMacros.asm"
# file opened: ../../Macros/MMUMacros.asm
  1+  0000              MMUSelectROM0:       MACRO
  2+  0000 ~                                 nextreg EXSDOSMMU0,        BankROM
  3+  0000                                   ENDM
  4+  0000
  5+  0000              MMUSelectROMS:       MACRO
  6+  0000 ~                                 nextreg EXSDOSMMU0,        BankROM
  7+  0000 ~                                 nextreg EXSDOSMMU1,        BankROM
  8+  0000                                   ENDM
  9+  0000
 10+  0000              MMUSelectMathsTables:MACRO
 11+  0000 ~                                 nextreg MathsTablesMMU,    BankMathsTables
 12+  0000                                   ENDM
 13+  0000
 14+  0000              MMUSelectKeyboard:   MACRO
 15+  0000 ~                                 nextreg KeyboardMMU,       BankKeyboard
 16+  0000                                   ENDM
 17+  0000
 18+  0000              MMUSelectSpriteBank: MACRO
 19+  0000 ~            					 nextreg SpritememMMU,	    BankSPRITE
 20+  0000              					 ENDM
 21+  0000
 22+  0000              MMUSelectConsoleBank: MACRO
 23+  0000 ~            					 nextreg ConsoleImageDataMMU,  BankConsole
 24+  0000              					 ENDM
 25+  0000
 26+  0000              MMUSelectLayer1: 	 MACRO
 27+  0000 ~            					 nextreg L1memMMU,		    BankLAYER1
 28+  0000              					 ENDM
 29+  0000
 30+  0000              MMUSelectLayer2: 	 MACRO
 31+  0000 ~            					 nextreg L2memMMU,		    BankLAYER2
 32+  0000              					 ENDM
 33+  0000
 34+  0000              MMUSelectResetUniv:  MACRO
 35+  0000 ~                                 nextreg ResetUniverseMMU, BankResetUniv
 36+  0000                                   ENDM
 37+  0000
 38+  0000              MMUSelectShipARead:  MACRO
 39+  0000 ~                                 add    a,BankUNIVDATA0
 40+  0000 ~                                 nextreg ShipReadMMU,       a
 41+  0000                                   ENDM
 42+  0000
 43+  0000              MMUSelectShipBank1:  MACRO
 44+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModels1
 45+  0000              					 ENDM
 46+  0000              MMUSelectShipBank2:  MACRO
 47+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModels2
 48+  0000              					 ENDM
 49+  0000              MMUSelectShipBank3:  MACRO
 50+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModels3
 51+  0000              					 ENDM
 52+  0000              MMUSelectShipBank4:  MACRO
 53+  0000 ~            					 nextreg ShipModelMMU,	    BankShipModels4
 54+  0000              					 ENDM
 55+  0000
 56+  0000              MMUSelectShipBankA   MACRO
 57+  0000 ~            					 nextreg ShipModelMMU,	    a
 58+  0000              					 ENDM
 59+  0000
 60+  0000              MMUSelectShipBankN:  MACRO value
 61+  0000 ~            					 nextreg ShipModelMMU,	    value
 62+  0000              					 ENDM
 63+  0000
 64+  0000              MMUSelectCommander:	 MACRO
 65+  0000 ~                                 nextreg CommanderMMU,       BankCommander
 66+  0000              					 ENDM
 67+  0000
 68+  0000              MMUSelectStockTable: MACRO
 69+  0000 ~                                 nextreg StockTableMMU,     BankStockTable
 70+  0000              					 ENDM
 71+  0000
 72+  0000              MMUSelectCpySrcA:    MACRO
 73+  0000 ~                                 nextreg DMACpySourceMMU,	a
 74+  0000              					 ENDM
 75+  0000
 76+  0000              MMUSelectCpySrcN:    MACRO value
 77+  0000 ~                                 nextreg DMACpySourceMMU,	value
 78+  0000              					 ENDM
 79+  0000
 80+  0000              MMUSelectSun:        MACRO
 81+  0000 ~                                 nextreg SunMMU,            BankSunData
 82+  0000                                   ENDM
 83+  0000
 84+  0000              MMUSelectPlanet:     MACRO
 85+  0000 ~                                 nextreg PlanetMMU,         BankPlanetData
 86+  0000                                   ENDM
 87+  0000
 88+  0000              MMUSelectUniverseA:  MACRO
 89+  0000 ~                                 add    a,BankUNIVDATA0
 90+  0000 ~                                 nextreg UniverseMMU,       a
 91+  0000                                   ENDM
 92+  0000              ;Version that assumes a pre calulated A, used whn optimising many switches
 93+  0000              MMUSelectUnivBankA:  MACRO
 94+  0000 ~                                 nextreg UniverseMMU,       a
 95+  0000                                   ENDM
 96+  0000
 97+  0000              MMUSelectUniverseN:  MACRO value
 98+  0000 ~                                 nextreg UniverseMMU,       BankUNIVDATA0+value
 99+  0000                                   ENDM
100+  0000
101+  0000              MMUSelectSpaceStation: MACRO
102+  0000 ~                                 nextreg SpaceStationMMU,   BankSpaceStationData
103+  0000                                   ENDM
104+  0000
105+  0000              MMUSelectMathsBankedFns   MACRO
106+  0000 ~                                 nextreg MathsBankedFnsMMU, BankMathsBankedFns
107+  0000                                   ENDM
108+  0000
109+  0000              MMUSelectGalaxyA:    MACRO
110+  0000 ~                                 nextreg GalaxyDataMMU,     a
111+  0000                                   ENDM
112+  0000
113+  0000              MMUSelectGalaxyN:    MACRO value
114+  0000 ~                                 nextreg GalaxyDataMMU,     BankGalaxyData0+value
115+  0000                                   ENDM
116+  0000              MMUSelectGalaxyACopy:MACRO
117+  0000 ~                                 nextreg UniverseMMU,       a
118+  0000                                   ENDM
119+  0000
120+  0000              MMUSelectUniverseAbs:MACRO value
121+  0000 ~                                 nextreg UniverseMMU,       value
122+  0000                                   ENDM
123+  0000
124+  0000              MMUSelectMenuGalCht: MACRO
125+  0000 ~                                 nextreg MenuGalChtMMU,		BankMenuGalCht
126+  0000              					 ENDM
127+  0000
128+  0000              MMUSelectMenuShrCht: MACRO
129+  0000 ~            					 nextreg MenuShrChtMMU,		BankMenuShrCht
130+  0000              					 ENDM
131+  0000
132+  0000              MMUSelectMenuInvent: MACRO
133+  0000 ~                                 nextreg MenuInventMMU,		BankMenuInvent
134+  0000              					 ENDM
135+  0000
136+  0000              MMUSelectMenuSystem: MACRO
137+  0000 ~                                 nextreg MenuSystemMMU,		BankMenuSystem
138+  0000              					 ENDM
139+  0000
140+  0000              MMUSelectMenuMarket: MACRO
141+  0000 ~                                 nextreg MenuMarketMMU,		BankMenuMarket
142+  0000              					 ENDM
143+  0000
144+  0000              MMUSelectMenuStatus: MACRO
145+  0000 ~                                 nextreg MenuStatusMMU,		BankMenuStatus
146+  0000              					 ENDM
147+  0000
148+  0000              MMUSelectViewFront:  MACRO
149+  0000 ~                                 nextreg ScreenBankMMU,		BankFrontView
150+  0000              					 ENDM
151+  0000
152+  0000              MMUSelectScreenA:    MACRO
153+  0000 ~                                 nextreg ScreenBankMMU,		a
154+  0000              					 ENDM
155+  0000
156+  0000              MMUSelectSound:      MACRO
157+  0000 ~                                 nextreg SoundMMU,		    BankSound
158+  0000              					 ENDM
159+  0000
160+  0000
161+  0000
162+  0000              SaveMMU6:           MACRO
163+  0000 ~                                GetNextReg  MMU_SLOT_6_REGISTER
164+  0000 ~                                ld      (SavedMMU6),a
165+  0000                                  ENDM
166+  0000
167+  0000              RestoreMMU6:        MACRO
168+  0000 ~                                ld      a,(SavedMMU6)               ; now restore up post interrupt
169+  0000 ~                                nextreg MMU_SLOT_6_REGISTER,a       ; Restore MMU7
170+  0000                                  ENDM
171+  0000
172+  0000              SaveMMU7:           MACRO
173+  0000 ~                                GetNextReg  MMU_SLOT_7_REGISTER
174+  0000 ~                                ld      (SavedMMU7),a
175+  0000                                  ENDM
176+  0000
177+  0000              RestoreMMU7:        MACRO
178+  0000 ~                                ld      a,(SavedMMU7)               ; now restore up post interrupt
179+  0000 ~                                nextreg MMU_SLOT_7_REGISTER,a       ; Restore MMU7
180+  0000                                  ENDM
# file closed: ../../Macros/MMUMacros.asm
 68   0000                                      INCLUDE "../../Macros/NegateMacros.asm"
# file opened: ../../Macros/NegateMacros.asm
  1+  0000
  2+  0000              macronegate16hl:	MACRO
  3+  0000 ~            					xor 	a
  4+  0000 ~            					sub 	l
  5+  0000 ~            					ld 		l,a
  6+  0000 ~            					sbc 	a,a
  7+  0000 ~            					sub 	h
  8+  0000 ~            					ld 		h,a
  9+  0000              					ENDM
 10+  0000
 11+  0000
 12+  0000              macroAbsHL:         MACRO
 13+  0000 ~                                bit     7,h
 14+  0000 ~                                jp      z,.alreadyABS
 15+  0000 ~            					xor 	a
 16+  0000 ~            					sub 	l
 17+  0000 ~            					ld 		l,a
 18+  0000 ~            					sbc 	a,a
 19+  0000 ~            					sub 	h
 20+  0000 ~            					ld 		h,a
 21+  0000 ~            .alreadyABS:
 22+  0000                                  ENDM
 23+  0000
 24+  0000              macronegate16de:	MACRO
 25+  0000 ~            					xor 	a
 26+  0000 ~                                sub 	e
 27+  0000 ~                                ld 		e,a
 28+  0000 ~                                sbc 	a,a
 29+  0000 ~                                sub 	d
 30+  0000 ~                                ld 		d,a
 31+  0000              					ENDM
 32+  0000
 33+  0000              macronegate16bc:	MACRO
 34+  0000 ~            					xor 	a
 35+  0000 ~                                sub 	c
 36+  0000 ~                                ld 		c,a
 37+  0000 ~                                sbc 	a,a
 38+  0000 ~                                sub 	b
 39+  0000 ~                                ld 		b,a
 40+  0000              					ENDM
 41+  0000
 42+  0000              macronegate16ix:	MACRO
 43+  0000 ~            					xor 	a
 44+  0000 ~                                sub 	ixl
 45+  0000 ~                                ld 		ixl,a
 46+  0000 ~                                sbc 	a,a
 47+  0000 ~                                sub 	ixh
 48+  0000 ~                                ld 		ixh,a
 49+  0000              					ENDM
 50+  0000
 51+  0000
 52+  0000              NegIY:			    MACRO
 53+  0000 ~                                xor a
 54+  0000 ~                                sub iyl
 55+  0000 ~                                ld iyl,a
 56+  0000 ~                                sbc a,a
 57+  0000 ~                                sub iyh
 58+  0000 ~                                ld iyh,a
 59+  0000                                  ENDM
 60+  0000
 61+  0000              NegHL:			    MACRO
 62+  0000 ~                                xor a
 63+  0000 ~                                sub l
 64+  0000 ~                                ld l,a
 65+  0000 ~                                sbc a,a
 66+  0000 ~                                sub h
 67+  0000 ~                                ld h,a
 68+  0000                                  ENDM
 69+  0000
 70+  0000              NegDE:			    MACRO
 71+  0000 ~                                xor a
 72+  0000 ~                                sub e
 73+  0000 ~                                ld e,a
 74+  0000 ~                                sbc a,a
 75+  0000 ~                                sub d
 76+  0000 ~                                ld d,a
 77+  0000                                  ENDM
 78+  0000
 79+  0000              NegBC:			    MACRO
 80+  0000 ~                                xor a
 81+  0000 ~                                sub c
 82+  0000 ~                                ld c,a
 83+  0000 ~                                sbc a,a
 84+  0000 ~                                sub  b
 85+  0000 ~                                ld b,a
 86+  0000                                  ENDM
 87+  0000
 88+  0000              NegH                MACRO
 89+  0000 ~                                ld      a,h
 90+  0000 ~                                neg
 91+  0000 ~                                ld      h,a
 92+  0000                                  ENDM
 93+  0000
 94+  0000              NegD                MACRO
 95+  0000 ~                                ld      a,d
 96+  0000 ~                                neg
 97+  0000 ~                                ld      d,a
 98+  0000                                  ENDM
 99+  0000
100+  0000              NegB                MACRO
101+  0000 ~                                ld      a,b
102+  0000 ~                                neg
103+  0000 ~                                ld      b,a
104+  0000                                  ENDM
105+  0000
# file closed: ../../Macros/NegateMacros.asm
 69   0000                                      INCLUDE "../../Macros/returnMacros.asm"
# file opened: ../../Macros/returnMacros.asm
  1+  0000              ReturnIfHLNegative:     MACRO   target
  2+  0000 ~                                    bit     7,h
  3+  0000 ~                                    ret     nz
  4+  0000                                      ENDM
  5+  0000
  6+  0000              ReturnIfDENegative:     MACRO   target
  7+  0000 ~                                    bit     7,d
  8+  0000 ~                                    ret     nz
  9+  0000                                      ENDM
 10+  0000
 11+  0000              ReturnOnBitSet:         MACRO  reg, bitnbr
 12+  0000 ~                                    bit 	bitnbr,reg
 13+  0000 ~                                    ret     nz
 14+  0000                                      ENDM
 15+  0000
 16+  0000              ReturnOnMemBitSet:      MACRO mem, bitnbr
 17+  0000 ~                                    ld   a,(mem)
 18+  0000 ~                                    bit 	bitnbr,a
 19+  0000 ~                                    ret     nz
 20+  0000                                      ENDM
 21+  0000
 22+  0000              ReturnOnBitClear:       MACRO reg, bitnbr
 23+  0000 ~                                    bit 	bitnbr,reg
 24+  0000 ~                                    ret		z
 25+  0000                                      ENDM
 26+  0000
 27+  0000              ReturnOnMemBitClear:    MACRO mem, bitnbr
 28+  0000 ~                                    ld     a,(mem)
 29+  0000 ~                                    bit 	bitnbr,a
 30+  0000 ~                                    ret		z
 31+  0000                                      ENDM
 32+  0000
 33+  0000              ReturnIfMemFalse:       MACRO   mem
 34+  0000 ~                                    ld      a,(mem)
 35+  0000 ~                                    and     a
 36+  0000 ~                                    ret     nz
 37+  0000                                      ENDM
 38+  0000
 39+  0000              ReturnIfMemTrue:        MACRO   mem
 40+  0000 ~                                    ld      a,(mem)
 41+  0000 ~                                    and     a
 42+  0000 ~                                    ret     z
 43+  0000                                      ENDM
 44+  0000
 45+  0000              ReturnIfAIsZero:        MACRO
 46+  0000 ~                                    and     a
 47+  0000 ~                                    ret     z
 48+  0000                                      ENDM
 49+  0000
 50+  0000              ReturnIfMemisZero:      MACRO mem
 51+  0000 ~                                    ld   a,(mem)
 52+  0000 ~                                    and a
 53+  0000 ~                                    ret    z
 54+  0000                                      ENDM
 55+  0000
 56+  0000              ReturnIfMemIsNegative:  MACRO mem
 57+  0000 ~                                    ld      a,(mem)
 58+  0000 ~                                    and     $80
 59+  0000 ~                                    ret     nz
 60+  0000                                      ENDM
 61+  0000
 62+  0000              ReturnIfBitMaskClear    MACRO   bitmask
 63+  0000 ~                                    and     bitmask
 64+  0000 ~                                    ret     z
 65+  0000                                      ENDM
 66+  0000
 67+  0000              ReturnIfBitMaskSet      MACRO   bitmask
 68+  0000 ~                                    and     bitmask
 69+  0000 ~                                    ret     nz
 70+  0000                                      ENDM
 71+  0000
 72+  0000              ReturnIfMemEquN:        MACRO mem, value
 73+  0000 ~                                    ld     a,(mem)
 74+  0000 ~                                    cp     value
 75+  0000 ~                                    ret    nz
 76+  0000                                      ENDM
 77+  0000
 78+  0000              ReturnIfMemNeNusng:     MACRO mem, value
 79+  0000 ~                                    ld   a,(mem)
 80+  0000 ~                                    cp     value
 81+  0000 ~                                    ret    z
 82+  0000                                      ENDM
 83+  0000
 84+  0000              ReturnIfRegNotZero:     MACRO reg
 85+  0000 ~                                    ld      a, reg
 86+  0000 ~                                    and     a
 87+  0000 ~                                    ret     nz
 88+  0000                                      ENDM
 89+  0000
 90+  0000              ReturnIfANotZero:       MACRO
 91+  0000 ~                                    and     a
 92+  0000 ~                                    ret     nz
 93+  0000                                      ENDM
 94+  0000
 95+  0000              ReturnIfNotZero:        MACRO
 96+  0000 ~                                    ret     nz
 97+  0000                                      ENDM
 98+  0000
 99+  0000              ReturnIfZero:           MACRO
100+  0000 ~                                    ret     z
101+  0000                                      ENDM
102+  0000
103+  0000              ReturnIfNegative:       MACRO
104+  0000 ~                                    ret     m
105+  0000                                      ENDM
106+  0000
107+  0000
108+  0000              ReturnIfMemNotZero:     MACRO mem
109+  0000 ~                                    ld     a,(mem)
110+  0000 ~                                    and     a
111+  0000 ~                                    ret    nz
112+  0000                                      ENDM
113+  0000
114+  0000              ReturnIfAGTEusng:       MACRO value
115+  0000 ~                                    cp    value
116+  0000 ~                                    ret	 nc
117+  0000                                      ENDM
118+  0000
119+  0000              ReturnIfRegLTNusng:     MACRO reg, value
120+  0000 ~                                    ld      a,reg
121+  0000 ~                                    cp      value
122+  0000 ~                                    ret	    c
123+  0000                                      ENDM
124+  0000
125+  0000              ReturnIfALTNusng:       MACRO value
126+  0000 ~                                    cp    value
127+  0000 ~                                    ret	 c
128+  0000                                      ENDM
129+  0000
130+  0000              ReturnIfAGTENusng:      MACRO value
131+  0000 ~                                    cp    value
132+  0000 ~                                    ret	 nc
133+  0000                                      ENDM
134+  0000
135+  0000              ReturnIfAGTEMemusng:    MACRO value
136+  0000 ~                                    ld      hl,value
137+  0000 ~                                    cp      (hl)
138+  0000 ~                                    ret	    nc
139+  0000                                      ENDM
140+  0000
141+  0000              ReturnIfANENusng:       MACRO value
142+  0000 ~                                    cp      value
143+  0000 ~                                    ret     nz
144+  0000                                      ENDM
145+  0000
146+  0000              ReturnIfAEqNusng:       MACRO value
147+  0000 ~                                    cp      value
148+  0000 ~                                    ret     z
149+  0000                                      ENDM
150+  0000
# file closed: ../../Macros/returnMacros.asm
 70   0000                                      INCLUDE "../../Macros/ShiftMacros.asm"
# file opened: ../../Macros/ShiftMacros.asm
  1+  0000              ShiftIYRight1: MACRO
  2+  0000 ~            			   ld 	a,iyh
  3+  0000 ~            			   srl 	a
  4+  0000 ~            			   ld	iyh,a
  5+  0000 ~            			   ld 	a,iyl
  6+  0000 ~            			   rra
  7+  0000 ~            			   ld	iyl,a
  8+  0000              			   ENDM
  9+  0000
 10+  0000              ShiftIXRight1: MACRO
 11+  0000 ~            			   ld 	a,ixh
 12+  0000 ~            			   srl 	a
 13+  0000 ~            			   ld	ixh,a
 14+  0000 ~            			   ld 	a,ixl
 15+  0000 ~            			   rra
 16+  0000 ~            			   ld	ixl,a
 17+  0000              			   ENDM
 18+  0000
 19+  0000              ShiftIXhHLRight1: MACRO
 20+  0000 ~                           ld  a,ixh
 21+  0000 ~                           srl a
 22+  0000 ~                           ld  ixh,a
 23+  0000 ~            			   rr  h
 24+  0000 ~            			   rr  l
 25+  0000              			   ENDM
 26+  0000
 27+  0000              ShiftIYhDERight1: MACRO
 28+  0000 ~                           ld  a,iyh
 29+  0000 ~                           srl a
 30+  0000 ~                           ld  iyh,a
 31+  0000 ~                           rr  d
 32+  0000 ~            			   rr  e
 33+  0000              			   ENDM
 34+  0000
 35+  0000              ShiftIYlBCRight1: MACRO
 36+  0000 ~                           ld  a,iyl
 37+  0000 ~                           srl a
 38+  0000 ~                           ld  iyl,a
 39+  0000 ~            			   rr  b
 40+  0000 ~                           rr  c
 41+  0000              			   ENDM
 42+  0000
 43+  0000              ShiftIXlBCRight1: MACRO
 44+  0000 ~                           ld  a,ixl
 45+  0000 ~                           srl a
 46+  0000 ~                           ld  ixl,a
 47+  0000 ~            			   rr  b
 48+  0000 ~                           rr  c
 49+  0000              			   ENDM
 50+  0000
 51+  0000              ShiftHLRight1: MACRO
 52+  0000 ~            			   srl h
 53+  0000 ~            			   rr  l
 54+  0000              			   ENDM
 55+  0000
 56+  0000              ShiftDERight1: MACRO
 57+  0000 ~            			   srl d
 58+  0000 ~            			   rr  e
 59+  0000              			   ENDM
 60+  0000
 61+  0000              ShiftBCRight1: MACRO
 62+  0000 ~            			   srl b
 63+  0000 ~            			   rr  c
 64+  0000              			   ENDM
 65+  0000
 66+  0000
 67+  0000
 68+  0000              ShiftHLDiv8:   MACRO
 69+  0000 ~            			   srl h
 70+  0000 ~            			   rr  l
 71+  0000 ~            			   srl h
 72+  0000 ~            			   rr  l
 73+  0000 ~            			   srl h
 74+  0000 ~            			   rr  l
 75+  0000              			   ENDM
 76+  0000
 77+  0000              ShiftHLLeft1:  MACRO    ; 16 T states
 78+  0000 ~            			   sla l
 79+  0000 ~            			   rl  h
 80+  0000              			   ENDM
 81+  0000
 82+  0000              ShiftDELeft1:  MACRO    ; 16 T states
 83+  0000 ~            			   sla e
 84+  0000 ~            			   rl  d
 85+  0000              			   ENDM
 86+  0000
 87+  0000              BarrelHLLeft3: MACRO
 88+  0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
 89+  0000 ~                           push     bc      ; 10
 90+  0000 ~                           ld       b,3     ; 7
 91+  0000 ~                           bsrl     de,b    ; 8
 92+  0000 ~                           pop      bc      ; 10
 93+  0000 ~                           ex       de,hl   ; 4
 94+  0000                             ENDM
 95+  0000
 96+  0000              BarrelHLRight3: MACRO
 97+  0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
 98+  0000 ~                           push     bc      ; 10
 99+  0000 ~                           ld       b,3     ; 7
100+  0000 ~                           bsrl     de,b    ; 8
101+  0000 ~                           pop      bc      ; 10
102+  0000 ~                           ex       de,hl   ; 4
103+  0000                             ENDM
104+  0000
105+  0000              RollBCLeft1:   MACRO	; 16 T states
106+  0000 ~                           rl  c
107+  0000 ~                           rl  b
108+  0000                             ENDM
109+  0000
110+  0000              RollDELeft1:   MACRO	; 16 T states
111+  0000 ~                           rl  e
112+  0000 ~                           rl  d
113+  0000                             ENDM
114+  0000
115+  0000              ShiftBCLeft1:  MACRO    ; 16 T states
116+  0000 ~            			   sla c
117+  0000 ~            			   rl  b
118+  0000              			   ENDM
119+  0000
120+  0000              ShiftLeftMem:       MACRO   reg
121+  0000 ~                                ld      hl,reg
122+  0000 ~                                sla     (hl)
123+  0000                                  ENDM
124+  0000
125+  0000
126+  0000
127+  0000              ShiftMem16Right1:   MACRO memaddr
128+  0000 ~                                ld    hl,(memaddr)
129+  0000 ~                                srl   h
130+  0000 ~                                rr    l
131+  0000 ~                                ld    (memaddr),hl
132+  0000                                  ENDM
133+  0000
134+  0000              ShiftMem8Right1:    MACRO memaddr
135+  0000 ~                                ld      a,(memaddr)
136+  0000 ~                                srl     a
137+  0000 ~                                ld      (memaddr),a
138+  0000                                  ENDM
139+  0000
140+  0000
141+  0000              ShiftMem8Left1A:    MACRO memaddr
142+  0000 ~                                ld      a,(memaddr)
143+  0000 ~                                sla     a
144+  0000 ~                                ld      (memaddr),a
145+  0000                                  ENDM
146+  0000
# file closed: ../../Macros/ShiftMacros.asm
 71   0000                                      INCLUDE "../../Macros/signBitMacros.asm"
# file opened: ../../Macros/signBitMacros.asm
  1+  0000              SetMemBitN              MACRO mem,bitnbr
  2+  0000 ~                                    ld      hl,mem
  3+  0000 ~                                    set     bitnbr,(hl)
  4+  0000                                      ENDM
  5+  0000
  6+  0000              ClearMemBitN            MACRO mem,bitnbr
  7+  0000 ~                                    ld      hl,mem
  8+  0000 ~                                    res     bitnbr,(hl)
  9+  0000                                      ENDM
 10+  0000
 11+  0000
 12+  0000              ClearSignBitMem:        MACRO mem
 13+  0000 ~                                    ld      a,(mem)
 14+  0000 ~                                    and     SignMask8Bit
 15+  0000 ~                                    ld      (mem),a
 16+  0000                                      ENDM
 17+  0000
 18+  0000              SetSignBitMem:          MACRO   mem
 19+  0000 ~                                    ld      a,(mem)
 20+  0000 ~                                    or      SignOnly8Bit
 21+  0000 ~                                    ld      (mem),a
 22+  0000                                      ENDM
 23+  0000
 24+  0000              FlipSignMem:            MACRO mem
 25+  0000 ~                                    ld  a,(mem)
 26+  0000 ~                                    xor SignOnly8Bit
 27+  0000 ~                                    ld  (mem),a
 28+  0000                                      ENDM
 29+  0000
 30+  0000              SignBitOnlyMem:         MACRO mem
 31+  0000 ~                                    ld      a, (mem)
 32+  0000 ~                                    and     SignOnly8Bit
 33+  0000 ~                                    ld      (mem),a
 34+  0000                                      ENDM
 35+  0000
 36+  0000              ClearSignBit:           MACRO reg
 37+  0000 ~                                    ld      a,reg
 38+  0000 ~                                    and     SignMask8Bit
 39+  0000 ~                                    ld      reg,a
 40+  0000                                      ENDM
 41+  0000
 42+  0000              SetSignBit:             MACRO   reg
 43+  0000 ~                                    ld      a,reg
 44+  0000 ~                                    or      SignOnly8Bit
 45+  0000 ~                                    ld      reg,a
 46+  0000                                      ENDM
 47+  0000
 48+  0000              FlipSignBit:            MACRO   reg
 49+  0000 ~                                    ld      a, reg
 50+  0000 ~                                    xor     SignOnly8Bit
 51+  0000 ~                                    ld      reg,a
 52+  0000                                      ENDM
 53+  0000
 54+  0000              SignBitOnly:            MACRO   reg
 55+  0000 ~                                    ld      a, reg
 56+  0000 ~                                    and     SignOnly8Bit
 57+  0000 ~                                    ld      reg,a
 58+  0000                                      ENDM
 59+  0000
 60+  0000              ClearSignBitA:          MACRO
 61+  0000 ~                                    and     SignMask8Bit
 62+  0000                                      ENDM
 63+  0000
 64+  0000              SetSignBitA:            MACRO
 65+  0000 ~                                    or      SignOnly8Bit
 66+  0000                                      ENDM
 67+  0000
 68+  0000              FlipSignBitA:           MACRO
 69+  0000 ~                                    xor     SignOnly8Bit
 70+  0000                                      ENDM
 71+  0000
 72+  0000              SignBitOnlyA:           MACRO
 73+  0000 ~                                    and     SignOnly8Bit
 74+  0000                                      ENDM
# file closed: ../../Macros/signBitMacros.asm
 72   0000                                      INCLUDE "../../Macros/print_text_macros.asm"
# file opened: ../../Macros/print_text_macros.asm
  1+  0000
  2+  0000              print_msg_at_de_at_b_hl_macro:  MACRO   varcolour
  3+  0000 ~                                    ld      c,varcolour
  4+  0000 ~                                    call    l2_print_at_320
  5+  0000                                      ENDM
  6+  0000
  7+  0000              print_msg_ld_bc_at_de_macro:  MACRO  varcol
  8+  0000 ~                                    ld      hl,varcol
  9+  0000 ~                                    call    l2_print_at_320
 10+  0000                                      ENDM
 11+  0000
 12+  0000              print_msg_at_de_macro:  MACRO   varcolour, varrow, varcol
 13+  0000 ~                                    ld      c,varcolour
 14+  0000 ~                                    ld      b,varrow
 15+  0000 ~                                    ld      hl,varcol
 16+  0000 ~                                    call    l2_print_at_320
 17+  0000                                      ENDM
 18+  0000
 19+  0000              print_msg_ld_bc_macro:  MACRO   varcol, varmessage
 20+  0000 ~                                    ld      hl,varcol
 21+  0000 ~                                    ld      de,varmessage
 22+  0000 ~                                    call    l2_print_at_320
 23+  0000                                      ENDM
 24+  0000
 25+  0000              print_msg_macro:        MACRO   varcolour, varrow, varcol, varmessage
 26+  0000 ~                                    ld      c,varcolour
 27+  0000 ~                                    ld      b,varrow
 28+  0000 ~                                    ld      hl,varcol
 29+  0000 ~                                    ld      de,varmessage
 30+  0000 ~                                    call    l2_print_at_320
 31+  0000                                      ENDM
 32+  0000
 33+  0000              print_msg_wrap_macro:   MACRO   varcolour, varrow, varcol, varmessage
 34+  0000 ~                                    ld      c,varcolour
 35+  0000 ~                                    ld      b,varrow
 36+  0000 ~                                    ld      hl,varcol
 37+  0000 ~                                    ld      de,varmessage
 38+  0000 ~                                    call    l2_print_at_wrap_320
 39+  0000                                      ENDM
 40+  0000
# file closed: ../../Macros/print_text_macros.asm
 73   0000
 74   0000              MessageAt:              MACRO   x,y,message
 75   0000 ~                                    push    af,,bc,,de,,hl
 76   0000 ~                                    ld      d,y
 77   0000 ~                                    ld      e,x*8
 78   0000 ~                                    ld      hl,message
 79   0000 ~                                    call    l1_print_at_char_wrap
 80   0000 ~                                    pop     af,,bc,,de,,hl
 81   0000                                      ENDM
 82   0000
 83   0000              PrintHexARegAt:         MACRO   x,y
 84   0000 ~                                    push    af,,bc,,de,,hl
 85   0000 ~                                    ld      d,y
 86   0000 ~                                    ld      e,x*8
 87   0000 ~                                    call    l1_print_u8_hex_at_char
 88   0000 ~                                    pop     af,,bc,,de,,hl
 89   0000                                      ENDM
 90   0000
 91   0000
 92   0000              SetBorder:              MACRO   value
 93   0000 ~                                    ld          a,value
 94   0000 ~                                    call        l1_set_border
 95   0000                                      ENDM
 96   0000
 97   0000              charactersetaddr		equ 15360
 98   0000              STEPDEBUG               equ 1
 99   0000
100   0000              TopOfStack              equ $5CCB ;$6100
101   0000
102   0000                                      ORG $5DCB;      $6200
103   5DCB F3           EliteNextStartup:       di
104   5DCC ED 91 07 03  .InitialiseClockSpeed:  nextreg     TURBO_MODE_REGISTER,Speed_28MHZ
105   5DD0              .InitialiseLayerOrder:  DISPLAY "Starting Assembly At ", EliteNextStartup
106   5DD0                                      ; "STARTUP"
107   5DD0                                      ; Make sure  rom is in page 0 during load
108   5DD0 ED 91 15 05                          nextreg 	SPRITE_LAYERS_SYSTEM_REGISTER,%00000101 ; ULS
109   5DD4                                      SetBorder   0
109   5DD4 3E 00       >                        ld          a,0
109   5DD6 CD A9 63    >                        call        l1_set_border
110   5DD9 CD 84 63                             call        l1_cls
111   5DDC 3E 07                                ld          a,7
112   5DDE CD 9F 63                             call        l1_attr_cls_to_a
113   5DE1 ED 91 06 01  .InitialisePeripherals: nextreg     PERIPHERAL_2_REGISTER, AUDIO_CHIPMODE_AY ; Enable Turbo Sound
114   5DE5 ED 91 08 52                          nextreg     PERIPHERAL_3_REGISTER, DISABLE_RAM_IO_CONTENTION | ENABLE_TURBO_SOUND | INTERNAL_SPEAKER_ENABLE
115   5DE9 ED 91 09 00                          nextreg     PERIPHERAL_4_REGISTER, %00000000
116   5DED ED 91 68 10                          nextreg     ULA_CONTROL_REGISTER,  %00010000                ; set up ULA CONRTROL may need to change bit 0 at least, but bit 4 is separate extended keys from main matrix
117   5DF1              .InitialisingMessage:   MessageAt   0,0,InitialiseMessage
117   5DF1 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
117   5DF5 16 00       >                        ld      d,0
117   5DF7 1E 00       >                        ld      e,0*8
117   5DF9 21 34 5E    >                        ld      hl,InitialiseMessage
117   5DFC CD BD 65    >                        call    l1_print_at_char_wrap
117   5DFF E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
118   5E03 CD 61 60                             call        PiReset
119   5E06                                      MessageAt   15,0,ResetMessage
119   5E06 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
119   5E0A 16 00       >                        ld      d,0
119   5E0C 1E 78       >                        ld      e,15*8
119   5E0E 21 3D 5E    >                        ld      hl,ResetMessage
119   5E11 CD BD 65    >                        call    l1_print_at_char_wrap
119   5E14 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
120   5E18 DD 01                                break
121   5E1A CD 1C 66                             call        WaitForAnyKey
122   5E1D CD 47 5E     TestCode:               call        ENPiHello
123   5E20 CD 1C 66                             call        WaitForAnyKey
124   5E23 CD 07 5F                             call        ENPiPingTest
125   5E26 CD 1C 66                             call        WaitForAnyKey
126   5E29 3E 01                                ld          a,1
127   5E2B 32 45 5E                             ld          (Var_ViewPort),a
128   5E2E CD 6E 5F                             call        ENPiSetView
129   5E31 C3 31 5E     EndLoop:                jp          EndLoop
130   5E34 53 74 61 72  InitialiseMessage:      db 'Starting',0
130   5E38 74 69 6E 67
130   5E3C 00
131   5E3D 50 69 52 65  ResetMessage:           db 'PiReset',0
131   5E41 73 65 74 00
132   5E45              ;--------------------------------------------------------------------------------------
133   5E45              ; Elite Pi Commands
134   5E45              ;
135   5E45 00           Var_ViewPort:           DB      0
136   5E46 00           Var_BYTE                DB      0
137   5E47              PiSendCommand:          MACRO   cmd
138   5E47 ~                                    ld      d,cmd
139   5E47 ~                                    call    PiWriteByte
140   5E47                                      ENDM
141   5E47
142   5E47              ENPiHello:              MessageAt 0,2,CommandMessage
142   5E47 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
142   5E4B 16 02       >                        ld      d,2
142   5E4D 1E 00       >                        ld      e,0*8
142   5E4F 21 D3 5E    >                        ld      hl,CommandMessage
142   5E52 CD BD 65    >                        call    l1_print_at_char_wrap
142   5E55 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
143   5E59                                      PiSendCommand   1
143   5E59 16 01       >                        ld      d,1
143   5E5B CD 81 60    >                        call    PiWriteByte
144   5E5E                                      MessageAt 9,2,SentMessage
144   5E5E F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
144   5E62 16 02       >                        ld      d,2
144   5E64 1E 48       >                        ld      e,9*8
144   5E66 21 DB 5E    >                        ld      hl,SentMessage
144   5E69 CD BD 65    >                        call    l1_print_at_char_wrap
144   5E6C E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
145   5E70                                      MessageAt 13,2,HelloMessage
145   5E70 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
145   5E74 16 02       >                        ld      d,2
145   5E76 1E 68       >                        ld      e,13*8
145   5E78 21 CD 5E    >                        ld      hl,HelloMessage
145   5E7B CD BD 65    >                        call    l1_print_at_char_wrap
145   5E7E E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
146   5E82 21 CD 5E                             ld      hl,HelloMessage
147   5E85 16 05                                ld      d,5             ; 5 characters
148   5E87 1E 01                                ld      e,1             ; fixed, no terminating 0
149   5E89 CD 6C 62                             call    PiWriteString
150   5E8C                                      MessageAt 18,2,SentMessage
150   5E8C F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
150   5E90 16 02       >                        ld      d,2
150   5E92 1E 90       >                        ld      e,18*8
150   5E94 21 DB 5E    >                        ld      hl,SentMessage
150   5E97 CD BD 65    >                        call    l1_print_at_char_wrap
150   5E9A E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
151   5E9E                                      MessageAt 22,2,ReadingMessage
151   5E9E F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
151   5EA2 16 02       >                        ld      d,2
151   5EA4 1E B0       >                        ld      e,22*8
151   5EA6 21 E0 5E    >                        ld      hl,ReadingMessage
151   5EA9 CD BD 65    >                        call    l1_print_at_char_wrap
151   5EAC E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
152   5EB0 21 EF 5E                             ld      hl,HelloResponse
153   5EB3 16 05                                ld      d,5             ; 5 characters
154   5EB5 1E 01                                ld      e,1             ; fixed, no terminating 0
155   5EB7 CD 7F 62                             call    PiReadString
156   5EBA                                      MessageAt  0,3,HelloResponse
156   5EBA F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
156   5EBE 16 03       >                        ld      d,3
156   5EC0 1E 00       >                        ld      e,0*8
156   5EC2 21 EF 5E    >                        ld      hl,HelloResponse
156   5EC5 CD BD 65    >                        call    l1_print_at_char_wrap
156   5EC8 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
157   5ECC C9                                   ret
158   5ECD 48 65 6C 6C  HelloMessage:           DB 'Hello',0
158   5ED1 6F 00
159   5ED3 43 6F 6D 6D  CommandMessage:         DB 'Command',0
159   5ED7 61 6E 64 00
160   5EDB 53 65 6E 74  SentMessage:            DB 'Sent',0
160   5EDF 00
161   5EE0 52 65 61 64  ReadingMessage:         DB 'Reading',0
161   5EE4 69 6E 67 00
162   5EE8 50 69 6E 67  PingMessage:            db 'Ping ',0,0
162   5EEC 20 00 00
163   5EEF 58 58 58 58  HelloResponse:          db 'XXXXX',0,0,0,0,0,0,0,0
163   5EF3 58 00 00 00
163   5EF7 00 00 00 00
163   5EFB 00
164   5EFC 56 69 65 77  ViewMessage:            db 'View Set',0,0,0
164   5F00 20 53 65 74
164   5F04 00 00 00
165   5F07              ENPiPingTest:           MessageAt 0,4,CommandMessage
165   5F07 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
165   5F0B 16 04       >                        ld      d,4
165   5F0D 1E 00       >                        ld      e,0*8
165   5F0F 21 D3 5E    >                        ld      hl,CommandMessage
165   5F12 CD BD 65    >                        call    l1_print_at_char_wrap
165   5F15 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
166   5F19                                      PiSendCommand 2
166   5F19 16 02       >                        ld      d,2
166   5F1B CD 81 60    >                        call    PiWriteByte
167   5F1E                                      MessageAt 9,4,SentMessage
167   5F1E F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
167   5F22 16 04       >                        ld      d,4
167   5F24 1E 48       >                        ld      e,9*8
167   5F26 21 DB 5E    >                        ld      hl,SentMessage
167   5F29 CD BD 65    >                        call    l1_print_at_char_wrap
167   5F2C E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
168   5F30                                      MessageAt 13,4,PingMessage
168   5F30 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
168   5F34 16 04       >                        ld      d,4
168   5F36 1E 68       >                        ld      e,13*8
168   5F38 21 E8 5E    >                        ld      hl,PingMessage
168   5F3B CD BD 65    >                        call    l1_print_at_char_wrap
168   5F3E E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
169   5F42 CD 5F 61                             call    PiReadByte
170   5F45 21 6C 5F                             ld      hl,PingCode
171   5F48 C6 30                                add     a,'0'
172   5F4A 77                                   ld      (hl),a
173   5F4B                                      MessageAt   0,5,ResponseMessage
173   5F4B F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
173   5F4F 16 05       >                        ld      d,5
173   5F51 1E 00       >                        ld      e,0*8
173   5F53 21 5E 5F    >                        ld      hl,ResponseMessage
173   5F56 CD BD 65    >                        call    l1_print_at_char_wrap
173   5F59 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
174   5F5D C9                                   ret
175   5F5E 50 69 6E 67  ResponseMessage:        DB      'Ping Result : '
175   5F62 20 52 65 73
175   5F66 75 6C 74 20
175   5F6A 3A 20
176   5F6C 30 00        PingCode:               DB      '0', 0
177   5F6E              ENPiSetView:            MessageAt 0,6,CommandMessage
177   5F6E F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
177   5F72 16 06       >                        ld      d,6
177   5F74 1E 00       >                        ld      e,0*8
177   5F76 21 D3 5E    >                        ld      hl,CommandMessage
177   5F79 CD BD 65    >                        call    l1_print_at_char_wrap
177   5F7C E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
178   5F80                                      PiSendCommand 18
178   5F80 16 12       >                        ld      d,18
178   5F82 CD 81 60    >                        call    PiWriteByte
179   5F85                                      MessageAt 9,6,SentMessage
179   5F85 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
179   5F89 16 06       >                        ld      d,6
179   5F8B 1E 48       >                        ld      e,9*8
179   5F8D 21 DB 5E    >                        ld      hl,SentMessage
179   5F90 CD BD 65    >                        call    l1_print_at_char_wrap
179   5F93 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
180   5F97                                      MessageAt 13,6,ViewMessage
180   5F97 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
180   5F9B 16 06       >                        ld      d,6
180   5F9D 1E 68       >                        ld      e,13*8
180   5F9F 21 FC 5E    >                        ld      hl,ViewMessage
180   5FA2 CD BD 65    >                        call    l1_print_at_char_wrap
180   5FA5 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
181   5FA9 3A 45 5E                             ld      a,(Var_ViewPort)
182   5FAC 57                                   ld      d,a
183   5FAD CD 81 60                             call    PiWriteByte
184   5FB0                                      MessageAt  25,6,SentMessage
184   5FB0 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
184   5FB4 16 06       >                        ld      d,6
184   5FB6 1E C8       >                        ld      e,25*8
184   5FB8 21 DB 5E    >                        ld      hl,SentMessage
184   5FBB CD BD 65    >                        call    l1_print_at_char_wrap
184   5FBE E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
185   5FC2 C9                                   ret
186   5FC3              ; d = row char e = col pixel
187   5FC3 F5 C5 E5 D5  PrintPortBinary:        push    af,,bc,,hl,,de
188   5FC7 16 0C                                ld      d,12
189   5FC9 1E 00                                ld      e,0
190   5FCB                                      GetNextReg 152
190   5FCB 01 3B 24    >            ld bc,$243B
190   5FCE 3E 98       >            ld a,152
190   5FD0 ED 79       >            out (c),a
190   5FD2 04          >            inc b
190   5FD3 ED 78       >            in a,(c)
191   5FD5 CD 77 64                             call    l1_print_bin8_lh_at_char
192   5FD8 16 0C                                ld      d,12
193   5FDA 1E 0A                                ld      e,10
194   5FDC                                      GetNextReg 153
194   5FDC 01 3B 24    >            ld bc,$243B
194   5FDF 3E 99       >            ld a,153
194   5FE1 ED 79       >            out (c),a
194   5FE3 04          >            inc b
194   5FE4 ED 78       >            in a,(c)
195   5FE6 CD 77 64                             call    l1_print_bin8_lh_at_char
196   5FE9 16 0C                                ld      d,12
197   5FEB 1E 14                                ld      e,20
198   5FED                                      GetNextReg 155
198   5FED 01 3B 24    >            ld bc,$243B
198   5FF0 3E 9B       >            ld a,155
198   5FF2 ED 79       >            out (c),a
198   5FF4 04          >            inc b
198   5FF5 ED 78       >            in a,(c)
199   5FF7 CD 77 64                             call    l1_print_bin8_lh_at_char
200   5FFA D1 E1 C1 F1                          pop     af,,bc,,hl,,de
201   5FFE C9                                   ret
202   5FFF              ;--------------------------------------------------------------------------------------
203   5FFF              ; Pi Library
204   5FFF
205   5FFF              PiSetnDSRnCTSnACK:      MACRO
206   5FFF ~                                    nextreg 155,0
207   5FFF                                      ENDM
208   5FFF              PiSetnDSRCTSnACK:       MACRO
209   5FFF ~                                    nextreg 155,2
210   5FFF                                      ENDM
211   5FFF              PiSetDSR:               MACRO
212   5FFF ~                                    nextreg 155,1           ; Set DSR high andy anything else writable low
213   5FFF                                      ENDM
214   5FFF              PiSetnCTSACK:           MACRO
215   5FFF ~                                    nextreg 155,4           ; Set ACK high andy anything else writable low
216   5FFF                                      ENDM
217   5FFF ED 91 90 00  PiSetReadMode:          nextreg 144, 0              ; pins 4 to 7 read  enable
218   6003 ED 91 91 00                          nextreg 145, 0              ; pins 0 to 3 read enable
219   6007 ED 91 93 06                          nextreg 147,2+4             ; data ready pin read, CTS write, ack write , Desync read
220   600B                                      MessageAt 0,15,PiInReadMode
220   600B F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
220   600F 16 0F       >                        ld      d,15
220   6011 1E 00       >                        ld      e,0*8
220   6013 21 F7 61    >                        ld      hl,PiInReadMode
220   6016 CD BD 65    >                        call    l1_print_at_char_wrap
220   6019 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
221   601D                                      MessageAt 15,15,PiClearMode
221   601D F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
221   6021 16 0F       >                        ld      d,15
221   6023 1E 78       >                        ld      e,15*8
221   6025 21 05 62    >                        ld      hl,PiClearMode
221   6028 CD BD 65    >                        call    l1_print_at_char_wrap
221   602B E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
222   602F C9                                   ret
223   6030
224   6030 ED 91 90 F0  PiSetWriteMode:         nextreg 144, 16+32+64+128   ;pins 4 to 7 write enable
225   6034 ED 91 91 0F                          nextreg 145, 1+2+4+8        ;pins 0 to 3 write enable
226   6038 ED 91 93 09                          nextreg 147, 1 + 8          ;DSR and Desync pins write enable
227   603C                                      MessageAt 15,15,PiInWriteMode
227   603C F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
227   6040 16 0F       >                        ld      d,15
227   6042 1E 78       >                        ld      e,15*8
227   6044 21 E8 61    >                        ld      hl,PiInWriteMode
227   6047 CD BD 65    >                        call    l1_print_at_char_wrap
227   604A E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
228   604E                                      MessageAt 0,15,PiClearMode
228   604E F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
228   6052 16 0F       >                        ld      d,15
228   6054 1E 00       >                        ld      e,0*8
228   6056 21 05 62    >                        ld      hl,PiClearMode
228   6059 CD BD 65    >                        call    l1_print_at_char_wrap
228   605C E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
229   6060 C9                                   ret
230   6061              ;--------------------------------------------------------------------------------------
231   6061 ED 91 93 07  PiReset:                nextreg 147,1+2+4           ; data ready 0, cts 0, ack 0
232   6065 ED 91 9B 00                          nextreg 155,0               ;
233   6069 C9                                   ret
234   606A CD 30 60                             call    PiSetWriteMode      ; clear out bits on data line
235   606D ED 91 98 00                          nextreg 152,0
236   6071 ED 91 99 00                          nextreg 153,0
237   6075 ED 91 9B 00                          nextreg 155,0               ; and clear DSR,DeSync
238   6079 CD FF 5F                             call    PiSetReadMode
239   607C ED 91 9B 00                          nextreg 155,0               ; and clear CTS,ACK
240   6080 C9                                   ret
241   6081
242   6081              ;--------------------------------------------------------------------------------------
243   6081              ;  Write byte held in d (data)
244   6081              PiWriteByte:            IFDEF DEBUGMODE
245   6081 7A                                       ld      a,d
246   6082 32 46 5E                                 ld      (Var_BYTE),a
247   6085                                      ENDIF
248   6085 CD 30 60                             call    PiSetWriteMode      ; Write Mode
249   6088                                      PiSetnDSRnCTSnACK
249   6088 ED 91 9B 00 >                        nextreg 155,0
250   608C                                      IFDEF DEBUGMODE
251   608C                                          MessageAt 0,16,PiWaitCTS
251   608C F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
251   6090 16 10       >                        ld      d,16
251   6092 1E 00       >                        ld      e,0*8
251   6094 21 2F 62    >                        ld      hl,PiWaitCTS
251   6097 CD BD 65    >                        call    l1_print_at_char_wrap
251   609A E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
252   609E                                          MessageAt 15,16,PiClearMode
252   609E F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
252   60A2 16 10       >                        ld      d,16
252   60A4 1E 78       >                        ld      e,15*8
252   60A6 21 05 62    >                        ld      hl,PiClearMode
252   60A9 CD BD 65    >                        call    l1_print_at_char_wrap
252   60AC E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
253   60B0                                          MessageAt 0,17,PiClearMode
253   60B0 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
253   60B4 16 11       >                        ld      d,17
253   60B6 1E 00       >                        ld      e,0*8
253   60B8 21 05 62    >                        ld      hl,PiClearMode
253   60BB CD BD 65    >                        call    l1_print_at_char_wrap
253   60BE E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
254   60C2                                      ENDIF
255   60C2 CD B5 62                             call    PiWaitforCTSnACK    ; wait for Clear to send
256   60C5                                      IFDEF DEBUGMODE
257   60C5                                          MessageAt 15,16,PiWriting
257   60C5 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
257   60C9 16 10       >                        ld      d,16
257   60CB 1E 78       >                        ld      e,15*8
257   60CD 21 13 62    >                        ld      hl,PiWriting
257   60D0 CD BD 65    >                        call    l1_print_at_char_wrap
257   60D3 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
258   60D7                                          MessageAt 0,16,PiClearMode
258   60D7 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
258   60DB 16 10       >                        ld      d,16
258   60DD 1E 00       >                        ld      e,0*8
258   60DF 21 05 62    >                        ld      hl,PiClearMode
258   60E2 CD BD 65    >                        call    l1_print_at_char_wrap
258   60E5 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
259   60E9 3A 46 5E                                 ld      a,(Var_BYTE)
260   60EC                                          PrintHexARegAt 25,19
260   60EC F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
260   60F0 16 13       >                        ld      d,19
260   60F2 1E C8       >                        ld      e,25*8
260   60F4 CD 47 65    >                        call    l1_print_u8_hex_at_char
260   60F7 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
261   60FB                                      ENDIF
262   60FB 7A                                   ld      a,d                 ; build up port values and send
263   60FC                                      IFDEF DEBUGMODE
264   60FC 3A 46 5E                                 ld      a,(Var_BYTE)    ; DEBUG
265   60FF 57                                       ld      d,a
266   6100                                      ENDIF
267   6100 E6 F0                                and     %11110000           ; we don't swap here and let the pi
268   6102 ED 92 98                             nextreg 152,a               ; handle that
269   6105 7A                                   ld      a,d                 ; .
270   6106 E6 0F                                and     %00001111           ; .
271   6108 ED 92 99                             nextreg 153,a               ; .
272   610B                                      PiSetDSR                    ; Data Set is Ready
272   610B ED 91 9B 01 >                        nextreg 155,1           ; Set DSR high andy anything else writable low
273   610F                                      IFDEF DEBUGMODE
274   610F                                          MessageAt 0,17,PiWaitACK
274   610F F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
274   6113 16 11       >                        ld      d,17
274   6115 1E 00       >                        ld      e,0*8
274   6117 21 4B 62    >                        ld      hl,PiWaitACK
274   611A CD BD 65    >                        call    l1_print_at_char_wrap
274   611D E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
275   6121                                          MessageAt 15,16,PiClearMode
275   6121 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
275   6125 16 10       >                        ld      d,16
275   6127 1E 78       >                        ld      e,15*8
275   6129 21 05 62    >                        ld      hl,PiClearMode
275   612C CD BD 65    >                        call    l1_print_at_char_wrap
275   612F E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
276   6133                                      ENDIF
277   6133 CD 8F 62                             call    PiWaitforACK        ; Poll for Ackowledge
278   6136                                      IFDEF DEBUGMODE
279   6136                                          MessageAt 0,17,PiClearMode
279   6136 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
279   613A 16 11       >                        ld      d,17
279   613C 1E 00       >                        ld      e,0*8
279   613E 21 05 62    >                        ld      hl,PiClearMode
279   6141 CD BD 65    >                        call    l1_print_at_char_wrap
279   6144 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
280   6148                                          MessageAt 15,16,PiClearMode
280   6148 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
280   614C 16 10       >                        ld      d,16
280   614E 1E 78       >                        ld      e,15*8
280   6150 21 05 62    >                        ld      hl,PiClearMode
280   6153 CD BD 65    >                        call    l1_print_at_char_wrap
280   6156 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
281   615A                                      ENDIF
282   615A                                      PiSetnDSRnCTSnACK           ; clear DSR
282   615A ED 91 9B 00 >                        nextreg 155,0
283   615E C9                                   ret
284   615F              ;--------------------------------------------------------------------------------------
285   615F              ; result in a
286   615F CD FF 5F     PiReadByte:             call    PiSetReadMode       ; read mode
287   6162                                      PiSetnDSRCTSnACK            ; CTS and nACK (DSR is write only so won't matter)
287   6162 ED 91 9B 02 >                        nextreg 155,2
288   6166                                      IFDEF DEBUGMODE
289   6166                                          MessageAt 0,16,PiWaitDSR
289   6166 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
289   616A 16 10       >                        ld      d,16
289   616C 1E 00       >                        ld      e,0*8
289   616E 21 3D 62    >                        ld      hl,PiWaitDSR
289   6171 CD BD 65    >                        call    l1_print_at_char_wrap
289   6174 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
290   6178                                          MessageAt 15,16,PiClearMode
290   6178 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
290   617C 16 10       >                        ld      d,16
290   617E 1E 78       >                        ld      e,15*8
290   6180 21 05 62    >                        ld      hl,PiClearMode
290   6183 CD BD 65    >                        call    l1_print_at_char_wrap
290   6186 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
291   618A                                      ENDIF
292   618A CD CA 62                             call    PiWaitforDSR        ; Wait for data to be ready
293   618D                                      IFDEF DEBUGMODE
294   618D                                          MessageAt 15,16,PiReading
294   618D F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
294   6191 16 10       >                        ld      d,16
294   6193 1E 78       >                        ld      e,15*8
294   6195 21 21 62    >                        ld      hl,PiReading
294   6198 CD BD 65    >                        call    l1_print_at_char_wrap
294   619B E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
295   619F                                      ENDIF
296   619F                                      GetNextReg  152             ; Read data and re-assemble byte
296   619F 01 3B 24    >            ld bc,$243B
296   61A2 3E 98       >            ld a,152
296   61A4 ED 79       >            out (c),a
296   61A6 04          >            inc b
296   61A7 ED 78       >            in a,(c)
297   61A9 E6 F0                                and     %11110000           ; it will be pre swapnib on the pi side
298   61AB 6F                                   ld      l,a                 ; so we don't have to here
299   61AC                                      GetNextReg  153             ; .
299   61AC 01 3B 24    >            ld bc,$243B
299   61AF 3E 99       >            ld a,153
299   61B1 ED 79       >            out (c),a
299   61B3 04          >            inc b
299   61B4 ED 78       >            in a,(c)
300   61B6 E6 0F                                and     %00001111           ; .
301   61B8 B5                                   or      l                   ; .
302   61B9                                      IFDEF DEBUGMODE
303   61B9 32 46 5E                                 ld      (Var_BYTE),a
304   61BC                                      ENDIF
305   61BC                                      PiSetnCTSACK                ; not clear to send, ACK set
305   61BC ED 91 9B 04 >                        nextreg 155,4           ; Set ACK high andy anything else writable low
306   61C0                                      IFDEF DEBUGMODE
307   61C0 3A 46 5E                                 ld      a,(Var_BYTE)
308   61C3                                          PrintHexARegAt 25,19
308   61C3 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
308   61C7 16 13       >                        ld      d,19
308   61C9 1E C8       >                        ld      e,25*8
308   61CB CD 47 65    >                        call    l1_print_u8_hex_at_char
308   61CE E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
309   61D2 3A 46 5E                                 ld      a,(Var_BYTE)
310   61D5                                          MessageAt 15,16,PiClearMode
310   61D5 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
310   61D9 16 10       >                        ld      d,16
310   61DB 1E 78       >                        ld      e,15*8
310   61DD 21 05 62    >                        ld      hl,PiClearMode
310   61E0 CD BD 65    >                        call    l1_print_at_char_wrap
310   61E3 E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
311   61E7                                      ENDIF
312   61E7 C9                                   ret
313   61E8              ;--------------------------------------------------------------------------------------
314   61E8              ; Diag messages
315   61E8 49 6E 20 57  PiInWriteMode:          DB 'In Write  Mode',0
315   61EC 72 69 74 65
315   61F0 20 20 4D 6F
315   61F4 64 65 00
316   61F7 49 6E 20 52  PiInReadMode:           DB 'In Read Mode ',0
316   61FB 65 61 64 20
316   61FF 4D 6F 64 65
316   6203 20 00
317   6205 2E 2E 2E 2E  PiClearMode:            DB '.............',0
317   6209 2E 2E 2E 2E
317   620D 2E 2E 2E 2E
317   6211 2E 00
318   6213 57 72 69 74  PiWriting               DB 'Writing      ',0
318   6217 69 6E 67 20
318   621B 20 20 20 20
318   621F 20 00
319   6221 52 65 61 64  PiReading               DB 'Reading      ',0
319   6225 69 6E 67 20
319   6229 20 20 20 20
319   622D 20 00
320   622F 57 61 69 74  PiWaitCTS:              DB 'Waiting CTS  ',0
320   6233 69 6E 67 20
320   6237 43 54 53 20
320   623B 20 00
321   623D 57 61 69 74  PiWaitDSR:              DB 'Waiting DSR  ',0
321   6241 69 6E 67 20
321   6245 44 53 52 20
321   6249 20 00
322   624B 57 61 69 74  PiWaitACK:              DB 'Waiting ACK  ',0
322   624F 69 6E 67 20
322   6253 41 43 4B 20
322   6257 20 00
323   6259              ;--------------------------------------------------------------------------------------
324   6259              ; hl = word to write
325   6259 55           PiWriteWord:            ld      d,l
326   625A E5                                   push    hl
327   625B CD 81 60                             call    PiWriteByte
328   625E E1                                   pop     hl
329   625F 54                                   ld      d,h
330   6260 CD 81 60                             call    PiWriteByte
331   6263 C9                                   ret
332   6264              ;--------------------------------------------------------------------------------------
333   6264              ; de = word read - low high sequence
334   6264 CD 5F 61     PiReadWord:             call    PiReadByte
335   6267 5F                                   ld      e,a
336   6268 CD 5F 61                             call    PiReadByte
337   626B 57                                   ld      d,a
338   626C              ; hl = address of string to write, d = length, if e = 0 then send terminating /0
339   626C D5           PiWriteString:          push    de
340   626D 7E                                   ld      a,(hl)              ; assume that if d = 0 then we are writing 256 bytes
341   626E 57                                   ld      d,a                 ; d = data to write
342   626F CD 81 60                             call    PiWriteByte
343   6272 D1                                   pop     de
344   6273 15                                   dec     d
345   6274 C2 6C 62                             jp      nz,PiWriteString   ; if d has not hit zero then loop
346   6277                                      ZeroA                       ; if e is zero then send a /0 to finish
346   6277 AF          >                        xor a
347   6278 B3                                   or      e                   ; .
348   6279 C0                                   ret     nz                  ; this is done if receiving end is expecting variable string length
349   627A 57                                   ld      d,a                 ; d is data to write
350   627B CD 81 60                             call    PiWriteByte         ; a will stil be /0
351   627E C9                                   ret
352   627F              ; hl = address to write to, d = Limit, if e = 0 then expecting terminating /0 (i.e. variable length) else d = fixed string length
353   627F D5 E5        PiReadString:           push    de,,hl              ; Recived
354   6281 CD 5F 61                             call    PiReadByte
355   6284 E1                                   pop     hl
356   6285 77                                   ld      (hl),a
357   6286 23                                   inc     hl
358   6287 D1                                   pop     de
359   6288 15                                   dec     d
360   6289 C8                                   ret     z                   ; d provides a hard limit or fixed string length depending on e
361   628A B3                                   or      e                   ; if the byte read the a is 0 and e was zero then this will be zero
362   628B C2 7F 62                             jp      nz,PiReadString
363   628E C9                                   ret
364   628F
365   628F              PiWaitforACK:           GetNextReg  155             ; read status until bit 2 (ACK) is set
365   628F 01 3B 24    >            ld bc,$243B
365   6292 3E 9B       >            ld a,155
365   6294 ED 79       >            out (c),a
365   6296 04          >            inc b
365   6297 ED 78       >            in a,(c)
366   6299 CD C3 5F                             call    PrintPortBinary
367   629C E6 04                                and %00000100               ;
368   629E CA 8F 62                             jp  z,PiWaitforACK          ; if not then spin waiting
369   62A1 C9                                   ret
370   62A2
371   62A2              PiWaitforCTS:           GetNextReg  155             ; read status until bit 1 (CTS) is set
371   62A2 01 3B 24    >            ld bc,$243B
371   62A5 3E 9B       >            ld a,155
371   62A7 ED 79       >            out (c),a
371   62A9 04          >            inc b
371   62AA ED 78       >            in a,(c)
372   62AC CD C3 5F                             call    PrintPortBinary
373   62AF E6 02                                and %00000010               ;
374   62B1 CA A2 62                             jp  z,PiWaitforCTS          ; if not then spin waiting
375   62B4 C9                                   ret
376   62B5              PiWaitforCTSnACK:       GetNextReg  155             ; read status for ACK low and CTS High
376   62B5 01 3B 24    >            ld bc,$243B
376   62B8 3E 9B       >            ld a,155
376   62BA ED 79       >            out (c),a
376   62BC 04          >            inc b
376   62BD ED 78       >            in a,(c)
377   62BF CD C3 5F                             call    PrintPortBinary
378   62C2 E6 06                                and %00000110               ; just want ACK and CTS bits
379   62C4 FE 02                                cp  %00000010               ; if CTS is set and ACK is clear
380   62C6 C2 B5 62                             jp  nz,PiWaitforCTSnACK     ; reg value is just CTS then we are good
381   62C9 C9                                   ret
382   62CA
383   62CA              PiWaitforDSR:           GetNextReg  155             ; read status until bit 2 (DSR) is set
383   62CA 01 3B 24    >            ld bc,$243B
383   62CD 3E 9B       >            ld a,155
383   62CF ED 79       >            out (c),a
383   62D1 04          >            inc b
383   62D2 ED 78       >            in a,(c)
384   62D4 CD C3 5F                             call    PrintPortBinary
385   62D7 E6 01                                and %00000001               ;
386   62D9 CA CA 62                             jp  z,PiWaitforDSR          ; if not then spin waiting
387   62DC C9                                   ret
388   62DD
389   62DD
390   62DD              SetPiDesycMode:
391   62DD
392   62DD              PIDescyncReceived:
393   62DD
394   62DD
395   62DD              SendAddObject:
396   62DD
397   62DD
398   62DD                                      INCLUDE	"../../Hardware/memfill_dma.asm"
# file opened: ../../Hardware/memfill_dma.asm
  1+  62DD
  2+  62DD 00           memfillvalue		DB 0
  3+  62DE 83 C3 C7 CB  memfill        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
  3+  62E2 7D
  4+  62E3 DD 62        memfill_astrt  		DW memfillvalue
  5+  62E5 00 40        memfill_length 		DB $00,$40
  6+  62E7 24 10 AD     					DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
  7+  62EA 00 00        memfill_bstrt  		DB $00,$00
  8+  62EC 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
  9+  62F0              memfill_cmd_len	  	EQU $ - memfill
 10+  62F0
 11+  62F0              memfill_dma:
 12+  62F0              ; "memfill_dma, hl = address to fill, a = value, de = length"
 13+  62F0              .set_fill_value:
 14+  62F0 32 DD 62     	ld 		(memfillvalue),a
 15+  62F3              .set_target:
 16+  62F3 22 EA 62     	ld		(memfill_bstrt),hl
 17+  62F6              .set_length:
 18+  62F6 ED 53 E5 62  	ld		(memfill_length),de
 19+  62FA              .write_dma:
 20+  62FA 21 DE 62     	ld 		hl, memfill
 21+  62FD 06 12        	ld 		b, memfill_cmd_len
 22+  62FF 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
 23+  6301 ED B3        	otir
 24+  6303 C9           	ret
 25+  6304
# file closed: ../../Hardware/memfill_dma.asm
399   6304              ; Layer 1  ------------------------------------------------------------------------------------------------------------------------
400   6304                  INCLUDE "../../Layer1Graphics/layer1_attr_utils.asm"
# file opened: ../../Layer1Graphics/layer1_attr_utils.asm
  1+  6304
  2+  6304 00 58        L1AttrRow00:            DW $5800                    ;Row 1    */
  3+  6306 20 58        L1AttrRow01:            DW $5820                    ;Row 2    */
  4+  6308 40 58        L1AttrRow02:            DW $5840                    ;Row 3    */
  5+  630A 60 58        L1AttrRow03:            DW $5860                    ;Row 4    */
  6+  630C 80 58        L1AttrRow04:            DW $5880                    ;Row 5    */
  7+  630E A0 58        L1AttrRow05:            DW $58A0                    ;Row 6    */
  8+  6310 C0 58        L1AttrRow06:            DW $58C0                    ;Row 7    */
  9+  6312 E0 58        L1AttrRow07:            DW $58E0                    ;Row 8    */
 10+  6314 00 59        L1AttrRow08:            DW $5900                    ;Row 9    */
 11+  6316 20 59        L1AttrRow09:            DW $5920                    ;Row 10   */
 12+  6318 40 59        L1AttrRow10:            DW $5940                    ;Row 11   */
 13+  631A 60 59        L1AttrRow11:            DW $5960                    ;Row 12   */
 14+  631C 80 59        L1AttrRow12:            DW $5980                    ;Row 13   */
 15+  631E A0 59        L1AttrRow13:            DW $59A0                    ;Row 14   */
 16+  6320 C0 59        L1AttrRow14:            DW $59C0                    ;Row 15   */
 17+  6322 E0 59        L1AttrRow15:            DW $59E0                    ;Row 16   */
 18+  6324 00 5A        L1AttrRow16:            DW $5A00                    ;Row 17   */
 19+  6326 20 5A        L1AttrRow17:            DW $5A20                    ;Row 18   */
 20+  6328 40 5A        L1AttrRow18:            DW $5A40                    ;Row 19   */
 21+  632A 60 5A        L1AttrRow19:            DW $5A60                    ;Row 20   */
 22+  632C 80 5A        L1AttrRow20:            DW $5A80                    ;Row 21   */
 23+  632E A0 5A        L1AttrRow21:            DW $5AA0                    ;Row 22   */
 24+  6330 C0 5A        L1AttrRow22:            DW $5AC0                    ;Row 23   */
 25+  6332 E0 5A        L1AttrRow23:            DW $5AE0                    ;Row 23   */
 26+  6334
 27+  6334              ; "l2_hilight_row, d = row, e = colour"
 28+  6334 21 04 63     l1_hilight_row:         ld      hl, L1AttrRow00
 29+  6337 4B                                   ld      c,e
 30+  6338 7A                                   ld      a,d
 31+  6339 CB 27                                sla     a
 32+  633B ED 31                                add     hl,a
 33+  633D 7E                                   ld      a,(hl)
 34+  633E 5F                                   ld      e,a
 35+  633F 23                                   inc     hl
 36+  6340 7E                                   ld      a,(hl)
 37+  6341 57                                   ld      d,a
 38+  6342 EB                                   ex      hl,de
 39+  6343 79                                   ld		a,c
 40+  6344 11 20 00                             ld		de, 32
 41+  6347 CD F0 62                             call	memfill_dma
 42+  634A C9                                   ret
 43+  634B
# file closed: ../../Layer1Graphics/layer1_attr_utils.asm
401   634B                  INCLUDE "../../Layer1Graphics/layer1_cls.asm"
# file opened: ../../Layer1Graphics/layer1_cls.asm
  1+  634B AF           l1_cls_top:             xor     a
  2+  634C 21 00 40                             ld      hl, $4000
  3+  634F 11 00 08                             ld      de, $0800
  4+  6352 CD F0 62                             call    memfill_dma
  5+  6355 C9                                   ret
  6+  6356
  7+  6356 AF           l1_cls_mid:             xor     a
  8+  6357 21 00 48                             ld      hl, $4800
  9+  635A 11 00 08                             ld      de, $0800
 10+  635D CD F0 62                             call    memfill_dma
 11+  6360 C9                                   ret
 12+  6361
 13+  6361 AF           l1_cls_bottom:          xor     a
 14+  6362 21 00 50                             ld      hl, $5000
 15+  6365 11 00 08                             ld      de, $0800
 16+  6368 CD F0 62                             call    memfill_dma
 17+  636B C9                                   ret
 18+  636C
 19+  636C              ; Designed specifically to clear a whole character aligned line
 20+  636C 1E 00        l1_cls_line_d:          ld      e,0
 21+  636E ED 94                                pixelad
 22+  6370 11 00 01                             ld      de,32 * 8
 23+  6373 AF                                   xor     a
 24+  6374 CD F0 62                             call    memfill_dma
 25+  6377 C9                                   ret
 26+  6378
 27+  6378              ; Designed specifically to clear a whole character aligned 2 lines line, used for say clearing hyperspace message
 28+  6378 1E 00        l1_cls_2_lines_d:       ld      e,0
 29+  637A ED 94                                pixelad
 30+  637C 11 00 02                             ld      de,32 * 16
 31+  637F AF                                   xor     a
 32+  6380 CD F0 62                             call    memfill_dma
 33+  6383 C9                                   ret
 34+  6384
 35+  6384 AF           l1_cls:                 xor		a
 36+  6385 21 00 40     l1_cls_to_a:            ld		hl,	$4000
 37+  6388 11 00 18                             ld		de, $1800
 38+  638B CD F0 62                             call	memfill_dma
 39+  638E C9                                   ret
 40+  638F
 41+  638F 21 00 58     l1_attr_cls_2DlinesA:   ld		hl,	$5800
 42+  6392 1E 20                                ld      e,32
 43+  6394 ED 30                                mul
 44+  6396 19                                   add     hl,de
 45+  6397 11 40 00                             ld		de, 32 * 2
 46+  639A CD F0 62                             call	memfill_dma
 47+  639D C9                                   ret
 48+  639E
 49+  639E
 50+  639E AF           l1_attr_cls:            xor		a
 51+  639F 21 00 58     l1_attr_cls_to_a:       ld		hl,	$5800
 52+  63A2 11 00 03                             ld		de, $0300
 53+  63A5 CD F0 62                             call	memfill_dma
 54+  63A8 C9                                   ret
 55+  63A9
 56+  63A9 01 FE FE     l1_set_border:          ld	    bc, 0xFEFE
 57+  63AC ED 79                                out		(c),a
 58+  63AE C9                                   ret
# file closed: ../../Layer1Graphics/layer1_cls.asm
402   63AF                  INCLUDE "../../Layer1Graphics/layer1_print_at.asm"
# file opened: ../../Layer1Graphics/layer1_print_at.asm
  1+  63AF              ; "l1 print char a = character, de = Ypixel Xpxiel rounded to char of print"
  2+  63AF D5 E5        l1_print_char:          push	de,,hl
  3+  63B1 ED 94                                pixelad								; hl = address of de
  4+  63B3 E5                                   push	hl							; save hl for loop
  5+  63B4 26 00                                ld		h,0
  6+  63B6 6F                                   ld		l,a
  7+  63B7 29                                   add		hl,hl						; * 2
  8+  63B8 29                                   add		hl,hl						; * 4
  9+  63B9 29                                   add		hl,hl						; * 8 to get byte address
 10+  63BA ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
 11+  63BE EB                                   ex		de,hl						; save address into de
 12+  63BF E1                                   pop		hl							; get back hl for loop
 13+  63C0 06 08                                ld		b,8							; do 8 rows
 14+  63C2 1A           .PrintCharLoop:         ld		a,(de)						; row byte
 15+  63C3 13                                   inc		de							; next byte
 16+  63C4 77                                   ld		(hl),a						; poke to screen
 17+  63C5 ED 93                                pixeldn								; Down 1 row
 18+  63C7 10 F9                                djnz	.PrintCharLoop				; loop for 8 bytes
 19+  63C9 E1 D1                                pop		de,,hl					    ; restore hl
 20+  63CB C9                                   ret
 21+  63CC
 22+  63CC              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
 23+  63CC              ; now skips ascii code < 32 but moves on cursor by 1 char
 24+  63CC              l1_print_at_char
 24+  63CC CB 22           sla     d       ; Convert D from char to pixel
 25+  63CE CB 22                                sla     d       ; by muliplying by 8
 26+  63D0 CB 22                                sla     d       ;
 27+  63D2 CB 23                                sla     e       ; Convert E from char to pixel
 28+  63D4 CB 23                                sla     e
 29+  63D6 CB 23                                sla     e
 30+  63D8              l1_print_at:
 31+  63D8 7E           .PrintLoop:             ld		a,(hl)
 32+  63D9 FE 00                                cp		0
 33+  63DB C8                                   ret		z
 34+  63DC                                      CallIfAGTENusng " ", l1_print_char
 34+  63DC FE 20       >                        cp      " "
 34+  63DE D4 AF 63    >                        call	nc,l1_print_char
 35+  63E1 23                                   inc		hl							; move 1 message character right
 36+  63E2 7B                                   ld		a,e
 37+  63E3 C6 08                                add		a,8
 38+  63E5 5F                                   ld		e,a							; move 1 screen character right
 39+  63E6 18 F0                                jr		.PrintLoop
 40+  63E8                                                      DISPLAY "TODO: looks liek rogue popde"
 41+  63E8              .Clearstackandfinish:   ;pop		de                      ; TODO LOOOKS TO BE A ROGUE POPDE
 42+  63E8 C9                                   ret
 43+  63E9
 44+  63E9
 45+  63E9
 46+  63E9 30 30 00     HexU8Char:       DB "00",0
 47+  63EC 30 30 30 30  HexU16Char:      DB "0000",0
 47+  63F0 00
 48+  63F1 2B 30 30 00  HexS8Char:       DB "+00",0
 49+  63F5 2B 30 30 30  HexS16Char:      DB "+0000",0
 49+  63F9 30 00
 50+  63FB 2B 30 30 30  HexS24Char:      DB "+0000.00",0
 50+  63FF 30 2E 30 30
 50+  6403 00
 51+  6404 2A 2A 00     HexU8NaN:        DB "**",0
 52+  6407 30 30 30 30  Bin8Bit:         DB "00000000",0
 52+  640B 30 30 30 30
 52+  640F 00
 53+  6410              ; prints + sign for bit 7 clear in a else - sign for bit 7 set, Load to buffer location in ix
 54+  6410 CB 7F        l1_buffer_sign_at_ix:   bit     7,a
 55+  6412 CA 1B 64                             jp      z,.PrintPlus
 56+  6415 3E 2D        .PrintMinus:            ld      a,"-"
 57+  6417 DD 77 00                             ld      (ix+0),a
 58+  641A C9                                   ret
 59+  641B 3E 2B        .PrintPlus:             ld      a,"+"
 60+  641D DD 77 00                             ld      (ix+0),a
 61+  6420 C9                                   ret
 62+  6421
 63+  6421 30 31 32 33  HexMapping:     DB "0123456789ABCDEF"
 63+  6425 34 35 36 37
 63+  6429 38 39 41 42
 63+  642D 43 44 45 46
 64+  6431              ; writes hex 8 bit to ix buffer position
 65+  6431 C5 E5        l1_buffer_hex_8_at_ix:  push    bc,,hl
 66+  6433 47                                   ld      b,a
 67+  6434 ED 23                                swapnib
 68+  6436 E6 0F                                and     $0F
 69+  6438 21 21 64                             ld      hl,HexMapping
 70+  643B ED 31                                add     hl,a
 71+  643D 7E                                   ld      a,(hl)
 72+  643E DD 77 00                             ld      (ix+0),a
 73+  6441 21 21 64                             ld      hl,HexMapping
 74+  6444 78                                   ld      a,b
 75+  6445 E6 0F                                and     $0F
 76+  6447 ED 31                                add     hl,a
 77+  6449 7E                                   ld      a,(hl)
 78+  644A DD 77 01                             ld      (ix+1),a
 79+  644D E1 C1                                pop     bc,,hl
 80+  644F C9                                   ret
 81+  6450 F5 C5 D5 E5  l1_print_bin8_at_char:    push  af,,bc,,de,,hl
 82+  6454 DD 21 07 64                            ld    ix,Bin8Bit
 83+  6458 06 08                                  ld    b,8
 84+  645A CB 27        .WriteLoop:               sla   a
 85+  645C 38 05                                  jr    c,.ItsaOne
 86+  645E 0E 30        .ItsAZero:                ld    c,'0'
 87+  6460 C3 65 64                               jp    .DoWrite
 88+  6463 0E 31        .ItsaOne:                 ld    c,'1'
 89+  6465 DD 71 00     .DoWrite:                 ld    (ix+0),c
 90+  6468 DD 23                                  inc   ix
 91+  646A 10 EE                                  djnz  .WriteLoop
 92+  646C E1 D1 C1 F1                            pop   af,,bc,,de,,hl
 93+  6470 21 07 64                               ld    hl,Bin8Bit
 94+  6473 CD CC 63                               call  l1_print_at_char
 95+  6476 C9                                     ret
 96+  6477
 97+  6477 F5 C5 D5 E5  l1_print_bin8_lh_at_char: push  af,,bc,,de,,hl
 98+  647B DD 21 07 64                            ld    ix,Bin8Bit
 99+  647F 06 08                                  ld    b,8
100+  6481 CB 3F        .WriteLoop:               srl   a
101+  6483 38 05                                  jr    c,.ItsaOne
102+  6485 0E 30        .ItsAZero:                ld    c,'0'
103+  6487 C3 8C 64                               jp    .DoWrite
104+  648A 0E 31        .ItsaOne:                 ld    c,'1'
105+  648C DD 71 00     .DoWrite:                 ld    (ix+0),c
106+  648F DD 23                                  inc   ix
107+  6491 10 EE                                  djnz  .WriteLoop
108+  6493 E1 D1 C1 F1                            pop   af,,bc,,de,,hl
109+  6497 21 07 64                               ld    hl,Bin8Bit
110+  649A CD CC 63                               call  l1_print_at_char
111+  649D C9                                     ret
112+  649E
113+  649E              ; prints 16 bit lead sign hex value in HLA at char pos DE
114+  649E F5           l1_print_s24_hex_at_char: push  af                      ; first off do sign
115+  649F DD 21 FB 63                            ld    ix,HexS24Char
116+  64A3 7C                                     ld    a,h
117+  64A4 CD 10 64                               call  l1_buffer_sign_at_ix
118+  64A7 F1                                     pop   af                      ; now do hl as an unsigned by clearing bit 7
119+  64A8 DD 23                                  inc   ix                      ; move to actual digits
120+  64AA F5                                     push  af
121+  64AB 7C                                     ld    a,h
122+  64AC CB BF                                  res   7,a                     ; clear sign bit regardless
123+  64AE CD 31 64                               call  l1_buffer_hex_8_at_ix
124+  64B1 DD 23                                  inc   ix
125+  64B3 DD 23                                  inc   ix
126+  64B5 7D                                     ld    a,l
127+  64B6 CD 31 64                               call  l1_buffer_hex_8_at_ix
128+  64B9 DD 23                                  inc   ix
129+  64BB DD 23                                  inc   ix
130+  64BD DD 23                                  inc   ix                      ; also skip decimal point
131+  64BF F1                                     pop   af
132+  64C0 CD 31 64                               call  l1_buffer_hex_8_at_ix
133+  64C3 21 FB 63                               ld    hl,HexS24Char           ; by here de is still unaffected
134+  64C6 CD CC 63                               call  l1_print_at_char
135+  64C9 C9                                     ret
136+  64CA              ; prints 16 bit lead sign hex value in HL at char pos DE
137+  64CA DD 21 F5 63  l1_print_s16_hex_at_char: ld    ix,HexS16Char
138+  64CE 7C                                     ld    a,h
139+  64CF CD 10 64                               call  l1_buffer_sign_at_ix
140+  64D2 DD 23                                  inc   ix                      ; move to actual digits
141+  64D4 7C                                     ld    a,h
142+  64D5 CB BF                                  res   7,a
143+  64D7 CD 31 64                               call  l1_buffer_hex_8_at_ix
144+  64DA DD 23                                  inc   ix
145+  64DC DD 23                                  inc   ix
146+  64DE 7D                                     ld    a,l
147+  64DF CD 31 64                               call  l1_buffer_hex_8_at_ix
148+  64E2 21 F5 63                               ld    hl,HexS16Char           ; by here de is still unaffected
149+  64E5 CD CC 63                               call  l1_print_at_char
150+  64E8 C9                                     ret
151+  64E9              ; prints 16 bit unsigned hext value in HL at char pos DE
152+  64E9 DD 21 EC 63  l1_print_u16_hex_at_char: ld    ix,HexU16Char
153+  64ED 7C                                     ld    a,h
154+  64EE CD 31 64                               call  l1_buffer_hex_8_at_ix
155+  64F1 DD 23                                  inc   ix
156+  64F3 DD 23                                  inc   ix
157+  64F5 7D                                     ld    a,l
158+  64F6 CD 31 64                               call  l1_buffer_hex_8_at_ix
159+  64F9 21 EC 63                               ld    hl,HexU16Char           ; by here de is still unaffected
160+  64FC CD CC 63                               call  l1_print_at_char
161+  64FF C9                                     ret
162+  6500              ; prints 8 bit signed hext value in a at char pos DE
163+  6500 DD 21 F1 63  l1_print_s8_hex_at_char:  ld    ix,HexS8Char
164+  6504 67                                     ld    h,a                     ; save a into h
165+  6505 CD 10 64                               call  l1_buffer_sign_at_ix
166+  6508 DD 23                                  inc   ix                      ; move to actual digits
167+  650A 7C                                     ld    a,h                     ; get a back
168+  650B CB BF                                  res   7,a                     ; clear sign bit regardless
169+  650D CD 31 64                               call  l1_buffer_hex_8_at_ix
170+  6510 21 F1 63                               ld    hl,HexS8Char           ; by here de is still unaffected
171+  6513 CD CC 63                               call  l1_print_at_char
172+  6516 C9                                     ret
173+  6517              ; prints 8 bit 2s compliment value in a at char pos DE
174+  6517 DD 21 F1 63  l1_print_82c_hex_at_char: ld    ix,HexS8Char
175+  651B 67                                     ld    h,a                     ; save a into h
176+  651C CD 10 64                               call  l1_buffer_sign_at_ix
177+  651F DD 23                                  inc   ix                      ; move to actual digits
178+  6521 7C                                     ld    a,h                     ; get a back
179+  6522 CB 7F                                  bit   7,a
180+  6524 CA 29 65                               jp    z,.NoNeg
181+  6527 ED 44                                  neg
182+  6529 CD 31 64     .NoNeg:                   call  l1_buffer_hex_8_at_ix
183+  652C 21 F1 63                               ld    hl,HexS8Char           ; by here de is still unaffected
184+  652F CD CC 63                               call  l1_print_at_char
185+  6532 C9                                     ret
186+  6533
187+  6533              ; prints Lead Sign byte 8 bit signed hex value in hl at char pos DE, reuse HexS8Char buffer
188+  6533 DD 21 F1 63  l1_print_s08_hex_at_char: ld    ix,HexS8Char
189+  6537 CD 10 64                               call  l1_buffer_sign_at_ix    ; h holds sign bit
190+  653A DD 23                                  inc   ix                      ; move to actual digits
191+  653C 7D                                     ld    a,l                     ; l holds value
192+  653D CD 31 64                               call  l1_buffer_hex_8_at_ix
193+  6540 21 F1 63                               ld    hl,HexS8Char           ; by here de is still unaffected
194+  6543 CD CC 63                               call  l1_print_at_char
195+  6546 C9                                     ret
196+  6547              ; prints 8 bit signed hext value in a at char pos DE
197+  6547 DD 21 E9 63  l1_print_u8_hex_at_char:  ld    ix,HexU8Char
198+  654B CD 31 64                               call  l1_buffer_hex_8_at_ix
199+  654E 21 E9 63                               ld    hl,HexU8Char           ; by here de is still unaffected
200+  6551 CD CC 63                               call  l1_print_at_char
201+  6554 C9                                     ret
202+  6555 2B 00        l1_PlusSign:              DB      "+",0
203+  6557 2D 00        l1_MinusSign:             DB      "-",0
204+  6559 20 00        l1_ClearSign:             DB      " ",0
205+  655B              ; Displays sign byte in A at DE
206+  655B FE 80        l1_printSignByte:         cp      $80
207+  655D C2 73 65                               jp      nz,.DisplayPlus
208+  6560 FE 01                                  cp      1
209+  6562 C2 6C 65                               jp      nz,.DisplayMinus
210+  6565 21 59 65     .DisplayClear:            ld      hl,l1_ClearSign
211+  6568 CD CC 63                               call    l1_print_at_char
212+  656B C9                                     ret
213+  656C 21 57 65     .DisplayMinus             ld      hl,l1_MinusSign
214+  656F CD CC 63                               call    l1_print_at_char
215+  6572 C9                                     ret
216+  6573 21 55 65     .DisplayPlus:             ld      hl,l1_PlusSign
217+  6576 CD CC 63                               call    l1_print_at_char
218+  6579 C9                                     ret
219+  657A
220+  657A 21 04 64     l1_print_u8_nan_at_char:  ld    hl,HexU8NaN
221+  657D CD CC 63                               call  l1_print_at_char
222+  6580 C9                                     ret
223+  6581
224+  6581
225+  6581              ;l1_print_at_wrap:
226+  6581              ;; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
227+  6581              ;	ld      iyh,e
228+  6581              ;.PrintLoop:
229+  6581              ;	ld		a,(hl)
230+  6581              ;	cp		0
231+  6581              ;	ret		z
232+  6581              ;.CountWordCharLen
233+  6581              ;; Need to change to word wrap, so it will loop through string as before
234+  6581              ;; but read up until a null or space, take the character count * 8 for pixels
235+  6581              ;; if that is > 238 then force a premature line wrap
236+  6581              ;
237+  6581              ;
238+  6581              ;    push    iy
239+  6581              ;    call	l1_print_char
240+  6581              ;    pop     iy
241+  6581              ;	inc		hl							; move 1 message character right
242+  6581              ;	ld		a,e
243+  6581              ;    cp      238
244+  6581              ;    jr      nc,.NextLine
245+  6581              ;	add		a,8
246+  6581              ;	ld		e,a							; move 1 screen character right
247+  6581              ;	jr		.PrintLoop
248+  6581              ;.Clearstackandfinish:
249+  6581              ;	pop		de
250+  6581              ;	ret
251+  6581              ;.NextLine:
252+  6581              ;    ld      a,(hl)
253+  6581              ;    cp      " "
254+  6581              ;    ld      e,iyh
255+  6581              ;    ld      a,d
256+  6581              ;    add     a,8
257+  6581              ;    ld      d,a
258+  6581              ;    jr		.PrintLoop
259+  6581
260+  6581              ; Counts next word at hl, uses e and forces a wrap if it would over flow puts value in c
261+  6581 E5           L1LenWordAtHL:          push    hl
262+  6582 D5                                   push    de
263+  6583 7E           .CountLoop:             ld      a,(hl)
264+  6584 FE 00                                cp      0
265+  6586 28 0F                                jr      z,.CountDone
266+  6588 FE 20                                cp      32
267+  658A 28 0B                                jr      z,.CountDone
268+  658C 7B                                   ld      a,e
269+  658D C6 08                                add     a,8
270+  658F 5F                                   ld      e,a
271+  6590 FE EE                                cp      238
272+  6592 30 07                                jr      nc,.TooLong
273+  6594 23                                   inc     hl
274+  6595 18 EC                                jr      .CountLoop
275+  6597 D1           .CountDone:             pop     de
276+  6598 E1                                   pop     hl
277+  6599 AF                                   xor     a
278+  659A C9                                   ret
279+  659B D1           .TooLong                pop     de
280+  659C E1                                   pop     hl
281+  659D 3E FF                                ld      a,$FF
282+  659F C9                                   ret
283+  65A0
284+  65A0 7E           L1PrintWordAtHL:        ld      a,(hl)
285+  65A1 FE 00                                cp      0
286+  65A3 C8                                   ret     z
287+  65A4 FE 20                                cp      32
288+  65A6 28 0F                                jr      z,.ItsASpace
289+  65A8 FD E5                                push    iy
290+  65AA CD AF 63                             call	l1_print_char
291+  65AD FD E1                                pop     iy
292+  65AF 7B                                   ld      a,e
293+  65B0 C6 08                                add     a,8
294+  65B2 5F                                   ld      e,a
295+  65B3 23                                   inc     hl
296+  65B4 C3 A0 65                             jp      L1PrintWordAtHL
297+  65B7 23           .ItsASpace:             inc     hl      ;  Just a bodge for now
298+  65B8 7B                                   ld      a,e
299+  65B9 C6 08                                add     a,8
300+  65BB 5F                                   ld      e,a
301+  65BC C9                                   ret
302+  65BD
303+  65BD
304+  65BD              ; print at based whole character positions DE=yx, HL = message Addr
305+  65BD              ;
306+  65BD CB 22        l1_print_at_char_wrap:  sla     d       ; Convert D from char to pixel
307+  65BF CB 22                                sla     d       ; by muliplying by 8
308+  65C1 CB 22                                sla     d       ;
309+  65C3              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
310+  65C3              ; Now has full word level wrapping
311+  65C3 FD 63        l1_print_at_wrap:       ld      iyh,e
312+  65C5 7E           .PrintLoop:             ld		a,(hl)
313+  65C6 FE 00                                cp		0
314+  65C8 C8                                   ret		z
315+  65C9 CD 81 65     .CountWordCharLen:      call    L1LenWordAtHL
316+  65CC FE FF                                cp      $FF
317+  65CE 28 06                                jr      z,.WrapNextLine
318+  65D0 CD A0 65     .NotTooLong:            call    L1PrintWordAtHL
319+  65D3              ; Need to change to word wrap, so it will loop through string as before
320+  65D3              ; but read up until a null or space, take the character count * 8 for pixels
321+  65D3              ; if that is > 238 then force a premature line wrap
322+  65D3 18 F0                                jr		.PrintLoop
323+  65D5              .Clearstackandfinish:   ;op		de
324+  65D5 C9                                   ret
325+  65D6              .WrapNextLine:
326+  65D6 FD 5C        .NextLine:              ld      e,iyh
327+  65D8 7A                                   ld      a,d
328+  65D9 C6 08                                add     a,8
329+  65DB 57                                   ld      d,a
330+  65DC 18 E7                                jr		.PrintLoop
331+  65DE
332+  65DE
# file closed: ../../Layer1Graphics/layer1_print_at.asm
403   65DE
404   65DE              ; Keyboard
405   65DE FE FD FB F7  KeyAddrTab				DB	$FE, $FD, $FB, $F7, $EF, $DF, $BF, $7F
405   65E2 EF DF BF 7F
406   65E6
407   65E6 21 DE 65     WaitForNoKey:           ld      hl,KeyAddrTab                   ; de = table of IO ports to read
408   65E9 06 08                                ld		b,8                             ; 8 ports to ready
409   65EB 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
410   65EC DB FE                                in		a,($FE)							; read port to a
411   65EE E6 1F                                and     %00011111
412   65F0 FE 1F                                cp      %00011111
413   65F2 20 F2                                jr      nz ,WaitForNoKey
414   65F4 23                                   inc		hl                              ; and ready for next read
415   65F5 10 F4                                djnz    .PortReadLoop
416   65F7 C9                                   ret
417   65F8 57 61 69 74  WaitMsg:                DB "Waiting for Input",0
417   65FC 69 6E 67 20
417   6600 66 6F 72 20
417   6604 49 6E 70 75
417   6608 74 00
418   660A 2E 2E 2E 2E  WaitClear:              DB ".................",0
418   660E 2E 2E 2E 2E
418   6612 2E 2E 2E 2E
418   6616 2E 2E 2E 2E
418   661A 2E 00
419   661C F5 D5 C5 E5  WaitForAnyKey:          push    af,,de,,bc,,hl
420   6620                                      IFDEF DEBUGMODE
421   6620                                          MessageAt 10,20,WaitMsg
421   6620 F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
421   6624 16 14       >                        ld      d,20
421   6626 1E 50       >                        ld      e,10*8
421   6628 21 F8 65    >                        ld      hl,WaitMsg
421   662B CD BD 65    >                        call    l1_print_at_char_wrap
421   662E E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
422   6632                                      ENDIF
423   6632 CD E6 65                             call    WaitForNoKey
424   6635 21 DE 65     .waitKeyLoop:           ld		hl,KeyAddrTab                   ; de = table of IO ports to read
425   6638 06 08                                ld		b,8                             ; 8 ports to ready
426   663A 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
427   663B DB FE                                in		a,($FE)							; read port to a
428   663D E6 1F                                and     %00011111
429   663F FE 1F                                cp      %00011111
430   6641 C2 4B 66                             jp      nz,.WaitComplete
431   6644 C0                                   ret     nz
432   6645 23                                   inc		hl                              ; and ready for next read
433   6646 10 F2                                djnz    .PortReadLoop
434   6648 C3 35 66                             jp      .waitKeyLoop
435   664B E1 C1 D1 F1  .WaitComplete:          pop     af,,de,,bc,,hl
436   664F                                      IFDEF DEBUGMODE
437   664F                                          MessageAt 10,20,WaitClear
437   664F F5 C5 D5 E5 >                        push    af,,bc,,de,,hl
437   6653 16 14       >                        ld      d,20
437   6655 1E 50       >                        ld      e,10*8
437   6657 21 0A 66    >                        ld      hl,WaitClear
437   665A CD BD 65    >                        call    l1_print_at_char_wrap
437   665D E1 D1 C1 F1 >                        pop     af,,bc,,de,,hl
438   6661                                      ENDIF
439   6661 C9                                   ret
440   6662
441   6662              MainNonBankedCodeEnd:
442   6662
443   6662
444   6662                  SAVENEX OPEN "piiotest.nex", EliteNextStartup , TopOfStack
445   6662                  SAVENEX CFG  0,0,0,1
446   6662                  SAVENEX AUTO
447   6662                  SAVENEX CLOSE
448   6662                  DISPLAY "Main Non Banked Code End ", MainNonBankedCodeEnd , " Bytes free ", 0B000H - MainNonBankedCodeEnd
449   6662                  ASSERT MainNonBankedCodeEnd < 0B000H, Program code leaks intot interrup vector table
450   6662
# file closed: piiotest.asm
