# file opened: TriangleTst.asm
   1  0000               DEVICE ZXSPECTRUMNEXT
   2  0000
   3  0000               CSPECTMAP TriangleTst.map
   4  0000               OPT --zxnext=cspect --syntax=a --reversepop
   5  0000
   6  0000              DEBUGSEGSIZE   equ 1
   7  0000              DEBUGLOGSUMMARY equ 1
   8  0000              ;DEBUGLOGDETAIL equ 1
   9  0000
  10  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  11  0000              ; Game Defines
  12  0000              ScreenLocal     EQU 0
  13  0000              ScreenGalactic  EQU ScreenLocal + 1
  14  0000              ScreenMarket    EQU ScreenGalactic + 1
  15  0000              ScreenMarketDsp EQU ScreenMarket + 1
  16  0000              ScreenStatus    EQU ScreenMarketDsp + 1
  17  0000              ScreenInvent    EQU ScreenStatus + 1
  18  0000              ScreenPlanet    EQU ScreenInvent + 1
  19  0000              ScreenEquip     EQU ScreenPlanet + 1
  20  0000              ScreenLaunch    EQU ScreenEquip + 1
  21  0000              ScreenFront     EQU ScreenLaunch + 1
  22  0000              ScreenAft       EQU ScreenFront+1
  23  0000              ScreenLeft      EQU ScreenAft+2
  24  0000              ScreenRight     EQU ScreenLeft+3
  25  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  26  0000              ; Colour Defines
  27  0000                  INCLUDE "./Hardware/L2ColourDefines.asm"
# file opened: ./Hardware/L2ColourDefines.asm
   1+ 0000              L2ColourBLACK           EQU   0
   2+ 0000              L2ColourRED_1           EQU 224                 ; RGB 255,  0,  0
   3+ 0000              L2ColourRED_2           EQU 192                 ; RGB 218,  0,  0
   4+ 0000              L2ColourRED_3           EQU 160                 ; RGB 182,  0,  0
   5+ 0000              L2ColourRED_4           EQU 128                 ; RGB 145,  0,  0
   6+ 0000              L2ColourRED_5           EQU  96                 ; RGB 109,  0,  0
   7+ 0000              L2ColourRED_6           EQU  64                 ; RGB  72,  0,  0
   8+ 0000              L2ColourRED_7           EQU  32                 ; RGB  36,  0,  0
   9+ 0000              L2ColourYELLOW_1        EQU 252                 ; RGB 255,255,  0
  10+ 0000              L2ColourYELLOW_2        EQU 216                 ; RGB 218,218,  0
  11+ 0000              L2ColourYELLOW_3        EQU 180                 ; RGB 182,182,  0
  12+ 0000              L2ColourYELLOW_4        EQU 144                 ; RGB 145,145,  0
  13+ 0000              L2ColourYELLOW_5        EQU 108                 ; RGB 109.109,  0
  14+ 0000              L2ColourYELLOW_6        EQU  72                 ; RGB  72, 72,  0
  15+ 0000              L2ColourYELLOW_7        EQU  36                 ; RGB  36, 36,  0
  16+ 0000              L2ColourGREEN_1		    EQU  28                 ; RGB   0,255,  0
  17+ 0000              L2ColourGREEN_2		    EQU  24                 ; RGB   0,218,  0
  18+ 0000              L2ColourGREEN_3		    EQU  16                 ; RGB   0,145,  0
  19+ 0000              L2ColourGREEN_4         EQU  12                 ; RGB   0,109,  0
  20+ 0000              L2ColourGREEN_5         EQU   8                 ; RGB   0, 72,  0
  21+ 0000              L2ColourGREEN_6         EQU   4                 ; RGB   0, 36,  0
  22+ 0000              L2ColourBLUE_1          EQU   3                 ; RGB 0,0,255
  23+ 0000              L2ColourBLUE_2          EQU   2                 ; RGB 0,0,170
  24+ 0000              L2ColourBLUE_3          EQU   1                 ; RGB 0,0,85
  25+ 0000
  26+ 0000
  27+ 0000              L2ColourWHITE_1         EQU 255                 ; RGB 255,255,255
  28+ 0000              L2ColourWHITE_2         EQU 146
  29+ 0000              L2ColourGREY_1		    EQU L2ColourWHITE_2
  30+ 0000              L2ColourGREY_2		    EQU 109
  31+ 0000              L2ColourGREY_3		    EQU  73
  32+ 0000              L2ColourGREY_4		    EQU  37
  33+ 0000
  34+ 0000              L2ColourGREEN_MB        EQU  29                 ;RGB 0,255,85
  35+ 0000              L2ColourGREEN_MR        EQU 124                 ;RGB 109.255,0
  36+ 0000              L2ColourCREAM_1         EQU 218                 ; RGB 218,218,170
  37+ 0000              L2ColourCREAM_2         EQU 182                 ; RGB 182,182,170
  38+ 0000              L2ColourCREAM_3         EQU 146                 ; RGB 145,145,170
  39+ 0000
  40+ 0000              L2ColourTRANSPARENT     EQU 227                 ; RGB 255,  0,255
  41+ 0000              L2ColourMAGENTA_1       EQU 162                 ; RGB 182,  0,170
  42+ 0000              L2ColourMAGENTA_2       EQU 130                 ; RGB 145,  0,170
  43+ 0000              L2ColourMAGENTA_3       EQU  97                 ; RGB 109,  0, 85
  44+ 0000              L2ColourMAGENTA_4       EQU  65                 ; RGB  72,  0, 85
  45+ 0000              L2ColourORANGE_1        EQU 236                 ; RGB
  46+ 0000              L2ColourORANGE_2        EQU 168                 ; RGB
  47+ 0000              L2ColourORANGE_3        EQU  68                 ; RGB
  48+ 0000              L2ColourCYAN_1          EQU  31                 ; RGB   0,255, 255
  49+ 0000              L2ColourCYAN_2          EQU  18                 ; RGB
  50+ 0000              L2ColourCYAN_3          EQU   9                 ; RGB
  51+ 0000              L2ColourPURPLE_1        EQU 109                 ; RGB
  52+ 0000              L2ColourPURPLE_2        EQU  66                 ; RGB
  53+ 0000              L2ColourPURPLE_3        EQU  33                 ; RGB
  54+ 0000              L2ColourPINK_1		    EQU 231                 ; RGB
  55+ 0000              L2ColourPINK_2		    EQU 226                 ; RGB
  56+ 0000              L2ColourPINK_3		    EQU 225                 ; RGB
  57+ 0000              L2ColourPINK_4		    EQU 224                 ; RGB
  58+ 0000
# file closed: ./Hardware/L2ColourDefines.asm
  28  0000                  INCLUDE "./Hardware/L1ColourDefines.asm"
# file opened: ./Hardware/L1ColourDefines.asm
   1+ 0000
   2+ 0000              L1ColourInkBlack        EQU %00000000
   3+ 0000              L1ColourInkBlue         EQU %00000001
   4+ 0000              L1ColourInkRed          EQU %00000010
   5+ 0000              L1ColourInkMagenta      EQU %00000011
   6+ 0000              L1ColourInkGreen        EQU %00000100
   7+ 0000              L1ColourInkCyan         EQU %00000101
   8+ 0000              L1ColourInkYellow       EQU %00000110
   9+ 0000              L1ColourInkWhite        EQU %00000111
  10+ 0000              L1ColourPaperBlack      EQU %00000000
  11+ 0000              L1ColourPaperBlue       EQU %00001000
  12+ 0000              L1ColourPaperRed        EQU %00010000
  13+ 0000              L1ColourPaperMagenta    EQU %00011000
  14+ 0000              L1ColourPaperGreen      EQU %00100000
  15+ 0000              L1ColourPaperCyan       EQU %00101000
  16+ 0000              L1ColourPaperYellow     EQU %00110000
  17+ 0000              L1ColourPaperWhite      EQU %00111000
  18+ 0000              L1ColourFlash           EQU %10000000
  19+ 0000              L1ColourBright          EQU %01000000
  20+ 0000              ;----------------------------------------------------------------------------------------------------------------------------------
  21+ 0000              ; Screen Specific Colour Defines
  22+ 0000              L1InvHighlight          EQU L1ColourBright | L1ColourPaperRed   | L1ColourInkYellow
  23+ 0000              L1InvLowlight           EQU                  L1ColourPaperBlack | L1ColourInkWhite
# file closed: ./Hardware/L1ColourDefines.asm
  29  0000
  30  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  31  0000
  32  0000                                      INCLUDE "./Hardware/register_defines.asm"
# file opened: ./Hardware/register_defines.asm
   1+ 0000              ; Peripheral 2
   2+ 0000              ENABLE_CPU_SPEED_MODE                   EQU %10000000
   3+ 0000              DIVERT_BEEP_ONLY                        EQU %01000000
   4+ 0000              ENABLE_50_60_SWITCH                     EQU %00100000
   5+ 0000              ENABLE_MMCAUTO_SWITCH                   EQU %00010000
   6+ 0000              ENABLE_MULTIFACE_M1                     EQU %00001000
   7+ 0000              PS2MODE_KEYBOARD                        EQU %00000000
   8+ 0000              PS2MODE_MOUSE                           EQU %00000100
   9+ 0000              AUDIO_CHIPMODE_YM                       EQU %00000000
  10+ 0000              AUDIO_CHIPMODE_AY                       EQU %00000001
  11+ 0000              AUDIO_CHIPMODE_DISABLED                 EQU %00000010
  12+ 0000              INTERNAL_SPEAKER_ENABLE                 EQU %00010000
  13+ 0000              ; Peripheral 3
  14+ 0000              UNLOCK_PORT_7FFD_PAGING                 EQU %10000000
  15+ 0000              DISABLE_RAM_IO_CONTENTION               EQU %01000000
  16+ 0000              AY_STEREO_MODE_ACB                      EQU %00100000
  17+ 0000              INTERNAL_SPEAKER                        EQU %00010000
  18+ 0000              ENABLE_DACS                             EQU %00001000
  19+ 0000              ENABLE_TIMEX_VIDEO_MODE                 EQU %00000100
  20+ 0000              ENABLE_TURBO_SOUND                      EQU %00000010
  21+ 0000              ENABLE_ISSUE2_KEYBOARD                  EQU %00000001
  22+ 0000              ; Peripheral 4
  23+ 0000              ENABLE_AY2_MONO                         EQU %10000000
  24+ 0000              ENABLE_AY1_MONO                         EQU %01000000
  25+ 0000              ENABLE_AY0_MONO                         EQU %00100000
  26+ 0000              SPRITE_ID_LOCKSTEP                      EQU %00010000
  27+ 0000              RESET_DIVMMC_MAPRAM                     EQU %00001000
  28+ 0000              SILENCE_HDMI_AUDIO                      EQU %00000100
  29+ 0000              SCALLINES_50PCT                         EQU %00000001
  30+ 0000              SCANLINES_25PCT                         EQU %00000010
  31+ 0000              SCANLINES_125PCT                        EQU %00000011
  32+ 0000              ; Audio Registers
  33+ 0000              CHANNEL_A_FINE                          EQU 0
  34+ 0000              CHANNEL_A_COARSE                        EQU 1
  35+ 0000              CHANNEL_B_FINE                          EQU 2
  36+ 0000              CHANNEL_B_COARSE                        EQU 3
  37+ 0000              CHANNEL_C_FINE                          EQU 4
  38+ 0000              CHANNEL_C_COARSE                        EQU 5
  39+ 0000              NOISE_PERIOD                            EQU 6
  40+ 0000              TONE_ENABLE                             EQU 7
  41+ 0000              CHANNEL_A_AMPLITUDE                     EQU 8
  42+ 0000              CHANNEL_B_AMPLITUDE                     EQU 9
  43+ 0000              CHANNEL_C_AMPLITUDE                     EQU 10
  44+ 0000              ENVELOPE_PERIOD_FINE                    EQU 11
  45+ 0000              ENVELOPE_PERIOD_COARSE                  EQU 12
  46+ 0000              ENVELOPE_SHAPE                          EQU 13
  47+ 0000
  48+ 0000              ENVELOPE_HOLD_ON                        EQU 1
  49+ 0000              ENVELOPE_ALTERNATE_ON                   EQU 2
  50+ 0000              ENVELOPE_ATTACK_ON                      EQU 4
  51+ 0000              ENVELOPE_CONTINUE_ON                    EQU 8
  52+ 0000
  53+ 0000              ENVELOPE_SHAPE_SINGLE_DECAY             EQU 0                                                                                    ; \____________
  54+ 0000              ENVELOPE_SHAPE_SINGLE_ATTACK            EQU                        ENVELOPE_ATTACK_ON                                            ; /|___________
  55+ 0000              ENVELOPE_SHAPE_REPEAT_DECAY             EQU ENVELOPE_CONTINUE_ON                                                                 ; \|\|\|\|\|\|\
  56+ 0000              ENVELOPE_SHAPE_REPEAT_DECAY_ATTACK      EQU ENVELOPE_CONTINUE_ON |                      ENVELOPE_ALTERNATE_ON                    ; \/\/\/\/\/\/\
  57+ 0000              ENVELOPE_SHAPE_SINGLE_DECAY_HOLD        EQU ENVELOPE_CONTINUE_ON |                      ENVELOPE_ALTERNATE_ON | ENVELOPE_HOLD_ON ; \|-----------
  58+ 0000              ENVELOPE_SHAPE_REPEAT_ATTACK            EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON                                            ; /|/|/|/|/|/|/|
  59+ 0000              ENVELOPE_SHAPE_SINGLE_ATTACK_HOLD       EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON |                         ENVELOPE_HOLD_ON ; /------------
  60+ 0000              ENVELOPE_SHAPE_REPEAT_ATTACK_DECAY      EQU ENVELOPE_CONTINUE_ON | ENVELOPE_ATTACK_ON | ENVELOPE_ALTERNATE_ON                    ; /\/\/\/\/\/\/
  61+ 0000
  62+ 0000              ENVELOPE_HOLD                           EQU %00000001
  63+ 0000              ENVELOPE_ALTERNATE                      EQU %00000010
  64+ 0000              ENVELOPE_ATTACK                         EQU %00000010
  65+ 0000              ENVELOPE_CONTINUE                       EQU %00000010
  66+ 0000              ; Sound Control
  67+ 0000              TONE_CHANNEL_A                          EQU %00000001
  68+ 0000              TONE_CHANNEL_B                          EQU %00000010
  69+ 0000              TONE_CHANNEL_C                          EQU %00000100
  70+ 0000              NOISE_CHANNEL_A                         EQU %00001000
  71+ 0000              NOISE_CHANNEL_B                         EQU %00010000
  72+ 0000              NOISE_CHANNEL_C                         EQU %00100000
  73+ 0000              ; Version for AND to enabled (its inverted)
  74+ 0000              TONE_CHANNEL_A_ON                       EQU %11111110
  75+ 0000              TONE_CHANNEL_B_ON                       EQU %11111101
  76+ 0000              TONE_CHANNEL_C_ON                       EQU %11111011
  77+ 0000              NOISE_CHANNEL_A_ON                      EQU %11110111
  78+ 0000              NOISE_CHANNEL_B_ON                      EQU %11101111
  79+ 0000              NOISE_CHANNEL_C_ON                      EQU %11011111
  80+ 0000
  81+ 0000              ; Turbo Sound Control
  82+ 0000              TURBO_MANDATORY                         EQU %10011100
  83+ 0000              TURBO_LEFT                              EQU %01000000
  84+ 0000              TURBO_RIGHT                             EQU %00100000
  85+ 0000              TURBO_CHIP_AY3                          EQU %00000011
  86+ 0000              TURBO_CHIP_AY2                          EQU %00000010
  87+ 0000              TURBO_CHIP_AY1                          EQU %00000001
  88+ 0000
  89+ 0000              IO_LAYER2_PORT                          EQU $123B
  90+ 0000              IO_EXT_BANK_PORT 			            EQU $DFFD ; 57341
  91+ 0000              IO_BANK_PORT                            EQU $7FFD ; 32765
  92+ 0000              REGISTER_NUMBER_PORT					EQU $243B
  93+ 0000              REGISTER_VALUE_PORT						EQU $253B
  94+ 0000              SPRITE_SLOT_PORT						EQU $303B ; port for sprite and pattern index
  95+ 0000              SPRITE_INFO_PORT                        EQU $0057
  96+ 0000              SPRITE_PATTERN_UPLOAD_PORT				EQU $005B
  97+ 0000              TURBO_SOUND_NEXT_CONTROL                EQU $FFFD
  98+ 0000              SOUND_CHIP_REGISTER_WRITE               EQU $BFFD
  99+ 0000              IO_KEYBOARD_PORT                        EQU $FE
 100+ 0000              IO_DATAGEAR_DMA_PORT 		            EQU $6B
 101+ 0000              UART_TX_PORT_PORT                       EQU $133B
 102+ 0000              UART_RX_PORT_PORT                       EQU $143B
 103+ 0000              UART_CONTROL_PORT                       EQU $153B
 104+ 0000              UART_FRAME_PORT                         EQU $163B
 105+ 0000              CTC_CHANNEL1_PORT                       EQU $183B
 106+ 0000              CTC_CHANNEL2_PORT                       EQU $193B
 107+ 0000              CTC_CHANNEL3_PORT                       EQU $1A3B
 108+ 0000              CTC_CHANNEL4_PORT                       EQU $1B3B
 109+ 0000              PLUS_3_MEMORY_PAGING_CONTROL_PORT       EQU $1FFD
 110+ 0000              MB02_DMA_PORT                           EQU $0B
 111+ 0000              SPECDRUM_DAC_OUTPUT                     EQU $DF
 112+ 0000
 113+ 0000              Speed_3_5MHZ                            EQU 0
 114+ 0000              Speed_7MHZ                              EQU 1
 115+ 0000              Speed_14MHZ                             EQU 2
 116+ 0000              Speed_28MHZ                             EQU 3
 117+ 0000
 118+ 0000
 119+ 0000              MACHINE_ID_REGISTER						EQU 0
 120+ 0000              VERSION_REGISTER						EQU 1
 121+ 0000              RESET_REGISTER		    				EQU 2
 122+ 0000              MACHINE_TYPE_REGISTER					EQU 3
 123+ 0000              PAGE_RAM_REGISTER						EQU 4
 124+ 0000              PERIPHERAL_1_REGISTER					EQU 5   ; Sets joystick mode, video frequency and Scandoubler
 125+ 0000              PERIPHERAL_2_REGISTER					EQU 6   ; Enables CPU Speed key, DivMMC, Multiface, Mouse and AY audio.
 126+ 0000              TURBO_MODE_REGISTER						EQU 7
 127+ 0000              PERIPHERAL_3_REGISTER					EQU 8   ; ABC/ACB Stereo, Internal Speaker, SpecDrum, Timex Video Modes, Turbo Sound Next, RAM contention and [un]lock 128k paging
 128+ 0000              PERIPHERAL_4_REGISTER                   EQU 9   ; Sets scanlines, AY mono output, Sprite-id lockstep, reset DivMMC mapram and disable HDMI audio
 129+ 0000              PERIPHERAL_5_REGISTER                   EQU 10  ; Mouse
 130+ 0000              CORE_VERSION_REGISTER                   EQU 14
 131+ 0000              ANTI_BRICK_SYSTEM_REGISTER				EQU 16
 132+ 0000              VIDEO_TIMING_REGISTER                   EQU 17
 133+ 0000              LAYER2_RAM_PAGE_REGISTER				EQU 18
 134+ 0000              LAYER2_RAM_SHADOW_REGISTER      		EQU 19
 135+ 0000              TRANSPARENCY_COLOUR_REGISTER			EQU 20
 136+ 0000              SPRITE_LAYERS_SYSTEM_REGISTER			EQU 21
 137+ 0000              LAYER2_OFFSET_X_REGISTER				EQU 22
 138+ 0000              LAYER2_OFFSET_Y_REGISTER				EQU 23
 139+ 0000              CLIP_WINDOW_LAYER2_REGISTER				EQU 24
 140+ 0000              CLIP_WINDOW_SPRITES_REGISTER			EQU 25
 141+ 0000              CLIP_WINDOW_ULA_REGISTER				EQU 26
 142+ 0000              CLIP_WINDOW_TILEMAP_REGISTER            EQU 27
 143+ 0000              CLIP_WINDOW_CONTROL_REGISTER			EQU 28
 144+ 0000              ;29 not used
 145+ 0000              ACTIVE_VIDEO_LINE_MSB_REGISTER			EQU 30
 146+ 0000              ACTIVE_VIDEO_LINE_LSB_REGISTER			EQU 31
 147+ 0000              ; 32 to 34 not used
 148+ 0000              LINE_INTERRUPT_CONTROL_REGISTER			EQU 34
 149+ 0000              LINE_INTERRUPT_VALUE_LSB_REGISTER		EQU 35
 150+ 0000              ULA_X_OFFSET_REGISTER                   EQU 38
 151+ 0000              ULA_Y_OFFSET_REGSITER                   EQU 39
 152+ 0000              KEYMAP_HIGH_ADDRESS_REGISTER			EQU 40
 153+ 0000              KEYMAP_LOW_ADDRESS_REGISTER				EQU 41
 154+ 0000              KEYMAP_HIGH_DATA_REGISTER				EQU 42
 155+ 0000              KEYMAP_LOW_DATA_REGISTER				EQU 43
 156+ 0000              DAC_B_MIRROR_REGISTER                   EQU 44
 157+ 0000              DAC_AB_MIRROR_REGISTER                  EQU 45
 158+ 0000              DAC_C_MORROR_REGISTER                   EQU 46
 159+ 0000              TILEMAP_OFFSET_XMSB_REGISTER            EQU 47
 160+ 0000              TILEMAP_OFFSET_XLSB_REGISTER            EQU 48
 161+ 0000              TILEMAP_OFFSET_YMSB_REGISTER            EQU 49
 162+ 0000              LORES_OFFSET_X_REGISTER					EQU 50
 163+ 0000              LORES_OFFSET_Y_REGISTER					EQU 51
 164+ 0000              SPRITE_PORT_INDEX_REGISTER              EQU 52
 165+ 0000              SPRITE_PORT_ATTR0_REGISTER              EQU 53
 166+ 0000              SPRITE_PORT_ATTR1_REGISTER              EQU 54
 167+ 0000              SPRITE_PORT_ATTR2_REGISTER              EQU 55
 168+ 0000              SPRITE_PORT_ATTR3_REGISTER              EQU 56
 169+ 0000              SPRITE_PORT_ATTR4_REGISTER              EQU 57
 170+ 0000              PALETTE_INDEX_REGISTER					EQU 64
 171+ 0000              PALETTE_VALUE_8BIT_REGISTER				EQU 65
 172+ 0000              PALETTE_FORMAT_REGISTER					EQU 66
 173+ 0000              PALETTE_CONTROL_REGISTER				EQU 67
 174+ 0000              PALETTE_VALUE_9BIT_REGISTER				EQU 68
 175+ 0000              TRANSPARENCY_COLOUR_FALLBACK_REGISTER   EQU 69
 176+ 0000              SPRITES_TRANSPARENCY_INDEX_REGISTER     EQU 70
 177+ 0000              TILEMAP_TRANSPARENCY_INDEX_REGISTER     EQU 71
 178+ 0000              ; 72 to 79 unused
 179+ 0000              MMU_SLOT_0_REGISTER						EQU 80
 180+ 0000              MMU_SLOT_1_REGISTER						EQU 81
 181+ 0000              MMU_SLOT_2_REGISTER						EQU 82
 182+ 0000              MMU_SLOT_3_REGISTER						EQU 83
 183+ 0000              MMU_SLOT_4_REGISTER						EQU 84
 184+ 0000              MMU_SLOT_5_REGISTER						EQU 85
 185+ 0000              MMU_SLOT_6_REGISTER						EQU 86
 186+ 0000              MMU_SLOT_7_REGISTER						EQU 87
 187+ 0000              ; 88 to 95 unused
 188+ 0000              COPPER_DATA_REGISTER					EQU 96
 189+ 0000              COPPER_CONTROL_LOW_REGISTER				EQU 97
 190+ 0000              COPPER_CONTROL_HIGH_REGISTER			EQU 98
 191+ 0000              COPPER_DATA_16BIT_WRITE_REGISTER        EQU 99
 192+ 0000              VERTICAL_VIDEO_LINE_OFFSET_REGISTER     EQU 100
 193+ 0000              ULA_CONTROL_REGISTER                    EQU 104
 194+ 0000              DISPLAY_CONTROL_1_REGISTER              EQU 105
 195+ 0000              LORES_CONTROL_REGISTER                  EQU 106
 196+ 0000              TILEMAP_CONTROL_REGISTER                EQU 107
 197+ 0000              DEFAULT_TILEMAP_ATTRIBUTE_REGISTER      EQU 108
 198+ 0000              ; 109 unused
 199+ 0000              TILEMAP_BASE_ADDRESS_REGISTER           EQU 110
 200+ 0000              TILE_DEFINITIONS_BASE_ADDRESS_REGISTER  EQU 111
 201+ 0000              LAYER_2_CONTROL_REGISTER                EQU 112
 202+ 0000              LAYER_2_X_OFFSET_MSB_REGISTER           EQU 113
 203+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_1          EQU 114
 204+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_2          EQU 115
 205+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_3          EQU 116
 206+ 0000              SPRITE_PORT_MIRROR_ATTRIBUTE_4          EQU 117
 207+ 0000              USER_STORAGE_0_REGISTER                 EQU 118 ; general purpose variable, e.g. for copper
 208+ 0000              EXPANSION_BUS_ENABLE_REGISTER           EQU 128
 209+ 0000              EXTENDED_KEYS_0_REGISTER                EQU 176
 210+ 0000              EXTENDED_KEYS_1_REGISTER                EQU 177
 211+ 0000
 212+ 0000              INTERUPT_CONTROL                        EQU $0C ; Interrupt control
 213+ 0000              NMI_RETURN_LSB				            EQU	$0C2	; NMI Return Address LSB
 214+ 0000              NMI_RETURN_MSB				            EQU	$0C3	; NMI Return Address MSB
 215+ 0000              INTERRUPT_EN0				            EQU	$0C4	; INT EN 0
 216+ 0000              INTERRUPT_EN1				            EQU	$0C5	; INT EN 1
 217+ 0000              INTERRUPT_EN2				            EQU	$0C6	; INT EN 2
 218+ 0000              INTERRUPT_ST0				            EQU	$0C8	; INT status 0
 219+ 0000              INTERRUPT_ST1				            EQU	$0C9	; INT status 1
 220+ 0000              INTERRUPT_ST2				            EQU	$0CA	; INT status 2
 221+ 0000              INTERRUPT_DM0				            EQU	$0CC	; INT DMA EN 0
 222+ 0000              INTERRUPT_DM1				            EQU	$0CD	; INT DMA EN 1
 223+ 0000              INTERRUPT_DM2				            EQU	$0CE	; INT DMA EN 2
 224+ 0000              CTC_CHANNEL_0				            EQU	$183B	; CTC channel 0 port
 225+ 0000              CTC_CHANNEL_1				            EQU	$193B	; CTC channel 1 port
 226+ 0000              CTC_CHANNEL_2				            EQU	$1A3B	; CTC channel 2 port
 227+ 0000              CTC_CHANNEL_3				            EQU	$1B3B	; CTC channel 3 port
 228+ 0000              CTC_CHANNEL_4				            EQU	$1C3B	; CTC channel 4 port
 229+ 0000              CTC_CHANNEL_5				            EQU	$1D3B	; CTC channel 5 port
 230+ 0000              CTC_CHANNEL_6				            EQU	$1E3B	; CTC channel 6 port
 231+ 0000              CTC_CHANNEL_7				            EQU	$1F3B	; CTC channel 7 port
 232+ 0000              CTCBASE                                 EQU $c0		; MSB Base address of buffer
 233+ 0000              CTCSIZE                                 EQU $04 	; MSB buffer length
 234+ 0000              CTCEND                                  EQU CTCBASE+(CTCSIZE*2)
 235+ 0000
 236+ 0000
 237+ 0000              DEBUG_LEDS_REGISTER						EQU 255
 238+ 0000
 239+ 0000
 240+ 0000              GetNextRegSaveBC:	MACRO register
 241+ 0000 ~                                push bc
 242+ 0000 ~                                ld bc,$243B
 243+ 0000 ~                                ld a,register
 244+ 0000 ~                                out (c),a
 245+ 0000 ~                                inc b
 246+ 0000 ~                                in a,(c)
 247+ 0000 ~                                pop bc
 248+ 0000                                  ENDM
 249+ 0000
 250+ 0000              GetNextReg:	MACRO register
 251+ 0000 ~                        ld bc,$243B
 252+ 0000 ~                        ld a,register
 253+ 0000 ~                        out (c),a
 254+ 0000 ~                        inc b
 255+ 0000 ~                        in a,(c)
 256+ 0000                          ENDM
 257+ 0000
# file closed: ./Hardware/register_defines.asm
  33  0000                                      INCLUDE "./Layer2Graphics/layer2_defines.asm"
# file opened: ./Layer2Graphics/layer2_defines.asm
   1+ 0000
   2+ 0000
   3+ 0000              LAYER2_SHIFTED_SCREEN_TOP  	 equ 0
   4+ 0000              LAYER2_SHIFTED_SCREEN_MIDDLE equ $40
   5+ 0000              LAYER2_SHIFTED_SCREEN_BOTTOM equ $80
   6+ 0000
   7+ 0000              ; note hi byte is not decoded on DMA port so can out OUTIR
   8+ 0000
   9+ 0000              IO_SPRITE_SLOT_PORT 		 equ 12347
  10+ 0000              IO_SPRITE_PATTERN_PORT       equ 91
  11+ 0000              IO_SPRITE_ATTRIBUTES_PORT    equ 87
  12+ 0000
  13+ 0000              LAYER2_VISIBLE_MASK 		equ $02
  14+ 0000              ; DEBUG 0 for always write to primary 08 for double buffering
  15+ 0000                  IFDEF DOUBLEBUFFER
  16+ 0000 ~            LAYER2_SHADOW_SCREEN_MASK 	equ $08
  17+ 0000                  ELSE
  18+ 0000              LAYER2_SHADOW_SCREEN_MASK 	equ $00
  19+ 0000                  ENDIF
  20+ 0000              LAYER2_READ_ENABLE_MASK 	equ %00000100
  21+ 0000              LAYER2_WRITE_ENABLE_MASK 	equ %00000001
  22+ 0000              LAYER2_READ_WRITE_MASK      equ %00000101
  23+ 0000              LAYER2_SCREEN_SECTION_MASK 	equ $03
  24+ 0000              LAYER2_SCREEN_SECTION_SHIFT equ 6
  25+ 0000
  26+ 0000              LAYER2_DISABLE_MEM_WRITE    equ %11111110
  27+ 0000              LAYER2_DISABLE_MEM_READ     equ %11111011
  28+ 0000              LAYER2_DISABLE_MEM_ACCESS   equ %11111010
  29+ 0000
  30+ 0000              LAYER2_SCREEN_BANK1          equ 8
  31+ 0000              LAYER2_SCREEN_BANK2          equ 9
  32+ 0000              LAYER2_SCREEN_BANK3          equ 10
  33+ 0000              LAYER2_SCREEN_BANK4          equ 11     ; used by 320 and 640 mode
  34+ 0000              LAYER2_SCREEN_BANK5          equ 12     ; used by 320 and 640 mode
  35+ 0000              LAYER2_SHADOW_BANK1          equ 13
  36+ 0000              LAYER2_SHADOW_BANK2          equ 14
  37+ 0000              LAYER2_SHADOW_BANK3          equ 15
  38+ 0000              LAYER2_SHADOW_BANK4          equ 16     ; used by 320 and 640 mode
  39+ 0000              LAYER2_SHADOW_BANK5          equ 17     ; used by 320 and 640 mode
  40+ 0000
  41+ 0000              SCREEN_HEIGHT 				 equ 192
  42+ 0000              SCREEN_RAM_BASE				 equ $0000
  43+ 0000              SCREEN_HOZ_MIN_PIX		     equ 10
  44+ 0000
  45+ 0000              SPRITES_VISIBLE_MASK         equ $01
  46+ 0000              SPRITES_ON_BORDER_MASK       equ $02
  47+ 0000              LAYER_PRIORITIES_MASK        equ $07
  48+ 0000              LORES_MODE_MASK              equ $80
  49+ 0000              LAYER_PRIORITIES_SHIFT       equ 2
  50+ 0000
  51+ 0000              LAYER_PRIORITIES_S_L_U 		equ 0
  52+ 0000              LAYER_PRIORITIES_L_S_U 		equ 1
  53+ 0000              LAYER_PRIORITIES_S_U_L  	equ 2
  54+ 0000              LAYER_PRIORITIES_L_U_S 		equ 3
  55+ 0000              LAYER_PRIORITIES_U_S_L 		equ 4
  56+ 0000              LAYER_PRIORITIES_U_L_S 		equ 5
  57+ 0000
  58+ 0000              DMA_WRO_BLOCK_PORTA_A2B_XFR  equ $7D
  59+ 0000              DMA_WRO_BLOCK_PORTA_B2A_XFR  equ $79
  60+ 0000              DMA_WR1_P1FIXED_MEMORY       equ $24
  61+ 0000              DMA_WR1_P1DEC_MEMORY         equ $04
  62+ 0000              DMA_WR1_P1INC_MEMORY         equ $14
  63+ 0000              DMA_WR2_P2FIXED_MEMORY       equ $20
  64+ 0000              DMA_WR2_P2DEC_MEMORY         equ $00
  65+ 0000              DMA_WR2_P2INC_MEMORY         equ $10
  66+ 0000              DMA_WR4_CONT_MODE            equ $AD
  67+ 0000              DMA_WR4_BURST_MODE           equ $CD
  68+ 0000              DMA_RESET                    equ $c3
  69+ 0000              DMA_RESET_PORT_A_TIMING      equ $c7
  70+ 0000              DMA_RESET_PORT_B_TIMING      equ $cb
  71+ 0000              DMA_LOAD                     equ $cf
  72+ 0000              DMA_CONTINUE                 equ $d3
  73+ 0000              DMA_DISABLE_INTERUPTS        equ $af
  74+ 0000              DMA_ENABLE_INTERUPTS         equ $ab
  75+ 0000              DMA_RESET_DISABLE_INTERUPTS  equ $a3
  76+ 0000              DMA_ENABLE_AFTER_RETI        equ $b7
  77+ 0000              DMA_READ_STATUS_BYTE         equ $bf
  78+ 0000              DMA_REINIT_STATUS_BYTE       equ $8b
  79+ 0000              DMA_START_READ_SEQUENCE      equ $a7
  80+ 0000              DMA_FORCE_READY              equ $b3
  81+ 0000              DMA_STOP_AT_END			     equ $82
  82+ 0000              DMA_DISABLE                  equ $83
  83+ 0000              DMA_ENABLE                   equ $87
  84+ 0000              DMA_WRITE_REGISTER_COMMAND   equ $bb
  85+ 0000              DMA_BURST                    equ $cd
  86+ 0000              DMA_CONTINUOUS               equ $ad
  87+ 0000              ZXN_DMA_PORT                 equ $6b
  88+ 0000
  89+ 0000
  90+ 0000              COLOUR_TRANSPARENT			 equ $E3
  91+ 0000
  92+ 0000
  93+ 0000
  94+ 0000
# file closed: ./Layer2Graphics/layer2_defines.asm
  34  0000                                      INCLUDE	"./Hardware/memory_bank_defines.asm"
# file opened: ./Hardware/memory_bank_defines.asm
   1+ 0000
   2+ 0000              membanksize			    equ	$1FFF
   3+ 0000
   4+ 0000              StartOfBank     	    equ $0000
   5+ 0000
   6+ 0000              membank0 			    equ $0000
   7+ 0000              dmaCopySrcAddr		    equ	$0000
   8+ 0000              MathsTablesAddr         equ $0000
   9+ 0000              membank1 			    equ $2000
  10+ 0000              membank2 			    equ $4000
  11+ 0000              membank3 			    equ $6000
  12+ 0000              membank4 			    equ $8000
  13+ 0000              membank5 			    equ $a000
  14+ 0000              membank6 			    equ $c000
  15+ 0000              ScreenBank              equ $c000
  16+ 0000              MenuGalChtAddr          equ $c000
  17+ 0000              MenuEquipSAddr          equ $c000
  18+ 0000              MenuInventAddr          equ $c000
  19+ 0000              MenuMarketAddr          equ $c000
  20+ 0000              DispMarketAddr          equ $c000
  21+ 0000              MenuShrChtAddr          equ $c000
  22+ 0000              MenuStatusAddr          equ $c000
  23+ 0000              MenuSystemAddr          equ $c000
  24+ 0000              ViewFrontAddr           equ $c000
  25+ 0000              SunBankAddr             equ $c000
  26+ 0000              PlanetBankAddr          equ $c000
  27+ 0000              UniverseBankAddr	    equ $c000
  28+ 0000              LaunchShipAddr          equ $c000
  29+ 0000              membank7 			    equ $e000
  30+ 0000              L1membankAddr   	    equ $e000
  31+ 0000              L2membankAddr   	    equ $e000
  32+ 0000              ShipModelsAddr	        equ $e000
  33+ 0000              SpritemembankAddr       equ $e000
  34+ 0000              ResetUniverseAddr       equ $e000
  35+ 0000              StockTableAddr	        equ $e000
  36+ 0000              CommanderAddr           equ $e000
  37+ 0000              LAYER2Addr              equ $e000
  38+ 0000              LAYER1Addr              equ $e000
  39+ 0000              SPRITEAddr              equ $e000
  40+ 0000              ConsoleImageAddr        equ $e000
  41+ 0000              GalaxyDataAddr          equ $e000
  42+ 0000              SoundAddr               equ $e000
  43+ 0000
  44+ 0000              EXSDOSMMU0              equ MMU_SLOT_0_REGISTER
  45+ 0000              MathsTablesMMU          equ MMU_SLOT_0_REGISTER
  46+ 0000              ShipReadMMU             equ MMU_SLOT_0_REGISTER
  47+ 0000              DMACpySourceMMU		    equ	MMU_SLOT_0_REGISTER
  48+ 0000              EXSDOSMMU1              equ MMU_SLOT_1_REGISTER
  49+ 0000              SunMMU 		            equ MMU_SLOT_6_REGISTER
  50+ 0000              PlanetMMU 		        equ MMU_SLOT_6_REGISTER
  51+ 0000              UniverseMMU 		    equ MMU_SLOT_6_REGISTER
  52+ 0000              ScreenBankMMU           equ MMU_SLOT_6_REGISTER
  53+ 0000              MenuEquipSMMU           equ MMU_SLOT_6_REGISTER
  54+ 0000              MenuShrChtMMU           equ MMU_SLOT_6_REGISTER
  55+ 0000              MenuGalChtMMU           equ MMU_SLOT_6_REGISTER
  56+ 0000              MenuInventMMU           equ MMU_SLOT_6_REGISTER
  57+ 0000              MenuSystemMMU           equ MMU_SLOT_6_REGISTER
  58+ 0000              MenuMarketMMU           equ MMU_SLOT_6_REGISTER
  59+ 0000              DispMarketMMU           equ MMU_SLOT_6_REGISTER
  60+ 0000              MenuStatusMMU           equ MMU_SLOT_6_REGISTER
  61+ 0000              LaunchShipMMU           equ MMU_SLOT_6_REGISTER
  62+ 0000              L1memMMU       		    equ MMU_SLOT_7_REGISTER
  63+ 0000              L2memMMU       		    equ MMU_SLOT_7_REGISTER
  64+ 0000              SpritememMMU   		    equ MMU_SLOT_7_REGISTER
  65+ 0000              ShipModelMMU  		    equ MMU_SLOT_7_REGISTER
  66+ 0000              ResetUniverseMMU	    equ MMU_SLOT_7_REGISTER
  67+ 0000              CommanderMMU	        equ MMU_SLOT_7_REGISTER
  68+ 0000              StockTableMMU		    equ MMU_SLOT_7_REGISTER
  69+ 0000              ConsoleImageDataMMU	    equ MMU_SLOT_7_REGISTER
  70+ 0000              GalaxyDataMMU	        equ MMU_SLOT_7_REGISTER
  71+ 0000              SoundMMU                equ MMU_SLOT_7_REGISTER
  72+ 0000
  73+ 0000              ; banks 8 to 17 are reserved for layer 2 memory
  74+ 0000              BankResetUniv           equ 49
  75+ 0000              BankMenuShrCht          equ 50
  76+ 0000              BankMenuGalCht          equ 51
  77+ 0000              BankMenuInvent          equ 52
  78+ 0000              BankMenuSystem          equ 53
  79+ 0000              BankMenuMarket          equ 54
  80+ 0000              BankStockTable          equ 55
  81+ 0000              BankCommander           equ 56
  82+ 0000              BankLAYER2              equ 57
  83+ 0000              BankLAYER1              equ 58
  84+ 0000              BankShipModels1         equ 59
  85+ 0000              BankSPRITE              equ 60
  86+ 0000              BankConsole             equ 61
  87+ 0000              BankFrontView           equ 62
  88+ 0000              BankMenuStatus          equ 63
  89+ 0000              BankMenuEquipS          equ 64
  90+ 0000              BankLaunchShip          equ 65
  91+ 0000              BankDispMarket          equ 66
  92+ 0000              BankShipModels2         equ 67
  93+ 0000              BankShipModels3         equ 68
  94+ 0000              BankShipModels4         equ 69
  95+ 0000
  96+ 0000              BankUNIVDATA0           equ 70
  97+ 0000              BankUNIVDATA1           equ 71
  98+ 0000              BankUNIVDATA2           equ 72
  99+ 0000              BankUNIVDATA3           equ 73
 100+ 0000              BankUNIVDATA4           equ 74
 101+ 0000              BankUNIVDATA5           equ 75
 102+ 0000              BankUNIVDATA6           equ 76
 103+ 0000              BankUNIVDATA7           equ 77
 104+ 0000              BankUNIVDATA8           equ 78
 105+ 0000              BankUNIVDATA9           equ 79
 106+ 0000              BankUNIVDATA10          equ 80
 107+ 0000              BankUNIVDATA11          equ 81
 108+ 0000              BankUNIVDATA12          equ 82
 109+ 0000              BankSunData             equ 83
 110+ 0000              BankPlanetData          equ 84
 111+ 0000
 112+ 0000              BankGalaxyData0         equ 91
 113+ 0000              BankGalaxyData1         equ 92
 114+ 0000              BankGalaxyData2         equ 93
 115+ 0000              BankGalaxyData3         equ 94
 116+ 0000              BankGalaxyData4         equ 95
 117+ 0000              BankGalaxyData5         equ 96
 118+ 0000              BankGalaxyData6         equ 97
 119+ 0000              BankGalaxyData7         equ 98
 120+ 0000
 121+ 0000              BankMathsTables         equ 99
 122+ 0000              BankSound               equ 100
 123+ 0000
 124+ 0000              BankROM                 equ 255
 125+ 0000
# file closed: ./Hardware/memory_bank_defines.asm
  35  0000                                      INCLUDE "./Hardware/screen_equates.asm"
# file opened: ./Hardware/screen_equates.asm
   1+ 0000              ScreenHeight 		equ 192
   2+ 0000              ScreenLastRow       equ ScreenHeight -1
   3+ 0000              ScreenWidth  		equ 256
   4+ 0000              ScreenLastCol       equ ScreenWidth -1
   5+ 0000              ScreenHeightHalf	equ 96
   6+ 0000              ScreenWidthHalf  	equ 128
   7+ 0000              ScreenCenterY		equ 96
   8+ 0000              ScreenCenterX       equ 128
   9+ 0000              ViewHeight          equ 128
  10+ 0000              ViewHeightPlus1     equ 128+1
  11+ 0000              ViewLastRow       	equ ViewHeight -1
  12+ 0000              ViewWidth  			equ 256
  13+ 0000              ViewLastCol         equ ViewWidth -1
  14+ 0000              ViewHeightHalf      equ 63
  15+ 0000              ViewWidthHalf       equ 127
  16+ 0000              ViewCenterY         equ 64
  17+ 0000              ViewCenterX         equ 128
  18+ 0000              ShipColour			equ $FF		; place holder for debugging TODO
  19+ 0000              ScreenL1Bottom      equ $5000
  20+ 0000              ScreenL1BottomLen   equ 32 * 8 * 8
  21+ 0000              ScreenL1AttrBtm     equ $5A00
  22+ 0000              ScreenL1AttrBtmLen  equ 32 * 8
  23+ 0000
# file closed: ./Hardware/screen_equates.asm
  36  0000                                      INCLUDE "./Data/ShipModelEquates.asm"
# file opened: ./Data/ShipModelEquates.asm
   1+ 0000              ScoopDebrisOffset	        equ	0                               ; hull byte#0 high nibble is scoop info, lower nibble is debris spin info
   2+ 0000              MissileLockLoOffset	        equ 1
   3+ 0000              MissileLockHiOffset	        equ 2
   4+ 0000              EdgeAddyOffset		        equ 3
   5+ 0000              LineX4Offset		        equ 5
   6+ 0000              GunVertexOffset		        equ 6
   7+ 0000              ExplosionCtOffset	        equ 7
   8+ 0000              VertexCountOffset           equ 8
   9+ 0000              VertexCtX6Offset	        equ 9
  10+ 0000              EdgeCountOffset		        equ 10
  11+ 0000              BountyLoOffset		        equ 11
  12+ 0000              BountyHiOffset		        equ 12
  13+ 0000              FaceCtX4Offset		        equ 13
  14+ 0000              DotOffset			        equ 14
  15+ 0000              EnergyOffset		        equ 15
  16+ 0000              SpeedOffset			        equ 16
  17+ 0000              FaceAddyOffset		        equ 17
  18+ 0000              QOffset				        equ 19
  19+ 0000              LaserOffset			        equ 20
  20+ 0000              VerticiesAddyOffset         equ 21
  21+ 0000              ShipTypeOffset              equ 23
  22+ 0000              ShipNewBitsOffset           equ 24
  23+ 0000              ShipAIFlagsOffset           equ 25
  24+ 0000              ShipECMFittedChanceOffset   equ 26
  25+ 0000              ShipSolidFlagOffset         equ 27 ; Intially for non cargo these will be garbage
  26+ 0000              ShipSolidFillOffset         equ 28
  27+ 0000              ShipSolidLenOffset          equ 29
  28+ 0000              ShipDataLength              equ ShipECMFittedChanceOffset+1
  29+ 0000
  30+ 0000              CobraTablePointer           equ 43
  31+ 0000              ;29 faulty
  32+ 0000              BankThreshold               equ 16
  33+ 0000
  34+ 0000              ShipTableALast              equ 23
  35+ 0000              ShipTableBLast              equ 39
  36+ 0000              ShipTableCLast              equ 55
  37+ 0000
# file closed: ./Data/ShipModelEquates.asm
  37  0000                                      INCLUDE "./Menus/clear_screen_inline_no_double_buffer.asm"
# file opened: ./Menus/clear_screen_inline_no_double_buffer.asm
   1+ 0000              InitNoDoubleBuffer:         MACRO
   2+ 0000 ~                                        MMUSelectLayer1
   3+ 0000 ~                                        call	l1_cls
   4+ 0000 ~                                        ld		a,7
   5+ 0000 ~                                        call	l1_attr_cls_to_a
   6+ 0000 ~                                        MMUSelectLayer2
   7+ 0000 ~                                        call    asm_l2_double_buffer_off
   8+ 0000 ~                                        call	l2_cls	; Get some space
   9+ 0000 ~                                        MMUSelectSpriteBank
  10+ 0000 ~                                        call    sprite_cls_cursors
  11+ 0000                                          ENDM
  12+ 0000
  13+ 0000
# file closed: ./Menus/clear_screen_inline_no_double_buffer.asm
  38  0000                                      INCLUDE "./Macros/graphicsMacros.asm"
# file opened: ./Macros/graphicsMacros.asm
   1+ 0000              ; General Graphics macros
   2+ 0000              DoubleBufferIfPossible: MACRO
   3+ 0000 ~                                    IFDEF DOUBLEBUFFER
   4+ 0000 ~                                        MMUSelectLayer2
   5+ 0000 ~                                        call  l2_cls
   6+ 0000 ~                                        call  l2_flip_buffers
   7+ 0000 ~                                    ENDIF
   8+ 0000                                      ENDM
   9+ 0000
  10+ 0000              DoubleBuffer320IfPossible: MACRO
  11+ 0000 ~                                    IFDEF DOUBLEBUFFER
  12+ 0000 ~                                        MMUSelectLayer2
  13+ 0000 ~                                        call  l2_320_cls
  14+ 0000 ~                                        call  l2_flip_buffers
  15+ 0000 ~                                    ENDIF
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              DoubleBuffer640IfPossible: MACRO
  19+ 0000 ~                                    IFDEF DOUBLEBUFFER
  20+ 0000 ~                                        MMUSelectLayer2
  21+ 0000 ~                                        call  l2_640_cls
  22+ 0000 ~                                        call  l2_flip_buffers
  23+ 0000 ~                                    ENDIF
  24+ 0000                                      ENDM
  25+ 0000
# file closed: ./Macros/graphicsMacros.asm
  39  0000                                      INCLUDE "./Macros/callMacros.asm"
# file opened: ./Macros/callMacros.asm
   1+ 0000
   2+ 0000              CallIfAEqNusng:         MACRO   reg,target
   3+ 0000 ~                                    cp      reg
   4+ 0000 ~                                    call	z,target
   5+ 0000                                      ENDM
   6+ 0000
   7+ 0000              CallIfAGTENusng:        MACRO   reg,target
   8+ 0000 ~                                    cp      reg
   9+ 0000 ~                                    call	nc,target
  10+ 0000                                      ENDM
  11+ 0000
  12+ 0000              CallIfAGTEMemusng:      MACRO   reg,target
  13+ 0000 ~                                    ld      hl,reg
  14+ 0000 ~                                    cp      (hl)
  15+ 0000 ~                                    call	nc,target
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              CallIfALTMemusng:       MACRO   reg,target
  19+ 0000 ~                                    ld      hl,reg
  20+ 0000 ~                                    cp      (hl)
  21+ 0000 ~                                    call	c,target
  22+ 0000                                      ENDM
  23+ 0000
  24+ 0000              CallIfALTNusng:         MACRO   reg,target
  25+ 0000 ~                                    cp      reg
  26+ 0000 ~                                    call	c,target
  27+ 0000                                      ENDM
  28+ 0000
  29+ 0000              CallIfMemEqMemusng:     MACRO mem, address, target
  30+ 0000 ~                                    ld      a,(mem)
  31+ 0000 ~                                    ld      hl,address
  32+ 0000 ~                                    cp      (hl)
  33+ 0000 ~                                    call    z,target
  34+ 0000                                      ENDM
  35+ 0000
  36+ 0000              CallIfMemEqNusng:       MACRO mem, value, target
  37+ 0000 ~                                    ld      a,(mem)
  38+ 0000 ~                                    cp      value
  39+ 0000 ~                                    call    z,target
  40+ 0000                                      ENDM
  41+ 0000
  42+ 0000
  43+ 0000              CallIfMemGTENusng:      MACRO mem, value, target
  44+ 0000 ~                                    ld      a,(mem)
  45+ 0000 ~                                    cp      value
  46+ 0000 ~                                    call    nc,target
  47+ 0000                                      ENDM
  48+ 0000
  49+ 0000              CallIfMemTrue:          MACRO mem, target
  50+ 0000 ~                                    ld      a,(mem)
  51+ 0000 ~                                    and     a
  52+ 0000 ~                                    call    z, target
  53+ 0000                                      ENDM
  54+ 0000
  55+ 0000              CallIfMemFalse:         MACRO mem, target
  56+ 0000 ~                                    ld      a,(mem)
  57+ 0000 ~                                    and     a
  58+ 0000 ~                                    call    nz, target
  59+ 0000                                      ENDM
  60+ 0000
  61+ 0000              CallIfMemZero:          MACRO mem, target
  62+ 0000 ~                                    ld      a,(mem)
  63+ 0000 ~                                    and     a
  64+ 0000 ~                                    call    z, target
  65+ 0000                                      ENDM
  66+ 0000
  67+ 0000              CallIfMemNotZero:       MACRO mem, target
  68+ 0000 ~                                    ld      a,(mem)
  69+ 0000 ~                                    and     a
  70+ 0000 ~                                    call    nz, target
  71+ 0000                                      ENDM
  72+ 0000              CallIfATrue:            MACRO target
  73+ 0000 ~                                    and     a
  74+ 0000 ~                                    call    z, target
  75+ 0000                                      ENDM
  76+ 0000
  77+ 0000              CallIfAFalse:           MACRO target
  78+ 0000 ~                                    and     a
  79+ 0000 ~                                    call    nz, target
  80+ 0000                                      ENDM
  81+ 0000
  82+ 0000              CallIfAZero:            MACRO target
  83+ 0000 ~                                    and     a
  84+ 0000 ~                                    call    z, target
  85+ 0000                                      ENDM
  86+ 0000
  87+ 0000              CallIfANotZero:         MACRO target
  88+ 0000 ~                                    and     a
  89+ 0000 ~                                    call    nz, target
  90+ 0000                                      ENDM
# file closed: ./Macros/callMacros.asm
  40  0000                                      INCLUDE "./Macros/carryFlagMacros.asm"
# file opened: ./Macros/carryFlagMacros.asm
   1+ 0000
   2+ 0000              SetCarryFlag:           MACRO
   3+ 0000 ~                                    scf
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              ClearCarryFlag:	        MACRO
   7+ 0000 ~                                    or a
   8+ 0000                                      ENDM
   9+ 0000
  10+ 0000              FlipCarryFlag:          MACRO
  11+ 0000 ~                                    ccf
  12+ 0000                                      ENDM
  13+ 0000
# file closed: ./Macros/carryFlagMacros.asm
  41  0000                                      INCLUDE "./Macros/CopyByteMacros.asm"
# file opened: ./Macros/CopyByteMacros.asm
   1+ 0000              CopyByteAtHLixToA:		MACRO memloc
   2+ 0000 ~            						ex          de,hl                               ; save hl
   3+ 0000 ~            						ld          hl,memloc
   4+ 0000 ~            						add         hl,a
   5+ 0000 ~            						ld          a,(hl)                              ; get XX2[x]
   6+ 0000 ~            						ex          de,hl                               ; get hl back as we need it in loop
   7+ 0000              						ENDM
   8+ 0000
   9+ 0000              ; Increments IYL
  10+ 0000              ; Increments IHL
  11+ 0000              ; Gets value at hl and loads into Parameter 1 address
  12+ 0000
  13+ 0000              CopyByteAtNextHLiyl: 	MACRO memloc
  14+ 0000 ~            						inc         iyl                                 ;
  15+ 0000 ~            						inc         hl                                  ; vertex byte#1
  16+ 0000 ~            						ld          a,(hl)                              ;
  17+ 0000 ~            						ld          (memloc),a                     ; XX15+2 = (V),Y
  18+ 0000              						ENDM
  19+ 0000
  20+ 0000              ;------------------------------------------------------------------------------------------------------------------------------
  21+ 0000              CopyByteAtNextHL:   MACRO targetaddr
  22+ 0000 ~                                inc         hl                                  ; vertex byte#1
  23+ 0000 ~                                ld          a,(hl)                              ;
  24+ 0000 ~                                ld          (targetaddr),a                     ; SunXX15+2 = (V),Y
  25+ 0000                                  ENDM
# file closed: ./Macros/CopyByteMacros.asm
  42  0000                                      INCLUDE "./Macros/ldCopyMacros.asm"
# file opened: ./Macros/ldCopyMacros.asm
   1+ 0000              ZeroA:		            MACRO
   2+ 0000 ~                                    xor a
   3+ 0000                                      ENDM
   4+ 0000
   5+ 0000              SetATrue:               MACRO
   6+ 0000 ~                                    xor     a
   7+ 0000                                      ENDM
   8+ 0000
   9+ 0000              SetAFalse:              MACRO
  10+ 0000 ~                                    ld      a,$FF
  11+ 0000                                      ENDM
  12+ 0000
  13+ 0000              SetMemFalse             MACRO   mem
  14+ 0000 ~                                    ld      a,$FF
  15+ 0000 ~                                    ld      (mem),a
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              SetMemTrue              MACRO   mem
  19+ 0000 ~                                    xor     a
  20+ 0000 ~                                    ld      (mem),a
  21+ 0000                                      ENDM
  22+ 0000
  23+ 0000              SetMemZero:             MACRO   mem
  24+ 0000 ~                                    xor     a
  25+ 0000 ~                                    ld      (mem),a
  26+ 0000                                      ENDM
  27+ 0000
  28+ 0000              SetMemToN:              MACRO   mem,value
  29+ 0000 ~                                    ld      a,value
  30+ 0000 ~                                    ld      (mem),a
  31+ 0000                                      ENDM
  32+ 0000
  33+ 0000              ldCopyStringLen:        MACRO   source, target, strlen
  34+ 0000 ~                                    ld      hl,source
  35+ 0000 ~                                    ld      de, target
  36+ 0000 ~                                    ld      bc, strlen
  37+ 0000 ~                                    ldir
  38+ 0000                                      ENDM
  39+ 0000
  40+ 0000              ldCopyTextAtHLtoDE:     MACRO
  41+ 0000 ~            .CopyLoop:              ld      a,(hl)
  42+ 0000 ~                                    ld      (de),a
  43+ 0000 ~                                    cp      0
  44+ 0000 ~                                    jp      z,.DoneCopy
  45+ 0000 ~                                    inc     hl
  46+ 0000 ~                                    inc     de
  47+ 0000 ~                                    jr      .CopyLoop
  48+ 0000 ~            .DoneCopy:
  49+ 0000                                      ENDM
  50+ 0000
  51+ 0000              ldClearTextLoop:        MACRO   TextSize
  52+ 0000 ~                                    ld      b,a
  53+ 0000 ~                                    ld      a,TextSize
  54+ 0000 ~            .ClearLoop:             ld      (hl),a
  55+ 0000 ~                                    inc     hl
  56+ 0000 ~                                    djnz    .ClearLoop
  57+ 0000                                      ENDM
  58+ 0000
  59+ 0000              ldCopyByte:             MACRO memfrom, memto
  60+ 0000 ~                                    ld       a,(memfrom)
  61+ 0000 ~                                    ld       (memto),a
  62+ 0000                                      ENDM
  63+ 0000
  64+ 0000
  65+ 0000              ldCopyByteABS:          MACRO memfrom, memto
  66+ 0000 ~                                    ld       a,(memfrom)
  67+ 0000 ~                                    and		$7F
  68+ 0000 ~                                    ld       (memto),a
  69+ 0000                                      ENDM
  70+ 0000
  71+ 0000              ldAtHLtoMem:            MACRO   memto
  72+ 0000 ~                                    ld      a,(hl)
  73+ 0000 ~                                    ld      (memto),a
  74+ 0000                                      ENDM
  75+ 0000
  76+ 0000              ldCopy2Byte             MACRO  memfrom, memto
  77+ 0000 ~                                    ld       hl,(memfrom)
  78+ 0000 ~                                    ld       (memto),hl
  79+ 0000                                      ENDM
  80+ 0000
  81+ 0000              ldWriteConst            MACRO  memfrom, memto
  82+ 0000 ~                                    ld       a,memfrom
  83+ 0000 ~                                    ld       (memto),a
  84+ 0000                                      ENDM
  85+ 0000
  86+ 0000              ldWriteZero             MACRO  memto
  87+ 0000 ~                                    xor      a
  88+ 0000 ~                                    ld       (memto),a
  89+ 0000                                      ENDM
  90+ 0000
  91+ 0000              ldIXLaFromN:	        MACRO memfrom
  92+ 0000 ~                                    ld		a,(memfrom)
  93+ 0000 ~                                    ld		ixl,a
  94+ 0000                                      ENDM
  95+ 0000
  96+ 0000              ldIXHaFromN:	        MACRO memfrom
  97+ 0000 ~                                    ld		a,(memfrom)
  98+ 0000 ~                                    ld		ixh,a
  99+ 0000                                      ENDM
 100+ 0000
 101+ 0000              ldIYLaFromN:	        MACRO memfrom
 102+ 0000 ~                                    ld		a,(memfrom)
 103+ 0000 ~                                    ld		iyl,a
 104+ 0000                                      ENDM
 105+ 0000
 106+ 0000              ldIYHaFromN:	        MACRO memfrom
 107+ 0000 ~                                    ld		a,(memfrom)
 108+ 0000 ~                                    ld		iyh,a
 109+ 0000                                      ENDM
 110+ 0000
 111+ 0000              ; Read a 32 bit value from address HL into BCDE
 112+ 0000              ldBCDEatHL:             MACRO
 113+ 0000 ~                                    ld      e,(hl)
 114+ 0000 ~                                    inc     hl
 115+ 0000 ~                                    ld      d,(hl)
 116+ 0000 ~                                    inc     hl
 117+ 0000 ~                                    ld      c,(hl)
 118+ 0000 ~                                    inc     hl
 119+ 0000 ~                                    ld      b,(hl)
 120+ 0000 ~                                    inc     hl
 121+ 0000                                      ENDM
 122+ 0000
 123+ 0000              ldBCatHL:               MACRO
 124+ 0000 ~                                    ld      c,(hl)
 125+ 0000 ~                                    inc     hl
 126+ 0000 ~                                    ld      b,(hl)
 127+ 0000 ~                                    inc     hl
 128+ 0000                                      ENDM
 129+ 0000
 130+ 0000              ldhlde:			        MACRO
 131+ 0000 ~                                    ld		h,d
 132+ 0000 ~                                    ld		l,e
 133+ 0000                                      ENDM
 134+ 0000
 135+ 0000              ldhlbc:			        MACRO
 136+ 0000 ~                                    ld		h,b
 137+ 0000 ~                                    ld		l,c
 138+ 0000                                      ENDM
 139+ 0000
 140+ 0000              ldbcde:			        MACRO
 141+ 0000 ~                                    ld		b,d
 142+ 0000 ~                                    ld		c,e
 143+ 0000                                      ENDM
 144+ 0000
 145+ 0000              lddebc:			        MACRO
 146+ 0000 ~                                    ld		d,b
 147+ 0000 ~                                    ld		e,c
 148+ 0000                                      ENDM
 149+ 0000
 150+ 0000              ldbchl:			        MACRO
 151+ 0000 ~                                    ld		b,h
 152+ 0000 ~                                    ld		c,l
 153+ 0000                                      ENDM
 154+ 0000
 155+ 0000              lddeiy:			        MACRO
 156+ 0000 ~                                    ld		d,iyh
 157+ 0000 ~                                    ld		e,iyl
 158+ 0000                                      ENDM
 159+ 0000
 160+ 0000              ldiyde:			        MACRO
 161+ 0000 ~                                    ld		iyh,d
 162+ 0000 ~                                    ld		iyl,e
 163+ 0000                                      ENDM
 164+ 0000
 165+ 0000
 166+ 0000              FourLDIInstrunctions:   MACRO
 167+ 0000 ~                                    ldi
 168+ 0000 ~                                    ldi
 169+ 0000 ~                                    ldi
 170+ 0000 ~                                    ldi
 171+ 0000                                      ENDM
 172+ 0000
 173+ 0000              FiveLDIInstrunctions:   MACRO
 174+ 0000 ~                                    ldi
 175+ 0000 ~                                    ldi
 176+ 0000 ~                                    ldi
 177+ 0000 ~                                    ldi
 178+ 0000 ~                                    ldi
 179+ 0000                                      ENDM
 180+ 0000
 181+ 0000              SixLDIInstrunctions:    MACRO
 182+ 0000 ~                                    ldi
 183+ 0000 ~                                    ldi
 184+ 0000 ~                                    ldi
 185+ 0000 ~                                    ldi
 186+ 0000 ~                                    ldi
 187+ 0000 ~                                    ldi
 188+ 0000                                      ENDM
 189+ 0000
 190+ 0000              EightLDIInstrunctions:  MACRO
 191+ 0000 ~            		                ldi
 192+ 0000 ~            		                ldi
 193+ 0000 ~            		                ldi
 194+ 0000 ~            		                ldi
 195+ 0000 ~            		                ldi
 196+ 0000 ~            		                ldi
 197+ 0000 ~            		                ldi
 198+ 0000 ~            		                ldi
 199+ 0000                                      ENDM
 200+ 0000
 201+ 0000              NineLDIInstrunctions:  MACRO
 202+ 0000 ~            		                ldi
 203+ 0000 ~            		                ldi
 204+ 0000 ~            		                ldi
 205+ 0000 ~            		                ldi
 206+ 0000 ~            		                ldi
 207+ 0000 ~            		                ldi
 208+ 0000 ~            		                ldi
 209+ 0000 ~            		                ldi
 210+ 0000 ~            		                ldi
 211+ 0000                                      ENDM
# file closed: ./Macros/ldCopyMacros.asm
  43  0000                                      INCLUDE "./Macros/ldIndexedMacros.asm"
# file opened: ./Macros/ldIndexedMacros.asm
   1+ 0000              GetByteAInTable:    MACRO table
   2+ 0000 ~                                ld          hl,table
   3+ 0000 ~                                add         hl,a
   4+ 0000 ~                                ld          a,(hl)
   5+ 0000                                  ENDM
   6+ 0000
   7+ 0000              HLWordAInTable:     MACRO table
   8+ 0000 ~                                ld          hl,table
   9+ 0000 ~                                sla         a
  10+ 0000 ~                                add         hl,a
  11+ 0000 ~                                ld          a,(hl)
  12+ 0000 ~                                inc         hl
  13+ 0000 ~                                ld          h,(hl)
  14+ 0000 ~                                ld          l,a
  15+ 0000                                  ENDM
  16+ 0000
  17+ 0000
  18+ 0000              ldAToHLixl:			MACRO value
  19+ 0000 ~            					ld          hl,value
  20+ 0000 ~            					ex          af,af'
  21+ 0000 ~            					ld          a,ixl
  22+ 0000 ~            					add         hl,a
  23+ 0000 ~            					ex          af,af'
  24+ 0000 ~            					ld          (hl),a
  25+ 0000              					ENDM
  26+ 0000
  27+ 0000              ldAToHLiyl:			MACRO value
  28+ 0000 ~            					ld          hl,value
  29+ 0000 ~            					ex          af,af'
  30+ 0000 ~            					ld          a,iyl
  31+ 0000 ~            					add         hl,a
  32+ 0000 ~            					ex          af,af'
  33+ 0000 ~            					ld          (hl),a
  34+ 0000              					ENDM
  35+ 0000
  36+ 0000
  37+ 0000              ldHLixlToA:         MACRO value
  38+ 0000 ~                                ld          hl,value
  39+ 0000 ~                                ex          af,af'
  40+ 0000 ~                                ld          a,ixl
  41+ 0000 ~                                add         hl,a
  42+ 0000 ~                                ld          a,(hl)
  43+ 0000                                  ENDM
  44+ 0000
  45+ 0000              ldHLiylToA:         MACRO value
  46+ 0000 ~                                ld          hl,value
  47+ 0000 ~                                ex          af,af'
  48+ 0000 ~                                ld          a,iyl
  49+ 0000 ~                                add         hl,a
  50+ 0000 ~                                ld          a,(hl)
  51+ 0000                                  ENDM
  52+ 0000
  53+ 0000              ldHLIdxAToA:        MACRO value
  54+ 0000 ~                                ld          hl,value
  55+ 0000 ~                                add         hl,a
  56+ 0000 ~                                ld          a,(hl)
  57+ 0000                                  ENDM
  58+ 0000
  59+ 0000              HLEquAddrAtHLPlusA: MACRO
  60+ 0000 ~                                sla         a
  61+ 0000 ~                                add         hl,a
  62+ 0000 ~                                ld          a,(hl)
  63+ 0000 ~                                inc         hl
  64+ 0000 ~                                ld          h,(hl)
  65+ 0000 ~                                ld          l,a
  66+ 0000                                  ENDM
# file closed: ./Macros/ldIndexedMacros.asm
  44  0000                                      INCLUDE "./Macros/jumpMacros.asm"
# file opened: ./Macros/jumpMacros.asm
   1+ 0000              JumpIfPositive:	        MACRO target
   2+ 0000 ~                                    jp		p, target
   3+ 0000                                      ENDM
   4+ 0000
   5+ 0000              JumpIfNegative:	        MACRO target
   6+ 0000 ~                                    jp		m, target
   7+ 0000                                      ENDM
   8+ 0000
   9+ 0000
  10+ 0000              JumpIfUnderflow:	    MACRO target
  11+ 0000 ~                                    jp		po, target
  12+ 0000                                      ENDM
  13+ 0000
  14+ 0000              JumpIfOverflow:	        MACRO target
  15+ 0000 ~                                    jp		po, target
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000
  19+ 0000              JumpIfNotZero:	        MACRO target
  20+ 0000 ~                                    jp	nz,target
  21+ 0000                                      ENDM
  22+ 0000
  23+ 0000              JumpIfZero:	            MACRO target
  24+ 0000 ~                                    jp	z,target
  25+ 0000                                      ENDM
  26+ 0000
  27+ 0000              ;.. Bit routines
  28+ 0000              JumpOnLeadSignSet:      MACRO   reg, target
  29+ 0000 ~                                    ld      a,reg
  30+ 0000 ~                                    and     SignOnly8Bit
  31+ 0000 ~                                    jp      nz,target
  32+ 0000                                      ENDM
  33+ 0000
  34+ 0000              JumpOnLeadSignClear:    MACRO   reg, target
  35+ 0000 ~                                    ld      a,reg
  36+ 0000 ~                                    and     SignOnly8Bit
  37+ 0000 ~                                    jp      z,target
  38+ 0000                                      ENDM
  39+ 0000
  40+ 0000              JumpOnLeadSignSetA:     MACRO   target
  41+ 0000 ~                                    and     SignOnly8Bit
  42+ 0000 ~                                    jp      nz,target
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              JumpOnLeadSignClearA:   MACRO   target
  46+ 0000 ~                                    and     SignOnly8Bit
  47+ 0000 ~                                    jp      z,target
  48+ 0000                                      ENDM
  49+ 0000
  50+ 0000              JumpOnMemBitSet:        MACRO mem, bitnbr, target
  51+ 0000 ~                                    ld      a,(mem)
  52+ 0000 ~                                    bit 	bitnbr,a
  53+ 0000 ~                                    jp      nz,target
  54+ 0000                                      ENDM
  55+ 0000
  56+ 0000              JumpOnMemBitClear:      MACRO mem, bitnbr, target
  57+ 0000 ~                                    ld      a,(mem)
  58+ 0000 ~                                    bit 	bitnbr,a
  59+ 0000 ~                                    jp      z,target
  60+ 0000                                      ENDM
  61+ 0000
  62+ 0000
  63+ 0000              JumpOnABitSet:          MACRO   bitnbr, target
  64+ 0000 ~                                    bit 	bitnbr, a
  65+ 0000 ~                                    jp      nz,target
  66+ 0000                                      ENDM
  67+ 0000
  68+ 0000              JumpOnABitClear:        MACRO   bitnbr, target
  69+ 0000 ~                                    bit 	bitnbr, a
  70+ 0000 ~                                    jp      z,target
  71+ 0000                                      ENDM
  72+ 0000
  73+ 0000              JumpOnABit5Set:         MACRO   target
  74+ 0000 ~                                    and     Bit5Only
  75+ 0000 ~                                    jp      nz,target
  76+ 0000                                      ENDM
  77+ 0000
  78+ 0000              JumpOnABit5Clear:       MACRO   target
  79+ 0000 ~                                    and     Bit5Only
  80+ 0000 ~                                    jp      z,target
  81+ 0000                                      ENDM
  82+ 0000
  83+ 0000              JumpOnBitMaskSet:       MACRO   bitmask, target
  84+ 0000 ~                                    and     bitmask
  85+ 0000 ~                                    jp      nz,target
  86+ 0000                                      ENDM
  87+ 0000
  88+ 0000              JumpOnBitMaskClear:     MACRO   bitmask, target
  89+ 0000 ~                                    and     bitmask
  90+ 0000 ~                                    jp      z,target
  91+ 0000                                      ENDM
  92+ 0000
  93+ 0000              JumpOnMemBitMaskSet:    MACRO   mem, bitmask, target
  94+ 0000 ~                                    ld      a,(mem)
  95+ 0000 ~                                    and     bitmask
  96+ 0000 ~                                    jp      nz,target
  97+ 0000                                      ENDM
  98+ 0000
  99+ 0000              JumpOnMemBitMaskClear:  MACRO   mem, bitmask, target
 100+ 0000 ~                                    ld      a,(mem)
 101+ 0000 ~                                    and     bitmask
 102+ 0000 ~                                    jp      z,target
 103+ 0000                                      ENDM
 104+ 0000
 105+ 0000              JumpOnBitSet:           MACRO  reg, bitnbr, target
 106+ 0000 ~                                    bit 	bitnbr,reg
 107+ 0000 ~                                    jp      nz,target
 108+ 0000                                      ENDM
 109+ 0000
 110+ 0000              JumpOnBitClear:         MACRO  reg, bitnbr, target
 111+ 0000 ~                                    bit 	bitnbr,reg
 112+ 0000 ~                                    jp      z,target
 113+ 0000                                      ENDM
 114+ 0000
 115+ 0000              ; Comparison Routines
 116+ 0000              JumpIfAGTEusng:         MACRO
 117+ 0000 ~                                    jp		nc,target
 118+ 0000                                      ENDM
 119+ 0000
 120+ 0000              JumpIfAGTENusng:        MACRO reg,target
 121+ 0000 ~                                    cp     reg
 122+ 0000 ~                                    jp		nc,target
 123+ 0000                                      ENDM
 124+ 0000
 125+ 0000              JumpIfAGTEMemusng:      MACRO mem,target
 126+ 0000 ~                                    ld      hl,mem
 127+ 0000 ~                                    cp      (hl)
 128+ 0000 ~                                    jp		nc,target
 129+ 0000                                      ENDM
 130+ 0000
 131+ 0000              JumpIfALTMemusng:       MACRO mem,target
 132+ 0000 ~                                    ld      hl,mem
 133+ 0000 ~                                    cp      (hl)
 134+ 0000 ~                                    jp		c,target
 135+ 0000                                      ENDM
 136+ 0000
 137+ 0000              JumpIfMemGTENusng:      MACRO mem, value, target
 138+ 0000 ~                                    ld     a,(mem)
 139+ 0000 ~                                    cp     value
 140+ 0000 ~                                    jp	  nc,target
 141+ 0000                                      ENDM
 142+ 0000
 143+ 0000              JumpIfMemGTEMemusng:    MACRO mem, address, target
 144+ 0000 ~                                    ld   a,(mem)
 145+ 0000 ~                                    ld   hl,address
 146+ 0000 ~                                    cp   (hl)
 147+ 0000 ~                                    jp	  nc,target
 148+ 0000                                      ENDM
 149+ 0000
 150+ 0000              JumpIfMemEqMemusng:     MACRO mem, address, target
 151+ 0000 ~                                    ld   a,(mem)
 152+ 0000 ~                                    ld   hl,address
 153+ 0000 ~                                    cp   (hl)
 154+ 0000 ~                                    jp	  z,target
 155+ 0000                                      ENDM
 156+ 0000
 157+ 0000              JumpIfMemNeMemusng:     MACRO mem, address, target
 158+ 0000 ~                                    ld   a,(mem)
 159+ 0000 ~                                    ld   hl,address
 160+ 0000 ~                                    cp   (hl)
 161+ 0000 ~                                    jp	  nz,target
 162+ 0000                                      ENDM
 163+ 0000
 164+ 0000              JumpIfMemTrue:          MACRO mem, target
 165+ 0000 ~                                    ld      a,(mem)
 166+ 0000 ~                                    and     a
 167+ 0000 ~                                    jp      z, target
 168+ 0000                                      ENDM
 169+ 0000
 170+ 0000              JumpIfMemFalse:         MACRO mem, target
 171+ 0000 ~                                    ld      a,(mem)
 172+ 0000 ~                                    and     a
 173+ 0000 ~                                    jp      nz, target
 174+ 0000                                      ENDM
 175+ 0000
 176+ 0000              JumpIfATrue:            MACRO target
 177+ 0000 ~                                    and     a
 178+ 0000 ~                                    jp      z, target
 179+ 0000                                      ENDM
 180+ 0000
 181+ 0000              JumpIfAFalse:           MACRO target
 182+ 0000 ~                                    and     a
 183+ 0000 ~                                    jp      nz, target
 184+ 0000                                      ENDM
 185+ 0000
 186+ 0000              JumpIfANotFalse:        MACRO target
 187+ 0000 ~                                    cp      $FF
 188+ 0000 ~                                    jp      nz, target
 189+ 0000                                      ENDM
 190+ 0000
 191+ 0000              JumpIfALTusng:          MACRO target
 192+ 0000 ~                                    jp		c,target
 193+ 0000                                      ENDM
 194+ 0000
 195+ 0000              JumpIfALTNusng:         MACRO value, target
 196+ 0000 ~                                    cp      value
 197+ 0000 ~                                    jp		c, target
 198+ 0000                                      ENDM
 199+ 0000
 200+ 0000              JumpIfMemLTNusng:       MACRO mem, value, target
 201+ 0000 ~                                    ld      a,(mem)
 202+ 0000 ~                                    cp      value
 203+ 0000 ~                                    jp	  c,target
 204+ 0000                                      ENDM
 205+ 0000
 206+ 0000              JumpIfMemLTMemusng:     MACRO mem, value, target
 207+ 0000 ~                                    ld    a,(mem)
 208+ 0000 ~                                    ld    hl,value
 209+ 0000 ~                                    cp    (hl)
 210+ 0000 ~                                    jp	  c,target
 211+ 0000                                      ENDM
 212+ 0000
 213+ 0000              JumpIfMemEqNusng:       MACRO mem,value,target
 214+ 0000 ~                                    ld  a,(mem)
 215+ 0000 ~                                    cp  value
 216+ 0000 ~                                    jp  z,target
 217+ 0000                                      ENDM
 218+ 0000
 219+ 0000              JumpIfMemNeNusng:       MACRO mem,value,target
 220+ 0000 ~                                    ld  a,(mem)
 221+ 0000 ~                                    cp  value
 222+ 0000 ~                                    jp  nz,target
 223+ 0000                                      ENDM
 224+ 0000
 225+ 0000              JumpIfMemZero:          MACRO mem,target
 226+ 0000 ~                                    ld  a,(mem)
 227+ 0000 ~                                    and a
 228+ 0000 ~                                    jp  z,target
 229+ 0000                                      ENDM
 230+ 0000
 231+ 0000              JumpIfMemNotZero:       MACRO mem,target
 232+ 0000 ~                                    ld  a,(mem)
 233+ 0000 ~                                    and a
 234+ 0000 ~                                    jp  nz,target
 235+ 0000                                      ENDM
 236+ 0000
 237+ 0000              JumpIfALTMemHLusng:     MACRO target
 238+ 0000 ~                                    cp    (hl)
 239+ 0000 ~                                    jp	  c,target
 240+ 0000                                      ENDM
 241+ 0000
 242+ 0000              JumpIfANENusng:         MACRO value, target
 243+ 0000 ~                                    cp     value
 244+ 0000 ~                                    jp      nz,target
 245+ 0000                                      ENDM
 246+ 0000
 247+ 0000              JumpIfANEquNusng:       MACRO value, target
 248+ 0000 ~                                    cp     value
 249+ 0000 ~                                    jp     z,target
 250+ 0000                                      ENDM
 251+ 0000
 252+ 0000              JumpIfANEMemusng:       MACRO  value, target
 253+ 0000 ~                                    ld    hl,value
 254+ 0000 ~                                    cp    (hl)
 255+ 0000 ~                                    jp      nz,target
 256+ 0000                                      ENDM
 257+ 0000
 258+ 0000              JumpIfAEqNusng:         MACRO value, target
 259+ 0000 ~                                    cp     value
 260+ 0000 ~                                    jp      z,target
 261+ 0000                                      ENDM
 262+ 0000
 263+ 0000              JumpIfAIsZero:	        MACRO target
 264+ 0000 ~                                    and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 265+ 0000 ~                                    jp	    z, target
 266+ 0000                                      ENDM
 267+ 0000
 268+ 0000              JumpIfRegIsNotZero:     MACRO   reg, target
 269+ 0000 ~                                    ld      a,reg
 270+ 0000 ~                                    and     a
 271+ 0000 ~                                    jp	    nz,target
 272+ 0000                                      ENDM
 273+ 0000
 274+ 0000              JumpIfAIsNotZero:       MACRO target
 275+ 0000 ~                                    and     a
 276+ 0000 ~                                    jp	    nz,target
 277+ 0000                                      ENDM
 278+ 0000
 279+ 0000              JumpIfMemIsNotZero:     MACRO value, target
 280+ 0000 ~                                    ld      a,(value)
 281+ 0000 ~                                    and     a
 282+ 0000 ~                                    jp	    nz,target
 283+ 0000                                      ENDM
 284+ 0000              IfResultZeroGoto:	    MACRO target
 285+ 0000 ~                                    jp	z,target
 286+ 0000                                      ENDM
 287+ 0000
 288+ 0000              IfResultNotZeroGoto:    MACRO target
 289+ 0000 ~                                    jp	nz,target
 290+ 0000                                      ENDM
 291+ 0000
# file closed: ./Macros/jumpMacros.asm
  45  0000                                      INCLUDE "./Macros/MathsMacros.asm"
# file opened: ./Macros/MathsMacros.asm
   1+ 0000
   2+ 0000              ABSa2c:                 MACRO
   3+ 0000 ~                                    bit     7,a
   4+ 0000 ~                                    jp      z,.DoneABSa
   5+ 0000 ~                                    neg
   6+ 0000 ~            .DoneABSa:
   7+ 0000                                      ENDM
   8+ 0000
   9+ 0000              DEEquSquareA:           MACRO
  10+ 0000 ~                                    ld  d,a
  11+ 0000 ~                                    ld  e,a
  12+ 0000 ~                                    mul de
  13+ 0000                                      ENDM
  14+ 0000
  15+ 0000              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
  16+ 0000 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
  17+ 0000 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
  18+ 0000 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
  19+ 0000 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
  20+ 0000 ~                                    xor $80                             ;
  21+ 0000 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
  22+ 0000 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
  23+ 0000 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
  24+ 0000 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
  25+ 0000 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
  26+ 0000 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
  27+ 0000                                      ENDM
  28+ 0000
  29+ 0000              SignedHLTo2C:           MACRO
  30+ 0000 ~                                    bit     7,h
  31+ 0000 ~                                    jr      z,.Done2c
  32+ 0000 ~                                    ld      a,h
  33+ 0000 ~                                    and     SignMask8Bit
  34+ 0000 ~                                    ld      h,a
  35+ 0000 ~                                    NegHL
  36+ 0000 ~            .Done2c:
  37+ 0000                                      ENDM
  38+ 0000
  39+ 0000              MemSignedTo2C:          MACRO   memfrom
  40+ 0000 ~                                    ld      hl,(memfrom)
  41+ 0000 ~                                    bit     7,h
  42+ 0000 ~                                    jr      z,.Done2c
  43+ 0000 ~                                    ld      a,h
  44+ 0000 ~                                    and     SignMask8Bit
  45+ 0000 ~                                    ld      h,a
  46+ 0000 ~            .Done2c:                ld      (memfrom),hl
  47+ 0000                                      ENDM
  48+ 0000
  49+ 0000
  50+ 0000                  ;returns result in H
  51+ 0000              EDiv10Inline:           MACRO
  52+ 0000 ~                                    ld      d,0
  53+ 0000 ~                                    ld      hl,de
  54+ 0000 ~                                    add     hl,hl
  55+ 0000 ~                                    add     hl,de
  56+ 0000 ~                                    add     hl,hl
  57+ 0000 ~                                    add     hl,hl
  58+ 0000 ~                                    add     hl,de
  59+ 0000 ~                                    add     hl,hl
  60+ 0000                                      ENDM
  61+ 0000
  62+ 0000              cpHLDE:                 MACRO
  63+ 0000 ~                                    push    hl
  64+ 0000 ~                                    and     a
  65+ 0000 ~                                    sbc     hl,de
  66+ 0000 ~                                    pop     hl
  67+ 0000                                      ENDM
  68+ 0000
  69+ 0000              cpABSDEHL:              MACRO
  70+ 0000 ~                                    push     hl,,de
  71+ 0000 ~                                    ld      a,h
  72+ 0000 ~                                    and     $7F
  73+ 0000 ~                                    ld      h,a
  74+ 0000 ~                                    ld      a,d
  75+ 0000 ~                                    and     $7F
  76+ 0000 ~                                    ld      d,a
  77+ 0000 ~                                    ex      de,hl
  78+ 0000 ~                                    sbc     hl,de
  79+ 0000 ~                                    pop     hl,,de
  80+ 0000                                      ENDM
  81+ 0000
  82+ 0000              ; Simple are they both the same setting z if they are
  83+ 0000              ; tehcicall this works but it measn the final ret z is alwys done
  84+ 0000              ; so jp needs to be to a target
  85+ 0000              cpHLEquDE:              MACRO   passedCheck
  86+ 0000 ~                                    ld      a,h
  87+ 0000 ~                                    cp      d
  88+ 0000 ~                                    jp      nz, passedCheck
  89+ 0000 ~                                    ld      a,l
  90+ 0000 ~                                    cp      e
  91+ 0000 ~            .NoTheSame:
  92+ 0000                                      ENDM
  93+ 0000
  94+ 0000              cpHLEquBC:              MACRO   passedCheck
  95+ 0000 ~                                    ld      a,h
  96+ 0000 ~                                    cp      b
  97+ 0000 ~                                    jp      nz, passedCheck
  98+ 0000 ~                                    ld      a,l
  99+ 0000 ~                                    cp      c
 100+ 0000 ~            .NoTheSame:
 101+ 0000                                      ENDM
 102+ 0000
 103+ 0000              cpDEEquBC:              MACRO   passedCheck
 104+ 0000 ~                                    ld      a,d
 105+ 0000 ~                                    cp      b
 106+ 0000 ~                                    jp      nz, passedCheck
 107+ 0000 ~                                    ld      a,e
 108+ 0000 ~                                    cp      c
 109+ 0000 ~            .NoTheSame:
 110+ 0000                                      ENDM
 111+ 0000              ; Simple version just sets carry if HL < DE reset, does an initial compare for z
 112+ 0000              cpHLDELeadSign:         MACRO
 113+ 0000 ~                                    ld      a,h
 114+ 0000 ~                                    cp      d
 115+ 0000 ~                                    jr      nz,.FullCompare
 116+ 0000 ~                                    ld      a,l
 117+ 0000 ~                                    cp      e
 118+ 0000 ~                                    ret     z
 119+ 0000 ~            .FullCompare:           ld      a,h
 120+ 0000 ~                                    xor     d
 121+ 0000 ~                                    and     $80
 122+ 0000 ~                                    jr      nz,.OppositeSigns   ; If opposite signs is a simple sign test
 123+ 0000 ~                                    ld      a,h                 ; same signs so a little simpler
 124+ 0000 ~                                    and     $80
 125+ 0000 ~                                    jp      z,cpHLDE            ; if h is positive then both are positive by here so just cpHLDE
 126+ 0000 ~                                    jp      cpABSDEHL           ; else we have to do ABScpDEHL
 127+ 0000 ~            .OppositeSigns:         ld      a,h
 128+ 0000 ~                                    and     $80
 129+ 0000 ~                                    and     $80
 130+ 0000 ~                                    jp      z,.HLGTDE
 131+ 0000 ~            .HLLTDE:                SetCarryFlag
 132+ 0000 ~                                    ret
 133+ 0000 ~            .HLGTDE:                ClearCarryFlag
 134+ 0000 ~                                    ret
 135+ 0000 ~
 136+ 0000 ~            ;Unsigned
 137+ 0000 ~            ;If HL == DE, then Z flag is set.
 138+ 0000 ~            ;If HL != DE, then Z flag is reset.
 139+ 0000 ~            ;If HL <  DE, then C flag is set.
 140+ 0000 ~            ;If HL >= DE, then C flag is reset.
 141+ 0000 ~            ;
 142+ 0000 ~            ;Signed
 143+ 0000 ~            ;If HL == DE, then Z flag is set.
 144+ 0000 ~            ;If HL != DE, then Z flag is reset.
 145+ 0000 ~            ;If HL <  DE, then S and P/V are different.
 146+ 0000 ~            ;If HL >= DE, then S and P/V are the same.
 147+ 0000 ~
 148+ 0000 ~
 149+ 0000 ~            N0equN1byN2div256:      MACRO param1,param2,param3
 150+ 0000 ~                                    ld      a,param3                        ;
 151+ 0000 ~                                    ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 152+ 0000 ~                                    ld      a,param2                        ; A = XX16 element
 153+ 0000 ~                                    ld      d,a
 154+ 0000 ~                                    mul
 155+ 0000 ~                                    ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 156+ 0000 ~                                    ld      (param1),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 157+ 0000                                      ENDM
 158+ 0000
 159+ 0000              AequN1xorN2:            MACRO  param1,param2
 160+ 0000 ~                                    ld      a,(param1)
 161+ 0000 ~                                    xor     param2
 162+ 0000                                      ENDM
 163+ 0000
 164+ 0000              SpeedMulAxis:           MACRO   speedreg, axis
 165+ 0000 ~                                    ld      e,speedreg
 166+ 0000 ~                                    ld      hl,(axis)
 167+ 0000 ~                                    ld      a,h
 168+ 0000 ~                                    ClearSignBitA
 169+ 0000 ~                                    ld      d,a
 170+ 0000 ~                                    mul     de
 171+ 0000 ~                                    ld      a,h
 172+ 0000 ~                                    SignBitOnlyA
 173+ 0000 ~                                    ld      b,a;ld      c,a
 174+ 0000 ~                                    ld      h,d;ld      e,d
 175+ 0000 ~                                    ld      c,0;ld      d,0
 176+ 0000                                      ENDM
 177+ 0000
 178+ 0000
 179+ 0000              AddSpeedToVert:         MACRO   vertex
 180+ 0000 ~                                    ld      de,(vertex+1)
 181+ 0000 ~                                    ld      a,(vertex)
 182+ 0000 ~                                    ld      l,a
 183+ 0000 ~                                    call    AddBCHtoDELsigned               ; DEL = DEL + BCH
 184+ 0000 ~                                    ld      a,l
 185+ 0000 ~                                    ld      (vertex),a
 186+ 0000 ~                                    ld      (vertex+1),de
 187+ 0000                                      ENDM
# file closed: ./Macros/MathsMacros.asm
  46  0000                                      INCLUDE "./Macros/MMUMacros.asm"
# file opened: ./Macros/MMUMacros.asm
   1+ 0000              MMUSelectROM0:       MACRO
   2+ 0000 ~                                 nextreg EXSDOSMMU0,        BankROM
   3+ 0000                                   ENDM
   4+ 0000
   5+ 0000              MMUSelectROMS:       MACRO
   6+ 0000 ~                                 nextreg EXSDOSMMU0,        BankROM
   7+ 0000 ~                                 nextreg EXSDOSMMU1,        BankROM
   8+ 0000                                   ENDM
   9+ 0000
  10+ 0000              MMUSelectMathsTables:MACRO
  11+ 0000 ~                                 nextreg MathsTablesMMU,    BankMathsTables
  12+ 0000                                   ENDM
  13+ 0000
  14+ 0000              MMUSelectSpriteBank: MACRO
  15+ 0000 ~            					 nextreg SpritememMMU,	    BankSPRITE
  16+ 0000              					 ENDM
  17+ 0000
  18+ 0000              MMUSelectConsoleBank: MACRO
  19+ 0000 ~            					 nextreg ConsoleImageDataMMU,  BankConsole
  20+ 0000              					 ENDM
  21+ 0000
  22+ 0000              MMUSelectLayer1: 	 MACRO
  23+ 0000 ~            					 nextreg L1memMMU,		    BankLAYER1
  24+ 0000              					 ENDM
  25+ 0000
  26+ 0000              MMUSelectLayer2: 	 MACRO
  27+ 0000 ~            					 nextreg L2memMMU,		    BankLAYER2
  28+ 0000              					 ENDM
  29+ 0000
  30+ 0000              MMUSelectResetUniv:  MACRO
  31+ 0000 ~                                 nextreg ResetUniverseMMU, BankResetUniv
  32+ 0000                                   ENDM
  33+ 0000
  34+ 0000              MMUSelectShipARead:  MACRO
  35+ 0000 ~                                 add    a,BankUNIVDATA0
  36+ 0000 ~                                 nextreg ShipReadMMU,       a
  37+ 0000                                   ENDM
  38+ 0000
  39+ 0000              MMUSelectShipBank1:  MACRO
  40+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels1
  41+ 0000              					 ENDM
  42+ 0000              MMUSelectShipBank2:  MACRO
  43+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels2
  44+ 0000              					 ENDM
  45+ 0000              MMUSelectShipBank3:  MACRO
  46+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels3
  47+ 0000              					 ENDM
  48+ 0000              MMUSelectShipBank4:  MACRO
  49+ 0000 ~            					 nextreg ShipModelMMU,	    BankShipModels4
  50+ 0000              					 ENDM
  51+ 0000
  52+ 0000              MMUSelectShipBankA   MACRO
  53+ 0000 ~            					 nextreg ShipModelMMU,	    a
  54+ 0000              					 ENDM
  55+ 0000
  56+ 0000              MMUSelectShipBankN:  MACRO value
  57+ 0000 ~            					 nextreg ShipModelMMU,	    value
  58+ 0000              					 ENDM
  59+ 0000
  60+ 0000              MMUSelectCommander:	 MACRO
  61+ 0000 ~                                 nextreg CommanderMMU,       BankCommander
  62+ 0000              					 ENDM
  63+ 0000
  64+ 0000              MMUSelectStockTable: MACRO
  65+ 0000 ~                                 nextreg StockTableMMU,     BankStockTable
  66+ 0000              					 ENDM
  67+ 0000
  68+ 0000              MMUSelectCpySrcA:    MACRO
  69+ 0000 ~                                 nextreg DMACpySourceMMU,	a
  70+ 0000              					 ENDM
  71+ 0000
  72+ 0000              MMUSelectCpySrcN:    MACRO value
  73+ 0000 ~                                 nextreg DMACpySourceMMU,	value
  74+ 0000              					 ENDM
  75+ 0000
  76+ 0000              MMUSelectSun:        MACRO
  77+ 0000 ~                                 nextreg SunMMU,            BankSunData
  78+ 0000                                   ENDM
  79+ 0000
  80+ 0000              MMUSelectPlanet:     MACRO
  81+ 0000 ~                                 nextreg PlanetMMU,         BankPlanetData
  82+ 0000                                   ENDM
  83+ 0000
  84+ 0000              MMUSelectUniverseA:  MACRO
  85+ 0000 ~                                 add    a,BankUNIVDATA0
  86+ 0000 ~                                 nextreg UniverseMMU,       a
  87+ 0000                                   ENDM
  88+ 0000              ;Version that assumes a pre calulated A, used whn optimising many switches
  89+ 0000              MMUSelectUnivBankA:  MACRO
  90+ 0000 ~                                 nextreg UniverseMMU,       a
  91+ 0000                                   ENDM
  92+ 0000
  93+ 0000              MMUSelectUniverseN:  MACRO value
  94+ 0000 ~                                 nextreg UniverseMMU,       BankUNIVDATA0+value
  95+ 0000                                   ENDM
  96+ 0000
  97+ 0000              MMUSelectGalaxyA:    MACRO
  98+ 0000 ~                                 nextreg GalaxyDataMMU,     a
  99+ 0000                                   ENDM
 100+ 0000
 101+ 0000              MMUSelectGalaxyN:    MACRO value
 102+ 0000 ~                                 nextreg GalaxyDataMMU,     BankGalaxyData0+value
 103+ 0000                                   ENDM
 104+ 0000              MMUSelectGalaxyACopy:MACRO
 105+ 0000 ~                                 nextreg UniverseMMU,       a
 106+ 0000                                   ENDM
 107+ 0000
 108+ 0000              MMUSelectUniverseAbs:MACRO value
 109+ 0000 ~                                 nextreg UniverseMMU,       value
 110+ 0000                                   ENDM
 111+ 0000
 112+ 0000              MMUSelectMenuGalCht: MACRO
 113+ 0000 ~                                 nextreg MenuGalChtMMU,		BankMenuGalCht
 114+ 0000              					 ENDM
 115+ 0000
 116+ 0000              MMUSelectMenuShrCht: MACRO
 117+ 0000 ~            					 nextreg MenuShrChtMMU,		BankMenuShrCht
 118+ 0000              					 ENDM
 119+ 0000
 120+ 0000              MMUSelectMenuInvent: MACRO
 121+ 0000 ~                                 nextreg MenuInventMMU,		BankMenuInvent
 122+ 0000              					 ENDM
 123+ 0000
 124+ 0000              MMUSelectMenuSystem: MACRO
 125+ 0000 ~                                 nextreg MenuSystemMMU,		BankMenuSystem
 126+ 0000              					 ENDM
 127+ 0000
 128+ 0000              MMUSelectMenuMarket: MACRO
 129+ 0000 ~                                 nextreg MenuMarketMMU,		BankMenuMarket
 130+ 0000              					 ENDM
 131+ 0000
 132+ 0000              MMUSelectMenuStatus: MACRO
 133+ 0000 ~                                 nextreg MenuStatusMMU,		BankMenuStatus
 134+ 0000              					 ENDM
 135+ 0000
 136+ 0000              MMUSelectViewFront:  MACRO
 137+ 0000 ~                                 nextreg ScreenBankMMU,		BankFrontView
 138+ 0000              					 ENDM
 139+ 0000
 140+ 0000              MMUSelectScreenA:    MACRO
 141+ 0000 ~                                 nextreg ScreenBankMMU,		a
 142+ 0000              					 ENDM
 143+ 0000
 144+ 0000              MMUSelectSound:      MACRO
 145+ 0000 ~                                 nextreg SoundMMU,		    BankSound
 146+ 0000              					 ENDM
# file closed: ./Macros/MMUMacros.asm
  47  0000                                      INCLUDE "./Macros/NegateMacros.asm"
# file opened: ./Macros/NegateMacros.asm
   1+ 0000
   2+ 0000              NegIY:			    MACRO
   3+ 0000 ~                                xor a
   4+ 0000 ~                                sub iyl
   5+ 0000 ~                                ld iyl,a
   6+ 0000 ~                                sbc a,a
   7+ 0000 ~                                sub iyh
   8+ 0000 ~                                ld iyh,a
   9+ 0000                                  ENDM
  10+ 0000
  11+ 0000              NegHL:			    MACRO
  12+ 0000 ~                                xor a
  13+ 0000 ~                                sub l
  14+ 0000 ~                                ld l,a
  15+ 0000 ~                                sbc a,a
  16+ 0000 ~                                sub h
  17+ 0000 ~                                ld h,a
  18+ 0000                                  ENDM
  19+ 0000
  20+ 0000              NegDE:			    MACRO
  21+ 0000 ~                                xor a
  22+ 0000 ~                                sub e
  23+ 0000 ~                                ld e,a
  24+ 0000 ~                                sbc a,a
  25+ 0000 ~                                sub d
  26+ 0000 ~                                ld d,a
  27+ 0000                                  ENDM
  28+ 0000
  29+ 0000              NegBC:			    MACRO
  30+ 0000 ~                                xor a
  31+ 0000 ~                                sub c
  32+ 0000 ~                                ld c,a
  33+ 0000 ~                                sbc a,a
  34+ 0000 ~                                sub  b
  35+ 0000 ~                                ld b,a
  36+ 0000                                  ENDM
  37+ 0000
  38+ 0000              NegH                MACRO
  39+ 0000 ~                                ld      a,h
  40+ 0000 ~                                neg
  41+ 0000 ~                                ld      h,a
  42+ 0000                                  ENDM
  43+ 0000
  44+ 0000              NegD                MACRO
  45+ 0000 ~                                ld      a,d
  46+ 0000 ~                                neg
  47+ 0000 ~                                ld      d,a
  48+ 0000                                  ENDM
  49+ 0000
  50+ 0000              NegB                MACRO
  51+ 0000 ~                                ld      a,b
  52+ 0000 ~                                neg
  53+ 0000 ~                                ld      b,a
  54+ 0000                                  ENDM
  55+ 0000
# file closed: ./Macros/NegateMacros.asm
  48  0000                                      INCLUDE "./Macros/returnMacros.asm"
# file opened: ./Macros/returnMacros.asm
   1+ 0000              ReturnOnBitSet:         MACRO  reg, bitnbr
   2+ 0000 ~                                    bit 	bitnbr,reg
   3+ 0000 ~                                    ret     nz
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              ReturnOnMemBitSet:      MACRO mem, bitnbr
   7+ 0000 ~                                    ld   a,(mem)
   8+ 0000 ~                                    bit 	bitnbr,a
   9+ 0000 ~                                    ret     nz
  10+ 0000                                      ENDM
  11+ 0000
  12+ 0000              ReturnOnBitClear:       MACRO reg, bitnbr
  13+ 0000 ~                                    bit 	bitnbr,reg
  14+ 0000 ~                                    ret		z
  15+ 0000                                      ENDM
  16+ 0000
  17+ 0000              ReturnOnMemBitClear:    MACRO mem, bitnbr
  18+ 0000 ~                                    ld     a,(mem)
  19+ 0000 ~                                    bit 	bitnbr,a
  20+ 0000 ~                                    ret		z
  21+ 0000                                      ENDM
  22+ 0000
  23+ 0000              ReturnIfMemFalse:       MACRO   mem
  24+ 0000 ~                                    ld      a,(mem)
  25+ 0000 ~                                    and     a
  26+ 0000 ~                                    ret     nz
  27+ 0000                                      ENDM
  28+ 0000
  29+ 0000              ReturnIfMemTrue:        MACRO   mem
  30+ 0000 ~                                    ld      a,(mem)
  31+ 0000 ~                                    and     a
  32+ 0000 ~                                    ret     z
  33+ 0000                                      ENDM
  34+ 0000
  35+ 0000              ReturnIfAIsZero:        MACRO
  36+ 0000 ~                                    and     a
  37+ 0000 ~                                    ret     z
  38+ 0000                                      ENDM
  39+ 0000
  40+ 0000              ReturnIfMemisZero:      MACRO mem
  41+ 0000 ~                                    ld   a,(mem)
  42+ 0000 ~                                    and a
  43+ 0000 ~                                    ret    z
  44+ 0000                                      ENDM
  45+ 0000
  46+ 0000              ReturnIfMemIsNegative:  MACRO mem
  47+ 0000 ~                                    ld      a,(mem)
  48+ 0000 ~                                    and     $80
  49+ 0000 ~                                    ret     nz
  50+ 0000                                      ENDM
  51+ 0000
  52+ 0000              ReturnIfBitMaskClear    MACRO   bitmask
  53+ 0000 ~                                    and     bitmask
  54+ 0000 ~                                    ret     z
  55+ 0000                                      ENDM
  56+ 0000
  57+ 0000              ReturnIfBitMaskSet      MACRO   bitmask
  58+ 0000 ~                                    and     bitmask
  59+ 0000 ~                                    ret     nz
  60+ 0000                                      ENDM
  61+ 0000
  62+ 0000              ReturnIfMemEquN:        MACRO mem, value
  63+ 0000 ~                                    ld     a,(mem)
  64+ 0000 ~                                    cp     value
  65+ 0000 ~                                    ret    nz
  66+ 0000                                      ENDM
  67+ 0000
  68+ 0000              ReturnIfMemNeNusng:     MACRO mem, value
  69+ 0000 ~                                    ld   a,(mem)
  70+ 0000 ~                                    cp     value
  71+ 0000 ~                                    ret    z
  72+ 0000                                      ENDM
  73+ 0000
  74+ 0000              ReturnIfRegNotZero:     MACRO reg
  75+ 0000 ~                                    ld      a, reg
  76+ 0000 ~                                    and     a
  77+ 0000 ~                                    ret     nz
  78+ 0000                                      ENDM
  79+ 0000
  80+ 0000              ReturnIfANotZero:       MACRO
  81+ 0000 ~                                    and     a
  82+ 0000 ~                                    ret     nz
  83+ 0000                                      ENDM
  84+ 0000
  85+ 0000              ReturnIfNotZero:        MACRO
  86+ 0000 ~                                    ret     nz
  87+ 0000                                      ENDM
  88+ 0000
  89+ 0000              ReturnIfZero:           MACRO
  90+ 0000 ~                                    ret     z
  91+ 0000                                      ENDM
  92+ 0000
  93+ 0000              ReturnIfNegative:       MACRO
  94+ 0000 ~                                    ret     m
  95+ 0000                                      ENDM
  96+ 0000
  97+ 0000
  98+ 0000              ReturnIfMemNotZero:     MACRO mem
  99+ 0000 ~                                    ld     a,(mem)
 100+ 0000 ~                                    and     a
 101+ 0000 ~                                    ret    nz
 102+ 0000                                      ENDM
 103+ 0000
 104+ 0000              ReturnIfAGTEusng:       MACRO value
 105+ 0000 ~                                    cp    value
 106+ 0000 ~                                    ret	 nc
 107+ 0000                                      ENDM
 108+ 0000
 109+ 0000              ReturnIfRegLTNusng:     MACRO reg, value
 110+ 0000 ~                                    ld      a,reg
 111+ 0000 ~                                    cp      value
 112+ 0000 ~                                    ret	    c
 113+ 0000                                      ENDM
 114+ 0000
 115+ 0000              ReturnIfALTNusng:       MACRO value
 116+ 0000 ~                                    cp    value
 117+ 0000 ~                                    ret	 c
 118+ 0000                                      ENDM
 119+ 0000
 120+ 0000              ReturnIfAGTENusng:      MACRO value
 121+ 0000 ~                                    cp    value
 122+ 0000 ~                                    ret	 nc
 123+ 0000                                      ENDM
 124+ 0000
 125+ 0000              ReturnIfAGTEMemusng:    MACRO value
 126+ 0000 ~                                    ld      hl,value
 127+ 0000 ~                                    cp      (hl)
 128+ 0000 ~                                    ret	    nc
 129+ 0000                                      ENDM
 130+ 0000
 131+ 0000              ReturnIfANENusng:       MACRO value
 132+ 0000 ~                                    cp      value
 133+ 0000 ~                                    ret     nz
 134+ 0000                                      ENDM
 135+ 0000
 136+ 0000              ReturnIfAEqNusng:       MACRO value
 137+ 0000 ~                                    cp      value
 138+ 0000 ~                                    ret     z
 139+ 0000                                      ENDM
 140+ 0000
# file closed: ./Macros/returnMacros.asm
  49  0000                                      INCLUDE "./Macros/ShiftMacros.asm"
# file opened: ./Macros/ShiftMacros.asm
   1+ 0000              ShiftIYRight1: MACRO
   2+ 0000 ~            			   ld 	a,iyh
   3+ 0000 ~            			   srl 	a
   4+ 0000 ~            			   ld	iyh,a
   5+ 0000 ~            			   ld 	a,iyl
   6+ 0000 ~            			   rra
   7+ 0000 ~            			   ld	iyl,a
   8+ 0000              			   ENDM
   9+ 0000
  10+ 0000              ShiftHLRight1: MACRO
  11+ 0000 ~            			   srl h
  12+ 0000 ~            			   rr  l
  13+ 0000              			   ENDM
  14+ 0000
  15+ 0000              ShiftDERight1: MACRO
  16+ 0000 ~            			   srl d
  17+ 0000 ~            			   rr  e
  18+ 0000              			   ENDM
  19+ 0000
  20+ 0000              ShiftBCRight1: MACRO
  21+ 0000 ~            			   srl b
  22+ 0000 ~            			   rr  c
  23+ 0000              			   ENDM
  24+ 0000
  25+ 0000
  26+ 0000
  27+ 0000              ShiftHLDiv8:   MACRO
  28+ 0000 ~            			   srl h
  29+ 0000 ~            			   rr  l
  30+ 0000 ~            			   srl h
  31+ 0000 ~            			   rr  l
  32+ 0000 ~            			   srl h
  33+ 0000 ~            			   rr  l
  34+ 0000              			   ENDM
  35+ 0000
  36+ 0000              ShiftHLLeft1:  MACRO    ; 16 T states
  37+ 0000 ~            			   sla l
  38+ 0000 ~            			   rl  h
  39+ 0000              			   ENDM
  40+ 0000
  41+ 0000              ShiftDELeft1:  MACRO    ; 16 T states
  42+ 0000 ~            			   sla e
  43+ 0000 ~            			   rl  d
  44+ 0000              			   ENDM
  45+ 0000
  46+ 0000              BarrelHLLeft3: MACRO
  47+ 0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
  48+ 0000 ~                           push     bc      ; 10
  49+ 0000 ~                           ld       b,3     ; 7
  50+ 0000 ~                           bsrl     de,b    ; 8
  51+ 0000 ~                           pop      bc      ; 10
  52+ 0000 ~                           ex       de,hl   ; 4
  53+ 0000                             ENDM
  54+ 0000
  55+ 0000              BarrelHLRight3: MACRO
  56+ 0000 ~                           ex       de,hl   ; 4   43 T states vs 32 for doing ShiftHL Twice, so need at least 3 Shifts
  57+ 0000 ~                           push     bc      ; 10
  58+ 0000 ~                           ld       b,3     ; 7
  59+ 0000 ~                           bsrl     de,b    ; 8
  60+ 0000 ~                           pop      bc      ; 10
  61+ 0000 ~                           ex       de,hl   ; 4
  62+ 0000                             ENDM
  63+ 0000
  64+ 0000              RollDELeft1:   MACRO	; 16 T states
  65+ 0000 ~                           rl  e
  66+ 0000 ~                           rl  d
  67+ 0000                             ENDM
  68+ 0000
  69+ 0000              ShiftBCLeft1:  MACRO    ; 16 T states
  70+ 0000 ~            			   sla c
  71+ 0000 ~            			   rl  b
  72+ 0000              			   ENDM
  73+ 0000
  74+ 0000              ShiftMem16Right1:   MACRO memaddr
  75+ 0000 ~                                ld    hl,(memaddr)
  76+ 0000 ~                                srl   h
  77+ 0000 ~                                rr    l
  78+ 0000 ~                                ld    (memaddr),hl
  79+ 0000                                  ENDM
  80+ 0000
  81+ 0000              ShiftMem8Right1:    MACRO memaddr
  82+ 0000 ~                                ld      a,(memaddr)
  83+ 0000 ~                                srl     a
  84+ 0000 ~                                ld      (memaddr),a
  85+ 0000                                  ENDM
  86+ 0000
  87+ 0000
  88+ 0000              ShiftMem8Left1A:    MACRO memaddr
  89+ 0000 ~                                ld      a,(memaddr)
  90+ 0000 ~                                sla     a
  91+ 0000 ~                                ld      (memaddr),a
  92+ 0000                                  ENDM
  93+ 0000
# file closed: ./Macros/ShiftMacros.asm
  50  0000                                      INCLUDE "./Macros/signBitMacros.asm"
# file opened: ./Macros/signBitMacros.asm
   1+ 0000              SetMemBitN              MACRO mem,bitnbr
   2+ 0000 ~                                    ld      hl,mem
   3+ 0000 ~                                    set     bitnbr,(hl)
   4+ 0000                                      ENDM
   5+ 0000
   6+ 0000              ClearMemBitN            MACRO mem,bitnbr
   7+ 0000 ~                                    ld      hl,mem
   8+ 0000 ~                                    res     bitnbr,(hl)
   9+ 0000                                      ENDM
  10+ 0000
  11+ 0000
  12+ 0000              ClearSignBitMem:        MACRO mem
  13+ 0000 ~                                    ld      a,(mem)
  14+ 0000 ~                                    and     SignMask8Bit
  15+ 0000 ~                                    ld      (mem),a
  16+ 0000                                      ENDM
  17+ 0000
  18+ 0000              SetSignBitMem:          MACRO   mem
  19+ 0000 ~                                    ld      a,(mem)
  20+ 0000 ~                                    or      SignOnly8Bit
  21+ 0000 ~                                    ld      (mem),a
  22+ 0000                                      ENDM
  23+ 0000
  24+ 0000              FlipSignMem:            MACRO mem
  25+ 0000 ~                                    ld  a,(mem)
  26+ 0000 ~                                    xor SignOnly8Bit
  27+ 0000 ~                                    ld  (mem),a
  28+ 0000                                      ENDM
  29+ 0000
  30+ 0000              SignBitOnlyMem:         MACRO mem
  31+ 0000 ~                                    ld      a, (mem)
  32+ 0000 ~                                    and     SignOnly8Bit
  33+ 0000 ~                                    ld      (mem),a
  34+ 0000                                      ENDM
  35+ 0000
  36+ 0000              ClearSignBit:           MACRO reg
  37+ 0000 ~                                    ld      a,reg
  38+ 0000 ~                                    and     SignMask8Bit
  39+ 0000 ~                                    ld      reg,a
  40+ 0000                                      ENDM
  41+ 0000
  42+ 0000              SetSignBit:             MACRO   reg
  43+ 0000 ~                                    ld      a,reg
  44+ 0000 ~                                    or      SignOnly8Bit
  45+ 0000 ~                                    ld      reg,a
  46+ 0000                                      ENDM
  47+ 0000
  48+ 0000              FlipSignBit:            MACRO   reg
  49+ 0000 ~                                    ld      a, reg
  50+ 0000 ~                                    xor     SignOnly8Bit
  51+ 0000 ~                                    ld      reg,a
  52+ 0000                                      ENDM
  53+ 0000
  54+ 0000              SignBitOnly:            MACRO   reg
  55+ 0000 ~                                    ld      a, reg
  56+ 0000 ~                                    and     SignOnly8Bit
  57+ 0000 ~                                    ld      reg,a
  58+ 0000                                      ENDM
  59+ 0000
  60+ 0000              ClearSignBitA:          MACRO
  61+ 0000 ~                                    and     SignMask8Bit
  62+ 0000                                      ENDM
  63+ 0000
  64+ 0000              SetSignBitA:            MACRO
  65+ 0000 ~                                    or      SignOnly8Bit
  66+ 0000                                      ENDM
  67+ 0000
  68+ 0000              FlipSignBitA:           MACRO
  69+ 0000 ~                                    xor     SignOnly8Bit
  70+ 0000                                      ENDM
  71+ 0000
  72+ 0000              SignBitOnlyA:           MACRO
  73+ 0000 ~                                    and     SignOnly8Bit
  74+ 0000                                      ENDM
# file closed: ./Macros/signBitMacros.asm
  51  0000                                      INCLUDE "./Tables/message_queue_macros.asm"
# file opened: ./Tables/message_queue_macros.asm
   1+ 0000
   2+ 0000              AnyMessagesMacro:       MACRO   NoMessageTarget
   3+ 0000 ~                                    ld      a, (MessageCount)
   4+ 0000 ~                                    and     a
   5+ 0000 ~                                    jr      z, NoMessageTarget
   6+ 0000                                      ENDM
   7+ 0000
   8+ 0000              AnyHyperSpaceMacro:     MACRO   NoMessageText
   9+ 0000 ~                                    ld      hl,(InnerHyperCount)
  10+ 0000 ~                                    ld      a,h
  11+ 0000 ~                                    or      l
  12+ 0000 ~                                    jr      z, NoMessageText
  13+ 0000                                      ENDM
  14+ 0000
# file closed: ./Tables/message_queue_macros.asm
  52  0000                                      INCLUDE "./Variables/general_variables_macros.asm"
# file opened: ./Variables/general_variables_macros.asm
   1+ 0000              ; limited to 255 character length
   2+ 0000              CountLengthHL:          MACRO   Limiter
   3+ 0000 ~                                    ld      de,hl
   4+ 0000 ~                                    ld      bc,Limiter
   5+ 0000 ~                                    xor     a
   6+ 0000 ~                                    cpir
   7+ 0000 ~                                    ClearCarryFlag
   8+ 0000 ~                                    sbc     hl,de
   9+ 0000 ~                                    ld      a,l
  10+ 0000 ~                                    ret
  11+ 0000                                      ENDM
  12+ 0000
  13+ 0000              IncMemMaxN:             MACRO   mem, maxvalue
  14+ 0000 ~                                    ld      a,(mem)
  15+ 0000 ~                                    cp      maxvalue
  16+ 0000 ~                                    jr      c,.IncMaxed
  17+ 0000 ~                                    inc     a
  18+ 0000 ~                                    ld      (mem),a
  19+ 0000 ~            .IncMaxed:
  20+ 0000                                      ENDM
  21+ 0000
  22+ 0000              IncMemMaxNCycle:        MACRO   mem, cyclevalue
  23+ 0000 ~                                    ld      a,(mem)
  24+ 0000 ~                                    inc     a
  25+ 0000 ~                                    cp      cyclevalue
  26+ 0000 ~                                    jr      c,.IncMaxed
  27+ 0000 ~                                    xor     a
  28+ 0000 ~            .IncMaxed:              ld      (mem),a
  29+ 0000                                      ENDM
  30+ 0000
  31+ 0000
  32+ 0000              HalfLengthHL:           MACRO
  33+ 0000 ~                                    ld      b,0
  34+ 0000 ~            .CountLenLoop:          ld      a,(hl)
  35+ 0000 ~                                    cp      0
  36+ 0000 ~                                    jr      z,.DoneCount
  37+ 0000 ~                                    inc     b
  38+ 0000 ~                                    inc     hl
  39+ 0000 ~                                    jr      .CountLenLoop
  40+ 0000 ~            .DoneCount:             ld      a,32
  41+ 0000 ~                                    sub     b
  42+ 0000 ~                                    sra     a
  43+ 0000                                      ENDM
  44+ 0000
  45+ 0000              MakeInnocentMacro:		MACRO
  46+ 0000 ~            						xor		a
  47+ 0000 ~            						ld		(FugitiveInnocentStatus),a
  48+ 0000              						ENDM
  49+ 0000
  50+ 0000              NoEscapePodMacro:		MACRO
  51+ 0000 ~            						xor		a
  52+ 0000 ~            						ld		(EscapePod),a
  53+ 0000              						ENDM
  54+ 0000
  55+ 0000              MaxFuelLevel            EQU     70              ; 7.0 light years max
  56+ 0000              MaxFuelMacro:			MACRO
  57+ 0000 ~            						ld		a,MaxFuelLevel
  58+ 0000 ~            						ld		(Fuel),a
  59+ 0000              						ENDM
  60+ 0000
  61+ 0000              MaxThrottle:            MACRO
  62+ 0000 ~                                    ld      a,(SHIPMAXSPEED)
  63+ 0000 ~                                    ld      (DELTA),a
  64+ 0000 ~                                    ld      d,a
  65+ 0000 ~                                    ld      e,4
  66+ 0000 ~                                    mul
  67+ 0000 ~                                    ld      (DELT4Lo),de
  68+ 0000                                      ENDM
  69+ 0000
  70+ 0000              ZeroThrottle:           MACRO
  71+ 0000 ~                                    xor     a
  72+ 0000 ~                                    ld      (DELTA),a
  73+ 0000 ~                                    ld      (DELT4Lo),a
  74+ 0000 ~                                    ld      (DELT4Lo+1),a
  75+ 0000                                      ENDM
  76+ 0000
  77+ 0000              ZeroPitch:              MACRO
  78+ 0000 ~                                    xor     a
  79+ 0000 ~                                    ld      (BET2),a
  80+ 0000 ~                                    ld      (BET2FLIP),a
  81+ 0000 ~                                    ld      (JSTY),a
  82+ 0000 ~                                    ld      (BETA),a
  83+ 0000                                      ENDM
  84+ 0000
  85+ 0000              ZeroRoll:               MACRO
  86+ 0000 ~                                    xor     a                              ; zero roll and climb
  87+ 0000 ~                                    ld      (ALP2),a
  88+ 0000 ~                                    ld      (ALP2FLIP),a
  89+ 0000 ~                                    ld      (JSTX),a
  90+ 0000 ~                                    ld      (ALPHA),a
  91+ 0000                                      ENDM
  92+ 0000
  93+ 0000              CorrectPostJumpFuel:    MACRO
  94+ 0000 ~                                    ld      a,(Fuel)
  95+ 0000 ~                                    ld      hl,Distance
  96+ 0000 ~                                    sub     a,(hl)
  97+ 0000 ~                                    ld      (Fuel),a
  98+ 0000                                      ENDM
  99+ 0000
 100+ 0000              AnyMissilesLeft:        MACRO
 101+ 0000 ~                                    ld      a,(NbrMissiles)
 102+ 0000 ~                                    and     a
 103+ 0000                                      ENDM
 104+ 0000
 105+ 0000              SetMissileTargetA:      MACRO
 106+ 0000 ~                                    ld      (MissileTargettingFlag),a   ; Set to slot number clearing bit 7
 107+ 0000                                      ENDM
 108+ 0000
 109+ 0000              IsMissileLaunchFlagged: MACRO
 110+ 0000 ~                                    ld      a,(MissileTargettingFlag)
 111+ 0000 ~                                    and     $80
 112+ 0000                                      ENDM
 113+ 0000
 114+ 0000              SetMissileTargetting:   MACRO
 115+ 0000 ~                                    ld      a,StageMissileTargeting
 116+ 0000 ~                                    ld      (MissileTargettingFlag),a
 117+ 0000                                      ENDM
 118+ 0000
 119+ 0000              ClearMissileTargetting: MACRO
 120+ 0000 ~                                    ld      a,StageMissileNotTargeting
 121+ 0000 ~                                    ld      (MissileTargettingFlag),a
 122+ 0000                                      ENDM
 123+ 0000
 124+ 0000
 125+ 0000              ; Clear targetting bits which signals launch if lower nibble has selected target
 126+ 0000              SetMissileLaunch:       MACRO
 127+ 0000 ~                                    ld      a,(MissileTargettingFlag)
 128+ 0000 ~                                    and     $0F
 129+ 0000 ~                                    ld      (MissileTargettingFlag),a
 130+ 0000                                      ENDM
 131+ 0000
 132+ 0000              LockMissileToA:         MACRO
 133+ 0000 ~                                    or      $80
 134+ 0000 ~                                    ld      (MissileTargettingFlag),a
 135+ 0000                                      ENDM
 136+ 0000
 137+ 0000              ClearECM:               MACRO
 138+ 0000 ~                                    xor     a
 139+ 0000 ~                                    ld      (ECMCountDown),a
 140+ 0000                                      ENDM
 141+ 0000
 142+ 0000
 143+ 0000              ; Will check to see if bit 2 is set, if it is clear, then friendly hence z is set
 144+ 0000              ;                                    if hit is set then hostile hence z is not set
 145+ 0000              IsShipHostile:          MACRO
 146+ 0000 ~                                    ld      a,(ShipNewBitsAddr)
 147+ 0000 ~                                    and     ShipIsHostile
 148+ 0000                                      ENDM
 149+ 0000
 150+ 0000              ; Will check to see if bit 2 is set, if it is clear, then friendly hence z is set
 151+ 0000              ;                                    if hit is set then hostile hence z is not set
 152+ 0000              IsShipFriendly:         MACRO
 153+ 0000 ~                                    ld      a,(ShipNewBitsAddr)
 154+ 0000 ~                                    and     ShipNotHostile                  ; mask so we only have hostile bit
 155+ 0000                                      ENDM
 156+ 0000
 157+ 0000              ; Will check to see if bit 5 is set, if clear, then not exploding z clear
 158+ 0000              ;                                    if set    then exploding     z set
 159+ 0000              IsShipExploding:        MACRO
 160+ 0000 ~                                    ld      a,(UBnkaiatkecm)
 161+ 0000 ~                                    and     ShipExploding
 162+ 0000                                      ENDM
 163+ 0000
 164+ 0000              UpdateLaserOnCounter:   MACRO
 165+ 0000 ~                                    ld      a,(CurrLaserPulseOnCount)
 166+ 0000 ~                                    and     a
 167+ 0000 ~                                    jr      z,.LaserOnIsDone
 168+ 0000 ~                                    dec     a
 169+ 0000 ~                                    ld      (CurrLaserPulseOnCount),a
 170+ 0000 ~                                    jr      z,.LaserOnIsDone
 171+ 0000 ~                                    ldCopyByte CurrLaserPulseOffTime, CurrLaserPulseOffCount
 172+ 0000 ~            .LaserOnIsDone:
 173+ 0000                                      ENDM
 174+ 0000
 175+ 0000              UpdateLaserOffCounter:  MACRO
 176+ 0000 ~                                    ld      a,(CurrLaserPulseOffTime)
 177+ 0000 ~                                    and     a
 178+ 0000 ~                                    jr      z,.LaserOffIsDone
 179+ 0000 ~                                    dec     a
 180+ 0000 ~                                    ld      (CurrLaserPulseOffTime),a
 181+ 0000 ~                                    jr      z,.LaserOffIsDone
 182+ 0000 ~                                    ldCopyByte CurrLaserPulseRest, CurrLaserPulseRestCount
 183+ 0000 ~            .LaserOffIsDone:
 184+ 0000                                      ENDM
 185+ 0000
 186+ 0000              UpdateLaserRestCounter: MACRO
 187+ 0000 ~                                    ld      a,(CurrLaserPulseRestCount)
 188+ 0000 ~                                    and     a
 189+ 0000 ~                                    jr      z,.LaserRestIsDone
 190+ 0000 ~                                    dec     a
 191+ 0000 ~                                    ld      (CurrLaserPulseRestCount),a
 192+ 0000 ~                                    jr      z,.LaserRestIsDone
 193+ 0000 ~                                    ZeroA                                                                           ;    then pulse rate count = 0
 194+ 0000 ~                                    ld      (CurrLaserPulseRateCount),a                                             ;    .
 195+ 0000 ~            .LaserRestIsDone
 196+ 0000                                      ENDM
 197+ 0000
 198+ 0000              ChargeEnergyAndShields: MACRO
 199+ 0000 ~                                    ld      a,$FF
 200+ 0000 ~                                    ld      (PlayerEnergy),a
 201+ 0000 ~                                    ld      (ForeShield),a
 202+ 0000 ~                                    ld      (AftShield),a
 203+ 0000                                      ENDM
 204+ 0000
 205+ 0000              CopyPresentSystemToTarget: MACRO
 206+ 0000 ~                                    ld      hl,(PresentSystemX)
 207+ 0000 ~                                    ld      (TargetSystemX),hl
 208+ 0000                                      ENDM
 209+ 0000
 210+ 0000              CopyTargetSystemToPresent: MACRO
 211+ 0000 ~                                    ld      hl,(TargetSystemX)
 212+ 0000 ~                                    ld      (PresentSystemX),hl
 213+ 0000                                      ENDM
 214+ 0000
 215+ 0000              HalveFugitiveStatus:    MACRO
 216+ 0000 ~                                    ld      hl,FugitiveInnocentStatus
 217+ 0000 ~                                    srl     (hl)
 218+ 0000                                      ENDM
 219+ 0000
 220+ 0000              ClearForceTransition    MACRO
 221+ 0000 ~                                    ld      a,$FF
 222+ 0000 ~                                    ld      (ScreenTransitionForced),a
 223+ 0000                                      ENDM
 224+ 0000
 225+ 0000              ForceTransition:        MACRO newScreen
 226+ 0000 ~                                    ld      a,newScreen
 227+ 0000 ~                                    ld      (ScreenTransitionForced), a
 228+ 0000                                      ENDM
 229+ 0000
 230+ 0000              IsSpaceStationPresent:  MACRO
 231+ 0000 ~                                    ld      a,(SpaceStationSafeZone)
 232+ 0000 ~                                    and     a
 233+ 0000                                      ENDM
 234+ 0000
 235+ 0000              SetSafeZone:            MACRO
 236+ 0000 ~                                    xor     a
 237+ 0000 ~                                    ld      (SpaceStationSafeZone),a
 238+ 0000                                      ENDM
 239+ 0000
 240+ 0000              ClearSafeZone:          MACRO
 241+ 0000 ~                                    ld      a,$FF
 242+ 0000 ~                                    ld      (SpaceStationSafeZone),a
 243+ 0000                                      ENDM
 244+ 0000
 245+ 0000              ClearTemperatures:      MACRO
 246+ 0000 ~                                    xor     a
 247+ 0000 ~                                    ld      (CabinTemperature),a
 248+ 0000 ~                                    ld      (GunTemperature),a
 249+ 0000                                      ENDM
 250+ 0000
 251+ 0000              ClearWarpPressed:       MACRO
 252+ 0000 ~                                    SetMemFalse WarpPressed
 253+ 0000                                      ENDM
 254+ 0000
 255+ 0000              CoolCabin:              MACRO
 256+ 0000 ~                                    ld      a,(CabinTemperature)
 257+ 0000 ~                                    and     a
 258+ 0000 ~                                    jr      z,.AlreadyCool
 259+ 0000 ~                                    dec     a
 260+ 0000 ~                                    ld      (CabinTemperature),a
 261+ 0000 ~            .AlreadyCool:
 262+ 0000                                      ENDM
 263+ 0000
 264+ 0000              CoolLasers:             MACRO
 265+ 0000 ~                                    ld      a,(GunTemperature)
 266+ 0000 ~                                    and     a
 267+ 0000 ~                                    jr      z,.AlreadyCool
 268+ 0000 ~                                    dec     a
 269+ 0000 ~                                    ld      (GunTemperature),a
 270+ 0000 ~            .AlreadyCool:
 271+ 0000                                      ENDM
 272+ 0000
 273+ 0000              ; type 255 is "not fitted"
 274+ 0000
 275+ 0000
 276+ 0000              InitEventCounter:       MACRO
 277+ 0000 ~                                    xor     a
 278+ 0000 ~                                    ld      (EventCounter),a
 279+ 0000                                      ENDM
 280+ 0000
 281+ 0000              ClearMissJump:          MACRO
 282+ 0000 ~                                    ld      a,$FF
 283+ 0000 ~                                    ld      (MissJumpFlag),a
 284+ 0000                                      ENDM
 285+ 0000
 286+ 0000
 287+ 0000              DrainSystem:            MACRO   SystemMem, DrainMem
 288+ 0000 ~                                    ld      a,(DrainMem)
 289+ 0000 ~                                    ld      b,a
 290+ 0000 ~                                    ld      a,(SystemMem)
 291+ 0000 ~                                    sub     a,b
 292+ 0000 ~                                    ld      (SystemMem),a
 293+ 0000 ~                                    jr      c,.ZeroSystem
 294+ 0000 ~                                    jp      .ExitPoint
 295+ 0000 ~            .ZeroSystem:            ZeroA
 296+ 0000 ~                                    ld      (SystemMem),a
 297+ 0000 ~            .ExitPoint
 298+ 0000                                      ENDM
 299+ 0000
 300+ 0000              BoostSystem:            MACRO   SystemMem, BoostMem
 301+ 0000 ~                                    ld      a,(BoostMem)
 302+ 0000 ~                                    ld      b,a
 303+ 0000 ~                                    ld      a,(SystemMem)
 304+ 0000 ~                                    add     b
 305+ 0000 ~                                    ld      (SystemMem),a
 306+ 0000 ~                                    jr      c, .MaxSystem
 307+ 0000 ~                                    jp      .ExitPoint
 308+ 0000 ~            .MaxSystem:             ld      a,255
 309+ 0000 ~                                    ld      (SystemMem),a
 310+ 0000 ~            .ExitPoint
 311+ 0000                                      ENDM
 312+ 0000
 313+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER HasEngineSoundChanged:  MACRO
 314+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ld      a,(EngineSoundChanged)
 315+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         and     a
 316+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ENDM
 317+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER
 318+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER ClearEngineSoundChanged:MACRO
 319+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         xor      a
 320+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ld      (EngineSoundChanged),a
 321+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ENDM
 322+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER
 323+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER SetEngineSoundChanged:  MACRO
 324+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ld      a,$FF
 325+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ld      (EngineSoundChanged),a
 326+ 0000              ;DEFUNCT DONE IN INTERRUPT HANDLER                         ENDM
 327+ 0000
# file closed: ./Variables/general_variables_macros.asm
  53  0000                                      INCLUDE "./Variables/UniverseSlot_macros.asm"
# file opened: ./Variables/UniverseSlot_macros.asm
   1+ 0000
   2+ 0000              AddJunkCount:           MACRO
   3+ 0000 ~                                    ld      hl,JunkCount
   4+ 0000 ~                                    inc     (hl)
   5+ 0000                                      ENDM
   6+ 0000
   7+ 0000              SubJunkCount:           MACRO
   8+ 0000 ~                                    ld      hl,JunkCount
   9+ 0000 ~                                    dec     (hl)
  10+ 0000                                      ENDM
  11+ 0000
  12+ 0000              ClearJunkCount:         MACRO
  13+ 0000 ~                                    ZeroA
  14+ 0000 ~                                    ld      (JunkCount),a
  15+ 0000                                      ENDM
  16+ 0000
  17+ 0000              AddCop:                 MACRO
  18+ 0000 ~                                    ld      hl,CopCount
  19+ 0000 ~                                    inc     (hl)
  20+ 0000                                      ENDM
  21+ 0000
  22+ 0000              SubCop:                 MACRO
  23+ 0000 ~                                    ld      hl,CopCount
  24+ 0000 ~                                    dec     (hl)
  25+ 0000                                      ENDM
  26+ 0000
  27+ 0000              AddPirateCount:         MACRO
  28+ 0000 ~                                    ld      hl,PirateCount
  29+ 0000 ~                                    inc     (hl)
  30+ 0000                                      ENDM
  31+ 0000
  32+ 0000              SubPirateCount:         MACRO
  33+ 0000 ~                                    ld      hl,PirateCount
  34+ 0000 ~                                    inc     (hl)
  35+ 0000                                      ENDM
  36+ 0000
  37+ 0000              AreCopsPresent:         MACRO
  38+ 0000 ~                                    ld      a,(CopCount)
  39+ 0000 ~                                    and     a
  40+ 0000                                      ENDM
  41+ 0000
  42+ 0000              ; Class == shiptype
  43+ 0000              SetSlotAToUnivClass:    MACRO
  44+ 0000 ~                                    ex      af,af'
  45+ 0000 ~                                    ld      a,(ShipTypeAddr)
  46+ 0000 ~                                    ld      b,a
  47+ 0000 ~                                    ex      af,af'
  48+ 0000 ~                                    call    SetSlotAToClassB
  49+ 0000                                      ENDM
  50+ 0000
  51+ 0000              TestRoomForJunk:        MACRO   Target
  52+ 0000 ~                                    ld      a,3
  53+ 0000 ~                                    JumpIfMemTrue  SpaceStationSafeZone, .DoTest
  54+ 0000 ~                                    add     a,2
  55+ 0000 ~            .DoTest                 JumpIfALTMemusng    JunkCount, Target
  56+ 0000                                      ENDM
  57+ 0000
  58+ 0000              JumpIfSpaceStation:     MACRO   Target
  59+ 0000 ~                                    ld      hl,UniverseSlotType
  60+ 0000 ~                                    ld      a,(hl)
  61+ 0000 ~                                    cp      ShipTypeStation
  62+ 0000                                      ENDM
  63+ 0000
  64+ 0000              ClearSlotMem:           MACRO   mem
  65+ 0000 ~                                    ld      a,(mem)
  66+ 0000 ~                                    call    ClearSlotA
  67+ 0000                                      ENDM
  68+ 0000
  69+ 0000              IsSlotEmpty:            MACRO
  70+ 0000 ~                                    ld      hl,UniverseSlotList
  71+ 0000 ~                                    add     hl,a
  72+ 0000 ~                                    ld      a,(hl)
  73+ 0000 ~                                    cp      0
  74+ 0000                                      ENDM
  75+ 0000
  76+ 0000              IsSlotMissile:          MACRO
  77+ 0000 ~                                    ld      hl,UniverseSlotType
  78+ 0000 ~                                    add     hl,a
  79+ 0000 ~                                    ld      a,(hl)
  80+ 0000 ~                                    cp      ShipTypeMissile
  81+ 0000                                      ENDM
  82+ 0000
  83+ 0000
  84+ 0000              ; Checks if slot is empty else A = ship type
  85+ 0000              ReturnIfSlotAEmpty:     MACRO
  86+ 0000 ~                                    ld      hl,UniverseSlotList
  87+ 0000 ~                                    add     hl,a
  88+ 0000 ~                                    ld      a,(hl)
  89+ 0000 ~                                    inc     a
  90+ 0000 ~                                    ret     z           ; if slot was ff inc would make it 0
  91+ 0000 ~                                    dec     a           ; get original value back for later
  92+ 0000                                      ENDM
  93+ 0000
  94+ 0000              JumpIfSlotAEmpty:       MACRO   Target
  95+ 0000 ~                                    ld      hl,UniverseSlotList
  96+ 0000 ~                                    add     hl,a
  97+ 0000 ~                                    ld      a,(hl)
  98+ 0000 ~                                    inc     a
  99+ 0000 ~                                    jp      z,Target    ; if slot was ff inc would make it 0
 100+ 0000 ~                                    dec     a           ; get original value back for later
 101+ 0000                                      ENDM
 102+ 0000
 103+ 0000              JumpIfSlotHLEmpty:      MACRO   Target
 104+ 0000 ~                                    ld      a,(hl)
 105+ 0000 ~                                    and     a
 106+ 0000 ~                                    jr      nz,Target
 107+ 0000                                      ENDM
# file closed: ./Variables/UniverseSlot_macros.asm
  54  0000
  55  0000                                      INCLUDE "./Data/ShipIdEquates.asm"
# file opened: ./Data/ShipIdEquates.asm
   1+ 0000
   2+ 0000
   3+ 0000
   4+ 0000              ShipID_Adder            EQU 00
   5+ 0000              ShipID_Anaconda         EQU 01
   6+ 0000              ShipID_Asp_Mk_2         EQU 02
   7+ 0000              ShipID_Boa              EQU 03
   8+ 0000              ShipID_CargoType5       EQU 04
   9+ 0000              ShipID_Boulder          EQU 05
  10+ 0000              ShipID_Asteroid         EQU 06
  11+ 0000              ShipID_Bushmaster       EQU 07
  12+ 0000              ShipID_Chameleon        EQU 08
  13+ 0000              ShipID_CobraMk3         EQU 09
  14+ 0000              ShipID_Cobra_Mk_1       EQU 10
  15+ 0000              ShipID_Cobra_Mk_3_P     EQU 11
  16+ 0000              ShipID_Constrictor      EQU 12
  17+ 0000              ShipID_Coriolis         EQU 13
  18+ 0000              ShipID_Cougar           EQU 14
  19+ 0000              ShipID_Dodo             EQU 15
  20+ 0000              ShipID_Dragon           EQU 16
  21+ 0000              ShipID_Escape_Pod       EQU 17
  22+ 0000              ShipID_Fer_De_Lance     EQU 18
  23+ 0000              ShipID_Gecko            EQU 19
  24+ 0000              ShipID_Ghavial          EQU 20
  25+ 0000              ShipID_Iguana           EQU 21
  26+ 0000              ShipID_Krait            EQU 22
  27+ 0000              ShipID_Logo             EQU 23
  28+ 0000              ShipID_Mamba            EQU 24
  29+ 0000              ShipID_Missile          EQU 25
  30+ 0000              ShipID_Monitor          EQU 26
  31+ 0000              ShipID_Moray            EQU 27
  32+ 0000              ShipID_Ophidian         EQU 28
  33+ 0000              ShipID_Plate            EQU 29
  34+ 0000              ShipID_Python           EQU 30
  35+ 0000              ShipID_Python_P         EQU 31
  36+ 0000              ShipID_Rock_Hermit      EQU 32
  37+ 0000              ShipID_ShuttleType9     EQU 33
  38+ 0000              ShipID_Shuttle_Mk_2     EQU 34
  39+ 0000              ShipID_Sidewinder       EQU 35
  40+ 0000              ShipID_Splinter         EQU 36
  41+ 0000              ShipID_TestVector       EQU 37
  42+ 0000              ShipID_Thargoid         EQU 38
  43+ 0000              ShipID_Thargon          EQU 39
  44+ 0000              ShipID_TransportType10  EQU 40
  45+ 0000              ShipID_Viper            EQU 41
  46+ 0000              ShipID_Worm             EQU 42
  47+ 0000              ShipID_Rattler          EQU 43
  48+ 0000
# file closed: ./Data/ShipIdEquates.asm
  56  0000
  57  0000              charactersetaddr		equ 15360
  58  0000              STEPDEBUG               equ 1
  59  0000
  60  0000
  61  0000                                      ORG         $8000
  62  8000 F3                                   di
  63  8001                                      ; "STARTUP"
  64  8001                                      MMUSelectLayer1
  64  8001 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
  65  8005 CD 80 E0                             call		l1_cls
  66  8008 3E 07                                ld			a,7
  67  800A CD 9B E0                             call		l1_attr_cls_to_a
  68  800D 3E FF                                ld          a,$FF
  69  800F CD A5 E0                             call        l1_set_border
  70  8012              Initialise:             MMUSelectLayer2
  70  8012 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
  71  8016 CD 45 E2                             call 		l2_initialise
  72  8019 CD 0E E2                             call		l2_cls
  73  801C CD 4F 82                             call        init_keyboard
  74  801F CD 0A E0     MainLoop:               call        asm_l2_double_buffer_off
  75  8022 06 14                                ld		b, 20
  76  8024 0E 14                                ld		c, 20
  77  8026 16 32                                ld		d, 50
  78  8028 1E 32                                ld		e, 50
  79  802A 26 1E                                ld		h, 30
  80  802C 2E 46                                ld		l, 70
  81  802E 3E D3                                ld		a,  $D3
  82  8030 32 43 E5                             ld		(l2linecolor),a
  83  8033 32 A7 F1                             ld      (line_gfx_colour),a
  84  8036
  85  8036                               ;       call	l2_draw_triangle
  86  8036
  87  8036 06 3C                                ld		b, 60
  88  8038 0E 3C                                ld		c, 60
  89  803A 16 50                                ld		d, 80
  90  803C 1E 78                                ld		e, 120
  91  803E 26 46                                ld		h, 70
  92  8040 3E B8                                ld		a, $B8
  93  8042 32 43 E5                             ld		(l2linecolor),a
  94  8045 32 A7 F1                             ld      (line_gfx_colour),a
  95  8048                                      ;break
  96  8048                                ;      call l2_fillBottomFlatTriangle
  97  8048 06 50                                ld		b, 80
  98  804A 0E 1E                                ld		c, 30
  99  804C 16 0A                                ld		d, 10
 100  804E 1E 32                                ld		e, 50
 101  8050 26 1E                                ld		h, 30
 102  8052 3E F3                                ld		a, $F3
 103  8054 32 43 E5                             ld		(l2linecolor),a
 104  8057 32 A7 F1                             ld      (line_gfx_colour),a
 105  805A                                            ;                 x  y     x  y         x  y     x  y
 106  805A                                      ;break ; Line 1 bc -> de 10,30 to 30,80 line 2 50,30 to 30,80
 107  805A                                ;      call l2_fillTopFlatTriangle
 108  805A                                      ;break
 109  805A 06 28                                ld		b, 40    ;28
 110  805C 0E 0A                                ld		c, 10    ;0A
 111  805E 16 4B                                ld		d, 75    ;4B
 112  8060 1E 6E                                ld		e, 110   ;6E
 113  8062 26 5A                                ld		h, 90    ;5A
 114  8064 2E 3C                                ld      l, 60    ;3C
 115  8066 3E C4                                ld		a, $C4
 116  8068 32 43 E5                             ld		(l2linecolor),a
 117  806B 32 A7 F1                             ld      (line_gfx_colour),a
 118  806E                                ;      call l2_fillAnyTriangle ; so X? = 2D n
 119  806E DD 01                                break
 120  8070 21 32 00                             ld      hl,50        ; $14
 121  8073 22 6C E7                             ld      (l2_X0),hl   ;
 122  8076 21 0A 00                             ld      hl,10        ; $28
 123  8079 22 70 E7                             ld      (l2_X1),hl   ;
 124  807C 21 14 00                             ld      hl,20        ;
 125  807F 22 6E E7                             ld      (l2_Y0),hl   ;
 126  8082 21 32 00                             ld      hl,50        ; 1E
 127  8085 22 72 E7                             ld      (l2_Y1),hl   ;
 128  8088 CD 49 E8                             call    int_bren_save_Array1Low
 129  808B 21 37 00                             ld      hl,55        ; $14
 130  808E 22 6C E7                             ld      (l2_X0),hl   ;
 131  8091 21 64 00                             ld      hl,100        ; $28
 132  8094 22 70 E7                             ld      (l2_X1),hl   ;
 133  8097 21 14 00                             ld      hl,20        ;
 134  809A 22 6E E7                             ld      (l2_Y0),hl   ;
 135  809D 21 32 00                             ld      hl,50        ; 1E
 136  80A0 22 72 E7                             ld      (l2_Y1),hl   ;
 137  80A3 CD 78 E8                             call    int_bren_save_Array2High
 138  80A6 21 5F E5                             ld      hl,l2targetArray1+20
 139  80A9 06 1E                                ld      b,30
 140  80AB DD 2E 1E                             ld      ixl,30
 141  80AE C5 E5 DD E5  .LineLoop:              push    bc,,hl,,ix
 142  80B2 7E                                   ld      a,(hl)          ; x0
 143  80B3 4F                                   ld      c,a
 144  80B4 24                                   inc     h
 145  80B5 7E                                   ld      a,(hl)          ; x1
 146  80B6 91                                   sub     c
 147  80B7 57                                   ld      d,a
 148  80B8 1E C5                                ld      e,$C5
 149  80BA DD 45                                ld      b,ixl
 150  80BC                                      MMUSelectLayer2
 150  80BC ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 151  80C0 CD 5B E4                             call    l2_draw_horz_line
 152  80C3 DD E1 E1 C1                          pop     bc,,hl,,ix
 153  80C7 DD 2C                                inc     ixl
 154  80C9 23                                   inc     hl
 155  80CA 10 E2                                djnz    .LineLoop
 156  80CC
 157  80CC
 158  80CC              ;;#optmisation to try
 159  80CC              ;;sort all 3 coordinates y ascending
 160  80CC              ;;if y0 and y1 == then simple flat top
 161  80CC              ;;if y1 aand y2 == then simple flat bottom
 162  80CC              ;;else
 163  80CC              ;;  start drawing flat bottom traingle from x0,y0
 164  80CC              ;;  when y line calulation reaches row y1 we switch to doinig a flat top triangle from xcurrycurr to x1y1 ad x2y2
 165  80CC              ;;  saves all the precalculating
 166  80CC
 167  80CC 21 64 00     LargerTriangle:         ld      hl, 100         ; 64
 168  80CF 22 6C E7                             ld      (l2_X0),hl
 169  80D2 21 64 00                             ld      hl, 100
 170  80D5 22 6E E7                             ld      (l2_Y0),hl
 171  80D8 21 2C 01                             ld      hl, 300
 172  80DB 22 70 E7                             ld      (l2_X1),hl
 173  80DE 21 91 00                             ld      hl, 145
 174  80E1 22 72 E7                             ld      (l2_Y1),hl
 175  80E4 21 78 00                             ld      hl,120
 176  80E7 22 74 E7                             ld      (ld_YMid),hl
 177  80EA DD 01                                break
 178  80EC CD AA E7                             call    HLEquMidX
 179  80EF
 180  80EF DD 01        PausePoint:             break
 181  80F1 C3 EF 80                             jp PausePoint
 182  80F4
 183  80F4 00 00 00...  XX20                DS 20
 184  8108
 185  8108 00           CurrentX            DB 0
 186  8109 00           CurrentY            DB 0
 187  810A               ;..................................................................................................................................
 188  810A              	;call		keyboard_main_loop
 189  810A
 190  810A                  INCLUDE	"./Hardware/memfill_dma.asm"
# file opened: ./Hardware/memfill_dma.asm
   1+ 810A
   2+ 810A 00           memfillvalue		DB 0
   3+ 810B 83 C3 C7 CB  memfill        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   3+ 810F 7D
   4+ 8110 0A 81        memfill_astrt  		DW memfillvalue
   5+ 8112 00 40        memfill_length 		DB $00,$40
   6+ 8114 24 10 AD     					DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
   7+ 8117 00 00        memfill_bstrt  		DB $00,$00
   8+ 8119 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
   9+ 811D              memfill_cmd_len	  	EQU $ - memfill
  10+ 811D
  11+ 811D              memfill_dma:
  12+ 811D              ; "memfill_dma, hl = address to fill, a = value, de = length"
  13+ 811D              .set_fill_value:
  14+ 811D 32 0A 81     	ld 		(memfillvalue),a
  15+ 8120              .set_target:
  16+ 8120 22 17 81     	ld		(memfill_bstrt),hl
  17+ 8123              .set_length:
  18+ 8123 ED 53 12 81  	ld		(memfill_length),de
  19+ 8127              .write_dma:
  20+ 8127 21 0B 81     	ld 		hl, memfill
  21+ 812A 06 12        	ld 		b, memfill_cmd_len
  22+ 812C 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
  23+ 812E ED B3        	otir
  24+ 8130 C9           	ret
  25+ 8131
# file closed: ./Hardware/memfill_dma.asm
 191  8131                  INCLUDE	"./Hardware/memcopy_dma.asm"
# file opened: ./Hardware/memcopy_dma.asm
   1+ 8131
   2+ 8131 83 C3 C7 CB  memcopy        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   2+ 8135 7D
   3+ 8136 00 00        memcopy_astrt  		DB $00,$00
   4+ 8138 00 40        memcopy_length 		DB $00,$40
   5+ 813A 14 10 CD     					DB DMA_WR1_P1INC_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_BURST_MODE;DMA_WR4_CONT_MODE
   6+ 813D 00 00        memcopy_bstrt  		DB $00,$00
   7+ 813F 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
   8+ 8143              memcopy_cmd_len	  	equ $ - memcopy
   9+ 8143
  10+ 8143              memcopy_dma:
  11+ 8143              ; "memcopy_dma, hl = target address de = source address to copy, bc = length"
  12+ 8143              .set_target:
  13+ 8143 22 3D 81     	ld		(memcopy_bstrt),hl
  14+ 8146              .set_source:
  15+ 8146 ED 53 36 81  	ld		(memcopy_astrt),de
  16+ 814A              .set_length:
  17+ 814A ED 43 38 81  	ld		(memcopy_length),bc
  18+ 814E              .write_dma:
  19+ 814E 21 31 81     	ld 		hl, memcopy
  20+ 8151 06 12        	ld 		b, memcopy_cmd_len
  21+ 8153 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
  22+ 8155 ED B3        	otir
  23+ 8157 C9           	ret
  24+ 8158
# file closed: ./Hardware/memcopy_dma.asm
 192  8158                  INCLUDE "./Hardware/keyboard.asm"
# file opened: ./Hardware/keyboard.asm
   1+ 8158              ;
   2+ 8158              ; $FEFE;65278 V, C, X, Z, Caps Shifts       4  3  2  1  0
   3+ 8158              ; $FDFE;65022 G, F, D, S, A                 9  8  7  6  5
   4+ 8158              ; $FBFE;64510 T, R, E, W, Q                14 13 12 11 10
   5+ 8158              ; $F7FE;63486 5, 4, 3, 2, 1                19 18 17 16 15
   6+ 8158              ; $EFFE;61438 6, 7, 8, 9, 0                24 23 22 23 20
   7+ 8158              ; $DFFE;57342 Y, U, I, O, P                29 28 27 26 25
   8+ 8158              ; $BFFE;49150 H, J, K, L, Enter            34 33 32 31 30
   9+ 8158              ; $7FFE;32766 B, N, M, Symbol Shift, Space 39 38 37 36 35
  10+ 8158              ;
  11+ 8158              ; Keyboard
  12+ 8158              ;
  13+ 8158              ;   0      1       2       3       4       5        6       7       8       9
  14+ 8158              ;  VK_CAPS, VK_Z,  VK_X,   VK_C,   VK_V,   VK_A,    VK_S,   VK_D,   VK_F,   VK_G
  15+ 8158              ;   10     11      12      13      14      15       16      17      18      19
  16+ 8158              ;  VK_Q,   VK_W,   VK_E,   VK_R,   VK_T,   VK_1,    VK_2,   VK_3,   VK_4,   VK_5
  17+ 8158              ;   20     21      22      23      24      25       26      27      28      29
  18+ 8158              ;  VK_0    VK_9,   VK_8,   VK_7,   VK_6,   VK_P ,    VK_O,  VK_I,   VK_U,   VK_Y
  19+ 8158              ;   30     31      32      33      34      35       36      37      38      39
  20+ 8158              ; VK_ENTER VK_L,   VK_K,   VK_J,   VK_H,   VK_SPACE VK_SYM, VK_M,   VK_N,   VK_B
  21+ 8158              ;
  22+ 8158              ; ZX Spectrum Next Compound keys
  23+ 8158              ;   40     41       42       43      44      45       46       47
  24+ 8158              ;  VK_SEMI VK_QUOTE VK_COMMA VK_STOP VK_UP   VK_DOWN  VK_LEFT  VK _RIGHT        $Register B0 bits 7 to 0    (Set to set ULA Register ($68) bit to to prevent default keystrokes
  25+ 8158              ;   48       49      50       51         52          53       54      55
  26+ 8158              ;  VK_DELETE VK_EDIT VK_BREAK VK_INV_VID VK_TRUE_VID VK_GRAPH VK_CAPS VK_EXTEND $Register B1 bits 7 to 0
  27+ 8158              ; Default map
  28+ 8158              ;-----------------------------------------------------------------------------------------------------------------------------------
  29+ 8158              ;   0          1           2             3              4           5           6           7           8           9
  30+ 8158              ;   VK_CAPS    VK_Z        VK_X,         VK_C,          VK_V,       VK_A        VK_S,       VK_D,       VK_F,       VK_G
  31+ 8158              ;              GameSkip                  Equip          SelLCargo   Climb       Decelerate  Recentre    FireM       HomeCursor
  32+ 8158              ;                                                                                                       Find System
  33+ 8158              ;-----------------------------------------------------------------------------------------------------------------------------------
  34+ 8158              ;   10         11          12            13             14          15          16          17          18          19
  35+ 8158              ;   VK_Q       VK_W,       VK_E,         VK_R,          VK_T,       VK_1        VK_2        VK_3        VK_4        VK_5
  36+ 8158              ;   Dive       Accelerate  ECM           UnarmMissile   TargetM     FrontV      AftV        LeftV       RightV      GalacticChart
  37+ 8158              ;-----------------------------------------------------------------------------------------------------------------------------------
  38+ 8158              ;   20         Accel       22            23             24          25          26          27          28          29
  39+ 8158              ;   VK_0       VK_9,       VK_8,         VK_7,          VK_6,       VK_P ,      VK_O,       VK_I,       VK_U,       VK_Y
  40+ 8158              ;   EscapePod  Inventory   Status        MarketPrices   LocalChart  RollRight   RolLLeft                EnergyBomb  Quit
  41+ 8158              ;   PlanetData                                                      PauseGame   SaveGame
  42+ 8158              ;-----------------------------------------------------------------------------------------------------------------------------------
  43+ 8158              ;   30         31          32            33             34          Right       36          37          EnergyBomb  39
  44+ 8158              ;   VK_ENTER   VK_L,       VK_K,         VK_J,          VK_H,       VK_SPACE    VK_SYM,     VK_M,       VK_N,       VK_B
  45+ 8158              ;              Launch                    Distance       Hyperspace  Laser                               DockComp    BuyCargo
  46+ 8158              ;              ResumeGame                WarpJump
  47+ 8158              ;-----------------------------------------------------------------------------------------------------------------------------------
  48+ 8158              ;   40         41          42            43             44          45          46          47          48          49
  49+ 8158              ;   VK_SEMI    VK_QUOTE    VK_COMMA      VK_STOP        VK_UP       VK_DOWN     VK_LEFT     VK _RIGHT   VK_DELETE   VK_EDIT
  50+ 8158              ;   Market     EquipShip   PlanetData    NearestObject  Map Cursor no auto repeat....................   Delete      Find System
  51+ 8158              ;
  52+ 8158              ;-----------------------------------------------------------------------------------------------------------------------------------
  53+ 8158              ;   50         51          52            53             54          55
  54+ 8158              ;   VK_BREAK   VK_INV_VID  VK_TRUE_VID   VK_GRAPH       VK_EXTCAPS  VK_EXTEND
  55+ 8158              ;   EscapePod  Inventory   Status        GalacticChart  LocalChart  SystemJump
  56+ 8158              ;
  57+ 8158
  58+ 8158              ; You can read address to check keystate by address KeyboardMap + c_Pressed corresponding key. There is also an addr_ helper too
  59+ 8158
  60+ 8158              c_Pressed_Front         equ 0  * 2
  61+ 8158              c_Pressed_Aft           equ 1  * 2
  62+ 8158              c_Pressed_Left          equ 2  * 2
  63+ 8158              c_Pressed_Right         equ 3  * 2
  64+ 8158              c_Pressed_RollLeft      equ 4  * 2
  65+ 8158              c_Pressed_RollRight     equ 5  * 2
  66+ 8158              c_Pressed_Dive          equ 6  * 2
  67+ 8158              c_Pressed_Climb         equ 7  * 2
  68+ 8158              c_Pressed_Accellerate   equ 8  * 2
  69+ 8158              c_Pressed_Decellerate   equ 9  * 2
  70+ 8158              c_Pressed_FireLaser     equ 10 * 2
  71+ 8158              c_Pressed_TargetMissle  equ 11 * 2
  72+ 8158              c_Pressed_FireMissile   equ 12 * 2
  73+ 8158              c_Pressed_UnarmMissile  equ 13 * 2
  74+ 8158              c_Pressed_ECM           equ 14 * 2
  75+ 8158              c_Pressed_EnergyBomb    equ 15 * 2
  76+ 8158              c_Pressed_EscapePod     equ 16 * 2
  77+ 8158              c_Pressed_DockingComp   equ 17 * 2
  78+ 8158              c_Pressed_Hyperspace    equ 18 * 2
  79+ 8158              c_Pressed_Distance      equ 19 * 2
  80+ 8158              c_Pressed_HomeCursor    equ 20 * 2
  81+ 8158              c_Pressed_Launch        equ 21 * 2
  82+ 8158              c_Pressed_BuyCargo      equ 22 * 2
  83+ 8158              c_Pressed_SellCargo     equ 23 * 2
  84+ 8158              c_Pressed_Equip         equ 24 * 2
  85+ 8158              c_Pressed_GalacticChrt  equ 25 * 2
  86+ 8158              c_Pressed_LocalChart    equ 26 * 2
  87+ 8158              c_Pressed_MarketPrices  equ 27 * 2
  88+ 8158              c_Pressed_Status        equ 28 * 2
  89+ 8158              c_Pressed_Inventory     equ 29 * 2
  90+ 8158              c_Pressed_GameSkip      equ 30 * 2
  91+ 8158              c_Pressed_Save          equ 31 * 2
  92+ 8158              c_Pressed_Freeze        equ 32 * 2
  93+ 8158              c_Pressed_Resume        equ 33 * 2
  94+ 8158              c_Pressed_Recentre      equ 34 * 2
  95+ 8158              c_Pressed_Quit          equ 35 * 2
  96+ 8158              c_Pressed_PlanetData    equ 36 * 2
  97+ 8158              c_Pressed_CursorUp      equ 37 * 2
  98+ 8158              c_Pressed_CursorDown    equ 38 * 2
  99+ 8158              c_Pressed_Find          equ 39 * 2
 100+ 8158              c_Pressed_Yes           equ 40 * 2
 101+ 8158              c_Pressed_No            equ 41 * 2
 102+ 8158              c_Pressed_Warp          equ 42 * 2
 103+ 8158              c_Pressed_ExtMarket     equ 43 * 2
 104+ 8158              c_Pressed_ExtEquip      equ 44 * 2
 105+ 8158              c_Pressed_ExtPlanet     equ 45 * 2
 106+ 8158              c_Pressed_ExtNearest    equ 46 * 2
 107+ 8158              c_Pressed_ExtCurUp      equ 47 * 2
 108+ 8158              c_Pressed_ExtCurDown    equ 48 * 2
 109+ 8158              c_Pressed_ExtCurLeft    equ 49 * 2
 110+ 8158              c_Pressed_ExtCurRight   equ 50 * 2
 111+ 8158              c_Pressed_ExtDelete     equ 51 * 2
 112+ 8158              c_Pressed_ExtFindSystem equ 52 * 2
 113+ 8158              c_Pressed_ExtEscapePod  equ 53 * 2
 114+ 8158              c_Pressed_ExtInventory  equ 54 * 2
 115+ 8158              c_Pressed_ExtStatus     equ 55 * 2
 116+ 8158              c_Pressed_ExtGlactic    equ 56 * 2
 117+ 8158              c_Pressed_ExtLocal      equ 57 * 2
 118+ 8158              c_Pressed_ExtSystemJump equ 58 * 2
 119+ 8158
 120+ 8158              ; half row 1
 121+ 8158              VK_CAPS  				equ 0
 122+ 8158              VK_Z  					equ 1
 123+ 8158              VK_X  					equ 2
 124+ 8158              VK_C  					equ 3
 125+ 8158              VK_V  					equ 4
 126+ 8158              ; half row 2
 127+ 8158              VK_A  					equ 5
 128+ 8158              VK_S  					equ 6
 129+ 8158              VK_D  					equ 7
 130+ 8158              VK_F					equ 8
 131+ 8158              VK_G  					equ 9
 132+ 8158              ; half row 3
 133+ 8158              VK_Q  					equ 10
 134+ 8158              VK_W  					equ 11
 135+ 8158              VK_E  					equ 12
 136+ 8158              VK_R  					equ 13
 137+ 8158              VK_T  					equ 14
 138+ 8158              ; half row 4
 139+ 8158              VK_1  					equ 15
 140+ 8158              VK_2  					equ 16
 141+ 8158              VK_3  					equ 17
 142+ 8158              VK_4  					equ 18
 143+ 8158              VK_5  					equ 19
 144+ 8158              ; half row 5
 145+ 8158              VK_0 					equ 20
 146+ 8158              VK_9 					equ 21
 147+ 8158              VK_8 					equ 22
 148+ 8158              VK_7 					equ 23
 149+ 8158              VK_6 					equ 24
 150+ 8158              ; half row 6
 151+ 8158              VK_P  					equ 25
 152+ 8158              VK_O  					equ 26
 153+ 8158              VK_I  					equ 27
 154+ 8158              VK_U  					equ 28
 155+ 8158              VK_Y  					equ 29
 156+ 8158              ; half row 7
 157+ 8158              VK_ENTER 				equ 30
 158+ 8158              VK_L  					equ 31
 159+ 8158              VK_K  					equ 32
 160+ 8158              VK_J  					equ 33
 161+ 8158              VK_H  					equ 34
 162+ 8158              ; half row 8
 163+ 8158              VK_SPACE 				equ 35
 164+ 8158              VK_SYM  				equ 36
 165+ 8158              VK_M  					equ 37
 166+ 8158              VK_N  					equ 38
 167+ 8158              VK_B  					equ 39
 168+ 8158              ; Extended Group B0
 169+ 8158              VK_SEMI                 equ 40
 170+ 8158              VK_QUOTE                equ 41
 171+ 8158              VK_COMMA                equ 42
 172+ 8158              VK_STOP                 equ 43
 173+ 8158              VK_UP                   equ 44
 174+ 8158              VK_DOWN                 equ 45
 175+ 8158              VK_LEFT                 equ 46
 176+ 8158              VK_RIGHT                equ 47
 177+ 8158              ; Extended Group B1
 178+ 8158              VK_DELETE               equ 48
 179+ 8158              VK_EDIT                 equ 49
 180+ 8158              VK_BREAK                equ 50
 181+ 8158              VK_INV_VID              equ 51
 182+ 8158              VK_TRUE_VID             equ 52
 183+ 8158              VK_GRAPH                equ 53
 184+ 8158              VK_EXTCAPS              equ 54
 185+ 8158              VK_EXTEND               equ 55
 186+ 8158              ;KeyboardMapping
 187+ 8158              KeyCode_Front        	equ VK_1
 188+ 8158              KeyCode_Aft          	equ VK_2
 189+ 8158              KeyCode_Left         	equ VK_3
 190+ 8158              KeyCode_Right        	equ VK_4
 191+ 8158              KeyCode_RollLeft     	equ VK_O
 192+ 8158              KeyCode_RollRight    	equ VK_P
 193+ 8158              KeyCode_Dive         	equ VK_Q
 194+ 8158              KeyCode_Climb        	equ VK_A
 195+ 8158              KeyCode_Accellerate  	equ VK_W
 196+ 8158              KeyCode_Decellerate  	equ VK_S
 197+ 8158              KeyCode_FireLaser    	equ VK_SPACE
 198+ 8158              KeyCode_TargetMissle 	equ VK_T
 199+ 8158              KeyCode_FireMissile  	equ VK_STOP
 200+ 8158              KeyCode_Find        	equ VK_F
 201+ 8158              KeyCode_UnarmMissile 	equ VK_R
 202+ 8158              KeyCode_ECM          	equ VK_E
 203+ 8158              KeyCode_EnergyBomb   	equ VK_U
 204+ 8158              KeyCode_EscapePod    	equ VK_CAPS
 205+ 8158              KeyCode_DockingComp  	equ VK_N
 206+ 8158              KeyCode_Hyperspace   	equ VK_H
 207+ 8158              KeyCode_Distance     	equ VK_J
 208+ 8158              KeyCode_HomeCursor   	equ VK_G
 209+ 8158              KeyCode_Launch       	equ VK_L
 210+ 8158              KeyCode_BuyCargo     	equ VK_B
 211+ 8158              KeyCode_SellCargo    	equ VK_V
 212+ 8158              KeyCode_Equip        	equ VK_C
 213+ 8158              KeyCode_GalacticChrt 	equ VK_5
 214+ 8158              KeyCode_LocalChart   	equ VK_6
 215+ 8158              KeyCode_MarketPrices 	equ VK_7
 216+ 8158              KeyCode_Status       	equ VK_8
 217+ 8158              KeyCode_Inventory    	equ VK_9
 218+ 8158              KeyCode_GameSkip     	equ VK_Z
 219+ 8158              KeyCode_Save         	equ VK_O
 220+ 8158              KeyCode_Freeze       	equ VK_B
 221+ 8158              KeyCode_Resume       	equ VK_L
 222+ 8158              KeyCode_Recentre     	equ VK_STOP
 223+ 8158              KeyCode_Quit         	equ VK_Y
 224+ 8158              KeyCode_PlanetData   	equ VK_0
 225+ 8158              KeyCode_CursorUp        equ VK_Q
 226+ 8158              KeyCode_CursorDown      equ VK_A
 227+ 8158              KeyCode_PressedYes      equ VK_Y
 228+ 8158              KeyCode_PressedNo       equ VK_N
 229+ 8158              KeyCode_Warp            equ VK_J
 230+ 8158              KeyCode_ExtMarket       equ VK_SEMI
 231+ 8158              KeyCode_ExtEquip        equ VK_QUOTE
 232+ 8158              KeyCode_ExtPlanet       equ VK_COMMA
 233+ 8158              KeyCode_ExtNearest      equ VK_STOP
 234+ 8158              KeyCode_ExtCurUp        equ VK_UP
 235+ 8158              KeyCode_ExtCurDown      equ VK_DOWN
 236+ 8158              KeyCode_ExtCurLeft      equ VK_LEFT
 237+ 8158              KeyCode_ExtCurRight     equ VK_RIGHT
 238+ 8158              KeyCode_ExtDelete       equ VK_DELETE
 239+ 8158              KeyCode_ExtFindSystem   equ VK_EDIT
 240+ 8158              KeyCode_ExtEscapePod    equ VK_BREAK
 241+ 8158              KeyCode_ExtInventory    equ VK_INV_VID
 242+ 8158              KeyCode_ExtStatus       equ VK_TRUE_VID
 243+ 8158              KeyCode_ExtGlactic      equ VK_GRAPH
 244+ 8158              KeyCode_ExtLocal        equ VK_EXTCAPS
 245+ 8158              KeyCode_ExtSystemJump   equ VK_EXTEND
 246+ 8158
 247+ 8158 00 00 00...  Keys					DS	55          ; This is the list of key states for all the VK keys presssed i.e. VK_CAPS through to VK_B
 248+ 818F              c_KeyBoardLen 			equ $ - Keys
 249+ 818F 00 00 00...  RawKeys					DS	10          ; increased for extended keys
 250+ 8199 FE FD FB F7  KeyAddrTab				DB	$FE, $FD, $FB, $F7, $EF, $DF, $BF, $7F
 250+ 819D EF DF BF 7F
 251+ 81A1              ; Now keyboard map lists each game key and the corresponding address in the Keys table to get the value. This way redefining keys is just a case
 252+ 81A1              ; of updating this table with the respective location to look up
 253+ 81A1              ; key list sequence is in table above
 254+ 81A1 67 81 68 81  KeyboardMap             DW  Keys+KeyCode_Front        ,Keys+KeyCode_Aft          ,Keys+KeyCode_Left         ,Keys+KeyCode_Right        ,Keys+KeyCode_RollLeft
 254+ 81A5 69 81 6A 81
 254+ 81A9 72 81
 255+ 81AB 71 81 62 81                          DW  Keys+KeyCode_RollRight    ,Keys+KeyCode_Dive         ,Keys+KeyCode_Climb        ,Keys+KeyCode_Accellerate  ,Keys+KeyCode_Decellerate
 255+ 81AF 5D 81 63 81
 255+ 81B3 5E 81
 256+ 81B5 7B 81 66 81                          DW  Keys+KeyCode_FireLaser    ,Keys+KeyCode_TargetMissle ,Keys+KeyCode_FireMissile  ,Keys+KeyCode_UnarmMissile ,Keys+KeyCode_ECM
 256+ 81B9 83 81 65 81
 256+ 81BD 64 81
 257+ 81BF 74 81 58 81                          DW  Keys+KeyCode_EnergyBomb   ,Keys+KeyCode_EscapePod    ,Keys+KeyCode_DockingComp  ,Keys+KeyCode_Hyperspace   ,Keys+KeyCode_Distance
 257+ 81C3 7E 81 7A 81
 257+ 81C7 79 81
 258+ 81C9 61 81 77 81                          DW  Keys+KeyCode_HomeCursor   ,Keys+KeyCode_Launch       ,Keys+KeyCode_BuyCargo     ,Keys+KeyCode_SellCargo    ,Keys+KeyCode_Equip
 258+ 81CD 7F 81 5C 81
 258+ 81D1 5B 81
 259+ 81D3 6B 81 70 81                          DW  Keys+KeyCode_GalacticChrt ,Keys+KeyCode_LocalChart   ,Keys+KeyCode_MarketPrices ,Keys+KeyCode_Status       ,Keys+KeyCode_Inventory
 259+ 81D7 6F 81 6E 81
 259+ 81DB 6D 81
 260+ 81DD 59 81 72 81                          DW  Keys+KeyCode_GameSkip     ,Keys+KeyCode_Save         ,Keys+KeyCode_Freeze       ,Keys+KeyCode_Resume       ,Keys+KeyCode_Recentre
 260+ 81E1 7F 81 77 81
 260+ 81E5 83 81
 261+ 81E7 75 81 6C 81                          DW  Keys+KeyCode_Quit         ,Keys+KeyCode_PlanetData   ,Keys+KeyCode_CursorUp     ,Keys+KeyCode_CursorDown   ,Keys+KeyCode_Find
 261+ 81EB 62 81 5D 81
 261+ 81EF 60 81
 262+ 81F1 75 81 7E 81                          DW  Keys+KeyCode_PressedYes   ,Keys+KeyCode_PressedNo    ,Keys+KeyCode_Warp         ,Keys+KeyCode_ExtMarket    ,Keys+KeyCode_ExtEquip
 262+ 81F5 79 81 80 81
 262+ 81F9 81 81
 263+ 81FB 82 81 83 81                          DW  Keys+KeyCode_ExtPlanet    ,Keys+KeyCode_ExtNearest   ,Keys+KeyCode_ExtCurUp     ,Keys+KeyCode_ExtCurDown   ,Keys+KeyCode_ExtCurLeft
 263+ 81FF 84 81 85 81
 263+ 8203 86 81
 264+ 8205 87 81 88 81                          DW  Keys+KeyCode_ExtCurRight  ,Keys+KeyCode_ExtDelete    ,Keys+KeyCode_ExtFindSystem,Keys+KeyCode_ExtEscapePod ,Keys+KeyCode_ExtInventory
 264+ 8209 89 81 8A 81
 264+ 820D 8B 81
 265+ 820F 8C 81 8D 81                          DW  Keys+KeyCode_ExtStatus    ,Keys+KeyCode_ExtGlactic   ,Keys+KeyCode_ExtLocal     ,Keys+KeyCode_ExtSystemJump
 265+ 8213 8E 81 8F 81
 266+ 8217              s
 267+ 8217 3F 5A 58 43  ASCII_Map:              DB "?","Z","X","C","V"
 267+ 821B 56
 268+ 821C 41 53 44 46                          DB "A","S","D","F","G"
 268+ 8220 47
 269+ 8221 51 57 45 52                          DB "Q","W","E","R","T"
 269+ 8225 54
 270+ 8226 31 32 33 34                          DB "1","2","3","4","5"
 270+ 822A 35
 271+ 822B 30 39 38 37                          DB "0","9","8","7","6"
 271+ 822F 36
 272+ 8230 50 4F 49 55                          DB "P","O","I","U","Y"
 272+ 8234 59
 273+ 8235 3E 4C 4B 4A                          DB ">","L","K","J","H"
 273+ 8239 48
 274+ 823A 20 5E 4D 4E                          DB " ","^","M","N","B"
 274+ 823E 42
 275+ 823F 3F 3F 3F 3F                          DB "?","?","?","?","?"  ; Extended keys
 275+ 8243 3F
 276+ 8244 3F 3F 3F 23                          DB "?","?","?","#","?"  ; delete key is marked as hash
 276+ 8248 3F
 277+ 8249 3F 3F 3F 3F                          DB "?","?","?","?","?"
 277+ 824D 3F
 278+ 824E 3F                                   DB "?"
 279+ 824F              ; mapping of a code to the lookup table Keyboard map. So if you are using an addr_Pressed you can then fetch from KeyboardMap the address in Keys
 280+ 824F              ; for the raw key press status
 281+ 824F              addr_Pressed_Front         equ KeyboardMap+c_Pressed_Front
 282+ 824F              addr_Pressed_Aft           equ KeyboardMap+c_Pressed_Aft
 283+ 824F              addr_Pressed_Left          equ KeyboardMap+c_Pressed_Left
 284+ 824F              addr_Pressed_Right         equ KeyboardMap+c_Pressed_Right
 285+ 824F              addr_Pressed_RollLeft      equ KeyboardMap+c_Pressed_RollLeft
 286+ 824F              addr_Pressed_RollRight     equ KeyboardMap+c_Pressed_RollRight
 287+ 824F              addr_Pressed_Dive          equ KeyboardMap+c_Pressed_Dive
 288+ 824F              addr_Pressed_Climb         equ KeyboardMap+c_Pressed_Climb
 289+ 824F              addr_Pressed_Accellerate   equ KeyboardMap+c_Pressed_Accellerate
 290+ 824F              addr_Pressed_Decellerate   equ KeyboardMap+c_Pressed_Decellerate
 291+ 824F              addr_Pressed_FireLaser     equ KeyboardMap+c_Pressed_FireLaser
 292+ 824F              addr_Pressed_TargetMissle  equ KeyboardMap+c_Pressed_TargetMissle
 293+ 824F              addr_Pressed_FireMissile   equ KeyboardMap+c_Pressed_FireMissile
 294+ 824F              addr_Pressed_UnarmMissile  equ KeyboardMap+c_Pressed_UnarmMissile
 295+ 824F              addr_Pressed_ECM           equ KeyboardMap+c_Pressed_ECM
 296+ 824F              addr_Pressed_EnergyBomb    equ KeyboardMap+c_Pressed_EnergyBomb
 297+ 824F              addr_Pressed_EscapePod     equ KeyboardMap+c_Pressed_EscapePod
 298+ 824F              addr_Pressed_DockingComp   equ KeyboardMap+c_Pressed_DockingComp
 299+ 824F              addr_Pressed_Hyperspace    equ KeyboardMap+c_Pressed_Hyperspace
 300+ 824F              addr_Pressed_Distance      equ KeyboardMap+c_Pressed_Distance
 301+ 824F              addr_Pressed_HomeCursor    equ KeyboardMap+c_Pressed_HomeCursor
 302+ 824F              addr_Pressed_Launch        equ KeyboardMap+c_Pressed_Launch
 303+ 824F              addr_Pressed_BuyCargo      equ KeyboardMap+c_Pressed_BuyCargo
 304+ 824F              addr_Pressed_SellCargo     equ KeyboardMap+c_Pressed_SellCargo
 305+ 824F              addr_Pressed_Equip         equ KeyboardMap+c_Pressed_Equip
 306+ 824F              addr_Pressed_GalacticChrt  equ KeyboardMap+c_Pressed_GalacticChrt
 307+ 824F              addr_Pressed_LocalChart    equ KeyboardMap+c_Pressed_LocalChart
 308+ 824F              addr_Pressed_MarketPrices  equ KeyboardMap+c_Pressed_MarketPrices
 309+ 824F              addr_Pressed_Status        equ KeyboardMap+c_Pressed_Status
 310+ 824F              addr_Pressed_Inventory     equ KeyboardMap+c_Pressed_Inventory
 311+ 824F              addr_Pressed_GameSkip      equ KeyboardMap+c_Pressed_GameSkip
 312+ 824F              addr_Pressed_Save          equ KeyboardMap+c_Pressed_Save
 313+ 824F              addr_Pressed_Freeze        equ KeyboardMap+c_Pressed_Freeze
 314+ 824F              addr_Pressed_Resume        equ KeyboardMap+c_Pressed_Resume
 315+ 824F              addr_Pressed_Recentre      equ KeyboardMap+c_Pressed_Recentre
 316+ 824F              addr_Pressed_Quit          equ KeyboardMap+c_Pressed_Quit
 317+ 824F              addr_Pressed_PlanetData    equ KeyboardMap+c_Pressed_PlanetData
 318+ 824F              addr_Pressed_CursorUp      equ KeyboardMap+c_Pressed_CursorUp
 319+ 824F              addr_Pressed_CursorDown    equ KeyboardMap+c_Pressed_CursorDown
 320+ 824F              addr_Pressed_Find          equ KeyboardMap+c_Pressed_Find
 321+ 824F              addr_Pressed_Warp          equ KeyboardMap+c_Pressed_Warp
 322+ 824F
 323+ 824F
 324+ 824F              MIsKeyPressed:          MACRO   keyaddress, misstarget
 325+ 824F ~                                    ld      hl,(keyaddress)
 326+ 824F ~                                    ld      a,(hl)
 327+ 824F ~                                    JumpIfAIsZero   misstarget
 328+ 824F                                      ENDM
 329+ 824F
 330+ 824F 21 58 81     init_keyboard:          ld		hl,Keys                         ; no key s are pressed by default
 331+ 8252 11 37 00                             ld		de, c_KeyBoardLen               ;
 332+ 8255 3E 00                                ld		a,0                             ;
 333+ 8257 CD 1D 81                             call	memfill_dma                     ;
 334+ 825A C9                                   ret                                     ;
 335+ 825B
 336+ 825B
 337+ 825B
 338+ 825B DD 21 8F 81  scan_keyboard:          ld		ix,RawKeys                      ; hl = table of raw IO port readings
 339+ 825F 21 99 81                             ld		hl,KeyAddrTab                   ; de = table of IO ports to read
 340+ 8262 0E 08                                ld		c,8                             ; 8 ports to ready
 341+ 8264 11 58 81                             ld      de,Keys                         ; ix = table of key states from raw read
 342+ 8267 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
 343+ 8268 DB FE                                in		a,($FE)							; read port to a
 344+ 826A DD 77 00                             ld      (ix+0),a                        ; save raw scan
 345+ 826D DD 23                                inc     ix
 346+ 826F 23                                   inc		hl                              ; and ready for next read
 347+ 8270 06 05        .ProcessInputBits:      ld		b,5								; loop all bits (there are only 5 keys to a group)
 348+ 8272 1F           .ProcessBitsLoop:       rra                                     ; shit bit 0 into carry
 349+ 8273 30 08                                jr      nc,.SetKeyPressed               ; low bit means it was pressed
 350+ 8275 FD 6F                                ld      iyl,a
 351+ 8277                                      ZeroA
 351+ 8277 AF          >                        xor a
 352+ 8278 C3 85 82                             jp      .SetKey
 353+ 827B 20 0B                                jr		nz,.SkipKeySet
 354+ 827D FD 6F        .SetKeyPressed:	        ld      iyl,a                           ; save current input byte
 355+ 827F 1A                                   ld      a,(de)                          ; get current keystate
 356+ 8280 FE 02                                cp      2
 357+ 8282 28 02                                jr      z,.AlreadyHeld
 358+ 8284 3C                                   inc     a                               ; and increment by 1 as its moved from previous state
 359+ 8285 12           .SetKey:                ld		(de),a				  	        ; save key Pressed state
 360+ 8286 FD 7D        .AlreadyHeld:           ld      a,iyl                           ; and retrieve the current input byte
 361+ 8288 13           .SkipKeySet:	        inc		de								; move to next key
 362+ 8289 10 E7                                djnz	.ProcessBitsLoop				; Process all key group bits
 363+ 828B 0D                                   dec     c                               ; thats one row of bits all processed
 364+ 828C 20 D9                                jr      nz,.PortReadLoop				; Read next input port
 365+ 828E              .ReadExtend0:           GetNextReg EXTENDED_KEYS_0_REGISTER
 365+ 828E 01 3B 24    >            ld bc,$243B
 365+ 8291 3E B0       >            ld a,EXTENDED_KEYS_0_REGISTER
 365+ 8293 ED 79       >            out (c),a
 365+ 8295 04          >            inc b
 365+ 8296 ED 78       >            in a,(c)
 366+ 8298 32 97 81                             ld      (RawKeys+8),a                      ; save to extended slot
 367+ 829B 06 08                                ld      b,8
 368+ 829D 21 80 81                             ld      hl,Keys + VK_SEMI
 369+ 82A0 17           .ProcessExtend0:        rla                                     ; shift bits left into carry for extended keys
 370+ 82A1 30 04                                jr      nc,.SetExtend0KeyPressed
 371+ 82A3              .Extend0NotPressed:     ZeroA
 371+ 82A3 AF          >                        xor a
 372+ 82A4 C3 AD 82                             jp      .SetExtend0Key
 373+ 82A7 7E           .SetExtend0KeyPressed:  ld      a,(hl)
 374+ 82A8 FE 02                                cp      2
 375+ 82AA 28 02                                jr      z,.Extend0AlreadyHeld
 376+ 82AC 3C                                   inc     a
 377+ 82AD 77           .SetExtend0Key:         ld      (hl),a
 378+ 82AE 23           .Extend0AlreadyHeld:    inc     hl
 379+ 82AF 10 EF                                djnz    .ProcessExtend0
 380+ 82B1              .ReadExtend1:           GetNextReg EXTENDED_KEYS_1_REGISTER
 380+ 82B1 01 3B 24    >            ld bc,$243B
 380+ 82B4 3E B1       >            ld a,EXTENDED_KEYS_1_REGISTER
 380+ 82B6 ED 79       >            out (c),a
 380+ 82B8 04          >            inc b
 380+ 82B9 ED 78       >            in a,(c)
 381+ 82BB 32 98 81                             ld      (RawKeys+9),a                      ; save to extended slot
 382+ 82BE 06 08                                ld      b,8
 383+ 82C0 21 88 81                             ld      hl,Keys + VK_DELETE
 384+ 82C3 17           .ProcessExtend1:        rla                                     ; shift bits left into carry for extended keys
 385+ 82C4 30 04                                jr      nc,.SetExtend1KeyPressed
 386+ 82C6              .Extend1NotPressed:     ZeroA
 386+ 82C6 AF          >                        xor a
 387+ 82C7 C3 D0 82                             jp      .SetExtend1Key
 388+ 82CA 7E           .SetExtend1KeyPressed:  ld      a,(hl)
 389+ 82CB FE 02                                cp      2
 390+ 82CD 28 02                                jr      z,.Extend1AlreadyHeld
 391+ 82CF 3C                                   inc     a
 392+ 82D0 77           .SetExtend1Key:         ld      (hl),a
 393+ 82D1 23           .Extend1AlreadyHeld:    inc     hl
 394+ 82D2 10 EF                                djnz    .ProcessExtend1
 395+ 82D4 C9                                   ret
 396+ 82D5
 397+ 82D5
 398+ 82D5
 399+ 82D5              GetKeyStateAddressDE:   MACRO
 400+ 82D5 ~                                    ld      hl,KeyboardMap                  ; work our address to read from
 401+ 82D5 ~                                    add     hl,a
 402+ 82D5 ~                                    ld      e,(hl)
 403+ 82D5 ~                                    inc     hl
 404+ 82D5 ~                                    ld      d,(hl)                          ; now de = address in keypress list
 405+ 82D5                                      ENDM
 406+ 82D5
 407+ 82D5              GetKeyStateAddressHL:   MACRO
 408+ 82D5 ~                                    ld      hl,KeyboardMap                  ; work our address to read from
 409+ 82D5 ~                                    add     hl,a
 410+ 82D5 ~                                    ld      a,(hl)
 411+ 82D5 ~                                    inc     hl
 412+ 82D5 ~                                    ld      h,(hl)                          ; now hl = address in keypress list
 413+ 82D5 ~                                    ld      l,a
 414+ 82D5                                      ENDM
 415+ 82D5
 416+ 82D5
 417+ 82D5              ;;old debug codeCurrentX            DB 0
 418+ 82D5              ;;old debug codeCurrentY            DB 0
 419+ 82D5              ;;old debug code
 420+ 82D5              ;;old debug codedisplayKeyStatus:       xor         a
 421+ 82D5              ;;old debug code                        ld          (CurrentX),a
 422+ 82D5              ;;old debug code                        ld          hl,RawKeys
 423+ 82D5              ;;old debug code                        ld          a,(hl)
 424+ 82D5              ;;old debug code                        and         %00011111
 425+ 82D5              ;;old debug code                        ld          b,5
 426+ 82D5              ;;old debug code.displayLoop:           push        bc,,hl
 427+ 82D5              ;;old debug code                        rra
 428+ 82D5              ;;old debug code                        jr          c,.displayNoPress
 429+ 82D5              ;;old debug code.displayPress:          push        af
 430+ 82D5              ;;old debug code                        ld          a,(CurrentX)
 431+ 82D5              ;;old debug code                        ld          e,a
 432+ 82D5              ;;old debug code                        ld          a,(CurrentY)
 433+ 82D5              ;;old debug code                        ld          d,a
 434+ 82D5              ;;old debug code                        ld          a,'*'
 435+ 82D5              ;;old debug code                        MMUSelectLayer1
 436+ 82D5              ;;old debug code                        call        l1_print_char
 437+ 82D5              ;;old debug code                        ld          a,(CurrentX)
 438+ 82D5              ;;old debug code                        add         a,8
 439+ 82D5              ;;old debug code                        ld          (CurrentX),a
 440+ 82D5              ;;old debug code                        pop         af
 441+ 82D5              ;;old debug code                        pop         bc,,hl
 442+ 82D5              ;;old debug code                        djnz        .displayLoop
 443+ 82D5              ;;old debug code                        ret
 444+ 82D5              ;;old debug code.displayNoPress:        push        af
 445+ 82D5              ;;old debug code                        ld          a,(CurrentX)
 446+ 82D5              ;;old debug code                        ld          e,a
 447+ 82D5              ;;old debug code                        ld          a,(CurrentY)
 448+ 82D5              ;;old debug code                        ld          d,a
 449+ 82D5              ;;old debug code                        ld          a,'O'
 450+ 82D5              ;;old debug code                        MMUSelectLayer1
 451+ 82D5              ;;old debug code                        call        l1_print_char
 452+ 82D5              ;;old debug code                        ld          a,(CurrentX)
 453+ 82D5              ;;old debug code                        add         a,8
 454+ 82D5              ;;old debug code                        ld          (CurrentX),a
 455+ 82D5              ;;old debug code                        pop         af
 456+ 82D5              ;;old debug code                        pop         bc,,hl
 457+ 82D5              ;;old debug code                        djnz        .displayLoop
 458+ 82D5              ;;old debug code                        ret
 459+ 82D5              ;;old debug code
 460+ 82D5              ;;old debug codedisplayDownStatus:      ld  a,(Keys+      KeyCode_CursorUp)
 461+ 82D5              ;;old debug code                        cp  0
 462+ 82D5              ;;old debug code                        jr      z,.displayNoUp
 463+ 82D5              ;;old debug code                        cp  1
 464+ 82D5              ;;old debug code                        jr      z,.displayUp
 465+ 82D5              ;;old debug code.displayHeld:           ld      de,8*15
 466+ 82D5              ;;old debug code                        ld      a,"*"
 467+ 82D5              ;;old debug code                        MMUSelectLayer1
 468+ 82D5              ;;old debug code                        call        l1_print_char
 469+ 82D5              ;;old debug code                        ret
 470+ 82D5              ;;old debug code.displayUp:             ld      de,8*15
 471+ 82D5              ;;old debug code                        ld      a,"+"
 472+ 82D5              ;;old debug code                        MMUSelectLayer1
 473+ 82D5              ;;old debug code                        call        l1_print_char
 474+ 82D5              ;;old debug code                        ret
 475+ 82D5              ;;old debug code.displayNoUp:             ld      de,8*15
 476+ 82D5              ;;old debug code                        ld      a,"O"
 477+ 82D5              ;;old debug code                        MMUSelectLayer1
 478+ 82D5              ;;old debug code                        call        l1_print_char
 479+ 82D5              ;;old debug code                        ret
 480+ 82D5              ;;old debug code
 481+ 82D5
 482+ 82D5
 483+ 82D5              ; call with a = c_Pressed key, will then read mapping does this with keyboard scan, waits until key gets to state 1, if it was already held then#
 484+ 82D5              ; it will have to be let go to reset of 0 and scan again
 485+ 82D5              ; Deprecated as not used as yet
 486+ 82D5              ;;;;;;wait_for_key_a_press:   GetKeyStateAddressHL
 487+ 82D5              ;;;;;;                        push    hl
 488+ 82D5              ;;;;;;.wait_loop:             call    scan_keyboard
 489+ 82D5              ;;;;;;                        pop     hl                              ; get key address into hl
 490+ 82D5              ;;;;;;                        push    hl
 491+ 82D5              ;;;;;;                        ld      a,(hl)
 492+ 82D5              ;;;;;;                        JumpIfANENusng  1,.wait_loop             ; will also loop if held down when entering this routine
 493+ 82D5              ;;;;;;                        pop     hl                              ; tidy up rogue push, less t states than detecting if we want to push or not
 494+ 82D5              ;;;;;;                        ret
 495+ 82D5              ;;;;;;; call with a = c_Pressed key, will then read mapping does this with keyboard scan waits until key gets to state 2
 496+ 82D5              ;;;;;;wait_for_key_a_held:    GetKeyStateAddressDE
 497+ 82D5              ;;;;;;                        push    hl
 498+ 82D5              ;;;;;;.wait_loop:             call    scan_keyboard
 499+ 82D5              ;;;;;;                        pop     hl
 500+ 82D5              ;;;;;;                        push    hl
 501+ 82D5              ;;;;;;                        ld      a,(hl)
 502+ 82D5              ;;;;;;                        JumpIfALTNusng  2, .wait_loop
 503+ 82D5              ;;;;;;                        pop     hl
 504+ 82D5              ;;;;;;                        ret
 505+ 82D5
 506+ 82D5              ; Gets the current keystate of the c_Pressed Key in a register
 507+ 82D5              get_key_a_state:        GetKeyStateAddressHL                    ; reads a mapped key and sets a to key staus, e.g. 0 1 or >=2 DOES NOT SCAN KEYBOARD
 507+ 82D5 21 A1 81    >                        ld      hl,KeyboardMap                  ; work our address to read from
 507+ 82D8 ED 31       >                        add     hl,a
 507+ 82DA 7E          >                        ld      a,(hl)
 507+ 82DB 23          >                        inc     hl
 507+ 82DC 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 507+ 82DD 6F          >                        ld      l,a
 508+ 82DE 7E                                   ld      a,(hl)                          ; a = keystate
 509+ 82DF C9                                   ret
 510+ 82E0
 511+ 82E0              ; sets they keystate of c pressed key in a register to 1 (pressed)
 512+ 82E0              ; This will be used by auto dock
 513+ 82E0              force_key_press:        GetKeyStateAddressHL                    ; read key locations
 513+ 82E0 21 A1 81    >                        ld      hl,KeyboardMap                  ; work our address to read from
 513+ 82E3 ED 31       >                        add     hl,a
 513+ 82E5 7E          >                        ld      a,(hl)
 513+ 82E6 23          >                        inc     hl
 513+ 82E7 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 513+ 82E8 6F          >                        ld      l,a
 514+ 82E9 3E 01                                ld      a,1
 515+ 82EB 77                                   ld      (hl),a
 516+ 82EC C9                                   ret
 517+ 82ED
 518+ 82ED              is_key_up_state:        GetKeyStateAddressHL
 518+ 82ED 21 A1 81    >                        ld      hl,KeyboardMap                  ; work our address to read from
 518+ 82F0 ED 31       >                        add     hl,a
 518+ 82F2 7E          >                        ld      a,(hl)
 518+ 82F3 23          >                        inc     hl
 518+ 82F4 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 518+ 82F5 6F          >                        ld      l,a
 519+ 82F6 7E                                   ld      a,(hl)
 520+ 82F7 FE 00                                cp      0
 521+ 82F9 C9                                   ret
 522+ 82FA
 523+ 82FA              ; returns z is set if c_ key is pressed
 524+ 82FA              is_key_pressed:         GetKeyStateAddressHL
 524+ 82FA 21 A1 81    >                        ld      hl,KeyboardMap                  ; work our address to read from
 524+ 82FD ED 31       >                        add     hl,a
 524+ 82FF 7E          >                        ld      a,(hl)
 524+ 8300 23          >                        inc     hl
 524+ 8301 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 524+ 8302 6F          >                        ld      l,a
 525+ 8303 7E                                   ld      a,(hl)                          ; a = keystate
 526+ 8304 FE 01                                cp      1                               ; we cant just test bit 0 as this may have been held long
 527+ 8306 C9                                   ret
 528+ 8307
 529+ 8307              ; returns nz is set if c_ key is held, if key was held then keystate would be 2 or 3, i.e. bit 1 set
 530+ 8307              is_key_held:            GetKeyStateAddressHL
 530+ 8307 21 A1 81    >                        ld      hl,KeyboardMap                  ; work our address to read from
 530+ 830A ED 31       >                        add     hl,a
 530+ 830C 7E          >                        ld      a,(hl)
 530+ 830D 23          >                        inc     hl
 530+ 830E 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 530+ 830F 6F          >                        ld      l,a
 531+ 8310 7E                                   ld      a,(hl)                          ; a = keystate
 532+ 8311 E6 02                                and     Bit1Only                        ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
 533+ 8313 C9                                   ret
 534+ 8314
 535+ 8314              ; checks to see if any key is pressed in the key table
 536+ 8314 21 58 81     is_any_key_pressed:     ld      hl,Keys
 537+ 8317 01 28 00                             ld      bc,40
 538+ 831A 3E 01                                ld      a,1
 539+ 831C ED B1                                cpir                                    ; search for the value 1
 540+ 831E 28 03                                jr      z,.KeyPressed                   ; if a key was pressed then handle press
 541+ 8320                                      SetAFalse
 541+ 8320 3E FF       >                        ld      a,$FF
 542+ 8322 C9                                   ret
 543+ 8323 3E 27        .KeyPressed:            ld      a,39                            ; so c will be how many keys still to scan
 544+ 8325 91                                   sub     c                               ; so a = 40 - c to get to result
 545+ 8326 C9                                   ret
 546+ 8327
 547+ 8327 21 58 81     is_any_key_held:        ld      hl,Keys
 548+ 832A 06 28                                ld      b,40
 549+ 832C 0E 00                                ld      c,0
 550+ 832E 7E           .KeyReadLoop:           ld      a,(hl)
 551+ 832F E6 02                                and     Bit1Only                        ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
 552+ 8331 C2 3B 83                             jp      nz,.KeyPressed
 553+ 8334 23                                   inc     hl
 554+ 8335 0C                                   inc     c
 555+ 8336 10 F6                                djnz    .KeyReadLoop
 556+ 8338                                      SetAFalse
 556+ 8338 3E FF       >                        ld      a,$FF
 557+ 833A C9                                   ret
 558+ 833B 79           .KeyPressed:            ld      a,c
 559+ 833C C9                                   ret
 560+ 833D
 561+ 833D
 562+ 833D 21 99 81     WaitForNoKey:           ld      hl,KeyAddrTab                   ; de = table of IO ports to read
 563+ 8340 06 08                                ld		b,8                             ; 8 ports to ready
 564+ 8342 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
 565+ 8343 DB FE                                in		a,($FE)							; read port to a
 566+ 8345 E6 1F                                and     %00011111
 567+ 8347 FE 1F                                cp      %00011111
 568+ 8349 20 F2                                jr      nz ,WaitForNoKey
 569+ 834B 23                                   inc		hl                              ; and ready for next read
 570+ 834C 10 F4                                djnz    .PortReadLoop
 571+ 834E C9                                   ret
 572+ 834F
 573+ 834F F5 D5 C5 E5  WaitForAnyKey:          push    af,,de,,bc,,hl
 574+ 8353 CD 3D 83                             call    WaitForNoKey
 575+ 8356 21 99 81     .waitKeyLoop:           ld		hl,KeyAddrTab                   ; de = table of IO ports to read
 576+ 8359 06 08                                ld		b,8                             ; 8 ports to ready
 577+ 835B 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
 578+ 835C DB FE                                in		a,($FE)							; read port to a
 579+ 835E E6 1F                                and     %00011111
 580+ 8360 FE 1F                                cp      %00011111
 581+ 8362 C2 6C 83                             jp      nz,.WaitComplete
 582+ 8365 C0                                   ret     nz
 583+ 8366 23                                   inc		hl                              ; and ready for next read
 584+ 8367 10 F2                                djnz    .PortReadLoop
 585+ 8369 C3 56 83                             jp      .waitKeyLoop
 586+ 836C E1 C1 D1 F1  .WaitComplete:          pop     af,,de,,bc,,hl
 587+ 8370 C9                                   ret
 588+ 8371
 589+ 8371
 590+ 8371 00 00 00...  InputString             DS  30              ; used for a 30 character input buffer
 591+ 838F 00                                   DB  0               ; end of string marker as a safety
 592+ 8390 00           InputCursor             DB  0
 593+ 8391 00           EnterPressed            DB  0               ; zero notpressed FF pressed
 594+ 8392 00           InputChanged            DB  0
 595+ 8393              InputLimit              EQU 20
 596+ 8393
 597+ 8393 21 71 83     keyboard_copy_input_to_de:  ld      hl,InputString
 598+ 8396 3A 90 83                                 ld      a,(InputCursor)
 599+ 8399 FE 00                                    cp      0
 600+ 839B 28 05                                    jr      z,.NoString
 601+ 839D 4F                                       ld      c,a
 602+ 839E 06 00                                    ld      b,0
 603+ 83A0 ED B0                                    ldir
 604+ 83A2 3E 00        .NoString                   ld      a,0
 605+ 83A4 12                                       ld      (de),a
 606+ 83A5 C9                                       ret
 607+ 83A6
 608+ 83A6 AF           initInputText:          xor     a
 609+ 83A7 32 90 83                             ld      (InputCursor),a
 610+ 83AA                                      SetMemFalse EnterPressed
 610+ 83AA 3E FF       >                        ld      a,$FF
 610+ 83AC 32 91 83    >                        ld      (EnterPressed),a
 611+ 83AF                                      SetMemFalse InputChanged
 611+ 83AF 3E FF       >                        ld      a,$FF
 611+ 83B1 32 92 83    >                        ld      (InputChanged),a
 612+ 83B4 21 71 83                             ld      hl,InputString
 613+ 83B7 06 1E                                ld      b,30
 614+ 83B9 77           .wipeloop:              ld      (hl),a
 615+ 83BA 23                                   inc     hl
 616+ 83BB 10 FC                                djnz    .wipeloop
 617+ 83BD C9                                   ret
 618+ 83BE
 619+ 83BE              InputName:              SetMemFalse InputChanged
 619+ 83BE 3E FF       >                        ld      a,$FF
 619+ 83C0 32 92 83    >                        ld      (InputChanged),a
 620+ 83C3 CD 14 83                             call    is_any_key_pressed
 621+ 83C6 FE FF                                cp      $FF
 622+ 83C8 C8                                   ret     z
 623+ 83C9 4F           .KeyPressed:            ld      c,a
 624+ 83CA 3A 90 83                             ld      a,(InputCursor)                 ; No key so we can now look at if we are at the end of the buffer
 625+ 83CD FE 14                                cp      InputLimit                      ; move to variable later and then cp (hl)
 626+ 83CF 28 0B                                jr      z,.DeleteOrEnterOnly            ;
 627+ 83D1 21 17 82                             ld      hl,ASCII_Map
 628+ 83D4 79                                   ld      a,c
 629+ 83D5 ED 31                                add     hl,a
 630+ 83D7 7E                                   ld      a,(hl)
 631+ 83D8 FE 41                                cp      "A"
 632+ 83DA 30 09                                jr      nc,.AlphaPressed
 633+ 83DC              ; CAPS and Symbol act as delete for now
 634+ 83DC FE 23        .DeleteOrEnterOnly      cp      "#"                             ; if space was  pressed (mapped to Hash in ASCII table))
 635+ 83DE 28 31                                jr      z,.SpacePressed                 ; for now we will ignore the shift and just assume delete
 636+ 83E0 FE 3E                                cp      ">"         ; ENTER
 637+ 83E2 28 17                                jr      z,.EnterPressed
 638+ 83E4 C9                                   ret
 639+ 83E5 47           .AlphaPressed:          ld      b,a
 640+ 83E6 3A 90 83                             ld      a,(InputCursor)
 641+ 83E9 4F                                   ld      c,a
 642+ 83EA 21 71 83                             ld      hl,InputString
 643+ 83ED ED 31                                add     hl,a
 644+ 83EF 78                                   ld      a,b
 645+ 83F0 70                                   ld      (hl),b
 646+ 83F1 79                                   ld      a,c
 647+ 83F2 21 90 83                             ld      hl,InputCursor
 648+ 83F5 34                                   inc     (hl)
 649+ 83F6                                      SetMemTrue InputChanged
 649+ 83F6 AF          >                        xor     a
 649+ 83F7 32 92 83    >                        ld      (InputChanged),a
 650+ 83FA C9                                   ret
 651+ 83FB 3A 90 83     .EnterPressed:          ld      a,(InputCursor)
 652+ 83FE 21 71 83                             ld      hl,InputString
 653+ 8401 ED 31                                add     hl,a
 654+ 8403                                      ZeroA
 654+ 8403 AF          >                        xor a
 655+ 8404 77                                   ld      (hl),a
 656+ 8405                                      SetMemTrue EnterPressed
 656+ 8405 AF          >                        xor     a
 656+ 8406 32 91 83    >                        ld      (EnterPressed),a
 657+ 8409                                      SetMemTrue InputChanged
 657+ 8409 AF          >                        xor     a
 657+ 840A 32 92 83    >                        ld      (InputChanged),a
 658+ 840D CD 4F 82                             call    init_keyboard           ; Flush keyboard status so futher inputs don't auto read the enter key as a second press
 659+ 8410 C9                                   ret
 660+ 8411 3A 90 83     .SpacePressed:          ld      a,(InputCursor)         ; Space = delete
 661+ 8414 FE 00                                cp      0                       ; if input is zero length then can not delete
 662+ 8416 C8                                   ret     z
 663+ 8417 3D                                   dec     a                       ; move back one and update cursor pos
 664+ 8418 32 90 83                             ld      (InputCursor),a         ;
 665+ 841B 21 71 83                             ld      hl,InputString          ; now update end of line to null
 666+ 841E ED 31                                add     hl,a                    ; .
 667+ 8420                                      ZeroA                           ; .
 667+ 8420 AF          >                        xor a
 668+ 8421 77                                   ld      (hl),a                  ; .
 669+ 8422                                      SetMemTrue InputChanged
 669+ 8422 AF          >                        xor     a
 669+ 8423 32 92 83    >                        ld      (InputChanged),a
 670+ 8426 C9                                   ret
 671+ 8427
 672+ 8427              TargetMissileTest:      AnyMissilesLeft
 672+ 8427 3A F6 8A    >                        ld      a,(NbrMissiles)
 672+ 842A A7          >                        and     a
 673+ 842B                                      JumpIfZero      .ClearTargetting
 673+ 842B CA 42 84    >                        jp	z,.ClearTargetting
 674+ 842E                                      IsMissileLaunchFlagged                      ; if we are comitted to launch
 674+ 842E 3A 86 8D    >                        ld      a,(MissileTargettingFlag)
 674+ 8431 E6 80       >                        and     $80
 675+ 8433 C8                                   ret             z                           ; then don't scan as it will be cleared on launch
 676+ 8434 3E 16        .ScanForKey:            ld              a,c_Pressed_TargetMissle    ; if not pressed we are done
 677+ 8436 CD FA 82                             call            is_key_pressed              ; .
 678+ 8439 C0                                   ret             nz                          ; .
 679+ 843A 3A 86 8D     .TargetPressed:         ld              a,(MissileTargettingFlag)   ; get flag back
 680+ 843D                                      JumpIfAEqNusng  StageMissileNotTargeting, .SetTargetting
 680+ 843D FE FF       >                        cp     StageMissileNotTargeting
 680+ 843F CA 48 84    >                        jp      z,.SetTargetting
 681+ 8442              .ClearTargetting:       ClearMissileTargetting
 681+ 8442 3E FF       >                        ld      a,StageMissileNotTargeting
 681+ 8444 32 86 8D    >                        ld      (MissileTargettingFlag),a
 682+ 8447 C9                                   ret
 683+ 8448              .SetTargetting:         SetMissileTargetting
 683+ 8448 3E FE       >                        ld      a,StageMissileTargeting
 683+ 844A 32 86 8D    >                        ld      (MissileTargettingFlag),a
 684+ 844D C9                                   ret
 685+ 844E
 686+ 844E AF           MovementKeyTest:        xor     a
 687+ 844F 32 2D 8C                             ld      (CursorKeysPressed),a
 688+ 8452 3A 60 8A                             ld      a,(MenuIdMax)
 689+ 8455 E6 FC                                and     $FC
 690+ 8457 20 26                                jr      nz,CursorKeys
 691+ 8459 2A AF 81     ClimbDiveKeys:          ld      hl,(addr_Pressed_Climb)                 ; Check for Climb
 692+ 845C 7E                                   ld      a,(hl)
 693+ 845D                                      JumpIfAIsZero ScanDiveKey
 693+ 845D A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 693+ 845E CA 6C 84    >                        jp	    z, ScanDiveKey
 694+ 8461 3A 2D 8C                             ld      a,(CursorKeysPressed)
 695+ 8464 F6 80                                or      CursorClimb
 696+ 8466 32 2D 8C                             ld      (CursorKeysPressed),a
 697+ 8469 C3 A2 84                             jp      ScanLeftKey
 698+ 846C 2A AD 81     ScanDiveKey:            ld      hl,(addr_Pressed_Dive)                  ; Check for Dive
 699+ 846F 7E                                   ld      a,(hl)
 700+ 8470                                      JumpIfAIsZero ScanLeftKey
 700+ 8470 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 700+ 8471 CA A2 84    >                        jp	    z, ScanLeftKey
 701+ 8474 3A 2D 8C                             ld      a,(CursorKeysPressed)
 702+ 8477 F6 40                                or      CursorDive
 703+ 8479 32 2D 8C                             ld      (CursorKeysPressed),a
 704+ 847C C3 A2 84                             jp      ScanLeftKey
 705+ 847F 2A EB 81     CursorKeys:             ld      hl,(addr_Pressed_CursorUp)              ; Check cursor keys
 706+ 8482 7E                                   ld      a,(hl)
 707+ 8483                                      JumpIfAIsZero ScanCursorDownKey
 707+ 8483 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 707+ 8484 CA 92 84    >                        jp	    z, ScanCursorDownKey
 708+ 8487 3A 2D 8C                             ld      a,(CursorKeysPressed)
 709+ 848A F6 80                                or      CursorClimb
 710+ 848C 32 2D 8C                             ld      (CursorKeysPressed),a
 711+ 848F C3 A2 84                             jp      ScanLeftKey
 712+ 8492 2A ED 81     ScanCursorDownKey:      ld      hl,(addr_Pressed_CursorDown)
 713+ 8495 7E                                   ld      a,(hl)
 714+ 8496                                      JumpIfAIsZero ScanLeftKey
 714+ 8496 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 714+ 8497 CA A2 84    >                        jp	    z, ScanLeftKey
 715+ 849A 3A 2D 8C                             ld      a,(CursorKeysPressed)
 716+ 849D F6 40                                or      CursorDive
 717+ 849F 32 2D 8C                             ld      (CursorKeysPressed),a
 718+ 84A2 2A A9 81     ScanLeftKey:            ld      hl,(addr_Pressed_RollLeft)
 719+ 84A5 7E                                   ld      a,(hl)
 720+ 84A6                                      JumpIfAIsZero ScanRightKey
 720+ 84A6 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 720+ 84A7 CA B3 84    >                        jp	    z, ScanRightKey
 721+ 84AA 3A 2D 8C                             ld      a,(CursorKeysPressed)
 722+ 84AD F6 20                                or      CursorLeft
 723+ 84AF 32 2D 8C                             ld      (CursorKeysPressed),a
 724+ 84B2 C9                                   ret
 725+ 84B3 2A AB 81     ScanRightKey:           ld      hl,(addr_Pressed_RollRight)
 726+ 84B6 7E                                   ld      a,(hl)
 727+ 84B7                                      JumpIfAIsZero ScanHomeKey
 727+ 84B7 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 727+ 84B8 CA C4 84    >                        jp	    z, ScanHomeKey
 728+ 84BB 3A 2D 8C                             ld      a,(CursorKeysPressed)
 729+ 84BE F6 10                                or      CursorRight
 730+ 84C0 32 2D 8C                             ld      (CursorKeysPressed),a
 731+ 84C3 C9                                   ret
 732+ 84C4 2A C9 81     ScanHomeKey:            ld      hl,(addr_Pressed_HomeCursor)
 733+ 84C7 7E                                   ld      a,(hl)
 734+ 84C8                                      JumpIfAIsZero ScanRecentreKey
 734+ 84C8 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 734+ 84C9 CA D5 84    >                        jp	    z, ScanRecentreKey
 735+ 84CC 3A 2D 8C                             ld      a,(CursorKeysPressed)
 736+ 84CF F6 08                                or      CursorHome
 737+ 84D1 32 2D 8C                             ld      (CursorKeysPressed),a
 738+ 84D4 C9                                   ret
 739+ 84D5 2A E5 81     ScanRecentreKey:        ld      hl,(addr_Pressed_Recentre)
 740+ 84D8 7E                                   ld      a,(hl)
 741+ 84D9                                      ReturnIfAIsZero
 741+ 84D9 A7          >                        and     a
 741+ 84DA C8          >                        ret     z
 742+ 84DB 3A 2D 8C                             ld      a,(CursorKeysPressed)
 743+ 84DE F6 04                                or      CursorRecenter
 744+ 84E0 32 2D 8C                             ld      (CursorKeysPressed),a
 745+ 84E3 C9                                   ret
 746+ 84E4
 747+ 84E4
# file closed: ./Hardware/keyboard.asm
 193  84E4                  INCLUDE "./Maths/compare16.asm"
# file opened: ./Maths/compare16.asm
   1+ 84E4              ; Input:
   2+ 84E4              ;       HL = 1st value
   3+ 84E4              ;       DE = 2nd value
   4+ 84E4              ; Output:
   5+ 84E4              ;       CF, ZF = results of comparison:
   6+ 84E4              ;
   7+ 84E4              ;               CF      ZF      Result
   8+ 84E4              ;               -----------------------------------
   9+ 84E4              ;               0       0       HL > DE
  10+ 84E4              ;               0       1       HL == DE
  11+ 84E4              ;               1       0       HL < DE
  12+ 84E4              ;               1       1       Impossible
  13+ 84E4              ;
  14+ 84E4
  15+ 84E4 E5           compare16HLDE:      push    hl
  16+ 84E5 A7                               and     a
  17+ 84E6 ED 52                            sbc     hl,de
  18+ 84E8 E1                               pop     hl
  19+ 84E9 C9                               ret
  20+ 84EA
  21+ 84EA              ; With compare signed we do ABS comparison
  22+ 84EA              ; this is used for view ports as we just want to know if its +/- out side of 90 degrees
  23+ 84EA
  24+ 84EA E5 D5        compare16HLDEABS:   push    hl,,de
  25+ 84EC 7C                               ld      a,h                                     ; Quick pass see of both the same sign
  26+ 84ED E6 7F                            and     SignMask8Bit
  27+ 84EF 67                               ld      h,a
  28+ 84F0 7A                               ld      a,d                                     ; Quick pass see of both the same sign
  29+ 84F1 E6 7F                            and     SignMask8Bit
  30+ 84F3 57                               ld      d,a
  31+ 84F4 A7                               and     a
  32+ 84F5 ED 52                            sbc     hl,de
  33+ 84F7 D1 E1                            pop     hl,,de
  34+ 84F9 C9                               ret
  35+ 84FA
  36+ 84FA
# file closed: ./Maths/compare16.asm
 194  84FA                  INCLUDE "./Maths/asm_divide.asm"
# file opened: ./Maths/asm_divide.asm
   1+ 84FA
   2+ 84FA
   3+ 84FA
   4+ 84FA              ;
   5+ 84FA              ;   Set flags E to 11111110
   6+ 84FA              ;   Loop:   A << 2
   7+ 84FA              ;           if carry was 0
   8+ 84FA              ;               if a >= D
   9+ 84FA              ;                   A = A - D
  10+ 84FA              ;                   clear carry (probably irrelevant really)
  11+ 84FA              ;           else
  12+ 84FA
  13+ 84FA              ;               sla flags << bringing in carry of 1
  14+ 84FA              ;               if bit 7 of flag was set then loop
  15+ 84FA              ;                                        elase a = e and exit
  16+ 84FA              ;
  17+ 84FA              ; ">BC_Div_DE: BC = BC / DE. HL = remainder fast divide with unrolled loop BC/DE ==> BC, remainder in HL
  18+ 84FA              ;
  19+ 84FA              ;INPUTS: hl = dividend dbc = divisor
  20+ 84FA              ;OUTPUTS: hl/de -> AHL = quotient CDE = remainder, Carryflag set if divide by 0
  21+ 84FA
  22+ 84FA 57           DVIDT:                  ld      d,a                     ; D = var P+1
  23+ 84FB 3A 53 8A                             ld      a,(varQ)
  24+ 84FE 4F                                   ld      c,a                     ; C = var Q
  25+ 84FF 3A 54 89                             ld      a,(varP)
  26+ 8502 5F                                   ld      e,a                     ; E = var P
  27+ 8503                                      ; Need fast exists on ABS values
  28+ 8503 7A           BAequDEdivC:            ld      a,d                     ; Fast exit is value is 0
  29+ 8504 B3                                   or      e                       ; .
  30+ 8505 28 2A                                jr      z,.ResultIsZero         ; .
  31+ 8507 79                                   ld      a,c                     ; Fast exit is divide by 0
  32+ 8508 A7                                   and     a                       ;
  33+ 8509 28 29                                jr      z,.ResultIsFFFF         ;
  34+ 850B 7A           .SavSign:               ld      a,d                     ; preserve sign of result in var T
  35+ 850C A9                                   xor     c                       ;
  36+ 850D E6 80                                and     $80
  37+ 850F 6F                                   ld      l,a                     ; l = var T
  38+ 8510 3E 00                                ld      a,0
  39+ 8512 06 10                                ld      b,16
  40+ 8514                                      ShiftDELeft1
  40+ 8514 CB 23       >			   sla e
  40+ 8516 CB 12       >			   rl  d
  41+ 8518 CB 21                                sla     c                       ; c = abs c
  42+ 851A CB 39                                srl     c
  43+ 851C CB 17        .DivideLoop:            rl      a
  44+ 851E                                      JumpIfALTNusng c, .SkipSubtract
  44+ 851E B9          >                        cp      c
  44+ 851F DA 25 85    >                        jp		c, .SkipSubtract
  45+ 8522                                      ClearCarryFlag
  45+ 8522 B7          >                        or a
  46+ 8523 99                                   sbc     c
  47+ 8524                                      ClearCarryFlag
  47+ 8524 B7          >                        or a
  48+ 8525 3F           .SkipSubtract:          ccf
  49+ 8526 CB 13                                rl      e
  50+ 8528 CB 12                                rl      d
  51+ 852A 05                                   dec     b
  52+ 852B 20 EF                                jr      nz,.DivideLoop
  53+ 852D 7B                                   ld      a,e
  54+ 852E B5                                   or      l
  55+ 852F 42                                   ld      b,d
  56+ 8530 C9                                   ret
  57+ 8531              .ResultIsZero:          ZeroA
  57+ 8531 AF          >                        xor a
  58+ 8532 47                                   ld      b,a
  59+ 8533 C9                                   ret
  60+ 8534 3E FF        .ResultIsFFFF:          ld      a,$FF
  61+ 8536 47                                   ld      b,a
  62+ 8537 C9                                   ret
  63+ 8538
  64+ 8538 57           DIV96:                  ld      d,a                     ; D = var P+1
  65+ 8539 3A 53 8A                             ld      a,(varQ)
  66+ 853C 0E 60                                ld      c,96                    ; C = var Q
  67+ 853E 3A 54 89                             ld      a,(varP)
  68+ 8541 5F                                   ld      e,a                     ; E = var P
  69+ 8542                                      ; Need fast exists on ABS values
  70+ 8542 7A           BAequDEdiv96            ld      a,d                     ; Fast exit is value is 0
  71+ 8543 B3                                   or      e                       ; .
  72+ 8544 28 26                                jr      z,.ResultIsZero         ; .
  73+ 8546 7A           .SavSign:               ld      a,d                     ; preserve sign of result in var T
  74+ 8547 A9                                   xor     c                       ;
  75+ 8548 E6 80                                and     $80
  76+ 854A 6F                                   ld      l,a                     ; l = var T
  77+ 854B 3E 00                                ld      a,0
  78+ 854D 06 10                                ld      b,16
  79+ 854F                                      ShiftDELeft1
  79+ 854F CB 23       >			   sla e
  79+ 8551 CB 12       >			   rl  d
  80+ 8553 CB 21                                sla     c                       ; c = abs c
  81+ 8555 CB 39                                srl     c
  82+ 8557 CB 17        .DivideLoop:            rl      a
  83+ 8559                                      JumpIfALTNusng c, .SkipSubtract
  83+ 8559 B9          >                        cp      c
  83+ 855A DA 60 85    >                        jp		c, .SkipSubtract
  84+ 855D                                      ClearCarryFlag
  84+ 855D B7          >                        or a
  85+ 855E 99                                   sbc     c
  86+ 855F                                      ClearCarryFlag
  86+ 855F B7          >                        or a
  87+ 8560 3F           .SkipSubtract:          ccf
  88+ 8561 CB 13                                rl      e
  89+ 8563 CB 12                                rl      d
  90+ 8565 05                                   dec     b
  91+ 8566 20 EF                                jr      nz,.DivideLoop
  92+ 8568 7B                                   ld      a,e
  93+ 8569 B5                                   or      l
  94+ 856A 42                                   ld      b,d
  95+ 856B C9                                   ret
  96+ 856C              .ResultIsZero:          ZeroA
  96+ 856C AF          >                        xor a
  97+ 856D 47                                   ld      b,a
  98+ 856E C9                                   ret
  99+ 856F
 100+ 856F 14           Div16by24usgn:          inc     d                           ; can we fast retu
 101+ 8570 15                                   dec     d
 102+ 8571 20 13                                jr      nz,.ResultZero
 103+ 8573 50 59                                ld      de,bc                       ; so prep for bc/de
 104+ 8575 44 4D                                ld      bc,hl
 105+ 8577 7A           .div16by16usng:         ld      a,d
 106+ 8578 B3                                   or      e
 107+ 8579 28 10                                jr      z,.DivideByZero
 108+ 857B 14                                   inc     d
 109+ 857C 15                                   dec     d
 110+ 857D CD 02 87                             call    BC_Div_DE
 111+ 8580                                      ZeroA
 111+ 8580 AF          >                        xor a
 112+ 8581 EB                                   ex      de,hl                       ; de = remainder (need to fix c after hl = nothing of worth)
 113+ 8582 60 69                                ld      hl,bc                       ; hl = result (a is zero from above)
 114+ 8584 4F                                   ld      c,a                         ; now fix c
 115+ 8585 C9                                   ret
 116+ 8586 AF           .ResultZero:            xor     a                           ; set AHL to 0 as d was 0 so h is zero
 117+ 8587 4F                                   ld      c,a                         ; c = 0
 118+ 8588 67                                   ld      h,a
 119+ 8589 6F                                   ld      l,a
 120+ 858A C9                                   ret
 121+ 858B 3E FF        .DivideByZero:          ld      a,$FF
 122+ 858D 67                                   ld      h,a
 123+ 858E 6F                                   ld      l,a
 124+ 858F                                      SetCarryFlag
 124+ 858F 37          >                        scf
 125+ 8590 C9                                   ret
 126+ 8591
 127+ 8591              ;DIVD4 P-R=A/Qunsg  \P.R = A/Q unsigned called by Hall
 128+ 8591 06 08        HLEquAmul256DivD:       ld		b,8							; counter
 129+ 8593 CB 27                                sla		a							;
 130+ 8595 67                                   ld		h,a							; r a * 2 we will build result in hl
 131+ 8596 CB 17        .DivideLoop:            rl		a							; a = a * 2
 132+ 8598 38 03                                jr      c,.StraightToSubtraction    ; jump on carry to subtraction
 133+ 859A BA                                   cp      d                           ; what was var Q
 134+ 859B 38 03                                jr		c,.SkipSubtraction	        ; if a < d skip subtraction, note this will come to skip subtraction with carry the wrong way round
 135+ 859D              .StraightToSubtraction: ClearCarryFlag                      ; in 6502 the borrow flag is inverted carry, z80 just uses carry so we need to clear it
 135+ 859D B7          >                        or a
 136+ 859E 9A                                   sbc     a,d                         ; a = a - q
 137+ 859F                                      ClearCarryFlag                      ; set carry so it gets shifted into bit 0 of b. we do this as we have to flip carry due to jr c from earlier cp d
 137+ 859F B7          >                        or a
 138+ 85A0 3F           .SkipSubtraction:       ccf                                 ; we need to do this as 6502 does opposite on carry, i.e. if we jumped direct here then carry would be set in z80
 139+ 85A1 CB 14                                rl      h                           ; roll d left bringing in carry if there was an sbc performed
 140+ 85A3 10 F1                                djnz    .DivideLoop                 ; 8 cycles
 141+ 85A5 BA           .CalculateRemainder:    cp      d                           ; calulate 256 * a / d if q >= q then answer will not fit in one byte d is still set, a holds remainder to be subtracted
 142+ 85A6 30 19                                jr      nc, .RemainderTooBig
 143+ 85A8                                      ClearCarryFlag                      ; remove carry as the previous cp will have set it and mess up the sla in the remainder loop
 143+ 85A8 B7          >                        or a
 144+ 85A9 06 FE        .InitRemainderLoop:     ld      b,%11111110                 ; loop for bits 1 to 7
 145+ 85AB 68                                   ld      l,b                         ; and set l to capture result bits (R)
 146+ 85AC CB 27        .RemainderLoop:         sla     a                           ; shift a left
 147+ 85AE 38 0A                                jr      c, .RemainderSubtraction    ; if there was a carry go to subtraction
 148+ 85B0 BA                                   cp      d                           ; if a < d then skip subtraction
 149+ 85B1 38 01                                jr      c,.RemainderSkipSubtract    ; .
 150+ 85B3 9A                                   sbc     d                           ; a > q so a = a - q, carry will be clear here
 151+ 85B4 3F           .RemainderSkipSubtract: ccf                                 ; as the jr used z80 we need to flip the carry to behave like 6502
 152+ 85B5 CB 15                                rl      l                           ; rotate counter to the left
 153+ 85B7 38 F3                                jr      c, .RemainderLoop           ; if there was a bit pushed to carry then loop
 154+ 85B9 C9                                   ret
 155+ 85BA 9A           .RemainderSubtraction:  sbc     d                           ; as the carry came from an sla we want to retain it
 156+ 85BB                                      SetCarryFlag                        ; roll in a carry bit to result
 156+ 85BB 37          >                        scf
 157+ 85BC CB 15                                rl      l                           ;
 158+ 85BE 38 EC                                jr      c, .RemainderLoop           ; and loop if there was a carry bit that came out
 159+ 85C0 C9                                   ret
 160+ 85C1 2E FF        .RemainderTooBig:       ld      l,$FF                       ; now hl = result
 161+ 85C3 C9                                   ret
 162+ 85C4
 163+ 85C4 BA           AEquAmul256DivD:        cp      d
 164+ 85C5 28 1D                                jr      z,.BothSame
 165+ 85C7 30 1E                                jr      nc,.DgtA
 166+ 85C9 1E FE                                ld      e,%11111110                 ; Set R to have bits 1-7 set, so we can rotate through 7
 167+ 85CB CB 27        .DivideLoop:            sla     a
 168+ 85CD 38 0D                                jr      c,.LL29
 169+ 85CF                                      JumpIfALTNusng  d, .SkipSub         ; will jump if carry set, so we need to reset on the rol
 169+ 85CF BA          >                        cp      d
 169+ 85D0 DA D5 85    >                        jp		c, .SkipSub
 170+ 85D3 92                                   sub     d
 171+ 85D4                                      ClearCarryFlag                      ; reset clarry as it will be complimented for rotate as 6502 does carry flags inverted
 171+ 85D4 B7          >                        or a
 172+ 85D5              .SkipSub:               FlipCarryFlag                       ; if we did the subtract the carry will be clear so we need to invert to roll in.
 172+ 85D5 3F          >                        ccf
 173+ 85D6 CB 13                                rl      e
 174+ 85D8 38 F1                                jr      c,.DivideLoop
 175+ 85DA 7B                                   ld      a,e
 176+ 85DB C9                                   ret
 177+ 85DC 92           .LL29:                  sub     d                           ; A >= Q, so set A = A - Q
 178+ 85DD                                      SetCarryFlag                        ; Set the C flag to rotate into the result in R
 178+ 85DD 37          >                        scf
 179+ 85DE CB 13                                rl      e                           ; rotate counter e left
 180+ 85E0 38 E9                                jr      c,.DivideLoop               ; if a bit was spat off teh end then loop
 181+ 85E2 7B                                   ld      a,e                         ; stick result in a
 182+ 85E3 C9                                   ret
 183+ 85E4 3E 01        .BothSame:              ld  a,1
 184+ 85E6 C9                                   ret
 185+ 85E7 3E FF        .DgtA:                  ld  a,255                           ; Fail with FF as result
 186+ 85E9 C9                                   ret
 187+ 85EA
 188+ 85EA
 189+ 85EA              ; Divide 8-bit values
 190+ 85EA              ; In: Divide E by divider C
 191+ 85EA              ; Out: A = result, B = rest
 192+ 85EA              ;
 193+ 85EA              ;;;Div8:
 194+ 85EA              ;;;    xor a
 195+ 85EA              ;;;    ld b,8
 196+ 85EA              ;;;Div8_Loop:
 197+ 85EA              ;;;    rl e
 198+ 85EA              ;;;    rla
 199+ 85EA              ;;;    sub c
 200+ 85EA              ;;;    jr nc,Div8_NoAdd
 201+ 85EA              ;;;    add a,c
 202+ 85EA              ;;;Div8_NoAdd:
 203+ 85EA              ;;;    djnz Div8_Loop
 204+ 85EA              ;;;    ld b,a0
 205+ 85EA              ;;;    ld a,e
 206+ 85EA              ;;;    rla
 207+ 85EA              ;;;    cpl
 208+ 85EA              ;;;    ret
 209+ 85EA
 210+ 85EA              ;;Inputs: DE is the numerator, BC is the divisor
 211+ 85EA              ;;Outputs: DE is the result
 212+ 85EA              ;;         A is a copy of E
 213+ 85EA              ;;         HL is the remainder
 214+ 85EA              ;;         BC is not changed
 215+ 85EA              ;; so DE = DE /BC
 216+ 85EA              ;140 bytes
 217+ 85EA              ;145cc
 218+ 85EA
 219+ 85EA              MacroDEDivBC:       MACRO
 220+ 85EA ~                                rla
 221+ 85EA ~                                adc     hl,hl
 222+ 85EA ~                                sbc     hl,bc
 223+ 85EA ~                                jr      nc,$+3
 224+ 85EA ~                                add     hl,bc
 225+ 85EA                                  ENDM
 226+ 85EA
 227+ 85EA              DEequDEDivBC:
 228+ 85EA AF               xor a
 229+ 85EB ED 62            sbc hl,hl
 230+ 85ED 7A               ld a,d
 231+ 85EE                  MacroDEDivBC
 231+ 85EE 17          >                    rla
 231+ 85EF ED 6A       >                    adc     hl,hl
 231+ 85F1 ED 42       >                    sbc     hl,bc
 231+ 85F3 30 01       >                    jr      nc,$+3
 231+ 85F5 09          >                    add     hl,bc
 232+ 85F6                  MacroDEDivBC
 232+ 85F6 17          >                    rla
 232+ 85F7 ED 6A       >                    adc     hl,hl
 232+ 85F9 ED 42       >                    sbc     hl,bc
 232+ 85FB 30 01       >                    jr      nc,$+3
 232+ 85FD 09          >                    add     hl,bc
 233+ 85FE                  MacroDEDivBC
 233+ 85FE 17          >                    rla
 233+ 85FF ED 6A       >                    adc     hl,hl
 233+ 8601 ED 42       >                    sbc     hl,bc
 233+ 8603 30 01       >                    jr      nc,$+3
 233+ 8605 09          >                    add     hl,bc
 234+ 8606                  MacroDEDivBC
 234+ 8606 17          >                    rla
 234+ 8607 ED 6A       >                    adc     hl,hl
 234+ 8609 ED 42       >                    sbc     hl,bc
 234+ 860B 30 01       >                    jr      nc,$+3
 234+ 860D 09          >                    add     hl,bc
 235+ 860E                  MacroDEDivBC
 235+ 860E 17          >                    rla
 235+ 860F ED 6A       >                    adc     hl,hl
 235+ 8611 ED 42       >                    sbc     hl,bc
 235+ 8613 30 01       >                    jr      nc,$+3
 235+ 8615 09          >                    add     hl,bc
 236+ 8616                  MacroDEDivBC
 236+ 8616 17          >                    rla
 236+ 8617 ED 6A       >                    adc     hl,hl
 236+ 8619 ED 42       >                    sbc     hl,bc
 236+ 861B 30 01       >                    jr      nc,$+3
 236+ 861D 09          >                    add     hl,bc
 237+ 861E                  MacroDEDivBC
 237+ 861E 17          >                    rla
 237+ 861F ED 6A       >                    adc     hl,hl
 237+ 8621 ED 42       >                    sbc     hl,bc
 237+ 8623 30 01       >                    jr      nc,$+3
 237+ 8625 09          >                    add     hl,bc
 238+ 8626                  MacroDEDivBC
 238+ 8626 17          >                    rla
 238+ 8627 ED 6A       >                    adc     hl,hl
 238+ 8629 ED 42       >                    sbc     hl,bc
 238+ 862B 30 01       >                    jr      nc,$+3
 238+ 862D 09          >                    add     hl,bc
 239+ 862E 17               rla
 240+ 862F 2F               cpl
 241+ 8630 57               ld d,a
 242+ 8631
 243+ 8631 7B               ld a,e
 244+ 8632                  MacroDEDivBC
 244+ 8632 17          >                    rla
 244+ 8633 ED 6A       >                    adc     hl,hl
 244+ 8635 ED 42       >                    sbc     hl,bc
 244+ 8637 30 01       >                    jr      nc,$+3
 244+ 8639 09          >                    add     hl,bc
 245+ 863A                  MacroDEDivBC
 245+ 863A 17          >                    rla
 245+ 863B ED 6A       >                    adc     hl,hl
 245+ 863D ED 42       >                    sbc     hl,bc
 245+ 863F 30 01       >                    jr      nc,$+3
 245+ 8641 09          >                    add     hl,bc
 246+ 8642                  MacroDEDivBC
 246+ 8642 17          >                    rla
 246+ 8643 ED 6A       >                    adc     hl,hl
 246+ 8645 ED 42       >                    sbc     hl,bc
 246+ 8647 30 01       >                    jr      nc,$+3
 246+ 8649 09          >                    add     hl,bc
 247+ 864A                  MacroDEDivBC
 247+ 864A 17          >                    rla
 247+ 864B ED 6A       >                    adc     hl,hl
 247+ 864D ED 42       >                    sbc     hl,bc
 247+ 864F 30 01       >                    jr      nc,$+3
 247+ 8651 09          >                    add     hl,bc
 248+ 8652                  MacroDEDivBC
 248+ 8652 17          >                    rla
 248+ 8653 ED 6A       >                    adc     hl,hl
 248+ 8655 ED 42       >                    sbc     hl,bc
 248+ 8657 30 01       >                    jr      nc,$+3
 248+ 8659 09          >                    add     hl,bc
 249+ 865A                  MacroDEDivBC
 249+ 865A 17          >                    rla
 249+ 865B ED 6A       >                    adc     hl,hl
 249+ 865D ED 42       >                    sbc     hl,bc
 249+ 865F 30 01       >                    jr      nc,$+3
 249+ 8661 09          >                    add     hl,bc
 250+ 8662                  MacroDEDivBC
 250+ 8662 17          >                    rla
 250+ 8663 ED 6A       >                    adc     hl,hl
 250+ 8665 ED 42       >                    sbc     hl,bc
 250+ 8667 30 01       >                    jr      nc,$+3
 250+ 8669 09          >                    add     hl,bc
 251+ 866A                  MacroDEDivBC
 251+ 866A 17          >                    rla
 251+ 866B ED 6A       >                    adc     hl,hl
 251+ 866D ED 42       >                    sbc     hl,bc
 251+ 866F 30 01       >                    jr      nc,$+3
 251+ 8671 09          >                    add     hl,bc
 252+ 8672 17               rla
 253+ 8673 2F               cpl
 254+ 8674 5F               ld e,a
 255+ 8675 C9               ret
 256+ 8676
 257+ 8676
 258+ 8676
 259+ 8676              ;divdide by 16 using undocumented instrunctions
 260+ 8676              ;Input: BC = Dividend, DE = Divisor, HL = 0
 261+ 8676              ;Output: BC = Quotient, HL = Remainder
 262+ 8676              ; Our use
 263+ 8676              ; BC = A0
 264+ 8676              ; DE = 0C
 265+ 8676              ; so BC = a * 256 / C
 266+ 8676              DIV16Amul256dCUNDOC:    JumpIfAGTENusng	  c,DEV16ATooLarge                                          ; first off if a > c ten return 255
 266+ 8676 B9          >                        cp     c
 266+ 8677 D2 A2 86    >                        jp		nc,DEV16ATooLarge
 267+ 867A 47                                   ld      b,a
 268+ 867B 59                                   ld      e,c
 269+ 867C 0E 00                                ld      c,0
 270+ 867E 16 00                                ld      d,0
 271+ 8680 C3 8D 86                             jp      DIV16UNDOC
 272+ 8683 47           DIV16Amul256dQUNDOC:    ld      b,a
 273+ 8684 0E 00                                ld      c,0
 274+ 8686 21 53 8A                             ld      hl,varQ
 275+ 8689 7E                                   ld      a,(hl)
 276+ 868A 16 00                                ld      d,0
 277+ 868C 5F                                   ld      e,a
 278+ 868D              DIV16BCDivDEUNDOC:
 279+ 868D 21 00 00     DIV16UNDOC:             ld      hl,0
 280+ 8690 78                                   ld      a,b
 281+ 8691 06 10                                ld      b,16
 282+ 8693 CB 31        DIV16UNDOCLOOP:         sll	c		; unroll 16 times
 283+ 8695 17                                   rla			; ...
 284+ 8696 ED 6A                                adc	hl,hl		; ...
 285+ 8698 ED 52                                sbc	hl,de		; ...
 286+ 869A 30 02                                jr	nc,DIV16UNDOCSKIP		; ...
 287+ 869C 19                                   add	hl,de		; ...
 288+ 869D 0D                                   dec	c		; ...
 289+ 869E 10 F3        DIV16UNDOCSKIP:         djnz DIV16UNDOCLOOP
 290+ 86A0 47                                   ld   b,a
 291+ 86A1 C9                                   ret
 292+ 86A2 01 FF 00     DEV16ATooLarge:         ld     bc,$00FF
 293+ 86A5 C9                                   ret
 294+ 86A6              ; switch to logarithm version
 295+ 86A6              ; "> asm_div8 C_Div_D - C is the numerator, D is the denominator, A is the remainder, B is 0, C is the result of C/D,D,E,H,L are not changed"
 296+ 86A6 06 08        asm_div8:               ld b,8
 297+ 86A8 AF                                   xor a
 298+ 86A9 CB 21        .div8_loop:	            sla c
 299+ 86AB 17                                   rla
 300+ 86AC BA                                   cp d
 301+ 86AD 38 02                                jr c,.div8_skip
 301+ 86AF
 302+ 86AF 0C                                   inc c
 303+ 86B0 92                                   sub d
 304+ 86B1 10 F6        .div8_skip:	            djnz .div8_loop
 305+ 86B3 C9                                   ret
 306+ 86B4              ; ">asm_div16: HL_Div_C: HL is the numerator,  C is the denominator, output A is the remainder, B is 0, C,DE is not changedHL is the quotient"
 307+ 86B4 06 10        asm_div16:              ld b,16
 308+ 86B6 AF                                   xor a
 309+ 86B7 CB 25        div16_loop:	            sla l
 310+ 86B9 CB 14                                rl	h
 311+ 86BB              ;    add hl,hl
 312+ 86BB 17                                   rla
 313+ 86BC B9                                   cp c
 314+ 86BD 38 02                                jr c,div16_skip
 315+ 86BF 2C                                   inc l
 316+ 86C0 91                                   sub c
 317+ 86C1 10 F4        div16_skip:		        djnz div16_loop
 318+ 86C3 C9                                   ret
 319+ 86C4              ;
 320+ 86C4              ; Divide 16-bit values (with 16-bit result)
 321+ 86C4              ; In: Divide BC by divider DE
 322+ 86C4              ; Out: BC = result, HL = rest
 323+ 86C4              ;
 324+ 86C4              HLDivC_Iteration: 	    MACRO
 325+ 86C4 ~                                    add	hl,hl		; unroll 16 times
 326+ 86C4 ~                                    rla				; ...
 327+ 86C4 ~                                    cp	c			; ...
 328+ 86C4 ~                                    jr	1F
 329+ 86C4 ~                                    sub	c			; ...
 330+ 86C4 ~            1:
 331+ 86C4 ~                                    inc	l			; ...
 332+ 86C4                                      ENDM
 333+ 86C4
 334+ 86C4              EDivC_Iteration:        MACRO
 335+ 86C4 ~                                    rl  e
 336+ 86C4 ~                                    rla
 337+ 86C4 ~                                    sub c
 338+ 86C4 ~                                    jr  nc,.Div8_NoAdd
 339+ 86C4 ~                                    add a,c
 340+ 86C4 ~            .Div8_NoAdd:
 341+ 86C4                                      ENDM
 342+ 86C4
 343+ 86C4              ; Switch to a logarithm version
 344+ 86C4              ; Divide E by divider C Out: A = result, B = rest
 345+ 86C4              E_Div_C:                ZeroA
 345+ 86C4 AF          >                        xor a
 346+ 86C5                                      EDivC_Iteration
 346+ 86C5 CB 13       >                        rl  e
 346+ 86C7 17          >                        rla
 346+ 86C8 91          >                        sub c
 346+ 86C9 30 01       >                        jr  nc,.Div8_NoAdd
 346+ 86CB 81          >                        add a,c
 346+ 86CC             >.Div8_NoAdd:
 347+ 86CC                                      EDivC_Iteration
 347+ 86CC CB 13       >                        rl  e
 347+ 86CE 17          >                        rla
 347+ 86CF 91          >                        sub c
 347+ 86D0 30 01       >                        jr  nc,.Div8_NoAdd
 347+ 86D2 81          >                        add a,c
 347+ 86D3             >.Div8_NoAdd:
 348+ 86D3                                      EDivC_Iteration
 348+ 86D3 CB 13       >                        rl  e
 348+ 86D5 17          >                        rla
 348+ 86D6 91          >                        sub c
 348+ 86D7 30 01       >                        jr  nc,.Div8_NoAdd
 348+ 86D9 81          >                        add a,c
 348+ 86DA             >.Div8_NoAdd:
 349+ 86DA                                      EDivC_Iteration
 349+ 86DA CB 13       >                        rl  e
 349+ 86DC 17          >                        rla
 349+ 86DD 91          >                        sub c
 349+ 86DE 30 01       >                        jr  nc,.Div8_NoAdd
 349+ 86E0 81          >                        add a,c
 349+ 86E1             >.Div8_NoAdd:
 350+ 86E1                                      EDivC_Iteration
 350+ 86E1 CB 13       >                        rl  e
 350+ 86E3 17          >                        rla
 350+ 86E4 91          >                        sub c
 350+ 86E5 30 01       >                        jr  nc,.Div8_NoAdd
 350+ 86E7 81          >                        add a,c
 350+ 86E8             >.Div8_NoAdd:
 351+ 86E8                                      EDivC_Iteration
 351+ 86E8 CB 13       >                        rl  e
 351+ 86EA 17          >                        rla
 351+ 86EB 91          >                        sub c
 351+ 86EC 30 01       >                        jr  nc,.Div8_NoAdd
 351+ 86EE 81          >                        add a,c
 351+ 86EF             >.Div8_NoAdd:
 352+ 86EF                                      EDivC_Iteration
 352+ 86EF CB 13       >                        rl  e
 352+ 86F1 17          >                        rla
 352+ 86F2 91          >                        sub c
 352+ 86F3 30 01       >                        jr  nc,.Div8_NoAdd
 352+ 86F5 81          >                        add a,c
 352+ 86F6             >.Div8_NoAdd:
 353+ 86F6                                      EDivC_Iteration
 353+ 86F6 CB 13       >                        rl  e
 353+ 86F8 17          >                        rla
 353+ 86F9 91          >                        sub c
 353+ 86FA 30 01       >                        jr  nc,.Div8_NoAdd
 353+ 86FC 81          >                        add a,c
 353+ 86FD             >.Div8_NoAdd:
 354+ 86FD 47                                   ld      b,a
 355+ 86FE 7B                                   ld      a,e
 356+ 86FF 17                                   rla
 357+ 8700 2F                                   cpl
 358+ 8701 C9                                   ret
 359+ 8702
 360+ 8702
 361+ 8702              BCDIVDE_Iteration:      MACRO
 362+ 8702 ~                                    rla
 363+ 8702 ~                                    adc	    hl,hl
 364+ 8702 ~                                    add	    hl,de
 365+ 8702 ~                                    jr	    c,1F
 366+ 8702 ~                                    sbc	    hl,de
 367+ 8702 ~            1:
 368+ 8702                                      ENDM
 369+ 8702
 370+ 8702
 371+ 8702              ; ">BC_Div_DE: BC = BC / DE. HL = remainder fast divide with unrolled loop"
 372+ 8702              ;BC/DE ==> BC, remainder in HL
 373+ 8702              ;NOTE: BC/0 returns 0 as the quotient.
 374+ 8702              ;min: 738cc
 375+ 8702              ;max: 898cc
 376+ 8702              ;avg: 818cc
 377+ 8702              ;144 bytes
 378+ 8702 AF           BC_Div_DE:              xor a
 379+ 8703 67                                   ld h,a
 380+ 8704 6F                                   ld l,a
 381+ 8705 93                                   sub e
 382+ 8706 5F                                   ld e,a
 383+ 8707 9F                                   sbc a,a
 384+ 8708 92                                   sub d
 385+ 8709 57                                   ld d,a
 386+ 870A 78                                   ld a,b
 387+ 870B                                      BCDIVDE_Iteration
 387+ 870B 17          >                        rla
 387+ 870C ED 6A       >                        adc	    hl,hl
 387+ 870E 19          >                        add	    hl,de
 387+ 870F 38 02       >                        jr	    c,1F
 387+ 8711 ED 52       >                        sbc	    hl,de
 387+ 8713             >1:
 388+ 8713                                      BCDIVDE_Iteration
 388+ 8713 17          >                        rla
 388+ 8714 ED 6A       >                        adc	    hl,hl
 388+ 8716 19          >                        add	    hl,de
 388+ 8717 38 02       >                        jr	    c,1F
 388+ 8719 ED 52       >                        sbc	    hl,de
 388+ 871B             >1:
 389+ 871B                                      BCDIVDE_Iteration
 389+ 871B 17          >                        rla
 389+ 871C ED 6A       >                        adc	    hl,hl
 389+ 871E 19          >                        add	    hl,de
 389+ 871F 38 02       >                        jr	    c,1F
 389+ 8721 ED 52       >                        sbc	    hl,de
 389+ 8723             >1:
 390+ 8723                                      BCDIVDE_Iteration
 390+ 8723 17          >                        rla
 390+ 8724 ED 6A       >                        adc	    hl,hl
 390+ 8726 19          >                        add	    hl,de
 390+ 8727 38 02       >                        jr	    c,1F
 390+ 8729 ED 52       >                        sbc	    hl,de
 390+ 872B             >1:
 391+ 872B                                      BCDIVDE_Iteration
 391+ 872B 17          >                        rla
 391+ 872C ED 6A       >                        adc	    hl,hl
 391+ 872E 19          >                        add	    hl,de
 391+ 872F 38 02       >                        jr	    c,1F
 391+ 8731 ED 52       >                        sbc	    hl,de
 391+ 8733             >1:
 392+ 8733                                      BCDIVDE_Iteration
 392+ 8733 17          >                        rla
 392+ 8734 ED 6A       >                        adc	    hl,hl
 392+ 8736 19          >                        add	    hl,de
 392+ 8737 38 02       >                        jr	    c,1F
 392+ 8739 ED 52       >                        sbc	    hl,de
 392+ 873B             >1:
 393+ 873B                                      BCDIVDE_Iteration
 393+ 873B 17          >                        rla
 393+ 873C ED 6A       >                        adc	    hl,hl
 393+ 873E 19          >                        add	    hl,de
 393+ 873F 38 02       >                        jr	    c,1F
 393+ 8741 ED 52       >                        sbc	    hl,de
 393+ 8743             >1:
 394+ 8743                                      BCDIVDE_Iteration
 394+ 8743 17          >                        rla
 394+ 8744 ED 6A       >                        adc	    hl,hl
 394+ 8746 19          >                        add	    hl,de
 394+ 8747 38 02       >                        jr	    c,1F
 394+ 8749 ED 52       >                        sbc	    hl,de
 394+ 874B             >1:
 395+ 874B 17                                   rla
 396+ 874C 47                                   ld b,a
 397+ 874D 79                                   ld a,c
 398+ 874E                                      BCDIVDE_Iteration
 398+ 874E 17          >                        rla
 398+ 874F ED 6A       >                        adc	    hl,hl
 398+ 8751 19          >                        add	    hl,de
 398+ 8752 38 02       >                        jr	    c,1F
 398+ 8754 ED 52       >                        sbc	    hl,de
 398+ 8756             >1:
 399+ 8756                                      BCDIVDE_Iteration
 399+ 8756 17          >                        rla
 399+ 8757 ED 6A       >                        adc	    hl,hl
 399+ 8759 19          >                        add	    hl,de
 399+ 875A 38 02       >                        jr	    c,1F
 399+ 875C ED 52       >                        sbc	    hl,de
 399+ 875E             >1:
 400+ 875E                                      BCDIVDE_Iteration
 400+ 875E 17          >                        rla
 400+ 875F ED 6A       >                        adc	    hl,hl
 400+ 8761 19          >                        add	    hl,de
 400+ 8762 38 02       >                        jr	    c,1F
 400+ 8764 ED 52       >                        sbc	    hl,de
 400+ 8766             >1:
 401+ 8766                                      BCDIVDE_Iteration
 401+ 8766 17          >                        rla
 401+ 8767 ED 6A       >                        adc	    hl,hl
 401+ 8769 19          >                        add	    hl,de
 401+ 876A 38 02       >                        jr	    c,1F
 401+ 876C ED 52       >                        sbc	    hl,de
 401+ 876E             >1:
 402+ 876E                                      BCDIVDE_Iteration
 402+ 876E 17          >                        rla
 402+ 876F ED 6A       >                        adc	    hl,hl
 402+ 8771 19          >                        add	    hl,de
 402+ 8772 38 02       >                        jr	    c,1F
 402+ 8774 ED 52       >                        sbc	    hl,de
 402+ 8776             >1:
 403+ 8776                                      BCDIVDE_Iteration
 403+ 8776 17          >                        rla
 403+ 8777 ED 6A       >                        adc	    hl,hl
 403+ 8779 19          >                        add	    hl,de
 403+ 877A 38 02       >                        jr	    c,1F
 403+ 877C ED 52       >                        sbc	    hl,de
 403+ 877E             >1:
 404+ 877E                                      BCDIVDE_Iteration
 404+ 877E 17          >                        rla
 404+ 877F ED 6A       >                        adc	    hl,hl
 404+ 8781 19          >                        add	    hl,de
 404+ 8782 38 02       >                        jr	    c,1F
 404+ 8784 ED 52       >                        sbc	    hl,de
 404+ 8786             >1:
 405+ 8786                                      BCDIVDE_Iteration
 405+ 8786 17          >                        rla
 405+ 8787 ED 6A       >                        adc	    hl,hl
 405+ 8789 19          >                        add	    hl,de
 405+ 878A 38 02       >                        jr	    c,1F
 405+ 878C ED 52       >                        sbc	    hl,de
 405+ 878E             >1:
 406+ 878E 17                                   rla
 407+ 878F 4F                                   ld c,a
 408+ 8790 C9                                   ret
 409+ 8791
# file closed: ./Maths/asm_divide.asm
 195  8791                  INCLUDE "./Maths/multiply.asm"
# file opened: ./Maths/multiply.asm
   1+ 8791              HLequSRmulQdiv256:      ;X.Y=x1lo.S*M/256  	\ where M/256 is gradient
   2+ 8791 2A 54 8A                             ld  hl,(varRS)
   3+ 8794 3A 53 8A                             ld  a,(varQ)
   4+ 8797 C5 D5        HLeqyHLmulAdiv256:      push    bc,,de
   5+ 8799 11 00 00                             ld  de,0        ; de = XY
   6+ 879C 47                                   ld  b,a         ; b = Q
   7+ 879D                                      ShiftHLRight1
   7+ 879D CB 3C       >			   srl h
   7+ 879F CB 1D       >			   rr  l
   8+ 87A1 CB 20                                sla b
   9+ 87A3 30 03                                jr  nc,.LL126
  10+ 87A5 EB           .LL125:                 ex de,hl
  11+ 87A6 19                                   add hl,de
  12+ 87A7 EB                                   ex  de,hl       ; de = de + rs
  13+ 87A8              .LL126:                 ShiftHLRight1
  13+ 87A8 CB 3C       >			   srl h
  13+ 87AA CB 1D       >			   rr  l
  14+ 87AC CB 20                                sla b
  15+ 87AE 38 F5                                jr      c,.LL125
  16+ 87B0 20 F6                                jr      nz,.LL126
  17+ 87B2 EB                                   ex      de,hl   ; hl = result
  18+ 87B3 D1 C1                                pop     bc,,de
  19+ 87B5 C9                                   ret
  20+ 87B6
  21+ 87B6
  22+ 87B6              MacroDEEquQmulASigned:  MACRO
  23+ 87B6 ~                                    ld      d,a                         ; save a into d
  24+ 87B6 ~                                    ld      a,(varQ)
  25+ 87B6 ~                                    ld      e,a
  26+ 87B6 ~                                    xor     d                           ; a = a xor var Q
  27+ 87B6 ~                                    and     SignOnly8Bit
  28+ 87B6 ~                                    ld      b,a                         ; b = sign of a xor q
  29+ 87B6 ~                                    ld      a,d                         ; d = abs d (or a reg)
  30+ 87B6 ~                                    and     SignMask8Bit
  31+ 87B6 ~                                    ld      d,a
  32+ 87B6 ~                                    ld      a,e                         ; e = abs e (or varQ)
  33+ 87B6 ~                                    and     SignMask8Bit
  34+ 87B6 ~                                    ld      e,a
  35+ 87B6 ~                                    mul                                 ; de = a * Q
  36+ 87B6 ~                                    ld      a,d
  37+ 87B6 ~                                    or      b                           ; de = a * Q leading sign bit
  38+ 87B6 ~                                    ld      d,a
  39+ 87B6                                      ENDM
  40+ 87B6
  41+ 87B6
  42+ 87B6
  43+ 87B6                                 ; .MAD	\ -> &22AD  \ Multiply and Add  (DE also) X.A(Lo.Hi) = Q*A + R.S (Lo.Hi)
  44+ 87B6              madXAequQmulAaddRS:     MacroDEEquQmulASigned
  44+ 87B6 57          >                        ld      d,a                         ; save a into d
  44+ 87B7 3A 53 8A    >                        ld      a,(varQ)
  44+ 87BA 5F          >                        ld      e,a
  44+ 87BB AA          >                        xor     d                           ; a = a xor var Q
  44+ 87BC E6 80       >                        and     SignOnly8Bit
  44+ 87BE 47          >                        ld      b,a                         ; b = sign of a xor q
  44+ 87BF 7A          >                        ld      a,d                         ; d = abs d (or a reg)
  44+ 87C0 E6 7F       >                        and     SignMask8Bit
  44+ 87C2 57          >                        ld      d,a
  44+ 87C3 7B          >                        ld      a,e                         ; e = abs e (or varQ)
  44+ 87C4 E6 7F       >                        and     SignMask8Bit
  44+ 87C6 5F          >                        ld      e,a
  44+ 87C7 ED 30       >                        mul                                 ; de = a * Q
  44+ 87C9 7A          >                        ld      a,d
  44+ 87CA B0          >                        or      b                           ; de = a * Q leading sign bit
  44+ 87CB 57          >                        ld      d,a
  45+ 87CC 2A 54 8A                             ld		hl,(varR)
  46+ 87CF CD F7 87                             call	madXAAddHLDESigned
  47+ 87D2 EB                                   ex      de,hl                       ; de = R.S + DE
  48+ 87D3                                      ClearCarryFlag
  48+ 87D3 B7          >                        or a
  49+ 87D4 DD 6B                                ld      ixl,e
  50+ 87D6 7A                                   ld      a,d
  51+ 87D7 C9                                   ret
  52+ 87D8
  53+ 87D8              madDEequQmulAaddRS:     MacroDEEquQmulASigned
  53+ 87D8 57          >                        ld      d,a                         ; save a into d
  53+ 87D9 3A 53 8A    >                        ld      a,(varQ)
  53+ 87DC 5F          >                        ld      e,a
  53+ 87DD AA          >                        xor     d                           ; a = a xor var Q
  53+ 87DE E6 80       >                        and     SignOnly8Bit
  53+ 87E0 47          >                        ld      b,a                         ; b = sign of a xor q
  53+ 87E1 7A          >                        ld      a,d                         ; d = abs d (or a reg)
  53+ 87E2 E6 7F       >                        and     SignMask8Bit
  53+ 87E4 57          >                        ld      d,a
  53+ 87E5 7B          >                        ld      a,e                         ; e = abs e (or varQ)
  53+ 87E6 E6 7F       >                        and     SignMask8Bit
  53+ 87E8 5F          >                        ld      e,a
  53+ 87E9 ED 30       >                        mul                                 ; de = a * Q
  53+ 87EB 7A          >                        ld      a,d
  53+ 87EC B0          >                        or      b                           ; de = a * Q leading sign bit
  53+ 87ED 57          >                        ld      d,a
  54+ 87EE 2A 54 8A                             ld		hl,(varR)
  55+ 87F1 CD F7 87                             call	madXAAddHLDESigned
  56+ 87F4 EB                                   ex      de,hl                       ; de = R.S + DE
  57+ 87F5                                      ClearCarryFlag
  57+ 87F5 B7          >                        or a
  58+ 87F6 C9                                   ret
  59+ 87F7
  60+ 87F7 7C           madXAAddHLDESigned:     ld      a,h
  61+ 87F8 E6 80                                and     SignOnly8Bit
  62+ 87FA 47                                   ld      b,a                         ;save sign bit in b
  63+ 87FB AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
  64+ 87FC                                      JumpIfNegative .ADDHLDEOppSGN        ;Signs are opposite there fore we can subtract to get difference
  64+ 87FC FA 14 88    >                        jp		m, .ADDHLDEOppSGN
  65+ 87FF 78           .ADDHLDESameSigns:       ld      a,b
  66+ 8800 B2                                   or      d
  67+ 8801                                      JumpIfNegative .ADDHLDESameNeg       ; optimisation so we can just do simple add if both positive
  67+ 8801 FA 06 88    >                        jp		m, .ADDHLDESameNeg
  68+ 8804 19                                   add     hl,de
  69+ 8805 C9                                   ret
  70+ 8806 7C           .ADDHLDESameNeg:         ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
  71+ 8807 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
  72+ 8809 67                                   ld      h,a
  73+ 880A 7A                                   ld      a,d
  74+ 880B E6 7F                                and     SignMask8Bit
  75+ 880D 57                                   ld      d,a
  76+ 880E 19                                   add     hl,de
  77+ 880F 3E 80                                ld      a,SignOnly8Bit
  78+ 8811 B4                                   or      h                           ; now set bit for negative value, we won't bother with overflow for now TODO
  79+ 8812 67                                   ld      h,a
  80+ 8813 C9                                   ret
  81+ 8814 7C           .ADDHLDEOppSGN:          ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit                     ; here HL and DE are opposite
  82+ 8815 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
  83+ 8817 67                                   ld      h,a
  84+ 8818 7A                                   ld      a,d
  85+ 8819 E6 7F                                and     SignMask8Bit
  86+ 881B 57                                   ld      d,a
  87+ 881C B7                                   or      a
  88+ 881D ED 52                                sbc     hl,de
  89+ 881F 38 04                                jr      c,.ADDHLDEOppInvert
  90+ 8821 78           .ADDHLDEOppSGNNoCarry:   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
  91+ 8822 B4                                   or      h
  92+ 8823 67                                   ld      h,a                         ; set the previou sign value
  93+ 8824 C9                                   ret
  94+ 8825              .ADDHLDEOppInvert:       NegHL                                                   ; we need to flip the sign and 2'c the Hl result
  94+ 8825 AF          >                    xor a
  94+ 8826 95          >                    sub l
  94+ 8827 6F          >                    ld l,a
  94+ 8828 9F          >                    sbc a,a
  94+ 8829 94          >                    sub h
  94+ 882A 67          >                    ld h,a
  95+ 882B 78                                   ld      a,b
  96+ 882C EE 80                                xor     SignOnly8Bit                ; flip sign bit
  97+ 882E B4                                   or      h
  98+ 882F 67                                   ld      h,a                         ; recover sign
  99+ 8830 C9                                   ret
 100+ 8831
 101+ 8831
 102+ 8831                  ; multiplication of 16-bit number and 8-bit number into a 24-bit product
 103+ 8831                  ;
 104+ 8831                  ; enter : hl = 16-bit multiplier   = x
 105+ 8831                  ;          e =  8-bit multiplicand = y
 106+ 8831                  ;
 107+ 8831                  ; exit  : ahl = 24-bit product
 108+ 8831                  ;         carry reset
 109+ 8831                  ;
 110+ 8831                  ; uses  : af, de, hl
 111+ 8831 54           AHLequHLmulE:           ld d,h                      ; xh
 112+ 8832 63                                   ld h,e                      ; yl
 113+ 8833 ED 30                                mul de                      ; xh*yl
 114+ 8835 EB                                   ex de,hl
 115+ 8836 ED 30                                mul de                      ; yl*xl, hl = xh*yl
 116+ 8838
 117+ 8838 7A                                   ld  a,d                     ; sum products
 118+ 8839 85                                   add a,l
 119+ 883A 57                                   ld  d,a
 120+ 883B EB                                   ex de,hl
 121+ 883C
 122+ 883C 7A                                   ld  a,d
 123+ 883D CE 00                                adc a,0
 124+ 883F C9                                   ret
 125+ 8840
 126+ 8840 54           HLE0quH0mulE:           ld      d,h                 ; .
 127+ 8841 63                                   ld      h,e                 ; .
 128+ 8842 ED 30                                mul     de                  ; de = xh * yl
 129+ 8844 EB                                   ex      de,hl
 130+ 8845 C9                                   ret
 131+ 8846
 132+ 8846                 ; multiplication of two 16-bit numbers into a 32-bit product
 133+ 8846                 ;
 134+ 8846                 ; enter : de = 16-bit multiplicand = y
 135+ 8846                 ;         hl = 16-bit multiplicand = x
 136+ 8846                 ;
 137+ 8846                 ; exit  : dehl = 32-bit product
 138+ 8846                 ;         carry reset
 139+ 8846                 ;
 140+ 8846                 ; uses  : af, bc, de, hl
 141+ 8846
 142+ 8846
 143+ 8846
 144+ 8846 45           DEHLequDEmulHL:         ld b,l                      ; x0
 145+ 8847 4B                                   ld c,e                      ; y0
 146+ 8848 5D                                   ld e,l                      ; x0
 147+ 8849 6A                                   ld l,d
 148+ 884A E5                                   push hl                     ; x1 y1
 149+ 884B 69                                   ld l,c                      ; y0
 150+ 884C              ; bc = x0 y0, de = y1 x0,  hl = x1 y0,  stack = x1 y1
 151+ 884C ED 30                                mul de                      ; y1*x0
 152+ 884E EB                                   ex de,hl
 153+ 884F ED 30                                mul de                      ; x1*y0
 154+ 8851
 155+ 8851 AF                                   xor a                       ; zero A
 156+ 8852 19                                   add hl,de                   ; sum cross products p2 p1
 157+ 8853 8F                                   adc a,a                     ; capture carry p3
 158+ 8854
 159+ 8854 59                                   ld e,c                      ; x0
 160+ 8855 50                                   ld d,b                      ; y0
 161+ 8856 ED 30                                mul de                      ; y0*x0
 162+ 8858
 163+ 8858 47                                   ld b,a                      ; carry from cross products
 164+ 8859 4C                                   ld c,h                      ; LSB of MSW from cross products
 165+ 885A
 166+ 885A 7A                                   ld a,d
 167+ 885B 85                                   add a,l
 168+ 885C 67                                   ld h,a
 169+ 885D 6B                                   ld l,e                      ; LSW in HL p1 p0
 170+ 885E
 171+ 885E D1                                   pop de
 172+ 885F ED 30                                mul de                      ; x1*y1
 173+ 8861
 174+ 8861 EB                                   ex de,hl
 175+ 8862 ED 4A                                adc hl,bc
 176+ 8864 EB                                   ex de,hl                    ; de = final MSW
 177+ 8865
 178+ 8865 C9                                   ret
 179+ 8866
 180+ 8866              ; multiplication of two 16-bit numbers into a 16-bit product
 181+ 8866              ; enter : de = 16-bit multiplicand
 182+ 8866              ;         hl = 16-bit multiplicand
 183+ 8866              ; exit  : hl = 16-bit product
 184+ 8866              ;         carry reset
 185+ 8866              ; maths is
 186+ 8866              ;        hl = y , de= x
 187+ 8866              ;        hl = xhi,ylo + (yhigh * xlow)
 188+ 8866              ;        hl = yhih & xlo + x
 189+ 8866              ;
 190+ 8866              ;
 191+ 8866              ; uses  : af, bc, de, hl
 192+ 8866 C5           mulDEbyHL:              push    bc
 193+ 8867 7A                                   ld a,d                      ; a = xh
 194+ 8868 54                                   ld d,h                      ; d = yh
 195+ 8869 67                                   ld h,a                      ; h = xh
 196+ 886A 4B                                   ld c,e                      ; c = xl
 197+ 886B 45                                   ld b,l                      ; b = yl
 198+ 886C ED 30                                mul                         ; yh * yl
 199+ 886E EB                                   ex de,hl
 200+ 886F ED 30                                mul                         ; xh * yl
 201+ 8871 19                                   add hl,de                   ; add cross products
 202+ 8872 59                                   ld e,c
 203+ 8873 50                                   ld d,b
 204+ 8874 ED 30                                mul                         ; yl * xl
 205+ 8876 7D                                   ld a,l                      ; cross products lsb
 206+ 8877 82                                   add a,d                     ; add to msb final
 207+ 8878 67                                   ld h,a
 208+ 8879 6B                                   ld l,e                      ; hl = final
 209+ 887A                                      ; 83 cycles, 19 bytes
 210+ 887A AF                                   xor a                       ; reset carry
 211+ 887B C1                                   pop     bc
 212+ 887C C9                                   ret
 213+ 887D
 214+ 887D
 215+ 887D              ; CHL = multiplicand D = multiplier
 216+ 887D              ; DCHL = CHL * D
 217+ 887D 7A           mulCHLbyDSigned:        ld      a,d                 ; get sign from d
 218+ 887E AC                                   xor     h                   ; xor with h to get resultant sign
 219+ 887F E6 80                                and     SignOnly8Bit        ; .
 220+ 8881 FD 67                                ld      iyh,a               ; iyh = copy of sign
 221+ 8883 79                                   ld      a,c                 ; now CHL = ABS (CHL)
 222+ 8884 E6 7F                                and     SignMask8Bit        ; .
 223+ 8886 4F                                   ld      c,a                 ; .
 224+ 8887 7A                                   ld      a,d                 ; d = ABS D
 225+ 8888 E6 7F                                and     SignMask8Bit        ; .
 226+ 888A              ; At this point CHL = ABS (HLE), A = ABS(D)
 227+ 888A 57           .mul1:                  ld      d,a                 ; first do D * L
 228+ 888B 5D                                   ld      e,l                 ; .
 229+ 888C ED 30                                mul     de                  ; DE = L * D
 230+ 888E 08                                   ex      af,af'              ; save multiplier
 231+ 888F 6B                                   ld      l,e                 ; L = p0
 232+ 8890 7A                                   ld      a,d                 ; carry byte
 233+ 8891 08                                   ex      af,af'              ; retrieve muliplier and save carry byte along with flags
 234+ 8892 5C           .mul2:                  ld      e,h                 ; byte 2 of multiplicand
 235+ 8893 57                                   ld      d,a                 ; and multiplier
 236+ 8894 ED 30                                mul     de                  ; now its D & L
 237+ 8896 08                                   ex      af,af'              ; get back carry byte with flags
 238+ 8897 83           .carrybyte1:            add     a,e                 ; add low byte carry to result and retain carry too through next instructions
 239+ 8898 67                                   ld      h,a                 ; h = P1
 240+ 8899 7A                                   ld      a,d                 ; a = carry byte
 241+ 889A 08                                   ex      af,af'              ; save carry byte and get back multiplier with flags
 242+ 889B 59           .mul3:                  ld      e,c                 ; byte 3 of multiplicand
 243+ 889C 57                                   ld      d,a                 ;
 244+ 889D ED 30                                mul     de                  ;
 245+ 889F 08                                   ex      af,af'              ; get back carry byte and carry prior to first add
 246+ 88A0 8B                                   adc     a,e                 ;
 247+ 88A1 FD B4                                or      iyh                 ; recover saved resultant sign
 248+ 88A3 4F                                   ld      c,a                 ; c byte 3. Note the value range allowed can never cause a byte 3 carry
 249+ 88A4 C9                                   ret
 250+ 88A5
 251+ 88A5              ;  CHL = 53456 D = 1E
 252+ 88A5              ;  56 * 1E = A14 L = 14 carry = 0A
 253+ 88A5              ;  34 * 1E = 618 H = 18 +A = 22 carry = 6
 254+ 88A5              ;  5  * 1E = 096 C = 96 + 6 = 9C
 255+ 88A5              ;  CHL = 9C2214
 256+ 88A5              ;mult3
 257+ 88A5              ; DELC = HLE * D, uses HL, DE, C , A , IYH
 258+ 88A5              ; HLE = multiplicand D = multiplier
 259+ 88A5              ; tested by mathstestsun.asm all passed
 260+ 88A5              ; Algorithm
 261+ 88A5              ; AC =  E * D   (save carry)         H    L    E
 262+ 88A5              ; DE =  L * D                                  D
 263+ 88A5              ;  L =  A + E + carry                         E*D (lo)
 264+ 88A5              ; DE =  H * D                             L*D+ ^ (hi)
 265+ 88A5              ;  E =  A + E + carry                H*D (lo) + carry
 266+ 88A5              ;
 267+ 88A5              ;
 268+ 88A5 7A           mulHLEbyDSigned:        ld      a,d                 ; get sign from d
 269+ 88A6 AC                                   xor     h                   ; xor with h to get resultant sign
 270+ 88A7 E6 80                                and     SignOnly8Bit        ; .
 271+ 88A9 FD 67                                ld      iyh,a               ; iyh = copy of sign
 272+ 88AB 7C                                   ld      a,h                 ; now HLE = ABS (HLE)
 273+ 88AC E6 7F                                and     SignMask8Bit        ; .
 274+ 88AE 67                                   ld      h,a                 ; .
 275+ 88AF 7A                                   ld      a,d                 ; d = ABS D
 276+ 88B0 E6 7F                                and     SignMask8Bit        ; .
 277+ 88B2 57                                   ld      d,a                 ; .
 278+ 88B3 B7           .testEitherSideZero:    or      a
 279+ 88B4 28 24                                jr      z,.ResultZero
 280+ 88B6 7C                                   ld      a,h
 281+ 88B7 B5                                   or      l
 282+ 88B8 B3                                   or      e
 283+ 88B9 28 1F                                jr      z,.ResultZero
 284+ 88BB              ; At this point HLE = ABS (HLE), A = ABS(D)
 285+ 88BB 42                                   ld      b,d                 ; save Quotient
 286+ 88BC ED 30        .mul1:                  mul     de                  ; C = E * D
 287+ 88BE 4B                                   ld      c,e                 ; C = p0
 288+ 88BF FD 6A                                ld      iyl,d               ; save carry (p1)
 289+ 88C1 5D           .mul2:                  ld      e,l                 ; L = L * D
 290+ 88C2 50                                   ld      d,b                 ; .
 291+ 88C3 ED 30                                mul     de                  ; .
 292+ 88C5 FD 7D                                ld      a,iyl               ; get back p1
 293+ 88C7 83           .carrybyte1:            add     a,e                 ; L = L + E
 294+ 88C8 6F                                   ld      l,a                 ; .
 295+ 88C9 FD 6A                                ld      iyl,d               ; save new carry byte
 296+ 88CB 5C           .mul3:                  ld      e,h                 ; E = H * D
 297+ 88CC 50                                   ld      d,b                 ; .
 298+ 88CD ED 30                                mul     de                  ; .
 299+ 88CF FD 7D                                ld      a,iyl
 300+ 88D1 8B                                   adc     a,e                 ; .
 301+ 88D2 5F                                   ld      e,a                 ; .
 302+ 88D3 7A           .ItsNotZero:            ld      a,d                 ;
 303+ 88D4 CE 00                                adc     a,0                 ; final carry bit
 304+ 88D6 FD B4                                or      iyh                 ; bring back sign
 305+ 88D8 57                                   ld      d,a                 ; s = sign
 306+ 88D9 C9                                   ret
 307+ 88DA 11 00 00     .ResultZero:            ld      de,0
 308+ 88DD                                      ZeroA
 308+ 88DD AF          >                        xor a
 309+ 88DE 4F                                   ld      c,a
 310+ 88DF 6F                                   ld      l,a
 311+ 88E0 C9                                   ret
 312+ 88E1
 313+ 88E1              ;;;
 314+ 88E1              ;;;
 315+ 88E1              ;;;mulHLEbyDSigned:        ld      a,d                 ; get sign from d
 316+ 88E1              ;;;                        xor     h                   ; xor with h to get resultant sign
 317+ 88E1              ;;;                        and     SignOnly8Bit        ; .
 318+ 88E1              ;;;                        ld      iyh,a               ; iyh = copy of sign
 319+ 88E1              ;;;                        ld      a,h                 ; now HLE = ABS (HLE)
 320+ 88E1              ;;;                        and     SignMask8Bit        ; .
 321+ 88E1              ;;;                        ld      h,a                 ; .
 322+ 88E1              ;;;                        ld      a,d                 ; d = ABS D
 323+ 88E1              ;;;                        and     SignMask8Bit        ; .
 324+ 88E1              ;;;                        ld      d,a                 ; .
 325+ 88E1              ;;;.testEitherSideZero:    or      a
 326+ 88E1              ;;;                        jr      z,.ResultZero
 327+ 88E1              ;;;                        ld      a,h
 328+ 88E1              ;;;                        or      l
 329+ 88E1              ;;;                        or      e
 330+ 88E1              ;;;                        jr      z,.ResultZero
 331+ 88E1              ;;;; At this point HLE = ABS (HLE), A = ABS(D)
 332+ 88E1              ;;;.mul1:                  mul     de                  ; C = E * D
 333+ 88E1              ;;;                        ex      af,af'              ; save mulitplier
 334+ 88E1              ;;;                        ld      c,e                 ; C = p0
 335+ 88E1              ;;;                        ld      a,d                 ; save carry (p1)
 336+ 88E1              ;;;                        ex      af,af'              ; .
 337+ 88E1              ;;;.mul2:                  ld      e,l                 ; L = L * D
 338+ 88E1              ;;;                        ld      d,a                 ; .
 339+ 88E1              ;;;                        mul     de                  ; .
 340+ 88E1              ;;;                        ex      af,af'              ; .
 341+ 88E1              ;;;.carrybyte1:            add     a,e                 ; L = L + E
 342+ 88E1              ;;;                        ld      l,a                 ; .
 343+ 88E1              ;;;                        ld      a,d
 344+ 88E1              ;;;                        ex      af,af'              ; save new carry byte
 345+ 88E1              ;;;.mul3:                  ld      e,h                 ; E = H * D
 346+ 88E1              ;;;                        ld      d,a                 ; .
 347+ 88E1              ;;;                        mul     de                  ; .
 348+ 88E1              ;;;                        ex      af,af'              ; .
 349+ 88E1              ;;;                        adc     a,e                 ; .
 350+ 88E1              ;;;                        ld      e,a                 ; .
 351+ 88E1              ;;;.ItsNotZero:            ld      a,d                 ;
 352+ 88E1              ;;;                        adc     a,0                 ; final carry bit
 353+ 88E1              ;;;                        or      iyh                 ; bring back sign
 354+ 88E1              ;;;                        ld      d,a                 ; s = sign
 355+ 88E1              ;;;                        ret
 356+ 88E1              ;;;.ResultZero:            ld      de,0
 357+ 88E1              ;;;                        ZeroA
 358+ 88E1              ;;;                        ld      c,a
 359+ 88E1              ;;;                        ld      l,a
 360+ 88E1              ;;;                        ret
 361+ 88E1
 362+ 88E1              ; multiplication of two S156-bit numbers into a 16-bit 2'd compliment product
 363+ 88E1              ; enter : de = 16-bit multiplicand
 364+ 88E1              ;         hl = 16-bit multiplicand
 365+ 88E1              ; exit  : hl = 16-bit product
 366+ 88E1              ;         carry reset
 367+ 88E1              ;
 368+ 88E1              ; uses  : af, bc, de, hl
 369+ 88E1 00           mulDEbyHLSignByte       DB      0
 370+ 88E2 AF           mulDEbyHLSgnTo2c:       xor     a
 371+ 88E3 32 E1 88                             ld      (mulDEbyHLSignByte),a
 372+ 88E6 7A           .SignDE:                ld      a,d
 373+ 88E7 ED 27 80                             test    $80
 374+ 88EA 28 08                                jr      z,.SignHL
 375+ 88EC E6 7F        .NegativeDE:            and     $7F
 376+ 88EE 57                                   ld      d,a
 377+ 88EF 3E 80                                ld      a,$80
 378+ 88F1 32 E1 88                             ld      (mulDEbyHLSignByte),a
 379+ 88F4 7C           .SignHL:                ld      a,h
 380+ 88F5 ED 27 80                             test    $80
 381+ 88F8 28 0B                                jr      z,.AbsoluteMultiply
 382+ 88FA E6 7F        .NegativeHL:            and     $7F
 383+ 88FC 67                                   ld      h,a
 384+ 88FD 3A E1 88                             ld      a,(mulDEbyHLSignByte)
 385+ 8900 EE 80                                xor     $80
 386+ 8902 32 E1 88                             ld      (mulDEbyHLSignByte),a
 387+ 8905 CD 66 88     .AbsoluteMultiply:      call    mulDEbyHL
 388+ 8908 3A E1 88     .RecoverSign:           ld      a,(mulDEbyHLSignByte)
 389+ 890B ED 27 80                             test    $80
 390+ 890E C8                                   ret     z
 391+ 890F AF           .Negateghl: 			xor 	a
 392+ 8910 95                                   sub 	l
 393+ 8911 6F                                   ld 		l,a
 394+ 8912 9F                                   sbc 	a,a
 395+ 8913 94                                   sub 	h
 396+ 8914 67                                   ld 		h,a
 397+ 8915 C9                                   ret
 398+ 8916
 399+ 8916 AF           mulDESgnbyHLUnsgnTo2c:  xor     a
 400+ 8917 32 E1 88                             ld      (mulDEbyHLSignByte),a
 401+ 891A 7A           .SignDE:                ld      a,d
 402+ 891B ED 27 80                             test    $80
 403+ 891E 28 08                                jr      z,.AbsoluteMultiply
 404+ 8920 E6 7F        .NegativeDE:            and     $7F
 405+ 8922 57                                   ld      d,a
 406+ 8923 3E 80                                ld      a,$80
 407+ 8925 32 E1 88                             ld      (mulDEbyHLSignByte),a
 408+ 8928 CD 66 88     .AbsoluteMultiply:      call    mulDEbyHL
 409+ 892B 3A E1 88     .RecoverSign:           ld      a,(mulDEbyHLSignByte)
 410+ 892E ED 27 80                             test    $80
 411+ 8931 C8                                   ret     z
 412+ 8932 AF           .Negateghl:             xor 	a
 413+ 8933 95                                   sub 	l
 414+ 8934 6F                                   ld 		l,a
 415+ 8935 9F                                   sbc 	a,a
 416+ 8936 94                                   sub 	h
 417+ 8937 67                                   ld 		h,a
 418+ 8938 C9                                   ret
 419+ 8939
 420+ 8939
# file closed: ./Maths/multiply.asm
 196  8939
 197  8939                  INCLUDE "./Variables/constant_equates.asm"
# file opened: ./Variables/constant_equates.asm
   1+ 8939              ;Contants
   2+ 8939
   3+ 8939              SignMask8Bit		equ %01111111
   4+ 8939              SignMask16Bit		equ %0111111111111111
   5+ 8939              SignOnly8Bit		equ $80
   6+ 8939              SignOnly16Bit		equ $8000
   7+ 8939
   8+ 8939              Bit7Only            equ %10000000
   9+ 8939              Bit6Only            equ %01000000
  10+ 8939              Bit5Only            equ %00100000
  11+ 8939              Bit4Only            equ %00010000
  12+ 8939              Bit3Only            equ %00001000
  13+ 8939              Bit2Only            equ %00000100
  14+ 8939              Bit1Only            equ %00000010
  15+ 8939              Bit0Only            equ %00000001
  16+ 8939              Bit7Clear           equ %01111111
  17+ 8939              Bit6Clear           equ %10111111
  18+ 8939              Bit5Clear           equ %11011111
  19+ 8939              Bit4Clear           equ %11101111
  20+ 8939              Bit3Clear           equ %11110111
  21+ 8939              Bit2Clear           equ %11111011
  22+ 8939              Bit1Clear           equ %11111101
  23+ 8939              Bit0Clear           equ %11111110
  24+ 8939              ConstPi				equ $80
  25+ 8939              ConstNorm           equ 197
  26+ 8939
  27+ 8939              ;Text Tokens
  28+ 8939              EliteToken			equ $1E			; Token ID for text messsage ---- E L I T E ----
  29+ 8939              BrabenBellToken 	equ $0D
  30+ 8939              AcorToken			equ $0C
  31+ 8939              ; Cursor Bits
  32+ 8939              CursorClimb         equ %10000000
  33+ 8939              CursorDive          equ %01000000
  34+ 8939              CursorLeft          equ %00100000
  35+ 8939              CursorRight         equ %00010000
  36+ 8939              CursorHome          equ %00001000
  37+ 8939              CursorRecenter      equ %00000100
  38+ 8939
  39+ 8939              ; Intro Screen
  40+ 8939              TitleShip			equ	$8C
  41+ 8939              RotationUnity		equ $60
  42+ 8939              DBCheckCode			equ $DB
  43+ 8939              MaxVisibility		equ $1F
  44+ 8939              FarInFront			equ $C0
  45+ 8939              ; Equipment Flags
  46+ 8939              EquipmentItemFitted     equ $FF
  47+ 8939              EquipmentItemNotFitted  equ 0
  48+ 8939              ; Universe Managment
  49+ 8939              ShipTotalModelCount     equ 44
  50+ 8939              ShipTypeScoopable       equ 4         ; a sub set of junk
  51+ 8939              ShipTypeJunk            equ 3
  52+ 8939              ShipTypeStation         equ 2
  53+ 8939              ShipTypeMissile         equ 1
  54+ 8939              ShipTypeNormal          equ 0
  55+ 8939              ShipTypeText            equ 253
  56+ 8939              ShipTypeDebug           equ 254
  57+ 8939              ShipTypeEmpty           equ 255
  58+ 8939
  59+ 8939              SpawnTypeStation        EQU 0
  60+ 8939              SpawnTypeAsteroid       EQU SpawnTypeStation        + 1
  61+ 8939              SpawnTypeJunk           EQU SpawnTypeAsteroid       + 1
  62+ 8939              SpawnTypeCop            EQU SpawnTypeJunk           + 1
  63+ 8939              SpawnTypeTrader         EQU SpawnTypeCop            + 1
  64+ 8939              SpawnTypeNonTrader      EQU SpawnTypeTrader         + 1
  65+ 8939              SpawnTypePirate         EQU SpawnTypeNonTrader      + 1
  66+ 8939              SpawnTypeHunter         EQU SpawnTypePirate         + 1
  67+ 8939              SpawnTypeThargoid       EQU SpawnTypeHunter         + 1
  68+ 8939              SpawnTypeMission        EQU SpawnTypeThargoid       + 1
  69+ 8939              SpawnTypeStationDebris  EQU SpawnTypeMission        + 1
  70+ 8939              SpawnTypeMissionEvent   EQU SpawnTypeStationDebris  + 1
  71+ 8939              SpawnTypeDoNotSpawn     EQU SpawnTypeMissionEvent   + 1
  72+ 8939
  73+ 8939
  74+ 8939              ; Laser and Missile Settings
  75+ 8939              ; Laser and Missile
  76+ 8939              ShipLaserPower          equ %11110000
  77+ 8939              ShipMissileCount        equ %00001111
  78+ 8939              ShipMissiles1           equ %00000001
  79+ 8939              ShipMissiles2           equ %00000010
  80+ 8939              ShipMissiles3           equ %00000011
  81+ 8939              ShipMissiles4           equ %00000100
  82+ 8939              ShipMissiles5           equ %00000101
  83+ 8939              ShipMissiles6           equ %00000110
  84+ 8939              ShipMissiles7           equ %00000111
  85+ 8939              ShipMissiles8           equ %00001000
  86+ 8939              ShipMissiles9           equ %00001001
  87+ 8939              ShipMissiles10          equ %00001010
  88+ 8939              ShipMissiles11          equ %00001011
  89+ 8939              ShipMissiles12          equ %00001100
  90+ 8939              ShipMissiles13          equ %00001101
  91+ 8939              ShipMissiles14          equ %00001110
  92+ 8939              ShipMissiles15          equ %00001111
  93+ 8939              ; AI Flags  UniverseAIControl
  94+ 8939              ShipCanAnger            equ %10000000   ; Yes or no
  95+ 8939              ShipFighterBaySize      equ %01110000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
  96+ 8939              ShipFighterBaySize1     equ %00010000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
  97+ 8939              ShipFighterBaySize2     equ %00100000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
  98+ 8939              ShipFighterBaySize3     equ %00110000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
  99+ 8939              ShipFighterBaySize4     equ %01000000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 100+ 8939              ShipFighterBaySize5     equ %01010000   ; fighter day size 0 = none 1,2 = 1 or 2 fighters, 3 = infinite
 101+ 8939              ShipFighterBaySizeInf   equ %01110000   ; Infinite fighters (well 255 as thats enough)
 102+ 8939              ShipFighterType         equ %00001100   ; 4 types 0 = Worm, 1 = Sidewinder, 2 = Viper, 3 = Thargon
 103+ 8939              ShipFighterWorm         equ %00000000
 104+ 8939              ShipFighterSidewinder   equ %00000100
 105+ 8939              ShipFighterViper        equ %00001000
 106+ 8939              ShipFighterThargon      equ %00001100
 107+ 8939              ShipUltraHostile        equ %00000010   ; If ultra hostile, will never back down so behaves like a missile
 108+ 8939              ShipFree                equ $00000011   ; Unused bits at present for later
 109+ 8939              ; NewBTactics
 110+ 8939              ShipIsTrader            equ Bit0Only   ; Trader flag  80% are peaceful 20% also have Bounty Hunter flag
 111+ 8939              ShipIsBountyHunter      equ Bit1Only   ;
 112+ 8939              ShipIsHostile           equ Bit2Only   ; Also used as Angry flag now
 113+ 8939              ShipIsPirate            equ Bit3Only   ;
 114+ 8939              ShipIsDocking           equ Bit4Only   ;
 115+ 8939              ShipIsBystander         equ Bit5Only   ;
 116+ 8939              ShipIsCop               equ Bit6Only   ;
 117+ 8939              ShipHasEscapePod        equ Bit7Only   ;
 118+ 8939              ShipHostileNewBitNbr    equ 2
 119+ 8939
 120+ 8939              ; UBnkaiatkecm
 121+ 8939              ;Unused                 equ Bit0Only
 122+ 8939              ;Unused                 equ Bit1Only
 123+ 8939              ;Unused                 equ Bit2Only
 124+ 8939              ShipIsDot               equ Bit3Only
 125+ 8939              ShipKilled              equ Bit4Only    ; Ship has just been marked as killed so initiate cloud of debris
 126+ 8939              ShipExploding           equ Bit5Only
 127+ 8939              ShipIsVisible           equ Bit6Only
 128+ 8939              ShipAIEnabled           equ Bit7Only   ;
 129+ 8939
 130+ 8939
 131+ 8939              ; UBnkaiakecm 2
 132+ 8939              ;ShipAngryNewBitNbr      equ 4
 133+ 8939              ShipExplosionDuration   equ 75         ; amount of frames an explosion lasts for
 134+ 8939              ShipNotHostile          equ Bit2Clear   ;
 135+ 8939              ShipIsNotDot            equ Bit3Clear
 136+ 8939              ShipIsDotBitNbr         equ 3
 137+ 8939              ShipKilledBitNbr        equ 4
 138+ 8939              ShipIsVisibleBitNbr     equ 6
 139+ 8939              ShipIsScoopDockEsc      equ Bit7Only   ;
 140+ 8939              ShipAIDisabled          equ Bit7Clear
 141+ 8939              ShipAIEnabledBitNbr     equ 7
 142+ 8939              ShipExplodingBitNbr     equ 5
 143+ 8939              ; Equipment Defaults
 144+ 8939              ECMCounterMax           equ $80
 145+ 8939              ; Main Loop State
 146+ 8939              StatePlayerDocked       equ $FF
 147+ 8939              StateCompletedLaunch    equ $FD
 148+ 8939              StateInTransition       equ $FE
 149+ 8939              StateHJumping           equ $FC
 150+ 8939              StateHEntering          equ $FB
 151+ 8939              StateCompletedHJump     equ $FA
 152+ 8939              StateNormal             equ 0
 153+ 8939              ; Missile Stage flags , $8x = locked to ship id x, $0x = fire at ship id x requested
 154+ 8939              StageMissileNotTargeting equ $FF
 155+ 8939              StageMissileTargeting   equ $FE
 156+ 8939
 157+ 8939
 158+ 8939              ShipMaxDistance     equ 192
 159+ 8939              HyperSpaceTimers    equ $0B0B
 160+ 8939
 161+ 8939              ; -- game limts
 162+ 8939              MaxNumberOfStars	equ 11
 163+ 8939              ConsoleRefreshInterval  equ 5
 164+ 8939              MaxJunkStation      equ 3
 165+ 8939              MaxJunkFreeSpace    equ 5
 166+ 8939              WarpCoolDownPeriod  equ 90
 167+ 8939
 168+ 8939              ShipTypeSize		equ	32 			;??????? just a guess for now
 169+ 8939              ShipSST				equ 4			; its a space station
 170+ 8939              UniverseBasePage 	equ 70			; Base memory bank for universe Item #0
 171+ 8939              ShipDataBasePage	equ	90			; Needs 2mb upgrade but what the heck
 172+ 8939              ShipCountMax		equ	2			; For now just 2 ships to debug
 173+ 8939              LineLimitPerShip	equ 70			; Max lines per ship
 174+ 8939              FaceLimitPerShip	equ	70			; Same as line limit to simplify some logic
 175+ 8939              ; "NEED TO DEFINE SHIPTYPESIZE TODO"
 176+ 8939
 177+ 8939              ; Memory page managment	(Refers to a memory slot as a place to access data)
 178+ 8939              ShipDataSlot		equ	6			; this may move into rom swap out space later
 179+ 8939              UniverseObjectSlot	equ	7
 180+ 8939
 181+ 8939              KeyForwardsView		equ	$20
 182+ 8939              ; Game specific equates
 183+ 8939              MissileDropHeight   equ 5           ; how far the missile is ejected on launch in y axis
 184+ 8939              WarpSequenceCount   equ 50
 185+ 8939
 186+ 8939              ;...Game Colour Mapping
 187+ 8939              L2DustColour        equ L2ColourGREY_1
 188+ 8939              L2SunScannerBright  equ 252
 189+ 8939              L2SunScanner        equ 180
 190+ 8939              L2DebrisColour      equ L2ColourYELLOW_1
 191+ 8939
 192+ 8939
 193+ 8939              ; Ship Data
 194+ 8939              ;;;;	.XX21	\ -> &5600 \ Table of pointers to ships' data given to XX0
 195+ 8939              ;;;;00 7F			 EQUW &7F00 \ type  1 is #MSL  Missile data on page off bottom of screen
 196+ 8939              ;;;;00 00			 EQUW 0     \ type  2 is #SST  Space Station, Coriolis or Dodo.
 197+ 8939              ;;;;00 00			 EQUW 0     \ type  3 is #ESC  Escape capsule
 198+ 8939              ;;;;00 00			 EQUW 0     \ type  4 is #PLT  Plate, alloys
 199+ 8939              ;;;;00 00			 EQUW 0     \ type  5 is #OIL  Cargo cannister
 200+ 8939              ;;;;00 00			 EQUW 0     \ type  6 is       Boulder
 201+ 8939              ;;;;00 00			 EQUW 0     \ type  7 is #AST  Asteroid
 202+ 8939              ;;;;00 00			 EQUW 0     \ type  8 is #SPL  Splinter, rock.
 203+ 8939              ;;;;00 00			 EQUW 0     \ type  9 is #SHU  Shuttle
 204+ 8939              ;;;;00 00			 EQUW 0     \ type 10 is       Transporter
 205+ 8939              ;;;;00 00			 EQUW 0     \ type 11 is #CYL  Cobra Mk III,  Boa
 206+ 8939              ;;;;00 00			 EQUW 0     \ type 12 is       Python
 207+ 8939              ;;;;00 00			 EQUW 0     \ type 13 is       Last of three traders
 208+ 8939              ;;;;00 00			 EQUW 0     \ type 14 is #ANA  Anaconda
 209+ 8939              ;;;;00 00			 EQUW 0     \ type 15 is #WRM  Worm with Anaconda
 210+ 8939              ;;;;00 00			 EQUW 0     \ type 16 is #COP  Viper
 211+ 8939              ;;;;00 00			 EQUW 0     \ type 17 is       First pirate
 212+ 8939              ;;;;00 00			 EQUW 0     \ type 18 is
 213+ 8939              ;;;;00 00			 EQUW 0     \ type 19 is #KRA  Krait small pirate
 214+ 8939              ;;;;00 00			 EQUW 0     \ type 20 is #ADA  Adder
 215+ 8939              ;;;;00 00			 EQUW 0     \ type 21 is
 216+ 8939              ;;;;00 00			 EQUW 0     \ type 22 is
 217+ 8939              ;;;;00 00			 EQUW 0     \ type 23 is
 218+ 8939              ;;;;00 00			 EQUW 0     \ type 24 is #CYL2 Last strong pirate
 219+ 8939              ;;;;00 00			 EQUW 0     \ type 25 is #ASP  Asp Mk II
 220+ 8939              ;;;;00 00			 EQUW 0     \ type 26 is #FER  Fer de Lance
 221+ 8939              ;;;;00 00			 EQUW 0     \ type 27 is
 222+ 8939              ;;;;00 00			 EQUW 0     \ type 28 is	Last of three bounty hunters
 223+ 8939              ;;;;00 00			 EQUW 0     \ type 29 is #THG  Thargoid
 224+ 8939              ;;;;00 00			 EQUW 0     \ type 30 is #TGL  Thargon
 225+ 8939              ;;;;00 00			 EQUW 0     \ type 31 is #CON  Constrictor
 226+ 8939              ;;;;	.E%	\ -> &563E \ Hull NEWB bits are escpod, cop, inno, ?, pirate, angry, hunter, trader.
 227+ 8939              ;;;;			\ NEWB examples
 228+ 8939              ;;;;\ 21			EQUB &21    \ 0010 0001    9 Shuttle has no escape pod, inno, trader.
 229+ 8939              ;;;;\ 61			EQUB &61    \ 0110 0001   10 Tansporter no escape pod, Cop, inno, trader.
 230+ 8939              ;;;;\ A0			EQUB &A0    \ 1010 0000   11 Cobra has Escape pod, inno, not a trader.
 231+ 8939              ;;;;\ C2			EQUB &C2    \ 1100 0010   16 Viper has Escape pod, Cop, hunter.
 232+ 8939              ;;;;\ 8C			EQUB &8C    \ 1000 1100   19 Krait pirate has escape pod, is pirate and angry.
 233+ 8939
# file closed: ./Variables/constant_equates.asm
 198  8939                  INCLUDE "./Variables/general_variables.asm"
# file opened: ./Variables/general_variables.asm
   1+ 8939                  IFNDEF LASER_V2
   2+ 8939                  DEFINE  LASER_V2    1
   3+ 8939                  ENDIF
   4+ 8939
   5+ 8939 00 00        varAxis1	DW 	0				; address of first axis in a rotation action
   6+ 893B 00 00        varAxis2	DW	0				; address of 2nd axis in a roation action
   7+ 893D              ; Variables to simulate 6502 registers until code fixed
   8+ 893D              ; These must be here in this order as reading Y and X can then be a 16 bit read
   9+ 893D 00           regX		DB	0               ; using 16 bit read into BC this would go into C
  10+ 893E 00           regY		DB	0               ; using 16 bit read into BC this would go into B
  11+ 893F 00           regA		DB	0
  12+ 8940
  13+ 8940
  14+ 8940 00           varGPLoopA	DB	0				; General Purpose innermost loop variable
  15+ 8941 00 00        INF			DW	0				; page 0 &20 Used to get address from UNIV array
  16+ 8943 00 00        INF28		DW	0				; page 0 &20 Used to get address from UNIV array
  17+ 8945
  18+ 8945
  19+ 8945
  20+ 8945              ;XX16		DS	16				; 16 byte Matrix
  21+ 8945
  22+ 8945              P0INWK							; page 0 & 46
  23+ 8945              p0INWK31						; page 0 & 65
  24+ 8945              P0INWK36						; PAGE 0 &6A
  25+ 8945
  26+ 8945 00           XX4			DB	0				; XX4 page 0 &96 last Normal Found to be visible
  27+ 8946              LastNormalVisible	equ	XX4
  28+ 8946              varXX4              equ XX4
  29+ 8946
  30+ 8946
  31+ 8946
  32+ 8946 00           PATG		DB	0				; 6502 &03C9
  33+ 8947 00 00        SLSP 		DW	0				; &03B0 \ SLSP \ ship lines pointer
  34+ 8949
  35+ 8949
  36+ 8949              ;UNIV		DS FreeListSize*2	; Array of Universe Pointers
  37+ 8949              ;HULLINDEX	DS ShipTypeSize*2	; hull index for table at XX21= &5600 XX21-1,Y
  38+ 8949
  39+ 8949              ; Present System Variables
  40+ 8949
  41+ 8949 2B           RandomSeed				DB	43			    ; 00 DEBUG JUST SOME START VALUES
  42+ 894A 20           RandomSeed1				DB	32	            ; 01
  43+ 894B 0C           RandomSeed2				DB	12			    ; 02
  44+ 894C 42           RandomSeed3				DB	66			    ; 03
  45+ 894D 00 00 00 00  RandomSeedSave          DS  4               ; used in explosion routine to save randoms
  46+ 8951 00           varT1					DB	0				; 06
  47+ 8952 00           SClo					DB 0				; 07
  48+ 8953 00           SChi					DB 0				; 08
  49+ 8954 00           varP					DB 0 				; 10	XX16+7
  50+ 8955 00           varPhi					DB 0 				; 11	XX16+8
  51+ 8956 00           varPhi2					DB 0 				; 12	XX16+9
  52+ 8957              varPp1                  equ varPhi
  53+ 8957              varPp2                  equ varPhi2
  54+ 8957 00           UnivPointerLo			DB	0				; 20		INF                 XX0+2
  55+ 8958 00           UnivPointerHi			DB	0				; 21      INF+1               XX0+3
  56+ 8959              UnivPointer				equ	UnivPointerLo
  57+ 8959 00           varV					DB 0				; 22                          XX0+4
  58+ 895A 00           varVHi					DB 0				; 23                          XX0+5
  59+ 895B 00           varXXlo                 DB 0                ; 24
  60+ 895C 00           varXXHi                 DB 0                ; 25
  61+ 895D              varXX					equ	varXXlo
  62+ 895D 00           YYlo                    DB 0                ; 26
  63+ 895E 00           YYHi                    DB 0                ; 27
  64+ 895F              varYY					equ	YYlo
  65+ 895F              											;	28
  66+ 895F              											;	29
  67+ 895F              ;PlayerShipPositionData - Must be contiguous for setup
  68+ 895F 00           BETA 					DB	0               ; 2A        (pitch done)
  69+ 8960 00           JSTY                    DB  0               ; Joystick analog
  70+ 8961 00           BET1 					DB	0               ; 2B        lower7 magnitude
  71+ 8962 00           BET2                    DB  0               ;            climb sign
  72+ 8963 00           BET2FLIP				DB	0				; 7C		BET 2 pitch Sign negated
  73+ 8964 1F           BET1MAXC                DB  31              ; max climb
  74+ 8965 E1           BET1MAXD                DB  -31             ; max dive
  75+ 8966 00           XC						DB	0               ; 2C
  76+ 8967 00           YC						DB 	0               ; 2D
  77+ 8968              ;... ECM logic. If another ship adds ECM then we just set the loop A and B to starting values so they overlap
  78+ 8968 00           ECMCountDown            DB  0
  79+ 8969 00           ECMLoopB                DB  0
  80+ 896A 00 00        JSTX                    DW  0               ;           Joystick analog value
  81+ 896C 00           ALPHA					DB	0				; 8D        Alpha with bit 7 sign
  82+ 896D 00           ALP1					DB 	0				; 31		ALP1	Roll magnitude Also Apha
  83+ 896E 00           ALP2					DB  0				; 32		ALP2	Roll Sign
  84+ 896F 00           ALP2FLIP				DB  0				; 33		ALP2	negated roll sign
  85+ 8970 1F           ALP1MAXR                DB  31               ;   Maximum roll, added becuase we may allow different ship types
  86+ 8971 E1           ALP1MAXL                DB  -31             ;   Maximum roll, added becuase we may allow different ship types
  87+ 8972
  88+ 8972
  89+ 8972              ;-- Message handler -----------------------------------------------------------------------------------------------------------------
  90+ 8972              MAXMESSAGES             EQU 5
  91+ 8972              MESSAGETIMELIMIT        EQU 20
  92+ 8972              MESSAGESIZE             EQU 33
  93+ 8972              MESSAGELINE             EQU $0001
  94+ 8972
  95+ 8972 00           MessageCount            DB  0                ; used for enquing messages later
  96+ 8973 00           MessageCurrent          DB  0
  97+ 8974 05 00        MessageIndex            DW  MAXMESSAGES
  98+ 8976 00 00 00...  MessageQueue            DS  MAXMESSAGES * MESSAGESIZE
  99+ 8A1B 05           MessageTimeout          DB  MAXMESSAGES
 100+ 8A1C 00 00 00...  IndexedWork				DS	37				; General purpose work space when doing temp arrays
 101+ 8A41
 102+ 8A41              ; MOVED TO Universe XX19					DB	0				; page 0 &67
 103+ 8A41              ; MOVED TO Universe XX20					DB	0				; page 0 &67 also used as XX19+1 for XX19 being a word
 104+ 8A41              ;DEFUNCT EQUATE NormalCountCopyBy4		equ	XX20			; Also used for normal * 4 holding variable
 105+ 8A41 00           XX21					DB  0				; this may be part of XX20/xx21 accordign to spawn new shipXX21		DW	0				; Ah XX21 is hull pointer  hull pointer lo as it can;t hold HULLINDX as 16bit array
 106+ 8A42              ;XX21 is the pointer table to the pages for ship types. this will be repalaced by paging so just need an equate for first page
 107+ 8A42
 108+ 8A42
 109+ 8A42 00           QQ17					DB	0				;   72
 110+ 8A43 00           XX18xlo                 DB  0               ;	72		XX18   xlo
 111+ 8A44 00           XX18xhi                 DB  0               ;	73		XX18+1 xhi
 112+ 8A45 00           XX18xsg                 DB  0               ;	74		XX18+2 xsgn
 113+ 8A46 00           XX18ylo                 DB  0               ;	75		XX18   ylo
 114+ 8A47 00           XX18yhi                 DB  0               ;	76		XX18+1 yhi
 115+ 8A48 00           XX18ysg                 DB  0               ;	77		XX18+2 ysgn
 116+ 8A49 00           XX18zlo                 DB  0               ;	78		XX18   zlo
 117+ 8A4A 00           XX18zhi                 DB  0               ;	79		XX18+1 zhi
 118+ 8A4B 00           XX18zsg                 DB  0               ;	7A		XX18+2 zsgn
 119+ 8A4C
 120+ 8A4C 28           SHIPMAXSPEED            DB  40              ; variable to facilitate ship editing later
 121+ 8A4D 00           DELTA					DB 	0				; 7D 		DELTA  \ bpl -2 inserted here to stall from title code if byte check fails
 122+ 8A4E 00           DELT4Lo					DB 	0				; 7E
 123+ 8A4F 00           DELT4Hi					DB 	0				; 7F
 124+ 8A50              DELTA4                  equ                 DELT4Lo
 125+ 8A50
 126+ 8A50              ; SoundFX Variables -------------------------------------------------------------------------------------------
 127+ 8A50              ;DEFUNCT, uses DELTA/ LAST_DELTAEngineSoundChanged:     DB  0
 128+ 8A50 FF           SoundFxToEnqueue        DB  $FF             ; $FF No sound to enque,if it is $FF then next sound will not get enqued
 129+ 8A51 00           InterruptCounter        DB 0                ; simple marker updated once per IM2 event
 130+ 8A52
 131+ 8A52
 132+ 8A52              ; Not thise must be in this order else 16 bit fetches will fail
 133+ 8A52 00           varU                    DB  0               ;   80
 134+ 8A53 00           varQ					DB  0 				;	81
 135+ 8A54 00           varR					DB  0 				;	82
 136+ 8A55 00           varS					DB  0 				;	83
 137+ 8A56              varRS                   equ varR
 138+ 8A56
 139+ 8A56 00 00        varU16                  DW  0               ; 16 bit variant on varU as I can't use above for this
 140+ 8A58
 141+ 8A58 00           XSAV					DB	0				; 84	   XSAV usef for nearby ship count outer
 142+ 8A59 00           YSAV                    DB  0               ; 85
 143+ 8A5A 00           XX17					DB	0				; 86
 144+ 8A5B              RequiredScale			equ  XX17			; use to hold calculated scale in drawing ship
 145+ 8A5B              varXX17                 equ  XX17
 146+ 8A5B 00           ScreenChanged           DB  0
 147+ 8A5C 00           ScreenIndex             DB  0
 148+ 8A5D 00 00        ScreenIndexTablePointer DW  0
 149+ 8A5F 00           InvertedYAxis           DB  0
 150+ 8A60 00           MenuIdMax				DB	0				;	87		MenuIdMax		QQ11
 151+ 8A61              											; Bit 7 Set  ShortRangeChart    $80
 152+ 8A61              											; Bit 6 Set  Galactic Chart     $40
 153+ 8A61              											; Bit 5 Set  Market Place       $20
 154+ 8A61              											; Bit 4 Set  Status Screen      $10
 155+ 8A61              											; Bit 3 Set  Display Inventory  $08
 156+ 8A61                                                          ; Bit 2 Set  Planet Data        $04
 157+ 8A61                                                          ; View bit combinations if the ones above not matched
 158+ 8A61                                                          ; bits 1 0
 159+ 8A61                                                          ;      1 1  Front view , i.e. $03
 160+ 8A61                                                          ;      1 0  Aft View          $02
 161+ 8A61                                                          ;      0 1  Left View         $01
 162+ 8A61                                                          ;      0 0  Right view        $00
 163+ 8A61              											; Bit 0 Set  Data On System
 164+ 8A61              											; 0  Space View (Not a menu)
 165+ 8A61 00           ZZDust					DB	0				;	88		ZZDust (Poss 16 bit need to check)
 166+ 8A62 00           XX13                    DB  0               ;   89
 167+ 8A63 00           TYPE					DB	0				; 8C used for ship type in drawing
 168+ 8A64              ;Docked flag = 00 = in free space
 169+ 8A64              ;              FF = Docked
 170+ 8A64              ;              FE = transition
 171+ 8A64              ;              FD = Setup open space and transition to not docked
 172+ 8A64              ;              FC = Hyperspace manimation
 173+ 8A64              ;              FB = Hyperspace complete
 174+ 8A64 00           varSWAP                 DB  0               ; 90 , general purpose swap variable
 175+ 8A65 00           varCNT                  DB  0               ; 93
 176+ 8A66
 177+ 8A66 00           varK					DB	0				; 40
 178+ 8A67 00           varKp1					DB	0				; 41
 179+ 8A68 00           varKp2					DB	0				; 42
 180+ 8A69 00           varKp3					DB	0				; 43
 181+ 8A6A
 182+ 8A6A 00           varK2                   DB  0               ; 9B
 183+ 8A6B 00           varK2p1                 DB  0               ; 9C K2 plus 1
 184+ 8A6C 00           varK2p2                 DB  0               ; 9D K2 plus 2
 185+ 8A6D 00           varK2p3                 DB  0               ; 9E K2 plus 3
 186+ 8A6E
 187+ 8A6E 00           Point                   DB  0               ; 9F      POINT
 188+ 8A6F
 189+ 8A6F 00           varT					DB	0				; D1
 190+ 8A70 00           varTSign                DB  0               ; for teh odd need for a 16 bit varT
 191+ 8A71
 192+ 8A71 00 00 00...  varVector9ByteWork      DS  9
 193+ 8A7A
 194+ 8A7A 00 00 00 00  varK3					DS	4				; D2
 195+ 8A7E 00           varK3p2					DB	0				; 42
 196+ 8A7F 00           varK3p3					DB	0				; 43
 197+ 8A80              varK3p1					equ varK3+1			; D3
 198+ 8A80 00 00 00 00  varK4					DS	4				; E0
 199+ 8A84              varK4p1					equ varK4+1			; D3
 200+ 8A84
 201+ 8A84
 202+ 8A84              ;Heap
 203+ 8A84
 204+ 8A84 00 00        HeapStart				DS	2				; &0100 XX3 50 bytes for now
 205+ 8A86 00 00 00...  HeapData				DS	50
 206+ 8AB8              ; Contains 				X 16 bit, Y ;MissileArmedStatus		DB	0				; 0344 MSAR   using MissileTarget, if missile is not armed tehn target is FF
 207+ 8AB8              ; TODO will need an read for a list of missiles, who they are targeting an the target current vector for AI persuit
 208+ 8AB8              ; i.e. a list of programmed missiles in universe slot list code
 209+ 8AB8 00 00 00...  DampingKeys				DS  7				; 0387 - 038D
 210+ 8ABF              ;  #&6 Does K toggle keyboard/joystick control -  03CD certainly makes keyboard not work anymore.
 211+ 8ABF              ;  #&5 Does J reverse both joystick channels
 212+ 8ABF              ;  #&4 Does Y reverse joystick Y channel			03CB
 213+ 8ABF              ;  #&2 Does X toggle startup message display ? PATG?	03C9
 214+ 8ABF              ;  #&3 Does F toggle flashing information			03CA
 215+ 8ABF              ;  #&1 Does A toggle keyboard auto-recentering ?
 216+ 8ABF              ;  #&0 Caps-lock toggles keyboard flight damping
 217+ 8ABF
 218+ 8ABF              ;-- Galaxy and Universe Variables ----------------------------------------------------------------------------------------------------
 219+ 8ABF 00 00 00...  SystemSeed				DS  5				;	6C		QQ15	Current Galaxy Seed
 220+ 8AC4 00 00 00...  StockAvaliabiliy		DS 	16				; 038D - 039C Stock inventory in station
 221+ 8AD4 00           AlienItemsAvaliability  DB	0				; 039D
 222+ 8AD5 00           RandomMarketSeed		DB	0				; 039E   \ QQ26	\ random byte for each system vist (for market)
 223+ 8AD6 00           Galaxy      			DB	0				; 0367 Galaxy (incremented with galactiv drive
 224+ 8AD7 00 00 00...  WorkingSeeds			DS	6
 225+ 8ADD 00 00 00...  PresentSystemSeeds		DS	6				; 03B2 - 03B7
 226+ 8AE3 00 00 00...  GalaxySeeds				DS	6				; 035B - 0360 QQ21
 227+ 8AE9 00           PresentSystemX			DB	0				; System we are currently in
 228+ 8AEA 00           PresentSystemY			DB  0				; System we are currently in
 229+ 8AEB 00           TargetSystemX			DB	0				; System we are targeting for jump
 230+ 8AEC 00           TargetSystemY			DB	0				; System we are targeting for jump
 231+ 8AED              ; --- Current System Data ------------------------------------------------------------------------------------------------------------
 232+ 8AED 00           GovPresentSystem		DB	0				; 03AE Govenment
 233+ 8AEE 00           TekPresentSystem		DB	0				; 03AF Technology
 234+ 8AEF 00           SpaceStationSafeZone    DB  0               ; Flag to determine if we are in safe zone
 235+ 8AF0 00           ExtraVesselsCounter     DB  0
 236+ 8AF1 00           JunkCount				DB  0				; $033E
 237+ 8AF2 00           AsteroidCount           DB  0               ; Not used as yet
 238+ 8AF3 00           TransporterCount        DB  0
 239+ 8AF4 00           CopCount                DB  0
 240+ 8AF5 00           PirateCount             DB  0
 241+ 8AF6              ;- commander and ship state variables ------------------------------------------------------------------------------------------------
 242+ 8AF6 00           NbrMissiles				DB	0				; 038B	Does this clash with Dampingkeys?
 243+ 8AF7 00           PlayerECMActiveCount    DB  0               ; Countdown for player ECM
 244+ 8AF8 00           FugitiveInnocentStatus	DB	0				; 038C	FIST
 245+ 8AF9 00 00        KillTally  				DW	0				; 039F - 03A0 \ TALLY   \ kills lo hi
 246+ 8AFB 00           CurrentRank             DB  0   			;
 247+ 8AFC 00           MarketPrice				DB	0				; 03AA QQ24
 248+ 8AFD 00           MaxStockAvaliable		DB  0				; 03AB   \ QQ25     \ max available
 249+ 8AFE 00           SystemEconomy			DB  0				; 03AC \ QQ28   \ the economy byte of present system (0 is Rich Ind.)
 250+ 8AFF 00           CargoItem				DB	0				; 03AD (I think its item type just scooped) QQ29
 251+ 8B00 00 00        ShipLineStackPointer	DW	0				; 03B0 & 03B1 ship Lines pointer reset to top LS% = &0CFF (make DW for z80 and direct hl pointer)
 252+ 8B02              											; this is ship lines stack pointer so may be redundant with paging
 253+ 8B02              											; LS = line stack so we will have one for now to remove later
 254+ 8B02              ; - no longer used, holding here intil its safe to delte
 255+ 8B02 00           MCH						DB	0				; 03A4  \ MCH  \ old message to erase
 256+ 8B03 00           COMP     				DB	0				; 03A1 2nd competion byte used for save integrity checks?
 257+ 8B04              ; not needed as we don't do security on file COK						DB	0				; 0366 Competition Byte what ? Does some file check and accelleration check
 258+ 8B04              ; - no longer used, holding here intil its safe to delte
 259+ 8B04
 260+ 8B04 00           DisplayEcononmy			DB	0				; 03B8
 261+ 8B05 00           DisplayGovernment		DB  0				; 03B9 Is it target? 03B9 \ QQ4	 \ Government, 0 is Anarchy.
 262+ 8B06 00           DisplayTekLevel			DB	0				; 03BA   \ QQ5	\ Tech
 263+ 8B07 00 00        DisplayPopulation		DW	0				; 03BB \ QQ6  \ population*10
 264+ 8B09 00 00        DisplayProductivity		DW	0				; 03BD \ QQ7   \ productivity*10
 265+ 8B0B 00 00        Distance          		DW	0				; 03BE \ QQ8 distince in 0.1LY units
 266+ 8B0D 00 00        DisplayRadius			DW	0
 267+ 8B0F              ; --- Used in creation of sun and planet ------------------------------------------------------------------------------------------------
 268+ 8B0F 00           PlanetXPos              DS  1
 269+ 8B10 00           PlanetYPos              DS  1
 270+ 8B11 00           PlanetZPos              DS  1
 271+ 8B12 00           PlanetType              DS  1
 272+ 8B13 00           SunXPos                 DS  1
 273+ 8B14 00           SunYPos                 DS  1
 274+ 8B15 00           SunZPos                 DS  1
 275+ 8B16              ; -- Current Missile Runbtime data ------------------------------------------------------------------------------------------------
 276+ 8B16 00           CurrentMissileBank:     DB      0                                   ; used by missile logic as local copy of missile bank number
 277+ 8B17 00 00        MissileXPos             DW      0
 278+ 8B19 00           MissileXSgn             DB      0
 279+ 8B1A 00 00        MissileYPos             DW      0
 280+ 8B1C 00           MissileYSgn             DB      0
 281+ 8B1D 00 00        MissileZPos             DW      0
 282+ 8B1F 00           MissileZSgn             DB      0
 283+ 8B20 00 00        CurrentTargetXpos       DS      2
 284+ 8B22 00 00        CurrentTargetXsgn       DS      2
 285+ 8B24 00 00        CurrentTargetYpos       DS      2
 286+ 8B26 00 00        CurrentTargetYsgn       DS      2
 287+ 8B28 00 00        CurrentTargetZpos       DS      2
 288+ 8B2A 00 00        CurrentTargetZsgn       DS      2
 289+ 8B2C 00 00        TargetVectorXpos        DS      2
 290+ 8B2E 00 00        TargetVectorXsgn        DS      2
 291+ 8B30 00 00        TargetVectorYpos        DS      2
 292+ 8B32 00 00        TargetVectorYsgn        DS      2
 293+ 8B34 00 00        TargetVectorZpos        DS      2
 294+ 8B36 00 00        TargetVectorZsgn        DS      2
 295+ 8B38 00           CurrentMissileBlastRange:      DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 296+ 8B39 00           CurrentMissileBlastDamage:     DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 297+ 8B3A 00           CurrentMissileDetonateRange:   DB  0                       ; TODO Initi for runtime copied in when setting up a missile, allows for proximity missiles
 298+ 8B3B 00           CurrentMissileDetonateDamage:  DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 299+ 8B3C              ; --- Spawn Probability Table ---------------------------------------------------------------------------------------------------
 300+ 8B3C 00 00 00...  SpawnLowVssalue         DS 6                                ; Maxium of 6 entries in table
 301+ 8B42 00 00 00...  SpawnHighvalue          DS 6                                ; Maxium of 6 entries in table
 302+ 8B48 00 00 00...  ShipClassId             DS 6
 303+ 8B4E              ; --- Space dust ----------------------------------------------------------------------------------------------------------------
 304+ 8B4E 00 00 00...  varDustWarpRender       DS MaxNumberOfStars * 2 ; Copy of base positions for warp
 305+ 8B64 00 00 00...  varDust                 DS MaxNumberOfStars * 6
 306+ 8BA6 00 00 00...  varDustSceen            DS MaxNumberOfStars * 2 ; To optimise star list to wipe from screen
 307+ 8BBC 00           varStarX                DB 0
 308+ 8BBD 00           varStarY                DB 0
 309+ 8BBE 00 00 00...  varDustX                DS MaxNumberOfStars *2
 310+ 8BD4 00 00 00...  varDustY                DS MaxNumberOfStars *2
 311+ 8BEA 00 00 00...  varDustZ                DS MaxNumberOfStars *2
 312+ 8C00              ; --- Main Loop Data -------------------------------------------------------------------------------------------------------------
 313+ 8C00 00           DockedFlag				DB	0				; 8E -
 314+ 8C01 00           GamePaused              DB  0
 315+ 8C02 00           CurrentUniverseAI       DB  0               ; current ship unviverse slot due an AI update
 316+ 8C03 00           SelectedUniverseSlot    DB  0
 317+ 8C04 00           SetStationHostileFlag   DB  0               ; used to semaphore angry space station
 318+ 8C05 00           ShipBlastCheckCounter   DB  0
 319+ 8C06 00           InnerHyperCount			DB 	0				; 2F QQ22+1 (will move to a CTC timer later)
 320+ 8C07 00           OuterHyperCount			DB 	0				; 2E QQ22
 321+ 8C08 00           WarpCooldown            DB  0
 322+ 8C09 00           EventCounter            DB  0
 323+ 8C0A 00           HyperCircle             DB  0
 324+ 8C0B 00           MissJumpFlag            DB  0
 325+ 8C0C 00           PlayerMisJump			DB	0				; $0341 witchspace misjump
 326+ 8C0D 00           HyperSpaceFX			DB	0				; 0348 HFX (probabyl BBC specific
 327+ 8C0E 00           ExtraVessels			DB	0				; 0349 EV Use d by cops, extra vessels still to spawn?
 328+ 8C0F 00           Delay					DB	0				; 034A Delay general purpose eg. spawing EV or when printign messages
 329+ 8C10 00           CurrentMissileCheck:    DB  0               ; if > Universe Slot list then free for next missile
 330+ 8C11 00           MessageForDestroyed		DB	0				; 034B Message flag for item + destroyed
 331+ 8C12              UniverseSlotListSize    equ	12
 332+ 8C12 00 00 00...  UniverseSlotList        DS  UniverseSlotListSize
 333+ 8C1E 00 00 00...  UniverseSlotType        DS  UniverseSlotListSize ; base type, e.g. missile, cargo etc,
 334+ 8C2A              ; Probably not needed UniverseTypeCount       DS  UniverseSlotListSize
 335+ 8C2A 05           ConsoleRefreshCounter   DB  ConsoleRefreshInterval ; Every 4 interations the console will update twice (once for primary and once for seconday buffer)
 336+ 8C2B 00           ConsoleRedrawFlag       DB  0
 337+ 8C2C 00           TextInputMode           DB  0
 338+ 8C2D 00           CursorKeysPressed       DB  0               ; mapping of the current key presses
 339+ 8C2E                                                          ; 7    6    5    4     3    2        1    0
 340+ 8C2E                                                          ; Up   Down Left Right Home Recentre
 341+ 8C2E 00           FireLaserPressed        DB  0
 342+ 8C2F 00           WarpPressed             DB  0
 343+ 8C30 00           CompassColor			DB	0				; 03C5
 344+ 8C31 00           SoundToggle				DB	0				; 03C6
 345+ 8C32 00           KeyboardRecenterToggle	DB	0				; 03C8
 346+ 8C33 00           PATGMask				DB	0				; &03C9    \ PATG	\ Mask to scan keyboard X-key, for misjump
 347+ 8C34 00           FlashToggle				DB  0				; 03CA \ FLH \ flash toggle
 348+ 8C35 00           ReverseJoystick			DB	0				; 03CB \ JSTGY \ Y reverse joystick Y channel
 349+ 8C36 00           JoystickToggle			DB	0				; 03CD  \ JSTK    \ K toggle keyboard/joystick
 350+ 8C37 00           DigitalJoystick			DB	0				; 03CE \ JDB   \ . = toggle between keyboard and bitpaddle
 351+ 8C38 00           DiskReadFailFlag		DB	0				; 03CF \ CATF \ Disk catalog fail flag
 352+ 8C39
 353+ 8C39              ; Working Data
 354+ 8C39
 355+ 8C39              ;UniverseTable			DS	26				; 1741  \ address pointers for 13 ships INF on pages &9. 37 bytes each.
 356+ 8C39              ; $0900 =	EQUW page9+37* 0 \ copied to inner worskpace INWK on zero-page when needed
 357+ 8C39              ; $0925 =	EQUW page9+37* 1
 358+ 8C39              ; $094A =	EQUW page9+37* 2
 359+ 8C39              ; $096F =	EQUW page9+37* 3
 360+ 8C39              ; $0994 =	EQUW page9+37* 4
 361+ 8C39              ; $09B9 =	EQUW page9+37* 5
 362+ 8C39              ; $09DE =	EQUW page9+37* 6
 363+ 8C39              ; $0A03 =	EQUW page9+37* 7
 364+ 8C39              ; $0A28 =	EQUW page9+37* 8
 365+ 8C39              ; $0A4D =	EQUW page9+37* 9
 366+ 8C39              ; $0A72 =	EQUW page9+37*10
 367+ 8C39              ; $0A97 =	EQUW page9+37*11
 368+ 8C39              ; $0ABC =	EQUW page9+37*12 \ allwk up to &0ABC while heap for edges working down from &CFF.
 369+ 8C39
 370+ 8C39
 371+ 8C39
 372+ 8C39              ; 0b00 is start address of data to save
 373+ 8C39              ; Now MissionData VarTP					DB	0				; 0358 TP? The Plan  \ mission uses lower 4 bits
 374+ 8C39              											; Bit mask XXXX10XX - Thargoid plan mission
 375+ 8C39
 376+ 8C39 00           MissionData				DB	0				; &0B00	  \ look at data, first byte is TP mission bits
 377+ 8C3A
 378+ 8C3A 00 00        FileNameStringPointer	DW	0				;0C00	   \ pointer to filename string
 379+ 8C3C 00 00        CommanderLoadAddress	DW	0				;0C03
 380+ 8C3E 00 00        LengthOfFile			DW	0				;0C0B
 381+ 8C40 00 00        SaveDataEndAddress		DW	0				;&0C0F	      \ &0C00 is end address of data to save
 382+ 8C42
 383+ 8C42 00 00 00...  EdgesBuffer				DS 50
 384+ 8C74              EdgesBufferSP			equ	$				; Was $0CFF			; Heap pointer for edges buffer
 385+ 8C74              ShipLinesBufferSP		equ EdgesBufferSP	; was $0CFF
 386+ 8C74
 387+ 8C74 00 00 00...  ShipLineStack			DS  70			; For now but will be in the page later
 388+ 8CBA              ShipLineStackTop		equ $ - ShipLineStack
 389+ 8CBA
 390+ 8CBA 00 00 00...  LSO						DS 	$C0				;0E00 Line Buffer Solar of 192 lines (may be 191 in reality)
 391+ 8D7A              ; LSX vector overlaps with LSO
 392+ 8D7A 00           LSX2					DB	0				; &0EC0	    \ LSX2 bline buffer size?
 393+ 8D7B 00           LSY2					DB	0           	; &0F0E	    \ LSY2
 394+ 8D7C
 395+ 8D7C              ; -- Player Runtime Data
 396+ 8D7C 00           GunTemperature          DB  0
 397+ 8D7D 00           CabinTemperature        DB  0
 398+ 8D7E 00           PlayerForwardSheild0	DB	0 ; ?????
 399+ 8D7F 00           PlayerForwardSheild1    DB	0
 400+ 8D80 00           PlayerForwardSheild2    DB	0
 401+ 8D81 00           ForeShield				DB	0				; These three must be contiguous
 402+ 8D82 00           AftShield				DB	0				; .
 403+ 8D83 00           PlayerEnergy			DB	0				; and in this order
 404+ 8D84 00           CompassX				DB	0				; 03A8
 405+ 8D85 00           CompassY				DB	0				; 03A9
 406+ 8D86              ; Simplification of missile targetting
 407+ 8D86              ; $FF no missile targettting enabled
 408+ 8D86              ; $FE missile targetting, no target selected
 409+ 8D86              ; bit 7 set then tagetting and lower nibble holds missile target and launching
 410+ 8D86              ; bit 7 clear launch at selected target in lower nibble
 411+ 8D86 00           MissileTargettingFlag   DB  0
 412+ 8D87              ;;MissileTarget			DB  0				; 45
 413+ 8D87              ;;MissileLaunchFlag       DB  0
 414+ 8D87 00 00 00...  CommanderName           DS  15
 415+ 8D96 00           CommanderName0			DB	0				; Sneaky little 0 to allow use of print name directly
 416+ 8D97 00           BadnessStatus           DB  0
 417+ 8D98              ;note rapidly changing views could reset these so need to consider it in an array
 418+ 8D98              ; LaserType
 419+ 8D98              ; LaserPulseRate                          ; how many pulses can be fired before long pause
 420+ 8D98              ; LaserPulsePause                         ; time before next pulse - 0 = beam
 421+ 8D98              ; LaserPulseRest                          ; time before pulse count resets to 0
 422+ 8D98              ; LaserDamageOutput                       ; amount of damage for a laser hit
 423+ 8D98              ; LaserEnergyDrain                        ; amount of energy drained by cycle
 424+ 8D98              ; LaserHeat                               ; amount of heat generated
 425+ 8D98              ; LaserDurability                         ; probabability out of 255 that a hit on unshielded will add random amount of damage
 426+ 8D98              ; LaserDurabilityAmount                   ; max amount of damagage can be sustained in one damage hit
 427+ 8D98              ; LaserInMarkets                          ; can this laser be purchased 0 = yes 1 = no
 428+ 8D98              ; LaserTechLevel                          ; minimum tech level system to buy from
 429+ 8D98              ; need to add copy table routines
 430+ 8D98 00           CurrLaserType           DB  0               ; current view laser type, copied in from LaserType array
 431+ 8D99 00           CurrLaserDamage         DB  0               ; copied in from LaserDamagedFlag array
 432+ 8D9A 00           CurrLaserPulseRate      DB  0               ; current view laser amount of pulses
 433+ 8D9B 00           CurrLaserPulseOnTime    DB  0               ; how many cycles the laser is on
 434+ 8D9C 00           CurrLaserPulseOffTime   DB  0               ; how many cycles the laser is on
 435+ 8D9D 00           CurrLaserPulseRest      DB  0               ; current view laser delay setup between pulses
 436+ 8D9E
 437+ 8D9E                  IFDEF LASER_V2
 438+ 8D9E 00           LaserBeamOn             DB  0
 439+ 8D9F 00           CurrLaserDuration       DB  0   ; == CurrLaserPulseOnTime
 440+ 8DA0 00           CurrentBurstPause       DB  0   ; == CurrLaserPulseOffTime
 441+ 8DA1 00           CurrentCooldown         DB  0   ; == CurrLaserPulseRest
 442+ 8DA2                  ENDIF
 443+ 8DA2 00           CurrLaserBurstRate      DB  0
 444+ 8DA3 00           CurrLaserBurstCount     DB  0   ; == LaserPulseRate
 445+ 8DA4 00           CurrLaserDamageOutput   DB  0
 446+ 8DA5 00           CurrLaserEnergyDrain    DB  0
 447+ 8DA6 00           CurrLaserHeat           DB  0
 448+ 8DA7 00           CurrLaserDurability     DB  0
 449+ 8DA8 00           CurrLaserDurabilityAmount DB  0
 450+ 8DA9
 451+ 8DA9              ; Count down timers must be aligned like this to work
 452+ 8DA9 00           CurrLaserPulseOnCount   DB  0               ; how many cycles the laser is on timer
 453+ 8DAA 00           CurrLaserPulseOffCount  DB  0               ; how many cycles the laser is on timer
 454+ 8DAB 00           CurrLaserPulseRestCount DB  0               ; countdown after shooting for next shot
 455+ 8DAC 00           CurrLaserPulseRateCount DB  0               ; current view laser current pulses fired
 456+ 8DAD
 457+ 8DAD              ; -- Input variables
 458+ 8DAD 00           JoystickX				DB	0				; 034C JSTX
 459+ 8DAE 00           JoystickY				DB	0				; 034D JSTY
 460+ 8DAF 00           XSAV2 					DB	0				; 034E used to temporary save 6502 X reg
 461+ 8DB0 00           YSAV2 					DB	0				; 034F used to temporary save 6502 Y reg
 462+ 8DB1
 463+ 8DB1              ; -- Console drawing data
 464+ 8DB1              FShieldStart            equ $8410
 465+ 8DB1              AShieldStart            equ $8D10
 466+ 8DB1              FuelStart               equ $9410
 467+ 8DB1
 468+ 8DB1              EnergyBar4Start         equ $A5D5
 469+ 8DB1              EnergyBar3Start         equ $ADD5
 470+ 8DB1              EnergyBar2Start         equ $B5D5
 471+ 8DB1              EnergyBar1Start         equ $BDD5
 472+ 8DB1              ; 70 /2 = 35 values
 473+ 8DB1              ;                            0                             1                             2                             3
 474+ 8DB1              ;                            0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6
 475+ 8DB1 01 02 02 03  FuelMapping             DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,19,20,21,21,22,23,24,25,26,27,28,30,31,31
 475+ 8DB5 04 04 05 06
 475+ 8DB9 06 07 08 09
 475+ 8DBD 0A 0A 0B 0C
 475+ 8DC1 0D 0E 0E 0F
 475+ 8DC5 10 10 11 13
 475+ 8DC9 14 15 15 16
 475+ 8DCD 17 18 19 1A
 475+ 8DD1 1B 1C 1E 1F
 475+ 8DD5 1F
 476+ 8DD6              SpeedoStart             equ $84D1
 477+ 8DD6              ;                            0                             1                             2                             3                             4
 478+ 8DD6              ;                            0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0
 479+ 8DD6 01 02 02 03  SpeedoMapping           DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,18,19,20,20,21,22,23,24,24,25,26,26,27,28,28,29,30,31
 479+ 8DDA 04 04 05 06
 479+ 8DDE 06 07 08 09
 479+ 8DE2 0A 0A 0B 0C
 479+ 8DE6 0D 0E 0E 0F
 479+ 8DEA 10 10 11 12
 479+ 8DEE 13 14 14 15
 479+ 8DF2 16 17 18 18
 479+ 8DF6 19 1A 1A 1B
 479+ 8DFA 1C 1C 1D 1E
 479+ 8DFE 1F
 480+ 8DFF
 481+ 8DFF              DialMiddleXPos          equ $E1
 482+ 8DFF              RollMiddle              equ $8CE0
 483+ 8DFF              PitchMiddle             equ $94E0
 484+ 8DFF
 485+ 8DFF
 486+ 8DFF
 487+ 8DFF
 488+ 8DFF
# file closed: ./Variables/general_variables.asm
 199  8DFF
 200  8DFF              ; Include all maths libraries to test assembly
 201  8DFF
 202  8DFF
 203  8DFF              ;--------------------------------------------------------------------------------------------------------
 204  8DFF              ; Goes through each edge in to determine if they are on a visible face, if so load start and end to line array as clipped lines
 205  8DFF
 206  8DFF              ; Bank 58  ------------------------------------------------------------------------------------------------------------------------
 207  8DFF                  SLOT    LAYER1Addr
 208  8DFF                  PAGE    BankLAYER1
 209  8DFF                  ORG     LAYER1Addr, BankLAYER1
 210  E000
 211  E000                  INCLUDE "./Layer1Graphics/layer1_attr_utils.asm"
# file opened: ./Layer1Graphics/layer1_attr_utils.asm
   1+ E000
   2+ E000 00 58        L1AttrRow00:            DW $5800                    ;Row 1    */
   3+ E002 20 58        L1AttrRow01:            DW $5820                    ;Row 2    */
   4+ E004 40 58        L1AttrRow02:            DW $5840                    ;Row 3    */
   5+ E006 60 58        L1AttrRow03:            DW $5860                    ;Row 4    */
   6+ E008 80 58        L1AttrRow04:            DW $5880                    ;Row 5    */
   7+ E00A A0 58        L1AttrRow05:            DW $58A0                    ;Row 6    */
   8+ E00C C0 58        L1AttrRow06:            DW $58C0                    ;Row 7    */
   9+ E00E E0 58        L1AttrRow07:            DW $58E0                    ;Row 8    */
  10+ E010 00 59        L1AttrRow08:            DW $5900                    ;Row 9    */
  11+ E012 20 59        L1AttrRow09:            DW $5920                    ;Row 10   */
  12+ E014 40 59        L1AttrRow10:            DW $5940                    ;Row 11   */
  13+ E016 60 59        L1AttrRow11:            DW $5960                    ;Row 12   */
  14+ E018 80 59        L1AttrRow12:            DW $5980                    ;Row 13   */
  15+ E01A A0 59        L1AttrRow13:            DW $59A0                    ;Row 14   */
  16+ E01C C0 59        L1AttrRow14:            DW $59C0                    ;Row 15   */
  17+ E01E E0 59        L1AttrRow15:            DW $59E0                    ;Row 16   */
  18+ E020 00 5A        L1AttrRow16:            DW $5A00                    ;Row 17   */
  19+ E022 20 5A        L1AttrRow17:            DW $5A20                    ;Row 18   */
  20+ E024 40 5A        L1AttrRow18:            DW $5A40                    ;Row 19   */
  21+ E026 60 5A        L1AttrRow19:            DW $5A60                    ;Row 20   */
  22+ E028 80 5A        L1AttrRow20:            DW $5A80                    ;Row 21   */
  23+ E02A A0 5A        L1AttrRow21:            DW $5AA0                    ;Row 22   */
  24+ E02C C0 5A        L1AttrRow22:            DW $5AC0                    ;Row 23   */
  25+ E02E E0 5A        L1AttrRow23:            DW $5AE0                    ;Row 23   */
  26+ E030
  27+ E030              ; "l2_hilight_row, d = row, e = colour"
  28+ E030 21 00 E0     l1_hilight_row:         ld      hl, L1AttrRow00
  29+ E033 4B                                   ld      c,e
  30+ E034 7A                                   ld      a,d
  31+ E035 CB 27                                sla     a
  32+ E037 ED 31                                add     hl,a
  33+ E039 7E                                   ld      a,(hl)
  34+ E03A 5F                                   ld      e,a
  35+ E03B 23                                   inc     hl
  36+ E03C 7E                                   ld      a,(hl)
  37+ E03D 57                                   ld      d,a
  38+ E03E EB                                   ex      hl,de
  39+ E03F 79                                   ld		a,c
  40+ E040 11 20 00                             ld		de, 32
  41+ E043 CD 1D 81                             call	memfill_dma
  42+ E046 C9                                   ret
  43+ E047
# file closed: ./Layer1Graphics/layer1_attr_utils.asm
 212  E047                  INCLUDE "./Layer1Graphics/layer1_cls.asm"
# file opened: ./Layer1Graphics/layer1_cls.asm
   1+ E047 AF           l1_cls_top:             xor     a
   2+ E048 21 00 40                             ld      hl, $4000
   3+ E04B 11 00 08                             ld      de, $0800
   4+ E04E CD 1D 81                             call    memfill_dma
   5+ E051 C9                                   ret
   6+ E052
   7+ E052 AF           l1_cls_mid:             xor     a
   8+ E053 21 00 48                             ld      hl, $4800
   9+ E056 11 00 08                             ld      de, $0800
  10+ E059 CD 1D 81                             call    memfill_dma
  11+ E05C C9                                   ret
  12+ E05D
  13+ E05D AF           l1_cls_bottom:          xor     a
  14+ E05E 21 00 50                             ld      hl, $5000
  15+ E061 11 00 08                             ld      de, $0800
  16+ E064 CD 1D 81                             call    memfill_dma
  17+ E067 C9                                   ret
  18+ E068
  19+ E068              ; Designed specifically to clear a whole character aligned line
  20+ E068 1E 00        l1_cls_line_d:          ld      e,0
  21+ E06A ED 94                                pixelad
  22+ E06C 11 00 01                             ld      de,32 * 8
  23+ E06F AF                                   xor     a
  24+ E070 CD 1D 81                             call    memfill_dma
  25+ E073 C9                                   ret
  26+ E074
  27+ E074              ; Designed specifically to clear a whole character aligned 2 lines line, used for say clearing hyperspace message
  28+ E074 1E 00        l1_cls_2_lines_d:       ld      e,0
  29+ E076 ED 94                                pixelad
  30+ E078 11 00 02                             ld      de,32 * 16
  31+ E07B AF                                   xor     a
  32+ E07C CD 1D 81                             call    memfill_dma
  33+ E07F C9                                   ret
  34+ E080
  35+ E080 AF           l1_cls:                 xor		a
  36+ E081 21 00 40     l1_cls_to_a:            ld		hl,	$4000
  37+ E084 11 00 18                             ld		de, $1800
  38+ E087 CD 1D 81                             call	memfill_dma
  39+ E08A C9                                   ret
  40+ E08B
  41+ E08B 21 00 58     l1_attr_cls_2DlinesA:   ld		hl,	$5800
  42+ E08E 1E 20                                ld      e,32
  43+ E090 ED 30                                mul
  44+ E092 19                                   add     hl,de
  45+ E093 11 40 00                             ld		de, 32 * 2
  46+ E096 CD 1D 81                             call	memfill_dma
  47+ E099 C9                                   ret
  48+ E09A
  49+ E09A
  50+ E09A AF           l1_attr_cls:            xor		a
  51+ E09B 21 00 58     l1_attr_cls_to_a:       ld		hl,	$5800
  52+ E09E 11 00 03                             ld		de, $0300
  53+ E0A1 CD 1D 81                             call	memfill_dma
  54+ E0A4 C9                                   ret
  55+ E0A5
  56+ E0A5 01 FE FE     l1_set_border:          ld	    bc, 0xFEFE
  57+ E0A8 ED 79                                out		(c),a
  58+ E0AA C9                                   ret
# file closed: ./Layer1Graphics/layer1_cls.asm
 213  E0AB                  INCLUDE "./Layer1Graphics/layer1_print_at.asm"
# file opened: ./Layer1Graphics/layer1_print_at.asm
   1+ E0AB              ; "l1 print char a = character, de = Ypixel Xchar of print"
   2+ E0AB D5 E5        l1_print_char:          push	de,,hl
   3+ E0AD ED 94                                pixelad								; hl = address of de
   4+ E0AF E5                                   push	hl							; save hl for loop
   5+ E0B0 26 00                                ld		h,0
   6+ E0B2 6F                                   ld		l,a
   7+ E0B3 29                                   add		hl,hl						; * 2
   8+ E0B4 29                                   add		hl,hl						; * 4
   9+ E0B5 29                                   add		hl,hl						; * 8 to get byte address
  10+ E0B6 ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
  11+ E0BA EB                                   ex		de,hl						; save address into de
  12+ E0BB E1                                   pop		hl							; get back hl for loop
  13+ E0BC 06 08                                ld		b,8							; do 8 rows
  14+ E0BE 1A           .PrintCharLoop:         ld		a,(de)						; row byte
  15+ E0BF 13                                   inc		de							; next byte
  16+ E0C0 77                                   ld		(hl),a						; poke to screen
  17+ E0C1 ED 93                                pixeldn								; Down 1 row
  18+ E0C3 10 F9                                djnz	.PrintCharLoop				; loop for 8 bytes
  19+ E0C5 E1 D1                                pop		de,,hl					    ; restore hl
  20+ E0C7 C9                                   ret
  21+ E0C8
  22+ E0C8              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
  23+ E0C8              ; now skips ascii code < 32 but moves on cursor by 1 char
  24+ E0C8              l1_print_at:
  25+ E0C8 7E           .PrintLoop:             ld		a,(hl)
  26+ E0C9 FE 00                                cp		0
  27+ E0CB C8                                   ret		z
  28+ E0CC                                      CallIfAGTENusng " ", l1_print_char
  28+ E0CC FE 20       >                        cp      " "
  28+ E0CE D4 AB E0    >                        call	nc,l1_print_char
  29+ E0D1 23                                   inc		hl							; move 1 message character right
  30+ E0D2 7B                                   ld		a,e
  31+ E0D3 C6 08                                add		a,8
  32+ E0D5 5F                                   ld		e,a							; move 1 screen character right
  33+ E0D6 18 F0                                jr		.PrintLoop
  34+ E0D8              .Clearstackandfinish:   ;pop		de                      ; TODO LOOOKS TO BE A ROGUE POPDE
  35+ E0D8 C9                                   ret
  36+ E0D9
  37+ E0D9              ;l1_print_at_wrap:
  38+ E0D9              ;; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
  39+ E0D9              ;	ld      iyh,e
  40+ E0D9              ;.PrintLoop:
  41+ E0D9              ;	ld		a,(hl)
  42+ E0D9              ;	cp		0
  43+ E0D9              ;	ret		z
  44+ E0D9              ;.CountWordCharLen
  45+ E0D9              ;; Need to change to word wrap, so it will loop through string as before
  46+ E0D9              ;; but read up until a null or space, take the character count * 8 for pixels
  47+ E0D9              ;; if that is > 238 then force a premature line wrap
  48+ E0D9              ;
  49+ E0D9              ;
  50+ E0D9              ;    push    iy
  51+ E0D9              ;    call	l1_print_char
  52+ E0D9              ;    pop     iy
  53+ E0D9              ;	inc		hl							; move 1 message character right
  54+ E0D9              ;	ld		a,e
  55+ E0D9              ;    cp      238
  56+ E0D9              ;    jr      nc,.NextLine
  57+ E0D9              ;	add		a,8
  58+ E0D9              ;	ld		e,a							; move 1 screen character right
  59+ E0D9              ;	jr		.PrintLoop
  60+ E0D9              ;.Clearstackandfinish:
  61+ E0D9              ;	pop		de
  62+ E0D9              ;	ret
  63+ E0D9              ;.NextLine:
  64+ E0D9              ;    ld      a,(hl)
  65+ E0D9              ;    cp      " "
  66+ E0D9              ;    ld      e,iyh
  67+ E0D9              ;    ld      a,d
  68+ E0D9              ;    add     a,8
  69+ E0D9              ;    ld      d,a
  70+ E0D9              ;    jr		.PrintLoop
  71+ E0D9
  72+ E0D9              ; Counts next word at hl, uses e and forces a wrap if it would over flow puts value in c
  73+ E0D9 E5           L1LenWordAtHL:          push    hl
  74+ E0DA D5                                   push    de
  75+ E0DB 7E           .CountLoop:             ld      a,(hl)
  76+ E0DC FE 00                                cp      0
  77+ E0DE 28 0F                                jr      z,.CountDone
  78+ E0E0 FE 20                                cp      32
  79+ E0E2 28 0B                                jr      z,.CountDone
  80+ E0E4 7B                                   ld      a,e
  81+ E0E5 C6 08                                add     a,8
  82+ E0E7 5F                                   ld      e,a
  83+ E0E8 FE EE                                cp      238
  84+ E0EA 30 07                                jr      nc,.TooLong
  85+ E0EC 23                                   inc     hl
  86+ E0ED 18 EC                                jr      .CountLoop
  87+ E0EF D1           .CountDone:             pop     de
  88+ E0F0 E1                                   pop     hl
  89+ E0F1 AF                                   xor     a
  90+ E0F2 C9                                   ret
  91+ E0F3 D1           .TooLong                pop     de
  92+ E0F4 E1                                   pop     hl
  93+ E0F5 3E FF                                ld      a,$FF
  94+ E0F7 C9                                   ret
  95+ E0F8
  96+ E0F8 7E           L1PrintWordAtHL:        ld      a,(hl)
  97+ E0F9 FE 00                                cp      0
  98+ E0FB C8                                   ret     z
  99+ E0FC FE 20                                cp      32
 100+ E0FE 28 0F                                jr      z,.ItsASpace
 101+ E100 FD E5                                push    iy
 102+ E102 CD AB E0                             call	l1_print_char
 103+ E105 FD E1                                pop     iy
 104+ E107 7B                                   ld      a,e
 105+ E108 C6 08                                add     a,8
 106+ E10A 5F                                   ld      e,a
 107+ E10B 23                                   inc     hl
 108+ E10C C3 F8 E0                             jp      L1PrintWordAtHL
 109+ E10F 23           .ItsASpace:             inc     hl      ;  Just a bodge for now
 110+ E110 7B                                   ld      a,e
 111+ E111 C6 08                                add     a,8
 112+ E113 5F                                   ld      e,a
 113+ E114 C9                                   ret
 114+ E115
 115+ E115
 116+ E115              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
 117+ E115              ; Now has full word level wrapping
 118+ E115 FD 63        l1_print_at_wrap:       ld      iyh,e
 119+ E117 7E           .PrintLoop:             ld		a,(hl)
 120+ E118 FE 00                                cp		0
 121+ E11A C8                                   ret		z
 122+ E11B CD D9 E0     .CountWordCharLen:      call    L1LenWordAtHL
 123+ E11E FE FF                                cp      $FF
 124+ E120 28 06                                jr      z,.WrapNextLine
 125+ E122 CD F8 E0     .NotTooLong:            call    L1PrintWordAtHL
 126+ E125              ; Need to change to word wrap, so it will loop through string as before
 127+ E125              ; but read up until a null or space, take the character count * 8 for pixels
 128+ E125              ; if that is > 238 then force a premature line wrap
 129+ E125 18 F0                                jr		.PrintLoop
 130+ E127              .Clearstackandfinish:   ;op		de
 131+ E127 C9                                   ret
 132+ E128              .WrapNextLine:
 133+ E128 FD 5C        .NextLine:              ld      e,iyh
 134+ E12A 7A                                   ld      a,d
 135+ E12B C6 08                                add     a,8
 136+ E12D 57                                   ld      d,a
 137+ E12E 18 E7                                jr		.PrintLoop
 138+ E130
 139+ E130
# file closed: ./Layer1Graphics/layer1_print_at.asm
 214  E130
 215  E130                  SLOT    LAYER2Addr
 216  E130                  PAGE    BankLAYER2
 217  E130                  ORG     LAYER2Addr
 218  E000
 219  E000                  INCLUDE "./Layer2Graphics/layer2_bank_select.asm"
# file opened: ./Layer2Graphics/layer2_bank_select.asm
   1+ E000
   2+ E000 00           varL2_BANK_SELECTED			 DB	0
   3+ E001 00           varL2_CURRENT_BANK           DB	0
   4+ E002 00           varL2_BUFFER_MODE            DB 0
   5+ E003 00           varL2_ACCESS_MODE            DB 0
   6+ E004
   7+ E004 3E 08        asm_l2_double_buffer_on:    ld      a,8
   8+ E006 32 02 E0                                 ld      (varL2_BUFFER_MODE),a
   9+ E009 C9                                       ret
  10+ E00A
  11+ E00A AF           asm_l2_double_buffer_off:   xor     a
  12+ E00B 32 02 E0                                 ld      (varL2_BUFFER_MODE),a
  13+ E00E C9                                       ret
  14+ E00F
  15+ E00F 01 3B 12     asm_disable_l2_readwrite:   ld      bc, IO_LAYER2_PORT
  16+ E012 ED 70                                    in      (c)
  17+ E014 32 03 E0                                 ld      (varL2_ACCESS_MODE),a
  18+ E017 E6 FA                                    and     LAYER2_DISABLE_MEM_ACCESS
  19+ E019 ED 79                                    out     (c),a
  20+ E01B C9                                       ret
  21+ E01C
  22+ E01C 3A 03 E0     asm_restore_l2_readwrite:   ld      a,(varL2_ACCESS_MODE)
  23+ E01F E6 05                                    and     LAYER2_READ_WRITE_MASK
  24+ E021 57                                       ld      d,a
  25+ E022 01 3B 12                                 ld      bc, IO_LAYER2_PORT
  26+ E025 ED 70                                    in      (c)
  27+ E027 32 03 E0                                 ld      (varL2_ACCESS_MODE),a
  28+ E02A A2                                       and     d
  29+ E02B ED 79                                    out     (c),a
  30+ E02D C9                                       ret
  31+ E02E
  32+ E02E 01 3B 12     asm_enable_l2_readwrite:    ld      bc, IO_LAYER2_PORT
  33+ E031 ED 70                                    in      (c)
  34+ E033 F6 05                                    or      LAYER2_READ_WRITE_MASK
  35+ E035 ED 79                                    out     (c),a
  36+ E037 C9                                       ret
  37+ E038
  38+ E038              ; "asm_l2_bank_select"
  39+ E038              ; " a = sepecific bank mask value to select, does not set varL2_BANK_SELECTED"
  40+ E038 57           asm_l2_bank_select:         ld      d,a
  41+ E039 FE 00                                    cp      0
  42+ E03B 28 08                                    jr      z,.NotBreakDebug
  43+ E03D FE 40                                    cp      $40
  44+ E03F 28 04                                    jr      z,.NotBreakDebug
  45+ E041 FE 80                                    cp      $80
  46+ E043 28 00                                    jr      z,.NotBreakDebug
  47+ E045              .NotBreakDebug:
  48+ E045 3A 02 E0                                 ld      a,(varL2_BUFFER_MODE)
  49+ E048 F6 03                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK
  50+ E04A B2                                       or      d; | LAYER2_SHADOW_SCREEN_MASK
  51+ E04B 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
  52+ E04E ED 79                                    out 	(c),a
  53+ E050 C9                                       ret
  54+ E051              ;  "asm_l2_bank_select a = sepecific bank number to select, dsets varL2_BANK_SELECTED"
  55+ E051 32 00 E0     asm_l2_bank_n_select:       ld		(varL2_BANK_SELECTED),a
  56+ E054 FE 00                                    cp		0
  57+ E056 20 04                                    jr 		nz,.nottopbank
  58+ E058 3E 00        .topbank:                   ld		a,LAYER2_SHIFTED_SCREEN_TOP
  59+ E05A 18 DC                                    jr		asm_l2_bank_select
  60+ E05C FE 01        .nottopbank:                cp		1
  61+ E05E 20 04                                    jr 		nz,.notmiddlebank
  62+ E060 3E 40        .middlebank:                ld		a,LAYER2_SHIFTED_SCREEN_MIDDLE
  63+ E062 18 D4                                    jr		asm_l2_bank_select
  64+ E064 3E 80        .notmiddlebank:             ld		a,LAYER2_SHIFTED_SCREEN_BOTTOM ; default to bottom
  65+ E066 18 D0                                    jr		asm_l2_bank_select
  66+ E068              		; Note no ret as its handled by above routines
  67+ E068
  68+ E068              asm_l2_bank_0_macro:        MACRO
  69+ E068 ~                                        ld      a,(varL2_BUFFER_MODE)
  70+ E068 ~                                        or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
  71+ E068 ~                                        ld 		bc, IO_LAYER2_PORT
  72+ E068 ~                                        out 	(c),a
  73+ E068 ~                                      ;  ld      a,%0001000              ; Bank offset of + 1
  74+ E068 ~                                      ;  out     (c),a
  75+ E068 ~                                        ZeroA						; set a to 0
  76+ E068 ~                                        ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  77+ E068                                          ENDM
  78+ E068
  79+ E068              asm_l2_bank_1_macro:        MACRO
  80+ E068 ~                                        ld      a,(varL2_BUFFER_MODE)
  81+ E068 ~                                        or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
  82+ E068 ~                                        ld 		bc, IO_LAYER2_PORT
  83+ E068 ~                                        out 	(c),a
  84+ E068 ~                                       ; ld      a,%0001000              ; Bank offset of + 1
  85+ E068 ~                                      ;  out     (c),a
  86+ E068 ~                                        ld      a,1						; set a to 0
  87+ E068 ~                                        ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  88+ E068                                          ENDM
  89+ E068
  90+ E068              asm_l2_bank_2_macro:        MACRO
  91+ E068 ~                                        ld      a,(varL2_BUFFER_MODE)
  92+ E068 ~                                        or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
  93+ E068 ~                                        ld 		bc, IO_LAYER2_PORT
  94+ E068 ~                                        out 	(c),a
  95+ E068 ~                                      ;  ld      a,%0001000              ; Bank offset of + 1
  96+ E068 ~                                       ; out     (c),a
  97+ E068 ~                                        ld      a,2						; set a to 0
  98+ E068 ~                                        ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  99+ E068                                          ENDM
 100+ E068
 101+ E068              asm_l2_bank_3_macro:        MACRO
 102+ E068 ~                                        ld      a,(varL2_BUFFER_MODE)
 103+ E068 ~                                        or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
 104+ E068 ~                                        or      %0001011
 105+ E068 ~                                        ld 		bc, IO_LAYER2_PORT
 106+ E068 ~                                        out 	(c),a
 107+ E068 ~                                        ld      a,3						; set a to 0
 108+ E068 ~                                        ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 109+ E068                                          ENDM
 110+ E068
 111+ E068              asm_l2_bank_4_macro:        MACRO
 112+ E068 ~                                        ld      a,(varL2_BUFFER_MODE)
 113+ E068 ~                                        or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
 114+ E068 ~                                        ld 		bc, IO_LAYER2_PORT
 115+ E068 ~                                        out 	(c),a
 116+ E068 ~                                        ld      a,4						; set a to 0
 117+ E068 ~                                        ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 118+ E068                                          ENDM
 119+ E068
 120+ E068              ; "asm_l2_row_bank_select"
 121+ E068              ; "A (unsinged) = y row of pixel line from top, sets the bank to top middle or bottom and adjusts a reg to row memory address"
 122+ E068              ; "Could optimise by holding the previous bank but given its only an out statement it may not save T states at all"
 123+ E068              ; "destroys BC call de is safe a = adjusted poke pixel row"
 124+ E068              asm_l2_row_bank_select:     JumpIfAGTENusng 128, .BottomBank
 124+ E068 FE 80       >                        cp     128
 124+ E06A D2 A6 E0    >                        jp		nc,.BottomBank
 125+ E06D                                          JumpIfAGTENusng 64, .MiddleBank
 125+ E06D FE 40       >                        cp     64
 125+ E06F D2 8A E0    >                        jp		nc,.MiddleBank
 126+ E072 08                                       ex      af,af'
 127+ E073                                          JumpIfMemZero varL2_BANK_SELECTED, .NoTopChange
 127+ E073 3A 00 E0    >                        ld  a,(varL2_BANK_SELECTED)
 127+ E076 A7          >                        and a
 127+ E077 CA 88 E0    >                        jp  z,.NoTopChange
 128+ E07A                                          asm_l2_bank_0_macro
 128+ E07A 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 128+ E07D F6 03       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
 128+ E07F 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 128+ E082 ED 79       >                            out 	(c),a
 128+ E084             >                          ;  ld      a,%0001000              ; Bank offset of + 1
 128+ E084             >                          ;  out     (c),a
 128+ E084             >                            ZeroA						; set a to 0
 128+ E084 AF          >                        xor a
 128+ E085 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 129+ E088 08           .NoTopChange:               ex      af,af'
 130+ E089 C9                                       ret
 131+ E08A 08           .MiddleBank:                ex      af,af'
 132+ E08B                                          JumpIfMemEqNusng varL2_BANK_SELECTED, 1, .NoMiddleChange
 132+ E08B 3A 00 E0    >                        ld  a,(varL2_BANK_SELECTED)
 132+ E08E FE 01       >                        cp  1
 132+ E090 CA A2 E0    >                        jp  z,.NoMiddleChange
 133+ E093                                          asm_l2_bank_1_macro
 133+ E093 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 133+ E096 F6 43       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
 133+ E098 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 133+ E09B ED 79       >                            out 	(c),a
 133+ E09D             >                           ; ld      a,%0001000              ; Bank offset of + 1
 133+ E09D             >                          ;  out     (c),a
 133+ E09D 3E 01       >                            ld      a,1						; set a to 0
 133+ E09F 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 134+ E0A2 08           .NoMiddleChange:            ex      af,af'
 135+ E0A3 D6 40                                    sub     64
 136+ E0A5 C9                                       ret
 137+ E0A6 08           .BottomBank:                ex      af,af'
 138+ E0A7                                          JumpIfMemEqNusng varL2_BANK_SELECTED, 2, .NoBottomChange
 138+ E0A7 3A 00 E0    >                        ld  a,(varL2_BANK_SELECTED)
 138+ E0AA FE 02       >                        cp  2
 138+ E0AC CA BE E0    >                        jp  z,.NoBottomChange
 139+ E0AF                                          asm_l2_bank_2_macro
 139+ E0AF 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 139+ E0B2 F6 83       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 139+ E0B4 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 139+ E0B7 ED 79       >                            out 	(c),a
 139+ E0B9             >                          ;  ld      a,%0001000              ; Bank offset of + 1
 139+ E0B9             >                           ; out     (c),a
 139+ E0B9 3E 02       >                            ld      a,2						; set a to 0
 139+ E0BB 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 140+ E0BE 08           .NoBottomChange:            ex      af,af'
 141+ E0BF D6 80                                    sub     128
 142+ E0C1 C9                                       ret
 143+ E0C2
 144+ E0C2
 145+ E0C2              ; "asm_l2_row_bank_select"
 146+ E0C2              ; "HL (unsinged) = x column of pixel line from left
 147+ E0C2              ; 0-  63
 148+ E0C2              ; 64- 127
 149+ E0C2              ; 128 - 191
 150+ E0C2              ; 192 - 255
 151+ E0C2              ; 256 - 321
 152+ E0C2              ; outputs l with the correct column number
 153+ E0C2 7A           asm_l2_320_col_bank_select: ld      a,d
 154+ E0C3                                          JumpIfAIsNotZero .Bank5             ; 256 - 321
 154+ E0C3 A7          >                        and     a
 154+ E0C4 C2 27 E1    >                        jp	    nz,.Bank5
 155+ E0C7 7B                                       ld      a,e
 156+ E0C8                                          JumpIfAGTENusng 192, .Bank4
 156+ E0C8 FE C0       >                        cp     192
 156+ E0CA D2 10 E1    >                        jp		nc,.Bank4
 157+ E0CD                                          JumpIfAGTENusng 128, .Bank3
 157+ E0CD FE 80       >                        cp     128
 157+ E0CF D2 FB E0    >                        jp		nc,.Bank3
 158+ E0D2                                          JumpIfAGTENusng 64 , .Bank2
 158+ E0D2 FE 40       >                        cp     64
 158+ E0D4 D2 E6 E0    >                        jp		nc,.Bank2
 159+ E0D7              .Bank1:                     asm_l2_bank_0_macro
 159+ E0D7 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 159+ E0DA F6 03       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
 159+ E0DC 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 159+ E0DF ED 79       >                            out 	(c),a
 159+ E0E1             >                          ;  ld      a,%0001000              ; Bank offset of + 1
 159+ E0E1             >                          ;  out     (c),a
 159+ E0E1             >                            ZeroA						; set a to 0
 159+ E0E1 AF          >                        xor a
 159+ E0E2 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 160+ E0E5 C9                                       ret
 161+ E0E6              .Bank2:                     asm_l2_bank_1_macro
 161+ E0E6 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 161+ E0E9 F6 43       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
 161+ E0EB 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 161+ E0EE ED 79       >                            out 	(c),a
 161+ E0F0             >                           ; ld      a,%0001000              ; Bank offset of + 1
 161+ E0F0             >                          ;  out     (c),a
 161+ E0F0 3E 01       >                            ld      a,1						; set a to 0
 161+ E0F2 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 162+ E0F5                                          ClearCarryFlag
 162+ E0F5 B7          >                        or a
 163+ E0F6 7D                                       ld      a,l
 164+ E0F7 E6 BF                                    and     %10111111       ; fast subtract 64, just clear bit
 165+ E0F9 67                                       ld      h,a
 166+ E0FA C9                                       ret
 167+ E0FB              .Bank3:                     asm_l2_bank_2_macro
 167+ E0FB 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 167+ E0FE F6 83       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 167+ E100 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 167+ E103 ED 79       >                            out 	(c),a
 167+ E105             >                          ;  ld      a,%0001000              ; Bank offset of + 1
 167+ E105             >                           ; out     (c),a
 167+ E105 3E 02       >                            ld      a,2						; set a to 0
 167+ E107 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 168+ E10A                                          ClearCarryFlag
 168+ E10A B7          >                        or a
 169+ E10B 7D                                       ld      a,l
 170+ E10C E6 7F                                    and     %01111111       ; fast subtract 128, just clear bit
 171+ E10E 67                                       ld      h,a
 172+ E10F C9                                       ret
 173+ E110              .Bank4:                     asm_l2_bank_3_macro
 173+ E110 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 173+ E113 F6 03       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
 173+ E115 F6 0B       >                            or      %0001011
 173+ E117 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 173+ E11A ED 79       >                            out 	(c),a
 173+ E11C 3E 03       >                            ld      a,3						; set a to 0
 173+ E11E 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 174+ E121                                          ClearCarryFlag
 174+ E121 B7          >                        or a
 175+ E122 7B                                       ld      a,e
 176+ E123 E6 3F                                    and     %00111111       ; fast subtract 192, just clear bit
 177+ E125 67                                       ld      h,a
 178+ E126 C9                                       ret
 179+ E127              .Bank5:                     asm_l2_bank_4_macro
 179+ E127 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
 179+ E12A F6 43       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
 179+ E12C 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
 179+ E12F ED 79       >                            out 	(c),a
 179+ E131 3E 04       >                            ld      a,4						; set a to 0
 179+ E133 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 180+ E136 65                                       ld      h,l             ; fast subtract 256, just clear bit
 181+ E137 C9                                       ret
 182+ E138
 183+ E138              ;;;
 184+ E138              ;;;
 185+ E138              ;;;                            cp 		64			; row < 64?
 186+ E138              ;;;                            jr 		nc, .l2rowGTE64
 187+ E138              ;;;.l2rowLT64:                 ex		af,af'
 188+ E138              ;;;                            ;ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP | LAYER2_SHADOW_SCREEN_MASK
 189+ E138              ;;;                            ld      a,(varL2_BUFFER_MODE)
 190+ E138              ;;;                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
 191+ E138              ;;;                            ld 		bc, IO_LAYER2_PORT
 192+ E138              ;;;                            out 	(c),a
 193+ E138              ;;;                            xor		a						; set a to 0
 194+ E138              ;;;                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
 195+ E138              ;;;                            ex		af,af'					; return pixel poke unharmed
 196+ E138              ;;;                            ret
 197+ E138              ;;;.l2rowGTE64:                cp 		128
 198+ E138              ;;;                            jr 		nc, .l2rowGTE128
 199+ E138              ;;;.l2row64to127:              ex		af,af'
 200+ E138              ;;;                    ;		ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE | LAYER2_SHADOW_SCREEN_MASK
 201+ E138              ;;;                            ld      a,(varL2_BUFFER_MODE)
 202+ E138              ;;;                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
 203+ E138              ;;;                            ld 		bc, IO_LAYER2_PORT
 204+ E138              ;;;                            out 	(c),a
 205+ E138              ;;;                            ld		a,1						; set a to 1
 206+ E138              ;;;                            ld		(varL2_BANK_SELECTED),a	; save selected bank
 207+ E138              ;;;                            ex		af,af'
 208+ E138              ;;;                            sub		64
 209+ E138              ;;;                            ret
 210+ E138              ;;;.l2rowGTE128:               ex		af,af'
 211+ E138              ;;;                    ;		ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM | LAYER2_SHADOW_SCREEN_MASK
 212+ E138              ;;;                            ld      a,(varL2_BUFFER_MODE)
 213+ E138              ;;;                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
 214+ E138              ;;;
 215+ E138              ;;;                            ld 		bc, IO_LAYER2_PORT
 216+ E138              ;;;                            out 	(c),a
 217+ E138              ;;;                            ld		a,1						; set a to 2
 218+ E138              ;;;                            ld		(varL2_BANK_SELECTED),a	; save selected bank
 219+ E138              ;;;                            ex		af,af'
 220+ E138              ;;;                            sub		128
 221+ E138              ;;;                            ret
 222+ E138
 223+ E138
# file closed: ./Layer2Graphics/layer2_bank_select.asm
 220  E138                  INCLUDE "./Layer2Graphics/layer2_cls.asm"
# file opened: ./Layer2Graphics/layer2_cls.asm
   1+ E138
   2+ E138 00           l2_cls_byte	            DB 0
   3+ E139              ; ">DMA Command BLOCK"
   4+ E139
   5+ E139 83 C3 C7 CB  l2_fill                 DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   5+ E13D 7D
   6+ E13E 38 E1        l2_fill_astrt           DW l2_cls_byte
   7+ E140 00 40        l2_fill_length          DB $00,$40
   8+ E142 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
   9+ E145 00 00        l2_fill_bstrt           DB $00,$00
  10+ E147 82 CF B3 87                          DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
  11+ E14B              l2_fill_cmd_len	        EQU $ - l2_fill
  12+ E14B
  13+ E14B 83 C3 C7 CB  l2_fill_burst           DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
  13+ E14F 7D
  14+ E150 38 E1        .l2_fill_astrt          DW l2_cls_byte
  15+ E152 00 40        .l2_fill_length         DB $00,$40
  16+ E154 24 10 CD                             DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_BURST_MODE
  17+ E157 00 00        .l2_fill_bstrt          DB $00,$00
  18+ E159 82 CF B3 87                          DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
  19+ E15D              l2_fill_burst_cmd_len   EQU $ - l2_fill_burst
  20+ E15D
  21+ E15D              ; ">l2_cls_dma_bank sets a bank to"
  22+ E15D              l2_cls_dma_bank:
  23+ E15D 32 38 E1     .set_colour:            ld (l2_cls_byte),a
  24+ E160 21 39 E1     .write_dma:             ld hl, l2_fill
  25+ E163 06 12                                ld b, l2_fill_cmd_len
  26+ E165 0E 6B                                ld	c,IO_DATAGEAR_DMA_PORT
  27+ E167 ED B3                                otir
  28+ E169 C9                                   ret
  29+ E16A
  30+ E16A              ; ">l2_cls_dma_bank sets a bank to"
  31+ E16A              l2_cls_dma_bank_burst:
  32+ E16A 32 38 E1     .set_colour:            ld (l2_cls_byte),a
  33+ E16D 21 4B E1     .write_dma:             ld hl, l2_fill_burst
  34+ E170 06 12                                ld b, l2_fill_burst_cmd_len
  35+ E172 0E 6B                                ld	c,IO_DATAGEAR_DMA_PORT
  36+ E174 ED B3                                otir
  37+ E176 C9                                   ret
  38+ E177
  39+ E177 3E 00        l2_set_color_upper2:    ld      a,0
  40+ E179 CD 68 E0                             call asm_l2_row_bank_select
  41+ E17C 3A 38 E1                             ld      a,(l2_cls_byte)
  42+ E17F CD 5D E1                             call l2_cls_dma_bank
  43+ E182 3E 40                                ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
  44+ E184 CD 68 E0                             call asm_l2_row_bank_select
  45+ E187 3A 38 E1                             ld      a,(l2_cls_byte)
  46+ E18A CD 5D E1                             call l2_cls_dma_bank
  47+ E18D C9                                   ret
  48+ E18E
  49+ E18E
  50+ E18E              l2_cls_upper_two_thirds:;ld a,0								; pretend we are plotting pixel on row 0 to force top selection
  51+ E18E                                      asm_l2_bank_0_macro ; call asm_l2_row_bank_select
  51+ E18E 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  51+ E191 F6 03       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
  51+ E193 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  51+ E196 ED 79       >                            out 	(c),a
  51+ E198             >                          ;  ld      a,%0001000              ; Bank offset of + 1
  51+ E198             >                          ;  out     (c),a
  51+ E198             >                            ZeroA						; set a to 0
  51+ E198 AF          >                        xor a
  51+ E199 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  52+ E19C 3E E3                                ld 	a,COLOUR_TRANSPARENT
  53+ E19E CD 5D E1                             call l2_cls_dma_bank
  54+ E1A1                                      ;ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
  55+ E1A1                                      asm_l2_bank_1_macro ;call asm_l2_row_bank_select
  55+ E1A1 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  55+ E1A4 F6 43       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
  55+ E1A6 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  55+ E1A9 ED 79       >                            out 	(c),a
  55+ E1AB             >                           ; ld      a,%0001000              ; Bank offset of + 1
  55+ E1AB             >                          ;  out     (c),a
  55+ E1AB 3E 01       >                            ld      a,1						; set a to 0
  55+ E1AD 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  56+ E1B0 3E E3                                ld 	a,COLOUR_TRANSPARENT
  57+ E1B2 CD 5D E1                             call l2_cls_dma_bank
  58+ E1B5 C9                                   ret
  59+ E1B6
  60+ E1B6              l2_cls_upper_two_thirds_burst:;ld a,0								; pretend we are plotting pixel on row 0 to force top selection
  61+ E1B6                                      asm_l2_bank_0_macro ; call asm_l2_row_bank_select
  61+ E1B6 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  61+ E1B9 F6 03       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
  61+ E1BB 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  61+ E1BE ED 79       >                            out 	(c),a
  61+ E1C0             >                          ;  ld      a,%0001000              ; Bank offset of + 1
  61+ E1C0             >                          ;  out     (c),a
  61+ E1C0             >                            ZeroA						; set a to 0
  61+ E1C0 AF          >                        xor a
  61+ E1C1 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  62+ E1C4 3E E3                                ld 	a,COLOUR_TRANSPARENT
  63+ E1C6 CD 6A E1                             call l2_cls_dma_bank_burst
  64+ E1C9                                      ;ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
  65+ E1C9                                      asm_l2_bank_1_macro ;call asm_l2_row_bank_select
  65+ E1C9 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  65+ E1CC F6 43       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
  65+ E1CE 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  65+ E1D1 ED 79       >                            out 	(c),a
  65+ E1D3             >                           ; ld      a,%0001000              ; Bank offset of + 1
  65+ E1D3             >                          ;  out     (c),a
  65+ E1D3 3E 01       >                            ld      a,1						; set a to 0
  65+ E1D5 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  66+ E1D8 3E E3                                ld 	a,COLOUR_TRANSPARENT
  67+ E1DA CD 6A E1                             call l2_cls_dma_bank_burst
  68+ E1DD C9                                   ret
  69+ E1DE
  70+ E1DE              l2_cls_lower_third:     ;ld a,128							; pretend we are plotting pixel on row 64 to force mid selection
  71+ E1DE                                      asm_l2_bank_2_macro; call asm_l2_row_bank_select
  71+ E1DE 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  71+ E1E1 F6 83       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
  71+ E1E3 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  71+ E1E6 ED 79       >                            out 	(c),a
  71+ E1E8             >                          ;  ld      a,%0001000              ; Bank offset of + 1
  71+ E1E8             >                           ; out     (c),a
  71+ E1E8 3E 02       >                            ld      a,2						; set a to 0
  71+ E1EA 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  72+ E1ED 3E E3                                ld 	a,COLOUR_TRANSPARENT
  73+ E1EF CD 5D E1                             call l2_cls_dma_bank
  74+ E1F2 C9                                   ret
  75+ E1F3
  76+ E1F3              l2_cls_lower_third_burst:asm_l2_bank_2_macro; call asm_l2_row_bank_select
  76+ E1F3 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  76+ E1F6 F6 83       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
  76+ E1F8 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  76+ E1FB ED 79       >                            out 	(c),a
  76+ E1FD             >                          ;  ld      a,%0001000              ; Bank offset of + 1
  76+ E1FD             >                           ; out     (c),a
  76+ E1FD 3E 02       >                            ld      a,2						; set a to 0
  76+ E1FF 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  77+ E202 3E E3                                ld 	a,COLOUR_TRANSPARENT
  78+ E204 CD 6A E1                             call l2_cls_dma_bank_burst
  79+ E207 C9                                   ret
  80+ E208
  81+ E208
  82+ E208 CD B6 E1     l2_cls_burst:           call l2_cls_upper_two_thirds_burst
  83+ E20B C3 F3 E1                             jp   l2_cls_lower_third_burst
  84+ E20E
  85+ E20E
  86+ E20E CD 8E E1     l2_cls:                 call l2_cls_upper_two_thirds
  87+ E211 C3 DE E1                             jp   l2_cls_lower_third
  88+ E214
  89+ E214              l2_320_cls:
  90+ E214 CD 8E E1     l2_640_cls:             call l2_cls_upper_two_thirds
  91+ E217 CD DE E1                             call   l2_cls_lower_third
  92+ E21A                                      ; need to clear banks 4 and 5 via normal paging, say into C000 with interrupts disabled
  93+ E21A                                      asm_l2_bank_3_macro
  93+ E21A 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  93+ E21D F6 03       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
  93+ E21F F6 0B       >                            or      %0001011
  93+ E221 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  93+ E224 ED 79       >                            out 	(c),a
  93+ E226 3E 03       >                            ld      a,3						; set a to 0
  93+ E228 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  94+ E22B 3E E3                                ld 	a,COLOUR_TRANSPARENT
  95+ E22D CD 5D E1                             call l2_cls_dma_bank
  96+ E230                                      asm_l2_bank_4_macro
  96+ E230 3A 02 E0    >                            ld      a,(varL2_BUFFER_MODE)
  96+ E233 F6 43       >                            or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
  96+ E235 01 3B 12    >                            ld 		bc, IO_LAYER2_PORT
  96+ E238 ED 79       >                            out 	(c),a
  96+ E23A 3E 04       >                            ld      a,4						; set a to 0
  96+ E23C 32 00 E0    >                            ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  97+ E23F 3E E3                                ld 	a,COLOUR_TRANSPARENT
  98+ E241 CD 5D E1                             call l2_cls_dma_bank
  99+ E244
 100+ E244 C9                                   ret
 101+ E245
# file closed: ./Layer2Graphics/layer2_cls.asm
 221  E245                  INCLUDE "./Layer2Graphics/layer2_initialise.asm"
# file opened: ./Layer2Graphics/layer2_initialise.asm
   1+ E245
   2+ E245 ED 91 70 00  l2_initialise:          nextreg     LAYER_2_CONTROL_REGISTER,           %00000000               ; 256x192x8bpp
   3+ E249 ED 91 12 08                          nextreg		LAYER2_RAM_PAGE_REGISTER,          	LAYER2_SCREEN_BANK1
   4+ E24D ED 91 13 0D                          nextreg		LAYER2_RAM_SHADOW_REGISTER,     	LAYER2_SHADOW_BANK1
   5+ E251 ED 91 14 E3                          nextreg		TRANSPARENCY_COLOUR_REGISTER, 		COLOUR_TRANSPARENT
   6+ E255                                      ZeroA
   6+ E255 AF          >                        xor a
   7+ E256                                      DoubleBufferIfPossible
   7+ E256             >                        IFDEF DOUBLEBUFFER
   7+ E256 ~           >                            MMUSelectLayer2
   7+ E256 ~           >                            call  l2_cls
   7+ E256 ~           >                            call  l2_flip_buffers
   7+ E256             >                        ENDIF
   8+ E256                                      DoubleBufferIfPossible
   8+ E256             >                        IFDEF DOUBLEBUFFER
   8+ E256 ~           >                            MMUSelectLayer2
   8+ E256 ~           >                            call  l2_cls
   8+ E256 ~           >                            call  l2_flip_buffers
   8+ E256             >                        ENDIF
   9+ E256 CD 68 E0                             call        asm_l2_row_bank_select
  10+ E259 C9                                   ret
  11+ E25A
  12+ E25A ED 91 70 10  l2_320_initialise:      nextreg     LAYER_2_CONTROL_REGISTER,           %00010000               ; 320x256x8bpp
  13+ E25E ED 91 12 08                          nextreg		LAYER2_RAM_PAGE_REGISTER,          	LAYER2_SCREEN_BANK1
  14+ E262 ED 91 13 0D                          nextreg		LAYER2_RAM_SHADOW_REGISTER,     	LAYER2_SHADOW_BANK1
  15+ E266 ED 91 14 E3                          nextreg		TRANSPARENCY_COLOUR_REGISTER, 		COLOUR_TRANSPARENT
  16+ E26A                                      ZeroA
  16+ E26A AF          >                        xor a
  17+ E26B                                      DoubleBuffer320IfPossible
  17+ E26B             >                        IFDEF DOUBLEBUFFER
  17+ E26B ~           >                            MMUSelectLayer2
  17+ E26B ~           >                            call  l2_320_cls
  17+ E26B ~           >                            call  l2_flip_buffers
  17+ E26B             >                        ENDIF
  18+ E26B                                      DoubleBuffer320IfPossible
  18+ E26B             >                        IFDEF DOUBLEBUFFER
  18+ E26B ~           >                            MMUSelectLayer2
  18+ E26B ~           >                            call  l2_320_cls
  18+ E26B ~           >                            call  l2_flip_buffers
  18+ E26B             >                        ENDIF
  19+ E26B CD C2 E0                             call        asm_l2_320_col_bank_select
  20+ E26E C9                                   ret
  21+ E26F
  22+ E26F              ;l2_640_initialise:      nextreg     LAYER_2_CONTROL_REGISTER,           %00100000               ; 320x256x8bpp
  23+ E26F              ;                        nextreg		LAYER2_RAM_PAGE_REGISTER,          	LAYER2_SCREEN_BANK1
  24+ E26F              ;                        nextreg		LAYER2_RAM_SHADOW_REGISTER,     	LAYER2_SHADOW_BANK1
  25+ E26F              ;                        nextreg		TRANSPARENCY_COLOUR_REGISTER, 		COLOUR_TRANSPARENT
  26+ E26F              ;                        ZeroA
  27+ E26F              ;                        DoubleBuffer640IfPossible
  28+ E26F              ;                        DoubleBuffer640IfPossible
  29+ E26F              ;                        call        asm_l2_640_col_bank_select
  30+ E26F              ;                        ret
  31+ E26F
# file closed: ./Layer2Graphics/layer2_initialise.asm
 222  E26F                  INCLUDE "./Layer2Graphics/l2_flip_buffers.asm"
# file opened: ./Layer2Graphics/l2_flip_buffers.asm
   1+ E26F              l2_flip_buffers:        GetNextReg LAYER2_RAM_PAGE_REGISTER
   1+ E26F 01 3B 24    >            ld bc,$243B
   1+ E272 3E 12       >            ld a,LAYER2_RAM_PAGE_REGISTER
   1+ E274 ED 79       >            out (c),a
   1+ E276 04          >            inc b
   1+ E277 ED 78       >            in a,(c)
   2+ E279 57                                   ld      d,a
   3+ E27A                                      GetNextReg LAYER2_RAM_SHADOW_REGISTER
   3+ E27A 01 3B 24    >            ld bc,$243B
   3+ E27D 3E 13       >            ld a,LAYER2_RAM_SHADOW_REGISTER
   3+ E27F ED 79       >            out (c),a
   3+ E281 04          >            inc b
   3+ E282 ED 78       >            in a,(c)
   4+ E284 5F                                   ld      e,a
   5+ E285 ED 92 12                             nextreg LAYER2_RAM_PAGE_REGISTER, a
   6+ E288 7A                                   ld      a,d
   7+ E289 ED 92 13                             nextreg LAYER2_RAM_SHADOW_REGISTER, a
   8+ E28C C9                                   ret
   9+ E28D
# file closed: ./Layer2Graphics/l2_flip_buffers.asm
 223  E28D                  INCLUDE "./Layer2Graphics/layer2_plot_pixel.asm"
# file opened: ./Layer2Graphics/layer2_plot_pixel.asm
   1+ E28D              l2_plot_macro:          MACRO
   2+ E28D ~                                    ld      a,b
   3+ E28D ~                                    JumpIfAGTENusng 192 ,.NoPlot
   4+ E28D ~                                    ld      l,c
   5+ E28D ~                                    call    asm_l2_row_bank_select
   6+ E28D ~                                    ld      h,a
   7+ E28D ~                                    ld      a,(line_gfx_colour)
   8+ E28D ~                                    ld      (hl),a
   9+ E28D ~            .NoPlot:
  10+ E28D                                      ENDM
  11+ E28D
  12+ E28D
  13+ E28D              ; ">l2_plot_pixel b= row number, c = column number, a = pixel col"
  14+ E28D F5           l2_plot_pixel:          push    af
  15+ E28E 78                                   ld      a,b
  16+ E28F              l2_pp_row_valid:        JumpIfAGTENusng ScreenHeight,l2_pp_dont_plot
  16+ E28F FE C0       >                        cp     ScreenHeight
  16+ E291 D2 9F E2    >                        jp		nc,l2_pp_dont_plot
  17+ E294 C5                                   push    bc								; bank select destroys bc so need to save it
  18+ E295                                  ;	ld      a,b
  19+ E295 CD 68 E0                             call    asm_l2_row_bank_select
  20+ E298 C1                                   pop     bc
  21+ E299 47                                   ld      b,a
  22+ E29A 60                                   ld      h,b								; hl now holds ram address after bank select
  23+ E29B 69                                   ld      l,c
  24+ E29C F1                                   pop     af								; a = colour to plott
  25+ E29D 77                                   ld      (hl),a
  26+ E29E C9                                   ret
  27+ E29F F1           l2_pp_dont_plot:        pop     af
  28+ E2A0 C9                                   ret
  29+ E2A1
  30+ E2A1              ; ">l2_plot_pixel d= row number, hl = column number, e = pixel col"
  31+ E2A1 7C           l2_plot_pixel_320:      ld      a,h
  32+ E2A2 FE 01                                cp      1                               ; if < 256, definite OK
  33+ E2A4 20 05                                jr      nz,.DoneCheck
  34+ E2A6 7D                                   ld      a,l
  35+ E2A7 E6 C0                                and     %11000000                       ; if its 7 or 6 set then > 319
  36+ E2A9 20 06                                jr      nz,.DontPlot
  37+ E2AB CD C2 E0     .DoneCheck:             call    asm_l2_320_col_bank_select      ; adjust hl for column > h
  38+ E2AE 6A                                   ld      l,d                             ; as they are horizontal now
  39+ E2AF 7B                                   ld      a,e
  40+ E2B0 77                                   ld      (hl),a
  41+ E2B1 C9           .DontPlot:              ret
  42+ E2B2
  43+ E2B2 CD C2 E0     l2_plot_pixel_320_no_check:   call    asm_l2_320_col_bank_select      ; adjust hl for column > h
  44+ E2B5 6A                                   ld      l,d                             ; as they are horizontal now
  45+ E2B6 7B                                   ld      a,e
  46+ E2B7 77                                   ld      (hl),a
  47+ E2B8 C9                                   ret
  48+ E2B9
  49+ E2B9              ; y aixs bounds check must have been done before calling this
  50+ E2B9 F5           l2_plot_pixel_no_check: push    af
  51+ E2BA C5                                   push    bc								; bank select destroys bc so need to save it
  52+ E2BB 78                                   ld      a,b                             ; determine target bank
  53+ E2BC CD 68 E0                             call    asm_l2_row_bank_select
  54+ E2BF C1                                   pop     bc
  55+ E2C0 47                                   ld      b,a                             ; b now adjusted for bank, c = column
  56+ E2C1 60 69                                ld      hl,bc                           ; hl now holds ram address after bank select
  57+ E2C3 F1                                   pop     af								; a = colour to plott
  58+ E2C4 77                                   ld      (hl),a                          ; poke to ram
  59+ E2C5 C9                                   ret
  60+ E2C6
  61+ E2C6              ; ">l2_plot_pixel_no_bank b= row number, c = column number, a = pixel col"
  62+ E2C6              ; This version assues pixel is in the same bank as previously plotted ones. optimised for horizontal lines
  63+ E2C6 E5           l2_plot_pixel_no_bank:  push 	hl
  64+ E2C7 60                                   ld 		h,b								; hl now holds ram address after bank select
  65+ E2C8 69                                   ld 		l,c
  66+ E2C9 77                                   ld 		(hl),a
  67+ E2CA E1                                   pop		hl
  68+ E2CB C9                                   ret
  69+ E2CC
  70+ E2CC              ; ">l2_plot_pixel_no_bank d= row number, h = column number, a = pixel col"
  71+ E2CC              ; This version assues pixel is in the same bank as previously plotted ones. optimised for horizontal lines
  72+ E2CC              l2_plot_pixel_320_no_bank:
  73+ E2CC 6A                                   ld 		l,d
  74+ E2CD 77                                   ld 		(hl),a
  75+ E2CE C9                                   ret
  76+ E2CF              ; The more simpler h col l row is just ld (hl),a so no need for a function
  77+ E2CF
  78+ E2CF
  79+ E2CF F5           ShipPixel:              push    af
  80+ E2D0 78                                   ld      a,b
  81+ E2D1 FE 7F                                cp      127
  82+ E2D3 D0                                   ret     nc
  83+ E2D4 F1                                   pop     af
  84+ E2D5 18 E2                                jr      l2_plot_pixel_no_check
  85+ E2D7                                      ;***Implicit ret due to jr
  86+ E2D7
  87+ E2D7              ; in bc = yx iyl = colour
  88+ E2D7 78           DebrisPixel:            ld      a,b
  89+ E2D8 FE 7F                                cp      127
  90+ E2DA D0                                   ret     nc
  91+ E2DB FD 7D                                ld      a, iyl
  92+ E2DD 18 DA                                jr      l2_plot_pixel_no_check
  93+ E2DF                                      ;***Implicit ret due to jr
  94+ E2DF
  95+ E2DF F5           l2_plot_pixel_y_test:   push	af
  96+ E2E0 78                                   ld		a,b
  97+ E2E1 FE C0                                cp		192
  98+ E2E3 30 03                                jr		nc,.clearup
  99+ E2E5 F1                                   pop		af
 100+ E2E6 18 A5                                jr		l2_plot_pixel
 101+ E2E8 F1           .clearup:               pop		af
 102+ E2E9 C9                                   ret
 103+ E2EA
 104+ E2EA              l2_point_pixel_y_safe:	MACRO
 105+ E2EA ~            						push	hl
 106+ E2EA ~            						push	bc
 107+ E2EA ~            						call	l2_plot_pixel
 108+ E2EA ~            						pop		bc
 109+ E2EA ~            						pop		hl
 110+ E2EA              						ENDM
 111+ E2EA
# file closed: ./Layer2Graphics/layer2_plot_pixel.asm
 224  E2EA                  INCLUDE "./Layer2Graphics/layer2_print_character.asm"
# file opened: ./Layer2Graphics/layer2_print_character.asm
   1+ E2EA
   2+ E2EA              l2_print_chr_at:
   3+ E2EA              ; "l2_print_chr_at, bc = col,row, d= character, e = colour"
   4+ E2EA              ; "Need a version that also prints absence of character"
   5+ E2EA 7A           	ld		a,d
   6+ E2EB FE 20        	cp		32
   7+ E2ED 38 3F        	jr		c,.InvalidCharacter		; Must be between 32 and 127
   8+ E2EF FE 7F        	cp		127
   9+ E2F1 30 3B        	jr		nc,.InvalidCharacter
  10+ E2F3              .ValidCharater:
  11+ E2F3 26 00        	ld		h,0
  12+ E2F5 6A           	ld		l,d
  13+ E2F6 29           	add		hl,hl						; * 2
  14+ E2F7 29           	add		hl,hl						; * 4
  15+ E2F8 29           	add		hl,hl						; * 8 to get byte address
  16+ E2F9 ED 34 00 3C  	add		hl,charactersetaddr			; hl = address of rom char
  17+ E2FD 04           	inc		b							; start + 1 pixel x and y as we only print 7x7
  18+ E2FE 23           	inc		hl							; skip first byte
  19+ E2FF 16 07        	ld		d,7
  20+ E301              .PrintCharLoop:
  21+ E301 D5           	push	de
  22+ E302 7E           	ld		a,(hl)
  23+ E303 FE 00        	cp		0
  24+ E305 28 21        	jr		z,.NextRowNoBCPop
  25+ E307              .PrintARow:
  26+ E307 C5           	push	bc							; save row col
  27+ E308 16 07        	ld		d,7							; d is loop row number now
  28+ E30A              .PrintPixelLoop:
  29+ E30A 0C           	inc		c							; we start at col 1 not 0 so can move inc here
  30+ E30B              .PrintTheRow:
  31+ E30B CB 27        	sla		a							; scroll char 1 pixel as we read from bit 7
  32+ E30D F5           	push	af							; save character byte
  33+ E30E CB 7F        	bit		7,a							; If left most pixel set then plot
  34+ E310 20 04        	jr		nz,.PixelToPrint
  35+ E312              .NoPixelToPrint:
  36+ E312 3E E3        	ld		a,$E3
  37+ E314 18 01        	jr		.HaveSetPixelColour
  38+ E316              .PixelToPrint:
  39+ E316 7B           	ld		a,e							; Get Colour
  40+ E317              .HaveSetPixelColour
  41+ E317 E5           	push	hl
  42+ E318              ;	push	bc							; at the moment we don't do paging on first plot so need to preserve BC
  43+ E318              .BankOnFirstOnly:
  44+ E318 F5           	push	af
  45+ E319 7A           	ld		a,d
  46+ E31A FE 07        	cp		7
  47+ E31C 28 11        	jr		z,.PlotWithBank
  48+ E31E              .PlotNoBank:
  49+ E31E F1           	pop		af
  50+ E31F 60           	ld 		h,b								; hl now holds ram address after bank select
  51+ E320 69           	ld 		l,c
  52+ E321 77           	ld 		(hl),a
  53+ E322              .IterateLoop:
  54+ E322              ;	pop		bc
  55+ E322 E1           	pop		hl
  56+ E323 F1           	pop		af							; a= current byte shifted
  57+ E324 15           	dec		d						 	; do dec after inc as we amy
  58+ E325 20 E3        	jr		nz,.PrintPixelLoop
  59+ E327              .NextRow:
  60+ E327 C1           	pop		bc							; Current Col Row
  61+ E328              .NextRowNoBCPop:
  62+ E328 D1           	pop		de							; d= row loop
  63+ E329 04           	inc		b							; Down 1 row
  64+ E32A 23           	inc		hl							; Next character byte
  65+ E32B 15           	dec		d							; 1 done now
  66+ E32C 20 D3        	jr		nz,.PrintCharLoop
  67+ E32E              .InvalidCharacter:
  68+ E32E C9           	ret
  69+ E32F              .PlotWithBank:
  70+ E32F F1           	pop		af
  71+ E330 CD 8D E2     	call	l2_plot_pixel				; This will shift bc to poke row
  72+ E333 18 ED        	jr		.IterateLoop
  73+ E335
  74+ E335              l2_print_at:
  75+ E335              ; "l2_print_at bc= colrow, hl = addr of message, e = colour"
  76+ E335              ; "No error trapping, if there is no null is will just cycle on the line"
  77+ E335 7E           	ld	a,(hl)							; Return if empty string
  78+ E336 FE 00        	cp	0
  79+ E338 C8           	ret	z
  80+ E339 E5           	push	hl
  81+ E33A D5           	push	de
  82+ E33B C5           	push	bc
  83+ E33C 57           	ld		d,a							; bc = pos, de = char and colour
  84+ E33D CD EA E2     	call 	l2_print_chr_at
  85+ E340 C1           	pop		bc
  86+ E341 D1           	pop		de
  87+ E342 E1           	pop		hl
  88+ E343              .Move8Pixlestoright:
  89+ E343 08           	ex		af,af'
  90+ E344 79           	ld		a,c
  91+ E345 C6 08        	add		8
  92+ E347 4F           	ld		c,a
  93+ E348 08           	ex		af,af'
  94+ E349 23           	inc		hl
  95+ E34A 18 E9        	jr		l2_print_at					; Just loop until 0 found
  96+ E34C
  97+ E34C
  98+ E34C              ; "l2_print_chr_at, bc = col,row, d= character, e = colour"
  99+ E34C              ; "Need a version that also prints absence of character"
 100+ E34C              ; removed blank line optimisation as we need spaces printed
 101+ E34C 7A           l2_print_7chr_at:       ld		a,d
 102+ E34D FE 1F                                cp		31
 103+ E34F 38 3D                                jr		c,.InvalidCharacter		; Must be between 32 and 127
 104+ E351 FE 7F                                cp		127
 105+ E353 30 39                                jr		nc,.InvalidCharacter
 106+ E355 26 00        .ValidCharater:         ld		h,0
 107+ E357 6A                                   ld		l,d
 108+ E358 29                                   add		hl,hl						; * 2
 109+ E359 29                                   add		hl,hl						; * 4
 110+ E35A 29                                   add		hl,hl						; * 8 to get byte address
 111+ E35B ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
 112+ E35F 04                                   inc		b							; start + 1 pixel x and y as we only print 7x7
 113+ E360 23                                   inc		hl							; skip first byte
 114+ E361 16 07                                ld		d,7
 115+ E363 D5           .PrintCharLoop:         push	de
 116+ E364 7E                                   ld		a,(hl)
 117+ E365                                      ;cp		0
 118+ E365                                      ;jr		z,.NextRowNoBCPop
 119+ E365 C5           .PrintARow:             push	bc							; save row col
 120+ E366 16 06                                ld		d,6							; d is loop row number now
 121+ E368 0C           .PrintPixelLoop:        inc		c							; we start at col 1 not 0 so can move inc here
 122+ E369 28 1C                                jr		z,.NextRow
 123+ E36B CB 27                                sla		a							; scroll char 1 pixel as we read from bit 7
 124+ E36D F5                                   push	af							; save character byte
 125+ E36E CB 7F                                bit		7,a							; If left most pixel set then plot
 126+ E370 20 04                                jr		nz,.PixelToPrint
 127+ E372 3E E3        .NoPixelToPrint:        ld		a,$E3
 128+ E374 18 01                                jr		.HaveSetPixelColour
 129+ E376 7B           .PixelToPrint:          ld		a,e							; Get Colour
 130+ E377 E5           .HaveSetPixelColour		push	hl
 131+ E378                                      ;	push	bc							; at the moment we don't do paging on first plot so need to preserve BC
 132+ E378 F5           .BankOnFirstOnly:       push	af
 133+ E379 7A                                   ld		a,d
 134+ E37A FE 06                                cp		6
 135+ E37C 28 11                                jr		z,.PlotWithBank
 136+ E37E F1           .PlotNoBank:            pop		af
 137+ E37F 60                                   ld 		h,b								; hl now holds ram address after bank select
 138+ E380 69                                   ld 		l,c
 139+ E381 77                                   ld 		(hl),a
 140+ E382              .IterateLoop:	        ;	pop		bc
 141+ E382 E1                                   pop		hl
 142+ E383 F1                                   pop		af							; a= current byte shifted
 143+ E384 15                                   dec		d						 	; do dec after inc as we amy
 144+ E385 20 E1                                jr		nz,.PrintPixelLoop
 145+ E387 C1           .NextRow:               pop		bc							; Current Col Row
 146+ E388 D1           .NextRowNoBCPop:	    pop		de							; d= row loop
 147+ E389 04                                   inc		b							; Down 1 row
 148+ E38A 23                                   inc		hl							; Next character byte
 149+ E38B 15                                   dec		d							; 1 done now
 150+ E38C 20 D5                                jr		nz,.PrintCharLoop
 151+ E38E C9           .InvalidCharacter:      ret
 152+ E38F F1           .PlotWithBank:          pop		af
 153+ E390 CD 8D E2                             call	l2_plot_pixel				; This will shift bc to poke row
 154+ E393 18 ED                                jr		.IterateLoop
 155+ E395
 156+ E395              ; "l2_print_7at bc= colrow, hl = addr of message, e = colour"
 157+ E395              ; "No error trapping, if there is no null is will just cycle on the line"
 158+ E395 7E           l2_print_7at:           ld	a,(hl)							; Return if empty string
 159+ E396 FE 00                                cp	0
 160+ E398 C8                                   ret	z
 161+ E399 E5                                   push	hl
 162+ E39A D5                                   push	de
 163+ E39B C5                                   push	bc
 164+ E39C 57                                   ld		d,a							; bc = pos, de = char and colour
 165+ E39D CD 4C E3                             call 	l2_print_7chr_at
 166+ E3A0 C1                                   pop		bc
 167+ E3A1 D1                                   pop		de
 168+ E3A2 E1                                   pop		hl
 169+ E3A3 08           .Move7Pixlestoright:	ex		af,af'
 170+ E3A4 79                                   ld		a,c
 171+ E3A5 C6 07                                add		7
 172+ E3A7 4F                                   ld		c,a
 173+ E3A8 08                                   ex		af,af'
 174+ E3A9 23                                   inc		hl
 175+ E3AA 18 E9                                jr		l2_print_7at					; Just loop until 0 found
 176+ E3AC
 177+ E3AC
 178+ E3AC              ; "l2_print_7at b= row, hl = col de = addr of message, c = colour"
 179+ E3AC              ; "No error trapping, if there is no null is will just cycle on the line"
 180+ E3AC
 181+ E3AC 1A           l2_print_7at_320:       ld	a,(de)							; Return if empty string
 182+ E3AD FE 00                                cp	0
 183+ E3AF C8                                   ret	z
 184+ E3B0 E5 D5 C5                             push	hl,,de,,bc
 185+ E3B3 57                                   ld		d,a							; bc = pos, de = char and colour
 186+ E3B4                                      ;TODOcallcall 	l2_print_7chr_at_320
 187+ E3B4 C1 D1 E1                             pop		hl,,de,,bc
 188+ E3B7 08           .Move7Pixlestoright:	ex		af,af'
 189+ E3B8 79                                   ld		a,c
 190+ E3B9 C6 07                                add		7
 191+ E3BB 4F                                   ld		c,a
 192+ E3BC 08                                   ex		af,af'
 193+ E3BD 23                                   inc		hl
 194+ E3BE 18 EC                                jr		l2_print_7at_320		    ; Just loop until 0 found
 195+ E3C0
 196+ E3C0
# file closed: ./Layer2Graphics/layer2_print_character.asm
 225  E3C0                  INCLUDE "./Layer2Graphics/layer2_draw_box.asm"
# file opened: ./Layer2Graphics/layer2_draw_box.asm
   1+ E3C0              ; "l2_draw_thick_box bc=rowcol, de=heightwidth h=color"
   2+ E3C0              ; TODO DMA Optimise
   3+ E3C0 C5 D5 E5     l2_draw_fill_box:       push    bc,,de,,hl
   4+ E3C3 53                                   ld      d,e
   5+ E3C4 5C                                   ld      e,h
   6+ E3C5 CD 5B E4                             call    l2_draw_horz_line           ; "bc = left side row,col, d = length, e = color"
   7+ E3C8 E1 D1 C1                             pop     bc,,de,,hl
   8+ E3CB 04                                   inc     b
   9+ E3CC 15                                   dec     d
  10+ E3CD C8                                   ret     z
  11+ E3CE 18 F0                                jr      l2_draw_fill_box
  12+ E3D0
  13+ E3D0              ; "l2_draw_box bc=rowcol, de=heightwidth a=color"
  14+ E3D0 C5 D5 F5     l2_draw_box:            push	bc,,de,,af
  15+ E3D3 53                                   ld		d,e
  16+ E3D4 5F                                   ld		e,a
  17+ E3D5 14                                   inc		d
  18+ E3D6 CD 5B E4                             call	l2_draw_horz_line
  19+ E3D9 F1 D1 C1                             pop		bc,,de,,af
  20+ E3DC C5 D5 F5     .bottomhorzline:	    push	bc,,de,,af
  21+ E3DF 67                                   ld		h,a							;save color whilst b = row + height
  22+ E3E0 78                                   ld		a,b
  23+ E3E1 82                                   add		a,d
  24+ E3E2 47                                   ld		b,a
  25+ E3E3 53                                   ld		d,e							; d = width
  26+ E3E4 14                                   inc		d							; Extra pixel for width
  27+ E3E5 5C                                   ld		e,h							; e = colour
  28+ E3E6 CD 5B E4                             call	l2_draw_horz_line
  29+ E3E9 F1 D1 C1                             pop		bc,,de,,af
  30+ E3EC C5 D5 F5     .leftvertline:          push	bc,,de,,af
  31+ E3EF 04                                   inc		b							; save 2 pixles
  32+ E3F0 15                                   dec		d
  33+ E3F1 5F                                   ld		e,a							; e = color
  34+ E3F2 CD C6 E4                             call	l2_draw_vert_line
  35+ E3F5 F1 D1 C1                             pop		bc,,de,,af
  36+ E3F8 04           .rightvertline:         inc		b							; save 2 pixles
  37+ E3F9 15                                   dec		d
  38+ E3FA 67                                   ld		h,a							;save color whilst c = col + width
  39+ E3FB 79                                   ld		a,c
  40+ E3FC 83                                   add		a,e
  41+ E3FD 4F                                   ld		c,a
  42+ E3FE 5C                                   ld		e,h							; e = color
  43+ E3FF CD C6 E4                             call	l2_draw_vert_line
  44+ E402 C9                                   ret
  45+ E403
  46+ E403              ; "b = row, hl = col, c = height, de = width, a = colour"
  47+ E403 C5 D5 E5 F5  l2_draw_box_320:        push    bc,,de,,hl,,af
  48+ E407                                      ;TODOcall    l2_draw_horz_line_320       ; b = row, hl = col, e = width a = colour
  49+ E407 F1 E1 D1 C1                          pop     bc,,de,,hl,,af
  50+ E40B C5 D5 E5 F5                          push    bc,,de,,hl,,af
  51+ E40F 08                                   ex      af,af'
  52+ E410 78                                   ld      a,b
  53+ E411 3D                                   dec     a
  54+ E412 81                                   add     a,c
  55+ E413 41                                   ld      b,c
  56+ E414 08                                   ex      af,af'
  57+ E415                                      ;TODOcall    l2_draw_horz_line_320       ; b = row, hl = col, e = width a = colour
  58+ E415 F1 E1 D1 C1  .leftVertLine:          pop     bc,,de,,hl,,af
  59+ E419 C5 D5 E5 F5                          push    bc,,de,,hl,,af
  60+ E41D                                      ;TODOcall    l2_draw_vert_line_320
  61+ E41D F1 E1 D1 C1                          pop     bc,,de,,hl,,af
  62+ E421 19                                   add     hl,de
  63+ E422 2B                                   dec     hl
  64+ E423                                      ;TODOcall    l2_draw_vert_line_320
  65+ E423 C9                                   ret
  66+ E424
# file closed: ./Layer2Graphics/layer2_draw_box.asm
 226  E424                  INCLUDE "./Layer2Graphics/asm_l2_plot_horizontal.asm"
# file opened: ./Layer2Graphics/asm_l2_plot_horizontal.asm
   1+ E424
   2+ E424              ;; NOTE DMA is little endian
   3+ E424 00           l2_horz_pixel           DB 0
   4+ E425
   5+ E425 83 C3 C7 CB  l2_horz_line            DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   5+ E429 7D
   6+ E42A 24 E4        l2_horz_colr            DW l2_horz_pixel
   7+ E42C 00           l2_horz_lenlo           DB 0
   8+ E42D 00           l2_horz_lenhi           DB 0
   9+ E42E 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY, DMA_WR2_P2INC_MEMORY, DMA_WR4_CONT_MODE
  10+ E431 00 00        l2_horz_target          DB $00, $00
  11+ E433 CF 87                                DB DMA_LOAD, DMA_ENABLE
  12+ E435              l2_horz_cmd_len	        EQU $ - l2_horz_line
  13+ E435
  14+ E435
  15+ E435              ; "l2_draw_horz_dma"
  16+ E435              ; "plot at bc for length d colour e using dma, assumes bank already selected"
  17+ E435 7B           l2_draw_horz_dma:       ld		a,e                                               ; T=4      ;
  18+ E436 32 24 E4                             ld		(l2_horz_pixel),a                                 ; T=13     ;
  19+ E439 5A                                   ld      e,d ; saved 3 t states ld		a,d                                               ; T=4      ; e=d   4
  20+ E43A 16 00                                ld      d,0; saved 3 t states ld 		(l2_horz_lenlo),a                                 ; T=13     ; d = 0  7
  21+ E43C ED 53 2C E4                          ld      (l2_horz_lenlo),de; saved 3 t states xor 	a                                                 ; T=4      ; t 20  31
  22+ E440                                      ; saved 3 t states ld ld 		(l2_horz_lenhi),a                                 ; T=13     ;
  23+ E440                                    ; saved 4 t states  ld		h,b                           ;          ;
  24+ E440                                    ; saved 4 t states  ld		l,c                           ;          ;
  25+ E440 ED 43 31 E4                          ld      (l2_horz_target),bc ; saved 4 t states  was , hl  ; T=20     ;
  26+ E444 21 25 E4     .write_dma:             ld 		hl, l2_horz_line                                  ;          ;
  27+ E447 06 10                                ld 		b, l2_horz_cmd_len                                ;
  28+ E449 0E 6B                                ld		c,IO_DATAGEAR_DMA_PORT                            ;
  29+ E44B ED B3                                otir                                                      ;
  30+ E44D C9                                   ret
  31+ E44E
  32+ E44E              ; "bc = left side row,col, d = length, e = color"
  33+ E44E D5           l2_draw_horz_dma_bank:  push 	de							; save length and colour
  34+ E44F C5                                   push 	bc							; save row col
  35+ E450 78                                   ld   	a,b
  36+ E451 CD 68 E0                             call 	asm_l2_row_bank_select		; now we have the correct bank, its a horizontal line so bank will not shift
  37+ E454 C1                                   pop  	bc
  38+ E455 47                                   ld	 	b,a	       					; fixed row by the call we can go straight into HL with row col
  39+ E456 D1                                   pop  	de							; get length back
  40+ E457 CD 35 E4                             call    l2_draw_horz_dma
  41+ E45A C9                                   ret
  42+ E45B
  43+ E45B              ; "l2_draw_horz_line"
  44+ E45B              ; "bc = left side row,col, d = length, e = color"
  45+ E45B              ; "optimisation if above min pix is will use dma call SCREEN_HOZ_MIN_PIX not implemented yet"
  46+ E45B 7A           l2_draw_horz_line:      ld		a,d
  47+ E45C FE 00                                cp 		0							; if its zero length then just return
  48+ E45E C8           .zerolengthexit:        ret		z
  49+ E45F FE 01        .isitlen1:              cp 		1
  50+ E461 CA 83 E4                             jp 		z,.l2_draw_horz_line_1
  51+ E464 FE 0A        .longenoughtfordma:     cp  10
  52+ E466 C3 4E E4                             jp  l2_draw_horz_dma_bank
  53+ E469 D5 C5        .plottableline:         push 	de,,bc  					; save length and colour an d row col
  54+ E46B 78                                   ld   	a,b
  55+ E46C CD 68 E0                             call 	asm_l2_row_bank_select		; now we have the correct bank, its a horizontal line so bank will not shift
  56+ E46F C1                                   pop  	bc
  57+ E470 67                                   ld	 	h,a	       					; fixed row by the call we can go straight into HL with row col
  58+ E471 69                                   ld   	l,c
  59+ E472 D1                                   pop  	de							; get length back
  60+ E473 79           .cliptest:              ld	 	a,c							; get column + length
  61+ E474 42                                   ld  	b,d  						; speculate that we don't clip by pre-loading b with length
  62+ E475 82                                   add  	a,d
  63+ E476 30 06                                jr   	nc, .l2_draw_horz_plot_loop	; if carry is set c+d > 255
  64+ E478 3E FF        .clipat255:             ld   	a,$FF
  65+ E47A 91                                   sub  	c							; a holds clipped length
  66+ E47B 47                                   ld 		b, a 						; so now hl holds poke address  b = clipped length e = colour
  67+ E47C 18 00                                jr		.l2_draw_horz_plot_loop
  68+ E47E 73           .l2_draw_horz_plot_loop:ld (hl),e							; loop poking hl with e for b pixels
  69+ E47F 23                                   inc hl
  70+ E480 10 FC                                djnz .l2_draw_horz_plot_loop
  71+ E482 C9                                   ret
  72+ E483 7B           .l2_draw_horz_line_1:   ld		a,e
  73+ E484                                      l2_plot_macro; jp		l2_plot_pixel				; hijack return
  73+ E484 78          >                        ld      a,b
  73+ E485             >                        JumpIfAGTENusng 192 ,.NoPlot
  73+ E485 FE C0       >                        cp     192
  73+ E487 D2 93 E4    >                        jp		nc,.NoPlot
  73+ E48A 69          >                        ld      l,c
  73+ E48B CD 68 E0    >                        call    asm_l2_row_bank_select
  73+ E48E 67          >                        ld      h,a
  73+ E48F 3A A7 F1    >                        ld      a,(line_gfx_colour)
  73+ E492 77          >                        ld      (hl),a
  73+ E493             >.NoPlot:
  74+ E493 C9                                   ret
  75+ E494
  76+ E494
  77+ E494              ; "l2_draw_horz_line_to"
  78+ E494              ; "bc = left side row,col, d right pixel, e = color"
  79+ E494 7A           l2_draw_horz_line_to:   ld 		a,d
  80+ E495 B9                                   cp 		c
  81+ E496 30 04                                jr		nc, .noswap
  82+ E498 28 07                                jr      z, .singlepixel
  83+ E49A 51           .swap:                  ld		d,c
  84+ E49B 4F                                   ld		c,a
  85+ E49C 7A           .noswap:                ld		a,d
  86+ E49D 91                                   sub		c
  87+ E49E              ;                        dec		a							; so now its length not offset
  88+ E49E 57                                   ld		d,a
  89+ E49F 18 BA                                jr 		l2_draw_horz_line			; hijack routine and return statements
  90+ E4A1 7B           .singlepixel:           ld		a,e
  91+ E4A2                                      l2_plot_macro; jp		l2_plot_pixel				; hijack return
  91+ E4A2 78          >                        ld      a,b
  91+ E4A3             >                        JumpIfAGTENusng 192 ,.NoPlot
  91+ E4A3 FE C0       >                        cp     192
  91+ E4A5 D2 B1 E4    >                        jp		nc,.NoPlot
  91+ E4A8 69          >                        ld      l,c
  91+ E4A9 CD 68 E0    >                        call    asm_l2_row_bank_select
  91+ E4AC 67          >                        ld      h,a
  91+ E4AD 3A A7 F1    >                        ld      a,(line_gfx_colour)
  91+ E4B0 77          >                        ld      (hl),a
  91+ E4B1             >.NoPlot:
  92+ E4B1 C9                                   ret
  93+ E4B2
# file closed: ./Layer2Graphics/asm_l2_plot_horizontal.asm
 227  E4B2                  INCLUDE "./Layer2Graphics/asm_l2_plot_vertical.asm"
# file opened: ./Layer2Graphics/asm_l2_plot_vertical.asm
   1+ E4B2              ; ">l2_draw_vert_segment"
   2+ E4B2              ; ">hl = bank adjusted pixel poke address d = length, e = color"
   3+ E4B2              ; ">will always clip once h = 64 even if length > 64 destroys a and hl, d = resudual length not plotted"
   4+ E4B2 7A           l2_draw_vert_segment:   ld		a,d
   5+ E4B3 FE 00        .emptylinecheck:	    cp 		0
   6+ E4B5 C8                                   ret		z
   7+ E4B6 FE 01        .justonepixel	        cp		1
   8+ E4B8 20 02                                jr		nz, .multiplepixelsLoop
   9+ E4BA 73                                   ld		(hl),e
  10+ E4BB C9                                   ret
  11+ E4BC              .multiplepixelsLoop:
  12+ E4BC 7C           .endofbankcheck:        ld   	a,h
  13+ E4BD FE 40                                cp   	64
  14+ E4BF D0                                   ret		nc							; check before we poke data if we have hit a boundary
  15+ E4C0 73           .canplotapixel:         ld   	(hl),e						; set colour
  16+ E4C1 24                                   inc 	h							; we don't check here else we would need a dec d on ret could do for optimisation of loop though
  17+ E4C2 15                                   dec		d
  18+ E4C3 C8                                   ret		z
  19+ E4C4 18 F6                                jr		.multiplepixelsLoop
  20+ E4C6
  21+ E4C6              ; ">l2_draw_vert_line"
  22+ E4C6              ; ">bc = row col d = length, e = color"
  23+ E4C6 78           l2_draw_vert_line:      ld 		a,b
  24+ E4C7 FE C0        .offscreencheck:        cp 		SCREEN_HEIGHT
  25+ E4C9 D0                                   ret 	nc							; can't start off the screen
  26+ E4CA 7A           .emptylinecheck:        ld		a,d
  27+ E4CB FE 00                                cp		0
  28+ E4CD C8                                   ret		z
  29+ E4CE FE 01                                cp		1
  30+ E4D0 20 10                                jr		nz,.multiplepixels
  31+ E4D2              .itsonepixel:           l2_plot_macro; call	l2_plot_pixel
  31+ E4D2 78          >                        ld      a,b
  31+ E4D3             >                        JumpIfAGTENusng 192 ,.NoPlot
  31+ E4D3 FE C0       >                        cp     192
  31+ E4D5 D2 E1 E4    >                        jp		nc,.NoPlot
  31+ E4D8 69          >                        ld      l,c
  31+ E4D9 CD 68 E0    >                        call    asm_l2_row_bank_select
  31+ E4DC 67          >                        ld      h,a
  31+ E4DD 3A A7 F1    >                        ld      a,(line_gfx_colour)
  31+ E4E0 77          >                        ld      (hl),a
  31+ E4E1             >.NoPlot:
  32+ E4E1 C9                                   ret
  33+ E4E2              .multiplepixels:						; so now we have at least 2 pixels to plot
  34+ E4E2 7A           .clipto192:             ld		a,d							; get length
  35+ E4E3 80                                   add		a,b							; a= row + length
  36+ E4E4 38 04                                jr		c,.needtoclip				; if it was > 255 then there is a definite need
  37+ E4E6 FE C0                                cp		SCREEN_HEIGHT
  38+ E4E8 38 08                                jr		c, .noclipneeded
  39+ E4EA 78           .needtoclip             ld		a,b
  40+ E4EB 82                                   add		a,d
  41+ E4EC D6 C0                                sub		SCREEN_HEIGHT
  42+ E4EE 67                                   ld		h,a							; use h as a temp holding for (row + length) - 192
  43+ E4EF 7A                                   ld		a,d
  44+ E4F0 94                                   sub		h
  45+ E4F1 57                                   ld		d,a							; d = length - ((row + length) - 192)
  46+ E4F2              ; so now BC = row col, d = length clipped, e = color
  47+ E4F2 78           .noclipneeded:          ld		a,b
  48+ E4F3 C5 D5                                push	bc,,de
  49+ E4F5 CD 68 E0                             call 	asm_l2_row_bank_select
  49+ E4F8               	 	; we now have poke address and a variable holding current bank number
  50+ E4F8 D1 C1                                pop		bc,,de
  51+ E4FA 67                                   ld		h,a							; b now tolds target pixel for first plot
  52+ E4FB 69                                   ld		l,c  						; and c holds pixel column for plotting
  53+ E4FC CD B2 E4                             call 	l2_draw_vert_segment		; draw seg, d = pixels remaining
  54+ E4FF 7A                                   ld		a,d							; a and d = nbr pixels remaining
  55+ E500 FE 00                                cp		0
  56+ E502 28 27                                jr		z, .doneplotting
  57+ E504 3A 00 E0     .anotherbank:           ld		a, (varL2_BANK_SELECTED)
  58+ E507 3C                                   inc		a
  59+ E508 06 00                                ld		b,0
  60+ E50A C5 D5                                push	bc,,de
  61+ E50C CD 51 E0                             call 	asm_l2_bank_n_select
  62+ E50F D1 C1                                pop     bc,,de
  63+ E511 60                                   ld		h,b							; b now tolds target pixel for first plot
  64+ E512 69                                   ld		l,c  						; and c holds pixel column for plotting
  65+ E513 CD B2 E4                             call	l2_draw_vert_segment
  66+ E516 7A                                   ld		a,d
  67+ E517 FE 00                                cp		0
  68+ E519 28 10                                jr		z,.doneplotting
  69+ E51B 3A 00 E0     .yetanotherbank:        ld		a, (varL2_BANK_SELECTED)
  70+ E51E 3C                                   inc		a
  71+ E51F 06 00                                ld		b,0
  72+ E521 C5 D5                                push	bc,,de
  73+ E523 CD 51 E0                             call 	asm_l2_bank_n_select
  74+ E526 D1                                   pop		de
  75+ E527 E1                                   pop		hl							; hl = bc
  76+ E528 CD B2 E4                             call	l2_draw_vert_segment		; we have now hit 192 pixels so done
  77+ E52B C9           .doneplotting:	        ret
  78+ E52C
  79+ E52C              ; ">l2_draw_vert_line_to"
  80+ E52C              ; ">bc = row col d = to position, e = color"
  81+ E52C 78           l2_draw_vert_line_to:   ld		a,b
  82+ E52D BA                                   cp		d
  83+ E52E 38 02                                jr		c, .noyswap
  84+ E530 42           .yswap:                 ld		b,d			; Swap round row numbers so we are always incrementing
  85+ E531 57                                   ld		d,a			; now we have a top to bottom to we we can calc length from bc
  86+ E532 7A           .noyswap:               ld		a,d 		; we still may have d in a but only if it was bottom to top
  87+ E533 90                                   sub		b
  88+ E534 3C                                   inc		a			; so now its length not offset
  89+ E535 57                                   ld		d,a
  90+ E536 18 8E                                jr		l2_draw_vert_line	; we can hijack its clipping, 0 check and return logic
  91+ E538                                      ; no return needed
  92+ E538
# file closed: ./Layer2Graphics/asm_l2_plot_vertical.asm
 228  E538                  INCLUDE "./Layer2Graphics/layer2_plot_diagonal.asm"
# file opened: ./Layer2Graphics/layer2_plot_diagonal.asm
   1+ E538
   2+ E538              l2_draw_box_to:
   3+ E538              ; ">l2_draw_box_to bc=rowcol, de=torowcol a=color"
   4+ E538              ; ">NOT IMPLEMENTED YET"
   5+ E538 C9           	ret
   6+ E539
   7+ E539              ;; Note l2stepx is done via self modifying code rather than an if for speed
   8+ E539              ;; l2stepx1 and l2stepx2 are the addresses to stick the inc or dec in
   9+ E539              l2incbcstep EQU $03
  10+ E539              l2incbstep	EQU	$04
  11+ E539              l2decbstep	EQU $05
  12+ E539              l2decbcstep EQU $0B
  13+ E539              l2deccstep	EQU $0D
  14+ E539              l2inccstep	EQU	$0C
  15+ E539              l2incdestep EQU $13
  16+ E539              l2decdestep EQU $1B
  17+ E539              l2inchlstep EQU $23
  18+ E539              l2dechlstep EQU $2B
  19+ E539              		; l2 deltas are signed
  20+ E539 00 00        l2deltaY	DW	0
  21+ E53B 00 00        l2deltaX	DW	0
  22+ E53D 00           l2deltaYsq	db	0
  23+ E53E 00           l2deltaXsq	db	0
  24+ E53F 00           l2deltaYn	db	0
  25+ E540 00           l2deltaXn	db	0
  26+ E541 00           l2deltaYsqn	db	0
  27+ E542 00           l2deltaXsqn	db	0
  28+ E543 00           l2linecolor	db	0
  29+ E544 00 00        l2fraction	dw	0
  30+ E546 00 00        l2e2		dw	0
  31+ E548 00           l2way		db	0
  32+ E549 00 00        l2targetPtr	dw	0
  33+ E54B              ;; These arrays should be 192 but if we use 256 then getting array2 value is just inc h rather than indexing again.
  34+ E54B 00 00 00...  l2targetArray1 ds	256
  35+ E64B 00 00 00...  l2targetArray2 ds	256
  36+ E74B              ;; Using Bresenham Algorithm draw a diagonal line top to bottom. First we must sort of course
  37+ E74B              ;;plotLine(int x0, int y0, int x1, int y1)
  38+ E74B              ;;    dx =  abs(x1-x0);
  39+ E74B              ;;    sx = x0<x1 ? 1 : -1;
  40+ E74B              ;;    dy = -abs(y1-y0);
  41+ E74B              ;;    sy = y0<y1 ? 1 : -1;
  42+ E74B              ;;    err = dx+dy;  /* error value e_xy */
  43+ E74B              ;;    while (true)   /* loop */
  44+ E74B              ;;        plot(x0, y0);
  45+ E74B              ;;        if (x0==x1 && y0==y1) break;
  46+ E74B              ;;        e2 = 2*err;
  47+ E74B              ;;        if (e2 >= dy) /* e_xy+e_x > 0 */
  48+ E74B              ;;            err += dy;
  49+ E74B              ;;            x0 += sx;
  50+ E74B              ;;        end if
  51+ E74B              ;;        if (e2 <= dx) /* e_xy+e_y < 0 */
  52+ E74B              ;;            err += dx;
  53+ E74B              ;;            y0 += sy;
  54+ E74B              ;;        end if
  55+ E74B              ;;    end while
  56+ E74B              ; ">l2_draw_diagonal_save, bc = y0,x0 de=y1,x1,a=array nbr ESOURCE LL30 or LION"
  57+ E74B              ; ">hl will be either l2targetArray1 or 2"
  58+ E74B              ; For S15 version we can still use the current table as this will hold final fill data
  59+ E74B              ; but we have to come in with X1Y1 X2Y2 being 16 bit
  60+ E74B              ; if the Y1Y2 are both off same side of screen or X1X2 both off same side them line array is set as empty
  61+ E74B              ; so
  62+ E74B              ;       for each line from Y1 to Y2
  63+ E74B              ;           if calculate as normal
  64+ E74B              ;                if off screen we don't write
  65+ E74B              ;                if on screen we clip to 0,255  which is easy as a horizontal line
  66+ E74B              ;           we will need a special case were a line is not rendered    we have x1=255 and X1 = 0, i.e. they are flipped
  67+ E74B              ;              we could also cheat and say view port as 1 pixel edge border so we can count x1 = 0 as no line
  68+ E74B
  69+ E74B              ; This must be called with  Y1 < Y2 as we won;t do a pre check
  70+ E74B              ; Caulates the temp x. IY [01] = X1 [23]=Y1 [45]=X2 [67]=Y2 [89]=midY3
  71+ E74B              ; Draw a line from BC to DE, with target Y position in a, all values must be 2's C at this points
  72+ E74B              ; calculate deltaX, deltaY for line.
  73+ E74B              ; calculate offsetY = TargetY - Y1
  74+ E74B              ; calculate XTarget = X1 + (deltaX/deltaY) *  offsetY
  75+ E74B              ;;;l2DiagDeltaX    DW 0
  76+ E74B              ;;;l2_diagonal_getx:       ld		hl,0                            ;
  77+ E74B              ;;;                        ld      ixh,0                           ; flag byte clear
  78+ E74B              ;;;                        ld      (target_y),a                    ; save target
  79+ E74B              ;;;.calculateDeltaX:       ld      hl,(IY+4)
  80+ E74B              ;;;                        ld      de,(IY+0)
  81+ E74B              ;;;                        ClearCarryFlag
  82+ E74B              ;;;                        sbc     hl,de
  83+ E74B              ;;;                        ld      (l2DiagDeltaX),hl
  84+ E74B              ;;;.calculateDeltaY:       ld      hl,(IY+6)
  85+ E74B              ;;;                        ld      de,(IY+2)
  86+ E74B              ;;;                        ClearCarryFlag
  87+ E74B              ;;;                        sbc     hl,de
  88+ E74B              ;;;                        ld      (l2DiagDeltaY),hl
  89+ E74B              ;;;.ABSDx:                 ld      hl,(l2DiagDeltaX)
  90+ E74B              ;;;                        ld      a,h
  91+ E74B              ;;;                        and     $80
  92+ E74B              ;;;                        jr      nz,.DxPositive
  93+ E74B              ;;;.DxNegative:            macronegate16hl
  94+ E74B              ;;;.DxPositive:            ex      de,hl                               ; de = deltaX
  95+ E74B              ;;;                        ld      hl,(l2DiagDeltaY)
  96+ E74B              ;;;                        ld      a,h
  97+ E74B              ;;;                        and     $80
  98+ E74B              ;;;                        jr      nz,.DyPositive
  99+ E74B              ;;;.DyNegative:            macronegate16hl
 100+ E74B              ;;;.DyPositive:
 101+ E74B              ;;;.ScaleLoop:             ld      a,h                                 ; At this point DX and DY are ABS values
 102+ E74B              ;;;                        or      d                                   ; .
 103+ E74B              ;;;                        jr      z,.ScaleDone                        ; .
 104+ E74B              ;;;                        ShiftDERight1                               ; .
 105+ E74B              ;;;                        ShiftHLRight1                               ; .
 106+ E74B              ;;;                        jr      .ScaleLoop                          ; scaled down Dx and Dy to 8 bit, Dy may have been;;                                                                                               negative
 107+ E74B              ;;;.ScaleDone:             ; hl = ABS DY, DE = ABS DX,  bc = Y1, ix = Y2,   note H and D will be zero
 108+ E74B              ;;;.CalculateDelta:        ld      a,e                                 ; if DX < DY goto DX/DY
 109+ E74B              ;;;                        JumpIfALTNusng l,.DXdivDY                   ; else do DY/DX
 110+ E74B              ;;;.DYdivDX:               ld      a,l                                 ;    A = DY
 111+ E74B              ;;;                        ld      d,e                                 ;    D = DX
 112+ E74B              ;;;                        call    AEquAmul256DivD                     ;    A = R = 256 * DY / DX
 113+ E74B              ;;;.SaveGradientDYDX:      ld      (Gradient),a
 114+ E74B              ;;;                        ld      a,ixh
 115+ E74B              ;;;                        or      16
 116+ E74B              ;;;                        ld      ixh,a                               ;
 117+ E74B              ;;;                        jp      .ClipP1                             ;
 118+ E74B              ;;;.DXdivDY:               ld      a,e                                 ;    A = DX
 119+ E74B              ;;;                        ld      d,l                                 ;    D = DY
 120+ E74B              ;;;                        call    AEquAmul256DivD                     ;    A = R = 256 * DX / DY
 121+ E74B              ;;;.SaveGradientDXDY:      ld      (Gradient),a
 122+ E74B              ;;;
 123+ E74B              ;;;have X1 -> X
 124+ E74B              ;;;need deltaMidY = MidY - Y0
 125+ E74B              ;;;                        X0 + (DeltaMY * Gradient) but if the graident is flipped then its X0+(deltaMY / Gradient)
 126+ E74B              ;;;
 127+ E74B              ;;;
 128+ E74B              ;;;.calculateDeltaY:
 129+ E74B              ;;;.calcualteDxDyOrDyDx
 130+ E74B              ;;;.calculate
 131+ E74B              ;;;
 132+ E74B              ; Total unoptimised version
 133+ E74B              ; use hl, de, bc, af,
 134+ E74B              ; no used yet ix iy
 135+ E74B              ; can we do an ex for hl' and de' holding x and hl, de holding y?
 136+ E74B                                  INCLUDE "./Layer2Graphics/int_bren_save.asm"
# file opened: ././Layer2Graphics/int_bren_save.asm
   1++E74B              OPCODE_IncHL            EQU $23
   2++E74B              OPCODE_DecHL            EQU $2B
   3++E74B              OPCODE_IncHLIndirect    EQU $34
   4++E74B              OPCODE_DecHLIndirect    EQU $35
   5++E74B              OPCODE_IncDE            EQU $13
   6++E74B              OPCODE_DecDE            EQU $1B
   7++E74B              OPCODE_JpNCnn           EQU $D2
   8++E74B              OPCODE_JpCnn            EQU $DA
   9++E74B              LOWEST_SAVE             EQU 0
  10++E74B              HIGHEST_SAVE            EQU 1
  11++E74B
  12++E74B              SetIncrement:           MACRO   Location
  13++E74B ~                                    ld      a,OPCODE_IncDE
  14++E74B ~                                    ld      (Location),a
  15++E74B                                      ENDM
  16++E74B              SetDecrement:           MACRO   Location
  17++E74B ~                                    ld      a,OPCODE_DecDE
  18++E74B ~                                    ld      (Location),a
  19++E74B                                      ENDM
  20++E74B
  21++E74B              ; So next optimisation
  22++E74B              ; we know that we start from row y0 to row Y0
  23++E74B              ; so we can just reference that row range and zero it out rather than the whole
  24++E74B              ; data set
  25++E74B 00           l2_fillValue            DB 0
  26++E74C
  27++E74C 83 C3 C7 CB  l2_fill_line            DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
  27++E750 7D
  28++E751 4B E7        l2_fill_colr            DW l2_fillValue
  29++E753 FF           l2_fill_lenlo           DB 255
  30++E754 00           l2_fill_lenhi           DB 0
  31++E755 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY, DMA_WR2_P2INC_MEMORY, DMA_WR4_CONT_MODE
  32++E758 00 00        l2_fill_target          DB $00, $00
  33++E75A CF 87                                DB DMA_LOAD, DMA_ENABLE
  34++E75C              l2_bren_cmd_len	        EQU $ - l2_fill_line
  35++E75C
  36++E75C 32 4B E7     l2_fill_dma:            ld		(l2_fillValue),a                                 ; T=13     ;
  37++E75F 22 58 E7                             ld      (l2_fill_target),hl
  38++E762 21 4C E7     .write_dma:             ld 		hl, l2_fill_line                                  ;          ;
  39++E765 06 10                                ld 		b, l2_bren_cmd_len                                ;
  40++E767 0E 6B                                ld		c,IO_DATAGEAR_DMA_PORT                            ;
  41++E769 ED B3                                otir                                                      ;
  42++E76B C9                                   ret
  43++E76C
  44++E76C              ; to find a point Y1 along a line X0Y0 to X2Y2
  45++E76C              ; DX = X2-X0, DY = Y2-Y0, D = DX/DY, X1 = X0+ ((Y1-Y0)*DX)
  46++E76C              ; will need 16.8 24 bit maths for DX DY unless we scale down and do a muliplier up
  47++E76C              ; so we could do DX = X2-X0, scale to 8.8  ... Note this will fail for extrmem near vertical or horizontal angles
  48++E76C              ;                DY = Y2-Y0, scale to 8.8  ... could we use an octlet lookup table?
  49++E76C              ;                D  = DX/DY which would give us an 8.2 proportion
  50++E76C              ; a look up table would not work for calc of DX DY but we could use a log table and anti log to simplify to add/subtract
  51++E76C              ; need a version of this that counts down to a trigger Y axis + 1, ideallign using DX DY if possible
  52++E76C              ; We may be able to use the flat top/flat botttom and pick up a calculated value 0nce it hits Y2?
  53++E76C              ; Yes logirithm table will work, need to build as a decimal set optimised
  54++E76C              ; logically if the ship is too close it will always be too close to render so we can exclude
  55++E76C              ; excessivley large values for X and Y as they will either be too far off side or span the whole screen
  56++E76C              ; and just flood fill
  57++E76C              ; Thsi means we can do log maths for jsut 0 to 1024
  58++E76C              ; 9/11 we assume that large values will either flood fill or be straight lines
  59++E76C              ; so we allow a range of -256 to + 512 ,i.e. off screen by a whole additional screen
  60++E76C              ; then divide becomes 16 bit div 16 bit to yeild an 8.8 result. This can then be used to work out the new position
  61++E76C              ; so                    DE = DX (Ignoring signs for now)
  62++E76C              ;                       HL = DY
  63++E76C              ; we need L2_DX, L2_DY output is HL
  64++E76C              ; After workign out in excel Formulas are:
  65++E76C              ; incomming X0, Y0, Y1, DX , DY
  66++E76C              ; dY2 = Y1-Y0
  67++E76C              ; dXHi = DX/DY*256
  68++E76C              ; dxRemainder = DX-dXHi
  69++E76C              ; dXRemainder = TRUNC((dxRemainder)/DY)*256
  70++E76C              ; Integer component = dY2 * dXHi /256
  71++E76C              ; Adj     component = DY2 * dXRemainder /256
  72++E76C              ; total = Integer + Adj + X0
  73++E76C
  74++E76C 00 00        l2_X0                   DW 0
  75++E76E 00 00        l2_Y0                   DW 0
  76++E770 00 00        l2_X1                   DW 0
  77++E772 00 00        l2_Y1                   DW 0
  78++E774 00 00        ld_YMid                 DW 0
  79++E776 00 00        l2_DX                   DW 0
  80++E778 00 00        l2_DY                   DW 0
  81++E77A 00 00        l2_Error                DW 0
  82++E77C 00 00        l2_E2                   DW 0
  83++E77E 00 00        l2_dY2                  DW 0
  84++E780 00 00        ld_dxHi                 DW 0
  85++E782 00 00        l2_dxRemainder          DW 0
  86++E784 00 00        l2_dxRemainder2         DW 0
  87++E786 00 00        l2_dXRemainderAdj       DW 0
  88++E788 00 00        l2_integer              DW 0
  89++E78A 00 00        l2_integer2             DW 0
  90++E78C
  91++E78C 2A 76 E7     ScaleDXDY:              ld      hl,(l2_DX)
  92++E78F ED 5B 78 E7                          ld      de,(l2_DY)
  93++E793 7C           .ScaleLoop:             ld      a,h
  94++E794 B2                                   or      d
  95++E795 28 0B                                jr      z,.ScaleDone
  96++E797                                      ShiftHLRight1
  96++E797 CB 3C       >			   srl h
  96++E799 CB 1D       >			   rr  l
  97++E79B                                      ShiftDERight1
  97++E79B CB 3A       >			   srl d
  97++E79D CB 1B       >			   rr  e
  98++E79F C3 93 E7                             jp      .ScaleLoop
  99++E7A2 22 76 E7     .ScaleDone:             ld      (l2_DX),hl
 100++E7A5 ED 53 78 E7                          ld      (l2_DY),de
 101++E7A9 C9                                   ret
 102++E7AA
 103++E7AA 2A 70 E7     HLEquMidX:              ld      hl,(l2_X1)
 104++E7AD ED 5B 6C E7                          ld      de,(l2_X0)
 105++E7B1                                      ClearCarryFlag
 105++E7B1 B7          >                        or a
 106++E7B2 ED 52                                sbc     hl,de
 107++E7B4 22 76 E7                             ld      (l2_DX),hl
 108++E7B7 2A 72 E7                             ld      hl,(l2_Y1)
 109++E7BA ED 5B 6E E7                          ld      de,(l2_Y0)
 110++E7BE                                      ClearCarryFlag
 110++E7BE B7          >                        or a
 111++E7BF ED 52                                sbc     hl,de
 112++E7C1 22 78 E7                             ld      (l2_DY),hl
 113++E7C4 DD 01                                break
 114++E7C6 CD 8C E7                             call    ScaleDXDY
 115++E7C9 2A 74 E7                             ld      hl,(ld_YMid)
 116++E7CC                                      ClearCarryFlag
 116++E7CC B7          >                        or a
 117++E7CD ED 52                                sbc     hl,de
 118++E7CF 22 7E E7                             ld      (l2_dY2),hl
 119++E7D2 ED 4B 76 E7                          ld      bc,(l2_DX)          ; dXHi(DE)= DX/DY*256
 120++E7D6 ED 5B 78 E7                          ld      de,(l2_DY)          ; .
 121++E7DA DD 62 DD 6B                          ld      ix,de               ; .
 122++E7DE E5 FD E1                             ld      iy,hl               ; .
 123++E7E1              ;                       BC = DX/DY as 8.8           ; .
 124++E7E1 CD 02 87                             call    BC_Div_DE; DEequDEDivBC; DE is the result HL is the remainder
 125++E7E4 78                                   ld      a,b                 ; if DE is 8 bit only
 126++E7E5 A7                                   and     a                   ; .
 127++E7E6 28 06                                jr      z,.LT255            ; goto LT255
 128++E7E8 01 FF FF                             ld      bc,$FFFF            ; else set BC to $FFFF
 129++E7EB C3 27 E8                             jp      .DoneCalc           ; .
 130++E7EE ED 43 80 E7  .LT255:                 ld      (ld_dxHi),bc        ;
 131++E7F2 22 82 E7                             ld      (l2_dxRemainder),hl ; dxRemainder = DX-dXHi
 132++E7F5 DD 01        .CalcIntegerComponent:  break
 133++E7F7 2A 7E E7                             ld      hl,(l2_dY2)         ; Integer component = dY2 * dXHi /256
 134++E7FA ED 5B 80 E7                          ld      de,(ld_dxHi)        ; .
 135++E7FE CD 46 88                             call    DEHLequDEmulHL      ; .
 136++E801 ED 53 88 E7                          ld      (l2_integer),de     ; .
 137++E805 22 8A E7                             ld      (l2_integer2),hl    ; .
 138++E808 ED 4B 82 E7  .CalcRemainderFraction: ld      bc,(l2_dxRemainder) ; dXRemainder = TRUNC((dxRemainder)/DY)*256
 139++E80C ED 5B 78 E7                          ld      de,(l2_DY)          ; .
 140++E810 CD 02 87                             call    BC_Div_DE           ; BC, remainder in HL
 141++E813 ED 43 86 E7                          ld      (l2_dXRemainderAdj),bc
 142++E817 22 84 E7                             ld      (l2_dxRemainder2),hl
 143++E81A 2A 7E E7     .CalcAdjustment:        ld      hl,(l2_dY2)         ; Adj component = DY2 * dXRemainder /256
 144++E81D 50 59                                ld      de,bc               ;
 145++E81F CD 46 88                             call    DEHLequDEmulHL      ;
 146++E822 2A 88 E7                             ld      hl,(l2_integer)
 147++E825 19                                   add     hl,de
 148++E826 C9                                   ret
 149++E827
 150++E827
 151++E827              ;                       HL = (DE * B) /256
 152++E827 C5           .DoneCalc:              push    bc
 153++E828 58                                   ld      e,b
 154++E829 DD E5 E1                             ld      hl,ix
 155++E82C CD 31 88                             call AHLequHLmulE
 156++E82F 6C                                   ld l,h
 157++E830 67                                   ld h,a
 158++E831 E5 DD E1                             ld      ix,hl
 159++E834              ;                       DE = (DE * C) /256          ld e,c call AHLequHLmulE,ld l,h, ld h,a
 160++E834 C1                                   pop     bc
 161++E835 59                                   ld      e,c
 162++E836 FD E5 E1                             ld      hl,iy
 163++E839 CD 31 88                             call AHLequHLmulE
 164++E83C 6C                                   ld l,h
 165++E83D 67                                   ld h,a
 166++E83E              ;                       HL + = DE
 167++E83E DD 54 DD 5D                          ld      de,ix
 168++E842 19                                   add     hl,de
 169++E843              ;                       HL + + X0
 170++E843 ED 5B 6C E7                          ld      de,(l2_X0)
 171++E847 19                                   add     hl,de
 172++E848 C9                                   ret
 173++E849
 174++E849
 175++E849
 176++E849
 177++E849              ;; Need optimisation for vertical line and horizonal
 178++E849              int_bren_save_Array1Low:
 179++E849 3E FF                                ld      a,$FF
 180++E84B 21 4B E5                             ld      hl,l2targetArray1   ; L2targetArray2 Population
 181++E84E CD 5C E7                             call    l2_fill_dma
 182++E851 3E DA                                ld      a,OPCODE_JpCnn
 183++E853 21 4B E5                             ld      hl,l2targetArray1   ; L2targetArray2 Population
 184++E856 C3 84 E8                             jp      int_bren_save_Array ;
 185++E859              int_bren_save_Array1High:
 186++E859                                      ZeroA
 186++E859 AF          >                        xor a
 187++E85A 21 4B E5                             ld      hl,l2targetArray1   ; L2targetArray2 Population
 188++E85D CD 5C E7                             call    l2_fill_dma
 189++E860 3E D2                                ld      a,OPCODE_JpNCnn
 190++E862 21 4B E5                             ld      hl,l2targetArray1   ; L2targetArray2 Population
 191++E865 C3 84 E8                             jp      int_bren_save_Array ;
 192++E868              int_bren_save_Array2Low:
 193++E868 3E FF                                ld      a,$FF
 194++E86A 21 4B E6                             ld      hl,l2targetArray2   ; L2targetArray2 Population
 195++E86D CD 5C E7                             call    l2_fill_dma
 196++E870 3E DA                                ld      a,OPCODE_JpCnn
 197++E872 21 4B E6                             ld      hl,l2targetArray2   ; L2targetArray2 Population
 198++E875 C3 84 E8                             jp      int_bren_save_Array ;
 199++E878              int_bren_save_Array2High:
 200++E878                                      ZeroA
 200++E878 AF          >                        xor a
 201++E879 21 4B E6                             ld      hl,l2targetArray2   ; L2targetArray2 Population
 202++E87C CD 5C E7                             call    l2_fill_dma
 203++E87F 21 4B E6                             ld      hl,l2targetArray2   ; L2targetArray2 Population
 204++E882 3E D2                                ld      a,OPCODE_JpNCnn
 205++E884              ; Uses HL DE
 206++E884              ; Note this works out the last position for each point, not any intermediate
 207++E884              ; so we need a version that plots lowest for left line & highest for right line
 208++E884 22 10 E9     int_bren_save_Array:    ld      (.TargetArrayAddr+2),hl
 209++E887 32 21 E9                             ld      (.TargetJump),a
 210++E88A 2A 70 E7                             ld      hl,(l2_X1)          ; if X0 < X1
 211++E88D ED 5B 6C E7                          ld      de,(l2_X0)          ; calculate SX DX
 212++E891              ; --- dx = abs(x1 - x0) & set up SX
 213++E891                                      ClearCarryFlag              ;
 213++E891 B7          >                        or a
 214++E892 ED 52                                sbc     hl,de               ;
 215++E894 CB 7C                                bit     7,h                 ;
 216++E896 28 0E                                jr      z,.DXPositive       ;
 217++E898              .DXNegative:            NegHL                       ;
 217++E898 AF          >                    xor a
 217++E899 95          >                    sub l
 217++E89A 6F          >                    ld l,a
 217++E89B 9F          >                    sbc a,a
 217++E89C 94          >                    sub h
 217++E89D 67          >                    ld h,a
 218++E89E                                      SetDecrement .UpdateX0Operation
 218++E89E 3E 1B       >                        ld      a,OPCODE_DecDE
 218++E8A0 32 71 E9    >                        ld      (.UpdateX0Operation),a
 219++E8A3 C3 AB E8                             jp      .DoneCalcDx         ;
 220++E8A6              .DXPositive:            SetIncrement .UpdateX0Operation
 220++E8A6 3E 13       >                        ld      a,OPCODE_IncDE
 220++E8A8 32 71 E9    >                        ld      (.UpdateX0Operation),a
 221++E8AB 22 76 E7     .DoneCalcDx:            ld      (l2_DX),hl          ;
 222++E8AE ED 5B 6C E7                          ld      de,(l2_X0)          ; fetch in X0 so we can exx
 223++E8B2 ED 4B 70 E7                          ld      bc,(l2_X1)          ; and also X1
 224++E8B6 D9                                   exx                         ; ++now hl' = DX, DE'=X0, BC' = X1
 225++E8B7              ; --- dy = -abs(y1 - y0) & set up SY
 226++E8B7 2A 72 E7     .CalcDY:                ld      hl,(l2_Y1)          ; If Y1 < Y1
 227++E8BA ED 5B 6E E7                          ld      de,(l2_Y0)          ; calculate SY DY
 228++E8BE                                      ClearCarryFlag              ;
 228++E8BE B7          >                        or a
 229++E8BF ED 52                                sbc     hl,de               ;
 230++E8C1 CB 7C                                bit     7,h                 ;
 231++E8C3 28 08                                jr      z,.DYPositive       ;
 232++E8C5              .DYNegative:            SetDecrement .UpdateY0Operation
 232++E8C5 3E 1B       >                        ld      a,OPCODE_DecDE
 232++E8C7 32 A8 E9    >                        ld      (.UpdateY0Operation),a
 233++E8CA C3 AB E8                             jp      .DoneCalcDx         ;
 234++E8CD              .DYPositive:            NegHL                       ;
 234++E8CD AF          >                    xor a
 234++E8CE 95          >                    sub l
 234++E8CF 6F          >                    ld l,a
 234++E8D0 9F          >                    sbc a,a
 234++E8D1 94          >                    sub h
 234++E8D2 67          >                    ld h,a
 235++E8D3                                      SetIncrement .UpdateY0Operation
 235++E8D3 3E 13       >                        ld      a,OPCODE_IncDE
 235++E8D5 32 A8 E9    >                        ld      (.UpdateY0Operation),a
 236++E8D8 22 78 E7     .DoneCalcDy:            ld      (l2_DY),hl
 237++E8DB ED 5B 6E E7                          ld      de,(l2_Y0)          ; fetch in X0
 238++E8DF ED 4B 72 E7                          ld      bc,(l2_Y1)          ; now hl = DY, DE=Y0, BC = Y1
 239++E8E3              ; ---   error = dx + dy >> at this point hl' = DX, DE'=X0, BC' = X1 and hl = DY, DE=Y0, BC = Y1
 240++E8E3 E5 FD E1     .CalcError:             ld      iy,hl               ; fetch DY into IY
 241++E8E6 D9                                   exx                         ; ++now looking at DX data set and DY in alternate
 242++E8E7 EB                                   ex      de,hl               ; quickly flip over de and to support add instruction
 243++E8E8 FD 19                                add     iy,de               ; we have set up IY as L2_Error
 244++E8EA EB                                   ex      de,hl
 245++E8EB FD 22 7A E7                          ld      (l2_Error),iy
 246++E8EF              ; --- While True        >> at this point we are looing at DX and need to consider state at iteration loop
 247++E8EF D9           .CalcLoop:              exx                         ; ++now looking at DY data set and DX in alternate
 248++E8F0                                      ;ld      hl,(l2_X0)         ; get X0 and Y0
 249++E8F0              ; --- PLOT X0, Y0       >> now looking at DY data set and DX in alternate
 250++E8F0              .CheckYRange:           ;ld      de,(l2_Y0)
 251++E8F0 7A                                   ld      a,d                 ; if Y0 > 127
 252++E8F1 A7                                   and     a                   ; or Y0 is negative
 253++E8F2 20 35                                jr      nz,.YOutOfRange     ; then we can skip the plot
 254++E8F4 7B                                   ld      a,e                 ;
 255++E8F5 E6 80                                and     $80                 ;
 256++E8F7 20 30                                jr      nz,.YOutOfRange     ;
 257++E8F9 D9           .CheckXRange:           exx                         ; ++now looking at DX data set and DY in alternate
 258++E8FA 7A                                   ld      a,d                 ; if X0 is negative
 259++E8FB A7                                   and     a
 260++E8FC 28 0E                                jr      z,.XOKToPlot
 261++E8FE E6 80                                and     $80
 262++E900 28 05                                jr      z,.NotXNegative
 263++E902 3E 00        .XNegative:             ld      a,0                 ; if X0 <0 > 255 then clamp it
 264++E904 C3 0D E9                             jp      .ClipXDone          ;
 265++E907 3E FF        .NotXNegative:          ld      a,255               ;
 266++E909 C3 0D E9                             jp      .ClipXDone          ;
 267++E90C 7B           .XOKToPlot:             ld      a,e                 ; no clip therefore we can just use X0 as is
 268++E90D D9           .ClipXDone:             exx                         ; ++now looking at DY data set and DX in alternate
 269++E90E DD 21 4B E5  .TargetArrayAddr:       ld      ix,l2targetArray1   ; later this will be self modifying
 270++E912 08                                   ex      af,af'
 271++E913 7B                                   ld      a,e
 272++E914 32 1F E9                             ld      (.TargetRead+2),a   ; Write Y0 offset to IX offset
 273++E917 32 27 E9                             ld      (.TargetWrite+2),a  ; Write Y0 offset to IX offset
 274++E91A 08                                   ex      af,af'
 275++E91B C5                                   push    bc
 276++E91C 47                                   ld      b,a
 277++E91D DD 7E 00     .TargetRead:            ld      a,(IX+0)
 278++E920 B8                                   cp      b
 279++E921 DA 28 E9     .TargetJump:            jp      c,.SkipWrite
 280++E924 78                                   ld      a,b
 281++E925 DD 77 00     .TargetWrite:           ld      (IX+0),a            ; directly updates l2targetArray1
 282++E928 C1           .SkipWrite:             pop     bc
 283++E929              ; --- if x0 == x1 && y0 == y1 break
 284++E929              .YOutOfRange: ; At this point we have either plotted or its outside array range
 285++E929 D9                                   exx                         ; ++now looking at DX data set and DY in alternate
 286++E92A              ;                        ld      bc,(l2_X1)
 287++E92A              .CheckEndXY:            cpDEEquBC .CheckEndXYOK     ; de will equal X0 still by here
 287++E92A 7A          >                        ld      a,d
 287++E92B B8          >                        cp      b
 287++E92C C2 34 E9    >                        jp      nz, .CheckEndXYOK
 287++E92F 7B          >                        ld      a,e
 287++E930 B9          >                        cp      c
 287++E931             >.NoTheSame:
 288++E931 C2 3E E9                             jp      nz,.x0x1Differ
 289++E934 D9           .CheckEndXYOK:          exx                         ; ++ in this branch in this branchnow looking at DY data set and DX in alternate
 290++E935              ;                        ld      bc,(l2_Y1)
 291++E935                                      cpDEEquBC  .x0x1Differ      ; de will equal Y0 still by here
 291++E935 7A          >                        ld      a,d
 291++E936 B8          >                        cp      b
 291++E937 C2 3E E9    >                        jp      nz, .x0x1Differ
 291++E93A 7B          >                        ld      a,e
 291++E93B B9          >                        cp      c
 291++E93C             >.NoTheSame:
 292++E93C D9                                   exx                         ; ++ in this branch now looking at DX data set and DY in alternate
 293++E93D C8                                   ret     z                   ; if they are both the same we are done
 294++E93E              .x0x1Differ:                                        ; by this point we could be looking at DX on all branches
 295++E93E              ; --- e2 = 2 * error
 296++E93E D9           .SetError2:             exx                         ; ++now looking at DY data set and DX in alternate
 297++E93F E5 D5                                push    hl,,de              ; save HL
 298++E941 EB                                   ex      de,hl               ; de = DY; could futher optimise to check DY>E2 and reduce instruction count
 299++E942 FD E5 E1                             ld      hl,iy;(l2_Error)       ; e2 = 2 * error
 300++E945 29                                   add     hl,hl               ; .
 301++E946 22 7C E7                             ld      (l2_E2),hl          ; .
 302++E949                                      ; before here we are looking at DY
 303++E949              ; --- if e2 >= dy
 304++E949 CD E4 84     .CheckE2gteDY:          call    compare16HLDE       ; .
 305++E94C D1 E1                                pop     hl,,de              ; before jumps get HL back
 306++E94E EA 57 E9                             jp      pe, .E2DyParitySet  ; Jump looking at DY
 307++E951 FA 73 E9                             jp      m,  .E2ltDY         ; Jump looking at DY to get here overflow clear, so if m is set then HL<DE
 308++E954 C3 5A E9                             jp      .E2gteDY            ; Jump looking at DY
 309++E957              .E2DyParitySet:         ; entering here looking at DY
 310++E957 F2 73 E9                             jp      p,  .E2ltDY         ; Jump looking at DY if pe is set, then if sign is clear HL<DE
 311++E95A              ; --- if x0 == x1 break
 312++E95A D9           .E2gteDY:               exx                         ; ++ in this branch now looking at DX data set and DY in alternate
 313++E95B                                      cpDEEquBC .ErrorUpdateDY    ;      if x0 == x1 break
 313++E95B 7A          >                        ld      a,d
 313++E95C B8          >                        cp      b
 313++E95D C2 63 E9    >                        jp      nz, .ErrorUpdateDY
 313++E960 7B          >                        ld      a,e
 313++E961 B9          >                        cp      c
 313++E962             >.NoTheSame:
 314++E962 C8                                   ret     z                   ;      .
 315++E963              ; --- error = error + dy
 316++E963 D9           .ErrorUpdateDY:         exx                         ; if we get here we are looking at DY data set and DX in alternate
 317++E964 E5 D5                                push    hl,,de              ; save HL
 318++E966 EB                                   ex      de,hl               ; de = DY
 319++E967 FD E5 E1                             ld      hl,iy;(l2_Error)       ;      error = error + dy
 320++E96A 19                                   add     hl,de               ;      .
 321++E96B E5 FD E1                             ld      iy,hl;(l2_Error),hl       ;      .
 322++E96E D1 E1                                pop     hl,,de
 323++E970              ; --- x0 = x0 + sx
 324++E970 D9           .UpdateX0:              exx                         ; now back looking at DX data set and DY in alternate
 325++E971 00           .UpdateX0Operation:     nop                         ;      x0 = x0 +/- sx
 326++E972 D9                                   exx                         ; correction on this brach so we are looking at DY
 327++E973              .E2ltDY:                ; entering here, looking at DY in all branches
 328++E973              ; --- if e2 <= dx
 329++E973 D9           .CheckE2lteDX:          exx                         ; we want to look at DX
 330++E974 E5 D5                                push    hl,,de
 331++E976 EB                                   ex      de,hl               ; de = l2_DX
 332++E977 2A 7C E7                             ld      hl,(l2_E2)          ; if e2 <= dx
 333++E97A              ;                        ld      de,(l2_DX)          ; as we can't do skip on e2>dx
 334++E97A CD E4 84                             call    compare16HLDE       ; we will jump based on e2 <= dx
 335++E97D D1 E1                                pop     hl,,de              ; recover saved HL DE
 336++E97F CA 91 E9                             jp      z, .E2lteDX         ; Jump looking at DX
 337++E982 EA 8B E9                             jp      pe, .E2DxParitySet  ; Jump looking at DX
 338++E985 FA 91 E9                             jp      m,  .E2lteDX        ; Jump looking at DX : to get here overflow clear, so if m is set then HL<DE
 339++E988 C3 AA E9                             jp      .E2gteDx            ; Jump looking at DX
 340++E98B F2 91 E9     .E2DxParitySet:         jp      p,  .E2lteDX        ; Jump looking at DX
 341++E98E C3 AA E9                             jp      .E2gteDx            ; Jump looking at DX
 342++E991              ; ---  if y0 == y1 break
 343++E991              .E2lteDX:               ; Entry looking at DX
 344++E991 D9                                   exx                         ;      in branch looking at DY
 345++E992                                      cpDEEquBC .ErrorUpdateDX    ;      .
 345++E992 7A          >                        ld      a,d
 345++E993 B8          >                        cp      b
 345++E994 C2 9B E9    >                        jp      nz, .ErrorUpdateDX
 345++E997 7B          >                        ld      a,e
 345++E998 B9          >                        cp      c
 345++E999             >.NoTheSame:
 346++E999 D9                                   exx                         ;      in branch looking at DX
 347++E99A C8                                   ret     z                   ;      .
 348++E99B              ; --- error = error + dx
 349++E99B              .ErrorUpdateDX:         ; at this point will be looking at DX
 350++E99B E5 D5                                push    hl,,de
 351++E99D EB                                   ex      de,hl               ;      de = DY
 352++E99E FD E5 E1                             ld      hl,iy;(l2_Error)       ;      error = error + dx
 353++E9A1 19                                   add     hl,de               ;      .
 354++E9A2 E5 FD E1                             ld      iy,hl;(l2_Error),hl       ;      .
 355++E9A5 D1 E1                                pop     hl,,de
 356++E9A7              ; --- y0 = y0 + sy
 357++E9A7 D9           .UpdateY0:              exx                         ;      in this branch we are looking at DY
 358++E9A8 00           .UpdateY0Operation:     nop                         ;      y0 = y0 + sy
 359++E9A9 D9                                   exx                         ;      in this branch we are looking at
 360++E9AA              ; --- Loop
 361++E9AA              .E2gteDx:               ; at this point will be looking at DX again
 362++E9AA C3 EF E8                             jp      .CalcLoop           ; repeat until we have a return
 363++E9AD
# file closed: ././Layer2Graphics/int_bren_save.asm
 137+ E9AD              ;;;l2_X0                   DW 0
 138+ E9AD              ;;;l2_Y0                   DW 0
 139+ E9AD              ;;;l2_X1                   DW 0
 140+ E9AD              ;;;l2_Y1                   DW 0
 141+ E9AD              ;;;l2_DX                   DW 0
 142+ E9AD              ;;;l2_DY                   DW 0
 143+ E9AD              ;;;l2_SX                   DW 0
 144+ E9AD              ;;;l2_SY                   DW 0
 145+ E9AD              ;;;l2_Error                DW 0
 146+ E9AD              ;;;l2_E2                   DW 0
 147+ E9AD              ;;;int_bren_save_Array1:   ld      hl,(l2_X1)          ; if X0 < X1
 148+ E9AD              ;;;                        ld      de,(l2_X0)          ; calculate SX DX
 149+ E9AD              ;;;                        ClearCarryFlag              ;
 150+ E9AD              ;;;                        sbc     hl,de               ;
 151+ E9AD              ;;;                        bit     7,h                 ;
 152+ E9AD              ;;;                        jr      z,.DXPositive       ;
 153+ E9AD              ;;;.DXNegative:            NegHL                       ;
 154+ E9AD              ;;;                        ld      bc,-1               ;
 155+ E9AD              ;;;                        jp      .DoneCalcDx         ;
 156+ E9AD              ;;;.DXPositive:            ld      bc,1                ;
 157+ E9AD              ;;;.DoneCalcDx:            ld      (l2_SX),bc          ;
 158+ E9AD              ;;;                        ld      (l2_DX),hl          ;
 159+ E9AD              ;;;.CalcDY:                ld      hl,(l2_Y1)          ; If Y1 < Y1
 160+ E9AD              ;;;                        ld      de,(l2_Y0)          ; calculate SY DY
 161+ E9AD              ;;;                        ClearCarryFlag              ;
 162+ E9AD              ;;;                        sbc     hl,de               ;
 163+ E9AD              ;;;                        bit     7,h                 ;
 164+ E9AD              ;;;                        jr      z,.DYPositive       ;
 165+ E9AD              ;;;.DYNegative:            ld      bc,-1               ;
 166+ E9AD              ;;;                        jp      .DoneCalcDx         ;
 167+ E9AD              ;;;.DYPositive:            NegHL                       ;
 168+ E9AD              ;;;                        ld      bc,1                ;
 169+ E9AD              ;;;.DoneCalcDy:            ld      (l2_SY),bc          ;
 170+ E9AD              ;;;                        ld      (l2_DY),hl
 171+ E9AD              ;;;.CalcError:             ld      hl,(l2_DX)
 172+ E9AD              ;;;                        ld      de,(l2_DY)
 173+ E9AD              ;;;                        add     hl,de
 174+ E9AD              ;;;                        ld      (l2_Error),hl
 175+ E9AD              ;;;.CalcLoop:              break
 176+ E9AD              ;;;                        ld      hl,(l2_X0)          ; get X0 and Y0
 177+ E9AD              ;;;.CheckYRange:           ld      de,(l2_Y0)
 178+ E9AD              ;;;                        ld      a,d                 ; if Y > 127
 179+ E9AD              ;;;                        and     a                   ; or Y is negative
 180+ E9AD              ;;;                        jr      nz,.YOutOfRange     ; then we can skip the plot
 181+ E9AD              ;;;                        ld      a,e                 ;
 182+ E9AD              ;;;                        and     $80                 ;
 183+ E9AD              ;;;                        jr      nz,.YOutOfRange     ;
 184+ E9AD              ;;;.CheckXRange:           ld      a,h                 ; if X0 is negative
 185+ E9AD              ;;;                        and     a
 186+ E9AD              ;;;                        jr      z,.XOKToPlot
 187+ E9AD              ;;;                        and     $80
 188+ E9AD              ;;;                        jr      z,.NotXNegative
 189+ E9AD              ;;;.XNegative:             ld      a,0
 190+ E9AD              ;;;                        jp      .ClipXDone
 191+ E9AD              ;;;.NotXNegative:          ld      a,255
 192+ E9AD              ;;;                        jp      .ClipXDone
 193+ E9AD              ;;;.XOKToPlot:             ld      a,l                 ; no clip therefore we can just use l
 194+ E9AD              ;;;.ClipXDone:             push    hl
 195+ E9AD              ;;;                        push    af                  ; using the Y coordinate
 196+ E9AD              ;;;                        ld      hl,l2targetArray1   ; plot the X value for this row
 197+ E9AD              ;;;                        ld      a,e
 198+ E9AD              ;;;                        add     hl,a
 199+ E9AD              ;;;                        pop     af
 200+ E9AD              ;;;                        ld      (hl),a
 201+ E9AD              ;;;                        pop     hl
 202+ E9AD              ;;;.YOutOfRange: ; At this point we have either plotted or its outside array range
 203+ E9AD              ;;;                        ld      bc,(l2_X1)
 204+ E9AD              ;;;.CheckEndXY:            cpHLEquBC .CheckEndXYOK     ; hl will equal X0 still by here
 205+ E9AD              ;;;                        jp      nz,.x0x1Differ
 206+ E9AD              ;;;.CheckEndXYOK:          ld      bc,(l2_Y1)
 207+ E9AD              ;;;                        cpDEEquBC  .x0x1Differ      ; de will equal Y0 still by here
 208+ E9AD              ;;;                        ret     z                   ; if they are both the same we are done
 209+ E9AD              ;;;.x0x1Differ:
 210+ E9AD              ;;;.SetError2:             ld      hl,(l2_Error)       ; e2 = 2 * error
 211+ E9AD              ;;;                        add     hl,hl               ; .
 212+ E9AD              ;;;                        ld      (l2_E2),hl          ; .
 213+ E9AD              ;;;.CheckE2gteDY:          ld      de,(l2_DY)          ; if e2 >= dy
 214+ E9AD              ;;;                        call    compare16HLDE       ; .
 215+ E9AD              ;;;                        jp      pe, .E2DyParitySet
 216+ E9AD              ;;;                        jp      m,  .E2ltDY         ; to get here overflow clear, so if m is set then HL<DE
 217+ E9AD              ;;;                        jp      .E2gteDY
 218+ E9AD              ;;;.E2DyParitySet:         jp      p,  .E2ltDY         ; if pe is set, then if sign is clear HL<DE
 219+ E9AD              ;;;.E2gteDY:               ld      hl,(l2_X0)          ;      if x0 == x1 break
 220+ E9AD              ;;;                        ld      de,(l2_X1)          ;      .
 221+ E9AD              ;;;                        cpHLEquDE .ErrorUpdateDY    ;      .
 222+ E9AD              ;;;                        ret     z                   ;      .
 223+ E9AD              ;;;.ErrorUpdateDY:         ld      hl,(l2_Error)       ;      error = error + dy
 224+ E9AD              ;;;                        ld      de,(l2_DY)          ;      .
 225+ E9AD              ;;;                        add     hl,de               ;      .
 226+ E9AD              ;;;                        ld      (l2_Error),hl       ;      .
 227+ E9AD              ;;;.UpdateX0:              ld      hl,(l2_X0)          ;      x0 = x0 + sx
 228+ E9AD              ;;;                        ld      bc,(l2_SX)          ;      .
 229+ E9AD              ;;;                        add     hl,bc               ;      .
 230+ E9AD              ;;;                        ld      (l2_X0),hl          ;      .
 231+ E9AD              ;;;.E2ltDY:
 232+ E9AD              ;;;.CheckE2lteDX:          ld      hl,(l2_E2)          ; if e2 <= dx
 233+ E9AD              ;;;                        ld      de,(l2_DX)          ; as we can't do skip on e2>dx
 234+ E9AD              ;;;                        call    compare16HLDE       ; we will jump based on e2 <= dx
 235+ E9AD              ;;;                        jp      z, .E2lteDX
 236+ E9AD              ;;;                        jp      pe, .E2DxParitySet
 237+ E9AD              ;;;                        jp      m,  .E2lteDX         ; to get here overflow clear, so if m is set then HL<DE
 238+ E9AD              ;;;                        jp      .E2gteDx
 239+ E9AD              ;;;.E2DxParitySet:         jp      p,  .E2lteDX
 240+ E9AD              ;;;                        jp      .E2gteDx
 241+ E9AD              ;;;.E2lteDX:               ld      hl,(l2_Y0)          ;      .
 242+ E9AD              ;;;                        ld      de,(l2_Y1)          ;      .
 243+ E9AD              ;;;                        cpHLEquDE .ErrorUdpateDX    ;      .
 244+ E9AD              ;;;                        ret     z                   ;      .
 245+ E9AD              ;;;.ErrorUdpateDX:         ld      hl,(l2_Error)       ;      error = error + dx
 246+ E9AD              ;;;                        ld      de,(l2_DX)          ;      .
 247+ E9AD              ;;;                        add     hl,de               ;      .
 248+ E9AD              ;;;                        ld      (l2_Error),hl       ;      .
 249+ E9AD              ;;;.UpdateY0:              ld      hl,(l2_Y0)          ;      x0 = x0 + sx
 250+ E9AD              ;;;                        ld      bc,(l2_SY)          ;      .
 251+ E9AD              ;;;                        add     hl,bc              ;      .
 252+ E9AD              ;;;                        ld      (l2_Y0),hl         ;      .
 253+ E9AD              ;;;.E2gteDx:               jp      .CalcLoop           ; repeat until we have a return
 254+ E9AD
 255+ E9AD
 256+ E9AD              ;;;;;;;; for this it myst always be sorted Y0 -> Y2
 257+ E9AD              ;;;;;;;;; note we ca't use this to do x? as it will clip inherently
 258+ E9AD              ;;;;;;;l2_save_diagnonal_signed_1:
 259+ E9AD              ;;;;;;;                        ld		hl,0                            ;
 260+ E9AD              ;;;;;;;                        ld		(l2deltaX),hl                   ;
 261+ E9AD              ;;;;;;;                        ld		(l2deltaY),hl
 262+ E9AD              ;;;;;;;.CheckYOnScreen:        ld      de,(l2_commonTopY)
 263+ E9AD              ;;;;;;;                        ld      hl,(l2_bottomY)
 264+ E9AD              ;;;;;;;                        ld      a,d
 265+ E9AD              ;;;;;;;                        and     h
 266+ E9AD              ;;;;;;;                        and     $80
 267+ E9AD              ;;;;;;;                        jr      nz,.OffScreen
 268+ E9AD              ;;;;;;;;...dy = y1 - y0
 269+ E9AD              ;;;;;;;.CalcDeltaY:            ClearCarryFlag
 270+ E9AD              ;;;;;;;                        sbc     hl,de                           ; now delta is signed, if its negative then something bad as gone wrong
 271+ E9AD              ;;;;;;;                        ld      a,h
 272+ E9AD              ;;;;;;;                        and     $80
 273+ E9AD              ;;;;;;;                        jr      nz,.OffScreen
 274+ E9AD              ;;;;;;;                        ld      (l2deltaY),hl                   ; Delta signed
 275+ E9AD              ;;;;;;;CheckXOnScreen:         ld      de,(l2_leftX)
 276+ E9AD              ;;;;;;;                        ld      hl,(l2_rightX)
 277+ E9AD              ;;;;;;;                        ld      a,d
 278+ E9AD              ;;;;;;;                        and     h
 279+ E9AD              ;;;;;;;                        and     $80
 280+ E9AD              ;;;;;;;                        jr      nz,.OffScreen
 281+ E9AD              ;;;;;;;                        ClearCarryFlag
 282+ E9AD              ;;;;;;;;...dx = x1 - x0
 283+ E9AD              ;;;;;;;.CalcDeltaX:            sbc     hl,de                           ; now delta is signed, could be negative
 284+ E9AD              ;;;;;;;                        ld      (l2deltaX),hl                   ; Delta signed
 285+ E9AD              ;;;;;;;                        ld      a,h
 286+ E9AD              ;;;;;;;                        and     $80
 287+ E9AD              ;;;;;;;                        jr      nz,.LeftToRight
 288+ E9AD              ;;;;;;;.RightToLeft:           set up instrnctin
 289+ E9AD              ;;;;;;;.LeftToRight:           set up instrnctin
 290+ E9AD              ;;;;;;;.setErr:									                    ;  LD H  := (D'-E')/2    round up if +ve or down if -ve
 291+ E9AD              ;;;;;;;,FracDYltDX:            ld		hl,(l2deltaY)					; Fraction = dY - dX
 292+ E9AD              ;;;;;;;                        ld		de,(l2deltaX)
 293+ E9AD              ;;;;;;;                        ClearCarryFlag
 294+ E9AD              ;;;;;;;                        sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
 295+ E9AD              ;;;;;;;                        ex		de,hl
 296+ E9AD              ;;;;;;;                        ld		iyh,d							; we will use IY reg for fractions
 297+ E9AD              ;;;;;;;                        ld		iyl,e
 298+ E9AD              ;;;;;;;                        jp		p,.fracIsPositive
 299+ E9AD              ;;;;;;;
 300+ E9AD              ;;;;;;;plotLine(x0, y0, x1, y1)
 301+ E9AD              ;;;;;;;    dx = x1 - x0
 302+ E9AD              ;;;;;;;    dy = y1 - y0
 303+ E9AD              ;;;;;;;    D = 2*dy - dx
 304+ E9AD              ;;;;;;;    y = y0
 305+ E9AD              ;;;;;;;
 306+ E9AD              ;;;;;;;    for x from x0 to x1
 307+ E9AD              ;;;;;;;        plot(x,y)
 308+ E9AD              ;;;;;;;        if D > 0
 309+ E9AD              ;;;;;;;            y = y + 1
 310+ E9AD              ;;;;;;;            D = D - 2*dx
 311+ E9AD              ;;;;;;;        end if
 312+ E9AD              ;;;;;;;        D = D + 2*dy
 313+ E9AD              ;;;;;;;
 314+ E9AD
 315+ E9AD
 316+ E9AD
 317+ E9AD              ;;;;;.fracIsNegative:        NegIY
 318+ E9AD              ;;;;;                        ShiftIYRight1
 319+ E9AD              ;;;;;                        NegIY
 320+ E9AD              ;;;;;                        jp		.SkipCalcInc					; so we have a negative frac
 321+ E9AD              ;;;;;.fracIsPositive:        ShiftIYRight1
 322+ E9AD              ;;;;;.SkipCalcInc:		                        			    	; As we loop, bc = to plot current XY
 323+ E9AD              ;;;;;.preTargetArray:	    ld		hl,l2targetArray1               ; Assuming row 0
 324+ E9AD              ;;;;;l2S_setTarget:	        ld		(l2targetPtr),hl
 325+ E9AD              ;;;;;                                                                ; set DE to current row
 326+ E9AD              ;;;;;.S_Loop:			    ld		hl,(l2targetPtr)				; Insert into respective array
 327+ E9AD              ;;;;;                                                                ; calculate current row
 328+ E9AD              ;;;;;                                                                ; if current row >= 0
 329+ E9AD              ;;;;;                                                                ; write current X value in DE to (hl)
 330+ E9AD              ;;;;;                        ld		a,b
 331+ E9AD              ;;;;;                        add		hl,a
 332+ E9AD              ;;;;;                        ld		(hl),c
 333+ E9AD              ;;;;;l2S_CheckIfEnd:	        ld		a,ixh
 334+ E9AD              ;;;;;                        JumpIfAGTENusng	  b,l2S_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
 335+ E9AD              ;;;;;                        jp		l2S_Continue
 336+ E9AD              ;;;;;l2S_CheckXPos:          ld      a,(l2S_adjustCol)
 337+ E9AD              ;;;;;                        cp      l2inccstep; if we self modified to inc the we can do a cp e else its cp c
 338+ E9AD              ;;;;;                        jr      z,.IncCP
 339+ E9AD              ;;;;;.DecCP:                 ld      a,c
 340+ E9AD              ;;;;;                        ReturnIfALTNusng ixl
 341+ E9AD              ;;;;;                        ReturnIfAEqNusng ixl
 342+ E9AD              ;;;;;                        jp      l2S_Continue
 343+ E9AD              ;;;;;.IncCP:                 ld		a,c
 344+ E9AD              ;;;;;                        ReturnIfAGTENusng ixl					; if X1 has reached or exceeded X2 then we are done
 345+ E9AD              ;;;;;l2S_Continue:
 346+ E9AD              ;;;;;l2S_HNegative:			ld		a,iyh
 347+ E9AD              ;;;;;                        bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
 348+ E9AD              ;;;;;                        jr		z,l2S_ErrNotNegative			;
 349+ E9AD              ;;;;;l2S_ErrNegative:		ld		a,(l2deltaY)					; if its a negative error update X
 350+ E9AD              ;;;;;                        ld		d,0
 351+ E9AD              ;;;;;                        ld		e,a
 352+ E9AD              ;;;;;                        add		iy,de							; add deltaY(unsinged) to l2fraction
 353+ E9AD              ;;;;;l2S_adjustCol:          nop										; this is our inc/dec of X
 354+ E9AD              ;;;;;                        jr		l2S_Loop							; repeat loop
 355+ E9AD              ;;;;;l2S_ErrNotNegative:     ld		a,iyh
 356+ E9AD              ;;;;;                        or		iyl
 357+ E9AD              ;;;;;                        JumpIfAIsZero l2S_ErrZero					; if there is no error then goto zeroerror
 358+ E9AD              ;;;;;l2S_ErrPositive:        ld      de,iy;  lddeiy								; if its a positive error then we update Y
 359+ E9AD              ;;;;;                        ex		de,hl
 360+ E9AD              ;;;;;                        ld		d,0
 361+ E9AD              ;;;;;                        ld		a,(l2deltaX)
 362+ E9AD              ;;;;;                        ld		e,a
 363+ E9AD              ;;;;;                        ClearCarryFlag
 364+ E9AD              ;;;;;                        sbc		hl,de
 365+ E9AD              ;;;;;                        ex		de,hl
 366+ E9AD              ;;;;;                        ld      iy,de;ldiyde
 367+ E9AD              ;;;;;l2S_adjustRow:          inc		b								; move Y down by one
 368+ E9AD              ;;;;;                        jr		l2S_Loop
 369+ E9AD              ;;;;;l2S_ErrZero:            ld		hl,(l2deltaX)
 370+ E9AD              ;;;;;                        ex		de,hl
 371+ E9AD              ;;;;;                        ld		hl,(l2deltaY)
 372+ E9AD              ;;;;;                        ClearCarryFlag
 373+ E9AD              ;;;;;                        sbc		hl,de
 374+ E9AD              ;;;;;                        ex		de,hl
 375+ E9AD              ;;;;;                        ld      iy,de; ldiyde
 376+ E9AD              ;;;;;l2S_adjustCol2:         nop										; update X and Y
 377+ E9AD              ;;;;;                        inc		b
 378+ E9AD              ;;;;;                        jr		l2S_Loop
 379+ E9AD              ;;;;;
 380+ E9AD              ;;;;;.OffScreen:             SetCarryFlag
 381+ E9AD              ;;;;;                        ret
 382+ E9AD              ;;;;;
 383+ E9AD              ;;;;;
 384+ E9AD
 385+ E9AD
 386+ E9AD
 387+ E9AD FE 01        l2_draw_diagonal_save:  cp		1
 388+ E9AF 28 06                                jr		z,l2S_ItsArray1
 389+ E9B1 21 4B E6                             ld		hl,l2targetArray2
 390+ E9B4 C3 BA E9                             jp		l2S_setTarget
 391+ E9B7 21 4B E5     l2S_ItsArray1:	        ld		hl,l2targetArray1
 392+ E9BA 22 49 E5     l2S_setTarget:	        ld		(l2targetPtr),hl
 393+ E9BD              ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
 394+ E9BD 32 43 E5                             ld		(l2linecolor),a					;save colour for later
 395+ E9C0 21 00 00                             ld		hl,0                            ;
 396+ E9C3 22 3B E5                             ld		(l2deltaX),hl                   ;
 397+ E9C6 22 39 E5                             ld		(l2deltaY),hl                   ; initlaise deltas as we will only be loading 8 bit in there but workign in 16 bit later
 398+ E9C9 78           l2S_preSort:            ld		a,b								;
 399+ E9CA                                      JumpIfALTNusng	d,l2S_noYSort			; we must have Y1 < Y2 (if eqyal then verical line picked up earlier
 399+ E9CA BA          >                        cp      d
 399+ E9CB DA D3 E9    >                        jp		c, l2S_noYSort
 400+ E9CE              l2S_SortBasedOnY:	    ldhlbc									;
 400+ E9CE 60          >                        ld		h,b
 400+ E9CF 69          >                        ld		l,c
 401+ E9D0 EB                                   ex		de,hl                           ;
 402+ E9D1                                      ldbchl									; swap over bc and de using hl as an intermediate
 402+ E9D1 44          >                        ld		b,h
 402+ E9D2 4D          >                        ld		c,l
 403+ E9D3 DD 62        l2S_noYSort:		    ld		ixh,d							; ixh now holds target Y coord post sorting
 404+ E9D5 DD 6B                                ld		ixl,e							; ixl now holds target X coord post sorting
 405+ E9D7 79           l2S_setXLen:            ld		a,c                             ;
 406+ E9D8                                      JumpIfALTNusng e,l2S_PosXLen			; if x1 < x2 then we have a positive increment
 406+ E9D8 BB          >                        cp      e
 406+ E9D9 DA E5 E9    >                        jp		c, l2S_PosXLen
 407+ E9DC 79           l2S_NegXLen:            ld		a,c                             ;
 408+ E9DD 93                                   sub     e                               ;
 409+ E9DE 32 3B E5                             ld		(l2deltaX),a					; As x1 > x2 we do deltaX = X1 - X2
 410+ E9E1 3E 0D                                ld		a,l2deccstep					; and set the value for inc dec self modifying to Dec
 411+ E9E3 18 07                                jr		l2S_XINCDEC
 412+ E9E5              ; we set comparison
 413+ E9E5 7B           l2S_PosXLen:	        ld		a,e                             ;
 414+ E9E6 91                                   sub		c                               ;
 415+ E9E7 32 3B E5                             ld 		(l2deltaX),a                    ; As x1 < x2 we do deltaX = X2 - X1
 416+ E9EA 3E 0C                                ld		a,l2inccstep                    ; and set the value for inc dec self modifying to Inc
 417+ E9EC              ; also need to fix the comparison, if its +x then compare with
 418+ E9EC 32 69 EA     l2S_XINCDEC:	        ld		(l2S_adjustCol),a				;
 419+ E9EF 32 99 EA                             ld		(l2S_adjustCol2),a				; update self modifying code for X update with inc or dec from above
 420+ E9F2 7A           l2S_setYLen:            ld		a,d							 	; presorted on Y so it is now always positive
 421+ E9F3 90                                   sub		b
 422+ E9F4 32 39 E5                             ld 		(l2deltaY),a					; DeltaY = Y2 - Y1
 423+ E9F7              l2S_setErr:									;  LD H  := (D'-E')/2    round up if +ve or down if -ve
 424+ E9F7 2A 39 E5     ldS_FracDYltDX:         ld		hl,(l2deltaY)					; Fraction = dY - dX
 425+ E9FA ED 5B 3B E5                          ld		de,(l2deltaX)
 426+ E9FE                                      ClearCarryFlag
 426+ E9FE B7          >                        or a
 427+ E9FF ED 52                                sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
 428+ EA01 EB                                   ex		de,hl
 429+ EA02 FD 62                                ld		iyh,d							; we will use IY reg for fractions
 430+ EA04 FD 6B                                ld		iyl,e
 431+ EA06 F2 2B EA                             jp		p,l2S_fracIsPositive
 432+ EA09              l2S_fracIsNegative:     NegIY
 432+ EA09 AF          >                    xor a
 432+ EA0A FD 95       >                    sub iyl
 432+ EA0C FD 6F       >                    ld iyl,a
 432+ EA0E 9F          >                    sbc a,a
 432+ EA0F FD 94       >                    sub iyh
 432+ EA11 FD 67       >                    ld iyh,a
 433+ EA13                                      ShiftIYRight1
 433+ EA13 FD 7C       >			   ld 	a,iyh
 433+ EA15 CB 3F       >			   srl 	a
 433+ EA17 FD 67       >			   ld	iyh,a
 433+ EA19 FD 7D       >			   ld 	a,iyl
 433+ EA1B 1F          >			   rra
 433+ EA1C FD 6F       >			   ld	iyl,a
 434+ EA1E                                      NegIY
 434+ EA1E AF          >                    xor a
 434+ EA1F FD 95       >                    sub iyl
 434+ EA21 FD 6F       >                    ld iyl,a
 434+ EA23 9F          >                    sbc a,a
 434+ EA24 FD 94       >                    sub iyh
 434+ EA26 FD 67       >                    ld iyh,a
 435+ EA28 C3 36 EA                             jp		l2S_SkipCalcInc					; so we have a negative frac
 436+ EA2B              l2S_fracIsPositive:     ShiftIYRight1
 436+ EA2B FD 7C       >			   ld 	a,iyh
 436+ EA2D CB 3F       >			   srl 	a
 436+ EA2F FD 67       >			   ld	iyh,a
 436+ EA31 FD 7D       >			   ld 	a,iyl
 436+ EA33 1F          >			   rra
 436+ EA34 FD 6F       >			   ld	iyl,a
 437+ EA36              l2S_SkipCalcInc:		                        				; As we loop, bc = to plot current XY
 438+ EA36 2A 49 E5     l2S_Loop:			    ld		hl,(l2targetPtr)				; Insert into respective array
 439+ EA39 78                                   ld		a,b
 440+ EA3A ED 31                                add		hl,a
 441+ EA3C 71                                   ld		(hl),c
 442+ EA3D DD 7C        l2S_CheckIfEnd:	        ld		a,ixh
 443+ EA3F                                      JumpIfAGTENusng	  b,l2S_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
 443+ EA3F B8          >                        cp     b
 443+ EA40 D2 46 EA    >                        jp		nc,l2S_CheckXPos
 444+ EA43 C3 5B EA                             jp		l2S_Continue
 445+ EA46 3A 69 EA     l2S_CheckXPos:          ld      a,(l2S_adjustCol)
 446+ EA49 FE 0C                                cp      l2inccstep; if we self modified to inc the we can do a cp e else its cp c
 447+ EA4B 28 0A                                jr      z,.IncCP
 448+ EA4D 79           .DecCP:                 ld      a,c
 449+ EA4E                                      ReturnIfALTNusng ixl
 449+ EA4E DD BD       >                        cp    ixl
 449+ EA50 D8          >                        ret	 c
 450+ EA51                                      ReturnIfAEqNusng ixl
 450+ EA51 DD BD       >                        cp      ixl
 450+ EA53 C8          >                        ret     z
 451+ EA54 C3 5B EA                             jp      l2S_Continue
 452+ EA57 79           .IncCP:                 ld		a,c
 453+ EA58                                      ReturnIfAGTENusng ixl					; if X1 has reached or exceeded X2 then we are done
 453+ EA58 DD BD       >                        cp    ixl
 453+ EA5A D0          >                        ret	 nc
 454+ EA5B              l2S_Continue:
 455+ EA5B FD 7C        l2S_HNegative:			ld		a,iyh
 456+ EA5D CB 7F                                bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
 457+ EA5F 28 0B                                jr		z,l2S_ErrNotNegative			;
 458+ EA61 3A 39 E5     l2S_ErrNegative:		ld		a,(l2deltaY)					; if its a negative error update X
 459+ EA64 16 00                                ld		d,0
 460+ EA66 5F                                   ld		e,a
 461+ EA67 FD 19                                add		iy,de							; add deltaY(unsinged) to l2fraction
 462+ EA69 00           l2S_adjustCol:          nop										; this is our inc/dec of X
 463+ EA6A 18 CA                                jr		l2S_Loop							; repeat loop
 464+ EA6C FD 7C        l2S_ErrNotNegative:     ld		a,iyh
 465+ EA6E FD B5                                or		iyl
 466+ EA70                                      JumpIfAIsZero l2S_ErrZero					; if there is no error then goto zeroerror
 466+ EA70 A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 466+ EA71 CA 8A EA    >                        jp	    z, l2S_ErrZero
 467+ EA74 FD 54 FD 5D  l2S_ErrPositive:        ld      de,iy;  lddeiy								; if its a positive error then we update Y
 468+ EA78 EB                                   ex		de,hl
 469+ EA79 16 00                                ld		d,0
 470+ EA7B 3A 3B E5                             ld		a,(l2deltaX)
 471+ EA7E 5F                                   ld		e,a
 472+ EA7F                                      ClearCarryFlag
 472+ EA7F B7          >                        or a
 473+ EA80 ED 52                                sbc		hl,de
 474+ EA82 EB                                   ex		de,hl
 475+ EA83 FD 62 FD 6B                          ld      iy,de;ldiyde
 476+ EA87 04           l2S_adjustRow:          inc		b								; move Y down by one
 477+ EA88 18 AC                                jr		l2S_Loop
 478+ EA8A 2A 3B E5     l2S_ErrZero:            ld		hl,(l2deltaX)
 479+ EA8D EB                                   ex		de,hl
 480+ EA8E 2A 39 E5                             ld		hl,(l2deltaY)
 481+ EA91                                      ClearCarryFlag
 481+ EA91 B7          >                        or a
 482+ EA92 ED 52                                sbc		hl,de
 483+ EA94 EB                                   ex		de,hl
 484+ EA95 FD 62 FD 6B                          ld      iy,de; ldiyde
 485+ EA99 00           l2S_adjustCol2:         nop										; update X and Y
 486+ EA9A 04                                   inc		b
 487+ EA9B 18 99                                jr		l2S_Loop
 488+ EA9D
 489+ EA9D              ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
 490+ EA9D 32 43 E5     l2_draw_diagonal:       ld		(l2linecolor),a					;save colour for later
 491+ EAA0 21 00 00                             ld		hl,0                            ;
 492+ EAA3 22 3B E5                             ld		(l2deltaX),hl                   ;
 493+ EAA6 22 39 E5                             ld		(l2deltaY),hl                   ; initlaise deltas as we will only be loading 8 bit in there but workign in 16 bit later
 494+ EAA9 78           l2D_preSort:            ld		a,b								;
 495+ EAAA                                      JumpIfALTNusng	d,l2D_noYSort			; we must have Y1 < Y2 (if equal then verical line picked up earlier
 495+ EAAA BA          >                        cp      d
 495+ EAAB DA B3 EA    >                        jp		c, l2D_noYSort
 496+ EAAE              l2D_SortBasedOnY:	    ldhlbc									;
 496+ EAAE 60          >                        ld		h,b
 496+ EAAF 69          >                        ld		l,c
 497+ EAB0 EB                                   ex		de,hl                           ;
 498+ EAB1                                      ldbchl									; swap over bc and de using hl as an intermediate
 498+ EAB1 44          >                        ld		b,h
 498+ EAB2 4D          >                        ld		c,l
 499+ EAB3 DD 62        l2D_noYSort:		    ld		ixh,d							; ixh now holds target Y coord post sorting
 500+ EAB5 DD 6B                                ld		ixl,e							; ixl now holds target X coord post sorting
 501+ EAB7 79           l2D_setXLen:            ld		a,c                             ;
 502+ EAB8                                      JumpIfALTNusng e,l2D_PosXLen			; if x1 < x2 then we have a positive increment
 502+ EAB8 BB          >                        cp      e
 502+ EAB9 DA C5 EA    >                        jp		c, l2D_PosXLen
 503+ EABC 79           l2D_NegXLen:            ld		a,c                             ;
 504+ EABD 93                                   sub     e                               ;
 505+ EABE 32 3B E5                             ld		(l2deltaX),a					; As x1 > x2 we do deltaX = X1 - X2
 506+ EAC1 3E 0D                                ld		a,l2deccstep					; and set the value for inc dec self modifying to Dec
 507+ EAC3 18 07                                jr		l2D_XINCDEC
 508+ EAC5 7B           l2D_PosXLen:	        ld		a,e                             ;
 509+ EAC6 91                                   sub		c                               ;
 510+ EAC7 32 3B E5                             ld 		(l2deltaX),a                    ; As x1 < x2 we do deltaX = X2 - X1
 511+ EACA 3E 0C                                ld		a,l2inccstep                    ; and set the value for inc dec self modifying to Inc
 512+ EACC 32 47 EB     l2D_XINCDEC:	        ld		(l2D_adjustCol),a				;
 513+ EACF 32 77 EB                             ld		(l2D_adjustCol2),a				; update self modifying code for X update with inc or dec from above
 514+ EAD2 7A           l2D_setYLen				ld		a,d							 	; presorted on Y so it is now always positive
 515+ EAD3 90                                   sub		b
 516+ EAD4 32 39 E5                             ld 		(l2deltaY),a					; DeltaY = Y2 - Y1
 517+ EAD7              l2D_setErr:									;  LD H  := (D'-E')/2    round up if +ve or down if -ve
 518+ EAD7 2A 39 E5     ldD_FracDYltDX:			ld		hl,(l2deltaY)					; Fraction = dY - dX
 519+ EADA ED 5B 3B E5                          ld		de,(l2deltaX)
 520+ EADE                                      ClearCarryFlag
 520+ EADE B7          >                        or a
 521+ EADF ED 52                                sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
 522+ EAE1 EB                                   ex		de,hl
 523+ EAE2 FD 62                                ld		iyh,d							; we will use IY reg for fractions
 524+ EAE4 FD 6B                                ld		iyl,e
 525+ EAE6 F2 0B EB                             jp		p,l2D_fracIsPositive
 526+ EAE9              l2D_fracIsNegative:     NegIY
 526+ EAE9 AF          >                    xor a
 526+ EAEA FD 95       >                    sub iyl
 526+ EAEC FD 6F       >                    ld iyl,a
 526+ EAEE 9F          >                    sbc a,a
 526+ EAEF FD 94       >                    sub iyh
 526+ EAF1 FD 67       >                    ld iyh,a
 527+ EAF3                                      ShiftIYRight1
 527+ EAF3 FD 7C       >			   ld 	a,iyh
 527+ EAF5 CB 3F       >			   srl 	a
 527+ EAF7 FD 67       >			   ld	iyh,a
 527+ EAF9 FD 7D       >			   ld 	a,iyl
 527+ EAFB 1F          >			   rra
 527+ EAFC FD 6F       >			   ld	iyl,a
 528+ EAFE                                      NegIY
 528+ EAFE AF          >                    xor a
 528+ EAFF FD 95       >                    sub iyl
 528+ EB01 FD 6F       >                    ld iyl,a
 528+ EB03 9F          >                    sbc a,a
 528+ EB04 FD 94       >                    sub iyh
 528+ EB06 FD 67       >                    ld iyh,a
 529+ EB08 C3 16 EB                             jp		l2D_SkipCalcInc					; so we have a negative frac
 530+ EB0B              l2D_fracIsPositive:     ShiftIYRight1
 530+ EB0B FD 7C       >			   ld 	a,iyh
 530+ EB0D CB 3F       >			   srl 	a
 530+ EB0F FD 67       >			   ld	iyh,a
 530+ EB11 FD 7D       >			   ld 	a,iyl
 530+ EB13 1F          >			   rra
 530+ EB14 FD 6F       >			   ld	iyl,a
 531+ EB16              l2D_SkipCalcInc:
 532+ EB16 C5 D5        l2D_Loop:				push	bc,,de                 			; l2DeltaY and l2DeltaX are set
 533+ EB18 3A 43 E5                             ld		a,(l2linecolor)     			;
 534+ EB1B                                      l2_plot_macro;call	l2_plot_pixel       			; Plot Pixel
 534+ EB1B 78          >                        ld      a,b
 534+ EB1C             >                        JumpIfAGTENusng 192 ,.NoPlot
 534+ EB1C FE C0       >                        cp     192
 534+ EB1E D2 2A EB    >                        jp		nc,.NoPlot
 534+ EB21 69          >                        ld      l,c
 534+ EB22 CD 68 E0    >                        call    asm_l2_row_bank_select
 534+ EB25 67          >                        ld      h,a
 534+ EB26 3A A7 F1    >                        ld      a,(line_gfx_colour)
 534+ EB29 77          >                        ld      (hl),a
 534+ EB2A             >.NoPlot:
 535+ EB2A D1 C1                                pop     bc,,de
 536+ EB2C DD 7C        l2D_CheckIfEnd:	        ld		a,ixh
 537+ EB2E                                      JumpIfAGTENusng	  b,l2D_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
 537+ EB2E B8          >                        cp     b
 537+ EB2F D2 35 EB    >                        jp		nc,l2D_CheckXPos
 538+ EB32 C3 39 EB                             jp		l2D_Continue
 539+ EB35 79           l2D_CheckXPos:          ld		a,c
 540+ EB36                                      ReturnIfAEqNusng ixl					; if X1 has reached or exceeded X2 then we are done
 540+ EB36 DD BD       >                        cp      ixl
 540+ EB38 C8          >                        ret     z
 541+ EB39              l2D_Continue:
 542+ EB39 FD 7C        l2D_HNegative:			ld		a,iyh
 543+ EB3B CB 7F                                bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
 544+ EB3D 28 0B                                jr		z,l2D_ErrNotNegative			;
 545+ EB3F 3A 39 E5     l2D_ErrNegative:		ld		a,(l2deltaY)
 546+ EB42 16 00                                ld		d,0
 547+ EB44 5F                                   ld		e,a
 548+ EB45 FD 19                                add		iy,de							; add deltaY(unsinged) to l2fraction
 549+ EB47 00           l2D_adjustCol:          nop										; this is our inc/dec of X
 550+ EB48 18 CC                                jr		l2D_Loop							; repeat loop
 551+ EB4A FD 7C        l2D_ErrNotNegative:     ld		a,iyh
 552+ EB4C FD B5                                or		iyl
 553+ EB4E                                      JumpIfAIsZero l2D_ErrZero					; if there is no error then goto zeroerror
 553+ EB4E A7          >                        and     a   ; cp 0 - changed to and a for optimisation but affects other flags
 553+ EB4F CA 68 EB    >                        jp	    z, l2D_ErrZero
 554+ EB52 FD 54 FD 5D  l2D_ErrPositive:		ld      de,iy;lddeiy
 555+ EB56 EB                                   ex		de,hl
 556+ EB57 16 00                                ld		d,0
 557+ EB59 3A 3B E5                             ld		a,(l2deltaX)
 558+ EB5C 5F                                   ld		e,a
 559+ EB5D                                      ClearCarryFlag
 559+ EB5D B7          >                        or a
 560+ EB5E ED 52                                sbc		hl,de
 561+ EB60 EB                                   ex		de,hl
 562+ EB61 FD 62 FD 6B                          ld      iy,de;ldiyde
 563+ EB65 04           l2D_adjustRow:			inc		b
 564+ EB66 18 AE                                jr		l2D_Loop
 565+ EB68 2A 3B E5     l2D_ErrZero:            ld		hl,(l2deltaX)
 566+ EB6B EB                                   ex		de,hl
 567+ EB6C 2A 39 E5                             ld		hl,(l2deltaY)
 568+ EB6F                                      ClearCarryFlag
 568+ EB6F B7          >                        or a
 569+ EB70 ED 52                                sbc		hl,de
 570+ EB72 EB                                   ex		de,hl
 571+ EB73 FD 62 FD 6B                          ld      iy,de;ldiyde
 572+ EB77 00           l2D_adjustCol2:         nop										; update X and Y
 573+ EB78 04                                   inc		b
 574+ EB79 18 9B                                jr		l2D_Loop
 575+ EB7B              ;----------------------------------------------------------------------------------------------------------------------------------
 576+ EB7B
 577+ EB7B
 578+ EB7B
 579+ EB7B
 580+ EB7B              ;Loin:				; BBC version of line draw
 581+ EB7B              ;; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color)"
 582+ EB7B              ;	ld		(l2linecolor),a					; save colour as a reg gets used alot, coudl move this into interrupt flag and disable interrups
 583+ EB7B              ;	ld		ixh,0							; ixh = s
 584+ EB7B              ;	ld		iyh,0							; iyh = swap
 585+ EB7B              ;	ld		l,0								; l will hold delta sign flags
 586+ EB7B              ;LoinCalcDeltaX:
 587+ EB7B              ;	ld		a,e
 588+ EB7B              ;	sub		c								; a = deltaX
 589+ EB7B              ;	JumpIfPositive LoinPosDx
 590+ EB7B              ;LoinNegDx:
 591+ EB7B              ;	neg										; carry flag will indicate deltaX was negative
 592+ EB7B              ;	ld		l,$80							; set bit 7 of l for negative
 593+ EB7B              ;LoinPosDx:
 594+ EB7B              ;	ld		ixl,a							; ixl = varP = deltaX
 595+ EB7B              ;LoinCalcDeltaY:
 596+ EB7B              ;	ld		a,d
 597+ EB7B              ;	sub		b								; a= deltaY
 598+ EB7B              ;	JumpIfPositive LoinPosDy
 599+ EB7B              ;LoinNegDy:
 600+ EB7B              ;	neg
 601+ EB7B              ;	set		6,l								; set bit 6 of l for negative deltaY
 602+ EB7B              ;LoinPosDy:
 603+ EB7B              ;	ld		iyl,a							; iyl = varQ = deltaY
 604+ EB7B              ;	JumpIfAGTENusng ixl, LoinSTPy			; if deltaY >= DeltaX then step along Y
 605+ EB7B              ;LoinSTPx:									; step along X
 606+ EB7B              ;	JumpOnBitClear l,7						; if l flags were clear then X2 < X2
 607+ EB7B              ;LoinSTPxSwapCoords:
 608+ EB7B              ;	dec		iyh								; swap flag now becomes FF
 609+ EB7B              ;	ld		a,l								; save l flags
 610+ EB7B              ;	ex		de,hl							; save de to hl
 611+ EB7B              ;	lddebc									; Point2 = point1
 612+ EB7B              ;	ldbchl									; Point1 = point2 that was saved
 613+ EB7B              ;	ld		l,a								; get back l flags
 614+ EB7B              ;LoinSTPxCorrectOrder:
 615+ EB7B              ;	l2_point_pixel_y_safe					; call plot pixel preseving bc hl
 616+ EB7B              ;	ld		a,iyl							; get delta Y back
 617+ EB7B              ;	ld		iy1,$FE							; roll counter
 618+ EB7B              ;LionSTPxRollQ:
 619+ EB7B              ;	sla		a								; highest bit of delta-Y
 620+ EB7B              ;	jp		c,LoinSTPxSteep
 621+ EB7B              ;	cp		ixl								; compare with DeltaX
 622+ EB7B              ;	jp		cs,LoinSTPxShallow
 623+ EB7B              ;LoinSTPxSteep:								;; LI4
 624+ EB7B              ;	sbc		a,ixl							; deltaYwork -= (deltaX+1)
 625+ EB7B              ;	scf										; force carry flag set
 626+ EB7B              ;LoinSTPxShallow:							;; LI5
 627+ EB7B              ;	rl		iyl								; rotate iyl which started as FE
 628+ EB7B              ;	jp		c,LionSTPxRollQ					; so we are doing a 6 bit loop
 629+ EB7B              ;	inc		ihl								; DeltaX += 1
 630+ EB7B              ;LoinSTPxYDirection:							; change this to self modifying code
 631+ EB7B              ;	ld		a,d
 632+ EB7B              ;	JumpIfAGTEn	b,LionDOWN:
 633+ EB7B              ;	ld		a,iyh							; swap flag
 634+ EB7B              ;	JumpIfANotZero	X1Inc  					; if swap flag was not set then no need to update R
 635+ EB7B              ;LoinSTPxX1Dec:
 636+ EB7B              ;	dec		c								; move left 1 pixel as we sawped
 637+ EB7B              ;LoinSTPxXCounter:							;; LIL2
 638+ EB7B              ;	sub		b
 639+ EB7B              ;	if
 640+ EB7B              ;
 641+ EB7B              ;85 82                   STA &82	   \ R	\ mask byte
 642+ EB7B              ;A5 81                   LDA &81	   \ Q	\ delta-Y
 643+ EB7B              ;A2 FE                   LDX #&FE	\ roll counter
 644+ EB7B              ;86 81                   STX &81		\ Q
 645+ EB7B              ;.LIL1	\ roll Q
 646+ EB7B              ;0A                      ASL A		\ highest bit of delta-Y
 647+ EB7B              ;B0 04                   BCS LI4		\ steep
 648+ EB7B              ;C5 1B                   CMP &1B	   \ P	\ delta-X
 649+ EB7B              ;90 03                   BCC LI5		\ shallow
 650+ EB7B              ;.LI4	\ steep
 651+ EB7B              ;E5 1B                   SBC &1B		\ P
 652+ EB7B              ;38                      SEC
 653+ EB7B              ;.LI5	\ shallow
 654+ EB7B              ;26 81                   ROL &81	   \ Q	\ #&FE
 655+ EB7B              ;B0 F2                   BCS LIL1 	\ loop Q, end with some low bits in Q
 656+ EB7B              ;A6 1B                   LDX &1B		\ P
 657+ EB7B              ;E8                      INX 		\ Xreg is width
 658+ EB7B              ;A5 37                   LDA &37		\ Y2
 659+ EB7B              ;E5 35                   SBC &35		\ Y1
 660+ EB7B              ;B0 2C                   BCS DOWN	\ draw line to the right and down
 661+ EB7B              ;A5 90                   LDA &90		\ SWAP
 662+ EB7B              ;D0 07                   BNE LI6		\ else Xreg was correct after all, no need to update R
 663+ EB7B              ;CA                      DEX
 664+ EB7B              ;.LIL2	\ counter X width
 665+ EB7B              ;A5 82                   LDA &82	   \ R	\ mask byte
 666+ EB7B              ;51 07                   EOR (&07),Y	\ (SC),Y
 667+ EB7B              ;91 07                   STA (&07),Y	\ (SC),Y
 668+ EB7B              ;.LI6	\ Xreg correct
 669+ EB7B              ;46 82                   LSR &82	   \ R	\ mask byte
 670+ EB7B              ;90 08                   BCC LI7   	\ else moving to next column to right. Bring carry in back
 671+ EB7B              ;66 82                   ROR &82		\ R
 672+ EB7B              ;A5 07                   LDA &07		\ SC
 673+ EB7B              ;69 08                   ADC #8		\ next column
 674+ EB7B              ;85 07                   STA &07		\ SC
 675+ EB7B              ;.LI7	\ S += Q. this is like an overflow monitor to update Y
 676+ EB7B              ;A5 83                   LDA &83		\ S
 677+ EB7B              ;65 81                   ADC &81	   \ Q	\ some low bits
 678+ EB7B              ;85 83                   STA &83		\ S
 679+ EB7B              ;90 07                   BCC LIC2	\ skip Y adjustment
 680+ EB7B              ;88                      DEY
 681+ EB7B              ;10 04                   BPL LIC2	\ skip Y adjustment
 682+ EB7B              ;C6 08                   DEC &08		\ SC+1
 683+ EB7B              ;A0 07                   LDY #7
 684+ EB7B              ;.LIC2	\ skip Y adjustment
 685+ EB7B              ;CA                      DEX
 686+ EB7B              ;D0 DC                   BNE LIL2	\ loop X width
 687+ EB7B              ;A4 85                   LDY &85	 \ YSAV \ restore Yreg
 688+ EB7B              ;60                      RTS
 689+ EB7B              ;
 690+ EB7B              ;.DOWN	\ Line is going to the right and down
 691+ EB7B              ;A5 90                   LDA &90		\ SWAP
 692+ EB7B              ;F0 07                   BEQ LI9		\ no swap
 693+ EB7B              ;CA                      DEX
 694+ EB7B              ;.LIL3	\ counter X width
 695+ EB7B              ;A5 82                   LDA &82	    \ R \ mask byte
 696+ EB7B              ;51 07                   EOR (&07),Y	\ (SC),Y
 697+ EB7B              ;91 07                   STA (&07),Y	\ (SC),Y
 698+ EB7B              ;.LI9	\ no swap
 699+ EB7B              ;46 82                   LSR &82		\ R
 700+ EB7B              ;90 08                   BCC LI10	\ still in correct column, hop
 701+ EB7B              ;66 82                   ROR &82		\ R
 702+ EB7B              ;A5 07                   LDA &07		\ SC
 703+ EB7B              ;69 08                   ADC #8		\ next column
 704+ EB7B              ;85 07                   STA &07		\ SC
 705+ EB7B              ;.LI10	\ this is like an overflow monitor to update Y
 706+ EB7B              ;A5 83                   LDA &83		\ S
 707+ EB7B              ;65 81                   ADC &81		\ Q
 708+ EB7B              ;85 83                   STA &83		\ S
 709+ EB7B              ;90 09                   BCC LIC3	\ skip Y adjustment
 710+ EB7B              ;C8                      INY
 711+ EB7B              ;C0 08                   CPY #8
 712+ EB7B              ;D0 04                   BNE LIC3	\ have not reached bottom byte of char, hop
 713+ EB7B              ;E6 08                   INC &08		\ SC+1
 714+ EB7B              ;A0 00                   LDY #0
 715+ EB7B              ;.LIC3	\ skipped Y adjustment
 716+ EB7B              ;CA                      DEX
 717+ EB7B              ;D0 DA                   BNE LIL3	\ loop X width
 718+ EB7B              ;A4 85                   LDY &85	 \ YSAV \ restore Yreg
 719+ EB7B              ;60                      RTS
 720+ EB7B              ;
 721+ EB7B              ;.STPY	\ -> &1797 \ Step along y for line, goes down and to right
 722+ EB7B              ;A4 35                   LDY &35		\ Y1
 723+ EB7B              ;98                      TYA
 724+ EB7B              ;A6 34                   LDX &34		\ X1
 725+ EB7B              ;C4 37                   CPY &37		\ Y2
 726+ EB7B              ;B0 10                   BCS LI15	\ skip swap if Y1 >= Y2
 727+ EB7B              ;C6 90                   DEC &90		\ SWAP
 728+ EB7B              ;A5 36                   LDA &36		\ X2
 729+ EB7B              ;85 34                   STA &34		\ X1
 730+ EB7B              ;86 36                   STX &36		\ X2
 731+ EB7B              ;AA                      TAX
 732+ EB7B              ;A5 37                   LDA &37		\ Y2
 733+ EB7B              ;85 35                   STA &35		\ Y1
 734+ EB7B              ;84 37                   STY &37		\ Y2
 735+ EB7B              ;A8                      TAY
 736+ EB7B              ;.LI15	\ Y1 Y2 order is now correct
 737+ EB7B              ;4A                      LSR A
 738+ EB7B              ;4A                      LSR A
 739+ EB7B              ;4A                      LSR A
 740+ EB7B              ;09 60                   ORA #&60
 741+ EB7B              ;85 08                   STA &08	 \ SC+1	\ screen hi
 742+ EB7B              ;8A                      TXA 		\ X1
 743+ EB7B              ;29 F8                   AND #&F8
 744+ EB7B              ;85 07                   STA &07	  \ SC	\ screen lo
 745+ EB7B              ;8A                      TXA
 746+ EB7B              ;29 07                   AND #7		\ mask index
 747+ EB7B              ;AA                      TAX
 748+ EB7B              ;BD AF 16                LDA &16AF,X \ TWOS,X \ Mode4 single pixel
 749+ EB7B              ;85 82                   STA &82	    \ R	\ mask
 750+ EB7B              ;A5 35                   LDA &35		\ Y1
 751+ EB7B              ;29 07                   AND #7
 752+ EB7B              ;A8                      TAY
 753+ EB7B              ;A5 1B                   LDA &1B	    \ P	\ delta-X
 754+ EB7B              ;A2 01                   LDX #1		\ roll counter
 755+ EB7B              ;86 1B                   STX &1B	    	\ P
 756+ EB7B              ;.LIL4	\ roll P
 757+ EB7B              ;0A                      ASL A
 758+ EB7B              ;B0 04                   BCS LI13	\ do subtraction
 759+ EB7B              ;C5 81                   CMP &81	    \ Q	\ delta-Y
 760+ EB7B              ;90 03                   BCC LI14	\ less than Q
 761+ EB7B              ;.LI13	\ do subtraction
 762+ EB7B              ;E5 81                   SBC &81		\ Q
 763+ EB7B              ;38                      SEC
 764+ EB7B              ;.LI14	\ less than Q
 765+ EB7B              ;26 1B                   ROL &1B		\ P
 766+ EB7B              ;90 F2                   BCC LIL4	\ loop P, end with some low bits in P
 767+ EB7B              ;A6 81                   LDX &81		\ Q
 768+ EB7B              ;E8                      INX 		\ adjust height
 769+ EB7B              ;A5 36                   LDA &36		\ X2
 770+ EB7B              ;E5 34                   SBC &34		\ X1
 771+ EB7B              ;90 2D                   BCC LFT		\ if C cleared then line moving to the left - hop down
 772+ EB7B              ;18                      CLC
 773+ EB7B              ;A5 90                   LDA &90		\ SWAP
 774+ EB7B              ;F0 07                   BEQ LI17 	\ skip first point
 775+ EB7B              ;CA                      DEX
 776+ EB7B              ;.LIL5	\ skipped first point, counter X
 777+ EB7B              ;A5 82                   LDA &82	    \ R \ mask byte
 778+ EB7B              ;51 07                   EOR (&07),Y	\ (SC),Y
 779+ EB7B              ;91 07                   STA (&07),Y	\ (SC),Y
 780+ EB7B              ;.LI17	\ skipped first point
 781+ EB7B              ;88                      DEY
 782+ EB7B              ;10 04                   BPL LI16	\ skip hi adjust
 783+ EB7B              ;C6 08                   DEC &08		\ SC+1
 784+ EB7B              ;A0 07                   LDY #7		\ new char
 785+ EB7B              ;	.LI16	\ skipped hi adjust
 786+ EB7B              ;A5 83                   LDA &83		\ S
 787+ EB7B              ;65 1B                   ADC &1B		\ P
 788+ EB7B              ;85 83                   STA &83		\ S
 789+ EB7B              ;90 0C                   BCC LIC5	\ skip, still in same column
 790+ EB7B              ;46 82                   LSR &82	  \ R	\ mask
 791+ EB7B              ;90 08                   BCC LIC5  	\ no mask bit hop
 792+ EB7B              ;66 82                   ROR &82   \ R	\ else moved over to next column, reset mask
 793+ EB7B              ;A5 07                   LDA &07	  \ SC  \ screen lo
 794+ EB7B              ;69 08                   ADC #8		\ next char below
 795+ EB7B              ;85 07                   STA &07		\ SC
 796+ EB7B              ;.LIC5	\ same column
 797+ EB7B              ;CA                      DEX
 798+ EB7B              ;D0 DC                   BNE LIL5	\ loop X height
 799+ EB7B              ;A4 85                   LDY &85	 \ YSAV	\ restore Yreg
 800+ EB7B              ;60                      RTS
 801+ EB7B              ;
 802+ EB7B              ;.LFT	\ going left
 803+ EB7B              ;A5 90                   LDA &90		\ SWAP
 804+ EB7B              ;F0 07                   BEQ LI18	\ skip first point
 805+ EB7B              ;CA                      DEX 		\ reduce height
 806+ EB7B              ;.LIL6	\ counter X height
 807+ EB7B              ;A5 82                   LDA &82	   \ R	\ mask byte
 808+ EB7B              ;51 07                   EOR (&07),Y	\ (SC),Y
 809+ EB7B              ;91 07                   STA (&07),Y	\ (SC),Y
 810+ EB7B              ;.LI18
 811+ EB7B              ;88                      DEY
 812+ EB7B              ;10 04                   BPL LI19	\ skip hi adjust
 813+ EB7B              ;C6 08                   DEC &08		\ SC+1
 814+ EB7B              ;A0 07                   LDY #7		\ rest char row
 815+ EB7B              ;.LI19	\ skipped hi adjust
 816+ EB7B              ;A5 83                   LDA &83		\ S
 817+ EB7B              ;65 1B                   ADC &1B	    \ P \ some low bits
 818+ EB7B              ;85 83                   STA &83		\ S
 819+ EB7B              ;90 0D                   BCC LIC6	\ no overflow
 820+ EB7B              ;06 82                   ASL &82	    \ R \ else move byte mask to the left
 821+ EB7B              ;90 09                   BCC LIC6	\ no overflow
 822+ EB7B              ;26 82                   ROL &82		\ R
 823+ EB7B              ;A5 07                   LDA &07		\ SC
 824+ EB7B              ;E9 07                   SBC #7		\ down 1 char
 825+ EB7B              ;85 07                   STA &07		\ SC
 826+ EB7B              ;18                      CLC
 827+ EB7B              ;.LIC6	\ no overflow
 828+ EB7B              ;CA                      DEX 		\ height
 829+ EB7B              ;D0 DB                   BNE LIL6	\ loop X
 830+ EB7B              ;A4 85                   LDY &85	 \ YSAV	\ restore Yreg
 831+ EB7B              ;.HL6
 832+ EB7B              ;60                      RTS 		\ end Line drawing
 833+ EB7B
 834+ EB7B
 835+ EB7B              ;;l2_draw_diagonalopt:
 836+ EB7B              	; ">TODO l2_draw_diagonalopt fast horz vert optmisation"
 837+ EB7B              ;;	push	af
 838+ EB7B              ;;	ld		a,b
 839+ EB7B              ;;	cp		d
 840+ EB7B              ;;	jr		z,.RegularDiagnonal
 841+ EB7B              ;;.CheckHorz:
 842+ EB7B              ;;	ld		a,c
 843+ EB7B              ;;	cp		e
 844+ EB7B              ;;	jr		z,.horizontalLine
 845+ EB7B              ;;.RegularDiagnonal:
 846+ EB7B              ;;	pop		af
 847+ EB7B              ;;	call diag
 848+ EB7B
 849+ EB7B
 850+ EB7B              ;;l2_signed_mul2a:
 851+ EB7B              ;;; ">l2_signed_mul2a - Signed a = a * 2 using shift)"
 852+ EB7B              ;;	TEST	$80
 853+ EB7B              ;;	jr		nz, .negativecalc
 854+ EB7B              ;;.positivecalc:
 855+ EB7B              ;;	ccf
 856+ EB7B              ;;	rla
 857+ EB7B              ;;	ret
 858+ EB7B              ;;.negativecalc:
 859+ EB7B              ;;	neg
 860+ EB7B              ;;	ccf
 861+ EB7B              ;;	rla
 862+ EB7B              ;;	neg
 863+ EB7B              ;;	ret
 864+ EB7B              ;;
 865+ EB7B              ;;l2_signed_mul2atohl:
 866+ EB7B              ;;; ">l2_signed_mul2ahl - Signed hl = a * 2 using shift)"
 867+ EB7B              ;;	TEST	$80
 868+ EB7B              ;;	jr		nz, .negativecalc
 869+ EB7B              ;;.positivecalc:
 870+ EB7B              ;;	ld		hl,0
 871+ EB7B              ;;	ld		l,a
 872+ EB7B              ;;	add		hl,a
 873+ EB7B              ;;	ret
 874+ EB7B              ;;.negativecalc:
 875+ EB7B              ;;	neg
 876+ EB7B              ;;	ld		hl,0
 877+ EB7B              ;;	ld		l,a
 878+ EB7B              ;;	neghl
 879+ EB7B              ;;	ret
 880+ EB7B              ;;
 881+ EB7B              ;;l2_e2fractionby2:
 882+ EB7B              ;;	ld 		hl,(l2fraction)
 883+ EB7B              ;;	push	de
 884+ EB7B              ;;	ld		d,h
 885+ EB7B              ;;	ld		e,l
 886+ EB7B              ;;	add		hl,de
 887+ EB7B              ;;	pop		de
 888+ EB7B              ;;	ld		(l2e2),hl
 889+ EB7B              ;;	ret
 890+ EB7B
 891+ EB7B
 892+ EB7B
 893+ EB7B
 894+ EB7B
 895+ EB7B              ;;//	ld		(l2linecolor),a   			; could do an ex but it will be needed multiple times between many uses of a reg
 896+ EB7B              ;;//.catchLoop:
 897+ EB7B              ;;//	jp .catchLoop
 898+ EB7B              ;;//.continue:
 899+ EB7B              ;;//    ld      A,D
 900+ EB7B              ;;//    sub     H
 901+ EB7B              ;;//    jr      NC,.DXpositive    ;delta_x > 0
 902+ EB7B              ;;//.DXNegative:
 903+ EB7B              ;;//    neg
 904+ EB7B              ;;//.DXPositive:
 905+ EB7B              ;;//    ld      B,A              ;B <- |delta_x|
 906+ EB7B              ;;//    ld      A,E
 907+ EB7B              ;;//    sub     L
 908+ EB7B              ;;//    jr      NC,.DYpositive    ;delta_y > 0
 909+ EB7B              ;;//.DYNegative:
 910+ EB7B              ;;//    neg
 911+ EB7B              ;;//.DYPositive:
 912+ EB7B              ;;//    sub     B               ;|delta_y|
 913+ EB7B              ;;//	push	af
 914+ EB7B              ;;//	jr		c,.DeltaX
 915+ EB7B              ;;//.DeltaY
 916+ EB7B              ;;//	ld      A,H             			;if |delta_x| < |delta_y| then
 917+ EB7B              ;;//    ld      H,L             			;then values x and y are swapped
 918+ EB7B              ;;//    ld      L,A             			;so the loop will always be performed on the
 919+ EB7B              ;;//    ld      A,D             			;x value. A flag must be set to
 920+ EB7B              ;;//    ld      D,E             			;remind that data must be drawn (y,x)
 921+ EB7B              ;;//    ld      E,A             			;instead of (x,y)
 922+ EB7B              ;;//.DeltaX:
 923+ EB7B              ;;//	ld		a,d
 924+ EB7B              ;;//	sub		h
 925+ EB7B              ;;//	jr		nc,.TestDY					; x1 < x2
 926+ EB7B              ;;//.TestDX:
 927+ EB7B              ;;//	ex		de,hl
 928+ EB7B              ;;//.TestDY:
 929+ EB7B              ;;//	ld		a,e
 930+ EB7B              ;;//	sub		l
 931+ EB7B              ;;//    ld      A,$01
 932+ EB7B              ;;//    jr      NC,.StoreA
 933+ EB7B              ;;//    neg                     ;y1 > y2 : in case2 the 'y' variable
 934+ EB7B              ;;//.StoreA:
 935+ EB7B              ;;//        ld      (l2way),A
 936+ EB7B              ;;//.InitLine:
 937+ EB7B              ;;//        ld      B,H
 938+ EB7B              ;;//        ld      C,L
 939+ EB7B              ;;//        ld      A,E
 940+ EB7B              ;;//        sub     L
 941+ EB7B              ;;//        jr      NC,.EndInit
 942+ EB7B              ;;//        ld      A,L
 943+ EB7B              ;;//        ld      L,E
 944+ EB7B              ;;//        ld      E,A
 945+ EB7B              ;;//.EndInit:
 946+ EB7B              ;;//        ld      A,E
 947+ EB7B              ;;//        sub     L
 948+ EB7B              ;;//        rla
 949+ EB7B              ;;//        ld      L,A             ;value to add in case1 (d < 0)
 950+ EB7B              ;;//        add     A,H
 951+ EB7B              ;;//        sub     D
 952+ EB7B              ;;//        ld      E,A             ;'d' variable is initialised
 953+ EB7B              ;;//        add     A,H
 954+ EB7B              ;;//        sub     D
 955+ EB7B              ;;//        ld      H,A             ;value to add in case2 (d >= 0)
 956+ EB7B              ;;//.Loop:
 957+ EB7B              ;;//        ld      A,B
 958+ EB7B              ;;//        sub     D
 959+ EB7B              ;;//        jr      NC,.EndLine       ;the line is completely drawn.
 960+ EB7B              ;;//        pop     AF
 961+ EB7B              ;;//        bit     7,A
 962+ EB7B              ;;//        push    AF
 963+ EB7B              ;;//        push    AF
 964+ EB7B              ;;//        push    BC
 965+ EB7B              ;;//        jr      Z,.DrawPoint
 966+ EB7B              ;;//        ld      A,B
 967+ EB7B              ;;//        ld      B,C
 968+ EB7B              ;;//        ld      C,A
 969+ EB7B              ;;//.DrawPoint:
 970+ EB7B              ;;//		push	hl
 971+ EB7B              ;;//		pushbcdeaf
 972+ EB7B              ;;//		ld		b,e
 973+ EB7B              ;;//		ld		c,d
 974+ EB7B              ;;//	ld 		a,(l2linecolor)
 975+ EB7B              ;;//	call	l2_plot_pixel
 976+ EB7B              ;;//		popafdebc
 977+ EB7B              ;;//		pop		hl
 978+ EB7B              ;;//        pop     BC
 979+ EB7B              ;;//        pop     AF
 980+ EB7B              ;;//.TestD:
 981+ EB7B              ;;//        bit     7,E
 982+ EB7B              ;;//        jr      NZ,.Case1
 983+ EB7B              ;;//.Case2:                          ;d >= 0
 984+ EB7B              ;;//        ld      A,E
 985+ EB7B              ;;//        add     A,H
 986+ EB7B              ;;//        ld      E,A
 987+ EB7B              ;;//        ld      A,(l2way)
 988+ EB7B              ;;//        add     A,C
 989+ EB7B              ;;//        ld      C,A
 990+ EB7B              ;;//        jr      .EndLoop
 991+ EB7B              ;;//.Case1:                          ;d < 0
 992+ EB7B              ;;//        ld      A,E
 993+ EB7B              ;;//        add     A,L
 994+ EB7B              ;;//        ld      E,A
 995+ EB7B              ;;//.EndLoop:
 996+ EB7B              ;;//        inc     B
 997+ EB7B              ;;//        jr      .Loop
 998+ EB7B              ;;//.EndLine:
 999+ EB7B              ;;//        pop     AF              ;MUST NOT BE REMOVED
1000+ EB7B              ;;//        pop     HL              ;can be removed
1001+ EB7B              ;;//        pop     DE              ;can be removed
1002+ EB7B              ;;//        ret
1003+ EB7B
1004+ EB7B              ;;	ld		(.l2yadjust),a
1005+ EB7B              ;;	call	calcdeltax:
1006+ EB7B              ;;	ld		(.l2xadjust),a
1007+ EB7B              ;;.calcfraction:							; err(or fraction) = dx+dy;
1008+ EB7B              ;;	push	hl
1009+ EB7B              ;;	push	de
1010+ EB7B              ;;	ld		hl,(l2deltaX)
1011+ EB7B              ;;	ld		de,(l2deltaY)
1012+ EB7B              ;;	add		hl,de
1013+ EB7B              ;;	ld		(l2fraction),hl
1014+ EB7B              ;;	pop		de
1015+ EB7B              ;;	pop		hl
1016+ EB7B              ;;.mainloop:
1017+ EB7B              ;;	push	bc
1018+ EB7B              ;;	push	de
1019+ EB7B              ;;	ld 		a,(l2linecolor)
1020+ EB7B              ;;	call	l2_plot_pixel
1021+ EB7B              ;;	pop		de
1022+ EB7B              ;;	pop		bc
1023+ EB7B              ;;.arewefinishedtest
1024+ EB7B              ;;	ld		a,b
1025+ EB7B              ;;	cp		d
1026+ EB7B              ;;	jr		nz,.notthereyet
1027+ EB7B              ;;	ld		a,c
1028+ EB7B              ;;	cp		e
1029+ EB7B              ;;	ret		z
1030+ EB7B              ;;.notthereyet:
1031+ EB7B              ;;	push	de
1032+ EB7B              ;;	call	l2_e2fractionby2			; e2 = 2*err;
1033+ EB7B              ;;	pop		de
1034+ EB7B              ;;.e2dytest:								; if (e2 >= dy) /* e_xy+e_x > 0 */  then S and P/V are the same
1035+ EB7B              ;;	push	de							; so if m & pe  or p & po calc (m = sign set p = 0)
1036+ EB7B              ;;	ld		de,(l2deltaY)				;    if m & po  or p & pe skip  (pe = pv set po = pv 0)
1037+ EB7B              ;;	or		a							;
1038+ EB7B              ;;	sbc		hl,de						;
1039+ EB7B              ;;	pop		de
1040+ EB7B              ;;	jr		z,  .dodycalc				; if equal then calc
1041+ EB7B              ;;	jp		p,	.dodycalc				; sign clear to H>D even with negtives
1042+ EB7B              ;;	jr		.skipdycalc         		; sign = 0     so  skip as pe
1043+ EB7B              ;;.dodycalc:
1044+ EB7B              ;;	ld		hl,(l2fraction)
1045+ EB7B              ;;	push	de
1046+ EB7B              ;;	ld		de,(l2deltaY)
1047+ EB7B              ;;	add		hl,de
1048+ EB7B              ;;	ld		(l2fraction),de
1049+ EB7B              ;;	pop		de
1050+ EB7B              ;;.l2yadjust:
1051+ EB7B              ;;	nop
1052+ EB7B              ;;.skipdycalc:
1053+ EB7B              ;;.e2dxtest:								;  if (e2 <= dx) /* e_xy+e_y < 0 */ then S and P/V are different.
1054+ EB7B              ;;	ld		hl,(l2e2)
1055+ EB7B              ;;	push	de							;
1056+ EB7B              ;;	ld		de,(l2deltaX)				;
1057+ EB7B              ;;	or		a							; clear carry flag
1058+ EB7B              ;;	sbc		hl,de						; hl = hl - de is if de > hl will get pv and signed different?
1059+ EB7B              ;;	pop		de
1060+ EB7B              ;;	jr		z,.dodxcalc					; e2 == dx so do calc
1061+ EB7B              ;;	jp		m,.dodxcalc					; was sign bit set
1062+ EB7B              ;;	jr		.skipdxcalc         	    ; diff so skip ; pvclear = po        pvset = pe
1063+ EB7B              ;;.dodxcalc:
1064+ EB7B              ;;	ld		hl,(l2fraction)
1065+ EB7B              ;;	push	de
1066+ EB7B              ;;	ld		de,(l2deltaX)
1067+ EB7B              ;;	add		hl,de
1068+ EB7B              ;;	ld		(l2fraction),de
1069+ EB7B              ;;	pop		de
1070+ EB7B              ;;.l2xadjust:
1071+ EB7B              ;;	nop
1072+ EB7B              ;;.skipdxcalc:
1073+ EB7B              ;;	jr 		.mainloop
1074+ EB7B
1075+ EB7B
1076+ EB7B              ;;/l2_draw_diagonalold:
1077+ EB7B              ;;/MESSAGE ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color)"
1078+ EB7B              ;;/	ld		(l2linecolor),a   			; could do an ex but it will be needed multiple times between many uses of a reg
1079+ EB7B              ;;/.sortycoords:
1080+ EB7B              ;;/	ld		a,b							; Sort to Y0 is always > y1 so we don't have to deal with step y and only step x
1081+ EB7B              ;;/	cp		d
1082+ EB7B              ;;/	jr		nc, .nocoordswap
1083+ EB7B              ;;/.swapcoords:
1084+ EB7B              ;;/	ex		de,hl						; save de to hl ! effective code line 98 after macros
1085+ EB7B              ;;/	lddebc
1086+ EB7B              ;;/	ldbchl
1087+ EB7B              ;;/.nocoordswap:
1088+ EB7B              ;;/	ld		a,d							; l2_dy = -ABS(l2_vy1 - l2_vy0)
1089+ EB7B              ;;/	sub		b							; we have already sorted  so y1 > y0
1090+ EB7B              ;;/	ld		(l2deltaY),a
1091+ EB7B              ;;/	neg									; DEBUG
1092+ EB7B              ;;/	ld		(l2deltaYn),a				; DEBUG
1093+ EB7B              ;;/	neg									; DEBUG
1094+ EB7B              ;;/.deltaxequABSx0Minusx1:						; we need to set l2dx to abs x1-x0 and set
1095+ EB7B              ;;/    ld		a,c
1096+ EB7B              ;;/	cp		e
1097+ EB7B              ;;/	jr		c, .x1GTx0
1098+ EB7B              ;;/.x1LTx0
1099+ EB7B              ;;/	ld		a,c
1100+ EB7B              ;;/	sub		e
1101+ EB7B              ;;/	ld		(l2deltaX),a				; just 8 bit for now should it be 16?
1102+ EB7B              ;;/	neg									; DEBUG
1103+ EB7B              ;;/	ld		(l2deltaXn),a				; DEBUG
1104+ EB7B              ;;/	neg									; DEBUG
1105+ EB7B              ;;/	ld		a,l2incbstep
1106+ EB7B              ;;/	jr		.setlayershift0
1107+ EB7B              ;;/.x1GTx0:
1108+ EB7B              ;;/	ld		a,e
1109+ EB7B              ;;/	sub		c
1110+ EB7B              ;;/	ld		(l2deltaX),a					; just 8 bit for now should it be 16?
1111+ EB7B              ;;/	neg									; DEBUG
1112+ EB7B              ;;/	ld		(l2deltaXn),a				; DEBUG
1113+ EB7B              ;;/	neg									; DEBUG
1114+ EB7B              ;;/	ld		a,l2decbstep
1115+ EB7B              ;;/.setlayershift0:
1116+ EB7B              ;;/	ld		a,0
1117+ EB7B              ;;/	pushbcde
1118+ EB7B              ;;/	call	asm_l2_bank_n_select		; l2_layer_shift = 0 and bank 0 selected
1119+ EB7B              ;;/	popdebc
1120+ EB7B              ;;/; so now we have set inc or dec instruction, l2dy, l2dx and on bank 0,
1121+ EB7B              ;;/.dymuliplyby2:
1122+ EB7B              ;;/	ld		a, (l2deltaY)				; dy *= 2
1123+ EB7B              ;;/	call	l2_signed_mul2a
1124+ EB7B              ;;/	ld		(l2deltaYsq),a
1125+ EB7B              ;;/	neg									; DEBUG
1126+ EB7B              ;;/	ld		(l2deltaYsqn),a				; DEBUG
1127+ EB7B              ;;/	neg									; DEBUG
1128+ EB7B              ;;/.dxmuliplyby2:
1129+ EB7B              ;;/	ld		a, (l2deltaX)				; dx *= 2
1130+ EB7B              ;;/	call	l2_signed_mul2a
1131+ EB7B              ;;/	ld		(l2deltaXsq),a
1132+ EB7B              ;;/	neg									; DEBUG
1133+ EB7B              ;;/	ld		(l2deltaXsqn),a				; DEBUG
1134+ EB7B              ;;/	neg									; DEBUG
1135+ EB7B              ;;/.plotfirstpixel:
1136+ EB7B              ;;/	pushbcde
1137+ EB7B              ;;/	ld a,(l2linecolor)
1138+ EB7B              ;;/	call	l2_plot_pixel
1139+ EB7B              ;;/	popdebc
1140+ EB7B              ;;/.mainloop:								; if (l2_dx > l2_dy) signed
1141+ EB7B              ;;/	ld		a,(l2deltaX)				;If A < N, then S and P/V are different.
1142+ EB7B              ;;/	ld		hl,l2deltaY					;A >= N, then S and P/V are the same
1143+ EB7B              ;;/	cp		(hl)
1144+ EB7B              ;;/	jp		m,	.signset
1145+ EB7B              ;;/.signclear:
1146+ EB7B              ;;/	jp		pe,	.dxLTEdybranch
1147+ EB7B              ;;/	jr		.dxGTdybranch
1148+ EB7B              ;;/.signset:
1149+ EB7B              ;;/	jp		po,	.dxLTEdybranch
1150+ EB7B              ;;/.dxGTdybranch:
1151+ EB7B              ;;/	ld		a,(l2deltaYsq)
1152+ EB7B              ;;/	ld		hl,l2deltaX
1153+ EB7B              ;;/	sub		(hl)
1154+ EB7B              ;;/	ld		(l2fraction),a				; faction = dy - 1/2 dx
1155+ EB7B              ;;/.BranchAwhile							; while (l2_vx0 != l2_vx1)
1156+ EB7B              ;;/	ld		a,c
1157+ EB7B              ;;/	cp		e
1158+ EB7B              ;;/	ret		z							; if x0 = x1 then done
1159+ EB7B              ;;/.BranchAtestfraction:					; if (l2_fraction >= 0)
1160+ EB7B              ;;/	ld		a,(l2fraction)
1161+ EB7B              ;;/	TEST	$80
1162+ EB7B              ;;/	jr		nz,.BranchAskipYstep
1163+ EB7B              ;;/	inc		b							; 		++l2_vy0;
1164+ EB7B              ;;/	ld		hl,l2deltaXsq
1165+ EB7B              ;;/	sub		(hl)						; 		l2_fraction -= l2_dx;
1166+ EB7B              ;;/	ld		(l2fraction),a
1167+ EB7B              ;;/.BranchAskipYstep:
1168+ EB7B              ;;/.l2stepx1:
1169+ EB7B              ;;/	inc		b							; this is self modifying code point 1 l2_vx0 += l2_stepx
1170+ EB7B              ;;/	ld		a,(l2fraction)				; l2_fraction += l2_dy can optimise later as a already has this?
1171+ EB7B              ;;/	ld		hl,l2deltaYsq
1172+ EB7B              ;;/	add		a,(hl)
1173+ EB7B              ;;/	ld		(l2fraction),a
1174+ EB7B              ;;/.BranchAplotBCColA:						; l2_plot_pixel(l2_vx0,l2_vy0,color);
1175+ EB7B              ;;/	pushbcde
1176+ EB7B              ;;/	ld a,(l2linecolor)
1177+ EB7B              ;;/	call	l2_plot_pixel
1178+ EB7B              ;;/	popdebc
1179+ EB7B              ;;/.BranchAloop:
1180+ EB7B              ;;/	jr		.BranchAwhile
1181+ EB7B              ;;/.dxLTEdybranch:
1182+ EB7B              ;;/	ld		a,(l2deltaXsq)				; l2_fraction = l2_dx - (l2_dy >> 1);
1183+ EB7B              ;;/	ld		hl, l2deltaY
1184+ EB7B              ;;/	sub		(hl)
1185+ EB7B              ;;/	ld		(l2fraction),a				; faction = dy - 1/2 d
1186+ EB7B              ;;/.BranchBwhile:							; while (l2_vy0 != l2_vy1)
1187+ EB7B              ;;/	ld		a,b
1188+ EB7B              ;;/	cp		d
1189+ EB7B              ;;/	ret		z							; if x0 = x1 then done
1190+ EB7B              ;;/.BranchBtestfraction:					; if (l2_fraction >= 0)
1191+ EB7B              ;;/	ld		a,(l2fraction)
1192+ EB7B              ;;/	TEST	$80
1193+ EB7B              ;;/	jr		nz,.BranchBskipYstep
1194+ EB7B              ;;/.l2stepx2
1195+ EB7B              ;;/	inc		b							; l2_vx0 += l2_stepx; this is self modifying code point 2
1196+ EB7B              ;;/	ld		a,(l2fraction)				; l2_fraction -= l2_dy
1197+ EB7B              ;;/	ld		hl,l2deltaYsq
1198+ EB7B              ;;/	sub		(hl)
1199+ EB7B              ;;/	ld		(l2fraction),a
1200+ EB7B              ;;/.BranchBskipYstep:
1201+ EB7B              ;;/	ld		hl, l2deltaYsq
1202+ EB7B              ;;/	add		a,(hl)
1203+ EB7B              ;;/	ld		(l2fraction),a
1204+ EB7B              ;;/	inc		b							; ++l2_vy0;
1205+ EB7B              ;;/.BranchBplotBCColA:
1206+ EB7B              ;;/	pushbcde
1207+ EB7B              ;;/	ld a,(l2linecolor)
1208+ EB7B              ;;/	call	l2_plot_pixel
1209+ EB7B              ;;/	popdebc
1210+ EB7B              ;;/.BranchBloop:
1211+ EB7B              ;;/	jr		.BranchBwhile
1212+ EB7B
# file closed: ./Layer2Graphics/layer2_plot_diagonal.asm
 229  EB7B                  INCLUDE "./Layer2Graphics/asm_l2_plot_triangle.asm"
# file opened: ./Layer2Graphics/asm_l2_plot_triangle.asm
   1+ EB7B
   2+ EB7B
   3+ EB7B
   4+ EB7B 00 00        l2trianglebc	        DW 0
   5+ EB7D 00 00        l2trianglede	        DW 0
   6+ EB7F 00 00        l2trianglehl	        DW 0
   7+ EB81
   8+ EB81              ; "l2_draw_triangle, BC = y1x1, DE=y2x2, HL=y3x3 a = Color"
   9+ EB81 C5 D5 E5 F5  l2_draw_triangle:       push	bc,,de,,hl,,af
  10+ EB85 CD 9D EA                             call	l2_draw_diagonal		; BC to DE
  11+ EB88 F1                                   pop		af
  12+ EB89 D1                                   pop		de						; swap DE and HL
  13+ EB8A E1                                   pop		hl						; so BC to DE is really to HL
  14+ EB8B C1                                   pop		bc
  15+ EB8C D5 E5                                push    de,,hl                    ; which is pushing original hl then original de
  16+ EB8E F5                                   push	af
  17+ EB8F CD 9D EA                             call	l2_draw_diagonal		; BC to HL (leaving DE and HL swapped)
  18+ EB92 F1                                   pop		af
  19+ EB93 C1                                   pop		bc						; Now bc = original de
  20+ EB94 D1                                   pop		de						; de = original hl
  21+ EB95 CD 9D EA                             call	l2_draw_diagonal		; BC to HL (leaving DE and HL swapped)
  22+ EB98 C9                                   ret
  23+ EB99
  24+ EB99
  25+ EB99
  26+ EB99
  27+ EB99
# file closed: ./Layer2Graphics/asm_l2_plot_triangle.asm
 230  EB99                  INCLUDE "./Layer2Graphics/asm_l2_fill_triangle.asm"
# file opened: ./Layer2Graphics/asm_l2_fill_triangle.asm
   1+ EB99              ; First off basic off screen clip tests
   2+ EB99              ; Sort points in Y ascending order
   3+ EB99              ; Detect if flat top    -> l2_fillTopFlatTriangle
   4+ EB99              ; Detect if flat bottom ->l2_fillBottomFlatTriangle
   5+ EB99              ; else
   6+ EB99              ; Calc X2-X1 = delta X
   7+ EB99              ; calc Y2-Y1 = partialY
   8+ EB99              ; calc Y3-Y1 = fullY
   9+ EB99              ; X2partial = X1 + (deltaX * (partialY/fullY) - Can be done by line algorithim variant?
  10+ EB99              ; l2_fillBottomFlatTriangle (X1Y1, X2parialY2, X2Y2)
  11+ EB99              ; l2_fillTopFlatTriangle(X2partialY2, X2Y2, X3Y3)
  12+ EB99              ; done
  13+ EB99              ;
  14+ EB99              ; Sorts    Y1   Y2    Y3
  15+ EB99              ;          1    2     3     Y1 < Y2 no      Y1 < Y3 no      Y2 < Y3 no
  16+ EB99              ;          1    3     2     Y1 < Y2 no      Y1 < Y3 no      Y2 > Y3 1 2<=>3
  17+ EB99              ;          2    1     3     Y1 < Y2 1<=>2 3 Y1 < Y3 no      Y2 < Y3 no
  18+ EB99              ;          2    3     1     Y1 < Y2 no      Y1 < Y3 1  2  3 Y2 < Y3 no
  19+ EB99              ;          3    1     2     Y1 < Y2 1<=>3 2 Y1 < Y3 no      Y2 < Y3 1 2 3
  20+ EB99              ;          3    2     1     Y1 < Y2 2<->3 1 Y1 < Y2 1  2  3 Y2 < Y2 no
  21+ EB99
  22+ EB99
  23+ EB99              ; X1  IY +0
  24+ EB99              ; Y1  IY +2
  25+ EB99              ; X2  IY +4
  26+ EB99              ; Y2  IY +6
  27+ EB99              ; X3  IY +8
  28+ EB99              ; Y3  IY +10
  29+ EB99              ;;;
  30+ EB99              ;;;compareCoordsSwap:      MACRO   OffsetX1, OffsetX2
  31+ EB99              ;;;                        ld      hl,(IY+(OffsetX1+2))                       ; Y1
  32+ EB99              ;;;                        ld      de,(IY+(OffsetX2+2))                       ; Y2
  33+ EB99              ;;;                        cpHLDELeadSign
  34+ EB99              ;;;                        ret     nc
  35+ EB99              ;;;                        ld      hl,(IY+OffsetX1)   ; swap X1 and X2
  36+ EB99              ;;;                        ld      de,(IY+OffsetX2)   ;
  37+ EB99              ;;;                        ld      hl,(IY+OffsetX2)   ;
  38+ EB99              ;;;                        ld      de,(IY+OffsetX1)   ;
  39+ EB99              ;;;                        ld      hl,(IY+(OffsetX1+2))   ; swap Y1 and Y2
  40+ EB99              ;;;                        ld      de,(IY+(OffsetX2+2))   ;
  41+ EB99              ;;;                        ld      hl,(IY+(OffsetX2+2))   ;
  42+ EB99              ;;;                        ld      de,(IY+(OffsetX1+2))
  43+ EB99              ;;;                        ENDM
  44+ EB99              ;;;; points in in IY = address of all 3 points in S15,S15 format
  45+ EB99              ;;;l_fillTriangle:         ; Do initial off screen clip tests
  46+ EB99              ;;;                        ; sortpoints Y ascending
  47+ EB99              ;;;                        compareCoordsSwap 0, 4
  48+ EB99              ;;;                        compareCoordsSwap 0, 8
  49+ EB99              ;;;                        compareCoordsSwap 4, 8
  50+ EB99              ;;;                        ld      hl,(IY+2)                ; if Y1 and Y2 are the same then its a flat top
  51+ EB99              ;;;                        ld      de,(IY+6)                ; (in these routines it santity checks its not a flat line)
  52+ EB99              ;;;                        cpHLEquDE
  53+ EB99              ;;;                        jp      z,.PrepareFlatTopTriangle
  54+ EB99              ;;;                        ld      hl,(IY+8)               ; if Y1 and Y2 are the same then its a flat bottom
  55+ EB99              ;;;                        cpHLEquDE                       ;
  56+ EB99              ;;;                        jp      z,.PrepareFlatBottomTriagle
  57+ EB99              ;;;.SplitTriangleInTwo     ; Y2 will always be <= Y3
  58+ EB99              ;;;                        ; calculate line X1Y1 to X3Y3 until y row = Y2, result is XTemp,
  59+ EB99              ;;;                        ; drawflat bottomed X1Y1, X2Y2, XTempY2
  60+ EB99              ;;;                        ; drawflat topped   X2Y2, XTempY2, X3Y3
  61+ EB99              ;;;
  62+ EB99              ;;;
  63+ EB99              ;;;
  64+ EB99              ;;;
  65+ EB99              ;;;; Calc X2-X1 = delta X
  66+ EB99              ;;;                        ; calc Y2-Y1 = partialY
  67+ EB99              ;;;                        ; calc Y3-Y1 = fullY
  68+ EB99              ;;;                        ; X2partial = X1 + (deltaX * (partialY/fullY) - Can be done by line algorithim variant?
  69+ EB99              ;;;                        ; l2_fillBottomFlatTriangle (X1Y1, X2parialY2, X2Y2)
  70+ EB99              ;;;                        ; l2_fillTopFlatTriangle(X2partialY2, X2Y2, X3Y3)
  71+ EB99              ;;;
  72+ EB99              ;;;                           X1   H           X2 H
  73+ EB99              ;;;                                Y0
  74+ EB99              ;; bc = x0y0, de=x1y1 hl=x2y2 a = colour
  75+ EB99              ;Now Works
  76+ EB99 78           l2_fillAnyTriangle:     ld      a,b
  77+ EB9A                                      JumpIfALTNusng   d, .noSwapY0Y1
  77+ EB9A BA          >                        cp      d
  77+ EB9B DA A2 EB    >                        jp		c, .noSwapY0Y1
  78+ EB9E C5           .SwapY0Y1:              push    bc
  79+ EB9F 42 4B                                ld      bc,de
  80+ EBA1 D1                                   pop     de
  81+ EBA2 78           .noSwapY0Y1:            ld      a,b
  82+ EBA3                                      JumpIfALTNusng   h, .noSwapY0Y2
  82+ EBA3 BC          >                        cp      h
  82+ EBA4 DA AB EB    >                        jp		c, .noSwapY0Y2
  83+ EBA7 C5           .SwapY0Y2:              push    bc
  84+ EBA8 44 4D                                ld      bc,hl
  85+ EBAA E1                                   pop     hl
  86+ EBAB 7A           .noSwapY0Y2:            ld      a,d
  87+ EBAC                                      JumpIfALTNusng   h, .noSwapY1Y2
  87+ EBAC BC          >                        cp      h
  87+ EBAD DA B1 EB    >                        jp		c, .noSwapY1Y2
  88+ EBB0 EB           .SwapY1Y2:              ex      de,hl
  89+ EBB1              .noSwapY1Y2:
  90+ EBB1 78           .DoneYAscending:        ld      a,b
  91+ EBB2 BA                                   cp      d
  92+ EBB3 CA E8 EB                             jp      z,.PrepFlatTopTriangle
  93+ EBB6 7A                                   ld      a,d
  94+ EBB7 BC                                   cp      h
  95+ EBB8 CA EF EB                             jp      z,.PrepFlatBottomTriangle
  96+ EBBB              ; Now we know we have a triangle that needs to split at point X?Y1 where X? is between X0 and X2
  97+ EBBB              ; Simplified expensive version for now, just call l2_draw_diagonal_save until we hit Y1 and then check for X pixel adjust
  98+ EBBB              ; better later to do a quick Deltaxy calc but for now we are testing
  99+ EBBB              ; acutallty diagnoal save will be better to do as we can calculate the line from X0 to X2 up front and save having to do that calc
 100+ EBBB              ; again in the top to bottom or bottom to top, we can refine it with an overshoot variable so it precalcs upto Y1 + 1 to make sure x? is correct
 101+ EBBB E5 D5 C5     .SplitTriangleInTwo:    push	hl,,de,,bc                      ; save for now. bc is already X0Y0
 102+ EBBE EB                                   ex      de,hl                           ; quick load of de with X2Y2
 103+ EBBF 3E 01                                ld		a,1
 104+ EBC1 DD 01                                break
 105+ EBC3 CD AD E9                             call	l2_draw_diagonal_save           ;now we don't know if x? is going to be > x1 or no
 106+ EBC6 C1           .CheckX1:               pop     bc
 107+ EBC7 D1                                   pop     de
 108+ EBC8 21 4B E5                             ld      hl,l2targetArray1
 109+ EBCB 7A                                   ld      a,d
 110+ EBCC ED 31                                add     hl,a
 111+ EBCE 7E                                   ld      a,(hl)                          ; now we have x?
 112+ EBCF E1                                   pop     hl                              ; now we have bc=x0y0, de=x1y1, hl=x2y2 a = x?
 113+ EBD0              ; We will optimise that we ahve already calcualteed a diagnoal later
 114+ EBD0 E5 D5 C5 F5                          push    hl,,de,,bc,,af                  ; bc already = y0x0;
 115+ EBD4 62                                   ld      h,d                             ; h = y common whch is y1
 116+ EBD5 53                                   ld      d,e                             ; d = x1
 117+ EBD6 5F                                   ld      e,a                             ; e = x2
 118+ EBD7 DD 01                                break
 119+ EBD9 CD 60 EC                             call    l2_fillBottomFlatTriangle       ;>l2_fillBottomFlatTriangle BC y0x0 DE x1x2, H YCommon, L Colour"
 120+ EBDC F1 C1 D1 E1                          pop     hl,,de,,bc,,af
 121+ EBE0 44 4D                                ld      bc,hl                           ; bc = common bottom x2y2
 122+ EBE2 62                                   ld      h,d                             ; h = common y for flat top
 123+ EBE3 57                                   ld      d,a                             ; d = X?, e is already x1
 124+ EBE4 CD F5 EB                             call    l2_fillTopFlatTriangle          ;>l2_fillTopFlatTriangle BC y2x2 DE x0x1, H YCommon, L Colour"
 125+ EBE7 C9                                   ret
 126+ EBE8              ;; bc = x0y0, de=x1y1 hl=x2y2 a = colour
 127+ EBE8 51           .PrepFlatTopTriangle:   ld      d,c
 128+ EBE9 44 4D                                ld      bc,hl
 129+ EBEB CD F5 EB                             call    l2_fillTopFlatTriangle          ;>l2_fillTopFlatTriangle BC y2x2 DE x0x1, H YCommon, L Colour"
 130+ EBEE C9                                   ret
 131+ EBEF 54           .PrepFlatBottomTriangle:ld      d,h
 132+ EBF0 65                                   ld      h,l
 133+ EBF1 CD 60 EC                             call    l2_fillBottomFlatTriangle       ;>l2_fillBottomFlatTriangle BC y0x0 DE x1x2, H YCommon, L Colour"
 134+ EBF4 C9                                   ret
 135+ EBF5              ;;;.SplitTriangleInTwo     ; Y2 will always be <= Y3
 136+ EBF5              ;;;                        ; calculate line X1Y1 to X3Y3 until y row = Y2, result is XTemp,
 137+ EBF5              ;;;                        ; drawflat bottomed X1Y1, X2Y2, XTempY2
 138+ EBF5              ;;;                        ; drawflat topped   X2Y2, XTempY2, X3Y3
 139+ EBF5
 140+ EBF5
 141+ EBF5
 142+ EBF5                                     ; call    l2_fillTopFlatTriangle
 143+ EBF5
 144+ EBF5              ;; ">l2_fillTopFlatTriangle BC y2x2 DE x0x1, H YCommon, L Colour"                            X1YC            X2YC
 145+ EBF5              ;; b = bottomxy, de = to x1 x2, h =common top y
 146+ EBF5 DD 01        l2_fillTopFlatTriangle: break
 147+ EBF7 7B                                   ld		a,e                             ; check x0 x1 to make sure lines draw left to right
 148+ EBF8                                      JumpIfAGTENusng d, .x2gtex1
 148+ EBF8 BA          >                        cp     d
 148+ EBF9 D2 04 EC    >                        jp		nc,.x2gtex1
 149+ EBFC              ;                        cp		e
 150+ EBFC              ;                        jr		nc, .x2gtex1                    ; make sureline is alwasy left to right so +ve direction
 151+ EBFC DD 26 01     .x1ltx2:                ld		ixh,1                           ; list 1 holds x0 down to x2
 152+ EBFF DD 2E 02                             ld		ixl,2                           ; list 2 hols  x1 down to x2
 153+ EC02 18 06                                jr		.storepoints
 154+ EC04 DD 26 02     .x2gtex1:               ld		ixh,2
 155+ EC07 DD 2E 01                             ld		ixl,1
 156+ EC0A DD E5        .storepoints:           push    ix
 157+ EC0C C5 D5 E5                             push	bc,,de,,hl
 158+ EC0F 79                                   ld      a,c                             ; save    c x2
 159+ EC10 4A                                   ld      c,d                             ; now c = d = x0
 160+ EC11 5F                                   ld      e,a                             ; e = a = old c = x2
 161+ EC12 50                                   ld      d,b                             ; d = b = y2
 162+ EC13 44                                   ld      b,h                             ; b = h = y common
 163+ EC14 DD 7C                                ld      a,ixh
 164+ EC16 E5                                   push    hl; temp fix
 165+ EC17 CD AD E9                             call	l2_draw_diagonal_save			;l2_store_diagonal(x0,y0,x1,ycommon,l2_LineMinX);
 166+ EC1A FD E1                                pop     iy ;tempfix to hold y common
 167+ EC1C E1 D1 C1                             pop		bc,,de,,hl
 168+ EC1F DD E1                                pop     ix
 169+ EC21 C5 D5 E5                             push	bc,,de,,hl; of course it always assumes ?
 170+ EC24 79                                   ld      a,c                             ; save    c x2
 171+ EC25 4B                                   ld      c,e                             ; now c = d = x1
 172+ EC26 5F                                   ld      e,a                             ; e = a = old c = x2
 173+ EC27 50                                   ld      d,b                             ; d = b = y2
 174+ EC28 FD 44                                ld      b,iyh ;tempfix                            ; b = h = y common
 175+ EC2A DD 7D                                ld		a,ixl
 176+ EC2C CD AD E9                             call	l2_draw_diagonal_save			;l2_store_diagonal(x0,y0,x2,ycommon,l2_LineMaxX);
 177+ EC2F E1 D1 C1                             pop		bc,,de,,hl
 178+ EC32 DD 01                                break                                   ; so now we have two arrays loaded h = start b = end
 179+ EC34 78                                   ld      a,b
 180+ EC35 44                                   ld		b,h                             ; and set up working values as we share
 181+ EC36 67                                   ld		h,a								; the flat bottom code here
 182+ EC37 DD 01                                break
 183+ EC39 50           .OldSave:               ld		d,b
 184+ EC3A 5C                                   ld		e,h								; save loop counters
 185+ EC3B D5           .SaveForLoop:           push	de								; de = y0ycommon
 186+ EC3C 21 4B E5     .GetFirstHorizontalRow:	ld		hl,l2targetArray1               ; get first row for loop
 187+ EC3F 78                                   ld		a,b
 188+ EC40 ED 31                                add		hl,a							; hl = l2targetArray1 row b
 189+ EC42 7E                                   ld		a,(hl)							;
 190+ EC43 4F                                   ld		c,a								; c = col1 i.e. l2targetarray1[b]
 191+ EC44 21 4B E6                             ld      hl,l2targetArray2
 192+ EC47 78                                   ld      a,b
 193+ EC48 ED 31                                add     hl,a
 194+ EC4A              ;                        inc		h								; hl = l2targetArray2 row b if we interleave
 195+ EC4A 7E                                   ld		a,(hl)
 196+ EC4B 57                                   ld		d,a								; d = col2 i.e. l2targetarray2[b]
 197+ EC4C 3A 43 E5     .SetColour:             ld		a,(l2linecolor)
 198+ EC4F 5F                                   ld		e,a								; de = to colour
 199+ EC50 C5           .SavePoints:            push	bc								; bc = rowcol
 200+ EC51 25                                   dec		h
 201+ EC52 E5                                   push	hl								; hl = l2targetArray1[b]
 202+ EC53 CD 94 E4     .DoLine:	            call	l2_draw_horz_line_to
 203+ EC56 E1                                   pop		hl
 204+ EC57 C1                                   pop		bc
 205+ EC58 04                                   inc		b								; down a rowc
 206+ EC59 D1                                   pop		de								; de = from to (and b also = current)
 207+ EC5A 14                                   inc		d
 208+ EC5B 7B                                   ld		a,e								; while e >= d
 209+ EC5C BA                                   cp		d
 210+ EC5D 30 DC                                jr 		nc,.SaveForLoop					; Is this the right point??
 211+ EC5F C9                                   ret
 212+ EC60
 213+ EC60              ; Calulate
 214+ EC60
 215+ EC60              ; ">l2_fillBottomFlatTriangle BC y0x0 DE x1x2, H YCommon, L Colour"
 216+ EC60              ; "note >l2_draw_diagonal_save, bc = y0,x0 de=y1,x1,a=array nbr ESOURCE LL30 or LION"
 217+ EC60              ; "note line to   bc = left side row,col, d right pixel, l = color"
 218+ EC60              l2_fillBottomFlatTriangle:;break
 219+ EC60 7B                                   ld      a,e
 220+ EC61                                      JumpIfAGTENusng d, .x2gtex1
 220+ EC61 BA          >                        cp     d
 220+ EC62 D2 6D EC    >                        jp		nc,.x2gtex1
 221+ EC65              ;                        ld		a,d                             ; if x0 < x2 goto x2<x1
 222+ EC65              ;                        cp		e                               ;      list 1 holds x1 down to x0
 223+ EC65              ;                        ld		ixl,2                           ;      list 2 hols  x2 down to x0
 224+ EC65              ;                        jr		nc, .x2gtex1                    ;
 225+ EC65 DD 26 01     .x1ltx2:                ld		ixh,1                           ; else list 1 holds x0 down to x1
 226+ EC68 DD 2E 02                             ld		ixl,2                           ;      list 2 hols  x0 down to x2
 227+ EC6B 18 06                                jr		.storepoints                    ;
 228+ EC6D DD 26 02     .x2gtex1:               ld		ixh,2                           ;
 229+ EC70 DD 2E 01                             ld		ixl,1                           ;
 230+ EC73 DD E5        .storepoints:           push    ix
 231+ EC75 C5 D5 E5                             push	bc,,de,,hl                      ; save working variables
 232+ EC78 DD 7C                                ld		a,ixh
 233+ EC7A 5A                                   ld		e,d                             ; we alreay have bc so its now bc -> hd
 234+ EC7B 54                                   ld		d,h
 235+ EC7C CD AD E9                             call	l2_draw_diagonal_save			;l2_store_diagonal(x0,y0,x1,ycommon,l2_LineMinX);
 236+ EC7F E1 D1 C1                             pop		bc,,de,,hl
 237+ EC82 DD E1                                pop     ix
 238+ EC84 C5 E5                                push	bc,,hl
 239+ EC86 54                                   ld		d,h                             ; now its bc -> he
 240+ EC87 DD 7D                                ld		a,ixl
 241+ EC89 CD AD E9                             call	l2_draw_diagonal_save			;l2_store_diagonal(x0,y0,x2,ycommon,l2_LineMaxX);
 242+ EC8C E1 C1                                pop		bc,,hl
 243+ EC8E 50           .OldSaveForLoop:           ld		d,b
 244+ EC8F 5C                                   ld		e,h								; save loop counters
 245+ EC90 D5           .SaveForLoop:                        push	de								; de = y0ycommon
 246+ EC91 21 4B E5     .GetFirstHorizontalRow:	ld		hl,l2targetArray1               ; get first row for loop
 247+ EC94 78                                   ld		a,b
 248+ EC95 ED 31                                add		hl,a							; hl = l2targetArray1 row b
 249+ EC97 7E                                   ld		a,(hl)							;
 250+ EC98 4F                                   ld		c,a								; c = col1 i.e. l2targetarray1[b]
 251+ EC99 21 4B E6                             ld      hl,l2targetArray2
 252+ EC9C 78                                   ld      a,b
 253+ EC9D ED 31                                add     hl,a
 254+ EC9F              ;                        inc		h								; hl = l2targetArray2 row b if we interleave
 255+ EC9F 7E                                   ld		a,(hl)
 256+ ECA0 57                                   ld		d,a								; d = col2 i.e. l2targetarray2[b]
 257+ ECA1 3A 43 E5     .SetColour:             ld		a,(l2linecolor)
 258+ ECA4 5F                                   ld		e,a								; de = to colour
 259+ ECA5 C5           .SavePoints:            push	bc								; bc = rowcol
 260+ ECA6 25                                   dec		h
 261+ ECA7 E5                                   push	hl								; hl = l2targetArray1[b]
 262+ ECA8 CD 94 E4     .DoLine:	            call	l2_draw_horz_line_to
 263+ ECAB E1                                   pop		hl
 264+ ECAC C1                                   pop		bc
 265+ ECAD 04                                   inc		b								; down a rowc
 266+ ECAE D1                                   pop		de								; de = from to (and b also = current)
 267+ ECAF 14                                   inc		d
 268+ ECB0 7B                                   ld		a,e								; while e >= d
 269+ ECB1 BA                                   cp		d
 270+ ECB2 30 DC                                jr 		nc,.SaveForLoop					; Is this the right point??
 271+ ECB4 C9                                   ret
 272+ ECB5
 273+ ECB5 DD 7C        l2_fill_BoundsTest:     ld      a,ixh
 274+ ECB7 A8                                   xor     b
 275+ ECB8 E6 80                                and     $80
 276+ ECBA 20 17                                jr      nz,.Y0Y1SpanScreen              ; they are opposite signs
 277+ ECBC 78                                   ld      a,b
 278+ ECBD E6 80                                and     $80
 279+ ECBF 28 10                                jr      z,.NotOnScreen                  ; both negative if at least one is negative
 280+ ECC1 DD 7D                                ld      a,ixl                           ; so to get here, both must be positive
 281+ ECC3 A1                                   and     c
 282+ ECC4 E6 80                                and     $80
 283+ ECC6 20 09                                jr      nz,.NotOnScreen                 ; if both ahave bit 7 set of low they are both > 127
 284+ ECC8 DD 7C                                ld      a,ixh
 285+ ECCA A7                                   and     a
 286+ ECCB 28 06                                jr      z,.Y0Y1SpanScreen               ; so if Y0 is low byte only then its between 0 and 127
 287+ ECCD 78                                   ld      a,b
 288+ ECCE A7                                   and     a
 289+ ECCF 28 02                                jr      z,.Y0Y1SpanScreen               ; so if YCommon is low byte only then its between 0 and 127
 290+ ECD1              .NotOnScreen:           SetCarryFlag
 290+ ECD1 37          >                        scf
 291+ ECD2 C9                                   ret
 292+ ECD3 C9           .Y0Y1SpanScreen:         ret
 293+ ECD4
 294+ ECD4
 295+ ECD4              ;16 bit soli l2_fill16BottomFlatTriangle BC y0x0 DE x1x2, H YCommon, L Colour"
 296+ ECD4              ;IY Offsets IY=X0 IX=Y0 HL=X1 DE=X2 BC=YCommon A= Colour
 297+ ECD4              l2_fill16BottomFlatTriangle:;break
 298+ ECD4                                      ; test if Y0 and YCommon on screen
 299+ ECD4 DD 22 6E E7  .TestY0YCommon          ld      (l2_Y0),ix
 300+ ECD8 22 72 E7                             ld      (l2_Y1),hl
 301+ ECDB
 302+ ECDB
 303+ ECDB DD 7C                                ld      a,ixh
 304+ ECDD A8                                   xor     b
 305+ ECDE E6 80                                and     $80
 306+ ECE0 20 14                                jr      nz,.Y0Y1SpanScreen              ; they are opposite signs
 307+ ECE2 78                                   ld      a,b
 308+ ECE3 E6 80                                and     $80
 309+ ECE5 C8                                   ret     z                               ; both negative if at least one is negative
 310+ ECE6 DD 7D                                ld      a,ixl                           ; so to get here, both must be positive
 311+ ECE8 A1                                   and     c
 312+ ECE9 E6 80                                and     $80
 313+ ECEB C0                                   ret     nz                              ; if both ahave bit 7 set of low they are both > 127
 314+ ECEC DD 7C                                ld      a,ixh
 315+ ECEE A7                                   and     a
 316+ ECEF 28 05                                jr      z,.Y0Y1SpanScreen               ; so if Y0 is low byte only then its between 0 and 127
 317+ ECF1 78                                   ld      a,b
 318+ ECF2 A7                                   and     a
 319+ ECF3 28 01                                jr      z,.Y0Y1SpanScreen               ; so if YCommon is low byte only then its between 0 and 127
 320+ ECF5 C9                                   ret                                     ;
 321+ ECF6 C9           .Y0Y1SpanScreen:        ret
 322+ ECF7
 323+ ECF7 32 43 E5                             ld      (l2linecolor),a                 ; Set Colour
 324+ ECFA                                      ;CompareHLDE
 325+ ECFA
 326+ ECFA 7B                                   ld      a,e
 327+ ECFB                                      JumpIfAGTENusng d, .x2gtex1
 327+ ECFB BA          >                        cp     d
 327+ ECFC D2 07 ED    >                        jp		nc,.x2gtex1
 328+ ECFF              ;                        ld		a,d                             ; if x0 < x2 goto x2<x1
 329+ ECFF              ;                        cp		e                               ;      list 1 holds x1 down to x0
 330+ ECFF              ;                        ld		ixl,2                           ;      list 2 hols  x2 down to x0
 331+ ECFF              ;                        jr		nc, .x2gtex1                    ;
 332+ ECFF DD 26 01     .x1ltx2:                ld		ixh,1                           ; else list 1 holds x0 down to x1
 333+ ED02 DD 2E 02                             ld		ixl,2                           ;      list 2 hols  x0 down to x2
 334+ ED05 18 06                                jr		.storepoints                    ;
 335+ ED07 DD 26 02     .x2gtex1:               ld		ixh,2                           ;
 336+ ED0A DD 2E 01                             ld		ixl,1                           ;
 337+ ED0D DD E5        .storepoints:           push    ix
 338+ ED0F C5 D5 E5                             push	bc,,de,,hl                      ; save working variables
 339+ ED12 DD 7C                                ld		a,ixh
 340+ ED14 5A                                   ld		e,d                             ; we alreay have bc so its now bc -> hd
 341+ ED15 54                                   ld		d,h
 342+ ED16 CD AD E9                             call	l2_draw_diagonal_save			;l2_store_diagonal(x0,y0,x1,ycommon,l2_LineMinX);
 343+ ED19 E1 D1 C1                             pop		bc,,de,,hl
 344+ ED1C DD E1                                pop     ix
 345+ ED1E C5 E5                                push	bc,,hl
 346+ ED20 54                                   ld		d,h                             ; now its bc -> he
 347+ ED21 DD 7D                                ld		a,ixl
 348+ ED23 CD AD E9                             call	l2_draw_diagonal_save			;l2_store_diagonal(x0,y0,x2,ycommon,l2_LineMaxX);
 349+ ED26 E1 C1                                pop		bc,,hl
 350+ ED28 50           .OldSaveForLoop:           ld		d,b
 351+ ED29 5C                                   ld		e,h								; save loop counters
 352+ ED2A D5           .SaveForLoop:                        push	de								; de = y0ycommon
 353+ ED2B 21 4B E5     .GetFirstHorizontalRow:	ld		hl,l2targetArray1               ; get first row for loop
 354+ ED2E 78                                   ld		a,b
 355+ ED2F ED 31                                add		hl,a							; hl = l2targetArray1 row b
 356+ ED31 7E                                   ld		a,(hl)							;
 357+ ED32 4F                                   ld		c,a								; c = col1 i.e. l2targetarray1[b]
 358+ ED33 21 4B E6                             ld      hl,l2targetArray2
 359+ ED36 78                                   ld      a,b
 360+ ED37 ED 31                                add     hl,a
 361+ ED39              ;                        inc		h								; hl = l2targetArray2 row b if we interleave
 362+ ED39 7E                                   ld		a,(hl)
 363+ ED3A 57                                   ld		d,a								; d = col2 i.e. l2targetarray2[b]
 364+ ED3B 3A 43 E5     .SetColour:             ld		a,(l2linecolor)
 365+ ED3E 5F                                   ld		e,a								; de = to colour
 366+ ED3F C5           .SavePoints:            push	bc								; bc = rowcol
 367+ ED40 25                                   dec		h
 368+ ED41 E5                                   push	hl								; hl = l2targetArray1[b]
 369+ ED42 CD 94 E4     .DoLine:	            call	l2_draw_horz_line_to
 370+ ED45 E1                                   pop		hl
 371+ ED46 C1                                   pop		bc
 372+ ED47 04                                   inc		b								; down a rowc
 373+ ED48 D1                                   pop		de								; de = from to (and b also = current)
 374+ ED49 14                                   inc		d
 375+ ED4A 7B                                   ld		a,e								; while e >= d
 376+ ED4B BA                                   cp		d
 377+ ED4C 30 DC                                jr 		nc,.SaveForLoop					; Is this the right point??
 378+ ED4E C9                                   ret
 379+ ED4F
 380+ ED4F
 381+ ED4F              ;;;;fnCompareHLDELeadSign:  cpHLDELeadSign
 382+ ED4F              ;;;;                        ret
 383+ ED4F              ;;;;
 384+ ED4F              ;;;;l2_bottomX              DW 0
 385+ ED4F              ;;;;l2_bottomY              DW 0
 386+ ED4F              ;;;;l2_leftX                DW 0
 387+ ED4F              ;;;;l2_rightX               DW 0
 388+ ED4F              ;;;;l2_commonTopY           DW 0
 389+ ED4F              ;;;;l2_fillTopY             DB 0
 390+ ED4F              ;;;;l2_fillBottomY          DB 0
 391+ ED4F              ;;;;;; l2_fillTopFlatTriangleSigned IY[01] bottomX[23] bottom Y [45]X1 [67]X2 [89]Common Top Y
 392+ ED4F              ;;;;;; Note values must be 2's c not lead sign
 393+ ED4F              ;;;;l2_fillTopFlatTriangleSigned: break
 394+ ED4F              ;;;;                        ld      hl,iy                          ; transfer to local copy off IY tables
 395+ ED4F              ;;;;                        ld      b,10                            ;
 396+ ED4F              ;;;;                        ld      de,l2_commonY                  ;
 397+ ED4F              ;;;;                        ldir                                   ;
 398+ ED4F              ;;;;                        ld      hl,(l2_leftX)
 399+ ED4F              ;;;;                        ld      de,(l2_rightX)
 400+ ED4F              ;;;;                        call    fnCompareHLDELeadSign
 401+ ED4F              ;;;;                        jr      c,.x1LTX2
 402+ ED4F              ;;;;                        ld      (l2_leftX),de                   ; swap them over to simplify later code
 403+ ED4F              ;;;;                        ld      (l2_rightX),hl
 404+ ED4F              ;;;;.x1ltx2:                call    l2_save_diagnonal_signed_1      ; will also set the fillTopX and bottomY, if Y top & bottom off screen will set Carry flag
 405+ ED4F              ;;;;                        ret     c
 406+ ED4F              ;;;;                        call    l2_save_diagnonal_signed_2
 407+ ED4F              ;;;;.DrawLines:             ld      a,(l2_fillTopY)
 408+ ED4F              ;;;;                        ld		d,a
 409+ ED4F              ;;;;                        ld      a,(l2_fillBottomY)              ; will always draw to
 410+ ED4F              ;;;;                        ld      e,a
 411+ ED4F              ;;;;.SaveForLoop:           push	de								; de = y0ycommon
 412+ ED4F              ;;;;.GetFirstHorizontalRow:	ld		hl,l2targetArray1               ; get first row for loop
 413+ ED4F              ;;;;                        ld		a,b
 414+ ED4F              ;;;;                        add		hl,a							; hl = l2targetArray1 row b
 415+ ED4F              ;;;;                        ld		a,(hl)							;
 416+ ED4F              ;;;;                        ld		c,a								; c = col1 i.e. l2targetarray1[b]
 417+ ED4F              ;;;;                        ld      hl,l2targetArray2
 418+ ED4F              ;;;;                        ld      a,b
 419+ ED4F              ;;;;                        add     hl,a
 420+ ED4F              ;;;;;                        inc		h								; hl = l2targetArray2 row b if we interleave
 421+ ED4F              ;;;;                        ld		a,(hl)
 422+ ED4F              ;;;;                        ld		d,a								; d = col2 i.e. l2targetarray2[b]
 423+ ED4F              ;;;;.SetColour:             ld		a,(l2linecolor)
 424+ ED4F              ;;;;                        ld		e,a								; de = to colour
 425+ ED4F              ;;;;.SavePoints:            push	bc								; bc = rowcol
 426+ ED4F              ;;;;                        dec		h
 427+ ED4F              ;;;;                        push	hl								; hl = l2targetArray1[b]
 428+ ED4F              ;;;;.DoLine:	            call	l2_draw_horz_line_to
 429+ ED4F              ;;;;                        pop		hl
 430+ ED4F              ;;;;                        pop		bc
 431+ ED4F              ;;;;                        inc		b								; down a rowc
 432+ ED4F              ;;;;                        pop		de								; de = from to (and b also = current)
 433+ ED4F              ;;;;                        inc		d
 434+ ED4F              ;;;;                        ld		a,e								; while e >= d
 435+ ED4F              ;;;;                        cp		d
 436+ ED4F              ;;;;                        jr 		nc,.SaveForLoop					; Is this the right point??
 437+ ED4F              ;;;;                        ret
 438+ ED4F
# file closed: ./Layer2Graphics/asm_l2_fill_triangle.asm
 231  ED4F                  INCLUDE "./Layer2Graphics/layer2_plot_circle.asm"
# file opened: ./Layer2Graphics/layer2_plot_circle.asm
   1+ ED4F
   2+ ED4F 00 00        l2_circle_pos		DW 0
   3+ ED51 00           l2_circle_colour	DB 0
   4+ ED52 00           l2_circle_radius	DB 0
   5+ ED53 00           l2_circle_x			DB 0
   6+ ED54 00           l2_circle_y			DB 0
   7+ ED55 00           l2_circle_d			DB 0
   8+ ED56
   9+ ED56 00 00 00...  l2_circle_xHeap 	DS 2*66
  10+ EDDA 00 00 00...  l2_circle_yHeap     DS 2*66
  11+ EE5E 00           l2_circle_heap_size DB 0
  12+ EE5F 00 00        l2_circle_clip_y    DW 0
  13+ EE61 00 00        l2_circle_clip_x    DW 0
  14+ EE63 00           l2_circle_flag      DB 0
  15+ EE64 00           l2_circle_counter   DB 0
  16+ EE65              ;Sine table
  17+ EE65              ;FOR I%, 0, 31
  18+ EE65              ;
  19+ EE65              ; N = ABS(SIN((I% / 64) * 2 * PI))
  20+ EE65              ;
  21+ EE65              ; IF N >= 1
  22+ EE65              ;  EQUB 255
  23+ EE65              ; ELSE
  24+ EE65              ;  EQUB INT(256 * N + 0.5)
  25+ EE65              ; ENDIF
  26+ EE65              ;
  27+ EE65              ;NEXT
  28+ EE65              ;---------------------------------------------------------------------------------------------------------------------------------
  29+ EE65              ; in HL = xPixelPos, DE = yPixelPos, A = Radius
  30+ EE65              ;IFDEF   CIRCLE2
  31+ EE65              ;;;;+l2_circle_clipped:	ld		(l2_circle_radius),a
  32+ EE65              ;;;;+					ld		(l2_circle_clip_y),de
  33+ EE65              ;;;;+					ld		(l2_circle_clip_x),hl
  34+ EE65              ;;;;+					ZeroA
  35+ EE65              ;;;;+					ld		(l2_circle_heap_size),a
  36+ EE65              ;;;;+					ld		(l2_circle_counter),a
  37+ EE65              ;;;;+					dec		a
  38+ EE65              ;;;;+					ld		(l2_circle_flag),a
  39+ EE65              ;;;;+.CircleLoop:		call	SinCounter						; a = sin (counter) * 256
  40+ EE65              ;;;;+					ld		d,a
  41+ EE65              ;;;;+					ld		a,(l2_circle_radius)
  42+ EE65              ;;;;+					ld		e,a
  43+ EE65              ;;;;+					mul										; de = k * sin (counter) so d = k * sin (counter) / 256
  44+ EE65              ;;;;+					ld		e,d								; using de as TA
  45+ EE65              ;;;;+					ld		d,0
  46+ EE65              ;;;;+					ld		a,(l2_circle_counter)
  47+ EE65              ;;;;+					JumpIfALTNusng 33,.RightHalf
  48+ EE65              ;;;;+.LeftHalf:			NegateDE								; if >= 33 then DE = de * -1 (2's c)
  49+ EE65              ;;;;+					K6 = de + l2_circle_clip_x
  50+ EE65              ;;;;+					call	CosCounter
  51+ EE65              ;;;;+					ld		d,a
  52+ EE65              ;;;;+					ld		a,(l2_circla_radius)
  53+ EE65              ;;;;+					mul		de
  54+ EE65              ;;;;+					ld		e,d
  55+ EE65              ;;;;+					ld		d,0
  56+ EE65              ;;;;+					a 		= l2_counter + 15 mod 64
  57+ EE65              ;;;;+					JumpIfALTNusng	33, .BottomHalf
  58+ EE65              ;;;;+.TopHalf:			NegateDE
  59+ EE65              ;;;;+					K62 = de + l2_circle_clip_y
  60+ EE65              ;;;;+					ld		a,(l2_circle_flag)
  61+ EE65              ;;;;+					JumpIfAIsZZero		.SkipFlagUpdate
  62+ EE65              ;;;;+					inc		a
  63+ EE65              ;;;;+					ld		(l2_circle_flag),a
  64+ EE65              ;;;;+.SkipFlagUpdate:
  65+ EE65              ;;;;+
  66+ EE65              ;;;;+                X = K * SIN (CNT + 16) (i.e X = K * COS (CNT)
  67+ EE65              ;;;;+                A = (CNT + 15) mod 64
  68+ EE65              ;;;;+                if  A >= 33     ; top half of circle
  69+ EE65              ;;;;+                    X = neg X
  70+ EE65              ;;;;+                    T = negative
  71+ EE65              ;;;;+                call    Bline (draw segment)
  72+ EE65              ;;;;+                        K6(32) = TX + K4(10) = y corrc of center + new point
  73+ EE65              ;;;;+                        if flag <> 0
  74+ EE65              ;;;;+                            flag ++ (as flag initially will be $FF so go to 0)
  75+ EE65              ;;;;+                        BL5:
  76+ EE65              ;;;;+                        if LSY2[LSP-1] <> $FF and LSY2 [LSP1] <> $FF    (BL5)
  77+ EE65              ;;;;+                            X15 [0 1] = K5(10)                      (BL1)
  78+ EE65              ;;;;+                            X15 [2 3] = K5(32)
  79+ EE65              ;;;;+                            X15 [4 5] = K6(10)
  80+ EE65              ;;;;+                            X15 [6 7] = K6(32)
  81+ EE65              ;;;;+                            call clip X1Y1 to X2Y2
  82+ EE65              ;;;;+                            if Line off scren goto BL5
  83+ EE65              ;;;;+                            IF swap <> 0
  84+ EE65              ;;;;+                                swap X1Y1 with X2Y2
  85+ EE65              ;;;;+                            Y = LAP                                 (BL9)
  86+ EE65              ;;;;+                            A = LSY2-1 [Y]
  87+ EE65              ;;;;+                            if A = $FF
  88+ EE65              ;;;;+                                LSX2[Y] = X1
  89+ EE65              ;;;;+                                LSY2[Y] = Y1
  90+ EE65              ;;;;+                                Y++
  91+ EE65              ;;;;+
  92+ EE65              ;;;;+                            Store X2 in LSX2(Y)                     (BL8)
  93+ EE65              ;;;;+                            Store Y2 in lSY2(y)
  94+ EE65              ;;;;+                            call    DrawLine from (X1 Y1 to X2 Y2)
  95+ EE65              ;;;;+                            if  XX13 <> 0 goto BL5
  96+ EE65              ;;;;+                                                                (BL7)
  97+ EE65              ;;;;+                        Copy data for K6(3210) into K5(3210) for next call (K5(10) = x  K5(32) = y)
  98+ EE65              ;;;;+                        CNT = CNT + STP
  99+ EE65              ;;;;+            while CNT < 65
 100+ EE65              ;ENDIF
 101+ EE65              ;---------------------------------------------------------------------------------------------------------------------------------
 102+ EE65              ; ">l2_draw_circle BC = center row col, d = radius, e = colour"
 103+ EE65 7B           l2_draw_circle:     ld		a,e
 104+ EE66 32 0C EF                         ld		(.PlotPixel+1),a
 105+ EE69 7A                               ld		a,d								; get radius
 106+ EE6A A7                               and		a
 107+ EE6B C8                               ret		z
 108+ EE6C FE 01                            cp		1
 109+ EE6E CA 23 EF                         jp		z,CircleSinglepixel
 110+ EE71 ED 43 9B EE                      ld		(.Plot1+1),bc					; save origin into DE reg in code
 111+ EE75 DD 67                            ld		ixh,a							; ixh = raidus
 112+ EE77 DD 2E 00                         ld		ixl,0
 113+ EE7A 26 00        .calcd:	            ld		h,0
 114+ EE7C 6F                               ld		l,a
 115+ EE7D 29                               add		hl,hl							; hl = r * 2
 116+ EE7E EB                               ex		de,hl							; de = r * 2
 117+ EE7F 21 03 00                         ld		hl,3
 118+ EE82 A7                               and		a
 119+ EE83 ED 52                            sbc		hl,de							; hl = 3 - (r * 2)
 120+ EE85 44                               ld		b,h
 121+ EE86 4D                               ld		c,l								; bc = 3 - (r * 2)
 122+ EE87 21 01 00     .calcdelta:         ld		hl,1
 123+ EE8A 16 00                            ld		d,0
 124+ EE8C DD 5D                            ld		e,ixl
 125+ EE8E A7                               and		a
 126+ EE8F ED 52                            sbc		hl,de
 127+ EE91 11 01 00     .Setde1:            ld		de,1
 128+ EE94 DD 7C        .CircleLoop:        ld		a,ixh
 129+ EE96 DD BD                            cp		ixl
 130+ EE98 D8                               ret		c
 131+ EE99 D9           .ProcessLoop:	    exx
 132+ EE9A 11 00 00     .Plot1:             ld		de,0
 133+ EE9D 7B                               ld		a,e
 134+ EE9E DD 85                            add		a,ixl
 135+ EEA0 4F                               ld		c,a
 136+ EEA1 7A                               ld		a,d
 137+ EEA2 DD 84                            add		a,ixh
 138+ EEA4 47                               ld		b,a
 139+ EEA5 CD 0B EF                         call	.PlotPixel			;CX+X,CY+Y
 140+ EEA8 7B           .Plot2:             ld 		a,e
 141+ EEA9 DD 95                            sub 	ixl
 142+ EEAB 4F                               ld 		c,a
 143+ EEAC 7A                               ld 		a,d
 144+ EEAD DD 84                            add 	a,ixh
 145+ EEAF 47                               ld		b,a
 146+ EEB0 CD 0B EF                         call	.PlotPixel			;CX-X,CY+Y
 147+ EEB3 7B           .Plot3:             ld 		a,e
 148+ EEB4 DD 85                            add		a,ixl
 149+ EEB6 4F                               ld 		c,a
 150+ EEB7 7A                               ld 		a,d
 151+ EEB8 DD 94                            sub 	ixh
 152+ EEBA 47                               ld 		b,a
 153+ EEBB CD 0B EF                         call	.PlotPixel			;CX+X,CY-Y
 154+ EEBE 7B           .Plot4:             ld 		a,e
 155+ EEBF DD 95                            sub 	ixl
 156+ EEC1 4F                               ld 		c,a
 157+ EEC2 7A                               ld 		a,d
 158+ EEC3 DD 94                            sub 	ixh
 159+ EEC5 47                               ld 		b,a
 160+ EEC6 CD 0B EF                         call	.PlotPixel			;CX-X,CY-Y
 161+ EEC9 7A           .Plot5:	            ld 		a,d
 162+ EECA DD 85                            add 	a,ixl
 163+ EECC 47                               ld 		b,a
 164+ EECD 7B                               ld 		a,e
 165+ EECE DD 84                            add 	a,ixh
 166+ EED0 4F                               ld 		c,a
 167+ EED1 CD 0B EF                         call	.PlotPixel			;CY+X,CX+Y
 168+ EED4 7A           .Plot6:	            ld 		a,d
 169+ EED5 DD 95                            sub 	ixl
 170+ EED7 47                               ld 		b,a
 171+ EED8 7B                               ld 		a,e
 172+ EED9 DD 84                            add 	a,ixh
 173+ EEDB 4F                               ld 		c,a
 174+ EEDC CD 0B EF                         call	.PlotPixel			;CY-X,CX+Y
 175+ EEDF 7A           .Plot7:	            ld 		a,d
 176+ EEE0 DD 85                            add 	a,ixl
 177+ EEE2 47                               ld 		b,a
 178+ EEE3 7B                               ld 		a,e
 179+ EEE4 DD 94                            sub 	ixh
 180+ EEE6 4F                               ld 		c,a
 181+ EEE7 CD 0B EF                         call	.PlotPixel			;CY+X,CX-Y
 182+ EEEA 7A           .Plot8:	            ld 		a,d
 183+ EEEB DD 95                            sub 	ixl
 184+ EEED 47                               ld		b,a
 185+ EEEE 7B                               ld 		a,e
 186+ EEEF DD 94                            sub 	ixh
 187+ EEF1 4F                               ld 		c,a
 188+ EEF2 CD 0B EF                         call	.PlotPixel			;CY-X,CX-Y
 189+ EEF5 D9                               exx
 190+ EEF6 CB 7C        .IncrementCircle:	bit     7,h				; Check for Hl<=0
 191+ EEF8 28 03                            jr z,   .draw_circle_1
 192+ EEFA 19                               add hl,de			; Delta=Delta+D1
 193+ EEFB 18 05                            jr      .draw_circle_2		;
 194+ EEFD 09           .draw_circle_1:		add     hl,bc			; Delta=Delta+D2
 195+ EEFE 03                               inc     bc
 196+ EEFF 03                               inc     bc				; D2=D2+2
 197+ EF00 DD 25                            dec     ixh				; Y=Y-1
 198+ EF02 03           .draw_circle_2:		inc bc				; D2=D2+2
 199+ EF03 03                               inc bc
 200+ EF04 13                               inc de				; D1=D1+2
 201+ EF05 13                               inc de
 202+ EF06 DD 2C                            inc ixl				; X=X+1
 203+ EF08 C3 94 EE                         jp      .CircleLoop
 204+ EF0B 3E 00        .PlotPixel:         ld		a,0                  ; This was originally indirect, where as it neeed to be value
 205+ EF0D D5 C5 E5                         push	de,,bc,,hl
 206+ EF10                                  l2_plot_macro; call 	l2_plot_pixel_y_test
 206+ EF10 78          >                        ld      a,b
 206+ EF11             >                        JumpIfAGTENusng 192 ,.NoPlot
 206+ EF11 FE C0       >                        cp     192
 206+ EF13 D2 1F EF    >                        jp		nc,.NoPlot
 206+ EF16 69          >                        ld      l,c
 206+ EF17 CD 68 E0    >                        call    asm_l2_row_bank_select
 206+ EF1A 67          >                        ld      h,a
 206+ EF1B 3A A7 F1    >                        ld      a,(line_gfx_colour)
 206+ EF1E 77          >                        ld      (hl),a
 206+ EF1F             >.NoPlot:
 207+ EF1F E1 C1 D1                         pop		de,,bc,,hl
 208+ EF22 C9                               ret
 209+ EF23 7B           CircleSinglepixel:  ld		a,e
 210+ EF24                                  l2_plot_macro; call	l2_plot_pixel_y_test
 210+ EF24 78          >                        ld      a,b
 210+ EF25             >                        JumpIfAGTENusng 192 ,.NoPlot
 210+ EF25 FE C0       >                        cp     192
 210+ EF27 D2 33 EF    >                        jp		nc,.NoPlot
 210+ EF2A 69          >                        ld      l,c
 210+ EF2B CD 68 E0    >                        call    asm_l2_row_bank_select
 210+ EF2E 67          >                        ld      h,a
 210+ EF2F 3A A7 F1    >                        ld      a,(line_gfx_colour)
 210+ EF32 77          >                        ld      (hl),a
 210+ EF33             >.NoPlot:
 211+ EF33 C9                               ret
 212+ EF34
 213+ EF34              ; ">l2_draw_clipped_circle HL = Center X 2's c, DE = Center Y 2's c = center , c = radius, b = colour"
 214+ EF34 43           l2_draw_clipped_circle:     ld		b,e                     ; save Colour
 215+ EF35 32 AD F0                         ld		(.PlotPixel+1),a
 216+ EF38 79                               ld		a,c								; get radius
 217+ EF39                                  ReturnIfAIsZero
 217+ EF39 A7          >                        and     a
 217+ EF3A C8          >                        ret     z
 218+ EF3B                                  JumpIfAEqNusng  1, .circleSinglepixel
 218+ EF3B FE 01       >                        cp     1
 218+ EF3D CA C6 F0    >                        jp      z,.circleSinglepixel
 219+ EF40 ED 53 6D EF                      ld		(.Plot1Y+1),de					; save origin into DE and HL
 220+ EF44 22 70 EF                         ld      (.Plot1X+1),hl                  ; .
 221+ EF47 DD 67                            ld		ixh,a							; ixh = raidus
 222+ EF49 DD 2E 00                         ld		ixl,0						    ; ixl = 0
 223+ EF4C 26 00        .calcd:	            ld		h,0                             ; hl = radius
 224+ EF4E 6F                               ld		l,a                             ; .
 225+ EF4F 29                               add		hl,hl							; hl = r * 2
 226+ EF50 EB                               ex		de,hl							; de = r * 2
 227+ EF51 21 03 00                         ld		hl,3                            ; hl = 3 - (r * 2)
 228+ EF54 A7                               and		a                               ; .
 229+ EF55 ED 52                            sbc		hl,de							; .
 230+ EF57 44                               ld		b,h                             ; bc = 3 - (r * 2)
 231+ EF58 4D                               ld		c,l								; .
 232+ EF59 21 01 00     .calcdelta:         ld		hl,1                            ; hl = 1
 233+ EF5C 16 00                            ld		d,0                             ; de = ixl
 234+ EF5E DD 5D                            ld		e,ixl                           ;
 235+ EF60 A7                               and		a                               ;
 236+ EF61 ED 52                            sbc		hl,de                           ; hl = 1 - radius
 237+ EF63 11 01 00     .Setde1:            ld		de,1                            ; de = 1
 238+ EF66              .CircleLoop:        ReturnIfRegLTNusng ixh, ixl             ; if radius > ixl counter
 238+ EF66 DD 7C       >                        ld      a,ixh
 238+ EF68 DD BD       >                        cp      ixl
 238+ EF6A D8          >                        ret	    c
 239+ EF6B D9           .ProcessLoop:	    exx                                     ; save all bc,de,hl registers
 240+ EF6C 11 00 00     .Plot1Y:            ld		de,0                            ; this is Y coord
 241+ EF6F 21 00 00     .Plot1X:            ld      hl,0                            ; this is x coord
 242+ EF72 E5 D5 C5                         push    hl,,de,,bc                      ; save bc +3
 243+ EF75 06 00                            ld      b,0
 244+ EF77 DD 4D                            ld      c,ixl
 245+ EF79                                  ClearCarryFlag
 245+ EF79 B7          >                        or a
 246+ EF7A ED 4A                            adc     hl,bc
 247+ EF7C C1                               pop     bc                              ; can optimise, perhaps use iy instead of bc or just optimise push pop and jump to an overall .Plot1Done and minimise push pops + 2
 248+ EF7D                                  JumpIfRegIsNotZero  h,.Plot1Done        ; if h <> 0 then hl < 0 or hl > 255
 248+ EF7D 7C          >                        ld      a,h
 248+ EF7E A7          >                        and     a
 248+ EF7F C2 94 EF    >                        jp	    nz,.Plot1Done
 249+ EF82 EB                               ex      de,hl                           ; now de = x coord calculated
 250+ EF83 C5                               push    bc                              ; + 3
 251+ EF84                                  ClearCarryFlag
 251+ EF84 B7          >                        or a
 252+ EF85 06 00                            ld      b,0
 253+ EF87 DD 4D                            ld      c,ixl
 254+ EF89 ED 4A                            adc     hl,bc
 255+ EF8B C1                               pop     bc                              ; + 2
 256+ EF8C                                  JumpIfRegIsNotZero  h,.Plot1Done        ; if h <> 0 then hl < 0 or hl > 255
 256+ EF8C 7C          >                        ld      a,h
 256+ EF8D A7          >                        and     a
 256+ EF8E C2 94 EF    >                        jp	    nz,.Plot1Done
 257+ EF91 CD AC F0                         call	.PlotPixel	            		;CX+X,CY+Y using DE = x and hl = y *** Note if we order plot 1 to 8 we can selectivley jump past many on elimiation check
 258+ EF94 D1 E1        .Plot1Done:         pop     hl,,de                          ; get de (y) and hl (x) back but reversed as the next plot expected the to be reversed from the ex de,hl above  + 0
 259+ EF96 E5 D5 C5     .Plot2:             push    hl,,de,,bc                      ; e.g  do all CX + X first, so plot1, plot3 and just one check for cx + x off screen
 260+ EF99 06 00                            ld      b,0                             ;                              plot2, plot8 for cx - x
 261+ EF9B DD 4D                            ld      c,ixl                           ;                              plot4, plot5 for cy + x  ** Need to check the comments on each plot are correct
 262+ EF9D                                  ClearCarryFlag                          ;                              plot6        for cy - x
 262+ EF9D B7          >                        or a
 263+ EF9E ED 42                            sbc     hl,bc                           ;                              plot7 is last one
 264+ EFA0 C1                               pop     bc                              ;
 265+ EFA1                                  JumpIfRegIsNotZero  h,.Plot2Done        ;
 265+ EFA1 7C          >                        ld      a,h
 265+ EFA2 A7          >                        and     a
 265+ EFA3 C2 B8 EF    >                        jp	    nz,.Plot2Done
 266+ EFA6 EB                               ex      de,hl
 267+ EFA7 C5                               push    bc
 268+ EFA8 06 00                            ld      b,0
 269+ EFAA DD 4D                            ld      c,ixl
 270+ EFAC                                  ClearCarryFlag
 270+ EFAC B7          >                        or a
 271+ EFAD ED 4A                            adc     hl,bc
 272+ EFAF C1                               pop     bc
 273+ EFB0                                  JumpIfRegIsNotZero  h,.Plot2Done
 273+ EFB0 7C          >                        ld      a,h
 273+ EFB1 A7          >                        and     a
 273+ EFB2 C2 B8 EF    >                        jp	    nz,.Plot2Done
 274+ EFB5 CD AC F0                         call	.PlotPixel	                    ; CX-X,CY+Y
 275+ EFB8 E1 D1        .Plot2Done:         pop     de,,hl
 276+ EFBA E5 D5 C5     .Plot3:             push    hl,,de,,bc
 277+ EFBD 06 00                            ld      b,0
 278+ EFBF DD 4D                            ld      c,ixl
 279+ EFC1                                  ClearCarryFlag
 279+ EFC1 B7          >                        or a
 280+ EFC2 ED 4A                            adc     hl,bc
 281+ EFC4 C1                               pop     bc
 282+ EFC5                                  JumpIfRegIsNotZero  h,.Plot3Done
 282+ EFC5 7C          >                        ld      a,h
 282+ EFC6 A7          >                        and     a
 282+ EFC7 C2 DC EF    >                        jp	    nz,.Plot3Done
 283+ EFCA EB                               ex      de,hl
 284+ EFCB C5                               push    bc
 285+ EFCC 06 00                            ld      b,0
 286+ EFCE DD 4D                            ld      c,ixl
 287+ EFD0                                  ClearCarryFlag
 287+ EFD0 B7          >                        or a
 288+ EFD1 ED 42                            sbc     hl,bc
 289+ EFD3 C1                               pop     bc
 290+ EFD4                                  JumpIfRegIsNotZero  h,.Plot3Done
 290+ EFD4 7C          >                        ld      a,h
 290+ EFD5 A7          >                        and     a
 290+ EFD6 C2 DC EF    >                        jp	    nz,.Plot3Done
 291+ EFD9 CD AC F0                         call	.PlotPixel	                    ; CX+X,CY-Y
 292+ EFDC E1 D1        .Plot3Done:         pop     de,,hl
 293+ EFDE E5 D5 C5     .Plot4:             push    hl,,de,,bc
 294+ EFE1 06 00                            ld      b,0
 295+ EFE3 DD 4D                            ld      c,ixl
 296+ EFE5                                  ClearCarryFlag
 296+ EFE5 B7          >                        or a
 297+ EFE6 ED 42                            sbc     hl,bc
 298+ EFE8 C1                               pop     bc
 299+ EFE9                                  JumpIfRegIsNotZero  h,.Plot4Done
 299+ EFE9 7C          >                        ld      a,h
 299+ EFEA A7          >                        and     a
 299+ EFEB C2 00 F0    >                        jp	    nz,.Plot4Done
 300+ EFEE EB                               ex      de,hl
 301+ EFEF C5                               push    bc
 302+ EFF0 06 00                            ld      b,0
 303+ EFF2 DD 4D                            ld      c,ixl
 304+ EFF4                                  ClearCarryFlag
 304+ EFF4 B7          >                        or a
 305+ EFF5 ED 42                            sbc     hl,bc
 306+ EFF7 C1                               pop     bc
 307+ EFF8                                  JumpIfRegIsNotZero  h,.Plot4Done
 307+ EFF8 7C          >                        ld      a,h
 307+ EFF9 A7          >                        and     a
 307+ EFFA C2 00 F0    >                        jp	    nz,.Plot4Done
 308+ EFFD CD AC F0                         call	.PlotPixel	                    ; CX-X,CY-Y
 309+ F000 E1 D1        .Plot4Done:         pop     de,,hl
 310+ F002 EB           .Plot5:             ex      de,hl
 311+ F003 E5 D5 C5                         push    hl,,de,,bc
 312+ F006 06 00                            ld      b,0
 313+ F008 DD 4D                            ld      c,ixl
 314+ F00A                                  ClearCarryFlag
 314+ F00A B7          >                        or a
 315+ F00B ED 4A                            adc     hl,bc
 316+ F00D C1                               pop     bc
 317+ F00E                                  JumpIfRegIsNotZero  h,.Plot5Done
 317+ F00E 7C          >                        ld      a,h
 317+ F00F A7          >                        and     a
 317+ F010 C2 25 F0    >                        jp	    nz,.Plot5Done
 318+ F013 EB                               ex      de,hl
 319+ F014 C5                               push    bc
 320+ F015 06 00                            ld      b,0
 321+ F017 DD 4D                            ld      c,ixl
 322+ F019                                  ClearCarryFlag
 322+ F019 B7          >                        or a
 323+ F01A ED 4A                            adc     hl,bc
 324+ F01C C1                               pop     bc
 325+ F01D                                  JumpIfRegIsNotZero  h,.Plot5Done
 325+ F01D 7C          >                        ld      a,h
 325+ F01E A7          >                        and     a
 325+ F01F C2 25 F0    >                        jp	    nz,.Plot5Done
 326+ F022 CD AC F0                         call	.PlotPixel	                    ;CY+X,CX+Y
 327+ F025 E1 D1        .Plot5Done:         pop     de,,hl
 328+ F027 EB           .Plot6:             ex      de,hl
 329+ F028 E5 D5 C5                         push    hl,,de,,bc
 330+ F02B 06 00                            ld      b,0
 331+ F02D DD 4D                            ld      c,ixl
 332+ F02F                                  ClearCarryFlag
 332+ F02F B7          >                        or a
 333+ F030 ED 42                            sbc     hl,bc
 334+ F032 C1                               pop     bc
 335+ F033                                  JumpIfRegIsNotZero  h,.Plot6Done
 335+ F033 7C          >                        ld      a,h
 335+ F034 A7          >                        and     a
 335+ F035 C2 4A F0    >                        jp	    nz,.Plot6Done
 336+ F038 EB                               ex      de,hl
 337+ F039 C5                               push    bc
 338+ F03A 06 00                            ld      b,0
 339+ F03C DD 4D                            ld      c,ixl
 340+ F03E                                  ClearCarryFlag
 340+ F03E B7          >                        or a
 341+ F03F ED 4A                            adc     hl,bc
 342+ F041 C1                               pop     bc
 343+ F042                                  JumpIfRegIsNotZero  h,.Plot6Done
 343+ F042 7C          >                        ld      a,h
 343+ F043 A7          >                        and     a
 343+ F044 C2 4A F0    >                        jp	    nz,.Plot6Done
 344+ F047 CD AC F0                         call	.PlotPixel	                    ; CY-X,CX+Y
 345+ F04A E1 D1        .Plot6Done:         pop     de,,hl
 346+ F04C EB           .Plot7:             ex      de,hl
 347+ F04D E5 D5 C5                         push    hl,,de,,bc
 348+ F050 06 00                            ld      b,0
 349+ F052 DD 4D                            ld      c,ixl
 350+ F054                                  ClearCarryFlag
 350+ F054 B7          >                        or a
 351+ F055 ED 4A                            adc     hl,bc
 352+ F057 C1                               pop     bc
 353+ F058                                  JumpIfRegIsNotZero  h,.Plot7Done
 353+ F058 7C          >                        ld      a,h
 353+ F059 A7          >                        and     a
 353+ F05A C2 6F F0    >                        jp	    nz,.Plot7Done
 354+ F05D EB                               ex      de,hl
 355+ F05E C5                               push    bc
 356+ F05F 06 00                            ld      b,0
 357+ F061 DD 4D                            ld      c,ixl
 358+ F063                                  ClearCarryFlag
 358+ F063 B7          >                        or a
 359+ F064 ED 42                            sbc     hl,bc
 360+ F066 C1                               pop     bc
 361+ F067                                  JumpIfRegIsNotZero  h,.Plot7Done
 361+ F067 7C          >                        ld      a,h
 361+ F068 A7          >                        and     a
 361+ F069 C2 6F F0    >                        jp	    nz,.Plot7Done
 362+ F06C CD AC F0                         call	.PlotPixel	                    ; CY+X,CX-Y
 363+ F06F E1 D1        .Plot7Done:         pop     de,,hl
 364+ F071 EB           .Plot8:             ex      de,hl
 365+ F072 E5 D5 C5                         push    hl,,de,,bc
 366+ F075 06 00                            ld      b,0
 367+ F077 DD 4D                            ld      c,ixl
 368+ F079                                  ClearCarryFlag
 368+ F079 B7          >                        or a
 369+ F07A ED 42                            sbc     hl,bc
 370+ F07C C1                               pop     bc
 371+ F07D                                  JumpIfRegIsNotZero  h,.Plot8Done
 371+ F07D 7C          >                        ld      a,h
 371+ F07E A7          >                        and     a
 371+ F07F C2 94 F0    >                        jp	    nz,.Plot8Done
 372+ F082 EB                               ex      de,hl
 373+ F083 C5                               push    bc
 374+ F084 06 00                            ld      b,0
 375+ F086 DD 4D                            ld      c,ixl
 376+ F088                                  ClearCarryFlag
 376+ F088 B7          >                        or a
 377+ F089 ED 42                            sbc     hl,bc
 378+ F08B C1                               pop     bc
 379+ F08C                                  JumpIfRegIsNotZero  h,.Plot8Done
 379+ F08C 7C          >                        ld      a,h
 379+ F08D A7          >                        and     a
 379+ F08E C2 94 F0    >                        jp	    nz,.Plot8Done
 380+ F091 CD AC F0                         call	.PlotPixel	                    ; CY-X,CX-Y
 381+ F094 E1 D1        .Plot8Done:         pop     de,,hl
 382+ F096 D9           .PlotDone:          exx
 383+ F097 CB 7C        .IncrementCircle:	bit     7,h				; Check for Hl<=0
 384+ F099 28 03                            jr z,   .draw_circle_1
 385+ F09B 19                               add hl,de			; Delta=Delta+D1
 386+ F09C 18 05                            jr      .draw_circle_2		;
 387+ F09E 09           .draw_circle_1:		add     hl,bc			; Delta=Delta+D2
 388+ F09F 03                               inc     bc
 389+ F0A0 03                               inc     bc				; D2=D2+2
 390+ F0A1 DD 25                            dec     ixh				; Y=Y-1
 391+ F0A3 03           .draw_circle_2:		inc     bc				; D2=D2+2
 392+ F0A4 03                               inc     bc
 393+ F0A5 13                               inc     de				; D1=D1+2
 394+ F0A6 13                               inc     de
 395+ F0A7 DD 2C                            inc     ixl				; X=X+1
 396+ F0A9 C3 66 EF                         jp      .CircleLoop
 397+ F0AC 3E 00        .PlotPixel:         ld		a,0                  ; This was originally indirect, where as it neeed to be value
 398+ F0AE D5 C5 E5                         push	de,,bc,,hl
 399+ F0B1 45                               ld      b,l                     ; At this point de = x and hl = y
 400+ F0B2 4B                               ld      c,e
 401+ F0B3                                  l2_plot_macro; call 	l2_plot_pixel_y_test
 401+ F0B3 78          >                        ld      a,b
 401+ F0B4             >                        JumpIfAGTENusng 192 ,.NoPlot
 401+ F0B4 FE C0       >                        cp     192
 401+ F0B6 D2 C2 F0    >                        jp		nc,.NoPlot
 401+ F0B9 69          >                        ld      l,c
 401+ F0BA CD 68 E0    >                        call    asm_l2_row_bank_select
 401+ F0BD 67          >                        ld      h,a
 401+ F0BE 3A A7 F1    >                        ld      a,(line_gfx_colour)
 401+ F0C1 77          >                        ld      (hl),a
 401+ F0C2             >.NoPlot:
 402+ F0C2 E1 C1 D1                         pop		de,,bc,,hl
 403+ F0C5 C9                               ret
 404+ F0C6 7B           .circleSinglepixel:  ld		a,e
 405+ F0C7                                  l2_plot_macro; call	l2_plot_pixel_y_test
 405+ F0C7 78          >                        ld      a,b
 405+ F0C8             >                        JumpIfAGTENusng 192 ,.NoPlot
 405+ F0C8 FE C0       >                        cp     192
 405+ F0CA D2 D6 F0    >                        jp		nc,.NoPlot
 405+ F0CD 69          >                        ld      l,c
 405+ F0CE CD 68 E0    >                        call    asm_l2_row_bank_select
 405+ F0D1 67          >                        ld      h,a
 405+ F0D2 3A A7 F1    >                        ld      a,(line_gfx_colour)
 405+ F0D5 77          >                        ld      (hl),a
 405+ F0D6             >.NoPlot:
 406+ F0D6 C9                               ret
# file closed: ./Layer2Graphics/layer2_plot_circle.asm
 232  F0D7                  INCLUDE "./Layer2Graphics/layer2_plot_circle_fill.asm"
# file opened: ./Layer2Graphics/layer2_plot_circle_fill.asm
   1+ F0D7
   2+ F0D7 00           l2_circle_dblx		DB 0
   3+ F0D8 00           l2_circle_dbly		DB 0
   4+ F0D9
   5+ F0D9              ; ">l2_draw_circle_fill BC = center row col, d = radius, e = colour"
   6+ F0D9              ; Note this code currently does not process BC
   7+ F0D9 7B           l2_draw_circle_fill:    ld		a,e
   8+ F0DA 32 70 F1                             ld		(.LineColour+1),a
   9+ F0DD 7A                                   ld		a,d								; get radius
  10+ F0DE A7                                   and		a
  11+ F0DF C8                                   ret		z
  12+ F0E0 FE 01                                cp		1
  13+ F0E2 CA 23 EF                             jp		z,CircleSinglepixel
  14+ F0E5 ED 43 0F F1                          ld		(.Line1+1),bc					; save origin into DE reg in code
  15+ F0E9 DD 67                                ld		ixh,a							; ixh = raidus (x)
  16+ F0EB DD 2E 00                             ld		ixl,0							; ihy = y
  17+ F0EE 26 00        .calcd:	                ld		h,0
  18+ F0F0 6F                                   ld		l,a
  19+ F0F1 29                                   add		hl,hl							; hl = r * 2
  20+ F0F2 EB                                   ex		de,hl							; de = r * 2
  21+ F0F3 21 03 00                             ld		hl,3
  22+ F0F6 A7                                   and		a
  23+ F0F7 ED 52                                sbc		hl,de							; hl = 3 - (r * 2)
  24+ F0F9 44                                   ld		b,h
  25+ F0FA 4D                                   ld		c,l								; bc = 3 - (r * 2)
  26+ F0FB 21 01 00     .calcdelta              ld		hl,1
  27+ F0FE 16 00                                ld		d,0
  28+ F100 DD 5D                                ld		e,ixl
  29+ F102 A7                                   and		a
  30+ F103 ED 52                                sbc		hl,de
  31+ F105 11 01 00     .Setde1	                ld		de,1
  32+ F108 DD 7C        .CircleLoop:            ld		a,ixh
  33+ F10A DD BD                                cp		ixl
  34+ F10C D8                                   ret		c
  35+ F10D D9           .ProcessLoop:	        exx
  36+ F10E 11 00 00     .Line1:                 ld		de,0
  37+ F111 7B                                   ld 		a,e
  38+ F112 DD 95                                sub 	ixl
  39+ F114 4F                                   ld 		c,a
  40+ F115 7A                                   ld 		a,d
  41+ F116 DD 84                                add 	a,ixh
  42+ F118 47                                   ld		b,a
  43+ F119                                      ;; TODO ADD DOUBLE X CALC
  44+ F119 D5                                   push	de
  45+ F11A DD 55                                ld		d,ixl
  46+ F11C CB 22                                sla		d
  47+ F11E CD 6B F1                             call	.PlotLine			;CX-X,CY+Y
  48+ F121 D1                                   pop		de
  49+ F122 7B           .Line2:                 ld 		a,e
  50+ F123 DD 95                                sub		ixl
  51+ F125 4F                                   ld 		c,a
  52+ F126 7A                                   ld 		a,d
  53+ F127 DD 94                                sub 	ixh
  54+ F129 47                                   ld 		b,a
  55+ F12A                                      ;; TODO ADD DOUBLE X CALC
  56+ F12A D5                                   push	de
  57+ F12B DD 55                                ld		d,ixl
  58+ F12D CB 22                                sla		d
  59+ F12F CD 6B F1                             call	.PlotLine			;CX-X,CY-Y
  60+ F132 D1                                   pop		de
  61+ F133 7B           .Line3:	                ld 		a,e
  62+ F134 DD 94                                sub		ixh
  63+ F136 4F                                   ld 		c,a
  64+ F137 7A                                   ld 		a,d
  65+ F138 DD 85                                add 	a,ixl
  66+ F13A 47                                   ld 		b,a
  67+ F13B                                      ;; TODO ADD DOUBLE Y CALC
  68+ F13B D5                                   push	de
  69+ F13C DD 54                                ld		d,ixh
  70+ F13E CB 22                                sla		d
  71+ F140 CD 6B F1                             call	.PlotLine			;CX-Y,CY+x
  72+ F143 D1                                   pop		de
  73+ F144 7B           .Line4:	                ld 		a,e
  74+ F145 DD 94                                sub		ixh
  75+ F147 4F                                   ld 		c,a
  76+ F148 7A                                   ld 		a,d
  77+ F149 DD 95                                sub 	ixl
  78+ F14B 47                                   ld 		b,a
  79+ F14C                                      ;; TODO ADD DOUBLE Y CALC
  80+ F14C D5                                   push	de
  81+ F14D DD 54                                ld		d,ixh
  82+ F14F CB 22                                sla		d
  83+ F151 CD 6B F1                             call	.PlotLine			;CX-Y,CY+x
  84+ F154 D1                                   pop		de
  85+ F155 D9                                   exx
  86+ F156 CB 7C        .IncrementCircle:	    bit 7,h				; Check for Hl<=0
  87+ F158 28 03                                jr z,.draw_circle_1
  88+ F15A 19                                   add hl,de			; Delta=Delta+D1
  89+ F15B 18 05                                jr .draw_circle_2		;
  90+ F15D 09           .draw_circle_1:		    add hl,bc			; Delta=Delta+D2
  91+ F15E 03                                   inc bc
  92+ F15F 03                                   inc bc				; D2=D2+2
  93+ F160 DD 25                                dec ixh				; Y=Y-1
  94+ F162 03           .draw_circle_2:		    inc bc				; D2=D2+2
  95+ F163 03                                   inc bc
  96+ F164 13                                   inc de				; D1=D1+2
  97+ F165 13                                   inc de
  98+ F166 DD 2C                                inc ixl				; X=X+1
  99+ F168 C3 08 F1                             jp .CircleLoop
 100+ F16B D5 C5 E5 F5  .PlotLine:              push	de,,bc,,hl,,af
 101+ F16F 3E 00        .LineColour:	        ld		a,0         ; circle colur
 102+ F171 5F                                   ld      e,a
 103+ F172 CD 5B E4                             call 	l2_draw_horz_line
 104+ F175 F1 E1 C1 D1                          pop     de,,bc,,hl,,af
 105+ F179 C9                                   ret
 106+ F17A
# file closed: ./Layer2Graphics/layer2_plot_circle_fill.asm
 233  F17A                  INCLUDE "./Layer2Graphics/l2_draw_any_line.asm"
# file opened: ./Layer2Graphics/l2_draw_any_line.asm
   1+ F17A              ; ">l2_draw_any_line, bc = y0,x0 de=y1,x1,a=color: determines if its horizontal, vertical or diagonal then hands off the work"
   2+ F17A 08           l2_draw_any_line:       ex		af,af'              ; save colour into a'
   3+ F17B 79                                   ld		a,c                 ; if x and e are the same its horizontal
   4+ F17C BB                                   cp		e
   5+ F17D 28 08                                jr		z,.HorizontalLineCheck
   6+ F17F 78                                   ld		a,b                 ; if b and d are the same its vertica;
   7+ F180 BA                                   cp		d
   8+ F181 28 0E                                jr		z,.VerticalLine
   9+ F183              ; use jp and get a free ret instruction optimisation
  10+ F183 08           .DiagonalLine:		    ex		af,af'			     ; get colour back into a
  11+ F184 C3 9D EA                             jp		l2_draw_diagonal
  12+ F187
  13+ F187 78           .HorizontalLineCheck:   ld      a,b
  14+ F188 BA                                   cp      d
  15+ F189 28 0B                                jr      z, .SinglePixel
  16+ F18B 08           .HorizontalLine:        ex		af,af'              ; get colour back into a
  17+ F18C 53                                   ld		d,e				    ; set d as target right pixel
  18+ F18D 5F                                   ld		e,a				    ; e holds colour on this call
  19+ F18E C3 94 E4                             jp		l2_draw_horz_line_to
  20+ F191 08           .VerticalLine:          ex		af,af'
  21+ F192 5F                                   ld		e,a				    ; e holds colour on this call
  22+ F193 C3 2C E5                             jp		l2_draw_vert_line_to
  23+ F196 08           .SinglePixel:           ex		af,af'              ; get colour back into a
  24+ F197                                      l2_plot_macro; jp      l2_plot_pixel
  24+ F197 78          >                        ld      a,b
  24+ F198             >                        JumpIfAGTENusng 192 ,.NoPlot
  24+ F198 FE C0       >                        cp     192
  24+ F19A D2 A6 F1    >                        jp		nc,.NoPlot
  24+ F19D 69          >                        ld      l,c
  24+ F19E CD 68 E0    >                        call    asm_l2_row_bank_select
  24+ F1A1 67          >                        ld      h,a
  24+ F1A2 3A A7 F1    >                        ld      a,(line_gfx_colour)
  24+ F1A5 77          >                        ld      (hl),a
  24+ F1A6             >.NoPlot:
  25+ F1A6 C9                                   ret
  26+ F1A7              ;......................................................
  27+ F1A7
# file closed: ./Layer2Graphics/l2_draw_any_line.asm
 234  F1A7                  INCLUDE "./Layer2Graphics/l2_draw_line_v2.asm"
# file opened: ./Layer2Graphics/l2_draw_line_v2.asm
   1+ F1A7              ; ******************************************************************************
   2+ F1A7              ;
   3+ F1A7              ;	Draw a pixel line from (x0,y0) defined in (COORDS) - the current plot
   4+ F1A7              ;	coordinate, to the relative distance points (x0+x,y0+y).
   5+ F1A7              ;
   6+ F1A7              ;	Design & programming by Gunther Strube,	Copyright (C) InterLogic 1995
   7+ F1A7              ;
   8+ F1A7              ;	The (COORDS+0)	pointer contains the current y coordinate, (COORDS+1) the
   9+ F1A7              ;	current x coordinate. The main program should reset the (COORDS) variables
  10+ F1A7              ;	before using line drawing.
  11+ F1A7              ;
  12+ F1A7              ;	The routine checks the range of specified coordinates which is the
  13+ F1A7              ;	boundaries of the graphics area (256x64	pixels).
  14+ F1A7              ;	If a boundary error occurs the routine exits automatically.	This may be
  15+ F1A7              ;	useful if you are trying to draw a line longer than allowed. Only the
  16+ F1A7              ;	visible part will be drawn.
  17+ F1A7              ;
  18+ F1A7              ;	The hardware graphics memory is organized as (0,0) in the top left corner.
  19+ F1A7              ;
  20+ F1A7              ;	The plot routine is	defined by an address pointer	in IX.
  21+ F1A7              ;
  22+ F1A7              ;	IN:	HL =	move	relative x horisontal points (maximum +/- 255).
  23+ F1A7              ;		DE =	move	relative y vertical	points (maximum +/-	255).
  24+ F1A7              ;		IX =	pointer to plot routine that uses HL = (x,y)	of plot coordinate.
  25+ F1A7              ;
  26+ F1A7              ;	OUT:	None.
  27+ F1A7              ;
  28+ F1A7              ;	Registers	used	by routine:
  29+ F1A7              ;		   N	:	B, loop counter
  30+ F1A7              ;		   i	:	line	balance variable
  31+ F1A7              ;		   x	:	H/L,	horisontal, vertical distance	variables
  32+ F1A7              ;		   y	:	H/L,	horisontal, vertical distance	variables
  33+ F1A7              ;	  (x0,y0)	:	(h,l)
  34+ F1A7              ;	  direc_x	:	d, horisontal step increment
  35+ F1A7              ;	  direc_y	:	e, vertical step increment
  36+ F1A7              ;		 ddx	:	b, horisontal step increment
  37+ F1A7              ;		 ddy	:	c, vertical step increment
  38+ F1A7              ;
  39+ F1A7              ;		DE, A work registers.
  40+ F1A7              ;
  41+ F1A7              ; The algorithm in pseudo-code:
  42+ F1A7              ;
  43+ F1A7              ;	direc_x =	SGN x: direc_y	= SGN y
  44+ F1A7              ;	x = ABS x: y =	ABS y
  45+ F1A7              ;
  46+ F1A7              ;	if x	>= y
  47+ F1A7              ;		if x+y=0 then return
  48+ F1A7              ;		H = x
  49+ F1A7              ;		L = y
  50+ F1A7              ;		ddx = direc_x
  51+ F1A7              ;		ddy = 0
  52+ F1A7              ;	else
  53+ F1A7              ;		H = y
  54+ F1A7              ;		L = x
  55+ F1A7              ;		ddx = 0
  56+ F1A7              ;		ddy = direc_y
  57+ F1A7              ;	endif
  58+ F1A7              ;
  59+ F1A7              ;	B = H
  60+ F1A7              ;	i = INT(B/2)
  61+ F1A7              ;	FOR N=B TO 1 STEP -1
  62+ F1A7              ;		i = i + L
  63+ F1A7              ;		if i	< H
  64+ F1A7              ;			ix =	ddx
  65+ F1A7              ;			iy =	ddy
  66+ F1A7              ;		else
  67+ F1A7              ;			i = i - H
  68+ F1A7              ;			ix =	direc_x
  69+ F1A7              ;			iy =	direc_y
  70+ F1A7              ;		endif
  71+ F1A7              ;		x0 =	x0 +	ix
  72+ F1A7              ;		y0 =	y0 +	iy
  73+ F1A7              ;		plot	(x0,y0)
  74+ F1A7              ;	NEXT	N
  75+ F1A7              ;
  76+ F1A7              ;
  77+ F1A7              ;	Registers	changed after return:
  78+ F1A7              ;		..BCDEHL/IXIY/af......	same
  79+ F1A7              ;		AF....../..../..bcdehl	different
  80+ F1A7              ;
  81+ F1A7 DF           line_gfx_colour db $DF
  82+ F1A8 00 00        line_gfx_coords	dw 0
  83+ F1AA              LineHLtoDE:
  84+ F1AA 7C           TestMaxY:               ld	a,h ; were h = y or l = y?
  85+ F1AB FE C0                                cp	192
  86+ F1AD 30 26                                jr	nc, exit_line		; y0	coordinate out	of range
  87+ F1AF 7A                                   ld	a,d
  88+ F1B0 FE C0                                cp	192
  89+ F1B2 30 21                                jr	nc, exit_line		; y1	coordinate out	of range
  90+ F1B4 22 A8 F1                             ld	(line_gfx_coords),hl		; the starting	point is now default
  91+ F1B7 E5                                   push	hl
  92+ F1B8 D5                                   push	de
  93+ F1B9 6C                                   ld	l,h				; L = x0
  94+ F1BA 62                                   ld	h,d				; H = x1
  95+ F1BB 7C           distanceX:		        ld	a,h
  96+ F1BC 95                                   sub	l
  97+ F1BD 6F                                   ld	l,a
  98+ F1BE 26 00                                ld	h,0
  99+ F1C0 30 02                                jr	nc, distanceXDone
 100+ F1C2 26 FF                                ld	h,-1
 101+ F1C4 D1           distanceXDone:          pop	de
 102+ F1C5 E3                                   ex	(sp),hl			; L = y0
 103+ F1C6 63                                   ld	h,e				; H = y1
 104+ F1C7 7C           distanceY:		        ld	a,h
 105+ F1C8 95                                   sub	l
 106+ F1C9 6F                                   ld	l,a
 107+ F1CA 26 00                                ld	h,0
 108+ F1CC 30 02                                jr	nc, distanceYDone
 109+ F1CE 26 FF                                ld	h,-1
 110+ F1D0 D1           distanceYDone:          pop	de
 111+ F1D1 EB                                   ex	de,hl			; h.dist.	= HL, v.dist. = DE
 112+ F1D2 CD D6 F1                             call	DrawLineRelative			; draw line...
 113+ F1D5 C9           exit_line:              ret
 114+ F1D6
 115+ F1D6              ; ***************************************************************************
 116+ F1D6              ;
 117+ F1D6              ;	IN:	HL =	move	relative x horisontal points (maximum +/- 255).
 118+ F1D6              ;		DE =	move	relative y vertical	points (maximum +/-	255).
 119+ F1D6              ;
 120+ F1D6              ; OUT: h - l distance in	HL
 121+ F1D6              ;
 122+ F1D6
 123+ F1D6 D5           DrawLineRelative:       push	de
 124+ F1D7 E5                                   push	hl
 125+ F1D8 D9                                   exx
 126+ F1D9 E1                                   pop	hl					; get relative	horisontal movement
 127+ F1DA CD 51 F2                             call	sgn
 128+ F1DD 57                                   ld	d,a					; direc_x	= SGN(x) installed d = +/-1 for horizontal update
 129+ F1DE CD 5E F2                             call	absValue
 130+ F1E1 45                                   ld	b,l					; x = ABS(x)
 131+ F1E2 E1           DrawLineGetVertRelative:pop	hl					; get relative	vertical movement
 132+ F1E3 CD 51 F2                             call	sgn
 133+ F1E6 5F                                   ld	e,a					; direc_y	= SGN(y) installed  = +/-1 for vertical update
 134+ F1E7 CD 5E F2                             call	absValue
 135+ F1EA 4D                                   ld	c,l					; y = ABS(y) so now bc = dxdy
 136+ F1EB              ; so by here BC = dx dy HL in increment/decrement x y
 137+ F1EB C5                                   push	bc
 138+ F1EC D9                                   exx
 139+ F1ED E1                                   pop	hl					; H = absolute	x dist., L = absolute y distance
 140+ F1EE 7C                                   ld	a,h
 141+ F1EF BD                                   cp	l
 142+ F1F0 38 0A                                jr	c, x_smaller_y		; if	x >=	y
 143+ F1F2 B4           areXandYZero:           or	h					;	if x+y = 0
 144+ F1F3 28 5B                                jr	z, exit_draw		;		return
 145+ F1F5 D9           y_lessorequal_x:        exx						;	else
 146+ F1F6 42                                   ld	b,d					;		ddx = direc_x
 147+ F1F7 0E 00                                ld	c,0					;		ddy = 0
 148+ F1F9 D9                                   exx
 149+ F1FA 18 08                                jr	init_drawloop		; else
 150+ F1FC 7C           x_smaller_y:	        ld	a,h
 151+ F1FD 65                                   ld	h,l					;	H = y
 152+ F1FE 6F                                   ld	l,a					;	L = x
 153+ F1FF D9                                   exx
 154+ F200 06 00                                ld	b,0					;	ddx = 0
 155+ F202 4B                                   ld	c,e					;	ddy = direc_y
 156+ F203 D9                                   exx
 157+ F204 44           init_drawloop:	        ld	b,h
 158+ F205 4C                                   ld	c,h					; B = H
 159+ F206 CB 39                                srl	c					; i = INT(B/2)
 160+ F208              										; FOR N=B	TO 1	STEP	-1
 161+ F208 79           drawloop:		        ld	a,c
 162+ F209 85                                   add	a,l
 163+ F20A 38 09                                jr	c, i_greater		;	i + L > 255  (i > H)
 164+ F20C BC                                   cp	h
 165+ F20D 30 06                                jr	nc, i_greater		;	if i	< H
 166+ F20F 4F                                   ld	c,a					;		i = i + L
 167+ F210 D9                                   exx
 168+ F211 C5                                   push	bc				;		ix =	ddx:	iy =	ddy
 169+ F212 D9                                   exx
 170+ F213 18 05                                jr	check_plot			;	else
 171+ F215 94           i_greater:		        sub	h					;		i = i - H
 172+ F216 4F                                   ld	c,a
 173+ F217 D9                                   exx
 174+ F218 D5                                   push	de				;		ix =	direc_x: iy = direc_y
 175+ F219 D9                                   exx						;	endif
 176+ F21A E3           check_plot:		        ex	(sp),hl				;	preserve H,L distances on stack
 177+ F21B EB                                   ex	de,hl				;	D,E = ix,	iy
 178+ F21C 2A A8 F1                             ld	hl,(line_gfx_coords)
 179+ F21F 7D                                   ld	a,l
 180+ F220 83                                   add	a,e					;
 181+ F221 6F                                   ld	l,a					;	y0 =	y0 +	iy (y0 is	checked by plot)
 182+ F222 7A                                   ld	a,d
 183+ F223 3C                                   inc	a
 184+ F224 84                                   add	a,h
 185+ F225 38 04                                jr	c, check_range		;	check out	of range
 186+ F227 28 26                                jr	z, range_error		;	Fz=1	& Fc=0 denotes	x0 <	0
 187+ F229 18 02                                jr	plot_point
 188+ F22B 20 22        check_range:            jr	nz, range_error	;	Fz=0	& Fc=1 denotes	x0 >	255
 189+ F22D
 190+ F22D 3D           plot_point:             dec	a
 191+ F22E C5                                   push	bc
 192+ F22F F5                                   push	af
 193+ F230 47                                   ld	    b,a					;	x0 =	x0 +	ix
 194+ F231 4D                                   ld		c,l
 195+ F232 3A A7 F1                             ld		a,(line_gfx_colour)
 196+ F235 ED 43 A8 F1                          ld      (line_gfx_coords),bc
 197+ F239                                      l2_plot_macro; call	l2_plot_pixel:
 197+ F239 78          >                        ld      a,b
 197+ F23A             >                        JumpIfAGTENusng 192 ,.NoPlot
 197+ F23A FE C0       >                        cp     192
 197+ F23C D2 48 F2    >                        jp		nc,.NoPlot
 197+ F23F 69          >                        ld      l,c
 197+ F240 CD 68 E0    >                        call    asm_l2_row_bank_select
 197+ F243 67          >                        ld      h,a
 197+ F244 3A A7 F1    >                        ld      a,(line_gfx_colour)
 197+ F247 77          >                        ld      (hl),a
 197+ F248             >.NoPlot:
 198+ F248 F1                                   pop		af
 199+ F249 C1                                   pop		bc
 200+ F24A E1           plot_RET:		        pop	hl					;	restore H,L distances...
 201+ F24B 10 BB                                djnz	drawloop		; NEXT N
 202+ F24D 18 01                                jr	exit_draw
 203+ F24F
 204+ F24F E1           range_error:	        pop	hl					; remove H,L distances...
 205+ F250 C9           exit_draw:		        ret
 206+ F251
 207+ F251
 208+ F251              ; ******************************************************************************
 209+ F251              ;
 210+ F251              ;	SGN (Signum value) of 16	bit signed integer.
 211+ F251              ;
 212+ F251              ;	IN:		HL =	integer
 213+ F251              ;	OUT:		A = result: 0,1,-1 (if zero, positive, negative)
 214+ F251              ;
 215+ F251              ;	Registers	changed after return:
 216+ F251              ;	..BCDEHL/IXIY	same
 217+ F251              ;	AF....../....	different
 218+ F251              ;
 219+ F251 7C           sgn:				    ld	a,h
 220+ F252 B5                                   or	l
 221+ F253 C8                                   ret	z				; integer	is zero, return 0...
 222+ F254 CB 7C                                bit	7,h
 223+ F256 20 03                                jr	nz, negative_int
 224+ F258 3E 01                                ld	a,1
 225+ F25A C9                                   ret
 226+ F25B 3E FF        negative_int:		    ld	a,-1
 227+ F25D C9                                   ret
 228+ F25E
 229+ F25E
 230+ F25E              ; ******************************************************************************
 231+ F25E              ;
 232+ F25E              ;	ABS (Absolute value) of 16 bit signed integer.
 233+ F25E              ;
 234+ F25E              ;	IN:		HL =	integer
 235+ F25E              ;	OUT:		HL =	converted	integer
 236+ F25E              ;
 237+ F25E              ;	Registers	changed after return:
 238+ F25E              ;	A.BCDE../IXIY	same
 239+ F25E              ;	.F....HL/....	different
 240+ F25E              ;
 241+ F25E CB 7C        absValue:			    bit	7,h
 242+ F260 C8                                   ret	z				; integer	is positive...
 243+ F261 D5                                   push	de
 244+ F262 EB                                   ex	de,hl
 245+ F263 21 00 00                             ld	hl,0
 246+ F266 BF                                   cp	a				; Fc	= 0,	may not be used...
 247+ F267 ED 52                                sbc	hl,de			; convert	negative integer
 248+ F269 D1                                   pop	de
 249+ F26A C9                                   ret
 250+ F26B
# file closed: ./Layer2Graphics/l2_draw_line_v2.asm
 235  F26B
 236  F26B
 237  F26B                  SAVENEX OPEN "TriangleTst.nex", $8000 , $7F00
 238  F26B                  SAVENEX CFG  0,0,0,1
 239  F26B                  SAVENEX AUTO
 240  F26B                  SAVENEX CLOSE
 241  F26B
# file closed: TriangleTst.asm
