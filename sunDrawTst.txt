# file opened: sunDrawTst.asm
   1  0000               DEVICE ZXSPECTRUMNEXT
   2  0000
   3  0000               CSPECTMAP clipTst.map
   4  0000               OPT --zxnext=cspect --syntax=a --reversepop
   5  0000
   6  0000              DEBUGSEGSIZE   equ 1
   7  0000              DEBUGLOGSUMMARY equ 1
   8  0000              ;DEBUGLOGDETAIL equ 1
   9  0000
  10  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  11  0000              ; Game Defines
  12  0000              ScreenLocal     EQU 0
  13  0000              ScreenGalactic  EQU ScreenLocal + 1
  14  0000              ScreenMarket    EQU ScreenGalactic + 1
  15  0000              ScreenMarketDsp EQU ScreenMarket + 1
  16  0000              ScreenStatus    EQU ScreenMarketDsp + 1
  17  0000              ScreenInvent    EQU ScreenStatus + 1
  18  0000              ScreenPlanet    EQU ScreenInvent + 1
  19  0000              ScreenEquip     EQU ScreenPlanet + 1
  20  0000              ScreenLaunch    EQU ScreenEquip + 1
  21  0000              ScreenFront     EQU ScreenLaunch + 1
  22  0000              ScreenAft       EQU ScreenFront+1
  23  0000              ScreenLeft      EQU ScreenAft+2
  24  0000              ScreenRight     EQU ScreenLeft+3
  25  0000              ;----------------------------------------------------------------------------------------------------------------------------------
  26  0000              ; Colour Defines
  27  0000                  INCLUDE "./Hardware/L2ColourDefines.asm"
# file opened: ./Hardware/L2ColourDefines.asm
   1+ 0000              L2ColourBLACK           EQU   0
   2+ 0000              L2ColourRED_1           EQU 224                 ; RGB 255,  0,  0
   3+ 0000              L2ColourRED_2           EQU 192                 ; RGB 218,  0,  0
   4+ 0000              L2ColourRED_3           EQU 160                 ; RGB 182,  0,  0
   5+ 0000              L2ColourRED_4           EQU 128                 ; RGB 145,  0,  0
   6+ 0000              L2ColourRED_5           EQU  96                 ; RGB 109,  0,  0
   7+ 0000              L2ColourRED_6           EQU  64                 ; RGB  72,  0,  0
   8+ 0000              L2ColourRED_7           EQU  32                 ; RGB  36,  0,  0
   9+ 0000              L2ColourYELLOW_1        EQU 252                 ; RGB 255,255,  0
  10+ 0000              L2ColourYELLOW_2        EQU 216                 ; RGB 218,218,  0
  11+ 0000              L2ColourYELLOW_3        EQU 180                 ; RGB 182,182,  0
  12+ 0000              L2ColourYELLOW_4        EQU 144                 ; RGB 145,145,  0
  13+ 0000              L2ColourYELLOW_5        EQU 108                 ; RGB 109.109,  0
  14+ 0000              L2ColourYELLOW_6        EQU  72                 ; RGB  72, 72,  0
  15+ 0000              L2ColourYELLOW_7        EQU  36                 ; RGB  36, 36,  0
  16+ 0000              L2ColourGREEN_1		    EQU  28                 ; RGB   0,255,  0
  17+ 0000              L2ColourGREEN_2		    EQU  24                 ; RGB   0,218,  0
  18+ 0000              L2ColourGREEN_3		    EQU  16                 ; RGB   0,145,  0
  19+ 0000              L2ColourGREEN_4         EQU  12                 ; RGB   0,109,  0
  20+ 0000              L2ColourGREEN_5         EQU   8                 ; RGB   0, 72,  0
  21+ 0000              L2ColourGREEN_6         EQU   4                 ; RGB   0, 36,  0
  22+ 0000              L2ColourBLUE_1          EQU   3                 ; RGB 0,0,255
  23+ 0000              L2ColourBLUE_2          EQU   2                 ; RGB 0,0,170
  24+ 0000              L2ColourBLUE_3          EQU   1                 ; RGB 0,0,85
  25+ 0000
  26+ 0000
  27+ 0000              L2ColourWHITE_1         EQU 255                 ; RGB 255,255,255
  28+ 0000              L2ColourWHITE_2         EQU 146
  29+ 0000              L2ColourGREY_1		    EQU L2ColourWHITE_2
  30+ 0000              L2ColourGREY_2		    EQU 109
  31+ 0000              L2ColourGREY_3		    EQU  73
  32+ 0000              L2ColourGREY_4		    EQU  37
  33+ 0000
  34+ 0000              L2ColourGREEN_MB        EQU  29                 ;RGB 0,255,85
  35+ 0000              L2ColourGREEN_MR        EQU 124                 ;RGB 109.255,0
  36+ 0000              L2ColourCREAM_1         EQU 218                 ; RGB 218,218,170
  37+ 0000              L2ColourCREAM_2         EQU 182                 ; RGB 182,182,170
  38+ 0000              L2ColourCREAM_3         EQU 146                 ; RGB 145,145,170
  39+ 0000
  40+ 0000              L2ColourTRANSPARENT     EQU 227                 ; RGB 255,  0,255
  41+ 0000              L2ColourMAGENTA_1       EQU 162                 ; RGB 182,  0,170
  42+ 0000              L2ColourMAGENTA_2       EQU 130                 ; RGB 145,  0,170
  43+ 0000              L2ColourMAGENTA_3       EQU  97                 ; RGB 109,  0, 85
  44+ 0000              L2ColourMAGENTA_4       EQU  65                 ; RGB  72,  0, 85
  45+ 0000              L2ColourORANGE_1        EQU 236                 ; RGB
  46+ 0000              L2ColourORANGE_2        EQU 168                 ; RGB
  47+ 0000              L2ColourORANGE_3        EQU  68                 ; RGB
  48+ 0000              L2ColourCYAN_1          EQU  31                 ; RGB   0,255, 255
  49+ 0000              L2ColourCYAN_2          EQU  18                 ; RGB
  50+ 0000              L2ColourCYAN_3          EQU   9                 ; RGB
  51+ 0000              L2ColourPURPLE_1        EQU 109                 ; RGB
  52+ 0000              L2ColourPURPLE_2        EQU  66                 ; RGB
  53+ 0000              L2ColourPURPLE_3        EQU  33                 ; RGB
  54+ 0000              L2ColourPINK_1		    EQU 231                 ; RGB
  55+ 0000              L2ColourPINK_2		    EQU 226                 ; RGB
  56+ 0000              L2ColourPINK_3		    EQU 225                 ; RGB
  57+ 0000              L2ColourPINK_4		    EQU 224                 ; RGB
  58+ 0000
# file closed: ./Hardware/L2ColourDefines.asm
  28  0000                  INCLUDE "./Hardware/L1ColourDefines.asm"
# file opened: ./Hardware/L1ColourDefines.asm
   1+ 0000
   2+ 0000              L1ColourInkBlack        EQU %00000000
   3+ 0000              L1ColourInkBlue         EQU %00000001
   4+ 0000              L1ColourInkRed          EQU %00000010
   5+ 0000              L1ColourInkMagenta      EQU %00000011
   6+ 0000              L1ColourInkGreen        EQU %00000100
   7+ 0000              L1ColourInkCyan         EQU %00000101
   8+ 0000              L1ColourInkYellow       EQU %00000110
   9+ 0000              L1ColourInkWhite        EQU %00000111
  10+ 0000              L1ColourPaperBlack      EQU %00000000
  11+ 0000              L1ColourPaperBlue       EQU %00001000
  12+ 0000              L1ColourPaperRed        EQU %00010000
  13+ 0000              L1ColourPaperMagenta    EQU %00011000
  14+ 0000              L1ColourPaperGreen      EQU %00100000
  15+ 0000              L1ColourPaperCyan       EQU %00101000
  16+ 0000              L1ColourPaperYellow     EQU %00110000
  17+ 0000              L1ColourPaperWhite      EQU %00111000
  18+ 0000              L1ColourFlash           EQU %10000000
  19+ 0000              L1ColourBright          EQU %01000000
  20+ 0000              ;----------------------------------------------------------------------------------------------------------------------------------
  21+ 0000              ; Screen Specific Colour Defines
  22+ 0000              L1InvHighlight          EQU L1ColourBright | L1ColourPaperRed   | L1ColourInkYellow
  23+ 0000              L1InvLowlight           EQU                  L1ColourPaperBlack | L1ColourInkWhite
# file closed: ./Hardware/L1ColourDefines.asm
  29  0000              ; Just to make assmebly work
  30  0000 00 00        UBnKxlo         DW 0
  31  0002 00 00        UBnKxsgn         DW 0
  32  0004 00 00        UBnKzlo         DW 0
  33  0006 00 00        UBnKzsgn         DW 0
  34  0008              ;----------------------------------------------------------------------------------------------------------------------------------
  35  0008
  36  0008              N0equN1byN2div256:      MACRO param1,param2,param3
  37  0008 ~                                    ld      a,param3                        ;
  38  0008 ~                                    ld      e,a                         ; use e as var Q = value of XX15 [n] lo
  39  0008 ~                                    ld      a,param2                        ; A = XX16 element
  40  0008 ~                                    ld      d,a
  41  0008 ~                                    mul
  42  0008 ~                                    ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
  43  0008 ~                                    ld      (param1),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
  44  0008                                      ENDM
  45  0008
  46  0008              AequN1xorN2:            MACRO  param1,param2
  47  0008 ~                                    ld      a,(param1)
  48  0008 ~                                    xor     param2
  49  0008                                      ENDM
  50  0008                  INCLUDE "./Hardware/register_defines.asm"
# file opened: ./Hardware/register_defines.asm
   1+ 0008              IO_LAYER2_PORT                          EQU $123B
   2+ 0008              IO_EXT_BANK_PORT 			            EQU $DFFD ; 57341
   3+ 0008              IO_BANK_PORT                            EQU $7FFD ; 32765
   4+ 0008              REGISTER_NUMBER_PORT					EQU $243B
   5+ 0008              REGISTER_VALUE_PORT						EQU $253B
   6+ 0008              SPRITE_SLOT_PORT						EQU $303B
   7+ 0008              SPRITE_INFO_PORT                        EQU $0057
   8+ 0008              SPRITE_PATTERN_UPLOAD_PORT				EQU $005B
   9+ 0008
  10+ 0008              MACHINE_ID_REGISTER						EQU 0
  11+ 0008              VERSION_REGISTER						EQU 1
  12+ 0008              RESET_REGISTER		    				EQU 2
  13+ 0008              MACHINE_TYPE_REGISTER					EQU 3
  14+ 0008              PAGE_RAM_REGISTER						EQU 4
  15+ 0008              PERIPHERAL_1_REGISTER					EQU 5
  16+ 0008              PERIPHERAL_2_REGISTER					EQU 6
  17+ 0008              TURBO_MODE_REGISTER						EQU 7
  18+ 0008              PERIPHERAL_3_REGISTER					EQU 8
  19+ 0008              ANTI_BRICK_SYSTEM_REGISTER				EQU 10
  20+ 0008              LAYER2_RAM_PAGE_REGISTER				EQU 18
  21+ 0008              LAYER2_RAM_SHADOW_REGISTER      		EQU 19
  22+ 0008              TRANSPARENCY_COLOUR_REGISTER			EQU 20
  23+ 0008              SPRITE_LAYERS_SYSTEM_REGISTER			EQU 21
  24+ 0008              LAYER2_OFFSET_X_REGISTER				EQU 22
  25+ 0008              LAYER2_OFFSET_Y_REGISTER				EQU 23
  26+ 0008              CLIP_WINDOW_LAYER2_REGISTER				EQU 24
  27+ 0008              CLIP_WINDOW_SPRITES_REGISTER			EQU 25
  28+ 0008              CLIP_WINDOW_ULA_REGISTER				EQU 26
  29+ 0008              CLIP_WINDOW_CONTROL_REGISTER			EQU 28
  30+ 0008              ACTIVE_VIDEO_LINE_MSB_REGISTER			EQU 30
  31+ 0008              ACTIVE_VIDEO_LINE_LSB_REGISTER			EQU 31
  32+ 0008              LINE_INTERRUPT_CONTROL_REGISTER			EQU 34
  33+ 0008              LINE_INTERRUPT_VALUE_LSB_REGISTER		EQU 35
  34+ 0008              KEYMAP_HIGH_ADDRESS_REGISTER			EQU 40
  35+ 0008              KEYMAP_LOW_ADDRESS_REGISTER				EQU 41
  36+ 0008              KEYMAP_HIGH_DATA_REGISTER				EQU 42
  37+ 0008              KEYMAP_LOW_DATA_REGISTER				EQU 43
  38+ 0008              DAC_B_MIRROR_REGISTER                   EQU 44
  39+ 0008              DAC_AB_MIRROR_REGISTER                  EQU 45
  40+ 0008              DAC_C_MORROR_REGISTER                   EQU 46
  41+ 0008              TILEMAP_OFFSET_XMSB_REGISTER            EQU 47
  42+ 0008              TILEMAP_OFFSET_XLSB_REGISTER            EQU 48
  43+ 0008              TILEMAP_OFFSET_YMSB_REGISTER            EQU 49
  44+ 0008              LORES_OFFSET_X_REGISTER					EQU 50
  45+ 0008              LORES_OFFSET_Y_REGISTER					EQU 51
  46+ 0008              SPRITE_PORT_INDEX_REGISTER              EQU 52
  47+ 0008              SPRITE_PORT_ATTR0_REGISTER              EQU 53
  48+ 0008              SPRITE_PORT_ATTR1_REGISTER              EQU 54
  49+ 0008              SPRITE_PORT_ATTR2_REGISTER              EQU 55
  50+ 0008              SPRITE_PORT_ATTR3_REGISTER              EQU 56
  51+ 0008              SPRITE_PORT_ATTR4_REGISTER              EQU 57
  52+ 0008              PALETTE_INDEX_REGISTER					EQU 64
  53+ 0008              PALETTE_VALUE_8BIT_REGISTER				EQU 65
  54+ 0008              PALETTE_FORMAT_REGISTER					EQU 66
  55+ 0008              PALETTE_CONTROL_REGISTER				EQU 67
  56+ 0008              PALETTE_VALUE_9BIT_REGISTER				EQU 68
  57+ 0008              MMU_SLOT_0_REGISTER						EQU 80
  58+ 0008              MMU_SLOT_1_REGISTER						EQU 81
  59+ 0008              MMU_SLOT_2_REGISTER						EQU 82
  60+ 0008              MMU_SLOT_3_REGISTER						EQU 83
  61+ 0008              MMU_SLOT_4_REGISTER						EQU 84
  62+ 0008              MMU_SLOT_5_REGISTER						EQU 85
  63+ 0008              MMU_SLOT_6_REGISTER						EQU 86
  64+ 0008              MMU_SLOT_7_REGISTER						EQU 87
  65+ 0008              COPPER_DATA_REGISTER					EQU 96
  66+ 0008              COPPER_CONTROL_LOW_REGISTER				EQU 97
  67+ 0008              COPPER_CONTROL_HIGH_REGISTER			EQU 98
  68+ 0008              DISPLAY_CONTROL_1_REGISTER              EQU 105
  69+ 0008              LAYER_2_CONTROL_REGISTER                EQU 112
  70+ 0008              LAYER_2_X_OFFSET_MSB_REGISTER           EQU 113
  71+ 0008              DEBUG_LEDS_REGISTER						EQU 255
  72+ 0008
  73+ 0008
  74+ 0008              GetNextReg:	MACRO register
  75+ 0008 ~                        push bc
  76+ 0008 ~                            ld bc,$243B
  77+ 0008 ~                                ld a,register
  78+ 0008 ~                                out (c),a
  79+ 0008 ~                                inc b
  80+ 0008 ~                            in a,(c)
  81+ 0008 ~                        pop bc
  82+ 0008                          ENDM
  83+ 0008
# file closed: ./Hardware/register_defines.asm
  51  0008                  INCLUDE "./Layer2Graphics/layer2_defines.asm"
# file opened: ./Layer2Graphics/layer2_defines.asm
   1+ 0008
   2+ 0008
   3+ 0008              LAYER2_SHIFTED_SCREEN_TOP  	 equ 0
   4+ 0008              LAYER2_SHIFTED_SCREEN_MIDDLE equ $40
   5+ 0008              LAYER2_SHIFTED_SCREEN_BOTTOM equ $80
   6+ 0008
   7+ 0008              ; note hi byte is not decoded on DMA port so can out OUTIR
   8+ 0008              IO_DATAGEAR_DMA_PORT 		 equ 107
   9+ 0008              IO_SPRITE_SLOT_PORT 		 equ 12347
  10+ 0008              IO_SPRITE_PATTERN_PORT       equ 91
  11+ 0008              IO_SPRITE_ATTRIBUTES_PORT    equ 87
  12+ 0008
  13+ 0008              LAYER2_VISIBLE_MASK 		equ $02
  14+ 0008              ; DEBUG 0 for always write to primary 08 for double buffering
  15+ 0008                  IFDEF DOUBLEBUFFER
  16+ 0008 ~            LAYER2_SHADOW_SCREEN_MASK 	equ $08
  17+ 0008                  ELSE
  18+ 0008              LAYER2_SHADOW_SCREEN_MASK 	equ $00
  19+ 0008                  ENDIF
  20+ 0008              LAYER2_READ_ENABLE_MASK 	equ %00000100
  21+ 0008              LAYER2_WRITE_ENABLE_MASK 	equ %00000001
  22+ 0008              LAYER2_READ_WRITE_MASK      equ %00000101
  23+ 0008              LAYER2_SCREEN_SECTION_MASK 	equ $03
  24+ 0008              LAYER2_SCREEN_SECTION_SHIFT equ 6
  25+ 0008
  26+ 0008              LAYER2_DISABLE_MEM_WRITE    equ %11111110
  27+ 0008              LAYER2_DISABLE_MEM_READ     equ %11111011
  28+ 0008              LAYER2_DISABLE_MEM_ACCESS   equ %11111010
  29+ 0008
  30+ 0008              LAYER2_SCREEN_BANK1          equ 8
  31+ 0008              LAYER2_SCREEN_BANK2          equ 9
  32+ 0008              LAYER2_SCREEN_BANK3          equ 10
  33+ 0008              LAYER2_SHADOW_BANK1          equ 11
  34+ 0008              LAYER2_SHADOW_BANK2          equ 12
  35+ 0008              LAYER2_SHADOW_BANK3          equ 13
  36+ 0008
  37+ 0008              SCREEN_HEIGHT 				 equ 192
  38+ 0008              SCREEN_RAM_BASE				 equ $0000
  39+ 0008              SCREEN_HOZ_MIN_PIX		     equ 10
  40+ 0008
  41+ 0008              SPRITES_VISIBLE_MASK         equ $01
  42+ 0008              SPRITES_ON_BORDER_MASK       equ $02
  43+ 0008              LAYER_PRIORITIES_MASK        equ $07
  44+ 0008              LORES_MODE_MASK              equ $80
  45+ 0008              LAYER_PRIORITIES_SHIFT       equ 2
  46+ 0008
  47+ 0008              LAYER_PRIORITIES_S_L_U 		equ 0
  48+ 0008              LAYER_PRIORITIES_L_S_U 		equ 1
  49+ 0008              LAYER_PRIORITIES_S_U_L  	equ 2
  50+ 0008              LAYER_PRIORITIES_L_U_S 		equ 3
  51+ 0008              LAYER_PRIORITIES_U_S_L 		equ 4
  52+ 0008              LAYER_PRIORITIES_U_L_S 		equ 5
  53+ 0008
  54+ 0008              DMA_WRO_BLOCK_PORTA_A2B_XFR  equ $7D
  55+ 0008              DMA_WRO_BLOCK_PORTA_B2A_XFR  equ $79
  56+ 0008              DMA_WR1_P1FIXED_MEMORY       equ $24
  57+ 0008              DMA_WR1_P1DEC_MEMORY         equ $04
  58+ 0008              DMA_WR1_P1INC_MEMORY         equ $14
  59+ 0008              DMA_WR2_P2FIXED_MEMORY       equ $20
  60+ 0008              DMA_WR2_P2DEC_MEMORY         equ $00
  61+ 0008              DMA_WR2_P2INC_MEMORY         equ $10
  62+ 0008              DMA_WR4_CONT_MODE            equ $AD
  63+ 0008              DMA_RESET                    equ $c3
  64+ 0008              DMA_RESET_PORT_A_TIMING      equ $c7
  65+ 0008              DMA_RESET_PORT_B_TIMING      equ $cb
  66+ 0008              DMA_LOAD                     equ $cf
  67+ 0008              DMA_CONTINUE                 equ $d3
  68+ 0008              DMA_DISABLE_INTERUPTS        equ $af
  69+ 0008              DMA_ENABLE_INTERUPTS         equ $ab
  70+ 0008              DMA_RESET_DISABLE_INTERUPTS  equ $a3
  71+ 0008              DMA_ENABLE_AFTER_RETI        equ $b7
  72+ 0008              DMA_READ_STATUS_BYTE         equ $bf
  73+ 0008              DMA_REINIT_STATUS_BYTE       equ $8b
  74+ 0008              DMA_START_READ_SEQUENCE      equ $a7
  75+ 0008              DMA_FORCE_READY              equ $b3
  76+ 0008              DMA_STOP_AT_END			     equ $82
  77+ 0008              DMA_DISABLE                  equ $83
  78+ 0008              DMA_ENABLE                   equ $87
  79+ 0008              DMA_WRITE_REGISTER_COMMAND   equ $bb
  80+ 0008              DMA_BURST                    equ $cd
  81+ 0008              DMA_CONTINUOUS               equ $ad
  82+ 0008              ZXN_DMA_PORT                 equ $6b
  83+ 0008
  84+ 0008
  85+ 0008              COLOUR_TRANSPARENT			 equ $E3
  86+ 0008
  87+ 0008
  88+ 0008
  89+ 0008
# file closed: ./Layer2Graphics/layer2_defines.asm
  52  0008                  INCLUDE	"./Hardware/memory_bank_defines.asm"
# file opened: ./Hardware/memory_bank_defines.asm
   1+ 0008
   2+ 0008              membanksize			    equ	$1FFF
   3+ 0008
   4+ 0008              StartOfBank     	    equ $0000
   5+ 0008
   6+ 0008              membank0 			    equ $0000
   7+ 0008              dmaCopySrcAddr		    equ	$0000
   8+ 0008              membank1 			    equ $2000
   9+ 0008              membank2 			    equ $4000
  10+ 0008              membank3 			    equ $6000
  11+ 0008              membank4 			    equ $8000
  12+ 0008              membank5 			    equ $a000
  13+ 0008              membank6 			    equ $c000
  14+ 0008              ScreenBank              equ $c000
  15+ 0008              MenuGalChtAddr          equ $c000
  16+ 0008              MenuEquipSAddr          equ $c000
  17+ 0008              MenuInventAddr          equ $c000
  18+ 0008              MenuMarketAddr          equ $c000
  19+ 0008              DispMarketAddr          equ $c000
  20+ 0008              MenuShrChtAddr          equ $c000
  21+ 0008              MenuStatusAddr          equ $c000
  22+ 0008              MenuSystemAddr          equ $c000
  23+ 0008              ViewFrontAddr           equ $c000
  24+ 0008              SunBankAddr             equ $c000
  25+ 0008              PlanetBankAddr          equ $c000
  26+ 0008              UniverseBankAddr	    equ $c000
  27+ 0008              LaunchShipAddr          equ $c000
  28+ 0008              membank7 			    equ $e000
  29+ 0008              L1membankAddr   	    equ $e000
  30+ 0008              L2membankAddr   	    equ $e000
  31+ 0008              ShipModelsAddr	        equ $e000
  32+ 0008              SpritemembankAddr       equ $e000
  33+ 0008              ResetUniverseAddr       equ $e000
  34+ 0008              StockTableAddr	        equ $e000
  35+ 0008              CommanderAddr           equ $e000
  36+ 0008              LAYER2Addr              equ $e000
  37+ 0008              LAYER1Addr              equ $e000
  38+ 0008              SPRITEAddr              equ $e000
  39+ 0008              ConsoleImageAddr        equ $e000
  40+ 0008              GalaxyDataAddr          equ $e000
  41+ 0008
  42+ 0008              EXSDOSMMU0              equ MMU_SLOT_0_REGISTER
  43+ 0008              EXSDOSMMU1              equ MMU_SLOT_1_REGISTER
  44+ 0008              DMACpySourceMMU		    equ	MMU_SLOT_0_REGISTER
  45+ 0008              SunMMU 		            equ MMU_SLOT_6_REGISTER
  46+ 0008              PlanetMMU 		        equ MMU_SLOT_6_REGISTER
  47+ 0008              UniverseMMU 		    equ MMU_SLOT_6_REGISTER
  48+ 0008              ScreenBankMMU           equ MMU_SLOT_6_REGISTER
  49+ 0008              MenuEquipSMMU           equ MMU_SLOT_6_REGISTER
  50+ 0008              MenuShrChtMMU           equ MMU_SLOT_6_REGISTER
  51+ 0008              MenuGalChtMMU           equ MMU_SLOT_6_REGISTER
  52+ 0008              MenuInventMMU           equ MMU_SLOT_6_REGISTER
  53+ 0008              MenuSystemMMU           equ MMU_SLOT_6_REGISTER
  54+ 0008              MenuMarketMMU           equ MMU_SLOT_6_REGISTER
  55+ 0008              DispMarketMMU           equ MMU_SLOT_6_REGISTER
  56+ 0008              MenuStatusMMU           equ MMU_SLOT_6_REGISTER
  57+ 0008              LaunchShipMMU           equ MMU_SLOT_6_REGISTER
  58+ 0008              L1memMMU       		    equ MMU_SLOT_7_REGISTER
  59+ 0008              L2memMMU       		    equ MMU_SLOT_7_REGISTER
  60+ 0008              SpritememMMU   		    equ MMU_SLOT_7_REGISTER
  61+ 0008              ShipModelMMU  		    equ MMU_SLOT_7_REGISTER
  62+ 0008              ResetUniverseMMU	    equ MMU_SLOT_7_REGISTER
  63+ 0008              CommanderMMU	        equ MMU_SLOT_7_REGISTER
  64+ 0008              StockTableMMU		    equ MMU_SLOT_7_REGISTER
  65+ 0008              ConsoleImageDataMMU	    equ MMU_SLOT_7_REGISTER
  66+ 0008              GalaxyDataMMU	        equ MMU_SLOT_7_REGISTER
  67+ 0008
  68+ 0008              BankResetUniv           equ 49
  69+ 0008              BankMenuShrCht          equ 50
  70+ 0008              BankMenuGalCht          equ 51
  71+ 0008              BankMenuInvent          equ 52
  72+ 0008              BankMenuSystem          equ 53
  73+ 0008              BankMenuMarket          equ 54
  74+ 0008              BankStockTable          equ 55
  75+ 0008              BankCommander           equ 56
  76+ 0008              BankLAYER2              equ 57
  77+ 0008              BankLAYER1              equ 58
  78+ 0008              BankShipModels1         equ 59
  79+ 0008              BankSPRITE              equ 60
  80+ 0008              BankConsole             equ 61
  81+ 0008              BankFrontView           equ 62
  82+ 0008              BankMenuStatus          equ 63
  83+ 0008              BankMenuEquipS          equ 64
  84+ 0008              BankLaunchShip          equ 65
  85+ 0008              BankDispMarket          equ 66
  86+ 0008              BankShipModels2         equ 67
  87+ 0008              BankShipModels3         equ 68
  88+ 0008              BankShipModels4         equ 69
  89+ 0008
  90+ 0008              BankUNIVDATA0           equ 70
  91+ 0008              BankUNIVDATA1           equ 71
  92+ 0008              BankUNIVDATA2           equ 72
  93+ 0008              BankUNIVDATA3           equ 73
  94+ 0008              BankUNIVDATA4           equ 74
  95+ 0008              BankUNIVDATA5           equ 75
  96+ 0008              BankUNIVDATA6           equ 76
  97+ 0008              BankUNIVDATA7           equ 77
  98+ 0008              BankUNIVDATA8           equ 78
  99+ 0008              BankUNIVDATA9           equ 79
 100+ 0008              BankUNIVDATA10          equ 80
 101+ 0008              BankUNIVDATA11          equ 81
 102+ 0008              BankUNIVDATA12          equ 82
 103+ 0008              BankSunData             equ 83
 104+ 0008              BankPlanetData          equ 84
 105+ 0008
 106+ 0008              BankGalaxyData0         equ 91
 107+ 0008              BankGalaxyData1         equ 92
 108+ 0008              BankGalaxyData2         equ 93
 109+ 0008              BankGalaxyData3         equ 94
 110+ 0008              BankGalaxyData4         equ 95
 111+ 0008              BankGalaxyData5         equ 96
 112+ 0008              BankGalaxyData6         equ 97
 113+ 0008              BankGalaxyData7         equ 98
 114+ 0008
 115+ 0008              BankROM                 equ 255
 116+ 0008
# file closed: ./Hardware/memory_bank_defines.asm
  53  0008                  INCLUDE "./Hardware/screen_equates.asm"
# file opened: ./Hardware/screen_equates.asm
   1+ 0008              ScreenHeight 		equ 192
   2+ 0008              ScreenLastRow       equ ScreenHeight -1
   3+ 0008              ScreenWidth  		equ 256
   4+ 0008              ScreenLastCol       equ ScreenWidth -1
   5+ 0008              ScreenHeightHalf	equ 96
   6+ 0008              ScreenWidthHalf  	equ 128
   7+ 0008              ScreenCenterY		equ 96
   8+ 0008              ScreenCenterX       equ 128
   9+ 0008              ViewHeight          equ 128
  10+ 0008              ViewHeightPlus1     equ 128+1
  11+ 0008              ViewLastRow       	equ ViewHeight -1
  12+ 0008              ViewWidth  			equ 256
  13+ 0008              ViewLastCol         equ ViewWidth -1
  14+ 0008              ViewHeightHalf      equ 63
  15+ 0008              ViewWidthHalf       equ 127
  16+ 0008              ViewCenterY         equ 64
  17+ 0008              ViewCenterX         equ 128
  18+ 0008              ShipColour			equ $FF		; place holder for debugging TODO
  19+ 0008              ScreenL1Bottom      equ $5000
  20+ 0008              ScreenL1BottomLen   equ 32 * 8 * 8
  21+ 0008              ScreenL1AttrBtm     equ $5A00
  22+ 0008              ScreenL1AttrBtmLen  equ 32 * 8
  23+ 0008
# file closed: ./Hardware/screen_equates.asm
  54  0008
  55  0008                                      INCLUDE "./Macros/graphicsMacros.asm"
# file opened: ./Macros/graphicsMacros.asm
   1+ 0008              ; General Graphics macros
   2+ 0008              DoubleBufferIfPossible: MACRO
   3+ 0008 ~                                    IFDEF DOUBLEBUFFER
   4+ 0008 ~                                        MMUSelectLayer2
   5+ 0008 ~                                        call  l2_cls
   6+ 0008 ~                                        call  l2_flip_buffers
   7+ 0008 ~                                    ENDIF
   8+ 0008                                      ENDM
# file closed: ./Macros/graphicsMacros.asm
  56  0008                                      INCLUDE "./Macros/callMacros.asm"
# file opened: ./Macros/callMacros.asm
   1+ 0008
   2+ 0008              CallIfAEqNusng:         MACRO   reg,target
   3+ 0008 ~                                    cp      reg
   4+ 0008 ~                                    call	z,target
   5+ 0008                                      ENDM
   6+ 0008
   7+ 0008              CallIfAGTENusng:        MACRO   reg,target
   8+ 0008 ~                                    cp      reg
   9+ 0008 ~                                    call	nc,target
  10+ 0008                                      ENDM
  11+ 0008
  12+ 0008              CallIfAGTEMemusng:      MACRO   reg,target
  13+ 0008 ~                                    ld      hl,reg
  14+ 0008 ~                                    cp      (hl)
  15+ 0008 ~                                    call	nc,target
  16+ 0008                                      ENDM
  17+ 0008
  18+ 0008              CallIfALTNusng:         MACRO   reg,target
  19+ 0008 ~                                    cp      reg
  20+ 0008 ~                                    call	c,target
  21+ 0008                                      ENDM
  22+ 0008
  23+ 0008              CallIfMemEqMemusng:     MACRO mem, address, target
  24+ 0008 ~                                    ld   a,(mem)
  25+ 0008 ~                                    ld   hl,address
  26+ 0008 ~                                    cp   (hl)
  27+ 0008 ~                                    call    z,target
  28+ 0008                                      ENDM
  29+ 0008
  30+ 0008              CallIfMemEqNusng:       MACRO mem, value, target
  31+ 0008 ~                                    ld   a,(mem)
  32+ 0008 ~                                    cp   value
  33+ 0008 ~                                    call    z,target
  34+ 0008                                      ENDM
  35+ 0008
  36+ 0008              CallIfMemTrue:          MACRO mem, target
  37+ 0008 ~                                    ld      a,(mem)
  38+ 0008 ~                                    and     a
  39+ 0008 ~                                    call    z, target
  40+ 0008                                      ENDM
  41+ 0008
  42+ 0008              CallIfMemFalse:         MACRO mem, target
  43+ 0008 ~                                    ld      a,(mem)
  44+ 0008 ~                                    and     a
  45+ 0008 ~                                    call    nz, target
  46+ 0008                                      ENDM
  47+ 0008
  48+ 0008              CallIfATrue:            MACRO target
  49+ 0008 ~                                    and     a
  50+ 0008 ~                                    call    z, target
  51+ 0008                                      ENDM
  52+ 0008
  53+ 0008              CallIfAFalse:           MACRO target
  54+ 0008 ~                                    and     a
  55+ 0008 ~                                    call    nz, target
  56+ 0008                                      ENDM
# file closed: ./Macros/callMacros.asm
  57  0008                                      INCLUDE "./Macros/carryFlagMacros.asm"
# file opened: ./Macros/carryFlagMacros.asm
   1+ 0008
   2+ 0008              SetCarryFlag:           MACRO
   3+ 0008 ~                                    scf
   4+ 0008                                      ENDM
   5+ 0008
   6+ 0008              ClearCarryFlag:	        MACRO
   7+ 0008 ~                                    or a
   8+ 0008                                      ENDM
   9+ 0008
  10+ 0008              FlipCarryFlag:          MACRO
  11+ 0008 ~                                    ccf
  12+ 0008                                      ENDM
  13+ 0008
# file closed: ./Macros/carryFlagMacros.asm
  58  0008                                      INCLUDE "./Macros/CopyByteMacros.asm"
# file opened: ./Macros/CopyByteMacros.asm
   1+ 0008              CopyByteAtHLixToA:		MACRO memloc
   2+ 0008 ~            						ex          de,hl                               ; save hl
   3+ 0008 ~            						ld          hl,memloc
   4+ 0008 ~            						add         hl,a
   5+ 0008 ~            						ld          a,(hl)                              ; get XX2[x]
   6+ 0008 ~            						ex          de,hl                               ; get hl back as we need it in loop
   7+ 0008              						ENDM
   8+ 0008
   9+ 0008              ; Increments IYL
  10+ 0008              ; Increments IHL
  11+ 0008              ; Gets value at hl and loads into Parameter 1 address
  12+ 0008
  13+ 0008              CopyByteAtNextHLiyl: 	MACRO memloc
  14+ 0008 ~            						inc         iyl                                 ;
  15+ 0008 ~            						inc         hl                                  ; vertex byte#1
  16+ 0008 ~            						ld          a,(hl)                              ;
  17+ 0008 ~            						ld          (memloc),a                     ; XX15+2 = (V),Y
  18+ 0008              						ENDM
  19+ 0008
  20+ 0008              ;------------------------------------------------------------------------------------------------------------------------------
  21+ 0008              CopyByteAtNextHL:   MACRO targetaddr
  22+ 0008 ~                                inc         hl                                  ; vertex byte#1
  23+ 0008 ~                                ld          a,(hl)                              ;
  24+ 0008 ~                                ld          (targetaddr),a                     ; SunXX15+2 = (V),Y
  25+ 0008                                  ENDM
# file closed: ./Macros/CopyByteMacros.asm
  59  0008                                      INCLUDE "./Macros/ldCopyMacros.asm"
# file opened: ./Macros/ldCopyMacros.asm
   1+ 0008              ZeroA:		            MACRO
   2+ 0008 ~                                    xor a
   3+ 0008                                      ENDM
   4+ 0008
   5+ 0008              SetATrue:               MACRO
   6+ 0008 ~                                    xor     a
   7+ 0008                                      ENDM
   8+ 0008
   9+ 0008              SetAFalse:              MACRO
  10+ 0008 ~                                    ld      a,$FF
  11+ 0008                                      ENDM
  12+ 0008
  13+ 0008              SetMemFalse             MACRO   mem
  14+ 0008 ~                                    ld      a,$FF
  15+ 0008 ~                                    ld      (mem),a
  16+ 0008                                      ENDM
  17+ 0008
  18+ 0008              SetMemTrue              MACRO   mem
  19+ 0008 ~                                    xor     a
  20+ 0008 ~                                    ld      (mem),a
  21+ 0008                                      ENDM
  22+ 0008
  23+ 0008              SetMemToN:              MACRO   mem,value
  24+ 0008 ~                                    ld      a,value
  25+ 0008 ~                                    ld      (mem),a
  26+ 0008                                      ENDM
  27+ 0008
  28+ 0008              ldCopyStringLen:        MACRO   source, target, strlen
  29+ 0008 ~                                    ld      hl,source
  30+ 0008 ~                                    ld      de, target
  31+ 0008 ~                                    ld      bc, strlen
  32+ 0008 ~                                    ldir
  33+ 0008                                      ENDM
  34+ 0008
  35+ 0008              ldCopyTextAtHLtoDE:     MACRO
  36+ 0008 ~            .CopyLoop:              ld      a,(hl)
  37+ 0008 ~                                    ld      (de),a
  38+ 0008 ~                                    cp      0
  39+ 0008 ~                                    jp      z,.DoneCopy
  40+ 0008 ~                                    inc     hl
  41+ 0008 ~                                    inc     de
  42+ 0008 ~                                    jr      .CopyLoop
  43+ 0008 ~            .DoneCopy:
  44+ 0008                                      ENDM
  45+ 0008
  46+ 0008              ldClearTextLoop:        MACRO   TextSize
  47+ 0008 ~                                    ld      b,a
  48+ 0008 ~                                    ld      a,TextSize
  49+ 0008 ~            .ClearLoop:             ld      (hl),a
  50+ 0008 ~                                    inc     hl
  51+ 0008 ~                                    djnz    .ClearLoop
  52+ 0008                                      ENDM
  53+ 0008
  54+ 0008              ldCopyByte:             MACRO memfrom, memto
  55+ 0008 ~                                    ld       a,(memfrom)
  56+ 0008 ~                                    ld       (memto),a
  57+ 0008                                      ENDM
  58+ 0008
  59+ 0008
  60+ 0008              ldCopyByteABS:          MACRO memfrom, memto
  61+ 0008 ~                                    ld       a,(memfrom)
  62+ 0008 ~                                    and		$7F
  63+ 0008 ~                                    ld       (memto),a
  64+ 0008                                      ENDM
  65+ 0008
  66+ 0008              ldAtHLtoMem:            MACRO   memto
  67+ 0008 ~                                    ld      a,(hl)
  68+ 0008 ~                                    ld      (memto),a
  69+ 0008                                      ENDM
  70+ 0008
  71+ 0008              ldCopy2Byte             MACRO  memfrom, memto
  72+ 0008 ~                                    ld       hl,(memfrom)
  73+ 0008 ~                                    ld       (memto),hl
  74+ 0008                                      ENDM
  75+ 0008
  76+ 0008              ldWriteConst            MACRO  memfrom, memto
  77+ 0008 ~                                    ld       a,memfrom
  78+ 0008 ~                                    ld       (memto),a
  79+ 0008                                      ENDM
  80+ 0008
  81+ 0008              ldWriteZero             MACRO  memto
  82+ 0008 ~                                    xor      a
  83+ 0008 ~                                    ld       (memto),a
  84+ 0008                                      ENDM
  85+ 0008
  86+ 0008              ldIXLaFromN:	        MACRO memfrom
  87+ 0008 ~                                    ld		a,(memfrom)
  88+ 0008 ~                                    ld		ixl,a
  89+ 0008                                      ENDM
  90+ 0008
  91+ 0008              ldIXHaFromN:	        MACRO memfrom
  92+ 0008 ~                                    ld		a,(memfrom)
  93+ 0008 ~                                    ld		ixh,a
  94+ 0008                                      ENDM
  95+ 0008
  96+ 0008              ldIYLaFromN:	        MACRO memfrom
  97+ 0008 ~                                    ld		a,(memfrom)
  98+ 0008 ~                                    ld		iyl,a
  99+ 0008                                      ENDM
 100+ 0008
 101+ 0008              ldIYHaFromN:	        MACRO memfrom
 102+ 0008 ~                                    ld		a,(memfrom)
 103+ 0008 ~                                    ld		iyh,a
 104+ 0008                                      ENDM
 105+ 0008
 106+ 0008              ldhlde:			        MACRO
 107+ 0008 ~                                    ld		h,d
 108+ 0008 ~                                    ld		l,e
 109+ 0008                                      ENDM
 110+ 0008
 111+ 0008              ldhlbc:			        MACRO
 112+ 0008 ~                                    ld		h,b
 113+ 0008 ~                                    ld		l,c
 114+ 0008                                      ENDM
 115+ 0008
 116+ 0008              ldbcde:			        MACRO
 117+ 0008 ~                                    ld		b,d
 118+ 0008 ~                                    ld		c,e
 119+ 0008                                      ENDM
 120+ 0008
 121+ 0008              lddebc:			        MACRO
 122+ 0008 ~                                    ld		d,b
 123+ 0008 ~                                    ld		e,c
 124+ 0008                                      ENDM
 125+ 0008
 126+ 0008              ldbchl:			        MACRO
 127+ 0008 ~                                    ld		b,h
 128+ 0008 ~                                    ld		c,l
 129+ 0008                                      ENDM
 130+ 0008
 131+ 0008              lddeiy:			        MACRO
 132+ 0008 ~                                    ld		d,iyh
 133+ 0008 ~                                    ld		e,iyl
 134+ 0008                                      ENDM
 135+ 0008
 136+ 0008              ldiyde:			        MACRO
 137+ 0008 ~                                    ld		iyh,d
 138+ 0008 ~                                    ld		iyl,e
 139+ 0008                                      ENDM
 140+ 0008
 141+ 0008
 142+ 0008              FourLDIInstrunctions:   MACRO
 143+ 0008 ~                                    ldi
 144+ 0008 ~                                    ldi
 145+ 0008 ~                                    ldi
 146+ 0008 ~                                    ldi
 147+ 0008                                      ENDM
 148+ 0008
 149+ 0008              FiveLDIInstrunctions:   MACRO
 150+ 0008 ~                                    ldi
 151+ 0008 ~                                    ldi
 152+ 0008 ~                                    ldi
 153+ 0008 ~                                    ldi
 154+ 0008 ~                                    ldi
 155+ 0008                                      ENDM
 156+ 0008
 157+ 0008              SixLDIInstrunctions:    MACRO
 158+ 0008 ~                                    ldi
 159+ 0008 ~                                    ldi
 160+ 0008 ~                                    ldi
 161+ 0008 ~                                    ldi
 162+ 0008 ~                                    ldi
 163+ 0008 ~                                    ldi
 164+ 0008                                      ENDM
 165+ 0008
 166+ 0008              EightLDIInstrunctions:  MACRO
 167+ 0008 ~            		                ldi
 168+ 0008 ~            		                ldi
 169+ 0008 ~            		                ldi
 170+ 0008 ~            		                ldi
 171+ 0008 ~            		                ldi
 172+ 0008 ~            		                ldi
 173+ 0008 ~            		                ldi
 174+ 0008 ~            		                ldi
 175+ 0008                                      ENDM
 176+ 0008
 177+ 0008              NineLDIInstrunctions:  MACRO
 178+ 0008 ~            		                ldi
 179+ 0008 ~            		                ldi
 180+ 0008 ~            		                ldi
 181+ 0008 ~            		                ldi
 182+ 0008 ~            		                ldi
 183+ 0008 ~            		                ldi
 184+ 0008 ~            		                ldi
 185+ 0008 ~            		                ldi
 186+ 0008 ~            		                ldi
 187+ 0008                                      ENDM
# file closed: ./Macros/ldCopyMacros.asm
  60  0008                                      INCLUDE "./Macros/ldIndexedMacros.asm"
# file opened: ./Macros/ldIndexedMacros.asm
   1+ 0008              GetByteAInTable:    MACRO table
   2+ 0008 ~                                ld          hl,table
   3+ 0008 ~                                add         hl,a
   4+ 0008 ~                                ld          a,(hl)
   5+ 0008                                  ENDM
   6+ 0008
   7+ 0008              HLWordAInTable:     MACRO table
   8+ 0008 ~                                ld          hl,table
   9+ 0008 ~                                sla         a
  10+ 0008 ~                                add         hl,a
  11+ 0008 ~                                ld          a,(hl)
  12+ 0008 ~                                inc         hl
  13+ 0008 ~                                ld          h,(hl)
  14+ 0008 ~                                ld          l,a
  15+ 0008                                  ENDM
  16+ 0008
  17+ 0008
  18+ 0008              ldAToHLixl:			MACRO value
  19+ 0008 ~            					ld          hl,value
  20+ 0008 ~            					ex          af,af'
  21+ 0008 ~            					ld          a,ixl
  22+ 0008 ~            					add         hl,a
  23+ 0008 ~            					ex          af,af'
  24+ 0008 ~            					ld          (hl),a
  25+ 0008              					ENDM
  26+ 0008
  27+ 0008              ldAToHLiyl:			MACRO value
  28+ 0008 ~            					ld          hl,value
  29+ 0008 ~            					ex          af,af'
  30+ 0008 ~            					ld          a,iyl
  31+ 0008 ~            					add         hl,a
  32+ 0008 ~            					ex          af,af'
  33+ 0008 ~            					ld          (hl),a
  34+ 0008              					ENDM
  35+ 0008
  36+ 0008
  37+ 0008              ldHLixlToA:         MACRO value
  38+ 0008 ~                                ld          hl,value
  39+ 0008 ~                                ex          af,af'
  40+ 0008 ~                                ld          a,ixl
  41+ 0008 ~                                add         hl,a
  42+ 0008 ~                                ld          a,(hl)
  43+ 0008                                  ENDM
  44+ 0008
  45+ 0008              ldHLiylToA:         MACRO value
  46+ 0008 ~                                ld          hl,value
  47+ 0008 ~                                ex          af,af'
  48+ 0008 ~                                ld          a,iyl
  49+ 0008 ~                                add         hl,a
  50+ 0008 ~                                ld          a,(hl)
  51+ 0008                                  ENDM
  52+ 0008
  53+ 0008              ldHLIdxAToA:        MACRO value
  54+ 0008 ~                                ld          hl,value
  55+ 0008 ~                                add         hl,a
  56+ 0008 ~                                ld          a,(hl)
  57+ 0008                                  ENDM
  58+ 0008
  59+ 0008              HLEquAddrAtHLPlusA: MACRO
  60+ 0008 ~                                sla         a
  61+ 0008 ~                                add         hl,a
  62+ 0008 ~                                ld          a,(hl)
  63+ 0008 ~                                inc         hl
  64+ 0008 ~                                ld          h,(hl)
  65+ 0008 ~                                ld          l,a
  66+ 0008                                  ENDM
# file closed: ./Macros/ldIndexedMacros.asm
  61  0008                                      INCLUDE "./Macros/jumpMacros.asm"
# file opened: ./Macros/jumpMacros.asm
   1+ 0008              JumpIfPositive:	        MACRO target
   2+ 0008 ~                                    jp		p, target
   3+ 0008                                      ENDM
   4+ 0008
   5+ 0008              JumpIfNegative:	        MACRO target
   6+ 0008 ~                                    jp		m, target
   7+ 0008                                      ENDM
   8+ 0008
   9+ 0008
  10+ 0008              JumpIfUnderflow:	    MACRO target
  11+ 0008 ~                                    jp		po, target
  12+ 0008                                      ENDM
  13+ 0008
  14+ 0008              JumpIfOverflow:	        MACRO target
  15+ 0008 ~                                    jp		po, target
  16+ 0008                                      ENDM
  17+ 0008
  18+ 0008
  19+ 0008              JumpIfNotZero:	        MACRO target
  20+ 0008 ~                                    jp	nz,target
  21+ 0008                                      ENDM
  22+ 0008
  23+ 0008              JumpIfZero:	            MACRO target
  24+ 0008 ~                                    jp	z,target
  25+ 0008                                      ENDM
  26+ 0008
  27+ 0008              ;.. Bit routines
  28+ 0008              JumpOnLeadSignSet:      MACRO   reg, target
  29+ 0008 ~                                    ld      a,reg
  30+ 0008 ~                                    and     SignOnly8Bit
  31+ 0008 ~                                    jp      nz,target
  32+ 0008                                      ENDM
  33+ 0008
  34+ 0008              JumpOnLeadSignClear:    MACRO   reg, target
  35+ 0008 ~                                    ld      a,reg
  36+ 0008 ~                                    and     SignOnly8Bit
  37+ 0008 ~                                    jp      z,target
  38+ 0008                                      ENDM
  39+ 0008
  40+ 0008              JumpOnLeadSignSetA:     MACRO   target
  41+ 0008 ~                                    and     SignOnly8Bit
  42+ 0008 ~                                    jp      nz,target
  43+ 0008                                      ENDM
  44+ 0008
  45+ 0008              JumpOnLeadSignClearA:   MACRO   target
  46+ 0008 ~                                    and     SignOnly8Bit
  47+ 0008 ~                                    jp      z,target
  48+ 0008                                      ENDM
  49+ 0008
  50+ 0008              JumpOnMemBitSet:        MACRO mem, bitnbr, target
  51+ 0008 ~                                    ld      a,(mem)
  52+ 0008 ~                                    bit 	bitnbr,a
  53+ 0008 ~                                    jp      nz,target
  54+ 0008                                      ENDM
  55+ 0008
  56+ 0008              JumpOnMemBitClear:      MACRO mem, bitnbr, target
  57+ 0008 ~                                    ld      a,(mem)
  58+ 0008 ~                                    bit 	bitnbr,a
  59+ 0008 ~                                    jp      z,target
  60+ 0008                                      ENDM
  61+ 0008
  62+ 0008              JumpOnABit5Set:         MACRO   target
  63+ 0008 ~                                    and     Bit5Only
  64+ 0008 ~                                    jp      nz,target
  65+ 0008                                      ENDM
  66+ 0008
  67+ 0008              JumpOnABit5Clear:       MACRO   target
  68+ 0008 ~                                    and     Bit5Only
  69+ 0008 ~                                    jp      z,target
  70+ 0008                                      ENDM
  71+ 0008
  72+ 0008              JumpOnBitMaskSet:       MACRO   bitmask, target
  73+ 0008 ~                                    and     bitmask
  74+ 0008 ~                                    jp      nz,target
  75+ 0008                                      ENDM
  76+ 0008
  77+ 0008              JumpOnBitMaskClear:     MACRO   bitmask, target
  78+ 0008 ~                                    and     bitmask
  79+ 0008 ~                                    jp      z,target
  80+ 0008                                      ENDM
  81+ 0008
  82+ 0008              JumpOnBitSet:           MACRO  reg, bitnbr, target
  83+ 0008 ~                                    bit 	bitnbr,reg
  84+ 0008 ~                                    jp      nz,target
  85+ 0008                                      ENDM
  86+ 0008
  87+ 0008              JumpOnBitClear:         MACRO  reg, bitnbr, target
  88+ 0008 ~                                    bit 	bitnbr,reg
  89+ 0008 ~                                    jp      z,target
  90+ 0008                                      ENDM
  91+ 0008
  92+ 0008              ; Comparison Routines
  93+ 0008              JumpIfAGTEusng:         MACRO
  94+ 0008 ~                                    jp		nc,target
  95+ 0008                                      ENDM
  96+ 0008
  97+ 0008              JumpIfAGTENusng:        MACRO reg,target
  98+ 0008 ~                                    cp     reg
  99+ 0008 ~                                    jp		nc,target
 100+ 0008                                      ENDM
 101+ 0008
 102+ 0008              JumpIfAGTEMemusng:      MACRO mem,target
 103+ 0008 ~                                    ld      hl,mem
 104+ 0008 ~                                    cp      (hl)
 105+ 0008 ~                                    jp		nc,target
 106+ 0008                                      ENDM
 107+ 0008
 108+ 0008              JumpIfALTMemusng:       MACRO mem,target
 109+ 0008 ~                                    ld      hl,mem
 110+ 0008 ~                                    cp      (hl)
 111+ 0008 ~                                    jp		c,target
 112+ 0008                                      ENDM
 113+ 0008
 114+ 0008              JumpIfMemGTENusng:      MACRO mem, value, target
 115+ 0008 ~                                    ld     a,(mem)
 116+ 0008 ~                                    cp     value
 117+ 0008 ~                                    jp	  nc,target
 118+ 0008                                      ENDM
 119+ 0008
 120+ 0008              JumpIfMemGTEMemusng:    MACRO mem, address, target
 121+ 0008 ~                                    ld   a,(mem)
 122+ 0008 ~                                    ld   hl,address
 123+ 0008 ~                                    cp   (hl)
 124+ 0008 ~                                    jp	  nc,target
 125+ 0008                                      ENDM
 126+ 0008
 127+ 0008              JumpIfMemEqMemusng:     MACRO mem, address, target
 128+ 0008 ~                                    ld   a,(mem)
 129+ 0008 ~                                    ld   hl,address
 130+ 0008 ~                                    cp   (hl)
 131+ 0008 ~                                    jp	  z,target
 132+ 0008                                      ENDM
 133+ 0008
 134+ 0008              JumpIfMemNeMemusng:     MACRO mem, address, target
 135+ 0008 ~                                    ld   a,(mem)
 136+ 0008 ~                                    ld   hl,address
 137+ 0008 ~                                    cp   (hl)
 138+ 0008 ~                                    jp	  nz,target
 139+ 0008                                      ENDM
 140+ 0008
 141+ 0008              JumpIfMemTrue:          MACRO mem, target
 142+ 0008 ~                                    ld      a,(mem)
 143+ 0008 ~                                    and     a
 144+ 0008 ~                                    jp      z, target
 145+ 0008                                      ENDM
 146+ 0008
 147+ 0008              JumpIfMemFalse:         MACRO mem, target
 148+ 0008 ~                                    ld      a,(mem)
 149+ 0008 ~                                    and     a
 150+ 0008 ~                                    jp      nz, target
 151+ 0008                                      ENDM
 152+ 0008
 153+ 0008              JumpIfATrue:            MACRO target
 154+ 0008 ~                                    and     a
 155+ 0008 ~                                    jp      z, target
 156+ 0008                                      ENDM
 157+ 0008
 158+ 0008              JumpIfAFalse:           MACRO target
 159+ 0008 ~                                    and     a
 160+ 0008 ~                                    jp      nz, target
 161+ 0008                                      ENDM
 162+ 0008
 163+ 0008              JumpIfALTusng:          MACRO target
 164+ 0008 ~                                    jp		c,target
 165+ 0008                                      ENDM
 166+ 0008
 167+ 0008              JumpIfALTNusng:         MACRO value, target
 168+ 0008 ~                                    cp      value
 169+ 0008 ~                                    jp		c, target
 170+ 0008                                      ENDM
 171+ 0008
 172+ 0008              JumpIfMemLTNusng:       MACRO mem, value, target
 173+ 0008 ~                                    ld      a,(mem)
 174+ 0008 ~                                    cp      value
 175+ 0008 ~                                    jp	  c,target
 176+ 0008                                      ENDM
 177+ 0008
 178+ 0008              JumpIfMemLTMemusng:     MACRO mem, value, target
 179+ 0008 ~                                    ld    a,(mem)
 180+ 0008 ~                                    ld    hl,value
 181+ 0008 ~                                    cp    (hl)
 182+ 0008 ~                                    jp	  c,target
 183+ 0008                                      ENDM
 184+ 0008
 185+ 0008              JumpIfMemEqNusng:       MACRO mem,value,target
 186+ 0008 ~                                    ld  a,(mem)
 187+ 0008 ~                                    cp  value
 188+ 0008 ~                                    jp  z,target
 189+ 0008                                      ENDM
 190+ 0008
 191+ 0008              JumpIfMemNeNusng:       MACRO mem,value,target
 192+ 0008 ~                                    ld  a,(mem)
 193+ 0008 ~                                    cp  value
 194+ 0008 ~                                    jp  nz,target
 195+ 0008                                      ENDM
 196+ 0008
 197+ 0008              JumpIfMemZero:          MACRO mem,target
 198+ 0008 ~                                    ld  a,(mem)
 199+ 0008 ~                                    and a
 200+ 0008 ~                                    jp  z,target
 201+ 0008                                      ENDM
 202+ 0008
 203+ 0008              JumpIfMemNotZero:       MACRO mem,target
 204+ 0008 ~                                    ld  a,(mem)
 205+ 0008 ~                                    and a
 206+ 0008 ~                                    jp  nz,target
 207+ 0008                                      ENDM
 208+ 0008
 209+ 0008              JumpIfALTMemHLusng:     MACRO target
 210+ 0008 ~                                    cp    (hl)
 211+ 0008 ~                                    jp	  c,target
 212+ 0008                                      ENDM
 213+ 0008
 214+ 0008              JumpIfANENusng:         MACRO value, target
 215+ 0008 ~                                    cp     value
 216+ 0008 ~                                    jp      nz,target
 217+ 0008                                      ENDM
 218+ 0008
 219+ 0008              JumpIfANEMemusng:       MACRO  value, target
 220+ 0008 ~                                    ld    hl,value
 221+ 0008 ~                                    cp    (hl)
 222+ 0008 ~                                    jp      nz,target
 223+ 0008                                      ENDM
 224+ 0008
 225+ 0008              JumpIfAEqNusng:         MACRO value, target
 226+ 0008 ~                                    cp     value
 227+ 0008 ~                                    jp      z,target
 228+ 0008                                      ENDM
 229+ 0008
 230+ 0008              JumpIfAIsZero:	        MACRO target
 231+ 0008 ~                                    and a   ; cp 0 - changed to and a for optimisation but affects other flags
 232+ 0008 ~                                    jp	z, target
 233+ 0008                                      ENDM
 234+ 0008
 235+ 0008              JumpIfAIsNotZero:       MACRO target
 236+ 0008 ~                                    cp	0
 237+ 0008 ~                                    jp	nz,target
 238+ 0008                                      ENDM
 239+ 0008
 240+ 0008              IfResultZeroGoto:	    MACRO target
 241+ 0008 ~                                    jp	z,target
 242+ 0008                                      ENDM
 243+ 0008
 244+ 0008              IfResultNotZeroGoto:    MACRO target
 245+ 0008 ~                                    jp	nz,target
 246+ 0008                                      ENDM
 247+ 0008
# file closed: ./Macros/jumpMacros.asm
  62  0008                                      INCLUDE "./Macros/MathsMacros.asm"
# file opened: ./Macros/MathsMacros.asm
   1+ 0008
   2+ 0008
   3+ 0008              ApplyMyRollToVector:    MACRO angle, vectorX, vectorY
   4+ 0008 ~                                    ldCopyByte angle,varQ               ; Set Q = a = alpha (the roll angle to rotate through)
   5+ 0008 ~                                    ldCopy2Byte vectorY, varR           ; RS =  nosev_y
   6+ 0008 ~                                    ldCopyByte  vectorX, varP           ; set P to nosevX lo (may be redundant)
   7+ 0008 ~                                    ld a,(vectorX+1)                    ; Set A = -nosev_x_hi
   8+ 0008 ~                                    xor $80                             ;
   9+ 0008 ~                                    call  madXAequQmulAaddRS            ; Set (A X) = Q * A + (S R) = = alpha * -nosev_x_hi + nosev_y
  10+ 0008 ~                                    ld  (vectorY),de                    ; nosev_y = nosev_y - alpha * nosev_x_hi
  11+ 0008 ~                                    ldCopy2Byte vectorX, varR           ; Set (S R) = nosev_x
  12+ 0008 ~                                    ld  a,(vectorY+1)                   ;  Set A = nosev_y_hi
  13+ 0008 ~                                    call madXAequQmulAaddRS             ; Set (A X) = Q * A + (S R)
  14+ 0008 ~                                    ld  (vectorX),de                    ; nosev_x = nosev_x + alpha * nosev_y_hi
  15+ 0008                                      ENDM
  16+ 0008
  17+ 0008              SignedHLTo2C:           MACRO
  18+ 0008 ~                                    bit     7,h
  19+ 0008 ~                                    jr      z,.Done2c
  20+ 0008 ~                                    ld      a,h
  21+ 0008 ~                                    and     SignMask8Bit
  22+ 0008 ~                                    ld      h,a
  23+ 0008 ~                                    NegHL
  24+ 0008 ~            .Done2c:
  25+ 0008                                      ENDM
  26+ 0008
  27+ 0008              MemSignedTo2C:          MACRO   memfrom
  28+ 0008 ~                                    ld      hl,(memfrom)
  29+ 0008 ~                                    bit     7,h
  30+ 0008 ~                                    jr      z,.Done2c
  31+ 0008 ~                                    ld      a,h
  32+ 0008 ~                                    and     SignMask8Bit
  33+ 0008 ~                                    ld      h,a
  34+ 0008 ~            .Done2c:                ld      (memfrom),hl
  35+ 0008                                      ENDM
  36+ 0008
  37+ 0008
  38+ 0008                  ;returns result in H
  39+ 0008              EDiv10Inline:           MACRO
  40+ 0008 ~                                    ld      d,0
  41+ 0008 ~                                    ld      hl,de
  42+ 0008 ~                                    add     hl,hl
  43+ 0008 ~                                    add     hl,de
  44+ 0008 ~                                    add     hl,hl
  45+ 0008 ~                                    add     hl,hl
  46+ 0008 ~                                    add     hl,de
  47+ 0008 ~                                    add     hl,hl
  48+ 0008                                      ENDM
  49+ 0008
# file closed: ./Macros/MathsMacros.asm
  63  0008                                      INCLUDE "./Macros/MMUMacros.asm"
# file opened: ./Macros/MMUMacros.asm
   1+ 0008              MMUSelectROMS:       MACRO
   2+ 0008 ~                                 nextreg EXSDOSMMU0,        BankROM
   3+ 0008 ~                                 nextreg EXSDOSMMU1,        BankROM
   4+ 0008                                   ENDM
   5+ 0008
   6+ 0008              MMUSelectSpriteBank: MACRO
   7+ 0008 ~            					 nextreg SpritememMMU,	    BankSPRITE
   8+ 0008              					 ENDM
   9+ 0008
  10+ 0008              MMUSelectConsoleBank: MACRO
  11+ 0008 ~            					 nextreg ConsoleImageDataMMU,  BankConsole
  12+ 0008              					 ENDM
  13+ 0008
  14+ 0008              MMUSelectLayer1: 	 MACRO
  15+ 0008 ~            					 nextreg L1memMMU,		    BankLAYER1
  16+ 0008              					 ENDM
  17+ 0008
  18+ 0008              MMUSelectLayer2: 	 MACRO
  19+ 0008 ~            					 nextreg L2memMMU,		    BankLAYER2
  20+ 0008              					 ENDM
  21+ 0008
  22+ 0008              MMUSelectResetUniv:  MACRO
  23+ 0008 ~                                 nextreg  ResetUniverseMMU, BankResetUniv
  24+ 0008                                   ENDM
  25+ 0008
  26+ 0008              MMUSelectShipBank1:  MACRO
  27+ 0008 ~            					 nextreg ShipModelMMU,	    BankShipModels1
  28+ 0008              					 ENDM
  29+ 0008              MMUSelectShipBank2:  MACRO
  30+ 0008 ~            					 nextreg ShipModelMMU,	    BankShipModels2
  31+ 0008              					 ENDM
  32+ 0008              MMUSelectShipBank3:  MACRO
  33+ 0008 ~            					 nextreg ShipModelMMU,	    BankShipModels3
  34+ 0008              					 ENDM
  35+ 0008              MMUSelectShipBank4:  MACRO
  36+ 0008 ~            					 nextreg ShipModelMMU,	    BankShipModels4
  37+ 0008              					 ENDM
  38+ 0008
  39+ 0008              MMUSelectShipBankA   MACRO
  40+ 0008 ~            					 nextreg ShipModelMMU,	    a
  41+ 0008              					 ENDM
  42+ 0008
  43+ 0008              MMUSelectShipBankN:  MACRO value
  44+ 0008 ~            					 nextreg ShipModelMMU,	    value
  45+ 0008              					 ENDM
  46+ 0008
  47+ 0008              MMUSelectCommander:	 MACRO
  48+ 0008 ~                                 nextreg CommanderMMU,       BankCommander
  49+ 0008              					 ENDM
  50+ 0008
  51+ 0008              MMUSelectStockTable: MACRO
  52+ 0008 ~                                 nextreg StockTableMMU,     BankStockTable
  53+ 0008              					 ENDM
  54+ 0008
  55+ 0008              MMUSelectCpySrcA:    MACRO
  56+ 0008 ~                                 nextreg DMACpySourceMMU,	a
  57+ 0008              					 ENDM
  58+ 0008
  59+ 0008              MMUSelectCpySrcN:    MACRO value
  60+ 0008 ~                                 nextreg DMACpySourceMMU,	value
  61+ 0008              					 ENDM
  62+ 0008
  63+ 0008              MMUSelectSun:        MACRO
  64+ 0008 ~                                 nextreg SunMMU,            BankSunData
  65+ 0008                                   ENDM
  66+ 0008
  67+ 0008              MMUSelectPlanet:     MACRO
  68+ 0008 ~                                 nextreg PlanetMMU,         PlanetBankAddr
  69+ 0008                                   ENDM
  70+ 0008
  71+ 0008              MMUSelectUniverseA:  MACRO
  72+ 0008 ~                                 add    a,BankUNIVDATA0
  73+ 0008 ~                                 nextreg UniverseMMU,       a
  74+ 0008                                   ENDM
  75+ 0008
  76+ 0008              MMUSelectUniverseN:  MACRO value
  77+ 0008 ~                                 nextreg UniverseMMU,       BankUNIVDATA0+value
  78+ 0008                                   ENDM
  79+ 0008
  80+ 0008              MMUSelectGalaxyA:    MACRO
  81+ 0008 ~                                 nextreg GalaxyDataMMU,       a
  82+ 0008                                   ENDM
  83+ 0008
  84+ 0008              MMUSelectGalaxyN:    MACRO value
  85+ 0008 ~                                 nextreg GalaxyDataMMU,     BankGalaxyData0+value
  86+ 0008                                   ENDM
  87+ 0008              MMUSelectGalaxyACopy:MACRO
  88+ 0008 ~                                 nextreg UniverseMMU,       a
  89+ 0008                                   ENDM
  90+ 0008
  91+ 0008              MMUSelectUniverseAbs:MACRO value
  92+ 0008 ~                                 nextreg UniverseMMU,       value
  93+ 0008                                   ENDM
  94+ 0008
  95+ 0008              MMUSelectMenuGalCht: MACRO
  96+ 0008 ~                                 nextreg MenuGalChtMMU,		BankMenuGalCht
  97+ 0008              					 ENDM
  98+ 0008
  99+ 0008              MMUSelectMenuShrCht: MACRO
 100+ 0008 ~            					 nextreg MenuShrChtMMU,		BankMenuShrCht
 101+ 0008              					 ENDM
 102+ 0008
 103+ 0008              MMUSelectMenuInvent: MACRO
 104+ 0008 ~                                 nextreg MenuInventMMU,		BankMenuInvent
 105+ 0008              					 ENDM
 106+ 0008
 107+ 0008              MMUSelectMenuSystem: MACRO
 108+ 0008 ~                                 nextreg MenuSystemMMU,		BankMenuSystem
 109+ 0008              					 ENDM
 110+ 0008
 111+ 0008              MMUSelectMenuMarket: MACRO
 112+ 0008 ~                                 nextreg MenuMarketMMU,		BankMenuMarket
 113+ 0008              					 ENDM
 114+ 0008
 115+ 0008              MMUSelectMenuStatus: MACRO
 116+ 0008 ~                                 nextreg MenuStatusMMU,		BankMenuStatus
 117+ 0008              					 ENDM
 118+ 0008
 119+ 0008              MMUSelectViewFront:  MACRO
 120+ 0008 ~                                 nextreg ScreenBankMMU,		BankFrontView
 121+ 0008              					 ENDM
 122+ 0008
 123+ 0008              MMUSelectScreenA:    MACRO
 124+ 0008 ~                                 nextreg ScreenBankMMU,		a
 125+ 0008              					 ENDM
 126+ 0008
# file closed: ./Macros/MMUMacros.asm
  64  0008                                      INCLUDE "./Macros/NegateMacros.asm"
# file opened: ./Macros/NegateMacros.asm
   1+ 0008
   2+ 0008              NegIY:			    MACRO
   3+ 0008 ~                                xor a
   4+ 0008 ~                                sub iyl
   5+ 0008 ~                                ld iyl,a
   6+ 0008 ~                                sbc a,a
   7+ 0008 ~                                sub iyh
   8+ 0008 ~                                ld iyh,a
   9+ 0008                                  ENDM
  10+ 0008
  11+ 0008              NegHL:			    MACRO
  12+ 0008 ~                                xor a
  13+ 0008 ~                                sub l
  14+ 0008 ~                                ld l,a
  15+ 0008 ~                                sbc a,a
  16+ 0008 ~                                sub h
  17+ 0008 ~                                ld h,a
  18+ 0008                                  ENDM
  19+ 0008
  20+ 0008              NegDE:			    MACRO
  21+ 0008 ~                                xor a
  22+ 0008 ~                                sub e
  23+ 0008 ~                                ld e,a
  24+ 0008 ~                                sbc a,a
  25+ 0008 ~                                sub d
  26+ 0008 ~                                ld d,a
  27+ 0008                                  ENDM
  28+ 0008
  29+ 0008              NegBC:			    MACRO
  30+ 0008 ~                                xor a
  31+ 0008 ~                                sub c
  32+ 0008 ~                                ld c,a
  33+ 0008 ~                                sbc a,a
  34+ 0008 ~                                sub  b
  35+ 0008 ~                                ld b,a
  36+ 0008                                  ENDM
  37+ 0008
  38+ 0008              NegH                MACRO
  39+ 0008 ~                                ld      a,h
  40+ 0008 ~                                neg
  41+ 0008 ~                                ld      h,a
  42+ 0008                                  ENDM
  43+ 0008
  44+ 0008              NegD                MACRO
  45+ 0008 ~                                ld      a,d
  46+ 0008 ~                                neg
  47+ 0008 ~                                ld      d,a
  48+ 0008                                  ENDM
  49+ 0008
  50+ 0008              NegB                MACRO
  51+ 0008 ~                                ld      a,b
  52+ 0008 ~                                neg
  53+ 0008 ~                                ld      b,a
  54+ 0008                                  ENDM
  55+ 0008
# file closed: ./Macros/NegateMacros.asm
  65  0008                                      INCLUDE "./Macros/returnMacros.asm"
# file opened: ./Macros/returnMacros.asm
   1+ 0008              ReturnOnBitSet:         MACRO  reg, bitnbr,
   2+ 0008 ~                                    bit 	bitnbr,reg
   3+ 0008 ~                                    ret     nz
   4+ 0008                                      ENDM
   5+ 0008
   6+ 0008              ReturnOnMemBitSet:      MACRO mem, bitnbr
   7+ 0008 ~                                    ld   a,(mem)
   8+ 0008 ~                                    bit 	bitnbr,a
   9+ 0008 ~                                    ret     nz
  10+ 0008                                      ENDM
  11+ 0008
  12+ 0008              ReturnOnBitClear:       MACRO reg, bitnbr
  13+ 0008 ~                                    bit 	bitnbr,reg
  14+ 0008 ~                                    ret		z
  15+ 0008                                      ENDM
  16+ 0008
  17+ 0008              ReturnOnMemBitClear:    MACRO mem, bitnbr
  18+ 0008 ~                                    ld     a,(mem)
  19+ 0008 ~                                    bit 	bitnbr,a
  20+ 0008 ~                                    ret		z
  21+ 0008                                      ENDM
  22+ 0008
  23+ 0008              ReturnIfMemFalse:       MACRO   mem
  24+ 0008 ~                                    ld      a,(mem)
  25+ 0008 ~                                    and     a
  26+ 0008 ~                                    ret     nz
  27+ 0008                                      ENDM
  28+ 0008
  29+ 0008              ReturnIfMemTrue:        MACRO   mem
  30+ 0008 ~                                    ld      a,(mem)
  31+ 0008 ~                                    and     a
  32+ 0008 ~                                    ret     z
  33+ 0008                                      ENDM
  34+ 0008
  35+ 0008              ReturnIfAIsZero:        MACRO
  36+ 0008 ~                                    and     a
  37+ 0008 ~                                    ret     z
  38+ 0008                                      ENDM
  39+ 0008
  40+ 0008              ReturnIfMemisZero:      MACRO mem
  41+ 0008 ~                                    ld   a,(mem)
  42+ 0008 ~                                    and a
  43+ 0008 ~                                    ret    z
  44+ 0008                                      ENDM
  45+ 0008
  46+ 0008              ReturnIfBitMaskClear    MACRO   bitmask
  47+ 0008 ~                                    and     bitmask
  48+ 0008 ~                                    ret     z
  49+ 0008                                      ENDM
  50+ 0008
  51+ 0008              ReturnIfBitMaskSet      MACRO   bitmask
  52+ 0008 ~                                    and     bitmask
  53+ 0008 ~                                    ret     nz
  54+ 0008                                      ENDM
  55+ 0008
  56+ 0008              ReturnIfMemEquN:        MACRO mem, value
  57+ 0008 ~                                    ld     a,(mem)
  58+ 0008 ~                                    cp     value
  59+ 0008 ~                                    ret    nz
  60+ 0008                                      ENDM
  61+ 0008
  62+ 0008              ReturnIfMemNeNusng:     MACRO mem, value
  63+ 0008 ~                                    ld   a,(mem)
  64+ 0008 ~                                    cp     value
  65+ 0008 ~                                    ret    z
  66+ 0008                                      ENDM
  67+ 0008
  68+ 0008              ReturnIfRegNotZero:     MACRO reg
  69+ 0008 ~                                    ld      a, reg
  70+ 0008 ~                                    and     a
  71+ 0008 ~                                    ret     nz
  72+ 0008                                      ENDM
  73+ 0008
  74+ 0008              ReturnIfANotZero:       MACRO
  75+ 0008 ~                                    and     a
  76+ 0008 ~                                    ret     nz
  77+ 0008                                      ENDM
  78+ 0008
  79+ 0008              ReturnIfNotZero:        MACRO
  80+ 0008 ~                                    ret     nz
  81+ 0008                                      ENDM
  82+ 0008
  83+ 0008
  84+ 0008              ReturnIfNegative:       MACRO
  85+ 0008 ~                                    ret     m
  86+ 0008                                      ENDM
  87+ 0008
  88+ 0008
  89+ 0008              ReturnIfMemNotZero:     MACRO mem
  90+ 0008 ~                                    ld     a,(mem)
  91+ 0008 ~                                    and     a
  92+ 0008 ~                                    ret    nz
  93+ 0008                                      ENDM
  94+ 0008
  95+ 0008              ReturnIfAGTEusng:       MACRO value
  96+ 0008 ~                                    cp    value
  97+ 0008 ~                                    ret	 nc
  98+ 0008                                      ENDM
  99+ 0008
 100+ 0008              ReturnIfALTNusng:       MACRO value
 101+ 0008 ~                                    cp    value
 102+ 0008 ~                                    ret	 c
 103+ 0008                                      ENDM
 104+ 0008
 105+ 0008              ReturnIfAGTENusng:      MACRO value
 106+ 0008 ~                                    cp    value
 107+ 0008 ~                                    ret	 nc
 108+ 0008                                      ENDM
 109+ 0008
 110+ 0008              ReturnIfAGTEMemusng:    MACRO value
 111+ 0008 ~                                    ld      hl,value
 112+ 0008 ~                                    cp      (hl)
 113+ 0008 ~                                    ret	    nc
 114+ 0008                                      ENDM
 115+ 0008
 116+ 0008              ReturnIfANENusng:       MACRO value
 117+ 0008 ~                                    cp      value
 118+ 0008 ~                                    ret     nz
 119+ 0008                                      ENDM
 120+ 0008
 121+ 0008              ReturnIfAEqNusng:       MACRO value
 122+ 0008 ~                                    cp      value
 123+ 0008 ~                                    ret     z
 124+ 0008                                      ENDM
 125+ 0008
# file closed: ./Macros/returnMacros.asm
  66  0008                                      INCLUDE "./Macros/ShiftMacros.asm"
# file opened: ./Macros/ShiftMacros.asm
   1+ 0008              ShiftIYRight1: MACRO
   2+ 0008 ~            			   ld 	a,iyh
   3+ 0008 ~            			   srl 	a
   4+ 0008 ~            			   ld	iyh,a
   5+ 0008 ~            			   ld 	a,iyl
   6+ 0008 ~            			   rra
   7+ 0008 ~            			   ld	iyl,a
   8+ 0008              			   ENDM
   9+ 0008
  10+ 0008              ShiftHLRight1: MACRO
  11+ 0008 ~            			   srl h
  12+ 0008 ~            			   rr  l
  13+ 0008              			   ENDM
  14+ 0008
  15+ 0008              ShiftDERight1: MACRO
  16+ 0008 ~            			   srl d
  17+ 0008 ~            			   rr  e
  18+ 0008              			   ENDM
  19+ 0008
  20+ 0008              ShiftBCRight1: MACRO
  21+ 0008 ~            			   srl b
  22+ 0008 ~            			   rr  c
  23+ 0008              			   ENDM
  24+ 0008
  25+ 0008
  26+ 0008
  27+ 0008              ShiftHLDiv8:   MACRO
  28+ 0008 ~            			   srl h
  29+ 0008 ~            			   rr  l
  30+ 0008 ~            			   srl h
  31+ 0008 ~            			   rr  l
  32+ 0008 ~            			   srl h
  33+ 0008 ~            			   rr  l
  34+ 0008              			   ENDM
  35+ 0008
  36+ 0008              ShiftHLLeft1:  MACRO
  37+ 0008 ~            			   sla l
  38+ 0008 ~            			   rl  h
  39+ 0008              			   ENDM
  40+ 0008
  41+ 0008              ShiftDELeft1:  MACRO
  42+ 0008 ~            			   sla e
  43+ 0008 ~            			   rl  d
  44+ 0008              			   ENDM
  45+ 0008
  46+ 0008
  47+ 0008              RollDELeft1:   MACRO
  48+ 0008 ~                           rl  e
  49+ 0008 ~                           rl  d
  50+ 0008                             ENDM
  51+ 0008
  52+ 0008              ShiftBCLeft1:  MACRO
  53+ 0008 ~            			   sla c
  54+ 0008 ~            			   rl  b
  55+ 0008              			   ENDM
  56+ 0008
  57+ 0008
  58+ 0008              ShiftMem16Right1:   MACRO memaddr
  59+ 0008 ~                                ld    hl,(memaddr)
  60+ 0008 ~                                srl   h
  61+ 0008 ~                                rr    l
  62+ 0008 ~                                ld    (memaddr),hl
  63+ 0008                                  ENDM
  64+ 0008
  65+ 0008              ShiftMem8Right1:    MACRO memaddr
  66+ 0008 ~                                ld      a,(memaddr)
  67+ 0008 ~                                srl     a
  68+ 0008 ~                                ld      (memaddr),a
  69+ 0008                                  ENDM
  70+ 0008
  71+ 0008
  72+ 0008              ShiftMem8Left1A:    MACRO memaddr
  73+ 0008 ~                                ld      a,(memaddr)
  74+ 0008 ~                                sla     a
  75+ 0008 ~                                ld      (memaddr),a
  76+ 0008                                  ENDM
  77+ 0008
# file closed: ./Macros/ShiftMacros.asm
  67  0008                                      INCLUDE "./Macros/signBitMacros.asm"
# file opened: ./Macros/signBitMacros.asm
   1+ 0008              ClearSignBitMem:        MACRO mem
   2+ 0008 ~                                    ld      a,(mem)
   3+ 0008 ~                                    and     SignMask8Bit
   4+ 0008 ~                                    ld      (mem),a
   5+ 0008                                      ENDM
   6+ 0008
   7+ 0008              SetSignBitMem:          MACRO   mem
   8+ 0008 ~                                    ld      a,(mem)
   9+ 0008 ~                                    or      SignOnly8Bit
  10+ 0008 ~                                    ld      (mem),a
  11+ 0008                                      ENDM
  12+ 0008
  13+ 0008              FlipSignMem:            MACRO mem
  14+ 0008 ~                                    ld  a,(mem)
  15+ 0008 ~                                    xor SignOnly8Bit
  16+ 0008 ~                                    ld  (mem),a
  17+ 0008                                      ENDM
  18+ 0008
  19+ 0008              ClearSignBit:           MACRO reg
  20+ 0008 ~                                    ld      a,reg
  21+ 0008 ~                                    and     SignMask8Bit
  22+ 0008 ~                                    ld      reg,a
  23+ 0008                                      ENDM
  24+ 0008
  25+ 0008              SetSignBit:             MACRO   reg
  26+ 0008 ~                                    ld      a,reg
  27+ 0008 ~                                    or      SignOnly8Bit
  28+ 0008 ~                                    ld      reg,a
  29+ 0008                                      ENDM
  30+ 0008
  31+ 0008              FlipSignBit:            MACRO   reg
  32+ 0008 ~                                    ld      a,reg
  33+ 0008 ~                                    xor     SignOnly8Bit
  34+ 0008 ~                                    ld      reg,a
  35+ 0008                                      ENDM
  36+ 0008
  37+ 0008              ClearSignBitA:          MACRO
  38+ 0008 ~                                    and     SignMask8Bit
  39+ 0008                                      ENDM
  40+ 0008
  41+ 0008              SetSignBitA:            MACRO
  42+ 0008 ~                                    or      SignOnly8Bit
  43+ 0008                                      ENDM
  44+ 0008
  45+ 0008              FlipSignBitA:           MACRO
  46+ 0008 ~                                    xor     SignOnly8Bit
  47+ 0008                                      ENDM
  48+ 0008
# file closed: ./Macros/signBitMacros.asm
  68  0008                  INCLUDE "./Variables/general_variables_macros.asm"
# file opened: ./Variables/general_variables_macros.asm
   1+ 0008              ; limited to 255 character length
   2+ 0008              CountLengthHL:          MACRO   Limiter
   3+ 0008 ~                                    ld      de,hl
   4+ 0008 ~                                    ld      bc,Limiter
   5+ 0008 ~                                    xor     a
   6+ 0008 ~                                    cpir
   7+ 0008 ~                                    ClearCarryFlag
   8+ 0008 ~                                    sbc     hl,de
   9+ 0008 ~                                    ld      a,l
  10+ 0008 ~                                    ret
  11+ 0008                                      ENDM
  12+ 0008
  13+ 0008              HalfLengthHL:           MACRO
  14+ 0008 ~                                    ld      b,0
  15+ 0008 ~            .CountLenLoop:          ld      a,(hl)
  16+ 0008 ~                                    cp      0
  17+ 0008 ~                                    jr      z,.DoneCount
  18+ 0008 ~                                    inc     b
  19+ 0008 ~                                    inc     hl
  20+ 0008 ~                                    jr      .CountLenLoop
  21+ 0008 ~            .DoneCount:             ld      a,32
  22+ 0008 ~                                    sub     b
  23+ 0008 ~                                    sra     a
  24+ 0008                                      ENDM
  25+ 0008
  26+ 0008              MakeInnocentMacro:		MACRO
  27+ 0008 ~            						xor		a
  28+ 0008 ~            						ld		(FugitiveInnocentStatus),a
  29+ 0008              						ENDM
  30+ 0008
  31+ 0008              NoEscapePodMacro:		MACRO
  32+ 0008 ~            						xor		a
  33+ 0008 ~            						ld		(EscapePod),a
  34+ 0008              						ENDM
  35+ 0008
  36+ 0008              MaxFuelLevel            EQU     70              ; 7.0 light years max
  37+ 0008              MaxFuelMacro:			MACRO
  38+ 0008 ~            						ld		a,MaxFuelLevel
  39+ 0008 ~            						ld		(Fuel),a
  40+ 0008              						ENDM
  41+ 0008
  42+ 0008              MaxThrottle:            MACRO
  43+ 0008 ~                                    ld      a,(SHIPMAXSPEED)
  44+ 0008 ~                                    ld      (DELTA),a
  45+ 0008 ~                                    ld      d,a
  46+ 0008 ~                                    ld      e,4
  47+ 0008 ~                                    mul
  48+ 0008 ~                                    ld      (DELT4Lo),de
  49+ 0008                                      ENDM
  50+ 0008
  51+ 0008              ZeroThrottle:           MACRO
  52+ 0008 ~                                    xor     a
  53+ 0008 ~                                    ld      (DELTA),a
  54+ 0008 ~                                    ld      (DELT4Lo),a
  55+ 0008 ~                                    ld      (DELT4Lo+1),a
  56+ 0008                                      ENDM
  57+ 0008
  58+ 0008              ZeroPitch:              MACRO
  59+ 0008 ~                                    xor     a
  60+ 0008 ~                                    ld      (BET2),a
  61+ 0008 ~                                    ld      (BET2FLIP),a
  62+ 0008 ~                                    ld      (JSTY),a
  63+ 0008 ~                                    ld      (BETA),a
  64+ 0008                                      ENDM
  65+ 0008
  66+ 0008              ZeroRoll:               MACRO
  67+ 0008 ~                                    xor     a                              ; zero roll and climb
  68+ 0008 ~                                    ld      (ALP2),a
  69+ 0008 ~                                    ld      (ALP2FLIP),a
  70+ 0008 ~                                    ld      (JSTX),a
  71+ 0008 ~                                    ld      (ALPHA),a
  72+ 0008                                      ENDM
  73+ 0008
  74+ 0008              CorrectPostJumpFuel:    MACRO
  75+ 0008 ~                                    ld      a,(Fuel)
  76+ 0008 ~                                    ld      hl,Distance
  77+ 0008 ~                                    sub     a,(hl)
  78+ 0008 ~                                    ld      (Fuel),a
  79+ 0008                                      ENDM
  80+ 0008
  81+ 0008              AnyMissilesLeft:        MACRO
  82+ 0008 ~                                    ld      a,(NbrMissiles)
  83+ 0008 ~                                    and     a
  84+ 0008                                      ENDM
  85+ 0008
  86+ 0008              SetMissileTargetA:      MACRO
  87+ 0008 ~                                    ld      (MissileTarget),a
  88+ 0008                                      ENDM
  89+ 0008
  90+ 0008              IsMissileLockedOn:      MACRO
  91+ 0008 ~                                    ld      a,(MissileTarget)
  92+ 0008 ~                                    cp      $FF
  93+ 0008 ~                                    ret     z
  94+ 0008 ~                                    ReturnIfSlotAEmpty                  ; if target slot is empty
  95+ 0008 ~                                    ret                                 ; will return as nz now
  96+ 0008                                      ENDM
  97+ 0008
  98+ 0008              ClearMissileTarget:     MACRO
  99+ 0008 ~                                    xor     a                           ; Set missile target to FF
 100+ 0008 ~                                    dec     a
 101+ 0008 ~                                    ld      (MissileTarget),a
 102+ 0008 ~                                    SetMemFalse MissileLaunchFlag
 103+ 0008                                      ENDM
 104+ 0008
 105+ 0008              ClearECM:               MACRO
 106+ 0008 ~                                    xor     a
 107+ 0008 ~                                    ld      (ECMLoopA),a
 108+ 0008 ~                                    ld      (ECMLoopB),a
 109+ 0008                                      ENDM
 110+ 0008
 111+ 0008              ChargeEnergyAndShields: MACRO
 112+ 0008 ~                                    ld      a,$FF
 113+ 0008 ~                                    ld      (PlayerEnergy),a
 114+ 0008 ~                                    ld      (ForeShield),a
 115+ 0008 ~                                    ld      (AftShield),a
 116+ 0008                                      ENDM
 117+ 0008
 118+ 0008              CopyPresentSystemToTarget: MACRO
 119+ 0008 ~                                    ld      hl,(PresentSystemX)
 120+ 0008 ~                                    ld      (TargetSystemX),hl
 121+ 0008                                      ENDM
 122+ 0008
 123+ 0008              CopyTargetSystemToPresent: MACRO
 124+ 0008 ~                                    ld      hl,(TargetSystemX)
 125+ 0008 ~                                    ld      (PresentSystemX),hl
 126+ 0008                                      ENDM
 127+ 0008
 128+ 0008              HalveFugitiveStatus:    MACRO
 129+ 0008 ~                                    ld      hl,FugitiveInnocentStatus
 130+ 0008 ~                                    srl     (hl)
 131+ 0008                                      ENDM
 132+ 0008
 133+ 0008              ClearForceTransition    MACRO
 134+ 0008 ~                                    ld      a,$FF
 135+ 0008 ~                                    ld      (ScreenTransitionForced),a
 136+ 0008                                      ENDM
 137+ 0008
 138+ 0008              ForceTransition:        MACRO newScreen
 139+ 0008 ~                                    ld      a,newScreen
 140+ 0008 ~                                    ld      (ScreenTransitionForced), a
 141+ 0008                                      ENDM
 142+ 0008
 143+ 0008              IsSpaceStationPresent:  MACRO
 144+ 0008 ~                                    ld      a,(SpaceStationSafeZone)
 145+ 0008 ~                                    and     a
 146+ 0008                                      ENDM
 147+ 0008
 148+ 0008              SetSafeZone:            MACRO
 149+ 0008 ~                                    xor     a
 150+ 0008 ~                                    ld      (SpaceStationSafeZone),a
 151+ 0008                                      ENDM
 152+ 0008
 153+ 0008              ClearSafeZone:          MACRO
 154+ 0008 ~                                    ld      a,$FF
 155+ 0008 ~                                    ld      (SpaceStationSafeZone),a
 156+ 0008                                      ENDM
 157+ 0008
 158+ 0008              ClearTemperatures:      MACRO
 159+ 0008 ~                                    xor     a
 160+ 0008 ~                                    ld      (CabinTemperature),a
 161+ 0008 ~                                    ld      (GunTemperature),a
 162+ 0008                                      ENDM
 163+ 0008
 164+ 0008              CoolCabin:              MACRO
 165+ 0008 ~                                    ld      a,(CabinTemperature)
 166+ 0008 ~                                    and     a
 167+ 0008 ~                                    jr      z,.AlreadyCool
 168+ 0008 ~                                    dec     a
 169+ 0008 ~                                    ld      (CabinTemperature),a
 170+ 0008 ~            .AlreadyCool:
 171+ 0008                                      ENDM
 172+ 0008
 173+ 0008              CoolLasers:             MACRO
 174+ 0008 ~                                    ld      a,(GunTemperature)
 175+ 0008 ~                                    and     a
 176+ 0008 ~                                    jr      z,.AlreadyCool
 177+ 0008 ~                                    dec     a
 178+ 0008 ~                                    ld      (GunTemperature),a
 179+ 0008 ~            .AlreadyCool:
 180+ 0008                                      ENDM
 181+ 0008
 182+ 0008              ; type 255 is "not fitted"
 183+ 0008
 184+ 0008
 185+ 0008              InitEventCounter:       MACRO
 186+ 0008 ~                                    xor     a
 187+ 0008 ~                                    ld      (EventCounter),a
 188+ 0008                                      ENDM
 189+ 0008
 190+ 0008              ClearMissJump:          MACRO
 191+ 0008 ~                                    ld      a,$FF
 192+ 0008 ~                                    ld      (MissJumpFlag),a
 193+ 0008                                      ENDM
 194+ 0008
 195+ 0008
 196+ 0008              DrainSystem:            MACRO   SystemMem, DrainMem
 197+ 0008 ~                                    ld      a,(DrainMem)
 198+ 0008 ~                                    ld      b,a
 199+ 0008 ~                                    ld      a,(SystemMem)
 200+ 0008 ~                                    sub     a,b
 201+ 0008 ~                                    ld      (SystemMem),a
 202+ 0008 ~                                    jr      c,.ZeroSystem
 203+ 0008 ~                                    jp      .ExitPoint
 204+ 0008 ~            .ZeroSystem:            ZeroA
 205+ 0008 ~                                    ld      (SystemMem),a
 206+ 0008 ~            .ExitPoint
 207+ 0008                                      ENDM
 208+ 0008
 209+ 0008              BoostSystem:            MACRO   SystemMem, BoostMem
 210+ 0008 ~                                    ld      a,(BoostMem)
 211+ 0008 ~                                    ld      b,a
 212+ 0008 ~                                    ld      a,(SystemMem)
 213+ 0008 ~                                    add     b
 214+ 0008 ~                                    ld      (SystemMem),a
 215+ 0008 ~                                    jr      c, .MaxSystem
 216+ 0008 ~                                    jp      .ExitPoint
 217+ 0008 ~            .MaxSystem:             ld      a,255
 218+ 0008 ~                                    ld      (SystemMem),a
 219+ 0008 ~            .ExitPoint
 220+ 0008                                      ENDM
 221+ 0008
# file closed: ./Variables/general_variables_macros.asm
  69  0008
  70  0008              charactersetaddr		equ 15360
  71  0008              STEPDEBUG               equ 1
  72  0008
  73  0008
  74  0008                                      ORG         $8000
  75  8000 F3                                   di
  76  8001                                      ; "STARTUP"
  77  8001                                      MMUSelectLayer1
  77  8001 ED 91 57 3A >					 nextreg L1memMMU,		    BankLAYER1
  78  8005 CD 80 E0                             call		l1_cls
  79  8008 3E 07                                ld			a,7
  80  800A CD 9B E0                             call		l1_attr_cls_to_a
  81  800D 3E FF                                ld          a,$FF
  82  800F CD A5 E0                             call        l1_set_border
  83  8012              Initialise:             MMUSelectLayer2
  83  8012 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
  84  8016 CD FA E0                             call 		l2_initialise
  85  8019 CD F3 E0                             call		l2_cls
  86  801C              ;..................................................................................................................................
  87  801C                                      MMUSelectLayer2
  87  801C ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
  88  8020              SunLoop:                MMUSelectSun
  88  8020 ED 91 56 53 >                     nextreg SunMMU,            BankSunData
  89  8024 21 01 00                             ld          hl,$0001
  90  8027 22 10 C0                             ld          (SBnKxlo),hl
  91  802A 22 13 C0                             ld          (SBnKylo),hl
  92  802D 21 60 01                             ld          hl,$0160
  93  8030 22 16 C0                             ld          (SBnKzlo),hl
  94  8033                                      ZeroA
  94  8033 AF          >                        xor a
  95  8034 32 12 C0                             ld          (SBnKxsgn),a
  96  8037 32 15 C0                             ld          (SBnKysgn),a
  97  803A 32 18 C0                             ld          (SBnKzsgn),a
  98  803D CD 23 C6                             call        SunUpdateAndRender
  99  8040                                      MMUSelectLayer2
  99  8040 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 100  8044 C3 20 80                             jp          SunLoop
 101  8047              ;..................................................................................................................................
 102  8047
 103  8047                  INCLUDE	"./Hardware/memfill_dma.asm"
# file opened: ./Hardware/memfill_dma.asm
   1+ 8047
   2+ 8047 00           memfillvalue		DB 0
   3+ 8048 83 C3 C7 CB  memfill        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   3+ 804C 7D
   4+ 804D 47 80        memfill_astrt  		DW memfillvalue
   5+ 804F 00 40        memfill_length 		DB $00,$40
   6+ 8051 24 10 AD     					DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
   7+ 8054 00 00        memfill_bstrt  		DB $00,$00
   8+ 8056 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
   9+ 805A              memfill_cmd_len	  	EQU $ - memfill
  10+ 805A
  11+ 805A              memfill_dma:
  12+ 805A              ; "memfill_dma, hl = address to fill, a = value, de = length"
  13+ 805A              .set_fill_value:
  14+ 805A 32 47 80     	ld 		(memfillvalue),a
  15+ 805D              .set_target:
  16+ 805D 22 54 80     	ld		(memfill_bstrt),hl
  17+ 8060              .set_length:
  18+ 8060 ED 53 4F 80  	ld		(memfill_length),de
  19+ 8064              .write_dma:
  20+ 8064 21 48 80     	ld 		hl, memfill
  21+ 8067 06 12        	ld 		b, memfill_cmd_len
  22+ 8069 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
  23+ 806B ED B3        	otir
  24+ 806D C9           	ret
  25+ 806E
# file closed: ./Hardware/memfill_dma.asm
 104  806E                  INCLUDE	"./Hardware/memcopy_dma.asm"
# file opened: ./Hardware/memcopy_dma.asm
   1+ 806E
   2+ 806E 83 C3 C7 CB  memcopy        		DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   2+ 8072 7D
   3+ 8073 00 00        memcopy_astrt  		DB $00,$00
   4+ 8075 00 40        memcopy_length 		DB $00,$40
   5+ 8077 14 10 AD     					DB DMA_WR1_P1INC_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
   6+ 807A 00 00        memcopy_bstrt  		DB $00,$00
   7+ 807C 82 CF B3 87  					DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
   8+ 8080              memcopy_cmd_len	  	equ $ - memcopy
   9+ 8080
  10+ 8080              memcopy_dma:
  11+ 8080              ; "memcopy_dma, hl = target address de = source address to copy, bc = length"
  12+ 8080              .set_target:
  13+ 8080 22 7A 80     	ld		(memcopy_bstrt),hl
  14+ 8083              .set_source:
  15+ 8083 ED 53 73 80  	ld		(memcopy_astrt),de
  16+ 8087              .set_length:
  17+ 8087 ED 43 75 80  	ld		(memcopy_length),bc
  18+ 808B              .write_dma:
  19+ 808B 21 6E 80     	ld 		hl, memcopy
  20+ 808E 06 12        	ld 		b, memcopy_cmd_len
  21+ 8090 0E 6B        	ld		c,IO_DATAGEAR_DMA_PORT
  22+ 8092 ED B3        	otir
  23+ 8094 C9           	ret
  24+ 8095
# file closed: ./Hardware/memcopy_dma.asm
 105  8095                  INCLUDE "./Hardware/keyboard.asm"
# file opened: ./Hardware/keyboard.asm
   1+ 8095              ;
   2+ 8095              ; $FEFE;65278 V, C, X, Z, Caps Shifts       4  3  2  1  0
   3+ 8095              ; $FDFE;65022 G, F, D, S, A                 9  8  7  6  5
   4+ 8095              ; $FBFE;64510 T, R, E, W, Q                14 13 12 11 10
   5+ 8095              ; $F7FE;63486 5, 4, 3, 2, 1                19 18 17 16 15
   6+ 8095              ; $EFFE;61438 6, 7, 8, 9, 0                24 23 22 23 20
   7+ 8095              ; $DFFE;57342 Y, U, I, O, P                29 28 27 26 25
   8+ 8095              ; $BFFE;49150 H, J, K, L, Enter            34 33 32 31 30
   9+ 8095              ; $7FFE;32766 B, N, M, Symbol Shift, Space 39 38 37 36 35
  10+ 8095              ;
  11+ 8095              ; Keyboard
  12+ 8095              ;
  13+ 8095              ;   0      1       2       3       4       5        6       7       8       9
  14+ 8095              ;  VK_CAPS, VK_Z,  VK_X,   VK_C,   VK_V,   VK_A,    VK_S,   VK_D,   VK_F,   VK_G
  15+ 8095              ;   10     11      12      13      14      15       16      17      18      19
  16+ 8095              ;  VK_Q,   VK_W,   VK_E,   VK_R,   VK_T,   VK_1,    VK_2,   VK_3,   VK_4,   VK_5
  17+ 8095              ;   20     21      22      23      24      25       26      27      28      29
  18+ 8095              ;  VK_0    VK_9,   VK_8,   VK_7,   VK_6,   VK_P ,    VK_O,  VK_I,   VK_U,   VK_Y
  19+ 8095              ;   30     31      32      33      34      35       36      37      38      39
  20+ 8095              ; VK_ENTER VK_L,   VK_K,   VK_J,   VK_H,   VK_SPACE VK_SYM, VK_M,   VK_N,   VK_B
  21+ 8095              ;
  22+ 8095              ; Default map
  23+ 8095              ;-----------------------------------------------------------------------------------------------------------------------------------
  24+ 8095              ;   0          1           2             3              4           5           6           7           8           9
  25+ 8095              ;   VK_CAPS    VK_Z        VK_X,         VK_C,          VK_V,       VK_A        VK_S,       VK_D,       VK_F,       VK_G
  26+ 8095              ;              GameSkip                  Equip          SelLCargo   Climb       Decelerate  Recentre    FireM       HomeCursor
  27+ 8095              ;                                                                                                       Find System
  28+ 8095              ;-----------------------------------------------------------------------------------------------------------------------------------
  29+ 8095              ;   10         11          12            13             14          15          16          17          18          19
  30+ 8095              ;   VK_Q       VK_W,       VK_E,         VK_R,          VK_T,       VK_1        VK_2        VK_3        VK_4        VK_5
  31+ 8095              ;   Dive       Accelerate  ECM           UnarmMissile   TargetM     FrontV      AftV        LeftV       RightV      GalacticChart
  32+ 8095              ;-----------------------------------------------------------------------------------------------------------------------------------
  33+ 8095              ;   20         Accel       22            23             24          25          26          27          28          29
  34+ 8095              ;   VK_0       VK_9,       VK_8,         VK_7,          VK_6,       VK_P ,      VK_O,       VK_I,       VK_U,       VK_Y
  35+ 8095              ;   EscapePod  Inventory   Status        MarketPrices   LocalChart  RollRight   RolLLeft                EnergyBomb  Quit
  36+ 8095              ;   PlanetData                                                      PauseGame   SaveGame
  37+ 8095              ;-----------------------------------------------------------------------------------------------------------------------------------
  38+ 8095              ;   30         31          32            33             34          Right       36          37          EnergyBomb  39
  39+ 8095              ;   VK_ENTER   VK_L,       VK_K,         VK_J,          VK_H,       VK_SPACE    VK_SYM,     VK_M,       VK_N,       VK_B
  40+ 8095              ;              Launch                    Distance       Hyperspace  Laser                               DockComp    BuyCargo
  41+ 8095              ;              ResumeGame
  42+ 8095
  43+ 8095              ; You can read address to check keystate by address KeyboardMap + c_Pressed corresponding key. There is also an addr_ helper too
  44+ 8095
  45+ 8095              c_Pressed_Front         equ 0  * 2
  46+ 8095              c_Pressed_Aft           equ 1  * 2
  47+ 8095              c_Pressed_Left          equ 2  * 2
  48+ 8095              c_Pressed_Right         equ 3  * 2
  49+ 8095              c_Pressed_RollLeft      equ 4  * 2
  50+ 8095              c_Pressed_RollRight     equ 5  * 2
  51+ 8095              c_Pressed_Dive          equ 6  * 2
  52+ 8095              c_Pressed_Climb         equ 7  * 2
  53+ 8095              c_Pressed_Accellerate   equ 8  * 2
  54+ 8095              c_Pressed_Decellerate   equ 9  * 2
  55+ 8095              c_Pressed_FireLaser     equ 10 * 2
  56+ 8095              c_Pressed_TargetMissle  equ 11 * 2
  57+ 8095              c_Pressed_FireMissile   equ 12 * 2
  58+ 8095              c_Pressed_UnarmMissile  equ 13 * 2
  59+ 8095              c_Pressed_ECM           equ 14 * 2
  60+ 8095              c_Pressed_EnergyBomb    equ 15 * 2
  61+ 8095              c_Pressed_EscapePod     equ 16 * 2
  62+ 8095              c_Pressed_DockingComp   equ 17 * 2
  63+ 8095              c_Pressed_Hyperspace    equ 18 * 2
  64+ 8095              c_Pressed_Distance      equ 19 * 2
  65+ 8095              c_Pressed_HomeCursor    equ 20 * 2
  66+ 8095              c_Pressed_Launch        equ 21 * 2
  67+ 8095              c_Pressed_BuyCargo      equ 22 * 2
  68+ 8095              c_Pressed_SellCargo     equ 23 * 2
  69+ 8095              c_Pressed_Equip         equ 24 * 2
  70+ 8095              c_Pressed_GalacticChrt  equ 25 * 2
  71+ 8095              c_Pressed_LocalChart    equ 26 * 2
  72+ 8095              c_Pressed_MarketPrices  equ 27 * 2
  73+ 8095              c_Pressed_Status        equ 28 * 2
  74+ 8095              c_Pressed_Inventory     equ 29 * 2
  75+ 8095              c_Pressed_GameSkip      equ 30 * 2
  76+ 8095              c_Pressed_Save          equ 31 * 2
  77+ 8095              c_Pressed_Freeze        equ 32 * 2
  78+ 8095              c_Pressed_Resume        equ 33 * 2
  79+ 8095              c_Pressed_Recentre      equ 34 * 2
  80+ 8095              c_Pressed_Quit          equ 35 * 2
  81+ 8095              c_Pressed_PlanetData    equ 36 * 2
  82+ 8095              c_Pressed_CursorUp      equ 37 * 2
  83+ 8095              c_Pressed_CursorDown    equ 38 * 2
  84+ 8095              c_Pressed_Find          equ 39 * 2
  85+ 8095              c_Pressed_Yes           equ 40 * 2
  86+ 8095              c_Pressed_No            equ 41 * 2
  87+ 8095
  88+ 8095
  89+ 8095              ; half row 1
  90+ 8095              VK_CAPS  				equ 0
  91+ 8095              VK_Z  					equ 1
  92+ 8095              VK_X  					equ 2
  93+ 8095              VK_C  					equ 3
  94+ 8095              VK_V  					equ 4
  95+ 8095              ; half row 2
  96+ 8095              VK_A  					equ 5
  97+ 8095              VK_S  					equ 6
  98+ 8095              VK_D  					equ 7
  99+ 8095              VK_F  					equ 8
 100+ 8095              VK_G  					equ 9
 101+ 8095              ; half row 3
 102+ 8095              VK_Q  					equ 10
 103+ 8095              VK_W  					equ 11
 104+ 8095              VK_E  					equ 12
 105+ 8095              VK_R  					equ 13
 106+ 8095              VK_T  					equ 14
 107+ 8095              ; half row 4
 108+ 8095              VK_1  					equ 15
 109+ 8095              VK_2  					equ 16
 110+ 8095              VK_3  					equ 17
 111+ 8095              VK_4  					equ 18
 112+ 8095              VK_5  					equ 19
 113+ 8095              ; half row 5
 114+ 8095              VK_0 					equ 20
 115+ 8095              VK_9 					equ 21
 116+ 8095              VK_8 					equ 22
 117+ 8095              VK_7 					equ 23
 118+ 8095              VK_6 					equ 24
 119+ 8095              ; half row 6
 120+ 8095              VK_P  					equ 25
 121+ 8095              VK_O  					equ 26
 122+ 8095              VK_I  					equ 27
 123+ 8095              VK_U  					equ 28
 124+ 8095              VK_Y  					equ 29
 125+ 8095              ; half row 7
 126+ 8095              VK_ENTER 				equ 30
 127+ 8095              VK_L  					equ 31
 128+ 8095              VK_K  					equ 32
 129+ 8095              VK_J  					equ 33
 130+ 8095              VK_H  					equ 34
 131+ 8095              ; half row 8
 132+ 8095              VK_SPACE 				equ 35
 133+ 8095              VK_SYM  				equ 36
 134+ 8095              VK_M  					equ 37
 135+ 8095              VK_N  					equ 38
 136+ 8095              VK_B  					equ 39
 137+ 8095
 138+ 8095              ;KeyboardMapping
 139+ 8095              KeyCode_Front        	equ VK_1
 140+ 8095              KeyCode_Aft          	equ VK_2
 141+ 8095              KeyCode_Left         	equ VK_3
 142+ 8095              KeyCode_Right        	equ VK_4
 143+ 8095              KeyCode_RollLeft     	equ VK_O
 144+ 8095              KeyCode_RollRight    	equ VK_P
 145+ 8095              KeyCode_Dive         	equ VK_Q
 146+ 8095              KeyCode_Climb        	equ VK_A
 147+ 8095              KeyCode_Accellerate  	equ VK_W
 148+ 8095              KeyCode_Decellerate  	equ VK_S
 149+ 8095              KeyCode_FireLaser    	equ VK_SPACE
 150+ 8095              KeyCode_TargetMissle 	equ VK_T
 151+ 8095              KeyCode_FireMissile  	equ VK_F
 152+ 8095              KeyCode_Find        	equ VK_F
 153+ 8095              KeyCode_UnarmMissile 	equ VK_R
 154+ 8095              KeyCode_ECM          	equ VK_E
 155+ 8095              KeyCode_EnergyBomb   	equ VK_U
 156+ 8095              KeyCode_EscapePod    	equ VK_CAPS
 157+ 8095              KeyCode_DockingComp  	equ VK_N
 158+ 8095              KeyCode_Hyperspace   	equ VK_H
 159+ 8095              KeyCode_Distance     	equ VK_J
 160+ 8095              KeyCode_HomeCursor   	equ VK_G
 161+ 8095              KeyCode_Launch       	equ VK_L
 162+ 8095              KeyCode_BuyCargo     	equ VK_B
 163+ 8095              KeyCode_SellCargo    	equ VK_V
 164+ 8095              KeyCode_Equip        	equ VK_C
 165+ 8095              KeyCode_GalacticChrt 	equ VK_5
 166+ 8095              KeyCode_LocalChart   	equ VK_6
 167+ 8095              KeyCode_MarketPrices 	equ VK_7
 168+ 8095              KeyCode_Status       	equ VK_8
 169+ 8095              KeyCode_Inventory    	equ VK_9
 170+ 8095              KeyCode_GameSkip     	equ VK_Z
 171+ 8095              KeyCode_Save         	equ VK_O
 172+ 8095              KeyCode_Freeze       	equ VK_B
 173+ 8095              KeyCode_Resume       	equ VK_L
 174+ 8095              KeyCode_Recentre     	equ VK_D
 175+ 8095              KeyCode_Quit         	equ VK_Y
 176+ 8095              KeyCode_PlanetData   	equ VK_0
 177+ 8095              KeyCode_CursorUp        equ VK_Q
 178+ 8095              KeyCode_CursorDown      equ VK_A
 179+ 8095              KeyCode_PressedYes      equ VK_Y
 180+ 8095              KeyCode_PressedNo       equ VK_N
 181+ 8095
 182+ 8095 00 00 00...  Keys					DS	40          ; This is the list of key states for all the VK keys presssed i.e. VK_CAPS through to VK_B
 183+ 80BD              c_KeyBoardLen 			equ $ - Keys
 184+ 80BD 00 00 00...  RawKeys					DS	8
 185+ 80C5 FE FD FB F7  KeyAddrTab				DB	$FE, $FD, $FB, $F7, $EF, $DF, $BF, $7F
 185+ 80C9 EF DF BF 7F
 186+ 80CD              ; Now keyboard map lists each game key and the corresponding address in the Keys table to get the value. This way redefining keys is just a case
 187+ 80CD              ; of updating this table with the respective location to look up
 188+ 80CD              ; key list sequence is in table above
 189+ 80CD A4 80 A5 80  KeyboardMap             DW  Keys+KeyCode_Front        ,Keys+KeyCode_Aft          ,Keys+KeyCode_Left         ,Keys+KeyCode_Right        ,Keys+KeyCode_RollLeft
 189+ 80D1 A6 80 A7 80
 189+ 80D5 AF 80
 190+ 80D7 AE 80 9F 80                          DW  Keys+KeyCode_RollRight    ,Keys+KeyCode_Dive         ,Keys+KeyCode_Climb        ,Keys+KeyCode_Accellerate  ,Keys+KeyCode_Decellerate
 190+ 80DB 9A 80 A0 80
 190+ 80DF 9B 80
 191+ 80E1 B8 80 A3 80                          DW  Keys+KeyCode_FireLaser    ,Keys+KeyCode_TargetMissle ,Keys+KeyCode_FireMissile  ,Keys+KeyCode_UnarmMissile ,Keys+KeyCode_ECM
 191+ 80E5 9D 80 A2 80
 191+ 80E9 A1 80
 192+ 80EB B1 80 95 80                          DW  Keys+KeyCode_EnergyBomb   ,Keys+KeyCode_EscapePod    ,Keys+KeyCode_DockingComp  ,Keys+KeyCode_Hyperspace   ,Keys+KeyCode_Distance
 192+ 80EF BB 80 B7 80
 192+ 80F3 B6 80
 193+ 80F5 9E 80 B4 80                          DW  Keys+KeyCode_HomeCursor   ,Keys+KeyCode_Launch       ,Keys+KeyCode_BuyCargo     ,Keys+KeyCode_SellCargo    ,Keys+KeyCode_Equip
 193+ 80F9 BC 80 99 80
 193+ 80FD 98 80
 194+ 80FF A8 80 AD 80                          DW  Keys+KeyCode_GalacticChrt ,Keys+KeyCode_LocalChart   ,Keys+KeyCode_MarketPrices ,Keys+KeyCode_Status       ,Keys+KeyCode_Inventory
 194+ 8103 AC 80 AB 80
 194+ 8107 AA 80
 195+ 8109 96 80 AF 80                          DW  Keys+KeyCode_GameSkip     ,Keys+KeyCode_Save         ,Keys+KeyCode_Freeze       ,Keys+KeyCode_Resume       ,Keys+KeyCode_Recentre
 195+ 810D BC 80 B4 80
 195+ 8111 9C 80
 196+ 8113 B2 80 A9 80                          DW  Keys+KeyCode_Quit         ,Keys+KeyCode_PlanetData   ,Keys+KeyCode_CursorUp     ,Keys+KeyCode_CursorDown   ,Keys+KeyCode_Find
 196+ 8117 9F 80 9A 80
 196+ 811B 9D 80
 197+ 811D B2 80 BB 80                          DW  Keys+KeyCode_PressedYes   ,Keys+KeyCode_PressedNo
 198+ 8121
 199+ 8121 23 5A 58 43  ASCII_Map:              DB "#","Z","X","C","V"
 199+ 8125 56
 200+ 8126 41 53 44 46                          DB "A","S","D","F","G"
 200+ 812A 47
 201+ 812B 51 57 45 52                          DB "Q","W","E","R","T"
 201+ 812F 54
 202+ 8130 31 32 33 34                          DB "1","2","3","4","5"
 202+ 8134 35
 203+ 8135 30 39 38 37                          DB "0","9","8","7","6"
 203+ 8139 36
 204+ 813A 50 4F 49 55                          DB "P","O","I","U","Y"
 204+ 813E 59
 205+ 813F 3E 4C 4B 4A                          DB ">","L","K","J","H"
 205+ 8143 48
 206+ 8144 20 5E 4D 4E                          DB " ","^","M","N","B"
 206+ 8148 42
 207+ 8149
 208+ 8149              ; mapping of a code to the lookup table Keyboard map. So if you are using an addr_Pressed you can then fetch from KeyboardMap the address in Keys
 209+ 8149              ; for the raw key press status
 210+ 8149              addr_Pressed_Front         equ KeyboardMap+c_Pressed_Front
 211+ 8149              addr_Pressed_Aft           equ KeyboardMap+c_Pressed_Aft
 212+ 8149              addr_Pressed_Left          equ KeyboardMap+c_Pressed_Left
 213+ 8149              addr_Pressed_Right         equ KeyboardMap+c_Pressed_Right
 214+ 8149              addr_Pressed_RollLeft      equ KeyboardMap+c_Pressed_RollLeft
 215+ 8149              addr_Pressed_RollRight     equ KeyboardMap+c_Pressed_RollRight
 216+ 8149              addr_Pressed_Dive          equ KeyboardMap+c_Pressed_Dive
 217+ 8149              addr_Pressed_Climb         equ KeyboardMap+c_Pressed_Climb
 218+ 8149              addr_Pressed_Accellerate   equ KeyboardMap+c_Pressed_Accellerate
 219+ 8149              addr_Pressed_Decellerate   equ KeyboardMap+c_Pressed_Decellerate
 220+ 8149              addr_Pressed_FireLaser     equ KeyboardMap+c_Pressed_FireLaser
 221+ 8149              addr_Pressed_TargetMissle  equ KeyboardMap+c_Pressed_TargetMissle
 222+ 8149              addr_Pressed_FireMissile   equ KeyboardMap+c_Pressed_FireMissile
 223+ 8149              addr_Pressed_UnarmMissile  equ KeyboardMap+c_Pressed_UnarmMissile
 224+ 8149              addr_Pressed_ECM           equ KeyboardMap+c_Pressed_ECM
 225+ 8149              addr_Pressed_EnergyBomb    equ KeyboardMap+c_Pressed_EnergyBomb
 226+ 8149              addr_Pressed_EscapePod     equ KeyboardMap+c_Pressed_EscapePod
 227+ 8149              addr_Pressed_DockingComp   equ KeyboardMap+c_Pressed_DockingComp
 228+ 8149              addr_Pressed_Hyperspace    equ KeyboardMap+c_Pressed_Hyperspace
 229+ 8149              addr_Pressed_Distance      equ KeyboardMap+c_Pressed_Distance
 230+ 8149              addr_Pressed_HomeCursor    equ KeyboardMap+c_Pressed_HomeCursor
 231+ 8149              addr_Pressed_Launch        equ KeyboardMap+c_Pressed_Launch
 232+ 8149              addr_Pressed_BuyCargo      equ KeyboardMap+c_Pressed_BuyCargo
 233+ 8149              addr_Pressed_SellCargo     equ KeyboardMap+c_Pressed_SellCargo
 234+ 8149              addr_Pressed_Equip         equ KeyboardMap+c_Pressed_Equip
 235+ 8149              addr_Pressed_GalacticChrt  equ KeyboardMap+c_Pressed_GalacticChrt
 236+ 8149              addr_Pressed_LocalChart    equ KeyboardMap+c_Pressed_LocalChart
 237+ 8149              addr_Pressed_MarketPrices  equ KeyboardMap+c_Pressed_MarketPrices
 238+ 8149              addr_Pressed_Status        equ KeyboardMap+c_Pressed_Status
 239+ 8149              addr_Pressed_Inventory     equ KeyboardMap+c_Pressed_Inventory
 240+ 8149              addr_Pressed_GameSkip      equ KeyboardMap+c_Pressed_GameSkip
 241+ 8149              addr_Pressed_Save          equ KeyboardMap+c_Pressed_Save
 242+ 8149              addr_Pressed_Freeze        equ KeyboardMap+c_Pressed_Freeze
 243+ 8149              addr_Pressed_Resume        equ KeyboardMap+c_Pressed_Resume
 244+ 8149              addr_Pressed_Recentre      equ KeyboardMap+c_Pressed_Recentre
 245+ 8149              addr_Pressed_Quit          equ KeyboardMap+c_Pressed_Quit
 246+ 8149              addr_Pressed_PlanetData    equ KeyboardMap+c_Pressed_PlanetData
 247+ 8149              addr_Pressed_CursorUp      equ KeyboardMap+c_Pressed_CursorUp
 248+ 8149              addr_Pressed_CursorDown    equ KeyboardMap+c_Pressed_CursorDown
 249+ 8149              addr_Pressed_Find          equ KeyboardMap+c_Pressed_Find
 250+ 8149
 251+ 8149
 252+ 8149              MIsKeyPressed:          MACRO   keyaddress, misstarget
 253+ 8149 ~                                    ld      hl,(keyaddress)
 254+ 8149 ~                                    ld      a,(hl)
 255+ 8149 ~                                    JumpIfAIsZero   misstarget
 256+ 8149                                      ENDM
 257+ 8149
 258+ 8149 21 95 80     init_keyboard:          ld		hl,Keys                         ; no key s are pressed by default
 259+ 814C 11 28 00                             ld		de, c_KeyBoardLen               ;
 260+ 814F 3E 00                                ld		a,0                             ;
 261+ 8151 CD 5A 80                             call	memfill_dma                     ;
 262+ 8154 C9                                   ret                                     ;
 263+ 8155
 264+ 8155
 265+ 8155
 266+ 8155 DD 21 BD 80  scan_keyboard:          ld		ix,RawKeys                      ; hl = table of raw IO port readings
 267+ 8159 21 C5 80                             ld		hl,KeyAddrTab                   ; de = table of IO ports to read
 268+ 815C 0E 08                                ld		c,8                             ; 8 ports to ready
 269+ 815E 11 95 80                             ld      de,Keys                         ; ix = table of key states from raw read
 270+ 8161 7E           .PortReadLoop:          ld		a,(hl)							; Set up port to read as (hl)$FE
 271+ 8162 DB FE                                in		a,($FE)							; read port to a
 272+ 8164 DD 77 00                             ld      (ix+0),a                        ; save raw scan
 273+ 8167 DD 23                                inc     ix
 274+ 8169 23                                   inc		hl                              ; and ready for next read
 275+ 816A 06 05        .ProcessInputBits:      ld		b,5								; loop all bits (there are only 5 keys to a group)
 276+ 816C 1F           .ProcessBitsLoop:       rra                                     ; shit bit 0 into carry
 277+ 816D CB 47                                bit		0,a								; is bit set
 278+ 816F 30 08                                jr      nc,.SetKeyPressed               ; low bit means it was pressed
 279+ 8171 FD 6F                                ld      iyl,a
 280+ 8173                                      ZeroA
 280+ 8173 AF          >                        xor a
 281+ 8174 C3 81 81                             jp      .SetKey
 282+ 8177 20 0B                                jr		nz,.SkipKeySet
 283+ 8179 FD 6F        .SetKeyPressed:	        ld      iyl,a                           ; save current input byte
 284+ 817B 1A                                   ld      a,(de)                          ; get current keystate
 285+ 817C FE 02                                cp      2
 286+ 817E 28 02                                jr      z,.AlreadyHeld
 287+ 8180 3C                                   inc     a                               ; and increment by 1 as its moved from previous state
 288+ 8181 12           .SetKey:                ld		(de),a				  	        ; save key Pressed state
 289+ 8182 FD 7D        .AlreadyHeld:           ld      a,iyl                           ; and retrieve the current input byte
 290+ 8184 13           .SkipKeySet:	        inc		de								; move to next key
 291+ 8185 10 E5                                djnz	.ProcessBitsLoop				; Process all key group bits
 292+ 8187 0D                                   dec     c                               ; thats one row of bits all processed
 293+ 8188 20 D7                                jr      nz,.PortReadLoop				; Read next input port
 294+ 818A C9                                   ret
 295+ 818B
 296+ 818B
 297+ 818B
 298+ 818B              GetKeyStateAddressDE:   MACRO
 299+ 818B ~                                    ld      hl,KeyboardMap                  ; work our address to read from
 300+ 818B ~                                    add     hl,a
 301+ 818B ~                                    ld      e,(hl)
 302+ 818B ~                                    inc     hl
 303+ 818B ~                                    ld      d,(hl)                          ; now de = address in keypress list
 304+ 818B                                      ENDM
 305+ 818B
 306+ 818B              GetKeyStateAddressHL:   MACRO
 307+ 818B ~                                    ld      hl,KeyboardMap                  ; work our address to read from
 308+ 818B ~                                    add     hl,a
 309+ 818B ~                                    ld      a,(hl)
 310+ 818B ~                                    inc     hl
 311+ 818B ~                                    ld      h,(hl)                          ; now hl = address in keypress list
 312+ 818B ~                                    ld      l,a
 313+ 818B                                      ENDM
 314+ 818B
 315+ 818B
 316+ 818B              ;;old debug codeCurrentX            DB 0
 317+ 818B              ;;old debug codeCurrentY            DB 0
 318+ 818B              ;;old debug code
 319+ 818B              ;;old debug codedisplayKeyStatus:       xor         a
 320+ 818B              ;;old debug code                        ld          (CurrentX),a
 321+ 818B              ;;old debug code                        ld          hl,RawKeys
 322+ 818B              ;;old debug code                        ld          a,(hl)
 323+ 818B              ;;old debug code                        and         %00011111
 324+ 818B              ;;old debug code                        ld          b,5
 325+ 818B              ;;old debug code.displayLoop:           push        bc,,hl
 326+ 818B              ;;old debug code                        rra
 327+ 818B              ;;old debug code                        jr          c,.displayNoPress
 328+ 818B              ;;old debug code.displayPress:          push        af
 329+ 818B              ;;old debug code                        ld          a,(CurrentX)
 330+ 818B              ;;old debug code                        ld          e,a
 331+ 818B              ;;old debug code                        ld          a,(CurrentY)
 332+ 818B              ;;old debug code                        ld          d,a
 333+ 818B              ;;old debug code                        ld          a,'*'
 334+ 818B              ;;old debug code                        MMUSelectLayer1
 335+ 818B              ;;old debug code                        call        l1_print_char
 336+ 818B              ;;old debug code                        ld          a,(CurrentX)
 337+ 818B              ;;old debug code                        add         a,8
 338+ 818B              ;;old debug code                        ld          (CurrentX),a
 339+ 818B              ;;old debug code                        pop         af
 340+ 818B              ;;old debug code                        pop         bc,,hl
 341+ 818B              ;;old debug code                        djnz        .displayLoop
 342+ 818B              ;;old debug code                        ret
 343+ 818B              ;;old debug code.displayNoPress:        push        af
 344+ 818B              ;;old debug code                        ld          a,(CurrentX)
 345+ 818B              ;;old debug code                        ld          e,a
 346+ 818B              ;;old debug code                        ld          a,(CurrentY)
 347+ 818B              ;;old debug code                        ld          d,a
 348+ 818B              ;;old debug code                        ld          a,'O'
 349+ 818B              ;;old debug code                        MMUSelectLayer1
 350+ 818B              ;;old debug code                        call        l1_print_char
 351+ 818B              ;;old debug code                        ld          a,(CurrentX)
 352+ 818B              ;;old debug code                        add         a,8
 353+ 818B              ;;old debug code                        ld          (CurrentX),a
 354+ 818B              ;;old debug code                        pop         af
 355+ 818B              ;;old debug code                        pop         bc,,hl
 356+ 818B              ;;old debug code                        djnz        .displayLoop
 357+ 818B              ;;old debug code                        ret
 358+ 818B              ;;old debug code
 359+ 818B              ;;old debug codedisplayDownStatus:      ld  a,(Keys+      KeyCode_CursorUp)
 360+ 818B              ;;old debug code                        cp  0
 361+ 818B              ;;old debug code                        jr      z,.displayNoUp
 362+ 818B              ;;old debug code                        cp  1
 363+ 818B              ;;old debug code                        jr      z,.displayUp
 364+ 818B              ;;old debug code.displayHeld:           ld      de,8*15
 365+ 818B              ;;old debug code                        ld      a,"*"
 366+ 818B              ;;old debug code                        MMUSelectLayer1
 367+ 818B              ;;old debug code                        call        l1_print_char
 368+ 818B              ;;old debug code                        ret
 369+ 818B              ;;old debug code.displayUp:             ld      de,8*15
 370+ 818B              ;;old debug code                        ld      a,"+"
 371+ 818B              ;;old debug code                        MMUSelectLayer1
 372+ 818B              ;;old debug code                        call        l1_print_char
 373+ 818B              ;;old debug code                        ret
 374+ 818B              ;;old debug code.displayNoUp:             ld      de,8*15
 375+ 818B              ;;old debug code                        ld      a,"O"
 376+ 818B              ;;old debug code                        MMUSelectLayer1
 377+ 818B              ;;old debug code                        call        l1_print_char
 378+ 818B              ;;old debug code                        ret
 379+ 818B              ;;old debug code
 380+ 818B
 381+ 818B
 382+ 818B              ; call with a = c_Pressed key, will then read mapping does this with keyboard scan, waits until key gets to state 1, if it was already held then#
 383+ 818B              ; it will have to be let go to reset of 0 and scan again
 384+ 818B              ; Deprecated as not used as yet
 385+ 818B              ;;;;;;wait_for_key_a_press:   GetKeyStateAddressHL
 386+ 818B              ;;;;;;                        push    hl
 387+ 818B              ;;;;;;.wait_loop:             call    scan_keyboard
 388+ 818B              ;;;;;;                        pop     hl                              ; get key address into hl
 389+ 818B              ;;;;;;                        push    hl
 390+ 818B              ;;;;;;                        ld      a,(hl)
 391+ 818B              ;;;;;;                        JumpIfANENusng  1,.wait_loop             ; will also loop if held down when entering this routine
 392+ 818B              ;;;;;;                        pop     hl                              ; tidy up rogue push, less t states than detecting if we want to push or not
 393+ 818B              ;;;;;;                        ret
 394+ 818B              ;;;;;;; call with a = c_Pressed key, will then read mapping does this with keyboard scan waits until key gets to state 2
 395+ 818B              ;;;;;;wait_for_key_a_held:    GetKeyStateAddressDE
 396+ 818B              ;;;;;;                        push    hl
 397+ 818B              ;;;;;;.wait_loop:             call    scan_keyboard
 398+ 818B              ;;;;;;                        pop     hl
 399+ 818B              ;;;;;;                        push    hl
 400+ 818B              ;;;;;;                        ld      a,(hl)
 401+ 818B              ;;;;;;                        JumpIfALTNusng  2, .wait_loop
 402+ 818B              ;;;;;;                        pop     hl
 403+ 818B              ;;;;;;                        ret
 404+ 818B
 405+ 818B              ; Gets the current keystate of the c_Pressed Key in a register
 406+ 818B              get_key_a_state:        GetKeyStateAddressHL                    ; reads a mapped key and sets a to key staus, e.g. 0 1 or >=2 DOES NOT SCAN KEYBOARD
 406+ 818B 21 CD 80    >                        ld      hl,KeyboardMap                  ; work our address to read from
 406+ 818E ED 31       >                        add     hl,a
 406+ 8190 7E          >                        ld      a,(hl)
 406+ 8191 23          >                        inc     hl
 406+ 8192 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 406+ 8193 6F          >                        ld      l,a
 407+ 8194 7E                                   ld      a,(hl)                          ; a = keystate
 408+ 8195 C9                                   ret
 409+ 8196
 410+ 8196              ; sets they keystate of c pressed key in a register to 1 (pressed)
 411+ 8196              force_key_press:        GetKeyStateAddressHL                    ; read key locations
 411+ 8196 21 CD 80    >                        ld      hl,KeyboardMap                  ; work our address to read from
 411+ 8199 ED 31       >                        add     hl,a
 411+ 819B 7E          >                        ld      a,(hl)
 411+ 819C 23          >                        inc     hl
 411+ 819D 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 411+ 819E 6F          >                        ld      l,a
 412+ 819F 3E 01                                ld      a,1
 413+ 81A1 77                                   ld      (hl),a
 414+ 81A2 C9                                   ret
 415+ 81A3
 416+ 81A3              is_key_up_state:        GetKeyStateAddressHL
 416+ 81A3 21 CD 80    >                        ld      hl,KeyboardMap                  ; work our address to read from
 416+ 81A6 ED 31       >                        add     hl,a
 416+ 81A8 7E          >                        ld      a,(hl)
 416+ 81A9 23          >                        inc     hl
 416+ 81AA 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 416+ 81AB 6F          >                        ld      l,a
 417+ 81AC 7E                                   ld      a,(hl)
 418+ 81AD FE 00                                cp      0
 419+ 81AF C9                                   ret
 420+ 81B0
 421+ 81B0              ; returns z is set if c_ key is pressed
 422+ 81B0              is_key_pressed:         GetKeyStateAddressHL
 422+ 81B0 21 CD 80    >                        ld      hl,KeyboardMap                  ; work our address to read from
 422+ 81B3 ED 31       >                        add     hl,a
 422+ 81B5 7E          >                        ld      a,(hl)
 422+ 81B6 23          >                        inc     hl
 422+ 81B7 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 422+ 81B8 6F          >                        ld      l,a
 423+ 81B9 7E                                   ld      a,(hl)                          ; a = keystate
 424+ 81BA FE 01                                cp      1                               ; we cant just test bit 0 as this may have been held long
 425+ 81BC C9                                   ret
 426+ 81BD
 427+ 81BD              ; returns nz is set if c_ key is held, if key was held then keystate would be 2 or 3, i.e. bit 1 set
 428+ 81BD              is_key_held:            GetKeyStateAddressHL
 428+ 81BD 21 CD 80    >                        ld      hl,KeyboardMap                  ; work our address to read from
 428+ 81C0 ED 31       >                        add     hl,a
 428+ 81C2 7E          >                        ld      a,(hl)
 428+ 81C3 23          >                        inc     hl
 428+ 81C4 66          >                        ld      h,(hl)                          ; now hl = address in keypress list
 428+ 81C5 6F          >                        ld      l,a
 429+ 81C6 7E                                   ld      a,(hl)                          ; a = keystate
 430+ 81C7 E6 02                                and     Bit1Only                        ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
 431+ 81C9 C9                                   ret
 432+ 81CA
 433+ 81CA              ; checks to see if any key is pressed in the key table
 434+ 81CA 21 95 80     is_any_key_pressed:     ld      hl,Keys
 435+ 81CD 01 28 00                             ld      bc,40
 436+ 81D0 3E 01                                ld      a,1
 437+ 81D2 ED B1                                cpir                                    ; search for the value 1
 438+ 81D4 28 03                                jr      z,.KeyPressed                   ; if a key was pressed then handle press
 439+ 81D6                                      SetAFalse
 439+ 81D6 3E FF       >                        ld      a,$FF
 440+ 81D8 C9                                   ret
 441+ 81D9 3E 27        .KeyPressed:            ld      a,39                            ; so c will be how many keys still to scan
 442+ 81DB 91                                   sub     c                               ; so a = 40 - c to get to result
 443+ 81DC C9                                   ret
 444+ 81DD
 445+ 81DD 21 95 80     is_any_key_held:        ld      hl,Keys
 446+ 81E0 06 28                                ld      b,40
 447+ 81E2 0E 00                                ld      c,0
 448+ 81E4 7E           .KeyReadLoop:           ld      a,(hl)
 449+ 81E5 E6 02                                and     Bit1Only                        ; clear out bit 1 which elimiates state 3, so it can now be 2 (held) or 0 (not pressed or one off)
 450+ 81E7 C2 F1 81                             jp      nz,.KeyPressed
 451+ 81EA 23                                   inc     hl
 452+ 81EB 0C                                   inc     c
 453+ 81EC 10 F6                                djnz    .KeyReadLoop
 454+ 81EE                                      SetAFalse
 454+ 81EE 3E FF       >                        ld      a,$FF
 455+ 81F0 C9                                   ret
 456+ 81F1 79           .KeyPressed:            ld      a,c
 457+ 81F2 C9                                   ret
 458+ 81F3
 459+ 81F3
 460+ 81F3 00 00 00...  InputString             DS  30              ; used for a 30 character input buffer
 461+ 8211 00                                   DB  0               ; end of string marker as a safety
 462+ 8212 00           InputCursor             DB  0
 463+ 8213 00           EnterPressed            DB  0               ; zero notpressed FF pressed
 464+ 8214 00           InputChanged            DB  0
 465+ 8215              InputLimit              EQU 20
 466+ 8215
 467+ 8215 21 F3 81     keyboard_copy_input_to_de:  ld      hl,InputString
 468+ 8218 3A 12 82                                 ld      a,(InputCursor)
 469+ 821B FE 00                                    cp      0
 470+ 821D 28 05                                    jr      z,.NoString
 471+ 821F 4F                                       ld      c,a
 472+ 8220 06 00                                    ld      b,0
 473+ 8222 ED B0                                    ldir
 474+ 8224 3E 00        .NoString                   ld      a,0
 475+ 8226 12                                       ld      (de),a
 476+ 8227 C9                                       ret
 477+ 8228
 478+ 8228 AF           initInputText:          xor     a
 479+ 8229 32 12 82                             ld      (InputCursor),a
 480+ 822C                                      SetMemFalse EnterPressed
 480+ 822C 3E FF       >                        ld      a,$FF
 480+ 822E 32 13 82    >                        ld      (EnterPressed),a
 481+ 8231                                      SetMemFalse InputChanged
 481+ 8231 3E FF       >                        ld      a,$FF
 481+ 8233 32 14 82    >                        ld      (InputChanged),a
 482+ 8236 21 F3 81                             ld      hl,InputString
 483+ 8239 06 1E                                ld      b,30
 484+ 823B 77           .wipeloop:              ld      (hl),a
 485+ 823C 23                                   inc     hl
 486+ 823D 10 FC                                djnz    .wipeloop
 487+ 823F C9                                   ret
 488+ 8240
 489+ 8240              InputName:              SetMemFalse InputChanged
 489+ 8240 3E FF       >                        ld      a,$FF
 489+ 8242 32 14 82    >                        ld      (InputChanged),a
 490+ 8245 CD CA 81                             call    is_any_key_pressed
 491+ 8248 FE FF                                cp      $FF
 492+ 824A C8                                   ret     z
 493+ 824B 4F           .KeyPressed:            ld      c,a
 494+ 824C 3A 12 82                             ld      a,(InputCursor)                 ; No key so we can now look at if we are at the end of the buffer
 495+ 824F FE 14                                cp      InputLimit                      ; move to variable later and then cp (hl)
 496+ 8251 28 0B                                jr      z,.DeleteOrEnterOnly            ;
 497+ 8253 21 21 81                             ld      hl,ASCII_Map
 498+ 8256 79                                   ld      a,c
 499+ 8257 ED 31                                add     hl,a
 500+ 8259 7E                                   ld      a,(hl)
 501+ 825A FE 41                                cp      "A"
 502+ 825C 30 0B                                jr      nc,.AlphaPressed
 503+ 825E              ; CAPS and Symbol act as delete for now
 504+ 825E FE 20        .DeleteOrEnterOnly      cp      " "                             ; if space was  pressed (mapped to Hash in ASCII table))
 505+ 8260 28 33                                jr      z,.SpacePressed               ; for now we will ignore the shift and just assume delete
 506+ 8262 FE 3E                                cp      ">"         ; ENTER
 507+ 8264 28 19                                jr      z,.EnterPressed
 508+ 8266 FE 23                                cp      "#"         ; CAPS
 509+ 8268 C9                                   ret
 510+ 8269 47           .AlphaPressed:          ld      b,a
 511+ 826A 3A 12 82                             ld      a,(InputCursor)
 512+ 826D 4F                                   ld      c,a
 513+ 826E 21 F3 81                             ld      hl,InputString
 514+ 8271 ED 31                                add     hl,a
 515+ 8273 78                                   ld      a,b
 516+ 8274 70                                   ld      (hl),b
 517+ 8275 79                                   ld      a,c
 518+ 8276 21 12 82                             ld      hl,InputCursor
 519+ 8279 34                                   inc     (hl)
 520+ 827A                                      SetMemTrue InputChanged
 520+ 827A AF          >                        xor     a
 520+ 827B 32 14 82    >                        ld      (InputChanged),a
 521+ 827E C9                                   ret
 522+ 827F 3A 12 82     .EnterPressed:          ld      a,(InputCursor)
 523+ 8282 21 F3 81                             ld      hl,InputString
 524+ 8285 ED 31                                add     hl,a
 525+ 8287                                      ZeroA
 525+ 8287 AF          >                        xor a
 526+ 8288 77                                   ld      (hl),a
 527+ 8289                                      SetMemTrue EnterPressed
 527+ 8289 AF          >                        xor     a
 527+ 828A 32 13 82    >                        ld      (EnterPressed),a
 528+ 828D                                      SetMemTrue InputChanged
 528+ 828D AF          >                        xor     a
 528+ 828E 32 14 82    >                        ld      (InputChanged),a
 529+ 8291 CD 49 81                             call    init_keyboard           ; Flush keyboard status so futher inputs don't auto read the enter key as a second press
 530+ 8294 C9                                   ret
 531+ 8295 3A 12 82     .SpacePressed:          ld      a,(InputCursor)         ; Space = delete
 532+ 8298 FE 00                                cp      0                       ; if input is zero length then can not delete
 533+ 829A C8                                   ret     z
 534+ 829B 3D                                   dec     a                       ; move back one and update cursor pos
 535+ 829C 32 12 82                             ld      (InputCursor),a         ;
 536+ 829F 21 F3 81                             ld      hl,InputString          ; now update end of line to null
 537+ 82A2 ED 31                                add     hl,a                    ; .
 538+ 82A4                                      ZeroA                           ; .
 538+ 82A4 AF          >                        xor a
 539+ 82A5 77                                   ld      (hl),a                  ; .
 540+ 82A6                                      SetMemTrue InputChanged
 540+ 82A6 AF          >                        xor     a
 540+ 82A7 32 14 82    >                        ld      (InputChanged),a
 541+ 82AA C9                                   ret
 542+ 82AB
 543+ 82AB AF           MovementKeyTest:        xor     a
 544+ 82AC 32 47 85                             ld      (CursorKeysPressed),a
 545+ 82AF 3A 66 84                             ld      a,(MenuIdMax)
 546+ 82B2 E6 FC                                and     $FC
 547+ 82B4 20 26                                jr      nz,CursorKeys
 548+ 82B6 2A DB 80     ClimbDiveKeys:          ld      hl,(addr_Pressed_Climb)
 549+ 82B9 7E                                   ld      a,(hl)
 550+ 82BA                                      JumpIfAIsZero ScanDiveKey
 550+ 82BA A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 550+ 82BB CA C9 82    >                        jp	z, ScanDiveKey
 551+ 82BE 3A 47 85                             ld      a,(CursorKeysPressed)
 552+ 82C1 F6 80                                or      $80
 553+ 82C3 32 47 85                             ld      (CursorKeysPressed),a
 554+ 82C6 C3 FF 82                             jp      ScanLeftKey
 555+ 82C9 2A D9 80     ScanDiveKey:            ld      hl,(addr_Pressed_Dive)
 556+ 82CC 7E                                   ld      a,(hl)
 557+ 82CD                                      JumpIfAIsZero ScanLeftKey
 557+ 82CD A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 557+ 82CE CA FF 82    >                        jp	z, ScanLeftKey
 558+ 82D1 3A 47 85                             ld      a,(CursorKeysPressed)
 559+ 82D4 F6 40                                or      $40
 560+ 82D6 32 47 85                             ld      (CursorKeysPressed),a
 561+ 82D9 C3 FF 82                             jp      ScanLeftKey
 562+ 82DC 2A 17 81     CursorKeys:             ld      hl,(addr_Pressed_CursorUp)
 563+ 82DF 7E                                   ld      a,(hl)
 564+ 82E0                                      JumpIfAIsZero ScanCursorDownKey
 564+ 82E0 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 564+ 82E1 CA EF 82    >                        jp	z, ScanCursorDownKey
 565+ 82E4 3A 47 85                             ld      a,(CursorKeysPressed)
 566+ 82E7 F6 80                                or      $80
 567+ 82E9 32 47 85                             ld      (CursorKeysPressed),a
 568+ 82EC C3 FF 82                             jp      ScanLeftKey
 569+ 82EF 2A 19 81     ScanCursorDownKey:      ld      hl,(addr_Pressed_CursorDown)
 570+ 82F2 7E                                   ld      a,(hl)
 571+ 82F3                                      JumpIfAIsZero ScanLeftKey
 571+ 82F3 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 571+ 82F4 CA FF 82    >                        jp	z, ScanLeftKey
 572+ 82F7 3A 47 85                             ld      a,(CursorKeysPressed)
 573+ 82FA F6 40                                or      $40
 574+ 82FC 32 47 85                             ld      (CursorKeysPressed),a
 575+ 82FF 2A D5 80     ScanLeftKey:            ld      hl,(addr_Pressed_RollLeft)
 576+ 8302 7E                                   ld      a,(hl)
 577+ 8303                                      JumpIfAIsZero ScanRightKey
 577+ 8303 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 577+ 8304 CA 10 83    >                        jp	z, ScanRightKey
 578+ 8307 3A 47 85                             ld      a,(CursorKeysPressed)
 579+ 830A F6 20                                or      $20
 580+ 830C 32 47 85                             ld      (CursorKeysPressed),a
 581+ 830F C9                                   ret
 582+ 8310 2A D7 80     ScanRightKey:           ld      hl,(addr_Pressed_RollRight)
 583+ 8313 7E                                   ld      a,(hl)
 584+ 8314                                      JumpIfAIsZero ScanHomeKey
 584+ 8314 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 584+ 8315 CA 21 83    >                        jp	z, ScanHomeKey
 585+ 8318 3A 47 85                             ld      a,(CursorKeysPressed)
 586+ 831B F6 10                                or      $10
 587+ 831D 32 47 85                             ld      (CursorKeysPressed),a
 588+ 8320 C9                                   ret
 589+ 8321 2A F5 80     ScanHomeKey:            ld      hl,(addr_Pressed_HomeCursor)
 590+ 8324 7E                                   ld      a,(hl)
 591+ 8325                                      JumpIfAIsZero ScanRecentreKey
 591+ 8325 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 591+ 8326 CA 32 83    >                        jp	z, ScanRecentreKey
 592+ 8329 3A 47 85                             ld      a,(CursorKeysPressed)
 593+ 832C F6 08                                or      $08
 594+ 832E 32 47 85                             ld      (CursorKeysPressed),a
 595+ 8331 C9                                   ret
 596+ 8332 2A 11 81     ScanRecentreKey:        ld      hl,(addr_Pressed_Recentre)
 597+ 8335 7E                                   ld      a,(hl)
 598+ 8336                                      ReturnIfAIsZero
 598+ 8336 A7          >                        and     a
 598+ 8337 C8          >                        ret     z
 599+ 8338 3A 47 85                             ld      a,(CursorKeysPressed)
 600+ 833B F6 04                                or      $04
 601+ 833D 32 47 85                             ld      (CursorKeysPressed),a
 602+ 8340 C9                                   ret
 603+ 8341
 604+ 8341
# file closed: ./Hardware/keyboard.asm
 106  8341                  INCLUDE "./Data/EquipmentEquates.asm"
# file opened: ./Data/EquipmentEquates.asm
   1+ 8341
   2+ 8341              EQ_FUEL                 EQU 0
   3+ 8341              EQ_MISSILE              EQU 1
   4+ 8341              EQ_CARGO_BAY            EQU 2
   5+ 8341              EQ_ECM                  EQU 3
   6+ 8341              EQ_FUEL_SCOOPS          EQU 4
   7+ 8341              EQ_ESCAPE_POD           EQU 5
   8+ 8341              EQ_ENERGY_BOMB          EQU 6
   9+ 8341              EQ_ENERGY_UNIT          EQU 7
  10+ 8341              EQ_DOCK_COMP            EQU 8
  11+ 8341              EQ_GAL_DRIVE            EQU 9
  12+ 8341              EQ_FRONT_PULSE          EQU 10
  13+ 8341              EQ_REAR_PULSE           EQU 11
  14+ 8341              EQ_LEFT_PULSE           EQU 12
  15+ 8341              EQ_RIGHT_PULSE          EQU 13
  16+ 8341              EQ_FRONT_BEAM           EQU 14
  17+ 8341              EQ_REAR_BEAM            EQU 15
  18+ 8341              EQ_LEFT_BEAM            EQU 16
  19+ 8341              EQ_RIGHT_BEAM           EQU 17
  20+ 8341              EQ_FRONT_MINING         EQU 18
  21+ 8341              EQ_REAR_MINING          EQU 19
  22+ 8341              EQ_LEFT_MINING          EQU 20
  23+ 8341              EQ_RIGHT_MINING         EQU 21
  24+ 8341              EQ_FRONT_MILITARY       EQU 22
  25+ 8341              EQ_REAR_MILITARY        EQU 23
  26+ 8341              EQ_LEFT_MILITARY        EQU 24
  27+ 8341              EQ_RIGHT_MILITARY       EQU 25
  28+ 8341
  29+ 8341              EQ_ITEM_COUNT           EQU EQ_RIGHT_MILITARY+1
  30+ 8341
# file closed: ./Data/EquipmentEquates.asm
 107  8341                  INCLUDE "./Variables/constant_equates.asm"
# file opened: ./Variables/constant_equates.asm
   1+ 8341              ;Contants
   2+ 8341
   3+ 8341              SignMask8Bit		equ %01111111
   4+ 8341              SignMask16Bit		equ %0111111111111111
   5+ 8341              SignOnly8Bit		equ $80
   6+ 8341              SignOnly16Bit		equ $8000
   7+ 8341
   8+ 8341              Bit7Only            equ %10000000
   9+ 8341              Bit6Only            equ %01000000
  10+ 8341              Bit5Only            equ %00100000
  11+ 8341              Bit4Only            equ %00010000
  12+ 8341              Bit3Only            equ %00001000
  13+ 8341              Bit2Only            equ %00000100
  14+ 8341              Bit1Only            equ %00000010
  15+ 8341              Bit0Only            equ %00000001
  16+ 8341              Bit7Clear           equ %01111111
  17+ 8341              Bit6Clear           equ %10111111
  18+ 8341              Bit5Clear           equ %11011111
  19+ 8341              Bit4Clear           equ %11101111
  20+ 8341              Bit3Clear           equ %11110111
  21+ 8341              Bit2Clear           equ %11111011
  22+ 8341              Bit1Clear           equ %11111101
  23+ 8341              Bit0Clear           equ %11111110
  24+ 8341              ConstPi				equ $80
  25+ 8341              ConstNorm           equ 197
  26+ 8341
  27+ 8341              ;Text Tokens
  28+ 8341              EliteToken			equ $1E			; Token ID for text messsage ---- E L I T E ----
  29+ 8341              BrabenBellToken 	equ $0D
  30+ 8341              AcorToken			equ $0C
  31+ 8341
  32+ 8341              ; Intro Screen
  33+ 8341              TitleShip			equ	$8C
  34+ 8341              RotationUnity		equ $60
  35+ 8341              DBCheckCode			equ $DB
  36+ 8341              MaxVisibility		equ $1F
  37+ 8341              FarInFront			equ $C0
  38+ 8341
  39+ 8341              ; Universe Managment
  40+ 8341              ShipTypeJunk        equ 3
  41+ 8341              ShipTypeStation     equ 2
  42+ 8341              ShipTypeMissile     equ 1
  43+ 8341              ShipTypeNormal      equ 0
  44+ 8341              ShipTypeText        equ 253
  45+ 8341              ShipTypeDebug       equ 254
  46+ 8341              ShipTypeEmpty       equ 255
  47+ 8341              ; TacticsControl
  48+ 8341              ShipIsTrader        equ Bit0Only   ; Trader flag  80% are peaceful 20% also have Bounty Hunter flag
  49+ 8341              ShipIsBountyHunter  equ Bit1Only   ;
  50+ 8341              ShipIsHostile       equ Bit2Only   ;
  51+ 8341              ShipNotHostile      equ Bit2Clear   ;
  52+ 8341              ShipIsPirate        equ Bit3Only   ;
  53+ 8341              ShipIsDocking       equ Bit4Only   ;
  54+ 8341              ShipIsBystander     equ Bit5Only   ;
  55+ 8341              ShipIsCop           equ Bit6Only   ;
  56+ 8341              ShipIsScoopDockEsc  equ Bit7Only   ;
  57+ 8341              ShipAIEnabled       equ Bit7Only   ;
  58+ 8341              ShipExploding       equ Bit5Only
  59+ 8341              ShipKilled          equ Bit7Clear
  60+ 8341
  61+ 8341              ; UniverseAIControl
  62+ 8341              ShipCanAnger        equ %00000001
  63+ 8341
  64+ 8341
  65+ 8341              ShipMaxDistance     equ 192
  66+ 8341              HyperSpaceTimers    equ $0B0B
  67+ 8341
  68+ 8341
  69+ 8341              MaxNumberOfStars	equ 11
  70+ 8341              ConsoleRefreshInterval  equ 4
  71+ 8341
  72+ 8341              ShipTypeSize		equ	32 			;??????? just a guess for now
  73+ 8341              ShipSST				equ 4			; its a space station
  74+ 8341              UniverseBasePage 	equ 70			; Base memory bank for universe Item #0
  75+ 8341              ShipDataBasePage	equ	90			; Needs 2mb upgrade but what the heck
  76+ 8341              ShipCountMax		equ	2			; For now just 2 ships to debug
  77+ 8341              LineLimitPerShip	equ 70			; Max lines per ship
  78+ 8341              FaceLimitPerShip	equ	70			; Same as line limit to simplify some logic
  79+ 8341              ; "NEED TO DEFINE SHIPTYPESIZE TODO"
  80+ 8341              PlayerDocked		equ	$FF
  81+ 8341
  82+ 8341              ; Memory page managment	(Refers to a memory slot as a place to access data)
  83+ 8341              ShipDataSlot		equ	6			; this may move into rom swap out space later
  84+ 8341              UniverseObjectSlot	equ	7
  85+ 8341
  86+ 8341              KeyForwardsView		equ	$20
  87+ 8341              ; Game specific equates
  88+ 8341              MissileDropHeight   equ 5           ; how far the missile is ejected on launch in y axis
  89+ 8341
  90+ 8341              ;...Game Colour Mapping
  91+ 8341              L2DustColour        equ L2ColourGREY_1
  92+ 8341              L2SunScannerBright  equ 252
  93+ 8341              L2SunScanner        equ 180
  94+ 8341
  95+ 8341
  96+ 8341              ; Ship Data
  97+ 8341              ;;;;	.XX21	\ -> &5600 \ Table of pointers to ships' data given to XX0
  98+ 8341              ;;;;00 7F			 EQUW &7F00 \ type  1 is #MSL  Missile data on page off bottom of screen
  99+ 8341              ;;;;00 00			 EQUW 0     \ type  2 is #SST  Space Station, Coriolis or Dodo.
 100+ 8341              ;;;;00 00			 EQUW 0     \ type  3 is #ESC  Escape capsule
 101+ 8341              ;;;;00 00			 EQUW 0     \ type  4 is #PLT  Plate, alloys
 102+ 8341              ;;;;00 00			 EQUW 0     \ type  5 is #OIL  Cargo cannister
 103+ 8341              ;;;;00 00			 EQUW 0     \ type  6 is       Boulder
 104+ 8341              ;;;;00 00			 EQUW 0     \ type  7 is #AST  Asteroid
 105+ 8341              ;;;;00 00			 EQUW 0     \ type  8 is #SPL  Splinter, rock.
 106+ 8341              ;;;;00 00			 EQUW 0     \ type  9 is #SHU  Shuttle
 107+ 8341              ;;;;00 00			 EQUW 0     \ type 10 is       Transporter
 108+ 8341              ;;;;00 00			 EQUW 0     \ type 11 is #CYL  Cobra Mk III,  Boa
 109+ 8341              ;;;;00 00			 EQUW 0     \ type 12 is       Python
 110+ 8341              ;;;;00 00			 EQUW 0     \ type 13 is       Last of three traders
 111+ 8341              ;;;;00 00			 EQUW 0     \ type 14 is #ANA  Anaconda
 112+ 8341              ;;;;00 00			 EQUW 0     \ type 15 is #WRM  Worm with Anaconda
 113+ 8341              ;;;;00 00			 EQUW 0     \ type 16 is #COP  Viper
 114+ 8341              ;;;;00 00			 EQUW 0     \ type 17 is       First pirate
 115+ 8341              ;;;;00 00			 EQUW 0     \ type 18 is
 116+ 8341              ;;;;00 00			 EQUW 0     \ type 19 is #KRA  Krait small pirate
 117+ 8341              ;;;;00 00			 EQUW 0     \ type 20 is #ADA  Adder
 118+ 8341              ;;;;00 00			 EQUW 0     \ type 21 is
 119+ 8341              ;;;;00 00			 EQUW 0     \ type 22 is
 120+ 8341              ;;;;00 00			 EQUW 0     \ type 23 is
 121+ 8341              ;;;;00 00			 EQUW 0     \ type 24 is #CYL2 Last strong pirate
 122+ 8341              ;;;;00 00			 EQUW 0     \ type 25 is #ASP  Asp Mk II
 123+ 8341              ;;;;00 00			 EQUW 0     \ type 26 is #FER  Fer de Lance
 124+ 8341              ;;;;00 00			 EQUW 0     \ type 27 is
 125+ 8341              ;;;;00 00			 EQUW 0     \ type 28 is	Last of three bounty hunters
 126+ 8341              ;;;;00 00			 EQUW 0     \ type 29 is #THG  Thargoid
 127+ 8341              ;;;;00 00			 EQUW 0     \ type 30 is #TGL  Thargon
 128+ 8341              ;;;;00 00			 EQUW 0     \ type 31 is #CON  Constrictor
 129+ 8341              ;;;;	.E%	\ -> &563E \ Hull NEWB bits are escpod, cop, inno, ?, pirate, angry, hunter, trader.
 130+ 8341              ;;;;			\ NEWB examples
 131+ 8341              ;;;;\ 21			EQUB &21    \ 0010 0001    9 Shuttle has no escape pod, inno, trader.
 132+ 8341              ;;;;\ 61			EQUB &61    \ 0110 0001   10 Tansporter no escape pod, Cop, inno, trader.
 133+ 8341              ;;;;\ A0			EQUB &A0    \ 1010 0000   11 Cobra has Escape pod, inno, not a trader.
 134+ 8341              ;;;;\ C2			EQUB &C2    \ 1100 0010   16 Viper has Escape pod, Cop, hunter.
 135+ 8341              ;;;;\ 8C			EQUB &8C    \ 1000 1100   19 Krait pirate has escape pod, is pirate and angry.
 136+ 8341
# file closed: ./Variables/constant_equates.asm
 108  8341                  INCLUDE "./Variables/general_variables.asm"
# file opened: ./Variables/general_variables.asm
   1+ 8341
   2+ 8341
   3+ 8341 00 00        varAxis1	DW 	0				; address of first axis in a rotation action
   4+ 8343 00 00        varAxis2	DW	0				; address of 2nd axis in a roation action
   5+ 8345              ; Variables to simulate 6502 registers until code fixed
   6+ 8345              ; These must be here in this order as reading Y and X can then be a 16 bit read
   7+ 8345 00           regX		DB	0               ; using 16 bit read into BC this would go into C
   8+ 8346 00           regY		DB	0               ; using 16 bit read into BC this would go into B
   9+ 8347 00           regA		DB	0
  10+ 8348
  11+ 8348
  12+ 8348 00           varGPLoopA	DB	0				; General Purpose innermost loop variable
  13+ 8349 00 00        INF			DW	0				; page 0 &20 Used to get address from UNIV array
  14+ 834B 00 00        INF28		DW	0				; page 0 &20 Used to get address from UNIV array
  15+ 834D
  16+ 834D
  17+ 834D
  18+ 834D              ;XX16		DS	16				; 16 byte Matrix
  19+ 834D
  20+ 834D              P0INWK							; page 0 & 46
  21+ 834D              p0INWK31						; page 0 & 65
  22+ 834D              P0INWK36						; PAGE 0 &6A
  23+ 834D
  24+ 834D 00           XX4			DB	0				; XX4 page 0 &96 last Normal Found to be visible
  25+ 834E              LastNormalVisible	equ	XX4
  26+ 834E              varXX4              equ XX4
  27+ 834E
  28+ 834E
  29+ 834E
  30+ 834E 00           PATG		DB	0				; 6502 &03C9
  31+ 834F 00 00        SLSP 		DW	0				; &03B0 \ SLSP \ ship lines pointer
  32+ 8351
  33+ 8351
  34+ 8351              ;UNIV		DS FreeListSize*2	; Array of Universe Pointers
  35+ 8351              ;HULLINDEX	DS ShipTypeSize*2	; hull index for table at XX21= &5600 XX21-1,Y
  36+ 8351
  37+ 8351              ; Present System Variables
  38+ 8351
  39+ 8351 2B           RandomSeed				DB	43			; 00 DEBUG JUST SOME START VALUES
  40+ 8352 20           RandomSeed1				DB	32	; 01
  41+ 8353 0C           RandomSeed2				DB	12			; 02
  42+ 8354 42           RandomSeed3				DB	66			; 03
  43+ 8355
  44+ 8355 00           varT1					DB	0				; 06
  45+ 8356 00           SClo					DB 0				; 07
  46+ 8357 00           SChi					DB 0				; 08
  47+ 8358 00           varP					DB 0 				; 10	XX16+7
  48+ 8359 00           varPhi					DB 0 				; 11	XX16+8
  49+ 835A 00           varPhi2					DB 0 				; 12	XX16+9
  50+ 835B              varPp1                  equ varPhi
  51+ 835B              varPp2                  equ varPhi2
  52+ 835B 00           UnivPointerLo			DB	0				; 20		INF                 XX0+2
  53+ 835C 00           UnivPointerHi			DB	0				; 21      INF+1               XX0+3
  54+ 835D              UnivPointer				equ	UnivPointerLo
  55+ 835D 00           varV					DB 0				; 22                          XX0+4
  56+ 835E 00           varVHi					DB 0				; 23                          XX0+5
  57+ 835F 00           varXXlo                 DB 0                ; 24
  58+ 8360 00           varXXHi                 DB 0                ; 25
  59+ 8361              varXX					equ	varXXlo
  60+ 8361 00           YYlo                    DB 0                ; 26
  61+ 8362 00           YYHi                    DB 0                ; 27
  62+ 8363              varYY					equ	YYlo
  63+ 8363              											;	28
  64+ 8363              											;	29
  65+ 8363              ;PlayerShipPositionData - Must be contiguous for setup
  66+ 8363 00           BETA 					DB	0               ; 2A        (pitch done)
  67+ 8364 00           JSTY                    DB  0               ; Joystick analog
  68+ 8365 00           BET1 					DB	0               ; 2B        lower7 magnitude
  69+ 8366 00           BET2                    DB  0               ;            climb sign
  70+ 8367 00           BET2FLIP				DB	0				; 7C		BET 2 pitch Sign negated
  71+ 8368 1F           BET1MAXC                DB  31              ; max climb
  72+ 8369 E1           BET1MAXD                DB  -31             ; max dive
  73+ 836A 00           XC						DB	0               ; 2C
  74+ 836B 00           YC						DB 	0               ; 2D
  75+ 836C              ;... ECM logic. If another ship adds ECM then we just set the loop A and B to starting values so they overlap
  76+ 836C 00           ECMActive				DB 	0				; 30		ECM Active flag
  77+ 836D 00           ECMLoopA                DB  0
  78+ 836E 00           ECMLoopB                DB  0
  79+ 836F 00 00        JSTX                    DW  0               ;           Joystick analog value
  80+ 8371 00           ALPHA					DB	0				; 8D        Alpha with bit 7 sign
  81+ 8372 00           ALP1					DB 	0				; 31		ALP1	Roll magnitude Also Apha
  82+ 8373 00           ALP2					DB  0				; 32		ALP2	Roll Sign
  83+ 8374 00           ALP2FLIP				DB  0				; 33		ALP2	negated roll sign
  84+ 8375 1F           ALP1MAXR                DB  31               ;   Maximum roll, added becuase we may allow different ship types
  85+ 8376 E1           ALP1MAXL                DB  -31             ;   Maximum roll, added becuase we may allow different ship types
  86+ 8377
  87+ 8377
  88+ 8377
  89+ 8377              MAXMESSAGES             EQU 5
  90+ 8377              MESSAGETIMELIMIT        EQU 20
  91+ 8377              MESSAGESIZE             EQU 33
  92+ 8377              MESSAGELINE             EQU $0001
  93+ 8377
  94+ 8377 00           MessageCount            DB  0                ; used for enquing messages later
  95+ 8378 00           MessageCurrent          DB  0
  96+ 8379 05 00        MessageIndex            DW  MAXMESSAGES
  97+ 837B 00 00 00...  MessageQueue            DS  MAXMESSAGES * MESSAGESIZE
  98+ 8420 05           MessageTimeout          DB  MAXMESSAGES
  99+ 8421 00 00 00...  IndexedWork				DS	37				; General purpose work space when doing temp arrays
 100+ 8446
 101+ 8446              ; MOVED TO Universe XX19					DB	0				; page 0 &67
 102+ 8446              ; MOVED TO Universe XX20					DB	0				; page 0 &67 also used as XX19+1 for XX19 being a word
 103+ 8446              ;DEFUNCT EQUATE NormalCountCopyBy4		equ	XX20			; Also used for normal * 4 holding variable
 104+ 8446 00           XX21					DB  0				; this may be part of XX20/xx21 accordign to spawn new shipXX21		DW	0				; Ah XX21 is hull pointer  hull pointer lo as it can;t hold HULLINDX as 16bit array
 105+ 8447              ;XX21 is the pointer table to the pages for ship types. this will be repalaced by paging so just need an equate for first page
 106+ 8447
 107+ 8447
 108+ 8447 00 00 00...  SystemSeed				DS  5				;	6C		QQ15	Current Galaxy Seed
 109+ 844C              											;	6D		QQ15+1
 110+ 844C              											;	6E		QQ15+2
 111+ 844C              											;	6F		QQ15+3
 112+ 844C              											;	70		QQ15+4
 113+ 844C              											;	71		QQ15+5
 114+ 844C 00           QQ17					DB	0				;   72
 115+ 844D 00           XX18xlo                 DB  0               ;	72		XX18   xlo
 116+ 844E 00           XX18xhi                 DB  0               ;	73		XX18+1 xhi
 117+ 844F 00           XX18xsg                 DB  0               ;	74		XX18+2 xsgn
 118+ 8450 00           XX18ylo                 DB  0               ;	75		XX18   ylo
 119+ 8451 00           XX18yhi                 DB  0               ;	76		XX18+1 yhi
 120+ 8452 00           XX18ysg                 DB  0               ;	77		XX18+2 ysgn
 121+ 8453 00           XX18zlo                 DB  0               ;	78		XX18   zlo
 122+ 8454 00           XX18zhi                 DB  0               ;	79		XX18+1 zhi
 123+ 8455 00           XX18zsg                 DB  0               ;	7A		XX18+2 zsgn
 124+ 8456
 125+ 8456 28           SHIPMAXSPEED            DB  40              ; variable to facilitate ship editing later
 126+ 8457 00           DELTA					DB 	0				; 7D 		DELTA  \ bpl -2 inserted here to stall from title code if byte check fails
 127+ 8458 00           DELT4Lo					DB 	0				; 7E
 128+ 8459 00           DELT4Hi					DB 	0				; 7F
 129+ 845A              DELTA4                  equ                 DELT4Lo
 130+ 845A
 131+ 845A
 132+ 845A              ; Not thise must be in this order else 16 bit fetches will fail
 133+ 845A 00           varU                    DB  0               ;   80
 134+ 845B 00           varQ					DB  0 				;	81
 135+ 845C 00           varR					DB  0 				;	82
 136+ 845D 00           varS					DB  0 				;	83
 137+ 845E              varRS                   equ varR
 138+ 845E
 139+ 845E 00 00        varU16                  DW  0               ; 16 bit variant on varU as I can't use above for this
 140+ 8460
 141+ 8460 00           XSAV					DB	0				; 84	   XSAV usef for nearby ship count outer
 142+ 8461 00           YSAV                    DB  0               ; 85
 143+ 8462 00           XX17					DB	0				; 86
 144+ 8463              RequiredScale			equ  XX17			; use to hold calculated scale in drawing ship
 145+ 8463              varXX17                 equ  XX17
 146+ 8463 00           ScreenChanged           DB  0
 147+ 8464 00           ScreenIndex             DB  0
 148+ 8465 00           InvertedYAxis           DB  0
 149+ 8466 00           MenuIdMax				DB	0				;	87		MenuIdMax		QQ11
 150+ 8467              											; Bit 7 Set  ShortRangeChart    $80
 151+ 8467              											; Bit 6 Set  Galactic Chart     $40
 152+ 8467              											; Bit 5 Set  Market Place       $20
 153+ 8467              											; Bit 4 Set  Status Screen      $10
 154+ 8467              											; Bit 3 Set  Display Inventory  $08
 155+ 8467                                                          ; Bit 2 Set  Planet Data        $04
 156+ 8467                                                          ; View bit combinations if the ones above not matched
 157+ 8467                                                          ; bits 1 0
 158+ 8467                                                          ;      1 1  Front view , i.e. $03
 159+ 8467                                                          ;      1 0  Aft View          $02
 160+ 8467                                                          ;      0 1  Left View         $01
 161+ 8467                                                          ;      0 0  Right view        $00
 162+ 8467              											; Bit 0 Set  Data On System
 163+ 8467              											; 0  Space View (Not a menu)
 164+ 8467 00           ZZDust					DB	0				;	88		ZZDust (Poss 16 bit need to check)
 165+ 8468 00           XX13                    DB  0               ;   89
 166+ 8469 00           TYPE					DB	0				; 8C used for ship type in drawing
 167+ 846A              ;Docked flag = 00 = in free space
 168+ 846A              ;              FF = Docked
 169+ 846A              ;              FE = transition
 170+ 846A              ;              FD = Setup open space and transition to not docked
 171+ 846A              ;              FC = Hyperspace manimation
 172+ 846A              ;              FB = Hyperspace complete
 173+ 846A 00           DockedFlag				DB	0				; 8E -
 174+ 846B 00           GamePaused              DB  0
 175+ 846C 00           varSWAP                 DB  0               ; 90 , general purpose swap variable
 176+ 846D 00           varCNT                  DB  0               ; 93
 177+ 846E
 178+ 846E 00           varK					DB	0				; 40
 179+ 846F 00           varKp1					DB	0				; 41
 180+ 8470 00           varKp2					DB	0				; 42
 181+ 8471 00           varKp3					DB	0				; 43
 182+ 8472
 183+ 8472 00           varK2                   DB  0               ; 9B
 184+ 8473 00           varK2p1                 DB  0               ; 9C K2 plus 1
 185+ 8474 00           varK2p2                 DB  0               ; 9D K2 plus 2
 186+ 8475 00           varK2p3                 DB  0               ; 9E K2 plus 3
 187+ 8476
 188+ 8476 00           Point                   DB  0               ; 9F      POINT
 189+ 8477
 190+ 8477 00           varT					DB	0				; D1
 191+ 8478
 192+ 8478 00 00 00...  varVector9ByteWork      DS  9
 193+ 8481
 194+ 8481 00 00 00 00  varK3					DS	4				; D2
 195+ 8485 00           varK3p2					DB	0				; 42
 196+ 8486 00           varK3p3					DB	0				; 43
 197+ 8487              varK3p1					equ varK3+1			; D3
 198+ 8487 00 00 00 00  varK4					DS	4				; E0
 199+ 848B              varK4p1					equ varK4+1			; D3
 200+ 848B
 201+ 848B
 202+ 848B              ;Heap
 203+ 848B
 204+ 848B 00 00        HeapStart				DS	2				; &0100 XX3 50 bytes for now
 205+ 848D 00 00 00...  HeapData				DS	50
 206+ 84BF              ; Contains 				X 16 bit, Y ;MissileArmedStatus		DB	0				; 0344 MSAR   using MissileTarget, if missile is not armed tehn target is FF
 207+ 84BF              ; TODO will need an read for a list of missiles, who they are targeting an the target current vector for AI persuit
 208+ 84BF              ; i.e. a list of programmed missiles in universe slot list code
 209+ 84BF 00 00 00...  DampingKeys				DS  7				; 0387 - 038D
 210+ 84C6              ;  #&6 Does K toggle keyboard/joystick control -  03CD certainly makes keyboard not work anymore.
 211+ 84C6              ;  #&5 Does J reverse both joystick channels
 212+ 84C6              ;  #&4 Does Y reverse joystick Y channel			03CB
 213+ 84C6              ;  #&2 Does X toggle startup message display ? PATG?	03C9
 214+ 84C6              ;  #&3 Does F toggle flashing information			03CA
 215+ 84C6              ;  #&1 Does A toggle keyboard auto-recentering ?
 216+ 84C6              ;  #&0 Caps-lock toggles keyboard flight damping
 217+ 84C6 00           NbrMissiles				DB	0				; 038B	Does this clash with Dampingkeys?
 218+ 84C7 00           FugitiveInnocentStatus	DB	0				; 038C	FIST
 219+ 84C8 00 00 00...  StockAvaliabiliy		DS 	16				; 038D - 039C Stock inventory in station
 220+ 84D8 00           AlienItemsAvaliability  DB	0				; 039D
 221+ 84D9 00           RandomMarketSeed		DB	0				; 039E   \ QQ26	\ random byte for each system vist (for market)
 222+ 84DA 00 00        KillTally  				DW	0				; 039F - 03A0 \ TALLY   \ kills lo hi
 223+ 84DC 00           COMP     				DB	0				; 03A1 2nd competion byte used for save integrity checks?
 224+ 84DD              											;
 225+ 84DD 00           MCH						DB	0				; 03A4  \ MCH  \ old message to erase
 226+ 84DE 00           MarketPrice				DB	0				; 03AA QQ24
 227+ 84DF 00           MaxStockAvaliable		DB  0				; 03AB   \ QQ25     \ max available
 228+ 84E0 00           SystemEconomy			DB  0				; 03AC \ QQ28   \ the economy byte of present system (0 is Rich Ind.)
 229+ 84E1 00           CargoItem				DB	0				; 03AD (I think its item type just scooped) QQ29
 230+ 84E2 00 00        ShipLineStackPointer	DW	0				; 03B0 & 03B1 ship Lines pointer reset to top LS% = &0CFF (make DW for z80 and direct hl pointer)
 231+ 84E4              											; this is ship lines stack pointer so may be redundant with paging
 232+ 84E4              											; LS = line stack so we will have one for now to remove later
 233+ 84E4 00           COK						DB	0				; 0366 Competition Byte what ? Does some file check and accelleration check
 234+ 84E5 00           DisplayEcononmy			DB	0				; 03B8
 235+ 84E6 00           DisplayGovernment		DB  0				; 03B9 Is it target? 03B9 \ QQ4	 \ Government, 0 is Anarchy.
 236+ 84E7 00           DisplayTekLevel			DB	0				; 03BA   \ QQ5	\ Tech
 237+ 84E8 00 00        DisplayPopulation		DW	0				; 03BB \ QQ6  \ population*10
 238+ 84EA 00 00        DisplayProductivity		DW	0				; 03BD \ QQ7   \ productivity*10
 239+ 84EC 00 00        Distance          		DW	0				; 03BE \ QQ8 distince in 0.1LY units
 240+ 84EE 00 00        DisplayRadius			DW	0
 241+ 84F0              ; --- Used in creation of sun and planet----;
 242+ 84F0 00           PlanetXPos              DS  1
 243+ 84F1 00           PlanetYPos              DS  1
 244+ 84F2 00           PlanetZPos              DS  1
 245+ 84F3 00           PlanetType              DS  1
 246+ 84F4 00           SunXPos                 DS  1
 247+ 84F5 00           SunYPos                 DS  1
 248+ 84F6 00           SunZPos                 DS  1
 249+ 84F7              ; -- Current Missile Runbtime data
 250+ 84F7 00           CurrentMissileBank:     DB      0                                   ; used by missile logic as local copy of missile bank number
 251+ 84F8 00 00        MissileXPos             DW      0
 252+ 84FA 00           MissileXSgn             DB      0
 253+ 84FB 00 00        MissileYPos             DW      0
 254+ 84FD 00           MissileYSgn             DB      0
 255+ 84FE 00 00        MissileZPos             DW      0
 256+ 8500 00           MissileZSgn             DB      0
 257+ 8501 00 00        CurrentTargetXpos       DS      2
 258+ 8503 00 00        CurrentTargetXsgn       DS      2
 259+ 8505 00 00        CurrentTargetYpos       DS      2
 260+ 8507 00 00        CurrentTargetYsgn       DS      2
 261+ 8509 00 00        CurrentTargetZpos       DS      2
 262+ 850B 00 00        CurrentTargetZsgn       DS      2
 263+ 850D 00 00        TargetVectorXpos        DS      2
 264+ 850F 00 00        TargetVectorXsgn        DS      2
 265+ 8511 00 00        TargetVectorYpos        DS      2
 266+ 8513 00 00        TargetVectorYsgn        DS      2
 267+ 8515 00 00        TargetVectorZpos        DS      2
 268+ 8517 00 00        TargetVectorZsgn        DS      2
 269+ 8519 00           CurrentMissileBlastRange:      DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 270+ 851A 00           CurrentMissileBlastDamage:     DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 271+ 851B 00           CurrentMissileDetonateRange:   DB  0                       ; TODO Initi for runtime copied in when setting up a missile, allows for proximity missiles
 272+ 851C 00           CurrentMissileDetonateDamage:  DB  0                       ; TODO Initi for runtime copied in when setting up a missile
 273+ 851D
 274+ 851D              ; --- Main Loop Data -----------------------;
 275+ 851D 00           CurrentUniverseAI       DB  0               ; current ship unviverse slot due an AI update
 276+ 851E 00           SelectedUniverseSlot    DB  0
 277+ 851F 00           SetStationAngryFlag     DB  0               ; used to semaphore angry space station
 278+ 8520 00           ShipBlastCheckCounter   DB  0
 279+ 8521 00           InnerHyperCount			DB 	0				; 2F QQ22+1
 280+ 8522 00           OuterHyperCount			DB 	0				; 2E QQ22
 281+ 8523 00           EventCounter            DB  0
 282+ 8524 00           HyperCircle             DB  0
 283+ 8525 00           MissJumpFlag            DB  0
 284+ 8526 00           PlayerMisJump			DB	0				; $0341 witchspace misjump
 285+ 8527 00           HyperSpaceFX			DB	0				; 0348 HFX (probabyl BBC specific
 286+ 8528 00           ExtraVessels			DB	0				; 0349 EV Use d by cops, extra vessels still to spawn?
 287+ 8529 00           Delay					DB	0				; 034A Delay general purpose eg. spawing EV or when printign messages
 288+ 852A 00           CurrentMissileCheck:    DB  0               ; if > Universe Slot list then free for next missile
 289+ 852B 00           MessageForDestroyed		DB	0				; 034B Message flag for item + destroyed
 290+ 852C              UniverseSlotListSize    equ	12
 291+ 852C 00 00 00...  UniverseSlotList        DS  UniverseSlotListSize
 292+ 8538 00 00 00...  UniverseSlotType        DS  UniverseSlotListSize ; base type, e.g. missile, cargo etc,
 293+ 8544              ; Probably not needed UniverseTypeCount       DS  UniverseSlotListSize
 294+ 8544 04           ConsoleRefreshCounter   DB  ConsoleRefreshInterval ; Every 4 interations the console will update twice (once for primary and once for seconday buffer)
 295+ 8545 00           ConsoleRedrawFlag       DB  0
 296+ 8546 00           TextInputMode           DB  0
 297+ 8547 00           CursorKeysPressed       DB  0               ; mapping of the current key presses
 298+ 8548                                                          ; 7    6    5    4     3    2        1    0
 299+ 8548                                                          ; Up   Down Left Right Home Recentre
 300+ 8548 00           FireLaserPressed        DB  0
 301+ 8549              ; --- Current System Data ------------------;
 302+ 8549 00           SpaceStationSafeZone    DB  0               ; Flag to determine if we are in safe zone
 303+ 854A 00           ExtraVesselsCounter     DB  0
 304+ 854B 00           JunkCount				DB  0				; $033E
 305+ 854C 00           AsteroidCount           DB  0               ; Not used as yet
 306+ 854D 00           TransporterCount        DB  0
 307+ 854E 00           CopCount                DB  0
 308+ 854F 00           PirateCount             DB  0
 309+ 8550              ; --- Galaxy Data --------------------------;
 310+ 8550 00           Galaxy      			DB	0				; 0367 Galaxy (incremented with galactiv drive
 311+ 8551 00 00 00...  WorkingSeeds			DS	6
 312+ 8557 00 00 00...  PresentSystemSeeds		DS	6				; 03B2 - 03B7
 313+ 855D 00 00 00...  GalaxySeeds				DS	6				; 035B - 0360 QQ21
 314+ 8563 00           PresentSystemX			DB	0				; System we are currently in
 315+ 8564 00           PresentSystemY			DB  0				; System we are currently in
 316+ 8565 00           TargetSystemX			DB	0				; System we are targeting for jump
 317+ 8566 00           TargetSystemY			DB	0				; System we are targeting for jump
 318+ 8567 00           GovPresentSystem		DB	0				; 03AE Govenment
 319+ 8568 00           TekPresentSystem		DB	0				; 03AF Technology
 320+ 8569
 321+ 8569 00           CompassColor			DB	0				; 03C5
 322+ 856A 00           SoundToggle				DB	0				; 03C6
 323+ 856B 00           KeyboardRecenterToggle	DB	0				; 03C8
 324+ 856C 00           PATGMask				DB	0				; &03C9    \ PATG	\ Mask to scan keyboard X-key, for misjump
 325+ 856D 00           FlashToggle				DB  0				; 03CA \ FLH \ flash toggle
 326+ 856E 00           ReverseJoystick			DB	0				; 03CB \ JSTGY \ Y reverse joystick Y channel
 327+ 856F 00           JoystickToggle			DB	0				; 03CD  \ JSTK    \ K toggle keyboard/joystick
 328+ 8570 00           DigitalJoystick			DB	0				; 03CE \ JDB   \ . = toggle between keyboard and bitpaddle
 329+ 8571 00           DiskReadFailFlag		DB	0				; 03CF \ CATF \ Disk catalog fail flag
 330+ 8572
 331+ 8572              ; Working Data
 332+ 8572
 333+ 8572              ;UniverseTable			DS	26				; 1741  \ address pointers for 13 ships INF on pages &9. 37 bytes each.
 334+ 8572              ; $0900 =	EQUW page9+37* 0 \ copied to inner worskpace INWK on zero-page when needed
 335+ 8572              ; $0925 =	EQUW page9+37* 1
 336+ 8572              ; $094A =	EQUW page9+37* 2
 337+ 8572              ; $096F =	EQUW page9+37* 3
 338+ 8572              ; $0994 =	EQUW page9+37* 4
 339+ 8572              ; $09B9 =	EQUW page9+37* 5
 340+ 8572              ; $09DE =	EQUW page9+37* 6
 341+ 8572              ; $0A03 =	EQUW page9+37* 7
 342+ 8572              ; $0A28 =	EQUW page9+37* 8
 343+ 8572              ; $0A4D =	EQUW page9+37* 9
 344+ 8572              ; $0A72 =	EQUW page9+37*10
 345+ 8572              ; $0A97 =	EQUW page9+37*11
 346+ 8572              ; $0ABC =	EQUW page9+37*12 \ allwk up to &0ABC while heap for edges working down from &CFF.
 347+ 8572
 348+ 8572
 349+ 8572
 350+ 8572              ; 0b00 is start address of data to save
 351+ 8572              ; Now MissionData VarTP					DB	0				; 0358 TP? The Plan  \ mission uses lower 4 bits
 352+ 8572              											; Bit mask XXXX10XX - Thargoid plan mission
 353+ 8572
 354+ 8572 00           MissionData				DB	0				; &0B00	  \ look at data, first byte is TP mission bits
 355+ 8573
 356+ 8573 00 00        FileNameStringPointer	DW	0				;0C00	   \ pointer to filename string
 357+ 8575 00 00        CommanderLoadAddress	DW	0				;0C03
 358+ 8577 00 00        LengthOfFile			DW	0				;0C0B
 359+ 8579 00 00        SaveDataEndAddress		DW	0				;&0C0F	      \ &0C00 is end address of data to save
 360+ 857B
 361+ 857B 00 00 00...  EdgesBuffer				DS 50
 362+ 85AD              EdgesBufferSP			equ	$				; Was $0CFF			; Heap pointer for edges buffer
 363+ 85AD              ShipLinesBufferSP		equ EdgesBufferSP	; was $0CFF
 364+ 85AD
 365+ 85AD 00 00 00...  ShipLineStack			DS  70			; For now but will be in the page later
 366+ 85F3              ShipLineStackTop		equ $ - ShipLineStack
 367+ 85F3
 368+ 85F3 00 00 00...  LSO						DS 	$C0				;0E00 Line Buffer Solar of 192 lines (may be 191 in reality)
 369+ 86B3              ; LSX vector overlaps with LSO
 370+ 86B3 00           LSX2					DB	0				; &0EC0	    \ LSX2 bline buffer size?
 371+ 86B4 00           LSY2					DB	0           	; &0F0E	    \ LSY2
 372+ 86B5
 373+ 86B5              ; Star Positions are 16 bit 3d coordinates
 374+ 86B5 00 00 00...  varDust                 DS  MaxNumberOfStars * 6
 375+ 86F7 00 00 00...  varDustSceen            DS  MaxNumberOfStars * 2 ; To optimise star list to wipe from screen
 376+ 870D 00           varStarX                DB  0
 377+ 870E 00           varStarY                DB  0
 378+ 870F 00 00 00...  varDustX                DS MaxNumberOfStars *2
 379+ 8725 00 00 00...  varDustY                DS MaxNumberOfStars *2
 380+ 873B 00 00 00...  varDustZ                DS MaxNumberOfStars *2
 381+ 8751              ; -- Player Runtime Data
 382+ 8751 00           GunTemperature          DB  0
 383+ 8752 00           CabinTemperature        DB  0
 384+ 8753 00           PlayerForwardSheild0	DB	0 ; ?????
 385+ 8754 00           PlayerForwardSheild1    DB	0
 386+ 8755 00           PlayerForwardSheild2    DB	0
 387+ 8756 00           ForeShield				DB	0				; 03A5
 388+ 8757 00           AftShield				DB	0				; 03A6
 389+ 8758 00           PlayerEnergy			DB	0				; 03A7
 390+ 8759 00           CompassX				DB	0				; 03A8
 391+ 875A 00           CompassY				DB	0				; 03A9
 392+ 875B 00           MissileTarget			DB  0				; 45
 393+ 875C 00           MissileLaunchFlag       DB  0
 394+ 875D 00 00 00...  CommanderName           DS  15
 395+ 876C 00           CommanderName0			DB	0				; Sneaky little 0 to allow use of print name directly
 396+ 876D 00           BadnessStatus           DB  0
 397+ 876E              ; need to add copy table routines
 398+ 876E 00           CurrLaserType           DB  0               ; current view laser type, copied in from LaserType array
 399+ 876F 00           CurrLaserDamage         DB  0               ; copied in from LaserDamagedFlag array
 400+ 8770 00           CurrLaserPulseRate      DB  0               ; current view laser amount of pulses
 401+ 8771 00           CurrLaserPulseOnTime    DB  0               ; how many cycles the laser is on
 402+ 8772 00           CurrLaserPulseOffTime   DB  0               ; how many cycles the laser is on
 403+ 8773 00           CurrLaserPulseRest      DB  0               ; current view laser delay setup between pulses
 404+ 8774              ; Count down timers must be aligned like this to work
 405+ 8774 00           CurrLaserPulseOnCount   DB  0               ; how many cycles the laser is on timer
 406+ 8775 00           CurrLaserPulseOffCount  DB  0               ; how many cycles the laser is on timer
 407+ 8776 00           CurrLaserPulseRestCount DB  0               ; countdown after shooting for next shot
 408+ 8777 00           CurrLaserPulseRateCount DB  0               ; current view laser current pulses fired
 409+ 8778              ;note rapidly changing views could reset these so need to consider it in an array
 410+ 8778
 411+ 8778              ; LaserType
 412+ 8778              ; LaserPulseRate                          ; how many pulses can be fired before long pause
 413+ 8778              ; LaserPulsePause                         ; time before next pulse - 0 = beam
 414+ 8778              ; LaserPulseRest                          ; time before pulse count resets to 0
 415+ 8778              ; LaserDamageOutput                       ; amount of damage for a laser hit
 416+ 8778              ; LaserEnergyDrain                        ; amount of energy drained by cycle
 417+ 8778              ; LaserHeat                               ; amount of heat generated
 418+ 8778              ; LaserDurability                         ; probabability out of 255 that a hit on unshielded will add random amount of damage
 419+ 8778              ; LaserDurabilityAmount                   ; max amount of damagage can be sustained in one damage hit
 420+ 8778              ; LaserInMarkets                          ; can this laser be purchased 0 = yes 1 = no
 421+ 8778              ; LaserTechLevel                          ; minimum tech level system to buy from
 422+ 8778
 423+ 8778 00           CurrLaserBurstRate      DB  0
 424+ 8779 00           CurrLaserBurstCount     DB  0
 425+ 877A 00           CurrLaserDamageOutput   DB  0
 426+ 877B 00           CurrLaserEnergyDrain    DB  0
 427+ 877C 00           CurrLaserHeat           DB  0
 428+ 877D 00           CurrLaserDurability     DB  0
 429+ 877E 00           CurrLaserDurabilityAmount DB  0
 430+ 877F
 431+ 877F              ; -- Input variables
 432+ 877F 00           JoystickX				DB	0				; 034C JSTX
 433+ 8780 00           JoystickY				DB	0				; 034D JSTY
 434+ 8781 00           XSAV2 					DB	0				; 034E used to temporary save 6502 X reg
 435+ 8782 00           YSAV2 					DB	0				; 034F used to temporary save 6502 Y reg
 436+ 8783
 437+ 8783              ; -- Console drawing data
 438+ 8783              FShieldStart            equ $8410
 439+ 8783              AShieldStart            equ $8D10
 440+ 8783              FuelStart               equ $9410
 441+ 8783
 442+ 8783              EnergyBar4Start         equ $A5D5
 443+ 8783              EnergyBar3Start         equ $ADD5
 444+ 8783              EnergyBar2Start         equ $B5D5
 445+ 8783              EnergyBar1Start         equ $BDD5
 446+ 8783              ; 70 /2 = 35 values
 447+ 8783              ;                            0                             1                             2                             3
 448+ 8783              ;                            0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6
 449+ 8783 01 02 02 03  FuelMapping             DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,19,20,21,21,22,23,24,25,26,27,28,30,31,31
 449+ 8787 04 04 05 06
 449+ 878B 06 07 08 09
 449+ 878F 0A 0A 0B 0C
 449+ 8793 0D 0E 0E 0F
 449+ 8797 10 10 11 13
 449+ 879B 14 15 15 16
 449+ 879F 17 18 19 1A
 449+ 87A3 1B 1C 1E 1F
 449+ 87A7 1F
 450+ 87A8              SpeedoStart             equ $84D1
 451+ 87A8              ;                            0                             1                             2                             3                             4
 452+ 87A8              ;                            0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5  6  7  8  9  0
 453+ 87A8 01 02 02 03  SpeedoMapping           DB  01,02,02,03,04,04,05,06,06,07,08,09,10,10,11,12,13,14,14,15,16,16,17,18,19,20,20,21,22,23,24,24,25,26,26,27,28,28,29,30,31
 453+ 87AC 04 04 05 06
 453+ 87B0 06 07 08 09
 453+ 87B4 0A 0A 0B 0C
 453+ 87B8 0D 0E 0E 0F
 453+ 87BC 10 10 11 12
 453+ 87C0 13 14 14 15
 453+ 87C4 16 17 18 18
 453+ 87C8 19 1A 1A 1B
 453+ 87CC 1C 1C 1D 1E
 453+ 87D0 1F
 454+ 87D1
 455+ 87D1              DialMiddleXPos          equ $E1
 456+ 87D1              RollMiddle              equ $8CE0
 457+ 87D1              PitchMiddle             equ $94E0
 458+ 87D1
 459+ 87D1
 460+ 87D1
 461+ 87D1
 462+ 87D1
# file closed: ./Variables/general_variables.asm
 109  87D1                  INCLUDE "./Variables/UniverseSlotRoutines.asm"
# file opened: ./Variables/UniverseSlotRoutines.asm
   1+ 87D1 AF           ClearSlotCount:         xor     a
   2+ 87D2 21 2C 85                             ld      hl,UniverseSlotList
   3+ 87D5 06 0C                                ld      b, UniverseSlotListSize ; prbably not needed + UniverseSlotTypeSize
   4+ 87D7 77           .fillLoop:              ld      (hl),a
   5+ 87D8 23                                   inc     hl
   6+ 87D9 10 FC                                djnz    .fillLoop
   7+ 87DB C9                                   ret
   8+ 87DC
   9+ 87DC              ; Initialises all types to a count of 1 where there is an occupied universe slot
  10+ 87DC              ; this needs expanding to cater for a missing type, find type and increment count (use cpir?)
  11+ 87DC              ; DOE NOT WORK CorrectSlotCount:       call    ClearSlotCount
  12+ 87DC              ; DOE NOT WORK                         ld      hl,UniverseSlotCount
  13+ 87DC              ; DOE NOT WORK                         ld      de,UniverseSlotList
  14+ 87DC              ; DOE NOT WORK                         ld      b,UniverseSlotListSize
  15+ 87DC              ; DOE NOT WORK .fillLoop:              ld      a,(de)
  16+ 87DC              ; DOE NOT WORK                         cp      $FF
  17+ 87DC              ; DOE NOT WORK                         jr      z,.SkipSlot
  18+ 87DC              ; DOE NOT WORK .CorrectSlot:           ld      (hl),a
  19+ 87DC              ; DOE NOT WORK                         inc     hl
  20+ 87DC              ; DOE NOT WORK                         ld      (hl),1
  21+ 87DC              ; DOE NOT WORK                         inc     hl
  22+ 87DC              ; DOE NOT WORK                         inc     hl
  23+ 87DC              ; DOE NOT WORK .SkipSlot               inc     de
  24+ 87DC              ; DOE NOT WORK                         djnz    .fillLoop
  25+ 87DC C9                                   ret
  26+ 87DD              ; Wipe all items
  27+ 87DD 3E FF        ClearUnivSlotList:      ld      a,$FF
  28+ 87DF 21 2C 85                             ld      hl,UniverseSlotList
  29+ 87E2 06 18                                ld      b, UniverseSlotListSize * 2
  30+ 87E4 77           .fillLoop:              ld      (hl),a
  31+ 87E5 23                                   inc     hl
  32+ 87E6 10 FC                                djnz    .fillLoop
  33+ 87E8 C9                                   ret
  34+ 87E9
  35+ 87E9 21 2C 85     SetSlot0ToSpaceStation: ld      hl,UniverseSlotList
  36+ 87EC 36 02                                ld      (hl),ShipTypeStation
  37+ 87EE 21 38 85                             ld      hl,UniverseSlotType
  38+ 87F1 36 02                                ld      (hl),ShipTypeStation
  39+ 87F3 C9                                   ret
  40+ 87F4
  41+ 87F4 21 2C 85     SetSlotAToTypeB:        ld      hl,UniverseSlotList
  42+ 87F7 ED 31                                add     hl,a
  43+ 87F9 70                                   ld      (hl),b
  44+ 87FA C9                                   ret
  45+ 87FB
  46+ 87FB 21 38 85     SetSlotAToClassB:       ld      hl,UniverseSlotType
  47+ 87FE ED 31                                add     hl,a
  48+ 8800 70                                   ld      (hl),b
  49+ 8801 C9                                   ret
  50+ 8802
  51+ 8802              ; Clears all except slot A, used when say restarting a space station post launch
  52+ 8802 57           ClearFreeSlotListSaveA: ld      d,a
  53+ 8803 0E 00                                ld      c,0
  54+ 8805 21 2C 85                             ld      hl,UniverseSlotList
  55+ 8808 06 18                                ld      b, UniverseSlotListSize * 2
  56+ 880A 79           .fillLoop:              ld      a,c
  57+ 880B BA                                   cp      d
  58+ 880C 28 03                                jr      z,.SkipSlot
  59+ 880E 3E FF                                ld      a,$FF
  60+ 8810 77                                   ld      (hl),a
  61+ 8811 23           .SkipSlot:              inc     hl
  62+ 8812 23                                   inc     hl
  63+ 8813 10 F5                                djnz    .fillLoop
  64+ 8815 C9                                   ret
  65+ 8816
  66+ 8816 21 2C 85     ClearSlotA:             ld      hl,UniverseSlotList
  67+ 8819 ED 31                                add     hl,a
  68+ 881B 36 FF                                ld      (hl),$FF
  69+ 881D 3E 0C                                ld      a,UniverseSlotListSize  ; move to types
  70+ 881F ED 31                                add     hl,a
  71+ 8821 36 FF                                ld      (hl),$FF
  72+ 8823 C9                                   ret
  73+ 8824              ; Space Station will always be slot 0
  74+ 8824
  75+ 8824 21 39 85     AreShipsPresent:        ld      hl,UniverseSlotType+1
  76+ 8827 06 0B                                ld      b,UniverseSlotListSize -1      ; ignore space station
  77+ 8829 7E           .NextShip:              ld      a,(hl)
  78+ 882A FE 00                                cp      ShipTypeNormal
  79+ 882C                                      ClearCarryFlag
  79+ 882C B7          >                        or a
  80+ 882D C8                                   ret     z
  81+ 882E 23                                   inc     hl
  82+ 882F 10 F8                                djnz    .NextShip
  83+ 8831                                      SetCarryFlag
  83+ 8831 37          >                        scf
  84+ 8832 C9                                   ret
  85+ 8833
  86+ 8833 21 2C 85     IsSpaceStationPresent:  ld      hl,UniverseSlotList
  87+ 8836                                      ClearCarryFlag
  87+ 8836 B7          >                        or a
  88+ 8837 7E           .SearchLoop:            ld      a,(hl)
  89+ 8838                                      ReturnIfAEqNusng ShipTypeStation
  89+ 8838 FE 02       >                        cp      ShipTypeStation
  89+ 883A C8          >                        ret     z
  90+ 883B                                      SetCarryFlag
  90+ 883B 37          >                        scf
  91+ 883C C9                                   ret
  92+ 883D
  93+ 883D 21 2C 85     GetTypeAtSlotA:         ld      hl,UniverseSlotList
  94+ 8840 ED 31                                add     hl,a
  95+ 8842 7E                                   ld      a,(hl)
  96+ 8843 C9                                   ret
  97+ 8844
  98+ 8844 21 2D 85     IsPlanetOrSpaceStation: ld      hl,UniverseSlotList+1
  99+ 8847 7E                                   ld      a,(hl)
 100+ 8848 C9                                   ret
 101+ 8849
 102+ 8849 21 2C 85     FindNextFreeSlotInC:    ld      hl,UniverseSlotList
 103+ 884C 06 0C                                ld      b, UniverseSlotListSize
 104+ 884E 0E 00                                ld      c, 0
 105+ 8850 7E           .SearchLoop:            ld      a,(hl)
 106+ 8851                                      JumpIfAEqNusng $FF, .FoundSlot
 106+ 8851 FE FF       >                        cp     $FF
 106+ 8853 CA 5C 88    >                        jp      z,.FoundSlot
 107+ 8856 0C                                   inc     c
 108+ 8857 23                                   inc     hl
 109+ 8858 10 F6                                djnz    .SearchLoop
 110+ 885A                                      SetCarryFlag
 110+ 885A 37          >                        scf
 111+ 885B C9                                   ret
 112+ 885C              .FoundSlot:             ClearCarryFlag
 112+ 885C B7          >                        or a
 113+ 885D C9                                   ret
 114+ 885E
 115+ 885E
 116+ 885E CD 49 88     FindNextFreeSlotInA:    call    FindNextFreeSlotInC
 117+ 8861 79                                   ld      a,c
 118+ 8862 C9                                   ret
 119+ 8863
# file closed: ./Variables/UniverseSlotRoutines.asm
 110  8863                  INCLUDE "./Variables/EquipmentVariables.asm"
# file opened: ./Variables/EquipmentVariables.asm
   1+ 8863 00           AutoDocking				DB	0				; $033F
   2+ 8864 00           PlayerECM				DB	0				; $0340
   3+ 8865 00           Laser2					DB	0				; 0343 laser Power? Not sure
   4+ 8866 00           LaserCount				DB	0				; 0346  LASCT  \ laser count =9 for pulse, cooled off?
   5+ 8867 00 00 00 00  Cash					DB  0,0,0,0			; 0361 - 0364 Cash now litte endian
   6+ 886B 19           Fuel					DB	25				; 0365  QQ14
   7+ 886C 46           CargoBaySize			DB	70				; 036E
   8+ 886D 00           CargoRunningLoad        DB  0
   9+ 886E 00 00 00 00  CargoTonnes             DB  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   9+ 8872 00 00 00 00
   9+ 8876 00 00 00 00
   9+ 887A 00 00 00 00
  10+ 887E              ;CargoTonnes		    DB	16,1,2,3,4,5,6,7,6,9,10,11,12,13,14,15			; 036F - 037F	QQ20
  11+ 887E              SlaveCargoTonnes		equ CargoTonnes+3
  12+ 887E              NarcoticsCargoTonnes	equ CargoTonnes+6
  13+ 887E              FirearmsCargoTonnes		equ CargoTonnes+10
  14+ 887E              ; For each view laser a localised copy of the stats
  15+ 887E              ; TODO - need to add code to maintain on load/save/equipment transactions
  16+ 887E 00 00 00 00  LaserType               DS  4               ; quick reference to laser type
  17+ 8882 00 00 00 00  LaserDamagedFlag        DS  4               ; probabiliy out of 255 that it will no fire, 0 = good, 255 = will not fire
  18+ 8886              ; dont need as static from table LaserPulseRate          DS  4               ; how many pulses can be fired before long pause
  19+ 8886              ; dont need as static from table LaserPulsePause         DS  4               ; time before next pulse - 0 = beam
  20+ 8886              ; dont need as static from table LaserPulseRest          DS  4               ; time before pulse count resets to 0
  21+ 8886              ; dont need as static from table LaserDamageOutput       DS  4               ; amount of damage for a laser hit
  22+ 8886              ; dont need as static from table LaserEnergyDrain        DS  4               ; amount of energy drained by cycle
  23+ 8886              ; dont need as static from table LaserHeat               DS  4               ; amount of heat generated
  24+ 8886              ; dont need as static from table LaserDurability         DS  4               ; probabability out of 255 that a hit on it unshielded will add random amount of damage
  25+ 8886              ; dont need as static from table LaserDurabilityAmount   DS  4               ; max amount of damagage can be sustained in one damage hit
  26+ 8886
  27+ 8886
  28+ 8886              QQ20                    equ CargoTonnes
  29+ 8886 00 00 00...  EquipmentFitted         DS  EQ_ITEM_COUNT    ; Series of flags for if each item is fitted
  30+ 88A0              ECMPresent				EQU EquipmentFitted + EQ_ECM				; 0380
  31+ 88A0              EnergyBomb				EQU EquipmentFitted + EQ_ENERGY_BOMB		; 0382	Also random hyperspeace in Elite A
  32+ 88A0              ExtraEnergyUnit			EQU EquipmentFitted + EQ_ENERGY_UNIT        ; 0383
  33+ 88A0              DockingComputer 		EQU EquipmentFitted + EQ_DOCK_COMP    		; 0384
  34+ 88A0              GalacticHyperDrive		EQU EquipmentFitted + EQ_GAL_DRIVE   		; 0385
  35+ 88A0              EscapePod				EQU EquipmentFitted + EQ_ESCAPE_POD  		; 0386
  36+ 88A0 01           FuelScoopsBarrelStatus	DB	1				; 0381
  37+ 88A1
# file closed: ./Variables/EquipmentVariables.asm
 111  88A1                  INCLUDE "./Variables/random_number.asm"
# file opened: ./Variables/random_number.asm
   1+ 88A1              doRandom2:									; .DORND2	\ -> &3F85 \ Restricted for explosion dust.
   2+ 88A1              doRND2:
   3+ 88A1 A7           	and		a								; fast clear carry  leave bit0 of RAND+2 at 0.
   4+ 88A2              doRandom:									;.DORND	\ -> &3F86 \ do random, new A, X.
   5+ 88A2              ; "doRandom, Random Seed update, new value in A & B)"
   6+ 88A2 3A 51 83     doRND:                  ld		a,(RandomSeed)					; Get Seed 0
   7+ 88A5 CB 17                                rl		a								; Rotate L including carry
   8+ 88A7 4F                                   ld		c,a								; c =  double lo
   9+ 88A8 21 53 83     .AddSeed2:              ld		hl,RandomSeed2
  10+ 88AB 8E                                   adc		a,(hl)							; RAND+2
  11+ 88AC 32 51 83     .SaveAtoSeed:           ld		(RandomSeed),a					; and save RAND
  12+ 88AF 08           .SaveBtoSeed2:          ex		af,af'
  13+ 88B0 79                                   ld		a,c
  14+ 88B1 32 53 83                             ld		(RandomSeed2),a
  15+ 88B4 08                                   ex		af,af'
  16+ 88B5 3A 52 83                             ld		a,(RandomSeed1)
  17+ 88B8 4F                                   ld		c,a								; C = Seed1
  18+ 88B9 21 54 83     .AddSeed3:              ld		hl,RandomSeed3
  19+ 88BC 8E                                   adc		a,(hl)
  20+ 88BD 32 52 83                             ld		(RandomSeed1),a
  21+ 88C0 08                                   ex		af,af'
  22+ 88C1 79                                   ld		a,c
  23+ 88C2 32 54 83                             ld		(RandomSeed3),a
  24+ 88C5 08                                   ex		af,af'
  25+ 88C6 C9                                   ret
  26+ 88C7
# file closed: ./Variables/random_number.asm
 112  88C7                  INCLUDE "./Variables/galaxy_seed.asm"
# file opened: ./Variables/galaxy_seed.asm
   1+ 88C7 47 41 4C 41  GALAXYSEED DB "GALAXYSEED"
   1+ 88CB 58 59 53 45
   1+ 88CF 45 44
   2+ 88D1 21 5D 85     copy_galaxy_to_system:  ld		hl,GalaxySeeds
   3+ 88D4 11 47 84                             ld		de,SystemSeed
   4+ 88D7 ED A0        copy_seed:		        ldi
   5+ 88D9 ED A0                                ldi
   6+ 88DB ED A0                                ldi
   7+ 88DD ED A0                                ldi
   8+ 88DF ED A0                                ldi
   9+ 88E1 ED A0                                ldi
  10+ 88E3 C9                                   ret
  11+ 88E4
  12+ 88E4 21 47 84     copy_system_to_galaxy:  ld		hl,SystemSeed
  13+ 88E7 11 5D 85                             ld		de,GalaxySeeds
  14+ 88EA 18 EB                                jr		copy_seed
  15+ 88EC
  16+ 88EC 21 5D 85     copy_galaxy_to_working: ld		hl,GalaxySeeds
  17+ 88EF 11 51 85                             ld		de,WorkingSeeds
  18+ 88F2 18 E3                                jr		copy_seed
  19+ 88F4
  20+ 88F4 21 51 85     copy_working_to_galaxy: ld		hl,WorkingSeeds
  21+ 88F7 11 5D 85                             ld		de,GalaxySeeds
  22+ 88FA 18 DB                                jr		copy_seed
  23+ 88FC
  24+ 88FC 21 51 85     copy_working_to_system: ld		hl,WorkingSeeds
  25+ 88FF 11 47 84                             ld		de,SystemSeed
  26+ 8902 18 D3                                jr		copy_seed
  27+ 8904
  28+ 8904 21 47 84     copy_system_to_working: ld		hl,SystemSeed
  29+ 8907 11 51 85                             ld		de,WorkingSeeds
  30+ 890A 18 CB                                jr		copy_seed
  31+ 890C
  32+ 890C              next_system_seed:							;.TT20	\ -> &2B0E  \ TWIST on QQ15 to next system
  33+ 890C CD 0F 89     		call	.NextStep					; This logic means we hard code x4
  34+ 890F              .NextStep:
  35+ 890F CD 12 89     		call	process_seed				; This logic means we hard code x2
  36+ 8912              process_seed:								; TT54	\ -> &2637 \ Twist seed for next digram in QQ15
  37+ 8912 3A 47 84     		ld		a,(SystemSeed)				; QQ15
  38+ 8915 B7           		or		a							; clear carry flag
  39+ 8916 21 49 84     		ld		hl,SystemSeed+2				; hl -> qq+2
  40+ 8919 86           		add		a,(hl)						; a= QQ15 + QQ152
  41+ 891A 47           		ld		b,a							; partial sum lo
  42+ 891B 3A 48 84     		ld		a,(SystemSeed+1)
  43+ 891E 21 4A 84     		ld		hl,SystemSeed+3				; HL -> QQ+3 )we don't inc as it affects carry)
  44+ 8921 8E           		adc		a,(hl)						; note add with carry
  45+ 8922 4F           		ld		c,a  						; c = QQ1+QQ3+carry bit parial sum hi
  46+ 8923 3A 49 84     		ld		a,(SystemSeed+2)
  47+ 8926 32 47 84     		ld		(SystemSeed+0),a			; copy qq152 to qq150
  48+ 8929 3A 4A 84     		ld		a,(SystemSeed+3)
  49+ 892C 32 48 84     		ld		(SystemSeed+1),a			; copy qq153 to qq151
  50+ 892F 3A 4C 84     		ld		a,(SystemSeed+5)
  51+ 8932 32 4A 84     		ld		(SystemSeed+3),a			; copy qq155 to qq153
  52+ 8935 3A 4B 84     		ld		a,(SystemSeed+4)
  53+ 8938 32 49 84     		ld		(SystemSeed+2),a			; copy qq154 to qq152
  54+ 893B B7           		or		a
  55+ 893C 78           		ld		a,b
  56+ 893D 21 49 84     		ld		hl,SystemSeed+2				; hl -> qq+2
  57+ 8940 86           		add	    a,(hl)
  58+ 8941 32 4B 84     		ld		(SystemSeed+4),a
  59+ 8944 79           		ld		a,c
  60+ 8945 21 4A 84     		ld		hl,SystemSeed+3				; HL -> QQ+3 )we don't inc as it affects carry)
  61+ 8948 8E           		adc		a,(hl)
  62+ 8949 32 4C 84     		ld		(SystemSeed+5),a
  63+ 894C C9           		ret
  64+ 894D
  65+ 894D              next_working_seed:							;.TT20	\ -> &2B0E  \ TWIST on QQ15 to next system
  66+ 894D CD 50 89     		call	.NextStep					; This logic means we hard code x4
  67+ 8950              .NextStep:
  68+ 8950 CD 53 89     		call	working_seed				; This logic means we hard code x2
  69+ 8953              working_seed:								; TT54	\ -> &2637 \ Twist seed for next digram in QQ15
  70+ 8953              ; x = a + c
  71+ 8953 3A 51 85     		ld		a,(WorkingSeeds)			; QQ15
  72+ 8956 B7           		or		a							; clear carry flag
  73+ 8957 21 53 85     		ld		hl,WorkingSeeds+2			; hl -> qq+2 [c]
  74+ 895A 86           		add		a,(hl)						; a= QQ15 [a]+ QQ15 [c]
  75+ 895B 47           		ld		b,a							; partial sum lo [x]
  76+ 895C              ; y = b + d	+ carry
  77+ 895C 3A 52 85     		ld		a,(WorkingSeeds+1)          ; [b]
  78+ 895F 21 54 85     		ld		hl,WorkingSeeds+3			; HL -> QQ+3 [d] we don't inc as it affects carry)
  79+ 8962 8E           		adc		a,(hl)						; note add with carry
  80+ 8963 4F           		ld		c,a  						; c = QQ1+QQ3+carry bit parial sum hi
  81+ 8964 3A 53 85     		ld		a,(WorkingSeeds+2)
  82+ 8967 32 51 85     		ld		(WorkingSeeds+0),a			; copy qq152 to qq150 [a] = [c]
  83+ 896A 3A 54 85     		ld		a,(WorkingSeeds+3)
  84+ 896D 32 52 85     		ld		(WorkingSeeds+1),a			; copy qq153 to qq151 [b] = [d]
  85+ 8970 3A 56 85     		ld		a,(WorkingSeeds+5)
  86+ 8973 32 54 85     		ld		(WorkingSeeds+3),a			; copy qq155 to qq153 [d] = [f]
  87+ 8976 3A 55 85     		ld		a,(WorkingSeeds+4)
  88+ 8979 32 53 85     		ld		(WorkingSeeds+2),a			; copy qq154 to qq152 [c] = [e]
  89+ 897C B7           		or		a
  90+ 897D 78           		ld		a,b
  91+ 897E 21 53 85     		ld		hl,WorkingSeeds+2		    ; hl -> qq+2
  92+ 8981 86           		add	    a,(hl)
  93+ 8982 32 55 85     		ld		(WorkingSeeds+4),a			; e = x + [c]
  94+ 8985 79           		ld		a,c
  95+ 8986 21 54 85     		ld		hl,WorkingSeeds+3			; HL -> QQ+3 )we don't inc as it affects carry)
  96+ 8989 8E           		adc		a,(hl)
  97+ 898A 32 56 85     		ld		(WorkingSeeds+5),a			; f = y + [d] + carry
  98+ 898D C9           		ret
  99+ 898E
 100+ 898E 32           working_distX	DB 50
 101+ 898F 32           working_distY	DB 50
 102+ 8990 00           current_distY	DB 0
 103+ 8991
 104+ 8991 AF           find_present_system:    xor		a
 105+ 8992 32 60 84                             ld		(XSAV),a
 106+ 8995 3A 48 84     .CounterLoop:           ld		a,(SystemSeed+1)				; QQ15+1 \ seed Ycoord of star
 107+ 8998 4F                                   ld		c,a
 108+ 8999 3A 64 85     .calcLocaldy:           ld		a,(PresentSystemY)
 109+ 899C 47                                   ld		b,a								; so b holds Y ccord
 110+ 899D 79                                   ld		a,c
 111+ 899E 90                                   sub		b
 112+ 899F CB 7F                                bit		7,a
 113+ 89A1 28 02                                jr		z,.positivedy
 114+ 89A3 ED 44        .negativedy:            neg
 115+ 89A5 32 90 89     .positivedy:            ld		(current_distY),a				; save cuirrent_dist Y as we need it maybe
 116+ 89A8 ED 5B 8E 89                          ld		de,(working_distX)
 117+ 89AC BA                                   cp		d
 118+ 89AD 30 24                                jr		nc,.toofar
 119+ 89AF 3A 4A 84     .calcLocaldx:           ld		a,(SystemSeed+3)				; QQ15+3 \ seed Xcoord of star
 120+ 89B2 4F                                   ld		c,a
 121+ 89B3 3A 63 85                             ld		a,(PresentSystemX)
 122+ 89B6 47                                   ld		b,a								; so b holds Y ccord
 123+ 89B7 79                                   ld		a,c
 124+ 89B8 90                                   sub		b
 125+ 89B9 CB 7F                                bit		7,a
 126+ 89BB 28 02                                jr		z,.positivedx
 127+ 89BD ED 44        .negativedx:            neg
 128+ 89BF 4F           .positivedx:            ld		c,a
 129+ 89C0 BB                                   cp		e
 130+ 89C1 30 10                                jr		nc,.toofar
 131+ 89C3 3A 90 89     .Nearer:			    ld		a,(current_distY) 				; we have a closer system
 132+ 89C6 47                                   ld		b,a								; we have c to recall Y into b
 133+ 89C7 ED 43 8E 89                          ld		(working_distX),bc
 134+ 89CB C5                                   push	bc
 135+ 89CC CD 04 89                             call 	copy_system_to_working
 136+ 89CF C1                                   pop		bc
 137+ 89D0 78                                   ld		a,b								;
 138+ 89D1 B1                                   or		c								;
 139+ 89D2 C8                                   ret		z								; if we have distance 0 then bang on
 140+ 89D3 CD 0C 89     .toofar:                call	next_system_seed
 141+ 89D6 3A 60 84                             ld		a,(XSAV)
 142+ 89D9 3D                                   dec		a
 143+ 89DA FE 00                                cp		0
 144+ 89DC C8                                   ret		z
 145+ 89DD 32 60 84                             ld		(XSAV),a
 146+ 89E0 18 B3                                jr		.CounterLoop
 147+ 89E2
 148+ 89E2              get_planet_data_working_seed:
 149+ 89E2 3A 52 85     		ld		a, (WorkingSeeds+1)
 150+ 89E5 E6 07        		and		7
 151+ 89E7 32 E5 84     		ld		(DisplayEcononmy),a
 152+ 89EA 3A 53 85     		ld		a, (WorkingSeeds+2)
 153+ 89ED CB 3F        		srl	a
 154+ 89EF CB 3F        		srl	a
 155+ 89F1 CB 3F        		srl	a
 156+ 89F3 CB 3F        		srl	a								; c/8
 157+ 89F5 E6 07        		and		7
 158+ 89F7 32 E6 84     		ld		(DisplayGovernment),a
 159+ 89FA CB 3F        		srl	a
 160+ 89FC FE 00        		cp		0
 161+ 89FE 20 08        		jr		nz,.CanBeRich
 162+ 8A00              .Fedual:
 163+ 8A00 3A E5 84     		ld		a,(DisplayEcononmy)
 164+ 8A03 F6 02        		or		2							; Adjust Eco for Anarchy and Feudal, set bit 1.
 165+ 8A05 32 E5 84     		ld		(DisplayEcononmy),a
 166+ 8A08              .CanBeRich:
 167+ 8A08 3A E5 84     		ld		a,(DisplayEcononmy)
 168+ 8A0B EE 07        		xor		7							; flip economy so Rich is now 7
 169+ 8A0D 32 E7 84     		ld		(DisplayTekLevel),a			; Flipped Eco, EcoEOR7, Rich Ind = 7
 170+ 8A10 47           		ld		b,a
 171+ 8A11 3A 54 85     		ld		a,(WorkingSeeds+3)
 172+ 8A14 E6 03        		and		3
 173+ 8A16 80           		add		a,b
 174+ 8A17 32 E7 84     		ld		(DisplayTekLevel),a			; Tek Level += seed d & 3
 175+ 8A1A 3A E6 84     		ld		a,(DisplayGovernment)		; Government, 0 is Anarchy
 176+ 8A1D CB 3F        		srl		a 							; gov/2
 177+ 8A1F 47           		ld		b,a
 178+ 8A20 3A E7 84     		ld		a,(DisplayTekLevel)
 179+ 8A23 80           		add		a,b
 180+ 8A24 32 E7 84     		ld		(DisplayTekLevel),a			; Tek += gov /2
 181+ 8A27 CB 27        		sla		a
 182+ 8A29 CB 27        		sla		a							; Onto Population (TL-1)*= 4
 183+ 8A2B 47           		ld		b,a
 184+ 8A2C 3A E5 84     		ld		a,(DisplayEcononmy)
 185+ 8A2F 80           		add		a,b                  		; TechLevel*4 + Eco   7-56
 186+ 8A30 47           		ld		b,a
 187+ 8A31 3A E6 84     		ld		a,(DisplayGovernment)
 188+ 8A34 3C           		inc		a  							; +Government, 0 is Anarchy + 1
 189+ 8A35 32 E8 84     		ld		(DisplayPopulation),a
 190+ 8A38 3A E5 84     		ld		a,(DisplayEcononmy)
 191+ 8A3B EE 07        		xor		7							; Onto productivity
 192+ 8A3D C6 03        		add		3							;  (Flipped eco +3)
 193+ 8A3F 57           		ld		d,a
 194+ 8A40 3A E6 84     		ld		a,(DisplayGovernment)		; Government, 0 is Anarchy
 195+ 8A43 C6 04        		add		4
 196+ 8A45 5F           		ld		e,a
 197+ 8A46 ED 30        		mul									; ; DE = d*e, Productivity part 1. has hsb in A, lsb in P.
 198+ 8A48 3A E8 84     		ld		a,(DisplayPopulation)		; then we use d for radius
 199+ 8A4B 57           		ld		d,a
 200+ 8A4C ED 30        		mul
 201+ 8A4E CB 23        		sla		e
 202+ 8A50 CB 1A        		rr		d
 203+ 8A52 CB 23        		sla		e
 204+ 8A54 CB 1A        		rr		d
 205+ 8A56 CB 23        		sla		e
 206+ 8A58 CB 1A        		rr		d							; de * 8
 207+ 8A5A ED 53 EA 84  		ld		(DisplayProductivity),de
 208+ 8A5E              .DoRadius:
 209+ 8A5E 3A 54 85     		ld		a,(WorkingSeeds+3)
 210+ 8A61 4F           		ld		c,a
 211+ 8A62 3A 56 85     		ld		a,(WorkingSeeds+5)
 212+ 8A65 E6 0F        		and		$0F							;  lower 4 bits of w2_h determine planet radius
 213+ 8A67 C6 0B        		add		11							;  radius min = 256*11 = 2816 km
 214+ 8A69 47           		ld		b,a							;
 215+ 8A6A ED 43 EE 84  		ld		(DisplayRadius),bc
 216+ 8A6E C9           		ret
 217+ 8A6F
# file closed: ./Variables/galaxy_seed.asm
 113  8A6F                  INCLUDE "./Tables/text_tables.asm"
# file opened: ./Tables/text_tables.asm
   1+ 8A6F 50 75 6C 73  StatusLaserName1	DB	"Pulse",0
   1+ 8A73 65 00
   2+ 8A75 42 65 61 6D  StatusLaserName2	DB	"Beam",0
   2+ 8A79 00
   3+ 8A7A 4D 69 6C 69  StatusLaserName3    DB  "Military",0
   3+ 8A7E 74 61 72 79
   3+ 8A82 00
   4+ 8A83 4D 69 6E 69  StatusLaserName4    DB  "Mining",0
   4+ 8A87 6E 67 00
   5+ 8A8A 43 75 73 74  StatusLaserName5    DB  "Custom",0
   5+ 8A8E 6F 6D 00
   6+ 8A91
   7+ 8A91 6F 8A 75 8A  StatusLaserNameIdx	DW	StatusLaserName1,StatusLaserName2,StatusLaserName3,StatusLaserName4,StatusLaserName5
   7+ 8A95 7A 8A 83 8A
   7+ 8A99 8A 8A
   8+ 8A9B              StatusLaserNameIdxLen EQU $ - StatusLaserNameIdx
   9+ 8A9B
  10+ 8A9B 44 6F 63 6B  ConditionName1		DB "Docked",0
  10+ 8A9F 65 64 00
  11+ 8AA2 47 72 65 65  ConditionName2		DB "Green",0
  11+ 8AA6 6E 00
  12+ 8AA8 59 65 6C 6C  ConditionName3		DB "Yellow",0
  12+ 8AAC 6F 77 00
  13+ 8AAF 52 65 64 00  ConditionName4		DB "Red",0
  14+ 8AB3
  15+ 8AB3 9B 8A A2 8A  ConditionNameIdx	DW ConditionName1,ConditionName2,ConditionName3,ConditionName4
  15+ 8AB7 A8 8A AF 8A
  16+ 8ABB              ConditionNameIdxLen EQU $ - ConditionNameIdx
  17+ 8ABB
  18+ 8ABB 41 42 4F 55  StatusDiagrams		DB "ABOUSEITILETSTONLONUTHNOALLEXEGEZACEBISOUSESARMAINDIREA?ERATENBERALAVETIEDORQUANTEISRION",0
  18+ 8ABF 53 45 49 54
  18+ 8AC3 49 4C 45 54
  18+ 8AC7 53 54 4F 4E
  18+ 8ACB 4C 4F 4E 55
  18+ 8ACF 54 48 4E 4F
  18+ 8AD3 41 4C 4C 45
  18+ 8AD7 58 45 47 45
  18+ 8ADB 5A 41 43 45
  18+ 8ADF 42 49 53 4F
  18+ 8AE3 55 53 45 53
  18+ 8AE7 41 52 4D 41
  18+ 8AEB 49 4E 44 49
  18+ 8AEF 52 45 41 3F
  18+ 8AF3 45 52 41 54
  18+ 8AF7 45 4E 42 45
  18+ 8AFB 52 41 4C 41
  18+ 8AFF 56 45 54 49
  18+ 8B03 45 44 4F 52
  18+ 8B07 51 55 41 4E
  18+ 8B0B 54 45 49 53
  18+ 8B0F 52 49 4F 4E
  18+ 8B13 00
  19+ 8B14
  20+ 8B14 00 00 08 00  RankingTable		DW	$0000,$0008,$0010,$0020,$0040,$0080,$0200,$0A00,$1900,$4900,$FFFF
  20+ 8B18 10 00 20 00
  20+ 8B1C 40 00 80 00
  20+ 8B20 00 02 00 0A
  20+ 8B24 00 19 00 49
  20+ 8B28 FF FF
  21+ 8B2A
  22+ 8B2A 48 61 72 6D  RankingName1		DB 	"Harmless",0
  22+ 8B2E 6C 65 73 73
  22+ 8B32 00
  23+ 8B33 4D 6F 73 74  RankingName2		DB 	"Mostly Harmless",0
  23+ 8B37 6C 79 20 48
  23+ 8B3B 61 72 6D 6C
  23+ 8B3F 65 73 73 00
  24+ 8B43 50 6F 6F 72  RankingName3		DB 	"Poor",0
  24+ 8B47 00
  25+ 8B48 41 76 65 72  RankingName4		DB 	"Average",0
  25+ 8B4C 61 67 65 00
  26+ 8B50 41 62 6F 76  RankingName5		DB 	"Above Average",0
  26+ 8B54 65 20 41 76
  26+ 8B58 65 72 61 67
  26+ 8B5C 65 00
  27+ 8B5E 43 6F 6D 70  RankingName6		DB 	"Competent",0
  27+ 8B62 65 74 65 6E
  27+ 8B66 74 00
  28+ 8B68 44 61 6E 67  RankingName7		DB 	"Dangerous",0
  28+ 8B6C 65 72 6F 75
  28+ 8B70 73 00
  29+ 8B72 44 65 61 64  RankingName8		DB 	"Deadly",0
  29+ 8B76 6C 79 00
  30+ 8B79 2D 2D 2D 2D  RankingName9		DB 	"---- E L I T E ---",0
  30+ 8B7D 20 45 20 4C
  30+ 8B81 20 49 20 54
  30+ 8B85 20 45 20 2D
  30+ 8B89 2D 2D 00
  31+ 8B8C 53 6B 6F 6C  RankingName10		DB 	"Skollobsgod",0
  31+ 8B90 6C 6F 62 73
  31+ 8B94 67 6F 64 00
  32+ 8B98 4E 75 74 74  RankingName11		DB 	"Nutter",0
  32+ 8B9C 65 72 00
  33+ 8B9F
  34+ 8B9F 2A 8B 33 8B  RankingNameIdx		dw RankingName1,RankingName2,RankingName3,RankingName4,RankingName5,RankingName6,RankingName7,RankingName8,RankingName9,RankingName10,RankingName11
  34+ 8BA3 43 8B 48 8B
  34+ 8BA7 50 8B 5E 8B
  34+ 8BAB 68 8B 72 8B
  34+ 8BAF 79 8B 8C 8B
  34+ 8BB3 98 8B
  35+ 8BB5              RankingNameIdxLen EQU $ - RankingNameIdx
  36+ 8BB5
  37+ 8BB5
  38+ 8BB5              getTableText:
  39+ 8BB5              ; ">getTableText, hl = indexlist, a = textnbr, returns with hl = porinter to head of text"
  40+ 8BB5              ; ">Note for ranking first 2 bytes are target rank"
  41+ 8BB5 D5           	push	de								; save DE as we will likley need it in caller
  42+ 8BB6 ED 31        	add		hl,a							; 0 based ref, and its 2 bytes
  43+ 8BB8 ED 31        	add		hl,a
  44+ 8BBA 5E           	ld		e,(hl)
  45+ 8BBB 23           	inc		hl
  46+ 8BBC 56           	ld		d,(hl)							; de = indexed address
  47+ 8BBD EB           	ex		de,hl							; flip it to hl
  48+ 8BBE D1           	pop		de								; retrieve de
  49+ 8BBF C9           	ret										; return with hl as start entry
  50+ 8BC0
  51+ 8BC0
  52+ 8BC0              ;               CF      ZF      Result
  53+ 8BC0              ;               -----------------------------------
  54+ 8BC0              ;               0       0       HL > DE
  55+ 8BC0              ;               0       1       HL == DE
  56+ 8BC0              ;               1       0       HL < DE
  57+ 8BC0              ;               1       1       Impossible
  58+ 8BC0              getRankIndex:
  59+ 8BC0              ; ">getRank, de = kill count, returns a = index,hl destroyed"
  60+ 8BC0              ; ">Note for ranking first 2 bytes are target rank"
  61+ 8BC0 7A           	ld		a,d
  62+ 8BC1 B3           	or		e
  63+ 8BC2 FE 00        	cp		0
  64+ 8BC4 C8           	ret		z								; quicks skip for 0 kills
  65+ 8BC5 AF           	xor 	a
  66+ 8BC6 21 14 8B     	ld		hl,RankingTable
  67+ 8BC9              .testLoop:
  68+ 8BC9 4E           	ld		c,(hl)
  69+ 8BCA 23           	inc		hl
  70+ 8BCB 46           	ld		b,(hl)							; bc = ranking
  71+ 8BCC E5           	push	hl
  72+ 8BCD 60           	ld		h,b
  73+ 8BCE 69           	ld		l,c
  74+ 8BCF CD 4A 97     	call	compare16HLDE
  75+ 8BD2 38 06        	jr		c,.HLLTDE
  76+ 8BD4              .HLGTEDE									; Found the correct rank
  77+ 8BD4 E1           	pop		hl
  78+ 8BD5 23           	inc		hl								; move to next value
  79+ 8BD6 23           	inc		hl
  80+ 8BD7 3C           	inc		a								; we canloop forever as if kills was $FFFF then hits nutter rank but also +1 = 0000 as its 16 bit
  81+ 8BD8 18 EF        	jr		.testLoop
  82+ 8BDA              .HLLTDE:									; HL < Kills so found correct rank
  83+ 8BDA E1           	pop		hl
  84+ 8BDB C9           	ret
  85+ 8BDC
# file closed: ./Tables/text_tables.asm
 114  8BDC                  INCLUDE "./Tables/dictionary.asm"
# file opened: ./Tables/dictionary.asm
   1+ 8BDC 58 00        WordDummy					DB  "X",0
   2+ 8BDE 46 72 6F 6E  WordFront					DB	"Front",0              ;1
   2+ 8BE2 74 00
   3+ 8BE4 52 69 67 68  WordRight					DB	"Right",0              ;2
   3+ 8BE8 74 00
   4+ 8BEA 4C 65 66 74  WordLeft 					DB	"Left",0               ;3
   4+ 8BEE 00
   5+ 8BEF 52 65 61 72  WordRear   	 				DB	"Rear",0               ;4
   5+ 8BF3 00
   6+ 8BF4 4C 61 72 67  WordLarge           		DB  "Large",0              ;5
   6+ 8BF8 65 00
   7+ 8BFA 45 73 63 61  WordEscape          		DB  "Escape",0             ;6
   7+ 8BFE 70 65 00
   8+ 8C01 50 6F 64 00  WordPod             		DB  "Pod",0                ;7
   9+ 8C05 43 61 72 67  WordCargo           		DB  "Cargo",0              ;8
   9+ 8C09 6F 00
  10+ 8C0B 42 61 79 00  WordBay             		DB  "Bay",0                ;9
  11+ 8C0F 46 75 65 6C  WordFuel            		DB  "Fuel",0               ;10
  11+ 8C13 00
  12+ 8C14 53 63 6F 6F  WordScoops          		DB  "Scoops",0             ;11
  12+ 8C18 70 73 00
  13+ 8C1B 45 2E 43 2E  WordECM             		DB  "E.C.M.",0             ;12
  13+ 8C1F 4D 2E 00
  14+ 8C22 53 79 73 74  WordSystem          		DB  "System",0             ;13
  14+ 8C26 65 6D 00
  15+ 8C29 45 6E 65 72  WordEnergy					DB  "Energy",0             ;14
  15+ 8C2D 67 79 00
  16+ 8C30 42 6F 6D 62  WordBomb					DB  "Bomb",0               ;15
  16+ 8C34 00
  17+ 8C35 4C 61 73 65  WordLaser					DB  "Laser",0              ;16
  17+ 8C39 72 00
  18+ 8C3B 50 75 6C 73  WordPulse           		DB  "Pulse",0              ;17
  18+ 8C3F 65 00
  19+ 8C41 42 65 61 6D  WordBeam            		DB  "Beam",0               ;18
  19+ 8C45 00
  20+ 8C46 4D 69 6C 69  WordMiliary         		DB  "Miliary",0            ;19
  20+ 8C4A 61 72 79 00
  21+ 8C4E 4D 69 6E 69  WordMining          		DB  "Mining",0             ;20
  21+ 8C52 6E 67 00
  22+ 8C55 43 75 73 74  WordCustom          		DB  "Custom",0             ;21
  22+ 8C59 6F 6D 00
  23+ 8C5C 55 6E 69 74  WordUnit            		DB  "Unit",0               ;22
  23+ 8C60 00
  24+ 8C61 53 68 69 65  WordShield          		DB  "Shield",0             ;23
  24+ 8C65 6C 64 00
  25+ 8C68 44 6F 63 6B  WordDocking         		DB  "Docking",0            ;24
  25+ 8C6C 69 6E 67 00
  26+ 8C70 43 6F 6D 70  WordComputers       		DB  "Computers",0          ;25
  26+ 8C74 75 74 65 72
  26+ 8C78 73 00
  27+ 8C7A 48 79 70 65  WordHyperspace      		DB  "Hyperspace",0         ;26
  27+ 8C7E 72 73 70 61
  27+ 8C82 63 65 00
  28+ 8C85 47 61 6C 61  WordGalactic        		DB  "Galactic",0           ;27
  28+ 8C89 63 74 69 63
  28+ 8C8D 00
  29+ 8C8E 45 78 74 72  WordExtra           		DB  "Extra",0              ;28
  29+ 8C92 61 00
  30+ 8C94 43 6C 65 61  WordClean           		DB  "Clean",0              ;29
  30+ 8C98 6E 00
  31+ 8C9A 4F 66 66 65  WordOffender        		DB  "Offender",0           ;30
  31+ 8C9E 6E 64 65 72
  31+ 8CA2 00
  32+ 8CA3 46 75 67 69  WordFugitive        		DB  "Fugitive",0           ;31
  32+ 8CA7 74 69 76 65
  32+ 8CAB 00
  33+ 8CAC 46 6F 6F 64  WordFood					DB	"Food",0               ;32
  33+ 8CB0 00
  34+ 8CB1 54 65 78 74  WordTextiles				DB 	"Textiles",0           ;33
  34+ 8CB5 69 6C 65 73
  34+ 8CB9 00
  35+ 8CBA 52 61 64 69  WordRadioactives			DB  "Radioactives",0       ;34
  35+ 8CBE 6F 61 63 74
  35+ 8CC2 69 76 65 73
  35+ 8CC6 00
  36+ 8CC7 53 6C 61 76  WordSlaves					DB  "Slaves",0             ;35
  36+ 8CCB 65 73 00
  37+ 8CCE 4C 69 71 75  WordLiquorWines     		DB  "Liquor/Wines",0       ;36
  37+ 8CD2 6F 72 2F 57
  37+ 8CD6 69 6E 65 73
  37+ 8CDA 00
  38+ 8CDB 4C 75 78 75  WordLuxuries  	    		DB  "Luxuries",0	       ;37
  38+ 8CDF 72 69 65 73
  38+ 8CE3 00
  39+ 8CE4 4E 61 72 63  WordNarcotics  	    		DB  "Narcotics",0	       ;38
  39+ 8CE8 6F 74 69 63
  39+ 8CEC 73 00
  40+ 8CEE 4D 61 63 68  WordMachinery  	    		DB  "Machinery",0	       ;39
  40+ 8CF2 69 6E 65 72
  40+ 8CF6 79 00
  41+ 8CF8 41 6C 6C 6F  WordAlloys  				DB  "Alloys",0		       ;40
  41+ 8CFC 79 73 00
  42+ 8CFF 46 69 72 65  WordFirearms  	    		DB  "Firearms",0	       ;41
  42+ 8D03 61 72 6D 73
  42+ 8D07 00
  43+ 8D08 46 75 72 73  WordFurs  		    		DB  "Furs",0	           ;42
  43+ 8D0C 00
  44+ 8D0D 4D 69 6E 65  WordMinerals  	    		DB  "Minerals",0           ;43
  44+ 8D11 72 61 6C 73
  44+ 8D15 00
  45+ 8D16 47 6F 6C 64  WordGold  		    		DB  "Gold",0	           ;44
  45+ 8D1A 00
  46+ 8D1B 50 6C 61 74  WordPlatinum  	    		DB  "Platinum",0           ;45
  46+ 8D1F 69 6E 75 6D
  46+ 8D23 00
  47+ 8D24 47 65 6D 2D  WordGemStones  				DB  "Gem-Stones",0         ;46
  47+ 8D28 53 74 6F 6E
  47+ 8D2C 65 73 00
  48+ 8D2F 41 6C 69 65  WordAlienItems      		DB  "Alien Items",0        ;47
  48+ 8D33 6E 20 49 74
  48+ 8D37 65 6D 73 00
  49+ 8D3B 54 6F 6E 6E  WordTonnes          		DB  "Tonnes",0             ;48
  49+ 8D3F 65 73 00
  50+ 8D42 4B 69 6C 6F  WordKilograms       		DB  "Kilograms",0          ;49
  50+ 8D46 67 72 61 6D
  50+ 8D4A 73 00
  51+ 8D4C 47 72 61 6D  WordGrams           		DB  "Grams",0			   ;50
  51+ 8D50 73 00
  52+ 8D52 53 68 6F 72  WordShort           		DB  "Short",0			   ;51
  52+ 8D56 74 00
  53+ 8D58 52 61 6E 67  WordRange           		DB  "Range",0			   ;52
  53+ 8D5C 65 00
  54+ 8D5E 43 68 61 72  WordChart	        		DB  "Chart",0			   ;53
  54+ 8D62 74 00
  55+ 8D64 44 61 74 61  WordData					DB	"Data",0			   ;54
  55+ 8D68 00
  56+ 8D69 4F 6E 00     WordOn						DB  "On",0                 ;55
  57+ 8D6C 44 69 73 74  WordDistance        		DB  "Distance",0           ;56
  57+ 8D70 61 6E 63 65
  57+ 8D74 00
  58+ 8D75 45 63 6F 6E  WordEconomy         		DB  "Economy",0            ;57
  58+ 8D79 6F 6D 79 00
  59+ 8D7D 47 6F 76 65  WordGovernment      		DB  "Government",0         ;58
  59+ 8D81 72 6E 6D 65
  59+ 8D85 6E 74 00
  60+ 8D88 54 65 63 68  WordTechLevel       		DB  "TechLevel",0          ;59
  60+ 8D8C 4C 65 76 65
  60+ 8D90 6C 00
  61+ 8D92 50 6F 70 75  WordPopulation      		DB  "Population",0         ;60
  61+ 8D96 6C 61 74 69
  61+ 8D9A 6F 6E 00
  62+ 8D9D 4D 69 6C 6C  WordMillion         		DB  "Million",0            ;61
  62+ 8DA1 69 6F 6E 00
  63+ 8DA5 42 69 6C 6C  WordBillion         		DB  "Billion",0            ;62
  63+ 8DA9 69 6F 6E 00
  64+ 8DAD 47 72 6F 73  WordGross           		DB  "Gross",0              ;63
  64+ 8DB1 73 00
  65+ 8DB3 50 72 6F 64  WordProductivity    		DB  "Productivity",0       ;64
  65+ 8DB7 75 63 74 69
  65+ 8DBB 76 69 74 79
  65+ 8DBF 00
  66+ 8DC0 41 76 65 72  WordAverage         		DB  "Average",0            ;65
  66+ 8DC4 61 67 65 00
  67+ 8DC8 52 61 64 69  WordRadius          		DB  "Radius",0             ;66
  67+ 8DCC 75 73 00
  68+ 8DCF 4B 4D 00     WordKM              		DB  "KM",0                 ;67
  69+ 8DD2 4D 20 43 52  WordMCR             		DB  "M CR",0               ;68
  69+ 8DD6 00
  70+ 8DD7 52 69 63 68  WordRich					DB  "Rich",0               ;69
  70+ 8DDB 00
  71+ 8DDC 41 76 67 00  WordAvg         			DB  "Avg",0            	   ;70
  72+ 8DE0 4D 61 69 6E  WordMainly          		DB  "Mainly",0             ;71
  72+ 8DE4 6C 79 00
  73+ 8DE7 50 6F 6F 72  WordPoor            		DB  "Poor",0               ;72
  73+ 8DEB 00
  74+ 8DEC 49 6E 64 75  WordIndustrial      		DB  "Industrial",0         ;73
  74+ 8DF0 73 74 72 69
  74+ 8DF4 61 6C 00
  75+ 8DF7 41 67 72 69  WordAgricultural    		DB  "Agricultural",0       ;74
  75+ 8DFB 63 75 6C 74
  75+ 8DFF 75 72 61 6C
  75+ 8E03 00
  76+ 8E04 41 6E 61 72  WordAnarchy                 DB  "Anarchy",0            ;75
  76+ 8E08 63 68 79 00
  77+ 8E0C 46 65 75 64  WordFeudal                  DB  "Feudal",0             ;76
  77+ 8E10 61 6C 00
  78+ 8E13 4D 75 6C 74  WordMultiGovernment         DB  "Multi-Government",0   ;77
  78+ 8E17 69 2D 47 6F
  78+ 8E1B 76 65 72 6E
  78+ 8E1F 6D 65 6E 74
  78+ 8E23 00
  79+ 8E24 44 69 63 74  WordDictatorship            DB  "Dictatorship",0       ;78
  79+ 8E28 61 74 6F 72
  79+ 8E2C 73 68 69 70
  79+ 8E30 00
  80+ 8E31 43 6F 6D 6D  WordCommunist               DB  "Communist",0          ;79
  80+ 8E35 75 6E 69 73
  80+ 8E39 74 00
  81+ 8E3B 43 6F 6E 66  WordConfederacy             DB  "Confederacy",0        ;80
  81+ 8E3F 65 64 65 72
  81+ 8E43 61 63 79 00
  82+ 8E47 44 65 6D 6F  WordDemocracy               DB  "Democracy",0          ;81
  82+ 8E4B 63 72 61 63
  82+ 8E4F 79 00
  83+ 8E51 43 6F 72 70  WordCorporate               DB  "Corporate State",0    ;82
  83+ 8E55 6F 72 61 74
  83+ 8E59 65 20 53 74
  83+ 8E5D 61 74 65 00
  84+ 8E61 53 74 61 74  WordState 					DB  "State",0              ;83
  84+ 8E65 65 00
  85+ 8E67 4C 69 67 68  WordLight 					DB  "Light",0              ;84
  85+ 8E6B 74 00
  86+ 8E6D 59 65 61 72  WordYears 					DB  "Years",0              ;85
  86+ 8E71 73 00
  87+ 8E73 30 00        Word0						DB  "0",0				   ;86
  88+ 8E75 4D 61 72 6B  WordMarket					DB  "Market",0			   ;87
  88+ 8E79 65 74 00
  89+ 8E7C 50 72 69 63  WordPrices					DB  "Prices",0			   ;88
  89+ 8E80 65 73 00
  90+ 8E83 50 72 6F 64  WordProduct    				DB  "Product",0  		   ;89
  90+ 8E87 75 63 74 00
  91+ 8E8B 55 6F 4D 00  WordUoM						DB  "UoM",0                ;90
  92+ 8E8F 50 72 69 63  WordPrice					DB  "Price",0              ;91
  92+ 8E93 65 00
  93+ 8E95 46 6F 72 00  WordFor                     DB  "For",0                ;92
  94+ 8E99 53 61 6C 65  WordSale                    DB  "Sale",0               ;93
  94+ 8E9D 00
  95+ 8E9E 74 00        Wordt						DB  "t",0                  ;94
  96+ 8EA0 6B 67 00     Wordkg						DB  "kg",0                 ;95
  97+ 8EA3 67 00        Wordg						DB  "g",0                  ;96
  98+ 8EA5 51 75 61 6E  WordQuantity				DB  "Quanitity",0		   ;97
  98+ 8EA9 69 74 69 74
  98+ 8EAD 79 00
  99+ 8EAF 49 6E 76 00  WordInv                     DB  "Inv",0                ;98
 100+ 8EB3 53 74 6F 63  WordStock                   DB  "Stock",0              ;99
 100+ 8EB7 6B 00
 101+ 8EB9 45 71 75 69  WordEquip                   DB  "Equip",0              ;100
 101+ 8EBD 70 00
 102+ 8EBF 53 68 69 70  WordShip                    DB  "Ship",0               ;101
 102+ 8EC3 00
 103+ 8EC4 4D 69 73 73  WordMissile                 DB  "Missile",0            ;102
 103+ 8EC8 69 6C 65 00
 104+ 8ECC 48 79 70 65  WordHyperdrive              DB  "Hyperdrive",0
 104+ 8ED0 72 64 72 69
 104+ 8ED4 76 65 00
 105+ 8ED7 4D 69 6C 69  WordMilitary                DB  "Military",0
 105+ 8EDB 74 61 72 79
 105+ 8EDF 00
 106+ 8EE0
 107+ 8EE0 DC 8B DE 8B  WordIdx				DW  WordDummy,          WordFront,        WordRight,        WordLeft		;0-3
 107+ 8EE4 E4 8B EA 8B
 108+ 8EE8 EF 8B F4 8B  					DW  WordRear,           WordLarge,        WordEscape,       WordPod      	;4-7
 108+ 8EEC FA 8B 01 8C
 109+ 8EF0 05 8C 0B 8C  					DW  WordCargo,          WordBay,          WordFuel,         WordScoops   	;8
 109+ 8EF4 0F 8C 14 8C
 110+ 8EF8 1B 8C 22 8C  					DW  WordECM,            WordSystem,       WordEnergy,       WordBomb     	;12
 110+ 8EFC 29 8C 30 8C
 111+ 8F00 35 8C 3B 8C  					DW  WordLaser,          WordPulse,        WordBeam,         WordMiliary  	;16
 111+ 8F04 41 8C 46 8C
 112+ 8F08 4E 8C 55 8C  					DW  WordMining,         WordCustom,       WordUnit,         WordShield   	;20
 112+ 8F0C 5C 8C 61 8C
 113+ 8F10 68 8C 70 8C  					DW  WordDocking,        WordComputers,    WordHyperspace,   WordGalactic 	;24
 113+ 8F14 7A 8C 85 8C
 114+ 8F18 8E 8C 94 8C  					DW  WordExtra,          WordClean,        WordOffender,     WordFugitive	;28
 114+ 8F1C 9A 8C A3 8C
 115+ 8F20 AC 8C B1 8C  					DW  WordFood,           WordTextiles,     WordRadioactives, WordSlaves		;32
 115+ 8F24 BA 8C C7 8C
 116+ 8F28 CE 8C DB 8C  					DW  WordLiquorWines,    WordLuxuries,     WordNarcotics,    WordMachinery   ;36
 116+ 8F2C E4 8C EE 8C
 117+ 8F30 F8 8C FF 8C  					DW  WordAlloys,         WordFirearms,     WordFurs,         WordMinerals    ;40
 117+ 8F34 08 8D 0D 8D
 118+ 8F38 16 8D 1B 8D  					DW  WordGold,           WordPlatinum,     WordGemStones,    WordAlienItems  ;44               ;
 118+ 8F3C 24 8D 2F 8D
 119+ 8F40 3B 8D 42 8D  WordIdxUoMFull		DW  WordTonnes,         WordKilograms,    WordGrams,		WordShort		;48
 119+ 8F44 4C 8D 52 8D
 120+ 8F48 58 8D 5E 8D  					DW	WordRange,		    WordChart,        WordData,         WordOn          ;52
 120+ 8F4C 64 8D 69 8D
 121+ 8F50 6C 8D 75 8D  					DW  WordDistance,       WordEconomy,      WordGovernment,   WordTechLevel   ;56
 121+ 8F54 7D 8D 88 8D
 122+ 8F58 92 8D 9D 8D  					DW  WordPopulation,     WordMillion,      WordBillion,      WordGross       ;60
 122+ 8F5C A5 8D AD 8D
 123+ 8F60 B3 8D C0 8D  					DW  WordProductivity,   WordAverage,      WordRadius,       WordKM          ;64
 123+ 8F64 C8 8D CF 8D
 124+ 8F68 D2 8D        					DW  WordMCR																	;68
 125+ 8F6A D7 8D DC 8D  WordIdxEconomy		DW  WordRich,           WordAvg,      	  WordMainly,       WordPoor        ;69
 125+ 8F6E E0 8D E7 8D
 126+ 8F72 EC 8D F7 8D                      DW  WordIndustrial,     WordAgricultural									;73
 127+ 8F76 04 8E 0C 8E  WordIdxGovernment	DW  WordAnarchy,        WordFeudal,       WordMultiGovernment, WordDictatorship ;75
 127+ 8F7A 13 8E 24 8E
 128+ 8F7E 31 8E 3B 8E                      DW  WordCommunist,      WordConfederacy,  WordDemocracy,       WordCorporate ;79
 128+ 8F82 47 8E 51 8E
 129+ 8F86 61 8E 67 8E  					DW  WordState,          WordLight,        WordYears,           Word0         ; 83
 129+ 8F8A 6D 8E 73 8E
 130+ 8F8E 75 8E 7C 8E  WordIdxMarketmenu	DW  WordMarket,         WordPrices,       WordProduct,         WordUoM	    ;87
 130+ 8F92 83 8E 8B 8E
 131+ 8F96 8F 8E 95 8E                      DW  WordPrice,          WordFor,          WordSale                          ;91
 131+ 8F9A 99 8E
 132+ 8F9C 9E 8E A0 8E  WordIdxUomAbbrev	DW	Wordt,				Wordkg,           Wordg                 		    ;94
 132+ 8FA0 A3 8E
 133+ 8FA2 A5 8E AF 8E  					DW  WordQuantity,       WordInv,          WordStock,           WordEquip	;97
 133+ 8FA6 B3 8E B9 8E
 134+ 8FAA BF 8E C4 8E                      DW  WordShip,           WordMissile       ; 101
 135+ 8FAE
 136+ 8FAE              ; Phrases
 137+ 8FAE 05 08 09 00  TextLargeCargoBay			DB 	5,8,9,0          ;0
 138+ 8FB2 06 07 00     TextEscapePod				DB	6,7,0            ;1
 139+ 8FB5 0A 0B 00     TextFuelScoops				DB	10,11,0          ;2
 140+ 8FB8 0C 0D 00     TextECMSystem				DB	12,13,0          ;3
 141+ 8FBB 0E 0F 00     TextEnergyBomb				DB	14,15,0          ;4
 142+ 8FBE 0E 16 00     TextEnergyUnit				DB	14,22,0          ;5
 143+ 8FC1 18 19 00     TextDockingComp     		DB  24,25,0          ;6
 144+ 8FC4 1B 1A 00     TextGalacticHyper			DB	27,26,0          ;7
 145+ 8FC7 01 12 10 00  TextFrontLaser      		DB  01,18,16,0       ;8
 146+ 8FCB 03 12 10 00  TextLeftLaser       		DB  03,18,16,0       ;9
 147+ 8FCF 02 12 10 00  TextRightLaser      		DB  02,18,16,0       ;10
 148+ 8FD3 04 12 10 00  TextRearLaser       		DB  04,18,16,0       ;11
 149+ 8FD7 33 34 35 00  TextShortRangeChart 		DB	51,52,53,0       ;12
 150+ 8FDB 1B 35 00     TextGalacticChart   		DB	27,53,0          ;13
 151+ 8FDE 36 37 00     TextDataOn					DB	54,55,0          ;14
 152+ 8FE1 45 49 00     TextRichIndustrial          DB  69,73,0          ;15
 153+ 8FE4 46 49 00     TextAvgIndustrial           DB  70,73,0			 ;16
 154+ 8FE7 47 49 00     TextMainIndustrial          DB  71,73,0          ;17
 155+ 8FEA 48 49 00     TextPoorIndustrial          DB  72,73,0          ;18
 156+ 8FED 45 4A 00     TextRichAgricultural        DB  69,74,0          ;19
 157+ 8FF0 46 4A 00     TextAvgAgricultural         DB  70,74,0          ;20
 158+ 8FF3 47 4A 00     TextMainAgricultural        DB  71,74,0          ;21
 159+ 8FF6 48 4A 00     TextPoorAgricultural        DB  72,74,0          ;22
 160+ 8FF9 54 55 00     TextLightYears				DB  84,85,0			 ;23
 161+ 8FFC 56 54 55 00  Text0LightYears				DB  86,84,85,0		 ;24
 162+ 9000 57 58 00     TextMarketPrices			DB  87,88,0			 ;25
 163+ 9003 64 65        TextEquipShip               DB  100,101          ;26
 164+ 9005
 165+ 9005 00           TextDummy					DB  0
 166+ 9006
 167+ 9006 AE 8F B2 8F  TextTokens			DW  TextLargeCargoBay, TextEscapePod, TextFuelScoops				; 0 2
 167+ 900A B5 8F
 168+ 900C B8 8F BB 8F  					DW  TextECMSystem, TextEnergyBomb, TextEnergyUnit					; 3 5
 168+ 9010 BE 8F
 169+ 9012 C1 8F C4 8F  					DW  TextDockingComp, TextGalacticHyper  							; 6 7
 170+ 9016 C7 8F CB 8F  					DW	TextFrontLaser, TextLeftLaser, TextRightLaser, TextRearLaser	; 8 11
 170+ 901A CF 8F D3 8F
 171+ 901E D7 8F DB 8F  					DW  TextShortRangeChart, TextGalacticChart, TextDataOn				; 12 14
 171+ 9022 DE 8F
 172+ 9024 E1 8F E4 8F  TextTokenEconomy	DW  TextRichIndustrial, TextAvgIndustrial, TextPoorIndustrial, TextMainIndustrial, TextMainAgricultural, TextRichAgricultural, TextAvgAgricultural,  TextPoorAgricultural
 172+ 9028 EA 8F E7 8F
 172+ 902C F3 8F ED 8F
 172+ 9030 F0 8F F6 8F
 173+ 9034 F9 8F        					DW  TextLightYears		                                            ; 21 23
 174+ 9036 FC 8F 00 90  					DW  Text0LightYears, TextMarketPrices
 175+ 903A 05 90        					DW  TextDummy;  25
 176+ 903C 00 00 00...  TextBuffer			DS	33
 177+ 905D
 178+ 905D              TextEconomyOffset   EQU (TextTokenEconomy - TextTokens)/2
 179+ 905D              TextGovOffset       EQU (WordIdxGovernment - WordIdx)/2
 180+ 905D
 181+ 905D              CapitaliseString:
 182+ 905D              ; ">CapitaliseString hl = address"
 183+ 905D              .CapLoop:
 184+ 905D 23           	inc		hl
 185+ 905E 7E           	ld		a,(hl)
 186+ 905F FE 00        	cp		0
 187+ 9061 C8           	ret		z
 188+ 9062 FE 5B        	cp		'Z'+1
 189+ 9064 30 F7        	jr		nc,.CapLoop
 190+ 9066 FE 41        	cp		'A'
 191+ 9068 38 F3        	jr		c,.CapLoop
 192+ 906A              .LowerCase:
 193+ 906A C6 20        	add		a,'a'-'A'
 194+ 906C 77           	ld		(hl),a
 195+ 906D 18 EE        	jr		.CapLoop
 196+ 906F
 197+ 906F              WordIndexToAddress:
 198+ 906F 21 E0 8E     	ld		hl,WordIdx
 199+ 9072 ED 31        	add		hl,a
 200+ 9074 ED 31        	add		hl,a
 201+ 9076 D5           	push	de
 202+ 9077 5E           	ld		e,(hl)
 203+ 9078 23           	inc		hl
 204+ 9079 56           	ld		d,(hl)
 205+ 907A EB           	ex		de,hl
 206+ 907B D1           	pop		de
 207+ 907C C9           	ret
 208+ 907D
 209+ 907D
 210+ 907D              expandTokenToString:
 211+ 907D              ; ">expandTokenToString a = texttoken"
 212+ 907D 21 06 90     	ld		hl,TextTokens
 213+ 9080 CD B5 8B     	call	getTableText
 214+ 9083 11 3C 90     	ld		de,TextBuffer
 215+ 9086              .ReadLoop:
 216+ 9086 7E           	ld		a,(hl)
 217+ 9087 FE 00        	cp		0
 218+ 9089 28 1B        	jr		z,.ReadDone
 219+ 908B E5           	push	hl
 220+ 908C D5           	push	de
 221+ 908D 21 E0 8E     	ld		hl,WordIdx
 222+ 9090 CD B5 8B     	call	getTableText
 223+ 9093 D1           	pop		de
 224+ 9094              .WordExpandLoop:
 225+ 9094 7E           	ld		a,(hl)
 226+ 9095 FE 00        	cp		0
 227+ 9097 28 05        	jr		z,.AddSpace
 228+ 9099              ;.GetChar:
 229+ 9099 12           	ld		(de),a
 230+ 909A 13           	inc		de
 231+ 909B 23           	inc		hl
 232+ 909C 18 F6        	jr		.WordExpandLoop
 233+ 909E              .AddSpace:
 234+ 909E 3E 20        	ld		a,' '
 235+ 90A0 12           	ld		(de),a
 236+ 90A1 13           	inc		de
 237+ 90A2 E1           	pop		hl
 238+ 90A3 23           	inc		hl
 239+ 90A4 18 E0        	jr		.ReadLoop
 240+ 90A6              .ReadDone:
 241+ 90A6 1B           	dec		de
 242+ 90A7 AF           	xor		a
 243+ 90A8 12           	ld		(de),a
 244+ 90A9 C9           	ret
 245+ 90AA
# file closed: ./Tables/dictionary.asm
 115  90AA                  INCLUDE "./Tables/name_digrams.asm"
# file opened: ./Tables/name_digrams.asm
   1+ 90AA 41 42 4F 55  name_digrams	DB "ABOUSEITILETSTONLONUTHNO"
   1+ 90AE 53 45 49 54
   1+ 90B2 49 4C 45 54
   1+ 90B6 53 54 4F 4E
   1+ 90BA 4C 4F 4E 55
   1+ 90BE 54 48 4E 4F
   2+ 90C2 41 4C 4C     name_digrams2   DB "ALL"
   3+ 90C5 45 58 45 47  				DB "EXEGEZACEBISOUSESARMAINDIREA"
   3+ 90C9 45 5A 41 43
   3+ 90CD 45 42 49 53
   3+ 90D1 4F 55 53 45
   3+ 90D5 53 41 52 4D
   3+ 90D9 41 49 4E 44
   3+ 90DD 49 52 45 41
   4+ 90E1 3F 45 52 41  				DB "?ERATENBERALAVETIEDORQUANTEISRION"
   4+ 90E5 54 45 4E 42
   4+ 90E9 45 52 41 4C
   4+ 90ED 41 56 45 54
   4+ 90F1 49 45 44 4F
   4+ 90F5 52 51 55 41
   4+ 90F9 4E 54 45 49
   4+ 90FD 53 52 49 4F
   4+ 9101 4E
   5+ 9102
   6+ 9102              ; TODO Moveinto galaxy data module
   7+ 9102 00 00 00...  name_expanded	DS 32
   8+ 9122 00           				DB 0
   9+ 9123
  10+ 9123
  11+ 9123
  12+ 9123              NamingLoop:
  13+ 9123 3A 56 85     	ld		a,(WorkingSeeds+5)	; a = first byte of name seed
  14+ 9126 E6 1F        	and 	$1F					; Keep bottom 5 bits only
  15+ 9128 FE 00        	cp		0					; 0 = skip 2 chars
  16+ 912A 28 12        	jr		z,.SkipPhrase
  17+ 912C C6 0C        	add		a,12
  18+ 912E CB 27        	sla		a					; phrase = (a+12)*2
  19+ 9130 21 AA 90     	ld		hl,name_digrams
  20+ 9133 ED 31        	add		hl,a
  21+ 9135 ED A0        	ldi
  22+ 9137 7E           	ld		a,(hl)
  23+ 9138 FE 3F        	cp		'?'
  24+ 913A 28 02        	jr		z,.SkipPhrase
  25+ 913C              .AddExtra:
  26+ 913C ED A0        	ldi
  27+ 913E              .SkipPhrase:
  28+ 913E D5           	push	de
  29+ 913F CD 53 89     	call	working_seed
  30+ 9142 D1           	pop		de
  31+ 9143 C9           	ret
  32+ 9144
  33+ 9144              ;GetDigramGalaxySeed:
  34+ 9144              ;	call	copy_galaxy_to_working
  35+ 9144              ;	jr		GetDigramWorkingSeed
  36+ 9144              ;GetDigramSystemSeed:
  37+ 9144              ;	call	copy_system_to_working
  38+ 9144              ;GetDigramWorkingSeed:
  39+ 9144              ;; ">GetDigram a = digram seed"
  40+ 9144              ;	ld		de,name_expanded
  41+ 9144              ;	ld		b,3
  42+ 9144              ;	ld		a,(WorkingSeeds)
  43+ 9144              ;	and		$40
  44+ 9144              ;	jr		z,.SmallSizeName
  45+ 9144              ;.LargeSizeName:
  46+ 9144              ;	call	NamingLoop
  47+ 9144              ;.SmallSizeName:
  48+ 9144              ;	call	NamingLoop
  49+ 9144              ;	call	NamingLoop
  50+ 9144              ;	call	NamingLoop
  51+ 9144              ;.DoneName:
  52+ 9144              ;	ex		de,hl
  53+ 9144              ;	ld		(hl),0
  54+ 9144              ;	ex		de,hl
  55+ 9144              ;	ret
  56+ 9144
  57+ 9144
  58+ 9144
  59+ 9144              ;GetDigramWorkingSeed:
  60+ 9144              ;	MESSAGE ">GetDigram a = digram seed b = length"
  61+ 9144              ;	ld		b,5					; working seed
  62+ 9144              ;	ld		de,name_expanded
  63+ 9144              ;.ExpansionLoop:
  64+ 9144              ;	push	bc
  65+ 9144              ;	ld		hl,WorkingSeeds
  66+ 9144              ;	ld		a,b
  67+ 9144              ;	add		hl,a
  68+ 9144              ;	ld		a,(hl)	; a = first byte of name seed
  69+ 9144              ;	and 	$1F					; Keep bottom 5 bits only
  70+ 9144              ;	cp		0					; 0 = skip 2 chars
  71+ 9144              ;	jr		z,.SkipPhrase
  72+ 9144              ;	or		&80					; set buit 7 high (probabtyl capitalisation)
  73+ 9144              ;	call	TT27
  74+ 9144              ;.SkipPhrase:
  75+ 9144              ;	push	de
  76+ 9144              ;	call	next_working_seed
  77+ 9144              ;	pop		de
  78+ 9144              ;	pop		bc
  79+ 9144              ;	djnz	GetDigramWorkingSeed
  80+ 9144              ;.DoneName:
  81+ 9144              ;	ex		de,hl
  82+ 9144              ;	ld		(hl),0
  83+ 9144              ;	ex		de,hl
  84+ 9144              ;	ret
  85+ 9144              ;
  86+ 9144              ;ExpandToken:
  87+ 9144              ;	DE = target
  88+ 9144              ;	a = token
  89+ 9144              ;
  90+ 9144              ;PlanetDigram:
  91+ 9144              ;	cp		&A0							; >- 160
  92+ 9144              ;	jr		c,MorePage4
  93+ 9144              ;	and		$7F							; 128 to 159 now 0 to 31
  94+ 9144              ;	asl		2							; Multiply by 2
  95+ 9144              ;	ld		hl, name_digrams2
  96+ 9144              ;	add		hl,a
  97+ 9144              ;	ld		a,(hl)
  98+ 9144              ;	call	ProcessTextToken
  99+ 9144              ;	inc		hl
 100+ 9144              ;	ld		a,(hl)
 101+ 9144              ;	cp		'?'
 102+ 9144              ;	ret		z
 103+ 9144              ;	call	ProcessTextToken
 104+ 9144              ;	ret
 105+ 9144              ;MorePage4:
 106+ 9144              ;	sub		$A0
 107+ 9144              ;ExtraTokenCheck:
 108+ 9144              ;	push	de							; save target address
 109+ 9144              ;	push	bc
 110+ 9144              ;	ld		b,a
 111+ 9144              ;	ld		hl,varV
 112+ 9144              ;	ld		(VarV),0400
 113+ 9144              ;	ld		(varV),a
 114+ 9144              ;	ld
 115+ 9144              ;
 116+ 9144              ;		.TT43	\ Token > 127 page4 token or planet digram.
 117+ 9144              ;C9 A0                   CMP #&A0	      \ >= #160 ?
 118+ 9144              ;B0 14                   BCS TT47	      \ more page4, subtract #160
 119+ 9144              ;29 7F                   AND #&7F	      \ else token 128to159  -> 0 to 31
 120+ 9144              ;0A                      ASL A		      \ *= 2
 121+ 9144              ;A8                      TAY 		      \ digram index = 0to62
 122+ 9144              ;B9 80 08                LDA &0880,Y \ QQ16,Y  \ ALLEXEGEZACEBISOUSESARMAINDIREA?ER  etc.
 123+ 9144              ;20 9A 33                JSR &339A   \ TT27    \ process text token
 124+ 9144              ;B9 81 08                LDA &0881,Y \ QQ16+1,Y \ 2nd character of diagram. Flight copied down from docked code.
 125+ 9144              ;C9 3F                   CMP #&3F	      \ is second letter '?'
 126+ 9144              ;F0 40                   BEQ TT48    	      \ rts, name has odd-number of letters.
 127+ 9144              ;4C 9A 33                JMP &339A   \ TT27    \ process text token
 128+ 9144              ;
 129+ 9144              ;	.TT47	\ more page4, subtract #160
 130+ 9144              ;E9 A0                   SBC #&A0	\ -= 160
 131+ 9144              ;	.ex	\ -> &342D \ extra, token >= 96 or Acc = 128to145 or -=160
 132+ 9144              ;AA                      TAX 		\ copy of word index
 133+ 9144              ;A9 00                   LDA #0		\ page 4 words lo  #QQ18 MOD 256
 134+ 9144              ;85 22                   STA &22		\ V
 135+ 9144              ;A9 04                   LDA #4		\ page 4 words hi  #QQ18 DIV 256
 136+ 9144              ;85 23                   STA &23		\ V+1
 137+ 9144              ;A0 00                   LDY #0
 138+ 9144              ;8A                      TXA 		\ token = word index
 139+ 9144              ;F0 13                   BEQ TT50	\ if X=0 then Y offset to word correct
 140+ 9144              ;	.TT51	\ counters Y letter, X token
 141+ 9144              ;B1 22                   LDA (&22),Y	\ (V),Y
 142+ 9144              ;F0 07                   BEQ TT49	\ exit as word ended
 143+ 9144              ;C8                      INY 		\ letter count
 144+ 9144              ;D0 F9                   BNE TT51	\ loop Y
 145+ 9144              ;E6 23                   INC &23	  \ V+1 \ next page as Y reached 256
 146+ 9144              ;D0 F5                   BNE TT51    	\ guaranteed, loop Y letter
 147+ 9144              ;	.TT49	\ word ended
 148+ 9144              ;C8                      INY
 149+ 9144              ;D0 02                   BNE TT59    	\ next word
 150+ 9144              ;E6 23                   INC &23	  \ V+1	\ next page as Y reached 256
 151+ 9144              ;	.TT59	\ next word
 152+ 9144              ;CA                      DEX 		\ token count
 153+ 9144              ;D0 ED                   BNE TT51	\ loop X token
 154+ 9144              ;	.TT50	\ token X = 0, counter Y offset to word correct
 155+ 9144              ;98                      TYA
 156+ 9144              ;48                      PHA 		\ store Yindex
 157+ 9144              ;A5 23                   LDA &23		\ V+1
 158+ 9144              ;48                      PHA 		\ correct pointer hi
 159+ 9144              ;B1 22                   LDA (&22),Y 	\ (V),Y
 160+ 9144              ;49 23                   EOR #&23	\ decode '#'
 161+ 9144              ;20 9A 33                JSR &339A \ TT27 \ process text token to next depth
 162+ 9144              ;68                      PLA 		\ restore this depth's Vhi
 163+ 9144              ;85 23                   STA &23		\ V+1
 164+ 9144              ;68                      PLA
 165+ 9144              ;A8                      TAY 		\ restore this depth's Yindex
 166+ 9144              ;C8                      INY 		\ next letter
 167+ 9144              ;D0 02                   BNE P%+4	\ not zero so skip next page
 168+ 9144              ;E6 23                   INC &23		\ V+1
 169+ 9144              ;B1 22                   LDA (&22),Y	\ (V),Y
 170+ 9144              ;D0 E6                   BNE TT50    	\ loop Y for next letter of page4 token
 171+ 9144              ;	.TT48 	\ rts
 172+ 9144              ;60                      RTS 		\ end of flight token printing TT27
 173+ 9144              ;
 174+ 9144              ;
 175+ 9144              ;
 176+ 9144              ;
 177+ 9144              ;
 178+ 9144              ;
 179+ 9144              ;		.TT27	\ -> &36E0 \ process flight text Token in Acc
 180+ 9144              ;;AA                      TAX		\ copy token to count down
 181+ 9144              ;;F0 DE                   BEQ csh		\ Acc = 0, up to Cash
 182+ 9144              ;30 74                   BMI TT43	\ if token is >  127 down, page4 token or digram
 183+ 9144              ;CA                      DEX
 184+ 9144              ;F0 BC                   BEQ tal		\ Acc == 1, up, print Galaxy number.
 185+ 9144              ;CA                      DEX
 186+ 9144              ;F0 A3                   BEQ ypl		\ Acc == 2, up, present planet in QQ2.
 187+ 9144              ;CA                      DEX
 188+ 9144              ;D0 03                   BNE P%+5	\ hop over, else X == 0
 189+ 9144              ;4C 0A 33                JMP &330A \ cpl \ Acc = 3 print Planet name for seed QQ15
 190+ 9144              ;CA                      DEX
 191+ 9144              ;F0 8A                   BEQ cmn		\ Acc == 4, up, commander name.
 192+ 9144              ;CA                      DEX
 193+ 9144              ;F0 B5                   BEQ fwl		\ Acc == 5, up, fuel followed by cash.
 194+ 9144              ;CA                      DEX
 195+ 9144              ;D0 05                   BNE  P%+7	\ hop over, else X == 0
 196+ 9144              ;A9 80                   LDA #&80	\ Acc == 6, set bit 7 TT27m
 197+ 9144              ;85 72                   STA &72	 	\ QQ17
 198+ 9144              ;60                      RTS
 199+ 9144              ;CA                      DEX 		\ skip Acc ==7
 200+ 9144              ;CA                      DEX
 201+ 9144              ;D0 03                   BNE P%+5	\ hop over to continue Acc 9to127
 202+ 9144              ;86 72                   STX &72	 \ QQ17	\ else Acc ==8, QQ17 set to X = 0
 203+ 9144              ;60                      RTS
 204+ 9144              ;CA                      DEX 		\ continue 9to127 tokens
 205+ 9144              ;F0 38                   BEQ crlf	\ Acc == 9, down, colon on right.
 206+ 9144              ;C9 60                   CMP #&60	\ discard X, look at Acc = token >= 96
 207+ 9144              ;B0 66                   BCS ex   	\ extra >= #&60, far down
 208+ 9144              ;C9 0E                   CMP #14		\ < 14 ?
 209+ 9144              ;90 04                   BCC P%+6	\ goes to Token < 14 or > 31
 210+ 9144              ;C9 20                   CMP #32		\ < 32 ?
 211+ 9144              ;90 28                   BCC qw   	\ 14 <= token A < 32 becomes 128to145 page4 digram
 212+ 9144              ;		\ Token  < 14 or > 31
 213+ 9144              ;A6 72                   LDX &72	 	\ QQ17
 214+ 9144              ;F0 3D                   BEQ TT74 	\ if QQ17 = 0 Upper case, jmp TT26, print character.
 215+ 9144              ;30 11                   BMI TT41 	\ if bit7 set
 216+ 9144              ;24 72                   BIT &72		\ QQ17 has bit6 set too
 217+ 9144              ;70 30                   BVS TT46 	\ If only bit6 set, clear bit6 and print as Upper
 218+ 9144              ;	.TT42	\ Uppercase to lowercase
 219+ 9144              ;C9 41                   CMP #&41	\ < ascii 'A'
 220+ 9144              ;90 06                   BCC TT44 	\ jmp TT26, print character
 221+ 9144              ;C9 5B                   CMP #&5B	\ >= ascii 'Z'+1
 222+ 9144              ;B0 02                   BCS TT44 	\ jmp TT26, print character
 223+ 9144              ;69 20                   ADC #&20	\ else Upper to lowercase
 224+ 9144              ;	.TT44	\ print character as is with TT26
 225+ 9144              ;4C FC 1E                JMP &1EFC \ TT26 \ print character
 226+ 9144              ;
 227+ 9144              ;	.TT41	\ QQ17 bit7 set
 228+ 9144              ;24 72                   BIT &72		\ QQ17
 229+ 9144              ;70 17                   BVS TT45	\ bit6 set too, Nothing or lower.
 230+ 9144              ;C9 41                   CMP #&41	\ < ascii 'A'
 231+ 9144              ;90 22                   BCC TT74 	\ print as is using TT26
 232+ 9144              ;48                      PHA 		\ else store token Acc
 233+ 9144              ;8A                      TXA 		\ QQ17 copy
 234+ 9144              ;09 40                   ORA #&40	\ set bit6 in QQ17 so subsequent ones lower
 235+ 9144              ;85 72                   STA &72	 	\ QQ17
 236+ 9144              ;68                      PLA 		\ restore token
 237+ 9144              ;D0 EC                   BNE TT44	\ guaranteed up, print as Uppercase with TT26.
 238+ 9144              ;
 239+ 9144              ;	.qw	\ Acc = 14to31 becomes 128to145 page4 digram
 240+ 9144              ;69 72                   ADC #&72	\ A+=114 becomes 128to145 page4 digram
 241+ 9144              ;D0 32                   BNE ex		\ guaranteed down, extra.
 242+ 9144              ;
 243+ 9144              ;	.crlf	\ Acc == 9,  colon on right
 244+ 9144              ;A9 15                   LDA #21		\ on right
 245+ 9144              ;85 2C                   STA &2C		\ XC
 246+ 9144              ;D0 97                   BNE TT73	\ guaranteed up, print colon.
 247+ 9144              ;
 248+ 9144              ;	.TT45	\ QQ17 bits 7,6 set. Nothing or lower.
 249+ 9144              ;E0 FF                   CPX #&FF	\ if QQ17 = #&FF
 250+ 9144              ;F0 63                   BEQ TT48	\ rts
 251+ 9144              ;C9 41                   CMP #&41	\ >= ascii 'A' ?
 252+ 9144              ;B0 D0                   BCS TT42	\ Uppercase to lowercase, up.
 253+ 9144              ;	.TT46	\ clear bit6 QQ17 and print as is using TT26
 254+ 9144              ;48                      PHA 		\ push token
 255+ 9144              ;8A                      TXA 		\ QQ17 copy
 256+ 9144              ;29 BF                   AND #&BF	\ clear bit6
 257+ 9144              ;85 72                   STA &72	 	\ QQ17
 258+ 9144              ;68                      PLA 		\ pull token
 259+ 9144              ;	.TT74	\ TT26, print character.
 260+ 9144              ;4C FC 1E                JMP &1EFC	\ TT26
 261+ 9144              ;
 262+ 9144              ;	.TT43	\ Token > 127 page4 token or planet digram.
 263+ 9144              ;C9 A0                   CMP #&A0	      \ >= #160 ?
 264+ 9144              ;B0 14                   BCS TT47	      \ more page4, subtract #160
 265+ 9144              ;29 7F                   AND #&7F	      \ else token 128to159  -> 0 to 31
 266+ 9144              ;0A                      ASL A		      \ *= 2
 267+ 9144              ;A8                      TAY 		      \ digram index = 0to62
 268+ 9144              ;B9 80 08                LDA &0880,Y \ QQ16,Y  \ ALLEXEGEZACEBISOUSESARMAINDIREA?ER  etc.
 269+ 9144              ;20 9A 33                JSR &339A   \ TT27    \ process text token
 270+ 9144              ;B9 81 08                LDA &0881,Y \ QQ16+1,Y \ 2nd character of diagram. Flight copied down from docked code.
 271+ 9144              ;C9 3F                   CMP #&3F	      \ is second letter '?'
 272+ 9144              ;F0 40                   BEQ TT48    	      \ rts, name has odd-number of letters.
 273+ 9144              ;4C 9A 33                JMP &339A   \ TT27    \ process text token
 274+ 9144              ;
 275+ 9144              ;	.TT47	\ more page4, subtract #160
 276+ 9144              ;E9 A0                   SBC #&A0	\ -= 160
 277+ 9144              ;	.ex	\ -> &342D \ extra, token >= 96 or Acc = 128to145 or -=160
 278+ 9144              ;AA                      TAX 		\ copy of word index
 279+ 9144              ;A9 00                   LDA #0		\ page 4 words lo  #QQ18 MOD 256
 280+ 9144              ;85 22                   STA &22		\ V
 281+ 9144              ;A9 04                   LDA #4		\ page 4 words hi  #QQ18 DIV 256
 282+ 9144              ;85 23                   STA &23		\ V+1
 283+ 9144              ;A0 00                   LDY #0
 284+ 9144              ;8A                      TXA 		\ token = word index
 285+ 9144              ;F0 13                   BEQ TT50	\ if X=0 then Y offset to word correct
 286+ 9144              ;	.TT51	\ counters Y letter, X token
 287+ 9144              ;B1 22                   LDA (&22),Y	\ (V),Y
 288+ 9144              ;F0 07                   BEQ TT49	\ exit as word ended
 289+ 9144              ;C8                      INY 		\ letter count
 290+ 9144              ;D0 F9                   BNE TT51	\ loop Y
 291+ 9144              ;E6 23                   INC &23	  \ V+1 \ next page as Y reached 256
 292+ 9144              ;D0 F5                   BNE TT51    	\ guaranteed, loop Y letter
 293+ 9144              ;	.TT49	\ word ended
 294+ 9144              ;C8                      INY
 295+ 9144              ;D0 02                   BNE TT59    	\ next word
 296+ 9144              ;E6 23                   INC &23	  \ V+1	\ next page as Y reached 256
 297+ 9144              ;	.TT59	\ next word
 298+ 9144              ;CA                      DEX 		\ token count
 299+ 9144              ;D0 ED                   BNE TT51	\ loop X token
 300+ 9144              ;	.TT50	\ token X = 0, counter Y offset to word correct
 301+ 9144              ;98                      TYA
 302+ 9144              ;48                      PHA 		\ store Yindex
 303+ 9144              ;A5 23                   LDA &23		\ V+1
 304+ 9144              ;48                      PHA 		\ correct pointer hi
 305+ 9144              ;B1 22                   LDA (&22),Y 	\ (V),Y
 306+ 9144              ;49 23                   EOR #&23	\ decode '#'
 307+ 9144              ;20 9A 33                JSR &339A \ TT27 \ process text token to next depth
 308+ 9144              ;68                      PLA 		\ restore this depth's Vhi
 309+ 9144              ;85 23                   STA &23		\ V+1
 310+ 9144              ;68                      PLA
 311+ 9144              ;A8                      TAY 		\ restore this depth's Yindex
 312+ 9144              ;C8                      INY 		\ next letter
 313+ 9144              ;D0 02                   BNE P%+4	\ not zero so skip next page
 314+ 9144              ;E6 23                   INC &23		\ V+1
 315+ 9144              ;B1 22                   LDA (&22),Y	\ (V),Y
 316+ 9144              ;D0 E6                   BNE TT50    	\ loop Y for next letter of page4 token
 317+ 9144              ;	.TT48 	\ rts
 318+ 9144              ;60                      RTS 		\ end of flight token printing TT27
 319+ 9144              ;
 320+ 9144              ;
 321+ 9144              ;
# file closed: ./Tables/name_digrams.asm
 116  9144                  INCLUDE "./Maths/addhldesigned.asm"
# file opened: ./Maths/addhldesigned.asm
   1+ 9144 CB 7C        addhldesigned:          bit     7,h
   2+ 9146 20 03                                jr      nz,.noneghl
   3+ 9148 CD 60 97                             call    negate16hl
   4+ 914B CB 7A        .noneghl:               bit     7,d
   5+ 914D 20 03                                jr      nz,.nonegde
   6+ 914F CD 67 97                             call    negate16de
   7+ 9152 19           .nonegde:               add     hl,de                       ; do 2'd c add
   8+ 9153 AF                                   xor     a                           ; assume positive
   9+ 9154 CB 7C                                bit     7,h
  10+ 9156 C8                                   ret     z                           ; if not set then can exit early
  11+ 9157 CD 60 97                             call    negate16hl
  12+ 915A 3E FF                                ld      a,$FF
  13+ 915C C9                                   ret
  14+ 915D
# file closed: ./Maths/addhldesigned.asm
 117  915D                  INCLUDE "./Maths/asm_add.asm"
# file opened: ./Maths/asm_add.asm
   1+ 915D
   2+ 915D              ; HL(2sc) = HL (signed) + A (unsigned), uses HL, DE, A
   3+ 915D 16 00        HL2cEquHLSgnPlusAusgn:  ld      d,0
   4+ 915F 5F                                   ld      e,a                         ; set up DE = A
   5+ 9160 7C                                   ld      a,h
   6+ 9161 E6 7F                                and     SignMask8Bit
   7+ 9163 28 07                                jr      z,.HLPositive               ; if HL is negative then do HL - A
   8+ 9165 67           .HLNegative:            ld      h,a                         ; hl = ABS (HL)
   9+ 9166                                      NegHL                               ; hl = - hl
   9+ 9166 AF          >                    xor a
   9+ 9167 95          >                    sub l
   9+ 9168 6F          >                    ld l,a
   9+ 9169 9F          >                    sbc a,a
   9+ 916A 94          >                    sub h
   9+ 916B 67          >                    ld h,a
  10+ 916C              .HLPositive:            ClearCarryFlag                      ; now do adc hl,de
  10+ 916C B7          >                        or a
  11+ 916D ED 5A                                adc     hl,de                       ; aftert his hl will be 2's c
  12+ 916F C9                                   ret
  13+ 9170
  14+ 9170 5F           HLEquHLSgnPlusAusgn:    ld      e,a
  15+ 9171 7C                                   ld      a,h
  16+ 9172 E6 7F                                and     SignMask8Bit
  17+ 9174 20 04                                jr      nz,.HLNegative              ; if HL is negative then do HL - A
  18+ 9176 7B           .HLPositive:            ld      a,e                         ; else its HL + A
  19+ 9177 ED 31                                add     hl,a
  20+ 9179 C9                                   ret
  21+ 917A              .HLNegative:            ClearSignBit    h                   ; Clear sign of HL
  21+ 917A 7C          >                        ld      a,h
  21+ 917B E6 7F       >                        and     SignMask8Bit
  21+ 917D 67          >                        ld      h,a
  22+ 917E                                      NegHL                               ; and convert to 2's C
  22+ 917E AF          >                    xor a
  22+ 917F 95          >                    sub l
  22+ 9180 6F          >                    ld l,a
  22+ 9181 9F          >                    sbc a,a
  22+ 9182 94          >                    sub h
  22+ 9183 67          >                    ld h,a
  23+ 9184 16 00                                ld      d,0
  24+ 9186                                      ClearCarryFlag
  24+ 9186 B7          >                        or a
  25+ 9187 ED 52                                sbc     hl,de                       ; now add a to -ve HL , add does not do 2's c
  26+ 9189 FA 91 91                             jp      m,.FlipResult               ; if it was negative then its really positive
  27+ 918C                                      SetSignBit      h
  27+ 918C 7C          >                        ld      a,h
  27+ 918D F6 80       >                        or      SignOnly8Bit
  27+ 918F 67          >                        ld      h,a
  28+ 9190 C9                                   ret
  29+ 9191              .FlipResult:            NegHL                               ; so if -hl + A => HL - A => HL - DE is negative then the actual result is +ve
  29+ 9191 AF          >                    xor a
  29+ 9192 95          >                    sub l
  29+ 9193 6F          >                    ld l,a
  29+ 9194 9F          >                    sbc a,a
  29+ 9195 94          >                    sub h
  29+ 9196 67          >                    ld h,a
  30+ 9197 C9                                   ret
  31+ 9198
  32+ 9198
  33+ 9198
  34+ 9198              ; HL = HL (signed) + A (unsigned), uses HL, DE, A
  35+ 9198 57           AddAusngToHLsng:        ld      d,a
  36+ 9199 5C                                   ld      e,h
  37+ 919A 7C                                   ld      a,h
  38+ 919B E6 7F                                and     SignMask8Bit
  39+ 919D 67                                   ld      h,a
  40+ 919E 7A                                   ld      a,d
  41+ 919F ED 31                                add     hl,a
  42+ 91A1 7B                                   ld      a,e
  43+ 91A2 E6 80                                and     SignOnly8Bit
  44+ 91A4 B4                                   or      h
  45+ 91A5 C9                                   ret
  46+ 91A6              ; HL = A (unsigned) - HL (signed), uses HL, DE, BC, A
  47+ 91A6 44           HLEequAusngMinusHLsng:  ld      b,h
  48+ 91A7 4F                                   ld      c,a
  49+ 91A8 78                                   ld      a,b
  50+ 91A9 E6 80                                and     SignOnly8Bit
  51+ 91AB 20 08                                jr      nz,.DoAdd
  52+ 91AD EB           .DoSubtract:            ex      de,hl               ; move hl into de
  53+ 91AE 26 00                                ld      h,0                 ; hl = a
  54+ 91B0 69                                   ld      l,c
  55+ 91B1                                      ClearCarryFlag
  55+ 91B1 B7          >                        or a
  56+ 91B2 ED 52                                sbc     hl,de               ; hl = a - hl
  57+ 91B4 C9                                   ret
  58+ 91B5 79           .DoAdd:                 ld      a,c
  59+ 91B6 ED 31                                add hl,a
  60+ 91B8 C9                                   ret
  61+ 91B9              ;tested mathstestsun2
  62+ 91B9              ; DEL = DEL + BCH signed, uses BC, DE, HL, IY, A
  63+ 91B9 78           AddBCHtoDELsigned:      ld      a,b                 ; Are the values both the same sign?
  64+ 91BA AA                                   xor     d                   ; .
  65+ 91BB E6 80                                and     SignOnly8Bit        ; .
  66+ 91BD 20 19                                jr      nz,.SignDifferent   ; .
  67+ 91BF 78           .SignSame:              ld      a,b                 ; if they are then we only need 1 signe
  68+ 91C0 E6 80                                and     SignOnly8Bit        ; so store it in iyh
  69+ 91C2 FD 67                                ld      iyh,a               ;
  70+ 91C4 78                                   ld      a,b                 ; bch = abs bch
  71+ 91C5 E6 7F                                and     SignMask8Bit        ; .
  72+ 91C7 47                                   ld      b,a                 ; .
  73+ 91C8 7A                                   ld      a,d                 ; del = abs del
  74+ 91C9 E6 7F                                and     SignMask8Bit        ; .
  75+ 91CB 57                                   ld      d,a                 ; .
  76+ 91CC 7C                                   ld      a,h                 ; l = h + l
  77+ 91CD 85                                   add     l                   ; .
  78+ 91CE 6F                                   ld      l,a                 ; .
  79+ 91CF 79                                   ld      a,c                 ; e = e + c + carry
  80+ 91D0 8B                                   adc     e                   ; .
  81+ 91D1 5F                                   ld      e,a                 ; .
  82+ 91D2 78                                   ld      a,b                 ; d = b + d + carry (signed)
  83+ 91D3 8A                                   adc     d                   ;
  84+ 91D4 FD B4                                or      iyh                 ; d = or back in sign bit
  85+ 91D6 57                                   ld      d,a                 ;
  86+ 91D7 C9                                   ret                         ; done
  87+ 91D8 78           .SignDifferent:         ld      a,b                 ; bch = abs bch
  88+ 91D9 FD 67                                ld      iyh,a               ; iyh = b sign
  89+ 91DB E6 7F                                and     SignMask8Bit        ; .
  90+ 91DD 47                                   ld      b,a                 ; .
  91+ 91DE 7A                                   ld      a,d                 ; del = abs del
  92+ 91DF FD 6F                                ld      iyl,a               ; iyl = d sign
  93+ 91E1 E6 7F                                and     SignMask8Bit        ; .
  94+ 91E3 57                                   ld      d,a                 ; .
  95+ 91E4 E5                                   push    hl                  ; hl = bc - de
  96+ 91E5 60 69                                ld      hl,bc               ; if bc < de then there is a carry
  97+ 91E7 ED 52                                sbc     hl,de               ;
  98+ 91E9 E1                                   pop     hl                  ;
  99+ 91EA 38 0E                                jr      c,.BCHltDEL
 100+ 91EC 20 1C                                jr      nz,.DELltBCH        ; if the result was not zero then DEL > BCH
 101+ 91EE 7C           .BCeqDE:                ld      a,h                 ; if the result was zero then check lowest bits
 102+ 91EF                                      JumpIfALTNusng l,.BCHltDEL
 102+ 91EF BD          >                        cp      l
 102+ 91F0 DA FA 91    >                        jp		c, .BCHltDEL
 103+ 91F3 20 15                                jr      nz,.DELltBCH
 104+ 91F5              ; The same so its just zero
 105+ 91F5 AF           .BCHeqDEL:              xor     a                  ; its just zero
 106+ 91F6 57                                   ld      d,a                ; .
 107+ 91F7 5F                                   ld      e,a                ; .
 108+ 91F8 6F                                   ld      l,a                ; .
 109+ 91F9 C9                                   ret                        ; .
 110+ 91FA              ;BCH is less than DEL so its DEL - BCH the sort out sign
 111+ 91FA 7D           .BCHltDEL:              ld      a,l                ; l = l - h                      ; ex
 112+ 91FB 94                                   sub     h                  ; .                              ;   01D70F DEL
 113+ 91FC 6F                                   ld      l,a                ; .                              ;  -000028 BCH
 114+ 91FD 7B                                   ld      a,e                ; e = e - c - carry              ;1.
 115+ 91FE 99                                   sbc     c                  ; .                              ;
 116+ 91FF 5F                                   ld      e,a                ; .                              ;
 117+ 9200 7A                                   ld      a,d                ; d = d - b - carry              ;
 118+ 9201 98                                   sbc     b                  ; .                              ;
 119+ 9202 57                                   ld      d,a                ; .                              ;
 120+ 9203 FD 7D                                ld      a,iyl              ; as d was larger, take d sign
 121+ 9205 E6 80                                and     SignOnly8Bit       ;
 122+ 9207 B2                                   or      d                  ;
 123+ 9208 57                                   ld      d,a                ;
 124+ 9209 C9                                   ret
 125+ 920A 7C           .DELltBCH:              ld      a,h                ; l = h - l
 126+ 920B 95                                   sub     l                  ;
 127+ 920C 6F                                   ld      l,a                ;
 128+ 920D 79                                   ld      a,c                ; e = c - e - carry
 129+ 920E 9B                                   sbc     e                  ;
 130+ 920F 5F                                   ld      e,a                ;
 131+ 9210 78                                   ld      a,b                ; d = b - d - carry
 132+ 9211 9A                                   sbc     d                  ;
 133+ 9212 57                                   ld      d,a                ;
 134+ 9213 FD 7C                                ld      a,iyh              ; as b was larger, take b sign into d
 135+ 9215 E6 80                                and     SignOnly8Bit       ;
 136+ 9217 B2                                   or      d                  ;
 137+ 9218 57                                   ld      d,a                ;
 138+ 9219 C9                                   ret
 139+ 921A
 140+ 921A
 141+ 921A              ;BHL = AHL + DE where AHL = 16 bit + A sign and DE = 15 bit signed
 142+ 921A 47           AddAHLtoDEsigned:       ld      b,a                     ; B = A , C = D (save sign bytes)
 143+ 921B 4A                                   ld      c,d                     ; .
 144+ 921C A9                                   xor     c                       ; A = A xor C
 145+ 921D CB BA                                res     7,d                     ; clear sign bit of D
 146+ 921F 20 02                                jr nz,  .OppositeSigns          ; if A xor C is opposite signs job to A0A1
 147+ 9221 19                                   add     hl,de                   ; HL = HL + DE
 148+ 9222 C9                                   ret                             ; return
 149+ 9223 ED 52        .OppositeSigns:         sbc     hl,de                   ; HL = HL -DE
 150+ 9225 D0                                   ret     nc                      ; if no carry return
 151+ 9226 19                                   add     hl,de                   ; else HL = HL + DE
 152+ 9227 EB                                   ex      de,hl                   ;      swap HL and DE
 153+ 9228 A7                                   and     a                       ;      reset carry
 154+ 9229 ED 52                                sbc     hl,de                   ;      HL = DE - HL (as they were swapped)
 155+ 922B 41                                   ld      b,c                     ;      B = sign of C
 156+ 922C C9                                   ret                             ;      ret
 157+ 922D
 158+ 922D
 159+ 922D
 160+ 922D              ; a = value to add
 161+ 922D              ; b = offset (equivalent to regX)
 162+ 922D              ; returns INWK [x] set to new value
 163+ 922D              addINWKbasigned:
 164+ 922D 21 00 00     		ld 		hl,UBnKxlo                  ; hl = INWK 0
 165+ 9230 4F           		ld      c,a                         ; preserve a
 166+ 9231 78           		ld		a,b
 167+ 9232 ED 31        		add		hl,a                        ; hl = INWK[x]
 168+ 9234 79                   ld      a,c                         ; get back a value
 169+ 9235 E6 80                and     $80                         ; get sign bit from a
 170+ 9237 47                   ld      b,a                         ; now b = sign bit of a
 171+ 9238 79                   ld      a,c                         ; a = original value
 172+ 9239 E6 7F                and     SignMask8Bit                ; a = unsigned version of original value
 173+ 923B              ; hl = unsigned version of INWK0[b]
 174+ 923B              ; a = value to add, also in c which will optimise later code
 175+ 923B              ; b = sign bit of a ( in old code was varT)
 176+ 923B              addhlcsigned:
 177+ 923B 5E                   ld      e,(hl)                      ; de = INKK value
 178+ 923C 23                   inc     hl
 179+ 923D 56                   ld      d,(hl)
 180+ 923E 23                   inc     hl                          ; now pointing a sign
 181+ 923F 7E                   ld      a,(hl)                      ; a = sign bit
 182+ 9240 EB                   ex      de,hl                       ; hl = value now and de = pointer to sign
 183+ 9241 A8                   xor     b                           ; a = resultant sign
 184+ 9242 CB 7F                bit     7,a                         ; is it negative?
 185+ 9244 28 28                jr      z,.postivecalc
 186+ 9246              .negativecalc:
 187+ 9246 7C                   ld      a,h
 188+ 9247 E6 7F                and     SignMask8Bit
 189+ 9249 67                   ld      h,a                         ; strip high bit
 190+ 924A DD 68                ld      ixl,b                       ; save sign bit from b into d
 191+ 924C 06 00                ld      b,0                         ; c = value to subtract so now bc = value to subtract
 192+ 924E ED 42                sbc     hl,bc
 193+ 9250 DD 45                ld      b,ixl                       ; get sign back
 194+ 9252 EB                   ex      de,hl                       ; de = value hl = pointer to sign
 195+ 9253 7E                   ld      a,(hl)                      ;
 196+ 9254 E6 7F                and     SignMask8Bit
 197+ 9256 DE 00                sbc     a,0                         ; subtract carry which could flip sign bit
 198+ 9258 F6 80                or      $80                         ; set bit 0
 199+ 925A A8                   xor     b                           ; flip bit on sign (var T)
 200+ 925B 77                   ld      (hl),a
 201+ 925C 2B                   dec     hl
 202+ 925D 72                   ld      (hl),d
 203+ 925E 2B                   dec     hl
 204+ 925F 73                   ld      (hl),e                      ; write out DE to INKW[x]0,1
 205+ 9260 EB                   ex      de,hl                       ; hl = value de = pointer to start if INKW[x]
 206+ 9261 D8                   ret     c                           ; if carry was set then we can exit now
 207+ 9262              .nocarry:
 208+ 9262 CD 60 97             call    negate16hl                  ; get hl back to positive, a is still inkw+2
 209+ 9265 B0                   or      b                           ; b is still varT
 210+ 9266 EB                   ex      de,hl                       ; de = value hl = pointer to start if INKW[x]
 211+ 9267 73                   ld      (hl),e
 212+ 9268 23                   inc     hl
 213+ 9269 72                   ld      (hl),d
 214+ 926A 23                   inc     hl
 215+ 926B 77                   ld      (hl),a                      ; set sign bit in INKK[x]+2
 216+ 926C EB                   ex      de,hl                       ; hl = value de = pointer to sign
 217+ 926D C9                   ret
 218+ 926E              .postivecalc:
 219+ 926E DD 68                ld      ixl,b
 220+ 9270 06 00                ld      b,0
 221+ 9272 19                   add     hl,de
 222+ 9273 EB                   ex      de,hl
 223+ 9274 DD B5                or      ixl                         ; we don;t need to recover b here
 224+ 9276 77                   ld      (hl),a                      ; push sign into INWK[x]
 225+ 9277 2B                   dec     hl
 226+ 9278 72                   ld      (hl),d
 227+ 9279 2B                   dec     hl
 228+ 927A 73                   ld      (hl),e
 229+ 927B C9                   ret
 230+ 927C
 231+ 927C              ;a = a AND 80 (i.e. bit 7) =>carry       so value is -
 232+ 927C              ;MVT1
 233+ 927C              ;    S = bits 6 to 0 of A
 234+ 927C              ;    A = sign bit => T
 235+ 927C              ;    xor sign bit with ink[x] Sign
 236+ 927C              ;    if negative thn its not an add
 237+ 927C              ;
 238+ 927C              ;        and h, 7F
 239+ 927C              ;        b = 0
 240+ 927C              ;        c = varS
 241+ 927C              ;        subtract INW[X]hilo, bc
 242+ 927C              ;        retain carry
 243+ 927C              ;        get INKW[x]Sign
 244+ 927C              ;        and 7F
 245+ 927C              ;        subtract carry (so will go negtive if negative)
 246+ 927C              ;        xor bit 7 of h with T to flip bit
 247+ 927C              ;        write to INKW[x]Sign
 248+ 927C              ;
 249+ 927C              ;    else
 250+ 927C              ;MV10.
 251+ 927C              ;        add INWK[x]hi,lo, varS
 252+ 927C              ;        or      sign bit
 253+ 927C
 254+ 927C
# file closed: ./Maths/asm_add.asm
 118  927C                  INCLUDE "./Maths/Utilities/AddDEToCash.asm"
# file opened: ./Maths/Utilities/AddDEToCash.asm
   1+ 927C              ; Note its big endian
   2+ 927C 2A 67 88     addDEtoCash:            ld      hl,(Cash)
   3+ 927F 19                                   add     hl,de
   4+ 9280 22 67 88                             ld      (Cash),hl
   5+ 9283 11 00 00                             ld      de,0
   6+ 9286 2A 69 88                             ld      hl,(Cash+2)
   7+ 9289 ED 5A                                adc     hl,de
   8+ 928B 22 69 88                             ld      (Cash+2),hl
   9+ 928E C9                                   ret
  10+ 928F
  11+ 928F 2A 67 88     subDEfromCash:          ld      hl,(Cash)
  12+ 9292 7C                                   ld      a,h
  13+ 9293 B5                                   or      l
  14+ 9294 2A 69 88                             ld      hl,(Cash+2)
  15+ 9297 B4                                   or      h
  16+ 9298 B5                                   or      l
  17+ 9299 C8                                   ret     z               ; No cash return
  18+ 929A B7                                   or      a
  19+ 929B 2A 67 88                             ld      hl,(Cash)
  20+ 929E ED 52                                sbc     hl,de
  21+ 92A0 22 67 88                             ld      (Cash),hl
  22+ 92A3 11 00 00                             ld      de,0
  23+ 92A6 2A 69 88                             ld      hl,(Cash+2)
  24+ 92A9 ED 52                                sbc     hl,de
  25+ 92AB 22 69 88                             ld      (Cash+2),hl
  26+ 92AE                                      JumpOnBitSet h,7,.ZeroCash
  26+ 92AE CB 7C       >                        bit 	7,h
  26+ 92B0 C2 B4 92    >                        jp      nz,.ZeroCash
  27+ 92B3 C9                                   ret
  28+ 92B4 21 00 00     .ZeroCash:              ld      hl,0
  29+ 92B7 22 67 88                             ld      (Cash),hl
  30+ 92BA 22 69 88                             ld      (Cash+2),hl
  31+ 92BD C9                                   ret
  32+ 92BE
# file closed: ./Maths/Utilities/AddDEToCash.asm
 119  92BE                  INCLUDE "./Maths/DIVD3B2.asm"
# file opened: ./Maths/DIVD3B2.asm
   1+ 92BE              ;INPUTS: ahl = dividend cde = divisor
   2+ 92BE              ;OUTPUTS: cde = quotient ahl = remainder
   3+ 92BE 47           Div24by24:              ld b,a
   4+ 92BF E5                                   push hl
   5+ 92C0 DD E1                                pop ix
   6+ 92C2 2E 18                                ld l,24
   7+ 92C4 E5                                   push hl
   8+ 92C5 AF                                   xor a
   9+ 92C6 67                                   ld h,a
  10+ 92C7 6F                                   ld l,a
  11+ 92C8 DD 29        .Div24by24loop:         add ix,ix
  12+ 92CA CB 10                                rl b
  13+ 92CC ED 6A                                adc hl,hl
  14+ 92CE 17                                   rla
  15+ 92CF B9                                   cp c
  16+ 92D0 38 0C                                jr c,.Div24by24skip
  17+ 92D2 20 05                                jr nz,.Div24by24setbit
  18+ 92D4 ED 52                                sbc hl,de
  19+ 92D6 19                                   add hl,de
  20+ 92D7 38 05                                jr c,.Div24by24skip
  21+ 92D9 ED 52        .Div24by24setbit:       sbc hl,de
  22+ 92DB 99                                   sbc a,c
  23+ 92DC DD 23                                inc ix
  24+ 92DE E3           .Div24by24skip:         ex (sp),hl
  25+ 92DF 2D                                   dec l
  26+ 92E0 E3                                   ex (sp),hl
  27+ 92E1 20 E5                                jr nz,.Div24by24loop
  28+ 92E3 D1                                   pop de
  29+ 92E4 48                                   ld c,b
  30+ 92E5 DD E5                                push ix
  31+ 92E7 D1                                   pop de
  32+ 92E8 C9                                   ret
  33+ 92E9
  34+ 92E9 FD 67        Div24by24ASigned:       ld      iyh,a
  35+ 92EB E6 7F                                and     SignMask8Bit
  36+ 92ED CD BE 92                             call    Div24by24
  37+ 92F0 F5                                   push    af
  38+ 92F1 FD 7C                                ld      a,iyh
  39+ 92F3 E6 80                                and     SignOnly8Bit
  40+ 92F5 B1                                   or      c
  41+ 92F6 4F                                   ld      c,a
  42+ 92F7 F1                                   pop     af
  43+ 92F8 C9                                   ret
  44+ 92F9
  45+ 92F9                                      ; CDE = AHL/CDE, AHL = remainder
  46+ 92F9 FD 67        Div24by24LeadSign:      ld      iyh,a           ; Preserve signed in IYL
  47+ 92FB A9                                   xor     c               ; flip sign if negative
  48+ 92FC E6 80                                and     SignOnly8Bit    ; .
  49+ 92FE FD 6F                                ld      iyl,a           ; .
  50+ 9300 79                                   ld      a,c             ; make both values ABS
  51+ 9301 E6 7F                                and     SignMask8Bit    ; .
  52+ 9303 4F                                   ld      c,a             ; .
  53+ 9304 FD 7C                                ld      a,iyh           ; .
  54+ 9306 E6 7F                                and     SignMask8Bit    ; .
  55+ 9308 CD BE 92                             call    Div24by24       ; do abs divide
  56+ 930B FD B5                                or      iyl             ; bring in sign bit
  57+ 930D FD 67                                ld      iyh,a           ; save a
  58+ 930F 79                                   ld      a,c             ; sort sign for c
  59+ 9310 FD B5                                or      iyl             ;
  60+ 9312 4F                                   ld      c,a             ;
  61+ 9313 FD 7C                                ld      a,iyh           ; sort sign of a
  62+ 9315 C9                                   ret
  63+ 9316
  64+ 9316              ; --------------------------------------------------------------
  65+ 9316              ;divdide by 16 using undocumented instrunctions
  66+ 9316              ;Input: BC = Dividend, DE = Divisor, HL = 0
  67+ 9316              ;Output: BC = Quotient, HL = Remainder
  68+ 9316 47           PROJ256mulAdivQ:        ld      b,a
  69+ 9317 0E 00                                ld      c,0
  70+ 9319 16 00                                ld      d,0
  71+ 931B 3A 5B 84                             ld      a,(varQ)
  72+ 931E 5F                                   ld      e,a
  73+ 931F 21 00 00     PROJDIV16UNDOC:         ld      hl,0
  74+ 9322 78                                   ld      a,b
  75+ 9323 06 10                                ld      b,16
  76+ 9325 CB 31        PROJDIV16UNDOCLOOP:     sll     c       ; unroll 16 times
  77+ 9327 17                                   rla             ; ...
  78+ 9328 ED 6A                                adc     hl,hl       ; ...
  79+ 932A ED 52                                sbc     hl,de       ; ...
  80+ 932C 30 02                                jr      nc,PROJDIV16UNDOCSKIP       ; ...
  81+ 932E 19                                   add     hl,de       ; ...
  82+ 932F 0D                                   dec     c       ; ...
  83+ 9330 10 F3        PROJDIV16UNDOCSKIP:     djnz    PROJDIV16UNDOCLOOP
  84+ 9332 79                                   ld      a,c
  85+ 9333 32 5C 84                             ld      (varR),a
  86+ 9336 C9                                   ret
  87+ 9337
  88+ 9337
  89+ 9337
  90+ 9337
# file closed: ./Maths/DIVD3B2.asm
 120  9337                  INCLUDE "./Maths/multiply.asm"
# file opened: ./Maths/multiply.asm
   1+ 9337              HLequSRmulQdiv256:      ;X.Y=x1lo.S*M/256  	\ where M/256 is gradient
   2+ 9337 2A 5C 84                             ld  hl,(varRS)
   3+ 933A 3A 5B 84                             ld  a,(varQ)
   4+ 933D C5 D5        HLeqyHLmulAdiv256:      push    bc,,de
   5+ 933F 11 00 00                             ld  de,0        ; de = XY
   6+ 9342 47                                   ld  b,a         ; b = Q
   7+ 9343                                      ShiftHLRight1
   7+ 9343 CB 3C       >			   srl h
   7+ 9345 CB 1D       >			   rr  l
   8+ 9347 CB 20                                sla b
   9+ 9349 30 03                                jr  nc,.LL126
  10+ 934B EB           .LL125:                 ex de,hl
  11+ 934C 19                                   add hl,de
  12+ 934D EB                                   ex  de,hl       ; de = de + rs
  13+ 934E              .LL126:                 ShiftHLRight1
  13+ 934E CB 3C       >			   srl h
  13+ 9350 CB 1D       >			   rr  l
  14+ 9352 CB 20                                sla b
  15+ 9354 38 F5                                jr      c,.LL125
  16+ 9356 20 F6                                jr      nz,.LL126
  17+ 9358 EB                                   ex      de,hl   ; hl = result
  18+ 9359 D1 C1                                pop     bc,,de
  19+ 935B C9                                   ret
  20+ 935C
  21+ 935C
  22+ 935C              MacroDEEquQmulASigned:  MACRO
  23+ 935C ~                                    ld      d,a                         ; save a into d
  24+ 935C ~                                    ld      a,(varQ)
  25+ 935C ~                                    ld      e,a
  26+ 935C ~                                    xor     d                           ; a = a xor var Q
  27+ 935C ~                                    and     SignOnly8Bit
  28+ 935C ~                                    ld      b,a                         ; b = sign of a xor q
  29+ 935C ~                                    ld      a,d                         ; d = abs d (or a reg)
  30+ 935C ~                                    and     SignMask8Bit
  31+ 935C ~                                    ld      d,a
  32+ 935C ~                                    ld      a,e                         ; e = abs e (or varQ)
  33+ 935C ~                                    and     SignMask8Bit
  34+ 935C ~                                    ld      e,a
  35+ 935C ~                                    mul                                 ; de = a * Q
  36+ 935C ~                                    ld      a,d
  37+ 935C ~                                    or      b                           ; de = a * Q leading sign bit
  38+ 935C ~                                    ld      d,a
  39+ 935C                                      ENDM
  40+ 935C
  41+ 935C
  42+ 935C
  43+ 935C                                 ; .MAD	\ -> &22AD  \ Multiply and Add  (DE also) X.A(Lo.Hi) = Q*A + R.S (Lo.Hi)
  44+ 935C              madXAequQmulAaddRS:     MacroDEEquQmulASigned
  44+ 935C 57          >                        ld      d,a                         ; save a into d
  44+ 935D 3A 5B 84    >                        ld      a,(varQ)
  44+ 9360 5F          >                        ld      e,a
  44+ 9361 AA          >                        xor     d                           ; a = a xor var Q
  44+ 9362 E6 80       >                        and     SignOnly8Bit
  44+ 9364 47          >                        ld      b,a                         ; b = sign of a xor q
  44+ 9365 7A          >                        ld      a,d                         ; d = abs d (or a reg)
  44+ 9366 E6 7F       >                        and     SignMask8Bit
  44+ 9368 57          >                        ld      d,a
  44+ 9369 7B          >                        ld      a,e                         ; e = abs e (or varQ)
  44+ 936A E6 7F       >                        and     SignMask8Bit
  44+ 936C 5F          >                        ld      e,a
  44+ 936D ED 30       >                        mul                                 ; de = a * Q
  44+ 936F 7A          >                        ld      a,d
  44+ 9370 B0          >                        or      b                           ; de = a * Q leading sign bit
  44+ 9371 57          >                        ld      d,a
  45+ 9372 2A 5C 84     madDEaddRS:             ld		hl,(varR)
  46+ 9375 CD 7E 93                             call	madXAAddHLDESigned
  47+ 9378 EB                                   ex      de,hl                       ; de = R.S + DE
  48+ 9379                                      ClearCarryFlag
  48+ 9379 B7          >                        or a
  49+ 937A DD 6B                                ld      ixl,e
  50+ 937C 7A                                   ld      a,d
  51+ 937D C9                                   ret
  52+ 937E
  53+ 937E
  54+ 937E 7C           madXAAddHLDESigned:     ld      a,h
  55+ 937F E6 80                                and     SignOnly8Bit
  56+ 9381 47                                   ld      b,a                         ;save sign bit in b
  57+ 9382 AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
  58+ 9383                                      JumpIfNegative .ADDHLDEOppSGN        ;Signs are opposite there fore we can subtract to get difference
  58+ 9383 FA 9B 93    >                        jp		m, .ADDHLDEOppSGN
  59+ 9386 78           .ADDHLDESameSigns:       ld      a,b
  60+ 9387 B2                                   or      d
  61+ 9388                                      JumpIfNegative .ADDHLDESameNeg       ; optimisation so we can just do simple add if both positive
  61+ 9388 FA 8D 93    >                        jp		m, .ADDHLDESameNeg
  62+ 938B 19                                   add     hl,de
  63+ 938C C9                                   ret
  64+ 938D 7C           .ADDHLDESameNeg:         ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
  65+ 938E E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
  66+ 9390 67                                   ld      h,a
  67+ 9391 7A                                   ld      a,d
  68+ 9392 E6 7F                                and     SignMask8Bit
  69+ 9394 57                                   ld      d,a
  70+ 9395 19                                   add     hl,de
  71+ 9396 3E 80                                ld      a,SignOnly8Bit
  72+ 9398 B4                                   or      h                           ; now set bit for negative value, we won't bother with overflow for now TODO
  73+ 9399 67                                   ld      h,a
  74+ 939A C9                                   ret
  75+ 939B 7C           .ADDHLDEOppSGN:          ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit                     ; here HL and DE are opposite
  76+ 939C E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
  77+ 939E 67                                   ld      h,a
  78+ 939F 7A                                   ld      a,d
  79+ 93A0 E6 7F                                and     SignMask8Bit
  80+ 93A2 57                                   ld      d,a
  81+ 93A3 B7                                   or      a
  82+ 93A4 ED 52                                sbc     hl,de
  83+ 93A6 38 04                                jr      c,.ADDHLDEOppInvert
  84+ 93A8 78           .ADDHLDEOppSGNNoCarry:   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
  85+ 93A9 B4                                   or      h
  86+ 93AA 67                                   ld      h,a                         ; set the previou sign value
  87+ 93AB C9                                   ret
  88+ 93AC              .ADDHLDEOppInvert:       NegHL                                                   ; we need to flip the sign and 2'c the Hl result
  88+ 93AC AF          >                    xor a
  88+ 93AD 95          >                    sub l
  88+ 93AE 6F          >                    ld l,a
  88+ 93AF 9F          >                    sbc a,a
  88+ 93B0 94          >                    sub h
  88+ 93B1 67          >                    ld h,a
  89+ 93B2 78                                   ld      a,b
  90+ 93B3 EE 80                                xor     SignOnly8Bit                ; flip sign bit
  91+ 93B5 B4                                   or      h
  92+ 93B6 67                                   ld      h,a                         ; recover sign
  93+ 93B7 C9                                   ret
  94+ 93B8
  95+ 93B8
  96+ 93B8                  ; multiplication of 16-bit number and 8-bit number into a 24-bit product
  97+ 93B8                  ;
  98+ 93B8                  ; enter : hl = 16-bit multiplier   = x
  99+ 93B8                  ;          e =  8-bit multiplicand = y
 100+ 93B8                  ;
 101+ 93B8                  ; exit  : ahl = 24-bit product
 102+ 93B8                  ;         carry reset
 103+ 93B8                  ;
 104+ 93B8                  ; uses  : af, de, hl
 105+ 93B8 54           AHLequHLmulE:           ld d,h                      ; xh
 106+ 93B9 63                                   ld h,e                      ; yl
 107+ 93BA ED 30                                mul de                      ; xh*yl
 108+ 93BC EB                                   ex de,hl
 109+ 93BD ED 30                                mul de                      ; yl*xl, hl = xh*yl
 110+ 93BF
 111+ 93BF 7A                                   ld  a,d                     ; sum products
 112+ 93C0 85                                   add a,l
 113+ 93C1 57                                   ld  d,a
 114+ 93C2 EB                                   ex de,hl
 115+ 93C3
 116+ 93C3 7A                                   ld  a,d
 117+ 93C4 CE 00                                adc a,0
 118+ 93C6 C9                                   ret
 119+ 93C7
 120+ 93C7
 121+ 93C7
 122+ 93C7                 ; multiplication of two 16-bit numbers into a 32-bit product
 123+ 93C7                 ;
 124+ 93C7                 ; enter : de = 16-bit multiplicand = y
 125+ 93C7                 ;         hl = 16-bit multiplicand = x
 126+ 93C7                 ;
 127+ 93C7                 ; exit  : dehl = 32-bit product
 128+ 93C7                 ;         carry reset
 129+ 93C7                 ;
 130+ 93C7                 ; uses  : af, bc, de, hl
 131+ 93C7
 132+ 93C7
 133+ 93C7
 134+ 93C7 45           DEHLequDEmulHL:         ld b,l                      ; x0
 135+ 93C8 4B                                   ld c,e                      ; y0
 136+ 93C9 5D                                   ld e,l                      ; x0
 137+ 93CA 6A                                   ld l,d
 138+ 93CB E5                                   push hl                     ; x1 y1
 139+ 93CC 69                                   ld l,c                      ; y0
 140+ 93CD              ; bc = x0 y0, de = y1 x0,  hl = x1 y0,  stack = x1 y1
 141+ 93CD ED 30                                mul de                      ; y1*x0
 142+ 93CF EB                                   ex de,hl
 143+ 93D0 ED 30                                mul de                      ; x1*y0
 144+ 93D2
 145+ 93D2 AF                                   xor a                       ; zero A
 146+ 93D3 19                                   add hl,de                   ; sum cross products p2 p1
 147+ 93D4 8F                                   adc a,a                     ; capture carry p3
 148+ 93D5
 149+ 93D5 59                                   ld e,c                      ; x0
 150+ 93D6 50                                   ld d,b                      ; y0
 151+ 93D7 ED 30                                mul de                      ; y0*x0
 152+ 93D9
 153+ 93D9 47                                   ld b,a                      ; carry from cross products
 154+ 93DA 4C                                   ld c,h                      ; LSB of MSW from cross products
 155+ 93DB
 156+ 93DB 7A                                   ld a,d
 157+ 93DC 85                                   add a,l
 158+ 93DD 67                                   ld h,a
 159+ 93DE 6B                                   ld l,e                      ; LSW in HL p1 p0
 160+ 93DF
 161+ 93DF D1                                   pop de
 162+ 93E0 ED 30                                mul de                      ; x1*y1
 163+ 93E2
 164+ 93E2 EB                                   ex de,hl
 165+ 93E3 ED 4A                                adc hl,bc
 166+ 93E5 EB                                   ex de,hl                    ; de = final MSW
 167+ 93E6
 168+ 93E6 C9                                   ret
 169+ 93E7
 170+ 93E7              ; multiplication of two 16-bit numbers into a 16-bit product
 171+ 93E7              ; enter : de = 16-bit multiplicand
 172+ 93E7              ;         hl = 16-bit multiplicand
 173+ 93E7              ; exit  : hl = 16-bit product
 174+ 93E7              ;         carry reset
 175+ 93E7              ; maths is
 176+ 93E7              ;        hl = y , de= x
 177+ 93E7              ;        hl = xhi,ylo + (yhigh * xlow)
 178+ 93E7              ;        hl = yhih & xlo + x
 179+ 93E7              ;
 180+ 93E7              ;
 181+ 93E7              ; uses  : af, bc, de, hl
 182+ 93E7 C5           mulDEbyHL:              push    bc
 183+ 93E8 7A                                   ld a,d                      ; a = xh
 184+ 93E9 54                                   ld d,h                      ; d = yh
 185+ 93EA 67                                   ld h,a                      ; h = xh
 186+ 93EB 4B                                   ld c,e                      ; c = xl
 187+ 93EC 45                                   ld b,l                      ; b = yl
 188+ 93ED ED 30                                mul                         ; yh * yl
 189+ 93EF EB                                   ex de,hl
 190+ 93F0 ED 30                                mul                         ; xh * yl
 191+ 93F2 19                                   add hl,de                   ; add cross products
 192+ 93F3 59                                   ld e,c
 193+ 93F4 50                                   ld d,b
 194+ 93F5 ED 30                                mul                         ; yl * xl
 195+ 93F7 7D                                   ld a,l                      ; cross products lsb
 196+ 93F8 82                                   add a,d                     ; add to msb final
 197+ 93F9 67                                   ld h,a
 198+ 93FA 6B                                   ld l,e                      ; hl = final
 199+ 93FB                                      ; 83 cycles, 19 bytes
 200+ 93FB AF                                   xor a                       ; reset carry
 201+ 93FC C1                                   pop     bc
 202+ 93FD C9                                   ret
 203+ 93FE
 204+ 93FE
 205+ 93FE              ; CHL = multiplicand D = multiplier
 206+ 93FE              ; DCHL = CHL * D
 207+ 93FE 7A           mulCHLbyDSigned:        ld      a,d                 ; get sign from d
 208+ 93FF AC                                   xor     h                   ; xor with h to get resultant sign
 209+ 9400 E6 80                                and     SignOnly8Bit        ; .
 210+ 9402 FD 67                                ld      iyh,a               ; iyh = copy of sign
 211+ 9404 79                                   ld      a,c                 ; now CHL = ABS (CHL)
 212+ 9405 E6 7F                                and     SignMask8Bit        ; .
 213+ 9407 4F                                   ld      c,a                 ; .
 214+ 9408 7A                                   ld      a,d                 ; d = ABS D
 215+ 9409 E6 7F                                and     SignMask8Bit        ; .
 216+ 940B              ; At this point CHL = ABS (HLE), A = ABS(D)
 217+ 940B 57           .mul1:                  ld      d,a                 ; first do D * L
 218+ 940C 5D                                   ld      e,l                 ; .
 219+ 940D ED 30                                mul     de                  ; DE = L * D
 220+ 940F 08                                   ex      af,af'              ; save multiplier
 221+ 9410 6B                                   ld      l,e                 ; L = p0
 222+ 9411 7A                                   ld      a,d                 ; carry byte
 223+ 9412 08                                   ex      af,af'              ; retrieve muliplier and save carry byte along with flags
 224+ 9413 5C           .mul2:                  ld      e,h                 ; byte 2 of multiplicand
 225+ 9414 57                                   ld      d,a                 ; and multiplier
 226+ 9415 ED 30                                mul     de                  ; now its D & L
 227+ 9417 08                                   ex      af,af'              ; get back carry byte with flags
 228+ 9418 83           .carrybyte1:            add     a,e                 ; add low byte carry to result and retain carry too through next instructions
 229+ 9419 67                                   ld      h,a                 ; h = P1
 230+ 941A 7A                                   ld      a,d                 ; a = carry byte
 231+ 941B 08                                   ex      af,af'              ; save carry byte and get back multiplier with flags
 232+ 941C 59           .mul3:                  ld      e,c                 ; byte 3 of multiplicand
 233+ 941D 57                                   ld      d,a                 ;
 234+ 941E ED 30                                mul     de                  ;
 235+ 9420 08                                   ex      af,af'              ; get back carry byte and carry prior to first add
 236+ 9421 8B                                   adc     a,e                 ;
 237+ 9422 FD B4                                or      iyh                 ; recover saved resultant sign
 238+ 9424 4F                                   ld      c,a                 ; c byte 3. Note the value range allowed can never cause a byte 3 carry
 239+ 9425 C9                                   ret
 240+ 9426
 241+ 9426              ;  CHL = 53456 D = 1E
 242+ 9426              ;  56 * 1E = A14 L = 14 carry = 0A
 243+ 9426              ;  34 * 1E = 618 H = 18 +A = 22 carry = 6
 244+ 9426              ;  5  * 1E = 096 C = 96 + 6 = 9C
 245+ 9426              ;  CHL = 9C2214
 246+ 9426
 247+ 9426              ; DELC = HLE * D, uses HL, DE, C , A , IYH
 248+ 9426              ; HLE = multiplicand D = multiplier
 249+ 9426              ; tested by mathstestsun.asm all passed
 250+ 9426 7A           mulHLEbyDSigned:        ld      a,d                 ; get sign from d
 251+ 9427 AC                                   xor     h                   ; xor with h to get resultant sign
 252+ 9428 E6 80                                and     SignOnly8Bit        ; .
 253+ 942A FD 67                                ld      iyh,a               ; iyh = copy of sign
 254+ 942C 7C                                   ld      a,h                 ; now HLE = ABS (HLE)
 255+ 942D E6 7F                                and     SignMask8Bit        ; .
 256+ 942F 67                                   ld      h,a                 ; .
 257+ 9430 7A                                   ld      a,d                 ; d = ABS D
 258+ 9431 E6 7F                                and     SignMask8Bit        ; .
 259+ 9433 57                                   ld      d,a                 ; .
 260+ 9434              ; At this point HLE = ABS (HLE), A = ABS(D)
 261+ 9434 ED 30        .mul1:                  mul     de                  ; C = E * D
 262+ 9436 08                                   ex      af,af'              ; save mulitplier
 263+ 9437 4B                                   ld      c,e                 ; C = p0
 264+ 9438 7A                                   ld      a,d                 ; save carry and get back multiplier
 265+ 9439 08                                   ex      af,af'
 266+ 943A 5D           .mul2:                  ld      e,l                 ; L = L * D
 267+ 943B 57                                   ld      d,a                 ; .
 268+ 943C ED 30                                mul     de                  ; .
 269+ 943E 08                                   ex      af,af'              ; .
 270+ 943F 83           .carrybyte1:            add     a,e                 ; L = L + carry byte
 271+ 9440 6F                                   ld      l,a                 ; .
 272+ 9441 7A                                   ld      a,d
 273+ 9442 08                                   ex      af,af'              ; save new carry byte
 274+ 9443 5C           .mul3:                  ld      e,h                 ; e = H * D
 275+ 9444 57                                   ld      d,a
 276+ 9445 ED 30                                mul     de
 277+ 9447 08                                   ex      af,af'
 278+ 9448 8B                                   adc     a,e                 ;
 279+ 9449 5F                                   ld      e,a
 280+ 944A FD 54                                ld      d,iyh
 281+ 944C C9                                   ret
 282+ 944D
 283+ 944D
 284+ 944D              ; multiplication of two S156-bit numbers into a 16-bit 2'd compliment product
 285+ 944D              ; enter : de = 16-bit multiplicand
 286+ 944D              ;         hl = 16-bit multiplicand
 287+ 944D              ; exit  : hl = 16-bit product
 288+ 944D              ;         carry reset
 289+ 944D              ;
 290+ 944D              ; uses  : af, bc, de, hl
 291+ 944D 00           mulDEbyHLSignByte       DB      0
 292+ 944E AF           mulDEbyHLSgnTo2c:       xor     a
 293+ 944F 32 4D 94                             ld      (mulDEbyHLSignByte),a
 294+ 9452 7A           .SignDE:                ld      a,d
 295+ 9453 ED 27 80                             test    $80
 296+ 9456 28 08                                jr      z,.SignHL
 297+ 9458 E6 7F        .NegativeDE:            and     $7F
 298+ 945A 57                                   ld      d,a
 299+ 945B 3E 80                                ld      a,$80
 300+ 945D 32 4D 94                             ld      (mulDEbyHLSignByte),a
 301+ 9460 7C           .SignHL:                ld      a,h
 302+ 9461 ED 27 80                             test    $80
 303+ 9464 28 0B                                jr      z,.AbsoluteMultiply
 304+ 9466 E6 7F        .NegativeHL:            and     $7F
 305+ 9468 67                                   ld      h,a
 306+ 9469 3A 4D 94                             ld      a,(mulDEbyHLSignByte)
 307+ 946C EE 80                                xor     $80
 308+ 946E 32 4D 94                             ld      (mulDEbyHLSignByte),a
 309+ 9471 CD E7 93     .AbsoluteMultiply:      call    mulDEbyHL
 310+ 9474 3A 4D 94     .RecoverSign:           ld      a,(mulDEbyHLSignByte)
 311+ 9477 ED 27 80                             test    $80
 312+ 947A C8                                   ret     z
 313+ 947B AF           .Negateghl: 			xor 	a
 314+ 947C 95                                   sub 	l
 315+ 947D 6F                                   ld 		l,a
 316+ 947E 9F                                   sbc 	a,a
 317+ 947F 94                                   sub 	h
 318+ 9480 67                                   ld 		h,a
 319+ 9481 C9                                   ret
 320+ 9482
 321+ 9482 AF           mulDESgnbyHLUnsgnTo2c:  xor     a
 322+ 9483 32 4D 94                             ld      (mulDEbyHLSignByte),a
 323+ 9486 7A           .SignDE:                ld      a,d
 324+ 9487 ED 27 80                             test    $80
 325+ 948A 28 08                                jr      z,.AbsoluteMultiply
 326+ 948C E6 7F        .NegativeDE:            and     $7F
 327+ 948E 57                                   ld      d,a
 328+ 948F 3E 80                                ld      a,$80
 329+ 9491 32 4D 94                             ld      (mulDEbyHLSignByte),a
 330+ 9494 CD E7 93     .AbsoluteMultiply:      call    mulDEbyHL
 331+ 9497 3A 4D 94     .RecoverSign:           ld      a,(mulDEbyHLSignByte)
 332+ 949A ED 27 80                             test    $80
 333+ 949D C8                                   ret     z
 334+ 949E AF           .Negateghl:             xor 	a
 335+ 949F 95                                   sub 	l
 336+ 94A0 6F                                   ld 		l,a
 337+ 94A1 9F                                   sbc 	a,a
 338+ 94A2 94                                   sub 	h
 339+ 94A3 67                                   ld 		h,a
 340+ 94A4 C9                                   ret
 341+ 94A5
 342+ 94A5
# file closed: ./Maths/multiply.asm
 121  94A5                  INCLUDE "./Maths/asm_square.asm"
# file opened: ./Maths/asm_square.asm
   1+ 94A5              ; "ASM_SQUA : TESTGOOD"
   2+ 94A5              ; "AP = A^2 A = low,P = hi"
   3+ 94A5
   4+ 94A5              inline_squde: MACRO
   5+ 94A5 ~            			ld	e,a
   6+ 94A5 ~            			ld  d,a
   7+ 94A5 ~            			mul
   8+ 94A5              			ENDM
   9+ 94A5
  10+ 94A5              inline_squa: MACRO
  11+ 94A5 ~            			ld	e,a
  12+ 94A5 ~            			ld  d,a
  13+ 94A5 ~            			mul
  14+ 94A5 ~            			ld	a,e
  15+ 94A5              			ENDM
  16+ 94A5
  17+ 94A5
  18+ 94A5              asm_squa:
  19+ 94A5 E6 7F        	and SignMask8Bit
  20+ 94A7              ; "ASM SQUA2 : TESTGOOD"
  21+ 94A7              ; "AP = A^2 A = low,P = hi singed"
  22+ 94A7              asm_squa2:
  23+ 94A7 5F           	ld e, a
  24+ 94A8 57           	ld d,a
  25+ 94A9 ED 30        	mul
  26+ 94AB ED 53 58 83  	ld (varP),de
  27+ 94AF 7B           	ld a,e
  28+ 94B0 C9           	ret
# file closed: ./Maths/asm_square.asm
 122  94B1                  INCLUDE "./Maths/asm_sqrt.asm"
# file opened: ./Maths/asm_sqrt.asm
   1+ 94B1              ; "ASM SQRT : TESTGOOD"
   2+ 94B1              ; "16-bit integer square root"
   3+ 94B1              ; "call with de = number to square root"
   4+ 94B1              ; "returns   hl = square root"
   5+ 94B1              ; "corrupts  bc, de"
   6+ 94B1              asm_sqrt:
   7+ 94B1 01 00 80     	ld bc,$8000
   8+ 94B4 61           	ld h,c
   9+ 94B5 69           	ld l,c
  10+ 94B6              .sqrloop:
  11+ 94B6 CB 38        	srl b
  12+ 94B8 CB 19        	rr c
  13+ 94BA 09           	add hl,bc
  14+ 94BB EB           	ex de,hl
  15+ 94BC ED 52        	sbc hl,de
  16+ 94BE 38 04        	jr c,.sqrbit
  17+ 94C0 EB           	ex de,hl
  18+ 94C1 09           	add hl,bc
  19+ 94C2 18 05        	jr .sqrfi
  20+ 94C4              .sqrbit:
  21+ 94C4 19           	add hl,de
  22+ 94C5 EB           	ex de,hl
  23+ 94C6 B7           	or a
  24+ 94C7 ED 42        	sbc hl,bc
  25+ 94C9              .sqrfi:
  26+ 94C9 CB 3C        	srl h
  27+ 94CB CB 1D        	rr l
  28+ 94CD CB 38        	srl b
  29+ 94CF CB 19        	rr c
  30+ 94D1 30 E3        	jr nc,.sqrloop
  31+ 94D3 C9           	ret
  32+ 94D4
  33+ 94D4
  34+ 94D4              sqrtQR:					; Q = SQR(Qlo.Rhi) Q <~127
  35+ 94D4 3A 5B 84     	ld		a,(varQ)
  36+ 94D7 5F           	ld		e,a
  37+ 94D8 3A 5C 84     	ld		a,(varR)
  38+ 94DB 57           	ld		d,a
  39+ 94DC CD B1 94     	call	asm_sqrt
  40+ 94DF 7D               ld      a,l
  41+ 94E0 32 5B 84     	ld		(varQ),a
  42+ 94E3 C9           	ret
  43+ 94E4
# file closed: ./Maths/asm_sqrt.asm
 123  94E4                  INCLUDE "./Maths/asm_divide.asm"
# file opened: ./Maths/asm_divide.asm
   1+ 94E4              ;
   2+ 94E4              ;   Set flags E to 11111110
   3+ 94E4              ;   Loop:   A << 2
   4+ 94E4              ;           if carry was 0
   5+ 94E4              ;               if a >= D
   6+ 94E4              ;                   A = A - D
   7+ 94E4              ;                   clear carry (probably irrelevant really)
   8+ 94E4              ;           else
   9+ 94E4
  10+ 94E4              ;               sla flags << bringing in carry of 1
  11+ 94E4              ;               if bit 7 of flag was set then loop
  12+ 94E4              ;                                        elase a = e and exit
  13+ 94E4              ;
  14+ 94E4              ;
  15+ 94E4
  16+ 94E4
  17+ 94E4              AEquAmul256DivD:        JumpIfAGTENusng  d, .Ll28Exit255
  17+ 94E4 BA          >                        cp     d
  17+ 94E5 D2 03 95    >                        jp		nc,.Ll28Exit255
  18+ 94E8 1E FE                                ld      e,%11111110                 ; Set R to have bits 1-7 set, so we can rotate through 7
  19+ 94EA CB 27        .DivideLoop:            sla     a
  20+ 94EC 38 0D                                jr      c,.LL29
  21+ 94EE                                      JumpIfALTNusng  d, .SkipSub         ; will jump if carry set, so we need to reset on the rol
  21+ 94EE BA          >                        cp      d
  21+ 94EF DA F4 94    >                        jp		c, .SkipSub
  22+ 94F2 92                                   sub     d
  23+ 94F3                                      ClearCarryFlag                      ; reset clarry as it will be complimented for rotate as 6502 does carry flags inverted
  23+ 94F3 B7          >                        or a
  24+ 94F4              .SkipSub:               FlipCarryFlag                       ; if we did the subtract the carry will be clear so we need to invert to roll in.
  24+ 94F4 3F          >                        ccf
  25+ 94F5 CB 13                                rl      e
  26+ 94F7 38 F1                                jr      c,.DivideLoop
  27+ 94F9 7B                                   ld      a,e
  28+ 94FA C9                                   ret
  29+ 94FB 92           .LL29:                  sub     d                           ; A >= Q, so set A = A - Q
  30+ 94FC                                      SetCarryFlag                        ; Set the C flag to rotate into the result in R
  30+ 94FC 37          >                        scf
  31+ 94FD CB 13                                rl      e                           ; rotate counter e left
  32+ 94FF 38 E9                                jr      c,.DivideLoop               ; if a bit was spat off teh end then loop
  33+ 9501 7B                                   ld      a,e                         ; stick result in a
  34+ 9502 C9                                   ret
  35+ 9503 3E FF        .Ll28Exit255:           ld  a,255                           ; Fail with FF as result
  36+ 9505 C9                                   ret
  37+ 9506
  38+ 9506
  39+ 9506              ; Divide 8-bit values
  40+ 9506              ; In: Divide E by divider C
  41+ 9506              ; Out: A = result, B = rest
  42+ 9506              ;
  43+ 9506              ;;;Div8:
  44+ 9506              ;;;    xor a
  45+ 9506              ;;;    ld b,8
  46+ 9506              ;;;Div8_Loop:
  47+ 9506              ;;;    rl e
  48+ 9506              ;;;    rla
  49+ 9506              ;;;    sub c
  50+ 9506              ;;;    jr nc,Div8_NoAdd
  51+ 9506              ;;;    add a,c
  52+ 9506              ;;;Div8_NoAdd:
  53+ 9506              ;;;    djnz Div8_Loop
  54+ 9506              ;;;    ld b,a0
  55+ 9506              ;;;    ld a,e
  56+ 9506              ;;;    rla
  57+ 9506              ;;;    cpl
  58+ 9506              ;;;    ret
  59+ 9506
  60+ 9506              ;;Inputs: DE is the numerator, BC is the divisor
  61+ 9506              ;;Outputs: DE is the result
  62+ 9506              ;;         A is a copy of E
  63+ 9506              ;;         HL is the remainder
  64+ 9506              ;;         BC is not changed
  65+ 9506              ;; so DE = DE /BC
  66+ 9506              ;140 bytes
  67+ 9506              ;145cc
  68+ 9506
  69+ 9506              MacroDEDivBC:       MACRO
  70+ 9506 ~                                rla
  71+ 9506 ~                                adc     hl,hl
  72+ 9506 ~                                sbc     hl,bc
  73+ 9506 ~                                jr      nc,$+3
  74+ 9506 ~                                add     hl,bc
  75+ 9506                                  ENDM
  76+ 9506
  77+ 9506              DEequDEDivBC:
  78+ 9506 AF               xor a
  79+ 9507 ED 62            sbc hl,hl
  80+ 9509 7A               ld a,d
  81+ 950A                  MacroDEDivBC
  81+ 950A 17          >                    rla
  81+ 950B ED 6A       >                    adc     hl,hl
  81+ 950D ED 42       >                    sbc     hl,bc
  81+ 950F 30 01       >                    jr      nc,$+3
  81+ 9511 09          >                    add     hl,bc
  82+ 9512                  MacroDEDivBC
  82+ 9512 17          >                    rla
  82+ 9513 ED 6A       >                    adc     hl,hl
  82+ 9515 ED 42       >                    sbc     hl,bc
  82+ 9517 30 01       >                    jr      nc,$+3
  82+ 9519 09          >                    add     hl,bc
  83+ 951A                  MacroDEDivBC
  83+ 951A 17          >                    rla
  83+ 951B ED 6A       >                    adc     hl,hl
  83+ 951D ED 42       >                    sbc     hl,bc
  83+ 951F 30 01       >                    jr      nc,$+3
  83+ 9521 09          >                    add     hl,bc
  84+ 9522                  MacroDEDivBC
  84+ 9522 17          >                    rla
  84+ 9523 ED 6A       >                    adc     hl,hl
  84+ 9525 ED 42       >                    sbc     hl,bc
  84+ 9527 30 01       >                    jr      nc,$+3
  84+ 9529 09          >                    add     hl,bc
  85+ 952A                  MacroDEDivBC
  85+ 952A 17          >                    rla
  85+ 952B ED 6A       >                    adc     hl,hl
  85+ 952D ED 42       >                    sbc     hl,bc
  85+ 952F 30 01       >                    jr      nc,$+3
  85+ 9531 09          >                    add     hl,bc
  86+ 9532                  MacroDEDivBC
  86+ 9532 17          >                    rla
  86+ 9533 ED 6A       >                    adc     hl,hl
  86+ 9535 ED 42       >                    sbc     hl,bc
  86+ 9537 30 01       >                    jr      nc,$+3
  86+ 9539 09          >                    add     hl,bc
  87+ 953A                  MacroDEDivBC
  87+ 953A 17          >                    rla
  87+ 953B ED 6A       >                    adc     hl,hl
  87+ 953D ED 42       >                    sbc     hl,bc
  87+ 953F 30 01       >                    jr      nc,$+3
  87+ 9541 09          >                    add     hl,bc
  88+ 9542                  MacroDEDivBC
  88+ 9542 17          >                    rla
  88+ 9543 ED 6A       >                    adc     hl,hl
  88+ 9545 ED 42       >                    sbc     hl,bc
  88+ 9547 30 01       >                    jr      nc,$+3
  88+ 9549 09          >                    add     hl,bc
  89+ 954A 17               rla
  90+ 954B 2F               cpl
  91+ 954C 57               ld d,a
  92+ 954D
  93+ 954D 7B               ld a,e
  94+ 954E                  MacroDEDivBC
  94+ 954E 17          >                    rla
  94+ 954F ED 6A       >                    adc     hl,hl
  94+ 9551 ED 42       >                    sbc     hl,bc
  94+ 9553 30 01       >                    jr      nc,$+3
  94+ 9555 09          >                    add     hl,bc
  95+ 9556                  MacroDEDivBC
  95+ 9556 17          >                    rla
  95+ 9557 ED 6A       >                    adc     hl,hl
  95+ 9559 ED 42       >                    sbc     hl,bc
  95+ 955B 30 01       >                    jr      nc,$+3
  95+ 955D 09          >                    add     hl,bc
  96+ 955E                  MacroDEDivBC
  96+ 955E 17          >                    rla
  96+ 955F ED 6A       >                    adc     hl,hl
  96+ 9561 ED 42       >                    sbc     hl,bc
  96+ 9563 30 01       >                    jr      nc,$+3
  96+ 9565 09          >                    add     hl,bc
  97+ 9566                  MacroDEDivBC
  97+ 9566 17          >                    rla
  97+ 9567 ED 6A       >                    adc     hl,hl
  97+ 9569 ED 42       >                    sbc     hl,bc
  97+ 956B 30 01       >                    jr      nc,$+3
  97+ 956D 09          >                    add     hl,bc
  98+ 956E                  MacroDEDivBC
  98+ 956E 17          >                    rla
  98+ 956F ED 6A       >                    adc     hl,hl
  98+ 9571 ED 42       >                    sbc     hl,bc
  98+ 9573 30 01       >                    jr      nc,$+3
  98+ 9575 09          >                    add     hl,bc
  99+ 9576                  MacroDEDivBC
  99+ 9576 17          >                    rla
  99+ 9577 ED 6A       >                    adc     hl,hl
  99+ 9579 ED 42       >                    sbc     hl,bc
  99+ 957B 30 01       >                    jr      nc,$+3
  99+ 957D 09          >                    add     hl,bc
 100+ 957E                  MacroDEDivBC
 100+ 957E 17          >                    rla
 100+ 957F ED 6A       >                    adc     hl,hl
 100+ 9581 ED 42       >                    sbc     hl,bc
 100+ 9583 30 01       >                    jr      nc,$+3
 100+ 9585 09          >                    add     hl,bc
 101+ 9586                  MacroDEDivBC
 101+ 9586 17          >                    rla
 101+ 9587 ED 6A       >                    adc     hl,hl
 101+ 9589 ED 42       >                    sbc     hl,bc
 101+ 958B 30 01       >                    jr      nc,$+3
 101+ 958D 09          >                    add     hl,bc
 102+ 958E 17               rla
 103+ 958F 2F               cpl
 104+ 9590 5F               ld e,a
 105+ 9591 C9               ret
 106+ 9592
 107+ 9592
 108+ 9592
 109+ 9592              ;divdide by 16 using undocumented instrunctions
 110+ 9592              ;Input: BC = Dividend, DE = Divisor, HL = 0
 111+ 9592              ;Output: BC = Quotient, HL = Remainder
 112+ 9592              ; Our use
 113+ 9592              ; BC = A0
 114+ 9592              ; DE = 0C
 115+ 9592              ; so BC = a * 256 / C
 116+ 9592              DIV16Amul256dCUNDOC:    JumpIfAGTENusng	  c,DEV16ATooLarge                                          ; first off if a > c ten return 255
 116+ 9592 B9          >                        cp     c
 116+ 9593 D2 BE 95    >                        jp		nc,DEV16ATooLarge
 117+ 9596 47                                   ld      b,a
 118+ 9597 59                                   ld      e,c
 119+ 9598 0E 00                                ld      c,0
 120+ 959A 16 00                                ld      d,0
 121+ 959C C3 A9 95                             jp      DIV16UNDOC
 122+ 959F 47           DIV16Amul256dQUNDOC:    ld      b,a
 123+ 95A0 0E 00                                ld      c,0
 124+ 95A2 21 5B 84                             ld      hl,varQ
 125+ 95A5 7E                                   ld      a,(hl)
 126+ 95A6 16 00                                ld      d,0
 127+ 95A8 5F                                   ld      e,a
 128+ 95A9              DIV16BCDivDEUNDOC:
 129+ 95A9 21 00 00     DIV16UNDOC:             ld      hl,0
 130+ 95AC 78                                   ld      a,b
 131+ 95AD 06 10                                ld      b,16
 132+ 95AF CB 31        DIV16UNDOCLOOP:         sll	c		; unroll 16 times
 133+ 95B1 17                                   rla			; ...
 134+ 95B2 ED 6A                                adc	hl,hl		; ...
 135+ 95B4 ED 52                                sbc	hl,de		; ...
 136+ 95B6 30 02                                jr	nc,DIV16UNDOCSKIP		; ...
 137+ 95B8 19                                   add	hl,de		; ...
 138+ 95B9 0D                                   dec	c		; ...
 139+ 95BA 10 F3        DIV16UNDOCSKIP:         djnz DIV16UNDOCLOOP
 140+ 95BC 47                                   ld   b,a
 141+ 95BD C9                                   ret
 142+ 95BE 01 FF 00     DEV16ATooLarge:         ld     bc,$00FF
 143+ 95C1 C9                                   ret
 144+ 95C2
 145+ 95C2              ; "> asm_div8 C_Div_D - C is the numerator, D is the denominator, A is the remainder, B is 0, C is the result of C/D,D,E,H,L are not changed"
 146+ 95C2 06 08        asm_div8:               ld b,8
 147+ 95C4 AF                                   xor a
 148+ 95C5 CB 21        .div8_loop:	            sla c
 149+ 95C7 17                                   rla
 150+ 95C8 BA                                   cp d
 151+ 95C9 38 02                                jr c,.div8_skip
 151+ 95CB
 152+ 95CB 0C                                   inc c
 153+ 95CC 92                                   sub d
 154+ 95CD 10 F6        .div8_skip:	            djnz .div8_loop
 155+ 95CF C9                                   ret
 156+ 95D0              ; ">asm_div16: HL_Div_C: HL is the numerator,  C is the denominator, output A is the remainder, B is 0, C,DE is not changedHL is the quotient"
 157+ 95D0 06 10        asm_div16:              ld b,16
 158+ 95D2 AF                                   xor a
 159+ 95D3 CB 25        div16_loop:	            sla l
 160+ 95D5 CB 14                                rl	h
 161+ 95D7              ;    add hl,hl
 162+ 95D7 17                                   rla
 163+ 95D8 B9                                   cp c
 164+ 95D9 38 02                                jr c,div16_skip
 165+ 95DB 2C                                   inc l
 166+ 95DC 91                                   sub c
 167+ 95DD 10 F4        div16_skip:		        djnz div16_loop
 168+ 95DF C9                                   ret
 169+ 95E0              ;
 170+ 95E0              ; Divide 16-bit values (with 16-bit result)
 171+ 95E0              ; In: Divide BC by divider DE
 172+ 95E0              ; Out: BC = result, HL = rest
 173+ 95E0              ;
 174+ 95E0              HLDivC_Iteration: 	MACRO
 175+ 95E0 ~            					add	hl,hl		; unroll 16 times
 176+ 95E0 ~            					rla				; ...
 177+ 95E0 ~            					cp	c			; ...
 178+ 95E0 ~            					jr	1F
 179+ 95E0 ~            					sub	c			; ...
 180+ 95E0 ~            1:
 181+ 95E0 ~            					inc	l			; ...
 182+ 95E0              					ENDM
 183+ 95E0
 184+ 95E0
 185+ 95E0
 186+ 95E0              ; ">div1616: BC = BC / DE. HL = remainder"
 187+ 95E0 21 00 00     Div1616:            ld hl,0
 188+ 95E3 78                               ld a,b
 189+ 95E4 06 08                            ld b,8
 190+ 95E6 17           .Div16_Loop1:       rla
 191+ 95E7 ED 6A                            adc hl,hl
 192+ 95E9 ED 52                            sbc hl,de
 193+ 95EB 30 01                            jr nc,.Div16_NoAdd1
 194+ 95ED 19                               add hl,de
 195+ 95EE 10 F6        .Div16_NoAdd1:      djnz .Div16_Loop1
 196+ 95F0 17                               rla
 197+ 95F1 2F                               cpl
 198+ 95F2 47                               ld b,a
 199+ 95F3 79                               ld a,c
 200+ 95F4 48                               ld c,b
 201+ 95F5 06 08                            ld b,8
 202+ 95F7 17           .Div16_Loop2:       rla
 203+ 95F8 ED 6A                            adc hl,hl
 204+ 95FA ED 52                            sbc hl,de
 205+ 95FC 30 01                            jr nc,.Div16_NoAdd2
 206+ 95FE 19                               add hl,de
 207+ 95FF 10 F6        .Div16_NoAdd2:      djnz .Div16_Loop2
 208+ 9601 17                               rla
 209+ 9602 2F                               cpl
 210+ 9603 41                               ld b,c
 211+ 9604 4F                               ld c,a
 212+ 9605 C9                               ret
 213+ 9606
 214+ 9606
 215+ 9606
 216+ 9606              BCDIVDE_Iteration: MACRO
 217+ 9606 ~            				   rla
 218+ 9606 ~            				   adc	hl,hl
 219+ 9606 ~            				   add	hl,de
 220+ 9606 ~            				   jr	c,1F
 221+ 9606 ~            				   sbc	hl,de
 222+ 9606 ~            1:
 223+ 9606              				   ENDM
 224+ 9606
 225+ 9606
 226+ 9606              ; ">BC_Div_DE: BC = BC / DE. HL = remainder fast divide with unrolled loop"
 227+ 9606              ;BC/DE ==> BC, remainder in HL
 228+ 9606              ;NOTE: BC/0 returns 0 as the quotient.
 229+ 9606              ;min: 738cc
 230+ 9606              ;max: 898cc
 231+ 9606              ;avg: 818cc
 232+ 9606              ;144 bytes
 233+ 9606 AF           BC_Div_DE:              xor a
 234+ 9607 67                                   ld h,a
 235+ 9608 6F                                   ld l,a
 236+ 9609 93                                   sub e
 237+ 960A 5F                                   ld e,a
 238+ 960B 9F                                   sbc a,a
 239+ 960C 92                                   sub d
 240+ 960D 57                                   ld d,a
 241+ 960E 78                                   ld a,b
 242+ 960F                                      BCDIVDE_Iteration
 242+ 960F 17          >				   rla
 242+ 9610 ED 6A       >				   adc	hl,hl
 242+ 9612 19          >				   add	hl,de
 242+ 9613 38 02       >				   jr	c,1F
 242+ 9615 ED 52       >				   sbc	hl,de
 242+ 9617             >1:
 243+ 9617                                      BCDIVDE_Iteration
 243+ 9617 17          >				   rla
 243+ 9618 ED 6A       >				   adc	hl,hl
 243+ 961A 19          >				   add	hl,de
 243+ 961B 38 02       >				   jr	c,1F
 243+ 961D ED 52       >				   sbc	hl,de
 243+ 961F             >1:
 244+ 961F                                      BCDIVDE_Iteration
 244+ 961F 17          >				   rla
 244+ 9620 ED 6A       >				   adc	hl,hl
 244+ 9622 19          >				   add	hl,de
 244+ 9623 38 02       >				   jr	c,1F
 244+ 9625 ED 52       >				   sbc	hl,de
 244+ 9627             >1:
 245+ 9627                                      BCDIVDE_Iteration
 245+ 9627 17          >				   rla
 245+ 9628 ED 6A       >				   adc	hl,hl
 245+ 962A 19          >				   add	hl,de
 245+ 962B 38 02       >				   jr	c,1F
 245+ 962D ED 52       >				   sbc	hl,de
 245+ 962F             >1:
 246+ 962F                                      BCDIVDE_Iteration
 246+ 962F 17          >				   rla
 246+ 9630 ED 6A       >				   adc	hl,hl
 246+ 9632 19          >				   add	hl,de
 246+ 9633 38 02       >				   jr	c,1F
 246+ 9635 ED 52       >				   sbc	hl,de
 246+ 9637             >1:
 247+ 9637                                      BCDIVDE_Iteration
 247+ 9637 17          >				   rla
 247+ 9638 ED 6A       >				   adc	hl,hl
 247+ 963A 19          >				   add	hl,de
 247+ 963B 38 02       >				   jr	c,1F
 247+ 963D ED 52       >				   sbc	hl,de
 247+ 963F             >1:
 248+ 963F                                      BCDIVDE_Iteration
 248+ 963F 17          >				   rla
 248+ 9640 ED 6A       >				   adc	hl,hl
 248+ 9642 19          >				   add	hl,de
 248+ 9643 38 02       >				   jr	c,1F
 248+ 9645 ED 52       >				   sbc	hl,de
 248+ 9647             >1:
 249+ 9647                                      BCDIVDE_Iteration
 249+ 9647 17          >				   rla
 249+ 9648 ED 6A       >				   adc	hl,hl
 249+ 964A 19          >				   add	hl,de
 249+ 964B 38 02       >				   jr	c,1F
 249+ 964D ED 52       >				   sbc	hl,de
 249+ 964F             >1:
 250+ 964F 17                                   rla
 251+ 9650 47                                   ld b,a
 252+ 9651
 253+ 9651 79                                   ld a,c
 254+ 9652                                      BCDIVDE_Iteration
 254+ 9652 17          >				   rla
 254+ 9653 ED 6A       >				   adc	hl,hl
 254+ 9655 19          >				   add	hl,de
 254+ 9656 38 02       >				   jr	c,1F
 254+ 9658 ED 52       >				   sbc	hl,de
 254+ 965A             >1:
 255+ 965A                                      BCDIVDE_Iteration
 255+ 965A 17          >				   rla
 255+ 965B ED 6A       >				   adc	hl,hl
 255+ 965D 19          >				   add	hl,de
 255+ 965E 38 02       >				   jr	c,1F
 255+ 9660 ED 52       >				   sbc	hl,de
 255+ 9662             >1:
 256+ 9662                                      BCDIVDE_Iteration
 256+ 9662 17          >				   rla
 256+ 9663 ED 6A       >				   adc	hl,hl
 256+ 9665 19          >				   add	hl,de
 256+ 9666 38 02       >				   jr	c,1F
 256+ 9668 ED 52       >				   sbc	hl,de
 256+ 966A             >1:
 257+ 966A                                      BCDIVDE_Iteration
 257+ 966A 17          >				   rla
 257+ 966B ED 6A       >				   adc	hl,hl
 257+ 966D 19          >				   add	hl,de
 257+ 966E 38 02       >				   jr	c,1F
 257+ 9670 ED 52       >				   sbc	hl,de
 257+ 9672             >1:
 258+ 9672                                      BCDIVDE_Iteration
 258+ 9672 17          >				   rla
 258+ 9673 ED 6A       >				   adc	hl,hl
 258+ 9675 19          >				   add	hl,de
 258+ 9676 38 02       >				   jr	c,1F
 258+ 9678 ED 52       >				   sbc	hl,de
 258+ 967A             >1:
 259+ 967A                                      BCDIVDE_Iteration
 259+ 967A 17          >				   rla
 259+ 967B ED 6A       >				   adc	hl,hl
 259+ 967D 19          >				   add	hl,de
 259+ 967E 38 02       >				   jr	c,1F
 259+ 9680 ED 52       >				   sbc	hl,de
 259+ 9682             >1:
 260+ 9682                                      BCDIVDE_Iteration
 260+ 9682 17          >				   rla
 260+ 9683 ED 6A       >				   adc	hl,hl
 260+ 9685 19          >				   add	hl,de
 260+ 9686 38 02       >				   jr	c,1F
 260+ 9688 ED 52       >				   sbc	hl,de
 260+ 968A             >1:
 261+ 968A                                      BCDIVDE_Iteration
 261+ 968A 17          >				   rla
 261+ 968B ED 6A       >				   adc	hl,hl
 261+ 968D 19          >				   add	hl,de
 261+ 968E 38 02       >				   jr	c,1F
 261+ 9690 ED 52       >				   sbc	hl,de
 261+ 9692             >1:
 262+ 9692 17                                   rla
 263+ 9693 4F                                   ld c,a
 264+ 9694 C9                                   ret
 265+ 9695
 266+ 9695              ;Inputs:
 267+ 9695              ;     DE,BC are 8.8 Fixed Point numbers
 268+ 9695              ;Outputs:
 269+ 9695              ;     DE is the 8.8 Fixed Point result (rounded to the least significant bit)
 270+ 9695              ;if DE is 0 : 122cc or 136cc if BC is negative
 271+ 9695              ;if |BC|>=128*|DE| : 152cc or 166cc if BC is negative
 272+ 9695              ;Otherwise:
 273+ 9695              ;min: 1107cc
 274+ 9695              ;max: 1319cc
 275+ 9695              ;avg: 1201cc
 276+ 9695 78           BC_Div_DE_88:           ld a,b  ; First, find out if the output is positive or negative
 277+ 9696 AA                                   xor d
 278+ 9697 F5                                   push af   ;sign bit is the result sign bit
 279+ 9698              ; Now make sure the inputs are positive
 280+ 9698 A8                                   xor b     ;A now has the value of B, since I XORed it with D twice (cancelling)
 281+ 9699 F2 A2 96                             jp p,BC_Div_DE_88_lbl1   ;if Positive, don't negate
 282+ 969C AF                                   xor a
 283+ 969D 91                                   sub c
 284+ 969E 4F                                   ld c,a
 285+ 969F 9F                                   sbc a,a
 286+ 96A0 90                                   sub b
 287+ 96A1 47                                   ld b,a
 288+ 96A2 7A           BC_Div_DE_88_lbl1:      ld a,d  ;now make DE negative to optimize the remainder comparison
 289+ 96A3 B2                                   or d
 290+ 96A4 FA AD 96                             jp m,BC_Div_DE_88_lbl2
 291+ 96A7 AF                                   xor a
 292+ 96A8 93                                   sub e
 293+ 96A9 5F                                   ld e,a
 294+ 96AA 9F                                   sbc a,a
 295+ 96AB 92                                   sub d
 296+ 96AC 57                                   ld d,a
 297+ 96AD B3           BC_Div_DE_88_lbl2:      or e      ;if DE is 0, we can call it an overflow ;A is the current value of D
 298+ 96AE 28 1D                                jr z,div_fixed88_overflow
 299+ 96B0 26 00                                ld h,0          ;The accumulator gets set to B if no overflow.;We can use H=0 to save a few cc in the meantime
 300+ 96B2 78                                   ld a,b;if B+DE>=0, then we'll have overflow
 301+ 96B3 83                                   add a,e
 302+ 96B4 7A                                   ld a,d
 303+ 96B5 8C                                   adc a,h
 304+ 96B6 38 15                                jr c,div_fixed88_overflow
 305+ 96B8 68                                   ld l,b  ;Now we can load the accumulator/remainder with B;H is already 0
 306+ 96B9 79                                   ld a,c
 307+ 96BA CD D5 96                             call div_fixed88_sub
 308+ 96BD 4F                                   ld c,a
 309+ 96BE 78                                   ld a,b      ;A is now 0
 310+ 96BF CD D5 96                             call div_fixed88_sub
 311+ 96C2 51                                   ld d,c
 312+ 96C3 5F                                   ld e,a
 313+ 96C4 F1                                   pop af
 314+ 96C5 F0                                   ret p
 315+ 96C6 AF                                   xor a
 316+ 96C7 93                                   sub e
 317+ 96C8 5F                                   ld e,a
 318+ 96C9 9F                                   sbc a,a
 319+ 96CA 92                                   sub d
 320+ 96CB 57                                   ld d,a
 321+ 96CC C9                                   ret
 322+ 96CD
 323+ 96CD 11 FF 7F     div_fixed88_overflow:   ld de,$7FFF
 324+ 96D0 F1                                   pop af
 325+ 96D1 F0                                   ret p
 326+ 96D2 13                                   inc de
 327+ 96D3 1C                                   inc e
 328+ 96D4 C9                                   ret
 329+ 96D5
 330+ 96D5              ;min: 456cc
 331+ 96D5              ;max: 536cc
 332+ 96D5              ;avg: 496cc
 333+ 96D5 06 08        div_fixed88_sub:        ld b,8
 334+ 96D7 17           BC_Div_DE_88_lbl3:      rla
 335+ 96D8 ED 6A                                adc hl,hl
 336+ 96DA 19                                   add hl,de
 337+ 96DB 38 02                                jr c,$+4
 338+ 96DD ED 52                                sbc hl,de
 339+ 96DF 10 F6                                djnz BC_Div_DE_88_lbl3
 340+ 96E1 8F                                   adc a,a
 341+ 96E2 C9                                   ret
 342+ 96E3
# file closed: ./Maths/asm_divide.asm
 124  96E3                  INCLUDE "./Maths/asm_unitvector.asm"
# file opened: ./Maths/asm_unitvector.asm
   1+ 96E3              asm_tis2:
   2+ 96E3              ; ">TIS2 A = (A / Q * 96) so A = -96 ---- 96  range "
   3+ 96E3              ; ">DOES NOT DO SIGNED YET"
   4+ 96E3 F5           	push af
   5+ 96E4 E6 7F            and SignMask8Bit
   6+ 96E6 57           	ld d,a				;; d = A
   7+ 96E7 3A 5B 84     	ld a,(varQ)
   8+ 96EA 5F           	ld e,a
   9+ 96EB 7A           	ld a,d
  10+ 96EC BB           	cp e
  11+ 96ED 30 11        	jr nc, .tis2_set96	;; jump if a >= Q
  12+ 96EF 1E 60        	ld e, 96
  13+ 96F1 ED 30        	mul				; de = d * 96 (also a * 96 )
  14+ 96F3 EB           	ex de,hl
  15+ 96F4 3A 5B 84     	ld a,(varQ)
  16+ 96F7 4F           	ld c,a
  17+ 96F8 CD D0 95     	call asm_div16
  18+ 96FB F1           	pop af
  19+ 96FC E6 80        	and $80
  20+ 96FE B5           	or l
  21+ 96FF C9           	ret
  22+ 9700              .tis2_set96:
  23+ 9700 F1           	pop af
  24+ 9701 E6 80        	and $80
  25+ 9703 F6 96        	or $96
  26+ 9705 C9           	ret
  27+ 9706
  28+ 9706
  29+ 9706              asm_unit_vector:
  30+ 9706              squareregfx:
  31+ 9706 3A 9C 9E     	ld a,(UBnkXScaled)
  32+ 9709 57           	ld d,a
  33+ 970A 5F           	ld e,a
  34+ 970B ED 30        	mul
  35+ 970D EB           	ex de,hl
  36+ 970E              squareregfy:
  37+ 970E 3A 9E 9E     	ld a, (UBnkYScaled)
  38+ 9711 57           	ld d,a
  39+ 9712 5F           	ld e,a
  40+ 9713 ED 30        	mul
  41+ 9715 19           	add hl,de
  42+ 9716              squareregfz:
  43+ 9716 3A A0 9E     	ld a, (UBnkZScaled)
  44+ 9719 57           	ld d,a
  45+ 971A 5F           	ld e,a
  46+ 971B ED 30        	mul
  47+ 971D 19           	add hl,de
  48+ 971E EB           	ex de,hl			; de de to number to root
  49+ 971F              hlequsquareroot:
  50+ 971F CD B1 94     	call asm_sqrt		; hl = sqrt (fx^2 + fy^2 + fx^2)
  51+ 9722 E5           	push hl				; save it for work 3 copies
  52+ 9723 E5           	push hl				; save it for work
  53+ 9724 E5           	push hl				; save it for work
  54+ 9725              normfx:
  55+ 9725 3A 9C 9E     	ld a,(UBnkXScaled)
  56+ 9728 E1           	pop hl				; get copy #1
  57+ 9729 7D           	ld a,l				; we assume only l had worthwhile data but could spill into h
  58+ 972A 4F           	ld c,a
  59+ 972B CD E3 96     	call asm_tis2
  60+ 972E 32 9C 9E     	ld (UBnkXScaled),a
  61+ 9731              normfy:
  62+ 9731 3A 9E 9E     	ld a,(UBnkYScaled)
  63+ 9734 E1           	pop hl				; get copy #2
  64+ 9735 7D           	ld a,l
  65+ 9736 4F           	ld c,a
  66+ 9737 CD E3 96     	call asm_tis2
  67+ 973A 32 9E 9E     	ld (UBnkYScaled),a
  68+ 973D              normfz:
  69+ 973D 3A A0 9E     	ld a,(UBnkZScaled)
  70+ 9740 E1           	pop hl				; get copy #2
  71+ 9741 7D           	ld a,l
  72+ 9742 4F           	ld c,a
  73+ 9743 CD E3 96     	call asm_tis2
  74+ 9746 32 A0 9E     	ld (UBnkZScaled),a
  75+ 9749              asm_unit_vector_end:
  76+ 9749 C9           	ret
  77+ 974A
# file closed: ./Maths/asm_unitvector.asm
 125  974A                  INCLUDE "./Maths/compare16.asm"
# file opened: ./Maths/compare16.asm
   1+ 974A              ; Input:
   2+ 974A              ;       HL = 1st value
   3+ 974A              ;       DE = 2nd value
   4+ 974A              ; Output:
   5+ 974A              ;       CF, ZF = results of comparison:
   6+ 974A              ;
   7+ 974A              ;               CF      ZF      Result
   8+ 974A              ;               -----------------------------------
   9+ 974A              ;               0       0       HL > DE
  10+ 974A              ;               0       1       HL == DE
  11+ 974A              ;               1       0       HL < DE
  12+ 974A              ;               1       1       Impossible
  13+ 974A              ;
  14+ 974A
  15+ 974A E5           compare16HLDE:      push    hl
  16+ 974B A7                               and     a
  17+ 974C ED 52                            sbc     hl,de
  18+ 974E E1                               pop     hl
  19+ 974F C9                               ret
  20+ 9750
  21+ 9750              ; With compare signed we do ABS comparison
  22+ 9750              ; this is used for view ports as we just want to know if its +/- out side of 90 degrees
  23+ 9750
  24+ 9750 E5 D5        compare16HLDEABS:   push    hl,,de
  25+ 9752 7C                               ld      a,h                                     ; Quick pass see of both the same sign
  26+ 9753 E6 7F                            and     SignMask8Bit
  27+ 9755 67                               ld      h,a
  28+ 9756 7A                               ld      a,d                                     ; Quick pass see of both the same sign
  29+ 9757 E6 7F                            and     SignMask8Bit
  30+ 9759 57                               ld      d,a
  31+ 975A A7                               and     a
  32+ 975B ED 52                            sbc     hl,de
  33+ 975D D1 E1                            pop     hl,,de
  34+ 975F C9                               ret
  35+ 9760
  36+ 9760
# file closed: ./Maths/compare16.asm
 126  9760                  INCLUDE "./Maths/negate16.asm"
# file opened: ./Maths/negate16.asm
   1+ 9760              ;;----------------------------------------------------------------------------------------------------------------------
   2+ 9760              ;; 16-bit negate
   3+ 9760              negate16:
   4+ 9760              negate16hl:
   5+ 9760                      ; Input:
   6+ 9760                      ;       HL = value
   7+ 9760                      ; Output:
   8+ 9760                      ;       HL = -value
   9+ 9760                      ; Destroys:
  10+ 9760                      ;       AF
  11+ 9760                      ;
  12+ 9760 AF           	xor 	a
  13+ 9761 95           	sub 	l
  14+ 9762 6F           	ld 		l,a
  15+ 9763 9F           	sbc 	a,a
  16+ 9764 94           	sub 	h
  17+ 9765 67           	ld 		h,a
  18+ 9766 C9           	ret
  19+ 9767
  20+ 9767              negate16de:
  21+ 9767 AF           	xor 	a
  22+ 9768 93           	sub 	e
  23+ 9769 5F           	ld 		e,a
  24+ 976A 9F           	sbc 	a,a
  25+ 976B 92           	sub 	d
  26+ 976C 57           	ld 		d,a
  27+ 976D C9           	ret
  28+ 976E
  29+ 976E              negate16bc:
  30+ 976E AF           	xor 	a
  31+ 976F 91           	sub 	c
  32+ 9770 4F           	ld 		c,a
  33+ 9771 9F           	sbc 	a,a
  34+ 9772 90           	sub 	b
  35+ 9773 47           	ld 		b,a
  36+ 9774 C9           	ret
  37+ 9775
  38+ 9775
  39+ 9775              macronegate16hl:	MACRO
  40+ 9775 ~            					xor 	a
  41+ 9775 ~            					sub 	l
  42+ 9775 ~            					ld 		l,a
  43+ 9775 ~            					sbc 	a,a
  44+ 9775 ~            					sub 	h
  45+ 9775 ~            					ld 		h,a
  46+ 9775              					ENDM
  47+ 9775
  48+ 9775              macronegate16de:	MACRO
  49+ 9775 ~            					xor 	a
  50+ 9775 ~                                sub 	e
  51+ 9775 ~                                ld 		e,a
  52+ 9775 ~                                sbc 	a,a
  53+ 9775 ~                                sub 	d
  54+ 9775 ~                                ld 		d,a
  55+ 9775              					ENDM
  56+ 9775              macronegate16bc:	MACRO
  57+ 9775 ~            					xor 	a
  58+ 9775 ~                                sub 	c
  59+ 9775 ~                                ld 		c,a
  60+ 9775 ~                                sbc 	a,a
  61+ 9775 ~                                sub 	b
  62+ 9775 ~                                ld 		b,a
  63+ 9775              					ENDM
  64+ 9775
  65+ 9775              macronegate16ix:	MACRO
  66+ 9775 ~            					xor 	a
  67+ 9775 ~                                sub 	ixl
  68+ 9775 ~                                ld 		ixl,a
  69+ 9775 ~                                sbc 	a,a
  70+ 9775 ~                                sub 	ixh
  71+ 9775 ~                                ld 		ixh,a
  72+ 9775              					ENDM
# file closed: ./Maths/negate16.asm
 127  9775                  INCLUDE "./Maths/normalise96.asm"
# file opened: ./Maths/normalise96.asm
   1+ 9775 DD 68        AequAdivDmul96Unsg:     ld			ixl,b						; Get sign bit passed in as bit 7 in b
   2+ 9777                                      JumpIfAGTENusng d, TISXAccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
   2+ 9777 BA          >                        cp     d
   2+ 9778 D2 8D 97    >                        jp		nc,TISXAccGTEQ
   3+ 977B 4F                                   ld			c,a
   4+ 977C CD C2 95                             call		asm_div8
   5+ 977F 79                                   ld			a,c							; a = result
   6+ 9780 CB 3F                                srl			a							; result / 4
   7+ 9782 47                                   ld			b,a							; t = t /4
   8+ 9783 CB 3F                                srl			a							; result / 8
   9+ 9785 80                                   add			a,b							; result /8 + result /4
  10+ 9786 47                                   ld			b,a							; b = 3/8*Acc (max = 96)
  11+ 9787 DD 7D                                ld			a,ixl						; copy of Acc to look at sign bit
  12+ 9789 E6 80                                and			$80							; recover sign only
  13+ 978B B0                                   or			b							; now put b back in so we have a leading sign bit (note not 2's compliment)
  14+ 978C C9                                   ret
  15+ 978D              TISXAccGTEQ:
  16+ 978D              ;TI4:										;\ clean to +/- unity
  17+ 978D DD 7D                                ld			a,ixl     					; get saved sign from b
  18+ 978F E6 80                                and			$80							; copy of Acc
  19+ 9791 F6 60                                or			$60							; unity
  20+ 9793 C9                                   ret
  21+ 9794
  22+ 9794
  23+ 9794
  24+ 9794
  25+ 9794              normaliseXX1596fast:
  26+ 9794                  ; .NORM	\ -> &3BD6 \ Normalize 3-vector length of XX15
  27+ 9794 3A 9C 9E     	ld		a,(XX15)		    ; XX15+0
  28+ 9797 DD 67        	ld		ixh,a               ; ixh = signed x component
  29+ 9799 E6 7F        	and		SignMask8Bit                 ; a = unsigned version
  30+ 979B              N96SQX:
  31+ 979B              	inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
  31+ 979B 5F          >			ld	e,a
  31+ 979C 57          >			ld  d,a
  31+ 979D ED 30       >			mul
  32+ 979F 62           	ld		h,d					; h == varR d = varO e= varA
  33+ 97A0 6B           	ld		l,e					; l == varQ  															:: so HL = XX15[x]^2
  34+ 97A1              N96SQY:
  35+ 97A1 3A 9D 9E     	ld		a,(XX15+1)
  36+ 97A4 DD 6F        	ld		ixl,a               ; ixl = signed y componet
  37+ 97A6 E6 7F        	and		SignMask8Bit                 ; = abs
  38+ 97A8              	inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2		:: so DE = XX15[y]^2
  38+ 97A8 5F          >			ld	e,a
  38+ 97A9 57          >			ld  d,a
  38+ 97AA ED 30       >			mul
  39+ 97AC 19           	add		hl,de				; hl = XX15[x]^2 + XX15[y]^2
  40+ 97AD              N96SQZ:
  41+ 97AD 3A 9E 9E     	ld		a,(XX15+2)			; Note comments say \ ZZ15+2  should be \ XX15+2 as per code
  42+ 97B0 FD 67        	ld		iyh,a               ; iyh = signed
  43+ 97B2 E6 7F        	and		SignMask8Bit                 ; unsigned
  44+ 97B4              	inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2		:: so DE = XX15[z]^2
  44+ 97B4 5F          >			ld	e,a
  44+ 97B5 57          >			ld  d,a
  44+ 97B6 ED 30       >			mul
  45+ 97B8              N96SQADD:
  46+ 97B8 19           	add		hl,de				; hl = XX15[x]^2 + XX15[y]^2 + XX15[z]^2
  47+ 97B9 EB           	ex		de,hl				; hl => de ready for square root
  48+ 97BA              N96SQRT:
  49+ 97BA CD B1 94     	call	asm_sqrt			; hl = sqrt(XX15[x]^2 + XX15[y]^2 + XX15[z]^2), we just are interested in l which is the new Q
  50+ 97BD              N96NORMX:
  51+ 97BD 3A 9C 9E     	ld		a,(XX15+0)
  52+ 97C0 E6 7F        	and		SignMask8Bit
  53+ 97C2 4F           	ld		c,a
  54+ 97C3 55           	ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  55+ 97C4 CD EB 99     	call	AequAdivDmul96	; does not use HL so we can retain it
  56+ 97C7 47           	ld		b,a				;++SGN
  57+ 97C8 DD 7C        	ld		a,ixh			;++SGN
  58+ 97CA E6 80        	and		$80				;++SGN
  59+ 97CC B0           	or		b				;++SGN
  60+ 97CD 32 9C 9E     	ld		(XX15+0),a
  61+ 97D0              N96NORMY:
  62+ 97D0 3A 9D 9E     	ld		a,(XX15+1)
  63+ 97D3 E6 7F        	and		SignMask8Bit
  64+ 97D5 4F           	ld		c,a
  65+ 97D6 55           	ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  66+ 97D7 CD EB 99     	call	AequAdivDmul96     	; does not use HL so we can retain it
  67+ 97DA 47           	ld		b,a				;++SGN
  68+ 97DB DD 7D        	ld		a,ixl			;++SGN
  69+ 97DD E6 80        	and		$80				;++SGN
  70+ 97DF B0           	or		b				;++SGN
  71+ 97E0 32 9D 9E     	ld		(XX15+1),a
  72+ 97E3              N96NORMZ:
  73+ 97E3 3A 9E 9E     	ld		a,(XX15+2)
  74+ 97E6 E6 7F        	and		SignMask8Bit
  75+ 97E8 4F           	ld		c,a
  76+ 97E9 55           	ld		d,l					; Q(i.e. l) => D, later we can just pop into de
  77+ 97EA CD EB 99     	call	AequAdivDmul96	; does not use HL so we can retain it
  78+ 97ED 47           	ld		b,a				;++SGN
  79+ 97EE FD 7C        	ld		a,iyh			;++SGN
  80+ 97F0 E6 80        	and		$80				;++SGN
  81+ 97F2 B0           	or		b				;++SGN
  82+ 97F3 32 9E 9E     	ld		(XX15+2),a
  83+ 97F6 C9           	ret
  84+ 97F7
  85+ 97F7              ; Normalise vector
  86+ 97F7              ; scale Q = Sqrt (X^2 + Y^2 + Z^2)
  87+ 97F7              ; X = X / Q with 96 = 1 , i.e X = X / Q * 3/8
  88+ 97F7              ; Y = Y / Q with 96 = 1 , i.e Y = Y / Q * 3/8
  89+ 97F7              ; Z = Z / Q with 96 = 1 , i.e Z = Z / Q * 3/8
  90+ 97F7              ;
  91+ 97F7              ;
  92+ 97F7              ;
  93+ 97F7
  94+ 97F7              ; .NORM	\ -> &3BD6 \ Normalize 3-vector length of XX15
  95+ 97F7 3A 9C 9E     normaliseXX1596:        ld		a,(XX15)		    ; XX15+0
  96+ 97FA                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
  96+ 97FA 5F          >			ld	e,a
  96+ 97FB 57          >			ld  d,a
  96+ 97FC ED 30       >			mul
  97+ 97FE 7A                                   ld		a,d
  98+ 97FF 32 5C 84                             ld		(varR),a			; R	 \ hi sum later use b
  99+ 9802 7B                                   ld		a,e
 100+ 9803 32 5B 84                             ld		(varQ),a			; Q	 \ lo sum later use c
 101+ 9806 32 58 83                             ld		(varP),a			; P	 \ lo sum later just drop
 102+ 9809 3A 9D 9E                             ld		a,(XX15+1)
 103+ 980C                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
 103+ 980C 5F          >			ld	e,a
 103+ 980D 57          >			ld  d,a
 103+ 980E ED 30       >			mul
 104+ 9810 7A                                   ld		a,d
 105+ 9811 32 77 84                             ld		(varT),a			; T	 \ hi sum
 106+ 9814 7B                                   ld		a,e
 107+ 9815 32 58 83                             ld		(varP),a			; P	 \ lo sum
 108+ 9818 21 5B 84                             ld		hl,varQ
 109+ 981B 8E                                   adc		a,(hl)				; +Q
 110+ 981C 32 5B 84                             ld		(varQ),a			; =>Q
 111+ 981F 3A 77 84                             ld		a,(varT)			;
 112+ 9822 21 5C 84                             ld		hl,varR
 113+ 9825 8E                                   adc		a,(hl)				;  R
 114+ 9826 32 5C 84                             ld		(varR),a			; R
 115+ 9829 3A 9E 9E                             ld		a,(XX15+2)			; Note comments say \ ZZ15+2  should be \ XX15+2 as per code
 116+ 982C                                      inline_squde				; Use inline square for speed	objective is SQUA \ P.A =A7*A7 x^2
 116+ 982C 5F          >			ld	e,a
 116+ 982D 57          >			ld  d,a
 116+ 982E ED 30       >			mul
 117+ 9830 7A                                   ld		a,d
 118+ 9831 32 77 84                             ld		(varT),a			; T	 \ hi sum
 119+ 9834 7B                                   ld		a,e
 120+ 9835 32 58 83                             ld		(varP),a			; P	 \ lo sum
 121+ 9838 21 5B 84                             ld		hl,varQ
 122+ 983B 8E                                   adc		a,(hl)				; +Q
 123+ 983C 32 5B 84                             ld		(varQ),a			; =>Q  xlo2 + ylo2 + zlo2
 124+ 983F 3A 77 84                             ld		a,(varT)			; T temp Hi
 125+ 9842 21 5C 84                             ld		hl,varR
 126+ 9845 8E                                   adc		a,(hl)				; +R
 127+ 9846 32 5C 84                             ld		(varR),a			; R
 128+ 9849 CD D4 94                             call	sqrtQR				; Q = SQR(Qlo.Rhi) Q <~127
 129+ 984C 3A 9C 9E                             ld		a,(XX15+0)
 130+ 984F CD E5 99                             call	AequAdivQmul96		;  TIS2 \ *96/Q
 131+ 9852 32 9C 9E                             ld		(XX15+0),a
 132+ 9855 3A 9D 9E                             ld		a,(XX15+1)
 133+ 9858 CD E5 99                             call	AequAdivQmul96		;  TIS2 \ *96/Q
 134+ 985B 32 9D 9E                             ld		(XX15+1),a
 135+ 985E 3A 9D 9E                             ld		a,(XX15+1)
 136+ 9861 CD E5 99                             call	AequAdivQmul96		;  TIS2 \ *96/Q
 137+ 9864 32 9D 9E                             ld		(XX15+1),a
 138+ 9867 C9                                   ret
 139+ 9868
 140+ 9868
# file closed: ./Maths/normalise96.asm
 128  9868                  INCLUDE "./Maths/binary_to_decimal.asm"
# file opened: ./Maths/binary_to_decimal.asm
   1+ 9868              ;Number in hl to decimal ASCII
   2+ 9868              ;Thanks to z80 Bits
   3+ 9868              ;inputs:	hl = number to ASCII
   4+ 9868              ;example: hl=300 outputs '00300'
   5+ 9868              ;destroys: af, bc, hl, de used
   6+ 9868              DispHLtoDE:
   7+ 9868              ; "DispHL, writes HL to DE address"
   8+ 9868 01 F0 D8     	ld	bc,-10000
   9+ 986B CD 81 98     	call	Num1
  10+ 986E 01 18 FC     	ld	bc,-1000
  11+ 9871 CD 81 98     	call	Num1
  12+ 9874 01 9C FF     	ld	bc,-100
  13+ 9877 CD 81 98     	call	Num1
  14+ 987A 0E F6        	ld	c,-10
  15+ 987C CD 81 98     	call	Num1
  16+ 987F 0E FF        	ld	c,-1
  17+ 9881              Num1:
  18+ 9881 3E 2F        	ld	a,'0'-1
  19+ 9883              .Num2:
  20+ 9883 3C           	inc	a
  21+ 9884 09           	add	hl,bc
  22+ 9885 38 FC        	jr	c,.Num2
  23+ 9887 ED 42        	sbc	hl,bc
  24+ 9889 12           	ld	(de),a
  25+ 988A 13           	inc	de
  26+ 988B C9           	ret
  27+ 988C
  28+ 988C              DispAtoDE:
  29+ 988C 26 00        	ld h,0
  30+ 988E 6F           	ld l,a
  31+ 988F C3 68 98     	jp DispHLtoDE
  32+ 9892
  33+ 9892              DispPriceAtoDE:
  34+ 9892 26 00        	ld h,0
  35+ 9894 6F           	ld l,a
  36+ 9895 01 9C FF     	ld	bc,-100
  37+ 9898 CD A8 98     	call	.NumLeadBlank1
  38+ 989B 0E F6        	ld	c,-10
  39+ 989D CD 81 98     	call	Num1
  40+ 98A0 3E 2E        	ld		a,'.'					; we could assume preformat but
  41+ 98A2 12           	ld		(de),a					; we can optimse that later TODO
  42+ 98A3 13           	inc		de						; with just an inc De
  43+ 98A4 0E FF        	ld	c,-1
  44+ 98A6 18 D9        	jr		Num1
  45+ 98A8              .NumLeadBlank1:
  46+ 98A8 3E 2F        	ld	a,'0'-1
  47+ 98AA              .NumLeadBlank2:
  48+ 98AA 3C           	inc	a
  49+ 98AB 09           	add	hl,bc
  50+ 98AC 38 FC        	jr	c,.NumLeadBlank2
  51+ 98AE FE 30        	cp	'0'
  52+ 98B0 20 02        	jr	nz,.DontBlank
  53+ 98B2              .Blank:
  54+ 98B2 3E 20        	ld	a,' '
  55+ 98B4              .DontBlank:
  56+ 98B4 ED 42        	sbc	hl,bc
  57+ 98B6 12           	ld	(de),a
  58+ 98B7 13           	inc	de
  59+ 98B8 C9           	ret
  60+ 98B9
  61+ 98B9              DispQtyAtoDE:
  62+ 98B9 FE 00        	cp	0
  63+ 98BB 28 23        	jr	z,.NoStock
  64+ 98BD 26 00        	ld h,0
  65+ 98BF 6F           	ld l,a
  66+ 98C0 01 9C FF     	ld	bc,-100
  67+ 98C3 CD CF 98     	call	.NumLeadBlank1
  68+ 98C6 0E F6        	ld	c,-10
  69+ 98C8 CD CF 98     	call	.NumLeadBlank1
  70+ 98CB 0E FF        	ld	c,-1
  71+ 98CD 18 B2        	jr		Num1
  72+ 98CF              .NumLeadBlank1:
  73+ 98CF 3E 2F        	ld	a,'0'-1
  74+ 98D1              .NumLeadBlank2:
  75+ 98D1 3C           	inc	a
  76+ 98D2 09           	add	hl,bc
  77+ 98D3 38 FC        	jr	c,.NumLeadBlank2
  78+ 98D5 FE 30        	cp	'0'
  79+ 98D7 20 02        	jr	nz,.DontBlank
  80+ 98D9              .Blank:
  81+ 98D9 3E 20        	ld	a,' '
  82+ 98DB              .DontBlank:
  83+ 98DB ED 42        	sbc	hl,bc
  84+ 98DD 12           	ld	(de),a
  85+ 98DE 13           	inc	de
  86+ 98DF C9           	ret
  87+ 98E0              .NoStock:
  88+ 98E0 3E 20        	ld	a,' '
  89+ 98E2 12           	ld	(de),a
  90+ 98E3 13           	inc	de
  91+ 98E4 12           	ld	(de),a
  92+ 98E5 13           	inc	de
  93+ 98E6 3E 2D        	ld	a,'-'
  94+ 98E8 12           	ld	(de),a
  95+ 98E9 13           	inc de
  96+ 98EA C9           	ret
  97+ 98EB
  98+ 98EB
  99+ 98EB              ;### CLCN32 -> Converts 32Bit-Value in ASCII-String (terminated by 0)
 100+ 98EB              ;### Input      DE,IX=32bit value, IY=destination address
 101+ 98EB              ;### Output     IY=last char in destination string
 102+ 98EB              ;### Destroyed AF,BC,DE,HL,IX
 103+ 98EB 01 00 00 00  clcn32t dw 1,0,     10,0,     100,0,     1000,0,       10000,0
 103+ 98EF 0A 00 00 00
 103+ 98F3 64 00 00 00
 103+ 98F7 E8 03 00 00
 103+ 98FB 10 27 00 00
 104+ 98FF A0 86 01 00          dw $86a0,1, $4240,$0f, $9680,$98, $e100,$05f5, $ca00,$3b9a
 104+ 9903 40 42 0F 00
 104+ 9907 80 96 98 00
 104+ 990B 00 E1 F5 05
 104+ 990F 00 CA 9A 3B
 105+ 9913 00 00 00 00  clcn32z ds 4
 106+ 9917
 107+ 9917              ; As per display but shifts final digit by 1 and puts in "." for 1 decimal place
 108+ 9917 CD 26 99     DispDEIXtoIY1DP:        call    DispDEIXtoIY
 109+ 991A FD 7E 00                             ld      a,(IY+0)
 110+ 991D FD 77 01                             ld      (IY+1),a
 111+ 9920 3E 2E                                ld      a,"."
 112+ 9922 FD 77 00                             ld      (IY+0),a
 113+ 9925 C9                                   ret
 114+ 9926
 115+ 9926 DD 22 13 99  DispDEIXtoIY:           ld (clcn32z),ix
 116+ 992A ED 53 15 99                          ld (clcn32z+2),de
 117+ 992E DD 21 0F 99                          ld ix,clcn32t+36
 118+ 9932 06 09                                ld b,9
 119+ 9934 0E 00                                ld c,0
 120+ 9936 3E 30        .clcn321:               ld a,'0'
 121+ 9938 B7                                   or a
 122+ 9939 DD 5E 00     .clcn322:               ld e,(ix+0)
 123+ 993C DD 56 01                             ld d,(ix+1)
 124+ 993F 2A 13 99                             ld hl,(clcn32z)
 125+ 9942 ED 52                                sbc hl,de
 126+ 9944 22 13 99                             ld (clcn32z),hl
 127+ 9947 DD 5E 02                             ld e,(ix+2)
 128+ 994A DD 56 03                             ld d,(ix+3)
 129+ 994D 2A 15 99                             ld hl,(clcn32z+2)
 130+ 9950 ED 52                                sbc hl,de
 131+ 9952 22 15 99                             ld (clcn32z+2),hl
 132+ 9955 38 04                                jr c,.clcn325
 133+ 9957 0C                                   inc c
 134+ 9958 3C                                   inc a
 135+ 9959 18 DE                                jr .clcn322
 136+ 995B DD 5E 00     .clcn325:               ld e,(ix+0)
 137+ 995E DD 56 01                             ld d,(ix+1)
 138+ 9961 2A 13 99                             ld hl,(clcn32z)
 139+ 9964 19                                   add hl,de
 140+ 9965 22 13 99                             ld (clcn32z),hl
 141+ 9968 DD 5E 02                             ld e,(ix+2)
 142+ 996B DD 56 03                             ld d,(ix+3)
 143+ 996E 2A 15 99                             ld hl,(clcn32z+2)
 144+ 9971 ED 5A                                adc hl,de
 145+ 9973 22 15 99                             ld (clcn32z+2),hl
 146+ 9976 11 FC FF                             ld de,-4
 147+ 9979 DD 19                                add ix,de
 148+ 997B 0C                                   inc c
 149+ 997C 0D                                   dec c
 150+ 997D 28 05                                jr z,.clcn323
 151+ 997F FD 77 00                             ld (iy+0),a
 152+ 9982 FD 23                                inc iy
 153+ 9984 10 B0        .clcn323:               djnz .clcn321
 154+ 9986 3A 13 99                             ld a,(clcn32z)
 155+ 9989 C6 30                                add A,'0'
 156+ 998B FD 77 00                             ld (iy+0),a
 157+ 998E FD 36 01 00                          ld (iy+1),0
 158+ 9992 C9                                   ret
 159+ 9993
# file closed: ./Maths/binary_to_decimal.asm
 129  9993                  include "./Maths/ADDHLDESignBC.asm"
# file opened: ./Maths/ADDHLDESignBC.asm
   1+ 9993              ;; calcs HLB + DEC where B and C are signs
   2+ 9993              ;; result HL with A as sign
   3+ 9993              ;; special handling if result is zero forcign sign bit to be zero
   4+ 9993 78           ADDHLDESignBC:          ld      a,b
   5+ 9994 E6 80                                and     SignOnly8Bit
   6+ 9996 A9                                   xor     c                           ;if b sign and c sign were different then bit 7 of a will be 1 which means
   7+ 9997                                      JumpIfNegative ADDHLDEsBCOppSGN     ;Signs are opposite there fore we can subtract to get difference
   7+ 9997 FA A5 99    >                        jp		m, ADDHLDEsBCOppSGN
   8+ 999A 78           ADDHLDEsBCSameSigns:    ld      a,b
   9+ 999B B1                                   or      c
  10+ 999C                                      JumpIfNegative ADDHLDEsBCSameNeg        ; optimisation so we can just do simple add if both positive
  10+ 999C FA A1 99    >                        jp		m, ADDHLDEsBCSameNeg
  11+ 999F 19                                   add     hl,de                       ; both positive so a will already be zero
  12+ 99A0 C9                                   ret
  13+ 99A1 19           ADDHLDEsBCSameNeg:      add     hl,de
  14+ 99A2 78                                   ld      a,b
  15+ 99A3 B1                                   or      c                           ; now set bit for negative value, we won't bother with overflow for now TODO
  16+ 99A4 C9                                   ret
  17+ 99A5 B7           ADDHLDEsBCOppSGN:       or      a
  18+ 99A6 ED 52                                sbc     hl,de
  19+ 99A8 38 02                                jr      c,ADDHLDEsBCOppInvert
  20+ 99AA 78           ADDHLDEsBCOppSGNNoCarry: ld      a,b                                               ; we got here so hl > de therefore we can just take hl's previous sign bit
  21+ 99AB C9                                   ret
  22+ 99AC              ADDHLDEsBCOppInvert:    NegHL                         ; if result was zero then set sign to zero (which doing h or l will give us for free)
  22+ 99AC AF          >                    xor a
  22+ 99AD 95          >                    sub l
  22+ 99AE 6F          >                    ld l,a
  22+ 99AF 9F          >                    sbc a,a
  22+ 99B0 94          >                    sub h
  22+ 99B1 67          >                    ld h,a
  23+ 99B2 78                                   ld      a,b
  24+ 99B3 EE 80                                xor     SignOnly8Bit                ; flip sign bit
  25+ 99B5 C9                                   ret
  26+ 99B6
# file closed: ./Maths/ADDHLDESignBC.asm
 130  99B6                  INCLUDE "./Maths/Utilities/AequAdivQmul96-TIS2.asm"
# file opened: ./Maths/Utilities/AequAdivQmul96-TIS2.asm
   1+ 99B6              AequAdivQmul96ABS:      JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
   1+ 99B6 BA          >                        cp     d
   1+ 99B7 D2 D2 99    >                        jp		nc,.TIS2AccGTEQ
   2+ 99BA 06 FE                                ld			b,$FE						; division roll (replaced varT)
   3+ 99BC CB 27        .TIS2RollTLoop:			sla			a
   4+ 99BE                                      JumpIfALTNusng d,.TIS2SkipSub           ; a < d so don;t subtract
   4+ 99BE BA          >                        cp      d
   4+ 99BF DA D5 99    >                        jp		c, .TIS2SkipSub
   5+ 99C2 9A                                   sbc			a,d							; do subtraction with carry
   6+ 99C3 37                                   scf
   7+ 99C4 CB 10                                rl			b							; T rolled left to push bit out the end
   8+ 99C6 38 F4                                jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
   9+ 99C8 78           .TIS2SKIPCont:	        ld			a,b							; T
  10+ 99C9 CB 3F                                srl			a							; result / 2
  11+ 99CB CB 3F                                srl			a							; result / 4
  12+ 99CD 47                                   ld			b,a							; t = t /4
  13+ 99CE CB 3F                                srl			a							; result / 8
  14+ 99D0 80                                   add			a,b							; result /8 + result /4
  15+ 99D1 C9                                   ret
  16+ 99D2 3E 60        .TIS2AccGTEQ:           ld			a,$60							; unity
  17+ 99D4 C9                                   ret
  18+ 99D5 B7           .TIS2SkipSub:           or			a
  19+ 99D6 CB 10                                rl			b							; T rolled left to push bit out the end
  20+ 99D8 38 E2                                jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
  21+ 99DA C3 C8 99                             jp			.TIS2SKIPCont
  22+ 99DD
  23+ 99DD
  24+ 99DD              ; USES 			A DE BC
  25+ 99DD              ; DOES NOT USE 	HL
  26+ 99DD              TIS2962C:		; two's compliment entry point, exits not 2's compliment
  27+ 99DD CB 7F        	bit			7,a
  28+ 99DF 28 04        	jr			z,AequAdivQmul96
  29+ 99E1 ED 44        	neg										; revers 2s'c and just set neg bit
  30+ 99E3 CB FF        	set			7,a
  31+ 99E5              ; Note negative numbers are bit 7 set not 2's compliment
  32+ 99E5              AequAdivQmul96:								; TIS296:			; .tis2 A = A /Q *96 (or A = A * 3/8 * Q) Reduce Acc in NORM routine i.e. *96/Q clamps at +- 96
  33+ 99E5              TIS2:
  34+ 99E5 4F           	ld			c,a							; copy of Acc
  35+ 99E6 3A 5B 84     	ld			a,(varQ)
  36+ 99E9 57           	ld			d,a							; d = varQ
  37+ 99EA 79           	ld			a,c							; recover a
  38+ 99EB              AequAdivDmul96:
  39+ 99EB 4F           	ld			c,a							; copy of Acc as we need the sign, alternate entry point assuming D preloaded, wastes an "ld c,a" but simplifies code
  40+ 99EC E6 7F        	and			SignMask8Bit				; ignore sign
  41+ 99EE              	JumpIfAGTENusng d, .TIS2AccGTEQ			; if A >= Q then return with a 1 (unity i.e. 96) with the correct sign
  41+ 99EE BA          >                        cp     d
  41+ 99EF D2 0F 9A    >                        jp		nc,.TIS2AccGTEQ
  42+ 99F2 06 FE        	ld			b,$FE						; division roll (replaced varT)
  43+ 99F4              .TIS2RollTLoop:									; .TIL2	; roll T
  44+ 99F4 CB 27        	sla			a
  45+ 99F6              	JumpIfALTNusng d,.TIS2SkipSub            ; a < d so don;t subtract
  45+ 99F6 BA          >                        cp      d
  45+ 99F7 DA 15 9A    >                        jp		c, .TIS2SkipSub
  46+ 99FA 9A           	sbc			a,d							; do subtraction with carry
  47+ 99FB 37           	scf
  48+ 99FC CB 10        	rl			b							; T rolled left to push bit out the end
  49+ 99FE 38 F4        	jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
  50+ 9A00              .TIS2SKIPCont:
  51+ 9A00 78           	ld			a,b							; T
  52+ 9A01 CB 3F        	srl			a							; result / 2
  53+ 9A03 CB 3F        	srl			a							; result / 4
  54+ 9A05 47           	ld			b,a							; t = t /4
  55+ 9A06 CB 3F        	srl			a							; result / 8
  56+ 9A08 80           	add			a,b							; result /8 + result /4
  57+ 9A09 47           	ld			b,a							; b = 3/8*Acc (max = 96)
  58+ 9A0A 79           	ld			a,c							; copy of Acc to look at sign bit
  59+ 9A0B E6 80        	and			$80							; recover sign only
  60+ 9A0D B0           	or			b							; now put b back in so we have a leading sign bit (note not 2's compliment)
  61+ 9A0E C9           	ret
  62+ 9A0F              .TIS2AccGTEQ:
  63+ 9A0F              ;TI4:										;\ clean to +/- unity
  64+ 9A0F 79           	ld			a,c
  65+ 9A10 E6 80        	and			$80							; copy of Acc
  66+ 9A12 F6 60        	or			$60							; unity
  67+ 9A14 C9           	ret
  68+ 9A15              .TIS2SkipSub:
  69+ 9A15 B7           	or			a
  70+ 9A16 CB 10        	rl			b							; T rolled left to push bit out the end
  71+ 9A18 38 DA        	jr			c,.TIS2RollTLoop				; if we still have not hit the empty marker continue
  72+ 9A1A C3 00 9A     	jp			.TIS2SKIPCont
  73+ 9A1D
# file closed: ./Maths/Utilities/AequAdivQmul96-TIS2.asm
 131  9A1D                  INCLUDE "./Maths/Utilities/AequAmulQdiv256-FMLTU.asm"
# file opened: ./Maths/Utilities/AequAmulQdiv256-FMLTU.asm
   1+ 9A1D              fmltu:
   2+ 9A1D              AequAmulQdiv256:
   3+ 9A1D              ; "ASM_FMUTKL .FMLTU	\ -> &2847  \ A=A*Q/256unsg  Fast multiply"
   4+ 9A1D 57           	ld	d,a
   5+ 9A1E 3A 5B 84     	ld	a,(varQ)
   6+ 9A21 5F           	ld	e,a
   7+ 9A22 ED 30        	mul
   8+ 9A24 7A           	ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
   9+ 9A25 C9           	ret
  10+ 9A26
# file closed: ./Maths/Utilities/AequAmulQdiv256-FMLTU.asm
 132  9A26                  INCLUDE "./Maths/Utilities/PRequSpeedDivZZdiv8-DV42-DV42IYH.asm"
# file opened: ./Maths/Utilities/PRequSpeedDivZZdiv8-DV42-DV42IYH.asm
   1+ 9A26              ; "DV42,DV42IYH DE = P.R, c = R"
   2+ 9A26              DV42IYH:									; as per DV42 but using iyl for Y reg
   3+ 9A26 21 3B 87     		ld		hl,varDustZ
   4+ 9A29 FD 7D        		ld		a,iyl
   5+ 9A2B ED 31        		add		hl,a
   6+ 9A2D 7E           		ld		a,(hl)
   7+ 9A2E C3 3A 9A     		jp		DV41
   8+ 9A31              DV42:										; travel step of dust particle front/rear
   9+ 9A31 21 3B 87     		ld		hl,varDustZ
  10+ 9A34 3A 46 83     		ld		a,(regY)
  11+ 9A37 ED 31        		add		hl,a
  12+ 9A39 7E           		ld		a,(hl)						; a = SZ[y]
  13+ 9A3A              DV41:										; P.R = speed/ (ZZ/8) dust left/right
  14+ 9A3A 5F           		ld		e,a							; using E as Q var replacement
  15+ 9A3B 3A 57 84     		ld		a,(DELTA)					; DELTA \ speed, how far has dust moved based on its z-coord.
  16+ 9A3E              DVID4:										; P-R=A/Qunsg  \P.R = A/Q unsigned called by Hall
  17+ 9A3E 06 08        		ld		b,8							; counter
  18+ 9A40 CB 27        		sla		a							;
  19+ 9A42 57           		ld		d,a							; use d for - p = delta * 2
  20+ 9A43 AF           		xor		a
  21+ 9A44              DVL4:										; counter x loop (b reg)
  22+ 9A44 CB 17        		rl		a							; a = a * 2
  23+ 9A46 38 03        		jr		c,DV8						; jump on carry
  24+ 9A48 BB           		cp		e							; var Q
  25+ 9A49 38 02        		jr		c,DV5						; skip subtraction
  26+ 9A4B              DV8:
  27+ 9A4B 9B           		sbc		a,e							; a = a - q (with carry)
  28+ 9A4C 37           		scf									;  carry gets set
  29+ 9A4D              DV5:										; skipped subtraction
  30+ 9A4D CB 12        		rl		d							; d (P hi)
  31+ 9A4F 10 F3        		djnz	DVL4						; dec b and loop loop X, hi left in P.
  32+ 9A51              .CalcRemainder:								; BFRDIV R=A*256/Q
  33+ 9A51              ; Note we are not going to call LL28+4 but inline code here:
  34+ 9A51 06 FE        		ld		b,$FE						; remainder R for AofQ *256/Q
  35+ 9A53 4F           		ld		c,a							; use c as R var
  36+ 9A54              .RollRemainder:
  37+ 9A54 CB 27        		sla		a
  38+ 9A56 38 11        		jr		c,.Reduce					; if a >> generates carry reduce
  39+ 9A58 B8           		cp		b							; a < q?
  40+ 9A59 30 01        		jr		nc,.DontSBC
  41+ 9A5B              .DoSBC:										; a is < q
  42+ 9A5B 98           		sbc		a,b							; 	a -= q
  43+ 9A5C              .DontSBC:
  44+ 9A5C CB 11        		rl		c							; r << 1
  45+ 9A5E 38 F4        		jr		c, .RollRemainder			; if rol generated a carry, continue
  46+ 9A60 79           		ld		a,c
  47+ 9A61 32 5C 84     		ld		(varR),a					; for backwards compat
  48+ 9A64 7A           		ld		a,d
  49+ 9A65 32 58 83     		ld		(varP),a
  50+ 9A68 C9           		ret									; R (c) left with remainder
  51+ 9A69              .Reduce:									; a geneated a carry
  52+ 9A69 98           		sbc		a,b							; a = a - (q +1)
  53+ 9A6A 37           		scf									; set carry flag for rl
  54+ 9A6B CB 11        		rl		c							; r << 1 briging in carry
  55+ 9A6D 38 E5        		jr		c,	.RollRemainder			; if a carry fell off bit 7 then repeat
  56+ 9A6F 79           		ld		a,c
  57+ 9A70 32 5C 84     		ld		(varR),a					; for backwards compat
  58+ 9A73 7A           		ld		a,d
  59+ 9A74 32 58 83     		ld		(varP),a
  60+ 9A77 C9           		ret
  61+ 9A78              .AnswerTooBig:
  62+ 9A78 0E FF        		ld		c,$FF						; arse its too big
  63+ 9A7A 79           		ld		a,c
  64+ 9A7B 32 5C 84     		ld		(varR),a					; for backwards compat
  65+ 9A7E 7A           		ld		a,d
  66+ 9A7F 32 58 83     		ld		(varP),a
  67+ 9A82 C9           		ret
  68+ 9A83
# file closed: ./Maths/Utilities/PRequSpeedDivZZdiv8-DV42-DV42IYH.asm
 133  9A83                  INCLUDE "./Maths/Utilities/AequDmulEdiv256usgn-DEFMUTL.asm"
# file opened: ./Maths/Utilities/AequDmulEdiv256usgn-DEFMUTL.asm
   1+ 9A83
   2+ 9A83              asm_defmutl:
   3+ 9A83              AequDmulEdiv256usgn:
   4+ 9A83              ; "ASM_FMUTKL .FMLTU	\ -> &2847  \ A=D*E/256unsg  Fast multiply"
   5+ 9A83 ED 30        	mul
   6+ 9A85 7A           	ld	a,d				; we get only the high byte which is like doing a /256 if we think of a as low
   7+ 9A86 C9           	ret
   8+ 9A87
   9+ 9A87
# file closed: ./Maths/Utilities/AequDmulEdiv256usgn-DEFMUTL.asm
 134  9A87                  INCLUDE "./Maths/Utilities/APequQmulA-MULT1.asm"
# file opened: ./Maths/Utilities/APequQmulA-MULT1.asm
   1+ 9A87              APequQmulA:
   2+ 9A87              asm_mult1:
   3+ 9A87              ; "ASM_MULT1 (DE) A(hi).P(lo) = Q * A first part of MAD, multiply and add. Visited Quite often. A=hi P = lo also returns result in DE"
   4+ 9A87 FE 00        	cp	0
   5+ 9A89 28 1F        	jr	z,.mul0			; quick exit if its Q * 0
   6+ 9A8B 5F           	ld	e,a
   7+ 9A8C 3A 5B 84     	ld	a,(varQ)
   8+ 9A8F 57           	ld	d,a
   9+ 9A90 FE 00        	cp	0				; compare a
  10+ 9A92 28 16        	jr	z,.mul0			; quick exit if its 0 * a
  11+ 9A94 AB           	xor	e				; -- = + +- = - -+ = - ++ = +
  12+ 9A95 E6 80        	and $80				; get the resultant sign and save into b
  13+ 9A97 47           	ld	b,a
  14+ 9A98 7A           	ld	a,d
  15+ 9A99 E6 7F        	and	SignMask8Bit	; now strip off sign bits
  16+ 9A9B 57           	ld	d,a
  17+ 9A9C 7B           	ld	a,e
  18+ 9A9D E6 7F        	and SignMask8Bit
  19+ 9A9F 5F           	ld	e,a
  20+ 9AA0 ED 30        	mul					; zxn de = d * e
  21+ 9AA2 7B           	ld	a,e
  22+ 9AA3 32 58 83     	ld	(varP),a		; p = lo
  23+ 9AA6 7A           	ld	a,d				; a = hi
  24+ 9AA7 B0           	or	b				; de goes to a and varP also re-do sign bit
  25+ 9AA8 57           	ld	d,a				; we will work with de having result as we may bin vars later
  26+ 9AA9 C9           	ret
  27+ 9AAA              .mul0:
  28+ 9AAA AF           	xor	a
  29+ 9AAB 32 58 83     	ld	(varP),a
  30+ 9AAE 57           	ld	d,a
  31+ 9AAF 5F           	ld  e,a
  32+ 9AB0 C9           	ret
  33+ 9AB1
# file closed: ./Maths/Utilities/APequQmulA-MULT1.asm
 135  9AB1                  INCLUDE "./Maths/Utilities/badd_ll38.asm"
# file opened: ./Maths/Utilities/badd_ll38.asm
   1+ 9AB1              baddll38:				;.LL38	\ -> &4812 \ BADD(S)A=R+Q(SA) \ byte add (subtract)   (Sign S)A = R + Q*(Sign from A^S)
   2+ 9AB1              SAEquSRPlusAQ:
   3+ 9AB1              ; Calculate the following between sign-magnitude numbers:
   4+ 9AB1              ;   (S A) = (S R) + (A Q)
   5+ 9AB1              ; where the sign bytes only contain the sign bits, not magnitudes.
   6+ 9AB1              ; note goes wrong at <-127 >128 so need 16 bit version
   7+ 9AB1              ; so need to fix the issue with carry flag not returning a fault correctly
   8+ 9AB1              LL38:
   9+ 9AB1              ;	ld		d,a
  10+ 9AB1              ;	ld		a,(varQ)
  11+ 9AB1              ;	ld		e,a
  12+ 9AB1              ;	ld		a,(varS)
  13+ 9AB1              ;	ld		h,a
  14+ 9AB1              ;	ld		a,(varR)
  15+ 9AB1              ;	ld		l,a
  16+ 9AB1              ;	call	ADDHLDESignedv3
  17+ 9AB1              ;	ld		a,h
  18+ 9AB1              ;	ld		(varS),a
  19+ 9AB1              ;	ld		a,l
  20+ 9AB1              ;	ret
  21+ 9AB1              ; calculation table
  22+ 9AB1              ;   R     Q    Op            Sign calc
  23+ 9AB1              ;	10    5    Add           +    sign same add R sign
  24+ 9AB1              ;   -10   5    ABS Sub       -    sign diff ABS R > S sub R sign
  25+ 9AB1              ;   10   -5    ABS sub       +    sign diff ABS R > S sub R sign
  26+ 9AB1              ;	-10  -5    ABS Add       -    sign same add R sign
  27+ 9AB1              ;   5    10    Add           +    sign same add R sign
  28+ 9AB1              ;   -5   10    Swap ABS SUB  +    sign diff ABS Q > R swap SUB Q sign
  29+ 9AB1              ;   5    -10   swap ABS Sub  -    sign diff ABS Q > R swap SUB R sign
  30+ 9AB1              ;   -5   -10   ABS  add      -    sign same add R sign
  31+ 9AB1
  32+ 9AB1              ;   -10   5    ABS Sub       -    sign diff ABS R > S sub R sign
  33+ 9AB1              ;   10   -5    ABS sub       +    sign diff ABS R > S sub R sign
  34+ 9AB1              ;   -5   10    Swap ABS SUB  +    sign diff ABS Q > R swap SUB Q sign
  35+ 9AB1              ;   5    -10   swap ABS Sub  -    sign diff ABS Q > R swap SUB R sign
  36+ 9AB1
  37+ 9AB1
  38+ 9AB1              ; Calculate sign for Q from A and varS
  39+ 9AB1 21 5D 84     	ld		hl,varS							;
  40+ 9AB4 AE           	xor		(hl)							;  EOR &83		\ S	\ sign of operator is A xor S
  41+ 9AB5 FA C0 9A     	jp		m,.LL39Subtraction  			; if signs are different then we have subtraction
  42+ 9AB8 3A 5B 84     	ld		a,(varQ)						; Q	\ else addition, S already correct
  43+ 9ABB 21 5C 84     	ld		hl,varR
  44+ 9ABE 86           	add		a,(hl)							; a = Q + R
  45+ 9ABF C9           	ret										; Done carry set if overflow
  46+ 9AC0              .LL39Subtraction:							; 1 byte subtraction (S)A = R-Q
  47+ 9AC0 3A 5C 84     	ld		a,(varR)						; a = R
  48+ 9AC3 21 5B 84     	ld		hl,varQ                         ; Q
  49+ 9AC6              ;--	JumpIfALTMemHLusng LL39SwapSubtraction	; if a < (hl) then do LL39SwapSubtraction
  50+ 9AC6              	ClearCarryFlag                          ; we need to not use carry (6502 is different that it uses the compliement)
  50+ 9AC6 B7          >                        or a
  51+ 9AC7 9E           	sbc		a,(hl)							; A = R - Q which as R >= Q will always be a positive result
  52+ 9AC8 38 01            jr      c,.LL39SignCorrection
  53+ 9ACA              ;--    jr      a,.LL39ResultZero
  54+ 9ACA              ;--   JumpIfNegative LL39SignCorrection		; if there was underflow we have to correct sign
  55+ 9ACA              ;--	or		a								; Clear carry flag to say result is correct
  56+ 9ACA C9           	ret
  57+ 9ACB              .LL39SignCorrection:
  58+ 9ACB FE 00            cp      0                               ; if its 0 then neg will affect flag so we just zero result to save compute
  59+ 9ACD 28 0E            jr      z,.LL39ResultZero
  60+ 9ACF ED 44            neg                                     ; flip A 2'c value to positive
  61+ 9AD1 08           	ex		af,af'							; save A temporarily
  62+ 9AD2 3A 5D 84     	ld		a,(varS)						; Flip Sign bit in varS
  63+ 9AD5 EE 80        	xor		$80							    ;
  64+ 9AD7 32 5D 84     	ld		(varS),a                        ; flip sign bit of a
  65+ 9ADA 08           	ex		af,af'                          ; get back a which is the result
  66+ 9ADB                  ClearCarryFlag                          ; clear carry as NEG instrunction sets it for non zero
  66+ 9ADB B7          >                        or a
  67+ 9ADC C9           	ret
  68+ 9ADD              .LL39ResultZero:
  69+ 9ADD 32 5D 84         ld      (varS),a                        ; a is zero at this stage so set sign as well
  70+ 9AE0                  ClearCarryFlag                          ; clear carry
  70+ 9AE0 B7          >                        or a
  71+ 9AE1 C9               ret
  72+ 9AE2              ;--LL39SwapSubtraction:
  73+ 9AE2              ;--	push	bc
  74+ 9AE2              ;--	ld		b,a
  75+ 9AE2              ;--	ld		a,(hl)
  76+ 9AE2              ;--	sub		b
  77+ 9AE2              ;--	pop		bc
  78+ 9AE2              ;--	ex		af,af'							; do we flip here or negate. i think its flip as its overflowed unsigned
  79+ 9AE2              ;--	ld		a,(varS)
  80+ 9AE2              ;--	xor		$80
  81+ 9AE2              ;--	ld		(varS),a
  82+ 9AE2              ;--	ex		af,af'
  83+ 9AE2              ;--	ret
  84+ 9AE2
  85+ 9AE2              ;;;;	baddll38:				;.LL38	\ -> &4812 \ BADD(S)A=R+Q(SA) \ byte add (subtract)   (Sign S)A = R + Q*(Sign from A^S)
  86+ 9AE2              ;;;;; Calculate the following between sign-magnitude numbers:
  87+ 9AE2              ;;;;;   (S A) = (S R) + (A Q)
  88+ 9AE2              ;;;;; where the sign bytes only contain the sign bits, not magnitudes.
  89+ 9AE2              ;;;;; note goes wrong at <-127 >128 so need 16 bit version
  90+ 9AE2              ;;;;LL38:
  91+ 9AE2              ;;;;; Calculate sign for Q from A and varS
  92+ 9AE2              ;;;;	ld		hl,varS							;
  93+ 9AE2              ;;;;	xor		(hl)							;  EOR &83		\ S	\ sign of operator is A xor S
  94+ 9AE2              ;;;;	jp		m,.LL39Subtraction  			; if signs are different then we have subtraction
  95+ 9AE2              ;;;;	ld		a,(varQ)						; Q	\ else addition, S already correct
  96+ 9AE2              ;;;;	ld		hl,varR
  97+ 9AE2              ;;;;	add		a,(hl)							; a = Q + R
  98+ 9AE2              ;;;;	ret										; Done
  99+ 9AE2              ;;;;.LL39Subtraction:							; 1 byte subtraction (S)A = R-Q
 100+ 9AE2              ;;;;	ld		hl,varQ                         ;
 101+ 9AE2              ;;;;	ld		a,(hl)
 102+ 9AE2              ;;;;	JumpIfAGTENusng 128,LL39Sub16bit		; does this need to be 16 bit
 103+ 9AE2              ;;;;	ld		a,(varR)						;
 104+ 9AE2              ;;;;	ClearCarryFlag                          ; we need to not use carry (6502 is different that it uses the compliement)
 105+ 9AE2              ;;;;	sbc		a,(hl)							; A = R - Q
 106+ 9AE2              ;;;;	jr		c,.SignCorrection				; if there was underflow we have to correct sign
 107+ 9AE2              ;;;;	or		a								; Clear carry flag to say result is correct
 108+ 9AE2              ;;;;	ret
 109+ 9AE2              ;;;;.SignCorrection:
 110+ 9AE2              ;;;;    neg                                     ; flip A 2'c value to positive
 111+ 9AE2              ;;;;	ex		af,af'							; save A temporarily
 112+ 9AE2              ;;;;	ld		a,(varS)						; Flip Sign bit in varS
 113+ 9AE2              ;;;;	xor		$80							    ;
 114+ 9AE2              ;;;;	ld		(varS),a                        ; flip sign bit of a
 115+ 9AE2              ;;;;	ex		af,af'                          ; get back a which is the result
 116+ 9AE2              ;;;;	ret
 117+ 9AE2              ;;;;LL39Sub16Bit:
 118+ 9AE2              ;;;;	ld		e,a
 119+ 9AE2              ;;;;	ld		d,0
 120+ 9AE2              ;;;;	ld		a,(varR)
 121+ 9AE2              ;;;;	ld		l,a
 122+ 9AE2              ;;;;	ld		h,0
 123+ 9AE2              ;;;;	ClearCarryFlag
 124+ 9AE2              ;;;;	sbc		hl,de
 125+ 9AE2              ;;;;	jr		c,.SignCorrection16bit
 126+ 9AE2              ;;;;	bit		7,h
 127+ 9AE2              ;;;;	jr		z,.GoodToReturn
 128+ 9AE2              ;;;;.Needtonegate:
 129+ 9AE2              ;;;;	macronegate16hl
 130+ 9AE2              ;;;;.GoodToReturn
 131+ 9AE2              ;;;;	ld		a,l
 132+ 9AE2              ;;;;	or		a
 133+ 9AE2              ;;;;	ret
 134+ 9AE2              ;;;;.SignCorrection16bit:
 135+ 9AE2              ;;;;	macronegate16hl
 136+ 9AE2              ;;;;	ld		a,(varS)						; Flip Sign bit in varS
 137+ 9AE2              ;;;;	xor		$80							    ;
 138+ 9AE2              ;;;;	ld		(varS),a                        ; flip sign bit of a
 139+ 9AE2              ;;;;	ld		a,l
 140+ 9AE2              ;;;;	ret
 141+ 9AE2
 142+ 9AE2
# file closed: ./Maths/Utilities/badd_ll38.asm
 136  9AE2                  INCLUDE "./Maths/Utilities/moveship4-MVS4.asm"
# file opened: ./Maths/Utilities/moveship4-MVS4.asm
   1+ 9AE2              ; Note comparing hl vs iY, you need at least 3 incs or decs for hl to be slower
   2+ 9AE2              ; it may be faster though if we can use hl to avoid memory actions if needed
   3+ 9AE2              ; need to optimise mad as push hl pop hl and use de doesn't really improve speed
   4+ 9AE2
   5+ 9AE2
   6+ 9AE2              moveship4Yreg:
   7+ 9AE2 3A 46 83     		ld		a,(regY)
   8+ 9AE5 47           		ld		b,a
   9+ 9AE6              moveship4breg:
  10+ 9AE6              		; b = Y index, 9 = nosev, 15 = roofv 21 = sidev
  11+ 9AE6              MVS4PitchAlphaRollBeta:
  12+ 9AE6              MVS4:										;.MVS4	\ -> &52A1 \ Moveship4, Y is matrix row, pitch&roll update to coordinates
  13+ 9AE6 3A 71 83     		ld		a,(ALPHA)					;  ALPHA
  14+ 9AE9 32 5B 84     		ld		(varQ),a					; player ship's roll Q = Alpha
  15+ 9AEC 21 02 00     		ld		hl,UBnKxsgn
  16+ 9AEF 78           		ld		a,b							; from
  17+ 9AF0 ED 31        		add		hl,a
  18+ 9AF2 7E           		ld		a,(hl)						; INWK+2,Y
  19+ 9AF3 32 5C 84     		ld		(varR),a					; R  \ lo
  20+ 9AF6 23           		inc		hl
  21+ 9AF7 7E           		ld		a,(hl)						; INWK+3,Y
  22+ 9AF8 32 5D 84     		ld		(varS),a					; S  \ hi		SR = nosev_y (or axis y)
  23+ 9AFB 2B           		dec		hl
  24+ 9AFC 2B           		dec		hl
  25+ 9AFD 2B           		dec		hl							;
  26+ 9AFE 7E           		ld		a,(hl)						; INWK+0,Y
  27+ 9AFF 32 58 83     		ld		(varP),a					; P  \ over-written	 P = nosevx lo
  28+ 9B02 23           		inc		hl
  29+ 9B03 7E           		ld		a,(hl)						; INWK+1,Y
  30+ 9B04 EE 80        		xor		$80							; flip sign  AP = nosevx * - 1
  31+ 9B06 CD 5C 93     		call	madXAequQmulAaddRS			; MAD	\ DE = X.A = alpha*INWK+1,Y + INWK+2to3,Y
  32+ 9B09 23                   inc     hl
  33+ 9B0A 23                   inc     hl
  34+ 9B0B 77                   ld      (hl),a                      ; INWK+3,Y \ hi
  35+ 9B0C 2B                   dec     hl
  36+ 9B0D 3A 45 83             ld      a,(regX)
  37+ 9B10 77                   ld      (hl),a                      ; INWK+2,Y \ Y=Y-aX   \ their comment
  38+ 9B11 32 58 83             ld      (varP),a                    ;  P
  39+ 9B14 2B                   dec     hl
  40+ 9B15 2B                   dec     hl
  41+ 9B16 7E                   ld      a,(hl)                      ; INWK+0,Y
  42+ 9B17 32 5C 84             ld      (varR),a                    ;  R	\ lo
  43+ 9B1A 23                   inc     hl
  44+ 9B1B 7E                   ld      a,(hl)                      ;  INWK+1,Y
  45+ 9B1C 32 5D 84             ld      (varS),a                    ; S	\ hi
  46+ 9B1F 23                   inc     hl
  47+ 9B20 23                   inc     hl
  48+ 9B21 7E                   ld      a,(hl)                      ; INWK+3,Y
  49+ 9B22 CD 5C 93             call    madXAequQmulAaddRS          ; MAD	\ X.A = alpha*INWK+3,Y + INWK+0to1,Y
  50+ 9B25 2B                   dec     hl
  51+ 9B26 2B                   dec     hl
  52+ 9B27 77                   ld      (hl),a                      ; INWK+1,Y  \ hi
  53+ 9B28 3A 45 83             ld      a,(regX)
  54+ 9B2B 2B                   dec     hl
  55+ 9B2C 77                   ld      (hl),a                      ; INWK+0,Y  \ X=X+aY   \ their comment
  56+ 9B2D 32 58 83             ld      (varP),a                    ; P
  57+ 9B30 3A 63 83             ld      a,(BETA)                    ; BETA
  58+ 9B33 32 5B 84             ld      (varQ),a                    ; Q	\ player ship's pitch
  59+ 9B36 23                   inc     hl
  60+ 9B37 23                   inc     hl
  61+ 9B38 7E                   ld      a,(hl)                      ; INWK+2,Y
  62+ 9B39 32 5C 84             ld      (varR),a                    ; R	\ lo
  63+ 9B3C 23                   inc     hl
  64+ 9B3D 7E                   ld      a,(hl)                      ; INWK+3,Y
  65+ 9B3E 32 5D 84             ld      (varS),a                    ; S	\ hi
  66+ 9B41 23                   inc     hl
  67+ 9B42 7E                   ld      a,(hl)                      ; INWK+4,Y
  68+ 9B43 32 58 83             ld      (varP),a                    ; P	\ lo
  69+ 9B46 23                   inc     hl
  70+ 9B47 7E                   ld      a,(hl)                      ; INWK+5,Y
  71+ 9B48 EE 80                xor     $80                         ; flip sign hi
  72+ 9B4A CD 5C 93             call    madXAequQmulAaddRS          ; MAD	\ X.A =-beta*INWK+5,Y + INWK+2to3,Y
  73+ 9B4D 2B                   dec     hl
  74+ 9B4E 2B                   dec     hl
  75+ 9B4F 77                   ld      (hl),a                      ; INWK+3,Y \ hi
  76+ 9B50 3A 45 83             ld      a,(regX)
  77+ 9B53 2B                   dec     hl
  78+ 9B54 77                   ld      (hl),a                      ; INWK+2,Y \ Y=Y-bZ  \ their comment
  79+ 9B55 32 58 83             ld      (varP),a                    ; P
  80+ 9B58 23                   inc     hl
  81+ 9B59 23                   inc     hl
  82+ 9B5A 7E                   ld      a,(hl)                      ; INWK+4,Y
  83+ 9B5B 32 5C 84             ld      (varR),a                    ; R	\ lo
  84+ 9B5E 23                   inc     hl
  85+ 9B5F 7E                   ld      a,(hl)                      ; INWK+5,Y
  86+ 9B60 32 5D 84             ld      (varS),a                    ; S	\ hi
  87+ 9B63 2B                   dec     hl
  88+ 9B64 2B                   dec     hl
  89+ 9B65 7E                   ld      a,(hl)                      ; INWK+3,Y
  90+ 9B66 CD 5C 93             call    madXAequQmulAaddRS          ; MAD	\ X.A = beta*INWK+3,Y + INWK+4,5,Y
  91+ 9B69 23                   inc     hl
  92+ 9B6A 23                   inc     hl
  93+ 9B6B 77                   ld      (hl),a                      ; INWK+5,Y \ hi
  94+ 9B6C 3A 45 83             ld      a,(regX)
  95+ 9B6F 2B                   dec     hl
  96+ 9B70 77                   ld      (hl),a                      ; INWK+4,Y \ Z=Z+bY   \ their comment
  97+ 9B71 C9                   ret
  98+ 9B72
  99+ 9B72
# file closed: ./Maths/Utilities/moveship4-MVS4.asm
 137  9B72                  INCLUDE "./Maths/Utilities/RequAmul256divQ-BFRDIV.asm"
# file opened: ./Maths/Utilities/RequAmul256divQ-BFRDIV.asm
   1+ 9B72              ;;;LL28:
   2+ 9B72              ;;;    ld      c,a                         ;
   3+ 9B72              ;;;    ld      a,(varQ)                    ;
   4+ 9B72              ;;;    ld      b,a                         ;
   5+ 9B72              ;;;    ld      a,c                         ; Get varQ into b and retain c
   6+ 9B72              ;;;RequAmul256divB:                        ;
   7+ 9B72              ;;;LL28Breg:
   8+ 9B72              ;;;; "BFRDIV R = (A * 256 / Q)  byte from remainder of division, not signed a = a, b = q, c = r"
   9+ 9B72              ;;;	cp		b							; Check A >= Q
  10+ 9B72              ;;;	jr		nc, .AnswerTooBig			; A >= Q? yes too big
  11+ 9B72              ;;;.CalcRemainder:
  12+ 9B72              ;;;	ld		c, 	$FE						; set R to $FE
  13+ 9B72              ;;;.RollRemainder:
  14+ 9B72              ;;;	sla		a
  15+ 9B72              ;;;	jr		c,.Reduce					; if a >> generates carry reduce
  16+ 9B72              ;;;	cp		b							; a < q?
  17+ 9B72              ;;;	jr		nc,.DontSBC
  18+ 9B72              ;;;.DoSBC:									; a is < q
  19+ 9B72              ;;;	sbc		a,b							; 	a -= q
  20+ 9B72              ;;;.DontSBC:
  21+ 9B72              ;;;	rl		c							; r << 1
  22+ 9B72              ;;;	jr		c, .RollRemainder			; if rol generated a carry, continue
  23+ 9B72              ;;;    ld      a,c
  24+ 9B72              ;;;    ld      (varR),a
  25+ 9B72              ;;;	ret									; R (c) left with remainder
  26+ 9B72              ;;;.Reduce:								; a geneated a carry
  27+ 9B72              ;;;	sbc		a,b							; a = a - (q +1)
  28+ 9B72              ;;;	scf									; set carry flag for rl
  29+ 9B72              ;;;	rl		c							; r << 1 briging in carry
  30+ 9B72              ;;;	jr		c,	.RollRemainder			; if a carry fell off bit 7 then repeat
  31+ 9B72              ;;;    ld      a,c
  32+ 9B72              ;;;    ld      (varR),a
  33+ 9B72              ;;;	ret
  34+ 9B72              ;;;.AnswerTooBig:
  35+ 9B72              ;;;	ld	    c,$FF							; arse its too big
  36+ 9B72              ;;;    ld      a,c
  37+ 9B72              ;;;    ld      (varR),a
  38+ 9B72              ;;;	ret
  39+ 9B72
  40+ 9B72              BCequAmul256DivC:
  41+ 9B72 59             ld    e,c
  42+ 9B73 67             ld    h,a
  43+ 9B74 2E 00          ld    l,0
  44+ 9B76              AdivEDivide:                             ; this routine performs the operation BC=HL/E
  45+ 9B76 7B             ld a,e                                 ; checking the divisor; returning if it is zero
  46+ 9B77 B7             or a                                   ; from this time on the carry is cleared
  47+ 9B78 C8             ret z
  48+ 9B79 01 FF FF       ld bc,-1                               ; BC is used to accumulate the result
  49+ 9B7C 16 00          ld d,0                                 ; clearing D, so DE holds the divisor
  50+ 9B7E              AdivEDivLoop:                            ; subtracting DE from HL until the first overflow
  51+ 9B7E ED 52          sbc hl,de                              ; since the carry is zero, SBC works as if it was a SUB
  52+ 9B80 03             inc bc                                 ;  note that this instruction does not alter the flags
  53+ 9B81 30 FB          jr nc,AdivEDivLoop                     ; no carry means that there was no overflow
  54+ 9B83 C9             ret
  55+ 9B84
  56+ 9B84              HL_Div_C:
  57+ 9B84              ; Integer divides HL by C
  58+ 9B84              ; Result in HL, remainder in A
  59+ 9B84              ; Clobbers F, B
  60+ 9B84 06 10                ld b,16
  61+ 9B86 AF                   xor a
  62+ 9B87              HL_Div_C_Loop:
  63+ 9B87 29                   add hl,hl
  64+ 9B88 17                   rla
  65+ 9B89 B9                   cp c
  66+ 9B8A 38 02                jr c,HL_DivC_Skip
  67+ 9B8C 91                   sub c
  68+ 9B8D 2C                   inc l
  69+ 9B8E              HL_DivC_Skip:
  70+ 9B8E 10 F7                djnz HL_Div_C_Loop
  71+ 9B90 7D                   ld   a,l
  72+ 9B91 32 5C 84             ld  (varR),a
  73+ 9B94 C9                   ret
  74+ 9B95
  75+ 9B95
  76+ 9B95
  77+ 9B95              ; Entry point if varQ is populated with demoninator
  78+ 9B95              RequAmul256divQ:
  79+ 9B95              BFRDIV:
  80+ 9B95 F5           		push	af
  81+ 9B96 3A 5B 84     		ld		a,(varQ)
  82+ 9B99 4F           		ld		c,a
  83+ 9B9A F1           		pop		af
  84+ 9B9B FE 00        		cp		0
  85+ 9B9D CA B4 9B     		jp		z, HLDIVC_0_BY	; fast exit if numerator is 0
  86+ 9BA0              RequAmul256divC:
  87+ 9BA0 2E 00        		ld		l,0
  88+ 9BA2 67           		ld		h,a
  89+ 9BA3              HL_Div_Cold:						; fast entry point if C and HL are already set
  90+ 9BA3 06 10        		ld b,16
  91+ 9BA5 AF           		xor a
  92+ 9BA6              LOOPPOINT:
  93+ 9BA6 29           		add hl,hl
  94+ 9BA7 17           		rla
  95+ 9BA8 B9           		cp c
  96+ 9BA9 38 02        		jr c,SKIPINCSUB
  97+ 9BAB 2C           		inc l
  98+ 9BAC 91           		sub c
  99+ 9BAD              SKIPINCSUB:
 100+ 9BAD 10 F7        		djnz LOOPPOINT
 101+ 9BAF 7D           		ld		a,l
 102+ 9BB0 32 5C 84     		ld 		(varR),a
 103+ 9BB3 C9           		ret
 104+ 9BB4              HLDIVC_0_BY:
 105+ 9BB4 32 5C 84     		ld		(varR),a
 106+ 9BB7 C9           		ret
 107+ 9BB8              ;	push	af
 108+ 9BB8              ;	ld		a,b
 109+ 9BB8              ;	ld		(varQ),a
 110+ 9BB8              ;	pop		af
 111+ 9BB8              ;RequAmul256divQ:
 112+ 9BB8              ;BFRDIV:									;BFRDIV R=A*256/Q   byte from remainder of division
 113+ 9BB8              ;	ld		hl,varQ
 114+ 9BB8              ;	JumpIfAGTENusng	(hl),LL2			;  is A >=  Q ?, if yes, answer too big for 1 byte, R=#&FF
 115+ 9BB8              ;	ld		b,$FE						; b = X
 116+ 9BB8              ;	ld		c,a							; c = R	div roll counter
 117+ 9BB8              ;LL31:									; roll R
 118+ 9BB8              ;	sla		a
 119+ 9BB8              ;	jr		c,LL29						; hop to Reduce
 120+ 9BB8              ;	JumpIfALTNusng (hl)					; Q skip sbc if a < Q
 121+ 9BB8              ;	sbc		a,(hl)						; a = a - Q
 122+ 9BB8              ;	rl		c							; rotate R left
 123+ 9BB8              ;	jr		c,LL31						; loop if R poped out a carry bit
 124+ 9BB8              ;	jr		LL2Good
 125+ 9BB8              ;LL29:									; Reduce
 126+ 9BB8              ;	sbc		a,(hl)
 127+ 9BB8              ;	scf
 128+ 9BB8              ;	rl		c							; roll a carry flag into R
 129+ 9BB8              ;	jr		c,LL31						;  loop R
 130+ 9BB8              ;	jr		LL2Good
 131+ 9BB8              ;LL2:
 132+ 9BB8              ;	ld		c,$FF
 133+ 9BB8              ;LL2Good:
 134+ 9BB8              ;	ld		a,c
 135+ 9BB8              ;	ld		(varR),a
 136+ 9BB8              ;	ret
 137+ 9BB8
# file closed: ./Maths/Utilities/RequAmul256divQ-BFRDIV.asm
 138  9BB8                  INCLUDE "./Maths/Utilities/RequAdivQ-LL61.asm"
# file opened: ./Maths/Utilities/RequAdivQ-LL61.asm
   1+ 9BB8              RequAdivQ:
   2+ 9BB8              	; R = A/Q, U = remainder, code looked a little odd as if R is reminader and U = result
   3+ 9BB8              LL61:										; Handling division R=A/Q for case further down
   4+ 9BB8 4F           	ld		c,a								; c = A
   5+ 9BB9 3A 5B 84     	ld		a,(varQ)						; test for divide by 0
   6+ 9BBC FE 00        	cp		0
   7+ 9BBE 28 16        	jr		z,LL84							; divide by zero error
   8+ 9BC0 57           	ld		d,a								; now we can do C/D
   9+ 9BC1 06 08            ld b,8
  10+ 9BC3 AF               xor a
  11+ 9BC4              LL63:										; roll divide loop
  12+ 9BC4 CB 21            sla c
  13+ 9BC6 17               rla
  14+ 9BC7 BA               cp d
  15+ 9BC8 38 02            jr c,LL64
  16+ 9BCA 0C               inc c
  17+ 9BCB 92               sub d
  18+ 9BCC              LL64:
  19+ 9BCC 10 F6            djnz LL63
  20+ 9BCE 32 5A 84     	ld	(varU),a							; store remainder in U
  21+ 9BD1 79           	ld	a,c
  22+ 9BD2 32 5C 84     	ld	(varR),a							; store remainder in R
  23+ 9BD5 C9               ret
  24+ 9BD6              LL84:										; div error  R=U=#5
  25+ 9BD6 3E 32        	ld		a,50
  26+ 9BD8 32 5C 84     	ld		(varR),a
  27+ 9BDB 32 5A 84     	ld		(varU),a
  28+ 9BDE C9           	ret
  29+ 9BDF
# file closed: ./Maths/Utilities/RequAdivQ-LL61.asm
 139  9BDF                  INCLUDE "./Maths/Utilities/RSequQmulA-MULT12.asm"
# file opened: ./Maths/Utilities/RSequQmulA-MULT12.asm
   1+ 9BDF              asm_mult12:
   2+ 9BDF              RSequQmulA:
   3+ 9BDF              ; "asm_ult12  R.S = Q * A \ visited quite often S = hi, R = lo, odd that its opposite to mult1"
   4+ 9BDF CD 87 9A     	call APequQmulA
   5+ 9BE2 08           	ex 	af,af'
   6+ 9BE3 7A           	ld	a,d
   7+ 9BE4 32 5D 84     	ld	(varS),a
   8+ 9BE7 7B           	ld	a,e
   9+ 9BE8 32 5C 84     	ld	(varR),a
  10+ 9BEB 08           	ex 	af,af'
  11+ 9BEC C9           	ret
  12+ 9BED
# file closed: ./Maths/Utilities/RSequQmulA-MULT12.asm
 140  9BED                  INCLUDE "./Maths/Utilities/LL28AequAmul256DivD.asm"
# file opened: ./Maths/Utilities/LL28AequAmul256DivD.asm
   1+ 9BED
   2+ 9BED              LL28Amul256DivD:        JumpIfAGTENusng  d, .Ll28Exit255
   2+ 9BED BA          >                        cp     d
   2+ 9BEE D2 0C 9C    >                        jp		nc,.Ll28Exit255
   3+ 9BF1 1E FE                                ld      e,%11111110                 ; Set R to have bits 1-7 set, so we can rotate through 7
   4+ 9BF3 CB 27        .LL31:                  sla     a
   5+ 9BF5 38 0D                                jr      c,.LL29
   6+ 9BF7                                      JumpIfALTNusng  d, .SkipSub         ; will jump if carry set, so we need to reset on the rol
   6+ 9BF7 BA          >                        cp      d
   6+ 9BF8 DA FD 9B    >                        jp		c, .SkipSub
   7+ 9BFB 92                                   sub     d
   8+ 9BFC                                      ClearCarryFlag                      ; reset clarry as it will be complimented for rotate as 6502 does carry flags inverted
   8+ 9BFC B7          >                        or a
   9+ 9BFD 3F           .SkipSub:               ccf                                 ; if we did the subtract the carry will be clear so we need to invert to roll in.
  10+ 9BFE CB 13                                rl      e
  11+ 9C00 38 F1                                jr      c,.LL31
  12+ 9C02 7B                                   ld      a,e
  13+ 9C03 C9                                   ret
  14+ 9C04 92           .LL29:                  sub     d                           ; A >= Q, so set A = A - Q
  15+ 9C05 37                                   scf                                 ; Set the C flag to rotate into the result in R
  16+ 9C06 CB 13                                rl      e                           ; rotate counter e left
  17+ 9C08 38 E9                                jr      c,.LL31                     ; if a bit was spat off teh end then loop
  18+ 9C0A 7B                                   ld      a,e                         ; stick result in a
  19+ 9C0B C9                                   ret
  20+ 9C0C 3E FF        .Ll28Exit255:           ld  a,255                           ; Fail with FF as result
  21+ 9C0E C9                                   ret
  22+ 9C0F
# file closed: ./Maths/Utilities/LL28AequAmul256DivD.asm
 141  9C0F                  INCLUDE "./Maths/Utilities/XAequMinusXAPplusRSdiv96-TIS1.asm"
# file opened: ./Maths/Utilities/XAequMinusXAPplusRSdiv96-TIS1.asm
   1+ 9C0F              XAequMinusXAplusRSdiv96:					;.TIS1	\ -> &293B  \ Tidy subroutine 1  X.A =  (-X*A  + (R.S))/96
   2+ 9C0F              TIS1:
   3+ 9C0F 08           		ex		af,af'
   4+ 9C10 3A 45 83     		ld		a,(regX)
   5+ 9C13 47           		ld		b,a
   6+ 9C14 08           		ex		af,af'
   7+ 9C15              BAequMinusBAplusRSdiv96:					;.TIS1	\ -> &293B  \ Tidy subroutine 1 using B register = X
   8+ 9C15 08           		ex		af,af'
   9+ 9C16 78           		ld		a,b
  10+ 9C17 32 5B 84     		ld		(varQ),a
  11+ 9C1A 08           		ex		af,af'
  12+ 9C1B EE 80        		xor		$80							;	 flip sign of Acc
  13+ 9C1D CD 5C 93     		call	madXAequQmulAaddRS			; \ MAD \ multiply and add (X,A) =  -X*A  + (R,S)
  14+ 9C20              ; USES 				A BC E
  15+ 9C20              ; DOES NOT USE		D HL
  16+ 9C20              Div96:										; .DVID96	\ Their comment A=A/96: answer is A*255/96
  17+ 9C20 47           		ld		b,a
  18+ 9C21 E6 80        		and		$80							;	hi sign
  19+ 9C23 5F           		ld		e,a							;   e = varT
  20+ 9C24 78           		ld		a,b
  21+ 9C25 E6 7F        		and		$7F							;	hi A7
  22+ 9C27 06 FE        		ld		b,$FE						;   slide counter
  23+ 9C29 48           		ld		c,b							;   c == T1 ::  T1
  24+ 9C2A              .DVL3:										;   roll T1  clamp Acc to #96 for rotation matrix unity
  25+ 9C2A CB 27        		sla		a
  26+ 9C2C FE 60        		cp		$60							; max 96
  27+ 9C2E 30 02        		jr		nc,.DV4
  28+ 9C30 DE 60        		sbc		a,$60							;  SBC #&60
  29+ 9C32              .DV4:										; skip subtraction
  30+ 9C32 CB 11        		rl		c							;  T1
  31+ 9C34 38 F4        		jr		c,.DVL3
  32+ 9C36 79           		ld		a,c							;   T1
  33+ 9C37 B3           		or		e							;   restore T sign
  34+ 9C38 C9           		ret
  35+ 9C39
# file closed: ./Maths/Utilities/XAequMinusXAPplusRSdiv96-TIS1.asm
 142  9C39
 143  9C39
 144  9C39              ;--------------------------------------------------------------------------------------------------------------------
 145  9C39                  INCLUDE "./ModelRender/CLIP-LL145.asm"
# file opened: ./ModelRender/CLIP-LL145.asm
   1+ 9C39              ;--------------------------------------------------------------------------------------------------------------------
   2+ 9C39
   3+ 9C39 00           clipDx                  DB      0           ; also XX12+2
   4+ 9C3A 00           clipDxHigh              DB      0           ; also XX12+3
   5+ 9C3B 00           clipDxHighNonABS        DB      0           ; also XX12+3
   6+ 9C3C 00           clipDy                  DB      0           ; also XX12+4
   7+ 9C3D 00           clipDyHigh              DB      0           ; also XX12+5
   8+ 9C3E 00           clipGradient            DB      0
   9+ 9C3F 00           clipDxySign             DB      0
  10+ 9C40              varX12p3                equ     clipDxySign
  11+ 9C40 00           clipXGTY                DB      0
  12+ 9C41 00           clipFlags               DB      0
  13+ 9C42 00           SWAP                    DB      0
  14+ 9C43 00 00        varYX                   DW      0
  15+ 9C45              ;varRegX                 DB      0
  16+ 9C45              ;varXX12p2               DB      0
  17+ 9C45 00           clipXX13                 DB      0
  18+ 9C46
  19+ 9C46
  20+ 9C46              ; bounds check and the start to avoid dxy calcs if off screen, eliminating off screens first saves a lot of uncessary mul/div
  21+ 9C46              ;ClipXX15XX12Line:
  22+ 9C46 ED 4B 9E 9E  ClipLine:               ld      bc,(UbnkPreClipY1)          ; bc - XX15(2,3)
  23+ 9C4A DD 2A A2 9E                          ld      ix,(UbnkPreClipY2)          ; ix - XX12(0,1)
  24+ 9C4E 2A 9C 9E                             ld      hl,(UbnkPreClipX1)          ; hl - XX15(0,1)
  25+ 9C51 ED 5B A0 9E                          ld      de,(UbnkPreClipX2)          ; de - XX15(4,5)
  26+ 9C55 AF                                   xor     a
  27+ 9C56 32 42 9C                             ld      (SWAP),a                    ; SWAP = 0
  28+ 9C59 7A                                   ld      a,d                         ; A = X2Hi
  29+ 9C5A FD 26 BF     .LL147:                 ld      iyh,$BF                     ; we need to be 191 as its 128 + another bit set from 0 to 6, we are using iyh as regX
  30+ 9C5D                                      ;       push    af
  31+ 9C5D                                      ;       ld      a,iyh
  32+ 9C5D                                      ;       ld      (regX),a
  33+ 9C5D                                      ;       pop     af
  34+ 9C5D DD B4                                or      ixh                         ; if (X2Hi L-OR Y2 Hi <> 0) goto LL107             -- X2Y2 off screen
  35+ 9C5F 20 0A                                jr      nz, .LL107
  36+ 9C61 DD 7D                                ld      a,ixl
  37+ 9C63 ED 27 80                             test    $80                         ; if screen hight < y2 lo, i.e y2 lo >127 goto LL107,
  38+ 9C66 20 03                                jr      nz,.LL107
  39+ 9C68 FD 26 00                             ld      iyh, 0                      ; else iyh = regX = 0                                                                        -- X2Y2 on screen
  40+ 9C6B                                      ;        push    af
  41+ 9C6B                                      ;        ld      a,iyh
  42+ 9C6B                                      ;        ld      (regX),a
  43+ 9C6B                                      ;        pop     af
  44+ 9C6B              ; XX13 = regX (i.e. iyh)      ( if XX13 = XX13 is 191 if (x2, y2) is off-screen else 0) we bin XX13 as not needed
  45+ 9C6B              ; so XX13 = 0 if x2_hi = y2_hi = 0, y2_lo is on-screen,  XX13 = 191 if x2_hi or y2_hi are non-zero or y2_lo is off the bottom of the screen
  46+ 9C6B FD 7C        .LL107                  ld      a,iyh
  47+ 9C6D 32 45 9C                             ld      (clipXX13),a                ; debug copy iyh to xx13
  48+ 9C70 7C                                   ld      a,h                         ; If (X1 hi L-OR Y1) hi  goto LL83                   -- X1Y1 off screen and maybe X2Y2
  49+ 9C71 B0                                   or      b                           ;
  50+ 9C72 20 27                                jr      nz,.LL83                    ;
  51+ 9C74 79                                   ld      a,c                         ; or (y1 lo > bottom of screen)
  52+ 9C75 ED 27 80                             test    $80                         ; i.e  screen height < y1)
  53+ 9C78 20 21                                jr      nz,.LL83
  54+ 9C7A              ; If we get here, (x1, y1) is on-screen
  55+ 9C7A FD 7C                                ld      a,iyh                       ; iyh = xx13 at this point if  XX13 <> 0 goto LL108                                                        -- X1Y1 on screen, if we flagged X2Y2 off screen goto LL108
  56+ 9C7C FE 00                                cp      0
  57+ 9C7E 20 15                                jr      nz, .LL108
  58+ 9C80              ; Finished clipping exit point ----------------------------------------------------------------------------------------
  59+ 9C80 79           .ClipDone:              ld      a,c                         ; LL146 (Clip Done)               Y1 = y1 lo, x2 = x2 lo, x1 = x1 lo y1 = y1 lo                                   -- Nothing off screen
  60+ 9C81 32 9D 9E                             ld      (UBnkNewY1),a
  61+ 9C84 DD 7D                                ld      a,ixl
  62+ 9C86 32 9F 9E                             ld      (UBnkNewY2),a
  63+ 9C89 7D                                   ld      a,l
  64+ 9C8A 32 9C 9E                             ld      (UBnkNewX1),a
  65+ 9C8D 7B                                   ld      a,e
  66+ 9C8E 32 9E 9E                             ld      (UBnkNewX2),a
  67+ 9C91                                      ClearCarryFlag                      ; carry is clear so valid to plot is in XX15(0to3)
  67+ 9C91 B7          >                        or a
  68+ 9C92 C9                                   ret                                 ; 2nd pro different, it swops based on swop flag around here.
  69+ 9C93              ; Finished out of bounds exit point -----------------------------------------------------------------------------------
  70+ 9C93 37           .PointsOutofBounds:     scf                                 ; LL109 (ClipFailed) carry flag set as not visible
  71+ 9C94 C9                                   ret
  72+ 9C95 FD 7C        .LL108:                 ld      a,iyh
  73+ 9C97 B7                                   or      a
  74+ 9C98 1F                                   rra
  75+ 9C99 FD 67                                ld      iyh,a                       ; (X2Y2 Off Screen)         XX13 = 95 (i.e. divide it by 2)                                                 -- X1Y1 on screen X2Y2 off screen
  76+ 9C9B                                      ;        push    af                  ;OPTIMISATION 6/11/21 commented out
  77+ 9C9B                                      ;        ld      a,iyh               ;OPTIMISATION 6/11/21 commented out
  78+ 9C9B                                      ;        ld      (regX),a            ;OPTIMISATION 6/11/21 commented out
  79+ 9C9B                                      ;        pop     af                  ;OPTIMISATION 6/11/21 commented out
  80+ 9C9B FD 7C        .LL83:                  ld      a,iyh                       ; (Line On screen Test)      if XX13 < 128 then only 1 point is on screen so goto LL115                      -- We only need to deal with X2Y2
  81+ 9C9D ED 27 80                             test    $80                         ;
  82+ 9CA0 28 28                                jr      z, .LL115                   ;
  83+ 9CA2 7C                                   ld      a,h                         ; If both x1_hi and x2_hi have bit 7 set, jump to LL109  to return from the subroutine with the C flag set, as the entire line is above the top of the screen
  84+ 9CA3 A2                                   and     d
  85+ 9CA4                                      JumpIfNegative  .PointsOutofBounds
  85+ 9CA4 FA 93 9C    >                        jp		m, .PointsOutofBounds
  86+ 9CA7 78                                   ld      a,b                         ; If both y1_hi and y2_hi have bit 7 set, jump to LL109  to return from the subroutine with the C flag set, as the entire line is above the top of the screen
  87+ 9CA8 DD A4                                and     ixh
  88+ 9CAA                                      JumpIfNegative  .PointsOutofBounds
  88+ 9CAA FA 93 9C    >                        jp		m, .PointsOutofBounds
  89+ 9CAD 7C                                   ld      a,h                         ; If neither (x1_hi - 1) or (x2_hi - 1) have bit 7 set, jump to LL109 to return from the subroutine with the C  flag set, as the line doesn't fit on-screen
  90+ 9CAE 3D                                   dec     a
  91+ 9CAF FD 6F                                ld      iyl,a                       ; using iyl as XX12+2 var
  92+ 9CB1                                      ;        push    af                 ;OPTIMISATION 6/11/21 commented out
  93+ 9CB1                                      ;        ld      a,iyl              ;OPTIMISATION 6/11/21 commented out
  94+ 9CB1                                      ;        ld      (varXX12p2),a      ;OPTIMISATION 6/11/21 commented out
  95+ 9CB1                                      ;        pop     af                 ;OPTIMISATION 6/11/21 commented out
  96+ 9CB1 7A                                   ld      a,d                         ; a = x2 hi
  97+ 9CB2 3D                                   dec     a
  98+ 9CB3 FD B5                                or      iyl                         ; (x2 hi -1 ) or (x1 hi -1)
  99+ 9CB5                                      JumpIfPositive .PointsOutofBounds   ; if both x1 and x2hi were > 0 then subtracting 1 would result in 0..254 so either being negative means it was 0 before
  99+ 9CB5 F2 93 9C    >                        jp		p, .PointsOutofBounds
 100+ 9CB8              ;by here we have eliminated -ve Y1 bounds so can just test for positive high and bit 7 of lo
 101+ 9CB8 DD 7C                                ld      a,ixh
 102+ 9CBA 3D                                   dec     a
 103+ 9CBB FD 6F                                ld      iyl,a
 104+ 9CBD 78                                   ld      a,b
 105+ 9CBE 3D                                   dec     a
 106+ 9CBF FD B5                                or      iyl
 107+ 9CC1                                      JumpIfPositive .PointsOutofBounds   ; if both x1 and x2hi were > 0 then subtracting 1 would result in 0..254 so either being negative means it was 0 before
 107+ 9CC1 F2 93 9C    >                        jp		p, .PointsOutofBounds
 108+ 9CC4 79                                   ld      a,c
 109+ 9CC5 DD A5                                and     ixl
 110+ 9CC7                                      JumpIfNegative .PointsOutofBounds   ; really if both are > 127
 110+ 9CC7 FA 93 9C    >                        jp		m, .PointsOutofBounds
 111+ 9CCA              ; Clip line: calulate the line's gradient
 112+ 9CCA              ; here as an optimisation we make sure X1 is always < X2  later on
 113+ 9CCA              .LL115:                 ClearCarryFlag
 113+ 9CCA B7          >                        or a
 114+ 9CCB E5 D5        .CalcDX:                push    hl,,de
 115+ 9CCD EB                                   ex      hl,de                       ; so hl is x2 and de = x1
 116+ 9CCE ED 52                                sbc     hl,de
 117+ 9CD0                                     ; pop     de                          ; we need de back
 118+ 9CD0 22 39 9C                             ld      (clipDx),hl
 119+ 9CD3 7C                                   ld      a,h
 120+ 9CD4 32 3B 9C                             ld      (clipDxHighNonABS),a
 121+ 9CD7                                     ; ld      a,e                         ;a = x2 lo
 122+ 9CD7                                     ; sbc     a,l                         ;a= a - x1
 123+ 9CD7                                     ; ld      (clipDx),a
 124+ 9CD7                                     ; ld      a,d
 125+ 9CD7                                     ; sbc     a,h
 126+ 9CD7                                     ; ld      (clipDxHigh),a                ; later we will just move to sub hl,de
 127+ 9CD7                                     ; ld      (clipDxHighNonABS),a          ; it looks liek we need this later post scale loop
 128+ 9CD7              .CalcDy:                ClearCarryFlag
 128+ 9CD7 B7          >                        or a
 129+ 9CD8 DD E5 E1                             ld      hl,ix
 130+ 9CDB ED 42                                sbc     hl,bc
 131+ 9CDD 54 5D                                ld      de,hl           ;;OPTIMISATION 6/11/21
 132+ 9CDF 22 3C 9C                             ld      (clipDy),hl     ;OPTIMISATION 6/11/21 commented out
 133+ 9CE2 7C           .CalcQuadrant:          ld      a,h
 134+ 9CE3                                     ; ld      a,ixl
 135+ 9CE3                                     ; sbc     c
 136+ 9CE3                                     ; ld      (clipDy),a
 137+ 9CE3                                     ; ld      a,ixh
 138+ 9CE3                                     ; sbc     a,b
 139+ 9CE3                                     ; ld      (clipDyHigh),a              ; so A = sign of deltay in effect
 140+ 9CE3                                     ; pop     hl
 141+ 9CE3
 142+ 9CE3              ;So we now have delta_x in XX12(3 2), delta_y in XX12(5 4)  where the delta is (x1, y1) - (x2, y2))
 143+ 9CE3                                    ;  push    hl                          ; Set S = the sign of delta_x * the sign of delta_y, so if bit 7 of S is set, the deltas have different signs
 144+ 9CE3 21 3A 9C                             ld      hl,clipDxHigh
 145+ 9CE6 AE                                   xor     (hl)                        ; now a = sign dx xor sign dy
 146+ 9CE7 32 5D 84                             ld      (varS),a                    ; DEBGU putting it in var S too for now
 147+ 9CEA 32 3F 9C                             ld      (clipDxySign),a
 148+ 9CED 3A 3D 9C     .AbsDy:                 ld      a,(clipDyHigh)
 149+ 9CF0 ED 27 80                             test    $80
 150+ 9CF3 28 0C                                jr      z,.LL110                    ; If delta_y_hi is positive, jump down to LL110 to skip the following
 151+ 9CF5 2A 3C 9C                             ld      hl,(clipDy)                 ;OPTIMISATION 6/11/21 commented out
 152+ 9CF8                                      macronegate16de                     ; Otherwise flip the sign of delta_y to make it  positive, starting with the low bytes
 152+ 9CF8 AF          >					xor 	a
 152+ 9CF9 93          >                    sub 	e
 152+ 9CFA 5F          >                    ld 		e,a
 152+ 9CFB 9F          >                    sbc 	a,a
 152+ 9CFC 92          >                    sub 	d
 152+ 9CFD 57          >                    ld 		d,a
 153+ 9CFE 22 3C 9C                             ld      (clipDy),hl                 ;OPTIMISATION 6/11/21 commented out
 154+ 9D01 2A 39 9C     .LL110:                 ld      hl,(clipDx)
 155+ 9D04 3A 3A 9C                             ld      a,(clipDxHigh)
 156+ 9D07 ED 27 80                             test    $80                         ; is it a negative X
 157+ 9D0A 28 06                                jr      z,.LL111                    ; If delta_x_hi is positive, jump down to LL110 to skip the following
 158+ 9D0C                                      ;ld      hl,(clipDx)                 ;OPTIMISATION 6/11/21 commented out
 159+ 9D0C                                      macronegate16hl                     ; Otherwise flip the sign of delta_y to make it  positive, starting with the low bytes
 159+ 9D0C AF          >					xor 	a
 159+ 9D0D 95          >					sub 	l
 159+ 9D0E 6F          >					ld 		l,a
 159+ 9D0F 9F          >					sbc 	a,a
 159+ 9D10 94          >					sub 	h
 159+ 9D11 67          >					ld 		h,a
 160+ 9D12                                     ; ld      (clipDx),hl                 ;OPTIMISATION 6/11/21 commented out; we still retain the old sign in NonABS version
 161+ 9D12              .LL111:               ;  push    de
 162+ 9D12                                     ; ld      hl,(clipDx)                 ;OPTIMISATION 6/11/21 commented out
 163+ 9D12                                     ; ld      de,(clipDy)                 ;OPTIMISATION 6/11/21 commented out
 164+ 9D12 7C           .ScaleLoop:             ld      a,h                         ; At this point DX and DY are ABS values
 165+ 9D13 B2                                   or      d
 166+ 9D14 28 0A                                jr      z,.CalculateDelta
 166+ 9D16
 167+ 9D16                                      ShiftDERight1
 167+ 9D16 CB 3A       >			   srl d
 167+ 9D18 CB 1B       >			   rr  e
 168+ 9D1A                                      ShiftHLRight1
 168+ 9D1A CB 3C       >			   srl h
 168+ 9D1C CB 1D       >			   rr  l
 169+ 9D1E 18 F2                                jr      .ScaleLoop                  ; scaled down Dx and Dy to 8 bit, Dy may have been negative
 170+ 9D20              .CalculateDelta:        ;ld      (clipDx),hl                ;OPTIMISATION 6/11/21 commented out
 171+ 9D20                                      ;ld      (clipDy),de                ;OPTIMISATION 6/11/21 commented out
 172+ 9D20              ; By now, the high bytes of both |delta_x| and |delta_y| are zero We know that h and d are both = 0 as that's what we tested with a BEQ
 173+ 9D20 AF           .LL113:                 xor     a
 174+ 9D21 32 77 84                             ld      (varT),a                    ; t = 0
 175+ 9D24 7D                                   ld      a,l                         ; If delta_x_lo < delta_y_lo, so our line is more vertical than horizontal, jump to LL114
 176+ 9D25                                      JumpIfALTNusng  e, .LL114           ;
 176+ 9D25 BB          >                        cp      e
 176+ 9D26 DA 36 9D    >                        jp		c, .LL114
 177+ 9D29              ; Here Dx >= Dy sp calculate Delta Y / delta X
 178+ 9D29 32 5B 84     .DxGTEDy:               ld      (varQ),a                    ; Set Q = delta_x_lo
 179+ 9D2C 57                                   ld      d,a                         ; d = also Q for calc
 180+ 9D2D 7B                                   ld      a,e                         ; Set A = delta_y_lo
 181+ 9D2E CD E4 94                             call    AEquAmul256DivD; LL28Amul256DivD             ; Call LL28 to calculate:  R (actually a reg) = 256 * A / Q   = 256 * delta_y_lo / delta_x_lo
 182+ 9D31 32 5C 84                             ld      (varR),a                    ;
 183+ 9D34 18 10                                jr      .LL116                      ; Jump to LL116, as we now have the line's gradient in R
 184+ 9D36              ; Here Delta Y > Delta X so calulate delta X / delta Y
 185+ 9D36 7B           .LL114:                 ld      a,e                         ; Set Q = delta_y_lo
 186+ 9D37 57                                   ld      d,a
 187+ 9D38 32 5B 84                             ld      (varQ),a
 188+ 9D3B 7D                                   ld      a,l                         ; Set A = delta_x_lo
 189+ 9D3C CD E4 94                             call    AEquAmul256DivD; LL28Amul256DivD             ; Call LL28 to calculate: R = 256 * A / Q  = 256 * delta_x_lo / delta_y_lo
 190+ 9D3F 32 5C 84                             ld      (varR),a                    ;
 191+ 9D42 21 77 84                             ld      hl,varT                     ; T was set to 0 above, so this sets T = &FF
 192+ 9D45 35                                   dec     (hl)
 193+ 9D46 D1           .LL116:                 pop     de                          ; get back X2
 194+ 9D47 E1                                   pop     hl                          ; get back X1 into hl,
 195+ 9D48 3A 5C 84                             ld      a,(varR)                    ; Store the gradient in XX12+2 this can be optimised later
 196+ 9D4B 32 3E 9C                             ld      (clipGradient),a
 197+ 9D4E FD 6F                                ld      iyl,a
 198+ 9D50                                      ;       push    af                   ;OPTIMISATION 6/11/21 commented out
 199+ 9D50                                      ;       ld      a,iyl                ;OPTIMISATION 6/11/21 commented out
 200+ 9D50                                      ;       ld      (varXX12p2),a        ;OPTIMISATION 6/11/21 commented out
 201+ 9D50                                      ;       pop     af                   ;OPTIMISATION 6/11/21 commented out
 202+ 9D50 3A 5D 84                             ld      a,(varS)
 203+ 9D53 32 3F 9C                             ld      (clipDxySign),a             ;  Store the type of slope in XX12+3, bit 7 clear means ?Not needed as clipDxySign is used for varS earlier?
 204+ 9D56                                                                          ; top left to bottom right, bit 7 set means top right to bottom left **CODE IS WRONG HERE A TEST IS BL to TR
 205+ 9D56 FD 7C                                ld      a,iyh                       ; iyh was XX13 from earlier
 206+ 9D58 FE 00                                cp      0                           ; If XX13 = 0, skip the following instruction
 207+ 9D5A 28 05                                jr      z,.LL138                    ;
 208+ 9D5C ED 27 80                             test    $80                         ; If XX13 is positive, it must be 95. This means (x1, y1) is on-screen but (x2, y2) isn't, so we jump to LLX117 to swap the (x1, y1) and (x2, y2)
 209+ 9D5F 28 13                                jr      z,.LLX117                   ; coordinates around before doing the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
 210+ 9D61              ; If we get here, XX13 = 0 or 191, so (x1, y1) is off-screen and needs clipping
 211+ 9D61 CD 88 9D     .LL138                  call    ClipPointHLBC               ; Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 212+ 9D64 FD 7C                                ld      a,iyh                       ; If XX13 = 0, i.e. (x2, y2) is on-screen, jump down to LL124 to return with a successfully clipped line
 213+ 9D66 ED 27 80                             test    $80
 214+ 9D69 28 1A                                jr      z,.LL124
 215+ 9D6B              ; If we get here, XX13 = 191 (both coordinates are off-screen)
 216+ 9D6B 7C           .LL117:                 ld      a,h                         ; If either of x1_hi or y1_hi are non-zero, jump to
 217+ 9D6C B0                                   or      b                           ; LL137 to return from the subroutine with the C flag
 218+ 9D6D C2 93 9C                             jp      nz, .PointsOutofBounds      ; set, as the line doesn't fit on-screen
 219+ 9D70 B1                                   or      c                           ; if x1 and y1 hi are both zero test bit 8 or Y1 to see if its > 128
 220+ 9D71 FA 93 9C                             jp      m, .PointsOutofBounds       ; set, as the line doesn't fit on-screen
 221+ 9D74              ; If we get here, XX13 = 95 or 191, and in both cases (x2, y2) is off-screen, so we now need to swap the (x1, y1) and (x2, y2) coordinates around before doing
 222+ 9D74              ; the actual clipping, because we need to clip (x2, y2) but the clipping routine at LL118 only clips (x1, y1)
 223+ 9D74 EB           .LLX117:                ex      de,hl                       ;  swap X1 and X2
 224+ 9D75 DD E5                                push    ix                          ;  swap Y1 and Y2
 225+ 9D77 C5                                   push    bc
 226+ 9D78 DD E1                                pop     ix
 227+ 9D7A C1                                   pop     bc
 228+ 9D7B CD 88 9D                             call    ClipPointHLBC               ;  Call LL118 to move (x1, y1) along the line onto the screen, i.e. clip the line at the (x1, y1) end
 229+ 9D7E 3A 42 9C                             ld      a,(SWAP)
 230+ 9D81 3D                                   dec     a
 231+ 9D82 32 42 9C                             ld      (SWAP),a                    ; Set SWAP = &FF to indicate that we just clipped the line at the (x2, y2) end by swapping the coordinates (the DEC does this as we set SWAP to 0 at the start of this subroutine)
 232+ 9D85 C3 80 9C     .LL124:                 jp      .ClipDone                    ; now put points in place
 233+ 9D88
 234+ 9D88              ; Move a point along a line until it is on-screen point is held in HL(X) BC(Y) LL118
 235+ 9D88              ; iyh still holds XX13 iyl still holds gradient
 236+ 9D88 7C           ClipPointHLBC:          ld      a,h                         ; If x1_hi is positive, jump down to LL119 to skip the following
 237+ 9D89 ED 27 80                             test    $80
 238+ 9D8C 28 17                                jr      z,.LL119
 239+ 9D8E 32 5D 84     .X1isNegative:          ld      (varS),a                    ;  Otherwise x1_hi is negative, i.e. off the left of the screen, so set S = x1_hi
 240+ 9D91 E5 D5 C5                             push    hl,,de,,bc
 241+ 9D94 CD 0A 9E                             call    LL120                       ;  Call LL120 to calculate:   (Y X) = (S x1_lo) * XX12+2      if T = 0   = x1 * gradient
 242+ 9D97                                                                          ;                             (Y X) = (S x1_lo) / XX12+2      if T <> 0  = x1 / gradient
 243+ 9D97                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
 244+ 9D97 C1 D1 E1                             pop    hl,,de,,bc                   ;  get coordinates back
 245+ 9D9A 2A 43 9C                             ld      hl,(varYX)
 246+ 9D9D              ;                        ex      hl,de
 247+ 9D9D                                  ;    ld      hl,bc
 248+ 9D9D 09                                   add     hl,bc                       ; y1 = y1 + varYX
 249+ 9D9E 44 4D                                ld      bc,hl
 250+ 9DA0 21 00 00                             ld      hl,0                        ; Set x1 = 0
 251+ 9DA3               ;                       pop     de
 252+ 9DA3 18 1A                                jr      .LL134                      ; in BBC is set x to 0 to force jump, we will just jump
 253+ 9DA5 FE 00        .LL119:                 cp      0
 254+ 9DA7 28 16                                jr      z,.LL134                    ;  If x1_hi = 0 then jump down to LL134 to skip the following, as the x-coordinate is already on-screen (as 0 <= (x_hi x_lo) <= 255)
 255+ 9DA9 3D                                   dec     a
 256+ 9DAA 32 5D 84                             ld      (varS),a                    ;  Otherwise x1_hi is positive, i.e. x1 >= 256 and off the right side of the screen, so set S = x1_hi - 1
 257+ 9DAD E5 D5 C5                             push    hl,,de,,bc
 258+ 9DB0 CD 0A 9E                             call    LL120                      ;  Call LL120 to calculate: (Y X) = (S x1_lo) * XX12+2      if T = 0  = (x1 - 256) * gradient
 259+ 9DB3                                                                          ;                           (Y X) = (S x1_lo) / XX12+2      if T <> 0 = (x1 - 256) / gradient
 260+ 9DB3                                                                          ;  with the sign of (Y X) set to the opposite of theline's direction of slope
 261+ 9DB3 C1 D1 E1                             pop     hl,,de,,bc
 262+ 9DB6                                    ;  push    de                          ; Set y1 = y1 + (Y X)
 263+ 9DB6 2A 43 9C                             ld      hl,(varYX)
 264+ 9DB9                                    ; ex      de,hl                       ;OPTIMISATION 6/11/21 commented out
 265+ 9DB9 09                                   add     hl,bc                        ;OPTIMISATION 6/11/21 simplfied post debug
 266+ 9DBA 44 4D                                ld      bc,hl                        ;OPTIMISATION 6/11/21 simplfied post debug
 267+ 9DBC                                    ; ex      hl,de                       ;OPTIMISATION 6/11/21 commented out
 268+ 9DBC                                    ; ld      hl,bc                       ;OPTIMISATION 6/11/21 commented out
 269+ 9DBC                                    ; add     hl,de                       ; y1 = y1 + varYX
 270+ 9DBC 21 FF 00                             ld      hl,255                      ; Set x1 = 255
 271+ 9DBF                                    ;  pop     de
 272+ 9DBF              ; We have moved the point so the x-coordinate is on screen (i.e. in the range 0-255), so now for they-coordinate
 273+ 9DBF 78           .LL134:                 ld      a,b                         ; If y1_hi is positive, jump down to LL135  to skip the following
 274+ 9DC0 ED 27 80                             test    $80                         ;
 275+ 9DC3 28 1A                                jr      z,.LL135                    ;
 276+ 9DC5 32 5D 84                             ld      (varS),a                    ; Otherwise y1_hi is negative, i.e. off the top of the screen, so set S = y1_hi
 277+ 9DC8 79                                   ld      a,c                         ; Set R = y1_lo
 278+ 9DC9 32 5C 84                             ld      (varR),a                    ;
 279+ 9DCC E5 D5 C5                             push    hl,,de,,bc
 280+ 9DCF CD 31 9E                             call    LL123                       ;  Call LL123 to calculate: (Y X) = (S R) / XX12+2      if T = 0  = y1 / gradient
 281+ 9DD2                                                                          ;                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
 282+ 9DD2                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
 283+ 9DD2 C1 D1 E1                             pop     hl,,de,,bc
 284+ 9DD5 D5                                   push    de
 285+ 9DD6 EB                                   ex      hl,de                       ; de = x1
 286+ 9DD7 2A 43 9C                             ld      hl,(varYX)                  ; hl = varYX
 287+ 9DDA 19                                   add     hl,de                       ; we don't need to swap back as its an add, Set x1 = x1 + (Y X)
 288+ 9DDB D1                                   pop     de                          ; de = x2 again
 289+ 9DDC 01 00 00                             ld      bc,0                        ; Set y1 = 0
 290+ 9DDF 79           .LL135:                 ld      a,c                         ; if bc < 128 then no work to do
 291+ 9DE0 E6 80                                and     $80
 292+ 9DE2 B0                                   or      b                           ; here we see if c bit 8 is set or anything in b as we know if its 0 this would mean there is no need to clip
 293+ 9DE3 C8                                   ret     z
 294+ 9DE4 E5                                   push    hl
 295+ 9DE5 60 69                                ld      hl,bc
 296+ 9DE7 01 80 00                             ld      bc,128
 297+ 9DEA B7                                   or      a
 298+ 9DEB ED 42                                sbc     hl,bc                       ; hl =  (S R) = (y1_hi y1_lo) - 128
 299+ 9DED 22 5C 84                             ld      (varRS), hl                 ; and now RS (or SR)
 300+ 9DF0 7C                                   ld      a,h
 301+ 9DF1 E1                                   pop     hl
 302+ 9DF2 ED 27 80                             test    $80                         ; If the subtraction underflowed, i.e. if y1 < 192, then y1 is already on-screen, so jump to LL136 to return from the subroutine, as we are done
 303+ 9DF5 C0                                   ret     nz
 304+ 9DF6              ; If we get here then y1 >= 192, i.e. off the bottom of the screen
 305+ 9DF6 E5 D5 C5     .LL139:                 push    hl,,de,,bc
 306+ 9DF9 CD 31 9E                             call    LL123                       ;  Call LL123 to calculate: (Y X) = (S R) / XX12+2      if T = 0  = y1 / gradient
 307+ 9DFC                                                                          ;                           (Y X) = (S R) * XX12+2      if T <> 0 = y1 * gradient
 308+ 9DFC                                                                          ;  with the sign of (Y X) set to the opposite of the line's direction of slope
 309+ 9DFC C1 D1 E1                             pop     hl,,de,,bc
 310+ 9DFF D5                                   push    de
 311+ 9E00 EB                                   ex      hl,de
 312+ 9E01 2A 43 9C                             ld      hl,(varYX)
 313+ 9E04 19                                   add     hl,de                       ; we don't need to swap back as its an add, Set x1 = x1 + (Y X)
 314+ 9E05 01 7F 00                             ld      bc,127                      ; set bc to 127 bottom of screen
 315+ 9E08 D1                                   pop     de
 316+ 9E09 C9           .LL136:                 ret                                 ;  Return from the subroutine
 317+ 9E0A
 318+ 9E0A
 319+ 9E0A              ; Calculate the following:   * If T = 0  (more vertical than horizontal), (Y X) = (S x1_lo) * XX12+2
 320+ 9E0A              ;                            * If T <> 0 (more horizontal than vertical), (Y X) = (S x1_lo) / XX12+2
 321+ 9E0A              ;                              giving (Y X) the opposite sign to the slope direction in XX12+3.
 322+ 9E0A              ; Other entry points        LL122                Calculate (Y X) = (S R) * Q and set the sign to the opposite of the top byte on the stack
 323+ 9E0A 7D           LL120:                  ld      a,l                          ; Set R = x1_lo
 324+ 9E0B 32 5C 84                             ld      (varR),a
 325+ 9E0E CD 79 9E                             call    LL129                        ;  Call LL129 to do the following:  Q = XX12+2   = line gradient  A = S EOR XX12+3 = S EOR slope direction (S R) = |S R| So A contains the sign of S * slope direction
 326+ 9E11 F5                                   push    af                           ;  Store A on the stack so we can use it later
 327+ 9E12 C5                                   push    bc
 328+ 9E13 47                                   ld      b,a
 329+ 9E14 3A 77 84                             ld      a,(varT)                     ; instead : (Y X) = (S R ) / Q
 330+ 9E17 FE 00                                cp      0
 331+ 9E19 78                                   ld      a,b
 332+ 9E1A C1                                   pop     bc                           ; we can't use af as that would disrupt the flags
 333+ 9E1B 20 23                                jr      nz, LL121
 334+ 9E1D              ; The following calculates:  (Y X) = (S R) * Q using the same shift-and-add algorithm that's documented in MULT1
 335+ 9E1D 3A 3E 9C     LL122:                  ld      a,(clipGradient)
 336+ 9E20 32 5B 84                             ld      (varQ),a; optimise
 337+ 9E23 CD 37 93                             call    HLequSRmulQdiv256
 338+ 9E26 22 43 9C                             ld      (varYX),hl
 339+ 9E29 F1                                   pop     af
 340+ 9E2A ED 27 80                             test    $80
 341+ 9E2D CA 6C 9E                             jp      z,LL133
 342+ 9E30 C9                                   ret
 343+ 9E31              ; Calculate the following: * If T = 0,  calculate (Y X) = (S R) / XX12+2 (actually SR & XX12+2 /256)
 344+ 9E31              ;                          * If T <> 0, calculate (Y X) = (S R) * XX12+2
 345+ 9E31              ;                          giving (Y X) the opposite sign to the slope direction in XX12+3.
 346+ 9E31              ;
 347+ 9E31              ; Other entry points:      LL121                Calculate (Y X) = (S R) / Q and set the sign to the opposite of the top byte on the stack
 348+ 9E31              ;                          LL133                Negate (Y X) and return from the subroutine
 349+ 9E31              ;                          LL128                Contains an RTS
 350+ 9E31 CD 79 9E     LL123:                  call    LL129                       ; Call LL129 to do the following: Q = XX12+2   = line gradient  A = S EOR XX12+3 = S EOR slope direction (S R) = |S R| So A contains the sign of S * slope direction
 351+ 9E34 F5                                   push    af                          ; Store A on the stack so we can use it later
 352+ 9E35 C5                                   push    bc                          ; If T is non-zero, so it's more horizontal than vertical, jump down to LL121 to calculate this
 353+ 9E36 47                                   ld      b,a
 354+ 9E37 3A 77 84                             ld      a,(varT)                    ; instead : (Y X) = (S R) * Q *** this looks to be the wrong way roudn for Y!!!!
 355+ 9E3A FE 00                                cp      0
 356+ 9E3C 78                                   ld      a,b
 357+ 9E3D C1                                   pop     bc
 358+ 9E3E 20 DD                                jr      nz, LL122
 359+ 9E40              ; The following calculates: (Y X) = (S R) / Q using the same shift-and-subtract algorithm that's documented in TIS2, its actually X.Y=R.S*256/Q
 360+ 9E40 11 FE FF     LL121:                  ld      de,$FFFE                    ; set XY to &FFFE at start, de holds XY
 361+ 9E43 2A 5C 84                             ld      hl,(varRS)                  ; hl = RS
 362+ 9E46 3A 5B 84                             ld      a,(varQ)
 363+ 9E49 47                                   ld      b,a                         ; b = q
 364+ 9E4A              .LL130:                 ShiftHLLeft1                        ; RS *= 2
 364+ 9E4A CB 25       >			   sla l
 364+ 9E4C CB 14       >			   rl  h
 365+ 9E4E 7C                                   ld      a,h
 366+ 9E4F 38 04                                jr      c,.LL131                    ; if S overflowed skip Q test and do subtractions
 367+ 9E51                                      JumpIfALTNusng b, .LL132            ; if S <  Q = 256/gradient skip subtractions
 367+ 9E51 B8          >                        cp      b
 367+ 9E52 DA 5D 9E    >                        jp		c, .LL132
 368+ 9E55 3F           .LL131:                 ccf                                 ; compliment carry
 369+ 9E56 98                                   sbc     a,b                         ; q
 370+ 9E57 67                                   ld      h,a                         ; h (s)
 371+ 9E58 7D                                   ld      a,l                         ; r
 372+ 9E59 DE 00                                sbc     a,0                         ; 0 - so in effect SR - Q*256
 373+ 9E5B 37                                   scf                                 ; set carry for next rolls
 374+ 9E5C 3F                                   ccf
 375+ 9E5D              .LL132:                 RollDELeft1                         ; Rotate de bits left
 375+ 9E5D CB 13       >               rl  e
 375+ 9E5F CB 12       >               rl  d
 376+ 9E61 38 E7                                jr      c,.LL130                    ;
 377+ 9E63 ED 53 43 9C                          ld      (varYX),de
 378+ 9E67 F1                                   pop     af              ; get back sign
 379+ 9E68 ED 27 80                             test    $80
 380+ 9E6B C8                                   ret     z               ; if negative then return with value as is reversed sign
 381+ 9E6C 2A 43 9C     LL133:                  ld      hl,(varYX)      ; may not actually need this?
 382+ 9E6F                                      NegHL
 382+ 9E6F AF          >                    xor a
 382+ 9E70 95          >                    sub l
 382+ 9E71 6F          >                    ld l,a
 382+ 9E72 9F          >                    sbc a,a
 382+ 9E73 94          >                    sub h
 382+ 9E74 67          >                    ld h,a
 383+ 9E75 22 43 9C                             ld      (varYX),hl
 384+ 9E78 C9           LL128:                  ret
 385+ 9E79              ; Do the following, in this order:  Q = XX12+2
 386+ 9E79              ;                                   A = S EOR XX12+3
 387+ 9E79              ;                                   (S R) = |S R|
 388+ 9E79              ; This sets up the variables required above to calculate (S R) / XX12+2 and give the result the opposite sign to XX13+3.
 389+ 9E79 3A 3E 9C     LL129:                  ld      a,(clipGradient)
 390+ 9E7C 32 5B 84                             ld      (varQ),a                    ;Set Q = XX12+2
 391+ 9E7F 3A 5D 84                             ld      a,(varS)                    ; If S is positive, jump to LL127
 392+ 9E82 E5 F5                                push    hl,,af
 393+ 9E84 ED 27 80                             test    $80
 394+ 9E87 28 0C                                jr      z,.LL127
 395+ 9E89 2A 5C 84                             ld      hl,(varRS)                  ; else SR = | SR|
 396+ 9E8C                                      NegHL
 396+ 9E8C AF          >                    xor a
 396+ 9E8D 95          >                    sub l
 396+ 9E8E 6F          >                    ld l,a
 396+ 9E8F 9F          >                    sbc a,a
 396+ 9E90 94          >                    sub h
 396+ 9E91 67          >                    ld h,a
 397+ 9E92 22 5C 84                             ld      (varRS),hl
 398+ 9E95 21 3F 9C     .LL127:                 ld      hl,clipDxySign
 399+ 9E98 F1                                   pop     af
 400+ 9E99 AE                                   xor     (hl)                        ; a = S XOR clipDxySign
 401+ 9E9A E1                                   pop     hl
 402+ 9E9B C9                                   ret
 403+ 9E9C
# file closed: ./ModelRender/CLIP-LL145.asm
 146  9E9C
 147  9E9C
 148  9E9C              ; Repurposed XX15 when plotting lines
 149  9E9C              ; Repurposed XX15 before calling clip routine
 150  9E9C              UBnkX1                      equ XX15
 151  9E9C              UBnKx1Lo                    equ XX15
 152  9E9C              UBnKx1Hi                    equ XX15+1
 153  9E9C              UBnkY1                      equ XX15+2
 154  9E9C              UbnKy1Lo                    equ XX15+2
 155  9E9C              UBnkY1Hi                    equ XX15+3
 156  9E9C              UBnkX2                      equ XX15+4
 157  9E9C              UBnkX2Lo                    equ XX15+4
 158  9E9C              UBnkX2Hi                    equ XX15+5
 159  9E9C              ; Repurposed XX12 when plotting lines
 160  9E9C              UBnkY2                      equ XX12+0
 161  9E9C              UbnKy2Lo                    equ XX12+0
 162  9E9C              UBnkY2Hi                    equ XX12+1
 163  9E9C              UBnkDeltaXLo                equ XX12+2
 164  9E9C              UBnkDeltaXHi                equ XX12+3
 165  9E9C              UBnkDeltaYLo                equ XX12+4
 166  9E9C              UBnkDeltaYHi                equ XX12+5
 167  9E9C              UbnkGradient                equ XX12+2
 168  9E9C              UBnkTemp1                   equ XX12+2
 169  9E9C              UBnkTemp1Lo                 equ XX12+2
 170  9E9C              UBnkTemp1Hi                 equ XX12+3
 171  9E9C              UBnkTemp2                   equ XX12+3
 172  9E9C              UBnkTemp2Lo                 equ XX12+3
 173  9E9C              UBnkTemp2Hi                 equ XX12+4
 174  9E9C              ;-- XX15 --------------------------------------------------------------------------------------------------------------------------
 175  9E9C 00           UBnkXScaled                 DB  0               ; XX15+0Xscaled
 176  9E9D 00           UBnkXScaledSign             DB  0               ; XX15+1xsign
 177  9E9E 00           UBnkYScaled                 DB  0               ; XX15+2yscaled
 178  9E9F 00           UBnkYScaledSign             DB  0               ; XX15+3ysign
 179  9EA0 00           UBnkZScaled                 DB  0               ; XX15+4zscaled
 180  9EA1 00           UBnkZScaledSign             DB  0               ; XX15+5zsign
 181  9EA2
 182  9EA2              XX15                        equ UBnkXScaled
 183  9EA2              XX15VecX                    equ XX15
 184  9EA2              XX15VecY                    equ XX15+1
 185  9EA2
 186  9EA2              XX15VecZ                    equ XX15+2
 187  9EA2              UbnkXPoint                  equ XX15
 188  9EA2              UbnkXPointLo                equ XX15+0
 189  9EA2              UbnkXPointHi                equ XX15+1
 190  9EA2              UbnkXPointSign              equ XX15+2
 191  9EA2              UbnkYPoint                  equ XX15+3
 192  9EA2              UbnkYPointLo                equ XX15+3
 193  9EA2              UbnkYPointHi                equ XX15+4
 194  9EA2              UbnkYPointSign              equ XX15+5
 195  9EA2              ; Repurposed XX15 pre clip plines
 196  9EA2              UbnkPreClipX1               equ XX15+0
 197  9EA2              UbnkPreClipY1               equ XX15+2
 198  9EA2              UbnkPreClipX2               equ XX15+4
 199  9EA2              UbnkPreClipY2               equ XX15+6
 200  9EA2              ; Repurposed XX15 post clip lines
 201  9EA2              UBnkNewX1                   equ XX15+0
 202  9EA2              UBnkNewY1                   equ XX15+1
 203  9EA2              UBnkNewX2                   equ XX15+2
 204  9EA2              UBnkNewY2                   equ XX15+3
 205  9EA2              ; Repurposed XX15
 206  9EA2              regXX15fx                   equ UBnkXScaled
 207  9EA2              regXX15fxSgn                equ UBnkXScaledSign
 208  9EA2              regXX15fy                   equ UBnkYScaled
 209  9EA2              regXX15fySgn                equ UBnkYScaledSign
 210  9EA2              regXX15fz                   equ UBnkZScaled
 211  9EA2              regXX15fzSgn                equ UBnkZScaledSign
 212  9EA2              ; Repurposed XX15
 213  9EA2              varX1                       equ UBnkXScaled       ; Reused, verify correct position
 214  9EA2              varY1                       equ UBnkXScaledSign   ; Reused, verify correct position
 215  9EA2              varZ1                       equ UBnkYScaled       ; Reused, verify correct position
 216  9EA2              ; After clipping the coords are two 8 bit pairs
 217  9EA2              UBnkPoint1Clipped           equ UBnkXScaled
 218  9EA2              UBnkPoint2Clipped           equ UBnkYScaled
 219  9EA2              ;-- transmat0 --------------------------------------------------------------------------------------------------------------------------
 220  9EA2              ; Note XX12 comes after as some logic in normal processing uses XX15 and XX12 combines
 221  9EA2 00           UBnkXX12xLo                 DB  0               ; XX12+0
 222  9EA3 00           UBnkXX12xSign               DB  0               ; XX12+1
 223  9EA4 00           UBnkXX12yLo                 DB  0               ; XX12+2
 224  9EA5 00           UBnkXX12ySign               DB  0               ; XX12+3
 225  9EA6 00           UBnkXX12zLo                 DB  0               ; XX12+4
 226  9EA7 00           UBnkXX12zSign               DB  0               ; XX12+5
 227  9EA8 00 00 00...  XX12Save                    DS  6
 228  9EAE 00 00 00...  XX12Save2                   DS  6
 229  9EB4              XX12                        equ UBnkXX12xLo
 230  9EB4              varXX12                     equ UBnkXX12xLo
 231  9EB4              ; Post clipping the results are now 8 bit
 232  9EB4 00           UBnkVisibility              DB  0               ; replaces general purpose xx4 in rendering
 233  9EB5 00           UbnKDrawAsDot               DB  0               ; if 0 then OK, if 1 then just draw dot of line heap
 234  9EB6 00           UBnkProjectedY              DB  0
 235  9EB7 00           UBnkProjectedX              DB  0
 236  9EB8              UBnkProjected               equ UBnkProjectedY  ; resultant projected position
 237  9EB8 00 00 00...  XX15Save                    DS  8
 238  9EC0 00 00 00...  XX15Save2                   DS  8
 239  9EC8 00           VarBackface                 DB 0
 240  9EC9              ; Heap (or array) information for lines and normals
 241  9EC9              ; Coords are stored XY,XY,XY,XY
 242  9EC9              ; Normals
 243  9EC9              ; This needs re-oprganising now.
 244  9EC9              ; Runtime Calculation Store
 245  9EC9
 246  9EC9
 247  9EC9              ;--------------------------------------------------------------------------------------------------------
 248  9EC9
 249  9EC9              ; Bank 58  ------------------------------------------------------------------------------------------------------------------------
 250  9EC9                  SLOT    LAYER1Addr
 251  9EC9                  PAGE    BankLAYER1
 252  9EC9                  ORG     LAYER1Addr, BankLAYER1
 253  E000
 254  E000                  INCLUDE "./Layer1Graphics/layer1_attr_utils.asm"
# file opened: ./Layer1Graphics/layer1_attr_utils.asm
   1+ E000
   2+ E000 00 58        L1AttrRow00:            DW $5800                    ;Row 1    */
   3+ E002 20 58        L1AttrRow01:            DW $5820                    ;Row 2    */
   4+ E004 40 58        L1AttrRow02:            DW $5840                    ;Row 3    */
   5+ E006 60 58        L1AttrRow03:            DW $5860                    ;Row 4    */
   6+ E008 80 58        L1AttrRow04:            DW $5880                    ;Row 5    */
   7+ E00A A0 58        L1AttrRow05:            DW $58A0                    ;Row 6    */
   8+ E00C C0 58        L1AttrRow06:            DW $58C0                    ;Row 7    */
   9+ E00E E0 58        L1AttrRow07:            DW $58E0                    ;Row 8    */
  10+ E010 00 59        L1AttrRow08:            DW $5900                    ;Row 9    */
  11+ E012 20 59        L1AttrRow09:            DW $5920                    ;Row 10   */
  12+ E014 40 59        L1AttrRow10:            DW $5940                    ;Row 11   */
  13+ E016 60 59        L1AttrRow11:            DW $5960                    ;Row 12   */
  14+ E018 80 59        L1AttrRow12:            DW $5980                    ;Row 13   */
  15+ E01A A0 59        L1AttrRow13:            DW $59A0                    ;Row 14   */
  16+ E01C C0 59        L1AttrRow14:            DW $59C0                    ;Row 15   */
  17+ E01E E0 59        L1AttrRow15:            DW $59E0                    ;Row 16   */
  18+ E020 00 5A        L1AttrRow16:            DW $5A00                    ;Row 17   */
  19+ E022 20 5A        L1AttrRow17:            DW $5A20                    ;Row 18   */
  20+ E024 40 5A        L1AttrRow18:            DW $5A40                    ;Row 19   */
  21+ E026 60 5A        L1AttrRow19:            DW $5A60                    ;Row 20   */
  22+ E028 80 5A        L1AttrRow20:            DW $5A80                    ;Row 21   */
  23+ E02A A0 5A        L1AttrRow21:            DW $5AA0                    ;Row 22   */
  24+ E02C C0 5A        L1AttrRow22:            DW $5AC0                    ;Row 23   */
  25+ E02E E0 5A        L1AttrRow23:            DW $5AE0                    ;Row 23   */
  26+ E030
  27+ E030              ; "l2_hilight_row, d = row, e = colour"
  28+ E030 21 00 E0     l1_hilight_row:         ld      hl, L1AttrRow00
  29+ E033 4B                                   ld      c,e
  30+ E034 7A                                   ld      a,d
  31+ E035 CB 27                                sla     a
  32+ E037 ED 31                                add     hl,a
  33+ E039 7E                                   ld      a,(hl)
  34+ E03A 5F                                   ld      e,a
  35+ E03B 23                                   inc     hl
  36+ E03C 7E                                   ld      a,(hl)
  37+ E03D 57                                   ld      d,a
  38+ E03E EB                                   ex      hl,de
  39+ E03F 79                                   ld		a,c
  40+ E040 11 20 00                             ld		de, 32
  41+ E043 CD 5A 80                             call	memfill_dma
  42+ E046 C9                                   ret
  43+ E047
# file closed: ./Layer1Graphics/layer1_attr_utils.asm
 255  E047                  INCLUDE "./Layer1Graphics/layer1_cls.asm"
# file opened: ./Layer1Graphics/layer1_cls.asm
   1+ E047 AF           l1_cls_top:             xor     a
   2+ E048 21 00 40                             ld      hl, $4000
   3+ E04B 11 00 08                             ld      de, $0800
   4+ E04E CD 5A 80                             call    memfill_dma
   5+ E051 C9                                   ret
   6+ E052
   7+ E052 AF           l1_cls_mid:             xor     a
   8+ E053 21 00 48                             ld      hl, $4800
   9+ E056 11 00 08                             ld      de, $0800
  10+ E059 CD 5A 80                             call    memfill_dma
  11+ E05C C9                                   ret
  12+ E05D
  13+ E05D AF           l1_cls_bottom:          xor     a
  14+ E05E 21 00 50                             ld      hl, $5000
  15+ E061 11 00 08                             ld      de, $0800
  16+ E064 CD 5A 80                             call    memfill_dma
  17+ E067 C9                                   ret
  18+ E068
  19+ E068              ; Designed specifically to clear a whole character aligned line
  20+ E068 1E 00        l1_cls_line_d:          ld      e,0
  21+ E06A ED 94                                pixelad
  22+ E06C 11 00 01                             ld      de,32 * 8
  23+ E06F AF                                   xor     a
  24+ E070 CD 5A 80                             call    memfill_dma
  25+ E073 C9                                   ret
  26+ E074
  27+ E074              ; Designed specifically to clear a whole character aligned 2 lines line, used for say clearing hyperspace message
  28+ E074 1E 00        l1_cls_2_lines_d:       ld      e,0
  29+ E076 ED 94                                pixelad
  30+ E078 11 00 02                             ld      de,32 * 16
  31+ E07B AF                                   xor     a
  32+ E07C CD 5A 80                             call    memfill_dma
  33+ E07F C9                                   ret
  34+ E080
  35+ E080 AF           l1_cls:                 xor		a
  36+ E081 21 00 40     l1_cls_to_a:            ld		hl,	$4000
  37+ E084 11 00 18                             ld		de, $1800
  38+ E087 CD 5A 80                             call	memfill_dma
  39+ E08A C9                                   ret
  40+ E08B
  41+ E08B 21 00 58     l1_attr_cls_2DlinesA:   ld		hl,	$5800
  42+ E08E 1E 20                                ld      e,32
  43+ E090 ED 30                                mul
  44+ E092 19                                   add     hl,de
  45+ E093 11 40 00                             ld		de, 32 * 2
  46+ E096 CD 5A 80                             call	memfill_dma
  47+ E099 C9                                   ret
  48+ E09A
  49+ E09A
  50+ E09A AF           l1_attr_cls:            xor		a
  51+ E09B 21 00 58     l1_attr_cls_to_a:       ld		hl,	$5800
  52+ E09E 11 00 03                             ld		de, $0300
  53+ E0A1 CD 5A 80                             call	memfill_dma
  54+ E0A4 C9                                   ret
  55+ E0A5
  56+ E0A5 01 FE FE     l1_set_border:          ld	    bc, 0xFEFE
  57+ E0A8 ED 79                                out		(c),a
  58+ E0AA C9                                   ret
# file closed: ./Layer1Graphics/layer1_cls.asm
 256  E0AB                  INCLUDE "./Layer1Graphics/layer1_print_at.asm"
# file opened: ./Layer1Graphics/layer1_print_at.asm
   1+ E0AB              ; "l1 print char a = character, de = Ypixel Xchar of print"
   2+ E0AB D5 E5        l1_print_char:          push	de,,hl
   3+ E0AD ED 94                                pixelad								; hl = address of de
   4+ E0AF E5                                   push	hl							; save hl for loop
   5+ E0B0 26 00                                ld		h,0
   6+ E0B2 6F                                   ld		l,a
   7+ E0B3 29                                   add		hl,hl						; * 2
   8+ E0B4 29                                   add		hl,hl						; * 4
   9+ E0B5 29                                   add		hl,hl						; * 8 to get byte address
  10+ E0B6 ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
  11+ E0BA EB                                   ex		de,hl						; save address into de
  12+ E0BB E1                                   pop		hl							; get back hl for loop
  13+ E0BC 06 08                                ld		b,8							; do 8 rows
  14+ E0BE 1A           .PrintCharLoop:         ld		a,(de)						; row byte
  15+ E0BF 13                                   inc		de							; next byte
  16+ E0C0 77                                   ld		(hl),a						; poke to screen
  17+ E0C1 ED 93                                pixeldn								; Down 1 row
  18+ E0C3 10 F9                                djnz	.PrintCharLoop				; loop for 8 bytes
  19+ E0C5 E1 D1                                pop		de,,hl					    ; restore hl
  20+ E0C7 C9                                   ret
  21+ E0C8
  22+ E0C8              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
  23+ E0C8              ; now skips ascii code < 32 but moves on cursor by 1 char
  24+ E0C8              l1_print_at:
  25+ E0C8 7E           .PrintLoop:             ld		a,(hl)
  26+ E0C9 FE 00                                cp		0
  27+ E0CB C8                                   ret		z
  28+ E0CC                                      CallIfAGTENusng " ", l1_print_char
  28+ E0CC FE 20       >                        cp      " "
  28+ E0CE D4 AB E0    >                        call	nc,l1_print_char
  29+ E0D1 23                                   inc		hl							; move 1 message character right
  30+ E0D2 7B                                   ld		a,e
  31+ E0D3 C6 08                                add		a,8
  32+ E0D5 5F                                   ld		e,a							; move 1 screen character right
  33+ E0D6 18 F0                                jr		.PrintLoop
  34+ E0D8              .Clearstackandfinish:   ;pop		de                      ; TODO LOOOKS TO BE A ROGUE POPDE
  35+ E0D8 C9                                   ret
  36+ E0D9
  37+ E0D9              ;l1_print_at_wrap:
  38+ E0D9              ;; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
  39+ E0D9              ;	ld      iyh,e
  40+ E0D9              ;.PrintLoop:
  41+ E0D9              ;	ld		a,(hl)
  42+ E0D9              ;	cp		0
  43+ E0D9              ;	ret		z
  44+ E0D9              ;.CountWordCharLen
  45+ E0D9              ;; Need to change to word wrap, so it will loop through string as before
  46+ E0D9              ;; but read up until a null or space, take the character count * 8 for pixels
  47+ E0D9              ;; if that is > 238 then force a premature line wrap
  48+ E0D9              ;
  49+ E0D9              ;
  50+ E0D9              ;    push    iy
  51+ E0D9              ;    call	l1_print_char
  52+ E0D9              ;    pop     iy
  53+ E0D9              ;	inc		hl							; move 1 message character right
  54+ E0D9              ;	ld		a,e
  55+ E0D9              ;    cp      238
  56+ E0D9              ;    jr      nc,.NextLine
  57+ E0D9              ;	add		a,8
  58+ E0D9              ;	ld		e,a							; move 1 screen character right
  59+ E0D9              ;	jr		.PrintLoop
  60+ E0D9              ;.Clearstackandfinish:
  61+ E0D9              ;	pop		de
  62+ E0D9              ;	ret
  63+ E0D9              ;.NextLine:
  64+ E0D9              ;    ld      a,(hl)
  65+ E0D9              ;    cp      " "
  66+ E0D9              ;    ld      e,iyh
  67+ E0D9              ;    ld      a,d
  68+ E0D9              ;    add     a,8
  69+ E0D9              ;    ld      d,a
  70+ E0D9              ;    jr		.PrintLoop
  71+ E0D9
  72+ E0D9              ; Counts next word at hl, uses e and forces a wrap if it would over flow puts value in c
  73+ E0D9 E5           L1LenWordAtHL:          push    hl
  74+ E0DA D5                                   push    de
  75+ E0DB 7E           .CountLoop:             ld      a,(hl)
  76+ E0DC FE 00                                cp      0
  77+ E0DE 28 0F                                jr      z,.CountDone
  78+ E0E0 FE 20                                cp      32
  79+ E0E2 28 0B                                jr      z,.CountDone
  80+ E0E4 7B                                   ld      a,e
  81+ E0E5 C6 08                                add     a,8
  82+ E0E7 5F                                   ld      e,a
  83+ E0E8 FE EE                                cp      238
  84+ E0EA 30 07                                jr      nc,.TooLong
  85+ E0EC 23                                   inc     hl
  86+ E0ED 18 EC                                jr      .CountLoop
  87+ E0EF D1           .CountDone:             pop     de
  88+ E0F0 E1                                   pop     hl
  89+ E0F1 AF                                   xor     a
  90+ E0F2 C9                                   ret
  91+ E0F3 D1           .TooLong                pop     de
  92+ E0F4 E1                                   pop     hl
  93+ E0F5 3E FF                                ld      a,$FF
  94+ E0F7 C9                                   ret
  95+ E0F8
  96+ E0F8 7E           L1PrintWordAtHL:        ld      a,(hl)
  97+ E0F9 FE 00                                cp      0
  98+ E0FB C8                                   ret     z
  99+ E0FC FE 20                                cp      32
 100+ E0FE 28 0F                                jr      z,.ItsASpace
 101+ E100 FD E5                                push    iy
 102+ E102 CD AB E0                             call	l1_print_char
 103+ E105 FD E1                                pop     iy
 104+ E107 7B                                   ld      a,e
 105+ E108 C6 08                                add     a,8
 106+ E10A 5F                                   ld      e,a
 107+ E10B 23                                   inc     hl
 108+ E10C C3 F8 E0                             jp      L1PrintWordAtHL
 109+ E10F 23           .ItsASpace:             inc     hl      ;  Just a bodge for now
 110+ E110 7B                                   ld      a,e
 111+ E111 C6 08                                add     a,8
 112+ E113 5F                                   ld      e,a
 113+ E114 C9                                   ret
 114+ E115
 115+ E115
 116+ E115              ; "l1 PrintAt, pixel row, whole char col, DE = yx, HL = message Addr"
 117+ E115              ; Now has full word level wrapping
 118+ E115 FD 63        l1_print_at_wrap:       ld      iyh,e
 119+ E117 7E           .PrintLoop:             ld		a,(hl)
 120+ E118 FE 00                                cp		0
 121+ E11A C8                                   ret		z
 122+ E11B CD D9 E0     .CountWordCharLen:      call    L1LenWordAtHL
 123+ E11E FE FF                                cp      $FF
 124+ E120 28 06                                jr      z,.WrapNextLine
 125+ E122 CD F8 E0     .NotTooLong:            call    L1PrintWordAtHL
 126+ E125              ; Need to change to word wrap, so it will loop through string as before
 127+ E125              ; but read up until a null or space, take the character count * 8 for pixels
 128+ E125              ; if that is > 238 then force a premature line wrap
 129+ E125 18 F0                                jr		.PrintLoop
 130+ E127              .Clearstackandfinish:   ;op		de
 131+ E127 C9                                   ret
 132+ E128              .WrapNextLine:
 133+ E128 FD 5C        .NextLine:              ld      e,iyh
 134+ E12A 7A                                   ld      a,d
 135+ E12B C6 08                                add     a,8
 136+ E12D 57                                   ld      d,a
 137+ E12E 18 E7                                jr		.PrintLoop
 138+ E130
 139+ E130
# file closed: ./Layer1Graphics/layer1_print_at.asm
 257  E130
 258  E130                  SLOT    LAYER2Addr
 259  E130                  PAGE    BankLAYER2
 260  E130                  ORG     LAYER2Addr
 261  E000
 262  E000                  INCLUDE "./Layer2Graphics/layer2_bank_select.asm"
# file opened: ./Layer2Graphics/layer2_bank_select.asm
   1+ E000
   2+ E000 00           varL2_BANK_SELECTED			 DB	0
   3+ E001 00           varL2_BUFFER_MODE            DB 0
   4+ E002 00           varL2_ACCESS_MODE            DB 0
   5+ E003
   6+ E003 3E 08        asm_l2_double_buffer_on:    ld      a,8
   7+ E005 32 01 E0                                 ld      (varL2_BUFFER_MODE),a
   8+ E008 C9                                       ret
   9+ E009
  10+ E009 AF           asm_l2_double_buffer_off:   xor     a
  11+ E00A 32 01 E0                                 ld      (varL2_BUFFER_MODE),a
  12+ E00D C9                                       ret
  13+ E00E
  14+ E00E 01 3B 12     asm_disable_l2_readwrite:   ld      bc, IO_LAYER2_PORT
  15+ E011 ED 70                                    in      (c)
  16+ E013 32 02 E0                                 ld      (varL2_ACCESS_MODE),a
  17+ E016 E6 FA                                    and     LAYER2_DISABLE_MEM_ACCESS
  18+ E018 ED 79                                    out     (c),a
  19+ E01A C9                                       ret
  20+ E01B
  21+ E01B 3A 02 E0     asm_restore_l2_readwrite:   ld      a,(varL2_ACCESS_MODE)
  22+ E01E E6 05                                    and     LAYER2_READ_WRITE_MASK
  23+ E020 57                                       ld      d,a
  24+ E021 01 3B 12                                 ld      bc, IO_LAYER2_PORT
  25+ E024 ED 70                                    in      (c)
  26+ E026 32 02 E0                                 ld      (varL2_ACCESS_MODE),a
  27+ E029 A2                                       and     d
  28+ E02A ED 79                                    out     (c),a
  29+ E02C C9                                       ret
  30+ E02D
  31+ E02D 01 3B 12     asm_enable_l2_readwrite:    ld      bc, IO_LAYER2_PORT
  32+ E030 ED 70                                    in      (c)
  33+ E032 F6 05                                    or      LAYER2_READ_WRITE_MASK
  34+ E034 ED 79                                    out     (c),a
  35+ E036 C9                                       ret
  36+ E037
  37+ E037              ; "asm_l2_bank_select"
  38+ E037              ; " a = sepecific bank mask value to select, does not set varL2_BANK_SELECTED"
  39+ E037 57           asm_l2_bank_select:         ld      d,a
  40+ E038 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
  41+ E03B F6 03                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK
  42+ E03D B2                                       or      d; | LAYER2_SHADOW_SCREEN_MASK
  43+ E03E 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
  44+ E041 ED 79                                    out 	(c),a
  45+ E043 C9                                       ret
  46+ E044              ;  "asm_l2_bank_select a = sepecific bank number to select, dsets varL2_BANK_SELECTED"
  47+ E044 32 00 E0     asm_l2_bank_n_select:       ld		(varL2_BANK_SELECTED),a
  48+ E047 FE 00                                    cp		0
  49+ E049 20 04                                    jr 		nz,.nottopbank
  50+ E04B 3E 00        .topbank:                   ld		a,LAYER2_SHIFTED_SCREEN_TOP
  51+ E04D 18 E8                                    jr		asm_l2_bank_select
  52+ E04F FE 01        .nottopbank:                cp		1
  53+ E051 20 04                                    jr 		nz,.notmiddlebank
  54+ E053 3E 40        .middlebank:                ld		a,LAYER2_SHIFTED_SCREEN_MIDDLE
  55+ E055 18 E0                                    jr		asm_l2_bank_select
  56+ E057 3E 80        .notmiddlebank:             ld		a,LAYER2_SHIFTED_SCREEN_BOTTOM ; default to bottom
  57+ E059 18 DC                                    jr		asm_l2_bank_select
  58+ E05B              		; Note no ret as its handled by above routines
  59+ E05B
  60+ E05B              ; "asm_l2_row_bank_select"
  61+ E05B              ; "A (unsinged) = y row of pixel line from top, sets the bank to top middle or bottom and adjusts a reg to row memory address"
  62+ E05B              ; "Could optimise by holding the previous bank but given its only an out statement it may not save T states at all"
  63+ E05B              ; "destroys BC call de is safe a = adjusted poke pixel row"
  64+ E05B FE 40        asm_l2_row_bank_select:     cp 		64			; row < 64?
  65+ E05D 30 11                                    jr 		nc, .l2rowGTE64
  66+ E05F 08           .l2rowLT64:                 ex		af,af'
  67+ E060                                          ;ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP | LAYER2_SHADOW_SCREEN_MASK
  68+ E060 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
  69+ E063 F6 03                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_TOP
  70+ E065 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
  71+ E068 ED 79                                    out 	(c),a
  72+ E06A AF                                       xor		a						; set a to 0
  73+ E06B 32 00 E0                                 ld		(varL2_BANK_SELECTED),a	; save selected bank number 0
  74+ E06E 08                                       ex		af,af'					; return pixel poke unharmed
  75+ E06F C9                                       ret
  76+ E070 FE 80        .l2rowGTE64:                cp 		128
  77+ E072 30 14                                    jr 		nc, .l2rowGTE128
  78+ E074 08           .l2row64to127:              ex		af,af'
  79+ E075                                  ;		ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE | LAYER2_SHADOW_SCREEN_MASK
  80+ E075 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
  81+ E078 F6 43                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_MIDDLE
  82+ E07A 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
  83+ E07D ED 79                                    out 	(c),a
  84+ E07F 3E 01                                    ld		a,1						; set a to 1
  85+ E081 32 00 E0                                 ld		(varL2_BANK_SELECTED),a	; save selected bank
  86+ E084 08                                       ex		af,af'
  87+ E085 D6 40                                    sub		64
  88+ E087 C9                                       ret
  89+ E088 08           .l2rowGTE128:               ex		af,af'
  90+ E089                                  ;		ld		a, LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM | LAYER2_SHADOW_SCREEN_MASK
  91+ E089 3A 01 E0                                 ld      a,(varL2_BUFFER_MODE)
  92+ E08C F6 83                                    or		LAYER2_VISIBLE_MASK  |  LAYER2_WRITE_ENABLE_MASK | LAYER2_SHIFTED_SCREEN_BOTTOM
  93+ E08E
  94+ E08E 01 3B 12                                 ld 		bc, IO_LAYER2_PORT
  95+ E091 ED 79                                    out 	(c),a
  96+ E093 3E 01                                    ld		a,1						; set a to 2
  97+ E095 32 00 E0                                 ld		(varL2_BANK_SELECTED),a	; save selected bank
  98+ E098 08                                       ex		af,af'
  99+ E099 D6 80                                    sub		128
 100+ E09B C9                                       ret
 101+ E09C
# file closed: ./Layer2Graphics/layer2_bank_select.asm
 263  E09C                  INCLUDE "./Layer2Graphics/layer2_cls.asm"
# file opened: ./Layer2Graphics/layer2_cls.asm
   1+ E09C
   2+ E09C 00           l2_cls_byte	            DB 0
   3+ E09D              ; ">DMA Command BLOCK"
   4+ E09D
   5+ E09D 83 C3 C7 CB  l2_fill                 DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   5+ E0A1 7D
   6+ E0A2 9C E0        l2_fill_astrt           DW l2_cls_byte
   7+ E0A4 00 40        l2_fill_length          DB $00,$40
   8+ E0A6 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY ,DMA_WR2_P2INC_MEMORY ,DMA_WR4_CONT_MODE
   9+ E0A9 00 00        l2_fill_bstrt           DB $00,$00
  10+ E0AB 82 CF B3 87                          DB DMA_STOP_AT_END, DMA_LOAD, DMA_FORCE_READY, DMA_ENABLE
  11+ E0AF              l2_fill_cmd_len	        EQU $ - l2_fill
  12+ E0AF
  13+ E0AF              l2_cls_dma_bank:
  14+ E0AF              ; ">l2_cls_dma_bank"
  15+ E0AF              ; ">sets a bank to"
  16+ E0AF 32 9C E0     .set_colour:            ld (l2_cls_byte),a
  17+ E0B2 21 9D E0     .write_dma:             ld hl, l2_fill
  18+ E0B5 06 12                                ld b, l2_fill_cmd_len
  19+ E0B7 0E 6B                                ld	c,IO_DATAGEAR_DMA_PORT
  20+ E0B9 ED B3                                otir
  21+ E0BB C9                                   ret
  22+ E0BC
  23+ E0BC 3E 00        l2_set_color_upper2:    ld      a,0
  24+ E0BE CD 5B E0                             call asm_l2_row_bank_select
  25+ E0C1 3A 9C E0                             ld      a,(l2_cls_byte)
  26+ E0C4 CD AF E0                             call l2_cls_dma_bank
  27+ E0C7 3E 40                                ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
  28+ E0C9 CD 5B E0                             call asm_l2_row_bank_select
  29+ E0CC 3A 9C E0                             ld      a,(l2_cls_byte)
  30+ E0CF CD AF E0                             call l2_cls_dma_bank
  31+ E0D2 C9                                   ret
  32+ E0D3
  33+ E0D3
  34+ E0D3 3E 00        l2_cls_upper_two_thirds:ld a,0								; pretend we are plotting pixel on row 0 to force top selection
  35+ E0D5 CD 5B E0                             call asm_l2_row_bank_select
  36+ E0D8 3E E3                                ld 	a,COLOUR_TRANSPARENT
  37+ E0DA CD AF E0                             call l2_cls_dma_bank
  38+ E0DD 3E 40                                ld a,64								; pretend we are plotting pixel on row 64 to force mid selection
  39+ E0DF CD 5B E0                             call asm_l2_row_bank_select
  40+ E0E2 3E E3                                ld 	a,COLOUR_TRANSPARENT
  41+ E0E4 CD AF E0                             call l2_cls_dma_bank
  42+ E0E7 C9                                   ret
  43+ E0E8
  44+ E0E8 3E 80        l2_cls_lower_third:     ld a,128							; pretend we are plotting pixel on row 64 to force mid selection
  45+ E0EA CD 5B E0                             call asm_l2_row_bank_select
  46+ E0ED 3E E3                                ld 	a,COLOUR_TRANSPARENT
  47+ E0EF CD AF E0                             call l2_cls_dma_bank
  48+ E0F2 C9                                   ret
  49+ E0F3
  50+ E0F3 CD D3 E0     l2_cls:                 call l2_cls_upper_two_thirds
  51+ E0F6 CD E8 E0                             call l2_cls_lower_third
  52+ E0F9 C9                                   ret
  53+ E0FA
# file closed: ./Layer2Graphics/layer2_cls.asm
 264  E0FA                  INCLUDE "./Layer2Graphics/layer2_initialise.asm"
# file opened: ./Layer2Graphics/layer2_initialise.asm
   1+ E0FA
   2+ E0FA ED 91 12 08  l2_initialise:          nextreg		LAYER2_RAM_PAGE_REGISTER,          	LAYER2_SCREEN_BANK1
   3+ E0FE ED 91 13 0B                          nextreg		LAYER2_RAM_SHADOW_REGISTER,     	LAYER2_SHADOW_BANK1
   4+ E102 ED 91 14 E3                          nextreg		TRANSPARENCY_COLOUR_REGISTER, 		COLOUR_TRANSPARENT
   5+ E106 C9                                   ret
   6+ E107
# file closed: ./Layer2Graphics/layer2_initialise.asm
 265  E107                  INCLUDE "./Layer2Graphics/l2_flip_buffers.asm"
# file opened: ./Layer2Graphics/l2_flip_buffers.asm
   1+ E107              l2_flip_buffers:        GetNextReg LAYER2_RAM_PAGE_REGISTER
   1+ E107 C5          >            push bc
   1+ E108 01 3B 24    >                ld bc,$243B
   1+ E10B 3E 12       >                    ld a,LAYER2_RAM_PAGE_REGISTER
   1+ E10D ED 79       >                    out (c),a
   1+ E10F 04          >                    inc b
   1+ E110 ED 78       >                in a,(c)
   1+ E112 C1          >            pop bc
   2+ E113 57                                   ld      d,a
   3+ E114                                      GetNextReg LAYER2_RAM_SHADOW_REGISTER
   3+ E114 C5          >            push bc
   3+ E115 01 3B 24    >                ld bc,$243B
   3+ E118 3E 13       >                    ld a,LAYER2_RAM_SHADOW_REGISTER
   3+ E11A ED 79       >                    out (c),a
   3+ E11C 04          >                    inc b
   3+ E11D ED 78       >                in a,(c)
   3+ E11F C1          >            pop bc
   4+ E120 5F                                   ld      e,a
   5+ E121 ED 92 12                             nextreg LAYER2_RAM_PAGE_REGISTER, a
   6+ E124 7A                                   ld      a,d
   7+ E125 ED 92 13                             nextreg LAYER2_RAM_SHADOW_REGISTER, a
   8+ E128 C9                                   ret
   9+ E129
# file closed: ./Layer2Graphics/l2_flip_buffers.asm
 266  E129                  INCLUDE "./Layer2Graphics/layer2_plot_pixel.asm"
# file opened: ./Layer2Graphics/layer2_plot_pixel.asm
   1+ E129              l2_plot_pixel:
   2+ E129              ; ">l2_plot_pixel b= row number, c = column number, a = pixel col"
   3+ E129 F5           	push    af
   4+ E12A 78               ld      a,b
   5+ E12B              l2_pp_row_valid:
   6+ E12B                  JumpIfAGTENusng ScreenHeight,l2_pp_dont_plot
   6+ E12B FE C0       >                        cp     ScreenHeight
   6+ E12D D2 3B E1    >                        jp		nc,l2_pp_dont_plot
   7+ E130 C5           	push    bc								; bank select destroys bc so need to save it
   8+ E131              ;	ld      a,b
   9+ E131 CD 5B E0     	call    asm_l2_row_bank_select
  10+ E134 C1           	pop     bc
  11+ E135 47           	ld      b,a
  12+ E136 60           	ld      h,b								; hl now holds ram address after bank select
  13+ E137 69           	ld      l,c
  14+ E138 F1           	pop     af								; a = colour to plott
  15+ E139 77           	ld      (hl),a
  16+ E13A C9           	ret
  17+ E13B              l2_pp_dont_plot:
  18+ E13B F1               pop     af
  19+ E13C C9               ret
  20+ E13D
  21+ E13D              l2_plot_pixel_no_bank:
  22+ E13D              ; ">l2_plot_pixel_no_bank b= row number, c = column number, a = pixel col"
  23+ E13D              ; This version assues pixel is in the same bank as previously plotted ones. optimised for horizontal lines
  24+ E13D E5           	push 	hl
  25+ E13E 60           	ld 		h,b								; hl now holds ram address after bank select
  26+ E13F 69           	ld 		l,c
  27+ E140 77           	ld 		(hl),a
  28+ E141 E1           	pop		hl
  29+ E142 C9           	ret
  30+ E143
  31+ E143              l2_plot_pixel_y_test:
  32+ E143 F5           	push	af
  33+ E144 78           	ld		a,b
  34+ E145 FE C0        	cp		192
  35+ E147 30 03        	jr		nc,.clearup
  36+ E149 F1           	pop		af
  37+ E14A 18 DD        	jr		l2_plot_pixel
  38+ E14C              .clearup:
  39+ E14C F1           	pop		af
  40+ E14D C9           	ret
  41+ E14E
  42+ E14E              l2_point_pixel_y_safe:	MACRO
  43+ E14E ~            						push	hl
  44+ E14E ~            						push	bc
  45+ E14E ~            						call	l2_plot_pixel
  46+ E14E ~            						pop		bc
  47+ E14E ~            						pop		hl
  48+ E14E              						ENDM
  49+ E14E
# file closed: ./Layer2Graphics/layer2_plot_pixel.asm
 267  E14E                  INCLUDE "./Layer2Graphics/layer2_print_character.asm"
# file opened: ./Layer2Graphics/layer2_print_character.asm
   1+ E14E
   2+ E14E              l2_print_chr_at:
   3+ E14E              ; "l2_print_chr_at, bc = col,row, d= character, e = colour"
   4+ E14E              ; "Need a version that also prints absence of character"
   5+ E14E 7A           	ld		a,d
   6+ E14F FE 20        	cp		32
   7+ E151 38 3F        	jr		c,.InvalidCharacter		; Must be between 32 and 127
   8+ E153 FE 7F        	cp		127
   9+ E155 30 3B        	jr		nc,.InvalidCharacter
  10+ E157              .ValidCharater:
  11+ E157 26 00        	ld		h,0
  12+ E159 6A           	ld		l,d
  13+ E15A 29           	add		hl,hl						; * 2
  14+ E15B 29           	add		hl,hl						; * 4
  15+ E15C 29           	add		hl,hl						; * 8 to get byte address
  16+ E15D ED 34 00 3C  	add		hl,charactersetaddr			; hl = address of rom char
  17+ E161 04           	inc		b							; start + 1 pixel x and y as we only print 7x7
  18+ E162 23           	inc		hl							; skip first byte
  19+ E163 16 07        	ld		d,7
  20+ E165              .PrintCharLoop:
  21+ E165 D5           	push	de
  22+ E166 7E           	ld		a,(hl)
  23+ E167 FE 00        	cp		0
  24+ E169 28 21        	jr		z,.NextRowNoBCPop
  25+ E16B              .PrintARow:
  26+ E16B C5           	push	bc							; save row col
  27+ E16C 16 07        	ld		d,7							; d is loop row number now
  28+ E16E              .PrintPixelLoop:
  29+ E16E 0C           	inc		c							; we start at col 1 not 0 so can move inc here
  30+ E16F              .PrintTheRow:
  31+ E16F CB 27        	sla		a							; scroll char 1 pixel as we read from bit 7
  32+ E171 F5           	push	af							; save character byte
  33+ E172 CB 7F        	bit		7,a							; If left most pixel set then plot
  34+ E174 20 04        	jr		nz,.PixelToPrint
  35+ E176              .NoPixelToPrint:
  36+ E176 3E E3        	ld		a,$E3
  37+ E178 18 01        	jr		.HaveSetPixelColour
  38+ E17A              .PixelToPrint:
  39+ E17A 7B           	ld		a,e							; Get Colour
  40+ E17B              .HaveSetPixelColour
  41+ E17B E5           	push	hl
  42+ E17C              ;	push	bc							; at the moment we don't do paging on first plot so need to preserve BC
  43+ E17C              .BankOnFirstOnly:
  44+ E17C F5           	push	af
  45+ E17D 7A           	ld		a,d
  46+ E17E FE 07        	cp		7
  47+ E180 28 11        	jr		z,.PlotWithBank
  48+ E182              .PlotNoBank:
  49+ E182 F1           	pop		af
  50+ E183 60           	ld 		h,b								; hl now holds ram address after bank select
  51+ E184 69           	ld 		l,c
  52+ E185 77           	ld 		(hl),a
  53+ E186              .IterateLoop:
  54+ E186              ;	pop		bc
  55+ E186 E1           	pop		hl
  56+ E187 F1           	pop		af							; a= current byte shifted
  57+ E188 15           	dec		d						 	; do dec after inc as we amy
  58+ E189 20 E3        	jr		nz,.PrintPixelLoop
  59+ E18B              .NextRow:
  60+ E18B C1           	pop		bc							; Current Col Row
  61+ E18C              .NextRowNoBCPop:
  62+ E18C D1           	pop		de							; d= row loop
  63+ E18D 04           	inc		b							; Down 1 row
  64+ E18E 23           	inc		hl							; Next character byte
  65+ E18F 15           	dec		d							; 1 done now
  66+ E190 20 D3        	jr		nz,.PrintCharLoop
  67+ E192              .InvalidCharacter:
  68+ E192 C9           	ret
  69+ E193              .PlotWithBank:
  70+ E193 F1           	pop		af
  71+ E194 CD 29 E1     	call	l2_plot_pixel				; This will shift bc to poke row
  72+ E197 18 ED        	jr		.IterateLoop
  73+ E199
  74+ E199              l2_print_at:
  75+ E199              ; "l2_print_at bc= colrow, hl = addr of message, e = colour"
  76+ E199              ; "No error trapping, if there is no null is will just cycle on the line"
  77+ E199 7E           	ld	a,(hl)							; Return if empty string
  78+ E19A FE 00        	cp	0
  79+ E19C C8           	ret	z
  80+ E19D E5           	push	hl
  81+ E19E D5           	push	de
  82+ E19F C5           	push	bc
  83+ E1A0 57           	ld		d,a							; bc = pos, de = char and colour
  84+ E1A1 CD 4E E1     	call 	l2_print_chr_at
  85+ E1A4 C1           	pop		bc
  86+ E1A5 D1           	pop		de
  87+ E1A6 E1           	pop		hl
  88+ E1A7              .Move8Pixlestoright:
  89+ E1A7 08           	ex		af,af'
  90+ E1A8 79           	ld		a,c
  91+ E1A9 C6 08        	add		8
  92+ E1AB 4F           	ld		c,a
  93+ E1AC 08           	ex		af,af'
  94+ E1AD 23           	inc		hl
  95+ E1AE 18 E9        	jr		l2_print_at					; Just loop until 0 found
  96+ E1B0
  97+ E1B0
  98+ E1B0              ; "l2_print_chr_at, bc = col,row, d= character, e = colour"
  99+ E1B0              ; "Need a version that also prints absence of character"
 100+ E1B0              ; removed blank line optimisation as we need spaces printed
 101+ E1B0 7A           l2_print_7chr_at:       ld		a,d
 102+ E1B1 FE 1F                                cp		31
 103+ E1B3 38 3D                                jr		c,.InvalidCharacter		; Must be between 32 and 127
 104+ E1B5 FE 7F                                cp		127
 105+ E1B7 30 39                                jr		nc,.InvalidCharacter
 106+ E1B9 26 00        .ValidCharater:         ld		h,0
 107+ E1BB 6A                                   ld		l,d
 108+ E1BC 29                                   add		hl,hl						; * 2
 109+ E1BD 29                                   add		hl,hl						; * 4
 110+ E1BE 29                                   add		hl,hl						; * 8 to get byte address
 111+ E1BF ED 34 00 3C                          add		hl,charactersetaddr			; hl = address of rom char
 112+ E1C3 04                                   inc		b							; start + 1 pixel x and y as we only print 7x7
 113+ E1C4 23                                   inc		hl							; skip first byte
 114+ E1C5 16 07                                ld		d,7
 115+ E1C7 D5           .PrintCharLoop:         push	de
 116+ E1C8 7E                                   ld		a,(hl)
 117+ E1C9                                      ;cp		0
 118+ E1C9                                      ;jr		z,.NextRowNoBCPop
 119+ E1C9 C5           .PrintARow:             push	bc							; save row col
 120+ E1CA 16 06                                ld		d,6							; d is loop row number now
 121+ E1CC 0C           .PrintPixelLoop:        inc		c							; we start at col 1 not 0 so can move inc here
 122+ E1CD 28 1C                                jr		z,.NextRow
 123+ E1CF CB 27                                sla		a							; scroll char 1 pixel as we read from bit 7
 124+ E1D1 F5                                   push	af							; save character byte
 125+ E1D2 CB 7F                                bit		7,a							; If left most pixel set then plot
 126+ E1D4 20 04                                jr		nz,.PixelToPrint
 127+ E1D6 3E E3        .NoPixelToPrint:        ld		a,$E3
 128+ E1D8 18 01                                jr		.HaveSetPixelColour
 129+ E1DA 7B           .PixelToPrint:          ld		a,e							; Get Colour
 130+ E1DB E5           .HaveSetPixelColour		push	hl
 131+ E1DC                                      ;	push	bc							; at the moment we don't do paging on first plot so need to preserve BC
 132+ E1DC F5           .BankOnFirstOnly:       push	af
 133+ E1DD 7A                                   ld		a,d
 134+ E1DE FE 06                                cp		6
 135+ E1E0 28 11                                jr		z,.PlotWithBank
 136+ E1E2 F1           .PlotNoBank:            pop		af
 137+ E1E3 60                                   ld 		h,b								; hl now holds ram address after bank select
 138+ E1E4 69                                   ld 		l,c
 139+ E1E5 77                                   ld 		(hl),a
 140+ E1E6              .IterateLoop:	        ;	pop		bc
 141+ E1E6 E1                                   pop		hl
 142+ E1E7 F1                                   pop		af							; a= current byte shifted
 143+ E1E8 15                                   dec		d						 	; do dec after inc as we amy
 144+ E1E9 20 E1                                jr		nz,.PrintPixelLoop
 145+ E1EB C1           .NextRow:               pop		bc							; Current Col Row
 146+ E1EC D1           .NextRowNoBCPop:	    pop		de							; d= row loop
 147+ E1ED 04                                   inc		b							; Down 1 row
 148+ E1EE 23                                   inc		hl							; Next character byte
 149+ E1EF 15                                   dec		d							; 1 done now
 150+ E1F0 20 D5                                jr		nz,.PrintCharLoop
 151+ E1F2 C9           .InvalidCharacter:      ret
 152+ E1F3 F1           .PlotWithBank:          pop		af
 153+ E1F4 CD 29 E1                             call	l2_plot_pixel				; This will shift bc to poke row
 154+ E1F7 18 ED                                jr		.IterateLoop
 155+ E1F9
 156+ E1F9              ; "l2_print_7at bc= colrow, hl = addr of message, e = colour"
 157+ E1F9              ; "No error trapping, if there is no null is will just cycle on the line"
 158+ E1F9 7E           l2_print_7at:           ld	a,(hl)							; Return if empty string
 159+ E1FA FE 00                                cp	0
 160+ E1FC C8                                   ret	z
 161+ E1FD E5                                   push	hl
 162+ E1FE D5                                   push	de
 163+ E1FF C5                                   push	bc
 164+ E200 57                                   ld		d,a							; bc = pos, de = char and colour
 165+ E201 CD B0 E1                             call 	l2_print_7chr_at
 166+ E204 C1                                   pop		bc
 167+ E205 D1                                   pop		de
 168+ E206 E1                                   pop		hl
 169+ E207 08           .Move7Pixlestoright:	ex		af,af'
 170+ E208 79                                   ld		a,c
 171+ E209 C6 07                                add		7
 172+ E20B 4F                                   ld		c,a
 173+ E20C 08                                   ex		af,af'
 174+ E20D 23                                   inc		hl
 175+ E20E 18 E9                                jr		l2_print_7at					; Just loop until 0 found
 176+ E210
 177+ E210
# file closed: ./Layer2Graphics/layer2_print_character.asm
 268  E210                  INCLUDE "./Layer2Graphics/layer2_draw_box.asm"
# file opened: ./Layer2Graphics/layer2_draw_box.asm
   1+ E210              ; "l2_draw_thick_box bc=rowcol, de=heightwidth h=color"
   2+ E210              ; TODO DMA Optimise
   3+ E210 C5 D5 E5     l2_draw_fill_box:       push    bc,,de,,hl
   4+ E213 53                                   ld      d,e
   5+ E214 5C                                   ld      e,h
   6+ E215 CD 8A E2                             call    l2_draw_horz_line           ; "bc = left side row,col, d = length, e = color"
   7+ E218 E1 D1 C1                             pop     bc,,de,,hl
   8+ E21B 04                                   inc     b
   9+ E21C 15                                   dec     d
  10+ E21D C8                                   ret     z
  11+ E21E 18 F0                                jr      l2_draw_fill_box
  12+ E220
  13+ E220              ; "l2_draw_box bc=rowcol, de=heightwidth a=color"
  14+ E220 C5 D5 F5     l2_draw_box:            push	bc,,de,,af
  15+ E223 53                                   ld		d,e
  16+ E224 5F                                   ld		e,a
  17+ E225 14                                   inc		d
  18+ E226 CD 8A E2                             call	l2_draw_horz_line
  19+ E229 F1 D1 C1                             pop		bc,,de,,af
  20+ E22C C5 D5 F5     .bottomhorzline:	    push	bc,,de,,af
  21+ E22F 67                                   ld		h,a							;save color whilst b = row + height
  22+ E230 78                                   ld		a,b
  23+ E231 82                                   add		a,d
  24+ E232 47                                   ld		b,a
  25+ E233 53                                   ld		d,e							; d = width
  26+ E234 14                                   inc		d							; Extra pixel for width
  27+ E235 5C                                   ld		e,h							; e = colour
  28+ E236 CD 8A E2                             call	l2_draw_horz_line
  29+ E239 F1 D1 C1                             pop		bc,,de,,af
  30+ E23C C5 D5 F5     .leftvertline:          push	bc,,de,,af
  31+ E23F 04                                   inc		b							; save 2 pixles
  32+ E240 15                                   dec		d
  33+ E241 5F                                   ld		e,a							; e = color
  34+ E242 CD DB E2                             call	l2_draw_vert_line
  35+ E245 F1 D1 C1                             pop		bc,,de,,af
  36+ E248 04           .rightvertline:         inc		b							; save 2 pixles
  37+ E249 15                                   dec		d
  38+ E24A 67                                   ld		h,a							;save color whilst c = col + width
  39+ E24B 79                                   ld		a,c
  40+ E24C 83                                   add		a,e
  41+ E24D 4F                                   ld		c,a
  42+ E24E 5C                                   ld		e,h							; e = color
  43+ E24F CD DB E2                             call	l2_draw_vert_line
  44+ E252 C9                                   ret
  45+ E253
# file closed: ./Layer2Graphics/layer2_draw_box.asm
 269  E253                  INCLUDE "./Layer2Graphics/asm_l2_plot_horizontal.asm"
# file opened: ./Layer2Graphics/asm_l2_plot_horizontal.asm
   1+ E253
   2+ E253              ;; NOTE DMA is little endian
   3+ E253 00           l2_horz_pixel           DB 0
   4+ E254
   5+ E254 83 C3 C7 CB  l2_horz_line            DB DMA_DISABLE,  DMA_RESET, DMA_RESET_PORT_A_TIMING, DMA_RESET_PORT_B_TIMING ,DMA_WRO_BLOCK_PORTA_A2B_XFR
   5+ E258 7D
   6+ E259 53 E2        l2_horz_colr            DW l2_horz_pixel
   7+ E25B 00           l2_horz_lenlo           DB 0
   8+ E25C 00           l2_horz_lenhi           DB 0
   9+ E25D 24 10 AD                             DB DMA_WR1_P1FIXED_MEMORY, DMA_WR2_P2INC_MEMORY, DMA_WR4_CONT_MODE
  10+ E260 00 00        l2_horz_target          DB $00, $00
  11+ E262 CF 87                                DB DMA_LOAD, DMA_ENABLE
  12+ E264              l2_horz_cmd_len	        EQU $ - l2_horz_line
  13+ E264
  14+ E264
  15+ E264              ; "l2_draw_horz_dma"
  16+ E264              ; "plot at bc for length d colour e using dma, assumes bank already selected"
  17+ E264 7B           l2_draw_horz_dma:       ld		a,e                                               ; T=4      ;
  18+ E265 32 53 E2                             ld		(l2_horz_pixel),a                                 ; T=13     ;
  19+ E268 5A                                   ld      e,d ; saved 3 t states ld		a,d                                               ; T=4      ; e=d   4
  20+ E269 16 00                                ld      d,0; saved 3 t states ld 		(l2_horz_lenlo),a                                 ; T=13     ; d = 0  7
  21+ E26B ED 53 5B E2                          ld      (l2_horz_lenlo),de; saved 3 t states xor 	a                                                 ; T=4      ; t 20  31
  22+ E26F                                      ; saved 3 t states ld ld 		(l2_horz_lenhi),a                                 ; T=13     ;
  23+ E26F                                    ; saved 4 t states  ld		h,b                           ;          ;
  24+ E26F                                    ; saved 4 t states  ld		l,c                           ;          ;
  25+ E26F ED 43 60 E2                          ld      (l2_horz_target),bc ; saved 4 t states  was , hl  ; T=20     ;
  26+ E273 21 54 E2     .write_dma:             ld 		hl, l2_horz_line                                  ;          ;
  27+ E276 06 10                                ld 		b, l2_horz_cmd_len                                ;
  28+ E278 0E 6B                                ld		c,IO_DATAGEAR_DMA_PORT                            ;
  29+ E27A ED B3                                otir                                                      ;
  30+ E27C C9                                   ret
  31+ E27D
  32+ E27D              ; "bc = left side row,col, d = length, e = color"
  33+ E27D D5           l2_draw_horz_dma_bank:  push 	de							; save length and colour
  34+ E27E C5                                   push 	bc							; save row col
  35+ E27F 78                                   ld   	a,b
  36+ E280 CD 5B E0                             call 	asm_l2_row_bank_select		; now we have the correct bank, its a horizontal line so bank will not shift
  37+ E283 C1                                   pop  	bc
  38+ E284 47                                   ld	 	b,a	       					; fixed row by the call we can go straight into HL with row col
  39+ E285 D1                                   pop  	de							; get length back
  40+ E286 CD 64 E2                             call    l2_draw_horz_dma
  41+ E289 C9                                   ret
  42+ E28A
  43+ E28A              ; "l2_draw_horz_line"
  44+ E28A              ; "bc = left side row,col, d = length, e = color"
  45+ E28A              ; "optimisation if above min pix is will use dma call SCREEN_HOZ_MIN_PIX not implemented yet"
  46+ E28A 7A           l2_draw_horz_line:      ld		a,d
  47+ E28B FE 00                                cp 		0							; if its zero length then just return
  48+ E28D C8           .zerolengthexit:        ret		z
  49+ E28E FE 01        .isitlen1:              cp 		1
  50+ E290 CA B2 E2                             jp 		z,.l2_draw_horz_line_1
  51+ E293 FE 0A        .longenoughtfordma:     cp  10
  52+ E295 C3 7D E2                             jp  l2_draw_horz_dma_bank
  53+ E298 D5 C5        .plottableline:         push 	de,,bc  					; save length and colour an d row col
  54+ E29A 78                                   ld   	a,b
  55+ E29B CD 5B E0                             call 	asm_l2_row_bank_select		; now we have the correct bank, its a horizontal line so bank will not shift
  56+ E29E C1                                   pop  	bc
  57+ E29F 67                                   ld	 	h,a	       					; fixed row by the call we can go straight into HL with row col
  58+ E2A0 69                                   ld   	l,c
  59+ E2A1 D1                                   pop  	de							; get length back
  60+ E2A2 79           .cliptest:              ld	 	a,c							; get column + length
  61+ E2A3 42                                   ld  	b,d  						; speculate that we don't clip by pre-loading b with length
  62+ E2A4 82                                   add  	a,d
  63+ E2A5 30 06                                jr   	nc, .l2_draw_horz_plot_loop	; if carry is set c+d > 255
  64+ E2A7 3E FF        .clipat255:             ld   	a,$FF
  65+ E2A9 91                                   sub  	c							; a holds clipped length
  66+ E2AA 47                                   ld 		b, a 						; so now hl holds poke address  b = clipped length e = colour
  67+ E2AB 18 00                                jr		.l2_draw_horz_plot_loop
  68+ E2AD 73           .l2_draw_horz_plot_loop:ld (hl),e							; loop poking hl with e for b pixels
  69+ E2AE 23                                   inc hl
  70+ E2AF 10 FC                                djnz .l2_draw_horz_plot_loop
  71+ E2B1 C9                                   ret
  72+ E2B2 7B           .l2_draw_horz_line_1:   ld		a,e
  73+ E2B3 C3 29 E1                             jp		l2_plot_pixel				; hijack return
  74+ E2B6
  75+ E2B6              ; "l2_draw_horz_line_to"
  76+ E2B6              ; "bc = left side row,col, d right pixel, e = color"
  77+ E2B6 7A           l2_draw_horz_line_to:   ld 		a,d
  78+ E2B7 B9                                   cp 		c
  79+ E2B8 30 04                                jr		nc, .noswap
  80+ E2BA 28 07                                jr      z, .singlepixel
  81+ E2BC 51           .swap:                  ld		d,c
  82+ E2BD 4F                                   ld		c,a
  83+ E2BE 7A           .noswap:                ld		a,d
  84+ E2BF 91                                   sub		c
  85+ E2C0              ;                        dec		a							; so now its length not offset
  86+ E2C0 57                                   ld		d,a
  87+ E2C1 18 C7                                jr 		l2_draw_horz_line			; hijack routine and return statements
  88+ E2C3 7B           .singlepixel:           ld		a,e
  89+ E2C4 C3 29 E1                             jp		l2_plot_pixel				; hijack return
  90+ E2C7
# file closed: ./Layer2Graphics/asm_l2_plot_horizontal.asm
 270  E2C7                  INCLUDE "./Layer2Graphics/asm_l2_plot_vertical.asm"
# file opened: ./Layer2Graphics/asm_l2_plot_vertical.asm
   1+ E2C7              ; ">l2_draw_vert_segment"
   2+ E2C7              ; ">hl = bank adjusted pixel poke address d = length, e = color"
   3+ E2C7              ; ">will always clip once h = 64 even if length > 64 destroys a and hl, d = resudual length not plotted"
   4+ E2C7 7A           l2_draw_vert_segment:   ld		a,d
   5+ E2C8 FE 00        .emptylinecheck:	    cp 		0
   6+ E2CA C8                                   ret		z
   7+ E2CB FE 01        .justonepixel	        cp		1
   8+ E2CD 20 02                                jr		nz, .multiplepixelsLoop
   9+ E2CF 73                                   ld		(hl),e
  10+ E2D0 C9                                   ret
  11+ E2D1              .multiplepixelsLoop:
  12+ E2D1 7C           .endofbankcheck:        ld   	a,h
  13+ E2D2 FE 40                                cp   	64
  14+ E2D4 D0                                   ret		nc							; check before we poke data if we have hit a boundary
  15+ E2D5 73           .canplotapixel:         ld   	(hl),e						; set colour
  16+ E2D6 24                                   inc 	h							; we don't check here else we would need a dec d on ret could do for optimisation of loop though
  17+ E2D7 15                                   dec		d
  18+ E2D8 C8                                   ret		z
  19+ E2D9 18 F6                                jr		.multiplepixelsLoop
  20+ E2DB
  21+ E2DB              ; ">l2_draw_vert_line"
  22+ E2DB              ; ">bc = row col d = length, e = color"
  23+ E2DB 78           l2_draw_vert_line:      ld 		a,b
  24+ E2DC FE C0        .offscreencheck:        cp 		SCREEN_HEIGHT
  25+ E2DE D0                                   ret 	nc							; can't start off the screen
  26+ E2DF 7A           .emptylinecheck:        ld		a,d
  27+ E2E0 FE 00                                cp		0
  28+ E2E2 C8                                   ret		z
  29+ E2E3 FE 01                                cp		1
  30+ E2E5 20 04                                jr		nz,.multiplepixels
  31+ E2E7 CD 29 E1     .itsonepixel:           call	l2_plot_pixel
  32+ E2EA C9                                   ret
  33+ E2EB              .multiplepixels:						; so now we have at least 2 pixels to plot
  34+ E2EB 7A           .clipto192:             ld		a,d							; get length
  35+ E2EC 80                                   add		a,b							; a= row + length
  36+ E2ED 38 04                                jr		c,.needtoclip				; if it was > 255 then there is a definite need
  37+ E2EF FE C0                                cp		SCREEN_HEIGHT
  38+ E2F1 38 08                                jr		c, .noclipneeded
  39+ E2F3 78           .needtoclip             ld		a,b
  40+ E2F4 82                                   add		a,d
  41+ E2F5 D6 C0                                sub		SCREEN_HEIGHT
  42+ E2F7 67                                   ld		h,a							; use h as a temp holding for (row + length) - 192
  43+ E2F8 7A                                   ld		a,d
  44+ E2F9 94                                   sub		h
  45+ E2FA 57                                   ld		d,a							; d = length - ((row + length) - 192)
  46+ E2FB              ; so now BC = row col, d = length clipped, e = color
  47+ E2FB 78           .noclipneeded:          ld		a,b
  48+ E2FC C5 D5                                push	bc,,de
  49+ E2FE CD 5B E0                             call 	asm_l2_row_bank_select
  49+ E301               	 	; we now have poke address and a variable holding current bank number
  50+ E301 D1 C1                                pop		bc,,de
  51+ E303 67                                   ld		h,a							; b now tolds target pixel for first plot
  52+ E304 69                                   ld		l,c  						; and c holds pixel column for plotting
  53+ E305 CD C7 E2                             call 	l2_draw_vert_segment		; draw seg, d = pixels remaining
  54+ E308 7A                                   ld		a,d							; a and d = nbr pixels remaining
  55+ E309 FE 00                                cp		0
  56+ E30B 28 27                                jr		z, .doneplotting
  57+ E30D 3A 00 E0     .anotherbank:           ld		a, (varL2_BANK_SELECTED)
  58+ E310 3C                                   inc		a
  59+ E311 06 00                                ld		b,0
  60+ E313 C5 D5                                push	bc,,de
  61+ E315 CD 44 E0                             call 	asm_l2_bank_n_select
  62+ E318 D1 C1                                pop     bc,,de
  63+ E31A 60                                   ld		h,b							; b now tolds target pixel for first plot
  64+ E31B 69                                   ld		l,c  						; and c holds pixel column for plotting
  65+ E31C CD C7 E2                             call	l2_draw_vert_segment
  66+ E31F 7A                                   ld		a,d
  67+ E320 FE 00                                cp		0
  68+ E322 28 10                                jr		z,.doneplotting
  69+ E324 3A 00 E0     .yetanotherbank:        ld		a, (varL2_BANK_SELECTED)
  70+ E327 3C                                   inc		a
  71+ E328 06 00                                ld		b,0
  72+ E32A C5 D5                                push	bc,,de
  73+ E32C CD 44 E0                             call 	asm_l2_bank_n_select
  74+ E32F D1                                   pop		de
  75+ E330 E1                                   pop		hl							; hl = bc
  76+ E331 CD C7 E2                             call	l2_draw_vert_segment		; we have now hit 192 pixels so done
  77+ E334 C9           .doneplotting:	        ret
  78+ E335
  79+ E335              ; ">l2_draw_vert_line_to"
  80+ E335              ; ">bc = row col d = to position, e = color"
  81+ E335 78           l2_draw_vert_line_to:   ld		a,b
  82+ E336 BA                                   cp		d
  83+ E337 38 02                                jr		c, .noyswap
  84+ E339 42           .yswap:                 ld		b,d			; Swap round row numbers so we are always incrementing
  85+ E33A 57                                   ld		d,a			; now we have a top to bottom to we we can calc length from bc
  86+ E33B 7A           .noyswap:               ld		a,d 		; we still may have d in a but only if it was bottom to top
  87+ E33C 90                                   sub		b
  88+ E33D 3C                                   inc		a			; so now its length not offset
  89+ E33E 57                                   ld		d,a
  90+ E33F 18 9A                                jr		l2_draw_vert_line	; we can hijack its clipping, 0 check and return logic
  91+ E341                                      ; no return needed
  92+ E341
# file closed: ./Layer2Graphics/asm_l2_plot_vertical.asm
 271  E341                  INCLUDE "./Layer2Graphics/layer2_plot_diagonal.asm"
# file opened: ./Layer2Graphics/layer2_plot_diagonal.asm
   1+ E341
   2+ E341              l2_draw_box_to:
   3+ E341              ; ">l2_draw_box_to bc=rowcol, de=torowcol a=color"
   4+ E341              ; ">NOT IMPLEMENTED YET"
   5+ E341 C9           	ret
   6+ E342
   7+ E342              ;; Note l2stepx is done via self modifying code rather than an if for speed
   8+ E342              ;; l2stepx1 and l2stepx2 are the addresses to stick the inc or dec in
   9+ E342              l2decbstep	EQU $05
  10+ E342              l2incbstep	EQU	$04
  11+ E342              l2deccstep	EQU $0D
  12+ E342              l2inccstep	EQU	$0C
  13+ E342              		; l2 deltas are signed
  14+ E342 00 00        l2deltaY	DW	0
  15+ E344 00 00        l2deltaX	DW	0
  16+ E346 00           l2deltaYsq	db	0
  17+ E347 00           l2deltaXsq	db	0
  18+ E348 00           l2deltaYn	db	0
  19+ E349 00           l2deltaXn	db	0
  20+ E34A 00           l2deltaYsqn	db	0
  21+ E34B 00           l2deltaXsqn	db	0
  22+ E34C 00           l2linecolor	db	0
  23+ E34D 00 00        l2fraction	dw	0
  24+ E34F 00 00        l2e2		dw	0
  25+ E351 00           l2way		db	0
  26+ E352 00 00        l2targetPtr	dw	0
  27+ E354              ;; These arrays should be 192 but if we use 256 then getting array2 value is just inc h rather than indexing again.
  28+ E354 00 00 00...  l2targetArray1 ds	256
  29+ E454 00 00 00...  l2targetArray2 ds	256
  30+ E554              ;; Using Bresenham Algorithm draw a diagonal line top to bottom. First we must sort of course
  31+ E554              ;;plotLine(int x0, int y0, int x1, int y1)
  32+ E554              ;;    dx =  abs(x1-x0);
  33+ E554              ;;    sx = x0<x1 ? 1 : -1;
  34+ E554              ;;    dy = -abs(y1-y0);
  35+ E554              ;;    sy = y0<y1 ? 1 : -1;
  36+ E554              ;;    err = dx+dy;  /* error value e_xy */
  37+ E554              ;;    while (true)   /* loop */
  38+ E554              ;;        plot(x0, y0);
  39+ E554              ;;        if (x0==x1 && y0==y1) break;
  40+ E554              ;;        e2 = 2*err;
  41+ E554              ;;        if (e2 >= dy) /* e_xy+e_x > 0 */
  42+ E554              ;;            err += dy;
  43+ E554              ;;            x0 += sx;
  44+ E554              ;;        end if
  45+ E554              ;;        if (e2 <= dx) /* e_xy+e_y < 0 */
  46+ E554              ;;            err += dx;
  47+ E554              ;;            y0 += sy;
  48+ E554              ;;        end if
  49+ E554              ;;    end while
  50+ E554              ; ">l2_draw_diagonal_save, bc = y0,x0 de=y1,x1,a=array nbr ESOURCE LL30 or LION"
  51+ E554              ; ">hl will be either l2targetArray1 or 2"
  52+ E554              ; NOTE IF WE INTERLEAVE THESE TWO TABLES WE COUDL READ BOTH X POS as a 16 bit read
  53+ E554 FE 01        l2_draw_diagonal_save:  cp		1
  54+ E556 28 06                                jr		z,l2S_ItsArray1
  55+ E558 21 54 E4                             ld		hl,l2targetArray2
  56+ E55B C3 61 E5                             jp		l2S_setTarget
  57+ E55E 21 54 E3     l2S_ItsArray1:	        ld		hl,l2targetArray1
  58+ E561 22 52 E3     l2S_setTarget:	        ld		(l2targetPtr),hl
  59+ E564              ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
  60+ E564 32 4C E3                             ld		(l2linecolor),a					;save colour for later
  61+ E567 21 00 00                             ld		hl,0                            ;
  62+ E56A 22 44 E3                             ld		(l2deltaX),hl                   ;
  63+ E56D 22 42 E3                             ld		(l2deltaY),hl                   ; initlaise deltas as we will only be loading 8 bit in there but workign in 16 bit later
  64+ E570 78           l2S_preSort:            ld		a,b								;
  65+ E571                                      JumpIfALTNusng	d,l2S_noYSort			; we must have Y1 < Y2 (if eqyal then verical line picked up earlier
  65+ E571 BA          >                        cp      d
  65+ E572 DA 7A E5    >                        jp		c, l2S_noYSort
  66+ E575              l2S_SortBasedOnY:	    ldhlbc									;
  66+ E575 60          >                        ld		h,b
  66+ E576 69          >                        ld		l,c
  67+ E577 EB                                   ex		de,hl                           ;
  68+ E578                                      ldbchl									; swap over bc and de using hl as an intermediate
  68+ E578 44          >                        ld		b,h
  68+ E579 4D          >                        ld		c,l
  69+ E57A DD 62        l2S_noYSort:		    ld		ixh,d							; ixh now holds target Y coord post sorting
  70+ E57C DD 6B                                ld		ixl,e							; ixl now holds target X coord post sorting
  71+ E57E 79           l2S_setXLen:            ld		a,c                             ;
  72+ E57F                                      JumpIfALTNusng e,l2S_PosXLen			; if x1 < x2 then we have a positive increment
  72+ E57F BB          >                        cp      e
  72+ E580 DA 8C E5    >                        jp		c, l2S_PosXLen
  73+ E583 79           l2S_NegXLen:            ld		a,c                             ;
  74+ E584 93                                   sub     e                               ;
  75+ E585 32 44 E3                             ld		(l2deltaX),a					; As x1 > x2 we do deltaX = X1 - X2
  76+ E588 3E 0D                                ld		a,l2deccstep					; and set the value for inc dec self modifying to Dec
  77+ E58A 18 07                                jr		l2S_XINCDEC
  78+ E58C 7B           l2S_PosXLen:	        ld		a,e                             ;
  79+ E58D 91                                   sub		c                               ;
  80+ E58E 32 44 E3                             ld 		(l2deltaX),a                    ; As x1 < x2 we do deltaX = X2 - X1
  81+ E591 3E 0C                                ld		a,l2inccstep                    ; and set the value for inc dec self modifying to Inc
  82+ E593              l2S_XINCDEC:
  83+ E593 32 FF E5     	ld		(l2S_adjustCol),a				;
  84+ E596 32 2F E6     	ld		(l2S_adjustCol2),a				; update self modifying code for X update with inc or dec from above
  85+ E599              l2S_setYLen
  86+ E599 7A           	ld		a,d							 	; presorted on Y so it is now always positive
  87+ E59A 90           	sub		b
  88+ E59B 32 42 E3     	ld 		(l2deltaY),a					; DeltaY = Y2 - Y1
  89+ E59E              l2S_setErr:									;  LD H  := (D'-E')/2    round up if +ve or down if -ve
  90+ E59E              ldS_FracDYltDX:								;
  91+ E59E 2A 42 E3     	ld		hl,(l2deltaY)					; Fraction = dY - dX
  92+ E5A1 ED 5B 44 E3  	ld		de,(l2deltaX)
  93+ E5A5              	ClearCarryFlag
  93+ E5A5 B7          >                        or a
  94+ E5A6 ED 52        	sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
  95+ E5A8 EB           	ex		de,hl
  96+ E5A9 FD 62        	ld		iyh,d							; we will use IY reg for fractions
  97+ E5AB FD 6B        	ld		iyl,e
  98+ E5AD F2 D2 E5     	jp		p,l2S_fracIsPositive
  99+ E5B0              l2S_fracIsNegative:
 100+ E5B0              	NegIY
 100+ E5B0 AF          >                    xor a
 100+ E5B1 FD 95       >                    sub iyl
 100+ E5B3 FD 6F       >                    ld iyl,a
 100+ E5B5 9F          >                    sbc a,a
 100+ E5B6 FD 94       >                    sub iyh
 100+ E5B8 FD 67       >                    ld iyh,a
 101+ E5BA              	ShiftIYRight1
 101+ E5BA FD 7C       >			   ld 	a,iyh
 101+ E5BC CB 3F       >			   srl 	a
 101+ E5BE FD 67       >			   ld	iyh,a
 101+ E5C0 FD 7D       >			   ld 	a,iyl
 101+ E5C2 1F          >			   rra
 101+ E5C3 FD 6F       >			   ld	iyl,a
 102+ E5C5              	NegIY
 102+ E5C5 AF          >                    xor a
 102+ E5C6 FD 95       >                    sub iyl
 102+ E5C8 FD 6F       >                    ld iyl,a
 102+ E5CA 9F          >                    sbc a,a
 102+ E5CB FD 94       >                    sub iyh
 102+ E5CD FD 67       >                    ld iyh,a
 103+ E5CF C3 DD E5     	jp		l2S_SkipCalcInc					; so we have a negative frac
 104+ E5D2              l2S_fracIsPositive:
 105+ E5D2              	ShiftIYRight1
 105+ E5D2 FD 7C       >			   ld 	a,iyh
 105+ E5D4 CB 3F       >			   srl 	a
 105+ E5D6 FD 67       >			   ld	iyh,a
 105+ E5D8 FD 7D       >			   ld 	a,iyl
 105+ E5DA 1F          >			   rra
 105+ E5DB FD 6F       >			   ld	iyl,a
 106+ E5DD              l2S_SkipCalcInc:
 107+ E5DD              l2S_Loop:									; As we loop, bc = to plot current XY
 108+ E5DD 2A 52 E3     	ld		hl,(l2targetPtr)				; Insert into respective array
 109+ E5E0 78           	ld		a,b
 110+ E5E1 ED 31        	add		hl,a
 111+ E5E3 71           	ld		(hl),c
 112+ E5E4              l2S_CheckIfEnd:
 113+ E5E4 DD 7C        	ld		a,ixh
 114+ E5E6              	JumpIfAGTENusng	  b,l2S_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
 114+ E5E6 B8          >                        cp     b
 114+ E5E7 D2 ED E5    >                        jp		nc,l2S_CheckXPos
 115+ E5EA C3 F1 E5     	jp		l2S_Continue
 116+ E5ED              l2S_CheckXPos:
 117+ E5ED 79           	ld		a,c
 118+ E5EE              	ReturnIfAGTENusng ixl					; if X1 has reached or exceeded X2 then we are done
 118+ E5EE DD BD       >                        cp    ixl
 118+ E5F0 D0          >                        ret	 nc
 119+ E5F1              l2S_Continue:
 120+ E5F1              l2S_HNegative:
 121+ E5F1 FD 7C        	ld		a,iyh
 122+ E5F3 CB 7F        	bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
 123+ E5F5 28 0B        	jr		z,l2S_ErrNotNegative			;
 124+ E5F7              l2S_ErrNegative:								; if its a negative error update X
 125+ E5F7 3A 42 E3     	ld		a,(l2deltaY)
 126+ E5FA 16 00        	ld		d,0
 127+ E5FC 5F           	ld		e,a
 128+ E5FD FD 19        	add		iy,de							; add deltaY(unsinged) to l2fraction
 129+ E5FF              l2S_adjustCol:
 130+ E5FF 00           	nop										; this is our inc/dec of X
 131+ E600 18 DB        	jr		l2S_Loop							; repeat loop
 132+ E602              l2S_ErrNotNegative:
 133+ E602 FD 7C        	ld		a,iyh
 134+ E604 FD B5        	or		iyl
 135+ E606              	JumpIfAIsZero l2S_ErrZero					; if there is no error then goto zeroerror
 135+ E606 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 135+ E607 CA 20 E6    >                        jp	z, l2S_ErrZero
 136+ E60A              l2S_ErrPositive:								; if its a positive error then we update Y
 137+ E60A              	lddeiy
 137+ E60A FD 54       >                        ld		d,iyh
 137+ E60C FD 5D       >                        ld		e,iyl
 138+ E60E EB           	ex		de,hl
 139+ E60F 16 00        	ld		d,0
 140+ E611 3A 44 E3     	ld		a,(l2deltaX)
 141+ E614 5F           	ld		e,a
 142+ E615              	ClearCarryFlag
 142+ E615 B7          >                        or a
 143+ E616 ED 52        	sbc		hl,de
 144+ E618 EB           	ex		de,hl
 145+ E619              	ldiyde
 145+ E619 FD 62       >                        ld		iyh,d
 145+ E61B FD 6B       >                        ld		iyl,e
 146+ E61D              l2S_adjustRow:									; move Y down by one
 147+ E61D 04           	inc		b
 148+ E61E 18 BD        	jr		l2S_Loop
 149+ E620              l2S_ErrZero:
 150+ E620 2A 44 E3     	ld		hl,(l2deltaX)
 151+ E623 EB           	ex		de,hl
 152+ E624 2A 42 E3     	ld		hl,(l2deltaY)
 153+ E627              	ClearCarryFlag
 153+ E627 B7          >                        or a
 154+ E628 ED 52        	sbc		hl,de
 155+ E62A EB           	ex		de,hl
 156+ E62B              	ldiyde
 156+ E62B FD 62       >                        ld		iyh,d
 156+ E62D FD 6B       >                        ld		iyl,e
 157+ E62F              l2S_adjustCol2:
 158+ E62F 00           	nop										; update X and Y
 159+ E630 04           	inc		b
 160+ E631 18 AA        	jr		l2S_Loop
 161+ E633
 162+ E633              ; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color) Thsi version performs a pre sort based on y axis"
 163+ E633 32 4C E3     l2_draw_diagonal:       ld		(l2linecolor),a					;save colour for later
 164+ E636 21 00 00                             ld		hl,0                            ;
 165+ E639 22 44 E3                             ld		(l2deltaX),hl                   ;
 166+ E63C 22 42 E3                             ld		(l2deltaY),hl                   ; initlaise deltas as we will only be loading 8 bit in there but workign in 16 bit later
 167+ E63F 78           l2D_preSort:            ld		a,b								;
 168+ E640                                      JumpIfALTNusng	d,l2D_noYSort			; we must have Y1 < Y2 (if equal then verical line picked up earlier
 168+ E640 BA          >                        cp      d
 168+ E641 DA 49 E6    >                        jp		c, l2D_noYSort
 169+ E644              l2D_SortBasedOnY:	    ldhlbc									;
 169+ E644 60          >                        ld		h,b
 169+ E645 69          >                        ld		l,c
 170+ E646 EB                                   ex		de,hl                           ;
 171+ E647                                      ldbchl									; swap over bc and de using hl as an intermediate
 171+ E647 44          >                        ld		b,h
 171+ E648 4D          >                        ld		c,l
 172+ E649 DD 62        l2D_noYSort:		    ld		ixh,d							; ixh now holds target Y coord post sorting
 173+ E64B DD 6B                                ld		ixl,e							; ixl now holds target X coord post sorting
 174+ E64D 79           l2D_setXLen:            ld		a,c                             ;
 175+ E64E                                      JumpIfALTNusng e,l2D_PosXLen			; if x1 < x2 then we have a positive increment
 175+ E64E BB          >                        cp      e
 175+ E64F DA 5B E6    >                        jp		c, l2D_PosXLen
 176+ E652 79           l2D_NegXLen:            ld		a,c                             ;
 177+ E653 93                                   sub     e                               ;
 178+ E654 32 44 E3                             ld		(l2deltaX),a					; As x1 > x2 we do deltaX = X1 - X2
 179+ E657 3E 0D                                ld		a,l2deccstep					; and set the value for inc dec self modifying to Dec
 180+ E659 18 07                                jr		l2D_XINCDEC
 181+ E65B 7B           l2D_PosXLen:	        ld		a,e                             ;
 182+ E65C 91                                   sub		c                               ;
 183+ E65D 32 44 E3                             ld 		(l2deltaX),a                    ; As x1 < x2 we do deltaX = X2 - X1
 184+ E660 3E 0C                                ld		a,l2inccstep                    ; and set the value for inc dec self modifying to Inc
 185+ E662 32 D1 E6     l2D_XINCDEC:	        ld		(l2D_adjustCol),a				;
 186+ E665 32 01 E7                             ld		(l2D_adjustCol2),a				; update self modifying code for X update with inc or dec from above
 187+ E668 7A           l2D_setYLen				ld		a,d							 	; presorted on Y so it is now always positive
 188+ E669 90                                   sub		b
 189+ E66A 32 42 E3                             ld 		(l2deltaY),a					; DeltaY = Y2 - Y1
 190+ E66D              l2D_setErr:									;  LD H  := (D'-E')/2    round up if +ve or down if -ve
 191+ E66D 2A 42 E3     ldD_FracDYltDX:			ld		hl,(l2deltaY)					; Fraction = dY - dX
 192+ E670 ED 5B 44 E3                          ld		de,(l2deltaX)
 193+ E674                                      ClearCarryFlag
 193+ E674 B7          >                        or a
 194+ E675 ED 52                                sbc		hl,de							; sbc does not have an SBC IY so need to do this in HL
 195+ E677 EB                                   ex		de,hl
 196+ E678 FD 62                                ld		iyh,d							; we will use IY reg for fractions
 197+ E67A FD 6B                                ld		iyl,e
 198+ E67C F2 A1 E6                             jp		p,l2D_fracIsPositive
 199+ E67F              l2D_fracIsNegative:     NegIY
 199+ E67F AF          >                    xor a
 199+ E680 FD 95       >                    sub iyl
 199+ E682 FD 6F       >                    ld iyl,a
 199+ E684 9F          >                    sbc a,a
 199+ E685 FD 94       >                    sub iyh
 199+ E687 FD 67       >                    ld iyh,a
 200+ E689                                      ShiftIYRight1
 200+ E689 FD 7C       >			   ld 	a,iyh
 200+ E68B CB 3F       >			   srl 	a
 200+ E68D FD 67       >			   ld	iyh,a
 200+ E68F FD 7D       >			   ld 	a,iyl
 200+ E691 1F          >			   rra
 200+ E692 FD 6F       >			   ld	iyl,a
 201+ E694                                      NegIY
 201+ E694 AF          >                    xor a
 201+ E695 FD 95       >                    sub iyl
 201+ E697 FD 6F       >                    ld iyl,a
 201+ E699 9F          >                    sbc a,a
 201+ E69A FD 94       >                    sub iyh
 201+ E69C FD 67       >                    ld iyh,a
 202+ E69E C3 AC E6                             jp		l2D_SkipCalcInc					; so we have a negative frac
 203+ E6A1              l2D_fracIsPositive:     ShiftIYRight1
 203+ E6A1 FD 7C       >			   ld 	a,iyh
 203+ E6A3 CB 3F       >			   srl 	a
 203+ E6A5 FD 67       >			   ld	iyh,a
 203+ E6A7 FD 7D       >			   ld 	a,iyl
 203+ E6A9 1F          >			   rra
 203+ E6AA FD 6F       >			   ld	iyl,a
 204+ E6AC              l2D_SkipCalcInc:
 205+ E6AC C5 D5        l2D_Loop:				push	bc,,de                 			; l2DeltaY and l2DeltaX are set
 206+ E6AE 3A 4C E3                             ld		a,(l2linecolor)     			;
 207+ E6B1 CD 29 E1                             call	l2_plot_pixel       			; Plot Pixel
 208+ E6B4 D1 C1                                pop     bc,,de
 209+ E6B6 DD 7C        l2D_CheckIfEnd:	        ld		a,ixh
 210+ E6B8                                      JumpIfAGTENusng	  b,l2D_CheckXPos		; if Y1 < Y2 then continue regardless, when it hits Y2 then we must check X1 and X2
 210+ E6B8 B8          >                        cp     b
 210+ E6B9 D2 BF E6    >                        jp		nc,l2D_CheckXPos
 211+ E6BC C3 C3 E6                             jp		l2D_Continue
 212+ E6BF 79           l2D_CheckXPos:          ld		a,c
 213+ E6C0                                      ReturnIfAEqNusng ixl					; if X1 has reached or exceeded X2 then we are done
 213+ E6C0 DD BD       >                        cp      ixl
 213+ E6C2 C8          >                        ret     z
 214+ E6C3              l2D_Continue:
 215+ E6C3 FD 7C        l2D_HNegative:			ld		a,iyh
 216+ E6C5 CB 7F                                bit		7,a								; if its negative then we need to deal with delta Y, there is no bit n,iyh instrunction
 217+ E6C7 28 0B                                jr		z,l2D_ErrNotNegative			;
 218+ E6C9 3A 42 E3     l2D_ErrNegative:		ld		a,(l2deltaY)
 219+ E6CC 16 00                                ld		d,0
 220+ E6CE 5F                                   ld		e,a
 221+ E6CF FD 19                                add		iy,de							; add deltaY(unsinged) to l2fraction
 222+ E6D1 00           l2D_adjustCol:          nop										; this is our inc/dec of X
 223+ E6D2 18 D8                                jr		l2D_Loop							; repeat loop
 224+ E6D4 FD 7C        l2D_ErrNotNegative:     ld		a,iyh
 225+ E6D6 FD B5                                or		iyl
 226+ E6D8                                      JumpIfAIsZero l2D_ErrZero					; if there is no error then goto zeroerror
 226+ E6D8 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 226+ E6D9 CA F2 E6    >                        jp	z, l2D_ErrZero
 227+ E6DC              l2D_ErrPositive:		lddeiy
 227+ E6DC FD 54       >                        ld		d,iyh
 227+ E6DE FD 5D       >                        ld		e,iyl
 228+ E6E0 EB                                   ex		de,hl
 229+ E6E1 16 00                                ld		d,0
 230+ E6E3 3A 44 E3                             ld		a,(l2deltaX)
 231+ E6E6 5F                                   ld		e,a
 232+ E6E7                                      ClearCarryFlag
 232+ E6E7 B7          >                        or a
 233+ E6E8 ED 52                                sbc		hl,de
 234+ E6EA EB                                   ex		de,hl
 235+ E6EB                                      ldiyde
 235+ E6EB FD 62       >                        ld		iyh,d
 235+ E6ED FD 6B       >                        ld		iyl,e
 236+ E6EF 04           l2D_adjustRow:			inc		b
 237+ E6F0 18 BA                                jr		l2D_Loop
 238+ E6F2 2A 44 E3     l2D_ErrZero:            ld		hl,(l2deltaX)
 239+ E6F5 EB                                   ex		de,hl
 240+ E6F6 2A 42 E3                             ld		hl,(l2deltaY)
 241+ E6F9                                      ClearCarryFlag
 241+ E6F9 B7          >                        or a
 242+ E6FA ED 52                                sbc		hl,de
 243+ E6FC EB                                   ex		de,hl
 244+ E6FD                                      ldiyde
 244+ E6FD FD 62       >                        ld		iyh,d
 244+ E6FF FD 6B       >                        ld		iyl,e
 245+ E701 00           l2D_adjustCol2:         nop										; update X and Y
 246+ E702 04                                   inc		b
 247+ E703 18 A7                                jr		l2D_Loop
 248+ E705              ;----------------------------------------------------------------------------------------------------------------------------------
 249+ E705
 250+ E705
 251+ E705
 252+ E705
 253+ E705              ;Loin:				; BBC version of line draw
 254+ E705              ;; ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color)"
 255+ E705              ;	ld		(l2linecolor),a					; save colour as a reg gets used alot, coudl move this into interrupt flag and disable interrups
 256+ E705              ;	ld		ixh,0							; ixh = s
 257+ E705              ;	ld		iyh,0							; iyh = swap
 258+ E705              ;	ld		l,0								; l will hold delta sign flags
 259+ E705              ;LoinCalcDeltaX:
 260+ E705              ;	ld		a,e
 261+ E705              ;	sub		c								; a = deltaX
 262+ E705              ;	JumpIfPositive LoinPosDx
 263+ E705              ;LoinNegDx:
 264+ E705              ;	neg										; carry flag will indicate deltaX was negative
 265+ E705              ;	ld		l,$80							; set bit 7 of l for negative
 266+ E705              ;LoinPosDx:
 267+ E705              ;	ld		ixl,a							; ixl = varP = deltaX
 268+ E705              ;LoinCalcDeltaY:
 269+ E705              ;	ld		a,d
 270+ E705              ;	sub		b								; a= deltaY
 271+ E705              ;	JumpIfPositive LoinPosDy
 272+ E705              ;LoinNegDy:
 273+ E705              ;	neg
 274+ E705              ;	set		6,l								; set bit 6 of l for negative deltaY
 275+ E705              ;LoinPosDy:
 276+ E705              ;	ld		iyl,a							; iyl = varQ = deltaY
 277+ E705              ;	JumpIfAGTENusng ixl, LoinSTPy			; if deltaY >= DeltaX then step along Y
 278+ E705              ;LoinSTPx:									; step along X
 279+ E705              ;	JumpOnBitClear l,7						; if l flags were clear then X2 < X2
 280+ E705              ;LoinSTPxSwapCoords:
 281+ E705              ;	dec		iyh								; swap flag now becomes FF
 282+ E705              ;	ld		a,l								; save l flags
 283+ E705              ;	ex		de,hl							; save de to hl
 284+ E705              ;	lddebc									; Point2 = point1
 285+ E705              ;	ldbchl									; Point1 = point2 that was saved
 286+ E705              ;	ld		l,a								; get back l flags
 287+ E705              ;LoinSTPxCorrectOrder:
 288+ E705              ;	l2_point_pixel_y_safe					; call plot pixel preseving bc hl
 289+ E705              ;	ld		a,iyl							; get delta Y back
 290+ E705              ;	ld		iy1,$FE							; roll counter
 291+ E705              ;LionSTPxRollQ:
 292+ E705              ;	sla		a								; highest bit of delta-Y
 293+ E705              ;	jp		c,LoinSTPxSteep
 294+ E705              ;	cp		ixl								; compare with DeltaX
 295+ E705              ;	jp		cs,LoinSTPxShallow
 296+ E705              ;LoinSTPxSteep:								;; LI4
 297+ E705              ;	sbc		a,ixl							; deltaYwork -= (deltaX+1)
 298+ E705              ;	scf										; force carry flag set
 299+ E705              ;LoinSTPxShallow:							;; LI5
 300+ E705              ;	rl		iyl								; rotate iyl which started as FE
 301+ E705              ;	jp		c,LionSTPxRollQ					; so we are doing a 6 bit loop
 302+ E705              ;	inc		ihl								; DeltaX += 1
 303+ E705              ;LoinSTPxYDirection:							; change this to self modifying code
 304+ E705              ;	ld		a,d
 305+ E705              ;	JumpIfAGTEn	b,LionDOWN:
 306+ E705              ;	ld		a,iyh							; swap flag
 307+ E705              ;	JumpIfANotZero	X1Inc  					; if swap flag was not set then no need to update R
 308+ E705              ;LoinSTPxX1Dec:
 309+ E705              ;	dec		c								; move left 1 pixel as we sawped
 310+ E705              ;LoinSTPxXCounter:							;; LIL2
 311+ E705              ;	sub		b
 312+ E705              ;	if
 313+ E705              ;
 314+ E705              ;85 82                   STA &82	   \ R	\ mask byte
 315+ E705              ;A5 81                   LDA &81	   \ Q	\ delta-Y
 316+ E705              ;A2 FE                   LDX #&FE	\ roll counter
 317+ E705              ;86 81                   STX &81		\ Q
 318+ E705              ;.LIL1	\ roll Q
 319+ E705              ;0A                      ASL A		\ highest bit of delta-Y
 320+ E705              ;B0 04                   BCS LI4		\ steep
 321+ E705              ;C5 1B                   CMP &1B	   \ P	\ delta-X
 322+ E705              ;90 03                   BCC LI5		\ shallow
 323+ E705              ;.LI4	\ steep
 324+ E705              ;E5 1B                   SBC &1B		\ P
 325+ E705              ;38                      SEC
 326+ E705              ;.LI5	\ shallow
 327+ E705              ;26 81                   ROL &81	   \ Q	\ #&FE
 328+ E705              ;B0 F2                   BCS LIL1 	\ loop Q, end with some low bits in Q
 329+ E705              ;A6 1B                   LDX &1B		\ P
 330+ E705              ;E8                      INX 		\ Xreg is width
 331+ E705              ;A5 37                   LDA &37		\ Y2
 332+ E705              ;E5 35                   SBC &35		\ Y1
 333+ E705              ;B0 2C                   BCS DOWN	\ draw line to the right and down
 334+ E705              ;A5 90                   LDA &90		\ SWAP
 335+ E705              ;D0 07                   BNE LI6		\ else Xreg was correct after all, no need to update R
 336+ E705              ;CA                      DEX
 337+ E705              ;.LIL2	\ counter X width
 338+ E705              ;A5 82                   LDA &82	   \ R	\ mask byte
 339+ E705              ;51 07                   EOR (&07),Y	\ (SC),Y
 340+ E705              ;91 07                   STA (&07),Y	\ (SC),Y
 341+ E705              ;.LI6	\ Xreg correct
 342+ E705              ;46 82                   LSR &82	   \ R	\ mask byte
 343+ E705              ;90 08                   BCC LI7   	\ else moving to next column to right. Bring carry in back
 344+ E705              ;66 82                   ROR &82		\ R
 345+ E705              ;A5 07                   LDA &07		\ SC
 346+ E705              ;69 08                   ADC #8		\ next column
 347+ E705              ;85 07                   STA &07		\ SC
 348+ E705              ;.LI7	\ S += Q. this is like an overflow monitor to update Y
 349+ E705              ;A5 83                   LDA &83		\ S
 350+ E705              ;65 81                   ADC &81	   \ Q	\ some low bits
 351+ E705              ;85 83                   STA &83		\ S
 352+ E705              ;90 07                   BCC LIC2	\ skip Y adjustment
 353+ E705              ;88                      DEY
 354+ E705              ;10 04                   BPL LIC2	\ skip Y adjustment
 355+ E705              ;C6 08                   DEC &08		\ SC+1
 356+ E705              ;A0 07                   LDY #7
 357+ E705              ;.LIC2	\ skip Y adjustment
 358+ E705              ;CA                      DEX
 359+ E705              ;D0 DC                   BNE LIL2	\ loop X width
 360+ E705              ;A4 85                   LDY &85	 \ YSAV \ restore Yreg
 361+ E705              ;60                      RTS
 362+ E705              ;
 363+ E705              ;.DOWN	\ Line is going to the right and down
 364+ E705              ;A5 90                   LDA &90		\ SWAP
 365+ E705              ;F0 07                   BEQ LI9		\ no swap
 366+ E705              ;CA                      DEX
 367+ E705              ;.LIL3	\ counter X width
 368+ E705              ;A5 82                   LDA &82	    \ R \ mask byte
 369+ E705              ;51 07                   EOR (&07),Y	\ (SC),Y
 370+ E705              ;91 07                   STA (&07),Y	\ (SC),Y
 371+ E705              ;.LI9	\ no swap
 372+ E705              ;46 82                   LSR &82		\ R
 373+ E705              ;90 08                   BCC LI10	\ still in correct column, hop
 374+ E705              ;66 82                   ROR &82		\ R
 375+ E705              ;A5 07                   LDA &07		\ SC
 376+ E705              ;69 08                   ADC #8		\ next column
 377+ E705              ;85 07                   STA &07		\ SC
 378+ E705              ;.LI10	\ this is like an overflow monitor to update Y
 379+ E705              ;A5 83                   LDA &83		\ S
 380+ E705              ;65 81                   ADC &81		\ Q
 381+ E705              ;85 83                   STA &83		\ S
 382+ E705              ;90 09                   BCC LIC3	\ skip Y adjustment
 383+ E705              ;C8                      INY
 384+ E705              ;C0 08                   CPY #8
 385+ E705              ;D0 04                   BNE LIC3	\ have not reached bottom byte of char, hop
 386+ E705              ;E6 08                   INC &08		\ SC+1
 387+ E705              ;A0 00                   LDY #0
 388+ E705              ;.LIC3	\ skipped Y adjustment
 389+ E705              ;CA                      DEX
 390+ E705              ;D0 DA                   BNE LIL3	\ loop X width
 391+ E705              ;A4 85                   LDY &85	 \ YSAV \ restore Yreg
 392+ E705              ;60                      RTS
 393+ E705              ;
 394+ E705              ;.STPY	\ -> &1797 \ Step along y for line, goes down and to right
 395+ E705              ;A4 35                   LDY &35		\ Y1
 396+ E705              ;98                      TYA
 397+ E705              ;A6 34                   LDX &34		\ X1
 398+ E705              ;C4 37                   CPY &37		\ Y2
 399+ E705              ;B0 10                   BCS LI15	\ skip swap if Y1 >= Y2
 400+ E705              ;C6 90                   DEC &90		\ SWAP
 401+ E705              ;A5 36                   LDA &36		\ X2
 402+ E705              ;85 34                   STA &34		\ X1
 403+ E705              ;86 36                   STX &36		\ X2
 404+ E705              ;AA                      TAX
 405+ E705              ;A5 37                   LDA &37		\ Y2
 406+ E705              ;85 35                   STA &35		\ Y1
 407+ E705              ;84 37                   STY &37		\ Y2
 408+ E705              ;A8                      TAY
 409+ E705              ;.LI15	\ Y1 Y2 order is now correct
 410+ E705              ;4A                      LSR A
 411+ E705              ;4A                      LSR A
 412+ E705              ;4A                      LSR A
 413+ E705              ;09 60                   ORA #&60
 414+ E705              ;85 08                   STA &08	 \ SC+1	\ screen hi
 415+ E705              ;8A                      TXA 		\ X1
 416+ E705              ;29 F8                   AND #&F8
 417+ E705              ;85 07                   STA &07	  \ SC	\ screen lo
 418+ E705              ;8A                      TXA
 419+ E705              ;29 07                   AND #7		\ mask index
 420+ E705              ;AA                      TAX
 421+ E705              ;BD AF 16                LDA &16AF,X \ TWOS,X \ Mode4 single pixel
 422+ E705              ;85 82                   STA &82	    \ R	\ mask
 423+ E705              ;A5 35                   LDA &35		\ Y1
 424+ E705              ;29 07                   AND #7
 425+ E705              ;A8                      TAY
 426+ E705              ;A5 1B                   LDA &1B	    \ P	\ delta-X
 427+ E705              ;A2 01                   LDX #1		\ roll counter
 428+ E705              ;86 1B                   STX &1B	    	\ P
 429+ E705              ;.LIL4	\ roll P
 430+ E705              ;0A                      ASL A
 431+ E705              ;B0 04                   BCS LI13	\ do subtraction
 432+ E705              ;C5 81                   CMP &81	    \ Q	\ delta-Y
 433+ E705              ;90 03                   BCC LI14	\ less than Q
 434+ E705              ;.LI13	\ do subtraction
 435+ E705              ;E5 81                   SBC &81		\ Q
 436+ E705              ;38                      SEC
 437+ E705              ;.LI14	\ less than Q
 438+ E705              ;26 1B                   ROL &1B		\ P
 439+ E705              ;90 F2                   BCC LIL4	\ loop P, end with some low bits in P
 440+ E705              ;A6 81                   LDX &81		\ Q
 441+ E705              ;E8                      INX 		\ adjust height
 442+ E705              ;A5 36                   LDA &36		\ X2
 443+ E705              ;E5 34                   SBC &34		\ X1
 444+ E705              ;90 2D                   BCC LFT		\ if C cleared then line moving to the left - hop down
 445+ E705              ;18                      CLC
 446+ E705              ;A5 90                   LDA &90		\ SWAP
 447+ E705              ;F0 07                   BEQ LI17 	\ skip first point
 448+ E705              ;CA                      DEX
 449+ E705              ;.LIL5	\ skipped first point, counter X
 450+ E705              ;A5 82                   LDA &82	    \ R \ mask byte
 451+ E705              ;51 07                   EOR (&07),Y	\ (SC),Y
 452+ E705              ;91 07                   STA (&07),Y	\ (SC),Y
 453+ E705              ;.LI17	\ skipped first point
 454+ E705              ;88                      DEY
 455+ E705              ;10 04                   BPL LI16	\ skip hi adjust
 456+ E705              ;C6 08                   DEC &08		\ SC+1
 457+ E705              ;A0 07                   LDY #7		\ new char
 458+ E705              ;	.LI16	\ skipped hi adjust
 459+ E705              ;A5 83                   LDA &83		\ S
 460+ E705              ;65 1B                   ADC &1B		\ P
 461+ E705              ;85 83                   STA &83		\ S
 462+ E705              ;90 0C                   BCC LIC5	\ skip, still in same column
 463+ E705              ;46 82                   LSR &82	  \ R	\ mask
 464+ E705              ;90 08                   BCC LIC5  	\ no mask bit hop
 465+ E705              ;66 82                   ROR &82   \ R	\ else moved over to next column, reset mask
 466+ E705              ;A5 07                   LDA &07	  \ SC  \ screen lo
 467+ E705              ;69 08                   ADC #8		\ next char below
 468+ E705              ;85 07                   STA &07		\ SC
 469+ E705              ;.LIC5	\ same column
 470+ E705              ;CA                      DEX
 471+ E705              ;D0 DC                   BNE LIL5	\ loop X height
 472+ E705              ;A4 85                   LDY &85	 \ YSAV	\ restore Yreg
 473+ E705              ;60                      RTS
 474+ E705              ;
 475+ E705              ;.LFT	\ going left
 476+ E705              ;A5 90                   LDA &90		\ SWAP
 477+ E705              ;F0 07                   BEQ LI18	\ skip first point
 478+ E705              ;CA                      DEX 		\ reduce height
 479+ E705              ;.LIL6	\ counter X height
 480+ E705              ;A5 82                   LDA &82	   \ R	\ mask byte
 481+ E705              ;51 07                   EOR (&07),Y	\ (SC),Y
 482+ E705              ;91 07                   STA (&07),Y	\ (SC),Y
 483+ E705              ;.LI18
 484+ E705              ;88                      DEY
 485+ E705              ;10 04                   BPL LI19	\ skip hi adjust
 486+ E705              ;C6 08                   DEC &08		\ SC+1
 487+ E705              ;A0 07                   LDY #7		\ rest char row
 488+ E705              ;.LI19	\ skipped hi adjust
 489+ E705              ;A5 83                   LDA &83		\ S
 490+ E705              ;65 1B                   ADC &1B	    \ P \ some low bits
 491+ E705              ;85 83                   STA &83		\ S
 492+ E705              ;90 0D                   BCC LIC6	\ no overflow
 493+ E705              ;06 82                   ASL &82	    \ R \ else move byte mask to the left
 494+ E705              ;90 09                   BCC LIC6	\ no overflow
 495+ E705              ;26 82                   ROL &82		\ R
 496+ E705              ;A5 07                   LDA &07		\ SC
 497+ E705              ;E9 07                   SBC #7		\ down 1 char
 498+ E705              ;85 07                   STA &07		\ SC
 499+ E705              ;18                      CLC
 500+ E705              ;.LIC6	\ no overflow
 501+ E705              ;CA                      DEX 		\ height
 502+ E705              ;D0 DB                   BNE LIL6	\ loop X
 503+ E705              ;A4 85                   LDY &85	 \ YSAV	\ restore Yreg
 504+ E705              ;.HL6
 505+ E705              ;60                      RTS 		\ end Line drawing
 506+ E705
 507+ E705
 508+ E705              ;;l2_draw_diagonalopt:
 509+ E705              	; ">TODO l2_draw_diagonalopt fast horz vert optmisation"
 510+ E705              ;;	push	af
 511+ E705              ;;	ld		a,b
 512+ E705              ;;	cp		d
 513+ E705              ;;	jr		z,.RegularDiagnonal
 514+ E705              ;;.CheckHorz:
 515+ E705              ;;	ld		a,c
 516+ E705              ;;	cp		e
 517+ E705              ;;	jr		z,.horizontalLine
 518+ E705              ;;.RegularDiagnonal:
 519+ E705              ;;	pop		af
 520+ E705              ;;	call diag
 521+ E705
 522+ E705
 523+ E705              ;;l2_signed_mul2a:
 524+ E705              ;;; ">l2_signed_mul2a - Signed a = a * 2 using shift)"
 525+ E705              ;;	TEST	$80
 526+ E705              ;;	jr		nz, .negativecalc
 527+ E705              ;;.positivecalc:
 528+ E705              ;;	ccf
 529+ E705              ;;	rla
 530+ E705              ;;	ret
 531+ E705              ;;.negativecalc:
 532+ E705              ;;	neg
 533+ E705              ;;	ccf
 534+ E705              ;;	rla
 535+ E705              ;;	neg
 536+ E705              ;;	ret
 537+ E705              ;;
 538+ E705              ;;l2_signed_mul2atohl:
 539+ E705              ;;; ">l2_signed_mul2ahl - Signed hl = a * 2 using shift)"
 540+ E705              ;;	TEST	$80
 541+ E705              ;;	jr		nz, .negativecalc
 542+ E705              ;;.positivecalc:
 543+ E705              ;;	ld		hl,0
 544+ E705              ;;	ld		l,a
 545+ E705              ;;	add		hl,a
 546+ E705              ;;	ret
 547+ E705              ;;.negativecalc:
 548+ E705              ;;	neg
 549+ E705              ;;	ld		hl,0
 550+ E705              ;;	ld		l,a
 551+ E705              ;;	neghl
 552+ E705              ;;	ret
 553+ E705              ;;
 554+ E705              ;;l2_e2fractionby2:
 555+ E705              ;;	ld 		hl,(l2fraction)
 556+ E705              ;;	push	de
 557+ E705              ;;	ld		d,h
 558+ E705              ;;	ld		e,l
 559+ E705              ;;	add		hl,de
 560+ E705              ;;	pop		de
 561+ E705              ;;	ld		(l2e2),hl
 562+ E705              ;;	ret
 563+ E705
 564+ E705
 565+ E705
 566+ E705
 567+ E705
 568+ E705              ;;//	ld		(l2linecolor),a   			; could do an ex but it will be needed multiple times between many uses of a reg
 569+ E705              ;;//.catchLoop:
 570+ E705              ;;//	jp .catchLoop
 571+ E705              ;;//.continue:
 572+ E705              ;;//    ld      A,D
 573+ E705              ;;//    sub     H
 574+ E705              ;;//    jr      NC,.DXpositive    ;delta_x > 0
 575+ E705              ;;//.DXNegative:
 576+ E705              ;;//    neg
 577+ E705              ;;//.DXPositive:
 578+ E705              ;;//    ld      B,A              ;B <- |delta_x|
 579+ E705              ;;//    ld      A,E
 580+ E705              ;;//    sub     L
 581+ E705              ;;//    jr      NC,.DYpositive    ;delta_y > 0
 582+ E705              ;;//.DYNegative:
 583+ E705              ;;//    neg
 584+ E705              ;;//.DYPositive:
 585+ E705              ;;//    sub     B               ;|delta_y|
 586+ E705              ;;//	push	af
 587+ E705              ;;//	jr		c,.DeltaX
 588+ E705              ;;//.DeltaY
 589+ E705              ;;//	ld      A,H             			;if |delta_x| < |delta_y| then
 590+ E705              ;;//    ld      H,L             			;then values x and y are swapped
 591+ E705              ;;//    ld      L,A             			;so the loop will always be performed on the
 592+ E705              ;;//    ld      A,D             			;x value. A flag must be set to
 593+ E705              ;;//    ld      D,E             			;remind that data must be drawn (y,x)
 594+ E705              ;;//    ld      E,A             			;instead of (x,y)
 595+ E705              ;;//.DeltaX:
 596+ E705              ;;//	ld		a,d
 597+ E705              ;;//	sub		h
 598+ E705              ;;//	jr		nc,.TestDY					; x1 < x2
 599+ E705              ;;//.TestDX:
 600+ E705              ;;//	ex		de,hl
 601+ E705              ;;//.TestDY:
 602+ E705              ;;//	ld		a,e
 603+ E705              ;;//	sub		l
 604+ E705              ;;//    ld      A,$01
 605+ E705              ;;//    jr      NC,.StoreA
 606+ E705              ;;//    neg                     ;y1 > y2 : in case2 the 'y' variable
 607+ E705              ;;//.StoreA:
 608+ E705              ;;//        ld      (l2way),A
 609+ E705              ;;//.InitLine:
 610+ E705              ;;//        ld      B,H
 611+ E705              ;;//        ld      C,L
 612+ E705              ;;//        ld      A,E
 613+ E705              ;;//        sub     L
 614+ E705              ;;//        jr      NC,.EndInit
 615+ E705              ;;//        ld      A,L
 616+ E705              ;;//        ld      L,E
 617+ E705              ;;//        ld      E,A
 618+ E705              ;;//.EndInit:
 619+ E705              ;;//        ld      A,E
 620+ E705              ;;//        sub     L
 621+ E705              ;;//        rla
 622+ E705              ;;//        ld      L,A             ;value to add in case1 (d < 0)
 623+ E705              ;;//        add     A,H
 624+ E705              ;;//        sub     D
 625+ E705              ;;//        ld      E,A             ;'d' variable is initialised
 626+ E705              ;;//        add     A,H
 627+ E705              ;;//        sub     D
 628+ E705              ;;//        ld      H,A             ;value to add in case2 (d >= 0)
 629+ E705              ;;//.Loop:
 630+ E705              ;;//        ld      A,B
 631+ E705              ;;//        sub     D
 632+ E705              ;;//        jr      NC,.EndLine       ;the line is completely drawn.
 633+ E705              ;;//        pop     AF
 634+ E705              ;;//        bit     7,A
 635+ E705              ;;//        push    AF
 636+ E705              ;;//        push    AF
 637+ E705              ;;//        push    BC
 638+ E705              ;;//        jr      Z,.DrawPoint
 639+ E705              ;;//        ld      A,B
 640+ E705              ;;//        ld      B,C
 641+ E705              ;;//        ld      C,A
 642+ E705              ;;//.DrawPoint:
 643+ E705              ;;//		push	hl
 644+ E705              ;;//		pushbcdeaf
 645+ E705              ;;//		ld		b,e
 646+ E705              ;;//		ld		c,d
 647+ E705              ;;//	ld 		a,(l2linecolor)
 648+ E705              ;;//	call	l2_plot_pixel
 649+ E705              ;;//		popafdebc
 650+ E705              ;;//		pop		hl
 651+ E705              ;;//        pop     BC
 652+ E705              ;;//        pop     AF
 653+ E705              ;;//.TestD:
 654+ E705              ;;//        bit     7,E
 655+ E705              ;;//        jr      NZ,.Case1
 656+ E705              ;;//.Case2:                          ;d >= 0
 657+ E705              ;;//        ld      A,E
 658+ E705              ;;//        add     A,H
 659+ E705              ;;//        ld      E,A
 660+ E705              ;;//        ld      A,(l2way)
 661+ E705              ;;//        add     A,C
 662+ E705              ;;//        ld      C,A
 663+ E705              ;;//        jr      .EndLoop
 664+ E705              ;;//.Case1:                          ;d < 0
 665+ E705              ;;//        ld      A,E
 666+ E705              ;;//        add     A,L
 667+ E705              ;;//        ld      E,A
 668+ E705              ;;//.EndLoop:
 669+ E705              ;;//        inc     B
 670+ E705              ;;//        jr      .Loop
 671+ E705              ;;//.EndLine:
 672+ E705              ;;//        pop     AF              ;MUST NOT BE REMOVED
 673+ E705              ;;//        pop     HL              ;can be removed
 674+ E705              ;;//        pop     DE              ;can be removed
 675+ E705              ;;//        ret
 676+ E705
 677+ E705              ;;	ld		(.l2yadjust),a
 678+ E705              ;;	call	calcdeltax:
 679+ E705              ;;	ld		(.l2xadjust),a
 680+ E705              ;;.calcfraction:							; err(or fraction) = dx+dy;
 681+ E705              ;;	push	hl
 682+ E705              ;;	push	de
 683+ E705              ;;	ld		hl,(l2deltaX)
 684+ E705              ;;	ld		de,(l2deltaY)
 685+ E705              ;;	add		hl,de
 686+ E705              ;;	ld		(l2fraction),hl
 687+ E705              ;;	pop		de
 688+ E705              ;;	pop		hl
 689+ E705              ;;.mainloop:
 690+ E705              ;;	push	bc
 691+ E705              ;;	push	de
 692+ E705              ;;	ld 		a,(l2linecolor)
 693+ E705              ;;	call	l2_plot_pixel
 694+ E705              ;;	pop		de
 695+ E705              ;;	pop		bc
 696+ E705              ;;.arewefinishedtest
 697+ E705              ;;	ld		a,b
 698+ E705              ;;	cp		d
 699+ E705              ;;	jr		nz,.notthereyet
 700+ E705              ;;	ld		a,c
 701+ E705              ;;	cp		e
 702+ E705              ;;	ret		z
 703+ E705              ;;.notthereyet:
 704+ E705              ;;	push	de
 705+ E705              ;;	call	l2_e2fractionby2			; e2 = 2*err;
 706+ E705              ;;	pop		de
 707+ E705              ;;.e2dytest:								; if (e2 >= dy) /* e_xy+e_x > 0 */  then S and P/V are the same
 708+ E705              ;;	push	de							; so if m & pe  or p & po calc (m = sign set p = 0)
 709+ E705              ;;	ld		de,(l2deltaY)				;    if m & po  or p & pe skip  (pe = pv set po = pv 0)
 710+ E705              ;;	or		a							;
 711+ E705              ;;	sbc		hl,de						;
 712+ E705              ;;	pop		de
 713+ E705              ;;	jr		z,  .dodycalc				; if equal then calc
 714+ E705              ;;	jp		p,	.dodycalc				; sign clear to H>D even with negtives
 715+ E705              ;;	jr		.skipdycalc         		; sign = 0     so  skip as pe
 716+ E705              ;;.dodycalc:
 717+ E705              ;;	ld		hl,(l2fraction)
 718+ E705              ;;	push	de
 719+ E705              ;;	ld		de,(l2deltaY)
 720+ E705              ;;	add		hl,de
 721+ E705              ;;	ld		(l2fraction),de
 722+ E705              ;;	pop		de
 723+ E705              ;;.l2yadjust:
 724+ E705              ;;	nop
 725+ E705              ;;.skipdycalc:
 726+ E705              ;;.e2dxtest:								;  if (e2 <= dx) /* e_xy+e_y < 0 */ then S and P/V are different.
 727+ E705              ;;	ld		hl,(l2e2)
 728+ E705              ;;	push	de							;
 729+ E705              ;;	ld		de,(l2deltaX)				;
 730+ E705              ;;	or		a							; clear carry flag
 731+ E705              ;;	sbc		hl,de						; hl = hl - de is if de > hl will get pv and signed different?
 732+ E705              ;;	pop		de
 733+ E705              ;;	jr		z,.dodxcalc					; e2 == dx so do calc
 734+ E705              ;;	jp		m,.dodxcalc					; was sign bit set
 735+ E705              ;;	jr		.skipdxcalc         	    ; diff so skip ; pvclear = po        pvset = pe
 736+ E705              ;;.dodxcalc:
 737+ E705              ;;	ld		hl,(l2fraction)
 738+ E705              ;;	push	de
 739+ E705              ;;	ld		de,(l2deltaX)
 740+ E705              ;;	add		hl,de
 741+ E705              ;;	ld		(l2fraction),de
 742+ E705              ;;	pop		de
 743+ E705              ;;.l2xadjust:
 744+ E705              ;;	nop
 745+ E705              ;;.skipdxcalc:
 746+ E705              ;;	jr 		.mainloop
 747+ E705
 748+ E705
 749+ E705              ;;/l2_draw_diagonalold:
 750+ E705              ;;/MESSAGE ">l2_draw_diagonal, bc = y0,x0 de=y1,x1,a=color)"
 751+ E705              ;;/	ld		(l2linecolor),a   			; could do an ex but it will be needed multiple times between many uses of a reg
 752+ E705              ;;/.sortycoords:
 753+ E705              ;;/	ld		a,b							; Sort to Y0 is always > y1 so we don't have to deal with step y and only step x
 754+ E705              ;;/	cp		d
 755+ E705              ;;/	jr		nc, .nocoordswap
 756+ E705              ;;/.swapcoords:
 757+ E705              ;;/	ex		de,hl						; save de to hl ! effective code line 98 after macros
 758+ E705              ;;/	lddebc
 759+ E705              ;;/	ldbchl
 760+ E705              ;;/.nocoordswap:
 761+ E705              ;;/	ld		a,d							; l2_dy = -ABS(l2_vy1 - l2_vy0)
 762+ E705              ;;/	sub		b							; we have already sorted  so y1 > y0
 763+ E705              ;;/	ld		(l2deltaY),a
 764+ E705              ;;/	neg									; DEBUG
 765+ E705              ;;/	ld		(l2deltaYn),a				; DEBUG
 766+ E705              ;;/	neg									; DEBUG
 767+ E705              ;;/.deltaxequABSx0Minusx1:						; we need to set l2dx to abs x1-x0 and set
 768+ E705              ;;/    ld		a,c
 769+ E705              ;;/	cp		e
 770+ E705              ;;/	jr		c, .x1GTx0
 771+ E705              ;;/.x1LTx0
 772+ E705              ;;/	ld		a,c
 773+ E705              ;;/	sub		e
 774+ E705              ;;/	ld		(l2deltaX),a				; just 8 bit for now should it be 16?
 775+ E705              ;;/	neg									; DEBUG
 776+ E705              ;;/	ld		(l2deltaXn),a				; DEBUG
 777+ E705              ;;/	neg									; DEBUG
 778+ E705              ;;/	ld		a,l2incbstep
 779+ E705              ;;/	jr		.setlayershift0
 780+ E705              ;;/.x1GTx0:
 781+ E705              ;;/	ld		a,e
 782+ E705              ;;/	sub		c
 783+ E705              ;;/	ld		(l2deltaX),a					; just 8 bit for now should it be 16?
 784+ E705              ;;/	neg									; DEBUG
 785+ E705              ;;/	ld		(l2deltaXn),a				; DEBUG
 786+ E705              ;;/	neg									; DEBUG
 787+ E705              ;;/	ld		a,l2decbstep
 788+ E705              ;;/.setlayershift0:
 789+ E705              ;;/	ld		a,0
 790+ E705              ;;/	pushbcde
 791+ E705              ;;/	call	asm_l2_bank_n_select		; l2_layer_shift = 0 and bank 0 selected
 792+ E705              ;;/	popdebc
 793+ E705              ;;/; so now we have set inc or dec instruction, l2dy, l2dx and on bank 0,
 794+ E705              ;;/.dymuliplyby2:
 795+ E705              ;;/	ld		a, (l2deltaY)				; dy *= 2
 796+ E705              ;;/	call	l2_signed_mul2a
 797+ E705              ;;/	ld		(l2deltaYsq),a
 798+ E705              ;;/	neg									; DEBUG
 799+ E705              ;;/	ld		(l2deltaYsqn),a				; DEBUG
 800+ E705              ;;/	neg									; DEBUG
 801+ E705              ;;/.dxmuliplyby2:
 802+ E705              ;;/	ld		a, (l2deltaX)				; dx *= 2
 803+ E705              ;;/	call	l2_signed_mul2a
 804+ E705              ;;/	ld		(l2deltaXsq),a
 805+ E705              ;;/	neg									; DEBUG
 806+ E705              ;;/	ld		(l2deltaXsqn),a				; DEBUG
 807+ E705              ;;/	neg									; DEBUG
 808+ E705              ;;/.plotfirstpixel:
 809+ E705              ;;/	pushbcde
 810+ E705              ;;/	ld a,(l2linecolor)
 811+ E705              ;;/	call	l2_plot_pixel
 812+ E705              ;;/	popdebc
 813+ E705              ;;/.mainloop:								; if (l2_dx > l2_dy) signed
 814+ E705              ;;/	ld		a,(l2deltaX)				;If A < N, then S and P/V are different.
 815+ E705              ;;/	ld		hl,l2deltaY					;A >= N, then S and P/V are the same
 816+ E705              ;;/	cp		(hl)
 817+ E705              ;;/	jp		m,	.signset
 818+ E705              ;;/.signclear:
 819+ E705              ;;/	jp		pe,	.dxLTEdybranch
 820+ E705              ;;/	jr		.dxGTdybranch
 821+ E705              ;;/.signset:
 822+ E705              ;;/	jp		po,	.dxLTEdybranch
 823+ E705              ;;/.dxGTdybranch:
 824+ E705              ;;/	ld		a,(l2deltaYsq)
 825+ E705              ;;/	ld		hl,l2deltaX
 826+ E705              ;;/	sub		(hl)
 827+ E705              ;;/	ld		(l2fraction),a				; faction = dy - 1/2 dx
 828+ E705              ;;/.BranchAwhile							; while (l2_vx0 != l2_vx1)
 829+ E705              ;;/	ld		a,c
 830+ E705              ;;/	cp		e
 831+ E705              ;;/	ret		z							; if x0 = x1 then done
 832+ E705              ;;/.BranchAtestfraction:					; if (l2_fraction >= 0)
 833+ E705              ;;/	ld		a,(l2fraction)
 834+ E705              ;;/	TEST	$80
 835+ E705              ;;/	jr		nz,.BranchAskipYstep
 836+ E705              ;;/	inc		b							; 		++l2_vy0;
 837+ E705              ;;/	ld		hl,l2deltaXsq
 838+ E705              ;;/	sub		(hl)						; 		l2_fraction -= l2_dx;
 839+ E705              ;;/	ld		(l2fraction),a
 840+ E705              ;;/.BranchAskipYstep:
 841+ E705              ;;/.l2stepx1:
 842+ E705              ;;/	inc		b							; this is self modifying code point 1 l2_vx0 += l2_stepx
 843+ E705              ;;/	ld		a,(l2fraction)				; l2_fraction += l2_dy can optimise later as a already has this?
 844+ E705              ;;/	ld		hl,l2deltaYsq
 845+ E705              ;;/	add		a,(hl)
 846+ E705              ;;/	ld		(l2fraction),a
 847+ E705              ;;/.BranchAplotBCColA:						; l2_plot_pixel(l2_vx0,l2_vy0,color);
 848+ E705              ;;/	pushbcde
 849+ E705              ;;/	ld a,(l2linecolor)
 850+ E705              ;;/	call	l2_plot_pixel
 851+ E705              ;;/	popdebc
 852+ E705              ;;/.BranchAloop:
 853+ E705              ;;/	jr		.BranchAwhile
 854+ E705              ;;/.dxLTEdybranch:
 855+ E705              ;;/	ld		a,(l2deltaXsq)				; l2_fraction = l2_dx - (l2_dy >> 1);
 856+ E705              ;;/	ld		hl, l2deltaY
 857+ E705              ;;/	sub		(hl)
 858+ E705              ;;/	ld		(l2fraction),a				; faction = dy - 1/2 d
 859+ E705              ;;/.BranchBwhile:							; while (l2_vy0 != l2_vy1)
 860+ E705              ;;/	ld		a,b
 861+ E705              ;;/	cp		d
 862+ E705              ;;/	ret		z							; if x0 = x1 then done
 863+ E705              ;;/.BranchBtestfraction:					; if (l2_fraction >= 0)
 864+ E705              ;;/	ld		a,(l2fraction)
 865+ E705              ;;/	TEST	$80
 866+ E705              ;;/	jr		nz,.BranchBskipYstep
 867+ E705              ;;/.l2stepx2
 868+ E705              ;;/	inc		b							; l2_vx0 += l2_stepx; this is self modifying code point 2
 869+ E705              ;;/	ld		a,(l2fraction)				; l2_fraction -= l2_dy
 870+ E705              ;;/	ld		hl,l2deltaYsq
 871+ E705              ;;/	sub		(hl)
 872+ E705              ;;/	ld		(l2fraction),a
 873+ E705              ;;/.BranchBskipYstep:
 874+ E705              ;;/	ld		hl, l2deltaYsq
 875+ E705              ;;/	add		a,(hl)
 876+ E705              ;;/	ld		(l2fraction),a
 877+ E705              ;;/	inc		b							; ++l2_vy0;
 878+ E705              ;;/.BranchBplotBCColA:
 879+ E705              ;;/	pushbcde
 880+ E705              ;;/	ld a,(l2linecolor)
 881+ E705              ;;/	call	l2_plot_pixel
 882+ E705              ;;/	popdebc
 883+ E705              ;;/.BranchBloop:
 884+ E705              ;;/	jr		.BranchBwhile
 885+ E705
# file closed: ./Layer2Graphics/layer2_plot_diagonal.asm
 272  E705                  INCLUDE "./Layer2Graphics/asm_l2_plot_triangle.asm"
# file opened: ./Layer2Graphics/asm_l2_plot_triangle.asm
   1+ E705
   2+ E705
   3+ E705
   4+ E705 00 00        l2trianglebc	        DW 0
   5+ E707 00 00        l2trianglede	        DW 0
   6+ E709 00 00        l2trianglehl	        DW 0
   7+ E70B
   8+ E70B              ; "l2_draw_triangle, BC = y1x1, DE=y2x2, HL=y3x3 a = Color"
   9+ E70B C5 D5 E5 F5  l2_draw_triangle:       push	bc,,de,,hl,,af
  10+ E70F CD 33 E6                             call	l2_draw_diagonal		; BC to DE
  11+ E712 F1                                   pop		af
  12+ E713 D1                                   pop		de						; swap DE and HL
  13+ E714 E1                                   pop		hl						; so BC to DE is really to HL
  14+ E715 C1                                   pop		bc
  15+ E716 D5 E5                                push    de,,hl                    ; which is pushing original hl then original de
  16+ E718 F5                                   push	af
  17+ E719 CD 33 E6                             call	l2_draw_diagonal		; BC to HL (leaving DE and HL swapped)
  18+ E71C F1                                   pop		af
  19+ E71D C1                                   pop		bc						; Now bc = original de
  20+ E71E D1                                   pop		de						; de = original hl
  21+ E71F CD 33 E6                             call	l2_draw_diagonal		; BC to HL (leaving DE and HL swapped)
  22+ E722 C9                                   ret
  23+ E723
  24+ E723
  25+ E723
  26+ E723
  27+ E723
# file closed: ./Layer2Graphics/asm_l2_plot_triangle.asm
 273  E723                  INCLUDE "./Layer2Graphics/asm_l2_fill_triangle.asm"
# file opened: ./Layer2Graphics/asm_l2_fill_triangle.asm
   1+ E723              ; ">l2_fillBottomFlatTriangle BC y0x0 DE x1x2, H YCommon, L Colour"
   2+ E723              ; "note >l2_draw_diagonal_save, bc = y0,x0 de=y1,x1,a=array nbr ESOURCE LL30 or LION"
   3+ E723              ; "note line to   bc = left side row,col, d right pixel, e = color"
   4+ E723 DD 01        l2_fillBottomFlatTriangle:break
   5+ E725 7D                                   ld		a,l
   6+ E726 32 4C E3                             ld		(l2linecolor),a
   7+ E729 79                                   ld		a,c
   8+ E72A BB                                   cp		e
   9+ E72B 30 08                                jr		nc, .x2gtex1
  10+ E72D DD 26 01     .x1ltx2:                ld		ixh,1                           ; list 1 holds x0 down to x1
  11+ E730 DD 2E 02                             ld		ixl,2                           ; list 2 hols  x0 down to x2
  12+ E733 18 06                                jr		.storepoints
  13+ E735 DD 26 02     .x2gtex1:               ld		ixh,2
  14+ E738 DD 2E 01                             ld		ixl,1
  15+ E73B C5 D5 E5     .storepoints:           push	bc,,de,,hl
  16+ E73E DD 7C                                ld		a,ixh
  17+ E740 5A                                   ld		e,d                             ; we alreay have bc so its now bc -> hd
  18+ E741 54                                   ld		d,h
  19+ E742 CD 54 E5                             call	l2_draw_diagonal_save			;l2_store_diagonal(x0,y0,x1,ycommon,l2_LineMinX);
  20+ E745 E1 D1 C1                             pop		bc,,de,,hl
  21+ E748 C5 E5                                push	bc,,hl
  22+ E74A 54                                   ld		d,h                             ; now its bc -> he
  23+ E74B DD 7D                                ld		a,ixl
  24+ E74D CD 54 E5                             call	l2_draw_diagonal_save			;l2_store_diagonal(x0,y0,x2,ycommon,l2_LineMaxX);
  25+ E750 E1 C1                                pop		bc,,hl
  26+ E752 50           .SaveForLoop:           ld		d,b
  27+ E753 5C                                   ld		e,h								; save loop counters
  28+ E754 D5                                   push	de								; de = y0ycommon
  29+ E755 21 54 E3     .GetFirstHorizontalRow:	ld		hl,l2targetArray1               ; get first row for loop
  30+ E758 78                                   ld		a,b
  31+ E759 ED 31                                add		hl,a							; hl = l2targetArray1 row b
  32+ E75B 7E                                   ld		a,(hl)							;
  33+ E75C 4F                                   ld		c,a								; c = col1 i.e. l2targetarray1[b]
  34+ E75D 21 54 E4                             ld      hl,l2targetArray2
  35+ E760 78                                   ld      a,b
  36+ E761 ED 31                                add     hl,a
  37+ E763              ;                        inc		h								; hl = l2targetArray2 row b if we interleave
  38+ E763 7E                                   ld		a,(hl)
  39+ E764 57                                   ld		d,a								; d = col2 i.e. l2targetarray2[b]
  40+ E765 3A 4C E3     .SetColour:             ld		a,(l2linecolor)
  41+ E768 5F                                   ld		e,a								; de = to colour
  42+ E769 C5           .SavePoints:            push	bc								; bc = rowcol
  43+ E76A 25                                   dec		h
  44+ E76B E5                                   push	hl								; hl = l2targetArray1[b]
  45+ E76C CD B6 E2     .DoLine:	            call	l2_draw_horz_line_to
  46+ E76F E1                                   pop		hl
  47+ E770 C1                                   pop		bc
  48+ E771 04                                   inc		b								; down a rowc
  49+ E772 D1                                   pop		de								; de = from to (and b also = current)
  50+ E773 14                                   inc		d
  51+ E774 7B                                   ld		a,e								; while e >= d
  52+ E775 BA                                   cp		d
  53+ E776 30 DA                                jr 		nc,.SaveForLoop					; Is this the right point??
  54+ E778 C9                                   ret
  55+ E779
# file closed: ./Layer2Graphics/asm_l2_fill_triangle.asm
 274  E779                  INCLUDE "./Layer2Graphics/layer2_plot_circle.asm"
# file opened: ./Layer2Graphics/layer2_plot_circle.asm
   1+ E779
   2+ E779 00 00        l2_circle_pos		DW 0
   3+ E77B 00           l2_circle_colour	DB 0
   4+ E77C 00           l2_circle_radius	DB 0
   5+ E77D 00           l2_circle_x			DB 0
   6+ E77E 00           l2_circle_y			DB 0
   7+ E77F 00           l2_circle_d			DB 0
   8+ E780
   9+ E780              ; ">l2_draw_circle BC = center row col, d = radius, e = colour"
  10+ E780 7B           l2_draw_circle:     ld		a,e
  11+ E781 32 27 E8                         ld		(.PlotPixel+1),a
  12+ E784 7A                               ld		a,d								; get radius
  13+ E785 A7                               and		a
  14+ E786 C8                               ret		z
  15+ E787 FE 01                            cp		1
  16+ E789 CA 32 E8                         jp		z,CircleSinglepixel
  17+ E78C ED 43 B6 E7                      ld		(.Plot1+1),bc					; save origin into DE reg in code
  18+ E790 DD 67                            ld		ixh,a							; ixh = raidus
  19+ E792 DD 2E 00                         ld		ixl,0
  20+ E795 26 00        .calcd:	            ld		h,0
  21+ E797 6F                               ld		l,a
  22+ E798 29                               add		hl,hl							; hl = r * 2
  23+ E799 EB                               ex		de,hl							; de = r * 2
  24+ E79A 21 03 00                         ld		hl,3
  25+ E79D A7                               and		a
  26+ E79E ED 52                            sbc		hl,de							; hl = 3 - (r * 2)
  27+ E7A0 44                               ld		b,h
  28+ E7A1 4D                               ld		c,l								; bc = 3 - (r * 2)
  29+ E7A2 21 01 00     .calcdelta:         ld		hl,1
  30+ E7A5 16 00                            ld		d,0
  31+ E7A7 DD 5D                            ld		e,ixl
  32+ E7A9 A7                               and		a
  33+ E7AA ED 52                            sbc		hl,de
  34+ E7AC 11 01 00     .Setde1:            ld		de,1
  35+ E7AF DD 7C        .CircleLoop:        ld		a,ixh
  36+ E7B1 DD BD                            cp		ixl
  37+ E7B3 D8                               ret		c
  38+ E7B4 D9           .ProcessLoop:	    exx
  39+ E7B5 11 00 00     .Plot1:             ld		de,0
  40+ E7B8 7B                               ld		a,e
  41+ E7B9 DD 85                            add		a,ixl
  42+ E7BB 4F                               ld		c,a
  43+ E7BC 7A                               ld		a,d
  44+ E7BD DD 84                            add		a,ixh
  45+ E7BF 47                               ld		b,a
  46+ E7C0 CD 26 E8                         call	.PlotPixel			;CX+X,CY+Y
  47+ E7C3 7B           .Plot2:             ld 		a,e
  48+ E7C4 DD 95                            sub 	ixl
  49+ E7C6 4F                               ld 		c,a
  50+ E7C7 7A                               ld 		a,d
  51+ E7C8 DD 84                            add 	a,ixh
  52+ E7CA 47                               ld		b,a
  53+ E7CB CD 26 E8                         call	.PlotPixel			;CX-X,CY+Y
  54+ E7CE 7B           .Plot3:             ld 		a,e
  55+ E7CF DD 85                            add		a,ixl
  56+ E7D1 4F                               ld 		c,a
  57+ E7D2 7A                               ld 		a,d
  58+ E7D3 DD 94                            sub 	ixh
  59+ E7D5 47                               ld 		b,a
  60+ E7D6 CD 26 E8                         call	.PlotPixel			;CX+X,CY-Y
  61+ E7D9 7B           .Plot4:             ld 		a,e
  62+ E7DA DD 95                            sub 	ixl
  63+ E7DC 4F                               ld 		c,a
  64+ E7DD 7A                               ld 		a,d
  65+ E7DE DD 94                            sub 	ixh
  66+ E7E0 47                               ld 		b,a
  67+ E7E1 CD 26 E8                         call	.PlotPixel			;CY+X,CX-Y
  68+ E7E4 7A           .Plot5:	            ld 		a,d
  69+ E7E5 DD 85                            add 	a,ixl
  70+ E7E7 47                               ld 		b,a
  71+ E7E8 7B                               ld 		a,e
  72+ E7E9 DD 84                            add 	a,ixh
  73+ E7EB 4F                               ld 		c,a
  74+ E7EC CD 26 E8                         call	.PlotPixel			;CY+X,CX+Y
  75+ E7EF 7A           .Plot6:	            ld 		a,d
  76+ E7F0 DD 95                            sub 	ixl
  77+ E7F2 47                               ld 		b,a
  78+ E7F3 7B                               ld 		a,e
  79+ E7F4 DD 84                            add 	a,ixh
  80+ E7F6 4F                               ld 		c,a
  81+ E7F7 CD 26 E8                         call	.PlotPixel			;CY-X,CX+Y
  82+ E7FA 7A           .Plot7:	            ld 		a,d
  83+ E7FB DD 85                            add 	a,ixl
  84+ E7FD 47                               ld 		b,a
  85+ E7FE 7B                               ld 		a,e
  86+ E7FF DD 94                            sub 	ixh
  87+ E801 4F                               ld 		c,a
  88+ E802 CD 26 E8                         call	.PlotPixel			;CY+X,CX-Y
  89+ E805 7A           .Plot8:	            ld 		a,d
  90+ E806 DD 95                            sub 	ixl
  91+ E808 47                               ld		b,a
  92+ E809 7B                               ld 		a,e
  93+ E80A DD 94                            sub 	ixh
  94+ E80C 4F                               ld 		c,a
  95+ E80D CD 26 E8                         call	.PlotPixel			;CX+X,CY-Y
  96+ E810 D9                               exx
  97+ E811 CB 7C        .IncrementCircle:	bit     7,h				; Check for Hl<=0
  98+ E813 28 03                            jr z,   .draw_circle_1
  99+ E815 19                               add hl,de			; Delta=Delta+D1
 100+ E816 18 05                            jr      .draw_circle_2		;
 101+ E818 09           .draw_circle_1:		add     hl,bc			; Delta=Delta+D2
 102+ E819 03                               inc     bc
 103+ E81A 03                               inc     bc				; D2=D2+2
 104+ E81B DD 25                            dec     ixh				; Y=Y-1
 105+ E81D 03           .draw_circle_2:		inc bc				; D2=D2+2
 106+ E81E 03                               inc bc
 107+ E81F 13                               inc de				; D1=D1+2
 108+ E820 13                               inc de
 109+ E821 DD 2C                            inc ixl				; X=X+1
 110+ E823 C3 AF E7                         jp      .CircleLoop
 111+ E826 3E 00        .PlotPixel:         ld		a,0                  ; This was originally indirect, where as it neeed to be value
 112+ E828 D5 C5 E5                         push	de,,bc,,hl
 113+ E82B CD 43 E1                         call 	l2_plot_pixel_y_test
 114+ E82E E1 C1 D1                         pop		de,,bc,,hl
 115+ E831 C9                               ret
 116+ E832 7B           CircleSinglepixel:  ld		a,e
 117+ E833 CD 43 E1                         call	l2_plot_pixel_y_test
 118+ E836 C9                               ret
 119+ E837
# file closed: ./Layer2Graphics/layer2_plot_circle.asm
 275  E837                  INCLUDE "./Layer2Graphics/layer2_plot_circle_fill.asm"
# file opened: ./Layer2Graphics/layer2_plot_circle_fill.asm
   1+ E837
   2+ E837 00           l2_circle_dblx		DB 0
   3+ E838 00           l2_circle_dbly		DB 0
   4+ E839
   5+ E839              ; ">l2_draw_circle_fill BC = center row col, d = radius, e = colour"
   6+ E839              ; Note this code currently does not process BC
   7+ E839 7B           l2_draw_circle_fill:    ld		a,e
   8+ E83A 32 D0 E8                             ld		(.LineColour+1),a
   9+ E83D 7A                                   ld		a,d								; get radius
  10+ E83E A7                                   and		a
  11+ E83F C8                                   ret		z
  12+ E840 FE 01                                cp		1
  13+ E842 CA 32 E8                             jp		z,CircleSinglepixel
  14+ E845 ED 43 6F E8                          ld		(.Line1+1),bc					; save origin into DE reg in code
  15+ E849 DD 67                                ld		ixh,a							; ixh = raidus (x)
  16+ E84B DD 2E 00                             ld		ixl,0							; ihy = y
  17+ E84E 26 00        .calcd:	                ld		h,0
  18+ E850 6F                                   ld		l,a
  19+ E851 29                                   add		hl,hl							; hl = r * 2
  20+ E852 EB                                   ex		de,hl							; de = r * 2
  21+ E853 21 03 00                             ld		hl,3
  22+ E856 A7                                   and		a
  23+ E857 ED 52                                sbc		hl,de							; hl = 3 - (r * 2)
  24+ E859 44                                   ld		b,h
  25+ E85A 4D                                   ld		c,l								; bc = 3 - (r * 2)
  26+ E85B 21 01 00     .calcdelta              ld		hl,1
  27+ E85E 16 00                                ld		d,0
  28+ E860 DD 5D                                ld		e,ixl
  29+ E862 A7                                   and		a
  30+ E863 ED 52                                sbc		hl,de
  31+ E865 11 01 00     .Setde1	                ld		de,1
  32+ E868 DD 7C        .CircleLoop:            ld		a,ixh
  33+ E86A DD BD                                cp		ixl
  34+ E86C D8                                   ret		c
  35+ E86D D9           .ProcessLoop:	        exx
  36+ E86E 11 00 00     .Line1:                 ld		de,0
  37+ E871 7B                                   ld 		a,e
  38+ E872 DD 95                                sub 	ixl
  39+ E874 4F                                   ld 		c,a
  40+ E875 7A                                   ld 		a,d
  41+ E876 DD 84                                add 	a,ixh
  42+ E878 47                                   ld		b,a
  43+ E879                                      ;; TODO ADD DOUBLE X CALC
  44+ E879 D5                                   push	de
  45+ E87A DD 55                                ld		d,ixl
  46+ E87C CB 22                                sla		d
  47+ E87E CD CB E8                             call	.PlotLine			;CX-X,CY+Y
  48+ E881 D1                                   pop		de
  49+ E882 7B           .Line2:                 ld 		a,e
  50+ E883 DD 95                                sub		ixl
  51+ E885 4F                                   ld 		c,a
  52+ E886 7A                                   ld 		a,d
  53+ E887 DD 94                                sub 	ixh
  54+ E889 47                                   ld 		b,a
  55+ E88A                                      ;; TODO ADD DOUBLE X CALC
  56+ E88A D5                                   push	de
  57+ E88B DD 55                                ld		d,ixl
  58+ E88D CB 22                                sla		d
  59+ E88F CD CB E8                             call	.PlotLine			;CX-X,CY-Y
  60+ E892 D1                                   pop		de
  61+ E893 7B           .Line3:	                ld 		a,e
  62+ E894 DD 94                                sub		ixh
  63+ E896 4F                                   ld 		c,a
  64+ E897 7A                                   ld 		a,d
  65+ E898 DD 85                                add 	a,ixl
  66+ E89A 47                                   ld 		b,a
  67+ E89B                                      ;; TODO ADD DOUBLE Y CALC
  68+ E89B D5                                   push	de
  69+ E89C DD 54                                ld		d,ixh
  70+ E89E CB 22                                sla		d
  71+ E8A0 CD CB E8                             call	.PlotLine			;CX-Y,CY+x
  72+ E8A3 D1                                   pop		de
  73+ E8A4 7B           .Line4:	                ld 		a,e
  74+ E8A5 DD 94                                sub		ixh
  75+ E8A7 4F                                   ld 		c,a
  76+ E8A8 7A                                   ld 		a,d
  77+ E8A9 DD 95                                sub 	ixl
  78+ E8AB 47                                   ld 		b,a
  79+ E8AC                                      ;; TODO ADD DOUBLE Y CALC
  80+ E8AC D5                                   push	de
  81+ E8AD DD 54                                ld		d,ixh
  82+ E8AF CB 22                                sla		d
  83+ E8B1 CD CB E8                             call	.PlotLine			;CX-Y,CY+x
  84+ E8B4 D1                                   pop		de
  85+ E8B5 D9                                   exx
  86+ E8B6 CB 7C        .IncrementCircle:	    bit 7,h				; Check for Hl<=0
  87+ E8B8 28 03                                jr z,.draw_circle_1
  88+ E8BA 19                                   add hl,de			; Delta=Delta+D1
  89+ E8BB 18 05                                jr .draw_circle_2		;
  90+ E8BD 09           .draw_circle_1:		    add hl,bc			; Delta=Delta+D2
  91+ E8BE 03                                   inc bc
  92+ E8BF 03                                   inc bc				; D2=D2+2
  93+ E8C0 DD 25                                dec ixh				; Y=Y-1
  94+ E8C2 03           .draw_circle_2:		    inc bc				; D2=D2+2
  95+ E8C3 03                                   inc bc
  96+ E8C4 13                                   inc de				; D1=D1+2
  97+ E8C5 13                                   inc de
  98+ E8C6 DD 2C                                inc ixl				; X=X+1
  99+ E8C8 C3 68 E8                             jp .CircleLoop
 100+ E8CB D5 C5 E5 F5  .PlotLine:              push	de,,bc,,hl,,af
 101+ E8CF 3E 00        .LineColour:	        ld		a,0         ; circle colur
 102+ E8D1 5F                                   ld      e,a
 103+ E8D2 CD 8A E2                             call 	l2_draw_horz_line
 104+ E8D5 F1 E1 C1 D1                          pop     de,,bc,,hl,,af
 105+ E8D9 C9                                   ret
 106+ E8DA
# file closed: ./Layer2Graphics/layer2_plot_circle_fill.asm
 276  E8DA                  INCLUDE "./Layer2Graphics/l2_draw_any_line.asm"
# file opened: ./Layer2Graphics/l2_draw_any_line.asm
   1+ E8DA              ; ">l2_draw_any_line, bc = y0,x0 de=y1,x1,a=color: determines if its horizontal, vertical or diagonal then hands off the work"
   2+ E8DA 08           l2_draw_any_line:       ex		af,af'              ; save colour into a'
   3+ E8DB 79                                   ld		a,c                 ; if x and e are the same its horizontal
   4+ E8DC BB                                   cp		e
   5+ E8DD 28 08                                jr		z,.HorizontalLineCheck
   6+ E8DF 78                                   ld		a,b                 ; if b and d are the same its vertica;
   7+ E8E0 BA                                   cp		d
   8+ E8E1 28 0E                                jr		z,.VerticalLine
   9+ E8E3              ; use jp and get a free ret instruction optimisation
  10+ E8E3 08           .DiagonalLine:		    ex		af,af'			     ; get colour back into a
  11+ E8E4 C3 33 E6                             jp		l2_draw_diagonal
  12+ E8E7
  13+ E8E7 78           .HorizontalLineCheck:   ld      a,b
  14+ E8E8 BA                                   cp      d
  15+ E8E9 28 0B                                jr      z, .SinglePixel
  16+ E8EB 08           .HorizontalLine:        ex		af,af'              ; get colour back into a
  17+ E8EC 53                                   ld		d,e				    ; set d as target right pixel
  18+ E8ED 5F                                   ld		e,a				    ; e holds colour on this call
  19+ E8EE C3 B6 E2                             jp		l2_draw_horz_line_to
  20+ E8F1 08           .VerticalLine:          ex		af,af'
  21+ E8F2 5F                                   ld		e,a				    ; e holds colour on this call
  22+ E8F3 C3 35 E3                             jp		l2_draw_vert_line_to
  23+ E8F6 08           .SinglePixel:           ex		af,af'              ; get colour back into a
  24+ E8F7 C3 29 E1                             jp      l2_plot_pixel
  25+ E8FA              ;......................................................
  26+ E8FA
# file closed: ./Layer2Graphics/l2_draw_any_line.asm
 277  E8FA                  INCLUDE "./Layer2Graphics/l2_draw_line_v2.asm"
# file opened: ./Layer2Graphics/l2_draw_line_v2.asm
   1+ E8FA              ; ******************************************************************************
   2+ E8FA              ;
   3+ E8FA              ;	Draw a pixel line from (x0,y0) defined in (COORDS) - the current plot
   4+ E8FA              ;	coordinate, to the relative distance points (x0+x,y0+y).
   5+ E8FA              ;
   6+ E8FA              ;	Design & programming by Gunther Strube,	Copyright (C) InterLogic 1995
   7+ E8FA              ;
   8+ E8FA              ;	The (COORDS+0)	pointer contains the current y coordinate, (COORDS+1) the
   9+ E8FA              ;	current x coordinate. The main program should reset the (COORDS) variables
  10+ E8FA              ;	before using line drawing.
  11+ E8FA              ;
  12+ E8FA              ;	The routine checks the range of specified coordinates which is the
  13+ E8FA              ;	boundaries of the graphics area (256x64	pixels).
  14+ E8FA              ;	If a boundary error occurs the routine exits automatically.	This may be
  15+ E8FA              ;	useful if you are trying to draw a line longer than allowed. Only the
  16+ E8FA              ;	visible part will be drawn.
  17+ E8FA              ;
  18+ E8FA              ;	The hardware graphics memory is organized as (0,0) in the top left corner.
  19+ E8FA              ;
  20+ E8FA              ;	The plot routine is	defined by an address pointer	in IX.
  21+ E8FA              ;
  22+ E8FA              ;	IN:	HL =	move	relative x horisontal points (maximum +/- 255).
  23+ E8FA              ;		DE =	move	relative y vertical	points (maximum +/-	255).
  24+ E8FA              ;		IX =	pointer to plot routine that uses HL = (x,y)	of plot coordinate.
  25+ E8FA              ;
  26+ E8FA              ;	OUT:	None.
  27+ E8FA              ;
  28+ E8FA              ;	Registers	used	by routine:
  29+ E8FA              ;		   N	:	B, loop counter
  30+ E8FA              ;		   i	:	line	balance variable
  31+ E8FA              ;		   x	:	H/L,	horisontal, vertical distance	variables
  32+ E8FA              ;		   y	:	H/L,	horisontal, vertical distance	variables
  33+ E8FA              ;	  (x0,y0)	:	(h,l)
  34+ E8FA              ;	  direc_x	:	d, horisontal step increment
  35+ E8FA              ;	  direc_y	:	e, vertical step increment
  36+ E8FA              ;		 ddx	:	b, horisontal step increment
  37+ E8FA              ;		 ddy	:	c, vertical step increment
  38+ E8FA              ;
  39+ E8FA              ;		DE, A work registers.
  40+ E8FA              ;
  41+ E8FA              ; The algorithm in pseudo-code:
  42+ E8FA              ;
  43+ E8FA              ;	direc_x =	SGN x: direc_y	= SGN y
  44+ E8FA              ;	x = ABS x: y =	ABS y
  45+ E8FA              ;
  46+ E8FA              ;	if x	>= y
  47+ E8FA              ;		if x+y=0 then return
  48+ E8FA              ;		H = x
  49+ E8FA              ;		L = y
  50+ E8FA              ;		ddx = direc_x
  51+ E8FA              ;		ddy = 0
  52+ E8FA              ;	else
  53+ E8FA              ;		H = y
  54+ E8FA              ;		L = x
  55+ E8FA              ;		ddx = 0
  56+ E8FA              ;		ddy = direc_y
  57+ E8FA              ;	endif
  58+ E8FA              ;
  59+ E8FA              ;	B = H
  60+ E8FA              ;	i = INT(B/2)
  61+ E8FA              ;	FOR N=B TO 1 STEP -1
  62+ E8FA              ;		i = i + L
  63+ E8FA              ;		if i	< H
  64+ E8FA              ;			ix =	ddx
  65+ E8FA              ;			iy =	ddy
  66+ E8FA              ;		else
  67+ E8FA              ;			i = i - H
  68+ E8FA              ;			ix =	direc_x
  69+ E8FA              ;			iy =	direc_y
  70+ E8FA              ;		endif
  71+ E8FA              ;		x0 =	x0 +	ix
  72+ E8FA              ;		y0 =	y0 +	iy
  73+ E8FA              ;		plot	(x0,y0)
  74+ E8FA              ;	NEXT	N
  75+ E8FA              ;
  76+ E8FA              ;
  77+ E8FA              ;	Registers	changed after return:
  78+ E8FA              ;		..BCDEHL/IXIY/af......	same
  79+ E8FA              ;		AF....../..../..bcdehl	different
  80+ E8FA              ;
  81+ E8FA DF           line_gfx_colour db $DF
  82+ E8FB 00 00        line_gfx_coords	dw 0
  83+ E8FD              LineHLtoDE:
  84+ E8FD 7C           TestMaxY:               ld	a,h ; were h = y or l = y?
  85+ E8FE FE C0                                cp	192
  86+ E900 30 26                                jr	nc, exit_line		; y0	coordinate out	of range
  87+ E902 7A                                   ld	a,d
  88+ E903 FE C0                                cp	192
  89+ E905 30 21                                jr	nc, exit_line		; y1	coordinate out	of range
  90+ E907 22 FB E8                             ld	(line_gfx_coords),hl		; the starting	point is now default
  91+ E90A E5                                   push	hl
  92+ E90B D5                                   push	de
  93+ E90C 6C                                   ld	l,h				; L = x0
  94+ E90D 62                                   ld	h,d				; H = x1
  95+ E90E 7C           distanceX:		        ld	a,h
  96+ E90F 95                                   sub	l
  97+ E910 6F                                   ld	l,a
  98+ E911 26 00                                ld	h,0
  99+ E913 30 02                                jr	nc, distanceXDone
 100+ E915 26 FF                                ld	h,-1
 101+ E917 D1           distanceXDone:          pop	de
 102+ E918 E3                                   ex	(sp),hl			; L = y0
 103+ E919 63                                   ld	h,e				; H = y1
 104+ E91A 7C           distanceY:		        ld	a,h
 105+ E91B 95                                   sub	l
 106+ E91C 6F                                   ld	l,a
 107+ E91D 26 00                                ld	h,0
 108+ E91F 30 02                                jr	nc, distanceYDone
 109+ E921 26 FF                                ld	h,-1
 110+ E923 D1           distanceYDone:          pop	de
 111+ E924 EB                                   ex	de,hl			; h.dist.	= HL, v.dist. = DE
 112+ E925 CD 29 E9                             call	DrawLineRelative			; draw line...
 113+ E928 C9           exit_line:              ret
 114+ E929
 115+ E929              ; ***************************************************************************
 116+ E929              ;
 117+ E929              ;	IN:	HL =	move	relative x horisontal points (maximum +/- 255).
 118+ E929              ;		DE =	move	relative y vertical	points (maximum +/-	255).
 119+ E929              ;
 120+ E929              ; OUT: h - l distance in	HL
 121+ E929              ;
 122+ E929
 123+ E929 D5           DrawLineRelative:       push	de
 124+ E92A E5                                   push	hl
 125+ E92B D9                                   exx
 126+ E92C E1                                   pop	hl					; get relative	horisontal movement
 127+ E92D CD 98 E9                             call	sgn
 128+ E930 57                                   ld	d,a					; direc_x	= SGN(x) installed d = +/-1 for horizontal update
 129+ E931 CD A5 E9                             call	absValue
 130+ E934 45                                   ld	b,l					; x = ABS(x)
 131+ E935 E1           DrawLineGetVertRelative:pop	hl					; get relative	vertical movement
 132+ E936 CD 98 E9                             call	sgn
 133+ E939 5F                                   ld	e,a					; direc_y	= SGN(y) installed  = +/-1 for vertical update
 134+ E93A CD A5 E9                             call	absValue
 135+ E93D 4D                                   ld	c,l					; y = ABS(y) so now bc = dxdy
 136+ E93E              ; so by here BC = dx dy HL in increment/decrement x y
 137+ E93E C5                                   push	bc
 138+ E93F D9                                   exx
 139+ E940 E1                                   pop	hl					; H = absolute	x dist., L = absolute y distance
 140+ E941 7C                                   ld	a,h
 141+ E942 BD                                   cp	l
 142+ E943 38 0A                                jr	c, x_smaller_y		; if	x >=	y
 143+ E945 B4           areXandYZero:           or	h					;	if x+y = 0
 144+ E946 28 4F                                jr	z, exit_draw		;		return
 145+ E948 D9           y_lessorequal_x:        exx						;	else
 146+ E949 42                                   ld	b,d					;		ddx = direc_x
 147+ E94A 0E 00                                ld	c,0					;		ddy = 0
 148+ E94C D9                                   exx
 149+ E94D 18 08                                jr	init_drawloop		; else
 150+ E94F 7C           x_smaller_y:	        ld	a,h
 151+ E950 65                                   ld	h,l					;	H = y
 152+ E951 6F                                   ld	l,a					;	L = x
 153+ E952 D9                                   exx
 154+ E953 06 00                                ld	b,0					;	ddx = 0
 155+ E955 4B                                   ld	c,e					;	ddy = direc_y
 156+ E956 D9                                   exx
 157+ E957 44           init_drawloop:	        ld	b,h
 158+ E958 4C                                   ld	c,h					; B = H
 159+ E959 CB 39                                srl	c					; i = INT(B/2)
 160+ E95B              										; FOR N=B	TO 1	STEP	-1
 161+ E95B 79           drawloop:		        ld	a,c
 162+ E95C 85                                   add	a,l
 163+ E95D 38 09                                jr	c, i_greater		;	i + L > 255  (i > H)
 164+ E95F BC                                   cp	h
 165+ E960 30 06                                jr	nc, i_greater		;	if i	< H
 166+ E962 4F                                   ld	c,a					;		i = i + L
 167+ E963 D9                                   exx
 168+ E964 C5                                   push	bc				;		ix =	ddx:	iy =	ddy
 169+ E965 D9                                   exx
 170+ E966 18 05                                jr	check_plot			;	else
 171+ E968 94           i_greater:		        sub	h					;		i = i - H
 172+ E969 4F                                   ld	c,a
 173+ E96A D9                                   exx
 174+ E96B D5                                   push	de				;		ix =	direc_x: iy = direc_y
 175+ E96C D9                                   exx						;	endif
 176+ E96D E3           check_plot:		        ex	(sp),hl				;	preserve H,L distances on stack
 177+ E96E EB                                   ex	de,hl				;	D,E = ix,	iy
 178+ E96F 2A FB E8                             ld	hl,(line_gfx_coords)
 179+ E972 7D                                   ld	a,l
 180+ E973 83                                   add	a,e					;
 181+ E974 6F                                   ld	l,a					;	y0 =	y0 +	iy (y0 is	checked by plot)
 182+ E975 7A                                   ld	a,d
 183+ E976 3C                                   inc	a
 184+ E977 84                                   add	a,h
 185+ E978 38 04                                jr	c, check_range		;	check out	of range
 186+ E97A 28 1A                                jr	z, range_error		;	Fz=1	& Fc=0 denotes	x0 <	0
 187+ E97C 18 02                                jr	plot_point
 188+ E97E 20 16        check_range:            jr	nz, range_error	;	Fz=0	& Fc=1 denotes	x0 >	255
 189+ E980
 190+ E980 3D           plot_point:             dec	a
 191+ E981 C5                                   push	bc
 192+ E982 F5                                   push	af
 193+ E983 47                                   ld	    b,a					;	x0 =	x0 +	ix
 194+ E984 4D                                   ld		c,l
 195+ E985 3A FA E8                             ld		a,(line_gfx_colour)
 196+ E988 ED 43 FB E8                          ld      (line_gfx_coords),bc
 197+ E98C CD 29 E1                             call	l2_plot_pixel
 197+ E98F
 198+ E98F F1                                   pop		af
 199+ E990 C1                                   pop		bc
 200+ E991 E1           plot_RET:		        pop	hl					;	restore H,L distances...
 201+ E992 10 C7                                djnz	drawloop		; NEXT N
 202+ E994 18 01                                jr	exit_draw
 203+ E996
 204+ E996 E1           range_error:	        pop	hl					; remove H,L distances...
 205+ E997 C9           exit_draw:		        ret
 206+ E998
 207+ E998
 208+ E998              ; ******************************************************************************
 209+ E998              ;
 210+ E998              ;	SGN (Signum value) of 16	bit signed integer.
 211+ E998              ;
 212+ E998              ;	IN:		HL =	integer
 213+ E998              ;	OUT:		A = result: 0,1,-1 (if zero, positive, negative)
 214+ E998              ;
 215+ E998              ;	Registers	changed after return:
 216+ E998              ;	..BCDEHL/IXIY	same
 217+ E998              ;	AF....../....	different
 218+ E998              ;
 219+ E998 7C           sgn:				    ld	a,h
 220+ E999 B5                                   or	l
 221+ E99A C8                                   ret	z				; integer	is zero, return 0...
 222+ E99B CB 7C                                bit	7,h
 223+ E99D 20 03                                jr	nz, negative_int
 224+ E99F 3E 01                                ld	a,1
 225+ E9A1 C9                                   ret
 226+ E9A2 3E FF        negative_int:		    ld	a,-1
 227+ E9A4 C9                                   ret
 228+ E9A5
 229+ E9A5
 230+ E9A5              ; ******************************************************************************
 231+ E9A5              ;
 232+ E9A5              ;	ABS (Absolute value) of 16 bit signed integer.
 233+ E9A5              ;
 234+ E9A5              ;	IN:		HL =	integer
 235+ E9A5              ;	OUT:		HL =	converted	integer
 236+ E9A5              ;
 237+ E9A5              ;	Registers	changed after return:
 238+ E9A5              ;	A.BCDE../IXIY	same
 239+ E9A5              ;	.F....HL/....	different
 240+ E9A5              ;
 241+ E9A5 CB 7C        absValue:			    bit	7,h
 242+ E9A7 C8                                   ret	z				; integer	is positive...
 243+ E9A8 D5                                   push	de
 244+ E9A9 EB                                   ex	de,hl
 245+ E9AA 21 00 00                             ld	hl,0
 246+ E9AD BF                                   cp	a				; Fc	= 0,	may not be used...
 247+ E9AE ED 52                                sbc	hl,de			; convert	negative integer
 248+ E9B0 D1                                   pop	de
 249+ E9B1 C9                                   ret
 250+ E9B2
# file closed: ./Layer2Graphics/l2_draw_line_v2.asm
 278  E9B2
 279  E9B2              ; Bank 83  ------------------------------------------------------------------------------------------------------------------------
 280  E9B2                  SLOT    SunBankAddr
 281  E9B2                  PAGE    BankSunData
 282  E9B2              	ORG	    SunBankAddr,BankSunData
 283  C000                  INCLUDE "./Universe/Sun/sun_data.asm"
# file opened: ./Universe/Sun/sun_data.asm
   1+ C000              ; In  flight ship data tables
   2+ C000              ; In  flight ship data tables
   3+ C000              ; In  flight ship data tables
   4+ C000              ; There can be upto &12 objects in flight.
   5+ C000              ; To avoid hassle of memory heap managment, the free list
   6+ C000              ; will correspond to a memory bank offset so data will be held in
   7+ C000              ; 1 bank per universe object. Its a waste of a lot of memory but really
   8+ C000              ; 1 bank per universe object. Its a waste of a lot of memory but really
   9+ C000              ; simple that way. Each bank will be 8K and swapped on 8K slot 7 $E000 to $FFFF
  10+ C000              ; This means each gets its own line list, inwork etc
  11+ C000
  12+ C000              ; "Runtime Ship Data paged into in Bank 7"
  13+ C000 53 75 6E 20  StartOfSun:        DB "Sun and Planet X"
  13+ C004 61 6E 64 20
  13+ C008 50 6C 61 6E
  13+ C00C 65 74 20 58
  14+ C010              ; NOTE we can cheat and pre allocate segs just using a DS for now
  15+ C010              CheckRowHLOnScreen:     MACRO   failtarget
  16+ C010 ~                                    ld      a,h                             ; is h byte set, i.e > 256 or < 0
  17+ C010 ~                                    and     a                               ; .
  18+ C010 ~                                    jr      nz,failtarget                   ; h <> 0 so fails (covers <0 and > 255
  19+ C010 ~                                    ld      a,l                             ; l bit 7 0?
  20+ C010 ~                                    and     Bit7Only                        ; covers l > 127 (screen draw area is 0 to 192 / 3 * 2 (128)
  21+ C010 ~                                    jr      nz,failtarget                   ;
  22+ C010                                      ENDM
  23+ C010
  24+ C010              ; IY = SBnKLineArray + rowValue*2
  25+ C010              IYEquRowN:              MACRO   rowValue                        ; set up iy as target address
  26+ C010 ~                                    ld      a,rowValue
  27+ C010 ~                                    ld      hl,SBnKLineArray
  28+ C010 ~                                    add     hl,a
  29+ C010 ~                                    add     hl,a
  30+ C010 ~                                    push    hl
  31+ C010 ~                                    pop     iy
  32+ C010                                      ENDM
  33+ C010              ;   \ -> & 565D \ See ship data files chosen and loaded after flight code starts running.
  34+ C010              ; Universe map substibute for INWK
  35+ C010              ;-Camera Position of Ship----------------------------------------------------------------------------------------------------------
  36+ C010              SBnKDataBlock:
  37+ C010                                      INCLUDE "./Universe/Sun/SunPosVars.asm"
# file opened: ././Universe/Sun/SunPosVars.asm
   1++C010              ;-Camera Position of Ship----------------------------------------------------------------------------------------------------------
   2++C010 00           SBnKxlo                     DB  0                       ; INWK+0
   3++C011 00           SBnKxhi                     DB  0                       ; there are hi medium low as some times these are 24 bit
   4++C012 00           SBnKxsgn                    DB  0                       ; INWK+2
   5++C013 00           SBnKylo                     DB  0                       ; INWK+3 \ ylo
   6++C014 00           SBnKyhi                     DB  0                       ; INWK+4 \ yHi
   7++C015 00           SBnKysgn                    DB  0                       ; INWK +5
   8++C016 00           SBnKzlo                     DB  0                       ; INWK +6
   9++C017 00           SBnKzhi                     DB  0                       ; INWK +7
  10++C018 00           SBnKzsgn                    DB  0                       ; INWK +8
  11++C019
# file closed: ././Universe/Sun/SunPosVars.asm
  38+ C019                                      INCLUDE "./Universe/Sun/SunRotationMatrixVars.asm"
# file opened: ././Universe/Sun/SunRotationMatrixVars.asm
   1++C019              ;-Rotation Matrix of Ship----------------------------------------------------------------------------------------------------------
   2++C019              ; Rotation data is stored as lohi, but only 15 bits with 16th bit being  a sign bit. Note this is NOT 2'c compliment
   3++C019 00 00        SBnKrotmatSidevX            DW  0                       ; INWK +21
   4++C01B              SBnKrotmatSidev             equ SBnKrotmatSidevX
   5++C01B 00 00        SBnKrotmatSidevY            DW  0                       ; INWK +23
   6++C01D 00 00        SBnKrotmatSidevZ            DW  0                       ; INWK +25
   7++C01F 00 00        SBnKrotmatRoofvX            DW  0                       ; INWK +15
   8++C021              SBnKrotmatRoofv             equ SBnKrotmatRoofvX
   9++C021 00 00        SBnKrotmatRoofvY            DW  0                       ; INWK +17
  10++C023 00 00        SBnKrotmatRoofvZ            DW  0                       ; INWK +19
  11++C025 00 00        SBnKrotmatNosevX            DW  0                       ; INWK +9
  12++C027              SBnKrotmatNosev             EQU SBnKrotmatNosevX
  13++C027 00 00        SBnKrotmatNosevY            DW  0                       ; INWK +11
  14++C029 00 00        SBnKrotmatNosevZ            DW  0                       ; INWK +13
  15++C02B
# file closed: ././Universe/Sun/SunRotationMatrixVars.asm
  39+ C02B                                      INCLUDE "./Universe/Sun/SunAIRuntimeData.asm"
# file opened: ././Universe/Sun/SunAIRuntimeData.asm
   1++C02B              ; -- Ship AI data
   2++C02B 00           SBnKRotXCounter             DB  0                       ; INWK +29
   3++C02C 00           SBnKRotZCounter             DB  0                       ; INWK +30
   4++C02D 00           SBnkCam0yLo                 DB  0                       ; INWK +33 ????
   5++C02E 00           SBnkCam0yHi                 DB  0                       ; INWK +34?????
   6++C02F
# file closed: ././Universe/Sun/SunAIRuntimeData.asm
  40+ C02F
  41+ C02F
  42+ C02F                                      INCLUDE "./Universe/Sun/SunXX16Vars.asm"
# file opened: ././Universe/Sun/SunXX16Vars.asm
   1++C02F              ;-- XX16 --------------------------------------------------------------------------------------------------------------------------
   2++C02F 00 00        SBnkTransmatSidevX          DW  0               ; XX16+0
   3++C031              SBnkTransmatSidev           EQU SBnkTransmatSidevX
   4++C031 00 00        SBnkTransmatSidevY          DW 0                ; XX16+2
   5++C033 00 00        SBnkTransmatSidevZ          DW 0                ; XX16+2
   6++C035 00 00        SBnkTransmatRoofvX          DW 0
   7++C037              SBnkTransmatRoofv           EQU SBnkTransmatRoofvX
   8++C037 00 00        SBnkTransmatRoofvY          DW 0                ; XX16+2
   9++C039 00 00        SBnkTransmatRoofvZ          DW 0                ; XX16+2
  10++C03B 00 00        SBnkTransmatNosevX          DW 0
  11++C03D              SBnkTransmatNosev           EQU SBnkTransmatNosevX
  12++C03D 00 00        SBnkTransmatNosevY          DW 0                ; XX16+2
  13++C03F 00 00        SBnkTransmatNosevZ          DW 0                ; XX16+2
  14++C041 00 00        SBnkTransmatTransX          DW 0
  15++C043 00 00        SBnkTransmatTransY          DW 0
  16++C045 00 00        SBnkTransmatTransZ          DW 0
  17++C047              SunXX16                      equ SBnkTransmatSidev
  18++C047              ;-- XX16Inv --------------------------------------------------------------------------------------------------------------------------
  19++C047 00 00        SBnkTransInvRow0x0          DW 0
  20++C049 00 00        SBnkTransInvRow0x1          DW 0
  21++C04B 00 00        SBnkTransInvRow0x2          DW 0
  22++C04D 00 00        SBnkTransInvRow0x3          DW 0
  23++C04F 00 00        SBnkTransInvRow1y0          DW 0
  24++C051 00 00        SBnkTransInvRow1y1          DW 0
  25++C053 00 00        SBnkTransInvRow1y2          DW 0
  26++C055 00 00        SBnkTransInvRow1y3          DW 0
  27++C057 00 00        SBnkTransInvRow2z0          DW 0
  28++C059 00 00        SBnkTransInvRow2z1          DW 0
  29++C05B 00 00        SBnkTransInvRow2z2          DW 0
  30++C05D 00 00        SBnkTransInvRow2z3          DW 0
  31++C05F
  32++C05F              SunXX16Inv             equ SBnkTransInvRow0x0
  33++C05F
# file closed: ././Universe/Sun/SunXX16Vars.asm
  43+ C05F                                      INCLUDE "./Universe/Sun/SunXX25Vars.asm"
# file opened: ././Universe/Sun/SunXX25Vars.asm
   1++C05F              ;-- XX25 --------------------------------------------------------------------------------------------------------------------------
   2++C05F 00           SBnKProjxLo                 DB  0
   3++C060 00           SBnKProjxHi                 DB  0
   4++C061 00           SBnKProjxSgn                DB  0
   5++C062              SBnKProjx                   EQU SBnKProjxLo
   6++C062 00           SBnKProjyLo                 DB  0
   7++C063 00           SBnKProjyHi                 DB  0
   8++C064 00           SBnKProjySgn                DB  0
   9++C065              SBnKProjy                   EQU SBnKProjyLo
  10++C065 00           SBnKProjzLo                 DB  0
  11++C066 00           SBnKProjzHi                 DB  0
  12++C067 00           SBnKProjzSgn                DB  0
  13++C068              SBnKProjz                   EQU SBnKProjzLo
  14++C068              SXX25                       EQU SBnKProjxLo
  15++C068
# file closed: ././Universe/Sun/SunXX25Vars.asm
  44+ C068                                      INCLUDE "./Universe/Sun/SunXX18Vars.asm"
# file opened: ././Universe/Sun/SunXX18Vars.asm
   1++C068              ;-- XX18 --------------------------------------------------------------------------------------------------------------------------
   2++C068 00           SBnKDrawCam0xLo             DB  0               ; XX18+0
   3++C069 00           SBnKDrawCam0xHi             DB  0               ; XX18+1
   4++C06A 00           SBnKDrawCam0xSgn            DB  0               ; XX18+2
   5++C06B              SBnKDrawCam0x               equ SBnKDrawCam0xLo
   6++C06B 00           SBnKDrawCam0yLo             DB  0               ; XX18+3
   7++C06C 00           SBnKDrawCam0yHi             DB  0               ; XX18+4
   8++C06D 00           SBnKDrawCam0ySgn            DB  0               ; XX18+5
   9++C06E              SBnKDrawCam0y               equ SBnKDrawCam0yLo
  10++C06E 00           SBnKDrawCam0zLo             DB  0               ; XX18+6
  11++C06F 00           SBnKDrawCam0zHi             DB  0               ; XX18+7
  12++C070 00           SBnKDrawCam0zSgn            DB  0               ; XX18+8
  13++C071              SBnKDrawCam0z               equ SBnKDrawCam0zLo
  14++C071              SXX18                       equ SBnKDrawCam0xLo
  15++C071
# file closed: ././Universe/Sun/SunXX18Vars.asm
  45+ C071
  46+ C071              ; Used to make 16 bit reads a little cleaner in source code
  47+ C071 00 00 00     SBnKzPoint                  DS  3
  48+ C074              SBnKzPointLo                equ SBnKzPoint
  49+ C074              SBnKzPointHi                equ SBnKzPoint+1
  50+ C074              SBnKzPointSign              equ SBnKzPoint+2
  51+ C074                                      INCLUDE "./Universe/Sun/SunXX15Vars.asm"
# file opened: ././Universe/Sun/SunXX15Vars.asm
   1++C074              ;-- XX15 --------------------------------------------------------------------------------------------------------------------------
   2++C074 00           SBnKXScaled                 DB  0               ; XX15+0Xscaled
   3++C075 00           SBnKXScaledSign             DB  0               ; XX15+1xsign
   4++C076 00           SBnKYScaled                 DB  0               ; XX15+2yscaled
   5++C077 00           SBnKYScaledSign             DB  0               ; XX15+3ysign
   6++C078 00           SBnKZScaled                 DB  0               ; XX15+4zscaled
   7++C079 00           SBnKZScaledSign             DB  0               ; XX15+5zsign
   8++C07A
   9++C07A              SXX15                       equ SBnKXScaled
  10++C07A              SXX15VecX                   equ SXX15
  11++C07A              SXX15VecY                   equ SXX15+1
  12++C07A              SXX15VecZ                   equ SXX15+2
  13++C07A              SBnKXPoint                  equ SXX15
  14++C07A              SBnKXPointLo                equ SXX15+0
  15++C07A              SBnKXPointHi                equ SXX15+1
  16++C07A              SBnKXPointSign              equ SXX15+2
  17++C07A              SBnKYPoint                  equ SXX15+3
  18++C07A              SBnKYPointLo                equ SXX15+3
  19++C07A              SBnKYPointHi                equ SXX15+4
  20++C07A              SBnKYPointSign              equ SXX15+5
  21++C07A
# file closed: ././Universe/Sun/SunXX15Vars.asm
  52+ C07A                                      INCLUDE "./Universe/Sun/SunXX12Vars.asm"
# file opened: ././Universe/Sun/SunXX12Vars.asm
   1++C07A              ;-- transmat0 --------------------------------------------------------------------------------------------------------------------------
   2++C07A              ; Note XX12 comes after as some logic in normal processing uses XX15 and XX12 combines
   3++C07A 00           SBnKXX12xLo                 DB  0               ; XX12+0
   4++C07B 00           SBnKXX12xSign               DB  0               ; XX12+1
   5++C07C 00           SBnKXX12yLo                 DB  0               ; XX12+2
   6++C07D 00           SBnKXX12ySign               DB  0               ; XX12+3
   7++C07E 00           SBnKXX12zLo                 DB  0               ; XX12+4
   8++C07F 00           SBnKXX12zSign               DB  0               ; XX12+5
   9++C080 00 00 00...  SXX12Save                   DS  6
  10++C086 00 00 00...  SXX12Save2                  DS  6
  11++C08C              SXX12                       equ SBnKXX12xLo
  12++C08C              varSXX12                    equ SBnKXX12xLo
  13++C08C              ; Repurposed XX12 when plotting lines
  14++C08C              SBnkY2                      equ SXX12+0
  15++C08C              SbnKy2Lo                    equ SXX12+0
  16++C08C              SBnkY2Hi                    equ SXX12+1
  17++C08C              SBnkDeltaXLo                equ SXX12+2
  18++C08C              SBnkDeltaXHi                equ SXX12+3
  19++C08C              SBnkDeltaYLo                equ SXX12+4
  20++C08C              SBnkDeltaYHi                equ SXX12+5
  21++C08C              SbnkGradient                equ SXX12+2
  22++C08C              SBnkTemp1                   equ SXX12+2
  23++C08C              SBnkTemp1Lo                 equ SXX12+2
  24++C08C              SBnkTemp1Hi                 equ SXX12+3
  25++C08C              SBnkTemp2                   equ SXX12+3
  26++C08C              SBnkTemp2Lo                 equ SXX12+3
  27++C08C              SBnkTemp2Hi                 equ SXX12+4
  28++C08C
# file closed: ././Universe/Sun/SunXX12Vars.asm
  53+ C08C
  54+ C08C
  55+ C08C              ; Post clipping the results are now 8 bit
  56+ C08C 00           SBnKVisibility              DB  0               ; replaces general purpose xx4 in rendering
  57+ C08D 00           SBnKProjectedY              DB  0
  58+ C08E 00           SBnKProjectedX              DB  0
  59+ C08F              SBnKProjected               equ SBnKProjectedY  ; resultant projected position
  60+ C08F 00 00 00...  SunXX15Save                 DS  8
  61+ C097 00 00 00...  SunXX15Save2                DS  8
  62+ C09F              ; Heap (or array) information for lines and normals
  63+ C09F              ; Coords are stored XY,XY,XY,XY
  64+ C09F              ; Normals
  65+ C09F              ; This needs re-oprganising now.
  66+ C09F              ; Runtime Calculation Store
  67+ C09F
  68+ C09F              SunLineArraySize            equ 128 * 2
  69+ C09F              ; Storage arrays for data
  70+ C09F
  71+ C09F 00 00 00...  SBnKLineArray               DS SunLineArraySize ; XX19 Holds the clipped line details
  72+ C19F              SBnKLinesHeapMax            EQU $ - SBnKLineArray
  73+ C19F
  74+ C19F 00 00        LineArrayPtr                DW  0
  75+ C1A1
  76+ C1A1              SBnK_Data_len               EQU $ - SBnKDataBlock
  77+ C1A1
  78+ C1A1              ; --------------------------------------------------------------
  79+ C1A1 21 10 C0     ResetSBnKData:          ld      hl,SBnKDataBlock
  80+ C1A4 11 91 01                             ld      de,SBnK_Data_len
  81+ C1A7 AF                                   xor     a
  82+ C1A8 CD 5A 80                             call    memfill_dma
  83+ C1AB C9                                   ret
  84+ C1AC              ; --------------------------------------------------------------
  85+ C1AC 21 10 C0     ResetSBnKPosition:      ld      hl,SBnKxlo
  86+ C1AF 06 09                                ld      b, 3*3
  87+ C1B1 AF                                   xor     a
  88+ C1B2 77           .zeroLoop:              ld      (hl),a
  89+ C1B3 23                                   inc     hl
  90+ C1B4 10 FC                                djnz    .zeroLoop
  91+ C1B6 C9                                   ret
  92+ C1B7              ; This uses UBNKNodeArray as the list
  93+ C1B7              ; the array is 256 * 2 bytes
  94+ C1B7              ; counter is current row y pos
  95+ C1B7              ; byte 1 is start x pos
  96+ C1B7              ; byte 2 is end x pos
  97+ C1B7              ; if they are both 0 then skip
  98+ C1B7              ; its always horizontal, yellow
  99+ C1B7
 100+ C1B7              ; PLANET
 101+ C1B7
 102+ C1B7
 103+ C1B7              .SunNoDraw:             SetCarryFlag                    ; ship is behind so do not draw, so we don't care abour draw as dot
 103+ C1B7 37          >                        scf
 104+ C1B8 C9                                   ret
 105+ C1B9
 106+ C1B9
 107+ C1B9
 108+ C1B9              SunBankDraw:            MACRO
 109+ C1B9 ~            .drawLoop               ld      a,(hl)
 110+ C1B9 ~                                    ld      c,a                     ; c = left column
 111+ C1B9 ~                                    inc     hl
 112+ C1B9 ~                                    ld      d,(hl)                  ; d = right col
 113+ C1B9 ~                                    inc     hl                      ; now ready for next linel
 114+ C1B9 ~                                    push    hl,,bc
 115+ C1B9 ~                                    cp      d                       ; if both points are the same then no line (we will ignore single pixel as it can't happen at this stage other than tips of circles)
 116+ C1B9 ~                                    IfResultZeroGoto .NoLineDraw
 117+ C1B9 ~                                    ld      a,d                     ; get right col back
 118+ C1B9 ~                                    sub     c                       ; subtract left so a = length
 119+ C1B9 ~                                    inc     a                       ; so its at least 1 , TODO add cp jr c logic in dma routine so that it does non dma if line < x
 120+ C1B9 ~                                    call    z, .FixWidth
 121+ C1B9 ~                                    ld      d,a                     ; de = length (e - d)
 122+ C1B9 ~                                    ld      e,216                   ; yellow
 123+ C1B9 ~                                    call    l2_draw_horz_dma        ; draw without bank switch
 124+ C1B9 ~            .NoLineDraw:            pop     hl,,bc
 125+ C1B9 ~                                    inc     b
 126+ C1B9 ~                                    dec     iyh
 127+ C1B9 ~                                    IfResultNotZeroGoto  .drawLoop
 128+ C1B9                                      ENDM
 129+ C1B9
 130+ C1B9
 131+ C1B9
 132+ C1B9              SunDraw:                MMUSelectLayer2
 132+ C1B9 ED 91 57 39 >					 nextreg L2memMMU,		    BankLAYER2
 133+ C1BD 3A 56 C5     .OptimiseStartPos:      ld      a,(MinYOffset)
 134+ C1C0                                      JumpIfAIsZero .OffsetIsZero     ; if offset is 0 then just initate as normal
 134+ C1C0 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 134+ C1C1 CA D1 C1    >                        jp	z, .OffsetIsZero
 135+ C1C4                                      JumpIfALTNusng 64, .OffsetLT64  ; if offset >=64 then we adjust and mve to bank 0
 135+ C1C4 FE 40       >                        cp      64
 135+ C1C6 DA DE C1    >                        jp		c, .OffsetLT64
 136+ C1C9 D6 40        .OffsetGTE64:           sub     64
 137+ C1CB 32 56 C5                             ld      (MinYOffset),a          ; adjust offset for bank 2
 138+ C1CE C3 16 C2                             jp      .StartBank2
 139+ C1D1 06 00        .OffsetIsZero:          ld      b,0                     ; row
 140+ C1D3 FD 26 40                             ld      iyh,64                  ; counter
 141+ C1D6 21 9F C0                             ld      hl,SBnKLineArray        ; set hl to start of array
 142+ C1D9 C3 F0 C1                             jp      .StartBank1
 143+ C1DC              ;-- Snuck routine in here so that the macro will be happier
 144+ C1DC 3D           .FixWidth:              dec     a                       ; if carry resulted in a value of zero then correct
 145+ C1DD C9                                   ret
 146+ C1DE 21 9F C0     .OffsetLT64:            ld      hl,SBnKLineArray        ; adjust hl for line array offset
 147+ C1E1 ED 31                                add     hl,a                    ; .
 148+ C1E3 ED 31                                add     hl,a                    ; .
 149+ C1E5 47                                   ld      b,a                     ; set b row to the actual offset
 150+ C1E6 4F                                   ld      c,a                     ; iyh = 64 - Y offset
 151+ C1E7 3E 40                                ld      a,64                    ; .
 152+ C1E9 91                                   sub     c                       ; .
 153+ C1EA FD 67                                ld      iyh,a
 154+ C1EC AF                                   xor     a                       ; Ready bank 2 with no offset
 155+ C1ED 32 56 C5                             ld      (MinYOffset),a          ; .
 156+ C1F0 D9           .StartBank1:            exx
 157+ C1F1 3E 00                                ld      a,LAYER2_SHIFTED_SCREEN_TOP
 158+ C1F3 CD 37 E0                             call    asm_l2_bank_select      ; get in the first bank, we will only then bank select when needed
 159+ C1F6 D9                                   exx
 160+ C1F7                                      SunBankDraw
 160+ C1F7 7E          >.drawLoop               ld      a,(hl)
 160+ C1F8 4F          >                        ld      c,a                     ; c = left column
 160+ C1F9 23          >                        inc     hl
 160+ C1FA 56          >                        ld      d,(hl)                  ; d = right col
 160+ C1FB 23          >                        inc     hl                      ; now ready for next linel
 160+ C1FC E5 C5       >                        push    hl,,bc
 160+ C1FE BA          >                        cp      d                       ; if both points are the same then no line (we will ignore single pixel as it can't happen at this stage other than tips of circles)
 160+ C1FF             >                        IfResultZeroGoto .NoLineDraw
 160+ C1FF CA 0E C2    >                        jp	z,.NoLineDraw
 160+ C202 7A          >                        ld      a,d                     ; get right col back
 160+ C203 91          >                        sub     c                       ; subtract left so a = length
 160+ C204 3C          >                        inc     a                       ; so its at least 1 , TODO add cp jr c logic in dma routine so that it does non dma if line < x
 160+ C205 CC DC C1    >                        call    z, .FixWidth
 160+ C208 57          >                        ld      d,a                     ; de = length (e - d)
 160+ C209 1E D8       >                        ld      e,216                   ; yellow
 160+ C20B CD 64 E2    >                        call    l2_draw_horz_dma        ; draw without bank switch
 160+ C20E C1 E1       >.NoLineDraw:            pop     hl,,bc
 160+ C210 04          >                        inc     b
 160+ C211 FD 25       >                        dec     iyh
 160+ C213             >                        IfResultNotZeroGoto  .drawLoop
 160+ C213 C2 F7 C1    >                        jp	nz,.drawLoop
 161+ C216 3A 56 C5     .StartBank2:            ld      a,(MinYOffset)
 162+ C219                                      JumpIfAIsZero .OffsetBank2IsZero; if offset is 0 then we just continue, offset can never be >127 else there would be no draw
 162+ C219 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 162+ C21A CA 2E C2    >                        jp	z, .OffsetBank2IsZero
 163+ C21D 21 1F C1     .NotZeroOffset:         ld      hl,SBnKLineArray + (64 * 2); adjust to correct offset
 164+ C220 ED 31                                add     hl,a
 165+ C222 ED 31                                add     hl,a
 166+ C224 4F                                   ld      c,a                     ; iyh = 64 - offset
 167+ C225 3E 40                                ld      a,64                    ; .
 168+ C227 91                                   sub     c                       ; .
 169+ C228 FD 67                                ld      iyh,a                   ; .
 170+ C22A 41                                   ld      b,c                     ; b = offset row
 171+ C22B C3 36 C2                             jp      .drawLineBank2
 172+ C22E 21 1F C1     .OffsetBank2IsZero:     ld      hl,SBnKLineArray + (64 * 2); start with offset adjusted
 173+ C231 06 00                                ld      b,0
 174+ C233 FD 26 40                             ld      iyh,64
 175+ C236 D9           .drawLineBank2:         exx
 176+ C237 3E 40                                ld      a,LAYER2_SHIFTED_SCREEN_MIDDLE
 177+ C239 CD 37 E0                             call    asm_l2_bank_select      ; now do the lower bank
 178+ C23C D9                                   exx
 179+ C23D              ; Could make this a sub routine but unwrapping saves a call
 180+ C23D                                      SunBankDraw
 180+ C23D 7E          >.drawLoop               ld      a,(hl)
 180+ C23E 4F          >                        ld      c,a                     ; c = left column
 180+ C23F 23          >                        inc     hl
 180+ C240 56          >                        ld      d,(hl)                  ; d = right col
 180+ C241 23          >                        inc     hl                      ; now ready for next linel
 180+ C242 E5 C5       >                        push    hl,,bc
 180+ C244 BA          >                        cp      d                       ; if both points are the same then no line (we will ignore single pixel as it can't happen at this stage other than tips of circles)
 180+ C245             >                        IfResultZeroGoto .NoLineDraw
 180+ C245 CA 54 C2    >                        jp	z,.NoLineDraw
 180+ C248 7A          >                        ld      a,d                     ; get right col back
 180+ C249 91          >                        sub     c                       ; subtract left so a = length
 180+ C24A 3C          >                        inc     a                       ; so its at least 1 , TODO add cp jr c logic in dma routine so that it does non dma if line < x
 180+ C24B CC DC C1    >                        call    z, .FixWidth
 180+ C24E 57          >                        ld      d,a                     ; de = length (e - d)
 180+ C24F 1E D8       >                        ld      e,216                   ; yellow
 180+ C251 CD 64 E2    >                        call    l2_draw_horz_dma        ; draw without bank switch
 180+ C254 C1 E1       >.NoLineDraw:            pop     hl,,bc
 180+ C256 04          >                        inc     b
 180+ C257 FD 25       >                        dec     iyh
 180+ C259             >                        IfResultNotZeroGoto  .drawLoop
 180+ C259 C2 3D C2    >                        jp	nz,.drawLoop
 181+ C25C C9                                   ret
 182+ C25D
 183+ C25D              ; --------------------------------------------------------------
 184+ C25D              ; This sets current universe object to a star / sun, they use sign + 23 bit positions
 185+ C25D CD A1 C1     CreateSun:              call    ResetSBnKData
 186+ C260 3A 54 85                             ld      a,(WorkingSeeds+3)
 187+ C263 E6 07                                and     %00000111
 188+ C265 F6 81                                or      %10000001
 189+ C267 32 18 C0                             ld      (SBnKzsgn),a
 190+ C26A 3A 56 85                             ld      a,(WorkingSeeds+5)
 191+ C26D E6 03                                and     %00000011
 192+ C26F 32 12 C0                             ld      (SBnKxsgn),a
 193+ C272 32 15 C0                             ld      (SBnKysgn),a
 194+ C275                                   ; DEBUG   ld      hl, $0000
 195+ C275                                   ; DEBUG   ld      (SBnKzhi),hl
 196+ C275                                   ; DEBUG   ld      a, $E3
 197+ C275                                   ; DEBUG   ld      (SBnKzlo),a
 198+ C275 C9                                   ret
 199+ C276              ; --------------------------------------------------------------
 200+ C276              ; This sets current universe object to a planet,they use sign + 23 bit positions
 201+ C276              ;;TODOCreatePlanet:           call    ResetSBnKData
 202+ C276              ;;TODO                        ld      a,(DisplayTekLevel)
 203+ C276              ;;TODO                        and     $00000010               ; Set A = 128 or 130 depending on bit 1 of the system's tech level
 204+ C276              ;;TODO                        or      $10000000
 205+ C276              ;;TODO                        ld      (SBnKShipType),a
 206+ C276              ;;TODO                        xor     a
 207+ C276              ;;TODO                        ld      (SBnKaiatkecm),a
 208+ C276              ;;TODO                        MaxUnivPitchAndRoll
 209+ C276              ;;TODO                        ld      a,(WorkingSeeds+1)      ; a= bits 1 and 0 of working seed1 + 3 + carry
 210+ C276              ;;TODO                        and     %00000011               ; .
 211+ C276              ;;TODO                        adc     3                       ; .
 212+ C276              ;;TODO                        ld      (SBnKzsgn),a            ; set z sign to 3 + C + 0..3 bits
 213+ C276              ;;TODO                        rr      a
 214+ C276              ;;TODO                        ld      (PlanetXsgn),a
 215+ C276              ;;TODO                        ld      (PlanetYsgn),a
 216+ C276              ;;TODO                        ret
 217+ C276
 218+ C276
 219+ C276                                 ;     include "./Maths/ADDHLDESignBC.asm"
 220+ C276
 221+ C276 7C           SunADDHLDESignedv3:     ld      a,h
 222+ C277 E6 80                                and     SignOnly8Bit
 223+ C279 47                                   ld      b,a                         ;save sign bit in b
 224+ C27A AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
 225+ C27B                                      JumpIfNegative .SunADDHLDEOppSGN    ;Signs are opposite there fore we can subtract to get difference
 225+ C27B FA 96 C2    >                        jp		m, .SunADDHLDEOppSGN
 226+ C27E 78           .SunADDHLDESameSigns:   ld      a,b
 227+ C27F B2                                   or      d
 228+ C280                                      JumpIfNegative .SunADDHLDESameNeg   ; optimisation so we can just do simple add if both positive
 228+ C280 FA 88 C2    >                        jp		m, .SunADDHLDESameNeg
 229+ C283                                      JumpIfNegative .SunADDHLDESameNeg   ; optimisation so we can just do simple add if both positive
 229+ C283 FA 88 C2    >                        jp		m, .SunADDHLDESameNeg
 230+ C286 19                                   add     hl,de
 231+ C287 C9                                   ret
 232+ C288 7C           .SunADDHLDESameNeg:     ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 233+ C289 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 234+ C28B 67                                   ld      h,a
 235+ C28C 7A                                   ld      a,d
 236+ C28D E6 7F                                and     SignMask8Bit
 237+ C28F 57                                   ld      d,a
 238+ C290 19                                   add     hl,de
 239+ C291 3E 80                                ld      a,SignOnly8Bit
 240+ C293 B4                                   or      h                           ; now set bit for negative value, we won't bother with overflow for now TODO
 241+ C294 67                                   ld      h,a
 242+ C295 C9                                   ret
 243+ C296 7C           .SunADDHLDEOppSGN:      ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit                     ; here HL and DE are opposite
 244+ C297 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 245+ C299 67                                   ld      h,a
 246+ C29A 7A                                   ld      a,d
 247+ C29B E6 7F                                and     SignMask8Bit
 248+ C29D 57                                   ld      d,a
 249+ C29E B7                                   or      a
 250+ C29F ED 52                                sbc     hl,de
 251+ C2A1 38 04                                jr      c,.SunADDHLDEOppInvert
 252+ C2A3 78           .SunADDHLDEOppSGNNoCarry:   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
 253+ C2A4 B4                                   or      h
 254+ C2A5 67                                   ld      h,a                         ; set the previou sign value
 255+ C2A6 C9                                   ret
 256+ C2A7              .SunADDHLDEOppInvert:       NegHL                                                   ; we need to flip the sign and 2'c the Hl result
 256+ C2A7 AF          >                    xor a
 256+ C2A8 95          >                    sub l
 256+ C2A9 6F          >                    ld l,a
 256+ C2AA 9F          >                    sbc a,a
 256+ C2AB 94          >                    sub h
 256+ C2AC 67          >                    ld h,a
 257+ C2AD 78                                   ld      a,b
 258+ C2AE EE 80                                xor     SignOnly8Bit                ; flip sign bit
 259+ C2B0 B4                                   or      h
 260+ C2B1 67                                   ld      h,a                         ; recover sign
 261+ C2B2 C9                                   ret
 262+ C2B3
 263+ C2B3              ; we could cheat, flip the sign of DE and just add but its not very optimised
 264+ C2B3 7C           .SunSUBHLDESignedv3:        ld      a,h
 265+ C2B4 E6 80                                and     SignOnly8Bit
 266+ C2B6 47                                   ld      b,a                         ;save sign bit in b
 267+ C2B7 AA                                   xor     d                           ;if h sign and d sign were different then bit 7 of a will be 1 which means
 268+ C2B8                                      JumpIfNegative .SunSUBHLDEOppSGN        ;Signs are opposite therefore we can add
 268+ C2B8 FA E6 C2    >                        jp		m, .SunSUBHLDEOppSGN
 269+ C2BB 78           .SunSUBHLDESameSigns:       ld      a,b
 270+ C2BC B2                                   or      d
 271+ C2BD                                      JumpIfNegative .SunSUBHLDESameNeg       ; optimisation so we can just do simple add if both positive
 271+ C2BD FA C7 C2    >                        jp		m, .SunSUBHLDESameNeg
 272+ C2C0 B7                                   or      a
 273+ C2C1 ED 52                                sbc     hl,de
 274+ C2C3                                      JumpIfNegative .SunSUBHLDESameOvrFlw
 274+ C2C3 FA DA C2    >                        jp		m, .SunSUBHLDESameOvrFlw
 275+ C2C6 C9                                   ret
 276+ C2C7 7C           .SunSUBHLDESameNeg:         ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 277+ C2C8 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 278+ C2CA 67                                   ld      h,a
 279+ C2CB 7A                                   ld      a,d
 280+ C2CC E6 7F                                and     SignMask8Bit
 281+ C2CE 57                                   ld      d,a
 282+ C2CF B7                                   or      a
 283+ C2D0 ED 52                                sbc     hl,de
 284+ C2D2                                      JumpIfNegative .SunSUBHLDESameOvrFlw
 284+ C2D2 FA DA C2    >                        jp		m, .SunSUBHLDESameOvrFlw
 285+ C2D5 7C                                   ld      a,h                         ; now set bit for negative value, we won't bother with overflow for now TODO
 286+ C2D6 F6 80                                or      SignOnly8Bit
 287+ C2D8 67                                   ld      h,a
 288+ C2D9 C9                                   ret
 289+ C2DA              .SunSUBHLDESameOvrFlw:      NegHL                                                        ; we need to flip the sign and 2'c the Hl result
 289+ C2DA AF          >                    xor a
 289+ C2DB 95          >                    sub l
 289+ C2DC 6F          >                    ld l,a
 289+ C2DD 9F          >                    sbc a,a
 289+ C2DE 94          >                    sub h
 289+ C2DF 67          >                    ld h,a
 290+ C2E0 78                                   ld      a,b
 291+ C2E1 EE 80                                xor     SignOnly8Bit                ; flip sign bit
 292+ C2E3 B4                                   or      h
 293+ C2E4 67                                   ld      h,a                         ; recover sign
 294+ C2E5 C9                                   ret
 295+ C2E6 B7           .SunSUBHLDEOppSGN:          or      a                                               ; here HL and DE are opposite so we can add the values
 296+ C2E7 7C                                   ld      a,h                         ; so if we enter here then signs are the same so we clear the 16th bit
 297+ C2E8 E6 7F                                and     SignMask8Bit                ; we could check the value of b for optimisation
 298+ C2EA 67                                   ld      h,a
 299+ C2EB 7A                                   ld      a,d
 300+ C2EC E6 7F                                and     SignMask8Bit
 301+ C2EE 57                                   ld      d,a
 302+ C2EF 19                                   add     hl,de
 303+ C2F0 78                                   ld      a,b                         ; we got here so hl > de therefore we can just take hl's previous sign bit
 304+ C2F1 B4                                   or      h
 305+ C2F2 67                                   ld      h,a                         ; set the previou sign value
 306+ C2F3 C9                                   ret
 307+ C2F4
 308+ C2F4
 309+ C2F4              .SunSBCHLDESigned:      JumpOnBitSet h,7,.SunSBCHLDEhlNeg
 309+ C2F4 CB 7C       >                        bit 	7,h
 309+ C2F6 C2 07 C3    >                        jp      nz,.SunSBCHLDEhlNeg
 310+ C2F9              .SunSBCHLDEhlPos:       JumpOnBitSet h,7,.SunSBCHLDEhlNeg
 310+ C2F9 CB 7C       >                        bit 	7,h
 310+ C2FB C2 07 C3    >                        jp      nz,.SunSBCHLDEhlNeg
 311+ C2FE ED 52        .SunSBCHLDEhlPosDePos:  sbc     hl,de                           ; ignore overflow for now will sort later TODO
 312+ C300 C9                                   ret
 313+ C301 CB BA        .SunSBCHLDEhlPosDeNeg:  res     7,d
 314+ C303 19                                   add     hl,de                           ; ignore overflow for now will sort later TODO
 315+ C304 CB FA                                set     7,d
 316+ C306 C9                                   ret
 317+ C307 CB BC        .SunSBCHLDEhlNeg:       res     7,h
 318+ C309                                      JumpOnBitSet d,7,.SunSBCHLDEhlNegdeNeg
 318+ C309 CB 7A       >                        bit 	7,d
 318+ C30B C2 13 C3    >                        jp      nz,.SunSBCHLDEhlNegdeNeg
 319+ C30E ED 52        .SunSBCHLDEhlNegdePos:  sbc     hl,de                       ; ignore overflow for now will sort later TODO
 320+ C310 CB FC                                set     7,h
 321+ C312 C9                                   ret
 322+ C313 CB BA        .SunSBCHLDEhlNegdeNeg:      res     7,d
 323+ C315 19                                   add     hl,de                   ; ignore overflow for now will sort later TODO
 324+ C316 CB FA                                set     7,d
 325+ C318 CB FC                                set     7,h
 326+ C31A C9                                   ret
 327+ C31B
 328+ C31B
 329+ C31B                                      include "./Universe/Sun/TransposeSunXX12BySunToSunXX15.asm"
# file opened: ././Universe/Sun/TransposeSunXX12BySunToSunXX15.asm
   1++C31B              TransposeSXX12BySunToSXX15:
   2++C31B 2A 7A C0                             ld		hl,(SBnKXX12xLo)					; get X into HL
   3++C31E 7C                                   ld		a,h			                        ; get XX12 Sign
   4++C31F E6 80                                and		$80									; check sign bit on high byte
   5++C321 47                                   ld		b,a									; and put it in of 12xlo in b
   6++C322                                      ;110921 debugld      h,0
   7++C322 7C                                   ld      a,h
   8++C323 E6 7F                                and     $7F
   9++C325 67                                   ld      h,a
  10++C326                                      ;110921 debugld      h,0
  11++C326 ED 5B 10 C0                          ld		de,(SBnKxlo)						;
  12++C32A 3A 12 C0                             ld		a,(SBnKxsgn)						; get Ship Pos (low,high,sign)
  13++C32D E6 80                                and		$80									; make sure we only have bit 7
  14++C32F 4F                                   ld		c,a									; and put sign of unkxsgn c
  15++C330 CD 93 99                             call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC		; this will result in HL = result and A = sign
  16++C333 B4                                   or		h									; combine sign in A with H to give 15 bit signed (*NOT* 2's c)
  17++C334 67                                   ld		h,a
  18++C335 22 74 C0                             ld		(SBnKXScaled),hl					; now write it out to XX15 X pos
  19++C338              ; ..................................
  20++C338 2A 7C C0                             ld		hl,(SBnKXX12yLo)					; Repeat above for Y coordinate
  21++C33B 7C                                   ld		a,h
  22++C33C E6 80                                and		$80
  23++C33E 47                                   ld		b,a
  24++C33F                                      ;110921 debugld      h,0
  25++C33F 7C                                   ld      a,h
  26++C340 E6 7F                                and     $7F
  27++C342 67                                   ld      h,a
  28++C343                                      ;110921 debugld      h,0
  29++C343 ED 5B 13 C0                          ld		de,(SBnKylo)
  30++C347 3A 15 C0                             ld		a,(SBnKysgn)
  31++C34A E6 80                                and		$80									; make sure we only have bit 7
  32++C34C 4F                                   ld		c,a
  33++C34D CD 93 99                             call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC
  34++C350 B4                                   or		h									; combine sign in A with H
  35++C351 67                                   ld		h,a
  36++C352 22 76 C0                             ld		(SBnKYScaled),hl
  37++C355              ; ..................................
  38++C355 2A 7E C0                             ld		hl,(SBnKXX12zLo)					; and now repeat for Z cooord
  39++C358 7C                                   ld		a,h
  40++C359 E6 80                                and		$80
  41++C35B 47                                   ld		b,a
  42++C35C                                      ;110921 debugld      h,0
  43++C35C 7C                                   ld      a,h
  44++C35D E6 7F                                and     $7F
  45++C35F 67                                   ld      h,a
  46++C360                                      ;110921 debugld      h,0
  47++C360 ED 5B 16 C0                          ld		de,(SBnKzlo)
  48++C364 3A 18 C0                             ld		a,(SBnKzsgn)
  49++C367 E6 80                                and		$80									; make sure we only have bit 7
  50++C369 4F                                   ld		c,a
  51++C36A CD 93 99                             call 	ADDHLDESignBC; XX12ProcessCalcHLPlusDESignBC
  52++C36D B4                                   or		h									; combine sign in A with H
  53++C36E 67                                   ld		h,a
  54++C36F CB 7C                                bit		7,h                                 ; if sign if positive then we don't need to do the clamp so we ony jump
  55++C371 20 16                                jr		nz,.ClampZto4                        ; result was negative so we need to clamp to 4
  56++C373 E6 7F                                and     $7F                                 ; a = value unsigned
  57++C375 20 06                                jr      nz,.NoClampZto4                      ; if high byte was 0 then we could need to clamp still by this stage its +v but and will set z flag if high byte is zero
  58++C377 7D                                   ld      a,l                                 ; get low byte now
  59++C378                                      JumpIfALTNusng 4,.ClampZto4					; if its < 4 then fix at 4
  59++C378 FE 04       >                        cp      4
  59++C37A DA 89 C3    >                        jp		c, .ClampZto4
  60++C37D 22 78 C0     .NoClampZto4:           ld		(SBnKZScaled),hl					; hl = signed calculation and > 4
  61++C380 7D                                   ld		a,l									; in addition write out the z cooord to UT for now for backwards compat (DEBUG TODO remove later)
  62++C381 32 77 84                             ld      (varT),a
  63++C384 7C                                   ld		a,h
  64++C385 32 5A 84                             ld      (varU),a
  65++C388 C9                                   ret
  66++C389              ; This is where we limit 4 to a minimum of 4
  67++C389 21 04 00     .ClampZto4:             ld		hl,4
  68++C38C 22 78 C0                             ld		(SBnKZScaled),hl; BODGE FOR NOW
  69++C38F 7D                                   ld		a,l
  70++C390 32 77 84                             ld      (varT),a                            ;                                                                           ;;;
  71++C393 7C                                   ld		a,h
  72++C394 32 5A 84                             ld      (varU),a 						; compatibility for now
  73++C397 C9                                   ret
  74++C398
# file closed: ././Universe/Sun/TransposeSunXX12BySunToSunXX15.asm
 330+ C398
 331+ C398
 332+ C398 ED 4B 78 C0  ScaleSunTo8Bit:			ld			bc,(SBnKZScaled)
 333+ C39C 2A 74 C0                             ld			hl,(SBnKXScaled)
 334+ C39F ED 5B 76 C0                          ld			de,(SBnKYScaled)
 335+ C3A3 78           .SetABSbc:              ld			a,b
 336+ C3A4 DD 67                                ld			ixh,a
 337+ C3A6 E6 7F                                and			SignMask8Bit
 338+ C3A8 47                                   ld			b,a									; bc = ABS bc
 339+ C3A9 7C           .SetABShl:              ld			a,h
 340+ C3AA DD 6F                                ld			ixl,a
 341+ C3AC E6 7F                                and			SignMask8Bit
 342+ C3AE 67                                   ld			h,a									; hl = ABS hl
 343+ C3AF 7A           .SetABSde:              ld			a,d
 344+ C3B0 FD 67                                ld			iyh,a
 345+ C3B2 E6 7F                                and			SignMask8Bit
 346+ C3B4 57                                   ld			d,a									; de = ABS de
 347+ C3B5 78           .ScaleNodeTo8BitLoop:   ld          a,b		                            ; U	\ z hi
 348+ C3B6 B4                                   or			h                                   ; XX15+1	\ x hi
 349+ C3B7 B2                                   or			d                                   ; XX15+4	\ y hi
 350+ C3B8 28 0F                                jr          z,.ScaleNodeDone                   ; if X, Y, Z = 0  exit loop down once hi U rolled to 0
 351+ C3BA                                      ShiftHLRight1
 351+ C3BA CB 3C       >			   srl h
 351+ C3BC CB 1D       >			   rr  l
 352+ C3BE                                      ShiftDERight1
 352+ C3BE CB 3A       >			   srl d
 352+ C3C0 CB 1B       >			   rr  e
 353+ C3C2                                      ShiftBCRight1
 353+ C3C2 CB 38       >			   srl b
 353+ C3C4 CB 19       >			   rr  c
 354+ C3C6 C3 B5 C3                             jp          .ScaleNodeTo8BitLoop
 355+ C3C9              ; now we have scaled values we have to deal with sign
 356+ C3C9 DD 7C        .ScaleNodeDone:          ld			a,ixh								; get sign bit and or with b
 357+ C3CB E6 80                                and			SignOnly8Bit
 358+ C3CD B0                                   or			b
 359+ C3CE 47                                   ld			b,a
 360+ C3CF DD 7D        .SignforHL:              ld			a,ixl								; get sign bit and or with b
 361+ C3D1 E6 80                                and			SignOnly8Bit
 362+ C3D3 B4                                   or			h
 363+ C3D4 67                                   ld			h,a
 364+ C3D5 FD 7C        .SignforDE:              ld			a,iyh								; get sign bit and or with b
 365+ C3D7 E6 80                                and			SignOnly8Bit
 366+ C3D9 B2                                   or			d
 367+ C3DA 57                                   ld			d,a
 368+ C3DB ED 43 78 C0  .SignsDoneSaveResult:	ld			(SBnKZScaled),bc
 369+ C3DF 22 74 C0                             ld			(SBnKXScaled),hl
 370+ C3E2 ED 53 76 C0                          ld			(SBnKYScaled),de
 371+ C3E6 78                                   ld			a,b
 372+ C3E7 32 5A 84                             ld			(varU),a
 373+ C3EA 79                                   ld			a,c
 374+ C3EB 32 77 84                             ld			(varT),a
 375+ C3EE C9                                   ret
 376+ C3EF
 377+ C3EF              ;--------------------------------------------------------------------------------------------------------
 378+ C3EF              ;;;;X = normal scale
 379+ C3EF              ;;;;ZtempHi = zhi
 380+ C3EF              ;;;;......................................................
 381+ C3EF              ;;;; if ztemp hi <> 0                                   ::Scale Object Distance
 382+ C3EF              ;;;;  Loop                                              ::LL90
 383+ C3EF              ;;;;     inc X
 384+ C3EF              ;;;;     divide X, Y & ZtempHiLo by 2
 385+ C3EF              ;;;;  Until ZtempHi = 0
 386+ C3EF              ;;;;......................................................
 387+ C3EF              ;-LL21---------------------------------------------------------------------------------------------------
 388+ C3EF              ;                        include "./Universe/NormaliseTransMat.asm"
 389+ C3EF              ;-LL91---------------------------------------------------------------------------------------------------
 390+ C3EF
 391+ C3EF              ; Now we have
 392+ C3EF              ;   * XX18(2 1 0) = (x_sign x_hi x_lo)
 393+ C3EF              ;   * XX18(5 4 3) = (y_sign y_hi y_lo)
 394+ C3EF              ;   * XX18(8 7 6) = (z_sign z_hi z_lo)
 395+ C3EF              ;
 396+ C3EF              ;--------------------------------------------------------------------------------------------------------
 397+ C3EF              ;--------------------------------------------------------------------------------------------------------
 398+ C3EF              ;   XX12(1 0) = [x y z] . sidev  = (dot_sidev_sign dot_sidev_lo)  = dot_sidev
 399+ C3EF              ;   XX12(3 2) = [x y z] . roofv  = (dot_roofv_sign dot_roofv_lo)  = dot_roofv
 400+ C3EF              ;   XX12(5 4) = [x y z] . nosev  = (dot_nosev_sign dot_nosev_lo)  = dot_nosev
 401+ C3EF              ; Returns
 402+ C3EF              ;
 403+ C3EF              ;   XX12(1 0)            The dot product of [x y z] vector with the sidev (or _x)
 404+ C3EF              ;                        vector, with the sign in XX12+1 and magnitude in XX12
 405+ C3EF              ;
 406+ C3EF              ;   XX12(3 2)            The dot product of [x y z] vector with the roofv (or _y)
 407+ C3EF              ;                        vector, with the sign in XX12+3 and magnitude in XX12+2
 408+ C3EF              ;
 409+ C3EF              ;   XX12(5 4)            The dot product of [x y z] vector with the nosev (or _z)
 410+ C3EF              ;                        vector, with the sign in XX12+5 and magnitude in XX12+4
 411+ C3EF
 412+ C3EF
 413+ C3EF               ; TESTEDOK
 414+ C3EF              SXX12DotOneRow:
 415+ C3EF              SXX12CalcX:              N0equN1byN2div256 varT, (hl), (SBnKXScaled)       ; T = (hl) * regSunXX15fx /256
 415+ C3EF 3A 74 C0    >                        ld      a,(SBnKXScaled)                        ;
 415+ C3F2 5F          >                        ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 415+ C3F3 7E          >                        ld      a,(hl)                        ; A = XX16 element
 415+ C3F4 57          >                        ld      d,a
 415+ C3F5 ED 30       >                        mul
 415+ C3F7 7A          >                        ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 415+ C3F8 32 77 84    >                        ld      (varT),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 416+ C3FB 23                                   inc     hl                                  ; move to sign byte
 417+ C3FC              SXX12CalcXSign:          AequN1xorN2 SBnKXScaledSign,(hl)             ;
 417+ C3FC 3A 75 C0    >                        ld      a,(SBnKXScaledSign)
 417+ C3FF AE          >                        xor     (hl)
 418+ C400 32 5D 84                             ld      (varS),a                            ; Set S to the sign of x_sign * sidev_x
 419+ C403 23                                   inc     hl
 420+ C404              SXX12CalcY:              N0equN1byN2div256 varQ, (hl),(SBnKYScaled)       ; Q = XX16 * SunXX15 /256 using varQ to hold regSunXX15fx
 420+ C404 3A 76 C0    >                        ld      a,(SBnKYScaled)                        ;
 420+ C407 5F          >                        ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 420+ C408 7E          >                        ld      a,(hl)                        ; A = XX16 element
 420+ C409 57          >                        ld      d,a
 420+ C40A ED 30       >                        mul
 420+ C40C 7A          >                        ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 420+ C40D 32 5B 84    >                        ld      (varQ),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 421+ C410                                      ldCopyByte varT,varR                        ; R = T =  |sidev_x| * x_lo / 256
 421+ C410 3A 77 84    >                        ld       a,(varT)
 421+ C413 32 5C 84    >                        ld       (varR),a
 422+ C416 23                                   inc     hl
 423+ C417                                      AequN1xorN2 SBnKYScaledSign,(hl)             ; Set A to the sign of y_sign * sidev_y
 423+ C417 3A 77 C0    >                        ld      a,(SBnKYScaledSign)
 423+ C41A AE          >                        xor     (hl)
 424+ C41B              ; (S)A = |sidev_x| * x_lo / 256  = |sidev_x| * x_lo + |sidev_y| * y_lo
 425+ C41B E5           SSTequSRplusAQ           push    hl
 426+ C41C CD B1 9A                             call    baddll38                            ; JSR &4812 \ LL38   \ BADD(S)A=R+Q(SA) \ 1byte add (subtract)
 427+ C41F E1                                   pop     hl
 428+ C420 32 77 84                             ld      (varT),a                            ; T = |sidev_x| * x_lo + |sidev_y| * y_lo
 429+ C423 23                                   inc     hl
 430+ C424              SXX12CalcZ:              N0equN1byN2div256 varQ,(hl),(SBnKZScaled)       ; Q = |sidev_z| * z_lo / 256
 430+ C424 3A 78 C0    >                        ld      a,(SBnKZScaled)                        ;
 430+ C427 5F          >                        ld      e,a                         ; use e as var Q = value of XX15 [n] lo
 430+ C428 7E          >                        ld      a,(hl)                        ; A = XX16 element
 430+ C429 57          >                        ld      d,a
 430+ C42A ED 30       >                        mul
 430+ C42C 7A          >                        ld      a,d                         ; we get only the high byte which is like doing a /256 if we think of a as low
 430+ C42D 32 5B 84    >                        ld      (varQ),a                      ; Q         ; result variable = XX16[n] * XX15[n]/256
 431+ C430                                      ldCopyByte varT,varR                        ; R = |sidev_x| * x_lo + |sidev_y| * y_lo
 431+ C430 3A 77 84    >                        ld       a,(varT)
 431+ C433 32 5C 84    >                        ld       (varR),a
 432+ C436 23                                   inc     hl
 433+ C437                                      AequN1xorN2 SBnKZScaledSign,(hl)             ; A = sign of z_sign * sidev_z
 433+ C437 3A 79 C0    >                        ld      a,(SBnKZScaledSign)
 433+ C43A AE          >                        xor     (hl)
 434+ C43B              ; (S)A= |sidev_x| * x_lo + |sidev_y| * y_lo + |sidev_z| * z_lo
 435+ C43B CD B1 9A                             call    baddll38                            ; JSR &4812 \ LL38   \ BADD(S)A=R+Q(SA)   \ 1byte add (subtract)
 436+ C43E              ; Now we exit with A = result S = Sign
 437+ C43E C9                                   ret
 438+ C43F
 439+ C43F
 440+ C43F
 441+ C43F              ;--------------------------------------------------------------------------------------------------------
 442+ C43F                                      include "./Universe/Sun/CopySunXX12ScaledToSunXX18.asm"
# file opened: ././Universe/Sun/CopySunXX12ScaledToSunXX18.asm
   1++C43F              CopySXX12ScaledToSXX18:
   2++C43F              CopyResultToSDrawCam:
   3++C43F                      ldCopyByte SXX12         ,SXX18             ; XX12+0 => XX18+0  Set XX18(2 0) = dot_sidev
   3++C43F 3A 7A C0    >                        ld       a,(SXX12)
   3++C442 32 68 C0    >                        ld       (SXX18),a
   4++C445                      ldCopyByte SXX12+1       ,SXX18+2           ; XX12+1 => XX18+2
   4++C445 3A 7B C0    >                        ld       a,(SXX12+1)
   4++C448 32 6A C0    >                        ld       (SXX18+2),a
   5++C44B                      ldCopyByte SXX12+2       ,SXX18+3           ; XX12+2 => XX18+3  Set XX12+1 => XX18+2
   5++C44B 3A 7C C0    >                        ld       a,(SXX12+2)
   5++C44E 32 6B C0    >                        ld       (SXX18+3),a
   6++C451                      ldCopyByte SXX12+3       ,SXX18+5           ; XX12+3 => XX18+5
   6++C451 3A 7D C0    >                        ld       a,(SXX12+3)
   6++C454 32 6D C0    >                        ld       (SXX18+5),a
   7++C457                      ldCopyByte SXX12+4       ,SXX18+6           ; XX12+4 => XX18+6  Set XX18(8 6) = dot_nosev
   7++C457 3A 7E C0    >                        ld       a,(SXX12+4)
   7++C45A 32 6E C0    >                        ld       (SXX18+6),a
   8++C45D                      ldCopyByte SXX12+5       ,SXX18+8           ; XX12+5 => XX18+8
   8++C45D 3A 7F C0    >                        ld       a,(SXX12+5)
   8++C460 32 70 C0    >                        ld       (SXX18+8),a
   9++C463 C9                   ret
  10++C464
# file closed: ././Universe/Sun/CopySunXX12ScaledToSunXX18.asm
 443+ C464              ;                        include "./Variables/CopySunXX12toSunXX15.asm"
 444+ C464              ;                       include "./Variables/CopySunXX18toSunXX15.asm"
 445+ C464              ;                       include "./Variables/CopySunXX18ScaledToSunXX15.asm"
 446+ C464              ;                       include "./Variables/CopySunXX12ToScaled.asm"
 447+ C464              ;--------------------------------------------------------------------------------------------------------
 448+ C464              ;                        include "./Maths/Utilities/DotProductXX12SunXX15.asm"
 449+ C464              ;--------------------------------------------------------------------------------------------------------
 450+ C464
 451+ C464 DD 25        ScaleDownSXX15byIXH:    dec     ixh
 452+ C466 F8                                   ret     m
 453+ C467 21 74 C0                             ld      hl,SBnKXScaled
 454+ C46A CB 3E                                srl     (hl)                        ; SunXX15  \ xnormal lo/2 \ LL93+3 \ counter X
 455+ C46C 23                                   inc     hl                          ; looking at SunXX15 x sign now
 456+ C46D 23                                   inc     hl                          ; looking at SunXX15 y Lo now
 457+ C46E CB 3E                                srl     (hl)                        ; SunXX15+2    \ ynormal lo/2
 458+ C470 23                                   inc     hl                          ; looking at SunXX15 y sign now
 459+ C471 23                                   inc     hl                          ; looking at SunXX15 z Lo now
 460+ C472 CB 3E                                srl     (hl)
 461+ C474 C3 64 C4                             jp      ScaleDownSXX15byIXH
 462+ C477 C9                                   ret
 463+ C478
 464+ C478 21 68 C0     DivideSXX18By2:         ld      hl,SBnKDrawCam0xLo
 465+ C47B CB 3E                                srl     (hl)                        ; XX18  \ xnormal lo/2 \ LL93+3 \ counter X
 466+ C47D 23                                   inc     hl                          ; looking at XX18 x sign now
 467+ C47E 23                                   inc     hl                          ; looking at XX18 y Lo now
 468+ C47F CB 3E                                srl     (hl)                        ; XX18+2    \ ynormal lo/2
 469+ C481 23                                   inc     hl                          ; looking at XX18 y sign now
 470+ C482 23                                   inc     hl                          ; looking at XX18 z Lo now
 471+ C483 CB 3E                                srl     (hl)
 472+ C485 C9                                   ret
 473+ C486
 474+ C486              ; ......................................................                                                         ;;;
 475+ C486
 476+ C486
 477+ C486
 478+ C486
 479+ C486              ; Pitch and roll are 2 phases
 480+ C486              ; 1 - we apply our pitch and roll to the ship position
 481+ C486              ;       x -> x + alpha * (y - alpha * x)
 482+ C486              ;       y -> y - alpha * x - beta * z
 483+ C486              ;       z -> z + beta * (y - alpha * x - beta * z)
 484+ C486              ; which can be simplified as:
 485+ C486              ;       1. K2 = y - alpha * x
 486+ C486              ;       2. z = z + beta * K2
 487+ C486              ;       3. y = K2 - beta * z
 488+ C486              ;       4. x = x + alpha * y
 489+ C486              ; 2 - we apply our patch and roll to the ship orientation
 490+ C486              ;      Roll calculations:
 491+ C486              ;
 492+ C486              ;        nosev_y = nosev_y - alpha * nosev_x_hi
 493+ C486              ;        nosev_x = nosev_x + alpha * nosev_y_hi
 494+ C486              ;      Pitch calculations:
 495+ C486              ;
 496+ C486              ;        nosev_y = nosev_y - beta * nosev_z_hi
 497+ C486              ;        nosev_z = nosev_z + beta * nosev_y_hi
 498+ C486
 499+ C486
 500+ C486                          INCLUDE "./Universe/Sun/SunApplyMyRollAndPitch.asm"
# file opened: ././Universe/Sun/SunApplyMyRollAndPitch.asm
   1++C486
   2++C486              ; Full version
   3++C486              ; 1. K2 = y - alpha * x
   4++C486              ; 2. z = z + beta * K2
   5++C486              ; 3. y = K2 - beta * z
   6++C486              ; 4. x = x + alpha * y
   7++C486
   8++C486
   9++C486
  10++C486              ; SunrollWork holds Alpha intermidate results
  11++C486 00 00 00     SunRollResult:          DS 3                    ; equivalent of K
  12++C489              SunRollResultp1         equ SunRollResult
  13++C489              SunRollResultp2         equ SunRollResult+1
  14++C489              SunRollResultp3         equ SunRollResult+2
  15++C489 00           SunRollResultp4         DB 0
  16++C48A              ;SunRollResult2:         DS 3                    ; do we need this? TODO
  17++C48A 00 00 00     SunZResult:             DS 3
  18++C48D              ;  1. K2 = y - alpha * x
  19++C48D              ;  2. z = z + beta * K2
  20++C48D              ;  3. y = K2 - beta * z
  21++C48D              ;  4. x = x + alpha * y
  22++C48D              ;.... or
  23++C48D              ;  2. z = z + (beta * (y - alpha * x))
  24++C48D              ;  3. y = (y - alpha * x) - (beta * z)
  25++C48D              ;  4. x = x + (alpha * y)
  26++C48D
  27++C48D
  28++C48D              ;----------------------------------------------------------------------------------------------------------------------------------
  29++C48D              ; Sun version of pitch and roll is a 24 bit calculation 1 bit sign + 23 bit value
  30++C48D 3A 71 83     SunApplyMyRollAndPitch: ld      a,(ALPHA)                   ; no roll or pitch, no calc needed
  31++C490 21 63 83                             ld      hl,BETA
  32++C493 B6                                   or      (hl)
  33++C494 E6 7F                                and     SignMask8Bit
  34++C496 CA 32 C5                             jp      z,.NoRotation
  35++C499              .CalcZ:                 ;break
  36++C499 3A 71 83                             ld      a,(ALPHA)                   ; get roll magnitude
  37++C49C FE 00                                cp      0
  38++C49E 20 0B                                jr      nz,.ApplyAlpha
  39++C4A0 ED 5B 14 C0  .NoAlpha:               ld      de,(SBnKyhi)                ; here we have no roll so
  40++C4A4 3A 13 C0                             ld      a,(SBnKylo)                 ; store untouched in SunRollResult
  41++C4A7 6F                                   ld      l,a                         ; .
  42++C4A8 C3 C7 C4                             jp      .SaveResult1                ; .
  43++C4AB EE 80        .ApplyAlpha:            xor     SignOnly8Bit                ; d = -alpha (Q value)
  44++C4AD 57                                   ld      d,a                         ;
  45++C4AE 3A 10 C0                             ld      a,(SBnKxlo)                 ; HLE = x sgn, hi, lo
  46++C4B1 5F                                   ld      e,a                         ; .
  47++C4B2 2A 11 C0                             ld      hl,(SBnKxhi)                ; .
  48++C4B5 CD 26 94                             call    mulHLEbyDSigned             ; DELC = x * -alpha, so DEL = X * -alpha / 256 where d = sign byte
  49++C4B8 7A           .SkipAlphaMultiply:     ld      a,d
  50++C4B9 32 89 C4                             ld      (SunRollResultp4),a         ; save sign from result, ELC holds actual result
  51++C4BC 3A 13 C0     .CalcYPlusDEL:          ld      a,(SBnKylo)                 ; BCH = Y sgn, hi, lo, we loose the C from result
  52++C4BF 67                                   ld      h,a                         ; .
  53++C4C0 ED 4B 14 C0                          ld      bc,(SBnKyhi)                ; .
  54++C4C4 CD B9 91                             call    AddBCHtoDELsigned           ; DEL = Y - ( X *  alpha /256) (which is K2)
  55++C4C7 7A           .SaveResult1:           ld      a,d                         ; SunPitchWork = AHL = DEL
  56++C4C8 63                                   ld      h,e                         ;
  57++C4C9 32 88 C4     .CopyResultTo2:         ld      (SunRollResult+2),a         ; .
  58++C4CC 22 86 C4                             ld      (SunRollResult) ,hl         ; .
  59++C4CF 5D           .CalcY:                 ld      e,l                         ; HLE = result (K2)
  60++C4D0 6C                                   ld      l,h                         ; .
  61++C4D1 67                                   ld      h,a                         ; .
  62++C4D2 3A 63 83                             ld      a,(BETA)                    ; get pitch
  63++C4D5 57                                   ld      d,a                         ; now D = BETA
  64++C4D6 CD 26 94                             call    mulHLEbyDSigned             ; DELC = (y - alpha * x /256 ) * Beta or K2 * beta
  65++C4D9 ED 4B 17 C0                          ld      bc,(SBnKzhi)                ; BCH = z
  66++C4DD 3A 16 C0                             ld      a,(SBnKzlo)                 ; .
  67++C4E0 67                                   ld      h,a                         ; .
  68++C4E1 CD B9 91                             call    AddBCHtoDELsigned           ; DEL = z + ((y - alpha * x /256 ) * Beta) /256
  69++C4E4 ED 53 8B C4  .SaveZResult:           ld      (SunZResult+1),de           ; We now have a z result which we save
  70++C4E8 ED 53 17 C0                          ld      (SBnKzhi),de                ; .
  71++C4EC 7D                                   ld      a,l                         ; .
  72++C4ED 32 8A C4                             ld      (SunZResult),a              ; .
  73++C4F0 32 16 C0                             ld      (SBnKzlo),a                 ; .
  74++C4F3 EB           .CalcMinusBetaMulZ:     ex      de,hl                       ; HLE = DEL = z post calculation
  75++C4F4                                      ; not needed bugld      e,l                         ; .
  76++C4F4 3A 63 83                             ld      a,(BETA)                    ; d = - BETA
  77++C4F7 EE 80                                xor     SignOnly8Bit                ; .
  78++C4F9 57                                   ld      d,a                         ; .
  79++C4FA CD 26 94                             call    mulHLEbyDSigned             ; DELC = z * - BETA
  80++C4FD ED 4B 87 C4                          ld      bc, (SunRollResult+1)       ; BCH = (y - alpha * x) (or K2)
  81++C501 3A 86 C4                             ld      a,(SunRollResult)           ; .
  82++C504 67                                   ld      h,a                         ; .
  83++C505 CD B9 91                             call    AddBCHtoDELsigned           ; DEL = (y - alpha * x) - (Z * BETA) (K2+ (Z * -BETA)
  84++C508 ED 53 14 C0                          ld      (SBnKyhi),de                ; y = (y - alpha * x) - (Z * BETA)
  85++C50C 7D                                   ld      a,l                         ; .
  86++C50D 32 13 C0                             ld      (SBnKylo),a                 ; .
  87++C510 EB           .CalcX:                 ex      de,hl                       ; HLE = DEL = Y
  88++C511 5D                                   ld      e,l                         ; .
  89++C512 3A 71 83                             ld      a,(ALPHA)                   ; D = alpha
  90++C515 FE 00                                cp      0                           ; if alpha is 0 then don't update x
  91++C517 CA 32 C5                             jp      z,.NoRotation
  92++C51A 57                                   ld      d,a                         ; .
  93++C51B CD 26 94                             call    mulHLEbyDSigned             ; DELC = Y * alpha
  94++C51E ED 4B 11 C0                          ld      bc,(SBnKxhi)                ; BCH = x
  95++C522 3A 10 C0                             ld      a,(SBnKxlo)                 ; .
  96++C525 67                                   ld      h,a                         ; .
  97++C526 CD B9 91                             call    AddBCHtoDELsigned           ; DEL = x + (alpha * y /256 )
  98++C529 ED 53 11 C0                          ld      (SBnKxhi),de                ; x = x + (alpha * y /256 )
  99++C52D 7C                                   ld      a,h                         ; .
 100++C52E 32 10 C0                             ld      (SBnKxlo),a                 ; .
 101++C531 C9                                   ret
 102++C532 3A 57 84     .NoRotation:            ld      a,(DELTA)                   ; BCH = - Delta
 103++C535 FE 00                                cp      0
 104++C537 C8                                   ret     z
 105++C538 0E 00                                ld      c,0                         ;
 106++C53A 67                                   ld      h,a                         ;
 107++C53B 06 80                                ld      b,$80                       ;
 108++C53D ED 5B 17 C0                          ld      de,(SBnKzhi)                ; DEL = z position
 109++C541 3A 16 C0                             ld      a,(SBnKzlo)                 ; .
 110++C544 6F                                   ld      l,a                         ; .
 111++C545 CD B9 91                             call    AddBCHtoDELsigned           ; update speed
 112++C548 ED 53 17 C0                          ld      (SBnKzhi),DE                ; write back to zpos
 113++C54C 7D                                   ld      a,l
 114++C54D 32 16 C0                             ld      (SBnKzlo),a                ;
 115++C550 C9                                   ret
 116++C551
 117++C551              ;
 118++C551              ;SunApplyMyRollAndPitch: ld      a,(ALPHA)                   ; no roll or pitch, no calc needed
 119++C551              ;                        ld      hl,BETA
 120++C551              ;                        or      (hl)
 121++C551              ;                        and     SignMask8Bit
 122++C551              ;                        ret     z
 123++C551              ;.CalcZ:                 ;break
 124++C551              ;                        ld      a,(ALPHA)                   ; get roll magnitude
 125++C551              ;                        xor     SignOnly8Bit                ; get Q = -alpha
 126++C551              ;                        ld      d,a                         ; d reg represents Q (abount to roll)
 127++C551              ;                        ld      a,(SBnKxlo)                 ; HLE = x sgn, hi, lo
 128++C551              ;                        ld      e,a                         ;
 129++C551              ;                        ld      hl,(SBnKxhi)                ;
 130++C551              ;                        call    mulHLEbyDSigned             ; DELC = x * -alpha, so DEL = X * -alpha / 256
 131++C551              ;                        ld      a,d
 132++C551              ;                        ld      (SunRollResultp4),a         ; save D (I guess we need the sign?)
 133++C551              ;.CalcYPlusDEL:          ld      a,(SBnKylo)                 ; BCH = Y sgn, hi, lo
 134++C551              ;                        ld      h,a
 135++C551              ;                        ld      bc,(SBnKyhi)
 136++C551              ;                        call    AddBCHtoDELsigned           ; DEL = Y - ( X *  alpha /256)
 137++C551              ;.SaveResult1:           ld      a,l                         ; SunPitchWork = DEL
 138++C551              ;                        ;ld      (SunRollResult), a          ; SunPitchWork + 0 = L
 139++C551              ;                        ex      de,hl                       ; SunPitchWork + 1 = E
 140++C551              ;.CopyResultTo2:         ld      (SunRollResult+1),a         ; SunPitchWork + 2 = D
 141++C551              ;                        ld      (SunRollResult+1) ,hl       ; Copy K to K2 (y - alpha * x)
 142++C551              ;                        ;ld      (SunRollResult2+1),hl       ; also HLA = result
 143++C551              ;                        ld      a,(SunRollResult)           ; .
 144++C551              ;                        ;ld      (SunRollResult2),a          ; .
 145++C551              ;.CalcY:                 ld      e,a                         ; so now HLE = result
 146++C551              ;                        ld      a,(BETA)                    ; get pitch
 147++C551              ;                        ld      d,a                         ; now D = BETA
 148++C551              ;                        call    mulHLEbyDSigned             ; DELC = (y - alpha * x /256 ) * Beta
 149++C551              ;                        ld      bc,(SBnKzhi)                ; BCH = z
 150++C551              ;                        ld      a,(SBnKzlo)                 ;
 151++C551              ;                        ld      h,a                         ;
 152++C551              ;                        call    AddBCHtoDELsigned           ; DEL = z + ((y - alpha * x /256 ) * Beta) /256
 153++C551              ;.SaveZResult:           ld      (SunZResult+1),de           ; We now have a z result which we save
 154++C551              ;                        ld      (SBnKzhi),de                ; .
 155++C551              ;                        ld      a,l                         ; .
 156++C551              ;                        ld      (SunZResult),a              ; .
 157++C551              ;                        ld      (SBnKzlo),a                 ; .
 158++C551              ;.CalcMinusBetaMulZ:     ex      de,hl                       ; HLE = DEL = z post calculation
 159++C551              ;                        ld      e,l                         ;
 160++C551              ;                        ld      a,(BETA)                    ; d = - BETA
 161++C551              ;                        ld      d,a                         ;
 162++C551              ;                        xor     SignOnly8Bit                ;
 163++C551              ;                        call    mulHLEbyDSigned             ; DELC = z * - BETA
 164++C551              ;                        ld      bc, (SunRollResult+1)       ; BCH = (y - alpha * x) (or K2)
 165++C551              ;                        ld      a,(SunRollResult)           ;
 166++C551              ;                        ld      h,a                         ;
 167++C551              ;                        call    AddBCHtoDELsigned           ; DEL = (y - alpha * x) - (Z * BETA)
 168++C551              ;                        ld      (SBnKyhi),de                ; y = (y - alpha * x) - (Z * BETA)
 169++C551              ;                        ld      a,l                         ;
 170++C551              ;                        ld      (SBnKylo),a                 ;
 171++C551              ;.CalcX:                 ex      de,hl                       ; HLE = DEL = Y
 172++C551              ;                        ld      e,l                         ;
 173++C551              ;                        ld      a,(ALPHA)
 174++C551              ;                        ld      d,a                         ; D = alpha
 175++C551              ;                        call    mulHLEbyDSigned             ; DELC = Y * alpha
 176++C551              ;                        ld      bc,(SBnKxhi)                ; BCH = x
 177++C551              ;                        ld      a,(SBnKxlo)                 ;
 178++C551              ;                        ld      h,a                         ;
 179++C551              ;                        call    AddBCHtoDELsigned           ; DEL = x + (alpha * y /256 )
 180++C551              ;                        ld      (SBnKxhi),de                ; x = x + (alpha * y /256 )
 181++C551              ;                        ld      a,h                         ;
 182++C551              ;                        ld      (SBnKxlo),a                 ;
 183++C551              ;                        ret
 184++C551              ;
# file closed: ././Universe/Sun/SunApplyMyRollAndPitch.asm
 501+ C551              ;            INCLUDE "./Universe/SunApplyShipRollAndPitch.asm"
 502+ C551
 503+ C551 00           SunOnScreen             DB 0
 504+ C552 00 00        cLineArrayPtr            DW 0
 505+ C554 00           LineCount               DB 0
 506+ C555 00           RaggedSize              DB 0
 507+ C556 00           MinYOffset              DB 0
 508+ C557 00           MaxYOffSet              DB 0
 509+ C558 00 00        SunScrnX                DW  0       ; signed
 510+ C55A 00 00        SunScrnY                DW  0       ; signed
 511+ C55C 00           SunRadius               DB  0       ; unsigned
 512+ C55D              ; draw circle
 513+ C55D
 514+ C55D              ;
 515+ C55D              ;DIVD3B2 K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
 516+ C55D
 517+ C55D 00 00 00 00  SunVarK                 DS 4
 518+ C561 00 00 00     SunVarP                 DS 3
 519+ C564 00           SunVarQ                 DS 1
 520+ C565 00           SunVarR                 DS 1
 521+ C566 00           SunVarS                 DS 1
 522+ C567 00           SunVarT                 DS 1
 523+ C568
 524+ C568              ; Needs tuning for registers vs memroy
 525+ C568 22 61 C5     SunKEquAHLDivCDE:       ld      (SunVarP),hl
 526+ C56B 32 63 C5                             ld      (SunVarP+2),a
 527+ C56E ED 53 64 C5                          ld      (SunVarQ),de
 528+ C572 79                                   ld      a,c
 529+ C573 32 66 C5                             ld      (SunVarS),a
 530+ C576 3A 61 C5     SunDivD3B:              ld      a,(SunVarP)                 ; Ensure P is at least 1
 531+ C579 F6 01                                or      1
 532+ C57B 32 61 C5                             ld      (SunVarP),a
 533+ C57E 3A 63 C5                             ld      a,(SunVarP+2)               ; T = Sign xor Sign
 534+ C581 21 66 C5                             ld      hl,SunVarS
 535+ C584 AE                                   xor     (hl)
 536+ C585 E6 80                                and     SignOnly8Bit
 537+ C587 32 67 C5                             ld      (SunVarT),a
 538+ C58A 06 00                                ld      b,0                         ; b = y counter
 539+ C58C 3A 63 C5                             ld      a,(SunVarP+2)               ; a = abs high byte of p
 540+ C58F E6 7F                                and     SignMask8Bit                ; .
 541+ C591 2A 61 C5                             ld      hl,(SunVarP)                ; shift P left
 542+ C594              .SunDVL9:               JumpIfAGTENusng   64, .SunDV14      ; if high p > 64 then go to DV14
 542+ C594 FE 40       >                        cp     64
 542+ C596 D2 A3 C5    >                        jp		nc,.SunDV14
 543+ C599                                      ShiftHLLeft1                        ;
 543+ C599 CB 25       >			   sla l
 543+ C59B CB 14       >			   rl  h
 544+ C59D CB 17                                rl      a                           ;
 545+ C59F 04                                   inc     b                           ; increase shift count
 546+ C5A0 C3 94 C5                             jp      .SunDVL9
 547+ C5A3 22 61 C5     .SunDV14:               ld      (SunVarP),hl                ; save off var P
 548+ C5A6 32 63 C5                             ld      (SunVarP+2),a
 549+ C5A9 3A 66 C5                             ld      a,(SunVarS)                 ; a= ABS varS
 550+ C5AC E6 7F                                and     SignMask8Bit
 551+ C5AE 2A 64 C5                             ld      hl,(SunVarQ)                ; HL = vars Q & R
 552+ C5B1 05           .SunDVL6:               dec     b                           ; reduce b counter by 1
 553+ C5B2                                      ShiftHLLeft1                        ; varQRA  shift left
 553+ C5B2 CB 25       >			   sla l
 553+ C5B4 CB 14       >			   rl  h
 554+ C5B6 CB 17                                rl      a                           ;
 555+ C5B8 F2 B1 C5                             jp      p, .SunDVL6                 ; keep shifting until bit 7 of a is set
 556+ C5BB 22 64 C5                             ld      (SunVarQ),hl                ; save QR
 557+ C5BE 32 66 C5     .SunDV9:                ld      (SunVarS),a                 ; save S
 558+ C5C1                                      ;ld      a,h
 559+ C5C1                                      ;ld      (varQ),a
 560+ C5C1 4F                                   ld      c,a
 561+ C5C2 3A 63 C5                             ld      a,(SunVarP+2)
 562+ C5C5 C5                                   push    bc                          ; save shift counter in b
 563+ C5C6 CD 92 95                             call    DIV16Amul256dCUNDOC
 564+ C5C9                                      ;call    RequAmul256divQ
 565+ C5C9 79                                   ld      a, c
 566+ C5CA 32 5C 84                             ld      (varR),a
 567+ C5CD C1                                   pop     bc                          ; retrieve shift counter
 568+ C5CE 21 00 00                             ld      hl,0                        ; set K to 0
 569+ C5D1 22 5D C5                             ld      (SunVarK),hl                ; .
 570+ C5D4 22 5F C5                             ld      (SunVarK+2),hl              ; .
 571+ C5D7 CB 78                                bit     7,b                         ; is counter positive
 572+ C5D9 28 32                                jr      z,.SunDV12                  ; .
 573+ C5DB 3A 5C 84                             ld      a,(varR)                    ;
 574+ C5DE CB 27        .SunDVL8:               sla     a                           ; Shift K by 1 left
 575+ C5E0 21 5E C5                             ld      hl,SunVarK+1                ; .
 576+ C5E3 CB 16                                rl      (hl)                        ; .
 577+ C5E5 23                                   inc     hl                          ; .
 578+ C5E6 CB 16                                rl      (hl)                        ; .
 579+ C5E8 23                                   inc     hl                          ; .
 580+ C5E9 CB 16                                rl      (hl)                        ; .
 581+ C5EB 04                                   inc     b
 582+ C5EC 20 F0                                jr      nz,.SunDVL8                 ; loop until K is shifted
 583+ C5EE 32 5D C5                             ld      (SunVarK),a
 584+ C5F1 3A 60 C5                             ld      a,(SunVarK+3)
 585+ C5F4 21 67 C5                             ld      hl,SunVarT
 586+ C5F7 B6                                   or      (hl)
 587+ C5F8 32 60 C5                             ld      (SunVarK+3),a
 588+ C5FB C9                                   ret
 589+ C5FC 3A 5C 84     .SunDV13:               ld      a,(varR)                    ; when we get here, shift is zero
 590+ C5FF 32 5D C5                             ld      (SunVarK),a
 591+ C602 3A 60 C5                             ld      a,(SunVarK+3)
 592+ C605 21 67 C5                             ld      hl,SunVarT
 593+ C608 B6                                   or      (hl)
 594+ C609 32 60 C5                             ld      (SunVarK+3),a
 595+ C60C C9                                   ret
 596+ C60D 78           .SunDV12:               ld      a,b
 597+ C60E A7                                   and     a
 598+ C60F 28 EB                                jr      z,.SunDV13
 599+ C611 3A 5C 84                             ld      a,(varR)                    ; it probably is already R so need to test
 600+ C614 CB 2F        .SunDVL10:              sra     a                           ; Shift K by 1 left
 601+ C616 05                                   dec     b
 602+ C617 20 FB                                jr      nz,.SunDVL10
 603+ C619 32 5D C5                             ld      (SunVarK),a                 ; as original divide was onyl 8 bits K 1,2,3 don;t matter
 604+ C61C 3A 67 C5                             ld      a,(SunVarT)
 605+ C61F 32 60 C5                             ld      (SunVarK+3),a
 606+ C622 C9                                   ret
 607+ C623
 608+ C623
 609+ C623
 610+ C623              SunProcessVertex:       MACRO   vertlo, vertsgn
 611+ C623 ~            .SunProjectToEye:       ld      de,(SBnKzlo)                ; X Pos = X / Z
 612+ C623 ~                                    ld      a,(SBnKzsgn)                ; CDE = z
 613+ C623 ~                                    ld      c,a                         ;
 614+ C623 ~                                    ld      hl,(vertlo)                ; AHL = x
 615+ C623 ~                                    ld      a,(vertsgn)                ;
 616+ C623 ~                                    call    SunKEquAHLDivCDE            ; result in sunvarK to K + 3
 617+ C623 ~                                    ld      hl,(SunVarK)                ; result is in DEHL (high to low)
 618+ C623 ~                                    ld      de,(SunVarK+2)
 619+ C623 ~            .CheckPosOnScreenX:     ld      a,d                         ; a= abs highest byte (k+3)  or k+2
 620+ C623 ~                                    and     SignMask8Bit                ;
 621+ C623 ~                                    or      e                           ;
 622+ C623 ~                                    ret     nz                          ; off screen
 623+ C623 ~                                    ld      a,h                         ; a = k + 1 can do this as ABS
 624+ C623 ~                                    ReturnIfAGTEusng 4                  ; if > 1024 then return
 625+ C623 ~                                    ld      a,d                         ; get sign back
 626+ C623 ~                                    and     SignOnly8Bit                ; if positive then we are good
 627+ C623 ~                                    jr      z,.calculatedVert
 628+ C623 ~            .XIsNegative:           NegHL                               ; make 2's c as negative
 629+ C623 ~            .calculatedVert:
 630+ C623                                      ENDM
 631+ C623
 632+ C623
 633+ C623
 634+ C623                                 ; could probabyl set a variable say "varGood", default as 1 then set to 0 if we end up with a good calulation?? may not need it as we draw here
 635+ C623 CD 8D C4     SunUpdateAndRender:     call    SunApplyMyRollAndPitch
 636+ C626 3A 18 C0     .CheckDrawable:         ld      a,(SBnKzsgn)
 637+ C629 E6 80                                and     SignOnly8Bit
 638+ C62B C0                                   ret     nz
 639+ C62C              .CheckDist48:           ReturnIfAGTENusng 48                ; at a distance over 48 its too far away
 639+ C62C FE 30       >                        cp    48
 639+ C62E D0          >                        ret	 nc
 640+ C62F 21 17 C0                             ld      hl,SBnKzhi                  ; if the two high bytes are zero then its too close
 641+ C632 B6                                   or      (hl)
 642+ C633                                      ReturnIfAIsZero
 642+ C633 A7          >                        and     a
 642+ C634 C8          >                        ret     z
 643+ C635              .calculateX:            SunProcessVertex SBnKxlo, SBnKxsgn
 643+ C635 ED 5B 16 C0 >.SunProjectToEye:       ld      de,(SBnKzlo)                ; X Pos = X / Z
 643+ C639 3A 18 C0    >                        ld      a,(SBnKzsgn)                ; CDE = z
 643+ C63C 4F          >                        ld      c,a                         ;
 643+ C63D 2A 10 C0    >                        ld      hl,(SBnKxlo)                ; AHL = x
 643+ C640 3A 12 C0    >                        ld      a,(SBnKxsgn)                ;
 643+ C643 CD 68 C5    >                        call    SunKEquAHLDivCDE            ; result in sunvarK to K + 3
 643+ C646 2A 5D C5    >                        ld      hl,(SunVarK)                ; result is in DEHL (high to low)
 643+ C649 ED 5B 5F C5 >                        ld      de,(SunVarK+2)
 643+ C64D 7A          >.CheckPosOnScreenX:     ld      a,d                         ; a= abs highest byte (k+3)  or k+2
 643+ C64E E6 7F       >                        and     SignMask8Bit                ;
 643+ C650 B3          >                        or      e                           ;
 643+ C651 C0          >                        ret     nz                          ; off screen
 643+ C652 7C          >                        ld      a,h                         ; a = k + 1 can do this as ABS
 643+ C653             >                        ReturnIfAGTEusng 4                  ; if > 1024 then return
 643+ C653 FE 04       >                        cp    4
 643+ C655 D0          >                        ret	 nc
 643+ C656 7A          >                        ld      a,d                         ; get sign back
 643+ C657 E6 80       >                        and     SignOnly8Bit                ; if positive then we are good
 643+ C659 28 06       >                        jr      z,.calculatedVert
 643+ C65B             >.XIsNegative:           NegHL                               ; make 2's c as negative
 643+ C65B AF          >                    xor a
 643+ C65C 95          >                    sub l
 643+ C65D 6F          >                    ld l,a
 643+ C65E 9F          >                    sbc a,a
 643+ C65F 94          >                    sub h
 643+ C660 67          >                    ld h,a
 643+ C661             >.calculatedVert:
 644+ C661 3E 80        .calculatedX:           ld      a,ScreenCenterX
 645+ C663 CD 5D 91                             call    HL2cEquHLSgnPlusAusgn       ; correct to center of screen
 646+ C666 22 58 C5                             ld      (SunScrnX),hl               ; save projected X Position, 2's compliment
 647+ C669              .calculateY:            SunProcessVertex SBnKylo, SBnKysgn
 647+ C669 ED 5B 16 C0 >.SunProjectToEye:       ld      de,(SBnKzlo)                ; X Pos = X / Z
 647+ C66D 3A 18 C0    >                        ld      a,(SBnKzsgn)                ; CDE = z
 647+ C670 4F          >                        ld      c,a                         ;
 647+ C671 2A 13 C0    >                        ld      hl,(SBnKylo)                ; AHL = x
 647+ C674 3A 15 C0    >                        ld      a,(SBnKysgn)                ;
 647+ C677 CD 68 C5    >                        call    SunKEquAHLDivCDE            ; result in sunvarK to K + 3
 647+ C67A 2A 5D C5    >                        ld      hl,(SunVarK)                ; result is in DEHL (high to low)
 647+ C67D ED 5B 5F C5 >                        ld      de,(SunVarK+2)
 647+ C681 7A          >.CheckPosOnScreenX:     ld      a,d                         ; a= abs highest byte (k+3)  or k+2
 647+ C682 E6 7F       >                        and     SignMask8Bit                ;
 647+ C684 B3          >                        or      e                           ;
 647+ C685 C0          >                        ret     nz                          ; off screen
 647+ C686 7C          >                        ld      a,h                         ; a = k + 1 can do this as ABS
 647+ C687             >                        ReturnIfAGTEusng 4                  ; if > 1024 then return
 647+ C687 FE 04       >                        cp    4
 647+ C689 D0          >                        ret	 nc
 647+ C68A 7A          >                        ld      a,d                         ; get sign back
 647+ C68B E6 80       >                        and     SignOnly8Bit                ; if positive then we are good
 647+ C68D 28 06       >                        jr      z,.calculatedVert
 647+ C68F             >.XIsNegative:           NegHL                               ; make 2's c as negative
 647+ C68F AF          >                    xor a
 647+ C690 95          >                    sub l
 647+ C691 6F          >                    ld l,a
 647+ C692 9F          >                    sbc a,a
 647+ C693 94          >                    sub h
 647+ C694 67          >                    ld h,a
 647+ C695             >.calculatedVert:
 648+ C695 3E 60        .calculatedY:           ld      a,ScreenCenterY
 649+ C697 CD 5D 91                             call    HL2cEquHLSgnPlusAusgn       ; correct to center of screen
 650+ C69A 22 5A C5                             ld      (SunScrnY),hl               ; save projected Y Position, 2's compliment
 651+ C69D              ; .........................................................................................................................
 652+ C69D ED 5B 16 C0  .CalculateRadius:       ld      de,(SBnKzlo)
 653+ C6A1 3A 18 C0                             ld      a,(SBnKzsgn)
 654+ C6A4 4F                                   ld      c,a
 655+ C6A5 21 00 60                             ld      hl,$6000  ; was hl          ; planet radius at Z = 1 006000
 656+ C6A8 AF                                   xor     a
 657+ C6A9 CD F9 92                             call    Div24by24LeadSign           ; radius = AHL/CDE = 24576 / distance z
 658+ C6AC 7A                                   ld      a,d                         ; if high byte (d) = 0 then e contains radius
 659+ C6AD                                      JumpIfAIsZero  .SaveRadius
 659+ C6AD A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 659+ C6AE CA B3 C6    >                        jp	z, .SaveRadius
 660+ C6B1 1E F8        .MaxRadius:             ld      e,248                       ;set radius to 248 as maxed out
 661+ C6B3 7B           .SaveRadius:            ld      a,e
 662+ C6B4 32 5C C5                             ld      (SunRadius),a               ; save a copy of radius now for later
 663+ C6B7              ; .........................................................................................................................
 664+ C6B7 2A 58 C5     .CheckIfSunOnScreen:    ld      hl,(SunScrnX)               ; get x pixel position
 665+ C6BA FD 26 00                             ld      iyh,0                       ; iyh holds draw status, 0= OK
 666+ C6BD 16 00                                ld      d,0                         ; e still holds radius
 667+ C6BF 7C                                   ld      a,h
 668+ C6C0                                      JumpOnLeadSignSet   h,.CheckXNegative
 668+ C6C0 7C          >                        ld      a,h
 668+ C6C1 E6 80       >                        and     SignOnly8Bit
 668+ C6C3 C2 D9 C6    >                        jp      nz,.CheckXNegative
 669+ C6C6 7C           .CheckXPositive:        ld      a,h
 670+ C6C7                                      JumpIfAIsZero   .XOnScreen          ; if high byte of h is not zero its definitly on screen
 670+ C6C7 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 670+ C6C8 CA E2 C6    >                        jp	z, .XOnScreen
 671+ C6CB 16 00                                ld      d,0                         ; de = radius
 672+ C6CD                                      ClearCarryFlag
 672+ C6CD B7          >                        or a
 673+ C6CE ED 52                                sbc     hl,de
 674+ C6D0 FA E2 C6                             jp      m   ,.XOnScreen             ; if result was negative then it spans screen
 675+ C6D3 7C                                   ld      a,h
 676+ C6D4                                      JumpIfAIsZero   .XOnScreen          ; if high byte of h is not zero then its partially on screen at least
 676+ C6D4 A7          >                        and a   ; cp 0 - changed to and a for optimisation but affects other flags
 676+ C6D5 CA E2 C6    >                        jp	z, .XOnScreen
 677+ C6D8 C9                                   ret                                 ; None of the X coordinates are on screen
 678+ C6D9 16 00        .CheckXNegative:        ld      d,0                         ; de = radius
 679+ C6DB                                      ClearCarryFlag
 679+ C6DB B7          >                        or a
 680+ C6DC ED 5A                                adc     hl,de                       ; so we have hl - de
 681+ C6DE F2 E2 C6                             jp      p,.XOnScreen                ; if result was positive then it spans screen so we are good
 682+ C6E1 C9                                   ret                                 ; else x is totally off the left side of the screen
 683+ C6E2              ; .........................................................................................................................
 684+ C6E2 2A 5A C5     .XOnScreen:             ld      hl,(SunScrnY)               ; now Check Y coordinate
 685+ C6E5                                      JumpOnLeadSignSet   h,.CheckYNegative
 685+ C6E5 7C          >                        ld      a,h
 685+ C6E6 E6 80       >                        and     SignOnly8Bit
 685+ C6E8 C2 0A C7    >                        jp      nz,.CheckYNegative
 686+ C6EB 7C           .CheckYPositive:        ld      a,h
 687+ C6EC                                      JumpIfAIsNotZero   .PosYCheck2
 687+ C6EC FE 00       >                        cp	0
 687+ C6EE C2 F7 C6    >                        jp	nz,.PosYCheck2
 688+ C6F1 7D                                   ld      a,l
 689+ C6F2 E6 80                                and     %10000000
 690+ C6F4 CA 13 C7                             jp      z,.YOnScreen                ; at least 1 row is on screen as > 128
 691+ C6F7 16 00        .PosYCheck2:            ld      d,0                         ; de = radius
 692+ C6F9                                      ClearCarryFlag
 692+ C6F9 B7          >                        or a
 693+ C6FA ED 52                                sbc     hl,de
 694+ C6FC FA 13 C7                             jp      m,.YOnScreen                ; so if its -ve then it spans screen
 695+ C6FF 7C                                   ld      a,h                         ; if h > 0 then off screen so did not span
 696+ C700                                      ReturnIfANotZero                    ; .
 696+ C700 A7          >                        and     a
 696+ C701 C0          >                        ret     nz
 697+ C702 7D                                   ld      a,l                         ; if l > 128 then off screen so did not span
 698+ C703 E6 80                                and     %10000000                   ; .
 699+ C705                                      ReturnIfANotZero                    ; .
 699+ C705 A7          >                        and     a
 699+ C706 C0          >                        ret     nz
 700+ C707 C3 13 C7                             jp      .YOnScreen                  ; so Y at least spans
 701+ C70A 16 00        .CheckYNegative:        ld      d,0                         ; de = radius
 702+ C70C                                      ClearCarryFlag
 702+ C70C B7          >                        or a
 703+ C70D ED 5A                                adc     hl,de                       ; so we have hl - de
 704+ C70F F2 13 C7                             jp      p,.YOnScreen                ; if result was positive then it spans screen so we are good
 705+ C712 C9                                   ret                                 ; else never gets above 0 so return
 706+ C713              ; .........................................................................................................................
 707+ C713 21 9F C0     .YOnScreen:             ld      hl,SBnKLineArray            ; we load start and end as 0
 708+ C716 11 00 01                             ld		de, SunLineArraySize        ; just if we get a 0,0 genuine we will not plot it
 709+ C719 3E 00                                ld		a,0
 710+ C71B CD 5A 80                             call	memfill_dma
 711+ C71E              ; .........................................................................................................................
 712+ C71E 11 00 00     .SetRaggedEdgeMax:      ld      de,0
 713+ C721 3A 5C C5                             ld      a,(SunRadius)               ; get readius
 714+ C724 FE 60                                cp      96                          ; if > 96 then roll carry flag into e
 715+ C726                                      FlipCarryFlag
 715+ C726 3F          >                        ccf
 716+ C727 CB 13                                rl      e                           ; if > 40 then roll carry flag into e
 717+ C729 FE 28                                cp      40
 718+ C72B                                      FlipCarryFlag
 718+ C72B 3F          >                        ccf
 719+ C72C CB 13                                rl      e
 720+ C72E FE 10                                cp      16                          ; if > 16 then roll carry flag into e
 721+ C730                                      FlipCarryFlag
 721+ C730 3F          >                        ccf
 722+ C731 CB 13                                rl     e
 723+ C733 7B                                   ld      a,e                         ; a = ragged size from %00000111 to %00000000
 724+ C734 32 55 C5                             ld      (RaggedSize),a
 725+ C737              ; .........................................................................................................................
 726+ C737 21 9F C0     .SkipSetK:              ld      hl,SBnKLineArray            ; prep line array details ready for filling
 727+ C73A 22 9F C1                             ld      (LineArrayPtr),hl
 728+ C73D AF                                   xor     a
 729+ C73E 32 54 C5                             ld      (LineCount),a
 730+ C741 16 00                                ld      d,0
 731+ C743              ; .........................................................................................................................
 732+ C743 2A 5A C5     .GetMinY:               ld      hl,(SunScrnY)               ; now calculate start Y position
 733+ C746 3A 5C C5                             ld      a,(SunRadius)
 734+ C749 5F                                   ld      e,a
 735+ C74A 57                                   ld      d,a
 736+ C74B                                      ClearCarryFlag
 736+ C74B B7          >                        or a
 737+ C74C ED 52                                sbc     hl,de
 738+ C74E F2 54 C7                             jp      p,.DoneMinY
 739+ C751 21 00 00                             ld      hl,0                        ; if its negative then we start with 0 as it can only go up screen after radius
 740+ C754              .DoneMinY:              ReturnIfRegNotZero h                ; if h > 0 then off the screen
 740+ C754 7C          >                        ld      a, h
 740+ C755 A7          >                        and     a
 740+ C756 C0          >                        ret     nz
 741+ C757 7D                                   ld      a,l                         ; check if l > 127
 742+ C758 E6 80                                and     SignOnly8Bit                ; .
 743+ C75A C0                                   ret     nz                          ; if bit is set then > 128
 744+ C75B 7D           .SetMinY:               ld      a,l
 745+ C75C 32 56 C5                             ld      (MinYOffset),a              ; so now we have Y top of screen
 746+ C75F 2A 5A C5     .GetMaxY:               ld      hl,(SunScrnY)               ; get hl = Y + radius, note if we got here then this can never be a negative result but can go from -ve hl to +ve result
 747+ C762 3A 5C C5                             ld      a,(SunRadius)               ; hl = hl + radius
 748+ C765 16 00                                ld      d,0                         ; .
 749+ C767 5F                                   ld      e,a                         ; .
 750+ C768                                      ClearCarryFlag                      ; .
 750+ C768 B7          >                        or a
 751+ C769 ED 5A                                adc     hl,de                       ; .
 752+ C76B 7C                                   ld      a,h
 753+ C76C A7                                   and     a
 754+ C76D 28 06                                jr      z,.YHiOK
 755+ C76F 21 7F 00     .YHiGTE127:             ld      hl,127
 756+ C772 C3 7E C7                             jp      .SetMaxY
 757+ C775 7D           .YHiOK:                 ld      a,l                         ; clamp at 127
 758+ C776 E6 80                                and     SignOnly8Bit                ; .
 759+ C778 CA 7E C7                             jp      z,.SetMaxY
 760+ C77B 21 7F 00                             ld      hl,127
 761+ C77E 7D           .SetMaxY                ld      a,l
 762+ C77F 32 57 C5                             ld      (MaxYOffSet),a              ; so now we have min and max Y coordinates and SunScrnX & Y holds center
 763+ C782 CD 89 C7                             call    SunDrawCircle
 764+ C785 CD B9 C1                             call    SunDraw
 765+ C788 C9                                   ret
 766+ C789                                      ; b8 04 00 02 00 00 60 01 00 gives a 0.5 so we have the cal wrong as its +-1 so should be * result of divide by 128
 767+ C789              ;.. Now we caluclate the circle of the star
 768+ C789              ;.. its from MinY down the screen to MaxY center ProjX,ProjY.
 769+ C789              ;.. We can use the circle draw logic gtom Bressenham's algorithm
 770+ C789              ; so now there are the following conditions to consider
 771+ C789              ; y min = 0   y center is negative radius <= ABS (Y center)             => Don't draw
 772+ C789              ; y min = 0   y center is negative radius > ABS (Y center)+1            => Draw bottom half only
 773+ C789              ; y max = 127 y center is > 127    radius <= y center - 127             => Don't draw
 774+ C789              ; y max = 127 y center is > 127    radius > y center - 127              => Draw top half only
 775+ C789              ; y min >= 0  y center > y min     we don't need to worry about radius  => Draw both halves
 776+ C789              ; x center + radius < 0                                                 => Don't draw
 777+ C789              ; x center - radius > 255                                               => Don't draw
 778+ C789              ; we won't consider x more here as the driver is the y coordinate but we will check if x is vaiable
 779+ C789              ; x point = max (x point, 0)   on left
 780+ C789              ; x point = min (x point, 255) on right
 781+ C789
 782+ C789              SetIYPlusOffset:        MACRO   reg
 783+ C789 ~                                    push    hl,,iy                          ; save hl, then hl = iy
 784+ C789 ~                                    pop     hl                              ;
 785+ C789 ~                                    ld      a,reg
 786+ C789 ~                                    add     hl,a
 787+ C789 ~                                    add     hl,a
 788+ C789 ~                                    push    hl
 789+ C789 ~                                    pop     iy
 790+ C789 ~                                    pop     hl
 791+ C789                                      ENDM
 792+ C789
 793+ C789              SetIYMinusOffset:       MACRO   reg
 794+ C789 ~                                    push    de,,hl,,iy                      ; save hl, then hl = iy
 795+ C789 ~                                    pop     hl                              ;
 796+ C789 ~                                    ld      a,reg
 797+ C789 ~                                    add     a,a
 798+ C789 ~                                    ld      e,a
 799+ C789 ~                                    ld      d,0
 800+ C789 ~                                    ClearCarryFlag
 801+ C789 ~                                    sbc     hl,de
 802+ C789 ~                                    push    hl
 803+ C789 ~                                    pop     iy
 804+ C789 ~                                    pop     de,,hl
 805+ C789                                      ENDM
 806+ C789
 807+ C789
 808+ C789 3A 5C C5     SunDrawCircle:          ld      a,(SunRadius)
 809+ C78C              .CheckRadius:           ReturnIfAIsZero                         ; elimiate zero or single pixel
 809+ C78C A7          >                        and     a
 809+ C78D C8          >                        ret     z
 810+ C78E                                      JumpIfAEqNusng  1, SunCircleSinglePixel
 810+ C78E FE 01       >                        cp     1
 810+ C790 CA D0 C8    >                        jp      z,SunCircleSinglePixel
 811+ C793                                     ; JumpIfAGTENusng 127, SunFullScreen      ; if its covering whole then just make it yellow
 812+ C793              ; already done .MakeCentreX2C:         MemSignedTo2C SunScrnX                   ; convert 16 bit signed to 2's compliment
 813+ C793              ; already done .MakeCentreY2C:         MemSignedTo2C SunScrnY                   ; .
 814+ C793 2A 5A C5     .BoundsCheck            ld      hl,(SunScrnY)
 815+ C796 E5                                   push    hl
 816+ C797 3A 5C C5                             ld      a,(SunRadius)
 817+ C79A ED 31                                add     hl,a
 818+ C79C CB 7C                                bit     7,h
 819+ C79E C0                                   ret     nz                              ; if Y + radius is negative then off the screen
 820+ C79F E1                                   pop     hl
 821+ C7A0 16 00                                ld      d,0
 822+ C7A2 5F                                   ld      e,a
 823+ C7A3                                      ClearCarryFlag
 823+ C7A3 B7          >                        or a
 824+ C7A4 ED 52                                sbc     hl,de
 825+ C7A6 7C                                   ld      a,h
 826+ C7A7                                      ReturnIfAGTENusng  1                     ; really shoudl be signed TODO
 826+ C7A7 FE 01       >                        cp    1
 826+ C7A9 D0          >                        ret	 nc
 827+ C7AA
 828+ C7AA 2A 58 C5                             ld      hl,(SunScrnX)
 829+ C7AD E5                                   push    hl
 830+ C7AE 3A 5C C5                             ld      a,(SunRadius)
 831+ C7B1 ED 31                                add     hl,a
 832+ C7B3 CB 7C                                bit     7,h
 833+ C7B5 C0                                   ret     nz                              ; if Y + radius is negative then off the screen
 834+ C7B6 E1                                   pop     hl
 835+ C7B7 16 00                                ld      d,0
 836+ C7B9 5F                                   ld      e,a
 837+ C7BA                                      ClearCarryFlag
 837+ C7BA B7          >                        or a
 838+ C7BB ED 52                                sbc     hl,de
 839+ C7BD 7C                                   ld      a,h
 840+ C7BE
 841+ C7BE                                      ReturnIfAGTENusng 1                      ; really shoudl be signed TODO
 841+ C7BE FE 01       >                        cp    1
 841+ C7C0 D0          >                        ret	 nc
 842+ C7C1
 843+ C7C1                                      ; ** BNOTE Ptuichj abnd roll has a bug as piitch increases z axis value
 844+ C7C1              .PrepCircleData:       ; ld      ixl,0
 845+ C7C1                                     ; ld		(.Plot1+1),bc			        ; save origin into DE reg in code
 846+ C7C1 3A 5C C5                            ld      a,(SunRadius)
 847+ C7C4 DD 67                                ld		ixh,a							; ixh = radius
 848+ C7C6
 849+ C7C6
 850+ C7C6 DD 2E 00                             ld		ixl,0						    ; ixl = delta (y)
 851+ C7C9 26 00        .calcd:	                ld		h,0                             ; de = radius * 2
 852+ C7CB 6F                                   ld		l,a                             ; .
 853+ C7CC 29                                   add		hl,hl							; .
 854+ C7CD EB                                   ex		de,hl							; .
 855+ C7CE 21 03 00                             ld		hl,3                            ; hl = 3 - (r * 2)
 856+ C7D1 A7                                   and		a                               ; .
 857+ C7D2 ED 52                                sbc		hl,de							; .
 858+ C7D4 44                                   ld		b,h                             ; bc = 3 - (r * 2) : d = 3 - 2r
 859+ C7D5 4D                                   ld		c,l								; .
 860+ C7D6 21 01 00     .calcdelta:             ld		hl,1                            ; set hl to 1
 861+ C7D9 16 00                                ld		d,0                             ; de = ixl
 862+ C7DB DD 5D                                ld		e,ixl                           ;
 863+ C7DD                                      ClearCarryFlag                          ;
 863+ C7DD B7          >                        or a
 864+ C7DE ED 52                                sbc		hl,de                           ; hl = 1 - ixl
 865+ C7E0 11 01 00     .Setde1:                ld		de,1                            ; del = 1
 866+ C7E3 DD 7C        .CircleLoop:            ld		a,ixh                           ; if x = y then exit
 867+ C7E5 DD BD                                cp		ixl                             ;
 868+ C7E7 D8                                   ret		c                               ;
 869+ C7E8 D9           .ProcessLoop:	        exx                                     ; save out registers
 870+ C7E9              ; Process CY+Y CX+X & CY+Y CX-X..................................
 871+ C7E9 2A 5A C5     .Plot1:                 ld      hl, (SunScrnY)
 872+ C7EC DD 7C        .Get1YRow:              ld      a,ixh
 873+ C7EE ED 31                                add     hl,a                            ; Check to see if CY+Y (note is add hl ,a usginedf only??)
 874+ C7F0              .Check1YRowOnScreen:    CheckRowHLOnScreen .NoTopPixelPair
 874+ C7F0 7C          >                        ld      a,h                             ; is h byte set, i.e > 256 or < 0
 874+ C7F1 A7          >                        and     a                               ; .
 874+ C7F2 20 26       >                        jr      nz,.NoTopPixelPair                   ; h <> 0 so fails (covers <0 and > 255
 874+ C7F4 7D          >                        ld      a,l                             ; l bit 7 0?
 874+ C7F5 E6 80       >                        and     Bit7Only                        ; covers l > 127 (screen draw area is 0 to 192 / 3 * 2 (128)
 874+ C7F7 20 21       >                        jr      nz,.NoTopPixelPair                   ;
 875+ C7F9              .Write1YCoord:          SetIYPlusOffset ixh                     ; IY = IY + ixh
 875+ C7F9 E5 FD E5    >                        push    hl,,iy                          ; save hl, then hl = iy
 875+ C7FC E1          >                        pop     hl                              ;
 875+ C7FD DD 7C       >                        ld      a,ixh
 875+ C7FF ED 31       >                        add     hl,a
 875+ C801 ED 31       >                        add     hl,a
 875+ C803 E5          >                        push    hl
 875+ C804 FD E1       >                        pop     iy
 875+ C806 E1          >                        pop     hl
 876+ C807                                      IYEquRowN l                             ; IY = SBnkLineArray + (2 * l) - set up iy as target address
 876+ C807 7D          >                        ld      a,l
 876+ C808 21 9F C0    >                        ld      hl,SBnKLineArray
 876+ C80B ED 31       >                        add     hl,a
 876+ C80D ED 31       >                        add     hl,a
 876+ C80F E5          >                        push    hl
 876+ C810 FD E1       >                        pop     iy
 877+ C812 DD 7D                                ld      a,ixl
 878+ C814 CD E7 C8                             call    ProcessXRowA
 879+ C817 C3 1A C8                             jp      .Plot2
 880+ C81A              .NoTopPixelPair:        ;break
 881+ C81A              ; Process CY-Y CX+X & CY-Y CX-X..................................
 882+ C81A 2A 5A C5     .Plot2:                 ld      hl, (SunScrnY)
 883+ C81D 16 00        .Get2YRow:              ld      d,0
 884+ C81F DD 5C                                ld      e,ixh
 885+ C821                                      ClearCarryFlag
 885+ C821 B7          >                        or a
 886+ C822 ED 52                                sbc     hl,de
 887+ C824              .Check2YRowOnScreen:    CheckRowHLOnScreen .NoBottomPixelPair
 887+ C824 7C          >                        ld      a,h                             ; is h byte set, i.e > 256 or < 0
 887+ C825 A7          >                        and     a                               ; .
 887+ C826 20 2B       >                        jr      nz,.NoBottomPixelPair                   ; h <> 0 so fails (covers <0 and > 255
 887+ C828 7D          >                        ld      a,l                             ; l bit 7 0?
 887+ C829 E6 80       >                        and     Bit7Only                        ; covers l > 127 (screen draw area is 0 to 192 / 3 * 2 (128)
 887+ C82B 20 26       >                        jr      nz,.NoBottomPixelPair                   ;
 888+ C82D                                      SetIYMinusOffset ixh
 888+ C82D D5 E5 FD E5 >                        push    de,,hl,,iy                      ; save hl, then hl = iy
 888+ C831 E1          >                        pop     hl                              ;
 888+ C832 DD 7C       >                        ld      a,ixh
 888+ C834 87          >                        add     a,a
 888+ C835 5F          >                        ld      e,a
 888+ C836 16 00       >                        ld      d,0
 888+ C838             >                        ClearCarryFlag
 888+ C838 B7          >                        or a
 888+ C839 ED 52       >                        sbc     hl,de
 888+ C83B E5          >                        push    hl
 888+ C83C FD E1       >                        pop     iy
 888+ C83E E1 D1       >                        pop     de,,hl
 889+ C840              .Write2YCoord:          IYEquRowN l                             ; set up iy as target address
 889+ C840 7D          >                        ld      a,l
 889+ C841 21 9F C0    >                        ld      hl,SBnKLineArray
 889+ C844 ED 31       >                        add     hl,a
 889+ C846 ED 31       >                        add     hl,a
 889+ C848 E5          >                        push    hl
 889+ C849 FD E1       >                        pop     iy
 890+ C84B DD 7D                                ld      a,ixl
 891+ C84D CD E7 C8                             call    ProcessXRowA
 892+ C850 C3 53 C8                             jp      .Plot3
 893+ C853              .NoBottomPixelPair:     ;break
 894+ C853              ; Process CY+X CX+Y & CY+X CX-Y..................................
 895+ C853 2A 5A C5     .Plot3:                 ld      hl, (SunScrnY)
 896+ C856 DD 7D        .Get3YRow:              ld      a,ixl
 897+ C858 ED 31                                add     hl,a                            ; Check to see if CY+Y
 898+ C85A              .Check3YRowOnScreen:    CheckRowHLOnScreen .NoTop3PixelPair
 898+ C85A 7C          >                        ld      a,h                             ; is h byte set, i.e > 256 or < 0
 898+ C85B A7          >                        and     a                               ; .
 898+ C85C 20 26       >                        jr      nz,.NoTop3PixelPair                   ; h <> 0 so fails (covers <0 and > 255
 898+ C85E 7D          >                        ld      a,l                             ; l bit 7 0?
 898+ C85F E6 80       >                        and     Bit7Only                        ; covers l > 127 (screen draw area is 0 to 192 / 3 * 2 (128)
 898+ C861 20 21       >                        jr      nz,.NoTop3PixelPair                   ;
 899+ C863                                      SetIYPlusOffset ixl
 899+ C863 E5 FD E5    >                        push    hl,,iy                          ; save hl, then hl = iy
 899+ C866 E1          >                        pop     hl                              ;
 899+ C867 DD 7D       >                        ld      a,ixl
 899+ C869 ED 31       >                        add     hl,a
 899+ C86B ED 31       >                        add     hl,a
 899+ C86D E5          >                        push    hl
 899+ C86E FD E1       >                        pop     iy
 899+ C870 E1          >                        pop     hl
 900+ C871              .Write3YCoord:          IYEquRowN l                             ; set up iy as target address
 900+ C871 7D          >                        ld      a,l
 900+ C872 21 9F C0    >                        ld      hl,SBnKLineArray
 900+ C875 ED 31       >                        add     hl,a
 900+ C877 ED 31       >                        add     hl,a
 900+ C879 E5          >                        push    hl
 900+ C87A FD E1       >                        pop     iy
 901+ C87C DD 7C                                ld      a,ixh
 902+ C87E CD E7 C8                             call    ProcessXRowA
 903+ C881 C3 84 C8                             jp      .Plot4
 904+ C884              .NoTop3PixelPair:       ;break
 905+ C884              ; Process CY-X CX+Y & CY-X CX-Y..................................
 906+ C884 2A 5A C5     .Plot4:                 ld      hl, (SunScrnY)
 907+ C887 16 00        .Get4YRow:              ld      d,0
 908+ C889 DD 5D                                ld      e,ixl
 909+ C88B                                      ClearCarryFlag
 909+ C88B B7          >                        or a
 910+ C88C ED 52                                sbc     hl,de
 911+ C88E              .Check4YRowOnScreen:    CheckRowHLOnScreen .NoBottom4PixelPair
 911+ C88E 7C          >                        ld      a,h                             ; is h byte set, i.e > 256 or < 0
 911+ C88F A7          >                        and     a                               ; .
 911+ C890 20 28       >                        jr      nz,.NoBottom4PixelPair                   ; h <> 0 so fails (covers <0 and > 255
 911+ C892 7D          >                        ld      a,l                             ; l bit 7 0?
 911+ C893 E6 80       >                        and     Bit7Only                        ; covers l > 127 (screen draw area is 0 to 192 / 3 * 2 (128)
 911+ C895 20 23       >                        jr      nz,.NoBottom4PixelPair                   ;
 912+ C897                                      SetIYMinusOffset ixl
 912+ C897 D5 E5 FD E5 >                        push    de,,hl,,iy                      ; save hl, then hl = iy
 912+ C89B E1          >                        pop     hl                              ;
 912+ C89C DD 7D       >                        ld      a,ixl
 912+ C89E 87          >                        add     a,a
 912+ C89F 5F          >                        ld      e,a
 912+ C8A0 16 00       >                        ld      d,0
 912+ C8A2             >                        ClearCarryFlag
 912+ C8A2 B7          >                        or a
 912+ C8A3 ED 52       >                        sbc     hl,de
 912+ C8A5 E5          >                        push    hl
 912+ C8A6 FD E1       >                        pop     iy
 912+ C8A8 E1 D1       >                        pop     de,,hl
 913+ C8AA              .Write4YCoord:          IYEquRowN l                             ; set up iy as target address
 913+ C8AA 7D          >                        ld      a,l
 913+ C8AB 21 9F C0    >                        ld      hl,SBnKLineArray
 913+ C8AE ED 31       >                        add     hl,a
 913+ C8B0 ED 31       >                        add     hl,a
 913+ C8B2 E5          >                        push    hl
 913+ C8B3 FD E1       >                        pop     iy
 914+ C8B5 DD 7C                                ld      a,ixh
 915+ C8B7 CD E7 C8                             call    ProcessXRowA
 916+ C8BA              .NoBottom4PixelPair:
 917+ C8BA              ; Completed one iteration........................................
 918+ C8BA D9                                   exx
 919+ C8BB CB 7C        .IncrementCircle:	    bit     7,h				; Check for Hl<=0
 920+ C8BD 28 03                                jr z,   .draw_circle_1
 921+ C8BF 19                                   add hl,de			; Delta=Delta+D1
 922+ C8C0 18 05                                jr      .draw_circle_2		;
 923+ C8C2 09           .draw_circle_1:		    add     hl,bc			; Delta=Delta+D2
 924+ C8C3 03                                   inc     bc
 925+ C8C4 03                                   inc     bc				; D2=D2+2
 926+ C8C5 DD 25                                dec     ixh				; Y=Y-1
 927+ C8C7 03           .draw_circle_2:		    inc bc				    ; D2=D2+2
 928+ C8C8 03                                   inc bc
 929+ C8C9 13                                   inc de				    ; D1=D1+2
 930+ C8CA 13                                   inc de
 931+ C8CB DD 2C                                inc ixl				    ; X=X+1
 932+ C8CD C3 E3 C7                             jp      .CircleLoop
 933+ C8D0 2A 58 C5     SunCircleSinglePixel:     ld      hl,(SunScrnX)
 934+ C8D3 7C                                   ld      a,h
 935+ C8D4 A7                                   and     a
 936+ C8D5 C0                                   ret     nz                  ; if the high byte is set then no pixel
 937+ C8D6 4D                                   ld      c,l
 938+ C8D7 2A 5A C5                             ld      hl,(SunScrnY)
 939+ C8DA 7C                                   ld      a,h
 940+ C8DB A7                                   and     a
 941+ C8DC C0                                   ret     nz                  ; if the high byte is set then no pixel
 942+ C8DD 7D                                   ld      a,l
 943+ C8DE CB 7F                                bit     7,a
 944+ C8E0 C0                                   ret     nz                  ; if l > 127 then no pixel
 945+ C8E1 47                                   ld      b,a
 946+ C8E2 7B                                   ld		a,e
 947+ C8E3 CD 43 E1                             call	l2_plot_pixel_y_test
 948+ C8E6 C9                                   ret
 949+ C8E7
 950+ C8E7              ProcessXRowA:           ;break
 951+ C8E7 2A 58 C5                             ld      hl,(SunScrnX)                    ; get X Center
 952+ C8EA F5                                   push    af                              ; save A (curent offset +/- value
 953+ C8EB ED 31                                add     hl,a                            ; Hl = HL + offset
 954+ C8ED 7C                                   ld      a,h                             ; is HL negative?, if so then set C to 0
 955+ C8EE CB 7F                                bit     7,a                             ;
 956+ C8F0 20 14                                jr      nz,.XCoordNegative              ; We can have this for non X + Radius i.e. the equater
 957+ C8F2 A7                                   and     a                               ; if H <> 0? (why by here must be +ve), set c to $FF
 958+ C8F3 20 16                                jr      nz,.XCoordMaxed                 ; .
 959+ C8F5 4D                                   ld      c,l                             ; else set c to l and do the -ve offset
 960+ C8F6 C5           .AddFuzz:               push    bc
 961+ C8F7 CD A2 88                             call    doRandom                        ; c = c - random AND ragged Size
 962+ C8FA C1                                   pop     bc
 963+ C8FB 21 55 C5                             ld      hl,RaggedSize                   ;
 964+ C8FE A6                                   and     (hl)                            ;
 965+ C8FF 81                                   add     c                               ;
 966+ C900 4F                                   ld      c,a                             ;
 967+ C901 38 08                                jr      c,.XCoordMaxed                  ; has fuzz caused a carry, if so > 255 to make 255
 968+ C903 C3 0D C9                             jp      .ProcessSubtract                ;
 969+ C906 0E 00        .XCoordNegative:        ld      c,0                             ; if it was negative then 0
 970+ C908 C3 0D C9                             jp      .ProcessSubtract
 971+ C90B 0E FF        .XCoordMaxed:           ld      c,255                           ; if it was +ve then 255
 972+ C90D F1           .ProcessSubtract:       pop     af                              ; get offset back
 973+ C90E 5F                                   ld      e,a                             ; but goes into DE as its a subtract
 974+ C90F 16 00                                ld      d,0
 975+ C911 2A 58 C5                             ld      hl,(SunScrnX)                    ; so do subtract
 976+ C914                                      ClearCarryFlag                          ; .
 976+ C914 B7          >                        or a
 977+ C915 ED 52                                sbc     hl,de                           ; .
 978+ C917 FA 34 C9                             jp      m,.XCoordLeftNegative           ; again test for min max
 979+ C91A E5 C5        .AddFuzzSubtract:       push    hl,,bc
 980+ C91C CD A2 88                             call    doRandom                        ; c = c - random AND ragged Size
 981+ C91F C1                                   pop     bc
 982+ C920 21 55 C5                             ld      hl,RaggedSize                   ;
 983+ C923 A6                                   and     (hl)                            ;
 984+ C924 5F                                   ld      e,a
 985+ C925 E1                                   pop     hl
 986+ C926 ED 52                                sbc     hl,de
 987+ C928 FA 34 C9                             jp      m,.XCoordLeftNegative           ; again test for min max
 988+ C92B 7C                                   ld      a,h
 989+ C92C A7                                   and     a
 990+ C92D C2 39 C9                             jp      nz,.XCordLeftMaxed
 991+ C930 45                                   ld      b,l
 992+ C931 C3 3B C9                             jp      .CompletedXCoords
 993+ C934 06 00        .XCoordLeftNegative:    ld      b,0
 994+ C936 C3 3B C9                             jp      .CompletedXCoords
 995+ C939 06 FF        .XCordLeftMaxed:        ld      b,255
 996+ C93B 78           .CompletedXCoords:      ld      a,b
 997+ C93C FD 77 00     .RowSaveIY1             ld      (iy+0),a                        ; iy holds current line array index
 998+ C93F 79                                   ld      a,c
 999+ C940 FD 77 01     .RowSaveIY3             ld      (iy+1),a
1000+ C943 C9                                   ret
1001+ C944
1002+ C944              ; .....................................................
1003+ C944              ; if the universe object is a planet or sun then do that instead
1004+ C944              ;;TODOProcessPlanet:          cp      129
1005+ C944              ;;TODO                        jr      nz, .ItsAPlanet
1006+ C944              ;;TODO.ItsAStar:              ld      a,(SBnKzsgn)
1007+ C944              ;;TODO                        cp      48                               ; if z > 48 (it must be positive to enter this routine)
1008+ C944
1009+ C944
1010+ C944              ; Square Root using tables
1011+ C944              ; DE = number to find
1012+ C944 21 64 CB     SunLookupSqrtDE:        ld      hl,SunSquareRootTable
1013+ C947 7A           .LookupCorseJump:       ld      a,d
1014+ C948 ED 31                                add     hl,a
1015+ C94A ED 31                                add     hl,a
1016+ C94C 7E                                   ld      a,(hl)
1017+ C94D 23                                   inc     hl
1018+ C94E 66                                   ld      h,(hl)
1019+ C94F 6F                                   ld      l,a
1020+ C950 7E           .FineSearchLoop:        ld      a,(hl)
1021+ C951                                      JumpIfAEqNusng  e, .FoundByte
1021+ C951 BB          >                        cp     e
1021+ C952 CA 5E C9    >                        jp      z,.FoundByte
1022+ C955                                      JumpIfAGTENusng e, .PreviousByte
1022+ C955 BB          >                        cp     e
1022+ C956 D2 61 C9    >                        jp		nc,.PreviousByte
1023+ C959 23           .NotFound:              inc     hl
1024+ C95A 23                                   inc     hl
1025+ C95B C3 50 C9                             jp      .FineSearchLoop
1026+ C95E 23           .FoundByte:             inc     hl
1027+ C95F 7E                                   ld      a,(hl)
1028+ C960 C9                                   ret
1029+ C961 2B           .PreviousByte:          dec     hl
1030+ C962 7E                                   ld      a,(hl)
1031+ C963 C9                                   ret
1032+ C964
1033+ C964 64 CB 76 CB  SunRootHighIndex:       DW SunSqr00,SunSqr01,SunSqr02,SunSqr03,SunSqr04,SunSqr05,SunSqr06,SunSqr07,SunSqr08,SunSqr09,SunSqr0A,SunSqr0B,SunSqr0C,SunSqr0D,SunSqr0E,SunSqr0F
1033+ C968 84 CB 90 CB
1033+ C96C 9A CB A2 CB
1033+ C970 AA CB B2 CB
1033+ C974 BA CB C0 CB
1033+ C978 C8 CB CE CB
1033+ C97C D2 CB D8 CB
1033+ C980 DE CB E4 CB
1034+ C984 EA CB F0 CB                          DW SunSqr10,SunSqr11,SunSqr12,SunSqr13,SunSqr14,SunSqr15,SunSqr16,SunSqr17,SunSqr18,SunSqr19,SunSqr1A,SunSqr1B,SunSqr1C,SunSqr1D,SunSqr1E,SunSqr1F
1034+ C988 F6 CB FC CB
1034+ C98C 02 CC 06 CC
1034+ C990 0A CC 0C CC
1034+ C994 10 CC 14 CC
1034+ C998 18 CC 1C CC
1034+ C99C 20 CC 24 CC
1034+ C9A0 26 CC 2A CC
1035+ C9A4 2C CC 30 CC                          DW SunSqr20,SunSqr21,SunSqr22,SunSqr23,SunSqr24,SunSqr25,SunSqr26,SunSqr27,SunSqr28,SunSqr29,SunSqr2A,SunSqr2B,SunSqr2C,SunSqr2D,SunSqr2E,SunSqr2F
1035+ C9A8 34 CC 36 CC
1035+ C9AC 38 CC 3C CC
1035+ C9B0 3E CC 40 CC
1035+ C9B4 44 CC 46 CC
1035+ C9B8 48 CC 4A CC
1035+ C9BC 4E CC 50 CC
1035+ C9C0 52 CC 56 CC
1036+ C9C4 5A CC 5E CC                          DW SunSqr30,SunSqr31,SunSqr32,SunSqr33,SunSqr34,SunSqr35,SunSqr36,SunSqr37,SunSqr38,SunSqr39,SunSqr3A,SunSqr3B,SunSqr3C,SunSqr3D,SunSqr3E,SunSqr3F
1036+ C9C8 62 CC 66 CC
1036+ C9CC 68 CC 6C CC
1036+ C9D0 70 CC 74 CC
1036+ C9D4 76 CC 7A CC
1036+ C9D8 7E CC 82 CC
1036+ C9DC 86 CC 8A CC
1036+ C9E0 8E CC 92 CC
1037+ C9E4 96 CC 9A CC                          DW SunSqr40,SunSqr41,SunSqr42,SunSqr43,SunSqr44,SunSqr45,SunSqr46,SunSqr47,SunSqr48,SunSqr49,SunSqr4A,SunSqr4B,SunSqr4C,SunSqr4D,SunSqr4E,SunSqr4F
1037+ C9E8 9E CC A2 CC
1037+ C9EC A6 CC AA CC
1037+ C9F0 AE CC B2 CC
1037+ C9F4 B6 CC BA CC
1037+ C9F8 BE CC C2 CC
1037+ C9FC C6 CC CA CC
1037+ CA00 CE CC D2 CC
1038+ CA04 D6 CC D8 CC                          DW SunSqr50,SunSqr51,SunSqr52,SunSqr53,SunSqr54,SunSqr55,SunSqr56,SunSqr57,SunSqr58,SunSqr59,SunSqr5A,SunSqr5B,SunSqr5C,SunSqr5D,SunSqr5E,SunSqr5F
1038+ CA08 DC CC E0 CC
1038+ CA0C E4 CC E8 CC
1038+ CA10 EC CC F0 CC
1038+ CA14 F4 CC F6 CC
1038+ CA18 FA CC FE CC
1038+ CA1C 02 CD 06 CD
1038+ CA20 0A CD 0C CD
1039+ CA24 10 CD 14 CD                          DW SunSqr60,SunSqr61,SunSqr62,SunSqr63,SunSqr64,SunSqr65,SunSqr66,SunSqr67,SunSqr68,SunSqr69,SunSqr6A,SunSqr6B,SunSqr6C,SunSqr6D,SunSqr6E,SunSqr6F
1039+ CA28 18 CD 1C CD
1039+ CA2C 1E CD 22 CD
1039+ CA30 26 CD 2A CD
1039+ CA34 2E CD 30 CD
1039+ CA38 34 CD 38 CD
1039+ CA3C 3C CD 3E CD
1039+ CA40 40 CD 44 CD
1040+ CA44 48 CD 4C CD                          DW SunSqr70,SunSqr71,SunSqr72,SunSqr73,SunSqr74,SunSqr75,SunSqr76,SunSqr77,SunSqr78,SunSqr79,SunSqr7A,SunSqr7B,SunSqr7C,SunSqr7D,SunSqr7E,SunSqr7F
1040+ CA48 50 CD 54 CD
1040+ CA4C 58 CD 5C CD
1040+ CA50 5E CD 62 CD
1040+ CA54 66 CD 68 CD
1040+ CA58 6C CD 70 CD
1040+ CA5C 74 CD 76 CD
1040+ CA60 7A CD 7E CD
1041+ CA64 82 CD 84 CD                          DW SunSqr80,SunSqr81,SunSqr82,SunSqr83,SunSqr84,SunSqr85,SunSqr86,SunSqr87,SunSqr88,SunSqr89,SunSqr8A,SunSqr8B,SunSqr8C,SunSqr8D,SunSqr8E,SunSqr8F
1041+ CA68 88 CD 8A CD
1041+ CA6C 8E CD 92 CD
1041+ CA70 96 CD 98 CD
1041+ CA74 9C CD A0 CD
1041+ CA78 A2 CD A6 CD
1041+ CA7C AA CD AC CD
1041+ CA80 B0 CD B4 CD
1042+ CA84 B6 CD BA CD                          DW SunSqr90,SunSqr91,SunSqr92,SunSqr93,SunSqr94,SunSqr95,SunSqr96,SunSqr97,SunSqr98,SunSqr99,SunSqr9A,SunSqr9B,SunSqr9C,SunSqr9D,SunSqr9E,SunSqr9F
1042+ CA88 BE CD C0 CD
1042+ CA8C C4 CD C8 CD
1042+ CA90 CA CD CE CD
1042+ CA94 D2 CD D4 CD
1042+ CA98 D8 CD DC CD
1042+ CA9C DE CD E2 CD
1042+ CAA0 E6 CD E8 CD
1043+ CAA4 EC CD F0 CD                          DW SunSqrA0,SunSqrA1,SunSqrA2,SunSqrA3,SunSqrA4,SunSqrA5,SunSqrA6,SunSqrA7,SunSqrA8,SunSqrA9,SunSqrAA,SunSqrAB,SunSqrAC,SunSqrAD,SunSqrAE,SunSqrAF
1043+ CAA8 F2 CD F6 CD
1043+ CAAC F8 CD FC CD
1043+ CAB0 00 CE 02 CE
1043+ CAB4 06 CE 08 CE
1043+ CAB8 0C CE 10 CE
1043+ CABC 12 CE 16 CE
1043+ CAC0 1A CE 1C CE
1044+ CAC4 1E CE 20 CE                          DW SunSqrB0,SunSqrB1,SunSqrB2,SunSqrB3,SunSqrB4,SunSqrB5,SunSqrB6,SunSqrB7,SunSqrB8,SunSqrB9,SunSqrBA,SunSqrBB,SunSqrBC,SunSqrBD,SunSqrBE,SunSqrBF
1044+ CAC8 24 CE 28 CE
1044+ CACC 2A CE 2E CE
1044+ CAD0 30 CE 34 CE
1044+ CAD4 38 CE 3C CE
1044+ CAD8 3E CE 40 CE
1044+ CADC 44 CE 46 CE
1044+ CAE0 4A CE 4E CE
1045+ CAE4 50 CE 54 CE                          DW SunSqrC0,SunSqrC1,SunSqrC2,SunSqrC3,SunSqrC4,SunSqrC5,SunSqrC6,SunSqrC7,SunSqrC8,SunSqrC9,SunSqrCA,SunSqrCB,SunSqrCC,SunSqrCD,SunSqrCE,SunSqrCF
1045+ CAE8 56 CE 5A CE
1045+ CAEC 5C CE 60 CE
1045+ CAF0 64 CE 66 CE
1045+ CAF4 68 CE 6A CE
1045+ CAF8 6E CE 70 CE
1045+ CAFC 74 CE 78 CE
1045+ CB00 7A CE 7E CE
1046+ CB04 80 CE 84 CE                          DW SunSqrD0,SunSqrD1,SunSqrD2,SunSqrD3,SunSqrD4,SunSqrD5,SunSqrD6,SunSqrD7,SunSqrD8,SunSqrD9,SunSqrDA,SunSqrDB,SunSqrDC,SunSqrDD,SunSqrDE,SunSqrDF
1046+ CB08 86 CE 8A CE
1046+ CB0C 8C CE 90 CE
1046+ CB10 94 CE 96 CE
1046+ CB14 9A CE 9C CE
1046+ CB18 A0 CE A2 CE
1046+ CB1C A6 CE A8 CE
1046+ CB20 AA CE AC CE
1047+ CB24 B0 CE B4 CE                          DW SunSqrE0,SunSqrE1,SunSqrE2,SunSqrE3,SunSqrE4,SunSqrE5,SunSqrE6,SunSqrE7,SunSqrE8,SunSqrE9,SunSqrEA,SunSqrEB,SunSqrEC,SunSqrED,SunSqrEE,SunSqrEF
1047+ CB28 B8 CE BC CE
1047+ CB2C C0 CE C4 CE
1047+ CB30 C6 CE CA CE
1047+ CB34 CE CE D2 CE
1047+ CB38 D4 CE D8 CE
1047+ CB3C DA CE DC CE
1047+ CB40 DE CE E2 CE
1048+ CB44 E4 CE E6 CE                          DW SunSqrF0,SunSqrF1,SunSqrF2,SunSqrF3,SunSqrF4,SunSqrF5,SunSqrF6,SunSqrF7,SunSqrF8,SunSqrF9,SunSqrFA,SunSqrFB,SunSqrFC,SunSqrFD,SunSqrFE,SunSqrFF
1048+ CB48 E8 CE EC CE
1048+ CB4C EE CE F2 CE
1048+ CB50 F4 CE F8 CE
1048+ CB54 FA CE FE CE
1048+ CB58 00 CF 04 CF
1048+ CB5C 06 CF 0A CF
1048+ CB60 0C CF 0E CF
1049+ CB64
1050+ CB64              SunSquareRootTable:
1051+ CB64 00 00        SunSqr00:               DB $00,   0
1052+ CB66 04 02                                DB $04,   2
1053+ CB68 10 04                                DB $10,   4
1054+ CB6A 24 06                                DB $24,   6
1055+ CB6C 40 08                                DB $40,   8
1056+ CB6E 64 0A                                DB $64,  10
1057+ CB70 90 0C                                DB $90,  12
1058+ CB72 C4 0E                                DB $C4,  14
1059+ CB74 FF 0F                                DB $FF,  15
1060+ CB76 00 10        SunSqr01:               DB $00,  16
1061+ CB78 21 11                                DB $21,  17
1062+ CB7A 44 12                                DB $44,  18
1063+ CB7C 69 13                                DB $69,  19
1064+ CB7E 90 14                                DB $90,  20
1065+ CB80 B9 15                                DB $B9,  21
1066+ CB82 FF 16                                DB $FF,  22
1067+ CB84 11 17        SunSqr02:               DB $11,  23
1068+ CB86 40 18                                DB $40,  24
1069+ CB88 71 19                                DB $71,  25
1070+ CB8A A4 1A                                DB $A4,  26
1071+ CB8C D9 1B                                DB $D9,  27
1072+ CB8E FF 1B                                DB $FF,  27
1073+ CB90 10 1C        SunSqr03:               DB $10,  28
1074+ CB92 49 1D                                DB $49,  29
1075+ CB94 84 1E                                DB $84,  30
1076+ CB96 C1 1F                                DB $C1,  31
1077+ CB98 FF 1F                                DB $FF,  31
1078+ CB9A 00 20        SunSqr04:               DB $00,  32
1079+ CB9C 41 21                                DB $41,  33
1080+ CB9E 84 22                                DB $84,  34
1081+ CBA0 FF 23                                DB $FF,  35
1082+ CBA2 10 24        SunSqr05:               DB $10,  36
1083+ CBA4 59 25                                DB $59,  37
1084+ CBA6 A4 26                                DB $A4,  38
1085+ CBA8 FF 27                                DB $FF,  39
1086+ CBAA 40 28        SunSqr06:               DB $40,  40
1087+ CBAC 91 29                                DB $91,  41
1088+ CBAE E4 2A                                DB $E4,  42
1089+ CBB0 FF 2A                                DB $FF,  42
1090+ CBB2 39 2B        SunSqr07:               DB $39,  43
1091+ CBB4 90 2C                                DB $90,  44
1092+ CBB6 E9 2D                                DB $E9,  45
1093+ CBB8 FF 2D                                DB $FF,  45
1094+ CBBA 44 2E        SunSqr08:               DB $44,  46
1095+ CBBC A1 2F                                DB $A1,  47
1096+ CBBE FF 2F                                DB $FF,  47
1097+ CBC0 00 30        SunSqr09:               DB $00,  48
1098+ CBC2 61 31                                DB $61,  49
1099+ CBC4 C4 32                                DB $C4,  50
1100+ CBC6 FF 32                                DB $FF,  50
1101+ CBC8 29 33        SunSqr0A:               DB $29,  51
1102+ CBCA 90 34                                DB $90,  52
1103+ CBCC FF 35                                DB $FF,  53
1104+ CBCE 64 36        SunSqr0B:               DB $64,  54
1105+ CBD0 FF 37                                DB $FF,  55
1106+ CBD2 40 38        SunSqr0C:               DB $40,  56
1107+ CBD4 B1 39                                DB $B1,  57
1108+ CBD6 FF 39                                DB $FF,  57
1109+ CBD8 24 3A        SunSqr0D:               DB $24,  58
1110+ CBDA 99 3B                                DB $99,  59
1111+ CBDC FF 3B                                DB $FF,  59
1112+ CBDE 10 3C        SunSqr0E:               DB $10,  60
1113+ CBE0 89 3D                                DB $89,  61
1114+ CBE2 FF 3D                                DB $FF,  61
1115+ CBE4 04 3E        SunSqr0F:               DB $04,  62
1116+ CBE6 81 3F                                DB $81,  63
1117+ CBE8 FF 3F                                DB $FF,  63
1118+ CBEA 00 40        SunSqr10:               DB $00,  64
1119+ CBEC 81 41                                DB $81,  65
1120+ CBEE FF 41                                DB $FF,  65
1121+ CBF0 04 42        SunSqr11:               DB $04,  66
1122+ CBF2 89 43                                DB $89,  67
1123+ CBF4 FF 43                                DB $FF,  67
1124+ CBF6 10 44        SunSqr12:               DB $10,  68
1125+ CBF8 99 45                                DB $99,  69
1126+ CBFA FF 45                                DB $FF,  69
1127+ CBFC 24 46        SunSqr13:               DB $24,  70
1128+ CBFE B1 47                                DB $B1,  71
1129+ CC00 FF 47                                DB $FF,  71
1130+ CC02 40 48        SunSqr14:               DB $40,  72
1131+ CC04 FF 49                                DB $FF,  73
1132+ CC06 64 4A        SunSqr15:               DB $64,  74
1133+ CC08 FF 4B                                DB $FF,  75
1134+ CC0A FF 4C        SunSqr16:               DB $FF,  76
1135+ CC0C C4 4D        SunSqr17:               DB $C4,  77
1136+ CC0E FF 4E                                DB $FF,  78
1137+ CC10 61 4F        SunSqr18:               DB $61,  79
1138+ CC12 FF 4F                                DB $FF,  79
1139+ CC14 00 50        SunSqr19:               DB $00,  80
1140+ CC16 FF 51                                DB $FF,  81
1141+ CC18 44 52        SunSqr1A:               DB $44,  82
1142+ CC1A FF 53                                DB $FF,  83
1143+ CC1C 90 54        SunSqr1B:               DB $90,  84
1144+ CC1E FF 54                                DB $FF,  84
1145+ CC20 39 55        SunSqr1C:               DB $39,  85
1146+ CC22 FF 56                                DB $FF,  86
1147+ CC24 FF 57        SunSqr1D:               DB $FF,  87
1148+ CC26 40 58        SunSqr1E:               DB $40,  88
1149+ CC28 FF 59                                DB $FF,  89
1150+ CC2A FF 5A        SunSqr1F:               DB $FF,  90
1151+ CC2C 59 5B        SunSqr20:               DB $59,  91
1152+ CC2E FF 5B                                DB $FF,  91
1153+ CC30 10 5C        SunSqr21:               DB $10,  92
1154+ CC32 FF 5D                                DB $FF,  93
1155+ CC34 FF 5E        SunSqr22:               DB $FF,  94
1156+ CC36 FF 5F        SunSqr23:               DB $FF,  95
1157+ CC38 00 60        SunSqr24:               DB $00,  96
1158+ CC3A FF 61                                DB $FF,  97
1159+ CC3C 84 62        SunSqr25:               DB $84,  98
1160+ CC3E 49 63        SunSqr26:               DB $49,  99
1161+ CC40 10 64        SunSqr27:               DB $10, 100
1162+ CC42 FF 65                                DB $FF, 101
1163+ CC44 FF 66        SunSqr28:               DB $FF, 102
1164+ CC46 FF 67        SunSqr29:               DB $FF, 103
1165+ CC48 FF 68        SunSqr2A:               DB $FF, 104
1166+ CC4A 11 69        SunSqr2B:               DB $11, 105
1167+ CC4C FF 6A                                DB $FF, 106
1168+ CC4E FF 6B        SunSqr2C:               DB $FF, 107
1169+ CC50 FF 6C        SunSqr2D:               DB $FF, 108
1170+ CC52 69 6D        SunSqr2E:               DB $69, 109
1171+ CC54 FF 6E                                DB $FF, 110
1172+ CC56 44 6E        SunSqr2F:               DB $44, 110
1173+ CC58 FF 6F                                DB $FF, 111
1174+ CC5A 21 6F        SunSqr30:               DB $21, 111
1175+ CC5C FF 70                                DB $FF, 112
1176+ CC5E 00 70        SunSqr31:               DB $00, 112
1177+ CC60 FF 71                                DB $FF, 113
1178+ CC62 C4 72        SunSqr32:               DB $C4, 114
1179+ CC64 FF 72                                DB $FF, 114
1180+ CC66 FF 73        SunSqr33:               DB $FF, 115
1181+ CC68 90 74        SunSqr34:               DB $90, 116
1182+ CC6A FF 75                                DB $FF, 117
1183+ CC6C 79 75        SunSqr35:               DB $79, 117
1184+ CC6E FF 76                                DB $FF, 118
1185+ CC70 64 76        SunSqr36:               DB $64, 118
1186+ CC72 64 77                                DB $64, 119
1187+ CC74 51 77        SunSqr37:               DB $51, 119
1188+ CC76 40 78        SunSqr38:               DB $40, 120
1189+ CC78 FF 79                                DB $FF, 121
1190+ CC7A 31 79        SunSqr39:               DB $31, 121
1191+ CC7C FF 7A                                DB $FF, 122
1192+ CC7E 24 7A        SunSqr3A:               DB $24, 122
1193+ CC80 FF 7B                                DB $FF, 123
1194+ CC82 19 7B        SunSqr3B:               DB $19, 123
1195+ CC84 FF 7C                                DB $FF, 124
1196+ CC86 10 7C        SunSqr3C:               DB $10, 124
1197+ CC88 FF 7D                                DB $FF, 125
1198+ CC8A 09 7D        SunSqr3D:               DB $09, 125
1199+ CC8C FF 7D                                DB $FF, 125
1200+ CC8E 04 7E        SunSqr3E:               DB $04, 126
1201+ CC90 FF 7E                                DB $FF, 126
1202+ CC92 01 7F        SunSqr3F:               DB $01, 127
1203+ CC94 FF 7F                                DB $FF, 127
1204+ CC96 00 80        SunSqr40:               DB $00, 128
1205+ CC98 FF 80                                DB $FF, 128
1206+ CC9A 01 81        SunSqr41:               DB $01, 129
1207+ CC9C FF 82                                DB $FF, 130
1208+ CC9E 04 82        SunSqr42:               DB $04, 130
1209+ CCA0 FF 83                                DB $FF, 131
1210+ CCA2 09 83        SunSqr43:               DB $09, 131
1211+ CCA4 FF 84                                DB $FF, 132
1212+ CCA6 10 84        SunSqr44:               DB $10, 132
1213+ CCA8 FF 85                                DB $FF, 133
1214+ CCAA 19 85        SunSqr45:               DB $19, 133
1215+ CCAC FF 86                                DB $FF, 134
1216+ CCAE 24 86        SunSqr46:               DB $24, 134
1217+ CCB0 FF 87                                DB $FF, 135
1218+ CCB2 31 87        SunSqr47:               DB $31, 135
1219+ CCB4 FF 88                                DB $FF, 136
1220+ CCB6 40 88        SunSqr48:               DB $40, 136
1221+ CCB8 FF 89                                DB $FF, 137
1222+ CCBA 51 89        SunSqr49:               DB $51, 137
1223+ CCBC FF 8A                                DB $FF, 138
1224+ CCBE 64 8A        SunSqr4A:               DB $64, 138
1225+ CCC0 FF 8A                                DB $FF, 138
1226+ CCC2 79 8B        SunSqr4B:               DB $79, 139
1227+ CCC4 FF 8B                                DB $FF, 139
1228+ CCC6 90 8C        SunSqr4C:               DB $90, 140
1229+ CCC8 FF 8C                                DB $FF, 140
1230+ CCCA A9 8D        SunSqr4D:               DB $A9, 141
1231+ CCCC FF 8D                                DB $FF, 141
1232+ CCCE C4 8E        SunSqr4E:               DB $C4, 142
1233+ CCD0 FF 8E                                DB $FF, 142
1234+ CCD2 E1 8F        SunSqr4F:               DB $E1, 143
1235+ CCD4 FF 8F                                DB $FF, 143
1236+ CCD6 FF 8F        SunSqr50:               DB $FF, 143
1237+ CCD8 00 90        SunSqr51:               DB $00, 144
1238+ CCDA FF 90                                DB $FF, 144
1239+ CCDC 21 91        SunSqr52:               DB $21, 145
1240+ CCDE FF 91                                DB $FF, 145
1241+ CCE0 44 92        SunSqr53:               DB $44, 146
1242+ CCE2 FF 92                                DB $FF, 146
1243+ CCE4 69 93        SunSqr54:               DB $69, 147
1244+ CCE6 FF 93                                DB $FF, 147
1245+ CCE8 90 94        SunSqr55:               DB $90, 148
1246+ CCEA FF 94                                DB $FF, 148
1247+ CCEC B9 95        SunSqr56:               DB $B9, 149
1248+ CCEE FF 95                                DB $FF, 149
1249+ CCF0 E4 96        SunSqr57:               DB $E4, 150
1250+ CCF2 FF 96                                DB $FF, 150
1251+ CCF4 FF 96        SunSqr58:               DB $FF, 150
1252+ CCF6 11 97        SunSqr59:               DB $11, 151
1253+ CCF8 FF 97                                DB $FF, 151
1254+ CCFA 40 98        SunSqr5A:               DB $40, 152
1255+ CCFC FF 98                                DB $FF, 152
1256+ CCFE 71 99        SunSqr5B:               DB $71, 153
1257+ CD00 FF 99                                DB $FF, 153
1258+ CD02 A4 9A        SunSqr5C:               DB $A4, 154
1259+ CD04 FF 9A                                DB $FF, 154
1260+ CD06 D9 9B        SunSqr5D:               DB $D9, 155
1261+ CD08 FF 9B                                DB $FF, 155
1262+ CD0A FF 9B        SunSqr5E:               DB $FF, 155
1263+ CD0C 10 9C        SunSqr5F:               DB $10, 156
1264+ CD0E FF 9C                                DB $FF, 156
1265+ CD10 49 9D        SunSqr60:               DB $49, 157
1266+ CD12 FF 9D                                DB $FF, 157
1267+ CD14 84 9E        SunSqr61:               DB $84, 158
1268+ CD16 FF 9E                                DB $FF, 158
1269+ CD18 C1 9F        SunSqr62:               DB $C1, 159
1270+ CD1A FF 9F                                DB $FF, 159
1271+ CD1C FF 9F        SunSqr63:               DB $FF, 159
1272+ CD1E 00 A0        SunSqr64:               DB $00, 160
1273+ CD20 FF A0                                DB $FF, 160
1274+ CD22 41 A1        SunSqr65:               DB $41, 161
1275+ CD24 FF A1                                DB $FF, 161
1276+ CD26 84 A2        SunSqr66:               DB $84, 162
1277+ CD28 FF A2                                DB $FF, 162
1278+ CD2A C9 A3        SunSqr67:               DB $C9, 163
1279+ CD2C FF A3                                DB $FF, 163
1280+ CD2E FF A3        SunSqr68:               DB $FF, 163
1281+ CD30 10 A4        SunSqr69:               DB $10, 164
1282+ CD32 FF A4                                DB $FF, 164
1283+ CD34 59 A5        SunSqr6A:               DB $59, 165
1284+ CD36 FF A5                                DB $FF, 165
1285+ CD38 A4 A6        SunSqr6B:               DB $A4, 166
1286+ CD3A FF A6                                DB $FF, 166
1287+ CD3C FF A7        SunSqr6C:               DB $FF, 167
1288+ CD3E FF A7        SunSqr6D:               DB $FF, 167
1289+ CD40 40 A8        SunSqr6E:               DB $40, 168
1290+ CD42 FF A8                                DB $FF, 168
1291+ CD44 91 A9        SunSqr6F:               DB $91, 169
1292+ CD46 FF A9                                DB $FF, 169
1293+ CD48 E4 AA        SunSqr70:               DB $E4, 170
1294+ CD4A FF AA                                DB $FF, 170
1295+ CD4C 00 AA        SunSqr71:               DB $00, 170
1296+ CD4E FF AA                                DB $FF, 170
1297+ CD50 39 AB        SunSqr72:               DB $39, 171
1298+ CD52 FF AB                                DB $FF, 171
1299+ CD54 90 AC        SunSqr73:               DB $90, 172
1300+ CD56 FF AC                                DB $FF, 172
1301+ CD58 E9 AD        SunSqr74:               DB $E9, 173
1302+ CD5A FF AD                                DB $FF, 173
1303+ CD5C FF AD        SunSqr75:               DB $FF, 173
1304+ CD5E 44 AE        SunSqr76:               DB $44, 174
1305+ CD60 FF AE                                DB $FF, 174
1306+ CD62 A1 AF        SunSqr77:               DB $A1, 175
1307+ CD64 FF AF                                DB $FF, 175
1308+ CD66 FF AF        SunSqr78:               DB $FF, 175
1309+ CD68 00 B0        SunSqr79:               DB $00, 176
1310+ CD6A FF B0                                DB $FF, 176
1311+ CD6C 61 B1        SunSqr7A:               DB $61, 177
1312+ CD6E FF B1                                DB $FF, 177
1313+ CD70 C4 B2        SunSqr7B:               DB $C4, 178
1314+ CD72 FF B2                                DB $FF, 178
1315+ CD74 FF B2        SunSqr7C:               DB $FF, 178
1316+ CD76 29 B3        SunSqr7D:               DB $29, 179
1317+ CD78 FF B3                                DB $FF, 179
1318+ CD7A 90 B4        SunSqr7E:               DB $90, 180
1319+ CD7C FF B4                                DB $FF, 180
1320+ CD7E F9 B5        SunSqr7F:               DB $F9, 181
1321+ CD80 FF B5                                DB $FF, 181
1322+ CD82 FF B5        SunSqr80:               DB $FF, 181
1323+ CD84 64 B6        SunSqr81:               DB $64, 182
1324+ CD86 FF B6                                DB $FF, 182
1325+ CD88 D1 B7        SunSqr82:               DB $D1, 183
1326+ CD8A FF B7        SunSqr83:               DB $FF, 183
1327+ CD8C FF B7                                DB $FF, 183
1328+ CD8E 40 B8        SunSqr84:               DB $40, 184
1329+ CD90 FF B8                                DB $FF, 184
1330+ CD92 B1 B9        SunSqr85:               DB $B1, 185
1331+ CD94 FF B9                                DB $FF, 185
1332+ CD96 FF B9        SunSqr86:               DB $FF, 185
1333+ CD98 24 BA        SunSqr87:               DB $24, 186
1334+ CD9A FF BA                                DB $FF, 186
1335+ CD9C 99 BB        SunSqr88:               DB $99, 187
1336+ CD9E FF BB                                DB $FF, 187
1337+ CDA0 FF BB        SunSqr89:               DB $FF, 187
1338+ CDA2 10 BC        SunSqr8A:               DB $10, 188
1339+ CDA4 FF BC                                DB $FF, 188
1340+ CDA6 89 BD        SunSqr8B:               DB $89, 189
1341+ CDA8 FF BD                                DB $FF, 189
1342+ CDAA FF BD        SunSqr8C:               DB $FF, 189
1343+ CDAC 04 BE        SunSqr8D:               DB $04, 190
1344+ CDAE FF BE                                DB $FF, 190
1345+ CDB0 81 BF        SunSqr8E:               DB $81, 191
1346+ CDB2 FF BF                                DB $FF, 191
1347+ CDB4 FF BF        SunSqr8F:               DB $FF, 191
1348+ CDB6 00 C0        SunSqr90:               DB $00, 192
1349+ CDB8 FF C0                                DB $FF, 192
1350+ CDBA 81 C1        SunSqr91:               DB $81, 193
1351+ CDBC FF C1                                DB $FF, 193
1352+ CDBE FF C1        SunSqr92:               DB $FF, 193
1353+ CDC0 04 C2        SunSqr93:               DB $04, 194
1354+ CDC2 FF C2                                DB $FF, 194
1355+ CDC4 89 C3        SunSqr94:               DB $89, 195
1356+ CDC6 FF C3                                DB $FF, 195
1357+ CDC8 FF C3        SunSqr95:               DB $FF, 195
1358+ CDCA 10 C4        SunSqr96:               DB $10, 196
1359+ CDCC FF C4                                DB $FF, 196
1360+ CDCE 99 C5        SunSqr97:               DB $99, 197
1361+ CDD0 FF C5                                DB $FF, 197
1362+ CDD2 FF C5        SunSqr98:               DB $FF, 197
1363+ CDD4 24 C6        SunSqr99:               DB $24, 198
1364+ CDD6 FF C6                                DB $FF, 198
1365+ CDD8 B1 C7        SunSqr9A:               DB $B1, 199
1366+ CDDA FF C7                                DB $FF, 199
1367+ CDDC FF C7        SunSqr9B:               DB $FF, 199
1368+ CDDE 40 C8        SunSqr9C:               DB $40, 200
1369+ CDE0 FF C8                                DB $FF, 200
1370+ CDE2 D1 C9        SunSqr9D:               DB $D1, 201
1371+ CDE4 FF C9                                DB $FF, 201
1372+ CDE6 FF C9        SunSqr9E:               DB $FF, 201
1373+ CDE8 64 CA        SunSqr9F:               DB $64, 202
1374+ CDEA FF CA                                DB $FF, 202
1375+ CDEC F9 CB        SunSqrA0:               DB $F9, 203
1376+ CDEE FF CB                                DB $FF, 203
1377+ CDF0 FF CB        SunSqrA1:               DB $FF, 203
1378+ CDF2 90 CC        SunSqrA2:               DB $90, 204
1379+ CDF4 FF CC                                DB $FF, 204
1380+ CDF6 FF CC        SunSqrA3:               DB $FF, 204
1381+ CDF8 29 CD        SunSqrA4:               DB $29, 205
1382+ CDFA FF CD                                DB $FF, 205
1383+ CDFC C4 CE        SunSqrA5:               DB $C4, 206
1384+ CDFE FF CE                                DB $FF, 206
1385+ CE00 FF CE        SunSqrA6:               DB $FF, 206
1386+ CE02 61 CF        SunSqrA7:               DB $61, 207
1387+ CE04 FF CF                                DB $FF, 207
1388+ CE06 FF CF        SunSqrA8:               DB $FF, 207
1389+ CE08 00 D0        SunSqrA9:               DB $00, 208
1390+ CE0A FF D0                                DB $FF, 208
1391+ CE0C A1 D1        SunSqrAA:               DB $A1, 209
1392+ CE0E FF D1                                DB $FF, 209
1393+ CE10 FF D1        SunSqrAB:               DB $FF, 209
1394+ CE12 44 D2        SunSqrAC:               DB $44, 210
1395+ CE14 FF D2                                DB $FF, 210
1396+ CE16 E9 D3        SunSqrAD:               DB $E9, 211
1397+ CE18 FF D3                                DB $FF, 211
1398+ CE1A FF D3        SunSqrAE:               DB $FF, 211
1399+ CE1C 90 D4        SunSqrAF:               DB $90, 212
1400+ CE1E FF D4        SunSqrB0:               DB $FF, 212
1401+ CE20 39 D5        SunSqrB1:               DB $39, 213
1402+ CE22 FF D5                                DB $FF, 213
1403+ CE24 E4 D6        SunSqrB2:               DB $E4, 214
1404+ CE26 FF D6                                DB $FF, 214
1405+ CE28 FF D6        SunSqrB3:               DB $FF, 214
1406+ CE2A 91 D7        SunSqrB4:               DB $91, 215
1407+ CE2C FF D7                                DB $FF, 215
1408+ CE2E FF D7        SunSqrB5:               DB $FF, 215
1409+ CE30 40 D8        SunSqrB6:               DB $40, 216
1410+ CE32 FF D8                                DB $FF, 216
1411+ CE34 F1 D9        SunSqrB7:               DB $F1, 217
1412+ CE36 FF D9                                DB $FF, 217
1413+ CE38 FF D9        SunSqrB8:               DB $FF, 217
1414+ CE3A FF D9                                DB $FF, 217
1415+ CE3C A4 DA        SunSqrB9:               DB $A4, 218
1416+ CE3E FF DA        SunSqrBA:               DB $FF, 218 ; we can reuse SunSeqrBA as  $FF for B9 terminator as well as they have the same target
1417+ CE40 59 DB        SunSqrBB:               DB $59, 219
1418+ CE42 FF DB                                DB $FF, 219
1419+ CE44 FF DB        SunSqrBC:               DB $FF, 219
1420+ CE46 10 DC        SunSqrBD:               DB $10, 220
1421+ CE48 FF DC                                DB $FF, 220
1422+ CE4A C9 DD        SunSqrBE:               DB $C9, 221
1423+ CE4C FF DD                                DB $FF, 221
1424+ CE4E FF DD        SunSqrBF:               DB $FF, 221
1425+ CE50 84 DE        SunSqrC0:               DB $84, 222
1426+ CE52 FF DE                                DB $FF, 222
1427+ CE54 FF DE        SunSqrC1:               DB $FF, 222
1428+ CE56 41 DF        SunSqrC2:               DB $41, 223
1429+ CE58 FF DF                                DB $FF, 223
1430+ CE5A FF DF        SunSqrC3:               DB $FF, 223
1431+ CE5C 00 E0        SunSqrC4:               DB $00, 224
1432+ CE5E FF E0                                DB $FF, 224
1433+ CE60 C1 E1        SunSqrC5:               DB $C1, 225
1434+ CE62 FF E1                                DB $FF, 225
1435+ CE64 FF E1        SunSqrC6:               DB $FF, 225
1436+ CE66 84 E2        SunSqrC7:               DB $84, 226
1437+ CE68 FF E2        SunSqrC8:               DB $FF, 226
1438+ CE6A 49 E3        SunSqrC9:               DB $49, 227
1439+ CE6C FF E3                                DB $FF, 227
1440+ CE6E FF E4        SunSqrCA:               DB $FF, 228
1441+ CE70 10 E4        SunSqrCB:               DB $10, 228
1442+ CE72 FF E4                                DB $FF, 228
1443+ CE74 D9 E5        SunSqrCC:               DB $D9, 229
1444+ CE76 FF E5                                DB $FF, 229
1445+ CE78 FF E5        SunSqrCD:               DB $FF, 229
1446+ CE7A A4 E6        SunSqrCE:               DB $A4, 230
1447+ CE7C FF E6                                DB $FF, 230
1448+ CE7E FF E6        SunSqrCF:               DB $FF, 230
1449+ CE80 71 E7        SunSqrD0:               DB $71, 231
1450+ CE82 FF E7                                DB $FF, 231
1451+ CE84 FF E7        SunSqrD1:               DB $FF, 231
1452+ CE86 40 E8        SunSqrD2:               DB $40, 232
1453+ CE88 FF E8                                DB $FF, 232
1454+ CE8A FF E8        SunSqrD3:               DB $FF, 232
1455+ CE8C 11 E9        SunSqrD4:               DB $11, 233
1456+ CE8E FF E9                                DB $FF, 233
1457+ CE90 E4 EA        SunSqrD5:               DB $E4, 234
1458+ CE92 FF EA                                DB $FF, 234
1459+ CE94 FF EA        SunSqrD6:               DB $FF, 234
1460+ CE96 B9 EB        SunSqrD7:               DB $B9, 235
1461+ CE98 FF EB                                DB $FF, 235
1462+ CE9A FF EB        SunSqrD8:               DB $FF, 235
1463+ CE9C 90 EC        SunSqrD9:               DB $90, 236
1464+ CE9E FF EC                                DB $FF, 236
1465+ CEA0 FF EC        SunSqrDA:               DB $FF, 236
1466+ CEA2 69 ED        SunSqrDB:               DB $69, 237
1467+ CEA4 FF ED                                DB $FF, 237
1468+ CEA6 FF ED        SunSqrDC:               DB $FF, 237
1469+ CEA8 44 EE        SunSqrDD:               DB $44, 238
1470+ CEAA FF EE        SunSqrDE:               DB $FF, 238
1471+ CEAC 21 EF        SunSqrDF:               DB $21, 239
1472+ CEAE FF EF                                DB $FF, 239
1473+ CEB0 00 F0        SunSqrE0:               DB $00, 240
1474+ CEB2 FF F0                                DB $FF, 240
1475+ CEB4 00 F0        SunSqrE1:               DB $00, 240
1476+ CEB6 FF F0                                DB $FF, 240
1477+ CEB8 E1 F1        SunSqrE2:               DB $E1, 241
1478+ CEBA FF F1                                DB $FF, 241
1479+ CEBC E1 F1        SunSqrE3:               DB $E1, 241
1480+ CEBE FF F1                                DB $FF, 241
1481+ CEC0 C4 F2        SunSqrE4:               DB $C4, 242
1482+ CEC2 FF F2                                DB $FF, 242
1483+ CEC4 FF F2        SunSqrE5:               DB $FF, 242
1484+ CEC6 A9 F3        SunSqrE6:               DB $A9, 243
1485+ CEC8 FF F3                                DB $FF, 243
1486+ CECA FF F3        SunSqrE7:               DB $FF, 243
1487+ CECC FF F3                                DB $FF, 243
1488+ CECE 90 F3        SunSqrE8:               DB $90, 243
1489+ CED0 FF F4                                DB $FF, 244
1490+ CED2 FF F4        SunSqrE9:               DB $FF, 244
1491+ CED4 79 F5        SunSqrEA:               DB $79, 245
1492+ CED6 FF F5                                DB $FF, 245
1493+ CED8 FF F5        SunSqrEB:               DB $FF, 245
1494+ CEDA 64 F6        SunSqrEC:               DB $64, 246
1495+ CEDC FF F6        SunSqrED:               DB $FF, 246
1496+ CEDE 51 F7        SunSqrEE:               DB $51, 247
1497+ CEE0 FF F7                                DB $FF, 247
1498+ CEE2 FF F7        SunSqrEF:               DB $FF, 247
1499+ CEE4 40 F8        SunSqrF0:               DB $40, 248
1500+ CEE6 FF F8        SunSqrF1:               DB $FF, 248
1501+ CEE8 31 F9        SunSqrF2:               DB $31, 249
1502+ CEEA FF F9                                DB $FF, 249
1503+ CEEC FF F9        SunSqrF3:               DB $FF, 249
1504+ CEEE 24 FA        SunSqrF4:               DB $24, 250
1505+ CEF0 FF FA                                DB $FF, 250
1506+ CEF2 FF FA        SunSqrF5:               DB $FF, 250
1507+ CEF4 19 FB        SunSqrF6:               DB $19, 251
1508+ CEF6 FF FB                                DB $FF, 251
1509+ CEF8 FF FB        SunSqrF7:               DB $FF, 251
1510+ CEFA 10 FC        SunSqrF8:               DB $10, 252
1511+ CEFC FF FC                                DB $FF, 252
1512+ CEFE FF FC        SunSqrF9:               DB $FF, 252
1513+ CF00 09 FD        SunSqrFA:               DB $09, 253
1514+ CF02 FF FD                                DB $FF, 253
1515+ CF04 FF FD        SunSqrFB:               DB $FF, 253
1516+ CF06 04 FE        SunSqrFC:               DB $04, 254
1517+ CF08 FF FE                                DB $FF, 254
1518+ CF0A FF FE        SunSqrFD:               DB $FF, 254
1519+ CF0C 01 FF        SunSqrFE:               DB $01, 255
1520+ CF0E FF FF        SunSqrFF:               DB $FF, 255
1521+ CF10
1522+ CF10
1523+ CF10
1524+ CF10              SunBankSize  EQU $ - StartOfSun
1525+ CF10
1526+ CF10
# file closed: ./Universe/Sun/sun_data.asm
 284  CF10
 285  CF10                  SAVENEX OPEN "TestSunRender.nex", $8000 , $7F00
 286  CF10                  SAVENEX CFG  0,0,0,1
 287  CF10                  SAVENEX AUTO
 288  CF10                  SAVENEX CLOSE
 289  CF10
# file closed: sunDrawTst.asm
